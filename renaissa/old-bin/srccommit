#!/usr/local/bin/perl
#############################################################################
## $Id$
## $Revision$
## $Date$
#############################################################################
use Getopt::Std;
use POSIX "tmpnam";
#############################################################################
$ENV{"SRCCOMMIT"} = "Running";
$CVSROOT = &get_repository();
$script  = $0;
$script  =~ s/^.*\///;
$usage = "Usage: $script [-h] [-m <message>]\n";
$admin = "rbuckley";
$version_file     = "VersionNum";
$version_file_asm = "VersionASM";
$user = $ENV{"LOGNAME"};
$user = $ENV{"USER"} if($user eq '');
$asm_version = 0;
$tagable = 0;
#############################################################################

getopts('hm:');
if ($opt_h == 1) {			# help
  die($usage);
}

#############################################################################
# Check for presence of the VersionNum file and create it if absent. If 
# adding on the trunk, don't have a minor version number. If adding on a
# branch, use keyword substitution to obtain the correct revision number for
# the minor version number.
#
system("cvs update $version_file 2> /dev/null");
$branch = get_branch();
$dir    = &get_directory();
if (! -e $version_file) {
  print("\nVersionNum not found, create in $dir (Y/n) :");
  
  if (&ask("ny","y")) {
    printf("Do you want an assembler version aswell (y/N) :");
    if (&ask("ny","n")) {
      $asm_version = 1;
    }

    if ($branch eq "TRUNK") {
      &create_file("",$asm_version);		# no minor version number
      system("cvs add $version_file");
      if ($asm_version) {
        system("cvs add $version_file_asm");
      }
    } else {
      &create_file('$'.'Revision:'.'$',$asm_version);	# need substitution
      system("cvs add -kv $version_file");
      if ($asm_version) {
        system("cvs add -kv $version_file_asm");
      }
    }
    system("cvs commit -m \"created by $script.\" $version_file");
    if ($asm_version) {
      system("cvs commit -m \"created by $script.\" $version_file_asm");
    }
    print("\n$script: $version_file file(s) created. You may need to modify ");
    print("your sources to make use of this file. Then re-run srccommit.\n");
    exit(0);
  } else {
    die("$script: aborted\n");
  }
}
#############################################################################

#############################################################################
# Find out about these sources. If working on the trunk, prompt for the major
# version number to be incremented. If on a branch, obtain the current revision
# and increment to find the next revision.
#
print("$script: investigating module....\n");

($file_added,$file_removed,$file_modified) = &nq_update();
$mod_major = &read_file($version_file);
$mod_date  = &get_date();
if (-e $version_file_asm) {
  $version_asm = 1;
}

print("Module version $mod_major is on branch $branch.\n");
if ($branch eq "TRUNK") {
  print("Increment major version number (Y/n) :");
  if (&ask("ny","y")) {
    $mod_major = &increment_major_version($mod_major);
    $tagable = 1;
   }
} else {
  $mod_minor = &get_revision($version_file);
  $tagable = 1;
}
#############################################################################

#############################################################################
# Obtain a change log entry from the user. Create a tag based on version 
# numbers that will be in force when the commit is performed.
#
if (defined($opt_m)) {
  $message = $opt_m."\n";
} else {
  $message = get_message("$mod_major, $mod_minor",$dir,$file_added,
  			$file_removed,$file_modified);
}
$message .= "\nVersion $mod_major";
$message .= ", $mod_minor" if ($mod_minor ne "");

if ($tagable) {
  $tag = $dir;
  $tag =~ s#^.*/(.*)$#$1#;
  $tag .= "-".$mod_major;
  $tag .= "-".$mod_minor if ($mod_minor ne "");
  $tag =~ s/[.]/_/g;
  $message .= ". Tagged as '$tag'\n";
} else {
  $message .= ". Not tagged\n";
}
#############################################################################

#############################################################################
print("$script: commiting files....\n");
if ($branch eq "TRUNK") {
  &write_file($mod_major,"",$mod_date,$version_asm);
} else {
  &write_file($mod_major,$mod_minor,$mod_date,$version_asm);
}
system("cvs","commit","-m",$message);
if ($? != 0) {
  die("$script: commit failed, bailing ...\n");
}
#############################################################################

#############################################################################
if ($tagable) {
  print("$script: tagging files....\n");
  system("cvs tag $tag");
}

#############################################################################
print("$script: complete.\n");
#############################################################################

#############################################################################
# Wrap things up neatly.
#
sub failed {
  die("$script: $_[0] failed: $!\n");
};

#############################################################################
# Find out the state of checked out bits by doing a cvs -nq update and parsing
# the output. Return the files serperated by ':' so we can parse them later.
#
sub nq_update {
  my $line, $added, $removed, $modified;
  
  open(PIPE,"cvs -nq update 2>&1 |") || failed("fork");
  while($line = <PIPE>) {
    if($line =~ /^A (.*)$/) { 			# Added locally
      if ($added ne "") {
        $added .= ":";
      }
      $added .= $1;
    } elsif($line =~ /^R (.*)$/) { 		# Removed locally
      if ($removed ne "") {
        $removed .= ":";
      }
      $removed .= $1;
    } elsif($line =~ /^M (.*)$/) { 		# Modified locally
      if ($modified ne "") {
        $modified .= ":";
      }
      $modified .= $1;
    } elsif($line =~ /^C (.*)$/) { 		# Conflict
      print("$1 contains conflicts, remove conflicts, update sources (to ");
      print("clear\nthe conflict) and try again.\n");
      die("$script: aborted\n");
    }
  }
  return ($added, $removed, $modified);
}

#############################################################################
# Sort out line formatting for inserting text in the editor. We want the text
# to wrap round nicely.
#
sub format_line {
  my ($prefix,$data,$length) = @_;
  my $line,$lines,$file,@files;

  $lines = "";
  $line = $prefix;  
  @files = split(":",$data);
  foreach $file (@files) {
    if (length($line.$file)>70) {
      $lines .= "$line\n";
      $line = "$prefix";
    }
    $line .= $file.", ";
  }
  $lines .= "$line\n";
  
  return $lines;
}

#############################################################################
# Get change log entry from user, either use the configured editor or prompt
# the user for successive lines of input.
#
sub get_message {
  my ($header,$dir,$added,$removed,$modified) = @_;
  my $tmpfile, $line, $message, $editor;
  
  $editor = $ENV{"EDITOR"};
  print("Enter change log (blank line to end), or hit enter to invoke $editor.\n");
  print("> ");
  $line = <STDIN>;
  chop($line);
  
  # Deal with using the configured editor.
  #
  if ($line eq "") {
editor_again:    
    $tmpfile = tmpnam();
    open(TMP,">$tmpfile") || failed("cannot open editor file $tmpfile");
    print TMP <<"EOB";

CVS: ----------------------------------------------------------------------
CVS: Enter Log.  Lines beginning with 'CVS:'  are removed automatically
CVS: 
CVS: Committing in $dir
CVS:
EOB
    if ($added ne "") {
      print(TMP "CVS: Files added :\n");
      print(TMP &format_line("CVS:    ",$added,72));
      print(TMP "CVS:\n");
    }
    if ($removed ne "") {
      print(TMP "CVS: Files removed :\n");
      print(TMP &format_line("CVS:    ",$removed,72));
      print(TMP "CVS:\n");
    }
    if ($modified ne "") {
      print(TMP "CVS: Files modified :\n");
      print(TMP &format_line("CVS:    ",$modified,72));
      print(TMP "CVS:\n");
    }
    print TMP <<"EOB";
CVS: Version $header
CVS: ----------------------------------------------------------------------
EOB
    close(TMP);
    system("$editor $tmpfile");
  
    open(TMP,"<$tmpfile") || failed("cannot open editor file $tmpfile");
    while ($line = <TMP>) {
      chop($line);
      if ($line !~ /^CVS:/) {
        if ($line ne "") {
          $message .= $line."\n";
        }
      }
    }
    close(TMP);
    unlink($tmpfile);
    if ($message eq "") {
      print("No change log entered, (A)bort or (r)etry :");
      if (&ask("ra","a")) {
        die("$script: aborted\n");
      } else {
        goto editor_again;
      }
    }
  } else {
    
    # Get user input directly.
    #     
    while ($line ne "") {
      $message .= $line."\n";
      print("> ");
      $line = <STDIN>;
      chop($line);
    }
  }
  return ($message);
}

#############################################################################
# Increment the major version number in the form "0.01" to obtain a value in
# the form "0.02". Prompt the user if the default is no good.
#
sub increment_major_version {
  my $version = $_[0];
  my $major;
  
  $version =~ s/(^\d*)[.](\d*)/$1$2/;
  $version += 1;
  $version = sprintf("%d.%02d",int($version/100),($version-int($version/100)*100));

input_again:
  print("Enter new version number (default $version) :");
  $major = <STDIN>;
  chop($major);
  if ($major =~ /[^0-9.]/) {
    print("'$version' is an invalid version number\n");
    goto input_again;
  }
  if ($major eq "") {
    return ($version);
  } else {
    return ($major);
  }
}

#############################################################################
# Obtain current date and return in the correct format for RISC OS modules.
#
sub get_date {
  my $now = localtime;
  my @parts;
  @parts = split(" ",$now);
  $date = sprintf("%02d %s %s",@parts[2], @parts[1], @parts[4]);
  return ($date);
}

#############################################################################
# Read the version number file to retreive the current major version number.
# will set $version_asm if "asm" is found in the right field.
#
sub read_file {
  my $file = $_[0];
  my $line,$major;
  
  # first line contains the interesting stuff
  open(FILE,"<$file") || &failed("cannot open $file");
  $line = <FILE>;
  close(FILE);
  
  chop($line);
  $line =~ m|^.*\((.*)\).*$|;			# extract the bits
  $major = $1;
  
  if ($major eq "") {
    die("$script: cannot find major version number, has the file been messed with ?\n");
  }
  
  return ($major);
}

#############################################################################
# Obtain the details to put into the first version number file.
#
sub create_file {
  my ($minor,$asm_version) = @_;
  my $major,$date;
  
  $date  = &get_date();
    
  # get the version number to use
  #
input_again:
  print("Enter the initial version number in form n.nn (default 0.01) :");
  $major = <STDIN>;
  chop($major);
  if ($major =~ /[^0-9.]/) {
    print("'$version' is an invalid version number\n");
    goto input_again;
  }
  if ($major eq "") {
    $major = "0.01";
  }
  &write_file($major,$minor,$date,$asm_version);
}

#############################################################################
# Write out the given details to the file and optionally an asm duplicate.
#
sub write_file {
  my ($major,$minor,$date,$asm) = @_;
  my $number = $major;

  $number = $number*100;

  open(FILE,">$version_file") || &failed("cannot open $version_num");
print FILE <<"EOB";
/* ($major)
 *
 * This file is automatically maintained by srccommit, do not edit manually.
 *
 */
#define Module_MajorVersion_CMHG     	$major
#define Module_MinorVersion_CMHG	$minor
#define Module_Date_CMHG      		$date

#define Module_MajorVersion     	"$major"
#define Module_Version                  $number
#define Module_MinorVersion		"$minor"
#define Module_Date      		"$date"

EOB
  close(FILE);
  
  if ($asm) {
    open(FILE,">$version_file_asm") || &failed("cannot open $version_file_asm");
print FILE <<"EOB";
;
; This file is automatically maintained by srccommit, do not edit manually.
;
			GBLS	Module_MajorVersion
			GBLA    Module_Version
			GBLS	Module_MinorVersion
			GBLS	Module_Date
Module_MajorVersion	SETS    "$major"
Module_Version          SETA    $number
Module_MinorVersion	SETS	"$minor"
Module_Date		SETS    "$date"
		        END
EOB
    close(FILE);
  }
}

#############################################################################
# Ask for user input return position in $options string. Allow a default
# option if enter it hit.
#
sub ask {
  my ($options,$default) = @_;
  my $response;
  
  $options =~ tr/a-z/A-Z/;

  do {
    $response = <STDIN>;
    chop($response);
    if ($response eq "") {
      $response = $default;
    }
    $response =~ tr/a-z/A-Z/;
    if (index($options,$response)<0) {
      print("Not valid, try again :");
    }
  } while (index($options,$response)<0);

  return index($options,$response);
}

#############################################################################
# Get the next revision number from cvs status.
#
sub get_revision {
  my ($file) = @_;
  my ($revision,$branch,$line);
  
  open(PIPE,"cvs status $file |") || failed("fork of cvs status");
  while ($line = <PIPE>) {
    chop($line);
    if ($line =~ /$\s*Repository\srevision:\s*(\S*)/) {
      $revision = $1;
    } elsif ($line =~ /$\s*Sticky\sTag:.*\(branch:\s(\S*)\)/) {
      $branch = $1;
    } elsif ($line =~ /$\s*Sticky\sTag:\s+(.*)\s+\(revision:\s(\S*)\)/) {
      die <<"EOT";
$script: This module has been checked out as $1 which is
a specific version.  You cannot commit back to a specific version, but
must first move to a line of development (either a branch or the trunk)
using the "cvs update..." command.
EOT
    }      
  }
  close(PIPE);
  
  if (!defined($revision) || !defined($branch)) {
    die("$script: Yuk: consistancy check failed for cvs status.\n");
  }
  
  if (length($revision) > length($branch)) {
    unless ((substr($revision,0,length($branch)) eq $branch) &&
        (substr($revision,length($branch)) =~ /^\.(\d+)$/)) {
      die("$script: Revision number not on branch, barf, barf...\n");
    }
    $revision = $branch.".".($1+1);
  } else {
    unless ((substr($branch,0,length($revision)) eq $revision) &&
        (substr($branch,length($revision)) =~ /^\.\d+$/)) {
      die("$script: Branch number not based on revision, barf, barf...\n");
    }
    $revision = $branch.".1";
  }
  
  return ($revision);
}

#############################################################################
# Get the branch name from the cvs control file.
#
sub get_branch {
  my $branch;
  my $input;
  my $line,$tag;
  
  if (open(TAG,"CVS/Tag")) {
    $branch = <TAG>;
    chop($branch);
    if ($branch =~ /^T(.*$)/) {
      $branch = $1;
    } else {
      $branch='TRUNK';
    }
    close(TAG);
  } else {
    $branch = "TRUNK";
  }
   
  return ($branch);
}

#############################################################################
# Get the directory name from the cvs control file.
#
sub get_directory {
  my $dir,$input,$fullpath;
    
  # get the full path to the file in the repository
  open(REPOS,"CVS/Repository") || failed("cannot open CVS/Repository file");
  $dir = <REPOS>;
  close(REPOS);
  chop($dir);
  $dir = substr($dir,length($CVSROOT),length($dir)-length($CVSROOT));
  
  return ($dir);
}

#############################################################################
# Get repository from CVS control file in preference to environment variable
# complain if we don't have either.
#
sub get_repository {
  my $cvsroot;
  
  if (open(ROOT,"CVS/Root")) {
    $cvsroot = <ROOT>;
    close(ROOT);
    chop($cvsroot);
  } else {
    $cvsroot = $ENV{"CVSROOT"};
  }

  if ($cvsroot eq "") {
    die("$script: cannot establish a path to repository root. Need CVSROOT environment variable or CVS control files.\n");
  }

  return (canonify($cvsroot));
}

#############################################################################
sub canonify {
  my ($dir)=@_;
  $dir=~s/\/\/+/\//g;
  $dir=~s/[^\/]$/$&\//;
  $dir;
};

#############################################################################
