#!/usr/local/bin/perl
#############################################################################
## $Id$
## $Revision$
## $Date$
#############################################################################
use Getopt::Std;
use POSIX "tmpnam";
#############################################################################
$CVSROOT = &get_repository();
$script  = $0;
$script  =~ s/^.*\///;
$usage = "Usage: $script [-h] [-m <message>]\n";
$admin = "rbuckley";
$version_file = "VersionNum";
$user = $ENV{"LOGNAME"};
$user = $ENV{"USER"} if($user eq '');
#############################################################################

getopts('hm:');
if ($opt_h == 1) {			# help
  die($usage);
}

#############################################################################
# Check for presence of the VersionNum file and create it if absent. If 
# adding on the trunk, don't have a minor version number. If adding on a
# branch, use keyword substitution to obtain the correct revision number for
# the minor version number.
#
system("cvs update $version_file 2> /dev/null");
$branch = get_branch();
if (! -e $version_file) {
  print("\nVersionNum not found, create in $0 (Y/n) :");
  
  if (&ask("ny","y")) {
    if ($branch eq "TRUNK") {
      &create_file($version_file,"");		# no minor version number
      system("cvs add $version_file");
    } else {
      &create_file($version_file,'$Revision$');	# need substitution
      system("cvs add -kv $version_file");
    }
    system("cvs commit -m \"created by $script.\" $version_file");
    print("\n$script: $version_file file created. You may need to modify ");
    print("your sources to make use of this file.\n");
    exit(0);
  } else {
    die("$script: aborted\n");
  }
}
#############################################################################

#############################################################################
# Find out about these sources. If working on the trunk, prompt for the major
# version number to be incremented. If on a branch, obtain the current revision
# and increment to find the next revision.
#
print("$script: investigating module....\n");

($file_added,$file_removed,$file_modified) = &nq_update();
$mod_major = &read_file($version_file);
$mod_date  = &get_date();
$dir 	   = &get_directory();

print("Module version $mod_major is on branch $branch.\n");
if ($branch eq "TRUNK") {
  print("Increment major version number (Y/n) :");
  if (&ask("ny","y")) {
    $mod_major = &increment_major_version($mod_major);
  }
} else {
  $mod_minor = &get_revision($version_file);
  $mod_minor = &increment_minor_version($mod_minor);
}
#############################################################################

#############################################################################
# Obtain a change log entry from the user. Create a tag based on version 
# numbers that will be in force when the commit is performed.
#
if (defined($opt_m)) {
  $message = $opt_m."\n";
} else {
  $message = get_message("$mod_major, $mod_minor",$dir,$file_added,
  			$file_removed,$file_modified);
}
$tag = $dir;
$tag =~ s#^.*/(.*)$#$1#;
$tag .= "-".$mod_major;
$tag .= "-".$mod_minor if ($mod_minor ne "");
$tag =~ s/[.]/_/g;
$message .= "\nVersion $mod_major";
$message .= ", $mod_minor" if ($mod_minor ne "");
$message .= ". Tagged as '$tag'\n";
#############################################################################

#############################################################################
print("$script: commiting files....\n");
if ($branch eq "TRUNK") {
  &write_file($version_file,$mod_major,"",$mod_date);
} else {
  &write_file($version_file,$mod_major,'$Revision$',$mod_date);
}
system("cvs commit -m \"$message\"");
#############################################################################

#############################################################################
print("$script: tagging files....\n");
system("cvs tag $tag");

#############################################################################
print("$script: complete.\n");
#############################################################################

#############################################################################
# Wrap things up neatly.
#
sub failed {
  die("$script: $_[0] failed: $!\n");
};

#############################################################################
# Find out the state of checked out bits by doing a cvs -nq update and parsing
# the output. Return the files serperated by ':' so we can parse them later.
#
sub nq_update {
  my $line, $added, $removed, $modified;
  
  open(PIPE,"cvs -nq update 2>&1 |") || failed("fork");
  while($line = <PIPE>) {
    if($line =~ /^A (.*)$/) { 			# Added locally
      if ($added ne "") {
        $added .= ":";
      }
      $added .= $1;
    } elsif($line =~ /^R (.*)$/) { 		# Removed locally
      if ($removed ne "") {
        $removed .= ":";
      }
      $removed .= $1;
    } elsif($line =~ /^M (.*)$/) { 		# Modified locally
      if ($modified ne "") {
        $modified .= ":";
      }
      $modified .= $1;
    } elsif($line =~ /^C (.*)$/) { 		# Conflict
      print("$1 contains conflicts, remove conflicts and try again.\n");
      die("$script: aborted\n");
    }
  }
  return ($added, $removed, $modified);
}

#############################################################################
# Sort out line formatting for inserting text in the editor. We want the text
# to wrap round nicely.
#
sub format_line {
  my ($prefix,$data,$length) = @_;
  my $line,$lines,$file,@files;

  $lines = "";
  $line = $prefix;  
  @files = split(":",$data);
  foreach $file (@files) {
    if (length($line.$file)>70) {
      $lines .= "$line\n";
      $line = "$prefix";
    }
    $line .= $file.", ";
  }
  $lines .= "$line\n";
  
  return $lines;
}

#############################################################################
# Get change log entry from user, either use the configured editor or prompt
# the user for successive lines of input.
#
sub get_message {
  my ($header,$dir,$added,$removed,$modified) = @_;
  my $tmpfile, $line, $message, $editor;
  
  $editor = $ENV{"EDITOR"};
  print("Enter change log (blank line to end), or hit enter to invoke $editor.\n");
  print("> ");
  $line = <STDIN>;
  chop($line);
  
  # Deal with using the configured editor.
  #
  if ($line eq "") {
editor_again:    
    $tmpfile = tmpnam();
    open(TMP,">$tmpfile") || failed("cannot open editor file $tmpfile");
    print TMP <<"EOB";

CVS: ----------------------------------------------------------------------
CVS: Enter Log.  Lines beginning with `CVS: ' are removed automatically
CVS: 
CVS: Committing in $dir
CVS:
EOB
    if ($added ne "") {
      print(TMP "CVS: Files added :\n");
      print(TMP &format_line("CVS:    ",$added,72));
      print(TMP "CVS:\n");
    }
    if ($removed ne "") {
      print(TMP "CVS: Files removed :\n");
      print(TMP &format_line("CVS:    ",$removed,72));
      print(TMP "CVS:\n");
    }
    if ($modified ne "") {
      print(TMP "CVS: Files modified :\n");
      print(TMP &format_line("CVS:    ",$modified,72));
      print(TMP "CVS:\n");
    }
    print TMP <<"EOB";
CVS: Version $header
CVS: ----------------------------------------------------------------------
EOB
    close(TMP);
    system("$editor $tmpfile");
  
    open(TMP,"<$tmpfile") || failed("cannot open editor file $tmpfile");
    while ($line = <TMP>) {
      chop($line);
      if ($line !~ /^CVS:/) {
        if ($line ne "") {
          $message .= $line."\n";
        }
      }
    }
    close(TMP);
    unlink($tmpfile);
    if ($message eq "") {
      print("No change log entered, (A)bort or (r)etry :");
      if (&ask("ra","a")) {
        die("$script: aborted\n");
      } else {
        goto editor_again;
      }
    }
  } else {
    
    # Get user input directly.
    #     
    while ($line ne "") {
      $message .= $line."\n";
      print("> ");
      $line = <STDIN>;
      chop($line);
    }
  }
  return ($message);
}

#############################################################################
# Increment the major version number in the form "0.01" to obtain a value in
# the form "0.02". Prompt the user if the default is no good.
#
sub increment_major_version {
  my $version = $_[0];
  my $major;
  
  $version =~ s/(^\d*)[.](\d*)/$1$2/;
  $version += 1;
  $version = sprintf("%d.%02d",int($version/100),($version-int($version/100)*100));

input_again:
  print("Enter new version number (default $version) :");
  $major = <STDIN>;
  chop($major);
  if ($major =~ /[^0-9.]/) {
    print("'$version' is an invalid version number\n");
    goto input_again;
  }
  if ($major eq "") {
    return ($version);
  } else {
    return ($major);
  }
}

#############################################################################
# Increment the minor version number in the form "1.1.1.1" to obtain a value
# in the form "1.1.1.2".
#
sub increment_minor_version {
  my $version = $_[0];
  
  $version =~ s/\d*$/$&+1/e;

  return ($version);
}

#############################################################################
# Obtain current date and return in the correct format for RISC OS modules.
#
sub get_date {
  my $now = localtime;
  my @parts;
  @parts = split(" ",$now);
  return ("@parts[2] @parts[1] @parts[4]");
}

#############################################################################
# Read the version number file to retreive the current major version number.
#
sub read_file {
  my $file = $_[0];
  my $line,$major;
  
  # first line contains the interesting stuff
  open(FILE,"<$file") || &failed("cannot open $file");
  $line = <FILE>;
  close(FILE);
  
  chop($line);
  $line =~ m|^.*\((.*)\).*$|;			# extract the version number
  $major = $1;
  if ($major eq "") {
    die("$script: cannot find major version number, has the file been messed with ?\n");
  }
  
  return ($major);
}

#############################################################################
# Obtain the details to put into the first version number file.
#
sub create_file {
  my ($file,$minor) = @_;
  my $major,$date;
  
  $date  = &get_date();
    
  # get the version number to use
  #
input_again:
  print("Enter the initial version number in form n.nn (default 0.01) :");
  $major = <STDIN>;
  chop($major);
  if ($major =~ /[^0-9.]/) {
    print("'$version' is an invalid version number\n");
    goto input_again;
  }
  if ($major eq "") {
    $major = "0.01";
  }
  &write_file($file,$major,$minor,$date);
}

#############################################################################
# Write out the given details to the file.
#
sub write_file {
  my ($file,$major,$minor,$date) = @_;
  
  open(FILE,">$file") || &failed("cannot open $file");
print FILE <<"EOB";
; /* ($major)
;    This file is automatically updated by srccommit, do not edit manually.
;    Can be included by both C and assembler.
;
			GBLS	Module_MajorVersion
			GBLS	Module_MinorVersion
			GBLS	Module_Date
Module_MajorVersion	SETS    "$major"
Module_MinorVersion	SETS	"$minor"
Module_Date		SETS    "$date"
		        END
 */
#define Module_MajorVersion     $major
#define Module_MinorVersion	$minor
#define Module_Date      	$date
;
; /* End */
EOB
  close(FILE);
}

#############################################################################
# Ask for user input return position in $options string. Allow a default
# option if enter it hit.
#
sub ask {
  my ($options,$default) = @_;
  my $response;
  
  $options =~ tr/a-z/A-Z/;

  do {
    $response = <STDIN>;
    chop($response);
    if ($response eq "") {
      $response = $default;
    }
    $response =~ tr/a-z/A-Z/;
    if (index($options,$response)<0) {
      print("Not valid, try again :");
    }
  } while (index($options,$response)<0);

  return index($options,$response);
}

#############################################################################
# Get the revision number from the cvs control file, this is quicker than
# using cvs status.
#
sub get_revision {
  my $file = $_[0];
  my $revision,$line;
  
  open(ENTRIES,"CVS/Entries") || failed("cannot open CVS/Entries file");
  while ($line = <ENTRIES>) {
    chop($line);
    $line =~ m|/([^/]*)/([^/]*)/.*|;
    if ($1 eq $file) {
      $revision = $2;
      last;
    }
  }
  close(ENTRIES);
  
  return ($revision);
}

#############################################################################
# Get the branch name from the cvs control file.
#
sub get_branch {
  my $branch;
  my $input;
  my $line,$tag;
  
  if (open(TAG,"CVS/Tag")) {
    $branch = <TAG>;
    chop($branch);
    if ($branch =~ /^T(.*$)/) {
      $branch = $1;
    } else {
      $branch='TRUNK';
    }
    close(TAG);
  } else {
    $branch = "TRUNK";
  }
   
  return ($branch);
}

#############################################################################
# Get the directory name from the cvs control file.
#
sub get_directory {
  my $dir,$input,$fullpath;
    
  # get the full path to the file in the repository
  open(REPOS,"CVS/Repository") || failed("cannot open CVS/Repository file");
  $dir = <REPOS>;
  close(REPOS);
  chop($dir);
  $dir = substr($dir,length($CVSROOT),length($dir)-length($CVSROOT));
  
  return ($dir);
}

#############################################################################
# Get repository from CVS control file in preference to environment variable
# complain if we don't have either.
#
sub get_repository {
  my $cvsroot;
  
  if (open(ROOT,"CVS/Root")) {
    $cvsroot = <ROOT>;
    close(ROOT);
    chop($cvsroot);
  } else {
    $cvsroot = $ENV{"CVSROOT"};
  }

  if ($cvsroot eq "") {
    die("$script: cannot establish a path to repository root. Need CVSROOT environment variable or CVS control files.\n");
  }

  return (canonify($cvsroot));
}

#############################################################################
sub canonify {
  my ($dir)=@_;
  $dir=~s/\/\/+/\//g;
  $dir=~s/[^\/]$/$&\//;
  $dir;
};

#############################################################################
