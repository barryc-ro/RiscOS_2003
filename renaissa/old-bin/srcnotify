#!/usr/local/bin/perl
#############################################################################
## $Id$
## $Revision$
## $Date$
#############################################################################
$CVSROOT = &get_repository();
$usage = "Usage: $0  [-q] [-r <branch>] -d [path] [add|remove]\n";
$admin = "rbuckley";
$user = $ENV{"LOGNAME"};
$user = $ENV{"USER"} if($user eq '');
$notify_file = $CVSROOT."CVSROOT/srcnotifications";
$notify_tmp  = $CVSROOT."CVSROOT/srcnotifications~";
$cvstags     = $CVSROOT."CVSROOT/val-tags";
$quiet = 0;
$LOCK_SH=1;
$LOCK_EX=2;
$LOCK_NB=4;
$LOCK_UN=8;
#
# Notifications file will be formated as
# 
# username:branch:path with a serperate line for each notification
#
#############################################################################

#sort out the input arguments
while ($ARGV[0]=~/^-/) {
  $arg = shift(@ARGV);

  if ($arg eq '-h') {			# help
    die($usage);
  } elsif ($arg eq '-q') {		# quiet
    $quiet = 1;
  } elsif ($arg eq '-r') {		# branch
    $arg_branch = shift(@ARGV);
  } elsif ($arg eq '-d') {		# directory
    $arg_directory = shift(@ARGV);
  } else {
    die($usage);
  }
}

# sort out remaining arguments
#
$arg = shift(@ARGV);
if ($arg eq 'add') {
  $function = "add";
} elsif ($arg eq 'remove') {
  $function = "remove";
} elsif (!defined($arg)) {
  $function = "list";
} else {
  die($usage);
}

&read_notifications($user);

if (($function eq "list") || ($function eq "remove")) {
  print("\n");
  if (defined(@notifications)) {
    $i = 1;
    foreach $entry (@notifications) {
      ($b,$d,$s) = split(":",$entry);
      if ($s eq "") {
        $s = "Yes";
      }
      if ($b =~ /all/i) {
        $b = "All branches";
      }
      print("  $i) $b : $d : self notifcation ($s)\n");
      $i++;
    }
    printf("\n");
    if ($function eq "remove") {
      print("Which notification do you want to remove ? : ");
      $input = <STDIN>;
      chop($input);
      if ($input>=$i || $input<1) {
        print("\nNot one of the options given !\n\n");
        exit(1);
      }

      ($b,$d,$s) = split(":",$notifications[$input-1]);
      &modify_notifications($function,$b,$d,$s);
      print("\nNotification removed for $user on $d".(defined($b)&&" ($b)")."\n\n");
    }
  } else {
    print("  No notifications currently registered.\n\n");
  }
} else {

  $branch    = &get_branch($arg_branch);
  $directory = &get_directory($arg_directory);
  $self_notify = &get_self_notification();
  
  foreach $entry (@notifications) {
    ($b,$d) = split(":",$entry);
    if (($b eq $branch) && ($d eq $directory)) {
      print("\nThis notification already exists !\n\n");
      exit(1);
    }
  }
  &modify_notifications($function,$branch,$directory,$self_notify);
  
  print("\nNotification added for $user on $directory".(defined($branch)&&" ($branch)")."\n\n"); 
}

#############################################################################
# functions
#
sub failed {
  die("$0: $_[0] failed: $!\n");
};

sub canonify {
  my ($dir)=@_;
  $dir=~s/\/\/+/\//g;
  $dir=~s/[^\/]$/$&\//;
  $dir;
};

# get repository from CVS control file in preference to environment variable
#
sub get_repository
{
  my ($cvsroot);
  
  if (open(ROOT,"CVS/Root")) {
    $cvsroot = <ROOT>;
    close(ROOT);
    chop($cvsroot);
  } else {
    $cvsroot = $ENV{"CVSROOT"};
  }

  if ($cvsroot eq "") {
    die("$0: cannot establish a path to repository root. Need CVSROOT environment variable or CVS control files.\n");
  }

  return (canonify($cvsroot));
}

# get the branch name if not specified on the command line, default to TRUNK
#
sub get_branch
{
  my ($branch) = @_;
  my ($input,$line,$tag);
  
  if (!defined($branch)) {  
    if (open(TAG,"CVS/Tag")) {
      $branch = <TAG>;
      chop($branch);
      if ($branch =~ /^T(.*$)/) {
        $branch = $1;
      } else {
        $branch='TRUNK';
      }
      close(TAG);
    } else {
      $branch = "TRUNK";
    }
    # if not in quiet mode, prompt the user
    #
    if (!$quiet) {
      print("Enter the branch to apply (default $branch, 'All' for all branches) : ");
      $input = <STDIN>;
      chop($input);
      if ($input ne "") {
        $branch = $input;
        
        # check that this tag exists
        #
        if ($branch eq "TRUNK") {
          ;
        } elsif ($branch =~ /all/i) {
          $branch =~ tr/A-Z/a-z/;
        } else {
          open(TAGS,$cvstags) || failed("cannot open $cvstags");
          while ($line = <TAGS>) {
            ($tag) = split(" ",$line);
            if ($tag eq $branch) {
              last;
            }
          }
          close(TAGS);
          if ($tag ne $branch) {
            printf("\nTag '$branch' does not exist !\n\n");
            exit(1);
          }
        }
      }
    }
  }
  return ($branch);
}

# get the directory name if not specified on the command line
#
sub get_directory
{
  my ($dir) = @_;
  my ($input,$fullpath);
    
  if (!defined($dir)) {
    # get the full path to the file in the repository
    if (open(REPOS,"CVS/Repository")) {
      $dir = <REPOS>;
      close(REPOS);
      chop($dir);
      $dir = substr($dir,length($CVSROOT),length($dir)-length($CVSROOT));
    }
    # if not in quiet mode, prompt the user
    #
    if (!$quiet) {
      printf("Enter the directory to apply (default $dir) : ");
      $input = <STDIN>;
      chop($input);
      if ($input ne "") {
        $dir = $input;
        
        # check that this path exists
        #
        $fullpath = $CVSROOT.$dir;
        if (!(-x $fullpath)) {
          printf("\nPath '$fullpath' does not exist !\n\n");
          exit(1);
        }
      }
    }
  }
  return ($dir);
}

# see if the user wants to be informed when they commit things
#
sub get_self_notification
{
  if (!$quiet) {
    print("Do you want to be informed when you do commits (Y/n) :");
    if (&ask("ny","y")) {
      return ("Yes");
    }
  }
  return ("No");
}

# read notifications file
#
sub read_notifications
{
  my ($username) = @_;
  my ($line,$branch,$path,$user,$self_notify);
  
  open(NOTIFY,$notify_file) || failed("cannot open $notify_file");
  while ($line = <NOTIFY>)
  {
    chop($line);
    ($user,$branch,$path,$self_notify) = split(':',$line);
    if ($username eq $user) {
      push(@notifications,$branch.":".$path.":".$self_notify)
    }
  }
  close(NOTIFY);
}

# add or remove an entry from the notifications file.
#
sub modify_notifications
{
  my ($action,$branch,$directory,$self_notify) = @_;
  my ($line,$u,$b,$d,$handle_dev,$handle_ino,$dev,$ino);
  
  # try to open tmp file and get a lock on it, check for race conditions
  #
  while (1) {
    if (!open(TMP,"+<$notify_tmp")) {
      open(TMP,">>$notify_tmp") || failed("cannot create $notify_file");
      close(TMP)
    } else {
      flock(TMP,$LOCK_EX);
      
      # check that file we now have lock on is the correct file
      #
      ($handle_dev,$handle_ino) = stat(TMP);
      ($dev,$ino) = stat($notify_tmp);
      if (($dev == $handle_dev) && ($ino == $handle_ino)) {
        last;
      } else {
        flock(TMP,$LOCK_UN);
        close(TMP);
      }
    }
  }
  
  open(NOTIFY,"$notify_file") || failed("cannot open $notify_file");
  # copy real file to tempory file, except for one to remove
  #
  while ($line = <NOTIFY>) {
    if ($action eq "add") {
      print(TMP $line);
    } else {
      # see if we need to remove this entry
      #
      chop($line);
      ($u,$b,$d) = split(":",$line);
      if (($u ne $user) || ($b ne $branch) || ($d ne $directory)) {
        print(TMP "$line\n");
      }
    }
  }
  
  # append the one to be added to the end of the file
  #
  if ($action eq "add") {
    print(TMP "$user:$branch:$directory:$self_notify\n");
  }
  close(NOTIFY);
  
  # now move the tempory file over the old one - file handle follows file
  #
  rename($notify_tmp,$notify_file);
  flock(TMP,$LOCK_UN);
  close(TMP);
}

# Ask for user input return position in $options string. Allow a default
# option if enter it hit.
#
sub ask {
  my ($options,$default) = @_;
  my ($response);
  
  $options =~ tr/a-z/A-Z/;

  do {
    $response = <STDIN>;
    chop($response);
    if ($response eq "") {
      $response = $default;
    }
    $response =~ tr/a-z/A-Z/;
    if (index($options,$response)<0) {
      print("Not valid, try again :");
    }
  } while (index($options,$response)<0);

  return index($options,$response);
}
