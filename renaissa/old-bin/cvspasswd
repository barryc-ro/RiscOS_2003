#!/usr/local/bin/perl
#############################################################################
## $Id$
## $Revision$
## $Date$
#############################################################################
use POSIX "tmpnam";
#############################################################################

# sysuser is the user to match the password for if you want to create a new
# entry in the password file.  If the supplied user isn't in the file, then this
# user's local password lookup will be attempted on the "old password" to
# validate the addition of the new user - otherwise the addition will be
# faulted. 
$sysuser = 'sources';

$usage = "Usage: $0 [options] <user> <verify password> [<new password>|<new user>]\n\n" .
  "The <verify password> is the specified user's current password, or may\n".
  "be the system user's password (system user is '$sysuser')  To create new\n".
  "entries, just attempt to change the user's password giving the system\n".
  "user's password as the <verify password>.  Accepted options are:\n\n".
  "  -d <repository>     the repository to use\n" .
  "  -q                  quiet\n".
  "  -del                delete the named user (*)\n".
  "  -map                map the named user to the specified <new user> (*)\n\n".
  "(* = verify password MUST be password for the system user)\n".
  "\n";
# extra unreported option -D enables debugging.

$admin = "cam-cvsadmin";

$tmpdir = tmpnam();
$leafname = "passwd";
$tmpleaf = "newpass";
$notify_file = "CVSROOT/" . $leafname;
$notify_tmp = $tmpdir . '/' . $tmpleaf;
$quiet = 0;
$debug = 0;
$winnt = ($^O eq 'MSWin32');

# This value is used to parse the output of the attempted commit.
# If this phrase is found inside the output of the CVS command we
# execute, we assume that it succeeded and suppress the output (to
# avoid confusing the poor users) otherwise we assume failure and
# output the whole thing to aid debugging.
$checkregexp = 'building administrative';

# The same, but for the initial checkout of the current file
$checkexport = ' checkout:';

#############################################################################
#
# The passwd file is formatted thus:
#
# username:password:local username
#
#############################################################################

#sort out the input arguments
while ($ARGV[0]=~/^-/) {
  $arg = shift(@ARGV);

  if ($arg eq '-h') {                   # help
    die($usage);
  } elsif ($arg eq '-q') {              # quiet
    $quiet = 1;
  } elsif ($arg eq '-d') {              # repository
    $CVSROOT = shift(@ARGV);
  } elsif ($arg eq '-del') {            # remove user
    $deluser = 1;
  } elsif ($arg eq '-map') {            # remap user
    $mapuser = 1;
  } elsif ($arg eq '-D') {
    $debug++;                           # debugging level
  } else {
    die($usage);
  }
}

$CVSROOT = &get_repository($CVSROOT);
$cvsrootparam = '-d ' . $CVSROOT;
$cvsrootparam =~ s/\/$//; # strip trailing / put there by &canonify()

if ($debug) {
  print "Checking out $notify_file\nTemporary directory: $tmpdir\n";
}

# sort out remaining arguments
#
($user,$oldpw,$newpw)=@ARGV;
if ($user && !$newpw && !$oldpw) {
  ($oldpw,$newpw) = &interactive_passwords($user);
}
die($usage) unless $user && ($deluser || $newpw);

$suok = checksyspassword($oldpw);
print STDERR "Super-user password check: $suok\n" if $debug;

($edited, $aborted, $logmessage) = &modify_cvsfile($user,$oldpw,$newpw,"Password changed for $user");
print "\n" . $logmessage . "\n\n" if $logmessage && !$quiet;

exit $aborted;
#############################################################################
# functions
#
sub failed {
  my $diemsg="$0: $_[0] failed: $!\n";
  &cleanup();
  die $diemsg;
};

sub canonify {
  my ($dir)=@_;
  $dir=~s/\/\/+/\//g;
  $dir=~s/[^\/]$/$&\//;
  $dir;
};

# get repository from CVS control file in preference to environment variable
#
sub get_repository
{
  my ($cvsroot);
  
  if (open(ROOT,"CVS/Root")) {
    $cvsroot = <ROOT>;
    close(ROOT);
    chomp($cvsroot);
  } else {
    $cvsroot = $ENV{"CVSROOT"};
  }

  $cvsroot = $_[0] if $_[0]; 

  if ($cvsroot eq "") {
    die("$0: cannot establish a path to repository root.\n".
	"  Need CVSROOT environment variable, CVS control files or -d parameter.\n");
  }

  return (canonify($cvsroot));
}

# modify the password file with the new details
#
sub modify_cvsfile
{
  my ($user,$oldpw,$newpw,$logmessage) = @_;
  my ($line,$u,$b,$d,$handle_dev,$handle_ino,$dev,$ino,$command,$edited,$abort);
  
  # checkout the file for real
  #
  if ($winnt || ($cvsrootparam !~ /:pserver:/)) {
    $command = "cvs -Q $cvsrootparam co -d $tmpdir $notify_file";
  }
  else {
  # Client-server CVS on UNIX seems to have a bug relating to the use of
  # the co -d option to choose the checkout directory.  This code gets
  # around it.
    if ($tmpdir =~ /\A(.*)\/([^\/]+\Z)/) {
      $pathname=$1;
      $leafdir=$2;
    }
    else {
      failed("Unable to parse temporary filename! $tmpdir");
    }
    failed("Unable to change directory to $pathname") unless chdir $pathname;
    $command = "cvs -Q $cvsrootparam co -d $leafdir $notify_file";
  }
  execute($command);
  failed("Unable to check out $notify_file") if ($? >> 8);
  
  open(TMP,">$notify_tmp") || failed("unable to open $notify_tmp");
  open(NOTIFY,$tmpdir.'/'.$leafname) || failed("cannot open $leafname");
  #
  # copy real file to temporary file, except for one to change
  #
  while ($line = <NOTIFY>) {
    chomp $line;
    @details=split(":", $line);

    # Interested in this line?
    if ($details[0] ne $user || $edited || $abort) {
      print $line . "\n" if $debug;
      print(TMP "$line\n");
      next;
    }

    if (!$suok && !&checkuserpassword($details[1], $oldpw, $deluser || $mapuser)) {
      $logmessage = "Unable to update password file: permission denied";
      print STDERR "Permission denied: wrong password\n" if $debug;
      $abort = 1;
      last;
    }

    $edited = 1; # indicate that we should commit the file
    if ($deluser) {
      $logmessage = "Deleted user $user";
      next;
    }
    if ($mapuser) {
      $details[2] = $newpw;
      $logmessage = "Changed usermap for $user to $newpw";
    }
    else {
      $details[1] = makepw($newpw);
    }
    $line = join ':', @details;
    print $line . "\n" if $debug;
    print(TMP "$line\n");
  }
 
  # append the new entry to be added to the end of the file - if $sysuser's password matches
  #
  if (!$edited && !$abort && !$deluser) {
    if (!$suok) {
      $logmessage = "Unable to update password file: permission denied";
      print STDERR "Permission denied: need to be super-user to add new entries to password file\n" if $debug;
      $abort = 1;
    }
    else {
      @details = ($user, makepw($newpw));
      $line = join ':', @details;
      print $line . "\n" if $debug;
      print(TMP "$line\n");
      $logmessage = "Added new user $user to password file";
      $edited = 1;
    }
  }

  if (!$edited && !$abort && $deluser) {
    $abort = 1;
    $logmessage = "User $user was not in the password file\n";
  }

  close(TMP);
  close(NOTIFY);
  
  # now move the temporary file over the old one - file handle follows file
  #
  chdir($tmpdir);
  if ($edited && !$abort && $debug < 2) {
    unlink($leafname);
    rename($tmpleaf,$leafname);
    $command = "cvs -Q $cvsrootparam ci -m\"$logmessage\" $leafname|";
    print "-- executing: $command\n" if $debug;
    open(TMP, $command) ||
      failed("Unable to commit new file");
    while (<TMP>) {
      $results.=$_;
      $ok = 1 if (/$checkregexp/i);
    }
    close TMP;
    print $results unless $ok;
  }
  &cleanup();
  return ($edited, $abort, $logmessage);
}

sub makepw {
  my ($password, $salt) = @_;
  if (!$salt) {
    my @salt = ('a'..'z', 'A'..'Z', '0'..'9');
    my $rnd1 = int rand(@salt);
    my $rnd2 = int rand(@salt);
    $salt = $salt[$rnd1] . $salt[$rnd2];
  }
  return crypt($password, $salt);
};

# This routine checks that the password supplied matches the system password
# (which is the password for $sysuser)
sub checksyspassword {
  my ($verify) = @_;
  my ($uid,$passwd) = getpwnam($sysuser);
  print STDERR "Super-user is $uid, password is $passwd, crypt gives ".&makepw($verify,$passwd)."\n" if $debug > 1;
  return (makepw($verify, $passwd) eq $passwd);
}

sub checkuserpassword {
  my ($file, $cli, $suop) = @_;
  # Restrict super-user ops to superuser password
  return 0 if $suop;
  # Empty password in file and on command line ... OK
  return 1 if ($file eq '' && $cli eq '');
  # Otherwise, compare the crypted passwords.
  return (makepw($cli, $file) eq $file);
}

sub cleanup {
  chdir; # Get out of the directory we're about to massacre ...
  if ($debug > 2) {
    print "** WARNING: Not deleting temporary directory $tmpdir\n";
    return;
  }
  if ($winnt) {
    execute('rmdir /q /s ' . $tmpdir);
  }
  else {
    execute("rm -rf $tmpdir");
  }
}

sub execute {
  print "-- executing: $_[0]\n" if $debug;
  system($_[0]);
}

sub read_crypt_string {
  my ($prompt, $clear) = @_;

  print $prompt;
  system("stty -echo") if !$clear;
  $prompt = <STDIN>;
  chomp $prompt;
  system("stty echo") if !$clear;
  print "\n" if !$clear;
  return $prompt;
}

# This routine prompts for the <verify password> and new information (user/password)
sub interactive_passwords {
  my $optype = "new password";
  my $oldpw,$newpw;
  $optype = "new username" if $mapuser;
  $oldpw = read_crypt_string("Enter verify password: ", 0);
  $newpw = read_crypt_string("Enter ".$optype.": ", $mapuser) unless $deluser;
  $newpw2 = read_crypt_string("Re-enter ".$optype.": ", $mapuser) unless $mapuser || $deluser;
  die("The $optype entries were not identical!\n") unless $newpw eq $newpw2;
  return ($oldpw, $newpw);
}

# Local Variables:
# mode:perl
# perl-indent-level: 2
# End:
