#!/usr/local/bin/perl

# Author: $Author$
# Version: $Revision$

# !! This application is not complete.  Do not use except for manual
# !! testing.

# This program takes a "normal" diff output and generates a log
# entry suitable for a commit log message for product module's file.
#
# Eventually it will be used in the same way that srccommit is for
# source code (hence the name prodcommit) where it primes the editor
# buffer with the differences that have been made to the modules file
# allowing the buildmaster to check over them (perhaps spot errors!)
# and not have to worry about typing out complicated log messages.

# The output message will list the component name, its old symbolic tag
# and its new symbolic tag (where appropriate).  For an updated component,
# it will check to see if it is using a srccommit generated tag and test
# the revision numbers and append "(REGRESSED)" in the log file to
# indicate that the component version number has been reduced.

# Set this to 1 for full directory paths on output; 0 for just leafnames
$report=0;

# Read output of diff from stdin

while (<>) {
  if (/\A\<\s(\S+)\s+(\S+)\s*\Z/) {
    $previous{$1}=$2;
  }
  elsif (/\A\>\s(\S+)\s+(\S+)\s*\Z/) {
    $next{$1}=$2;
  }
};

# Components can be removed, added or updated.  Keep a count so that
# we can generate a pretty output message
$updated = 0;
$new = 0;
$dead = 0;

foreach $i (keys %previous) {
  if ($next{$i}) {
    $updated++;                           # There was a newer tag inserted.
  }
  else {
    $dead++;                              # Component has been removed.
  }
};

foreach $i (keys %next) {
  $new++ unless $previous{$i};            # New component if no older tag
};

if ($new) {
  printf("$new new component%s:\n", $new == 1 ? "" : "s");
  foreach $i (sort(keys %next)) {
    print "  ",&leaf_dir($i,$report)," ($next{$i})\n" unless $previous{$i};
  }
}

if ($updated) {
  printf("$updated updated component%s:\n", $updated == 1 ? "" : "s");
  foreach $i (sort(keys %next)) {
    next unless $previous{$i};
    print "  ",&leaf_dir($i,$report)," ($previous{$i} -> $next{$i})";
    &check_regress($i, $previous{$i}, $next{$i});
    print "\n";
  }
}

if ($dead) {
  printf("$dead removed component%s:\n", $dead == 1 ? "" : "s");
  foreach $i (sort(keys %previous)) {
    print "  ",&leaf_dir($i,$report)," ($previous{$i})\n" unless $next{$i};
  }
}

exit 0;

sub leaf_dir {
  my ($dir,$option)=@_;
  $dir =~ s/.+\/([^\/]+)\Z/$1/ unless $option;
  return $dir;
};

sub check_regress {
  my ($dir, $old, $new)=@_;
  my $oldv, $newv;

  $dir=leaf_dir($dir, 0);

  return unless $old =~ /$dir\-\d+[\d\_]+\Z/;
  return unless $new =~ /$dir\-\d+[\d\_]+\Z/;

  $old =~ s/$dir\-(.*)/$1/;
  $new =~ s/$dir\-(.*)/$1/;

  if (&compare_rev($old, $new) > 0) {
    print "  (REGRESSED)"
  }

};

# Compare two revision numbers.  Returns -1, 0 or 1 in a strcmp-like
# manner meaning "earlier than", "the same as" and "later than",
# depending on the relative values of the revision numbers.
# Works with branches too, although it takes no account of the dates
# on the differing branches.

# Note that this is using _ as the revision level separator because
# we are processing srccommit tags

sub compare_rev {
  my ($a,$b)=@_;
  @crev_a = split(/\_/,$a);
  @crev_b = split(/\_/,$b);

  while (@crev_a > 0) {
    my $result = (shift @crev_a) - (shift @crev_b);
    next unless $result;
    return -1 if $result < 0;
    return 1;
  }

  return 1 if (@crev_b > 0);
  return 0;
};

# end
