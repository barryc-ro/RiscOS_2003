
; file:    iodma_chan.s
; purpose: Test the state transitions on a single IODMA channel.
; author:  Simon Proven

; history: Sat 28th February 1998

;          Created.



	GBLS	GetAroundObjAsm
GetAroundObjAsm	SETS	" GET s.$testname"

$GetAroundObjAsm


iodma_Message_Start
	DCB	"TUBE:IODMA: Starting test",&0
iodma_Message_End
	DCB	"TUBE:IODMA: Finished test",&0
iodma_ResetChannel_Disable_Failed
	DCB	"TUBE:IODMA: Failed to reset and disable channel",CONTINUE_AFTER_ERROR,0
iodma_ResetChannel_Enable_Failed
	DCB	"TUBE:IODMA: Failed to reset and enable channel",CONTINUE_AFTER_ERROR,0
iodma_Illegal_State_Message
	DCB	"TUBE:IODMA: Channel entered unexpected state",CONTINUE_AFTER_ERROR,0
iodma_DMAST_Message
	DCB	"TUBE:IODMA: Wrong value in DMAST register",CONTINUE_AFTER_ERROR,0
iodma_DMARQ_Message
	DCB	"TUBE:IODMA: Wrong value in DMARQ register",CONTINUE_AFTER_ERROR,0
iodma_Length_Error_Message
	DCB	"TUBE:IODMA: Channel length error",CONTINUE_AFTER_ERROR,0
iodma_Error_Message
	DCB	"TUBE:IODMA: Error reported from error register",CONTINUE_AFTER_ERROR,0
iodma_Error_Data_Message
	DCB	"TUBE:IODMA: Error - data in buffer did not match with other data",CONTINUE_AFTER_ERROR,0
iodma_Copy_Data_Fail_Message
	DCB	"TUBE:IODMA: Data written to SDRAM was different when read back",CONTINUE_AFTER_ERROR,0
	ALIGN

	GET	s.iodma_defs

	GBLL	check_length
check_length	SETL	{FALSE}		; don't bother to check the length
; register allocations:

iodma_RChannel	RN 0	; points to the currently being tested channel
iodma_RTest	RN 1	; points to the test control structure for that channel
iodma_RBuf	RN 2	; points to the buffer space for a channel
iodma_RError	RN 3	; points to the error report register for a channel
iodma_RTmp1	RN 4	; temp
iodma_RTmp2	RN 5	; temp
iodma_RStart	RN 6	; holds start addr
iodma_REnd	RN 7	; holds end
iodma_RLength	RN 8	; length
iodma_RTmp3	RN 9	; another temp

iodma_FastTube	RN 10
iodma_Msg	RN 11
iodma_Link	RN 12

; notes:

; this file implements tests designed to look for problems with the
; IODMA state machines

; =================================================

; this macro outputs a message onto the fasttube

; $msglabel gives the message to be sent

; $cc is a condition code.  the event happens only
; if this condition code is met

; the register iodma_FastTubeMsg is allocated for writing
; out the message

; the register iodma_FastTubePtr must always point to the fasttube

	MACRO
	iodma_Message	$msglabel, $cc

	ldr$cc	iodma_Msg, =$msglabel
	str$cc	iodma_Msg, [iodma_FastTube]

	MEND


; =================================================

; this macro is used for resetting an IODMA channel,
; and disables it.  the other bits in the control
; register for this channel are not altered.

; when this is done, the macro reads the value of
; the control register and checks that E is set to
; zero

; it also checks that the channel is disabled

; $rchannel is the register which contains a pointer
; to the channel control structure

	MACRO
	iodma_ResetChannel_Disable

	ldrb	iodma_RTmp1, [iodma_RChannel, #iodma_iocr]	; get current status of the channel
	orr	iodma_RTmp2, iodma_RTmp2, #iod_clear	; want to reset this channel
	bic	iodma_RTmp2, iodma_RTmp2, #iod_enable	; and clear the enable bit
	strb	iodma_RTmp2, [iodma_RChannel, #iodma_iocr]	; now write new control stuff
	strb	iodma_RTmp2, [iodma_RTest, #iodma_TestControl]	; write copy to test space

; we now check that the values are properly set...

; test that the enable and control bits are clear
	ldrb	iodma_RTmp2, [iodma_RChannel, #iodma_iocr]
	tsts	iodma_RTmp2, #iod_enable+iod_clear

	iodma_Message	iodma_ResetChannel_Disable_Failed, ne

; this shouldn't have affected the D or Inc[4:0] bits, so test them

	bic	iodma_RTmp2, iodma_RTmp1, #iod_enable+iod_clear

	teqs	iodma_RTmp2, iodma_RTmp1

	iodma_Message	iodma_ResetChannel_Disable_Failed, ne

; also, check that status has gone to OIA

	ldrb	iodma_RTmp1, [iodma_RChannel, #iodma_iost]

	teqs	iodma_RTmp1, #iodma_status_OIA

	iodma_Message	iodma_Illegal_State_Message, ne	; if it's not OIA, it's bad

	MEND


; =================================================

; this macro is used for resetting an IODMA channel,
; and enables it.  the other bits in the control
; register for this channel are not altered.

; when this is done, the macro reads the value of
; the control register and checks that E is set to
; zero

; it also checks that the state on the channel is
; as expected (should be OIA)

; $rchannel is the register which contains a pointer
; to the channel control structure

	MACRO
	iodma_ResetChannel_Enable	$dir, $width

	mov	iodma_RTmp1, #iod_clear+iod_enable+$dir+$width
	str	iodma_RTmp1, [iodma_RChannel, #iodma_iocr]	; store control reg value
	str	iodma_RTmp1, [iodma_RTest, #iodma_TestControl]

; check that the channel has entered state 110 (OIA)

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]

	teqs	iodma_RTmp1, #iodma_status_OIA

	iodma_Message	iodma_Illegal_State_Message, ne	; if it's not OIA, is bad

	MEND

; =================================================

; this macro is used for enabling an iodma channel.
; the other bits in the control
; register for this channel are not altered.

; when this is done, the macro reads the value of
; the control register and checks that E is set to
; zero

; $rchannel is the register which contains a pointer
; to the channel control structure

	MACRO
	iodma_Enable	$dir, $width

	mov	iodma_RTmp1, #iod_enable+$dir+$width
	str	iodma_RTmp1, [iodma_RChannel, #iodma_iocr]	; store control reg value
	str	iodma_RTmp1, [iodma_RTest, #iodma_TestControl]

; check that the channel has entered state 110 (OIA) or 111 (OIB)

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]

	teqs	iodma_RTmp1, #iodma_status_OIA
	teqnes	iodma_RTmp1, #iodma_status_OIB

	iodma_Message	iodma_Illegal_State_Message, ne	; if it's not OIA, is bad

	MEND

; =================================================

; program BufA for a given channel

	MACRO
	iodma_ProgramBufA

	str	iodma_RStart, [iodma_RChannel, #iodma_iocurA]
	str	iodma_REnd, [iodma_RChannel, #iodma_ioendA]

	MEND

; =================================================

; program BufA for a given channel

	MACRO
	iodma_ProgramBufB

	str	iodma_RStart, [iodma_RChannel, #iodma_iocurB]
	str	iodma_REnd, [iodma_RChannel, #iodma_ioendB]

	MEND

; =================================================

; iodma_Test_SingleBuffer_BufA

; this macro tests the operation of transferring a single
; block on buffer A.


	MACRO
$label	iodma_Test_SingleBuffer_BufA	$start, $end, $dir, $width, $length

$label

	b	%ft20

	LCLA	nstart
nstart	SETA	$start

	LCLA	nend
nend	SETA	$end

	LCLA	nlength
nlength	SETA	$length

$label.L25

	DCB	"TUBE:IODMA Buf A single $nstart->$nend, $dir, $width, len=$nlength"
	DCB	0
	ALIGN	4

	LCLA	thing
thing	SETA	$label.L25


20

	iodma_Message	&$thing

; reset and enable the channel - also ensures that state OIA is entered


; store the expected length for the transfer
	ldr	iodma_RLength, =$length

	str	iodma_RLength, [iodma_RTest, #iodma_TestLength]	; set the length

	iodma_ResetChannel_Enable	$dir, $width

	ldr	iodma_RStart, =$start
	ldr	iodma_REnd, =$end

	iodma_ProgramBufA

; now wait for a state OIA to occur

30
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IA	; IA or OIA are the only states we're happy with
	beq	%bt30

	teqs	iodma_RTmp1, #iodma_status_OIA	; OIA implies transfer completed, anything else is a problem

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	; here, the transfer has completed; perform any necessary checks:

 [ check_length
	ldr	iodma_RTmp1, [iodma_RTest, #iodma_TestOffset]	; get the offset
	teqs	iodma_RTmp1, iodma_RLength	; check that the correct length has been transferred

	iodma_Message	iodma_Length_Error_Message, ne	; if the wrong transfer length occured, say so
 ]

	ldr	iodma_RTmp1, [iodma_RError]	; get the error register's contents

	tsts	iodma_RTmp1, #(1<<31)		; top bit set -> fail

	iodma_Message	iodma_Error_Message, ne		; if error, complain

;	iodma_ResetChannel_Disable		; disable the channel

	B	%ft40

	LTORG

40

	MEND

; =================================================

; iodma_Test_SingleBuffer_BufB

; this macro tests the operation of transferring a single
; block on buffer B.


	MACRO
$label	iodma_Test_SingleBuffer_BufB	$start, $end, $dir, $width, $length

$label
	b	%ft20

	LCLA	nstart
nstart	SETA	$start

	LCLA	nend
nend	SETA	$end

	LCLA	nlength
nlength	SETA	$length

$label.L25
	DCB	"TUBE:IODMA Buf B single $nstart->$nend, $dir, $width, len=$nlength"
	DCB	0
	ALIGN

	LCLA	thing
thing	SETA	$label.L25

20
	iodma_Message	&$thing

; reset and enable the channel - also ensures that state OIA is entered

	iodma_Enable	$dir, $width		; don't want to reset the channel

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]	; get channel's status

	teqs	iodma_RTmp1, #iodma_status_OIB		; check that it's OIB

	iodma_Message	iodma_Illegal_State_Message, ne	; if it's not OIA, is bad

; store the expected length for the transfer
	ldr	iodma_RLength, =$length
	ldr	iodma_RStart, =$start
	ldr	iodma_REnd, =$end

	str	iodma_RLength, [iodma_RTest, #iodma_TestLength]	; set the length

	iodma_ProgramBufB

; now wait for a state OIA to occur

30
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IB	; IA or OIA are the only states we're happy with
	beq	%bt30

	teqs	iodma_RTmp1, #iodma_status_OIB	; OIA implies transfer completed, anything else is a problem

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	; here, the transfer has completed; perform any necessary checks:

 [ check_length
	ldr	iodma_RTmp1, [iodma_RTest, #iodma_TestOffset]	; get the offset
	teqs	iodma_RTmp1, iodma_RLength	; check that the correct length has been transferred

	iodma_Message	iodma_Length_Error_Message, ne	; if the wrong transfer length occured, say so
 ]

	ldr	iodma_RTmp1, [iodma_RError]	; get the error register's contents

	tsts	iodma_RTmp1, #(1<<31)		; top bit set -> fail

	iodma_Message	iodma_Error_Message, ne		; if error, complain

;	iodma_ResetChannel_Disable		; disable the channel

	B	%ft40

	LTORG

40

	MEND

; =================================================

; iodma_Test_DoubleBuffer_BufA

; this macro tests the operation of transferring two blocks,
; one on buffer A, followed by one on buffer B.


	MACRO
$label	iodma_Test_DoubleBuffer_BufA	$startA, $endA, $startB, $endB, $dir, $width, $length

$label
	b	%ft20


	LCLA	nstartA
nstartA	SETA	$startA

	LCLA	nendA
nendA	SETA	$endA

	LCLA	nlength
nlength	SETA	$length


	LCLA	nstartB
nstartB	SETA	$startB

	LCLA	nendB
nendB	SETA	$endB


$label.L25
	DCB	"TUBE:IODMA Buf A double $nstartA->$nendA    $nstartB->$nendB, $dir, $width, len=$nlength"
	DCB	0
	ALIGN

	LCLA	thing
thing	SETA	$label.L25

20
	iodma_Message	&$thing

; reset and enable the channel - also ensures that state OIA is entered

	iodma_ResetChannel_Enable	$dir, $width

; store the expected length for the transfer
	ldr	iodma_RLength, =$length
	ldr	iodma_RStart, =$startA
	ldr	iodma_REnd, =$endA

	str	iodma_RLength, [iodma_RTest, #iodma_TestLength]	; set the length


; note:  perhaps we might want to program the buffers without the cost of the second
;        pair of LDRs?

	iodma_ProgramBufA

; we could check the state at this point, too; valid states would be IA or OIA

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IA	; valid
	teqnes	iodma_RTmp1, #iodma_status_OIA	; valid, perhaps

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	ldr	iodma_RStart, =$startB
	ldr	iodma_REnd, =$endB

	iodma_ProgramBufB

; now wait for a state OIB to occur; the state should

30
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_A	; while doing buff A
	beq	%bt30

	; from a should go to IB then to OIB
35
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IB	; while doing buff B
	beq	%bt35

	teqs	iodma_RTmp1, #iodma_status_OIB	;

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	; here, the transfer has completed; perform any necessary checks:

 [ check_length
	ldr	iodma_RTmp1, [iodma_RTest, #iodma_TestOffset]	; get the offset
	teqs	iodma_RTmp1, iodma_RLength	; check that the correct length has been transferred

	iodma_Message	iodma_Length_Error_Message, ne	; if the wrong transfer length occured, say so
 ]

	ldr	iodma_RTmp1, [iodma_RError]	; get the error register's contents

	tsts	iodma_RTmp1, #(1<<31)		; top bit set -> fail

	iodma_Message	iodma_Error_Message, ne		; if error, complain

;	iodma_ResetChannel_Disable		; disable the channel

	B	%ft40

	LTORG

40

	MEND

; =================================================

; iodma_Test_DoubleBuffer_BufB

; this macro tests the operation of transferring two blocks,
; one on buffer B, followed by one on buffer A.


	MACRO
$label	iodma_Test_DoubleBuffer_BufB	$startB, $endB, $startA, $endA, $dir, $width, $length

; reset and enable the channel - also ensures that state OIA is entered

	B	%ft20

	LCLA	nstartA
nstartA	SETA	$startA

	LCLA	nendA
nendA	SETA	$endA

	LCLA	nlength
nlength	SETA	$length


	LCLA	nstartB
nstartB	SETA	$startB

	LCLA	nendB
nendB	SETA	$endB

$label.L25
	DCB	"TUBE:IODMA Buf B double $nstartB->$nendB    $nstartA->$nendA, $dir, $width, len=$length"
	DCB	0
	ALIGN


	LCLA	thing
thing	SETA	$label.L25


20
	iodma_Message	&$thing

	iodma_Enable	$dir, $width

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]

	teqs	iodma_RTmp1, #iodma_status_OIB

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

; store the expected length for the transfer
	ldr	iodma_RLength, =$length
	ldr	iodma_RStart, =$startB
	ldr	iodma_REnd, =$endB

	str	iodma_RLength, [iodma_RTest, #iodma_TestLength]	; set the length


; note:  perhaps we might want to program the buffers without the cost of the second
;        pair of LDRs?

	iodma_ProgramBufB

; we could check the state at this point, too; valid states would be IA or OIA

	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IB	; valid
	teqnes	iodma_RTmp1, #iodma_status_OIB	; valid, perhaps less likely

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	ldr	iodma_RStart, =$startA
	ldr	iodma_REnd, =$endA

	iodma_ProgramBufA

; now wait for a state OIA to occur

30
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_B	; while doing buff B
	beq	%bt30

	; from a should go to IB then to OIB
35
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_IA	; while doing buff A
	beq	%bt35

	teqs	iodma_RTmp1, #iodma_status_OIA	;

	iodma_Message	iodma_Illegal_State_Message, ne	; if the state isn't legal, complain

	; here, the transfer has completed; perform any necessary checks:

 [ check_length
	ldr	iodma_RTmp1, [iodma_RTest, #iodma_TestOffset]	; get the offset
	teqs	iodma_RTmp1, iodma_RLength	; check that the correct length has been transferred

	iodma_Message	iodma_Length_Error_Message, ne	; if the wrong transfer length occured, say so
 ]

	ldr	iodma_RTmp1, [iodma_RError]	; get the error register's contents

	tsts	iodma_RTmp1, #(1<<31)		; top bit set -> fail

	iodma_Message	iodma_Error_Message, ne		; if error, complain

;	iodma_ResetChannel_Disable		; disable the channel

	B	%ft40

	LTORG

40

	MEND


;

; =====================================================================

	MACRO
	iodma_Setup_Chan0

	ldr	iodma_RChannel, =io0cura
	ldr	iodma_RTest,    =&0ff00000
	ldr	iodma_RError,   =&88000040
	ldr	iodma_RBuf,     =&0ff80000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan1

	ldr	iodma_RChannel, =io1cura
	ldr	iodma_RTest,    =&0ff00010
	ldr	iodma_RError,   =&88000044
	ldr	iodma_RBuf,     =&0ff90000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan2

	ldr	iodma_RChannel, =io2cura
	ldr	iodma_RTest,    =&0ff00020
	ldr	iodma_RError,   =&88000048
	ldr	iodma_RBuf,     =&0ffa0000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan3

	ldr	iodma_RChannel, =io3cura
	ldr	iodma_RTest,    =&0ff00030
	ldr	iodma_RError,   =&8800004C
	ldr	iodma_RBuf,     =&0ffb0000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan4

	ldr	iodma_RChannel, =io4cura
	ldr	iodma_RTest,    =&0ff00040
	ldr	iodma_RError,   =&88000050
	ldr	iodma_RBuf,     =&0ffc0000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan5

	ldr	iodma_RChannel, =io5cura
	ldr	iodma_RTest,    =&0ff00050
	ldr	iodma_RError,   =&88000054
	ldr	iodma_RBuf,     =&0ffd0000

	MEND

; =====================================================================

	MACRO
	iodma_Setup_Chan6

	ldr	iodma_RChannel, =io6cura
	ldr	iodma_RTest,    =&0ff00060
	ldr	iodma_RError,   =&88000058
	ldr	iodma_RBuf,     =&0ffe0000

	MEND

	MACRO
	iodma_Setup_Chan7

	ldr	iodma_RChannel, =io7cura
	ldr	iodma_RTest,    =&0ff00070
	ldr	iodma_RError,   =&8800005C
	ldr	iodma_RBuf,     =&0fff0000

	MEND

; =====================================================================

; this macro fills the given address range with test data

	MACRO
	iodma_Copy_Test_Data	$start, $length

 [ $length <> 0
	ldr	iodma_RStart, =$start
        ldr	iodma_RTmp1, =iodma_test_data
	ldr	iodma_RLength, =$length
	ldr	iodma_RTmp2, =0

10
	ldr	iodma_RTmp3, [iodma_RTmp1, iodma_RTmp2]
	str	iodma_RTmp3, [iodma_RStart, iodma_RTmp2]
	ldr	iodma_RBuf,  [iodma_RStart, iodma_RTmp2]
	teq	iodma_RTmp3, iodma_RBuf
	iodma_Message	iodma_Copy_Data_Fail_Message, ne
	add	iodma_RTmp2, iodma_RTmp2, #4
	and	iodma_RTmp2, iodma_RTmp2, #31
	subs	iodma_RLength, iodma_RLength, #4
	bne	%BT10
 ]

	MEND

; =====================================================================

	MACRO
	iodma_Check_Buffer_Data_Word		$data, $length

 [ $length <> 0
	mov	iodma_RStart, iodma_RBuf	; buffer
	ldr	iodma_RTmp1, =$data
	ldr	iodma_RLength, =$length

10
	ldr	iodma_RTmp2, [iodma_RTmp1], #4
	ldr	iodma_RTmp3, [iodma_RStart], #4
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	subs	iodma_RLength, iodma_RLength, #4
	bne	%BT10
 ]

	MEND

; =====================================================================

	MACRO
	iodma_Check_Buffer_Data_Byte		$data, $length

 [ $length <> 0
	mov	iodma_RStart, iodma_RBuf	; buffer
	ldr	iodma_RTmp1, =$data
	ldr	iodma_RLength, =$length

10
	ldrb	iodma_RTmp2, [iodma_RTmp1], #1
	ldrb	iodma_RTmp3, [iodma_RStart], #1
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	subs	iodma_RLength, iodma_RLength, #1
	bne	%BT10
 ]

	MEND

; =====================================================================

	MACRO
	iodma_Check_Buffer_Data_Wrap	$data, $length, $width

 [ $length <> 0
	mov	iodma_RStart, iodma_RBuf	; buffer
	ldr	iodma_RTmp1, =$data
	ldr	iodma_RLength, =$length

10
  [ ($width)=1
	ldrb	iodma_RTmp2, [iodma_RTmp1], #1
	ldrb	iodma_RTmp3, [iodma_RStart], #1
  ]
  [ ($width)=2
	ldr	iodma_RTmp2, [iodma_RTmp1], #2
	mov	iodma_RTmp2, iodma_RTmp2, lsl #16
	ldr	iodma_RTmp3, [iodma_RStart], #2
	mov	iodma_RTmp3, iodma_RTmp3, lsl #16
  ]
  [ ($width)=4
	ldr	iodma_RTmp2, [iodma_RTmp1], #4
	ldr	iodma_RTmp3, [iodma_RStart], #4
  ]
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	mov	iodma_RTmp2, #&ff
	orr	iodma_RTmp2, iodma_RTmp2, #&f00
	tsts	iodma_RTmp1, iodma_RTmp2
	subeq	iodma_RTmp1, iodma_RTmp1, #&1000
	subs	iodma_RLength, iodma_RLength, #($width)
	bne	%BT10
 ]

	MEND


; =====================================================================

; this macro is used to generate code to check the validity of data
; that has been read from one address, and written to another, under
; DMA

	MACRO
	iodma_Check_Data_Wrap	$data1, $data2, $length, $width

 [ $length <> 0
	ldr	iodma_RStart, =$data1	; buffer
	ldr	iodma_RTmp1, =$data2
	ldr	iodma_RLength, =$length

10
  [ ($width)=1
	ldrb	iodma_RTmp2, [iodma_RTmp1], #1
	ldrb	iodma_RTmp3, [iodma_RStart], #1
  ]
  [ ($width)=2
	ldr	iodma_RTmp2, [iodma_RTmp1], #2
	mov	iodma_RTmp2, iodma_RTmp2, lsl #16
	ldr	iodma_RTmp3, [iodma_RStart], #2
	mov	iodma_RTmp3, iodma_RTmp3, lsl #16
  ]
  [ ($width)=4
	ldr	iodma_RTmp2, [iodma_RTmp1], #4
	ldr	iodma_RTmp3, [iodma_RStart], #4
  ]
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	mov	iodma_RTmp2, #&ff
	orr	iodma_RTmp2, iodma_RTmp2, #&f00
	tsts	iodma_RTmp1, iodma_RTmp2
	subeq	iodma_RTmp1, iodma_RTmp1, #&1000
	tsts	iodma_RStart, iodma_RTmp2
	subeq	iodma_RStart, iodma_RStart, #&1000
	subs	iodma_RLength, iodma_RLength, #($width)
	bne	%BT10
 ]

	MEND

; =====================================================================

; this macro is used to check that data has been correctly transferred

; it should be used when

	MACRO
	iodma_Compare_Page_Data_Wrap	$start1, $start2, $data, $length, $width

 [ $length <> 0
	mov	iodma_RStart, =$start1	; buffer
	ldr	iodma_RTmp1, =$start2
	ldr	iodma_RLength, =$length

10
  [ ($width)=1
	ldrb	iodma_RTmp2, [iodma_RTmp1], #1
	ldrb	iodma_RTmp3, [iodma_RStart], #1
  ]
  [ ($width)=2
	ldr	iodma_RTmp2, [iodma_RTmp1], #2
	mov	iodma_RTmp2, iodma_RTmp2, lsl #16
	ldr	iodma_RTmp3, [iodma_RStart], #2
	mov	iodma_RTmp3, iodma_RTmp3, lsl #16
  ]
  [ ($width)=4
	ldr	iodma_RTmp2, [iodma_RTmp1], #4
	ldr	iodma_RTmp3, [iodma_RStart], #4
  ]
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	mov	iodma_RTmp2, #&ff
	orr	iodma_RTmp2, iodma_RTmp2, #&f00
	tsts	iodma_RTmp1, iodma_RTmp2
	subeq	iodma_RTmp1, iodma_RTmp1, #&1000
	tsts	iodma_RStart, iodma_RTmp2
	subeq	iodma_RStart, iodma_RStart, #&1000
	subs	iodma_RLength, iodma_RLength, #($width)
	bne	%BT10
 ]

	MEND

; =====================================================================

	MACRO
	iodma_Check_Buffer_Data_Half_Wrap	$data, $length

 [ $length <> 0
	mov	iodma_RStart, iodma_RBuf	; buffer
	ldr	iodma_RTmp1, =$data
	ldr	iodma_RLength, =$length

10
	ldr	iodma_RTmp2, [iodma_RTmp1], #2
	ldr	iodma_RTmp3, [iodma_RStart], #2
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	mov	iodma_RTmp2, #&ff
	orr	iodma_RTmp2, iodma_RTmp2, #&f00
	tsts	iodma_RTmp1, iodma_RTmp2
	subeq	iodma_RTmp1, iodma_RTmp1, #&1000
	subs	iodma_RLength, iodma_RLength, #2
	bne	%BT10
 ]

	MEND

; =====================================================================

	MACRO
	iodma_Check_Buffer_Data_Word_Wrap	$data, $length

 [ $length <> 0
	mov	iodma_RStart, iodma_RBuf	; buffer
	ldr	iodma_RTmp1, =$data
	ldr	iodma_RLength, =$length

10
	ldr	iodma_RTmp2, [iodma_RTmp1], #4
	ldr	iodma_RTmp3, [iodma_RStart], #4
	teqs	iodma_RTmp2, iodma_RTmp3
	iodma_Message	iodma_Error_Data_Message, ne
	mov	iodma_RTmp2, #&ff
	orr	iodma_RTmp2, iodma_RTmp2, #&f00
	tsts	iodma_RTmp1, iodma_RTmp2
	subeq	iodma_RTmp1, iodma_RTmp1, #&1000
	subs	iodma_RLength, iodma_RLength, #4
	bne	%BT10
 ]

	MEND



;

; =============================================================

; the MACRO iodma_DoTest_SingleBuffer_BufA generates code for read
; transfer, followed by a write transfer.  readstart and writestart
; give the addresses to read from and write to

	MACRO
$label	iodma_DoTest_SingleBuffer_BufA		$readstart, $writestart, $length, $width

	ASSERT	(($width)=1):LOR:(($width)=2):LOR:(($width)=4)	; byte, half or word width
	ASSERT	($length)<=4096
	ASSERT	($length)<>0
	ASSERT	(($readstart) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($length) :AND:(($width)-1))=0		; or else complain

	LCLA	readend
 [ ($length)=($width)
readend		SETA	((($readstart+$length)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
readend		SETA	((($readstart+$length)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer A byte read ":CC::STR:($start):CC:",":CC:"$end"
$label.DoTest_SingleBuffer_BufA_l1	iodma_Test_SingleBuffer_BufA		$readstart, &$readend, iod_read, $width, $length

	LCLA	writeend
 [ ($length)=($width)
writeend	SETA	((($writestart+$length)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
writeend	SETA	((($writestart+$length)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

$label.DoTest_SingleBuffer_BufA_l2	iodma_Test_SingleBuffer_BufA		$writestart, &$writeend, iod_write, $width, $length

	iodma_Check_Data_Wrap			$readstart, $writestart, $length, $width

	MEND


; =============================================================

; the MACRO iodma_DoTest_DoubleBuffer_BufAB generates code for a
; double buffer read, followed by a double buffer write.  readstart and
; writestart give the addresses to read from and write to

	MACRO
$label	iodma_DoTest_DoubleBuffer_BufA		$readstart1, $writestart1, $length1, $readstart2, $writestart2, $length2, $width

	ASSERT	(($width)=1):LOR:(($width)=2):LOR:(($width)=4)	; byte, half or word width
	ASSERT	($length1)<=4096
	ASSERT	($length1)<>0
	ASSERT	($length2)<=4096
	ASSERT	($length2)<>0
	ASSERT	(($readstart1) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart1) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($readstart2) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart2) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($length1) :AND:(($width)-1))=0		; or else complain
	ASSERT	(($length2) :AND:(($width)-1))=0		; or else complain

	LCLA	readend1
 [ ($length1)=($width)
readend1		SETA	((($readstart1+$length1)-($width)) :AND: &fff) :OR: (iodma_LastBit)		; work out the new end
 |
readend1		SETA	((($readstart1+$length1)-($width)) :AND: &fff)				; work out the new end
 ]

	LCLA	readend2
 [ ($length2)=($width)
readend2		SETA	((($readstart2+$length2)-($width)) :AND: &fff) :OR: (iodma_LastBt+iodma_StopBit)		; work out the new end
 |
readend2		SETA	((($readstart2+$length2)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

;	! 0, "Single buffer A byte read ":CC::STR:($start):CC:",":CC:"$end"
$label.DoTest_DoubleBuffer_BufA_l1	iodma_Test_DoubleBuffer_BufA		$readstart1, &$readend1, $readstart2, &$readend2, iod_read, $width, ($length1 + $length2)

	LCLA	writeend1
 [ ($length1)=($width)
writeend1	SETA	((($writestart1+$length1)-($width)) :AND: &fff) :OR: (iodma_LastBit)	; work out the new end
 |
writeend1	SETA	((($writestart1+$length1)-($width)) :AND: &fff)				; work out the new end
 ]

	LCLA	writeend2
 [ ($length2)=($width)
writeend2	SETA	((($writestart2+$length2)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
writeend2	SETA	((($writestart2+$length2)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

$label.DoTest_DoubleBuffer_BufA_l2	iodma_Test_DoubleBuffer_BufA		$writestart1, &$writeend1, $writestart2, &$writeend2, iod_write, $width, ($length1 + $length2)

	iodma_Check_Data_Wrap			$readstart1, $writestart1, $length1, $width
	iodma_Check_Data_Wrap			$readstart2, $writestart2, $length2, $width

	MEND


; =============================================================

; the MACRO iodma_DoTest_SingleBuffer_BufB generates code for read
; transfer, followed by a write transfer.  readstart and writestart
; give the addresses to read from and write to

	MACRO
$label	iodma_DoTest_SingleBuffer_BufB		$readstart, $writestart, $length, $width

	ASSERT	(($width)=1):LOR:(($width)=2):LOR:(($width)=4)	; byte, half or word width
	ASSERT	($length)<=4096
	ASSERT	($length)<>0
	ASSERT	(($readstart) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($length) :AND:(($width)-1))=0		; or else complain

	LCLA	readend
 [ ($length)=($width)
readend		SETA	((($readstart+$length)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
readend		SETA	((($readstart+$length)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer A byte read ":CC::STR:($start):CC:",":CC:"$end"
$label.DoTest_SingleBuffer_BufB_l1	iodma_Test_SingleBuffer_BufB		$readstart, &$readend, iod_read, $width, $length

	LCLA	writeend
 [ ($length)=($width)
writeend	SETA	((($writestart+$length)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
writeend	SETA	((($writestart+$length)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

$label.DoTest_SingleBuffer_BufB_l2	iodma_Test_SingleBuffer_BufB		$writestart, &$writeend, iod_write, $width, $length

	iodma_Check_Data_Wrap			$readstart, $writestart, $length, $width

	MEND


; =============================================================

; the MACRO iodma_DoTest_DoubleBuffer_BufB generates code for a
; double buffer read, followed by a double buffer write.  readstart and
; writestart give the addresses to read from and write to

	MACRO
$label	iodma_DoTest_DoubleBuffer_BufB		$readstart1, $writestart1, $length1, $readstart2, $writestart2, $length2, $width

$label
	ASSERT	(($width)=1):LOR:(($width)=2):LOR:(($width)=4)	; byte, half or word width
	ASSERT	($length1)<=4096
	ASSERT	($length1)<>0
	ASSERT	($length2)<=4096
	ASSERT	($length2)<>0
	ASSERT	(($readstart1) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart1) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($readstart2) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($writestart2) :AND:(($width)-1))=0		; check that start and length are multiple of width
	ASSERT	(($length1) :AND:(($width)-1))=0		; or else complain
	ASSERT	(($length2) :AND:(($width)-1))=0		; or else complain

	LCLA	readend1
 [ ($length1)=($width)
readend1		SETA	((($readstart1+$length1)-($width)) :AND: &fff) :OR: (iodma_LastBit)		; work out the new end
 |
readend1		SETA	((($readstart1+$length1)-($width)) :AND: &fff)				; work out the new end
 ]

	LCLA	readend2
 [ ($length2)=($width)
readend2		SETA	((($readstart2+$length2)-($width)) :AND: &fff) :OR: (iodma_LastBt+iodma_StopBit)		; work out the new end
 |
readend2		SETA	((($readstart2+$length2)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

;	! 0, "Single buffer A byte read ":CC::STR:($start):CC:",":CC:"$end"
$label.iodma_DoTest_DoubleBuffer_BufB_l1	iodma_Test_DoubleBuffer_BufB		$readstart1, &$readend1, $readstart2, &$readend2, iod_read, $width, ($length1 + $length2)

	LCLA	writeend1
 [ ($length1)=($width)
writeend1	SETA	((($writestart1+$length1)-($width)) :AND: &fff) :OR: (iodma_LastBit)	; work out the new end
 |
writeend1	SETA	((($writestart1+$length1)-($width)) :AND: &fff)				; work out the new end
 ]

	LCLA	writeend2
 [ ($length2)=($width)
writeend2	SETA	((($writestart2+$length2)-($width)) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
writeend2	SETA	((($writestart2+$length2)-($width)) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]

$label.iodma_DoTest_DoubleBuffer_BufB_l2	iodma_Test_DoubleBuffer_BufB		$writestart1, &$writeend1, $writestart2, &$writeend2, iod_write, $width, ($length1 + $length2)

	iodma_Check_Data_Wrap			$readstart1, $writestart1, $length1, $width
	iodma_Check_Data_Wrap			$readstart2, $writestart2, $length2, $width

	MEND

; =============================================================

; the MACRO iodma_DoAByteReadTest_SingleBuffer_BufA generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAByteReadTest_SingleBuffer_BufA		$start, $length

	ASSERT	($length)<=4096

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-1) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-1) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer A byte read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufA		$start, &$end, 0, iodma_width_byte, $length
	iodma_Check_Buffer_Data_Byte_Wrap	$start, $length

	MEND

; =============================================================

; the MACRO iodma_DoAByteReadTest_SingleBuffer_BufB generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAByteReadTest_SingleBuffer_BufB		$start, $length

	ASSERT	($length)<=4096

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-1) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-1) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer B byte read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufB		$start, &$end, 0, iodma_width_byte, $length
	iodma_Check_Buffer_Data_Byte_Wrap	$start, $length

	MEND


; =============================================================

; the MACRO iodma_DoAWordReadTest_SingleBuffer_BufA generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAWordReadTest_SingleBuffer_BufA		$start, $length

	ASSERT	($length)<=4096
	ASSERT	(($start) :AND:3)=0
	ASSERT	(($length) :AND:3)=0

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-4) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer A word read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufA		$start, &$end, 0, iodma_width_word, $length
	iodma_Check_Buffer_Data_Word_Wrap	$start, $length

	MEND

; =============================================================

; the MACRO iodma_DoAWordReadTest_SingleBuffer_BufB generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAWordReadTest_SingleBuffer_BufB		$start, $length

	ASSERT	($length)<=4096
	ASSERT	(($start) :AND:3)=0
	ASSERT	(($length) :AND:3)=0

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-4) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer B word read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufB		$start, &$end, 0, iodma_width_word, $length
	iodma_Check_Buffer_Data_Word_Wrap	$start, $length

	MEND


; =============================================================

; the MACRO iodma_DoAHalfReadTest_SingleBuffer_BufA generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAHalfReadTest_SingleBuffer_BufA		$start, $length

	ASSERT	($length)<=4096
	ASSERT	(($start) :AND:1)=0
	ASSERT	(($length) :AND:1)=0

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-2) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-2) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer A word read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufA		$start, &$end, 0, iodma_width_word, $length
	iodma_Check_Buffer_Data_Half_Wrap	$start, $length

	MEND

; =============================================================

; the MACRO iodma_DoAHalfReadTest_SingleBuffer_BufB generates code for a byte
; transfer.  start is the start address, and length is the
; end address.  it doesn't cope with wraparound of the transfer
; (yet)

	MACRO
	iodma_DoAHalfReadTest_SingleBuffer_BufB		$start, $length

	ASSERT	($length)<=4096
	ASSERT	(($start) :AND:1)=0
	ASSERT	(($length) :AND:1)=0

	LCLA	end
 [ $length=1
end	SETA	((($start+$length)-2) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)		; work out the new end
 |
end	SETA	((($start+$length)-2) :AND: &fff) :OR: (iodma_StopBit)				; work out the new end
 ]
;	! 0, "Single buffer B word read ":CC::STR:($start):CC:",":CC:"$end"
	iodma_Test_SingleBuffer_BufB		$start, &$end, 0, iodma_width_word, $length
	iodma_Check_Buffer_Data_Half_Wrap	$start, $length

	MEND

	GBLA	iodma_channel
iodma_channel	SETA	0


iodma_test_data
        DCD     &01234567
        DCD     &12345678
        DCD     &23456789
        DCD     &3456789A
        DCD     &456789AB
        DCD     &56789ABC
        DCD     &6789ABCD
        DCD     &789ABCDE

; here is the IODMA_TEST

; MACRO iodma_GenerateTestCases

	MACRO
$label	iodma_GenerateSingleBufferTestCases	$base, $buffer, $width

; read from start of page at base addr, write to end of page at base addr, one three transfer, no wrap
$label.gs_l1	iodma_DoTest_SingleBuffer_Buf$buffer	($base	+&000)	, ($base + &2000-$width*3), $width*3 , $width

; read from start of page, two unit transfer, write to end of page, two unit transfer, wrapping
$label.gs_l2	iodma_DoTest_SingleBuffer_Buf$buffer	($base	+&000)	, ($base + &2000-$width), $width*2 , $width

; read from end of page, three unit transfer, with wrap, write to start of page unit

$label.gs_l3	iodma_DoTest_SingleBuffer_Buf$buffer	($base	+&2000-($width*2)), ($base + &1000), $width*3 , $width

	MEND

	MACRO
$label	iodma_GenerateDoubleBufferTestCases	$base, $buffer, $width

$label.gb_l1	iodma_DoTest_DoubleBuffer_Buf$buffer	($base + &000), ($base + &4000-$width*3), $width*3, ($base + &1000-$width*3), ($base + &2000), $width*3, $width
$label.gb_l2	iodma_DoTest_DoubleBuffer_Buf$buffer	($base + &000), ($base + $width*3), $width*3, ($base + &1000-$width*3), ($base + &1000-$width*6), $width*3, $width

	MEND

; we use the side effect that the source data at the start of the page ends up generating new source data in the next page

iodma_DoTheSingleTests
;	iodma_Copy_Test_Data			sdram0_base, 3*4
;t1a	iodma_GenerateSingleBufferTestCases	sdram0_base, A, 4
;t2a	iodma_GenerateSingleBufferTestCases	sdram0_base+&1000, A, 4
;t3a	iodma_GenerateSingleBufferTestCases	sdram0_base+&2000, A, 4
;t4a	iodma_GenerateSingleBufferTestCases	sdram0_base+&3000, A, 2
;t5a	iodma_GenerateSingleBufferTestCases	sdram0_base+&4000, A, 2
;t6a	iodma_GenerateSingleBufferTestCases	sdram0_base+&5000, A, 1
;t7a	iodma_GenerateSingleBufferTestCases	sdram0_base+&6000, A, 1
;
;	iodma_Copy_Test_Data			sdram1_base, 3*4
;
;t1d	iodma_GenerateDoubleBufferTestCases	sdram1_base, A, 4
;t2d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&02000, B, 4
;t3d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&04000, A, 4
;t4d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&08000, B, 2
;t5d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&0a000, A, 2
;t6d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&0c000, B, 1
;t7d	iodma_GenerateDoubleBufferTestCases	sdram1_base+&10000, A, 1
;
;	iodma_Copy_Test_Data			sdram0_base+&10000, 3*4
;t1b	iodma_GenerateSingleBufferTestCases	sdram0_base+&10000, B, 4
;t2b	iodma_GenerateSingleBufferTestCases	sdram0_base+&11000, B, 4
;t3b	iodma_GenerateSingleBufferTestCases	sdram0_base+&12000, B, 4
;t4b	iodma_GenerateSingleBufferTestCases	sdram0_base+&13000, B, 2
;t5b	iodma_GenerateSingleBufferTestCases	sdram0_base+&14000, B, 2
;t6b	iodma_GenerateSingleBufferTestCases	sdram0_base+&15000, B, 1
;t7b	iodma_GenerateSingleBufferTestCases	sdram0_base+&16000, B, 1

	iodma_DoTheTests

	mov	pc, lr

	MACRO
	iodma_Set_Cycle_Type	$type

	ldr	iodma_RTmp1, =($type)+(($type)<<2)+(($type)<<4)+(($type)<<6)+(($type)<<8)+(($type)<<10)+(($type)<<12)+(($type)<<14)
	ldr	iodma_RTmp2, =iodma_CycleTypeReg
	ldr	iodma_RTmp3, =dmatcr
	str	iodma_RTmp1, [iodma_RTmp2]
	str	iodma_RTmp1, [iodma_RTmp3]

	MEND

; ====================================================================

; multichannel DMA transfers

; Multi channel DMA transfers are a more complex case.  We do not wish
; to exhaustively test all possible cases.  We thus set up multichannel
; operation to supply the following variations:

; 1) Transfer a single buffer from either buffer A or buffer B, on
;    a selected range of channels.  We vary the length of transfer
;    for each channel.  Where a length of zero is set for a given
;    channel, no transfer is performed on that channel.

; our method is to start transfers on all the channels, then wait
; for all of the channels to terminate, and then check the data
; validity for all the channels

; this macro deals with programming the channels up.  We set the
; variables according to the values in the macro call.

; we set the variables iodma_Channel0_start1 etc.

; variable numbers of parameters are supported, to allow full control
; over things.

	MACRO
	iodma_ChannelSetUp	$channel, $dir, $width, $start1, $length1, $start2, $length2

	GBLA	iodma_dir_Channel$channel
	GBLA	iodma_width_Channel$channel
	GBLA	iodma_start1_Channel$channel
	GBLA	iodma_start2_Channel$channel
	GBLA	iodma_length1_Channel$channel
	GBLA	iodma_length2_Channel$channel
	GBLA	iodma_width_Channel$channel

 [ "$dir"=""
iodma_dir_Channel$channel	SETA	0
iodma_width_Channel$channel	SETA	0
 |
iodma_dir_Channel$channel	SETA	$dir
iodma_width_Channel$channel	SETA	$width
 ]

 [ "$start1"=""
iodma_start1_Channel$channel	SETA	0
iodma_length1_Channel$channel	SETA	0
 |
iodma_start1_Channel$channel	SETA	$start1
iodma_length1_Channel$channel	SETA	$length1
 ]


 [ "$start2"=""
iodma_start2_Channel$channel	SETA	0
iodma_length2_Channel$channel	SETA	0
 |
iodma_start2_Channel$channel	SETA	$start2
iodma_length2_Channel$channel	SETA	$length2
 ]
	MEND

; ===========================================================================

; this macro programs buffer A, then buffer B, for a given channel

	MACRO
	iodma_ChannelProgramAB	$channel

	LCLA	length1
	LCLA	length2
	LCLA	start1
	LCLA	end1
	LCLA	start2
	LCLA	end2

length1	SETA	&$iodma_length1_Channel$channel
length2	SETA	&$iodma_length2_Channel$channel
start1	SETA	&$iodma_start1_Channel$channel
start2	SETA	&$iodma_start2_Channel$channel


 [ $length1<>0

   [ $length2<>0

; first transfer won't have a stop bit

     [ $length1=4
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_LastBit)		; work out the new end
     |
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff)					; work out the new end
     ]


     [ $length2=4
end2	SETA	(((&$start2+&$length2)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)	; work out the new end
     |
end2	SETA	(((&$start2+&$length2)-4) :AND: &fff) :OR: (iodma_StopBit)		; work out the new end
     ]

	iodma_Setup_Chan$channel

; now, have to program the direction and width for this channel

	iodma_ResetChannel_Enable	&$iodma_dir_Channel$channel, &$iodma_width_Channel$channel


	ldr	iodma_RStart,=&$start1
	ldr	iodma_REnd,=&$end1

	iodma_ProgramBufA

	ldr	iodma_RStart,=&$start2
	ldr	iodma_REnd,=&$end2

	iodma_ProgramBufB

   |

; first transfer will have a stop bit, as it's the only transfer
     [ $length1=4
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)	; work out the new end
     |
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_StopBit)		; work out the new end
     ]

	iodma_Setup_Chan$channel

	iodma_ResetChannel_Enable	&$iodma_dir_Channel$channel, &$iodma_width_Channel$channel

	ldr	iodma_RStart,=&$start1
	ldr	iodma_REnd,=&$end1

	iodma_ProgramBufA
   ]

 ]

	MEND


; ============================================================================================

; this macro programs buffer B, then buffer A, for a given channel

	MACRO
	iodma_ChannelProgramBA	$channel

	LCLA	length1
	LCLA	length2
	LCLA	start1
	LCLA	end1
	LCLA	start2
	LCLA	end2

length1	SETA	&$iodma_length1_Channel$channel
length2	SETA	&$iodma_length2_Channel$channel
start1	SETA	&$iodma_start1_Channel$channel
start2	SETA	&$iodma_start2_Channel$channel


 [ $length1<>0

   [ $length2<>0

; first transfer won't have a stop bit

     [ $length1=4
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_LastBit)		; work out the new end
     |
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff)					; work out the new end
     ]


     [ $length2=4
end2	SETA	(((&$start2+&$length2)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)	; work out the new end
     |
end2	SETA	(((&$start2+&$length2)-4) :AND: &fff) :OR: (iodma_StopBit)		; work out the new end
     ]

	iodma_Setup_Chan$channel

	iodma_ResetChannel_Enable	&$iodma_dir_Channel$channel, &$iodma_width_Channel$channel

	ldr	iodma_RStart,=&$start1
	ldr	iodma_REnd,=&$end1

	iodma_ProgramBufB

	ldr	iodma_RStart,=&$start2
	ldr	iodma_REnd,=&$end2

	iodma_ProgramBufA

   |

; first transfer will have a stop bit, as it's the only transfer
     [ $length1=4
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_LastBit+iodma_StopBit)	; work out the new end
     |
end1	SETA	(((&$start1+&$length1)-4) :AND: &fff) :OR: (iodma_StopBit)		; work out the new end
     ]

	iodma_Setup_Chan$channel

	iodma_ResetChannel_Enable	&$iodma_dir_Channel$channel, &$iodma_width_Channel$channel

	ldr	iodma_RStart,=&$start1
	ldr	iodma_REnd,=&$end1

	iodma_ProgramBufB
   ]

 ]

	MEND

; ===============================================================================

; this MACRO generates code which will wait for a given channel to complete.

; $channel gives the number of the channel we want to wait for

; $state gives the target state.  we wait for an idle state to occur (ie either OIA or OIB)

	MACRO
	iodma_ChannelWait	$channel

	iodma_Setup_Chan$channel	; set stuff up

10
	ldr	iodma_RTmp1, [iodma_RChannel, #iodma_iost]
	teqs	iodma_RTmp1, #iodma_status_OIA
	teqnes	iodma_RTmp1, #iodma_status_OIB
	bne	%bt10

	MEND

; ===============================================================================

; once the channels have all been

; ===============================================================================

; this MACRO does it all

	MACRO
	iodma_WaitForAllChannels

	iodma_ChannelWait	0
	iodma_ChannelWait	1
	iodma_ChannelWait	2
	iodma_ChannelWait	3
	iodma_ChannelWait	4
	iodma_ChannelWait	5
	iodma_ChannelWait	6
	iodma_ChannelWait	7

	MEND


; macro to check channel data was transferred correctly; this uses the buffer
; area for that channel

	MACRO
	iodma_CheckChannelData	$channel

	LCLA	length1
	LCLA	length2
	LCLA	start1
	LCLA	end1
	LCLA	start2
	LCLA	end2

length1	SETA	&$iodma_length1_Channel$channel
length2	SETA	&$iodma_length2_Channel$channel
start1	SETA	&$iodma_start1_Channel$channel
start2	SETA	&$iodma_start2_Channel$channel


 [ length1<>0	; IF any data has been set up for this channel
	iodma_Setup_Chan$channel	; setup for this channel

	iodma_Check_Buffer_Data_Wrap	$start1, $length1,  &$iodma_width_Channel$channel
	iodma_Check_Buffer_Data_Wrap	$start2, $length2,  &$iodma_width_Channel$channel
 ]

	MEND


; =========================================================================

; =========================================================================

; This section of the code deals with testing IODMA IRQ routing.


; =========================================================================

; This macro resets and disables all the channels.

	MACRO
	iodma_Reset_Disable_All_Channels

	LCLA	channel
	LCLS	schannel

channel	SETA	0

	WHILE	channel<8
schannel	SETS	"$channel":RIGHT:1
	iodma_Setup_Chan$schannel

	iodma_ResetChannel_Disable

channel	SETA	&$channel+1

	WEND

	MEND


; =========================================================================

; MACRO to check that DMAST has the correct value

	MACRO
	iodma_Check_DMAST	$checkval

	ldr	iodma_RTmp1, =dmast
	ldr	iodma_RTmp1, [iodma_RTmp1]
	ldr	iodma_RTmp2, =$checkval
	teqs	iodma_RTmp1, iodma_RTmp2

	iodma_Message	iodma_DMAST_Message, ne

	MEND

; =========================================================================

 [ {TRUE}

; this subroutine performs all the IODMA checks for IRQ routing

iodma_DMAST0	*	&0f0e
iodma_DMAST1	*	&0f0d
iodma_DMAST2	*	&0f0b
iodma_DMAST3	*	&0f07
iodma_DMAST4	*	&0e0f
iodma_DMAST5	*	&0d0f
iodma_DMAST6	*	&0b0f
iodma_DMAST7	*	&070f

iodma_DMAMSK_List
	DCD	&0000
	DCD	&0001
	DCD	&0002
	DCD	&0004
	DCD	&0008
	DCD	&0100
	DCD	&0200
	DCD	&0400
	DCD	&0800
	DCD	&0f0f
	DCD	&00ff		; this is the end of list marker

	LTORG

iodma_Test_IRQ_Routing ROUT

	iodma_Reset_Disable_All_Channels

	iodma_Check_DMAST	&0f0f		; everything should be shouting for an IRQ

	GBLA	iodma_channel
	GBLS	iodma_schannel



	WHILE	iodma_channel<8

iodma_schannel	SETS	"$iodma_channel":RIGHT:1

	ldr	iodma_RStart,=sdram0_base
	ldr	iodma_REnd,=&ffc

	iodma_Setup_Chan$iodma_schannel

	iodma_ProgramBufA
	iodma_ProgramBufB

	iodma_Check_DMAST	iodma_DMAST$iodma_schannel	; channel 0 should not be IRQing

	adrl	iodma_RTmp1, iodma_DMAMSK_List

1$iodma_channel
	ldr	iodma_RTmp3, [iodma_RTmp1], #4
	teqs	iodma_RTmp3, #&ff		; ff is the end market
	beq	%ft2$iodma_channel

	ldr	iodma_RTmp2, =dmamsk
	str	iodma_RTmp3, [iodma_RTmp2]

	ldr	iodma_RTmp2, =iodma_DMAST$iodma_schannel
	and	iodma_RTmp3, iodma_RTmp2, iodma_RTmp3

	ldr	iodma_RTmp2, =dmarq
	ldr	iodma_RTmp2, [iodma_RTmp2]

	teqs	iodma_RTmp3, iodma_RTmp2

	iodma_Message	iodma_DMARQ_Message, ne

	b	%bt1$iodma_channel

2$iodma_channel

	iodma_ResetChannel_Disable		; reset the channel, so that its IRQ bit comes back

	iodma_Check_DMAST	&0f0f		; check it's gone back to where it should

iodma_channel	SETA	iodma_channel+1

	WEND


	mov	pc, lr

 ]

	LTORG


	EXPORT	IODMA_TEST
IODMA_TEST	ROUT

	mov	iodma_Link, lr

	ldr	iodma_FastTube, =fasttube

	iodma_Reset_Disable_All_Channels	; disable all the channels

	iodma_Set_Cycle_Type		0

 [ iodma_Test_Routing

	BL	iodma_Test_IRQ_Routing
 ]

 	iodma_Setup_Chan0
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan1
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan2
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan3
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan4
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan5
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan6
	BL iodma_DoTheSingleTests

 	iodma_Setup_Chan7
	BL iodma_DoTheSingleTests


	mov	pc, iodma_Link

	END


