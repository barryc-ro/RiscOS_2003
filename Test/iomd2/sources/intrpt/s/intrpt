; File:    irqtest.s
; Purpose: Test interrupt routing and selection in IOMD2
; Author:  Timothy Roddis
; History: 01-Mar-1998: TGR: created
;

                            ;
IRQ_TESTSTART_MESS
        DCB     "TUBE:Irq test testing beginning",&0
IRQ_TESTEND_MESS
        DCB     "TUBE:Irq test testing completed",&0
IRQ_TESTPASS_MESS
        DCB     "TUBE:Irq test PASSED test",0
IRQ_RESET_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to reset to correct values", 4, 0
IRQ_CLRSTATFAIL_MESS
        DCB     "TUBE:Irq test FAILED to clear status register", 4, 0
IRQ_MAINROUTERESET_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to reset main routing", 4, 0
IRQ_OLDINT_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to set old interrupt status bit", 4, 0
IRQ_OLDRQ_FAIL_MESS
       DCB     "TUBE:Irq test FAILED  to set old interrupt request bit", 4, 0
IRQ_OLDPIRQ_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to route old interrupt as expected", 4, 0
IRQ_OLDIRQ_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to set backward compatibility status",4,0
IRQ_EXTSTAT_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to show external interrupt status",4,0
IRQ_EXTRQ_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to show external interrupt request", 4, 0
IRQ_EXTROUTE_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to route external interrupt",4,0
IRQ_INTSERSTAT_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to show internal interrupt status",4,0
IRQ_INTSERRQ_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to show internal interrupt request", 4, 0
IRQ_INTSERROUTE_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to route internal interrupt",4,0
IRQ_DMASTAT_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to show DMA interrupt status",4,0
IRQ_DMARQ_FAIL_MESS
       DCB     "TUBE:Irq test FAILED to show DMA interrupt request", 4, 0
IRQ_DMAROUTE_FAIL_MESS
        DCB     "TUBE:Irq test FAILED to route DMA interrupt",4,0
        ALIGN

;; Start of the actual Irq test code
IRQ_TEST ROUT

        ;; Send test starting message
        LDR     R0,=IRQ_TESTSTART_MESS
        LDR     R10,=fasttube
        STR     R0,[R10]

; Start testing sequence

        LDR     r6, =irqsta      
        LDR     r7, =intrtea     ; r7 -> clist interrupt routing tables
        LDR     r8, =intstatmon  ; r8 -> proc I/F interrupt status
        LDR     r9, =intstat
        
        LDRB    r2,[r8]          ; get proc I/F status 
        TEQ     r2,#&ff
;        LDRNE   r12,=IRQ_IFINTSRESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r9]         ; get enhanced bank status
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_MAINSTATRESET_FAIL_MESS
;        BNE     IRQ_TESTEND

        LDREQ   r2, [r9, #4]     ; get enhanced bank enable
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_MAINSENBLRESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r9, #8]     ; get enhanced bank request
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_MAINSREQRESET_FAIL_MESS
;        BNE     IRQ_TESTEND

        LDREQ   r2, [r6]         ; get old, old irq A status reg
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQSTARESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r6, #4]     ; get old, old irq A request
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQRQARESET_FAIL_MESS
;        BNE     IRQ_TESTEND

        LDREQ   r2, [r6, #8]     ; get old, old irq A enable
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQENARESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r6, #&10]   ; get old, old irq B status reg
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQSTBRESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r6, #&14]   ; get old, old irq B request
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQRQBRESET_FAIL_MESS
;        BNE     IRQ_TESTEND

        LDREQ   r2, [r6, #&18]   ; get old, old irq B enable
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQENBRESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r6, #&20]   ; get old, old fiq status reg
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQSTBRESET_FAIL_MESS
;        BNE     IRQ_TESTEND
        
        LDREQ   r2, [r6, #&24]   ; get old, old fiq request
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQRQBRESET_FAIL_MESS
;        BNE     IRQ_TESTEND

        LDREQ   r2, [r6, #&28]   ; get old, old fiq enable
        TEQEQ   r2, #0
;        LDRNE   r12,=IRQ_IRQENBRESET_FAIL_MESS
        LDRNE   r12,=IRQ_RESET_FAIL_MESS
        BNE     IRQ_TESTEND
        
 [ 1 <> 1

; check intlvl???


; check routing tables are correct defaults

        LDR     r2, [r7]        ; intrtea
        TEQ     r2, #0
        LDREQ   r2, [r7, #4]    ; intrteb
        TEQEQ   r2, #0
        LDREQ   r2, [r7, #8]    ; intrtec
        TEQEQ   r2, #0
        LDREQ   r2, [r7, #12]   ; intrted
        TEQEQ   r2, #0
        LDREQ   r2, [r7, #16]    ; intrtee
        TEQEQ   r2, #0
        LDRNE   r12,=IRQ_MAINROUTERESET_FAIL_MESS
        BNE     IRQ_TESTEND
 ]
        
        LDR     r12,=intstat
        MOV     r2, #0
        STR     r2,[r12, #4]
        LDR     r2,[r12, #4]
        TEQ     r2, #0
        LDRNE   r12,=IRQ_CLRSTATFAIL_MESS
        BNE     IRQ_TESTEND

;----------------------------------------------------------------------------
; test backward compatible interrupts

; IOMD2 should reset in a state where the IOMD1 backward compatible
; registers are configured as needed.

           ^       0
ExtInt     #       4
ExtType    #       4
OldIntAddr #       4
OldIntMask #       4

        LDR     r0, =IRQ_TESTDATA_START
        LDR     r1, =IRQ_TESTDATA_END
        LDR     r5, =fiqst
        LDR     r6, =extintcfg00
        LDR     r7, =irqtest
        LDR     r11,=extintcause
10
        LDR     r2, [r0], #4   ; get ext/int/ser irq no.
        
        MOV     r3, #1
        MOV     r3, r3, LSL r2 ; select appropriate interrupt bit

        CMP     r2, #16        ; internal/serial or external?

        LDRLO   r4, [r0], #4   ; get external irq type
        STRLO   r4, [r6,r2]    ; setup type
        STRLO   r3, [r11]      ; set interrupt
        
        STRHS   r3, [r7]       ; internal/serial interrupt
        ADDHS   r0, r0, #4     ; skip over type


        LDR     r2, [r0], #4   ; get address of irq status reg.
        LDR     r4, [r0], #4   ; get bit pos in reg

; test backward compatible status reg.
        LDR     r9, [r2]       ; r9 := olde-fashioned status reg contents
        TEQ     r9, r4         ; is it set how we expect
        LDRNE   r12,=IRQ_OLDINT_FAIL_MESS
        BNE     IRQ_TESTEND

; test backwarf compatible request bit
        STR     r3,  [r2, #8]  ; enable interrupt
        LDR     r12, [r2, #4]  ; get request bits (offset 4 from status)
        TEQ     r12, r3        ; expect bit pattern?
        LDRNE   r12,=IRQ_OLDRQ_FAIL_MESS
        BNE     IRQ_TESTEND
        
        TEQ     r2, r5         ; see which irq reg is in use
        MOVEQ   r9, #(1 :SHL: 5) :EOR: &ff ; pfiq[0]
        MOVNE   r9, #1:EOR &ff             ; pirq[0]

        LDRB    r12, [r8]      ; get status of proc I/F interrupts
        TEQ     r12,r9
        LDRNE   r12,=IRQ_OLDPIRQ_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r3, #0
        STR     r3, [r11]      ; zero causes of interrupts
        STR     r3, [r7]
        LDR     r9, =intstat   ; zero main status reg
        STR     r3, [r9]
 
        CMP     r0, r1
        BLO     %BT10

        

;============================================================================
; test enhanced interrupts

; interrupt ids:
;
;  000 - irq 0  |  010 - irq 2  |  100 - irq 4  |  110 - irq 6
;  001 - irq 1  |  011 - irq 3  |  101 - irq 5  |  111 - irq 7
;

; zero a few things

        MOV     r3, #0
        STR     r3, [r7]      ; zero internal/serial/DMA interrupt cause
        STR     r3, [r11]     ; zero external interrupt cause
        LDR     r7, =intrtea     ; r7 -> clist interrupt routing tables
        STR     r3, [r7]      ; zero routing info: intrtea
        STR     r3, [r7, #4]  ; intrteb
        STR     r3, [r7, #8]  ; intrtec
        STR     r3, [r7, #12] ; intrted
        STR     r3, [r7, #16] ; intrtee
        LDR     r0, =intlvl
        STR     r3, [r0]      ; zero level info
        
; test generator??? (rising, falling edge, eacg level?)


;----------------------------------------------------------------------------
; test external interrupts

        MOV     r3, #1
        LDR     r9, =intstat
        MOV     r5, #0           ; 0..12 => extern ints
        MOV     r12,#0
30
        MOV     r4, #7         ; r4 is iterrupt id (outward) ie. routing value
         
40
        AND     r2, r5, #7         ; 0 .. 7 interrupts per word
        ADD     r2, r2, r2, LSL #1 ; spaced every 3 bits
        MOV     r1, r4, LSL r2 ; write routing info into relevant position
        STR     r1, [r7, r5, LSR #3] ; in correct routing word

        MOV     r1, r3, LSL r5
        STR     r1, [r11]      ; cause interrupt (active high)

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        STR     r2, [r9, #8]          ; enable
        LDR     r2, [r9, #4]          ; get request
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_EXTRQ_FAIL_MESS
        BNE     IRQ_TESTEND

        LDRB    r2, [r8]              ; check interrupt bit (and only that bit)
        EOR     r2, r2, #&ff
        TEQ     r2, r3, LSL r4        ; is set in instatmon
        LDRNE   r12,=IRQ_EXTROUTE_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r2, #0
        STR     r2, [r9, #8]          ; disable everything again

        SUBS    r4, r4, #1
        BGE     %BT40
        
; check each type of interrupt

        MOV     r4, #4+1       ; level, active lo
        
        MOV     r1, r4, LSL r5 ; move up two places
        MOV     r1, r1, LSL r5 ; for each value of r5
        
        STR     r1, [r0]       ; configure interrupt sensitivity type

        MOV     r2, r3, LSL r5 ; go
        STR     r2,[r11]       ; hi

; signal hi, trigger on lo

        LDR     r2, [r9]
        TEQ     r2, #0
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        STR     r12, [r11]     ; clear extern causes

        STR     r4, [r6, r5]   ; configure interrupt test type to lo

        MOV     r2, r3, LSL r5 ; go
        STR     r2,[r11]       ; lo

; signal lo, trigger on lo

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r4, #4+0       ; level, active hi
        
        MOV     r1, r4, LSL r5 ; move up two places
        MOV     r1, r1, LSL r5 ; for each value of r5
        
        STR     r1, [r0]       ; configure interrupt sensitivity type

        MOV     r2, r3, LSL r5 ; go
        STR     r2,[r11]       ; lo

; signal lo, tigger on hi

        LDR     r2, [r9]
        TEQ     r2, #0
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

; now test edge irqs
        
        MOV     r4, #4+2       ; rising edge
        
        MOV     r1, r4, LSL r5 ; move up two places
        MOV     r1, r1, LSL r5 ; for each value of r5
        
        STR     r1, [r0]       ; configure interrupt sensitivity type
        
        STR     r12, [r11]     ; clear extern causes

        STR     r4, [r6, r5]   ; configure interrupt test type to rising edge

        STR     r12, [r9, #4]  ; clear latched interrupts

        MOV     r2, r3, LSL r5 ; generate
        STR     r2,[r11]       ; rising edge

; generated rising edge, trigger on rising edge

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r4, #4+3       ; falling edge

        MOV     r1, r4, LSL r5 ; move up two places
        MOV     r1, r1, LSL r5 ; for each value of r5
        
        STR     r1, [r0]       ; configure interrupt sensitivity type (-ve)

        STR     r12, [r11]     ; clear extern causes

        STR     r12, [r9, #4]  ; clear latched interrupts

        MOV     r2, r3, LSL r5 ; generate
        STR     r2, [r11]      ; rising edge

; generated rising edge, trigger on falling edge

        LDR     r2, [r9]
        TEQ     r2, #0
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND
        
        STR     r12, [r11]     ; clear extern causes

        STR     r4, [r6, r5]   ; configure interrupt test type to falling edge
        
        STR     r12, [r9, #4]  ; clear latched interrupts

        MOV     r2, r3, LSL r5 ; generate
        STR     r2,[r11]       ; falling edge

; generated falling edge, trigger on falling edge

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r4, #4+2       ; rising edge

        MOV     r1, r4, LSL r5 ; move up two places
        MOV     r1, r1, LSL r5 ; for each value of r5
        
        STR     r1, [r0]       ; configure interrupt sensitivity type (-ve)

        STR     r12, [r11]     ; clear extern causes

        STR     r12, [r9, #4]  ; clear latched interrupts

        MOV     r2, r3, LSL r5 ; generate
        STR     r2, [r11]      ; falling edge

; generated falling edge, trigger on rising edge

        LDR     r2, [r9]
        TEQ     r2, #0
        LDRNE   r12,=IRQ_EXTSTAT_FAIL_MESS
        BNE     IRQ_TESTEND
 
        ADD     r5, r5, #1
        CMP     r5,#12 ; 0.12 external enhanced interrupts
        BLE     %BT30

        MOV     r2, #0
        STR     r2, [r11]      ; clear all interrupts

;----------------------------------------------------------------------------
; test internal and serial interrupts
        MOV     r5, #16          ; internal and serial interrupts
        LDR     r6, =irqtest
50
        MOV     r4, #0         ; r4 is iterrupt id (outward)
        MOV     r2, r3, LSL r5 ; bit position for interrupt
        STR     r2, [r6]       ; fake interrupt
60

        AND     r2, r5, #7         ; 0 .. 7 interrupts per word
        ADD     r2, r2, r2, LSL #1 ; spaced every 3 bits

        MOV     r1, r4, LSL r2 ; write routing info into relevant position
        STR     r1, [r7, r5, LSR #3] ; in correct routing word

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_INTSERSTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        STR     r2, [r9, #8]          ; enable
        LDR     r2, [r9, #4]          ; get request
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_INTSERRQ_FAIL_MESS
        BNE     IRQ_TESTEND

        LDRB    r2, [r8]              ; check interrupt bit (and only that bit)
        EOR     r2, r2, #&ff
        TEQ     r2, r3, LSL r4        ; is set in instatmon
        LDRNE   r12,=IRQ_INTSERROUTE_FAIL_MESS
        BNE     IRQ_TESTEND

        MOV     r2, #0
        STR     r2, [r9, #8]          ; disable everything again

        ADD     r4, r4, #1
        CMP     r4, #7
        BLE     %BT60

        ADD     r5, r5, #1
        CMP     r5,#29 ; 16..29 (incl) internal enhanced interrupts
        BLE     %BT50


;----------------------------------------------------------------------------
; test DMA
        MOV     r5, #0           ; DMA
        LDR     r6, =irqtest
        LDR     r7, =intrtee
70
        MOV     r4, #0         ; r4 is iterrupt id (outward)
        MOV     r2, r3, LSL r5 ; bit position for interrupt
        STR     r2, [r6]       ; fake interrupt
80
        ADD     r2, r5, r5, LSL #1 ; routing spaced every 3 bits

        MOV     r1, r4, LSL r2 ; write routing info into relevant position
        STR     r1, [r7]

        LDR     r2, [r9]
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_DMASTAT_FAIL_MESS
        BNE     IRQ_TESTEND

        STR     r2, [r9, #8]          ; enable
        LDR     r2, [r9, #4]          ; get request
        TEQ     r2, r3, LSL r5
        LDRNE   r12,=IRQ_DMARQ_FAIL_MESS
        BNE     IRQ_TESTEND

        LDRB    r2, [r8]              ; check interrupt bit (and only that bit)
        EOR     r2, r2, #&ff
        TEQ     r2, r3, LSL r4        ; is set in instatmon
        LDRNE   r12,=IRQ_DMAROUTE_FAIL_MESS
        BNE     IRQ_TESTEND

        ADD     r4, r4, #1
        CMP     r4, #7
        BLE     %BT60

        ADD     r5, r5, #1
        CMP     r5,#7  ; 16..31 internal enhanced interrupts
        BLE     %BT50

        LDR     r12,=IRQ_TESTPASS_MESS

IRQ_TESTEND
        LDR     R10,=fasttube
        STR     R12,[R10]

        ;; Send test complete message
        LDR     R0,=IRQ_TESTEND_MESS
        LDR     R10,=fasttube
        STR     R0,[R10]

        ; Unstack return address
        MOV     PC,LR

IRQ_TESTDATA_START
        DCD     28 ; Pintr
        DCD     1
        DCD     irqsta
        DCD     1

        DCD     5 ; Nindex
        DCD     3
        DCD     irqsta
        DCD     1:SHL:2

        DCD     6 ; Flybk
        DCD     2
        DCD     irqsta
        DCD     1:SHL:3
        
        DCD     22 ; por
        DCD     1 ; ???
        DCD     irqsta
        DCD     1:SHL:4
        
        DCD     16 ; timer 0
        DCD     1 ; ???
        DCD     irqsta
        DCD     1:SHL:5
        
        DCD     17 ; timer 1
        DCD     1 ; ???
        DCD     irqsta
        DCD     1:SHL:6

        DCD     0 ; npfiq
        DCD     1 
        DCD     irqstb
        DCD     1

        DCD     3 ; nidea
        DCD     1
        DCD     irqstb
        DCD     1:SHL:1

        DCD     25 ; Nsintr/sintr0
        DCD     1 
        DCD     irqstb
        DCD     1:SHL:2

        DCD     4 ; nideb
        DCD     1
        DCD     irqstb
        DCD     1:SHL:3
        
        DCD     27 ; Nfintr
        DCD     1
        DCD     irqstb
        DCD     1:SHL:4

        DCD     1 ; npirq
        DCD     1
        DCD     irqstb
        DCD     1:SHL:5
        
        DCD     24 ; kirq
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:6
        
        DCD     29 ; mirq
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:7
 [ {FALSE}       
        DCD     18 ; timer 2
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:10
        
        DCD     19 ; timer 3
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:11
        
        DCD     20 ; timer 4
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:12
        
        DCD     21 ; timer 5
        DCD     1 ; ???
        DCD     irqstb
        DCD     1:SHL:13
 ]
        DCD     12 ;Fdrq
        DCD     0
        DCD     fiqst
        DCD     1:SHL:0
        
        DCD     4 ; Nideb
        DCD     1 
        DCD     fiqst
        DCD     1:SHL:1
        
        DCD     25 ; Nsintr/sintr0
        DCD     1 
        DCD     fiqst
        DCD     1:SHL:4
        
        DCD     0 ; npfiq
        DCD     1 
        DCD     fiqst
        DCD     1:SHL:6

IRQ_TESTDATA_END

	LTORG

        END

