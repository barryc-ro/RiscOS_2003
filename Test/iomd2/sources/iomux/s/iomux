;	--------------------------------------------
; 	© Acorn Computers Ltd. 1998
;
; 	IOMD2 Multiplex signals from IO cycle generator test
;	--------------------------------------------
;	Steve Taylor
;
;	0.0a	04.03.98	initial
;	0.0b	10.03.98	Change to fasttube output instead of tube,
;				implemented continue_after_error switching
;	0.0c	11.03.98	Spotted some out-of-date procedures, fixed
;				them. Moved data to end of code
;	0.0d	24.03.98	Implemented new &68xxxxxx error register addresses
;				Also a common initialisation code sequence will have been added
;				at the integration stage






;	------------------------------------------------
;	Writes a message to Tube
;	Requires that tube_defin has been Got beforehand
;	------------------------------------------------

	MACRO
$tubewrm	write_message	$message

$tubewrm
	LDR	r12, =$message		; Pointer to message
	LDR	r11, =fasttube		; Pointer to the FastTube address
	STR	r12,[r11]		; Send the message

	MEND




	EXPORT	iomux_test
iomux_test
; Test begins

; Setup some registers
	MOV	R13,LR					; Save LR for return later
	write_message	iomux_testbegin_message

	LDR	R1,=testpattern

; Setup relevent registers for A,C,E,F tests
IOMUX_ACEF_SETUP
	LDR	R2,=iotcr			; Point to IOTCR
	MOV	R3,#0
	STR	R3,[R2]					; Clear IOTCR
	MOV	R0,#0					; Clear our internal error register


	LDR	R3,=IOMUX_ECTCR_CYCACEF+0		; Get the ectcr dataword for 1st pass
	LDR	R2,=iomux_cyclea_addr			; Set access address
	LDR	R4,=iomux_cycleacef_error_register	; Set error register

IOMUX_ACEF_LOOP
	LDR	R5,=ectcr
	LDR	R8,[R3]
	STR	R8,[R5]					; Set ectcr register with test value

	STR	R1,[R2]					; Write the testpattern
	LDR	R6,[R2]					; Read it back
	CMPS	R1,R6					; Is it the same as was written?
	ORRNE	R0,R0,#&01

	LDR	R5,[R4]					; Get iomux error register
	TST	R5,#iomux_errorbit			; Did the error register flag failure?
	ORREQ	R0,R0,#&02

	CMP	R0,#0
	BLNE	IOMUX_FAILURE				; Go report errors to tube

	ADD	R2,R2,#&10				; Increment next access address
	ADD	R3,R3,#4				; Increment data pointer
	LDR	R6,=(IOMUX_ECTCR_CYCACEF+(4*4))
	CMPS	R3,R6					; Any data defs left to read?

	BLT	IOMUX_ACEF_LOOP				; If not, get next dataword to verify against


; Setup registers for cycle types D+G

IOMUX_DG_SETUP
	LDR	R4,=iotcr

; Do cycles D+G
IOMUX_DG_TEST
	LDR	R3,=IOMUX_ECTCR_CYCDG+0			; Pointer to first dataword for IOTCR
	LDR	R2,=iomux_cycled_addr			; First access address
	LDR	R5,=iomux_cycledg_error_register	; Current error register

IOMUX_DG_LOOP
	LDR	R6,[R3]
	STR	R6,[R2]					; Set IOTCR to test value

	STR	R1,[R2]					; Write testpattern to current address
	LDR	R6,[R2]					; Read it back
	CMPS	R1,R6					; Are they the same?
	ORRNE	R0,R0,#&01

	LDR	R6,[R5]
	TST	R6,#iomux_errorbit                      ; Has error register failbit been set?
	ORREQ	R0,R0,#&02

	CMP	R0,#0					; Were any errors flagged during test?
	BLNE	IOMUX_FAILURE

	SUB	R2,R2,#&30				; Decrement to next address as per spec
	ADD	R3,R3,#4
	LDR	R6,=(IOMUX_ECTCR_CYCDG+(2*4))
	CMPS	R3,R6					; Reached end of test IOCTR datawords yet?

	BLT	IOMUX_DG_LOOP


; Setup registers for devsel(n) tests
IOMUX_DEVSEL_SETUP
	LDR	R4,=iotcr
	MOV	R3,#0					; Arbitrary value until told otherwise
	STR	R3,[R4]

	LDR	R4,=ectcr				; Similarly here
	STR	R3,[R4]

; Do devsel(n) tests
IOMUX_DEVSEL_TEST
	LDR	R4,=(IOMUX_DEVSEL_ACCESS+0)		; Pointer to list of test access addresses
	LDR	R5,=(IOMUX_DEVSEL_ERRORREG+0)		; Pointer to list of test error register locations

IOMUX_DEVSEL_LOOP
	LDR	R2,[R4]					; Get current address
	STR	R1,[R2]					; Write testpattern to the address
	LDR	R3,[R2]					; Read it back
	CMPS	R1,R3					; Are they the same?
	ORRNE	R0,R0,#01				; Set our "verify
							; failed" bit


	LDR	R6,[R5]					; Read error register for this iteration
	TST	R6,#iomux_errorbit			; Was an error flagged?
	ORREQ	R0,R0,#02				; Set our "failure bit asserted" bit


	CMP	R0,#0					; Has test affected our internal error flags?
	BLNE	IOMUX_FAILURE

	ADD	R4,R4,#4				; Increment address list pointer
	ADD	R5,R5,#4				; Increment errorreg list pointer
	LDR	R7,=(IOMUX_DEVSEL_ACCESS+(4*10))
	CMPS	R4,R7					; Finished our list of addresses?

	BLT	IOMUX_DEVSEL_LOOP



; Get out
IOMUX_END
	write_message	iomux_testend_message		; Test Ends

	MOV	PC,R13					; Return



; --------- Test fail routines


; A function failed
; Here we try to find out which one, and then report to Tube

IOMUX_FAILURE
	LDR	R10,=dump_r2
	STR	R2,[R10]				; Print the current address

	LDR	r10,=dump_r3
	STR	R3,[r10]				; Print (unshifted) data


	LDR	R10,=dump_r6
	STR	R6,[r10]				; Print the error register


	CMPS	R0,#&01					; Was only the "verify failed" bit set?
	BLEQ	IOMUX_VERIFY_INEQUALITY			; ie. written+read data was unequal
							; but the error register didn't show it

	CMPS	R0,#&02					; Was only the "failure bit" bit set?
	BLEQ	IOMUX_FAIL_INEQUALITY			; ie. error register thought failure occurred
							; but data had verified OK

	CMPS	R0,#&03					; Were v+f bits set?
	BLEQ	IOMUX_VERIFICATION_FAILED		; ie. error register and verification agreed
							; that an error occurred

	MOV	R0,#0					; Clear our failure register

	MOV	PC,LR					; Return to calling routine





IOMUX_VERIFY_INEQUALITY
	write_message	iomux_verifyinequality_message
	MOV	PC,LR

IOMUX_FAIL_INEQUALITY
	write_message	iomux_failbitinequality_message
	MOV	PC,LR

IOMUX_VERIFICATION_FAILED
	write_message	iomux_verifyfalse_message
        MOV	PC,LR




iomux_testbegin_message
	DCB	"TUBE:IOMUX Tests BEGIN",&0

iomux_verifyfalse_message
	DCB	"TUBE:IOMUX Verify FAILED: Data was false"
	DCB	CONTINUE_AFTER_ERROR, 0
iomux_verifyinequality_message
	DCB	"TUBE:IOMUX Verify FAILED: But iomux_ErrorRegister flagged No Error!"
	DCB	CONTINUE_AFTER_ERROR, 0
iomux_failbitinequality_message
	DCB	"TUBE:IOMUX Verify SUCCESSFUL: But iomux_ErrorRegister flagged FAILURE!"
	DCB	CONTINUE_AFTER_ERROR, 0

iomux_testpass_message
	DCB	"TUBE:IOMUX Tests PASSED",&0

iomux_testend_message
	DCB	"TUBE:IOMUX Test END",&0

	ALIGN

testpattern	*	&12345678			; Arbitrary test pattern
iomux_errorbit	*	&80000000			; io_model error register fail flag

iomux_cyclea_addr	*	&08010000		; Cycletype A base - cycles C-F offset from here
iomux_cycled_addr	*	&03800030

iomux_cycleacef_error_register	*	&6803C024	; Cycletypes A-F error report register base
iomux_cycledg_error_register	*	&6803C01C	; Cycletype D,G error report register base


; ECTCR register contents for cycle types A,C,E,F

IOMUX_ECTCR_CYCACEF
	DCD	&0
	DCD	&01
	DCD	&0200
	DCD	&0300

; ECTCR register contents for cycle types D + G

IOMUX_ECTCR_CYCDG
	DCD	&0300
	DCD	&0000

; Access address table for devsel signals

IOMUX_DEVSEL_ACCESS
	DCD	&03000000
	DCD	&03030000
	DCD	&03010000
	DCD	&03012000
	DCD	&0301A000
	DCD	&0302B000
	DCD	&0302C000
	DCD	&03210000
	DCD	&03800000
	DCD	&03900000

; Error registers for devsel signals

IOMUX_DEVSEL_ERRORREG
	DCD	&0303C004
	DCD	&0303C004
	DCD	&0303C008
	DCD	&0303C00C
	DCD	&0303C00C
	DCD	&0303C010
	DCD	&0303C014
	DCD	&0303C018
	DCD	&0303C01C
	DCD	&0303C020



	END



