  [ IOMD2Support
;
MemSizePhoebe
;
; for VRAM, we currently assume 4M is always there
;
; for SDRAM, we can cope with organisation of 11..14 rows, 8..11 columns, capacity of 4 to 128M
; in one DIMM, 1 or 2 banks in DIMM (if 2 banks, must be symmetric) (max total of 256M currently
; supported - 512M may be possible but will need looking at when/if suitable DIMMs exist)

; symbols for serial presence detect (SPD) 
; (we assume that Timer0 is already set up and running - needed by SPD routines)
;
  [ PhoebeBodge
SDRAMI2C_addr0       * &a4        ;address for slot 0  (old FPGA PCB)
SDRAMI2C_addr1       * &a2        ;address for slot 1  (old FPGA PCB)
  |
SDRAMI2C_addr0       * &a2        ;address for slot 0
SDRAMI2C_addr1       * &a4        ;address for slot 1
  ]
SDRAMI2C_Nrows       * 3          ;byte 3 holds number of rows in SDRAM organisation
SDRAMI2C_Ncolumns    * 4
SDRAMI2C_Nbanks      * 5
SDRAMI2C_bankdensity * 31

;first, determine organisation (rows,columns) of SDRAM in each slot, and program SDRAMCR
;
        MOV     r7,#0                 ;accumulate bits for programming SDRAMCR
        MOV     r0,#SDRAMI2C_addr0
        BL      SPD_PreRead
        BVS     %FT10                 ;nothing in slot0
        MOV     r0,#SDRAMI2C_Nrows
        MOV     r1,#SDRAMI2C_addr0
        BL      SPD_ReadValue         ;read number of rows for slot0 SDRAM
        SUBS    r0,r0,#11
        BMI     BadSDRAMPanic
        CMP     r0,#3
        BHI     BadSDRAMPanic
        ORR     r7,r7,r0,LSL #2       ;(11..14 rows means 0..3 in RAS0 bits of SDRAMCR)
        MOV     r0,#SDRAMI2C_addr0
        BL      SPD_PreRead
        MOV     r0,#SDRAMI2C_Ncolumns
        MOV     r1,#SDRAMI2C_addr0
        BL      SPD_ReadValue         ;read number of columns for slot0 SDRAM
        SUBS    r0,r0,#8
        BMI     BadSDRAMPanic
        CMP     r0,#3
        BHI     BadSDRAMPanic
        ORR     r7,r7,r0              ;(8..11 columns means 0..3 in CAS0 bits of SDRAMCR)
10
        MOV     r0,#SDRAMI2C_addr1
        BL      SPD_PreRead
        BVS     %FT20                 ;nothing in slot1
        MOV     r0,#SDRAMI2C_Nrows
        MOV     r1,#SDRAMI2C_addr1
        BL      SPD_ReadValue         ;read number of rows for slot1 SDRAM
        SUBS    r0,r0,#11
        BMI     BadSDRAMPanic
        CMP     r0,#3
        BHI     BadSDRAMPanic
        ORR     r7,r7,r0,LSL #6       ;(11..14 rows means 0..3 in RAS1 bits of SDRAMCR)
        MOV     r0,#SDRAMI2C_addr1
        BL      SPD_PreRead
        MOV     r0,#SDRAMI2C_Ncolumns
        MOV     r1,#SDRAMI2C_addr1
        BL      SPD_ReadValue         ;read number of columns for slot1 SDRAM
        SUBS    r0,r0,#8
        BMI     BadSDRAMPanic
        CMP     r0,#3
        BHI     BadSDRAMPanic
        ORR     r7,r7,r0,LSL #4       ;(8..11 columns means 0..3 in CAS1 bits of SDRAMCR)
20
        MOV     r12,#IOMD_Base
        STR     r7,[r12,#IOMD2_SDRAMCR]

;next determine sizes of SDRAM in each slot, and fill in PhysRamTable
;
        MOV     r7,#0                 ;accumulate 4 bytes of info in r7
        MOV     r0,#SDRAMI2C_addr0
        BL      SPD_PreRead
        BVS     %FT30                 ;nothing in slot0
        MOV     r0,#SDRAMI2C_Nbanks
        MOV     r1,#SDRAMI2C_addr0
        BL      SPD_ReadValue         ;read number of banks for slot0 SDRAM
        ORR     r7,r7,r0
        MOV     r0,#SDRAMI2C_addr0
        BL      SPD_PreRead
        MOV     r0,#SDRAMI2C_bankdensity
        MOV     r1,#SDRAMI2C_addr0
        BL      SPD_ReadValue         ;read bank density for slot0 SDRAM
        ORR     r7,r7,r0,LSL #8
30
        MOV     r0,#SDRAMI2C_addr1
        BL      SPD_PreRead
        BVS     %FT40                 ;nothing in slot1
        MOV     r0,#SDRAMI2C_Nbanks
        MOV     r1,#SDRAMI2C_addr1
        BL      SPD_ReadValue         ;read number of banks for slot1 SDRAM
        ORR     r7,r7,r0,LSL #16
        MOV     r0,#SDRAMI2C_addr1
        BL      SPD_PreRead
        MOV     r0,#SDRAMI2C_bankdensity
        MOV     r1,#SDRAMI2C_addr1
        BL      SPD_ReadValue         ;read bank density for slot1 SDRAM
        ORR     r7,r7,r0,LSL #24
40
        TEQ     r7,#0
        BEQ     BadSDRAMPanic         ;no SDRAM!

;note that we can safely use SDRAM now (wait for Precharge has happened, and we have programmed correct rows,columns)

        LDR     r3, =DRAMOffset_PageZero + PhysRamTable
        TST     r7, #&FF
        ADDNE   r3, r3, #DRAM0PhysRam                       ;address of first fragment pair in PhysRamTable (slot 0 present)
        ADDEQ   r3, r3, #DRAM4PhysRam                       ;address of first fragment pair in PhysRamTable (slot 0 absent)
        MOV     r2, r3
        MOV     r1, #&400000       ;always assume 4M VRAM
        MOV     r0, #VideoPhysRam
        STMIA   r3!, {r0,r1}       ;video fragment is 4M VRAM
;
        MOV     r0, #DRAM0PhysRam  ;first fragment address for slot 0
42
        ANDS    r8, r7, #&FF
        BEQ     %FT50              ;nothing in slot
        CMP     r8, #2
        BHI     BadSDRAMPanic
        ADD     r8, r8, r8         ;no. of fragments for slot 0 (2 or 4, for 1 or 2 banks)   
        MOV     r1, r7, LSR #8
        AND     r1, r1, #&FF
        TEQ     r1, #1             ;4M in one or both banks
        TEQNE   r1, #2             ;8M
        TEQNE   r1, #4             ;16M
        TEQNE   r1, #8             ;32M
        TEQNE   r1, #16            ;64M
        TEQNE   r1, #32            ;128M
        BNE     BadSDRAMPanic
        MOV     r1, r1, LSL #21    ;size of each fragment (bank splits into two half-size fragments)
        TEQ     r8, #2
        MOVEQ   r9, #DRAM2PhysRam - DRAM0PhysRam  ;step between fragments if 2 fragments
        MOVNE   r9, #DRAM1PhysRam - DRAM0PhysRam  ;step between fragments if 4 fragments
44
        STMIA   r3!, {r0,r1}       ;next fragment
        ADD     r0, r0, r9
        SUBS    r8, r8, #1
        BNE     %BT44
50
        MOVS    r7, r7, LSR #16    ;move to slot 1, if not already done
        MOV     r0, #DRAM4PhysRam  ;first fragment address for slot 1
        BNE     %BT42

        ASSERT  Phoebe_VRAMsize = &400000
        MOV     r6, #4                                   ; 4M of VRAM
        STR     r6, [r2, #VRAMWidth-PhysRamTable]        ; store width of VRAM (4M)
        MOV     r7, #SAMLength/2/256*2                   ; use VRAM mode, and set increment for 2*1/2 SAM
        LDR     r10, =320000000                          ; 320E6 bytes/sec bandwidth (about right for 50MHz SAM clk ???)
        MOV     r14, #IOMD_Base
        STRB    r7, [r14, #IOMD_VIDCR]
        MOV     r12, #VideoPhysRam
        STR     r12, [r14, #IOMD_VIDCUR]                 ; set up VIDCUR to start of video RAM
        STR     r12, [r14, #IOMD_VIDSTART]               ; do same for VIDSTART
        STR     r12, [r14, #IOMD_VIDINIT]                ; and for VIDINIT
                                                         ; so we don't get crap when we turn video DMA on later
        STR     r10, [r2, #VideoBandwidth-PhysRamTable]  ; store video bandwidth

        ADD     r10, r12, #1024*1024-4096                ; add on a bit to form VIDEND (will be on mult. of SAM)
        STR     r10, [r14, #IOMD_VIDEND]                 ; yes I know it's a bit of a bodge

        MOV     r14, r6, LSL #20                         ; convert amount of VRAM to bytes
        STR     r14, [r2, #VRAMSize-PhysRamTable]        ; and store

  [ Phoebe_SoftROM
    ;
    ; we want to automagically soft load ROM into RAM if not already done (warm reset), because of the enormous speed
    ; advantage of SDRAM versus ROM

        ADRL    r14, ROM                                 ; use PC-relative addressing to get to start of image
        TEQ     r14, #PhysROM                            ; see if we are currently running from ROM
        BNE     %FT70                                    ; if not, then it's a warm reset and we're already running from RAM

        ADD     r7, r2, #2*4                             ; -> first of SDRAM chunks in PhysRamTable
        MOV     r14, #0                                  ; suitable chunk not found yet
        MOV     r10, #0                                  ; used to sum total SDRAM size

60
        LDMIA   r7!, {r4, r5}                            ; address, size
        ADD     r10, r10, r5                             ; total size so far
        CMP     r5, #OSROM_ImageSize*1024
        MOVHS   r14, r4                                  ; big enough chunk (we know it's 1M aligned), so remember it
        CMP     r7, r3
        BLO     %BT60

        CMP     r10, #OSROM_ImageSize*1024 + &1000000
        MOVLT   r14, #0                                  ; don't soft load if it will leave less than 16M of SDRAM
        TEQ     r14, #0
        BEQ     %FT70
        STR     r14, [r2, #SoftROMaddr-PhysRamTable]     ; if we found a suitable chunk, reserve start of chunk for soft ROM
        MOV     r7, r2                                   ; -> start of PhysRamTable
        MOV     r10, r3                                  ; -> 1st byte after end of table
        B       MemSizeSoftROMreserved

70
  ] ; Phoebe_SoftROM

        MOV     r7, r2                                   ; -> start of PhysRamTable
        MOV     r10, r3                                  ; -> 1st byte after end of table
        B       MemSizeTotalRAM

;
BadSDRAMPanic
        B       BadSDRAMPanic

  ] ;IOMD2Support

