; s.hello
;
; Modification History
; 06-Mar-97  TMD	Created, based on Keith Clarke's program
; 18-Nov-97  TMD	Modified from startup

;		ORG	&10000000
		ORG 	&0000

		GBLL	SDRAMAtZero
SDRAMAtZero	SETL	{FALSE}

SDRAM_Base	*	&10000000	;DRAM SIMM 0 BANK 0 ON RISCPC
SDRAM_Size	*	&00400000	; SDRAM size - only used if InitSDRAMSizing=FALSE

BANK0_Base	*	&10000000
BANK0_End	*	&10800000
BANK1_Base	*	&18000000
BANK1_End	*	&18800000
BANK2_Base	*	&20000000
BANK2_End	*	&20800000
BANK3_Base	*	&28000000
BANK3_End	*	&28800000

LEDS		*	&02000000

		GBLL	RiscPC
RiscPC		SETL	{FALSE}

		GBLL	TestPCIAborts
TestPCIAborts	SETL	{FALSE}

		GBLL	InitSDRAMSizing
InitSDRAMSizing	SETL	{FALSE}

		GBLL    LEDTwiddling
LEDTwiddling	SETL	{FALSE}

		GBLL    IRQsOn
IRQsOn		SETL	{FALSE}

		GBLL	OldSDRAMTest
OldSDRAMTest	SETL	{FALSE}

		GBLL	TestingIRQs
TestingIRQs	SETL	{FALSE}

		GBLL	TurnICacheOnAtStart
TurnICacheOnAtStart SETL {FALSE}

		GBLL	TurnOnMMU
TurnOnMMU	SETL	{FALSE}

		GBLL	UseFastCacheInvalidate
UseFastCacheInvalidate SETL {FALSE}	; doesn't work on Pass 1 hardware

                GBLL Leggett
Leggett         SETL {TRUE}

                GBLS VersionString
VersionString   SETS "0.02 (16 Sep 98)"


	OPT	1+128

LF	*	10	; Linefeed character
CR	* 	13	; Carrage return character



	GET	s.GetAll
	GET	h.UART
	GET	h.UARTDebug

; Macros
	MACRO
	UARTRxEcho $reg, $uart, $temp
	UARTRx	$reg, $uart
	UARTTx	$reg, $uart, $temp
	MEND


StartOfROM
RESET	B	MAIN
UNDEF	B	UndefHandler
SWI	B	SWIHandler
ABORTA  B	IAbortHandler
ABORTD	B	DAbortHandler
ADDEX	B	AddExHandler				; Now reserved as no 26 bit config
IRQ	B	IRQHandler
FIQ	B	FIQHandler

MAIN
 [ TurnICacheOnAtStart
	SetCop2	r0, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r0, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	LDR	r0, =MMUC_P :OR: MMUC_D :OR: MMUC_L :OR: MMUC_I	; 32-bit program/data, little endian, instruction cache on
 |
	MOV	r0, #MMUC_P :OR: MMUC_D :OR: MMUC_L
 ]
	SetCop	r0, CR_Control

 [ Leggett
        ; Reset Timer 0
        MOV     R2, #IOC
        MOV     r0, #0
        STRB    r0, [r2, #Timer0LL]
        MOV     r0, #16
        STRB    r0, [r2, #Timer0LH]

        ; FIQ_R12 is used to store status when running sequence of tests
        ; FIQ R11 is used to store the number of failures
        SetMode FIQ32_mode, r0
        MOV     r12, #0
        MOV     r11, #0
 ]


	SetMode SVC32_mode, r0				; switch into SVC32 mode (debug routines now work in SVC32 mode)

        ;; Now get on with my code

	;; r0-r7 are free to use
	;; r8 is zero
	;; r12 is SDRAM base
	;; r13 is Stack at top of SDRAM

	MOV	r8, #0

	MOV	r12, #SDRAM_Base

	LDR	r0, =IOMD_Base
 [ RiscPC
 	MOV	r1, #&02
 	STR	r1, [r0, #&8C] ;DRAM refresh on
 |
	MOV	r1, #&0C
	STR	r1, [r0, #&C4]
 ]

 [ IRQsOn
;	MOV	r0, r13
;	SetMode IRQ32_mode, r1
;	SUB	r13, r0, #8*1024	; allow 8K for SVC stack, then IRQ stack below that
	MOV	r0, #SVC32_mode :OR: F32_bit ; enable IRQs, leaving FIQs disabled
	msr	AL, CPSR_all, r0
 ]

 [ LEDTwiddling
	; try poking LEDs
	MOV	r0, #LEDS
	MOV	r1, #1
10
	STR	r1, [r0]
	LDR	r2, =20000
20
	SUBS	r2, r2, #1
	BNE	%BT20
	ADD	r1, r1, #1
	B	%BT10
 ]


;-------------------------------------------------------------------------------

	; Initialise the Clock Frequency Divider Register here if req'd

 [ {FALSE}

 [ :LNOT: TurnICacheOnAtStart
; we didn't do it at start, so we'd better do it now
	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L :OR: MMUC_I	; 32-bit program/data, little endian, instruction cache on
	SetCop	r1, CR_Control
; we can turn I cache off again now
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L	; 32-bit program/data, little endian, instruction cache on
	SetCop	r1, CR_Control
	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
 ]

 ]

;-------------------------------------------------------------------------------

 [ LEDTwiddling
	; Initial LED twiddling stuff to give confidence :-)
	MOV	r0, #LEDS
	MOV	r1, #3					; go round 3 times
31
	MOV	r2, #1
32
	STRB	r2, [r0]
	MOV	r3, #&00100000
33
	SUBS	r3, r3, #1
	BNE	%BT33
	MOV	r2, r2, LSL #1
	TEQ	r2, #&100
	BNE	%BT32
	SUBS	r1, r1, #1
	BNE	%BT31
 ]


;-------------------------------------------------------------------------------
; Give the combo chip a kick in the pants to make the UART visible. Ignore the other stuff on there
; This is blatantly ripped from some other bootstrap code called 'RISC OS' :-)
        LDR     r0, =COMBO_Base          ; R0->  Base address of combo chip

 [ RiscPC
; We have a SMC665 - configure it
        MOV     r2, #SMC_config
        STRB    r2, [r0, #SMC_CSR]      ; Write &55 to CSR twice
        STRB    r2, [r0, #SMC_CSR]      ; to enter configuration mode
        ADR	r1, ConfigSMC665Table

;       Config loop
20
        LDRB    r2, [r1], #1            ; get config index
        STRB    r2, [r0, #SMC_CSR]
        TEQ     r2, #SMC_endconfig      ; end of table?
        LDRNEB  r2, [r1], #1            ; if not then get config data
        STRNEB  r2, [r0, #SMC_data]     ; and write it
        BNE     %BT20

	B	%FT10			; Finito, so skip over the table and continue executing

ConfigSMC665Table
        DCB     &01, 2_10000000         ; Enable config, COM3@338, COM4@238, IRQs active low,
                                        ; // is disabled & not powered
        DCB     &02, 2_00011100         ; COM2 disabled @2F8, COM1 powered & enabled @3F8
        DCB     &03, 2_01111000         ; floppy stuff (default)
        DCB     &04, 2_00000011         ; EPP v1.9, MIDI disabled, normal //floppy,
                                        ; // uses ECP & EPP modes
        DCB     &05, 0                  ; 4 drive support, don't swap drives, normal density,
                                        ; FDC burst mode, IDE@1F0-7,3F6-7, FDC@3F0-7 (default)
;       DCB     &06, &FF                ; floppy drive types (default)
;       DCB     &07, 0                  ; don't auto-powerdown anything (default)
;       DCB     &08, 0                  ; ADRA7:4 address decode (default)
;       DCB     &09, 0                  ; ADRA10:8 address decode (default)
;       DCB     &0A, 0                  ; FIFO threshold for ECP // = ??? (default)
;       DCB     &0B, 0                  ; floppy data rates (default)
;       DCB     &0C, 0                  ; UART2 & UART1 standard speed, UART2 standard mode,
                                        ; UART2 full duplex, XMIT active hi, RCV active hi (default)
        DCB     &00, 2_10100010         ; Valid config, OSC & BR on, FDC disabled & off, IDE AT & disabled
        DCB     SMC_endconfig, 0        ; Exit config mode
 |
; We have a SMC672 - configure it
        MOV     r2, #SMC_config
        STRB    r2, [r0, #SMC_CSR]      ; Write &55 to CSR to enter config mode.
        ADR	r1, ConfigSMC672Table
;       Config loop
20
        LDRB    r2, [r1], #1            ; get config index
        STRB    r2, [r0, #SMC_CSR]
        TEQ     r2, #SMC_endconfig      ; end of table?
        LDRNEB  r2, [r1], #1            ; if not then get config data
        STRNEB  r2, [r0, #SMC_data]     ; and write it
        BNE     %BT20

	B	%FT10			; Finito, so skip over the table and continue executing

ConfigSMC672Table
;DEFAULT POWER UP STATE IS ALL LOGICAL DEVICES DISABLED.
  [ {FALSE}
;Floppy Drive (8 regs, xx0-xx7)
	DCB	&07, 0			; Config the FDC first.
	DCB	&60, &03		; Address MSP
	DCB	&61, &F0		; Address LSP
	DCB	&70, &05		; IRQ 6 is FINTR
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_01001100		; FDC cfg - Normal, Burst, AT-interface, Noswap, push-pull, active
	DCB	&F1, 2_00000000		; FDC cfg - default
	DCB	&F2, 2_11111111		; FDC cfg - default again
	DCB	&F4, 2_00000000
	DCB	&F5, 2_00000000
	DCB	&30, 2_00000001		; Enable it
;Parallel Port (8 regs, xx8-xxF)
	DCB	&07, 3			; Config the Parallel Port.
	DCB	&60, &02		; Address MSP
	DCB	&61, &78		; Address LSP
	DCB	&70, &07		; IRQ 7 is PINTR
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_00111011		; ECP and EPP-1.9
	DCB	&F1, 2_00000000		; Don't have a FDD on PP.
	DCB	&30, 2_00000001		; Enable it
;Serial Port 1 (8 regs, xx8-xxF)
	DCB	&07, 4			; Config Serial Port 1
	DCB	&60, &03		; Address MSP
	DCB	&61, &F8		; Address LSP
	DCB	&70, &03		; IRQ 3 is SINTR0
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_00000000		; No MIDI, HighSpeed disabled, Use unique IRQ
	DCB	&30, 2_00000001		; Enable it
;Serial Port 2 (8 regs, xx8-xxF)
	DCB	&07, 4			; Config Serial Port 2
	DCB	&60, &02		; Address MSP
	DCB	&61, &F8		; Address LSP
	DCB	&70, &04		; IRQ 4 is SINTR1
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_00000000		; No MIDI, HighSpeed disabled
	DCB	&F1, 2_00000010		; Default
	DCB	&F2, 2_00000011
	DCB	&30, 2_00000000		; Disable it
;PS2 Port (8 regs, xx8-xxF)
	DCB	&07, 7			; Config PS2 Port
	DCB	&60, &02		; Address MSP
	DCB	&61, &F8		; Address LSP
	DCB	&70, &01		; IRQ 1 is KIRQ
	DCB	&72, &0C		; IRQ 12 is MIRQ
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_00000000		; Default
;Global Config
	DCB	&22, 2_00111001		; Finally, power 'em all up: SP2, SP1, PP, FDC
	DCB	&23, 2_00000000		; Turn 'intelligent power management' off
	DCB	&24, 2_00000100		; PLL on, Osc on, BRG on.
	
        DCB     SMC_endconfig, 0	; Exit config mode
  |
  ;******* THIS IS FOR THE 'REAL' DE-MON *********
;Serial Port 1 (8 regs, xx8-xxF)
	DCB	&07, 4			; Config Serial Port 1
	DCB	&60, &03		; Address MSP
	DCB	&61, &F8		; Address LSP
	DCB	&70, &00		; No IRQ
	DCB	&74, &04		; No DMA
	DCB	&F0, 2_00000000		; No MIDI, HighSpeed disabled, Use unique IRQ
	DCB	&30, 2_00000001		; Enable it

;Global Config
	DCB	&22, 2_00010000		; Finally, power 'em up: SP1
	DCB	&23, 2_00000000		; Turn 'power management' off
	DCB	&24, 2_00000100		; PLL on, Osc on, BRG on.
	
        DCB     SMC_endconfig, 0	; Exit config mode
   ]
 ]
        ALIGN


;-------------------------------------------------------------------------------
; Set up UART for debug output
10
	LDR	r10, =UART_Base

	MOV	r0, #UARTLCR_DivisorLatchAccess		; enable access to divisor registers
	STRB	r0, [r10, #UART_LineControl]
 [ {TRUE}
 	LDRB	r1, [r10, #UART_LineControl]
 ]

	LDR	r0, =BaudRateDivisor_19200

	STRB	r0, [r10, #UART_DivisorLatchLSB]
 [ {TRUE}
 	LDRB	r1, [r10, #UART_DivisorLatchLSB]
 ]
	MOV	r0, r0, LSR #8
	STRB	r0, [r10, #UART_DivisorLatchMSB]
 [ {TRUE}
 	LDRB	r1, [r10, #UART_DivisorLatchMSB]
 ]

	MOV	r0, #UARTLCR_CharLength8 :OR: UARTLCR_StopBits1	; 8 data, 1 stop bit, no parity
	STRB	r0, [r10, #UART_LineControl]		; also disables access to divisor regs
 [ {TRUE}
 	LDRB	r1, [r10, #UART_LineControl]
 ]

	MOV	r0, #0
	STRB	r0, [r10, #UART_InterruptEnable]	; no IRQs just yet
 [ {TRUE}
 	LDRB	r1, [r10, #UART_InterruptEnable]
 ]

	MOV	r0, #UARTFCR_Enable :OR: UARTFCR_RXReset :OR: UARTFCR_TXReset :OR: UARTFCR_Mode0RXRDYTXRDY :OR: UARTFCR_RXTrigger1
	STRB	r0, [r10, #UART_FIFOControl]		; turn FIFOs on
 [ {TRUE}
 	LDRB	r1, [r10, #UART_FIFOControl]
 ]

	MOV	r0, #UARTMCR_DTRActive			; make DTR active, but RTS inactive (don't allow other end to go)
	STRB	r0, [r10, #UART_ModemControl]
 [ {TRUE}
 	LDRB	r1, [r10, #UART_ModemControl]
 ]

	BL	UARTVString
	=	CR, LF, CR, LF, "Initialised UART", CR, LF, 0
	ALIGN
	
 [ Leggett
        BL      UARTVString
        =       "Phoebe Monitor "
        =       VersionString
        =       CR, LF, 0
 ]

 [ {FALSE}
	; Now transmit Hello World down the UART
	MOV	r11, #LEDS
	MOV	r3, #-1
02
	ADD	r3, r3, #1
	STRB	r3, [r11]
	ADR	r1, HelloWorldString
05
	LDRB	r0, [r1], #1
	TEQ	r0, #0
	BEQ	%BT02
	UARTTx	r0, r10, r2
	B	%BT05

HelloWorldString
	=	"Hello World!", CR, LF, 0
	ALIGN
 ]

 [ {FALSE}
	; Initialise the Interrupt Registers
	MOV	r0, #0
	STR	r0, [r11, #BIU_IENAB]		; Disable all interrupts
	STR	r0, [r11, #BIU_IPRI]		; All interrupts cause IRQ
	MVN	r0, r0
	STR	r0, [r11, #BIU_IPOL]		; Falling edge triggered
	STR	r0, [r11, #BIU_ICLR]		; Clear any pending interrupts
	MVN	r0, #3 :SHL: 16			; All gen purpose pins are outputs
	STR	r0, [r11, #BIU_IDIR]		; *except* for bits 16 and 17 which are inputs for Buxton IRQ and FIQ
	BL	UARTVString
	=	"Initialised IRQ registers", CR, LF, 0
 ]
	ALIGN


;-------------------------------------------------------------------------------

	; Initialise the SDRAM

; real SDRAM requires delay of 200µs before accessing
	MOV	r0, #512
10
	SUBS	r0, r0, #1
	BNE	%BT10

;	; Wait for 2 auto-refresh cycles (as req'd by 4516161 device)

	MOV	r0, #256
10
	SUBS	r0, r0, #1
	BNE	%BT10


; [ SCLKFreq = 100
;	MOV	r0, #50
; |
;	MOV	r0, #80				; Was 50 for 100MHz SCLK, but now 66.67MHz SCLK, so increase it
; ]
;DELAY_2_REFRESH
;	SUBS	r0, r0, #1
;	BPL	DELAY_2_REFRESH
 [ {FALSE}
	; Setup the sdram MRS register
	; Burst Length(3 bits) = 4 cycles   [2]
	; Burst Type  (1 bit ) = sequential [0]
	; CAS Latency (3 bits) = 3          [3]
	; Write Mode  (4 bits) = Burst      [0]
	LDR	r0, =SDRAMCtl_Base :OR: (2 << 9) :OR: (0 << 13) :OR: (3 << 14) :OR: (0 << 17)
	STR	r0, [r0]			; data irrelevant
	ADD	r0, r0, #&400000		; need to write it to 2nd bank too
	STR	r0, [r0]

	BL	UARTVString
	=	"Set up SDRAM MRS registers", CR, LF, 0
 ]
	ALIGN

;-------------------------------------------------------------------------------

 [ InitSDRAMSizing
	BL	UARTVString
	=	"Testing SDRAM", CR, LF, 0
	ALIGN

	MOV	r6, #4
	MOV	r0, r12
10
	ADD	r1, r0, r6
	BL	DistinctAddresses
	MOVEQ	r6, r6, LSL #1		; try next size up
	BEQ	%BT10

; r6 is now memory size, assuming it's a power of two

	BL	UARTVString
	=	"Memory size = ", 0
	ALIGN

	MOV	r0, r6
	BL	UARTHexOut

	MOV	r0, #CR
	UARTTx	r0, r10, r1
	MOV	r0, #LF
	UARTTx	r0, r10, r1
 |
 	MOV	r6, #SDRAM_Size
 ]
	ADD	r13, r12, r6		; r13 -> end of SDRAM

 [ TurnOnMMU
	ADR	r1, ROML1PT
	SetCop	r1, CR_TTabBase		; set base of L1PT
	MOV	r1, #1
	SetCop	r1, CR_Domains		; only use domain 0, use access privileges

	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L :OR: MMUC_M :OR: MMUC_C :OR: MMUC_W :OR: MMUC_I ; produces a warning!
	SetCop	r1, CR_Control		; turn MMU, D+I cache and WB on

	BL	UARTVString
	=	"Turned on MMU", CR, LF, 0
	ALIGN

 ]
	B	InteractiveDebug

 [ OldSDRAMTest
	MOV	r1, #0
12
	MVN	r3, r1
	ORR	r3, r1, r3, LSL #16
	LDR	r2, [r0, r1]
	TEQ	r2, r3
	BNE	%FT14
	ADD	r1, r1, #4
	TEQ	r1, #&4000		; only do 16K, next 16K is L1PT
	BNE	%BT12
	DLINE	"DRAM test passed"
	B	Finish

14
	DREG	r1, "SDRAM failed at address offset &"
	DREG	r2, "Value was &"
	B	Finish

 ]

 [ TestingIRQs
; need to set up IRQ sp
	MOV	r0, r13
	SetMode IRQ32_mode, r1
	SUB	r13, r0, #8*1024	; allow 8K for SVC stack, then IRQ stack below that
	MOV	r0, #SVC32_mode :OR: F32_bit ; enable IRQs, leaving FIQs disabled
	msr	AL, CPSR_all, r0
 ]

dmaloop	B	dmaloop			; loop round letting video DMAs happen


	ALIGN	32
; DistinctAddresses routine...
; r0,r1 are the addresses to check
; uses r2-5
; writes interleaved patterns (to prevent dynamic storage...)
; checks writing every bit low and high...
; return Z-flag set if distinct

; This routine must work in 32-bit mode

DistinctAddresses ROUT
        LDR     r2, [r0] ; preserve
        LDR     r3, [r1]
        LDR     r4, Pattern
        STR     r4, [r0] ; mark first
        MOV     r5, r4, ROR #16
        STR     r5, [r1] ; mark second
        LDR     r5, [r0]
        CMP     r5, r4 ; check first
        BNE     %10    ; exit with Z clear
        LDR     r5, [r1] ; check second
        CMP     r5, r4, ROR #16 ; clear Z if not same
        BNE     %10
; now check inverse bit writes
        STR     r4, [r1] ; mark second
        MOV     r5, r4, ROR #16
        STR     r5, [r0] ; mark first
        LDR     r5, [r1]
        CMP     r5, r4 ; check second
        BNE     %10   ; exit with Z clear
        LDR     r5, [r0] ; check first
        CMP     r5, r4, ROR #16 ; clear Z if not same
10      STR     r3, [r1] ; restore
        STR     r2, [r0]
        MOV     pc, lr                  ; Z flag is already set up, and other flags don't matter

Pattern
        &       &AAFF5500 ; shiftable bit check pattern

; UART string output when no memory yet
; in:	lr -> string
; out:	r0-r1,r10 corrupted

UARTVString ROUT
	LDR	r10, =UART_Base
10
	LDRB	r0, [lr], #1
	TEQ	r0, #0
	BEQ	%FT20
	UARTTx	r0, r10, r1
	B	%BT10
20
	ADD	lr, lr, #3	; round up to next word boundary
	BIC	pc, lr, #3

; output string at r0
; out:	r0-r2,r10 corrupted

UARTr0String ROUT
	LDR	r10, =UART_Base
10
	LDRB	r1, [r0], #1
	TEQ	r1, #0
	MOVEQ	pc, lr
	UARTTx	r1, r10, r2
	B	%BT10

; in:	r0 = value to print in hex
; out:	r1-r3, r10 corrupted

UARTHexOut ROUT
	LDR	r10, =UART_Base
	MOV	r2, lr
	MOV	r1, r0, LSR #28
	BL	UARTHexDig
	MOV	r1, r0, LSR #24
	BL	UARTHexDig
	MOV	r1, r0, LSR #20
	BL	UARTHexDig
	MOV	r1, r0, LSR #16
	BL	UARTHexDig
	MOV	r1, r0, LSR #12
	BL	UARTHexDig
	MOV	r1, r0, LSR #08
	BL	UARTHexDig
	MOV	r1, r0, LSR #04
	BL	UARTHexDig
	MOV	r1, r0
	BL	UARTHexDig
	MOV	pc, r2

UARTHexDig ROUT
	AND	r1, r1, #15
	CMP	r1, #10
	ADDCC	r1, r1, #"0"
	ADDCS	r1, r1, #"A"-10
	UARTTx	r1, r10, r3
	MOV	pc, lr


	MACRO
	FlushICache
	&	&EE070F15
	MEND

	MACRO
	FlushDCache
	&	&EE070F16
	MEND

	MACRO
	DrainWriteBuffer
	&	&EE070F9A
	MEND


; Macro to ensure any dirty data cache lines are written back to main memory

	MACRO
	CleanDCache	$t1, $t2, $t3
 [ UseFastCacheInvalidate
	MOV	$t1, #&30000000		; fast cache invalidate area
 |
	MOV	$t1, #&00800000		; use area of ROM *which has never been executed from*
					; this is important as code may have done LDR rn, =foo
					; which will have put it into the data cache
 ]
	ADD	$t2, $t1, #16384
15
	LDR	$t3, [$t1], #32
	TEQ	$t1, $t2
	BNE	%BT15

	DrainWriteBuffer
	FlushDCache
	MEND

GenericDRAMTestCode
	LDMIA	r12, {r5, r6}		; r5 = start address, r6 = log2(length)
	SUB	r6, r6, #2		; r6 = log2(length in words)
	SUB	r0, r6, #8		; table starts at size 2^8
	ADR	r4, magicprimes
	LDR	r4, [r4, r0, LSL #2]	; get entry
	SUB	r5, r5, #4		; point back one word, cos index starts at 1
	MOV	r0, #1
	MOV	r6, r0, LSL r6		; r6 = size of area in words

	BL	UARTVString
	=	"  Starting new DRAM test", CR, LF, 0
	ALIGN

; first stage - write out data

	MOV	r7, #1			; random number seed
	MOV	r8, r6, LSR #3		; test 1/8 of the memory
10
	RSBS	r7, r4, r7, LSL #1	; double random no., and try to subtract magicprime
	ADDCC	r7, r7, r4		; if didn't make it, add it back on again
	CMP	r7, r6			; check if in range (1 to 2^Log2MemorySize)
	BHI	%BT10			; if not then loop

	STR	r8, [r5, r7, LSL #2]	; store test number to memory
	SUBS	r8, r8, #1
	BNE	%BT10

	BL	UARTVString
	=	"  Now cleaning data cache and draining write buffer", CR, LF, 0
	ALIGN

; now clean the whole of the data cache

	CleanDCache r7, r8, r9

	BL	UARTVString
        =	"  Starting verification phase", CR, LF, 0
	ALIGN

; second stage - verify data

	MOV	r7, #1			; random number seed
	MOV	r8, r6, LSR #3		; test 1/8 of the memory
20
	RSBS	r7, r4, r7, LSL #1	; double random no., and try to subtract magicprime
	ADDCC	r7, r7, r4		; if didn't make it, add it back on again
	CMP	r7, r6			; check if in range (1 to 2^Log2MemorySize)
	BHI	%BT20			; if not then loop

	ADD	r11, r5, r7, LSL #2	; r11 = address in case of failure
	LDR	r9, [r11]		; get word from memory
	TEQ	r9, r8
	BNE	failedtest
	SUBS	r8, r8, #1
	BNE	%BT20

; start of STM test

	LDMIA	r12, {r5, r6}		; r5 = start address, r6 = log2(length in bytes)
	SUB	r6, r6, #4		; r6 = log2(length in quad-words)
	SUB	r0, r6, #8		; table starts at size 2^8
	ADR	r4, magicprimes
	LDR	r4, [r4, r0, LSL #2]	; get entry
	SUB	r5, r5, #16		; point back one quad word, cos index starts at 1
	MOV	r0, #1
	MOV	r6, r0, LSL r6		; r6 = size of area in quad-words

	BL	UARTVString
	=	"  Starting STM test", CR, LF, 0
	ALIGN

; first stage - write out data

	MOV	r7, #1			; random number seed
	MOV	r8, r6, LSR #3		; test 1/8 of the memory
10
	RSBS	r7, r4, r7, LSL #1	; double random no., and try to subtract magicprime
	ADDCC	r7, r7, r4		; if didn't make it, add it back on again
	CMP	r7, r6			; check if in range (1 to 2^Log2MemorySize)
	BHI	%BT10			; if not then loop

	MOV	r0, r8
	SUB	r1, r8, #1
	SUB	r2, r8, #2
	SUB	r3, r8, #3
	ADD	r11, r5, r7, LSL #4	; compute address
	STMIA	r11, {r0-r3}		; store test words to memory
	SUBS	r8, r8, #4
	BNE	%BT10

	BL	UARTVString
	=	"  Cleaning cache and draining WB again", CR, LF, 0
	ALIGN

; now clean the whole of the data cache

	CleanDCache r7, r8, r9

	BL	UARTVString
        =	"  Verifying STM phase", CR, LF, 0
	ALIGN

; second stage - verify data

	MOV	r7, #1			; random number seed
	MOV	r8, r6, LSR #3		; test 1/8 of the memory
20
	RSBS	r7, r4, r7, LSL #1	; double random no., and try to subtract magicprime
	ADDCC	r7, r7, r4		; if didn't make it, add it back on again
	CMP	r7, r6			; check if in range (1 to 2^Log2MemorySize)
	BHI	%BT20			; if not then loop

	ADD	r11, r5, r7, LSL #4	; compute address
	LDMIA	r11, {r0-r3}
	MOV	r9, r0
	TEQ	r9, r8
	BNE	failedtest
	SUB	r8, r8, #1
	ADD	r11, r11, #4
	MOV	r9, r1
	TEQ	r9, r8
	BNE	failedtest
	SUB	r8, r8, #1
	ADD	r11, r11, #4
	MOV	r9, r2
	TEQ	r9, r8
	BNE	failedtest
	SUB	r8, r8, #1
	ADD	r11, r11, #4
	MOV	r9, r3
	TEQ	r9, r8
	BNE	failedtest
	SUBS	r8, r8, #1
	BNE	%BT20

	BL	UARTVString
	=	"  SDRAM test passed", CR, LF, 0
	ALIGN
	B	InteractiveDebug

failedtest
      [ Leggett
        SetMode FIQ32_mode, r0
        ADD     r11, r11, #1
        SetMode SVC32_mode, r0
      ]

	BL	UARTVString
	=	"  *** WARNING: SDRAM test failed at address &", 0
	ALIGN
	MOV	r0, r11
	BL	UARTHexOut
	BL	UARTVString
	=	CR, LF, "Value was &", 0
	ALIGN
	MOV	r0, r9
	BL	UARTHexOut
	BL	UARTVString
	=	CR, LF, "but it should have been &", 0
	ALIGN
	MOV	r0, r8
	BL	UARTHexOut
	BL	UARTVString
	=	CR, LF, 0
	ALIGN
	B	InteractiveDebug



; magicprimes - table of prime numbers that cause the address randomizer to
; loop through all addresses in a given range

; The table is a list of words indexed by n = 8 to 24, where entry(n) is the
; magic prime for a memory size of 2^n storage units

magicprimes
	&	269, 523, 1061, 2053, 4099, 8219, 16421, 32771
	&	65539, 131213, 262147, 524309, 1048589, 2097211
	&	4194371, 8388619, 16777259

	LTORG

 [ TestingIRQs

		GBLA	ValidDMAIRQMask
		GBLA	ValidBuxtonIRQMask0
		GBLA	ValidBuxtonIRQMask1

ValidDMAIRQMask SETA	0

ValidBuxtonIRQMask0 SETA 0

ValidBuxtonIRQMask1 SETA 0

IRQ_HANDLER Entry "r0-r4, r11-r12"	; IRQ stack set up by main code
	MOV	r12, #SDRAM_Base

	MOV	r4, #FastTUBE
	ADR	r0, IRQString
	STR	r0, [r4]

	MOV	r11, #BIU_Base
	LDR	r0, [r11, #BIU_IRQ]
	TEQ	r0, #0
	BEQ	NotBIUIRQ

	STR	r0, [r11, #BIU_ICLR]	; clear the IRQs anyway

	BICS	r1, r0, #ValidDMAIRQMask ; test if any invalid IRQ bit is set
	ADRNE	r1, BIUIllegalString
	BNE	IllegalBit
	MOV	r1, #1<<1
	LDR	r2, =:INDEX: IRQCounts
	ADR	lr, IRQNumberStrings
10
	TST	r0, r1
	LDRNE	r3, [r2]
	ADDNE	r3, r3, #1
	STRNE	r3, [r2]
	STRNE	lr, [r4]	; print character code for channel number
	ADD	r2, r2, #4
	ADD	lr, lr, #16	; length of string
	MOV	r1, r1, LSL #1
	TEQ	r1, #1 << (1+?IRQCounts/4)
	BNE	%BT10


IRQExit
	MOV	r0, #10
	STR	r0, [r4]	; terminate line

	PullEnv
	SUBS	pc, lr, #4	; Return

IRQString
	=	"TUBE: IRQ", 0
	ALIGN
BIUIllegalString
	=	"TUBE: Illegal BIU interrupt", 0
	ALIGN
BuxtonIRQ0String
	=	"TUBE: Buxton IRQ0", 0
	ALIGN
BuxtonIRQ0IllegalString
	=	"TUBE: Illegal Buxton(0) interrupt", 0
	ALIGN
BuxtonIRQ1String
	=	"TUBE: Buxton IRQ1", 0
	ALIGN
BuxtonIRQ1IllegalString
	=	"TUBE: Illegal Buxton(1) interrupt", 0
	ALIGN
UnknownIRQString
	=	"TUBE: Unknown IRQ", 0
	ALIGN

IRQNumberStrings
	GBLA	TMP
TMP	SETA	"1"
	WHILE	TMP <= "7"
	=	"TUBE: DMA IRQ ",TMP,0
TMP	SETA	TMP + 1
	WEND


NotBIUIRQ
	MOV	r11, #Buxton_INT_Base
	LDR	r0, [r11, #BuxtonINT_RIRQ0]
	TEQ	r0, #0
	BEQ	NotBuxtonInt0

	ADR	r1, BuxtonIRQ0String
	STR	r1, [r4]

	STR	r0, [r11, #BuxtonINT_STATCLR0]	; clear the IRQs anyway
	BICS	r1, r0, #ValidBuxtonIRQMask0	; test if invalid bit set
	ADRNE	r1, BuxtonIRQ0IllegalString
	BNE	IllegalBit

; not sure what else we can do

	B	IRQExit

NotBuxtonInt0
	LDR	r0, [r11, #BuxtonINT_RIRQ1]
	TEQ	r0, #0
	BEQ	UnknownIRQ

	ADR	r1, BuxtonIRQ1String
	STR	r1, [r4]

	STR	r0, [r11, #BuxtonINT_STATCLR1]	; clear the IRQs anyway
	BICS	r1, r0, #ValidBuxtonIRQMask1	; test if invalid bit set
	ADRNE	r1, BuxtonIRQ1IllegalString
	BNE	IllegalBit


; now increment HCSTART

	ADR	r2, ModeStructPtr	; point at offset with SDRAM of mode structure
	LDR	r2, [r2]		; get offset (don't use LDR r2,ModeStructPtr cos offset is bigger than 4K)
	ADD	r2, r2, r12		; make into absolute address
	LDR	r0, [r2, #ModeStruct_HCSTART]
	ADD	r0, r0, #1		; increment
	STR	r0, [r2, #ModeStruct_HCSTART]	; write back to soft copy

	MOV	r11, #Buxton_DVE_Base
	STR	r0, [r11, #BuxtonDVE_HCSTART] ; write to hardware
	ADD	r0, r0, #32
	STR	r0, [r11, #BuxtonDVE_HCEND] ; and keep HCEND in step

	B	IRQExit

UnknownIRQ
	ADR	r0, UnknownIRQString
	STR	r0, [r4]
	B	IRQExit		; might reenter but who cares at this stage

IllegalBit
	STR	r1, [r4]		; write message that identifies what kind of IRQ
	DREG	r0, "IRQ status was"
	B	IRQExit

 |
IRQ_HANDLER
	SUBS	pc, lr, #4	; Return
 ]

; New command parser macros

	GBLA	Root
	GBLA	NextCommand
NextCommand SETA 0
	GBLA	NewNode
	GBLA	Params

	MACRO
$Label	NewCommandNode
$Label	SETA	NextCommand
	GBLS	String$NextCommand
	GBLA	Params$NextCommand
	GBLS	Code$NextCommand
Code$NextCommand SETS ""
NextCommand SETA NextCommand + 1
	MEND

	MACRO
	AddCommand	$string
	LCLS	CommandName
	LCLS	UCCommandName
	LCLA	Index
	LCLS	Char
Index	SETA	0
	WHILE	"$string" :LEFT: (Index+1) :RIGHT: 1 <> " " :LAND: Index < :LEN: "$string"
Char	SETS	"$string" :LEFT: (Index+1) :RIGHT: 1
 [ Char >= "a" :LAND: Char <= "z"
UCCommandName SETS	UCCommandName :CC: :CHR: (Char-&20)
 |
UCCommandName SETS	UCCommandName :CC: Char
 ]
Index	SETA	Index + 1
	WEND
CommandName SETS	"$string" :LEFT: Index
Params	SETA	0
Index	SETA	Index + 1
	WHILE	Index < :LEN: "$string"
Char	SETS	"$string" :LEFT: Index :RIGHT: 1
 [ Char = "<"
Params	SETA	Params + 1
 ]
 [ Char = ":"
Index	SETA	:LEN: "$string"
 |
Index	SETA	Index + 1
 ]
	WEND
Syntax_$CommandName	=	" $string", CR, LF				; output string anyway
	AddCommand2	Root, $UCCommandName, Params, Code_$CommandName, Syntax_$CommandName
	MEND

	MACRO
	AddCommand2	$where, $string, $params, $code, $syntax
	LCLA	Number
	LCLS	Keys
	LCLS	FirstChar
	LCLS	Rest
Number	SETA	$where
 [ "$string"=""
Params$Number	SETA	$params
Code$Number	SETS	"$code"
 |
FirstChar SETS	"$string" :LEFT: 1
Rest	SETS	"$string" :RIGHT: (:LEN: "$string" -1)
  [ :LNOT: :DEF: Link$Number$FirstChar
String$Number	SETS	String$Number :CC: FirstChar
NewNode	NewCommandNode
	GBLA	Link$Number$FirstChar
Link$Number$FirstChar SETA NewNode
Parent$NewNode  *	Parser$Number
  ]
	AddCommand2	Link$Number$FirstChar, $Rest, $params, $code, $syntax
 ]
	MEND

	MACRO
$Label	OutputCommandParser
$Label	ROUT
	LDR	r10, =UART_Base
	MOV	r12, #SDRAM_Base
	BL	UARTVString
	=	CR, LF, "Debug: ", 0
	ALIGN
	MOV	r11, #0					; number of chars typed

	LCLA	Index
	LCLA	KeyIndex
	LCLS	Char
	LCLA	BranchIndex
	LCLS	BranchTarget
Index	SETA	0
	WHILE	Index < NextCommand
Parser$Index
	BL	GetUpperChar
 [ Index = 0
	TEQ	r1, #8					; if backspace
	TEQNE	r1, #127				; or delete
	BEQ	Parser00000000				; at start, so ignore
	BL	TXChar
 |
	BL	TXChar					; always echo char
	TEQ	r1, #8					; if backspace
	TEQNE	r1, #127				; or delete
	SUBEQ	r11, r11, #1
	BEQ	Parent$Index
 ]
	ADD	r11, r11, #1
 [ Code$Index <> ""
; terminal node
; check for space or newline
BranchTarget SETS Code$Index
	CMP	r1, #" "
	BHI	%FT10
	MOV	r9, #0					; number of args (0..4)
 [ Params$Index >= 1
	BLCS	getvaluer4
	BCC	NotEnoughArgs
	MOV	r5, r4
	ADD	r9, r9, #1
 ]
 [ Params$Index >= 2
	CMP	r1, #" "
	BLCS	getvaluer4
	BCC	NotEnoughArgs
	MOV	r6, r4
	ADD	r9, r9, #1
 ]
 [ Params$Index >= 3
	CMP	r1, #" "
	BLCS	getvaluer4
	BCC	NotEnoughArgs
	MOV	r7, r4
	ADD	r9, r9, #1
 ]
 [ Params$Index >= 4
	CMP	r1, #" "
	BLCS	getvaluer4
	BCC	NotEnoughArgs
	MOV	r8, r4
	ADD	r9, r9, #1
 ]
	CMP	r1, #" "
	BCC	%FT05					; correct number of args
04
	UARTRxEcho r1, r10, r3
	TEQ	r1, #8
	TEQNE	r1, #127
	BEQ	BombOut
	CMP	r1, #" "
	BEQ	%BT04
	BHI	TooManyArgs
05
	BL	UARTVString
	=	CR, LF, 0
	ALIGN
	B	$BranchTarget
10
 ]
 [ String$Index <> ""
KeyIndex SETA	1
	WHILE	KeyIndex <= :LEN: String$Index
Char	SETS	(String$Index :LEFT: KeyIndex) :RIGHT: 1
BranchIndex SETA Link$Index$Char
	TEQ	r1, #Char
	BEQ	Parser$BranchIndex
KeyIndex SETA	KeyIndex + 1
	WEND	; KeyIndex loop
 ]
 [ Index = 0
; if top level, check for just newline
	CMP	r1, #" "
	BCC	InteractiveDebug
 ]
	BL	UnknownCommand				; unknown command
	B	Parser$Index				; if deleted enough chars again
Index	SETA	Index + 1
	WEND	; Index loop
	MEND

Root	NewCommandNode

SyntaxString
	=	"Commands are:", CR, LF
	;			   1         2         3         4         5         6         7
	;		 01234567890123456789012345678901234567890123456789012345678901234567890123456789
	AddCommand	"BW <addr> <data1> <data2>            : burstwrite 2 wds, cln cache, drain WB"
	AddCommand	"C <n>                                : write MMU control register"
	AddCommand	"Reloc <addr>                         : copy ROM to address and jump to it"
	AddCommand	"Go <addr>                            : go to address"
	AddCommand	"LR <addr1> <addr2>                   : loop reading addr1 then addr2"
	AddCommand	"LT1 <addr> <data1> <data2>           : loop testing burst reads"
	AddCommand	"LT2 <addr1> <data1> <addr2> <data2>  : loop testing two locations"
	AddCommand	"LW <addr1> <data1> <addr2> <data2>   : loop writing d1 to a1 then d2 to a2"
	AddCommand	"R <addr>                             : read from addr"
	AddCommand	"SRT <start> <end>                    : simple ramtest from start to end"
	AddCommand	"DRT <size>                           : Dual bank ram test."
	AddCommand	"TR                                   : test RAM"
	AddCommand	"RAT                                  : ROM address test"
	AddCommand	"W <addr> <data>                      : write data to addr"
	AddCommand	"WB <addr> <data>                     : write byte to addr"
	AddCommand	"MW <addr> <data>                     : Merging word write"
	AddCommand	"DUMP <addr> <size>                   : dump of memory contents"
	AddCommand	"BIN <addr> <size>                    : binary download of size to addr"
	AddCommand	"ION                                  : instruction cache on"
	AddCommand	"IOFF                                 : instruction cache off"
	AddCommand	"IRQON                                : interrupts on"
	AddCommand	"IRQOFF                               : interrupts off"
	AddCommand	"MMUON                                : MMU on"
	AddCommand	"MMUOFF                               : MMU off"
	AddCommand      "RAMSIZE <address>                    : report size/configuration of SDRAM DIMM"
        AddCommand      "SETSDRAMCR                           ; interrogate DIMMs and program SDRAMCR"
	AddCommand      "INITSDRAM                            ; Initialise SDRAM and setup SDRAMCR"
	AddCommand      "SPDSET <address> <offset> <value>    : set SPD registers in SDRAM DIMM"
	AddCommand      "SPDGET <address> <offset>            : get SPD register value from SDRAM DIMM"
	AddCommand      "IICWRITE <device> <start> <length>   : write data on I2C bus"
	AddCommand      "IICREAD <device> <start> <length>    : read data from I2C device"
	AddCommand	"VIDTEST <vidaddr> <curaddr> <flags>  : perform a video DMA test"
	AddCommand      "TESTCODEC                            : Initialise sound codec"
	AddCommand      "TESTPCI                              : Test for PCI hardware"
	AddCommand      "DOTESTS                              : run a programmed sequence of tests"
	=	0

InteractiveDebug

 [ Leggett
	SetMode FIQ32_mode, r0
	MOV     r1, r12
	SetMode SVC32_mode, r0
	CMP     r1, #0
	BNE     DoingTests
 ]	

	OutputCommandParser

; getvaluer4 - read a hex value
; in:	r10 -> UART
;
; out:	r1 = terminating char
;	r2 = number of digits
; 	r4 = value read
; 	r3 corrupted
; 	C clear => no digits

getvaluer4 ROUT
	MOV	r4, #0		; value
	MOV	r2, #0		; number of digits so far
10
	UARTRxEcho r1, r10, r3
	TEQ	r1, #8
	BEQ	%FT70
	CMP	r1, #" "
	BHI	%FT60
	BEQ	%FT50		; space
40
	CMP	r2, #1		; CC => no digits
	MOV	pc, lr

50
	TEQ	r2, #0
	BEQ	%BT10		; if had no digits yet, ignore space
	B	%BT40		; else end of number

60
	TEQ	r1, #127
	BNE	%FT80
70
	SUBS	r2, r2, #1
	MOVCS	r4, r4, LSR #4
	BCS	%BT10
BombOut
	MOV	r1, #"?"
	UARTTx	r1, r10, r3
	B	InteractiveDebug	; bomb out
80
	SUB	r3, r1, #"0"
	CMP	r3, #10
	BCC	%FT90
	SUB	r3, r1, #"A"
	CMP	r3, #6
	ADDCC	r3, r3, #10
	BCC	%FT90
	SUB	r3, r1, #"a"
	CMP	r3, #6
	ADDCC	r3, r3, #10
	BCC	%FT90
85
	ADRL	r0, ValueError
	B	GoToEnd
90
	ORR	r4, r3, r4, LSL #4
	ADD	r2, r2, #1
	B	%BT10

GetUpperChar ROUT
	UARTRx	r1, r10
	CMP	r1, #"a"
	RSBGES	r2, r1, #"z"
	SUBGE	r1, r1, #"a"-"A"			; force upper case
	MOV	pc, r14

TXChar ROUT
	UARTTx	r1, r10, r2
	MOV	pc, r14

UnknownCommand
	ADRL	r0, SyntaxString

	MOV	r9, lr					; save where to go back to
	SUB	r8, r11, #1				; stack level at which to return
10
	BL	GetUpperChar
	BL	TXChar					; always echo char
	TEQ	r1, #8					; if backspace
	TEQNE	r1, #127				; or delete
	BEQ	%FT20
	CMP	r1, #" "
	ADDHI	r11, r11, #1
	BHI	%BT10

	BL	UARTr0String
	B	InteractiveDebug

20
	SUB	r11, r11, #1				; decrement char count
	TEQ	r11, r8
	BNE	%BT10
	MOV	pc, r9					; return now

TooManyArgs
	ADR	r0, TooManyParamsError
	B	GoToEnd

NotEnoughArgs
	ADR	r0, NotEnoughParamsError
GoToEnd
	BL	SkipToEnd
	TEQ	r0, #0
	BLNE	UARTr0String
	B	InteractiveDebug

SkipToEnd ROUT
	CMP	r1, #" "
	MOVCC	pc, lr
	UARTRxEcho r1, r10, r2
	B	SkipToEnd

ValueError
	=	"Bad value", CR, LF, 0
	ALIGN
TooManyParamsError
	=	"Too many parameters", CR, LF, 0
	ALIGN
NotEnoughParamsError
	=	"Not enough parameters", CR, LF, 0
	ALIGN


;-------------------------------------------------------------------------------
; LW <addr1> <value1> <addr2> <value2> : loop writing two addresses
Code_LW
writeloop
	STR	r6, [r5]
	STR	r8, [r7]
	B	writeloop


;-------------------------------------------------------------------------------
; LR <addr1> <addr2>		: loop reading two addresses
Code_LR
readloop
	LDR	r7, [r5]
	LDR	r7, [r6]
	B	readloop


;-------------------------------------------------------------------------------
; LT1 <addr> <data1> <data2>	: loop test 1
Code_LT1 ROUT
	STMIA	r5, {r6, r7}
	CleanDCache r0, r1, r2
	MOV	r8, #0			; diff1
	MOV	r9, #0			; diff2
10
	FlushDCache
	LDMIA	r5, {r10, r11}
	EOR	r10, r10, r6		; differences from what it should be
	EOR	r11, r11, r7
	TEQ	r10, r8
	TEQEQ	r11, r9
	BEQ	%BT10
	MOV	r8, r10
	MOV	r9, r11			; update deltas
	BL	UARTVString
	=	"  New deltas: ", 0
	ALIGN
	MOV	r0, r8
	BL	UARTHexOut
	BL	UARTVString
	=	" ", 0
	ALIGN
	MOV	r0, r9
	BL	UARTHexOut
	BL	UARTVString
	=	CR, LF, 0
	ALIGN
	B	%BT10


;-------------------------------------------------------------------------------
; LT2 <addr1> <data1> <addr2> <data2>	: loop test 2
Code_LT2 ROUT
	STR	r6, [r5]
	STR	r8, [r7]
	MOV	r9, #0
	MOV	r11,#0
	MOV	r0, #'.'
10
	FlushDCache
	UARTTx	r0, r10, r12
	LDR	r12, [r5]
	LDR	r14, [r7]
	EOR	r12, r12, r6
	EOR	r14, r14, r8
	TEQ	r12, r9
	TEQEQ	r14, r11
	BEQ	%BT10

	MOV	r9, r12			; update deltas
	MOV	r11, r14
	BL	UARTVString
	=	"  New deltas: ", 0
	ALIGN
	MOV	r0, r9
	BL	UARTHexOut
	BL	UARTVString
	=	" ", 0
	ALIGN
	MOV	r0, r11
	BL	UARTHexOut
	BL	UARTVString
	=	CR, LF, 0
	ALIGN
	B	%BT10


;-------------------------------------------------------------------------------
; BW <addr> <data1> <data2>		: single burst write of 2 words
Code_BW
	STMIA	r5, {r6, r7}
	CleanDCache r0, r1, r2
	DrainWriteBuffer
	B	InteractiveDebug


;-------------------------------------------------------------------------------
; TR	: test RAM
Code_TR
	ADR	r12, SDRAMTestParams
	B	GenericDRAMTestCode

SDRAMTestParams
	&	SDRAM_Base
	&	22 ; = Log2(4MB)


;-------------------------------------------------------------------------------
; R <addr>				: read single location
Code_R
	BL	UARTVString
	=	"  Address: ", 0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut

	BL	UARTVString
	=	" Value read: ", 0

	LDR	r0, [r5]
	BL	UARTHexOut
LFEnd
	MOV	r0, #CR
	UARTTx	r0, r10, r1
	MOV	r0, #LF
	UARTTx	r0, r10, r1
	B	InteractiveDebug


;-------------------------------------------------------------------------------
; SRT <start> <end>			: simple ram test
Code_SRT
	BL	UARTVString
	=	"  Starting RAM test", CR, LF, 0
	ALIGN

	MOV	r0, r5
10	STR	r0, [r0], #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  Stuffed RAM with data.", CR, LF, 0
	ALIGN

	MOV	r0, r5
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	SRT_Fail
	ADD	r0, r0, #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  RAM test passed. ", 0
	ALIGN
	B	LFEnd

SRT_Fail
      [ Leggett
        SetMode FIQ32_mode, r5
        ADD     r11, r11, #1
        SetMode SVC32_mode, r5
      ]

	MOV	r5, r0
	BL	UARTVString
	=	"  *** WARNING: RAM test failed at: ",0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut
	BL	UARTVString
	=	" Value read: ", 0
	ALIGN
	LDR	r0, [r5]
	BL	UARTHexOut
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; RAT			: simple rom test
Code_RAT
	BL	UARTVString
	=	"  Starting ROM test", CR, LF, 0
	ALIGN

	ADRL	r0, ROMFill
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	RAT_Fail
	ADD	r0, r0, #4
	CMP	r0, #&00400000
	BNE	%BT10

	BL	UARTVString
	=	"  ROM test passed. ", 0
	ALIGN
	B	LFEnd

RAT_Fail
      [ Leggett
        SetMode FIQ32_mode, r5
        ADD     r11, r11, #1
        SetMode SVC32_mode, r5
      ]

	MOV	r5, r0
	BL	UARTVString
	=	"  *** WARNING: ROM test failed at: ",0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut
	BL	UARTVString
	=	" Value read: ", 0
	ALIGN
	LDR	r0, [r5]
	BL	UARTHexOut
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; DRT <size>			: simple ram test for both sockets
Code_DRT
	BL	UARTVString
	=	"  Starting dual-socket RAM test", CR, LF, 0
	ALIGN

	MOV	r0, #IOMD_Base
	MOV	r1, #&11
	STR	r1, [r0, #&EC]

	MOV	r0, #BANK0_Base
	ADD	r6, r5, #BANK0_Base
10	STR	r0, [r0], #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  Stuffed Bank 0 RAM with data.", 0
	ALIGN

	MOV	r0, #BANK1_Base
	ADD	r6, r5, #BANK1_Base
10	STR	r0, [r0], #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  Stuffed Bank 1 RAM with data.", 0
	ALIGN

	MOV	r0, #BANK2_Base
	ADD	r6, r5, #BANK2_Base
10	STR	r0, [r0], #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  Stuffed Bank 2 RAM with data.", 0
	ALIGN

	MOV	r0, #BANK3_Base
	ADD	r6, r5, #BANK3_Base
10	STR	r0, [r0], #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  Stuffed Bank 3 RAM with data.", 0
	ALIGN


 ; Now read the data back
	MOV	r0, #BANK0_Base
	ADD	r6, r5, #BANK0_Base
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	DRT_Fail
	ADD	r0, r0, #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  RAM test passed Bank 0.", 0
	ALIGN

	MOV	r0, #BANK1_Base
	ADD	r6, r5, #BANK1_Base
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	DRT_Fail
	ADD	r0, r0, #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  RAM test passed Bank 1.", 0
	ALIGN

	MOV	r0, #BANK2_Base
	ADD	r6, r5, #BANK2_Base
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	DRT_Fail
	ADD	r0, r0, #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  RAM test passed Bank 2.", 0
	ALIGN

	MOV	r0, #BANK3_Base
	ADD	r6, r5, #BANK3_Base
10	LDR	r1, [r0]
	CMP	r0, r1
	BNE	DRT_Fail
	ADD	r0, r0, #4
	CMP	r0, r6
	BNE	%BT10

	BL	UARTVString
	=	"  RAM test passed Bank 3.", 0
	ALIGN
	B	LFEnd

DRT_Fail
      [ Leggett
        SetMode FIQ32_mode, r5
        ADD     r11, r11, #1
        SetMode SVC32_mode, r5
      ]

	MOV	r5, r0
	BL	UARTVString
	=	"  *** WARNING: RAM test failed at: ",0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut
	BL	UARTVString
	=	" Value read: ", 0
	ALIGN
	LDR	r0, [r5]
	BL	UARTHexOut
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; W <addr> <data>			: write single location
Code_W
	BL	UARTVString
	=	"  Address: ", 0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut

	BL	UARTVString
	=	" Value written: ", 0
	ALIGN
        MOV	r0, r6
	BL	UARTHexOut
	STR	r6, [r5]		; write to address
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; WB <addr> <data>			: write byte to single location
Code_WB
	BL	UARTVString
	=	"  Address: ", 0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut

	BL	UARTVString
	=	" Value written: ", 0
	ALIGN
        MOV	r0, r6
	BL	UARTHexOut
	STRB	r6, [r5]		; write to address
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; MW <addr> <data>			: merging word write
Code_MW
	BL	UARTVString
	=	"  Merging word write, base: ", 0
	ALIGN
	MOV	r0, r5
	BL	UARTHexOut

	BL	UARTVString
	=	" Value to be written: ", 0
	ALIGN
        MOV	r0, r6
	BL	UARTHexOut

	STR	r6, [r5, #&00]
	STR	r6, [r5, #&0C]

	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; ION					: Switch instruction cache on
Code_ION
	BL	UARTVString
	=	"  Switching ICache on", CR, LF, 0
	ALIGN
	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L :OR: MMUC_I	; 32-bit program/data, little endian, instruction cache on
	SetCop	r1, CR_Control
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; IOFF					: Switch instruction cache off
Code_IOFF
	BL	UARTVString
	=	"  Switching ICache off", CR, LF, 0
	ALIGN
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L	; 32-bit program/data, little endian, instruction cache on
	SetCop	r1, CR_Control
	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; IRQON					; IRQs on
Code_IRQON
	BL	UARTVString
	=	"  Switching IRQs on", CR, LF, 0
	ALIGN
	mrs	AL, r0, CPSR_all
	BIC	r0, r0, #I32_bit 
	msr	AL, CPSR_all, r0
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; IRQOFF				; IRQs off
Code_IRQOFF
	BL	UARTVString
	=	"  Switching IRQs off", CR, LF, 0
	ALIGN
	mrs	AL, r0, CPSR_all
	ORR	r0, r0, #I32_bit 
	msr	AL, CPSR_all, r0
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; MMUON					: Switch I+D cache on
Code_MMUON
	BL	UARTVString
	=	"  Switching IDCache/MMU on", CR, LF, 0
	ALIGN

	LDR	r1, =IOMD2_Base
	MOV	r0, #8
	STR	r0, [r1, #&80]

	ADRL	r1, ROML1PT
	SetCop	r1, CR_TTabBase		; set base of L1PT
	MOV	r1, #1
	SetCop	r1, CR_Domains		; only use domain 0, use access privileges

	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L :OR: MMUC_M :OR: MMUC_C :OR: MMUC_W :OR: MMUC_I ; produces a warning!
	SetCop	r1, CR_Control
	BL	UARTVString
	=	"  Turned on MMU", 0
	ALIGN
	
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; MMUOFF				: Switch I+D cache off
Code_MMUOFF
	BL	UARTVString
	=	"  Switching Caches and MMU off", CR, LF, 0
	ALIGN
	LDR	r1, =MMUC_P :OR: MMUC_D :OR: MMUC_L	; 32-bit program/data, little endian, instruction cache on
	SetCop	r1, CR_Control
	SetCop2	r1, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r1, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	B	LFEnd

	LTORG


;-------------------------------------------------------------------------------
; DUMP <addr> <size>			: read block of data
Code_DUMP

	ADD	r6, r5, r6
05	BL	UARTVString
	=	CR, LF, 0
	MOV	r0, r5
	BL	UARTHexOut
	BL	UARTVString
	=	": ", 0

	MOV	r4, #4
10	CMP	r6, r5
	BLE	LFEnd
	LDR	r0, [r5], #4
	BL	UARTHexOut
	BL	UARTVString
	=	" ", 0
	SUBS	r4, r4, #1
	BNE	%BT10
	B	%BT05


;-------------------------------------------------------------------------------
; BIN <addr> <size>		: Download via serial for soft-upgrades.
Code_BIN
	BL	UARTVString
	=	"  Send binary data...", CR, LF, 0
	ALIGN
	LDR	r10, =UART_Base
10
	UARTRx	r0, r10		;Get byte from serial stream
	STRB	r0, [r5], #1	;Bung it at dest address & inc
	MOV	r0, r5
	SUBS	r6, r6, #1
	BNE	%BT10
	
	BL	UARTVString
	=	"  Binary data download complete.", CR, LF, 0
	ALIGN
	
	B	InteractiveDebug

	LTORG

;-------------------------------------------------------------------------------
; C <data>			: write MMU control register
Code_C
	SetCop	r5, CR_Control
	SetCop2	r0, CR_CacheControl, 0, CR_IDFlush	; flush I+D cache
	SetCop2	r0, CR_TLBControl, 0, CR_IDFlush	; flush TLB for both I + D cache
	B	InteractiveDebug


;-------------------------------------------------------------------------------
; Reloc <addr>			: copy ROM to address and jump to it (eg for flash testing)
Code_Reloc
	ADR	r0, StartOfROM
	ADRL	r1, InteractiveDebug
	ADD	r1, r1, r5
	SUB	r1, r1, r0				; r1 = address to jump to at end
	MOV	r2, #4*1024*1024
copytoramloop
	LDMIA	r0!, {r6-r9}
	STMIA	r5!, {r6-r9}
	SUBS	r2, r2, #4*4
	BNE	copytoramloop

	CleanDCache r0, r2, r3				; ensure dirty D-cache lines written back to main memory
	FlushICache					; flush I-cache as well since it may be stale
	MOV	pc, r1					; jump to code


;-------------------------------------------------------------------------------
; Go <addr>			: jump to address
Code_Go
	MOV	lr, pc
	MOV	pc, r5
	B	InteractiveDebug
	
	
;-------------------------------------------------------------------------------
	InsertDebugRoutines

UndefHandler
	SetMode	SVC32_mode, r0	
	ADR	r0, UndefString
ExceptionHandler
	BL	UARTr0String
	B	InteractiveDebug

SWIHandler
	SetMode	SVC32_mode, r0
	ADR	r0, SWIString
	B	ExceptionHandler

IAbortHandler
	SetMode	SVC32_mode, r0
	ADR	r0, IAbortString
	B	ExceptionHandler

DAbortHandler
 [ TestPCIAborts
 	SUBS	pc, lr, #8
 |
	SetMode	SVC32_mode, r0
	ADR	r0, DAbortString
	B	ExceptionHandler
 ]

AddExHandler
	SetMode	SVC32_mode, r0
	ADR	r0, AddExString
	B	ExceptionHandler

IRQHandler
	SetMode	SVC32_mode, r0
	MOV	r1, #&03200000
	MOV	r0, #&ffffffff
	STR	r0, [r1, #&314]

	mrs	AL, r0, CPSR_all
	BIC	r0, r0, #I32_bit 
	msr	AL, CPSR_all, r0

	ADR	r0, IRQString
	B	ExceptionHandler

FIQHandler
	SetMode	SVC32_mode, r0
	MOV	r1, #&03200000
	MOV	r0, #&ffffffff
	STR	r0, [r1, #&314]

	mrs	AL, r0, CPSR_all
	BIC	r0, r0, #F32_bit 
	msr	AL, CPSR_all, r0

	ADR	r0, FIQString
	B	ExceptionHandler


UndefString	=	"Undefined instruction", CR, LF, 0
SWIString	=	"SWI called", CR, LF, 0
IAbortString	=	"Instruction fetch abort", CR, LF, 0
DAbortString	=	"Data abort", CR, LF, 0
AddExString	=	"Address exception!", CR, LF, 0
IRQString	=	"IRQ happened", CR, LF, 0
FIQString	=	"FIQ happened", CR, LF, 0
	ALIGN



	%	&3FFF :AND: -{PC}	; align to 16K boundary
ROML1PT
	BIN	"L1PTC"


;-------------------------------------------------------------------------------


        GET     s.spd
        GET     s.more_cmds
        GET     s.do_tests
        GET     s.codec
        GET     s.vidtest


;-------------------------------------------------------------------------------


ROMFill
	WHILE	{PC} < &00400000	; 4MB
	DCD	{PC}
	WEND
	

	END
