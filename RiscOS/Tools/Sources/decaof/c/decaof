/*
  Title:     AOF File Decoder
  Copyright: (C) 1991, Advanced RISC Machines Ltd., Cambridge, England.
*/

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include <stdio.h>
#include <signal.h>
#include <ctype.h>
#ifdef __STDC__
#  include <stdlib.h>
#  include <string.h>
#  ifdef __GNUC__
#    define EXIT_SUCCESS    0
#    define EXIT_FAILURE    1
#  endif
#else
#  include <strings.h>
char *malloc();
void free();
#  define EXIT_SUCCESS    0
#  define EXIT_FAILURE    1
#endif

#ifndef SEEK_END
#  define  SEEK_SET       0
#  define  SEEK_END       2
#endif

#include "chunkfmt.h"
#include "chunkfls.h"
#include "aof.h"
#include "err.h"
#include "bytesex.h"
#include "decasd.h"   /* for decoding debug tables */
#include "disass.h"   /* instruction disassembly */
#include "prgname.h"  /* decodes program name */

#include "VersionNum"
#include "dem.h"

#define  SELF         "AOF Decoder"
#define  VSN          Module_MajorVersion
#define  BRIEF        "decodes an ARM Object Format (AOF) file"

#ifndef __DATE__
#  include "datenow.h"
#endif

#define  OK           0
#define  BAD          1

#define  A_DECLS      0x01
#define  A_CONTENTS   0x02
#define  A_SYMBOLS    0x04
#define  A_STRINGS    0x08
#define  A_DEBUG      0x10
#define  A_ALL        0x1f
#define  A_BRIEF      0x20
#define  A_RELOCS     0x40
#define  A_DISASS     0x80

static int enable_demangle = 0;

#define  INITOBJSIZE  65400

#ifndef int32
#  define int32 long  int
#endif
#ifndef unsigned32
#  define unsigned32  unsigned long
#endif

#define hv(v)         bytesex_hostval(v)

static char *object, *strt, *areas;
static aof_symbol *symt;
static int32 object_size, areas_size, symt_size, strt_size, idfn_size;
static int endian_ness = -1;
static aof_header *header;

static int which_endian(cf_magic)
int32 cf_magic;
{ int rc;
  static int32 which_end = (CF_BIG << 24) | 0x00ffff00 | CF_LITTLE;
  endian_ness = -1;
  bytesex_reverse((cf_magic & 255) == ((CF_MAGIC >> 24) & 255) ? 1 : 0);
  if (hv(cf_magic) != CF_MAGIC) return -1;
  rc = *((unsigned char *)&which_end);
  if (rc != (rc & (CF_BIG|CF_LITTLE))) return -1;
  if (bytesex_reversing()) rc = CF_BIG+CF_LITTLE - rc;
  endian_ness = rc;
  return rc;
}

static char *demangle_string(char *str)
{ static char obuf[MAXDBUF];
  if (enable_demangle && demangle(str, obuf) == 0) return obuf;
  return str;
}

static char *print_string(idx)
int32 idx;
{ char *ret;
  if (idx < 0 || idx > strt_size || !strt)
    printf(ret="<bad string index>");
  else
  { char *cp = demangle_string(strt + idx);
    char c;
    ret=cp;
    while ((c = *cp++) != 0)
    { if (c & 128) putchar('`');
      c &= 0x7f;
      if (c < 32) { putchar('|'); c += '@';}
      if (c == '|') putchar('|');
      putchar(c);
    }
  }
  return ret;
}

static void print_header(h, idfn, file)
aof_header *h;
char *idfn;
char *file;
{
  if (idfn != NULL && idfn_size > 0)
  { int32 j = 0;
    int nl = 0;
    printf("\n** Identification (file %s)\n\n", file);
    while (j < idfn_size)
    { char ch = idfn[j++];
      if (ch == 0) break;
      if (ch == '\n') nl = 1; else nl = 0;
      putchar(ch);
    }
    if (!nl) putchar('\n');
  }

  printf("\n** Header (file %s)\n\n", file);

  printf("AOF file type: ");
  if (endian_ness == CF_BIG) printf("Big"); else printf("Little");
  printf("-endian, ");

  switch (hv(h->aof_type))
  {
case AOF_RELOC:
    printf("Relocatable object code\n");
    break;
case AOF_RELOC+1:
    printf("Obsolete Image type (%s)\n", "contiguous RO and RW areas");
    break;
case AOF_RELOC+2:
    printf("Obsolete Image type (%s)\n", "page-aligned RW area");
    break;
case AOF_RELOC+3:
    printf("Obsolete Image type (%s)\n",
           "page-aligned RW area/block-aligned RO area");
    break;
default:
    printf("Unknown type %.8lx\n", hv(h->aof_type));
    break;
  }

  printf("AOF Version:   %3ld\n",   hv(h->aof_vsn));
  printf("No of areas:   %3ld\n",   hv(h->aof_nareas));
  printf("No of symbols: %3ld\n\n", hv(h->aof_nsyms));

  { int32 entryarea = hv(h->aof_entryarea);
    if (entryarea > 0 && entryarea <= hv(h->aof_nareas))
    { printf("Entry point at offset 0x%.4lx in area ", hv(h->aof_entryoffset));
      if (strt == NULL)
        printf("%ld\n", entryarea);
      else
      { putchar('"');
        print_string(hv(h->aof_areas[entryarea-1].area_name));
        printf("\"\n");
      }
    }
  }
  putchar('\n');
}

static unsigned two_to_the(n)
int n;
{
  unsigned u = 1;
  while (n-- > 0) u <<= 1;
  return u;
}

static void print_relocation(h, r, area, n)
aof_header *h;
aof_reloc *r;
char *area;
int n;
{ static char *field_type[] = { "Byte ", "Short", "Word ", "Instr"};
  int32 offset = hv(r->rel_offset);
  int32 flags = hv((int32)(r->rel_flags));
  int sid, FT, A, R, B;

  if (rel_type2(flags))
  { sid = rel2_sid(flags);
    FT  = rel2_FT(flags);
    R   = rel2_R(flags);
    A   = rel2_A(flags);
    B   = rel2_B(flags);
  }
  else
  { sid = rel1_sid(flags);
    FT  = rel1_FT(flags);
    R   = rel1_R(flags);
    A   = rel1_A(flags);
    if (R)  A = 1;
    if (!A) sid = n;
    B   = 0;
  }

  printf("At %.6lx: %s", offset, field_type[FT]);
  if (FT == 0)
    printf("      [%.2x]", *(area + offset));
  else if (FT == 1)
    printf("    [%.4lx]", hv((int32)*((short *)(area + offset))));
  else if (FT >= 2)
    printf("[%.8lx]", hv(*((long *)(area + offset))));

  if (R && B) printf(" tailcall to ");
  else if (R) printf(" PC-relative to ");
  else if (B) printf(" base-relative to ");
  else        printf(" displaced by ");

  if (A)
  { printf("symbol ");
    if ((sid * (int32)sizeof(aof_symbol) <  symt_size) && (strt != NULL))
      print_string(hv(symt[sid].sym_name));
    else
      printf("<bad symbol number>");
  }
  else
  { printf("base of area ");
    print_string(hv(h->aof_areas[sid].area_name));
  }
  putchar('\n');
}

static char *relocs;
static int32 relocsize;

char *symbol_relocating(offset)
int32 offset;
{ aof_reloc *base = (aof_reloc *)relocs,
            *end =  (aof_reloc *)(relocs + relocsize),
            *r = base;
  for (; r < end; r++)
  { int32 r_offset = hv(r->rel_offset);
    int32 sid, A;
    if (r_offset == offset)
    { int32 r_flags = hv((int32)(r->rel_flags));
      if (rel_type2(r_flags))
      { sid = rel2_sid(r_flags);
        A   = rel2_A(r_flags);
      } else {
        sid = rel1_sid(r_flags);
        A   = rel1_A(r_flags);
      }
      if (A)
      { if ((sid * (int32)sizeof(aof_symbol) <  symt_size) && (strt != NULL))
          return strt+hv(symt[sid].sym_name);
        else
          return 0;
      } else {
        return strt+hv(header->aof_areas[sid].area_name);
      }
    }
  }
  return 0;
}

static char *disass_cb(type, offset, address, width, cb_arg, buf)
dis_cb_type type;
int32 offset;
unsigned32 address;
int width;
VoidStar cb_arg;
char *buf;
{
  switch (type) {
  case D_BORBL:
    { char *sym = symbol_relocating((int32)address-offset-8);
      if (sym != NULL) {
        int len;
        sym = demangle_string(sym);
        len = strlen(sym);
        memcpy(buf, sym, len);
        buf += len;
        if (address != 0) {
          if ((int32)address < 0)
            sprintf(buf, "-0x%lx", -address);
          else
            sprintf(buf, "+0x%lx", address);
          buf += strlen(buf);
        }
      }
      else {
      }
    }
    break;
  case D_LOAD:
  case D_STORE:
  default:
    break;
  }
  return buf;
}

static void print_areas(h, opts)
aof_header *h;
int opts;
{
  aof_area *a = h->aof_areas;
  int nareas = (int) hv(h->aof_nareas);
  int32 base = 0, limit = 0;

  int n;
  for (n = 0;  n < nareas; ++n, ++a, base = limit+relocsize)
  {/*
    * First print the area header...
    */
    int32 attributes = hv(a->area_attributes);
    int32 size = hv(a->area_size);
    if (!(attributes & AOF_0INITAT))
    { limit = (base + size + 3L) & ~3L;
      if (limit > areas_size) limit = areas_size;
      relocsize = hv(a->area_nrelocs) * ((int32) sizeof(aof_reloc));
      if (limit+relocsize > areas_size) relocsize = areas_size-limit;
    } else {
      limit = base;
      relocsize = 0;
    }
    if (!(attributes & AOF_DEBUGAT) && !(opts & A_DECLS)) continue;

    printf("** Area ");
    print_string(hv(a->area_name));
    printf(", Alignment %u, Size %lu (0x%.4lx), %lu relocations\n",
           two_to_the((int)(attributes & AOF_ALMASK)),
           size, size, hv(a->area_nrelocs));
    printf("        Attributes");
    if (attributes & AOF_ABSAT) printf(": Absolute");
    if (attributes & AOF_CODEAT)
    { printf(": Code");
      if (attributes & AOF_CODEXATs)
      { int ch = '{';
        if (attributes & AOF_32bitAT) {printf("%c32bit", ch);  ch = ',';}
        if (attributes & AOF_REENTAT) {printf("%creentrant", ch);  ch = ',';}
        if (attributes & AOF_FP3AT)   {printf("%cFPIS3", ch);  ch = ',';}
        if (attributes & AOF_NOSWSTKCK)printf("%cNoSWStackCheck", ch);
        fputc('}', stdout);
      }
      if (attributes & AOF_PICAT) printf(": Position-independent");
    }
    else
    { printf(": Data");
      if (attributes & AOF_SHLDATA)
        printf(": Stub data");
      if (attributes & AOF_BASEDAT)
        printf(": Based r%lu", (attributes >> AOF_BASESHIFT) & 0xf);
    }
    if (attributes & AOF_COMDEFAT) printf(": Common definition");
    if (attributes & AOF_COMREFAT) printf(": Common");
    if (attributes & AOF_0INITAT)  printf(": Zero initialised");
    if (attributes & AOF_RONLYAT)  printf(": Read only");
    else                           printf(": Read Write");
    if (attributes & AOF_DEBUGAT)  printf(": Debugging tables");
    putchar('\n');
    if (attributes & AOF_ABSAT)
      printf("        Base address 0x%.6lx\n", hv(a->area_base));
    else
      a->area_base = 0;   /* just in case it isn't */

    if (areas != NULL && !(attributes & AOF_0INITAT) && size > 0)
    { int32 address;
      relocs = areas+base+size;
      if ((attributes & AOF_DEBUGAT) && (opts & A_DEBUG))
      { /*
         * Decode debugging area
         */
        char *debugdata = areas + base;
        char *debugend = debugdata + size;
        putchar('\n');
        set_debug_area_base(debugdata);
        while (debugdata < debugend)
        { debugdata = decasd_section(debugdata, debugend);
          if (debugdata == NULL) break;
        }
      }
      else
      {/*
        * Print the area contents...
        */
        address = hv(a->area_base);
        if ((attributes & AOF_CODEAT) && (opts & A_DISASS))
        { char buf[256];
          int32 p = base;
          for (; p < limit; p += (int32)sizeof(int32)) {
            int32 instr = hv(*(int32 *)(areas+p));
            char *cp = areas + p;
            int i;
            disass(instr, address, buf, (VoidStar)NULL, disass_cb);
            printf("  0x%.6lx:  %.8lx  ", address, instr);
            for (i = 0; i < 4; i++) {
                unsigned char c = *cp++;
                putchar(isprint(c) ? c : '.');
            }
            printf(" : %s\n", buf);
            address += sizeof(int32);
          }
        } else if (opts & A_CONTENTS)
        { int32 p = base;
          int32 count = 0;
          for (; p < limit; p += (int32)sizeof(int32), count++)
          { if ((count & 7) == 0)
            { printf("\n%.6lx:", address);
              address += (int32) (sizeof(int32)*8);
              count = 0;
            }
            printf(" %.8lx", hv(*((int32 *) (areas + p))));
          }
        }
      }
      /*
       * Print the relocation directives...
       */
      address = base;
      if (opts & A_RELOCS)
      { int32 p = limit;
        if (relocsize != 0) printf("\n\n** Relocation table\n\n");
        for (; p < limit+relocsize; p += (int32)sizeof(aof_reloc))
          print_relocation(h, (aof_reloc *)(areas + p), areas + address, n);
      }
    }
    printf("\n\n");
  }
}

static void print_symbols(h, file)
aof_header *h;
char *file;
{
  int32 len;
  aof_symbol *sym = symt;

  if (!symt)
  {   printf("** No symbol table **\n\n");
      return;
  }
  len = hv(h->aof_nsyms) * (int32) sizeof(aof_symbol);
  if (len != symt_size)
  {   err_report("anomaly: symbol table size %ld != OBJ_SYMT chunk size %ld",
                 len, symt_size);
      if (len > symt_size) len = symt_size;
  }
  len = len / (int32) sizeof(aof_symbol);

  if (len <= 0) return;

  printf("** Symbol Table (file %s):-\n\n", file);

  for (; len-- > 0; ++sym)
  { int32 symname = hv(sym->sym_name);
    int attributes;
    int l;

    l = strlen(print_string(symname));
    if (l > 20) { putchar('\n');  l = 0;}
    while (l++ < 20) putchar(' ');
    printf(" : ");

    attributes = (int) hv(sym->sym_AT);
    if ((attributes & SYM_REFDEFMASK) == SYM_REFAT)
    { printf("External ");
      if (attributes & SYM_COMMONAT) printf("common ");
      printf("reference");
      if (attributes & SYM_FPREGAT)  printf(", FPRegArgs, ");
      if (attributes & SYM_NOCASEAT) printf(", No-case");
      if (attributes & SYM_WEAKAT)   printf(", Weak");
      if (attributes & SYM_COMMONAT)
          printf(", size = 0x%.4lx", sym->sym_value);
    }
    else
    { if ((attributes & SYM_REFDEFMASK) == SYM_LOCALDEFAT)
        printf("Local,  ");
      else
        printf("Global, ");
      if (attributes & SYM_DATAAT)
        printf("Data, ");
      else
      { if (attributes & SYM_FPREGAT)  printf("FPRegArgs, ");
        if (attributes & SYM_USESSBAT) printf("Sb, ");
        if (attributes & SYM_LEAFAT)   printf("Leaf, ");
      }
      if (attributes & SYM_ABSAT)
        printf("Absolute, ");
      else
        printf("Relative, ");
      if (attributes & SYM_STRONGAT) printf("Strong, ");
      if (attributes & SYM_ABSAT)
        printf("value 0x%.4lx", hv(sym->sym_value));
      else
      { printf("offset 0x%.4lx in area \"", hv(sym->sym_value));
        print_string(hv(sym->sym_areaname));
        putchar('"');
      }
    }
    putchar('\n');
  }
  printf("\n\n");
}

static void print_strings(h, file)
aof_header *h;
char *file;
{
  char *s = strt;
  int32 j, len, l, aofvsn;

  if (s == NULL)
  { printf("** No string table **\n\n");
    return;
  }

  j = 0;
  aofvsn = hv(h->aof_vsn);
  if (aofvsn < 150)
    len = strt_size;
  else
  { len = hv(*((int32 *)s));
    l = (len +3) & ~3;
    if (len == strt_size || l == strt_size)
      j = sizeof(int32);
    else
    { err_report("anomaly: string table size %lx != OBJ_STRT chunk size %lx\n",
                 len, strt_size);
      len = strt_size;
    }
  }

  printf("** String Table (file %s):-\n\n", file);
  printf("Offset  String-name\n");
  printf("-------------------\n");

  while (j < len)
  { l = j;
    while (l < len && s[l] != 0) ++l;
    if (l == len) s[l-1] = 0;
    if (l > 0)
    { printf("%6lu: ", j);
      print_string(j);
      putchar('\n');
    }
    j = l + 1L;
    if (aofvsn < 150)
    { while (j < len && (j & 3L) != 0) ++j;
    }
    else
    { while (s[j] == 0) ++j;
    }
  }
}

static char bad_file[] = "%s is corrupt";

static int process(file, opts)
char *file;
int opts;
{
  int32 size, maxchunks, numchunks;
  cf_header *cfh;
  int idx;
  aof_header *h;
  char *idfn;
  FILE *f = fopen(file, "rb");

  if (f == NULL)
  { err_report("File %s doesn't exist?", file);
    return BAD;
  }

  fseek(f, 0L, SEEK_END);
  size = ftell(f);

  if (size > object_size || object == NULL)
  { while (size > object_size) object_size *= 2;
    if (object != NULL) free (object);
    object = (char *) malloc((int)object_size);
    if (object == NULL)
    { err_fail("Not enough memory to process %s (need %lu bytes)", file, size);
      fclose(f);
      return BAD;
    }
  }

  fseek(f, 0L, SEEK_SET);
  if (fread(object, 1, (size_t)size, f) != size)
  { err_report("Failed to load %s", file);
    fclose(f);
    return BAD;
  }
  fclose(f);

  cfh = (cf_header *)object;
  if (size < sizeof(int32) || which_endian(cfh->cf_magic) < 0)
  { err_report("%s isn't a chunk file", file);
    return BAD;
  }
  /* Assert: size >= sizeof(int32) && which_endian(...cf_magic) >= 0.     */
  /* Assert: endian_ness and reverse_bytes have been set by which_endian. */

  maxchunks = hv(cfh->cf_maxchunks);
  numchunks = hv(cfh->cf_numchunks);
  if ((maxchunks < numchunks) ||
      ((maxchunks - 1)*sizeof(cf_entry) + sizeof(cf_header) >= size))
  { err_report(bad_file, file);
    return BAD;
  }

  for (idx = 0; idx < maxchunks; idx++)
  { int32 cfesize, cfeoffset;
    cf_entry *ce = &(cfh->cf_chunks[idx]);
    cfesize = hv(ce->cfe_size);
    cfeoffset = hv(ce->cfe_offset);

    if (cfeoffset == 0 ||
         (cfeoffset > 0 && cfesize >= 0 &&
         (cfeoffset <= (size - cfesize))))
      continue;
    err_report(bad_file, file);
    return BAD;
  }

  if ((idx = cf_index(cfh, OBJ_HEAD)) == -1)
  { err_report("%s isn't an AOF file", file);
    return BAD;
  }

  h = (aof_header *) (object + hv(cfh->cf_chunks[idx].cfe_offset));
  header = h;

  if ((idx = cf_index(cfh, OBJ_IDFN)) == -1)
  { idfn = NULL;
    idfn_size = 0;
  }
  else
  { idfn = (char *) (object + hv(cfh->cf_chunks[idx].cfe_offset));
    idfn_size = hv(cfh->cf_chunks[idx].cfe_size);
  }

  if ((idx = cf_index(cfh, OBJ_SYMT)) == -1)
  { symt = NULL;
    symt_size = 0;
  }
  else
  { symt = (aof_symbol *) (object + hv(cfh->cf_chunks[idx].cfe_offset));
    symt_size = hv(cfh->cf_chunks[idx].cfe_size);
  }

  if ((idx = cf_index(cfh, OBJ_STRT)) == -1)
  { strt = NULL;
    strt_size = 0;
  }
  else
  { strt = (char *) (object + hv(cfh->cf_chunks[idx].cfe_offset));
    strt_size = hv(cfh->cf_chunks[idx].cfe_size);
  }

  print_header(h, idfn, file);

  areas = NULL;
  areas_size = 0;
  if ((idx = cf_index(cfh, OBJ_AREA)) != -1)
  { areas = (char *) (object + hv(cfh->cf_chunks[idx].cfe_offset));
    areas_size = hv(cfh->cf_chunks[idx].cfe_size);
  }
  else
    printf("** No OBJ_AREA Chunk **\n\n");

  if (opts & (A_DECLS|A_DEBUG|A_DISASS)) print_areas(h, opts);
  if (opts & A_SYMBOLS) print_symbols(h, file);
  if (opts & A_STRINGS) print_strings(h, file);

  return OK;
}

static void handle_escape(signo)
int signo;
{ signal(signo, handle_escape);
  exit(EXIT_FAILURE);
}

static void give_help(myname)
char *myname;
{
  printf("\n%s Version %s [%s]\n       - %s\n", SELF, VSN, Module_Date, BRIEF);
  printf("\n%s [options] file [file...]\n", myname);
  printf("\nOptions:-\n");
  printf("-b   (brief) print only the area declarations\n");
  printf("-a   print area contents in hex (=> -d)\n");
  printf("-d   print area declarations\n");
  printf("-r   print relocation directives (=> -d)\n");
  printf("-c   disassemble code areas (=> -d)\n");
  printf("-g   print debug areas formatted readably\n");
  printf("-s   print symbol table\n");
  printf("-t   print string table\n");
  printf("\nExamples:-\n");
#ifdef __riscos
  printf("     %s -agst o.myprog\n", myname);
  printf("     %s -b o.test1 o.test2 o.test3\n", myname);
#else
  printf("     %s -agst myprog.o\n", myname);
  printf("     %s -b test1.o test2.o test3.o\n", myname);
#endif
}

static int cistrcmp(s1, s2)
char *s1, *s2;
{ for (;;)
  { int ch1 = *s1++,
        ch2 = *s2++;
    /* care here for portability... don't rely on ANSI spec */
    if (isupper(ch1)) ch1 = tolower(ch1);
    if (isupper(ch2)) ch2 = tolower(ch2);
    if (ch1 != ch2) return ch1-ch2;
    if (ch1 == 0) return 0;
  }
}

int main(argc, argv)
int argc;
char *argv[];
{
  int j, nf, rc, opts;
  static char myname[32];

  signal(SIGINT, handle_escape);
  err_init(SELF);

  (void) program_name(argv[0], myname, sizeof(myname));

  /* parse help or identify args */
  if (argc <= 1)
  { give_help(myname);
    exit(EXIT_FAILURE);
  }

  for (j = 1;  j < argc;  ++j)
  { char *arg = argv[j];
    if (cistrcmp("-help", arg) == 0 || cistrcmp("-h", arg) == 0)
    { give_help(myname);
      exit(EXIT_SUCCESS);
    }
  }

  nf = 0;  opts = 0;
  for (j = 1;  j < argc;  ++j)
  { char *arg = argv[j];
    if (arg[0] == '-')
    { while ((++arg)[0])
        switch (arg[0])
        {
case 'a':
case 'A': opts |= A_DECLS + A_CONTENTS;
          break;
case 'b':
case 'B': opts = A_DECLS + A_BRIEF;
          break;
case 'c':
case 'C':
          if (arg[1] == '+' && arg[2] == '+') {
                  enable_demangle = 1;
                  ++arg; ++arg;
          }
          else opts |= A_DECLS + A_DISASS;
          break;
case 'd':
case 'D': opts |= A_DECLS;
          break;
case 'r':
case 'R': opts |= A_RELOCS + A_DECLS;
          break;
case 'g':
case 'G': opts |= A_DEBUG;
          break;
case 's':
case 'S': opts |= A_SYMBOLS;
          break;
case 't':
case 'T': opts |= A_STRINGS;
          break;
default:
          err_report("unrecognised flag option %s (ignored)", arg);
          break;
        }
    }
    else
      ++nf;
  }

  if (opts == 0) opts = A_DECLS | A_SYMBOLS | A_STRINGS;
  if ((opts & A_BRIEF) && (opts & (A_ALL - A_DECLS)))
  { err_report("-b overrides other options (which have been ignored)");
    opts = A_DECLS;
  }

  if (nf == 0) err_fail("missing file argument(s)");

  object = NULL;
  object_size = INITOBJSIZE;
  rc = OK;
  for (j = 1;  j < argc;  ++j)
  { char *arg = argv[j];
    if (arg[0] != '-' && process(arg, opts) != OK) rc = BAD;
  }

  return rc;
}
