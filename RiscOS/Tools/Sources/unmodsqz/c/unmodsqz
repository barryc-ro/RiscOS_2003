/*
 * unmodsqz - reverses the effect of modsqz
 *
 * Copyright (C) Acorn Computers Ltd. 1998
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include "kernel.h"
#include "swis.h"
#include "VersionNum"

#define Program_Title "unmodsqz"

static int verbose = 0;

/*
 * This structure mimics that which the kernel uses to remember module
 * details.  We pass this to the assembler code we pinched from the kernel
 * to avoid having to change any of the main parts of the unsqueezing code.
 */
typedef struct modchain {
        struct modchain *next;
        int *code;
        int podule_base;
        void *incarn_list;
        int rommodule_node;
} modchain;

/* The assembler entry point */
extern void CheckModule(modchain *);

/* Error messages */
static const char err_NO_FILENAME[] = "missing filename";
static const char err_HELP[] =
	"\nUsage:         " Program_Title " [options] infile [outfile]\n\n"
	"Options:\n"
	"  -o output    Writes unsqueezed module to output\n"
	"  -v           Verbose\n"
	"  -h -?        Display help message\n";
static const char err_BAD_OPTION[] = "unrecognised option '%c'";
static const char err_BAD_PARAMETERS[] = "too many parameters";
static const char err_NO_OPEN[] = "unable to open `%s' for %sing";
static const char err_NOT_MODULE[] = "not a relocatable module";
static const char err_NO_RMA[] = "Unable to allocate RAM for module";
static const char err_NO_LOAD[] = "Unable to load input file";
static const char err_NO_PARAMS[] = "missing filenames";


static void banner(void)
{
        static int shown = 0;
        if (shown) return;
        ++shown;
	fputs("Acorn Module Unsqueeze Utility version " Module_MajorVersion " ["
		Module_Date "] " Module_MinorVersion "\n", stderr);
}

/* Print error message - does not return */
static void err(const char *errstring, ...)
{
        va_list ap;
	banner();
        if (errstring != err_HELP) fprintf(stderr, Program_Title ": ");
	va_start(ap, errstring);
	vfprintf(stderr, errstring, ap);
	va_end(ap);
	fputc('\n', stderr);
        exit(EXIT_FAILURE);
}

static void info(const char *info, ...)
{
        va_list ap;
	banner();
	va_start(ap, info);
	vfprintf(stderr, info, ap);
	va_end(ap);
}

static int file_length(const char *filename, int *load, int *exec, int *attr)
{
        _kernel_oserror *e;
        int size;
        int objtype, filetype;
        e = _swix(OS_File, _INR(0,1)|_OUT(0)|_OUTR(2,6), 20, filename,
                &objtype, load, exec, &size, attr, &filetype);
        if (e != NULL) {
                err("%s", e->errmess);
        }
        else {
                if (!(objtype & 1) ||  filetype != 0xFFA) {
                        err(err_NOT_MODULE);
                }
        }
        return size;
}

static void restamp(const char *filename, int load, int exec, int attr)
{
        load |= 0xFFFFFA00;
        (void) _swix(OS_File, _INR(0,3)|_IN(5), 1, filename, load, exec, attr);
}

int main(int argc, char *argv[])
{
        modchain chn;
        int load, exec, attr, size;
        int realsize;
        int *orig;
	FILE *f = 0;
	char *outfile = 0, *infile = 0;
	int ac;

	for (ac=1; ac<argc; ++ac) {
	        char *arg = argv[ac];
	        if (arg[0] == '-') {
	                while (*++arg) switch (*arg) {
	                        case 'v': ++verbose; break;
	                        case 'o':
	                                if ((ac+1)<argc) {
	                                        if (outfile) {
	                                                err(err_BAD_PARAMETERS);
	                                        }
	                                        outfile = argv[++ac];
	                                }
	                                else {
	                                        err(err_NO_FILENAME);
	                                }
	                                break;
	                        case 'h': case '?':
	                               	err(err_HELP);
	                               	break;
	                        default:
	                        	err(err_BAD_OPTION, *arg);
	                               	break;

	                }
	                continue;
	        }
	        if (!infile) infile = arg;
	        else if (!outfile) outfile = arg;
	        else err(err_BAD_PARAMETERS);
	}

	if (!infile) err(err_NO_PARAMS);
	if (!outfile) outfile = infile;

	size = file_length(infile, &load, &exec, &attr);

	if (verbose) info("-- original file is %d bytes\n", size);

        f = fopen(infile, "rb+");
        if (f == NULL) {
                err(err_NO_OPEN, infile, "read");
	}

	memset(&chn, 0, sizeof(chn));

	/* Need to do this in the RMA because the assembler code assumes
	 * that the squeezed module is living somewhere where it can
	 * OS_Module 7 it.
	 */
	if (_swix(OS_Module, _IN(0)|_IN(3)|_OUT(2), 6, size, &chn.code)) {
		err(err_NO_RMA);
	}

	if (fread(chn.code, size, 1, f) != 1) {
	        err(err_NO_LOAD);
	}

	orig = chn.code;

	/* may include extra zero bytes to pad out original to even number
	 * of complete words
	 */
	realsize = chn.code[1];

	/* Was the top bit set in the initialise entry? */
	if (realsize < 0) {
	        realsize = (chn.code + ((realsize ^ 0x80000000) >> 2))[-5];
	}
	else {
	        free(chn.code);
	        if (verbose) info("-- source was not squeezed - module copied\n");
	        exit(EXIT_SUCCESS);
	}
	CheckModule(&chn);
	if (chn.code != orig) {
	        /* Clear invincible bit - if set, stops *RMClear killing it!! */
	        chn.code[2] &= ~0x80000000;
	        if (infile != outfile) {
			f = freopen(outfile, "wb", f);
	        }
	        else {
	                rewind(f);
	        }
		if (f) fwrite(chn.code, realsize, 1, f);
		else err(err_NO_OPEN, outfile, "writ");
		fclose(f);
		restamp(outfile, load, exec, attr);
	}
	else {
	        if (verbose) info("-- not squeezed with modsqz\n");
	}

	free(chn.code);

	if (verbose) info("-- output size %d bytes\n", realsize);

        return EXIT_SUCCESS;
}
