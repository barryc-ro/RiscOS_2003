/*
 *
 *  Copyright (c) 2000 by Pace Micro Technology plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Technology
 * plc.
 *
 *
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

/* This program converts a binary file into a C representation as an array of
 * unsigned long.  It mirrors identically the functionality of the Windows only
 * tool supplied by PowerTV as part of their build environment, with the added
 * enhancement of endian-ness options.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stdarg.h>

#include "bytesex.h"
#include "VersionNum"

#define PROGNAME "bin2c"

static void usage(void)
{
        fprintf(stderr, PROGNAME
                " " Module_MajorVersion " [" Module_Date "]\n"
                "Usage: bin2c [-s] [-static] [-global] [-nonconst] "
                "[-bigendian|-littleendian] "
                "<file1> [<file2> ...]\n");
}

static void help(void)
{
        fprintf(stderr,
                "  -s            strips input file extension, if present\n"
                "  -static       makes array static\n"
                "  -global       makes a global reference\n"
                "  -nonconst     makes the array not be marked const\n"
                "  -bigendian    (DEFAULT)  Assume target is big-endian\n"
                "  -littleendian Assume target is little-endian\n"
                "\n");
}

static struct cli_options {
        int strip;
        int symstatic;
        int glob;
        int nonconst;
        int revendian;
} a = {
        0, 0, 0, 0, 0
};

static void sex_init(void)
{
        /* Determine sex of machine.  Relies on memory encoding of integers */
        union {
                char c[sizeof(unsigned int)];
                unsigned int i;
        } gross_ugly_hack;
        gross_ugly_hack.i = 1;
        /* If that statement sets c[0], this is little endian host */
        bytesex_reverse((gross_ugly_hack.c[0] != 1) ^ (a.revendian == 0));
}

static void fatal(const char *fmt, ...)
{
        va_list ap;

        fprintf(stderr, PROGNAME ": ");
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
        fputc('\n', stderr);
        exit(EXIT_FAILURE);
}

static void *safe_malloc(size_t n)
{
        void *const vp = malloc(n);
        if (!vp) {
                fatal("not enough memory");
        }

        return vp;
}


static int parse_arg(char *arg)
{
        if (*arg++ != '-') return 0;
        if (strcmp(arg, "s") == 0) a.strip = 1;
        else if (strcmp(arg, "static") == 0) a.symstatic = 1;
        else if (strcmp(arg, "global") == 0) a.glob = 1;
        else if (strcmp(arg, "nonconst") == 0) a.nonconst = 1;
        else if (strcmp(arg, "bigendian") == 0) a.revendian = 0;
        else if (strcmp(arg, "littleendian") == 0) a.revendian = 1;
        else if (strcmp(arg, "help") == 0) {
                usage();
                help();
                exit(EXIT_SUCCESS);
        }
        else {
                fatal("unknown option: %s", arg);
        }

        return 1;
}

static char *Strdup_ext(const char *s1, const size_t extra)
{
        if (s1 == NULL) {
                return NULL;
        }
        else {
                const size_t length = strlen(s1) + 1;
                char *const s2 = safe_malloc(length + extra);

                if (s2 == NULL) return NULL;
                return memcpy(s2, s1, length);
        }
}

static void process_file(char *filename, char *outname)
{
        FILE *f = fopen(outname, "w"), *g;
        long length;
        unsigned long bytes[4];
        time_t t;
        size_t c;

        g = fopen(filename, "rb");
        if (!g) {
                fatal("unable to open input file %s", filename);
        }
        time(&t);

        if (!f) {
                fatal("unable to open output file %s", outname);
        }

        fprintf(f, "/* Generated by " PROGNAME " at %s * Built from %s\n */\n\n",
                ctime(&t), filename);

        filename[strcspn(filename, ".")] = '\0';

        fseek(g, 0, SEEK_END);
        length = ftell(g);
        rewind(g);

        fprintf(f, "%s%sunsigned long %s_size = %ld;\t/* size in bytes */\n",
                a.symstatic ? "static " : "",
                a.nonconst ? "" : "const ", filename, length);
        fprintf(f, "%s%sunsigned long %s%s[] = {\n",
                a.symstatic ? "static " : "",
                a.nonconst ? "" : "const ", filename,
                a.glob ? "_local" : "");

        for (;;) {
                int d = 0;
                c = fread(bytes, 1, sizeof(bytes), g);
                if (!c) break;
                if (c < sizeof(bytes)) {
                        unsigned char *bp = (unsigned char *) bytes;
                        memset(bp + c, '\0', sizeof(bytes) - c);
                        c = (c + 3) & ~3;
                }

                while (d < c) {
                        unsigned long data = bytesex_hostval(bytes[d >> 2]);
                        fprintf(f, "0x%08lX,", data);
                        d += 4;
                        if (d < c) fputc(' ', f);
                }
                fputc('\n', f);
        }

        fprintf(f, "\n};\n");

        if (a.glob) {
                fprintf(f, "%sunsigned long *%s = %s_local;\n",
                        a.nonconst ? "" : "const ", filename, filename);
        }

        fclose(g);
        fclose(f);
}

int main(int argc, char **argv)
{
        while (argc > 1) {
                if (!parse_arg(argv[1])) break;
                ++argv;
                --argc;
        }

        if (argc < 2) {
                usage();
                exit(EXIT_FAILURE);
        }

        sex_init();

        while (argc > 1) {
                char *outname = Strdup_ext(argv[1], 2);
                if (a.strip) {
                        outname[strcspn(outname, ".")] = '\0';
                }
                strcat(outname, ".c");
                process_file(argv[1], outname);
                free(outname);
                ++argv;
                --argc;
        }

        return 0;
}
