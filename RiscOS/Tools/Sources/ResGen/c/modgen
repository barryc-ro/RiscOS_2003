/*
 * modgen - Generates modules containing ResourceFS data structures
 *
 *
 *  Copyright (c) 1999 by Pace Micro Technology plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stddef.h>
#include <locale.h>
#include <time.h>
#include <ctype.h>

#ifdef __riscos
#  define int32 size_t
#endif

/* These header files are supplied by CLX */
#include "host.h"
#include "bytesex.h"
#include "wholefls.h"
#include "filestamp.h"

#ifdef __riscos
#include "kernel.h"
#include "swis.h"
#include "Global/FileTypes.h"
#endif

#include "VersionNum"

static const char *program;

typedef struct ResFile {
    struct ResFile *next;
    char *infile;
    char *resfile;
} ResFile;

static void *check_malloc(size_t n)
{
        void *b = malloc(n);

        if (!b) {
                fprintf(stderr, "%s: Out of memory (unable to allocate %u bytes)\n", program, n);
                exit(EXIT_FAILURE);
        }

        return b;
}


static void modgen_check_args(int argc)
{
        if (argc < 5) {
                fprintf(stderr, "Syntax: %s <filename> <Module Name> <Module Help> <Module Version> "
                        "{ <Binary file> <Resource file> | -via <viafile> }\n", program);
                exit(EXIT_FAILURE);
        }
}

enum constants {
        XResourceFS_RegisterFiles       = 0x61b40ul,
        XResourceFS_DeregisterFiles,

        Service_ResourceFSStarting      = 0x60ul
};

/* Some ARM instruction encodings required for the module header code */
#define  SWIAL        0xEF000000u
#define  AL           0xE0000000u
#define  NE           0x10000000u
#define  TEQS_R1_0    0x03310000u
#define  MOVS_PC_LR   0x01B0F00Eu
#define  PUSH_LR      0x092D4000u
#define  PULL_PC      0x08BD8000u
#define  ADD_R0_PC    0x028F0000u
#define  MOV_A1_A1    0xE1A00000u /* MOV R0, R0 */
#define  MOV(rd,rs)  (0x01A00000u|((rd)<<12)|((rs)))
#define  SERVICESTM   0xE92D400Fu
#define  SERVICELDM   0xE8FD800Fu

/* The service call handler code.  Requires the add_pc_costant to be poked
 * to adjust it to point to the ResourceFS data structure
 */
typedef struct {
        int32   flags;
        int32   offset_to_code;
        int32   resourcefsstarting;
        int32   terminator;
        int32   offset_of_table;
        int32   magic_marker;
        int32   teq_r1_dec_96;
        int32   movne_pc_lr;
        int32   stack_regs;
        int32   add_pc_constant;
        int32   mov_lr_pc;
        int32   mov_pc_r2;
        int32   unstack_regs;
} service_call_handler;

/* The code for module initialisation or module finalisation (they are the same
 * except for the SWI called.  Requires the add_pc_constant to be poked
 * to adjust it to point to the ResourceFS data structure
 */
typedef struct {
        int32   stack_lr;
        int32   add_pc_constant;
        int32   swi_register;
        int32   unstack_pc;
} init_die_handler;

/* A module header data structure, plus the init, die & service call handlers */
typedef struct {
        int32   start;
        int32   init;
        int32   final;
        int32   service;
        int32   name;
        int32   help;
        int32   commands;
        int32   swi_base;
        init_die_handler        exec_init;
        init_die_handler        exec_die;
        service_call_handler    exec_service;
} module_header;

/* Since much of the stuff is constant, it is easier to just declare and initialise
 * a dummy module header with everything in it.  The only things that need adjustment are the
 * help string offset (need to add the length of the *name* in order to make it point past the
 * name, and the 3 offsets to the resourcefs data structure one each in the init, die and service
 * handlers.  The instructions are primed with an ADD R0,PC,#n instruction, requiring n to be
 * increased by the size of the module name and help string (rounded up)
 */
static const module_header template_header = {
        0,
        offsetof(module_header, exec_init),
        offsetof(module_header, exec_die),
        offsetof(module_header, exec_service.magic_marker),
        sizeof(module_header),
        sizeof(module_header) + 1,
        0,
        0,
        {
                AL|PUSH_LR,
                AL|ADD_R0_PC|
                        (sizeof(module_header)-offsetof(module_header, exec_init.add_pc_constant)-8),
                AL|SWIAL|XResourceFS_RegisterFiles,
                AL|PULL_PC
        },
        {
                AL|PUSH_LR,
                AL|ADD_R0_PC|
                        (sizeof(module_header)-offsetof(module_header, exec_die.add_pc_constant)-8),
                AL|SWIAL|XResourceFS_DeregisterFiles,
                AL|PULL_PC
        },
        {
                0,
                offsetof(module_header, exec_service.stack_regs),
                Service_ResourceFSStarting,
                0,
                offsetof(module_header, exec_service),
                MOV_A1_A1,
                AL|TEQS_R1_0|Service_ResourceFSStarting,
                NE|MOVS_PC_LR,
                AL|SERVICESTM,
                AL|ADD_R0_PC|
                        (sizeof(module_header)-offsetof(module_header, exec_service.add_pc_constant)-8),
                AL|MOV(14,15),
                AL|MOV(15,2),
                AL|SERVICELDM
        }

};

enum {
        arg_PROGRAM,
        arg_OUTFILE,
        arg_MODNAME,
        arg_MODHELP,
        arg_MODVERS,
        arg_BINFILE,
        arg_RESFILE,
        arg_MINUSVIA = arg_BINFILE,
        arg_VIAFILE
};

static void init_sex(void)
{
        /* Determine sex of machine.  Relies on memory encoding of integers */
        union {
                char c[sizeof(unsigned int)];
                unsigned int i;
        } gross_ugly_hack;
        gross_ugly_hack.i = 1;
        /* If that statement sets c[0], this is little endian and we don't need
         * sexing.  Only need sexing if we are big endian */
        bytesex_reverse(gross_ugly_hack.c[0] != 1);
}


static char *modgen_format_module_help(const char *helpstring, const char *version)
{
        size_t helplen = strlen(helpstring);
        char *help = check_malloc(helplen + 16 + 1 + strlen(version) + 1 + 14 + 1 + 1);
        time_t now = time(NULL);
        char datestr[16];

        setlocale(LC_TIME, "ISO8859-1");

        if (strftime(datestr, sizeof(datestr)-1, " (%d %b %Y)", localtime(&now))) {
                strcpy(help, helpstring);
                while (helplen < 16) {
                        strcat(help, "\t");
                        helplen += 8;
                }
                strcat(help, version);
                strcat(help, datestr);
        }
        else {
                fprintf(stderr, "Unable to format date string for module help string\n");
                exit(EXIT_FAILURE);
        }

        return help;
}

static void reverse_header(void *mh, size_t c)
{
        int32 *p = mh;
        c >>= 2;
        while (c-- > 0) {
                *p = bytesex_hostval(*p);
                ++p;
        }
}

static void modgen_write_module_header(FILE *f, module_header *mh, size_t headerlength)
{
        if (bytesex_reversing()) reverse_header(mh, sizeof(*mh));
        fwrite(mh, 1, headerlength, f);
        if (bytesex_reversing()) reverse_header(mh, sizeof(*mh));
}

static void modgen_die_missing_filename(const char *binary)
{
        fprintf(stderr, "Missing resource file for '%s'\n", binary);
        exit(EXIT_FAILURE);
}

static void modgen_die_generic_close_file(FILE *f, const char *outfile, const char *fmt, ...)
{
        va_list ap;

        fprintf(stderr, "%s: ", program);
        va_start(ap, fmt);
        vfprintf(stderr, fmt, ap);
        va_end(ap);
        if (f) {
                fclose(f);
        }
        if (outfile) {
                remove(outfile);
        }
        exit(EXIT_FAILURE);
}

static void align_fputs(const char *string, size_t length, FILE *f)
{
        size_t ptr;

        for (ptr=0; ptr<length; ++ptr) {
                fputc(string[ptr], f);
        }
        do {
                fputc('\0', f);
        } while (++ptr & 3);
}

#ifndef __riscos
static size_t modgen_derive_filetype(const char *filename)
{
        char *comma = strrchr(filename, ',');
        size_t type;
        int count = -1;

        if (comma && sscanf(comma+1, "%x%n", &type, &count) > 0 && count == 3) {
                return type;
        }
        return 0xFFF;
}

static void modgen_time_t_to_riscos(TimeStamp ts, size_t *load, size_t *exec)
{
        (void) ts;
        *load = (*load & ~0xFF) | 0;
        *exec = 0;
}
#endif

static void modgen_copy_file_information(FILE *f, int32 length, char *filename,
        const char *resfile, const char *out)
{
        typedef struct {
                size_t  next;
                size_t  load;
                size_t  exec;
                size_t  size;
                size_t  attr;
        } resourcefs_header;
        int32 w;
        resourcefs_header h;
        const size_t namelen = strlen(resfile);

#ifdef __riscos
        _kernel_oserror *e = _swix(OS_File, _INR(0,1)|_OUTR(2,5), 5, filename,
                &h.load, &h.exec, &h.size, &h.attr);
        if (e) {
                modgen_die_generic_close_file(f, out, "%s\n", e->errmess);
        }
#else
        TimeStamp ts;

        h.attr = 3;
        h.size = length;
        h.load = 0xFFF00000;
        h.exec = 0;
        h.load |= (modgen_derive_filetype(filename) << 8);
        ts = filestamp_get(filename);
        if (ts != -1) {
                modgen_time_t_to_riscos(ts, &h.load, &h.exec);
        }
#endif
        h.next = sizeof(h) + ((namelen + 4) & ~3) + 4 + ((length + 3) & ~3);
        if (bytesex_reversing()) reverse_header(&h, sizeof(h));
        fwrite(&h, 1, sizeof(h), f);
        align_fputs(resfile, namelen, f);
        length += 4;
        w = bytesex_hostval(length);
        fwrite(&w, 1, sizeof(w), f);
}

static ResFile **modgen_add_file(ResFile **pres, const char *load, const char *resfile)
{
        ResFile *r;
        const size_t extra = strlen(resfile) + 1;

        r = *pres = check_malloc(sizeof(*r) + extra + strlen(load) + 1);
        r->next = NULL;
        r->resfile = (char *) (r+1);
        r->infile = r->resfile + extra;
        strcpy(r->resfile, resfile);
        strcpy(r->infile, load);

        return &r->next;
}

static char *modgen_skip_spaces(char *ptr, char *eob)
{
        while (ptr < eob && isspace(*ptr)) {
                ++ptr;
        }

        return ptr == eob ? NULL : ptr;
}

static char *modgen_skip_string(char *ptr, char *eob)
{
        while (ptr < eob && !isspace(*ptr)) {
                ++ptr;
        }

        return ptr;
}

static ResFile **modgen_process_via(ResFile **pres, char *filename)
{
        int32 size;
        char *buffer, *ptr, *eobuffer;

        size = wf_filesize(filename);
        if (size == -1) {
                fprintf(stderr, "%s: unable to read size of via file %s\n", program, filename);
                exit(EXIT_FAILURE);
        }
        if (size == 0) {
                fprintf(stderr, "%s: warning: empty via file %s\n", program, filename);
                return pres;
        }

        buffer = check_malloc(size + 1);

        if (wf_load(filename, buffer, size) == -1) {
                fprintf(stderr, "%s: unable to load via file %s\n", program, filename);
                exit(EXIT_FAILURE);
        }

        eobuffer = buffer + size;
        *eobuffer = '\0'; /* Ensure a zero terminator */

        for (ptr = buffer; ptr < eobuffer; ) {
                char *binfile = modgen_skip_spaces(ptr, eobuffer);

                if (binfile) {
                        ptr = modgen_skip_string(binfile, eobuffer);
                        *ptr++ = '\0';
                        if (ptr < eobuffer) {
                                char *resfile = modgen_skip_spaces(ptr, eobuffer);
                                if (resfile == NULL) {
                                        modgen_die_missing_filename(binfile);
                                }
                                else {
                                        ptr = modgen_skip_string(resfile, eobuffer);
                                        *ptr++ = '\0';
                                        pres = modgen_add_file(pres, binfile, resfile);
                                }
                        }
                }
                else {
                        break; /* WTF? */
                }
        }

        free(buffer);
        return pres;
}

enum warning_flags {
        warn_ZERO_LENGTH_FILES = 1
};

static void modgen_banner(void)
{
        static int banner_shown = 0;

        if (!banner_shown++) {
                fprintf(stderr, "%s " Module_FullVersion " [" Module_Date "]\n", program);
        }
}

int main(int argc, char *argv[])
{
        const char *outfile = argv[arg_OUTFILE], *helpstring;
        module_header *header;
        size_t header_length;
        int opt;
        ResFile *res = NULL, **pres = &res;
        FILE *f;
        int32 w;
        int warnings = 0;

        host_init();
        program = strrchr(argv[0], host_dir_sep_char());
        program = program ? program+1 : argv[0];
        init_sex();

        for (opt = arg_PROGRAM + 1; opt < argc; ++opt) {
                const char *arg = argv[opt];
                if (*arg++ != '-') break;
                ++argv;
                --argc;
                if (strcmp(arg, "help") == 0) {
                        modgen_banner();
                        exit(EXIT_SUCCESS);
                }
                else if (tolower(*arg) == 'w') {
                        ++arg;
                        if (!*arg) {
                                warnings = -1;
                        }
                        else for (;*arg;++arg) {
                                char c = tolower(*arg);
                                if (isalpha(c)) {
                                        warnings |= 1<<(c - 'a');
                                }
                        }
                }
                else if (*arg == '-') {
                        /* Special marker for end of options - allows you to have names
                         * starting with - characters
                         */
                        break;
                }
                else {
                        fprintf(stderr, "%s: Unrecognised flag '%s'\n", program, arg);
                        exit(EXIT_FAILURE);
                }
        }

        modgen_check_args(argc);

        helpstring = modgen_format_module_help(argv[arg_MODHELP], argv[arg_MODVERS]);

        for (opt = arg_BINFILE; opt < argc; ++opt) {
                const char *arg = argv[opt];
                if (*arg == '-') {
                        if (*++arg == 'v') {
                                if (++opt >= argc) {
                                        modgen_die_missing_filename(arg);
                                }
                                pres = modgen_process_via(pres, argv[opt]);
                        }
                        else {
                                fprintf(stderr, "%s: Unrecognised flag '%s'\n", program, arg);
                                exit(EXIT_FAILURE);
                        }
                }
                else {
                        if (++opt >= argc) {
                                modgen_die_missing_filename(arg);
                        }
                        pres = modgen_add_file(pres, arg, argv[opt]);
                }
        }

        if (res == NULL) {
                fprintf(stderr, "Warning: No resource files specified\n");
        }

        f = fopen(outfile, "wb");
        if (!f) {
                fprintf(stderr, "%s: Unable to open output file %s\n", program, outfile);
                exit(EXIT_FAILURE);
        }

        header_length = sizeof(*header) + strlen(helpstring) + 1 + strlen(argv[arg_MODNAME]) + 1;
        header_length = (header_length + 3) & ~3;

        header = check_malloc(header_length);

        /* Initialise all the precalculated fields */
        memcpy(header, &template_header, sizeof(*header));
        /* Blank out the title and help string (to ensure zero padding in structure) */
        memset(header + 1, '\0', header_length - sizeof(*header));

        /* Fiddle the offsets */
        header->help += strlen(argv[arg_MODNAME]);
        header->exec_init.add_pc_constant += (header_length - sizeof(*header));
        header->exec_die.add_pc_constant += (header_length - sizeof(*header));
        header->exec_service.add_pc_constant += (header_length - sizeof(*header));

        sprintf((char *) (header + 1), "%s%c%s", argv[arg_MODNAME], '\0', helpstring);

        modgen_write_module_header(f, header, header_length);

        for (; res; res=res->next) {
                int32 infile_length = wf_filesize(res->infile);
                void *filebuf;

                if (infile_length == -1) {
                        modgen_die_generic_close_file(f, outfile, "Unable to read length of file '%s'",
                                res->infile);
                }
                if (infile_length == 0) {
                        if (!(warnings & warn_ZERO_LENGTH_FILES)) {
                                fprintf(stderr, "Warning: zero length file: '%s'\n", res->infile);
                        }
                }

                modgen_copy_file_information(f, infile_length, res->infile, res->resfile, outfile);

                /* avoid malloc(0) because that exhibits implementation dependent behaviour */
                filebuf = malloc(infile_length ? infile_length : 1);
                if (filebuf == NULL) {
                        /* Probably too big - copy by parts */
                        FILE *in = fopen(res->infile, "rb");
                        if (in == NULL) {
                                modgen_die_generic_close_file(f, outfile, "Unable to open file '%s'",
                                        res->infile);
                        }
                        else {
                                char buffer[BUFSIZ];

                                for (;;) {
                                        size_t count = fread(buffer, 1, sizeof(buffer), in);
                                        if (count > 0) {
                                                fwrite(buffer, 1, count, f);
                                        }
                                }
                                fclose(in);
                        }
                }
                else {
                        if (wf_load(res->infile, filebuf, infile_length) == -1) {
                                modgen_die_generic_close_file(f, outfile, "Unable to load file '%s'",
                                        res->infile);
                        }
                        else {
                                fwrite(filebuf, 1, infile_length, f);
                        }
                        free(filebuf);
                }

                while (infile_length & 3) {
                        fputc('\0', f);
                        ++infile_length;
                }
        }

        w = bytesex_hostval(0);
        fwrite(&w, 1, sizeof(w), f);
        if (fclose(f) == EOF) {
                modgen_die_generic_close_file(f, outfile, "Unable to write output file %s", outfile);
        }

#ifdef __riscos
        _swix(OS_File, _INR(0,2), 18, outfile, FileType_Module);
#endif

        return 0;
}
