/*---------------------------------------------------------------------------*/
/* File:    modgen.c                                                         */
/* Purpose: Generates a module containing files for ResourceFS               */
/* Author:  ***                                                              */
/* History: **-**-**: ***: Created.                                         */
/*          30-Apr-98: RML: Added ursula service call table to modules.      */
/*---------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#define Service_ResourceFSStarting 0x60

extern int hdr;
extern int init;
extern int die;
extern int service;
extern int messages;
#ifndef NO_SERVICE_TABLE
extern int service_table;
extern int service_ursula;
#endif

#define hdr ((int)&(hdr))
#define init ((int)&(init))
#define die ((int)&(die))
#define service ((int)&(service))
#define messages ((int)&(messages))
#ifndef NO_SERVICE_TABLE
#define service_table ((int)&(service_table))
#define service_ursula ((int)&(service_ursula))
#endif

typedef struct ResFile {
    struct ResFile *next;
    char *infile;
    char *resfile;
} ResFile;

static void *check_malloc(int n)
{
    void *b;

    if (!n) return "";
    b = malloc(n);
    if (!b) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return b;
}

#define malloc(n) check_malloc(n)

static void write_data(FILE *f, void *data, int size)
{
    int z = 0;

    fwrite(data, size, 1, f);
    if (size & 3)
        fwrite(&z, 4 - (size & 3), 1, f);
}

static void write_word(FILE *f, int w)
{
    fwrite(&w, sizeof(int), 1, f);
}


int main(int argc, char **argv)
{
    char *infile_buffer;
    char *outfile, *mname, *hstr, *mvsn;
    int mnamelen, mhelplen;
    int size;
    FILE *f;
    _kernel_osfile_block b;
    ResFile *reslist, *res, **pres;
    int offset;
    _kernel_swi_regs r;
    time_t t;
    char mhelp[80];
    char datestr[20];
    char *p;
    char *viafile;

    if (argc < 5) {
        fprintf(stderr, "Usage: ModGen <filename> <Module Name> <Module Help> <Module Version> { <Binary file> <Resource file> | -via <viafile> }\n");
        exit(1);
    }
    outfile = *++argv;
    mname = *++argv;
    hstr = *++argv;
    mvsn = *++argv;
    t = time(0);
    strftime(datestr, 20, "(%d %b %Y)", localtime(&t));
    sprintf(mhelp, "%s%s%s %s", hstr, strlen(hstr) < 8 ? "\t\t" : "\t", mvsn, datestr);
    reslist = 0;
    pres = &reslist;
    while (*++argv) {
        if (**argv == '-') {
            if (tolower((*argv)[1]) != 'v') {
                fprintf(stderr, "Unrecognised flag %s\n", *argv);
                exit(1);
            }
            viafile = *++argv;
            if (!viafile) {
                fprintf(stderr, "No filename on -via flag\n");
                exit(1);
            }
            r.r[0] = 17;
            r.r[1] = (int)viafile;
            if (_kernel_swi(OS_File, &r, &r)) {
                fprintf(stderr, "Error opening %s\n", viafile);
                exit(1);
            }
            if (r.r[0] != 1) {
                fprintf(stderr, "File %s not found or is a directory\n", viafile);
                exit(1);
            }
            infile_buffer = malloc(r.r[4] + 1);
            r.r[0] = 16;
            r.r[2] = (int)infile_buffer;
            r.r[3] = 0;
            if (_kernel_swi(OS_File, &r, &r)) {
                fprintf(stderr, "Error loading %s\n", viafile);
                exit(1);
            }
            infile_buffer[r.r[4]] = 0;
            p = infile_buffer;
            while (1) {
                while (isspace(*p)) p++;
                if (!*p) break;
                res = *pres = malloc(sizeof(ResFile));
                res->infile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                while (isspace(*p)) p++;
                if (!*p) {
                    fprintf(stderr, "No matching resource file for %s\n", res->infile);
                    exit(1);
                }
                res->resfile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                res->next = 0;
                pres = &(res->next);
            }
        } else {
            res = *pres = malloc(sizeof(ResFile));
            res->next = 0;
            res->infile = *argv;
            if ((res->resfile = *++argv) == 0) {
                fprintf(stderr, "No matching resource file for %s\n", res->infile);
                exit(1);
            }
        }
        pres = &(res->next);
    }
    if (!reslist)
        fprintf(stderr, "Warning: No resource files specified\n");

    f = fopen(outfile, "wb");
    if (!f) {
        fprintf(stderr, "Error opening %s\n", outfile);
        exit(1);
    }
    mnamelen = (strlen(mname) + 1 + 3) & ~3;
    mhelplen = (strlen(mhelp) + 1 + 3) & ~3;
    offset = 7 * 4 + mnamelen + mhelplen;
    write_word(f, 0);
    write_word(f, offset + init - hdr);
    write_word(f, offset + die - hdr);
    write_word(f, offset + service - hdr);
    write_word(f, 7 * 4);
    write_word(f, 7 * 4 + mnamelen);
    write_word(f, 0);
    write_data(f, mname, strlen(mname) + 1);
    write_data(f, mhelp, strlen(mhelp) + 1);

#ifndef NO_SERVICE_TABLE
    /* Write the init & die routinnes (ie. all upto service table) */
    write_data(f, (void *)hdr, service_table - hdr);
    
    /* Write the Ursula service call table */
    write_word(f, 0);
    write_word(f, offset + service_ursula - hdr);
    write_word(f, Service_ResourceFSStarting);
    write_word(f, 0);
    write_word(f, offset + service_table - hdr);
    
    /* Write remaining veneers */
    write_data(f, (void *)service, messages - service);
#else
    write_data(f, (void *)hdr, messages - hdr);
#endif

    res = reslist;
    while (res) {
        int res_hdr[5];

        if (_kernel_osfile(17, res->infile, &b) != 1) {
            fprintf(stderr, "Error reading %s\n", res->infile);
            exit(1);
        }
        size = b.start;
        if (!size)
            fprintf(stderr, "Warning: %s has size 0\n", res->infile);
        res_hdr[0] = ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
        res_hdr[1] = b.load;
        res_hdr[2] = b.exec;
        res_hdr[3] = b.start;
        res_hdr[4] = 3;
        write_data(f, res_hdr, sizeof(res_hdr));
        write_data(f, res->resfile, strlen(res->resfile) + 1);
        write_word(f, size + 4);
        infile_buffer = malloc(size);
        b.load = (int)infile_buffer;
        b.exec = 0;
        if (_kernel_osfile(16, res->infile, &b) != 1) {
            fprintf(stderr, "Error reading %s\n", res->infile);
            exit(1);
        }
        write_data(f, infile_buffer, size);
        res = res->next;
    }
    write_word(f, 0);
    if (fclose(f) == EOF) {
        fprintf(stderr, "Error writing %s\n", outfile);
        exit(1);
    }
    r.r[0] = 18;
    r.r[1] = (int)outfile;
    r.r[2] = 0xffa;
    if (_kernel_swi(OS_File, &r, &r)) {
        fprintf(stderr, "Error setting type of %s\n", outfile);
        exit(1);
    }
    return 0;
}
