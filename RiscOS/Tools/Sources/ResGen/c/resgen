/* resgen.c
 *
 *
 *  Copyright (c) 1999 by Pace Micro Technology plc. All Rights Reserved.
 *
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by Pace Micro Techonologies
 * plc.
 *
 *
 *                      PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "VersionNum"

#ifdef __riscos
#include "kernel.h"
#else
typedef struct {
   int load, exec;       /* load, exec addresses */
   int start, end;       /* start address/length, end address/attributes */
} _kernel_osfile_block;
#include <sys/stat.h>
#endif

#include "objflfmt.h"

#ifdef __riscos
extern int resource_adr;
extern int resources;

#define resource_adr ((int)&resource_adr)
#define resources    ((int)&resources)
#else
#include "rveneers1.h"
#endif

typedef struct ResFile {
    struct ResFile *next;
    char *infile;
    char *resfile;
} ResFile;

static void *check_malloc(int n)
{
    void *b;

    if (!n) return "";
    b = malloc(n);
    if (!b) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return b;
}

#define malloc(n) check_malloc(n)

#define IDFNSTR "ResGen Version " Module_FullVersion " [" Module_Date "]"


static int fileinfo(_kernel_osfile_block *info, const char *name)
{
#ifdef __riscos
    if (_kernel_osfile(READINFO, name, info) != FILEFOUND)
        return -1;
#else
    struct stat buf;
    int len, ftype;

    if (stat(name, &buf) != 0) return -1;

    len = strlen(name);
    if (len > 4 && name[len-4] == ',')
        ftype = (int)strtoul(name + len - 4, NULL, 16);
    else
        ftype = 0xfff;

    info->load = 0xfff00000 | (ftype << 8);
    info->exec = buf.st_mtime * 100 / 256;
    info->start = buf.st_size;
    info->end = 0;
#endif
    return 0;
}

static FILE *open_chunkfile(char *name, int numchunks, int maxchunks)
{
    FILE *f;
    int hdr[3];

    f = fopen(name, "wb");
    if (!f) {
        fprintf(stderr, "Error opening %s for output", name);
        exit(1);
    }
    hdr[0] = 0xc3cbc6c5;
    hdr[1] = maxchunks;
    hdr[2] = numchunks;
    fwrite(hdr, sizeof(int), 3, f);
    return f;
}

static int write_entry(FILE *f, char *s, int offset, int size)
{
   int chunk_entry[4];

   size = (size + 3) & ~3;
   strcpy((char *)chunk_entry, s);
   chunk_entry[2] = offset;
   chunk_entry[3] = size;
   fwrite(chunk_entry, sizeof(int), 4, f);
   return offset + size;
}

static void write_data(FILE *f, void *data, int size)
{
    int z = 0;

    fwrite(data, size, 1, f);
    if (size & 3)
        fwrite(&z, 4 - (size & 3), 1, f);
}

static void write_word(FILE *f, int w)
{
    fwrite(&w, sizeof(int), 1, f);
}

static void write_head(FILE *f, int area_size)
{
    aof_header hdr;

    hdr.aof_type = AOF_RELOC;
    hdr.aof_vsn = 200;
    hdr.aof_nareas = 1;
    hdr.aof_nsyms = 1;
    hdr.aof_entryarea = 0;
    hdr.aof_entryoffset = 0;
    hdr.aof_areas[0].area_name = 4;
    hdr.aof_areas[0].area_AL = 2;
    hdr.aof_areas[0].area_AT = AOF_CODEAT | AOF_RONLYAT;
    hdr.aof_areas[0].area_spare[0] = 0;
    hdr.aof_areas[0].area_spare[1] = 0;
    hdr.aof_areas[0].area_size = area_size;
    hdr.aof_areas[0].area_nrelocs = 0;
    hdr.aof_areas[0].area_base = 0;
    write_data(f, &hdr, sizeof(hdr));
}

static void write_symbol(FILE *f)
{
    aof_symbol sym;

    sym.sym_name = 4;
    sym.sym_AT = 3;
    sym.sym_spare[0] = 0;
    sym.sym_spare[1] = 0;
    sym.sym_spare[2] = 0;
    sym.sym_value = 0;
    sym.sym_areaname = 4;
    write_data(f, &sym, sizeof(sym));
}

int main(int argc, char **argv)
{
    char *infile_buffer;
    char *outfile, *symbol;
    int wsize, size, i;
    FILE *f;
    char cmdline[80];
    ResFile *reslist, *res, **pres;
    char *s;
    int area_size, offset;
    char *p;
    char *viafile;

    if (argc < 3) {
        fprintf(stderr, "Usage: ResGen <Area name> <Object file> { <Binary file> <Resource file> | -via <viafile> }\n");
        exit(1);
    }
    symbol = *++argv;
    outfile = *++argv;
    reslist = 0;
    pres = &reslist;
    area_size = 0;
    while (*++argv) {
        if (**argv == '-') {
            if (tolower((*argv)[1]) != 'v') {
                fprintf(stderr, "Unrecognised flag %s\n", *argv);
                exit(1);
            }
            viafile = *++argv;
            if (!viafile) {
                fprintf(stderr, "No filename on -via flag\n");
                exit(1);
            }
            size = wf_filesize(viafile);
            if (size == -1) {
                fprintf(stderr, "Error finding %s\n", viafile);
                exit(1);
            }
            infile_buffer = malloc(size + 1);
            if (wf_load(viafile, infile_buffer, size) == -1) {
                fprintf(stderr, "Error loading %s\n", viafile);
                exit(1);
            }
            infile_buffer[size] = 0;
            p = infile_buffer;
            while (1) {
                while (isspace(*p)) p++;
                if (!*p) break;
                res = *pres = malloc(sizeof(ResFile));
                res->infile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                while (isspace(*p)) p++;
                if (!*p) {
                    fprintf(stderr, "No matching resource file for %s\n", res->infile);
                    exit(1);
                }
                res->resfile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                res->next = 0;
                size = wf_filesize(res->infile);
                if (size == -1) {
                    fprintf(stderr, "Error opening %s\n", res->infile);
                    exit(1);
                }
                area_size += ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
                pres = &(res->next);
            }
        } else {
            res = *pres = malloc(sizeof(ResFile));
            res->next = 0;
            res->infile = *argv;
            if (!(res->resfile = *++argv)) {
                fprintf(stderr, "No matching resource file for %s\n", res->infile);
                exit(1);
            }
            size = wf_filesize(res->resfile);
            if (size == -1) {
                fprintf(stderr, "Error finding %s\n", res->resfile);
                exit(1);
            }
            area_size += ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
            pres = &(res->next);
        }
    }
    if (!reslist)
        fprintf(stderr, "Warning: No resource files specified\n");
    area_size += 4;
    area_size += resources - resource_adr;
    f = open_chunkfile(outfile, 5, 5);
    offset = (3 + 4 * 5) * 4;
    offset = write_entry(f, "OBJ_IDFN", offset, sizeof(IDFNSTR));
    offset = write_entry(f, "OBJ_HEAD", offset, (6 + 5 * 1) * 4);
    offset = write_entry(f, "OBJ_AREA", offset, area_size);
    offset = write_entry(f, "OBJ_SYMT", offset, sizeof(aof_symbol));
    offset = write_entry(f, "OBJ_STRT", offset, 4 + strlen(symbol) + 1);
    write_data(f, IDFNSTR, sizeof(IDFNSTR));
    write_head(f, area_size);
    write_data(f, (void *)resource_adr, resources - resource_adr);
    res = reslist;
    while (res) {
        _kernel_osfile_block b;
        int res_hdr[5];

        if (!size)
            fprintf(stderr, "Warning: %s has size 0\n", res->infile);
        fileinfo(&b, res->infile);
        size = b.start;
        if (size == -1) {
            fprintf(stderr, "Error finding %s\n", res->infile);
            exit(1);
        }
        res_hdr[0] = ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
        res_hdr[1] = b.load;
        res_hdr[2] = b.exec;
        res_hdr[3] = size;
        res_hdr[4] = 3;
        write_data(f, res_hdr, sizeof(res_hdr));
        write_data(f, res->resfile, strlen(res->resfile) + 1);
        write_word(f, size + 4);
        infile_buffer = malloc(size);
        if (wf_load(res->infile, infile_buffer, size) == -1) {
            fprintf(stderr, "Error reading %s\n", res->infile);
            exit(1);
        }
        write_data(f, infile_buffer, size);
        res = res->next;
    }
    write_word(f, 0);
    write_symbol(f);
    write_word(f, (strlen(symbol) + 5 + 3) & ~3);
    write_data(f, symbol, strlen(symbol) + 1);
    if (fclose(f) == EOF) {
        fprintf(stderr, "Error writing %s\n", outfile);
        exit(1);
    }
    return 0;
}
