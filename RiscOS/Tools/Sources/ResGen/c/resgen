#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"
#include "objflfmt.h"

extern int resource_adr;
extern int resources;

#define resource_adr ((int)&resource_adr)
#define resources    ((int)&resources)

typedef struct ResFile {
    struct ResFile *next;
    char *infile;
    char *resfile;
} ResFile;

static void *check_malloc(int n)
{
    void *b;

    if (!n) return "";
    b = malloc(n);
    if (!b) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return b;
}

#define malloc(n) check_malloc(n)

#define IDFNSTR "ResGen Version 1.00"

static FILE *open_chunkfile(char *name, int numchunks, int maxchunks)
{
    FILE *f;
    int hdr[3];

    f = fopen(name, "wb");
    if (!f) {
        fprintf(stderr, "Error opening %s for output", name);
        exit(1);
    }
    hdr[0] = 0xc3cbc6c5;
    hdr[1] = maxchunks;
    hdr[2] = numchunks;
    fwrite(hdr, sizeof(int), 3, f);
    return f;
}

static int write_entry(FILE *f, char *s, int offset, int size)
{
   int chunk_entry[4];

   size = (size + 3) & ~3;
   strcpy((char *)chunk_entry, s);
   chunk_entry[2] = offset;
   chunk_entry[3] = size;
   fwrite(chunk_entry, sizeof(int), 4, f);
   return offset + size;
}

static void write_data(FILE *f, void *data, int size)
{
    int z = 0;

    fwrite(data, size, 1, f);
    if (size & 3)
        fwrite(&z, 4 - (size & 3), 1, f);
}

static void write_word(FILE *f, int w)
{
    fwrite(&w, sizeof(int), 1, f);
}

static void write_head(FILE *f, int area_size)
{
    aof_header hdr;

    hdr.aof_type = AOF_RELOC;
    hdr.aof_vsn = 200;
    hdr.aof_nareas = 1;
    hdr.aof_nsyms = 1;
    hdr.aof_entryarea = 0;
    hdr.aof_entryoffset = 0;
    hdr.aof_areas[0].area_name = 4;
    hdr.aof_areas[0].area_AL = 2;
    hdr.aof_areas[0].area_AT = AOF_CODEAT | AOF_RONLYAT;
    hdr.aof_areas[0].area_spare[0] = 0;
    hdr.aof_areas[0].area_spare[1] = 0;
    hdr.aof_areas[0].area_size = area_size;
    hdr.aof_areas[0].area_nrelocs = 0;
    hdr.aof_areas[0].area_base = 0;
    write_data(f, &hdr, sizeof(hdr));
}

static void write_symbol(FILE *f)
{
    aof_symbol sym;

    sym.sym_name = 4;
    sym.sym_AT = 3;
    sym.sym_spare[0] = 0;
    sym.sym_spare[1] = 0;
    sym.sym_spare[2] = 0;
    sym.sym_value = 0;
    sym.sym_areaname = 4;
    write_data(f, &sym, sizeof(sym));
}

int main(int argc, char **argv)
{
    char *infile_buffer;
    char *outfile, *symbol;
    int wsize, size, i;
    FILE *f;
    _kernel_osfile_block b;
    char cmdline[80];
    ResFile *reslist, *res, **pres;
    char *s;
    int area_size, offset;
    char *p;
    char *viafile;
    _kernel_swi_regs r;

    if (argc < 3) {
        fprintf(stderr, "Usage: ResGen <Area name> <Object file> { <Binary file> <Resource file> | -via <viafile> }\n");
        exit(1);
    }
    symbol = *++argv;
    outfile = *++argv;
    reslist = 0;
    pres = &reslist;
    area_size = 0;
    while (*++argv) {
        if (**argv == '-') {
            if (tolower((*argv)[1]) != 'v') {
                fprintf(stderr, "Unrecognised flag %s\n", *argv);
                exit(1);
            }
            viafile = *++argv;
            if (!viafile) {
                fprintf(stderr, "No filename on -via flag\n");
                exit(1);
            }
            r.r[0] = 17;
            r.r[1] = (int)viafile;
            if (_kernel_swi(OS_File, &r, &r)) {
                fprintf(stderr, "Error opening %s\n", viafile);
                exit(1);
            }
            if (r.r[0] != 1) {
                fprintf(stderr, "File %s not found or is a directory\n", viafile);
                exit(1);
            }
            infile_buffer = malloc(r.r[4] + 1);
            r.r[0] = 16;
            r.r[2] = (int)infile_buffer;
            r.r[3] = 0;
            if (_kernel_swi(OS_File, &r, &r)) {
                fprintf(stderr, "Error loading %s\n", viafile);
                exit(1);
            }
            infile_buffer[r.r[4]] = 0;
            p = infile_buffer;
            while (1) {
                while (isspace(*p)) p++;
                if (!*p) break;
                res = *pres = malloc(sizeof(ResFile));
                res->infile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                while (isspace(*p)) p++;
                if (!*p) {
                    fprintf(stderr, "No matching resource file for %s\n", res->infile);
                    exit(1);
                }
                res->resfile = p;
                while (*p && !isspace(*p)) p++;
                if (*p) *p++ = 0;
                res->next = 0;
                if (_kernel_osfile(17, res->infile, &b) != 1) {
                    fprintf(stderr, "Error opening %s\n", res->infile);
                    exit(1);
                }
                size = b.start;
                area_size += ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
                pres = &(res->next);
            }
        } else {
            res = *pres = malloc(sizeof(ResFile));
            res->next = 0;
            res->infile = *argv;
            if (!(res->resfile = *++argv)) {
                fprintf(stderr, "No matching resource file for %s\n", res->infile);
                exit(1);
            }
            if (_kernel_osfile(17, res->infile, &b) != 1) {
                fprintf(stderr, "Error opening %s\n", res->infile);
                exit(1);
            }
            size = b.start;
            area_size += ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
            pres = &(res->next);
        }
    }
    if (!reslist)
        fprintf(stderr, "Warning: No resource files specified\n");
    area_size += 4;
    area_size += resources - resource_adr;
    f = open_chunkfile(outfile, 5, 5);
    offset = (3 + 4 * 5) * 4;
    offset = write_entry(f, "OBJ_IDFN", offset, sizeof(IDFNSTR));
    offset = write_entry(f, "OBJ_HEAD", offset, (6 + 5 * 1) * 4);
    offset = write_entry(f, "OBJ_AREA", offset, area_size);
    offset = write_entry(f, "OBJ_SYMT", offset, sizeof(aof_symbol));
    offset = write_entry(f, "OBJ_STRT", offset, 4 + strlen(symbol) + 1);
    write_data(f, IDFNSTR, sizeof(IDFNSTR));
    write_head(f, area_size);
    write_data(f, (void *)resource_adr, resources - resource_adr);
    res = reslist;
    while (res) {
        int res_hdr[5];

        if (!size)
            fprintf(stderr, "Warning: %s has size 0\n", res->infile);
        if (_kernel_osfile(17, res->infile, &b) != 1) {
            fprintf(stderr, "Error reading %s\n", res->infile);
            exit(1);
        }
        size = b.start;
        res_hdr[0] = ((size + 3) & ~3) +
                         ((strlen(res->resfile) + 4) & ~3) + 6 * sizeof(int);
        res_hdr[1] = b.load;
        res_hdr[2] = b.exec;
        res_hdr[3] = b.start;
        res_hdr[4] = 3;
        write_data(f, res_hdr, sizeof(res_hdr));
        write_data(f, res->resfile, strlen(res->resfile) + 1);
        write_word(f, size + 4);
        infile_buffer = malloc(size);
        b.load = (int)infile_buffer;
        b.exec = 0;
        if (_kernel_osfile(16, res->infile, &b) != 1) {
            fprintf(stderr, "Error reading %s\n", res->infile);
            exit(1);
        }
        write_data(f, infile_buffer, size);
        res = res->next;
    }
    write_word(f, 0);
    write_symbol(f);
    write_word(f, (strlen(symbol) + 5 + 3) & ~3);
    write_data(f, symbol, strlen(symbol) + 1);
    if (fclose(f) == EOF) {
        fprintf(stderr, "Error writing %s\n", outfile);
        exit(1);
    }
    return 0;
}
