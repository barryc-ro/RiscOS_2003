/*
 * AMU (amu.h)
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

#ifndef amu_h_included
#define amu_h_included

#ifdef __cplusplus
extern "C" {
#endif

/* First, some shared utility functions */
extern void *safe_malloc(const size_t size);
extern char *Strdup(const char *s);
extern char *Strdup_spare(const char *s, const size_t extra);

/* These are the core types used to represent makefiles */
typedef struct Makefile Makefile;
typedef struct LinePart LinePart;
typedef struct Line Line;

/* Makefiles contain four types of non-empty lines and this enumeration is used
 * to identify what is what within the makefile
 */
typedef enum {
  linetype_blank,
  linetype_pending,          /* not blank, but there's something there */
  linetype_macro_definition,
  linetype_dependency,
  linetype_command,
  linetype_directive
} LineType;

/* Return value for amu_is_directive() identifying which directive (if any) was found.
 */
typedef enum {
  not_a_directive,
  directive_include,
  directive_include_no_error,
  directive_override
} Directive;

/* Makefile represents the entire file.  Some members (lineno & lookahead) are
 * used in two places: firstly during the actual loading of the Makefile; secondly
 * during the parsing of the Makefile
 */
struct Makefile {
  Makefile *next;
  char *name;
  Line *lines;
  Line **nextline;
  Line *dynamic_dependencies_magic_comment;
  FILE *f;
  int lineno;
  int lookahead;
  long file_size;
};

struct Line {
  Line *next;
  Makefile *makefile;
  int lineno;
  long file_position;
  LinePart *firstpart;
  LinePart **nextpart;
};

struct LinePart {
  LinePart *next;
  int lineno;
  char *data;
};

/* This routine attempts to rejoin consecutive LinePart structures - these are
 * caused by very long lines in the Makefile being split by the parser, and also
 * by macro substitutions.
 *
 * If why == slr_rejoin_line, only consecutive LineParts of the same line are joined.
 * If why == slr_flatten, all consecutive LineParts are joined.
 * If why == slr_flatten_leading_spaces, then all consecutive LineParts are joined,
 *   but the first LinePart of each logical line loses leading whitespace.  This is
 *   used when parsing commands.
 */
typedef enum {
  slr_rejoin_line,
  slr_flatten,
  slr_flatten_leading_spaces
} sanitise_line_reason;
extern void sanitise_line(Line *l, sanitise_line_reason why);

/* This routine is a special case of sanitising a line, where we want to flatten
 * a list generated by resplit_line(..., rlr_words) into a single string of single
 * space separated entries.  It returns the new buffer.
 */
extern char *rejoin_words(LinePart *first);

/* This routine will attempt to split up a Line into multiple LinePart objects
 * based on separator strings.  This is used to split the input into words.
 *
 * If why == rlr_keep_whitespace, whitespace groupings are retained.
 * If why == rlr_words, all whitespace is discarded
 */
typedef enum {
  rlr_keep_whitespace,
  rlr_words
} resplit_line_reason;
extern void resplit_line(Line *l, resplit_line_reason why);

/* This routine will construct a new LinePart object based on the passed in template.
 * The passed LinePart's next field is updated to point at the new object.
 * The next field of the new object is pointed at the passed parameter's next field.
 */
extern LinePart *insert_line_part(LinePart *lp);

/* This routine will construct a new LinePart object with a specified line number
 * and fill in *next with the address of the new object (which is also returned)
 */
extern LinePart *make_new_line_part(LinePart **next, int lineno);

/* This routine will construct a new LinePart object and append it to the LinePart
 * list of the specified line.  It returns the new LinePart object.
 */
extern LinePart *append_new_line_part(Line *l);

/* This routine will copy a Line object but will reset its LinePart data so that it
 * is an empty line.
 */
extern Line *clone_line_no_lineparts(Line *l);

/* This routine will construct an empty Line object with no associated makefile
 * or line number.  It can be used to obtain a temporary object when required for
 * passing to routines like resplit_line.
 */
extern Line *alloc_line(void);

/* This routine will deallocate a complete LinePart list, including freeing the
 * data blocks.
 */
extern void deallocate_linepart_list(LinePart *lp);

/* This routine will deallocate a line object and all its lineparts. */
extern void deallocate_line(Line *l);

/* This routine will attempt to open the named makefile.  It returns NULL if
 * unable to allocate memory or open the file.  ptr is updated with the allocated
 * memory (so callers can distinguish between the two failure modes).  If the
 * file was opened, then lines are read in (aborting if memory is exhausted in
 * this phase) ready for the parser to use them.
 */
extern Makefile *load_makefile(Makefile **ptr, const char *filename);

/* This macro will enter a macro definition
 */
extern void define_macro(char *name, char *value, bool strong, bool expanded, bool override);

/* Some global variables - required by readmk.c, md.c and amu.c */

/* The name of the program */
extern char amu[];
extern const int dir_sep;
extern int amu_flags;

/* amu_flags bitfield values: */
#define TOUCHING       (1<<0)    /* amu -t */
#define HAS_CYCLES     (1<<1)    /* Set if a cyclic dependency is detected */
#define IGNORE_RC      (1<<2)    /* Amu -i, .IGNORE */
#define CONTINUE       (1<<3)    /* Amu -k */
#define NO_ACTION      (1<<4)    /* Amu -n */
#define SILENT         (1<<5)    /* Amu -s, .SILENT */
#define UNIX_NAMES     (1<<6)    /* set by .UNIXNAMES */
#define CMDS_OUTPUT    (1<<7)    /* set if any cmds have been sent to 'out' */
#define STATE_REASONS  (1<<8)    /* State reasons without -n */
#define USE_GETENV     (1<<9)    /* Environment variables override file macros */
/* The debugging values must be last, well out of the way */
#define DEBUGGING      (1<<24)   /* set if debugging */
#define DEBUGGING2     (1<<25)   /* very detailed debugging */
#define DEBUGGING3     (1<<26)   /* very very detailed debugging */
#define DEBUGGING4     (1<<27)   /* etc. */
#define DEBUGGING5     (1<<28)   /* etc. */
#define DEBUGGING6     (1<<29)   /* etc. */
#define DEBUGGING7     (1<<30)   /* etc. */
#define DEBUGGING8     (1<<31)   /* etc. */

#pragma check_printf_formats
extern void amu_debug(int, const char *, ...);
extern void amu_err_report(const char *fmt, ...);
extern void amu_err_fail(const char *fmt, ...);
#pragma -v0

#ifdef __cplusplus
}
#endif
#endif
