/*
 * AMU (readmk.h)
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

#ifndef readmk_h_included
#define readmk_h_included

#ifdef __cplusplus
extern "C" {
#endif

/* First, some shared utility functions */

/* This routine attempts to rejoin consecutive LinePart structures - these are
 * caused by very long lines in the Makefile being split by the parser, and also
 * by macro substitutions.
 *
 * If why == slr_rejoin_line, only consecutive LineParts of the same line are joined.
 * If why == slr_flatten, all consecutive LineParts are joined.
 * If why == slr_flatten_leading_spaces, then all consecutive LineParts are joined,
 *   but the first LinePart of each logical line loses leading whitespace.  This is
 *   used when parsing commands.
 */
typedef enum {
  slr_rejoin_line,
  slr_flatten,
  slr_flatten_leading_spaces
} sanitise_line_reason;
extern void sanitise_line(Line *l, sanitise_line_reason why);

/* This routine is a special case of sanitising a line, where we want to flatten
 * a list generated by resplit_line(..., rlr_words) into a single string of single
 * space separated entries.  It returns the new buffer.
 */
extern char *rejoin_words(LinePart *first);

/* This routine will attempt to split up a Line into multiple LinePart objects
 * based on separator strings.  This is used to split the input into words.
 *
 * If why == rlr_keep_whitespace, whitespace groupings are retained.
 * If why == rlr_words, all whitespace is discarded
 */
typedef enum {
  rlr_keep_whitespace,
  rlr_words
} resplit_line_reason;
extern void resplit_line(Line *l, resplit_line_reason why);

/* This routine will construct a new LinePart object based on the passed in template.
 * The passed LinePart's next field is updated to point at the new object.
 * The next field of the new object is pointed at the passed parameter's next field.
 */
extern LinePart *insert_line_part(LinePart *lp);

/* This routine will construct a new LinePart object with a specified line number
 * and fill in *next with the address of the new object (which is also returned)
 */
extern LinePart *make_new_line_part(LinePart **next, int lineno);

/* This routine will construct a new LinePart object and append it to the LinePart
 * list of the specified line.  It returns the new LinePart object.
 */
extern LinePart *append_new_line_part(Line *l);

/* This routine will copy a Line object but will reset its LinePart data so that it
 * is an empty line.
 */
extern Line *clone_line_no_lineparts(Line *l);

/* This routine will construct an empty Line object with no associated makefile
 * or line number.  It can be used to obtain a temporary object when required for
 * passing to routines like resplit_line.
 */
extern Line *alloc_line(void);

/* This routine will deallocate a complete LinePart list, including freeing the
 * data blocks.
 */
extern void deallocate_linepart_list(LinePart *lp);

/* This routine will deallocate a line object and all its lineparts. */
extern void deallocate_line(Line *l);

/* This routine will attempt to open the named makefile.  It returns NULL if
 * unable to allocate memory or open the file.  ptr is updated with the allocated
 * memory (so callers can distinguish between the two failure modes).  If the
 * file was opened, then lines are read in (aborting if memory is exhausted in
 * this phase) ready for the parser to use them.
 */
extern Makefile *load_makefile(Makefile **ptr, const char *filename);

#ifdef __cplusplus
}
#endif
#endif
