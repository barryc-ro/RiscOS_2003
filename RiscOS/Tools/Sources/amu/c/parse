/*
 * AMU (parse.c)
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

/*
 * This source contains the makefile parser - it interprets the data structures
 * created in readmk.c and generates the dependency tree.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

/* CLX */
#include "err.h"
#include "filestamp.h"
#include "wholefls.h"
#include "hash.h"
#include "fname.h"

/* Local */
#include "amu.h"
#include "parse.h"
#include "macros.h"
#include "md.h"

/* A hash table containing the names of Makefiles already included
 * The associated value is the filename.
 */
static HashTable inc_tab;

/* A hash table containing the names of the nodes in the tree.
 * The associated values are Node pointers
 */
static HashTable node_tab;

/* The directories containing files we are interested in.  This is held
 * to permit filestamps to be read efficiently.
 */
static HashTable dir_tab;

/* The macros.  The values associated with each entry are a MacroVar structure. */
static HashTable tag_tab;

/* nodep is a list of all nodes in the system; nodeq is the address into which new
 * nodes should be written.
 */
static Node *nodep, **nodeq;

/* dotnodep is a list of all .nodes in the system; dotnodeq is the address into which new
 * .nodes should be written.
 */
static Node *dotnodep, **dotnodeq;


/* This access function is used to obtain the list of all the nodes in the parse tree */
Node *get_node_list(void)
{
  return nodep;
}

/* A simple function to add a node to the list of nodes */
static Node *add_node_to_list(Node *n)
{
  *nodeq = n;
  nodeq = &n->next;
  return n;
}

/* This access function is used to obtain the list of all the .nodes in the parse tree */
Node *get_dot_node_list(void)
{
  return dotnodep;
}

/* A simple function to add a node to the list of .nodes */
static Node *add_dot_node_to_list(Node *n)
{
  *dotnodeq = n;
  dotnodeq = &n->next;
  return n;
}

/* Attempt to resolve a makefile filename against the search path, returning a malloc'ed
 * block containing the full filename.  If the file is not found on the search path, the
 * passed value is returned (duplicated).
 */
static char *include_resolve_name(char *name)
{
  char filename[CMDLEN];
  include_search_path *i;

  for (i = &include_dirs; i; i = i->next) {
    strcpy(filename, i->path);
    strcat(filename, name);
    if (wf_filesize(filename) != -1) break;
  }

  if (!i) {
    strcpy(filename, name);
  }

  return Strdup(filename);
}

/* Open a new makefile (root makefile or an included one) and prepare it for parsing */
void push_include(char *name, const bool reporting_errors)
{
  HashId h;

  /* Allocates returned buffer via malloc */
  name = include_resolve_name(name);
  amu_debug(DEBUGGING3, "Resolved makefile name is %s", name);

  /* Prevent multiple inclusion */
#ifndef PERMIT_MULTIPLE_INCLUSION
  if (hash_lookup(inc_tab, name, &h))
  {
    amu_err_report("Re-inclusion of %s", hash_value(inc_tab, h));
    return;
  }
#endif

  /* Store this filename in the hash table */
  hash_enter(inc_tab, name, &h);
  hash_assoc(inc_tab, h, name);

  /* Too deeply nested? (run out of space in our array) */
  if (in.idx >= (INCLUDEDEPTH-1))
  {
    amu_err_fail("include file invocations nested too deeply (> %u)", INCLUDEDEPTH-1);
  }

  amu_debug(DEBUGGING, "loading sub-makefile %s", name);

  if (load_makefile(&in.file[++in.idx], name)) {
    in.state.mf = in.file[in.idx];
    in.state.l  = NULL;
    in.state.mf->lineno = 0;
  }
  else if (reporting_errors) {
    char *error = in.file[in.idx--] ? "error reading makefile" : "out of memory reading makefile";
    amu_err_fail(error, name);
  }
  else {
    --in.idx;
  }
}

/* The associated value for entries in the macro table (tag_tab) */
static MacroVar *make_macro_var(bool strong, bool expanded, char *text)
{
  MacroVar *mv = safe_malloc(sizeof(*mv));

  mv->expanded = expanded;
  mv->strong = strong;
  mv->value = text;

  return mv;
}


/* Enter a macro into the macro table - unless the definition is prevented by an earlier
 * definition that takes priority.  If 'strong' is true, the definition is always made.
 * If 'expanded' is true, then the macro value has already been expanded.  This information
 * is required so that += definitions can determine whether the extra value needs to be
 * macroised before being appended or not.  'overriding' is true if the makefile wants
 * to define a macro and override the CLI and environment variable precedence and force
 * the definition.
 */
void define_macro(char *name, char *value, bool strong, bool expanded, bool overriding)
{
  HashId h;
  int existed;

  existed = !hash_enter(tag_tab, name, &h);
  if (!strong) {
    /* We weren't trying a strong definition (ie. a CLI definition), so prefer
     * to not knock out existing entries, and prefer to read the environment if
     * USE_GETENV if set (amu -e).
     */
    if (existed && !overriding) {
      /* We are attempting a non-strong definition - was the existing definition
       * strong?  if so, we prefer the existing definition unless temporary_override
       * was set (by the GNU-make override directive).
       */
      MacroVar *mv = hash_value(tag_tab, h);
      if (mv->strong) {
        /* Prevent the re-definition! */
        amu_debug(DEBUGGING2, "REDEFINE **BLOCKED**: %s = %s", name, value);
        return;
      }
    }
    else if (amu_flags & USE_GETENV) {
      char *env_value = getenv(name);
      if (env_value) value = env_value;
    }
  }
  hash_assoc(tag_tab, h, make_macro_var(strong, expanded, Strdup(value)));
  amu_debug(DEBUGGING2, "DEFINE: %s = %s%s", name, value, strong ? " **FUTURE REDEFINITIONS BLOCKED":"");
}

/* Look up a macro in the macro table (tag_tab).  If it isn't found, try looking in the
 * environment, and if we find it there, put it into the macro table.
 */
MacroVar *lookup_macro(char *name)
{
  HashId h;

  if (!hash_lookup(tag_tab, name, &h))
  {
    char *env = getenv(name);

    amu_debug(DEBUGGING2, "INVOKE (undef): %s", name);
    if (env) {
      /* Enter this environment variable into the macro table, marking it as
       * indelible if we are using environment override.
       */
      define_macro(name, env, amu_flags & USE_GETENV & strong_definitions, true, false);
    }

    if (!hash_lookup(tag_tab, name, &h)) {
      /* Still not defined */
      return NULL;
    }
  }

  return hash_value(tag_tab, h);
}


/* Enter the directories mentioned in 's' into the directory hash table.  This is used
 * to optimise the timestamp reading.
 */
static void accumulate_dirname(char *s)
{
  int l;
  HashId h;

  l = strlen(s);
  for(;;)
  {
    if (l == 0) break;
    --l;
    if (s[l] == dir_sep) break;
  }
  s[l] = 0;
  if (hash_enter(dir_tab, s, &h))
  { if (n_dirs >= MAXDIRS)
      amu_err_fail("too many directories (> %u)", MAXDIRS);
    dirs[n_dirs++] = strcpy(malloc(l+1), s);
  }
}

/* Find the Node representing 's' and return it.  If there is no such node, create it. */
Node *find_node(char *s)
{
  HashId h;
  Node *n;
  char buf[NAMELEN];

  amu_debug(DEBUGGING5, "find_node(%s)", s);

  if (s[0] != '.') s = real_file_name(s, buf, NAMELEN);
  if (hash_enter(node_tab, s, &h))
  {
    n = safe_malloc(sizeof(Node) + strlen(s) + 1);
    if (s[0] != '.') {
      /* omit 'special' nodes */
      add_node_to_list(n);
    }
    else {
      add_dot_node_to_list(n);
    }
    n->next = NULL;
    n->name = (char *) (n + 1);
    strcpy(n->name, s);
    n->file = &(n->name);
    n->cmds = NULL;
    n->depends_on = NULL;
    n->time = FILESTAMP_NEVER;
    n->flags = 0;
    hash_assoc(node_tab, h, n);
    if (s[0] != '.') accumulate_dirname(s);
  }
  else n = (Node *) hash_value(node_tab, h);
  return n;
}

/* Add a dependecy for 'target' on 'src'. */
void make_depend(Node *target, Node *src)
{
  Link *link;

  if ((src->flags & IS_COLONCOLON) &&
      (target->depends_on != NULL) &&
      (target->flags & HAS_CLONES) == 0)
  {
    amu_err_report("%s '::' rule clashes with earlier ':' rule", target->name);
  }
  else if ((target->flags & HAS_CLONES) &&
             (src->name != target->name))
  {
    amu_err_report("%s ':' rule clashes with earlier '::' rule", target->name);
  }
  else
  {
    link = safe_malloc(sizeof(*link));
    link->node = src;
    link->link = target->depends_on;
    target->depends_on = link;
    src->flags |= IS_DEPENDED_ON;
  }
}

static Node *clone_node(n)
Node *n;
{
  Node *clone;

  clone = safe_malloc(sizeof(*clone));
  add_node_to_list(clone);
  clone->next = NULL;
  clone->name = n->name;
  clone->file = n->file;
  clone->cmds = NULL;
  clone->depends_on = NULL;
  clone->time = FILESTAMP_NEVER;
  clone->flags = IS_COLONCOLON;
  make_depend(n, clone);
  n->flags |= HAS_CLONES;
  return clone;
}

/* We have had enough of the top Makefile - get rid of it.
 * NOTE: if in.idx == 0, then this was the top-level Makefile,
 * and we need it to hang around in in.state.mf so that we can
 * do the dynamic dependency work on it.  This is OK because once
 * in.idx gets back to -1, no more parsing will occur and in.state.mf
 * won't be touched.
 */
static void pop_makefile(void)
{
  if (in.idx > 0) {
    in.state.mf = in.file[--in.idx];
    in.state.l = NULL;
  }
  else {
    in.idx = -1;
  }
}

/* Move on to the next line in the Makefile.  This function handles the state of reaching the
 * end of a makefile and returning to the one which included it.  Reaching the end of the top-level
 * makefile is a persistent EOF condition, flagged by setting in.state.l to NULL.
 */
static void set_next_line(void)
{
  if (in.idx < 0) {
    /* Persistent EOF condition */
    in.state.l = NULL;
    return;
  }

  if (!in.state.l) {
    /* We haven't already parsed a line from this Makefile, get one. */
    in.state.l = in.state.mf->lines;
    ++in.state.mf->lineno;
    if (!in.state.l) {
      /* The Makefile was empty, pop it and try again */
      pop_makefile();
      set_next_line();
    }
  }
  else {
    /* We had already read a line, get the next line, throwing away the previous line data (leaking it) */
    in.state.l = in.state.mf->lines = in.state.l->next;
    ++in.state.mf->lineno;
    if (!in.state.l) {
      /* but we've reached the end of the file, pop it, return to previous */
      pop_makefile();
      set_next_line();
    }
  }
}

/* Like a std::string::iterator.  A character iterator for cp over *plp.
 * Behaviour is undefined if you iterate past plp->end()
 */
static char *cp_iterator(char *cp, LinePart **plp)
{
  ++cp;
  while (!*cp && (*plp)->next) {
    *plp = (*plp)->next;
    cp = (*plp)->data;
  }

  return cp;
}

/* Effectively, strchr() over a list of LineParts.
 * On entry, *pop holds the LinePart to start the search from.
 * On exit, *plp holds the LinePart containing the matched char or NULL if no match
 * Returns the address of the matched char in *plp.
 */
static char *lp_strchr(LinePart **plp, const char c)
{
  char *result = NULL;

  for (result = NULL; *plp; *plp = (*plp)->next) {
    result = strchr((*plp)->data, c);
    if (result) break;
  }

  return result;
}

/* Split up the includes and include each file.  Note that when we parse the include files,
 * we insert them into a list by adding new items at the front.  Then we walk the list and
 * push the included files *backwards* onto the include stack.  Thus when the stack is
 * repeatedly popped, the files come off in the *right* (i.e. left-to-right) order.
 *
 * Note that we don't bother to copy the filename out of the line buffer - there is no need.
 */
static void amu_parse_includes(Line *l, bool generate_errors)
{
  LinePart *lp;
  include_file *includes = NULL;

  resplit_line(l, rlr_words);
  for (lp = l->firstpart; lp; lp = lp->next) {
    include_file *inew = safe_malloc(sizeof(*inew));
    inew->next = includes;
    inew->txt = lp->data;
    includes = inew;
  }

  while (includes) {
    include_file *const next = includes->next;
    push_include(includes->txt, generate_errors);
    free(includes);
    includes = next;
  }
}


/* Determine whether the string pointed to by cp is a known directive, and return its enum code if so */
static Directive amu_decode_directive(char *cp)
{
  static const struct {
    char *text;
    Directive d;
  } directives[] = {
    { ".INCLUDE"   , directive_include },
    { "INCLUDE"    , directive_include },
    { ".-INCLUDE"  , directive_include_no_error },
    { "-INCLUDE"   , directive_include_no_error },
    { "OVERRIDE"   , directive_override },
    { NULL, not_a_directive }
  }, *d;

  for (d = directives; d->text; ++d) {
    if (hash_cistrcmp(cp, d->text) == 0) break;
  }

  return d->d;
}

/* This function is passed a string buffer of a complete line (*pcp) in a Makefile and asked to
 * identify its type: blank line, macro definition, dependency, command or directive.
 * Comments must have been removed.  cp must not be NULL.  It fills in first_interesting_character
 * with the first interesting character on the line:
 *   blank -> unused (f_i_c char* is corrupted though)
 *   macro_definition -> first character of assignment token (*pcp = first character of macro name)
 *   dependency -> first character of assignee
 *   command -> first character of command
 *   directive -> first parameter of directive (*dp = directive found)
 *
 * On exit, *dp contains the directive type or not_a_directive if no directive was found.  This permits
 * a return value of linetype_macro_definition with *dp containing directive_override to control the
 * macro assignment rules.
 */
static LineType identify_line_type(char **pcp, char **first_interesting_character, Directive *dp)
{
  LineType result = linetype_blank;
  bool leading_spaces = false;
  char last_ch = ' ';
  char *cp = *pcp;

  *dp = not_a_directive;

  leading_spaces = isspace(*cp);
  if (leading_spaces) {
    do {
      ++cp;
    } while (isspace(*cp));
  }

  if (leading_spaces || !*cp) {
    if (*cp) result = linetype_command;
  }
  else {
    char *first_non_ws = cp;
    while (*cp) {
      if (*cp == '=') {
        /* Macro assignment */
        if (cp == *pcp) {
          /* This is the first character!! */
          amu_err_fail("invalid macro definition");
        }
        result = linetype_macro_definition;
        if (strchr(":?.+", last_ch)) {
          --cp;
        }
        break;
      }
      else if (*cp == '$') {
        /* Must be a dependency declaration - nothing else is permitted */
        result = linetype_dependency;
        break;
      }
      else if (*cp == ':') {
        if (cp[1] == '=') {
          /* Macro assignment - let this character go, we'll see the = on the next iteration */
        }
        else {
          /* Must be a dependency declaration */
          result = linetype_dependency;
          break;
        }
      }
      else if (isspace(*cp) && !isspace(last_ch)) {
        /* Found a whitespace character immediately after some non-whitespace chars (ie. end of a string)
         * Look for a directive
         */
        last_ch = *cp;
        *cp = '\0';
        *dp = amu_decode_directive(first_non_ws);
        *cp = last_ch;
        if (*dp != not_a_directive) {
          /* skip further whitespace */
          while (isspace(*cp)) {
            ++cp;
          }
          if (!*cp) {
            result = linetype_blank;
            break;
          }

          /* Reset lp->data to point to the start of the macro definition or other parameter */
          *pcp = cp;

          if (*dp == directive_override) {
            /* We don't want the recursive call to clobber *dp, so we pass a dummy Directive */
            Directive dummy_directive;
            result = identify_line_type(pcp, first_interesting_character, &dummy_directive);
            if (result != linetype_macro_definition) {
              amu_err_fail("invalid override directive");
            }
          }
          else {
            result = linetype_directive;
          }
          break;
        }
      }
      else {
        result = linetype_pending;
      }
      last_ch = *cp++;
    }
  }

  *first_interesting_character = cp;
  return result;
}

char *strip_trailing_whitespace(char *cp)
{
  char *last_non_ws = strchr(cp, '\0');

  while (last_non_ws > cp && isspace(last_non_ws[-1])) {
    --last_non_ws;
  }

  *last_non_ws = '\0';
  return cp;
}

/* Note that a pointer returned from this function cannot be passed to free()
 * because if it has changed, it will no longer point to the malloced block.
 */
char *strip_leading_whitespace(char *cp)
{
  while (isspace(*cp)) ++cp;
  return cp;
}

static void process_directive(Line *l, Directive d)
{
  /* override has already been filtered out and passed to process_macro_definition,
   * so the only existing directives are include and -include, so optimise:
   */
  set_next_line();
  --in.state.mf->lineno;
  amu_parse_includes(l, d == directive_include);
}

static void process_macro_definition(Line *l, char *op, bool overriding)
{
  /* Now we check for a macro definition:   'name' '[<whitespace>]' '[:?+]=.*' ...
   * 'op' points at the first character of the assignment operator.
   * 'l->firstpart->data' points to the name of the macro.
   * overriding is true if the 'override' keyword was present.
   */
  enum assign_type {
    assign_colonequals,
    assign_equals,
    assign_noop
  } assign_op;
  char actual_op = *op;
  char *name = l->firstpart->data;
  MacroVar *mv;

  /* Terminate the macro name, strip trailing spaces from it - so we can look it up */
  if (*op != '=') *op++ = '\0';
  *op++ = '\0';
  strip_trailing_whitespace(name);
  /* Reset line data to be the value of the macro (name is safely stored in 'name') */
  strip_trailing_whitespace(op);
  l->firstpart->data = strip_leading_whitespace(op);

  switch (actual_op) {
    default:
      assign_op = assign_equals;
      break;
    case '.': /* Backward compatibility for old amu only */
    case '?':
      assign_op = lookup_macro(name) ? assign_noop : assign_equals;
      break;
    case ':':
      assign_op = assign_colonequals;
      macroise(l->firstpart, &l->firstpart);
      break;
    case '+':
      mv = lookup_macro(name);
      if (mv) {
        size_t exp_len;
        if (mv->expanded) {
          macroise(l->firstpart, &l->firstpart);
        }
        exp_len = strlen(l->firstpart->data) + 2 /* space separator and zero terminator */;
        l->firstpart->data = strcat(strcat(Strdup_spare(mv->value, exp_len), " "), l->firstpart->data);
        assign_op = mv->expanded ? assign_colonequals : assign_equals;
      }
      else {
        assign_op = assign_equals;
      }
      break;
  }

  if (assign_op != assign_noop) {
    amu_debug(DEBUGGING2, "Macro assignment '%s' to '%s', type '%c'", name, l->firstpart->data, actual_op);
    define_macro(name, l->firstpart->data, false, assign_op == assign_colonequals, overriding);
  }
}

/* Look for and delete comments after offering them to the magic string checker */
static void process_comment(Line *l)
{
  LinePart *lp;
  char *cp;

  /* Look for a magic comments first - these need to be kept specially */
  lp = l->firstpart;
  cp = lp->data;
  if (*cp == '#') {
    if (md_check_magic_string(lp->data)) {
      in.state.mf->dynamic_dependencies_magic_comment = l;
    }
  }
  else {
    cp = lp_strchr(&lp, '#');
  }

  if (cp) {
    *cp = '\0';      /* Get rid of it */
    lp->next = NULL; /* and any other line parts */
  }
}

/* Add the given command to the list to execute, but filter out blank lines */
static void add_command(char *text, Cmd **next, Cmd ***nextp)
{
  char *text_of_command = strip_leading_whitespace(text);
  const size_t length = strlen(text_of_command) + 1;
  Cmd *c;

  if (length > 1) {
    c = *next = safe_malloc(sizeof(**next) + length);
    *nextp = &((*next)->next);
    memcpy(c->txt, text_of_command, length);
    c->next = NULL;
  }
}

/* This routine returns NULL if it has handled the target, otherwise a node. */
static Node *process_special_target(char *target, LinePart *dependencies)
{
  /* Special target ... anything starting with a dot */
  Node *n = NULL;

  if (hash_cistrcmp(target, ".SILENT") == 0) {
    amu_flags |= SILENT;
  }
  else if (hash_cistrcmp(target, ".IGNORE") == 0) {
    amu_flags |= IGNORE_RC;
  }
  else if (hash_cistrcmp(target, ".PHONY") == 0) {
    n = find_node(target);
  }
  else if (hash_cistrcmp(target, ".UNIXNAMES") == 0) {
    amu_flags |= UNIX_NAMES;
  }
  else if (hash_cistrcmp(target, ".DEFAULT") == 0) {
    default_rule = n = find_node(target);
  }
  else if (hash_cistrcmp(target, ".INIT") == 0) {
    init_rule = n = find_node(target);
    init_rule->flags |= PHONY;
    make_depend(find_node(".PHONY"), n);
  }
  else if (hash_cistrcmp(target, ".DONE") == 0) {
    done_rule = n = find_node(target);
    done_rule->flags |= PHONY;
    make_depend(find_node(".PHONY"), n);
  }
  else if (hash_cistrcmp(target, ".FAILED") == 0) {
    failed_rule = n = find_node(target);
    failed_rule->flags |= PHONY;
    make_depend(find_node(".PHONY"), n);
  }
  else if (hash_cistrcmp(target, ".SUFFIXES") == 0) {
    suffixes = n = find_node(target);
    if (!dependencies) {
      /* Delete earlier suffixes */
      suffixes->depends_on = NULL;
    }
  }
  else {
    Link *lk;
    char *dest_suffix = strchr(target + 1, '.');

    if (!dest_suffix) {
      amu_err_fail("mal-formed suffix rule");
    }

    for (lk = suffixes ? suffixes->depends_on : NULL; lk && !n; lk = lk->link) {
      if (strcmp(dest_suffix, lk->node->name) == 0) {
        /* Found the target suffix in the list of suffixes */
        n = find_node(target);
        make_depend(lk->node, n);
      }
    }

    if (!n) {
      amu_err_report("rule mentions non-suffix '%s'", dest_suffix);
    }
  }

  return n;
}


static void process_dependency(Line *l)
{
  /* Before exiting, this routine *MUST* make sure it has called set_next_line() appropriately.
   * The act of calling this function is deferred by build_graph() for dependency lines explicitly
   * because this routine needs to read the subsequent command lines until a non-command line is
   * found.  When this routine exits, in.state.l will be pointing at the next line to process
   * already,
   */
  bool double_colon = false;
  LinePart *targets = NULL;
  LinePart *dependencies = NULL;
  LinePart *lp;
  Cmd *cmds = NULL, **next_cmd = &cmds;

  /* On entry, line l has already been completely macroised, so can be parsed straight */
  char *colon = l->firstpart->data;
  char *semicolon;
  char *dependees = NULL;

  strip_trailing_whitespace(colon);

  /* Find the : or :: - this is complicated for RISC OS, because pathnames are quite capable
   * of containing either match string, so we have to search carefully for the match string
   * followed by whitespace, end of string or semi-colon.
   */
  while (!dependees) {
    colon = strchr(colon, ':');
    if (!colon) {
      amu_err_fail("Unrecognised line - missing ':' or '::' ?");
    }

    if (colon[1] == ':') {
      double_colon = true;
      ++colon;
    }

    if (colon[1] == ';' || !colon[1]) {
      colon[-double_colon] = '\0';
      dependees = colon + 1;
    }
    else if (isspace(colon[1])) {
      colon[-double_colon] = '\0';
      dependees = strip_leading_whitespace(colon + 1);
    }
    else {
      double_colon = false;
      ++colon;
    }
  }
  /* Exit condition for loop above: dependees points to dependee list string (or ';' or '\0') */

  /* Now, l->firstpart->data is the purely whitespace separated target list */
  resplit_line(l, rlr_words);
  targets = l->firstpart;

  /* Convert the dependees into a list of LinePart objects.  After this three way if, dependees
   * is NULL if there is no command specified, or a pointer to the first line command otherwise.
   */

  if (dependees[0] == ';') {
    /* No dependees - the first command follows */
    dependees = strip_leading_whitespace(dependees + 1);
  }
  else if (dependees[0] == '\0') {
    /* No dependees - get the the first command follows */
    dependees = NULL;
  }
  else {
    /* Dependencies did exist, split them up to enter them */
    l = clone_line_no_lineparts(l);
    make_new_line_part(l->nextpart, l->lineno)->data = dependees;

    /* Look for a '<semi-colon> <whitespace>' terminator */
    for (semicolon = dependees, dependees = NULL; semicolon;) {
      semicolon = strchr(semicolon, ';');
      if (semicolon) {
        ++semicolon;
        if (isspace(*semicolon)) {
          semicolon[-1] = '\0';
          dependees = strip_leading_whitespace(semicolon);
          break;
        }
      }
    }

    resplit_line(l, rlr_words);
    dependencies = l->firstpart;
  }

  if (dependees) {
    /* This is the first command to be stored - store it then allow set_next_line to run */
    add_command(dependees, next_cmd, &next_cmd);
  }

  /* Read commands */
  for (set_next_line(); in.state.l; set_next_line()) {
    char *cp;

    process_comment(in.state.l);
    lp = in.state.l->firstpart;
    cp = cp_iterator(lp->data - 1, &lp);
    if (!isspace(*cp)) {
      /* Not another command here - exit out the loop */
      break;
    }

    /* We know we are a command, so flatten everything out properly */
    sanitise_line(in.state.l, slr_flatten_leading_spaces);
    macroise(in.state.l->firstpart, &in.state.l->firstpart);
    sanitise_line(in.state.l, slr_flatten);
    add_command(in.state.l->firstpart->data, next_cmd, &next_cmd);
  }

  /* Right, we have parsed everything - now to store it in the node tree.
   *
   * targets is a list of targets
   * dependencies is a list of the dependencies of those targets
   * double_colon is true if we need to clone the nodes
   * cmds is the list of commands to bring the targets up to date w.r.t. the dependencies.
   *
   */

  for (lp = targets; lp; lp = lp->next) {
    char *target = lp->data;
    Node *n;

    if (*target == '.') {
      n = process_special_target(target, dependencies);
    }
    else {
      n = find_node(target);
      if (double_colon) {
        n = clone_node(n);
      }
    }

    if (n) {
      LinePart *dl;
      for (dl = dependencies; dl; dl = dl->next) {
        amu_debug(DEBUGGING, "adding dependency for %s on '%s'", n->name, dl->data);
        make_depend(n, find_node(dl->data));
      }
    }

    if (n && cmds) {
      if (amu_flags & DEBUGGING3) {
        Cmd *c;
        amu_debug(DEBUGGING3, "Assign commands to node %p (%s):", n, n->name);
        for (c=cmds; c; c=c->next) amu_debug(DEBUGGING3, "  %s", c->txt);
      }
      if (n->cmds) {
        amu_err_report("'%s' already has commands (new commands ignored)", n->name);
      }
      else {
        n->cmds = cmds;
      }
    }
  }
}

void build_graph(void)
{
  LinePart *lp;
  LineType type;
  Directive d;
  char *cp;

  set_next_line();

  /* Keep reading stuff whilst there is stuff to read */
  while (in.state.l) {
    /* We are looking for: comments, macros, dependency declarations */
    process_comment(in.state.l);

    /* Reset to start of line; flatten it (we know we're not a command here) */
    sanitise_line(in.state.l, slr_flatten);
    lp = in.state.l->firstpart;
    /* Guaranteed to have one single string now (lp->data) */
    if (lp->next) amu_err_fail("fatal internal error: failed to rejoin parts");

    /* Perform initial parse of the line; lp->data possibly updated too */
    type = identify_line_type(&lp->data, &cp, &d);
    amu_debug(DEBUGGING4, "Line is %s (%s)",
      type == linetype_blank ? "blank" :
      type == linetype_pending ? "unrecognised (pending)" :
      type == linetype_macro_definition ? "a macro definition" :
      type == linetype_dependency ? "a dependency specification" :
      type == linetype_command ? "command" : "directive",
      lp->data);

    switch (type) {
      case linetype_blank:
        set_next_line();
        break;
      case linetype_macro_definition:
        process_macro_definition(in.state.l, cp, d == directive_override);
        set_next_line();
        break;
      case linetype_dependency:
        macroise(lp, &in.state.l->firstpart);
        process_dependency(in.state.l);
        /* no set_next_line() - process_dependency will have already done that! */
        break;
      case linetype_directive:
        in.state.l->firstpart->data = cp;
        macroise(lp, &in.state.l->firstpart);
        process_directive(in.state.l, d);
        set_next_line();
        break;
      case linetype_command:
        amu_err_fail("Command unexpected at this line (no preceding dependency)");
        break;
      case linetype_pending:
        amu_err_fail("Unrecognised line - missing ':' or '::' ?");
        break;
    }
  }
}

void expand_vpath(void)
{
  HashId h;
  char *s;
  UnparsedName un;
  char buf[NAMELEN];
  if (hash_lookup(tag_tab, "VPATH", &h))
  {
    Line *l = alloc_line();
    LinePart *lp = make_new_line_part(l->nextpart, -1);
    MacroVar *mv = hash_value(tag_tab, h);

    lp->data = mv->value;
    if (!mv->expanded) {
      macroise(lp, &lp);
      mv->expanded = true;
      mv->value = Strdup(lp->data);
    }
    else {
      lp->data = Strdup(lp->data);
    }
    resplit_line(l, rlr_words);

    vpathbuf = (char *) malloc(NAMELEN);
    for (lp = l->firstpart; lp; lp = lp->next) {
      fname_parse(lp->data, fname_suffixes, &un);
      fname_unparse(&un, FNAME_AS_NAME, buf, NAMELEN);
      if (n_vpaths >= MAXVPATHS)
        amu_err_fail("too many VPATH elements (> %u)", MAXVPATHS);
      vpaths[n_vpaths++] = s = Strdup_spare(buf, 1);
      s = strchr(s, '\0');
      *s++ = un.pathsep;
      *s = '\0';
    }

    free(l->firstpart);
    free(l);
  }
}

void make_default_suffixes(void)
{
  /* Create the default suffix list from fname_suffixes */
  char *slist, *s;
  int n;
  Link *l;
  char buf[NAMELEN];
  suffixes = find_node(".SUFFIXES");
  slist = fname_suffixes;
  buf[0] = '.';
  for (;;)
  { while (isspace(*slist)) ++slist;
    if (*slist == 0) break;
    s = slist;
    while (*s && !isspace(*s)) ++s;
    n = s - slist;
    strncpy(buf+1, slist, n);
    buf[n+1] = 0;
    l = (Link *) malloc(sizeof(Link));
    l->node = find_node(buf);
    l->link = suffixes->depends_on;
    suffixes->depends_on = l;
    slist = s;
  }
}

void parse_initialise(void)
{
  inc_tab = hash_cinew(TAGTABSZ);
  node_tab = hash_cinew(NODETABSZ);
  dir_tab = hash_cinew(MAXDIRS);
  tag_tab = hash_cinew(TAGTABSZ);
  nodep = NULL;
  nodeq = &nodep;
  dotnodep = NULL;
  dotnodeq = &dotnodep;
}
