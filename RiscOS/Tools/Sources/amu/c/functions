/*
 * AMU (functions.c)
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */

/*
 * This source contains the basic functions callable from makefile macros.
 * The table of available functions is at the end of this file.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>
#include <limits.h>

/* CLX */
#include "err.h"
#include "filestamp.h"
#include "wholefls.h"
#include "hash.h"
#include "fname.h"

/* Local */
#include "amu.h"
#include "parse.h"
#include "macros.h"
#include "md.h"
#include "functions.h"
#include "patterns.h"
#include "readmk.h"
#include "utility.h"

/* Not all of these functions are documented extensively - read the GNU make manual
 * for details of what each function_* function is doing.  The internal utility
 * functions are fully documented here.
 */


/* This function is used to split up the list of parameters into words with or
 * without whitespace.
 *
 * It constructs a dummy Line object to which it attaches the resplit output, and
 * fills in Line.lineno with the number of words it counted.  If rlr is rlr_words,
 * then you get a list of words and no whitespace.  Otherwise you get alternate
 * words and whitespace components.  Line.lineno is always the number of entries
 * in the list (ie. it counts whitespace components if rlr != rlr_words)
 *
 * NOTE: an empty string causes a single empty LinePart to be created, and thus
 *       the return value will always be non-0.
 *
 * This function exists only because the operations it performs are common to
 * a large number of the functions.
 *
 * The entry 'lp' is not deallocated, but its data might be replaced and
 * chained lineparts (lp->next) may have been created and/or deleted.
 * However, not that l->firstpart is NOT going to be equal to 'lp' - since
 * resplit_line duplicates the whole thing; sanitise_line is what modifies
 * what lp points to - and supplies the guarantee that 'lp' itself won't be freed.
 */
static Line *internal_function_make_line(LinePart *lp, resplit_line_reason rlr)
{
  Line *l = alloc_line();
  l->firstpart = lp;

  sanitise_line(l, slr_flatten);
  resplit_line(l,  rlr);

  l->lineno = 0;
  for (lp = l->firstpart; lp; lp = lp->next) {
    ++l->lineno;
  }

  return l;
}

/* This function is the internal helper that actually implements various
 * functions: word, words, wordlist and firstword - as these all do very
 * similar things.  It takes a space-separated word list and returns a
 * space-separated list of words starting at the s'th word up to and
 * including the e'th word (if s > e, swap s and e).
 */
static char *internal_function_word_s_to_word_e(int s, int e, LinePart *lp)
{
  Line *l = internal_function_make_line(lp, rlr_words);
  LinePart *slp, *elp;
  int part;
  char *result;

  slp = NULL;
  elp = NULL;

  /* Perverse: GNU says you may have s > e and make is supposed to swap them! */
  if (s > e) {
    /* Type-safe swap(s,e) */
    s ^= e;  /* s := s ^ e */
    e ^= s;  /* e := (s ^ e) ^ e   - ie. original s */
    s ^= e;  /* s := (s ^ e) ^ s   - ie. original e */
  }

  for (part = 1, lp = l->firstpart; part <= e && lp; ++part, lp = lp->next) {
    if (part == s) {
      /* Found the first word we are interested in */
      slp = lp;
    }
    if (part <= e) {
      /* Keep counting - we don't want to walk off the end of the list */
      elp = lp;
    }
  }

  if (slp) {
    /* Temporarily truncate the word list so we can rejoin things, then restore it */
    lp = elp->next;
    elp->next = NULL;
    result = rejoin_words(slp);
    elp->next = lp;
  }
  else {
    result = Strdup("");
  }

  deallocate_line(l);

  return result;
}

static char *functions_sth_to_eth_word(LinePart *lp)
{
  const int s = (signed int) strtoul(lp->data, NULL, 10);
  const int e = (signed int) strtoul(lp->next->data, NULL, 10);
  return internal_function_word_s_to_word_e(s, e, lp->next->next);
}

static char *functions_nth_word(LinePart *lp)
{
  const int n = (signed int) strtoul(lp->data, NULL, 10);
  return internal_function_word_s_to_word_e(n, n, lp->next);
}

static char *functions_firstword(LinePart *lp)
{
  return internal_function_word_s_to_word_e(1, 1, lp);
}

/* Returns a count of the number of words in lp (data is returned in l->lineno) */
static char *functions_words(LinePart *lp)
{
  Line *l = internal_function_make_line(lp, rlr_words);
  char temporary_string[16]; /* Must be long enough for the %i expansion */

  sprintf(temporary_string, "%i", l->lineno);
  deallocate_line(l);

  return Strdup(temporary_string);
}

/* strip: removes leading and trailing whitespace from its argument */
static char *functions_strip(LinePart *lp)
{
  return Strdup(strip_trailing_whitespace(strip_leading_whitespace(lp->data)));
}


/* Auxiliary sorter function for functions_sort */
static int functions_sort_aux(const void *o1, const void *o2)
{
  LinePart *const* lp1 = o1;
  LinePart *const* lp2 = o2;

  return strcmp((*lp1)->data, (*lp2)->data);
}

/* Filters out (and frees memory for) duplicates and empties in the supplied list */
static LinePart *remove_and_free_duplicates_for_sort(LinePart *lp)
{
  LinePart *match = NULL, *next_lp;
  LinePart *result = NULL, **next_result = &result;

  for (;lp;lp=next_lp) {
    next_lp = lp->next;
    if (lp->data[0] == '\0' || (match && strcmp(match->data, lp->data) == 0)) {
      /* Empty strings - delete these */
      free(lp->data);
      free(lp);
    }
    else {
      match = lp;
      *next_result = lp;
      next_result = &lp->next;
    }
  }

  *next_result = NULL;

  return result;
}

/* Sort the words in 'lp', *removing duplicates* as we go */
static char *functions_sort(LinePart *lp)
{
  Line *l = internal_function_make_line(lp, rlr_words);
  char *result;

  if (l->lineno == 0) {
    result = Strdup("");
  }
  else {
    int count, n;
    LinePart **array = safe_malloc((l->lineno+1) * sizeof(*array));
    for (count = 0, lp = l->firstpart; lp; lp = lp->next) {
      array[count++] = lp;
    }
    array[count] = NULL;
    qsort(array, count, sizeof(*array), functions_sort_aux);
    /* Re-link the sorted array back into a linked list */
    for (n = 0; n < count; ++n) {
      array[n]->next = array[n+1];
    }

    l->firstpart = remove_and_free_duplicates_for_sort(array[0]);
    free(array);
    result = rejoin_words(l->firstpart);
  }

  deallocate_line(l);
  return result;
}

static char *internal_functions__not_implemented(LinePart *lp)
{
  (void) lp;
  return Strdup("function not implemented");
}

static char *functions_subst(LinePart *lp)
{
  const char *match = lp->data;
  const char *repl  = lp->next->data;
  const char *data  = lp->next->next->data, *data_copy = data;
  const size_t mlen = strlen(match);
  const size_t rlen = strlen(repl);
  int result_length = 1;
  char *result, *cp;

  if (!*match) {
    /* Special case of empty match string - only match the end of string,
     * rather than entering an infinite loop :-)  This behaviour is that
     * exhibited by some version of GNU make.
     */
    result = safe_malloc(strlen(data) + rlen + result_length);
    strcpy(result, data);
    return strcat(result, repl);
  }

  while (data) {
    const char *new_data = strstr(data, match);

    if (!new_data) {
      result_length += strlen(data);
      data = new_data;
    }
    else {
      result_length += (new_data - data) + rlen;
      data = new_data + mlen;
    }
  }

  result = safe_malloc(result_length);

  for (data = data_copy, cp = result; data; ) {
    const char *new_data = strstr(data, match);

    if (!new_data) {
      strcpy(cp, data);
      data = new_data;
    }
    else {
      size_t amt = new_data - data;
      memcpy(cp, data, amt);
      memcpy(cp + amt, repl, rlen);
      cp += amt + rlen;
      data = new_data + mlen;
    }
  }

  return result;
}


static char *functions_patsubst(LinePart *lp)
{
  pattern_substitution search, replace;
  char *result;
  Line *l = alloc_line();

  patterns_analyse_pattern(lp->data, &search);
  patterns_analyse_pattern(lp->next->data, &replace);
  l->firstpart = lp->next->next;
  lp->next->next = NULL;
  resplit_line(l, rlr_words);
  patterns_process_line_part_list(l->firstpart, &search, &replace);
  result = rejoin_words(l->firstpart);
  patterns_destroy_substitution(&search);
  patterns_destroy_substitution(&replace);
  deallocate_line(l);

  return result;
}

/* Filter words in lp->next->data against the set of patterns in lp->data
 *
 * We split out the patterns by converting both linepart arguments into separate
 * pseudo-Line structures.  We take temporary copies of the linepart arguments
 * but we must remember that lp->data and lp->next->data *will* be deallocated
 * by the calls to internal_function_make_line.
 */
static char *internal_functions_filter(LinePart *lp, bool keep_matches)
{
  Line *patterns, *strings;
  LinePart **wanted_next, *slp;
  pattern_substitution *ps;
  LinePart *plp;
  int count;

  /* Find the string list to filter first so we can detach it from 'lp' */
  strings = internal_function_make_line(lp->next, rlr_words);
  /* We no longer require the original data, so delete it and forget it */
  deallocate_linepart_list(lp->next);
  lp->next = NULL;

  /* Detach the word list and reset the line object ready for the filtering */
  slp = strings->firstpart;
  strings->nextpart = &strings->firstpart;

  /* Now lp->next is gone, we can safely parse the pattern words */
  patterns = internal_function_make_line(lp, rlr_words);
  /* We no longer require this list either - so deallocate it too, and its
   * orignal data, leaving only the original object allocated (which our
   * caller will free after the function call completes).
   */
  deallocate_linepart_list(lp->next);
  free(lp->data);
  lp->next = NULL;
  lp->data = Strdup("");

  /* Now, decipher all the pattern matches */
  ps = safe_malloc(sizeof(*ps) * patterns->lineno);
  for (count = 0, plp = patterns->firstpart; plp; plp = plp->next, ++count) {
    patterns_analyse_pattern(plp->data, &ps[count]);
  }

  /* We need to keep some idea of the pattern list, so we shall leave the
   * patterns object alone, but we will immediately detach the string list
   * and assign it to 'slp' as we are going to be walking down this list
   * only once.  We then re-initialise the part list for 'strings'.  As we
   * progress down 'slp', we must decide whether to attach each entry to
   * the list rooted at 'lp' or to the list rooted at strings->nextpart
   * depending on whether we want to keep it or not respectively.
   *
   * When we come to exit, we need to return rejoin_words(lp).  The function
   * calling code will then free up 'lp' for us.  We deallocate the strings
   * line object, and it will take all the unwanted entries with it, thus
   * we won't leak anything or free anything twice.
   */

  wanted_next = &lp->next;  /* Where to store the address of the next wanted entry */
  /* strings->nextpart is where to store the address of the next unwanted entry */

  for (;slp; slp = slp->next) {
    bool matched = false;
    int stem_length_irrelevant;

    for (count = 0; count < patterns->lineno && !matched; ++count) {
      matched = patterns_match_word(slp->data, &ps[count], &stem_length_irrelevant);
    }

    /* matched is true if we matched the pattern - do we keep matches or not? */
    if (!keep_matches) {
      matched = !matched;
    }

    if (matched) {
      *wanted_next = slp;
      wanted_next = &slp->next;
    }
    else {
      *(strings->nextpart) = slp;
      strings->nextpart = &slp->next;
    }
  }

  for (count = 0; count < patterns->lineno; ++count) {
    patterns_destroy_substitution(&ps[count]);
  }
  free(ps);
  deallocate_line(patterns); /* throw away the patterns and their line object */

  *(strings->nextpart) = NULL; /* terminate the list of rejects */
  deallocate_line(strings); /* and throw them and the Line object away */

  *wanted_next = NULL; /* terminate the list of wanted notes */
  if (lp->next) {
    return rejoin_words(lp->next); /* and concatenate them with single spaces */
  }
  else {
    return Strdup("");
  }
}

static char *functions_filter(LinePart *lp)
{
  /* Only include matches - so pass true to the generic filter function */
  return internal_functions_filter(lp, true);
}

static char *functions_filter_out(LinePart *lp)
{
  /* Only include non-matches - so pass false to the generic filter function */
  return internal_functions_filter(lp, false);
}

static char *functions_findstring(LinePart *lp)
{
  char *result;

  if (strstr(lp->next->data, lp->data)) {
    /* Optimise - no need to duplicate it again */
    result = lp->data;
    lp->data = NULL;
  }
  else {
    result = Strdup("");
  }

  return result;
}

static char *functions_dir(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_notdir(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_suffix(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_basename(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_addsuffix(LinePart *lp)
{
  Line *arg1;
  char *cresult;

  arg1 = internal_function_make_line(lp->next, rlr_words);
  lp->next = NULL;

  if (arg1->lineno == 0 || !*(arg1->firstpart->data)) {
    cresult = Strdup("");
  }
  else {
    LinePart *lparg1;
    Line *result = alloc_line();
    const char *const right = lp->data;
    const size_t right_len = strlen(right);

    for (lparg1 = arg1->firstpart; lparg1; lparg1 = lparg1->next) {
      const char *const left = lparg1->data;
      append_new_line_part(result)->data = strcat(Strdup_spare(left, right_len), right);
    }

    cresult = rejoin_words(result->firstpart);
    deallocate_line(result);
  }

  deallocate_line(arg1);

  return cresult;

}

static char *functions_addprefix(LinePart *lp)
{
  Line *arg2;
  LinePart *lparg2 = lp->next;
  char *cresult;

  lp->next = NULL;
  arg2 = internal_function_make_line(lparg2, rlr_words);

  if (arg2->lineno == 0 || !*(arg2->firstpart->data)) {
    cresult = Strdup("");
  }
  else {
    Line *result = alloc_line();

    for (lparg2 = arg2->firstpart; lparg2; lparg2 = lparg2->next) {
      const char *const left = lp->data;
      const char *const right = lparg2->data;
      append_new_line_part(result)->data = strcat(Strdup_spare(left, strlen(right)), right);
    }

    cresult = rejoin_words(result->firstpart);
    deallocate_line(result);
  }

  deallocate_line(arg2);

  return cresult;
}

static char *functions_join(LinePart *lp)
{
  Line *arg1, *arg2;
  LinePart *lparg2 = lp->next;
  LinePart *lparg1 = lp;
  char *cresult;
  int counter;

  lp->next = NULL;
  arg1 = internal_function_make_line(lparg1, rlr_words);
  arg2 = internal_function_make_line(lparg2, rlr_words);
  counter = arg1->lineno > arg2->lineno ? arg1->lineno : arg2->lineno;

  if (counter == 0) {
    cresult = Strdup("");
  }
  else {
    Line *result = alloc_line();

    lparg1 = arg1->firstpart;
    lparg2 = arg2->firstpart;

    while (counter-- > 0) {
      /* Join lparg1->data and lparg2->data (substituting empty strings if NULL) */
      const char *const left = lparg1 ? lparg1->data : "";
      const char *const right = lparg2 ? lparg2->data : "";

      append_new_line_part(result)->data = strcat(Strdup_spare(left, strlen(right)), right);

      if (lparg1) lparg1 = lparg1->next;
      if (lparg2) lparg2 = lparg2->next;
    }

    cresult = rejoin_words(result->firstpart);
    deallocate_line(result);
  }

  deallocate_line(arg1);
  deallocate_line(arg2);

  return cresult;
}

static char *functions_wildcard(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_foreach(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  return internal_functions__not_implemented(lp);
}

static char *functions_origin(LinePart *lp)
{
  return Strdup(get_origin(lp->data));
}

static char *functions_shell(LinePart *lp)
{

  /* THIS FUNCTION NEEDS TO BE IMPLEMENTED PLEASE */

  /* need to basically pass it to 'execute', capture the output, re-arrange it
   * and return it as the result of this function.  This routine could also
   * be used to implement back-tick style shell execution.
   */

  return internal_functions__not_implemented(lp);
}

/******************************************************************************/
/******************************************************************************/

/* This is the table of supported functions and the support functions and types.
 *
 * When invoked, each function will be passed the count of entries
 * in the linepart list.  The list is guaranteed to have at least
 * min_args (first numueric parameter of the two) entries.
 */
typedef char *(*function_executor)(LinePart *args);

/* A simple enumerated type that can be used to identify functions
 *
 * Headings correspond to the GNU make manual's headings, where further
 * documentation can be found.
 */
typedef enum {
  func_not_recognised,
  /* Functions for String Substitutions and Analysis */
  func_subst,
  func_patsubst,
  func_strip,
  func_findstring,
  func_filter,
  func_filter_out,
  func_sort,
  /* Functions for File Names */
  func_dir,
  func_notdir,
  func_suffix,
  func_basename,
  func_addsuffix,
  func_addprefix,
  func_join,
  func_word,
  func_wordlist,
  func_words,
  func_firstword,
  func_wildcard,
  /* The foreach Function */
  func_foreach,
  /* The origin Function */
  func_origin,
  /* The shell Function */
  func_shell,

  /* A magic termination symbol */
  func__last
} known_functions;

struct function_table {
  known_functions code;
  char *name;
  int min_args;
  int max_args;
  bool macroise_each_parameter;
  function_executor execute;
};


static const function_table func_tab[] =
{
  { func_subst,       "subst",      3, 3, true,  functions_subst           },
  { func_patsubst,    "patsubst",   3, 3, true,  functions_patsubst        },
  { func_strip,       "strip",      1, 1, true,  functions_strip           },
  { func_findstring,  "findstring", 2, 2, true,  functions_findstring      },
  { func_filter_out,  "filter",     2, 2, true,  functions_filter          },
  { func_filter_out,  "filter-out", 2, 2, true,  functions_filter_out      },
  { func_sort,        "sort",       1, 1, true,  functions_sort            },

  { func_dir,         "dir",        1, 1, true,  functions_dir             },
  { func_notdir,      "notdir",     1, 1, true,  functions_notdir          },
  { func_suffix,      "suffix",     1, 1, true,  functions_suffix          },
  { func_basename,    "basename" ,  1, 1, true,  functions_basename        },
  { func_addsuffix,   "addsuffix",  2, 2, true,  functions_addsuffix       },
  { func_addprefix,   "addprefix",  2, 2, true,  functions_addprefix       },
  { func_join,        "join",       2, 2, true,  functions_join            },

  { func_word,        "word",       2, 2, true,  functions_nth_word,       },
  { func_wordlist,    "wordlist",   3, 3, true,  functions_sth_to_eth_word },
  { func_words,       "words",      1, 1, true,  functions_words,          },
  { func_firstword,   "firstword",  1, 1, true,  functions_firstword       },

  { func_wildcard,    "wildcard",   1, 1, true,  functions_wildcard        },

  { func_foreach,     "foreach",    1, 1, false, functions_foreach         },

  { func_origin,      "origin",     1, 1, true,  functions_origin          },

  { func_shell,       "shell",      1, 1, true,  functions_shell           },

  /* The following line is the terminating record */
  { func_not_recognised, NULL }
};

const function_table *fn_lookup(char *name)
{
  const function_table *ft;

  for (ft = func_tab; ft->name; ++ft) {
    if (hash_cistrcmp(name, ft->name) == 0) break;
  }

  return ft;
}

char *fn_execute(LinePart *argp, const function_table *ft)
{
  return (ft->execute)(argp);
}

int fn_minargs(const function_table *ft)
{
  return ft->min_args;
}

int fn_maxargs(const function_table *ft)
{
  return ft->max_args;
}

bool fn_macroise_parameters(const function_table *ft)
{
  return ft->macroise_each_parameter;
}

char *fn_name(const function_table *ft)
{
  return ft->name;
}
