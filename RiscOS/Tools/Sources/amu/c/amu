/*
  Title:        Acorn 'make' utility - amu
  Copyright:    (C) 1987, Acorn Computers Ltd., Cambridge, England.
*/

/*
 * The Acorn Make Utility (amu) processes a restricted makefile which textually
 * describes dependencies between 'targets' and 'sources'. Each block in the
 * makefile describes the dependency of some list of targets on a list of
 * sources and lists commands to be executed to bring the targets up to
 * date with respect to the sources.
 *
 * Amu operates by building a graph describing the dependencies between
 * sources and targets, obtaining time-stamps for each object (node) in the
 * graph, then processing the graph to generate the minimum file of commands
 * needed to bring all the targets up to date.
 *
 * Host dependent functions are isolated in host.c.
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <stdarg.h>
#include <ctype.h>
#include <stddef.h>
#include <stdbool.h>
#include <iso646.h>

#include "kernel.h"

/* From CLX */
#include "hash.h"
#include "filestamp.h"
#include "fname.h"
#include "host.h"
#include "err.h"
#include "wholefls.h"

/* Local headers */
#include "amu.h"
#include "md.h"
#include "parse.h"
#include "macros.h"
#include "utility.h"
#include "VersionNum"

#define  VERSION          Module_FullVersion
#define  DATE             Module_Date
#define  SELFNAME         "AMU"

/* give up if too many time-stamp errors */
#define  ERRORLIMIT      15

/* the commands to use for existing targets or non-existing targets when just touching files */
#define  TOUCH_E_CMD     "Stamp"
#define  TOUCH_NE_CMD    "Create"

#ifdef __STDC__
#  define safe_tolower(ch) tolower(ch)
#else
#  define safe_tolower(ch) (isupper(ch) ? tolower(ch) : ch)
#endif


/* Global variables */
char amu[] = SELFNAME;
int amu_flags;
const int dir_sep = '.';
Node *suffixes;
Node *default_rule, *init_rule, *done_rule, *failed_rule;
char *vpathbuf;
VpathList *vpaths = NULL;
DirList *dirs = NULL;
char *fname_suffixes = "aof o s c c++ f p l h x bas pas cmhg";
include_search_path include_dirs = { NULL, { 0 } };
Makefile_Stack in = { -1, -1 };


/* Local variables for this file */
static FILE *out;
static TimeStamp now;
static char *suffix_list;
static char *ebuf, *ebufbase;
static int  ebuflen;
static int nerrors;
static include_search_path **next_include_dir = &include_dirs.next;

/* Forward declarations */
static int process_target(char *target, int rc, Node *n);

/* This routine will print out the pre-amble for an error or warning showing the current
 * line number and current makefile, and also unwind the inclusion stack to show how we
 * got here.
 */
static void report_makefile_depth(void)
{
  if (in.idx < 0) {
    /* Do nothing - no file has been started yet */
  }
  else if (in.idx == 0) {
    /* One level only - report as before if we have the filename */
    if (in.file[0]->name) {
      err_report("in makefile %s (line %u):", in.file[0]->name, in.file[0]->lineno);
    }
    else {
      err_report("at line %u:", in.file[0]->lineno);
    }
  }
  else {
    int i;
    for (i=0; i<in.idx-1; ++i)
      err_report("in makefile included from %s (line %u):", in.file[i]->name, in.file[i]->lineno);
    err_report("in makefile %s (line %u):", in.file[i]->name, in.file[i]->lineno);
  }
}

/* Debug output - but only if amu_flags has flag set */
void amu_debug(int flag, const char *fmt, ...)
{
  if (amu_flags & flag) {
    va_list ap;
    va_start(ap, fmt);
    err_va_report((char *)fmt, ap);
    va_end(ap);
  }
}

/* Like CLX's err_report, but shows the makefile structure backtrace first */
void amu_err_report(const char *fmt, ...)
{
  va_list ap;
  report_makefile_depth();
  va_start(ap, fmt);
  err_va_report((char *)fmt, ap);
  va_end(ap);
}

/* Like CLX's err_fail, but shows the makefile structure backtrace first - DOES NOT RETURN */
void amu_err_fail(const char *fmt, ...)
{
  va_list ap;
  report_makefile_depth();
  va_start(ap, fmt);
  err_va_fail((char *)fmt, ap);  /* DOES NOT RETURN */
  va_end(ap);
}


static void add_include_path(const char *path)
{
  while (*path) {
    size_t prefix_len = strcspn(path, ",");
    if (prefix_len > 0) {
      char *end_of_path;
      include_search_path *i;
      i = *next_include_dir = malloc(prefix_len + sizeof(**next_include_dir));
      next_include_dir = &i->next;
      i->next = NULL;
      memcpy(i->txt, path, prefix_len);
      end_of_path = i->txt + prefix_len - 1;
      if (*end_of_path != ':' && *end_of_path != '.') {
        *++end_of_path = '.';
      }
      end_of_path[1] = '\0';
      amu_debug(DEBUGGING, "added directory '%s' to the search path", i->txt);
    }
    path += prefix_len;
    if (*path) {
      ++path;
    }
  }
}

char *real_file_name(char s[], char *buf, int maxlen)
{
  UnparsedName un;

  fname_parse(s, fname_suffixes, &un);
  fname_unparse(&un, FNAME_AS_NAME, buf, maxlen);
  return buf;
}

static void e_ensure(n)
int n;
{ int p = (ebuf - ebufbase);
  while (n >= (ebuflen - (ebuf - ebufbase)))
  { ebuflen *= 2;
    ebufbase = realloc(ebufbase, ebuflen);
  }
  ebuf = ebufbase + p;
}

static void e_save(s, n)
char *s;
int n;
{ e_ensure(n);
  strncpy(ebuf, s, n);
  ebuf += n;
}

static int is_extn(const char *e, int elen)
{
  char *s = suffix_list;
  int e0 = *e;

  while (*s)
  { if (*s == e0)
    { int j = 1, ch = e0;
      while (j < elen && (ch = s[j]) == e[j]) ++j;
      ch = s[j];
      if ((ch == 0 || ch == ' ') && j == elen) return 1;
    }
    ++s;
  }
  return 0;
}

static char *expand(cmdtxt, target_node, is_pattern)
char *cmdtxt;
Node *target_node;
int is_pattern;
{
  char *s = cmdtxt;
  char *target_name = *(target_node->file);
  int ch;

  while (*s)
  {
    if (*s == '$' && strchr("<*@?", s[1]) != NULL) break;
    ++s;
  }
  if (*s == 0) return cmdtxt;
  /* something to do */
  if (ebuf == NULL) ebufbase = malloc(ebuflen = CMDLEN);
  ebuf = ebufbase;
  while ((ch = *s++) != 0)
  {
    if (ch == '$' && strchr("<*@?", *s) != NULL)
    { e_save(cmdtxt, (s - cmdtxt) - 1);
      switch (*s)
      {
case '@': e_save(target_name, (int)strlen(target_name));
          ++s;
          break;
case '*': {
          char *s1, *extn, *name;

          s1 = target_name;
          name = s1;
          extn = 0;
          while (*s1) {
              if (*s1++ == '.') {
                  extn = name;
                  name = s1;
              }
          };
          e_ensure(NAMELEN);
          if (extn && is_extn(extn, name - extn - 1)) {
              memcpy(ebuf, target_name, extn - target_name);
              ebuf += extn - target_name;
              strcpy(ebuf, name);
          } else
              strcpy(ebuf, target_name);
          ebuf += strlen(ebuf);
          while (*++s && !isspace(*s))
              *ebuf++ = *s;
          *ebuf = 0;
          break;
      }
case '<': if (is_pattern)
          { char *prereq_name;
            if (target_node->depends_on == NULL)
              /* treat as $@ ... */
              prereq_name = target_name;
            else
              prereq_name = *(target_node->depends_on->node->file);
            e_save(prereq_name, (int)strlen(prereq_name));
          }
          ++s;
          break;
case '?': { Link *l = target_node->depends_on;
            while (l != NULL)
            { if (target_node->time == FILESTAMP_NEVER ||
                      l->node->time >  target_node->time)
              { char *prereq_name = *(l->node->file);
                e_save(prereq_name, (int)strlen(prereq_name));
              }
              l = l->link;
              if (l != NULL) e_save(" ", 1);
            }
          }
          ++s;
          break;
      }
      cmdtxt = s;
    }
  }
  e_save(cmdtxt, (s - cmdtxt) + 1);
  return ebufbase;
}

static void copy_cmds(Node *rule_node, Node *target_node)
{
  Cmd *cmdp = NULL, **cmdq = &cmdp, *cmd;

  for (cmd = rule_node->cmds; cmd; cmd = cmd->next) {
    cmdq = sl_new_append(cmdq, expand(cmd->txt, target_node, 1));
  }

  *cmdq = NULL;
  target_node->cmds = cmdp;
}

static Node *suffix_of(const char *extn, int elen)
{ Link *l;
  if (suffixes == NULL || (l = suffixes->depends_on) == NULL) return NULL;
  while (l != NULL)
  { char *s = l->node->name+1;
    if (strncmp(s, extn, elen) == 0) return l->node;
    l = l->link;
  }
  return NULL;
}

static int has_src_suffix(n, s)
Node *n;
char *s;
{ char *name = n->name;
  int l = strlen(s);
  if (strncmp(name, s, l) == 0 && name[l]  == '.') return 1;
  return 0;
}

static TimeStamp get_filestamp(char *name, int vpath)
{
  TimeStamp ts;
  if (vpath) {
    if (vpaths) {
      int len = strlen(name);
      VpathList *j;
      char *s = vpathbuf;
      ts = FILESTAMP_NEVER;
      for (j = vpaths;  j; j = j->next) {
        strcpy(s, j->txt);
        if ((strlen(s) + len) >= NAMELEN)
          amu_err_fail("name too long: %s%s\n", s, name);
        strcat(s, name);
        ts = filestamp_get(s);
        if (ts != 0 && ts != FILESTAMP_NEVER) break;
      }
      return ts;
    }
    else vpathbuf = name;
  }
  ts = filestamp_get(name);
  return ts;
}

static void make_inferences_for(node)
Node *node;
{
  Node *rules;
  Link *p, *l;
  UnparsedName un;
  char new_name[NAMELEN];

  rules = NULL;
  if (suffix_list != NULL)
  { fname_parse(node->name, suffix_list, &un);
    if (un.elen > 0) rules = suffix_of(un.extn, un.elen);
  }
  if (rules == NULL)
  { if (default_rule != NULL) copy_cmds(default_rule, node);
    return;
  }
  /* Do the following search this way to ensure correct search order. */
  /* Seek the first suffix (in the reversed - i.e. correctly ordered) */
  /* list of suffixes for which there is a rule and a source file...  */
  for (p = suffixes->depends_on;  p != NULL;  p = p->link)
  { TimeStamp ts;
    Node *new;
    /* search the list of rules with the target suffix of node->name  */
    /* for one with the same source suffix as the current suffix from */
    /* the list of all applicable suffixes.                           */
    for (l = rules->depends_on;  l != NULL;  l = l->link)
      if (has_src_suffix(l->node, p->node->name)) break;  /* found it */
    if (l == NULL) continue;                             /* not found */
    /* See if a file with the found source suffix exists */
    un.extn = p->node->name+1;
    un.elen = strlen(un.extn);
    fname_unparse(&un, FNAME_AS_NAME, new_name, NAMELEN);
    ts = get_filestamp(new_name, 1);
    if (ts == 0 || ts == FILESTAMP_NEVER) continue;  /* doesn't exist */
    /* Made a successful inference - so set up the source node */
    new = find_node(vpathbuf);
    new->time = ts;
    new->flags |= HAS_TIMESTAMP;
    make_depend(node, new);
    copy_cmds(l->node, node);
    break;
  }
}

static bool out_of_date(Node *n, TimeStamp t)
{
  Link *l;

  for (l = n->depends_on;  l != NULL;  l = l->link)
    n->flags |= (l->node->flags & CMDS_FAILED);

  if (n->flags & (CMDS_FAILED|HAS_CLONES)) return false;

  /* .PHONY targets are always out-of-date */
  for (l = find_node(".PHONY")->depends_on; l != NULL;  l = l->link) {
    if (l->node == n) {
      amu_debug(DEBUGGING, "%s is a phony target\n", n->name);
      if (amu_flags & STATE_REASONS) {
        fprintf(stderr, "%s is a phony target\n", n->name);
      }
      return true;
    }
  }

  if (n->time == FILESTAMP_NEVER)
  { if (n->flags & IS_DEPENDED_ON &&
        (amu_flags & STATE_REASONS))
      fprintf(stderr, "%s does not yet exist\n", n->name);
    return true;
  }

  for (l = n->depends_on;  l != NULL;  l = l->link)
  { Node *nd = l->node;
    if (n->cmds != NULL && nd->time > t ||
        n->cmds == NULL && out_of_date(nd, t))
    {
        if (amu_flags & STATE_REASONS)
fprintf(stderr, "%s is out of date w.r.t. %s\n", n->name, l->node->name);
        return true;
    }
  }
  return false;
}

static TimeStamp newest_source_time(target)
Node *target;
{
  Link *l;
  Node *s;
  TimeStamp t, t_default;

  t = t_default = ++now;
  for (l = target->depends_on;  l != NULL;  l = l->link) {
    s = l->node;
    if (s->time == FILESTAMP_NEVER) {
      return t_default;
    } else {
      if (t == t_default || (s->time > t)) t = s->time;
    }
  }
  return t;
}

/* Called to terminate the graph process.  Note that after deciding which
 * termination rule is to be used, the rules are blanked to avoid infinite
 * recursion!
 */
static int end_process_graph(int rc)
{
  Node *n = NULL;

  if (rc && failed_rule) {
    n = failed_rule;
    failed_rule = NULL;
  }
  else if (done_rule) {
    n = done_rule;
    done_rule = NULL;
  }

  if (n) {
    process_target(n->name, rc, get_dot_node_list());
  }

  return rc;
}

static int execute(Cmd *cmd, Node *node)
{
  if (node->time == FILESTAMP_NEVER &&
      node->flags & IS_DEPENDED_ON  &&
      cmd == NULL)
  {
    if (node->flags & PHONY) {
      return 0;
    }
    else if (amuflag_TOUCHING) {
      /* Simplest to simply recall this procedure with a non-NULL cmd */
      Cmd c;
      c.next = NULL;
      c.txt[0] = '\0';
      return execute(&c, node);
    }
    else {
      amu_err_report("Don't know how to make '%s'", node->name);
      return -1;
    }
  }

  if (cmd == NULL)
    node->time = newest_source_time(node);       /* no updating command... */

  while (cmd != NULL) {
    int flags = amu_flags;
    char *cmdtxt = Strdup(cmd->txt), *newtxt;

    amu_debug(DEBUGGING4, "Pre-expansion:  Executing '%s'", cmdtxt);

    (void) macroise_free(&cmdtxt, true);

    amu_debug(DEBUGGING4, "Post-expansion: Executing '%s'", cmdtxt);

    for (newtxt = cmdtxt;;++cmdtxt) {
      if (*cmdtxt == '@') flags |= SILENT;
      else if (*cmdtxt == '-') flags |= IGNORE_RC;
      else if (*cmdtxt == '+') flags &= ~amuflag_TOUCHING;
      else break;
    }

    /* Be careful - don't want to not show actions when in no-execute mode */
    if (amu_flags & NO_ACTION) flags &= ~SILENT;

    if (flags & amuflag_TOUCHING) {
      /* We must re-evaluate whether the file exists because previous + commands may
       * have created it.
       */
      const bool exists = (filestamp_get(node->name) != FILESTAMP_NEVER);
      char *touch_cmd =  exists ? TOUCH_E_CMD : TOUCH_NE_CMD;

      free(newtxt);
      cmdtxt = newtxt = safe_malloc(strlen(touch_cmd) + 1 + strlen(node->name) + 1);
      sprintf(cmdtxt, "%s %s", touch_cmd, node->name);
    }
    else {
      /* N.B. '?' MUST be first or it won't get expanded */
      cmdtxt = expand(cmdtxt, node, 0);
      if (strlen(cmdtxt) > CMDLENLIM && !dde_extended_cmdline())
      {
        putc('\n', stderr);
        amu_err_fail("command too long (must be shorter than %d chars)\n%s\n\n", CMDLENLIM, cmdtxt);
      }
    }

    if (!(flags & SILENT)) fprintf(stderr, "%s\n", cmdtxt);
    if (out)
    { fprintf(out, "%s\n", cmdtxt);
      amu_flags |= state_CMDS_OUTPUT;
    }
    else if (!(flags & NO_ACTION))
    { int rc;
      char *last_sys_rc = getenv("Sys$ReturnCode");
      if (last_sys_rc == NULL) last_sys_rc = "";
      _kernel_setenv("AMU$ReturnCode", last_sys_rc);
      _kernel_setenv("Sys$ReturnCode", "0");
      md_start_cmd();
      rc = system(cmdtxt);
      if (rc == _kernel_ERROR) {
        amu_err_report("*** %s ***\n", _kernel_last_oserror()->errmess);
      }
      else if (rc != 0) {
        if (flags & IGNORE_RC) {
          amu_err_report("*** ignored non-zero exit (%u) ***\n", rc);
        }
        else {
          amu_err_report("*** exit (%u) ***\n", rc);
        }
      }
      if (rc != 0 && !(flags& IGNORE_RC)) return rc;
      md_end_cmd();
    }
    free(newtxt);
    cmd = cmd->next;
  }
  return 0;
}

static void process_node(Node *n, char *const target)
{
  Link *l;
  int uptodate = UPTODATE;

  if (n->flags & PROCESSED) return;

  if (n->cmds == NULL) make_inferences_for(n);

  for (l = n->depends_on;  l != NULL;  l= l->link)
  { process_node(l->node, target);
    uptodate &= l->node->flags;
  }
  if (out_of_date(n, n->time))
  {
    if (!(n->flags & CMDS_EXECUTED))
    {
      if (execute(n->cmds, n) != 0)
      { n->flags |= CMDS_FAILED;
        if (!(amu_flags & CONTINUE)) {
          end_process_graph(1);
          md_merge(in.state.mf);
          md_delete();
          if (n->flags & PHONY && n->name[0] == '.') {
            amu_err_fail("*** '%s' target incomplete due to errors ***\n", target);
          }
          else {
            amu_err_fail("*** '%s' not re-made because of errors ***\n", target);
          }
        }
      }
      else if (n->cmds == NULL)
        n->flags |= uptodate;
      n->flags |= CMDS_EXECUTED;
    }
    else if (amu_flags & STATE_REASONS)
      fprintf(stderr, "(target updated by an earlier command)\n");
    n->time = ++now;
  }
  else if (!(n->flags & CMDS_FAILED)) n->flags |= uptodate;
  n->flags |= PROCESSED;
}

static bool is_a_cycle_from(Node *n)
{
  bool cyclic;
  Link *l;

  if (n->flags & MARKED)
  {
    amu_err_report("*** WARNING: cycle in dependency graph ***\n  to %s", n->name);
    cyclic = true;
    amu_flags |= state_HAS_CYCLES;
  }
  else cyclic = false;

  if (!(n->flags & VISITED))
  { n->flags |= VISITED + MARKED;
    for (l = n->depends_on;  l != NULL;  l = l->link)
        if (is_a_cycle_from(l->node)) {
            cyclic = true;
            n->flags |= PROCESSED;
        }
    if (cyclic)
        fprintf(stderr, "from %s\n", n->name);
    if (cyclic && !(n->flags & MARKED))
    {   cyclic = false;
        amu_err_report("*** end of cycle ***\n");
    }
  }
  n->flags &= ~MARKED;
  return cyclic;
}

static int process_target(char *target, int rc, Node *n)
{
  for (;  n != NULL;  n = n->next)
  {
    if (!(n->flags & PROCESSED) && (hash_cistrcmp(target, n->name) == 0)) {
      (void) is_a_cycle_from(n);
      process_node(n, target);
      if (n->flags & UPTODATE) {
        if (!(n->flags & IS_COLONCOLON) &&
            (amu_flags & (NO_ACTION|SILENT)) != (NO_ACTION|SILENT))
          fprintf(stderr, "'%s' is up to date\n", n->name);
      }
      else if ((n->flags & (CMDS_FAILED|PHONY)) != PHONY) {
        rc = 1;
      }
    }
  }

  return rc;
}

/* Process the targets in the supplied array, returning 0 if they all succeeded.
 * Process a .INIT target first though, and after the main targets, process .FAILED
 * if an error has occurred, or .DONE if no error occurred or there was no .FAILED
 * target.
 */
static int process_graph(TargetList *targets)
{
  int rc = 0;

  if (init_rule) {
    rc = process_target(init_rule->name, rc, get_dot_node_list());
  }

  while (targets) {
    rc = process_target(targets->txt, rc, get_node_list());
    targets = targets->next;
  }

  rc = end_process_graph(rc);

  if (amu_flags & state_HAS_CYCLES) {
    amu_err_report("*** There are cyclic dependencies in 'makefile' ***");
    amu_err_report("***    which have been broken arbitrarily.      ***\n");
  }

  return rc;
}

static void mark_phony_targets(Node *n)
{
  Link *l;
  Node *phony = find_node(".PHONY");

  for (;n;n=n->next) {
    for (l = phony->depends_on; l; l = l->link) {
      if (hash_cistrcmp(l->node->name, n->name) == 0) n->flags |= PHONY;
    }
  }
}

static void make_suffix_list()
{ Link *l, *p, *q;
  int n;
  if (suffixes != NULL && (l = suffixes->depends_on) != NULL)
  /* Reverse the suffix list, calculating the length of a character buffer */
  /* needed to hold a space-separated list of extensions as we go.         */
  {
    q = NULL;  n = 0;
    while (l != NULL)
    {
      p = l->link;  l->link = q;  q = l;  n += strlen(l->node->name);  l = p;
    }
    suffixes->depends_on = q;
    /* Allocate a buffer to hold the space-separated list of extensions    */
    /* and fill it up with extensions from the list of extension nodes.    */
    suffix_list = malloc(n + 1);
    n = 0;
    while (q != NULL)
    { strcpy(suffix_list+n, q->node->name+1);       /* don't copy the '.'s */
      n += strlen(suffix_list+n);
      suffix_list[n++] = ' ';
      q = q->link;
    }
    suffix_list[n-1] = 0;
  }
}

static int dir_match(dir, file)
char *dir, *file;
{
  while (*dir) {
    if (safe_tolower(*dir++) != safe_tolower(*file++)) return 0;
  }
  return (*file == dir_sep);
}

static void get_time_stamps_in(char *dir, bool vpath)
{
  Node *node;
  char *file;
  TimeStamp ts;
  Link *l;

  amu_debug(DEBUGGING5, "get_time_stamps_in: dir='%s', vpath=%d", dir?dir:"<<NULL>>", vpath);

  for (node = get_node_list();  node != NULL;  node = node->next) {
    if (node->flags & (HAS_TIMESTAMP | IS_COLONCOLON)) continue;
    file = node->name;
    if (dir == NULL || vpath || dir_match(dir, file)) {
      node->time = ts = get_filestamp(file, vpath);
      if (ts == 0) {
        if (vpath == false) {
          amu_err_report("failed to read time stamp for '%s'", file);
          ++nerrors;
        }
      }
      else if (ts != FILESTAMP_NEVER) {
        node->flags |= HAS_TIMESTAMP;
        if (vpath && strcmp(file, vpathbuf) != 0)
          node->name = strcpy(malloc(strlen(vpathbuf)+1), vpathbuf);
        if (node->flags & HAS_CLONES)
          for (l = node->depends_on;  l != NULL;  l = l->link)
            l->node->time = ts;
      }
      if (nerrors > ERRORLIMIT) break;
    }
  }
}

static void get_time_stamps(void)
{
  DirList *dl;
  VpathList *vp;

  /* Getting time stamps is more efficient if all references to the same */
  /* directory are bunched. Ergo, we do an inefficient sort on the fly.  */
  nerrors = 0;

  for (dl = dirs; dl && nerrors <= ERRORLIMIT; dl = dl->next) {
    get_time_stamps_in(*dl->txt ? dl->txt : NULL, false);
  }

  for (vp = vpaths; vp && nerrors <= ERRORLIMIT;  vp = vp->next) {
    get_time_stamps_in(vp->txt, true);
  }
}

static void handle_escape(int signo)
{
  signal(signo, SIG_IGN);
  exit(EXIT_FAILURE);
}

static void initialise(void)
{
  signal(SIGINT, handle_escape);
  (void) host_init();
  err_init(amu);
  amu_flags = 0;
  nerrors = 0;
  dirs = NULL;
  vpaths = NULL;
  now = filestamp_now();
  if (now == FILESTAMP_NEVER) amu_err_fail("can't read the current time");
  suffixes = default_rule = init_rule = failed_rule = done_rule = NULL;
  suffix_list = fname_suffixes;
  ebuf = NULL;
  parse_initialise();
}

static void check_version(char *v)
{
#ifdef Module_Version
  char *eptr;
  unsigned long version;
  version = strtoul(v, &eptr, 10);
  if (*eptr != '\0') amu_err_report("Invalid version specifier");
  if (version > Module_Version) {
          int major = (int) version / 100;
          int minor = (int) version % 100;
          amu_err_fail("This is %s version %s, code requires version %d.%02d or later",
            amu, Module_MajorVersion, major, minor);
  }
#else
  (void) v;
#endif
}

static void give_help()
{
  fprintf(stderr, "\n%s vsn %s [%s] - a 'make' utility\n\n"
    "%s  [options] [target1 target2...]\n"
    "\n"
    "Options:-\n"
    "-e Environment variables override macro definitions in the Makefile\n"
    "-E Macro definitions in the Makefile override definitions on the command-line\n"
    "   or in the environment (when -e is also specified)\n"
    "-f makefile\n"
    "   (makefile defaults to 'Makefile' if omitted).\n"
    "-i Ignore return codes from commands (equivalent to .IGNORE).\n"
    "-k On encountering a bad return code, don't give up, but continue with\n"
    "   each branch of the makefile that doesn't depend on the failing command.\n"
    "-n Don't execute any commands - just show what commands would be executed,\n"
    "   giving a reason for wanting to execute each one.\n"
    "-D Show on the screen the reasons for executing commands as they are executed.\n"
    "-o commandfile\n"
    "   Don't execute commands to make the target[s] up to date - write them to\n"
    "   commandfile for later execution (*EXEC or *OBEY commandfile).\n"
    "-s Don't echo commands to be executed (equivalent to .SILENT).\n"
    "-t Generate commands to make target[s] up to date by setting source\n"
    "   time-stamps consistently (only guaranteed to succeed if all sources\n"
    "   exist). The '%s' command is used to set time stamps.\n"
    "\n"
    "target1 target2 ...\n"
    "   A list of targets to be made or macro pre-definitions of the form\n"
    "   name=string. Targets are made in the order given. If no targets are\n"
    "   given, the first target found in makefile is used.\n"
    "\nExamples:-\n"
    "   %s ucc CC=cc31B     %s Link=Lnk650Exp     %s install\n",
      amu,
      VERSION,
      DATE,
      amu,
      TOUCH_E_CMD,
      amu,
      amu,
      amu);
  exit(0);
}

int main(argc, argv)
int argc;
char *argv[];
{
  char *in_file  = "Makefile",
       *out_file = NULL;
  char *arg, *s;
  int j;
  char buf[NAMELEN];
  TargetList *targets = NULL;
  TargetList **tail_target = &targets;

  initialise();

  /* Force output of commands to file under Brazil */
  if (_kernel_hostos() != _kernel_ARTHUR) out_file = "!Make";

  for (j = 1;  j < argc;  ++j)
  { arg = argv[j];
    if (hash_cistrcmp("-help", arg) == 0 || hash_cistrcmp("-h", arg) == 0)
      give_help();
  }

  for (j = 1;  j < argc;  ++j)
  { arg = argv[j];
    if (*arg == '-')
    {
      if (arg[1] == 'D')
      {
        amu_flags |= STATE_REASONS;
      }
      else if (arg[1] == 'E')
      {
        /* Emulate amu 5.00 macro precedences */
        parse_reinstate_amu_5_00_org_rank();
      }
      else if (arg[1] == 'I')
      {
        char *path;
        if (arg[2]) {
          path = &arg[2];
        }
        else {
          ++j;
          path = argv[j];
          if (j >= argc) {
            amu_err_fail("missing argument to %s option", arg);
          }
        }
        add_include_path(path);
      }
      else
      switch (safe_tolower(arg[1]))
      {
case 'a':
          if (hash_cistrcmp("muversion", arg+2) == 0) {
            ++j;
            if (j < argc)
              check_version(argv[j]);
            else
              amu_err_fail("missing argument to %s option", arg);
          }
          break;
case 'x':
          if (isdigit(arg[2])) {
            int new_flags = atoi(arg + 2) * DEBUGGING;
            amu_flags |= (new_flags & 0xFF000000);
          }
          else
            amu_flags += DEBUGGING;
          break;
case 'd':
          dde_prefix_used();
          break;
case 'e':
          amu_flags |= amuflag_ENVIRONMENT_OVERRIDE;
          break;
case 'f':
          if (arg[2] == 0) {
            ++j;
            if (j < argc)
              in_file = argv[j];
            else
              amu_err_report("missing argument to %s option", arg);
          } else in_file = arg+2;
          break;
case 'i':
          amu_flags |= IGNORE_RC;
          break;
case 'k':
          amu_flags |= CONTINUE;
          break;
case 'n':
          amu_flags |= NO_ACTION | STATE_REASONS;
          break;
case 'o':
          if (arg[2] == 0)
          { ++j;
            if (j < argc)
              out_file = argv[j];
            else
              amu_err_report("missing argument to %s option", arg);
          }
          else out_file = arg+2;
          break;
case 'q': amu_flags |= SILENT+NO_ACTION;
          break;
case 's':
          amu_flags |= SILENT;
          break;
case 't':
          amu_flags |= amuflag_TOUCHING;
          break;
default:  amu_err_report("unrecognised option '%s'", arg);
          break;
      }
    }
    else
    { /* filename or 'X=Y' type of argument... */
      while (isspace(*arg)) ++arg;
      s = arg;
      while (*s)
      { if (*s == '=') break;
        ++s;
      }
      if (*s)
      { /* 'X=Y' macro pre-definition */
        while (s != arg) {
          --s;
          if (!isspace(*s)) {++s;  break;}
        }
        *s++ = '\0';
        while (isspace(*s)) ++s;
        define_macro(arg, s, false, org_command_line);
      }
      else
      {
        tail_target = sl_new_append(tail_target, real_file_name(arg, buf, NAMELEN));
      }
    }
  }

  if (amu_flags & SILENT) amu_flags &= ~STATE_REASONS;

  dde_prefix_init(in_file);
  add_include_path("Makefiles:");
  push_include(in_file, true);

  s = NULL;
  if (argc > 1) s = strstr(_kernel_command_string(), argv[1]);
  if (s != NULL) define_macro("MFLAGS", s, true, org_environment);

  make_default_suffixes();
  build_graph();
  expand_vpath();
  get_time_stamps();

  if (nerrors > 0)
  { if ((NO_ACTION & amu_flags) || (out == NULL)) return 2;
    amu_err_fail("'%s' not written because of errors", out_file);
  }                                                           /* NO Return */

  if ((amu_flags & NO_ACTION) || (out_file == NULL))
    out = NULL;
  else
  { out = fopen(out_file, "w");
    if (out == NULL)
    { amu_err_report("can't create command file '%s'", out_file);
      amu_err_fail("(disk full? directory full? bad file name?)");
    }                                                         /* NO Return */
  }

  if (!targets) {
    Node *first_node = get_node_list();
    if (first_node != NULL) {
      tail_target = sl_new_append(tail_target, first_node->name);
    }
  }

  mark_phony_targets(get_node_list());
  make_suffix_list();
  j = process_graph(targets);
  md_merge(in.state.mf);
  md_delete();
  if ((amu_flags & (SILENT|NO_ACTION)) == (SILENT|NO_ACTION)) return j;

  if (out != NULL)
  { if (ferror(out) || fclose(out) != 0)
    { amu_err_report("error writing or closing command file '%s'", out_file);
      amu_err_fail("(disk full? map full? map too fragmented?)");
    }                                                         /* NO Return */

    if (amu_flags & state_CMDS_OUTPUT)
    { if (_kernel_hostos() == _kernel_ARTHUR)
      {
fprintf(stderr, "\n*** Don't forget to *OBEY or *EXEC '%s' ***\n\n", out_file);
      }
      else
      { /* Make a command guaranteed not to overflow buf... */
        strcpy(buf, "CHAIN:*EXEC ");
        j = strlen(buf);
        strncpy(buf+j, out_file, (NAMELEN-1)-j);
        buf[NAMELEN-1] = 0;
        /* and execute it... */
        system(buf);
      }
    }
  }

  return 0;
}
