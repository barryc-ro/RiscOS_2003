#define DEPENDANCY_FILE "!Depend"
#define COMMENT_DYNAMIC_DEPENDENCIES "# Dynamic dependencies:"

typedef struct Dependancy_File_List {
    struct Dependancy_File_List *next;
    char depend_file_contents[1];
} Dependancy_File_List;

typedef struct Target_List {
    struct Target_List *next;
    char name[1];
} Target_List;

static Dependancy_File_List *depend_list = 0;

#define OS_Word_Reason_TimeAndDate       14
#define OS_Word_SubReason_ReadRealTime    3

#define OS_File_Reason_Delete             6
#define OS_File_Reason_Load_NoPath       16
#define OS_File_Reason_ReadInfo_NoPath   17
#define OS_File_Result_FileFound          1

static unsigned md_time[2];

static int md_cistrcmp(char *s, char *t)
{
    for ( ; (*s | 0x20) == (*t | 0x20); s++, t++)
        if (!*s)
            return 0;
    return 1;
}

static int md_find_comment(char *s, char *text, char **ac)
{
    int l;
    char c;
    char *lp, *line;

    l = strlen(s);
    *ac = 0;
    while (*text) {
        if (*text == '#') {
            c = *(text + l);
            *(text + l) = 0;
            if (!md_cistrcmp(s, text)) {
                *(text + l) = c;
                while (*text && *text++ != '\n');
                *ac = text;
                return 1;
            }
            *(text + l) = c;
            while (*text && *text++ != '\n');
            while (*text == '\n') text++;
            lp = text;
            while (1) {
                line = lp;
                if (!*lp) {
                    *ac = text;
                    return 0;
                }
                if (*lp == '#') {
                    text = line;
                    break;
                }
                while ((c = *lp) != 0 && c != ':' && !isspace(c)) lp++;
                if (c != ':' || lp == line) {
                    while (*lp && *lp++ != '\n');
                    text = lp;
                    break;
                }
                lp++;
                while (isspace(*lp) && *lp != '\n') lp++;
                line = lp;
                while (*lp && !isspace(*lp)) lp++;
                if (line == lp || *lp++ != '\n') {
                    while (*lp && *lp++ != '\n');
                    text = lp;
                    break;
                }
            }
        } else
            while (*text && *text++ != '\n');
    }
    return 0;
}

static void md_start_cmd(void)
{
    md_time[0] = OS_Word_SubReason_ReadRealTime;
    _kernel_osword(OS_Word_Reason_TimeAndDate, (int *)md_time);
}

static void md_delete(void)
{
    _kernel_osfile_block b;

    _kernel_osfile(OS_File_Reason_Delete, DEPENDANCY_FILE, &b);
}

static void md_end_cmd(void)
{
  _kernel_osfile_block b;
  unsigned t;
  Dependancy_File_List *depend_file, *old_depend_file;
  int r0;
  char *s, *cs, *target, *ds;
  int d, f, c;

  r0 = _kernel_osfile(OS_File_Reason_ReadInfo_NoPath, DEPENDANCY_FILE, &b);
  if (r0 == OS_File_Result_FileFound && (b.load | 0xfffff) == -1) {
    t = b.load & 0xff;
    if (t > md_time[1] || (t == md_time[1] && b.exec >= md_time[0])) {
      depend_file = malloc(sizeof(Dependancy_File_List) + b.start);
      if (!depend_file) err_fail("out of memory");
      b.load = (int)depend_file->depend_file_contents;
      b.exec = 0;
      r0 = _kernel_osfile(OS_File_Reason_Load_NoPath, DEPENDANCY_FILE, &b);
      if (r0 != OS_File_Result_FileFound)
          err_fail("Unable to read dependancy file %s", DEPENDANCY_FILE);
      depend_file->depend_file_contents[b.start] = 0;
      s = depend_file->depend_file_contents;
      d = f = 0;
      while (1) {
          while (isspace(*s)) s++;
          if (!*s) break;
          target = s;
          while ((c = *s) != 0 && c != ':' && !isspace(c)) s++;
          if (s == target || c != ':') {
              f = 0;
              break;
          }
          s++;
          while (isspace(*s) && *s != '\n') s++;
          cs = s;
          while (*s && !isspace(*s)) s++;
          if (cs == s) {
              d -= s - target + 1;
              f = 1;
          } else {
              while (*s && *s != '\n') {
                  while (isspace(*s) && *s != '\n') s++;
                  if (*s && !isspace(*s)) {
                      d += cs - target + 1;
                      f = 1;
                      while (*s && !isspace(*s)) s++;
                  }
              }
          }
      }
      if (f) {
          old_depend_file = depend_file;
          b.start += d;
          depend_file = malloc(sizeof(Dependancy_File_List) + b.start);
          if (!depend_file) err_fail("out of memory");
          s = old_depend_file->depend_file_contents;
          ds = depend_file->depend_file_contents;
          while (1) {
              while (isspace(*s)) s++;
              if (!*s) {
                  *ds = 0;
                  break;
              }
              target = s;
              while ((c = *s) != 0 && c != ':' && !isspace(c)) s++;
              s++;
              while (isspace(*s) && *s != '\n') s++;
              cs = s;
              while (*s && !isspace(*s)) s++;
              if (cs != s) {
                  memcpy(ds, target, s - target);
                  ds += s - target;
                  *ds++ = '\n';
                  while (*s && *s != '\n') {
                      while (isspace(*s) && *s != '\n') s++;
                      if (*s && !isspace(*s)) {
                          memcpy(ds, target, cs - target);
                          ds += cs - target;
                          while (*s && !isspace(*s))
                              *ds++ = *s++;
                          *ds++ = '\n';
                      }
                  }
              }
          }
          free(old_depend_file);
      }
      depend_file->next = depend_list;
      depend_list = depend_file;
    }
  }
}

static void md_merge(void)
{
    Dependancy_File_List *dl;
    Target_List *tl, *nt;
    char *target, *fcp, *s, *ac;
    char c;
    FILE *f;
    int acflag;
    long size;

    if (depend_list) {
        dl = depend_list;
        tl = 0;
        do {
            fcp = dl->depend_file_contents;
            while (1) {
                while (isspace(*fcp)) fcp++;
                if (!*fcp) break;
                target = fcp;
                while ((c = *fcp) != 0 && c != ':' && !isspace(c)) fcp++;
                if (fcp == target) err_fail("null target in !Depend");
                if (c != ':') err_fail("':' expected after target in !Depend");
                *fcp = 0;
                nt = tl;
                while (nt) {
                    if (!md_cistrcmp(target, nt->name))
                        break;
                    nt = nt->next;
                }
                if (!nt) {
                    nt = malloc(sizeof(Target_List) + (fcp - target));
                    if (!nt) err_fail("out of memory");
                    strcpy(nt->name, target);
                    nt->next = tl;
                    tl = nt;
                }
                *fcp++ = c;
                while (*fcp && *fcp != '\n') fcp++;
            }
            dl = dl->next;
        } while (dl);
        acflag = md_find_comment(COMMENT_DYNAMIC_DEPENDENCIES, makefile, &ac);
        if (ac) {
            fcp = ac;
            while (1) {
                while (isspace(*fcp)) fcp++;
                if (!*fcp) break;
                target = fcp;
                while ((c = *fcp) != 0 && c != ':' && !isspace(c)) fcp++;
                if (fcp == target) err_fail("null target in Makefile");
                if (c != ':')
                    err_fail("':' expected after target in Makefile");
                *fcp = 0;
                nt = tl;
                while (nt) {
                    if (!md_cistrcmp(target, nt->name))
                        break;
                    nt = nt->next;
                }
                *fcp = c;
                while (*fcp && *fcp++ != '\n');
                if (nt) {
                    s = target;
                    while (*s++ = *fcp++);
                    fcp = target;
                }
            }
        }
        f = fopen(input_file, "r+");
        if (!f) err_fail("Error opening %s for update", input_file);
        if (!ac) {
            if (fseek(f, 0, SEEK_END))
                err_fail("Error writing %s", input_file);
            fputs("\n# Dynamic dependencies:\n", f);
        } else {
            if (fseek(f, ac - makefile, SEEK_SET))
                err_fail("Error writing %s", input_file);
            if (!acflag) {
                fputs(COMMENT_DYNAMIC_DEPENDENCIES, f);
                fputc('\n', f);
            }
            fputs(ac, f);
        }
        dl = depend_list;
        do {
            fputs(dl->depend_file_contents, f);
            dl = dl->next;
        } while (dl);
        size = ftell(f);
        if (fclose(f) || size < 0)
            err_fail("Error writing %s", input_file);
        wf_truncate(input_file, size);
    }
}
