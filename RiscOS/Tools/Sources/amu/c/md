#define DEPENDENCY_FILE "!Depend"
#define COMMENT_DYNAMIC_DEPENDENCIES "# Dynamic dependencies:"

typedef struct Dependency_File_List {
    struct Dependency_File_List *next;
    char depend_file_contents[1];
} Dependency_File_List;

typedef struct Target_List {
    struct Target_List *next;
    char name[1];
} Target_List;

static Dependency_File_List *depend_list = 0;

static TimeStamp md_time;

static int md_cistrcmp(char *s, char *t)
{
    for ( ; (*s | 0x20) == (*t | 0x20); s++, t++)
        if (!*s)
            return 0;
    return 1;
}

static int md_find_comment(char *s, char *text, char **ac)
{
    int l;
    char c;
    char *lp, *line;

    l = strlen(s);
    *ac = 0;
    while (*text) {
        if (*text == '#') {
            c = *(text + l);
            *(text + l) = 0;
            if (!md_cistrcmp(s, text)) {
                *(text + l) = c;
                while (*text && *text++ != '\n');
                *ac = text;
                return 1;
            }
            *(text + l) = c;
            while (*text && *text++ != '\n');
            while (*text == '\n') text++;
            lp = text;
            while (1) {
                line = lp;
                if (!*lp) {
                    *ac = text;
                    return 0;
                }
                if (*lp == '#') {
                    text = line;
                    break;
                }
                while ((c = *lp) != 0 && c != ':' && !isspace(c)) lp++;
                if (c != ':' || lp == line) {
                    while (*lp && *lp++ != '\n');
                    text = lp;
                    break;
                }
                lp++;
                while (isspace(*lp) && *lp != '\n') lp++;
                line = lp;
                while (*lp && !isspace(*lp)) lp++;
                if (line == lp || *lp++ != '\n') {
                    while (*lp && *lp++ != '\n');
                    text = lp;
                    break;
                }
            }
        } else
            while (*text && *text++ != '\n');
    }
    return 0;
}

static void md_start_cmd(void)
{
    md_time = filestamp_now();
}

static void md_delete(void)
{
    remove(DEPENDENCY_FILE);
}

static void md_end_cmd(void)
{
  Dependency_File_List *depend_file, *old_depend_file;
  char *s, *cs, *target, *ds;
  int d, f, c;
  TimeStamp t0;

  t0 = filestamp_get(DEPENDENCY_FILE);
  if (t0 != FILESTAMP_NEVER && t0 >= md_time) { {
      int32 size = wf_filesize(DEPENDENCY_FILE);
      depend_file = malloc(sizeof(Dependency_File_List) + (size_t)size + 1);
      if (!depend_file) err_fail("out of memory");
      if (wf_load(DEPENDENCY_FILE, depend_file->depend_file_contents, size)<0)
        err_fail("unable to read dependency file " DEPENDENCY_FILE);
      depend_file->depend_file_contents[size] = 0;
      s = depend_file->depend_file_contents;
      d = f = 0;
      while (1) {
          while (isspace(*s)) s++;
          if (!*s) break;
          target = s;
          while ((c = *s) != 0 && c != ':' && !isspace(c)) s++;
          if (s == target || c != ':') {
              f = 0;
              break;
          }
          s++;
          while (isspace(*s) && *s != '\n') s++;
          cs = s;
          while (*s && !isspace(*s)) s++;
          if (cs == s) {
              d -= s - target + 1;
              f = 1;
          } else {
              while (*s && *s != '\n') {
                  while (isspace(*s) && *s != '\n') s++;
                  if (*s && !isspace(*s)) {
                      d += cs - target + 1;
                      f = 1;
                      while (*s && !isspace(*s)) s++;
                  }
              }
          }
      }
      if (f) {
          old_depend_file = depend_file;
          size += d;
          depend_file = malloc(sizeof(Dependency_File_List) + (size_t)size);
          if (!depend_file) err_fail("out of memory");
          s = old_depend_file->depend_file_contents;
          ds = depend_file->depend_file_contents;
          while (1) {
              while (isspace(*s)) s++;
              if (!*s) {
                  *ds = 0;
                  break;
              }
              target = s;
              while ((c = *s) != 0 && c != ':' && !isspace(c)) s++;
              s++;
              while (isspace(*s) && *s != '\n') s++;
              cs = s;
              while (*s && !isspace(*s)) s++;
              if (cs != s) {
                  memcpy(ds, target, s - target);
                  ds += s - target;
                  *ds++ = '\n';
                  while (*s && *s != '\n') {
                      while (isspace(*s) && *s != '\n') s++;
                      if (*s && !isspace(*s)) {
                          memcpy(ds, target, cs - target);
                          ds += cs - target;
                          while (*s && !isspace(*s))
                              *ds++ = *s++;
                          *ds++ = '\n';
                      }
                  }
              }
          }
          free(old_depend_file);
      }
      depend_file->next = depend_list;
      depend_list = depend_file;
    }
  }
}

/* An aesthetic improvement (IMHO).  Join all the lines for the same
 * target dependency so you get one-line per target, instead of (potentially)
 * hundreds.
 */
static void md_flatten(char *p)
{
  char *tgt = p;
  size_t tgt_len, total = strlen(p) + 1;
  char *d = p;

  /* First of all, find the target name.  Need to find a colon followed by
   * whitespace (because it could be a fully-qualified RISC OS pathname)
   */
  for (;;) {
    p = strchr(d, ':');
    if (!p) return;
    if (isspace(p[1])) break;
    d=p+1;
  }

  tgt_len = p - tgt;

  /* Now look for EOL characters and just shift the entire remaining buffer
   * up to concatenate the lines.  Not the greatest of algorithms, but it
   * is good enough for the task in hand.
   */
  while (*p) {
    /* Find EOL */
    while (*p && *p++ != '\n') ;;
    d = p - 1;
    /* Last dependency?  Finished */
    if (!*p) break;
    /* Paranoia check: target name still matches? (should never not match!) */
    if (strncmp(p, tgt, tgt_len) != 0) break;
    p += tgt_len;
    /* More paranoia */
    if (*p++ != ':') break;
    while (*p && isspace(*p)) p++;
    /* Blat the EOL with a space, then shift the buffer up */
    *d++ = ' ';
    memmove(d, p, total - (p - tgt));
    /* Start next search with the first dependency we just moved */
    p = d;
  }
  /* I hate TABs in Makefiles which aren't indicative of commands ... */
  while ((tgt = strchr(tgt, '\t')) != NULL) *tgt++ = ' ';
}

static void md_merge(void)
{
    Dependency_File_List *dl;
    Target_List *tl, *nt;
    char *target, *fcp, *s, *ac;
    char c;
    FILE *f;
    int acflag;
    long size;

    if (depend_list) {
        dl = depend_list;
        tl = 0;
        do {
            fcp = dl->depend_file_contents;
            while (1) {
                while (isspace(*fcp)) fcp++;
                if (!*fcp) break;
                target = fcp;
                while ((c = *fcp) != 0 && c != ':' && !isspace(c)) fcp++;
                if (fcp == target) err_fail("null target in " DEPENDENCY_FILE);
                if (c != ':') err_fail("':' expected after target in " DEPENDENCY_FILE);
                *fcp = 0;
                nt = tl;
                while (nt) {
                    if (!md_cistrcmp(target, nt->name))
                        break;
                    nt = nt->next;
                }
                if (!nt) {
                    nt = malloc(sizeof(Target_List) + (fcp - target));
                    if (!nt) err_fail("out of memory");
                    strcpy(nt->name, target);
                    nt->next = tl;
                    tl = nt;
                }
                *fcp++ = c;
                while (*fcp && *fcp != '\n') fcp++;
            }
            dl = dl->next;
        } while (dl);
        acflag = md_find_comment(COMMENT_DYNAMIC_DEPENDENCIES, makefile, &ac);
        if (ac) {
            fcp = ac;
            while (1) {
                while (isspace(*fcp)) fcp++;
                if (!*fcp) break;
                target = fcp;
                while ((c = *fcp) != 0 && c != ':' && !isspace(c)) fcp++;
                if (fcp == target) err_fail("null target in Makefile");
                if (c != ':')
                    err_fail("':' expected after target in Makefile");
                *fcp = 0;
                nt = tl;
                while (nt) {
                    if (!md_cistrcmp(target, nt->name))
                        break;
                    nt = nt->next;
                }
                *fcp = c;
                while (*fcp && *fcp++ != '\n');
                if (nt) {
                    s = target;
                    while ((*s++ = *fcp++) != 0);
                    fcp = target;
                }
            }
        }
        if (wf_filesize(input_file) != (in->file[0].eof - in->file[0].data))
        {
          err_report("%s has been edited since %s was invoked!  "
                     "Ignoring dynamic dependency file.", input_file,
            amu);
          return;
        }
        f = fopen(input_file, "r+");
        if (!f) err_fail("Error opening %s for update", input_file);
        if (!ac) {
            if (fseek(f, 0, SEEK_END))
                err_fail("Error writing %s", input_file);
            fputs("\n" COMMENT_DYNAMIC_DEPENDENCIES "\n", f);
        } else {
            if (fseek(f, ac - makefile, SEEK_SET))
                err_fail("Error writing %s", input_file);
            if (!acflag) {
                fputs(COMMENT_DYNAMIC_DEPENDENCIES, f);
                fputc('\n', f);
            }
            fputs(ac, f);
        }
        dl = depend_list;
        do {
            md_flatten(dl->depend_file_contents);
            fputs(dl->depend_file_contents, f);
            dl = dl->next;
        } while (dl);
        size = ftell(f);
        if (fclose(f) || size < 0)
            err_fail("Error writing %s", input_file);
        wf_truncate(input_file, size);
    }
}
