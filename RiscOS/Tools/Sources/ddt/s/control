r0              RN      0
r1              RN      1
r2              RN      2
r3              RN      3
r4              RN      4
r5              RN      5
r6              RN      6
r7              RN      7
r8              RN      8
r9              RN      9
r10             RN      10
r11             RN      11
r12             RN      12
r13             RN      13
r14             RN      14
r15             RN      15

sl              RN      10
fp              RN      11
ip              RN      12
sp              RN      13

lr              RN      14
pc              RN      15

f0              FN      0
f1              FN      1
f2              FN      2
f3              FN      3
f4              FN      4
f5              FN      5
f6              FN      6
f7              FN      7

c0		CN	0
c5		CN	5
c7		CN	7
c10		CN	10

cp15		CP	15

                GET     s.defs

;                EXPORT  fpavailable
                EXPORT  registers
                EXPORT  regs_r14
                EXPORT  exit_swi
                EXPORT  cont
                EXPORT  dataaccessflag
                EXPORT  debugger_exit
                EXPORT  claim_swiv
                EXPORT  release_swiv
                EXPORT  poll_intercept_flag
                EXPORT  claim_dbgr_vectors
                EXPORT  release_dbgr_vectors
                EXPORT  irq_abort
                EXPORT  retfromcall
                EXPORT  prot_list
                EXPORT  unprot_list
                EXPORT  memory_protection
                EXPORT  svc_break_handler
                EXPORT  stepflag
                EXPORT  in_debuggee
                EXPORT  cmd_cli
                EXPORT  event_break_mask
                EXPORT  end_debug
                EXPORT  exception
                EXPORT  swap_in_handlers
                EXPORT  swap_out_handlers
                EXPORT  swap_dbge_handlers
                EXPORT  restore_mouse
                EXPORT  upcall_intercept_media
                EXPORT  user_sp
                EXPORT  user_lr

                IMPORT  window_closedown
                IMPORT  heap_discard
                IMPORT  error_buffer
                IMPORT  debugtask
                IMPORT  reset_dbgflag
                IMPORT  window_cleanup
                IMPORT  single_step
                IMPORT  abort_flag
                IMPORT  ss_proc_pc
                IMPORT  clear_breakpoints
                IMPORT  save_core
                IMPORT  rest_core
                IMPORT  bindings
                IMPORT  breaklist
                IMPORT  missing_media

o_user_sp       EQU     16 * 4 + 8 * 12 + 4
o_user_lr       EQU     o_user_sp + 4

IRQ26_Mode      *       2
I32Bit          *       1 :SHL: 7
F32Bit          *       1 :SHL: 6
IF32_26Shift    *       (26 - 6)


zp_wimpdomain   EQU     &ff8

exception_error EQU     &843

n_module_claim  EQU     6
n_module_free   EQU     7
n_module_lookup EQU     18

os_breakpt      EQU     &17

overflow        EQU     &10000000
xbit            EQU     &20000

wimp_swibase_h  EQU     &40000
wimp_poll_l     EQU     &c7
wimp_pollidle_l EQU     &e1

ddt_swibase_h   EQU  &41d00
ddt_swibase_l   EQU  &40

ddt_swi_debugaif      EQU 0
ddt_swi_beingdebugged EQU 1
ddt_swi_startdebug    EQU 2
ddt_swi_enddebug      EQU 3

xos_writec      EQU     &20000
xos_writes      EQU     &20001
xos_write0      EQU     &20002
xos_newline     EQU     &20003
xos_readc       EQU     &04
xos_word        EQU     &20007
xos_find        EQU     &2000d
xos_module      EQU     &2001e
xos_changeenvironment EQU &20040
xos_synchronisecodeareas EQU &2006e
os_callaswi	EQU	&6f
os_callaswir12	EQU	&71
xos_converthex8 EQU     &200d4
xos_writei      EQU     &20100
xdebugger_disassemble EQU &60380

os_exit         EQU     &11
os_writes       EQU     1
os_write0       EQU     2
os_generateerror EQU    &2b
os_converthex8   EQU    &d4
os_setmemmapentries EQU &53
os_cli          EQU     5

; Vector numbers
n_error_vector  EQU     &01
n_irq_vector    EQU     &02
n_word_vector   EQU     &07
n_find_vector   EQU     &0d
n_ins_vector    EQU     &14
n_upcall_vector EQU     &1d
n_changeenv_vector EQU  &1e

os_claim        EQU     &1f
os_release      EQU     &20
os_releaseswiv  EQU     &ff

n_kbd_buffer    EQU     0

os_enteros      EQU     &16
xos_upcall      EQU     &20033

os_writei       EQU     &100
os_newline      EQU     &03
os_byte         EQU     &06
os_word         EQU     &07
os_spriteop     EQU     &2e
os_readpalette  EQU     &2f
os_readpoint    EQU     &32
os_callavector  EQU     &34
os_prettyprint  EQU     &44
os_plot         EQU     &45
os_writen       EQU     &46

os_readc        EQU     &04

n_shift_f11     EQU     &db

; Reason code for stopping execution
n_undef_inst     EQU    1
n_prefetch_abort EQU    2
n_data_abort     EQU    3
n_address_ex     EQU    4
n_error          EQU    5
n_exit           EQU    6
n_exit_abex      EQU    7
n_hit_break      EQU    8
n_watch_changed  EQU    9
n_step_count     EQU    10
n_resume         EQU    11
n_shiftf12       EQU    12
n_retfromcall    EQU    13
n_lostwatch      EQU    14
n_enddebug       EQU    15
n_break_event    EQU    16
n_swi_break      EQU    17

n_memlimit_handler EQU  0
n_undef_handler    EQU  1
n_prefetch_handler EQU  2
n_abort_handler    EQU  3
n_address_handler  EQU  4
n_other_handler    EQU  5
n_error_handler    EQU  6
n_break_handler    EQU  8
n_exit_handler     EQU  11
n_upcall_handler   EQU  16

o_err_pc        EQU     0
o_err_errno     EQU     4
o_err_str       EQU     8

o_swinext       EQU     0
o_swino         EQU     4
o_swiaddr       EQU     8       ; 0 if this is a SWI breakpoint

                AREA    |C$$code|, CODE, READONLY

upcall_error    SWI     os_enteros
                BL      upcall_end
                TEQP    pc, #0
                LDR     r0, upcall_err_buff
                ADD     r0, r0, #4
                SWI     os_generateerror

upcall_exit     SWI     os_enteros
                BL      upcall_end
                TEQP    pc, #0
                SWI     os_exit

upcall_intercept
                CMP     r0, #n_upcall_newapp
                MOVNES  pc, lr
                STMDB   sp!, {r0, r1, r2, r3, lr}
                MOV     r3, #0
                LDR     r3, [r3, #zp_wimpdomain]
                CMP     r12, r3
                LDREQ   r0, in_subapp
                CMPEQ   r0, #0
                LDMNEIA sp!, {r0, r1, r2, r3, pc}^
                MOV     r0, #1
                STR     r0, in_subapp
                BL      swap_upcall_handlers
                BL      unprotmem
                LDMIA   sp!, {r0, r1, r2, r3, pc}^

upcall_end      STMDB   sp!, {r0, r1, r2, r3, lr}
                MOV     r0, #0
                STR     r0, in_subapp
                BL      swap_upcall_handlers
                BL      protmem
                LDMIA   sp!, {r0, r1, r2, r3, pc}^

n_upcall_handlers EQU   2

upcall_handlers DCD     n_error_handler, upcall_error, 0
upcall_err_buff DCD     0
                DCD     n_exit_handler, upcall_exit, 0, 0

dbgr_handlers   DCD     0                ; UpCall
                DCD     0                ; CAO
                DCD     0                ; Application space
                DCD     0                ; Exception regs
                DCD     0                ; Unused SWI
                DCD     exit_handler     ; Exit
                DCD     0                ; Event
                DCD     0                ; Escape
                DCD     0                ; BreakPoint
                DCD     0                ; CallBack
                DCD     my_error_handler ; Error
                DCD     0                ; Other exceptions
                DCD     address_handler  ; Address exception
                DCD     abort_handler    ; Data abort
                DCD     prefetch_handler ; Prefetch abort
                DCD     undef_handler    ; Undefined ins.
                DCD     0                ; MemoryLimit

old_dbgr_handlers
                %       3 * 4 * 17

n_dbge_handlers EQU     3

dbge_handlers   DCD     n_error_handler, error_handler, 0, error_buffer
                DCD     n_abort_handler, 0, 0, 0
                DCD     n_address_handler, 0, 0, 0

debugger_exit   BL      clear_breakpoints
                BL      heap_discard
                BL      reset_dbgflag
                SWI     os_exit

my_error_handler
                [ ERROR_BACKTRACE
                STR     r0, regs_r0
                ADRL    r0, regs_r1
                STMIA   r0, {r1-r14}
                MOV     r0, #n_error_handler
                MOV     r1, #0
                MOV     r2, #0
                MOV     r3, #0
                SWI     xos_changeenvironment
                LDR     r1, [r3, #o_err_pc]
                STR     r1, regs_r15
                ADD     r0, r3, #8
                ADRL    r12, registers
                B       exception
                |
                BL      window_closedown
                BL      window_cleanup
                BL      swap_out_handlers
                BL      release_dbgr_vectors
                BL      heap_discard
                BL      reset_dbgflag
                MOV     r0, #n_error_handler
                MOV     r1, #0
                MOV     r2, #0
                MOV     r3, #0
                SWI     xos_changeenvironment
                ADD     r0, r3, #4
                SWI     os_generateerror
                ]

swap_in_handlers
                STMDB   sp!, {r4, r5, r6, lr}
                MOV     r6, #n_upcall_handler
                ADR     r5, dbgr_handlers
                ADR     r4, old_dbgr_handlers
swap_in_handlers1
                MOV     r0, r6
                LDR     r1, [r5], #4
                MOV     r2, #0
                MOV     r3, #0
                SWI     xos_changeenvironment
                STMVCIA r4, {r1, r2, r3}
                ADD     r4, r4, #12
                SUBS    r6, r6, #1
                BPL     swap_in_handlers1
                LDMIA   sp!, {r4, r5, r6, pc}^

swap_out_handlers
                STMDB   sp!, {r4, r5, lr}
                MOV     r5, #n_upcall_handler
                ADR     r4, old_dbgr_handlers
swap_out_handlers1
                MOV     r0, r5
                LDMIA   r4!, {r1, r2, r3}
                SWI     xos_changeenvironment
                SUBS    r5, r5, #1
                BPL     swap_out_handlers1
                LDMIA   sp!, {r4, r5, pc}^

swap_dbge_handlers
                STMDB   sp!, {r0, r1, r5, lr}
                ADR     ip, dbge_handlers
                MOV     r5, #n_dbge_handlers
swap_dbge_h1    LDMIA   ip, {r0, r1, r2, r3}
                SWI     xos_changeenvironment
                STMIA   ip!, {r0, r1, r2, r3}
                SUBS    r5, r5, #1
                BNE     swap_dbge_h1
                LDMIA   sp!, {r0, r1, r5, pc}^

swap_upcall_handlers
                STMDB   sp!, {r5, lr}
                ADR     ip, upcall_handlers
                MOV     r5, #n_upcall_handlers
swap_upcall1    LDMIA   ip, {r0, r1, r2, r3}
                SWI     xos_changeenvironment
                STMIA   ip!, {r0, r1, r2, r3}
                SUBS    r5, r5, #1
                BNE     swap_upcall1
                LDMIA   sp!, {r5, pc}^

in_subapp       DCD     0


; R0, bit 0 = 1 => single step
; R0, bit 30 = 1 => step into procedures
; R0, bit 31 = 1 => step by source statement
; R1 = step count
cont            STMDB   sp!, {r4 - r9, lr}
;                LDR     r2, fpavailable
;                CMP     r2, #0
;                BEQ     cont1
                SFMFD   f4, 4, [sp]!
                RFS     r2
                STR     r2, [sp, #-4]!
                LDR     r2, fp_status
                WFS     r2
                LDFE    f0, fp_r0
                LDFE    f1, fp_r1
                LDFE    f2, fp_r2
                LDFE    f3, fp_r3
                LDFE    f4, fp_r4
                LDFE    f5, fp_r5
                LDFE    f6, fp_r6
                LDFE    f7, fp_r7
cont1           BL      swap_dbge_handlers
                MOV     r2, #0
                STR     r2, poll_intercept_flag
                ADRL    r3, ss_proc_pc
                STR     r2, [r3]
                LDR     r2, [r2, #zp_wimpdomain]
                STR     r2, [sp, #-4]!
                STR     r2, wimp_domain
                STMDB   sp!, {fp, sl}
                STR     sp, savesp
                MOV     r4, r1
                MOV     r11, r0, LSL #28
                MOV     r0, #n_upcall_vector
                ADR     r1, upcall_intercept
                SWI     os_claim
; MEDUSA - Don't claim IRQV directly as this doesn't work on medusa
;          This means SHIFT-F12 will not work fully.
;          IDJ: 4-Oct-94: decision reversed! Having ShiftF12 working
;          is vital - side effect is AUN networking is buggered.
;          Bug-fix AQU-00122
;          IDJ: 7-Oct-94: commented back out for Medusa!
;          IDJ/NK: 4-Jan-95: claim irqv again (this time dealing with 32-bit world!)
                BL      claim_irqv
                MOV     r2, #1
                STR     r2, stepflag
                STR     r2, cout_intercept_flag
                STR     r2, in_debuggee
                BL      protmem
                ADR     r12, registers
; Now go into SVC mode if the debuggee is in SVC mode but before doing
; so load r13 & r14 with potential values. If the debuggee is indeed in SVC
; mode these will be the correct values. If not they will be overwritten in
; any case when the full regset is loaded.
                LDR     r13, [r12, #o_user_sp]
                LDR     r14, [r12, #o_user_lr]
                SWI     os_enteros
                LDR     lr, [r12, #15 * 4]
                BIC     r0, lr, #&fc000003
                STR     r0, exec_addr
                TEQP    pc, lr
                ANDS    r1, r11, #&20000000
                BNE     cont_suspend
                ANDS    r1, r11, #&10000000
                BNE     cont_ss
                LDR     r10, [r12, #15 * 4]
                BIC     r10, r10, #&fc000003
                LDR     r0, [r10]
                AND     r0, r0, #&0f000000
                CMP     r0, #&0a000000
                BNE     cont2
                MOV     r4, #1
                MOV     r11, #&40000000
                BL      single_step
cont2           MOV     r0, #0
                STR     r0, stepflag
                ADR     r12, registers
                LDMIA   r12, {r0 - r15}^

cont_ss         BL      single_step
                B       retfromexec

in_debuggee     DCD     0
dataaccessflag  DCD     0

n_upcall_newapp EQU     256

fpename         DCB     "FPEmulator", 0
                ALIGN

checkdataaccess LDR     r0, in_debuggee
                CMP     r0, #0
                MOVNES  pc, lr
; Not in debuggee, could be a fault in the debugger or a fault because the
; debugger is trying to access user specified memory locations. In the latter
; case the dataaccess flag will be set (ie 0)
                LDR     r0, dataaccessflag
                CMP     r0, #0
                MOV     r0, #1          ; Set flag to indicate access failed
                STR     r0, dataaccessflag
                MOVNES  pc, lr
                LDMIA   sp!, {r0, lr}
                ADD     lr, lr, #4
                MOVS    pc, lr

abort_handler   SUB     lr, lr, #8
                STMDB   sp!, {r0, lr}
;                MOV     r0, lr
;                BL      dbg_abort
;                LDMIA   sp, {r0, lr}
                TST     lr, #3
                BL      checkdataaccess
                MOV     lr, #n_data_abort
                B       checkfpeaccess

address_handler SUB     lr, lr, #8
                STMDB   sp!, {r0, lr}
;                MOV     r0, lr
;                BL      dbg_abort
;                LDMIA   sp, {r0, lr}
                TST     lr, #3
                BL      checkdataaccess
                MOV     lr, #n_address_ex

; Data abort or address exception - Could be inside FPE in which case we need
; to recover the user registers from the SVC stack where they have been stored
; by the FPE.
;
checkfpeaccess  LDR     r0, [sp], #4
                BEQ     save_ex_regs       ; User mode so not FPE
; Find FPE module
                STMDB   sp!, {r0-r5, lr}
                MOV     r0, #n_module_lookup
                ADR     r1, fpename
                SWI     xos_module
                LDMVSIA sp!, {r0-r5, lr}
                BVS     save_ex_regs
; R3 = start of FPE code, [r3, #-4] = length of FPE code
                LDR     r0, [sp, #7 * 4]
                BIC     r0, r0, #&fc000003
                CMP     r0, r3
                LDRCS   r4, [r3, #-4]
                ADDCS   r3, r3, r4
                CMPCS   r3, r0
                LDMIA   sp!, {r0-r5, lr}
                ADDCS   sp, sp, #4      ; Data abort inside FPE, drop FPE lr
                BCS     save_ex_regs1   ; Reg set already saved on SVC stack

save_ex_regs    SUB     sp, sp, #15*4   ; Can't writeback and force user bank
                STMIA   sp, {r0-r14}^   ; All user regs -> SVC stack
save_ex_regs1   ADR     r11, registers
                LDR     r0, stepflag
                CMP     r0, #0
                LDMIA   sp!, {r0-r7}
                STMEQIA r11!, {r0-r7}
                LDMIA   sp!, {r0-r7}
                STMEQIA r11!, {r0-r7}
                ORRNE   r0, r3, r4      ; Single step leave pc in r11 & r12
                STRNE   r0, [r11, #15 * 4]
                ADRL    r0, ss_proc_pc
                LDR     r0, [r0]
                CMP     r0, #0
                STRNE   r0, [r11, #15 * 4]
                LDR     r0, in_debuggee
                CMP     r0, #0
                MOVNE   r0, lr
                BNE     retfromexec
                ADR     r12, registers
                ADRL    r0, abort_msg
                B       exception

arg_guard       DCD     &41524753

retfromcall     LDR     r0, bindings
                CMP     r0, #0
                MOVNE   sp, r12
                LDR     r0, arg_guard
retfromcall0    LDR     r1, [sp], #4
                CMP     r0, r1
                BNE     retfromcall0
;                LDR     r0, fpavailable
;                CMP     r0, #0
;                BEQ     retfromcall1
                LDFE    f0, [sp], #12
                LDFE    f1, [sp], #12
                LDFE    f2, [sp], #12
                LDFE    f3, [sp], #12
retfromcall1    ADR     r12, registers
                LDMIA   sp!, {r0, r1, r2, r3}
                STMIA   r12!, {r0 - r9}
                LDMIA   sp!, {r0 - r5}
                STMIA   r12!, {r0 - r5}
                MOV     r0, #n_retfromcall
                B       retfromexec

svc_break_handler
                STR     r0, regs_r0
                ADR     r0, regs_r1
                STMIA   r0!, {r1-r13}
                LDMIA   lr, {r1, r2}
                MOV     r3, pc
                AND     r3, r3, #&fc000003
                ORR     r2, r2, r3
                STMIA   r0, {r1, r2}
                MOV     r0, #n_hit_break

retfromexec     TEQP    pc, #0
                MOV     r4, r0
                STR     sp, user_sp
                STR     lr, user_lr
                MOV     r0, #0
                STR     r0, cout_intercept_flag
                LDR     sp, savesp
                LDMIA   sp!, {fp, sl}
                MOV     r0, #n_upcall_vector
                ADRL    r1, upcall_intercept
                LDR     r2, [sp], #4
                SWI     os_release
                BL      unprotmem
; MEDUSA - See claim_irqv above
                BL      release_irqv
                MOV     r2, #1
                STR     r2, poll_intercept_flag
;                LDR     r1, fpavailable
;                CMP     r1, #0
;                BEQ     retfromexec1
                STFE    f0, fp_r0
                STFE    f1, fp_r1
                STFE    f2, fp_r2
                STFE    f3, fp_r3
                STFE    f4, fp_r4
                STFE    f5, fp_r5
                STFE    f6, fp_r6
                STFE    f7, fp_r7
                RFS     r1
                STR     r1, fp_status
                LDR     r1, [sp], #4
                WFS     r1
		LFMFD	f4, 4, [sp]!
retfromexec1    BL      swap_dbge_handlers
                MOV     r0, #0
                STR     r0, in_debuggee
                MOV     r0, r4
                CMP     r0, #n_enddebug
                BEQ     ret_to_dbge
                LDMIA   sp!, {r4 - r9, pc}^

; Error handler is entered in user mode
error_handler   STR     r0, regs_r0
                ADR     r0, regs_r1
                STMIA   r0!, {r1-r9}
                LDR     r1, stepflag
                CMP     r1, #0
                BNE     error_handler1
                STMIA   r0!, {r10-r14}
                ADRL    r2, error_buffer
                LDR     r1, [r2, #o_err_pc]
                STR     r1, regs_r15
error_handler1  MOV     r0, #n_error
                B       retfromexec

abex            DCD     &58454241

savesp          DCD     0
stepflag        DCD     0
exec_addr       DCD     0

;fpavailable     DCD     0

exit_swi        SWI     os_exit

memorylimit     DCD     0

registers
regs_r0         DCD     0
regs_r1         DCD     0
                DCD     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
regs_r14        DCD     0
regs_r15        DCD     0
fp_r0           DCD     0, 0, 0
fp_r1           DCD     0, 0, 0
fp_r2           DCD     0, 0, 0
fp_r3           DCD     0, 0, 0
fp_r4           DCD     0, 0, 0
fp_r5           DCD     0, 0, 0
fp_r6           DCD     0, 0, 0
fp_r7           DCD     0, 0, 0
fp_status       DCD     0
user_sp         DCD     0
user_lr         DCD     0

                [ 0 = 1
; Breakpoints are now done by direct branches into unique per breakpoint
; data areas to allow SVC mode breakpointing.
;
; Breakpoint handler is entered in SVC mode with registers already saved.
; just load reason code and return
break_handler   MOV     r0, #n_hit_break
                B       retfromexec
                ]

; Exit handler is entered in user mode
; Save user lr as best guess for PC, load reason code and return
exit_handler    STR     lr, regs_r14
                LDR     lr, os_exit_lr
                STR     lr, regs_r15
                ADR     r14, registers
                STMIA   r14, {r0-r13}
                MOV     r0, #n_exit
                LDR     r2, abex
                CMP     r1, r2
                MOVEQ   r0, #n_exit_abex
                B       retfromexec

old_swiv        DCD     0

; MEDUSA - new SWI intercept claim
intercept_addr  DCD     &1f033c4

; StrongARM - must be careful modifying the SWI code as we need to call
;             a SWI to synchronise it :-)
claim_swiv
		LDR	r3, intercept_addr
		ADR	r2, swi_branch
		SUB	r2, r3, r2
		SUB	r2, r2, #4
		MOV	r2, r2, LSR #2
		BIC	r2, r2, #&ff000000
		ORR	r2, r2, #&ea000000
		STR	r2, swi_branch
                [ StrongARM
		MOV	ip, lr
		MOV	r0, #1
		ADR	r1, swi_branch
		MOV	r2, r1
		SWI	xos_synchronisecodeareas
		]
		ADR	r2, swi_intercept
		SUB	r2, r2, r3
		SUB	r2, r2, #8
		MOV	r2, r2, LSR #2
		BIC	r2, r2, #&ff000000
		ORR	r2, r2, #&ea000000
		STR	r2, [r3]
		[ StrongARM
		MOV	r0, #1
		MOV	r1, r3
		MOV	r2, r3
		SWI	xos_synchronisecodeareas
		MOVS	pc, ip
		|
                MOVS    pc, lr
		]

release_swiv    MOV     r3, lr
                LDR     r14, intercept_addr
                LDR     r2, intercept_inst
                STR     r2, [r14]
		[ StrongARM
		; Can't use SynchroniseCodeAreas because it's a SWI
		; and it will probably re-enter us nastily...
		MRC	cp15, 0, r0, c0, c0	; get processor ID
		AND	r0, r0, #&f000
		TEQ	r0, #&a000
		MOVNES	pc, r3			; not a StrongARM
		MCR	cp15, 0, r14, c7, c10, 1   ; clean D-cache entry
		MOV	r0, #0
		MCR	cp15, 0, r0, c7, c10, 4    ; drain write buffer
		MCR	cp15, 0, r0, c7, c5	   ; flush I-cache
		]
                MOVS    pc, r3

release_flag        DCD 0
event_break_mask    DCD 0
wimp_domain         DCD 0
irq_abort           DCD 0
poll_intercept_flag DCD 0
cout_intercept_flag DCD 0
os_exit_lr          DCD 0

; MEDUSA - POP regs saved by ROM swi intercept
swi_intercept   LDMIA   sp!, {r10-r12}
                STMDB   sp!, {r0, r12, lr}
                EOR     r0, lr, lr, LSR #1
                TST     r0, #1          ; IRQ or FIQ
                BNE     swi_cont        ; Don't even think about it

                BIC     lr, lr, #&fc000003
                LDR     r14, [lr, #-4]
                BIC     r14, r14, #&ff000000      ; r14 = SWI number as read from code
; MEDUSA - remove wacky SWI intercept SWI
                BIC     r14, r14, #xbit           ; clear the X bit
		TEQ	r14, #os_callaswi         ; deal with OS_CallASWI[R12]
		BICEQ	r14, r10, #xbit
		TEQ	r14, #os_callaswir12
		BICEQ	r14, r12, #xbit
                LDR     r12, in_debuggee          ; Are we running?
                CMP     r12, #0
                BEQ     swi_intercept3
                MOV     r0, #0                    ; if so, is our task paged in?
                LDR     r0, [r0, #zp_wimpdomain]
                LDR     r12, wimp_domain
                CMP     r0, r12
                BNE     swi_intercept3
                LDR     r12, wimppoll_lr          ; and we're not doing the Wimp_Poll
                CMP     r12, #0                   ; below are we?
                BNE     swi_intercept3
                ADRL    r12, breaklist            ; right, so let's check our SWI breakpoints.
swi_intercept4  LDR     r12, [r12]
                CMP     r12, #0
                BEQ     swi_intercept3
                LDR     r0, [r12, #o_swiaddr]
                CMP     r0, #0
                LDREQ   r0, [r12, #o_swino]
                CMPEQ   r0, r14
                BNE     swi_intercept4
                LDR     r0, stepflag              ; found a breakpoint! Are we single-stepping?
                CMP     r0, #0
                LDREQ   r0, [sp, #8]              ; get address from LR, or from R12 if this
                LDRNE   r0, [sp, #4]              ; SWI was called in the single-stepper
                BIC     r0, r0, #&fc000003
                SUB     r0, r0, #4
                LDR     r12, exec_addr            ; is this the first instruction executed?
                CMP     r0, r12                   ; if so, let it pass (otherwise how would one
                MOV     r0, #0                    ; continue after hitting a breakpoint?)
                STR     r0, exec_addr
                BEQ     swi_intercept3
                LDR     r0, stepflag
                CMP     r0, #0
                LDMIA   sp!, {r0, r12, lr}
                ORRNE   lr, r11, r12              ; Single step leaves pc in r11, r12
                SUB     lr, lr, #4
                STR     lr, regs_r15
                BNE     swi_intercept5            ; Regs already saved if single step
                TEQP    pc, lr
                STR     lr, regs_r14              ; store R0-R14
                ADR     lr, registers
                STMIA   r14, {r0-r13}
swi_intercept5  MOV     r0, #n_swi_break
                B       retfromexec               ; and stop with the breakpoint

                ; Okay, we're not stopping at a SWI breakpoint. Now what?
swi_intercept3  LDR     r12, cout_intercept_flag
                CMP     r12, #0
                BEQ     swi_intercept1            ; are we supposed to intercept output?
                CMP     r14, #os_writei + &100
                BCS     swi_intercept1
                CMP     r14, #os_writei
                BCS     swi_intercept0
                CMP     r14, #os_readc + 1
                BCC     swi_intercept0
                TEQ     r14, #os_byte
                TEQNE   r14, #os_word
                TEQNE   r14, #os_spriteop
                TEQNE   r14, #os_readpalette
                TEQNE   r14, #os_readpoint
                TEQNE   r14, #os_callavector
                TEQNE   r14, #os_prettyprint
                TEQNE   r14, #os_plot
                TEQNE   r14, #os_writen
                BNE     swi_intercept1
                ; Someone's doing some screen stuff... remove our windows...
swi_intercept0  MOV     r12, #0
                STR     r12, cout_intercept_flag
                STMDB   sp!, {r0, r1, r2, r3, r4, sl, fp, lr}
                LDR     r4, in_debuggee
                MOV     sl, #0
                STR     sl, in_debuggee
                AND     sl, sp, #&ff00000
                MOV     fp, #0
                BL      window_closedown
                STR     r4, in_debuggee
                LDMIA   sp!, {r0, r1, r2, r3, r4, sl, fp, lr}
                ; Now check for exciting SWIs.
swi_intercept1  TEQ     r14, #os_exit
                LDREQ   r12, [sp, #8]
                STREQ   r12, os_exit_lr                      ; note address of OS_Exit for later
                SUB     r14, r14, #wimp_swibase_h
                TEQ     r14, #wimp_poll_l                    ; check for Wimp_Poll[Idle] or
                TEQNE   r14, #wimp_pollidle_l                ; Debugger_*
                SUB     r14, r14, #ddt_swibase_h - wimp_swibase_h
                TEQNE   r14, #ddt_swibase_l + ddt_swi_debugaif
                TEQNE   r14, #ddt_swibase_l + ddt_swi_startdebug
                TEQNE   r14, #ddt_swibase_l + ddt_swi_enddebug
                BEQ     swi_intercept6
                ; and continue with SWI as normal
swi_cont        LDMIA   sp!, {r0, r12, lr}
; MEDUSA - 1st 2 instructions of 'real' SWI intercept
                STMDB   sp!, {r10-r12}
intercept_inst  BIC     r12, r14, #&fc000003
swi_branch      DCD     0

                ; special handler for Wimp_Poll[Idle] and Debugger_*
swi_intercept6  TEQ     r14, #ddt_swibase_l + ddt_swi_debugaif
                MOVEQ   r0, #0              ; Debugger_DebugAIF intercepted
                BEQ     debugtask           ; here so we have a full reg set.

                TEQ     r14, #ddt_swibase_l + ddt_swi_startdebug
                TEQEQ   r0, #1
                BEQ     debugtask          ; Debugger_StartDebug ditto

                TEQ     r14, #ddt_swibase_l + ddt_swi_enddebug
                BEQ     end_debug

                ; Now we deal with Wimp_Poll or Wimp_PollIdle (luverly)

                LDR     r14, poll_intercept_flag
                TEQ     r14, #1
                LDMEQIA sp!, {r0, r12, lr} ; If forcing single tasking
                BICEQ   lr, lr, #overflow  ; dummy a NULL event from
                MOVEQ   r0, #0             ; Wimp_Poll or Wimp_PollIdle
                MOVEQS  pc, lr             ; & hope program can handle it.

                LDR     r12, in_debuggee   ; This check may be redundant but
                TEQ     r12, #0            ; given the fatality if it isn't
                BEQ     swi_cont           ; I'd prefer it remains.

                MOV     r0, #0             ; Check debuggee task called SWI
                LDR     r0, [r0, #zp_wimpdomain]
                LDR     r12, wimp_domain
                TEQ     r0, r12

                LDREQ   lr, wimppoll_lr    ; Don't intercept if re-entering
                CMPEQ   lr, #0
                BNE     swi_cont

                STMFD   sp!, {r1}
                BL      unprotmem
                LDMFD   sp!, {r1}

                LDR     lr, [sp, #8]
                STR     lr, wimppoll_lr
                BIC     lr, lr, #&fc000003
		[ StrongARM
		LDMFD	sp!, {r0, r12}
		STR	r12, temp_r12
		LDR	r14, [lr, #-4]
		BIC	r12, r14, #&ff000000
		BIC	r14, r12, #&00020000
		TEQ	r14, #os_callaswi
		MOVEQ	r12, r10
		BEQ	%FT01
		TEQ	r14, #os_callaswir12
		LDREQ	r12, temp_r12
01		LDMFD	sp!, {lr}
		BIC	lr, lr, #&0c000003 ; Force to user mode and enable
                TEQP    pc, lr             ; interrupts so callback works!!!!
		SWI	os_callaswir12
		LDR	r12, temp_r12
		|
                LDR     r14, [lr, #-4]
                STR     r14, swi_inst
                B       exec_swi_inst      ; Must branch to break pipeline
exec_swi_inst   LDMIA   sp!, {r0, r12, lr}
                BIC     lr, lr, #&0c000003 ; Force to user mode and enable
                TEQP    pc, lr             ; interrupts so callback works!!!!

swi_inst        DCD     0                  ; Call the SWI (saved above)
		]

                STR     pc, wimppoll_pc
                SWI     os_enteros         ; Must enter SVC mode as I need
                STMDB   sp!, {r1, r2}      ; to return to user mode preserving
                                           ; user LR!!!!
                STMFD   sp!, {r0}
                BL      protmem
                LDMFD   sp!, {r0}

                LDR     lr, wimppoll_lr
                BIC     lr, lr, #&fc000000
                LDR     r1, wimppoll_pc
                AND     r1, r1, #&fc000000 ; Get flags from PC
                ORR     lr, lr, r1         ; Put them in LR
                MOV     r1, #0
                STR     r1, wimppoll_lr
                MOV     r2, #1
                MOV     r2, r2, LSL r0
                LDR     r1, event_break_mask
                TST     r1, r2
                LDMEQIA sp!, {r1, r2}
                MOVEQS  pc, lr
                LDR     r1, stepflag
                TEQ     r1, #0
                LDMIA   sp!, {r1, r2}
                ORRNE   lr, r11, r12
                STR     lr, regs_r15
                BNE     swi_intercept7
                TEQP    pc, lr
                STR     lr, regs_r14
                ADRL    lr, registers
                STMIA   lr, {r0-r13}
swi_intercept7  MOV     r0, #n_break_event
                B       retfromexec

wimppoll_lr     DCD     0
wimppoll_pc     DCD     0
temp_r12	DCD	0
in_poll_handler DCD     0

shift_f12_key   EQU     &dc

old_irqv        DCD     0

claim_irqv      MOV     r3, lr
                SWI     os_enteros
                MOV     lr, #&18
                LDR     r2, [lr]
                STR     r2, old_irqv
;               check if we are in 32-bit configuration
                MOVS    r1, #0            ; set Z-bit in status word
                MRS     r1, CPSR_all      ; save PSR in r1 (== CMP pc, r1 in 26-bit mode!)
                TEQ     r1, #0            ; r1 will be non-zero if it was an MRS (ie 32 bit)  YUK!!!
                BNE     claim_irqv_32bit
                ADR     r1, irq_branch
                MOV     r1, r1, LSR #2
                SUB     r2, r2, r1
                ADD     r2, r2, #6
                BIC     r2, r2, #&ff000000
                ORR     r2, r2, #&ea000000
                STR     r2, irq_branch
                ADR     r2, irq_intercept
                SUB     r2, r2, #&20
                MOV     r2, r2, LSR #2
                ORR     r2, r2, #&ea000000
                STR     r2, [lr]
                MOVS    pc, r3

release_irqv    MOV     r3, lr
                SWI     os_enteros
                MOV     lr, #&18
                LDR     r2, old_irqv
;               check if we are in 32-bit mode
                MOVS    r1, #0            ; set Z-bit in status word
                MRS     r1, CPSR_all      ; save PSR in r1 (== CMP pc, r1 in 26-bit mode!)
                TEQ     r1, #0            ; r1 will be non-zero if it was an MRS (ie 32 bit)  YUK!!!
                BNE     release_irqv_32bit
                STR     r2, [lr]
                MOVS    pc, r3

ldr_pc_plus_four
                LDR     pc, claim_irqv_32bit

claim_irqv_32bit
                MOV     r1, #&ff
                ORR     r1, r1, #&f00
                AND     r2, r2, r1
                ADD     r2, r2, #&20
                STR     r2, old_irqv
                LDR     r1, [r2]
                STR     r1, irq_branch +4
                LDR     r1, ldr_pc_plus_four
                STR     r1, irq_branch
                ADR     r1, irq_intercept_32bit
                STR     r1, [r2]
		[ StrongARM
		MOV	r0, #1
		ADR	r1, irq_branch
		ADR	r2, irq_branch
		SWI	xos_synchronisecodeareas
		]
                MOVS    pc, r3

release_irqv_32bit
                LDR     r1, irq_branch +4
                STR     r1, [r2]
                MOVS    pc, r3

irq_r14         DCD     0       ; User r14 in irq
irq_lr          DCD     0       ; Irq lr in irq

in_irq          DCD     1


irq_intercept   TST     lr, #&0c000003  ; Non user or interrupts disabled
                BNE     irq_branch      ; I really don't want to know
                STMDB   sp!, {r0, r1}
                LDR     r0, irq_abort   ; User shift f12
                CMP     r0, #0
                BEQ     irq_cont0       ; No, continue (default case)
                LDR     r0, in_irq
                CMP     r0, #0
                BEQ     irq_cont0
                MOV     r0, #0
                LDR     r0, [r0, #zp_wimpdomain]
                LDR     r1, wimp_domain
                CMP     r0, r1
                BNE     irq_cont0
                MOV     r0, #0
                STR     r0, in_irq
                SUB     lr, lr, #4
                STR     lr, irq_lr
                AND     lr, lr, #&fc000003
                ADR     r0, irq_break + 4
                ORR     lr, lr, r0
		B	irq_cont0

irq_intercept_32bit     ; deal with being in 32 bit mode
                STMDB   sp!, {r0, r1}
                MRS     r0, SPSR_all
                ANDS    r1, r0, #I32Bit + F32Bit      ; get I&F flags
                TSTEQ   r0, #&f
                LDMNEIA sp!, {r0, r1}	              ; if not user mode or interrupts disabled
                LDRNE   pc, irq_branch+4	      ; then pass it on

                LDR     r0, irq_abort   ; User shift f12
                TEQ     r0, #0
                BEQ     irq_cont0       ; No, continue (default case)

                LDR     r0, in_irq
                TEQ     r0, #0
                BEQ     irq_cont0	; have we been re-entered?

                MOV     r0, #0
                LDR     r0, [r0, #zp_wimpdomain]
                LDR     r1, wimp_domain
                TEQ     r0, r1
                BNE     irq_cont0       ; is the correct task switched in?

                MOV     r0, #0
                STR     r0, in_irq
                SUB     lr, lr, #4
                STR     lr, irq_lr
		ADR	lr, irq_break + 4
irq_cont0       LDMIA   sp!, {r0, r1}
irq_branch      DCD     0
                DCD     0

irq_break       STR     r14, irq_r14    ; Create work reg, No stack!
                MOV     r14, #0         ; Clear irq abort flag so we're
                STR     r14, irq_abort  ; not called twice for the same abort
                LDR     r14, stepflag   ; Single step polls abort flag
                CMP     r14, #0
                ADRNE   r14, irq_r14    ; So don't abort if single stepping
                STRNE   r14, in_irq
                LDMNEIA r14, {r14, pc}^
                LDR     r14, registers_adcon
                STMIA   r14!, {r0-r13}
                ADR     r0, irq_r14
                LDMIA   r0, {r1, r2}
                STMIA   r14, {r1, r2}
                MOV     r0, #n_shiftf12
                STR     r14, in_irq
                B       retfromexec

registers_adcon DCD     registers

n_osbyte_read_kbd  EQU 129
n_osbyte_clear_esc EQU 124
n_osbyte_prog_f11  EQU 222

cont_suspend    MOV     r0, #n_osbyte_prog_f11
                MOV     r1, #&d0
                MOV     r2, #0
                SWI     os_byte
                MOV     r3, r1
cont_suspend1   ADRL    r0, abort_flag
                LDR     r0, [r0]
                CMP     r0, #0
                BNE     suspend_exit
                MOV     r0, #n_osbyte_read_kbd
                MOV     r1, #0
                MOV     r2, #0
                SWI     os_byte
                CMP     r2, #&00
                BEQ     suspend_exit
                CMP     r2, #&1b
                BNE     cont_suspend1
                MOV     r0, #n_osbyte_clear_esc
                SWI     os_byte
suspend_exit    MOV     r0, #n_osbyte_prog_f11
                MOV     r1, r3
                MOV     r2, #0
                SWI     os_byte
                B       retfromexec

undef_handler   SUB     lr, lr, #4
                STMDB   sp!, {lr}
                BIC     lr, lr, #&fc000003
                LDR     lr, [lr]
                AND     lr, lr, #&0f000000
                CMP     lr, #&0f000000
                MOVNE   lr, #n_undef_inst
                BNE     save_ex_regs
                LDMIA   sp!, {lr}
                ADD     lr, lr, #4
;                TEQP    pc, lr   /* FIXME !!! */
                MOV     pc, #8

prefetch_handler
                SUB     lr, lr, #4
                STMDB   sp!, {lr}
                MOV     lr, #n_prefetch_abort
                B       save_ex_regs

exception       SWI     os_enteros
                SWI     xos_writes
                DCB     4, 12, 0
                SWI     xos_write0
                SWI     xos_writes
                DCB     13, 10, "Registers:", 13, 10
                MOV     r11, r12
                MOV     r10, #0
exception1      SWI     xos_writei + 'R'
                CMP     r10, #10
                ADD     r0, r10, #'0'
                SUBCS   r0, r0, #10
                SWICS   xos_writei + '1'
                SWI     xos_writec
                SWICC   xos_writei + ' '
                SWI     xos_writes
                DCB     " = "
                LDR     r0, [r11], #4
                ADR     r1, reg_hex
                MOV     r2, #9
                SWI     xos_converthex8
                SWI     xos_write0
                ADD     r10, r10, #1
                TST     r10, #3
                SWINE   xos_writei + ' '
                SWIEQ   xos_newline
                CMP     r10, #16
                BCC     exception1
                SWI     xos_writes
                DCB     "Backtrace:", 13, 10, 0
                LDR     r11, [r12, #11 * 4]
exception2      CMP     r11, #&1800000
                BCC     exception3
                CMP     r11, #&2000000
                BCS     exception3
                LDR     r10, [r11]
                BIC     r10, r10, #&fc000003
                CMP     r10, #&1800000
                BCC     exception3
                CMP     r10, #&2000000
                BCS     exception3
                LDR     r0, [r10, #-20]!
                ADDS    r0, r0, #&01000000
                LDRCC   r0, [r10, #-4]!
                ADDCCS  r0, r0, #&01000000
                ADRCC   r0, anon_msg
                SUBCS   r0, r10, r0
                SWI     xos_write0
                SWI     xos_newline
                LDR     r11, [r11, #-12]
                B       exception2

exception3      SWI     xos_writes
                DCB     "Please record the above and report it to Acorn"
                DCB     13, 10
                DCB     "Press any key to continue", 0
                SWI     xos_readc
                BIC     sl, sp, #&ff
                BIC     sl, sl, #&ff00
                BL      window_closedown
                BL      window_cleanup
                BL      swap_out_handlers
                BL      release_dbgr_vectors
                BL      heap_discard
                BL      reset_dbgflag
                ADR     r0, exception_msg
                SWI     os_generateerror

abort_msg       DCB     "Error / address exception / data abort in debugger", 0
                ALIGN

anon_msg        DCB     "Anonymous function", 0
                ALIGN

exception_msg   DCD     exception_error
                DCB     "Exception in debugger", 0
                ALIGN

reg_hex         DCD     0, 0, 0

protmem         LDR     r0, memory_protection
                CMP     r0, #0
                LDRNE   r0, in_debuggee
                CMPNE   r0, #0
                MOVEQS  pc, lr

                [ {FALSE}
                STMFD   r13!, {r14,pc}
                SWI     os_enteros
                MOV     r0, #&03500000
                LDR     r1, =&400000FF
                STR     r1, [r0]
                LDR     r0, [r13,#4]
                TEQP    r0, #0
                LDR     r14, [r13], #8
                ]

                MOV     r1, lr
                LDR     r0, prot_list
                SWI     os_setmemmapentries
                MOVS    pc, r1

unprotmem       LDR     r0, memory_protection
                CMP     r0, #0
                LDRNE   r0, in_debuggee
                CMPNE   r0, #0
                MOVEQS  pc, lr

                [ {FALSE}
                STMFD   r13!, {r14,pc}
                SWI     os_enteros
                MOV     r0, #&03500000
                LDR     r1, =&4000FF00
                STR     r1, [r0]
                LDR     r0, [r13,#4]
                TEQP    r0, #0
                LDR     r14, [r13], #8
                ]

                MOV     r1, lr
                LDR     r0, unprot_list
                SWI     os_setmemmapentries
                MOVS    pc, r1

prot_list       DCD     0
unprot_list     DCD     0
memory_protection
                DCD     0

cmd_cli         STMDB   sp!, {r4 - r12, lr}
;                LDR     r1, fpavailable
;                CMP     r1, #0
;                BEQ     cmd_cli1
		SFMFD	f4, 4, [sp]!
cmd_cli1        MOV     r4, r0
                BL      swap_cmd_upcall
                MOV     r0, r4
                STR     sp, cmd_sp
                SWI     os_cli
                MOVVC   r0, #0
cmd_err_ret     MOV     r4, r0
                LDR     sp, cmd_sp      ; So user sp should be ok
;                LDR     r1, fpavailable
;                CMP     r1, #0
;                BEQ     cmd_ret
		LFMFD	f4, 4, [sp]!
cmd_ret         LDR     sl, [sp, #4 * 6]
                LDR     r0, coredump
                CMP     r0, #0
                BLNE    rest_core
                MOV     r0, #0
                STR     r0, coredump
                BL      swap_cmd_upcall
                MOV     r0, r4
                LDMIA   sp!, {r4 - r12, pc}^

coredump        DCD     0
cmd_sp          DCD     0

cmd_upcall_handlers
                DCD     n_upcall_handler, cmd_upcall, 0, 0
                DCD     n_error_handler, cmd_upcall_error, 0
cmd_err_buff    DCD     error_buffer
                DCD     n_exit_handler, cmd_upcall_exit, 0, 0

swap_cmd_upcall STMDB   sp!, {lr}
                ADR     ip, cmd_upcall_handlers
swap_cmd_upcall1
                LDMIA   ip, {r0, r1, r2, r3}
                SWI     xos_changeenvironment
;                SWI     os_writes
;                DCB     "swapping upcall handler", 13, 10, 0
                STMIA   ip!, {r0, r1, r2, r3}
                CMP     r0, #n_exit_handler
                BNE     swap_cmd_upcall1
                LDMIA   sp!, {pc}^

cmd_upcall      CMP     r0, #n_upcall_newapp
                MOVNES  pc, lr
                STMDB   sp!, {r0, r1, r2, r3, r11, r12, lr}
;                SWI     os_writes
;                DCB     4, 30, "Starting new app", 13, 10, 5, 0
;                SWI     os_readc
                LDR     r0, coredump
                CMP     r0, #0
                LDMNEIA sp!, {r0, r1, r2, r3, r11, r12, pc}^
                BL      save_core
                STR     r0, coredump
                LDMIA   sp!, {r0, r1, r2, r3, r11, r12, pc}^

cmd_upcall_exit LDR     r2, abex
                CMP     r2, r1
                MOVNE   r0, #0
                B       cmd_err_ret

cmd_upcall_error
                TEQP    pc, #0
                ADRL    r0, error_buffer + 4
                B       cmd_err_ret

I_bit           EQU     &08000000

end_debug       MVN     r14, #I_bit
                TSTP    r14, pc
                LDR     r14, stepflag
                CMP     r14, #0
                LDMNEIA sp!, {r0, r12, lr}
                MOVNE   r0, #n_enddebug
                BNE     retfromexec    ; Use parent register if stepping
                ADRL    r14, registers
                STMIA   r14, {r0-r14}^
                LDMIA   sp!, {r0, r12, lr}
                STR     r0, registers + 0 * 4
                STR     r12, registers + 12 * 4
                STR     lr, registers + 15 * 4
                AND     r0, lr, #3
                CMP     r0, #3
                STREQ   sp, registers + 13 * 4
                MOV     r0, #n_enddebug
                B       retfromexec

ret_to_dbge     BL      window_closedown
                BL      window_cleanup
                BL      swap_out_handlers
                BL      release_dbgr_vectors
                BL      clear_breakpoints
                BL      heap_discard
                BL      reset_dbgflag
                LDR     r0, registers + 15 * 4
                AND     r0, r0, #3
                CMP     r0, #3
                SWIEQ   os_enteros
                ADRL    r12, user_sp
                LDMIA   r12, {r13, r14}^
		NOP
                ADRL    r12, registers
                LDMIA   r12, {r0 - r15}^

claim_dbgr_vectors
                STMDB   sp!, {r0, r1, r2, lr}
                MOV     r2, #0
                LDR     r2, [r2, #zp_wimpdomain]
                MOV     r0, #n_ins_vector
                ADR     r1, event_intercept
                SWI     os_claim
                MOV     r0, #n_changeenv_vector
                ADR     r1, changeenv_intercept
                SWI     os_claim
                MOV     r0, #n_word_vector
                ADR     r1, word_intercept
                SWI     os_claim
                MOV     r0, #n_upcall_vector
                ADR     r1, upcall_intercept_media
                SWI     os_claim
                MOV     r0, #n_find_vector
                ADR     r1, find_intercept
                SWI     os_claim
                MOV     r0, #0
                STR     r0, mouse_ptr
                STR     r0, mouse_ptr_size
                STR     r0, open_file_list
                LDMIA   sp!, {r0, r1, r2, pc}^

release_dbgr_vectors
                STMDB   sp!, {r0, r1, r2, lr}
release_dbgr_vectors0
                LDR     r2, open_file_list
                CMP     r2, #0
                MOVNE   r0, #0
                LDRNE   r1, [r2, #4]
                SWINE   xos_find
                CMP     r2, #0
                BNE     release_dbgr_vectors0
                LDR     r2, [r2, #zp_wimpdomain]
                MOV     r0, #n_ins_vector
                ADR     r1, event_intercept
                SWI     os_release
                MOV     r0, #n_changeenv_vector
                ADR     r1, changeenv_intercept
                SWI     os_release
                MOV     r0, #n_word_vector
                ADR     r1, word_intercept
                SWI     os_release
                MOV     r0, #n_upcall_vector
                ADR     r1, upcall_intercept_media
                SWI     os_release
                MOV     r0, #n_find_vector
                ADR     r1, find_intercept
                SWI     os_release
                LDR     r2, mouse_ptr
                CMP     r2, #0
                MOVNE   r0, #n_module_free
                SWINE   xos_module
                LDMIA   sp!, {r0, r1, r2, pc}^

event_intercept CMP     r1, #n_kbd_buffer
                CMPEQ   r0, #shift_f12_key
                MOVNES  pc, lr
                ADRL    r0, abort_flag
                STR     r0, [r0]
                STR     r0, irq_abort
                LDMIA   sp!, {pc}^

upcall_intercept_media
                TEQ     r0, #1
                TEQNE   r0, #2
                TEQNE   r0, #4
                MOVNES  pc, lr
                STMDB   sp!, {r0-r6, sl, fp}
                AND     sl, sp, #&ff00000
                MOV     fp, #0
                MOV     r0, sp
                BL      missing_media
                LDMIA   sp!, {r0-r6, sl, fp, pc}^

; Interception routine for OS_ChangeEnvironment. The aim is to
; prevent the debuggee changing the abort/error handlers - we
; want to catch aborts and errors ourselves.
changeenv_intercept
                LDR     r12, in_debuggee            ; if the we're not running, or the
                CMP     r12, #0                     ; debuggee has started a subapp,
                LDRNE   r12, in_subapp              ; allow the call.
                CMPNE   r12, #1
                MOVEQS  pc, lr
                LDR     r12, wimppoll_lr            ; if Wimp_Poll has been called, it's
                CMP     r12, #0                     ; the Wimp doing it, so allow it.
                MOVNES  pc, lr
                TEQ     r0, #n_undef_handler        ; if it's not one of these handlers,
                TEQNE   r0, #n_prefetch_handler     ; allow it
                TEQNE   r0, #n_abort_handler
                TEQNE   r0, #n_address_handler
                TEQNE   r0, #n_error_handler
                MOVNES  pc, lr
                STMDB   sp!, {lr}                   ; if it's not our task, allow it.
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]
                LDR     r12, wimp_domain
                CMP     r12, lr
                LDMNEIA sp!, {pc}^
                MOV     r1, #0                      ; disallow the call.
                MOV     r2, #0
                MOV     r3, #0
                LDMIA   sp!, {pc}^

n_osword_mouseop EQU 21
n_mouseop_defptr EQU 0

mouse_ptr       DCD     0
mouse_ptr_size  DCD     0
                DCB     0, 0
word_block      DCB     n_mouseop_defptr
                DCB     1
mouse_info      DCD     0
word_ptr        DCD     0

word_intercept  CMP     r0, #n_osword_mouseop
                BIC     r0, r0, #&80
                LDREQB  r12, [r1]
                CMPEQ   r12, #n_mouseop_defptr
                LDREQB  r12, [r1, #1]
                CMPEQ   r12, #1
                MOVNES  pc, lr
                STMDB   sp!, {r0, r1, r2, r3, lr}
                LDRB    r0, [r1, #3]
                LDRB    r3, [r1, #2]!
                MUL     r3, r0, r3
                LDR     r0, mouse_ptr_size
                CMP     r0, r3
                BCS     word_intercept0
                MOV     r0, #n_module_claim
                SWI     xos_module
                LDMVSIA sp!, {r0, r1, r2, r3, pc}^
                LDR     r0, mouse_ptr
                STR     r2, mouse_ptr
                MOVS    r2, r0
                BEQ     word_intercept0
                MOV     r0, #n_module_free
                SWI     xos_module
word_intercept0 ADR     r0, mouse_info
                MOV     r12, #8
word_intercept1 LDRB    lr, [r1], #1
                STRB    lr, [r0], #1
                SUBS    r12, r12, #1
                BNE     word_intercept1
                LDR     r1, mouse_ptr
                LDR     r2, word_ptr
word_intercept3 LDR     r0, [r2], #4
                STR     r0, [r1], #4
                SUBS    r3, r3, #4
                BHI     word_intercept3
                LDMIA   sp!, {r0, r1, r2, r3, pc}^

restore_mouse   LDR     r0, mouse_ptr
                CMP     r0, #0
                MOVEQS  pc, lr
                STMDB   sp!, {lr}
                STR     r0, word_ptr
                MOV     r0, #128 + n_osword_mouseop
                ADRL    r1, word_block
                SWI     xos_word
                LDMIA   sp!, {pc}^

open_file_list  DCD     0

find_intercept  TST     r0, #&c0
                BEQ     find_intercept_close
                STR     lr, [sp, #-4]!
                MOV     lr, #0
                LDR     lr, [lr, #zp_wimpdomain]
                TEQ     r12, lr
                LDR     lr, [sp], #4
                STREQ   pc, [sp, #-4]!  ; PC points 12 bytes on
                MOVS    pc, lr

                MOV     r0, r0          ; Nop to pad to 12 bytes

find_intercept_open
                LDRVS   pc, [sp], #4
                TEQ     r0, #0
                LDREQ   pc, [sp], #4
                STMDB   sp!, {r0, r1, r2, r3}
                MOV     r1, r0
                MOV     r0, #n_module_claim
                MOV     r3, #8
                SWI     xos_module
                LDRVC   r0, open_file_list
                STRVC   r0, [r2]
                STRVC   r1, [r2, #4]
                STRVC   r2, open_file_list
                LDMIA   sp!, {r0, r1, r2, r3, pc}

find_intercept_close
                STMDB   sp!, {r0-r4, lr}
                ADR     r4, open_file_list
                B       find_intercept_close1
find_intercept_close0
                LDR     r3, [r2, #4]
                CMP     r1, #0
                CMPNE   r1, r3
                MOVNE   r4, r2
                BNE     find_intercept_close1
                LDR     r3, [r2]
                MOV     r0, #n_module_free
                SWI     xos_module
                STR     r3, [r4]
find_intercept_close1
                LDR     r2, [r4]
                CMP     r2, #0
                BNE     find_intercept_close0
                LDMIA   sp!, {r0-r4, pc}^

                [ 0 = 1

dbg_hbuff       DCD     0, 0, 0

dbg_abort       STMDB   sp!, {r0, r1, r2, lr}
                ADR     r1, dbg_hbuff
                MOV     r2, #12
                SWI     &d4
                SWI     os_writes
                DCB     4, "Abort at ", 0
                SWI     xos_write0
                SWI     os_writes
                DCB     13, 10, 5, 0
                LDMIA   sp!, {r0, r1, r2, pc}^

hbuff           DCD     0, 0, 0

reg_dump        MOV     r6, lr
                SWI     os_writes
                DCB     4, 0
                MOV     r4, #16
cont3           LDR     r0, [r12], #4
                ADR     r1, hbuff
                MOV     r2, #12
                SWI     os_converthex8
                SWI     xos_write0
                SWI     os_writes
                DCB     13, 10, 0
                SUBS    r4, r4, #1
                BNE     cont3
                SWI     os_writes
                DCB     5, 0
                MOVS    pc, r6

                ]

                END
