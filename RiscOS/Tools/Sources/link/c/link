/*
 * ARM AOF Linker
 * Copyright (C) 1991-93 Advanced RISC Machines Limited. All rights reserved.
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 * IDJ: 14-Oct-94: bug fix for AQU-00046, AQU-00044, AQU-00062 (naff -aof output)
 */

#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <string.h>


/*
 * IDJ (Acorn) 3-Oct-94: bug-fix AQU-00065: don't automatically include debug
 *                       areas if found when no "-d".  Just print informational
 *                       message at end of link.  Previous behaviour annoys people!
 */
/*
 * RMJ 04Dec96: make sure the module relocation code is written out with the
 *              correct endianness.
 */

#ifdef __STDC__
#  include <stdlib.h>
#  include <stdarg.h>
#  include <time.h>
#  define  LOWER(ch)    (tolower((unsigned char)ch))
#  ifdef __GNUC__
#    include <unistd.h>
/* BSD/SUN don't have strtoul(), but then strtol() doesn't barf on */
/* overflow as required by ANSI... This bodge is horrid.           */
#    define strtoul(s, ptr, base) strtol(s, ptr, base)
#  endif
#else
#  include <varargs.h>
#  include <unistd.h> /* for SEEK_SET (IJR) */
extern char *malloc();
extern char *memcpy();
/* BSD/SUN don't have strtoul(), but then strtol() doesn't barf on */
/* overflow as required by ANSI... This bodge is horrid.           */
#  define strtoul(s, ptr, base) strtol(s, ptr, base)
extern int errno;
#  define  LOWER(ch) \
       (isascii(ch) && isupper(ch) ? tolower(ch): (unsigned char)ch)
#endif

#include "options.h"
#include "hostdep.h"
#include "msgnos.h"
#include "aof.h"
#include "prgname.h"

#ifdef LINKING_ON_ACORN_RISC_OS
#include "riscos.dem.h"
#include <assert.h>
#endif

#ifdef TARGET_HAS_AOUT
#  ifdef TARGET_IS_UNIX
#    include "vmparam.h"               /* for USRSTACK */
#  endif
#  include "aoutvsn.h"
#  include "exec.h"
#  include "aout.h"
#  include "ar.h"
#  include "ranlib.h"
#  ifndef PAGESIZE
#    define PAGESIZE   8192         /* there has to be some default... */
#  endif                            /* ... but assumed set by aout.h.  */
#endif

#ifdef TARGET_HAS_AOF
#  include "libflfmt.h"
#  include "chunkfmt.h"
#  include "aif.h"
#  include "aifcode.h"
#  include "asdfmt.h"
#  include "ovrflfmt.h"
#endif

#ifndef SELF
#  define SELF    "ARM Linker"
#endif
#ifndef IDFNSTR
#  define IDFNSTR " Version 5.00f (Acorn Computers Ltd) <beta+ release>"
#endif            /* NB - leading space is needed */
#ifndef Module_Date
#  define BUILDDATE __DATE__
#else
#  define BUILDDATE Module_Date
#endif

#define StrEQ(x, y)   (strcmp((x), (y)) == 0)
#define StrNE(x, y)   (strcmp((x), (y)) != 0)
#define CiStrEQ(x, y) (cistrcmp((x), (y)) == 0)
#define CiStrNE(x, y) (cistrcmp((x), (y)) != 0)

#define SYM_LINKSYM   0x01000000 /* well clear of AOF attributes.  */
#define SYM_EFTSYM    0x02000000 /* exported from a shared library */
#define SYM_DEXSYM    0x04000000 /* directly-exported from a shared lib. */
#define SYM_FNVSYM    0x08000000 /* exported via address-taken fn veneer */
#define SYM_SCANLIB   0x10000000 /* scan library to satisfy reference */
#define SYM_LINKFLAGS 0x1f000000

#define MAXLINESIZE   256        /* Program limitation(s) */
#define MAXSYMLEN     256        /* max symbol name length */
#define MAXERRMSGLEN   80        /* Max. length of any error message */
#define MAXAREANAMELEN 64
#define MAXCHUNKS       8        /* max no of chunks in an o/p AOF file */
#define MAXOPENFILES   16        /* max no concurrently open */
#define OVERSEGNAMELEN 10        /* Max len manageable by overlay manager */

#ifdef BIGHASHTABLES             /* PLEASE! make sure these are powers of 2 */
#define AREATABLESIZE     4096
#define GLOBHASHTABLESIZE 16384
#else
#define AREATABLESIZE     512
#define GLOBHASHTABLESIZE 4096   /* about 2200 unique syms in ARMcc */
#endif
#define OBJAREATABLESIZE   16    /* used bigger as needed */
#define COMMONTABLESIZE   128
#define LIBSYMTABLESIZE   512

#define HASH(hash, ch)    (hash*37L + (int32)LOWER(ch))

/* There are only three basic output types, noted below. Others are handled */
/* as subcases. E.g. RMF == (AIF, moduleflag == 1).                         */
#define NOTYPE     0                /* Input / output file types */
#define AOF        1                /* Output type... */
#define OFL        2
#define RMF        3
#define AIF        4                /* Output type... */
#define IHF        5                /* Intellec Hex Format... */

#define AOUT       8 + 1            /* Output type... */
#define AR         8 + 2

#define AOUT_MASK  8
#define LIB_MASK   2

#define OBJECT_MASK 1

#define ALIGN_MASK 3                /* & mask to align to the nearest word */

#ifdef __STDC__
typedef char *(*PFCS)(int32);       /* halloc / salloc switch */
typedef int (*PFI)(const char *, const char *);
                                    /* string compare function */
#else
typedef char *(*PFCS)();            /* halloc / salloc switch */
typedef int (*PFI)();               /* string compare function */
#endif

struct sym;                         /* defence against C++ scoping... */
struct globsym
{   struct hentry *next;
    int32 pcit_entry;
    struct sym
    {   int32 value;
        struct aentry *area;
#ifdef TARGET_HAS_AOUT
        unsigned32 dbxinfo;
#endif
        unsigned32 flags;
        int32 symno;
        struct oentry *refobj;
    } symval;
};

struct hentry
{   struct hentry *next;
    union
    {   int32 intval;
        struct globsym *globval;
        struct aentry *areaval;
    } h_un;
    char name[4];
};

static struct htable
{   struct hentry **table;
    size_t  tablesize;
    PFCS mget;                      /* fn used to allocate memory */
} commontable, globhashtable, libsymtable;


#ifdef LINKING_ON_ACORN_RISC_OS

/*
 * IDJ: 5-May-94: support for C++ static ctors and dtors
 */

struct __link_list {
    struct __link_list *next, *chain;
    struct sym *sy;
};

static struct __link_list *g__link_list = 0;

static struct sym *g__head_sym = 0;
#endif


static char *sharedlib;
static struct hentry *firstglobsym, **nextglobsym;

static struct fentry { /* struct to hold file info from command line */
    struct fentry *next;
    int32  type;                        /* AOF, AOUT, AR, ALF */
    union {
        char *hdrptr;
#ifdef TARGET_HAS_AOF
        cf_header *cfhdr;               /* Chunk file headers + entries */
#endif
#ifdef TARGET_HAS_AOUT
        char *armag;                    /* AR magic no. during file typing */
        struct ar_hdr *arhdr;           /* __.SYMDEF file header */
        struct exec *aouthdr;           /* a.out header */
        struct exec_header *newhdr;/* Extended hdr for shared libs */
#endif
    } f_un;
    int32 size;
    int32 posn;
    char *filebuffer;
    int  fd;               /* file descriptor + file seek position */
    int  lflag;
    char fname[4];         /* file name (as many chars as needed) */
} *clifilelist;

static int failedtostack;
static int32 outsiz;
static int32 relocposn, areaoutposn, srcposn;

struct lventry {
    struct oventry *seg_list;
    struct lventry *next;
    int32 clash;
};

static struct oventry {
    struct aentry **nextarea, *areas, *outarealist;
    struct aentry **arealist, **outareas;
    int32 textsize, datasize, bsssize, dbgsize;
    int32 entryv;
    int32 torigin, dorigin, borigin;
    int32 noofareas, noofoutareas;
    int32 pcit_base;
    unsigned32 base, limit;
    struct lventry *level;
    struct lventry *level_list;
    struct oventry *next;
    char *name;
    struct htable areatable;
} root;

static int32 total_seg_size;

struct aentryptr {
    struct aentry *aep;
    struct aentryptr *next;
};

struct aentry {
    struct oentry *oep;
    struct hentry *h;
    struct aentry *nxt;
    struct aentryptr *refs;
    struct oventry *overseg;
    int32 areaoff, areasiz, areapad;
    int32 relocoff, relocs;
    int32 base;
    int32 attrs;
    unsigned32 flags;
    int32 areano;
    int32 areaidx;
    char *areaval;
#ifdef LINKING_ON_ACORN_RISC_OS
    struct __link_list *area__link_list;   /* static ctors for CFront C++ */
#endif
    char name[4];
};

/* Values within an aentry's flags field */
#define  SHFLAG         1   /* a.out shared lib flag */
#define  COMPLAINED     2   /* suppresses multiple attribute clash msgs */
#define  REFERENCED     4   /* used during unused area scan... */
#define  UNUSEDAREA     8   /* used during unused area scan... */
#define  AREA_FIRST    16   /* place this area FIRST... */
#define  AREA_LAST     32   /* ... and this one LAST... */
#define  UNHASHED      64   /* A shared library stub area NOT copied */
                            /* to this shared library's stub.        */
#define  SHLRODATA    128   /* data to be copied from lib to stub */
#define  NOINSTRELOC  256   /* AOF earlier than Vsn 310 doesn't have */
                            /* relocatable instruction sequences */

static struct aentry *common;        /* Common area for a.out */
static struct aentry **nextoutarea;
static struct aentry *objarealist, **nextobjarea = &objarealist;
static struct aentry *lastoutarea;

static struct oentry {
    struct oentry *next;
    char *oname;
    struct fentry *fep;        /* file entry fm which this object was derived */
    union {
        char *hdrptr;
#ifdef TARGET_HAS_AOF
        cf_header *cfhdr;      /* header as read by filetype */
#endif
#ifdef TARGET_HAS_AOUT
        struct exec *aouthdr;
        struct exec_header *newhdr; /* Extended hdr for shared libs */
#endif
    } o_un;
    char *objbuffer;           /* if object is in memory, but file isn't */
    int32 offset;
    int32 size;                /* (== file size for non-library files) */
    struct hentry **numtosym;  /* xlate local symbol nos to table ptrs */
    struct aentry **arealist;  /* list of text & data areas in file    */
    char objectid[4];          /* unique id for this object '!!' .. 'ZZ' */
} *objectlist;

static struct oentry **nextobj = &objectlist;

static int32 popped; /*TBD*/
static int32 reloc_count;

static char objectid[2] = { '!', '!' };     /* gets updated... !!..ZZ */

#ifdef TARGET_HAS_AOF
static cf_header *cfouthdr;
static aof_header *aofhdr;
static size_t cfhdrsize, aofhdrsize;
#endif

#ifdef TARGET_HAS_AOUT
static int32 textrelocs, datarelocs;
static char nmagicflag;        /* Squidge text & data together */
static size_t pagesize;
#endif

static struct aentry *entryarea, *outentryarea;
static unsigned32 entryoffset, outentryofs;
static unsigned32 entrypoint;
static PFI  casefn = strcmp;   /* case sensitive symbol match by default */

/* Values taken by binaryflag - BIN_AIFHDR for a binary file preceded by */
/* an AIF header which describes it. BIN_NOHDR for plain binary.         */
#define BIN_NOHDR     1
#define BIN_AIFHDR    2

/* and values taken by scatterflag */
#define OVERLAY       1
#define SCATTERIMAGE  2

static char entryflag;         /* user supplied entry point? */
static char baseflag;          /* user supplied base address? */
static char debugflag;         /* include debugging areas/symbols? */
static char plinkflag;         /* partial link => keep relocs & symbol table */
static char binaryflag;        /* Only output areas - no header */
static char intellecflag;      /* Binary in VLSI superset-Intellec format */
static char scatterflag;       /* scatter format images, e.g. overlays */
static char verboseflag;       /* tell user whats a going on? */
static char moduleflag;        /* Produce AMF output */
static char private_amf_reloc; /* user supplied own AMF reloc code? */
static char relocflag;         /* Produce relocatable AIF output */
static char workspaceflag;
static char mapflag;           /* Produce placement map of areas */
static char xrefflag;          /* Print area xref */
static char shl_flag;          /* generate APCS-3 shared library */
static char reent_flag;        /* generate reentrant output */
#ifdef LINKING_ON_ACORN_RISC_OS
static char ddeflag = 1;       /* always be DDE compatible for Acorn RISC OS host! */
#else
static char ddeflag;           /* be Acorn C R.3 / DDE compatible */
#endif
static char rw_baseflag;       /* got a separate data base */
static char duplicateflag;     /* allow duplicate symbol defs */
#ifdef TARGET_IS_ACORN_RISC_OS
static char nounusedflag = 1;  /* never remove unref'ed areas for RISC OS target (because of stubs) */
#else
static char nounusedflag;      /* don't eliminate unused areas */
#endif
static char splitflag;         /* split RO and RW into separate O/P files */
static char libdataflag;       /* put shared lib data in the library */
#ifdef LINKING_ON_ACORN_RISC_OS
static char cplusplusflag;     /* support CFront-style ctors and dtors, and name demangling */
static int warned_cpp;
#endif


static unsigned char match_opts;
/* match_opts flag bits... */
#define MATCH_xTOx             1
#define MATCHxTO_x             2
#define MATCHx_yTOxDOTy        4
#define MATCHx__yTOx           8
#define PCREL_IMPLIES_CODE    16
#define WARN_FP3              32

static char has_dbg_areas;     /* if any input AREA has type AOF_DEBUGAT */

static struct {
    int32 id[2];
    unsigned char size,
                  toolid,
                  match_opts;
} patchable_config = {
/* an identifying "string" (but defined as a pair of word values to enable
   target bytesex to be identified by the patching tool
 */
   { ((((((long)'x' << 8) | 'c') << 8) | 'o') << 8) | 'n',
     ((((((long)'f' << 8) | 'i') << 8) | 'g') << 8) | 'x'
   },
   sizeof(patchable_config),
   4,               /* Linker  */
   PCREL_IMPLIES_CODE
};

static int32 qflag;            /* added by LDS for internal bodgery... */
#define  NEW_OVERMGR    1      /* qflag value to get new overlay manager */

static int32 workspace;        /* Workspace to reserve in AIF */
static int32 code_attrs_set = 0L, code_attrs_unset = 0L, code_attrs_warned = 0L;

static unsigned32 base=0x8000; /* base address of code in mem. */
static unsigned32 data_base;   /* separate data base, maybe... */
static int32 textoffset;

static int  output_type;       /* type of o/p to generate: AIF, AOF or a.out */
static char *outf, *outfile;   /* output file */
static char *editfile;         /* file containing link edit commands */
static char *scatterfile;      /* file containing scatter image commands */
static char *symfile;          /* file to take symbol table */
static char *shl_name;         /* name of shared library */
static char *shl_file;         /* name of file containing shared library */
static char *interLUcodeName = "sb$$interLUcode";
static char *interLUdataName = "sb$$interLUdata";
                               /* names of inter-LU code and data areas */

static char *entryarea_name;   /* name of object(area) containing entry point */
static char *first_area;       /* name of object(area) to place first */
static char *last_area;        /* name of object(area) to place last  */
static char *ro_ext = "";      /* file extension for -RO-base -SPLIT  */
static char *rw_ext = "";      /* file extension for -RW-base/-DATA -SPLIT */

static char *level_strs[4];
    /* msglevel_info, msglevel_warning, msglevel_error, msglevel_fatal */
static int  errcount[4];

static char myname[32];

static int32 sectoffset;       /* object / library file managagement vars */
static int32 sectsize;
static char  *sectinram;
static int   openfiles, maxopenfiles;
static struct fentry *curfile;

static int32 area_index;
static int32 strtsize;
static int32 symcount;
static int32 eft_size, eft_extra;
static int32 sposn, strposn, shlposn, shl_chunk;

static int32 overlay_segments;
static int32 entryv_total;
static struct hentry *load_seg_and_go, *overlay_init, *dyn_link;
static struct hentry *sb_limit, *eft_offset, *eft_params;
static struct hentry *stub_0base, *shl_database, *shl_datasz;
static struct aentry *inter_LU_code = NULL, *inter_LU_data = NULL;

static struct globsym *unresolved_fn;

#define LISTBUFSIZE     1024
struct listblock
{
  struct listblock *prev;
  char buf[ LISTBUFSIZE ];
};

struct listspec
{
  struct listblock *topblock;
  size_t itemsize;
  size_t offset;
  size_t maxoffset;
};

static struct listspec reloclist;
static struct listspec aofreloclist;
#ifdef TARGET_HAS_AOUT
static struct listspec aoutreloclist;
#endif

struct globalfile
{
  FILE *handle;
  int32 currentpos;
};

static struct globalfile fout;

#define inform_count  errcount[0]
#define warning_count errcount[1]
#define error_count   errcount[2]
#define fatal_count   errcount[3] /* 0 or 1 */

#define CODE_AREA        0
#define DATA_AREA        1
#define BSS_AREA         2


static int reversing_bytes = 0;

static int32 hv(int32 v)                     /* to host value... */
{   /* Return v with the same endian-ness as the host */
    /* This mess generates better ARM code than the more obvious mess */
    /* and may eventually peephole to optimal code...                      */
    if (reversing_bytes)
    { unsigned32 t;
        /* t = v ^ (v ror 16) */
        t = v ^ ((v << 16) | (((unsigned32)v) >> 16));
        t &= ~0xff0000;
        /* v = v ror 8 */
        v = (v << 24) | (((unsigned32)v) >> 8);
        v = v ^ (t >> 8);
    }
    return v;
}

static int32 tv(int32 v)                     /* to target value... */
{
    return hv(v);
}

static int32 xvs(int32 v)              /* to/fm host value, short... */
{   /* Return v with the same endian-ness as the host */
    if (reversing_bytes)
    {   v = (((v & 0xff) << 24) | ((v & 0xff00) << 8)) >> 16;
    }
    return v;
}

#ifdef TARGET_HAS_AOF

static unsigned32 cf_magic = 0;        /* CF_MAGIC in target byte order */

static int is_cf_magic(int32 v)
{
    if (cf_magic == 0)
    {   if (v == CF_MAGIC) {cf_magic = v;  return 1;}
        reversing_bytes = 1;
        if (hv(v) == CF_MAGIC) {cf_magic = v;  return 1;}
        reversing_bytes = 0;
    }
    else if (v == cf_magic)
        return 1;
    return 0;
}

static int is_reversed_cf_magic(int32 v)
{   int was_reversing = reversing_bytes;
    int rc = 0;
    reversing_bytes = 1;
    if (hv(v) == cf_magic) rc = 1;
    reversing_bytes = was_reversing;
    return rc;
}

static int is_little_endian(void)
{
    return *((unsigned char *)&cf_magic) == (CF_MAGIC & 255);
}

static void target_increment(int32 *ip, int32 i)
{
    *ip = tv(hv(*ip) + i);
}

#endif /* TARGET_HAS_AOF */

static int cistrcmp(const char *s, const char *t)
{   int sch, tch;

    for (;;)
    {   sch = *s++;
        tch = *t++;
        if (sch == tch)
        {   if (sch == 0) return 0; else continue;
        }
        sch = LOWER(sch);
        tch = LOWER(tch);
        if (sch != tch)  return sch - tch;
    }
}

static char *bufcpy(char *t, const char *s, int maxlen)
{   char *r = t;
    while ((*t = *s) != 0 && maxlen > 1) {++t;  ++s;  --maxlen;}
    *t = 0;
    return r;
}

static int32 hashval(const char *name, int32 tabsize)
{
    int32 hash = 0;

    while( *name )
    {
        hash = HASH(hash, *name);
        name++;
    }
    return( hash & ( tabsize - 1L ) );
}

static void hashinit(struct htable *tab, size_t size, PFCS mget)
{
    struct hentry **h, **hend;

    tab->tablesize = size;
    tab->mget = mget;
    tab->table = (struct hentry **) mget(
        (int32)size * (int32)sizeof(struct hentry *));
    for (h = tab->table, hend = h + size; h<hend; *h++ = NULL);
}

static int lookenter(struct hentry **rh,
    char *name, struct htable *tab, PFI cmp)
{
    int32 hash;
    struct hentry *h;

    hash = hashval(name, tab->tablesize);
    h = tab->table[hash];
    while (h && cmp(h->name, name)) h = h->next;
    if (h == NULL)
    {   h = (struct hentry *) tab->mget(
                (int32)(size_t)(sizeof(struct hentry) + strlen(name)));
        strcpy(h->name, name);
        h->next = tab->table[hash];
        h->h_un.globval = NULL;
        tab->table[hash] = h;
        *rh = h;
        return 1;
    }
    *rh = h;
    return 0;
}

static struct hentry *enter(char *name, struct htable *tab)
{
    struct hentry *h;
    int32 hash;

    hash = hashval( name, tab->tablesize );
    h = (struct hentry *) tab->mget(
        (int32)(size_t)(sizeof(struct hentry) + strlen(name)));
    strcpy(h->name, name);
    h->next = tab->table[hash];
    tab->table[hash] = h;
    return h;
}

static struct hentry *lookup(const char *name, struct htable *tab)
{
    struct hentry *h;

    h = tab->table[ hashval( name, tab->tablesize ) ];
    while (h != NULL && StrNE(h->name, name))
        h = h->next;
    return h;
}

static void closeout(struct oventry *ov)
{
    if (fout.handle != NULL)
    {
        fclose( fout.handle );
#ifdef TARGET_IS_UNIX
        chmod(outf, 0775);
#else
#  ifdef LINKING_ON_RISCOS
        { int ftype = 0xffd;                    /* Data */
          if (output_type == AIF)
          { if (binaryflag == 0 && ov == &root && !moduleflag)
            { if (ddeflag && debugflag)
                  ftype = 0xfd3;                /* Debug */
              else
                  ftype = 0xff8;                /* Absolute */
            }
            else if (intellecflag)
                ftype = 0xfff;                  /* Text */
            else if (moduleflag)
                ftype = 0xffa;                  /* Module */
          }
          settype(outf, ftype);
        }
#  endif
#endif
        if (fatal_count || error_count)
        {   remove( outf );
            fprintf(stderr, msgtext(misc_removeoutput), SELF, outf);
        }
        fout.handle = NULL;
    }
}

static void endlink(int n)
{   struct fentry *fep;

    if (n)
    {   if (n != SIGINT && n!= SIGTERM)
            fprintf(stderr, msgtext(misc_internalerror), SELF);
        else
            fprintf(stderr, msgtext(misc_interrupted), SELF);
        fatal_count++;
    }
    else if (inform_count + warning_count + error_count)
    {   fprintf(stderr, msgtext(misc_finished),
            SELF, inform_count, warning_count, error_count);
    }

    closeout(&root);

    for (fep = clifilelist; fep; fep = fep->next)
        if (fep->fd >= 0) close(fep->fd);

    if (n || (error_count + fatal_count)) exit(1);

    exit(0);
}

static void msg(Message_t errn, ...)
{   char        *errtxt, *msgfmt;
    int         level;
    va_list        ap;

    va_start(ap, errn);
    errtxt = msgtext(errn);
    msgfmt = msgtext(MSG_FORMAT);
    level = *errtxt++ - '0';
    fprintf(stderr, msgfmt, SELF, level_strs[level]);
    vfprintf(stderr, errtxt, ap);
    va_end(ap);
    fputc('\n', stderr);
    errcount[level]++;
    if (level==3) endlink(0);
}

/* Allow for !!<areaname>$$Limit... */
#define AREANAMEXLEN  9

static char *mkname(const char *pre, const char *name, const char *post)
{   static char buf[MAXAREANAMELEN+AREANAMEXLEN+1];
    int ll = 0;
    char *s;

    if (pre != NULL)
    {
        bufcpy(buf, pre, sizeof(buf));
        ll = strlen(buf);
    }
    s = bufcpy(buf + ll, name, sizeof(buf) - ll);
    if (post != NULL)
    {   ll += strlen(s);
        bufcpy(buf + ll, post, sizeof(buf) - ll);
    }
    if (ll >= (MAXAREANAMELEN+AREANAMEXLEN)) msg(fatal_truncated(buf));
    return buf;
}

/*************************************************************************/
/* Memory management functions.                                          */
/*                                                                       */
/* Memory is managed as a heap of allocated blocks which (logically)     */
/* grows upwards and a stack of blocks which (logically) grows downwards.*/
/* Heap blocks are never freed; stack blocks are deallocated en-masse by */
/* discarding everything allocated since a previous mark_stack(). In     */
/* both cases, the areas are managed as a chain of large-ish blocks of   */
/* memory.                                                               */
/*************************************************************************/

static void zmem(char *block, size_t n)
{
    while (n-- > 0) *block++ = 0;
}

struct memblk
{   struct memblk *prev;
    char *limit;
    int32 size;
};

static struct memblk *free_blks = NULL,
    *heap_blks = NULL, *stack_blks = NULL, *cache_blks = NULL;
static char *stack_mark = NULL;

static int32 heap_sz = 0, stack_sz = 0, max_stack_sz = 0, cache_sz = 0;

#define  MEMBLKSZ  0xff00    /* < 65K - sizeof(struct memblk) */


static void free_cache_block(struct memblk *p)
{   struct fentry *fep;
    struct oentry *oep;
    char *buf;
    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   if ((buf = fep->filebuffer) != NULL &&
             buf > (char *)p && buf < ((char *)p + p->size))
        {   fep->filebuffer = NULL;
            if (verboseflag)
                msg(info_uncache(fep->fname));
        }
    }
    for (oep = objectlist;  oep != NULL;  oep = oep->next)
    {   if ((buf = oep->objbuffer) != NULL &&
             buf > (char *)p && buf < ((char *)p + p->size))
        {   oep->objbuffer = NULL;
            if (verboseflag)
                msg(info_uncache(oep->oname));
        }
    }
}

#ifdef LINKING_ON_MAC
#  define malloc(n)  Tracked_malloc(n)
#endif

static struct memblk *get_new_blk(size_t size)
{   struct memblk *p, **pp;
    if (size < MEMBLKSZ) size = MEMBLKSZ;
    size += sizeof(struct memblk);
    for (pp = &free_blks;  (p = *pp) != NULL;  pp = &(p->prev))
        if (p->size >= size)
        {   *pp = p->prev;
            size = (size_t)(p->size);
            break;
        }
    if (p == NULL)
    {   p = (struct memblk *) malloc(size);
        if (p == NULL)
        {   for (pp = &cache_blks;  (p = *pp) != NULL;  pp = &(p->prev))
                /* NB <MUST> use signed compare here as p->size can be -ve */
                if (p->size >= (int32)size)
                {   *pp = p->prev;
                    size = (size_t)(p->size);
                    free_cache_block(p);
                    break;
                }
        }
        if (p == NULL) msg(fatal_outmem);
    }
    p->limit = (char *)p + size;
    p->size = (int32)size;
#ifdef DEBUG_MEM
fprintf(stderr, "getnewblk(%ld) -> %p\n", p->size, p);
#endif
    return p;
}

#define ALLOCABLE(n)  ((int32)(size_t)(n) == (n))  /* may generate no code */

static size_t allocsize(int32 n)
{   n = (n + ALIGN_MASK) & ~ALIGN_MASK;
    if (!ALLOCABLE(n))
    {    msg(fatal_toobig(n));
    }
    return (size_t)n;
}

static char *halloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    for (p = heap_blks;  p != NULL;  p = p->prev)
        if ((p->limit - (char *)p) >= (n + sizeof(struct memblk))) break;
    if (p == NULL)
    {   p = get_new_blk(n);
        zmem((char *)p + sizeof(*p), (size_t)(p->size) - sizeof(*p));
        p->prev = heap_blks;
        heap_blks = p;
    }
    p->limit -= n;
    heap_sz += n;
    return p->limit;
}

static char *cache_alloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    p = cache_blks;
    if (p == NULL || (p->limit - (char *)p) < (n + sizeof(struct memblk)))
    {   size_t size = n;
        if (size < MEMBLKSZ) size = MEMBLKSZ;
        size += sizeof(struct memblk);
        p = (struct memblk *) malloc(size);
#ifdef DEBUG_MEM
fprintf(stderr, "cache_alloc(%d) -> new cache block %p\n", size, p);
#endif
        if (p == NULL) return NULL;
        p->limit = (char *)p + size;
        p->size = (int32)size;
        p->prev = cache_blks;
        cache_blks = p;
    }
    p->limit -= n;
    cache_sz += n;
#ifdef DEBUG_MEM
fprintf(stderr, "cache_alloc(%d) -> %p\n", n, p->limit);
#endif
    return p->limit;
}

#ifdef LINKING_ON_MAC
#  undef malloc
#endif

static char *lock_in_cache(char *a)
{   struct memblk *p;
    if (a == NULL) return NULL;
    for (p = cache_blks;  p != NULL;  p = p->prev)
    {   char *base = (char *)p;
        int32 size = p->size;
        if (size < 0) size = -size;
        if (a >= base && a < base + size)
        {   if (p->size < 0) return NULL;  /* already locked */
            p->size = -size;               /* now locked...  */
            return base;
        }
    }
    return NULL;
}

static void unlock_cache_block(char *base)
{   if (base != NULL)
    {   struct memblk *p = (struct memblk *)base;
        int32 size = p->size;
        if (size < 0) size = -size;
        p->size = size;                    /* unlocked... */
    }
}

static char *salloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    p = stack_blks;
    if (p == NULL || (p->limit - (char *)p) < (n + sizeof(struct memblk)))
    {   p = get_new_blk(n);
        p->prev = stack_blks;
        stack_blks = p;
    }
    p->limit -= n;
    stack_sz += n;
    if (stack_sz > max_stack_sz) max_stack_sz = stack_sz;
    return p->limit;
}

static void mark_stack(void)
{   char **mark = (char **) salloc((int32)sizeof(char *));
    *mark = stack_mark;
    stack_mark = (char *)mark;
}

static void pop_stack(void)
{   struct memblk *p, *prev;
    char *sp;
    for (p = stack_blks;  p != NULL;  p = prev)
    {   prev = p->prev;
        if (stack_mark >= p->limit &&
            stack_mark < ((char *)p + p->size))
        {   /* pop and re-zero part of a block */
            sp = p->limit;
            p->limit = stack_mark + sizeof(char *);
            stack_mark = *((char **)stack_mark);
            stack_sz -= (p->limit - sp);
            zmem(sp, (p->limit - sp));
            break;
        }
        /* pop whole block to free list */
        sp = p->limit;
        p->limit = (char *)p + p->size;
        stack_sz -= (p->limit - sp);
        zmem(sp, (p->limit - sp));
        p->prev = free_blks;
        free_blks = p;
    }
    stack_blks = p;
}


#ifdef LINKING_ON_ACORN_RISC_OS
/**********************************************************************
  C++ name demangling code
**********************************************************************/

extern int demangle(char *in, char *out);

static char *cplusplusname(char *s)
{
    static char *sbuf;

    if (!cplusplusflag) return s;
    if (!sbuf) sbuf = halloc(MAXDBUF);
    demangle(s, sbuf);
    return sbuf;
}

#else

#define cplusplusname(s) (s)

#endif



/**********************************************************************
  List management functions
  - these use heap to implement a stack of same-sized objects
  - LIFO (like stack)
  - heap is never freed (uses halloc)
**********************************************************************/

static void listinit( struct listspec *ls, size_t itemsize )
{
  ls->topblock = NULL;
  ls->itemsize = itemsize;
  ls->maxoffset = itemsize * ( LISTBUFSIZE / itemsize );
}

static void listpush( struct listspec *ls, char *item )
{
  struct listblock *newblock;

  if( ls->topblock == NULL || ls->offset == ls->maxoffset )
  {
    newblock = (struct listblock *)halloc( sizeof( struct listblock ) );
    newblock->prev = ls->topblock;

    ls->offset = 0;
    ls->topblock = newblock;
  }
  memcpy( &ls->topblock->buf[ ls->offset ], item, ls->itemsize );
  ls->offset += ls->itemsize;
}

static char *listpop( struct listspec *ls )
{
  if( ls->topblock != NULL )
  {
    if( ls->offset == 0 )
    {
      /* get previous block */
      ls->topblock = ls->topblock->prev;
      ls->offset = ls->maxoffset;
    }

    /* check ls->topblock again because there may be no previous block */
    if( ls->topblock != NULL )
    {
      ls->offset -= ls->itemsize;
      return( &ls->topblock->buf[ ls->offset ] );
    }
  }
  return( NULL );
}

static char *readfile(char *buff, int32 posn, int32 n)
{
    HOURGLASS();
#ifdef DEBUG
    printf( "readfile posn=%ld\n", posn );
#endif
    if (posn == curfile->posn || lseek(curfile->fd, posn, L_SET) != -1)
    {   if ((size_t)read(curfile->fd, buff, n) == n)
        {   curfile->posn = posn + n;
            return buff;
        }
    }
    msg(fatal_readerr(curfile->fname));
    /*NOTREACHED*/
    return "";
}

static void closefile(struct fentry *filelist)
{   struct fentry *fep;

    for (fep = filelist; fep; fep = fep->next)
        if (fep->fd >= 0)
        {   if (close(fep->fd)) msg(fatal_readerr(fep->fname));
            openfiles--;
            fep->fd = -1;
            break;
        }
}

static void setfile(struct fentry *fep)
{
    sectoffset = 0;
    sectsize = fep->size;
    curfile = fep;
    if ((sectinram = fep->filebuffer) == NULL)
        if (fep->fd < 0)
        {   if (openfiles >= maxopenfiles)
                closefile(clifilelist);
            if ((fep->fd = open(fep->fname, BINARY_OPEN_MODE)) < 0)
                msg(fatal_openerr(fep->fname));
            fep->posn = 0;
            openfiles++;
        }
}

static void setfilesection(struct fentry *fep, int32 offset, int32 size)
{   setfile(fep);
    sectoffset = offset;
    sectsize = size;
    if (sectinram) sectinram += offset;
}

static void setobject(struct oentry *oep)
{
    if ((sectinram = oep->objbuffer) != NULL)
    {   sectoffset = oep->offset;
        sectsize = oep->size;
        curfile = oep->fep;
    }
    else
        setfilesection(oep->fep, oep->offset, oep->size);
}

static char *map_perm(int32 posn, int32 n)
{   if (posn < 0 || (posn + n) > (sectoffset + sectsize))
        msg(fatal_badobj(curfile->fname));
    if (sectinram) return sectinram + posn;
    return readfile(halloc(n), sectoffset + posn, n);
}

static char *map(int32 posn, int32 n)
{
    if (posn < 0 || (posn + n) > (sectoffset + sectsize))
        msg(fatal_badobj(curfile->fname));
    if (sectinram) return sectinram + posn;
    return readfile(salloc(n), sectoffset + posn, n);
}

static char *map_tvtv(int32 posn, int32 n)
{
    return map(hv(posn), hv(n));
}

static void writedirect(char *buf, int32 n)
{
#ifdef DEBUG
    printf( "writedirect: n=%ld\n", n );
#endif
    if (fwrite(buf, 1, (size_t)n, fout.handle) != n)
        msg(fatal_writeerr(outf));
}

static unsigned intellec_base = 0;

static void intellec_write( char *buff, int32 n )
{
    char outrec[ 80+1 ];
    unsigned j, recsz;
    unsigned addr, ch, chksum, rev;
    char *s;

    /* Intellec format demands most-significant byte first... */
    /* Therefore, we reverse the order only if not reversing! */
    if (is_little_endian()) rev = 6; else rev = 0;

    addr = intellec_base;                   /* a WORD address */
    if (n & 3L)
    {   msg(fatal_byteslost((n & 3L), addr + (n /4)));
        n &= ~3L;
    }

    for (;  n > 0;  n -= 32)
    {   if (n < 32L) recsz = (unsigned)n/4; else recsz = 8;
        sprintf(outrec, ":%.2X %.4X 00 ", recsz, addr);
        s = outrec + 12;
        chksum = recsz + ((addr >> 8) & 255) + (addr & 255);
        addr += recsz;
        for (j = 0;  j < recsz * 8;  j += 2)
        {   ch = (unsigned char)(*buff++);
            chksum += ch;
            s[(j ^ rev) + 0] = "0123456789ABCDEF"[ch >> 4];
            s[(j ^ rev) + 1] = "0123456789ABCDEF"[ch & 15];
        }
        chksum = (-chksum) & 255;
        sprintf(s+j, " %.2X\n", chksum);

        fputs( outrec, fout.handle );
    }
    intellec_base = addr;
}

static void writebytes( int32 posn, char *buff, int32 n )
{
    HOURGLASS(); /* in options.h */
#ifdef DEBUG
    printf( "writebytes posn=%ld, n=%ld\n", posn, n );
#endif

    if (intellecflag)
    {
#ifdef DEBUG
        if( posn != fout.currentpos )
        {
            puts( "Warning: non-sequential intellec_write()" );
        }
#endif
        /* intellec writes are always sequential */
        intellec_write( buff, n );
    }
    else
    {
        if( posn != fout.currentpos )
        {
#ifdef DEBUG
            puts( "Seeking.." );
#endif
            fseek( fout.handle, posn, SEEK_SET );
        }

        writedirect( buff, n );
    }
    /* currentpos contains byte offset within BINARY file */
    /* the file position in an intellec file will differ */
    /* AN INTELLEC FILE MUST BE WRITTEN SEQUENTIALLY */
    fout.currentpos = posn + n;
}

/* Write an individual aif reloc entry to file */
/* RMJ: Remember to twiddle the data! */

static void writeaifrelocdirect( int32 reloc )
{
  int32 d;

#ifdef DEBUG
puts( "writeaifrelocdirect" );
#endif

  d = tv(reloc);
  writebytes( relocposn, (char *)&d, sizeof( int32 ) );
  relocposn += sizeof( int32 );
}

/* Writes a reloc list (of any type) to file (in LIFO order) */
/* updates global relocposn */

static void writereloclist( struct listspec *ls )
{ char *nextitem;

  while( ( nextitem = listpop( ls ) ) != NULL )
  {
    writebytes( relocposn, nextitem, ls->itemsize );
    relocposn += ls->itemsize;
popped++;
  }
}

#ifdef TARGET_HAS_AOUT
static time_t libtime;

static void write_aout_header(struct oventry *ov)
{
    struct exec_header hdr;
    zmem((char *) &hdr, sizeof(struct exec_header));
    if (plinkflag) {
        hdr.a_exec.a_magic = OMAGIC;
        hdr.a_exec.a_text = ov->textsize;
        hdr.a_exec.a_data = ov->datasize;
        hdr.a_exec.a_bss = ov->bsssize;
        if (entryflag)
            hdr.a_exec.a_entry = entrypoint - base;
        else
            hdr.a_exec.a_entry = entryarea->base + entryoffset - base;
        hdr.a_exec.a_syms = symcount * sizeof(struct nlist);
        relocposn = ov->textsize + ov->datasize + sizeof(struct exec);
    } else {
        if (entryflag)
            hdr.a_exec.a_entry = entrypoint;
        else if (entryarea)
            hdr.a_exec.a_entry = entryarea->base + entryoffset;
        hdr.a_exec.a_syms = symcount * sizeof(struct nlist);
        hdr.a_timestamp = time(0);
        if (nmagicflag) {
            hdr.a_exec.a_magic = IMAGIC;
            hdr.a_exec.a_text = ov->textsize + ov->datasize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_data = 0;
            hdr.a_exec.a_bss = ov->bsssize -
                        (hdr.a_exec.a_text - (ov->textsize + ov->datasize));
            if ((hdr.a_exec.a_text -
                            (ov->textsize + ov->datasize)) > ov->bsssize)
                hdr.a_exec.a_bss = 0;
        } else {
            hdr.a_exec.a_magic = ZMAGIC;
            hdr.a_exec.a_text = ov->textsize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_data = ov->datasize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_bss = ov->bsssize -
                                (hdr.a_exec.a_data - ov->datasize);
            if ((hdr.a_exec.a_data - ov->datasize) > ov->bsssize)
                hdr.a_exec.a_bss = 0;
            }
        }
        if (sharedlib) {
            hdr.a_exec.a_magic |= MF_USES_SL;
            hdr.a_shlibtime = libtime;
            strcpy(hdr.a_shlibname, sharedlib);
    }
    sposn = N_SYMOFF(hdr.a_exec);
    strposn = (sposn + hdr.a_exec.a_syms);
    if (plinkflag)
        writebytes(0, (char *) &hdr, sizeof(struct exec));
    else
        writebytes(0, (char *) &hdr, sizeof(struct exec_header));
    areaoutposn = fout.currentpos;
}

static void fix_up_aout_globals(void)
{
    sposn += reloc_count * sizeof(struct relocation_info);
    strposn += reloc_count * sizeof(struct relocation_info);
}

static void fix_up_aout_header(void)
{
    int32 t[2];
    t[0] = textrelocs * sizeof(struct relocation_info);
    t[1] = datarelocs * sizeof(struct relocation_info);
    writebytes(6 * sizeof(int32), (char *) t, 2 * sizeof(long));
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static void ensure_byte_order(unsigned32 *p, int32 n)
{   /* Ensure that the code pointed to by p has the right byte sex. */
    /* The size is given in BYTEs; the code MUST begin with NOP.    */
    if (p[0] != tv(AIF_NOOP))
    {   n /= sizeof(unsigned32);
        while (n > 0) {*p = tv(*p);  ++p;  --n;}
    }
}


static void write_aif_header(struct oventry *ov)
{
    int32 dbgtype, ep, sz;
    if (moduleflag)
        relocposn = srcposn + amf_reloc_code_size;
    else if (binaryflag != BIN_NOHDR && ov == &root)
    {   ensure_byte_order((unsigned32 *)aif_header, sizeof(struct aif_hdr));
        sz = ov->textsize;
        if (!binaryflag) sz += sizeof(struct aif_hdr);
        aif_header->rosize = tv(sz);
        sz += ov->datasize;
        aif_header->rwsize = tv(ov->datasize);
        aif_header->dbgsize = 0;
        if (debugflag)
        {   aif_header->dbgsize =
                tv(ov->dbgsize + sizeof(ItemSection) +
                   symcount * sizeof(ItemSymbol) + strtsize);
            /* IDJ: don't insert dbg SWI instruction AQU-00245 */
#if 0
            if (ddeflag) aif_header->debug_swi = tv(DEBUG_TASK);
#endif
            dbgtype = 0;
            if (symcount > 0)  dbgtype =  AIF_DBG_LL;
            if (has_dbg_areas) dbgtype |= AIF_DBG_SRC;
            aif_header->dbgtype = tv(dbgtype);
        }
        aif_header->zinitsize = tv(ov->bsssize);
        aif_header->workspace = tv(workspace);
        aif_header->imagebase = tv(base);
        /* set the AIF header's address mode... */
        if (code_attrs_set & code_attrs_unset & AOF_32bitAT)
            ep = 0L;
        else if (code_attrs_set & AOF_32bitAT)
            ep = 32L;
        else
            ep = 26L;
        if (rw_baseflag)
        {   ep |= AIF_DATABASAT;
            aif_header->data_base = tv(data_base);
        }
        aif_header->address_mode = tv(ep);

        if (ov->bsssize || debugflag)
            aif_header->zinit_br = tv(AIF_BLZINIT);

        if (scatterflag == OVERLAY)
        {   int32 aif_base = base +
                ((char *)&(aif_header->zinit_br) - (char *)(aif_header));
            aif_header->zinit_br =
                tv(AIF_BLAL | (overlay_init->h_un.globval->symval.value -
                           (aif_base + 8L)) >> 2);
        }

        if (entryarea == NULL && entryflag == 0)
            msg(fatal_noentry);
        else
        {   if (entryflag == 1)
            {   if (entryarea != NULL)
                {   ep = entryarea->base + entryoffset;
                    if (ep != entrypoint)
                        msg(err_entryconflict(entryarea->name));
                }
                else
                    ep = entrypoint;
            }
            else
                ep = entryarea->base + entryoffset;
            ep -= base;
            if (ep < (int32) sizeof(struct aif_hdr) && !binaryflag ||
                ep < 0L || ep > sz)
            {   int32 hdrsz = binaryflag ? 0L : (int32) sizeof(struct aif_hdr);
                if (entryflag == 1)
                    msg(err_badentry1(ep+base, hdrsz+base, sz+base));
                else
                    msg(err_badentry2(ep, hdrsz, sz));
                ep = hdrsz;
            }
            if (binaryflag)
                aif_header->entry_br = tv(ep);
            else
                aif_header->entry_br = tv(AIF_BLAL | (ep - 0x14) >> 2);
        }
        outsiz = hv(aif_header->dbgsize) +
                 ov->textsize + ov->datasize + (int32)sizeof(struct aif_hdr);
        sposn = sizeof(struct aif_hdr) + ov->textsize + ov->datasize +
                 ov->dbgsize + sizeof(ItemSection);
        strposn = (sposn + symcount * sizeof(ItemSymbol));
        srcposn = outsiz;
        if (relocflag)
        {   aif_header->reloc_br = tv(AIF_BLAL|(srcposn-(sizeof(long)+8)) >> 2);
        }
        else
        {   /* allocate buffers for block by block  output instead...   */
        }
        relocposn = srcposn + aif_reloc_code_size;
        writebytes(0, (char *) aif_header, sizeof(struct aif_hdr));
    }
    areaoutposn = fout.currentpos;
}

static int32 addchunk(cf_header *hdr, char *c_name, int32 offset, int32 size)
{   cf_entry *cfe;
    int32 numchunks = hv(hdr->cf_numchunks);

    size = (size + 3L) & ~3L;
    cfe = hdr->cf_chunks + numchunks;
    strncpy(cfe->cfe_key, c_name, sizeof(cfe->cfe_key));
    cfe->cfe_offset = tv(offset);
    cfe->cfe_size = tv(size);
    hdr->cf_numchunks = tv(numchunks+1);
    return offset + size;
}

static void addoutarea(aof_header *hdr, int32 i, int32 attrs,
    int32 size, int32 relocs, int32 strsize, int32 base)
{   aof_area *aofarea = &(hdr->aof_areas[i]);
    aofarea->area_name = tv(strtsize);
    aofarea->area_attributes = tv(attrs);
    aofarea->area_size = tv(size);
    aofarea->area_nrelocs = tv(relocs);
    aofarea->area_base = tv(base);
    strtsize += strsize;
}

static cf_entry *findchunk(cf_header *cfhdr, char *key)
{
    struct cf_entry *entry, *hdrend;

    for (entry = cfhdr->cf_chunks, hdrend = entry + hv(cfhdr->cf_maxchunks);
         entry < hdrend;
         entry++)
        if (entry->cfe_offset != 0 &&
            strncmp(entry->cfe_key, key, CF_KEYSIZE) == 0)
            return entry;
    return NULL;
}

static void write_aof_header(struct oventry *ov)
{
    size_t nareas;
    int32 chunkoffset, i, saved_strtsize;
    struct aentry *aep;

    if (ov == &root)
    {   nareas = (size_t) (ov->noofoutareas);
        if (!plinkflag)
        {   nareas = 0;
            if (ov->textsize)        /* Image$$RO */
                nareas++;
            if (ov->datasize)        /* Image$$RW */
                nareas++;
            if (debugflag)           /* Image$$RWO */
                nareas++;
            if (ov->bsssize)         /* Image$$ZI */
                nareas++;
        }
        chunkoffset = cfhdrsize =
            sizeof(cf_header) + (MAXCHUNKS-1) * sizeof(cf_entry);
        cfouthdr = (cf_header *) salloc(cfhdrsize);
        aofhdrsize = sizeof(aof_header) + (nareas - 1)*sizeof(aof_area);
        aofhdr = (aof_header *) salloc(aofhdrsize);
        cfouthdr->cf_magic = tv(CF_MAGIC);
        cfouthdr->cf_maxchunks = tv(MAXCHUNKS);
        cfouthdr->cf_numchunks = 0;
        zmem((char *) (cfouthdr->cf_chunks), MAXCHUNKS*sizeof(cf_entry));
        aofhdr->aof_type = tv(AOF_RELOC);
#ifdef FIX_ME_LATER
        if (!plinkflag) aofhdr->aof_type = tv(AOF_IMAGE1);
#endif
        aofhdr->aof_vsn = tv(AOF_VERSION);
        aofhdr->aof_nareas = tv((int32)nareas);
        aofhdr->aof_nsyms = tv(symcount);
        saved_strtsize = strtsize - 4;
        strtsize = 4;                        /* AREA names come first... */
        if (!plinkflag)
        {   int32 areano;
            areano = 0;
            aofhdr->aof_entryarea = 0;
            aofhdr->aof_entryoffset = 0;
            if (ov->textsize)
            {   addoutarea(aofhdr, areano++, AOF_ABSAT+AOF_RONLYAT+AOF_CODEAT,
                    ov->textsize, 0, sizeof("Image$$RO"), base);
                if (entryarea)
                {   aofhdr->aof_entryarea = tv(1);
                    aofhdr->aof_entryoffset = tv(entryarea->base - base);
                }
            }
            if (ov->datasize)
                addoutarea(aofhdr, areano++, AOF_ABSAT,
                        ov->datasize, 0, sizeof("Image$$RW"),
                        (base + ov->textsize));
            if (ov->bsssize)
                addoutarea(aofhdr, areano++, AOF_ABSAT + AOF_0INITAT,
                        ov->bsssize, 0, sizeof("Image$$ZI"),
                        (base + ov->textsize + ov->datasize));
            if (debugflag && !intellecflag)
                addoutarea(aofhdr, areano++, AOF_ABSAT + AOF_DEBUGAT,
                        ov->dbgsize, 0, sizeof("Image$$RW0"),
                        (base + ov->textsize + ov->datasize));
        }
        else /* (plinkflag) */
        {   aofhdr->aof_entryarea = 0;
            aofhdr->aof_entryoffset = 0;
            for (i = 0; i < ov->noofoutareas; i++)
            {   aep = ov->outareas[i];
                if (aep == outentryarea)
                {   aofhdr->aof_entryarea = tv(i + 1);
                    aofhdr->aof_entryoffset = tv(outentryofs);
                }
                addoutarea(aofhdr, i, aep->attrs,
                    aep->areasiz, aep->relocs,
                    (int32)(size_t)(strlen(aep->h->name)+1), aep->base);
            }
        }
        strtsize = (strtsize + saved_strtsize + 3L) & ~3L;
        chunkoffset = addchunk(cfouthdr, OBJ_HEAD, chunkoffset, aofhdrsize);
        chunkoffset = addchunk(cfouthdr, OBJ_IDFN, chunkoffset,
                          (sizeof(SELF) + sizeof(IDFNSTR)-2) +1);
        chunkoffset = addchunk(cfouthdr, OBJ_AREA, chunkoffset,
                          (ov->textsize + ov->datasize + ov->dbgsize));
        sposn = chunkoffset;
        if (debugflag || plinkflag)
        {   chunkoffset = addchunk(cfouthdr, OBJ_SYMT, chunkoffset,
                                       symcount * sizeof(aof_symbol));
            strposn = chunkoffset;
            chunkoffset = addchunk(cfouthdr, OBJ_STRT, chunkoffset, strtsize);
        }
        if (shl_flag == 2)
        {   shlposn = chunkoffset;
            shl_chunk = hv(cfouthdr->cf_numchunks);
            chunkoffset = addchunk(cfouthdr, SHL_LIBY, chunkoffset, 0L);
        }
        writebytes(0, (char *) cfouthdr, cfhdrsize);
        writebytes(cfhdrsize, (char *) aofhdr, aofhdrsize);
        writebytes(fout.currentpos, SELF, sizeof(SELF) -1);
        writebytes(fout.currentpos, IDFNSTR, sizeof(IDFNSTR) -1);

        /* IDJ: 14-Oct-94: bug fix for AQU-00046, AQU-00044, AQU-00062 */
        /* previously the following line produced faulty AOF file if the
         * length of the link version string was an exact multiple of 4!
         */
        writebytes(fout.currentpos,
                "\0\0\0", 4L - ((sizeof(SELF)+sizeof(IDFNSTR)-2) &3L));
    }
    areaoutposn = fout.currentpos;
    relocposn = areaoutposn + ov->outareas[0]->areasiz;
}

static void fix_up_aof_globals(void)
{   int32 relsize, i;
    cf_entry *cfe;
    struct oventry *ov = &root;

    relsize = reloc_count * sizeof(aof_reloc);
    sposn += relsize;
    strposn += relsize;
    for (i = 0; i < ov->noofoutareas; i++)
        aofhdr->aof_areas[i].area_nrelocs = tv(ov->outareas[i]->relocs);
    cfe = cfouthdr->cf_chunks;
    target_increment(&(cfe[2].cfe_size),   relsize);
    i = hv(cfouthdr->cf_numchunks);
    while (i > 3)
    {   --i;
        target_increment(&(cfe[i].cfe_offset), relsize);
    }
}

static void fix_up_aof_header(void)
{   writebytes(0, (char *) cfouthdr, cfhdrsize);
    writebytes(cfhdrsize, (char *) aofhdr, aofhdrsize);
}

#endif /* TARGET_HAS_AOF */

static void write_header(struct oventry *ov)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        write_aout_header(ov);
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AIF)
        write_aif_header(ov);
    else
      if (output_type == AOF)
        write_aof_header(ov);
    else
#endif
        msg(fatal_optype(output_type));
    lastoutarea = ov->outareas[0];
}

static void fix_up_globals(void)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        fix_up_aout_globals();
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AOF)
        fix_up_aof_globals();
    else
#endif
        msg(fatal_optype(output_type));
}

static void fix_up_header(void)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        fix_up_aout_header();
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AOF)
        fix_up_aof_header();
    else
#endif
        msg(fatal_optype(output_type));
}

/* The print names of attributes are potential candidates for translation */
/* into languages other than English. However, for now we don't do this.  */
/* It seems adequate to concentrate on translating messages themselves.   */

static void sprintattrs(char *buf, size_t buflen, int32 attrs)
{   static struct attribute {
        int32 field;
        char *name;
    }
    attrtab[] = {
        {AOF_ALMASK,    "area-alignment"},
        {AOF_ABSAT,     "ABS"      },
        {AOF_CODEAT,    "CODE"     },
        {AOF_COMDEFAT,  "COMDEF"   },
        {AOF_COMREFAT,  "COMREF"   },
        {AOF_0INITAT,   "0INIT"    },
        {AOF_RONLYAT,   "READONLY" },
        {AOF_PICAT,     "PIC"      },
        {AOF_DEBUGAT,   "DEBUG"    },
        {AOF_32bitAT,   "32bit"    },
        {AOF_REENTAT,   "REENTRANT"},
        {AOF_FP3AT,     "FPIS3",   },
        {AOF_NOSWSTKCK, "NO_SW_STACK_CHECK"},
        {AOF_BASEDAT,   "BASED",   },
        {AOF_SHLDATA,   "SHL-data",},
        {AOF_BASEMASK,  "base-register" }
    };

    struct attribute *p;
    char *spacer = "";
    size_t len;

    for (p = attrtab; p < (attrtab + sizeof(attrtab)/sizeof(attrtab[0])); ++p)
    {   if ((attrs & p->field) == 0) continue;
        len = strlen(p->name) + strlen(spacer);
        if (len >= buflen) continue;
        buflen -= len;
        sprintf(buf, "%s%s", spacer, p->name);
        buf += len;
        spacer = ", ";
    }
}

static void linksymbl(char *name, int32 b, int32 l);

static struct aentry *addarea(char *name, struct oentry *oep, int32 areaoff,
    int32 areasiz, int32 relocoff, int32 relocs, int32 attrs, int32 areano)
{
    struct aentry *a;

    if ((attrs & AOF_DEBUGAT) &&
        (output_type == AIF && binaryflag == BIN_NOHDR || output_type == AOUT))
        return NULL;

#ifdef __acorn
    /* we don't want auto -inclusion of debug areas, so we return prematurely
       IDJ: 20-nov-94
     */
    if ((attrs & AOF_DEBUGAT) && (output_type == AIF) && !debugflag)
    {
        has_dbg_areas = 1;  /* do this so we can warn about removal of dbg areas later */
        return NULL;
    }
#endif

    if (attrs & AOF_DEBUGAT) has_dbg_areas = 1;

/* Areas with COMMON or SHLDATA attributes have to be merged by name. The */
/* constraints on attributes are that SHLDATA and (COMDEF, COMREF) are    */
/* mutually exclusive. Otherwise, SHLDATA,DATA is treated like COMDEF and */
/* SHLDATA,0INIT is treated like COMREF. There may be many COMREFs and 0  */
/* or more COMDEFs. Where there are multiple COMREFs (or SHLDATA,0INITs), */
/* the area size is the maximum of the input area sizes; if there is a    */
/* COMDEF then it must have the maximum area size. If there are multiple  */
/* COMDEFs, they must all have the same size, number of relocations and   */
/* area contents.                                                         */

    if (attrs & (AOF_COMREFAT|AOF_COMDEFAT|AOF_SHLDATA))
    {   struct hentry *h;
        char buf[MAXSYMLEN];

        /* COMDEF and COMREF set is allowable and means COMDEF */
        if (attrs & AOF_COMDEFAT) attrs &= ~AOF_COMREFAT;

        /* COMDEF, 0INIT is allowable and means COMREF, 0INIT */
        if ((attrs & (AOF_COMDEFAT|AOF_0INITAT)) == (AOF_COMDEFAT|AOF_0INITAT))
            attrs = (attrs & ~AOF_COMDEFAT) | AOF_COMREFAT;

        /* COMREF means COMREF, 0INIT... */
        if (attrs & AOF_COMREFAT) attrs |= AOF_0INITAT;

        if ((attrs & AOF_SHLDATA) && (attrs & (AOF_COMREFAT|AOF_COMDEFAT)))
        {   msg(warn_diffattr0(name, oep->oname));
            attrs &= ~(AOF_COMREFAT|AOF_COMDEFAT);
        }

        if (lookenter(&h, name, &commontable, strcmp))
        {   /* Area hasn't been seen before, so create a new instance...  */
            /* which will be initialised below...                         */
            a = h->h_un.areaval = (struct aentry *)
                halloc((int32)(size_t)(sizeof(struct aentry)+strlen(name)));
            if (!(attrs & AOF_0INITAT))
                a->areaval = map_perm(areaoff, areasiz);
            goto new_area;
        }
        a = h->h_un.areaval;

        /* An area with this name has been seen before so check its       */
        /* attribute and and size compatibility.                          */

        if (((attrs ^ a->attrs) & AOF_SHLDATA) ||
            (attrs & AOF_SHLDATA) && ((attrs ^ a->attrs) & AOF_0INITAT))
        {   /* only one of the areas has the SHLDATA attribute, or both   */
            /* have and only one has the 0-initialised attribute...       */
            msg(warn_diffattr3(name, a->oep->oname, oep->oname));
            sprintattrs(buf, sizeof(buf),
                (a->attrs ^ attrs) & (AOF_SHLDATA|AOF_0INITAT));
            msg(info_diffattrs(buf));
            goto recover;
        }

        if (attrs & AOF_COMREFAT)
        {   /* any COMDEF must be as big as the biggest COMREF...         */
            if (areasiz > a->areasiz)
            {   if (a->attrs & AOF_COMDEFAT)
                    msg(warn_com_toobig(name, oep->oname, a->oep->oname));
                else
                    a->areasiz = areasiz;
            }
            return a;
        }

        if (attrs & AOF_SHLDATA)
        {   /* SHLDATA is a special kind of common data which can only be */
            /* commoned with SHLDATA of the same sort. Initialised data   */
            /* must be identical; 0INIT data accumulate the max length.   */
            if (attrs & AOF_0INITAT)
            {   if (areasiz > a->areasiz) a->areasiz = areasiz;
            }
            else if (areasiz != a->areasiz ||
                     relocs  != a->relocs  ||
                (int32)(size_t)areasiz != areasiz ||    /* 16-bit defence */
                    memcmp(a->areaval,
                        map(areaoff,areasiz), (size_t)areasiz) != 0)
            {
                msg(warn_diffarea(name, a->oep->oname, oep->oname));
                goto recover;
            }
            return a;
        }

        if (attrs & AOF_COMDEFAT)
        {   if (a->attrs & AOF_COMDEFAT)
            {   if (areasiz != a->areasiz ||
                    relocs  != a->relocs  ||
                (int32)(size_t)areasiz != areasiz ||    /* 16-bit defence */
                    memcmp(a->areaval,
                         map(areaoff,areasiz), (size_t)areasiz) != 0)
                {
                    msg(warn_diffarea(name, a->oep->oname, oep->oname));
                    goto recover;
                }
            }
            else
            {   /* the defining COMDEF corresponding to a previous COMREF */
                if (a->areasiz > areasiz)
                    msg(warn_com_toobig(name, oep->oname, a->oep->oname));
                a->areaoff = areaoff;
                a->areasiz = areasiz;
                a->areapad = 0;
                a->relocoff = relocoff;
                a->relocs = relocs;
                a->oep = oep;
                a->areano = areano;
                a->attrs = attrs;
            }
            return a;
        }
        /* Assert: This point is unreachable... die horribly if reached.  */
        endlink(-1);
    }
    /* Not a COMMON/SHLDATA area so create a new area instance...     */
    /* ...which will be initialised below...                          */
recover:
    a = (struct aentry *)
        halloc((int32)(size_t)(sizeof(struct aentry)+strlen(name)));
    a->areaval = NULL;
new_area:
    a->areaidx = ++area_index;
    a->areaoff = areaoff;
    a->areasiz = areasiz;
    a->areapad = 0;
    a->base = 0;
    a->relocoff = relocoff;
    a->relocs = relocs;
    a->attrs = attrs;
    a->oep = oep;
    a->areano = areano;
    a->flags = 0;
    a->refs = NULL;
    a->overseg = NULL;
    strcpy(a->name, name);
    *nextobjarea = a;
    a->h = NULL;
    a->nxt = NULL;
#ifdef LINKING_ON_ACORN_RISC_OS
    a->area__link_list = 0;
#endif
    nextobjarea = &(a->nxt);
    /* Create a placeholder for the $$Base and $$Limit symbols so that */
    /* unused AREA elimination can work properly... later filled in by */
    /* map_areas...                                                    */
    if (!plinkflag) linksymbl(name, 0, areasiz);
    return a;
}

#ifdef SARMAG
#  define MAGICSZ SARMAG
#else
#  define MAGICSZ 8
#endif

static int32 filetype(struct fentry *fep)
{
    setfile(fep);
    if (fep->size >= MAGICSZ)   /* Make sure small files don't fool us */
    {   fep->f_un.hdrptr = map_perm(0, MAGICSZ);
#ifdef TARGET_HAS_AOF
        if (is_cf_magic(fep->f_un.cfhdr->cf_magic))
        {        /* read rest of chunk file header */
            fep->f_un.hdrptr = map_perm(0,
                hv(fep->f_un.cfhdr->cf_maxchunks)*sizeof(cf_entry) +
                    sizeof(cf_header) - sizeof(cf_entry));

            if (findchunk(fep->f_un.cfhdr, OBJ_HEAD)) return AOF;
            if (findchunk(fep->f_un.cfhdr, LIB_DIRY)) return OFL;
        }
        else if (is_reversed_cf_magic(fep->f_un.cfhdr->cf_magic))
            msg(fatal_byteorder(fep->fname));
#endif
#ifdef TARGET_HAS_AOUT
        if (strncmp(fep->f_un.armag, ARMAG, MAGICSZ) == 0)
        {   fep->f_un.hdrptr = map_perm(0, MAGICSZ+sizeof(struct ar_hdr));
            return AR;
        }
        if (!N_BADMAG(*(fep->f_un.aouthdr)))
        {   if (fep->f_un.aouthdr->a_magic == OMAGIC)
                fep->f_un.hdrptr = map_perm(0, sizeof(struct exec));
            else
                fep->f_un.hdrptr = map_perm(0, sizeof(struct exec_header));
            return AOUT;
        }
#endif
    }
    msg(fatal_notobj(fep->fname));
    /*NOTREACHED*/
    return 0;
}

#undef MAGICSZ

static struct sym *makesym(int32 value, unsigned32 flags, struct aentry *area)
{   static struct sym tsym;
    zmem((char *)&tsym, sizeof(tsym));
    tsym.value = value;
    tsym.flags = flags;
    tsym.area = area;
    return &tsym;
}

static struct hentry *globinsert(const char *name, struct sym *sy, char *id)
{   char symname[MAXSYMLEN];
    struct hentry *nh;
    int is_new;
    struct sym *nh_sym;

    symname[0] = id[0];
    symname[1] = id[1];
    bufcpy(symname+2, name, sizeof(symname)-2);

#ifdef LINKING_ON_ACORN_RISC_OS
        if ((sy->flags & SYM_REFDEFMASK) == SYM_GLOBALDEFAT &&
                ((!strncmp(name, "__sti__", 7) || !strncmp(name, "__std__", 7))))
        {
            /* Make static global constructor and destructor functions locally visible only,
             * otherwise if you have multiple source files of the same name (albeit in different
             * directories) then these functions will cause duplicate symbol errors
             * The only reference to these functions should be from the struct __linkl.ctor
             * pointer anyway.  (sbrodie; 08/Nov/1998)
             */
            sy->flags = (sy->flags & ~SYM_REFDEFMASK) | SYM_LOCALDEFAT;
        }
#endif

    is_new = lookenter(&nh, symname, &globhashtable,
                       (sy->flags & SYM_NOCASEAT) ? cistrcmp : casefn);
    if (!is_new)
    {   nh_sym = &nh->h_un.globval->symval;
        /* Allow duplicate identical definitions... */
        if ((sy->flags & SYM_DEFAT)     &&
            sy->flags == (nh_sym->flags & ~SYM_LINKFLAGS) &&
            sy->area  == nh_sym->area   &&
            sy->value == nh_sym->value)
#ifdef LINKING_ON_ACORN_RISC_OS
                goto check_for_ctors;
#else
                return nh;
#endif
    }

    /* Force local definitions (guaranteed non-identical) to be entered, */
    /* even if a definition with the same name has been seen before.    */

    if ((sy->flags & SYM_REFDEFMASK) == SYM_LOCALDEFAT &&
        (nh = enter(symname, &globhashtable)) != NULL  || is_new)
    {
        (nh->h_un.globval = (struct globsym *)
                           halloc(sizeof(struct globsym)))->symval = *sy;
        if ((sy->flags & (SYM_REFDEFMASK+SYM_WEAKAT)) == SYM_REFAT)
            /* newly entered non-weak symbol reference */
            nh->h_un.globval->symval.flags |= SYM_SCANLIB;
        nh->h_un.globval->pcit_entry = -1;
        *nextglobsym = nh;
        nextglobsym = &(nh->h_un.globval->next);
    }
    else if (sy->flags & SYM_DEFAT)
    {   nh_sym = &nh->h_un.globval->symval;
        if (nh_sym->flags & SYM_DEFAT && !(sy->flags & SYM_LINKSYM))
        {   if (duplicateflag)
                msg(warn_glob_muldef(name, sy->refobj->oname,
                    nh_sym->refobj->oname));
            else
                msg(err_glob_muldef(name, sy->refobj->oname,
                    nh_sym->refobj->oname));
        }
        else
            *nh_sym = *sy;
    }
    else if ((sy->flags & SYM_WEAKAT) == 0 &&
                  /* re-entry of non-weak symbol reference */
             (nh->h_un.globval->symval.flags & SYM_WEAKAT))
    {             /* to existing weak reference... */
            nh->h_un.globval->symval.flags =
                (nh->h_un.globval->symval.flags & ~SYM_WEAKAT) | SYM_SCANLIB;
    }

#ifdef LINKING_ON_ACORN_RISC_OS
check_for_ctors:
    if (sy->flags & SYM_DEFAT) {
        if (!(sy->flags & SYM_REFAT)) {
            if (strncmp(name, "__link", 6) == 0) {
                struct aentry *aep;
                struct __link_list *__link;

                if (!cplusplusflag) {
                    if (!warned_cpp) {
                        msg(warn_cppignored_nocpp);
                        warned_cpp = 1;
                    }
                    return nh;
                }
                aep = sy->area;
                /*aep->included = 1;*/
                __link = (struct __link_list *)halloc(sizeof(struct __link_list));
                __link->next = g__link_list;
                g__link_list = __link;
                __link->chain = aep->area__link_list;
                aep->area__link_list = __link;
                __link->sy = &nh->h_un.globval->symval;
            }
        } else {
            if (strcmp(name, "__head") == 0) {
                if (!cplusplusflag) {
                    if (!warned_cpp) {
                        msg(warn_cppignored_nocpp);
                        warned_cpp = 1;
                    }
                    return nh;
                }
                g__head_sym = &nh->h_un.globval->symval;
            }
        }
    }
#endif

    return nh;
}

#ifdef TARGET_HAS_AOUT

static int32 map_aoutsymt(struct exec *aouthdr, int32 *toff, int32 *doff, int32     *boff, struct nlist **symt, char **strt)
{
    int32 offt;
    *toff = 0;
    *doff = aouthdr->a_text;
    *boff = *doff + aouthdr->a_data;
    offt = N_SYMOFF(*aouthdr);
    *symt = (struct nlist *) map(offt, aouthdr->a_syms + sizeof(int32));
    *strt = map(offt + aouthdr->a_syms + sizeof(int32), *((int32 *)
        (((char *) *symt) + aouthdr->a_syms)) - sizeof(int32)) - sizeof(int32);
    return (aouthdr->a_syms / sizeof(struct nlist));
}

#endif /* TARGET_HAS_AOUT */

static void load1_aout(struct oentry *oep)
{
#ifdef TARGET_HAS_AOUT
    char *strt, *cp, at;
    int32 nsyms, offt;
    struct hentry **symno, **syend;
    struct aentry *aep;
    struct exec *aouthdr;
    struct nlist *symt;
    struct globsym *gs;
    int32 toff, doff, boff, nv;

    if (debugflag && output_type == AOUT) {
        symcount++;
        strtsize += (int32)(strlen(oep->oname) + 1); /* AOUT Only */
    }
    aouthdr = oep->o_un.aouthdr;
    nsyms = map_aoutsymt(aouthdr, &toff, &doff, &boff, &symt, &strt);
    oep->arealist = (struct aentry **) halloc(3 * sizeof(struct aentry *));
    offt = N_TXTOFF(*aouthdr);
    oep->arealist[CODE_AREA] = addarea("Aout$$Code", oep, offt,
            aouthdr->a_text, offt + aouthdr->a_text + aouthdr->a_data,
            aouthdr->a_trsize / sizeof(struct relocation_info),
            AOF_CODEAT + AOF_RONLYAT, CODE_AREA);
    offt += aouthdr->a_text;
    oep->arealist[DATA_AREA] = addarea("Aout$$Data", oep, offt,
            aouthdr->a_data, offt + aouthdr->a_data + aouthdr->a_trsize,
            aouthdr->a_drsize / sizeof(struct relocation_info), 0, DATA_AREA);
    oep->arealist[BSS_AREA] = addarea("Aout$$Bss", oep, 0, aouthdr->a_bss,
            0,0, AOF_0INITAT, BSS_AREA);
    if (aouthdr->a_magic & MF_IS_SL) {
        int32 i;

        if (sharedlib) msg(err_mulsharedlibs);

        for (i = CODE_AREA; i <= BSS_AREA; i++)
            oep->arealist[i]->flags |= SHFLAG;
        sharedlib = ((struct exec_header *) (aouthdr))->a_shlibname;
        libtime = ((struct exec_header *) (aouthdr))->a_shlibtime;
    }
    if (entryarea != NULL) {
        entryarea = oep->arealist[CODE_AREA];
        entryoffset = aouthdr->a_entry;
    }
    oep->numtosym = (struct hentry **)
                                    halloc(nsyms * sizeof(struct hentry *));
    for (symno = oep->numtosym, syend = symno+nsyms; symno<syend;
                                                    symt++, symno++) {
        cp = strt + symt->n_un.n_strx;
        if (!(symt->n_type & N_EXT)) {
            if (debugflag && output_type == AOUT &&
                                            (cp == strt || *cp != 'L')) {
                symcount++;
                if (cp > strt)
                    strtsize += (int32)(strlen(cp) + 1); /* AOUT Only */
            }
            *symno=NULL;            /* Throw away debug symbol */
            continue;
        }
        nv = symt->n_value;
        cp = "";
        if (symt->n_un.n_strx)            /* 0 string idx => null string */
            cp = strt + symt->n_un.n_strx;
        aep = NULL;
        if (aouthdr->a_magic & MF_IS_SL) {
            if ((symt->n_type & N_TYPE) == N_UNDF)
                msg(err_extref(cp));
            at = SYM_ABSAT | SYM_GLOBALDEFAT;
        }
        else {
            at = SYM_REFAT;
            switch ((symt->n_type & N_TYPE) >> 1) {
            case N_UNDF >> 1:
                if (nv) {
                    aep = common;
                    /* at = SYM_COMMON; */
                }
                break;
            case N_ABS >> 1:
                at = SYM_ABSAT + SYM_GLOBALDEFAT;
                break;
            case N_TEXT >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[CODE_AREA];
                break;
            case N_DATA >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[DATA_AREA];
                nv -= doff;  /* Make sym rel to data area */
                break;
            case N_BSS >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[BSS_AREA];
                nv -= boff;  /* Make sym rel to bss area */
                break;
            }
        }
        {
            struct sym tsym;
            zmem((char *)&tsym, sizeof(tsym));
            tsym.value = nv;
            tsym.flags = at;
            tsym.dbxinfo = symt->n_desc;
            tsym.area = aep;
            tsym.refobj = oep;
            gs = (*symno=globinsert(cp, &tsym, "!!"))->h_un.globval;
        }
        if (!(gs->symval.flags & SYM_DEFAT))
            if (symt->n_value > gs->symval.value) {
                gs->symval.value = symt->n_value;
                gs->symval.area = common;
            }
    }
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOUT */
}

static size_t next_power_of_2(int32 n, size_t n0)
{   if ((int32)(size_t)n != n) msg(fatal_tabtoobig(n));
    while (n0 < n) n0 *= 2;
    return n0;
}

static void load1_aof(struct oentry *oep)
{
#ifdef TARGET_HAS_AOF
    char *strt, *id;
    int32 nsyms, offt, i, nareas, asize;
    unsigned32 attributes;
    struct hentry **symno, **syend;
    struct aentry *ai;
    cf_entry *ce;
    aof_header *hdr;
    aof_area *area;
    aof_symbol *symt = 0;
    struct htable areatable;

    ce = findchunk(oep->o_un.cfhdr, OBJ_HEAD); /* Read in header */
    hdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    nsyms = hv(hdr->aof_nsyms);

    if (nsyms > 0)
    {   /* Read in symbol table */
        ce = findchunk(oep->o_un.cfhdr, OBJ_SYMT);
        symt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    }
    ce = findchunk(oep->o_un.cfhdr, OBJ_STRT); /* Read in string table */
    strt = map_tvtv(ce->cfe_offset, ce->cfe_size);
    offt = hv(findchunk(oep->o_un.cfhdr, OBJ_AREA)->cfe_offset);
    oep->arealist = (struct aentry **)
            halloc(hv(hdr->aof_nareas) * sizeof(struct aentry *));
    nareas = hv(hdr->aof_nareas);

    mark_stack();
    hashinit(&areatable, next_power_of_2(nareas, OBJAREATABLESIZE), salloc);

    for (i = 0, area = hdr->aof_areas;  i < nareas;  ++i, ++area)
    {   asize = hv(area->area_size);
        attributes = hv(area->area_attributes);
        id  = strt + hv(area->area_name);
        oep->arealist[i] = ai = addarea(id, oep,
                offt, asize, offt + asize, hv(area->area_nrelocs),
                attributes, i);
        if (!(attributes & AOF_0INITAT))
            offt += asize + hv(area->area_nrelocs) * sizeof(aof_reloc);
        if (ai == NULL) continue;
        ai->base = hv(area->area_base);        /* in case of AOF_ABSAT */
        if (attributes & AOF_ABSAT && !baseflag)
        {   base = ai->base;
            baseflag = 1;
        }
        if (hv(hdr->aof_vsn) < 300) ai->flags |= NOINSTRELOC;
        enter(id, &areatable)->h_un.areaval = ai;
    }
    if (hdr->aof_entryarea != 0)
    {   struct hentry* h;
        if (entryarea != NULL) msg(err_mulentries);
        i = hv(hdr->aof_entryarea) - 1;
        h = lookup(strt + hv(hdr->aof_areas[i].area_name), &areatable);
        entryarea = h ? h->h_un.areaval : NULL;
        entryoffset = hv(hdr->aof_entryoffset);
    }
    oep->numtosym = (struct hentry **) halloc(nsyms*sizeof(struct hentry *));
    for (symno = oep->numtosym, syend = symno+nsyms; symno < syend; symt++)
    {   struct sym tsym;
        struct hentry* h;

        zmem((char *)&tsym, sizeof(tsym));
        tsym.flags = attributes = hv(symt->sym_AT);
        tsym.refobj = oep;
        tsym.value = hv(symt->sym_value);
        if ((attributes & (SYM_ABSAT + SYM_DEFAT)) == SYM_DEFAT)
        {   h = lookup(strt + hv(symt->sym_areaname), &areatable);
            tsym.area = h ? h->h_un.areaval : NULL;
        }
        if ((attributes & SYM_REFDEFMASK) == SYM_LOCALDEFAT)
            id = oep->objectid;
        else
            id = "!!";                       /* magic id for globals */
        *symno++ = globinsert(strt + hv(symt->sym_name), &tsym, id);
    }
    pop_stack();
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOF */
}


static void load1(struct oentry *oep)
{   char *lock;
    if (oep->objbuffer != NULL)
        /* cached object from uncached library */
        lock = lock_in_cache(oep->objbuffer);
    else
        /* cached object file... */
        lock = lock_in_cache(oep->fep->filebuffer);
    mark_stack();
    if (oep->fep->type & AOUT_MASK)
        load1_aout(oep);
    else
        load1_aof(oep);
    *nextglobsym = NULL;
    pop_stack();
    unlock_cache_block(lock);
}


static int special_aof(struct oentry *oep)
{
    int rc = 0;
#ifdef TARGET_HAS_AOF
    char *strt, *id;
    int32 nsyms, offt, i, nareas, asize;
    unsigned32 attributes;
    cf_entry *ce;
    aof_header *hdr;
    aof_area *area;
    aof_symbol *symt = 0;

    ce = findchunk(oep->o_un.cfhdr, OBJ_HEAD); /* Read in header */
    hdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    nsyms = hv(hdr->aof_nsyms);
    if (nsyms > 0)
    {   /* Read in symbol table */
        ce = findchunk(oep->o_un.cfhdr, OBJ_SYMT);
        symt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    }
    ce = findchunk(oep->o_un.cfhdr, OBJ_STRT); /* Read in string table */
    strt = map_tvtv(ce->cfe_offset, ce->cfe_size);
    offt = hv(findchunk(oep->o_un.cfhdr, OBJ_AREA)->cfe_offset);
    nareas = hv(hdr->aof_nareas);
    for (i = 0, area = hdr->aof_areas;  i < nareas;  ++i, ++area)
    {   asize = hv(area->area_size);
        attributes = hv(area->area_attributes);
        id = strt + hv(area->area_name);
        if (attributes & (AOF_CODEAT+AOF_RONLYAT) != (AOF_CODEAT+AOF_RONLYAT))
            continue;
        if (strcmp(id, "AIF_HDR") == 0 &&
            asize == (int32) sizeof(struct aif_hdr))
        {   aif_header = (struct aif_hdr *) map_perm(offt, asize);
            ++rc;
        }
        else if (strcmp(id, "AIF_RELOC") == 0)
        {   aif_reloc_code = (unsigned32 *) map_perm(offt, asize);
            aif_reloc_code_size = (int) asize;
            ++rc;
        }
        else if (strcmp(id, "AMF_RELOC") == 0)
        {   amf_reloc_code = (unsigned32 *) map_perm(offt, asize);
            amf_reloc_code_size = (int) asize;
            private_amf_reloc = 1;
            ++rc;
        }
        if (!(attributes & AOF_0INITAT))
            offt += asize + hv(area->area_nrelocs) * sizeof(aof_reloc);
    }
    if (rc > 0 && rc != (int)nareas)
        msg(err_badspecial(oep->fep->fname));
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOF */
    return rc;
}

static int32 attr_index(int32 attr)
{
/*
 * AREA sorting order:
 * 1 RO code
 * 2 RO based data
 * 3 RO data
 * 4 RW code
 * 5 Based data
 * 6 Data
 * 7 0init data
 * 8 Debug
 */
    if (attr & AOF_0INITAT)
        return 7L;
    else if (attr & AOF_DEBUGAT)
        return 8L;
    else
    {   int32 idx = 1;
        if ((attr & AOF_RONLYAT) == 0) idx += 3;
        if ((attr & AOF_CODEAT) == 0)
        {   if ((attr & AOF_BASEDAT) == 0) idx += 1;
            idx += 1;
        }
        return idx;
    }
}

static int32 areagtr(struct aentry *cs, struct aentry *ct)
{
    int32 csa, cta;
/*
 * AREA sorting (return 1 if cs should come after ct):
 *   RO code
 *   RO based data
 *   RO data
 *   RW code
 *   Based data
 *   Data
 *   0init data
 *   Debug
 * Areas unordered by attribute are ordered first by AREA name, then by
 * position in the input link list.
 */
    if ((ct->flags & AREA_LAST) || (cs->flags & AREA_FIRST)) return 0;
    if ((cs->flags & AREA_LAST) || (ct->flags & AREA_FIRST)) return 1;

    csa = attr_index(cs->attrs);
    cta = attr_index(ct->attrs);

    if (csa > cta) return 1;

    if (csa == cta)
    /* AREAs are unordered by attribute... */
    {   if (cs->oep && ct->oep)
        {   if (cs->oep->fep->type & AOUT_MASK)
            {   /* first area is a.out... */
                if (!(ct->oep->fep->type & AOUT_MASK))
                {   /* 2nd area isn't a.out... so order by output type */
                    if (output_type & AOUT_MASK) return 0;
                    return 1;
                }
            }
            else if (ct->oep->fep->type & AOUT_MASK)
            {   /* 1st area isn't a.out and 2nd area is - order by o/p type */
                if (output_type & AOUT_MASK) return 1;
                return 0;
            }
        }
        if (cs->h->name == ct->h->name)
        {   /* AREAs unorderd by name, so order them by input position */
            if (cs->areaidx > ct->areaidx) return 1;
        }
        else if (strcmp(cs->h->name, ct->h->name) > 0)
            return 1;
    }
    return 0;
}

/* See Sedgewick: Algorithms 2nd edition P 108 */

static void sortareas(struct aentry **a, int32 n)
{
    int32 h, i, j;
    struct aentry *v;

    a--;        /* Make array 1 origin */
    h = 1;
    do {h = h * 3 + 1;} while (h <= n);
    do
    {   h = h / 3;
        for (i = h + 1; i <= n; i++)
        {   v = a[i];
            j = i;
            while (j > h && areagtr(a[j-h], v))
            {   a[j] = a[j-h];
                j = j-h;
            }
            a[j] = v;
        }
    }
    while (h > 1);
}

static void linksym_0(const char *name, int32 val)
{   struct sym sy;
    struct hentry *h;
    struct globsym *gs;

    h = lookup(name, &globhashtable);

    if ((h == NULL) && intellecflag) return;

    if ((h != NULL) && ((gs = h->h_un.globval)->symval.flags & SYM_LINKSYM))
        gs->symval.value = val;
    else
    {   zmem((char *)&sy, sizeof(sy));
        sy.value = val;
        sy.area  = NULL;
        sy.flags = (SYM_ABSAT + SYM_GLOBALDEFAT + SYM_LINKSYM);
        (void) globinsert(name+2, &sy, "!!");
    }
}

static void linksym(char *name, int32 val)
{   linksym_0(mkname("!!", name, NULL), val);
}

static void oldsym(char *name, char *newname, int32 val)
{   if (lookup(name, &globhashtable))
    {   msg(warn_deprecated(name + 2, newname));
        linksym_0(name, val);
    }
}

static void linksymbl(char *name, int32 b, int32 l)
{   linksym_0(mkname("!!", name, "$$Base"),  b);
    linksym_0(mkname("!!", name, "$$Limit"), l);
}

static void hash_area(struct oventry *ov, struct aentry *aep, char *name)
{   struct hentry *h;
    int32 aep_attrs, h_attrs;
    char buf[MAXSYMLEN];

    aep_attrs = aep->attrs;
    if (aep_attrs & AOF_CODEAT)
    {   code_attrs_set |=
            (aep_attrs  & (AOF_32bitAT+AOF_REENTAT+AOF_NOSWSTKCK));
        code_attrs_unset |=
            (~aep_attrs & (AOF_32bitAT+AOF_REENTAT+AOF_NOSWSTKCK));
        h_attrs = (code_attrs_set & code_attrs_unset) & ~code_attrs_warned;
        if (h_attrs != 0L)
        {   msg(warn_diffattr1(aep->name, aep->oep->oname));
            sprintattrs(buf, sizeof(buf), h_attrs);
            msg(info_diffattrs(buf));
            code_attrs_warned |= h_attrs;
        }
        else if ((aep_attrs & AOF_FP3AT) && (match_opts & WARN_FP3))
            msg(warn_fp3(aep->name, aep->oep->oname));
    }
tryagain:
    if (lookenter(&h, name, &(ov->areatable), strcmp))
    {   h->h_un.areaval = (struct aentry *)
            halloc((int32)sizeof(struct aentry) + strlen(name));
        h->h_un.areaval->areaidx = ++area_index;
        h->h_un.areaval->attrs = aep_attrs;
        h->h_un.areaval->areaoff = 0;
        h->h_un.areaval->areasiz = 0;
        h->h_un.areaval->relocs = 0;
        h->h_un.areaval->base = -1;
        h->h_un.areaval->h = h;
        h->h_un.areaval->nxt = NULL;
        h->h_un.areaval->oep = NULL;
        strcpy(h->h_un.areaval->name, name);
        ov->noofoutareas++;
        *nextoutarea = h->h_un.areaval;
        nextoutarea = &(h->h_un.areaval->nxt);
    }
    else if (aep_attrs != (h_attrs = h->h_un.areaval->attrs))
    {   h->h_un.areaval->attrs |= (aep_attrs & AOF_FP3AT);
        h_attrs = (h_attrs & ~AOF_FP3AT) | (aep_attrs & AOF_FP3AT);
        if (aep_attrs != h_attrs && (h->h_un.areaval->flags & COMPLAINED) == 0)
        {   msg(warn_diffattr2(aep->name, aep->oep->oname));
            sprintattrs(buf, sizeof(buf), h_attrs ^ aep_attrs);
            msg(info_diffattrs(buf));
            h->h_un.areaval->flags |= COMPLAINED;
        }
        /* now check for essential differences that would affect ordering */
        if (aep_attrs & (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT))
            aep_attrs &= (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_BASEMASK);
        else
            aep_attrs &= (AOF_CODEAT+AOF_RONLYAT);
        if (h_attrs & (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT))
            h_attrs &= (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_BASEMASK);
        else
            h_attrs &= (AOF_CODEAT+AOF_RONLYAT);
        if (aep_attrs != h_attrs)
        {   int len;
            sprintf(buf, "%lx", aep_attrs);
            len = strlen(buf);
            name = bufcpy(buf+len, name, sizeof(buf)-len);
            goto tryagain;
        }
    }
    aep->h = h;
}

static void init_overseg(struct oventry *ov, char *file, char *overseg)
{
    ov->nextarea = &(ov->areas);
    ov->noofareas = 0;
    ov->areas = NULL;
    ov->next = NULL;
    ov->level_list = NULL;
    ov->noofoutareas = 0;
    ov->outarealist = NULL;
    ov->entryv = 0;
    ov->base = -1L;    /* temp, while parsing tree */
    hashinit(&(ov->areatable), AREATABLESIZE, halloc);
    if (scatterflag)
    {   ov->name = halloc((int32)(size_t)(strlen(file)+strlen(overseg)+2));
        strcat(strcat(strcpy(ov->name, file), PATHSEP), overseg);
    }
    else
    {   ov->name = halloc((int32)(size_t)(strlen(file) + 1));
        strcpy(ov->name, file);
    }
}

static struct oventry *add_segment(char *seg_name)
{
    struct oventry *ov, **po;
    struct lventry *lv, **pl;
    int l, sl;

    overlay_segments++;
    sl = l = 0;
    while (seg_name[l] != 0 && seg_name[l] != '_') ++l;

    pl = &(root.level_list);
    for (lv = root.level_list;  lv != NULL;  lv = lv->next)
    {   char *s = lv->seg_list->name;
        s += strlen(s);
        while (s != lv->seg_list->name && *s != PATHSEP[0]) --s;
#if 0
        if (strncmp(s+1, seg_name, l) == 0) break;
#else
        if (strncmp(s+1, seg_name, l) == 0)
        {
            sl = s + 1 - lv->seg_list->name;
            break;
        }
#endif
        pl = &(lv->next);
    }

    if (lv == NULL)
    {   lv = *pl = (struct lventry *) halloc(sizeof(struct lventry));
        lv->next = NULL;
        lv->clash = -1;    /* Doesn't clash with itself */
        lv->seg_list = NULL;
    }

    po = &(lv->seg_list);
    for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
    {
#if 0
        if (strlen(ov->name) > l && strcmp(ov->name+l, seg_name+l) == 0) break;
#else
        if (strlen(ov->name) > sl && strcmp(ov->name+sl, seg_name) == 0) break;
#endif
        po = &(ov->next);
    }

    if (ov == NULL)
    {   ov = *po = (struct oventry *) halloc(sizeof(struct oventry));
        init_overseg(ov, outfile, seg_name);
        ov->level = lv;
        lv->clash++;
    }
    return ov;
}

static void add_segment_object(struct oventry *ov, char *obj_name)
{
    int32 gotone;
    struct aentry *aep;

    gotone = 0;
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if (aep->oep != NULL && CiStrEQ(aep->oep->oname, obj_name) &&
            (aep->attrs & AOF_CODEAT))
        {   gotone = 1;
            aep->overseg = ov;
        }
    }
    if (!gotone) msg(err_ovobj(obj_name));
}

static void add_segment_object_area(struct oventry *ov,
    char *obj_name, char *area_name)
{
    int32 gotone;
    struct aentry *aep;

    aep = objarealist;
    gotone = 0;
    while (aep)
    {   if (aep->oep != NULL && CiStrEQ(aep->oep->oname, obj_name) &&
                                StrEQ(aep->name, area_name))
        {   gotone = 1;
            aep->overseg = ov;
        }
        aep = aep->nxt;
    }
    if (!gotone) msg(err_ovarea(obj_name, area_name));
}

#define BEFORE_SEGMENT_NAME     0
#define IN_SEGMENT_NAME         1
#define AFTER_SEGMENT_NAME      2
#define IN_SEGMENT_ADDRESS      3
#define BEFORE_OBJECT_NAME      4
#define IN_OBJECT_NAME          5
#define BEFORE_1ST_AREA_NAME    6
#define BEFORE_AREA_NAME        7
#define IN_AREA_NAME            8

static void build_overlay_tree(void)
{   FILE *iop;
    int incomment, c, eof, line, state, buflen;
    char name_buff[MAXNAMELEN], area_name_buff[MAXAREANAMELEN], *name = NULL;
    struct oventry *this_seg = NULL;

    if ((iop = fopen(scatterfile, "r")) == 0) msg(fatal_openerr(scatterfile));

    line = 1;
    incomment = 0;
    state = BEFORE_SEGMENT_NAME;
    buflen = eof = 0;
    do
    {   c = getc(iop);
        if (c == EOF) {c = '\n';  eof = 1;}
        if (c == '\n') line++;
        if (incomment)                  /* Skip comment after ';' */
        {   if (c != '\n') continue;    /* newline passed through */
            incomment = 0;
        }
        if (c == ';')                   /* Comment start */
        {   incomment = 1;
            continue;
        }
        if (c == '\\')                  /* Possible Line continuation */
        {   c = getc(iop);
            if (c != '\n') msg(fatal_badcont(scatterfile, line));
            c = ' ';                   /* Treat nl as space if continuing */
        }

        if (isspace(c) && state != IN_AREA_NAME ||
              c == '(' && state == IN_SEGMENT_NAME)
        {   if (state == IN_SEGMENT_NAME)
            {   *name = '\0';
                if ((name - name_buff) > OVERSEGNAMELEN)
                {   msg(warn_oversegname(name_buff, OVERSEGNAMELEN));
                    name_buff[OVERSEGNAMELEN] = 0;
                }
                this_seg = add_segment(name_buff);
                if (c == '(')
                {   name = area_name_buff;
                    buflen = MAXAREANAMELEN;
                    state = IN_SEGMENT_ADDRESS;
                    if (scatterflag == OVERLAY)
                        msg(fatal_misbra(scatterfile, line));
                }
                else
                {   state = BEFORE_OBJECT_NAME;
                    if (scatterflag == SCATTERIMAGE)
                        msg(fatal_missegbase(scatterfile, line, name_buff));
                }
            }
            else if (state == IN_OBJECT_NAME)
            {   *name = '\0';
                if (buflen <= 0) msg(fatal_truncated(name_buff));
                add_segment_object(this_seg, name_buff);
                state = BEFORE_OBJECT_NAME;
            }

            if (c == '\n')
            {   if (state == BEFORE_AREA_NAME)
                    msg(fatal_badnl(scatterfile, line));
                state = BEFORE_SEGMENT_NAME;
            }
            continue;
        }

        if (c == '(')
        {   if (state == IN_OBJECT_NAME)
            {   *name = '\0';
                if (buflen <= 0) msg(fatal_truncated(name_buff));
                state = BEFORE_1ST_AREA_NAME;
                continue;
            }
            msg(fatal_misbra(scatterfile, line));
        }

        if (c == ')' || c == ',' || isspace(c))
        {   if (state == IN_AREA_NAME)
            {   *name = 0;
                if (buflen <= 0) msg(fatal_truncated(area_name_buff));
                add_segment_object_area(this_seg, name_buff, area_name_buff);
                state = BEFORE_OBJECT_NAME;
                if (c == ',') state = BEFORE_AREA_NAME;
                continue;
            }
            else if (state == IN_SEGMENT_ADDRESS)
            {   *name = 0;
                state = BEFORE_OBJECT_NAME;
                continue;
            }
            msg(fatal_misterm(scatterfile, line));
        }

        if (iscntrl(c)) msg(fatal_badchar(scatterfile, line, c));

        if (state == BEFORE_SEGMENT_NAME)
        {   name = name_buff;
            state = IN_SEGMENT_NAME;
            buflen = MAXNAMELEN;
        }
        else if (state == BEFORE_OBJECT_NAME)
        {   name = name_buff;
            state = IN_OBJECT_NAME;
            buflen = MAXNAMELEN;
        }
        else if (state == BEFORE_1ST_AREA_NAME || state == BEFORE_AREA_NAME)
        {   name = area_name_buff;
            state = IN_AREA_NAME;
            buflen = MAXAREANAMELEN;
        }

        if (--buflen > 0) *name++ = c;
    }
    while (!eof);
    if (ferror(iop)) msg(fatal_readerr(scatterfile));
    fclose(iop);
}

static unsigned32 imm_to_val(unsigned32 imm)
{   unsigned32 ror;
    imm &= 0xfff;
    ror = (imm >> 8) << 1;
    imm &= 255;
    if (ror != 0) imm = (imm >> ror) | (imm << (32-ror));
    return imm;
}

static unsigned32 val_to_imm(unsigned32 val)
{   unsigned32 mask = 0xc0000000;
    int j = 24;
    /* return the most significant part of val as an immediate */
    while (j > 0 && (mask & val) == 0)
    {   j -= 2;
        mask >>= 2;
    }
    return ((32L - j) << 7) & 0xf00 | ((val >> j) & 255L);
}

static char *paramBlk = NULL;
static size_t paramBlkSz = 64, paramBlkUsed = 0;

static void addParamVal(char *s, size_t l)
{   size_t len = (l + 3) & ~3;
    if (paramBlk == NULL || (paramBlkUsed + len) > paramBlkSz)
    {   char *p;
        while (paramBlkSz < (paramBlkUsed + len)) paramBlkSz *= 2;
        p = halloc((int32)paramBlkSz);
        if (paramBlk != NULL) memcpy(p, paramBlk, paramBlkUsed);
        paramBlk = p;
    }
    s = (char *) memcpy(paramBlk+paramBlkUsed, s, l);
    while (l < len) s[l++] = 0;
    paramBlkUsed += len;
}

#define ADD_IP_R9      0xe289c000
#define ADD_IP_PC      0xe28fc000
#define ADD_IP_IP      0xe28cc000
#define LDMIA_IP_IPPC  0xe89c9000
#define STMFD_SP_REGS  0xe92d407f
#define LDR_R0_END     0xe51f0010
#define BAL            0xea000000

#define SIMPLE_CODE_STRIDE     16
#define REENTRANT_CODE_STRIDE  12

static int32 inter_LU_code_stride = 0;
static int32 *inter_LU_data_map = NULL;

static void make_inter_LU_data_map(void)
{   struct hentry *h;
    struct globsym *gs;
    int32 *map, j, t, n, offset;
/* Called to make a map of the inter_LU_data area of a reentrant stub */

    n = eft_size;
    inter_LU_data_map = map = (int32 *) halloc(n*sizeof(int32));

    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if ((gs->symval.flags & SYM_EFTSYM) && ((t = gs->pcit_entry) >= 0))
        {   map[t] = (gs->symval.flags & SYM_FNVSYM) ? 16 : 8;
        }
    }
    offset = 0;
    for (j = 0;  j < n;  ++j) offset += map[j];
    t = (n + eft_extra)*8;
    if (offset != t) msg(fatal_eftmap(n, t));
}

static void make_reentrant_inter_LU_object(void)
{   struct oentry *oep;
    struct fentry *fep;
    struct aentry *aep;
    unsigned32 codesz, coderelsz, datasz, datarelsz;
    unsigned32 *w, n, j, imm, offset;
    aof_reloc *r;

    inter_LU_code_stride = REENTRANT_CODE_STRIDE;
    n = eft_size;
    codesz = n * REENTRANT_CODE_STRIDE;
    coderelsz = n * sizeof(aof_reloc);
    datasz = (n + eft_extra)*8 + 16 + paramBlkUsed;
    datarelsz = (n+2) * sizeof(aof_reloc);
    if (libdataflag)
    {   datarelsz += sizeof(aof_reloc);
        datasz += 8;
    }

    {   char *anon = msgtext(misc_anon);
        fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
        strcpy(fep->fname, anon);
        fep->size = codesz + coderelsz + datasz + datarelsz;
        w = (unsigned32 *) (fep->filebuffer = halloc(fep->size));
    }
    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = (struct aentry **) halloc(sizeof(struct aentry *) * 2L);

    /* fake the veneer code area: read-only code */
    inter_LU_code = aep = addarea(interLUcodeName, oep,
        0, codesz, codesz, coderelsz/sizeof(aof_reloc),
        (AOF_CODEAT+AOF_RONLYAT+AOF_REENTAT)+2, 0L);
    oep->arealist[0] = aep;
    codesz += coderelsz;

    /* and fake the entry veneer data, RONLY, BASED r9 */
    inter_LU_data = aep = addarea(interLUdataName, oep,
        codesz, datasz, codesz+datasz, datarelsz/sizeof(aof_reloc),
        AOF_RONLYAT+AOF_BASEDAT+(9<<AOF_BASESHIFT)+2, 1L);
    oep->arealist[1] = aep;

    oep->numtosym = (struct hentry **) halloc(3L*sizeof(struct hentry *));
    oep->numtosym[0] = dyn_link;
    oep->numtosym[1] = sb_limit;    /* later optimised out */
    oep->numtosym[2] = stub_0base;  /* only used if libdataflag != 0 */

    make_inter_LU_data_map();

    /* initialise the code... */
    offset = 0;
    for (j = 0;  j < n;  ++j)
    {   imm = val_to_imm(offset);
        *w++ = tv(ADD_IP_R9 + imm);
        *w++ = tv(ADD_IP_IP + val_to_imm(offset - imm_to_val(imm)));
        *w++ = tv(LDMIA_IP_IPPC);
        offset += inter_LU_data_map[j];
    }
    /* ...and the code relocations */
    r = (aof_reloc *) w;
    for (j = 0;  j < n;  ++j)
    {   r->rel_offset = tv(j * REENTRANT_CODE_STRIDE);
        r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_B) + 1L);
        ++r;
    }

    /* ... now the data and data relocations... */
    w = (unsigned32 *)r;
    r = (aof_reloc *)((char *)w + datasz);
    datasz = (n + eft_extra)*8;
    offset = 0;
    for (j = 0;  j < n;  ++j)
    {   if (inter_LU_data_map[j] == 16)
        {   /* address-taken fn veneer */
            *w++ = tv(ADD_IP_PC);        /* inter-LU fn-call veneer */
            *w++ = tv(LDMIA_IP_IPPC);
            offset += 8;
        }
        *w++ = tv(j);
        *w++ = tv(datasz);
        r->rel_offset = tv(offset + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG) + 1L);
        ++r;
        offset += 8;
    }
    /* construct a PC-relative B __rt_dynlink */
    *w++ = tv(STMFD_SP_REGS);
    *w++ = tv(LDR_R0_END);
    *w++ = tv(BAL + ((unsigned32)(-4L - (datasz >> 2)) & 0x00ffffff));
    *w++ = 0;
    if (libdataflag)
    {   *w++ = tv(shl_datasz->h_un.globval->symval.value);
        *w++ = 0;
    }
    for (j = 0;  j < (int32)paramBlkUsed/sizeof(int32);  ++j)
        *w++ = ((int32 *)paramBlk)[j];
    r->rel_offset = tv(datasz + 8);
    r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_R+REL_A) + 0L);
    ++r;
    /* this relocation is later optimised out by AOF outputting */
    r->rel_offset = tv(datasz + 12);
    r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 1L);
    if (libdataflag)
    {   ++r;
        r->rel_offset = tv(datasz + 16 + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 2L);
    }
}

static void make_simple_inter_LU_object(void)
{   struct oentry *oep;
    struct fentry *fep;
    struct aentry *aep;
    unsigned32 datasz, datarelsz;
    unsigned32 *w, n, j;
    aof_reloc *r;

    inter_LU_code_stride = SIMPLE_CODE_STRIDE;
    n = eft_size;
    datasz = n * SIMPLE_CODE_STRIDE + 16 + paramBlkUsed;
    datarelsz = (n+2) * sizeof(aof_reloc);
    if (libdataflag)
    {   datarelsz += sizeof(aof_reloc);
        datasz += 8;
    }

    {   char *anon = msgtext(misc_anon);
        fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
        strcpy(fep->fname, anon);
        fep->size = datasz + datarelsz;
        w = (unsigned32 *) (fep->filebuffer = halloc(fep->size));
    }
    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = (struct aentry **) halloc(sizeof(struct aentry *) * 1L);

    /* and fake the entry veneer data, RONLY, BASED r9 */
    inter_LU_code = inter_LU_data = aep = addarea(interLUdataName, oep,
        0, datasz, datasz, datarelsz/sizeof(aof_reloc),
        AOF_RONLYAT+AOF_BASEDAT+(9<<AOF_BASESHIFT)+2, 0);
    oep->arealist[0] = aep;

    oep->numtosym = (struct hentry **) halloc(3L*sizeof(struct hentry *));
    oep->numtosym[0] = dyn_link;
    oep->numtosym[1] = sb_limit;    /* later optimised out */
    oep->numtosym[2] = stub_0base;  /* only used if libdataflag != 0 */

    /* Initialise the stub data... */
    for (j = 0;  j < n;  ++j)
    {   *w++ = tv(ADD_IP_PC);            /* inter-LU fn-call veneer */
        *w++ = tv(LDMIA_IP_IPPC);
        *w++ = tv(j);
        *w++ = tv(n * SIMPLE_CODE_STRIDE);
    }
    /* construct a PC-relative B __rt_dynlink */
    *w++ = tv(STMFD_SP_REGS);
    *w++ = tv(LDR_R0_END);
    *w++ = tv(BAL + ((unsigned32)(-4L - n*4 ) & 0x00ffffff));
    *w++ = 0;
    if (libdataflag)
    {   *w++ = tv(shl_datasz->h_un.globval->symval.value);
        *w++ = 0;
    }
    for (j = 0;  j < (int32)paramBlkUsed/sizeof(int32);  ++j)
        *w++ = ((int32 *)paramBlk)[j];
    /* ...and the data relocations */
    r = (aof_reloc *) w;
    for (j = 0;  j < n;  ++j)
    {   r->rel_offset = tv(j * SIMPLE_CODE_STRIDE + 12);
        r->rel_flags = tv((REL_TYPE2+REL_LONG) + 0L);
        ++r;
    }
    r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 8);
    r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_R+REL_A) + 0L);
    ++r;
    /* this relocation is later optimised out by AOF outputting */
    r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 12);
    r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 1L);
    if (libdataflag)
    {   ++r;
        r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 16 + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 2L);
    }
}

static void int32param(int32 val)
{   int32 v = tv(val);
    addParamVal((char *)&v, sizeof(int32));
}

static char *stringparam(char *s)
{   char *e = ++s;
    char *t = e;
    int ch = *e;
    for (;;)
    {   if (ch == 0) return e;
        if (ch == '\\' && (e[1] == '"' || e[1] == '\\'))
            ch = e[1];
        else if (ch == '"')
            ch = 0;
        *t++ = ch;
        if (ch == 0) break;
        ch = *(++e);
    }
    addParamVal(s, (t - s));
    return e+1;
}

static char *object_id(char *oname)
{   struct oentry *oep;
    if (*oname == 0) return "!!";
    for (oep = objectlist;  oep != NULL; oep = oep->next)
    {   if (CiStrEQ(oep->oname, oname)) return oep->objectid;
    }
    return NULL;
}

static char *getline(FILE *iop, char *file, int lineno)
{   static char linebuff[MAXLINESIZE];
    int c, n = MAXLINESIZE - 3;
    char *lp = linebuff+2;          /* allow access to lp[-1], lp[-2] */

    while ((c = getc(iop)) != EOF && c != '\n')
        if (n > 0) {*lp++ = c;  --n;}
    if (n == 0) msg(err_truncated(file, lineno));
    *lp = '\0';
    if (lp == (linebuff+2) && feof(iop)) return NULL;
    return linebuff+2;
}

static void eft_entry_name(char *name)
{   /* Assert: name[-1] and name[-2] exist and name[] is writable.      */
    /* For directly-exported names, the format is just <name>.          */
    /* For names exported via a function reference, the format is       */
    /* <name>(<module>). <module> must be omitted if a global symbol is */
    /* exported via a ref to a fn. Note that a global symbol may be     */
    /* exported twice: once directly and once via a function reference. */
    struct hentry *h;
    struct globsym *gs;
    char *s = name, *id = "!!", *oname;
    int ch;
    unsigned32 veneer_type;

    while ((ch = *s) != 0 && ch != '(') ++s;
    oname = s;
    if (ch == '(')
    {   oname = ++s;
        while ((ch = *s) != 0 && ch != ')') ++s;
        *s = 0;
        if (ch != ')')
        {   msg(warn_eftname(name, oname));
            return;
        }
        /* Assert: ch == ')' */
        if ((id = object_id(oname)) == NULL)
        {   *s = ')';                    /* restore - earlier set to 0 */
            msg(err_extnotfound(name));
            return;
        }
        oname[-1] = 0;                   /* terminate the name part */
        veneer_type = SYM_FNVSYM;
    }
    else
        veneer_type = SYM_DEXSYM;

    (name-2)[0] = id[0]; (name-2)[1] = id[1];
    h = lookup((name-2), &globhashtable);
    if (h == NULL)
    {   msg(err_extnotfound(name));
        return;
    }

    gs = h->h_un.globval;
    if (gs->symval.area == NULL) /* catch null area pointer first... */
        if (gs->symval.flags & SYM_ABSAT)
        {   gs->symval.flags |= SYM_LINKSYM;
            msg(warn_constmigrationtostub(name));
        }
        else
            msg(err_badsymbolforexportfromsharedlib(name));
    else
    {
        if ((gs->symval.area->attrs & AOF_CODEAT) &&
            !(gs->symval.flags & SYM_DATAAT))
        {   /* putatively exported code symbol... */
            if (gs->symval.flags & veneer_type)
            {   if (veneer_type == SYM_DEXSYM)
                    msg(warn_eftdup1(name));
                else
                    msg(warn_eftdup2(name, oname));
            }
            else
            {   if ((gs->symval.flags & SYM_EFTSYM) == 0)
                    gs->pcit_entry = eft_size++;
                if (veneer_type == SYM_FNVSYM) ++eft_extra;
            }
        }
        else if (veneer_type == SYM_FNVSYM)
            msg(err_eftnoncode(name, oname));
        gs->symval.flags |= (SYM_EFTSYM+veneer_type);
    }
}

#define NOT_JUST_DATA \
    (AOF_CODEAT+AOF_COMDEFAT+AOF_COMREFAT+AOF_0INITAT+\
         AOF_PICAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_SHLDATA)

static void mark_shl_data(char *oname, char *aname)
{   struct aentry *aep;
/* Subtlety: + on its own yields oname == "" which matches nothing. */
/* + () yields oname == NULL, aname == "" which matches anything.   */
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if (oname != NULL && CiStrNE(oname, aep->oep->oname))
            continue;
        if (aname != NULL && aname[0] != 0 && CiStrNE(aname, aep->name))
            continue;
        if ((aep->attrs & NOT_JUST_DATA) == 0) aep->flags |= SHLRODATA;
    }
}

#undef NOT_JUST_DATA

static void shl_data(char *s)
{   /* Assert: s is writable... */
    int ch;
    char *oname = NULL, *aname = NULL;

    libdataflag = 1;

    while ((ch = *s++) != 0)
    {   if (isspace(ch) || ch == ',') continue;
        if (ch == '(')
            oname = NULL;
        else
        {   oname = s-1;
            while (ch != 0 && ch != ' ' && ch != ',' && ch != '(') ch = *s++;
            s[-1] = 0;
        }
        if (ch == '(')
            while (ch != 0 && ch != ')')
            {   do ch = *s++; while (isspace(ch) || ch == ',');
                aname = s-1;
                while (ch != 0 && ch != ' ' && ch != ',' && ch != ')')
                    ch = *s++;
                s[-1] = 0;
                mark_shl_data(oname, aname);
            }
        else
            mark_shl_data(oname, NULL);
    }
}

static void build_shl_description(void)
{   struct oventry *ov;
    struct lventry *lv;
    struct aentry *aep;
    FILE *iop;
    char *s, *shl_image;
    int ch, lineno;
    int32 shldatasz;

    if ((iop = fopen(shl_file, "r")) == NULL) msg(fatal_openerr(shl_file));

    lineno = 0;
    shl_image = NULL;
    ch = 0;
    while ((s = getline(iop, shl_file, ++lineno)) != NULL)
    {   while (isspace(*s)) ++s;                  /* skip leading spaces */

        if (ch == '\\' ||                       /* continuation line, or */
            (ch = *s) == '>')                   /* found the output line */
        {   if (ch == '>')
            {   char *fname;
                if (shl_image != NULL)
                {   msg(warn_dupopline(shl_file, lineno));
                    continue;
                }
                do { ++s; } while (isspace(*s));          /* skip spaces */
                fname = s;
                while ((ch = *s) != 0 && ch != '(' && !isspace(ch)) ++s;
                                              /* skip to space, '(' or 0 */
                *s++ = 0;        /* and mark the end of the library name */
                if (ch == '(')
                {   shl_name = strcpy(halloc(strlen(fname)+1L), fname);
                    fname = s;
                    while ((ch = *s) != 0 && ch != ')') ++s;
                    if (ch == ')')
                        *s++ = 0, ch = *s;
                    else
                        msg(warn_missket(shl_file, lineno));
                    if (strcmp(fname, "-") == 0) shl_flag = 2;
                        /* all output in a single AOF file... */
                }
                shl_image = strcpy(halloc(strlen(fname)+1L), fname);
                if (shl_name == NULL) shl_name = shl_image;
            }
            /* now deal with other parameters to __rt_dynlink... */
            while (ch != 0)
            {   while (isspace(*s)) ++s;
                if ((ch = *s) == '"')
                    s = stringparam(s);
                else if (ch == ';')
                    break;
                else if (ch == '\\')
                {   while ((ch = s[1]) != 0 && ch != ';' && isspace(ch)) ++s;
                    if (ch == 0 || ch == ';')
                    {   ch = '\\';          /* continuation line follows */
                        break;
                    }
                }
                else if (ch != 0)             /* a number, by hypothesis */
                {   char *p, *s0;
                    errno = 0;
                    int32param(strtoul(s, &p, 0));
                    s0 = s;
                    do {++s;} while (*s != 0 && !isspace(*s));
                    if (s != p || errno == ERANGE)
                    {   *s = 0;
                        msg(err_eftbadnum(s0));
                    }
                }
                ch = *s;
            }
        }
        else if (ch == ';' || ch == 0)
            continue;
        else if (ch == '+')
            shl_data(s+1);
        else
            eft_entry_name(s);
    }
    if (ferror(iop)) msg(fatal_readerr(shl_file));
    fclose(iop);
    if (shl_image == NULL) msg(fatal_noshlimage(shl_file));

    root.level_list = lv = (struct lventry *) halloc(sizeof(struct lventry));
    lv->next = NULL;
    lv->clash = 0;
    lv->seg_list = ov = (struct oventry *) halloc(sizeof(struct oventry));
    init_overseg(ov, shl_image, NULL);
    ov->level = lv;

    shldatasz = 0;
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if ((aep->attrs & (AOF_CODEAT|AOF_RONLYAT)) == (AOF_CODEAT|AOF_RONLYAT))
        {   if ((aep->attrs & AOF_REENTAT) == 0)
                msg(warn_notreent(aep->name, aep->oep->oname,
                    aep->oep->fep->fname));
            aep->overseg = ov;
        }
        else if (aep->flags & SHLRODATA)
    /* mark_shl_data() has already been careful only to mark areas which */
    /* are suitable for inclusion in a shared library.                   */
        {   if (aep->relocs > 0)
                msg(err_relocdata(aep->oep->oname, aep->name));
            else
    /* Here, we clone the data area description, marking the clone read- */
    /* only and changing its name to SHL$$data. The original description */
    /* is marked 0-initialised and left in the stub as area $$0. Name    */
    /* and attribute homogenization are vital: otherwise AREA sorting    */
    /* might preclude a simple block copy from the library to the stub.  */
            {
                struct aentry *clone = addarea("SHL$$data", aep->oep,
                    aep->areaoff, aep->areasiz, /* no relocs */ 0, 0,
                    (aep->attrs & AOF_ALMASK) | AOF_RONLYAT, aep->areano);
                clone->overseg = ov;             /* the sharable library */
                strcpy(aep->name, "$$0");  /* always >=4 chars available */
                aep->attrs = (aep->attrs & AOF_ALMASK) | AOF_0INITAT;
                if (shldatasz == 0)
                {   stub_0base->h_un.globval->symval.area = aep;
                    shl_database->h_un.globval->symval.area = clone;
                }
                shldatasz += aep->areasiz;
            }
        }
    }
    shl_datasz->h_un.globval->symval.value = shldatasz;
    if (stub_0base->h_un.globval->symval.area == NULL)
        stub_0base->h_un.globval->symval.flags |= SYM_ABSAT;
    if (reent_flag)
        make_reentrant_inter_LU_object();
    else
        make_simple_inter_LU_object();
}

static int default_resolve(struct globsym *gs)
{   struct sym *sy;
    if (unresolved_fn == NULL ||
        ((sy = &(unresolved_fn->symval))->flags & SYM_DEFAT) == 0)
        return 0;
    gs->symval = *sy;
    return 1;
}

/*
 * Place areas in their overlay segments, only place those areas whose location
 * can be determined easily. Ie. Named in overlay file, object file areas,
 * data areas & areas not referenced by any other area.
 */
static void place_areas(void)
{
    struct aentry *aep, **prev;

    prev = &objarealist;
    aep = objarealist;
    while (aep)
    {   struct aentry *nextaep;
        nextaep = aep->nxt;
        if (aep->oep == NULL)            /* Anonymous area - goes in root */
            aep->overseg = &root;
        if (aep->overseg != NULL ||                  /* Seg already known */
                !(aep->oep->fep->type & LIB_MASK) ||        /* Obect file */
                !(aep->attrs & AOF_CODEAT) ||                /* Data area */
                (aep->refs == NULL))                  /* Isn't refered to */
        {   if (aep->overseg == NULL)     /* Seg not known - goes in root */
                aep->overseg = &root;
            *prev = aep->nxt;             /* Remove from global area list */
            *(aep->overseg->nextarea) = aep;        /* Add to end of list */
            aep->overseg->nextarea = &(aep->nxt);
            aep->nxt = NULL;
            aep->overseg->noofareas++;
        } else
            prev = &(aep->nxt);
        aep = nextaep;
    }
}

/*
 * Place library areas in overlay segments using following rule,
 *
 * If all references to an area automatically include from a library are from
 * the same overlay segment then the area is included in that segment.
 * Otherwise, it is included in the lowest-level segment which can be co-
 * resident with all segments referring to it.
 *
 * This rule was written for multiply layered overlay segment. Since we only
 * support single layering (ie. no local roots for the present) the rule can
 * be rewritten.
 *
 * If all references to an area automatically include from a library are from
 * the same overlay segment then the area is included in that segment.
 * Otherwise, it is included in the root segment.
 *
 * This solves everything except ...
 *        Mutually dependant library areas which are not referenced by any other
 *        area. Since these are likely to be in a minority they are placed in
 *        the root segment.
 */

static void place_libareas(void)
{
    struct aentryptr *refaep;
    struct aentry *aep, **prev;
    int32 placed, ne;
    struct oventry *ov;

    do {
        prev = &objarealist;
        aep = objarealist;
        placed = 0;                /* Flag to see if we placed an area */
        while (aep) {
            struct aentry *nextaep;

            nextaep = aep->nxt;
            refaep = aep->refs;
            ne = 0;                /* Flag to see if we found any segs != */
            ov = refaep->aep->overseg;
            do {
                if (!refaep->aep->overseg)
                    break;        /* Not all referee segs placed */
                if (refaep->aep->overseg != ov)
                    ne = 1;
            } while ((refaep = refaep->next) != 0);
            if (!refaep) {        /* Reached end of list - all segs defined */
                aep->overseg = ov;
                if (ne)
                    aep->overseg = &root;
                placed = 1;
                *prev = aep->nxt;          /* Remove from global area list */
                *(aep->overseg->nextarea) = aep;    /* Add to end of list */
                aep->overseg->nextarea = &(aep->nxt);
                aep->nxt = NULL;
                aep->overseg->noofareas++;
            } else
                prev = &(aep->nxt);
            aep = nextaep;
        }
    } while (placed);
    /* Now tag any remaining areas onto the root */
    aep = objarealist;
    *(root.nextarea) = objarealist;
    while (aep) {
        aep->overseg = &root;
        aep->overseg->noofareas++;
        aep = aep->nxt;
    }
}

static void addarearef(struct aentry *aep, struct aentry *reftoaep)
{   struct aentryptr *ah;

    for (ah = aep->refs;  ah != NULL; ah = ah->next)
        if (ah->aep == reftoaep) return;

    if (xrefflag)
    {   char *anon = msgtext(misc_anon);
        char *oname = aep->oep != NULL ? aep->oep->oname : anon;
        char *ref_oname = reftoaep->oep != NULL ? reftoaep->oep->oname : anon;
        printf(msgtext(misc_refto), oname,aep->name, ref_oname,reftoaep->name);
    }
    ah = (struct aentryptr *) halloc(sizeof(struct aentryptr));
    ah->aep = reftoaep;
    ah->next = aep->refs;
    aep->refs = ah;
}

static void add_area_xrefs(struct aentry *aep)
{
    int32 siz;
    struct aentry *rel_wrt_area = 0;
    struct sym *sy;
    struct hentry *h;

    /* If no relocs, or making shared lib and relocs are in code, */
    /* then there is nothing to do.                               */
    if (aep->relocs == 0 || shl_flag && (aep->attrs & AOF_CODEAT)) return;

    setobject(aep->oep);
    if (aep->oep->fep->type & AOUT_MASK)
    {
#ifdef TARGET_HAS_AOUT
        struct relocation_info *reloc, *r, *rend;

        siz = aep->relocs * sizeof(struct relocation_info);
        reloc = (struct relocation_info *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++)
        {   if (r->r_extern)
            {   h = aep->oep->numtosym[r->r_symbolnum];
                sy = &(h->h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT)
                    rel_wrt_area = sy->area;
            }
            else switch (r->r_symbolnum & N_TYPE)
            {
case N_TEXT:    rel_wrt_area = aep->oep->arealist[CODE_AREA];
                break;
case N_DATA:
                rel_wrt_area = aep->oep->arealist[DATA_AREA];
                break;
case N_BSS:
                rel_wrt_area = aep->oep->arealist[BSS_AREA];
                break;
            }
            if (rel_wrt_area != NULL && rel_wrt_area != aep)
                addarearef(aep, rel_wrt_area);
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        aof_reloc *reloc, *r, *rend;
        int32 symno, pcrel, addsym;
        unsigned32 rflags;

        siz = aep->relocs * sizeof(aof_reloc);
        reloc = (aof_reloc *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs;  r < rend;  r++)
        {   rflags = hv(r->rel_flags);
            if (rel_type2(rflags))
            {   symno  = rel2_sid(rflags);
                pcrel  = rel2_R(rflags);
                addsym = rel2_A(rflags);
            }
            else
            {   symno  = rel1_sid(rflags);
                pcrel  = rel1_R(rflags);
                addsym = rel1_A(rflags);
                if (pcrel) addsym = 1;
                if (!addsym) symno = aep->areano;
            }
            if (addsym)
            {   h = aep->oep->numtosym[symno];
                sy = &(h->h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT) rel_wrt_area = sy->area;
            }
            else
            {   rel_wrt_area = aep->oep->arealist[symno];
                sy = NULL;
                h = NULL;
            }
            if (rel_wrt_area == NULL) continue;
            if (shl_flag)
    /* Here, we must fault all references between the shared library and */
    /* its stub, save for those via the EFT function entry veneers.      */
            {   if (aep->overseg == rel_wrt_area->overseg) continue;
                if (rel_wrt_area->overseg == &root)
                {   /* (*aep) in the shared lib, relocated wrt its stub. */
                    msg(err_shlrefstub(aep->name, aep->oep->oname,
                        rel_wrt_area->name, rel_wrt_area->oep->oname));
                }
                else
                {   /* (*aep) in the stub, relocated wrt the shared lib. */
                    /* OK iff relocated wrt an EFTSYM code symbol.       */
                    if (rel_wrt_area->attrs & AOF_CODEAT &&
                        sy != NULL &&
                        (sy->flags & (SYM_EFTSYM+SYM_DATAAT)) == SYM_EFTSYM)
                        continue;
                    msg(err_stubrefshl(aep->name, aep->oep->oname,
                        rel_wrt_area->name, rel_wrt_area->oep->oname));
                }
                msg(info_badref(
                    h == NULL ? msgtext(misc_areabase) : h->name+2,
                    sy == NULL ? 0L : sy->value,
                    hv(r->rel_offset)));
            }
            else if (rel_wrt_area != aep)
                addarearef(aep, rel_wrt_area);
        }
#endif /* TARGET_HAS_AOF */
    }
}

static void reference(struct aentry *aep)
{   struct aentryptr *ah;

    aep->flags |= REFERENCED;
    for (ah = aep->refs;  ah != NULL; ah = ah->next)
    {   if (ah->aep->flags & REFERENCED) continue;
        reference(ah->aep);
    }
}

static void remove_unused_areas(void)
{
    struct aentry *aep, *nextaep, **prev;

    reference(entryarea);

    prev = &objarealist;
    aep = objarealist;
    while (aep != NULL)
    {   nextaep = aep->nxt;
        if ((aep->flags & REFERENCED) || (aep->attrs & AOF_DEBUGAT))
           prev = &(aep->nxt);
        else
        {   if (xrefflag || verboseflag)
            {   if (aep->oep != NULL)
                    msg(info_unused_AREA_3(
                        aep->name, aep->oep->oname, aep->oep->fep->fname));
                else
                    msg(info_unused_AREA_1(aep->name));
            }
            aep->flags |= UNUSEDAREA;
            *prev = nextaep;
        }
        aep = nextaep;
    }
}

static unsigned32 alignof(unsigned32 val, int32 attributes)
{   unsigned32 align = 4L;
    int32 n = attributes & 31L;
    if (!plinkflag) while (--n >= 2) align *= 2;
    align -= 1;
    return (val + align) & ~align;
}

static int32 map_areas(struct oventry *ov, int32 base)
{
    struct aentry **arealist, **areasend, **area, *aep;
    int32 dbgsize, bsssize, datasize, textsize;
    int32 tor, dor, bor, dbgor, siz, psiz, at, i;
    struct lventry *lv;
    char *name;

    ov->arealist = arealist = (struct aentry **)
                            halloc(ov->noofareas * sizeof(struct aentry *));
    nextoutarea = &(ov->outarealist);
    for (aep = ov->areas;  aep != NULL;  aep = aep->nxt)
    {   name = aep->name;
        if (shl_flag && ov == &root)
        {   if (aep->attrs & AOF_BASEDAT)
                name = interLUdataName;
            else if (aep->attrs & AOF_SHLDATA)
/* Stub data from other stubs, which shouldn't be included in this stub. */
/* However, refs to these areas need to be converted to symbol-relative  */
/* refs to the corresponding area$$Base symbols. We create the symbols   */
/* here to avoid phase-order problems in AOF output.                     */
            {   aep->h = globinsert(mkname(NULL, aep->name, "$$Base"),
                    makesym(0, SYM_REFAT+SYM_LINKSYM, NULL), "!!");
                aep->flags |= UNHASHED;
                --ov->noofareas;
                continue;
            }
            else if (!(aep->attrs & AOF_CODEAT))
            {   name = mkname(NULL, shl_name,
                    (aep->attrs & AOF_0INITAT) ? "$$zidata" : "$$data");
                aep->attrs |= AOF_SHLDATA;
            }
        }
        hash_area(ov, aep, name);
        *arealist++ = aep;
    }
    areasend = arealist;

    arealist = ov->arealist;
    sortareas(arealist, ov->noofareas);

    tor = base;
    dor = 0;          /* here, meaning dealing with read-only section */
    if (output_type == AIF && !binaryflag && !moduleflag && ov == &root)
        tor += (int32) sizeof(struct aif_hdr);
    dbgsize = bsssize = datasize = textsize = 0;
    for (area = arealist;  area < areasend;  area++)
    {   at = (*area)->attrs;
        siz = ((*area)->areasiz + 3) & ~3;
        if ((at & AOF_RONLYAT) == 0 && dor == 0)
        {   if (rw_baseflag) tor = data_base;
            dor = 1;  /* now dealing with read-write section */
        }
        i = tor;
        tor = alignof(i, at);
        siz += tor - i;
        tor += siz;
        if (((*area)->flags & SHFLAG) == 0)
        {   if (at & AOF_DEBUGAT)
                dbgsize += siz;
            else if (at & AOF_0INITAT)
                bsssize += siz;
            else if (at & AOF_RONLYAT)
                textsize += siz;
            else
                datasize += siz;
        }
    }

    psiz = 0;
    if (scatterflag == OVERLAY)
    {   if (ov == &root)
        {   int32 clash_total;
            struct oventry *ov1;

            clash_total = 0;
            for (lv = root.level_list;  lv != NULL;  lv = lv->next)
            {   for (ov1 = lv->seg_list;  ov1 != NULL;  ov1 = ov1->next)
                    clash_total += lv->clash;
            }
            psiz = overlay_segments * sizeof(struct pcit_section) +
                (entryv_total + overlay_segments + clash_total)*4;
            root.pcit_base = base + textsize + datasize +
                (int32) (binaryflag ? 0 : sizeof(struct aif_hdr));
        }
        else
        {   psiz = ov->entryv * 4;
            ov->pcit_base = root.pcit_base;
            root.pcit_base += psiz + 4 + sizeof(struct pcit_section) +
                ov->level->clash * 4;
        }
        datasize += psiz;
    }

    bor = dor = tor = base;  /* to keep cc's data flow happy ... */

    if (output_type == AOUT)
    {
#ifdef TARGET_HAS_AOUT
        if (plinkflag || nmagicflag) {
            dor = tor + textsize;
            bor = dor + datasize;
        } else {
            dor = (tor + textsize + (int32)(pagesize - 1)) &
                ~(int32)(pagesize - 1);
            bor = dor + datasize;
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        if (plinkflag)
        {   if (!shl_flag) dor = textsize;
            bor = dor + datasize;
        }
        else
        {   if (output_type == AIF && !binaryflag && !moduleflag &&
                ov == &root)
                tor += (int32) sizeof(struct aif_hdr);
            dor = (rw_baseflag ? data_base : tor + textsize);
            bor = dor + datasize;
            if (rw_baseflag &&
                ((dor >= tor && dor < tor+textsize) ||
                 (dor <  tor && (bor+bsssize) > tor)))
            {
                msg(err_base_overlap(data_base, base));
            }
        }
#endif
    }

    ov->torigin = tor;
    ov->dorigin = dor;
    ov->borigin = dbgor = bor;
    ov->base = base;
    for (area = arealist;  area < areasend;  area++)
    {   aep = *area;
        if (aep->flags & (AREA_FIRST|AREA_LAST))
        {   int32 flags = aep->flags & (AREA_FIRST|AREA_LAST);
#define MASK (AOF_RONLYAT|AOF_0INITAT|AOF_DEBUGAT)
            aep->flags = aep->flags & ~flags;
            if ((flags & AREA_FIRST) && (area + 1) < areasend &&
                attr_index(aep->attrs & MASK) >
                    attr_index(area[1]->attrs & MASK) ||
                (flags & AREA_LAST) && area > arealist &&
                attr_index(area[-1]->attrs & MASK) >
                    attr_index(aep->attrs & MASK))
            {   struct aentry *x = (flags & AREA_FIRST) ? area[1] : area[-1];
                char buf[64];
                sprintattrs(buf, sizeof(buf), (aep->attrs ^ x->attrs) & MASK);
                msg(err_incompat_attrib(x->oep->oname, x->name, buf));
            }
#undef MASK
            aep->flags |= flags;
        }
        at = aep->attrs;
        siz = aep->areasiz + 3 & ~3;
        if ((aep->flags & SHFLAG) == 0)
        {   base = aep->base;
            if (at & AOF_0INITAT)
            {   aep->base = alignof(bor, at);
                aep->areapad = aep->base - bor;
                siz += aep->areapad;
                bor += siz;
            }
            else if (at & AOF_DEBUGAT)
            {   aep->base = alignof(dbgor, at);
                aep->areapad = aep->base - dbgor;
                siz += aep->areapad;
                dbgor += siz;
            }
            else if (at & AOF_RONLYAT)
            {   aep->base = alignof(tor, at);
                aep->areapad = aep->base - tor;
                siz += aep->areapad;
                tor += siz;
            }
            else
            {   aep->base = alignof(dor, at);
                aep->areapad = aep->base - dor;
                siz += aep->areapad;
                dor += siz;
            }
            if ((at & AOF_ABSAT) && (base != aep->base))
                msg(fatal_baseclash(aep->name, base, aep->base));
        }
        if (aep == entryarea)
        {   if (ov != &root) msg(err_notroot);
            outentryarea = aep->h->h_un.areaval;
            outentryofs = entryoffset + outentryarea->base;
        }
        aep->h->h_un.areaval->areasiz += siz;
        if (aep->h->h_un.areaval->base == -1)
            aep->h->h_un.areaval->base = aep->base;
    }
    *nextoutarea = NULL;
    aep = ov->outarealist;
    {   int32 na = ov->noofoutareas;
        if (shl_flag == 2) na += 1L;
            /* extra slot for shared library read-only area */
        arealist = ov->outareas =
            (struct aentry **) halloc(na * sizeof(struct aentry *));
    }
    while (aep)
    {   *arealist++ = aep;
        if (!plinkflag)
            linksymbl(aep->name, aep->base, aep->base + aep->areasiz);
        else if (shl_flag && ov == &root &&
                 StrEQ(aep->h->name, interLUdataName))
        {
            struct globsym *gs = sb_limit->h_un.globval;
            gs->symval.flags |= SYM_LOCALDEFAT+SYM_ABSAT;
            gs->symval.value = aep->areasiz - paramBlkUsed;
        }
        aep = aep->nxt;
    }
    sortareas(ov->outareas, ov->noofoutareas);
    arealist = ov->outareas;
    for (i = ov->noofoutareas - 1; i>=0; i--)
        arealist[i]->areano = i;
    ov->textsize = textsize;
    ov->datasize = datasize;
    ov->bsssize = bsssize;
    ov->dbgsize = dbgsize;
    ov->limit = ov->base + textsize + datasize + bsssize - psiz;
    return textsize + datasize + bsssize;
}

static void do_final_symbol_matching()
{   struct hentry *h, *h2;
    struct globsym *gs;
    int32 siz, csize, r;
    char tmpsym[MAXSYMLEN];
    int match;

    if (plinkflag) return;

    match = match_opts;
    csize = 0;
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if (!(gs->symval.flags & SYM_DEFAT))
        {   char *cp;
            siz = gs->symval.value;
            cp = h->name;
            tmpsym[0] = *cp++;
            tmpsym[1] = *cp++;
            tmpsym[2] = 0;

            if (cp[0] == '_')
            {   if (match & MATCH_xTOx)
                    bufcpy(tmpsym+2, cp+1, sizeof(tmpsym)-2);
            }
            else
            {   while (*cp != 0) {if (*cp == '_') break; cp++;}
                if (cp[0] == '_')
                {   bufcpy(tmpsym, h->name, sizeof(tmpsym));
                    if (cp[1] == '_' && (match & MATCHx__yTOx) &&
                        (cp - h->name) < sizeof(tmpsym))
                        tmpsym[cp - h->name] = 0;

                    if (cp[1] != '_' && (match & MATCHx_yTOxDOTy) &&
                        (cp - h->name) < sizeof(tmpsym))
                        tmpsym[cp - h->name] = '.';
                }
                else if (match & MATCHxTO_x)
                {   tmpsym[2] = '_';
                    bufcpy(tmpsym + 3, h->name + 2, sizeof(tmpsym)-3);
                }
            }
            /* Assert: tmpsym now contains one of:                  */
            /*     h->name[0-1] - i.e. the empty name (can't match) */
            /*     h->name                            (can't match) */
            /*     a translated name, which might match.            */

            if (((h2 = lookup(tmpsym, &globhashtable)) != 0) &&
                 (h2->h_un.globval->symval.flags & SYM_DEFAT))
            {   gs->symval = h2->h_un.globval->symval;
                msg(warn_symbol_match(h->name+2, tmpsym+2));
                continue;
            }

            if ((h2 = lookup(h->name + 2, &commontable)) != 0)
            {   struct aentry *a = h2->h_un.areaval;
                if (siz > a->areasiz)
                {   if (a->attrs & AOF_0INITAT)
                        a->areasiz = siz;
                    else
                        msg(warn_comsym_toobig(h2->name, a->oep->oname));
                }
                gs->symval.flags = SYM_GLOBALDEFAT;
                gs->symval.area = a;
                gs->symval.value = 0;
            }
            else if (siz && !(gs->symval.flags & SYM_WEAKAT))
            {   gs->symval.flags = SYM_GLOBALDEFAT;             /* fixme */
                if (siz > 2)
                    r = 3;                /* 4-byte alignment by default */
                else if (siz == 2)
                    r = 1;                /* 2-byte for isolated shorts  */
                else /* siz == 1 */
                    r = 0;                /* 1-byte for isolated chars   */
                csize = (csize + r) & ~r;
                gs->symval.value = csize;
                csize += siz;
            }
        }
        if ((gs->symval.flags & SYM_DEFAT) &&
            gs->symval.area != NULL &&
            (gs->symval.area->attrs & AOF_CODEAT) &&
            gs->symval.area->overseg != NULL &&
            gs->symval.area->overseg != &root)
        {
            gs->pcit_entry = (gs->symval.area->overseg->entryv++);
            entryv_total++;
        }
    }
    if (common != NULL) common->areasiz = csize;
}

static void middle(void)
{
    struct hentry *h;
    struct globsym *gs;
    int32  undefs, torigin;
    struct lventry *lv;
    struct oventry *ov;

    torigin = base;
#ifdef TARGET_HAS_AOUT
    textoffset = base - pagesize;
    if (sharedlib) {
        torigin = lookup("!!_estext",
                                &globhashtable)->h_un.globval->symval.value;
        textoffset = (torigin & ~0x7fff) - 0x8000;
    }
#endif
    torigin += map_areas(&root, torigin) +
        (binaryflag || plinkflag ? 0L : (int32) sizeof(struct aif_hdr));
#ifdef TARGET_HAS_AOF
    if (moduleflag)
    {   srcposn = root.textsize + root.datasize;
        root.datasize += amf_reloc_code_size;
    }
#endif
    if (shl_flag)
    {   ov = root.level_list->seg_list;
        (void) map_areas(ov, 0);
        eft_params->h_un.globval->symval.value =
            (ov->limit - ov->base) + (eft_size+1)*sizeof(int32);
        eft_offset->h_un.globval->symval.value = (ov->limit - ov->base);
    }
    else
    {   int32 seg_size, max_seg_size;
        for (lv = root.level_list;  lv != NULL;  lv = lv->next)
        {   max_seg_size = 0;
/* LDS */   if (relocflag) torigin = 0;
            for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
            {   seg_size = map_areas(ov, torigin);
                if (seg_size > max_seg_size) max_seg_size = seg_size;
            }
            torigin += max_seg_size;
            total_seg_size += max_seg_size;
        }
        if (!plinkflag)
        {   linksym("_etext", root.torigin + root.textsize);
            linksym("_edata", root.dorigin + root.datasize);
            linksym("_end", root.borigin + root.bsssize);
            if (!sharedlib)
            {   linksym("_estext", root.torigin);
#ifdef USRSTACK
                linksym("_esdata", USRSTACK);
#endif
            }
linksymbl("Image$$RO", root.torigin, root.torigin + root.textsize);
linksymbl("Image$$RW", root.dorigin, root.borigin+root.bsssize+total_seg_size);
linksymbl("Image$$ZI", root.borigin, root.borigin+root.bsssize+total_seg_size);
oldsym("!!Image$$CodeBase",  "Image$$RO$$Base", root.torigin);
oldsym("!!Image$$CodeLimit", "Image$$RO$$Limit", root.torigin+root.textsize);
oldsym("!!Image$$DataBase",  "Image$$RW$$Base", root.dorigin);
oldsym("!!Image$$DataLimit", "Image$$RW$$Limit",
     root.borigin + root.bsssize + total_seg_size);
            if (moduleflag) linksym("__RelocCode", root.torigin + srcposn);
        }
    }
    *nextglobsym = NULL;
    undefs = 0;
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if ((!shl_flag || (gs->symval.flags & (SYM_EFTSYM+SYM_LINKSYM))) &&
                (gs->symval.area == NULL ||
                 !(gs->symval.area->flags & UNUSEDAREA)))
        {
            if (debugflag ||
#ifdef LINKING_ON_ACORN_RISC_OS
                plinkflag && strncmp(h->name+2, "__link", 6) == 0 ||
#endif
                plinkflag &&
                ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT ||
                    output_type == AOUT))
            {   gs->symval.symno = symcount;
                symcount++;
                strtsize += (int32)(size_t)(strlen(h->name));
                    /* The 2 char prefix to h->name is not output, but here */
                    /* reserves space for a for a len byte and a final NUL. */
#ifdef USE_PSTRING_SYMBOLS
                if (plinkflag)       /* No len byte when partial linking... */
#endif                               /* ... nor when !USE_PSTRING_SYMBOLS.  */
                    strtsize -= 1L;
            }
        }
        if (!(gs->symval.flags & SYM_DEFAT))
        {   if (gs->symval.flags & SYM_WEAKAT)
                gs->symval.value = 0;
            else if ((!plinkflag ||
                      shl_flag && !(gs->symval.flags & SYM_LINKSYM)) &&
                     !default_resolve(gs))
            {   struct oentry *oep = gs->symval.refobj;
                if (undefs == 0) msg(err_undefsyms);
                undefs++;
                if (oep == NULL)
                    msg(info_undefsym1(cplusplusname(h->name+2)));
                else if (oep->fep->type & LIB_MASK)
                    msg(info_undefsym3(cplusplusname(h->name+2), oep->fep->fname, oep->oname));
                else
                    msg(info_undefsym2(cplusplusname(h->name+2), oep->fep->fname));
            }
        }
        else if (!(gs->symval.flags & SYM_ABSAT) && gs->symval.area != NULL)
            /* SYM_ABSAT <=iff=> area == NULL... but code it defensively */
            gs->symval.value += gs->symval.area->base;
    }
    strtsize = (strtsize + 3L) & ~3L;
}

static void writereloc(int32 offset, int32 dtod)
{   /* Get very fussy about when to allow the new bit marking
     * Data->Data relocation to be included in the relocation entry:
     * must avoid confusing older code!
     */
    int32 ddbit = (dtod && moduleflag && !private_amf_reloc) ? 1 << 1 : 0;
    int32 t = tv(offset | ddbit);
    /* If we are linking with -rmf and -base, then this is a ROM link, so we
     * can omit non data->data relocations for efficiency.
     */
    if (baseflag && moduleflag && !dtod)
        return;
    listpush( &reloclist, (char *)&t );
    reloc_count++;
}

#ifdef TARGET_HAS_AOUT

static void writeaoutreloc( struct relocation_info *r )
{
    listpush( &aoutreloclist, (char *)r );
    reloc_count++;
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static void writeaofreloc(int32 offset, int32 rflags)
{
    aof_reloc r;

    r.rel_offset = tv(offset);
    r.rel_flags  = tv(rflags);
    /* writebytes(relocposn, (char *) &r, sizeof(aof_reloc)); */
    /* relocposn += sizeof(aof_reloc); */
    listpush( &aofreloclist, (char *)&r );
    reloc_count++;
}

#endif /* TARGET_HAS_AOF */

static int32 instr_offset(int32 *p, int lim)
{   int32 v = hv(*p), op;

    if ((op = (v & 0x0e000000)) == 0x0a000000)         /* B, BL */
    {   /* B or BL */
        return (v << 8) >> 6;                          /* byte offset */
    }

    if (lim < 0) return -1L;    /* no instruction sequence relocation */

    if (op == 0x04000000 ||                            /* LDR/STR */
        (op = (v & 0x0ff00000)) == 0x02800000 ||       /* ADD immediate */
        op == 0x02400000)                              /* SUB immediate */
    {   int icount = 0;
        unsigned32 Rd = (unsigned32)-1;
        int32 offset = 0;

        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   Rd = v & 0x0000f000;
            /* Loop Invariant: lim == 0 || icount < lim */
            do                                         /* 1-3 ADD/SUBs */
            {   v = imm_to_val(v);
                if (op == 0x02400000) v = -v;          /* SUB */
                offset += v;                           /* byte offset */
                ++icount;
                if (icount == lim) return offset;
                v = hv(p[icount]);
            }
            while (icount < 3 && (v & 0x0ff00000) == op &&
                   (v & 0x0000f000) == Rd && ((v & 0x000f0000) >> 4) == Rd);
            op = (v & 0x0e000000);
        }
        /* ... followed by an LDR or STR... */
        /* Assert: lim == 0 || icount < lim */
        if (op == 0x04000000 &&
            (Rd == -1 || ((v & 0x000f0000) >> 4) == Rd))
        {   /* LDR/STR immediate */
            op = v & 0xfffff000;
            v &= 0xfff;                                /* byte offset */
            if ((op & 0x00800000) == 0) v = -v;
            offset += v;
        }
        return offset;
    }
    /* else error - not handled */
    return  -1L;
}

static int32 instr_reloc(int32 *p, int32 value, int lim)
{   int32 v = hv(*p), op;

    if ((op = (v & 0x0e000000)) == 0x0a000000)
    {   /* B or BL */
        int32 wordvalue = (value >> 2);
        *p = tv((v & 0xff000000) | (wordvalue & 0x00ffffff));
        value -= (wordvalue << 2);                   /* should be 0 */
        if (value != 0) msg(err_relocB);
        return value;
    }

    if (lim < 0) goto fail;    /* no instruction sequence relocation */

    if (op == 0x04000000 ||                            /* LDR/STR */
        (op = (v & 0x0ff00000)) == 0x02800000 ||       /* ADD immediate */
        op == 0x02400000)                              /* SUB immediate */
    {   int icount;
        int32 imm, xx;
        unsigned32 instr = 0;

        /* Count the number of instructions in the candidate sequence */
        icount = 0;
        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   unsigned32 Rd = v & 0x0000f000;
            for (icount = 1;  icount < 3 && icount != lim;  ++icount)
            {   instr = hv(p[icount]);
                if ((instr & 0x0ff00000) != op ||
                    (instr & 0x0000f000) != Rd ||
                    ((instr & 0x000f0000) >> 4) != Rd)
                {   instr = (instr & 0x0e000000);
                    break;
                }
            }
        }
        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   int n;
            if (instr == 0x04000000 && icount != lim)  /* LDR/STR follows */
            {   /* try to preserve the following LDR/STR offset */
                imm = xx = value - instr_offset(p+icount, 1);
                if (imm < 0) imm = -imm;
                if ((imm >> (icount*8)) == 0)
                {   value = xx;
                    lim = icount; /* ignore following LDR/STR */
                }
                else
                    lim = 0;      /* modify following LDR/STR */
            }
            else
                lim = icount;         /* no following LDR/STR */
            if (value < 0)
            {   instr = 0x02400000;                    /* SUB */
                value = -value;
            }
            else
                instr = 0x02800000;                    /* ADD */
            for (n = 0;  n < icount;  ++n)
            {   imm = val_to_imm(value);
                value -= imm_to_val(imm);
                *p++ = tv((v & 0xf00ff000) | instr | imm);
                v = hv(*p);
            }
            if (value == 0)  /* completed the relocation successfully */
                return 0;
            if (lim != 0)  /* not yet finished and no LDR/STR follows */
                goto fail;
            /* restore the sign of the residuum ready for the LDR/STR */
            if (instr == 0x02400000) /* SUB */ value = -value;
        }
        /* ... followed by an LDR or STR... */
        instr = v & 0xff7ff000;
        if (value < 0)
            value = -value;
        else
            instr |= 0x00800000;
        *p = tv(instr | (value & 0xfff));
        value &= 0xfffff000;                      /* should now be 0 */
    }
fail:
    if (value != 0 || lim < 0) msg(err_relocseq);
    return value;
}


static int32 overseg_entry(int32 index, struct sym *sy)
{
    return sy->area->overseg->pcit_base + 4 + (4 * index);
}


static int32 eft_entry(int32 index, int32 type)
{   if (reent_flag)
    {   if (type == 3)
            /* direct instr ref to fn entry veneer... */
            return index * REENTRANT_CODE_STRIDE + inter_LU_code->base;
        else
        {   /* indirect data ref to fn entry veneer... */
            return inter_LU_data_map[index] - 8 + inter_LU_data->base;
        }
    }
    else
        return index * SIMPLE_CODE_STRIDE + inter_LU_data->base;
}

static void load2(struct aentry *aep)
{
    char *area, *cp;
    int32 siz;
    int32 v = 0;
    struct sym *sy;
    int32 savreloc;
    struct aentry* rel_wrt_area = 0;
    int havewarned, havecomplained;
    int32 areasiz;

    havewarned = 0;
    havecomplained = 0;
    if (verboseflag >= 2)
    {   fprintf(stderr, "%s: ", SELF);
        fprintf(stderr, msgtext(misc_reloc1), aep->name);
        if (aep->oep)
        {   fprintf(stderr, msgtext(misc_reloc2), aep->oep->fep->fname);
            if (aep->oep->fep->type & LIB_MASK)
                fprintf(stderr, "(%s)", aep->oep->oname);
        }
        fprintf(stderr, ".\n");
        errcount[0]++;
    }
    if (aep->areasiz <= 0 || (aep->attrs & AOF_0INITAT)) return;

    mark_stack();

    setobject(aep->oep);
    areasiz = aep->areasiz;
    area = map(aep->areaoff, areasiz);
    if (aep->oep->fep->type & AOUT_MASK) {
#ifdef TARGET_HAS_AOUT
        struct relocation_info *reloc, *r, *rend;
        struct aentry *tarea, *darea, *zarea;
        struct exec *aouthdr;
        int32 doff, boff, offt, op;

        siz = aep->relocs * sizeof(struct relocation_info);
        reloc = (struct relocation_info *) map(aep->relocoff, siz);
        tarea = aep->oep->arealist[CODE_AREA];
        darea = aep->oep->arealist[DATA_AREA];
        zarea = aep->oep->arealist[BSS_AREA];
        aouthdr = aep->oep->o_un.aouthdr;
        if (aouthdr->a_magic == OMAGIC)
            doff = aouthdr->a_text;
        else
            doff = (aouthdr->a_text + (int32)(pagesize - 1)) &
                ~(int32)(pagesize - 1);
        boff = doff + aouthdr->a_data;
        if (aep->attrs & AOF_0INITAT)
            offt = boff;
        else if (aep->attrs & AOF_RONLYAT)
            offt = 0;
        else
            offt = doff;
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++) {
            if (r->r_address >= areasiz)
                msg(fatal_badobj(aep->oep->fep->fname));
            cp = area + r->r_address;
            savreloc = plinkflag;
            switch (r->r_length) {
            case 0:
                v = *cp;
                break;
            case 1:
                v = *(short *)cp;
                break;
            case 2:
                v = *(int32 *)cp;
                savreloc = 1;
                break;
            case 3:
                v = *(int32 *)cp;
                op = v & 0xff000000;
                v = ((v & 0x00ffffff) << 8) / 64;
                break;
            }
            if (r->r_extern) {
                sy = &(aep->oep->numtosym[r->r_symbolnum]->
                                            h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT) {
                    rel_wrt_area = sy->area;
                    if (!rel_wrt_area) {
                        savreloc = 0;
                        if ((r->r_pcrel || r->r_length == 3) &&
                                (plinkflag))
                            msg(err_pcrelabs(
                                aep->oep->numtosym[r->r_symbolnum]->name+2));
                    }
                }
                if (!plinkflag || (rel_wrt_area))
                    v += sy->value;
                r->r_symbolnum = (int) sy->symno;
            } else {
                switch (r->r_symbolnum & N_TYPE) {
                case N_TEXT:
                    v += tarea->base;
                    rel_wrt_area = tarea;
                    break;
                case N_DATA:
                    v += darea->base - doff;
                    rel_wrt_area = darea;
                    break;
                case N_BSS:
                    v += zarea->base - boff;
                    rel_wrt_area = zarea;
                    break;
                }
            }
            if (r->r_pcrel || r->r_length == 3) {
                if (!plinkflag ||
                            (rel_wrt_area && rel_wrt_area->h == aep->h)) {
                    v -= aep->base - offt;
                    savreloc = 0;
                    if (!r->r_pcrel)
                        v = v - r->r_address;
                }
            } else
                if (plinkflag && r->r_extern && savreloc) {
                    if (!rel_wrt_area)
                        goto nostrback;
                    if (rel_wrt_area->attrs & AOF_0INITAT) {
                        r->r_symbolnum = N_BSS;
                    }
                    else if (rel_wrt_area->attrs & AOF_RONLYAT)
                        r->r_symbolnum = N_TEXT;
                    else {
                        r->r_symbolnum = N_DATA;
                    }
                    r->r_extern = 0;
                }
            switch (r->r_length) {
            case 0:
                if (v < -128 || v > 127)
                  msg(err_reloc(r->r_offset,aep->oep->oname,aep->name,v,255));
                *cp = (char) v;
                break;
            case 1:
                if (v < -32768 || v > 32767)
                  msg(err_reloc(r->r_offset,aep->oep->oname,aep->name,v,65535));
                *(short *)cp = (short) v;
                break;
            case 2:
                *(long *)cp = v;
                break;
            case 3:
                *(long *)cp = v = op | ((v / sizeof(long)) & 0xffffff);
                break;
            }
nostrback:
            if ((relocflag || moduleflag) && savreloc &&
                                                output_type != AOUT)
                writereloc(areaoutposn + r->r_address,
			   !(aep->attrs & AOF_RONLYAT) && /* from RW area */
			   rel_wrt_area && /* relative to some area */
			   !(rel_wrt_area->attrs & AOF_RONLYAT)); /* which is also RW */
            if (plinkflag && savreloc) {
                r->r_address += (unsigned) aep->h->h_un.areaval->areaoff;
                if (output_type == AOUT) {
                    if (aep->attrs & AOF_RONLYAT)
                        textrelocs++;
                    else
                        datarelocs++;
                    writeaoutreloc( r );
                }
            }
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        struct globsym *gs;
        aof_reloc *reloc, *r, *rend;
        int len, pcrel, addsym, max_ins;
        int32 symno, psave, roffset;
        unsigned32 rflags;
#ifdef LINKING_ON_ACORN_RISC_OS
        struct __link_list *__link;
#endif

        if (lastoutarea != aep->h->h_un.areaval)
        {   areaoutposn += lastoutarea->relocs * sizeof(aof_reloc);
            lastoutarea = aep->h->h_un.areaval;
            if (plinkflag)
            {
                /* write aof relocations (from list structure) */
                /* file pointer should be in correct place (after area) */
                writereloclist( &aofreloclist );
                /* would like to free up list here... but we can't */
                listinit( &aofreloclist, sizeof( aof_reloc ) );
                relocposn = areaoutposn + lastoutarea->areasiz;
            }
        }
#ifdef LINKING_ON_ACORN_RISC_OS
/* Commentary (sbrodie; 13/Nov/1998), (graphics by ahodgkinson):

The problem with partially linked AOF is that the __link symbols are
discarded because they are local only.  The ->next fields have been poked
with useless values but that doesn't matter because the list is never walked!

When linking AIF files, the code uses the (known) final target address of the
__link->next fields and pokes it straight in.  Unfortunately, this is not
good enough for outputting AOF files ....

The change I have made here is that this code must do nothing at all when
partially linking.  It must not write the __head data, and it must not modify
anything else.  The only thing it needs to do is to ensure that __link
symbols are retained in the output (see write_symt() and middle()).  This
code already copes with multiple __link symbols in the intput areas by
storing them through the chain pointers, and so will link the whole lot up at
final link correctly.

                    +--------+        +--------+        +--------+
                    | aentry |        | aentry |        | aentry |
                    |        | <----- |        |  ...<- |        |
                    |  aep   |        |   aep  |        |  aep   |
                    +--------+        +--------+        +--------+
                        |                  |                |
                        | area_link_list   |                |
                        V                  V                V
                    +--------+        +--------+        +--------+       +--------+
                    |   _l_l |  next  |   _l_l |        |   _l_l |       |   _l_l |
   g__link_list --> |        | -----> |        | ->...  |        |   /-->|        |
                    |        |        |        |        |        |   |   |        |
                    +--------+        +--------+        +--------+   |   +--------+
                        |                  |               |  |      |
                        | chain            | chain   chain |  | next | next
                        V                  V               V  V      |
                       ---                ---           +--------+   |
                                                        |   _l_l |   |
                                                        |        |---/
                                                        |        |
                                                        +--------+
                                                            |
                                                            | chain
   "_l_l" = "__link_list"                                   V
                                                           ---

 */

        if (!plinkflag) {
                for (__link = aep->area__link_list; __link; __link = __link->chain) {
                    sy = __link->sy;
                    assert(sy->area == aep);
                    cp = area + (sy->value - aep->base);
                    if (__link->next) {
                        *(int32 *)cp = __link->next->sy->value;
                        writereloc(areaoutposn + sy->value - aep->base,1);
                    }
                }
                if ((sy = g__head_sym) != NULL && aep == sy->area) {
                    cp = area + (sy->value - aep->base);
                    __link = g__link_list;
                    if (__link) {
                        *(int32 *)cp = __link->sy->value;
                        writereloc(areaoutposn + sy->value - aep->base,1);
                    }
                }
        }
#endif

        siz = aep->relocs * sizeof(aof_reloc);
        reloc = (aof_reloc *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++)
        {   roffset = hv(r->rel_offset);
            rflags = hv(r->rel_flags);
            cp = area + roffset;
            if (roffset >= areasiz) msg(fatal_badobj(aep->oep->fep->fname));
            max_ins = -1;
            if (rel_type2(rflags))
            {   symno =  rel2_sid(rflags);
                len   =  rel2_FT(rflags);
                pcrel =  rel2_R(rflags);
                addsym = rel2_A(rflags);
                if (aep->flags & NOINSTRELOC)
                {   /* AOF vsn < 310 - do this for compatibility with */
                    /* Acorn's C release 3 and C release 4.           */
                    if (pcrel) len = 3;
                }
                else
                    /* version 310 or later... */
                    max_ins = rel2_ins(rflags);
                rflags &= (REL_TYPE2 | REL_B);
            }
            else
            {   /* olde style => pre vsn 310... max_ins = -1 */
                symno =  rel1_sid(rflags);
                len   =  rel1_FT(rflags);
                pcrel =  rel1_R(rflags);
                if (pcrel) len = 3;
                addsym = rel1_A(rflags);
                if (pcrel) addsym = 1;
                if (!addsym) symno = aep->areano;
                rflags = 0;
            }
            if (shl_flag && aep->overseg != &root &&
                !pcrel && (rflags & REL_B) == 0)
                msg(err_positiondependentreloc(roffset, aep->oep->oname,  aep->name));
            switch (len)
            {
            case 0:
                v = *cp;
                break;
            case 1:
                v = xvs((int32)(*(short *)cp));
                break;
            case 2:
                v = hv(*(int32 *)cp);
                break;
            case 3:
                v = instr_offset((int32 *)cp, max_ins);
                if (v == -1)
                {   msg(err_instreloc(hv(*(int32 *)cp), roffset, aep->oep->oname, aep->name));
                    v = 0;
                }
                break;
            }
            savreloc = 1;
            psave = 1;
if (verboseflag >= 3)
{   fprintf(stderr, "rel: off=0x%lx, A=%u, R=%u, len=%u, B=%u, symno=%lu\n",
    roffset, addsym, pcrel, len, (rflags & REL_B) != 0, symno);
}
            if (addsym)
            {   struct hentry *h = aep->oep->numtosym[symno];
                gs = h->h_un.globval;
                sy = &(gs->symval);
                if (sy->flags & SYM_WEAKAT) savreloc = 0;
                rel_wrt_area = NULL;
                symno = sy->symno;
                if (sy->flags & SYM_DEFAT)
                {   /* the symbol is defined... */
                    if ((sy->flags & (SYM_EFTSYM+SYM_DATAAT))==SYM_EFTSYM &&
                        aep->overseg == &root &&
                        sy->area != NULL &&
                        sy->area->attrs & AOF_CODEAT)
                    {
/* It's an EFTSYM symbol and not a code-area datum, and the area being */
/* relocated is in the stub, not the library, and and the symbol is    */
/* defined in a code area, so it needs an inter-LU entry veneer...     */
                        if (len == 3)
                            rel_wrt_area = inter_LU_code;
                        else
                            rel_wrt_area = inter_LU_data;
                    }
                    else
                        rel_wrt_area = sy->area;
                    if (gs->pcit_entry >= 0 &&
                        !(pcrel && sy->area->overseg == aep->overseg))
                    {
                        if (sy->flags & SYM_EFTSYM)
                            v += eft_entry(gs->pcit_entry, len);
                        else
                            v += overseg_entry(gs->pcit_entry, sy);
                    }
                    else
                        v += sy->value;
                    if ((sy->flags & SYM_ABSAT) ||
                        pcrel && rel_wrt_area->h == aep->h)
                    {   /* absolute or pc-rel within area group, so */
                        /* no relocation directive saved in output. */
                        psave = 0;
                        if (!(sy->flags & SYM_LINKSYM))
                            savreloc = 0;
                        if (pcrel && plinkflag && (sy->flags & SYM_ABSAT))
                            msg(err_pcrelabs(h->name + 2));
                        if (len == 3 &&
                           (rflags & REL_B) &&
                           !(sy->flags & SYM_LEAFAT))
                        /* Reentrant tail-call to a non-leaf fn... */
                        /* ... enters at inter-LU entry point...   */
                            v += 4L;
                    }
                    else if (plinkflag && aep->overseg == &root ||
                             (rflags & REL_B) && !pcrel)
                    {   /* symbol-relative -> area-base-relative... */
                        if (rel_wrt_area != NULL)
                        {   if (rel_wrt_area->flags & UNHASHED)
                            {   v -= rel_wrt_area->base;
            /* Reference to eliminated stub data from another stub, */
            /* re-written as a reference to stubArea$$Base.         */
                                symno =
                                    rel_wrt_area->h->h_un.globval->symval.symno;
                            }
                            else
                            {   v -= rel_wrt_area->h->h_un.areaval->base;
                                addsym = 0;
                                symno = rel_wrt_area->h->h_un.areaval->areano;
                            }
                        }
                        else
                        {   psave = savreloc = 0;
                            msg(err_lost_reloc(h->name+2, roffset,
                                aep->oep->oname, aep->name));
                        }
                    }
                }
            }
            else /* area-base-relative relocation */
            {   rel_wrt_area = aep->oep->arealist[symno];
                if (pcrel && rel_wrt_area->h == aep->h)
                    /* pc-relative reloc within area group */
                    psave = 0;
                else
                {   v += rel_wrt_area->base;
                    if (plinkflag && aep->overseg == &root ||
                        (rflags & REL_B))
                    {   if (rel_wrt_area->flags & UNHASHED)
                        {   addsym = 1;
            /* Reference to eliminated stub data from another stub, */
            /* re-written as a reference to stubArea$$Base.         */
                            symno = rel_wrt_area->h->h_un.globval->symval.symno;
                        }
                        else
                        {   v -= rel_wrt_area->h->h_un.areaval->base;
                            symno = rel_wrt_area->h->h_un.areaval->areano;
                        }
                    }
                }
            }
            if (shl_flag && aep->overseg != &root) psave = 0;
            if (scatterflag == OVERLAY &&
                rel_wrt_area != NULL &&
                !(rel_wrt_area->attrs & AOF_CODEAT) &&
                rel_wrt_area->overseg != &root &&
                rel_wrt_area->overseg != aep->overseg)
            {
                if (aep->overseg->level == rel_wrt_area->overseg->level)
                {   if (!havecomplained)
                    {   msg(err_noncores(aep->oep->oname, aep->name));
                        havecomplained = 1;
                    }
                }
                else if (!havewarned && !havecomplained)
                {   msg(warn_noncores(aep->oep->oname, aep->name));
                    havewarned = 1;
                }
            }
            if (pcrel)
            {   if ((rflags & REL_TYPE2) == 0) v -= roffset + 8;
                v -= aep->base;
                if (plinkflag && psave) v += aep->h->h_un.areaval->base;
            }
            switch (len)
            {
            case 0:
                savreloc = 0;
                *cp = (char) v;
                break;
            case 1:
                savreloc = 0;
                *(short *)cp = (short) xvs(v);
                break;
            case 2:
                if (scatterflag && rel_wrt_area != NULL)
                {   if (aep->overseg == &root)
                        savreloc = 0x80000000;
                    else if (rel_wrt_area->overseg == &root)
                    {   savreloc = 0x10000000;
            /* if the overlay is relocatable, link this segment */
            /* as if the root were loaded at 0.                 */
                        if (relocflag) v -= base;
                    }
                    else if (rel_wrt_area->overseg == aep->overseg)
                        savreloc = 0x20000000;
                }
                *(long *)cp = tv(v);
                break;
            case 3:
                if (pcrel)
                {   if (aep->overseg == &root)
                        savreloc = 0;
                    else
                    {   savreloc = 0x30000000;
            /* if the overlay is relocatable, link this segment */
            /* as if the root were loaded at 0.                 */
                        if (relocflag) v -= base;
                    }
                }
                if (instr_reloc((int32 *)cp, v, max_ins) != 0)
                    msg(info_ireloc(roffset, aep->oep->oname, aep->name, v));
                break;
            }
            if ((relocflag || moduleflag) &&
                savreloc && output_type != AOUT)
            {
                writereloc(areaoutposn + roffset + (savreloc & 0x70000000),
			   !(aep->attrs & AOF_RONLYAT) && /* from RW area */
			   rel_wrt_area && /* relative to some area */
			   !(rel_wrt_area->attrs & AOF_RONLYAT)); /* which is also RW */
            }
            if (plinkflag && psave && output_type != AOUT)
            {   aep->h->h_un.areaval->relocs++;
                rflags |= symno + REL_TYPE2 + (int32)len*REL_SHORT;
                if (pcrel)  rflags |= REL_R;
                if (addsym) rflags |= REL_A;
                writeaofreloc(aep->h->h_un.areaval->areaoff+roffset, rflags);
            }
        }
#endif /* TARGET_HAS_AOF */
    }
    if (output_type == AOUT && !plinkflag)
    {   if (aep->flags & SHFLAG)
        {   if (aep->attrs & AOF_RONLYAT)
                writebytes(0x8000, area, aep->areasiz);
        }
        else
            writebytes(aep->base - textoffset, area, aep->areasiz);
    }
    else
    {   if (aep->areapad > 0)
        {   char zeroes[64];
            int32 padding, count;
            memset(zeroes, 0, sizeof(zeroes));
            for (padding = aep->areapad;  padding > 0;  padding -= count)
            {   if (padding > sizeof(zeroes))
                    count = sizeof(zeroes);
                else
                    count = padding;
                writebytes(areaoutposn, zeroes, count);
                areaoutposn = fout.currentpos;
            }
        }
        writebytes(areaoutposn, area, aep->areasiz);
        areaoutposn = fout.currentpos;
    }
    aep->h->h_un.areaval->areaoff += aep->areasiz + aep->areapad;

    pop_stack();
}

#ifdef TARGET_HAS_AOF

static char *writeoutstr(char *st, char *s)
{   while ((*st++ = *s++) != 0);
    return st;
}

#endif /* TARGET_HAS_AOF */


static void write_symt(void)
{
    struct hentry *h;
    struct globsym *gs;
    int32 at, textareanameidx, dataareanameidx, bssareanameidx, dbgareanameidx;
    char *strtp, *cp, *outstrt;

    dbgareanameidx = 0;
    bssareanameidx = 0;
    dataareanameidx = 0;
    textareanameidx = 0;
    outstrt = strtp = NULL;

    if (output_type == AOUT) {
#ifdef TARGET_HAS_AOUT
        struct nlist *symtp, *outsymt;
        int nt;

        symtp=outsymt=(struct nlist *)
                            salloc(symcount * sizeof(struct nlist));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = strtsize;
        strtp += sizeof(int32);
        if (debugflag) {
            struct oentry *oep;
            int32 toff, doff, boff, nsyms;
            struct nlist *symt, *symtend;
            char   *strt;
            struct aentry *code, *data, *bss;

            oep = objectlist;
            while (oep) {
                if (oep->fep->type & AOUT_MASK) {
                    setobject(oep);
                    code = oep->arealist[CODE_AREA];
                    data = oep->arealist[DATA_AREA];
                    bss = oep->arealist[BSS_AREA];
                    symtp->n_un.n_strx = strtp - outstrt;
                    symtp->n_type = N_TEXT;
                    symtp->n_value = code->base;
                    cp = oep->oname;
                    while ((*strtp++ = *cp++) != 0);
                    symtp++;
                    nsyms = map_aoutsymt(oep->o_un.aouthdr, &toff,
                                                &doff, &boff, &symt, &strt);
                    for (symtend = symt + nsyms; symt < symtend; symt++)
                        if (!(symt->n_type & N_EXT)) {
                            if (symt->n_un.n_strx) {
                                cp = strt + symt->n_un.n_strx;
                                if (*cp == 'L')
                                    continue;
                                symt->n_un.n_strx = strtp - outstrt;
                                while ((*strtp++ = *cp++) != 0);
                            }
                            switch ((symt->n_type & N_TYPE) >> 1) {
                            case N_TEXT >> 1:
                                symt->n_value += code->base - toff;
                                break;
                            case N_DATA >> 1:
                                symt->n_value += data->base - doff;
                                break;
                            case N_BSS >> 1:
                                symt->n_value += bss->base - boff;
                                break;
                            }
                            *symtp++ = *symt;
                        }
                }
                oep = oep->next;
            }
        }
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if (!(gs->symval.flags & SYM_DEFAT))
                nt = N_UNDF;
            else if (gs->symval.area == NULL)
                nt = N_ABS;
            else if (gs->symval.area->flags & UNUSEDAREA)
                continue;
            else if ((at = gs->symval.area->attrs) & AOF_0INITAT)
                nt = N_BSS;
            else if (at & AOF_RONLYAT)
                nt = N_TEXT;
            else
                nt = N_DATA;
            if ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT)
                nt |= N_EXT;
            symtp->n_un.n_strx = strtp - outstrt;
            symtp->n_value = gs->symval.value;
            symtp->n_desc = gs->symval.dbxinfo;
            symtp->n_type = nt;
            cp = h->name + 2;
#ifdef USE_PSTRING_SYMBOLS
            *strtp++ = strlen(cp);
#endif
            strtp = writeoutstr(strtp, cp);
            symtp++;
        }
        writebytes(sposn, (char *)outsymt, symcount*sizeof(struct nlist));
#endif /* TARGET has AOUT */
    }
    else if (output_type == AIF)
    {
#ifdef TARGET_HAS_AOF
        ItemSection sect;
        ItemSymbol *symtp, *outsymt;
        unsigned32 f;

        memset((char *)&sect, 0, sizeof(ItemSection));
        sect.id = tv(asd_codeword(ITEMSECTION, (int32)sizeof(ItemSection)));
        sect.lang = LANG_NONE;
        sect.asdversion = 2;
        sect.codestart = tv(root.torigin);
        sect.datastart = tv(root.dorigin);
        sect.codesize  = tv(root.textsize);
        sect.datasize  = tv(root.datasize);
        sect.debugsize = tv(sizeof(ItemSection) +
                            symcount * sizeof(ItemSymbol) + strtsize);
        sect.n.nsyms = tv(symcount);
        writebytes(sposn - sizeof(ItemSection), (char *) &sect,
                                  sizeof(ItemSection));
        symtp = outsymt = (ItemSymbol *) salloc(symcount * sizeof(ItemSymbol));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = tv(strtsize);
        strtp += sizeof(int32);
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if (gs->symval.area == NULL)
                /* AOF_ABSAT => symval.area == NULL, but not conversely  */
                /* (but it's a convenient way to recover from previously */
                /*  diagnosed errors and symbols in unused/empty areas.  */
                f = ASD_ABSSYM;
            else if (gs->symval.area->flags & UNUSEDAREA)
                continue;
            else if ((at = gs->symval.area->attrs) & AOF_0INITAT)
                f = ASD_ZINITSYM;
            else if (at & AOF_RONLYAT)
                f = ASD_TEXTSYM;
            else
                f = ASD_DATASYM;
            if ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT)
                f |= ASD_GLOBSYM;
            symtp->sym = tv(f + (strtp - outstrt));
            symtp->value = tv(gs->symval.value);
            cp = h->name + 2;
#ifdef USE_PSTRING_SYMBOLS
            *strtp++ = strlen(cp);
#endif
            strtp = writeoutstr(strtp, cp);
            symtp++;
        }
        if (symcount)
            writebytes(sposn, (char *) outsymt,
                                    symcount * sizeof(ItemSymbol));
    }
    else /* output_type == AOF (methinks) */
    {   aof_symbol *symtp, *outsymt;
        struct aentry *aep;
        int32 i;

        symtp = outsymt = (aof_symbol *) salloc(symcount*sizeof(aof_symbol));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = tv(strtsize);
        strtp += sizeof(int32);
        if (plinkflag)
            for (i = 0; i < root.noofoutareas; i++)
            {   cp = root.outareas[i]->h->name;
                root.outareas[i]->areaoff = strtp - outstrt;
                strtp = writeoutstr(strtp, cp);
            }
        else
        {   if (root.textsize)
            {   textareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RO");
            }
            if (root.datasize)
            {   dataareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RW");
            }
            if (root.bsssize)
            {   bssareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$ZI");
            }
            if (debugflag)
            {   dbgareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RW0");
            }
        }
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   int32 v, attrs;
#ifdef LINKING_ON_ACORN_RISC_OS
            int forcibly_link = plinkflag && strncmp(h->name+2, "__link", 6) == 0;
#endif
            gs = h->h_un.globval;
            /* WARNING: changes to following expression must be duplicated
               in function middle() where symcount is incremented! */
            if (
#ifdef LINKING_ON_ACORN_RISC_OS
                !forcibly_link &&
#endif
                plinkflag && !debugflag &&
                (gs->symval.flags & SYM_REFDEFMASK) == SYM_LOCALDEFAT ||
                shl_flag &&
                (gs->symval.flags & (SYM_EFTSYM+SYM_LINKSYM)) == 0)
                    continue; /* don't output symbol */

#ifdef LINKING_ON_ACORN_RISC_OS
            if (forcibly_link) {
                    /* If we forcibly included this symbol, we must now make it local to the output
                     * AOF file to avoid problems of duplicate symbols in subsequent link phases
                     */
                    gs->symval.flags = (gs->symval.flags & ~SYM_REFDEFMASK) | SYM_LOCALDEFAT;
            }
#endif
            symtp->sym_name = tv(strtp - outstrt);
            if ((gs->symval.flags & SYM_EFTSYM) && (i = gs->pcit_entry) >= 0)
            {   aep = inter_LU_code;
                v = i * inter_LU_code_stride + aep->base;
            }
            else
            {   v = gs->symval.value;
                aep = gs->symval.area;
            }
            symtp->sym_value = tv(v);
            v = gs->symval.flags & ~SYM_LINKFLAGS;
            if (!plinkflag || aep == NULL)
                /* AOF image at absolute address or recovery from previous */
                /* error, or symbol defined in unreferenced/empty area...  */
                v |= SYM_ABSAT;
            symtp->sym_AT = tv(v);
            symtp->sym_areaname = 0;
            if (aep != NULL)
            {   attrs = hv(symtp->sym_AT);
                if (plinkflag)
                {   v = hv(symtp->sym_value);
                    v -= aep->h->h_un.areaval->base;
                    symtp->sym_value = tv(v);
                    v = aep->h->h_un.areaval->areaoff;
                }
                else if (aep->flags & UNUSEDAREA)
                    continue;
                else if (attrs & AOF_CODEAT)
                    v = textareanameidx;
                else if (attrs & AOF_DEBUGAT)
                    v = dbgareanameidx;
                else if (attrs & AOF_0INITAT)
                    v = bssareanameidx;
                else
                    v = dataareanameidx;
                symtp->sym_areaname = tv(v);
            }
            strtp = writeoutstr(strtp, h->name + 2);
            symtp++;
        }
        if (symcount)
            writebytes(sposn,(char *)outsymt,symcount*sizeof(aof_symbol));
#endif /* TARGET_HAS_AOF */
    }
    while ((strtp - outstrt) < strtsize) *strtp++= 0;
    if (strtsize > 4L) writebytes(strposn, outstrt, strtsize);
}

static void intellec_write_symt(void)
{   struct hentry *h;
    struct globsym *gs;
    char buf[80];

    for (h = firstglobsym;  h != NULL; )
    {   gs = h->h_un.globval;
        sprintf(buf, "#* %.8lx %.64s\n", gs->symval.value, h->name+2);
        writedirect( buf, strlen(buf));
        h = gs->next;
    }
}

#ifdef TARGET_HAS_AOF

static void write_root_pcit_section(struct oventry *ov)
{   struct pcit_section psect;
    struct oventry *ov2;
    int32 t;
    int i, l;
    char *cp;

    psect.br = tv(AIF_BLAL | (((load_seg_and_go->h_un.globval->symval.value -
        (ov->pcit_base + ov->entryv * 4 + 12)) >> 2) & 0xffffff));
    psect.vecsize = tv(ov->entryv * 4);
    psect.base = tv(ov->base);
    psect.limit = tv(ov->limit);
    l = strlen(ov->name);
    cp = ov->name;
    i = 0;
    while ((l = *cp++) != 0) {
        psect.name[i] = l;
        i++;
        if (l == PATHSEP[0]) i = 0;
    }
    while (i < 12) psect.name[i++] = 0;
    psect.clashsize = tv(ov->level->clash * 4);
    writebytes(fout.currentpos, (char *) &psect, sizeof(struct pcit_section));

    for (ov2 = ov->level->seg_list;  ov2 != NULL;  ov2 = ov2->next)
    {   if (ov2 == ov) continue;
        if (relocflag || (qflag & NEW_OVERMGR))
            /* use offset to clashing PCIT segment */
            t = ov2->pcit_base - ov->pcit_base + (ov2->entryv - ov->entryv)* 4;
        else
            /* use address of clashing PCIT segment */
            t = ov2->pcit_base + ov2->entryv * 4 + 8;
        t = tv(t);
        writebytes(fout.currentpos, (char *) &t, 4);
    }
}

static void write_root_pcit(void)
{
    struct lventry *lv;
    struct oventry *ov;
    int32 entryv, strlr = tv(STRLR);

    for (lv = root.level_list;  lv != NULL;  lv = lv->next)
    {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
        {   entryv = ov->entryv;
            while (entryv-- >= 0)
                writebytes(fout.currentpos, (char *) &strlr, 4);
            write_root_pcit_section(ov);
        }
    }
}

static void write_segment_pcit(struct oventry *ov)
{   struct hentry *h;
    struct globsym *gs;
    int32 entryvbase;
    int32 t;

    entryvbase = ov->pcit_base + 12;  /* 4 for 1st STRLR, 8 for ARM branch */
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if (gs->pcit_entry < 0 || gs->symval.area->overseg != ov) continue;
        /* PCIT branches always branch forwards, but don't rely on it */
        t = gs->symval.value - entryvbase;
        entryvbase += 4;
        if (relocflag)
        {    writereloc(fout.currentpos + 0x70000000, 0);
             /* link as if root of relocatable overlay system */
             /* were linked at 0 */
             t += base;
        }
        t = tv(0xea000000 | ((t >> 2) & 0xffffff));
        writebytes(fout.currentpos, (char *) &t, 4);
    }
}

#endif /* TARGET_HAS_AOF */

static void write_eft(struct oventry *ov)
{   struct hentry *h;
    struct globsym *gs;
    int32 t, *eft, entry_point, eftsz;

    eftsz = tv(eft_size);
    writebytes(fout.currentpos, (char *) &eftsz, 4);
    if (verboseflag)
    {   msg(info_EFTPBlock(paramBlkUsed));
        msg(info_EFTSize(eft_size));
    }
    if (eft_size != 0)
    {   mark_stack();
        eft = (int32 *) salloc(eft_size * sizeof(int32));
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if ((gs->symval.flags & SYM_EFTSYM) && ((t = gs->pcit_entry) >= 0))
            {   entry_point = gs->symval.value - (ov->limit - ov->base);
                /* Non-leaf functions have inter-LU entry at symbol+4 */
                if (!(gs->symval.flags & SYM_LEAFAT)) entry_point += 4;
                eft[t] = tv(entry_point);
                if (verboseflag)
                    msg(info_EFTEntry(t, entry_point, h->name));
            }
        }
        writebytes(fout.currentpos, (char *)eft, eft_size*sizeof(int32));
        pop_stack();
    }
    if (libdataflag)
    {    /* Write out size of SHL data area followed by the offset of it */
        int32 x = tv(shl_datasz->h_un.globval->symval.value);
        writebytes(fout.currentpos, (char *) &x, 4);
        x = tv(shl_database->h_un.globval->symval.value);
        writebytes(fout.currentpos, (char *) &x, 4);
    }
    /* and finally write out the parameter block */
    writebytes(fout.currentpos, paramBlk, paramBlkUsed);
}

static FILE *reopen_outfile(char *fname, char *ext, FILE *f)
{   char *fn = fname;
    if (f != NULL) fclose(f);
    if (ext != NULL && *ext != 0 && splitflag &&
        (intellecflag || binaryflag == BIN_NOHDR))
    {   int len = strlen(fname) + strlen(ext) + 1;
        fn = (char *) halloc(len);
        strcpy(fn, fname);
        strcat(fn, ext);
#ifdef LINKING_ON_RISCOS
        /* Assert: strlen(ext) > 0 ... */
        fn[strlen(fname)] = '/';
#endif
    }
    outf = fn;
    f = fopen(fn, intellecflag ? "w" : "wb");
    if (f == NULL ) msg(fatal_openerr(fn));
    return f;
}

static void write_intellec_header(char *segment_type, int32 base)
{   char outrec[80];
    time_t now;
    sprintf(outrec, "# Created by %s [%s]\n", IDFNSTR, __DATE__);
    writedirect( outrec, strlen(outrec));
    time(&now);
    sprintf(outrec, "#         on %s", ctime(&now));
    writedirect( outrec, strlen(outrec));
    sprintf(outrec, "# %s segment based at 0x%lx\n\n", segment_type, base);
    writedirect( outrec, strlen(outrec));
}

static void put_image_segment(struct oventry *ov)
{   struct aentry *aep;
    struct aentry **area, **areasend;

    if (!plinkflag)
    {   /* Create the <area>$$Base and $$Limit symbols */
        char tmpname[MAXSYMLEN];
        int tlen;
        strcpy(tmpname, "!!");
        for (aep = ov->outarealist;  aep != NULL;  aep = aep->nxt)
        {   struct hentry *h;
            bufcpy(tmpname+2, aep->h->name, sizeof(tmpname)-2);
            tlen = strlen(tmpname);
            bufcpy(tmpname+tlen, "$$Base", sizeof(tmpname)-tlen);
            h = lookup(tmpname, &globhashtable);
            if (h != NULL && aep->base < h->h_un.globval->symval.value)
                h->h_un.globval->symval.value = aep->base;
            bufcpy(tmpname+tlen, "$$Limit", sizeof(tmpname)-tlen);
            h = lookup(tmpname, &globhashtable);
            if (h != NULL &&
                (aep->base + aep->areasiz) > h->h_un.globval->symval.value)
                h->h_un.globval->symval.value = aep->base + aep->areasiz;
        }
    }

    mark_stack();

    fout.handle = reopen_outfile(ov->name, ro_ext, NULL);
    fout.currentpos = areaoutposn = 0;

    write_header(ov);
    if (intellecflag) write_intellec_header("RO", base);

    /* aofreloclist is reset here, but is also reset within load2 */
    listinit( &aofreloclist, sizeof( aof_reloc ) );

    /* these lists are initialised here, as they are on per-image basis */
    listinit( &reloclist, sizeof( int32 ) );
#ifdef TARGET_HAS_AOUT
    listinit( &aoutreloclist, sizeof( struct relocation_info ) );
#endif

again_for_shl_liby_chunk:
    if (ov != &root)
        relocposn = ov->textsize + ov->datasize + ov->bsssize;
    for (area = ov->arealist, areasend = area + ov->noofareas;
        area < areasend; area++)
    {   aep = *area;
        if (scatterflag && (aep->attrs & AOF_DEBUGAT)) continue;
        if (splitflag && (intellecflag || binaryflag == BIN_NOHDR) &&
            ov->dorigin == aep->base && aep->areasiz > 0 &&
            (aep->attrs & AOF_RONLYAT) == 0)
        {
            fout.handle = reopen_outfile(ov->name, rw_ext, fout.handle);
            areaoutposn = fout.currentpos = 0;
            if (intellecflag)
            {   write_intellec_header("RW", data_base);
                intellec_base = 0;
            }
        }
        load2(aep);
    }

#ifdef TARGET_HAS_AOF
    if (scatterflag == OVERLAY)
    {   if (ov == &root)
        {   int32 offset = fout.currentpos;
            write_root_pcit();
            areaoutposn = fout.currentpos;
            offset = fout.currentpos - offset;
            for (area = ov->arealist, areasend = area+ov->noofareas;
                area < areasend;  area++)
            {   aep = *area;
                if (!(aep->attrs & AOF_DEBUGAT)) continue;
                aep->base += offset;
                load2(aep);
            }
        }
        else
            write_segment_pcit(ov);
    }
#endif
    writereloclist( &aofreloclist ); /* IJR: this may be redundant..? */

    if (binaryflag == BIN_NOHDR)
    {   char zeroes[64];
        int32 n = ov->bsssize;
        memset(zeroes, 0, sizeof(zeroes));
        while (n > sizeof(zeroes))
        {   writebytes(fout.currentpos, zeroes, (int32)sizeof(zeroes));
            n -= sizeof(zeroes);
        }
        writebytes(fout.currentpos, zeroes, n);
    }

    /* fix_up_header() moved to end for io efficiency (IJR) */
    if (plinkflag && (ov == &root)) fix_up_globals();

    if (intellecflag)
    {  /* flushout(&o1); */
        writedirect( ":00 0000 01 FF\n\n", 16);
        if (debugflag) intellec_write_symt();
    }
    else if ((debugflag || plinkflag) && ov == &root)
    {   write_symt();
        if (shl_flag == 2)
        {   int32 n = fout.currentpos & 3L;
            ov = root.level_list->seg_list;
            root.level_list = NULL;
            if (n != 0) writebytes(fout.currentpos, "\0\0\0", 4L - n);
            areaoutposn = fout.currentpos;
            n = ov->textsize + (eft_size+1)*sizeof(int32) + paramBlkUsed;
            cfouthdr->cf_chunks[shl_chunk].cfe_size = tv(n);
            goto again_for_shl_liby_chunk;
        }
    }
    else if (shl_flag && ov != &root)
    {   write_eft(ov);
        if (shl_flag == 2) ov = &root;
    }

#ifdef TARGET_HAS_AOF
    if( relocflag )
    {   if (ov == &root)
        {   /* write aif relocation code */
            ensure_byte_order(aif_reloc_code, aif_reloc_code_size);
            writebytes(srcposn, (char *)aif_reloc_code, aif_reloc_code_size);
        }
        /* write aif relocation list next */
        writereloclist( &reloclist );
        /* write relocation terminator (-1) directly */
        writeaifrelocdirect( -1 );
    }

    if (moduleflag)
    {
        /* write amf module code */
        int sz = amf_reloc_code_size;
        unsigned32 *p = amf_reloc_code;
        p += sz/sizeof(unsigned32);
        p[-2] = tv(srcposn + base);
        p[-1] = tv(base);

	/* RMJ: if we just write this out, the relocation code itself
	/  won't have its endianness properly twiddled.  Therefore
	/  twiddle it manually as we go. */

	/* writebytes(srcposn, (char *)amf_reloc_code, sz); */
	{
	    int n;
	    int32 posn = srcposn;
	    unsigned32 *q = amf_reloc_code;
	    unsigned32 w;

	    for (n = sz/sizeof(unsigned32) - 2; n > 0; n--, q++)
	    {
		w = tv(*q);
		writebytes(posn, (char *)&w, sizeof(unsigned32));
		posn += sizeof(unsigned32);
	    }
	    writebytes(posn, (char *)(p-2), 2*sizeof(unsigned32));
	}

        writereloclist( &reloclist );
        /* ijr no need to stack these (inc -1) - just write out direct */
        writeaifrelocdirect( srcposn + sz - 8 );
        writeaifrelocdirect( srcposn + sz - 4 );
        /* write relocation terminator (-1) directly */
        writeaifrelocdirect( -1 );
    }
#endif
#ifdef TARGET_HAS_AOUT
    writereloclist( &aoutreloclist );
#endif
#ifdef DEBUG
    printf("reloc_count=%ld, popped=%ld\n", reloc_count, popped );
#endif

    /* do this last (involves a seek back to the start of the file) */
    if (plinkflag && ov == &root) fix_up_header();

#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT && !plinkflag && !debugflag)
    {   char zero = 0;
        /* ZMAGIC paged image... broken now that bwrite has gone. */
#ifdef LINKING_ON_UNIX

        bwrite((fout.currentpos + (pagesize-1)) & ~(pagesize-1), &zero, 1, 0);
        ftruncate(outfd, (fout.currentpos + (pagesize-1)) & ~(pagesize-1), 0);
#else
        if ((fout.currentpos & (int32)(size_t)(pagesize - 1)) != 0)
            bwrite(((fout.currentpos + (int32)(size_t)(pagesize - 1)) &
                    ~(int32)(size_t)(pagesize - 1)) - 1, &zero, 1, 0);
#endif
    }
#endif /* TARGET_HAS_AOUT */

    closeout(ov);
    pop_stack();
}

#ifdef SHL_IS_AOF_AREA
/*
 * LDS 01-Sep-93.
 * We probably don't ever want this option. If we do, then we have to modify
 * writebytes() to write into a buffer allocated here. This must also collude
 * with put_image_segment(). Although the result is less contorted than
 * writing a separate chunk, it is also much less useful.
 */
static void add_shl_library_area(void)
{   struct aentry *a, **p;
    struct oventry *ov = root.level_list->seg_list;
    char *anon = msgtext(misc_anon);
    struct fentry *fep;
    struct oentry *oep;

    root.level_list = NULL;
    a = (struct aentry *)
        halloc((int32)(size_t)(sizeof(struct aentry)+strlen(shl_name)+5));
    a->areano = root.noofoutareas++;
    root.outareas[a->areano] = a;
    a->areaoff = 0;
    a->areasiz = ov->textsize + (eft_size+1L)*sizeof(int32) + paramBlkUsed;
    a->areapad = 0;
    a->relocoff = 0;
    a->relocs = 0;
    a->attrs = AOF_CODEAT + AOF_RONLYAT + AOF_PICAT + AOF_REENTAT;
    a->oep = NULL;
    a->areaidx = 0;
    a->flags = 0;
    a->refs = NULL;
    a->overseg = NULL;
    a->nxt = NULL;
    strcpy(a->name, shl_name);
    strcpy(a->name + strlen(shl_name), "$$shl");
    a->areaval = (char *) halloc(a->areasiz);

    fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
    strcpy(fep->fname, anon);
    fep->size = a->areasiz;
    fep->filebuffer = a->areaval;

    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = NULL;        /* not needed */

    put_image_segment(ov);

    for (p = &ov->outarealist;  *p != NULL;) p = &(*p)->nxt;
    nextoutarea = p;
    hash_area(ov, a, a->name);
}
#endif

static void print_map(struct oventry *ov)
{
    struct aentry *aep, **area, **areasend;

    putchar('\n');
    printf(msgtext(misc_map_hdr), ov->name);
    for (area = ov->arealist, areasend = area + ov->noofareas;
        area < areasend;  ++area)
    {   aep = *area;
        if (aep->areasiz > 0)
        {   int32 baseval = aep->base;
            if (moduleflag) baseval -= base;
            printf("%-8lx %-8lx ", baseval, aep->areasiz);
            if (aep->attrs & AOF_CODEAT)
                printf("CODE    ");
            else if (aep->attrs & AOF_0INITAT)
                printf("ZERO    ");
            else if (aep->attrs & AOF_DEBUGAT)
                printf("DEBUG   ");
            else
                printf("DATA    ");
            printf(" %s", aep->name);
            if (aep->oep)
                printf(msgtext(misc_map_fromfile), aep->oep->oname);
            putchar('\n');
        }
    }
}


static struct fentry **addfile(struct fentry **next, char *fname, int lflag)
{
    struct fentry *fep;
    char *buffer;
    FILE *fp;

    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   if (CiStrEQ(fname, fep->fname))
        {   msg(warn_dupfname(fname));
            return next;
        }
    }
    fep = (struct fentry *)
        halloc((int32)(size_t)(sizeof(struct fentry) + strlen(fname)));
    *next = fep;
    strcpy(fep->fname, fname);
    fep->fd = -1;
    fep->next = NULL;
    /* IJR: temporary fopen/fclose here until raw reads have been expunged */
    fp = fopen(fep->fname, "rb");
    if (fp == NULL)
        msg(fatal_notfound(fep->fname));
    fseek(fp, 0L, SEEK_END);
    fep->size = ftell(fp);
    fclose(fp);
    fep->filebuffer = NULL;
    fep->type = filetype(fep);
    fep->lflag = lflag;
    if (lflag)
    {   if (fep->type & (OBJECT_MASK | AOUT_MASK))
            msg(fatal_badqual(fname));
        else
            msg(warn_libqual(fname));
    }
    if (fep->type != AR)
    {   if (ALLOCABLE(fep->size) && (buffer = cache_alloc(fep->size)) != NULL)
        {   fep->filebuffer = readfile(buffer, 0, fep->size);
#ifdef DEBUG_MEM
            fprintf(stderr, "stacked %s, size = %ld\n", fname, fep->size);
#endif
            closefile(fep);
        }
        else if (ALLOCABLE(fep->size))
        {
#ifdef DEBUG_MEM
            fprintf(stderr, "failed to stack %s, size = %ld\n",fname,fep->size);
#endif
            failedtostack = 1;
        }
    }
    return &(fep->next);
}

static void help(void)
{
    printf(msgtext(HELP_TEXT_FORMAT), SELF, IDFNSTR, BUILDDATE, myname );
    fputs( msgtext( HELP_TEXT_GENERAL_1), stdout );
    fputs( msgtext( HELP_TEXT_GENERAL_2), stdout );
    fputs( msgtext( HELP_TEXT_OPTS_1  ),  stdout );
    fputs( msgtext( HELP_TEXT_OPTS_2  ),  stdout );
    fputs( msgtext( HELP_TEXT_SPECIAL_1), stdout );
    fputs( msgtext( HELP_TEXT_SPECIAL_2), stdout );
#ifdef LINKING_ON_ACORN_RISC_OS
    fputs( msgtext( HELP_TEXT_SPECIAL_3), stdout );
#endif
}

static int32 getnum(char *arg, Message_t err)
{   int32 numbase = 10, n = 0;
    int c;

    if (arg[0] == '&' || arg[0] == '0' && (arg[1] == 'x' || arg[1] == 'X'))
    {   numbase = 16;
        if (arg[0] == '&') arg += 1; else arg += 2;
    }
    while ((c = *arg++) != 0)
    {   if (isdigit(c))
            n = n * numbase + c - '0';
        else
        {   c = LOWER(c);
            if (numbase != 16 || c < 'a' || c > 'f') break;
            n = n * numbase + c - 'a' + 10;
        }
    }
    if (c == 'k' || c == 'm')
    {   n *= 1024;
        if (c == 'm') n *= 1024;
        c = *arg;
    }
    if (c) msg(err);
    return n;
}

static struct oentry **addobject(struct oentry **next,
   char *oname, struct fentry *fep, char *hdr, int32 offset, int32 size)
{
    struct oentry *oep;
    char c, *mn;

    mn = oname;
    while ((c = *oname++) != 0)
#ifdef LINKING_ON_UNIX
        if (c == '/')
#else
#  ifdef LINKING_ON_MSDOS
        if (c == '\\' || c == ':')
#  else
#    ifdef LINKING_ON_MAC
        if (c == ':')
#    else
        if (c == '.' || c == ':')
#    endif
#  endif
#endif
            mn = oname;
    oep = (struct oentry *) halloc(sizeof(struct oentry));
    *next = oep;
    oep->oname = strcpy(halloc((int32)(size_t)(strlen(mn) + 1)), mn);
    oep->fep = fep;
    oep->o_un.hdrptr = hdr; /* fixme */
    oep->offset = offset;
    oep->size = size;
    if (objectid[0]++ > 'Z')
    {   objectid[0] = '!';
        if (objectid[1]++ > 'Z')
            msg(fatal_too_many_objs(('Z'-'!'+1)*('Z'-'!'+1)));
    }
    oep->objectid[0] = objectid[0];
    oep->objectid[1] = objectid[1];
    oep->next = NULL;
    return &(oep->next);
}

typedef struct gs_list {
    struct gs_list *next;
    struct globsym *sym;
    char *name;
} gs_list;

static gs_list *notyetdef;

static void ReportNewDefineds(void)
{   gs_list **pp = &notyetdef;
    gs_list *p;

    for (; (p = *pp) != 0; )
    {   if (p->sym->symval.flags & SYM_DEFAT)
        {   msg(info_def(p->name));
            *pp = p->next;
            free(p);
        }
        else
            pp = &(p->next);
    }
}

static void ReportNewUndefineds(void)
{   struct hentry *h1;
    struct globsym *gs;
    gs_list *p;

    for (h1 = firstglobsym;  h1 != NULL;  h1 = gs->next)
    {   gs = h1->h_un.globval;
        if (gs->symval.flags & SYM_DEFAT) continue;
        for (p = notyetdef; p != 0; p = p->next) if (p->sym == gs) break;
        if (p == 0)
        {
            if (gs->symval.flags & SYM_WEAKAT)
                msg(info_weakref(h1->name + 2));
            else
                msg(info_ref(h1->name + 2));
            p = (gs_list *) malloc(sizeof(*p));
            p->next = notyetdef;
            p->sym = gs;
            p->name = h1->name+2;
            notyetdef = p;
        }
    }
}

#ifdef TARGET_HAS_AOUT

static void enter_ar_symbols(struct fentry *fep)
{
    char *strt;
    struct ranlib *symt, *symtend;

    if (strncmp(fep->f_un.arhdr->ar_name, "__.SYMDEF", 9))
        msg(fatal_nosymtab(fep->fname));
#ifdef LINKING_ON_UNIX
    {   struct stat fileinfo;
        stat(fep->fname, &fileinfo);
        if (fileinfo.st_mtime > atol(fep->f_un.arhdr->ar_date))
            msg(fatal_ood(fep->fname));
    }
#endif
    strt = map(SARMAG+sizeof(struct ar_hdr),atoi(fep->f_un.arhdr->ar_size));
    symt = (struct ranlib *) (strt + sizeof(int32));
    symtend = (struct ranlib *) (strt + *((int32 *) strt) + sizeof(int32));
    strt = ((char *) symtend) + sizeof(int32);
    while (symt < symtend)
    {        symtend--;
        enter(strt + symtend->ran_un.ran_strx,
              &libsymtable)->h_un.intval = symtend->ran_off;
    }
}

static void load_ar_lib(struct fentry *fep)
{
    char *hdr;
    int32 ofs, siz;
    struct hentry *h, *lh;
    char *mname;
    struct oentry **lastobj;

    enter_ar_symbols(fep);

    if (verboseflag)
    {   if (fep->lflag == 'a')
            msg(info_loadlib(fep->fname));
        else
            msg(lib_scanlib(fep->fname));
    }

    h = firstglobsym;
    while (h != NULL)
    {        if (!(h->h_un.globval->symval.flags & (SYM_DEFAT|SYM_WEAKAT)) &&
              h->name[0] == '!' && h->name[1] == '!' &&
              ((lh=lookup(h->name + 2, &libsymtable)) != 0))
        {
            struct ar_hdr *arhdr;
            ofs = lh->h_un.intval;
            arhdr = (struct ar_hdr *) map(ofs, sizeof(struct ar_hdr));
            {        int32 i;
                for (i = 0; i < 16; i++)
                    if (arhdr->ar_name[i] == ' ')
                        arhdr->ar_name[i] = '\0';
            }
            mname = arhdr->ar_name;
            siz = atoi(arhdr->ar_size);
            hdr = map_perm(ofs += sizeof(struct ar_hdr),
                           sizeof(struct exec));
            if (((struct exec *) (hdr))->a_magic != OMAGIC)
                hdr = map_perm(ofs + sizeof(struct exec),
                    sizeof(struct exec_header) - sizeof(struct exec));
            if (verboseflag) msg(info_loadmemb(mname, cplusplusname(h->name+2)));
            setfilesection(fep, ofs, siz);
            lastobj = nextobj;
            nextobj = addobject(nextobj, mname, fep, hdr, ofs, siz);
            load1(*lastobj);
            setfile(fep);
        }
        h = h->h_un.globval->next;
    }
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static int enter_alf_symbols(struct fentry *fep)
{
    cf_entry *ce;
    lib_direntry *symt, *symtend, *d;
    lib_direntry *diry, *diryend;
    int has_old_alf_symt;

    ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
    diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
    ce = findchunk(fep->f_un.cfhdr, LIB_VRSN);
    has_old_alf_symt = (ce == NULL) ? 1 : 0;
/* (findchunk(fep->f_un.cfhdr, LIB_DATA) - fep->f_un.cfhdr->cf_chunks) - 1; */

    if (fep->lflag == 'a') return has_old_alf_symt;
    /* not library/a... */

    if (has_old_alf_symt && fep->lflag != 'l')
    {   /* old libraries are /a by default... */
        fep->lflag = 'a';
        return has_old_alf_symt;
    }

    ce = findchunk(fep->f_un.cfhdr, OFL_TIME);
    if (ce == NULL)
        msg(warn_nosymtab(fep->fname));
    else
    {   int32 *p1, *p2, t1, t2;
        p1 = (int32 *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(fep->f_un.cfhdr, LIB_TIME);
        p2 = (int32 *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        t1 = hv(p1[1]) & 0xffff;
        t2 = hv(p2[1]) & 0xffff;
        if (t2 > t1 || (t1 == t2 && hv(p2[0]) > hv(p1[0])))
            msg(warn_ood(fep->fname));
        else
        {   int32 chunkbase = has_old_alf_symt ? 1 : 0;

            ce = findchunk(fep->f_un.cfhdr, OFL_SYMT);
            symt = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
            symtend = (lib_direntry *) ((char *) symt + hv(ce->cfe_size));
            for (; symt < symtend;
                symt = (lib_direntry *) ((char *) symt +
                    hv(symt->lib_entrylength)))
            {
                if (symt->lib_chunkidx == 0) continue;
                enter(symt->lib_entry, &libsymtable)->h_un.intval =
                    hv(symt->lib_chunkidx) - chunkbase;
            }
            return has_old_alf_symt;
        }
    }

    /* library has no symt */
    for (d = diry; d < diryend;
        d = (lib_direntry *) ((char *) d + hv(d->lib_entrylength)))
    {
        cf_header *cfhdr;
        aof_header *aofhdr;
        aof_symbol *aofsymt, *syend;
        char *strt;
        int32 nsyms;

        if (d->lib_chunkidx == 0) continue;
        ce = fep->f_un.cfhdr->cf_chunks + hv(d->lib_chunkidx);
        setfilesection(fep, hv(ce->cfe_offset), hv(ce->cfe_size));
        cfhdr = (cf_header *) map(0, sizeof(cf_header));
        cfhdr = (cf_header *) map(0, sizeof(cf_header) +
            hv(cfhdr->cf_maxchunks) * sizeof(cf_entry));
        ce = findchunk(cfhdr, OBJ_HEAD);
        aofhdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(cfhdr, OBJ_SYMT);
        aofsymt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(cfhdr, OBJ_STRT);
        strt = (char *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        nsyms = hv(aofhdr->aof_nsyms);
        for (syend = aofsymt + nsyms; aofsymt < syend; aofsymt++)
        {   if ((hv(aofsymt->sym_AT) & SYM_REFDEFMASK) !=
                                       SYM_GLOBALDEFAT) continue;
            enter(strt + hv(aofsymt->sym_name), &libsymtable)->
                h_un.intval = hv(d->lib_chunkidx);
        }
        setfile(fep);
    }
    return 0;
}

static void load_whole_alf_lib(struct fentry *fep)
{
    cf_entry *ce;
    lib_direntry *diry, *diryend;
    struct oentry **lastobj;
    char *hdr;
    int32 ofs, siz;

    ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
    diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
    for (; diry < diryend;
        diry = (lib_direntry *) ((char *) diry + hv(diry->lib_entrylength)))
    {
        if (diry->lib_chunkidx == 0) continue;
        ce = fep->f_un.cfhdr->cf_chunks + diry->lib_chunkidx;
        ofs = hv(ce->cfe_offset);
        siz = hv(ce->cfe_size);
        setfilesection(fep, ofs, siz);
        lastobj = nextobj;
        if (sectinram == NULL &&
            ALLOCABLE(siz) && (hdr = cache_alloc(siz)) != NULL)
        {   sectinram = readfile(hdr, ofs, siz);
#ifdef DEBUG_MEM
fprintf(stderr, "stacked %s, size = %ld\n", diry->lib_entry, siz);
#endif
        }
        hdr = map_perm(0, sizeof(struct cf_header));
        hdr = map_perm(0, sizeof(struct cf_header)+
            hv(((cf_header *) hdr)->cf_maxchunks)*sizeof(cf_entry));
        nextobj = addobject(nextobj, diry->lib_entry, fep, hdr, ofs, siz);
        (*lastobj)->objbuffer = sectinram;
        load1(*lastobj);
        setfile(fep);
    }
}

static void load_alf_lib(struct fentry *fep)
{
    char **mnames, *mname;
    int32 *chunkmap;
    int has_old_alf_symt;

    mnames = NULL;
    chunkmap = NULL;
    has_old_alf_symt = enter_alf_symbols(fep);

    if (fep->lflag != 'a')
    {   int32 i, maxchunks;
        cf_entry *ce;
        lib_direntry *diry, *diryend;

        maxchunks = hv(fep->f_un.cfhdr->cf_maxchunks);
        mnames = (char **) salloc(maxchunks * sizeof(char *));
        if (has_old_alf_symt)
            chunkmap = (int32 *) salloc(maxchunks * sizeof(int32));
        ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
        diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
        for (i = 0;  diry < diryend;  i++,
            diry = (lib_direntry *)
                ((char *)diry + hv(diry->lib_entrylength)))
        {
            mnames[hv(diry->lib_chunkidx)] = diry->lib_entry;
            if (has_old_alf_symt) chunkmap[i] = hv(diry->lib_chunkidx);
        }
    }

    if (fep->lflag != 'a')
    {   struct oentry **lastobj;
        struct cf_entry *ce;
        struct hentry *h, *lh;
        int32 chunkindex, ofs, siz;
        char *hdr;
        int again = 1;

      while (again)
      { if (verboseflag)
        {   if (again == 2)
                msg(info_rescanlib(fep->fname));
            else
                msg(info_scanlib(fep->fname));
        }
        again = 0;
        for (h = firstglobsym;  h != NULL;  h = h->h_un.globval->next)
        {   if ((h->h_un.globval->symval.flags & SYM_SCANLIB) &&
                h->h_un.globval->symval.value == 0 &&
                h->name[0] == '!' && h->name[1] == '!' &&
                ((lh = lookup(h->name + 2, &libsymtable)) != 0))
            {
                h->h_un.globval->symval.flags &= ~SYM_SCANLIB;
                chunkindex = lh->h_un.intval;
                if (chunkmap != NULL) chunkindex = chunkmap[chunkindex];
                mname = mnames[chunkindex];
                ce = fep->f_un.cfhdr->cf_chunks + chunkindex;
                ofs = hv(ce->cfe_offset);
                siz = hv(ce->cfe_size);
                setfilesection(fep, ofs, siz);
                if (sectinram == NULL &&
                    ALLOCABLE(siz) && (hdr = cache_alloc(siz)) != NULL)
                {   sectinram = readfile(hdr, ofs, siz);
#ifdef DEBUG_MEM
fprintf(stderr, "stacked %s, size = %ld\n", mname, siz);
#endif
                }
                hdr = map_perm(0, sizeof(struct cf_header));
                hdr = map_perm(0, sizeof(struct cf_header) +
                    hv(((cf_header *) hdr)->cf_maxchunks)*sizeof(cf_entry));
                if (verboseflag) msg(info_loadmemb(mname, h->name+2));
                lastobj = nextobj;
                nextobj = addobject(nextobj, mname, fep, hdr, ofs, siz);
                (*lastobj)->objbuffer = sectinram;
                load1(*lastobj);
                if (verboseflag >= 3) {
                    ReportNewUndefineds();
                    ReportNewDefineds();
                }
                again = 2;
            }
        }
      }
    }
    else
    {   if (verboseflag) msg(info_loadlib(fep->fname));
        load_whole_alf_lib(fep);
    }
}

#endif /* TARGET_HAS_AOF */

static void load_lib(struct fentry *fep)
{   char *lock = lock_in_cache(fep->filebuffer);
    mark_stack();
    setfile(fep);
    hashinit(&libsymtable, LIBSYMTABLESIZE, salloc);
    if (fep->type == AR) {
#ifdef TARGET_HAS_AOUT
        load_ar_lib(fep);
#endif
    } else {
#ifdef TARGET_HAS_AOF
        load_alf_lib(fep);
#endif
    }
    pop_stack();
    unlock_cache_block(lock);
}

static struct aentry *find_object_area(char *obj_area_name, char *err_context)
{   char *s, *area;
    struct oentry *oep;

/* Read a name of the form object_name(area_name). The (area_name) may  */
/* be omitted if there is only one area in the object. Return a pointer */
/* to the identified area. obj_area_name MUST BE WRITABLE.              */

    area = NULL;
    for (s = obj_area_name;  *s != 0 && *s != '(';) ++s;
    if (*s == '(')
    {   *s++ = 0;
        area = s;
        while (*s != ')' && *s != '0') ++s;
        if (*s == ')')
            *s = 0;
        else
        {   msg(err_bad_areaname(err_context,obj_area_name, area));
            return NULL;
        }
    }

    for (oep = objectlist;  oep != NULL; oep = oep->next)
        if (CiStrEQ(oep->oname, obj_area_name))
        {   struct aentry *a, *aep = NULL;
            int found = 0;
            for (a = objarealist;  a != NULL;  a = a->nxt)
            {   if (a->oep == oep &&
                    (area == NULL || CiStrEQ(area, a->name)))
                {   if (found == 0)
                        aep = a;
                    else
                       msg(err_mult_area(err_context, obj_area_name));
                    ++found;
                }
            }
            if (found == 0)
                msg(err_area_notfound(err_context, area, obj_area_name));
            return aep;
        }
    msg(err_object_notfound(err_context, obj_area_name));
    return NULL;
}

static void mark_area(char *name, int flags, char *err_context)
{   struct aentry *aep;
    if (name == NULL) return;
    aep = find_object_area(name, err_context);
    if (aep != NULL) aep->flags |= flags;
}

static char *static_copy(char *s)
{   if (s == NULL)
        return NULL;
    else
        return strcpy(halloc(strlen(s)+1L), s);
}

static struct fentry **parse_cmd(char **argv, struct fentry **nextfile)
{
    char *ap;
    FILE *viafile;
    int32 libflag;

    libflag = 0;
    while ((ap = *++argv) != 0)
    {   int c;
        if (*ap != '-')
        {   int  lflag, err;
            char *cp;

            cp = ap;
            while (*cp) {
                if (*cp == ',') {
                    *cp = '\0'; /* Complete & total kludge */
                    *argv = ++cp;
                    msg(warn_commasep(ap));
                    argv--;
                    break;
                }
                cp++;
            }
            lflag = 0;
            if (libflag)
                lflag = 'l';
            c = *(cp = ap + strlen(ap) - 1);
            c = LOWER(c);
            if ((c=='a' || c=='l') && *--cp == '/') {
                lflag = c;
                *cp = '\0';                        /* Chop off /a or /l */
            }
#ifdef LINKING_ON_RISCOS
            startdirsearch(ap);         /* Expand wildcards if RISC OS */
            for (;;)
            {   ap = getwildcard(&err);
                if (err != 0) msg(fatal_dirread(ap));
                if (ap == NULL) break;
                nextfile = addfile(nextfile, ap, lflag);
            }
#else
            nextfile = addfile(nextfile, ap, lflag);
#endif
            continue;
        }
        c = *++ap;
        c = LOWER(c);
        switch (c)
        {
        case 'a':
            if (CiStrEQ(ap, "aif") &&
                output_type == AIF &&
                binaryflag == BIN_NOHDR)
            {   /* -bin -aif */
                binaryflag = BIN_AIFHDR;
                continue;
            }
            if (output_type) msg(fatal_multout);
            if (CiStrEQ(ap, "aif"))
                output_type = AIF;
            else if (CiStrEQ(ap, "aof"))
            {   output_type = AOF;
                plinkflag = 1;
            }
            else if (CiStrEQ(ap, "aout"))
                output_type = AOUT;
            else
                goto defolt;
            break;
        case 'b':
            if (ap[1] == 0 || CiStrEQ(ap, "base"))
                goto RO_base;
            else if (CiStrEQ(ap, "bin"))
            {   if (output_type != 0 &&
                    !(output_type == AIF && binaryflag == 0))
                    msg(fatal_multout);
                if (output_type == AIF)
                    binaryflag = BIN_AIFHDR;
                else
                    binaryflag = BIN_NOHDR;
                output_type = AIF;
            }
            else
                goto defolt;
            break;
        case 'c':
#ifdef LINKING_ON_ACORN_RISC_OS
            /* c++ flag */
            if (ap[1] == '+' && ap[2] == '+') {
                cplusplusflag = 1;
                continue;
            }
            else
#endif
            casefn = cistrcmp;
            break;
        case 'd':
            if (CiStrEQ(ap, "dde"))
                ddeflag = 1;
            else if (CiStrEQ(ap, "dupok"))
                duplicateflag = 1;
            else if (CiStrEQ(ap, "data"))
            {   rw_ext = ".dat";
                goto RW_base;
            }
            else
            {   debugflag = 1;
                if (ddeflag && CiStrEQ(ap, "dbug"))
                {   if (output_type && output_type != AOF) msg(fatal_multout);
                    output_type = AOF;
                }
            }
            break;
        case 'e':
            if (CiStrEQ(ap, "errors"))
            /* Put all following error diagnostics to a file */
            {   FILE *e;
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((e = fopen(*argv, "w")) == NULL)
                    msg(fatal_reopen_stderr(*argv));
                else
                {   fclose(e);
                    freopen(*argv, "w", stderr);
                }
                continue;
            }
            if (CiStrEQ(ap, "edit"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (editfile) msg(fatal_multflag(ap));
                editfile = static_copy(*argv);
                continue;
            }
            if (ap[1] == 0 || CiStrEQ(ap, "en") || CiStrEQ(ap, "entry"))
            {   char *s, *e;
                if (entryflag) msg(fatal_multflag(ap));
                if ((s = *++argv) == 0) msg(fatal_noarg(ap));
                if ((e = strchr(s, '+')) != NULL)
                {   entryflag = 2;
                    *e = 0;
                    entryarea_name = static_copy(e+1);
                    entryoffset = getnum(s, fatal_badentry);
                }
                else
                {   entryflag = 1;
                    entrypoint = getnum(s, fatal_badentry);
                }
            }
            else
                goto defolt;
            break;
        case 'f':
            if (CiStrEQ(ap, "first"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                first_area = static_copy(*argv);
            }
            else if (ap[1] == 0)
                libflag = 0;
            else
                goto defolt;
            break;
        case 'h':
            help();
            endlink(0);
            /*NOTREACHED*/
        case 'l':
            if (CiStrEQ(ap, "linkversion"))
            {
#ifdef Module_Version
                char *eptr;
                unsigned long version;
                if (*++argv == 0) msg(fatal_nover(ap));
                version = strtoul(*argv, &eptr, 10);
                if (*eptr != '\0') msg(fatal_nover(ap));
                if (version > Module_Version) {
                        int major = (int) version / 100;
                        int minor = (int) version % 100;
                        msg(fatal_needver(Module_MajorVersion, major, minor));
                }
#endif
            }
            else
            if (CiStrEQ(ap, "list"))
            /* Put MAP and Xref output to a file */
            {   FILE *l;
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((l = fopen(*argv, "w")) == NULL)
                    msg(fatal_reopen_stderr(*argv));
                else
                {   fclose(l);
                    freopen(*argv, "w", stdout);
                }
            }
            else if (CiStrEQ(ap, "last"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                last_area = static_copy(*argv);
            }
            else if (ap[1] == 0)
                libflag = 1;
            else
                goto defolt;
            break;
        case 'i':
            if (CiStrEQ(ap, "ihf"))
            {   output_type = IHF;
                continue;
            }
            if (CiStrNE(ap, "image")) goto defolt;
            ap = "o";
            /* FALL THROUGH */
        case 'o':
            if (CiStrEQ(ap, "ov") || CiStrEQ(ap, "overlay"))
            {   c = OVERLAY;
                goto scatter_format_image;
            }
#ifdef TARGET_HAS_AOUT
            if (CiStrEQ(ap, "omagic"))
            {   if (output_type) msg(fatal_multout);
                output_type = AOUT;
                plinkflag = 1;
                continue;
            }
#endif
            if (ap[1] == 0 || CiStrEQ(ap, "output"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (outfile) msg(fatal_multout);
                outfile = static_copy(*argv);
                continue;
            }
            goto defolt;
        case 'm':
            if (CiStrEQ(ap, "map"))
            {   mapflag = 1;
                continue;
            }
            else if (CiStrEQ(ap, "match"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                match_opts = (int) getnum(*argv, fatal_badmatchopts);
                continue;
            }
#ifdef TARGET_IS_RISCOS
            /* -module assumed */
            if (output_type) msg(fatal_multout);
            output_type = RMF;
            break;
#else
            goto defolt;
#endif
        case 'q':
            if (!*++argv) msg(fatal_noarg(ap));
            qflag = getnum(*argv, fatal_badwork);
            break;
        case 'w':
            if (workspaceflag) msg(fatal_multflag(ap));
            if (!*++argv) msg(fatal_noarg(ap));
            workspaceflag = 1;
            workspace = getnum(*argv, fatal_badwork);
            break;
        case 'r':
            if (CiStrEQ(ap, "rmf"))
            {   if (output_type) msg(fatal_multout);
                output_type = RMF;
            }
            else if (CiStrEQ(ap, "reent") || CiStrEQ(ap, "reentrant"))
                reent_flag = 1;
            else if (CiStrEQ(ap, "ro") || CiStrEQ(ap, "ro-base"))
            {   ro_ext = ".ro";
RO_base:        if (baseflag) msg(fatal_multbases);
                if (!*++argv) msg(fatal_badbase);
                base = getnum(*argv, fatal_badbase);
                baseflag = 1;
            }
            else if (CiStrEQ(ap, "rw") || CiStrEQ(ap, "rw-base"))
            {   rw_ext = ".rw";
RW_base:        if (rw_baseflag) msg(fatal_multflag(ap));
                if (*++argv == 0) msg(fatal_noarg(ap));
                data_base = getnum(*argv, fatal_baddatabase);
                rw_baseflag = 1;
            }
            else /* -relocatable assumed */
                relocflag = 1;
            continue;
        case 'n':
            if (CiStrEQ(ap, "nounusedareas") || CiStrEQ(ap, "nounused"))
            {   nounusedflag = 1;
                continue;
            }
#ifdef TARGET_HAS_AOUT
            else if (ap[1] != 0)
                goto defolt;
            if (output_type) msg(fatal_multout);
            output_type = AOUT;
            nmagicflag = 1;
            break;
        case 'z':
            if (output_type) msg(fatal_multout);
            output_type = AOUT;
            plinkflag = 0;
            break;
#endif
            goto defolt;
        case 's':
            if (CiStrEQ(ap, "shl"))
            {   if (output_type) msg(fatal_multout);
                output_type = AOF;
                plinkflag = 1;
                shl_flag = 1;
                if ((shl_file = *++argv) == NULL)
                    msg(fatal_noarg(ap));
                else
                    shl_file = static_copy(shl_file);
            }
            else if (ap[1] == 0 || CiStrEQ(ap, "sym") || CiStrEQ(ap, "symbols"))
            {   if ((symfile = *++argv) == NULL)
                    msg(fatal_noarg(ap));
                else
                    symfile = static_copy(symfile);
            }
            else if (CiStrEQ(ap, "split"))
                splitflag = 1;
/*/* The space in "scat ter" ensures there can never be a match, which is */
/* what is intended for R1.6. Fix later when -scatter has been developed. */
            else if (CiStrEQ(ap, "scat ter"))
            {   c = SCATTERIMAGE;
scatter_format_image:
                if (*++argv == 0) msg(fatal_noarg(ap));
                if (scatterflag) msg(fatal_multflag(ap));
                scatterflag = c;
                scatterfile = static_copy(*argv);
                continue;
            }
            else
                goto defolt;
            break;
        case 'u':
            if (ap[1] == 0 || CiStrEQ(ap, "unresolved"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (unresolved_fn != NULL)
                    msg(fatal_multunresolved);
                else
                {   unresolved_fn = globinsert(*argv,
                        makesym(0, SYM_REFAT, NULL), "!!")->h_un.globval;
                }
            }
            else
                goto defolt;
            break;
        case 'v':
        {   char *nargv[64], *cp;
            int i, lineno;

            if (CiStrEQ(ap, "via"))
            {   /* VIA viafile */
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((viafile = fopen(*argv, "r")) == 0)
                    msg(fatal_openerr(*argv));
                lineno = 0;
                while ((cp = getline(viafile, *argv, ++lineno)) != NULL)
                {   while (isspace(*cp)) cp++;
                    i = 1;
                    while (*cp)
                    {   nargv[i++] = cp;
                        if ( i > sizeof(nargv)/sizeof(char *))
                            msg(fatal_toomany(viafile, lineno));
                        while (*cp != 0 && !isspace(*cp)) cp++;
                        if (*cp)
                        {   *cp++ = '\0';
                            while (isspace(*cp)) cp++;
                        }
                    }
                    nargv[i] = 0;
                    nextfile = parse_cmd(nargv, nextfile);
                }
                if (ferror(viafile)) msg(fatal_readerr(*argv));
                fclose(viafile);
            }
            else
            {   /* assume -verbose, -v, -vv, etc */
                i = *ap++;
                while ((i = LOWER(i)) == 'e' || i == 'v')
                {   ++verboseflag;
                    i = *ap++;
                }
            }
            break;
        }
        case 'x':
            xrefflag = 1;
            break;
        default:
        defolt:
            msg(fatal_badflag(ap));
        }
    }
    return nextfile;
}

static void list_syms(void)
{
    FILE *f;
    struct globsym *gs;
    struct hentry *h;
    struct aentry *aep;
    struct oentry *oep;

    if (symfile == NULL) return;

    if (strcmp(symfile, "-") == 0)
        f = stdout;
    else if ((f = fopen(symfile, "w")) == 0)
        msg(fatal_openerr(symfile));

    fprintf(f, msgtext(misc_sym_hdr));
    h = firstglobsym;
    while (h != NULL)
    {   gs = h->h_un.globval;
        aep = gs->symval.area;
        if (aep != NULL && (aep->flags & UNUSEDAREA)) goto skip_unused;
        fprintf(f, "%-24s", cplusplusname(h->name + 2));
        if (!(gs->symval.flags & SYM_DEFAT))
        {   if (gs->symval.flags & SYM_WEAKAT)
                fprintf(f, msgtext(misc_sym_undefweak));
            else
                fprintf(f, msgtext(misc_sym_undefref));
            oep = gs->symval.refobj;
        }
        else
        {   fprintf(f, " %06lx", gs->symval.value);
            oep = 0;
            if (aep && plinkflag)
            {   fprintf(f, " + |%s|", aep->name);
                oep = aep->oep;
            }
        }
        if (oep && plinkflag)
        {   fprintf(f, msgtext(misc_map_fromfile), oep->fep->fname);
            if (oep->fep->type & LIB_MASK)
                fprintf(f, "(%s)", oep->oname);
        }
        fputc('\n', f);
skip_unused:
        h = gs->next;
    }
    if (ferror(f)) msg(fatal_writeerr(symfile));
    if (f != stdout) fclose(f);
}

int main(int argc, char **argv)
{
    struct fentry *fep;
    struct aentry *aep;
    struct lventry *lv;
    struct oventry *ov;

    level_strs[0] = msgtext(msglevel_info);
    level_strs[1] = msgtext(msglevel_warning);
    level_strs[2] = msgtext(msglevel_error);
    level_strs[3] = msgtext(msglevel_fatal);

    (void)program_name(argv[0], myname, sizeof(myname));
    if (argc <= 1)
    {   help();
        endlink(0);
        /*NOTREACHED*/
    }

#ifdef TIME
    int32 start_time = cs_wall_clock();
#endif
    notyetdef = 0;
    signal(SIGINT, endlink);
    signal(SIGTERM, endlink);
    signal(SIGILL, endlink);
    signal(SIGABRT, endlink);
/*  signal(SIGFPE, endlink); crashes IBM PS2/55SX with Watcom C/386 v9.01 */
    signal(SIGSEGV, endlink);
#ifdef TARGET_HAS_AOUT
    pagesize = PAGESIZE;
#endif
    maxopenfiles = MAXOPENFILES;
#ifdef LINKING_ON_UNIX
#  ifdef UNIX_NATIVE_LINKER
    pagesize = getpagesize();
#  endif
#endif
#ifdef LINKING_ON_MAC
    Tracked_init();
#endif
    hashinit(&commontable, COMMONTABLESIZE, halloc);
    hashinit(&globhashtable, GLOBHASHTABLESIZE, halloc);
    firstglobsym = NULL;
    nextglobsym = &firstglobsym;
    match_opts = patchable_config.match_opts;

    (void) parse_cmd(argv, &clifilelist);

    if (output_type == AOUT)
        common = addarea("Aout$$Common", NULL, 0, 0, 0, 0, AOF_COMREFAT, 0);

    if (failedtostack) msg(warn_nearoutmem);

    if (plinkflag)
    {   if (shl_flag)
        {   if (!baseflag) base = 0;
        }
        else
        {   if (baseflag) msg(fatal_basedplink);
            base = 0;
        }
    }

    if (binaryflag == BIN_NOHDR && debugflag)
    {   debugflag = 0;
        msg(warn_dbgignored_1);
    }

    if (output_type == NOTYPE) output_type = DEFOUTPUT_TYPE;
    if (output_type == RMF) {output_type = AIF;  moduleflag = 1;}

    if (output_type == IHF)
    {   output_type = AIF;
        binaryflag = BIN_NOHDR;
        intellecflag = 1;
        if (rw_baseflag && !splitflag)
        {   msg(warn_rwbaseignored);
            rw_baseflag = 0;
        }
    }

    if (!baseflag && (binaryflag || intellecflag)) base = 0;

    /* IHF must always start at 0 */
    /* if (intellecflag) intellec_base = (unsigned)base; */
    intellec_base = 0;

    if (outfile == NULL)
    {   if (output_type == AOUT)
            outfile = AOUTFNAME;
        else if (output_type == AIF)
        {   if (scatterflag)
                outfile = OVRFNAME;
            else
                outfile = AIFFNAME;
        }
        else
            outfile = AOFFNAME;
    }

    if (clifilelist == NULL) msg(fatal_nofiles(myname));

    if (scatterflag == OVERLAY)
    {   (void) addarea("Overlay$$Data", NULL, 0, 64 * 16,
                        0, 0, AOF_COMREFAT, 0);
        load_seg_and_go = globinsert("Image$$load_seg",
                                     makesym(0, SYM_REFAT, NULL), "!!");
        overlay_init = globinsert("Image$$overlay_init",
                                  makesym(0, SYM_REFAT, NULL), "!!");
    }

    if (shl_flag)
    {   dyn_link = globinsert("__rt_dynlink",
            makesym(0, SYM_REFAT+SYM_LINKSYM, NULL), "!!");
        /* These symbols are never output - they are optimised away by */
        /* AOF output formatting - but it's very convenient during the */
        /* construction of inter-LU veneer objects and shared libs.    */
        sb_limit = globinsert(mkname(NULL, interLUdataName, "$$Limit"),
            makesym(0, SYM_LOCALDEFAT+SYM_ABSAT, NULL), "!!");
        eft_offset = globinsert("EFT$$Offset",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        eft_params = globinsert("EFT$$Params",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        shl_datasz = globinsert("SHL$$data$$Size",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        stub_0base = globinsert("$$0$$Base",
            makesym(0, SYM_GLOBALDEFAT, NULL), "!!");
        shl_database = globinsert("SHL$$data$$Base",
            makesym(0, SYM_GLOBALDEFAT, NULL), "!!");
    }

    symcount = 0;
    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   struct oentry **lastobj;
        if (!(fep->type & OBJECT_MASK)) continue;
        setfile(fep);
        lastobj = nextobj;
        nextobj = addobject(nextobj, fep->fname, fep,
                            fep->f_un.hdrptr, 0, fep->size);
        if (lastobj == &objectlist &&
            special_aof(*lastobj)) continue;
        if (verboseflag) msg(info_loadobj(fep->fname));
        load1(*lastobj);
        if (verboseflag >= 2)
        {   ReportNewUndefineds();
            ReportNewDefineds();
        }
    }

    /* Turn on debugging if any input area is a DEBUG area. An AIF output  */
    /* can only have DEBUG areas if binaryflag != BIN_NOHDR (See addarea().*/
    /* We repeat the test here for local completeness. Note also that we   */
    /* allow a DEBUG area in a primary input to turn on debugging, but not */
    /* so for a DEBUG area in a library. We may want to revise this later. */

    /* IDJ - 3-Oct-94: remove auto-inclusion of debug areas for RISC OS */

#ifdef LINKING_ON_ACORN_RISC_OS
    if ((output_type == AIF || output_type == RMF) && binaryflag != BIN_NOHDR && has_dbg_areas && !debugflag)
        msg(info_dbgignored_nod);
#else
    if (output_type == AIF && binaryflag != BIN_NOHDR && has_dbg_areas)
        debugflag = 1;
#endif

    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
        if (fep->type & LIB_MASK)
            load_lib(fep);

    mark_area(first_area, AREA_FIRST, "-First");
    mark_area(last_area,  AREA_LAST,  "-Last");

    if (entryarea != NULL && entryarea_name != NULL)
        msg(warn_multentry(
            entryarea->oep->oname, entryarea->name, entryarea_name));

    if (entryarea_name != NULL)
        entryarea = find_object_area(entryarea_name, "-Entry");

    if (common != NULL) common->oep = NULL;
    *nextobjarea = NULL;
    init_overseg(&root, outfile, ROOTNAME);

    if (scatterflag)
    {   build_overlay_tree();
#ifdef LINKING_ON_MSDOS
        mkdir(outfile);
#else
        mkdir(outfile, 0775);
#endif
    }

    if (shl_flag)
        build_shl_description();

    if (entryarea == NULL ||
        output_type != AIF ||
        binaryflag || debugflag)
        /* Don't remove unreferenced areas except from vanilla AIF images */
        nounusedflag = 1;

    do_final_symbol_matching();

    if (scatterflag || xrefflag || shl_flag || nounusedflag == 0)
    {   struct aentry *reftoarea;
        if (xrefflag)
            printf(msgtext(misc_xref_hdr));
        for (aep = objarealist; aep != NULL; aep = aep->nxt)
            add_area_xrefs(aep);
        if (scatterflag &&
            entryarea != NULL &&
            (reftoarea = overlay_init->h_un.globval->symval.area) != NULL)
            addarearef(entryarea, reftoarea);
        if (xrefflag) printf("\n");
    }

    if (nounusedflag == 0)
        remove_unused_areas();

    place_areas();
    place_libareas();
    strtsize = 4;
    middle();
    if (symfile) list_syms();

    if (error_count == 0)
    {   if (mapflag)
        {   print_map(&root);
            for (lv = root.level_list;  lv != NULL;  lv = lv->next)
            {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
                    print_map(ov);
            }
        }
        if (verboseflag) msg(info_openout(outfile));
        put_image_segment(&root);
        for (lv = root.level_list;  lv != NULL;  lv = lv->next)
        {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
                put_image_segment(ov);
        }
    }
    else
        msg(info_errors);
    if (verboseflag)
        msg(info_mem_use(heap_sz, max_stack_sz, cache_sz));
#ifdef TIME
    fprintf(stderr, "Time = %d cSec\n", cs_wall_clock() - start_time);
#endif
    endlink(0);
    /*NOTREACHED*/
    argc = argc;
    return 0;
}
