/*
 * ARM AOF Linker
 * Copyright (C) 1991-93 Advanced RISC Machines Limited. All rights reserved.
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 * IDJ: 14-Oct-94: bug fix for AQU-00046, AQU-00044, AQU-00062 (naff -aof output)
 */

#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include <signal.h>
#include <string.h>


/*
 * IDJ (Acorn) 3-Oct-94: bug-fix AQU-00065: don't automatically include debug
 *                       areas if found when no "-d".  Just print informational
 *                       message at end of link.  Previous behaviour annoys people!
 */
/*
 * RMJ 04Dec96: make sure the module relocation code is written out with the
 *              correct endianness.
 */

#ifdef __STDC__
#  include <stdlib.h>
#  include <stdarg.h>
#  include <time.h>
#  define  LOWER(ch)    (tolower((unsigned char)ch))
#  ifdef __GNUC__
#    include <unistd.h>
/* BSD/SUN don't have strtoul(), but then strtol() doesn't barf on */
/* overflow as required by ANSI... This bodge is horrid.           */
#    define strtoul(s, ptr, base) strtol(s, ptr, base)
#  endif
#else
#  include <varargs.h>
#  include <unistd.h> /* for SEEK_SET (IJR) */
extern char *malloc();
extern char *memcpy();
/* BSD/SUN don't have strtoul(), but then strtol() doesn't barf on */
/* overflow as required by ANSI... This bodge is horrid.           */
#  define strtoul(s, ptr, base) strtol(s, ptr, base)
extern int errno;
#  define  LOWER(ch) \
       (isascii(ch) && isupper(ch) ? tolower(ch): (unsigned char)ch)
#endif

#include "options.h"
#include "hostdep.h"
#include "msgnos.h"
#include "aof.h"
#include "prgname.h"

#ifdef LINKING_ON_ACORN_RISC_OS
#include "riscos.dem.h"
#include <assert.h>
#endif

#ifdef TARGET_HAS_AOUT
#  ifdef TARGET_IS_UNIX
#    include "vmparam.h"               /* for USRSTACK */
#  endif
#  include "aoutvsn.h"
#  include "exec.h"
#  include "aout.h"
#  include "ar.h"
#  include "ranlib.h"
#  ifndef PAGESIZE
#    define PAGESIZE   8192         /* there has to be some default... */
#  endif                            /* ... but assumed set by aout.h.  */
#endif

#ifdef TARGET_HAS_AOF
#  include "libflfmt.h"
#  include "chunkfmt.h"
#  include "aif.h"
#  include "aifcode.h"
#  include "asdfmt.h"
#  include "ovrflfmt.h"
#endif

#ifndef SELF
#  define SELF    "ARM Linker"
#endif
#ifndef IDFNSTR
#  define IDFNSTR " Version 5.00f (Acorn Computers Ltd) <beta+ release>"
#endif            /* NB - leading space is needed */
#ifndef __DATE__
#  include "datenow.h" /* [Mar 30 1993] */
#endif

#define StrEQ(x, y)   (strcmp((x), (y)) == 0)
#define StrNE(x, y)   (strcmp((x), (y)) != 0)
#define CiStrEQ(x, y) (cistrcmp((x), (y)) == 0)
#define CiStrNE(x, y) (cistrcmp((x), (y)) != 0)

#define SYM_LINKSYM   0x01000000 /* well clear of AOF attributes.  */
#define SYM_EFTSYM    0x02000000 /* exported from a shared library */
#define SYM_DEXSYM    0x04000000 /* directly-exported from a shared lib. */
#define SYM_FNVSYM    0x08000000 /* exported via address-taken fn veneer */
#define SYM_SCANLIB   0x10000000 /* scan library to satisfy reference */
#define SYM_LINKFLAGS 0x1f000000

#define MAXLINESIZE   256        /* Program limitation(s) */
#define MAXSYMLEN     256        /* max symbol name length */
#define MAXERRMSGLEN   80        /* Max. length of any error message */
#define MAXAREANAMELEN 64
#define MAXCHUNKS       8        /* max no of chunks in an o/p AOF file */
#define MAXOPENFILES   16        /* max no concurrently open */
#define OVERSEGNAMELEN 10        /* Max len manageable by overlay manager */

#ifdef BIGHASHTABLES             /* PLEASE! make sure these are powers of 2 */
#define AREATABLESIZE     4096
#define GLOBHASHTABLESIZE 16384
#else
#define AREATABLESIZE     512
#define GLOBHASHTABLESIZE 4096   /* about 2200 unique syms in ARMcc */
#endif
#define OBJAREATABLESIZE   16    /* used bigger as needed */
#define COMMONTABLESIZE   128
#define LIBSYMTABLESIZE   512

#define HASH(hash, ch)    (hash*37L + (int32)LOWER(ch))

/* There are only three basic output types, noted below. Others are handled */
/* as subcases. E.g. RMF == (AIF, moduleflag == 1).                         */
#define NOTYPE     0                /* Input / output file types */
#define AOF        1                /* Output type... */
#define OFL        2
#define RMF        3
#define AIF        4                /* Output type... */
#define IHF        5                /* Intellec Hex Format... */

#define AOUT       8 + 1            /* Output type... */
#define AR         8 + 2

#define AOUT_MASK  8
#define LIB_MASK   2

#define OBJECT_MASK 1

#define ALIGN_MASK 3                /* & mask to align to the nearest word */

#ifdef __STDC__
typedef char *(*PFCS)(int32);       /* halloc / salloc switch */
typedef int (*PFI)(const char *, const char *);
                                    /* string compare function */
#else
typedef char *(*PFCS)();            /* halloc / salloc switch */
typedef int (*PFI)();               /* string compare function */
#endif

struct sym;                         /* defence against C++ scoping... */
struct globsym
{   struct hentry *next;
    int32 pcit_entry;
    struct sym
    {   int32 value;
        struct aentry *area;
#ifdef TARGET_HAS_AOUT
        unsigned32 dbxinfo;
#endif
        unsigned32 flags;
        int32 symno;
        struct oentry *refobj;
    } symval;
};

struct hentry
{   struct hentry *next;
    union
    {   int32 intval;
        struct globsym *globval;
        struct aentry *areaval;
    } h_un;
    char name[4];
};

static struct htable
{   struct hentry **table;
    size_t  tablesize;
    PFCS mget;                      /* fn used to allocate memory */
} commontable, globhashtable, libsymtable;


#ifdef LINKING_ON_ACORN_RISC_OS

/*
 * IDJ: 5-May-94: support for C++ static ctors and dtors
 */

struct __link_list {
    struct __link_list *next, *chain;
    struct sym *sy;
};

static struct __link_list *g__link_list = 0;

static struct sym *g__head_sym = 0;
#endif


static char *sharedlib;
static struct hentry *firstglobsym, **nextglobsym;

static struct fentry { /* struct to hold file info from command line */
    struct fentry *next;
    int32  type;                        /* AOF, AOUT, AR, ALF */
    union {
        char *hdrptr;
#ifdef TARGET_HAS_AOF
        cf_header *cfhdr;               /* Chunk file headers + entries */
#endif
#ifdef TARGET_HAS_AOUT
        char *armag;                    /* AR magic no. during file typing */
        struct ar_hdr *arhdr;           /* __.SYMDEF file header */
        struct exec *aouthdr;           /* a.out header */
        struct exec_header *newhdr;/* Extended hdr for shared libs */
#endif
    } f_un;
    int32 size;
    int32 posn;
    char *filebuffer;
    int  fd;               /* file descriptor + file seek position */
    int  lflag;
    char fname[4];         /* file name (as many chars as needed) */
} *clifilelist;

static int failedtostack;
static int32 outsiz;
static int32 relocposn, areaoutposn, srcposn;

struct lventry {
    struct oventry *seg_list;
    struct lventry *next;
    int32 clash;
};

static struct oventry {
    struct aentry **nextarea, *areas, *outarealist;
    struct aentry **arealist, **outareas;
    int32 textsize, datasize, bsssize, dbgsize;
    int32 entryv;
    int32 torigin, dorigin, borigin;
    int32 noofareas, noofoutareas;
    int32 pcit_base;
    unsigned32 base, limit;
    struct lventry *level;
    struct lventry *level_list;
    struct oventry *next;
    char *name;
    struct htable areatable;
} root;

static int32 total_seg_size;

struct aentryptr {
    struct aentry *aep;
    struct aentryptr *next;
};

struct aentry {
    struct oentry *oep;
    struct hentry *h;
    struct aentry *nxt;
    struct aentryptr *refs;
    struct oventry *overseg;
    int32 areaoff, areasiz, areapad;
    int32 relocoff, relocs;
    int32 base;
    int32 attrs;
    unsigned32 flags;
    int32 areano;
    int32 areaidx;
    char *areaval;
#ifdef LINKING_ON_ACORN_RISC_OS
    struct __link_list *area__link_list;   /* static ctors for CFront C++ */
#endif
    char name[4];
};

/* Values within an aentry's flags field */
#define  SHFLAG         1   /* a.out shared lib flag */
#define  COMPLAINED     2   /* suppresses multiple attribute clash msgs */
#define  REFERENCED     4   /* used during unused area scan... */
#define  UNUSEDAREA     8   /* used during unused area scan... */
#define  AREA_FIRST    16   /* place this area FIRST... */
#define  AREA_LAST     32   /* ... and this one LAST... */
#define  UNHASHED      64   /* A shared library stub area NOT copied */
                            /* to this shared library's stub.        */
#define  SHLRODATA    128   /* data to be copied from lib to stub */
#define  NOINSTRELOC  256   /* AOF earlier than Vsn 310 doesn't have */
                            /* relocatable instruction sequences */

static struct aentry *common;        /* Common area for a.out */
static struct aentry **nextoutarea;
static struct aentry *objarealist, **nextobjarea = &objarealist;
static struct aentry *lastoutarea;

static struct oentry {
    struct oentry *next;
    char *oname;
    struct fentry *fep;        /* file entry fm which this object was derived */
    union {
        char *hdrptr;
#ifdef TARGET_HAS_AOF
        cf_header *cfhdr;      /* header as read by filetype */
#endif
#ifdef TARGET_HAS_AOUT
        struct exec *aouthdr;
        struct exec_header *newhdr; /* Extended hdr for shared libs */
#endif
    } o_un;
    char *objbuffer;           /* if object is in memory, but file isn't */
    int32 offset;
    int32 size;                /* (== file size for non-library files) */
    struct hentry **numtosym;  /* xlate local symbol nos to table ptrs */
    struct aentry **arealist;  /* list of text & data areas in file    */
    char objectid[4];          /* unique id for this object '!!' .. 'ZZ' */
} *objectlist;

static struct oentry **nextobj = &objectlist;

static int32 popped; /*TBD*/
static int32 reloc_count;

static char objectid[2] = { '!', '!' };     /* gets updated... !!..ZZ */

#ifdef TARGET_HAS_AOF
static cf_header *cfouthdr;
static aof_header *aofhdr;
static size_t cfhdrsize, aofhdrsize;
#endif

#ifdef TARGET_HAS_AOUT
static int32 textrelocs, datarelocs;
static char nmagicflag;        /* Squidge text & data together */
static size_t pagesize;
#endif

static struct aentry *entryarea, *outentryarea;
static unsigned32 entryoffset, outentryofs;
static unsigned32 entrypoint;
static PFI  casefn = strcmp;   /* case sensitive symbol match by default */

/* Values taken by binaryflag - BIN_AIFHDR for a binary file preceded by */
/* an AIF header which describes it. BIN_NOHDR for plain binary.         */
#define BIN_NOHDR     1
#define BIN_AIFHDR    2

/* and values taken by scatterflag */
#define OVERLAY       1
#define SCATTERIMAGE  2

static char entryflag;         /* user supplied entry point? */
static char baseflag;          /* user supplied base address? */
static char debugflag;         /* include debugging areas/symbols? */
static char plinkflag;         /* partial link => keep relocs & symbol table */
static char binaryflag;        /* Only output areas - no header */
static char intellecflag;      /* Binary in VLSI superset-Intellec format */
static char scatterflag;       /* scatter format images, e.g. overlays */
static char verboseflag;       /* tell user whats a going on? */
static char moduleflag;        /* Produce AMF output */
static char private_amf_reloc; /* user supplied own AMF reloc code? */
static char relocflag;         /* Produce relocatable AIF output */
static char workspaceflag;
static char mapflag;           /* Produce placement map of areas */
static char xrefflag;          /* Print area xref */
static char shl_flag;          /* generate APCS-3 shared library */
static char reent_flag;        /* generate reentrant output */
#ifdef LINKING_ON_ACORN_RISC_OS
static char ddeflag = 1;       /* always be DDE compatible for Acorn RISC OS host! */
#else
static char ddeflag;           /* be Acorn C R.3 / DDE compatible */
#endif
static char rw_baseflag;       /* got a separate data base */
static char duplicateflag;     /* allow duplicate symbol defs */
#ifdef TARGET_IS_ACORN_RISC_OS
static char nounusedflag = 1;  /* never remove unref'ed areas for RISC OS target (because of stubs) */
#else
static char nounusedflag;      /* don't eliminate unused areas */
#endif
static char splitflag;         /* split RO and RW into separate O/P files */
static char libdataflag;       /* put shared lib data in the library */
#ifdef LINKING_ON_ACORN_RISC_OS
static char cplusplusflag;     /* support CFront-style ctors and dtors, and name demangling */
static int warned_cpp;
#endif


static unsigned char match_opts;
/* match_opts flag bits... */
#define MATCH_xTOx             1
#define MATCHxTO_x             2
#define MATCHx_yTOxDOTy        4
#define MATCHx__yTOx           8
#define PCREL_IMPLIES_CODE    16
#define WARN_FP3              32

static char has_dbg_areas;     /* if any input AREA has type AOF_DEBUGAT */

static struct {
    int32 id[2];
    unsigned char size,
                  toolid,
                  match_opts;
} patchable_config = {
/* an identifying "string" (but defined as a pair of word values to enable
   target bytesex to be identified by the patching tool
 */
   { ((((((long)'x' << 8) | 'c') << 8) | 'o') << 8) | 'n',
     ((((((long)'f' << 8) | 'i') << 8) | 'g') << 8) | 'x'
   },
   sizeof(patchable_config),
   4,               /* Linker  */
   PCREL_IMPLIES_CODE
};

static int32 qflag;            /* added by LDS for internal bodgery... */
#define  NEW_OVERMGR    1      /* qflag value to get new overlay manager */

static int32 workspace;        /* Workspace to reserve in AIF */
static int32 code_attrs_set = 0L, code_attrs_unset = 0L, code_attrs_warned = 0L;

static unsigned32 base=0x8000; /* base address of code in mem. */
static unsigned32 data_base;   /* separate data base, maybe... */
static int32 textoffset;

static int  output_type;       /* type of o/p to generate: AIF, AOF or a.out */
static char *outf, *outfile;   /* output file */
static char *editfile;         /* file containing link edit commands */
static char *scatterfile;      /* file containing scatter image commands */
static char *symfile;          /* file to take symbol table */
static char *shl_name;         /* name of shared library */
static char *shl_file;         /* name of file containing shared library */
static char *interLUcodeName = "sb$$interLUcode";
static char *interLUdataName = "sb$$interLUdata";
                               /* names of inter-LU code and data areas */

static char *entryarea_name;   /* name of object(area) containing entry point */
static char *first_area;       /* name of object(area) to place first */
static char *last_area;        /* name of object(area) to place last  */
static char *ro_ext = "";      /* file extension for -RO-base -SPLIT  */
static char *rw_ext = "";      /* file extension for -RW-base/-DATA -SPLIT */

static char *level_strs[4];
    /* msglevel_info, msglevel_warning, msglevel_error, msglevel_fatal */
static int  errcount[4];

static char myname[32];

static int32 sectoffset;       /* object / library file managagement vars */
static int32 sectsize;
static char  *sectinram;
static int   openfiles, maxopenfiles;
static struct fentry *curfile;

static int32 area_index;
static int32 strtsize;
static int32 symcount;
static int32 eft_size, eft_extra;
static int32 sposn, strposn, shlposn, shl_chunk;

static int32 overlay_segments;
static int32 entryv_total;
static struct hentry *load_seg_and_go, *overlay_init, *dyn_link;
static struct hentry *sb_limit, *eft_offset, *eft_params;
static struct hentry *stub_0base, *shl_database, *shl_datasz;
static struct aentry *inter_LU_code = NULL, *inter_LU_data = NULL;

static struct globsym *unresolved_fn;

#define LISTBUFSIZE     1024
struct listblock
{
  struct listblock *prev;
  char buf[ LISTBUFSIZE ];
};

struct listspec
{
  struct listblock *topblock;
  size_t itemsize;
  size_t offset;
  size_t maxoffset;
};

static struct listspec reloclist;
static struct listspec aofreloclist;
#ifdef TARGET_HAS_AOUT
static struct listspec aoutreloclist;
#endif

struct globalfile
{
  FILE *handle;
  int32 currentpos;
};

static struct globalfile fout;

#define inform_count  errcount[0]
#define warning_count errcount[1]
#define error_count   errcount[2]
#define fatal_count   errcount[3] /* 0 or 1 */

#define CODE_AREA        0
#define DATA_AREA        1
#define BSS_AREA         2


static int reversing_bytes = 0;

static int32 hv(int32 v)                     /* to host value... */
{   /* Return v with the same endian-ness as the host */
    /* This mess generates better ARM code than the more obvious mess */
    /* and may eventually peephole to optimal code...                      */
    if (reversing_bytes)
    { unsigned32 t;
        /* t = v ^ (v ror 16) */
        t = v ^ ((v << 16) | (((unsigned32)v) >> 16));
        t &= ~0xff0000;
        /* v = v ror 8 */
        v = (v << 24) | (((unsigned32)v) >> 8);
        v = v ^ (t >> 8);
    }
    return v;
}

static int32 tv(int32 v)                     /* to target value... */
{
    return hv(v);
}

static int32 xvs(int32 v)              /* to/fm host value, short... */
{   /* Return v with the same endian-ness as the host */
    if (reversing_bytes)
    {   v = (((v & 0xff) << 24) | ((v & 0xff00) << 8)) >> 16;
    }
    return v;
}

#ifdef TARGET_HAS_AOF

static unsigned32 cf_magic = 0;        /* CF_MAGIC in target byte order */

static int is_cf_magic(int32 v)
{
    if (cf_magic == 0)
    {   if (v == CF_MAGIC) {cf_magic = v;  return 1;}
        reversing_bytes = 1;
        if (hv(v) == CF_MAGIC) {cf_magic = v;  return 1;}
        reversing_bytes = 0;
    }
    else if (v == cf_magic)
        return 1;
    return 0;
}

static int is_reversed_cf_magic(int32 v)
{   int was_reversing = reversing_bytes;
    int rc = 0;
    reversing_bytes = 1;
    if (hv(v) == cf_magic) rc = 1;
    reversing_bytes = was_reversing;
    return rc;
}

static int is_little_endian(void)
{
    return *((unsigned char *)&cf_magic) == (CF_MAGIC & 255);
}

static void target_increment(int32 *ip, int32 i)
{
    *ip = tv(hv(*ip) + i);
}

#endif /* TARGET_HAS_AOF */

static int cistrcmp(const char *s, const char *t)
{   int sch, tch;

    for (;;)
    {   sch = *s++;
        tch = *t++;
        if (sch == tch)
        {   if (sch == 0) return 0; else continue;
        }
        sch = LOWER(sch);
        tch = LOWER(tch);
        if (sch != tch)  return sch - tch;
    }
}

static char *bufcpy(char *t, const char *s, int maxlen)
{   char *r = t;
    while ((*t = *s) != 0 && maxlen > 1) {++t;  ++s;  --maxlen;}
    *t = 0;
    return r;
}

static int32 hashval(const char *name, int32 tabsize)
{
    int32 hash = 0;

    while( *name )
    {
        hash = HASH(hash, *name);
        name++;
    }
    return( hash & ( tabsize - 1L ) );
}

static void hashinit(struct htable *tab, size_t size, PFCS mget)
{
    struct hentry **h, **hend;

    tab->tablesize = size;
    tab->mget = mget;
    tab->table = (struct hentry **) mget(
        (int32)size * (int32)sizeof(struct hentry *));
    for (h = tab->table, hend = h + size; h<hend; *h++ = NULL);
}

static int lookenter(struct hentry **rh,
    char *name, struct htable *tab, PFI cmp)
{
    int32 hash;
    struct hentry *h;

    hash = hashval(name, tab->tablesize);
    h = tab->table[hash];
    while (h && cmp(h->name, name)) h = h->next;
    if (h == NULL)
    {   h = (struct hentry *) tab->mget(
                (int32)(size_t)(sizeof(struct hentry) + strlen(name)));
        strcpy(h->name, name);
        h->next = tab->table[hash];
        h->h_un.globval = NULL;
        tab->table[hash] = h;
        *rh = h;
        return 1;
    }
    *rh = h;
    return 0;
}

static struct hentry *enter(char *name, struct htable *tab)
{
    struct hentry *h;
    int32 hash;

    hash = hashval( name, tab->tablesize );
    h = (struct hentry *) tab->mget(
        (int32)(size_t)(sizeof(struct hentry) + strlen(name)));
    strcpy(h->name, name);
    h->next = tab->table[hash];
    tab->table[hash] = h;
    return h;
}

static struct hentry *lookup(const char *name, struct htable *tab)
{
    struct hentry *h;

    h = tab->table[ hashval( name, tab->tablesize ) ];
    while (h != NULL && StrNE(h->name, name))
        h = h->next;
    return h;
}

static void closeout(struct oventry *ov)
{
    if (fout.handle != NULL)
    {
        fclose( fout.handle );
#ifdef TARGET_IS_UNIX
        chmod(outf, 0775);
#else
#  ifdef LINKING_ON_RISCOS
        { int ftype = 0xffd;                    /* Data */
          if (output_type == AIF)
          { if (binaryflag == 0 && ov == &root && !moduleflag)
            { if (ddeflag && debugflag)
                  ftype = 0xfd3;                /* Debug */
              else
                  ftype = 0xff8;                /* Absolute */
            }
            else if (intellecflag)
                ftype = 0xfff;                  /* Text */
            else if (moduleflag)
                ftype = 0xffa;                  /* Module */
          }
          settype(outf, ftype);
        }
#  endif
#endif
        if (fatal_count || error_count)
        {   remove( outf );
            fprintf(stderr, msgtext(misc_removeoutput), SELF, outf);
        }
        fout.handle = NULL;
    }
}

static void endlink(int n)
{   struct fentry *fep;

    if (n)
    {   if (n != SIGINT && n!= SIGTERM)
            fprintf(stderr, msgtext(misc_internalerror), SELF);
        else
            fprintf(stderr, msgtext(misc_interrupted), SELF);
        fatal_count++;
    }
    else if (inform_count + warning_count + error_count)
    {   fprintf(stderr, msgtext(misc_finished),
            SELF, inform_count, warning_count, error_count);
    }

    closeout(&root);

    for (fep = clifilelist; fep; fep = fep->next)
        if (fep->fd >= 0) close(fep->fd);

    if (n || (error_count + fatal_count)) exit(1);

    exit(0);
}

static void msg(Message_t errn, ...)
{   char        *errtxt, *msgfmt;
    int         level;
    va_list        ap;

    va_start(ap, errn);
    errtxt = msgtext(errn);
    msgfmt = msgtext(MSG_FORMAT);
    level = *errtxt++ - '0';
    fprintf(stderr, msgfmt, SELF, level_strs[level]);
    vfprintf(stderr, errtxt, ap);
    va_end(ap);
    fputc('\n', stderr);
    errcount[level]++;
    if (level==3) endlink(0);
}

/* Allow for !!<areaname>$$Limit... */
#define AREANAMEXLEN  9

static char *mkname(const char *pre, const char *name, const char *post)
{   static char buf[MAXAREANAMELEN+AREANAMEXLEN+1];
    int ll = 0;
    char *s;

    if (pre != NULL)
    {
        bufcpy(buf, pre, sizeof(buf));
        ll = strlen(buf);
    }
    s = bufcpy(buf + ll, name, sizeof(buf) - ll);
    if (post != NULL)
    {   ll += strlen(s);
        bufcpy(buf + ll, post, sizeof(buf) - ll);
    }
    if (ll >= (MAXAREANAMELEN+AREANAMEXLEN)) msg(fatal_truncated(buf));
    return buf;
}

/*************************************************************************/
/* Memory management functions.                                          */
/*                                                                       */
/* Memory is managed as a heap of allocated blocks which (logically)     */
/* grows upwards and a stack of blocks which (logically) grows downwards.*/
/* Heap blocks are never freed; stack blocks are deallocated en-masse by */
/* discarding everything allocated since a previous mark_stack(). In     */
/* both cases, the areas are managed as a chain of large-ish blocks of   */
/* memory.                                                               */
/*************************************************************************/

static void zmem(char *block, size_t n)
{
    while (n-- > 0) *block++ = 0;
}

struct memblk
{   struct memblk *prev;
    char *limit;
    int32 size;
};

static struct memblk *free_blks = NULL,
    *heap_blks = NULL, *stack_blks = NULL, *cache_blks = NULL;
static char *stack_mark = NULL;

static int32 heap_sz = 0, stack_sz = 0, max_stack_sz = 0, cache_sz = 0;

#define  MEMBLKSZ  0xff00    /* < 65K - sizeof(struct memblk) */


static void free_cache_block(struct memblk *p)
{   struct fentry *fep;
    struct oentry *oep;
    char *buf;
    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   if ((buf = fep->filebuffer) != NULL &&
             buf > (char *)p && buf < ((char *)p + p->size))
        {   fep->filebuffer = NULL;
            if (verboseflag)
                msg(info_uncache(fep->fname));
        }
    }
    for (oep = objectlist;  oep != NULL;  oep = oep->next)
    {   if ((buf = oep->objbuffer) != NULL &&
             buf > (char *)p && buf < ((char *)p + p->size))
        {   oep->objbuffer = NULL;
            if (verboseflag)
                msg(info_uncache(oep->oname));
        }
    }
}

#ifdef LINKING_ON_MAC
#  define malloc(n)  Tracked_malloc(n)
#endif

static struct memblk *get_new_blk(size_t size)
{   struct memblk *p, **pp;
    if (size < MEMBLKSZ) size = MEMBLKSZ;
    size += sizeof(struct memblk);
    for (pp = &free_blks;  (p = *pp) != NULL;  pp = &(p->prev))
        if (p->size >= size)
        {   *pp = p->prev;
            size = (size_t)(p->size);
            break;
        }
    if (p == NULL)
    {   p = (struct memblk *) malloc(size);
        if (p == NULL)
        {   for (pp = &cache_blks;  (p = *pp) != NULL;  pp = &(p->prev))
                /* NB <MUST> use signed compare here as p->size can be -ve */
                if (p->size >= (int32)size)
                {   *pp = p->prev;
                    size = (size_t)(p->size);
                    free_cache_block(p);
                    break;
                }
        }
        if (p == NULL) msg(fatal_outmem);
    }
    p->limit = (char *)p + size;
    p->size = (int32)size;
#ifdef DEBUG_MEM
fprintf(stderr, "getnewblk(%ld) -> %p\n", p->size, p);
#endif
    return p;
}

#define ALLOCABLE(n)  ((int32)(size_t)(n) == (n))  /* may generate no code */

static size_t allocsize(int32 n)
{   n = (n + ALIGN_MASK) & ~ALIGN_MASK;
    if (!ALLOCABLE(n))
    {    msg(fatal_toobig(n));
    }
    return (size_t)n;
}

static char *halloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    for (p = heap_blks;  p != NULL;  p = p->prev)
        if ((p->limit - (char *)p) >= (n + sizeof(struct memblk))) break;
    if (p == NULL)
    {   p = get_new_blk(n);
        zmem((char *)p + sizeof(*p), (size_t)(p->size) - sizeof(*p));
        p->prev = heap_blks;
        heap_blks = p;
    }
    p->limit -= n;
    heap_sz += n;
    return p->limit;
}

static char *cache_alloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    p = cache_blks;
    if (p == NULL || (p->limit - (char *)p) < (n + sizeof(struct memblk)))
    {   size_t size = n;
        if (size < MEMBLKSZ) size = MEMBLKSZ;
        size += sizeof(struct memblk);
        p = (struct memblk *) malloc(size);
#ifdef DEBUG_MEM
fprintf(stderr, "cache_alloc(%d) -> new cache block %p\n", size, p);
#endif
        if (p == NULL) return NULL;
        p->limit = (char *)p + size;
        p->size = (int32)size;
        p->prev = cache_blks;
        cache_blks = p;
    }
    p->limit -= n;
    cache_sz += n;
#ifdef DEBUG_MEM
fprintf(stderr, "cache_alloc(%d) -> %p\n", n, p->limit);
#endif
    return p->limit;
}

#ifdef LINKING_ON_MAC
#  undef malloc
#endif

static char *lock_in_cache(char *a)
{   struct memblk *p;
    if (a == NULL) return NULL;
    for (p = cache_blks;  p != NULL;  p = p->prev)
    {   char *base = (char *)p;
        int32 size = p->size;
        if (size < 0) size = -size;
        if (a >= base && a < base + size)
        {   if (p->size < 0) return NULL;  /* already locked */
            p->size = -size;               /* now locked...  */
            return base;
        }
    }
    return NULL;
}

static void unlock_cache_block(char *base)
{   if (base != NULL)
    {   struct memblk *p = (struct memblk *)base;
        int32 size = p->size;
        if (size < 0) size = -size;
        p->size = size;                    /* unlocked... */
    }
}

static char *salloc(int32 req)
{   struct memblk *p;
    size_t n = allocsize(req);
    p = stack_blks;
    if (p == NULL || (p->limit - (char *)p) < (n + sizeof(struct memblk)))
    {   p = get_new_blk(n);
        p->prev = stack_blks;
        stack_blks = p;
    }
    p->limit -= n;
    stack_sz += n;
    if (stack_sz > max_stack_sz) max_stack_sz = stack_sz;
    return p->limit;
}

static void mark_stack(void)
{   char **mark = (char **) salloc((int32)sizeof(char *));
    *mark = stack_mark;
    stack_mark = (char *)mark;
}

static void pop_stack(void)
{   struct memblk *p, *prev;
    char *sp;
    for (p = stack_blks;  p != NULL;  p = prev)
    {   prev = p->prev;
        if (stack_mark >= p->limit &&
            stack_mark < ((char *)p + p->size))
        {   /* pop and re-zero part of a block */
            sp = p->limit;
            p->limit = stack_mark + sizeof(char *);
            stack_mark = *((char **)stack_mark);
            stack_sz -= (p->limit - sp);
            zmem(sp, (p->limit - sp));
            break;
        }
        /* pop whole block to free list */
        sp = p->limit;
        p->limit = (char *)p + p->size;
        stack_sz -= (p->limit - sp);
        zmem(sp, (p->limit - sp));
        p->prev = free_blks;
        free_blks = p;
    }
    stack_blks = p;
}


#ifdef LINKING_ON_ACORN_RISC_OS
/**********************************************************************
  C++ name demangling code
**********************************************************************/

extern int demangle(char *in, char *out);

static char *cplusplusname(char *s)
{
    static char *sbuf;

    if (!cplusplusflag) return s;
    if (!sbuf) sbuf = halloc(MAXDBUF);
    demangle(s, sbuf);
    return sbuf;
}

#else

#define cplusplusname(s) (s)

#endif



/**********************************************************************
  List management functions
  - these use heap to implement a stack of same-sized objects
  - LIFO (like stack)
  - heap is never freed (uses halloc)
**********************************************************************/

static void listinit( struct listspec *ls, size_t itemsize )
{
  ls->topblock = NULL;
  ls->itemsize = itemsize;
  ls->maxoffset = itemsize * ( LISTBUFSIZE / itemsize );
}

static void listpush( struct listspec *ls, char *item )
{
  struct listblock *newblock;

  if( ls->topblock == NULL || ls->offset == ls->maxoffset )
  {
    newblock = (struct listblock *)halloc( sizeof( struct listblock ) );
    newblock->prev = ls->topblock;

    ls->offset = 0;
    ls->topblock = newblock;
  }
  memcpy( &ls->topblock->buf[ ls->offset ], item, ls->itemsize );
  ls->offset += ls->itemsize;
}

static char *listpop( struct listspec *ls )
{
  if( ls->topblock != NULL )
  {
    if( ls->offset == 0 )
    {
      /* get previous block */
      ls->topblock = ls->topblock->prev;
      ls->offset = ls->maxoffset;
    }

    /* check ls->topblock again because there may be no previous block */
    if( ls->topblock != NULL )
    {
      ls->offset -= ls->itemsize;
      return( &ls->topblock->buf[ ls->offset ] );
    }
  }
  return( NULL );
}

static char *readfile(char *buff, int32 posn, int32 n)
{
    HOURGLASS();
#ifdef DEBUG
    printf( "readfile posn=%ld\n", posn );
#endif
    if (posn == curfile->posn || lseek(curfile->fd, posn, L_SET) != -1)
    {   if ((size_t)read(curfile->fd, buff, n) == n)
        {   curfile->posn = posn + n;
            return buff;
        }
    }
    msg(fatal_readerr(curfile->fname));
    /*NOTREACHED*/
    return "";
}

static void closefile(struct fentry *filelist)
{   struct fentry *fep;

    for (fep = filelist; fep; fep = fep->next)
        if (fep->fd >= 0)
        {   if (close(fep->fd)) msg(fatal_readerr(fep->fname));
            openfiles--;
            fep->fd = -1;
            break;
        }
}

static void setfile(struct fentry *fep)
{
    sectoffset = 0;
    sectsize = fep->size;
    curfile = fep;
    if ((sectinram = fep->filebuffer) == NULL)
        if (fep->fd < 0)
        {   if (openfiles >= maxopenfiles)
                closefile(clifilelist);
            if ((fep->fd = open(fep->fname, BINARY_OPEN_MODE)) < 0)
                msg(fatal_openerr(fep->fname));
            fep->posn = 0;
            openfiles++;
        }
}

static void setfilesection(struct fentry *fep, int32 offset, int32 size)
{   setfile(fep);
    sectoffset = offset;
    sectsize = size;
    if (sectinram) sectinram += offset;
}

static void setobject(struct oentry *oep)
{
    if ((sectinram = oep->objbuffer) != NULL)
    {   sectoffset = oep->offset;
        sectsize = oep->size;
        curfile = oep->fep;
    }
    else
        setfilesection(oep->fep, oep->offset, oep->size);
}

static char *map_perm(int32 posn, int32 n)
{   if (posn < 0 || (posn + n) > (sectoffset + sectsize))
        msg(fatal_badobj(curfile->fname));
    if (sectinram) return sectinram + posn;
    return readfile(halloc(n), sectoffset + posn, n);
}

static char *map(int32 posn, int32 n)
{
    if (posn < 0 || (posn + n) > (sectoffset + sectsize))
        msg(fatal_badobj(curfile->fname));
    if (sectinram) return sectinram + posn;
    return readfile(salloc(n), sectoffset + posn, n);
}

static char *map_tvtv(int32 posn, int32 n)
{
    return map(hv(posn), hv(n));
}

static void writedirect(char *buf, int32 n)
{
#ifdef DEBUG
    printf( "writedirect: n=%ld\n", n );
#endif
    if (fwrite(buf, 1, (size_t)n, fout.handle) != n)
        msg(fatal_writeerr(outf));
}

static unsigned intellec_base = 0;

static void intellec_write( char *buff, int32 n )
{
    char outrec[ 80+1 ];
    unsigned j, recsz;
    unsigned addr, ch, chksum, rev;
    char *s;

    /* Intellec format demands most-significant byte first... */
    /* Therefore, we reverse the order only if not reversing! */
    if (is_little_endian()) rev = 6; else rev = 0;

    addr = intellec_base;                   /* a WORD address */
    if (n & 3L)
    {   msg(fatal_byteslost((n & 3L), addr + (n /4)));
        n &= ~3L;
    }

    for (;  n > 0;  n -= 32)
    {   if (n < 32L) recsz = (unsigned)n/4; else recsz = 8;
        sprintf(outrec, ":%.2X %.4X 00 ", recsz, addr);
        s = outrec + 12;
        chksum = recsz + ((addr >> 8) & 255) + (addr & 255);
        addr += recsz;
        for (j = 0;  j < recsz * 8;  j += 2)
        {   ch = (unsigned char)(*buff++);
            chksum += ch;
            s[(j ^ rev) + 0] = "0123456789ABCDEF"[ch >> 4];
            s[(j ^ rev) + 1] = "0123456789ABCDEF"[ch & 15];
        }
        chksum = (-chksum) & 255;
        sprintf(s+j, " %.2X\n", chksum);

        fputs( outrec, fout.handle );
    }
    intellec_base = addr;
}

static void writebytes( int32 posn, char *buff, int32 n )
{
    HOURGLASS(); /* in options.h */
#ifdef DEBUG
    printf( "writebytes posn=%ld, n=%ld\n", posn, n );
#endif

    if (intellecflag)
    {
#ifdef DEBUG
        if( posn != fout.currentpos )
        {
            puts( "Warning: non-sequential intellec_write()" );
        }
#endif
        /* intellec writes are always sequential */
        intellec_write( buff, n );
    }
    else
    {
        if( posn != fout.currentpos )
        {
#ifdef DEBUG
            puts( "Seeking.." );
#endif
            fseek( fout.handle, posn, SEEK_SET );
        }

        writedirect( buff, n );
    }
    /* currentpos contains byte offset within BINARY file */
    /* the file position in an intellec file will differ */
    /* AN INTELLEC FILE MUST BE WRITTEN SEQUENTIALLY */
    fout.currentpos = posn + n;
}

/* Write an individual aif reloc entry to file */
/* RMJ: Remember to twiddle the data! */

static void writeaifrelocdirect( int32 reloc )
{
  int32 d;

#ifdef DEBUG
puts( "writeaifrelocdirect" );
#endif

  d = tv(reloc);
  writebytes( relocposn, (char *)&d, sizeof( int32 ) );
  relocposn += sizeof( int32 );
}

/* Writes a reloc list (of any type) to file (in LIFO order) */
/* updates global relocposn */

static void writereloclist( struct listspec *ls )
{ char *nextitem;

  while( ( nextitem = listpop( ls ) ) != NULL )
  {
    writebytes( relocposn, nextitem, ls->itemsize );
    relocposn += ls->itemsize;
popped++;
  }
}

#ifdef TARGET_HAS_AOUT
static time_t libtime;

static void write_aout_header(struct oventry *ov)
{
    struct exec_header hdr;
    zmem((char *) &hdr, sizeof(struct exec_header));
    if (plinkflag) {
        hdr.a_exec.a_magic = OMAGIC;
        hdr.a_exec.a_text = ov->textsize;
        hdr.a_exec.a_data = ov->datasize;
        hdr.a_exec.a_bss = ov->bsssize;
        if (entryflag)
            hdr.a_exec.a_entry = entrypoint - base;
        else
            hdr.a_exec.a_entry = entryarea->base + entryoffset - base;
        hdr.a_exec.a_syms = symcount * sizeof(struct nlist);
        relocposn = ov->textsize + ov->datasize + sizeof(struct exec);
    } else {
        if (entryflag)
            hdr.a_exec.a_entry = entrypoint;
        else if (entryarea)
            hdr.a_exec.a_entry = entryarea->base + entryoffset;
        hdr.a_exec.a_syms = symcount * sizeof(struct nlist);
        hdr.a_timestamp = time(0);
        if (nmagicflag) {
            hdr.a_exec.a_magic = IMAGIC;
            hdr.a_exec.a_text = ov->textsize + ov->datasize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_data = 0;
            hdr.a_exec.a_bss = ov->bsssize -
                        (hdr.a_exec.a_text - (ov->textsize + ov->datasize));
            if ((hdr.a_exec.a_text -
                            (ov->textsize + ov->datasize)) > ov->bsssize)
                hdr.a_exec.a_bss = 0;
        } else {
            hdr.a_exec.a_magic = ZMAGIC;
            hdr.a_exec.a_text = ov->textsize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_data = ov->datasize +
                                (int32)((pagesize - 1) & ~(pagesize - 1));
            hdr.a_exec.a_bss = ov->bsssize -
                                (hdr.a_exec.a_data - ov->datasize);
            if ((hdr.a_exec.a_data - ov->datasize) > ov->bsssize)
                hdr.a_exec.a_bss = 0;
            }
        }
        if (sharedlib) {
            hdr.a_exec.a_magic |= MF_USES_SL;
            hdr.a_shlibtime = libtime;
            strcpy(hdr.a_shlibname, sharedlib);
    }
    sposn = N_SYMOFF(hdr.a_exec);
    strposn = (sposn + hdr.a_exec.a_syms);
    if (plinkflag)
        writebytes(0, (char *) &hdr, sizeof(struct exec));
    else
        writebytes(0, (char *) &hdr, sizeof(struct exec_header));
    areaoutposn = fout.currentpos;
}

static void fix_up_aout_globals(void)
{
    sposn += reloc_count * sizeof(struct relocation_info);
    strposn += reloc_count * sizeof(struct relocation_info);
}

static void fix_up_aout_header(void)
{
    int32 t[2];
    t[0] = textrelocs * sizeof(struct relocation_info);
    t[1] = datarelocs * sizeof(struct relocation_info);
    writebytes(6 * sizeof(int32), (char *) t, 2 * sizeof(long));
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static void ensure_byte_order(unsigned32 *p, int32 n)
{   /* Ensure that the code pointed to by p has the right byte sex. */
    /* The size is given in BYTEs; the code MUST begin with NOP.    */
    if (p[0] != tv(AIF_NOOP))
    {   n /= sizeof(unsigned32);
        while (n > 0) {*p = tv(*p);  ++p;  --n;}
    }
}


static void write_aif_header(struct oventry *ov)
{
    int32 dbgtype, ep, sz;
    if (moduleflag)
        relocposn = srcposn + amf_reloc_code_size;
    else if (binaryflag != BIN_NOHDR && ov == &root)
    {   ensure_byte_order((unsigned32 *)aif_header, sizeof(struct aif_hdr));
        sz = ov->textsize;
        if (!binaryflag) sz += sizeof(struct aif_hdr);
        aif_header->rosize = tv(sz);
        sz += ov->datasize;
        aif_header->rwsize = tv(ov->datasize);
        aif_header->dbgsize = 0;
        if (debugflag)
        {   aif_header->dbgsize =
                tv(ov->dbgsize + sizeof(ItemSection) +
                   symcount * sizeof(ItemSymbol) + strtsize);
            /* IDJ: don't insert dbg SWI instruction AQU-00245 */
#if 0
            if (ddeflag) aif_header->debug_swi = tv(DEBUG_TASK);
#endif
            dbgtype = 0;
            if (symcount > 0)  dbgtype =  AIF_DBG_LL;
            if (has_dbg_areas) dbgtype |= AIF_DBG_SRC;
            aif_header->dbgtype = tv(dbgtype);
        }
        aif_header->zinitsize = tv(ov->bsssize);
        aif_header->workspace = tv(workspace);
        aif_header->imagebase = tv(base);
        /* set the AIF header's address mode... */
        if (code_attrs_set & code_attrs_unset & AOF_32bitAT)
            ep = 0L;
        else if (code_attrs_set & AOF_32bitAT)
            ep = 32L;
        else
            ep = 26L;
        if (rw_baseflag)
        {   ep |= AIF_DATABASAT;
            aif_header->data_base = tv(data_base);
        }
        aif_header->address_mode = tv(ep);

        if (ov->bsssize || debugflag)
            aif_header->zinit_br = tv(AIF_BLZINIT);

        if (scatterflag == OVERLAY)
        {   int32 aif_base = base +
                ((char *)&(aif_header->zinit_br) - (char *)(aif_header));
            aif_header->zinit_br =
                tv(AIF_BLAL | (overlay_init->h_un.globval->symval.value -
                           (aif_base + 8L)) >> 2);
        }

        if (entryarea == NULL && entryflag == 0)
            msg(fatal_noentry);
        else
        {   if (entryflag == 1)
            {   if (entryarea != NULL)
                {   ep = entryarea->base + entryoffset;
                    if (ep != entrypoint)
                        msg(err_entryconflict(entryarea->name));
                }
                else
                    ep = entrypoint;
            }
            else
                ep = entryarea->base + entryoffset;
            ep -= base;
            if (ep < (int32) sizeof(struct aif_hdr) && !binaryflag ||
                ep < 0L || ep > sz)
            {   int32 hdrsz = binaryflag ? 0L : (int32) sizeof(struct aif_hdr);
                if (entryflag == 1)
                    msg(err_badentry1(ep+base, hdrsz+base, sz+base));
                else
                    msg(err_badentry2(ep, hdrsz, sz));
                ep = hdrsz;
            }
            if (binaryflag)
                aif_header->entry_br = tv(ep);
            else
                aif_header->entry_br = tv(AIF_BLAL | (ep - 0x14) >> 2);
        }
        outsiz = hv(aif_header->dbgsize) +
                 ov->textsize + ov->datasize + (int32)sizeof(struct aif_hdr);
        sposn = sizeof(struct aif_hdr) + ov->textsize + ov->datasize +
                 ov->dbgsize + sizeof(ItemSection);
        strposn = (sposn + symcount * sizeof(ItemSymbol));
        srcposn = outsiz;
        if (relocflag)
        {   aif_header->reloc_br = tv(AIF_BLAL|(srcposn-(sizeof(long)+8)) >> 2);
        }
        else
        {   /* allocate buffers for block by block  output instead...   */
        }
        relocposn = srcposn + aif_reloc_code_size;
        writebytes(0, (char *) aif_header, sizeof(struct aif_hdr));
    }
    areaoutposn = fout.currentpos;
}

static int32 addchunk(cf_header *hdr, char *c_name, int32 offset, int32 size)
{   cf_entry *cfe;
    int32 numchunks = hv(hdr->cf_numchunks);

    size = (size + 3L) & ~3L;
    cfe = hdr->cf_chunks + numchunks;
    strncpy(cfe->cfe_key, c_name, sizeof(cfe->cfe_key));
    cfe->cfe_offset = tv(offset);
    cfe->cfe_size = tv(size);
    hdr->cf_numchunks = tv(numchunks+1);
    return offset + size;
}

static void addoutarea(aof_header *hdr, int32 i, int32 attrs,
    int32 size, int32 relocs, int32 strsize, int32 base)
{   aof_area *aofarea = &(hdr->aof_areas[i]);
    aofarea->area_name = tv(strtsize);
    aofarea->area_attributes = tv(attrs);
    aofarea->area_size = tv(size);
    aofarea->area_nrelocs = tv(relocs);
    aofarea->area_base = tv(base);
    strtsize += strsize;
}

static cf_entry *findchunk(cf_header *cfhdr, char *key)
{
    struct cf_entry *entry, *hdrend;

    for (entry = cfhdr->cf_chunks, hdrend = entry + hv(cfhdr->cf_maxchunks);
         entry < hdrend;
         entry++)
        if (entry->cfe_offset != 0 &&
            strncmp(entry->cfe_key, key, CF_KEYSIZE) == 0)
            return entry;
    return NULL;
}

static void write_aof_header(struct oventry *ov)
{
    size_t nareas;
    int32 chunkoffset, i, saved_strtsize;
    struct aentry *aep;

    if (ov == &root)
    {   nareas = (size_t) (ov->noofoutareas);
        if (!plinkflag)
        {   nareas = 0;
            if (ov->textsize)        /* Image$$RO */
                nareas++;
            if (ov->datasize)        /* Image$$RW */
                nareas++;
            if (debugflag)           /* Image$$RWO */
                nareas++;
            if (ov->bsssize)         /* Image$$ZI */
                nareas++;
        }
        chunkoffset = cfhdrsize =
            sizeof(cf_header) + (MAXCHUNKS-1) * sizeof(cf_entry);
        cfouthdr = (cf_header *) salloc(cfhdrsize);
        aofhdrsize = sizeof(aof_header) + (nareas - 1)*sizeof(aof_area);
        aofhdr = (aof_header *) salloc(aofhdrsize);
        cfouthdr->cf_magic = tv(CF_MAGIC);
        cfouthdr->cf_maxchunks = tv(MAXCHUNKS);
        cfouthdr->cf_numchunks = 0;
        zmem((char *) (cfouthdr->cf_chunks), MAXCHUNKS*sizeof(cf_entry));
        aofhdr->aof_type = tv(AOF_RELOC);
#ifdef FIX_ME_LATER
        if (!plinkflag) aofhdr->aof_type = tv(AOF_IMAGE1);
#endif
        aofhdr->aof_vsn = tv(AOF_VERSION);
        aofhdr->aof_nareas = tv((int32)nareas);
        aofhdr->aof_nsyms = tv(symcount);
        saved_strtsize = strtsize - 4;
        strtsize = 4;                        /* AREA names come first... */
        if (!plinkflag)
        {   int32 areano;
            areano = 0;
            aofhdr->aof_entryarea = 0;
            aofhdr->aof_entryoffset = 0;
            if (ov->textsize)
            {   addoutarea(aofhdr, areano++, AOF_ABSAT+AOF_RONLYAT+AOF_CODEAT,
                    ov->textsize, 0, sizeof("Image$$RO"), base);
                if (entryarea)
                {   aofhdr->aof_entryarea = tv(1);
                    aofhdr->aof_entryoffset = tv(entryarea->base - base);
                }
            }
            if (ov->datasize)
                addoutarea(aofhdr, areano++, AOF_ABSAT,
                        ov->datasize, 0, sizeof("Image$$RW"),
                        (base + ov->textsize));
            if (ov->bsssize)
                addoutarea(aofhdr, areano++, AOF_ABSAT + AOF_0INITAT,
                        ov->bsssize, 0, sizeof("Image$$ZI"),
                        (base + ov->textsize + ov->datasize));
            if (debugflag && !intellecflag)
                addoutarea(aofhdr, areano++, AOF_ABSAT + AOF_DEBUGAT,
                        ov->dbgsize, 0, sizeof("Image$$RW0"),
                        (base + ov->textsize + ov->datasize));
        }
        else /* (plinkflag) */
        {   aofhdr->aof_entryarea = 0;
            aofhdr->aof_entryoffset = 0;
            for (i = 0; i < ov->noofoutareas; i++)
            {   aep = ov->outareas[i];
                if (aep == outentryarea)
                {   aofhdr->aof_entryarea = tv(i + 1);
                    aofhdr->aof_entryoffset = tv(outentryofs);
                }
                addoutarea(aofhdr, i, aep->attrs,
                    aep->areasiz, aep->relocs,
                    (int32)(size_t)(strlen(aep->h->name)+1), aep->base);
            }
        }
        strtsize = (strtsize + saved_strtsize + 3L) & ~3L;
        chunkoffset = addchunk(cfouthdr, OBJ_HEAD, chunkoffset, aofhdrsize);
        chunkoffset = addchunk(cfouthdr, OBJ_IDFN, chunkoffset,
                          (sizeof(SELF) + sizeof(IDFNSTR)-2) +1);
        chunkoffset = addchunk(cfouthdr, OBJ_AREA, chunkoffset,
                          (ov->textsize + ov->datasize + ov->dbgsize));
        sposn = chunkoffset;
        if (debugflag || plinkflag)
        {   chunkoffset = addchunk(cfouthdr, OBJ_SYMT, chunkoffset,
                                       symcount * sizeof(aof_symbol));
            strposn = chunkoffset;
            chunkoffset = addchunk(cfouthdr, OBJ_STRT, chunkoffset, strtsize);
        }
        if (shl_flag == 2)
        {   shlposn = chunkoffset;
            shl_chunk = hv(cfouthdr->cf_numchunks);
            chunkoffset = addchunk(cfouthdr, SHL_LIBY, chunkoffset, 0L);
        }
        writebytes(0, (char *) cfouthdr, cfhdrsize);
        writebytes(cfhdrsize, (char *) aofhdr, aofhdrsize);
        writebytes(fout.currentpos, SELF, sizeof(SELF) -1);
        writebytes(fout.currentpos, IDFNSTR, sizeof(IDFNSTR) -1);

        /* IDJ: 14-Oct-94: bug fix for AQU-00046, AQU-00044, AQU-00062 */
        /* previously the following line produced faulty AOF file if the
         * length of the link version string was an exact multiple of 4!
         */
        writebytes(fout.currentpos,
                "\0\0\0", 4L - ((sizeof(SELF)+sizeof(IDFNSTR)-2) &3L));
    }
    areaoutposn = fout.currentpos;
    relocposn = areaoutposn + ov->outareas[0]->areasiz;
}

static void fix_up_aof_globals(void)
{   int32 relsize, i;
    cf_entry *cfe;
    struct oventry *ov = &root;

    relsize = reloc_count * sizeof(aof_reloc);
    sposn += relsize;
    strposn += relsize;
    for (i = 0; i < ov->noofoutareas; i++)
        aofhdr->aof_areas[i].area_nrelocs = tv(ov->outareas[i]->relocs);
    cfe = cfouthdr->cf_chunks;
    target_increment(&(cfe[2].cfe_size),   relsize);
    i = hv(cfouthdr->cf_numchunks);
    while (i > 3)
    {   --i;
        target_increment(&(cfe[i].cfe_offset), relsize);
    }
}

static void fix_up_aof_header(void)
{   writebytes(0, (char *) cfouthdr, cfhdrsize);
    writebytes(cfhdrsize, (char *) aofhdr, aofhdrsize);
}

#endif /* TARGET_HAS_AOF */

static void write_header(struct oventry *ov)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        write_aout_header(ov);
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AIF)
        write_aif_header(ov);
    else
      if (output_type == AOF)
        write_aof_header(ov);
    else
#endif
        msg(fatal_optype(output_type));
    lastoutarea = ov->outareas[0];
}

static void fix_up_globals(void)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        fix_up_aout_globals();
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AOF)
        fix_up_aof_globals();
    else
#endif
        msg(fatal_optype(output_type));
}

static void fix_up_header(void)
{
#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT)
        fix_up_aout_header();
    else
#endif
#ifdef TARGET_HAS_AOF
      if (output_type == AOF)
        fix_up_aof_header();
    else
#endif
        msg(fatal_optype(output_type));
}

/* The print names of attributes are potential candidates for translation */
/* into languages other than English. However, for now we don't do this.  */
/* It seems adequate to concentrate on translating messages themselves.   */

static void sprintattrs(char *buf, size_t buflen, int32 attrs)
{   static struct attribute {
        int32 field;
        char *name;
    }
    attrtab[] = {
        {AOF_ALMASK,    "area-alignment"},
        {AOF_ABSAT,     "ABS"      },
        {AOF_CODEAT,    "CODE"     },
        {AOF_COMDEFAT,  "COMDEF"   },
        {AOF_COMREFAT,  "COMREF"   },
        {AOF_0INITAT,   "0INIT"    },
        {AOF_RONLYAT,   "READONLY" },
        {AOF_PICAT,     "PIC"      },
        {AOF_DEBUGAT,   "DEBUG"    },
        {AOF_32bitAT,   "32bit"    },
        {AOF_REENTAT,   "REENTRANT"},
        {AOF_FP3AT,     "FPIS3",   },
        {AOF_NOSWSTKCK, "NO_SW_STACK_CHECK"},
        {AOF_BASEDAT,   "BASED",   },
        {AOF_SHLDATA,   "SHL-data",},
        {AOF_BASEMASK,  "base-register" }
    };

    struct attribute *p;
    char *spacer = "";
    size_t len;

    for (p = attrtab; p < (attrtab + sizeof(attrtab)/sizeof(attrtab[0])); ++p)
    {   if ((attrs & p->field) == 0) continue;
        len = strlen(p->name) + strlen(spacer);
        if (len >= buflen) continue;
        buflen -= len;
        sprintf(buf, "%s%s", spacer, p->name);
        buf += len;
        spacer = ", ";
    }
}

static void linksymbl(char *name, int32 b, int32 l);

static struct aentry *addarea(char *name, struct oentry *oep, int32 areaoff,
    int32 areasiz, int32 relocoff, int32 relocs, int32 attrs, int32 areano)
{
    struct aentry *a;

    if ((attrs & AOF_DEBUGAT) &&
        (output_type == AIF && binaryflag == BIN_NOHDR || output_type == AOUT))
        return NULL;

#ifdef __acorn
    /* we don't want auto -inclusion of debug areas, so we return prematurely
       IDJ: 20-nov-94
     */
    if ((attrs & AOF_DEBUGAT) && (output_type == AIF) && !debugflag)
    {
        has_dbg_areas = 1;  /* do this so we can warn about removal of dbg areas later */
        return NULL;
    }
#endif

    if (attrs & AOF_DEBUGAT) has_dbg_areas = 1;

/* Areas with COMMON or SHLDATA attributes have to be merged by name. The */
/* constraints on attributes are that SHLDATA and (COMDEF, COMREF) are    */
/* mutually exclusive. Otherwise, SHLDATA,DATA is treated like COMDEF and */
/* SHLDATA,0INIT is treated like COMREF. There may be many COMREFs and 0  */
/* or more COMDEFs. Where there are multiple COMREFs (or SHLDATA,0INITs), */
/* the area size is the maximum of the input area sizes; if there is a    */
/* COMDEF then it must have the maximum area size. If there are multiple  */
/* COMDEFs, they must all have the same size, number of relocations and   */
/* area contents.                                                         */

    if (attrs & (AOF_COMREFAT|AOF_COMDEFAT|AOF_SHLDATA))
    {   struct hentry *h;
        char buf[MAXSYMLEN];

        /* COMDEF and COMREF set is allowable and means COMDEF */
        if (attrs & AOF_COMDEFAT) attrs &= ~AOF_COMREFAT;

        /* COMDEF, 0INIT is allowable and means COMREF, 0INIT */
        if ((attrs & (AOF_COMDEFAT|AOF_0INITAT)) == (AOF_COMDEFAT|AOF_0INITAT))
            attrs = (attrs & ~AOF_COMDEFAT) | AOF_COMREFAT;

        /* COMREF means COMREF, 0INIT... */
        if (attrs & AOF_COMREFAT) attrs |= AOF_0INITAT;

        if ((attrs & AOF_SHLDATA) && (attrs & (AOF_COMREFAT|AOF_COMDEFAT)))
        {   msg(warn_diffattr0(name, oep->oname));
            attrs &= ~(AOF_COMREFAT|AOF_COMDEFAT);
        }

        if (lookenter(&h, name, &commontable, strcmp))
        {   /* Area hasn't been seen before, so create a new instance...  */
            /* which will be initialised below...                         */
            a = h->h_un.areaval = (struct aentry *)
                halloc((int32)(size_t)(sizeof(struct aentry)+strlen(name)));
            if (!(attrs & AOF_0INITAT))
                a->areaval = map_perm(areaoff, areasiz);
            goto new_area;
        }
        a = h->h_un.areaval;

        /* An area with this name has been seen before so check its       */
        /* attribute and and size compatibility.                          */

        if (((attrs ^ a->attrs) & AOF_SHLDATA) ||
            (attrs & AOF_SHLDATA) && ((attrs ^ a->attrs) & AOF_0INITAT))
        {   /* only one of the areas has the SHLDATA attribute, or both   */
            /* have and only one has the 0-initialised attribute...       */
            msg(warn_diffattr3(name, a->oep->oname, oep->oname));
            sprintattrs(buf, sizeof(buf),
                (a->attrs ^ attrs) & (AOF_SHLDATA|AOF_0INITAT));
            msg(info_diffattrs(buf));
            goto recover;
        }

        if (attrs & AOF_COMREFAT)
        {   /* any COMDEF must be as big as the biggest COMREF...         */
            if (areasiz > a->areasiz)
            {   if (a->attrs & AOF_COMDEFAT)
                    msg(warn_com_toobig(name, oep->oname, a->oep->oname));
                else
                    a->areasiz = areasiz;
            }
            return a;
        }

        if (attrs & AOF_SHLDATA)
        {   /* SHLDATA is a special kind of common data which can only be */
            /* commoned with SHLDATA of the same sort. Initialised data   */
            /* must be identical; 0INIT data accumulate the max length.   */
            if (attrs & AOF_0INITAT)
            {   if (areasiz > a->areasiz) a->areasiz = areasiz;
            }
            else if (areasiz != a->areasiz ||
                     relocs  != a->relocs  ||
                (int32)(size_t)areasiz != areasiz ||    /* 16-bit defence */
                    memcmp(a->areaval,
                        map(areaoff,areasiz), (size_t)areasiz) != 0)
            {
                msg(warn_diffarea(name, a->oep->oname, oep->oname));
                goto recover;
            }
            return a;
        }

        if (attrs & AOF_COMDEFAT)
        {   if (a->attrs & AOF_COMDEFAT)
            {   if (areasiz != a->areasiz ||
                    relocs  != a->relocs  ||
                (int32)(size_t)areasiz != areasiz ||    /* 16-bit defence */
                    memcmp(a->areaval,
                         map(areaoff,areasiz), (size_t)areasiz) != 0)
                {
                    msg(warn_diffarea(name, a->oep->oname, oep->oname));
                    goto recover;
                }
            }
            else
            {   /* the defining COMDEF corresponding to a previous COMREF */
                if (a->areasiz > areasiz)
                    msg(warn_com_toobig(name, oep->oname, a->oep->oname));
                a->areaoff = areaoff;
                a->areasiz = areasiz;
                a->areapad = 0;
                a->relocoff = relocoff;
                a->relocs = relocs;
                a->oep = oep;
                a->areano = areano;
                a->attrs = attrs;
            }
            return a;
        }
        /* Assert: This point is unreachable... die horribly if reached.  */
        endlink(-1);
    }
    /* Not a COMMON/SHLDATA area so create a new area instance...     */
    /* ...which will be initialised below...                          */
recover:
    a = (struct aentry *)
        halloc((int32)(size_t)(sizeof(struct aentry)+strlen(name)));
    a->areaval = NULL;
new_area:
    a->areaidx = ++area_index;
    a->areaoff = areaoff;
    a->areasiz = areasiz;
    a->areapad = 0;
    a->base = 0;
    a->relocoff = relocoff;
    a->relocs = relocs;
    a->attrs = attrs;
    a->oep = oep;
    a->areano = areano;
    a->flags = 0;
    a->refs = NULL;
    a->overseg = NULL;
    strcpy(a->name, name);
    *nextobjarea = a;
    a->h = NULL;
    a->nxt = NULL;
#ifdef LINKING_ON_ACORN_RISC_OS
    a->area__link_list = 0;
#endif
    nextobjarea = &(a->nxt);
    /* Create a placeholder for the $$Base and $$Limit symbols so that */
    /* unused AREA elimination can work properly... later filled in by */
    /* map_areas...                                                    */
    if (!plinkflag) linksymbl(name, 0, areasiz);
    return a;
}

#ifdef SARMAG
#  define MAGICSZ SARMAG
#else
#  define MAGICSZ 8
#endif

static int32 filetype(struct fentry *fep)
{
    setfile(fep);
    if (fep->size >= MAGICSZ)   /* Make sure small files don't fool us */
    {   fep->f_un.hdrptr = map_perm(0, MAGICSZ);
#ifdef TARGET_HAS_AOF
        if (is_cf_magic(fep->f_un.cfhdr->cf_magic))
        {        /* read rest of chunk file header */
            fep->f_un.hdrptr = map_perm(0,
                hv(fep->f_un.cfhdr->cf_maxchunks)*sizeof(cf_entry) +
                    sizeof(cf_header) - sizeof(cf_entry));

            if (findchunk(fep->f_un.cfhdr, OBJ_HEAD)) return AOF;
            if (findchunk(fep->f_un.cfhdr, LIB_DIRY)) return OFL;
        }
        else if (is_reversed_cf_magic(fep->f_un.cfhdr->cf_magic))
            msg(fatal_byteorder(fep->fname));
#endif
#ifdef TARGET_HAS_AOUT
        if (strncmp(fep->f_un.armag, ARMAG, MAGICSZ) == 0)
        {   fep->f_un.hdrptr = map_perm(0, MAGICSZ+sizeof(struct ar_hdr));
            return AR;
        }
        if (!N_BADMAG(*(fep->f_un.aouthdr)))
        {   if (fep->f_un.aouthdr->a_magic == OMAGIC)
                fep->f_un.hdrptr = map_perm(0, sizeof(struct exec));
            else
                fep->f_un.hdrptr = map_perm(0, sizeof(struct exec_header));
            return AOUT;
        }
#endif
    }
    msg(fatal_notobj(fep->fname));
    /*NOTREACHED*/
    return 0;
}

#undef MAGICSZ

static struct sym *makesym(int32 value, unsigned32 flags, struct aentry *area)
{   static struct sym tsym;
    zmem((char *)&tsym, sizeof(tsym));
    tsym.value = value;
    tsym.flags = flags;
    tsym.area = area;
    return &tsym;
}

static struct hentry *globinsert(const char *name, struct sym *sy, char *id)
{   char symname[MAXSYMLEN];
    struct hentry *nh;
    int is_new;
    struct sym *nh_sym;

    symname[0] = id[0];
    symname[1] = id[1];
    bufcpy(symname+2, name, sizeof(symname)-2);

    is_new = lookenter(&nh, symname, &globhashtable,
                       (sy->flags & SYM_NOCASEAT) ? cistrcmp : casefn);
    if (!is_new)
    {   nh_sym = &nh->h_un.globval->symval;
        /* Allow duplicate identical definitions... */
        if ((sy->flags & SYM_DEFAT)     &&
            sy->flags == (nh_sym->flags & ~SYM_LINKFLAGS) &&
            sy->area  == nh_sym->area   &&
            sy->value == nh_sym->value)
#ifdef LINKING_ON_ACORN_RISC_OS
                goto check_for_ctors;
#else
                return nh;
#endif
    }

    /* Force local definitions (guaranteed non-identical) to be entered, */
    /* even if a definition with the same name has been seen before.    */

    if ((sy->flags & SYM_REFDEFMASK) == SYM_LOCALDEFAT &&
        (nh = enter(symname, &globhashtable)) != NULL  || is_new)
    {
        (nh->h_un.globval = (struct globsym *)
                           halloc(sizeof(struct globsym)))->symval = *sy;
        if ((sy->flags & (SYM_REFDEFMASK+SYM_WEAKAT)) == SYM_REFAT)
            /* newly entered non-weak symbol reference */
            nh->h_un.globval->symval.flags |= SYM_SCANLIB;
        nh->h_un.globval->pcit_entry = -1;
        *nextglobsym = nh;
        nextglobsym = &(nh->h_un.globval->next);
    }
    else if (sy->flags & SYM_DEFAT)
    {   nh_sym = &nh->h_un.globval->symval;
        if (nh_sym->flags & SYM_DEFAT && !(sy->flags & SYM_LINKSYM))
        {   if (duplicateflag)
                msg(warn_glob_muldef(name, sy->refobj->oname,
                    nh_sym->refobj->oname));
            else
                msg(err_glob_muldef(name, sy->refobj->oname,
                    nh_sym->refobj->oname));
        }
        else
            *nh_sym = *sy;
    }
    else if ((sy->flags & SYM_WEAKAT) == 0 &&
                  /* re-entry of non-weak symbol reference */
             (nh->h_un.globval->symval.flags & SYM_WEAKAT))
    {             /* to existing weak reference... */
            nh->h_un.globval->symval.flags =
                (nh->h_un.globval->symval.flags & ~SYM_WEAKAT) | SYM_SCANLIB;
    }

#ifdef LINKING_ON_ACORN_RISC_OS
check_for_ctors:
    if (sy->flags & SYM_DEFAT) {
        if (!(sy->flags & SYM_REFAT)) {
            if (strcmp(name, "__link") == 0) {
                struct aentry *aep;
                struct __link_list *__link;

                if (!cplusplusflag) {
                    if (!warned_cpp) {
                        /*/* warn here */
                        warned_cpp = 1;
                    }
                    return nh;
                }
                aep = sy->area;
                /*aep->included = 1;*/
                __link = (struct __link_list *)halloc(sizeof(struct __link_list));
                __link->next = g__link_list;
                g__link_list = __link;
                __link->chain = aep->area__link_list;
                aep->area__link_list = __link;
                __link->sy = &nh->h_un.globval->symval;
            }
        } else {
            if (strcmp(name, "__head") == 0) {
                if (!cplusplusflag) {
                    if (!warned_cpp) {
                        /*/* warn here */
                        warned_cpp = 1;
                    }
                    return nh;
                }
                g__head_sym = &nh->h_un.globval->symval;
            }
        }
    }
#endif

    return nh;
}

#ifdef TARGET_HAS_AOUT

static int32 map_aoutsymt(struct exec *aouthdr, int32 *toff, int32 *doff, int32     *boff, struct nlist **symt, char **strt)
{
    int32 offt;
    *toff = 0;
    *doff = aouthdr->a_text;
    *boff = *doff + aouthdr->a_data;
    offt = N_SYMOFF(*aouthdr);
    *symt = (struct nlist *) map(offt, aouthdr->a_syms + sizeof(int32));
    *strt = map(offt + aouthdr->a_syms + sizeof(int32), *((int32 *)
        (((char *) *symt) + aouthdr->a_syms)) - sizeof(int32)) - sizeof(int32);
    return (aouthdr->a_syms / sizeof(struct nlist));
}

#endif /* TARGET_HAS_AOUT */

static void load1_aout(struct oentry *oep)
{
#ifdef TARGET_HAS_AOUT
    char *strt, *cp, at;
    int32 nsyms, offt;
    struct hentry **symno, **syend;
    struct aentry *aep;
    struct exec *aouthdr;
    struct nlist *symt;
    struct globsym *gs;
    int32 toff, doff, boff, nv;

    if (debugflag && output_type == AOUT) {
        symcount++;
        strtsize += (int32)(strlen(oep->oname) + 1); /* AOUT Only */
    }
    aouthdr = oep->o_un.aouthdr;
    nsyms = map_aoutsymt(aouthdr, &toff, &doff, &boff, &symt, &strt);
    oep->arealist = (struct aentry **) halloc(3 * sizeof(struct aentry *));
    offt = N_TXTOFF(*aouthdr);
    oep->arealist[CODE_AREA] = addarea("Aout$$Code", oep, offt,
            aouthdr->a_text, offt + aouthdr->a_text + aouthdr->a_data,
            aouthdr->a_trsize / sizeof(struct relocation_info),
            AOF_CODEAT + AOF_RONLYAT, CODE_AREA);
    offt += aouthdr->a_text;
    oep->arealist[DATA_AREA] = addarea("Aout$$Data", oep, offt,
            aouthdr->a_data, offt + aouthdr->a_data + aouthdr->a_trsize,
            aouthdr->a_drsize / sizeof(struct relocation_info), 0, DATA_AREA);
    oep->arealist[BSS_AREA] = addarea("Aout$$Bss", oep, 0, aouthdr->a_bss,
            0,0, AOF_0INITAT, BSS_AREA);
    if (aouthdr->a_magic & MF_IS_SL) {
        int32 i;

        if (sharedlib) msg(err_mulsharedlibs);

        for (i = CODE_AREA; i <= BSS_AREA; i++)
            oep->arealist[i]->flags |= SHFLAG;
        sharedlib = ((struct exec_header *) (aouthdr))->a_shlibname;
        libtime = ((struct exec_header *) (aouthdr))->a_shlibtime;
    }
    if (entryarea != NULL) {
        entryarea = oep->arealist[CODE_AREA];
        entryoffset = aouthdr->a_entry;
    }
    oep->numtosym = (struct hentry **)
                                    halloc(nsyms * sizeof(struct hentry *));
    for (symno = oep->numtosym, syend = symno+nsyms; symno<syend;
                                                    symt++, symno++) {
        cp = strt + symt->n_un.n_strx;
        if (!(symt->n_type & N_EXT)) {
            if (debugflag && output_type == AOUT &&
                                            (cp == strt || *cp != 'L')) {
                symcount++;
                if (cp > strt)
                    strtsize += (int32)(strlen(cp) + 1); /* AOUT Only */
            }
            *symno=NULL;            /* Throw away debug symbol */
            continue;
        }
        nv = symt->n_value;
        cp = "";
        if (symt->n_un.n_strx)            /* 0 string idx => null string */
            cp = strt + symt->n_un.n_strx;
        aep = NULL;
        if (aouthdr->a_magic & MF_IS_SL) {
            if ((symt->n_type & N_TYPE) == N_UNDF)
                msg(err_extref(cp));
            at = SYM_ABSAT | SYM_GLOBALDEFAT;
        }
        else {
            at = SYM_REFAT;
            switch ((symt->n_type & N_TYPE) >> 1) {
            case N_UNDF >> 1:
                if (nv) {
                    aep = common;
                    /* at = SYM_COMMON; */
                }
                break;
            case N_ABS >> 1:
                at = SYM_ABSAT + SYM_GLOBALDEFAT;
                break;
            case N_TEXT >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[CODE_AREA];
                break;
            case N_DATA >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[DATA_AREA];
                nv -= doff;  /* Make sym rel to data area */
                break;
            case N_BSS >> 1:
                at = SYM_GLOBALDEFAT;
                aep = oep->arealist[BSS_AREA];
                nv -= boff;  /* Make sym rel to bss area */
                break;
            }
        }
        {
            struct sym tsym;
            zmem((char *)&tsym, sizeof(tsym));
            tsym.value = nv;
            tsym.flags = at;
            tsym.dbxinfo = symt->n_desc;
            tsym.area = aep;
            tsym.refobj = oep;
            gs = (*symno=globinsert(cp, &tsym, "!!"))->h_un.globval;
        }
        if (!(gs->symval.flags & SYM_DEFAT))
            if (symt->n_value > gs->symval.value) {
                gs->symval.value = symt->n_value;
                gs->symval.area = common;
            }
    }
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOUT */
}

static size_t next_power_of_2(int32 n, size_t n0)
{   if ((int32)(size_t)n != n) msg(fatal_tabtoobig(n));
    while (n0 < n) n0 *= 2;
    return n0;
}

static void load1_aof(struct oentry *oep)
{
#ifdef TARGET_HAS_AOF
    char *strt, *id;
    int32 nsyms, offt, i, nareas, asize;
    unsigned32 attributes;
    struct hentry **symno, **syend;
    struct aentry *ai;
    cf_entry *ce;
    aof_header *hdr;
    aof_area *area;
    aof_symbol *symt = 0;
    struct htable areatable;

    ce = findchunk(oep->o_un.cfhdr, OBJ_HEAD); /* Read in header */
    hdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    nsyms = hv(hdr->aof_nsyms);

    if (nsyms > 0)
    {   /* Read in symbol table */
        ce = findchunk(oep->o_un.cfhdr, OBJ_SYMT);
        symt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    }
    ce = findchunk(oep->o_un.cfhdr, OBJ_STRT); /* Read in string table */
    strt = map_tvtv(ce->cfe_offset, ce->cfe_size);
    offt = hv(findchunk(oep->o_un.cfhdr, OBJ_AREA)->cfe_offset);
    oep->arealist = (struct aentry **)
            halloc(hv(hdr->aof_nareas) * sizeof(struct aentry *));
    nareas = hv(hdr->aof_nareas);

    mark_stack();
    hashinit(&areatable, next_power_of_2(nareas, OBJAREATABLESIZE), salloc);

    for (i = 0, area = hdr->aof_areas;  i < nareas;  ++i, ++area)
    {   asize = hv(area->area_size);
        attributes = hv(area->area_attributes);
        id  = strt + hv(area->area_name);
        oep->arealist[i] = ai = addarea(id, oep,
                offt, asize, offt + asize, hv(area->area_nrelocs),
                attributes, i);
        if (!(attributes & AOF_0INITAT))
            offt += asize + hv(area->area_nrelocs) * sizeof(aof_reloc);
        if (ai == NULL) continue;
        ai->base = hv(area->area_base);        /* in case of AOF_ABSAT */
        if (attributes & AOF_ABSAT && !baseflag)
        {   base = ai->base;
            baseflag = 1;
        }
        if (hv(hdr->aof_vsn) < 300) ai->flags |= NOINSTRELOC;
        enter(id, &areatable)->h_un.areaval = ai;
    }
    if (hdr->aof_entryarea != 0)
    {   struct hentry* h;
        if (entryarea != NULL) msg(err_mulentries);
        i = hv(hdr->aof_entryarea) - 1;
        h = lookup(strt + hv(hdr->aof_areas[i].area_name), &areatable);
        entryarea = h ? h->h_un.areaval : NULL;
        entryoffset = hv(hdr->aof_entryoffset);
    }
    oep->numtosym = (struct hentry **) halloc(nsyms*sizeof(struct hentry *));
    for (symno = oep->numtosym, syend = symno+nsyms; symno < syend; symt++)
    {   struct sym tsym;
        struct hentry* h;

        zmem((char *)&tsym, sizeof(tsym));
        tsym.flags = attributes = hv(symt->sym_AT);
        tsym.refobj = oep;
        tsym.value = hv(symt->sym_value);
        if ((attributes & (SYM_ABSAT + SYM_DEFAT)) == SYM_DEFAT)
        {   h = lookup(strt + hv(symt->sym_areaname), &areatable);
            tsym.area = h ? h->h_un.areaval : NULL;
        }
        if ((attributes & SYM_REFDEFMASK) == SYM_LOCALDEFAT)
            id = oep->objectid;
        else
            id = "!!";                       /* magic id for globals */
        *symno++ = globinsert(strt + hv(symt->sym_name), &tsym, id);
    }
    pop_stack();
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOF */
}


static void load1(struct oentry *oep)
{   char *lock;
    if (oep->objbuffer != NULL)
        /* cached object from uncached library */
        lock = lock_in_cache(oep->objbuffer);
    else
        /* cached object file... */
        lock = lock_in_cache(oep->fep->filebuffer);
    mark_stack();
    if (oep->fep->type & AOUT_MASK)
        load1_aout(oep);
    else
        load1_aof(oep);
    *nextglobsym = NULL;
    pop_stack();
    unlock_cache_block(lock);
}


static int special_aof(struct oentry *oep)
{
    int rc = 0;
#ifdef TARGET_HAS_AOF
    char *strt, *id;
    int32 nsyms, offt, i, nareas, asize;
    unsigned32 attributes;
    cf_entry *ce;
    aof_header *hdr;
    aof_area *area;
    aof_symbol *symt = 0;

    ce = findchunk(oep->o_un.cfhdr, OBJ_HEAD); /* Read in header */
    hdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    nsyms = hv(hdr->aof_nsyms);
    if (nsyms > 0)
    {   /* Read in symbol table */
        ce = findchunk(oep->o_un.cfhdr, OBJ_SYMT);
        symt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    }
    ce = findchunk(oep->o_un.cfhdr, OBJ_STRT); /* Read in string table */
    strt = map_tvtv(ce->cfe_offset, ce->cfe_size);
    offt = hv(findchunk(oep->o_un.cfhdr, OBJ_AREA)->cfe_offset);
    nareas = hv(hdr->aof_nareas);
    for (i = 0, area = hdr->aof_areas;  i < nareas;  ++i, ++area)
    {   asize = hv(area->area_size);
        attributes = hv(area->area_attributes);
        id = strt + hv(area->area_name);
        if (attributes & (AOF_CODEAT+AOF_RONLYAT) != (AOF_CODEAT+AOF_RONLYAT))
            continue;
        if (strcmp(id, "AIF_HDR") == 0 &&
            asize == (int32) sizeof(struct aif_hdr))
        {   aif_header = (struct aif_hdr *) map_perm(offt, asize);
            ++rc;
        }
        else if (strcmp(id, "AIF_RELOC") == 0)
        {   aif_reloc_code = (unsigned32 *) map_perm(offt, asize);
            aif_reloc_code_size = (int) asize;
            ++rc;
        }
        else if (strcmp(id, "AMF_RELOC") == 0)
        {   amf_reloc_code = (unsigned32 *) map_perm(offt, asize);
            amf_reloc_code_size = (int) asize;
            private_amf_reloc = 1;
            ++rc;
        }
        if (!(attributes & AOF_0INITAT))
            offt += asize + hv(area->area_nrelocs) * sizeof(aof_reloc);
    }
    if (rc > 0 && rc != (int)nareas)
        msg(err_badspecial(oep->fep->fname));
#else
    UNUSED(oep)
#endif /* TARGET_HAS_AOF */
    return rc;
}

static int32 attr_index(int32 attr)
{
/*
 * AREA sorting order:
 * 1 RO code
 * 2 RO based data
 * 3 RO data
 * 4 RW code
 * 5 Based data
 * 6 Data
 * 7 0init data
 * 8 Debug
 */
    if (attr & AOF_0INITAT)
        return 7L;
    else if (attr & AOF_DEBUGAT)
        return 8L;
    else
    {   int32 idx = 1;
        if ((attr & AOF_RONLYAT) == 0) idx += 3;
        if ((attr & AOF_CODEAT) == 0)
        {   if ((attr & AOF_BASEDAT) == 0) idx += 1;
            idx += 1;
        }
        return idx;
    }
}

static int32 areagtr(struct aentry *cs, struct aentry *ct)
{
    int32 csa, cta;
/*
 * AREA sorting (return 1 if cs should come after ct):
 *   RO code
 *   RO based data
 *   RO data
 *   RW code
 *   Based data
 *   Data
 *   0init data
 *   Debug
 * Areas unordered by attribute are ordered first by AREA name, then by
 * position in the input link list.
 */
    if ((ct->flags & AREA_LAST) || (cs->flags & AREA_FIRST)) return 0;
    if ((cs->flags & AREA_LAST) || (ct->flags & AREA_FIRST)) return 1;

    csa = attr_index(cs->attrs);
    cta = attr_index(ct->attrs);

    if (csa > cta) return 1;

    if (csa == cta)
    /* AREAs are unordered by attribute... */
    {   if (cs->oep && ct->oep)
        {   if (cs->oep->fep->type & AOUT_MASK)
            {   /* first area is a.out... */
                if (!(ct->oep->fep->type & AOUT_MASK))
                {   /* 2nd area isn't a.out... so order by output type */
                    if (output_type & AOUT_MASK) return 0;
                    return 1;
                }
            }
            else if (ct->oep->fep->type & AOUT_MASK)
            {   /* 1st area isn't a.out and 2nd area is - order by o/p type */
                if (output_type & AOUT_MASK) return 1;
                return 0;
            }
        }
        if (cs->h->name == ct->h->name)
        {   /* AREAs unorderd by name, so order them by input position */
            if (cs->areaidx > ct->areaidx) return 1;
        }
        else if (strcmp(cs->h->name, ct->h->name) > 0)
            return 1;
    }
    return 0;
}

/* See Sedgewick: Algorithms 2nd edition P 108 */

static void sortareas(struct aentry **a, int32 n)
{
    int32 h, i, j;
    struct aentry *v;

    a--;        /* Make array 1 origin */
    h = 1;
    do {h = h * 3 + 1;} while (h <= n);
    do
    {   h = h / 3;
        for (i = h + 1; i <= n; i++)
        {   v = a[i];
            j = i;
            while (j > h && areagtr(a[j-h], v))
            {   a[j] = a[j-h];
                j = j-h;
            }
            a[j] = v;
        }
    }
    while (h > 1);
}

static void linksym_0(const char *name, int32 val)
{   struct sym sy;
    struct hentry *h;
    struct globsym *gs;

    h = lookup(name, &globhashtable);

    if ((h == NULL) && intellecflag) return;

    if ((h != NULL) && ((gs = h->h_un.globval)->symval.flags & SYM_LINKSYM))
        gs->symval.value = val;
    else
    {   zmem((char *)&sy, sizeof(sy));
        sy.value = val;
        sy.area  = NULL;
        sy.flags = (SYM_ABSAT + SYM_GLOBALDEFAT + SYM_LINKSYM);
        (void) globinsert(name+2, &sy, "!!");
    }
}

static void linksym(char *name, int32 val)
{   linksym_0(mkname("!!", name, NULL), val);
}

static void oldsym(char *name, char *newname, int32 val)
{   if (lookup(name, &globhashtable))
    {   msg(warn_deprecated(name + 2, newname));
        linksym_0(name, val);
    }
}

static void linksymbl(char *name, int32 b, int32 l)
{   linksym_0(mkname("!!", name, "$$Base"),  b);
    linksym_0(mkname("!!", name, "$$Limit"), l);
}

static void hash_area(struct oventry *ov, struct aentry *aep, char *name)
{   struct hentry *h;
    int32 aep_attrs, h_attrs;
    char buf[MAXSYMLEN];

    aep_attrs = aep->attrs;
    if (aep_attrs & AOF_CODEAT)
    {   code_attrs_set |=
            (aep_attrs  & (AOF_32bitAT+AOF_REENTAT+AOF_NOSWSTKCK));
        code_attrs_unset |=
            (~aep_attrs & (AOF_32bitAT+AOF_REENTAT+AOF_NOSWSTKCK));
        h_attrs = (code_attrs_set & code_attrs_unset) & ~code_attrs_warned;
        if (h_attrs != 0L)
        {   msg(warn_diffattr1(aep->name, aep->oep->oname));
            sprintattrs(buf, sizeof(buf), h_attrs);
            msg(info_diffattrs(buf));
            code_attrs_warned |= h_attrs;
        }
        else if ((aep_attrs & AOF_FP3AT) && (match_opts & WARN_FP3))
            msg(warn_fp3(aep->name, aep->oep->oname));
    }
tryagain:
    if (lookenter(&h, name, &(ov->areatable), strcmp))
    {   h->h_un.areaval = (struct aentry *)
            halloc((int32)sizeof(struct aentry) + strlen(name));
        h->h_un.areaval->areaidx = ++area_index;
        h->h_un.areaval->attrs = aep_attrs;
        h->h_un.areaval->areaoff = 0;
        h->h_un.areaval->areasiz = 0;
        h->h_un.areaval->relocs = 0;
        h->h_un.areaval->base = -1;
        h->h_un.areaval->h = h;
        h->h_un.areaval->nxt = NULL;
        h->h_un.areaval->oep = NULL;
        strcpy(h->h_un.areaval->name, name);
        ov->noofoutareas++;
        *nextoutarea = h->h_un.areaval;
        nextoutarea = &(h->h_un.areaval->nxt);
    }
    else if (aep_attrs != (h_attrs = h->h_un.areaval->attrs))
    {   h->h_un.areaval->attrs |= (aep_attrs & AOF_FP3AT);
        h_attrs = (h_attrs & ~AOF_FP3AT) | (aep_attrs & AOF_FP3AT);
        if (aep_attrs != h_attrs && (h->h_un.areaval->flags & COMPLAINED) == 0)
        {   msg(warn_diffattr2(aep->name, aep->oep->oname));
            sprintattrs(buf, sizeof(buf), h_attrs ^ aep_attrs);
            msg(info_diffattrs(buf));
            h->h_un.areaval->flags |= COMPLAINED;
        }
        /* now check for essential differences that would affect ordering */
        if (aep_attrs & (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT))
            aep_attrs &= (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_BASEMASK);
        else
            aep_attrs &= (AOF_CODEAT+AOF_RONLYAT);
        if (h_attrs & (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT))
            h_attrs &= (AOF_0INITAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_BASEMASK);
        else
            h_attrs &= (AOF_CODEAT+AOF_RONLYAT);
        if (aep_attrs != h_attrs)
        {   int len;
            sprintf(buf, "%lx", aep_attrs);
            len = strlen(buf);
            name = bufcpy(buf+len, name, sizeof(buf)-len);
            goto tryagain;
        }
    }
    aep->h = h;
}

static void init_overseg(struct oventry *ov, char *file, char *overseg)
{
    ov->nextarea = &(ov->areas);
    ov->noofareas = 0;
    ov->areas = NULL;
    ov->next = NULL;
    ov->level_list = NULL;
    ov->noofoutareas = 0;
    ov->outarealist = NULL;
    ov->entryv = 0;
    ov->base = -1L;    /* temp, while parsing tree */
    hashinit(&(ov->areatable), AREATABLESIZE, halloc);
    if (scatterflag)
    {   ov->name = halloc((int32)(size_t)(strlen(file)+strlen(overseg)+2));
        strcat(strcat(strcpy(ov->name, file), PATHSEP), overseg);
    }
    else
    {   ov->name = halloc((int32)(size_t)(strlen(file) + 1));
        strcpy(ov->name, file);
    }
}

static struct oventry *add_segment(char *seg_name)
{
    struct oventry *ov, **po;
    struct lventry *lv, **pl;
    int l, sl;

    overlay_segments++;
    sl = l = 0;
    while (seg_name[l] != 0 && seg_name[l] != '_') ++l;

    pl = &(root.level_list);
    for (lv = root.level_list;  lv != NULL;  lv = lv->next)
    {   char *s = lv->seg_list->name;
        s += strlen(s);
        while (s != lv->seg_list->name && *s != PATHSEP[0]) --s;
#if 0
        if (strncmp(s+1, seg_name, l) == 0) break;
#else
        if (strncmp(s+1, seg_name, l) == 0)
        {
            sl = s + 1 - lv->seg_list->name;
            break;
        }
#endif
        pl = &(lv->next);
    }

    if (lv == NULL)
    {   lv = *pl = (struct lventry *) halloc(sizeof(struct lventry));
        lv->next = NULL;
        lv->clash = -1;    /* Doesn't clash with itself */
        lv->seg_list = NULL;
    }

    po = &(lv->seg_list);
    for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
    {
#if 0
        if (strlen(ov->name) > l && strcmp(ov->name+l, seg_name+l) == 0) break;
#else
        if (strlen(ov->name) > sl && strcmp(ov->name+sl, seg_name) == 0) break;
#endif
        po = &(ov->next);
    }

    if (ov == NULL)
    {   ov = *po = (struct oventry *) halloc(sizeof(struct oventry));
        init_overseg(ov, outfile, seg_name);
        ov->level = lv;
        lv->clash++;
    }
    return ov;
}

static void add_segment_object(struct oventry *ov, char *obj_name)
{
    int32 gotone;
    struct aentry *aep;

    gotone = 0;
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if (aep->oep != NULL && CiStrEQ(aep->oep->oname, obj_name) &&
            (aep->attrs & AOF_CODEAT))
        {   gotone = 1;
            aep->overseg = ov;
        }
    }
    if (!gotone) msg(err_ovobj(obj_name));
}

static void add_segment_object_area(struct oventry *ov,
    char *obj_name, char *area_name)
{
    int32 gotone;
    struct aentry *aep;

    aep = objarealist;
    gotone = 0;
    while (aep)
    {   if (aep->oep != NULL && CiStrEQ(aep->oep->oname, obj_name) &&
                                StrEQ(aep->name, area_name))
        {   gotone = 1;
            aep->overseg = ov;
        }
        aep = aep->nxt;
    }
    if (!gotone) msg(err_ovarea(obj_name, area_name));
}

#define BEFORE_SEGMENT_NAME     0
#define IN_SEGMENT_NAME         1
#define AFTER_SEGMENT_NAME      2
#define IN_SEGMENT_ADDRESS      3
#define BEFORE_OBJECT_NAME      4
#define IN_OBJECT_NAME          5
#define BEFORE_1ST_AREA_NAME    6
#define BEFORE_AREA_NAME        7
#define IN_AREA_NAME            8

static void build_overlay_tree(void)
{   FILE *iop;
    int incomment, c, eof, line, state, buflen;
    char name_buff[MAXNAMELEN], area_name_buff[MAXAREANAMELEN], *name = NULL;
    struct oventry *this_seg = NULL;

    if ((iop = fopen(scatterfile, "r")) == 0) msg(fatal_openerr(scatterfile));

    line = 1;
    incomment = 0;
    state = BEFORE_SEGMENT_NAME;
    buflen = eof = 0;
    do
    {   c = getc(iop);
        if (c == EOF) {c = '\n';  eof = 1;}
        if (c == '\n') line++;
        if (incomment)                  /* Skip comment after ';' */
        {   if (c != '\n') continue;    /* newline passed through */
            incomment = 0;
        }
        if (c == ';')                   /* Comment start */
        {   incomment = 1;
            continue;
        }
        if (c == '\\')                  /* Possible Line continuation */
        {   c = getc(iop);
            if (c != '\n') msg(fatal_badcont(scatterfile, line));
            c = ' ';                   /* Treat nl as space if continuing */
        }

        if (isspace(c) && state != IN_AREA_NAME ||
              c == '(' && state == IN_SEGMENT_NAME)
        {   if (state == IN_SEGMENT_NAME)
            {   *name = '\0';
                if ((name - name_buff) > OVERSEGNAMELEN)
                {   msg(warn_oversegname(name_buff, OVERSEGNAMELEN));
                    name_buff[OVERSEGNAMELEN] = 0;
                }
                this_seg = add_segment(name_buff);
                if (c == '(')
                {   name = area_name_buff;
                    buflen = MAXAREANAMELEN;
                    state = IN_SEGMENT_ADDRESS;
                    if (scatterflag == OVERLAY)
                        msg(fatal_misbra(scatterfile, line));
                }
                else
                {   state = BEFORE_OBJECT_NAME;
                    if (scatterflag == SCATTERIMAGE)
                        msg(fatal_missegbase(scatterfile, line, name_buff));
                }
            }
            else if (state == IN_OBJECT_NAME)
            {   *name = '\0';
                if (buflen <= 0) msg(fatal_truncated(name_buff));
                add_segment_object(this_seg, name_buff);
                state = BEFORE_OBJECT_NAME;
            }

            if (c == '\n')
            {   if (state == BEFORE_AREA_NAME)
                    msg(fatal_badnl(scatterfile, line));
                state = BEFORE_SEGMENT_NAME;
            }
            continue;
        }

        if (c == '(')
        {   if (state == IN_OBJECT_NAME)
            {   *name = '\0';
                if (buflen <= 0) msg(fatal_truncated(name_buff));
                state = BEFORE_1ST_AREA_NAME;
                continue;
            }
            msg(fatal_misbra(scatterfile, line));
        }

        if (c == ')' || c == ',' || isspace(c))
        {   if (state == IN_AREA_NAME)
            {   *name = 0;
                if (buflen <= 0) msg(fatal_truncated(area_name_buff));
                add_segment_object_area(this_seg, name_buff, area_name_buff);
                state = BEFORE_OBJECT_NAME;
                if (c == ',') state = BEFORE_AREA_NAME;
                continue;
            }
            else if (state == IN_SEGMENT_ADDRESS)
            {   *name = 0;
                state = BEFORE_OBJECT_NAME;
                continue;
            }
            msg(fatal_misterm(scatterfile, line));
        }

        if (iscntrl(c)) msg(fatal_badchar(scatterfile, line, c));

        if (state == BEFORE_SEGMENT_NAME)
        {   name = name_buff;
            state = IN_SEGMENT_NAME;
            buflen = MAXNAMELEN;
        }
        else if (state == BEFORE_OBJECT_NAME)
        {   name = name_buff;
            state = IN_OBJECT_NAME;
            buflen = MAXNAMELEN;
        }
        else if (state == BEFORE_1ST_AREA_NAME || state == BEFORE_AREA_NAME)
        {   name = area_name_buff;
            state = IN_AREA_NAME;
            buflen = MAXAREANAMELEN;
        }

        if (--buflen > 0) *name++ = c;
    }
    while (!eof);
    if (ferror(iop)) msg(fatal_readerr(scatterfile));
    fclose(iop);
}

static unsigned32 imm_to_val(unsigned32 imm)
{   unsigned32 ror;
    imm &= 0xfff;
    ror = (imm >> 8) << 1;
    imm &= 255;
    if (ror != 0) imm = (imm >> ror) | (imm << (32-ror));
    return imm;
}

static unsigned32 val_to_imm(unsigned32 val)
{   unsigned32 mask = 0xc0000000;
    int j = 24;
    /* return the most significant part of val as an immediate */
    while (j > 0 && (mask & val) == 0)
    {   j -= 2;
        mask >>= 2;
    }
    return ((32L - j) << 7) & 0xf00 | ((val >> j) & 255L);
}

static char *paramBlk = NULL;
static size_t paramBlkSz = 64, paramBlkUsed = 0;

static void addParamVal(char *s, size_t l)
{   size_t len = (l + 3) & ~3;
    if (paramBlk == NULL || (paramBlkUsed + len) > paramBlkSz)
    {   char *p;
        while (paramBlkSz < (paramBlkUsed + len)) paramBlkSz *= 2;
        p = halloc((int32)paramBlkSz);
        if (paramBlk != NULL) memcpy(p, paramBlk, paramBlkUsed);
        paramBlk = p;
    }
    s = (char *) memcpy(paramBlk+paramBlkUsed, s, l);
    while (l < len) s[l++] = 0;
    paramBlkUsed += len;
}

#define ADD_IP_R9      0xe289c000
#define ADD_IP_PC      0xe28fc000
#define ADD_IP_IP      0xe28cc000
#define LDMIA_IP_IPPC  0xe89c9000
#define STMFD_SP_REGS  0xe92d407f
#define LDR_R0_END     0xe51f0010
#define BAL            0xea000000

#define SIMPLE_CODE_STRIDE     16
#define REENTRANT_CODE_STRIDE  12

static int32 inter_LU_code_stride = 0;
static int32 *inter_LU_data_map = NULL;

static void make_inter_LU_data_map(void)
{   struct hentry *h;
    struct globsym *gs;
    int32 *map, j, t, n, offset;
/* Called to make a map of the inter_LU_data area of a reentrant stub */

    n = eft_size;
    inter_LU_data_map = map = (int32 *) halloc(n*sizeof(int32));

    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if ((gs->symval.flags & SYM_EFTSYM) && ((t = gs->pcit_entry) >= 0))
        {   map[t] = (gs->symval.flags & SYM_FNVSYM) ? 16 : 8;
        }
    }
    offset = 0;
    for (j = 0;  j < n;  ++j) offset += map[j];
    t = (n + eft_extra)*8;
    if (offset != t) msg(fatal_eftmap(n, t));
}

static void make_reentrant_inter_LU_object(void)
{   struct oentry *oep;
    struct fentry *fep;
    struct aentry *aep;
    unsigned32 codesz, coderelsz, datasz, datarelsz;
    unsigned32 *w, n, j, imm, offset;
    aof_reloc *r;

    inter_LU_code_stride = REENTRANT_CODE_STRIDE;
    n = eft_size;
    codesz = n * REENTRANT_CODE_STRIDE;
    coderelsz = n * sizeof(aof_reloc);
    datasz = (n + eft_extra)*8 + 16 + paramBlkUsed;
    datarelsz = (n+2) * sizeof(aof_reloc);
    if (libdataflag)
    {   datarelsz += sizeof(aof_reloc);
        datasz += 8;
    }

    {   char *anon = msgtext(misc_anon);
        fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
        strcpy(fep->fname, anon);
        fep->size = codesz + coderelsz + datasz + datarelsz;
        w = (unsigned32 *) (fep->filebuffer = halloc(fep->size));
    }
    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = (struct aentry **) halloc(sizeof(struct aentry *) * 2L);

    /* fake the veneer code area: read-only code */
    inter_LU_code = aep = addarea(interLUcodeName, oep,
        0, codesz, codesz, coderelsz/sizeof(aof_reloc),
        (AOF_CODEAT+AOF_RONLYAT+AOF_REENTAT)+2, 0L);
    oep->arealist[0] = aep;
    codesz += coderelsz;

    /* and fake the entry veneer data, RONLY, BASED r9 */
    inter_LU_data = aep = addarea(interLUdataName, oep,
        codesz, datasz, codesz+datasz, datarelsz/sizeof(aof_reloc),
        AOF_RONLYAT+AOF_BASEDAT+(9<<AOF_BASESHIFT)+2, 1L);
    oep->arealist[1] = aep;

    oep->numtosym = (struct hentry **) halloc(3L*sizeof(struct hentry *));
    oep->numtosym[0] = dyn_link;
    oep->numtosym[1] = sb_limit;    /* later optimised out */
    oep->numtosym[2] = stub_0base;  /* only used if libdataflag != 0 */

    make_inter_LU_data_map();

    /* initialise the code... */
    offset = 0;
    for (j = 0;  j < n;  ++j)
    {   imm = val_to_imm(offset);
        *w++ = tv(ADD_IP_R9 + imm);
        *w++ = tv(ADD_IP_IP + val_to_imm(offset - imm_to_val(imm)));
        *w++ = tv(LDMIA_IP_IPPC);
        offset += inter_LU_data_map[j];
    }
    /* ...and the code relocations */
    r = (aof_reloc *) w;
    for (j = 0;  j < n;  ++j)
    {   r->rel_offset = tv(j * REENTRANT_CODE_STRIDE);
        r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_B) + 1L);
        ++r;
    }

    /* ... now the data and data relocations... */
    w = (unsigned32 *)r;
    r = (aof_reloc *)((char *)w + datasz);
    datasz = (n + eft_extra)*8;
    offset = 0;
    for (j = 0;  j < n;  ++j)
    {   if (inter_LU_data_map[j] == 16)
        {   /* address-taken fn veneer */
            *w++ = tv(ADD_IP_PC);        /* inter-LU fn-call veneer */
            *w++ = tv(LDMIA_IP_IPPC);
            offset += 8;
        }
        *w++ = tv(j);
        *w++ = tv(datasz);
        r->rel_offset = tv(offset + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG) + 1L);
        ++r;
        offset += 8;
    }
    /* construct a PC-relative B __rt_dynlink */
    *w++ = tv(STMFD_SP_REGS);
    *w++ = tv(LDR_R0_END);
    *w++ = tv(BAL + ((unsigned32)(-4L - (datasz >> 2)) & 0x00ffffff));
    *w++ = 0;
    if (libdataflag)
    {   *w++ = tv(shl_datasz->h_un.globval->symval.value);
        *w++ = 0;
    }
    for (j = 0;  j < (int32)paramBlkUsed/sizeof(int32);  ++j)
        *w++ = ((int32 *)paramBlk)[j];
    r->rel_offset = tv(datasz + 8);
    r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_R+REL_A) + 0L);
    ++r;
    /* this relocation is later optimised out by AOF outputting */
    r->rel_offset = tv(datasz + 12);
    r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 1L);
    if (libdataflag)
    {   ++r;
        r->rel_offset = tv(datasz + 16 + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 2L);
    }
}

static void make_simple_inter_LU_object(void)
{   struct oentry *oep;
    struct fentry *fep;
    struct aentry *aep;
    unsigned32 datasz, datarelsz;
    unsigned32 *w, n, j;
    aof_reloc *r;

    inter_LU_code_stride = SIMPLE_CODE_STRIDE;
    n = eft_size;
    datasz = n * SIMPLE_CODE_STRIDE + 16 + paramBlkUsed;
    datarelsz = (n+2) * sizeof(aof_reloc);
    if (libdataflag)
    {   datarelsz += sizeof(aof_reloc);
        datasz += 8;
    }

    {   char *anon = msgtext(misc_anon);
        fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
        strcpy(fep->fname, anon);
        fep->size = datasz + datarelsz;
        w = (unsigned32 *) (fep->filebuffer = halloc(fep->size));
    }
    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = (struct aentry **) halloc(sizeof(struct aentry *) * 1L);

    /* and fake the entry veneer data, RONLY, BASED r9 */
    inter_LU_code = inter_LU_data = aep = addarea(interLUdataName, oep,
        0, datasz, datasz, datarelsz/sizeof(aof_reloc),
        AOF_RONLYAT+AOF_BASEDAT+(9<<AOF_BASESHIFT)+2, 0);
    oep->arealist[0] = aep;

    oep->numtosym = (struct hentry **) halloc(3L*sizeof(struct hentry *));
    oep->numtosym[0] = dyn_link;
    oep->numtosym[1] = sb_limit;    /* later optimised out */
    oep->numtosym[2] = stub_0base;  /* only used if libdataflag != 0 */

    /* Initialise the stub data... */
    for (j = 0;  j < n;  ++j)
    {   *w++ = tv(ADD_IP_PC);            /* inter-LU fn-call veneer */
        *w++ = tv(LDMIA_IP_IPPC);
        *w++ = tv(j);
        *w++ = tv(n * SIMPLE_CODE_STRIDE);
    }
    /* construct a PC-relative B __rt_dynlink */
    *w++ = tv(STMFD_SP_REGS);
    *w++ = tv(LDR_R0_END);
    *w++ = tv(BAL + ((unsigned32)(-4L - n*4 ) & 0x00ffffff));
    *w++ = 0;
    if (libdataflag)
    {   *w++ = tv(shl_datasz->h_un.globval->symval.value);
        *w++ = 0;
    }
    for (j = 0;  j < (int32)paramBlkUsed/sizeof(int32);  ++j)
        *w++ = ((int32 *)paramBlk)[j];
    /* ...and the data relocations */
    r = (aof_reloc *) w;
    for (j = 0;  j < n;  ++j)
    {   r->rel_offset = tv(j * SIMPLE_CODE_STRIDE + 12);
        r->rel_flags = tv((REL_TYPE2+REL_LONG) + 0L);
        ++r;
    }
    r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 8);
    r->rel_flags = tv((REL_TYPE2+REL_INSTR+REL_R+REL_A) + 0L);
    ++r;
    /* this relocation is later optimised out by AOF outputting */
    r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 12);
    r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 1L);
    if (libdataflag)
    {   ++r;
        r->rel_offset = tv(n * SIMPLE_CODE_STRIDE + 16 + 4);
        r->rel_flags = tv((REL_TYPE2+REL_LONG+REL_A) + 2L);
    }
}

static void int32param(int32 val)
{   int32 v = tv(val);
    addParamVal((char *)&v, sizeof(int32));
}

static char *stringparam(char *s)
{   char *e = ++s;
    char *t = e;
    int ch = *e;
    for (;;)
    {   if (ch == 0) return e;
        if (ch == '\\' && (e[1] == '"' || e[1] == '\\'))
            ch = e[1];
        else if (ch == '"')
            ch = 0;
        *t++ = ch;
        if (ch == 0) break;
        ch = *(++e);
    }
    addParamVal(s, (t - s));
    return e+1;
}

static char *object_id(char *oname)
{   struct oentry *oep;
    if (*oname == 0) return "!!";
    for (oep = objectlist;  oep != NULL; oep = oep->next)
    {   if (CiStrEQ(oep->oname, oname)) return oep->objectid;
    }
    return NULL;
}

static char *getline(FILE *iop, char *file, int lineno)
{   static char linebuff[MAXLINESIZE];
    int c, n = MAXLINESIZE - 3;
    char *lp = linebuff+2;          /* allow access to lp[-1], lp[-2] */

    while ((c = getc(iop)) != EOF && c != '\n')
        if (n > 0) {*lp++ = c;  --n;}
    if (n == 0) msg(err_truncated(file, lineno));
    *lp = '\0';
    if (lp == (linebuff+2) && feof(iop)) return NULL;
    return linebuff+2;
}

static void eft_entry_name(char *name)
{   /* Assert: name[-1] and name[-2] exist and name[] is writable.      */
    /* For directly-exported names, the format is just <name>.          */
    /* For names exported via a function reference, the format is       */
    /* <name>(<module>). <module> must be omitted if a global symbol is */
    /* exported via a ref to a fn. Note that a global symbol may be     */
    /* exported twice: once directly and once via a function reference. */
    struct hentry *h;
    struct globsym *gs;
    char *s = name, *id = "!!", *oname;
    int ch;
    unsigned32 veneer_type;

    while ((ch = *s) != 0 && ch != '(') ++s;
    oname = s;
    if (ch == '(')
    {   oname = ++s;
        while ((ch = *s) != 0 && ch != ')') ++s;
        *s = 0;
        if (ch != ')')
        {   msg(warn_eftname(name, oname));
            return;
        }
        /* Assert: ch == ')' */
        if ((id = object_id(oname)) == NULL)
        {   *s = ')';                    /* restore - earlier set to 0 */
            msg(err_extnotfound(name));
            return;
        }
        oname[-1] = 0;                   /* terminate the name part */
        veneer_type = SYM_FNVSYM;
    }
    else
        veneer_type = SYM_DEXSYM;

    (name-2)[0] = id[0]; (name-2)[1] = id[1];
    h = lookup((name-2), &globhashtable);
    if (h == NULL)
    {   msg(err_extnotfound(name));
        return;
    }

    gs = h->h_un.globval;
    if (gs->symval.area == NULL) /* catch null area pointer first... */
        if (gs->symval.flags & SYM_ABSAT)
        {   gs->symval.flags |= SYM_LINKSYM;
            msg(warn_constmigrationtostub(name));
        }
        else
            msg(err_badsymbolforexportfromsharedlib(name));
    else
    {
        if ((gs->symval.area->attrs & AOF_CODEAT) &&
            !(gs->symval.flags & SYM_DATAAT))
        {   /* putatively exported code symbol... */
            if (gs->symval.flags & veneer_type)
            {   if (veneer_type == SYM_DEXSYM)
                    msg(warn_eftdup1(name));
                else
                    msg(warn_eftdup2(name, oname));
            }
            else
            {   if ((gs->symval.flags & SYM_EFTSYM) == 0)
                    gs->pcit_entry = eft_size++;
                if (veneer_type == SYM_FNVSYM) ++eft_extra;
            }
        }
        else if (veneer_type == SYM_FNVSYM)
            msg(err_eftnoncode(name, oname));
        gs->symval.flags |= (SYM_EFTSYM+veneer_type);
    }
}

#define NOT_JUST_DATA \
    (AOF_CODEAT+AOF_COMDEFAT+AOF_COMREFAT+AOF_0INITAT+\
         AOF_PICAT+AOF_DEBUGAT+AOF_BASEDAT+AOF_SHLDATA)

static void mark_shl_data(char *oname, char *aname)
{   struct aentry *aep;
/* Subtlety: + on its own yields oname == "" which matches nothing. */
/* + () yields oname == NULL, aname == "" which matches anything.   */
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if (oname != NULL && CiStrNE(oname, aep->oep->oname))
            continue;
        if (aname != NULL && aname[0] != 0 && CiStrNE(aname, aep->name))
            continue;
        if ((aep->attrs & NOT_JUST_DATA) == 0) aep->flags |= SHLRODATA;
    }
}

#undef NOT_JUST_DATA

static void shl_data(char *s)
{   /* Assert: s is writable... */
    int ch;
    char *oname = NULL, *aname = NULL;

    libdataflag = 1;

    while ((ch = *s++) != 0)
    {   if (isspace(ch) || ch == ',') continue;
        if (ch == '(')
            oname = NULL;
        else
        {   oname = s-1;
            while (ch != 0 && ch != ' ' && ch != ',' && ch != '(') ch = *s++;
            s[-1] = 0;
        }
        if (ch == '(')
            while (ch != 0 && ch != ')')
            {   do ch = *s++; while (isspace(ch) || ch == ',');
                aname = s-1;
                while (ch != 0 && ch != ' ' && ch != ',' && ch != ')')
                    ch = *s++;
                s[-1] = 0;
                mark_shl_data(oname, aname);
            }
        else
            mark_shl_data(oname, NULL);
    }
}

static void build_shl_description(void)
{   struct oventry *ov;
    struct lventry *lv;
    struct aentry *aep;
    FILE *iop;
    char *s, *shl_image;
    int ch, lineno;
    int32 shldatasz;

    if ((iop = fopen(shl_file, "r")) == NULL) msg(fatal_openerr(shl_file));

    lineno = 0;
    shl_image = NULL;
    ch = 0;
    while ((s = getline(iop, shl_file, ++lineno)) != NULL)
    {   while (isspace(*s)) ++s;                  /* skip leading spaces */

        if (ch == '\\' ||                       /* continuation line, or */
            (ch = *s) == '>')                   /* found the output line */
        {   if (ch == '>')
            {   char *fname;
                if (shl_image != NULL)
                {   msg(warn_dupopline(shl_file, lineno));
                    continue;
                }
                do { ++s; } while (isspace(*s));          /* skip spaces */
                fname = s;
                while ((ch = *s) != 0 && ch != '(' && !isspace(ch)) ++s;
                                              /* skip to space, '(' or 0 */
                *s++ = 0;        /* and mark the end of the library name */
                if (ch == '(')
                {   shl_name = strcpy(halloc(strlen(fname)+1L), fname);
                    fname = s;
                    while ((ch = *s) != 0 && ch != ')') ++s;
                    if (ch == ')')
                        *s++ = 0, ch = *s;
                    else
                        msg(warn_missket(shl_file, lineno));
                    if (strcmp(fname, "-") == 0) shl_flag = 2;
                        /* all output in a single AOF file... */
                }
                shl_image = strcpy(halloc(strlen(fname)+1L), fname);
                if (shl_name == NULL) shl_name = shl_image;
            }
            /* now deal with other parameters to __rt_dynlink... */
            while (ch != 0)
            {   while (isspace(*s)) ++s;
                if ((ch = *s) == '"')
                    s = stringparam(s);
                else if (ch == ';')
                    break;
                else if (ch == '\\')
                {   while ((ch = s[1]) != 0 && ch != ';' && isspace(ch)) ++s;
                    if (ch == 0 || ch == ';')
                    {   ch = '\\';          /* continuation line follows */
                        break;
                    }
                }
                else if (ch != 0)             /* a number, by hypothesis */
                {   char *p, *s0;
                    errno = 0;
                    int32param(strtoul(s, &p, 0));
                    s0 = s;
                    do {++s;} while (*s != 0 && !isspace(*s));
                    if (s != p || errno == ERANGE)
                    {   *s = 0;
                        msg(err_eftbadnum(s0));
                    }
                }
                ch = *s;
            }
        }
        else if (ch == ';' || ch == 0)
            continue;
        else if (ch == '+')
            shl_data(s+1);
        else
            eft_entry_name(s);
    }
    if (ferror(iop)) msg(fatal_readerr(shl_file));
    fclose(iop);
    if (shl_image == NULL) msg(fatal_noshlimage(shl_file));

    root.level_list = lv = (struct lventry *) halloc(sizeof(struct lventry));
    lv->next = NULL;
    lv->clash = 0;
    lv->seg_list = ov = (struct oventry *) halloc(sizeof(struct oventry));
    init_overseg(ov, shl_image, NULL);
    ov->level = lv;

    shldatasz = 0;
    for (aep = objarealist;  aep != NULL;  aep = aep->nxt)
    {   if ((aep->attrs & (AOF_CODEAT|AOF_RONLYAT)) == (AOF_CODEAT|AOF_RONLYAT))
        {   if ((aep->attrs & AOF_REENTAT) == 0)
                msg(warn_notreent(aep->name, aep->oep->oname,
                    aep->oep->fep->fname));
            aep->overseg = ov;
        }
        else if (aep->flags & SHLRODATA)
    /* mark_shl_data() has already been careful only to mark areas which */
    /* are suitable for inclusion in a shared library.                   */
        {   if (aep->relocs > 0)
                msg(err_relocdata(aep->oep->oname, aep->name));
            else
    /* Here, we clone the data area description, marking the clone read- */
    /* only and changing its name to SHL$$data. The original description */
    /* is marked 0-initialised and left in the stub as area $$0. Name    */
    /* and attribute homogenization are vital: otherwise AREA sorting    */
    /* might preclude a simple block copy from the library to the stub.  */
            {
                struct aentry *clone = addarea("SHL$$data", aep->oep,
                    aep->areaoff, aep->areasiz, /* no relocs */ 0, 0,
                    (aep->attrs & AOF_ALMASK) | AOF_RONLYAT, aep->areano);
                clone->overseg = ov;             /* the sharable library */
                strcpy(aep->name, "$$0");  /* always >=4 chars available */
                aep->attrs = (aep->attrs & AOF_ALMASK) | AOF_0INITAT;
                if (shldatasz == 0)
                {   stub_0base->h_un.globval->symval.area = aep;
                    shl_database->h_un.globval->symval.area = clone;
                }
                shldatasz += aep->areasiz;
            }
        }
    }
    shl_datasz->h_un.globval->symval.value = shldatasz;
    if (stub_0base->h_un.globval->symval.area == NULL)
        stub_0base->h_un.globval->symval.flags |= SYM_ABSAT;
    if (reent_flag)
        make_reentrant_inter_LU_object();
    else
        make_simple_inter_LU_object();
}

static int default_resolve(struct globsym *gs)
{   struct sym *sy;
    if (unresolved_fn == NULL ||
        ((sy = &(unresolved_fn->symval))->flags & SYM_DEFAT) == 0)
        return 0;
    gs->symval = *sy;
    return 1;
}

/*
 * Place areas in their overlay segments, only place those areas whose location
 * can be determined easily. Ie. Named in overlay file, object file areas,
 * data areas & areas not referenced by any other area.
 */
static void place_areas(void)
{
    struct aentry *aep, **prev;

    prev = &objarealist;
    aep = objarealist;
    while (aep)
    {   struct aentry *nextaep;
        nextaep = aep->nxt;
        if (aep->oep == NULL)            /* Anonymous area - goes in root */
            aep->overseg = &root;
        if (aep->overseg != NULL ||                  /* Seg already known */
                !(aep->oep->fep->type & LIB_MASK) ||        /* Obect file */
                !(aep->attrs & AOF_CODEAT) ||                /* Data area */
                (aep->refs == NULL))                  /* Isn't refered to */
        {   if (aep->overseg == NULL)     /* Seg not known - goes in root */
                aep->overseg = &root;
            *prev = aep->nxt;             /* Remove from global area list */
            *(aep->overseg->nextarea) = aep;        /* Add to end of list */
            aep->overseg->nextarea = &(aep->nxt);
            aep->nxt = NULL;
            aep->overseg->noofareas++;
        } else
            prev = &(aep->nxt);
        aep = nextaep;
    }
}

/*
 * Place library areas in overlay segments using following rule,
 *
 * If all references to an area automatically include from a library are from
 * the same overlay segment then the area is included in that segment.
 * Otherwise, it is included in the lowest-level segment which can be co-
 * resident with all segments referring to it.
 *
 * This rule was written for multiply layered overlay segment. Since we only
 * support single layering (ie. no local roots for the present) the rule can
 * be rewritten.
 *
 * If all references to an area automatically include from a library are from
 * the same overlay segment then the area is included in that segment.
 * Otherwise, it is included in the root segment.
 *
 * This solves everything except ...
 *        Mutually dependant library areas which are not referenced by any other
 *        area. Since these are likely to be in a minority they are placed in
 *        the root segment.
 */

static void place_libareas(void)
{
    struct aentryptr *refaep;
    struct aentry *aep, **prev;
    int32 placed, ne;
    struct oventry *ov;

    do {
        prev = &objarealist;
        aep = objarealist;
        placed = 0;                /* Flag to see if we placed an area */
        while (aep) {
            struct aentry *nextaep;

            nextaep = aep->nxt;
            refaep = aep->refs;
            ne = 0;                /* Flag to see if we found any segs != */
            ov = refaep->aep->overseg;
            do {
                if (!refaep->aep->overseg)
                    break;        /* Not all referee segs placed */
                if (refaep->aep->overseg != ov)
                    ne = 1;
            } while ((refaep = refaep->next) != 0);
            if (!refaep) {        /* Reached end of list - all segs defined */
                aep->overseg = ov;
                if (ne)
                    aep->overseg = &root;
                placed = 1;
                *prev = aep->nxt;          /* Remove from global area list */
                *(aep->overseg->nextarea) = aep;    /* Add to end of list */
                aep->overseg->nextarea = &(aep->nxt);
                aep->nxt = NULL;
                aep->overseg->noofareas++;
            } else
                prev = &(aep->nxt);
            aep = nextaep;
        }
    } while (placed);
    /* Now tag any remaining areas onto the root */
    aep = objarealist;
    *(root.nextarea) = objarealist;
    while (aep) {
        aep->overseg = &root;
        aep->overseg->noofareas++;
        aep = aep->nxt;
    }
}

static void addarearef(struct aentry *aep, struct aentry *reftoaep)
{   struct aentryptr *ah;

    for (ah = aep->refs;  ah != NULL; ah = ah->next)
        if (ah->aep == reftoaep) return;

    if (xrefflag)
    {   char *anon = msgtext(misc_anon);
        char *oname = aep->oep != NULL ? aep->oep->oname : anon;
        char *ref_oname = reftoaep->oep != NULL ? reftoaep->oep->oname : anon;
        printf(msgtext(misc_refto), oname,aep->name, ref_oname,reftoaep->name);
    }
    ah = (struct aentryptr *) halloc(sizeof(struct aentryptr));
    ah->aep = reftoaep;
    ah->next = aep->refs;
    aep->refs = ah;
}

static void add_area_xrefs(struct aentry *aep)
{
    int32 siz;
    struct aentry *rel_wrt_area = 0;
    struct sym *sy;
    struct hentry *h;

    /* If no relocs, or making shared lib and relocs are in code, */
    /* then there is nothing to do.                               */
    if (aep->relocs == 0 || shl_flag && (aep->attrs & AOF_CODEAT)) return;

    setobject(aep->oep);
    if (aep->oep->fep->type & AOUT_MASK)
    {
#ifdef TARGET_HAS_AOUT
        struct relocation_info *reloc, *r, *rend;

        siz = aep->relocs * sizeof(struct relocation_info);
        reloc = (struct relocation_info *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++)
        {   if (r->r_extern)
            {   h = aep->oep->numtosym[r->r_symbolnum];
                sy = &(h->h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT)
                    rel_wrt_area = sy->area;
            }
            else switch (r->r_symbolnum & N_TYPE)
            {
case N_TEXT:    rel_wrt_area = aep->oep->arealist[CODE_AREA];
                break;
case N_DATA:
                rel_wrt_area = aep->oep->arealist[DATA_AREA];
                break;
case N_BSS:
                rel_wrt_area = aep->oep->arealist[BSS_AREA];
                break;
            }
            if (rel_wrt_area != NULL && rel_wrt_area != aep)
                addarearef(aep, rel_wrt_area);
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        aof_reloc *reloc, *r, *rend;
        int32 symno, pcrel, addsym;
        unsigned32 rflags;

        siz = aep->relocs * sizeof(aof_reloc);
        reloc = (aof_reloc *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs;  r < rend;  r++)
        {   rflags = hv(r->rel_flags);
            if (rel_type2(rflags))
            {   symno  = rel2_sid(rflags);
                pcrel  = rel2_R(rflags);
                addsym = rel2_A(rflags);
            }
            else
            {   symno  = rel1_sid(rflags);
                pcrel  = rel1_R(rflags);
                addsym = rel1_A(rflags);
                if (pcrel) addsym = 1;
                if (!addsym) symno = aep->areano;
            }
            if (addsym)
            {   h = aep->oep->numtosym[symno];
                sy = &(h->h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT) rel_wrt_area = sy->area;
            }
            else
            {   rel_wrt_area = aep->oep->arealist[symno];
                sy = NULL;
                h = NULL;
            }
            if (rel_wrt_area == NULL) continue;
            if (shl_flag)
    /* Here, we must fault all references between the shared library and */
    /* its stub, save for those via the EFT function entry veneers.      */
            {   if (aep->overseg == rel_wrt_area->overseg) continue;
                if (rel_wrt_area->overseg == &root)
                {   /* (*aep) in the shared lib, relocated wrt its stub. */
                    msg(err_shlrefstub(aep->name, aep->oep->oname,
                        rel_wrt_area->name, rel_wrt_area->oep->oname));
                }
                else
                {   /* (*aep) in the stub, relocated wrt the shared lib. */
                    /* OK iff relocated wrt an EFTSYM code symbol.       */
                    if (rel_wrt_area->attrs & AOF_CODEAT &&
                        sy != NULL &&
                        (sy->flags & (SYM_EFTSYM+SYM_DATAAT)) == SYM_EFTSYM)
                        continue;
                    msg(err_stubrefshl(aep->name, aep->oep->oname,
                        rel_wrt_area->name, rel_wrt_area->oep->oname));
                }
                msg(info_badref(
                    h == NULL ? msgtext(misc_areabase) : h->name+2,
                    sy == NULL ? 0L : sy->value,
                    hv(r->rel_offset)));
            }
            else if (rel_wrt_area != aep)
                addarearef(aep, rel_wrt_area);
        }
#endif /* TARGET_HAS_AOF */
    }
}

static void reference(struct aentry *aep)
{   struct aentryptr *ah;

    aep->flags |= REFERENCED;
    for (ah = aep->refs;  ah != NULL; ah = ah->next)
    {   if (ah->aep->flags & REFERENCED) continue;
        reference(ah->aep);
    }
}

static void remove_unused_areas(void)
{
    struct aentry *aep, *nextaep, **prev;

    reference(entryarea);

    prev = &objarealist;
    aep = objarealist;
    while (aep != NULL)
    {   nextaep = aep->nxt;
        if ((aep->flags & REFERENCED) || (aep->attrs & AOF_DEBUGAT))
           prev = &(aep->nxt);
        else
        {   if (xrefflag || verboseflag)
            {   if (aep->oep != NULL)
                    msg(info_unused_AREA_3(
                        aep->name, aep->oep->oname, aep->oep->fep->fname));
                else
                    msg(info_unused_AREA_1(aep->name));
            }
            aep->flags |= UNUSEDAREA;
            *prev = nextaep;
        }
        aep = nextaep;
    }
}

static unsigned32 alignof(unsigned32 val, int32 attributes)
{   unsigned32 align = 4L;
    int32 n = attributes & 31L;
    if (!plinkflag) while (--n >= 2) align *= 2;
    align -= 1;
    return (val + align) & ~align;
}

static int32 map_areas(struct oventry *ov, int32 base)
{
    struct aentry **arealist, **areasend, **area, *aep;
    int32 dbgsize, bsssize, datasize, textsize;
    int32 tor, dor, bor, dbgor, siz, psiz, at, i;
    struct lventry *lv;
    char *name;

    ov->arealist = arealist = (struct aentry **)
                            halloc(ov->noofareas * sizeof(struct aentry *));
    nextoutarea = &(ov->outarealist);
    for (aep = ov->areas;  aep != NULL;  aep = aep->nxt)
    {   name = aep->name;
        if (shl_flag && ov == &root)
        {   if (aep->attrs & AOF_BASEDAT)
                name = interLUdataName;
            else if (aep->attrs & AOF_SHLDATA)
/* Stub data from other stubs, which shouldn't be included in this stub. */
/* However, refs to these areas need to be converted to symbol-relative  */
/* refs to the corresponding area$$Base symbols. We create the symbols   */
/* here to avoid phase-order problems in AOF output.                     */
            {   aep->h = globinsert(mkname(NULL, aep->name, "$$Base"),
                    makesym(0, SYM_REFAT+SYM_LINKSYM, NULL), "!!");
                aep->flags |= UNHASHED;
                --ov->noofareas;
                continue;
            }
            else if (!(aep->attrs & AOF_CODEAT))
            {   name = mkname(NULL, shl_name,
                    (aep->attrs & AOF_0INITAT) ? "$$zidata" : "$$data");
                aep->attrs |= AOF_SHLDATA;
            }
        }
        hash_area(ov, aep, name);
        *arealist++ = aep;
    }
    areasend = arealist;

    arealist = ov->arealist;
    sortareas(arealist, ov->noofareas);

    tor = base;
    dor = 0;          /* here, meaning dealing with read-only section */
    if (output_type == AIF && !binaryflag && !moduleflag && ov == &root)
        tor += (int32) sizeof(struct aif_hdr);
    dbgsize = bsssize = datasize = textsize = 0;
    for (area = arealist;  area < areasend;  area++)
    {   at = (*area)->attrs;
        siz = ((*area)->areasiz + 3) & ~3;
        if ((at & AOF_RONLYAT) == 0 && dor == 0)
        {   if (rw_baseflag) tor = data_base;
            dor = 1;  /* now dealing with read-write section */
        }
        i = tor;
        tor = alignof(i, at);
        siz += tor - i;
        tor += siz;
        if (((*area)->flags & SHFLAG) == 0)
        {   if (at & AOF_DEBUGAT)
                dbgsize += siz;
            else if (at & AOF_0INITAT)
                bsssize += siz;
            else if (at & AOF_RONLYAT)
                textsize += siz;
            else
                datasize += siz;
        }
    }

    psiz = 0;
    if (scatterflag == OVERLAY)
    {   if (ov == &root)
        {   int32 clash_total;
            struct oventry *ov1;

            clash_total = 0;
            for (lv = root.level_list;  lv != NULL;  lv = lv->next)
            {   for (ov1 = lv->seg_list;  ov1 != NULL;  ov1 = ov1->next)
                    clash_total += lv->clash;
            }
            psiz = overlay_segments * sizeof(struct pcit_section) +
                (entryv_total + overlay_segments + clash_total)*4;
            root.pcit_base = base + textsize + datasize +
                (int32) (binaryflag ? 0 : sizeof(struct aif_hdr));
        }
        else
        {   psiz = ov->entryv * 4;
            ov->pcit_base = root.pcit_base;
            root.pcit_base += psiz + 4 + sizeof(struct pcit_section) +
                ov->level->clash * 4;
        }
        datasize += psiz;
    }

    bor = dor = tor = base;  /* to keep cc's data flow happy ... */

    if (output_type == AOUT)
    {
#ifdef TARGET_HAS_AOUT
        if (plinkflag || nmagicflag) {
            dor = tor + textsize;
            bor = dor + datasize;
        } else {
            dor = (tor + textsize + (int32)(pagesize - 1)) &
                ~(int32)(pagesize - 1);
            bor = dor + datasize;
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        if (plinkflag)
        {   if (!shl_flag) dor = textsize;
            bor = dor + datasize;
        }
        else
        {   if (output_type == AIF && !binaryflag && !moduleflag &&
                ov == &root)
                tor += (int32) sizeof(struct aif_hdr);
            dor = (rw_baseflag ? data_base : tor + textsize);
            bor = dor + datasize;
            if (rw_baseflag &&
                ((dor >= tor && dor < tor+textsize) ||
                 (dor <  tor && (bor+bsssize) > tor)))
            {
                msg(err_base_overlap(data_base, base));
            }
        }
#endif
    }

    ov->torigin = tor;
    ov->dorigin = dor;
    ov->borigin = dbgor = bor;
    ov->base = base;
    for (area = arealist;  area < areasend;  area++)
    {   aep = *area;
        if (aep->flags & (AREA_FIRST|AREA_LAST))
        {   int32 flags = aep->flags & (AREA_FIRST|AREA_LAST);
#define MASK (AOF_RONLYAT|AOF_0INITAT|AOF_DEBUGAT)
            aep->flags = aep->flags & ~flags;
            if ((flags & AREA_FIRST) && (area + 1) < areasend &&
                attr_index(aep->attrs & MASK) >
                    attr_index(area[1]->attrs & MASK) ||
                (flags & AREA_LAST) && area > arealist &&
                attr_index(area[-1]->attrs & MASK) >
                    attr_index(aep->attrs & MASK))
            {   struct aentry *x = (flags & AREA_FIRST) ? area[1] : area[-1];
                char buf[64];
                sprintattrs(buf, sizeof(buf), (aep->attrs ^ x->attrs) & MASK);
                msg(err_incompat_attrib(x->oep->oname, x->name, buf));
            }
#undef MASK
            aep->flags |= flags;
        }
        at = aep->attrs;
        siz = aep->areasiz + 3 & ~3;
        if ((aep->flags & SHFLAG) == 0)
        {   base = aep->base;
            if (at & AOF_0INITAT)
            {   aep->base = alignof(bor, at);
                aep->areapad = aep->base - bor;
                siz += aep->areapad;
                bor += siz;
            }
            else if (at & AOF_DEBUGAT)
            {   aep->base = alignof(dbgor, at);
                aep->areapad = aep->base - dbgor;
                siz += aep->areapad;
                dbgor += siz;
            }
            else if (at & AOF_RONLYAT)
            {   aep->base = alignof(tor, at);
                aep->areapad = aep->base - tor;
                siz += aep->areapad;
                tor += siz;
            }
            else
            {   aep->base = alignof(dor, at);
                aep->areapad = aep->base - dor;
                siz += aep->areapad;
                dor += siz;
            }
            if ((at & AOF_ABSAT) && (base != aep->base))
                msg(fatal_baseclash(aep->name, base, aep->base));
        }
        if (aep == entryarea)
        {   if (ov != &root) msg(err_notroot);
            outentryarea = aep->h->h_un.areaval;
            outentryofs = entryoffset + outentryarea->base;
        }
        aep->h->h_un.areaval->areasiz += siz;
        if (aep->h->h_un.areaval->base == -1)
            aep->h->h_un.areaval->base = aep->base;
    }
    *nextoutarea = NULL;
    aep = ov->outarealist;
    {   int32 na = ov->noofoutareas;
        if (shl_flag == 2) na += 1L;
            /* extra slot for shared library read-only area */
        arealist = ov->outareas =
            (struct aentry **) halloc(na * sizeof(struct aentry *));
    }
    while (aep)
    {   *arealist++ = aep;
        if (!plinkflag)
            linksymbl(aep->name, aep->base, aep->base + aep->areasiz);
        else if (shl_flag && ov == &root &&
                 StrEQ(aep->h->name, interLUdataName))
        {
            struct globsym *gs = sb_limit->h_un.globval;
            gs->symval.flags |= SYM_LOCALDEFAT+SYM_ABSAT;
            gs->symval.value = aep->areasiz - paramBlkUsed;
        }
        aep = aep->nxt;
    }
    sortareas(ov->outareas, ov->noofoutareas);
    arealist = ov->outareas;
    for (i = ov->noofoutareas - 1; i>=0; i--)
        arealist[i]->areano = i;
    ov->textsize = textsize;
    ov->datasize = datasize;
    ov->bsssize = bsssize;
    ov->dbgsize = dbgsize;
    ov->limit = ov->base + textsize + datasize + bsssize - psiz;
    return textsize + datasize + bsssize;
}

static void do_final_symbol_matching()
{   struct hentry *h, *h2;
    struct globsym *gs;
    int32 siz, csize, r;
    char tmpsym[MAXSYMLEN];
    int match;

    if (plinkflag) return;

    match = match_opts;
    csize = 0;
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if (!(gs->symval.flags & SYM_DEFAT))
        {   char *cp;
            siz = gs->symval.value;
            cp = h->name;
            tmpsym[0] = *cp++;
            tmpsym[1] = *cp++;
            tmpsym[2] = 0;

            if (cp[0] == '_')
            {   if (match & MATCH_xTOx)
                    bufcpy(tmpsym+2, cp+1, sizeof(tmpsym)-2);
            }
            else
            {   while (*cp != 0) {if (*cp == '_') break; cp++;}
                if (cp[0] == '_')
                {   bufcpy(tmpsym, h->name, sizeof(tmpsym));
                    if (cp[1] == '_' && (match & MATCHx__yTOx) &&
                        (cp - h->name) < sizeof(tmpsym))
                        tmpsym[cp - h->name] = 0;

                    if (cp[1] != '_' && (match & MATCHx_yTOxDOTy) &&
                        (cp - h->name) < sizeof(tmpsym))
                        tmpsym[cp - h->name] = '.';
                }
                else if (match & MATCHxTO_x)
                {   tmpsym[2] = '_';
                    bufcpy(tmpsym + 3, h->name + 2, sizeof(tmpsym)-3);
                }
            }
            /* Assert: tmpsym now contains one of:                  */
            /*     h->name[0-1] - i.e. the empty name (can't match) */
            /*     h->name                            (can't match) */
            /*     a translated name, which might match.            */

            if (((h2 = lookup(tmpsym, &globhashtable)) != 0) &&
                 (h2->h_un.globval->symval.flags & SYM_DEFAT))
            {   gs->symval = h2->h_un.globval->symval;
                msg(warn_symbol_match(h->name+2, tmpsym+2));
                continue;
            }

            if ((h2 = lookup(h->name + 2, &commontable)) != 0)
            {   struct aentry *a = h2->h_un.areaval;
                if (siz > a->areasiz)
                {   if (a->attrs & AOF_0INITAT)
                        a->areasiz = siz;
                    else
                        msg(warn_comsym_toobig(h2->name, a->oep->oname));
                }
                gs->symval.flags = SYM_GLOBALDEFAT;
                gs->symval.area = a;
                gs->symval.value = 0;
            }
            else if (siz && !(gs->symval.flags & SYM_WEAKAT))
            {   gs->symval.flags = SYM_GLOBALDEFAT;             /* fixme */
                if (siz > 2)
                    r = 3;                /* 4-byte alignment by default */
                else if (siz == 2)
                    r = 1;                /* 2-byte for isolated shorts  */
                else /* siz == 1 */
                    r = 0;                /* 1-byte for isolated chars   */
                csize = (csize + r) & ~r;
                gs->symval.value = csize;
                csize += siz;
            }
        }
        if ((gs->symval.flags & SYM_DEFAT) &&
            gs->symval.area != NULL &&
            (gs->symval.area->attrs & AOF_CODEAT) &&
            gs->symval.area->overseg != NULL &&
            gs->symval.area->overseg != &root)
        {
            gs->pcit_entry = (gs->symval.area->overseg->entryv++);
            entryv_total++;
        }
    }
    if (common != NULL) common->areasiz = csize;
}

static void middle(void)
{
    struct hentry *h;
    struct globsym *gs;
    int32  undefs, torigin;
    struct lventry *lv;
    struct oventry *ov;

    torigin = base;
#ifdef TARGET_HAS_AOUT
    textoffset = base - pagesize;
    if (sharedlib) {
        torigin = lookup("!!_estext",
                                &globhashtable)->h_un.globval->symval.value;
        textoffset = (torigin & ~0x7fff) - 0x8000;
    }
#endif
    torigin += map_areas(&root, torigin) +
        (binaryflag || plinkflag ? 0L : (int32) sizeof(struct aif_hdr));
#ifdef TARGET_HAS_AOF
    if (moduleflag)
    {   srcposn = root.textsize + root.datasize;
        root.datasize += amf_reloc_code_size;
    }
#endif
    if (shl_flag)
    {   ov = root.level_list->seg_list;
        (void) map_areas(ov, 0);
        eft_params->h_un.globval->symval.value =
            (ov->limit - ov->base) + (eft_size+1)*sizeof(int32);
        eft_offset->h_un.globval->symval.value = (ov->limit - ov->base);
    }
    else
    {   int32 seg_size, max_seg_size;
        for (lv = root.level_list;  lv != NULL;  lv = lv->next)
        {   max_seg_size = 0;
/* LDS */   if (relocflag) torigin = 0;
            for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
            {   seg_size = map_areas(ov, torigin);
                if (seg_size > max_seg_size) max_seg_size = seg_size;
            }
            torigin += max_seg_size;
            total_seg_size += max_seg_size;
        }
        if (!plinkflag)
        {   linksym("_etext", root.torigin + root.textsize);
            linksym("_edata", root.dorigin + root.datasize);
            linksym("_end", root.borigin + root.bsssize);
            if (!sharedlib)
            {   linksym("_estext", root.torigin);
#ifdef USRSTACK
                linksym("_esdata", USRSTACK);
#endif
            }
linksymbl("Image$$RO", root.torigin, root.torigin + root.textsize);
linksymbl("Image$$RW", root.dorigin, root.borigin+root.bsssize+total_seg_size);
linksymbl("Image$$ZI", root.borigin, root.borigin+root.bsssize+total_seg_size);
oldsym("!!Image$$CodeBase",  "Image$$RO$$Base", root.torigin);
oldsym("!!Image$$CodeLimit", "Image$$RO$$Limit", root.torigin+root.textsize);
oldsym("!!Image$$DataBase",  "Image$$RW$$Base", root.dorigin);
oldsym("!!Image$$DataLimit", "Image$$RW$$Limit",
     root.borigin + root.bsssize + total_seg_size);
            if (moduleflag) linksym("__RelocCode", root.torigin + srcposn);
        }
    }
    *nextglobsym = NULL;
    undefs = 0;
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if (debugflag || plinkflag &&
                ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT ||
                    output_type == AOUT))
        {
            if ((!shl_flag || (gs->symval.flags & (SYM_EFTSYM+SYM_LINKSYM))) &&
                (gs->symval.area == NULL ||
                 !(gs->symval.area->flags & UNUSEDAREA)))
            {   gs->symval.symno = symcount;
                symcount++;
                strtsize += (int32)(size_t)(strlen(h->name));
                    /* The 2 char prefix to h->name is not output, but here */
                    /* reserves space for a for a len byte and a final NUL. */
#ifdef USE_PSTRING_SYMBOLS
                if (plinkflag)       /* No len byte when partial linking... */
#endif                               /* ... nor when !USE_PSTRING_SYMBOLS.  */
                    strtsize -= 1L;
            }
        }
        if (!(gs->symval.flags & SYM_DEFAT))
        {   if (gs->symval.flags & SYM_WEAKAT)
                gs->symval.value = 0;
            else if ((!plinkflag ||
                      shl_flag && !(gs->symval.flags & SYM_LINKSYM)) &&
                     !default_resolve(gs))
            {   struct oentry *oep = gs->symval.refobj;
                if (undefs == 0) msg(err_undefsyms);
                undefs++;
                if (oep == NULL)
                    msg(info_undefsym1(cplusplusname(h->name+2)));
                else if (oep->fep->type & LIB_MASK)
                    msg(info_undefsym3(cplusplusname(h->name+2), oep->fep->fname, oep->oname));
                else
                    msg(info_undefsym2(cplusplusname(h->name+2), oep->fep->fname));
            }
        }
        else if (!(gs->symval.flags & SYM_ABSAT) && gs->symval.area != NULL)
            /* SYM_ABSAT <=iff=> area == NULL... but code it defensively */
            gs->symval.value += gs->symval.area->base;
    }
    strtsize = (strtsize + 3L) & ~3L;
}

static void writereloc(int32 offset, int32 dtod)
{   /* Get very fussy about when to allow the new bit marking
     * Data->Data relocation to be included in the relocation entry:
     * must avoid confusing older code!
     */
    int32 ddbit = (dtod && moduleflag && !private_amf_reloc) ? 1 << 1 : 0;
    int32 t = tv(offset | ddbit);
    /* If we are linking with -rmf and -base, then this is a ROM link, so we
     * can omit non data->data relocations for efficiency.
     */
    if (baseflag && moduleflag && !dtod)
        return;
    listpush( &reloclist, (char *)&t );
    reloc_count++;
}

#ifdef TARGET_HAS_AOUT

static void writeaoutreloc( struct relocation_info *r )
{
    listpush( &aoutreloclist, (char *)r );
    reloc_count++;
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static void writeaofreloc(int32 offset, int32 rflags)
{
    aof_reloc r;

    r.rel_offset = tv(offset);
    r.rel_flags  = tv(rflags);
    /* writebytes(relocposn, (char *) &r, sizeof(aof_reloc)); */
    /* relocposn += sizeof(aof_reloc); */
    listpush( &aofreloclist, (char *)&r );
    reloc_count++;
}

#endif /* TARGET_HAS_AOF */

static int32 instr_offset(int32 *p, int lim)
{   int32 v = hv(*p), op;

    if ((op = (v & 0x0e000000)) == 0x0a000000)         /* B, BL */
    {   /* B or BL */
        return (v << 8) >> 6;                          /* byte offset */
    }

    if (lim < 0) return -1L;    /* no instruction sequence relocation */

    if (op == 0x04000000 ||                            /* LDR/STR */
        (op = (v & 0x0ff00000)) == 0x02800000 ||       /* ADD immediate */
        op == 0x02400000)                              /* SUB immediate */
    {   int icount = 0;
        unsigned32 Rd = (unsigned32)-1;
        int32 offset = 0;

        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   Rd = v & 0x0000f000;
            /* Loop Invariant: lim == 0 || icount < lim */
            do                                         /* 1-3 ADD/SUBs */
            {   v = imm_to_val(v);
                if (op == 0x02400000) v = -v;          /* SUB */
                offset += v;                           /* byte offset */
                ++icount;
                if (icount == lim) return offset;
                v = hv(p[icount]);
            }
            while (icount < 3 && (v & 0x0ff00000) == op &&
                   (v & 0x0000f000) == Rd && ((v & 0x000f0000) >> 4) == Rd);
            op = (v & 0x0e000000);
        }
        /* ... followed by an LDR or STR... */
        /* Assert: lim == 0 || icount < lim */
        if (op == 0x04000000 &&
            (Rd == -1 || ((v & 0x000f0000) >> 4) == Rd))
        {   /* LDR/STR immediate */
            op = v & 0xfffff000;
            v &= 0xfff;                                /* byte offset */
            if ((op & 0x00800000) == 0) v = -v;
            offset += v;
        }
        return offset;
    }
    /* else error - not handled */
    return  -1L;
}

static int32 instr_reloc(int32 *p, int32 value, int lim)
{   int32 v = hv(*p), op;

    if ((op = (v & 0x0e000000)) == 0x0a000000)
    {   /* B or BL */
        int32 wordvalue = (value >> 2);
        *p = tv((v & 0xff000000) | (wordvalue & 0x00ffffff));
        value -= (wordvalue << 2);                   /* should be 0 */
        if (value != 0) msg(err_relocB);
        return value;
    }

    if (lim < 0) goto fail;    /* no instruction sequence relocation */

    if (op == 0x04000000 ||                            /* LDR/STR */
        (op = (v & 0x0ff00000)) == 0x02800000 ||       /* ADD immediate */
        op == 0x02400000)                              /* SUB immediate */
    {   int icount;
        int32 imm, xx;
        unsigned32 instr = 0;

        /* Count the number of instructions in the candidate sequence */
        icount = 0;
        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   unsigned32 Rd = v & 0x0000f000;
            for (icount = 1;  icount < 3 && icount != lim;  ++icount)
            {   instr = hv(p[icount]);
                if ((instr & 0x0ff00000) != op ||
                    (instr & 0x0000f000) != Rd ||
                    ((instr & 0x000f0000) >> 4) != Rd)
                {   instr = (instr & 0x0e000000);
                    break;
                }
            }
        }
        if (op == 0x02800000 || op == 0x02400000)      /* ADD/SUB */
        {   int n;
            if (instr == 0x04000000 && icount != lim)  /* LDR/STR follows */
            {   /* try to preserve the following LDR/STR offset */
                imm = xx = value - instr_offset(p+icount, 1);
                if (imm < 0) imm = -imm;
                if ((imm >> (icount*8)) == 0)
                {   value = xx;
                    lim = icount; /* ignore following LDR/STR */
                }
                else
                    lim = 0;      /* modify following LDR/STR */
            }
            else
                lim = icount;         /* no following LDR/STR */
            if (value < 0)
            {   instr = 0x02400000;                    /* SUB */
                value = -value;
            }
            else
                instr = 0x02800000;                    /* ADD */
            for (n = 0;  n < icount;  ++n)
            {   imm = val_to_imm(value);
                value -= imm_to_val(imm);
                *p++ = tv((v & 0xf00ff000) | instr | imm);
                v = hv(*p);
            }
            if (value == 0)  /* completed the relocation successfully */
                return 0;
            if (lim != 0)  /* not yet finished and no LDR/STR follows */
                goto fail;
            /* restore the sign of the residuum ready for the LDR/STR */
            if (instr == 0x02400000) /* SUB */ value = -value;
        }
        /* ... followed by an LDR or STR... */
        instr = v & 0xff7ff000;
        if (value < 0)
            value = -value;
        else
            instr |= 0x00800000;
        *p = tv(instr | (value & 0xfff));
        value &= 0xfffff000;                      /* should now be 0 */
    }
fail:
    if (value != 0 || lim < 0) msg(err_relocseq);
    return value;
}


static int32 overseg_entry(int32 index, struct sym *sy)
{
    return sy->area->overseg->pcit_base + 4 + (4 * index);
}


static int32 eft_entry(int32 index, int32 type)
{   if (reent_flag)
    {   if (type == 3)
            /* direct instr ref to fn entry veneer... */
            return index * REENTRANT_CODE_STRIDE + inter_LU_code->base;
        else
        {   /* indirect data ref to fn entry veneer... */
            return inter_LU_data_map[index] - 8 + inter_LU_data->base;
        }
    }
    else
        return index * SIMPLE_CODE_STRIDE + inter_LU_data->base;
}

static void load2(struct aentry *aep)
{
    char *area, *cp;
    int32 siz;
    int32 v = 0;
    struct sym *sy;
    int32 savreloc;
    struct aentry* rel_wrt_area = 0;
    int havewarned, havecomplained;
    int32 areasiz;

    havewarned = 0;
    havecomplained = 0;
    if (verboseflag >= 2)
    {   fprintf(stderr, "%s: ", SELF);
        fprintf(stderr, msgtext(misc_reloc1), aep->name);
        if (aep->oep)
        {   fprintf(stderr, msgtext(misc_reloc2), aep->oep->fep->fname);
            if (aep->oep->fep->type & LIB_MASK)
                fprintf(stderr, "(%s)", aep->oep->oname);
        }
        fprintf(stderr, ".\n");
        errcount[0]++;
    }
    if (aep->areasiz <= 0 || (aep->attrs & AOF_0INITAT)) return;

    mark_stack();

    setobject(aep->oep);
    areasiz = aep->areasiz;
    area = map(aep->areaoff, areasiz);
    if (aep->oep->fep->type & AOUT_MASK) {
#ifdef TARGET_HAS_AOUT
        struct relocation_info *reloc, *r, *rend;
        struct aentry *tarea, *darea, *zarea;
        struct exec *aouthdr;
        int32 doff, boff, offt, op;

        siz = aep->relocs * sizeof(struct relocation_info);
        reloc = (struct relocation_info *) map(aep->relocoff, siz);
        tarea = aep->oep->arealist[CODE_AREA];
        darea = aep->oep->arealist[DATA_AREA];
        zarea = aep->oep->arealist[BSS_AREA];
        aouthdr = aep->oep->o_un.aouthdr;
        if (aouthdr->a_magic == OMAGIC)
            doff = aouthdr->a_text;
        else
            doff = (aouthdr->a_text + (int32)(pagesize - 1)) &
                ~(int32)(pagesize - 1);
        boff = doff + aouthdr->a_data;
        if (aep->attrs & AOF_0INITAT)
            offt = boff;
        else if (aep->attrs & AOF_RONLYAT)
            offt = 0;
        else
            offt = doff;
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++) {
            if (r->r_address >= areasiz)
                msg(fatal_badobj(aep->oep->fep->fname));
            cp = area + r->r_address;
            savreloc = plinkflag;
            switch (r->r_length) {
            case 0:
                v = *cp;
                break;
            case 1:
                v = *(short *)cp;
                break;
            case 2:
                v = *(int32 *)cp;
                savreloc = 1;
                break;
            case 3:
                v = *(int32 *)cp;
                op = v & 0xff000000;
                v = ((v & 0x00ffffff) << 8) / 64;
                break;
            }
            if (r->r_extern) {
                sy = &(aep->oep->numtosym[r->r_symbolnum]->
                                            h_un.globval->symval);
                rel_wrt_area = NULL;
                if (sy->flags & SYM_DEFAT) {
                    rel_wrt_area = sy->area;
                    if (!rel_wrt_area) {
                        savreloc = 0;
                        if ((r->r_pcrel || r->r_length == 3) &&
                                (plinkflag))
                            msg(err_pcrelabs(
                                aep->oep->numtosym[r->r_symbolnum]->name+2));
                    }
                }
                if (!plinkflag || (rel_wrt_area))
                    v += sy->value;
                r->r_symbolnum = (int) sy->symno;
            } else {
                switch (r->r_symbolnum & N_TYPE) {
                case N_TEXT:
                    v += tarea->base;
                    rel_wrt_area = tarea;
                    break;
                case N_DATA:
                    v += darea->base - doff;
                    rel_wrt_area = darea;
                    break;
                case N_BSS:
                    v += zarea->base - boff;
                    rel_wrt_area = zarea;
                    break;
                }
            }
            if (r->r_pcrel || r->r_length == 3) {
                if (!plinkflag ||
                            (rel_wrt_area && rel_wrt_area->h == aep->h)) {
                    v -= aep->base - offt;
                    savreloc = 0;
                    if (!r->r_pcrel)
                        v = v - r->r_address;
                }
            } else
                if (plinkflag && r->r_extern && savreloc) {
                    if (!rel_wrt_area)
                        goto nostrback;
                    if (rel_wrt_area->attrs & AOF_0INITAT) {
                        r->r_symbolnum = N_BSS;
                    }
                    else if (rel_wrt_area->attrs & AOF_RONLYAT)
                        r->r_symbolnum = N_TEXT;
                    else {
                        r->r_symbolnum = N_DATA;
                    }
                    r->r_extern = 0;
                }
            switch (r->r_length) {
            case 0:
                if (v < -128 || v > 127)
                  msg(err_reloc(r->r_offset,aep->oep->oname,aep->name,v,255));
                *cp = (char) v;
                break;
            case 1:
                if (v < -32768 || v > 32767)
                  msg(err_reloc(r->r_offset,aep->oep->oname,aep->name,v,65535));
                *(short *)cp = (short) v;
                break;
            case 2:
                *(long *)cp = v;
                break;
            case 3:
                *(long *)cp = v = op | ((v / sizeof(long)) & 0xffffff);
                break;
            }
nostrback:
            if ((relocflag || moduleflag) && savreloc &&
                                                output_type != AOUT)
                writereloc(areaoutposn + r->r_address,
			   !(aep->attrs & AOF_RONLYAT) && /* from RW area */
			   rel_wrt_area && /* relative to some area */
			   !(rel_wrt_area->attrs & AOF_RONLYAT)); /* which is also RW */
            if (plinkflag && savreloc) {
                r->r_address += (unsigned) aep->h->h_un.areaval->areaoff;
                if (output_type == AOUT) {
                    if (aep->attrs & AOF_RONLYAT)
                        textrelocs++;
                    else
                        datarelocs++;
                    writeaoutreloc( r );
                }
            }
        }
#endif /* TARGET_HAS_AOUT */
    }
    else
    {
#ifdef TARGET_HAS_AOF
        struct globsym *gs;
        aof_reloc *reloc, *r, *rend;
        int len, pcrel, addsym, max_ins;
        int32 symno, psave, roffset;
        unsigned32 rflags;
#ifdef LINKING_ON_ACORN_RISC_OS
        struct __link_list *__link;
#endif

        if (lastoutarea != aep->h->h_un.areaval)
        {   areaoutposn += lastoutarea->relocs * sizeof(aof_reloc);
            lastoutarea = aep->h->h_un.areaval;
            if (plinkflag)
            {
                /* write aof relocations (from list structure) */
                /* file pointer should be in correct place (after area) */
                writereloclist( &aofreloclist );
                /* would like to free up list here... but we can't */
                listinit( &aofreloclist, sizeof( aof_reloc ) );
                relocposn = areaoutposn + lastoutarea->areasiz;
            }
        }
#ifdef LINKING_ON_ACORN_RISC_OS
                for (__link = aep->area__link_list; __link; __link = __link->chain) {
                    sy = __link->sy;
                    assert(sy->area == aep);
                    cp = area + (sy->value - aep->base);
                    if (__link->next)
                        *(int *)cp = __link->next->sy->value;
                    /* /* FIXME - Reloc code for __link */
                }
                if ((sy = g__head_sym) && aep == sy->area) {
                    cp = area + (sy->value - aep->base);
                    __link = g__link_list;
                    if (__link)
                        *(int *)cp = __link->sy->value;
                }
#endif

        siz = aep->relocs * sizeof(aof_reloc);
        reloc = (aof_reloc *) map(aep->relocoff, siz);
        for (r = reloc, rend = reloc + aep->relocs; r<rend; r++)
        {   roffset = hv(r->rel_offset);
            rflags = hv(r->rel_flags);
            cp = area + roffset;
            if (roffset >= areasiz) msg(fatal_badobj(aep->oep->fep->fname));
            max_ins = -1;
            if (rel_type2(rflags))
            {   symno =  rel2_sid(rflags);
                len   =  rel2_FT(rflags);
                pcrel =  rel2_R(rflags);
                addsym = rel2_A(rflags);
                if (aep->flags & NOINSTRELOC)
                {   /* AOF vsn < 310 - do this for compatibility with */
                    /* Acorn's C release 3 and C release 4.           */
                    if (pcrel) len = 3;
                }
                else
                    /* version 310 or later... */
                    max_ins = rel2_ins(rflags);
                rflags &= (REL_TYPE2 | REL_B);
            }
            else
            {   /* olde style => pre vsn 310... max_ins = -1 */
                symno =  rel1_sid(rflags);
                len   =  rel1_FT(rflags);
                pcrel =  rel1_R(rflags);
                if (pcrel) len = 3;
                addsym = rel1_A(rflags);
                if (pcrel) addsym = 1;
                if (!addsym) symno = aep->areano;
                rflags = 0;
            }
            if (shl_flag && aep->overseg != &root &&
                !pcrel && (rflags & REL_B) == 0)
                msg(err_positiondependentreloc(roffset, aep->oep->oname,  aep->name));
            switch (len)
            {
            case 0:
                v = *cp;
                break;
            case 1:
                v = xvs((int32)(*(short *)cp));
                break;
            case 2:
                v = hv(*(int32 *)cp);
                break;
            case 3:
                v = instr_offset((int32 *)cp, max_ins);
                if (v == -1)
                {   msg(err_instreloc(hv(*(int32 *)cp), roffset, aep->oep->oname, aep->name));
                    v = 0;
                }
                break;
            }
            savreloc = 1;
            psave = 1;
if (verboseflag >= 3)
{   fprintf(stderr, "rel: off=0x%lx, A=%u, R=%u, len=%u, B=%u, symno=%lu\n",
    roffset, addsym, pcrel, len, (rflags & REL_B) != 0, symno);
}
            if (addsym)
            {   struct hentry *h = aep->oep->numtosym[symno];
                gs = h->h_un.globval;
                sy = &(gs->symval);
                if (sy->flags & SYM_WEAKAT) savreloc = 0;
                rel_wrt_area = NULL;
                symno = sy->symno;
                if (sy->flags & SYM_DEFAT)
                {   /* the symbol is defined... */
                    if ((sy->flags & (SYM_EFTSYM+SYM_DATAAT))==SYM_EFTSYM &&
                        aep->overseg == &root &&
                        sy->area != NULL &&
                        sy->area->attrs & AOF_CODEAT)
                    {
/* It's an EFTSYM symbol and not a code-area datum, and the area being */
/* relocated is in the stub, not the library, and and the symbol is    */
/* defined in a code area, so it needs an inter-LU entry veneer...     */
                        if (len == 3)
                            rel_wrt_area = inter_LU_code;
                        else
                            rel_wrt_area = inter_LU_data;
                    }
                    else
                        rel_wrt_area = sy->area;
                    if (gs->pcit_entry >= 0 &&
                        !(pcrel && sy->area->overseg == aep->overseg))
                    {
                        if (sy->flags & SYM_EFTSYM)
                            v += eft_entry(gs->pcit_entry, len);
                        else
                            v += overseg_entry(gs->pcit_entry, sy);
                    }
                    else
                        v += sy->value;
                    if ((sy->flags & SYM_ABSAT) ||
                        pcrel && rel_wrt_area->h == aep->h)
                    {   /* absolute or pc-rel within area group, so */
                        /* no relocation directive saved in output. */
                        psave = 0;
                        if (!(sy->flags & SYM_LINKSYM))
                            savreloc = 0;
                        if (pcrel && plinkflag && (sy->flags & SYM_ABSAT))
                            msg(err_pcrelabs(h->name + 2));
                        if (len == 3 &&
                           (rflags & REL_B) &&
                           !(sy->flags & SYM_LEAFAT))
                        /* Reentrant tail-call to a non-leaf fn... */
                        /* ... enters at inter-LU entry point...   */
                            v += 4L;
                    }
                    else if (plinkflag && aep->overseg == &root ||
                             (rflags & REL_B) && !pcrel)
                    {   /* symbol-relative -> area-base-relative... */
                        if (rel_wrt_area != NULL)
                        {   if (rel_wrt_area->flags & UNHASHED)
                            {   v -= rel_wrt_area->base;
            /* Reference to eliminated stub data from another stub, */
            /* re-written as a reference to stubArea$$Base.         */
                                symno =
                                    rel_wrt_area->h->h_un.globval->symval.symno;
                            }
                            else
                            {   v -= rel_wrt_area->h->h_un.areaval->base;
                                addsym = 0;
                                symno = rel_wrt_area->h->h_un.areaval->areano;
                            }
                        }
                        else
                        {   psave = savreloc = 0;
                            msg(err_lost_reloc(h->name+2, roffset,
                                aep->oep->oname, aep->name));
                        }
                    }
                }
            }
            else /* area-base-relative relocation */
            {   rel_wrt_area = aep->oep->arealist[symno];
                if (pcrel && rel_wrt_area->h == aep->h)
                    /* pc-relative reloc within area group */
                    psave = 0;
                else
                {   v += rel_wrt_area->base;
                    if (plinkflag && aep->overseg == &root ||
                        (rflags & REL_B))
                    {   if (rel_wrt_area->flags & UNHASHED)
                        {   addsym = 1;
            /* Reference to eliminated stub data from another stub, */
            /* re-written as a reference to stubArea$$Base.         */
                            symno = rel_wrt_area->h->h_un.globval->symval.symno;
                        }
                        else
                        {   v -= rel_wrt_area->h->h_un.areaval->base;
                            symno = rel_wrt_area->h->h_un.areaval->areano;
                        }
                    }
                }
            }
            if (shl_flag && aep->overseg != &root) psave = 0;
            if (scatterflag == OVERLAY &&
                rel_wrt_area != NULL &&
                !(rel_wrt_area->attrs & AOF_CODEAT) &&
                rel_wrt_area->overseg != &root &&
                rel_wrt_area->overseg != aep->overseg)
            {
                if (aep->overseg->level == rel_wrt_area->overseg->level)
                {   if (!havecomplained)
                    {   msg(err_noncores(aep->oep->oname, aep->name));
                        havecomplained = 1;
                    }
                }
                else if (!havewarned && !havecomplained)
                {   msg(warn_noncores(aep->oep->oname, aep->name));
                    havewarned = 1;
                }
            }
            if (pcrel)
            {   if ((rflags & REL_TYPE2) == 0) v -= roffset + 8;
                v -= aep->base;
                if (plinkflag && psave) v += aep->h->h_un.areaval->base;
            }
            switch (len)
            {
            case 0:
                savreloc = 0;
                *cp = (char) v;
                break;
            case 1:
                savreloc = 0;
                *(short *)cp = (short) xvs(v);
                break;
            case 2:
                if (scatterflag && rel_wrt_area != NULL)
                {   if (aep->overseg == &root)
                        savreloc = 0x80000000;
                    else if (rel_wrt_area->overseg == &root)
                    {   savreloc = 0x10000000;
            /* if the overlay is relocatable, link this segment */
            /* as if the root were loaded at 0.                 */
                        if (relocflag) v -= base;
                    }
                    else if (rel_wrt_area->overseg == aep->overseg)
                        savreloc = 0x20000000;
                }
                *(long *)cp = tv(v);
                break;
            case 3:
                if (pcrel)
                {   if (aep->overseg == &root)
                        savreloc = 0;
                    else
                    {   savreloc = 0x30000000;
            /* if the overlay is relocatable, link this segment */
            /* as if the root were loaded at 0.                 */
                        if (relocflag) v -= base;
                    }
                }
                if (instr_reloc((int32 *)cp, v, max_ins) != 0)
                    msg(info_ireloc(roffset, aep->oep->oname, aep->name, v));
                break;
            }
            if ((relocflag || moduleflag) &&
                savreloc && output_type != AOUT)
            {
                writereloc(areaoutposn + roffset + (savreloc & 0x70000000),
			   !(aep->attrs & AOF_RONLYAT) && /* from RW area */
			   rel_wrt_area && /* relative to some area */
			   !(rel_wrt_area->attrs & AOF_RONLYAT)); /* which is also RW */
            }
            if (plinkflag && psave && output_type != AOUT)
            {   aep->h->h_un.areaval->relocs++;
                rflags |= symno + REL_TYPE2 + (int32)len*REL_SHORT;
                if (pcrel)  rflags |= REL_R;
                if (addsym) rflags |= REL_A;
                writeaofreloc(aep->h->h_un.areaval->areaoff+roffset, rflags);
            }
        }
#endif /* TARGET_HAS_AOF */
    }
    if (output_type == AOUT && !plinkflag)
    {   if (aep->flags & SHFLAG)
        {   if (aep->attrs & AOF_RONLYAT)
                writebytes(0x8000, area, aep->areasiz);
        }
        else
            writebytes(aep->base - textoffset, area, aep->areasiz);
    }
    else
    {   if (aep->areapad > 0)
        {   char zeroes[64];
            int32 padding, count;
            memset(zeroes, 0, sizeof(zeroes));
            for (padding = aep->areapad;  padding > 0;  padding -= count)
            {   if (padding > sizeof(zeroes))
                    count = sizeof(zeroes);
                else
                    count = padding;
                writebytes(areaoutposn, zeroes, count);
                areaoutposn = fout.currentpos;
            }
        }
        writebytes(areaoutposn, area, aep->areasiz);
        areaoutposn = fout.currentpos;
    }
    aep->h->h_un.areaval->areaoff += aep->areasiz + aep->areapad;

    pop_stack();
}

#ifdef TARGET_HAS_AOF

static char *writeoutstr(char *st, char *s)
{   while ((*st++ = *s++) != 0);
    return st;
}

#endif /* TARGET_HAS_AOF */


static void write_symt(void)
{
    struct hentry *h;
    struct globsym *gs;
    int32 at, textareanameidx, dataareanameidx, bssareanameidx, dbgareanameidx;
    char *strtp, *cp, *outstrt;

    dbgareanameidx = 0;
    bssareanameidx = 0;
    dataareanameidx = 0;
    textareanameidx = 0;
    outstrt = strtp = NULL;

    if (output_type == AOUT) {
#ifdef TARGET_HAS_AOUT
        struct nlist *symtp, *outsymt;
        int nt;

        symtp=outsymt=(struct nlist *)
                            salloc(symcount * sizeof(struct nlist));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = strtsize;
        strtp += sizeof(int32);
        if (debugflag) {
            struct oentry *oep;
            int32 toff, doff, boff, nsyms;
            struct nlist *symt, *symtend;
            char   *strt;
            struct aentry *code, *data, *bss;

            oep = objectlist;
            while (oep) {
                if (oep->fep->type & AOUT_MASK) {
                    setobject(oep);
                    code = oep->arealist[CODE_AREA];
                    data = oep->arealist[DATA_AREA];
                    bss = oep->arealist[BSS_AREA];
                    symtp->n_un.n_strx = strtp - outstrt;
                    symtp->n_type = N_TEXT;
                    symtp->n_value = code->base;
                    cp = oep->oname;
                    while ((*strtp++ = *cp++) != 0);
                    symtp++;
                    nsyms = map_aoutsymt(oep->o_un.aouthdr, &toff,
                                                &doff, &boff, &symt, &strt);
                    for (symtend = symt + nsyms; symt < symtend; symt++)
                        if (!(symt->n_type & N_EXT)) {
                            if (symt->n_un.n_strx) {
                                cp = strt + symt->n_un.n_strx;
                                if (*cp == 'L')
                                    continue;
                                symt->n_un.n_strx = strtp - outstrt;
                                while ((*strtp++ = *cp++) != 0);
                            }
                            switch ((symt->n_type & N_TYPE) >> 1) {
                            case N_TEXT >> 1:
                                symt->n_value += code->base - toff;
                                break;
                            case N_DATA >> 1:
                                symt->n_value += data->base - doff;
                                break;
                            case N_BSS >> 1:
                                symt->n_value += bss->base - boff;
                                break;
                            }
                            *symtp++ = *symt;
                        }
                }
                oep = oep->next;
            }
        }
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if (!(gs->symval.flags & SYM_DEFAT))
                nt = N_UNDF;
            else if (gs->symval.area == NULL)
                nt = N_ABS;
            else if (gs->symval.area->flags & UNUSEDAREA)
                continue;
            else if ((at = gs->symval.area->attrs) & AOF_0INITAT)
                nt = N_BSS;
            else if (at & AOF_RONLYAT)
                nt = N_TEXT;
            else
                nt = N_DATA;
            if ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT)
                nt |= N_EXT;
            symtp->n_un.n_strx = strtp - outstrt;
            symtp->n_value = gs->symval.value;
            symtp->n_desc = gs->symval.dbxinfo;
            symtp->n_type = nt;
            cp = h->name + 2;
#ifdef USE_PSTRING_SYMBOLS
            *strtp++ = strlen(cp);
#endif
            strtp = writeoutstr(strtp, cp);
            symtp++;
        }
        writebytes(sposn, (char *)outsymt, symcount*sizeof(struct nlist));
#endif /* TARGET has AOUT */
    }
    else if (output_type == AIF)
    {
#ifdef TARGET_HAS_AOF
        ItemSection sect;
        ItemSymbol *symtp, *outsymt;
        unsigned32 f;

        memset((char *)&sect, 0, sizeof(ItemSection));
        sect.id = tv(asd_codeword(ITEMSECTION, (int32)sizeof(ItemSection)));
        sect.lang = LANG_NONE;
        sect.asdversion = 2;
        sect.codestart = tv(root.torigin);
        sect.datastart = tv(root.dorigin);
        sect.codesize  = tv(root.textsize);
        sect.datasize  = tv(root.datasize);
        sect.debugsize = tv(sizeof(ItemSection) +
                            symcount * sizeof(ItemSymbol) + strtsize);
        sect.n.nsyms = tv(symcount);
        writebytes(sposn - sizeof(ItemSection), (char *) &sect,
                                  sizeof(ItemSection));
        symtp = outsymt = (ItemSymbol *) salloc(symcount * sizeof(ItemSymbol));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = tv(strtsize);
        strtp += sizeof(int32);
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if (gs->symval.area == NULL)
                /* AOF_ABSAT => symval.area == NULL, but not conversely  */
                /* (but it's a convenient way to recover from previously */
                /*  diagnosed errors and symbols in unused/empty areas.  */
                f = ASD_ABSSYM;
            else if (gs->symval.area->flags & UNUSEDAREA)
                continue;
            else if ((at = gs->symval.area->attrs) & AOF_0INITAT)
                f = ASD_ZINITSYM;
            else if (at & AOF_RONLYAT)
                f = ASD_TEXTSYM;
            else
                f = ASD_DATASYM;
            if ((gs->symval.flags & SYM_REFDEFMASK) != SYM_LOCALDEFAT)
                f |= ASD_GLOBSYM;
            symtp->sym = tv(f + (strtp - outstrt));
            symtp->value = tv(gs->symval.value);
            cp = h->name + 2;
#ifdef USE_PSTRING_SYMBOLS
            *strtp++ = strlen(cp);
#endif
            strtp = writeoutstr(strtp, cp);
            symtp++;
        }
        if (symcount)
            writebytes(sposn, (char *) outsymt,
                                    symcount * sizeof(ItemSymbol));
    }
    else /* output_type == AOF (methinks) */
    {   aof_symbol *symtp, *outsymt;
        struct aentry *aep;
        int32 i;

        symtp = outsymt = (aof_symbol *) salloc(symcount*sizeof(aof_symbol));
        strtp = outstrt = (char *) salloc(strtsize);
        *(int32 *) strtp = tv(strtsize);
        strtp += sizeof(int32);
        if (plinkflag)
            for (i = 0; i < root.noofoutareas; i++)
            {   cp = root.outareas[i]->h->name;
                root.outareas[i]->areaoff = strtp - outstrt;
                strtp = writeoutstr(strtp, cp);
            }
        else
        {   if (root.textsize)
            {   textareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RO");
            }
            if (root.datasize)
            {   dataareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RW");
            }
            if (root.bsssize)
            {   bssareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$ZI");
            }
            if (debugflag)
            {   dbgareanameidx = strtp - outstrt;
                strtp = writeoutstr(strtp, "Image$$RW0");
            }
        }
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   int32 v, attrs;
            gs = h->h_un.globval;
            /* WARNING: changes to following expression must be duplicated
               in function middle() where symcount is incremented! */
            if (plinkflag && !debugflag &&
                (gs->symval.flags & SYM_REFDEFMASK) == SYM_LOCALDEFAT ||
                shl_flag &&
                (gs->symval.flags & (SYM_EFTSYM+SYM_LINKSYM)) == 0)
                    continue; /* don't output symbol */

            symtp->sym_name = tv(strtp - outstrt);
            if ((gs->symval.flags & SYM_EFTSYM) && (i = gs->pcit_entry) >= 0)
            {   aep = inter_LU_code;
                v = i * inter_LU_code_stride + aep->base;
            }
            else
            {   v = gs->symval.value;
                aep = gs->symval.area;
            }
            symtp->sym_value = tv(v);
            v = gs->symval.flags & ~SYM_LINKFLAGS;
            if (!plinkflag || aep == NULL)
                /* AOF image at absolute address or recovery from previous */
                /* error, or symbol defined in unreferenced/empty area...  */
                v |= SYM_ABSAT;
            symtp->sym_AT = tv(v);
            symtp->sym_areaname = 0;
            if (aep != NULL)
            {   attrs = hv(symtp->sym_AT);
                if (plinkflag)
                {   v = hv(symtp->sym_value);
                    v -= aep->h->h_un.areaval->base;
                    symtp->sym_value = tv(v);
                    v = aep->h->h_un.areaval->areaoff;
                }
                else if (aep->flags & UNUSEDAREA)
                    continue;
                else if (attrs & AOF_CODEAT)
                    v = textareanameidx;
                else if (attrs & AOF_DEBUGAT)
                    v = dbgareanameidx;
                else if (attrs & AOF_0INITAT)
                    v = bssareanameidx;
                else
                    v = dataareanameidx;
                symtp->sym_areaname = tv(v);
            }
            strtp = writeoutstr(strtp, h->name + 2);
            symtp++;
        }
        if (symcount)
            writebytes(sposn,(char *)outsymt,symcount*sizeof(aof_symbol));
#endif /* TARGET_HAS_AOF */
    }
    while ((strtp - outstrt) < strtsize) *strtp++= 0;
    if (strtsize > 4L) writebytes(strposn, outstrt, strtsize);
}

static void intellec_write_symt(void)
{   struct hentry *h;
    struct globsym *gs;
    char buf[80];

    for (h = firstglobsym;  h != NULL; )
    {   gs = h->h_un.globval;
        sprintf(buf, "#* %.8lx %.64s\n", gs->symval.value, h->name+2);
        writedirect( buf, strlen(buf));
        h = gs->next;
    }
}

#ifdef TARGET_HAS_AOF

static void write_root_pcit_section(struct oventry *ov)
{   struct pcit_section psect;
    struct oventry *ov2;
    int32 t;
    int i, l;
    char *cp;

    psect.br = tv(AIF_BLAL | (((load_seg_and_go->h_un.globval->symval.value -
        (ov->pcit_base + ov->entryv * 4 + 12)) >> 2) & 0xffffff));
    psect.vecsize = tv(ov->entryv * 4);
    psect.base = tv(ov->base);
    psect.limit = tv(ov->limit);
    l = strlen(ov->name);
    cp = ov->name;
    i = 0;
    while ((l = *cp++) != 0) {
        psect.name[i] = l;
        i++;
        if (l == PATHSEP[0]) i = 0;
    }
    while (i < 12) psect.name[i++] = 0;
    psect.clashsize = tv(ov->level->clash * 4);
    writebytes(fout.currentpos, (char *) &psect, sizeof(struct pcit_section));

    for (ov2 = ov->level->seg_list;  ov2 != NULL;  ov2 = ov2->next)
    {   if (ov2 == ov) continue;
        if (relocflag || (qflag & NEW_OVERMGR))
            /* use offset to clashing PCIT segment */
            t = ov2->pcit_base - ov->pcit_base + (ov2->entryv - ov->entryv)* 4;
        else
            /* use address of clashing PCIT segment */
            t = ov2->pcit_base + ov2->entryv * 4 + 8;
        t = tv(t);
        writebytes(fout.currentpos, (char *) &t, 4);
    }
}

static void write_root_pcit(void)
{
    struct lventry *lv;
    struct oventry *ov;
    int32 entryv, strlr = tv(STRLR);

    for (lv = root.level_list;  lv != NULL;  lv = lv->next)
    {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
        {   entryv = ov->entryv;
            while (entryv-- >= 0)
                writebytes(fout.currentpos, (char *) &strlr, 4);
            write_root_pcit_section(ov);
        }
    }
}

static void write_segment_pcit(struct oventry *ov)
{   struct hentry *h;
    struct globsym *gs;
    int32 entryvbase;
    int32 t;

    entryvbase = ov->pcit_base + 12;  /* 4 for 1st STRLR, 8 for ARM branch */
    for (h = firstglobsym;  h != NULL;  h = gs->next)
    {   gs = h->h_un.globval;
        if (gs->pcit_entry < 0 || gs->symval.area->overseg != ov) continue;
        /* PCIT branches always branch forwards, but don't rely on it */
        t = gs->symval.value - entryvbase;
        entryvbase += 4;
        if (relocflag)
        {    writereloc(fout.currentpos + 0x70000000, 0);
             /* link as if root of relocatable overlay system */
             /* were linked at 0 */
             t += base;
        }
        t = tv(0xea000000 | ((t >> 2) & 0xffffff));
        writebytes(fout.currentpos, (char *) &t, 4);
    }
}

#endif /* TARGET_HAS_AOF */

static void write_eft(struct oventry *ov)
{   struct hentry *h;
    struct globsym *gs;
    int32 t, *eft, entry_point, eftsz;

    eftsz = tv(eft_size);
    writebytes(fout.currentpos, (char *) &eftsz, 4);
    if (verboseflag)
    {   msg(info_EFTPBlock(paramBlkUsed));
        msg(info_EFTSize(eft_size));
    }
    if (eft_size != 0)
    {   mark_stack();
        eft = (int32 *) salloc(eft_size * sizeof(int32));
        for (h = firstglobsym;  h != NULL;  h = gs->next)
        {   gs = h->h_un.globval;
            if ((gs->symval.flags & SYM_EFTSYM) && ((t = gs->pcit_entry) >= 0))
            {   entry_point = gs->symval.value - (ov->limit - ov->base);
                /* Non-leaf functions have inter-LU entry at symbol+4 */
                if (!(gs->symval.flags & SYM_LEAFAT)) entry_point += 4;
                eft[t] = tv(entry_point);
                if (verboseflag)
                    msg(info_EFTEntry(t, entry_point, h->name));
            }
        }
        writebytes(fout.currentpos, (char *)eft, eft_size*sizeof(int32));
        pop_stack();
    }
    if (libdataflag)
    {    /* Write out size of SHL data area followed by the offset of it */
        int32 x = tv(shl_datasz->h_un.globval->symval.value);
        writebytes(fout.currentpos, (char *) &x, 4);
        x = tv(shl_database->h_un.globval->symval.value);
        writebytes(fout.currentpos, (char *) &x, 4);
    }
    /* and finally write out the parameter block */
    writebytes(fout.currentpos, paramBlk, paramBlkUsed);
}

static FILE *reopen_outfile(char *fname, char *ext, FILE *f)
{   char *fn = fname;
    if (f != NULL) fclose(f);
    if (ext != NULL && *ext != 0 && splitflag &&
        (intellecflag || binaryflag == BIN_NOHDR))
    {   int len = strlen(fname) + strlen(ext) + 1;
        fn = (char *) halloc(len);
        strcpy(fn, fname);
        strcat(fn, ext);
#ifdef LINKING_ON_RISCOS
        /* Assert: strlen(ext) > 0 ... */
        fn[strlen(fname)] = '/';
#endif
    }
    outf = fn;
    f = fopen(fn, intellecflag ? "w" : "wb");
    if (f == NULL ) msg(fatal_openerr(fn));
    return f;
}

static void write_intellec_header(char *segment_type, int32 base)
{   char outrec[80];
    time_t now;
    sprintf(outrec, "# Created by %s [%s]\n", IDFNSTR, __DATE__);
    writedirect( outrec, strlen(outrec));
    time(&now);
    sprintf(outrec, "#         on %s", ctime(&now));
    writedirect( outrec, strlen(outrec));
    sprintf(outrec, "# %s segment based at 0x%lx\n\n", segment_type, base);
    writedirect( outrec, strlen(outrec));
}

static void put_image_segment(struct oventry *ov)
{   struct aentry *aep;
    struct aentry **area, **areasend;

    if (!plinkflag)
    {   /* Create the <area>$$Base and $$Limit symbols */
        char tmpname[MAXSYMLEN];
        int tlen;
        strcpy(tmpname, "!!");
        for (aep = ov->outarealist;  aep != NULL;  aep = aep->nxt)
        {   struct hentry *h;
            bufcpy(tmpname+2, aep->h->name, sizeof(tmpname)-2);
            tlen = strlen(tmpname);
            bufcpy(tmpname+tlen, "$$Base", sizeof(tmpname)-tlen);
            h = lookup(tmpname, &globhashtable);
            if (h != NULL && aep->base < h->h_un.globval->symval.value)
                h->h_un.globval->symval.value = aep->base;
            bufcpy(tmpname+tlen, "$$Limit", sizeof(tmpname)-tlen);
            h = lookup(tmpname, &globhashtable);
            if (h != NULL &&
                (aep->base + aep->areasiz) > h->h_un.globval->symval.value)
                h->h_un.globval->symval.value = aep->base + aep->areasiz;
        }
    }

    mark_stack();

    fout.handle = reopen_outfile(ov->name, ro_ext, NULL);
    fout.currentpos = areaoutposn = 0;

    write_header(ov);
    if (intellecflag) write_intellec_header("RO", base);

    /* aofreloclist is reset here, but is also reset within load2 */
    listinit( &aofreloclist, sizeof( aof_reloc ) );

    /* these lists are initialised here, as they are on per-image basis */
    listinit( &reloclist, sizeof( int32 ) );
#ifdef TARGET_HAS_AOUT
    listinit( &aoutreloclist, sizeof( struct relocation_info ) );
#endif

again_for_shl_liby_chunk:
    if (ov != &root)
        relocposn = ov->textsize + ov->datasize + ov->bsssize;
    for (area = ov->arealist, areasend = area + ov->noofareas;
        area < areasend; area++)
    {   aep = *area;
        if (scatterflag && (aep->attrs & AOF_DEBUGAT)) continue;
        if (splitflag && (intellecflag || binaryflag == BIN_NOHDR) &&
            ov->dorigin == aep->base && aep->areasiz > 0 &&
            (aep->attrs & AOF_RONLYAT) == 0)
        {
            fout.handle = reopen_outfile(ov->name, rw_ext, fout.handle);
            areaoutposn = fout.currentpos = 0;
            if (intellecflag)
            {   write_intellec_header("RW", data_base);
                intellec_base = 0;
            }
        }
        load2(aep);
    }

#ifdef TARGET_HAS_AOF
    if (scatterflag == OVERLAY)
    {   if (ov == &root)
        {   int32 offset = fout.currentpos;
            write_root_pcit();
            areaoutposn = fout.currentpos;
            offset = fout.currentpos - offset;
            for (area = ov->arealist, areasend = area+ov->noofareas;
                area < areasend;  area++)
            {   aep = *area;
                if (!(aep->attrs & AOF_DEBUGAT)) continue;
                aep->base += offset;
                load2(aep);
            }
        }
        else
            write_segment_pcit(ov);
    }
#endif
    writereloclist( &aofreloclist ); /* IJR: this may be redundant..? */

    if (binaryflag == BIN_NOHDR)
    {   char zeroes[64];
        int32 n = ov->bsssize;
        memset(zeroes, 0, sizeof(zeroes));
        while (n > sizeof(zeroes))
        {   writebytes(fout.currentpos, zeroes, (int32)sizeof(zeroes));
            n -= sizeof(zeroes);
        }
        writebytes(fout.currentpos, zeroes, n);
    }

    /* fix_up_header() moved to end for io efficiency (IJR) */
    if (plinkflag && (ov == &root)) fix_up_globals();

    if (intellecflag)
    {  /* flushout(&o1); */
        writedirect( ":00 0000 01 FF\n\n", 16);
        if (debugflag) intellec_write_symt();
    }
    else if ((debugflag || plinkflag) && ov == &root)
    {   write_symt();
        if (shl_flag == 2)
        {   int32 n = fout.currentpos & 3L;
            ov = root.level_list->seg_list;
            root.level_list = NULL;
            if (n != 0) writebytes(fout.currentpos, "\0\0\0", 4L - n);
            areaoutposn = fout.currentpos;
            n = ov->textsize + (eft_size+1)*sizeof(int32) + paramBlkUsed;
            cfouthdr->cf_chunks[shl_chunk].cfe_size = tv(n);
            goto again_for_shl_liby_chunk;
        }
    }
    else if (shl_flag && ov != &root)
    {   write_eft(ov);
        if (shl_flag == 2) ov = &root;
    }

#ifdef TARGET_HAS_AOF
    if( relocflag )
    {   if (ov == &root)
        {   /* write aif relocation code */
            ensure_byte_order(aif_reloc_code, aif_reloc_code_size);
            writebytes(srcposn, (char *)aif_reloc_code, aif_reloc_code_size);
        }
        /* write aif relocation list next */
        writereloclist( &reloclist );
        /* write relocation terminator (-1) directly */
        writeaifrelocdirect( -1 );
    }

    if (moduleflag)
    {
        /* write amf module code */
        int sz = amf_reloc_code_size;
        unsigned32 *p = amf_reloc_code;
        p += sz/sizeof(unsigned32);
        p[-2] = tv(srcposn + base);
        p[-1] = tv(base);

	/* RMJ: if we just write this out, the relocation code itself
	/  won't have its endianness properly twiddled.  Therefore
	/  twiddle it manually as we go. */

	/* writebytes(srcposn, (char *)amf_reloc_code, sz); */
	{
	    int n;
	    int32 posn = srcposn;
	    unsigned32 *q = amf_reloc_code;
	    unsigned32 w;

	    for (n = sz/sizeof(unsigned32) - 2; n > 0; n--, q++)
	    {
		w = tv(*q);
		writebytes(posn, (char *)&w, sizeof(unsigned32));
		posn += sizeof(unsigned32);
	    }
	    writebytes(posn, (char *)(p-2), 2*sizeof(unsigned32));
	}

        writereloclist( &reloclist );
        /* ijr no need to stack these (inc -1) - just write out direct */
        writeaifrelocdirect( srcposn + sz - 8 );
        writeaifrelocdirect( srcposn + sz - 4 );
        /* write relocation terminator (-1) directly */
        writeaifrelocdirect( -1 );
    }
#endif
#ifdef TARGET_HAS_AOUT
    writereloclist( &aoutreloclist );
#endif
#ifdef DEBUG
    printf("reloc_count=%ld, popped=%ld\n", reloc_count, popped );
#endif

    /* do this last (involves a seek back to the start of the file) */
    if (plinkflag && ov == &root) fix_up_header();

#ifdef TARGET_HAS_AOUT
    if (output_type == AOUT && !plinkflag && !debugflag)
    {   char zero = 0;
        /* ZMAGIC paged image... broken now that bwrite has gone. */
#ifdef LINKING_ON_UNIX

        bwrite((fout.currentpos + (pagesize-1)) & ~(pagesize-1), &zero, 1, 0);
        ftruncate(outfd, (fout.currentpos + (pagesize-1)) & ~(pagesize-1), 0);
#else
        if ((fout.currentpos & (int32)(size_t)(pagesize - 1)) != 0)
            bwrite(((fout.currentpos + (int32)(size_t)(pagesize - 1)) &
                    ~(int32)(size_t)(pagesize - 1)) - 1, &zero, 1, 0);
#endif
    }
#endif /* TARGET_HAS_AOUT */

    closeout(ov);
    pop_stack();
}

#ifdef SHL_IS_AOF_AREA
/*
 * LDS 01-Sep-93.
 * We probably don't ever want this option. If we do, then we have to modify
 * writebytes() to write into a buffer allocated here. This must also collude
 * with put_image_segment(). Although the result is less contorted than
 * writing a separate chunk, it is also much less useful.
 */
static void add_shl_library_area(void)
{   struct aentry *a, **p;
    struct oventry *ov = root.level_list->seg_list;
    char *anon = msgtext(misc_anon);
    struct fentry *fep;
    struct oentry *oep;

    root.level_list = NULL;
    a = (struct aentry *)
        halloc((int32)(size_t)(sizeof(struct aentry)+strlen(shl_name)+5));
    a->areano = root.noofoutareas++;
    root.outareas[a->areano] = a;
    a->areaoff = 0;
    a->areasiz = ov->textsize + (eft_size+1L)*sizeof(int32) + paramBlkUsed;
    a->areapad = 0;
    a->relocoff = 0;
    a->relocs = 0;
    a->attrs = AOF_CODEAT + AOF_RONLYAT + AOF_PICAT + AOF_REENTAT;
    a->oep = NULL;
    a->areaidx = 0;
    a->flags = 0;
    a->refs = NULL;
    a->overseg = NULL;
    a->nxt = NULL;
    strcpy(a->name, shl_name);
    strcpy(a->name + strlen(shl_name), "$$shl");
    a->areaval = (char *) halloc(a->areasiz);

    fep = (struct fentry *)
            halloc((int32)sizeof(struct fentry) + strlen(anon));
    strcpy(fep->fname, anon);
    fep->size = a->areasiz;
    fep->filebuffer = a->areaval;

    oep = (struct oentry *) halloc((int32)sizeof(struct oentry));
    oep->oname = fep->fname;
    oep->fep = fep;
    oep->size = fep->size;
    oep->arealist = NULL;        /* not needed */

    put_image_segment(ov);

    for (p = &ov->outarealist;  *p != NULL;) p = &(*p)->nxt;
    nextoutarea = p;
    hash_area(ov, a, a->name);
}
#endif

static void print_map(struct oventry *ov)
{
    struct aentry *aep, **area, **areasend;

    putchar('\n');
    printf(msgtext(misc_map_hdr), ov->name);
    for (area = ov->arealist, areasend = area + ov->noofareas;
        area < areasend;  ++area)
    {   aep = *area;
        if (aep->areasiz > 0)
        {   int32 baseval = aep->base;
            if (moduleflag) baseval -= base;
            printf("%-8lx %-8lx ", baseval, aep->areasiz);
            if (aep->attrs & AOF_CODEAT)
                printf("CODE    ");
            else if (aep->attrs & AOF_0INITAT)
                printf("ZERO    ");
            else if (aep->attrs & AOF_DEBUGAT)
                printf("DEBUG   ");
            else
                printf("DATA    ");
            printf(" %s", aep->name);
            if (aep->oep)
                printf(msgtext(misc_map_fromfile), aep->oep->oname);
            putchar('\n');
        }
    }
}


static struct fentry **addfile(struct fentry **next, char *fname, int lflag)
{
    struct fentry *fep;
    char *buffer;
    FILE *fp;

    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   if (CiStrEQ(fname, fep->fname))
        {   msg(warn_dupfname(fname));
            return next;
        }
    }
    fep = (struct fentry *)
        halloc((int32)(size_t)(sizeof(struct fentry) + strlen(fname)));
    *next = fep;
    strcpy(fep->fname, fname);
    fep->fd = -1;
    fep->next = NULL;
    /* IJR: temporary fopen/fclose here until raw reads have been expunged */
    fp = fopen(fep->fname, "rb");
    if (fp == NULL)
        msg(fatal_notfound(fep->fname));
    fseek(fp, 0L, SEEK_END);
    fep->size = ftell(fp);
    fclose(fp);
    fep->filebuffer = NULL;
    fep->type = filetype(fep);
    fep->lflag = lflag;
    if (lflag)
    {   if (fep->type & (OBJECT_MASK | AOUT_MASK))
            msg(fatal_badqual(fname));
        else
            msg(warn_libqual(fname));
    }
    if (fep->type != AR)
    {   if (ALLOCABLE(fep->size) && (buffer = cache_alloc(fep->size)) != NULL)
        {   fep->filebuffer = readfile(buffer, 0, fep->size);
#ifdef DEBUG_MEM
            fprintf(stderr, "stacked %s, size = %ld\n", fname, fep->size);
#endif
            closefile(fep);
        }
        else if (ALLOCABLE(fep->size))
        {
#ifdef DEBUG_MEM
            fprintf(stderr, "failed to stack %s, size = %ld\n",fname,fep->size);
#endif
            failedtostack = 1;
        }
    }
    return &(fep->next);
}

static void help(void)
{
    printf(msgtext(HELP_TEXT_FORMAT), SELF, IDFNSTR,  __DATE__, myname);
    fputs( msgtext( HELP_TEXT_GENERAL_1), stdout );
    fputs( msgtext( HELP_TEXT_GENERAL_2), stdout );
    fputs( msgtext( HELP_TEXT_OPTS_1  ),  stdout );
    fputs( msgtext( HELP_TEXT_OPTS_2  ),  stdout );
    fputs( msgtext( HELP_TEXT_SPECIAL_1), stdout );
    fputs( msgtext( HELP_TEXT_SPECIAL_2), stdout );
#ifdef LINKING_ON_ACORN_RISC_OS
    fputs( msgtext( HELP_TEXT_SPECIAL_3), stdout );
#endif
}

static int32 getnum(char *arg, Message_t err)
{   int32 numbase = 10, n = 0;
    int c;

    if (arg[0] == '&' || arg[0] == '0' && (arg[1] == 'x' || arg[1] == 'X'))
    {   numbase = 16;
        if (arg[0] == '&') arg += 1; else arg += 2;
    }
    while ((c = *arg++) != 0)
    {   if (isdigit(c))
            n = n * numbase + c - '0';
        else
        {   c = LOWER(c);
            if (numbase != 16 || c < 'a' || c > 'f') break;
            n = n * numbase + c - 'a' + 10;
        }
    }
    if (c == 'k' || c == 'm')
    {   n *= 1024;
        if (c == 'm') n *= 1024;
        c = *arg;
    }
    if (c) msg(err);
    return n;
}

static struct oentry **addobject(struct oentry **next,
   char *oname, struct fentry *fep, char *hdr, int32 offset, int32 size)
{
    struct oentry *oep;
    char c, *mn;

    mn = oname;
    while ((c = *oname++) != 0)
#ifdef LINKING_ON_UNIX
        if (c == '/')
#else
#  ifdef LINKING_ON_MSDOS
        if (c == '\\' || c == ':')
#  else
#    ifdef LINKING_ON_MAC
        if (c == ':')
#    else
        if (c == '.' || c == ':')
#    endif
#  endif
#endif
            mn = oname;
    oep = (struct oentry *) halloc(sizeof(struct oentry));
    *next = oep;
    oep->oname = strcpy(halloc((int32)(size_t)(strlen(mn) + 1)), mn);
    oep->fep = fep;
    oep->o_un.hdrptr = hdr; /* fixme */
    oep->offset = offset;
    oep->size = size;
    if (objectid[0]++ > 'Z')
    {   objectid[0] = '!';
        if (objectid[1]++ > 'Z')
            msg(fatal_too_many_objs(('Z'-'!'+1)*('Z'-'!'+1)));
    }
    oep->objectid[0] = objectid[0];
    oep->objectid[1] = objectid[1];
    oep->next = NULL;
    return &(oep->next);
}

typedef struct gs_list {
    struct gs_list *next;
    struct globsym *sym;
    char *name;
} gs_list;

static gs_list *notyetdef;

static void ReportNewDefineds(void)
{   gs_list **pp = &notyetdef;
    gs_list *p;

    for (; (p = *pp) != 0; )
    {   if (p->sym->symval.flags & SYM_DEFAT)
        {   msg(info_def(p->name));
            *pp = p->next;
            free(p);
        }
        else
            pp = &(p->next);
    }
}

static void ReportNewUndefineds(void)
{   struct hentry *h1;
    struct globsym *gs;
    gs_list *p;

    for (h1 = firstglobsym;  h1 != NULL;  h1 = gs->next)
    {   gs = h1->h_un.globval;
        if (gs->symval.flags & SYM_DEFAT) continue;
        for (p = notyetdef; p != 0; p = p->next) if (p->sym == gs) break;
        if (p == 0)
        {
            if (gs->symval.flags & SYM_WEAKAT)
                msg(info_weakref(h1->name + 2));
            else
                msg(info_ref(h1->name + 2));
            p = (gs_list *) malloc(sizeof(*p));
            p->next = notyetdef;
            p->sym = gs;
            p->name = h1->name+2;
            notyetdef = p;
        }
    }
}

#ifdef TARGET_HAS_AOUT

static void enter_ar_symbols(struct fentry *fep)
{
    char *strt;
    struct ranlib *symt, *symtend;

    if (strncmp(fep->f_un.arhdr->ar_name, "__.SYMDEF", 9))
        msg(fatal_nosymtab(fep->fname));
#ifdef LINKING_ON_UNIX
    {   struct stat fileinfo;
        stat(fep->fname, &fileinfo);
        if (fileinfo.st_mtime > atol(fep->f_un.arhdr->ar_date))
            msg(fatal_ood(fep->fname));
    }
#endif
    strt = map(SARMAG+sizeof(struct ar_hdr),atoi(fep->f_un.arhdr->ar_size));
    symt = (struct ranlib *) (strt + sizeof(int32));
    symtend = (struct ranlib *) (strt + *((int32 *) strt) + sizeof(int32));
    strt = ((char *) symtend) + sizeof(int32);
    while (symt < symtend)
    {        symtend--;
        enter(strt + symtend->ran_un.ran_strx,
              &libsymtable)->h_un.intval = symtend->ran_off;
    }
}

static void load_ar_lib(struct fentry *fep)
{
    char *hdr;
    int32 ofs, siz;
    struct hentry *h, *lh;
    char *mname;
    struct oentry **lastobj;

    enter_ar_symbols(fep);

    if (verboseflag)
    {   if (fep->lflag == 'a')
            msg(info_loadlib(fep->fname));
        else
            msg(lib_scanlib(fep->fname));
    }

    h = firstglobsym;
    while (h != NULL)
    {        if (!(h->h_un.globval->symval.flags & (SYM_DEFAT|SYM_WEAKAT)) &&
              h->name[0] == '!' && h->name[1] == '!' &&
              ((lh=lookup(h->name + 2, &libsymtable)) != 0))
        {
            struct ar_hdr *arhdr;
            ofs = lh->h_un.intval;
            arhdr = (struct ar_hdr *) map(ofs, sizeof(struct ar_hdr));
            {        int32 i;
                for (i = 0; i < 16; i++)
                    if (arhdr->ar_name[i] == ' ')
                        arhdr->ar_name[i] = '\0';
            }
            mname = arhdr->ar_name;
            siz = atoi(arhdr->ar_size);
            hdr = map_perm(ofs += sizeof(struct ar_hdr),
                           sizeof(struct exec));
            if (((struct exec *) (hdr))->a_magic != OMAGIC)
                hdr = map_perm(ofs + sizeof(struct exec),
                    sizeof(struct exec_header) - sizeof(struct exec));
            if (verboseflag) msg(info_loadmemb(mname, cplusplusname(h->name+2)));
            setfilesection(fep, ofs, siz);
            lastobj = nextobj;
            nextobj = addobject(nextobj, mname, fep, hdr, ofs, siz);
            load1(*lastobj);
            setfile(fep);
        }
        h = h->h_un.globval->next;
    }
}

#endif /* TARGET_HAS_AOUT */

#ifdef TARGET_HAS_AOF

static int enter_alf_symbols(struct fentry *fep)
{
    cf_entry *ce;
    lib_direntry *symt, *symtend, *d;
    lib_direntry *diry, *diryend;
    int has_old_alf_symt;

    ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
    diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
    ce = findchunk(fep->f_un.cfhdr, LIB_VRSN);
    has_old_alf_symt = (ce == NULL) ? 1 : 0;
/* (findchunk(fep->f_un.cfhdr, LIB_DATA) - fep->f_un.cfhdr->cf_chunks) - 1; */

    if (fep->lflag == 'a') return has_old_alf_symt;
    /* not library/a... */

    if (has_old_alf_symt && fep->lflag != 'l')
    {   /* old libraries are /a by default... */
        fep->lflag = 'a';
        return has_old_alf_symt;
    }

    ce = findchunk(fep->f_un.cfhdr, OFL_TIME);
    if (ce == NULL)
        msg(warn_nosymtab(fep->fname));
    else
    {   int32 *p1, *p2, t1, t2;
        p1 = (int32 *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(fep->f_un.cfhdr, LIB_TIME);
        p2 = (int32 *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        t1 = hv(p1[1]) & 0xffff;
        t2 = hv(p2[1]) & 0xffff;
        if (t2 > t1 || (t1 == t2 && hv(p2[0]) > hv(p1[0])))
            msg(warn_ood(fep->fname));
        else
        {   int32 chunkbase = has_old_alf_symt ? 1 : 0;

            ce = findchunk(fep->f_un.cfhdr, OFL_SYMT);
            symt = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
            symtend = (lib_direntry *) ((char *) symt + hv(ce->cfe_size));
            for (; symt < symtend;
                symt = (lib_direntry *) ((char *) symt +
                    hv(symt->lib_entrylength)))
            {
                if (symt->lib_chunkidx == 0) continue;
                enter(symt->lib_entry, &libsymtable)->h_un.intval =
                    hv(symt->lib_chunkidx) - chunkbase;
            }
            return has_old_alf_symt;
        }
    }

    /* library has no symt */
    for (d = diry; d < diryend;
        d = (lib_direntry *) ((char *) d + hv(d->lib_entrylength)))
    {
        cf_header *cfhdr;
        aof_header *aofhdr;
        aof_symbol *aofsymt, *syend;
        char *strt;
        int32 nsyms;

        if (d->lib_chunkidx == 0) continue;
        ce = fep->f_un.cfhdr->cf_chunks + hv(d->lib_chunkidx);
        setfilesection(fep, hv(ce->cfe_offset), hv(ce->cfe_size));
        cfhdr = (cf_header *) map(0, sizeof(cf_header));
        cfhdr = (cf_header *) map(0, sizeof(cf_header) +
            hv(cfhdr->cf_maxchunks) * sizeof(cf_entry));
        ce = findchunk(cfhdr, OBJ_HEAD);
        aofhdr = (aof_header *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(cfhdr, OBJ_SYMT);
        aofsymt = (aof_symbol *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        ce = findchunk(cfhdr, OBJ_STRT);
        strt = (char *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        nsyms = hv(aofhdr->aof_nsyms);
        for (syend = aofsymt + nsyms; aofsymt < syend; aofsymt++)
        {   if ((hv(aofsymt->sym_AT) & SYM_REFDEFMASK) !=
                                       SYM_GLOBALDEFAT) continue;
            enter(strt + hv(aofsymt->sym_name), &libsymtable)->
                h_un.intval = hv(d->lib_chunkidx);
        }
        setfile(fep);
    }
    return 0;
}

static void load_whole_alf_lib(struct fentry *fep)
{
    cf_entry *ce;
    lib_direntry *diry, *diryend;
    struct oentry **lastobj;
    char *hdr;
    int32 ofs, siz;

    ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
    diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
    diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
    for (; diry < diryend;
        diry = (lib_direntry *) ((char *) diry + hv(diry->lib_entrylength)))
    {
        if (diry->lib_chunkidx == 0) continue;
        ce = fep->f_un.cfhdr->cf_chunks + diry->lib_chunkidx;
        ofs = hv(ce->cfe_offset);
        siz = hv(ce->cfe_size);
        setfilesection(fep, ofs, siz);
        lastobj = nextobj;
        if (sectinram == NULL &&
            ALLOCABLE(siz) && (hdr = cache_alloc(siz)) != NULL)
        {   sectinram = readfile(hdr, ofs, siz);
#ifdef DEBUG_MEM
fprintf(stderr, "stacked %s, size = %ld\n", diry->lib_entry, siz);
#endif
        }
        hdr = map_perm(0, sizeof(struct cf_header));
        hdr = map_perm(0, sizeof(struct cf_header)+
            hv(((cf_header *) hdr)->cf_maxchunks)*sizeof(cf_entry));
        nextobj = addobject(nextobj, diry->lib_entry, fep, hdr, ofs, siz);
        (*lastobj)->objbuffer = sectinram;
        load1(*lastobj);
        setfile(fep);
    }
}

static void load_alf_lib(struct fentry *fep)
{
    char **mnames, *mname;
    int32 *chunkmap;
    int has_old_alf_symt;

    mnames = NULL;
    chunkmap = NULL;
    has_old_alf_symt = enter_alf_symbols(fep);

    if (fep->lflag != 'a')
    {   int32 i, maxchunks;
        cf_entry *ce;
        lib_direntry *diry, *diryend;

        maxchunks = hv(fep->f_un.cfhdr->cf_maxchunks);
        mnames = (char **) salloc(maxchunks * sizeof(char *));
        if (has_old_alf_symt)
            chunkmap = (int32 *) salloc(maxchunks * sizeof(int32));
        ce = findchunk(fep->f_un.cfhdr, LIB_DIRY);
        diry = (lib_direntry *) map_tvtv(ce->cfe_offset, ce->cfe_size);
        diryend = (lib_direntry *) ((char *) diry + hv(ce->cfe_size));
        for (i = 0;  diry < diryend;  i++,
            diry = (lib_direntry *)
                ((char *)diry + hv(diry->lib_entrylength)))
        {
            mnames[hv(diry->lib_chunkidx)] = diry->lib_entry;
            if (has_old_alf_symt) chunkmap[i] = hv(diry->lib_chunkidx);
        }
    }

    if (fep->lflag != 'a')
    {   struct oentry **lastobj;
        struct cf_entry *ce;
        struct hentry *h, *lh;
        int32 chunkindex, ofs, siz;
        char *hdr;
        int again = 1;

      while (again)
      { if (verboseflag)
        {   if (again == 2)
                msg(info_rescanlib(fep->fname));
            else
                msg(info_scanlib(fep->fname));
        }
        again = 0;
        for (h = firstglobsym;  h != NULL;  h = h->h_un.globval->next)
        {   if ((h->h_un.globval->symval.flags & SYM_SCANLIB) &&
                h->h_un.globval->symval.value == 0 &&
                h->name[0] == '!' && h->name[1] == '!' &&
                ((lh = lookup(h->name + 2, &libsymtable)) != 0))
            {
                h->h_un.globval->symval.flags &= ~SYM_SCANLIB;
                chunkindex = lh->h_un.intval;
                if (chunkmap != NULL) chunkindex = chunkmap[chunkindex];
                mname = mnames[chunkindex];
                ce = fep->f_un.cfhdr->cf_chunks + chunkindex;
                ofs = hv(ce->cfe_offset);
                siz = hv(ce->cfe_size);
                setfilesection(fep, ofs, siz);
                if (sectinram == NULL &&
                    ALLOCABLE(siz) && (hdr = cache_alloc(siz)) != NULL)
                {   sectinram = readfile(hdr, ofs, siz);
#ifdef DEBUG_MEM
fprintf(stderr, "stacked %s, size = %ld\n", mname, siz);
#endif
                }
                hdr = map_perm(0, sizeof(struct cf_header));
                hdr = map_perm(0, sizeof(struct cf_header) +
                    hv(((cf_header *) hdr)->cf_maxchunks)*sizeof(cf_entry));
                if (verboseflag) msg(info_loadmemb(mname, h->name+2));
                lastobj = nextobj;
                nextobj = addobject(nextobj, mname, fep, hdr, ofs, siz);
                (*lastobj)->objbuffer = sectinram;
                load1(*lastobj);
                if (verboseflag >= 3) {
                    ReportNewUndefineds();
                    ReportNewDefineds();
                }
                again = 2;
            }
        }
      }
    }
    else
    {   if (verboseflag) msg(info_loadlib(fep->fname));
        load_whole_alf_lib(fep);
    }
}

#endif /* TARGET_HAS_AOF */

static void load_lib(struct fentry *fep)
{   char *lock = lock_in_cache(fep->filebuffer);
    mark_stack();
    setfile(fep);
    hashinit(&libsymtable, LIBSYMTABLESIZE, salloc);
    if (fep->type == AR) {
#ifdef TARGET_HAS_AOUT
        load_ar_lib(fep);
#endif
    } else {
#ifdef TARGET_HAS_AOF
        load_alf_lib(fep);
#endif
    }
    pop_stack();
    unlock_cache_block(lock);
}

static struct aentry *find_object_area(char *obj_area_name, char *err_context)
{   char *s, *area;
    struct oentry *oep;

/* Read a name of the form object_name(area_name). The (area_name) may  */
/* be omitted if there is only one area in the object. Return a pointer */
/* to the identified area. obj_area_name MUST BE WRITABLE.              */

    area = NULL;
    for (s = obj_area_name;  *s != 0 && *s != '(';) ++s;
    if (*s == '(')
    {   *s++ = 0;
        area = s;
        while (*s != ')' && *s != '0') ++s;
        if (*s == ')')
            *s = 0;
        else
        {   msg(err_bad_areaname(err_context,obj_area_name, area));
            return NULL;
        }
    }

    for (oep = objectlist;  oep != NULL; oep = oep->next)
        if (CiStrEQ(oep->oname, obj_area_name))
        {   struct aentry *a, *aep = NULL;
            int found = 0;
            for (a = objarealist;  a != NULL;  a = a->nxt)
            {   if (a->oep == oep &&
                    (area == NULL || CiStrEQ(area, a->name)))
                {   if (found == 0)
                        aep = a;
                    else
                       msg(err_mult_area(err_context, obj_area_name));
                    ++found;
                }
            }
            if (found == 0)
                msg(err_area_notfound(err_context, area, obj_area_name));
            return aep;
        }
    msg(err_object_notfound(err_context, obj_area_name));
    return NULL;
}

static void mark_area(char *name, int flags, char *err_context)
{   struct aentry *aep;
    if (name == NULL) return;
    aep = find_object_area(name, err_context);
    if (aep != NULL) aep->flags |= flags;
}

static char *static_copy(char *s)
{   if (s == NULL)
        return NULL;
    else
        return strcpy(halloc(strlen(s)+1L), s);
}

static struct fentry **parse_cmd(char **argv, struct fentry **nextfile)
{
    char *ap;
    FILE *viafile;
    int32 libflag;

    libflag = 0;
    while ((ap = *++argv) != 0)
    {   int c;
        if (*ap != '-')
        {   int  lflag, err;
            char *cp;

            cp = ap;
            while (*cp) {
                if (*cp == ',') {
                    *cp = '\0'; /* Complete & total kludge */
                    *argv = ++cp;
                    msg(warn_commasep(ap));
                    argv--;
                    break;
                }
                cp++;
            }
            lflag = 0;
            if (libflag)
                lflag = 'l';
            c = *(cp = ap + strlen(ap) - 1);
            c = LOWER(c);
            if ((c=='a' || c=='l') && *--cp == '/') {
                lflag = c;
                *cp = '\0';                        /* Chop off /a or /l */
            }
#ifdef LINKING_ON_RISCOS
            startdirsearch(ap);         /* Expand wildcards if RISC OS */
            for (;;)
            {   ap = getwildcard(&err);
                if (err != 0) msg(fatal_dirread(ap));
                if (ap == NULL) break;
                nextfile = addfile(nextfile, ap, lflag);
            }
#else
            nextfile = addfile(nextfile, ap, lflag);
#endif
            continue;
        }
        c = *++ap;
        c = LOWER(c);
        switch (c)
        {
        case 'a':
            if (CiStrEQ(ap, "aif") &&
                output_type == AIF &&
                binaryflag == BIN_NOHDR)
            {   /* -bin -aif */
                binaryflag = BIN_AIFHDR;
                continue;
            }
            if (output_type) msg(fatal_multout);
            if (CiStrEQ(ap, "aif"))
                output_type = AIF;
            else if (CiStrEQ(ap, "aof"))
            {   output_type = AOF;
                plinkflag = 1;
            }
            else if (CiStrEQ(ap, "aout"))
                output_type = AOUT;
            else
                goto defolt;
            break;
        case 'b':
            if (ap[1] == 0 || CiStrEQ(ap, "base"))
                goto RO_base;
            else if (CiStrEQ(ap, "bin"))
            {   if (output_type != 0 &&
                    !(output_type == AIF && binaryflag == 0))
                    msg(fatal_multout);
                if (output_type == AIF)
                    binaryflag = BIN_AIFHDR;
                else
                    binaryflag = BIN_NOHDR;
                output_type = AIF;
            }
            else
                goto defolt;
            break;
        case 'c':
#ifdef LINKING_ON_ACORN_RISC_OS
            /* c++ flag */
            if (ap[1] == '+' && ap[2] == '+') {
                cplusplusflag = 1;
                continue;
            }
            else
#endif
            casefn = cistrcmp;
            break;
        case 'd':
            if (CiStrEQ(ap, "dde"))
                ddeflag = 1;
            else if (CiStrEQ(ap, "dupok"))
                duplicateflag = 1;
            else if (CiStrEQ(ap, "data"))
            {   rw_ext = ".dat";
                goto RW_base;
            }
            else
            {   debugflag = 1;
                if (ddeflag && CiStrEQ(ap, "dbug"))
                {   if (output_type && output_type != AOF) msg(fatal_multout);
                    output_type = AOF;
                }
            }
            break;
        case 'e':
            if (CiStrEQ(ap, "errors"))
            /* Put all following error diagnostics to a file */
            {   FILE *e;
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((e = fopen(*argv, "w")) == NULL)
                    msg(fatal_reopen_stderr(*argv));
                else
                {   fclose(e);
                    freopen(*argv, "w", stderr);
                }
                continue;
            }
            if (CiStrEQ(ap, "edit"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (editfile) msg(fatal_multflag(ap));
                editfile = static_copy(*argv);
                continue;
            }
            if (ap[1] == 0 || CiStrEQ(ap, "en") || CiStrEQ(ap, "entry"))
            {   char *s, *e;
                if (entryflag) msg(fatal_multflag(ap));
                if ((s = *++argv) == 0) msg(fatal_noarg(ap));
                if ((e = strchr(s, '+')) != NULL)
                {   entryflag = 2;
                    *e = 0;
                    entryarea_name = static_copy(e+1);
                    entryoffset = getnum(s, fatal_badentry);
                }
                else
                {   entryflag = 1;
                    entrypoint = getnum(s, fatal_badentry);
                }
            }
            else
                goto defolt;
            break;
        case 'f':
            if (CiStrEQ(ap, "first"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                first_area = static_copy(*argv);
            }
            else if (ap[1] == 0)
                libflag = 0;
            else
                goto defolt;
            break;
        case 'h':
            help();
            endlink(0);
            /*NOTREACHED*/
        case 'l':
            if (CiStrEQ(ap, "list"))
            /* Put MAP and Xref output to a file */
            {   FILE *l;
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((l = fopen(*argv, "w")) == NULL)
                    msg(fatal_reopen_stderr(*argv));
                else
                {   fclose(l);
                    freopen(*argv, "w", stdout);
                }
            }
            else if (CiStrEQ(ap, "last"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                last_area = static_copy(*argv);
            }
            else if (ap[1] == 0)
                libflag = 1;
            else
                goto defolt;
            break;
        case 'i':
            if (CiStrEQ(ap, "ihf"))
            {   output_type = IHF;
                continue;
            }
            if (CiStrNE(ap, "image")) goto defolt;
            ap = "o";
            /* FALL THROUGH */
        case 'o':
            if (CiStrEQ(ap, "ov") || CiStrEQ(ap, "overlay"))
            {   c = OVERLAY;
                goto scatter_format_image;
            }
#ifdef TARGET_HAS_AOUT
            if (CiStrEQ(ap, "omagic"))
            {   if (output_type) msg(fatal_multout);
                output_type = AOUT;
                plinkflag = 1;
                continue;
            }
#endif
            if (ap[1] == 0 || CiStrEQ(ap, "output"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (outfile) msg(fatal_multout);
                outfile = static_copy(*argv);
                continue;
            }
            goto defolt;
        case 'm':
            if (CiStrEQ(ap, "map"))
            {   mapflag = 1;
                continue;
            }
            else if (CiStrEQ(ap, "match"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                match_opts = (int) getnum(*argv, fatal_badmatchopts);
                continue;
            }
#ifdef TARGET_IS_RISCOS
            /* -module assumed */
            if (output_type) msg(fatal_multout);
            output_type = RMF;
            break;
#else
            goto defolt;
#endif
        case 'q':
            if (!*++argv) msg(fatal_noarg(ap));
            qflag = getnum(*argv, fatal_badwork);
            break;
        case 'w':
            if (workspaceflag) msg(fatal_multflag(ap));
            if (!*++argv) msg(fatal_noarg(ap));
            workspaceflag = 1;
            workspace = getnum(*argv, fatal_badwork);
            break;
        case 'r':
            if (CiStrEQ(ap, "rmf"))
            {   if (output_type) msg(fatal_multout);
                output_type = RMF;
            }
            else if (CiStrEQ(ap, "reent") || CiStrEQ(ap, "reentrant"))
                reent_flag = 1;
            else if (CiStrEQ(ap, "ro") || CiStrEQ(ap, "ro-base"))
            {   ro_ext = ".ro";
RO_base:        if (baseflag) msg(fatal_multbases);
                if (!*++argv) msg(fatal_badbase);
                base = getnum(*argv, fatal_badbase);
                baseflag = 1;
            }
            else if (CiStrEQ(ap, "rw") || CiStrEQ(ap, "rw-base"))
            {   rw_ext = ".rw";
RW_base:        if (rw_baseflag) msg(fatal_multflag(ap));
                if (*++argv == 0) msg(fatal_noarg(ap));
                data_base = getnum(*argv, fatal_baddatabase);
                rw_baseflag = 1;
            }
            else /* -relocatable assumed */
                relocflag = 1;
            continue;
        case 'n':
            if (CiStrEQ(ap, "nounusedareas") || CiStrEQ(ap, "nounused"))
            {   nounusedflag = 1;
                continue;
            }
#ifdef TARGET_HAS_AOUT
            else if (ap[1] != 0)
                goto defolt;
            if (output_type) msg(fatal_multout);
            output_type = AOUT;
            nmagicflag = 1;
            break;
        case 'z':
            if (output_type) msg(fatal_multout);
            output_type = AOUT;
            plinkflag = 0;
            break;
#endif
            goto defolt;
        case 's':
            if (CiStrEQ(ap, "shl"))
            {   if (output_type) msg(fatal_multout);
                output_type = AOF;
                plinkflag = 1;
                shl_flag = 1;
                if ((shl_file = *++argv) == NULL)
                    msg(fatal_noarg(ap));
                else
                    shl_file = static_copy(shl_file);
            }
            else if (ap[1] == 0 || CiStrEQ(ap, "sym") || CiStrEQ(ap, "symbols"))
            {   if ((symfile = *++argv) == NULL)
                    msg(fatal_noarg(ap));
                else
                    symfile = static_copy(symfile);
            }
            else if (CiStrEQ(ap, "split"))
                splitflag = 1;
/*/* The space in "scat ter" ensures there can never be a match, which is */
/* what is intended for R1.6. Fix later when -scatter has been developed. */
            else if (CiStrEQ(ap, "scat ter"))
            {   c = SCATTERIMAGE;
scatter_format_image:
                if (*++argv == 0) msg(fatal_noarg(ap));
                if (scatterflag) msg(fatal_multflag(ap));
                scatterflag = c;
                scatterfile = static_copy(*argv);
                continue;
            }
            else
                goto defolt;
            break;
        case 'u':
            if (ap[1] == 0 || CiStrEQ(ap, "unresolved"))
            {   if (*++argv == 0) msg(fatal_noarg(ap));
                if (unresolved_fn != NULL)
                    msg(fatal_multunresolved);
                else
                {   unresolved_fn = globinsert(*argv,
                        makesym(0, SYM_REFAT, NULL), "!!")->h_un.globval;
                }
            }
            else
                goto defolt;
            break;
        case 'v':
        {   char *nargv[64], *cp;
            int i, lineno;

            if (CiStrEQ(ap, "via"))
            {   /* VIA viafile */
                if (*++argv == 0) msg(fatal_noarg(ap));
                if ((viafile = fopen(*argv, "r")) == 0)
                    msg(fatal_openerr(*argv));
                lineno = 0;
                while ((cp = getline(viafile, *argv, ++lineno)) != NULL)
                {   while (isspace(*cp)) cp++;
                    i = 1;
                    while (*cp)
                    {   nargv[i++] = cp;
                        if ( i > sizeof(nargv)/sizeof(char *))
                            msg(fatal_toomany(viafile, lineno));
                        while (*cp != 0 && !isspace(*cp)) cp++;
                        if (*cp)
                        {   *cp++ = '\0';
                            while (isspace(*cp)) cp++;
                        }
                    }
                    nargv[i] = 0;
                    nextfile = parse_cmd(nargv, nextfile);
                }
                if (ferror(viafile)) msg(fatal_readerr(*argv));
                fclose(viafile);
            }
            else
            {   /* assume -verbose, -v, -vv, etc */
                i = *ap++;
                while ((i = LOWER(i)) == 'e' || i == 'v')
                {   ++verboseflag;
                    i = *ap++;
                }
            }
            break;
        }
        case 'x':
            xrefflag = 1;
            break;
        default:
        defolt:
            msg(fatal_badflag(ap));
        }
    }
    return nextfile;
}

static void list_syms(void)
{
    FILE *f;
    struct globsym *gs;
    struct hentry *h;
    struct aentry *aep;
    struct oentry *oep;

    if (symfile == NULL) return;

    if (strcmp(symfile, "-") == 0)
        f = stdout;
    else if ((f = fopen(symfile, "w")) == 0)
        msg(fatal_openerr(symfile));

    fprintf(f, msgtext(misc_sym_hdr));
    h = firstglobsym;
    while (h != NULL)
    {   gs = h->h_un.globval;
        aep = gs->symval.area;
        if (aep != NULL && (aep->flags & UNUSEDAREA)) goto skip_unused;
        fprintf(f, "%-24s", cplusplusname(h->name + 2));
        if (!(gs->symval.flags & SYM_DEFAT))
        {   if (gs->symval.flags & SYM_WEAKAT)
                fprintf(f, msgtext(misc_sym_undefweak));
            else
                fprintf(f, msgtext(misc_sym_undefref));
            oep = gs->symval.refobj;
        }
        else
        {   fprintf(f, " %06lx", gs->symval.value);
            oep = 0;
            if (aep && plinkflag)
            {   fprintf(f, " + |%s|", aep->name);
                oep = aep->oep;
            }
        }
        if (oep && plinkflag)
        {   fprintf(f, msgtext(misc_map_fromfile), oep->fep->fname);
            if (oep->fep->type & LIB_MASK)
                fprintf(f, "(%s)", oep->oname);
        }
        fputc('\n', f);
skip_unused:
        h = gs->next;
    }
    if (ferror(f)) msg(fatal_writeerr(symfile));
    if (f != stdout) fclose(f);
}

int main(int argc, char **argv)
{
    struct fentry *fep;
    struct aentry *aep;
    struct lventry *lv;
    struct oventry *ov;

    level_strs[0] = msgtext(msglevel_info);
    level_strs[1] = msgtext(msglevel_warning);
    level_strs[2] = msgtext(msglevel_error);
    level_strs[3] = msgtext(msglevel_fatal);

    (void)program_name(argv[0], myname, sizeof(myname));
    if (argc <= 1)
    {   help();
        endlink(0);
        /*NOTREACHED*/
    }

#ifdef TIME
    int32 start_time = cs_wall_clock();
#endif
    notyetdef = 0;
    signal(SIGINT, endlink);
    signal(SIGTERM, endlink);
    signal(SIGILL, endlink);
    signal(SIGABRT, endlink);
/*  signal(SIGFPE, endlink); crashes IBM PS2/55SX with Watcom C/386 v9.01 */
    signal(SIGSEGV, endlink);
#ifdef TARGET_HAS_AOUT
    pagesize = PAGESIZE;
#endif
    maxopenfiles = MAXOPENFILES;
#ifdef LINKING_ON_UNIX
#  ifdef UNIX_NATIVE_LINKER
    pagesize = getpagesize();
#  endif
#endif
#ifdef LINKING_ON_MAC
    Tracked_init();
#endif
    hashinit(&commontable, COMMONTABLESIZE, halloc);
    hashinit(&globhashtable, GLOBHASHTABLESIZE, halloc);
    firstglobsym = NULL;
    nextglobsym = &firstglobsym;
    match_opts = patchable_config.match_opts;

    (void) parse_cmd(argv, &clifilelist);

    if (output_type == AOUT)
        common = addarea("Aout$$Common", NULL, 0, 0, 0, 0, AOF_COMREFAT, 0);

    if (failedtostack) msg(warn_nearoutmem);

    if (plinkflag)
    {   if (shl_flag)
        {   if (!baseflag) base = 0;
        }
        else
        {   if (baseflag) msg(fatal_basedplink);
            base = 0;
        }
    }

    if (binaryflag == BIN_NOHDR && debugflag)
    {   debugflag = 0;
        msg(warn_dbgignored_1);
    }

    if (output_type == NOTYPE) output_type = DEFOUTPUT_TYPE;
    if (output_type == RMF) {output_type = AIF;  moduleflag = 1;}

    if (output_type == IHF)
    {   output_type = AIF;
        binaryflag = BIN_NOHDR;
        intellecflag = 1;
        if (rw_baseflag && !splitflag)
        {   msg(warn_rwbaseignored);
            rw_baseflag = 0;
        }
    }

    if (!baseflag && (binaryflag || intellecflag)) base = 0;

    /* IHF must always start at 0 */
    /* if (intellecflag) intellec_base = (unsigned)base; */
    intellec_base = 0;

    if (outfile == NULL)
    {   if (output_type == AOUT)
            outfile = AOUTFNAME;
        else if (output_type == AIF)
        {   if (scatterflag)
                outfile = OVRFNAME;
            else
                outfile = AIFFNAME;
        }
        else
            outfile = AOFFNAME;
    }

    if (clifilelist == NULL) msg(fatal_nofiles(myname));

    if (scatterflag == OVERLAY)
    {   (void) addarea("Overlay$$Data", NULL, 0, 64 * 16,
                        0, 0, AOF_COMREFAT, 0);
        load_seg_and_go = globinsert("Image$$load_seg",
                                     makesym(0, SYM_REFAT, NULL), "!!");
        overlay_init = globinsert("Image$$overlay_init",
                                  makesym(0, SYM_REFAT, NULL), "!!");
    }

    if (shl_flag)
    {   dyn_link = globinsert("__rt_dynlink",
            makesym(0, SYM_REFAT+SYM_LINKSYM, NULL), "!!");
        /* These symbols are never output - they are optimised away by */
        /* AOF output formatting - but it's very convenient during the */
        /* construction of inter-LU veneer objects and shared libs.    */
        sb_limit = globinsert(mkname(NULL, interLUdataName, "$$Limit"),
            makesym(0, SYM_LOCALDEFAT+SYM_ABSAT, NULL), "!!");
        eft_offset = globinsert("EFT$$Offset",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        eft_params = globinsert("EFT$$Params",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        shl_datasz = globinsert("SHL$$data$$Size",
            makesym(0, SYM_GLOBALDEFAT+SYM_ABSAT, NULL), "!!");
        stub_0base = globinsert("$$0$$Base",
            makesym(0, SYM_GLOBALDEFAT, NULL), "!!");
        shl_database = globinsert("SHL$$data$$Base",
            makesym(0, SYM_GLOBALDEFAT, NULL), "!!");
    }

    symcount = 0;
    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
    {   struct oentry **lastobj;
        if (!(fep->type & OBJECT_MASK)) continue;
        setfile(fep);
        lastobj = nextobj;
        nextobj = addobject(nextobj, fep->fname, fep,
                            fep->f_un.hdrptr, 0, fep->size);
        if (lastobj == &objectlist &&
            special_aof(*lastobj)) continue;
        if (verboseflag) msg(info_loadobj(fep->fname));
        load1(*lastobj);
        if (verboseflag >= 2)
        {   ReportNewUndefineds();
            ReportNewDefineds();
        }
    }

    /* Turn on debugging if any input area is a DEBUG area. An AIF output  */
    /* can only have DEBUG areas if binaryflag != BIN_NOHDR (See addarea().*/
    /* We repeat the test here for local completeness. Note also that we   */
    /* allow a DEBUG area in a primary input to turn on debugging, but not */
    /* so for a DEBUG area in a library. We may want to revise this later. */

    /* IDJ - 3-Oct-94: remove auto-inclusion of debug areas for RISC OS */

#ifdef LINKING_ON_ACORN_RISC_OS
    if ((output_type == AIF || output_type == RMF) && binaryflag != BIN_NOHDR && has_dbg_areas && !debugflag)
        msg(info_dbgignored_nod);
#else
    if (output_type == AIF && binaryflag != BIN_NOHDR && has_dbg_areas)
        debugflag = 1;
#endif

    for (fep = clifilelist;  fep != NULL;  fep = fep->next)
        if (fep->type & LIB_MASK)
            load_lib(fep);

    mark_area(first_area, AREA_FIRST, "-First");
    mark_area(last_area,  AREA_LAST,  "-Last");

    if (entryarea != NULL && entryarea_name != NULL)
        msg(warn_multentry(
            entryarea->oep->oname, entryarea->name, entryarea_name));

    if (entryarea_name != NULL)
        entryarea = find_object_area(entryarea_name, "-Entry");

    if (common != NULL) common->oep = NULL;
    *nextobjarea = NULL;
    init_overseg(&root, outfile, ROOTNAME);

    if (scatterflag)
    {   build_overlay_tree();
#ifdef LINKING_ON_MSDOS
        mkdir(outfile);
#else
        mkdir(outfile, 0775);
#endif
    }

    if (shl_flag)
        build_shl_description();

    if (entryarea == NULL ||
        output_type != AIF ||
        binaryflag || debugflag)
        /* Don't remove unreferenced areas except from vanilla AIF images */
        nounusedflag = 1;

    do_final_symbol_matching();

    if (scatterflag || xrefflag || shl_flag || nounusedflag == 0)
    {   struct aentry *reftoarea;
        if (xrefflag)
            printf(msgtext(misc_xref_hdr));
        for (aep = objarealist; aep != NULL; aep = aep->nxt)
            add_area_xrefs(aep);
        if (scatterflag &&
            entryarea != NULL &&
            (reftoarea = overlay_init->h_un.globval->symval.area) != NULL)
            addarearef(entryarea, reftoarea);
        if (xrefflag) printf("\n");
    }

    if (nounusedflag == 0)
        remove_unused_areas();

    place_areas();
    place_libareas();
    strtsize = 4;
    middle();
    if (symfile) list_syms();

    if (error_count == 0)
    {   if (mapflag)
        {   print_map(&root);
            for (lv = root.level_list;  lv != NULL;  lv = lv->next)
            {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
                    print_map(ov);
            }
        }
        if (verboseflag) msg(info_openout(outfile));
        put_image_segment(&root);
        for (lv = root.level_list;  lv != NULL;  lv = lv->next)
        {   for (ov = lv->seg_list;  ov != NULL;  ov = ov->next)
                put_image_segment(ov);
        }
    }
    else
        msg(info_errors);
    if (verboseflag)
        msg(info_mem_use(heap_sz, max_stack_sz, cache_sz));
#ifdef TIME
    fprintf(stderr, "Time = %d cSec\n", cs_wall_clock() - start_time);
#endif
    endlink(0);
    /*NOTREACHED*/
    argc = argc;
    return 0;
}
