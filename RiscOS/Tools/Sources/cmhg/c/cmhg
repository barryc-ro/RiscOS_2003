/*
 * CMHG -- RISC OS Module Header Generation Tool
 *
 * Copyright (C) Acorn Computers, 1989
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include "outaof.h"
#include "fname.h"
#ifdef __riscos
#include "swis.h"
#include "throwback.h"
#ifdef OLD_AOF
#define FNAME_ORDERTYPE FNAME_ACORN
#endif
#else
#ifdef OLD_AOF
#define FNAME_ORDERTYPE FNAME_DFLT
#endif
#endif

#define  SELF               "cmhg"
#define  VERSION            "5.16"
#define  VERSION_NUM        516
#define  OK                 0
#define  BAD                1
#define  NAMESZ             32
#define  HELP_STR_SZ        80                        /* Actually 79 + NUL */
#define  NAME               1
#define  STRING             0
#define  WARN_TITLE_LEN     16
#define  MAX_TEXT           1024
#define  MAX_HEADER_SZ      (1024*4)

#define  STRINGIFY(x)       #x

#define  RELOC_OFFSET_SYM   "_Lib$Reloc$Off$DP"
#define  LIB_INITIALISE     "_clib_initialisemodule"
#define  SYS_INITIALISE     "_cmhg_initialise"
#define  LIB_FINALISE       "_clib_finalisemodule"
#if 0
#define  LIB_START1         "_clib_entermodule"
#define  LIB_START2         "_blib_entermodule"
#else
#define  LIB_START          "_clib_entermodule"
#endif

#define  SUFFIXES           "c c++ cmhg h o p s"
/*
 * This banner string is written to the output AOF file.
 */
static char banner_string[] = SELF " vsn " VERSION " [" __DATE__ "]\0\0\0";

#ifndef unsigned32
#define unsigned32 unsigned long
#endif

/*
 * Veneer code sequences are defined in an object module linked into this
 * program. Each sequence is described by a veneer descriptor, also defined
 * by the (assembly language coded) veneer module. The veneer description
 * points to the start of the sequence, gives its length, gives the offset
 * of the (unique) BL <C-code> instruction within the veneer, and gives a
 * (-1 terminated) list of offsets of instructions to be relocated by the
 * value of _Lib$Reloc$Off.
 */
struct veneer
{
  unsigned32 *code_start;
  unsigned32 code_len;
  unsigned32 call_offset;           /* offset of BL <C-code> in veneer */
  unsigned32 reloc_offset[1];       /* list terminated by 0xffffffff */
};

/*
 * The following veneer sequences are defined by the veneer module...
 */
extern struct veneer b_veneer;
extern struct veneer bl_veneer;
extern struct veneer initialise_lib_veneer;
extern struct veneer initialise_user_veneer;
extern struct veneer initialise_end_veneer;
extern struct veneer finalise_user_veneer;
extern struct veneer finalise_end_veneer;
extern struct veneer finalise_lib_veneer;
extern struct veneer finalise_sys_veneer;
extern struct veneer service_call_veneer;
extern struct veneer cmd_handler_veneer;
extern struct veneer swi_handler_veneer;
extern struct veneer swi_decode_veneer;
extern struct veneer swi_decode2_start_veneer;
extern struct veneer swi_decode2_end_veneer;
extern struct veneer irq_entry_veneer;
extern struct veneer irq_common_head_veneer;
extern struct veneer irq_common_tail_veneer;
extern struct veneer generic_entry_veneer;
extern struct veneer generic_common_head_veneer;
extern struct veneer generic_common_tail_veneer;

/*
 * The following structure is used to describe a module '*' command table
 * entry between parsing the input description and 'generating code'.
 */
struct command
{
  struct command *prev;             /* previous in chain of commands */
  char *name;                       /* name of star command */
  unsigned int min_args:8;          /* self-explanatory */
  unsigned int gstrans_map:8;       /* self-explanatory */
  unsigned int max_args:8;          /* self-explanatory */
  unsigned int :4;                  /* reserved flags */
  unsigned int international:1;     /* help+syntax are internationalised */
  unsigned int help:1;              /* call code for *Help */
  unsigned int configure:1;         /* *Configure command */
  unsigned int fs:1;                /* filing system command */
  char *invalid_syntax_msg;         /* self-explanatory */
  unsigned32 invalid_syntax_offset; /* used during 'code generation' */
  char *help_text;                  /* self-explanatory */
  unsigned32 help_text_offset;      /* used during 'code generation' */
  unsigned int add_syntax:1;        /* append syntax to help */
};

/* Hack because C doesn't permit the address of a bitfield to be taken */
#define info_word(c) (*((unsigned32 *)&c->name + 1))

/*
 * The following structure is used to hold a list of SWI decode table
 * entries (strings) between reading the input and 'generating code'.
 */
struct swi_string
{
  struct swi_string *prev;          /* previous in the list */
  char str[4];                      /* as long as needed */
};

/*
 * The following structure is used to store a list of irq_handlers
 * between reading the input and 'generating code'.
 */
struct irq_handler
{
  struct irq_handler *prev;
  char *entry_name;                 /* name of the entry veneer */
  char *handler_name;               /* name of the C fn handling this IRQ */
};

/*
 * This structure describes a RISC OS Module Header.
 * Each field is an offset from the start of the module, i,e. from the
 * start of the module header. Each field may be 0 to indicate 'not used'.
 */
struct module_header
{
  unsigned32 start_code;
  unsigned32 init_code;
  unsigned32 final_code;
  unsigned32 service_call_handler;
  unsigned32 title_string;
  unsigned32 help_string;
  unsigned32 command_table;
  unsigned32 swi_chunk_base;
  unsigned32 swi_handler_code;
  unsigned32 swi_decoding_table;
  unsigned32 swi_decoding_code;
  unsigned32 international_help_file;   /* SMC: new entry for international help/syntax file path */
};

/*
 * The following global data are used during the translation process...
 */

static FILE *in;                    /* input FILE */
static char *in_name;               /* input filename */
static char in_name_buffer[256];    /* somewhere to put the parsed input name */
static int lineno, nerrs;           /* input line number, no of errors */
static char *defs_file;             /* optional 2nd output file */

static int not_re_entrant;          /* non-0 if module is not_re_entrant */
static char *start_code;            /* name of start code C function */
static char *init_code;             /* name of module init C function */
static char *final_code;            /* name of module finalise C function */
static char *service_call_handler;  /* name of service-call handler... */
static unsigned *fast_calls;        /* and the number and identity of  */
static unsigned nfast_calls;        /* calls which can be ignored quickly */
static char *title_string;          /* self-explanatory */
static char *help_string;           /* self-explanatory */
static char *command_handler;       /* name of C function handling '*' cmds */
static struct command *commands;    /* ...description of '*' commands... */
static unsigned32 swi_base;         /* self-explanatory */
static char *swi_handler;           /* name of C fn handling SWIs... */
static struct swi_string *swi_decode_str;
static char *swi_decode_code;       /* name of C fn decoding SWI nos */
static char *swi_decode2_code;
static struct irq_handler *irq_handlers;   /* irq handler entries & fns */
static struct irq_handler *generic_veneers;   /* generic entries & fns */
static struct irq_handler *event_handler;  /* event handler entry & fn  */
static unsigned nfast_events;              /* no of 'fast' events */
static unsigned *fast_events;              /* the fast events */
#ifdef SYSTEM_STATICS
static int sys_statics;
#endif
static char *lib_init_code;         /* SMC: name of replacement library initialisation entry
                                            point (instead of _clib_initialisemodule) */
static char *lib_enter_code;        /* KJB: name of replacement library entry point
                                            (instead of _clib_entermodule) */
static char *help_file;             /* SMC: name of international help/syntax file */
static char date_string[12];        /* KJB: date string */
static char version_string[8];      /* KJB: version string */

#if 0
static int bflag = 0;               /* IDJ: flag added to indicate that blib_entermodule should
                                            be called instead of clib_entermodule, when module
                                            is 'entered' (ie RUN).  This helps ShareFS
                                     */
#endif

static char *include_path = "C:";   /* KJB: include path to send to preprocessor */
static char temp_file[L_tmpnam];    /* KJB: temporary file used when preprocessing */
static int in_cmhg_file;            /* KJB: flag used when using preprocessor - #line
                                            directives are tracked so we can ignore
                                            guff in header files */
static int throwback_flag;          /* KJB: throwback enabled */
#ifdef NOTYET
static int reent_flag;              /* KJB: using -APCS 3/reent instead of -zM */
#endif

/*
 * The following data are used during 'code generation'...
 */
static char *module_area, *dot;     /* the module header is built here */
static unsigned32 reloc_offset_sym;

/*
 * CMHG accepts input in the form of statements, one to a (logical) line.
 * A ';' introduces a comment, which extends to the end of the current line.
 * A ',' separates list items (optionally - space will do too) and introduces
 * a line continuation (across several blank lines, if required.
 *
 * Each statement begins with a keyword. Keywords are made up from letters
 * and the '-' character. A keyword is always followed by a ':'.
 * The keywords and statement formats are:-
 *
 *   module-is-runnable:
 *   module-is-not-re-entrant:
 *   initialisation-code:           <name-of-C-fn>
 *   service-call-handler:          <name-of-C-fn>  <unsigned-int>*
 *   title-string:                  <title-string>
 *   help-string:                   <module-name>   <module-version>
 *   command-keyword-table:         <name-of-C-fn>  <command-description>+
 *   swi-chunk-base-number:         <unsigned-int>
 *   swi-handler-code:              <name-of-C-fn>
 *   swi-decoding-table:            <swi-base-name> <swi-name>*
 *   swi-decoding-code:             <name-of-C-fn>
 *   irq-handlers:                  <name-pair>+
 *   event-handler:                 <name-pair>     <unsigned-int>*
 *   finalisation-code:             <name-of-C-fn>
 *   library-initialisation-code:   <name-of-C-fn>
 *   international-help-file:       <name-of-text-file>
 *   date-string:                   <date-string>
 *
 * Each keyword (except command-keyword-table, which is abbreviated,
 * irq-handlers and event-handler, which have no corresponding fields
 * in the module header) has the same name as is given on page 628 of
 * the RISC OS PRM Vol 2 for the corresponding field of the module header.
 *
 * Title-string and help-string are compulsory: all other fields are optional.
 * The title string may contain any graphic, non-space characters. The help
 * string is similar, but '_'s are translated to spaces in it and it is padded
 * with TABs to be 16 chars long. The version must be exactly of the form d.dd
 * (e.g. 1.00).
 *
 * A command-description has the format:
 *
 *   <star-command-name> "("
 *       min-args:                  <unsigned-int>  ; default 0
 *       max-args:                  <unsigned-int>  ; default 0
 *       gstrans-map:               <unsigned-int>  ; default 0
 *       fs-command:                                ;>flag bits in     (31)
 *       status:                                    ;>the flag byte    (30)
 *       configure:                                 ;>of the cmd table (30)
 *       help:                                      ;>info word.       (29)
 *       international:                             ;>                 (28)
 *       add-syntax:
 *       help-text:                 <text>
 *       invalid-syntax:            <text>
 *                        ")"
 *
 * Each sub-argument is optional. A comma after any item allows continuation
 * on the next line. <text> follows the conventions of ANSI C string constants:
 * a sequence of implicitly concatenated string segments enclosed in " and ".
 * Within a string segment '\' introduces an escape character; all the single
 * character ASCII escapes are implemented; hexadecimal and octal escape codes
 * are not implemented. A '\' immediately preceding a newline allows the string
 * segment to be continued on the following line (but does NOT inlude a newline
 * in the string, which must be represented by \n). The add-syntax flag
 * indicates that the invalid-syntax string should be concatenated onto the
 * help-text (as is standard practice).
 *
 * A name pair consists of a C function name, optionally followed by "/" and
 * a second name. If omitted, the second name is constructed by appending
 * "_handler" to the first given name. This second name must be name of a C
 * function within the module which is supposed to handle an IRQ; the first
 * name is the name of its entry veneer and the name by which the handler
 * may be attached to (say) IrqV. For example:
 *
 *   irq-handlers:  irq1/irq_1 irq2 irq3/irq_handler_3
 */


/* Hacky little flag errf uses to communicate with warnf */
static int an_error;

/*
 * Generate an error message
 */

static void warnf(char *fmt, char *s)
{
  fputs(SELF, stderr);
  if (lineno == 0)
    fputs(": ", stderr);
  else
    fprintf(stderr, ", line %u: ", lineno);
  fprintf(stderr, fmt, s);

#ifdef __riscos
  if (throwback_flag && lineno)
  {
      char buf[256];
      sprintf(buf, fmt, s);
      throwback_send(an_error, lineno, buf, in_name, in_name);
      an_error = 0;
  }
#endif
}

static void errf(char *fmt, char *s)
{
  ++nerrs;
  an_error = 1;
  warnf(fmt, s);
}

static void fatal_error()
{
  errf("fatal error\n", NULL);
  exit(BAD);
}

/*
 * Input parsing procedures.
 */

static int getch(void)
{
  if (feof(in)) return EOF;
  return getc(in);
}

static void unget(int ch)
{
  if (ch != EOF) ungetc(ch, in);
}

static int iseol(int ch)
{
  return (ch == '\n' || ch == '\r' ? 1 : 0);
}

static int skip_spaces(void)
{
  int ch;
  do {ch = getch();} while (isspace(ch) && !iseol(ch));
  if (ch == ';')
  {
    while (ch != EOF && !iseol(ch)) ch = getch();
  }
  return ch;
}

static void skip_past_eol(int ch)
{
  while (ch != EOF && !iseol(ch)) ch = getch();
  if (iseol(ch))
  {
    int nch = getch();
    ++lineno;
    if ((ch + nch) != ('\n' + '\r')) unget(nch);
  }
}

static int skip_past_ch()
{
  int ch = skip_spaces();
  while (iseol(ch)) {skip_past_eol(ch);  ch = skip_spaces();}
  return ch;
}

static char *keyword[] = {
#define  RUNNABLE       0
    "module-is-runnable",
#define  NOTREENTRANT   1
    "module-is-not-re-entrant",
#define  INIT           2
    "initialisation-code",
#define  SERVICE        3
    "service-call-handler",
#define  TITLE          4
    "title-string",
#define  HELP_STR       5
    "help-string",
#define  CMD_TAB        6
    "command-keyword-table",
#define  SWI_BASE       7
    "swi-chunk-base-number",
#define  SWI_HANDLER    8
    "swi-handler-code",
#define  SWI_TABLE      9
    "swi-decoding-table",
#define  SWI_CODE       10
    "swi-decoding-code",
#define  IRQ_HANDLERS   11
    "irq-handlers",
#define  MIN_ARGS       12
    "min-args",
#define  MAX_ARGS       13
    "max-args",
#define  GST_MAP        14
    "gstrans-map",
#define  FS_CMD         15
    "fs-command",
#define  STAR_STATUS    16
    "status",
#define  STAR_CONFIG    17
    "configure",
#define  STAR_HELP      18
    "help",
#define  BAD_SYNTAX     19
    "invalid-syntax",
#define  HELP_TEXT      20
    "help-text",
#define  EVENT_HANDLER  21
    "event-handler",
#define FINALISE        22
    "finalisation-code",
/* SMC: new key words for international help/syntax and replacement library init code */
#define LIB_INIT        23
    "library-initialisation-code",
#define HELP_FILE       24
    "international-help-file",
#define INTERNATIONAL   25
    "international",
/* KJB: new keyword to allow date in the header to be overridden */
#define DATE            26
    "date-string",
#define LIB_ENTER       27
    "library-enter-code",
#define ADD_SYNTAX      28
    "add-syntax",
#define GENERIC_VENEERS 29
    "generic-veneers",
#define VECTOR_HANDLERS 30
    "vector-handlers"
  };

static int read_keyword(int ch)
{
  int j;
  char key[NAMESZ];

  j = 0;
  while (ch == '-' || isalpha(ch))
  {
    if (isupper(ch)) ch = tolower(ch);
    if (j < (NAMESZ-1)) key[j++] = ch;
    ch = getch();
  }
  key[j] = 0;

  for (j = 0;  j < sizeof(keyword)/sizeof(char *);  ++j)
  {
    if (strcmp(key, keyword[j]) == 0) break;
  }

  if (ch != ':')
  {
    ch = skip_spaces();
    if (ch != ':')
    {
      warnf("warning: missing ':' (assumed)\n", NULL);
      unget(ch);
    }
  }

  if (j < sizeof(keyword)/sizeof(char *))
      return j;
  errf("unrecognised keyword %s\n", key);
  return -1;
}

static int read_name(char *s, int maxlen, int not_string)
{
  int j, ch;

  j = 0;
  ch = skip_spaces();
  while (ch == '_' || not_string && isalnum(ch) || !not_string && isgraph(ch))
  {
    if (j < maxlen) s[j++] = ch;
    ch = getch();
  }
  unget(ch);

  if (j >= maxlen)
  {
    s[maxlen-1] = 0;
    errf("name %s... too long\n", s);
  }
  else s[j] = 0;

  return (j > 0 && j < maxlen);
}

static char *name_of(char *what)
{ char name[NAMESZ];
  if (read_name(name, NAMESZ, NAME))
  {
    return strcpy(malloc(strlen(name)+1), name);
  }
  else errf("missing %s name\n", what);
  return NULL;
}

static unsigned32 read_number(void)
{
  int ch = skip_spaces();
  unsigned32 n = 0, base = 10;
  if (ch == '&') {base = 16ul;  ch = getch();}
  if (ch == '0')
  {
    ch = getch();
    if (ch == 'x' || ch == 'X') {base = 16ul;  ch = getch();}
  }
  while (base == 10ul && isdigit(ch) || isxdigit(ch))
  {
    if (isdigit(ch)) ch = ch - '0';
    else if (islower(ch)) ch = ch - ('a' -10);
    else                  ch = ch - ('A' - 10);
    n = n * base + (unsigned32) ch;
    ch = getch();
  }
  unget(ch);
  return n;
}

static int hexval(int c)
{
    if (!isxdigit(c))
    {
    	errf("invalid hex digit\n", NULL);
    	return 0;
    }

    if (c >= '0' && c <= '9')
    	return c-'0';
    else if (c >= 'a' && c <= 'f')
    	return c-'a'+10;
    else /*if (c >= 'A' && c <= 'F')*/
        return c-'A'+10;
}

static char *read_text(int split)
{
  char text[MAX_TEXT];
  int ch = skip_spaces();
  int l = 0;
  while (ch == '"')
  {
    ch = getch();
    while (ch != '"' && ch != EOF)
    {
      if (ch == '\\')
      {
        ch = getch();
        if (iseol(ch))
        {
          do {ch = getch();} while (iseol(ch));
          continue;
        }
        switch (ch)
        {
case 'a':       ch = '\a';      break;  /* attn (otherwise known as bell) */
case 'b':       ch = '\b';      break;  /* backspace                      */
case 'f':       ch = '\f';      break;  /* form feed                      */
case 'n':       ch = '\r';      break;  /* newline                        */
case 'r':       ch = '\r';      break;  /* carriage return                */
case 't':       ch = '\t';      break;  /* (horizontal) tab               */
case 'v':       ch = '\v';      break;  /* vertical tab                   */
case '\\':      ch = '\\';      break;  /* backslash                      */
case '\'':      ch = '\'';      break;  /* single quote mark              */
case '\"':      ch = '\"';      break;  /* double quote mark              */
case '?':       ch = '?';       break;  /* '?' in case \?\?\? is needed   */
case 'x':       ch = hexval(getch()) * 16; ch += hexval(getch()); break;
case EOF:       break;
default:        if (l < MAX_TEXT) text[l++] = '\\';
                break;
        }
      }
      if (ch != EOF)
      {
        if (l < MAX_TEXT) text[l++] = ch;
        ch = getch();
      }
    }
    /* SMC: only skip newlines if allowed to have split lines */
    if (split)
      ch = skip_past_ch();
    else
      ch = skip_spaces();
  }
  unget(ch);
  if (l == MAX_TEXT)
  { char size[16];
    sprintf(size, "%u", MAX_TEXT);
    errf("quoted string too long (bigger than %s chars)\n", size);
    fatal_error();
  }
  text[l] = 0;
  return strcpy(malloc(l+1), text);
}

static void read_init_stmnt()
{
  init_code = name_of("initialisation function");
}

static void read_finalise_stmnt()
{
  final_code = name_of("finalisation function");
}

static int int_compare(const void *m1, const void *m2)
{
  return *(const int *) m1 - *(const int *) m2;
}

static unsigned read_fast_calls(unsigned * *fast_calls)
{ int ch;
  unsigned n_fast, fast[100];

  n_fast = 0;
  ch = skip_spaces();
  while (ch == '&' || isdigit(ch))
  { unsigned n;
    unget(ch);
    n = (unsigned) read_number();
    if (n_fast < 100)
      fast[n_fast++] = n;
    else
    {
      errf("more than 100 'fast' service calls\n", NULL);
      n_fast = 0;
    }
    ch = skip_spaces();
    if (ch == ',') ch = skip_past_ch();
  }
  unget(ch);
  if (n_fast != 0)
  {
    *fast_calls = (unsigned *) malloc(n_fast * sizeof(unsigned));
    memcpy(*fast_calls, fast, n_fast * sizeof(unsigned));
  }

  qsort(*fast_calls, n_fast, sizeof(unsigned), int_compare);

  return n_fast;
}

static void read_service_call()
{
  service_call_handler = name_of("service call handler");
  nfast_calls = read_fast_calls(&fast_calls);
}

static void read_title_string()
{
  char name[NAMESZ];

  if (read_name(name, NAMESZ, STRING))
  { int l = strlen(name);
    if (l > WARN_TITLE_LEN)
    {
      warnf("warning: title string longer than preferred max len of %s\n",
            STRINGIFY(WARN_TITLE_LEN));
    }
    title_string = strcpy(malloc(l+1), name);
  }
  else errf("missing title string\n", NULL);
}

static void read_help_string()
{
  int ch, j, l, n;
  char help[HELP_STR_SZ];

  if (read_name(help, NAMESZ, STRING))
  {
    /* pad name with tabs to 16 chars and replace '_' by ' ' ... */
    l = strlen(help);
    for (j = 0;  j < l;  ++j) if (help[j] == '_') help[j] = ' ';
    if (l > 15)
    {
      warnf("warning: title truncated to 15 chars\n", NULL);
      help[15] = ' ';
    }
    else
    {
      if (l < 8)  help[l++] = '\t';
      if (l < 16) help[l++] = '\t';
    }
    /* get the version string (if any) */
    ch = skip_spaces();
    if (isdigit(ch))
    {
      help[l++] = ch;  ch = getch();
      if (ch == '.')
      {
        help[l++] = '.';  ch = getch();
        if (isdigit(ch))
        {
          help[l++] = ch;  ch = getch();
          if (isdigit(ch))
          {
            help[l++] = ch;  goto got_version;
          }
        }
      }
      unget(ch);
      errf("mal-formed version string (d.dd required)\n", NULL);
      return;
    }
    else
    {
      unget(ch);
      strcpy(help+l, "0.00");
      l += 4;
    }
got_version:
    memcpy(version_string, help+l-4, 4);

    if (!date_string[0])
    {
        /*
         * We don't know what the date is yet - work it out, then fill in date_string
         */
#ifdef __riscos
        struct { int low, high; } riscostime;
        char *terminator;

        /*
         * Use the datestamp of the CMHG file for our module date - better than having the
         * date change every time we rebuild. Note that we use the UK territory as we want
         * the date in English. No error checking if the UK territory isn't present...
         */
        _swix(OS_File, _INR(0,1)|_OUTR(2,3), 20, in_name, &riscostime.high, &riscostime.low);
        _swix(Territory_ConvertDateAndTime, _INR(0,4)|_OUT(1),
                           1, &riscostime, help+l, HELP_STR_SZ-20, " (%DY %M3 %CE%YR)",
                           &terminator);
        memcpy(date_string, help+l+2, 11);
        n = terminator - (help + l);
#else
        time_t now;

        time(&now);
        n = strftime(help+l, (HELP_STR_SZ-20),
                          " (%d %b %Y)", localtime(&now));
        memcpy(date_string, help+l+2, 11);
#endif
    }
    else
    {
        /*
         * We already have a date! Copy it into place.
         */
        help[l]=' '; help[l+1]='('; help[l+13]=')';
        memcpy(help+l+2, date_string, 11);
        n = 14;
    }
    l += n;
    n += 20;
    ch = getch();
    if (!iseol(ch))
    { if (isspace(ch)) ch = skip_spaces();
      if (!iseol(ch))
      { help[l++] = ' ';
        j = l;
        while (!iseol(ch))
        { if (++n < (HELP_STR_SZ - 1)) help[l++] = ch;
          ch = getch();
        }
        if (n >= (HELP_STR_SZ - 1))
        { help[HELP_STR_SZ-1] = 0;
          warnf("help string comment truncated to:\n'%s'\n", help+j);
        }
        else
        { /* Strip trailing spaces */
          while (isspace(help[l-1])) l = l-1;
          help[l] = 0;
        }
      }
    }
    unget(ch);
    help_string = strcpy(malloc(l+1), help);
  }
  else errf("missing help string\n", NULL);
}

static void read_cmd_table()
{ command_handler = name_of("* command handler");
  if (command_handler != NULL)
  { int ch = ',';
    while (ch == ',')
    { struct command *cmd = (struct command *) calloc(1, sizeof(struct command));
      cmd->prev = commands;
      commands = cmd;
      ch = skip_past_ch();
      unget(ch);
      cmd->name = name_of("* command");
      cmd->invalid_syntax_msg = cmd->help_text = NULL;
      ch = getch();
      if (ch == '(')
      {
        for (;;)
        { int key;
          ch = skip_spaces();
          if (ch == ',') ch = skip_past_ch();
          if (ch == ')' || iseol(ch)) break;
          key = read_keyword(ch);
          switch (key)
          {
case MIN_ARGS:    cmd->min_args  = read_number();         break;
case MAX_ARGS:    cmd->max_args  = read_number();         break;
case GST_MAP:     cmd->gstrans_map = read_number();       break;
case FS_CMD:      cmd->fs        = 1;                     break;
case STAR_STATUS:
case STAR_CONFIG: cmd->configure = 1;                     break;
case STAR_HELP:   cmd->help      = 1;                     break;
case BAD_SYNTAX:  cmd->invalid_syntax_msg = read_text(1); break;
case HELP_TEXT:   cmd->help_text = read_text(1);          break;
/* SMC: new international help/syntax flag set by international: key word */
case INTERNATIONAL: cmd->international = 1;               break;
/* KJB: new flag to merge syntax onto end of help text */
case ADD_SYNTAX:  cmd->add_syntax = 1;                    break;
default:          if (key >= 0)
                  {
                    errf("invalid in *command(...) context: %s\n",
                         keyword[key]);
                  }
                  do {ch = getch();} while (ch != ')' && ch != EOF);
                  unget(ch);
                  break;
          }
        }
        if (ch != ')')
          errf("missing ')' at end of * command declaration\n", NULL);
        /* if min > max then set max = min */
        if (cmd->min_args > cmd->max_args)
          cmd->max_args = cmd->min_args;
      }
      ch = getch();
    }
    unget(ch);
  }
}

static void read_swi_base()
{
  swi_base = read_number();
}

static void read_swi_handler()
{
  swi_handler = name_of("SWI handler code");
}

static void mk_decode_str(char *name)
{
  struct swi_string *str = (struct swi_string *)
                            malloc(strlen(name) + sizeof(struct swi_string));
  str->prev = swi_decode_str;
  swi_decode_str = str;
  strcpy(str->str, name);
}

static void read_swi_decode_tab()
{
  int ch = ' ';
  char name[NAMESZ];

  while (!iseol(ch))
  {
    if (read_name(name, NAMESZ, NAME))
    {
      ch = skip_spaces();
      if (ch == ',') ch = skip_past_ch();
      unget(ch);
      mk_decode_str(name);
    }
    else
    {
      errf("missing SWI name\n", NULL);
      break;
    }
  }
  unget(ch);
}

static void read_swi_decode_code()
{
  int ch;
  swi_decode_code = name_of("SWI number decoding code");
  ch = skip_spaces();
  if (ch == '/')
      swi_decode2_code = name_of("SWI number to text conversion code");
  else
      unget(ch);
}

static struct irq_handler *read_irq_handler()
{ int ch;
  char *entry_name, *handler_name;
  struct irq_handler *i;
  char name[NAMESZ];
  static char sub_handler[] = "_handler";

  entry_name = name_of("irq/event entry");
  if (entry_name == NULL)  return NULL;
  ch = skip_spaces();
  if (ch == '/')
  {
    if (!read_name(name, NAMESZ, NAME))
    {
      errf("missing irq/event handler name\n", NULL);
      return NULL;
    }
    ch = skip_spaces();
    handler_name = strcpy(malloc(strlen(name)+1), name);
  }
  else
  {
    handler_name = malloc(strlen(entry_name)+sizeof(sub_handler));
    handler_name = strcat(strcpy(handler_name, entry_name), sub_handler);
  }
  unget(ch);
  i = (struct irq_handler *) malloc(sizeof(struct irq_handler));
  i->prev = NULL;
  i->entry_name = entry_name;
  i->handler_name = handler_name;
  return i;
}

static void warn_irq_handlers()
{
  warnf("'irq-handlers' is deprecated; use 'vector-handlers' or 'generic-veneers'\n", NULL);
}

static void read_irq_handlers(int generic)
{
  int ch = ',';
  struct irq_handler *i;

  while (!iseol(ch))
  {
    if (ch == ',') ch = skip_past_ch();
    unget(ch);
    i = read_irq_handler();
    if (i == NULL) return;
    if (generic)
    {
      i->prev = generic_veneers;
      generic_veneers = i;
    }
    else
    {
      i->prev = irq_handlers;
      irq_handlers = i;
    }
    ch = skip_spaces();
  }
  unget(ch);
}

static void read_event_handler()
{
  if ((event_handler = read_irq_handler()) != NULL)
    nfast_events = read_fast_calls(&fast_events);
}

/* SMC: can now replace _clib_initialisemodule with your own code */
static void read_lib_init_code()
{
  lib_init_code = name_of("library initialisation function");
}

/* KJB: can now replace _clib_entermodule with your own code */
static void read_lib_enter_code()
{
  lib_enter_code = name_of("library entry function");
}

/* SMC: can now specify the messages file which contains international help/syntax messages */
static void read_help_file()
{
  help_file = read_text(0);
}

static void read_date()
{
  date_string[0] = skip_spaces();
  fgets(date_string + 1, 11, in);

  /* Check that it is at least of the form "11 xxx 1111" */
  if (!isdigit(date_string[0]) || !isdigit(date_string[1])  || date_string[2] != ' '    ||
      !isalpha(date_string[3]) || !isalpha(date_string[4])  || !isalpha(date_string[5]) ||
      date_string[6] != ' '    || !isdigit(date_string[7])  || !isdigit(date_string[8]) ||
      !isdigit(date_string[9]) || !isdigit(date_string[10]))
  {
      errf("invalid date format\n", NULL);
  }

  if (help_string)
  {
      /* We need to copy the date into the help string... */
      memcpy(strstr(help_string, " (") + 2, date_string, 11);
  }
}

static void parse_directive(int ch)
{
  char buf[256];
  char *quote1, *quote2;

  fgets(buf, sizeof buf, in);
  unget('\n');

  if (ch != '#' || strncmp(buf, "line", 4)) /* Only interested in line directives */
    return;

  quote1 = strchr(buf, '\"');
  if (!quote1) return;
  quote2 = strchr(quote1 + 1, '\"');
  if (!quote2) return;
  *quote2 = '\0';

  /*
   * If this line says '#line n "<our filename>"' then start to process lines from here
   * else if it is '#line n <anything else>' stop processing.
   */
  in_cmhg_file = !strcmp(quote1+1, in_name);

  if (in_cmhg_file)
  {
      sscanf(buf, "line %d", &lineno);
      lineno--;
  }
}

static void parse_statement(int ch)
{
  int key;
  int errs_so_far = nerrs;

  if (ch == '#' || !in_cmhg_file)
  {
      parse_directive(ch);
      return;
  }

  key = read_keyword(ch);

  switch (key)
  {
#if 0
case RUNNABLE:        start_code = bflag ? LIB_START2 : LIB_START1;  break;
#else
case RUNNABLE:        start_code = LIB_START;  break;
#endif
case NOTREENTRANT:    not_re_entrant = 1;      break;
case INIT:            read_init_stmnt();       break;
case FINALISE:        read_finalise_stmnt();   break;
case SERVICE:         read_service_call();     break;
case TITLE:           read_title_string();     break;
case HELP_STR:        read_help_string();      break;
case CMD_TAB:         read_cmd_table();        break;
case SWI_BASE:        read_swi_base();         break;
case SWI_HANDLER:     read_swi_handler();      break;
case SWI_TABLE:       read_swi_decode_tab();   break;
case SWI_CODE:        read_swi_decode_code();  break;
case IRQ_HANDLERS:    warn_irq_handlers();     /* fall through */
case VECTOR_HANDLERS: read_irq_handlers(0);    break;
case EVENT_HANDLER:   read_event_handler();    break;
/* SMC: handle new key words for replacement init code and international help/syntax file */
case LIB_INIT:        read_lib_init_code();    break;
case HELP_FILE:       read_help_file();        break;
/* KJB: handle new date keyword */
case DATE:            read_date();             break;
case LIB_ENTER:       read_lib_enter_code();   break;
case GENERIC_VENEERS: read_irq_handlers(1);  break;
default:
        errf("unrecognised statement type\n", NULL);
        break;
  }
  if (nerrs > errs_so_far)
  {
    do {ch = getch();} while (ch != EOF && !iseol(ch));
    unget(ch);
  }
}

static void parse_input(void)
{
  int ch;
  for (;;)
  {
    ch = skip_spaces();
    if (ch == EOF) break;
    if (!iseol(ch))
    {
      parse_statement(ch);
      ch = skip_spaces();
      if (ch == EOF) break;
    }
    if (!iseol(ch) && in_cmhg_file)
    {
      errf("trailing junk - \n(ignoring \"", NULL);
      do {putc(ch, stderr);  ch = getch();} while (ch != EOF && !iseol(ch));
      fprintf(stderr, "\")\n");
    }
    skip_past_eol(ch);
  }
}

static void align_dot(void)
{
  while ((dot - module_area) & 3) *dot++ = 0;
}

static unsigned32 dot_offset(void)
{
  return (unsigned32) (dot - module_area);
}

static void check_dot(int len)
{
  if (((dot - module_area) + len) > MAX_HEADER_SZ)
  { char size[16];
    sprintf(size, "%u", MAX_HEADER_SZ);
    errf("module header bigger than %s bytes\n", size);
    fatal_error();
  }
}

static unsigned32 save_string(char *s)
{
  unsigned32 offset = 0;
  if (s != NULL)
  { int len = strlen(s) + 1;
    offset = dot_offset();
    check_dot(len);
    strcpy(dot, s);
    dot += len;
  }
  return offset;
}

static unsigned32 save_word(unsigned32 w)
{
  unsigned32 offset = 0;
  align_dot();
  offset = dot_offset();
  check_dot(sizeof(unsigned32));
  *((unsigned32 *)dot) = w;
  dot += sizeof(unsigned32);
  return offset;
}

#define  PCRelative  1
#define  Additive    0

static void cg_command_handler_despatch_table(void)
{ int j, offset, ncommands = 0;
  struct command *c = commands;
  while (c != NULL) {c = c->prev;  ++ncommands;}
 /*
  * Build the entry veneer
  *      MOV     R2, #j
  *      B       handler_veneer...
  * The final B is elided.
  */
#define  MOV_R2_0  0xE3A02000
#define  B_PLUS_2  0xEA000000
#define  B_PLUS_0  0xEAFFFFFE

  j = 0;
  offset = (ncommands - 1)*2 - 2;
  for (;;)
  {
    save_word(MOV_R2_0 | (unsigned32)j);
    ++j;
    if (j == ncommands) break;
    save_word(B_PLUS_2 | (unsigned32)offset);
    offset -= 2;
  }
}

static int valid_arm_constant(unsigned32 n)
{
  for (;;)
  {
    if (n <= 0xff)
      return 1;

    if (n & 3)
      return 0;

    n >>= 2;
  }
}

/*
 * This routine can be used to assemble a sequence of instructions along the
 * line:
 *          MOV r1, #&28
 *          ORR r1, r1, #&40000
 *
 * It is fairly optimal, except for wrapped cases (eg. &80000003)
 */
static void save_inst(unsigned32 cond, unsigned32 inst1, unsigned32 inst2, unsigned c)
{
  unsigned32 r = 32ul << 7;
  int t = 1;

  for (;;)
  {
    if (c == 0)
    {
      if (t)
        save_word(cond | inst1);
      return;
    }

    if (c <= 0xff || c & 3ul)
    {
      save_word(cond | (t ? inst1 : inst2) | (r & 0xf00) | c & 0xfful);
      t = 0;
      c >>= 8;
      r -= 8 << 7;
    }
    else
    {
      c >>= 2;
      r -= 2 << 7;
    }
  }
}

/*
 * This routine assembles fast service filter code as follows:
 *
 *   TEQ   R1,#<simple1>
 *   TEQNE R1,#<simple2>
 *   STMFD R13!,{R14}
 *   MOVNE R14,#<complex3i>
 *   ADDNE R14,R14,#<complex3ii>
 *   TEQNE R1,R14
 *   ADDNE R14,R14,#<complex4-complex3>
 *   TEQNE R1,R14
 *   TEQNE R1,#<simple5>
 *   LDMFD R13!,{PC}^         (or MOVS PC,R14 if no complex constants)
 *
 * As difficult constants are generally bunched together, this will
 * produce tighter code than CMHG 5.02, which would MOV each hard
 * constant from scratch for each TEQ.
 */
#if 1
static void cg_service_call_fast_returns(void)
{
  int j, need_to_push_r14;
  unsigned r14;
#define  AL           0xE0000000ul
#define  NE           0x10000000ul
#define  TEQS_R1_0    0x03310000ul
#define  MOVS_PC_LR   0x01B0F00Eul
#define  PUSH_LR      0x092D4000ul
#define  PULL_PC      0x08FD8000ul
#define  MOV_R14      0x03A0E000ul
#define  ADD_R14_R14  0x028EE000ul
#define  TEQS_R1_R14  0x0131000Eul
  if (nfast_calls == 0) {
    save_word(PUSH_LR | AL);
    return;
  }
  need_to_push_r14 = 1;
  r14 = 0;
  for (j = 0; j < nfast_calls; ++j)
  {
    if (valid_arm_constant(fast_calls[j]))
    {
      save_inst(j ? NE : AL, TEQS_R1_0, 0, fast_calls[j]);
    }
    else
    {
      if (need_to_push_r14)
      {
        save_word(PUSH_LR | AL);
        need_to_push_r14 = 0;
      }
      save_inst(j ? NE : AL, r14 ? ADD_R14_R14 : MOV_R14, ADD_R14_R14, fast_calls[j] - r14);
      save_word(TEQS_R1_R14 | (j ? NE : AL));
      r14 = fast_calls[j];
    }
  }

  if (!need_to_push_r14)
    save_word(PULL_PC | NE);
  else
  {
    save_word(MOVS_PC_LR | NE);
    save_word(PUSH_LR | AL);
  }
}
#else
static void cg_service_call_fast_returns(void)
{ unsigned32 j,t,s;
#define  TEQS_R1_0    0xE3310000
#define  TEQNES_R1_0  0x13310000
#define  MOVNES_PC_LR 0x11B0F00E
#define  PUSH_LR        0xE92D4000
#define  PULLNE_PC      0x18FD8000
#define  MOV_R14        0xE3A0E000
#define  ORR_R14        0xE38EE000
#define  TEQ_R1_R14     0xE131000E
#define  TEQNE_R1_R14   0x1131000E
#define  ADDNE_R14_R14_0 0x128EE000
  if (nfast_calls == 0) {
    save_word(PUSH_LR);                         /* veneer doesn't push R14 */
    return;
  }
  t = 1;

  for (j  = 0;  j < nfast_calls;  ++j)
  { if (fast_calls[j] > 255)
    {
      if (t)  save_word(PUSH_LR);            /* We need R14 as a temp register,
                                                If t =1, then we can't have done a
                                                cal > 255 */

      t=fast_calls[j];
      save_word(MOV_R14 + (t & 255));
      t = t>>8;
      s = 12;                   /* rotate right 12*2 */
      while (t) {
         save_word(ORR_R14 + (t & 255) + (s<<8));
         t = t>>8;
         s = s -4;
      }

      if (j == 0) save_word(TEQ_R1_R14);
      else save_word(TEQNE_R1_R14);

    }
    else {
       if (j == 0)  save_word(TEQS_R1_0 + (unsigned32)fast_calls[j]);
       else save_word(TEQNES_R1_0 + (unsigned32)fast_calls[j]);
    }
  }
  if (!t) save_word(PULLNE_PC);         /* t must be zero if any call no. was over 255 */
  else {
     save_word(MOVNES_PC_LR);
     save_word(PUSH_LR);                /* the veeners require R14 to be stacked, if all
                                           calls are < 256, then this wont have been done */

  }


}
#endif

static void cg_event_handler_fast_returns(void)
{ unsigned32 j, n;
  if (nfast_events == 0) return;
#define  HI           0x80000000
#define  CMPS_R0_255  0x035000FF
#define  TEQS_R0_R0   0x01300000
#define  TEQS_R0_0    0x03300000
  for (j = n = 0;  j < nfast_events;  ++j)
  { if (fast_events[j] > 255)
    { if (n == 0)
        warnf("can't handle a fast event number > 255\n\
(event will be passed to handler)\n", NULL);
      ++n;
    }
  }
  if (n == 0)
  {   save_word(TEQS_R0_0 + (unsigned32)fast_events[0] | AL);
      j = 1;
  }
  else
  {   save_word(CMPS_R0_255 | AL);
      save_word(TEQS_R0_R0 | HI);
      j = 0;
  }
  for (;  j < nfast_events;  ++j)
  { unsigned32 w = fast_events[j];
    if (w <= 255)
      save_word(TEQS_R0_0 + w | NE);
  }
  save_word(MOVS_PC_LR | NE);
}

static void offset_branch_to_base(unsigned32 offset)
{
  int b_offset = *(unsigned32 *)(module_area + offset);
  unsigned32 inst;

  inst = b_offset & 0xff000000ul;

  /* Sign extend... */
  b_offset = (b_offset << 8) >> 8;

  b_offset -= offset / 4;

  *(unsigned32 *)(module_area + offset) = inst | (b_offset & 0x00fffffful);
}

static void save_veneer(const struct veneer *v, const char *name)
{ unsigned32 code = dot_offset(), j;

  for (j = 0;  j < v->code_len / sizeof(unsigned32);  ++j)
      save_word(v->code_start[j]);

  if (name != NULL && v->call_offset != 0xffffffff)
  {
      outaof_relocate(code + v->call_offset,
                      outaof_refsymbol(name),
                      OUTAOF_PCREL);
#ifndef OLD_AOF
      offset_branch_to_base(code + v->call_offset);
#endif
  }

  j = 0;
  for (;;)
  { unsigned32 offset = v->reloc_offset[j++];
    if (offset == 0xffffffff) break;
    outaof_relocate(code + offset, reloc_offset_sym, OUTAOF_ADDITIVE);
  }
}

static void cg_irq_handlers(int generic)
{
  struct irq_handler *h;
  unsigned32 nh, n, *w;

  h = generic ? generic_veneers : irq_handlers;  nh = 0;
  while (h != NULL) {h = h->prev;  ++nh;}
  if (nh >= 60)
  { /*
     * 8-bit immediate constant restriction, with some spare...
     * Allowing 61... requires generating more sophisticated constant
     * descriptions (using shifts) and more collusion with veneers.s.
     */
    errf(generic ?
         "60 or more generic veneers - no generic veneers generated\n" :
         "60 or more IRQ handlers - no IRQ handling code generated\n", NULL);
    return;
  }

  if (event_handler != NULL && !generic)
  { ++nh;
    event_handler->prev = irq_handlers;
    irq_handlers = event_handler;
  }

  if (nh == 0) return;

  /*
   * An IRQ handler consists of:
   * 1)  An entry veneer, the name of which can be used as an argument to a
   *     SWI registering the handler, which jams the IRQ's 'identity' into r2.
   * 2)  A common entry veneer, setting up the C environment.
   * 3)  A despatch on r1 into a table of branches to handlers written in C.
   * 4)  A common exit sequence, returned to by each C-based handler.
   * The entry veneer contains 3 instructions - a STMFD to save some regs;
   * a MOV r0, #n; and a B common_head (omitted from the last one generated).
   *
   * An event handler consists of an optional fast event recognition sequence
   * (like the fast service-call sequence) followed by an event handler.
   *
   * A generic veneer is the same as a IRQ handler, but returns an optional
   * error condition, rather than vector claiming.
   */
  w = (generic ? generic_entry_veneer : irq_entry_veneer).code_start;
  for (h = (generic ? generic_veneers : irq_handlers), n = 0;  h != NULL;  h = h->prev)
  { if (outaof_defsymbol(h->entry_name, dot_offset()) == 0xffffffff)
      errf("duplicate definition of '%s' ignored\n", h->entry_name);
    if (n == 0 && event_handler != NULL && !generic)
      cg_event_handler_fast_returns();
    save_word(w[0]);                        /* STMFD sp!, {...} */
    save_word(w[1] + n*4);                  /* MOV   r2, #n*4   */
    if (++n == nh) break;
    save_word(B_PLUS_2 + (nh - n) * 3 - 2); /* B    common_head */
  }

  /*
   * Save the common head veneer.
   * In this case, the call offset denotes not a BL to be PCRelative-relocated,
   * but a literal add of the size of the despatch table (to the return link
   * used by the C function fespatched to). Earlier we ensured that nh is small
   * enough to allow this to be done naively.
   */
  n = dot_offset();
  save_veneer(generic ? &generic_common_head_veneer : &irq_common_head_veneer, NULL);
  w = (unsigned32 *) (module_area + n + (generic ? generic_common_head_veneer : irq_common_head_veneer).call_offset);
  *w += nh*4;

  /*
   * Now generate the despatch table... each entry is a branch to a C fn...
   */
  for (h = generic ? generic_veneers : irq_handlers;  h != NULL;  h = h->prev)
  {
    outaof_relocate(dot_offset(),
                    outaof_refsymbol(h->handler_name),
                    OUTAOF_PCREL);
#ifdef OLD_AOF
    save_word(B_PLUS_2);
#else
    save_word(B_PLUS_0 - dot_offset() / 4);
#endif
  }
  /* ... and, finally, save the common exit veneer */
  save_veneer(generic ? &generic_common_tail_veneer : &irq_common_tail_veneer, NULL);
}

static void write_defs_file(void)
{ FILE *f;
  UnparsedName un;
  char buf[512];

  if (defs_file == NULL) return;

#ifdef OLD_AOF
  fname_parse(defs_file, FNAME_ORDERTYPE, SUFFIXES, &un);

  fname_unparse(&un, FNAME_ORDERTYPE, buf, sizeof buf);
#else
  fname_parse(defs_file, SUFFIXES, &un);

  fname_unparse(&un, FNAME_AS_NAME, buf, sizeof buf);

  /*
   * If no extension, then we're probably going to a scrap file via !CMHG.
   * Use the define __cmhg_<source root>_h instead, as this is better than
   * __cmhg_x342ab312.
   */
  if (un.extn == NULL)
  {
      fname_parse(in_name, SUFFIXES, &un);
      un.elen = 1;
      un.extn = "h";
  }
#endif

  f = fopen(buf, "w");
  if (f == NULL)
  { errf("can't create #definitions file %s\n", buf);
    return;
  }
  fprintf(f, "/*\n * Created by %s vsn %s [%s]\n */\n\n",
             SELF, VERSION, __DATE__);

  sprintf(buf, "__%s_%.*s_%.*s", SELF, un.rlen, un.root, un.elen, un.extn);

  fprintf(f, "#ifndef %s\n#define %s\n\n", buf, buf);

  fprintf(f, "#ifndef __kernel_h\n"
             "#include \"kernel.h\"\n"
             "#endif\n\n");

  fprintf(f, "#define CMHG_VERSION %d\n\n", VERSION_NUM);

  fprintf(f, "#define Module_Title                     \"%s\"\n"
             "#define Module_Help                      \"%.*s\"\n"
             "#define Module_VersionString             \"%s\"\n"
             "#define Module_VersionNumber             %d\n"
             "#define Module_Date                      \"%s\"\n",
             title_string,
             strchr(help_string, '\t')-help_string, help_string,
             version_string,
             (version_string[0]-'0')*100 + (version_string[2]-'0')*10 + version_string[3]-'0',
             date_string);

  if (help_file)
    fprintf(f, "#define Module_MessagesFile              \"%s\"\n",
               help_file);

  if (start_code)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * Start code\n"
               " * ==========\n"
               " *\n"
               " * Entered in user-mode with argc and argv\n"
               " * set up as for any other application. Malloc\n"
               " * obtains storage from application workspace.\n"
               " */\n"
               "int main(int argc, char *argv[]);\n"
           );
  }

  if (init_code)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * Initialisation code\n"
               " * ===================\n"
               " *\n"
               " * Return NULL if your initialisation succeeds; otherwise return a pointer\n"
               " * to an error block. cmd_tail points to the string of arguments with which\n"
               " * the module is invoked (may be \"\", and is control-terminated, not zero\n"
               " * terminated).\n"
               " * podule_base is 0 unless the code has been invoked from a podule.\n"
               " * pw is the 'R12' value established by module initialisation. You may\n"
               " * assume nothing about its value (in fact it points to some RMA space\n"
               " * claimed and used by the module veneers). All you may do is pass it back\n"
               " * for your module veneers via an intermediary such as SWI OS_CallEvery\n"
               " * (use _swix() to issue the SWI call).\n"
               " */\n"
               "_kernel_oserror *%s(const char *cmd_tail, int podule_base, void *pw);\n"
            , init_code);
  }

  if (final_code)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * Finalisation code\n"
               " * =================\n"
               " *\n"
               " * Return NULL if your finalisation succeeds. Otherwise return a pointer to\n"
               " * an error block if your finalisation handler does not wish to die (e.g.\n"
               " * toolbox modules return a 'Task(s) active' error).\n"
               " * fatal, podule and pw are the values of R10, R11 and R12 (respectively)\n"
               " * on entry to the finalisation code.\n"
               " */\n"
               "_kernel_oserror *%s(int fatal, int podule, void *pw);\n"
            , final_code);
  }

  if (service_call_handler)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * Service call handler\n"
               " * ====================\n"
               " *\n"
               " * Return values should be poked directly into r->r[n]; the right\n"
               " * value/register to use depends on the service number (see the relevant\n"
               " * RISC OS Programmer's Reference Manual section for details).\n"
               " * pw is the private word (the 'R12' value).\n"
               " */\n"
               "void %s(int service_number, _kernel_swi_regs *r, void *pw);\n"
            , service_call_handler);
  }

  if (command_handler)
  {
    struct command *c;
    int ncommands;

    fprintf(f, "\n\n"
               "/*\n"
               " * Command handler\n"
               " * ===============\n"
               " *\n"
               " * If cmd_no identifies a command, then arg_string gives the command tail\n"
               " * (which you may not overwrite), and argc is the number of parameters.\n"
               " * Return NULL if the command has been successfully handled; otherwise\n"
               " * return a pointer to an error block describing the failure (in this\n"
               " * case, the veneer code will set the 'V' bit).\n"
               " *\n"
               " * If cmd_no identifies a *Help entry, then arg_string denotes a buffer\n"
               " * that you can assemble your output into. cmd_handler must return\n"
               " * NULL, an error pointer or help_PRINT_BUFFER (if help_PRINT_BUFFER)\n"
               " * is returned, the zero-terminated buffer will be printed).\n"
               " *\n"
               " * If cmd_no identifies a *Configure option, then arg_string gives the\n"
               " * command tail, and argc the number of parameters. Return NULL, an error\n"
               " * pointer, or one of the four special values defined below. If arg_string\n"
               " * is set to arg_CONFIGURE_SYNTAX, the user has typed *Configure with no\n"
               " * parameter; simply print your syntax string. If arg_string is set to\n"
               " * arg_STATUS, print your current configured status. Otherwise use\n"
               " * arg_string and argc to set the *Configure option.\n"
               " *\n"
               " * pw is the private word pointer ('R12') value passed into the entry\n"
               " * veneer\n"
               " */\n"
               "#define help_PRINT_BUFFER         ((_kernel_oserror *) arg_string)\n"
               "#define arg_CONFIGURE_SYNTAX      ((char *) 0)\n"
               "#define arg_STATUS                ((char *) 1)\n"
               "#define configure_BAD_OPTION      ((_kernel_oserror *) -1)\n"
               "#define configure_NUMBER_NEEDED   ((_kernel_oserror *) 1)\n"
               "#define configure_TOO_LARGE       ((_kernel_oserror *) 2)\n"
               "#define configure_TOO_MANY_PARAMS ((_kernel_oserror *) 3)\n\n"
            );

    for (c = commands, ncommands = 0; c; c = c->prev, ++ncommands)
      fprintf(f, "#define CMD_%-26s  %d\n", c->name, ncommands);

    fprintf(f, "%s_kernel_oserror *%s(const char *arg_string, int argc, int cmd_no, void *pw);\n"
            , commands ? "\n" : "", command_handler);
  }

  if (swi_handler && swi_base)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * SWI handler code\n"
               " * ================\n"
               " *\n"
               " * swi_offset contains the offset of the SWI into your SWI chunk.\n"
               " * r points to the registers passed to the SWI.\n"
               " *\n"
               " * Return NULL if the SWI is handled successfully; otherwise return\n"
               " * a pointer to an error block which describes the error.\n"
               " * The veneer code sets the 'V' bit if the returned value is non-NULL.\n"
               " * The special value error_BAD_SWI may be returned if you do not\n"
               " * implement a SWI; the veneer will arrange for the appropriate\n"
               " * standard internationalised error 'SWI value out of range for\n"
               " * module %s' to be returned.\n"
               " * The handler may update any of its input registers (R0-R9).\n"
               " * pw is the private word pointer ('R12') value passed into the\n"
               " * SWI handler entry veneer.\n"
               " */\n"
            , title_string
            );

    if (swi_decode_str)
    {
      unsigned32 swi_no;
      struct swi_string *s;
      char *base_name;
      char buf[64];

      base_name = swi_decode_str->str;
      sprintf(buf, "%.30s_00", base_name);
      fprintf(f, "#define %-30s  0x%.6lx\n", buf, swi_base);

      fprintf(f, "#ifndef %.30s_%.30s\n", base_name, swi_decode_str->prev->str);

      for (s = swi_decode_str->prev, swi_no = swi_base; s; s = s->prev, ++swi_no)
      { sprintf(buf, "%.30s_%.30s", base_name, s->str);
        fprintf(f, "#define %-30s  0x%.6lx\n"
                 , buf, swi_no);
      }
      fprintf(f, "#endif\n\n");
    }
    fprintf(f, "#define error_BAD_SWI ((_kernel_oserror *) -1)\n"
               "\n"
               "_kernel_oserror *%s(int swi_offset, _kernel_swi_regs *r, void *pw);\n"
               , swi_handler);
  }

  if (swi_decode_code)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * SWI decoding code\n"
               " * =================\n"
               " *\n");
    if (swi_decode2_code)
    {
      fprintf(f,
               " * For the text->number converter, string points to the name to convert\n"
               " * (terminated by a control character). If the SWI is recognised, return\n"
               " * the offset into the chunk (0-63), otherwise return <0.\n"
               " *\n"
               " * For the number->text converter:\n"
               " *   swi_no is the offset (0..63) of the SWI within the SWI chunk.\n"
               " *   buffer is a pointer to a buffer;\n"
               " *   offset is the offset within the buffer at which to place the text;\n"
               " *   size is the length of the buffer.\n"
               " * You should write the SWI name into the buffer at the position given\n"
               " * by offset, then return offset updated by the length of the text\n"
               " * written (excluding any terminating NUL, if you add one). If you don't\n"
               " * have a name for the SWI, just return offset, unaltered.\n"
               " *\n"
               " * pw is the priate word pointer ('R12') passed into the entry veneer.\n"
               " */\n"
               "int %s(const char *string, void *pw);\n"
               "int %s(int swi_no, char *buffer, int offset, int end, void *pw);\n"
             , swi_decode_code, swi_decode2_code);
    }
    else
    {
      fprintf(f,
               " * On entry, r[0] < 0 means a request to convert from text to a number.\n"
               " * In this case r[1] points to the string to convert (terminated by a\n"
               " * control character, NOT necessarily by NUL).\n"
               " * Set r[0] to the offset (0..63) of the SWI within the SWI chunk if\n"
               " * you recognise its name; set r[0] < 0 if you don't recognise the name.\n"
               " *\n"
               " * On entry, r[0] >= 0 means a request to convert from a SWI number to\n"
               " * a SWI string:\n"
               " *   r[0] is the offset (0..63) of the SWI within the SWI chunk.\n"
               " *   r[1] is a pointer to a buffer;\n"
               " *   r[2] is the offset within the buffer at which to place the text;\n"
               " *   r[3] is the length of the buffer.\n"
               " * You should write the SWI name into the buffer at the position given\n"
               " * by r[2] then update r[2] by the length of the text written (excluding\n"
               " * any terminating NUL, if you add one).\n"
               " *\n"
               " * pw is the private word pointer ('R12') passed into the entry veneer.\n"
               " *\n"
               " * For a more elegant interface, supply a pair of '/'-separated function\n"
               " * names to CMHG's swi-decoding-code command.\n"
               " */\n"
               "void %s(int r[4], void *pw);\n"
            , swi_decode_code);
    }
  }

  if (generic_veneers)
  {
    struct irq_handler *i;
    int plural = generic_veneers -> prev ? 1 : 0;

    fprintf(f, "\n\n"
               "/*\n"
               " * Generic veneers\n"
               " * ===============\n"
               " *\n"
               " * Th%s of the generic entry veneer%s compiled by CMHG.\n"
               " * Use th%s as an argument to, for example, SWI OS_CallEvery\n"
               " * or OS_AddCallBack.\n"
               " *\n"
               " * These veneers ensure that your handlers preserve R0-R11\n"
               " * and the processor flags (unless you return an error pointer.\n"
               " * The veneer can be entered in either IRQ or SVC mode. R12 and\n"
               " * R14 are corrupted.\n"
               " */\n"
             , plural ? "ese are the names" : "is is the name",
               plural ? "s" : "",
               plural ? "ese names" : "is name");

    for (i = generic_veneers; i; i = i->prev)
       fprintf(f, "extern void %s(void);\n", i->entry_name);

    fprintf(f, "\n"
               "/*\n"
               " * Th%s the handler function%s that the veneer%s declared above\n"
               " * call%s.\n"
               " *\n"
               " * For a standard exit, return NULL. For handlers that can return an\n"
               " * error, return an error block pointer, and the veneer will set the\n"
               " * 'V' bit, and set R0 to the error pointer.\n"
               " *\n"
               " * 'r' points to a vector of words containing the values of R0-R9 on\n"
               " * entry to the veneer. If r is updated, the updated values will be\n"
               " * loaded into R0-R9 on return from the handler.\n"
               " *\n"
               " * pw is the private word pointer ('R12') value with which the\n"
               " * entry veneer is called.\n"
               " */\n",
               plural ? "ese are" : "is is",
               plural ? "s" : "",
               plural ? "s" : "",
               plural ? "" : "s");

    for (i = generic_veneers; i; i = i->prev)
       fprintf(f, "_kernel_oserror *%s(_kernel_swi_regs *r, void *pw);\n", i->handler_name);
  }

  if (irq_handlers)
  {
    struct irq_handler *i;
    int plural = irq_handlers -> prev ? 1 : 0;

    fprintf(f, "\n\n"
               "/*\n"
               " * Vector handlers\n"
               " * ===============\n"
               " *\n"
               " * Th%s of the vector handler entry veneer%s\n"
               " * compiled by CMHG. Use th%s as an argument to SWI\n"
               " * OS_Claim. (EventV claimants should use a CMHG event handler).\n"
               " *\n"
               " * Note that vector handlers were previously called IRQ handlers\n"
               " * and were documented as being for attaching to IrqV. IrqV has\n"
               " * long being deprecated; you should use OS_ClaimDeviceVector and\n"
               " * a CMHG generic veneer instead.\n"
               " */\n"
             , plural ? "ese are the names" : "is is the name",
               plural ? "s" : "",
               plural ? "ese names" : "is name");

    for (i = irq_handlers; i; i = i->prev)
       fprintf(f, "extern void %s(void);\n", i->entry_name);

    fprintf(f, "\n"
               "/*\n"
               " * Th%s the handler function%s you must write to handle the\n"
               " * vector%s for which %s%s the veneer function%s.\n"
               " *\n"
               " * If a handler function is installed onto a vector, then:\n"
#if 0
               " *   Return NULL to intercept the call.\n"
               " *   Return vector_PASS_ON to pass on the call.\n"
               " *   Return an error pointer to intercept the call and return\n"
               " *   an error.\n"
#else
               " *   Return 0 to intercept the call.\n"
               " *   Return 1 to pass on the call.\n"
#endif
               " * If you use a vector handler veneer for any other purpose, always\n"
               " * return non-0, and consider the use of a generic veneer instead.\n"
               " * It is not currently possible to return an error from a vector\n"
               " * handler.\n"
               " *\n"
               " * 'r' points to a vector of words containing the values of R0-R9 on\n"
               " * entry to the veneer. If r is updated, the updated values will be\n"
               " * loaded into R0-R9 on return from the handler.\n"
               " *\n"
               " * pw is the private word pointer ('R12') value with which the\n"
               " * vector entry veneer is called.\n"
               " */\n",
               plural ? "ese are" : "is is",
               plural ? "s" : "",
               plural ? "s" : "",
               irq_handlers->entry_name,
               plural ? ", etc. are" : " is",
               plural ? "s" : "");

    for (i = irq_handlers; i; i = i->prev)
       fprintf(f, "int %s(_kernel_swi_regs *r, void *pw);\n", i->handler_name);
  }

  if (event_handler)
  {
    fprintf(f, "\n\n"
               "/*\n"
               " * Event handler\n"
               " * =============\n"
               " *\n"
               " * This is the name of the event handler entry veneer compiled by CMHG.\n"
               " * Use this name as an argument to, for example, SWI OS_Claim, in\n"
               " * order to attach your handler to EventV.\n"
               " */\n"
    	       "extern void %s(void);\n"
               "\n"
               "/*\n"
               " * This is the handler function you must write to handle the event for\n"
               " * which %s is the veneer function.\n"
               " *\n"
               " * Return 0 if you wish to claim the event.\n"
               " * Return 1 if you do not wish to claim the event.\n"
               " *\n"
               " * 'r' points to a vector of words containing the values of R0-R9 on\n"
               " * entry to the veneer. If r is updated, the updated values will be\n"
               " * loaded into R0-R9 on return from the handler.\n"
               " *\n"
               " * pw is the private word pointer ('R12') value with which the event\n"
               " * entry veneer is called.\n"
               " */\n"
               "int %s(_kernel_swi_regs *r, void *pw);\n"
             , event_handler->entry_name,
               event_handler->entry_name,
               event_handler->handler_name);
  }

  fprintf(f, "\n#endif\n");
  fclose(f);
}

static void write_output(char *out_name)
{ struct module_header *mh;
  FILE *out;
  UnparsedName un;
  char buf[512];

  if (title_string == NULL)
    errf("no title string given\n", NULL);
  else if (help_string == NULL)
    errf("no help string given\n", NULL);

  /*
   * Allocate some space to build the module header in and
   * initialise the module header.
   */
  mh = (struct module_header *) (dot = module_area = calloc(1, MAX_HEADER_SZ));
  dot += sizeof(struct module_header);

  /*
   * Leave out all the optional header fields
   */
  if (!help_file)
  {
    dot -= sizeof mh->international_help_file;
    if (!swi_decode_code)
    {
      dot -= sizeof mh->swi_decoding_code;
      if (!swi_decode_str)
      {
        dot -= sizeof mh->swi_decoding_table;
        if (!swi_handler)
          dot -= sizeof mh->swi_handler_code + sizeof mh->swi_chunk_base;
      }
    }
  }

  reloc_offset_sym = outaof_refsymbol(RELOC_OFFSET_SYM);

  /*
   * Add the title string and the help string.
   */
  mh->title_string = save_string(title_string);
  mh->help_string  = save_string(help_string);

  /*
   * Add the SWI decoding table if there is one...
   */
  if (swi_decode_str != NULL)
  { struct swi_string *s = swi_decode_str, *next, *prev;
    next = NULL;
    while (s != NULL)
    {
      prev = s->prev; s->prev = next;  next = s;  s = prev;
    }
    mh->swi_decoding_table = dot_offset();
    swi_decode_str = s = next;
    while (s != NULL) {save_string(s->str);  s = s->prev;}
    save_string("");
  }

  /*
   * Add the command table text messages - if there are any
   */
  if (commands != NULL)
  { struct command *c = commands, *next, *prev;
    unsigned32 offset = 0;
    next = NULL;
    while (c != NULL)
    {
      prev = c->prev; c->prev = next;  next = c;
      if (c->add_syntax)
      {
        char *merged;
        merged = malloc(strlen(c->help_text) + strlen(c->invalid_syntax_msg) + 1);
        sprintf(merged, "%s%s", c->help_text, c->invalid_syntax_msg);
        c->help_text_offset = save_string(merged);
        c->invalid_syntax_offset = c->help_text_offset + strlen(c->help_text);
        free(merged);
      }
      else
      {
        c->invalid_syntax_offset = save_string(c->invalid_syntax_msg);
        c->help_text_offset = save_string(c->help_text);
      }
      offset += (unsigned32) (4*sizeof(long)) +
                (unsigned32) ((strlen(c->name) + 4UL) & ~3UL);
      c = prev;
    }
    commands = next;
    align_dot();
    offset += (mh->command_table = dot_offset());
    for (c = next;  c != NULL;  c = c->prev)
    {
      save_string(c->name);
      align_dot();
      save_word(offset);
      offset += 8UL;
      /* Hack here allows neater code elsewhere */
      save_word(info_word(c));
      save_word(c->invalid_syntax_offset);
      if (c->help)
        save_word(offset-8UL);
      else
	save_word(c->help_text_offset);
    }
    cg_command_handler_despatch_table();
    save_veneer(&cmd_handler_veneer, command_handler);
  }

  if (help_file)
    mh->international_help_file = save_string(help_file);       /* SMC: add the international help/syntax file name */

  align_dot();  /* in case there was no command table */

  /* write out the defs file, if there is one */
  write_defs_file();

  /*
   * Add the service-call handler, if there is one...
   */
  if (service_call_handler != NULL)
  {
    mh->service_call_handler = dot_offset();
    cg_service_call_fast_returns();
    save_veneer(&service_call_veneer, service_call_handler);
  }

  /*
   * ... and the start code, if the module is runnable...
   */
  if (start_code != NULL)
  {
#ifdef SYSTEM_STATICS
    if (sys_statics)
        errf("module built using -system cannot be runnable\n", "");
#endif
    mh->start_code = dot_offset();
    if (lib_enter_code != NULL)
      save_veneer(&b_veneer, lib_enter_code);
    else
      save_veneer(&b_veneer, start_code);
  }

  /*
   * ... and the initialisation and finalisation code...
   */
  mh->init_code = dot_offset();
  /* SMC: check to see if there is a replacement library initialisation entry point */
  if (lib_init_code != NULL)
    save_veneer(&initialise_lib_veneer, lib_init_code);
  else
#ifdef SYSTEM_STATICS
    save_veneer(&initialise_lib_veneer, sys_statics ? SYS_INITIALISE : LIB_INITIALISE);
#else
    save_veneer(&initialise_lib_veneer, LIB_INITIALISE);
#endif
  if (not_re_entrant)
  { /* a filthy bit of collusion between CMHG and s.veneers... */
    *(module_area + mh->init_code + initialise_lib_veneer.call_offset - 4) = 0;
  }
  if (init_code != NULL) {
      save_veneer(&initialise_user_veneer, init_code);
  } else
      save_veneer(&initialise_end_veneer, NULL);
  if (final_code != NULL) {
      mh->final_code = dot_offset();
      save_veneer(&finalise_user_veneer, final_code);
#ifdef SYSTEM_STATCIS
      if (sys_statics)
          save_veneer(&finalise_sys_veneer, NULL);
      else
#endif
          save_veneer(&finalise_end_veneer, LIB_FINALISE);
  }
  else
#ifdef SYSTEM_STATICS
  if (!sys_statics)
#endif
  {
      mh->final_code = dot_offset();
      save_veneer(&finalise_lib_veneer, LIB_FINALISE);
  }

  /*
   * ... and the SWI handler, if there is one...
   */
  if (swi_handler != NULL)
  {
    unsigned32 *p, *t, o;
    extern int swi_handler_veneer_modname_reloc_offset;
    extern int swi_handler_veneer_adrtoken_offset;

    mh->swi_chunk_base = swi_base;
    mh->swi_handler_code = dot_offset();
    save_veneer(&swi_handler_veneer, swi_handler);

    /*
     * Munge the relocation for the BadSWI error return code.
     * We need to alter a long adr to point to the module
     * title. If it needn't be long, knock out the second
     * instruction; but then we need to shorten another ADR
     * across the ADRL.
     */
    p = (unsigned32 *)(module_area + mh->swi_handler_code +
                       swi_handler_veneer_modname_reloc_offset);
    t = (unsigned32 *)(module_area + mh->title_string);
    o = p - t + 2ul;
    p[0] += o & 0xFF;
    if (o >= 0x100)
      p[1] += (p - t + 2ul) >> 8;  /* relocate second ADRL word */
    else
    {
      /* remove second ADRL word */
      memmove(p+1, p+2, dot - (char *)(p+2));
      dot -= 4;
      /* shrink the ADR r0,BadSwiToken */
      p = (unsigned32 *)(module_area + mh->swi_handler_code +
                         swi_handler_veneer_adrtoken_offset);
      *p -= 4;
    }
  }

  /*
   * ... SWI decode code does SWI-number <--> SWI-string conversion...
   */
  if (swi_decode_code != NULL)
  {
    mh->swi_decoding_code = dot_offset();
    if (swi_decode2_code != NULL)
    {
      save_veneer(&swi_decode2_start_veneer, swi_decode_code);
      save_veneer(&swi_decode2_end_veneer, swi_decode2_code);
    }
    else
      save_veneer(&swi_decode_veneer, swi_decode_code);
  }

  /*
   * And, finally, deal with the IRQ handlers if there are any.
   * This is a Big Deal, so the 'code generation' is separated.
   */
  cg_irq_handlers(0);
  /*
   * And the generic veneers...
   */
  cg_irq_handlers(1);

  /*
   * Finally, output the AOF file... but only if all so far is OK...
   */
  if (nerrs !=0 || out_name == NULL) return;

#ifdef OLD_AOF
  fname_parse(out_name, FNAME_ORDERTYPE, SUFFIXES, &un);
  fname_unparse(&un, FNAME_ORDERTYPE, buf, sizeof buf);
#else
  fname_parse(out_name, SUFFIXES, &un);
  fname_unparse(&un, FNAME_AS_NAME, buf, sizeof buf);
#endif

  out = fopen(buf, "wb");
  if (out == NULL)
  {
    errf("can't write to output file %s\n", buf);
    return;
  }
#ifdef NOTYET
  outaof_fwrite(module_area, dot_offset(), banner_string, reent_flag, out);
#else
  outaof_fwrite(module_area, dot_offset(), banner_string, out);
#endif
  fclose(out);
}

static void give_help(void)
{ int n;
  FILE *e = stderr;

  fputc('\n', e);
  n = fprintf(e, "%s vsn %s [%s] - ", SELF, VERSION, __DATE__);
  fprintf(e, "make a RISC OS module header\n");
  while (n-- > 0) fputc(' ', e);
  fprintf(e, "for a module written in C.\n\n");
  fprintf(e, "Usage: %s [options] infile [objectfile [defs-file]]\n\n", SELF);
  fprintf(e, "Keyword options:\n\n");
  fprintf(e, "-help           Output this information\n");
  fprintf(e, "-o <file>       Name the <file> that will hold the final object file\n");
  fprintf(e, "-d <file>       Name a C header <file> that CMHG will generate\n");
  fprintf(e, "-p              Preprocess the input file using the C preprocessor\n");
  fprintf(e, "-I<directory>   Include <directory> on the #include search path\n");
  fprintf(e, "-D<symbol>=<value>\n");
  fprintf(e, "-D<symbol>      Define <symbol> on entry to the preprocessor\n");
  fprintf(e, "-depend <file>  Output 'make' include file dependency information to <file>\n");
  fprintf(e, "-throwback      Support error processing by Desktop Tools\n");
#ifdef NOTYET
  fprintf(e, "-reent          C object files were compiled using -APCS 3/reent, not -zM\n");
#endif
}

static void remove_temp(void)
{
    remove(temp_file);
}

int main(int argc, char *argv[])
{
  int j, preprocess_flag = 0;
  UnparsedName un;
  char *out_name = NULL;
  char *to_parse, *depend_file = "";
  char defines[128];

  defines[0]='\0';

  for (j = 1;  j < argc;  ++j)
  { char *arg = argv[j];
    if (arg[0] == '-') switch(arg[1])
    {
case 'h':
case 'H':
        give_help();
        return OK;
        break;
#ifdef SYSTEM_STATICS
case 's':
case 'S':
        sys_statics = 1;
        break;
#endif
case 'o':
        ++j;
        if (argv[j])
            out_name = argv[j];
        else
            errf("no filename on -o flag\n", "");
        break;
case 'd':
    	if (strcmp(arg+2, "epend") == 0)
    	{
    	    ++j;
    	    depend_file = argv[j];
    	}
    	else
    	{
            ++j;
            if (argv[j])
                defs_file = argv[j];
            else
                errf("no filename on -d flag\n", "");
        }
        break;
#if 1
case 'b':
case 'B':
        /*
         * XXX
         *
         * BODGE BODGE BODGE
         *
         * Hack cmhg to generate references to blib_entermodule
         * rather than clib_entermodule.  This allows use of
         * Brian Brunswick's hacked startup code for ShareFS
         * to be built in correctly.
         */
        lib_enter_code = "_blib_entermodule";
        warnf("The -b flag is deprecated. Use the library-enter-code instead.\n", NULL);
        break;
#else
case 'b':
case 'B':
        errf("The -b flag has been withdrawn. Use library-enter-code instead.\n", NULL);
        break;
#endif
case 'D':
    	strcat(defines, " -D");
        if (arg[2] != '\0')
            strcat(defines, arg + 2);
        else
            strcat(defines, argv[++j]);
        break;
case 'i':
case 'I':
        /*
         * Get the include path for the preprocessor (allow both
         * "-I C:" and "-IC:")
         */
        if (arg[2] != '\0')
            include_path = arg + 2;
        else
            include_path = argv[++j];
        break;
case 'p':
        preprocess_flag = 1;
        break;
case 't':
        throwback_flag = 1;
        break;
#ifdef NOTYET
case 'r':
        reent_flag = 1;
        break;
#endif
default:
        errf("unrecognised flag %s (try -h for help)\n", arg);
        break;
    }
    else if (in_name == NULL)
    {
      in_name = arg;
    }
    else if (out_name == NULL)
    {
      out_name = arg;
    }
    else if (defs_file == NULL)
    {
      defs_file = arg;
    }
    else
    {
      errf("extraneous file argument %s ignored\n", arg);
    }
  }

  if (in_name == NULL)
  {
    errf("no input given\n", NULL);
  }

  if (nerrs) return BAD;

#ifdef OLD_AOF
  fname_parse(in_name, FNAME_ORDERTYPE, SUFFIXES, &un);
  fname_unparse(&un, FNAME_ORDERTYPE, in_name_buffer, sizeof in_name_buffer);
#else
  fname_parse(in_name, SUFFIXES, &un);
  fname_unparse(&un, FNAME_AS_NAME, in_name_buffer, sizeof in_name_buffer);
#endif
  in_name = in_name_buffer;

  if (preprocess_flag)
  {
      char cmd[256];
      int rc;

      tmpnam(temp_file);

      /*
       * The C++ flag stops cc trying to look inside any ".c" directories.
       * defines contains all "-D" defines, prefixed by a space.
       */
      sprintf(cmd, "cc -C++ -E %s%s %s%s -I%s %s > %s",
                   depend_file[0] ? "-depend " : "",
                   depend_file,
                   throwback_flag ? "-throwback": "",
                   defines, include_path, in_name, temp_file);
      rc = system(cmd);

      if (rc == _kernel_ERROR)
      {
        fprintf(stderr, "*** %s ***\n", _kernel_last_oserror()->errmess);
        return BAD;
      }
      else if (rc != 0)
      {
        remove(temp_file);
        return rc;
      }

      atexit(remove_temp);

      to_parse = temp_file;
  }
  else
  {
      to_parse = in_name;
      in_cmhg_file = 1;
  }

  in = fopen(to_parse, "r");
  if (in == NULL)
  {
    errf("can't read input file %s\n", in_name);
    return BAD;
  }
  lineno = 1;
  parse_input();
  fclose(in);

  lineno = 0;
  outaof_init();
  write_output(out_name);

  return (nerrs ? BAD : OK);
}
