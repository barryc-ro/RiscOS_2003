/*
 * outaof - Output of AOF.
 * Copyright (C) Acorn Computers 1989.
 */

#include <stdlib.h>
#include <string.h>
#include "h.outaof"
#ifdef OLD_AOF
#include "objflfmt.h"
#include "chunkflfmt.h"
#else
#include "aof.h"
#include "chunkfmt.h"
#endif

#define  AREANAME    "!!!Module$$Header"
#define  MODULESYM   "__module_header"

static char areaname[] = AREANAME;
static char vsn_prefix[] = "Generated by ";

struct reloc
{
  struct reloc *next;
  unsigned32 offset;
  unsigned32 symbol;
  int type;
};

struct symbol
{
  struct symbol* next;
  unsigned32 index;
  unsigned32 value;
  char name[4];
};

struct generic_list
{
  struct generic_list *next;
  /* other fields... */
};

static struct symbol *symbols;
static struct reloc  *relocs;
static unsigned32 nsymbols, nrelocs;

static struct symbol *find_symbol(const char *name)
{ struct symbol *s = symbols;
  while (s != NULL)
  {
    if (strcmp(s->name, name) == 0) return s;
    s = s->next;
  }
  s = (struct symbol *) malloc(sizeof(struct symbol) + strlen(name));
  s->next = symbols;
  s->index = nsymbols++;
  s->value = 0xffffffff;
  strcpy(s->name, name);
  symbols = s;
  return s;
}

unsigned32 outaof_refsymbol(const char *name)
{
  return find_symbol(name)->index;
}

unsigned32 outaof_defsymbol(const char *name, unsigned32 offset)
{ struct symbol *s = find_symbol(name);
  if (s->value == 0xffffffff)
  {
    s->value = offset;
    return s->index;
  }
  return 0xffffffff;  /* error */
}

void outaof_relocate(unsigned32 offset, unsigned32 sym, int type)
{ struct reloc *r = (struct reloc *) malloc(sizeof(struct reloc));
  r->offset = offset;
  r->symbol = sym;
  r->type   = type;
  r->next   = relocs;
  relocs    = r;
  ++nrelocs;
}

static void mk_cfentry(cf_entry *e, char *key, int32 offset, int32 size)
{
  strncpy(e->cfe_key, key, sizeof(e->cfe_key));
  e->cfe_offset = offset;
  e->cfe_size = size;
}

static int32 strtlen(void)
{ struct symbol *s = symbols;
  int32 len = 4L + (int32) strlen(areaname) + 1L;
  while (s != NULL)
  {
    len += (int32) strlen(s->name) + 1L;
    s = s->next;
  }
  return (len + 3L) & ~3L;
}

static void reverse(void **list_head)
{ struct generic_list *l = *list_head, *n, *p;
  p = NULL;
  while (l != NULL)
  {
    n = l->next;  l->next = p;  p = l;  l = n;
  }
  *list_head = p;
}

static void out_relocs(FILE *f)
{ struct reloc *r;
#ifdef OLD_AOF
  aof_reloc1 ar;
#else
  aof_reloc ar;
#endif

  for (r = relocs;  r != NULL;  r = r->next)
  {
    ar.rel_offset = r->offset;
#ifdef OLD_AOF
    ((int32 *)(&ar))[1] = 0L;
    ar.rel_sid    = (int)(r->symbol);
    ar.rel_FT     = 2;
    if (r->type == OUTAOF_PCREL)
      ar.rel_R = 1;
    else
      ar.rel_A = 1;
#else
    ar.rel_flags = (int)(r->symbol);
    ar.rel_flags |= REL_TYPE2;
    if (r->type == OUTAOF_PCREL)
      ar.rel_flags |= REL_R | REL_A | REL_INSTR;
    else
      ar.rel_flags |= REL_A | REL_LONG;
#endif
    fwrite(&ar, sizeof(ar), 1, f);
  }
}

static void out_symt_and_strt(FILE *f)
{ struct symbol * s;
  int32 strt_offset = 4L + (int32) strlen(areaname) + 1L;
  int32 strt_len;
  aof_symbol as;

  for (s = symbols;  s != NULL;  s = s->next)
  {
    memset(&as, 0, sizeof(as));
    as.sym_name = strt_offset;
    if (s->value != 0xffffffff)
    {
      as.sym_AT = SYM_GLOBALDEFAT;
      as.sym_value = s->value;
      as.sym_areaname = 4L;
    }
    else as.sym_AT   = SYM_REFAT;
    fwrite(&as, sizeof(as), 1, f);
    strt_offset += (int32) strlen(s->name) + 1L;
  }

  strt_len = strt_offset;
  fwrite(&strt_len, sizeof(int32), 1, f);
  fwrite(areaname, 1, strlen(areaname) + 1, f);

  for (s = symbols;  s != NULL;  s = s->next)
  {
    fwrite(s->name, 1, strlen(s->name) + 1, f);
  }
  while (strt_offset & 3) {putc(0, f);  ++strt_offset;};
}

#ifdef NOTYET
void outaof_fwrite(char *base, unsigned32 len, char *vsn, int reent, FILE *f)
#else
void outaof_fwrite(char *base, unsigned32 len, char *vsn, FILE *f)
#endif
{
  cf_header *cf;
  aof_area  *a;
  int32 offset, chunklen;
  int cf_header_len;
  aof_header ah;

  reverse((void **)&relocs);
  reverse((void **)&symbols);
  /*
   * Set up the AOF header for the OBJ_HEAD chunk.
   * It describes exactly one area.
   */
  ah.aof_type   = AOF_RELOC;
  ah.aof_vsn    = AOF_VERSION;
  ah.aof_nareas = 1;
  ah.aof_nsyms  = nsymbols;
  ah.aof_entryarea = 0;
  a = ah.aof_areas;
  memset(a, 0, sizeof(aof_area));
  a->area_name = 4;
#ifdef OLD_AOF
  a->area_AT   = AOF_CODEAT+AOF_RONLYAT;
  a->area_AL   = 2;
#else
  a->area_attributes = AOF_CODEAT | AOF_RONLYAT | 2;
#ifdef NOTYET
  if (reent)
      a->area_attributes |= AOF_PICAT | AOF_REENTAT;
#endif
#endif
  a->area_size = (len + 3L) & ~3L;
  a->area_nrelocs = nrelocs;

  /*
   * Now initialise the chunk-file header, describing 5 chunks + 3 free chunks...
   */
  cf_header_len = sizeof(cf_header) + 7 * sizeof(cf_entry);
  cf = (cf_header *) calloc(1, cf_header_len);
  /* first the ch_header itself... */
  cf->cf_magic  = CF_MAGIC;
  cf->cf_maxchunks = 8L;
  cf->cf_numchunks = 5L;
  /* ...then the OBJ_IDFN chunk, first in the file */
  offset = (int32) cf_header_len;
  chunklen = (int32) strlen(vsn) + (int32) strlen(vsn_prefix) + 1L;
  mk_cfentry(cf->cf_chunks+0, OBJ_IDFN, offset, chunklen);
  offset += (chunklen + 3L) & ~3L;
  /* ...then the OBJ_HEAD (AOF header) chunk describing 1 area... */
  chunklen = (int32) sizeof(ah);
  mk_cfentry(cf->cf_chunks+1, OBJ_HEAD, offset, chunklen);
  offset += chunklen;
  /* ...then the area chunk, containing code and relocation directives... */
#ifdef OLD_AOF
  chunklen = len + (int32) sizeof(aof_reloc1) * nrelocs;
#else
  chunklen = len + (int32) sizeof(aof_reloc) * nrelocs;
#endif
  mk_cfentry(cf->cf_chunks+2, OBJ_AREA, offset, chunklen);
  offset += chunklen;
  /* ...then the symbol table chunk (OBJ_SYMT)... */
  chunklen = (int32) sizeof(aof_symbol) * nsymbols;
  mk_cfentry(cf->cf_chunks+3, OBJ_SYMT, offset, chunklen);
  offset += chunklen;
  /* ...and finally the string table OBJ_STRT */
  chunklen = strtlen();
  mk_cfentry(cf->cf_chunks+4, OBJ_STRT, offset, chunklen);

  /*
   * Now output the various bits of the AOF file in the correct order.
   * First the chunk-file header...
   */
  fwrite(cf, cf_header_len, 1, f);
  /* ...then the identification string... pad to a multiple of 4 with 0s... */
  fwrite(vsn_prefix, 1, strlen(vsn_prefix), f);
  fwrite(vsn, 1, strlen(vsn) + 1, f);
  chunklen = (int32) strlen(vsn_prefix) + (int32) strlen(vsn) + 1L;
  while (chunklen & 3L) {putc(0, f);  ++chunklen;}
  /* ...then the OBJ_HEAD (AOF header) chunk... */
  fwrite(&ah, sizeof(ah), 1, f);
  /* ... then the area (code + relocation directives) (OBJ_AREA chunk)... */
  fwrite(base, 1, (size_t) len, f);
  out_relocs(f);
  /* ...and finally the symbol table and string table */
  out_symt_and_strt(f);
}

void outaof_init(void)
{
  symbols = NULL;
  relocs  = NULL;
  nsymbols = nrelocs = 0;
  outaof_defsymbol(MODULESYM, 0);
}
