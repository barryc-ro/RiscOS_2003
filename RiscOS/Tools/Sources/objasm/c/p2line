/* -> p2line.c
 * Title: The general line processing routine for Pass 2.
 * Copyright (C) 1991 Advanced RISC Machines Limited. All rights reserved.
 */

/* RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#ifndef AAsm
#  include "aof.h"
#  include "aofvars.h"
#  include "aofvars.h"
#  include "tokens.h"
#endif
#include "code.h"
#include "condasm.h"
#include "constant.h"
#include "errors.h"
#include "expr.h"
#include "exprtyp.h"
#include "formatio.h"
#include "fpio.h"
#include "getline.h"
#include "globvars.h"
#include "listing.h"
#include "literals.h"
#include "locallab.h"
#include "macrotyp.h"
#include "nametyp.h"
#include "opcode.h"
#include "p1line.h"
#include "p2dir.h"
#include "p2line.h"
#include "tables.h"
#include "vars.h"
#include "message.h"
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#ifndef AAsm
#  include <string.h>
#endif

/* Bit values */

#define Type1ValueShift  21        /*Bit 21 onwards for four bits*/
#define Type1ValueMult   0x0200000
#define Type1ImmBit      0x2000000/*The bit distinguishing Imm from Reg*/
#define Type2RegBit      0x2000000/*The bit distinguishing Imm from Reg*/
#define PreBit           0x1000000/*The pre/post bit for type 2/4 opcodes*/
#define UpBit            0x800000/*The up/down bit for type 2/4 opcodes*/
#define PSRBit           0x400000/*The PSR update bit for group 4 opcodes*/
#define WriteBackBit     0x200000/*The writeback bit for data transfer opcodes*/
/*The bit distinguishing immediate from register forms*/
#define NOTFPRegisterBit 0x8

#define ANDVal           0x00
#define SUBVal           0x02
#define ADDVal           0x04
#define ADCVal           0x05
#define SBCVal           0x06
#define TSTVal           0x08
#define CMPVal           0x0A
#define CMNVal           0x0B
#define MOVVal           0x0D
#define BICVal           0x0E
#define MVNVal           0x0F
#define ADFVal           0x00
#define SUFVal           0x01
#define MVFVal           0BH
#define MNFVal           0CH

/* Bit positions */

#define DoubleBit        15

static BOOLEAN ADRRotatable(CARDINAL value)
{
  CARDINAL i, k;

  for (i = 0; i <= 1; i++)
  { k = 0;
    for (;;)
    { if (value < 0x100) { return TRUE; }
      if (k >= 0x10) break;
      value = (value >> 2) + (value << 30);
      k++;
    }
    value = (value ^ -1) + 1;
  }
  return FALSE;
} /* End ADRRotatable */

static BOOLEAN Rotatable(CARDINAL value,
  CARDINAL *k, 
  BOOLEAN inv,
  CARDINAL *immValue1)
{
  CARDINAL i;

  for (i = 0; i <= 1; i++) {
    *k = 0;
    do {
      if (value < 0x100) { *immValue1 = value; return TRUE; }; /* if */
      if (*k >= 0x10) { break; }; /* if */
      value = (value << 2) + (value >> 30);
      /* Rotate left value while incrementing rotator */
      (*k)++;
    } while (1); /* loop */
    if (!inv) { return FALSE; }; /* if */
    value ^= -1;
  }; /* for */
  return FALSE;
} /* End Rotatable */

static BOOLEAN RotatedForm(
    CARDINAL *rotator, 
    CARDINAL *immValue, 
    CARDINAL value, 
    CARDINAL *opcodeValue)
{
  CARDINAL oldImmValue=*immValue;
  *rotator = 0;
  do {
    if (*immValue < 0x100) { break; }; /* if */
    (*rotator)++;
    /*Now shift left immediate value*/
    *immValue = (*immValue << 2) + (*immValue >> 30);
    if (*rotator == 0x10) {
      /*
      Here we have failed,
      unless it can be converted
      MOV <-> MVN
      AND <-> BIC
      ADC <-> SBC
      by inverting the second operand, and
      ADD <-> SUB
      CMP <-> CMN
      by negating the second operand.
      */
      *immValue ^= -1;
      *rotator = 0;
      switch (value) {
        case MVNVal:
        *opcodeValue += (MOVVal-MVNVal) * Type1ValueMult;
        break;

        case MOVVal:
        *opcodeValue += (MVNVal-MOVVal) * Type1ValueMult;
        break;

        case BICVal:
        *opcodeValue += (ANDVal-BICVal) * Type1ValueMult;
        break;

        case ANDVal:
        *opcodeValue += (BICVal-ANDVal) * Type1ValueMult;
        break;

        case ADCVal:
        *opcodeValue += (SBCVal-ADCVal) * Type1ValueMult;
        break;

        case SBCVal:
        *opcodeValue += (ADCVal-SBCVal) * Type1ValueMult;
        break;

        case ADDVal:
        *opcodeValue += (SUBVal-ADDVal) * Type1ValueMult;
        (*immValue)++;
        break;

        case SUBVal:
        *opcodeValue += (ADDVal-SUBVal) * Type1ValueMult;
        (*immValue)++;
        break;

        case CMPVal:
        *opcodeValue += (CMNVal-CMPVal) * Type1ValueMult;
        (*immValue)++;
        break;

        case CMNVal:
        *opcodeValue += (CMPVal-CMNVal) * Type1ValueMult;
        (*immValue)++;
        break;

        default:
        Report(AsmError,errors_ImmValRange,oldImmValue);
        return TRUE;
      }; /* case */
      do {
        if (*immValue < 0x100) { break; }; /* if */
        (*rotator)++;
        /*Now shift left immediate value*/
        *immValue = (*immValue << 2) + (*immValue >> 30);
        if (*rotator == 0x10) {
          Report(AsmError,errors_ImmValRange,oldImmValue);
          return TRUE;
        };/* if */
      } while (1); /* loop */
    }; /* if */
  } while (1); /* loop */
  return FALSE;
} /* End RotatedForm */


static BOOLEAN Rotated16Form(
    CARDINAL *rotator1, 
    CARDINAL *rotator2, 
    CARDINAL *immValue1, 
    CARDINAL *immValue2, 
    CARDINAL *opcodeValue1,
    CARDINAL *opcodeValue2,
    BOOLEAN  mov_allowed,
    CARDINAL value)
/* Take _value_ and attempt to produce two instructions which load this value
 * the various paramters are modified if it is possible.
 * on entry it is assumed that opcodeValue 1 and 2 are unset.
 * If MVN/MOV is allowed as the 1st op (ie not reg relative) then mov_allowed
 * is TRUE, otherwise false.
 * Returned value indicates error found (TRUE=>error)
 */
{
  CARDINAL bits_set,tmp_val,i;

  /* count the number of bits set in value */
  for (bits_set=0,tmp_val=value; tmp_val!=0;
                               bits_set++,tmp_val=tmp_val&(tmp_val-1));

  if (bits_set>16) {
    /* If we have to use two Subtracts to perform an ADD, rather than
     * using an MVN and a SUB, then we need to adjust the
     * value by subtracting one to the unsigned value to get the 2's
     * complement arithmetic right!
     */
    tmp_val= (mov_allowed==FALSE) ? value-1 : value;

    /* Now search for unset bits, and eliminate all those within 8 bits,
     * and then see if what is left over can be patched in one instr
     */
    for (i=0; i<16 ;i++) {
      if ((tmp_val & 3)!=3) {        /* If the bottom 2 bits aren't both 1 */
        if (Rotatable((~tmp_val) & 0xFFFFFF00,rotator2,0,immValue2)){
          *opcodeValue2+=SUBCode;
          *rotator2=(*rotator2 + i)%16;
          *immValue1= (~tmp_val) & 255;
          *rotator1=i;
          *opcodeValue1+=mov_allowed?MVNCode:SUBCode;
          return FALSE;
        }
      }
      tmp_val=(tmp_val << 2) + (tmp_val >> 30); /* ROR tmp_val by 2 bits */
    }
    Report(AsmError,errors_ImmValRange,value);
    return TRUE;
  }
  /* search for set bits, and eliminate all those within 8 bits,
   * and then see if what is left over can be patched in one instr
   */
  for (tmp_val=value,i=0; i<16 ;i++) {
    if ((tmp_val & 3)!=0 || tmp_val==0) {
      /* If the bottom 2 bits aren't both 0 or it's completely 0 */
      if (Rotatable(tmp_val & 0xFFFFFF00,rotator2,0,immValue2)){
        *opcodeValue2+=ADDCode;
        *rotator2=(*rotator2 + i)%16;
        *immValue1= tmp_val & 255;
        *rotator1=i;
        *opcodeValue1+= mov_allowed?MOVCode:ADDCode;
        return FALSE;
      }
    }
    tmp_val=(tmp_val << 2) + (tmp_val >> 30); /* ROR tmp_val by 2 bits */
  }
  Report(AsmError,errors_ImmValRange,value);
  return TRUE;
}

BOOLEAN P2LineHandler(char **linkPointer, BOOLEAN *wasLink) /*
 The returned value indicates if the pass has finished.
 */
{
  Name          name,
                lname;
  SymbolPointer symbolPointer;
  char         *line;
  CARDINAL      lineIndex = 0,
                old_index,
                after_symbol,
                pastOpcode,
                opcodeValue,
                opcodeValue1,
                cop,
                destReg,
                sourceReg1,
                sourceReg2,
                immValue,
                rotator,
                immValue1,
                rotator1,
                value1,
                value2,
                value;
  OpcodeType    opcodeType;
  BOOLEAN       passEnded = FALSE,
                opcodeFound = FALSE,
                symbol_found = FALSE,
                mov_allowed,
#ifndef AAsm
                external = FALSE,
#endif
                defined;
  OperandType   type;
  Size          fPSize;
  ReadResponse  readResponse;

  *wasLink = FALSE;
  errorFound = FALSE;
  if (GetLine(&line, TRUE))
  { line = SubstituteString(line);
    currentLinePointer = line;
  }
  if (exception == EndOfInput) {exception = None;  return TRUE;}

  /*Now check for all comment*/
  ListLineNumber();
  ListAddress();
#ifndef AAsm
  do {
  /* Allow multiple assembler lines per source line for as */
  if (AllComment(line, &lineIndex))
#else
  { /* keep topcc happy */
  while (isWhiteSpace(line[lineIndex])) lineIndex++;
  if ((line[lineIndex] == CommentSymbol) || (line[lineIndex] == CR))
#endif
    return FALSE;
#ifndef AAsm
/* Sort out lines starting # */
  else if ((line[lineIndex] == Hash) && (input_style == AsIS)) {
    return FALSE;
  }; /* if */
#endif
  lineIndex = 0;
  /*pass first item on line*/
#ifndef AAsm
  if (input_style_set && (input_style == AsIS) && (isWhiteSpace(*line))) {
    /* 
     * Here we must check that the stupid format hasn't allowed a label
     * in a non column one position.
     */
    CARDINAL old_index;
    lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
    old_index = lineIndex;   /* Remember the symbol start */
    if (SymbolTest(line, &lineIndex, &lname) && (line[lineIndex] == Colon)) {
      line += old_index;
    }; /* if */
    lineIndex = 0;
    /* This should now point at the indented label if there is one */
  }; /* if */
#endif
  after_symbol = 0;  /* keep dataflow happy */
  if (SymbolTest(line, &lineIndex, &lname)) {
    symbol_found = TRUE;
    after_symbol = lineIndex;
#ifndef AAsm
    if (line[lineIndex] == Colon) {
      lineIndex++;
    }; /* if */
    if (!TermCheck(line[lineIndex])) {
      symbol_found = FALSE;
      while (!TermCheck(line[lineIndex])) {
        lineIndex++;
      }; /* while */
    }; /* if */
#else
    if (!termin[line[lineIndex]]) {
      symbol_found = FALSE;
      while (!termin[line[lineIndex]]) {
        lineIndex++;
      }; /* while */
    }; /* if */
#endif
  } else {
#ifndef AAsm
    while (!TermCheck(line[lineIndex])) {
#else
    while (!termin[line[lineIndex]]) {
#endif
      lineIndex++;
    }; /* while */
  }; /* if */
  pastOpcode = 0;  /* keep dataflow happy */
#ifndef AAsm
  if (!AllComment(line, &lineIndex) && (line[lineIndex] != CommentSymbol)) {
#else
  while (isWhiteSpace(line[lineIndex])) lineIndex++;
  if ((line[lineIndex] != CommentSymbol) && (line[lineIndex] != CR)) {
#endif
    old_index = lineIndex;
    (void) DirTest(line, &lineIndex, &name);
    opcodeFound = TRUE;
    pastOpcode = lineIndex;
    if (errorFound || P2Directive(line, wasLink, &passEnded, linkPointer)) {
#ifndef AAsm
      if ((input_style == ObjAsmIS) || errorFound || passEnded ||
          (exception != None) ||
        *wasLink || (line[end_of_line] != CommentSymbol))
        return passEnded || (exception != None);
      lineIndex = end_of_line;
      goto check_for_more_lines;
#else
      return passEnded || (exception != None);
#endif
    };
  }; /* if */

  /*Now handle WHILE and conditional stuff*/
  if (!notSkipping) return FALSE; /* Line conditionally ignored */

  /*Now search for a valid opcode or macro*/
  if (opcodeFound)
  { if (!Opcode(name, &opcodeType, &opcodeValue))
    {
      if (SymbolTest(line, &old_index, &name))
      { /* Get the symbol name right */
        ExpandMacro(line, name);
        if (exception != None) return TRUE;
        return FALSE;
      }
      opcodeFound = FALSE;
    }
  }

  /*Now sort out local or ordinary labels*/
  if (!isWhiteSpace(*line)) {
    if (symbol_found) {
      lineIndex = after_symbol;
#ifndef AAsm
      if (line[lineIndex] == Colon) {
        lineIndex++;
      } /* if */
#endif
      symbolPointer = LookupFixed(lname, FALSE);
#ifndef AAsm
      if (keepingAll &&
        (symbolPointer->u.s.at == NoneAT)) {
        AddSymbolToTable(symbolPointer, lname, FALSE, FALSE);
        symbolPointer->u.s.at = KeptAT;
      } /* if */
#endif
    } else if (isdigit(*line)) {
      lineIndex = 0;
      LabelDef(line, &lineIndex);
    };
  };
  if (opcodeFound) {
    lineIndex = pastOpcode;
    while (isWhiteSpace(line[lineIndex])) { lineIndex++; };
    /*Now align on word boundary*/
    while ((programCounter % 4) != 0) {
      CodeByte(0);
    }; /* while */

    switch (opcodeType) {

      case MVP:    /* MRS and MSR */
      if ((opcodeValue & ~0xF0000000) == MRSCode)
      { /* MRS Rd, CPSR/SPSR */
        destReg = RegisterExpr(line, &lineIndex); /*Destination*/
        lineIndex++; /*Step past comma*/
        if (CPSRorSPSR(line, &lineIndex) & 2)     /* SPSR */
          opcodeValue |= 0x00400000;
        CodeWord(opcodeValue + destReg*0x1000 + 15*0x10000);
      }
      else
      { /* MSR CPSR/SPSR[_flg,_ctl,_all] */
        value = CPSRorSPSR(line, &lineIndex);     /*Destination*/
        if (value & 2) opcodeValue |= 0x00400000; /* SPSR */
        if (value < 4 || value >= 12)
          sourceReg1 = 9;                         /* _flg + _ctl */
        else if (value & 8)
          sourceReg1 = 8;                         /* _flg only */
        else
          sourceReg1 = 1;                         /* _ctl only */
        lineIndex++;                              /*Step past comma*/
        destReg = 15;
        goto DPoperand2;
      }
      break;

      case DataProcessing:
      destReg = RegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      /*
      Now handle extra register unless MOV or MVN or test
      First get the opcode name bits
      */
      value = (opcodeValue >> Type1ValueShift) & 15;
      if ((value != MOVVal) && (value != MVNVal) &&
        ((value > CMNVal) || (value < TSTVal))) {
        /*Here we need another register*/
        sourceReg1 = RegisterExpr(line, &lineIndex);/*Read the destination*/
        lineIndex++;/*Step past comma*/
      } else if ((value == MOVVal) || (value == MVNVal)) {
        sourceReg1 = 0;
      } else {
        sourceReg1 = destReg;
        destReg = 0;
      }
DPoperand2:
      /*Now look for immediate or register form*/
      while (isWhiteSpace(line[lineIndex])) {
        lineIndex++;
      }; /* while */
      if (line[lineIndex] == Hash) {
        lineIndex++;
        /*Now look for immediate form*/
        immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
        if (errorFound) { return FALSE; }; /* if */
        /*Now see if we have a rotator as well*/
        if (line[lineIndex] == Comma) {
          /*Look for a rotator*/
          lineIndex++;
          rotator = ConstantExpr(line, &lineIndex, FALSE, &defined);
          /*Now check that it is valid*/
          if (immValue >= 0x100) {
            Report(AsmError,errors_ImmValRange,immValue);
            return FALSE;
          }; /* if */
          if ((rotator & 1) || ((rotator / 2) >= 0x10)) {
            Report(AsmError,errors_BadRot);
            return FALSE;
          }; /* if */
          rotator = rotator / 2;
        } else {
          /*Here we try to determine if the rotated form can be produced*/
          if (immValue < 0x100) {
            rotator = 0;
          } else if (RotatedForm(&rotator, &immValue, value, &opcodeValue)) {
            return FALSE;
          }; /* if */
        }; /* if */
        /*Now update opcodeValue*/
        opcodeValue += rotator*0x100 + immValue + Type1ImmBit;
      } else {
        /*Now look for register form*/
        opcodeValue += ShiftedRegister(line, &lineIndex, TRUE);
      }; /* if */
      if (errorFound) return FALSE;
      CodeWord(opcodeValue + destReg*0x1000 + sourceReg1*0x10000);
      break;

      case DataTransfer:
      destReg = RegisterExpr(line, &lineIndex); /* Destination/source */
      lineIndex++; /* Step past comma */
      while (isWhiteSpace(line[lineIndex])) lineIndex++;
      if (line[lineIndex] == SquareBra)
      { lineIndex++;
        sourceReg1 = RegisterExpr(line, &lineIndex);
        /* Here we split according to pre/post indexing */
        if (line[lineIndex] == SquareKet)
        { /* This is probably the post-indexed form */
          lineIndex++;
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] != Comma)
          { opcodeValue |= UpBit;
            /* Allow optional shriek */
            if (line[lineIndex] == Shriek)
              lineIndex++;
            else if ((WriteBackBit & opcodeValue) == 0)
              /* Not LDRT/STRT... */
              opcodeValue |= PreBit;    /* pre-indexed corner case */
            immValue = 0;
          }
          else
          { /*Definitely post-indexed*/
            lineIndex++;
            while (isWhiteSpace(line[lineIndex])) lineIndex++;
            if (line[lineIndex] == Hash)
            { lineIndex++;
              immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
              if (errorFound) { return FALSE; };
              if (abs((int)immValue) >= 0x1000) {
                Report(AsmError,errors_DatOff);
                return FALSE;
              }
              if (immValue < 0x1000) opcodeValue |= UpBit;
              immValue = abs((int)immValue);
            }
            else
            { opcodeValue |= Type2RegBit;
              /*Here we must allow an optional + or -*/
              if (line[lineIndex] == PlusSign) {
                lineIndex++;
                opcodeValue |= UpBit;
              } else if (line[lineIndex] == MinusSign) {
                lineIndex++;
              } else {
                opcodeValue |= UpBit;
              }; /* if */
              immValue = ShiftedRegister(line, &lineIndex, FALSE);
            }
          }
        }
        else
        { /* This is definitely pre-indexed */
          opcodeValue |= PreBit;
          lineIndex++;/*Past comma*/
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] == Hash) {
            lineIndex++;
            immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
            if (errorFound) { return FALSE; }; /* if */
            if (abs((int)immValue) >= 0x1000) {
              Report(AsmError,errors_DatOff);
              return FALSE;
            }
            if (immValue < 0x1000) opcodeValue |= UpBit;
            immValue = abs((int)immValue);
          } else {
            opcodeValue |= Type2RegBit;
            /*Here we must allow an optional + or -*/
            if (line[lineIndex] == PlusSign) {
              lineIndex++;
              opcodeValue |= UpBit;
            } else if (line[lineIndex] == MinusSign) {
              lineIndex++;
            } else {
              opcodeValue |= UpBit;
            }
            immValue = ShiftedRegister(line, &lineIndex, FALSE);
          }
          lineIndex++;
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] == Shriek) {
            lineIndex++;
            opcodeValue |= WriteBackBit;
          }
        }
      }
      else
      { /* Look for a PC or register relative expression or a literal. */
#ifndef AAsm
        if (((line[lineIndex] == Equals) && (input_style == ObjAsmIS)) ||
            ((line[lineIndex] == Hash) && (input_style == AsIS)))
#else
        if (line[lineIndex] == Equals)
#endif
        {
          lineIndex++;
#ifndef AAsm
          symbolPointer = ExternalExpr(line, &lineIndex, &value);
          sourceReg1 = 15;
          if (symbolPointer == NULL) {
            value = ConstantOrAddressExpr(line, &lineIndex, &type, FALSE,
              &defined);
            if (errorFound) { return FALSE; }; /* if */
/* Optimising PC relative LDR, = into an ADD or SUB has been deemed
 * undesirable, so this is #if ed out.
 */
            if (type==PCRelOT) {
#if 0
              BOOLEAN negative;
              CARDINAL oldvalue=value;
              if (value >= programCounter+8) {
                value -= programCounter + 8; /* Convert value to a PC */
                negative=FALSE;              /* relative offset, which */
              } else {                       /* is always posative */
                value = programCounter + 8 - value;
                negative=TRUE;
              }
              if (Rotatable(value,&rotator,0,&immValue)) {
                CodeWord((opcodeValue & 0xF0000000) + (destReg<<12) +
                         (sourceReg1<<16) + (negative?SUBCode:ADDCode) +
                         (rotator<<8) + immValue + Type1ImmBit);
                break;
              }
#endif
              immValue = AddAddressLiteral(value, DEFINED);
            } else if (Rotatable(value, &immValue, TRUE, &immValue1)) {
              opcodeValue = (opcodeValue & 0xF0000000) + destReg * 0x1000 +
                Type1ImmBit + MOVCode;
              immValue = value;
              value = MOVVal;
              defined = RotatedForm(&rotator, &immValue, value, &opcodeValue);
                /*Throw away result here*/
              CodeWord(opcodeValue + rotator*0x100 + immValue);
              break;
            } else {
              immValue = AddLiteral(TRUE, FALSE, value);
            }
          }
          else
            immValue = AddExternalLiteral(symbolPointer, value);
#else
          value = ConstantExpr(line, &lineIndex, FALSE, &defined);
          if (errorFound) return FALSE;
          if (Rotatable(value, &immValue, TRUE, &immValue1))
          { opcodeValue = (opcodeValue & 0xF0000000) + destReg * 0x1000 +
              Type1ImmBit + MOVCode;
            immValue = value;
            value = MOVVal;
            defined = RotatedForm(&rotator, &immValue, value, &opcodeValue);
              /*Throw away result here*/
            CodeWord(opcodeValue + rotator*0x100 + immValue);
            return FALSE;
          }
          immValue = AddLiteral(TRUE, FALSE, value);
          sourceReg1 = 15;
#endif
        }
        else
        {
#ifndef AAsm
          symbolPointer = ExternalExpr(line, &lineIndex, &immValue);
          if (symbolPointer == NULL)
            immValue = RegisterRelExpr(line, &lineIndex, &sourceReg1, FALSE,
                                       &defined);
          else
          { sourceReg1 = 15;
            external = TRUE;
          }
          if (external || sourceReg1 >= 256)
          { Relocation reloc;
            if (output_style == AofOS)
            { /* Now done with type 2 relocations */
              reloc.aof_reloc.rel_offset = (int32)programCounter;
              if (sourceReg1 == 15) {
                reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_R | REL_INSTR |
                  ((symbolPointer->u.s.sdt == ExternalSDT) ?
                   (REL_A | (symbolPointer->aOFData.symbolId & 0xffffff)) :
                   (symbolPointer->area - 1L));
                  /* Note inconsistent use of area number */
              }
              else
              { sourceReg1 &= 15;
                reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_B |
                    REL_INSTR | (area_of_base[sourceReg1] - 1);
              }
            }
            else
            { Report(AsmError,errors_BadAoutAdr);
              return FALSE;
            }
            PutReloc(reloc);
          }
#else
          immValue = RegisterRelExpr(line, &lineIndex, &sourceReg1, FALSE,
            &defined);
#endif
          if (errorFound) return FALSE;
        }
        opcodeValue |= PreBit;
        /* Always adjust PC relative offsets */
        if (sourceReg1 == 15) immValue -= programCounter+8;
        if (abs((int)immValue) >= 0x1000) {
          Report(AsmError,errors_DatOff);
          return FALSE;
        }
        if (immValue < 0x1000) {
          opcodeValue |= UpBit;
        }
        immValue = abs((int)immValue);
        if (line[lineIndex] == Shriek) {
          lineIndex++;
          opcodeValue |= WriteBackBit;
        }
      }
      CodeWord(opcodeValue + immValue + sourceReg1*0x10000 + destReg*0x1000);
      break;

      case SWI:
#ifndef AAsm
      symbolPointer = ExternalExpr(line, &lineIndex, &value);
      if (symbolPointer != NULL)
      { Relocation reloc;
        if (output_style == AofOS)
        { /* Now done with type 2 relocations */
          reloc.aof_reloc.rel_offset = (int32)programCounter;
          reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_LONG | REL_A |
            (symbolPointer->aOFData.symbolId & 0xffffff);
        }
        else
        { Report(AsmError,errors_BadAoutAdr);
          return FALSE;
        }
        PutReloc(reloc);
      }
      else
#endif
        value = ConstantExpr(line, &lineIndex, FALSE, &defined);
      if (value >= 0x1000000) {
        Report(AsmError,errors_ImmValRange,value);  return FALSE;}
      CodeWord(opcodeValue + value);
      break;

      case BlockData:
      sourceReg1 = RegisterExpr(line, &lineIndex);
      if (line[lineIndex] == Shriek) {
        lineIndex++;
        while (isWhiteSpace(line[lineIndex])) {
          lineIndex++;
        }; /* while */
        opcodeValue |= WriteBackBit;
      }; /* if */
      lineIndex++;
      while (isWhiteSpace(line[lineIndex])) {
        lineIndex++;
      }; /* while */
      value = RegisterListExpr(line, &lineIndex);
      if (line[lineIndex] == Hat) {
        lineIndex++;
        opcodeValue |= PSRBit;
      }; /* if */
      CodeWord(opcodeValue + sourceReg1*0x10000 + value);
      break;

      case Branch:
#ifndef AAsm
      type=UnDefOT;
      symbolPointer = ExternalExpr(line, &lineIndex, &value);
      if (symbolPointer == NULL)
      {
        value = ConstantOrAddressExpr(line, &lineIndex, &type, FALSE, &defined);
        if (errorFound) { return FALSE; };
        if (type == ConstantOT) {
          symbolPointer = LookupFixed(currArea->name, FALSE);
        }
      }
      if (((currArea->dec.area_attributes & AOF_ABSAT) && type==ConstantOT)
          || symbolPointer==NULL)
        value -= programCounter+8;
      else
      { Relocation reloc;
        if (output_style == AofOS)
        { /* Now done with type 2 relocations */
          reloc.aof_reloc.rel_offset = (int32)programCounter;
          reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_R | REL_INSTR |
            ((symbolPointer->u.s.sdt == ExternalSDT) ?
             (REL_A | (symbolPointer->aOFData.symbolId & 0xffffff)) :
             (symbolPointer->area - 1L));
                 /* Note inconsistent use of area number */
          value += currArea->dec.area_base - programCounter - 8;
              /* Account for offset into this area */
        }
        else
        { int a[2];
          a[0] = 0;
          a[1] = 0;
          memcpy(&reloc, a, 8); /* Ensure all fields clear */
          reloc.aout_reloc.r_address = programCounter;
          value -= 8; /* ld should know about this but it doesn't */
          if (symbolPointer->u.s.sdt == ExternalSDT) {
            reloc.aout_reloc.r_symbolnum =
                (int)(symbolPointer->aOFData.symbolId);
            reloc.aout_reloc.r_length = 3; /* ARM branch */
            reloc.aout_reloc.r_pcrel = 0;  /* No PC relocation needed */
            reloc.aout_reloc.r_extern = 1; /* Use symbol */
          } else {
            reloc.aout_reloc.r_length = 3; /* ARM branch */
            reloc.aout_reloc.r_pcrel = 1;  /* PC relocation needed */
            reloc.aout_reloc.r_extern = 0; /* Don't use symbol */
            /*
             * Now we adjust value to account for the current pc,
             * and the fact that a.out regards text, data and bss as contiguous
             * and expects offsets into data or bss to be calculated as if
             * from start of text. In my opinion this is incredibly stupid!
             */
            value += (CARDINAL) (aout_header.a_text - programCounter);
            if (input_style == ObjAsmIS) {
              aof_area *dec = GetArea(symbolPointer->area);
              reloc.aout_reloc.r_symbolnum =
                 (dec->area_attributes & AOF_0INITAT) ? N_BSS : N_DATA;
                /* Can't be more than one text area, and we're in it !*/
              /* Relocate relative to dot, and add in text size */
              if (dec->area_attributes & AOF_0INITAT) value +=
                (CARDINAL)aout_header.a_data;
              /* Optionally add in data size if target in bss */
            } else {
              reloc.aout_reloc.r_symbolnum = (symbolPointer->area == BssST) ?
                N_BSS : N_DATA;
              /* Relocate relative to dot, and add in text size */
              if (symbolPointer->area == BssST) value +=
                (CARDINAL)aout_header.a_data;
              /* Optionally add in data size if target in bss */
            }
          }
          reloc.aout_reloc.r_neg = 0;
        }
        PutReloc(reloc);
      }
#else
      value = AddressExpr(line, &lineIndex, FALSE, &defined);
      value -= programCounter+8;
#endif
      value1 = ((long)value < 0) ? -value : value;
      if (value1 > 0x4000000) { Report(AsmError,errors_BrOff);  return FALSE;}
      if (value & 3) Report(AsmError,p2line_p2line_B_unalign);
      CodeWord(opcodeValue + (((value+3) >> 2) & 0x00ffffff));
      break;

      case Adr:
      destReg = RegisterExpr(line, &lineIndex);
      lineIndex++;
      symbolPointer = ExternalExpr(line, &lineIndex, &immValue);
      if (symbolPointer != NULL)
      { Relocation reloc;
        external = TRUE;
        type = PCRelOT;
        if (output_style == AofOS)
        { /* Now done with type 2 relocations */
          reloc.aof_reloc.rel_offset = (int32)programCounter;
          reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_R | REL_INSTR |
            rel2_ins(1) |
            ((symbolPointer->u.s.sdt == ExternalSDT) ?
             (REL_A | (symbolPointer->aOFData.symbolId & 0xffffff)) :
             (symbolPointer->area - 1L));
            /* Note inconsistent use of area number */
          immValue -= programCounter+8;
          /* Account for offset into this area */
        }
        else
        { Report(AsmError,errors_BadAoutAdr);
          return FALSE;
        }
        PutReloc(reloc);
      } else
        immValue =
          NotStringExpr(line, &lineIndex, &sourceReg1, &type, FALSE, &defined);
      if (errorFound) return FALSE;
      switch (type) {
        case ConstantOT:
        if ((asmMode == AbsoluteAM) &&
          ADRRotatable(immValue - programCounter - 8)) {
          opcodeValue |= ADDCode | (15 << 16); /* Or in PC as source reg */
          value = ADDVal;
          immValue -= programCounter + 8;
        } else {
          opcodeValue |= MOVCode;
          value = MOVVal;
        }
        break;

        case PCRelOT:
#ifndef AAsm
        if (!external) /* Only do offset adjustment on local references */
#endif
          immValue -= programCounter + 8;
        opcodeValue |= ADDCode | (15 << 16); /* Or in PC as source reg */
        value = ADDVal;
        break;

        case RegRelOT:
        opcodeValue |= ADDCode | (sourceReg1 << 16);
        value = ADDVal;
      }
      if (RotatedForm(&rotator, &immValue, value, &opcodeValue))
        return FALSE;
      CodeWord(opcodeValue + rotator*0x100 + immValue + destReg*0x1000);
      break;

      case ADRL:
      opcodeValue &= 0xFFF0FFFF; /* Clear out source register, may be des */
      opcodeValue1=opcodeValue;
      mov_allowed=FALSE;
      destReg = RegisterExpr(line, &lineIndex);
      lineIndex++;
#ifndef AAsm
      symbolPointer = ExternalExpr(line, &lineIndex, &value);
      if (symbolPointer != NULL)
      { Relocation reloc;
        external = TRUE;
        type = PCRelOT;
        if (output_style == AofOS)
        { /* Now done with type 2 relocations */
          reloc.aof_reloc.rel_offset = (int32)programCounter;
          reloc.aof_reloc.rel_flags = REL_TYPE2 | REL_R | REL_INSTR |
            rel2_ins(2) |
            ((symbolPointer->u.s.sdt == ExternalSDT) ?
             (REL_A | (symbolPointer->aOFData.symbolId & 0xffffff)) :
             (symbolPointer->area - 1L));
            /* ADRL special */
            /* Note inconsistent use of area number */
          value -= programCounter+8;
          /* Account for offset into this area */
        }
        else
        { Report(AsmError,errors_BadAoutAdr);
          return FALSE;
        }
        PutReloc(reloc);
      } else
#endif
      value =
        NotStringExpr(line, &lineIndex, &sourceReg1, &type, FALSE, &defined);
      if (errorFound) { return FALSE; }; /* if */
      switch (type) {
        case ConstantOT:
        mov_allowed=TRUE;
        sourceReg1=destReg;
        break;

        case PCRelOT:
#ifndef AAsm
        if (!external) /* Only do offset adjustment on local references */
#endif
          value -= programCounter + 8;
        sourceReg1 = 0x0F;
        break;

        case RegRelOT:
        break;
      }; /* case */
      if (Rotated16Form(&rotator, &rotator1, &immValue, &immValue1,
                        &opcodeValue, &opcodeValue1, mov_allowed, value)) {
          return FALSE;
      }
      CodeWord(opcodeValue + (rotator<<8) + (immValue & 0xFF) +
                             (destReg<<12) + (sourceReg1<<16));
      CodeWord(opcodeValue1 + (rotator1<<8) + (immValue1 & 0xFF) + 
                              (destReg*0x11000));
      break;


      case SWP:
      destReg = RegisterExpr(line, &lineIndex);/*Destination*/
      lineIndex++;/*Step past comma*/
      while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
      sourceReg1 = RegisterExpr(line, &lineIndex);/*Source*/
      lineIndex++;/*Step past comma*/
      while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
      lineIndex++;/*Step past square bra*/
      sourceReg2 = RegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past square ket*/
      CodeWord(opcodeValue + sourceReg1 + sourceReg2*0x10000 + destReg*0x1000);
      break;

      case FPDataTransfer:
      destReg = FPRegisterExpr(line, &lineIndex);  /* Destination/source */
      lineIndex++;/*Step past comma*/
      while (isWhiteSpace(line[lineIndex])) lineIndex++;
      if (line[lineIndex] == SquareBra) {
        lineIndex++;
        sourceReg1 = RegisterExpr(line, &lineIndex);
        /* Here we split according to pre/post indexing */
        if (line[lineIndex] == SquareKet)
        { /* This is probably the post-indexed form */
          lineIndex++;
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] != Comma)
          { opcodeValue |= UpBit;
            /* Allow optional shriek */
            if (line[lineIndex] == Shriek)
            { lineIndex++;
              opcodeValue |= WriteBackBit;
            }
            else
              opcodeValue |= PreBit;   /* pre-indexed corner case */ 
            immValue = 0;
          }
          else
          { /* Definitely post-indexed */
            lineIndex++;
            opcodeValue |= WriteBackBit;  /* must set write back */
            while (isWhiteSpace(line[lineIndex])) lineIndex++;
            lineIndex++;
            immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
            if (errorFound) return FALSE;
            if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
              Report(AsmError,errors_DatOff);
              return FALSE;
            }
            if (immValue < 0x400) opcodeValue |= UpBit;
            immValue = abs((int)immValue) / 4L;
          }
        } else {
          /*This is definitely pre-indexed*/
          opcodeValue |= PreBit;
          lineIndex++;/*Past comma*/
          while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
          lineIndex++;/*Past hash*/
          immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
          if (errorFound) { return FALSE; }; /* if */
          if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
            Report(AsmError,errors_DatOff);
            return FALSE;
          }; /* if */
          if (immValue < 0x400) { opcodeValue |= UpBit; }; /* if */
          immValue = abs((int)immValue) / 4L;
          lineIndex++;/*Past ket*/
          while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
          if (line[lineIndex] == Shriek) {
            lineIndex++;
            opcodeValue |= WriteBackBit;
          }
        }
      } else {
        /*
        Here we look for a PC or register relative expression
        or a literal.
        */
        if (line[lineIndex] == Equals) {
          lineIndex++;
          if ((1L << DoubleBit) & opcodeValue) {
            fPSize = Double;
          } else {
            fPSize = Single;
          }; /* if */
          readResponse = Read(line, &lineIndex, fPSize, &value1, &value2);
          switch (fPSize) {
            case Single:
            immValue = AddFPLiteralSingle(value1);
            break;

            case Double:
            immValue = AddFPLiteralDouble(value1, value2);

          }; /* case */
          sourceReg1 = 15;
        } else {
          immValue = RegisterRelExpr(line, &lineIndex, &sourceReg1, FALSE,
            &defined);
          if (errorFound) { return FALSE; }; /* if */
        }; /* if */
        opcodeValue |= PreBit;
        if (sourceReg1 == 15) { immValue -= programCounter+8; }; /* if */
        if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
          Report(AsmError,errors_DatOff);
          return FALSE;
        }
        if (immValue < 0x400) opcodeValue |= UpBit;
        immValue = abs((int)immValue) / 4L;
        if (line[lineIndex] == Shriek) {
          lineIndex++;
          opcodeValue |= WriteBackBit;
        }
      }
      CodeWord(opcodeValue + immValue + sourceReg1*0x10000 + destReg*0x1000);
      break;

      case FPDyadic:
      destReg = FPRegisterExpr(line, &lineIndex);/*Read the destination*/
      lineIndex++;/*Step past comma*/
      sourceReg1 = FPRegisterExpr(line, &lineIndex);/*Read first source*/
      lineIndex++;/*Step past comma*/
      /*Now look for immediate or register form*/
      while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
      if (line[lineIndex] == Hash) {
        lineIndex++;
        /*Now look for immediate form*/
        immValue = FPConstant(line, &lineIndex);
        /*Now update opcodeValue*/
        opcodeValue |= immValue + NOTFPRegisterBit;
      } else {
        opcodeValue |= FPRegisterExpr(line, &lineIndex);
      }; /* if */
      CodeWord(opcodeValue + destReg*0x1000 + sourceReg1*0x10000);
      break;

      case FPMonadic:
      case FPCompare:
      case FPNorm:
      destReg = FPRegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      /*Now look for immediate or register form*/
      while (isWhiteSpace(line[lineIndex])) { lineIndex++; }; /* while */
      if (line[lineIndex] == Hash) {
        lineIndex++;
        /*Now look for immediate form*/
        immValue = FPConstant(line, &lineIndex);
        opcodeValue |= immValue + NOTFPRegisterBit;
      } else {
        /*Now look for register form*/
        opcodeValue |= FPRegisterExpr(line, &lineIndex);
      }; /* if */
      if (opcodeType == FPCompare) {
        CodeWord(opcodeValue + destReg*0x10000);
      } else {
        CodeWord(opcodeValue + destReg*0x1000);
      }; /* if */
      break;

      case FPFloat:
      opcodeValue |= FPRegisterExpr(line, &lineIndex)*0x10000;
      lineIndex++;/*Step past comma*/
      opcodeValue |= RegisterExpr(line, &lineIndex)*0x1000;
      CodeWord(opcodeValue);
      break;

      case FPFix:
      opcodeValue |= RegisterExpr(line, &lineIndex)*0x1000;
      lineIndex++;/*Step past comma*/
      opcodeValue |= FPRegisterExpr(line, &lineIndex);
      CodeWord(opcodeValue);
      break;

      case FPStatus:
      CodeWord(opcodeValue + RegisterExpr(line, &lineIndex)*0x1000);
      break;

      case FPBlock:
      case FPStack:
      destReg = FPRegisterExpr(line, &lineIndex);/*Destination/source*/
      if (destReg > 7) {
        Report(AsmError,errors_FPRegRange);
        return FALSE;
      }
      lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
      value = ConstantExpr(line, &lineIndex, FALSE, &defined);
      if (value < 1 || value > 4) {
        Report(AsmError,errors_ImmValRange,value);
        return FALSE;
      }
      opcodeValue |= ((value & 2) << 21) + ((value & 1) << 15);
      /* Stuff in the number of registers to be transferred */
      lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
      /* Past comma plus spaces */
      if (line[lineIndex]==SquareBra) {
        lineIndex++;
        sourceReg1 = RegisterExpr(line, &lineIndex);
        /* Here we split according to pre/post indexing */
        if (line[lineIndex] == SquareKet) {
          /* This is probably the post-indexed form */
          lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] != Comma) {
            /* Allow optional shriek with LFM and SFM */
            if (line[lineIndex] == Shriek)
              opcodeValue |= WriteBackBit;
            if (opcodeType == FPBlock) {
              opcodeValue |= PreBit;   /* pre-indexed corner case */
              immValue=0;
              opcodeValue |= UpBit; /* Offset zero is always considered plus */
            } else {
              /* We are dealing with Stack type instructions which have had */
              /* the pre-bit and up-bit already set up, just the offset to do */
              /* Pre  => Always add in offset */
              /* Post => Only add in offset if WB specified */
              if ((opcodeValue & PreBit) || (opcodeValue & WriteBackBit)) {
                immValue=3*value;
              } else {
                /* Post without writeback isn't allowed, but since offset=0 */
                /* We can use pre instead */
                immValue=0;
                opcodeValue |= PreBit;
              }
            }
          } else {
            opcodeValue |= WriteBackBit;
            lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
            lineIndex++; /* Skip # */
            immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
            if (errorFound) return FALSE;
            if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
              Report(AsmError,errors_DatOff);
              return FALSE;
            }
            if (immValue < 0x400) opcodeValue |= UpBit;
            immValue = abs((int)immValue) / 4L;
          }
        }
        else
        { /* This is the pre-index case for FPBlock */
          opcodeValue |= PreBit;
          lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
          /* Past comma and spaces */
          lineIndex++; /* Past hash */
          immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
          if (errorFound) { return FALSE; }; /* if */
          if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
            Report(AsmError,errors_DatOff);
            return FALSE;
          }
          if (immValue < 0x400) opcodeValue |= UpBit;
          immValue = abs((int)immValue) / 4L;
          lineIndex++; while (isWhiteSpace(line[lineIndex])) lineIndex++;
          /* Past ] and spaces */
          if (line[lineIndex] == Shriek) opcodeValue |= WriteBackBit;
        }
      } else {
        immValue = RegisterRelExpr(line, &lineIndex, &sourceReg1, FALSE,
          &defined);
        if (errorFound) { return FALSE; }; /* if */
        opcodeValue |= PreBit;
        if (sourceReg1 == 15) { immValue -= programCounter+8; }; /* if */
        if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
          Report(AsmError,errors_DatOff);
          return FALSE;
        }
        if (immValue < 0x400) opcodeValue |= UpBit;
        immValue = abs((int)immValue) / 4L;
        if (line[lineIndex] == Shriek) {
          lineIndex++;
          opcodeValue |= WriteBackBit;
        }
      }
      CodeWord(opcodeValue + immValue + destReg*0x1000 + sourceReg1*0x10000);
      break;

      case CPDT:
      cop = CPNameExpr(line, &lineIndex);
      lineIndex++;  /* Step past comma */
      destReg = CPRegisterExpr(line, &lineIndex);  /* Destination/source */
      lineIndex++;  /* Step past comma */
      while (isWhiteSpace(line[lineIndex])) lineIndex++;
      if (line[lineIndex] == SquareBra) {
        lineIndex++;
        sourceReg1 = RegisterExpr(line, &lineIndex);
        if (errorFound) return FALSE;
        /* Here we split according to pre/post indexing */
        if (line[lineIndex] == SquareKet)
        { /* This is probably the post-indexed form */
          lineIndex++;
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] != Comma)
          { opcodeValue |= UpBit;
            /* Allow optional shriek */
            if (line[lineIndex] == Shriek)
            { lineIndex++;
              opcodeValue |= WriteBackBit;  /* We must write back */
            }
            immValue = 0;
          }
          else
          { /* Definitely post-indexed */
            lineIndex++;
            while (isWhiteSpace(line[lineIndex])) lineIndex++;
            lineIndex++;
            immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
            if (errorFound) return FALSE;
            if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0))
            { Report(AsmError,errors_DatOff);
              return FALSE;
            }
            if (immValue < 0x400) opcodeValue |= UpBit;
            immValue = (abs((int)immValue)) / 4L;
            opcodeValue |= WriteBackBit;  /* We must write back */
          }
        }
        else
        { /* This is definitely pre-indexed */
          opcodeValue |= PreBit;
          lineIndex++;/*Past comma*/
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          lineIndex++;/*Past hash*/
          immValue = ConstantExpr(line, &lineIndex, FALSE, &defined);
          if (errorFound) { return FALSE; }; /* if */
          if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
            Report(AsmError,errors_DatOff);
            return FALSE;
          }; /* if */
          if (immValue < 0x400) opcodeValue |= UpBit;
          immValue = abs((int)immValue) / 4L;
          lineIndex++;
          while (isWhiteSpace(line[lineIndex])) lineIndex++;
          if (line[lineIndex] == Shriek) {
            lineIndex++;
            opcodeValue |= WriteBackBit;
          }
        }
      } else {
        immValue = RegisterRelExpr(line, &lineIndex, &sourceReg1, FALSE,
           &defined);
        if (errorFound) { return FALSE; }; /* if */
        opcodeValue |= PreBit;
        if (sourceReg1 == 15) { immValue -= programCounter+8; }; /* if */
        if ((abs((int)immValue) >= 0x400) || (immValue % 4 != 0)) {
          Report(AsmError,errors_DatOff);
          return FALSE;
        }; /* if */
        if (immValue < 0x400) { opcodeValue |= UpBit; }; /* if */
        immValue = abs((int)immValue) / 4L;
        if (line[lineIndex] == Shriek) {
          lineIndex++;
          opcodeValue |= WriteBackBit;
        }
      }
      CodeWord(opcodeValue + immValue + sourceReg1*0x10000 + destReg*0x1000 +
        cop*0x100);
      break;

      case CPDO:
      cop = CPNameExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      opcodeValue |= ConstantExpr(line, &lineIndex, FALSE, &defined)*0x100000;
      lineIndex++;/*Step past comma*/
      destReg = CPRegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      sourceReg1 = CPRegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past*/
      sourceReg2 = CPRegisterExpr(line, &lineIndex);
      if (line[lineIndex] == Comma) {
        lineIndex++;/*Step past*/
        opcodeValue |= ConstantExpr(line, &lineIndex, FALSE, &defined)*0x20;
      }; /* if */
      CodeWord(opcodeValue + sourceReg1*0x10000 + sourceReg2 + destReg*0x1000 +
        cop*0x100);
      break;

      case CPRT:
      cop = CPNameExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      opcodeValue |= ConstantExpr(line, &lineIndex, FALSE, &defined)*0x200000;
      lineIndex++;/*Step past comma*/
      destReg = RegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past comma*/
      sourceReg1 = CPRegisterExpr(line, &lineIndex);
      lineIndex++;/*Step past*/
      sourceReg2 = CPRegisterExpr(line, &lineIndex);
      if (line[lineIndex] == Comma) {
        lineIndex++;/*Step past*/
        opcodeValue |= ConstantExpr(line, &lineIndex, FALSE, &defined)*0x20;
      }; /* if */
      CodeWord(opcodeValue + sourceReg1*0x10000 + sourceReg2 + destReg*0x1000 +
        cop*0x100);
      break;

      case MUL:
      destReg = RegisterExpr(line, &lineIndex);/*Read the destination*/
      lineIndex++;/*Step past*/
      sourceReg1 = RegisterExpr(line, &lineIndex);/*Read the first source*/
      lineIndex++;/*Step past*/
      sourceReg2 = RegisterExpr(line, &lineIndex);/*Read the second source*/
      CodeWord(opcodeValue + destReg*0x10000 + sourceReg1 + sourceReg2*0x100);
      break;

      case MLA:
      destReg = RegisterExpr(line, &lineIndex);/*Read the destination*/
      lineIndex++;/*Step past*/
      sourceReg1 = RegisterExpr(line, &lineIndex);/*Read the first source*/
      lineIndex++;/*Step past*/
      sourceReg2 = RegisterExpr(line, &lineIndex);/*Read the second source*/
      lineIndex++;/*Step past*/
      value = RegisterExpr(line, &lineIndex);/*Read the addend*/
      CodeWord(opcodeValue + destReg*0x10000 + sourceReg1 + sourceReg2*0x100 +
        value*0x1000);
      break;

      case SMULL:
      case SMLAL:
      case UMULL:
      case UMLAL:
      { CARDINAL destLo, destHi;
        destLo = RegisterExpr(line, &lineIndex); /* Read the Lo destination */
        lineIndex++; /* Step past */
        destHi = RegisterExpr(line, &lineIndex);/* Read the high destination */
        lineIndex++; /* Step past */
        sourceReg1 = RegisterExpr(line, &lineIndex); /* Read the 1st source */
        lineIndex++; /* Step past */
        sourceReg2 = RegisterExpr(line, &lineIndex); /* Read the 2nd source */
        CodeWord(opcodeValue + destHi*0x10000 + destLo*0x1000
                             + sourceReg1 + sourceReg2*0x100);

        break;
      }

    }; /* switch */
  }; /* if */
#ifndef AAsm
check_for_more_lines:
  if (!errorFound && !AllComment(line, &lineIndex) &&
    (line[lineIndex] == CommentSymbol)) {
    /* Multiple line coming up.
     * Note above implies as style, as otherwise it would be comment
     */
    line += lineIndex+1; /* Point to next line */
    lineIndex = 0;
    opcodeFound = FALSE;
    symbol_found = FALSE;
  } else {
    return FALSE;
  }; /* if */
  } while (1); /* For as multiple line case */
#else
  } /* end of fooling topcc */
  return FALSE;
#endif
}

/* End p2line.c */
