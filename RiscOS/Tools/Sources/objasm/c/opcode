    /* -> opcode.c
 * Title:  The opcode detection routine
 * Copyright (C) 1991 Advanced RISC Machines Limited. All rights reserved.
 */

/* RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include "hostdep.h"
#include "globvars.h"
#include "nametyp.h"
#include "opcode.h"
#include "store.h"
#include "message.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

typedef struct {
  char       key[4];
  CARDINAL   value;
  OpcodeType type;
} OpcodeEntry;

typedef struct {
  Name key;
  CARDINAL   value;
} CondEntry;

#define TableSize 80

#define CondSize  64

/* Conditions */
#define CondShift 0x10000000
#define EQCond    0x00000000
#define NECond    0x10000000
#define CSCond    0x20000000
#define CCCond    0x30000000
#define MICond    0x40000000
#define PLCond    0x50000000
#define VSCond    0x60000000
#define VCCond    0x70000000
#define HICond    0x80000000
#define LSCond    0x90000000
#define GECond    0xA0000000
#define LTCond    0xB0000000
#define GTCond    0xC0000000
#define LECond    0xD0000000
#define ALCond    0xE0000000
#define NVCond    0xF0000000

/* Group 1 */
#define ANDCode   0x00000000
#define EORCode   0x00200000
#define RSBCode   0x00600000
#define ADCCode   0x00A00000
#define SBCCode   0x00C00000
#define RSCCode   0x00E00000
#define TSTCode   0x01100000
#define TEQCode   0x01300000
#define CMPCode   0x01500000
#define CMNCode   0x01700000
#define ORRCode   0x01800000
#define BICCode   0x01C00000
#define ANDSCode  0x00100000
#define EORSCode  0x00300000
#define SUBSCode  0x00500000
#define RSBSCode  0x00700000
#define ADDSCode  0x00900000
#define ADCSCode  0x00B00000
#define SBCSCode  0x00D00000
#define RSCSCode  0x00F00000
#define TSTSCode  TSTCode
#define TEQSCode  TEQCode
#define CMPSCode  CMPCode
#define CMNSCode  CMNCode
#define TSTPCode  0x0110F000
#define TEQPCode  0x0130F000
#define CMPPCode  0x0150F000
#define CMNPCode  0x0170F000
#define ORRSCode  0x01900000
#define MOVSCode  0x01B00000
#define BICSCode  0x01D00000
#define MVNSCode  0x01F00000

/* Group 2 */
#define STRCode   0x04000000
#define LDRBCode  0x04500000
#define STRBCode  0x04400000
#define LDRTCode  0x04300000
#define STRTCode  0x04200000
#define LDRBTCode 0x04700000
#define STRBTCode 0x04600000

/* Group 3 */
#define SWICode   0x0F000000

/* Group 4 */
#define LDMEDCode 0x09900000
#define STMEDCode 0x08000000
#define LDMFDCode 0x08900000
#define STMFDCode 0x09000000
#define LDMEACode 0x09100000
#define STMEACode 0x08800000
#define LDMFACode 0x08100000
#define STMFACode 0x09800000
#define LDMDBCode LDMEACode
#define STMDBCode STMFDCode
#define LDMDACode LDMFACode
#define STMDACode STMEDCode
#define LDMIBCode LDMEDCode
#define STMIBCode STMFACode
#define LDMIACode LDMFDCode
#define STMIACode STMEACode
#define IncBit    0x00800000
#define PreBit    0x01000000

/* Group 5 */
#define BCode     0x0A000000
#define BLCode    0x0B000000

/* Group 6 */
#define ADRCode   0x02000000
/* ADR just consists of the immediate bit for a Data Processing Op! */

/*Group 7*/
#define LDFCode  0x0C100100
#define STFCode  0x0C000100

/*Group 8*/
#define ADFCode  0x0E000100
#define MUFCode  0x0E100100
#define SUFCode  0x0E200100
#define RSFCode  0x0E300100
#define DVFCode  0x0E400100
#define RDFCode  0x0E500100
#define POWCode  0x0E600100
#define RPWCode  0x0E700100
#define RMFCode  0x0E800100
#define FMLCode  0x0E900100
#define FDVCode  0x0EA00100
#define FRDCode  0x0EB00100
#define POLCode  0x0EC00100

/*Group 9*/
#define MVFCode  0x0E008100
#define MNFCode  0x0E108100
#define ABSCode  0x0E208100
#define RNDCode  0x0E308100
#define SQTCode  0x0E408100
#define LOGCode  0x0E508100
#define LGNCode  0x0E608100
#define EXPCode  0x0E708100
#define SINCode  0x0E808100
#define COSCode  0x0E908100
#define TANCode  0x0EA08100
#define ASNCode  0x0EB08100
#define ACSCode  0x0EC08100
#define ATNCode  0x0ED08100

/*Group 10*/
#define CMFCode  0x0E90F110
#define CNFCode  0x0EB0F110
#define CMFECode 0x0ED0F110
#define CNFECode 0x0EF0F110

/*Group 11*/
#define FLTCode  0x0E000110

/*Group 12*/
#define FIXCode  0x0E100110

/*Group 13*/
#define WFSCode  0x0E200110
#define RFSCode  0x0E300110
#define WFCCode  0x0E400110
#define RFCCode  0x0E500110

/*Group 14*/
#define LMFCode  0x0C100200
#define SMFCode  0x0C000200

/*Group 15*/
#define LMFIACode 0x0C900200
#define LMFDBCode 0x0D100200
#define SMFIACode 0x0C800200
#define SMFDBCode 0x0D000200
#define LMFFDCode LMFIACode
#define LMFEACode LMFDBCode
#define SMFFDCode SMFDBCode
#define SMFEACode SMFIACode

/*Group 16*/
#define URDCode  0x0EE08100
#define NRMCode  0x0EF08100

/*Group 17*/
#define LDCCode   0x0C100000
#define STCCode   0x0C000000
#define LDCLCode  0x0C500000
#define STCLCode  0x0C400000

/*Group 18*/
#define CDPCode   0x0E000000

/*Group 19*/
#define MRCCode   0x0E100010

/*Group 20*/
#define MULCode   0x00000090
#define MULSCode  0x00100090

/*Group 21*/
#define MLACode   0x00200090
#define MLASCode  0x00300090

/*Group 22*/
#define ADRLCode  0x020F0000

/*Group 23*/
#define SWPCode  0x01000090

/*Group 24*/
#define UMULLCode 0x00800090
#define SMULLCode 0x00C00090
#define UMLALCode 0x00A00090
#define SMLALCode 0x00E00090
#define LongMultiplySBit 0x00100000

/*Extra bits*/
/*For data operations*/
#define SCode 0x00000
#define DCode 0x00080
#define ECode 0x80000
#define PCode 0x20
#define MCode 0x40
#define ZCode 0x60
/*For data transfer*/
#define SingleCode 0x000000
#define DoubleCode 0x008000
#define ExtendCode 0x400000
#define PackedCode 0x408000

static BOOLEAN initialised = FALSE;

static CondEntry   conditions[CondSize];

static OpcodeEntry opcodes[TableSize] = {
  {"ABS", ABSCode, FPMonadic},
  {"ACS", ACSCode, FPMonadic},
  {"ADC", ADCCode, DataProcessing},
  {"ADD", ADDCode, DataProcessing},
  {"ADF", ADFCode, FPDyadic},
  {"ADR", ADRCode, Adr},
  {"AND", ANDCode, DataProcessing},
  {"ASN", ASNCode, FPMonadic},
  {"ATN", ATNCode, FPMonadic},
  {"BIC", BICCode, DataProcessing},
  {"CDP", CDPCode, CPDO},
  {"CMF", CMFCode, FPCompare},
  {"CMN", CMNCode, DataProcessing},
  {"CMP", CMPCode, DataProcessing},
  {"CNF", CNFCode, FPCompare},
  {"COS", COSCode, FPMonadic},
  {"DVF", DVFCode, FPDyadic},
  {"EOR", EORCode, DataProcessing},
  {"EXP", EXPCode, FPMonadic},
  {"FDV", FDVCode, FPDyadic},
  {"FIX", FIXCode, FPFix},
  {"FLT", FLTCode, FPFloat},
  {"FML", FMLCode, FPDyadic},
  {"FRD", FRDCode, FPDyadic},
  {"LDC", LDCCode, CPDT},
  {"LDF", LDFCode, FPDataTransfer},
  {"LDM", LDMDACode, BlockData},
  {"LDR", LDRCode, DataTransfer},
  {"LEA", ADRCode, Adr},
  {"LFM", LMFCode, FPBlock},
  {"LGN", LGNCode, FPMonadic},
  {"LOG", LOGCode, FPMonadic},
  {"MCR", MCRCode, CPRT},
  {"MLA", MLACode, MLA},
  {"MNF", MNFCode, FPMonadic},
  {"MOV", MOVCode, DataProcessing},
  {"MRC", MRCCode, CPRT},
  {"MRS", MRSCode, MVP},
  {"MSR", MSRCode, MVP},
  {"MUF", MUFCode, FPDyadic},
  {"MUL", MULCode, MUL},
  {"MVF", MVFCode, FPMonadic},
  {"MVN", MVNCode, DataProcessing},
  {"NRM", NRMCode, FPNorm},
  {"ORR", ORRCode, DataProcessing},
  {"POL", POLCode, FPDyadic},
  {"POW", POWCode, FPDyadic},
  {"QMA", MLACode, MLA},
  {"QML", MULCode, MUL},
  {"RDF", RDFCode, FPDyadic},
  {"RFC", RFCCode, FPStatus},
  {"RFS", RFSCode, FPStatus},
  {"RMF", RMFCode, FPDyadic},
  {"RND", RNDCode, FPMonadic},
  {"RPW", RPWCode, FPDyadic},
  {"RSB", RSBCode, DataProcessing},
  {"RSC", RSCCode, DataProcessing},
  {"RSF", RSFCode, FPDyadic},
  {"SBC", SBCCode, DataProcessing},
  {"SFM", SMFCode, FPBlock},
  {"SIN", SINCode, FPMonadic},
  {"SML", SMLALCode, SMLAL},
  {"SMU", SMULLCode, SMULL},
  {"SQT", SQTCode, FPMonadic},
  {"STC", STCCode, CPDT},
  {"STF", STFCode, FPDataTransfer},
  {"STM", STMDACode, BlockData},
  {"STR", STRCode, DataTransfer},
  {"SUB", SUBCode, DataProcessing},
  {"SUF", SUFCode, FPDyadic},
  {"SWI", SWICode, SWI},
  {"SWP", SWPCode, SWP},
  {"TAN", TANCode, FPMonadic},
  {"TEQ", TEQCode, DataProcessing},
  {"TST", TSTCode, DataProcessing},
  {"UML", UMLALCode, UMLAL},
  {"UMU", UMULLCode, UMULL},
  {"URD", URDCode, FPNorm},
  {"WFC", WFCCode, FPStatus},
  {"WFS", WFSCode, FPStatus}
};

static int32 OpcodeFind(Name name)
{
  CARDINAL i,lb=0,ub=TableSize;
  int32 cmp;
  char *nptr=name.key, *iptr;

/* Do a binary chop on the ordered array of OpcodeEntries */

  while (lb!=ub) {
    i=(lb+ub)/2;
    iptr=opcodes[i].key;
    if ((cmp=(int32)nptr[0]-(int32)iptr[0])==0) {
      if ((cmp=(int32)nptr[1]-(int32)iptr[1])==0) {
        cmp=(int32)nptr[2]-(int32)iptr[2];
      }
    }
    if (cmp==0) return i;
    if (cmp<0)  ub=i;
    else        lb=i+1;
  }
  return -1;
}

static void Conditional(CARDINAL index, CARDINAL *condition,
  Name *name, char *opcodeChars)
{
  char *op = name->key+index;
  CARDINAL i =
    ((32L*(*op-0x40L) + op[1]-0x40) >> 2) & ((CondSize) - 1L);
  { CondEntry *cond = &(conditions[i]);
    if ((cond->key.length == 2) && (*op == *cond->key.key) &&
      (op[1] == cond->key.key[1])) {
      *condition = cond->value;
      /* Only copy opcode if there is a conditional in the middle */
      memcpy(opcodeChars, name->key, (size_t)index);
      memcpy(opcodeChars + index, name->key + index + 2,
        (size_t)(name->length - index -2));
      name->length -= 2;
      name->key = opcodeChars;
    }
  }
}

BOOLEAN Opcode(Name name, OpcodeType *opcodeType, CARDINAL *opcodeValue)
/*The result is TRUE iff the name is an opcode*/
{
  CARDINAL conditionalPart = ALCond,
           i;
  int32    index;
#ifdef DUAL_FPU_FRIG
  BOOLEAN  eXtraFPU = FALSE;
#endif
  BOOLEAN  conditionsParsed = FALSE;
  char     chs[9],
           opcodeChars[8],
           ch;

#ifdef HOST_IS_RISCOS
  if (!uppercase_flag)  /* IDJ (Acorn) support for -UpperCase */
#endif
  if ((name.length >= 1) && (name.length <= 8))
  { i = 0;
    while ((i < name.length) && islower(name.key[i]))
    { chs[i] = toupper(name.key[i]);
      i++;
    }
    if (i == name.length)
      /* Was all lower case, so we can try it as an opcode */
      name.key = chs;
  }

#ifdef DUAL_FPU_FRIG
  if (name.key[0] == 'X')
  { eXtraFPU = TRUE;
    ++(name.key);
    --(name.length);
  }
#endif

  switch (name.length) {
    case 1:
    if (*name.key == 'B') {
      *opcodeValue = BCode + conditionalPart;
      *opcodeType = Branch;
      return TRUE;
    };
    return FALSE;

    case 2:
    if ((*name.key == 'B') && (name.key[1] == 'L')) {
      *opcodeValue = BLCode + conditionalPart;
      *opcodeType = Branch;
      return TRUE;
    };
    return FALSE;

    case 3:
    if (*name.key == 'B')
      Conditional(1, &conditionalPart, &name, opcodeChars);
      conditionsParsed=TRUE;
    break;

    case 4:
    if ((*name.key == 'B') && (name.key[1] == 'L'))
      Conditional(2, &conditionalPart, &name, opcodeChars);
      conditionsParsed=TRUE;
    break;

    case 5:
    case 6:
    case 7:
    case 8:
    /* Don't parse the conditional part yet - we don't know where
     * it is yet due to UMULL etc
     */
    break;

    default:
    return FALSE;
    /*not an opcode*/
  }; /* case */

#ifdef DUAL_FPU_FRIG
  /* The following is a AWFUL frig for the FPA people...            */
  /* The idea is that if the instruction starts with an 'X' then    */
  /* it uses co-processors 9, 10 rather than 1, 2; However, BEWARE: */
  /* it may be bad for your code to go XMUL or XLDR...              */
  if (eXtraFPU) conditionalPart += 0x800L;
#endif

  /* Now we are ready to look up the opcode without conditional parts
   * interfering with the first 3 characters
   */
  switch (name.length) {

    case 1:
    if (*name.key == 'B') {
      *opcodeValue = BCode + conditionalPart;
      *opcodeType = Branch;
      return TRUE;
    }

    case 2:
    if ((*name.key == 'B') && (name.key[1] == 'L')) {
      *opcodeValue = BLCode + conditionalPart;
      *opcodeType = Branch;
      return TRUE;
    }

    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    index = OpcodeFind(name);
    { OpcodeEntry *opc = opcodes + index;
      if (index>=0 && (memcmp(name.key, opc->key, 3) == 0))
        {
        if (conditionsParsed==FALSE) switch (opc->type) {
          case UMULL :
          case UMLAL :
          case SMULL :
          case SMLAL :
            Conditional(5, &conditionalPart, &name, opcodeChars);
            break;
          case FPCompare :
            if (name.length==6) {
              Conditional(4, &conditionalPart, &name, opcodeChars);
            }
            Conditional(3, &conditionalPart, &name, opcodeChars);
            break;
          default:
            Conditional(3, &conditionalPart, &name, opcodeChars);
            break;
        }
        *opcodeValue = opc->value + conditionalPart;
        *opcodeType = opc->type;
        switch (name.length) {
          case 7:
          case 8:
            return FALSE;
          case 3:
          switch (opc->type) {
            case DataProcessing:
            case DataTransfer:
            case SWI:
            case Adr:
            case FPCompare:
            case FPFloat:
            case FPFix:
            case FPStatus:
            case FPBlock:
            case CPRT:
            case CPDT:
            case CPDO:
            case MUL:
            case MLA:
            case SWP:
            case MVP:
            break;

            case Branch:
            case BlockData:
            case FPDataTransfer:
            case FPDyadic:
            case FPMonadic:
            case FPNorm:
            case ADRL:
            return FALSE;
          }; /* case */
          break;

          case 4:
          ch = (name.key[3]);
          switch (opc->type) {
            case DataProcessing:
            if (ch == 'S') *opcodeValue |= ANDSCode;
            else if ((ch == 'P') && (opc->value >= TSTCode) &&
              (opc->value <= CMNCode))
              *opcodeValue += TSTPCode-TSTCode;
            else return FALSE;
            break;

            case DataTransfer:
            case SWP:
            if (ch == 'B') *opcodeValue += LDRBCode-LDRCode;
            else if ((ch == 'T') && (opc->type != SWP))
              *opcodeValue += LDRTCode-LDRCode;
            else return FALSE;
            break;

            case Adr:
            if (ch == 'L') {
              *opcodeValue = ADRLCode + conditionalPart;
              *opcodeType = ADRL;
            } else return FALSE;
            break;

            case MUL:
            case MLA:
            if (ch == 'S') *opcodeValue += MULSCode-MULCode;
            else return FALSE;
            break;

            case FPDataTransfer:
            if (ch == 'S') *opcodeValue += SingleCode;
            else if (ch == 'D') *opcodeValue += DoubleCode;
            else if (ch == 'E') *opcodeValue += ExtendCode;
            else if (ch == 'P') *opcodeValue += PackedCode;
            else return FALSE;
            break;

            case FPDyadic:
            case FPMonadic:
            case FPFloat:
            case FPFix:
            case FPNorm:
            switch (ch) {
              case 'S':
              *opcodeValue += SCode;
              break;

              case 'D':
              *opcodeValue += DCode;
              break;

              case 'E':
              *opcodeValue += ECode;
              break;

              default:
              return FALSE;
            }; /* case */
            if (opc->value == FIXCode) *opcodeValue &= ~(DCode | ECode);
            /* Destination size irrelevant for FIX */
            break;

            case FPCompare:
            if (ch == 'E') *opcodeValue += CMFECode-CMFCode;
            else return FALSE;
            break;

            case CPDT:
            if (ch == 'L') *opcodeValue += LDCLCode-LDCCode;
            else return FALSE;
            break;

            default:
            return FALSE;
          }; /* case */
          break;

          case 5:
          case 6:
          switch (opc->type) {
            case DataTransfer:
            if ((name.key[3] == 'B') && (name.key[4] == 'T'))
              *opcodeValue += LDRBTCode-LDRCode;
            else return FALSE;
            break;

            case BlockData:
            ch = name.key[4];
            switch (name.key[3]) {
              case 'D':
              if (ch == 'B') *opcodeValue += PreBit;
              else if (ch != 'A') return FALSE;
              break;

              case 'E':
              i = PreBit;
              if (ch == 'D') i += IncBit;
              else if (ch != 'A') return FALSE;
              if (opc->value == STMDACode) i ^= PreBit | IncBit;
              *opcodeValue += i;
              break;

              case 'F':
              i = 0;
              if (ch == 'D') i += IncBit;
              else if (ch != 'A') return FALSE;
              if (opc->value == STMDACode) i ^= PreBit | IncBit;
              *opcodeValue += i;
              break;

              case 'I':
              *opcodeValue += IncBit;
              if (ch == 'B') *opcodeValue += PreBit;
              else if (ch != 'A') return FALSE;
              break;

              default:
              return FALSE;
            }; /* case */
            break;

            case FPDyadic:
            case FPMonadic:
            case FPFloat:
            case FPFix:
            case FPNorm:
            switch (name.key[3]) {
              case 'D':
              *opcodeValue += DCode;
              break;

              case 'E':
              *opcodeValue += ECode;
              break;

              case 'S':
              break;

              default:
              return FALSE;
            }; /* case */
            if (opc->value == FIXCode) *opcodeValue &= ~(DCode | ECode);
            /* Destination size irrelevant for FIX */
            switch (name.key[4]) {
              case 'M':
              *opcodeValue += MCode;
              break;

              case 'P':
              *opcodeValue += PCode;
              break;

              case 'Z':
              *opcodeValue += ZCode;
              break;

              default:
              return FALSE;
            }; /* case */
            break;

            case FPBlock:
            *opcodeType = FPStack;
            ch = name.key[4];
            switch (name.key[3]) {
              case 'D':
              if (ch == 'B') *opcodeValue += PreBit;
              else return FALSE;
              break;

              case 'E':
              if (ch != 'A') return FALSE;
              *opcodeValue += (opc->value == SMFCode) ? IncBit : PreBit;
              break;

              case 'F':
              if (ch != 'D') return FALSE;
              *opcodeValue += (opc->value == SMFCode) ? PreBit : IncBit;
              break;

              case 'I':
              *opcodeValue += IncBit;
              if (ch != 'A') return FALSE;
              break;

              default:
              return FALSE;
            }; /* case */
            break;

            case SMULL:
            case UMULL:
              if (name.key[3]!='L' || name.key[4]!='L') return FALSE;
              if (name.length==6) {
                if (name.key[5]!='S') return FALSE;
                *opcodeValue += LongMultiplySBit;
              }
            break;

            case SMLAL:
            case UMLAL:
              if (name.key[3]!='A' || name.key[4]!='L') return FALSE;
              if (name.length==6) {
                if (name.key[5]!='S') return FALSE;
                *opcodeValue += LongMultiplySBit;
              }
            break;

            default:
            return FALSE;
          }; /* case */
        }; /* case */
        if ((*opcodeType <= Adr) || allowFP || (*opcodeType >= CPDT)) {
          if ((*opcodeType >= FPDataTransfer) && (*opcodeType <= FPStatus))
            hadFP = TRUE;
          return TRUE;
        }; /* if */
      }; /* if */
    };
  }; /* case */
  return FALSE;
} /* End Opcode */

static void InitCond(char *chars, CARDINAL condValue)
{
  CARDINAL index = ((32L*(chars[0]-0x40L)+chars[1]-0x40) >> 2) & (CondSize-1L);
  if (conditions[index].key.length != 0) {
    fprintf(stderr,opcode_initcond_internal_err,chars);
  }
  conditions[index].value = condValue;
  conditions[index].key.length = 2;
  conditions[index].key.key = (char *) mymalloc(2);
  conditions[index].key.key[0] = chars[0];
  conditions[index].key.key[1] = chars[1];
} /* End InitCond */

void InitOpcode(void)
{
  CARDINAL i;

  if (!initialised) {
    for (i = 0; i < CondSize; i++) conditions[i].key.length = 0;

    /*Initialise conditions*/
    InitCond("EQ", EQCond);
    InitCond("NE", NECond);
    InitCond("CS", CSCond);
    InitCond("CC", CCCond);
    InitCond("MI", MICond);
    InitCond("PL", PLCond);
    InitCond("VS", VSCond);
    InitCond("VC", VCCond);
    InitCond("HI", HICond);
    InitCond("LS", LSCond);
    InitCond("GE", GECond);
    InitCond("LT", LTCond);
    InitCond("GT", GTCond);
    InitCond("LE", LECond);
    InitCond("AL", ALCond);
    InitCond("NV", NVCond);
    InitCond("HS", CSCond);
    InitCond("LO", CCCond);

    for (i=0; i<TableSize-1; i++) {
      if (strcmp(opcodes[i].key,opcodes[i+1].key)>=0) {
        fprintf(stderr,opcode_initop_internal_err,
          i,opcodes[i].key,i+1,opcodes[i+1].key);
      }
    }
    initialised = TRUE;
  }
} /* End InitOpcode */

/* End opcode.c */
