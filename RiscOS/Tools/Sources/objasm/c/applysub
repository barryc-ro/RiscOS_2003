/* -> applysub.c
 * Title: Subroutines for expression evaluation
 * Copyright (C) 1991 Advanced RISC Machines Limited. All rights reserved.
 */

#include "applysub.h"
#include "errors.h"
#include "exprstor.h"
#include "exprtyp.h"
#include "nametyp.h"
#include "message.h"
#include <string.h>
#ifdef BINARY_INCLUDES
#include "riscos.h"        /* added by NRaine */
#include <stdio.h>         /* added by NRaine */
#include "getline.h"       /* added by NRaine */
#endif

CARDINAL Coerce(CARDINAL pointer)
/*Coerce a one byte string on the stack to a one byte constant if necessary*/
{
return ((eStack[pointer].u.operand.operandType == StringOT)
  ? eStack[pointer].u.operand.u.string.key[0]
  : eStack[pointer].u.operand.u.constant);
} /* End Coerce */

static BOOLEAN CompareString(Name *name1, Name *name2, BOOLEAN *equal)
/* Returns name1 <= name2 */
{
int j;
*equal = name1->length == name2->length;
if (name1->length == 0) return TRUE;
if (name2->length == 0) return FALSE;
j = memcmp(name1->key, name2->key,
        (size_t)((name1->length > name2->length) ? name2->length : name1->length));
if (j != 0) { *equal = FALSE; return j < 0; };
return name1->length <= name2->length;
} /* End CompareString */

BOOLEAN Compare(CARDINAL pointer, CARDINAL pointer2, Operator op)
{
BOOLEAN equal;
CARDINAL op1, op2, i;

if ((eStack[pointer].u.operand.operandType == StringOT) &&
  (eStack[pointer2].u.operand.operandType == StringOT)) {
  switch (op) {
    case Less:
    return CompareString(&(eStack[pointer2].u.operand.u.string),
                &(eStack[pointer].u.operand.u.string), &equal) && !equal;
    case OpEquals:
    return CompareString(&(eStack[pointer2].u.operand.u.string),
                &(eStack[pointer].u.operand.u.string), &equal) && equal;
    case LessEquals:
    return CompareString(&(eStack[pointer2].u.operand.u.string),
                &(eStack[pointer].u.operand.u.string), &equal);
    case Greater:
    return CompareString(&(eStack[pointer].u.operand.u.string),
                &(eStack[pointer2].u.operand.u.string), &equal) && !equal;
    case NotEquals:
    (void) CompareString(&(eStack[pointer2].u.operand.u.string),
                &(eStack[pointer].u.operand.u.string), &equal);
    return !equal;

    case GreaterEquals:
    return CompareString(&(eStack[pointer].u.operand.u.string),
                &(eStack[pointer2].u.operand.u.string), &equal);
  }; /* case */
}; /* if */
if ((eStack[pointer].u.operand.operandType == ConstantOT) ||
  (eStack[pointer2].u.operand.operandType == ConstantOT)) {
  op1 = Coerce(pointer2);
  op2 = Coerce(pointer);
} else if (eStack[pointer].u.operand.operandType == PCRelOT) {
  op1 = eStack[pointer2].u.operand.u.pLabel;
  op2 = eStack[pointer].u.operand.u.pLabel;
} else if (eStack[pointer].u.operand.operandType == LogicalOT) {
  op1= eStack[pointer].u.operand.u.bool;
  op2= eStack[pointer2].u.operand.u.bool;
} else {
  /*Must be RegRel*/
  op1 = eStack[pointer2].u.operand.u.regRel.offset;
  op2 = eStack[pointer].u.operand.u.regRel.offset;
  for (i = 0; i <= 15; i++) {
    if (eStack[pointer].u.operand.u.regRel.registers[i] !=
      eStack[pointer2].u.operand.u.regRel.registers[i]) return FALSE;
  }; /* for */
}; /* if */
switch (op) {
  case Less:
  return op1 < op2;
  case OpEquals:
  return op1 == op2;
  case LessEquals:
  return op1 <= op2;
  case Greater:
  return op1 > op2;
  case NotEquals:
  return op1 != op2;
  case GreaterEquals:
  return op1 >= op2;
  default:
  return TRUE;
}; /* case */
} /* End Compare */

void CcSub(CARDINAL pointer, CARDINAL pointer2)
{
char *tempString;

CARDINAL i,
         op1 = eStack[pointer].u.operand.u.string.length,
         op2 = eStack[pointer2].u.operand.u.string.length;
if (op2 + op1 > MaxStringSize) {
  Report(AsmError,errors_StringOver);
  return;
}; /* if */
ExprStore_alloc(&tempString, op2 + op1);
if (op2 > 0) {
  for (i = 0; i <= op2 - 1; i++)
    tempString[i] = eStack[pointer2].u.operand.u.string.key[i];
}; /* if */
if (op1 > 0) {
  for (i = 0; i <= op1 - 1; i++)
    tempString[op2 + i] = eStack[pointer].u.operand.u.string.key[i];
}; /* if */
eStack[pointer2].u.operand.u.string.length = op1 + op2;
eStack[pointer2].u.operand.u.string.key = tempString;
} /* End CcSub */

void LenSub(CARDINAL pointer, CARDINAL pointer2)
{
CARDINAL op1 = eStack[pointer].u.operand.u.string.length;
eStack[pointer2].type = OperandEST;
eStack[pointer2].u.operand.operandType = ConstantOT;
eStack[pointer2].u.operand.u.constant = op1;
} /* End LenSub */



/**** Added by NRaine ****/

void FInfoSub(int index,
            CARDINAL pointer,
            CARDINAL pointer2)
{
#ifdef BINARY_INCLUDES
  __riscos_osfile_block fblk;
  char errbuf[MaxLineLength+50], filename[MaxLineLength+1];
  char *f = eStack[pointer].u.operand.u.string.key;
  int len = eStack[pointer].u.operand.u.string.length;
  int i;

  for (i=0;i<len;i++) filename[i] = f[i];
  filename[len] = 0;
  switch(__riscos_osfile(5, filename, &fblk)) {
case 0: sprintf(errbuf,applysub_finfosub_fnotf,filename);
        Report(AsmError,errbuf);
        break;
case 1: eStack[pointer2].type = OperandEST;
        eStack[pointer2].u.operand.operandType = ConstantOT;
        eStack[pointer2].u.operand.u.constant = ((int *)&fblk)[index];
        break;
case 2: sprintf(errbuf,applysub_finfosub_direct,filename);
        Report(AsmError,errbuf);
  }
#else
  /* suppress unused warning */
  index = index;  pointer = pointer;  pointer2 = pointer2;
#endif /* BINARY_INCLUDES */
}

void ChrSub(CARDINAL pointer, CARDINAL pointer2)
{
CARDINAL op1;
op1 = eStack[pointer].u.operand.u.constant % 0x100;
eStack[pointer2].type = OperandEST;
eStack[pointer2].u.operand.operandType = StringOT;
ExprStore_alloc(&eStack[pointer2].u.operand.u.string.key, 1);
*eStack[pointer2].u.operand.u.string.key = (char)op1;
eStack[pointer2].u.operand.u.string.length = 1;
} /* End ChrSub */

#define string_len 8

void StrSub(CARDINAL pointer, CARDINAL pointer2)
{
CARDINAL op1,
         op2;
int      i;

BOOLEAN boolValue;

eStack[pointer2].type = OperandEST;
switch (eStack[pointer].u.operand.operandType) {
  case ConstantOT:
  op1 = eStack[pointer].u.operand.u.constant;
  eStack[pointer2].u.operand.operandType = StringOT;
  ExprStore_alloc(&eStack[pointer2].u.operand.u.string.key, 8);
  eStack[pointer2].u.operand.u.string.length = string_len;
  for (i = string_len-1; i >= 0; i--) {
    op2 = op1 % 16;
    eStack[pointer2].u.operand.u.string.key[i] = (char) ((op2 < 10) ?
        op2 + '0': op2 - 10 + 'A');
    op1 = op1 >> 4;
  }; /* for */
  break;

  case LogicalOT:
  boolValue = eStack[pointer].u.operand.u.bool;
  eStack[pointer2].u.operand.operandType = StringOT;
  ExprStore_alloc(&eStack[pointer2].u.operand.u.string.key, 1);
  eStack[pointer2].u.operand.u.string.length = 1;
  *eStack[pointer2].u.operand.u.string.key = (boolValue) ? 'T' : 'F';
}; /* case */
} /* End StrSub */

/* End applysub.c */
