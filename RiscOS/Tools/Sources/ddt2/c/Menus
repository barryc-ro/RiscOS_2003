/**************************************************************/
/* File:    Menus.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Generic menu handling.                            */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 20-Oct-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <string.h>

#include <kernel.h>

#include <tboxlibs/event.h>
#include <tboxlibs/toolbox.h>

#include "BEMenu.h"
#include "Errors.h"
#include "Global.h"
#include "MainMenu.h"

#include "Menus.h"

/* Local structures */

typedef struct menu_handler
{
  int                   e_to_be_shown;
  ToolboxEventHandler * to_be_shown;

  int                   e_selection;
  ToolboxEventHandler * selection;

  int                   e_hidden;
  ToolboxEventHandler * hidden;

} menu_handler;

/* Local variables */

/* The array of handlers. You MUST supply a Selection handler and */
/* all three event codes; the other two function pointers may be  */
/* NULL if the generic ToBeShown and Hidden handlers are enough.  */

static menu_handler menu_handlers[] = {
                                        { MainMenu_EToBeShown, mainmenu_to_be_shown, MainMenu_ESelection, mainmenu_selection, MainMenu_EHidden, NULL },
                                        { BEMenu_EToBeShown,   bemenu_to_be_shown,   BEMenu_ESelection,   bemenu_selection,   BEMenu_EHidden,   NULL },
                                        { 0,                   NULL,                 0,                   NULL,               0,                NULL }
                                      };

/* Local functions */

static menu_handler * menus_find_handler        (menu_handler * hdl);

static int            menus_generic_to_be_shown (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int            menus_generic_hidden      (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/**************************************************************/
/* menus_find_handler()                                       */
/*                                                            */
/* Ensures a given handler address is in the handler array.   */
/*                                                            */
/* Parameters: Pointer to a menu_handler structure.           */
/*                                                            */
/* Returns:    The same pointer, or NULL if the item was      */
/*             invalid.                                       */
/**************************************************************/

static menu_handler * menus_find_handler(menu_handler * hdl)
{
  unsigned int i = 0;

  dprintf(("Menu", "menus_find_handler: Called for &%08X\n", (unsigned int) hdl));

  if (hdl == NULL)
  {
    dprintf(("Menu", "menus_find_handler: NULL items are not allowed\n"));

    return NULL;
  }

  while (menu_handlers[i].selection != NULL)
  {
    if (&menu_handlers[i] == hdl)
    {
      dprintf(("Menu", "menus_find_handler: Successful\n"));

      return hdl;
    }

    i++;
  }

  dprintf(("Menu", "menus_find_handler: Did not find item\n"));

  return NULL;
}

/**************************************************************/
/* menus_register_primary_handlers()                          */
/*                                                            */
/* Register a generic TobeShown handler for all ToBeShown     */
/* event codes in the menu_handlers array.                    */
/**************************************************************/

_kernel_oserror * menus_register_primary_handlers(void)
{
  unsigned int i = 0;

  dprintf(("Menu", "menus_register_primary_handlers: Called\n"));

  while (menu_handlers[i].selection != NULL)
  {
    dprintf(("Menu", "menus_register_primary_handlers: Registering entry %d\n", i));

    RetError(event_register_toolbox_handler(-1,
                                            menu_handlers[i].e_to_be_shown,
                                            menus_generic_to_be_shown,
                                            (void *) &menu_handlers[i]));
    i++;
  }

  dprintf(("Menu", "menus_register_primary_handlers: Successful\n"));

  return NULL;
}

/**************************************************************/
/* menus_deregister_primary_handlers()                        */
/*                                                            */
/* Deregister all ToBeShown handlers registered with          */
/* menus_register_primary_handlers.                           */
/**************************************************************/

_kernel_oserror * menus_deregister_primary_handlers(void)
{
  unsigned int i = 0;

  dprintf(("Menu", "menus_deregister_primary_handlers: Called\n"));

  while (menu_handlers[i].selection != NULL)
  {
    dprintf(("Menu", "menus_deregister_primary_handlers: Deregistering entry %d\n", i));

    RetError(event_deregister_toolbox_handler(-1,
                                              menu_handlers[i].e_to_be_shown,
                                              menus_generic_to_be_shown,
                                              (void *) &menu_handlers[i]));
    i++;
  }

  dprintf(("Menu", "menus_deregister_primary_handlers: Successful\n"));

  return NULL;
}

/**************************************************************/
/* menus_generic_to_be_shown()                                */
/*                                                            */
/* Called before any menu is shown.                           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* 'handle' should point to an initialised menu_handler       */
/* structure, which must have a non-NULL 'selection' field.   */
/**************************************************************/

static int menus_generic_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  menu_handler * hdl = (menu_handler *) handle;

  dprintf(("Menu", "menus_generic_to_be_shown: Called for &%08X\n", (unsigned int) hdl));

  if (menus_find_handler(hdl) == NULL) ChkError(errors_frontend_error(fee_invalid_parameters,
                                                                      1,
                                                                      "menus_generic_to_be_shown"));

  /* Install the Selection handler. menus_register_primary_handler */
  /* has ensured that we're only ever called for items with a      */
  /* Selection handler present.                                    */

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          hdl->e_selection,
                                          hdl->selection,
                                          (void *) hdl));

  /* Install the generic "hidden" handler */

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          hdl->e_hidden,
                                          menus_generic_hidden,
                                          (void *) hdl));

  /* If there is one, exit through the custom ToBeShown handler */

  dprintf(("Menu", "menus_generic_to_be_shown: Successful, exitting via %s\n", hdl->to_be_shown != NULL ? "custom handler" : "return (1)"));

  if (hdl->to_be_shown != NULL) return (hdl->to_be_shown)(eventcode, event, idb, handle);
  else                          return 1;
}

/**************************************************************/
/* menus_generic_hidden()                                     */
/*                                                            */
/* Called after any menu is hidden.                           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* 'handle' should point to an initialised menu_handler       */
/* structure.                                                 */
/**************************************************************/

static int menus_generic_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  menu_handler * hdl = (menu_handler *) handle;

  dprintf(("Menu", "menus_generic_hidden: Called for &%08X\n", (unsigned int) hdl));

  if (menus_find_handler(hdl) == NULL) ChkError(errors_frontend_error(fee_invalid_parameters,
                                                                      1,
                                                                      "menus_generic_hidden"));
  /* Deregister all object-specific handlers */

  ChkError(event_deregister_toolbox_handlers_for_object(idb->self_id));

  /* If there is one, exit through the custom Hidden handler */

  dprintf(("Menu", "menus_generic_hidden: Successful, exitting via %s\n", hdl->hidden != NULL ? "custom handler" : "return (1)"));

  if (hdl->hidden != NULL) return (hdl->hidden)(eventcode, event, idb, handle);
  else                     return 1;
}

/**************************************************************/
/* menus_get_description()                                    */
/*                                                            */
/* If you want to copy a menu entry, a MenuTemplateEntry      */
/* structure from the Toolbox isn't enough. Items are in the  */
/* wrong format (e.g. object names instead of IDs) and some   */
/* things are missing (e.g. ticked state).                    */
/*                                                            */
/* Instead, call this function. It'll build an appropriate    */
/* template from the given component into a custom structure  */
/* that includes a MenuTemplateEntry. You then set the 'text' */
/* and 'max_text' fields of that substructure to the required */
/* values, create a new item using the now fully initialised  */
/* substructure, and call menus_set_description to finish it  */
/* all off.                                                   */
/*                                                            */
/* Parameters: Object ID that the template menu entry lies    */
/*             in;                                            */
/*                                                            */
/*             Component ID of the template menu entry item;  */
/*                                                            */
/*             Pointer to a writeable menus_entry structure   */
/*             that will be initialised;                      */
/*                                                            */
/* Assumes:    menus_entry structure contents will be corrupt */
/*             if an error is raised.                         */
/**************************************************************/

_kernel_oserror * menus_get_description(ObjectId o, ComponentId c, menus_entry * entry)
{
  if (entry == NULL) return errors_frontend_error(fee_invalid_parameters,
                                                  1,
                                                  "menus_get_description");

  /* First, the mostly static basic template. */

  entry->template.flags         = 0;
  entry->template.component_id  = c;
  entry->template.text          = NULL;
  entry->template.max_text      = 0;
  entry->template.click_show    = NULL;
  entry->template.submenu_show  = NULL;
  entry->template.submenu_event = 0;
  entry->template.click_event   = 0;

  RetError(menu_get_entry_help_message(0,
                                       o,
                                       c,
                                       entry->help_message,
                                       sizeof(entry->help_message) - 1,
                                       NULL));

  entry->help_message[sizeof(entry->help_message) - 1] = '\0';

  entry->template.help_message   = entry->help_message;
  entry->template.max_entry_help = strlen(entry->help_message) + 1;

  /* Now stuff that doesn't go in the template - this is what */
  /* menus_set_description will work with.                    */

  RetError(menu_get_click_event(0,
                                o,
                                c,
                                &entry->click_event));

  RetError(menu_get_click_show(0,
                               o,
                               c,
                               &entry->click_show,
                               &entry->show_flags));

  *entry->sprite = '\0';

  menu_get_entry_sprite(0,
                        o,
                        c,
                        entry->sprite,
                        sizeof(entry->sprite),
                        NULL);

  (entry->sprite)[sizeof(entry->sprite) - 1] = '\0';

  RetError(menu_get_fade(0,
                         o,
                         c,
                         &entry->fade));

  RetError(menu_get_sub_menu_event(0,
                                   o,
                                   c,
                                   &entry->submenu_event));

  RetError(menu_get_sub_menu_show(0,
                                  o,
                                  c,
                                  &entry->submenu_show));

  RetError(menu_get_tick(0,
                         o,
                         c,
                         &entry->tick));

  return NULL;
}

/**************************************************************/
/* menus_set_description()                                    */
/*                                                            */
/* Having got details of a menu entry for use as a template   */
/* in creating others with menus_get_description, and set up  */
/* any custom parts in the initialised structure after that,  */
/* create the entry using the template. Then call this        */
/* function to set up the remaining bits and pieces.          */
/*                                                            */
/* Parameters: Object ID that the new menu entry lies in;     */
/*                                                            */
/*             Component ID of that new menu entry;           */
/*                                                            */
/*             Pointer to a menus_entry structure to clone    */
/*             from, initialised by menus_get_description.    */
/**************************************************************/

_kernel_oserror * menus_set_description(ObjectId o, ComponentId c, menus_entry * entry)
{
  if (entry == NULL) return errors_frontend_error(fee_invalid_parameters,
                                                  1,
                                                  "menus_set_description");

  RetError(menu_set_click_event(0,
                                o,
                                c,
                                entry->click_event));

  RetError(menu_set_click_show(0,
                               o,
                               c,
                               entry->click_show,
                               entry->show_flags));

  menu_set_entry_sprite(0,
                        o,
                        c,
                        entry->sprite);

  RetError(menu_set_fade(0,
                         o,
                         c,
                         entry->fade));

  RetError(menu_set_sub_menu_event(0,
                                   o,
                                   c,
                                   entry->submenu_event));

  RetError(menu_set_sub_menu_show(0,
                                  o,
                                  c,
                                  entry->submenu_show));

  RetError(menu_set_tick(0,
                         o,
                         c,
                         entry->tick));
  return NULL;
}
