/**************************************************************/
/* File:    Projects.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Project struture handling.                        */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 17-Oct-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <string.h>

#include "Errors.h"
#include "FEStructs.h"
#include "Global.h"
#include "Utils.h"

#include "Projects.h"

/* Local variables */

static project * projects = NULL;

/* Local functions */

static project * project_find_project (project * p);

/**************************************************************/
/* projects_find_project()                                    */
/*                                                            */
/* For the truly paranoid, pass a project pointer and this    */
/* function will search for it in the projects list.          */
/*                                                            */
/* Parameters: Pointer to the project to find.                */
/*                                                            */
/* Returns:    The same pointer, or NULL if the item isn't in */
/*             the list.                                      */
/**************************************************************/

static project * project_find_project(project * p)
{
  project * current = projects;

  dprintf(("Proj", "projects_find_project: Called for &%08X\n", (unsigned int) p));

  if (p == NULL)
  {
    dprintf(("Proj", "projects_find_project: NULL items are not allowed\n"));

    return NULL;
  }

  while (current != NULL)
  {
    if (current == p)
    {
      dprintf(("Proj", "projects_find_project: Successful\n"));

      return p;
    }
    else
    {
      current = current->next;
    }
  }

  dprintf(("Proj", "projects_find_project: Did not find item\n"));

  return NULL;
}

/**************************************************************/
/* projects_get_list()                                        */
/*                                                            */
/* Return the head of the list of projects.                   */
/*                                                            */
/* Returns: Pointer to the first item in the list of projects */
/*          - may be NULL.                                    */
/**************************************************************/

project * projects_get_list(void)
{
  return projects;
}

/**************************************************************/
/* projects_add_project()                                     */
/*                                                            */
/* Allocate space for a new project structure.                */
/*                                                            */
/* Parameters: NUL-terminated project name, or NULL to        */
/*             auto-allocate the name;                        */
/*                                                            */
/*             Pointer to a project ** to update with the     */
/*             new value. Return value is undefined if an     */
/*             error is generated.                            */
/**************************************************************/

_kernel_oserror * projects_add_project(const char * name, project ** p)
{
  project * n;

  dprintf(("Proj", "projects_add_project: Called for '%s'\n", name ? name : "<NULL>"));

  /* Sanity check, allocate the new project structure */

  if (p == NULL || name == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_add_project");
  }

  n = calloc(1, sizeof(project));

  if (n == NULL)
  {
    return errors_frontend_error(fee_out_of_memory,
                                 1,
                                 "projects_add_project");
  }

  /* Add the name */

  n->project_name = utils_strdup(name);

  if (n->project_name == NULL)
  {
    free(n);
    return errors_frontend_error(fee_out_of_memory,
                                 1,
                                 "projects_add_project");
  }

  /* Link it in */

  n->prev  = projects;
  projects = n;
  *p       = n;

  /* Finished */

  dprintf(("Proj", "projects_add_project: Successful. New item is at &%08X\n", (unsigned int) n));

  return NULL;
}

/**************************************************************/
/* projects_remove_project()                                  */
/*                                                            */
/* Remove a project from the project list.                    */
/*                                                            */
/* Parameters: Pointer to the project.                        */
/**************************************************************/

_kernel_oserror * projects_remove_project(project * p)
{
  dprintf(("Proj", "projects_remove_project: Called for &%08X\n", (unsigned int) p));

  if (project_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_remove_project");
  }

  /* Free stuff attached to the project */

  free(p->project_name), p->project_name = NULL;
  free(p->search_path),  p->search_path  = NULL;

  RetError(projects_remove_objects(p));

  /* Unlink the item from the main list */

  if (p->prev != NULL) p->prev->next = p->next;
  if (p->next != NULL) p->next->prev = p->prev;
  if (p == projects)   projects      = p->next;

  /* Free the item itself */

  free(p);

  /* Finished */

  dprintf(("Proj", "projects_remove_project: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_remove_projects()                                 */
/*                                                            */
/* Remove all projects.                                       */
/**************************************************************/

_kernel_oserror * projects_remove_projects(void)
{
  dprintf(("Proj", "projects_remove_projects: Called\n"));

  while (projects != NULL) RetError(projects_remove_project(projects));

  dprintf(("Proj", "projects_remove_projects: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_add_object()                                      */
/*                                                            */
/* Add an object file to a project's list of objects. Callers */
/* may wish to take note of the project's number_of_objects   */
/* field on exit - this number, minus 1, is the array index   */
/* that the filename was added at. That can then be passed to */
/* projects_remove_object_by_index, rather than having to     */
/* call the slower projects_remove_object_by_name.            */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             Pointer to the NUL-terminated object filename. */
/**************************************************************/

_kernel_oserror * projects_add_object(project * p, const char * name)
{
  char ** n;

  dprintf(("Proj", "projects_add_object: Called for &%08X with '%s'\n", (unsigned int) p, name ? name : "<NULL>"));

  /* Paranoia fest */

  if (name == NULL || project_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_add_object");
  }

  /* Extend the array of filenames */

  n = realloc(p->objects, p->number_of_objects * sizeof(char *));

  if (n == NULL)
  {
    return errors_frontend_error(fee_out_of_memory,
                                 1,
                                 "projects_add_object");
  }
  else p->objects = n;

  /* Add the name to the end of the array */

  p->objects[p->number_of_objects] = utils_strdup(name);

  if (p->objects[p->number_of_objects] == NULL)
  {
    /* Don't bother reallocing the array back down as it is allocated */
    /* by absolute size at all times. The 4 bytes wasted will either  */
    /* be freed next time an item is removed or used up next time an  */
    /* item is added.                                                 */

    return errors_frontend_error(fee_out_of_memory,
                                 1,
                                 "projects_add_object");
  }
  else p->number_of_objects++;

  /* Finished */

  dprintf(("Proj", "projects_add_object: Successful. There are now %d object filenames held by this project\n", p->number_of_objects));

  return NULL;
}

/**************************************************************/
/* projects_remove_object_by_name()                           */
/*                                                            */
/* Remove an object file from a project's list of objects.    */
/* The filename match is case insensitive, though no path     */
/* canonicalisation is performed.                             */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             Pointer to the NUL-terminated object filename. */
/**************************************************************/

_kernel_oserror * projects_remove_object_by_name(project * p, const char * name)
{
  unsigned int i, found = 0;

  dprintf(("Proj", "projects_remove_object_by_name: Called for &%08X with '%s'\n", (unsigned int) p, name ? name : "<NULL>"));

  /* Paranoia fest */

  if (name == NULL || project_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_remove_object_by_name");
  }

  /* Find the item */

  for (i = 0; i < p->number_of_objects; i++)
  {
    if (!utils_strcasecmp(p->objects[i], name))
    {
      found = i + 1;
      break;
    }
  }

  /* If not found, throw back an error */

  if (found == 0)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_remove_object_by_name");
  }

  dprintf(("Proj", "projects_remove_object_by_name: Exitting through projects_remove_object_by_index with index %d\n", found - 1));

  return projects_remove_object_by_index(p, found - 1);
}

/**************************************************************/
/* projects_remove_object_by_index()                          */
/*                                                            */
/* Remove an object file from a project's list of objects     */
/* based on its index into the array of objects held by that  */
/* project.                                                   */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             Item's array index.                            */
/**************************************************************/

_kernel_oserror * projects_remove_object_by_index(project * p, unsigned int index)
{
  char ** n;

  dprintf(("Proj", "projects_remove_object_by_index: Called for &%08X with index %d\n", (unsigned int) p, index));

  if (project_find_project(p) == NULL || index >= p->number_of_objects)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_remove_object_by_index");
  }

  /* Shuffle stuff down to fill the gap if required */

  if (index < p->number_of_objects - 1)
  {
    memmove(p->objects + index,
            p->objects + index + 1,
            p->number_of_objects - index - 1);
  }

  p->number_of_objects--;

  /* Reallocate */

  n = realloc(p->objects, p->number_of_objects * sizeof(char *));

  /* This should never happen, but still... */

  if (n == NULL)
  {
    return errors_frontend_error(fee_cannot_release_memory,
                                 1,
                                 "projects_remove_object_by_index");
  }
  else p->objects = n;

  /* Finished */

  dprintf(("Proj", "projects_remove_object_by_index: Successful. There are now %d object filenames held by this project\n", p->number_of_objects));

  return NULL;
}

/**************************************************************/
/* projects_remove_objects                                    */
/*                                                            */
/* Remove all items in the list of object files for a         */
/* project.                                                   */
/*                                                            */
/* Parameters: Pointer to the project.                        */
/**************************************************************/

_kernel_oserror * projects_remove_objects(project * p)
{
  dprintf(("Proj", "projects_remove_objects: Called for &%08X\n", (unsigned int) p));

  if (project_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "projects_remove_objects");
  }

  free(p->objects);
  p->objects           = NULL;
  p->number_of_objects = 0;

  dprintf(("Proj", "projects_remove_objects: Successful\n"));

  return NULL;
}
