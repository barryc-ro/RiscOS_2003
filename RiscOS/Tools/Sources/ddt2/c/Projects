/**************************************************************/
/* File:    Projects.c                                        */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Project struture handling.                        */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 17-Oct-2000 (ADH): Created.                       */
/**************************************************************/

#include <stdlib.h>
#include <string.h>

#include "Errors.h"
#include "FEStructs.h"
#include "Global.h"
#include "Utils.h"

#include "Projects.h"

/* Local variables */

static project * projects = NULL;

/* Local functions */

static project * projects_find_project (project * p);

/**************************************************************/
/* projects_find_project()                                    */
/*                                                            */
/* For the truly paranoid, pass a project pointer and this    */
/* function will search for it in the projects list.          */
/*                                                            */
/* Parameters: Pointer to the project to find.                */
/*                                                            */
/* Returns:    The same pointer, or NULL if the item isn't in */
/*             the list.                                      */
/**************************************************************/

static project * projects_find_project(project * p)
{
  project * current = projects;

  dprintf(("Proj", "projects_find_project: Called for &%08X\n", (unsigned int) p));

  if (p == NULL)
  {
    dprintf(("Proj", "projects_find_project: NULL items are not allowed\n"));

    return NULL;
  }

  while (current != NULL)
  {
    if (current == p)
    {
      dprintf(("Proj", "projects_find_project: Successful\n"));

      return p;
    }
    else
    {
      current = current->next;
    }
  }

  dprintf(("Proj", "projects_find_project: Did not find item\n"));

  return NULL;
}

/**************************************************************/
/* projects_get_list()                                        */
/*                                                            */
/* Return the head of the list of projects.                   */
/*                                                            */
/* Returns: Pointer to the first item in the list of projects */
/*          - may be NULL.                                    */
/**************************************************************/

project * projects_get_list(void)
{
  return projects;
}

/**************************************************************/
/* projects_add_project()                                     */
/*                                                            */
/* Allocate space for a new project structure.                */
/*                                                            */
/* Parameters: NUL-terminated project name, or NULL to        */
/*             auto-allocate the name;                        */
/*                                                            */
/*             Pointer to a project ** to update with the     */
/*             new value. Return value is undefined if an     */
/*             error is generated.                            */
/**************************************************************/

_kernel_oserror * projects_add_project(const char * name, project ** p)
{
  project * n;

  dprintf(("Proj", "projects_add_project: Called for '%s'\n", name ? name : "<NULL>"));

  /* Sanity check, allocate the new project structure */

  if (p == NULL || name == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_add_project");
  }

  n = calloc(1, sizeof(project));

  if (n == NULL)
  {
    return errors_frontend_error(fee_out_of_memory,
                                 "projects_add_project");
  }

  /* Add the name */

  n->project_name = utils_strdup(name);

  if (n->project_name == NULL)
  {
    free(n);
    return errors_frontend_error(fee_out_of_memory,
                                 "projects_add_project");
  }

  /* Link it in */

  n->prev  = projects;
  projects = n;
  *p       = n;

  /* Finished */

  dprintf(("Proj", "projects_add_project: Successful. New item is at &%08X\n", (unsigned int) n));

  return NULL;
}

/**************************************************************/
/* projects_remove_project()                                  */
/*                                                            */
/* Remove a project from the project list.                    */
/*                                                            */
/* Parameters: Pointer to the project.                        */
/**************************************************************/

_kernel_oserror * projects_remove_project(project * p)
{
  dprintf(("Proj", "projects_remove_project: Called for &%08X\n", (unsigned int) p));

  if (projects_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_remove_project");
  }

  /* Free stuff attached to the project */

  RetError(projects_clear_project(p, false));

  /* Unlink the item from the main list */

  if (p->prev != NULL) p->prev->next = p->next;
  if (p->next != NULL) p->next->prev = p->prev;
  if (p == projects)   projects      = p->next;

  /* Free the item itself */

  free(p);

  /* Finished */

  dprintf(("Proj", "projects_remove_project: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_remove_projects()                                 */
/*                                                            */
/* Remove all projects.                                       */
/**************************************************************/

_kernel_oserror * projects_remove_projects(void)
{
  dprintf(("Proj", "projects_remove_projects: Called\n"));

  while (projects != NULL) RetError(projects_remove_project(projects));

  dprintf(("Proj", "projects_remove_projects: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_add_object()                                      */
/*                                                            */
/* Add an object file to a project's list of objects. Callers */
/* may wish to take note of the project's number_of_objects   */
/* field on exit - this number, minus 1, is the array index   */
/* that the filename was added at. That can then be passed to */
/* projects_remove_object_by_index, rather than having to     */
/* call the slower projects_remove_object_by_name.            */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             false if the project is a main project, else   */
/*             true if it is a temporary (bypass pointer      */
/*             checking from the main project list);          */
/*                                                            */
/*             Pointer to the NUL-terminated object filename. */
/**************************************************************/

_kernel_oserror * projects_add_object(project * p, bool temporary, const char * name)
{
  char ** n;

  dprintf(("Proj", "projects_add_object: Called for &%08X with '%s' (%s)\n", (unsigned int) p, name ? name : "<NULL>", temporary ? "temporary" : "main list"));

  /* Paranoia fest */

  if (name == NULL || (!temporary && projects_find_project(p) == NULL))
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_add_object");
  }

  /* Extend the array of filenames */

  n = realloc(p->objects, (p->number_of_objects + 1) * sizeof(char *));

  if (n == NULL)
  {
    return errors_frontend_error(fee_out_of_memory,
                                 "projects_add_object");
  }
  else p->objects = n;

  /* Add the name to the end of the array */

  p->objects[p->number_of_objects] = utils_strdup(name);

  if (p->objects[p->number_of_objects] == NULL)
  {
    /* Don't bother reallocing the array back down as it is allocated */
    /* by absolute size at all times. The 4 bytes wasted will either  */
    /* be freed next time an item is removed or used up next time an  */
    /* item is added.                                                 */

    return errors_frontend_error(fee_out_of_memory,
                                 "projects_add_object");
  }
  else p->number_of_objects++;

  /* Finished */

  dprintf(("Proj", "projects_add_object: Successful. There %s now %d object filename%s held by this project\n",
                   p->number_of_objects == 1 ? "is" : "are",
                   p->number_of_objects,
                   p->number_of_objects == 1 ? ""   : "s"));

  return NULL;
}

/**************************************************************/
/* projects_remove_object_by_name()                           */
/*                                                            */
/* Remove an object file from a project's list of objects.    */
/* The filename match is case insensitive, though no path     */
/* canonicalisation is performed.                             */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             false if the project is a main project, else   */
/*             true if it is a temporary (bypass pointer      */
/*             checking from the main project list);          */
/*                                                            */
/*             Pointer to the NUL-terminated object filename. */
/**************************************************************/

_kernel_oserror * projects_remove_object_by_name(project * p, bool temporary, const char * name)
{
  unsigned int i, found = 0;

  dprintf(("Proj", "projects_remove_object_by_name: Called for &%08X with '%s' (%s)\n", (unsigned int) p, name ? name : "<NULL>", temporary ? "temporary" : "main list"));

  /* Paranoia fest */

  if (name == NULL || (!temporary && projects_find_project(p) == NULL))
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_remove_object_by_name");
  }

  /* Find the item */

  for (i = 0; i < p->number_of_objects; i++)
  {
    if (!utils_strcasecmp(p->objects[i], name))
    {
      found = i + 1;
      break;
    }
  }

  /* If not found, throw back an error */

  if (found == 0)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_remove_object_by_name");
  }

  dprintf(("Proj", "projects_remove_object_by_name: Exitting through projects_remove_object_by_index with index %d\n", found - 1));

  return projects_remove_object_by_index(p, temporary, found - 1);
}

/**************************************************************/
/* projects_remove_object_by_index()                          */
/*                                                            */
/* Remove an object file from a project's list of objects     */
/* based on its index into the array of objects held by that  */
/* project.                                                   */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             false if the project is a main project, else   */
/*             true if it is a temporary (bypass pointer      */
/*             checking from the main project list);          */
/*                                                            */
/*             Item's array index.                            */
/**************************************************************/

_kernel_oserror * projects_remove_object_by_index(project * p, bool temporary, unsigned int index)
{
  char ** n;

  dprintf(("Proj", "projects_remove_object_by_index: Called for &%08X with index %d (%s)\n", (unsigned int) p, index, temporary ? "temporary" : "main list"));

  if ((!temporary && projects_find_project(p) == NULL) || index >= p->number_of_objects)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_remove_object_by_index");
  }

  /* Shuffle stuff down to fill the gap if required */

  if (index < p->number_of_objects - 1)
  {
    memmove(p->objects + index,
            p->objects + index + 1,
            p->number_of_objects - index - 1);
  }

  p->number_of_objects--;

  /* Reallocate */

  n = realloc(p->objects, p->number_of_objects * sizeof(char *));

  /* This should never happen, but still... */

  if (n == NULL)
  {
    return errors_frontend_error(fee_cannot_release_memory,
                                 "projects_remove_object_by_index");
  }
  else p->objects = n;

  /* Finished */

  dprintf(("Proj", "projects_remove_object_by_index: Successful. There %s now %d object filename%s held by this project\n",
                   p->number_of_objects == 1 ? "is" : "are",
                   p->number_of_objects,
                   p->number_of_objects == 1 ? ""   : "s"));

  return NULL;
}

/**************************************************************/
/* projects_remove_objects                                    */
/*                                                            */
/* Remove all items in the list of object files for a         */
/* project.                                                   */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             false if the project is a main project, else   */
/*             true if it is a temporary (bypass pointer      */
/*             checking from the main project list).          */
/**************************************************************/

_kernel_oserror * projects_remove_objects(project * p, bool temporary)
{
  dprintf(("Proj", "projects_remove_objects: Called for &%08X (%s)\n", (unsigned int) p, temporary ? "temporary" : "main list"));

  if (!temporary && projects_find_project(p) == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_remove_objects");
  }

  free(p->objects);
  p->objects           = NULL;
  p->number_of_objects = 0;

  dprintf(("Proj", "projects_remove_objects: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_clear_project()                                   */
/*                                                            */
/* Free up all data allocated within a project structure.     */
/*                                                            */
/* Parameters: Pointer to the project;                        */
/*                                                            */
/*             false if the project is a main project, else   */
/*             true if it is a temporary (bypass pointer      */
/*             checking from the main project list).          */
/**************************************************************/

_kernel_oserror * projects_clear_project(project * t, bool temporary)
{
  dprintf(("Proj", "projects_clear_project: Called for &%08X (%s)\n", (unsigned int) t, temporary ? "temporary" : "main list"));

  if (t == NULL || (!temporary && projects_find_project(t) == NULL))
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_clear_project");
  }

  free((void *) t->project_name);
  free((void *) t->debugger_name);
  free((void *) t->search_path);

  RetError(projects_remove_objects(t, true));

  dprintf(("Proj", "projects_clear_project: Successful\n"));

  return NULL;
}

/**************************************************************/
/* projects_copy_project()                                    */
/*                                                            */
/* Copy all data from one project structure to another. This  */
/* will free (i.e. trash) any data allocated within the       */
/* destination project.                                       */
/*                                                            */
/* If there is an allocation error during the copying, the    */
/* data attached to the destination project is freed before   */
/* the function exists by raising an appropriate error.       */
/*                                                            */
/* Parameters: Pointer to the destination project;            */
/*                                                            */
/*             Pointer to the source project;                 */
/*                                                            */
/*             false if the projects are main projects, else  */
/*             true if they're temporary (bypass pointer      */
/*             checking from the main project list).          */
/**************************************************************/

_kernel_oserror * projects_copy_project(project * dst, project * src, bool temporary)
{
  _kernel_oserror * e = NULL;
  unsigned int      item;

  dprintf(("Proj", "projects_copy_project: Called to copy to &%08X from %08X (%s)\n", (int) dst, (int) src, temporary ? "temporary" : "main list"));

  /* Sanity checks... */

  if (
       src == NULL ||
       dst == NULL ||
       (
         !temporary &&
         (
           projects_find_project(src) == NULL ||
           projects_find_project(dst) == NULL
         )
       )
     )
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "projects_copy_project");
  }

  /* Remove any existant allocated data from the destination project */

  dprintf(("Proj", "projects_copy_project: Clearing the destination\n"));

  RetError(projects_clear_project(dst, temporary));

  /* This copies over pointers... */

  dprintf(("Proj", "projects_copy_project: Copying raw structure and zeroing destination pointers\n"));

  *dst = *src;

  /* ...that we must clear before copying stuff, in case there's an */
  /* allocation failure half way through or something.              */

  dst->project_name      = NULL;
  dst->debugger_name     = NULL;
  dst->search_path       = NULL;

  dst->number_of_objects = 0;
  dst->objects           = NULL;

  /* Copy simple strings */

  dprintf(("Proj", "projects_copy_project: Copying simple strings\n"));

  if (src->project_name != NULL)
  {
    dst->project_name = utils_strdup(src->project_name);
    if (dst->project_name == NULL) goto projects_copy_project_error;
  }

  if (src->debugger_name != NULL)
  {
    dst->debugger_name = utils_strdup(src->debugger_name);
    if (dst->debugger_name == NULL) goto projects_copy_project_error;
  }

  if (src->search_path != NULL)
  {
    dst->search_path = utils_strdup(src->search_path);
    if (dst->search_path == NULL) goto projects_copy_project_error;
  }

  /* Copy the objects list */

  dprintf(("Proj", "projects_copy_project: Copying objects list\n"));

  for (item = 0; item < src->number_of_objects; item++)
  {
    e = projects_add_object(dst,
                            true,
                            src->objects[item]);

    if (e != NULL) goto projects_copy_project_error;
  }

  /* Right, done */

  dprintf(("Proj", "projects_copy_project: Successful\n"));

  return NULL;

projects_copy_project_error:

  /* Out of momory */

  dprintf(("Proj", "projects_copy_project: Exitting with error (%s)\n", e ? e->errmess : "out of memory"));

  projects_clear_project(dst, temporary);

  if (e == NULL)
  {
    return errors_frontend_error(fee_out_of_memory,
                                 "projects_copy_project");
  }
  else
  {
    return e;
  }
}
