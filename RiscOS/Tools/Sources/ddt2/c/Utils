/**************************************************************/
/* File:    Utils.c                                           */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Infrequently altered utilities.                   */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 07-Apr-2000 (ADH): Adapted from Browse source.    */
/*          16-Oct-2000 (ADH): Imported from PlugPlay.        */
/*          18-Oct-2000 (ADH): Error reporting functions and  */
/*                             related definitions moved to   */
/*                             Error.c / Error.h.             */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <setjmp.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimplib.h>
#include <tboxlibs/toolbox.h>
#include <tboxlibs/gadgets.h>

#include "Errors.h"
#include "FromROSLib.h"
#include "Global.h"
#include "MiscDefs.h"
#include "NestWimp.h"
#include "Save.h"

#include "Utils.h"

/* Local definitions */

#define MillipointsPerOSUnit 400

/* Locals */

static int  millipoints_per_os_unit_x = 400; /* See read_os_to_points */
static int  millipoints_per_os_unit_y = 400;
static int  half_mppou_x              = 200;
static int  half_mppou_y              = 200;
static int  overflow_limit_x          = 0x28f5c1; /* = (0x3fffffff / 400) rounded down for caution*/
static int  overflow_limit_y          = 0x28f5c1;

/* Local functions */

static char * lookup_in_given (MessagesFD * control, const char * s, unsigned int num_args, va_list ap);

/**************************************************************/
/* lookup_token()                                             */
/*                                                            */
/* Returns a pointer to an expanded message token, or '!' if  */
/* there was an error.                                        */
/*                                                            */
/* Lookup is done into a global fixed-size buffer. So if you  */
/* pass multiple calls to this function in as parameters to   */
/* something else, *it will fail* as each call points to the  */
/* same buffer (which will only contain data from the last    */
/* call).                                                     */
/*                                                            */
/* On the upside this means you can modify the returned       */
/* string directly without having to worry about taking a     */
/* copy. If you do this, though, you *must* invalidate the    */
/* record of the last looked up token; "*lasttokn = '\0'" is  */
/* sufficient. This is all clearly hideous and best avoided,  */
/* but hey, it's handy from time to time...!                  */
/*                                                            */
/* Parameters: Pointer to a message token;                    */
/*                                                            */
/*             Number of arguments that follow (0 to 4);      */
/*                                                            */
/*             Between zero and four pointers to NUL          */
/*             terminated strings used for substitution into  */
/*             the string being looked up ('%0' to '%3').     */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

char * lookup_token(const char * s, unsigned int num_args, ...)
{
  char    * ret;
  va_list   ap;

  dprintf(("MsgT", "lookup_token: Called, exitting through lookup_in_given\n"));

  va_start(ap, num_args);
  ret = lookup_in_given(&meb, s, num_args, ap);
  va_end(ap);

  return ret;
}

/**************************************************************/
/* lookup_in_given()                                          */
/*                                                            */
/* Workhorse back-end to lookup_token, lookup_choice and      */
/* so-on. See lookup_token for more information.              */
/*                                                            */
/* Parameters: A MessagesFD pointer, giving the control block */
/*             of the file to look in;                        */
/*                                                            */
/*             Pointer to a message token;                    */
/*                                                            */
/*             Number of arguments that follow (0 to 4);      */
/*                                                            */
/*             A va_list built by va_start before calling,    */
/*             from a variable argument list.                 */
/*                                                            */
/* Returns:    Pointer to the full message text or '!' to     */
/*             signal an error; never a null pointer.         */
/*                                                            */
/* Assumes:    That the pointer to the message token is never */
/*             NULL.                                          */
/**************************************************************/

static char * lookup_in_given(MessagesFD * control, const char * s, unsigned int num_args, va_list ap)
{
  _kernel_oserror * e;
  char            * args[4];

  dprintf(("MsgT", "lookup_in_given: Lookup token '%s'\n",s));

  if (strcmp(lasttokn, (char *) s))
  {
    dprintf(("MsgT", "lookup_in_given: Proceeding\n"));

    StrNCpy0(lasttokn, (char *) s);

    args[0] = num_args > 0 ? va_arg(ap, char *) : 0;
    args[1] = num_args > 1 ? va_arg(ap, char *) : 0;
    args[2] = num_args > 2 ? va_arg(ap, char *) : 0;
    args[3] = num_args > 3 ? va_arg(ap, char *) : 0;

    e = _swix(MessageTrans_Lookup,
              _INR(0,7),

              control,            /* Pointer to control block               */
              s,                  /* String to look up                      */
              tokens,             /* Global buffer to take looked up string */
              sizeof(tokens) - 1, /* Size of the buffer                     */
              args[0],            /* Parameter 0                            */
              args[1],            /* Parameter 1                            */
              args[2],            /* Parameter 2                            */
              args[3]);           /* Parameter 3                            */

    tokens[Limits_Message - 1] = 0;

    if (e)
    {
      /* If the lookup fails, put '!' into the lookup buffer and report */
      /* the error directly.                                            */

      dprintf(("MsgT", "lookup_in_given: Failed\n"));

      *lasttokn = 0;
      strcpy(tokens, "!");

      errors_cont(e);
    }
  }

  dprintf(("MsgT", "lookup_in_given: Returning '%s'\n",tokens));

  return (char *) &tokens;
}

/**************************************************************/
/* report_toolbox_error()                                     */
/*                                                            */
/* If the toolbox generates an error this function will be    */
/* called to report it. Parameters are as standard for a      */
/* Toolbox event handler.                                     */
/**************************************************************/

int report_toolbox_error(int eventcode,ToolboxEvent *event,IdBlock *idb,void *handle)
{
  ChkError((_kernel_oserror *) &event->data);

  return 1;
}

/**************************************************************/
/* register_null_claimant()                                   */
/*                                                            */
/* Call if you want to claim null polls.                      */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void register_null_claimant(int eventcode, WimpEventHandler * handler, void * handle)
{
  null_counter++;
  ChkError(event_register_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE

    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "register_null_claimant:   Registered a claimant for handle %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0213%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \02130x%08x\0217\n", (int) handler));
      }
    }

  #endif

  if (null_counter == 1)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask & (~Wimp_Poll_NullMask));
    ChkError(event_set_mask(mask));

    dprintf(("Null", "register_null_claimant:   \0211Nulls claimed\0217\n"));
  }
}

/**************************************************************/
/* deregister_null_claimant()                                 */
/*                                                            */
/* Call if you want to release null polls.                    */
/*                                                            */
/* Parameters: As for a Wimp event handler, but without the   */
/*             object ID.                                     */
/**************************************************************/

void deregister_null_claimant(int eventcode, WimpEventHandler * handler, void * handle)
{
  null_counter--;
  ChkError(event_deregister_wimp_handler(-1,eventcode,handler,handle));

  #ifdef TRACE

    {
      int   shut_up_compiler = (int)   handler;
      int * function_name    = (int *) shut_up_compiler;

      dprintf(("Null", "deregister_null_claimant: Deregistered a claimant for handle %p\n", handle));

      /* If the word before the function address has ff in the high */
      /* byte, the function name starts as many bytes before the    */
      /* function address as specified in the low 3 bytes.          */

      function_name -= 1;

      if (((*function_name) & 0xff000000) == 0xff000000)
      {
        dprintf(("Null", "                          Handler is '\0216%s\0217'\n", (char *) (((char *) function_name) - ((*function_name) & 0x00ffffff))));
      }
      else
      {
        dprintf(("Null", "                          Cannot find handler's name; address is \2160x%08x\0217\n", (int) handler));
      }
    }

  #endif

  if (null_counter < 0) null_counter = 0;

  if (!null_counter)
  {
    unsigned int mask;

    ChkError(event_get_mask(&mask));
    mask = (mask | Wimp_Poll_NullMask);
    ChkError(event_set_mask(mask));

    dprintf(("Null", "deregister_null_claimant: \0212Nulls released\0217\n"));
  }
}

/**************************************************************/
/* intersection()                                             */
/*                                                            */
/* Takes two BBoxes and returns a pointer to a third which is */
/* the the intersection between the first two, or NULL, if    */
/* they don't intersect.                                      */
/*                                                            */
/* Parameters: Pointer to a BBox;                             */
/*                                                            */
/*             Pointer to another BBox.                       */
/*                                                            */
/* Returns:    Pointer to a BBox which is the intersection of */
/*             the given two, or NULL, if they don't          */
/*             intersect.                                     */
/**************************************************************/

BBox * intersection(BBox * a, BBox * b)
{
  static BBox intersect;

  #define max(a,b) ((a) > (b) ? (a) : (b))
  #define min(a,b) ((a) < (b) ? (a) : (b))

  if (!a || !b) return NULL;

  if ((a->xmin >= b->xmax) || (a->xmax <= b->xmin) || (a->ymin >= b->ymax) || (a->ymax <= b->ymin)) return NULL;

  intersect.xmin = max(a->xmin,b->xmin);
  intersect.xmax = min(a->xmax,b->xmax);
  intersect.ymin = max(a->ymin,b->ymin);
  intersect.ymax = min(a->ymax,b->ymax);

  return &intersect;
}

/**************************************************************/
/* set_graphics_intersection()                                */
/*                                                            */
/* Intended for redraw loop routines, this sets up a given    */
/* graphics rectangle, but takes account of the intersection  */
/* between this and the current (given) graphics rectangle    */
/* for the redraw. The rectangle *must* be restored with      */
/* restore_graphics_intersection() as soon as the rectangle   */
/* set here is finished with; the caller must thus remember   */
/* this rectangle for later.                                  */
/*                                                            */
/* Parameters: Pointer to a BBox describing the rectangle to  */
/*             set, where xmax and ymax are inclusive;        */
/*                                                            */
/*             Pointer to a BBox describing the current       */
/*             graphics rectangle, where xmax and ymax are    */
/*             exclusive (e.g. as in a                        */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/*                                                            */
/* Returns:    Pointer to a BBox describing the actual        */
/*             rectangle that was set. If this is NULL, the   */
/*             two do not intersect at all and the redraw     */
/*             subsequent graphics window restoration can and */
/*             should be skipped.                             */
/**************************************************************/

BBox * set_graphics_intersection(BBox * rbox, BBox * cbox)
{
  BBox * ibox;
  BBox   ogrect = *cbox;

  ogrect.xmax -= 1;
  ogrect.ymax -= 1;

  ibox = intersection(rbox, &ogrect);

  if (!ibox) return NULL;

  bbc_gwindow(ibox->xmin, ibox->ymin, ibox->xmax, ibox->ymax);

  return ibox;
}

/**************************************************************/
/* restore_graphics_intersection()                            */
/*                                                            */
/* Restores the Wimp's redraw graphics rectangle which was    */
/* changed by a call to set_graphics_intersection (which      */
/* *must* have been called before this restoring function).   */
/*                                                            */
/* Parameters: Pointer to a BBox holding the graphics         */
/*             rectangle as it was before                     */
/*             set_graphics_intersection was called, where    */
/*             xmax and ymax are exclusive (e.g. as in a      */
/*             WimpRedrawWindowBlock's redraw_area BBox).     */
/**************************************************************/

void restore_graphics_intersection(BBox * cbox)
{
  BBox ogrect = *cbox;

  ogrect.xmax -= 1;
  ogrect.ymax -= 1;

  bbc_gwindow(ogrect.xmin, ogrect.ymin, ogrect.xmax, ogrect.ymax);
}

/*************************************************/
/* read_os_to_points()                           */
/*                                               */
/* To avoid having to use a SWI every time       */
/* a conversion is made between OS units and     */
/* points or vice versa, this initialises        */
/* some internal variables which are used        */
/* subsequently. It may be called on a mode      */
/* change, for example, to ensure things are up  */
/* to date.                                      */
/*                                               */
/* If printing, values of MillipointsPerOSUnit   */
/* as defined at the top of this file are used,  */
/* since you can't read it; it seems that during */
/* a print job, this call may *not* be used,     */
/* contrary to the information on PRM 3-573.     */
/* This bug caused *severe* grief during the     */
/* development of the print routines...          */
/*************************************************/

void read_os_to_points(void)
{
  int x = 1, y = 1;

  if (!printing)
  {
    if (
          _swix(Font_Converttopoints,
                _INR(1,2) | _OUTR(1,2),

                x,
                y,

                &x,
                &y)
       )
    {
      millipoints_per_os_unit_x = MillipointsPerOSUnit;
      millipoints_per_os_unit_y = MillipointsPerOSUnit;
    }
    else
    {
      millipoints_per_os_unit_x = x;
      millipoints_per_os_unit_y = y;
    }
  }
  else
  {
    millipoints_per_os_unit_x = MillipointsPerOSUnit;
    millipoints_per_os_unit_y = MillipointsPerOSUnit;
  }

  overflow_limit_x = (0x3fffffff / millipoints_per_os_unit_x) - 1;
  overflow_limit_y = (0x3fffffff / millipoints_per_os_unit_y) - 1;

  half_mppou_x = millipoints_per_os_unit_x / 2;
  half_mppou_y = millipoints_per_os_unit_y / 2;
}

/*************************************************/
/* convert_pair_to_os()                          */
/*                                               */
/* Converts from millipoints to OS units. The    */
/* scale factor is determined by a previous call */
/* to read_os_to_points.                         */
/*                                               */
/* Parameters: A coordinate in millipoints;      */
/*                                               */
/*             Another coord in millipoints;     */
/*                                               */
/*             Pointer to an int into which the  */
/*             first coordinate, converted to OS */
/*             units, is placed;                 */
/*                                               */
/*             Similarly a pointer to an int for */
/*             the second coordinate.            */
/*                                               */
/* Assumes:    The pointers may NOT be NULL. The */
/*             input and output variables may be */
/*             the same (so passing in x, y, &x, */
/*             &y would work correctly).         */
/*************************************************/

void convert_pair_to_os(int x, int y, int * osx, int * osy)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  *osy = ((y + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/*************************************************/
/* convert_pair_to_points()                      */
/*                                               */
/* Converts from OS units to millipoints. The    */
/* scale factor is determined by a previous call */
/* to read_os_to_points.                         */
/*                                               */
/* Parameters: A coordinate in OS units;         */
/*                                               */
/*             Another coordinate in OS units;   */
/*                                               */
/*             Pointer to an int into which the  */
/*             first coordinate, converted to    */
/*             millipoints, is placed;           */
/*                                               */
/*             Similarly a pointer to an int for */
/*             the second coordinate.            */
/*                                               */
/* Assumes:    The pointers may not be NULL. The */
/*             input and output variables may be */
/*             the same (so passing in x, y, &x, */
/*             &y would work correctly).         */
/*************************************************/

void convert_pair_to_points(int x, int y, int * mpx, int * mpy)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x || abs(y) > overflow_limit_y)
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_pair_to_points: Can't convert (%d, %d) to millipoints without overflow.",
              x,y);

      errors_ret(&erb);

      *mpx = *mpy = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
  *mpy = y * millipoints_per_os_unit_y;
}

/*************************************************/
/* convert_to_os()                               */
/*                                               */
/* As convert_pair_to_os, but only converts one  */
/* coordinate at a time.                         */
/*                                               */
/* Parameters: An x coordinate in millipoints;   */
/*                                               */
/*             Pointer to an int into which the  */
/*             coordinate, converted to OS       */
/*             units, is placed.                 */
/*                                               */
/* Assumes:    That the pointer is not NULL. The */
/*             input and output variable may be  */
/*             the same (so passing in x, &x     */
/*             would work correctly);            */
/*                                               */
/*             If x and y scalings differ, this  */
/*             will only ever use the x scaling. */
/*************************************************/

void convert_to_os(int x, int * osx)
{
  *osx = ((x + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
}

/*************************************************/
/* convert_to_points()                           */
/*                                               */
/* As convert_pair_to_points, but only converts  */
/* one coordinate at a time.                     */
/*                                               */
/* Parameters: An x coordinate in OS units;      */
/*                                               */
/*             Pointer to an int into which the  */
/*             coordinate, converted to milli-   */
/*             points, is placed.                */
/*                                               */
/* Assumes:    That the pointer is not NULL. The */
/*             input and output variable may be  */
/*             the same (so passing in x, &x     */
/*             would work correctly);            */
/*                                               */
/*             If x and y scalings differ, this  */
/*             will only ever use the x scaling. */
/*************************************************/

void convert_to_points(int x, int * mpx)
{
  #ifdef TRACE

    if (abs(x) > overflow_limit_x)
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_to_points: Can't convert '%d' to millipoints without overflow.",
              x);

      errors_ret(&erb);

      *mpx = 0;

      return;
    }

  #endif

  *mpx = x * millipoints_per_os_unit_x;
}

/*************************************************/
/* convert_box_to_os()                           */
/*                                               */
/* As convert_pair_to_os, but converts the four  */
/* coordinates inside a BBox in one go.          */
/*                                               */
/* Parameters: Pointer to a BBox containing      */
/*             coords in millipoints;            */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             first box's coords, converted to  */
/*             OS units, are placed.             */
/*                                               */
/* Assumes:    That neither pointer is NULL. The */
/*             two pointers may be the same (so  */
/*             passing in &box, &box would work  */
/*             correctly).                       */
/*************************************************/

void convert_box_to_os(const BBox * mp, BBox * os)
{
  os->xmin = ((mp->xmin + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymin = ((mp->ymin + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
  os->xmax = ((mp->xmax + half_mppou_x) / millipoints_per_os_unit_x) & ~(wimpt_dx() - 1);
  os->ymax = ((mp->ymax + half_mppou_y) / millipoints_per_os_unit_y) & ~(wimpt_dy() - 1);
}

/*************************************************/
/* convert_box_to_points()                       */
/*                                               */
/* As convert_pair_to_points, but converts the   */
/* four coordinates inside a BBox in one go.     */
/*                                               */
/* Parameters: Pointer to a BBox containing      */
/*             coords in OS units;               */
/*                                               */
/*             Pointer to a BBox into which the  */
/*             first box's coords, converted to  */
/*             millipoints, are placed.          */
/*                                               */
/* Assumes:    That neither pointer is NULL. The */
/*             two pointers may be the same (so  */
/*             passing in &box, &box would work  */
/*             correctly).                       */
/*************************************************/

void convert_box_to_points(const BBox * os, BBox * mp)
{
  #ifdef TRACE

    if (
         abs(os->xmin) > overflow_limit_x ||
         abs(os->ymin) > overflow_limit_y ||
         abs(os->xmax) > overflow_limit_x ||
         abs(os->ymax) > overflow_limit_y
       )
    {
      erb.errnum = Errors_Custom_Normal;
      sprintf(erb.errmess,
              "convert_box_to_points: Can't convert (%d, %d, %d, %d) to millipoints without overflow.",
              os->xmin,
              os->ymin,
              os->xmax,
              os->ymax);

      errors_ret(&erb);

      mp->xmin = mp->ymin = 0;
      mp->xmax = mp->ymax = 0;

      return;
    }

  #endif

  mp->xmin = os->xmin * millipoints_per_os_unit_x;
  mp->ymin = os->ymin * millipoints_per_os_unit_y;
  mp->xmax = os->xmax * millipoints_per_os_unit_x;
  mp->ymax = os->ymax * millipoints_per_os_unit_y;
}

/**************************************************************/
/* read_sprite_size()                                         */
/*                                                            */
/* Finds out the size of a given sprite in the application's  */
/* sprite pool in OS units.                                   */
/*                                                            */
/* Parameters: Pointer to the sprite name;                    */
/*                                                            */
/*             Pointer to int into which the sprite's width   */
/*             is returned;                                   */
/*                                                            */
/*             Pointer to int into which the sprite's height  */
/*             is returned.                                   */
/*                                                            */
/* Assumes:    The name pointer is not NULL, but either of    */
/*             the two int pointers may be.                   */
/**************************************************************/

_kernel_oserror * read_sprite_size(char * name, int * width, int * height)
{
  unsigned int      w, h, m;
  _kernel_oserror * e;

  e = _swix(OS_SpriteOp,
            _INR(0,2) | _OUTR(3,4) | _OUT(6),

            0x128,
            sprite_block,
            name,

            &w,
            &h,
            &m);

  if (e) return e;

  w = w << bbc_modevar(m, BBC_XEigFactor);
  h = h << bbc_modevar(m, BBC_YEigFactor);

  if (width)  *width  = (int) w;
  if (height) *height = (int) h;

  return NULL;
}

/**************************************************************/
/* utils_text_width()                                         */
/*                                                            */
/* Returns the width of a given piece of text, in OS units,   */
/* if it were to be plotted in the Desktop. Wimp_TextOp is    */
/* used if available, else the width and spacing of the       */
/* bitmap font is read and the width is calculated from this  */
/* instead.                                                   */
/*                                                            */
/* Parameters: Pointer to the text;                           */
/*                                                            */
/*             Pointer to an int, into which the width is     */
/*             written;                                       */
/*                                                            */
/*             0 to work out the whole string width, or the   */
/*             number of chars to read.                       */
/*                                                            */
/* Assumes:    Either pointer may be NULL;                    */
/*                                                            */
/*             If the number of chars to read is greater than */
/*             the string length, the value given is ignored  */
/*             and the string length used instead.            */
/**************************************************************/

_kernel_oserror * utils_text_width(char * text, int * width, int scan)
{
  int cwidth, cspacing;
  int len;

  /* Return if there's no text or 'width' is NULL */

  if (!width) return NULL;

  if (!text || !*text)
  {
    *width = 0;
    return NULL;
  }

  /* Otherwise, set 'len' either to the string length, */
  /* if 'scan' is zero, or to the value of 'scan'.     */

  len = strlen(text);
  if (scan && scan < len) len = scan;

  /* Rather than try mucking about guessing what version number of */
  /* Wimp supports Wimp_TextOp, simply use the alternative method  */
  /* if the SWI raises an error.                                   */

  if (
       _swix(Wimp_TextOp,
             _INR(0,2) | _OUT(0),

             1,
             text,
             len,

             width)
     )
  {
    /* Find out the spacing (start of one char to start of next) */
    /* and width of the text the Wimp is using, assuming that if */
    /* there is no nested wimp, Wimp_TextOp is unavailable.      */

    int vars[3] = {
                    BBC_GCharSizeX,
                    BBC_GCharSpaceX,
                    -1
                  };

    RetError(bbc_vduvars(vars, vars));

    cwidth   = vars[0];
    cspacing = vars[1];

    /* cspacing gives how much to increment x by after plotting a   */
    /* character, and therefore includes cwidth; so to find the     */
    /* width, we'd use (len * cspacing) - (cspacing - cwidth),      */
    /* which simplifies to the below (plus conversion to OS units). */

    *width = ((len - 1) * cspacing + cwidth) * wimpt_dx();
  }

  /* Finished */

  return NULL;
}

/**************************************************************/
/* set_window_flags()                                         */
/*                                                            */
/* Sets the flags of a given window, assuming the nested Wimp */
/* is available... The flags are set according to:            */
/*                                                            */
/*   new = (old BIC clear word) EOR EOR word                  */
/*                                                            */
/* i.e.:                                                      */
/*                                                            */
/*   C  E  Effect                                             */
/*   ------------                                             */
/*   0  0  Preserve bit                                       */
/*   0  1  Toggle bit                                         */
/*   1  0  Clear bit                                          */
/*   1  1  Set bit                                            */
/*                                                            */
/* Parameters: Window handle; EOR word; Clear word.           */
/*                                                            */
/* Assumes:    That a window manager that supports extended   */
/*             Wimp_OpenWindow calls (R2 = 'TASK') is         */
/*             present.                                       */
/**************************************************************/

_kernel_oserror * set_window_flags(int window_handle, unsigned int clear_word, unsigned int eor_word)
{
  /* Block required for the extended Wimp_OpenWindow */

  typedef struct
  {
    WimpOpenWindowBlock open;
    unsigned int        flags;
  }
  ExtendedOpenBlock;

  _kernel_oserror         * e;
  WimpGetWindowStateBlock   s;
  unsigned int              parent, align;
  unsigned int              new_flags;
  ExtendedOpenBlock         ext_o;

  /* Get the current window details */

  s.window_handle = window_handle;

  e = _swix(Wimp_GetWindowState,
            _INR(1, 2) | _OUTR(3, 4),

            &s,
            Magic_Word_TASK, /* See MiscDefs.h */

            &parent,
            &align);

  if (e) return e;

  /* Obtain the new flags word */

  new_flags = (s.flags & ~clear_word) ^ eor_word;

  /* Fill in the new open block and reopen the window with it */

  ext_o.open.window_handle = s.window_handle;
  ext_o.open.visible_area  = s.visible_area;
  ext_o.open.xscroll       = s.xscroll;
  ext_o.open.yscroll       = s.yscroll;
  ext_o.open.behind        = s.behind;
  ext_o.flags              = new_flags;

  return _swix(Wimp_OpenWindow,
               _INR(1,4),

               &ext_o,
               Magic_Word_TASK,
               parent,
               align | Alignment_NewFlagsGiven);
}

/**************************************************************/
/* set_gadget_state()                                         */
/*                                                            */
/* Greys or ungreys a gadget, only changing its state to      */
/* avoid flicker.                                             */
/*                                                            */
/* Parameters: Object ID the gadget resides in;               */
/*                                                            */
/*             Component ID of the gadget;                    */
/*                                                            */
/*             1 to grey, 0 to ungrey.                        */
/**************************************************************/

_kernel_oserror * set_gadget_state(ObjectId o, ComponentId c, int grey_state)
{
  _kernel_oserror * e;
  unsigned int      flags;

  e = gadget_get_flags(0, o, c, &flags);
  if (e) return e;

  /* Only change state, to avoid flicker. */

  if (!!grey_state != !!(flags & Gadget_Faded))
  {
    if (grey_state) flags |=  Gadget_Faded;
    else            flags &= ~Gadget_Faded;

    return gadget_set_flags(0, o, c, flags);
  }

  return NULL;
}

/**************************************************************/
/* adjust()                                                   */
/*                                                            */
/* Returns 1 if Wimp_GetPointerInfo says that Adjust is being */
/* pressed, else 0.                                           */
/**************************************************************/

int adjust(void)
{
  WimpGetPointerInfoBlock info;

  wimp_get_pointer_info(&info);

  return !!(info.button_state & Wimp_MouseButtonAdjust);
}

/**************************************************************/
/* debounce_keypress()                                        */
/*                                                            */
/* For some key presses (e.g. function keys), it is not       */
/* desirable to let the key autorepeat. This function sits in */
/* a tight loop waiting for all keys to be released before    */
/* exitting.                                                  */
/*                                                            */
/* Returns: 1 if a key was being pressed and the function     */
/* waited for its release, else 0.                            */
/**************************************************************/

int debounce_keypress(void)
{
  int               key, waited = 0;
  _kernel_oserror * e;

  do
  {
    e = _swix(OS_Byte,
              _INR(0,1) | _OUT(1),

              121, /* Keyboard scan */
              0,   /* Scan all keys */

              &key);

    if (key != 255) waited = 1;
  }
  while (!e && key != 255);

  if (waited) _swix(OS_Byte, _INR(0,1), 21, 0); /* Flush keyboard buffer */

  return waited;
}

/**************************************************************/
/* task_from_window()                                         */
/*                                                            */
/* Returns the task handle of the owner of a given window.    */
/*                                                            */
/* Parameters: A window handle.                               */
/*                                                            */
/* Returns:    Task handle of the window owner.               */
/**************************************************************/

int task_from_window (int window_handle)
{
  WimpMessage  m;
  int          handle;

  m.hdr.size        = 20;
  m.hdr.your_ref    = 0;
  m.hdr.action_code = 0;

  if (
       wimp_send_message(Wimp_EUserMessageAcknowledge,
                         &m,
                         window_handle,
                         0,
                         &handle)
     )
     return 0;

  return handle;
}

/**************************************************************/
/* utils_strcasecmp()                                         */
/*                                                            */
/* Function to compare two strings case insensitively.        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strcmp.                                     */
/*                                                            */
/* Returns:    As strcmp.                                     */
/**************************************************************/

int utils_strcasecmp(const char *a, const char *b)
{
  for (;;)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }
}

/**************************************************************/
/* utils_strncasecmp()                                        */
/*                                                            */
/* Function to compare two strings case insensitively up to a */
/* maximum char count.                                        */
/*                                                            */
/* Originally by S.Brodie.                                    */
/*                                                            */
/* The conversions to unsigned int stop the compiler messing  */
/* around with shifts all over the place whilst trying to     */
/* promote the chars to int whilst retaining the sign.        */
/*                                                            */
/* Problems: Choice of return value when strings do not match */
/* is based upon character number rather than any alphabetic  */
/* sorting.                                                   */
/*                                                            */
/* Parameters: As strncmp.                                    */
/*                                                            */
/* Returns:    As strncmp.                                    */
/**************************************************************/

int utils_strncasecmp(const char * a, const char * b, unsigned int n)
{
  for (; n; --n)
  {
    unsigned int f1 = *a++;
    unsigned int s1 = *b++;

    if (f1 == 0) return -s1;

    if (f1 != s1)
    {
      unsigned int f2     = (unsigned int) tolower(f1);
      unsigned int s2     = (unsigned int) tolower(s1);
      signed int   result = f2 - s2;

      if (result != 0) return result;
    }
  }

  return 0;
}

/**************************************************************/
/* utils_strcasestr()                                         */
/*                                                            */
/* Same as standard C library 'strstr', but works case        */
/* insensitively.                                             */
/*                                                            */
/* Parameters: As strstr.                                     */
/*                                                            */
/* Returns:    As strstr.                                     */
/**************************************************************/

char * utils_strcasestr(const char * a, const char * b)
{
  int i;

  for (;;)
  {
    for (i=0;; i++)
    {
      char ch = tolower(b[i]);

      if (ch == 0) return (char *) a;
      if (tolower(a[i]) != ch) break;
    }

    if (*a++ == 0) return 0;
  }
}

/**************************************************************/
/* utils_strdup()                                             */
/*                                                            */
/* Returns a pointer to a malloc'd copy of the given string.  */
/*                                                            */
/* Parameters: Pointer to the string to copy.                 */
/*                                                            */
/* Returns:    Pointer to a malloc'd copy of the given        */
/*             string.                                        */
/*                                                            */
/* Assumes:    Returns NULL if it gets NULL or if memory      */
/*             allocation fails.                              */
/**************************************************************/

char * utils_strdup(const char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) malloc(strlen(s1) + 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/**************************************************************/
/* utils_strndup()                                            */
/*                                                            */
/* Returns a pointer to a malloc'd copy of the given string,  */
/* copying only as many characters as asked for. The result   */
/* is zero terminated.                                        */
/*                                                            */
/* Parameters: Pointer to the string to copy;                 */
/*                                                            */
/*             Maximum number of characters to copy.          */
/*                                                            */
/* Returns:    Pointer to a malloc'd copy of the given        */
/*             string (always zero terminated).               */
/*                                                            */
/* Assumes:    Returns NULL if it gets NULL or if memory      */
/*             allocation fails. The length of the source     */
/*             string must be greater than or equal to the    */
/*             number of characters to copy.                  */
/**************************************************************/

char * utils_strndup(const char * s1, size_t size)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = malloc(size + 1); /* +1 so we can force a zero terminator */
  if (s2 == NULL) return NULL;

  s2[size] = '\0';
  return memcpy(s2,s1,size);
}

/**************************************************************/
/* utils_get_task_handle()                                    */
/*                                                            */
/* Returns the task handle of the given task (name comparison */
/* is case insensitive).                                      */
/*                                                            */
/* Parameters: Pointer to a null-terminated task name;        */
/*                                                            */
/*             Pointer to an unsigned int, in which the task  */
/*             handle is written, or 0 if the task is not     */
/*             found.                                         */
/*                                                            */
/* Assumes:    Neither pointer may be NULL.                   */
/**************************************************************/

_kernel_oserror * utils_get_task_handle(const char * task_to_get, unsigned int * found_handle)
{
  _kernel_oserror * e;
  char            * c;
  int             * p;
  int               buffer  [32];
  char              taskname[Limits_TaskName];
  int             * notused;
  int               t;
  int               len    = strlen(task_to_get);
  int               next   = 0;
  unsigned int      handle = 0;

  do
  {
    e = _swix(TaskManager_EnumerateTasks,
              _INR(0,2) | _OUTR(0,1),

              next,
              buffer,
              sizeof(buffer),

              &next,
              &notused);

    if (e) return e;

    /* Go through as much of the buffer as the call said it used */

    for (p = buffer; p < notused && handle == 0; p += 4)
    {
      c = (char *) p[1];
      t = 0;

      memset(taskname, 0, sizeof(taskname));
      while (*c > 31 && t < sizeof(taskname) - 1) taskname[t++] = *c++;

      if (!utils_strncasecmp(taskname, task_to_get, len)) handle = p[0];
    }
  }
  while (next >= 0 && handle == 0);

  /* Return the handle */

  *found_handle = handle;

  return NULL;
}

/**************************************************************/
/* utils_check_scrap()                                        */
/*                                                            */
/* If Save_ScrapFile (which should represent a system         */
/* variable name, see Save.h) does not exist, report an       */
/* appropriate error and return 1. Else return 0.             */
/*                                                            */
/* Returns: See above.                                        */
/**************************************************************/

int utils_check_scrap(void)
{
  int              len;
  _kernel_swi_regs r;

  r.r[0] = (int) Save_ScrapVar;
  r.r[1] = (int) NULL;
  r.r[2] = -1;
  r.r[3] = 0;
  r.r[4] = 4;

  /* _swix will not work correctly for this particular SWI if */
  /* requiring the returned R2 value. Something to do with    */
  /* the call relying on generating an error, but _swix spots */
  /* it and pulls out earlier than the call expects. Or some  */
  /* such thing...                                            */

  _kernel_swi(OS_ReadVarVal, &r, &r);

  len = r.r[2];

  if (!len)
  {
    erb.errnum = Errors_Custom_Message;
    sprintf(erb.errmess,
            "%s%s",
            Save_ScrapFile,
            lookup_token("NoScrapDef: not defined.",0));

    errors_ret(&erb);

    return 1;
  }

  return 0;
}

/**************************************************************/
/* utils_canonicalise_path()                                  */
/*                                                            */
/* Take some pathname (which may include a path or other      */
/* general system variable) and expand (or canonicalise) it.  */
/*                                                            */
/* Caller is responsible for calling free() on the returned   */
/* block.                                                     */
/*                                                            */
/* Parameters: Pointer to the path to canonicalise;           */
/*                                                            */
/*             Pointer to a char *, which will be filled in   */
/*             with the address of a malloced block - the     */
/*             caller is responsible for freeing it.          */
/*                                                            */
/* Returns:    If there is an error, it returns it, but it    */
/*             may return NULL and also return NULL as the    */
/*             pointer to the malloced block if some other    */
/*             internal failure occurred.                     */
/**************************************************************/

_kernel_oserror * utils_canonicalise_path(const char * in, char ** out)
{
  int required;

  if (!in || !*in || !out) return NULL;

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 NULL, NULL,
                 NULL, 0,

                 &required)); /* Path length not including terminator returned as MINUS r5 */

  *out = malloc(1 - required); /* (Yes, '1 - required' - see above!) */

  if (!*out) return errors_frontend_error(fee_out_of_memory, 1, "utils_canonicalise_path");

  RetError(_swix(OS_FSControl,
                 _INR(0, 5) | _OUT(5),

                 37,   in,
                 *out, NULL,
                 NULL, 1 - required,

                 &required));

  /* Er, 'something' went wrong... PRMs say to check, but not what to */
  /* do if you don't get 1 back here and haven't had an error from    */
  /* the SWI call!                                                    */

  if (required != 1)
  {
    free (*out);
    *out = NULL;
  }

  return NULL;
}

/**************************************************************/
/* utils_build_tree()                                         */
/*                                                            */
/* Takes a fully canonicalised pathname and ensures that all  */
/* the directories in the path exist. This is useful if you   */
/* are going to save something to a temporary directory in    */
/* Scrap or somewhere in <Choices$Write>, say, and need to    */
/* ensure that the directory structure you're addressing is   */
/* present.                                                   */
/*                                                            */
/* Parameters: Pointer to the path to ensure is present.      */
/**************************************************************/

_kernel_oserror * utils_build_tree(const char * path)
{
  char * temp;
  char * p;
  int    level, len;

  /* Sanity check, and take a local copy of the path */

  if (!path || !*path) return NULL;

  len = strlen(path);

  temp = malloc(len + 1);
  if (!temp) return errors_frontend_error(fee_out_of_memory, 1, "utils_build_tree");

retry:

  level = 0;
  strcpy(temp, path);

  /* Create the directories */

  do
  {
    p = strrchr(temp, '.');

    if (p)
    {
      *p = '\0';

      if (!_swix(OS_File,
                 _INR(0,1) | _IN(4),

                 8,
                 temp,
                 0))
      {
        if (level) goto retry;
        else       break;
      }
    }

    level++;
  }
  while (p);

  /* Finished */

  free(temp);

  return NULL;
}
