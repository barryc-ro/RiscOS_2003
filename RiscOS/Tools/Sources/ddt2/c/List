/**************************************************************/
/* File:    List.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle dialogue boxes showing a list of items     */
/*          (e.g. for breakpoints). Does some handling for    */
/*          the List add dialogue box and List menu.          */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 19-Mar-1999 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/*          25-Oct-2000 (ADH): Adapted for DDT2.              */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/menu.h>
#include <tboxlibs/ScrollList.h>

#include "Errors.h"
#include "Limit.h"
#include "ListAdd.h"
#include "ListMenu.h"
#include "Global.h"
#include "NewProject.h"
#include "TGUtils.h"
#include "Utils.h"

#include "List.h"

/* Locally managed array of known list types; list_known is defined */
/* in List.h and specialised routines needing to gain access to the */
/* array contents can do so with list_get_known_items.              */

static list_known   known[] = {
                                { NewProject_CID_ObjectFiles, "ListNewObj:Objects",             "ListAdd",    true,  ListAdd_EHidden, NewProject_EHidden, NULL, newproject_fill_list_with_objects,     newproject_read_list_of_objects     },
                                { NewProject_CID_Breakpoints, "ListNewBrk:Initial breakpoints", "Breakpoint", false, 0,               NewProject_EHidden, NULL, newproject_fill_list_with_breakpoints, newproject_read_list_of_breakpoints },
                                { NewProject_CID_Watchpoints, "ListNewWtc:Initial watchpoints", "Watchpoint", false, 0,               NewProject_EHidden, NULL, newproject_fill_list_with_watchpoints, newproject_read_list_of_watchpoints }
                              };

/* The idblocks array is used to store the ToBeShown event IdBlock  */
/* contents for other event handlers to later refer to. This means  */
/* we're restricted to having only one List window open for any one */
/* known source - multiple "views" are not supported.               */

typedef struct list_known_private
{
  unsigned int handle; /* A record of the handle for the read/fill functions above */
  IdBlock      idb;    /* ID block from the ToBeShown event                        */
  ObjectId     child;  /* Child's (e.g. Add dialogue box) object ID                */

} list_known_private;

static bool               initialised   = false;
static unsigned int       known_entries = sizeof(known) / sizeof(*known);
static list_known_private idblocks       [sizeof(known) / sizeof(*known)];

/* Local functions */

static int               list_hidden                   (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_parent_hidden            (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_child_hidden             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static int               list_ok                       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * list_closing                  (int index);

static int               list_select_all_handler       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_clear_selection_handler  (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_add_item_handler         (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_remove_item_handler      (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_scrolllist_event_handler (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * list_fill_from_array_index    (int index);
static _kernel_oserror * list_open_add_dialogue_box    (int index, list_add_for * attached);

/**************************************************************/
/* list_get_known_items()                                     */
/*                                                            */
/* Get a pointer to the array created above that holds the    */
/* types of lists we know about.                              */
/*                                                            */
/* This should really only be of use to very specialised      */
/* functions...                                               */
/*                                                            */
/* Parameters: Pointer to an int which is filled in with      */
/*             the number of entries in the array.            */
/*                                                            */
/* Returns:    Pointer to the list_known array.               */
/*                                                            */
/* Assumes:    The int pointer is mandatory; it may not be    */
/*             NULL.                                          */
/**************************************************************/

const list_known * list_get_known_items(int * entries)
{
  dprintf(("LiDi", "list_get_known_items: Called with &%08X\n", (unsigned int) entries));

  *entries = known_entries;

  dprintf(("LiDi", "list_get_known_items: Successful, returning &%08X\n", (unsigned int) known));

  return known;
}

/**************************************************************/
/* list_to_be_shown()                                         */
/*                                                            */
/* Called before the List dialogue box is displayed.          */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int list_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int          index = 0;
  const char * tkn   = NULL;

  dprintf(("LiDi", "list_to_be_shown: Called, self_id = &%08X\n", (unsigned int) idb->self_id));

  /* Have we been run at least once? */

  if (initialised == false)
  {
    unsigned int i;

    dprintf(("LiDi", "list_to_be_shown: First call; initialising\n"));

    for (i = 0; i < known_entries; i++)
    {
      idblocks[i].handle      = 0;
      idblocks[i].child       = NULL_ObjectId;
      idblocks[i].idb.self_id = NULL_ObjectId;
    }

    initialised = true;
  }

  /* Find out which list, if any, this is for */

  dprintf(("LiDi", "list_to_be_shown: Checking which list this is for\n"));

  while (index < known_entries)
  {
    if (idb->parent_component == known[index].reference)
    {
      tkn = known[index].messages_token;
      break;
    }
    else index++;
  }

  if (tkn == NULL)
  {
    dprintf(("LiDi", "list_to_be_shown: Don't recognise the parent component &%08X\n", idb->parent_component));

    /* Don't recognise the parent component ID */

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_to_be_shown"));

    return 0;
  }

  dprintf(("LiDi", "list_to_be_shown: Open for index %d\n", index));

  /* Do we appear to be open already though? */

  if (idblocks[index].idb.self_id != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_to_be_shown: This item is already open\n"));

    return 0;
  }

  /* Store the ID block contents for future reference */

  idblocks[index].idb   = *idb;
  idblocks[index].child = NULL_ObjectId;

  ChkError(list_fill_from_array_index(index));
  ChkError(window_set_title(0, idb->self_id, lookup_token(tkn, 0)));

  /* Grey out Remove for now, as there's nothing selected to start with */

  ChkError(set_gadget_state(idb->self_id, List_CID_Remove, 1));

  /* Ungrey "Add" in case it's still greyed from earlier */

  ChkError(set_gadget_state(idb->self_id, List_CID_Add, 0));

  /* Event handlers - first, for menu items / key shortcuts. */
  /* Need to keep this list in sync with deregistration code */
  /* in list_cancel.                                         */

  ChkError(event_register_toolbox_handler(-1,
                                          List_ESelectAll,
                                          list_select_all_handler,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(-1,
                                          List_EClearSelection,
                                          list_clear_selection_handler,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(-1,
                                          List_EAdd,
                                          list_add_item_handler,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(-1,
                                          List_ERemove,
                                          list_remove_item_handler,
                                          (void *) index));

  /* Now for this-object-specific items... */

  /* Must also be deregistered individually in the close handler. */
  /* You can't deregister all handlers for the object as child    */
  /* dialogue boxes may have handlers registered for us, which    */
  /* could get trashed depending on the event handling order.     */

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          List_EClose,
                                          list_ok,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          List_EHidden,
                                          list_hidden,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          ScrollList_Selection,
                                          list_scrolllist_event_handler,
                                          (void *) index));

  /* An unusual one - we need to hide *ourselves* if the parent window */
  /* that opened us disappears. Don't forget to deregister it later!   */

  dprintf(("LiDi", "list_to_be_shown: Registering handler on parent\n"));

  ChkError(event_register_toolbox_handler(idb->parent_id,
                                          known[index].parent_hide_event,
                                          list_parent_hidden,
                                          (void *) index));

  /* Finally, if we've got a function to get a handle for this item, call it */

  if (known[index].get_handle != NULL)
  {
    dprintf(("LiDi", "list_to_be_shown: Calling get_handle function\n"));

    ChkError((known[index].get_handle)(idb->self_id, &idblocks[index].handle));
  }

  dprintf(("LiDi", "list_to_be_shown: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_hidden()                                              */
/*                                                            */
/* Called when the List dialogue box is hidden.               */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_hidden: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_hidden"));
  }

  /* Clear the "don't re-open" semaphore */

  idblocks[index].idb.self_id = NULL_ObjectId;

  /* Deregister all event handlers registered in the */
  /* List_EToBeShown event handler.                  */

  ChkError(event_deregister_toolbox_handler(-1,
                                            List_ESelectAll,
                                            list_select_all_handler,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(-1,
                                            List_ESelectAll,
                                            list_select_all_handler,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(-1,
                                            List_EClearSelection,
                                            list_clear_selection_handler,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(-1,
                                            List_EAdd,
                                            list_add_item_handler,
                                            (void *) index));

  /* Object-specific handlers */

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            List_EClose,
                                            list_ok,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            List_EHidden,
                                            list_hidden,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            ScrollList_Selection,
                                            list_scrolllist_event_handler,
                                            (void *) index));

  /* Handler watching for a closing parent */

  if (idblocks[index].idb.parent_id != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_hidden: Deregistering handler on parent\n"));

    ChkError(event_deregister_toolbox_handler(idblocks[index].idb.parent_id,
                                              known[index].parent_hide_event,
                                              list_parent_hidden,
                                              NULL));
  }

  dprintf(("LiDi", "list_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_parent_hidden()                                       */
/*                                                            */
/* Eeek, the parent window is closing - time for bed...       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_parent_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_parent_hidden: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_parent_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_parent_hidden"));
  }

  ChkError(toolbox_hide_object(0, idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_parent_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_child_hidden()                                        */
/*                                                            */
/* Called on the child_hide_event for the Add dialogue box.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_child_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_child_hidden: Called for index %d\n", index));

  /* Don't check idb.self_id - the List dialogue's Hidden handler */
  /* may get called first and will have cleared the field         */

  if (
       index                 <  0             ||
       index                 >= known_entries ||
       idblocks[index].child == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_child_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_child_hidden"));
  }

  /* Clear our record of the child */

  idblocks[index].child = NULL_ObjectId;

  /* Ungrey "Add" */

  if (idblocks[index].idb.self_id != NULL_ObjectId)
  {
    ChkError(set_gadget_state(idblocks[index].idb.self_id,
                              List_CID_Add,
                              0));
  }

  /* Ensure the menu is up to date (we may want to ensure 'New' is ungreyed) */

  ChkError(list_setup_menu(idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_child_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_ok()                                                  */
/*                                                            */
/* Called when OK is activated for the List dialogue box.     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_ok(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_ok: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_ok: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_ok"));
  }

  /* If there's a handler, tell it to read the entries now */

  if (known[index].read_list != NULL)
  {
    dprintf(("LiDi", "list_ok: Calling read_list function\n"));

    ChkError((known[index].read_list)(idb->self_id, idblocks[index].handle));
  }

  idblocks[index].handle = 0;

  ChkError(list_closing(index));

  dprintf(("LiDi", "list_ok: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_closing()                                             */
/*                                                            */
/* If the List dialogue box may be closing, call this to do   */
/* various tidy-up actions which are the same for any source  */
/* of closure (e.g. "OK" and "Cancel").                       */
/*                                                            */
/* Parameters: Index into the 'known' and 'idblocks' arrays   */
/*             for this item.                                 */
/**************************************************************/

static _kernel_oserror * list_closing(int index)
{
  dprintf(("LiDi", "list_closing: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_closing: Invalid index\n"));

    RetError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_closing"));
  }

  /* Should we close the window? (Keyboard shortcut or SELECT pressed) */

  if (idblocks[index].idb.self_component == NULL_ComponentId || !adjust())
  {
    dprintf(("LiDi", "list_closing: Dialogue box should be closed\n"));

    /* Hide the object (don't delete - it was auto-created). The Hidden */
    /* handler does the rest.                                           */

    RetError(toolbox_hide_object(0, idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_closing: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_select_all_handler()                                  */
/*                                                            */
/* Handle an List_ESelectAll event from a menu item with a    */
/* List dialogue as its parent or a key shortcut invoked from */
/* a List dialogue.                                           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_select_all_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_select_all_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_select_all_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_select_all_handler"));
  }

  if (list_count_items(idblocks[index].idb.self_id) > 0)
  {
    ChkError(list_select_all(idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_select_all_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_clear_selection_handler()                             */
/*                                                            */
/* Handle an List_EClearSelection event from a menu item with */
/* a List dialogue as its parent or a key shortcut invoked    */
/* from a List dialogue.                                      */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_clear_selection_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_clear_selection_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_clear_selection_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_clear_selection"));
  }

  if (list_count_items(idblocks[index].idb.self_id) > 0)
  {
    ChkError(list_clear_selection(idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_clear_selection_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_add_item_handler()                                    */
/*                                                            */
/* Handle an List_EAdd event from a menu item with a List     */
/* dialogue as its parent or a key shortcut invoked from a    */
/* List dialogue.                                             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_add_item_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int            index = (int) handle;
  list_add_for * item;

  dprintf(("LiDi", "list_add_item_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_add_item_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_add_item_handler"));
  }

  /* Is there a dialogue box open already? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_add_item_handler: Child already open\n"));
    return 0;
  }

  /* Create the new item */

  item = (list_add_for *) malloc(sizeof(list_add_for));

  if (!item)
  {
    dprintf(("LiDi", "list_add_item_handler: Not enough memory\n"));

    ChkError(errors_frontend_error(fee_out_of_memory,
                                   1,
                                   "list_add_item_handler"));
  }
  else item->list_item = -1;

  /* Fill it in */

  item->parent            = idblocks[index].idb.self_id;
  item->open_for          = List_CID_ScrollList;
  item->restore_focus     = 1;
  item->parent_hide_event = List_EHidden;
  *item->initial_text     = '\0';

  /* Create and open the dialogue box */

  dprintf(("LiDi", "list_add_item_handler: Opening Add dialogue box\n"));

  ChkError(list_open_add_dialogue_box(index, item));

  dprintf(("LiDi", "list_add_item_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_remove_item_handler()                                 */
/*                                                            */
/* Handle an List_ERemove event from a menu item with a List  */
/* dialogue as its parent or a key shortcut invoked from a    */
/* List dialogue.                                             */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_remove_item_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_remove_item_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_remove_item_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_remove_item_handler"));
  }

  ChkError(list_remove_selected(idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_remove_item_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_scrolllist_event_handler()                            */
/*                                                            */
/* Handles events for the ScrollList gadget in a List         */
/* dialogue box. Specifically, checks for items being         */
/* selected / deselected and updates various UI components as */
/* required.                                                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_scrolllist_event_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ScrollListSelectionEvent * sel   = (ScrollListSelectionEvent *) event;
  int                        index = (int) handle;

  dprintf(("LiDi", "list_scrolllist_event_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_scrolllist_event_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_scrolllist_event_handler"));
  }

  /* Is there a dialogue box open already? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_scrolllist_event_handler: Child open - closing it\n"));

    ChkError(toolbox_hide_object(0, idblocks[index].child));
  }

  /* Grey/ungrey the "Remove" button and make sure the menu is up to date */

  if (list_count_selected(idb->self_id) > 0) set_gadget_state(idb->self_id, List_CID_Remove, 0);
  else                                       set_gadget_state(idb->self_id, List_CID_Remove, 1);

  ChkError(list_setup_menu(idb->self_id));

  /* If this was a double-click, need to open a List add dialogue */
  /* box (or equivalent) for that entry. So, a list_add_for       */
  /* structure needs building.                                    */

  if (sel->flags & ScrollList_Selection_Flags_DoubleClick)
  {
    list_add_for * item = (list_add_for *) malloc(sizeof(list_add_for));

    if (!item)
    {
      ChkError(errors_frontend_error(fee_out_of_memory,
                                     1,
                                     "list_scrolllist_event_handler"));
    }
    else item->list_item = sel->item;

    item->parent            = idb->self_id;
    item->open_for          = List_CID_ScrollList;
    item->restore_focus     = 1;
    item->parent_hide_event = List_EHidden;

    ChkError(scrolllist_get_item_text(0,
                                      idb->self_id,
                                      idb->self_component,
                                      item->initial_text,
                                      sizeof(item->initial_text),
                                      sel->item,
                                      NULL));

    ChkError(list_open_add_dialogue_box((int) handle, item));
  }

  dprintf(("LiDi", "list_scrolllist_event_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_fill_from_array_index()                               */
/*                                                            */
/* Given an index into the 'known' array of list_known        */
/* structures (see top of this file), write the relevant      */
/* items into a List dialogue via.                            */
/* list_fill_from_comma_separated_string.                     */
/*                                                            */
/* Parameters: Index into array (this is limit checked so     */
/*             invalid values can be passed safely - the      */
/*             function just exits if the value is invalid).  */
/**************************************************************/

static _kernel_oserror * list_fill_from_array_index(int index)
{
  unsigned int flags;
  ObjectId     self = idblocks[index].idb.self_id;

  dprintf(("LiDi", "list_fill_from_array_index: Called for index %d\n", index));

  /* Set the gadget to allow multiple selections */

  RetError(scrolllist_get_state(0, self, List_CID_ScrollList, &flags));
  RetError(scrolllist_set_state(0, self, List_CID_ScrollList, flags | ScrollList_MultipleSelections));

  /* Call the fill handler function, if present */

  if (index >= 0 && index < known_entries)
  {
    if (known[index].fill_list != NULL)
    {
      dprintf(("LiDi", "list_fill_from_array_index: Successful, exitting through fill_list function\n"));

      return (known[index].fill_list)(self, idblocks[index].handle);
    }

  }
  else
  {
    dprintf(("LiDi", "list_fill_from_array_index: Invalid index\n"));

    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "list_fill_from_array_index");
  }

  dprintf(("LiDi", "list_fill_from_array_index: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_open_add_dialogue_box()                               */
/*                                                            */
/* Direct callable function and service function for          */
/* list_add_item_handler. Creates and opens an appropriate    */
/* dialogue box to add an item to a list. The item's Hidden   */
/* handler is expected to delete it and free the              */
/* list_add_for structure.                                    */
/*                                                            */
/* Must not be called if the item is already being shown.     */
/*                                                            */
/* Parameters: Index into the 'known' and 'idblocks' array    */
/*             for the List dialogue box;                     */
/*                                                            */
/*             Pointer to an initialised list_add_for         */
/*             structure to attach to the new object.         */
/**************************************************************/

static _kernel_oserror * list_open_add_dialogue_box(int index, list_add_for * attached)
{
  dprintf(("LiDi", "list_open_add_dialogue_box: Called for index %d, attached &%08X\n", index, (unsigned int) attached));

  /* Is there already a child open? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_open_add_dialogue_box"));
  }

  /* Create a new dialogue box. */

  RetError(toolbox_create_object(0,
                                 (char *) known[index].add_name,
                                 &idblocks[index].child));

  /* Set the list_add_for pointer as a client handle */

  RetError(toolbox_set_client_handle(0, idblocks[index].child, (void *) attached));

  /* Register a handler for when the child is hidden */

  ChkError(event_register_toolbox_handler(idblocks[index].child,
                                          known[index].child_hide_event,
                                          list_child_hidden,
                                          (void *) index));

  /* Grey out the "Add" button */

  ChkError(set_gadget_state(idblocks[index].idb.self_id,
                            List_CID_Add,
                            1));

  /* Ensure the menu is up to date (we may want to ensure 'New' is greyed out) */

  ChkError(list_setup_menu(idblocks[index].idb.self_id));

  /* Show the new dialogue box - its ToBeShown handler does the rest. */

  dprintf(("LiDi", "list_open_add_dialogue_box: Successful, exitting through toolbox_show_object\n"));

  return toolbox_show_object(0,
                             idblocks[index].child,
                             Toolbox_ShowObject_Centre,
                             NULL,
                             idblocks[index].idb.self_id,
                             List_CID_ScrollList);
}

/**************************************************************/
/* list_count_items()                                         */
/*                                                            */
/* Returns the number of items present in the scrolling list  */
/* of the given List dialogue.                                */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/*                                                            */
/* Returns:    Number of items in the scrolling list. Returns */
/*             0 if there's an error as well as if there are  */
/*             no items in the list.                          */
/**************************************************************/

int list_count_items(ObjectId self)
{
  dprintf(("LiDi", "list_count_items: Called, successful, exitting through tgutils_count_items\n"));

  return tgutils_count_items(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_count_selected()                                      */
/*                                                            */
/* Returns the number of items selected in the scrolling list */
/* of the given List dialogue.                                */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/*                                                            */
/* Returns:    Number of items selected in the list. Returns  */
/*             0 if there's an error as well as if there are  */
/*             no items in the list.                          */
/**************************************************************/

int list_count_selected(ObjectId self)
{
  dprintf(("LiDi", "list_count_selected: Called\n"));

  dprintf(("LiDi", "list_count_selected: Successful, exitting through tgutils_count_selected\n"));

  return tgutils_count_selected(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_select_all()                                          */
/*                                                            */
/* Select all items in the ScrollList component of the given  */
/* List dialogue box.                                         */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/**************************************************************/

_kernel_oserror * list_select_all(ObjectId self)
{
  dprintf(("LiDi", "list_select_all: Called\n"));

  dprintf(("LiDi", "list_select_all: Successful, exitting through tgutils_select_all\n"));

  return tgutils_select_all(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_clear_selection()                                     */
/*                                                            */
/* Deselect all items in the ScrollList component of the      */
/* given List dialogue box.                                   */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/**************************************************************/

_kernel_oserror * list_clear_selection(ObjectId self)
{
  dprintf(("LiDi", "list_clear_selection: Called\n"));

  dprintf(("LiDi", "list_clear_selection: Successful, exitting through tgutils_clear_selection\n"));

  return tgutils_clear_selection(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_remove_selected()                                     */
/*                                                            */
/* Remove all selected items in the ScrollList component of   */
/* the given List dialogue box.                               */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/**************************************************************/

_kernel_oserror * list_remove_selected(ObjectId self)
{
  dprintf(("LiDi", "list_remove_selected: Called\n"));

  dprintf(("LiDi", "list_remove_selected: Successful, exitting through tgutils_remove_selected\n"));

  return tgutils_remove_selected(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_setup_menu()                                          */
/*                                                            */
/* Ensure the relevant items are greyed or ungreyed in the    */
/* menu attached to the List dialogue box (if any).           */
/*                                                            */
/* Parameters: Object ID of the List dialogue.                */
/**************************************************************/

_kernel_oserror * list_setup_menu(ObjectId self)
{
  ObjectId menu = NULL_ObjectId;

  dprintf(("LiDi", "list_setup_menu: Called for dialogue box object ID &%08X\n", self));

  if (window_get_menu(0, self, &menu) == NULL && menu != NULL_ObjectId)
  {
    int items    = list_count_items    (self);
    int selected = list_count_selected (self);
    int index;

    /* Can't clear a selection or remove items if nothing is selected */

    RetError(menu_set_fade(0, menu, ListMenu_CID_ClearSelection, !selected));
    RetError(menu_set_fade(0, menu, ListMenu_CID_Remove,         !selected));

    /* 'Select all' should be greyed if all items are selected or */
    /* there are no items to select in the first place            */

    if (!items || items == selected) RetError(menu_set_fade(0, menu, ListMenu_CID_SelectAll, 1));
    else                             RetError(menu_set_fade(0, menu, ListMenu_CID_SelectAll, 0));

    /* Grey out 'Add item' if there's a child open */

    for (index = 0; index < known_entries; index++)
    {
      if (idblocks[index].idb.self_id == self) break;
    }

    dprintf(("LiDi", "list_setup_menu: Relevant idblocks index is %d\n", index));

    if (index >= known_entries)
    {
      dprintf(("LiDi", "list_setup_menu: Index > known_entries, so no entry found\n"));

      return errors_frontend_error(fee_invalid_parameters,
                                   1,
                                   "list_setup_menu");
    }

    RetError(menu_set_fade(0, menu, ListMenu_CID_Add, !!(idblocks[index].child != NULL_ObjectId)));
  }

  #ifdef TRACE

    else
    {
      dprintf(("LiDi", "list_setup_menu: No menu attached to the dialogue box\n"));
    }

  #endif

  dprintf(("LiDi", "list_setup_menu: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_restore_focus()                                       */
/*                                                            */
/* Restore input focus to the List dialogue box.              */
/*                                                            */
/* Parameters: Pointer to a list_add_for with the dialogue    */
/*             box's object ID in it.                         */
/**************************************************************/

_kernel_oserror * list_restore_focus(list_add_for * attached)
{
  int handle;

  dprintf(("LiDi", "list_restore_focus: Called with &%08X\n", (unsigned int) attached));

  if (attached == NULL || attached->parent == NULL_ObjectId)
  {
    dprintf(("LiDi", "list_restore_focus: Given no list_add_for structure, or it holds no parent object ID\n"));

    return errors_frontend_error(fee_invalid_parameters,
                                 1,
                                 "list_restore_focus");
  }

  RetError(window_get_wimp_handle(0,
                                  attached->parent,
                                  &handle));

  dprintf(("LiDi", "list_restore_focus: Successful, exitting through wimp_set_caret_position\n"));

  return wimp_set_caret_position(handle, -1, 0, 0, 0, 0);
}
