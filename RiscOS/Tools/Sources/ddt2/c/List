/**************************************************************/
/* File:    List.c                                            */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle dialogue boxes showing a list of items     */
/*          (e.g. for breakpoints). Does some handling for    */
/*          the List add dialogue box and List menu.          */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 19-Mar-1999 (ADH): Created.                       */
/*          24-May-2000 (ADH): 64-wide comments adopted.      */
/*          25-Oct-2000 (ADH): Adapted for DDT2.              */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>
#include <tboxlibs/event.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/window.h>
#include <tboxlibs/menu.h>
#include <tboxlibs/ScrollList.h>

#include "Breakpoint.h"
#include "Errors.h"
#include "Limit.h"
#include "ListAdd.h"
#include "ListMenu.h"
#include "Global.h"
#include "NewProject.h"
#include "TGUtils.h"
#include "Utils.h"

#include "List.h"

/* Locally managed array of known list types; list_known is defined */
/* in List.h and specialised routines needing to gain access to the */
/* array contents can do so with list_get_known_items.              */

static list_known   known[] = {
                                { NewProject_CID_ObjectFiles, "ListNewObj:Objects",             "ListAdd",    true,  ListAdd_EHidden,    NewProject_EHidden, NULL, newproject_fill_list_with_objects,     newproject_read_list_of_objects     },
                                { NewProject_CID_Breakpoints, "ListNewBrk:Initial breakpoints", "Breakpoint", false, Breakpoint_EHidden, NewProject_EHidden, NULL, newproject_fill_list_with_breakpoints, newproject_read_list_of_breakpoints },
                                { NewProject_CID_Watchpoints, "ListNewWtc:Initial watchpoints", "Watchpoint", false, 0,                  NewProject_EHidden, NULL, newproject_fill_list_with_watchpoints, newproject_read_list_of_watchpoints }
                              };

/* The idblocks array is used to store the ToBeShown event IdBlock  */
/* contents for other event handlers to later refer to. This means  */
/* we're restricted to having only one List window open for any one */
/* known source - multiple "views" are not supported.               */

typedef struct list_known_private
{
  unsigned int handle; /* A record of the handle for the read/fill functions above */
  IdBlock      idb;    /* ID block from the ToBeShown event                        */
  ObjectId     child;  /* Child's (e.g. Add dialogue box) object ID                */

} list_known_private;

static bool               initialised   = false;
static unsigned int       known_entries = sizeof(known) / sizeof(*known);
static list_known_private idblocks       [sizeof(known) / sizeof(*known)];

/* Local functions */

static int               list_index_from_id                (ObjectId self);
static _kernel_oserror * list_deregister_shortcut_handlers (ObjectId parent, ObjectId menu, int hide_event);
static int               list_deregister_handlers_for_menu (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static int               list_hidden                       (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_parent_hidden                (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_child_hidden                 (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static int               list_ok                           (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * list_closing                      (int index);

static int               list_select_all_handler           (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_clear_selection_handler      (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_add_item_handler             (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_remove_item_handler          (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);
static int               list_scrolllist_event_handler     (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

static _kernel_oserror * list_fill_from_array_index        (int index);
static _kernel_oserror * list_open_add_dialogue_box        (int index, list_add_for * attached);

/**************************************************************/
/* list_get_known_items()                                     */
/*                                                            */
/* Get a pointer to the array created above that holds the    */
/* types of lists we know about.                              */
/*                                                            */
/* This should really only be of use to very specialised      */
/* functions...                                               */
/*                                                            */
/* Parameters: Pointer to an int which is filled in with      */
/*             the number of entries in the array.            */
/*                                                            */
/* Returns:    Pointer to the list_known array.               */
/*                                                            */
/* Assumes:    The int pointer is mandatory; it may not be    */
/*             NULL.                                          */
/**************************************************************/

const list_known * list_get_known_items(int * entries)
{
  dprintf(("LiDi", "list_get_known_items: Called with &%08X\n", (int) entries));

  *entries = known_entries;

  dprintf(("LiDi", "list_get_known_items: Successful, returning &%08X\n", (int) known));

  return known;
}

/**************************************************************/
/* list_index_from_id()                                       */
/*                                                            */
/* Given a List dialogue box object ID, look through the      */
/* idblocks array and return an index into it for that item.  */
/* Returns -1 if the ID is not found.                         */
/*                                                            */
/* Parameters: Object ID of the List dialogue box to find.    */
/*                                                            */
/* Returns:    Index of the item into the idblocks (and, in   */
/*             passing then, the known) array or -1 if the ID */
/*             is not found.                                  */
/**************************************************************/

static int list_index_from_id(ObjectId self)
{
  int index;

  dprintf(("LiDi", "list_index_from_id: Called for &%08X\n", (int) self));

  for (index = 0; index < known_entries; index++)
  {
    if (idblocks[index].idb.self_id == self) break;
  }

  dprintf(("LiDi", "list_index_from_id: Relevant idblocks index is %d\n", index));

  if (index >= known_entries)
  {
    dprintf(("LiDi", "list_index_from_id: Index > known_entries, returning -1\n"));

    return -1;
  }

  dprintf(("LiDi", "list_index_from_id: Successful, returning %d\n", index));

  return index;
}

/**************************************************************/
/* list_register_shortcut_handlers()                          */
/*                                                            */
/* Register handlers related to keyboard shortcuts and menu   */
/* items connected with the List dialogue box.                */
/*                                                            */
/* Parameters: Object ID of the List dialogue box;            */
/*                                                            */
/*             Object ID of a menu if the handlers are to be  */
/*             registered for that menu, else NULL_ObjectId;  */
/*                                                            */
/*             If a menu ID is given, unique event code       */
/*             raised when the menu is hidden.                */
/**************************************************************/

_kernel_oserror * list_register_shortcut_handlers(ObjectId parent, ObjectId menu, int hide_event)
{
  int      index;
  ObjectId on;

  dprintf(("LiDi", "list_register_shortcut_handlers: Called for parent &%08X, menu &%08X, hide event &%08X\n", (int) parent, (int) menu, hide_event));

  index = list_index_from_id(parent);

  if (index < 0) return errors_frontend_error(fee_invalid_parameters,
                                              "list_register_shortcut_handlers");

  if (menu == NULL_ObjectId) on = parent;
  else                       on = menu;

  RetError(event_register_toolbox_handler(on,
                                          List_ESelectAll,
                                          list_select_all_handler,
                                          (void *) index));

  RetError(event_register_toolbox_handler(on,
                                          List_EClearSelection,
                                          list_clear_selection_handler,
                                          (void *) index));

  RetError(event_register_toolbox_handler(on,
                                          List_EAdd,
                                          list_add_item_handler,
                                          (void *) index));

  RetError(event_register_toolbox_handler(on,
                                          List_ERemove,
                                          list_remove_item_handler,
                                          (void *) index));

  if (menu != NULL_ObjectId)
  {
    RetError(event_register_toolbox_handler(on,
                                            hide_event,
                                            list_deregister_handlers_for_menu,
                                            (void *) index));
  }

  dprintf(("LiDi", "list_register_shortcut_handlers: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_deregister_shortcut_handlers()                        */
/*                                                            */
/* Deregister things registered with                          */
/* list_register_shortcut_handlers.                           */
/*                                                            */
/* Parameters: Object ID of the List dialogue box;            */
/*                                                            */
/*             Object ID of a menu if the handlers are to be  */
/*             registered for that menu, else NULL_ObjectId;  */
/*                                                            */
/*             If a menu ID is given, unique event code       */
/*             raised when the menu is hidden.                */
/**************************************************************/

static _kernel_oserror * list_deregister_shortcut_handlers(ObjectId parent, ObjectId menu, int hide_event)
{
  int      index = list_index_from_id(parent);
  ObjectId on;

  dprintf(("LiDi", "list_deregister_shortcut_handlers: Called for parent &%08X, menu &%08X, hide event &%08X\n", (int) parent, (int) menu, hide_event));

  if (index < 0) return errors_frontend_error(fee_invalid_parameters,
                                              "list_deregister_shortcut_handlers");

  if (menu == NULL_ObjectId) on = parent;
  else                       on = menu;

  RetError(event_deregister_toolbox_handler(on,
                                            List_ESelectAll,
                                            list_select_all_handler,
                                            (void *) index));

  RetError(event_deregister_toolbox_handler(on,
                                            List_EClearSelection,
                                            list_clear_selection_handler,
                                            (void *) index));

  RetError(event_deregister_toolbox_handler(on,
                                            List_EAdd,
                                            list_add_item_handler,
                                            (void *) index));

  RetError(event_deregister_toolbox_handler(on,
                                            List_ERemove,
                                            list_remove_item_handler,
                                            (void *) index));

  if (menu != NULL_ObjectId)
  {
    RetError(event_deregister_toolbox_handler(on,
                                              hide_event,
                                              list_deregister_handlers_for_menu,
                                              (void *) index));
  }

  dprintf(("LiDi", "list_register_shortcut_handlers: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_deregister_handlers_for_menu()                        */
/*                                                            */
/* If list_register_shortcut_handlers was given a menu to     */
/* register for and a hide event, this will have been         */
/* registered then to get rid of the handlers it installed.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_deregister_handlers_for_menu(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_deregister_handlers_for_menu: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_deregister_handlers_for_menu: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_deregister_handlers_for_menu"));
  }

  ChkError(list_deregister_shortcut_handlers(idb->parent_id,
                                             idb->self_id,
                                             eventcode));

  dprintf(("LiDi", "list_deregister_handlers_for_menu: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_close_for_component()                                 */
/*                                                            */
/* If a parent's state changes such that a displayed List     */
/* dialogue box may be inconsistent or invalid (e.g. the      */
/* New project dialogue box's back-end type is changed to one */
/* that has a different set of capabilities not including the */
/* one that this dialogue box is open for), call this to shut */
/* down the list dialogue box. The key for this is the        */
/* component ID used as a source to open the item in the      */
/* first place.                                               */
/*                                                            */
/* May be called before any List dialogue boxes have been     */
/* opened, and called whether or not any are open right now.  */
/*                                                            */
/* Parameters: Component ID that was used as the dialogue box */
/*             source when it was opened.                     */
/**************************************************************/

_kernel_oserror * list_close_for_component(ComponentId c)
{
  bool found = false;
  int  index = 0;

  dprintf(("LiDi", "list_close_for_component: Called for component &%08X\n", (int) c));

  if (!initialised)
  {
    dprintf(("LiDi", "list_close_for_component: Not initialised yet, exitting silently\n"));

    return NULL;
  }

  while (index < known_entries)
  {
    if (known[index].reference == c)
    {
      found = true;

      if (idblocks[index].idb.self_id != NULL_ObjectId)
      {
        dprintf(("LiDi", "list_close_for_component: Closing index %d\n", index));

        utils_restore_focus(idblocks[index].idb.self_id);
        RetError(toolbox_hide_object(0, idblocks[index].idb.self_id));
      }
    }

    index++;
  }

  if (!found)
  {
    dprintf(("LiDi", "list_close_for_component: No matching item found\n"));

    return errors_frontend_error(fee_invalid_parameters,
                                 "list_close_for_component");
  }

  dprintf(("LiDi", "list_close_for_component: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_to_be_shown()                                         */
/*                                                            */
/* Called before the List dialogue box is displayed.          */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int list_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int          index = 0;
  const char * tkn   = NULL;

  dprintf(("LiDi", "list_to_be_shown: Called, self_id = &%08X\n", (int) idb->self_id));

  /* Have we been run at least once? */

  if (initialised == false)
  {
    unsigned int i;

    dprintf(("LiDi", "list_to_be_shown: First call; initialising\n"));

    for (i = 0; i < known_entries; i++)
    {
      idblocks[i].handle      = 0;
      idblocks[i].child       = NULL_ObjectId;
      idblocks[i].idb.self_id = NULL_ObjectId;
    }

    initialised = true;
  }

  /* Find out which list, if any, this is for */

  dprintf(("LiDi", "list_to_be_shown: Checking which list this is for\n"));

  while (index < known_entries)
  {
    if (idb->parent_component == known[index].reference)
    {
      tkn = known[index].messages_token;
      break;
    }
    else index++;
  }

  if (tkn == NULL)
  {
    dprintf(("LiDi", "list_to_be_shown: Don't recognise the parent component &%08X\n", idb->parent_component));

    /* Don't recognise the parent component ID */

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_to_be_shown"));

    return 0;
  }

  dprintf(("LiDi", "list_to_be_shown: Open for index %d\n", index));

  /* Do we appear to be open already though? */

  if (idblocks[index].idb.self_id != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_to_be_shown: This item is already open\n"));

    return 0;
  }

  /* Store the ID block contents for future reference; fill in the list */
  /* contents and set the window title up.                              */

  idblocks[index].idb   = *idb;
  idblocks[index].child = NULL_ObjectId;

  ChkError(window_set_title(0, idb->self_id, lookup_token(tkn, 0)));
  ChkError(tgutils_remove_all(idb->self_id, List_CID_ScrollList));
  ChkError(list_fill_from_array_index(index));

  /* Grey out Remove for now, as there's nothing selected to start with; */
  /* ungrey "Add" in case it's still greyed out from earlier.            */

  ChkError(set_gadget_state(idb->self_id, List_CID_Remove, 1));
  ChkError(set_gadget_state(idb->self_id, List_CID_Add,    0));

  /* Event handlers.                                           */
  /*                                                           */
  /* Must be deregistered individually in the close handler.   */
  /* You can't deregister all handlers for the object as child */
  /* dialogue boxes may have handlers registered for us, which */
  /* could get trashed depending on the event handling order.  */

  ChkError(list_register_shortcut_handlers(idb->self_id, NULL_ObjectId, 0));

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          ScrollList_Selection,
                                          list_scrolllist_event_handler,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          List_EClose,
                                          list_ok,
                                          (void *) index));

  ChkError(event_register_toolbox_handler(idb->self_id,
                                          List_EHidden,
                                          list_hidden,
                                          (void *) index));

  /* An unusual one - we need to hide *ourselves* if the parent window */
  /* that opened us disappears. Don't forget to deregister it later!   */

  dprintf(("LiDi", "list_to_be_shown: Registering handler on parent\n"));

  ChkError(event_register_toolbox_handler(idb->parent_id,
                                          known[index].parent_hide_event,
                                          list_parent_hidden,
                                          (void *) index));

  /* Finally, if we've got a function to get a handle for this item, call it */

  if (known[index].get_handle != NULL)
  {
    dprintf(("LiDi", "list_to_be_shown: Calling get_handle function\n"));

    ChkError((known[index].get_handle)(idb->self_id, &idblocks[index].handle));
  }

  dprintf(("LiDi", "list_to_be_shown: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_hidden()                                              */
/*                                                            */
/* Called when the List dialogue box is hidden.               */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_hidden: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_hidden"));
  }

  /* Clear the "don't re-open" semaphore */

  idblocks[index].idb.self_id = NULL_ObjectId;

  /* Deregister all event handlers registered in the */
  /* List_EToBeShown event handler.                  */

  ChkError(list_deregister_shortcut_handlers(idblocks[index].idb.self_id, NULL_ObjectId, 0));

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            ScrollList_Selection,
                                            list_scrolllist_event_handler,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            List_EClose,
                                            list_ok,
                                            (void *) index));

  ChkError(event_deregister_toolbox_handler(idblocks[index].idb.self_id,
                                            List_EHidden,
                                            list_hidden,
                                            (void *) index));

  /* Handler watching for a closing parent */

  if (idblocks[index].idb.parent_id != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_hidden: Deregistering handler on parent\n"));

    ChkError(event_deregister_toolbox_handler(idblocks[index].idb.parent_id,
                                              known[index].parent_hide_event,
                                              list_parent_hidden,
                                              (void *) index));
  }

  dprintf(("LiDi", "list_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_parent_hidden()                                       */
/*                                                            */
/* Eeek, the parent window is closing - time for bed...       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_parent_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_parent_hidden: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_parent_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_parent_hidden"));
  }

  ChkError(toolbox_hide_object(0, idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_parent_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_child_hidden()                                        */
/*                                                            */
/* Called on the child_hide_event for the Add dialogue box.   */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_child_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_child_hidden: Called for index %d\n", index));

  /* Don't check idb.self_id - the List dialogue's Hidden handler */
  /* may get called first and will have cleared the field         */

  if (
       index                 <  0             ||
       index                 >= known_entries ||
       idblocks[index].child == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_child_hidden: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_child_hidden"));
  }

  /* Clear our record of the child */

  idblocks[index].child = NULL_ObjectId;

  /* Ungrey "Add" */

  if (idblocks[index].idb.self_id != NULL_ObjectId)
  {
    ChkError(set_gadget_state(idblocks[index].idb.self_id,
                              List_CID_Add,
                              0));
  }

  /* Ensure the menu is up to date (we may want to ensure 'New' is ungreyed) */

  ChkError(list_setup_menu(idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_child_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_ok()                                                  */
/*                                                            */
/* Called when OK is activated for the List dialogue box.     */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_ok(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_ok: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_ok: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_ok"));
  }

  /* If there's a handler, tell it to read the entries now */

  if (known[index].read_list != NULL)
  {
    dprintf(("LiDi", "list_ok: Calling read_list function\n"));

    errors_ret((known[index].read_list)(idb->self_id, idblocks[index].handle));
  }

  idblocks[index].handle = 0;

  ChkError(list_closing(index));

  dprintf(("LiDi", "list_ok: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_closing()                                             */
/*                                                            */
/* If the List dialogue box may be closing, call this to do   */
/* various tidy-up actions which are the same for any source  */
/* of closure (e.g. "OK" and "Cancel").                       */
/*                                                            */
/* Parameters: Index into the 'known' and 'idblocks' arrays   */
/*             for this item.                                 */
/**************************************************************/

static _kernel_oserror * list_closing(int index)
{
  dprintf(("LiDi", "list_closing: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_closing: Invalid index\n"));

    RetError(errors_frontend_error(fee_invalid_parameters,
                                   "list_closing"));
  }

  /* Should we close the window? (Keyboard shortcut or SELECT pressed) */

  if (idblocks[index].idb.self_component == NULL_ComponentId || !adjust())
  {
    dprintf(("LiDi", "list_closing: Dialogue box should be closed\n"));

    /* Hide the object (don't delete - it was auto-created). The Hidden */
    /* handler does the rest.                                           */

    utils_restore_focus(idblocks[index].idb.self_id);
    RetError(toolbox_hide_object(0, idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_closing: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_select_all_handler()                                  */
/*                                                            */
/* Handle an List_ESelectAll event from a menu item with a    */
/* List dialogue as its parent or a key shortcut invoked from */
/* a List dialogue box.                                       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_select_all_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_select_all_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_select_all_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_select_all_handler"));
  }

  if (list_count_items(idblocks[index].idb.self_id) > 0)
  {
    ChkError(list_select_all(idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_select_all_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_clear_selection_handler()                             */
/*                                                            */
/* Handle an List_EClearSelection event from a menu item with */
/* a List dialogue as its parent or a key shortcut invoked    */
/* from a List dialogue box.                                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_clear_selection_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_clear_selection_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_clear_selection_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_clear_selection"));
  }

  if (list_count_items(idblocks[index].idb.self_id) > 0)
  {
    ChkError(list_clear_selection(idblocks[index].idb.self_id));
  }

  dprintf(("LiDi", "list_clear_selection_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_add_item_handler()                                    */
/*                                                            */
/* Handle an List_EAdd event from a menu item with a List     */
/* dialogue as its parent or a key shortcut invoked from a    */
/* List dialogue box.                                         */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_add_item_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int            index = (int) handle;
  list_add_for * item;

  dprintf(("LiDi", "list_add_item_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_add_item_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_add_item_handler"));
  }

  /* Is there a dialogue box open already? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_add_item_handler: Child already open\n"));
    return 0;
  }

  /* Create the new item */

  item = (list_add_for *) malloc(sizeof(list_add_for));

  if (!item)
  {
    dprintf(("LiDi", "list_add_item_handler: Not enough memory\n"));

    ChkError(errors_frontend_error(fee_out_of_memory,
                                   "list_add_item_handler"));
  }
  else item->list_item = -1;

  /* Fill it in */

  item->parent            = idblocks[index].idb.self_id;
  item->open_for          = List_CID_ScrollList;
  item->parent_hide_event = List_EHidden;
  *item->initial_text     = '\0';

  ChkError(toolbox_get_client_handle(0,
                                     idblocks[index].idb.parent_id,
                                     (void *) &item->debugger_handle));

  /* Create and open the dialogue box */

  dprintf(("LiDi", "list_add_item_handler: Opening Add dialogue box\n"));

  ChkError(list_open_add_dialogue_box(index, item));

  dprintf(("LiDi", "list_add_item_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_remove_item_handler()                                 */
/*                                                            */
/* Handle an List_ERemove event from a menu item with a List  */
/* dialogue as its parent or a key shortcut invoked from a    */
/* List dialogue box.                                         */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_remove_item_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int index = (int) handle;

  dprintf(("LiDi", "list_remove_item_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_remove_item_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_remove_item_handler"));
  }

  ChkError(list_remove_selected(idblocks[index].idb.self_id));

  dprintf(("LiDi", "list_remove_item_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_scrolllist_event_handler()                            */
/*                                                            */
/* Handles events for the ScrollList gadget in a List         */
/* dialogue box. Specifically, checks for items being         */
/* selected / deselected and updates various UI components as */
/* required.                                                  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The handle should be an integer index into the 'known'     */
/* and 'idblocks' arrays.                                     */
/**************************************************************/

static int list_scrolllist_event_handler(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ScrollListSelectionEvent * sel   = (ScrollListSelectionEvent *) event;
  int                        index = (int) handle;

  dprintf(("LiDi", "list_scrolllist_event_handler: Called for index %d\n", index));

  if (
       index                       <  0             ||
       index                       >= known_entries ||
       idblocks[index].idb.self_id == NULL_ObjectId
     )
  {
    dprintf(("LiDi", "list_scrolllist_event_handler: Invalid index\n"));

    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_scrolllist_event_handler"));
  }

  /* Is there a dialogue box open already? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    dprintf(("LiDi", "list_scrolllist_event_handler: Child open - closing it\n"));

    ChkError(toolbox_hide_object(0, idblocks[index].child));
  }

  /* Grey/ungrey the "Remove" button and make sure the menu is up to date */

  if (list_count_selected(idb->self_id) > 0) set_gadget_state(idb->self_id, List_CID_Remove, 0);
  else                                       set_gadget_state(idb->self_id, List_CID_Remove, 1);

  ChkError(list_setup_menu(idb->self_id));

  /* If this was a double-click, need to open a List add dialogue */
  /* box (or equivalent) for that entry. So, a list_add_for       */
  /* structure needs building.                                    */

  if (sel->flags & ScrollList_Selection_Flags_DoubleClick)
  {
    list_add_for * item = (list_add_for *) malloc(sizeof(list_add_for));

    if (!item)
    {
      ChkError(errors_frontend_error(fee_out_of_memory,
                                     "list_scrolllist_event_handler"));
    }
    else item->list_item = sel->item;

    item->parent            = idb->self_id;
    item->open_for          = List_CID_ScrollList;
    item->parent_hide_event = List_EHidden;

    ChkError(toolbox_get_client_handle(0,
                                       idblocks[index].idb.parent_id,
                                       (void *) &item->debugger_handle));

    ChkError(scrolllist_get_item_text(0,
                                      idb->self_id,
                                      idb->self_component,
                                      item->initial_text,
                                      sizeof(item->initial_text),
                                      sel->item,
                                      NULL));

    ChkError(list_open_add_dialogue_box((int) handle, item));
  }

  dprintf(("LiDi", "list_scrolllist_event_handler: Successful\n"));

  return 0;
}

/**************************************************************/
/* list_fill_from_array_index()                               */
/*                                                            */
/* Given an index into the 'known' array of list_known        */
/* structures (see top of this file), write the relevant      */
/* items into a List dialogue via.                            */
/* list_fill_from_comma_separated_string.                     */
/*                                                            */
/* Parameters: Index into array (this is limit checked so     */
/*             invalid values can be passed safely - the      */
/*             function just exits if the value is invalid).  */
/**************************************************************/

static _kernel_oserror * list_fill_from_array_index(int index)
{
  unsigned int flags;
  ObjectId     self = idblocks[index].idb.self_id;

  dprintf(("LiDi", "list_fill_from_array_index: Called for index %d\n", index));

  /* Set the gadget to allow multiple selections */

  RetError(scrolllist_get_state(0, self, List_CID_ScrollList, &flags));
  RetError(scrolllist_set_state(0, self, List_CID_ScrollList, flags | ScrollList_MultipleSelections));

  /* Call the fill handler function, if present */

  if (index >= 0 && index < known_entries)
  {
    if (known[index].fill_list != NULL)
    {
      dprintf(("LiDi", "list_fill_from_array_index: Successful, exitting through fill_list function\n"));

      return (known[index].fill_list)(self, idblocks[index].handle);
    }
  }
  else
  {
    dprintf(("LiDi", "list_fill_from_array_index: Invalid index\n"));

    return errors_frontend_error(fee_invalid_parameters,
                                 "list_fill_from_array_index");
  }

  dprintf(("LiDi", "list_fill_from_array_index: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_open_add_dialogue_box()                               */
/*                                                            */
/* Direct callable function and service function for          */
/* list_add_item_handler. Creates and opens an appropriate    */
/* dialogue box to add an item to a list. The item's Hidden   */
/* handler is expected to delete it and free the              */
/* list_add_for structure.                                    */
/*                                                            */
/* Must not be called if the item is already being shown.     */
/*                                                            */
/* Parameters: Index into the 'known' and 'idblocks' array    */
/*             for the List dialogue box;                     */
/*                                                            */
/*             Pointer to an initialised list_add_for         */
/*             structure to attach to the new object.         */
/**************************************************************/

static _kernel_oserror * list_open_add_dialogue_box(int index, list_add_for * attached)
{
  dprintf(("LiDi", "list_open_add_dialogue_box: Called for index %d, attached &%08X\n", index, (int) attached));

  /* Is there already a child open? */

  if (idblocks[index].child != NULL_ObjectId)
  {
    ChkError(errors_frontend_error(fee_invalid_parameters,
                                   "list_open_add_dialogue_box"));
  }

  /* Create a new dialogue box. */

  RetError(toolbox_create_object(0,
                                 (char *) known[index].add_name,
                                 &idblocks[index].child));

  /* Set the list_add_for pointer as a client handle */

  RetError(toolbox_set_client_handle(0, idblocks[index].child, (void *) attached));

  /* Register a handler for when the child is hidden */

  ChkError(event_register_toolbox_handler(idblocks[index].child,
                                          known[index].child_hide_event,
                                          list_child_hidden,
                                          (void *) index));

  /* Grey out the "Add" button */

  ChkError(set_gadget_state(idblocks[index].idb.self_id,
                            List_CID_Add,
                            1));

  /* Ensure the menu is up to date (we may want to ensure 'New' is greyed out) */

  ChkError(list_setup_menu(idblocks[index].idb.self_id));

  /* Show the new dialogue box - its ToBeShown handler does the rest. */

  dprintf(("LiDi", "list_open_add_dialogue_box: Successful, exitting through toolbox_show_object\n"));

  return toolbox_show_object(0,
                             idblocks[index].child,
                             Toolbox_ShowObject_Centre,
                             NULL,
                             idblocks[index].idb.self_id,
                             List_CID_ScrollList);
}

/**************************************************************/
/* list_count_items()                                         */
/*                                                            */
/* Returns the number of items present in the scrolling list  */
/* of the given List dialogue box.                            */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/*                                                            */
/* Returns:    Number of items in the scrolling list. Returns */
/*             0 if there's an error as well as if there are  */
/*             no items in the list.                          */
/**************************************************************/

int list_count_items(ObjectId self)
{
  dprintf(("LiDi", "list_count_items: Called, successful, exitting through tgutils_count_items\n"));

  return tgutils_count_items(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_count_selected()                                      */
/*                                                            */
/* Returns the number of items selected in the scrolling list */
/* of the given List dialogue box.                            */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/*                                                            */
/* Returns:    Number of items selected in the list. Returns  */
/*             0 if there's an error as well as if there are  */
/*             no items in the list.                          */
/**************************************************************/

int list_count_selected(ObjectId self)
{
  dprintf(("LiDi", "list_count_selected: Called\n"));
  dprintf(("LiDi", "list_count_selected: Successful, exitting through tgutils_count_selected\n"));

  return tgutils_count_selected(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_select_all()                                          */
/*                                                            */
/* Select all items in the ScrollList component of the given  */
/* List dialogue box.                                         */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/**************************************************************/

_kernel_oserror * list_select_all(ObjectId self)
{
  dprintf(("LiDi", "list_select_all: Called\n"));
  dprintf(("LiDi", "list_select_all: Successful, exitting through tgutils_select_all\n"));

  return tgutils_select_all(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_clear_selection()                                     */
/*                                                            */
/* Deselect all items in the ScrollList component of the      */
/* given List dialogue box.                                   */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/**************************************************************/

_kernel_oserror * list_clear_selection(ObjectId self)
{
  dprintf(("LiDi", "list_clear_selection: Called\n"));
  dprintf(("LiDi", "list_clear_selection: Successful, exitting through tgutils_clear_selection\n"));

  return tgutils_clear_selection(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_remove_selected()                                     */
/*                                                            */
/* Remove all selected items in the ScrollList component of   */
/* the given List dialogue box.                               */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/**************************************************************/

_kernel_oserror * list_remove_selected(ObjectId self)
{
  dprintf(("LiDi", "list_remove_selected: Called\n"));
  dprintf(("LiDi", "list_remove_selected: Successful, exitting through tgutils_remove_selected\n"));

  return tgutils_remove_selected(self, List_CID_ScrollList);
}

/**************************************************************/
/* list_add_item()                                            */
/*                                                            */
/* Add an item to a scrolling list if the item isn't already  */
/* present. If it is, delete the old item and replace it with */
/* the new one.                                               */
/*                                                            */
/* Parameters: Object ID of the List dialogue box;            */
/*                                                            */
/*             Text to put into item.                         */
/**************************************************************/

_kernel_oserror * list_add_item(ObjectId self, const char * text)
{
  char item    [Limits_List_Item];
  int  items = list_count_items(self);
  int  count;

  dprintf(("LiDi", "list_add_item: Called for &%08X with '%s'\n", (int) self, text ? text : "<NULL>"));

  if (text == NULL) return errors_frontend_error(fee_invalid_parameters,
                                                 "list_add_item");

  for (count = 0; count < items; count++)
  {
    RetError(scrolllist_get_item_text(0,
                                      self,
                                      List_CID_ScrollList,
                                      item,
                                      sizeof(item),
                                      count,
                                      NULL));

    item[sizeof(item) - 1] = '\0';

    if (!strcmp(item, text)) break;
  }

  /* Anything found? */

  if (count < items)
  {
    dprintf(("LiDi", "list_add_item: Existant copy found at index %d - removing it\n", count));

    RetError(scrolllist_delete_items(0,
                                     self,
                                     List_CID_ScrollList,
                                     count,
                                     count));
  }

  dprintf(("LiDi", "list_add_item: Successful, exitting through scrolllist_add_item\n"));

  return scrolllist_add_item(ScrollList_AddItem_MakeVisible,
                             self,
                             List_CID_ScrollList,
                             text,
                             NULL,
                             NULL,
                             0);
}

/**************************************************************/
/* list_modify_item()                                         */
/*                                                            */
/* Modify an item in a scrolling list. If an item with the    */
/* same text already exists, it is deleted.                   */
/*                                                            */
/* Parameters: Object ID of the List dialogue box;            */
/*                                                            */
/*             Index of item to change;                       */
/*                                                            */
/*             Text to change item to.                        */
/**************************************************************/

_kernel_oserror * list_modify_item(ObjectId self, int index, const char * text)
{
  char item    [Limits_List_Item];
  int  items = list_count_items(self);
  int  count;

  dprintf(("LiDi", "list_modify_item: Called for &%08X, index %d, with '%s'\n", (int) self, index, text ? text : "<NULL>"));

  if (text == NULL) return errors_frontend_error(fee_invalid_parameters,
                                                 "list_modify_item");

  /* Set the new text */

  RetError(scrolllist_set_item_text(ScrollList_AddItem_MakeVisible,
                                    self,
                                    List_CID_ScrollList,
                                    (char *) text,
                                    index));

  /* Check for an identical item */

  for (count = 0; count < items; count++)
  {
    if (count != index)
    {
      RetError(scrolllist_get_item_text(0,
                                        self,
                                        List_CID_ScrollList,
                                        item,
                                        sizeof(item),
                                        count,
                                        NULL));

      item[sizeof(item) - 1] = '\0';

      if (!strcmp(item, text)) break;
    }
  }

  /* If found, delete it */

  if (count < items)
  {
    dprintf(("LiDi", "list_modify_item: Existant copy found at index %d - removing it\n", count));

    RetError(scrolllist_delete_items(0,
                                     self,
                                     List_CID_ScrollList,
                                     count,
                                     count));
  }

  dprintf(("LiDi", "list_modify_item: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_setup_menu()                                          */
/*                                                            */
/* Ensure the relevant items are greyed or ungreyed in the    */
/* menu attached to the List dialogue box (if any).           */
/*                                                            */
/* Parameters: Object ID of the List dialogue box.            */
/**************************************************************/

_kernel_oserror * list_setup_menu(ObjectId self)
{
  ObjectId menu = NULL_ObjectId;

  dprintf(("LiDi", "list_setup_menu: Called for dialogue box object ID &%08X\n", self));

  if (window_get_menu(0, self, &menu) == NULL && menu != NULL_ObjectId)
  {
    int items    = list_count_items    (self);
    int selected = list_count_selected (self);
    int index;

    /* Can't clear a selection or remove items if nothing is selected */

    RetError(menu_set_fade(0, menu, ListMenu_CID_ClearSelection, !selected));
    RetError(menu_set_fade(0, menu, ListMenu_CID_Remove,         !selected));

    /* 'Select all' should be greyed if all items are selected or */
    /* there are no items to select in the first place            */

    if (!items || items == selected) RetError(menu_set_fade(0, menu, ListMenu_CID_SelectAll, 1));
    else                             RetError(menu_set_fade(0, menu, ListMenu_CID_SelectAll, 0));

    /* Grey out 'Add item' if there's a child open */

    index = list_index_from_id(self);

    if (index < 0)
    {
      dprintf(("LiDi", "list_setup_menu: No idblocks index found\n"));

      return errors_frontend_error(fee_invalid_parameters,
                                   "list_setup_menu");
    }

    RetError(menu_set_fade(0, menu, ListMenu_CID_Add, !!(idblocks[index].child != NULL_ObjectId)));
  }

  #ifdef TRACE

    else
    {
      dprintf(("LiDi", "list_setup_menu: No menu attached to the dialogue box\n"));
    }

  #endif

  dprintf(("LiDi", "list_setup_menu: Successful\n"));

  return NULL;
}

/**************************************************************/
/* list_handle_data_load()                                    */
/*                                                            */
/* Handle reception of Wimp_MDataLoad. Designed as a handler  */
/* function for Handlers.c's handle_messages.                 */
/*                                                            */
/* Parameters: Object ID the message was directed at;         */
/*                                                            */
/*             Component ID the message was directed at;      */
/*                                                            */
/*             Pointer to the message block.                  */
/*                                                            */
/* Returns:    true if the message was handled, else false.   */
/**************************************************************/

bool list_handle_data_load(ObjectId o, ComponentId c, const WimpMessage * m)
{
  unsigned int i;

  dprintf(("LiDi", "list_handle_data_load: Called for object &%08X, component &%08X\n", (int) o, (int) c));

  /* Check all open dialogue boxes */

  for (i = 0; i < known_entries; i++)
  {
    /* Is this entry valid, and does it allow dragging to itself? */

    if (
         known[i].drag_to_add                     &&
         idblocks[i].idb.self_id != NULL_ObjectId
       )
    {
      bool handle = false;

      /* Some mungery as dragging to the ScrollList can lead to a different */
      /* ObjectID being returned. When is a gadget not a gadget...          */

      if (idblocks[i].idb.self_id == o) handle = true;
      else
      {
        ObjectId parent;

        ChkError(toolbox_get_parent(0, o, &parent, NULL));

        if (
             parent != NULL_ObjectId           &&
             o      != idblocks[i].child       && /* Don't want to get the Add dialogue box by accident - allowing that screws up e.g. editing an item and dragging to the dialogue box - it gets added, not edited */
             parent == idblocks[i].idb.self_id
           )
           handle = true, o = parent;
      }

      /* OK, if we've decided to handle it, add the item for the ID in 'o' */

      if (handle)
      {
        dprintf(("LiDi", "list_handle_data_load: Object ID is recognised as handleable\n"));

        if (idblocks[i].child) ChkError(toolbox_hide_object(0, idblocks[i].child));

        ChkError(list_add_item(o, m->data.data_load.leaf_name));

        dprintf(("LiDi", "list_handle_data_load: Successful, message was handled\n"));

        return true;
      }
    }
  }

  dprintf(("LiDi", "list_handle_data_load: Successful, message was not handled\n"));

  return false;
}
