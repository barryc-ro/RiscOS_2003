/**************************************************************/
/* File:    Breakpoint.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Handle the Breakpoint dialogue box.               */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 14-Nov-2000 (ADH): Created from ListAdd.c.        */
/**************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <tboxlibs/wimp.h>
#include <tboxlibs/wimplib.h>

#include <tboxlibs/toolbox.h>
#include <tboxlibs/gadgets.h>
#include <tboxlibs/ScrollList.h>

#include "BEManager.h"
#include "BEStructs.h"
#include "Errors.h"
#include "Limit.h"
#include "List.h"
#include "Global.h"
#include "Utils.h"

#include "Breakpoint.h"

/* Local definitions */

/* These are for line of text -> Breakpoint dialogue box entry conversion */

#define Breakpoint_Tag_Function    "Function: "
#define Breakpoint_Tag_Address     "Address: "
#define Breakpoint_Tag_SWI         "SWI: "
#define Breakpoint_Tag_Line        "Line: "
#define Breakpoint_Tag_WimpEvent   "Wimp event: "
#define Breakpoint_Tag_ServiceCall "Service call: "
#define Breakpoint_Tag_UpCall      "UpCall: "

/* Local variables */

static ObjectId window_for_focus = NULL_ObjectId;

/* Local functions */

static _kernel_oserror * breakpoint_set_up        (ObjectId o, list_add_for * attached);
static int               breakpoint_gain_focus    (int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle);
static int               breakpoint_parent_hidden (int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle);

/**************************************************************/
/* breakpoint_set_up()                                        */
/*                                                            */
/* Set up the Breakpoint dialogue box using a list_add_for    */
/* structure.                                                 */
/*                                                            */
/* Parameters: Object ID of the dialogue box;                 */
/*                                                            */
/*             Pointer to the list_add_for structure.         */
/**************************************************************/

_kernel_oserror * breakpoint_set_up(ObjectId o, list_add_for * attached)
{
  const debugger * d;
  debugger         temp;
  ComponentId      def   = NULL_ComponentId;
  ComponentId      focus = NULL_ComponentId;
  int              state;

  dprintf(("BrkP", "breakpoints_set_up: Called with ID &%08X for &%08X\n", (int) o, (int) attached));

  if (attached == NULL)
  {
    return errors_frontend_error(fee_invalid_parameters,
                                 "breakpoint_set_up");
  }

  memset(&temp, 0, sizeof(temp));

  RetError(bemanager_get_debugger(attached->debugger_handle, &d));

  /* If "Add" isn't allowed, there's no way to set any break points at all, */
  /* so no point in allowing this dialogue to even view them - what's it    */
  /* going to view...?                                                      */

  if (d->ab.breakpoints.set == NULL)
  {
    errors_ret(errors_backend_error(attached->debugger_handle,
                                    bee_operation_not_supported));

    /* Ensure everything will be greyed out... */

    d = &temp;
  }

  /* First thing - grey/ungrey everything */

  state = d->ab.breakpoints.address == true ? 0 : 1;

  /* Function / address / SWI / line radio buttons */

  RetError(set_gadget_state(o,
                            Breakpoint_CID_Function,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_Address,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_Line,
                            state));

  if (state == 0) def = Breakpoint_CID_Function;

  state = d->ab.breakpoints.swi == true ? 0 : 1;

  RetError(set_gadget_state(o,
                            Breakpoint_CID_SWI,
                            state));

  if (state == 0 && def == NULL_ComponentId) def = Breakpoint_CID_SWI;

  /* Main writeable according to above radio button settings */

  RetError(set_gadget_state(o,
                            Breakpoint_CID_MainWriteable,
                            def != NULL_ComponentId ? 0 : 1));

  if (def != NULL_ComponentId) focus = Breakpoint_CID_MainWriteable;

  /* Wimp event */

  state = d->ab.breakpoints.event == true ? 0 : 1;

  RetError(set_gadget_state(o,
                            Breakpoint_CID_WimpEventRadio,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_WimpEventDisplay,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_WimpEventPopUp,
                            state));

  if (state == 0 && def == NULL_ComponentId) def = Breakpoint_CID_WimpEventRadio;

  /* Service call */

  state = d->ab.breakpoints.service == true ? 0 : 1;

  RetError(set_gadget_state(o,
                            Breakpoint_CID_ServiceCallRadio,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_ServiceCallWriteable,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_ServiceCallPopUp,
                            state));

  if (state == 0 && def == NULL_ComponentId)
  {
    def   = Breakpoint_CID_ServiceCallRadio;
    focus = Breakpoint_CID_ServiceCallWriteable;
  }

  /* UpCall */

  state = d->ab.breakpoints.upcall == true ? 0 : 1;

  RetError(set_gadget_state(o,
                            Breakpoint_CID_UpCallRadio,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_UpCallWriteable,
                            state));

  RetError(set_gadget_state(o,
                            Breakpoint_CID_UpCallPopUp,
                            state));

  if (state == 0 && def == NULL_ComponentId)
  {
    def   = Breakpoint_CID_UpCallRadio;
    focus = Breakpoint_CID_UpCallWriteable;
  }

  /* Action buttons */

//  state = d->ab.breakpoints.clear != NULL ? 0 : 1;
//
//  RetError(set_gadget_state(o,
//                            Breakpoint_CID_RemoveAll,
//                            state));
//
//  RetError(set_gadget_state(o,
//                            Breakpoint_CID_Remove,
//                            state));

  set_gadget_state(o, Breakpoint_CID_RemoveAll, 1);
  set_gadget_state(o, Breakpoint_CID_Remove,    1);

  RetError(set_gadget_state(o,
                            Breakpoint_CID_Add,
                            d->ab.breakpoints.set != NULL ? 0 : 1));

  /* Empty the writeable and display fields */

  RetError(utils_set_writeable_field(o,
                                     Breakpoint_CID_MainWriteable,
                                     "",
                                     Limits_Writeable_General));

  RetError(utils_set_display_field  (o,
                                     Breakpoint_CID_WimpEventDisplay,
                                     "",
                                     Limits_Breakpoint_WEDisplay));

  RetError(utils_set_writeable_field(o,
                                     Breakpoint_CID_ServiceCallWriteable,
                                     "",
                                     Limits_Breakpoint_SCWriteable));

  RetError(utils_set_writeable_field(o,
                                     Breakpoint_CID_UpCallWriteable,
                                     "",
                                     Limits_Breakpoint_UCWriteable));

  /* Second thing - deal with initial text */

  if (attached->initial_text == NULL || *attached->initial_text == '\0')
  {
    /* Is there a default radio button to select? */

    if (def == NULL_ComponentId)
    {
      /* Yikes, no. We shouldn't be open! */

      if (d != &temp) return errors_backend_error(attached->debugger_handle,
                                                  bee_operation_not_supported);
    }
    else
    {
      /* Select the default radio button */

      RetError(radiobutton_set_state(0, o, def, 1));
    }
  }
  else
  {
    unsigned int flags;
    unsigned int add = 0;

    def = NULL_ComponentId;

    /* See if this is an item for the main writeable */

    if      (!strncmp(attached->initial_text, Breakpoint_Tag_Function, sizeof(Breakpoint_Tag_Function) - 1)) add = sizeof(Breakpoint_Tag_Function) - 1, def = Breakpoint_CID_Function;
    else if (!strncmp(attached->initial_text, Breakpoint_Tag_Address,  sizeof(Breakpoint_Tag_Address)  - 1)) add = sizeof(Breakpoint_Tag_Address)  - 1, def = Breakpoint_CID_Address;
    else if (!strncmp(attached->initial_text, Breakpoint_Tag_SWI,      sizeof(Breakpoint_Tag_SWI)      - 1)) add = sizeof(Breakpoint_Tag_SWI)      - 1, def = Breakpoint_CID_SWI;
    else if (!strncmp(attached->initial_text, Breakpoint_Tag_Line,     sizeof(Breakpoint_Tag_Line)     - 1)) add = sizeof(Breakpoint_Tag_Line)     - 1, def = Breakpoint_CID_Line;

    /* If it is, select the appropriate radio button and fill in the text */

    if (def != NULL_ComponentId)
    {
      focus = Breakpoint_CID_MainWriteable;

      RetError(radiobutton_set_state(0, o, def, 1));

      RetError(utils_set_writeable_field(o,
                                         focus,
                                         attached->initial_text + add,
                                         Limits_Writeable_General));
    }

    /* Otherwise, deal with the Wimp event, service call and UpCall options */

    else if (!strncmp(attached->initial_text, Breakpoint_Tag_WimpEvent, sizeof(Breakpoint_Tag_WimpEvent) - 1))
    {
      def = Breakpoint_CID_WimpEventRadio;

      RetError(radiobutton_set_state(0, o, def, 1));

      RetError(utils_set_display_field(o,
                                       Breakpoint_CID_WimpEventDisplay,
                                       attached->initial_text + sizeof(Breakpoint_Tag_WimpEvent) - 1,
                                       Limits_Breakpoint_WEDisplay));
    }
    else if (!strncmp(attached->initial_text, Breakpoint_Tag_ServiceCall, sizeof(Breakpoint_Tag_ServiceCall) - 1))
    {
      def   = Breakpoint_CID_ServiceCallRadio;
      focus = Breakpoint_CID_ServiceCallWriteable;

      RetError(radiobutton_set_state(0, o, def, 1));

      RetError(utils_set_writeable_field(o,
                                         focus,
                                         attached->initial_text + sizeof(Breakpoint_Tag_ServiceCall) - 1,
                                         Limits_Breakpoint_SCWriteable));
    }
    else if (!strncmp(attached->initial_text, Breakpoint_Tag_UpCall, sizeof(Breakpoint_Tag_UpCall) - 1))
    {
      def   = Breakpoint_CID_UpCallRadio;
      focus = Breakpoint_CID_UpCallWriteable;

      RetError(radiobutton_set_state(0, o, def, 1));

      RetError(utils_set_writeable_field(o,
                                         focus,
                                         attached->initial_text + sizeof(Breakpoint_Tag_UpCall) - 1,
                                         Limits_Breakpoint_UCWriteable));
    }

    /* Nothing selected? Bad string. */

    if (def == NULL_ComponentId)
    {
      return errors_frontend_error(fee_invalid_parameters,
                                   "breakpoint_set_up");
    }

    /* Was whatever we just selected already greyed out? */

    RetError(gadget_get_flags(0, o, def, &flags));

    if (flags & Gadget_Faded)
    {
      return errors_frontend_error(fee_invalid_parameters,
                                   "breakpoint_set_up");
    }
  }

  /* Need to give input focus? We can't just set it here, as the window */
  /* isn't actually open yet. Giving a default input focus will lead to */
  /* a "can't place focus anywhere" Toolbox error if all the writeables */
  /* are greyed out, which is why it needs to be set manually in the    */
  /* first place.                                                       */

  if (focus != NULL_ComponentId)
  {
    window_for_focus = o;

    register_null_claimant(Wimp_ENull,
                           breakpoint_gain_focus,
                           (void *) focus);
  }

  /* Done */

  dprintf(("BrkP", "breakpoints_set_up: Successful\n"));

  return NULL;
}

/**************************************************************/
/* breakpoint_gain_focus()                                    */
/*                                                            */
/* If you set up a window to gain focus in a gadget but all   */
/* the writeable fields linked to and including that gadget   */
/* are greyed, the Toolbox actually raises an error. If you   */
/* try and set input focus manually in a ToBeShown handler    */
/* the Toolbox raises another error, because the dialogue box */
/* isn't open at that point. Hence this null event handler.   */
/*                                                            */
/* Ick.                                                       */
/*                                                            */
/* Parameters are as standard for a Wimp event handler. The   */
/* 'handle' field should hold the component ID to put the     */
/* focus in, cast to void *, and the "window_for_focus"       */
/* static (see top of source file) should be set to the       */
/* relevant ID - this is OK, since you can only have focus in */
/* one window at a time.                                      */
/**************************************************************/

static int breakpoint_gain_focus(int eventcode, WimpPollBlock * b, IdBlock * idb, void * handle)
{
  /* No error reporting in case the dialogue box has managed to hide itself by now */

  gadget_set_focus(0,
                   window_for_focus,
                   (ComponentId) handle);

  window_for_focus = NULL_ObjectId;

  deregister_null_claimant(Wimp_ENull,
                           breakpoint_gain_focus,
                           handle);

  return 0;
}

/**************************************************************/
/* breakpoint_to_be_shown()                                   */
/*                                                            */
/* When the dialogue box is created it should have a          */
/* list_add_for structure attached as a client handle. This   */
/* contains initial text for the List add dialogue box's      */
/* writeable field.                                           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int breakpoint_to_be_shown(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  list_add_for * attached;

  dprintf(("BrkP", "breakpoint_to_be_shown: Called\n"));

  ChkError(toolbox_get_client_handle(0,
                                     idb->self_id,
                                     (void *) (&attached)));

  dprintf(("BrkP", "breakpoint_to_be_shown: Attached list_add_for is at &%08X\n", (unsigned int) attached));

  if (attached != NULL)
  {
    ChkError(breakpoint_set_up(idb->self_id, attached));

    /* Watch the parent... */

    ChkError(event_register_toolbox_handler(attached->parent,
                                            attached->parent_hide_event,
                                            breakpoint_parent_hidden,
                                            (void *) idb->self_id));
  }

  dprintf(("BrkP", "breakpoint_to_be_shown: Successful\n"));

  return 0;
}

/**************************************************************/
/* breakpoint_hidden()                                        */
/*                                                            */
/* Called when the List add dialogue box is hidden.           */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int breakpoint_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  list_add_for * attached;

  dprintf(("BrkP", "breakpoint_hidden: Called\n"));

  ChkError(toolbox_get_client_handle(0,
                                     idb->self_id,
                                     (void *) (&attached)));

  dprintf(("BrkP", "breakpoint_hidden: Attached list_add_for is at &%08X\n", (unsigned int) attached));

  if (attached != NULL)
  {
    /* Remove our watch on the parent */

    ChkError(event_deregister_toolbox_handler(attached->parent,
                                              attached->parent_hide_event,
                                              breakpoint_parent_hidden,
                                              (void *) idb->self_id));

    /* Free the attached list_add_for structure */

    free(attached);
    ChkError(toolbox_set_client_handle(0, idb->self_id, NULL));
  }

  dprintf(("BrkP", "breakpoint_hidden: Self-destructing\n"));

  ChkError(toolbox_delete_object(0, idb->self_id));

  dprintf(("BrkP", "breakpoint_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* breakpoint_parent_hidden()                                 */
/*                                                            */
/* Called when the List add dialogue box's parent is hidden.  */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/* The 'handle' parameter should hold the object ID of the    */
/* List add dialogue box itself, since this event handler is  */
/* called on the parent, not on the List add dialogue box.    */
/**************************************************************/

static int breakpoint_parent_hidden(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  ObjectId self = (ObjectId) handle;

  dprintf(("BrkP", "breakpoint_parent_hidden: Called with self_id = &%08X\n", (unsigned int) self));

  /* Hide ourselves; the hidden handler does the rest */

  ChkError(toolbox_hide_object(0, self));

  dprintf(("BrkP", "breakpoint_parent_hidden: Successful\n"));

  return 0;
}

/**************************************************************/
/* breakpoint_add()                                           */
/*                                                            */
/* Called when Add is activated for the List add dialogue     */
/* box.                                                       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int breakpoint_add(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  list_add_for * attached;
  char           field[Limits_List_Item];
  const char   * tag;
  ComponentId    selected, readfrom;
  size_t         len;

  dprintf(("BrkP", "breakpoint_add: Called\n"));

  /* Need to know what radio button is selected, whatever happens */

  ChkError(radiobutton_get_state(0,
                                 idb->self_id,
                                 Breakpoint_CID_Function, /* Not interested in this one of course... */
                                 NULL,
                                 &selected)); /* ...That's what we really want */

  /* If this is a keyboard shortcut, make life easier for the user; act as */
  /* if the relevant radio is selected depending upon where the caret is   */

  if (idb->self_component == NULL_ComponentId)
  {
    WimpGetCaretPositionBlock caret;
    int                       handle;

    /* This is hellagrim. Why can't the Toolbox just tell me where the */
    /* blimmin' caret is? Sigh.                                        */

    ChkError(wimp_get_caret_position(&caret));
    ChkError(window_get_wimp_handle(0, idb->self_id, &handle));

    if (handle == caret.window_handle && caret.icon_handle >= 0)
    {
      ObjectId    o_in;
      ComponentId c_in;

      ChkError(window_wimp_to_toolbox(0,
                                      caret.window_handle,
                                      caret.icon_handle,
                                      &o_in,
                                      &c_in));

      /* Since we've confirmed the window handles are the same, the object IDs */
      /* should not differ unless it's All Gone Horribly Wrong.                */

      if (o_in != idb->self_id)
      {
        ChkError(errors_frontend_error(fee_should_never_happen,
                                       "Toolbox->Wimp disagreed with Wimp->Toolbox",
                                       "breakpoint_add"));
      }

      switch (c_in)
      {
        case Breakpoint_CID_MainWriteable:
        {
          if (
               selected != Breakpoint_CID_Function &&
               selected != Breakpoint_CID_Address  &&
               selected != Breakpoint_CID_SWI      &&
               selected != Breakpoint_CID_Line
             )
          {
            /* Oh dear; we're in the top writeable but none of its radios are selected. */
            /* It's actually bad GUI design - writeables ought to grey out if the radio */
            /* isn't selected - but that has problems. The Toolbox first sends the      */
            /* deselect event then the select one, so you temporarily have all fields   */
            /* greyed and lose the caret. I attempted several workarounds and was       */
            /* fought by the Toolbox every step of the way as usual, and I eventually   */
            /* gave up. History lesson ends.                                            */

            ChkError(errors_frontend_error(fee_do_not_be_a_muppet));
          }
        }
        break;

        case Breakpoint_CID_ServiceCallWriteable: selected = Breakpoint_CID_ServiceCallRadio; break;
        case Breakpoint_CID_UpCallWriteable:      selected = Breakpoint_CID_UpCallRadio;      break;

        default:
        {
          ChkError(errors_frontend_error(fee_invalid_parameters,
                                         "breakpoint_add"));
        }
        break;
      }
    }
  }

  /* Work out what to read and what to assemble */

  switch (selected)
  {
    case Breakpoint_CID_Function:         readfrom = Breakpoint_CID_MainWriteable,        tag = Breakpoint_Tag_Function;    break;
    case Breakpoint_CID_Address:          readfrom = Breakpoint_CID_MainWriteable,        tag = Breakpoint_Tag_Address;     break;
    case Breakpoint_CID_SWI:              readfrom = Breakpoint_CID_MainWriteable,        tag = Breakpoint_Tag_SWI;         break;
    case Breakpoint_CID_Line:             readfrom = Breakpoint_CID_MainWriteable,        tag = Breakpoint_Tag_Line;        break;
    case Breakpoint_CID_WimpEventRadio:   readfrom = Breakpoint_CID_WimpEventDisplay,     tag = Breakpoint_Tag_WimpEvent;   break;
    case Breakpoint_CID_ServiceCallRadio: readfrom = Breakpoint_CID_ServiceCallWriteable, tag = Breakpoint_Tag_ServiceCall; break;
    case Breakpoint_CID_UpCallRadio:      readfrom = Breakpoint_CID_UpCallWriteable,      tag = Breakpoint_Tag_UpCall;      break;

    default:
    {
      ChkError(errors_frontend_error(fee_invalid_parameters,
                                     "breakpoint_add"));

      return 0;
    }
    break;
  }

  len = strlen(tag);

  if (len + 1 < sizeof(field))
  {
    /* Read the field */

    if (readfrom == Breakpoint_CID_WimpEventDisplay)
    {
      ChkError(displayfield_get_value(0,
                                      idb->self_id,
                                      readfrom,
                                      field + len,
                                      sizeof(field) - len,
                                      NULL));
    }
    else
    {
      ChkError(writablefield_get_value(0,
                                       idb->self_id,
                                       readfrom,
                                       field + len,
                                       sizeof(field) - len,
                                       NULL));
    }

    field[sizeof(field) - 1] = '\0';

    if (*(field + len) != '\0')
    {
      /* Assemble the full string */

      strncpy(field, tag, len);

      dprintf(("BrkP", "breakpoint_add: Composite text is '%s'\n", field));

      ChkError(toolbox_get_client_handle(0,
                                         idb->self_id,
                                         (void *) (&attached)));

      dprintf(("BrkP", "breakpoint_add: Attached list_add_for is at &%08X\n", (unsigned int) attached));

      if (attached && attached->parent != NULL_ObjectId)
      {
        if (attached->list_item >= 0)
        {
          /* We're open for a specific item in the list, so change its text */
          /* and update the attached list_add_for data                      */

          ChkError(list_modify_item(attached->parent, attached->list_item, field));

          /* The dialogue box may not be closing (e.g. Adjust-click) so make */
          /* sure the initial text record is updated, otherwise a subsequent */
          /* Adjust-click on Cancel would behave strangely.                  */

          StrNCpy0(attached->initial_text, field);
        }
        else
        {
          /* We're open for no specific item, so add to the top */

          ChkError(list_add_item(attached->parent, field));
        }
      }
    }
  }

  /* Should we close the window? (Keyboard shortcut or SELECT pressed) */

  if (idb->self_component == NULL_ComponentId || !adjust())
  {
    dprintf(("BrkP", "breakpoint_add: Closing window\n"));

    utils_restore_focus(idb->self_id);
    ChkError(toolbox_hide_object(0, idb->self_id));
  }

  dprintf(("BrkP", "breakpoint_add: Successful\n"));

  return 0;
}

/**************************************************************/
/* breakpoint_cancel()                                        */
/*                                                            */
/* Called when Cancel is activated for the List add dialogue  */
/* box.                                                       */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int breakpoint_cancel(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  list_add_for * attached;

  dprintf(("BrkP", "breakpoint_cancel: Called\n"));

  ChkError(toolbox_get_client_handle(0,
                                     idb->self_id,
                                     (void *) (&attached)));

  dprintf(("BrkP", "breakpoint_cancel: Attached list_add_for is at &%08X\n", (unsigned int) attached));

  /* Should we close the window? (Keyboard shortcut or SELECT pressed) */

  if (idb->self_component == NULL_ComponentId || !adjust())
  {
    dprintf(("BrkP", "breakpoint_cancel: Closing window\n"));

    utils_restore_focus(idb->self_id);
    ChkError(toolbox_hide_object(0, idb->self_id));
  }
  else
  {
    /* Not closing... Restore original dialogue box contents */

    dprintf(("BrkP", "breakpoint_cancel: Window is not closing, restoring original contents\n"));

    ChkError(breakpoint_set_up(idb->self_id, attached));
  }

  /* Finished */

  dprintf(("BrkP", "breakpoint_cancel: Successful\n"));

  return 0;
}

/**************************************************************/
/* breakpoint_radios()                                        */
/*                                                            */
/* Called when one of the radio buttons in the Breakpoint     */
/* dialogue box changes state.                                */
/*                                                            */
/* Parameters are as standard for a Toolbox event handler.    */
/**************************************************************/

int breakpoint_radios(int eventcode, ToolboxEvent * event, IdBlock * idb, void * handle)
{
  int state;

  dprintf(("BrkP", "breakpoint_radios: Called\n"));

  /* Is this a selection? */

  ChkError(radiobutton_get_state(0,
                                 idb->self_id,
                                 idb->self_component,
                                 &state,
                                 NULL));

  if (state != 0)
  {
    unsigned int flags;
    ComponentId  focus = NULL_ComponentId;

    /* Can't select a greyed item - but that really should never happen */

    ChkError(gadget_get_flags(0,
                              idb->self_id,
                              idb->self_component,
                              &flags));

    if ((flags & Gadget_Faded) != 0) ChkError(errors_frontend_error(fee_should_never_happen,
                                                                    "disabled item was selected",
                                                                    "breakpoint_radios"));

    switch (idb->self_component)
    {
      default:
      {
        ChkError(errors_frontend_error(fee_invalid_parameters,
                                       "breakpoint_radios"));
      }
      break;

      case Breakpoint_CID_WimpEventRadio:
      break;

      case Breakpoint_CID_Function:
      case Breakpoint_CID_Address:
      case Breakpoint_CID_SWI:
      case Breakpoint_CID_Line:             focus = Breakpoint_CID_MainWriteable;        break;
      case Breakpoint_CID_ServiceCallRadio: focus = Breakpoint_CID_ServiceCallWriteable; break;
      case Breakpoint_CID_UpCallRadio:      focus = Breakpoint_CID_UpCallWriteable;      break;
    }

    if (focus != NULL_ComponentId) ChkError(utils_place_focus(idb->self_id, focus));
  }

  /* Finished */

  dprintf(("BrkP", "breakpoint_radios: Successful\n"));

  return 0;
}
