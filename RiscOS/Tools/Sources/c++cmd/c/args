/* File:    args.c
   Purpose: Process command line arguments
   Author:  Ben Laughton, Unknown

   Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.

   History:

   1998-08-15: BAL
   Created based on old code.
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Local */
#include "args.h"
#include "cplusplus.h"
#include "help.h"




/* =============================================================================
 * Global variable definitions
 */

int     f_flag = 0;
int     j_flag = 0;
int     l_flag = 0;
int     c_flag = 0;
int     s_flag = 0;
int     no_cc = 0;
int     no_cfront = 0;
int     ansi = 0;
char    lib_list[CLI_LEN];
char    cpp_args[CLI_LEN];
char    cfront_args[CLI_LEN];
char    cc_args[CLI_LEN];
char    link_args[CLI_LEN];
char *  desktop_dir;




/* =============================================================================
 * Function declarations
 */

static void  process_translator_args (char *  arg,
                                      char *  cfront_args,
                                      char *  cc_args,
                                      char *  link_args);

static char **  process_non_translator_args (char **  argv,
                                             char *   arg,
                                             char *   cpp_args,
                                             char *   cc_args);

static void  process_file_args (char *  arg);

static void  swap_leaf_and_extension (char *const   filename);

static void  help (void);




/* =============================================================================
 * Function definitions
 */

/* -----------------------------------------------------------------------------
   process_args

   Process arguments prefixed with '+'.

   Inputs
   char *       argv[]      : command line arguments
   char *const  cpp_args    : C preprocessor arguments
   char *const  cfront_args : CFront translator arguments
   char *const  cc_args     : C compiler arguments
   char *const  link_args   : Linker arguments
 */

void  process_args (char *       argv[],
                    char *const  cpp_args,
                    char *const  cfront_args,
                    char *const  cc_args,
                    char *const  link_args)
{
    char *   arg;
    int      number_files = 0;

    strcpy (cpp_args,
            "cc -C++ -D__cplusplus -E ");

    strcpy (cfront_args,
            "cfront <");

    strcat (cfront_args,
            cpp_output);

    strcpy (cc_args,
            "cc -C++ -c");

    strcpy (link_args,
            "link -c++");

    strcpy (lib_list,
            "");

    while ((arg = *++argv) != NULL)
    {
        switch (arg[0])
        {
            case '+':
                process_translator_args (arg,
                                         cfront_args,
                                         cc_args,
                                         link_args);
                break;

            case '-':
                argv = process_non_translator_args (argv,
                                                    arg,
                                                    cpp_args,
                                                    cc_args);
                break;

            default:
                number_files++;
                process_file_args (arg);
        }
    }

    if (number_files == 0)
    {
        error ("No filename specified\n");
    }
}




/* -----------------------------------------------------------------------------
   process_translator_args

   Process arguments prefixed with '+'.

   Inputs
   char *       arg         : pointer to current argument
   char *const  cfront_args : CFront translator arguments
   char *const  cc_args     : C compiler arguments
   char *const  link_args   : Linker arguments
 */

static void  process_translator_args (char *       arg,
                                      char *const  cfront_args,
                                      char *const  cc_args,
                                      char *const  link_args)
{
    int  append_arg = 1;

    switch (arg[1])
    {
        case 'v':
            verbose    = 1;
            append_arg = 0;
            break;

        case 'h':
        case 'H':
            help ();
            break;

        case 'f':   /* use label as unique id instead of filename */
            /* appears not to be implemented / documented */
            f_flag = 1;
            break;

        case 'g':
            strcat (cc_args, " -g");
            strcat (link_args, " -d");
            break;

        case 'a':    /* control generation of ANSI style code */
            if (arg[2] == '1')
            {
                ansi = 1;
            }
            break;

        case 'L':    /* generate ANSI style #line <n> directive */
            l_flag = 1;
            break;

        default:
            /* Do nothing */
            break;
    }

    if (append_arg)
    {
        strcat (cfront_args, " ");
        strcat (cfront_args, arg);
    }
}




/* -----------------------------------------------------------------------------
   process_non_translator_args

   Process arguments prefixed with '-'.

   Inputs
   char **       argv     : pointer to unprocessed command line arguments
   char *        arg      : pointer to current argument
   char *const   cpp_args : C preprocessor arguments
   char *const   cc_args  : C compiler arguments

   Returns  char **
   Pointer to remaining command line arguments
 */

static char **  process_non_translator_args (char **       argv,
                                             char *        arg,
                                             char *const   cpp_args,
                                             char *const   cc_args)
{
    /* Process 'long' command line arguments */

    if (cistrcmp (arg,
                  "-desktop") == 0)
    {
        arg = *++argv;
        if (!arg)
        {
            error ("No filename on '-Desktop' option");
        }
        desktop_dir = arg;
    }
    else if (cistrcmp (arg,
                       "-throwback") == 0)
    {
        strcat (cpp_args,
                " -throwback");

        strcat (cfront_args,
                " +throwback");

        strcat (cc_args,
                " -throwback");
    }
    else if (cistrcmp (arg,
                       "-depend") == 0)
    {
        arg = *++argv;
        if  (!arg)
        {
            error ("No filename on '-Depend' option");
        }
        strcat (cpp_args,
                " -Depend ");

        strcat (cpp_args,
                arg);
    }
    else
    {
        /* Process arguments that can be abbreviated to a single letter */

        char *  append_args = NULL;
        char *  append_args_2 = NULL;

        switch (arg[1])
        {
            case 'h':
            case 'H':
                help ();
                break;

            case 'F':    /* send CFront output to stdout, do not compile it */
                no_cc = 1;
                break;

            case 'C':    /* keep comments */
            case 'D':    /* define */
            case 'I':    /* include */
            case 'U':    /* undefine */
                append_args = cpp_args;
                break;

            case 'J':    /* default path */
                j_flag = 1;
                append_args = cpp_args;
                break;

            case 'E':    /* preprocess only */
                no_cfront = 1;
                append_args = cpp_args;
                break;

            case 'l':
            case 'L':    /* libraries */
            {
                char    c;
                char *  s;

                strcat (lib_list,
                        " ");

                s = lib_list + strlen (lib_list);
                arg += 2;

                /* Ensure list of libraries is space separated, not comma
                 * separated.
                 */
                while ((c = *arg++) != 0)
                {
                    if (c == ',')
                    {
                        c = ' ';
                    }
                    *s++ = c;
                }
                *s = 0;
                break;
            }

            case 's':
            case 'S':    /* assembler */
                s_flag = 1;
                append_args = cc_args;
                break;

            case 'o':    /* output file */
                arg = *++argv;
                if (!arg)
                {
                    error ("No filename on '-o' flag\n");
                }
                output_filename = arg;
                break;

            case 'c':    /* compile only */
                c_flag = 1;
                break;

            case 'w':
	    case 'W':    /* warning suppression */
	    case 'e':    /* error suppression */
	        append_args = cc_args;
	        append_args_2 = cpp_args;
	        break;

            case 'M':    /* dependencies only */
                no_cfront = 1;
                append_args = cc_args;
                break;

            default:
                append_args = cc_args;
                break;
        }

        if (append_args)
        {
            strcat (append_args,
                    " ");

            strcat (append_args,
                    arg);
        }

        if (append_args_2)
        {
            strcat (append_args_2,
                    " ");

            strcat (append_args_2,
                    arg);
        }
    }

    return argv;
}




/* -----------------------------------------------------------------------------
   process_file_args

   Process filename arguments.

   Inputs
   char *  arg : argument to process
 */

void  process_file_args (char *  arg)
{
    char *   leaf;
    FName *  nfile;

    nfiles++;
    nfile = malloc (sizeof (FName));
    if (!nfile)
    {
        error ("Out of memory");
    }
    *pfname_list = nfile;
    nfile->next  = NULL;
    pfname_list  = &(nfile->next);
    swap_leaf_and_extension (arg);

    nfile->filename = arg;
    leaf            = find_leaf (arg);
    if (leaf == arg)
    {
        /* File does not have an extension, so assume C++. */

        nfile->filename = malloc (sizeof ("c++.") - 1 + strlen (arg) + 1);
        if (nfile->filename == NULL)
        {
            error ("Out of memory");
        }
        strcpy (nfile->filename,
                "c++.");

        strcat (nfile->filename,
                leaf);
    }
}




/* -----------------------------------------------------------------------------
   swap_leaf_and_extension

   Convert a filename of the form [<path>.]<leaf>.<extension> to the RISC OS
   form [<path>.]<extension>.<leaf> (e.g. "MyProgs:tests.helloworld.c++" would
   become "MyProgs:tests.c++.helloworld).

   Inputs
   char * filename : filename to convert
 */

static void  swap_leaf_and_extension (char *const   filename)
{
    char *  extension;
    char *  leaf;

    find_leaf_and_extension (filename,
                             &leaf,
                             &extension);

    if (extension)
    {
        Extension *  e;

        for (e = extensions; e->name; e++)
        {
            if (cistrcmp (e->name,
                          extension) == 0)
            {
                size_t  extension_len = strlen (extension);

                /* Point after last char of leaf */
                char *  source        = extension - 1;

                /* Point after last char of extension */
                char *  dest          = extension + extension_len;

                /* Copy leaf to end of filename (this will overwrite extension).
                 */
                do
                {
                    *--dest = *--source;
                } while (source > leaf);

                /* Write the directory separator before the leaf */
                *dest = '.';

                /* Write the extension where the leaf orginally was */
                memcpy (leaf,
                        e,
                        extension_len);

                break;
            }
        }
    }
}




/* -----------------------------------------------------------------------------
   help

   Display the help text and exit.
 */

static void  help (void)
{
    fputs (help_string, stderr);
    exit (EXIT_SUCCESS);
}
