/************************************************************************/
/* File:    filecrc.c                                                   */
/* Purpose: The main code for the FileCRC applcation.                   */
/*                                                                      */
/* Author:  David Cotton <mailto:dcotton@e-14.com>                      */
/* History: 0.01  Pre 1999-02-16                                        */
/*                Created.                                              */
/*          0.02  1999-02-16                                            */
/*                Altered to generally improve it and tidy things up.   */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "kernel.h"
#include "swis.h"
#include "os.h"

#include "CRC.h"
#include "Display.h"
#include "FileCRC.h"

#include "DBUG.h"
#include "types.h"

#ifdef DEBUGLIB
#include "Debuglib/Debuglib.h"
#endif /* DEBUGLIB */

#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif /* MemCheck_MEMCHECK */

#define OK              0
#define Failed          1
#define InvalidOps      17
#define FileError       19

#define No              0
#define Yes             1
#define SCREENWIDTH     36
#define MAXIGNORE       10


#ifdef DEBUGLIB
  const int DebugOutputDevice = FILE_OUTPUT;
#endif /* DEBUGLIB */




char cmpfbuf[1200];
char iline[1200];
char **ignfile;
int  errors = 0;
int cmos_rbit = 3;
int cmos_rbits[] = {3, 4, 5};
int cmos_sbit = 11;
int cmos_sbits[] = {11, 12, 13};
int mangle_cmos = No;
int max_report_errors = 20;
int quiet = No;
BOOL printinfo = TRUE;
char FileCRCStatus[] = "FileCRC$Status";
char *namebuf;

struct _dirptr
{
  char *dir;
  char *cmp;
  char *ign[MAXIGNORE+1];
  struct _dirptr *next;
};

struct _dirptr *dirptr = NULL;
struct _dirptr *cdirptr = NULL;




/* Forward definitions */
char* get_filename_from_entry(char* entry);
BOOL validate_checkfile(char* filename, char* path);
BOOL file_exists(char* filename);
void display_help_information(void);
void tidy_memory(void);




/*********************************************************************************/
/* crcfile                                                                       */
/*                                                                               */
/* This routine CRC's the passed file.                                           */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    An integer representing the CRC for that file, or BADCRC if       */
/*              there was an error.                                              */
/*                                                                               */
/*********************************************************************************/
int crcfile( char *filename )
{
  char bigbuf[256*1024];
  int startval = 0;
  int ifile;
  int fpos;
  int flen;
  int tsize;
  _kernel_oserror *fail;

  DBUG_PRINTF(DBUG_LVL_DIAG, "crcfile(): Entry is %s\n", filename);

  if ((fail = _swix( OS_Find, _IN(0)|_IN(1)|_OUT(0), 0x4f, filename, &ifile )) != 0)
              return BADCRC;
      fail = _swix( OS_Args, _IN(0)|_IN(1)|_OUT(2), 2, ifile, &flen );

  for ( fpos=0; fpos<flen && !fail; fpos+=sizeof(bigbuf) )
  {
      tsize = sizeof( bigbuf );
      if ( tsize > flen-fpos ) tsize = flen-fpos;

      fail = _swix( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3), 3, ifile, bigbuf, tsize );
      startval = CRC( startval, bigbuf, tsize );
      /*_swi( OS_CRC, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_OUT(0), startval, bigbuf, bigbuf+tsize, 1, &startval );*/
  }

  _swix( OS_Find, _IN(0)|_IN(1), 0, ifile );

  return fail ? BADCRC : startval;
}




/*********************************************************************************/
/* ignore                                                                        */
/*                                                                               */
/* This routine checks that the filename pased in is not contained within the    */
/*  ignore list.                                                                 */
/*                                                                               */
/* Parameters: name  This is the filename of the file to be checked.             */
/*                                                                               */
/* Returns:    return TRUE if given filename is to be ignored                    */
/*                                                                               */
/*********************************************************************************/
BOOL ignore(char *name)
{
  char **ip;

  DBUG_PRINTF(DBUG_LVL_DIAG, "ignore(): filename is %s\n", name);

  for (ip = ignfile; ip != NULL && *ip != NULL; ++ip)
  {
    if (strcmp(*ip, name) == 0)
    {
      return (TRUE);
    }

  }
  return (FALSE);
}




/*********************************************************************************/
/* truncignore                                                                   */
/*                                                                               */
/* Extract the filename at the start of name, check it with ignore()             */
/*                                                                               */
/* Parameters: name  This is the filename of the file to be checked.             */
/*                                                                               */
/* Returns:    return TRUE if given filename is to be ignored                    */
/*                                                                               */
/*********************************************************************************/
int truncignore(char *name)
{
  char save, *sp;
  int ret;

  DBUG_PRINTF(DBUG_LVL_DIAG, "truncignore(): filename is %s\n", name);

  for (sp = name; *sp && !isspace(*sp); ++sp)
          ;
  save = *sp;
  *sp = '\0';
  ret = ignore(name);
  *sp = save;

  return (ret);
}




/*********************************************************************************/
/* reccheckdir                                                                   */
/*                                                                               */
/* Recursively check directory namebuf and CRC each file found.                  */
/*                                                                               */
/* Parameters: namebuf   The directory to be checked.                            */
/*             namebufp  A memory area to hold responses                         */
/*             cmpfi     The file handle to recieve input from.                  */
/*             cmpfo     The file handle to be output to.                        */
/*             withcrc   Whether the files are to be CRC'd or not.               */
/*                                                                               */
/* Returns:    return TRUE if given filename is to be ignored                    */
/*                                                                               */
/*********************************************************************************/
void reccheckdir(
    char *namebuf,
    char *namebufp,
    char *cmps,
    FILE *cmpfi,
    FILE *cmpfo,
    BOOL withcrc
)
{
  int pos = 0;
  int numread;
  int ft;
  char resbuf[1024];
  char *resp;
  int i;
  int buffered = No;
  _kernel_oserror *fail;
  char *error_string;
  char *print_string;

  DBUG_PRINTF(DBUG_LVL_DIAG, "reccheckdir(): namebuf is %s, withcrc=%d\n", namebuf, withcrc);

  do
  {
    /* get several entries from the current directory level */
    fail = _swix( OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|_OUT(3)|_OUT(4),
                 10, namebuf, resbuf, sizeof(resbuf), pos, sizeof( resbuf ), "*",
                  &numread, &pos );
    if (fail != 0)
    {
      Report((os_error *)fail);
      fatal("Unexpected error",Failed);
    }

    /* go through all the entries in this response block */
    resp = &resbuf[0];
    for ( i=0; i<numread; i++ )
    {
        sprintf( namebufp, ".%s", &resp[20] );

        /* make a string from the contents of the response block for this entry */
        ft = *(int *)&resp[16];
        if ( withcrc && (ft&1) )
        {
            sprintf( cmpfbuf, "%s %08X %08X %X %02X %d %04X\n",
                cmps, *(int *)&resp[0], *(int *)&resp[4], *(int *)&resp[8],
                                    *(int *)&resp[12], ft,
                crcfile( namebuf ) );
        }
        else
        {
            sprintf( cmpfbuf, "%s %08X %08X %X %02X %d\n",
                cmps, *(int *)&resp[0], *(int *)&resp[4], *(int *)&resp[8],
                                    *(int *)&resp[12], ft );
        }

        /* If we're creating the CRC file, check the ignore list for files that may
         * be uncheckable (such as the CRC file itself). Note that any such files
         * must exist, but the CRC and file info will be ignored.
         * The ignore list filenames are relative to the root directory of the file list.
         */
        if ( cmpfo )
        {
          if (ignore(cmps))
          {
            sprintf( cmpfbuf, "%s %08X *IGNORE\n",cmps, *(int *)&resp[0]);
          }
          DBUG_PRINTF(DBUG_LVL_DIAG, "reccheckdir(): Creating entry for file %s", cmpfbuf);
          fprintf( cmpfo, "%s", cmpfbuf );
        }

        /* If we're checking the CRC file and there's an error, ignore any differences
         * after the token '*IGNORE' on that entry in the CRC file, as written for
         * the CRC file itself above.
         */
        if ( cmpfi )
        {
          while (buffered || (fgets( iline, sizeof( iline ), cmpfi ) != NULL))
          {
            buffered = No;
            if ( strcmp( iline, cmpfbuf ) == 0 )
            {
              DBUG_PRINTF(DBUG_LVL_DIAG, "reccheckdir(): %s matches %s. Compares ok.\n", iline, cmpfbuf);
              break; /* Compares OK */
            }
            else
            {
              char *p, *q;
              DBUG_PRINTF(DBUG_LVL_DIAG, "reccheckdir(): %s does not match %s.\n", iline, cmpfbuf);

              for (p = iline, q = cmpfbuf; *p == *q; ++p,++q)
                      ;
              if (strncmp(p,"*IGNORE",6) == 0)
              {
                /* IGNORE entry exists in cmpfile : just ignore the error */
                break;
              }

              else if (ignore(cmps))
              {
                /* Disk file is in commandline ignore list - skip it,
                   leaving the cmpfile entry ready for next comparison
                */
                buffered = Yes;
                break;
              }

              else if (*iline == '#' || truncignore(iline))
              {
                /* Cmpfile entry is a comment or in the ignore list -
                   skip it, leaving the disc entry ready for next comparison
                */
                continue;
              }

              else
              {
                /* There's a problem - report it */
                error_string = (char *) dbg_malloc (512);
                if (!error_string)
                {
                  fatal ("Could not claim space", 1);
                }
//                trunc_message (namebuf);
                if (printinfo == TRUE)
                {
                  if (compare_tokens (iline, cmpfbuf, error_string) == E_CRC_MISMATCH_FILENAMES)
                  {
                    DBUG_PRINTF(DBUG_LVL_DIAG, "reccheckdir(): Filenames in entry did not match. Move to the next line in the file.\n");
                    failure (error_string);
                  }
                  else
                  {
                    print_string = (char *) dbg_malloc (128);
                    if (!print_string)
                    {
                      fatal ("Could not claim space", 1);
                    }
                    failure (error_string);

                    print_string = strtok (error_string, "\n");
                    while (print_string != NULL)
                    {
                      failure (print_string);
                      print_string = strtok (NULL, "\n");
                    }
                    dbg_free (print_string);
                  }

                }
                dbg_free (error_string);

                if (++errors > max_report_errors)
                {
                  fatal("CRC check failed", Failed);
                }
                break;
              }
            }
          } /* end while */
        } /* end if cmpfi */

        /* Recurse if the present entry is a directory */

        if ( ft == 2 )
        {
          reccheckdir( namebuf, namebufp+strlen(namebufp), cmps, cmpfi, cmpfo, withcrc );
        }

        /* find the next entry in the directory buffer */

        resp = &resp[20] + strlen( &resp[20] ) + 1 + 3;
        resp = (char *)((int)resp & ~3 );
        namebufp[0]='\0';
    }
  } while ( pos!=-1 );
}




/*********************************************************************************/
/* set_var_val                                                                   */
/*                                                                               */
/* This routine sets a system variable 'name' to string 'value', or destroy it   */
/*  if 'value' is NULL                                                           */
/*                                                                               */
/* Parameters: name      The name of the system variable to be set.              */
/*             value     The value for it to be set to.                          */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void set_var_val(char *name, char *value)
{
  _swix( OS_SetVarVal, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4), name, value, value ? strlen(value)+1 : -1, 0, 0);
}




/*********************************************************************************/
/* gstrans                                                                       */
/*                                                                               */
/* This routine gstrans's the passed argument vector.                            */
/* Please use this routine wirh care; it is very careless about allocating       */
/*  memory.                                                                      */
/*                                                                               */
/* Parameters: argv      A pointer to the argument vector to be gstrans'ed.      */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void gstrans(char *argv[])
{
  os_regset r;
  char buf[512], *p;

  DBUG_PRINTF(DBUG_LVL_DIAG, "gstrans()\n");

  while (*++argv != NULL)
  {
        r.r[0] = (int)*argv;
        r.r[1] = (int)buf;
        r.r[2] = sizeof(buf)-1;
        assert(os_swix(OS_GSTrans, &r) == 0);
        if (r.r[2] >= sizeof(buf) || (p = dbg_malloc(strlen(buf)+1)) == NULL)
        {
          continue;
        }
        *argv = p;
        buf[r.r[2]] = '\0';
        strcpy(p,buf);
  }
}




/*********************************************************************************/
/* diradd                                                                        */
/*                                                                               */
/* Add a directory to the directory list.                                        */
/*                                                                               */
/* Parameters: rootdir   The directry to be added to the list.                   */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void diradd(char * rootdir)
{
  struct _dirptr *dp;

  DBUG_PRINTF(DBUG_LVL_DIAG, "diradd()\n");

  if ((dp = calloc(1,sizeof(struct _dirptr))) == NULL)
  {
    fatal("No memory left\n", Failed);
  }

  if (dirptr == NULL)
  {
    dirptr = cdirptr = dp;
  }
  else
  {
     cdirptr->next = dp;
     cdirptr = dp;
  }
  dp->dir = rootdir;
}




/*********************************************************************************/
/* fileadd                                                                       */
/*                                                                               */
/* Store a file in the comparison structure.                                     */
/*                                                                               */
/* Parameters: cmpfile   The file to be stored.                                  */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void filadd(char *cmpfile)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "filadd()\n");

  if (dirptr == NULL || cdirptr->cmp != NULL)
  {
    fatal("Need root dir / Can't duplicate CRC file\n", InvalidOps);
  }
  cdirptr->cmp = cmpfile;
}




/*********************************************************************************/
/* skipadd                                                                       */
/*                                                                               */
/* Add a file to the ignore list (i.e. add a file to be skipped)                 */
/*                                                                               */
/* Parameters: skfile    The file to be stored.                                  */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void skipadd(char *skfile)
{
  char **ap;

  DBUG_PRINTF(DBUG_LVL_DIAG, "skipadd()\n");

  if (cdirptr == NULL)
  {
    fatal("Can't add skip file, no root dir\n", InvalidOps);
  }

  for (ap = cdirptr->ign; ap - cdirptr->ign < MAXIGNORE; ++ap)
  {
    if (*ap == NULL)
    {
      *ap = skfile;
      *++ap = NULL;
      return;
    }
  }
  fatal("Too many ignore files in this directory tree\n", InvalidOps);
}




/*********************************************************************************/
/* checkfile                                                                     */
/*                                                                               */
/* This routine performs a CRC check on an individual file instead of a whole    */
/*  directory tree, i.e. same as reccheckdir but operates on a single file only  */
/*                                                                               */
/* Parameters: namebuf   The directory to be checked.                            */
/*             cmpfi     The file handle to recieve input from.                  */
/*             cmpfo     The file handle to be output to.                        */
/*             withcrc   Whether the files are to be CRC'd or not.               */
/*                                                                               */
/* Returns:    Void.                                                             */
/*                                                                               */
/*********************************************************************************/
void checkfile (char *namebuf,
                FILE *cmpfi,
                FILE *cmpfo,
                BOOL withcrc)
{
  _kernel_oserror *e;
  int        objecttype;
  int        loadaddr;
  int        execaddr;
  int        objectlen;
  int        objectattrs;
  int        buffered = No;
  char      *error_string;
  char      *print_string;

  e = _swix (OS_File, _IN (0) | _IN (1) | _OUT (0) | _OUT (2) | _OUT (3) | _OUT (4) | _OUT (5),
            17,
            namebuf,
            &objecttype,
            &loadaddr,
            &execaddr,
            &objectlen,
            &objectattrs);
  if (e)
  {
    Report ((os_error *) e);
    fatal ("Unexpected error", Failed);
  }

  if (objecttype != 1)
  {
    fatal ("The -single flag does not work on directories or image files\n", Failed);
  }

  if (withcrc)
  {
    sprintf (cmpfbuf, "%s %08X %08X %X %02X %d %04X\n", namebuf, loadaddr, execaddr, objectlen, objectattrs, objecttype,
                              crcfile (namebuf));
  }
  else
  {
    sprintf (cmpfbuf, "%s %08X %08X %X %02X %d\n", namebuf, loadaddr, execaddr, objectlen, objectattrs, objecttype);
  }

  if (cmpfo)
  {
    if (ignore (namebuf))
    {
      sprintf (cmpfbuf, "%s %08X *IGNORE\n", namebuf, loadaddr);
    }
    else
    {
      fprintf (cmpfo, "%s", cmpfbuf);
    }
  }

  if ( cmpfi )
  {
    while (buffered || (fgets( iline, sizeof( iline ), cmpfi ) != NULL))
    {
      buffered = No;
      if ( strcmp( iline, cmpfbuf ) == 0 )
      {
        break; /* Compares OK */
      }
      else
      {
        char *p, *q;

        for (p = iline, q = cmpfbuf; *p == *q; ++p,++q)
                ;
        if (strncmp(p,"*IGNORE",6) == 0)
        {
          /* IGNORE entry exists in cmpfile : just ignore the error */
          break;
        }

        else if (ignore(namebuf))
        {
          /* Disk file is in commandline ignore list - skip it,
             leaving the cmpfile entry ready for next comparison
          */
          buffered = Yes;
          break;
        }

        else if (*iline == '#' || truncignore(iline))
        {
          /* Cmpfile entry is a comment or in the ignore list -
             skip it, leaving the disc entry ready for next comparison
          */
          continue;
        }

        else
        {
          /* There's a problem - report it */
          error_string = (char *) dbg_malloc (512);
          if (!error_string)
          {
            fatal ("Could not claim space", 1);
          }
//          trunc_message (namebuf);
          printf("Error with file '%s': ", namebuf);
          if (printinfo == TRUE)
          {
            compare_tokens (iline, cmpfbuf, error_string);
            print_string = (char *) dbg_malloc (128);
            if (!print_string)
            {
              fatal ("Could not claim space", 1);
            }

            print_string = strtok (error_string, "\n");
            while (print_string != NULL)
            {
              failure (print_string);
              print_string = strtok (NULL, "\n");
            }
            dbg_free (print_string);
          }
          dbg_free (error_string);

          if (++errors > max_report_errors)
          {
            fatal("CRC check failed", Failed);
          }
          break;
        }
      }
    }
  }
}




/*********************************************************************************/
/* processignorefile                                                             */
/*                                                                               */
/* Adds filenames specified in the ignore file to the list.                      */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be scanned.         */
/*                                                                               */
/* Returns:    void.                                                             */
/*                                                                               */
/*********************************************************************************/
void processignorefile (char *filename)
{
  FILE *fp;
  char *s;
  char  c;

  fp = fopen (filename, "r");
  if (!fp)
  {
    fatal ("Couldn't find ignore file", Failed);
  }

  s = dbg_malloc (256);
  if (!s)
  {
    fatal ("Couldn't claim memory", Failed);
  }

  s[0] = '\0';

  while (feof (fp) == 0)
  {
    c = fgetc (fp);
    if (c == '\n')
    {
      strncat (s, '\0', 1);
      skipadd (s);
      s[0] = '\0';
    }
    else
    {
      strncat (s, &c, 1);
    }
  }

  fclose (fp);
  dbg_free (s);
}






/*********************************************************************************/
/* compare_tokens                                                                */
/*                                                                               */
/* Description: compares two sets of tokens, returning an error string           */
/*  containing the differences                                                   */
/*                                                                               */
/* Parameters: original   The first token to be compared.                        */
/*             current    The second token to be compared                        */
/*             return_str A pointer ro an area of memory to hold any error       */
/*                         strings produced by the routine.                      */
/*                                                                               */
/* Returns:    An enumnerated integer stating what went wrong inside the routine */
/*              if there was an error.                                           */
/*********************************************************************************/
E_CRC_MISMATCH compare_tokens (char *original,
                               char *current,
                               char *return_str)
{
  char   *load,                                                       /* Declare oodles of chars to play with... */
         *exec,
         *size,
         *access,
         *csum,
         *tmp,
         date_block[5],
         date_str[21],
         *orig_access,
         *curr_access,
         *orig_name,
         *curr_name,
         *tmpstr;

  unsigned int load_value,                                              /* ...and some unsigned ints! */
         exec_value,
         orig_load,
         orig_exec;

  char original_name[100];
  char current_name[100];

  /* Error flag */
   E_CRC_MISMATCH error = E_CRC_MISMATCH_NONE;

  DBUG_PRINTF(DBUG_LVL_DIAG, "compare_tokens()\n");

  tmpstr = dbg_malloc (100);
  if (!tmpstr)
  {
    fatal ("Not enough memory", 1);
  }

  tmpstr[0] = '\0';
  return_str[0] = '\0';

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Read original values
   */
  orig_name = strtok (original, " ");                              /* Original name */
  load      = strtok (NULL, " ");                                  /* Load address of original file */
  exec      = strtok (NULL, " ");                                  /* Execution address of original file */
  size      = strtok (NULL, " ");                                  /* Size of original file */
  access    = strtok (NULL, " ");                                  /* Attributes of original file */
  tmp       = strtok (NULL, " ");
  csum      = strtok (NULL, " ");                                  /* Checksum of original file */

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Read in new values
   */
  curr_name = strtok (current, " ");                               /* Read in name */
  tmp  = strtok (NULL, " ");                                       /* Read in load address */
  orig_load  = (unsigned int) strtoul (load, NULL, 16);
  load_value = (unsigned int) strtoul (tmp, NULL, 16);
  tmp  = strtok (NULL, " ");                                       /* Read in execution address */
  orig_exec  = (unsigned int) strtoul (exec, NULL, 16);
  exec_value = (unsigned int) strtoul (tmp, NULL, 16);

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Check if the name strings are the same.
   */
  orig_name='\0';
  strcpy(original_name, original);
  orig_name=" ";
  DBUG_PRINTF(DBUG_LVL_DIAG, "compare_tokens(): Original name was '%s'\n", original_name);

  curr_name='\0';
  strcpy(current_name, current);
  curr_name=" ";
  DBUG_PRINTF(DBUG_LVL_DIAG, "compare_tokens(): Current name is   '%s'\n", current_name);

  if (strcmp(original_name, current_name) != 0) /* The strings do not match; two seperate files */
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "compare_tokens(): Two different files.\n");
    sprintf (return_str, "File '%s' inconsistent with '%s'.", original_name, current_name);
    strncat (return_str, tmpstr, strlen (tmpstr));
    return(E_CRC_MISMATCH_FILENAMES); /* Return early; if the files are different, the other things are not likely to match. */
  }

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Check to see if the execution addresses are the same
   */
  if (strcmp (exec, tmp) != 0)                                  /* Do the execution addresses differ */
  {
    /* Check to see whether we have a load/exec address pair or a date stamp by looking at the top 12 bits
       of the the load address.  If the bits are set to 0xfff then it's a date stamp (PRM 2-14) */
    if ((((orig_load >> 24) & 0xff) == 0xff) && (((orig_load >> 20) & 0xf) == 0xf))
    {
      date_block[0] = orig_exec & 0xff;                         /* Build up 5 byte date block */
      date_block[1] = (orig_exec >> 8) & 0xff;
      date_block[2] = (orig_exec >> 16) & 0xff;
      date_block[3] = (orig_exec >> 24) & 0xff;
      date_block[4] = orig_load & 0xff;
      _swix (OS_ConvertDateAndTime, _IN (0) | _IN (1) | _IN (2) | _IN (3), (int) date_block,
                                         &date_str,
                                         sizeof (date_str),
                                         (int) "%24:%mi:%se %dy %m3 %ce%yr");
      strncat (tmpstr, "T/D  S/B '", 11);
      strncat (tmpstr, date_str, sizeof (date_str));
      date_block[0] = exec_value & 0xff;
      date_block[1] = (exec_value >> 8) & 0xff;
      date_block[2] = (exec_value >> 16) & 0xff;
      date_block[3] = (exec_value >> 24) & 0xff;
      date_block[4] = load_value & 0xff;
      _swix (OS_ConvertDateAndTime, _IN (0) | _IN (1) | _IN (2) | _IN (3), (int) date_block,
                                         &date_str,
                                         sizeof (date_str),
                                         (int) "%24:%mi:%se %dy %m3 %ce%yr");
      strncat (tmpstr, "' Got '", 8);
      strncat (tmpstr, date_str, sizeof (date_str));
      strncat (tmpstr, "'\n", 3);
      strncat (return_str, tmpstr, strlen (tmpstr));
    }
    else                                                        /* If it's not a date stamp then print the */
    {                                                           /* load/exec addresses */
      sprintf (tmpstr, "S/B '&%08X &%08X' Got '&%08X &%08X'\n",
           orig_load, orig_exec,
           load_value, exec_value);
      strncat (return_str, tmpstr, strlen (tmpstr));
    }
  }

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Check to see if the file sizes are the same
   */
  tmp  = strtok (NULL, " ");                                    /* Read in size of file */
  if (strcmp (size, tmp) != 0)                                  /* Check to see if the sizes are different */
  {
    sprintf (tmpstr, "Size S/B '%d bytes' Got '%d bytes'\n",
         (int) strtol (size, NULL, 16),
         (int) strtol (tmp, NULL, 16));
    strncat (return_str, tmpstr, strlen (tmpstr));
  }

  /* ----------------------------------------------------------------------------------------------------------------
   *
   *      Check to see if the file attributes are the same
   */
  tmp  = strtok (NULL, " ");                                    /* Read in the attributes of the file */
  if (strcmp (access, tmp) != 0)                                /* Are the attributes different? */
  {
    orig_access = (char *) dbg_malloc (10);                         /* Claim space for our access strings */
    curr_access = (char *) dbg_malloc (10);
    if (!orig_access || !curr_access)
    {
      fatal ("Could not claim space", 1);                       /* Reporting an error if not possible */
    }
    calc_access ((int) strtol (access, NULL, 16), orig_access);
    calc_access ((int) strtol (tmp, NULL, 16), curr_access);

    sprintf (tmpstr, "Acc  S/B '%s' Got '%s'\n",                /* If so, print... */
         orig_access,                                           /* ...the correct ones...*/
         curr_access);                                          /* ...and the incorrect ones */
    dbg_free (orig_access);                                     /* free the claimed space */
    dbg_free (curr_access);
    strncat (return_str, tmpstr, strlen (tmpstr));
  }
  tmp  = strtok (NULL, " ");

/* ----------------------------------------------------------------------------------------------------------------
 *
 *      Check to see if the checksums are the same
 */
  tmp  = strtok (NULL, " ");                                    /* Read in the checksum of the file */
  if (strcmp (csum, tmp) != 0)                                  /* Are the checksums different? */
  {
    sprintf (tmpstr, "C/S  S/B '&%04X' Got '&%04X'\n",          /* If so, print... */
         (int) strtol (csum, NULL, 16),                         /* ...the correct checksum... */
         (int) strtol (tmp, NULL, 16));                         /* ...and the incorrect checksum */
     strncat (return_str, tmpstr, strlen (tmpstr));
  }

  dbg_free (tmpstr);

  return (error);
}





/*********************************************************************************/
/* calc_access                                                                   */
/*                                                                               */
/* calculate the access permissions from a given decimal number.                 */
/*                                                                               */
/* Parameters: int access. An integer representing the acess rights              */
/*             access_str. A pointer to be filled by the access string           */
/*                          coresponding to the integer value passed in.         */
/*                                                                               */
/* Returns:    Nothing.                                                          */
/*                                                                               */
/*********************************************************************************/
void calc_access (int access, char *access_str)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "get_filename_from_entry()\n");

  access_str[0] = '\0';
  if ((access & (1 << 3)) > 0)                                  /* File locked bit */
  {
    strncat (access_str, "L", 1);
  }
  if ((access & (1 << 1)) > 0)                                  /* Owner write bit */
  {
    strncat (access_str, "W", 1);
  }
  if ((access & (1 << 0)) > 0)                                  /* Owner read bit */
  {
    strncat (access_str, "R", 1);
  }
  strncat (access_str, "/", 1);                                 /* Owner/public seperator */
  if ((access & (1 << 5)) > 0)                                  /* Public write bit */
  {
    strncat (access_str, "w", 1);
  }
  if ((access & (1 << 4)) > 0)                                  /* Public read bit */
  {
    strncat (access_str, "r", 1);
  }
  strncat (access_str, "\0", 1);
}




/*********************************************************************************/
/* get_filename_from_entry                                                       */
/*                                                                               */
/* This routine strips the filename from a checkfile entry                       */
/*                                                                               */
/* Parameters: entry. The line from which the filename is to be stripped.        */
/*                                                                               */
/* Returns:    A pointer to a memory area containing the filename, or NULL       */
/*              if there was an error.                                           */
/*                                                                               */
/*********************************************************************************/
char* get_filename_from_entry(char* entry)
{
  char* filename;
  char* filename_end;

  DBUG_PRINTF(DBUG_LVL_DIAG, "get_filename_from_entry()\n");

  filename_end = strtok (entry, " ");                              /* Original name */
  filename_end='\0';

  /* Allocate memory for the filename */
  filename = dbg_malloc(strlen(entry)+1);
  if (!filename)
  {
    printf("Error allocating memory for filename string.\n");
    return (NULL);
  }
  strcpy(filename, entry);
  filename_end=" ";
  return(filename);
}




/*********************************************************************************/
/* file_exists                                                                   */
/*                                                                               */
/* This routine checks whether the passed file exists.                           */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    It returns TRUE if the file exists, FALSE otherwise (or if there  */
/*              was an error during the SWI call).                               */
/*                                                                               */
/*********************************************************************************/
BOOL file_exists(char* filename)
{
  _kernel_oserror *err;
  unsigned long int exists;

  DBUG_PRINTF(DBUG_LVL_DIAG, "file_exists()\n");

  err = _swix( OS_File, _IN(0)|_IN(1)|_OUT(0), 5, filename, &exists);
  if (!exists || err) /* File does not exist. */
  {
    return (FALSE);
  }
  return (TRUE);
}




/*********************************************************************************/
/* filer_object_type                                                             */
/*                                                                               */
/* This routine returns the type of the filer object corresponding to the        */
/*  filename passed in.                                                          */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*                                                                               */
/* Returns:    It returns : 0 for no such object                                 */
/*                          1 for a file object                                  */
/*                          2 for a directory object                             */
/*                          3 for an image object                                */
/*                                                                               */
/*********************************************************************************/
unsigned long int filer_object_type(const char* filename)
{
  _kernel_oserror *err;
  unsigned long int object_type = 0;

  DBUG_PRINTF(DBUG_LVL_DIAG, "filer_object_type()\n");

  assert (filename!=NULL);
  err = _swix( OS_File, _IN(0)|_IN(1)|_OUT(0), 5, filename, &object_type);
  if (err)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "filer_object_type(): Error trying to find object type of file '%s'\n", filename);
  }

  return (object_type);
}




/*********************************************************************************/
/* validate_checkfile                                                            */
/*                                                                               */
/* This routine scans through the checkfile and ensures that all files           */
/*  mentioned within it are present in the target directory structure. It        */
/*  does not report extra files in the target directory structure.               */
/*                                                                               */
/* Parameters: filename  This is the filename of the file to be checked.         */
/*             path      The path leading to filename                            */
/*                                                                               */
/* Returns:    It returns TRUE if all the files in the checkfile exist, FALSE    */
/*              otherwise                                                        */
/*                                                                               */
/*********************************************************************************/
BOOL validate_checkfile(char* filename, char* path)
{
  char input_line[1200];
  BOOL return_val = TRUE;
  FILE* istream;

  DBUG_PRINTF(DBUG_LVL_DIAG, "validate_checkfile()\n");

  /* Open the checkfile for reading */
  istream = fopen(filename, "r");
  if (!istream)
  {
    printf("Error opening input file %s for reading.\n", filename);
    exit (EXIT_FAILURE);
  }

  /* Scan through all the files one line at a time and check that the file exists in the target directory structure */
  fgets( input_line, sizeof( input_line ), istream );
  while (!feof(istream))
  {
    /* Print out this line, */
    char* filename = get_filename_from_entry(input_line);
    char* pathname = dbg_malloc(strlen(path)+strlen(filename)+2);
    if (!pathname)
    {
      printf("Error allocating memory for pathname.\n");
    }
    else
    {
      sprintf(pathname, "%s.%s", path, filename);
    }
    /* Ensure that the file exists. */
    if (!file_exists(pathname))
    {
      printf("File %s not present in directory structure.\n", pathname);
      return_val = FALSE;
    }
    fgets( input_line, sizeof( input_line ), istream );
    dbg_free (filename);
    dbg_free (pathname);
  };

  fclose (istream);

  return (return_val);
}






#ifdef PRODUCTION_TEST_BUILD
/* -------------------------------------------------------------------------------------------------------------------
 * Function   : main
 * Description: program entry point
 * In     : int argc
 *        char *argv[]
 * Out    : nothing
 * Returns  : 1
 *
 * Modifications
 * -------------
 * 09 Mar 1998  RLT  Changed the way that the command line options are parsed.  No longer requires
 *           them in a specific order.
 *           The variable namebuf now allocates memory dynamically instead of grabbing
 *           1KBs worth of stack so should be far more stable.
 *           Actually returns a value at the end of the function, 0 for error and 1 for OK.
 * 10 Mar 1998  RLT  Added support for checking a single file via. the -single command line option.
 */
int main (int argc, char *argv[])
{
  int   withcrc     = TRUE;
  BOOL  creatfile   = FALSE;
  BOOL  singlefile  = FALSE;
  int   i;
  char *namebuf;
  FILE *cmpfi;
  FILE *cmpfo;

  atexit(tidy_memory);

#ifdef DEBUGLIB
  debug_initialise ("FileCRC", "<obey$dir>.log", "");
  debug_atexit ();
  debug_output_device (DebugOutputDevice);   /* Output debug info via pdebug */
#endif /* DEBUGLIB */

  namebuf = dbg_malloc (1024);
  if (!namebuf)
  {
    fatal ("Not enough memory to run FileCRC", Failed);
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "main()\n");

  for (i = 1; i <= argc; i++)
  {
    if (argv[i][0] == '-')             /* Is it a switch option? */
    {
      if (strcmp (argv[i], "-crc") == 0)
      {
        withcrc = TRUE;
      }

      if (strcmp (argv[i], "-create") == 0)  /* Create CRC file */
      {
        creatfile = TRUE;
      }

      if (strcmp (argv[i], "-cmos0") == 0)
      {
        mangle_cmos = Yes;
        cmos_rbit   = cmos_rbits[0];
        cmos_sbit   = cmos_sbits[0];
      }

      if (strcmp (argv[i], "-cmos1") == 0)
      {
        mangle_cmos = Yes;
        cmos_rbit   = cmos_rbits[1];
        cmos_sbit   = cmos_sbits[1];
      }

      if (strcmp (argv[i], "-cmos2") == 0)
      {
        mangle_cmos = Yes;
        cmos_rbit   = cmos_rbits[2];
        cmos_sbit   = cmos_sbits[2];
      }

      if (strcmp (argv[i], "-quiet") == 0)
      {
        quiet = Yes;
        max_report_errors = 4;
      }

      if (strcmp (argv[i], "-d") == 0)
      {
        i++;
        diradd (argv[i]);
      }

      if (strcmp (argv[i], "-f") == 0)
      {
        i++;
        filadd (argv[i]);
      }

      if (strcmp (argv[i], "-s") == 0)
      {
        gstrans (argv);
        i++;
        skipadd (argv[i]);
      }

      if (strcmp (argv[i], "-single") == 0)
      {
        singlefile = TRUE;
      }

      if (strcmp (argv[i], "-i") == 0)
      {
        i++;
/*         processignorefile (argv[i]); */
        fatal ("Ignore file switch unavailable", Failed);
      }

      if (strcmp (argv[i], "-p") == 0)
      {
        printinfo = FALSE;
      }
    }
  }

  title ("FILE CRC CHECK (Production Test Build)", "2.21", __DATE__);
  set_var_val (FileCRCStatus, NULL);

  if ((dirptr == NULL) || (creatfile && dirptr -> cmp == NULL))
  {
    fatal ("Usage: FileCRC [-crc] [-create] [-single] [-cmos<0|1|2>] [-quiet] [-d <dirname> [-f <CmpFile>] [-s <IgnoreFile>] ...]\n", InvalidOps);
  }

  for (; dirptr != NULL; dirptr = dirptr -> next)
  {
    ignfile = dirptr -> ign;
    cmpfi   = NULL;
    cmpfo   = stdout;

    progress (cmpfo != NULL ? "Creating CRC file" : "Reading CRC file");

    /* Firstly check through the file and ensure that all the files are present. */
    if (!creatfile && !singlefile)      /* If we are checking files and we have to recurse down a directory tree */
    {
      validate_checkfile(dirptr->cmp, dirptr->dir);
    }

    if (dirptr -> cmp)
    {
      if (creatfile)
      {
        cmpfo = fopen (dirptr -> cmp, "w");
      }
      else
      {
        cmpfi = fopen (dirptr -> cmp, "r");
        cmpfo = NULL;
      }
    }

    if ((cmpfi == NULL) && (cmpfo == NULL))
    {
      fatal (creatfile ? "Cannot create CRC file" : "Cannot read CRC file", FileError);
    }

    sprintf (namebuf, "%s", dirptr -> dir);
    if (singlefile == FALSE)
    {
      reccheckdir (namebuf, namebuf + strlen (namebuf), namebuf + (strlen (namebuf) + 1),
             cmpfi, cmpfo, withcrc);
    }
    else
    {
      checkfile (namebuf, cmpfi, cmpfo, withcrc);
    }

    if (cmpfi)
    {
      fclose (cmpfi);
    }

    if ((cmpfo) && (cmpfo != stdout))
    {
      fclose (cmpfo);
    }
  }

  if (errors)
  {
    if (creatfile) /* Creating a CRC checkfile */
    {
      fatal ("CRC creation failed", Failed);
    }
    else/* Reading a CRC checkfile */
    {
      fatal ("CRC check failed", Failed);
    }
    return 0;
  }
  else
  {
    set_var_val (FileCRCStatus, "OK");
    if (creatfile) /* Creating a CRC checkfile */
    {
      fatal ("CRC creation complete with no errors.", OK);
    }
    else  /* Reading a CRC checkfile */
    {
      fatal ("CRC check complete with no errors.", OK);
    }
  }

  return 1;
}

#else /* Not a PRODUCTION_TEST_BUILD */

/*********************************************************************************/
/* main                                                                          */
/*                                                                               */
/* The main entry point to the program.                                          */
/*                                                                               */
/* Parameters: argc   The count of the number of arguments in the arg list.      */
/*             argv   A vector containing the arguments.                         */
/*                                                                               */
/* Returns:    An integer specifying whether execution was successful or not.    */
/*                                                                               */
/*********************************************************************************/
int main (int argc, char *argv[])
{
  BOOL  withcrc     = TRUE;
  BOOL  creatfile   = FALSE;
  BOOL  singlefile  = FALSE;
  int   i;
  FILE *cmpfi;
  FILE *cmpfo;

#ifdef MemCheck_MEMCHECK
//  MemCheck_InitNoDebug();
  MemCheck_RedirectToFilename("<obey$dir>.MemCheck");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_SetStoreMiscFunctions( 1);	// So that diagnostics tell us which functions malloced each malloc block.
  MemCheck_InterceptSCLStringFunctions();
  atexit(MemCheck_OutputBlocksInfo);
  MemCheck_SetQuitting(1, 1);
  MemCheck_SetAccessQuitting(1, 1);
  MemCheck_RegisterArgs( argc, argv);	// Tell MemCheck that strings in argv[0...argc-1] are ok to read.
#endif // MemCheck_MEMCHECK

#ifdef DEBUGLIB
  debug_initialise ("FileCRC", "<obey$dir>.log", "");
  debug_atexit ();
  debug_output_device (DebugOutputDevice);   /* Output debug info via pdebug */
#endif /* DEBUGLIB */

  namebuf = dbg_malloc (1024);
  if (!namebuf)
  {
    fatal ("Not enough memory to run FileCRC", Failed);
  }

  DBUG_PRINTF(DBUG_LVL_DIAG, "main(): arcg is %d\n", argc);

  for (i = 0; i < argc; i++)
  {
    DBUG_PRINTF(DBUG_LVL_DIAG, "main(): argument %d of %d is %s\n", i, argc, argv[i]);

    if (argv[i][0] == '-')             /* Is it a switch option? */
    {
      if (strcmp (argv[i], "-create") == 0)  /* Create CRC file */
      {
        creatfile = TRUE;
      }

      if (strcmp (argv[i], "-d") == 0)
      {
        i++;
        diradd (argv[i]);
      }

      if (strcmp (argv[i], "-f") == 0)
      {
        i++;
        filadd (argv[i]);
      }

      if (strcmp (argv[i], "-s") == 0)
      {
        gstrans (argv);
        i++;
        skipadd (argv[i]);
      }

      if (strcmp (argv[i], "-h") == 0)
      {
        /* Help information requested. Display it and exit. */
        display_help_information();
        exit(EXIT_SUCCESS);
      }
    }
  }

  title ("FILE CRC CHECK", "2.21", __DATE__);
  set_var_val (FileCRCStatus, NULL);

  /* Check whether we have all the information we need to continue. */
  if ((dirptr == NULL) || (creatfile && dirptr -> cmp == NULL))
  {
    display_help_information();
    exit(EXIT_FAILURE);
  }

  /* Detect if it is a singlefile or a directory */
  if (filer_object_type(dirptr->dir) == 1)
  {
    singlefile = TRUE;
  }

  for (; dirptr != NULL; dirptr = dirptr -> next)
  {
    ignfile = dirptr -> ign;
    cmpfi   = NULL;
    cmpfo   = stdout;

    if (creatfile)
    {
      progress ("Creating CRC file");
    }
    else
    {
      progress ("Reading CRC file");
    }

    /* Firstly check through the file and ensure that all the files are present. */
    if (!creatfile && !singlefile)      /* If we are checking files and we have to recurse down a directory tree */
    {
      validate_checkfile(dirptr->cmp, dirptr->dir);
    }

    if (dirptr -> cmp)
    {
      if (creatfile)
      {
        cmpfo = fopen (dirptr -> cmp, "w");
      }
      else
      {
        cmpfi = fopen (dirptr -> cmp, "r");
        cmpfo = NULL;
      }
    }

    if ((cmpfi == NULL) && (cmpfo == NULL))
    {
      fatal (creatfile ? "Cannot create CRC file" : "Cannot read CRC file", FileError);
    }

    sprintf (namebuf, "%s", dirptr->dir);
    if (singlefile == FALSE)
    {
      reccheckdir (namebuf, namebuf + strlen (namebuf), namebuf + (strlen (namebuf) + 1),
             cmpfi, cmpfo, withcrc);
    }
    else
    {
      checkfile (namebuf, cmpfi, cmpfo, withcrc);
    }

    if (cmpfi)
    {
      fclose (cmpfi);
    }

    if ((cmpfo) && (cmpfo != stdout))
    {
      fclose (cmpfo);
    }
  }

  if (errors)
  {
    if (creatfile) /* Creating a CRC checkfile */
    {
      fatal ("CRC creation failed", Failed);
    }
    else/* Reading a CRC checkfile */
    {
      fatal ("CRC check failed", Failed);
    }
    return 0;
  }
  else
  {
    set_var_val (FileCRCStatus, "OK");
    if (creatfile) /* Creating a CRC checkfile */
    {
      fatal ("CRC creation complete with no errors.", OK);
    }
    else  /* Reading a CRC checkfile */
    {
      fatal ("CRC check complete with no errors.", OK);
    }
  }

  return 1;
}

#endif /* PRODUCTION_TEST_BUILD */





/*********************************************************************************/
/* display_help_information                                                      */
/*                                                                               */
/* This routine displays the help information that can be obtained by using the  */
/*  -h flag or executing the utility with no flags passed.                       */
/*                                                                               */
/* Parameters: void                                                              */
/*                                                                               */
/* Returns:    void                                                              */
/*                                                                               */
/*********************************************************************************/
void display_help_information(void)
{
  printf("Usage: FileCRC [-create] [-h] [-d <dirname> [-f <CmpFile>] [-s <IgnoreFile>] ...]\n");

  printf("-create   Create a CRC file\n");

  printf("-d <directory> the directory to CRC\n");

  printf("-f <CmpFile> the name of the file that is to be created to hold CRC\n");
  printf("           OR the name of the reference file that is used to compare with the CRCs generated.\n");

  printf("-h Display a helpfile.\n");

  printf("-s <IgnoreFile> a list of files that are to be ignored when CRCing a directory.\n");


  printf("\n");
  printf("Example:\n");

  printf("Filecrc -crc -create -d adfs::0.$ -f adfs::4.temp\n");

  printf("Will create a file of CRCs for the directory adfs::0.$. The reference CRC\n");
  printf("file is called temp and stored in adfs::4.$.\n");


  printf("\n");
  printf("Filecrc -crc -d adfs::0.$ -f adfs::4.temp\n");

  printf("Compare CRCs of adfs::0.$ with the contents of adfs::4.$.temp.\n");
  printf("When running it should print Reading CRC file and print nothing else until\n");
  printf("CRC check complete is displayed at the end. Any failures will be displayed\n");
  printf("on the screen.\n");

  printf("\n");
  printf("To use ignore\n");
  printf("Filecrc -crc -create -d adfs::0.$ -f temp -s temp\n");

  printf("Will store reference in adfs::0.$ hence it will need to be ignored.\n");
}





/*********************************************************************************/
/* tidy_memory                                                                   */
/*                                                                               */
/* This routine tidies up all memory. It is registered with atexit()             */
/*                                                                               */
/* Parameters: void.                                                             */
/*                                                                               */
/* Returns:    void.                                                             */
/*                                                                               */
/*********************************************************************************/
void tidy_memory(void)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "tidy_memory()\n");

  /* Free memory */
  if (namebuf)
  {
    dbg_free(namebuf);
  }
}



