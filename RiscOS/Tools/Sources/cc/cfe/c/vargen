/*
 * vargen.c: static initialised variable generator for C compiler
 * Copyright (C) Codemist Ltd, 1988-1992.
 * Copyright (C) Acorn Computers Ltd., 1988-1990.
 * Copyright (C) Advanced RISC Machines Limited, 1991-1992.
 */

/*
 * RCS $Revision$  Codemist 46
 * Checkin $Date$
 * Revising $Author$
 */

/* AM memo: for C++ soon suppress static const's until first &taken.        */
/* AM memo: I do not see how genpointer gets called with a string arg       */
/*   for WR_STR_LITS since it s_string is filtered off by initsubstatic().  */
/*   Bug in WR_STR_LITS in ANSI mode?                                       */
/*   I think the two calls to genpointer need merging -- read ANSI carefully.*/
/* AM memo: see obj_symref @@@ below for more general use?                  */
/* Warning: the vg_copyobj/zeroobj probably depend on structs/arrays being  */
/*   aligned as the compiler currently does to 4 word boundaries.           */
/* AM memo: void values/vars need faulting earlier -- see initsubstatic()   */
/* WGD 28-9-87 ACW support added, 27-3-88 updated                           */
/* 30-Nov-86: vargen now assembles bytes/halfword data initialisations      */
/* into bytes and adds LIT_XXX flags for xxxasm.c, xxxobj.c                 */

/* Discussion:  Observe that generating code in full generality for
   arbitrary open arrays requires two passes - consider (e.g.)
   "char [][] = { "a", "bc",... }".  Moreover ANSI forbid such
   possibly useful initialisations.  So do we, but for reasons of
   producing (type and size) error messages as soon as possible rather
   than after a reading phase.  Accordingly we adopt a coroutine-like
   linkage to syn.c.
*/

#include <string.h>

#include "globals.h"
#include "vargen.h"
#include "lex.h"               /* for curlex */
#include "syn.h"
#include "sem.h"
#include "simplify.h"
#include "bind.h"
#include "builtin.h"
#include "aetree.h"
#include "codebuf.h"
#ifndef NON_CODEMIST_MIDDLE_END
#include "regalloc.h"  /* to handle global register variables */
#endif
#include "mcdep.h"     /* for dbg_xxx */
#include "store.h"
#include "aeops.h"
#include "util.h"      /* for padsize */
#include "xrefs.h"
#include "errors.h"

#define orig_(p)  arg1_(p)
#define compl_(p) arg2_(p)

static int32 initsubstatic(TypeExpr *t, Binder *whole, Designator *designated, bool designate_mode);

static ClassMember *findmember(TypeExpr *t, ClassMember *member)
{   ClassMember *l;
    TagBinder *b = typespectagbind_(t);
    //int32 sort = attributes_(b) & CLASSBITS;

    for (l = tagbindmems_(b);  l != NULL;  l = memcdr_(l))
    {   if (debugging(DEBUG_BIND))
            cc_msg("see $r %lx\n", memsv_(l), (long)attributes_(l));
        if (h0_(member) == s_identifier)
        {   Symstr *sv = (Symstr *)member;
            if (memsv_(l) == sv) return l;
        }
        else if (l == member)
            return l;
    }
    return NULL;
}

/* It is now clear that vg_acton_globreg() should be part of syn.c      */
/* and/or bind.c (see bind_err_conflicting_globalreg below).            */
static void vg_acton_globreg(DeclRhsList *d, Binder *b)
{   VRegnum reg = GAP;
    TypeExpr *t = princtype(bindtype_(b));
    int32 rno = declstgval_(d) >> 1;
#ifndef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
    if (declstgval_(d) & 1)
    {
        if (rno <= 0 || rno > MAXGLOBFLTREG)
            cc_err(vargen_err_overlarge_reg);
        else {
            if ( h0_(t) == s_typespec &&
                 ( typespecmap_(t) & bitoftype_(s_double) ) )
                reg = virtreg(R_FV1+rno-1,
                      typespecmap_(t) & bitoftype_(s_short) ?
                              FLTREG : DBLREG);
            else
                cc_err(vargen_err_not_float);
        }
    }
    else
#endif
    {
        {
            if (0 < rno && rno <= MAXGLOBINTREG)
                reg = virtreg(R_V1+rno-1, INTREG);
#ifdef TARGET_IS_AIH324
/* Prefered form, also prepares for use of a0...d31 etc.                */
            else if (160 <= rno && rno < 160+32)
                reg = virtreg(R_V1 + rno - 160, INTREG);
#endif
            else
                cc_err(vargen_err_overlarge_reg);
            if (reg != GAP) switch (h0_(t)) {
            case t_content:
                break;
            case s_typespec:
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
                if (typespecmap_(t) & bitoftype_(s_double))
                    break;
#endif
                if (typespecmap_(t) & ( bitoftype_(s_char) |
                                        bitoftype_(s_int) |
                                        bitoftype_(s_enum) ))
                    break;
                /* no one_word structs, unions - cg isn't up to the
                   notion that they might be in registers (?) */
                /* @@@AM: it ought to be! */
            default:
                cc_err(vargen_err_not_int);
                reg = GAP;
            }
        }
    }
    if (reg != GAP) {
    /* We have arranged that this binder has room to record a
     * register (though normally only auto binders have).
     */
        if (bindxx_(b) != GAP && bindxx_(b) != reg)
            cc_rerr(bind_err_conflicting_globalreg, b);
        bindxx_(b) = reg;
        globalregistervariable(reg);
    }
}

static bool vg_static_matches(DataInit *a, DataInit *b, int32 size)
{
    while (size > 0)
    {
        while (a && a->sort == LIT_LABEL) a = a->datacdr;
        while (b && b->sort == LIT_LABEL) b = b->datacdr;
        if (!a || !b) return NO;
        if (a->sort != b->sort || a->len != b->len || a->val != b->val)
            return NO;

        if (a->rpt == b->rpt)
        {   if (a->sort == LIT_ADCON || a->sort == LIT_FNCON)
                size -= 4;
            else
                size -= a->len * a->rpt;
            a = a->datacdr;
            b = b->datacdr;
        }
        else if (a->rpt * a->len >= size && b->rpt * b->len >= size)
            break;
        else
            return NO;
    }
    return YES;
}

static Expr *reduce(Expr *e, Binder *whole)
{
    /* a reduced optimise0: expose s_floatcon/s_integer             */
    if (whole &&
        (h0_(e) == s_assign || h0_(e) == s_init) &&
         arg1_(e) == (Expr *)whole)
        return arg2_(e);
    if (h0_(e) == s_invisible && (h0_(compl_(e)) == s_floatcon))
        return compl_(e);
    return e;
}

static Expr *rdinit(TypeExpr *t, Binder *whole, int32 flag)
{
//#ifdef CPLUSPLUS
/* We can't do optimise0() since it removes the cast to break toplevel  */
/*   int x = (int)"abc";  Make C code share this soon.                  */
/* Maybe the right thing to do is optimise0(x = e) for some var 'x'.    */
    Expr *e = syn_rdinit(t, whole, flag);
    if (e) e = reduce(e, whole);
//#else
///* The code for C and C++ has diverged -- share the above code soon.    */
//    Expr *e = syn_rdinit(t, 0, flag);
//    IGNORE(whole);
//    if (e) e = optimise0(e);
//#endif
    if (e && h0_(e) == s_error) e = 0;
    return e;
}

/* @@@ check this routine takes care with padding for wide strings.    */
static int32 genstring(String *s, int32 size)
{   /* the efficiency of this is abysmal. */
    StringSegList *p = s->strseg;
    AEop sort = h0_(s);
    int32 length = stringlength(p)/(sort == s_wstring ? 4 : 1);
    if (size == 0xffffff)
        size = length + 1;
    else if (length > size)
        cc_rerr(vargen_err_long_string, sort==s_wstring ? "wchar_t":"char",
                (long)size);
    else if (length == size)
        cc_warn(vargen_warn_nonull, sort==s_wstring ? "wchar_t":"char",
                (long)size);
    vg_genstring(p, size*(sort == s_wstring ? 4:1), 0);
    return size;
}

void genstaticstring(Binder *b, const char *p)
{   String s; StringSegList ss;
    bindaddr_(b) = datap->size;
    ss.strsegcdr = NULL;
    ss.strsegbase = (char *) p;
    ss.strseglen = strlen(p);
    s.h0 = s_string;
    s.strseg = &ss;
    genstring(&s, ss.strseglen + 1);
    padstatic(alignof_toplevel);
}

static int64 int_of_init0(Expr *init, bool *ok)
{   int64 ival = 0;
    if (init != 0 && *ok)
    {   int32 op = h0_(init);
        if (op == s_integer)
            ival = intval64_(init);
        else
        {
#ifndef PROPER_CODE_TO_SUPPORT_OFFSETOF_IN_STATIC_INITIALISERS
/* AM: It isn't just a case of being sensibly centralised, an attempt    */
/* was made to encourage sem.c only to reduce 'honest' constant exprs,   */
/* like 3.4*2, but not to do algebraic re-arrangement (which simplify.c  */
/* or cg.c are responsible for).  This is partly to enable that correct  */
/* diagnostics are produced (e.g. we do not want (x+0)=3 to become x=3). */
/* The offsetof rules changed and so I believe that sem.c should NOW     */
/* do a little more about these things.  Note the requirement to         */
/* diagnose "static int x = 1 || f();" comes in here!                    */
/*          /* @@@ LDS 27-Mar-90. The following makes offsetof() work in */
            /* static initializer contexts. Oh woe, expression reduction */
            /* isn't sensibly centralised. This must be regarded as an   */
            /* interim bodge of the worst sort, but I don't have time to */
            /* rstructure the tree-reduction part of the compiler.       */
            if (op == s_cast || op == s_plus || op == s_minus)
            {   Expr *a1, *a2;
                if (op == s_cast)
                    a1 = init, a2 = arg1_(init);
                else
                    a1 = arg1_(init), a2 = arg2_(init);
                if ((mcrepofexpr(a1) & ~0x01000000) == sizeof_int &&
                    (mcrepofexpr(a2) & ~0x01000000) == sizeof_int)
                {   ival = int_of_init0(a2, ok);
                    if (op == s_plus)
                        ival = int_of_init0(a1, ok) + ival;
                    if (op == s_minus)
                        ival = int_of_init0(a1, ok) - ival;
                    return ival;
                }
            }
#endif
            *ok = 0;
        }
    }
    return ival;
}

static struct vg_state
{
    bool vg_complain_non_aggregate, vg_initauto;
    TypeExpr *vg_inittype;
    int32 vg_initbsize, vg_initboffset, vg_initwoffset;
    Binder *vg_cur_initlhs;
    int32 vg_cur_initoff, vg_initoff;
    #ifdef CPLUSPLUS
    FileLine vg_init_fl;        /* @@@ not always set just before use! */
    #endif
    struct DynInitList *vg_dyninit_list;
} vg_state;

#define complain_non_aggregate vg_state.vg_complain_non_aggregate
#define initauto               vg_state.vg_initauto
#define inittype               vg_state.vg_inittype
#define initbsize              vg_state.vg_initbsize
#define initboffset            vg_state.vg_initboffset
#define initwoffset            vg_state.vg_initwoffset
#define cur_initlhs            vg_state.vg_cur_initlhs
#define cur_initoff            vg_state.vg_cur_initoff
#define initoff                vg_state.vg_initoff
#define init_fl                vg_state.vg_init_fl
#define dyninit_list           vg_state.vg_dyninit_list
static bool dynamic_init(Expr *e, bool full);
static bool eliminate_dynamic_init(void);
#ifdef CPLUSPLUS
static void vg_note_topdtor(Binder *b, bool toplevel);
#endif
static Expr *vg_get_dyninit(bool toplevel);
static int32 vg_get_dyninit_coverage(int32 start);

static int64 int_of_init(Expr *init)
{   bool ok = YES;
    int64 ival = int_of_init0(init, &ok);
    if (eliminate_dynamic_init()) ok = NO;
    if (!ok)
    {   if (!dynamic_init(init, 0))
            moan_nonconst(init, moan_static_int_type);
    }
    return ival;
}

static FloatCon *float_of_init(Expr *init)
{   FloatCon *fval = fc_zero.d;
    bool ok = !eliminate_dynamic_init();
    if (init != 0)
    {   init = optimise0(init); /* KJB ??? */
        if (!init) syserr("float_of_init");
        if (ok && h0_(init) == s_floatcon) fval = (FloatCon *)init;
        else if (!dynamic_init(init, 0))
            moan_nonconst(init, moan_floating_type);
    }
    return fval;
}

static String *string_of_init(Expr *init, bool wide)
{   if (init != 0 && h0_(init) == s_invisible)
        init = orig_(init);     /* can only happen in CPLUSPLUS         */
    if (init != 0 && isstring_(h0_(init)))
    {   if (wide == (h0_(init) == s_wstring)) return (String *)init;
    }
    return 0;
}

static int32 rd_bitinit(TypeExpr *t, int32 size)
{  t = unbitfield_type(t);
/* Apr 92: for type-safe enums, now use 't' instead of prev. te_int     */
/* The current version of unbitbields returns te_int/enum type.         */
    return int_of_init(rdinit(t, 0, 0))  &  (((unsigned32)1 << size)-1);
/* One day it might be nice to compare the value read with size...      */
}

/**************************************************************************
      oo          oo     Problem: This code is tailored to putting string
      o\\  ____  //o     literals in the read only code area, thus it handles
        \\/    \//       initialised char *s without additional buffering and
         | O  O |        can generate the address constants on the fly. In
          : oo :         order to put the literals in the data area, we have
           \__/          to postpone generating them until after we've made
           //\\          the adcons pointing to them. Clever use of existing
         o//  \\o        data structures makes this almost painless... but
         oo    oo        BEWARE if you aspire to grok the code...
**************************************************************************/

    struct StrLit {
        struct StrLit *next;
        DataInit *d;
        String *s;
    };
    static struct StrLit *str_lits;

    struct CompLit {
        struct CompLit *next;
        DataInit *start;
        DataInit *patch;
        Binder *bind;
        int32 size;
    };
    static struct CompLit *comp_lits;

    struct StaticCompLit {
        struct StaticCompLit *next;
        DataInit *start;
        int32 addr;
        int32 size;
        struct CompLit *clit; // during nesting only
    };
    static struct StaticCompLit *static_comp_lits;

static bool init_adcons;                /* @@@ unused */

static void genpointer(Expr *einit)
{   int32 offset = 0;
    AEop op;
//#ifdef CPLUSPLUS
    Expr *x = optimise0(einit); /* @@@ dubious -- see rdinit().         */
    if (x == 0 || h0_(x) == s_integer) syserr("genpointer new code");
//#else
//    Expr *x = einit;
//#endif
    for (;;) switch (op = h0_(x))
    {   case s_addrof:
        {   Expr *y = arg1_(x); Binder *b;
            int32 addr;
            struct CompLit *clit = 0;
            if (h0_(y) != s_binder)
                syserr(syserr_genpointer, (long)h0_(y));
            b = (Binder *)y;
            addr = bindaddr_(b);
            /* Arrange for backpatching of compound literal address */
            if (addr == BINDADDR_UNSET)
            {   for (clit = comp_lits; clit; clit = clit->next)
                    if (clit->bind == b)
                    {   addr = 0;
                        break;
                    }
            }
            if ((b->bindstg & (bitofstg_(s_static) | u_loctype))
                 == bitofstg_(s_static))
            {   /* now statics may be local (and hence use datasegment
                 * offsets -- see initstaticvar()) or functions (possibly
                 * not yet defined -- "static f(), (*g)() = f;".
                 */
                if (b->bindstg & b_fnconst) gendcF(bindsym_(b), offset, 0);
                else {
                    gendcA(bindsym_(datasegment), addr+offset, 0);
                }
            }
#ifdef TARGET_HAS_BSS
            else if ((bindstg_(b) & bitofstg_(s_static)) &&
                     addr != BINDADDR_UNSET)
                gendcA((bindstg_(b) & u_constdata) ? bindsym_(constdatasegment) :
                                                     bindsym_(bsssegment),
                       addr+offset, 0);
#endif
            else if (b->bindstg & (bitofstg_(s_extern) | u_loctype))
            {   int xr = (bindstg_(b) & bitofstg_(s_weak)) ? xr_weak : 0;
                if (b->bindstg & b_fnconst)
                    gendcF(bindsym_(b), offset, xr);
                else
                    gendcA(bindsym_(b), offset, xr);
            }
            else
            {   if (!dynamic_init(einit, 0))
                    cc_err(vargen_err_nonstatic_addr, b);
                if (sizeof_ptr == 8 && target_lsbytefirst)
                    gendcI(sizeof_ptr-4, TARGET_NULL_BITPATTERN);
                else gendcI(sizeof_ptr, TARGET_NULL_BITPATTERN);
                clit = 0;
            }
            if (clit) clit->patch = data.tail;

/*
 * The next line is because (at present?) gendcA does not put out the
 * high-order part of an 8-byte address... to allow me to fudge string
 * addresses....
 */
            if (sizeof_ptr == 8 && target_lsbytefirst) gendcI(4, 0); /* ! */
            init_adcons = YES;
            return;
        }
        case_s_any_string
            if ((feature & FEATURE_WR_STR_LITS) ||
                (config & CONFIG_REENTRANT_CODE)) {
              /*
               * Standard pcc mode: first dump a reference to the
               * literal then record that the literal must be generated
               * and the reference updated when the recursion terminates.
               * I.e. the offset value stashed away in the next value
               *  will be sought out again and updated.
               */
              gendcA(bindsym_(datasegment), offset, 0);  /* dataseg relative */
              init_adcons = YES;
              str_lits = (struct StrLit *) syn_list3(str_lits, data.tail, x);
/*
 * Here is the reason that (as a temporary hack?) I make gendcA only generate
 * 4 bytes if sizeof_ptr == 8 and target_lsbytefirst.  It is because the fudge
 * here needs to have a handle on the LOW word of the address to relocate it
 * to talk about the offset of the string being mentioned.
 */
              if (sizeof_ptr == 8 && target_lsbytefirst) gendcI(4, 0);
            } else {
              /*
               * Standard ANSI mode: put the strings in code space,
               * nonmodifiable. Rely on the fact that CG thinks it is
               * between routines (even for local static inits).
               * codeloc() is a routine temporarily for forward ref
               */
              gendcF(bindsym_(codesegment),codeloc()+offset, 0);
              if (sizeof_ptr == 8 && target_lsbytefirst) gendcI(4, 0);
              codeseg_stringsegs(((String *)x)->strseg, NO);
            }
            return;
        case s_cmplit:
            x = arg2_(x); break;
        case s_integer:
            /*
             * A New case to deal with things like '(&(struct tag*)0)->field'
             * Such expressions turn into '(int) + (int)' in the AE tree.
             * So here I calculate the value and assign it to the pointer.
             */
            /* @@@AM: new pointer reduction code in sem.c (for offsetof)   */
            /* *probably* means can never happen.  Review.                 */
            gendcI(sizeof_ptr, evaluate(x) + offset);
            return;
        case s_monplus:
        case s_cast:
            x = arg1_(x); break;
        case s_plus:
            if (h0_(arg1_(x)) == s_integer)
              { offset += evaluate(arg1_(x)); x = arg2_(x); break; }
            /* drop through */
        case s_minus:
            if (h0_(arg2_(x)) == s_integer)
              { offset += (op == s_plus ? evaluate(arg2_(x)) :
                                          -evaluate(arg2_(x)));
                x = arg1_(x); break; }
            /* drop through */
        default:
            /* I wonder if the type system allows the next error to occur! */
            /* ',' operator probably does */
            /* we must use 'einit': (1) to avoid optimise0()            */
            /*                  and (2) to keep 'offset'.               */
            if (!dynamic_init(einit, 0))
                cc_err(vargen_err_bad_ptr, op);
            gendcI(sizeof_ptr, TARGET_NULL_BITPATTERN);
            return;
    }
}

static void initbitfield(unsigned32 bfval, int32 bfsize, bool pad_to_int)
{
    int32 j;
    /* one day AM will extend this code to deal with long bit fields,   */
    /* e.g. a la mips.                                                  */
    if (!(feature & FEATURE_PCC))
    {   padstatic(alignof_int);
        gendcI(sizeof_int, bfval);
        return;
    }
    bfsize = (bfsize + 7) & ~7;
    if (debugging(DEBUG_DATA))
        cc_msg("initbitfield(%.8lx, %lu, %i)\n", bfval, bfsize, pad_to_int);
    for (j = 0;  j < bfsize;  j += 8)
        if (target_lsbytefirst)
            gendcI(1, bfval & 255), bfval >>= 8;
        else
            gendcI(1, bfval >> 24), bfval <<= 8;
    if (pad_to_int) padstatic(alignof_int);
}

static int32 readbackbitfield(void)
{   int32 v = readbackdcI();
    int32 j, bfval = 0;
    if (target_lsbytefirst)
        bfval = v;
    else
        for (j=0; j < 32; j += 8)
           bfval |= ((v>>(24-j)) & 0xFF) << j;

    return bfval;
}

/* NB. this MUST be kept in step with sizeoftype and findfield (q.v.) */
static void initstruct(TypeExpr *t, bool is_union, ClassMember *start, ClassMember *seeking, bool designate_mode)
{   TagBinder *b = typespectagbind_(t);
    ClassMember *l;
    int32 bfsize, bfval, k, woffset;
    int32 saved_initoff = cur_initoff;
    StructPos p;
    bool oldnowrite = staticnowrite(YES);
    AEop temp;
    static int32 saved_bfsize,saved_woffset; /* For after a seek */
    static StructPos saved_p;
    p.n = p.bitoff = 0;
    if (!(attributes_(b) & TB_DEFD))
        cc_err(vargen_err_undefined_struct, b);

    if (seeking) temp = curlex.sym, curlex.sym = s_rbrace;
    else staticnowrite(oldnowrite);

    if (start)
    {
        bfsize = saved_bfsize, woffset = saved_woffset;
        p = saved_p;
        bfval = readbackbitfield();
        saved_p.n = saved_p.bitoff = 0;
        saved_bfsize = saved_woffset = 0;
    }
    else
        bfsize = bfval = woffset = 0;
    for (l = start ? start : tagbindmems_(b); l != seeking; l = memcdr_(l))
    {
        if (!structfield(l, bitoftype_(s_struct), &p)) continue;
        inittype = memtype_(l);
        initbsize = p.bsize;
        initboffset = p.boffset;
        initwoffset = p.woffset;
        cur_initoff = saved_initoff + initwoffset;
        if (designate_mode && !(seeking || oldnowrite) && !syn_canrdinit())
            break;
        if (isbitfield_type(memtype_(l)))
        {   k = p.bsize;
            if (bfsize == 0)
            {   while (woffset < p.woffset)
                {   gendcI(1, 0);
                    ++woffset;
                }
            }
            if (woffset < p.woffset)
            {   initbitfield(bfval, bfsize, 1);
                bfsize = bfval = 0;
                woffset = p.woffset;
            }
            cur_initoff = saved_initoff + woffset;
            /* accumulate bitfield in bfval */
            if (memsv_(l) != 0)
            {   /* ANSI 3rd draft says unnamed bitfields */
                /* never consume initialisers.           */
                int32 leftshift = p.boffset;
                if (!target_lsbitfirst)
                    leftshift = MAXBITSIZE - k - leftshift;
                if (woffset != p.woffset)
                {   if (target_lsbytefirst)
                        leftshift -= (woffset-p.woffset)*8;
                    else
                        leftshift += (woffset-p.woffset)*8;
                }
                if ((leftshift + k) > bfsize)
                    bfsize = leftshift + k;
                if (!seeking)
                {   bfval &= ~((1<<k) - 1 << leftshift);
                    bfval |= rd_bitinit(memtype_(l), k)
                                << leftshift;
                }
            }
        }
        else
        {   if (bfsize)
            {   initbitfield(bfval, bfsize, 0);
                bfsize = bfval = 0;
            }
            padstatic(alignof_member);
            padstatic(alignoftype(memtype_(l)));
            woffset = p.woffset + p.typesize;
#ifdef CPLUSPLUS
            if (attributes_(l) & CB_MASK &&
                complain_non_aggregate)
            {   cc_warn(vargen_warn_init_non_aggregate);
                complain_non_aggregate = 0;
            }
#endif
            /* KJB - ignore flexible array members */
            if (!(!is_union &&
                  memcdr_(l) == 0 &&
                  h0_(princtype(memtype_(l))) == t_subscript &&
                  typesubsize_(princtype(memtype_(l))) == 0))
                initsubstatic(memtype_(l), 0, 0, designate_mode);
            cur_initoff = saved_initoff + woffset;
        }
        /* only the 1st field of a union can be initialised */
        if (is_union && !seeking) break;
    }
    if (bfsize && !seeking) initbitfield(bfval, bfsize, is_union);
    if (is_union)
        gendc0(sizeoftype(t) - (l==0 ? 0 : /* empty union!! */
             bfsize ? sizeof_int : sizeoftype(memtype_(l))));
#ifdef CPLUSPLUS        /* See sem.c(sizeoftype) -- check this agrees   */
    else
        if (bfsize == 0 && p.n == 0)
            gendc0(1); /* empty C++ struct.   */
#endif
    if (seeking)
    {   staticnowrite(oldnowrite), curlex.sym = temp;
        saved_bfsize = bfsize;
        saved_woffset = woffset;
        saved_p = p;
    }
}

static bool subdesignators(TypeExpr *st)
{
    Designator d;
    bool ok = NO;
    AEop r;

    st = princtype(st);
    r = syn_rddesignator(st, &d);

    if (r)
    {   ClassMember *sl = NULL;
        if (r == s_dot)
        {
            sl = findmember(st, d.member);
            if (sl)
                d.member = sl, ok = YES;
            else
                cc_err(sem_err_unknown_field, typespectagbind_(st),
                       h0_(d.member) == s_identifier ? (Symstr *)d.member:
                                                  memsv_(d.member));
        }
        else /* r == s_subscript */
        {   if (d.index <= evaluate(typesubsize_(st)))
                ok = YES;
            else
                cc_err(vargen_err_array_range, d.index), sl = NULL;
        }
    }
    if (ok)
        initsubstatic(st, 0, &d, YES);
    else
        syn_enddesignator();

    return ok;
}

/* NB. this MUST be kept in step with sizeoftype and findfield (q.v.) */
static int32 initsubstatic(TypeExpr *t, Binder *whole, Designator *designated, bool designate_mode)
{   SET_BITMAP m;
    int32 saved_initoff = cur_initoff, ret = 0;
    inittype = t;    /* for possible dynamic initialization */
    switch (h0_(t))
    {
case s_typespec:
            m = typespecmap_(t);
            switch (m & -m)    /* LSB - unsigned/long etc. are higher */
            {   case bitoftype_(s_void):
                    /*
                     * This Guy is trying to initalise a 'void' !!!
                     * @@@ Can this happen any more?
                     */
                    cc_err(vargen_err_init_void);
                    (void)int_of_init(rdinit(te_int,whole,0));
                    break;
                case bitoftype_(s_char):
                case bitoftype_(s_enum):    /* maybe do something more later */
                case bitoftype_(s_int):
                    if (m & BITFIELD) syserr(syserr_initsubstatic);
                        /* these are all supposedly done as part of the
                         * enclosing struct or union.
                         */
#ifndef REVIEW_AND_REMOVE     /* in by default */
/* /* This code to be reviewed now that the front end reduces some
      such expressions to integers.  AM and ??? to discuss.
      Do we need support for:   int x = (int)"abc";?
      Check the exact wording of last ANSI draft.
      If nothing else review the cc_err() message in genpointer.
*/
                    /*
                     * Okay, I confess, I have used the pointer initialisation
                     * code here to initialise 'int' values in PCC mode,
                     * But I can explain !!!.  Well, it goes like this, some
                     * PCC code contains expressions like :
                     *   'int x = (int) (&(struct tag*)0)->field;'
                     * Well, this is really a pointer initialisation so why
                     * not use the code.  (See simple, isn't it).
                     **** AM cringes at this.  Tidy soon.
                     *@@@ LDS too - BUT DON'T BREAK IT;
                     *              Unix won't compile if you do.
                     * AM dec90: this code probably is redundant since
                     *  changes elsewhere means it works in ansi mode.
                     *  but it does allow:  int x = (int)"abc";
                     */
                    if ((feature & FEATURE_PCC) && (sizeoftype(t) == 4))
                    {   Expr *init = rdinit(t,whole,0);
                        if (init == 0) gendcI(4,0);
                        else if (h0_(init) == s_integer)
                            gendcI(4,intval_(init));
                        else
                            genpointer(init);
                    }
                    else
#endif /* REVIEW_AND_REMOVE */
                        gendcI(sizeoftype(t), int_of_init(rdinit(t,whole,0)));
                    break;
                case bitoftype_(s_double):
                    gendcE(sizeoftype(t), float_of_init(rdinit(t,whole,0)));
                    break;
                case bitoftype_(s_struct):
                case bitoftype_(s_class):
                case bitoftype_(s_union):
/* ANSI 3rd public review draft says that                            */
/*   union { int a[2][2] a, ... } x = {{1,2}} initialises like       */
/*   int a[2][2] = {1,2}   ( = {{1,0},{2,0}}).                       */
                {   int32 note = NO;
                    TagBinder *b = typespectagbind_(t);
                    DataPos dp = staticgetpos(), ep;
                    Designator d;
                    bool is_union = ((m & -m) == bitoftype_(s_union));
                    bool had_designator = NO;
                    if (designated)
                    {   TypeExpr *st = memtype_(designated->member);
                        /* Seek to designated member */
                        //cc_msg("seeking to designated .$r\n", memsv_(designated->member));
                        if (!is_union)
                            initstruct(t, is_union, 0, designated->member, YES);
                        had_designator = subdesignators(st);
                    }
                    else
                        note = syn_begin_agg();  /* skips and notes if '{' */
                    if (note || (designated && !had_designator))
                        syn_ensure_init(note != 0);
                    if (note && designate_mode)
                    {   /* SPLAT! */
                        inittype = t;
                        initbsize = 0;
                        if (eliminate_dynamic_init())
                           syserr("Dynamic initialisation too weird (structure)");
                    }
                    cur_initoff = saved_initoff;
                    if (had_designator)
                    {   if (memcdr_(designated->member))
                            initstruct(t, is_union, memcdr_(designated->member), 0, YES);
                    }
                    else
                    {   Expr *e;
                        if (language_flavour >= FLAVOUR_C99 && !note &&
                            (e = rdinit(0,0,1)) != NULL && /* peek */
                            qualfree_equivtype(t, typeofexpr(e)))
                        {
                            dynamic_init(rdinit(0,0,0), 0);
                            gendc0(sizeoftype(t));
                        }
                        else
                        {   initstruct(t, is_union, designated ? designated->member : 0, 0, designate_mode && !note);
                        }
                    }
                    if (!designated)
                        padstatic(alignoftype(t));  /* often, alignof_struct */
                    had_designator = NO;
                    while (note && syn_rddesignator(t, &d))
                    {   ClassMember *l;
                        //printf("Whoot!");
                        cur_initoff = saved_initoff;
                        l = findmember(t, d.member);
                        if (l)
                        {   /* Rewind to start of structure */
                            if (!had_designator)
                            {   had_designator = YES;
                                ep = staticgetpos();
                            }
                            d.member = l;
                            staticsetpos(dp);
                            //cc_msg("writing subobject\n");
                            initsubstatic(t, 0, &d, YES);
                        }
                        else
                        {   cc_err(sem_err_unknown_field, b,
                                   h0_(d.member) == s_identifier ? (Symstr *)d.member:
                                                                   memsv_(d.member));
                            syn_enddesignator();
                            break;
                        }
                    }
                    if (had_designator) staticsetpos(ep);
                    syn_end_agg(note);
                    break;
                }
                case bitoftype_(s_typedefname):
                    initsubstatic(bindtype_(typespecbind_(t)), whole, 0, designate_mode);
                    break;
                default:
                    syserr(syserr_initstatic, (long)h0_(t), (long)m);
                    break;
            }
            break;
case t_fnap:  /* spotted earlier */
default:
        syserr(syserr_initstatic1, (long)h0_(t));
case t_subscript:
        {   int32 note = NO;
            int32 i = 0, m = typesubsize_(t) ? evaluate(typesubsize_(t)):0xffffff;
            int32 elemsize = sizeoftype(typearg_(t));
            TypeExpr *t2;
            DataPos dp = staticgetpos(), ep;
            Designator d;
            bool had_designator = NO;
            bool oldnowrite;
            if (m == 0)
            {   syn_end_agg(note);
/* Be careful with struct { char x; int y[0]; char y; } even if ANSI illegal */
                break;
            }
            //if (designated)
              //  printf("Array designated [%d]\n", designated->index);
            oldnowrite = staticnowrite(YES);
            if (designated)
            {   ClassMember *l;
                /*AEop temp = curlex.sym;
                curlex.sym = s_rbrace;*/

                gendc0(designated->index * sizeoftype(typearg_(t)));
                /*for (i = 0; i < designated->index; i++)
                    initsubstatic(typearg_(t), 0, 0, YES);*/
                i = designated->index;
                staticnowrite(oldnowrite);
                //curlex.sym = temp;

                had_designator = subdesignators(typearg_(t));
            }
            else
                note = syn_begin_agg();  /* skips and notes if '{' */
            staticnowrite(oldnowrite);
            if (note || (designated && !had_designator))
                syn_ensure_init(note != 0);
            if (note && designate_mode)
            {   /* SPLAT! */
                inittype = t;
                initbsize = 0;
                if (eliminate_dynamic_init())
                    syserr("Dynamic initialisation too weird (array)");
            }
            if (had_designator)
                i++;
            if (i == m)
            {   syn_end_agg(note);
                break;
            }
            had_designator = NO;
            cur_initoff = saved_initoff + i * elemsize;
/* N.B. the code here updates the size of an initialised [] array          */
/* with the size of its initialiser.  initstaticvar()                      */
/* ensures (by copying types if necessary) that this does not clobber      */
/* a typedef in things like: typedef int a[]; a b = {1,2};                 */
            if (!syn_canrdinit())
            {   //if (typesubsize_(t) == 0)
                //    cc_err(vargen_err_open_array);
            }
            else if (t2 = princtype(typearg_(t)), isprimtype_(t2,s_char))
            {   String *s = string_of_init(rdinit(0,0,1), 0);
                if (s)
                {   int32 k = genstring(s, m);
                    if (s != string_of_init(rdinit(0,0,0), 0))
                        syserr("vargen(string-peep)");
                    if (typesubsize_(t) == 0)
                        typesubsize_(t) = globalize_int(k);
                    syn_end_agg(note);
                    break;
                }
                /* ANSI say m > 0 so rdinit(peek) is re-read.           */
            }
            else if (t2 = princtype(typearg_(t)),
/* t2 is maybe const/volatile 'signed int' or 'int':                  */
                       h0_(t2) == s_typespec && (typespecmap_(t2) &
                              (bitoftype_(s_int)|bitoftype_(s_long)|
                               bitoftype_(s_short)|bitoftype_(s_unsigned))) ==
                           bitoftype_(s_int))
            {   String *s = string_of_init(rdinit(0,0,1), 1);
                if (s)
                {   int32 k = genstring(s, m);
                    if (s != string_of_init(rdinit(0,0,0), 1))
                        syserr("vargen(string-peep)");
                    if (typesubsize_(t) == 0)
                        typesubsize_(t) = globalize_int(k);
                    syn_end_agg(note);
                    break;
                }
                /* ANSI say m > 0 so rdinit(peek) is re-read.           */
            }
/* Maybe generalise this one day:                                       */
#define vg_init_to_null(t) (TARGET_NULL_BITPATTERN == 0)
            //printf("Entering normal array fill loop at %ld; size = %ld\n", i, m);
            for (; i < m; i++)
            {   if (!syn_canrdinit())
                {   if (typesubsize_(t) == 0)
                    {   //typesubsize_(t) = globalize_int(i);
                        break;  /* set size to number of elements read. */
                    }
                    if (designate_mode && !note && !oldnowrite)
                    {   //staticsetpos(ep);
                        break;
                    }
                    if (vg_init_to_null(typearg_(t)))
                    {   gendc0((m-i)*sizeoftype(typearg_(t)));
                        i = m;
                        break;  /* optimise multi-zero initialisation.  */
                    }
                }
                initsubstatic(typearg_(t), 0, 0, designate_mode);
                cur_initoff += elemsize;
            }
            //printf("Exited normal array fill loop at %ld\n", i);
            while (note && syn_rddesignator(t, &d))
            {   //printf("Array designator [%d] encountered; current array size = %d\n", d.index, i);
                int32 o;
                if (!had_designator)
                {   had_designator = YES;
                    ep = staticgetpos();
                }
                cur_initoff = saved_initoff;
                if (d.index >= i)
                {   if (d.index > 0xffffff)
                    { cc_err(syn_err_arraysize, (long) d.index); break; }
                    if (m == 0xffffff)
                    {   if (designate_mode) syserr("open array designate");
                        if (vg_init_to_null(typearg_(t)))
                        {
                             gendc0((d.index+1-i)*sizeoftype(typearg_(t)));
                             i = d.index+1;
                        }
                        else
                        {   AEop temp = curlex.sym;
                            curlex.sym = s_rbrace;
                            for (; i <= d.index; i++)
                                initsubstatic(typearg_(t), 0, 0, NO);
                            curlex.sym = temp;
                        }
                        ep = staticgetpos();
                    }
                    else
                        break;
                }
                staticsetpos(dp);
                //cc_msg("doing subobject for array\n");
                cur_initoff = saved_initoff + d.index * elemsize;
                o = initsubstatic(t, 0, &d, YES);
                if (o > i) { i = o; ep = staticgetpos(); }
            }

            if (!designated &&
                (typesubsize_(t) == 0 && i != 0
                   ||
                 typesubsize_(t) && evaluate(typesubsize_(t)) < i)
               )
            {   //printf("Array size determined as %ld\n", i);
                typesubsize_(t) = globalize_int(i);
            }
            ret = i;
            //printf("Exited array designator loop\n");
            if (!designated && typesubsize_(t) == 0)
                cc_err(vargen_err_open_array);
            if (had_designator && i == evaluate(typesubsize_(t)))
                staticsetpos(ep);
            syn_end_agg(note);
            break;
        }
case t_content:
case t_ref:
        {   Expr *init = rdinit(t,whole,0);
            if (init == 0)
                gendcI(sizeof_ptr, TARGET_NULL_BITPATTERN);
            else if (h0_(init) == s_integer)
                gendcI(sizeof_ptr, intval_(init)); /* casted int to pointer */
            else
                genpointer(init);
            break;
        }
    }

    cur_initoff = saved_initoff;

    return ret;
}

/* Should be static except for initstaticvar(datasegment) in compiler.c */
void initstaticvar(Binder *b, bool topflag)
{   padstatic(alignoftype(bindtype_(b)));
    if (debugging(DEBUG_DATA))
        cc_msg("%.6lx: %s%s\n", (long)data.size, topflag ? "":"; ",
               symname_(bindsym_(b)));
    bindaddr_(b) = cur_initoff = initoff = datap->size;
    if (topflag) /* note: names of local statics may clash but cannot be
                    forward refs (except for fns which don't come here) */
    {   labeldata(bindsym_(b));
        (void)obj_symref(bindsym_(b),
                   (bindstg_(b) & bitofstg_(s_extern) ? datap->xrarea+xr_defext :
                                                        datap->xrarea+xr_defloc),
                   datap->size);
    }
    if (b == datasegment) return;      /* not really tidy */
    /*
     * A decl such as 'typedef char MSG[];' gets side effected by
     * 'MSG name = "A name";'.  Therefore copy type before initialiser
     * is read ... Here we go ...
     */
    if (isprimtype_(bindtype_(b), s_typedefname))
    {   TypeExpr *t = prunetype(bindtype_(b));
        if (h0_(t)==t_subscript && typesubsize_(t) == 0)
            /* the next line is idle, since case is rare...             */
            /* (We must alloc. glob store since b maybe top level       */
            /*  and hence its type will already be globalised, but      */
            /*  prunetype() may alloc. local store -- globalise all.)   */
            /* Note that the next line relies on globalize_typeexpr     */
            /* NOT caching empty arrays, hence we get a fresh copy.     */
            bindtype_(b) = globalize_typeexpr(t);
    }
    {
#ifdef TARGET_IS_ACW
/* The following (hackish) lines force FEATURE_WR_STR_LITS (which puts   */
/* strings in data segment) for the Acorn 32000 machine) which, due to   */
/* TARGET_CALL_USES_DESCRIPTOR, are unhappy abount code segment adcons   */
/* (as opposed to descriptors) in a data segment.                        */
        int32 f = feature; feature |= FEATURE_WR_STR_LITS;
#endif
        initsubstatic(bindtype_(b), b, 0, NO);
/* Note that the following padstatic(alignof_toplevel) helps alignment   */
/* of (e.g.) strings (which often speeds memcpy etc.).  However it is    */
/* also assumed to happen by the code for initialising auto arrays.      */
/* See the call to trydeletezerodata().                                  */
        padstatic(alignof_toplevel);
#ifdef TARGET_IS_ACW
        feature = f;
#endif
    }
    codeseg_flush(0);           /* Aug 90: arg is ALWAYS 0 -- check.     */
}

static Expr *quietaddrof(Binder *b)
/* This function exists only to keep PCC mode happy. ensurelvalue() in */
/* sem is what's really needed, but it isn't exported and whinges in   */
/* pcc mode about &<array>. In the long-term, something like this is   */
/* needed for export from simplify (a quiet force-address-of-tree opn  */
/* for trusted callers) so until then LDS leves this bodge here.       */
{   bindstg_(b) |= b_addrof;
    return mk_expr1(s_addrof, ptrtotype_(bindtype_(b)), (Expr *)b);
}

/* Auxiliary routine for initialising auto array/struct/unions */
static Expr *vg_copyobj(Binder *sb, Binder *b, int32 size)
{   /* Note that the same code suffices for array and structs as it is */
    /* quite legal to take the address of an array, implicitly or      */
    /* explicitly.  Note that b/sb both have array/struct/union type.  */
    return mk_expr2(s_fnap, primtype_(bitoftype_(s_void)), sim.memcpyfn,
              (Expr *)mkExprList(
                mkExprList(
                  mkExprList(0, mkintconst32s(te_int, size, 0)),
                  quietaddrof(sb)),
                quietaddrof(b)));
}

static Expr *vg_zeroobj(Binder *b, int32 offset, int32 zeros)
{   Expr *addrb = quietaddrof(b);
    return mk_expr2(s_fnap, primtype_(bitoftype_(s_void)), sim.memsetfn,
              (Expr *)mkExprList(
                mkExprList(
                  mkExprList(0, mkintconst32s(te_int,zeros,0)),
                  mkintconst32s(te_int,0,0)),
                mk_expr2(s_plus, typeofexpr(addrb), addrb,
                         mkintconst32s(te_int, offset, 0))));
}

/* The following routine removes generated statics, which MUST have been
   instated with instate_declaration().  Dynamic initialistions are turned
   into assignments for rd_block(), by return'ing.  0 means no init.
   Ensure type errors are noticed here (for line numbers etc.) */
/* AM: the 'const's below are to police the unchanging nature of 'd'    */
/* (and its subfields stg,b).  Note that 't' can be changed.            */

Expr *genstaticparts(DeclRhsList *const d, bool topflag, bool dummy_call,
        Expr *dyninit, bool cmplitflag)
{   const SET_BITMAP stg = d->declstg;
/* @@@ move attempt_constdata here (and even defer it for C++).         */
/* also note stg below has 2/3 defns bindstg/declstg.                   */
    Binder     *b  = d->declbind;
    TypeExpr   *t  = prunetype(d->decltype);
    static int nested;
    struct vg_state saved_state = vg_state;
    DataPos saved_pos;
    struct CompLit *clit = 0;
    struct StaticCompLit *dup_clit = 0;
    int hackflag;             /* only while transforming code.          */
    int32 loc = 0;
    str_lits = NULL;          /* no static string inits seen yet.       */
    init_adcons = NO;
#ifdef CPLUSPLUS
    init_fl = d->fileline;
    complain_non_aggregate = !dummy_call;
#else
    IGNORE(dummy_call);
#endif
    dyninit_list = NULL;
    if (nested++)
    {    /* Awooga - nested genstaticparts. This is possible thanks to  */
         /* the miracle of compound literals. We run then store the     */
         /* data until we unwind fully.                                 */
         clit = comp_lits = (struct CompLit *) syn_list5(comp_lits, 0, 0, 0, 0);
         saved_pos = staticgetpos();
         padstatic(alignof_toplevel);
    }
    else if (cmplitflag)
         clit = (struct CompLit *) syn_list5(0, 0, 0, 0, 0);
    /* Apr 92: this case was recently lifted out -- maybe it shows a    */
    /* bug(?) whereby s_typedef and b_fnconst can both be set?          */
    if (stg & bitofstg_(s_typedef))
    {   if (usrdbg(DBG_PROC) && topflag)
            dbg_type(bindsym_(b), bindtype_(b), d->fileline);
    }
    else if (!(stg & b_fnconst)) switch (stg & PRINCSTGBITS)
    {
case bitofstg_(s_auto):                 /* includes register vars too   */
            /*
             * Deal with arrays, structs and unions here
             * Treat auto a[5] = 2; consistently with static a[5] = 2;
             * by always trying to read an initialiser for an array.
             * @@@ maybe forbid above for C++
             */
            if ( syn_canrdinit() &&
                 ( h0_(t) == t_subscript ||
                   ( curlex.sym == s_lbrace && isclasstype_(t))))
            {   /* For an initialised auto array/struct/union generate    */
                /* the whole object (ANSI 3rd draft say initialising one  */
                /* component of an object initialises it all) in static   */
                /* space and generate a run-time copy.   We treat large   */
                /* terminal zero segments specially.                      */
                /* For consistency this is a source-to-source translation. */
                int32 size, zeros, copy;
                Expr *vg_dyninit;
/* NB the use of bindtype_(b) in the next line instead of t avoids        */
/* updating a possible open array typedef.                                */
                Binder *sb = mk_binder(gensymval(0), bitofstg_(s_static),
                                       bindtype_(b));
                DataInit *start;
                /* It suffices to allocate sb like any other local static. */
#ifdef TARGET_IS_HELIOS
/*
 * A strange option needed with Helios (for building a shared library) can
 * make this mechanism fall apart (the forged static may not get set up)
 * so I generate a diagnostic to warn people.  Yuk at the break of modularity.
 */
                {   extern bool suppress_module;
                    if (suppress_module)
                        cc_err(vg_err_dynamicinit);
                }
#endif
#ifndef CPLUSPLUS       /* more syn.c(attempt_constdata) code!          */
#ifdef CONST_DATA_IN_CODE
                if ( !(config & CONFIG_REENTRANT_CODE) ||
                     pointerfree_type(bindtype_(b)))
                {   datap = &constdata;
                    binduses_(sb) |= u_constdata;
                    cur_initlhs = b;
                }
#endif
#endif
                start = (datap->head == NULL) ? NULL : datap->tail;
                if (clit)
                {   clit->bind = sb;
                    clit->start = start;
                    clit->size = datap->size;
                }
                /*
                 * Create hidden static for auto initialiser.
                 */
                initauto = YES;
                cur_initlhs = b;
                initstaticvar(sb, NO);
                cur_initlhs = 0;
/* Update bindtype_(b) in case it was typedef to open array which       */
/* would have been copied (cloned) by initstaticvar().                  */
                t = bindtype_(b) = bindtype_(sb);
                size = sizeoftype(t);    /* size of auto [] now known.  */

/* The following line is helpful for initialising auto char arrays.     */
/* We pad the size for initialisation purposes up to a multiple of      */
/* alignof_toplevel, safe (in the assumption) that flowgraf.c has padded*/
/* the stack object and that initstaticvar() below has done the same    */
/* for the statically allocated template.                               */
/* The effect is to encourage cg.c to optimised word-oriented copies.   */
                copy = size = padsize(size, alignof_toplevel);

/* If less than 8 words of zeros in array, struct or union then do not  */
/* remove trailing zeros.  trydeletezerodata() is a multiple of 4.      */
                copy -= zeros = trydeletezerodata(start, 32);
                if (dyninit) syserr("dyninit");
                {   int32 di = vg_get_dyninit_coverage(0);
                    if (di == size) /* total coverage */
                    {    if (copy != 0) trydeletezerodata(start, 0);
                         zeros = copy = 0;
                    }
                    else if (zeros)
                    {   di = vg_get_dyninit_coverage(copy) &~ 3;
                        /* dynamic init for a solid lump between
                         * static init and zero fill */
                        if (di > copy)
                            zeros = size - di;
                    }
                }
                vg_dyninit = vg_get_dyninit(topflag);
                if (cmplitflag && !vg_dyninit &&
                    qualifiersoftype(t) & bitoftype_(s_const))
                {   /* Quietly transform automatic constant compound literals */
                    /* into static ones for efficiency. */
                    d->declbind = b = sb;
                    d->declstg = bindstg_(sb);
                    break;
                }
                if (zeros == 0)
                    dyninit = vg_copyobj(sb, b, copy);
                else
                {   /*
                     * Call function to copy trailing zeros to the data
                     * structure.
                     */
                    dyninit = vg_zeroobj(b, size-zeros, zeros);
                    /*
                     * Copy hidden static to auto array, struct or union
                     * without any trailing zeros.
                     */
                    if (size>zeros)
                        dyninit = mkbinary(s_comma,
                                           vg_copyobj(sb, b, copy),
                                           dyninit);
                }
                if (vg_dyninit != 0)
                    dyninit = mkbinary(s_comma, dyninit, vg_dyninit);
                datap = &data;
            }
            else
            {
                Expr *e = syn_rdinit(d->decltype, b, 0);   /* no optimise0 */
                if (e)
                {  if (dyninit) syserr("dyninit");
                   dyninit = e;
                }
                if (clit)
                {  clit = NULL;
                   if (nested > 1)
                       comp_lits = comp_lits->next;
                }
            }
            break;
#ifndef NON_CODEMIST_MIDDLE_END
case b_globalregvar:
            vg_acton_globreg(d, b);
            loc = bindxx_(b);
            break;
#endif

default:
            syserr(syserr_rd_decl_init, (long)stg);
            /* assume static */
case bitofstg_(s_static):
case bitofstg_(s_extern):
        if (clit)
        {   clit->bind = b;
            clit->start = (datap->head == NULL) ? NULL : datap->tail;
            clit->size = datap->size;
        }
#ifdef CPLUSPLUS
/* @@@ This isn't right for local statics!                              */
        /* pick up any class initialiser calls passed in...             */
        if (dyninit) dynamic_init(dyninit, 1), dyninit = 0;
#endif
        if (!(d->declstg & b_undef))    /* explicit initialisation      */
                                        /* (or small tentative).        */
        {
#ifdef CPLUSPLUS
            /* similar code to auto for "static class A x, y = x;"      */
            if (isclasstype_(t) &&
                  curlex.sym != s_lbrace && syn_canrdinit())
            {   Expr *e = syn_rdinit(d->decltype, b, 0);   /* no optimise0 */
                if (e) dynamic_init(e, 1);
                else syserr("genstatic(static-class)");
            }
            vg_note_topdtor(b, topflag);
#endif
            initauto = NO;
            initstaticvar(b, topflag);
#ifdef CPLUSPLUS
            /* The next line should be a result of initstaticvar!       */
            dyninit = vg_get_dyninit(topflag);
#endif
            /* Put out debug info AFTER initialised array size has      */
            /* been filled in by initstaticvar():                       */
            hackflag = 1;
        }
        else    /* declaration with no explicit initialisation.         */
        {
            if (feature & FEATURE_PCC)
            {   TypeExpr *t = princtype(bindtype_(b));
                /*
                 * Found a declaration like int foo; with no initialiser.
                 * PCC regards this as common which is encoded as an
                 * undefined external data reference with a non-0 size.
                 * BUT BEWARE: int foo[]; is NOT a common variable - it
                 * is an extern decl. Thus, we have a look for undefined
                 * arrays.  (e.g. xxx[1][3][]), possibly via a leading
                 * typedef. If we find one then we exit.
                 * AM: @@@ use is_openarray() soon?  I would now, but
                 * am nervous about int a[][]; in pcc mode.
                 */
                for (; h0_(t) == t_subscript; t = princtype(typearg_(t)))
                {   if (typesubsize_(t) == 0)
                    {
#ifndef TARGET_IS_UNIX
                        /* Add debug info for open arrays (ASD only) */
                        if (usrdbg(DBG_PROC) && topflag)
#ifdef TARGET_HAS_BSS
                            dbg_topvar(bindsym_(b),0,bindtype_(b),DS_EXT+DS_UNDEF,d->fileline);
#else
/* Not all Codemist clients unix interfaces have BSS yet (e.g. COFF)    */
                            dbg_topvar(bindsym_(b),0,bindtype_(b),1,d->fileline);
#endif
#endif
                        goto switch_break;
                    }
                }
                /*
                 *  Generate a special extern reference for PCC style
                 *  common variables.
                 */
/* @@@ This is a genuine feature or config which other systems may want. */
/* Provide a switch one day soon.                                       */
                if ((stg & bitofstg_(s_extern)) && (stg & b_omitextern))
                    (void)obj_symref(bindsym_(b), xr_data+xr_comref,
                                      sizeoftype(bindtype_(b)));
            }
            /* Add debug information for common and extern variables */
            hackflag = 0;
        }
        loc = bindaddr_(b);
        break;
   }
   if (usrdbg(DBG_PROC) && topflag && !cmplitflag &&
       !(stg & (b_fnconst|bitofstg_(s_typedef))))
   {   /* Note that local (to a proc) statics are dealt with       */
       /* in flowgraph.c                                           */
#ifdef TARGET_HAS_BSS
/* @@@ AM Memo: do the BSS mods in a more principled way.               */
/* The following code (tidied Jul-93 but not changed in effect) does    */
/* several silly things: it sets DS_BSS even when the var is later      */
/* given a definition.                                                  */
        SET_BITMAP stg = bindstg_(b);
        dbg_topvar(bindsym_(b), loc, bindtype_(b),
                   stg & b_globalregvar ? DS_REG :
                   ( (stg & bitofstg_(s_extern) ? DS_EXT : 0) |
                     (stg & u_bss ? DS_BSS :
                      stg & u_constdata ? DS_CODE : 0) |
                     (stg & b_undef ? DS_UNDEF : 0)), d->fileline);
#else
        if (hackflag)
            dbg_topvar(bindsym_(b), bindaddr_(b), bindtype_(b),
                       (bindstg_(b) & bitofstg_(s_extern)) != 0, d->fileline);
        else
            dbg_topvar(bindsym_(b), 0, bindtype_(b), 1, d->fileline);
#endif
    }
switch_break:
/* AM Aug 90: bug fix to stop initialisation of a tentative to be a     */
/* string pointer leaving the string pointer in the wrong place in the  */
/* data segment in FEATURE_WR_STR_LITS mode.  Now that the ANSI std     */
/* has appeared, the whole tentative/bss/vargen edifice ought to be     */
/* rationally reconstructed.                                            */
   /*
    * The next call is part of a disgusting fix for tentative
    * static and extern decls.  What happens is as follows:
    * We parse along until we find a decl with no initialiser.
    * We then set 'b_undef' for this symbol and pass it to
    * 'instate_declaration()' above.  This symbol is then entered
    * into the symbol table and 'b_undef' is UNSET if it is a
    * tentative decl so that 'genstaticparts()' WILL allocate it
    * some store.
    * Now if sometime later a REAL initialiser is found for
    * this symbol, this is detected by is_tentative() in mip/bind.c
    * which removes the zeros from the 'data.head/tail' lists and then call
    * 'genstaticparts()' to read the initialiser and finally we call
    * 'reset_vg_after_init_of_...()' below to fix the tables.
    */
    reset_vg_after_init_of_tentative_defn();
    datap = &data;
    /* KJB - hmm - should change the type to match modified form */
    d->decltype = t;
    /*
     * Now generate the string literals we have delayed generating.
     * Also, we relocate the references to them by updating the
     * values in the data-generation templates that will cause those
     * references to be dumped in the data area... Note that we reverse
     * the work list so literals are generated in source order.
     * Note also that the following is a no-op unless FEATURE_WR_STR_LITS.
     */
    {   struct StrLit *p = (struct StrLit *) dreverse((List *)str_lits);
        for (; p != NULL;  p = p->next)
        {   p->d->val += data.size;      /* real offset of generated lit */
            genstring(p->s, 0xffffff);   /* literal dumped in data area  */
            padstatic(alignof_toplevel);
        }
    }

    if (clit)
        clit->size = datap->size - clit->size;

    /* Search for duplicate compound literals. */
    if (clit &&
        d->declstg & bitofstg_(s_static) &&
        qualifiersoftype(t) & bitoftype_(s_const))
    {   struct StaticCompLit *m;
        DataInit *s = clit->start ? clit->start->datacdr : datap->head;
        for (m = static_comp_lits; m; m = m->next)
        {    if (clit->size <= m->size &&
                 vg_static_matches(s, m->start, clit->size))
             {
                 //printf("Found duplicate compound literal %lx\n", m->addr);
                 dup_clit = m;
             }
        }
        if (!dup_clit)
        {   struct StaticCompLit *p = GlobAlloc(SU_Data, sizeof(struct StaticCompLit));
            p->next = static_comp_lits;
            p->start = s;
            p->addr = nested <= 1 ? bindaddr_(clit->bind) : BINDADDR_UNSET;
            p->size = clit->size;
            p->clit = clit;
            static_comp_lits = p;
        }
    }
    /* Now we clear up nested (or duplicate) compound literals. */
    if (clit && nested > 1 || dup_clit)
    {   //DataInit *p;
        datap->size -= clit->size;
        if (clit->start == NULL)
        {   clit->start = datap->head;
            datap->head = datap->tail = NULL;
        }
        else
        {   datap->tail = clit->start;
            clit->start = clit->start->datacdr;
            datap->tail->datacdr = NULL;
        }
        /*printf("Unhooked chain ");
        for (p = comp_lits->start; p; p = p->datacdr)
            printf("%p ", p);
        printf("\n");*/
        if (clit->bind)
            bindaddr_(clit->bind) = dup_clit && nested <= 1 ? dup_clit->addr : BINDADDR_UNSET;
        //printf("Address of %p set to %lx\n", clit->bind, bindaddr_(clit->bind));
        if (dup_clit)
        {   clit->start = (DataInit *)&comp_lits; /* Magic markers */
            clit->size = (int32) dup_clit;
        }
        if (nested > 1)
            staticsetpos(saved_pos);
    }
    if (--nested == 0 && comp_lits)
    {   struct CompLit *p = (struct CompLit *) dreverse((List *)comp_lits);
        struct StaticCompLit *s;
        for (; p != NULL;  p = p->next)
        {   if (p->start == (DataInit *)&comp_lits) /* Duplicate of earlier - just patch */
            {   struct StaticCompLit *dup = (struct StaticCompLit *) p->size;
                if (p->patch)
                    p->patch->val += bindaddr_(dup->clit->bind);
                bindaddr_(p->bind) = bindaddr_(dup->clit->bind);
        //printf("Address of %p set to %lx\n", p->bind, bindaddr_(p->bind));
                continue;
            }
            if (p->patch)
                p->patch->val += data.size;     /* real offset of c.lit */
            bindaddr_(p->bind) = datap->size;
            //printf("Size is %ld\n", p->size);
            datap->size += p->size;
            //printf("Attaching chain ");
           //{ DataInit *i;
           // for (i = p->start; i; i = i->datacdr)
           //     printf("%p ", i);
           //}
           // printf("\n");
            if (datap->head == NULL)
                datap->head = datap->tail = p->start;
            else
                datap->tail->datacdr = p->start;
            while (datap->tail->datacdr) datap->tail = datap->tail->datacdr;
        }
        comp_lits = NULL;
        /* Backpatch addresses of static literals (before Binders get freed) */
        for (s = static_comp_lits; s && s->clit; s = s->next)
            s->addr = bindaddr_(s->clit->bind), s->clit = NULL;
    }
    vg_state = saved_state;
    return dyninit ? optimise0(dyninit) : 0;
}

static Expr *forge_initlhs(void)
{   int32 boff = initboffset;
    if (target_lsbitfirst) boff = MAXBITSIZE - initbsize - boff;
/* It seems a shame we can't invent names instead of dataseg+offset.    */
#if 0
#ifdef CONST_DATA_IN_CODE
    if (datap == &constdata)
    {
/* The following line will one day be a syserr, but is currently no     */
/* more harmless than recovering from "static int c = 1; c = 2;         */
/* @@@ However, it does mean that the constdatasegment detection code   */
/* is wrong for, e.g.,  static const int a = f();                       */
        cc_rerr(vargen_rerr_compiler_confused);
        return mk_exprbdot(s_dot, inittype,
                           (Expr *)constdatasegment, constdata.size,
                           initbsize, boff);
    }
    else
#endif
#endif
    return (cur_initlhs == 0) ? mk_exprbdot(s_dot, inittype,
        (Expr *)datasegment,    /*/* should really be struct, but int OK. */
        data.size, initbsize, boff) :
        mk_exprbdot(s_dot, inittype, (Expr *)cur_initlhs,
                cur_initoff - initoff, initbsize, boff);
/* AM has changed this code to the more obvious code (for reasons       */
/* see comment containing 'x.a = x.b = nn' in sem.c).  However,         */
/* the absence of globalize_expr(s_let) is a pain!                      */
/* However, we need this to be there (or perhaps use global store for   */
/* all allocations during static initialisers) for things like          */
/*        int *f(); static int a = (*f())++;                            */
}

typedef struct DynInitList
{
    struct DynInitList *next;
    TypeExpr *type;
    Expr *expr;
    int32 woffset, boffset, bsize;
    int32 size;
} DynInitList;

static DynInitList *MkDynInit(TypeExpr *t, Expr *e, int32 woffset, int32 boffset, int32 bsize, int32 size)
{
    return (DynInitList *)syn_list7(0, t, e, woffset, boffset, bsize, size);
}

static bool InsertDynInit(DynInitList *d)
{
    DynInitList **prevptr = &dyninit_list, *p;
    int32 size = initbsize ? sizeof_int : sizeoftype(inittype);
    int32 woffset = cur_initoff - initoff;
    bool overlap = NO;
    while ((p = *prevptr) != NULL)
    {   bool eliminate = NO;
        if (p->woffset >= woffset + size)
            break;
        /* For caution - only eliminate if totally covering */
        if (woffset <= p->woffset &&
            woffset + size >= p->woffset + p->size)
        {
            if (p->bsize && initbsize)
            {
                if (woffset != p->woffset) syserr("dyninit bf");
                if (p->boffset >= initboffset + initbsize)
                    break;
                if (initboffset <= p->boffset &&
                    initboffset + initbsize >= p->boffset + p->bsize)
                    eliminate = YES;
                else if (!(initboffset + initbsize <= p->boffset ||
                           initboffset >= p->boffset + p->bsize))
                    overlap = YES;
            }
            else if (!initbsize)
                eliminate = YES;
        }
        else if (!(woffset + size <= p->woffset ||
                   woffset >= p->woffset + p->size))
            overlap = YES;
        if (eliminate)
        {
            /* Knock out old initialiser */
            printf("Eliminated initaliser (w=%ld, s=%ld, boff=%ld, bsize=%ld)\n", p->woffset, p->size, p->boffset, p->bsize);
            *prevptr = p->next;
        }
        else
        {
            prevptr = &p->next;
        }
    }

    if (d)
    {   //if (overlap) /* ordering to put overlaps at head of list (will happen last) */
        //    prevptr = &dyninit_list;

        d->next = *prevptr;
        *prevptr = d;
    }

    if (overlap) printf("Overlapping initialiser\n");

    return overlap;
}

static bool eliminate_dynamic_init()
{
    if (dyninit_list == 0 || staticgetnowrite()) return NO;
    return InsertDynInit(NULL);
}

static bool dynamic_init(Expr *e, bool full)
{   DynInitList *d;
    if (!initauto || language_flavour < FLAVOUR_C99) return NO;

    if (!full) e = mkbinary(s_init, forge_initlhs(), e);

    //printf("Dynamic init: woffset=%ld, boffset=%ld, bsize=%ld\n", cur_initoff - initoff, initboffset, initbsize);
    d = MkDynInit(inittype, e, cur_initoff - initoff, initboffset, initbsize, initbsize ? sizeof_int : sizeoftype(inittype));
    InsertDynInit(d);
    return YES;
}

static Expr *vg_get_dyninit(bool toplevel)
{
    DynInitList *d; Expr *e;
    for (d = dyninit_list, e = 0; d; d=d->next)
    {
        //printf("Using init (w=%ld, s=%ld, boff=%ld, bsize=%ld)\n", d->woffset, d->size, d->boffset, d->bsize);
        e = e ? mkbinary(s_comma, e, d->expr) : d->expr;
    }
    dyninit_list = 0;
    return e;
}

static int32 vg_get_dyninit_coverage(int32 c)
{   DynInitList *d;
    int32 b = 0;
    //printf("dyninit coverage from %ld ", c);
    for (d = dyninit_list; d; d = d->next)
    {
        if (d->woffset > c) break;
        if (d->bsize)
        {   if (d->woffset < c) syserr("dyninit_coverage");
            if (d->boffset > b) break;
            if (d->boffset + d->bsize > b)
                b = d->boffset + d->bsize;
            if (b == d->size) c += d->size, b = 0;
        }
        else
        {   b = 0;
            if (d->woffset + d->size > c)
                c = d->woffset + d->size;
        }
    }
    //printf("= %ld\n", c);
    return c;
}


/* end of vargen.c */
