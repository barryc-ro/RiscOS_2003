;;;; arm.peeppat
;;;; Copyright (C) Advanced Risc Machines Ltd., 1991
;;;; raw peepholer patterns for the arm peepholer

;;;;
;;;; RCS $Revision$
;;;; Checkin $Date$
;;;; Revising $Author$
;;;;

;;;; IDJ (Acorn) 5-Aug-94: for patterns 20-23 added && peep & P_RSHIFT == 0 to B(...)

;;; Tidy up after andk+andk peephole
;;;# 1
( ( A(op == J_ANDK) )
  ( (== A.m 0) )
  ( (= A.op J_MOVK) )
)

;;;# 2
( ( A(op == J_PUSHC) )
  ( (== A.m 0) )
  ( (kill A) )
)

;;;# 3
; the resulting SHLK can be combined with later RR ops.
( ( A(op == J_ADDR && peep == 0) )
  ( (== A.r2 A.r3) )
  ( (= A.op J_SHLK)
    (= A.m 1)
  )
)

;;;# 4
( ( A(op == J_ADDK && peep == 0)
  )
  ( (== A.m 0)
  )
  ( (= A.op J_MOVR)
    (= A.r3 A.r2)
    (= A.r2 0)
  )
)

;;;# 5
;;; movr a, a => noop (remove junk from earlier peepholes - remove_noops()
;;; in flowgraf.c filters such things from the input to localcg).
( ( A(op == J_MOVR && peep == 0)
  )
  ( (== A.r1 A.r3)
  )
  ( (kill A)
  )
)

;;;# 6
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r2 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r3)
    (kill A)
  )
)

;;;# 7
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r3 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r3) )
  ( (= B.r3 A.r3)
    (kill A)
  )
)

;;;# 8
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r1 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r1) )
  ( (= B.r1 A.r3)
    (kill A)
  )
)

;;;# 9
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r2 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r3) )
)

;;;# 10
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r3 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r3) )
  ( (= B.r3 A.r3) )
)

;;;# 11
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    B(uses_r1 &! op <- (J_MOVC J_CLRC J_PUSHC J_CALLR J_MULR J_MLA))
  )
  ( (== A.r1 B.r1) )
  ( (= B.r1 A.r3) )
)

;;;# 12
( ( A(op == J_MOVR && dead_r3)
    B(op <- (J_MOVC J_PUSHC))
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.m)
    (= B.r4 (| B.r4 (bit A.r1)))
    (kill A)
  )
)

;;;# 13
( ( A(op == J_MOVR)
    B(op <- (J_MOVC J_PUSHC))
  )
  ( (== A.r1 B.r2)
    (movc_pres_r1r2 B 0)
  )
  ( (= B.r2 A.m)
    (= B.r4 (| B.r4 (bit A.r1)))
    (kill A)
  )
)

;;;# 14
( ( A(op == J_MOVR && dead_r3)
    B(op <- (J_MOVC J_CLRC))
  )
  ( (== A.r1 B.r1) )
  ( (= B.r1 A.m)
    (= B.r4 (| B.r4 (bit A.r1)))
    (kill A)
  )
)

;;;# 15
( ( A(op == J_MOVR)
    B(op <- (J_MOVC J_CLRC))
  )
  ( (== A.r1 B.r1)
    (movc_pres_r1r2 B (& A.dataflow J_DEAD_R2))
  )
  ( (= B.r1 A.m)
    (= B.r4 (| B.r4 (bit A.r1)))
    (kill A)
  )
)

;;;# 16
; I suppose the peep & (P_PRE+P_POST+P_CMPZ) == 0 is just an over-explicit way
; of saying 'has no side effects'.
( ( A(sets_r1 && peep & (P_PRE+P_POST+P_CMPZ) == 0)
    B(sets_r1)
  )
  ( (== A.r1 B.r1)
    (notcall B)
  )
  ( (kill A) )
)

;;;# 17
( ( A(op <- (J_MULR J_MLA))
    B(op == J_MOVR && peep & P_CMPZ == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r1 A.r3)
    (regset_unused (bit B.r1))
  )
  ( (= A.r1 B.r1)
    (kill B)
  )
)

;;;# 18
( ( A(op <- (J_MULR J_MLA))
    B(op == J_MOVR && peep & P_CMPZ == 0)
  )
  ( (== A.r1 B.r3)
    (== B.r1 A.r3)
    (!= B.r1 A.r2)
    (regset_unused (bit B.r1))
  )
  ( (swapr2r3 A)
    (= A.r1 B.r1)
    (kill B)
  )
)

;;;# 19
( ( A(sets_r1 &! op <- (J_MULR J_MLA))
    B(op == J_MOVR && peep & P_CMPZ == 0)
  )
  ( (== A.r1 B.r3)
    (regset_unused (bit B.r1))
  )
  ( (kill B)
    (= A.r1 B.r1)
  )
)

;;;# 20
( ( A(op == J_MULR && peep == 0)
    B(op == J_ADDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r1 A.r3)
  )
  ( (kill A)
    (= B.op J_MLA)
    (= B.r2 A.r2)
    (= B.r3 A.r3)
    (= B.r4 B.r2)
  )
)

;;;# 21
( ( A(op == J_MULR && peep == 0)
    B(op == J_ADDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (== B.r1 A.r3)
    (!= B.r1 A.r2)
  )
  ( (kill A)
    (= B.op J_MLA)
    (= B.r2 A.r3)
    (= B.r3 A.r2)
    (= B.r4 B.r2)
  )
)

;;;# 22
( ( A(op == J_MULR && peep == 0)
    B(op == J_ADDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r1 A.r3)
  )
  ( (kill A)
    (= B.op J_MLA)
    (= B.r2 A.r2)
    (= B.r3 A.r3)
    (= B.r4 B.r3)
  )
)

;;;# 23
( ( A(op == J_MULR && peep == 0)
    B(op == J_ADDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (== B.r1 A.r3)
    (!= B.r1 A.r2)
  )
  ( (kill A)
    (= B.op J_MLA)
    (= B.r2 A.r3)
    (= B.r3 A.r2)
    (= B.r4 B.r3)
  )
)

;;;# 24
( ( A(op == J_ADDK)
    B(op == J_B)
  )
  ( (== A.r1 R_SP)
    (== A.r2 R_SP)
    (== B.m RETLABV)
    (regset_unused M_SP)
    (notleafproc)
  )
  ( (kill A) )
)

;;;# 25
( ( A(op == J_ADDK)
    B(op <- (J_TAILCALLK J_TAILCALLR))
  )
  ( (== A.r1 R_SP)
    (== A.r2 R_SP)
    (regset_unused M_SP)
    (notleafproc)
  )
  ( (kill A) )
)

;;;# 26
( ( A(op <- (J_MOVC J_PUSHC))
    B(op == J_B)
  )
  ( (== B.m RETLABV) )
  ( ( { bool changed = NO;
        IGNORE(ops);
        if (p_value_unused(u, R_A2)) { A->peep |= P_A2FREE; changed = YES; }
        if (p_value_unused(u, R_A3)) { A->peep |= P_A3FREE; changed = YES; }
        if (p_value_unused(u, R_LR) &&
            ((procflags & NONLEAF) || (regmask & M_LR))) {
          A->peep |= P_LRFREE; changed = YES;
        }
        return changed;
      }
    A)
  )
)

;;;# 27
( ( A(op <- (J_MOVC J_PUSHC))
    B(op == J_CALLK)
  )
  (   )
  ( ( { IGNORE(ops);
        if (p_value_unused(u, R_LR)) { A->peep |= P_LRFREE; return YES; }
        return NO;
      }
    A)
  )
)

;;;# 28
( ( A(op == J_NOTR && peep == 0)
    B(op == J_ANDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3) )
  ( (kill A)
    (= B.r3 A.r3)
    (= B.op J_BICR)  ; original allowed A to have a literal shift
                     ; in this replacement, but ruled it out in the
                     ; pattern
  )
)

;;;# 29
( ( A(op == J_NOTR && peep & ~P_RSHIFT == 0 &! peep == 0)
    B(op == J_ANDR && peep & P_RSHIFT == 0)
  )
  ( (regset_unkilled (bit A.r4))
    (== A.r1 B.r3) )
  ( (kill A)
    (= B.r4 A.r4)
    (= B.peep (| B.peep (& A.peep P_RSHIFT)))
    (= B.r3 A.r3)
    (= B.op J_BICR)  ; original allowed A to have a literal shift
                     ; in this replacement, but ruled it out in the
                     ; pattern
  )
)

;;;# 30
( ( A(op == J_NOTR && peep == 0)
    B(op == J_ANDR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2) )
  ( (kill A)
    (swapr2r3 B)
    (= B.r3 A.r3)
    (= B.op J_BICR)  ; original allowed A to have a literal shift
                     ; in this replacement, but ruled it out in the
                     ; pattern
  )
)

;;;# 31
( ( A(op == J_NOTR && peep & ~P_RSHIFT == 0 &! peep == 0)
    B(op == J_ANDR && peep & P_RSHIFT == 0)
  )
  ( (regset_unkilled (bit A.r4))
    (== A.r1 B.r2) )
  ( (kill A)
    (swapr2r3 B)
    (= B.r4 A.r4)
    (= B.peep (| B.peep (& A.peep P_RSHIFT)))
    (= B.r3 A.r3)
    (= B.op J_BICR)  ; original allowed A to have a literal shift
                     ; in this replacement, but ruled it out in the
                     ; pattern
  )
)

;;;# 32
( ( A(op == J_MOVR && peep == 0)
    B(op <- (J_CMPK+Q_EQ J_CMPK+Q_NE J_CMPK+Q_UEQ J_CMPK+Q_UNE))
  )
  ( (== B.r2 A.r3)
    (== B.m 0)
    (regset_unkilled M_PC)
  )
  ( (kill B)
    (= A.peep (| (| A.peep P_CMPZ) (& B.op Q_MASK)))
  )
)

;;;# 33
( ( A(op & ~(J_SHIFTMASK+J_SIGNED+J_UNSIGNED) <-
            (       J_MOVR
                    J_NEGR
                    J_NOTR
             J_ADDK J_ADDR
                    J_SUBR ; J_SUBK turned early into J_ADDK
             J_RSBK J_RSBR
             J_ANDK J_ANDR
                    J_BICR
             J_ORRK J_ORRR
             J_EORK J_EORR
             J_SHLR J_SHLK
             J_SHRR J_SHRK
             J_RORR J_RORK
             J_MULR J_MULK
             J_MLA) &&

      peep & ~P_RSHIFT == 0)

    B(op <- (J_CMPK+Q_EQ J_CMPK+Q_NE J_CMPK+Q_UEQ J_CMPK+Q_UNE) &&
      dead_r2)
  )
  ( (regset_unkilled M_PC)
    (regset_unused (bit A.r1))
    (== B.r2 A.r1)
    (== B.m 0)
    (== A.cond Q_AL)
  )
  ( (kill B)
    (= A.dataflow (| A.dataflow J_DEAD_R1))
    (= A.peep (| (| A.peep P_CMPZ) (& B.op Q_MASK)))
  )
)

;;;# 34
( ( A(op & ~(J_SHIFTMASK+J_SIGNED+J_UNSIGNED) <-
            (       J_MOVR
                    J_NEGR
                    J_NOTR
             J_ADDK J_ADDR
                    J_SUBR ; J_SUBK turned early into J_ADDK
             J_RSBK J_RSBR
             J_ANDK J_ANDR
                    J_BICR
             J_ORRK J_ORRR
             J_EORK J_EORR
             J_SHLR J_SHLK
             J_SHRR J_SHRK
             J_RORR J_RORK
             J_MULR J_MULK
             J_MLA) &&


      peep & ~P_RSHIFT == 0)

    B(op <- (J_CMPK+Q_EQ J_CMPK+Q_NE J_CMPK+Q_UEQ J_CMPK+Q_UNE))
  )
  ( (regset_unkilled M_PC)
    (== B.r2 A.r1)
    (== B.m 0)
    (== A.cond Q_AL)
  )
  ( (kill B)
    (= A.peep (| (| A.peep P_CMPZ) (& B.op Q_MASK)))
  )
)

;;; ORRK a, b, c; ANDK d, a, e => ANDK a, b, e; ORRK d, a, c&e.
;;;   This is chiefly to give the ANDK + ANDK and ORRK + ORRK
;;;   peepholes a better chance.
;;;# 35
( ( A(op == J_ORRK)
    B(op == J_ANDK && dead_r2)
  )
  ( (== A.r1 B.r2)
    (regset_unused (bit A.r1))
    (regset_unkilled (bit B.r2))
  )
  ( (= A.m B.m)         ;) in parallel
    (= B.m (& A.m B.m)) ;)
    (= A.op J_ANDK)
    (= B.op J_ORRK)
  )
)

;;;# 36
( ( A(op == J_ANDK)
    B(op == J_ORRK)
  )
  ( (== A.r1 B.r2)
    (==  (| A.m B.m) -1)
  )
  ( (= B.r2 A.r2)
    (kill A)
  )
)

;;;# 37
( ( A(op == J_ANDK)
    B(op == J_ANDK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r2)
    (= B.m (& A.m B.m))
    (kill A)
  )
)

;;;# 38
( ( A(op == J_ORRK)
    B(op == J_ORRK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r2)
    (= B.m (| A.m B.m))
    (kill A)
  )
)

;;;# 39
( ( A(op == J_EORK)
    B(op == J_EORK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r2)
    (= B.m (^ A.m B.m))
    (kill A)
  )
)

;;;# 40
( ( A(op == J_ADDK)
    B(op == J_ADDK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.r2 A.r2)
    (= B.m (+ A.m B.m))
    (kill A)
  )
)

;;;; At the moment we've lost deadr2(B) & unused(A.r1) => kill A from this set.
;;;# 41
( ( A(op == J_MOVK)
    B(op == J_ANDK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.m (& A.m B.m))
    (= B.op J_MOVK)
  )
)

;;;# 42
( ( A(op == J_MOVK)
    B(op == J_ORRK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.m (| A.m B.m))
    (= B.op J_MOVK)
  )
)

;;;# 43
( ( A(op == J_MOVK)
    B(op == J_EORK)
  )
  ( (== A.r1 B.r2) )
  ( (= B.m (^ A.m B.m))
    (= B.op J_MOVK)
  )
)

;;;# 44
( ( A(op == J_MOVK)
    B(op == J_ADDK)
  )
  ( (== A.r1 B.r2)
    (|| (! (difficult_constant (+ A.m B.m)))
        (! (difficult_constant (^ 0xffffffffl (+ A.m B.m)))))
  )
  ( (= B.m (+ A.m B.m))
    (= B.op J_MOVK)
  )
)

;;;# 45
( ( A(op == J_MOVK && peep == 0)
    B(op == J_SUBR)
  )
  ( (== A.r1 B.r2) )
  ( (kill A)
    (= B.op J_RSBK)
    (swapr2r3 B)
    (= B.m A.m)
  )
)


;;; This fixes up shortcomings in dead-code elimination, whereby dead compares
;;; get left.  The value for the earlier compare can't be used, because
;;; branches and condexec flush the peephole buffer.
;;; (If this peephole is removed, compares must kill PC)
;;;# 46
( ( A(op & ~Q_MASK <- (J_CMPK J_CMPR J_CMPFK J_CMPFR J_CMPDK J_CMPDR))
    B(op & ~Q_MASK <- (J_CMPK J_CMPR J_CMPFK J_CMPFR J_CMPDK J_CMPDR))
  )
  (   )
  ( (kill A) )
)

;;; This clears up the mess left by STRW of a (large) constant
;;;# 47
( ( A(op == J_MOVK)
    B(op == J_STRBK && dead_r1)
  )
  ( (== A.r1 B.r1)
    (>u A.m 255)
    (regset_unused (bit B.r1))
  )
  ( (= A.m (& A.m 255))  )
)

;;;# 48
( ( A(op == J_MOVIDR)
    B(op == J_PUSHD && dead_r1)
  )
  ( (== A.r1 B.r1)
    (regset_unkilled (bit A.r2))
    (regset_unkilled (bit A.r3))
   )
  ( (= B.op J_PUSHM)
    (= B.m (| (bit A.r2) (bit A.r3)))
    (kill A)
  )

)

;;;# 49
;;; ADDK x,12,#n is how ADCONV x, <something> arrives at gen
;;; (and ADDK x,12,#0 has been turned into MOVR x,-,12 earlier)
( ( A(op == J_MOVR)
    B(op & ~(J_SIGNED+J_UNSIGNED+J_NEGINDEX+J_SHIFTMASK) <-
              (J_LDRFR J_LDRDR J_STRFR J_STRDR
               J_LDRBR J_LDRWR J_LDRR J_STRBR J_STRR)) ; STRWR case avoided on arm
  )
  ( (== A.peep 0)
    (== A.r1 B.r2)
  )
  ( (= B.r2 A.r3)
    (kill A)
  )
)

;;;# 50
( ( A(op == J_ADDK && peep == 0)
    B(op <- (J_LDRFK J_LDRDK J_STRFK J_STRDK))
  )
  ( (== A.r1 A.r2)
    (== B.m 0)
    (>= A.m -0x3fc) (<= A.m 0x3fc)
    (== B.r2 A.r1)
  )
  ( (= B.peep P_PRE)
    (= B.m A.m)
    (kill A)
  )
)

;;;# 51
( ( A(op == J_ADDK && peep == 0)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_STRBK J_LDRBK J_LDRWK J_LDRK J_STRK)) ; STRWK avoided
  )
  ( (== A.r1 A.r2)
    (== B.m 0)
    (>= A.m -0xfff) (<= A.m 0xfff)
    (== B.r2 A.r1)
    (!= B.r1 B.r2)
  )
  ( (= B.peep P_PRE)
    (= B.m A.m)
    (kill A)
  )
)

;;;# 52
( ( A(op == J_ADDK && peep == 0)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_LDRBK J_LDRWK J_LDRK) && dead_r2) ; STRWK avoided
  )
  ( (== A.r1 B.r2)
    (>= (+ B.m A.m) -0xfff) (<= (+ B.m A.m) 0xfff)
  )
  ( (kill A)
    (= B.r2 A.r2) (= B.m (+ A.m B.m))
  )
)

;;;# 53
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_STRBK J_LDRBK J_LDRWK J_LDRK J_STRK) &&  ; STRWK avoided
      peep == 0)
    B(op == J_ADDK)
  )
  ( (== A.m 0)
    (!= A.r2 R_SP)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (!= B.r1 A.r1)
    (>= B.m -0xfff) (<= B.m 0xfff)
    (regset_unused (bit A.r2))
  )
  ( (kill B)
    (= A.m B.m)
    (= A.peep P_POST)
  )
)

;;;# 54
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_STRBK J_LDRBK J_LDRWK J_LDRK J_STRK) &&  ; STRWK avoided
      peep == P_POST)
    B(op == J_ADDK)
  )
  ( (== B.r1 A.r2)
    (!= A.r2 R_SP)
    (== B.r1 B.r2)
    (!= B.r1 A.r1)
    (>= (+ A.m B.m) -0xfff) (<= (+ A.m B.m) 0xfff)
    (regset_unused (bit A.r2))
  )
  ( (kill B)
    (= A.m (+ A.m B.m))
  )
)

;;;# 55
( ( A(op <- (J_LDRFK J_LDRDK J_STRFK J_STRDK) &&
      peep == 0)
    B(op == J_ADDK)
  )
  ( (== A.m 0)
    (!= A.r2 R_SP)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (>= B.m -0x3fc) (<= B.m 0x3fc)
    (regset_unused (bit A.r2))
  )
  ( (kill B)
    (= A.m B.m)
    (= A.peep P_POST)
  )
)

;;;# 56
( ( A(op <- (J_LDRFK J_LDRDK J_STRFK J_STRDK) &&
      peep == P_POST)
    B(op == J_ADDK)
  )
  ( (== B.r1 A.r2)
    (!= A.r2 R_SP)
    (== B.r1 B.r2)
    (>= (+ A.m B.m) -0x3fc) (<= (+ A.m B.m) 0x3fc)
    (regset_unused (bit A.r2))
  )
  ( (kill B)
    (= A.m (+ A.m B.m))
  )
)

;;;# 57
( ( A(op & ~(J_SIGNED+J_UNSIGNED+J_NEGINDEX) <- (J_LDRBK J_LDRBR))
    B(op == J_ANDK)
  )
  ( (== B.m 255)
    (== A.r1 B.r2)
    (== B.r1 B.r2)
  )
  ( (kill B) )
)

;;;# 58
( ( A(op == J_MOVR && peep & P_CMPZ == 0)
    X()
    B(op == J_MOVC && dead_r1)
  )
  ( (== A.r3 R_SP)
    (== B.r1 A.r1)
    (nostackrefsbelow A B.m)
  )
  ( (= A.op J_ADDK)
    (= A.r1 R_SP)
    (= A.r2 R_SP)
    (= A.m B.m)
    (= A.dataflow (| A.dataflow J_DEAD_R2))
    (= X.op J_ADDK)
    (= X.r1 B.r2)
    (= X.r2 B.r2)
    (= X.m B.m)
    (= X.dataflow J_DEAD_R2)
    (= X.r4 0)
    (= B.op J_PUSHC)
    (= B.r1 A.r3)
    (adjuststackrefs A B.m)
  )
)

;;;# 59
( ( A(op == J_MOVC && peep & P_POST == 0)
    B(op == J_ADDK && peep == 0)
  )
  ( (== A.r2 B.r2)
    (== B.r1 B.r2)
    (== A.m B.m)
    (!= A.r2 R_SP)
    (regset_unused (bit A.r2))
  )
  ( (kill B)
    (= A.peep (| A.peep P_POST))
  )
)

;;;; Two peepholes to improve handling of loading fp arguments into
;;;; integer registers.
;;;# 60
( ( A(op == J_LDRDK && peep & P_POST == 0)
    B(op == J_MOVDIR && dead_r3)
  )
  ( (== A.r1 B.r3)
    (regset_unused (bit B.r1)) (regset_unused (bit B.r2))
    (regset_unused (bit A.r1))
  )
  ( (= A.op J_POPMB)
    (= A.r1 (+ A.m 8))
    (= A.m (| (bit B.r1) (bit B.r2)))
    (kill B)
  )
)

;;;# 61
( ( A(op == J_MOVDK)
    B(op == J_MOVDIR && dead_r3)
  )
  ( (== A.r1 B.r3)
    (regset_unused (bit B.r1)) (regset_unused (bit B.r2))
    (regset_unused (bit A.r1))
  )
  ( (= A.op J_ADCOND)
    (= A.r1 B.r1)
    (= B.op J_POPMB)
    (= B.r2 B.r1)
    (= B.r1 8)
    (= B.m (| (bit B.r1) (bit B.r2)))
  )
)

;;;; 4 peepholes to do shift by register + arithlogical op => noop + scaled op
;;;# 62
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLR J_SHRR J_RORR) &&
      peep == 0)
    B(op <- (J_ADDR J_SUBR J_RSBR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
    (regset_unkilled (bit A.r3))
  )
  ( (kill A)
    (= B.peep (| B.peep (shift_p A.op)))
    (= B.r4 A.r3)
    (= B.r3 A.r2)
  )
)

;;;# 63
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLR J_SHRR J_RORR) &&
      peep == 0)
    B(op & ~(J_SIGNED | J_UNSIGNED | Q_MASK) == J_CMPR  &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
    (regset_unkilled (bit A.r3))
  )
  ( (kill A)
    (= B.peep (| B.peep (shift_p A.op)))
    (= B.r4 A.r3)
    (= B.r3 A.r2)
  )
)

;;;# 64
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLR J_SHRR J_RORR) &&
      peep == 0)
    B(op <- (J_ADDR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
    (regset_unkilled (bit A.r3))
  )
  ( (kill A)
    (swapr2r3 B)
    (= B.peep (| B.peep (shift_p A.op)))
    (= B.r4 A.r3)
    (= B.r3 A.r2)
  )
)

;;;# 65
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLR J_SHRR J_RORR) &&
      peep == 0)
    B(op <- (J_SUBR J_RSBR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
    (regset_unkilled (bit A.r3))
  )
  ( (kill A)
    (swapr2r3 B)
    (= B.peep (| B.peep (shift_p A.op)))
    (= B.op (^ B.op J_SUBR^J_RSBR))
    (= B.r4 A.r3)
    (= B.r3 A.r2)
  )
)

;;;; 4 peepholes to do shift by constant + arithlogical op => noop + scaled op
;;;; (TARGET_HAS_SCALED... means that often this will already have been
;;;;  done in cg, but this sweeps up cases where the constant shift was
;;;;  invented later).
;;;# 66
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op <- (J_ADDR J_SUBR J_RSBR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;# 67
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op & ~(J_SIGNED | J_UNSIGNED | Q_MASK) == J_CMPR  &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;# 68
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op <- (J_ADDR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (swapr2r3 B)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;# 69
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op <- (J_SUBR J_RSBR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (swapr2r3 B)
    (= B.op (| (^ B.op J_SUBR^J_RSBR) (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;; the next two are different because the constraints implied
;;;; by the replacements are different.
;;;# 70
( ( A(op <- (J_ADCON J_STRING))
    B(op == J_ADDK && dead_r2)
  )
  ( (== A.r1 B.r2)
    (regset_unused (bit B.r1))
  )
  ( (= A.r1 B.r1)
    (= A.r2 (+ A.r2 B.m))
    (kill B)
  )
)

;;;# 71
( ( A(op <- (J_ADCON J_STRING))
    B(op == J_ADDK && dead_r2)
  )
  ( (== A.r1 B.r2)
  )
  ( (kill A)
    (= B.op A.op)
    (= B.r2 (+ A.r2 B.m))
    (= B.m A.m)
  )
)

;;;; Peepholes to handle structure argument passing across the boundary between
;;;; registers and stack, turning push followed by partial pop into partial
;;;; push and direct load of the rest. No longer works since the demise of POPM.
;;;;# 72
;( ( A(op == J_PUSHM)
;    B(op == J_POPMX)
;  )
;  ( (==  (& A.m B.m) A.m)
;    (regset_unkilled A.m)
;    (regset_unkilled M_SP)
;    (> (lsb (^ B.m A.m)) A.m )
;    (nostackrefsbelow A (bitcount A.m))
;  )
;  ( (adjuststackrefs A (bitcount A.m))
;    (kill A)
;    (= B.m (^ B.m A.m))
;  )
;)
;
;;;;# 73
;( ( A(op == J_MOVC)
;    B(op == J_POPMX)
;  )
;  ( )
;  ( ( { bool changed = NO;
;        IGNORE(ops);
;        if ((ops[0]->m & regbit(R_A2)) && p_value_unused(u, R_A2)) { A->peep |= P_A2FREE; changed = NO; }
;        if ((ops[0]->m & regbit(R_A3)) && p_value_unused(u, R_A3)) { A->peep |= P_A3FREE; changed = NO; }
;        return changed;
;      }
;    A)
;  )
;)
;
;;;;# 74
;( ( A(op == J_PUSHC)
;    B(op == J_POPMX)
;  )
;  ( (regset_unkilled M_SP)
;    (<= (bitcount B.m) A.m)
;    (nostackrefsbelow A (bitcount B.m))
;    (regset_unused (bit A.r2))
;  )
;  ( (= A.m (- A.m (bitcount B.m)))
;    (= A.dataflow (& A.dataflow 0xffffffffl-J_DEAD_R2))
;    (= B.op J_POPMB)
;    (= B.r1 0)
;    (= B.r2 A.r2)
;    (adjuststackrefs A (bitcount B.m))
;    ( { bool changed = NO;
;        IGNORE(ops);
;        if ((ops[0]->m & regbit(R_A2)) && p_value_unused(u, R_A2)) { A->peep |= P_A2FREE; changed = NO; }
;        if ((ops[0]->m & regbit(R_A3)) && p_value_unused(u, R_A3)) { A->peep |= P_A3FREE; changed = NO; }
;        return changed;
;      }
;    A)
;  )
;)
;
;;;;# 75
;( ( A(op == J_PUSHC)
;    B(op == J_POPMX)
;  )
;  ( (regset_unkilled M_SP)
;    (==  (bitcount B.m) A.m)
;    (nostackrefsbelow A A.m)
;    (regset_unused (lsb B.m))
;  )
;  ( (= A.op J_ADDK) (= A.r1 (log2 (lsb B.m))) (= A.m 0) (= A.peep 0)
;    (= B.op J_POPMB)
;    (= B.r1 0)
;    (= B.r2 (log2 (lsb B.m)))
;    (adjuststackrefs A (bitcount B.m))
;  )
;)

;;;# 72
;;; The explicit constraint unkilled A.r2 in the following two peepholes is
;;; there because peepgen can't currently deduce it because it can't cope with
;;; registers in the r4 field.  (But there's no need for a unkilled A.r3 in the
;;; second peephole, because it can handle those).
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_LDRK)
    B(op == J_CALLR)
  )
  ( (!= A.r2 R_LR)
    (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op J_CALLI)
    (= B.m A.m)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 73
( ( A(op & ~(J_SIGNED+J_UNSIGNED+J_NEGINDEX+J_SHIFTMASK) == J_LDRR)
    B(op == J_CALLR)
  )
  ( (!= A.r2 R_LR) (!= A.r3 R_LR)
    (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| J_CALLIR (& A.op J_SHIFTMASK+J_NEGINDEX)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 74
;;; Expansion of the TAILCALL jopcodes is prepared to find the destination
;;; in a register expansion of the jopcode will destroy before its needed.
;;; So no check in the next two peepholes for not R_LR.
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_LDRK)
    B(op == J_TAILCALLR)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op J_TAILCALLI)
    (= B.m A.m)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 75
( ( A(op & ~(J_SIGNED+J_UNSIGNED+J_NEGINDEX+J_SHIFTMASK) == J_LDRR)
    B(op == J_TAILCALLR)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| J_TAILCALLIR (& A.op J_SHIFTMASK+J_NEGINDEX)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;; movr a,b then movr b,a => movr a,b + noop.
;;; kills some unintelligent argument juggling, as in
;;; f(a, b) { g(a, b); code using a & b }
;;;# 76
( ( A(op == J_MOVR && peep & P_RSHIFT == 0)
    B(op == J_MOVR && peep == 0)
  )
  ( (== A.r1 B.r3)
    (== A.r3 B.r1)
    (regset_unkilled (bit B.r1))
    (regset_unkilled (bit B.r3))
  )
  ( (kill B)
  )
)

;;; comparison of unsigned bitfield against 0
;;;# 77
( ( A(op == J_MOVK)
    B(op & ~(J_SHIFTVAL+J_SHIFTA) == J_ANDR+J_SHIFTR && dead_r1 &! peep & P_CMPZ == 0)
  )
  ( (== A.r1 B.r2)
  )
  ( (kill A)
    (= B.op J_ANDK)
    (swapr2r3 B)
    (= B.m (<< A.m
               (>> (& B.op J_SHIFTVAL)
                   J_SHIFTPOS)))
  )
)

;;; comparison of signed bitfield against 0
;;;# 78
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_SHLK)
    B(op == J_MOVK)
    C(op & ~J_SHIFTVAL <- (J_CMPR+J_SHIFTR+J_SHIFTA+Q_EQ J_CMPR+J_SHIFTR+J_SHIFTA+Q_NE))
  )
  ( (== B.m 0)
    (== C.r2 B.r1)
    (== C.r3 A.r1)
  )
  ( (kill A)
    (= C.op J_ANDK) (= C.r1 C.r3) (= C.r2 C.r3)
    (= C.m (<< (- (bit (- 32
                          (>> (& C.op J_SHIFTVAL)
                              J_SHIFTPOS)))
                  1)
               (- (>> (& C.op J_SHIFTVAL)
                      J_SHIFTPOS)
                  A.m)))
    (= C.peep (| P_CMPZ (& C.op Q_MASK)))
  )
)

;;; store of one bitfield into another gives a redundant mask
;;; (currently doesn't work too well, because the required (unkilled A.r1 (A B))
;;; is widened (since the range isn't representable) to ( - - (A C))
;;;# 79
( ( A(op == J_MOVK)
    B(op & ~J_SHIFTMASK == J_ANDR)
    C(op == J_ANDK)
  )
  ( (== A.r1 B.r2)
    (== C.r1 C.r2)
    (== C.r2 B.r1)
    (== (& A.m C.m) A.m)
  )
  ( (kill C)
  )
)

; store of a signed bitfield into a field of the same width gives unnecessary sign-extension
;;;# 80
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_SHLK)
    B(op == J_SHRK+J_SIGNED)
    C(op == J_ANDK && dead_r2)
  )
  ( (== A.r1 B.r2)
    (== B.r1 C.r2)
    (== (+ C.m 1) (bit (- 32 B.m)))
  )
  ( (kill A)
    (= B.m (- B.m A.m))
  )
)

;;;# 81
( ( A(op & ~(J_SHIFTMASK+J_SIGNED+J_UNSIGNED) <-
            (       J_MOVR
                    J_NEGR
                    J_NOTR
             J_ADDK J_ADDR
                    J_SUBR ; J_SUBK turned early into J_ADDK
             J_RSBK J_RSBR
             J_ANDK J_ANDR
                    J_BICR
             J_ORRK J_ORRR
             J_EORK J_EORR
             J_SHLR J_SHLK
             J_SHRR J_SHRK
             J_RORR J_RORK
             J_MULR J_MULK
             J_MLA) &&

      peep & ~P_RSHIFT == 0)

    B(op <- (J_CMPK+Q_LT J_CMPK+Q_GE) && dead_r2)
    C(op <- (J_B+Q_LT J_CONDEXEC+Q_LT J_B+Q_GE J_CONDEXEC+Q_GE))
  )
  ( (regset_unused (bit A.r1))
    (== B.r2 A.r1)
    (== B.m 0)
    (== A.cond Q_AL)
  )
  ( (kill B)
    (= A.dataflow (| A.dataflow J_DEAD_R1))
    (= A.peep (| (| A.peep P_CMPZ)
                 (+ (& C.op Q_MASK) Q_MI-Q_LT)))
    (= C.op (+ C.op Q_MI-Q_LT))
  )
)

;;;# 82
( ( A(op & ~(J_SHIFTMASK+J_SIGNED+J_UNSIGNED) <-
            (       J_MOVR
                    J_NEGR
                    J_NOTR
             J_ADDK J_ADDR
                    J_SUBR ; J_SUBK turned early into J_ADDK
             J_RSBK J_RSBR
             J_ANDK J_ANDR
                    J_BICR
             J_ORRK J_ORRR
             J_EORK J_EORR
             J_SHLR J_SHLK
             J_SHRR J_SHRK
             J_RORR J_RORK
             J_MULR J_MULK
             J_MLA) &&

      peep & ~P_RSHIFT == 0)

    B(op <- (J_CMPK+Q_LT J_CMPK+Q_GE))
    C(op <- (J_B+Q_LT J_CONDEXEC+Q_LT J_B+Q_GE J_CONDEXEC+Q_GE))
  )
  ( (== B.r2 A.r1)
    (== B.m 0)
    (== A.cond Q_AL)
  )
  ( (kill B)
    (= A.peep (| (| A.peep P_CMPZ)
                 (+ (& C.op Q_MASK) Q_MI-Q_LT)))
    (= C.op (+ C.op Q_MI-Q_LT))
  )
)

;;; movk a, n + <op>k b,c,n => movk a, n + <op>r b, c, a
;;;# 83
( ( A(op == J_MOVK)
    B(op <- (J_ADDK J_SUBK J_RSBK J_ANDK J_ORRK J_EORK))
  )
  ( (== A.m B.m)
    (regset_unkilled (bit A.r1))
  )
  (  (= B.op (+ B.op 1))    ; rk -> rr
     (= B.r3 A.r1)
  )
)

;;; in  store or load somewhere, then load from same place  replace second
;;; load with MOVR.  I think the simple case (arising from spilled binders)
;;; is all that needs doing: more complicated cases having already been
;;; fixed up (CSE?).
;;;# 84
( ( A(op <- (J_STRK J_LDRK) && peep & (P_PRE+P_POST) == 0)
    B(op == J_LDRK && peep & (P_PRE+P_POST) == 0)
  )
  ( (== A.r2 B.r2)
    (== A.m B.m)
    (== B.r2 R_SP)
    (nointervening G_STR)
  )
  ( (= B.op J_MOVR) (= B.r2 0) (= B.r3 A.r1)
  )
)

;;;# 85
( ( A(op <- (J_STRK J_LDRK) && peep & (P_PRE+P_POST) == P_PRE)
    B(op == J_LDRK && peep & (P_PRE+P_POST) == 0)
  )
  ( (== A.r2 B.r2)
    (== B.m 0)
    (== B.r2 R_SP)
    (nointervening G_STR)
  )
  ( (= B.op J_MOVR) (= B.r2 0) (= B.r3 A.r1)
  )
)

;( ( A(op == J_MOVK)
;    B(op == J_MOVK)
;  )
;  ( (difficult_constant A.m) (difficult_constant (^ A.m 0xffffffff))
;    (difficult_constant B.m) (difficult_constant (^ B.m 0xffffffff))
;    (! (difficult_constant (- B.m A.m)))
;  )
;  ( (= B.op J_ADDK) (= B.r2 A.r1) (= B.m (- B.m A.m))
;  )
;)

;;;; 4 peepholes to do mulk (k a multiple of 2^n, n>=1) + arithlogical op =>
;;;; mulk by k/2^n + scaled op.
;;;; (TARGET_HAS_SCALED... means that often this will already have been
;;;;  done in cg, but this sweeps up cases where the constant shift was
;;;;  invented later).
;;;# 86
( ( A(op == J_MULK)
    B(op <- (J_ADDR J_SUBR J_RSBR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0 && dead_r3)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
    (!= A.m 0)
    (!= (& A.m (- 0 A.m)) 1)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (/ A.m (& A.m (- 0 A.m))))
    (= B.op (| B.op (shift_k J_SHLK (log2 (& A.m (- 0 A.m))))))
  )
)

;;;# 87
( ( A(op == J_MULK)
    B(op & ~(J_SIGNED | J_UNSIGNED | Q_MASK) == J_CMPR  &&
      peep & P_RSHIFT == 0 && dead_r3)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
    (!= A.m 0)
    (!= (& A.m (- 0 A.m)) 1)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (/ A.m (& A.m (- 0 A.m))))
    (= B.op (| B.op (shift_k J_SHLK (log2 (& A.m (- 0 A.m))))))
  )
)

;;;# 88
( ( A(op == J_MULK)
    B(op <- (J_ADDR J_ANDR J_ORRR J_EORR) &&
      peep & P_RSHIFT == 0 && dead_r2)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
    (!= A.m 0)
    (!= (& A.m (- 0 A.m)) 1)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (/ A.m (& A.m (- 0 A.m))))
    (swapr2r3 B)
    (= B.op (| B.op (shift_k J_SHLK (log2 (& A.m (- 0 A.m))))))
  )
)

;;;# 89
( ( A(op == J_MULK)
    B(op <- (J_SUBR J_RSBR) &&
      peep & P_RSHIFT == 0 && dead_r2)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
    (!= A.m 0)
    (!= (& A.m (- 0 A.m)) 1)
    (regset_unused (bit A.r1))
  )
  ( (swapr2r3 B)
    (= A.m (/ A.m (& A.m (- 0 A.m))))
    (= B.op (| (^ B.op J_SUBR^J_RSBR) (shift_k J_SHLK (log2 (& A.m (- 0 A.m))))))
  )
)

;;;# 90
( ( A(op == J_ADCON)
    B(op & ~(J_SIGNED+J_UNSIGNED) == J_LDRWK &&
      peep & P_BASEALIGNED == 0)
  )
  ( (== A.r1 B.r2)
    (== (& A.r2 2) 0)
  )
  ( (= B.peep (| B.peep P_BASEALIGNED)) )
)

;;;# 91
( ( A(op == J_ADCON)
    B(op == J_LDRBK+J_SIGNED &&
      peep & P_BASEALIGNED == 0)
  )
  ( (== A.r1 B.r2)
    (== (& A.r2 3) 0)
  )
  ( (= B.peep (| B.peep P_BASEALIGNED)) )
)

;;;# 92
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_LDRWK &&
      peep & P_BASEALIGNED == 0)
  )
  ( (|| (== A.r2 R_SP)
        (== A.r2 R_FP)
    )
  )
  ( (= A.peep (| A.peep P_BASEALIGNED)) )
)

;;;# 93
( ( A(op == J_LDRBK+J_SIGNED &&
      peep & P_BASEALIGNED == 0)
  )
  ( (|| (== A.r2 R_SP)
        (== A.r2 R_FP)
    )
  )
  ( (= A.peep (| A.peep P_BASEALIGNED)) )
)

;;;# 94
( ( B()
    A(op <- (J_LDRWK+J_SIGNED J_LDRWR+J_SIGNED
             J_LDRWK+J_UNSIGNED J_LDRWR+J_UNSIGNED) &&
      peep & P_MS == 0)
  )
  ( (|| (! (config CONFIG_NO_UNALIGNED_LOADS))
        (!= (& A.peep P_BASEALIGNED) 0)
    )
  )
  ( (= B.peep (| A.peep P_MS))
    (= B.op A.op)
    (= B.r1 A.r1)
    (= B.r2 A.r2)
    (= B.m A.m)
    (= A.op (| J_SHRK (& A.op J_SIGNED)))
    (= A.r2 A.r1)
    (= A.m 16)
    (= A.peep 0)
  )
)

;;;# 95
( ( B()
    A(op <- (J_LDRBK+J_SIGNED J_LDRBR+J_SIGNED) &&
      peep & P_MS == 0)
  )
  ( (|| (! (config CONFIG_NO_UNALIGNED_LOADS))
        (!= (& A.peep P_BASEALIGNED) 0)
    )
  )
  ( (= B.peep (| A.peep P_MS))
    (= B.op A.op)
    (= B.r1 A.r1)
    (= B.r2 A.r2)
    (= B.m A.m)
    (= A.op J_SHRK+J_SIGNED)
    (= A.r2 A.r1)
    (= A.m 24)
    (= A.peep 0)
  )
)

;;;# 96
( ( A(op == J_MOVR && peep == 0)
    B(op <- (J_CMPK+Q_LT J_CMPK+Q_GE) && dead_r2)
    C(op <- (J_B+Q_LT J_CONDEXEC+Q_LT J_B+Q_GE J_CONDEXEC+Q_GE))
  )
  ( (regset_unkilled (bit A.r3))
    (== B.r2 A.r3)
    (== B.m 0)
    (== A.cond Q_AL)
  )
  ( (kill B)
    (= A.dataflow (| A.dataflow J_DEAD_R3))
    (= A.peep (| (| A.peep P_CMPZ)
                 (+ (& C.op Q_MASK) Q_MI-Q_LT)))
    (= C.op (+ C.op Q_MI-Q_LT))
  )
)

;;;# 97
( ( A(op == J_MOVR && peep == 0)
    B(op <- (J_CMPK+Q_LT J_CMPK+Q_GE))
    C(op <- (J_B+Q_LT J_CONDEXEC+Q_LT J_B+Q_GE J_CONDEXEC+Q_GE))
  )
  ( (== B.r2 A.r3)
    (== B.m 0)
    (== A.cond Q_AL)
    (regset_unkilled (bit A.r3))
  )
  ( (kill B)
    (= A.peep (| (| A.peep P_CMPZ)
                 (+ (& C.op Q_MASK) Q_MI-Q_LT)))
    (= C.op (+ C.op Q_MI-Q_LT))
  )
)

;;;# 98
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_LDRR J_STRR J_LDRBR J_STRBR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;# 99
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_LDRR J_STRR J_LDRBR J_STRBR) &&
      peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r2)
    (!= B.r2 B.r3)
  )
  ( (kill A)
    (swapr2r3 B)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;; Parallel peepholes to the four above (80-83), handling calls to a function
;;; vector (rather than function pointer vector).  Comments as for the above;
;;; in addition we need separate ADDR and SUBR peepholes, but no SUBK one
;;; because it was turned into ADDK earlier.
;;;# 100
( ( A(op == J_ADDK)
    B(op == J_CALLR)
  )
  ( (!= A.r2 R_LR)
    (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op J_CALLX)
    (= B.m A.m)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 101
( ( A(op & ~J_SHIFTMASK == J_ADDR)
    B(op == J_CALLR)
  )
  ( (!= A.r2 R_LR) (!= A.r3 R_LR)
    (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| J_CALLXR (& A.op J_SHIFTMASK)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 102
( ( A(op & ~J_SHIFTMASK == J_SUBR)
    B(op == J_CALLR)
  )
  ( (!= A.r2 R_LR) (!= A.r3 R_LR)
    (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| (| J_CALLXR J_NEGINDEX) (& A.op J_SHIFTMASK)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 103
( ( A(op == J_ADDK)
    B(op == J_TAILCALLR)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op J_TAILCALLX)
    (= B.m A.m)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 104
( ( A(op & ~J_SHIFTMASK == J_ADDR)
    B(op == J_TAILCALLR)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| J_TAILCALLXR (& A.op J_SHIFTMASK)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;;# 105
( ( A(op & ~J_SHIFTMASK == J_SUBR)
    B(op == J_TAILCALLR)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r2))
  )
  ( (= B.op (| (| J_TAILCALLXR J_NEGINDEX) (& A.op J_SHIFTMASK)))
    (= B.r3 A.r3)
    (= B.r4 A.r2)
    (= B.peep A.peep)
    (kill A)
  )
)

;;; Parallel set of peepholes to set P_POST, with base SP, so weaker
;;; constraints on intervening instructions (but adjustment of SP offsets
;;; if peephole succeeds).
;;;# 106
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_STRBK J_LDRBK J_LDRWK J_LDRK J_STRK) &&  ; STRWK avoided
      peep == 0)
    B(op == J_ADDK)
  )
  ( (== A.r2 R_SP)
    (== A.m 0)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (!= B.r1 A.r1)
    (>= B.m -0xfff) (<= B.m 0xfff)
    (nostackrefsbelow A B.m)
  )
  ( (kill B)
    (= A.m B.m)
    (= A.peep P_POST)
    (adjuststackrefs A B.m)
  )
)

;;;# 107
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_STRBK J_LDRBK J_LDRWK J_LDRK J_STRK) &&  ; STRWK avoided
      peep == P_POST)
    B(op == J_ADDK)
  )
  ( (== A.r2 R_SP)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (!= B.r1 A.r1)
    (>= (+ A.m B.m) -0xfff) (<= (+ A.m B.m) 0xfff)
    (nostackrefsbelow A B.m)
  )
  ( (kill B)
    (= A.m (+ A.m B.m))
    (adjuststackrefs A B.m)
  )
)

;;;# 108
( ( A(op <- (J_LDRFK J_LDRDK J_STRFK J_STRDK) &&
      peep == 0)
    B(op == J_ADDK)
  )
  ( (== A.r2 R_SP)
    (== A.m 0)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (>= B.m -0x3fc) (<= B.m 0x3fc)
    (nostackrefsbelow A B.m)
  )
  ( (kill B)
    (= A.m B.m)
    (= A.peep P_POST)
    (adjuststackrefs A B.m)
  )
)

;;;# 109
( ( A(op <- (J_LDRFK J_LDRDK J_STRFK J_STRDK) &&
      peep == P_POST)
    B(op == J_ADDK)
  )
  ( (== A.r2 R_SP)
    (== B.r1 A.r2)
    (== B.r1 B.r2)
    (>= (+ A.m B.m) -0x3fc) (<= (+ A.m B.m) 0x3fc)
    (nostackrefsbelow A B.m)
  )
  ( (kill B)
    (= A.m (+ A.m B.m))
    (adjuststackrefs A B.m)
  )
)

;;;# 110
( ( A(op == J_MOVC && peep & P_POST == 0)
    B(op == J_ADDK && peep == 0)
  )
  ( (== A.r2 R_SP)
    (== A.r2 B.r2)
    (== B.r1 B.r2)
    (== A.m B.m)
    (nostackrefsbelow A B.m)
  )
  ( (kill B)
    (= A.peep (| A.peep P_POST))
    (adjuststackrefs A B.m)
  )
)

;;;# 111
( ( A(op == J_MOVK)
    B(op == J_MOVK)
  )
  ( (== A.r1 B.r1)
    (== A.m B.m)
    (regset_unkilled (bit A.r1))
  )
  ( (kill B)
  )
)

;;;# 112
( ( A(op == J_MOVK)
    B(op == J_MOVK)
    C(op <- (J_STRK J_STRR J_STRBK J_STRBR) && dead_r1)
  )
  ( (== A.m B.m)
    (== B.r1 C.r1)
    (nointervening G_ANY)
  )
  ( (= C.r1 A.r1)
    (kill B)
    (= C.dataflow (& C.dataflow ~J_DEAD_R1))
  )
)

;;;# 113
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_SHLK)
    B(op == J_SHRK+J_UNSIGNED)
  )
  ( (== A.m B.m)
    (== A.r1 B.r2)
  )
  ( (kill A)
    (= B.op J_ANDK) (= B.r2 A.r2) (= B.m (- (bit (- 32 B.m)) 1))
  )
)

;;;# 114
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_SHLK)
    B(op == J_SHRK+J_UNSIGNED && dead_r2)
    C(op & ~J_SHIFTMASK+J_NEGINDEX <- (J_ADDR J_SUBR J_LDRR J_LDRWR J_LDRBR) && dead_r3 && peep == 0)
  )
  ( (!= (& C.op J_SHIFTVAL) 0)
    (== (& C.op J_SHIFTR) 0)
    (> B.m (+ A.m (& (>> C.op J_SHIFTPOS) SHIFT_MASK)))
    (== A.r1 B.r2)
    (== B.r1 C.r3)
    (nointervening G_ANY)
  )
  ( (= A.op J_ANDK) (= A.m (- (bit (- 32 A.m))
                              (bit (- B.m A.m))))
    (kill B)
    (= C.op (| (& C.op ~J_SHIFTMASK)
               (| J_SHIFTR (<< (- B.m
                                  (+ A.m
                                     (& (>> C.op J_SHIFTPOS) SHIFT_MASK)))
                            J_SHIFTPOS))))
  )
)

;;;# 115
( ( A(op & ~(J_SIGNED+J_UNSIGNED) == J_SHLK)
    B(op == J_MOVK)
    C(op & ~(J_SHIFTVAL+J_UNSIGNED) <- (J_CMPR+J_SHIFTR+Q_EQ J_CMPR+J_SHIFTR+Q_NE) && dead_r2 && dead_r3)
  )
  ( (== C.r2 B.r1)
    (== C.r3 A.r1)
    (<= A.m (>> (& C.op J_SHIFTVAL)
                J_SHIFTPOS))
    (nointervening G_ANY)
  )
  ( (kill B)
    (= A.op J_ANDK)
    (= A.m (- (bit (- 32 A.m))
              (bit (- (>> (& C.op J_SHIFTVAL)
                          J_SHIFTPOS)
                    A.m))))
    (= C.op (+ J_CMPK (& C.op Q_MASK)))
    (= C.r2 A.r1)
    (= C.m (<< B.m (- (>> (& C.op J_SHIFTVAL)
                          J_SHIFTPOS)
                      A.m)))
  )
)

;;;# 116
( ( A(op == J_MOVK)
    B(op & ~J_SHIFTVAL == J_ANDR+J_SHIFTR && dead_r2 && dead_r1 && dead_r3)
  )
  ( (== B.r2 A.r1)
    (!= (& B.peep P_CMPZ) 0)
  )
  ( (kill A)
    (= B.op J_ANDK) (= B.r2 B.r3)
    (= B.m (<< A.m (>> (& B.op J_SHIFTVAL)
                       J_SHIFTPOS)))
  )
)

;;;# 117
( ( A(op == J_MOVK)
    B(op & ~J_SHIFTVAL == J_ANDR+J_SHIFTR && dead_r2 && dead_r1)
  )
  ( (== B.r2 A.r1)
    (!= (& B.peep P_CMPZ) 0)
  )
  ( (kill A)
    (= B.op J_ANDK) (= B.r2 B.r3)
    (= B.m (<< A.m (>> (& B.op J_SHIFTVAL)
                       J_SHIFTPOS)))
    (= B.dataflow (^ B.dataflow J_DEAD_R2))
  )
)

;;;# 118
;;; Improve code generated by C++ pointer casts
;;; (code is of the form  (let (b) (b = p; (b != 0) ? (char *)b+k : 0)
;;; which makes it very likely that b and the expression result will be
;;; allocated the same register.
( ( A(op == J_CMPK+Q_EQ)
    B(op == J_CONDEXEC+Q_EQ)
    C(op == J_MOVK)
  )
  ( (== A.r2 C.r1)
    (== A.m 0)
    (== C.m 0)
    (regset_unkilled (bit C.r1))
  )
  ( (kill C)
  )
)

;;;# 119
( ( A(op == J_MOVK)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_LDRK J_STRK J_STRBK) && dead_r2)
  )
  ( (difficult_constant A.m)
    (! (difficult_constant (^ A.m (& A.m (* (lsb A.m) 0xff)))))
    (>= (+ B.m (& A.m (* (lsb A.m) 0xff))) -0xfff)
    (<= (+ B.m (& A.m (* (lsb A.m) 0xff))) 0xfff)
    (== A.r1 B.r2)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (^ A.m (& A.m (* (lsb A.m) 0xff))))
    (= B.m (+ B.m (& A.m (* (lsb A.m) 0xff))))
  )
)

;;;# 120
( ( A(op == J_MOVK)
    B(op & ~(J_SIGNED+J_UNSIGNED) <- (J_LDRWK J_LDRBK) && dead_r2)
  )
  ( (difficult_constant A.m)
    (! (difficult_constant (^ A.m (& A.m (* (lsb A.m) 0xff)))))
    (>= (+ B.m (& A.m (* (lsb A.m) 0xff))) -0xfff)
    (<= (+ B.m (& A.m (* (lsb A.m) 0xff))) 0xfff)
    (== A.r1 B.r2)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (^ A.m (& A.m (* (lsb A.m) 0xff))))
    (= B.m (+ B.m (& A.m (* (lsb A.m) 0xff))))
    (= B.peep (| B.peep P_BASEALIGNED))
  )
)

;;; MOVDIR + MOVDIR -> MOVDIM, MOVIDR+MOVIDR -> MOVIDM.
;;; Allows use of just one ld/stm. No point to MOVDIM + MOVDIR etc
;;; peepholes (just four argument registers).  Two peepholes for each
;;; (for the two different orders of the argument registers).
;;;# 121
( ( A(op == J_MOVDIR)
    B(op == J_MOVDIR)
  )
  ( (> A.r1 B.r1)
    (> A.m B.m)
    (regset_unused (bit A.r1)) (regset_unused (bit A.r2))
    (regset_unkilled (bit A.m))
  )
  ( (kill A)
    (= B.op J_MOVDIM)
    (= B.r1 (| (bit A.r1) (| (bit A.r2) (| (bit B.r1) (bit B.r2)))))
    (= B.r2 0)
    (= B.m (| (bit A.m) (bit B.m)))
  )
)

;;; 122
( ( A(op == J_MOVDIR)
    B(op == J_MOVDIR)
  )
  ( (< A.r1 B.r1)
    (< A.m B.m)
    (regset_unused (bit A.r1)) (regset_unused (bit A.r2))
    (regset_unkilled (bit A.m))
  )
  ( (kill A)
    (= B.op J_MOVDIM)
    (= B.r1 (| (bit A.r1) (| (bit A.r2) (| (bit B.r1) (bit B.r2)))))
    (= B.r2 0)
    (= B.m (| (bit A.m) (bit B.m)))
  )
)

;;; 123
( ( A(op == J_MOVIDR)
    B(op == J_MOVIDR)
  )
  ( (> A.r1 B.r1)
    (> A.m B.m)
    (regset_unused (bit A.r1))
    (regset_unkilled (bit A.r2)) (regset_unkilled (bit A.m))
  )
  ( (kill A)
    (= B.op J_MOVIDM)
    (= B.r1 (| (bit A.r1) (bit B.r1)))
    (= B.r2 0)
    (= B.m (| (bit A.r2) (| (bit A.m) (| (bit B.r2) (bit B.m)))))
  )
)

;;; 124
( ( A(op == J_MOVIDR)
    B(op == J_MOVIDR)
  )
  ( (< A.r1 B.r1)
    (< A.m B.m)
    (regset_unused (bit A.r1))
    (regset_unkilled (bit A.r2)) (regset_unkilled (bit A.m))
  )
  ( (kill A)
    (= B.op J_MOVIDM)
    (= B.r1 (| (bit A.r1) (bit B.r1)))
    (= B.r2 0)
    (= B.m (| (bit A.r2) (| (bit A.m) (| (bit B.r2) (bit B.m)))))
  )
)

;;; 125
;;; MOVDIR + load popping stack -> MOVDIM.
( ( A(op == J_MOVDIR)
    B(op == J_LDRK && peep == P_POST)
  )
  ( (== B.r2 R_SP)
    (== B.m 4)
    (> B.r1 A.r2)
    (regset_unused M_SP) (regset_unused (bit B.r1))
  )
  ( (kill B)
    (= A.op J_MOVDIM)
    (= A.r1 (| (| (bit A.r1) (bit A.r2)) (bit B.r1)))
    (= A.r2 0)
    (= A.m (bit A.m))
  )
)

;;;; Another peephole to improve handling of loading fp arguments into
;;;; integer registers.
;;;# 126
( ( A(op == J_STRDK && peep & P_POST == 0)
    B(op == J_MOVDIR && dead_r3)
  )
  ( (== A.r1 B.r3)
    (regset_unused (bit B.r1)) (regset_unused (bit B.r2))
    (regset_unused (bit A.r1))
    (nointervening G_STR)
  )
  ( (= B.op J_POPMB)
    (= B.r1 (+ A.m 8))
    (= B.r2 A.r2)
    (= B.m (| (bit B.r1) (bit B.r2)))
  )
)

;;;# 127
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLR J_SHRR J_RORR) &&
      peep == 0)
    B(op == J_NOTR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
    (regset_unkilled (bit A.r3))
  )
  ( (kill A)
    (= B.peep (| B.peep (shift_p A.op)))
    (= B.r4 A.r3)
    (= B.r3 A.r2)
  )
)

;;;# 128
( ( A(op & ~(J_SIGNED+J_UNSIGNED) <- (J_SHLK J_SHRK J_RORK) &&
      peep == 0)
    B(op == J_NOTR && peep & P_RSHIFT == 0)
  )
  ( (== A.r1 B.r3)
  )
  ( (kill A)
    (= B.op (| B.op (shift_k A.op A.m)))
    (= B.r3 A.r2)
  )
)

;;;# 129
( ( A(op == J_MULK)
    B(op == J_NOTR && peep & P_RSHIFT == 0 && dead_r3)
  )
  ( (== A.r1 B.r3)
    (!= A.m 0)
    (!= (& A.m (- 0 A.m)) 1)
    (regset_unused (bit A.r1))
  )
  ( (= A.m (/ A.m (& A.m (- 0 A.m))))
    (= B.op (| B.op (shift_k J_SHLK (log2 (& A.m (- 0 A.m))))))
  )
)

