/*
 * C compiler file arm/asd.c,  version 6c
 * Copyright (C) Codemist Ltd, 1988
 * Copyright (C) Acorn Computers Ltd., 1988
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

/* This file contains routines to buffer infomation which is required for */
/* Acorn's source-level debugger.                                         */
/* NOTA BENE: at several points this code refers to inadequacies of       */
/* the TopExpress draft specification.  See text file for further details */
/* of these criticisms.                                                   */

/* Memo: 1. redo s_typedefname          DONE?
         2. check spurious tests of DBG_XXX (done).
         4. The filedate field is left as 0 as TopExpress do not use it
            and no format is specified.
         5. Since we only save the file position of the start of each command,
            the end of a command is identified with the start of the
            next one.  Find the word 'sentinel' to check.
         6. Shame that the sectionflags field (see DEB_SECTION) cannot
            distinguish toplevel and local var table entries.
         7. Shame that the 16+16 coding of DEB_FILEINFO + length
            overflows when compiling the compiler.  8+24 better?
            Yes, but TopExpress hack by requiring setting length to 0
            if too big to fit.
*/

#ifdef __STDC__
#  include <string.h>
#else
#  include <strings.h>
#endif
#include <stddef.h>

#include "globals.h"
#include "mcdep.h"
#include "mcdpriv.h"
#include "aeops.h"
#include "errors.h"
#include "xrefs.h"
#include "store.h"
#include "codebuf.h"
#include "regalloc.h"
#include "util.h"
#include "bind.h"      /* evaluate */
#include "sem.h"       /* alignoftype, sizeoftype, structfield */
#include "builtin.h"   /* te_xxx, xxxsegment */
#include "errors.h"

#include "asdfmt.h"

#ifdef TARGET_HAS_DEBUGGER

#define OldAsdTables (asd_old_tables ^ ((var_cc_private_flags & 128L) != 0))

char dbg_name[4] = "ASD";
int usrdbgmask;
bool asd_old_tables;

#define DbgAlloc(n) GlobAlloc(SU_Dbg, n)

/* See also magic numbers coded as required in dbg_typerep() */

typedef struct Dbg_Structelt
{   struct Dbg_Structelt *next;     /* must be first for dreverse */
    int32 offset;
    int32 type;
    char *name;
} Dbg_Structelt;

typedef struct Dbg_Enumelt
{   struct Dbg_Enumelt *next;     /* must be first for dreverse */
    int32 val;
    char *name;
} Dbg_Enumelt;

typedef struct Dbg_Return
{   struct Dbg_Return *cdr;
    int32 car;
} Dbg_Return;

static Dbg_Return *dbg_returnlist;

typedef struct Dbg_TypeFRef {
    struct Dbg_TypeFRef *nextref;
    struct Dbg_TypeFRef *nextstruct;
    int32 *typeref;
    int32 ptrcnt;
    SET_BITMAP sort;
} Dbg_TypeFRef;

static Dbg_TypeFRef *dbg_structRefs;

typedef struct Dbg_LocList
{   struct Dbg_LocList *cdr;
    Binder *name;
    int32 pos;
    int32 typeref;
    Dbg_TypeFRef *typefrefs;
} Dbg_LocList;

static Dbg_LocList *dbg_loclist;

/* The next macro seems to indicate a lack to do this portably in ANSI-C */
/* Are discriminated unions second class objects?                        */
#define DbgListVarSize(variant) \
    ((size_t)(sizeof(p->car.variant)+offsetof(DbgList,car)))

/* The following is the *internal* data structure in which debug info. */
/* is buffered.  It differs from AOF format in keeping pointers to     */
/* strings instead of bcpl-style strings themselves to save space.     */
typedef struct DbgList
{   struct DbgList *cdr;
    int32 debsort;
    union Deb_Things
    {  struct { char *name;
              } DEB_SECTION;
       struct { int32 type;
                int32 args;
                int32 sourcepos;
                int32 entryaddr, bodyaddr;   /* see dbg_bodyproc */
                int32 endproc;
/* a (Deb_filecoord *) next line may subsume sourcepos too */
                char *fileentry;
                char *name;
              } DEB_PROC;
       struct { int32 sourcepos;
                int32 endaddr;
/* a (Deb_filecoord *) next line may subsume sourcepos too */
                char *fileentry;
                Dbg_Return *retaddrs;
              } DEB_ENDPROC;
       struct { int32 type;
                int32 sourcepos;
                unsigned32 stgclass;
                int32 location;
                Symstr *sym;
                Symstr *base;
              } DEB_VAR;
       struct { int32 type;
                TypeExpr *typex;
                int32 loc;
                char *name;
              } DEB_TYPE;
       struct { int32 space;
                int32 size;
                Dbg_Structelt *elts;
              } DEB_STRUCT;
       struct { int32 size;
                int32 arrayflags;
                int32 basetype;
                int32 lowerbound;
                int32 upperbound;
              } DEB_ARRAY;
       struct { int32 space;
                Dbg_Enumelt *elts;
              } DEB_ENUM;
       struct { union { struct DbgList *next;
                        int32 codeaddr;
                      } s;
              } DEB_SCOPE;
    } car;
} DbgList;

static int32 dbgloc;
static DbgList *dbglist, *dbglistproc;

static void dbg_relocate(int32 where, Symstr *symbol)
{   dbgxrefs = (DataXref*) global_list3(SU_Xref, dbgxrefs, where,  symbol);
}

/* For some strange reason, AOF debugger info has bcpl-format strings */
/* in spite of the fact that the rest of AOF uses C format ones.      */
static size_t bcpl_string(char *b, char *c)
{   size_t n = strlen(c);
    if (n > 255) n = 255;
    b[0] = n;
    memcpy(b+1, c, n);
    memclr(b+n+1, 3-(n&3));             /* for neatness */
    return (size_t)padstrlen(n);
}

static int32 dbg_check(int32 offset)
{   if (offset > 0x800000L)
        cc_fatalerr(armdbg_fatalerr_toobig);
    return -offset;
}

/* First structs and code for buffering file/line co-ordinates.         */
/* BEWARE: believing the debugging is usually done on small programs,   */
/* and not in production runs, the following data structures are        */
/* naive rather than efficient and often require quadratic algorithms.  */
/* If it worries you, then the solution is obvious, but given the       */
/* complexity of the debugger tables question the need first!           */

/* We have one of these for every file we see.  BUT because a file may  */
/* validly be included more than once in a C program, we had better do  */
/* pointer, not string, equality on names, and rely on pp.c behaviour.  */

typedef struct Deb_filecoord Deb_filecoord;
typedef struct Deb_filelist Deb_filelist;

struct Deb_filelist
{   Deb_filelist *nextfile;
    char *filename;
    int32 filelistoffset;  /* filename's ->fileentry offset for DEB_PROC */
    unsigned lastline;
    Deb_filecoord *linelist;    /* reverse sorted via nextinfile */
};

/* For putting out TopExpress-style line number info here we have to do */
/* a fair amount of work.  'nextinfile' is the next command start in a  */
/* file and 'nextincode' the chain in order of code addresses.          */
/* 'nextincode' is in ascending order, and 'nextinfile' in descending   */
/* but the latter is 'dreversed' before use.                            */
/* When they coincide, we can group fragments (see TopExpress doc).     */
struct Deb_filecoord
{   Deb_filecoord *nextinfile, *nextincode;   /* @@@ dreverse pun */
    Deb_filelist *file;
    unsigned16 line, col;
    int32 codeaddr;
};

static Deb_filelist *dbg_filelist;
/* The next two vars are (code order) list (->nextincode) & tail pointer */
static Deb_filecoord *dbg_coord_p, *dbg_coord_q;
static Deb_filecoord dbg_coord_sentinel =
  {   0, 0,                 /* nextinfile, nextincode                   */
      0,                    /* file                                     */
      65535, 0, 0x00ffffff /* line, col, codeaddr(set by dbg_fileinfo).*/
  };

int32 dbg_tablesize()
{
  return dbgloc;
}

int32 dbg_tableindex(int32 dt_number)
{
  IGNORE(dt_number);
  return 0;
}

VoidStar dbg_notefileline(FileLine fl)
{   Deb_filelist *x = dbg_filelist;
    while (x != NULL && x->filename != fl.f) x = x->nextfile;
    if (x == NULL)
    {   x = (Deb_filelist *) DbgAlloc(sizeof(Deb_filelist));
        x->nextfile = dbg_filelist, x->filename = fl.f,
        x->filelistoffset = 0, x->linelist = 0;
        dbg_filelist = x;
    }
    if (usrdbg(DBG_LINE))
    {   Deb_filecoord *l = x->linelist;
        /* @@@ beware - odd use of #line *MAY* (check) set off the syserr() */
        if (l != NULL && l->line > fl.l)
            syserr(syserr_debugger_line);
        l = (Deb_filecoord *) DbgAlloc(sizeof(Deb_filecoord));
          l->nextinfile = x->linelist, l->nextincode = 0,
          l->file = x, l->line = fl.l, l->col = fl.column,
          l->codeaddr = -1;
        x->linelist = l;
        x->lastline = fl.l;
        return (VoidStar) l;
    }
    return DUFF_ADDR;
}

static DbgList *dbglistscope;

/* The 'dbgaddr' arg has type 'void *' to keep the debugger types local to */
/* this file.  This does not make it any less of a (ANSI approved) hack.   */
void dbg_addcodep(VoidStar dbgaddr, int32 codeaddr)
{
    if (dbgaddr == NULL) { /* J_INFOSCOPE */
        /* c.flowgraf outputs a J_INFOSCOPE immediately after calling
         * dbg_scope, to mark the relevant code address.
         */
        if (debugging(DEBUG_Q)) cc_msg("-- scope at 0x%lx\n", codeaddr);
        {   DbgList *p = dbglistscope;
            while (p != NULL) {
                 DbgList *next = p->car.DEB_SCOPE.s.next;
                 p->car.DEB_SCOPE.s.codeaddr = codeaddr;
                 p = next;
            }
            dbglistscope = NULL;
        }
    } else if (usrdbg(DBG_LINE)) {
        Deb_filecoord *p = (Deb_filecoord *)dbgaddr;
        if (debugging(DEBUG_Q))
            cc_msg("%p ('%s' line %u/%u) @ %.6lx\n", (VoidStar )p,
                    p->file->filename, p->line, p->col, (long)codeaddr);
        /* The following test avoids setting nextincode/codeaddr twice */
        /* This is currently needed in case FileLine's are duplicated. */
        if (p->codeaddr == -1)
        {   p->codeaddr = codeaddr;
            if (dbg_coord_p) dbg_coord_q = dbg_coord_q->nextincode = p;
            else dbg_coord_p = dbg_coord_q = p;
        }
#ifdef never
        else
            syserr(syserr_addcodep);
#endif
    }
}

static int32 dbg_filetooffset(char *filename)
{   Deb_filelist *x;
    for (x = dbg_filelist; x != NULL; x = x->nextfile)
        if (x->filename == filename) return x->filelistoffset;
    /* The next line should not happen if dbg_notefileline is working. */
    syserr(syserr_filetooffset, filename);
    return 0;
}

static void dbg_hdr(int itemsort, size_t length) {
    int32 w = ((int32)length << 16) | itemsort;
    obj_writedebug(&w, 1+DBG_INTFLAG);
}

typedef struct {
  int32 codebytes;
  int infosize;
  unsigned lines;
  unsigned col;
} Dbg_LineInfoItem;

static bool dbg_GetLineInfoDescription(bool first,
                                       Deb_filecoord *l,
                                       Dbg_LineInfoItem *item)
{
    Deb_filecoord *nc = l->nextincode;
    Deb_filecoord *nf = l->nextinfile;
    if (nf!=NULL && nc!=NULL && nf->file==nc->file) {
        Deb_filecoord *nnf = nf;
        while (nnf!=NULL) {
            if (nnf==nc) { nf=nc; break; }
            if (nnf->codeaddr!=-1 &&
                nnf->codeaddr!=l->codeaddr) break;
            nnf = nnf->nextinfile;
        }
    }
    item->codebytes = nc->codeaddr - l->codeaddr;
    if (nf == NULL)
        item->lines = l->file->lastline - l->line, item->col = 0;
    else if (nf != nc && nf->codeaddr != -1)
        item->lines = 1, item->col = 0;
    else
        item->lines = nf->line - l->line,
        item->col = (item->lines == 0) ? (first ? nf->col - 1 : nf->col - l->col) :
                    (nf->col == 1) ? 0 :
                                     nf->col;

    if (item->codebytes==0 && item->lines == 0 && item->col == 0)
        item->infosize = 0;
    else if (item->codebytes<256 &&
              (OldAsdTables ?
                item->lines < 256 :
                 ( (item->lines == 0 && item->col < (255-Asd_LineInfo_Short_MaxLine)) ||
                   (item->col == 0 && item->lines <= Asd_LineInfo_Short_MaxLine))))
        item->infosize = 2;
    else if (OldAsdTables)
        item->infosize = 6;
    else if (item->lines == 0) {
        item->col += l->col;
        if (item->col <= 1)
            item->col = 0, item->infosize = 6;
        else
            item->infosize = 8;
    } else if (item->col == 0)
        item->infosize = 6;
    else
        item->infosize = 8;

    return nf==NULL || nf != nc;
}

static int32 dbg_padtoword(int32 loc) {
    if ((loc & 2) == 0)
        return loc;
    else {
        int w = 0;
        obj_writedebug(&w, 2);
        return loc + 2;
    }
}

/* dbg_fileinfo() writes out the DEB_FILEINFO table.  However, due     */
/* to the poxy requirement to write the length first we have to do two */
/* passes (and ditto for fragments within).                            */
static int32 dbg_fileinfo(bool writing, int32 predictedbytes, int32 loc)
{   int32 totalbytes = 4;   /* loc and totalbytes can probably merge */
    Deb_filelist *x;
    if (!usrdbg(DBG_ANY)) return 0;   /* nominally totalbytes */
    if (writing)
    {   dbg_hdr(ITEMFILEINFO, predictedbytes < 0x10000 ? (unsigned)predictedbytes : 0);
        loc += 4;
    }
    for (x = dbg_filelist; x != NULL; x = x->nextfile)
    {   Deb_filecoord *l;
        Dbg_LineInfoItem item;
        int32 nfrags = 0, nfragbytes = 0;
        bool discontinuity = YES;
        if (!writing)     /* first pass - do a dreverse (on ->nextinfile). */
            (x->linelist = (Deb_filecoord *)dreverse((List *)x->linelist),
             x->filelistoffset = totalbytes); /* save for DEB_PROC/ENDPROC */
        /* Note that ->nextincode has a sentinel to flush last fileline.   */
        for (l = x->linelist; l != NULL; l = l->nextinfile)
        {   if (l->codeaddr != -1)
            {   /* we generated code for this construct */
                bool nextdiscontinuity = dbg_GetLineInfoDescription(discontinuity, l, &item);
                if (item.infosize!=0) {
                  if (discontinuity) {
                    nfrags++;
                    nfragbytes = (nfragbytes+2)&(-4);  /* round up to word boundary */
                    nfragbytes += (int32)item.infosize+20;
                    discontinuity = NO;
                  } else {
                    nfragbytes += item.infosize;
                  }
                }
                discontinuity |= nextdiscontinuity;
            }
        }
        {   char c[256];
            size_t n = bcpl_string(c, x->filename);
            int32 size = (int32)n + 12 + ((nfragbytes+2)&(-4));
            if (writing)
            {   bool discontinuity = YES;
                int32 w[5];
                w[0] = size;
                w[1] = 0;        /* @@@ file date one day */
                obj_writedebug(w, 2+DBG_INTFLAG);
                obj_writedebug(c, n);
                obj_writedebug(&nfrags, 1+DBG_INTFLAG);
                loc += (int32)n + 12;
                for (l = x->linelist; l != NULL; l = l->nextinfile)
                    if (l->codeaddr != -1) {
                      bool nextdiscontinuity = dbg_GetLineInfoDescription(discontinuity, l, &item);
                      if (item.infosize!=0) {
                        if (discontinuity) {
                          int32 codebytes = 0;
                          int32 lines = 0;
                          int32 infosize = 0;
                          loc = dbg_padtoword(loc);
                          { Deb_filecoord *nl = l;
                            bool ended = YES;
                            Dbg_LineInfoItem li;
                            do {
                              ended = dbg_GetLineInfoDescription(ended, nl, &li);
                              codebytes += li.codebytes;
                              lines += li.lines;
                              infosize += li.infosize;
                              nl = nl->nextincode;
                            } while (!ended);
                          }
                          w[0] = 20+infosize;
                          w[1] = l->line;
                          w[2] = l->line+lines;
                          w[3] = l->codeaddr;
                          dbg_relocate(loc+12, bindsym_(codesegment));
                          w[4] = codebytes;
                          obj_writedebug(w, 5+DBG_INTFLAG);
                          loc += 20;
                          discontinuity = NO;
                        }
                        if (item.infosize==2) {
                          c[0] = (char)item.codebytes;
                          c[1] = (item.lines != 0 | OldAsdTables) ?
                                   (char)item.lines :
                                   (char)(item.col+1+Asd_LineInfo_Short_MaxLine);
                          obj_writedebug(c, 2);
                          loc += 2;
                        } else {
                          /* long format (now in two flavours) */
                          int32 lineinc = item.lines;
                          int32 codeinc = item.codebytes & 0xffff;
                          short s[3];
                          c[0] = c[1] = 0;
                          if (host_lsbytefirst != target_lsbytefirst) {
                              lineinc = (lineinc << 8) | ((lineinc >> 8) & 0xff);
                              codeinc = (codeinc << 8) | ((codeinc >> 8) & 0xff);
                          }
                          s[0] = (short)lineinc;
                          s[1] = (short)codeinc;
                          if (item.infosize == 8) {
                              int32 col = item.col;
                              if (host_lsbytefirst != target_lsbytefirst)
                                  col = (col << 8) | ((col >> 8) & 0xff);
                              s[2] = (short)col;
                              c[1] = Asd_LineInfo_Short_MaxLine+1;
                          }
                          obj_writedebug(c, 2);
                          obj_writedebug(s, (int32)item.infosize-2);
                          loc += item.infosize;
                        }
                      }
                      discontinuity |= nextdiscontinuity;
                    }

                loc = dbg_padtoword(loc);
            }
            totalbytes += size;
        }
    }
    if (writing)
    {   int32 v[1];
        v[0] = 0;
        obj_writedebug(v, 4);
        loc += 4;
    }
    return totalbytes+4;
}

/* End of file/line co-ordinate code */

static void dbg_typerep(TypeExpr *, int32 *typep);

static int32 dbg_arrayrep(TypeExpr *t, Expr *e)
{   /* e is the array size. Since C arrays start at 0, the upper bound is */
    /* one less                                                           */
    DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_ARRAY));
    p->debsort = ITEMARRAY;
    p->car.DEB_ARRAY.arrayflags = (e ? 10:6);
    dbg_typerep(t, &p->car.DEB_ARRAY.basetype);
    p->car.DEB_ARRAY.lowerbound = 0;
    p->car.DEB_ARRAY.upperbound = e ? evaluate(e)-1:0;
    p->car.DEB_ARRAY.size = sizeoftype(t);
    p->cdr = dbglist;              /* do this last (typerep above) */
    dbglist = p;
    dbgloc += 24;
    return dbg_check(dbgloc-24);
}

#define dbg_mk_typerep(code,ptrc) TYPE_TYPEWORD((int32)(code), ptrc)

static int32 dbg_structentry(
  SET_BITMAP sort, ClassMember *members, int32 size, Dbg_TypeFRef *refs,
  TagBinder *b)
{   ClassMember *l;
    DbgList *resultstruct;
    Dbg_Structelt *elts = 0;
    int32 space = 12;
    int32 entry;

    for (l = members; l != 0; l = memcdr_(l))
    {   if (memsv_(l))
        {   /* note that memsv is 0 for padding bit fields */
            space += 8 + padstrlen(strlen(symname_(memsv_(l))));
        }
    }
    /* The next line notes the struct definition in the debug table, */
    /* thereby avoiding problems with circular types.                */
    dbgloc += space;
    entry = dbg_check(dbgloc-space);
    if (b != NULL) b->tagbinddbg = entry;
    {   DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_STRUCT));
        p->debsort = ITEMSTRUCT;
        p->car.DEB_STRUCT.space = space;
        p->car.DEB_STRUCT.size = 0;    /* filled in later */
        p->car.DEB_STRUCT.elts = 0;    /* filled in later */
        p->cdr = dbglist;
        resultstruct = dbglist = p;
    }
    {   StructPos sp;
        sp.n = sp.bitoff = 0;
        for (l = members; l != 0; l = memcdr_(l)) {
            structfield(l, sort, &sp);
            if (memsv_(l))
            {   /* note that memsv is 0 for padding bit fields */
                Dbg_Structelt *p =
                  (Dbg_Structelt *) DbgAlloc(sizeof(Dbg_Structelt));
                p->next = elts;
                p->offset = sp.woffset;
                /* TopExpress format can't handle bitfields */
                dbg_typerep(sp.bsize != 0 ? te_int : memtype_(l), &p->type);
                p->name = symname_(memsv_(l));
                elts = p;
            }
        }
    }
    resultstruct->car.DEB_STRUCT.size = size;
    resultstruct->car.DEB_STRUCT.elts = (Dbg_Structelt*)dreverse((List*)elts);
    /* if the structure was forward-referenced, fill in the references */
    while (refs!=0) {
       *(refs->typeref) = dbg_mk_typerep(entry, refs->ptrcnt);
       refs->typeref = 0;    /* mark it as handled */
       refs = refs->nextref;
    }
    return entry;
}

static int32 dbg_enumentry(ClassMember *members, Dbg_TypeFRef *refs, TagBinder *b)
{   ClassMember *l;
    Dbg_Enumelt *elts = 0;
    int32 space = 12;
    int32 entry;
    int32 count = 0;
    bool contiguous = YES;
    int32 last = 0;

    for (l = members; l != 0; l = memcdr_(l), count++) {
        Dbg_Enumelt *p = (Dbg_Enumelt *)DbgAlloc(sizeof(Dbg_Enumelt));
        p->next = elts;
        p->name = symname_(memsv_(l));
        p->val = bindenumval_(l);
        if (contiguous) {
            if (count != 0 && p->val != last+1)
                contiguous = NO;
            last = p->val;
        }
        space += padstrlen(strlen(symname_(memsv_(l))));
        elts = p;
    }
    elts = (Dbg_Enumelt *)dreverse((List *)elts);
    if (contiguous)
        space += 4;
    else
        space += count*4;
    dbgloc += space;
    entry = dbg_check(dbgloc-space);
    if (b != NULL) b->tagbinddbg = entry;
    {   DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_STRUCT));
        p->debsort = contiguous ? ITEMENUMC : ITEMENUMD;
        p->car.DEB_ENUM.space = space;
        p->car.DEB_ENUM.elts = elts;
        p->cdr = dbglist;
        dbglist = p;
    }
    /* if the structure was forward-referenced, fill in the references */
    while (refs != 0) {
        *(refs->typeref) = dbg_mk_typerep(entry, refs->ptrcnt);
        refs->typeref = 0;    /* mark it as handled */
        refs = refs->nextref;
    }
    return entry;
}

static int32 dbg_structrep(TagBinder *b, int32 size)
{ /*
   * Note that the TopExpress definition cannot cope with undefined
   * structs as required by C.
   */
    if (!(attributes_(b) & TB_DEFD))
        return 0;                      /* presumably a forward reference */
    /* do two passes to cope with cycles */
    /* (b->tagbinddbg is a pointer to the structure's forward reference chain
       while it's not defined, and the negated offset of its entry in debug
       data when it is) */
    if (b->tagbinddbg >= 0) {         /* not yet defined */
        if (attributes_(b) & bitoftype_(s_enum))
            dbg_enumentry(tagbindmems_(b), (Dbg_TypeFRef *)b->tagbinddbg, b);
        else
            dbg_structentry(attributes_(b) & CLASSBITS, tagbindmems_(b),
                            size, (Dbg_TypeFRef *)b->tagbinddbg, b);
    }
    return b->tagbinddbg;
}

static Dbg_TypeFRef *addtypefref(Dbg_TypeFRef *next, int32 *typep, int32 ptrcnt) {
    Dbg_TypeFRef *fr = (Dbg_TypeFRef*)DbgAlloc(sizeof(Dbg_TypeFRef));
    fr->nextref = next;
    fr->typeref = typep;
    fr->ptrcnt = ptrcnt;
    *typep = 0;
    return fr;
}

static void struct_typerep(TypeExpr *x, int32 *typep, int32 ptrcnt)
{   TagBinder *b = typespectagbind_(x);
    int32 size = attributes_(b) & TB_DEFD ? sizeoftype(x) : 0;
    int32 structrep = dbg_structrep(b, size);
    /* if there's a real definition of the structure, structrep will ensure
       that an entry for it has been generated (and returns the negated offset
       of the entry within the debug data */
    if (structrep < 0) {
        *typep = dbg_mk_typerep(structrep, ptrcnt);
        return;
    } else {
    /* no real definition of the structure yet.  Add an entry to its forward
       references. */
        Dbg_TypeFRef *p = addtypefref((Dbg_TypeFRef*)b->tagbinddbg, typep, ptrcnt);
        p->nextstruct = dbg_structRefs;
        p->sort = attributes_(b) & ENUMORCLASSBITS;
        b->tagbinddbg = (int32)p;
        dbg_structRefs = p;
        return;
    }
}

static void dbg_typerep(TypeExpr *x, int32 *typep)
{   /* note that we do NOT call prunetype() here so we still see typedefs */
    /* BEWARE: this routine uses TopExpress magic numbers as type codes.  */
    int32 ptrcnt = 0;
    for (;;) switch (h0_(x)) {
    case t_content:
    case t_ref:         /* @@@ OK? */
        ptrcnt++;
        x = typearg_(x);
        /* TopExpress spec cannot express const/volatile pointers */
        continue;
    case t_subscript:
        *typep = dbg_mk_typerep(dbg_arrayrep(typearg_(x), typesubsize_(x)),
                                ptrcnt);
        return;
    case t_fnap:
        *typep = dbg_mk_typerep(TYPEFUNCTION, ptrcnt);  /* TopExpress cannot say more */
        return;
    case s_typespec:
      { SET_BITMAP m = typespecmap_(x);
        switch (m & -m) {   /* LSB - unsigned32/long etc. are higher */
        case bitoftype_(s_char):
            *typep = dbg_mk_typerep((m & bitoftype_(s_signed)) ? TYPESBYTE: TYPEUBYTE,
                                    ptrcnt);
            return;
        case bitoftype_(s_int):
            if (m & BITFIELD) syserr(syserr_dbg_bitfield);
            {   int32 tc = (m & bitoftype_(s_unsigned)) ? TYPEUWORD: TYPESWORD;
                if (m & bitoftype_(s_short)) tc--;
                *typep = dbg_mk_typerep(tc,ptrcnt);
                return;
            }
        case bitoftype_(s_double):
            *typep = dbg_mk_typerep((m & bitoftype_(s_short)) ? TYPEFLOAT : TYPEDOUBLE,
                                    ptrcnt);
            return;
        case bitoftype_(s_enum):
            struct_typerep(x, typep, ptrcnt);
            return;
        case bitoftype_(s_struct):
        case bitoftype_(s_class):
        case bitoftype_(s_union):
            struct_typerep(x, typep, ptrcnt);
            return;
        case bitoftype_(s_typedefname):
          { Binder *b = typespecbind_(x);
            /* is there already a table entry for it ? */
            {   DbgList *p;
                for ( p = dbglist ; p!=NULL ; p = p->cdr )
                    if ( p->debsort==ITEMTYPE &&
                         p->car.DEB_TYPE.typex==bindtype_(b) &&
                         p->car.DEB_TYPE.name==symname_(bindsym_(b))) {
                        *typep = dbg_mk_typerep(-(p->car.DEB_TYPE.loc), ptrcnt);
                        return;
                    }
            }
            /* if not, is there a pending one? */
            {   Dbg_LocList *p;
                for (p = dbg_loclist; p != NULL; p = cdr_(p))
                    if (p->name == b) {
                        p->typefrefs = addtypefref(p->typefrefs, typep, ptrcnt);
                        return;
                    }
            }
            syserr("typedef");
            break;
          }
        case bitoftype_(s_void):
            *typep = dbg_mk_typerep(TYPEVOID, ptrcnt);
            return;
        default: break;
        }
      }
        /* drop through for now */
    default:
        syserr(syserr_dbg_typerep, (VoidStar)x, (long)typespecmap_(x));
        *typep = 0;
        return;
    }
}

static void dbg_addvar(Symstr *name, int32 t, int32 sourcepos,
                       unsigned32 stgclass, Symstr *base, int32 addr, TypeExpr *type)
{   DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_VAR));
    p->debsort = ITEMVAR;
    p->car.DEB_VAR.type = t;
    p->car.DEB_VAR.sourcepos = sourcepos;
    p->car.DEB_VAR.stgclass = stgclass;
    p->car.DEB_VAR.location = addr;
    p->car.DEB_VAR.sym = name;
    p->car.DEB_VAR.base = base;
    p->cdr = dbglist;
    dbglist = p;
    dbgloc += 20 + padstrlen(strlen(symname_(name)));
    if (type != NULL) dbg_typerep(type, &p->car.DEB_VAR.type);
}

void dbg_topvar(Symstr *name, int32 addr, TypeExpr *t, int stgclass,
                FileLine fl)
/* For scoping reasons this only gets called on top-level variables (which */
/* are known to be held in global store).  (Does this matter?)             */
{   if (usrdbg(DBG_PROC))
    { /* nb bss => external here.  The effect is only to cause the table item
         to be 0+symbol, rather than addr+data seg
       */
        DbgList *p;
        Symstr *base = NULL;
        StgClass stg = (stgclass & DS_REG) ? C_REG :
                       (stgclass & DS_EXT) ? C_EXTERN :
                                             C_STATIC;
        if (stgclass & (DS_EXT|DS_BSS))
            base = name, addr = 0;
        else if (stgclass & DS_CODE)
            base = bindsym_(constdatasegment);
        else if (!(stgclass & DS_REG))
            base = bindsym_(datasegment);

        if (debugging(DEBUG_Q))
            cc_msg("top var $r @ %.6lx\n", name, (long)addr);
        if (stgclass != 0 && stg != C_REG)
            for ( p = dbglist ; p!=NULL ; p = p->cdr )
                if ( p->debsort==ITEMVAR &&
                     (p->car.DEB_VAR.stgclass==C_EXTERN ||
                      p->car.DEB_VAR.stgclass==C_STATIC) &&
                     p->car.DEB_VAR.location==0 &&
                     p->car.DEB_VAR.sym == name) {
                    p->car.DEB_VAR.sourcepos = fl.l;
                    p->car.DEB_VAR.location = addr;
                    p->car.DEB_VAR.base = base;
                    return;
                }
        dbg_addvar(name, 0, fl.l, stg, base, addr, t);
    }
}

static int32 dbg_typeinternal(Symstr *name, int32 t, TypeExpr *type)
/* This procedure is called on a type-declaration internal to a procedure
 * (from dbg_scope, after the syntax tree has evaporated), and on a global
 * one, with the syntax tree in place.  The latter therefore goes through
 * dbg_type, which internalises the type.
 */
{   DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_TYPE));
    if (debugging(DEBUG_Q))
        cc_msg("type $r\n", name);
    p->debsort = ITEMTYPE;
    p->car.DEB_TYPE.type = t;
    p->car.DEB_TYPE.typex = type;
    p->car.DEB_TYPE.loc = dbgloc;
    p->car.DEB_TYPE.name = symname_(name);
    p->cdr = dbglist;
    dbglist = p;
    dbgloc += 8 + padstrlen(strlen(symname_(name)));
    if (type != NULL) dbg_typerep(type, &p->car.DEB_TYPE.type);
    return p->car.DEB_TYPE.loc;
}

void dbg_type(Symstr *name, TypeExpr *t, FileLine fl)
/* This only gets called on top-level types (which are known to be held in
 * global store).
 */
{
    (void)dbg_typeinternal(name, 0, t);
}

static Deb_filecoord *cur_proc_coord;

void dbg_proc(Symstr *name, TypeExpr *t, bool ext, FileLine fl)
{   char *s = symname_(name);
    IGNORE(ext);   /* ASD has no use for static/external information */
    if (usrdbg(DBG_PROC))
    {   DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_PROC));
        if (debugging(DEBUG_Q)) cc_msg("startproc $r\n", name);
        t = princtype(t);
        p->debsort = ITEMPROC;
        if (h0_(t) != t_fnap) syserr(syserr_dbg_proc);
        dbg_typerep(typearg_(t), &p->car.DEB_PROC.type);
        p->car.DEB_PROC.args = length((List *)typefnargs_(t));
        p->car.DEB_PROC.sourcepos = fl.l;
        p->car.DEB_PROC.entryaddr = 0;       /* fill in at dbg_enterproc */
        p->car.DEB_PROC.bodyaddr = 0;        /* fill in at dbg_bodyproc */
        p->car.DEB_PROC.endproc = 0;         /* fill in at dbg_xendproc   */
        p->car.DEB_PROC.fileentry = fl.f;
        p->car.DEB_PROC.name = s;
        p->cdr = dbglist;              /* do this last (typerep above) */
        dbglistproc = dbglist = p;       /* so can be filled in */
        dbgloc += 32 + padstrlen(strlen(s));
    }
    if (usrdbg(DBG_LINE))
        cur_proc_coord = (Deb_filecoord *)fl.p;
    dbg_returnlist = 0, dbg_loclist = 0;
}

void dbg_enterproc(void)
{   if (usrdbg(DBG_PROC))
    {   DbgList *p = dbglistproc;
        if (p == 0 || p->debsort != ITEMPROC || p->car.DEB_PROC.entryaddr != 0)
            syserr(syserr_dbg_proc1);
        if (debugging(DEBUG_Q))
            cc_msg("enter '%s' @ %.6lx\n",
                    p->car.DEB_PROC.name, (long)codebase);
        p->car.DEB_PROC.entryaddr = codebase;
    }
    if (usrdbg(DBG_LINE))
       dbg_addcodep(cur_proc_coord, codebase);
}

/* The following routine records the post-entry codeaddr of a proc */
void dbg_bodyproc(void)
{   if (usrdbg(DBG_PROC))
    {   DbgList *p = dbglistproc;
        if (p == 0 || p->debsort != ITEMPROC || p->car.DEB_PROC.bodyaddr != 0)
            syserr(syserr_dbg_proc1);
        if (debugging(DEBUG_Q))
            cc_msg("body '%s' @ %.6lx\n",
                    p->car.DEB_PROC.name, (long)(codebase+codep));
        p->car.DEB_PROC.bodyaddr = codebase+codep;
    }
}

void dbg_return(int32 addr)
{   if (usrdbg(DBG_PROC))
    {   if (debugging(DEBUG_Q))
            cc_msg("return @ %.6lx\n", addr);
        dbg_returnlist = (Dbg_Return*) global_cons2(SU_Dbg, dbg_returnlist, addr);
    }
}

void dbg_xendproc(FileLine fl)
{   if (usrdbg(DBG_PROC))
    {   DbgList *q = dbglistproc;
        DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_ENDPROC));
        if (q == 0 || q->debsort != ITEMPROC || q->car.DEB_PROC.endproc != 0)
            syserr(syserr_dbg_proc1);
        if (debugging(DEBUG_Q))
            cc_msg("endproc '%s' @ %.6lx\n",
                    q->car.DEB_PROC.name, (long)(codebase+codep));
        q->car.DEB_PROC.endproc = dbgloc;
        p->debsort = ITEMENDPROC;
        p->car.DEB_ENDPROC.sourcepos = fl.l;
        p->car.DEB_ENDPROC.endaddr = codebase+codep;
        p->car.DEB_ENDPROC.fileentry = fl.f;
        p->car.DEB_ENDPROC.retaddrs = dbg_returnlist;
        p->cdr = dbglist;
        dbglist = p;
        dbgloc += 20 + 4*length((List *)dbg_returnlist);
        dbg_loclist = 0, dbg_returnlist = 0;    /* for safety */
    }
}

/* dbg_locvar() registers the name and line of a declaration, and internalises
 * the type.  Location info cannot be added until after register allocation.
 * See also dbg_scope which completes.
 * (Type internalisation cannot be done then, because by that time the tree
 * has evaporated).
 * Also remember that dead code elimination may remove some decls.
 */
void dbg_locvar(Binder *name, FileLine fl)
{   if (usrdbg(DBG_VAR) && !isgensym(bindsym_(name))) {
        /* local to a proc */
        Dbg_LocList *p = (Dbg_LocList*) BindAlloc(sizeof(Dbg_LocList));
        if (debugging(DEBUG_Q))
            cc_msg("note loc var $b\n", name);
        p->cdr = dbg_loclist;
        p->name = name;
        p->pos = fl.l;
        p->typefrefs = NULL;
        dbg_typerep(bindtype_(name), &p->typeref);
        dbg_loclist = p;
    }
}

static Dbg_LocList *dbg_findloclist(Binder *b)
{   Dbg_LocList *p;
    for (p = dbg_loclist; p != NULL; p = p->cdr)
        if (p->name == b) return p;
    return NULL;
}

void dbg_locvar1(Binder *b)
{   Symstr *name = bindsym_(b);
    Symstr *base = NULL;
    Dbg_LocList *p = dbg_findloclist(b);
    unsigned32 stgclass;
    int stgclassname;
    int32 addr = bindaddr_(b);
    if (p == NULL || p->pos == -1)
    {   if (debugging(DEBUG_Q))
            cc_msg(" omitted");
        return;   /* invented variable name (e.g. s_let) */
    }
    switch (bindstg_(b) & PRINCSTGBITS) {
    default:
    defolt:
        syserr(syserr_dbg_table, name, (long)bindstg_(b), (long)addr);
        return;
    case bitofstg_(s_typedef):
        if (debugging(DEBUG_Q)) cc_msg(" <typedef>");
        {   int32 loc = dbg_typeinternal(name, p->typeref, NULL);
            Dbg_TypeFRef *ref = p->typefrefs;
            for (; ref != NULL; ref = ref->nextref)
                *(ref->typeref) = dbg_mk_typerep(-loc, ref->ptrcnt);
        }
        return;                   /* dbg_type deals with s_typedef vars  */
    case bitofstg_(s_extern):
        if (debugging(DEBUG_Q)) cc_msg(" <extern>");
        return;                   /* local externs do not allocate store */
    case bitofstg_(s_static):
        stgclass = C_STATIC, stgclassname = 'S';
        base = (bindstg_(b) & u_constdata) ? bindsym_(constdatasegment) :
                (bindstg_(b) & u_bss) ? bindsym_(bsssegment) :
                                        bindsym_(datasegment);
        break;
    case bitofstg_(s_auto):
        if (bindxx_(b) != GAP) {
            stgclass = C_REG, stgclassname = 'R', addr = register_number(bindxx_(b));
        } else switch (addr & BINDADDR_MASK) {
        case BINDADDR_ARG:
            stgclass = C_AUTO, stgclassname = 'A', addr = local_fpaddress(addr);
            break;
        case BINDADDR_LOC:
            stgclass = C_AUTO, stgclassname = 'P', addr = local_fpaddress(addr);
            break;
        case 0:
          /* probably declared but not used case (where addr is still a bindlist) */
            if ((bindstg_(b) & b_bindaddrlist) != 0) {
               if (debugging(DEBUG_Q)) cc_msg(" unused - omitted");
               return; }
          /* otherwise, fall into internal error case */
        default:
            goto defolt;
        }
        break;
    }
    if (debugging(DEBUG_Q))
        cc_msg(" %c %lx", stgclassname, (long)addr);
    dbg_addvar(name, p->typeref, p->pos, stgclass, base, addr, NULL);
}

bool dbg_scope(BindListList *newbll, BindListList *oldbll)
{   int32 entering = length((List *)newbll) - length((List *)oldbll);
    if (entering == 0) return NO;
    if (entering < 0)
    {   BindListList *t = newbll;
        newbll = oldbll, oldbll = t;
    }
    if (length((List *)oldbll) > 0) {
        BindListList *bll = newbll;
        DbgList *last = NULL;
        for (bll = newbll; bll != oldbll; bll = bll->bllcdr) {
            if (bll == 0) syserr(syserr_dbg_scope);
            if (bll->bllcar != 0) {
                DbgList *p = (DbgList *)DbgAlloc(DbgListVarSize(DEB_SCOPE));
                dbglistscope = p;
                p->cdr = dbglist;
                p->debsort = entering >= 0 ? ITEMSCOPEBEGIN : ITEMSCOPEEND;
                p->car.DEB_SCOPE.s.next = last; /* filled in soon by INFOSCOPE */
                dbgloc += 8;
                dbglist = p;
                last = p;
            }
        }
    }
    if (debugging(DEBUG_Q)) cc_msg("scope %ld\n", entering);
    for (; newbll != oldbll; newbll = newbll->bllcdr)
    {   SynBindList *bl;
        if (newbll == 0) syserr(syserr_dbg_scope);
        for (bl = newbll->bllcar; bl; bl = bl->bindlistcdr)
        {   Binder *b = bl->bindlistcar;
            if (bindstg_(b) & b_dbgbit) continue; /* for this and next line */
            bindstg_(b) |= b_dbgbit;              /* see end of routine cmt */
            if (debugging(DEBUG_Q))
                cc_msg("  %s $b",
                        entering>=0 ? "binding" : "unbinding",
                        b);
            if (entering >= 0)
                dbg_locvar1(b);
            if (debugging(DEBUG_Q))
                cc_msg("\n");
        }
    }
    return YES;
    /* Ask for INFOSCOPE item to get called back more or less immediately */
    /* from the local cg (INFOSCOPE item) to fill in the codeaddr         */
}

/* Dummy procedure not yet properly implemented, included here to keep in */
/* step with dbx.c */
void dbg_commblock(Binder *b, SynBindList *members, FileLine fl)
{
    b = b;
    members = members;
    fl = fl;
}

/* armobj.c calls writedebug to generate the debugging tables.   */
/* It must format them and then call obj_writedebug()            */
void dbg_writedebug(void)
{   DbgList *p;
    int32 check = 0;
    int32 fileinfobase;
    int32 fileinfosize;
    int32 v[7];
    char c[256];
    /* produce structure descriptors for forward referenced structures for
     * which there hasn't been a real declaration
     */
    while (dbg_structRefs != 0) {
        if (dbg_structRefs->typeref != 0)
            dbg_structentry(dbg_structRefs->sort, NULL, 0, dbg_structRefs, 0);
        dbg_structRefs = dbg_structRefs->nextstruct;
    }
    {   /* add a sentinel to the ->nextincode list to flush last fileline */
        dbg_coord_sentinel.codeaddr = codebase+codep;
        if (dbg_coord_p)
            dbg_coord_q = dbg_coord_q->nextincode = &dbg_coord_sentinel;
        else dbg_coord_p = dbg_coord_q = &dbg_coord_sentinel;
    }
    fileinfobase = dbgloc;
    fileinfosize = dbg_fileinfo(NO,0,0);
    dbgloc += fileinfosize;
    for (p = (DbgList *)dreverse((List *)dbglist); p != NULL; p = p->cdr) {
        int sort = (int)p->debsort;
        switch (sort) {
        default:
            syserr(syserr_dbg_write, (long)sort);
            break;
        case ITEMSECTION:
          { char h[4];
            size_t n = bcpl_string(c, p->car.DEB_SECTION.name);
            h[0] = LANG_C;
            h[1] = (usrdbg(DBG_LINE) ? 1 : 0) +
                   (usrdbg(DBG_PROC|DBG_VAR) ? 2 : 0);
            h[2] = 0;
            h[3] = OldAsdTables ? ASD_FORMAT_VERSION-1 : ASD_FORMAT_VERSION;
            v[0] = 0, v[2] = codebase;
            dbg_relocate(check+8, bindsym_(codesegment));
            v[1] = 0, v[3] = data.size;
            if (data.size != 0) dbg_relocate(check+12, bindsym_(datasegment));
            v[4] = fileinfobase;
            v[5] = dbgloc;
            dbg_hdr(sort, n+32);
            obj_writedebug(h, 4);
            obj_writedebug(v, 6+DBG_INTFLAG);
            obj_writedebug(c, n);
            check += (int32)n+32;
            break;
          }
        case ITEMPROC:
          { size_t n = bcpl_string(c, p->car.DEB_PROC.name);
            v[0] = p->car.DEB_PROC.type;
            v[1] = p->car.DEB_PROC.args;
            v[2] = p->car.DEB_PROC.sourcepos;
            v[3] = p->car.DEB_PROC.entryaddr;
            dbg_relocate(check+16, bindsym_(codesegment));
            v[4] = p->car.DEB_PROC.bodyaddr;
            dbg_relocate(check+20, bindsym_(codesegment));
            v[5] = p->car.DEB_PROC.endproc;
            v[6] = fileinfobase + dbg_filetooffset(p->car.DEB_PROC.fileentry);
            dbg_hdr(sort, n+32);
            obj_writedebug(v, 7+DBG_INTFLAG);
            obj_writedebug(c, n);
            check += (int32)n+32;
            break;
          }
        case ITEMENDPROC:
          { Dbg_Return *l = p->car.DEB_ENDPROC.retaddrs;
            int n = (int)length((List *)l);
            v[0] = p->car.DEB_ENDPROC.sourcepos;
            v[1] = p->car.DEB_ENDPROC.endaddr;
            dbg_relocate(check+8, bindsym_(codesegment));
            v[2] = fileinfobase + dbg_filetooffset(p->car.DEB_ENDPROC.fileentry);
            v[3] = n;
            dbg_hdr(sort, 20+4*n);
            obj_writedebug(v, 4+DBG_INTFLAG);
            check += 20;
            for (; l ; l = l->cdr)
            {   obj_writedebug(&(l->car), 1+DBG_INTFLAG);
                dbg_relocate(check, bindsym_(codesegment));
                check += 4;
            }
            break;
          }
        case ITEMVAR:
          { size_t n = bcpl_string(c, symname_(p->car.DEB_VAR.sym));
            v[0] = p->car.DEB_VAR.type;
            v[1] = p->car.DEB_VAR.sourcepos;
            v[2] = (int32) p->car.DEB_VAR.stgclass;
            v[3] = p->car.DEB_VAR.location;
            if (p->car.DEB_VAR.stgclass == C_EXTERN ||
                p->car.DEB_VAR.stgclass == C_STATIC) {
            /* Make sure that occurrence in debug tables alone doesn't require
               a symbol to be resolved.  symext_(sym) is non-null if the symbol
               has been otherwise referenced.
             */
                Symstr *s = p->car.DEB_VAR.base;
                obj_symref(s, symext_(s) == NULL ? xr_data|xr_weak : xr_data, 0);
                dbg_relocate(check+16, p->car.DEB_VAR.base);
            }
            dbg_hdr(sort, n+20);
            obj_writedebug(v, 4+DBG_INTFLAG);
            obj_writedebug(c, n);
            check += (int32)n+20;
            break;
          }
        case ITEMTYPE:
          { size_t n = bcpl_string(c, p->car.DEB_TYPE.name);
            dbg_hdr(sort, n+8);
            obj_writedebug(&p->car.DEB_TYPE.type, 1+DBG_INTFLAG);
            obj_writedebug(c, n);
            check += (int32)n+8;
            break;
          }
        case ITEMSTRUCT:
          { Dbg_Structelt *q = p->car.DEB_STRUCT.elts;
            size_t space = (size_t)p->car.DEB_STRUCT.space;
            v[0] = length((List *)q);
            v[1] = p->car.DEB_STRUCT.size;
            dbg_hdr(sort, space);
            obj_writedebug(v, 2+DBG_INTFLAG);
            check += 12, space -= 12;
            for (; q; q = q->next)
            {   size_t n = bcpl_string(c, q->name);
                obj_writedebug(&q->offset, 2+DBG_INTFLAG);
                obj_writedebug(c, n);
                check += (int32)n+8, space -= n+8;
            }
            if (space != 0) syserr(syserr_dbg_struct);
            break;
          }
        case ITEMENUMC:
          { Dbg_Enumelt *q = p->car.DEB_ENUM.elts;
            size_t space = (size_t)p->car.DEB_ENUM.space;
            v[0] = dbg_mk_typerep(TYPESWORD,0);
            v[1] = length((List *)q);
            v[2] = q->val;
            dbg_hdr(sort, space);
            obj_writedebug(v, 3+DBG_INTFLAG);
            check += 16, space -= 16;
            for (; q; q = q->next)
            {   size_t n = bcpl_string(c, q->name);
                obj_writedebug(c, n);
                check += n, space -= n;
            }
            if (space != 0) syserr(syserr_dbg_struct);
            break;
          }
        case ITEMENUMD:
          { Dbg_Enumelt *q = p->car.DEB_ENUM.elts;
            size_t space = (size_t)p->car.DEB_ENUM.space;
            v[0] = dbg_mk_typerep(TYPESWORD,0);
            v[1] = length((List *)q);
            dbg_hdr(sort, space);
            obj_writedebug(v, 2+DBG_INTFLAG);
            check += 12, space -= 12;
            for (; q; q = q->next)
            {   size_t n = bcpl_string(c, q->name);
                obj_writedebug(&q->val, 1+DBG_INTFLAG);
                obj_writedebug(c, n);
                check += (int32)n+4, space -= n+4;
            }
            if (space != 0) syserr(syserr_dbg_struct);
            break;
          }
        case ITEMARRAY:
            dbg_hdr(sort, 24);
            obj_writedebug(&p->car.DEB_ARRAY.size, 5+DBG_INTFLAG);
            check += 24;
            break;
        case ITEMSCOPEBEGIN:
        case ITEMSCOPEEND:
            dbg_relocate(check+4, bindsym_(codesegment));
            dbg_hdr(sort, 8);
            obj_writedebug(&p->car.DEB_SCOPE.s.codeaddr, 1+DBG_INTFLAG);
            check += 8;
            break;
        }
    }
    if (check != fileinfobase)
        syserr(syserr_dbg_fileinfobase, (long)fileinfobase, (long)check);
    check += dbg_fileinfo(YES, fileinfosize, fileinfobase);
    if (check != dbgloc)
        syserr(syserr_dbgloc, (long)dbgloc, (long)check);
}

void dbg_init(void)
{
    dbglist = 0;
    if (usrdbg(DBG_ANY))
    {   /* leave space for the DEB_SECTION item */
        DbgList *p = (DbgList*) DbgAlloc(DbgListVarSize(DEB_SECTION));
        p->debsort = ITEMSECTION;
        p->car.DEB_SECTION.name = objectfile;
        p->cdr = dbglist;
        dbglist = p;
        dbgloc = 32 + padstrlen(strlen(objectfile));
    }
    dbglistproc = 0;
    dbglistscope = 0;
    dbg_filelist = 0, dbg_coord_p = 0;
    dbg_loclist = 0, dbg_returnlist = 0;    /* for safety */
    dbg_structRefs = 0;
}

#endif /* TARGET_HAS_DEBUGGER */

/* End of arm/asd.c */
