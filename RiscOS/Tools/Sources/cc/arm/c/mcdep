/*
 * mcdep.c - miscellaneous target-dependent things.
 * Copyright (C) Acorn Computers Ltd., 1988.
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#include "globals.h"
#include "mcdep.h"
#include "mcdpriv.h"

#include "compiler.h"

int arthur_module;
int32 config;
int32 pcs_flags;

#ifdef TARGET_IS_HELIOS
int in_stubs;
#endif

#define BYTESEX_LITTLE 1
#define BYTESEX_BIG 2
/* value for (target) bytesex field: anything else defaults to bytesex of host. */

#ifdef TARGET_DEFAULT_BIGENDIAN
#  if TARGET_DEFAULT_BIGENDIAN
#    define BYTESEX_DEFAULT BYTESEX_BIG
#  else
#    define BYTESEX_DEFAULT BYTESEX_LITTLE
#  endif
#else
#define BYTESEX_DEFAULT 0
#endif

static struct {
    int32 id[2];
    char size,
         toolid,
         bytesex,
         pcs_options,
         no_unaligned_loads,
         asd_old_tables,
         integer_load_max,
         ldm_regs_max;

} patchable_config = {
/* an identifying "string" (but defined as a pair of word values to enable
   target bytesex to be identified by the patching tool
 */
   { ((((((int32)'x' << 8) | 'c') << 8) | 'o') << 8) | 'n',
     ((((((int32)'f' << 8) | 'i') << 8) | 'g') << 8) | 'x'
   },
   16,
   1,  /* C compiler */
   BYTESEX_DEFAULT,
   PCS_DEFAULTS,
#ifdef NO_UNALIGNED_LOADS
   YES,
#else
   NO,
#endif
#ifdef OLD_FORMAT_ASD_TABLES
   YES,
#else
   NO,
#endif
   INTEGER_LOAD_MAX_DEFAULT,
   LDM_REGCOUNT_MAX_DEFAULT,
};

static void HandleZHOpt(char *tail) {
    int32 include = (int32)tail[0] - 'A';
    int32 exclude = (int32)tail[1] - 'A';
    if (include & PCS_FPREGARGS) {
        config |=  CONFIG_FPREGARGS;
        include &= ~PCS_FPREGARGS;
    } else if (exclude & PCS_FPREGARGS)
        config &=  ~CONFIG_FPREGARGS;
#if 0
    /* /noswst implies /nofp, unless /fp used explicitly */
    /* retracted, because it renders code undebuggable (even if its
       switched off for -g, unless absolutely everything, library included,
       is compiled likewise).
     */
    if ((include & PCS_NOSTACKCHECK) && !(exclude & PCS_NOFP))
        include |= PCS_NOFP;
#endif
    pcs_flags = (pcs_flags & ~exclude) | include;
    if (pcs_flags & PCS_REENTRANT)
        config |= CONFIG_REENTRANT_CODE;
}

bool mcdep_config_option(char name, char tail[])
{
    switch (name) {
#ifndef TARGET_IS_UNIX
#ifdef TARGET_IS_HELIOS
    case 'r': case 'R':
        suppress_module = 1;
        return YES;
#else
    case 'm': case 'M':
        arthur_module = 1;
        if (isdigit(tail[0]))
            arthur_module += (tail[0]-'0');
        return YES;
#endif
#endif
    case 'a': case 'A':
        if (tail[0] == '0')
            config &= ~CONFIG_NO_UNALIGNED_LOADS;
        else
            config |= CONFIG_NO_UNALIGNED_LOADS;
        return YES;

    case 'd': case 'D':
        if (tail[0] == '0')
            pcs_flags &= ~PCS_ACCESS_CONSTDATA_WITH_ADR;
        else
            pcs_flags |= PCS_ACCESS_CONSTDATA_WITH_ADR;
        return YES;

    case 'k': case 'K':
        switch (tail[0]) {
        case 'A': case 'a': setcallingstandard('A'); return YES;
        case 'U': case 'u': setcallingstandard('U'); return YES;
        case 'R': case 'r': setcallingstandard('R'); return YES;
        case 'M': case 'm': setcallingstandard('M'); return YES;
        }
        break;

    case 'n': case 'N':
        if (isdigit(tail[0])) {
            long i = strtol(tail, NULL, 0);
            if (i >= 0L && i <= 32)
            /* VERY CRUDE check of sanity... 32 is effectively infinity */
            {   integer_load_max = (int)i;
                return YES;
            }
        }
        break;

    case 'r': case 'R':
        if (isdigit(tail[0])) {
            long i = strtol(tail, NULL, 0);
            if (i >= LDM_REGCOUNT_MIN_DEFAULT &&
                i <= LDM_REGCOUNT_MAX_DEFAULT)
            {   ldm_regs_max = (int)i;
                return YES;
            }
        }
        break;

    case 'h': case 'H':
        HandleZHOpt(tail);
        return YES;
    }
    return NO;
}

static struct kw { char const *opt; int32 zhflag; } const pcs_keywords[] = {
    { "reentrant",      PCS_REENTRANT },
    { "nonreentrant",   PCS_REENTRANT << 8 },
    { "fpe3",           PCS_FPE3},
    { "fpe2",           PCS_FPE3 << 8},
    { "swstackcheck",   PCS_NOSTACKCHECK << 8},
    { "noswstackcheck", PCS_NOSTACKCHECK},
    { "26bit",                  PCS_CALLCHANGESPSR << 8},
    { "32bit",                  PCS_CALLCHANGESPSR},
    { "fpregargs",      PCS_FPREGARGS},
    { "nofpregargs",    PCS_FPREGARGS << 8},
    { "reent",                  PCS_REENTRANT },
    { "nonreent",       PCS_REENTRANT << 8 },
    { "swst",           PCS_NOSTACKCHECK << 8},
    { "noswst",         PCS_NOSTACKCHECK},
    { "26",             PCS_CALLCHANGESPSR << 8},
    { "32",             PCS_CALLCHANGESPSR},
    { "fpr",            PCS_FPREGARGS},
    { "nofpr",                  PCS_FPREGARGS << 8},
    { "fp",             PCS_NOFP << 8},
    { "nofp",           PCS_NOFP},
};

static char zhopt[] = "-zhAA";

KW_Status mcdep_keyword(const char *key, int *argp, char **argv) {
    if (cistreq(key, "-apcs")) {
        int32 flags = 0;
        int n = *argp+1;
        char *next = argv[n];
        if (next == 0) return KW_MISSINGARG;
        if (*next == '3') next++;
        *argp = n;
        for (;;) {
            int ch = *next;
            int i = 0;
            char str[64];
            if (ch == 0) {
                if (flags == 0) return KW_BADARG;
                zhopt[3] = 'A'+(int)(flags & PCS_ZH_MASK);
                zhopt[4] = 'A'+(int)((flags >> 8) & PCS_ZH_MASK);
                argv[n-1] = zhopt;
                argv[n] = NULL;
                return KW_OK;
            }
            if (ch != '/') return KW_BADARG;
            for (; (ch = *++next) != '/' && ch != 0; )
                str[i++] = safe_tolower(ch);
            str[i] = 0;
            for (i = 0; i < sizeof(pcs_keywords) / sizeof(struct kw); i++)
                if (strcmp(str, pcs_keywords[i].opt) == 0) {
                    flags |= pcs_keywords[i].zhflag;
                    break;
                }
            if (i == sizeof(pcs_keywords) / sizeof(struct kw))
                return KW_BADARG;
        }
    }
    return KW_NONE;
}

#ifndef COMPILING_ON_ARM
char *target_lib_name(const char *name, int32 endian) {
    static char namebuf[64];
    int len = strlen(name);
    if (endian == 0) endian = config;
    HandleZHOpt(&zhopt[3]);
    if (name[len-2] == '.' && name[len-1] == 'o') {
        memcpy(namebuf, name, len);
        memcpy(&namebuf[len-1], pcs_flags & PCS_CALLCHANGESPSR ? "32" : "26", 2);
        namebuf[len+1] = endian & CONFIG_BIG_ENDIAN ? 'b' : 'l';
        namebuf[len+2] = 0;
        return namebuf;
    }
    return (char *)name;
}
#endif

char *target_asm_options(int32 endian) {
  int i = 0;
  static char v[32];
  if (endian == 0) endian = config;
  if (endian & CONFIG_ENDIANNESS_SET) {
    strcpy(v, (endian & CONFIG_BIG_ENDIAN) ? "-bi" : "-li");
    i = 3;
  }
  HandleZHOpt(&zhopt[3]);
  if (i != 0) v[i++] = ' ';
  strcpy(&v[i], "-apcs 3");
  if (pcs_flags & PCS_REENTRANT) strcat(&v[i], "/reent");
  strcat(&v[i], (pcs_flags & PCS_CALLCHANGESPSR) ? "/32bit" : "/26bit");
  return v;
}

    /*************************************************************/
    /*                                                                   */
    /*               Code to configure compiler for host system          */
    /*                                                                   */
    /*************************************************************/

#ifndef APCS_BINDING
#  ifdef TARGET_IS_UNIX
#    define APCS_BINDING 'U'
#  else
#    define APCS_BINDING 'R'
#  endif
#endif

void config_init(void)
{
    config = CONFIG_HAS_MULTIPLY;
    if (patchable_config.bytesex == BYTESEX_LITTLE)
        config |= CONFIG_ENDIANNESS_SET;
    else if (patchable_config.bytesex == BYTESEX_BIG)
        config |= CONFIG_ENDIANNESS_SET+CONFIG_BIG_ENDIAN;
    else {
      static int endian_test = 1;
      if (*((char *)&endian_test) == 0)
        config |= CONFIG_BIG_ENDIAN;
    }

    if (patchable_config.pcs_options & PCS_FPREGARGS)
        config |= CONFIG_FPREGARGS;

    if (patchable_config.no_unaligned_loads)
        config |= CONFIG_NO_UNALIGNED_LOADS;

    arthur_module = 0;
    integer_load_max = patchable_config.integer_load_max;
    ldm_regs_max = patchable_config.ldm_regs_max;

#ifdef TARGET_IS_HELIOS
    suppress_module = 0;
#endif
    setcallingstandard(APCS_BINDING);
    pcs_flags = patchable_config.pcs_options & ~PCS_FPREGARGS;
#ifdef TARGET_HAS_AOF
    asd_old_tables = patchable_config.asd_old_tables;
#endif
}

/* end of arm/mcdep.c */
