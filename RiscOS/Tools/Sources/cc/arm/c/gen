/*
 * C compiler file arm/gen.c.
 * Copyright (C) Codemist Ltd, 1988.
 * Copyright (C) Acorn Computers Ltd., 1988
 * Copyright (C) Advanced Risc Machines Ltd., 1991
 */

/*
 * RCS $Revision$  Codemist 48
 * Checkin $Date$
 * Revising $Author$
 */

/* @@@ AM memo: the uses of bind_global_() are spiritually wrong.   */
/* @@@ LDS 30-Oct-92: wrong save when applied to top-level things.  */

/* This file contains mainly arm dependent machine coding routines. */
/* Apr 89: xr_refext removed by AM as unused elsewhere.             */
/* AM 3-Apr-87: add debugger.  Beware that machine *independent* code should
                *not* go in this file.  */
/* AM 10-Mar-87: add peepholer.  Beware local_address() (q.v.)      */

/* exports:
   void show_instruction(J_OPCODE op,RealRegister r1,RealRegister r2,int32 m);
   RealRegister local_base(Binder *b);
   int32 local_address(Binder *b);
   bool immed_cmp(int32);
   bool fpliteral(FloatCon *val, J_OPCODE op);
      also (unfortunately for peephole):
   void setlabel(LabelNumber *);
   void branch_round_literals(LabelNumber *);
*/

#ifdef __STDC__
#  include <string.h>
#else
#  include <strings.h>
#endif

#define DEFINE_A_JOPTABLE 1

#include "globals.h"
#include "mcdep.h"
#include "mcdpriv.h"
#include "aeops.h"
#include "xrefs.h"
#include "ops.h"
#include "jopcode.h"
#include "store.h"
#include "codebuf.h"
#include "regalloc.h"
#include "builtin.h"   /* for te_xxx */
#include "bind.h"      /* for sym_insert_id */
#include "cg.h"        /* for procflags, greatest_stackdepth */

#include "flowgraf.h"
#include "errors.h"
#include "pp.h"        /* for pp_predefine */

static char frameregs[16];  /* 'virtual' physical register -> physical register
                             * for R_IP, R_FP, R_SL & R_SP.
                             */

#define physical_register(r) (((r) < 10 || (r) > 13) ? (r) : frameregs[r])

int integer_load_max;
int ldm_regs_max;

static int32 nargwords, nregargwords, argwordsbelowfp, realargwordsbelowfp, fp_minus_sp;
static int32 intsavewordsbelowfp, savewordsabovefp, argstopopabovefp;
static int32 condition_mask;

static LabelNumber *returnlab;

static Symstr *lib_reloc_sym, *mod_reloc_sym;
#ifndef PROFILE_COUNTS_INLINE
static Symstr *fn_entry_sym, *fn_exit_sym;
#endif

static int32 spareregs;

static void compare_integer(RealRegister r,int32 n,RealRegister workreg,int32 mask,int32 when);
static void load_integer(RealRegister r,int32 n,int32 scc);
static void add_integer(RealRegister r1,RealRegister r2,int32 n,int32 scc);
static void rsb_integer(RealRegister r1,RealRegister r2,int32 n,int32 scc);
static void and_integer(RealRegister r1,RealRegister r2,int32 n,int32 peep,int32 deadr1);
static void orr_integer(RealRegister r1,RealRegister r2,int32 n,int32 scc,int32 opc);
static void multiply_integer(RealRegister r1,RealRegister r2,int32 n,int32 scc);
static void conditional_branch_to(int32 condition,LabelNumber *destination,bool bxxcase);
static void routine_entry(int32 m);
static void routine_exit(int32 condition,bool to_pc);
static void show_fp_inst_direct(J_OPCODE op,int32 m,int32 peep,RealRegister r1r,RealRegister r2r,RealRegister mr);

static RealRegister local_base_a(int32 p);
static int32 local_addr_a(int32 p);

static RealRegister LowestRegister(int32 mask);

#define AddCodeXref3(t, n) (codexrefs = (CodeXref *)global_list3(SU_Xref, codexrefs, t, n))
#define AddCodeXref4(t, n, x) (codexrefs = (CodeXref *)global_list4(SU_Xref, codexrefs, t, n, x))
#define AddCodeXref5(t, n, x, y) (codexrefs = (CodeXref *)global_list5(SU_Xref, codexrefs, t, n, x, y))

static void outinstr(int32 w)
{
    if ((unsigned32)w >= (unsigned32)0xff000000L)
        syserr(syserr_outinstr, (long)w);
    outcodeword(w ^ condition_mask, LIT_OPCODE);
}

static int32 outinstr3t(int32 w, Symstr *name, int xrflags, int32 tailcall)
{
    int32 d;
    if ((unsigned32)w >= (unsigned32)0xff000000L)
        syserr(syserr_outinstr, (long)w);
    /* the next two lines' data structures may be mergeable. */
    {
#ifndef TARGET_WANTS_LINKER_TO_RESOLVE_FUNCTION_REFERENCES
        d = obj_symref(name, xr_code | xrflags, 0);
        if (d == -1 || tailcall)
#endif
        {   int32 type = tailcall ? X_TailCall : X_PCreloc;
            AddCodeXref4(type | (codebase+codep), name, 0);
            d = 0;
        }
#ifdef AOF_VERSION_150
        else
#endif
          w += ((d - (codebase+codep+8)) >> 2) & 0x00ffffff;
    }
    outcodewordaux(w ^ condition_mask, LIT_RELADDR, name);
    return d;
}

static int32 outinstr3(int32 w, Symstr *name, int xrflags)
{   return outinstr3t(w, name, xrflags, NO);
}

/*
 * Some stuff added by RCC to peephole LDR a, [b, #x]; LDR a, [c, #x+4]
 * and similar into a single LDMIA, and possibly some shuffling of
 * registers.  This is probably of little use unless you have the hacks
 * to earlier stages of the code generator to encourage it to put
 * such things together (LRU-biased regalloc.c, and localopt.c).
 *
 * For the moment I am not going to integrate this with the rest of
 * the peepholing, because I think it is too confusing already.
 */

typedef enum {
  PENDING_NONE,
  PENDING_LD,
  PENDING_ST
} PendingStoreAccess;

typedef struct LoadOrStoreMul {
    int32 offset[16];
    PendingStoreAccess state;
    /* cond now unneeded since CONDEXEC now does an immediate flush,
       rather than waiting till the next generated instruction */
    RealRegister basereg;
    int32 regbits;
    int32 baseadjust;
    int32 baseadjusted;
    bool isload;
    int32 basedead;
} LoadOrStoreMul;

static LoadOrStoreMul ldm_state;

static void ldm_reinit(void)
{
    ldm_state.state = PENDING_NONE;
}

#define LDRMASK
#define CONDITION(w) ((w) & 0xf0000000L)
#define RN(w)        (((w) >> 16) & 0xf)
#define RD(w)        (((w) >> 12) & 0xf)
#define OFFSET(w)    (((w)&F_UPDOWN_FIELD)==F_UP?((w)&0xfff):-((w)&0xfff))
#define OP_LDR (OP_PREN|F_LDR|F_WORD)
#define OP_STR (OP_PREN|F_STR|F_WORD)
#define OP_IS_LDR(w) (((w) & (0x0e000000L|F_LDRSTR_FIELD|F_BYTEWORD_FIELD)) == (OP_POSTN|F_LDR|F_WORD))
#define OP_IS_STR(w) (((w) & (0x0e000000L|F_LDRSTR_FIELD|F_BYTEWORD_FIELD)) == (OP_POSTN|F_STR|F_WORD))

#define ldm_printf if (localcg_debug(4)) cc_msg

typedef struct SavedLDM {
   struct SavedLDM *cdr;
   int32 startoff;
   int32 endoff;
   int32 regset;
   RealRegister lastreg;
} SavedLDM;

static int32 ldm_type(int32 op, LoadOrStoreMul *s, int32 end)
{ if (!s->isload) op ^= (OP_LDMIA ^ OP_STMIA);
  if ((end < 0 && s->baseadjust < 0 && end >= s->baseadjust) ||
      (end > 0 && s->baseadjust > 0 && end <= s->baseadjust))
  { s->baseadjusted += end;
    s->baseadjust -= end;
    op |= F_WRITEBACK;
  }
  return op;
}

static void ldmstm_generate(SavedLDM *p, LoadOrStoreMul *s)
{ RealRegister basereg = s->basereg;
  if (p->startoff != p->endoff) {
    /* more than one register: ldm or stm likely */
    int32 op = 0;
    RealRegister b = basereg;
    bool altered = NO;
    int32 start = p->startoff - s->baseadjusted;
    int32 end = p->endoff - s->baseadjusted;
    int32 addon = 0;

    ldm_printf("-- flushing a %s r%ld, {%lx}\n", s->isload ? "LDM": "STM",
                                                 basereg, p->regset);

    if (start == 0)
      op = ldm_type(OP_LDMIA, s, end+4);
    else if (start == 4)
      op = ldm_type(OP_LDMIB, s, end);
    else if (end == 0)
      op = ldm_type(OP_LDMDA, s, start-4);
    else if (end == -4)
      op = ldm_type(OP_LDMDB, s, start);
    else if (start > 0 /* && end > 0 */ && s->baseadjust >= end) {
      if (s->baseadjust == end)
        addon = start-4, op = OP_LDMIB;
      else
        addon = start, op = OP_LDMIA, end += 4;
      op = ldm_type(op, s, end);
    } else if (/* start < 0 && */ end < 0 && s->baseadjust <= end) {
      if (s->baseadjust == start)
        addon = end+4, op = OP_LDMDB;
      else
        addon = end, op = OP_LDMDA, start -= 4;
      op = ldm_type(op, s, start);
    } else {
      if (s->isload) {
        b = p->lastreg;
        op = OP_LDMIA;
      } else {
        if (basereg == frameregs[R_SP]) {
          ldm_printf("No stm - would modify SP\n");
          goto dosingly;
        }
        altered = YES;
        op = OP_STMIA;
      }
      addon = start;
    }
    if (addon != 0) add_integer(b, basereg, addon, 0);
    outinstr(op | F_RN(b) | p->regset);
    if (altered) {
      s->baseadjusted += addon;
      s->baseadjust -= addon;
    }
    return;
  }

dosingly:
  { /* Note that we don't need to take here to load the base register last (if
       it's in the set to be loaded), because this code is only executed with
       regset having more than one member for stores (and base R_SP, moreover)
     */
    int32 rbit;
    int32 regset = p->regset;
    for (; (rbit = (regset & -regset)) != 0; p->startoff += 4, regset ^= rbit) {
      RealRegister r = power_of_two(rbit);
      int32 offx = p->startoff - s->baseadjusted, abs_offx;
      int32 op = (s->isload ? OP_LDR : OP_STR);
      ldm_printf("-- flushing %s r%ld, [r%ld, #%ld]\n",
                s->isload ? "LDR" : "STR",
                r, basereg, offx);
      ldm_printf("-- dosingly: (A) offx=%#lx s->baseadjust=%#lx s->baseadjusted=%#lx\n", offx, s->baseadjust, s->baseadjusted);
      if (offx == 0 && s->baseadjust != 0) {
        if (cdr_(p) == NULL)
          offx = s->baseadjust;
        else {
          int32 nextoff = cdr_(p)->startoff - s->baseadjusted;
          if ((s->baseadjust > 0 && nextoff <= s->baseadjust) ||
              (s->baseadjust < 0 && nextoff >= s->baseadjust))
            offx = nextoff;
        }
        if (offx != 0) {
          /* So this is definitely going to be a post-increment, optimise partial address adjustments by
           * still using the bottom twelve bits to aim in the right direction.  This may help avoid a
           * later ADD/SUB adjustment to the base register
           */
          op ^= (OP_PREN ^ OP_POSTN);
          if (offx >= 0x1000) {
            offx &= 0xFFF;
          }
          else if (offx <= -0x1000) {
            offx = -(0xFFF & -offx);
          }
          s->baseadjusted += offx;
          s->baseadjust -= offx;
          ldm_printf("-- switched to a post-increment: %#lx %#lx\n", s->baseadjusted, s->baseadjust);
        }
      } else if ((s->baseadjust > 0 && offx <= s->baseadjust) ||
                 (s->baseadjust < 0 && offx >= s->baseadjust)) {
        /* SNB 2000-04-18: This must not be done when s->basereg is the
           stack pointer, otherwise the stack pointer can be above the LWM of
           the stack, and SVC mode code is stuffed if an interrupt occurs
           at the vital moments whilst frameregs[R_SP] doesn't point at the lowest
           required memory.

           When basereg is the stack pointer, we must ensure that we are
           going in the right direction, otherwise we must prevent the writeback.
         */
        if (basereg == frameregs[R_SP] && (offx ^ s->baseadjust) < 0) {
          ldm_printf("-- avoid writeback: basereg R%ld, SGN offx != SGN baseadjust (%ld %ld)\n",
            basereg, offx, s->baseadjust);
        }
        else {
          ldm_printf("-- allow writeback: basereg R%ld, SGN offx == SGN baseadjust (%ld %ld)\n",
            basereg, offx, s->baseadjust);
          op |= F_WRITEBACK;
          s->baseadjusted += offx;
          s->baseadjust -= offx;
        }
      }
      ldm_printf("-- dosingly: (B) offx=%#lx s->baseadjust=%#lx\n", offx, s->baseadjust);
      if (offx < 0) {
        op |= F_DOWN;
        abs_offx = -offx;
      } else {
        op |= F_UP;
        abs_offx = offx;
      }
      if (abs_offx > 0xfff && (op & OP_PREN) == OP_PREN) {
        ldm_printf("-- dosingly: pre increment extra (offset = %ld)\n", offx);
        add_integer(basereg, basereg, offx, 0);
      }
      ldm_printf("-- dosingly: (C) offx=%#lx s->baseadjust=%#lx\n", offx, s->baseadjust);
      outinstr(op | F_RN(basereg) | F_RD(r) | (abs_offx & 0xFFF));
      if (abs_offx > 0xfff && (op & OP_PREN) != OP_PREN) {
        ldm_printf("-- dosingly: post increment extra (offset = %ld)\n", offx);
        add_integer(basereg, basereg, offx, 0);
      }
    }
  }
}

static void ldm_flush_r(int32 regbits)
{ struct LoadOrStoreMul *s = &ldm_state;
  RealRegister r;
  SavedLDM ldm[16],
           *ldmp = NULL,
           *atend = NULL;
  int ldmix = 0;

  if (s->state == PENDING_NONE) return;

  ldm_printf("-- ldm_flush: %lx (s->baseadjust=%#lx)\n", regbits, s->baseadjust);

  /* s describes a set of loads/stores to be done.  s->regbits has bit r set if
     register r is to be loaded/stored (at offset s->offset[r] from the initial
     value of s->basereg.  s->basereg must be adjusted by s->baseadjust.
     (but if s->basedead is non-zero we needn't bother)
   */

  /* If there is no writeback, but the base is dead (and not being reloaded)
     we may produce better code if more than one LDM/STM is to be generated
     if we pretend there is writeback.
   */
  if (s->baseadjust != 0)
    regbits = -1L;
  else if (s->basedead && !(s->regbits & regbit(s->basereg)) &&
           !usrdbg(DBG_VAR)) {
    int32 maxoffset = 0;
    bool fake_wb = YES;
    for (r = 0; r < 16; r++)
      if (s->regbits & regbit(r)) {
        int32 off = s->offset[r];
        if (maxoffset == 0 ||
            maxoffset >= 0 && off >= 0 ||
            maxoffset <= 0 && off <= 0)
          maxoffset = off;
        else
          fake_wb = NO;
      }
    if (fake_wb) {
      s->baseadjust = maxoffset;
      regbits = -1L;
    }
  }

  for (r = 0; r < 16; r++)
    if (s->regbits & regbits & regbit(r)) {
      unsigned count = 1;
      RealRegister lastr;
      SavedLDM *cur = &ldm[ldmix];
      s->regbits ^= regbit(r);
      cur->regset = regbit(r);
      cur->endoff = cur->startoff = s->offset[r];
      cur->lastreg = r;
      for (lastr = r-1; lastr >= 0 && count < ldm_regs_max; lastr--, count++)
        if ((s->regbits & regbit(lastr)) && s->offset[lastr] == cur->startoff-4) {
          s->regbits ^= regbit(lastr);
          cur->regset |= regbit(lastr);
          cur->startoff -= 4;
        }
      for (lastr = r+1; lastr < 16 && count < ldm_regs_max; lastr++, count++)
        if ((s->regbits & regbit(lastr)) && s->offset[lastr] == cur->endoff+4) {
          s->regbits ^= regbit(lastr);
          cur->regset |= regbit(lastr);
          cur->endoff += 4;
          cur->lastreg = lastr;
        }
      { SavedLDM *p, **pp = &ldmp;
        if (cur->regset & regbit(s->basereg)) {
        /* if the base register is in the set to be loaded, it must be done last. */
          for (; (p = *pp) != NULL; pp = &cdr_(p)) /* nothing */;
          atend = cur;
        } else {
        /* if there is writeback, sort into order of offset (increasing if increment,
           decreasing if decrement).  If not, any order will do.  This is all in aid
           of not pushing stuff on the stack before SP is advanced / popping it after
           SP retreats (in case base is R_SP).
         */
          for (; (p = *pp) != atend; pp = &cdr_(p))
            if ((s->baseadjust > 0 && cur->startoff < p->startoff) ||
                (s->baseadjust < 0 && cur->startoff > p->startoff))
              break;
        }
        *pp = cur; cdr_(cur) = p;
        ldmix++;
      }
    }

  ldm_printf("-- ldm_flush: (A) s->regbits = %#lx; s->baseadjusted = %#lx; s->baseadjust = %#lx\n",
    s->regbits, s->baseadjusted, s->baseadjust);

  if (s->regbits == 0) {
    s->state = PENDING_NONE;
  }
  s->baseadjusted = 0;
  for (; ldmp != NULL; ldmp = cdr_(ldmp))
    ldmstm_generate(ldmp, s);

  ldm_printf("-- ldm_flush: (B) s->regbits = %#lx; s->baseadjusted = %#lx; s->baseadjust = %#lx\n",
    s->regbits, s->baseadjusted, s->baseadjust);

  if (s->regbits != 0) {
    for (r = 0; r < 16; r++)
      if (s->regbits & regbit(r))
        s->offset[r] -= s->baseadjusted;
  } else if (s->baseadjust != 0 && !s->basedead)
  {
    add_integer(s->basereg, s->basereg, s->baseadjust, 0);
  }
}

static void ldm_flush(void) {
  ldm_flush_r(-1L);
}

static int ldm_addregoff(LoadOrStoreMul *s, int32 w, int32 basedead)
{ RealRegister reg = RD(w);
  int32 off = OFFSET(w);
  int32 off_s = s->baseadjust;
  int32 newadjust = off_s;

  if ((w & OP_CLASS) == OP_PREN) {
    off_s += off;
    if (w & F_WRITEBACK) newadjust = off_s;
  } else
    newadjust += off;

  if ((reg == s->basereg || (regbit(s->basereg) & s->regbits)) &&
      newadjust != 0)
    return NO;

  if (regbit(reg) & s->regbits) { /* already have this reg */
    if (s->state == PENDING_ST) {
      if (s->offset[reg] != off_s) { /* storing to different place */
        return NO; /* handle it yourself! */
      }
    }
  } else {
    if (s->state == PENDING_ST) {
    /* if a store, we must check there isn't already a store to the same
       place pending.  If there is, we may just throw it away - it hasn't
       been used
     */
      RealRegister r;
      for (r = 0; r < 16; r++)
        if ((s->regbits & regbit(r)) && s->offset[r] == off_s) {
          s->regbits ^= regbit(r);
          break;
        }
    }
    s->regbits |= regbit(reg);
  }
  s->offset[reg] = off_s;
  s->baseadjust = newadjust;
  s->basedead = basedead;
  /*
   * Now if this LDR has loaded the basereg, must not allow any
   * more to get peepholed onto it...
   */
  ldm_printf("-- ldm add %s %ld : [%ld, %ld]\n",
             s->state == PENDING_ST ? "store": "load",
             reg, s->basereg, off_s);

  if (reg == s->basereg) ldm_flush();
  return YES;
}

static void ldm_outinstr(int32 w, int32 basedead)
{ struct LoadOrStoreMul *s = &ldm_state;
  if (s->state != PENDING_NONE) {
    RealRegister base = RN(w);
    if (base == s->basereg &&
        !(OP_IS_STR(w) && RD(w) == base)) /* not worth the trouble */
    { if (((s->state == PENDING_LD) ? OP_IS_LDR(w) : OP_IS_STR(w)) &&
          ldm_addregoff(s, w, basedead))
        return;
    }
    ldm_flush();
  }
  if (var_ldm_enabled==0 || (RN(w) == R_PC)) {
    outinstr(w); return;
  }
  else if (OP_IS_LDR(w)) { s->state = PENDING_LD; s->isload = YES; }
  else if (OP_IS_STR(w)) { s->state = PENDING_ST; s->isload = NO; }

   /* Now we are starting a fresh LDM/STM. */
  s->basereg = RN(w);
  s->regbits = 0;
  s->baseadjust = 0;
  ldm_addregoff(s, w, basedead);
}

static void ldm_c_flush(int32 regbits, int32 setscond) {
  if (ldm_state.state != PENDING_NONE) {
    if ((regbits & regbit(ldm_state.basereg)) ||
        (setscond && condition_mask != C_ALWAYS))
      ldm_flush();
    else if (ldm_state.regbits & regbits)
      ldm_flush_r(regbits);
  }
}

/*
 * End of the stuff to peephole LDM and STM.
 */

#define LABREF_BRANCH 0x00000000  /* ARM addressing modes for forw. refs. */
#define LABREF_B4096  0x01000000
#define LABREF_W256   0x02000000

struct DispDesc { int32 u_d, m; RealRegister r; };

static struct {
    bool valid;
    RealRegister base;
    int32 offset;
} ipvalue;

static void bigdisp(struct DispDesc *x, int32 m, int32 mask, RealRegister r2r)
{   int32 w, modm;
    if (m<0)
        w = F_DOWN, modm = -m;
    else
        w = F_UP, modm = m;
    if (modm & ~mask)  /* This can happen via LDRV/STRV with big frames */
    {   int32 ip = frameregs[R_IP];
        int32 n;
        ldm_c_flush(regbit(r2r), 0);
        ldm_c_flush(regbit(ip), 0);
        if (ipvalue.valid && ipvalue.base == r2r) {
            int32 xw, offset = m - ipvalue.offset;
            if (offset < 0)
                xw = F_DOWN, offset = -offset;
            else
                xw = F_UP;
            if (offset <= mask) {
                x->u_d = xw; x->m = offset; x->r = ip;
                return;
            }
        }
        n = modm & ~mask;
        if (!(w & F_UP)) n = -n;
        add_integer(ip, r2r, n, 0);
        if (condition_mask == C_ALWAYS) {
            ipvalue.valid = YES; ipvalue.base = r2r; ipvalue.offset = n;
        } else
            ipvalue.valid = NO;
        r2r = ip;
        modm &= mask;
    }
    x->u_d = w;
    x->m = modm;
    x->r = r2r;
}

typedef union count_position
{
    struct ss
    {   unsigned int posn:12,
                     line:16,
                     file:4;
    } s;
    int32 i;
} count_position;

#ifndef TARGET_IS_HELIOS
static void arthur_module_relocation(void)
{
  /*
   * Dump relocation directives to relocate refs to
   * sl, -#_Lib$Reloc$Off and sl, -#_Mod$Reloc$off.
   */
  Symstr *name;

  if (arthur_module == 1) {
    name = mod_reloc_sym;
  } else if (arthur_module == 2) {
    name = lib_reloc_sym;
  } else {
    syserr(syserr_module_reloc, arthur_module);
    return;
  }
  obj_symref(name, 0, 0);  /* really a sort of xr_abs -- not code not data */
  AddCodeXref3(X_backaddrlit | (codebase+codep), name);
}
#endif

/* The notion of addressability is common, but w.r.t what varies
   between machines.
*/
static void addressability(int32 n)
{
/* the next line does not hide sloppy programming, but allows us to test
 * whether we have run out of addressability before we know exactly how
 * many (less than 5!) arm instructions a JOPCODE will generate.
 */
    n -= 5;
    if (litpoolp>=n) dumplits2(YES);
    if (codep-4*litpoolp+4*n < mustlitby) mustlitby = codep-4*litpoolp+4*n;
}

#ifdef TARGET_IS_HELIOS
bool is_function(Symstr *name)
/*
 * Needed when an adcon is formed - functions are treated specially.
 * Probably not machine specific, so should go elsewhere.
 */
{   Binder *b = bind_global_(name);
    if (b == NULL ) return 1;                 /* Default to true */
    return ((bindstg_(b) & b_fnconst) != 0);
}

void outINIT(void)
{
    AddCodeXref3(X_Init+codebase+codep,0);
    outcodeword(0, LIT_NUMBER);
}

#endif

#ifdef TARGET_IS_HELIOS

static void load_static_physical_reg(RealRegister r)
{
/*
 * DP points at the module table - load r with the static base needed
 * in this module.  The linker will allocate a module table slot and fill
 * in the offset in the LDR instruction here.
 */
    ldm_flush();
    AddCodeXref3(X_Modnum+codebase+codep, 0);

/*
 *              LDR r, [DP, #current_module_number<<2]
 */
    outinstr(OP_PREN | F_LDR | F_WORD | F_UP | F_RD(r) | F_RN(R_DP));
}

void load_static_data_ptr(RealRegister r)
{
/*
 * Oh misery - on the ARM the external interface to this must use mapped
 * register numbers - the internal one real physical register numbers.
 */
    load_static_physical_reg(physical_register(r));
}

static Symstr *find_data_start(Symstr *name)
/*
 * This routine will find another data symbol with the same offset
 * as the one provided as its argument. This is used in the Helios
 * compiler when compiling with the -zr flag so that we don't
 * have lots of __dataseg symbols.
 */
{
    ExtRef *r,*dext;
    dext = symext_(name)->extcdr;   /* @@@ dodgy order dependency? */

    for (r=dext ; r != NULL; r = r->extcdr)
    {
        if( (r->extflags & xr_data)  && (r->extoffset == dext->extoffset) )
        return r->extsym;
    }
    /* /* the following line will die if the first static in a file */
    /* is local to a function and so has not global name.           */
    syserr(syserr_datasymb, dext->extoffset);
    return 0;
}

static bool static_definition(Symstr *name)
/* /*
 * ACN wonders about this - it tests if a given spelling (Symstr) is in
 * use with static extent.  What semantically valid question can this
 * answer given that it is asking a question of a Symstr not a Binder?
 * LDS: (30-Oct-92) Now only works for top-level things...
 */
{   Binder *b = bind_global_(name);
    if (b != 0 && (bindstg_(b) & bitofstg_(s_static)) != 0) return 1;
    else return 0;
}

static void load_adcon(RealRegister r1, Symstr *name, int32 offset)
{
    ExtRef *x ;
    RealRegister tr;
/* /*
 * ACN worries about the xr_<bits> handed to obj_symref here, an in particular
 * the difference between refs to code & refs to data.  Help is required
 * from AM to sort out how critical this is an to patch it up.  Indeed
 * both in the Helios parts of this file and in heliosobj.c (and in gen
 * files for other Helios-targetted systems) the xr_qqq bits need
 * checking.
 */
    int32 d = obj_symref(name, 0, 0);   /* ensure OK, xr_xxx */

    x = symext_(name);
    if( (x->extflags & xr_data) && (x->extflags & (xr_defext+xr_defloc)) )
    {   /* A previously defined data symbol */
/*
 *  LDR      r1, [dp, modnum]
 *  ADD      r1, r1, #name+offset
 *  ADD      r1, r1, #<high offset>
 *         where name is the offset of the symbol in our data seg
 *
 *  X is the size of the exported code symbols in our data segment
 *  it is not known yet - but will be at the end.
 */
        if( x->extflags & xr_defloc )
        {
            if( strcmp("__dataseg", symname_(name)) == 0) /* YUK!! (acn) */
            {
               name = find_data_start(name);
               x    = symext_(name);
            }
        }

        load_static_physical_reg(r1);

        AddCodeXref4(X_DataSymb2+codebase+codep, name, offset);
        outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(r1) | 000);
        AddCodeXref4(X_DataSymb3+codebase+codep, name, offset);
        outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(r1) | 000);
    }
    else if(  d != -1 && !in_stubs)
    {   /* A previously defined code symbol */
/*
 *  ADD    r1, pc, #xxx
 *  [or some suitable sequence of ADDs to allow for large offset #xxx]
 *    This code is not used if we are generating stubs since
 *    the symbol will have been defined for the purposes of
 *    pointing a data variable at it and that is not the
 *    definition of the symbol that we actually want!
 *    Observe adjustment by 8 bytes to allow for ARM pipeline.
 */
        add_integer(r1, R_PC, d-(codep+codebase+8)+offset, 0);
    }
    else if (static_definition( name ) ||
             (suppress_module && is_function(name)))
    {                           /* Not yet defined internal code symbol */
/*
 *  ADD     r1, pc, #xxx     {Low part of offset}
 *  ADD     r1, r1, #yyy     {high part of offset}
 */
        AddCodeXref5(X_PCreloc2+codebase+codep, name, offset, 0);
        outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(R_PC) | 000);
        AddCodeXref5(X_PCreloc3+codebase+codep, name, offset, 0);
        outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(r1) | 000);
    }
/* All we have left are the external code and data symbols */
    else
    {
/*
    LDR     r1, [dp, #@name]
    LDR     r1, [r1, #name]     -- for functions
or
    LDR     r1, [dp, #@name]
    ADD     r1, r1, #name       -- for data
    ADD     r1, r1, #name_high
*/
        AddCodeXref4(X_DataModule+codebase+codep, name, 0);
        outinstr(OP_PREN | F_LDR | F_WORD | F_UP | F_RD(r1) | F_RN(R_DP));

        if( is_function(name) )
        {
            AddCodeXref4(X_DataSymb+codebase+codep, name, offset);
            outinstr(OP_PREN | F_LDR | F_WORD | F_UP | F_RD(r1) | F_RN(r1));
        }
        else
        {
            AddCodeXref4(X_DataSymb2+codebase+codep, name, offset);
            outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(r1) | 000);
            AddCodeXref4(X_DataSymb3+codebase+codep, name, offset);
            outinstr(OP_RXN | F_ADD | F_RD(r1) | F_RN(r1) | 000);
        }
    }
}


static void call_k(Symstr *name, bool tailcall, int32 xrflags, int32 t)
/*
 * Use for Helios equivalent of BSR name or B name, but has to deal
 * with module-table based addressing of procedures.
 */
{
    int32 dest;
    if (in_stubs)
    {   /* The next line follows outinstr3 (q.v).                  */
        int32 ip = frameregs[R_IP];
        obj_symref(name, xr_code | xrflags, 0);
                                        /* ensure marked as code.  */
        load_adcon(ip, name, 0);
        ipvalue.valid = NO;
        if (!tailcall) outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        outinstr(OP_RXR | F_MOV | F_RD(R_PC) | ip);
        return;
    }

    dest  = outinstr3(tailcall ? OP_B : OP_BL, name, xrflags);
    if (dest != -1) return;        /* previously defined routine */

/* Static forward or external calls are generated in the same   */
/*  way. The addition to the stublist will be removed if the    */
/*  function is subsequently defined.                           */

    request_stub(name);

}

#else  /* TARGET_IS_HELIOS */

#define call_k(name, tail, xrflags, t) outinstr3t((tail) ? OP_B : OP_BL, name, xrflags, t)

#endif /* TARGET_IS_HELIOS */

static void killipvalue(RealRegister r)
{
    if (r == frameregs[R_IP] || r == ipvalue.base) ipvalue.valid = NO;
}

static void adjustipvalue(RealRegister r1, RealRegister r2, int32 k)
{
    if (ipvalue.valid && r1 == r2) {
        if (r1 == frameregs[R_IP]) {
            if (condition_mask == C_ALWAYS)
                ipvalue.offset += k;
            else
                ipvalue.valid = NO;
        } else if (r1 == ipvalue.base) {
            if (condition_mask == C_ALWAYS)
                ipvalue.offset -= k;
            else
                ipvalue.valid = NO;
        }
    } else
        killipvalue(r1);
}

int32 a_loads_r1(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_set_r1:
                                                  loads_r1(op);
}

int32 a_uses_r1(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ?
             a_attributes(op) & (_a_set_r1 | _a_read_r1) :
             uses_r1(op);
}

int32 a_reads_r1(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_read_r1 :
                                                  reads_r1(op);
}

int32 a_loads_r2(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_set_r2:
                                                  loads_r2(op);
}

int32 a_uses_r2(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ?
             a_attributes(op) & (_a_set_r2 | _a_read_r2) :
             uses_r2(op);
}

int32 a_reads_r2(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_read_r2 :
                                                  reads_r2(op);
}

int32 a_uses_r3(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_read_r3 :
                                 uses_r3(op);
}

int32 a_uses_r4(J_OPCODE op, int32 peep)
{
   return (peep & P_RSHIFT) ||
          ((op & J_TABLE_BITS) > J_LAST_JOPCODE && (a_attributes(op) & _a_read_r4));
}

int32 a_modifies_mem(J_OPCODE op)
{
    return (op & J_TABLE_BITS) > J_LAST_JOPCODE ? a_attributes(op) & _a_modify_mem :
                                  stores_r1(op) ? 1 :
                                 op == J_PUSHM || op == J_PUSHF || op == J_PUSHD ||
                                 op == J_MOVC || op == J_CLRC;
}

bool setspsr(J_OPCODE op, int32 m)
{
    return (    is_compare(op)
             || (op == J_CASEBRANCH)
             || ((op == J_MOVC || op == J_CLRC || op == J_PUSHC) &&
                 m > MOVC_LOOP_THRESHOLD)
             || (op == J_OPSYSK && (var_cc_private_flags & 512L))
             || ((pcs_flags & PCS_CALLCHANGESPSR) &&
                 (op == J_CALLK || op == J_CALLR || op == J_CALLI)
                 /* J_COUNT is ok because the count functions don't
                    alter the psr.
                  */
                )
           );

}

static int32 resultregs(RealRegister r2r) {
    static const int32 rr[] = {
        regbit(R_A1),  /* suspect 0 used sometimes where 1 would be correct */
        regbit(R_A1),
        regbit(R_A1)|regbit(R_A2),
        regbit(R_A1)|regbit(R_A2)|regbit(R_A3),
        regbit(R_A1)|regbit(R_A2)|regbit(R_A3)|regbit(R_A4)
    };
    return rr[k_resultregs_((int32)r2r)];
}

static const int32 arm_cc[] = { C_EQ, C_NE, C_HS, C_LO, C_PL, C_MI, C_VS, C_VC,
                                C_HI, C_LS, C_GE, C_LT, C_GT, C_LE, 0,    C_NEVER};

static void tailcallxk(RealRegister r4, int32 m, int32 inst) {
    inst |= F_RN(r4) | m;
    if (!((regmask & (M_VARREGS|M_LR)) & regbit(r4))) {
        routine_exit(C_FROMQ(Q_AL), NO);
        outinstr(inst | F_RD(R_PC));
    } else {
    /* r4 is something restored by routine_exit() */
        int32 ip = frameregs[R_IP];
        outinstr(inst | F_RD(ip));
        routine_exit(C_FROMQ(Q_AL), NO);
        outinstr(OP_RXR | F_MOV | F_RD(R_PC) | ip);
    }
    ipvalue.valid = NO;
}

static void tailcallxr(RealRegister r4, RealRegister mr, int32 inst) {
    inst |= F_RN(r4) | mr;
    if (!((regmask & (M_VARREGS|M_LR)) & (regbit(r4)|regbit(mr)))) {
        routine_exit(C_FROMQ(Q_AL), NO);
        outinstr(inst | F_RD(R_PC));
    } else {
    /* m or r4 is something restored by routine_exit() */
        int32 ip = frameregs[R_IP];
        outinstr(inst | F_RD(ip));
        routine_exit(C_FROMQ(Q_AL), NO);
        outinstr(OP_RXR | F_MOV | F_RD(R_PC) | ip);
    }
    ipvalue.valid = NO;
}

void show_inst_direct(PendingOp *p)
/* The types of the arguments here are rather unsatisfactory - in        */
/* particular m is really a big union.                                   */
{
    struct DispDesc dispdesc;
    int32 w, msh = 0, illbits;
    J_OPCODE op = p->op;
    RealRegister r1r = p->r1, r2r = p->r2, mr = p->m, r4 = p->r4;
    int32 peep = p->peep, dataflow = p->dataflow;
    int32 r1 = r1r, r2 = r2r, m = mr;
    bool dont_kill_ip = NO;
    int32 regsused = 0;

    if (localcg_debug(4)) a_pr_jopcode(p);

/* Should this really be arranged as:
 *  union { Symstr *sym; int32 umint; } um;
 *  um.umint = m;
 */
    if (codep >= mustlitby) dumplits2(YES);
    if (a_uses_r1(op)) {
        if (r1r >= (unsigned32) 24l) syserr(syserr_r1r, (long)r1r);
        r1r = physical_register(r1r);
        regsused |= regbit(r1r);
    }
    if (a_uses_r2(op)) {
        if (r2r >= (unsigned32) 24l) syserr(syserr_r2r, (long)r2r);
        r2r = physical_register(r2r);
        regsused |= regbit(r2r);
    }
    if (a_uses_r3(op)) {
        if (mr >= (unsigned32) 24l) syserr(syserr_mr, (long)mr);
        mr = physical_register(mr);
        regsused |= regbit(mr);
    }
    if (a_uses_r4(op, peep)) {
        r4 = physical_register(r4);
        regsused |= regbit(r4);
    }

    msh = (op & J_SHIFTMASK) >> J_SHIFTPOS;
    if ((msh & SHIFT_RIGHT) == 0) {
        if (msh & SHIFT_ARITH)
        /* this encoding for ROR (left + arith) is somewhat delicate */
            msh = K_ROR(msh & SHIFT_MASK);
        else
            msh = K_LSL(msh & SHIFT_MASK);
    } else if (msh & SHIFT_ARITH) msh = K_ASR(msh & SHIFT_MASK);
    else msh = K_LSR(msh & SHIFT_MASK);
    if (peep & P_RSHIFT)
    {   if (msh) syserr(syserr_shifts);
        switch (peep & P_RSHIFT)
        {
    case P_LSL: msh = R_LSL(r4);    break;
    case P_LSR: msh = R_LSR(r4);    break;
    case P_ASR: msh = R_ASR(r4);    break;
    case P_ROR: msh = R_ROR(r4);    break;
        }
    }
    if (a_loads_r1(op)) spareregs &= ~regbit(r1r);

/* to enable future JOPCODE peephole optimisation expand_jop_macros()
   tries quite hard not to call show_inst() with instructions with
   no effect.
*/
    /* illbits (and peep) check that unexpected (erroneous!) bits are not set */
    illbits = op & (Q_MASK | J_SIGNED | J_UNSIGNED | J_NEGINDEX | J_SHIFTMASK);
    switch (op & ~(Q_MASK | J_SIGNED | J_UNSIGNED | J_NEGINDEX | J_SHIFTMASK))

#define prepost(op) \
    ((peep & P_POST) ? (peep &= ~P_POST, OP_POSTN) : \
     (peep & P_PRE) ? (peep &= ~P_PRE, OP_PREN | F_WRITEBACK) : OP_PREN)

#define prepostr(op) \
    ((peep & P_POST) ? (peep &= ~P_POST, OP_POSTR) : \
     (peep & P_PRE) ? (peep &= ~P_PRE, OP_PRER | F_WRITEBACK) : OP_PRER)

    {
case J_ORG:
        /* pad with OP_NOOP's -- here mov r0,r0.  Proper code?          */
        while (codep < m) outinstr(OP_RXR | F_MOV);
        if (codep != m) syserr("J_ORG");
        break;
case J_WORD:
        ldm_flush();
        outinstr(m ^ C_ALWAYS);
        break;
case J_CMPK:
/* N.B. that CMPK can use R_IP as a work register               */
        ldm_c_flush(regsused | regbit(frameregs[R_IP]), 1);
        compare_integer(r2r, m, frameregs[R_IP], op & Q_MASK, 0);
        illbits &= ~Q_MASK;
        break;

#ifdef RANGECHECK_SUPPORTED
case J_CHKLK:
        ldm_flush();
        compare_integer(r2r, m, frameregs[R_IP], Q_LT, 0);
        outinstr3(OP_BL ^ Q_LT, sim.abcfault, 0);
        break;
case J_CHKUK:
        ldm_flush();
        compare_integer(r2r, m, frameregs[R_IP], Q_GT, 0);
        outinstr3(OP_BL ^ Q_GT, sim.abcfault, 0);
        break;

case J_CHKLR:
        ldm_flush();
        outinstr(OP_RXR | F_CMP | F_SCC | F_RN(r2r) | mr | msh);
        outinstr3(OP_BL ^ Q_LT, sim.abcfault, 0);
        break;
case J_CHKUR:
        ldm_flush();
        outinstr(OP_RXR | F_CMP | F_SCC | F_RN(r2r) | mr | msh);
        outinstr3(OP_BL ^ Q_GT, sim.abcfault, 0);
        break;

case J_CHKNEK:
        ldm_flush();
        compare_integer(r2r, m, frameregs[R_IP], Q_EQ, 0);
        outinstr3(OP_BL ^ Q_EQ, sim.valfault, 0);
        break;

#endif /* RANGECHECK_SUPPORTED */

/* N.B. having someone (e.g. show_instruction) changing the next 3 ops into */
/* ADDK 0; RSBK 0; and RSBK -1; would simplify peepholing them with CMP 0   */
/* and remove 3 cases from this table but using more general code           */
/* No - a better idea: use the peepholer to squash shifts and ops together  */
/* (via V_INTERNAL reg), but also turn solitary shifts into J_MOV+J_SHIFTM  */
/* N.B. This would make J_SHIFTM a P_PEEPn bit local to this file           */
case J_MOVR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        if (r1r==mr) syserr(syserr_remove_noop);
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | mr | SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_NEGR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_RXN | F_RSB | F_RD(r1r) | F_RN(mr) | SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        illbits &= ~J_SHIFTMASK;
        break;
case J_NOTR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_RXR | F_MVN | F_RD(r1r) | mr | msh | SCC_of_PEEP(peep));
        peep &= ~(P_RSHIFT | P_CMPZ | Q_MASK);
        illbits &= ~J_SHIFTMASK;
        break;
case J_MOVK:
        ldm_c_flush(regsused, 0);
        load_integer(r1r, m, 0);
        break;

case J_ADDK:
        if (r1r == r2r && ldm_state.state != PENDING_NONE &&
            r1r == ldm_state.basereg && !(peep & P_CMPZ)) {
            ldm_state.baseadjust += m;
        } else {
            ldm_c_flush(regsused, SCC_of_PEEP(peep));
            add_integer(r1r, r2r, m, SCC_of_PEEP(peep));
            adjustipvalue(r1r, r2r, m);
            dont_kill_ip = YES;
            peep &= ~(P_CMPZ | Q_MASK);
        }
        break;
/* case J_SUBK turned into J_ADDK earlier */
case J_RSBK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        rsb_integer(r1r, r2r, m, SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_ANDK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        and_integer(r1r, r2r, m, peep, dataflow & J_DEAD_R1);
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_ORRK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        orr_integer(r1r, r2r, m, SCC_of_PEEP(peep), F_ORR);
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_EORK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        orr_integer(r1r, r2r, m, SCC_of_PEEP(peep), F_EOR);
        peep &= ~(P_CMPZ | Q_MASK);
        break;

case J_MULK:
        ldm_c_flush(regsused | regbit(frameregs[R_IP]), SCC_of_PEEP(peep));
        multiply_integer(r1r, r2r, m, SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_SHRK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        if (m!=0)
        {   if (m<0 || m>32) syserr(syserr_silly_shift, (long)m);
            outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) |
                     (op & J_SIGNED ? K_ASR(m) : K_LSR(m)));
            illbits &= ~(J_SIGNED|J_UNSIGNED);
            peep &= ~(P_CMPZ | Q_MASK);
            break;
        }
        /* drop through if shift by 0 */
case J_SHLK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        if (m<0 || m>31) syserr(syserr_silly_shift, (long)m);
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) | K_LSL(m));
        peep &= ~(P_CMPZ | Q_MASK);
        illbits &= ~(J_SIGNED|J_UNSIGNED);
        break;
case J_RORK:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        if (m<=0 || m>31) syserr(syserr_silly_shift, (long)m);
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) | K_ROR(m));
        peep &= ~(P_CMPZ | Q_MASK);
        break;

case J_SHLR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) | R_LSL(mr));
        peep &= ~(P_CMPZ | Q_MASK);
        illbits &= ~(J_SIGNED|J_UNSIGNED);
        break;
case J_SHRR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) |
                 (op & J_SIGNED ? R_ASR(mr) : R_LSR(mr)));
        peep &= ~(P_CMPZ | Q_MASK);
        illbits &= ~(J_SIGNED|J_UNSIGNED);
        break;
case J_RORR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_RXR | F_MOV | F_RD(r1r) | r2r | SCC_of_PEEP(peep) |
                 R_ROR(mr));
        peep &= ~(P_CMPZ | Q_MASK);
        illbits &= ~(J_SIGNED|J_UNSIGNED);
        break;
case J_CMPR:
        ldm_c_flush(regsused, 1);
        {   int32 mask = op & (Q_MASK & ~Q_UBIT);
            int32 opc = (mask == Q_EQ || mask == Q_NE) ? F_TEQ : F_CMP;
            outinstr(OP_RXR | opc | F_SCC | F_RN(r2r) | mr | msh);
        }
        illbits &= ~(Q_MASK|J_SHIFTMASK);
        peep &= ~P_RSHIFT;
        break;

case J_ANDR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        {   int32 opc = OP_RXR | F_AND, rd = F_RD(r1r);
            if ((dataflow & J_DEAD_R1) && (peep & P_CMPZ))
                opc = OP_RXR | F_TST, rd = 0;
            outinstr(opc | SCC_of_PEEP(peep) | rd | F_RN(r2r) | mr | msh);
            illbits &= ~J_SHIFTMASK, peep &= ~(P_CMPZ|Q_MASK|P_RSHIFT);
            break;
        }

#define irrop(alu)                                                  \
        ldm_c_flush(regsused, SCC_of_PEEP(peep));                   \
        outinstr(OP_RXR | (alu) | SCC_of_PEEP(peep) |               \
                 F_RD(r1r) | F_RN(r2r) | mr | msh);                 \
        illbits &= ~J_SHIFTMASK, peep &= ~(P_CMPZ|Q_MASK|P_RSHIFT);

case J_BICR:
        irrop(F_BIC); break;
case J_ORRR:
        irrop(F_ORR); break;
case J_EORR:
        irrop(F_EOR); break;
case J_ADDR:
        irrop(F_ADD); break;
case J_SUBR:
        irrop(F_SUB); break;
case J_RSBR:
        irrop(F_RSB); break;

#undef irrop

case J_MLA:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_MLA | F_RN(r1r) | F_RD(r4) |  (r2r << 8) | mr | SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        break;
case J_MULR:
        ldm_c_flush(regsused, SCC_of_PEEP(peep));
        outinstr(OP_MUL | F_RN(r1r) | (r2r << 8) | mr | SCC_of_PEEP(peep));
        peep &= ~(P_CMPZ | Q_MASK);
        break;

case J_OPSYSK:
        ldm_flush();
        outinstr(OP_SWI | m);
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4)) & ~resultregs(r2r);
        if (feature & FEATURE_INLINE_CALL_KILLS_LINKREG) spareregs |= M_LR;
        break;

case J_CALLK:
        ldm_flush();
        call_k((Symstr *)m, 0, (k_fltregs_(r2) != 0 ? aof_fpreg : 0), 0);
        ipvalue.valid = NO;
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        /* This set may be wrong if the usage of caller-save registers of the
           target function is precisely known (TypeExprFnAux.usedregs), but
           spareregs is used only in expanding MOVC/CLRC, and for functions
           containing these we suppress knowledge of the usage of called
           functions. (Better would be to have usedregs of the called function
           available from the jopcode stream).
         */
        break;

case J_TAILCALLK:
        ldm_flush();
        if (pcs_flags & PCS_REENTRANT)
            outinstr(OP_RXR | F_MOV | F_RD(frameregs[R_IP]) | R_SB | SCC_of_PEEP(peep));
        routine_exit(C_FROMQ(Q_AL), NO);
        call_k((Symstr *)m, 1, (k_fltregs_(r2) != 0 ? aof_fpreg : 0), pcs_flags & PCS_REENTRANT);
        ipvalue.valid = NO;
        break;

case J_CALLR:
        /* c.regalloc has ensured that mr and R_LR clash */
        ldm_flush();
        outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        outinstr(OP_RXR | F_MOV | F_RD(R_PC) | mr);
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        ipvalue.valid = NO;
        break;
case J_CALLX:
        ldm_flush();
        outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        {   int32 iop = F_ADD;
            if (m < 0) iop = F_SUB, m = -m;
            outinstr(OP_RXN | iop | F_RD(R_PC) | F_RN(r4) | m);
        }
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        ipvalue.valid = NO;
        break;
case J_CALLI:
        ldm_flush();
        outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        bigdisp(&dispdesc, m, 0xfff, r4);
        outinstr(prepost(op) | F_LDR | dispdesc.u_d | F_WORD | F_RD(R_PC) |
                 F_RN(dispdesc.r) | dispdesc.m);
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        ipvalue.valid = NO;
        break;
case J_CALLXR:
        ldm_flush();
        outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        outinstr(OP_RXR | ((op & J_NEGINDEX) ? F_SUB : F_ADD) | F_RD(R_PC) | F_RN(r4) | mr | msh);
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        ipvalue.valid = NO;
        break;
case J_CALLIR:
        ldm_flush();
        outinstr(OP_RXR | F_MOV | F_RD(R_LR) | R_PC);
        outinstr(OP_PRER | F_LDR | (op & J_NEGINDEX ? F_DOWN : F_UP) | F_WORD |
                 F_RD(R_PC) | F_RN(r4) | mr | msh);
        spareregs = (regbit(R_A2) | regbit(R_A3) | regbit(R_A4) | M_LR) & ~resultregs(r2r);
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        ipvalue.valid = NO;
        break;
case J_TAILCALLX:
        ldm_flush();
        tailcallxk(r4, (m < 0 ? -m : m), OP_RXN | (m < 0 ? F_SUB : F_ADD));
        ipvalue.valid = NO;
        break;
case J_TAILCALLI:
        ldm_flush();
        bigdisp(&dispdesc, m, 0xfff, r4);
        tailcallxk(dispdesc.r, dispdesc.m, prepost(op) | F_LDR | dispdesc.u_d | F_WORD);
        ipvalue.valid = NO;
        break;
case J_TAILCALLXR:
        ldm_flush();
        tailcallxr(r4, mr, OP_RXR | ((op & J_NEGINDEX) ? F_SUB : F_ADD) | msh);
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        break;
case J_TAILCALLIR:
        ldm_flush();
        tailcallxr(r4, mr, OP_PRER | F_LDR | (op & J_NEGINDEX ? F_DOWN : F_UP) |
                           F_WORD | msh);
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        break;
case J_TAILCALLR:
        ldm_flush();
        tailcallxk(mr, 0, OP_RXN | F_ADD);
        break;
case J_COUNT:
        ldm_flush();
#ifndef TARGET_IS_UNIX
#  ifndef PROFILE_COUNTS_INLINE
        outinstr3(OP_BL, fn_entry_sym, 0);
        ipvalue.valid = NO;
#  else
/* (int)r1 is ? (I would like the character on the line) ????              */
/* (char *)r2 is the name of the file, and (int)m is the line number       */
/* within that file. I will assume here a sensible limit on the length     */
/* of files and hence pack these two pieces of information into a single   */
/* 32-bit word. The structure used is count_position, and up to 16 files   */
/* can be referenced. If there is any danger of running out of same I will */
/* flush out the table used to decode files names and start again.         */
        {   count_position k;
            k.i = 0;         /* just to stop compiler winging */
            /* beware that the next line may flush literals etc. */
            k.s.file = lit_of_count_name((char *)r2);
            k.s.line = (unsigned int)m;
            k.s.posn = 0;   /* Not available here */
            outinstr3(OP_BL, count1routine, 0);
            ipvalue.valid = NO;
            outcodeword(0, LIT_NUMBER);              /* what it increments */
            outcodeword(k.i, LIT_NUMBER);
#    ifdef TARGET_IS_HELIOS
            request_stub(count1routine);
#    endif
        }
#  endif
#endif
        break;
case J_INFOLINE:
        ldm_flush(); /* ensure codep is correct */
        dbg_addcodep((VoidStar)r1, codebase+codep);  /* hack -- see armdbg.c */
        break;
case J_INFOSCOPE:
        ldm_flush(); /* ensure codep is correct */
        dbg_addcodep(NULL, codebase+codep); /* hack -- see armdbx.c */
        break;
case J_INFOBODY:
        dbg_bodyproc(/*codebase+codep*/);
        break;
case J_STRING:
        ldm_flush();
/* flowgraf.c has replaced J_STRING by J_ADCON if FEATURE_WR_STR_LITS.    */
          /*
           * Standard ANSI mode - string lits read-only in the code seg.
           * Ensure that the literal will be dumped in time for it to be
           * addressable. Note that by using coarser alignment than 4-bytes
           * I could often cover a longer span of addresses - but that does
           * not seem worthwhile here.
           */
        {   int32 disp, offset = (int32)r2r, addon = 0;
            StringSegList *s = (StringSegList *)m;
            if ((offset & 3) != 0) addon = offset, offset = 0;
            if ((disp = lit_findstringincurpool(s)) >= 0) {
            /* This reference must be addressable if the previous one was */
            /* SNB: Actually that's wrong.  A very long string constant that was tail-matched
             * by lit_findstringincurpool could be too far away and thus cause an internal error
             * later on when attempting to patch this reference back.  The addressability check
             * is thus reintroduced here to bring mustlitby closer to codep.
             */
                addressability(256+offset/4+disp/4-litpoolp);
                addfref_(litlab, codep | LABREF_W256);
                outinstr(OP_RXN | F_ADD | F_RD(r1r) | F_RN(R_PC) | ((disp+offset) >> 2) | 0xf00);
                if (addon != 0) add_integer(r1r, r1r, addon, 0);
                break;
            }
/* NB here that on the ARM a backwards displacement can go as far as 0x3fc */
/* (=1020) but NOT as far as 0x400 (sign & magnitude, not 2's comp offset) */
            disp = lit_findstringinprevpools(s, codebase+codep+8-1020+offset);
            if (disp >= 0) {
                disp = (codebase+codep+8-disp+offset)>>2;
                outinstr(OP_RXN | F_SUB | F_RD(r1r) | F_RN(R_PC) |disp|0xf00);
                if (addon != 0) add_integer(r1r, r1r, addon, 0);
                break;
            }
#ifdef TARGET_IS_HELIOS
        /* Always generate strings in the code segment, since the case of
         * dropping through to J_ADCON has not (yet?) been adequately
         * reconstructed.
         */
#else
        /* For sufficiently long strings, we ensure that there's just one copy
         * even at the expense of more expensive access.
         */
            if (stringlength(s) <= 8 ||
                (disp = lit_findstringinprevpools(s, 0)) < 0)
#endif /* TARGET-IS-HELIOS */
            {
                addressability(256-offset/4);
                addfref_(litlab, codep | LABREF_W256);
                outinstr(OP_RXN | F_ADD | F_RD(r1r) | F_RN(R_PC) | (litpoolp + (offset>>2)) | 0xf00);
                codeseg_stringsegs((StringSegList *)m, YES);
                if (addon != 0) add_integer(r1r, r1r, addon, 0);
                break;
            }
            m = (int32) bindsym_(codesegment);
            r2 = disp + addon + offset;
            /* fall through to generate an ADCON */
        }
case J_ADCON:
        ldm_flush();
#ifdef TARGET_IS_HELIOS
        /* flowgraf.c has done an obj_symref for code/data for m.   */
        load_adcon(r1r, (Symstr *)m, (int32)r2);
        break;
#else
        { Symstr *name = (Symstr *)m;
#ifdef TARGET_HAS_AOF
          if (name == bindsym_(constdatasegment) &&
               ((pcs_flags & PCS_REENTRANT) ||
                (pcs_flags & PCS_ACCESS_CONSTDATA_WITH_ADR))) {
            int32 offset, op = F_ADD;
            ldm_flush(); /* ensure codep is correct */
            AddCodeXref4(X_DataAddr1+codebase+codep, name, 0);
            offset = (int32)r2-(codebase+codep+8);
            if (offset < 0) op = F_SUB, offset = -offset;
            outcodewordaux(OP_RXN | condition_mask | op | F_RD(r1r) |
                             F_RN(R_PC) | eightbits(offset & 0x3fc00L),
                           LIT_RELADDR, (VoidStar)name);
            outinstr(OP_RXN | op | F_RD(r1r) | F_RN(r1r) | eightbits(offset & 0x3ffL));
          } else
#endif
          if (pcs_flags & PCS_REENTRANT) {
            int i = adconpool_find((int32)r2, LIT_ADCON, name);
            ldm_flush(); /* ensure codep is correct */
            AddCodeXref4(X_DataVal+codebase+codep, adconpool_lab, 0);
            outcodewordaux(OP_PREN | condition_mask | F_LDR | F_WORD | F_UP |
                             F_RD(r1r) | F_RN(R_SB) | i,
                           LIT_RELADDR, (VoidStar)adconpool_lab);
          } else {
            int32 offset = (int32)r2;
            int32 i;
/* Try to find adcon in following order: 1. current literal pool,        */
/* 2. previous addressable pools, 3. new allocation in current pool.     */
            if ((i = lit_findword(offset, LIT_ADCON, name,
                       LITF_INCODE|LITF_FIRST|LITF_LAST|LITF_PEEK)) >= 0)
            { /* adcon available in current literal pool */
              /* if previous ref was addressable this one will be */
              addfref_(litlab, codep | LABREF_B4096);
              outinstr(OP_PREN | F_LDR | F_WORD | F_UP | F_RD(r1r) |
                       F_RN(R_PC) | i);
            }
            else if ((i = lit_findadcon(name,offset,codebase+codep+8-0xffc))
                     >= 0)
              outinstr(OP_PREN | F_LDR | F_WORD | F_DOWN |
                       F_RD(r1r) | F_RN(R_PC) | codebase+codep+8-i);
            else
            {
/* ensure that the literal that I am about to issue can be addressed     */
              addressability(1024);
              i = lit_findword(offset, LIT_ADCON, name,
                               LITF_INCODE|LITF_FIRST|LITF_LAST|LITF_NEW);
              addfref_(litlab, codep | LABREF_B4096);
              outinstr(OP_PREN | F_LDR | F_WORD | F_UP | F_RD(r1r) |
                                 F_RN(R_PC) | i);
            }
          }
        }
        break;
#endif  /* TARGET_IS_HELIOS */
case J_LOADSB:
        ldm_flush();
#ifdef TARGET_IS_RISC_OS
        if (arthur_module)
        {
            arthur_module_relocation();
            outinstr(OP_PREN | F_LDR | F_WORD | F_DOWN | F_RD(r1r) | F_RN(frameregs[R_SL]));
        }
#endif
        break;

case J_CONDEXEC:
        ldm_flush();
        { int32 cond = op & Q_MASK;
          static bool mipl;
          if (cond == Q_MI || cond == Q_PL)
            mipl = YES;
          else if (cond == Q_AL)
            mipl = NO;
          else if (mipl) {
            if (cond == Q_LT)
              cond = Q_MI;
            else if (cond == Q_GE)
              cond = Q_PL;
          }
          /* Here we work round a problem with the peepholer turning (eg)
               ADD x.. + CMPK x,#0 + CONDEXEC(LT)
               into ADDS x.. + CONDEXEC(MI)
             (The problem is that if both arms have been conditionalised,
             the peepholer won't see the second).  This code is vulnerable
             to improvement in flowgraf's ability to conditionalise, but
             all is probably well because the real place to do improved
             conditionalisation is in gen.c instead.
           */
          condition_mask = C_FROMQ(cond) ^ C_ALWAYS;
          illbits &= ~Q_MASK;
          break;
        }
case J_B:
        ldm_flush();
        conditional_branch_to(op & Q_MASK, (LabelNumber *)m, NO);
        /* only assemble literals after a guaranteed unconditional branch */
        if (op==J_B && condition_mask == C_ALWAYS) dumplits2(NO);
        illbits &= ~Q_MASK;
        break;
case J_BXX:             /* Used with case tables */
        ldm_flush();
        conditional_branch_to(Q_AL, (LabelNumber *)m, YES);
        break;
case J_CASEBRANCH:
/* N.B. that J_CASEBRANCH can use R_IP as a work register                 */
        ldm_flush();
        compare_integer(r1r, m-2, frameregs[R_IP], Q_LS, 0);   /* -1 for default   */
        if (codep + 4*m >= mustlitby) dumplits2(YES);
        outinstr(OP_RXR | C_LS | F_ADD | F_RD(R_PC) | F_RN(R_PC) |
                    r1r | K_LSL(2));
        break;
case J_LABEL:
        ldm_flush();
        setlabel((LabelNumber *)m);
        spareregs = 0;
        ipvalue.valid = NO;
        break;
case J_STACK:
        fp_minus_sp = m;
        break;
case J_LDRBK:
        ldm_flush();
        { bool in_ms_byte = NO;
          if (op & J_SIGNED) {
            if (!(config & CONFIG_NO_UNALIGNED_LOADS)) {
            /* For signed loads, we can use the barrel shifter to rotate the
               byte we want into the MS byte of the word, saving a shift in
               propagating the sign, provided that we know that the base is
               word-aligned.  (Unfortunately, the hardware doesn't do the
               sensible thing on big-endian ARMs, rotating the desired byte
               into the MS byte only for offsets 0 and 2 mod 4)
             */
              if ((peep & (P_PRE|P_POST|P_BASEALIGNED)) == P_BASEALIGNED) {
                if (!target_lsbytefirst)
                  in_ms_byte = (m & 1) == 0;
                else {
                  m = (m & ~3L) | ((m+1) & 3L);
                  in_ms_byte = YES;
                }
              }
            } else /* CONFIG_NO_UNALIGNED_LOADS */
              if ((peep & (P_PRE|P_POST|P_BASEALIGNED)) == P_BASEALIGNED) {
                if ((m & 3L) == (target_lsbytefirst ? 3L : 0L)) {
                  in_ms_byte = YES;
                  m &= ~3L;
                }
              }
          }
          bigdisp(&dispdesc, m, 0xfff, r2r);
          w = dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
          if (peep & (P_PRE|P_POST)) adjustipvalue(r2r, r2r, w & F_UP ? m : -m);
          outinstr(prepost(op) | F_LDR | w | (in_ms_byte ? F_WORD : F_BYTE) |
                                 F_RD(r1r) | F_RN(r2r) | m);
          if (op & J_SIGNED) {
            if (!in_ms_byte)
              outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSL(24));
            if (!(peep & P_MS))
              outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_ASR(24));
          }
        }
        peep &= ~(P_BASEALIGNED | P_MS);
        illbits &= ~(J_SIGNED|J_UNSIGNED);
        break;
case J_LDRBR:
        ldm_flush();
        w = (op & J_NEGINDEX) ? F_DOWN | F_BYTE : F_UP | F_BYTE;
        if (peep & (P_PRE | P_POST)) killipvalue(r2r);
        outinstr(prepostr(op) | F_LDR | w | F_RD(r1r) | F_RN(r2r) | mr | msh);
        if (op & J_SIGNED) {
          outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSL(24));
          if (!(peep & P_MS))
            outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_ASR(24));
        }
        peep &= ~(P_MS|P_RSHIFT);
        illbits &= ~(J_SIGNED|J_UNSIGNED|J_NEGINDEX|J_SHIFTMASK);
        break;
case J_LDRWK:
        ldm_flush();
        illbits &= ~(J_SIGNED|J_UNSIGNED);
/* note that LDRWK with neither J_UNSIGNED nor J_SIGNED would be valid and */
/* leave junk in top 16 bits                                               */
        { bool in_ms_half = !target_lsbytefirst;
          if (config & CONFIG_NO_UNALIGNED_LOADS) {
            bool twobytes = YES;
            if (peep & P_BASEALIGNED) {
              /* base register of known alignment: we may be able to use
                 normal access code
               */
              if (peep & P_POST)
                twobytes = NO;
              else if (peep & P_PRE)
                twobytes = (m & 2L) != 0;
              else {
                if (m & 2L) in_ms_half = !in_ms_half;
                m &= ~2L;
                twobytes = NO;
              }
            }
            if (twobytes) {
              int32 ip = frameregs[R_IP];
              int32 lsbyte, msbyte;
              int32 p = peep; /* prepost() removes P_PRE, P_POST from peep */
              bigdisp(&dispdesc, m, 0xfff, r2r);
              w = dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
              if (peep & (P_PRE | P_POST))
                adjustipvalue(r2r, r2r, w & F_UP ? m : -m);
              outinstr(prepost(op) | F_LDR | w | F_BYTE | F_RD(ip) |
                                                          F_RN(r2r) | m);
              if (p & P_PRE)
                m = 1 | F_UP;
              else if ((p & P_POST) && m != 0) {
                if (w & F_UP)
                  m = (m-1) | F_DOWN;
                else
                  m = (m+1) | F_UP;
              } else if (w == F_UP)
                m = (m + 1) | w;
              else
                m = (m - 1) | w;
              outinstr(OP_PREN | F_LDR | F_BYTE | F_RD(r1r) | F_RN(r2r) | m);
              if (target_lsbytefirst)
                lsbyte = ip, msbyte = r1r;
              else
                lsbyte = r1r, msbyte = ip;
              if (peep & P_MS) {
                outinstr(OP_RXR | F_MOV | F_RD(msbyte) | msbyte | K_LSL(24));
                outinstr(OP_RXR | F_ORR | F_RD(r1r) | F_RN(msbyte) |
                                          lsbyte | K_LSL(16));
              } else if (op & J_SIGNED) {
                outinstr(OP_RXR | F_MOV | F_RD(msbyte) | msbyte | K_LSL(24));
                outinstr(OP_RXR | F_ORR | F_RD(r1r) | F_RN(lsbyte) |
                                          msbyte | K_ASR(16));
              } else
                outinstr(OP_RXR | F_ORR | F_RD(r1r) | F_RN(lsbyte) |
                                          msbyte | K_LSL(8));
              peep &= ~(P_BASEALIGNED | P_MS);
              break;
            }
          } else if (target_lsbytefirst &&
                     (peep & (P_PRE|P_POST|P_BASEALIGNED)) == P_BASEALIGNED &&
                     (op & (J_SIGNED | J_UNSIGNED))) {
            /* on a little-endian ARM, we can save one shift in zero or sign
               extension by addressing the halfword we don't want (provided we
               know that the base is word-aligned).
             */
            m ^= 2;
            in_ms_half = YES;
          }
          bigdisp(&dispdesc, m, 0xfff, r2r);
          w = dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
          if (peep & (P_PRE | P_POST))
            adjustipvalue(r2r, r2r, w & F_UP ? m : -m);
/* the following line uses that non-aligned 32 bits loads go via the       */
/* ARM barrel shifter.  Hence all is OK for aligned 16 bit loads!          */
          outinstr(prepost(op) | F_LDR | w | F_WORD | F_RD(r1r) | F_RN(r2r) | m);
          if (in_ms_half || (op & (J_SIGNED | J_UNSIGNED)) || (peep & P_MS)) {
            if (!in_ms_half)
              outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSL(16));
            if (!(peep & P_MS)) {
              if (op & J_SIGNED)
                outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_ASR(16));
              else
                outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSR(16));
            }
          }
          peep &= ~(P_BASEALIGNED | P_MS);
          break;
        }
case J_LDRWR:
        ldm_flush();
        if (peep & (P_PRE | P_POST)) killipvalue(r2r);
        if (config & CONFIG_NO_UNALIGNED_LOADS) {
          int32 ip = frameregs[R_IP];
          int32 lsbyte, msbyte;
          if (peep & P_PRE) {
            peep &= ~P_PRE;
            w = (op & J_NEGINDEX) ? F_DOWN : F_UP;
            outinstr(OP_PRER | F_LDR | w | F_BYTE | F_WRITEBACK | F_RD(r1r) | F_RN(r2r) | mr | msh);
            outinstr(OP_PREN | F_LDR | F_UP | F_BYTE | F_RD(ip) | F_RN(r2r) | 1);
          } else {
            if (op & J_NEGINDEX)
              outinstr(OP_RXR | F_SUB | F_RD(ip) | F_RN(r2r) | mr | msh);
            else
              outinstr(OP_RXR | F_ADD | F_RD(ip) | F_RN(r2r) | mr | msh);
            outinstr(OP_PREN | F_LDR | F_UP | F_BYTE | F_RD(r1r) | F_RN(ip) | 0);
            outinstr(OP_PREN | F_LDR | F_UP | F_BYTE | F_RD(ip) | F_RN(ip) | 1);
          }
          if (target_lsbytefirst)
            lsbyte = r1r, msbyte = ip;
          else
            lsbyte = ip, msbyte = r1r;
          if (op & J_SIGNED) {
            outinstr(OP_RXR | F_MOV | F_RD(msbyte) | msbyte | K_LSL(24));
            outinstr(OP_RXR | F_ORR | F_RD(r1r) | F_RN(lsbyte) |
                                      msbyte | K_ASR(16));
          } else
            outinstr(OP_RXR | F_ORR | F_RD(r1r) | F_RN(lsbyte) |
                                      msbyte | K_LSL(8));
        } else {
          w = (op & J_NEGINDEX) ? F_DOWN : F_UP;
          outinstr(prepostr(op) | F_LDR | F_WORD | w | F_RD(r1r) | F_RN(r2r) |
                   mr | msh);
          if (!target_lsbytefirst || (op & (J_SIGNED | J_UNSIGNED)) || (peep & P_MS)) {
            if (target_lsbytefirst)
              outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSL(16));
            if (!(peep & P_MS)) {
              if (op & J_SIGNED)
                outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_ASR(16));
              else
                outinstr(OP_RXR | F_MOV | F_RD(r1r) | r1r | K_LSR(16));
            }
            peep &= ~P_MS;
          }
        }
        peep &= P_RSHIFT;
        illbits &= ~(J_SIGNED|J_UNSIGNED|J_NEGINDEX|J_SHIFTMASK);
        break;
case J_LDRK:
case J_STRK:
        w = loads_r1(op) ? F_LDR : F_STR;
        bigdisp(&dispdesc, m, 0xfff, r2r);
        w |= dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
        if (peep & (P_PRE | P_POST)) adjustipvalue(r2r, r2r, w & F_UP ? m : -m);
        ldm_outinstr((prepost(op) | w | F_WORD | F_RD(r1r) | F_RN(r2r) | m),
                     dataflow & J_DEAD_R2);
        break;
case J_LDRR:
case J_STRR:
        ldm_flush();
        w = loads_r1(op) ? F_LDR : F_STR;
        w |= (op & J_NEGINDEX) ? F_DOWN : F_UP;
        if (peep & (P_PRE | P_POST)) killipvalue(r2r);
        outinstr(prepostr(op) | w | F_WORD | F_RD(r1r) | F_RN(r2r) | mr | msh);
        peep &= P_RSHIFT;
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        break;
case J_STRBK:
        ldm_flush();
        bigdisp(&dispdesc, m, 0xfff, r2r);
        w = dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
        if (peep & (P_PRE | P_POST)) adjustipvalue(r2r, r2r, w & F_UP ? m : -m);
        outinstr(prepost(op) | F_STR | F_BYTE | w | F_RD(r1r) | F_RN(r2r) | m);
        break;
case J_STRBR:
        ldm_flush();
        w = (op & J_NEGINDEX) ? F_DOWN : F_UP;
        if (peep & (P_PRE | P_POST)) killipvalue(r2r);
        outinstr(prepostr(op) | F_STR | F_BYTE | w | F_RD(r1r) | F_RN(r2r) |
                 mr | msh);
        peep &= P_RSHIFT;
        illbits &= ~(J_NEGINDEX|J_SHIFTMASK);
        break;
/* J_STRW is done by cg.c for the ARM */

case J_ENDPROC:
        ldm_flush();
        if (!lab_isset_(returnlab) && returnlab->u.frefs != NULL)
            /* at least one pending ref */
            conditional_branch_to(Q_AL, RETLAB, NO);
        dumplits2(NO); /* to ensure that all literals for a proc get put out */
        dump_count_names();
/* Fill in argument binders with offsets which can be used to access the
 * arguments in a containing procedure from a base of 'local 0'.  The need
 * to do something like this is target-independent, but what exactly needs
 * doing is of course strongly target-dependent.
 */
        {   BindList *b;
            /* /* work to be done here for NOFP */
            for (b = argument_bindlist; b != NULL; b = b->bindlistcdr) {
                Binder *v = b->bindlistcar;
                int32 p = bindaddr_(v) & ~BINDADDR_MASK;
                if (p >= 4*argwordsbelowfp)
                    p += 4 * bitcount(regmask & M_VARREGS) + 16;
                p += 12*bitcount(regmask & M_FVARREGS);
                bindaddr_(v) = (bindaddr_(v) & BINDADDR_MASK) | p;
            }
        }
        break;
case J_ENTER:
        routine_entry(m);
        break;

/* J_PUSHR should never reach armgen (removed in flowgraf) */
case J_PUSHM:
        ldm_flush();
        {   int32 sp = frameregs[R_SP];
            int32 count = 4 * bitcount(m);
            if (count == 4)
                outinstr(OP_PREN | F_STR | F_WORD | F_WRITEBACK | F_DOWN | F_RD(LowestRegister(m)) | F_RN(sp) | 4);
            else
                outinstr(OP_STMFD | F_WRITEBACK | F_RN(sp) | m);
            adjustipvalue(sp, sp, -count);
        }
        break;
case J_POPMB:  /* version of POP with a specified base */
        ldm_flush();
        {   int32 ldmop = OP_LDMDB;
            int32 count = 4 * bitcount(m);
            if (peep & P_PRE) {
                add_integer(r2r, r2r, r1-count, 0);
                r1 = count;
                peep &= ~P_PRE;
            }
            if (r1 != 0) {
                if (count == r1)
                    ldmop = OP_LDMIA;
                else {
                    int32 r = physical_register(power_of_two(m & (-m)));
                    add_integer(r, r2r, r1, 0);
                    r2r = r;
                }
            }
            outinstr(ldmop | F_RN(r2r) | m);
        }
        break;
case J_USE:
case J_VSTORE:
        ldm_flush();
case J_USEF:
case J_USED:
        break;

case J_INLINE1:
        syserr(syserr_inline1);
        break;

case J_CLRC:
case J_MOVC:
case J_PUSHC:
        ldm_flush();
        {   RealRegister ip = frameregs[R_IP];
            int32 regs = regbit(R_A4) | regbit(ip) | r4;
            unsigned rcount = 4 * (unsigned)bitcount(regs);
            unsigned count = (unsigned)m;
            bool useloop = count > MOVC_LOOP_THRESHOLD;
            /* That is, we are prepared to compile 3 load+store pairs.  This
               number is also used in regalloc (for number of registers
               believed corrupted) and flowgraf (for conditionalisability).
               Later, we may revise our ideas about whether a loop is
               indicated.
             */

            int32 ldm, stm;
            bool ismove = (op != J_CLRC);

            if (op == J_PUSHC)
                ldm = OP_LDMDB | F_WRITEBACK, stm = OP_STMDB | F_WRITEBACK;
            else if (peep & P_POST)
                ldm = OP_LDMIA | F_WRITEBACK, stm = OP_STMIA;
            else
                ldm = OP_LDMIA, stm = OP_STMIA;

            if (r1r != R_A2 && !(regs & regbit(R_A2)) && !(ismove && r2r == R_A2) &&
                rcount < 4*ldm_regs_max &&
                ((peep & P_A2FREE) || useloop || (spareregs & regbit(R_A2)))) {
                rcount += 4, regs |= regbit(R_A2);
                augment_RealRegSet(&regmaskvec, R_A2);
            }
            if (r1r != R_A3 && !(regs & regbit(R_A3)) && !(ismove && r2r == R_A3) &&
                rcount < 4*ldm_regs_max &&
                ((peep & P_A3FREE) || useloop || (spareregs & regbit(R_A3)))) {
                rcount += 4, regs |= regbit(R_A3);
                augment_RealRegSet(&regmaskvec, R_A3);
            }
            if (r1r != R_LR && !(regs & regbit(R_LR)) && !(ismove && r2r == R_LR) &&
                !(feature & FEATURE_DONTUSE_LINKREG) &&
                rcount < 4*ldm_regs_max &&
                ((peep & P_LRFREE) || (spareregs & M_LR))) {
                rcount += 4, regs |= M_LR;
                augment_RealRegSet(&regmaskvec, R_LR);
            }
            if (useloop) {
                if ( (ismove && count <= 3*rcount) ||
                     (count <= 4*rcount))
                    useloop = NO;
                else
                 /* We really do want to compile a loop - we will need
                    a register for the count.
                  */
                    rcount -= 4, regs &= ~regbit(ip);
            }
            if (!ismove) {
                int32 i = R_A1;
                for (; i <= R_LR; i++)
                    if (regs & regbit(i))
                        load_integer(i, 0, 0);
            }

            if (!useloop)
                for (; count > rcount; count -= rcount) {
                    if (ismove && count == rcount+4 && rcount < 4*ldm_regs_max &&
                        (dataflow & J_DEAD_R2) && !(peep & P_POST)) {
                        rcount += 4; regs |= regbit(r2r);
                        ldm &= ~F_WRITEBACK;
                        break;
                    }
                    if (ismove)
                        outinstr(ldm | F_WRITEBACK | F_RN(r2r) | regs);
                    outinstr(stm | F_WRITEBACK | F_RN(r1r) | regs);
                    regmask |= regs;
                }
            else {
                LabelNumber *lab = nextlabel();
                unsigned n = count / rcount;
                count = count % rcount;
                load_integer(ip, n, 0);
                setlabel(lab);
                if (ismove)
                    outinstr(ldm | F_WRITEBACK | F_RN(r2r) | regs);
                outinstr(stm | F_WRITEBACK | F_RN(r1r) | regs);
                regmask |= regs;
                add_integer(ip, ip, -1, F_SCC);
                conditional_branch_to(Q_NE, lab, NO);
            }
            if (count > 0) {
                unsigned i = rcount-count;
                for (; i != 0; i -= 4)
                    regs ^= (regs & -regs);
                if (ismove)
                    outinstr(ldm | F_RN(r2r) | regs);
                outinstr(stm | F_RN(r1r) | regs);
                regmask |= regs;
            }
        }
        ipvalue.valid = NO;
        peep &= ~(P_A2FREE | P_A3FREE | P_LRFREE | P_POST);
        break;

case J_CMPFK:
case J_CMPDK:
case J_CMPFR:
case J_CMPDR:
        ldm_c_flush(regsused, 1);
        show_fp_inst_direct(op, m, peep, r1r, r2r, mr);
        return;
#ifdef RANGECHECK_SUPPORTED
case J_CHKNEFR:
case J_CHKNEDR:
        ldm_flush();
        show_fp_inst_direct(op, m, peep, r1r, r2r, mr);
        return;
#endif
default:
        ldm_c_flush(regsused, 0);
        show_fp_inst_direct(op, m, peep, r1r, r2r, mr);
        return;
    }
    if (a_loads_r1(op) && !dont_kill_ip) killipvalue(r1r);
    if (illbits | peep) syserr(syserr_jop_mode, (long)op, (long)peep);
}

#define NFPLITERALS 16

typedef struct {
    FloatCon *val;
    int32 immop;
} FPLiteral;

static FPLiteral fpliterals[NFPLITERALS] = {
    {NULL, 0 | F_CONSTOP}, {NULL, 1 | F_CONSTOP}, {NULL, 2 | F_CONSTOP}, {NULL, 3 | F_CONSTOP},
    {NULL, 4 | F_CONSTOP}, {NULL, 5 | F_CONSTOP}, {NULL, 6 | F_CONSTOP}, {NULL, 7 | F_CONSTOP},
    {NULL, 0 | F_CONSTOP}, {NULL, 1 | F_CONSTOP}, {NULL, 2 | F_CONSTOP}, {NULL, 3 | F_CONSTOP},
    {NULL, 4 | F_CONSTOP}, {NULL, 5 | F_CONSTOP}, {NULL, 6 | F_CONSTOP}, {NULL, 7 | F_CONSTOP}
};

static int32 posfpliteral(FloatCon *val)
{
    int i;
    for ( i = 0 ; i != NFPLITERALS ; i++ )
        if (fpliterals[i].val->floatlen == (val->floatlen & TYPEDEFINHIBITORS) &&
            fpliterals[i].val->floatbin.irep[0] == val->floatbin.irep[0] &&
            ( (val->floatlen & bitoftype_(s_short)) ||
              fpliterals[i].val->floatbin.irep[1] == val->floatbin.irep[1]))
           return fpliterals[i].immop;
    return 0;
}

static int32 xposfpliteral(FloatCon *val)
{
    int32 l = posfpliteral(val);
    if (l == 0) syserr(syserr_fp_const, val->floatbin.irep[0]);
    return l;
}

static int32 negfpliteral(FloatCon *val)
{
    int i;
    for ( i = 0 ; i != NFPLITERALS ; i++ )
        if (fpliterals[i].val->floatlen == (val->floatlen & TYPEDEFINHIBITORS) &&
            (fpliterals[i].val->floatbin.irep[0] ^ 0x80000000) == val->floatbin.irep[0] &&
            ( (val->floatlen & bitoftype_(s_short)) ||
              fpliterals[i].val->floatbin.irep[1] == val->floatbin.irep[1]))
           return fpliterals[i].immop;
    return 0;
}

bool fpliteral(FloatCon *val, J_OPCODE op)
{
    int32 n = posfpliteral(val);
    if ( n != 0 &&
          /* disgusting bodge to ensure we can't fall foul of FPE bug -
             MULxK x, x, #0.0 non-functional
             This case should never arise, anyhow
           */
         !(n == F_CONSTOP && (op == J_MULFK || op == J_MULDK)))
        return YES;
    /* -ve cases also valid for ADDxK/SUBxK */
    if ((op == J_ADDFK || op == J_SUBFK ||
         op == J_ADDDK || op == J_SUBDK) && negfpliteral(val)) return YES;
    return NO;
}

static int32 checkfreg(RealRegister r)
{
    if (r < R_F0) /* already checked to be <= R_F7 */
        syserr(syserr_gen_freg, (long)r);
    return r & 0xf;
}

static void show_fp_inst_direct(J_OPCODE op, int32 m, int32 peep,
                                RealRegister r1r, RealRegister r2r,
                                RealRegister mr)
{   struct DispDesc dispdesc;
    int32 w, illbits;
    illbits = op & (Q_MASK | J_SIGNED | J_UNSIGNED | J_NEGINDEX | J_SHIFTMASK);
    switch (op & ~(Q_MASK | J_SIGNED | J_UNSIGNED | J_NEGINDEX | J_SHIFTMASK))
    {
/* Now the floating point part of the instruction set */
/* This is a version for FPE2 */
#define cpprepost(op) \
    ((peep & P_POST) ? (peep &= ~P_POST, OP_CPPOST | F_WRITEBACK) : \
     (peep & P_PRE) ? (peep &= ~P_PRE, OP_CPPRE | F_WRITEBACK) : OP_CPPRE)
#define fpround(op) \
    ((peep & P_RNDF) ? (peep &= ~P_RNDF, CPDO_SINGLE) : CPDO_FLTOFJ(op))
#define fpround_a(op) \
    ((peep & P_RNDF) ? (peep &= ~P_RNDF, CPDO_SINGLE) : CPDO_FLTOFJ_A(op))
case J_PUSHD:
        {   int32 sp = frameregs[R_SP];
            ldm_flush();
            outinstr(OP_CPPRE | F_DOWN | F_WRITEBACK | F_STR |
                            F_RN(sp) | F_RD(checkfreg(r1r)) | F_DOUBLE | 2);
            adjustipvalue(sp, sp, -8);
        }
        break;
case J_PUSHF:
        {   int32 sp = frameregs[R_SP];
            ldm_flush();
            outinstr(OP_CPPRE | F_DOWN | F_WRITEBACK | F_STR |
                            F_RN(sp) | F_RD(checkfreg(r1r)) | F_SINGLE | 1);
            adjustipvalue(sp, sp, -4);
        }
        break;
case J_MOVFK:
case J_MOVDK:       /* load single & double literals the same way        */
        {   int32 imm = posfpliteral((FloatCon *) m);
            if (imm != 0) {
                outinstr(OP_CPOP | F_MVF | fpround(op) |
                         F_RD(checkfreg(r1r)) | imm);
                break;
            }
            if ((imm = negfpliteral((FloatCon *) m)) != 0) {
                outinstr(OP_CPOP | F_MNF | fpround(op) |
                         F_RD(checkfreg(r1r)) | imm);
                break;
            }
        }
        /* Otherwise, drop through to create a FP literal */
case J_ADCONF:
case J_ADCOND:
        ldm_flush();
/* I do so hope very much that these instructions are used in a          */
/* compatible way wrt floating point operands.                           */
        {   FloatCon *fc = (FloatCon *)m;
            int size = (op==J_MOVDK || op==J_ADCOND) ? 2 : 1;
            int32 direction = F_UP, adconop = F_ADD;
            int32 disp = lit_findwordsincurpool(fc->floatbin.irep, size, LIT_FPNUM);
            if (disp < 0) {
                disp = lit_findwordsinprevpools(fc->floatbin.irep, size, LIT_FPNUM,
                          codebase+codep+8-1020);
                if (disp >= 0) {
                    disp = codebase+codep+8-disp;
                    direction = F_DOWN, adconop = F_SUB;
                } else {
                    addressability(256);
                    if (size == 1)
                        disp = lit_findwordaux(fc->floatbin.fb.val,
                                  LIT_FPNUM, fc->floatstr,
                                  LITF_INCODE|LITF_FIRST|LITF_LAST);
                    else {
                        (void)lit_findwordaux(fc->floatbin.db.msd,
                                  LIT_FPNUM1, fc->floatstr,
                                  LITF_INCODE|LITF_FIRST);
                        /* use the second address in case overflow */
                        disp = lit_findwordaux(fc->floatbin.db.lsd,
                                  LIT_FPNUM2, fc->floatstr,
                                  LITF_INCODE|LITF_LAST) - 4;
                    }
                }
            }
            disp >>= 2;
            if (direction == F_UP)
                addfref_(litlab, codep | LABREF_W256);
            if (op == J_ADCONF || op==J_ADCOND)
                 outinstr(OP_RXN | adconop | F_RD(r1r) |
                          F_RN(R_PC) | disp | 0xf00);
            else outinstr(OP_CPPRE | F_LDR | CPDT_FLTOFJ(op) | direction |
                          F_RD(checkfreg(r1r)) | F_RN(R_PC) | disp);
            break;
        }
case J_CMPFR:
case J_CMPDR:
/* Note that in FPE2 it is not necessary to specify the width of         */
/* numbers to be compared.                                               */
        {   int32 test = op & Q_MASK;
            outinstr(OP_CPOP | ((test==C_EQ || test==C_NE) ? F_CMF : F_CMFE) |
                     F_REGOP | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        }
        illbits &= ~Q_MASK;
        break;
case J_MOVFDR:   /* With FPE2 conversion to double is a noop */
        /* drop through */
case J_MOVFR:
case J_MOVDR:
        if (r1r==mr) syserr(syserr_remove_fp_noop);
        outinstr(OP_CPOP | F_MVF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | (checkfreg(mr)));
        break;
case J_NEGFR:
case J_NEGDR:
        outinstr(OP_CPOP | F_MNF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | (checkfreg(mr)));
        break;
case J_FIXFR:
case J_FIXDR:    /* C 'fix' is truncate towards zero */
        outinstr(OP_CPOP | F_FIX | CPDO_RNDZ | F_RD(r1r) |
                           (checkfreg(mr)));
        illbits ^= J_SIGNED;   /* only signed version acceptable */
        break;
case J_FLTFR:
case J_FLTDR:
        outinstr(OP_CPOP | F_FLT | fpround(op) | F_RD(mr) | F_RN(checkfreg(r1r)));
        illbits ^= J_SIGNED;   /* only signed version acceptable */
        break;
case J_MOVIFR:
/* Load FP register from an integer one                                  */
        {   int32 sp = frameregs[R_SP];
            outinstr(OP_STMFD | F_WRITEBACK | F_RN(sp) | regbit(mr));
            outinstr(OP_CPPOST | F_UP | F_LDR | F_WRITEBACK  |
                     F_RN(sp) | F_RD(checkfreg(r1r)) | F_SINGLE | 1);
        }
        break;
case J_MOVDIR:
/* Load integer register pair from fp register                           */
        {   int32 sp = frameregs[R_SP];
            ldm_flush();
            if (r2r <= r1r) syserr(syserr_bad_regpair);
            outinstr(OP_CPPRE | F_DOWN | F_STR | F_WRITEBACK |
                     F_RN(sp) | F_RD(checkfreg(mr)) | F_DOUBLE | 2);
            outinstr(OP_LDMFD | F_WRITEBACK | F_RN(sp) |
                     regbit(r1r) | regbit(r2r));
        }
        break;
case J_MOVIDM:
/* Load n FP registers from 2n integer registers. m holds a bitmap of    */
/* integer registers, r1 a bitmap of the fp registers.                   */
        {   int32 sp = frameregs[R_SP];
            int32 r;
            ldm_flush();
            outinstr(OP_STMFD | F_WRITEBACK | F_RN(sp) | m);
            for (r = R_F0; r1r != 0; r++)
                if (r1r & regbit(r)) {
                    outinstr(OP_CPPOST | F_UP | F_LDR | F_WRITEBACK |
                             F_RN(sp) | F_RD(checkfreg(r)) | F_DOUBLE | 2);
                    r1r ^= regbit(r);
                }
        }
        break;
case J_MOVDIM:
/* Load 2n integer registers from n FP registers. m holds a bitmap of    */
/* fp registers, r1 a bitmap of the integer registers. There may be more */
/* than 2n registers in the r1 map because unconnected individual        */
/* pops (of an object split between registers and stack) may have been   */
/* added.                                                                */
        {   int32 sp = frameregs[R_SP];
            int32 r;
            int32 netpush = 2 * bitcount(m) - bitcount(r1r);
            ldm_flush();
            for (r = R_F0+NFLTREGS-1; m != 0; r--)
                if (m & regbit(r)) {
                    outinstr(OP_CPPRE | F_DOWN | F_STR | F_WRITEBACK |
                             F_RN(sp) | F_RD(checkfreg(r)) | F_DOUBLE | 2);
                    m ^= regbit(r);
                }
            outinstr(OP_LDMFD | F_WRITEBACK | F_RN(sp) | r1r);
            adjustipvalue(sp, sp, -netpush);
        }
        break;
case J_MOVIDR:
/* Load FP register from 2 integer registers.  Only happens just after   */
/* function entry, with the integer registers being argument rgisters.   */
/* If arguments have been pushed on the stack, we can load the fp value  */
/* directly.  (It would be nice to ensure that if anything had been      */
/* pushed on entry, the argument registers of the MOVIDR had).           */
        {   int32 sp = frameregs[R_SP];
            ldm_flush();
            if (mr <= r2r) syserr(syserr_bad_regpair);
            if (!(procflags & PROC_ARGPUSH)) {
                outinstr(OP_STMFD | F_WRITEBACK | F_RN(sp) |
                         regbit(mr) | regbit(r2r));
                outinstr(OP_CPPOST | F_UP | F_LDR | F_WRITEBACK |
                         F_RN(sp) | F_RD(checkfreg(r1r)) | F_DOUBLE | 2);
                break;
            }
            {   int32 addr = BINDADDR_ARG + r2r*4;
                op = J_LDRDK;
                m = local_addr_a(addr); r2r = physical_register(local_base_a(addr));
                /* and fall through to handle the load */
            }
        }
case J_LDRFK:
case J_LDRDK:
case J_STRFK:
case J_STRDK:
        ldm_flush();
        w = loads_r1(op) ? F_LDR : F_STR;
        bigdisp(&dispdesc, m, 0x3fc, r2r);
        w |= dispdesc.u_d, m = dispdesc.m, r2r = dispdesc.r;
        outinstr(cpprepost(op) | w | CPDT_FLTOFJ(op) | F_RD(checkfreg(r1r)) |
                                                    F_RN(r2r) | (m>>2));
        break;
case J_MOVDFR:  /* Round from double to single precision */
                /* I guess I hope this gives exponent overflow if necessary */
        outinstr(OP_CPOP | F_MVF | F_REGOP | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | (checkfreg(mr)));
        break;

case J_ADDFR:
case J_ADDDR:
        outinstr(OP_CPOP | F_ADF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;
case J_SUBFR:
case J_SUBDR:
        outinstr(OP_CPOP | F_SUF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;
case J_MULFR:
        outinstr(OP_CPOP | F_FML | F_REGOP | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;
case J_MULDR:
        outinstr(OP_CPOP | F_MUF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;
case J_DIVFR:
        outinstr(OP_CPOP | F_FDV | F_REGOP | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;
case J_DIVDR:
        outinstr(OP_CPOP | F_DVF | F_REGOP | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        break;

case J_ADDFK:
case J_ADDDK:
    {   FloatCon *f = (FloatCon *) m;
        int32 imm = posfpliteral(f);
        if (imm)
            outinstr(OP_CPOP | F_ADF | fpround(op) |
                     F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | imm);
        else {
            imm = negfpliteral(f);
            if (imm == NULL) syserr(syserr_fp_const, f->floatbin.irep[0]);
            outinstr(OP_CPOP | F_SUF | fpround(op) |
                     F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | imm);
        }
        break;
    }
case J_SUBFK:
case J_SUBDK:
    {   FloatCon *f = (FloatCon *) m;
        int32 imm = posfpliteral(f);
        if (imm)
            outinstr(OP_CPOP | F_SUF | fpround(op) |
                     F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | imm);
        else {
            imm = negfpliteral(f);
            if (imm == NULL) syserr(syserr_fp_const, f->floatbin.irep[0]);
            outinstr(OP_CPOP | F_ADF | fpround(op) |
                     F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) | imm);
        }
        break;
    }
case J_RSBFK:
case J_RSBDK:
        outinstr(OP_CPOP | F_RSF | fpround_a(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_MULFK:
        outinstr(OP_CPOP | F_FML | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_MULDK:
        outinstr(OP_CPOP | F_MUF | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_DIVFK:
        outinstr(OP_CPOP | F_FDV | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_DIVDK:
        outinstr(OP_CPOP | F_DVF | fpround(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_RDVFK:
        outinstr(OP_CPOP | F_FRD | CPDO_SINGLE |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_RDVDK:
        outinstr(OP_CPOP | F_RDF | fpround_a(op) |
                 F_RD(checkfreg(r1r)) | F_RN(checkfreg(r2r)) |
                 xposfpliteral((FloatCon *) m));
        break;
case J_CMPFK:
case J_CMPDK:
        {   int32 test = op & Q_MASK;
            outinstr(OP_CPOP | ((test==C_EQ || test==C_NE) ? F_CMF : F_CMFE) |
                     F_RN(checkfreg(r2r)) | xposfpliteral((FloatCon *) m)); }
        illbits &= ~Q_MASK;
        break;

case J_INLINE1F:
case J_INLINE1D:
        if (peep & P_RNDF)
        {    peep &= ~P_RNDF; m = (m &~ CPDO_DOUBLE) | CPDO_SINGLE; }
        outinstr(m | F_RD(checkfreg(r1r)) | (checkfreg(r2r)));
        break;

#ifdef RANGECHECK_SUPPORTED
case J_CHKNEFR:
case J_CHKNEDR:
        outinstr(OP_CPOP | F_CMF | F_REGOP | F_RN(checkfreg(r2r)) | (checkfreg(mr)));
        outinstr3(OP_BL ^ Q_EQ, sim.valfault, 0);
        break;
#endif

default:
        syserr(syserr_show_inst_dir, (long)op);
        illbits = 0;
        break;
    }
    if (illbits | peep) syserr(syserr_jop_mode, (long)op, (long)peep);
}

int32 power_of_two(int32 n)
{
/* If n is an exact power of two this returns the power, else -1         */
    int32 s = 0, w;
    if (n != (n&(-n))) return(-1);
    for(w=1; w!=0; w = w<<1)
        if (w==n) return(s);
        else s++;
    return(-1);
}

#define ROR(x, n) (((x)<<(32-(n))) | (((x)>>(n)) & ((1L<<(32-(n)))-1L)))

int32 eightbits(int32 n)
{
/* If n fits in an ARM immediate field this function returns a 12-bit    */
/* quantity suitable for use there. Otherwise it returns -1              */
    int32 shift;
    for (shift = 0; shift<0x1000; shift += 0x100)
    {   if ((n&0xffffff00)==0) return(shift|n);
        n = ROR(n, 30);
    }
    return(-1);
}

bool immed_cmp(int32 n)
{
/* False if neither CMP nor CMN can handle this integer                  */
/* Utterly ARM specific                                                  */
    if (eightbits(n)>=0) return YES;
    if (eightbits(-n)>=0) return YES;
    return NO;
}

/* although the idea of setlabel is machine independent, it stays here
   because it back-patches code.  In the long term setlabel should be
   in codebuf.c and call a machine dependent backpatch routine.
*/
void setlabel(LabelNumber *l)
{
    List *p = l->u.frefs;
    for (; p!=NULL; p = (List*) discard2(p))
    {   int32 v = car_(p);
        int32 q = (v & 0x00ffffff);   /* BYTE address */
        int32 w = code_inst_(q);
        unsigned32 d;
        switch (v & 0xff000000)
        {
    case LABREF_BRANCH:   /* Bxx instruction */
/* note the assumption that the address field contained zero */
            d = (codep-q-8 >> 2) & 0x00ffffffL;
            w = (w & 0xff000000) | d;
            break;
    case LABREF_B4096:    /* LDR r1, [pc, #nn] forward ref */
            d = (codep-q-8) + (w & 0xfff);
            if (d >= 0x1000) syserr(syserr_displacement, (long)d);
            w = (w & 0xfffff000) | d;
            break;
    case LABREF_W256:     /* ADD r1, pc, #nn  with nn shifted left 2 bits */
                          /* LDFD f1, [pc, #nn] - again nn is a word offset */
            d = (codep-q-8 >> 2) + (w & 0xff);
            if (d >= 0x100) syserr(syserr_displacement, (long)d);
            w = (w & 0xffffff00) | d;
            break;
    default:
            syserr(syserr_unknown_label, (long)v);
        }
        code_inst_(q) = w;
    }
    lab_setloc_(l, codep | 0x80000000); /* cheapo union checker for ->frefs */
    asm_lablist = (LabList *) syn_cons2((VoidStar) asm_lablist, (VoidStar) l);
}

static void move_register(RealRegister r1, RealRegister r2, int32 scc)
{   /* r1 = r2    */
    if (r1!=r2 || scc!=0) outinstr(OP_RXR | F_MOV | scc | F_RD(r1) | r2);
}

static void negate_register(RealRegister r1, RealRegister r2, int32 scc)
{   /*  r1 = -r2  */
    outinstr(OP_RXN | F_RSB | scc | F_RD(r1) | F_RN(r2));
}

/* This is the ACN second attempt to produce sensible code to load       */
/* integer values into ARM registers.                                    */
/* /* There are too many different ways below to break up an integer into*/
/* 8-bit chunks.  Rationalisation needed.                                */

static int32 *add_integer_i(RealRegister r1, RealRegister r2, int32 n,
                            int32 scc, int32 *v)
{ /* Generate code for r1 = r2 + n.                                      */
    int32 packed;
    if (n==0)
    {
        if (r1!=r2 || scc!=0)
            *v++ = (OP_RXR | F_MOV | scc | F_RD(r1) | r2);
        return v;
    }
    packed = eightbits(n);
    if (packed>=0)
    {   *v++ = (OP_RXN | F_ADD | scc | F_RD(r1) | F_RN(r2) | packed);
        return v;
    }
    packed = eightbits(-n);
    if (packed>=0)
    {   *v++ = (OP_RXN | F_SUB | scc | F_RD(r1) | F_RN(r2) | packed);
        return v;
    }
/*
 * here it will take at least two instructions...
 */
    {   int32 tail = 0x3, mask = 0xff, op;
        int32 sp = frameregs[R_SP];
        while ((n & tail)==0) tail = tail << 2, mask = mask << 2;
        tail <<= 8;
        if (r1 != sp && (n & mask) != mask) {
            int32 bitsabove = (n & tail) == tail ? tail : 0;
            for (; ; tail >>= 2, mask = ROR(mask, 2)) {
                bitsabove >>= 2;
                if ((n & (tail >> 2)) != bitsabove) break;
            }
        }
/*
 * If the destination register is the stack pointer I decide on using
 * an ADD or a SUB based on the sign of n.  The effect should be to ensure
 * that the stack pointer moves in a monotonic way, which is necessary if
 * code is to be secure against assynchronous interrupts.  For other
 * destination registers it will sometimes be possible to generate
 * tighter code by (e.g.) treating a + 0x1fffffff as a - 1 + 0x20000000.
 */
        if ((r1 == sp && n < 0) || (r1 != sp && (n & tail) == tail))
        {   op = OP_RXN | F_SUB;
            mask &= (-n);
            n += mask;
        }
        else
        {   op = OP_RXN | F_ADD;
            mask &= n;
            n -= mask;
        }
        *v++ = (op | F_RD(r1) | F_RN(r2) | eightbits(mask));
        return add_integer_i(r1, r1, n, scc, v);
    }
}

static void add_integer(RealRegister r1, RealRegister r2, int32 n, int32 scc)
{   int32 v[4];
    int32 *ve = add_integer_i(r1, r2, n, scc, v);
    int32 *p;
    for (p = &v[0]; p != ve; p++) outinstr(*p);
}

static void rsb_integer(RealRegister r1, RealRegister r2, int32 n, int32 scc)
{ /* Generate code for r1 = n - r2.                                      */
    int32 packed = eightbits(n);
    if (packed>=0)
        outinstr(OP_RXN | F_RSB | scc | F_RD(r1) | F_RN(r2) | packed);
    else {
        int32 tail = 0x3, mask = 0xff;
        while ((n & tail)==0) tail = tail << 2, mask = mask << 2;
        mask &= n;
        n -= mask;
        outinstr(OP_RXN | F_RSB | F_RD(r1) | F_RN(r2) | eightbits(mask));
        add_integer(r1, r1, n, scc);
    }
}

static int32 *load_integer_i(RealRegister r, int32 n, int32 scc, int32 *v);

static int32 *symmetricload(RealRegister r, int32 n, int32 mask,
                            int shift, int32 scc, int32 *v)
{
    int c;
    for (c = 0 ; c < shift ; mask <<= 2, c += 2) {
        int k;
        for (k = 1-shift ; k < shift ; k++)
            if ((n & mask) == ROR((n & ~mask), shift+k)) {
                v = load_integer_i(r, n & mask, 0, v);
                *v++ = (OP_RXR | F_ADD | scc | F_RD(r) | F_RN(r) |
                        r | K_ROR(32L-shift-k));
                return v;
             }
     }
     return v;
}

static int32 *load_integer_i(RealRegister r, int32 n, int32 scc, int32 *v)
{ /* Set register r to the integer n, setting condition codes on scc     */

    int32 op = OP_RXN|F_MOV, packed = eightbits(n);
    if (packed<0) op = OP_RXN|F_MVN, packed = eightbits(~n);
    if (packed>=0) {
        *v++ = (op | F_RD(r) | scc | packed);
        return v;
    } else {
        int32 pos1 = 0, size1 = 0, value1 = -1;
        int32 pos2 = 0, size2 = 0, value2 = -1;
        int32 startsize = 0, startvalue = -1;
        int32 pos = 0, value = -1, start = -1;
        int32 mask = 3;
        /* find the two longest strings of pairs of 00 or 11 (on an even bit
           boundary), setting sizen to the number of bits, posn to the ls bit,
           valuen to 0 for 00, 1 for 11 (n=1 longest)
         */
        for ( ; pos <= 32; mask = mask<<2, pos += 2) {
            int32 newvalue = mask == 0            ? -1 :
                             ((n & mask) == mask) ? 3 :
                             ((n & mask) == 0)    ? 0 :
                                                    -1;
            if (value != newvalue) {
                if (value != -1) {
                    int32 size = pos - start;
                    if (start == 0) {
                        startsize = size;
                        startvalue = value;
                        /* disregard a string in the ls bits if these are the
                           same as the ms bits (it will be included in the
                           string including the ms bits).
                         */
                        if (((n >> 30) & 3) == value) size = -1;
                    }
                    if (pos == 32 && value == startvalue)
                        size += startsize;
                    if (size >= size1) {
                        pos2 = pos1; size2 = size1; value2 = value1;
                        size1 = size; pos1 = start; value1 = value;
                    } else if (size >= size2) {
                        size2 = size; pos2 = start; value2 = value;
                    }
                }
                value = newvalue;
                start = pos;
            }
        }
        {   int32 remainder, k;
            int32 nextpos = pos1 + size1;
            if (nextpos >= 32) nextpos -= 32;
            if ( value1 == 3 && size1 > 8 &&
                 (value2 == 3 || pos1 == 0)) {
            /* both longest strings are 1s, or the longest is 1s and starts
               at the ls bit.  And in any case, the length of the longest
               string is sensible (eg beware 55aa3355).
               Maybe should also look for a (shorter) sensible length for the
               second string.
               Use MVN to construct the 8-bit chunk above the longest string
               (which will give us 1s in the two longest strings for free)
             */
                op = OP_RXN | F_MVN;
                k = (~n) & ROR(255L, (32-nextpos));
                remainder = n - ~k;
            } else if ((value1 == 3 && size1 > 8) ||
                       (value2 == 3 && size2 > 8)) {
            /* one of the two longest strings is a sensible length and of 1s
               (the other is 0s).  Take the 8-bit chunk above the string of 1s
               incremented by 1 in its last place unless that is bit 0 of n.
               (The idea being that we will generate the string of 1s by
                subtracting something)
             */
                if (value2 == 3) {
                    nextpos = pos2 + size2;
                    if (nextpos >= 32) nextpos -= 32;
                }
                op = OP_RXN | F_MOV;
                if (nextpos != 0)
                    k = (n & ROR(255L, (32 - nextpos))) + (1L << nextpos);
                   /* (k has only 8 bits - (n & ...) cannot be 255<<nextpos
                      or it would have been included in the string of 1s)
                    */
                else {
                    if (startvalue == 0) nextpos += startsize;
                    k = n & ROR(255L, (32 - nextpos));
                }
                remainder = n - k;
            } else {
                /* The longest two strings are of 0s.  Take the 8-bit chunk above
                   the longer.
                 */
                op = OP_RXN | F_MOV;
                k = n & ROR(255L, (32 - nextpos));
                remainder = n - k;
            }
            if (eightbits(remainder) < 0 && eightbits(-remainder) < 0) {
                int32 *v1 = symmetricload(r, n, 0xffff, 16, scc, v);
                if (v1 != v) return v1;
                v1 = symmetricload(r, n, 0xff00ff, 8, scc, v);
                if (v1 != v) return v1;
            }
            *v++ = (op | F_RD(r) | eightbits(k));
            return add_integer_i(r, r, remainder, scc, v);
        }
    }
}

static void load_integer_literal(RealRegister r, int32 n) {
    int32 dirn = F_UP;
    int32 i;
    ldm_flush();
    i = lit_findwordsincurpool(&n, 1, LIT_NUMBER);
    if (i < 0) {
        i = lit_findwordsinprevpools(&n, 1, LIT_NUMBER, codebase+codep+8-4092);
        if (i >= 0) {
            i = codebase+codep+8-i;
            dirn = F_DOWN;
        } else {
            addressability(1024);
            i = lit_findword(n, LIT_NUMBER, 0, LITF_INCODE|LITF_FIRST|LITF_LAST);
        }
    }
    if (dirn == F_UP) addfref_(litlab, codep | LABREF_B4096);
    outinstr(OP_PREN | F_LDR | F_WORD | dirn | F_RD(r) | F_RN(R_PC) | i);
}

static void load_integer(RealRegister r, int32 n, int32 scc)
{   int32 v[5];  /* Pessimism here about the number of instructions add_integer
                    may decide to generate
                  */
    int32 *ve = load_integer_i(r, n, scc, v);
    int max = (scc == 0) ? integer_load_max : integer_load_max+1;
    if (ve-v <= max) {
        int32 *p = v;
        for (; p != ve; p++) outinstr(*p);
    } else {
        load_integer_literal(r, n);
        /* This should never happen, since load_integer gets called with */
        /* scc non-zero only perhaps from multiply_integer by 0, when n  */
        /* is zero, so shouldn't get into this code at all               */
        if (scc != 0)
           /* last three arguments to compare_integer irrelevant for     */
           /* comparison against 0.                                      */
            compare_integer(r, 0, 0, 0, 0);
    }
}

static int clears_lobits(int32 n)
{   int shift;
    for (shift = 0; shift < 32; ++shift) {
        int32 lobits = (1L << shift) - 1L;
        if (n == ~lobits) return shift;
    }
    return 0;
}

static int clears_hibits(int32 n)
{   int shift;
    for (shift = 0; shift < 32; ++shift) {
        int32 hibits = (~0L) << (32-shift);
        if (n == ~hibits) return shift;
    }
    return 0;
}

static void and_integer(RealRegister r1, RealRegister r2, int32 n, int32 peep, int32 dead_r1)
{ /* Generate code for r1 = r2 & n.                                      */
  int shift;
  int32 op = OP_RXN|F_AND, packed = eightbits(n);
  int32 scc = SCC_of_PEEP(peep);
  int32 mask = peep & Q_MASK;
  if (n == -1) {
    move_register(r1, r2, scc);
    return;
  }
  if (packed < 0)
    op = OP_RXN|F_BIC, packed = eightbits(~n);
  else if (dead_r1 && scc)
    op = OP_RXN | F_TST, r1 = 0;
  if (packed >= 0) {
    outinstr(op | scc | F_RD(r1) | F_RN(r2) | packed);
    return;
  }
  if ((shift = clears_hibits(n)) != 0) {
    if (dead_r1) {
      mask &= ~Q_UBIT;
      if (mask == Q_EQ || mask == Q_NE) {
        if (scc)
          outinstr(OP_RXR | F_MOV | scc | F_RD(r1) | r2 | K_LSL(shift));
        return;
      }
    }
    outinstr(OP_RXR | F_MOV | 0   | F_RD(r1) | r2 | K_LSL(shift));
    outinstr(OP_RXR | F_MOV | scc | F_RD(r1) | r1 | K_LSR(shift));
    return;
  }
  if ((shift = clears_lobits(n)) != 0) {
    if (dead_r1) {
      if (scc)
        outinstr(OP_RXR | F_MOV | scc | F_RD(r1) | r2 | K_ASR(shift));
      return;
    }
    outinstr(OP_RXR | F_MOV | 0   | F_RD(r1) | r2 | K_LSR(shift));
    outinstr(OP_RXR | F_MOV | scc | F_RD(r1) | r1 | K_LSL(shift));
    return;
  }
  { int32 tail=0x3, mask = 0xff;
    while ((~n & tail)==0) tail = tail << 2, mask = mask << 2;
    and_integer(r1, r2, n | mask, 0, 0);
    outinstr(OP_RXN | F_BIC | scc | F_RD(r1) | F_RN(r1) | eightbits(~n & mask));
  }
}

static void orr_integer(RealRegister r1, RealRegister r2, int32 n,
                        int32 scc, int32 opc)
{ /* Generate code for r1 = r2 | n.                                      */
    int32 packed = eightbits(n);
    if (n==0)
    {   move_register(r1, r2, scc);
        return;
    }
    if (packed>=0) outinstr(OP_RXN | opc | scc | F_RD(r1) | F_RN(r2) | packed);
    else
    {   int32 tail=0x3, mask = 0xff;
        while ((n & tail)==0) tail = tail << 2, mask = mask << 2;
        orr_integer(r1, r2, n & (~mask), 0, opc);
        outinstr(OP_RXN | opc | scc | F_RD(r1) | F_RN(r1) |
                 eightbits(n & mask));
    }
}

static int32 eightbit_floor(int32 n)
/* n is a positive integer - find a number representable as an ARM       */
/* operand that is less than (or ==) n but as close to it as possible    */
{
    unsigned32 m1 = 0xff000000, m2 = 0xc0000000;
    /* the special case is needed to cover n==0                          */
    if ((n & 0xff)==n) return n;
    while ((n & m2)==0)
    {   m1 = m1 >> 2;
        m2 = m2 >> 2;
    }
    return (n & m1);
}

static int32 eightbit_ceiling(int32 n)
/* n is a positive integer - find a number >= n that is representable    */
/* as an ARM operand.                                                    */
{
    unsigned32 m1 = 0xff000000, m2 = 0xc0000000;
    if ((n & 0xff)==n) return n;
    while ((n & m2)==0)
    {   m1 = m1 >> 2;
        m2 = m2 >> 2;
    }
/* In the next line I increment an 8-bit value by the lowest bit of m1,  */
/* which operation can certainly cause overflow from 0xff to 0x100, but  */
/* 0x100 is representable in 8-bits on ARM so this does not matter. Also */
/* there can be the generation of 0x80000000 as (e.g.) the nearest value */
/* above 0x7fxxxxxx - I will need to be careful about that when I call   */
/* this horrid function.                                                 */
    return (n & m1) + (m1 & (-m1));
}

static int32 *compare_integer_i(RealRegister r, int32 n, RealRegister workreg,
                                int32 mask, int32 when, int32 *v)
{
/* Compare register r with integer n, setting condition codes            */
    int32 op = OP_RXN|F_CMP|F_SCC, packed = eightbits(n);
    if (packed>=0) {
      if (mask == Q_EQ || mask == Q_NE || mask == Q_UNE || mask == Q_UEQ) {
        op = OP_RXN|F_TEQ|F_SCC;
      }
    } else
      op = OP_RXN|F_CMN|F_SCC,
      packed = eightbits(-n);
    if (packed>=0) *v++ = (when | op | F_RN(r) | packed);
    else
    {   int32 m = 0, cond = 0;
/* Note that n!=0 here                                                   */
        if (mask == Q_EQ || mask == Q_NE || mask == Q_UNE || mask == Q_UEQ) {
            m = (n > 0) ? eightbit_floor(n) : -eightbit_floor(-n);
        } else if (condition_mask != C_ALWAYS) {
            /* nothing */
        } else if (mask & Q_UBIT) {
            if (n > 0) m = eightbit_floor(n), cond = C_HS;
            else m = -eightbit_floor(-n), cond = C_LS;
            when |= F_SCC;
        } else {
            if (n > 0) m = eightbit_floor(n), cond = C_GE;
            else m = -eightbit_floor(-n), cond = C_LE;
            when |= F_SCC;
        }
        if (m != 0) {
            v = add_integer_i(workreg, r, -m, when, v);
            v = compare_integer_i(workreg, n-m, workreg, mask, cond, v);
            killipvalue(workreg);
        }
    }
    return v;
}

static void compare_integer(RealRegister r, int32 n, RealRegister workreg,
                            int32 mask, int32 when)
{
    int32 v[5], w[5];
    int32 *ve = compare_integer_i(r, n, workreg, mask, when, v);
    int iv = ve - v;
    int32 *we = load_integer_i(workreg, n, 0, w);
    int iw = we - w + 1;
    if (0 < iv && iv <= integer_load_max+1 && iv <= iw)
        for (iv = 0; &v[iv] != ve; iv++) outinstr(v[iv]);
    else {
        if (iw <= integer_load_max+1) {
            for (iw = 0; &w[iw] != we; iw++) outinstr(w[iw]);
        } else
            load_integer_literal(workreg, n);
        if (mask == Q_EQ || mask == Q_NE || mask == Q_UNE || mask == Q_UEQ)
          outinstr(OP_RXR | F_TEQ | F_SCC | F_RN(r) | workreg);
        else
          outinstr(OP_RXR | F_CMP | F_SCC | F_RN(r) | workreg);
        killipvalue(workreg);
    }
}

typedef struct {
    int32 i[32];
    RealRegister workreg;
    int n;
} InstDesc;

static int32 multiply_1(RealRegister r1, RealRegister r2, int32 n, int32 scc)
{   int32 s;
    if ((s = power_of_two(n)) >= 0)
      return OP_RXR | F_MOV | scc | F_RD(r1) | r2 | K_LSL(s);
    else if ((s = power_of_two(n-1)) >= 0)
      return OP_RXR | F_ADD | scc | F_RD(r1) | F_RN(r2) | r2 | K_LSL(s);
    else if ((s = power_of_two(1-n)) >= 0)
      return OP_RXR | F_SUB | scc | F_RD(r1) | F_RN(r2) | r2 | K_LSL(s);
    else if ((s = power_of_two(n+1)) >= 0)
      return OP_RXR | F_RSB | scc | F_RD(r1) | F_RN(r2) | r2 | K_LSL(s);
    return 0;
}

static bool multiply_2(RealRegister r1, RealRegister r2,
                       int32 n, int32 scc, InstDesc *i) {
    /* is n of the form (2^p +/- 1)(2^q +/- 1) ?
     *             (2^(p+q)+/-2^p+/-2^q+/-1)
     * thus if n is of this form (and p != q), one factor is s+/-1 where s is
     * the bottom bit of n after adding or subtracting 1.
     * if p == q, this is wrong, but we can still do the multiply in two
     * instructions as 2^(2*p)+/-2^(p+1)+/-1 using a work register
     */
    int32 k = (n & 2) == 0 ? n - 1 : n + 1;
    int32 s = k & (-k);
    int32 factor;
    int32 i0;
    if (( (n % (factor = s - 1)) == 0 ||
          (n % (factor = s + 1)) == 0 ) &&
        (i0 = multiply_1(r1, r2, n / factor, 0)) != 0) {
      i->i[i->n] = i0;
      i->i[i->n+1] = multiply_1(r1, r1, factor, scc);
      i->workreg = -1;
      i->n += 2;
      return YES;
    }

    if (i->workreg != -1) {
      RealRegister r3 = i->workreg;
      int32 sh;
        /* is n of the form 2^a +/- 2^b +/- 1 ? */
      if ((sh = power_of_two(k-s)) >= 0) {
        i->i[i->n] = multiply_1(r3, r2, s+n-k,0);
        i->i[i->n+1] = OP_RXR | F_ADD | scc | F_RD(r1) | F_RN(r3) | r2 | K_LSL(sh);
        i->n += 2;
        return YES;
      } else if ((sh = power_of_two(k+s)) >= 0) {
        i->i[i->n] = multiply_1(r3, r2, s-n+k, 0);
        i->i[i->n+1] = OP_RXR | F_RSB | scc | F_RD(r1) | F_RN(r3) | r2 | K_LSL(sh);
        i->n += 2;
        return YES;
      }
    }
    return NO;
}

static bool multiply_3(RealRegister r1, RealRegister r2,
                       int32 n, int32 scc, InstDesc *i) {
    int32 k;
      /* is n of the form (2^p+/-1)*m,
         where m can be multiplied by in two instructions?
       */
    for (k = 0x00010000; k >= 4; k = k >> 1) {
      if ((n % (k-1)) == 0 && multiply_2(r1, r2, n/(k-1), 0, i)) {
        i->i[i->n++] = multiply_1(r1, r1, k-1, scc);
        return YES;
      }
      if ((n % (k+1)) == 0 && multiply_2(r1, r2, n/(k+1), 0, i)) {
        i->i[i->n++] = multiply_1(r1, r1, k+1, scc);
        return YES;
      }
    }
    if (i->workreg != -1) {
      /* is n of the form +/-2^p+/-m,
         where m can be multiplied by in two instructions?
       */
      RealRegister r3 = i->workreg;
      k = (n & 2) == 0 ? n - 1 : n + 1;
      while (k != 0) {
        int32 s = k & (-k);
        if (multiply_2(r3, r2, n-s, 0, i)) {
          s = power_of_two(s);
          i->i[i->n++] = OP_RXR | F_ADD | scc | F_RD(r1) | F_RN(r3) | r2 | K_LSL(s);
          i->workreg = r3;
          return YES;
        } else if (multiply_2(r3, r2, n+s, 0, i)) {
          s = power_of_two(s);
          i->i[i->n++] = OP_RXR | F_SUB | scc | F_RD(r1) | F_RN(r3) | r2 | K_LSL(s);
          i->workreg = r3;
          return YES;
        }
        if (k & (s << 1))
          k += s;
        else
          k -= s;
      }
    }
    return NO;
}

static void multiply_i(RealRegister r1, RealRegister r2, int32 n, int32 scc,
                       InstDesc *i)
{   int32 s, k;
    RealRegister r3 = i->workreg;

    if (codep >= mustlitby) dumplits2(YES);
    if ((s = multiply_1(r1, r2, n, scc)) != 0) {
      i->i[i->n++] = s;
      return;

    } else if ((s = n & (-n)) != 1) {   /* divisible by a power of 2 */
      multiply_i(r1, r2, n/s, 0, i);
      i->i[i->n++] = multiply_1(r1, r1, s, scc);
      return;
    }

    if (multiply_2(r1, r2, n, scc, i) ||
        multiply_3(r1, r2, n, scc, i)) {
      if (i->workreg != -1) killipvalue(i->workreg);
      return;
    }

/* Determine whether our number has a factor of the form 2^s+1 or 2^s-1  */
/* Note that since various cases have already been checked the number n  */
/* is not of any of the forms 2^s+1, 2^s-1, 1-2^s.                       */
    for (k = 0x00010000; k >= 4; k = k >> 1) {
      if ((n % (k-1)) == 0) {
        k = k-1;
        break;
      } else if ((n % (k+1)) == 0) {
        k = k+1;
        break;
      }
    }
    if (k > 2) {
      multiply_i(r1, r2, n/k, 0, i);
      i->i[i->n++] = multiply_1(r1, r1, k, scc);
      return;
    }

    killipvalue(r3);
    if ((n&2) == 0) {
      k = n - 1;
      s = k & (-k);
      multiply_i(r3, r2, k/s, 0, i);
      s = power_of_two(s);
      i->i[i->n++] = OP_RXR | F_ADD | scc | F_RD(r1) | F_RN(r2) | r3 | K_LSL(s);
    } else {
      k = n + 1;
      s = k & (-k);
      multiply_i(r3, r2, k/s, 0, i);
      s = power_of_two(s);
      i->i[i->n++] = OP_RXR | F_RSB | scc | F_RD(r1) | F_RN(r2) | r3 | K_LSL(s);
    }
}

static void multiply_integer(RealRegister r1, RealRegister r2, int32 n,
                             int32 scc)
{ /* Generate code for r1 = r2 * n.  scc can be used to set condn codes. */
    if (n==0)
      load_integer(r1, 0, scc);
    else if (n==1)
      move_register(r1, r2, scc);
    else if (n==-1)
      negate_register(r1, r2, scc);
    else {
      InstDesc insts;
      RealRegister workreg;
      if (r1 != r2)
        workreg = r1;       /* if source != dest, can use dest reg */
      else
        workreg = frameregs[R_IP];   /* otherwise a fixed register */
      insts.n = 0;
      insts.workreg = workreg;
      multiply_i(r1, r2, n, scc, &insts);
      if (insts.n > integer_load_max+2) {
        load_integer(workreg, n, 0);
        if (workreg != r1)
          outinstr(OP_MUL | F_RN(r1) | (r2 << 8) | workreg | scc);
        else
          outinstr(OP_MUL | F_RN(r1) | (workreg << 8) | r2 | scc);
      } else {
        int n = 0;
        for (; n < insts.n; n++) outinstr(insts.i[n]);
      }
    }
}

#if DEBUG_X
/* For truly grim debugging I can make each compiled function display    */
/* its name each time it is entered. This is arranged here. Ugh.         */
static void desperate_codetrace(void)
    {   int32 w = 0, c, i = 0;
        outinstr(0x0f000001);       /* SWI KString */
            while ((c=symname_(currentfunction.symstr)[i++]) != 0)
            {   w = ((w>>8) & 0x00ffffff) | (c << 24);
                if ((w & 0xff)!=0)
                    outcodeword(w, LIT_STRING), w=0;
            }
            w = ((w>>8) & 0x00ffffff) | (((int32)'\r')<<24);
            if ((w & 0xff)!=0)
                outcodeword(w, LIT_STRING), w=0;
            w = ((w>>8) & 0x00ffffff) | (((int32)'\n')<<24);
            if ((w & 0xff)!=0)
            {   outcodeword(w,LIT_STRING);
                outcodeword(0,LIT_STRING);
            }
            else
            {   while ((w & 0xff)==0) w = (w>>8) & 0x00ffffff;
                outcodeword(w,LIT_STRING);
            }
    }
#endif /* DEBUG_X */


static RealRegister local_base_a(int32 p)
{
    switch (p & BINDADDR_MASK)
    {   default: syserr(syserr_local_base, (long)p);
        case BINDADDR_ARG: if ((procflags & NONLEAF) && !(pcs_flags & PCS_NOFP) &&
                               !(procauxflags & bitoffnaux_(s_irq)))
                               return R_FP;
                           /* drop through */
        case BINDADDR_LOC: return R_SP;
    }
}

RealRegister local_base(Binder *b) {
    return local_base_a(bindaddr_(b));
}

static int32 local_addr_a(int32 p)
{
    /* fp_minus_sp is now maintained by show_instruction_direct, so is
       up to date even if the instruction to modify the sp hasn't yet been
       generated thanks to peepholing.
     */
    switch (p & BINDADDR_MASK)
    {
default:
        syserr(syserr_local_addr, (long)p);
case BINDADDR_LOC:
        p = fp_minus_sp - (p & ~BINDADDR_MASK);
/*
 * You might have thought that the next line was a sensible thing to have
 * put in as a consistency check, but CSE elimination can lift an ADCONV
 * outside the scope of the variable being addressed.  The result is that
 * the address is sometimes computed as a negative offset relative to sp,
 * ready for when sp gets dropped later.  Ugh!
 *      if (p < 0) syserr(syserr_neg_addr, (long)p, (long)p, b);
 */
        return p;
case BINDADDR_ARG:
        p &= ~BINDADDR_MASK;
#if 0
        if (!(procflags & NONLEAF))
        {   /* LDRV1 only - hence nargwords > NARGREGS.  SP relative.   */
            if (p < 4*nregargwords) syserr(syserr_local_addr1);
            p += fp_minus_sp;
            return p - 16 + 4*bitcount(regmask & (M_VARREGS | regbit(R_LR)))
                          + 12*bitcount(regmask & M_FVARREGS);
        }
#endif
        /* on the ARM the args go in different places depending on      */
        /* their number.  This saves one STM for <= NARGREGS args.      */
        p -= (p >= 4*argwordsbelowfp) ?
                   4*(argwordsbelowfp - savewordsabovefp) :
                   4*(argwordsbelowfp + intsavewordsbelowfp);
        return (!(procflags & NONLEAF) || (pcs_flags & PCS_NOFP) ||
                (procauxflags & bitoffnaux_(s_irq))) ?
                   p + fp_minus_sp + 4*(intsavewordsbelowfp +
                                        realargwordsbelowfp +
                                        3*bitcount(regmask & M_FVARREGS)) :
                   p;
    }
}

int32 local_address(Binder *b) {
    return local_addr_a(bindaddr_(b));
}

#ifdef TARGET_HAS_DEBUGGER
/* The miserable debugger cannot cope with SP relative addresses so we */
/* have to calculate FP relative ones specially!                       */
/* Lets hope that we have calculated these correctly!                  */
/* This means that cg.c has set PROC_ARGPUSH which thereby inhibits    */
/* leaf procedure optimisation (else there would be no FP!)            */
int32 local_fpaddress(int32 p)
/* exported for debugger */
{   /* p is bindaddr_() of the relevant binder */
    if (procflags & NONLEAF) switch (p & BINDADDR_MASK)
    {
case BINDADDR_LOC:
        p &= ~BINDADDR_MASK;
        return -(p + 4*(intsavewordsbelowfp +
                        realargwordsbelowfp +
                        3*bitcount(regmask & M_FVARREGS)));
case BINDADDR_ARG:
        p &= ~BINDADDR_MASK;
        return (p >= 4*argwordsbelowfp) ?
                   p - 4*(argwordsbelowfp - savewordsabovefp) :
                   p - 4*(argwordsbelowfp + intsavewordsbelowfp);
    }
    syserr(syserr_debug_addr);
    return 0;
}
#endif /* TARGET_HAS_DEBUGGER */

static int32 const fm_countbits[] = { F_FM_1, F_FM_2, F_FM_3, F_FM_4 };

static void savefpregs(int32 mask)
{
    RealRegister r1;
    int32 spbit = F_RN(frameregs[R_SP]);
    for (r1 = R_F7; r1 >= R_F4; r1--)
    {   if (mask & regbit(r1))
        {   if (pcs_flags & PCS_FPE3) {
                int count = 1;
                while (--r1 >= R_F4 && count < 4 && (mask & regbit(r1)))
                    count++;
                outinstr(OP_CPPRE | F_DOWN | F_WRITEBACK | F_STR |
                         spbit | F_RD((r1+1) & 0xf) | fm_countbits[count-1] |
                         (3L * count));
            } else
                outinstr(OP_CPPRE | F_DOWN | F_WRITEBACK | F_STR |
                         spbit | F_RD(r1 & 0xf) | F_EXTENDED | 3);
        }
    }
}

static void restorefpregs(int32 mask, int32 condition)
{
    RealRegister r;
    int n = (int)(intsavewordsbelowfp +
                  3 * bitcount(regmask & M_FVARREGS) +
                  realargwordsbelowfp);
    for (r = R_F4; r <= R_F7; r++)
        if (regbit(r) & mask)
        {   if (!(procflags & NONLEAF) || (pcs_flags & PCS_NOFP) ||
                 (procauxflags & bitoffnaux_(s_irq)))
            {   int32 spbit = F_RN(frameregs[R_SP]);
                if (pcs_flags & PCS_FPE3)
                {   int count = 1;
                    RealRegister r1 = r;
                    while (count < 4 && ++r <= R_F7 && (mask & regbit(r)))
                        count++;
                    outinstr(OP_CPPOST | condition | F_UP | F_LDR | F_WRITEBACK |
                             spbit | F_RD(r1 & 0xf) | fm_countbits[count-1] |
                             (3L * count));
                } else
                    outinstr(OP_CPPOST | condition | F_UP | F_LDR | F_WRITEBACK |
                             spbit | F_RD(r & 0xf) | F_EXTENDED | 3);
            } else {
                int32 fpbit = F_RN(frameregs[R_FP]);
                int count = 1;
                if (pcs_flags & PCS_FPE3)
                {   RealRegister r1 = r;
                    while (++r <= R_F7 && (mask & regbit(r)))
                        count++;
                    outinstr(OP_CPPRE | condition | F_DOWN | F_LDR | fpbit |
                             F_RD(r1 & 0xf) | fm_countbits[count-1] | n);
                } else
                    outinstr(OP_CPPRE | condition | F_DOWN | F_LDR | fpbit |
                             F_RD(r & 0xf) | F_EXTENDED | n);
                n -= 3 * count;
            }
        }
}

static void savefltargs(int32 n) {
    int32 spbit = F_RN(frameregs[R_SP]);
    for (; --n >= 0; )
        outinstr(OP_CPPRE | F_DOWN | F_WRITEBACK | F_STR |
                 spbit | F_RD(R_F0+n) | F_DOUBLE | 2);
}

static int32 LSBits(int32 mask, int n) {
    int32 mask1 = 0;
    for (; --n >= 0;) {
        int32 bit = mask & (-mask);
        mask1 |= bit;
        mask ^= bit;
    }
    return mask1;
}

static int32 MSBits(int32 mask, int n) {
    int n1 = (int)bitcount(mask) - n;
    for (; --n1 >= 0;) {
        mask ^= mask & (-mask);
    }
    return mask;
}

static RealRegister LowestRegister(int32 mask) {
    RealRegister r;
    for (r = 0; r < 16; r++, mask >>= 1) {
        if (mask & 1)
            break;
    }

    return r;
}

static void PushRegs(int32 mask) {
    RealRegister sp = frameregs[R_SP];
    unsigned count = (unsigned)bitcount(mask);
    int32 stm = OP_STMFD | F_WRITEBACK | F_RN(sp);
    for (; count > ldm_regs_max; count -= ldm_regs_max) {
        int32 mask1 = MSBits(mask, ldm_regs_max);
        mask ^= mask1;
        outinstr(stm | mask1);
    }
    if (count == 1)
        outinstr(OP_PREN | F_STR | F_WORD | F_WRITEBACK | F_DOWN | F_RD(LowestRegister(mask)) | F_RN(sp) | 4);
    else
        outinstr(stm | mask);
}

static void routine_entry(int32 m)
{   RealRegister sp = frameregs[R_SP];
    RealRegister ip = frameregs[R_IP];
    int32 intregs = k_intregs_(m),
          fltregs = k_fltregs_(m);
    condition_mask = C_ALWAYS;
    if (m < 0) syserr(syserr_enter, (long)m);
    nargwords = k_argwords_(m);
    nregargwords = intregs + 2*fltregs;
#if DEBUG_X
    if (debugging(DEBUG_X)) desperate_codetrace();
#endif

    {   Symstr *name = currentfunction.symstr;
        int flags = currentfunction.xrflags;
        if ((pcs_flags & PCS_REENTRANT) &&
            (procflags & PROC_USESADCONS))
            flags |= aof_usessb;
        if (!(procflags & NONLEAF)) {
#ifndef TARGET_IS_UNIX
            if (!(procflags & BLK0EXIT))
                flags |= aof_leaf;
#endif
        } else if (feature & FEATURE_SAVENAME)
/* Dump a function name only if the function will have a stack frame... */
/* Without a frame the name isn't locatable (RISC OS and RISCiX kernel) */
            codeseg_function_name(name, /* nargwords, unused on ARM */ m);
        if (k_fltregs_(m) != 0) flags |= aof_fpreg;
        dbg_enterproc();
        show_entry(name, flags);
    }

#ifdef TARGET_IS_UNIX
    if (profile_option) {
        int32 loc = data.size;
        gendcI(4, 0);
        move_register(frameregs[R_IP], R_LR, 0);
        outinstr3(OP_BL, countroutine, 0);
        obj_symref(bindsym_(datasegment), xr_data, 0);
        AddCodeXref4(X_backaddrlit | (codebase + codep), bindsym_(datasegment), loc);
        outcodeword(loc, LIT_ADCON);
    }
#endif
    fp_minus_sp = 0;
    returnlab = nextlabel();
    argwordsbelowfp = realargwordsbelowfp = 0;
    argstopopabovefp = 0;
    if (!(procflags & NONLEAF) || (pcs_flags & PCS_NOFP) ||
         (procauxflags & bitoffnaux_(s_irq)))
    {
        int32 mask;
        savewordsabovefp = 0;
        if (feature & FEATURE_DONTUSE_LINKREG)
            regmask |= M_LR;
        if (procauxflags & bitoffnaux_(s_irq)) {
            mask = regmask & (M_VARREGS | M_ARGREGS | regbit(R_IP) | M_LR);
            if (pcs_flags & PCS_NOFP) {
                regmask |= regbit(R_FP); mask |= regbit(R_FP);
            }
        } else {
            mask = regmask & (M_VARREGS | M_LR);
            if (procflags & PROC_ARGPUSH) {
                bool maybevariadic = fltregs == 0 && intregs < nargwords;
                if (maybevariadic) {
                    PushRegs(M_ARGREGS);
                    argstopopabovefp = NARGREGS;
                } else {
                    argwordsbelowfp = nregargwords;
                    mask |= (regbit(R_A1+intregs) - regbit(R_A1));
                    realargwordsbelowfp = nregargwords;
                }
            } else
                argwordsbelowfp = nregargwords;
        }
        if ((pcs_flags & PCS_REENTRANT) &&
            (procflags & (PROC_USESADCONS+BLK0EXIT)))
        {   outinstr(OP_RXR | F_MOV | F_RD(ip) | R_SB);
            regmask |= regbit(R_SB); mask |= regbit(R_SB);
            PushRegs(mask);
            outinstr(OP_RXR | F_MOV | F_RD(R_SB) | ip);
        } else if (mask != 0)
            PushRegs(mask);
        savewordsabovefp = 0;
        intsavewordsbelowfp = bitcount(mask & ~M_ARGREGS);
        if (procflags & PROC_ARGPUSH) savefltargs(fltregs);
        savefpregs(regmask);
    }
    else
    {   RealRegister fp = frameregs[R_FP];
        bool saveargs = ((feature & FEATURE_SAVENAME) || (procflags & PROC_ARGPUSH));
        bool maybevariadic = fltregs == 0 && intregs < nargwords && saveargs;
        int32 mask;
        savewordsabovefp = 1;
        if (pcs_flags & PCS_REENTRANT) {
            int32 fpoff;
            regmask |= regbit(R_SB);
            mask = (regmask & M_VARREGS) | regbit(fp);
            intsavewordsbelowfp = bitcount(mask) + 2; /* + sp and lr */
            fpoff = intsavewordsbelowfp;

            outinstr(OP_RXR | F_MOV | F_RD(ip) | R_SB);
            if (!maybevariadic)
            {   PushRegs(regbit(sp) | M_LR | M_PC);
                argwordsbelowfp = nregargwords;
                if (saveargs) {
                    mask |= (regbit(R_A1+intregs) - regbit(R_A1));
                    realargwordsbelowfp = nregargwords;
                }
                PushRegs(mask);
                if (saveargs) {
                    savefltargs(fltregs);
                    fpoff += argwordsbelowfp;
                }
                outinstr(OP_RXR | F_MOV | F_RD(R_SB) | ip);
            } else {
                PushRegs(M_ARGREGS);
                PushRegs(mask | regbit(sp) | M_LR | M_PC);
                outinstr(OP_RXR | F_MOV | F_RD(R_SB) | ip);
                add_integer(ip, sp, 28+4*bitcount(mask), 0);
                outinstr(OP_PREN | F_STR | F_DOWN | F_WORD | F_RD(ip) | F_RN(ip) | 28);
            }
            add_integer(fp, sp, 4*fpoff, 0);

        } else {
            int32 fpoff = 4;
            mask = (regmask & M_VARREGS) | regbit(fp) | regbit(ip) | M_LR | M_PC;
            intsavewordsbelowfp = bitcount(mask) - 1; /* not pc */

            outinstr(OP_RXR | F_MOV | F_RD(ip) | sp);
            if (!maybevariadic)
            {   argwordsbelowfp = nregargwords;
                if (saveargs) {
                    mask |= (regbit(R_A1+intregs) - regbit(R_A1));
                    realargwordsbelowfp = nregargwords;
                }
            } else {
                PushRegs(M_ARGREGS);
                fpoff += NARGREGS*4;
            }
            PushRegs(mask);
            if (saveargs) savefltargs(fltregs);
            add_integer(fp, ip, -fpoff, 0);
        }
        savefpregs(regmask);
        if ((procflags & STACKCHECK) &&      /* not a leaf function and no large frame */
            !no_stack_checks &&              /* not locally turned off (pragma -s) */
            !(pcs_flags & PCS_NOSTACKCHECK)) /* not globally turned of (-apcs 3/noswst) */
        {   Symstr *name = stackoverflow;
            RealRegister sl = frameregs[R_SL];
            if (greatest_stackdepth > 256)
            {   int32 n = eightbit_ceiling(greatest_stackdepth);
                add_integer(ip, sp, -n, 0);
                outinstr(OP_RXR | F_CMP | F_SCC | F_RN(ip) | sl);
                name = stack1overflow;
            }
            else
                outinstr(OP_RXR | F_CMP | F_SCC | F_RN(sp) | sl);
            outinstr3(OP_BL | C_LT, name, 0);
#ifdef TARGET_IS_HELIOS
            request_stub(name);
#endif
        }
    }
#ifdef TARGET_STACK_MOVES_ONCE
    /* Simulate J_SETSP */
    add_integer(frameregs[R_SP], frameregs[R_SP], -greatest_stackdepth, 0);
    fp_minus_sp += greatest_stackdepth;
#endif
}

static void PopRegs(int32 condition, int32 mask) {
    RealRegister sp = frameregs[R_SP];
    int32 setsp = mask & F_PSR;
    mask &= ~F_PSR;
    {   unsigned count = (unsigned)bitcount(mask);
        unsigned maxcount = ldm_regs_max < 3 ? 3 : ldm_regs_max;
        int32 ldm = OP_LDMFD | condition | F_WRITEBACK | F_RN(sp);
        if (maxcount < count) {
            setsp |= MSBits(mask, maxcount);
            mask &= ~setsp;
            count -= maxcount;
            do {
                unsigned n = count > maxcount ? maxcount : count;
                int32 mask1 = LSBits(mask, n);
                mask ^= mask1;
                outinstr(ldm | mask1);
                count -= n;
            } while (count != 0);
            mask = setsp;
        }
        if (mask & regbit(sp)) ldm &= ~F_WRITEBACK;
        if (count == 1 && !setsp) {
            if (ldm & F_WRITEBACK)
                outinstr(condition | OP_POSTN | F_LDR | F_WORD | F_UP | F_RD(LowestRegister(mask)) | F_RN(sp) | 4);
            else
                outinstr(condition | OP_PREN | F_LDR | F_WORD | F_UP | F_RD(LowestRegister(mask)) | F_RN(sp));
        }
        else
            outinstr(ldm | mask | setsp);
    }
}

static bool ReturnIsSingleInstruction() {
   /* This must be kept up to date with routine_exit(), or code will
      be broken in places which assume a return is a single instruction
      (principly in switches).  To help, its structure follows that
      of routine_exit().
    */
#ifdef TARGET_STACK_MOVES_ONCE
    if (!(procflags & NONLEAF)) return NO;
#endif
#ifndef PROFILE_COUNTS_INLINE
    if (profile_option) return NO;
#endif
    if (regmask & M_FVARREGS ||
        procauxflags & bitoffnaux_(s_irq))
        return NO;
    if ((procflags & NONLEAF) && !(pcs_flags & PCS_NOFP)) {
        return bitcount(regmask & M_VARREGS) + 3 <= ldm_regs_max;
    } else {
        if (realargwordsbelowfp != 0 || argstopopabovefp != 0 ||
            (!(regmask & M_LR) && (regmask & M_VARREGS)) ||
            bitcount(regmask & M_VARREGS)+1 > ldm_regs_max)
            return NO;
        return YES;
    }
}

/* Restore all registers for routine exit.  Normally to_pc is set to give */
/* a return, but if unset causes LR to be restored for a TAILCALL.        */
static void routine_exit(int32 condition, bool to_pc)
{   RealRegister sp = frameregs[R_SP];
    int32 mask = regmask;
    int32 ldm_link = !to_pc ? M_LR :
                     procauxflags & bitoffnaux_(s_irq) ? M_LR :
                     (pcs_flags & PCS_CALLCHANGESPSR) ? M_PC :
                              M_PC | F_PSR;

#ifdef TARGET_STACK_MOVES_ONCE
    /* Simulate J_SETSP, and its ARM elision before NONLEAF return.       */
    /* /* this is wrong (condition as scc argument for add_integer is     */
    /* misguided)                                                         */
    if (!(procflags & NONLEAF))
      /* don't update fp_minus_fp, since next basic block requires.       */
      add_integer(frameregs[R_SP], frameregs[R_SP],
                  greatest_stackdepth, condition);
#endif
    if (feature & FEATURE_DONTUSE_LINKREG) mask |= M_LR;
    restorefpregs(mask, condition);
#ifndef PROFILE_COUNTS_INLINE
    if (profile_option)
        outinstr3(OP_BL | condition, fn_exit_sym, NO);
#endif
    if ((procflags & NONLEAF) && !(pcs_flags & PCS_NOFP) &&
         !(procauxflags & bitoffnaux_(s_irq))) {
        RealRegister fp = frameregs[R_FP];
        unsigned count = (unsigned)bitcount(mask & M_VARREGS);
        mask = (mask & M_VARREGS) | regbit(fp) | regbit(sp) | ldm_link;
        if (count+3 <= ldm_regs_max)
            outinstr(OP_LDMDB | condition | F_RN(fp) | mask);
        else {
          /* sp may already be right, but I can't know because SETSPs have
             been peepholed out before returns
           */
            outinstr(OP_RXN | condition | F_SUB | F_RD(sp) | F_RN(fp) |
                     4*(count + 3L));
            PopRegs(condition, mask);
        }
    } else {
        if (procauxflags & bitoffnaux_(s_irq))
            mask &= M_VARREGS | M_ARGREGS | regbit(R_IP) | M_LR;
        else {
            if (realargwordsbelowfp != 0)
               outinstr(OP_RXN | condition | F_ADD | F_RD(sp) | F_RN(sp) |
                        (4*realargwordsbelowfp));
            mask &= M_VARREGS;
        }
        if ((regmask & M_LR) == 0 || argstopopabovefp != 0)
        {   mask |= (regmask & M_LR);
            if (mask != 0)    /* AM: for odd circ's in tail recursion */
                PopRegs(condition, mask);
            if (argstopopabovefp != 0)
               outinstr(OP_RXN | condition | F_ADD | F_RD(sp) | F_RN(sp) |
                        (4*argstopopabovefp));

            if (to_pc && !(procauxflags & bitoffnaux_(s_irq)))
                outinstr(OP_RXR | condition | F_MOV | F_RD(R_PC) | R_LR |
                         ((pcs_flags & PCS_CALLCHANGESPSR) ? 0 : F_SCC));
        }
        else
            PopRegs(condition, mask | ldm_link);
        if (procauxflags & bitoffnaux_(s_irq))
            outinstr(OP_RXN | condition | F_SUB | F_RD(R_PC) | F_RN(R_LR) |
                     F_SCC | 4);
    }
}

static void conditional_branch_to(int32 condition,
                                  LabelNumber *destination,
                                  bool bxxcase)
{
    condition = C_FROMQ(condition);
    if (destination == RETLAB)
/* The test here is expected to detect all cases where the return ought    */
/* to expand into just one instruction.  Such cases are: 1. in a switch    */
/* branchtable, 2. returns with fp regs to restore when we try (harder)    */
/* to generate a single return sequence.  The latter trades a little loss  */
/* of speed for a (bigger?) improvement in code density.                   */
    {   if ((bxxcase && !ReturnIsSingleInstruction()) ||
/* AM: extra test to avoid generating conditional returns as (a) there will  */
/* will probably be an unconditional one (main reason) and (b) slow on ARM-1 */
            ((condition != (C_ALWAYS^C_ALWAYS) || condition_mask != C_ALWAYS
                                               || lab_isset_(returnlab)) &&
             (regmask & M_FVARREGS)!=0))
        {   destination = returnlab;
        }
        else
        {   /* Only set a return label if this is an UNCONDITIONAL return. */
            if (condition == (C_ALWAYS^C_ALWAYS) &&
                condition_mask == C_ALWAYS &&
                !lab_isset_(returnlab)) setlabel(returnlab);
            dbg_return(codebase+codep);
            routine_exit(condition, YES);
            return;
        }
    }
/* This is where I need to discriminate between the two sorts of things  */
/* that I put in the ->frefs field of a label entry.                     */
    if (lab_isset_(destination))
    {   int32 w = destination->u.defn;          /* ->frefs */
        outinstr(OP_B | condition |
                 ((((w & 0x00ffffff) - codep - 8) >> 2) & 0x00ffffff));
    }
    else
    {   addfref_(destination, codep | LABREF_BRANCH);
        outinstr(OP_B | condition);
    }
}

/* Exported routines...                                               */

void show_instruction(J_OPCODE op, VRegInt r1, VRegInt r2, VRegInt m)
{   int32 dataflow = op & J_DEADBITS;
    static int32 cond = Q_AL;
    int32 newcond = 1;
    op &= ~(J_DEADBITS|J_ALIGNMENT);    /* remove dataflow bits         */
/* While code is still in flux, we assume all STRW's coming here have   */
/* J_ALIGN4&J_ALIGNWR set...                                            */
    if ((op & J_TABLE_BITS) == J_STRWK || (op & J_TABLE_BITS) == J_STRWR)
        op = op - J_STRWK + J_STRK;
    switch (op) {
    case J_SETSP:
        {   int32 oldstack = r2.i, newstack = m.i;
            int32 diff = newstack - oldstack;
            if (fp_minus_sp != oldstack)
                syserr(syserr_setsp_confused,
                       (long)fp_minus_sp, (long)oldstack, (long)newstack);
            fp_minus_sp = newstack;
            op = J_ADDK; r1.rr = R_SP; r2.rr = R_SP; m.i = -diff;
            dataflow = J_DEAD_R2;
        }
        break;
    case J_PUSHM:  fp_minus_sp += (4 * bitcount(m.i)); break;
    case J_PUSHD:  m.i = 0; fp_minus_sp += 8; break;
/* case J_PUSHR: should never reach armgen (removed in flowgraf.c) */
    case J_PUSHF:  m.i = 0; fp_minus_sp += 4; break;

    case J_SUBK:   op = J_ADDK; m.i = -m.i; break;
    case J_SHLK+J_SIGNED:
    case J_SHLK+J_UNSIGNED:
    case J_SHRK+J_UNSIGNED:
                   m.i &= 255;
                   if (m.i >= 32) {
                       op = J_MOVK; dataflow &= ~J_DEAD_R2;
                       m.i = 0;
                   }
                   break;
    case J_SHRK+J_SIGNED:
                   m.i &= 255;
                   if (m.i >= 32) m.i = 31;
                   break;
    }
    {   bool flush = NO;
        switch (op & ~Q_MASK) {
        case J_ENTER: case J_ENDPROC: case J_LABEL:
            newcond = Q_AL; flush = YES; break;
        case J_STACK: case J_INFOLINE: case J_INFOBODY: case J_INFOSCOPE:
        case J_OPSYSK: case J_CALLK: case J_CALLR: case J_CALLI:
        case J_CASEBRANCH: case J_BXX:
        case J_B:
        case J_WORD: case J_ORG:
            flush = YES; break;
        case J_CONDEXEC:
            newcond = op & Q_MASK; /*flush = YES; */ break;
        }
        {   PendingOp cur;
            cur.op = op; cur.r1 = r1.rr; cur.r2 = r2.rr; cur.m = m.i;
            cur.r4 = 0; cur.peep = 0; cur.dataflow = dataflow;
            cur.cond = cond;
            peephole_op(&cur, flush);
            if (flush) ldm_flush();
            if (newcond != 1) cond = newcond;
        }
    }
}

/* the next routine is required for the machine independent codebuf.c */
void branch_round_literals(LabelNumber *m)
{
    int32 c = condition_mask;
    PendingOp p;
    condition_mask = C_ALWAYS;   /* in case conditional instructions */
    p.op = J_B; p.r1 = p.r2 = p.r4 = GAP; p.m = (int32)m;
    p.peep = p.dataflow = 0;
    show_inst_direct(&p);
    condition_mask = c;
}

static struct { char *name; Symstr *sym; int32 op; } inlinetable[] = {
    {"__r_sqrt", 0, OP_CPOP | CPDO_SINGLE | F_SQT},
    {"__r_exp",  0, OP_CPOP | CPDO_SINGLE | F_EXP},
    {"__r_log",  0, OP_CPOP | CPDO_SINGLE | F_LGN},
    {"__r_lg10", 0, OP_CPOP | CPDO_SINGLE | F_LOG},
    {"__r_sin",  0, OP_CPOP | CPDO_SINGLE | F_SIN},
    {"__r_cos",  0, OP_CPOP | CPDO_SINGLE | F_COS},
    {"__r_tan",  0, OP_CPOP | CPDO_SINGLE | F_TAN},
    {"__r_asin", 0, OP_CPOP | CPDO_SINGLE | F_ASN},
    {"__r_acos", 0, OP_CPOP | CPDO_SINGLE | F_ACS},
    {"__r_atan", 0, OP_CPOP | CPDO_SINGLE | F_ATN},
    {"__r_abs",  0, OP_CPOP | CPDO_SINGLE | F_ABS},

    {"__d_sqrt", 0, OP_CPOP | CPDO_DOUBLE | F_SQT},
    {"__d_exp",  0, OP_CPOP | CPDO_DOUBLE | F_EXP},
    {"__d_log",  0, OP_CPOP | CPDO_DOUBLE | F_LGN},
    {"__d_lg10", 0, OP_CPOP | CPDO_DOUBLE | F_LOG},
    {"__d_sin",  0, OP_CPOP | CPDO_DOUBLE | F_SIN},
    {"__d_cos",  0, OP_CPOP | CPDO_DOUBLE | F_COS},
    {"__d_tan",  0, OP_CPOP | CPDO_DOUBLE | F_TAN},
    {"__d_asin", 0, OP_CPOP | CPDO_DOUBLE | F_ASN},
    {"__d_acos", 0, OP_CPOP | CPDO_DOUBLE | F_ACS},
    {"__d_atan", 0, OP_CPOP | CPDO_DOUBLE | F_ATN},
    {"__d_abs",  0, OP_CPOP | CPDO_DOUBLE | F_ABS},
    {0,0,0}};

static void initinlinetable(void)
{
    int i;
    for (i = 0; ; i++) {
        char *name = inlinetable[i].name;
        if (name == NULL) return;
        inlinetable[i].sym = sym_insert_id(name);
    }
}

int32 target_inlinable(Binder *b, int32 nargs)
{
    if (nargs == 1) {
        int i;
        Symstr *sym = bindsym_(b);
        for (i = 0; ; i++) {
            Symstr *tsym = inlinetable[i].sym;
            if (tsym == 0) return 0;
            if (tsym == sym) return inlinetable[i].op;
        }
    }
    return 0;
}

bool alterscc(Icode *ic)
{
    return setspsr(ic->op & J_TABLE_BITS, ic->m.i);
}

#define TYPESPEC_DOUBLE typespecmap_(te_double)
#define TYPESPEC_FLOAT typespecmap_(te_float)

void setcallingstandard(char callingstandard)
{   if (callingstandard == 'R' || callingstandard == 'U') {
        frameregs[R_SL] = 10; asm_setregname(10, "sl");
        frameregs[R_FP] = 11; asm_setregname(11, "fp");
        frameregs[R_IP] = 12; asm_setregname(12, "ip");
        frameregs[R_SP] = 13; asm_setregname(13, "sp");
    } else if (callingstandard == 'A') {
        frameregs[R_SL] = 13; asm_setregname(13, "sl");
        frameregs[R_FP] = 10; asm_setregname(10, "fp");
        frameregs[R_IP] = 11; asm_setregname(11, "ip");
        frameregs[R_SP] = 12; asm_setregname(12, "sp");
    } else if (callingstandard == 'M') {
        frameregs[R_SL] = 12;  asm_setregname(12, "sl");
        frameregs[R_FP] = 10;  asm_setregname(10, "fp");
        frameregs[R_IP] = 11;  asm_setregname(11, "ip");
        frameregs[R_SP] = 13;  asm_setregname(13, "sp");
    } else
        syserr(syserr_callingstandard, callingstandard);

}

void localcg_reinit(void) {
    ipvalue.valid = NO;
    spareregs = 0;
    peephole_reinit();
}

void mcdep_init(void)
{
    ldm_reinit();
    adconpool_init();
    condition_mask = C_ALWAYS;

    if (pcs_flags & PCS_CALLCHANGESPSR) pp_predefine("__APCS_32");
    if (pcs_flags & PCS_FPREGARGS)      pp_predefine("__APCS_FPREGARGS");
    if (pcs_flags & PCS_NOFP)           pp_predefine("__APCS_NOFP");
    if (pcs_flags & PCS_REENTRANT)      pp_predefine("__APCS_REENT");
    if (pcs_flags & PCS_NOSTACKCHECK)   pp_predefine("__APCS_NOSWST");

#ifdef TARGET_IS_HELIOS
#  ifdef TRIPOS_OBJECTS
    outcodeword(0, LIT_NUMBER);
#  endif
    /* no B __main at the start of modules any more, since silly for all */
    /* ARM image formats                                                 */
#endif
    lib_reloc_sym = sym_insert_id("_Lib$Reloc$Off");
    mod_reloc_sym = sym_insert_id("_Mod$Reloc$Off");
#ifndef PROFILE_COUNTS_INLINE
    fn_entry_sym = sym_insert_id("__fn_entry");
    fn_exit_sym = sym_insert_id("__fn_exit");
#endif
    /* we must do the following initialisations once per module to     */
    /* avoid the store being reallocated (misapprehension & bug fix).  */
    fpliterals[0].val = fc_zero.d;
    fpliterals[1].val = fc_one.d;
    fpliterals[2].val = fc_two.d;
    fpliterals[3].val = real_of_string("3.0", TYPESPEC_DOUBLE);
    fpliterals[4].val = real_of_string("4.0", TYPESPEC_DOUBLE);
    fpliterals[5].val = real_of_string("5.0", TYPESPEC_DOUBLE);
    fpliterals[6].val = real_of_string("0.5", TYPESPEC_DOUBLE);
    fpliterals[7].val = real_of_string("10.0", TYPESPEC_DOUBLE);
    fpliterals[8].val = fc_zero.s;
    fpliterals[9].val = fc_one.s;
    fpliterals[10].val = fc_two.s;
    fpliterals[11].val = real_of_string("3.0", TYPESPEC_FLOAT);
    fpliterals[12].val = real_of_string("4.0", TYPESPEC_FLOAT);
    fpliterals[13].val = real_of_string("5.0", TYPESPEC_FLOAT);
    fpliterals[14].val = real_of_string("0.5", TYPESPEC_FLOAT);
    fpliterals[15].val = real_of_string("10.0", TYPESPEC_FLOAT);
    if (feature & FEATURE_DONTUSE_LINKREG) avoidallocating(R_LR);
    if (!(pcs_flags & PCS_NOSTACKCHECK))
        avoidallocating(R_SL);
    else
        asm_setregname(frameregs[R_SL], "v7");
    if (!(pcs_flags & PCS_NOFP))
        avoidallocating(R_FP);
    else
        asm_setregname(frameregs[R_FP], "v8");
    if (pcs_flags & PCS_REENTRANT) {
        avoidallocating(R_SB);
        asm_setregname((int)R_SB, "sb");
    } else
        asm_setregname((int)R_SB, "v6");

    initinlinetable();
    peephole_init();
}

void localcg_tidy(void)
{
    peephole_tidy();
}

/* End of section arm/gen.c */
