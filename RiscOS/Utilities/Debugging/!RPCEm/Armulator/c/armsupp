/***************************************************************************\
* armsupp.c                                                                 *
* ARMulator II support code.                                                *
* Copyright (C) 1991 Advanced RISC Machines Limited.  All rights reserved.  *
* Written by Dave Jaggar.                                                   *
\***************************************************************************/

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */


#include "armdefs.h"
#include "armemu.h"

/***************************************************************************\
*                 Definitions for the emulator architecture                 *
\***************************************************************************/

void ARMul_EmulateInit(void) ;
ARMul_State *ARMul_NewState(void) ;
void ARMul_Reset(ARMul_State *state) ;
void ARMul_SelectProcessor(ARMul_State *state, unsigned processor) ;
ARMword ARMul_DoCycle(ARMul_State *state) ;
unsigned ARMul_DoCoPro(ARMul_State *state) ;
ARMword ARMul_DoProg(ARMul_State *state) ;
ARMword ARMul_DoInstr(ARMul_State *state) ;

unsigned ARMul_MultTable[32] = {1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,
                                10,10,11,11,12,12,13,13,14,14,15,15,16,16,16} ;
ARMword ARMul_ImmedTable[4096] ; /* immediate DP LHS values */
char ARMul_BitList[256] ; /* number of bits in a byte table */

/***************************************************************************\
*                    Definitions for the support routines                   *
\***************************************************************************/

ARMword ARMul_GetReg(ARMul_State *state, unsigned mode, unsigned reg) ;
void ARMul_SetReg(ARMul_State *state, unsigned mode, unsigned reg, ARMword value) ;
ARMword ARMul_GetPC(ARMul_State *state) ;
ARMword ARMul_GetNextPC(ARMul_State *state) ;
void ARMul_SetPC(ARMul_State *state, ARMword value) ;
ARMword ARMul_GetR15(ARMul_State *state) ;
void ARMul_SetR15(ARMul_State *state, ARMword value) ;

ARMword ARMul_GetCPSR(ARMul_State *state) ;
void ARMul_SetCPSR(ARMul_State *state, ARMword value) ;
void ARMul_FixCPSR(ARMul_State *state, ARMword instr, ARMword rhs) ;
ARMword ARMul_GetSPSR(ARMul_State *state, ARMword mode) ;
void ARMul_SetSPSR(ARMul_State *state, ARMword mode, ARMword value) ;
void ARMul_FixSPSR(ARMul_State *state, ARMword instr, ARMword rhs) ;

void ARMul_CPSRAltered(ARMul_State *state) ;
void ARMul_R15Altered(ARMul_State *state) ;

ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode) ;
static ARMword ModeToBank(ARMul_State *state,ARMword mode) ;

unsigned ARMul_NthReg(ARMword instr, unsigned number) ;

void ARMul_NegZero(ARMul_State *state, ARMword result) ;

void ARMul_LDC(ARMul_State *state,ARMword instr,ARMword address) ;
void ARMul_STC(ARMul_State *state,ARMword instr,ARMword address) ;
void ARMul_MCR(ARMul_State *state,ARMword instr, ARMword source) ;
ARMword ARMul_MRC(ARMul_State *state,ARMword instr) ;
void ARMul_CDP(ARMul_State *state,ARMword instr) ;
void ARMul_UndefInstr(ARMul_State *state,ARMword instr) ;
#ifdef CYCLEBASED
unsigned CoProNextState(ARMul_State *state, unsigned ready, unsigned busy) ;
#endif
unsigned IntPending(ARMul_State *state) ;

ARMword ARMul_Align(ARMul_State *state, ARMword address, ARMword data) ;

void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay,
                         unsigned (*what)()) ;
void ARMul_EnvokeEvent(ARMul_State *state) ;
unsigned long ARMul_Time(ARMul_State *state) ;
static void EnvokeList(ARMul_State *state, unsigned long from, unsigned long to) ;
#ifdef CYCLEBASED
char *ARMul_ErrorMess(ARMul_State *state,unsigned number) ;
#endif
void ARMul_Abort(ARMul_State *state, ARMword address) ;

struct EventNode { /* An event list node */
      unsigned (*func)() ; /* The function to call */
      struct EventNode *next ;
      } ;

/***************************************************************************\
*         Call this routine once to set up the emulator's tables.           *
\***************************************************************************/

void ARMul_EmulateInit(void)
{unsigned long i, j ;

 for (i = 0 ; i < 4096 ; i++) { /* the values of 12 bit dp rhs's */
    ARMul_ImmedTable[i] = ROTATER(i & 0xffL,(i >> 7L) & 0x1eL) ;
    }

 for (i = 0 ; i < 256 ; ARMul_BitList[i++] = 0 ) ; /* how many bits in LSM */
 for (j = 1 ; j < 256 ; j <<= 1)
    for (i = 0 ; i < 256 ; i++)
       if ((i & j) > 0 )
          ARMul_BitList[i]++ ;

  for (i = 0 ; i < 256 ; i++)
    ARMul_BitList[i] *= 4 ; /* you always need 4 times these values */

}

/***************************************************************************\
*            Returns a new instantiation of the ARMulator's state           *
\***************************************************************************/

/* The null modechange function at the end of the upcall chain. */
static void NULL_ModeChange(ARMul_State *state, ARMword oldmode, ARMword newmode) {
  return;
}

ARMul_State *ARMul_NewState(void)
{unsigned i ;
 ARMul_State *state = (ARMul_State *)calloc(1, sizeof(ARMul_State)) ;

 state->Emulate = RUN ;

 state->Inted = 3 ;
 state->LastInted = 3 ;

 state->MemDataPtr = NULL ;
 state->MemInPtr = NULL ;
 state->MemOutPtr = NULL ;
 state->MemSparePtr = NULL ;

 state->OSptr = NULL ;
 state->CommandLine = NULL ;

 state->EventPtr = (struct EventNode **)malloc((unsigned)EVENTLISTSIZE *
                                               sizeof(struct EventNode *)) ;
 for (i = 0 ; i < EVENTLISTSIZE ; i++)
    *(state->EventPtr + i) = NULL ;

/* INITPROC can be predefined to choose the processor to start up as.
 * It defaults to ARM6.
 */
#ifndef INITPROC
#define INITPROC ARM6
#endif

 ARMul_SelectProcessor(state, INITPROC);

 state->bigendSig = LOW ;

 state->ModeChange = NULL_ModeChange;

 ARMul_Reset(state) ;
 return(state) ;
 }

/***************************************************************************\
* Call this routine to set up the initial machine state (or perform a RESET *
\***************************************************************************/

void ARMul_Reset(ARMul_State *state)
{state->NextInstr = 0 ;

 if (state->prog32Sig) {
    state->Reg[15] = 0 ;
    state->Cpsr = INTBITS | SVC32MODE ;
    }
 else {
    state->Reg[15] = 0 ;
    state->Cpsr = INTBITS | SVC26MODE ;
    }
 ARMul_CPSRAltered(state) ;
 state->Bank = SVCBANK ;
 FLUSHPIPE ;

 state->EndCondition = 0 ;
 state->ErrorCode = 0 ;

#ifdef CYCLEBASED
 state->NextCycle = DESTPC1 ;
 state->NmBus = ~state->Mode & MODEBITS ;
 state->NrwSig = LOW ;
 state->doutenSig = LOW ;
 state->NbwSig = HIGH ;
 state->NcpiSig = HIGH ;
 state->cpaSig = LOW ;
 state->cpbSig = LOW ;
 state->LSCActive = FALSE ;
#endif
 state->Exception = FALSE ;
 state->NresetSig = HIGH ;
 state->NfiqSig = HIGH ;
 state->NirqSig = HIGH ;
 state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
 state->abortSig = LOW ;
 state->AbortAddr = 1 ;

 state->NumInstrs = 0 ;
 state->NumNcycles = 0 ;
 state->NumScycles = 0 ;
 state->NumIcycles = 0 ;
 state->NumCcycles = 0 ;
 state->NumFcycles = 0 ;
}

/***************************************************************************\
*       Call this routine to set ARMulator to model a certian processor     *
\***************************************************************************/

void ARMul_SelectProcessor(ARMul_State *state, unsigned processor) {
  state->Processor = processor;
  if (processor & ARM_Fix26_Prop) {
    state->prog32Sig = LOW;
    state->data32Sig = LOW;
  }else{
    state->prog32Sig = HIGH;
    state->data32Sig = HIGH;
  }

  if (processor & ARM_Abort7_Prop)
    state->lateabtSig = HIGH;
  else
    state->lateabtSig = LOW;
}

#ifdef CYCLEBASED

/***************************************************************************\
* Emulate the execution of one cycle.  Start the correct emulator           *
* (Emulate26 for a 26 bit ARM and Emulate32 for a 32 bit ARM), return the   *
* address of the instruction that is executed.                              *
\***************************************************************************/

ARMword ARMul_DoCycle(ARMul_State *state)
{ARMword pc ;

 state->Emulate = ONCE ;
 if (state->prog32Sig && ARMul_MODE32BIT)
    pc = ARMul_Emulate32(state) ;
 else
    pc = ARMul_Emulate26(state) ;
 return(pc) ;
 }

/***************************************************************************\
* Coprocessor fixup code, as cpa and cpb change too late for ARMulator      *
* to fully predict the next cycle                                           *
\***************************************************************************/

unsigned ARMul_DoCoPro(ARMul_State *state)
{if (state->NcpiSig == LOW) { /* there is a coprocessor handshake active */
    if ((state->cpaSig == LOW) && (state->cpbSig == LOW)) { /* Ready */
       state->addrBus = state->NextaddrBus ;
       state->NrwSig = state->NextNrwSig ;
       state->NopcSig = state->NextNopcSig ;
       state->NmreqSig = state->NextNmreqSig ;
       state->seqSig = state->NextseqSig ;
       return(TRUE) ;
       }
    else if ((state->cpaSig == LOW) && (state->cpbSig == HIGH)) { /* Busy, force I cycle */
       state->addrBus = state->PrevaddrBus & PCBITS ; /* Clear A[0,1] */
       state->NopcSig = HIGH ;
       state->NrwSig = LOW ;
       ICYCLE ;
       return(TRUE) ;
       }
    else if ((state->cpaSig == HIGH) && (state->cpbSig == HIGH)) { /* Bounce, force I cycle */
       state->addrBus = state->PrevaddrBus & PCBITS ; /* Clear A[0,1] */
       state->NopcSig = HIGH ;
       state->NrwSig = LOW ;
       ICYCLE ;
       return(TRUE) ;
       }
    else /* the illegal state */
       return(FALSE) ;
    }
 if (state->LSCActive) {
    if ((state->cpaSig == LOW) && (state->cpbSig == LOW)) { /* Inc */
       state->addrBus = state->PrevaddrBus + 4 ;
       state->NrwSig = state->PrevNrwSig ;
       state->NopcSig = HIGH ;
       SCYCLE ;
       return(TRUE) ;
       }
    else if (state->cpaSig != state->cpbSig) /* Illegal */
       return(FALSE) ;
    else { /* end of transfer cpa = cpb = HIGH */
       state->addrBus = state->NextaddrBus ;
       state->NrwSig = state->NextNrwSig ;
       state->NopcSig = state->NextNopcSig ;
       state->NmreqSig = state->NextNmreqSig ;
       state->seqSig = state->NextseqSig ;
       return(TRUE) ;
       }
    }
 return(TRUE) ;
 }

#else

/***************************************************************************\
* Emulate the execution of an entire program.  Start the correct emulator   *
* (Emulate26 for a 26 bit ARM and Emulate32 for a 32 bit ARM), return the   *
* address of the last instruction that is executed.                         *
\***************************************************************************/

ARMword ARMul_DoProg(ARMul_State *state)
{ARMword pc = 0 ;

 state->Emulate = RUN ;
 while (state->Emulate != STOP) {
    state->Emulate = RUN ;
    if (state->prog32Sig && ARMul_MODE32BIT)
       pc = ARMul_Emulate32(state) ;
    else
       pc = ARMul_Emulate26(state) ;
    }
 return(pc) ;
 }

/***************************************************************************\
* Emulate the execution of one instruction.  Start the correct emulator     *
* (Emulate26 for a 26 bit ARM and Emulate32 for a 32 bit ARM), return the   *
* address of the instruction that is executed.                              *
\***************************************************************************/

ARMword ARMul_DoInstr(ARMul_State *state)
{ ARMword pc = 0 ;
  do {
    state->Emulate = ONCE;
    if (state->prog32Sig && ARMul_MODE32BIT)
      pc = ARMul_Emulate32(state);
    else
      pc = ARMul_Emulate26(state);
  } while (state->NextInstr & PRIMEPIPE);
  return pc;
}

#endif

/***************************************************************************\
* This routine returns the value of a register from a mode.                 *
\***************************************************************************/

ARMword ARMul_GetReg(ARMul_State *state, unsigned mode, unsigned reg)
{  mode &= (unsigned)MODEBITS;
   if (mode != state->Mode) {
      ARMword newbank = ModeToBank(state,(ARMword)mode);
      if ((reg >= 13) || (newbank == FIQBANK && reg >= 8))
          return state->RegBank[newbank][reg];
       else if (reg >= 8 && ModeToBank(state, state->Mode) == FIQBANK)
          return state->RegBank[USERBANK][reg];
    }
    return(state->Reg[reg]) ;
}

/***************************************************************************\
* This routine sets the value of a register for a mode.                     *
\***************************************************************************/

void ARMul_SetReg(ARMul_State *state, unsigned mode, unsigned reg, ARMword value)
{  mode &= (unsigned)MODEBITS;
   if (mode != state->Mode) {
      ARMword newbank = ModeToBank(state,(ARMword)mode);
      if ((reg >= 13) || (newbank == FIQBANK && reg >= 8)) {
          state->RegBank[newbank][reg] = value;
          return;
       } else if (reg >= 8 && ModeToBank(state, state->Mode) == FIQBANK) {
          state->RegBank[USERBANK][reg] = value;
          return;
      }
   }
   state->Reg[reg] = value;
}

/***************************************************************************\
* This routine returns the value of the PC, mode independently.             *
\***************************************************************************/

ARMword ARMul_GetPC(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15]) ;
 else
    return(R15PC) ;
}

/***************************************************************************\
* This routine returns the value of the PC, mode independently.             *
\***************************************************************************/

ARMword ARMul_GetNextPC(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15] + 4) ;
 else
    return((state->Reg[15] + 4) & R15PCBITS) ;
}

/***************************************************************************\
* This routine sets the value of the PC.                                    *
\***************************************************************************/

void ARMul_SetPC(ARMul_State *state, ARMword value)
{if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS ;
 else
    state->Reg[15] = value & R15PCBITS ;
 FLUSHPIPE ;
#ifdef CYCLEBASED
 state->addrBus = PC ;
 state->NbwSig = HIGH ;
 state->NrwSig = LOW ;
 state->doutenSig = LOW ;
 NCYCLE ;
 state->NopcSig = LOW ;
 state->NextCycle = DESTPC2 ;
#endif
}

/***************************************************************************\
* This routine returns the value of register 15, mode independently.        *
\***************************************************************************/

ARMword ARMul_GetR15(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15]) ;
 else
    return(R15PC | ECC | ER15INT | EMODE) ;
}

/***************************************************************************\
* This routine sets the value of Register 15.                               *
\***************************************************************************/

void ARMul_SetR15(ARMul_State *state, ARMword value)
{
 if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS ;
 else {
    state->Reg[15] = value ;
    ARMul_R15Altered(state) ;
    state->Reg[15] = value & PCBITS ;
    }
 FLUSHPIPE ;
#ifdef CYCLEBASED
 state->addrBus = ARMul_GetPC(state) ;
 state->NbwSig = HIGH ;
 state->NrwSig = LOW ;
 state->doutenSig = LOW ;
 NCYCLE ;
 state->NopcSig = LOW ;
 state->NextCycle = DESTPC2 ;
#endif
}

/***************************************************************************\
* This routine returns the value of the CPSR                                *
\***************************************************************************/

ARMword ARMul_GetCPSR(ARMul_State *state)
{
 return(CPSR) ;
 }

/***************************************************************************\
* This routine sets the value of the CPSR                                   *
\***************************************************************************/

void ARMul_SetCPSR(ARMul_State *state, ARMword value)
{state->Cpsr = CPSR ;
 SETPSR(state->Cpsr,value) ;
 ARMul_CPSRAltered(state) ;
 }

/***************************************************************************\
* This routine does all the nasty bits involved in a write to the CPSR,     *
* including updating the register bank, given a MSR instruction.                    *
\***************************************************************************/

void ARMul_FixCPSR(ARMul_State *state, ARMword instr, ARMword rhs)
{state->Cpsr = CPSR ;
 if (state->Bank==USERBANK) { /* Only write flags in user mode */
    if (BIT(19)) {
       SETCC(state->Cpsr,rhs) ;
       }
    }
 else { /* Not a user mode */
    if (BIT(16) && BIT(19)) SETPSR(state->Cpsr,rhs) ;
    else if (BIT(16)) SETINTMODE(state->Cpsr,rhs) ;
    else if (BIT(19)) SETCC(state->Cpsr,rhs) ;
    }
 ARMul_CPSRAltered(state) ;
 }

/***************************************************************************\
* Get an SPSR from the specified mode                                       *
\***************************************************************************/

ARMword ARMul_GetSPSR(ARMul_State *state, ARMword mode)
{ARMword bank = ModeToBank(state,mode & MODEBITS) ;
 if (bank == USERBANK || bank == DUMMYBANK)
    return(CPSR) ;
 else
    return(state->Spsr[bank]) ;
}

/***************************************************************************\
* This routine does a write to an SPSR                                      *
\***************************************************************************/

void ARMul_SetSPSR(ARMul_State *state, ARMword mode, ARMword value)
{ARMword bank = ModeToBank(state,mode & MODEBITS) ;
 if (bank != USERBANK && bank !=DUMMYBANK)
    state->Spsr[bank] = value ;
}

/***************************************************************************\
* This routine does a write to the current SPSR, given an MSR instruction   *
\***************************************************************************/

void ARMul_FixSPSR(ARMul_State *state, ARMword instr, ARMword rhs)
{if (state->Bank != USERBANK && state->Bank !=DUMMYBANK) {
    if (BIT(16) && BIT(19)) SETPSR(state->Spsr[state->Bank],rhs) ;
    else if (BIT(16)) SETINTMODE(state->Spsr[state->Bank],rhs) ;
    else if (BIT(19)) SETCC(state->Spsr[state->Bank],rhs) ;
    }
}

/***************************************************************************\
* This routine updates the state of the emulator after the Cpsr has been    *
* changed.  Both the processor flags and register bank are updated.         *
\***************************************************************************/

void ARMul_CPSRAltered(ARMul_State *state)
{ARMword oldmode ;

 if (state->prog32Sig == LOW)
    state->Cpsr &= (CCBITS | INTBITS | R15MODEBITS) ;
 oldmode = state->Mode ;
 if (state->Mode != (state->Cpsr & MODEBITS)) {
    state->Mode = ARMul_SwitchMode(state,state->Mode,state->Cpsr & MODEBITS) ;
    state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#ifdef CYCLEBASED
    state->NmBus = ~state->Mode & MODEBITS ;
#endif
    }

 ASSIGNINT(state->Cpsr & INTBITS) ;
 ASSIGNN((state->Cpsr & NBIT) != 0) ;
 ASSIGNZ((state->Cpsr & ZBIT) != 0) ;
 ASSIGNC((state->Cpsr & CBIT) != 0) ;
 ASSIGNV((state->Cpsr & VBIT) != 0) ;

 if ((oldmode & MODEBIT) != (state->Mode & MODEBIT))
    state->Emulate=CHANGEMODE ;
 if (state->Mode <= SVC26MODE)
    state->Reg[15] = PC ;
}

/***************************************************************************\
* This routine updates the state of the emulator after register 15 has      *
* been changed.  Both the processor flags and register bank are updated.    *
* This routine should only be called from a 26 bit mode.                    *
\***************************************************************************/

void ARMul_R15Altered(ARMul_State *state)
{
 if (state->Mode != R15MODE) {
    state->Mode = ARMul_SwitchMode(state,state->Mode,R15MODE) ;
    state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#ifdef CYCLEBASED
    state->NmBus = ~state->Mode & MODEBITS ;
#endif
    }
 if (state->Mode > SVC26MODE)
    state->Emulate = CHANGEMODE ;
 ASSIGNR15INT(R15INT) ;
 ASSIGNN((state->Reg[15] & NBIT) != 0) ;
 ASSIGNZ((state->Reg[15] & ZBIT) != 0) ;
 ASSIGNC((state->Reg[15] & CBIT) != 0) ;
 ASSIGNV((state->Reg[15] & VBIT) != 0) ;
 state->Reg[15] = PC ;
}

/***************************************************************************\
* This routine controls the saving and restoring of registers across mode   *
* changes.  The regbank matrix is largely unused, only rows 13 and 14 are   *
* used across all modes, 8 to 14 are used for FIQ, all others use the USER  *
* column.  It's easier this way.  old and new parameter are modes numbers.  *
* Notice the side effect of changing the Bank variable.                     *
\***************************************************************************/

ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode)
{unsigned i ;
 ARMword oldbank = ModeToBank(state, oldmode);

 state->Bank = ModeToBank(state,newmode) ;
 if (oldbank != state->Bank) { /* really need to do it */
    switch (oldbank) { /* save away the old registers */
       case USERBANK  :
       case IRQBANK   :
       case SVCBANK   :
       case ABORTBANK :
       case UNDEFBANK : if (state->Bank == FIQBANK)
                           for (i = 8 ; i < 13 ; i++)
                              state->RegBank[USERBANK][i] = state->Reg[i] ;
                        state->RegBank[oldbank][13] = state->Reg[13] ;
                        state->RegBank[oldbank][14] = state->Reg[14] ;
                        break ;
       case FIQBANK   : for (i = 8 ; i < 15 ; i++)
                           state->RegBank[FIQBANK][i] = state->Reg[i] ;
                        break ;
       case DUMMYBANK : for (i = 8 ; i < 15 ; i++)
                           state->RegBank[DUMMYBANK][i] = 0 ;
                        break ;

       }
    switch (state->Bank) { /* restore the new registers */
       case USERBANK  :
       case IRQBANK   :
       case SVCBANK   :
       case ABORTBANK :
       case UNDEFBANK : if (oldbank == FIQBANK)
                           for (i = 8 ; i < 13 ; i++)
                              state->Reg[i] = state->RegBank[USERBANK][i] ;
                        state->Reg[13] = state->RegBank[state->Bank][13] ;
                        state->Reg[14] = state->RegBank[state->Bank][14] ;
                        break ;
       case FIQBANK  : for (i = 8 ; i < 15 ; i++)
                           state->Reg[i] = state->RegBank[FIQBANK][i] ;
                        break ;
       case DUMMYBANK : for (i = 8 ; i < 15 ; i++)
                           state->Reg[i] = 0 ;
                        break ;
       } /* switch */
    } /* if */

 state->ModeChange(state, oldmode, newmode);

 return(newmode) ;
}

/***************************************************************************\
* Given a processor mode, this routine returns the register bank that       *
* will be accessed in that mode.                                            *
\***************************************************************************/

static ARMword ModeToBank(ARMul_State *state, ARMword mode)
{static ARMword bankofmode[] = {USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, ABORTBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK
                                } ;

 if (mode > UNDEF32MODE)
    return(DUMMYBANK) ;
 else
    return(bankofmode[mode]) ;
 }

/***************************************************************************\
* Returns the register number of the nth register in a reg list.            *
\***************************************************************************/

unsigned ARMul_NthReg(ARMword instr, unsigned number)
{unsigned bit, upto ;

 for (bit = 0, upto = 0 ; upto <= number ; bit++)
    if (BIT(bit)) upto++ ;
 return(bit - 1) ;
}

/***************************************************************************\
* Assigns the N and Z flags depending on the value of result                *
\***************************************************************************/

void ARMul_NegZero(ARMul_State *state, ARMword result)
{
 if (NEG(result)) { SETN ; CLEARZ ; }
 else if (result == 0) { CLEARN ; SETZ ; }
 else { CLEARN ; CLEARZ ; } ;
 }

/***************************************************************************\
* This function does the work of generating the addresses used in an        *
* LDC instruction.  The code here is always post-indexed, it's up to the    *
* caller to get the input address correct and to handle base register       *
* modification. It also handles the Busy-Waiting.                           *
\***************************************************************************/

void ARMul_LDC(ARMul_State *state,ARMword instr,ARMword address)
{unsigned cpab ;
 ARMword data ;

 UNDEF_LSCPCBaseWb ;
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 state->NextaddrBus = address ;
 state->addr01Bus = 0 ;
 state->NextNrwSig = LOW ;
 state->NextNopcSig = HIGH ;
 state->NextNmreqSig = LOW ;
 state->NextseqSig = LOW ;
 state->LastCycle = LDC1 ;
 return ;
#else /* INSTRBASED */
 cpab = (state->LDC[CPNum])(state,ARMul_FIRST,instr,0) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->LDC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->LDC[CPNum])(state,ARMul_BUSY,instr,0) ;
    }
 if (cpab == ARMul_CANT) {
    CPTAKEABORT ;
    return ;
    }
 cpab = (state->LDC[CPNum])(state,ARMul_TRANSFER,instr,0) ;
 data = ARMul_LoadWordN(state,address) ;
 BUSUSEDINCPCN ;
 if (BIT(21))
    LSBase = state->Base ;
 cpab = (state->LDC[CPNum])(state,ARMul_DATA,instr,data) ;
 while (cpab == ARMul_INC) {
    address += 4 ;
    data = ARMul_LoadWordN(state,address) ;
    cpab = (state->LDC[CPNum])(state,ARMul_DATA,instr,data) ;
    }
 if (state->abortSig || state->Aborted) {
    TAKEABORT ;
    }
#endif
 }

/***************************************************************************\
* This function does the work of generating the addresses used in an        *
* STC instruction.  The code here is always post-indexed, it's up to the    *
* caller to get the input address correct and to handle base register       *
* modification. It also handles the Busy-Waiting.                           *
\***************************************************************************/

void ARMul_STC(ARMul_State *state,ARMword instr,ARMword address)
{unsigned cpab ;
 ARMword data ;

 UNDEF_LSCPCBaseWb ;
 if (ADDREXCEPT(address) || VECTORACCESS(address)) {
    INTERNALABORT(address) ;
    }
#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 NCYCLE ;
 state->NextaddrBus = address ;
 state->Temp = address ;
 state->addr01Bus = 0 ;
 if (!state->Aborted)
    state->NextNrwSig = HIGH ;
 state->NextNopcSig = HIGH ;
 state->NextNmreqSig = LOW ; /* NCYCLE */
 state->NextseqSig = LOW ;
 state->LastCycle = STC1 ;
 return ;
#else /* INSTRBASED */
 cpab = (state->STC[CPNum])(state,ARMul_FIRST,instr,&data) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->STC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->STC[CPNum])(state,ARMul_BUSY,instr,&data) ;
    }
 if (cpab == ARMul_CANT) {
    CPTAKEABORT ;
    return ;
    }
#ifndef MODE32
 if (ADDREXCEPT(address) || VECTORACCESS(address)) {
    INTERNALABORT(address) ;
    }
#endif
 BUSUSEDINCPCN ;
 if (BIT(21))
    LSBase = state->Base ;
 cpab = (state->STC[CPNum])(state,ARMul_DATA,instr,&data) ;
 ARMul_StoreWordN(state,address,data) ;
 while (cpab == ARMul_INC) {
    address += 4 ;
    cpab = (state->STC[CPNum])(state,ARMul_DATA,instr,&data) ;
    ARMul_StoreWordN(state,address,data) ;
    }
 if (state->abortSig || state->Aborted) {
    TAKEABORT ;
    }
#endif
 }

/***************************************************************************\
*        This function does the Busy-Waiting for an MCR instruction.        *
\***************************************************************************/

void ARMul_MCR(ARMul_State *state,ARMword instr, ARMword source)
{unsigned cpab ;

#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 state->NextaddrBus = ARMul_GetNextPC(state) | state->addr01Bus ;
 state->NextNrwSig = HIGH ;
 state->NextNopcSig = HIGH ;
 state->NextNmreqSig = HIGH ; /* CCYCLE */
 state->NextseqSig = HIGH ;
 state->Temp = source ;
 state->LastCycle = MCR1 ;
 return ;
#else
 cpab = (state->MCR[CPNum])(state,ARMul_FIRST,instr,source) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->MCR[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->MCR[CPNum])(state,ARMul_BUSY,instr,source) ;
    }
 if (cpab == ARMul_CANT)
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
 else {
    BUSUSEDINCPCN ;
    ARMul_Ccycles(state,1,0) ;
    }
#endif
 }

/***************************************************************************\
*        This function does the Busy-Waiting for an MRC instruction.        *
\***************************************************************************/

ARMword ARMul_MRC(ARMul_State *state,ARMword instr)
{unsigned cpab ;
 ARMword result = 0 ;

#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 state->NextaddrBus = ARMul_GetNextPC(state) | state->addr01Bus ;
 state->NextNrwSig = LOW ;
 state->NextNopcSig = HIGH ;
 state->NextNmreqSig = HIGH ; /* CCYCLE */
 state->NextseqSig = HIGH ;
 state->LastCycle = MRC1 ;
 return(0) ;
#else
 cpab = (state->MRC[CPNum])(state,ARMul_FIRST,instr,&result) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->MRC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return(0) ;
       }
    else
       cpab = (state->MRC[CPNum])(state,ARMul_BUSY,instr,&result) ;
    }
 if (cpab == ARMul_CANT) {
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
    result = ECC ; /* Parent will destroy the flags otherwise */
    }
 else {
    BUSUSEDINCPCN ;
    ARMul_Ccycles(state,1,0) ;
    ARMul_Icycles(state,1,0) ;
    }
 return(result) ;
#endif
}

/***************************************************************************\
*        This function does the Busy-Waiting for an CDP instruction.        *
\***************************************************************************/

void ARMul_CDP(ARMul_State *state,ARMword instr)
{unsigned cpab ;

#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 NCYCLE ;
 state->NextaddrBus = ARMul_GetNextPC(state) | state->addr01Bus ;
 state->NextNrwSig = LOW ;
 state->NextNopcSig = LOW ;
 state->NextNmreqSig = LOW ; /* NCYCLE */
 state->NextseqSig = LOW ;
 state->LastCycle = CDP1 ;
 return ;
#else
 cpab = (state->CDP[CPNum])(state,ARMul_FIRST,instr) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->CDP[CPNum])(state,ARMul_INTERRUPT,instr) ;
       return ;
       }
    else
       cpab = (state->CDP[CPNum])(state,ARMul_BUSY,instr) ;
    }
 if (cpab == ARMul_CANT)
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
 else
    BUSUSEDN ;
#endif
}

/***************************************************************************\
*      This function handles Undefined instructions, as CP isntruction      *
\***************************************************************************/

void ARMul_UndefInstr(ARMul_State *state,ARMword instr)
{
#ifdef CYCLEBASED
 state->PrevaddrBus = state->addrBus ;
 state->NcpiSig = LOW ;
 state->LSCActive = FALSE ;
 state->NextaddrBus = ARMul_GetNextPC(state) ;
 state->NextNrwSig = LOW ;
 state->NextNopcSig = LOW ;
 state->NextNmreqSig = LOW ; /* NCYCLE */
 state->NextseqSig = LOW ;
 state->addr01Bus = 0 ;
 state->LastCycle = UNDEF ;
#else
 ARMul_Abort(state,ARMul_UndefinedInstrV) ;
#endif
}

#ifdef CYCLEBASED

/***************************************************************************\
* Monitor the CPA and CPB signals and decided which is the next state       *
* from the current one.                                                     *
\***************************************************************************/

unsigned CoProNextState(ARMul_State *state, unsigned ready, unsigned busy)
{if (state->cpaSig) {
    if (state->cpbSig) { /* Undefined Instruction */
       state->NcpiSig = HIGH ;
       if (!IntPending(state))
          ARMul_Abort(state,ARMul_UndefinedInstrV) ;
       return(DESTPC1) ;
       }
    else { /* Illegal state */
       state->NcpiSig = HIGH ;
       UNDEF_CoProHS ;
       ARMul_Abort(state,ARMul_ResetV) ;
       return(DESTPC1) ;
       }
    }
 else {
    if (state->cpbSig) { /* Busy wait */
       if (IntPending(state))
          return(DESTPC1) ;
       else /* busy wait */
          return(busy) ;
       }
    else { /* Normal */
       state->NcpiSig = HIGH ;
       return(ready) ;
       }
    }
}

#endif

/***************************************************************************\
*           Return TRUE if an interrupt is pending, FALSE otherwise.        *
\***************************************************************************/

unsigned IntPending(ARMul_State *state)
{
#ifdef CYCLEBASED
 if ((state->Inted & 3) < 3) {
    if (!(state->Inted & 1))
       ARMul_Abort(state,ARMul_FIQV) ;
    else
       ARMul_Abort(state,ARMul_IRQV) ;
    state->NcpiSig = HIGH ;
    NCYCLE ;
    return(TRUE) ;
    }
 return(FALSE) ;
#else
 if (state->Exception) { /* Any exceptions */
    if (state->NresetSig == LOW) {
       ARMul_Abort(state,ARMul_ResetV) ;
       return(TRUE) ;
       }
    else if (!state->NfiqSig && !FFLAG) {
       ARMul_Abort(state,ARMul_FIQV) ;
       return(TRUE) ;
       }
    else if (!state->NirqSig && !IFLAG) {
       ARMul_Abort(state,ARMul_IRQV) ;
       return(TRUE) ;
       }
    }
 return(FALSE) ;
#endif
 }

/***************************************************************************\
*               Align a word access to a non word boundary                  *
\***************************************************************************/

ARMword ARMul_Align(ARMul_State *state, ARMword address, ARMword data)
{/* this code assumes the address is really unaligned,
    as a shift by 32 is undefined in C */

 address = (address & 3) << 3 ; /* get the word address */
 return( ( data >> address) | (data << (32 - address)) ) ; /* rot right */
}

/***************************************************************************\
* This routine is used to call another routine after a certain number of    *
* cycles have been executed. The first parameter is the number of cycles    *
* delay before the function is called, the second argument is a pointer     *
* to the function. A delay of zero doesn't work, just call the function.    *
\***************************************************************************/

void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay, unsigned (*what)())
{unsigned long when ;
 struct EventNode *event ;

 if (state->EventSet++ == 0)
    state->Now = ARMul_Time(state) ;
 when = (state->Now + delay) % EVENTLISTSIZE ;
 event = (struct EventNode *)malloc(sizeof(struct EventNode)) ;
 event->func = what ;
 event->next = *(state->EventPtr + when) ;
 *(state->EventPtr + when) = event ;
}

/***************************************************************************\
* This routine is called at the beginning of every cycle, to envoke         *
* scheduled events.                                                         *
\***************************************************************************/

void ARMul_EnvokeEvent(ARMul_State *state)
{static unsigned long then ;

 then = state->Now ;
 state->Now = ARMul_Time(state) % EVENTLISTSIZE ;
 if (then < state->Now) /* schedule events */
    EnvokeList(state,then,state->Now) ;
 else if (then > state->Now) { /* need to wrap around the list */
    EnvokeList(state,then,EVENTLISTSIZE-1L) ;
    EnvokeList(state,0L,state->Now) ;
    }
 }

static void EnvokeList(ARMul_State *state, unsigned long from, unsigned long to)
/* envokes all the entries in a range */
{struct EventNode *anevent ;

 for (; from <= to ; from++) {
    anevent = *(state->EventPtr + from) ;
    while (anevent) {
       (anevent->func)(state) ;
       state->EventSet-- ;
       anevent = anevent->next ;
       }
    *(state->EventPtr + from) = NULL ;
    }
 }

/***************************************************************************\
* This routine is returns the number of clock ticks since the last reset.   *
\***************************************************************************/

unsigned long ARMul_Time(ARMul_State *state)
{return(state->NumScycles + state->NumNcycles +
        state->NumIcycles + state->NumCcycles + state->NumFcycles) ;
}

#ifdef CYCLEBASED

/***************************************************************************\
* This routine is returns the number of clock ticks since the last reset.   *
\***************************************************************************/

char *ARMul_ErrorMess(ARMul_State *state,unsigned number)
{
 switch (number) {
    case UNDEFNUM_Test :
       return("TST,TEQ,CMP,CMN operation without P bit set") ;
    case UNDEFNUM_Shift :
       return("Register shift with bit 7 set in the opcode") ;
    case UNDEFNUM_MSRPC :
       return("MSR instruction transferring from the PC") ;
    case UNDEFNUM_MRSPC :
       return("MRS instruction transferring to the PC") ;
    case UNDEFNUM_MULPCDest :
       return("MUL with Rd=PC or MULL with any register=PC");
    case UNDEFNUM_MULDestEQOp1 :
       return("MUL with Rd=Rm or MULL with RdHi=RdLo");
    case UNDEFNUM_ReservedMult :
       return("Multiply instruction with reserved flags pattern");
    case UNDEFNUM_LSRBPC :
       return("Loading or Storing a byte to/from the PC is undefined") ;
    case UNDEFNUM_LSRBaseEQOffWb :
       return("Load or Store with writeback, same register used for the base and the offset") ;
    case UNDEFNUM_LSRBaseEQDestWb :
       return("Load or Store with writeback, same register used for the base and the destination") ;
    case UNDEFNUM_LSRPCBaseWb :
       return("Load or Store, PC relative with writeback") ;
    case UNDEFNUM_LSRPCOffWb :
       return("Load or Store, PC as the offset with writeback") ;
    case UNDEFNUM_LSMNoRegs :
       return("No registers specified in the register list") ;
    case UNDEFNUM_LSMPCBase :
       return("Load or Store Multiple, PC relative") ;
    case UNDEFNUM_LSMUserBankWb :
       return("Load or Store Multiple, forced user bank with writeback") ;
    case UNDEFNUM_LSMBaseInListWb :
       return("Load or Store Multiple, base register in the register list") ;
    case UNDEFNUM_SWPPC :
       return("PC specified in a SWP instruction") ;
    case UNDEFNUM_CoProHS :
       return("Illegal Coprocessor Handshake") ;
    case UNDEFNUM_MCRPC :
       return("PC specified in an MCR instruction") ;
    case UNDEFNUM_LSCPCBaseWb :
       return("Load or Store Coprocessor, PC relative with writeback") ;
    case UNDEFNUM_UndefNotBounced :
       return("Undefined instruction not bounced") ;
    case UNDEFNUM_IllegalMode :
       return("Undefined processor mode entered") ;
    case UNDEFNUM_Prog32SigChange :
       return("Prog32 pulled low when processor in a 32 bit mode") ;
    case UNDEFNUM_Data32SigChange :
       return("Data32 pulled low when processor in a 32 bit mode") ;
    default :
       return("No Error") ;
    }
 }

#endif

/***************************************************************************\
* This routine causes an Abort to occur, including selecting the correct    *
* mode, register bank, and the saving of registers.  Call with the          *
* appropriate vector's memory address (0,4,8 ....)                          *
\***************************************************************************/

void ARMul_Abort(ARMul_State *state, ARMword vector)
{ARMword temp ;
 int nexus = state->NextInstr;
 state->Aborted = FALSE ;

#ifdef CYCLEBASED
 state->addr01Bus = 0 ;
 state->NexecSig = 0 ;
#else
 if (state->clearAborts) state->abortSig=LOW;
#endif
 if (ARMul_OSException(state,vector,ARMul_GetPC(state)))
    return ;

 if (state->prog32Sig)
    if (ARMul_MODE26BIT)
       temp = R15PC ;
    else
       temp = state->Reg[15] ;
 else
    temp = R15PC | ECC | ER15INT | EMODE ;

 switch (vector) {
    case ARMul_ResetV : /* RESET */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(INTBITS,state->prog32Sig?SVC32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp ;
       break ;
    case ARMul_UndefinedInstrV : /* Undefined Instruction */
       state->Spsr[state->prog32Sig?UNDEFBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?UNDEF32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_SWIV : /* Software Interrupt */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?SVC32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_PrefetchAbortV : /* Prefetch Abort */
       state->AbortAddr = 1 ;
       state->Spsr[state->prog32Sig?ABORTBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?ABORT32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_DataAbortV : /* Data Abort */
       state->Spsr[state->prog32Sig?ABORTBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?ABORT32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ; /* the PC must have been incremented */
       break ;
    case ARMul_AddrExceptnV : /* Address Exception */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?SVC32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_IRQV : /* IRQ */
       state->Spsr[IRQBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?IRQ32MODE:IRQ26MODE) ;
       ARMul_CPSRAltered(state) ;
       //if (nexus<PRIMEPIPE)
         state->Reg[14] = temp -4;
       //else
       //  state->Reg[14] = temp - 8;
       break ;
    case ARMul_FIQV : /* FIQ */
       state->Spsr[FIQBANK] = CPSR ;
       SETABORT(INTBITS,state->prog32Sig?FIQ32MODE:FIQ26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    }
 ARMul_SetPC(state,vector) ;
#ifdef CYCLEBASED
 state->NextCycle = DESTPC2 ;
#endif
}

