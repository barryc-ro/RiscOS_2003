/***************************************************************************\
* armemu.c                                                                  *
* ARMulator II main source code.                                            *
* Copyright (C) 1991 Advanced RISC Machines Limited.  All rights reserved.  *
* ARMulator II is an ARM6/7 instruction set emulator.                       *
* It is cycle accurate, instruction or cycle based.                         *
* Written by Dave Jaggar.                                                   *
\***************************************************************************/

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#define MODE32 1

#include "armdefs.h"
#include "armemu.h"

static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr) ;
static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr) ;
static void WriteR15(ARMul_State *state, ARMword src) ;
static void WriteSR15(ARMul_State *state, ARMword src) ;
static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr) ;
static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address) ;
static void LoadMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void StoreMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void LoadSMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void StoreSMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
#ifdef CYCLEBASED
static void LoadMultSetup(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void StoreMultSetup(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
#endif

/***************************************************************************\
*                            MULTIPLY routines                             *
\***************************************************************************/

/* These routines each return the number of I-cycles they will have
 * taken to execute.
 */

static int Mult32(ARMul_State *state, ARMword instr) {
/* Calculates a 32-bit result, from two operands.
 */
  ARMword Rm = state->Reg[MULRHSReg];
  if (MULLHSReg == MULDESTReg) {
    UNDEF_MULDestEQOp1;
    state->Reg[MULDESTReg] = 0;
    if (MULsetbit) {
      CLEARN;
      SETZ;
    }
  }else if (MULDESTReg==15 || MULLHSReg==15 || MULRHSReg==15
            || (MULaccbit && MULACCReg==15)) {
    UNDEF_MULPCDest;
  }else{
    ARMword Rd = state->Reg[MULLHSReg] * Rm
                   + (MULaccbit ? state->Reg[MULACCReg] : 0);
    if (MULsetbit) {
      ARMul_NegZero(state,Rd);
    }
    state->Reg[MULDESTReg] = Rd;
  }

  if (!(state->Processor & ARM_Mult64_Prop)) {
    int bits=0;
    if (Rm>>16) bits+=16,Rm>>=16;
    if (Rm>>8) bits+=8,Rm>>=8;
    if (Rm>>4) bits+=4,Rm>>=4;
    if (Rm>>2) bits+=2,Rm>>=2;
    if (Rm>>1) bits+=1,Rm>>=1;
    return ARMul_MultTable[bits];
  }else {
    if (Rm>>31) Rm=~Rm; /* Get the positive version of Rm */
    return (Rm>=0x100000 ? 4 : Rm>=0x10000 ? 3 : Rm>=0x100 ? 2 : 1) + MULaccbit;
  }
}

static int MultRes(ARMul_State *state, ARMword instr) {
  UNDEF_ReservedMult;
  return 1;
}

static int Mult64(ARMul_State *state, ARMword instr) {
/* Calculates a 64-bit result, from two operands.
 */
  ARMword Rn, Rm, ALo, AHi;
  ARMword RnLo, RmLo, RnHi, RmHi;
  ARMword LL, LH, HL, HH; /* Intermediate multiplies */
  ARMword C1, C2, C3; /* Carries */
  ARMword R1, R2; /* Intermediate summations */

  if (!(state->Processor & ARM_Mult64_Prop)) {
    UNDEF_ReservedMult;
    return 1;
  }

  /* Work out Rm here so it can be used for timings calculations even if
   * the instruction is illegal
   */
  Rm = state->Reg[MULRHSReg];

  if (MULLOReg==15 || MULHIReg==15 || MULLHSReg==15 || MULRHSReg==15) {
    UNDEF_MULPCDest;
  }else{
    if (MULLOReg==MULHIReg) {
      UNDEF_MULDestEQOp1;
    }

    if (MULaccbit) {
      ALo = state->Reg[MULLOReg];
      AHi = state->Reg[MULHIReg];
    }else{
      ALo = AHi = 0;
    }

    Rn = state->Reg[MULLHSReg];

    RnHi=(Rn>>16); RmHi=(Rm>>16);
    RnLo=Rn-(RnHi<<16); RmLo=Rm-(RmHi<<16);

    /* Extract the four sub-products */
    LL=RnLo*RmLo; LH=RnLo*RmHi; HL=RnHi*RmLo; HH=RnHi*RmHi;

    /* Calculate the carry into bits 32,33 from the low word. This is tricky
     * without a carry flag to use!
     *
     * Observe that, for A+B, there is a single-bit carry into bit 31,
     * and a single bit carry out. The carry in is Result(31) ^ A(31) ^ B(31),
     * since the low-order bit of an addition is the XOR of the summed bits.
     *
     * Thus:
     */

#define Add33(C,R,A,B) \
 ( (R)=(A)+(B), (C)=(((A)>>31) + ((B)>>31) + (((A)>>31)^((B)>>31)^((R)>>31)))>>1 )

    /*
     * Now regard A+B+C+D as (A+B)+(C+D). This is three simple binary
     * additions, each of which can generate a carry bit.
     */

    Add33(C1, R1, ALo, LL);
    Add33(C2, R2, LH<<16, HL<<16);
    Add33(C3, state->Reg[MULLOReg], R1, R2);

#undef Add33

    /* Forumulate the high word */
    state->Reg[MULHIReg] = AHi + (LH>>16) + (HL>>16) + HH + C1+C2+C3
                         - (MULsigbit ? (NEG(Rn)?Rm:0) + (NEG(Rm)?Rn:0) : 0);

    if (MULsetbit) ARMul_NegZero(state, state->Reg[MULHIReg]);
  }

  if (Rm>>31 && MULsigbit) Rm=~Rm; /* Get the positive version of Rm */
  return (Rm>=0x100000 ? 4 : Rm>=0x10000 ? 3 : Rm>=0x100 ? 2 : 1) + MULaccbit;
}

/***************************************************************************\
*                             EMULATION of ARM6                             *
\***************************************************************************/

#ifdef MODE32
ARMword ARMul_Emulate32(register ARMul_State *state)
{
#else
ARMword ARMul_Emulate26(register ARMul_State *state)
{
#endif
 register ARMword instr, /* the current instruction */
                 dest, /* almost the DestBus */
                 temp, /* ubiquitous third hand */
                 pc ; /* the address of the current instruction */
 ARMword lhs, rhs ; /* almost the ABus and BBus */
 ARMword decoded, loaded ; /* instruction pipeline */

/***************************************************************************\
*                        Execute the next instruction                       *
\***************************************************************************/

#ifdef CYCLEBASED

 instr = state->instr ;
 decoded = state->decoded ;
 loaded = state->loaded ;
 pc = state->pc ;
 temp = state->temp ;

#if 0
 if (state->EventSet)
    ARMul_EnvokeEvent(state) ;
#endif

#ifdef MODE32
 UNDEF_Prog32SigChange ;
 UNDEF_Data32SigChange ;
#endif

 if (state->NresetSig == LOW) {
    if (state->Reseted) {
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       state->NopcSig = LOW ;
       state->lockSig = LOW ;
       SCYCLE ;
       state->NcpiSig = HIGH ;
       state->doutenSig = LOW ;
       state->LSCActive = FALSE ;
       state->NextCycle = RESET1 ;
       state->NexecSig = 1 ;
       }
    else
       state->Reseted = TRUE ;
    }
 else {
    switch (state->LastCycle) {
       case NEWINSTR :
       case DESTPC3 :
          PREFETCH(loaded,pc+8) ;
          break ;

       case STR2 :
       case STRB2 :
          state->doutenSig = LOW ;
          if (state->abortSig || state->Aborted) {
             if (!state->lateabtSig)
                LSBase = state->OldBase ;
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
             if (state->Processor & ARM_Abort7_Prop)
                state->NextCycle = KILLNEXT ;
             else
                state->NextCycle = ABORT1 ;
             }
          break ;

       case STM3 :
          state->doutenSig = LOW ;
          if (state->abortSig || state->Aborted) {
             if (state->Processor & ARM_Abort7_Prop &&
               ((state->Aborted != ARMul_DataAbortV && state->abortSig) ||
                (state->Aborted == ARMul_AddrExceptnV && (LSMNumRegs / 4) == 1)))
                state->NextCycle = KILLNEXT ;
             else
                state->NextCycle = ABORT1 ;
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
             }
          break ;

       case UNDEF :
          PREFETCH(loaded,pc+8) ;
          if (!IntPending(state)) {
             if (!state->cpaSig || !state->cpbSig) {
                UNDEF_UndefNotBounced ;
                }
             state->NcpiSig = HIGH ;
             ARMul_Abort(state,ARMul_UndefinedInstrV) ;
             }
          state->NextCycle = DESTPC1 ;
          break ;

       case LDC1 :
          PREFETCH(loaded,pc+8) ;
       case LDCBUSY :
          state->NextCycle = CoProNextState(state,LDC2,LDCBUSY) ;
          if (state->NextCycle == LDC2) {
             BUSUSEDINCPCN ;
             if (BIT(21))
                LSBase = state->Base ;
             }
          break ;

       case LDC2 :
          if (state->cpaSig == HIGH && state->cpbSig == HIGH) {
             state->LSCActive = FALSE ;
             if (state->abortSig || state->Aborted) {
                state->NextCycle = ABORT1 ;
                }
             else
                state->NextCycle = NEWINSTR ;
             }
          else
             if (state->abortSig && !state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
          break ;

       case STC1 :
          PREFETCH(loaded,pc+8) ;
       case STCBUSY :
          state->NextCycle = CoProNextState(state,STC2,STCBUSY) ;
          if (state->NextCycle == STC2) {
             BUSUSEDINCPCN ;
             if (BIT(21))
                LSBase = state->Base ;
             }
          break ;

       case STC2 :
       case STC3 :
          if (state->cpaSig == HIGH && state->cpbSig == HIGH) {
             if (state->abortSig || state->Aborted) {
                if (state->Processor & ARM_Abort7_Prop &&
                  ((state->Aborted != ARMul_DataAbortV && state->abortSig) ||
                   (state->Aborted == ARMul_AddrExceptnV && state->LastCycle == STC2)))
                   state->NextCycle = KILLNEXT ;
                else
                   state->NextCycle = ABORT1 ;
                }
             else
                state->NextCycle = NEWINSTR ;
             state->LSCActive = FALSE ;
             state->doutenSig = LOW ;
             }
          else
             if (state->abortSig && !state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
          break ;

       case MCR1 :
          PREFETCH(loaded,pc+8) ;
       case MCRBUSY :
          state->NextCycle = CoProNextState(state,MCR2,MCRBUSY) ;
          if (state->NextCycle == MCR2) {
             BUSUSEDINCPCN ;
             }
          break ;

       case MCR2 :
          state->doutenSig = LOW ;
          break ;

       case MRC1 :
          PREFETCH(loaded,pc+8) ;
       case MRCBUSY :
          state->NextCycle = CoProNextState(state,MRC2,MRCBUSY) ;
          if (state->NextCycle == MRC2) {
             BUSUSEDINCPCN ;
             }
          break ;

       case CDP1 :
          PREFETCH(loaded,pc+8) ;
       case CDPBUSY :
          state->NextCycle = CoProNextState(state,NEWINSTR,CDPBUSY) ;
          if (state->NextCycle == NEWINSTR) {
             BUSUSEDN ;
             }
          break ;
       }
    }

 state->LastCycle = state->NextCycle ;

 switch (state->NextCycle) { /* In a cycle based world, a new instruction is */
    case NEWINSTR :   /* just an (important) state in a state machine */
          switch (state->NextInstr) {
          case SEQ :
          case NONSEQ :
             state->Reg[15] = state->Reg[15] + 4 ; /* Inc PC, and fall through */

          case PCINCEDSEQ :
          case PCINCEDNONSEQ :
             pc = pc + 4 ; /* Advance the dummy pc */
             instr = decoded ;
             decoded = loaded ;
             break ;

          case RESUME :
#ifdef MODE32
             state->Reg[15] = state->Reg[15] + 8 ;
#else
             state->Reg[15] = (state->Reg[15] + 8) & R15PCBITS ;
#endif
             break ;

          default : /* The program counter has been changed */
             pc = state->Reg[15] ;
#ifdef MODE32
             pc = pc & PCBITS ;
#else
             pc = pc & R15PCBITS ;
#endif
             state->Reg[15] = pc + 8 ;
             instr = decoded ;
             decoded = loaded ;
             break ;

          }
          NORMALCYCLE ;

    if ((state->Inted & 3) < 3) {
       if (!(state->Inted & 1))
          ARMul_Abort(state,ARMul_FIQV) ;
       else
          ARMul_Abort(state,ARMul_IRQV) ;
       break ;
       }

#else /* Instruction based */

 if (state->NextInstr < PRIMEPIPE) {
    decoded = state->decoded ;
    loaded = state->loaded ;
    pc = state->pc ;
    }

 do { /* just keep going */
    switch (state->NextInstr) {
       case SEQ :
          state->Reg[15] += 4 ; /* Advance the pipeline, and an S cycle */
          pc += 4 ;
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrS(state,pc+8) ;
          break ;

       case NONSEQ :
          state->Reg[15] += 4 ; /* Advance the pipeline, and an N cycle */
          pc += 4 ;
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrN(state,pc+8) ;
          NORMALCYCLE ;
          break ;

       case PCINCEDSEQ :
          pc += 4 ; /* Program counter advanced, and an S cycle */
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrS(state,pc+8) ;
          NORMALCYCLE ;
          break ;

       case PCINCEDNONSEQ :
          pc += 4 ; /* Program counter advanced, and an N cycle */
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrN(state,pc+8) ;
          NORMALCYCLE ;
          break ;

       case RESUME : /* The program counter has been changed */
          pc = state->Reg[15] ;
#ifndef MODE32
          pc = pc & R15PCBITS ;
#endif
          state->Reg[15] = pc + 8 ;
          state->AbortAddr = 1 ;
          instr = ARMul_ReadWord(state,pc) ;
          decoded = ARMul_ReadWord(state,pc + 4) ;
          loaded = ARMul_ReadWord(state,pc + 8) ;
          NORMALCYCLE ;
          break ;

       default : /* The program counter has been changed */
          pc = state->Reg[15] ;
#ifndef MODE32
          pc = pc & R15PCBITS ;
#endif
          state->Reg[15] = pc + 8 ;
          state->AbortAddr = 1 ;
          instr = ARMul_LoadInstrN(state,pc) ;
          decoded = ARMul_LoadInstrS(state,pc + 4) ;
          loaded = ARMul_LoadInstrS(state,pc + 8) ;
          NORMALCYCLE ;
          break ;
       }

#if 0
    if (state->EventSet)
       ARMul_EnvokeEvent(state) ;
#endif

    if (state->Exception) { /* Any exceptions */
       if (state->NresetSig == LOW) {
           ARMul_Abort(state,ARMul_ResetV) ;
           break ;
           }
       else if (!state->NfiqSig && !FFLAG) {
           ARMul_Abort(state,ARMul_FIQV) ;
           break ;
           }
       else if (!state->NirqSig && !IFLAG) {
          ARMul_Abort(state,ARMul_IRQV) ;
          break ;
          }
       }

#endif  /* not cycle based */

    if (state->CallDebug > 0) {
       instr = ARMul_Debug(state,pc,instr) ;
       if (state->Emulate < ONCE) {
          state->NextInstr = RESUME ;
          break ;
          }
       if (state->Debug) {
          ARMul_DebugPrint(state, "At %08lx Instr %08lx Mode %02lx\n",pc,instr,state->Mode) ;
          ARMul_DebugPause(state) ;
          }
       }
    else
       if (state->Emulate < ONCE) {
          state->NextInstr = RESUME ;
          break ;
          }

    state->NumInstrs++ ;

/***************************************************************************\
*                       Check the condition codes                           *
\***************************************************************************/
    if ((temp = TOPBITS(28)) == AL)
       goto mainswitch ; /* vile deed in the need for speed */

    switch ((int)TOPBITS(28)) { /* check the condition code */
       case AL : temp=TRUE ;
                 break ;
       case NV : temp=FALSE ;
                 break ;
       case EQ : temp=ZFLAG ;
                 break ;
       case NE : temp=!ZFLAG ;
                 break ;
       case VS : temp=VFLAG ;
                 break ;
       case VC : temp=!VFLAG ;
                 break ;
       case MI : temp=NFLAG ;
                 break ;
       case PL : temp=!NFLAG ;
                 break ;
       case CS : temp=CFLAG ;
                 break ;
       case CC : temp=!CFLAG ;
                 break ;
       case HI : temp=CFLAG && !ZFLAG ;
                 break ;
       case LS : temp=!CFLAG || ZFLAG ;
                 break ;
       case GE : temp=NFLAG == VFLAG ;
                 break ;
       case LT : temp=NFLAG != VFLAG ;
                 break ;
       case GT : temp=(NFLAG == VFLAG) && !ZFLAG ;
                 break ;
       case LE : temp=(NFLAG != VFLAG) || ZFLAG ;
                 break ;
       } /* cc check */

/***************************************************************************\
*               Actual execution of instructions begins here                *
\***************************************************************************/

    if (temp) { /* if the condition codes don't match, stop here */
mainswitch:
#ifdef CYCLEBASED
       state->NexecSig = 0 ;
#endif
       switch ((int)BITS(20,27)) {

/***************************************************************************\
*                 Data Processing Register RHS Instructions                 *
\***************************************************************************/

          case 0x00 : /* AND reg and MUL */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult32(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult32(state, instr), 0L);
#endif
             }else{
                SINGLECYCLEINSTR ;
                rhs = DPRegRHS ;
                dest = LHS & rhs ;
                WRITEDEST(dest) ;
                }
             break ;

          case 0x01 : /* ANDS reg and MULS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult32(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult32(state, instr), 0L);
#endif
             }else{
                SINGLECYCLEINSTR ;
                rhs = DPSRegRHS ;
                dest = LHS & rhs ;
                WRITESDEST(dest) ;
                }
             break ;

          case 0x02 : /* EOR reg and MLA */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult32(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult32(state, instr), 0L);
#endif
             }else{
                SINGLECYCLEINSTR ;
                rhs = DPRegRHS ;
                dest = LHS ^ rhs ;
                WRITEDEST(dest) ;
                }
             break ;

          case 0x03 : /* EORS reg and MLAS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult32(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult32(state, instr), 0L);
#endif
             }else{
                SINGLECYCLEINSTR ;
                rhs = DPSRegRHS ;
                dest = LHS ^ rhs ;
                WRITESDEST(dest) ;
                }
             break ;

          case 0x04 : /* SUB reg and MUL??? */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = MultRes(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,MultRes(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS;
               dest = LHS - rhs ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x05 : /* SUBS reg and MUL??? */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = MultRes(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,MultRes(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = lhs - rhs ;
               if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                 SUBCARRY(lhs,rhs,dest) ;
                 SUBOVERFLOW(lhs,rhs,dest) ;
               }
               else {
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x06 : /* RSB reg and MUL??? */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = MultRes(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,MultRes(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS ;
               dest = rhs - LHS ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x07 : /* RSBS reg */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = MultRes(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,MultRes(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = rhs - lhs ;
               if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                 SUBCARRY(rhs,lhs,dest) ;
                 SUBOVERFLOW(rhs,lhs,dest) ;
               }
               else {
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x08 : /* ADD reg and UMULL */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS ;
               dest = LHS + rhs ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x09 : /* ADDS reg and UMULLS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = lhs + rhs ;
               ASSIGNZ(dest==0) ;
               if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                 ASSIGNN(NEG(dest)) ;
                 ADDCARRY(lhs,rhs,dest) ;
                 ADDOVERFLOW(lhs,rhs,dest) ;
               }
               else {
                 CLEARN ;
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x0a : /* ADC reg and UMLAL */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS ;
               dest = LHS + rhs + CFLAG ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x0b : /* ADCS reg and UMLALS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = lhs + rhs + CFLAG ;
               ASSIGNZ(dest==0) ;
               if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                 ASSIGNN(NEG(dest)) ;
                 ADCCARRY(lhs,rhs,dest) ;
                 ADDOVERFLOW(lhs,rhs,dest) ;
               }
               else {
                 CLEARN ;
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x0c : /* SBC reg and SMULL */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS ;
               dest = LHS - rhs - !CFLAG ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x0d : /* SBCS reg and SMULLS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = lhs - rhs - !CFLAG ;
               if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                 SBCCARRY(lhs,rhs,dest) ;
                 SUBOVERFLOW(lhs,rhs,dest) ;
               }
               else {
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x0e : /* RSC reg and SMLAL */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               rhs = DPRegRHS ;
               dest = rhs - LHS - !CFLAG ;
               WRITEDEST(dest) ;
             }
             break ;

          case 0x0f : /* RSCS reg and SMLALS */
             if (BITS(4,7) == 9) {
#ifdef CYCLEBASED
               state->NumCycles = Mult64(state, instr);
               state->addrBus = PCWRAP(pc + 12);
               state->addr01Bus = 0;
               state->NopcSig = HIGH;
               ICYCLE;
               state->NextCycle = MUL;
#else
               ARMul_Icycles(state,Mult64(state, instr), 0L);
#endif
             }else{
               SINGLECYCLEINSTR ;
               lhs = LHS ;
               rhs = DPRegRHS ;
               dest = rhs - lhs - !CFLAG ;
               if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                 SBCCARRY(rhs,lhs,dest) ;
                 SUBOVERFLOW(rhs,lhs,dest) ;
               }
               else {
                 CLEARC ;
                 CLEARV ;
               }
               WRITESDEST(dest) ;
             }
             break ;

          case 0x10 : /* TST reg and MRS CPSR and SWP word */
             if (BITS(4,11) == 9) { /* SWP */
                UNDEF_SWPPC ;
                temp = LHS ;
                BUSUSEDINCPCS ;
#ifdef CYCLEBASED
                state->lockSig = HIGH ;
                state->addrBus = temp ;
                state->Base = temp ;
                state->addr01Bus = 0 ;
                state->NopcSig = HIGH ;
                NCYCLE ;
#ifndef MODE32
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   }
#endif
                state->NextCycle = SWP2 ;
#else
#ifndef MODE32
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   (void)ARMul_LoadWordN(state,temp) ;
                   (void)ARMul_LoadWordN(state,temp) ;
                   }
                else
#endif
                dest = ARMul_SwapWord(state,temp,state->Reg[RHSReg]) ;
                if (temp & 3)
                    DEST = ARMul_Align(state,temp,dest) ;
                else
                    DEST = dest ;
                if (state->abortSig || state->Aborted) {
                   TAKEABORT ;
                   }
#endif
                }
             else if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS CPSR */
                SINGLECYCLEINSTR ;
                UNDEF_MRSPC ;
                DEST = ECC | EINT | EMODE ;
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x11 : /* TSTP reg */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TSTP reg */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                rhs = DPRegRHS ;
                temp = LHS & rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* TST reg */
                rhs = DPSRegRHS ;
                dest = LHS & rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x12 : /* TEQ reg and MSR reg to CPSR */
             if (BITS(4,7)==7) { /* BKPT */
#ifndef CYCLEBASED
                if (ARMul_OSHandleBKPT(state,(BITS(8,19)<<4)+BITS(0,3))) {
                   SINGLECYCLEINSTR ;
                }
                else
#endif
                   ARMul_Abort(state,ARMul_PrefetchAbortV) ;
                break ;
             }
             SINGLECYCLEINSTR ;
             if (DESTReg==15) { /* MSR reg to CPSR */
                UNDEF_MSRPC ;
                temp = DPRegRHS ;
#ifdef CYCLEBASED
                if (state->NextCycle == WRITEPC1)
                   state->NextCycle = MSR2 ;
                else
#endif
                   ARMul_FixCPSR(state,instr,temp) ;
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x13 : /* TEQP reg */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TEQP reg */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                rhs = DPRegRHS ;
                temp = LHS ^ rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* TEQ Reg */
                rhs = DPSRegRHS ;
                dest = LHS ^ rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x14 : /* CMP reg and MRS SPSR and SWP byte */
             if (BITS(4,11) == 9) { /* SWP */
                UNDEF_SWPPC ;
                temp = LHS ;
                BUSUSEDINCPCS ;
#ifdef CYCLEBASED
                state->lockSig = HIGH ;
                state->addrBus = temp ;
                state->addr01Bus = 0 ;
                state->NopcSig = HIGH ;
                state->NbwSig = LOW ;
                NCYCLE ;
#ifndef MODE32
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   }
#endif
                state->NextCycle = SWPB2 ;
#else
#ifndef MODE32
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   (void)ARMul_LoadByte(state,temp) ;
                   (void)ARMul_LoadByte(state,temp) ;
                   }
                else
#endif
                DEST = ARMul_SwapByte(state,temp,state->Reg[RHSReg]) ;
                if (state->abortSig || state->Aborted) {
                   TAKEABORT ;
                   }
#endif
                }
             else if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS SPSR */
                SINGLECYCLEINSTR ;
                UNDEF_MRSPC ;
                DEST = GETSPSR(state->Bank) ;
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x15 : /* CMPP reg */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* CMPP reg */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                rhs = DPRegRHS ;
                temp = LHS - rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* CMP reg */
                lhs = LHS ;
                rhs = DPRegRHS ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                   SUBCARRY(lhs,rhs,dest) ;
                   SUBOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x16 : /* CMN reg and MSR reg to SPSR */
             SINGLECYCLEINSTR ;
             if (DESTReg==15) { /* MSR */
                UNDEF_MSRPC ;
                ARMul_FixSPSR(state,instr,DPRegRHS);
#ifdef CYCLEBASED
                if (state->NextCycle == DESTPC1)
                   state->NextCycle = NEXTISNEW ;
#endif
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x17 : /* CMNP reg */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) {
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                rhs = DPRegRHS ;
                temp = LHS + rhs ;
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else { /* CMN reg */
                lhs = LHS ;
                rhs = DPRegRHS ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ADDCARRY(lhs,rhs,dest) ;
                   ADDOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARN ;
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x18 : /* ORR reg */
             SINGLECYCLEINSTR ;
             rhs = DPRegRHS ;
             dest = LHS | rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x19 : /* ORRS reg */
             SINGLECYCLEINSTR ;
             rhs = DPSRegRHS ;
             dest = LHS | rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x1a : /* MOV reg */
             SINGLECYCLEINSTR ;
             dest = DPRegRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x1b : /* MOVS reg */
             SINGLECYCLEINSTR ;
             dest = DPSRegRHS ;
             WRITESDEST(dest) ;
             break ;

          case 0x1c : /* BIC reg */
             SINGLECYCLEINSTR ;
             rhs = DPRegRHS ;
             dest = LHS & ~rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x1d : /* BICS reg */
             SINGLECYCLEINSTR ;
             rhs = DPSRegRHS ;
             dest = LHS & ~rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x1e : /* MVN reg */
             SINGLECYCLEINSTR ;
             dest = ~DPRegRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x1f : /* MVNS reg */
             SINGLECYCLEINSTR ;
             dest = ~DPSRegRHS ;
             WRITESDEST(dest) ;
             break ;

/***************************************************************************\
*                Data Processing Immediate RHS Instructions                 *
\***************************************************************************/

          case 0x20 : /* AND immed */
             SINGLECYCLEINSTR ;
             dest = LHS & DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x21 : /* ANDS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS & rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x22 : /* EOR immed */
             SINGLECYCLEINSTR ;
             dest = LHS ^ DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x23 : /* EORS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS ^ rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x24 : /* SUB immed */
             SINGLECYCLEINSTR ;
             dest = LHS - DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x25 : /* SUBS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs - rhs ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x26 : /* RSB immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS - LHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x27 : /* RSBS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = rhs - lhs ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x28 : /* ADD immed */
             SINGLECYCLEINSTR ;
             dest = LHS + DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x29 : /* ADDS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs + rhs ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADDCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2a : /* ADC immed */
             SINGLECYCLEINSTR ;
             dest = LHS + DPImmRHS + CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2b : /* ADCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs + rhs + CFLAG ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADCCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2c : /* SBC immed */
             SINGLECYCLEINSTR ;
             dest = LHS - DPImmRHS - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2d : /* SBCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs - rhs - !CFLAG ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2e : /* RSC immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS - LHS - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2f : /* RSCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = rhs - lhs - !CFLAG ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x30 : /* TST immed */
             SINGLECYCLEINSTR ;
             UNDEF_Test ;
             break ;

          case 0x31 : /* TSTP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TSTP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS & DPImmRHS ;
                SETR15PSR(temp) ;
#endif
                }
             else {
                DPSImmRHS ; /* TST immed */
                dest = LHS & rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x32 : /* TEQ immed and MSR immed to CPSR */
             SINGLECYCLEINSTR ;
             if (DESTReg==15) { /* MSR immed to CPSR */
                ARMul_FixCPSR(state,instr,DPImmRHS) ;
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x33 : /* TEQP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TEQP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS ^ DPImmRHS ;
                SETR15PSR(temp) ;
#endif
                }
             else {
                DPSImmRHS ; /* TEQ immed */
                dest = LHS ^ rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x34 : /* CMP immed */
             SINGLECYCLEINSTR ;
             UNDEF_Test ;
             break ;

          case 0x35 : /* CMPP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* CMPP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS - DPImmRHS ;
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else {
                lhs = LHS ; /* CMP immed */
                rhs = DPImmRHS ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                   SUBCARRY(lhs,rhs,dest) ;
                   SUBOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x36 : /* CMN immed and MSR immed to SPSR */
             SINGLECYCLEINSTR ;
             if (DESTReg==15) /* MSR */
                ARMul_FixSPSR(state, instr, DPImmRHS) ;
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x37 : /* CMNP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* CMNP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS + DPImmRHS ;
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else {
                lhs = LHS ; /* CMN immed */
                rhs = DPImmRHS ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ADDCARRY(lhs,rhs,dest) ;
                   ADDOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARN ;
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x38 : /* ORR immed */
             SINGLECYCLEINSTR ;
             dest = LHS | DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x39 : /* ORRS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS | rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x3a : /* MOV immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3b : /* MOVS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             WRITESDEST(rhs) ;
             break ;

          case 0x3c : /* BIC immed */
             SINGLECYCLEINSTR ;
             dest = LHS & ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3d : /* BICS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS & ~rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x3e : /* MVN immed */
             SINGLECYCLEINSTR ;
             dest = ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3f : /* MVNS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             WRITESDEST(~rhs) ;
             break ;

/***************************************************************************\
*              Single Data Transfer Immediate RHS Instructions              *
\***************************************************************************/

          case 0x40 : /* Store Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x41 : /* Load Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x42 : /* Store Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             temp = lhs - LSImmRHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = temp ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x43 : /* Load Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x44 : /* Store Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x45 : /* Load Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x46 : /* Store Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x47 : /* Load Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x48 : /* Store Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x49 : /* Load Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4a : /* Store Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x4b : /* Load Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x4c : /* Store Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4d : /* Load Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4e : /* Store Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;

          case 0x4f : /* Load Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
             break ;


          case 0x50 : /* Store Word, No WriteBack, Pre Dec, Immed */
             (void)StoreWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x51 : /* Load Word, No WriteBack, Pre Dec, Immed */
             (void)LoadWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x52 : /* Store Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x53 : /* Load Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x54 : /* Store Byte, No WriteBack, Pre Dec, Immed */
             (void)StoreByte(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x55 : /* Load Byte, No WriteBack, Pre Dec, Immed */
             (void)LoadByte(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x56 : /* Store Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x57 : /* Load Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
             if (LoadByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x58 : /* Store Word, No WriteBack, Pre Inc, Immed */
             (void)StoreWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x59 : /* Load Word, No WriteBack, Pre Inc, Immed */
             (void)LoadWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5a : /* Store Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5b : /* Load Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5c : /* Store Byte, No WriteBack, Pre Inc, Immed */
             (void)StoreByte(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5d : /* Load Byte, No WriteBack, Pre Inc, Immed */
             (void)LoadByte(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5e : /* Store Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5f : /* Load Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
             if (LoadByte(state,instr,temp))
                LSBase = temp ;
             break ;

/***************************************************************************\
*              Single Data Transfer Register RHS Instructions               *
\***************************************************************************/

          case 0x60 : /* Store Word, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x61 : /* Load Word, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x62 : /* Store Word, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x63 : /* Load Word, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x64 : /* Store Byte, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x65 : /* Load Byte, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x66 : /* Store Byte, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x67 : /* Load Byte, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x68 : /* Store Word, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x69 : /* Load Word, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6a : /* Store Word, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6b : /* Load Word, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6c : /* Store Byte, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6d : /* Load Byte, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6e : /* Store Byte, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                state->NtransSig = LOW ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6f : /* Load Byte, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                   state->NtransSig = LOW ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;


          case 0x70 : /* Store Word, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                (void)StoreWord(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x71 : /* Load Word, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                (void)LoadWord(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x72 : /* Store Word, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                if (StoreWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x73 : /* Load Word, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                if (LoadWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x74 : /* Store Byte, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                (void)StoreByte(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x75 : /* Load Byte, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                (void)LoadByte(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x76 : /* Store Byte, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                if (StoreByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x77 : /* Load Byte, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                if (LoadByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x78 : /* Store Word, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                (void)StoreWord(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x79 : /* Load Word, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                (void)LoadWord(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7a : /* Store Word, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                if (StoreWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7b : /* Load Word, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                if (LoadWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7c : /* Store Byte, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                (void)StoreByte(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7d : /* Load Byte, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                (void)LoadByte(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7e : /* Store Byte, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                if (StoreByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7f : /* Load Byte, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                if (LoadByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

/***************************************************************************\
*                   Multiple Data Transfer Instructions                     *
\***************************************************************************/

          case 0x80 : /* Store, No WriteBack, Post Dec */
             STOREMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x81 : /* Load, No WriteBack, Post Dec */
             LOADMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x82 : /* Store, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             STOREMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x83 : /* Load, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             LOADMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x84 : /* Store, Flags, No WriteBack, Post Dec */
             STORESMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x85 : /* Load, Flags, No WriteBack, Post Dec */
             LOADSMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x86 : /* Store, Flags, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             STORESMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x87 : /* Load, Flags, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             LOADSMULT(instr,temp + 4L,temp) ;
             break ;


          case 0x88 : /* Store, No WriteBack, Post Inc */
             STOREMULT(instr,LSMBase,0L) ;
             break ;

          case 0x89 : /* Load, No WriteBack, Post Inc */
             LOADMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8a : /* Store, WriteBack, Post Inc */
             temp = LSMBase ;
             STOREMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8b : /* Load, WriteBack, Post Inc */
             temp = LSMBase ;
             LOADMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8c : /* Store, Flags, No WriteBack, Post Inc */
             STORESMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8d : /* Load, Flags, No WriteBack, Post Inc */
             LOADSMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8e : /* Store, Flags, WriteBack, Post Inc */
             temp = LSMBase ;
             STORESMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8f : /* Load, Flags, WriteBack, Post Inc */
             temp = LSMBase ;
             LOADSMULT(instr,temp,temp + LSMNumRegs) ;
             break ;


          case 0x90 : /* Store, No WriteBack, Pre Dec */
             STOREMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x91 : /* Load, No WriteBack, Pre Dec */
             LOADMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x92 : /* Store, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             STOREMULT(instr,temp,temp) ;
             break ;

          case 0x93 : /* Load, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             LOADMULT(instr,temp,temp) ;
             break ;

          case 0x94 : /* Store, Flags, No WriteBack, Pre Dec */
             STORESMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x95 : /* Load, Flags, No WriteBack, Pre Dec */
             LOADSMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x96 : /* Store, Flags, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             STORESMULT(instr,temp,temp) ;
             break ;

          case 0x97 : /* Load, Flags, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             LOADSMULT(instr,temp,temp) ;
             break ;


          case 0x98 : /* Store, No WriteBack, Pre Inc */
             STOREMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x99 : /* Load, No WriteBack, Pre Inc */
             LOADMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9a : /* Store, WriteBack, Pre Inc */
             temp = LSMBase ;
             STOREMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9b : /* Load, WriteBack, Pre Inc */
             temp = LSMBase ;
             LOADMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9c : /* Store, Flags, No WriteBack, Pre Inc */
             STORESMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9d : /* Load, Flags, No WriteBack, Pre Inc */
             LOADSMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9e : /* Store, Flags, WriteBack, Pre Inc */
             temp = LSMBase ;
             STORESMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9f : /* Load, Flags, WriteBack, Pre Inc */
             temp = LSMBase ;
             LOADSMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

/***************************************************************************\
*                            Branch forward                                 *
\***************************************************************************/

          case 0xa0 : case 0xa1 : case 0xa2 : case 0xa3 :
          case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 :
             state->Reg[15] = pc + 8 + POSBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                           Branch backward                                 *
\***************************************************************************/

          case 0xa8 : case 0xa9 : case 0xaa : case 0xab :
          case 0xac : case 0xad : case 0xae : case 0xaf :
             state->Reg[15] = pc + 8 + NEGBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                       Branch and Link forward                             *
\***************************************************************************/

          case 0xb0 : case 0xb1 : case 0xb2 : case 0xb3 :
          case 0xb4 : case 0xb5 : case 0xb6 : case 0xb7 :
#ifdef MODE32
             state->Reg[14] = pc + 4 ; /* put PC into Link */
#else
             state->Reg[14] = pc + 4 | ECC | ER15INT | EMODE ; /* put PC into Link */
#endif
             state->Reg[15] = pc + 8 + POSBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                       Branch and Link backward                            *
\***************************************************************************/

          case 0xb8 : case 0xb9 : case 0xba : case 0xbb :
          case 0xbc : case 0xbd : case 0xbe : case 0xbf :
#ifdef MODE32
             state->Reg[14] = pc + 4 ; /* put PC into Link */
#else
             state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE ; /* put PC into Link */
#endif
             state->Reg[15] = pc + 8 + NEGBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                        Co-Processor Data Transfers                        *
\***************************************************************************/

          case 0xc0 :
          case 0xc4 : /* Store , No WriteBack , Post Dec */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc1 :
          case 0xc5 : /* Load , No WriteBack , Post Dec */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xc2 :
          case 0xc6 : /* Store , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xc3 :
          case 0xc7 : /* Load , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xc8 :
          case 0xcc : /* Store , No WriteBack , Post Inc */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc9 :
          case 0xcd : /* Load , No WriteBack , Post Inc */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xca :
          case 0xce : /* Store , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xcb :
          case 0xcf : /* Load , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_LDC(state,instr,LHS) ;
             break ;


          case 0xd0 :
          case 0xd4 : /* Store , No WriteBack , Pre Dec */
             ARMul_STC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd1 :
          case 0xd5 : /* Load , No WriteBack , Pre Dec */
             ARMul_LDC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd2 :
          case 0xd6 : /* Store , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xd3 :
          case 0xd7 : /* Load , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xd8 :
          case 0xdc : /* Store , No WriteBack , Pre Inc */
             ARMul_STC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xd9 :
          case 0xdd : /* Load , No WriteBack , Pre Inc */
             ARMul_LDC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xda :
          case 0xde : /* Store , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xdb :
          case 0xdf : /* Load , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

/***************************************************************************\
*            Co-Processor Register Transfers (MCR) and Data Ops             *
\***************************************************************************/

          case 0xe0 : case 0xe2 : case 0xe4 : case 0xe6 :
          case 0xe8 : case 0xea : case 0xec : case 0xee :
             if (BIT(4)) { /* MCR */
                if (DESTReg == 15) {
                   UNDEF_MCRPC ;
#ifdef MODE32
                   ARMul_MCR(state,instr,state->Reg[15] + 4) ;
#else
                   ARMul_MCR(state,instr,ECC | ER15INT | EMODE |
                                          ((state->Reg[15] + 4) & R15PCBITS) ) ;
#endif
                   }
                else
                   ARMul_MCR(state,instr,DEST) ;
                }
             else /* CDP Part 1 */
                ARMul_CDP(state,instr) ;
             break ;

/***************************************************************************\
*            Co-Processor Register Transfers (MRC) and Data Ops             *
\***************************************************************************/

          case 0xe1 : case 0xe3 : case 0xe5 : case 0xe7 :
          case 0xe9 : case 0xeb : case 0xed : case 0xef :
             if (BIT(4)) { /* MRC */
#ifdef CYCLEBASED
                (void)ARMul_MRC(state,instr) ;
#else
                temp = ARMul_MRC(state,instr) ;
                if (DESTReg == 15) {
                   ASSIGNN((temp & NBIT) != 0) ;
                   ASSIGNZ((temp & ZBIT) != 0) ;
                   ASSIGNC((temp & CBIT) != 0) ;
                   ASSIGNV((temp & VBIT) != 0) ;
                   }
                else
                   DEST = temp ;
#endif
                }
             else /* CDP Part 2 */
                ARMul_CDP(state,instr) ;
             break ;

/***************************************************************************\
*                             SWI instruction                               *
\***************************************************************************/

          case 0xf0 : case 0xf1 : case 0xf2 : case 0xf3 :
          case 0xf4 : case 0xf5 : case 0xf6 : case 0xf7 :
          case 0xf8 : case 0xf9 : case 0xfa : case 0xfb :
          case 0xfc : case 0xfd : case 0xfe : case 0xff :
             if (instr == ARMul_ABORTWORD && state->AbortAddr == pc) { /* a prefetch abort */
                ARMul_Abort(state,ARMul_PrefetchAbortV) ;
                break ;
                }

#ifdef CYCLEBASED
             ARMul_Abort(state,ARMul_SWIV) ;
#else
             if (!ARMul_OSHandleSWI(state,BITS(0,23))) {
                ARMul_Abort(state,ARMul_SWIV) ;
                }
             else {
                SINGLECYCLEINSTR ;
                }
#endif
             break ;
          } /* 256 way main switch */
       } /* if temp */

#ifdef CYCLEBASED
    else { /* need to account for the unexecuted instruction */
       state->NexecSig = 1 ;
       SINGLECYCLEINSTR ;
       }
    break ; /* Cycle based NEWINSTR */
#endif

#ifdef CYCLEBASED
/***************************************************************************\
*                       The cycle based state machine                       *
\***************************************************************************/

    case RESET1 :
       state->addrBus = PCWRAP(state->addrBus + 4) ;
       if (state->NresetSig == HIGH)
          state->NextCycle = RESET2 ;
       break ;

    case RESET2 :
       state->Reseted = FALSE ;
       ARMul_Abort(state,ARMul_ResetV) ;
       break ;

    case MSR2 :
       ARMul_FixCPSR(state,instr,temp) ;
    case NEXTISNEW :
       state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = LOW ;
       SCYCLE ;
       state->NextCycle = NEWINSTR ;
       break ;

    case KILLNEXT :
       state->addrBus = PCWRAP(pc + 16) ;
       state->seqSig = HIGH ; /* SCYCLE */
       state->NexecSig = 1 ;
       state->NextCycle = ABORT1 ;
       break ;

    case ABORT1 :
       TAKEABORT ;
    case DESTPC1 :
       state->addrBus = PC | state->addr01Bus ;
       state->NopcSig = LOW ;
       NCYCLE ;
       state->NextCycle = DESTPC2 ;
       break ;

    case WRITEPC2 :
       state->NexecSig = 1 ;
    case DESTPC2 :
       state->AbortAddr = 1 ;
       state->addrBus = PCWRAP(state->Reg[15] + 4) | state->addr01Bus ;
       state->NopcSig = LOW ;
       SCYCLE ;
       state->NextCycle = DESTPC3 ;
       break ;

    case DESTPC3 :
       pc = PC ;
       PREFETCH(decoded = state->datainBus,pc) ;
       state->addrBus = PCWRAP(pc + 8) | state->addr01Bus ;
       state->NopcSig = LOW ;
       SCYCLE ;
       state->NextCycle = NEWINSTR ;
       break ;

    case MUL :
       if (--state->NumCycles == 0) { /* last cycle */
          state->addrBus = PCWRAP(pc + 12) ;
          state->NopcSig = LOW ;
          SCYCLE ;
          state->NextCycle = NEWINSTR ;
          }
       /* otherwise just spin in this state */
       break ;

    case LDR2 :
       state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
       if (LHSReg == 15 && BIT(21))
          state->addrBus = PC ;
       else
          state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = HIGH ;
       ICYCLE ;
       state->NextCycle = LDR3 ;
       break ;

    case LDR3 :
       state->NopcSig = LOW ;
       SCYCLE ;
       if (state->abortSig || state->Aborted) {
          if (!state->lateabtSig)
             LSBase = state->OldBase ;
          if (!state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
          state->NextCycle = ABORT1 ;
          }
       else {
          if (state->Base & 3) /* Fix non word alignment */
             state->datainBus =
                ARMul_Align(state,state->Base,state->datainBus) ;
          if (LHSReg == 15 && BIT(21)) { /* special case in ARM6 */
             state->NexecSig = 1 ;
             FLUSHPIPE ;
             state->NextCycle = WRITEPC2 ;
             state->Reg[15] = PCWRAP(state->Reg[15] + 4) ;
             state->addrBus = state->Reg[15] ;
             SCYCLE ;
             }
          else {
             WRITEDEST(state->datainBus) ;
             if (DESTReg == 15) {
                state->addrBus = PC | state->addr01Bus ;
                state->seqSig = LOW ; /* NCYCLE */
                state->NextCycle = WRITEPC2 ;
                }
             else {
                state->addrBus = PCWRAP(pc + 12) ;
                state->NextCycle = NEWINSTR ;
                }
             }
          }
       break ;

    case LDRB2 :
       state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
       state->NbwSig = HIGH ;
       state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = HIGH ;
       ICYCLE ;
       state->NextCycle = LDRB3 ;
       break ;

    case LDRB3 :
       state->NopcSig = LOW ;
       SCYCLE ;
       if (state->abortSig || state->Aborted) {
          if (!state->lateabtSig)
             LSBase = state->OldBase ;
          if (!state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
          state->NextCycle = ABORT1 ;
          }
       else {
          BUSTOBYTE(state->Base,state->datainBus) ;
          WRITEDEST(temp) ;
          if (DESTReg == 15) {
             state->addrBus = PC ;
             state->seqSig = LOW ; /* NCYCLE */
             state->NextCycle = WRITEPC2 ;
             }
          else {
             state->addrBus = PCWRAP(pc + 12) ;
             state->NextCycle = NEWINSTR ;
             }
          }
       break ;

    case STR2 :
       state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
       state->dataoutBus = state->Temp ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       state->NopcSig = LOW ;
       state->addrBus = PCWRAP(pc + 12) ;
       NCYCLE ;
       state->NextCycle = NEWINSTR ;
       if (LHSReg == 15 && BIT(21)) { /* special case in ARM6 */
          FLUSHPIPE ;
          state->NextCycle = WRITEPC2 ;
          }
       break ;

    case STRB2 :
       state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
       state->dataoutBus = BYTETOBUS(state->Temp) ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = LOW ;
       NCYCLE ;
       state->NextCycle = NEWINSTR ;
       break ;

    case SWP2 :
       state->dataoutBus = SWAPSRC ;
#ifndef MODE32
       if (!state->Aborted)
#endif
       state->NrwSig = HIGH ;
       state->NextCycle = SWP3 ;
       break ;

    case SWP3 :
       if (state->Base & 3) /* Fix non word alignment */
          state->Temp = ARMul_Align(state,state->Base,state->datainBus) ;
       else
          state->Temp = state->datainBus ;
       if (state->abortSig && !state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       ICYCLE ;
       state->addrBus = PCWRAP(pc + 12) ;
       state->lockSig = LOW ;
       state->NextCycle = SWP4 ;
       break ;

    case SWPB2 :
       temp = SWAPSRC & 0xff ;
       state->dataoutBus = BYTETOBUS(temp) ;
#ifndef MODE32
       if (!state->Aborted)
#endif
       state->NrwSig = HIGH ;
       state->NextCycle = SWPB3 ;
       break ;

    case SWPB3 :
       BUSTOBYTE(state->addrBus,state->datainBus) ;
       state->Temp = temp ;
       if (state->abortSig && !state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       ICYCLE ;
       state->addrBus = PCWRAP(pc + 12) ;
       state->lockSig = LOW ;
       state->NextCycle = SWP4 ;
       break ;

    case SWP4 :
       SCYCLE ;
       state->doutenSig = LOW ;
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       state->NopcSig = LOW ;
       if (state->abortSig || state->Aborted)
          state->NextCycle = ABORT1 ;
       else {
          WRITEDEST(state->Temp) ;
          state->addrBus = PCWRAP(pc + 12) ;
          state->NextCycle = NEWINSTR ;
          }
       break ;

    case LDM2 :
       state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = HIGH ;
       state->NmreqSig = HIGH ; /* I cycle */
       state->NextCycle = LDM7 ;
       break ;

    case LDM3 :
       state->addrBus += 4 ;
       state->seqSig = HIGH ; /* S cycle */
       state->NextCycle = LDM6 ;
       break ;

    case LDM4 :
       state->addrBus += 4 ;
       state->seqSig = HIGH ; /* S cycle */
       state->NextCycle = LDM5 ;
       break ;

    case LDM5 :
       if (state->abortSig || state->Aborted) {
          state->TempReg[state->Temp] =
             state->Reg[ARMul_NthReg(instr,(unsigned)state->Temp)] ;
          if (!state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
          }
       else
          state->TempReg[state->Temp] = state->datainBus ;
       state->Temp++ ;
       state->addrBus += 4 ;
       if (--state->NumCycles == 2)
          state->NextCycle = LDM6 ;
       break ;

    case LDM6 :
       if (state->abortSig || state->Aborted) {
          state->TempReg[state->Temp] =
             state->Reg[ARMul_NthReg(instr,(unsigned)state->Temp)] ;
          if (!state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
          }
       else
          state->TempReg[state->Temp] = state->datainBus ;
       state->Temp++ ;
       state->addrBus = PCWRAP(pc + 12) ;
       ICYCLE ;
       state->NextCycle = LDM7 ;
       break ;

    case LDM7 :
       if (state->abortSig || state->Aborted) {
          state->TempReg[state->Temp] =
             state->Reg[ARMul_NthReg(instr,(unsigned)state->Temp)] ;
          if (!state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
          }
       else
          state->TempReg[state->Temp] = state->datainBus ;
       temp = state->addrBus - state->Temp * 4 ;
       if (BIT(22)) /* is the S bit set ? */
          LoadSMult(state,instr,temp,0L) ;
       else
          LoadMult(state,instr,temp,0L) ;
       break ;

    case STM2 :
       state->dataoutBus = state->TempReg[state->Temp++] ;
       if (state->abortSig && !state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->addrBus += 4 ;
       state->seqSig = HIGH ;
       if (--state->NumCycles == 1)
          state->NextCycle = STM3 ;
       break ;

    case STM3 :
       state->dataoutBus = state->TempReg[state->Temp++] ;
       if (state->abortSig && !state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       state->NbwSig = HIGH ;
       state->addrBus = PCWRAP(pc + 12) ;
       state->NopcSig = LOW ;
       NCYCLE ;
       state->NextCycle = NEWINSTR ;
       break ;

    case LDCBUSY :
       state->addrBus = state->Temp ;
       break ;

    case LDC2 :
       state->LSCActive = TRUE ;
       state->PrevaddrBus = state->addrBus ;
       state->PrevNrwSig = state->NrwSig ;
       state->NextaddrBus = PCWRAP(pc + 12) ;
       state->NextNrwSig = LOW ;
       state->NextNopcSig = LOW ;
       state->NextNmreqSig = LOW ;
       state->NextseqSig = LOW ;
       break ;

    case STCBUSY :
       state->addrBus = state->Temp ;
       break ;

    case STC2 :
       state->NextCycle = STC3;
    case STC3 :
       state->LSCActive = TRUE ;
       state->PrevaddrBus = state->addrBus ;
       state->PrevNrwSig = state->NrwSig ;
       state->NextaddrBus = PCWRAP(pc + 12) ;
       state->NextNrwSig = LOW ;
       state->NextNopcSig = LOW ;
       state->NextNmreqSig = LOW ;
       state->NextseqSig = LOW ;
       break ;

    case MCRBUSY :
       state->addrBus = PCWRAP(pc + 12) ;
       state->addr01Bus = 0 ;
       break ;

    case MCR2 :
       state->doutenSig = HIGHLOW | state->NrwSig ;
       state->NrwSig = LOW ;
       state->addrBus = PCWRAP(pc + 12) ;
       NCYCLE ;
       state->NopcSig = LOW ;
       state->dataoutBus = state->Temp ;
       state->NextCycle = NEWINSTR ;
       break ;

    case MRCBUSY :
       state->addrBus = PCWRAP(pc + 12) ;
       state->addr01Bus = 0 ;
       break ;

    case MRC2 :
       state->addrBus = PCWRAP(pc + 12) ;
       ICYCLE ;
       state->NopcSig = HIGH ;
       state->NextCycle = MRC3 ;
       break ;

    case MRC3 :
       if (DESTReg == 15) {
          ASSIGNN((state->datainBus & NBIT) != 0) ;
          ASSIGNZ((state->datainBus & ZBIT) != 0) ;
          ASSIGNC((state->datainBus & CBIT) != 0) ;
          ASSIGNV((state->datainBus & VBIT) != 0) ;
          }
       else
          DEST = state->datainBus ;
       state->addrBus = PCWRAP(pc + 12) ;
       SCYCLE ;
       state->NopcSig = LOW ;
       state->NextCycle = NEWINSTR ;
       break ;

    case CDPBUSY :
       state->addrBus = PCWRAP(pc + 12) ;
       state->addr01Bus = 0 ;
       break ;

    case ANABORT :
       ARMul_Abort(state,state->Vector) ;
       break ;

    } /* cycle based state machine */

 state->Inted = state->LastInted ;
 state->LastInted = (state->NirqSig << 1) | state->NfiqSig | IFFLAGS ;
 state->instr = instr ;
 state->decoded = decoded ;
 state->loaded = loaded ;
 state->pc = pc ;
 state->temp = temp ;
 return(state->NextCycle) ;
 } /* Emulate26/32 in cycle based mode */
#else /* INSTRBASED */
    if (state->Emulate == ONCE) {
        state->Emulate = STOP;
#ifndef CYCLEBASED
        break;
#endif
    }
    else if (state->Emulate != RUN)
        break;
    } while (1) ; /* do loop */
 state->decoded = decoded ;
 state->loaded = loaded ;
 state->pc = pc ;
 return(pc) ;
 } /* Emulate 26/32 in instruction based mode */
#endif  /* CYCLEBASED */


/***************************************************************************\
* This routine evaluates most Data Processing register RHS's with the S     *
* bit clear.  It is intended to be called from the macro DPRegRHS, which    *
* filters the common case of an unshifted register with in line code        *
\***************************************************************************/

static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base ;

 base = RHSReg ;
 if (BIT(4)) { /* shift amount in a register */
    UNDEF_Shift ;
    INCPC ;
#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
#ifdef CYCLEBASED
    state->addrBus = PC ;
    state->NopcSig = HIGH ;
    ICYCLE ;
    if (DESTReg == 15)
       state->NextCycle = WRITEPC1 ;
    else {
       state->NextCycle = NEXTISNEW ;
       state->addr01Bus = 0 ;
       }
#else
    ARMul_Icycles(state,1,0L) ;
#endif
    shamt = state->Reg[BITS(8,11)] & 0xff ;
    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return(0) ;
                  else
                     return(base << shamt) ;
       case LSR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return(0) ;
                  else
                     return(base >> shamt) ;
       case ASR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return((ARMword)((long int)base >> 31L)) ;
                  else
                     return((ARMword)((long int)base >> (int)shamt)) ;
       case ROR : shamt &= 0x1f ;
                  if (shamt == 0)
                     return(base) ;
                  else
                     return((base << (32 - shamt)) | (base >> shamt)) ;
       }
    }
 else { /* shift amount is a constant */
#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
    base = state->Reg[base] ;
    shamt = BITS(7,11) ;
    switch ((int)BITS(5,6)) {
       case LSL : return(base<<shamt) ;
       case LSR : if (shamt == 0)
                     return(0) ;
                  else
                     return(base >> shamt) ;
       case ASR : if (shamt == 0)
                     return((ARMword)((long int)base >> 31L)) ;
                  else
                     return((ARMword)((long int)base >> (int)shamt)) ;
       case ROR : if (shamt==0) /* its an RRX */
                     return((base >> 1) | (CFLAG << 31)) ;
                  else
                     return((base << (32 - shamt)) | (base >> shamt)) ;
       }
    }
 return(0) ; /* just to shut up lint */
 }
/***************************************************************************\
* This routine evaluates most Logical Data Processing register RHS's        *
* with the S bit set.  It is intended to be called from the macro           *
* DPSRegRHS, which filters the common case of an unshifted register         *
* with in line code                                                         *
\***************************************************************************/

static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base ;

 base = RHSReg ;
 if (BIT(4)) { /* shift amount in a register */
    UNDEF_Shift ;
    INCPC ;
#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
#ifdef CYCLEBASED
    state->addrBus = PC ;
    state->NopcSig = HIGH ;
    ICYCLE ;
    if (DESTReg == 15)
       state->NextCycle = WRITEPC1 ;
    else {
       state->NextCycle = NEXTISNEW ;
       state->addr01Bus = 0 ;
       }
#else
    ARMul_Icycles(state,1,0L) ;
#endif
    shamt = state->Reg[BITS(8,11)] & 0xff ;
    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base) ;
                  else if (shamt == 32) {
                     ASSIGNC(base & 1) ;
                     return(0) ;
                     }
                  else if (shamt > 32) {
                     CLEARC ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (32-shamt)) & 1) ;
                     return(base << shamt) ;
                     }
       case LSR : if (shamt == 0)
                     return(base) ;
                  else if (shamt == 32) {
                     ASSIGNC(base >> 31) ;
                     return(0) ;
                     }
                  else if (shamt > 32) {
                     CLEARC ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return(base >> shamt) ;
                     }
       case ASR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32) {
                     ASSIGNC(base >> 31L) ;
                     return((ARMword)((long int)base >> 31L)) ;
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1) ;
                     return((ARMword)((long int)base >> (int)shamt)) ;
                     }
       case ROR : if (shamt == 0)
                     return(base) ;
                  shamt &= 0x1f ;
                  if (shamt == 0) {
                     ASSIGNC(base >> 31) ;
                     return(base) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt-1)) & 1) ;
                     return((base << (32-shamt)) | (base >> shamt)) ;
                     }
       }
    }
 else { /* shift amount is a constant */
#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
    shamt = BITS(7,11) ;
    switch ((int)BITS(5,6)) {
       case LSL : ASSIGNC((base >> (32-shamt)) & 1) ;
                  return(base << shamt) ;
       case LSR : if (shamt == 0) {
                     ASSIGNC(base >> 31) ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return(base >> shamt) ;
                     }
       case ASR : if (shamt == 0) {
                     ASSIGNC(base >> 31L) ;
                     return((ARMword)((long int)base >> 31L)) ;
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1) ;
                     return((ARMword)((long int)base >> (int)shamt)) ;
                     }
       case ROR : if (shamt == 0) { /* its an RRX */
                     shamt = CFLAG ;
                     ASSIGNC(base & 1) ;
                     return((base >> 1) | (shamt << 31)) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return((base << (32-shamt)) | (base >> shamt)) ;
                     }
       }
    }
 return(0) ; /* just to shut up lint */
 }

/***************************************************************************\
* This routine handles writes to register 15 when the S bit is not set.     *
\***************************************************************************/

static void WriteR15(ARMul_State *state, ARMword src)
{
#ifdef MODE32
 state->Reg[15] = src & PCBITS ;
#else
 state->Reg[15] = (src & R15PCBITS) | ECC | ER15INT | EMODE ;
 ARMul_R15Altered(state) ;
 state->Reg[15] = src & R15PCBITS ;
#endif
 FLUSHPIPE ;
#ifdef CYCLEBASED
 state->NextCycle = WRITEPC2 ;
 state->addr01Bus = src & 3 ;
 state->addrBus = PC | state->addr01Bus ;
#endif
 }

/***************************************************************************\
* This routine handles writes to register 15 when the S bit is set.         *
\***************************************************************************/

static void WriteSR15(ARMul_State *state, ARMword src)
{
#ifdef MODE32
 state->Reg[15] = src & PCBITS ;
 if (state->Bank > 0) {
    state->Cpsr = state->Spsr[state->Bank] ;
    ARMul_CPSRAltered(state) ;
    }
#else
 if (state->Bank == USERBANK)
    state->Reg[15] = (src & (CCBITS | R15PCBITS)) | ER15INT | EMODE ;
 else
    state->Reg[15] = src ;
 ARMul_R15Altered(state) ;
 state->Reg[15] = src & R15PCBITS ;
#endif
 FLUSHPIPE ;
#ifdef CYCLEBASED
 state->NextCycle = WRITEPC2 ;
 state->addr01Bus = src & 3 ;
 state->addrBus = PC | state->addr01Bus ;
#endif
 }

/***************************************************************************\
* This routine evaluates most Load and Store register RHS's.  It is         *
* intended to be called from the macro LSRegRHS, which filters the          *
* common case of an unshifted register with in line code                    *
\***************************************************************************/

static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt, base ;

 base = RHSReg ;
#ifndef MODE32
 if (base == 15)
    base = ECC | ER15INT | R15PC | EMODE ; /* Now forbidden, but .... */
 else
#endif
    base = state->Reg[base] ;

 shamt = BITS(7,11) ;
 switch ((int)BITS(5,6)) {
    case LSL : return(base << shamt) ;
    case LSR : if (shamt == 0)
                  return(0) ;
               else
                  return(base >> shamt) ;
    case ASR : if (shamt == 0)
                  return((ARMword)((long int)base >> 31L)) ;
               else
                  return((ARMword)((long int)base >> (int)shamt)) ;
    case ROR : if (shamt==0) /* its an RRX */
                  return((base >> 1) | (CFLAG << 31)) ;
               else
                  return((base << (32-shamt)) | (base >> shamt)) ;
    }
 return(0) ; /* just to shut up lint */
 }

/***************************************************************************\
* This function does the work of loading a word for a LDR instruction.      *
\***************************************************************************/

static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address)
{
#ifndef CYCLEBASED
 ARMword dest ;
#endif

 BUSUSEDINCPCS ;
#ifndef MODE32
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
#ifdef CYCLEBASED
 state->addrBus = address ;
 state->addr01Bus = 0 ;
 state->Base = address ;
 state->OldBase = LHS ;
 NCYCLE ;
 state->NopcSig = HIGH ;
 state->NextCycle = LDR2 ;
#else /* INSTRBASED */
 dest = ARMul_LoadWordN(state,address) ;
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
 if (address & 3)
    dest = ARMul_Align(state,address,dest) ;
 WRITEDEST(dest) ;
 ARMul_Icycles(state,1,0L) ;
#endif

 return(DESTReg != LHSReg) ;
}

/***************************************************************************\
* This function does the work of loading a byte for a LDRB instruction.     *
\***************************************************************************/

static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address)
{
#ifndef CYCLEBASED
 ARMword dest ;
#endif

 BUSUSEDINCPCS ;
#ifndef MODE32
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
#ifdef CYCLEBASED
 state->NbwSig = LOW ;
 state->addrBus = address ;
 state->addr01Bus = 0 ;
 state->Base = address ;
 state->OldBase = LHS ;
 state->NopcSig = HIGH ;
 NCYCLE ;
 state->NextCycle = LDRB2 ;
#else /* INSTRBASED */
 dest = ARMul_LoadByte(state,address) ;
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
 UNDEF_LSRBPC ;
 WRITEDEST(dest) ;
 ARMul_Icycles(state,1,0L) ;
#endif
 return(DESTReg != LHSReg) ;
}

/***************************************************************************\
* This function does the work of storing a word from a STR instruction.     *
\***************************************************************************/

static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address)
{BUSUSEDINCPCN ;
#ifdef CYCLEBASED
 state->NrwSig = HIGH ;
 state->addrBus = address ;
 state->addr01Bus = 0 ;
#ifndef MODE32
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
#ifndef MODE32
 if (DESTReg == 15)
    state->Temp = ECC | ER15INT | R15PC | EMODE ;
 else
#endif
 state->Temp = DEST ;
 state->NopcSig = HIGH ;
 NCYCLE ;
 state->NextCycle = STR2 ;
 state->OldBase = LSBase ;
#else /* INSTRBASED */
#ifdef MODE32
 ARMul_StoreWordN(state,address,DEST) ;
#else
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    (void)ARMul_LoadWordN(state,address) ;
    }
 else {
    if (DESTReg == 15)
       ARMul_StoreWordN(state,address,ECC | ER15INT | R15PC | EMODE) ;
    else
       ARMul_StoreWordN(state,address,DEST) ;
    }
#endif
 if (state->Aborted) {
    if (state->Processor & ARM_Abort7_Prop)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
#endif
 return(TRUE) ;
}

/***************************************************************************\
* This function does the work of storing a byte for a STRB instruction.     *
\***************************************************************************/

static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address)
{BUSUSEDINCPCN ;
#ifdef CYCLEBASED
 state->NbwSig = LOW ;
 state->NrwSig = HIGH ;
 state->addrBus = address ;
 state->addr01Bus = 0 ;
#ifndef MODE32
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
#ifndef MODE32
 if (DESTReg == 15)
    state->Temp = (R15PC | EMODE) & 0xff ;
 else
#endif
 state->Temp = DEST & 0xff ;
 state->NopcSig = HIGH ;
 NCYCLE ;
 state->OldBase = LSBase ;
 state->NextCycle = STRB2 ;
#else /* INSTRBASED */
#ifdef MODE32
 ARMul_StoreByte(state,address,DEST) ;
#else
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    (void)ARMul_LoadByte(state,address) ;
    }
 else {
    if (DESTReg == 15)
       ARMul_StoreByte(state,address,ECC | ER15INT | R15PC | EMODE) ;
    else
       ARMul_StoreByte(state,address,DEST) ;
    }
#endif
 if (state->Aborted) {
    if (state->Processor & ARM_Abort7_Prop)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
#endif
 UNDEF_LSRBPC ;
 return(TRUE) ;
}

#ifdef CYCLEBASED

/***************************************************************************\
* Handles the first cycle of a Load Multiple. The last cycle is handled by  *
* LoadMult(), which actually does the transferring to the real registers.   *
\***************************************************************************/

static void LoadMultSetup(ARMul_State *state, ARMword instr, ARMword address, ARMword WBBase)
{
#ifndef MODE32
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;
 state->addrBus = address ;
 state->addr01Bus = 0 ;
 state->NopcSig = HIGH ;
 NCYCLE ;
 state->NumCycles = (unsigned)(LSMNumRegs / 4) ;
 if (state->NumCycles == 1)
    state->NextCycle = LDM2 ;
 else if (state->NumCycles == 2)
    state->NextCycle = LDM3 ;
 else
    state->NextCycle = LDM4 ;
 state->Temp = 0 ;
 state->OldBase = WBBase ;
}

#endif

/***************************************************************************\
* This function does the work of loading the registers listed in an LDM     *
* instruction, when the S bit is clear.  The code here is always increment  *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/

static void LoadMult(ARMul_State *state, ARMword instr,
                     ARMword address, ARMword WBBase)
{ARMword dest, temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCS ;
#ifdef CYCLEBASED
 dest = 0 ;
#else
#ifndef MODE32
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;
#endif

    for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
#ifdef CYCLEBASED
    state->Reg[temp++] = state->TempReg[dest++] ;
#else
    dest = ARMul_LoadWordN(state,address) ;
    if (!state->abortSig && !state->Aborted)
       state->Reg[temp++] = dest ;
    else
       if (!state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
#endif

    for (; temp < 16 ; temp++) /* S cycles from here on */
       if (BIT(temp)) { /* load this register */
#ifdef CYCLEBASED
          state->Reg[temp] = state->TempReg[dest++] ;
#else
          address += 4 ;
          dest = ARMul_LoadWordS(state,address) ;
          if (!state->abortSig && !state->Aborted)
             state->Reg[temp] = dest ;
          else
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
#endif
          }

 if (BIT(15)) { /* PC is in the reg list */
#ifdef CYCLEBASED
    state->addr01Bus = state->Reg[15] & 3 ;
    state->NopcSig = LOW ;
#endif
    state->Reg[15] = PC ;
    FLUSHPIPE ;
#ifdef CYCLEBASED
    state->NextCycle = WRITEPC2 ;
#endif
    }
#ifdef CYCLEBASED
 else {
    state->NopcSig = LOW ;
    SCYCLE ;
    state->NextCycle = NEWINSTR ;
    }
 state->addrBus = PC | state->addr01Bus ;
#endif

#ifdef CYCLEBASED
 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = state->OldBase ;
    state->NextCycle = ABORT1 ;
    }
#else
 ARMul_Icycles(state,1,0L) ; /* to write back the final register */

 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
    }
#endif
 }

/***************************************************************************\
* This function does the work of loading the registers listed in an LDM     *
* instruction, when the S bit is set. The code here is always increment     *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/

static void LoadSMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase)
{ARMword dest, temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCS ;
#ifdef CYCLEBASED
 dest = 0 ;
#else
#ifndef MODE32
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
#endif
#endif

 if (!BIT(15) && state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE) ; /* temporary reg bank switch */
    UNDEF_LSMUserBankWb ;
    }

#ifndef CYCLEBASED
 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;
#endif

    for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
#ifdef CYCLEBASED
    state->Reg[temp++] = state->TempReg[dest++] ;
#else
    dest = ARMul_LoadWordN(state,address) ;
    if (!state->abortSig)
       state->Reg[temp++] = dest ;
    else
       if (!state->Aborted)
          state->Aborted = ARMul_DataAbortV ;
#endif

    for (; temp < 16 ; temp++) /* S cycles from here on */
       if (BIT(temp)) { /* load this register */
#ifdef CYCLEBASED
          state->Reg[temp] = state->TempReg[dest++] ;
#else
          address += 4 ;
          dest = ARMul_LoadWordS(state,address) ;
          if (!state->abortSig || state->Aborted)
             state->Reg[temp] = dest ;
          else
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
#endif
          }

 if (BIT(15)) { /* PC is in the reg list */
#ifdef CYCLEBASED
    state->addr01Bus = state->Reg[15] & 3 ;
    state->NopcSig = LOW ;
#endif
#ifdef MODE32
    if (state->Mode != USER26MODE && state->Mode != USER32MODE) {
       state->Cpsr = GETSPSR(state->Bank) ;
       ARMul_CPSRAltered(state) ;
       }
    state->Reg[15] = PC ;
#else
    if (state->Mode == USER26MODE || state->Mode == USER32MODE) { /* protect bits in user mode */
       ASSIGNN((state->Reg[15] & NBIT) != 0) ;
       ASSIGNZ((state->Reg[15] & ZBIT) != 0) ;
       ASSIGNC((state->Reg[15] & CBIT) != 0) ;
       ASSIGNV((state->Reg[15] & VBIT) != 0) ;
       }
    else
       ARMul_R15Altered(state) ;
#endif
    FLUSHPIPE ;
#ifdef CYCLEBASED
    state->NextCycle = WRITEPC2 ;
#endif
    }
#ifdef CYCLEBASED
 else {
    state->NopcSig = LOW ;
    SCYCLE ;
    state->NextCycle = NEWINSTR ;
    }
 state->addrBus = PC | state->addr01Bus ;
#endif

 if (!BIT(15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode) ; /* restore the correct bank */

#ifdef CYCLEBASED
 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = state->OldBase ;
    state->NextCycle = ABORT1 ;
    }
#else
 ARMul_Icycles(state,1,0L) ; /* to write back the final register */

 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
    }
#endif

}

#ifdef CYCLEBASED

/***************************************************************************\
* Handles the first cycle of a Store Multiple. First cycle is handled by    *
* StoreMult(), which actually does the transferring to the real registers.  *
\***************************************************************************/

static void StoreMultSetup(ARMul_State *state, ARMword instr,
                           ARMword address, ARMword WBBase)
{
 state->NrwSig = HIGH ;
 state->addrBus = address ;
 state->addr01Bus = 0 ;
 state->NopcSig = HIGH ;
 NCYCLE ;

 if (BIT(22)) /* is the S bit set ? */
    StoreSMult(state,instr,address,WBBase) ;
 else
    StoreMult(state,instr,address,WBBase) ;

 state->Temp = 0 ;
 if ((state->NumCycles = (unsigned)(LSMNumRegs / 4)) == 1)
    state->NextCycle = STM3 ;
 else
    state->NextCycle = STM2 ;
}

#endif

/***************************************************************************\
* This function does the work of storing the registers listed in an STM     *
* instruction, when the S bit is clear.  The code here is always increment  *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/

static void StoreMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase)
{ARMword temp ;
 ARMword dest = 0 ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCN ;
#ifndef MODE32
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
 if (BIT(15))
    state->Reg[15] = ECC | ER15INT | EMODE | R15PC ;
#endif

 for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
#ifdef CYCLEBASED
 state->TempReg[dest++] = state->Reg[temp++] ;
#else
#ifdef MODE32
 ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#else
 if (state->Aborted) {
    (void)ARMul_LoadWordN(state,address) ;
    for ( ; temp < 16 ; temp++) /* Fake the Stores as Loads */
       if (BIT(temp)) { /* save this register */
          address += 4 ;
          (void)ARMul_LoadWordS(state,address) ;
          dest++ ; /* count the aborts */
          }
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    if (state->Processor & ARM_Abort7_Prop && dest == 0)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    return ;
    }
 else
    ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#endif
 if (state->abortSig && !state->Aborted) {
    state->Aborted = ARMul_DataAbortV ;
    }
#endif

 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

 for ( ; temp < 16 ; temp++) /* S cycles from here on */
    if (BIT(temp)) { /* save this register */
#ifdef CYCLEBASED
       state->TempReg[dest++] = state->Reg[temp] ;
#else
       address += 4 ;
       ARMul_StoreWordS(state,address,state->Reg[temp]) ;
       if (state->abortSig && !state->Aborted) {
             state->Aborted = ARMul_DataAbortV ;
             dest++ ; /* count the aborts */
             }
#endif
       }
#ifndef CYCLEBASED
 if (state->Aborted) {
    if (state->Processor & ARM_Abort7_Prop && state->abortSig && dest == 1)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    }
#endif
#ifndef MODE32
 if (BIT(15))
    state->Reg[15] = PC ;
#endif
 }

/***************************************************************************\
* This function does the work of storing the registers listed in an STM     *
* instruction when the S bit is set.  The code here is always increment     *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/

static void StoreSMult(ARMul_State *state, ARMword instr,
                       ARMword address, ARMword WBBase)
{ARMword temp ;
 ARMword dest = 0 ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCN ;
#ifndef MODE32
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
 if (BIT(15))
    state->Reg[15] = ECC | ER15INT | EMODE | R15PC ;
#endif

 if (state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE) ; /* Force User Bank */
    UNDEF_LSMUserBankWb ;
    }

 for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
#ifdef CYCLEBASED
 state->TempReg[dest++] = state->Reg[temp++] ;
#else
#ifdef MODE32
 ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#else
 if (state->Aborted) {
    (void)ARMul_LoadWordN(state,address) ;
    for ( ; temp < 16 ; temp++) /* Fake the Stores as Loads */
       if (BIT(temp)) { /* save this register */
          address += 4 ;
          (void)ARMul_LoadWordS(state,address) ;
          dest++ ; /* count the aborts */
          }
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    if (state->Mode != USER26MODE && state->Mode != USER32MODE)
       (void)ARMul_SwitchMode(state,USER26MODE,state->Mode) ; /* restore the correct bank */
    if (state->Processor & ARM_Abort7_Prop && dest == 0)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    return ;
    }
 else
    ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#endif
 if (state->abortSig && !state->Aborted)
    state->Aborted = ARMul_DataAbortV ;
#endif

 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

 for (; temp < 16 ; temp++) /* S cycles from here on */
    if (BIT(temp)) { /* save this register */
#ifdef CYCLEBASED
       state->TempReg[dest++] = state->Reg[temp] ;
#else
       address += 4 ;
       ARMul_StoreWordS(state,address,state->Reg[temp]) ;
       if (state->abortSig && !state->Aborted) {
             state->Aborted = ARMul_DataAbortV ;
             dest++ ; /* count the aborts */
             }
#endif
       }

 if (state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode) ; /* restore the correct bank */

#ifndef CYCLEBASED
 if (state->Aborted) {
    if (state->Processor & ARM_Abort7_Prop && state->abortSig && dest == 1)
       (void)ARMul_LoadInstrS(state,PC) ;
    TAKEABORT ;
    }
#endif
#ifndef MODE32
 if (BIT(15))
    state->Reg[15] = PC ;
#endif
}
