/* ARMulator core switch statement
 * Conditional compilation allows this to be segmented
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#if 0                           /* Fool topcc */
void this_is_a_function(void)
{
#endif

#ifdef PART0                    /* 0x00 - 0x3f */
/***************************************************************************\
*                 Data Processing Register RHS Instructions                 *
\***************************************************************************/

          case 0x00 : /* AND reg and MUL and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = LHS & rhs ;
              WRITEDEST(dest) ;
              break ;
            }
            break;

          case 0x01 : /* ANDS reg and MULS and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPSRegRHS(rhs);
              dest = LHS & rhs ;
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x02 : /* EOR reg and MLA and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = LHS ^ rhs ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x03 : /* EORS reg and MLAS and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPSRegRHS(rhs);
              dest = LHS ^ rhs ;
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x04 : /* SUB reg and MUL??? and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs);
              dest = LHS - rhs ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x05 : /* SUBS reg and MUL??? */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = lhs - rhs ;
              if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
              }
              else {
                CLEARCV;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x06 : /* RSB reg and MUL??? and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = rhs - LHS ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x07 : /* RSBS reg and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = rhs - lhs ;
              if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
              }
              else {
                CLEARCV;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x08 : /* ADD reg and UMULL and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = LHS + rhs ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x09 : /* ADDS reg and UMULLS and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = lhs + rhs ;
              ASSIGNZ(dest==0) ;
              if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADDCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
              }
              else {
                CLEARNCV;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

           case 0x0a : /* ADC reg and UMLAL and halfwords */
             if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = LHS + rhs + CFLAG ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x0b : /* ADCS reg and UMLALS */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = lhs + rhs + CFLAG ;
              ASSIGNZ(dest==0) ;
              if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADCCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
              }
              else {
                CLEARNCV ;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x0c : /* SBC reg and SMULL and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = LHS - rhs - !CFLAG ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x0d : /* SBCS reg and SMULLS */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = lhs - rhs - !CFLAG ;
              if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
              }
              else {
                CLEARCV;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

          case 0x0e : /* RSC reg and SMLAL and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              AssignDPRegRHS(rhs) ;
              dest = rhs - LHS - !CFLAG ;
              WRITEDEST(dest) ;
              break;
            }
            break;

          case 0x0f : /* RSCS reg and SMLALS and halfwords */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              lhs = LHS ;
              AssignDPRegRHS(rhs) ;
              dest = rhs - lhs - !CFLAG ;
              if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
              }
              else {
                CLEARCV ;
              }
              WRITESDEST(dest) ;
              break;
            }
            break;

           case 0x10 : /* TST reg and MRS CPSR and SWP word or halfword */
             if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS CPSR */
                 SINGLECYCLEINSTR ;
                 UNDEF_MRSPC ;
                 DEST = CPSR ;
               } else {
                 SINGLECYCLEINSTR ;
                 UNDEF_Test;
               }
             }
             break ;

           case 0x11 : /* TST(P) reg or halfword */
             if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               if (DESTReg == 15) { /* TSTP reg */
#ifdef MODE32
                 state->Cpsr = GETSPSR(state->Bank) ;
                 ARMul_CPSRAltered(state) ;
#else
                 AssignDPRegRHS(rhs) ;
                 temp = LHS & rhs ;
                 SETR15PSR(temp) ;
#endif
               }
               else { /* TST reg */
                 AssignDPSRegRHS(rhs);
                 dest = LHS & rhs ;
                 ARMul_NegZero(state,dest) ;
               }
             }
             break ;

           case 0x12 : /* TEQ reg and MSR reg to CPSR or halfword */
             if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
#ifdef CODE16
               if (BITS(4,19) == 0xfff1 && (state->Processor & ARM_Code16_Prop)) {
                 /* BX reg */
                 ARMword dest = state->Reg[BITS(0,3)];
                 SETINSTRUCTIONSET(BXINSTRUCTIONSET(dest));
                 WriteR15(state, PCADDRESSBITS(dest)); /* NB uses iset just set */
                 instruction_size = INSTRUCTIONSIZE;
                 break;
               }
#endif
               SINGLECYCLEINSTR ;
               if (DESTReg==15 && BITS(17,18)==0) { /* MSR reg to CPSR */
                 UNDEF_MSRPC ;
                 AssignDPRegRHS(temp) ;
#ifdef CYCLEBASED
                 if (state->NextCycle == WRITEPC1)
                   state->NextCycle = MSR2 ;
                 else
#endif
                   ARMul_FixCPSR(state,instr,temp) ;
               }
               else {
                 SINGLECYCLEINSTR ;
                 UNDEF_Test ;
               }
             }
             break ;

           case 0x13 : /* TEQ(P) reg or halfword */
             if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               if (DESTReg == 15) { /* TEQP reg */
#ifdef MODE32
                 state->Cpsr = GETSPSR(state->Bank) ;
                 ARMul_CPSRAltered(state) ;
#else
                 AssignDPRegRHS(rhs) ;
                 temp = LHS ^ rhs ;
                 SETR15PSR(temp) ;
#endif
               }
               else { /* TEQ Reg */
                 AssignDPSRegRHS(rhs);
                 dest = LHS ^ rhs ;
                 ARMul_NegZero(state,dest) ;
               }
             }
             break ;

          case 0x14 : /* CMP reg and MRS SPSR and SWP byte or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS SPSR */
                SINGLECYCLEINSTR ;
                UNDEF_MRSPC ;
                DEST = GETSPSR(state->Bank) ;
              } else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
              }
            }
            break ;

          case 0x15 : /* CMP(P) reg or halfword down,preindex,nowb,load */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              if (DESTReg == 15) { /* CMPP reg */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                AssignDPRegRHS(rhs) ;
                temp = LHS - rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* CMP reg */
                lhs = LHS ;
                AssignDPRegRHS(rhs) ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                  SUBCARRY(lhs,rhs,dest) ;
                  SUBOVERFLOW(lhs,rhs,dest) ;
                } else {
                  CLEARCV ;
                }
              }
           }
           break ;

          case 0x16 : /* CMN reg and MSR reg to SPSR or halfword down,preindex,wb,store */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              if (DESTReg==15 && BITS(17,18)==0) { /* MSR */
                UNDEF_MSRPC ;
                ARMul_FixSPSR(state,instr,DPRegRHS);
#ifdef CYCLEBASED
                if (state->NextCycle == DESTPC1)
                   state->NextCycle = NEXTISNEW ;
#endif
                }
             else { /* CMN */
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
           }
             break ;

          case 0x17 : /* CMN(P) reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              if (DESTReg == 15) { /* CMNP reg */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                AssignDPRegRHS(rhs) ;
                temp = LHS + rhs ;
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else { /* CMN reg */
                lhs = LHS ;
                AssignDPRegRHS(rhs) ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ADDCARRY(lhs,rhs,dest) ;
                   ADDOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                  CLEARNCV;
                }
              }
           }
             break ;

           case 0x18 : /* ORR reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               AssignDPRegRHS(rhs) ;
               dest = LHS | rhs ;
               WRITEDEST(dest) ;
             }
             break ;

           case 0x19 : /* ORRS reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               AssignDPSRegRHS(rhs);
               dest = LHS | rhs ;
               WRITESDEST(dest) ;
             }
             break ;

           case 0x1a : /* MOV reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               AssignDPRegRHS(dest) ;
               WRITEDEST(dest) ;
             }
             break ;

           case 0x1b : /* MOVS reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               dest = DPSRegRHS;
#ifdef CODE16
               if (BITS(4,11) == 0 && RHSReg == 14 && state->Processor & ARM_Code16_Prop){
                 WRITESDESTANDT(dest);
                 instruction_size = INSTRUCTIONSIZE;
               } else
#endif
               {
                 WRITESDEST(dest) ;
               }
             }
             break ;

           case 0x1c : /* BIC reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               AssignDPRegRHS(rhs) ;
               dest = LHS & ~rhs ;
               WRITEDEST(dest) ;
             }
             break ;

           case 0x1d : /* BICS reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
               SINGLECYCLEINSTR ;
               AssignDPSRegRHS(rhs);
               dest = LHS & ~rhs ;
               WRITESDEST(dest) ;
             }
             break ;

          case 0x1e : /* MVN reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              dest = ~DPRegRHS ;
              WRITEDEST(dest) ;
            }
             break ;

          case 0x1f : /* MVNS reg or halfword */
            if ((instr & 0x90) != 0x90 || InstructionExtension(state,instr)) {
              SINGLECYCLEINSTR ;
              dest = ~DPSRegRHS;
              WRITESDEST(dest) ;
            }
            break ;

/***************************************************************************\
*                Data Processing Immediate RHS Instructions                 *
\***************************************************************************/

          case 0x20 : /* AND immed */
             SINGLECYCLEINSTR ;
             dest = LHS & DPImmRHS ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x21 : /* ANDS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS & rhs ;
             Interlock1(LHSReg);
             WRITESDEST(dest) ;
             break ;

          case 0x22 : /* EOR immed */
             SINGLECYCLEINSTR ;
             dest = LHS ^ DPImmRHS ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x23 : /* EORS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS ^ rhs ;
             Interlock1(LHSReg);
             WRITESDEST(dest) ;
             break ;

          case 0x24 : /* SUB immed */
             SINGLECYCLEINSTR ;
             dest = LHS - DPImmRHS ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x25 : /* SUBS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = lhs - rhs ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARCV;
                }
#ifdef CODE16
             if (LHSReg == 15 && state->Processor & ARM_Code16_Prop) {
               WRITESDESTANDT(dest);
               instruction_size = INSTRUCTIONSIZE;
             } else
#endif
             {
               WRITESDEST(dest) ;
             }
             break ;

          case 0x26 : /* RSB immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS - LHS ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x27 : /* RSBS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = rhs - lhs ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SUBCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
                }
             else {
                CLEARCV;
                }
             WRITESDEST( dest) ;
             break ;

          case 0x28 : /* ADD immed */
             SINGLECYCLEINSTR ;
             dest = LHS + DPImmRHS ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x29 : /* ADDS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = lhs + rhs ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADDCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARNCV;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2a : /* ADC immed */
             SINGLECYCLEINSTR ;
             dest = LHS + DPImmRHS + CFLAG ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x2b : /* ADCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = lhs + rhs + CFLAG ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ADCCARRY(lhs,rhs,dest) ;
                ADDOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARNCV;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2c : /* SBC immed */
             SINGLECYCLEINSTR ;
             dest = LHS - DPImmRHS - !CFLAG ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x2d : /* SBCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = lhs - rhs - !CFLAG ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(lhs,rhs,dest) ;
                SUBOVERFLOW(lhs,rhs,dest) ;
                }
             else {
                CLEARCV;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2e : /* RSC immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS - LHS - !CFLAG ;
             Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x2f : /* RSCS immed */
             SINGLECYCLEINSTR ;
             lhs = LHS ;
             Interlock1(LHSReg);
             rhs = DPImmRHS ;
             dest = rhs - lhs - !CFLAG ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                SBCCARRY(rhs,lhs,dest) ;
                SUBOVERFLOW(rhs,lhs,dest) ;
                }
             else {
                CLEARCV;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x30 : /* TST immed */
             SINGLECYCLEINSTR ;
             Interlock1(LHSReg);
             UNDEF_Test ;
             break ;

          case 0x31 : /* TSTP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TSTP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS & DPImmRHS ;
                Interlock1(LHSReg);
                SETR15PSR(temp) ;
#endif
                }
             else {
                DPSImmRHS ; /* TST immed */
                dest = LHS & rhs ;
                Interlock1(LHSReg);
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x32 : /* TEQ immed and MSR immed to CPSR */
             SINGLECYCLEINSTR ;
             if (DESTReg==15 && BITS(17,18)==0) { /* MSR immed to CPSR */
                ARMul_FixCPSR(state,instr,DPImmRHS) ;
                }
             else {
                SINGLECYCLEINSTR ;
                UNDEF_Test ;
                }
             break ;

          case 0x33 : /* TEQP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* TEQP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS ^ DPImmRHS ;
                Interlock1(LHSReg);
                SETR15PSR(temp) ;
#endif
                }
             else {
                DPSImmRHS ; /* TEQ immed */
                dest = LHS ^ rhs ;
                Interlock1(LHSReg);
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x34 : /* CMP immed */
             SINGLECYCLEINSTR ;
             Interlock1(LHSReg);
             UNDEF_Test ;
             break ;

          case 0x35 : /* CMPP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* CMPP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS - DPImmRHS ;
                Interlock1(LHSReg);
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else {
                lhs = LHS ; /* CMP immed */
                Interlock1(LHSReg);
                rhs = DPImmRHS ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                   SUBCARRY(lhs,rhs,dest) ;
                   SUBOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARCV;
                   }
                }
             break ;

          case 0x36 : /* CMN immed and MSR immed to SPSR */
             SINGLECYCLEINSTR ;
             if (DESTReg==15 && BITS(17,18)==0) {/* MSR */
                ARMul_FixSPSR(state, instr, DPImmRHS) ;
             } else {
                SINGLECYCLEINSTR ;
                Interlock1(LHSReg);
                UNDEF_Test ;
                }
             break ;

          case 0x37 : /* CMNP immed */
             SINGLECYCLEINSTR ;
             if (DESTReg == 15) { /* CMNP immed */
#ifdef MODE32
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
#else
                temp = LHS + DPImmRHS ;
                Interlock1(LHSReg);
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else {
                lhs = LHS ; /* CMN immed */
                Interlock1(LHSReg);
                rhs = DPImmRHS ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ADDCARRY(lhs,rhs,dest) ;
                   ADDOVERFLOW(lhs,rhs,dest) ;
                   }
                else {
                   CLEARNCV;
                   }
                }
             break ;

          case 0x38 : /* ORR immed */
             SINGLECYCLEINSTR ;
             dest = LHS | DPImmRHS ;
            Interlock1(LHSReg);
             WRITEDEST(dest) ;
             break ;

          case 0x39 : /* ORRS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS | rhs ;
            Interlock1(LHSReg);
             WRITESDEST(dest) ;
             break ;

          case 0x3a : /* MOV immed */
             SINGLECYCLEINSTR ;
             dest = DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3b : /* MOVS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             WRITESDEST(rhs) ;
             break ;

          case 0x3c : /* BIC immed */
             SINGLECYCLEINSTR ;
             dest = LHS & ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3d : /* BICS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             dest = LHS & ~rhs ;
            Interlock1(LHSReg);
             WRITESDEST(dest) ;
             break ;

          case 0x3e : /* MVN immed */
             SINGLECYCLEINSTR ;
             dest = ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3f : /* MVNS immed */
             SINGLECYCLEINSTR ;
             DPSImmRHS ;
             WRITESDEST(~rhs) ;
             break ;
#endif
#ifdef PART1                    /* 0x40-0x7f */
/***************************************************************************\
*              Single Data Transfer Immediate RHS Instructions              *
\***************************************************************************/

          case 0x40 : /* Store Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (StoreWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x41 : /* Load Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x42 : /* Store Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             temp = lhs - LSImmRHS ;
             ARMul_SetNtrans(state,LOW) ;
             if (StoreWord(state,instr,lhs))
                LSBase = temp ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x43 : /* Load Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x44 : /* Store Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x45 : /* Load Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (LoadByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x46 : /* Store Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x47 : /* Load Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x48 : /* Store Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x49 : /* Load Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4a : /* Store Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x4b : /* Load Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x4c : /* Store Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4d : /* Load Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
            Interlock1(LHSReg);
             if (LoadByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4e : /* Store Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;

          case 0x4f : /* Load Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRImm ;
             lhs = LHS ;
            Interlock1(LHSReg);
             ARMul_SetNtrans(state,LOW) ;
             if (LoadByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
#ifndef CYCLEBASED
             ARMul_SetNtrans(state,-1) ;
#endif
             break ;


          case 0x50 : /* Store Word, No WriteBack, Pre Dec, Immed */
            Interlock1(LHSReg);
             (void)StoreWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x51 : /* Load Word, No WriteBack, Pre Dec, Immed */
            Interlock1(LHSReg);
             (void)LoadWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x52 : /* Store Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
            Interlock1(LHSReg);
             temp = LHS - LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x53 : /* Load Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
            Interlock1(LHSReg);
             temp = LHS - LSImmRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x54 : /* Store Byte, No WriteBack, Pre Dec, Immed */
            Interlock1(LHSReg);
             (void)StoreByte(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x55 : /* Load Byte, No WriteBack, Pre Dec, Immed */
            Interlock1(LHSReg);
             (void)LoadByte(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x56 : /* Store Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
            Interlock1(LHSReg);
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x57 : /* Load Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRImm ;
             temp = LHS - LSImmRHS ;
            Interlock1(LHSReg);
             if (LoadByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x58 : /* Store Word, No WriteBack, Pre Inc, Immed */
             (void)StoreWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x59 : /* Load Word, No WriteBack, Pre Inc, Immed */
            Interlock1(LHSReg);
#ifdef CODE16
            if (INSTRUCTION16STATE && LHSReg == 15) /* LDR rd, [pc,#word8]  note mask of pc */
              (void)LoadWord(state,instr,(LHS & PCBITS) + LSImmRHS) ;
             else
#endif
             (void)LoadWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5a : /* Store Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
            Interlock1(LHSReg);
             temp = LHS + LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5b : /* Load Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
            Interlock1(LHSReg);
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5c : /* Store Byte, No WriteBack, Pre Inc, Immed */
            Interlock1(LHSReg);
             (void)StoreByte(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5d : /* Load Byte, No WriteBack, Pre Inc, Immed */
            Interlock1(LHSReg);
             (void)LoadByte(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5e : /* Store Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
            Interlock1(LHSReg);
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5f : /* Load Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRImm ;
             temp = LHS + LSImmRHS ;
            Interlock1(LHSReg);
             if (LoadByte(state,instr,temp))
                LSBase = temp ;
             break ;

/***************************************************************************\
*              Single Data Transfer Register RHS Instructions               *
\***************************************************************************/

          case 0x60 : /* Store Word, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
               {
                 ARMul_UndefInstr(state,instr) ;
               }
             break ;

          case 0x61 : /* Load Word, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x62 : /* Store Word, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x63 : /* Load Word, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x64 : /* Store Byte, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x65 : /* Load Byte, No WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x66 : /* Store Byte, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x67 : /* Load Byte, WriteBack, Post Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs - LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x68 : /* Store Word, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x69 : /* Load Word, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6a : /* Store Word, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (StoreWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6b : /* Load Word, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (LoadWord(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6c : /* Store Byte, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6d : /* Load Byte, No WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6e : /* Store Byte, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (StoreByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x6f : /* Load Byte, WriteBack, Post Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                lhs = LHS ;
                Interlock2(LHSReg,RHSReg);
                ARMul_SetNtrans(state,LOW) ;
                if (LoadByte(state,instr,lhs))
                   LSBase = lhs + LSRegRHS ;
#ifndef CYCLEBASED
                ARMul_SetNtrans(state,-1) ;
#endif
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;


          case 0x70 : /* Store Word, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)StoreWord(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x71 : /* Load Word, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)LoadWord(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x72 : /* Store Word, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x73 : /* Load Word, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x74 : /* Store Byte, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)StoreByte(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x75 : /* Load Byte, No WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)LoadByte(state,instr,LHS - LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x76 : /* Store Byte, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x77 : /* Load Byte, WriteBack, Pre Dec, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS - LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x78 : /* Store Word, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)StoreWord(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x79 : /* Load Word, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)LoadWord(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7a : /* Store Word, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7b : /* Load Word, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadWord(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7c : /* Store Byte, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)StoreByte(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7d : /* Load Byte, No WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
               Interlock2(LHSReg,RHSReg);
                (void)LoadByte(state,instr,LHS + LSRegRHS) ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7e : /* Store Byte, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (StoreByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;

          case 0x7f : /* Load Byte, WriteBack, Pre Inc, Reg */
             if (!BIT(4)) {
                UNDEF_LSRReg ;
                temp = LHS + LSRegRHS ;
                Interlock2(LHSReg,RHSReg);
                if (LoadByte(state,instr,temp))
                   LSBase = temp ;
                }
             else
                ARMul_UndefInstr(state,instr) ;
             break ;
#endif
#ifdef PART2                    /* 0x80-0xbf */
/***************************************************************************\
*                   Multiple Data Transfer Instructions                     *
\***************************************************************************/

          case 0x80 : /* Store, No WriteBack, Post Dec */
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x81 : /* Load, No WriteBack, Post Dec */
            Interlock1(LHSReg);
             LOADMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x82 : /* Store, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x83 : /* Load, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
            Interlock1(LHSReg);
             LOADMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x84 : /* Store, Flags, No WriteBack, Post Dec */
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x85 : /* Load, Flags, No WriteBack, Post Dec */
            Interlock1(LHSReg);
             LOADSMULT(instr,LSMBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x86 : /* Store, Flags, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x87 : /* Load, Flags, WriteBack, Post Dec */
             temp = LSMBase - LSMNumRegs ;
            Interlock1(LHSReg);
             LOADSMULT(instr,temp + 4L,temp) ;
             break ;


          case 0x88 : /* Store, No WriteBack, Post Inc */
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,LSMBase,0L) ;
             break ;

          case 0x89 : /* Load, No WriteBack, Post Inc */
            Interlock1(LHSReg);
             LOADMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8a : /* Store, WriteBack, Post Inc */
             temp = LSMBase ;
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8b : /* Load, WriteBack, Post Inc */
             temp = LSMBase ;
            Interlock1(LHSReg);
             LOADMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8c : /* Store, Flags, No WriteBack, Post Inc */
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8d : /* Load, Flags, No WriteBack, Post Inc */
            Interlock1(LHSReg);
             LOADSMULT(instr,LSMBase,0L) ;
             break ;

          case 0x8e : /* Store, Flags, WriteBack, Post Inc */
             temp = LSMBase ;
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8f : /* Load, Flags, WriteBack, Post Inc */
             temp = LSMBase ;
            Interlock1(LHSReg);
#ifdef CODE16
             if (state->Processor & ARM_Code16_Prop) {
               LOADSMULTANDT(instr,temp,temp + LSMNumRegs) ;
               instruction_size = INSTRUCTIONSIZE;
             } else
#endif
             LOADSMULT(instr,temp,temp + LSMNumRegs) ;
             break ;


          case 0x90 : /* Store, No WriteBack, Pre Dec */
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x91 : /* Load, No WriteBack, Pre Dec */
            Interlock1(LHSReg);
             LOADMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x92 : /* Store, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,temp,temp) ;
             break ;

          case 0x93 : /* Load, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
            Interlock1(LHSReg);
             LOADMULT(instr,temp,temp) ;
             break ;

          case 0x94 : /* Store, Flags, No WriteBack, Pre Dec */
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x95 : /* Load, Flags, No WriteBack, Pre Dec */
            Interlock1(LHSReg);
             LOADSMULT(instr,LSMBase - LSMNumRegs,0L) ;
             break ;

          case 0x96 : /* Store, Flags, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,temp,temp) ;
             break ;

          case 0x97 : /* Load, Flags, WriteBack, Pre Dec */
             temp = LSMBase - LSMNumRegs ;
            Interlock1(LHSReg);
             LOADSMULT(instr,temp,temp) ;
             break ;


          case 0x98 : /* Store, No WriteBack, Pre Inc */
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x99 : /* Load, No WriteBack, Pre Inc */
            Interlock1(LHSReg);
             LOADMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9a : /* Store, WriteBack, Pre Inc */
             temp = LSMBase ;
             Interlock1(LHSReg);
             STMInterlock;
             STOREMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9b : /* Load, WriteBack, Pre Inc */
             temp = LSMBase ;
            Interlock1(LHSReg);
             LOADMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9c : /* Store, Flags, No WriteBack, Pre Inc */
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9d : /* Load, Flags, No WriteBack, Pre Inc */
            Interlock1(LHSReg);
             LOADSMULT(instr,LSMBase + 4L,0L) ;
             break ;

          case 0x9e : /* Store, Flags, WriteBack, Pre Inc */
             temp = LSMBase ;
             Interlock1(LHSReg);
             STMInterlock;
             STORESMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9f : /* Load, Flags, WriteBack, Pre Inc */
             temp = LSMBase ;
             Interlock1(LHSReg);
             LOADSMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

/***************************************************************************\
*                            Branch forward                                 *
\***************************************************************************/

          case 0xa0 : case 0xa1 : case 0xa2 : case 0xa3 :
          case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 :
             state->Reg[15] = pc + PCR15DIFFERENCE32 + POSBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                           Branch backward                                 *
\***************************************************************************/

          case 0xa8 : case 0xa9 : case 0xaa : case 0xab :
          case 0xac : case 0xad : case 0xae : case 0xaf :
             state->Reg[15] = pc + PCR15DIFFERENCE32 + NEGBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                       Branch and Link forward                             *
\***************************************************************************/

          case 0xb0 : case 0xb1 : case 0xb2 : case 0xb3 :
          case 0xb4 : case 0xb5 : case 0xb6 : case 0xb7 :
#ifdef MODE32
             state->Reg[14] = pc + INSTRUCTION32SIZE ; /* put PC into Link */
#else
             state->Reg[14] = (pc + INSTRUCTION32SIZE) | ECC | ER15INT | EMODE ; /* put PC into Link */
#endif
             state->Reg[15] = pc + PCR15DIFFERENCE32 + POSBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;

/***************************************************************************\
*                       Branch and Link backward                            *
\***************************************************************************/

          case 0xb8 : case 0xb9 : case 0xba : case 0xbb :
          case 0xbc : case 0xbd : case 0xbe : case 0xbf :
#ifdef MODE32
             state->Reg[14] = pc + INSTRUCTION32SIZE ; /* put PC into Link */
#else
             state->Reg[14] = (pc + INSTRUCTION32SIZE) | ECC | ER15INT | EMODE ; /* put PC into Link */
#endif
             state->Reg[15] = pc + PCR15DIFFERENCE32 + NEGBRANCH ;
             FLUSHPIPE ;
#ifdef CYCLEBASED
             state->NextCycle = DESTPC2 ;
             state->addr01Bus = 0 ;
#endif
             break ;
#endif
#ifdef PART3                    /* 0xc0-0xff */
/***************************************************************************\
*                        Co-Processor Data Transfers                        *
\***************************************************************************/

          case 0xc0 :
          case 0xc4 : /* Store , No WriteBack , Post Dec */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc1 :
          case 0xc5 : /* Load , No WriteBack , Post Dec */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xc2 :
          case 0xc6 : /* Store , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xc3 :
          case 0xc7 : /* Load , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xc8 :
          case 0xcc : /* Store , No WriteBack , Post Inc */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc9 :
          case 0xcd : /* Load , No WriteBack , Post Inc */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xca :
          case 0xce : /* Store , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xcb :
          case 0xcf : /* Load , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_LDC(state,instr,LHS) ;
             break ;


          case 0xd0 :
          case 0xd4 : /* Store , No WriteBack , Pre Dec */
             ARMul_STC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd1 :
          case 0xd5 : /* Load , No WriteBack , Pre Dec */
             ARMul_LDC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd2 :
          case 0xd6 : /* Store , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xd3 :
          case 0xd7 : /* Load , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xd8 :
          case 0xdc : /* Store , No WriteBack , Pre Inc */
             ARMul_STC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xd9 :
          case 0xdd : /* Load , No WriteBack , Pre Inc */
             ARMul_LDC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xda :
          case 0xde : /* Store , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xdb :
          case 0xdf : /* Load , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

/***************************************************************************\
*            Co-Processor Register Transfers (MCR) and Data Ops             *
\***************************************************************************/

          case 0xe0 : case 0xe2 : case 0xe4 : case 0xe6 :
          case 0xe8 : case 0xea : case 0xec : case 0xee :
             if (BIT(4)) { /* MCR */
                if (DESTReg == 15) {
                   UNDEF_MCRPC ;
#ifdef MODE32
                   ARMul_MCR(state,instr,state->Reg[15] + INSTRUCTION32SIZE) ;
#else
                   ARMul_MCR(state,instr,ECC | ER15INT | EMODE |
                             ((state->Reg[15] + INSTRUCTION32SIZE) & R15PCBITS) ) ;
#endif
                   }
                else
                   ARMul_MCR(state,instr,DEST) ;
                }
             else /* CDP Part 1 */
                ARMul_CDP(state,instr) ;
             break ;

/***************************************************************************\
*            Co-Processor Register Transfers (MRC) and Data Ops             *
\***************************************************************************/

          case 0xe1 : case 0xe3 : case 0xe5 : case 0xe7 :
          case 0xe9 : case 0xeb : case 0xed : case 0xef :
             if (BIT(4)) { /* MRC */
#ifdef CYCLEBASED
                (void)ARMul_MRC(state,instr) ;
#else
                temp = ARMul_MRC(state,instr) ;
                if (DESTReg == 15) {
                   state->Flags = temp>>28;
                   }
                else
                   DEST = temp ;
#endif
                }
             else /* CDP Part 2 */
                ARMul_CDP(state,instr) ;
             break ;

/***************************************************************************\
*                             SWI instruction                               *
\***************************************************************************/

          case 0xf0 : case 0xf1 : case 0xf2 : case 0xf3 :
          case 0xf4 : case 0xf5 : case 0xf6 : case 0xf7 :
          case 0xf8 : case 0xf9 : case 0xfa : case 0xfb :
          case 0xfc : case 0xfd : case 0xfe : case 0xff :
             if (instr == ARMul_ABORTWORD && state->AbortAddr == pc) { /* a prefetch abort */
                ARMul_Abort(state,ARMul_PrefetchAbortV,0);
                break ;
             }

             if ((state->Processor & ARM_SubPage_Prop) &&
                 state->proc.arm7.decoded==ARMul_ABORTWORD &&
                 state->AbortAddr==pc+4) {
               ARMword new_instr;
               /* ARM7 abort bug (maybe) - reload real instruction */
               while (MEM_ACCESS(state)(state->mem.handle,pc,&new_instr,
                                        acc_DontAccount(acc_LoadInstrS))==0 &&
                      Hourglass())
                 ;
               instr=new_instr;
             }

#ifdef CYCLEBASED
             ARMul_Abort(state,ARMul_SWIV) ;
#else
            if (state->os.handle_swi==NULL ||
                !state->os.handle_swi(state->os.handle,BITS(0,23))) {
               ARMul_Abort(state,ARMul_SWIV,BITS(0,23));
             } else {
               SINGLECYCLEINSTR ;
             }
#endif
             break ;
#endif

#if 0
}
#endif
