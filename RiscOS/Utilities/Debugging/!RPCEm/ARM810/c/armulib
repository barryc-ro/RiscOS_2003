/* armulib.c - shared functions for ARMulators */
/* Copyright (C) Advanced RISC Machines Limited, 1996. All rights reserved. */

/* RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include <string.h>
#include <ctype.h>
#include <time.h>
#include "armdefsp.h"
#include "multirdi.h"
#include "dbg_cp.h"
#include "dbg_conf.h"
#include "dbg_rdi.h"
#include "dbg_hif.h"
#include "linklist.h"

#include "toolconf.h"

void ARMul_DebugPrint_i(const Dbg_HostosInterface *hostif,
                        const char *format, ...)
{ va_list ap;
  va_start(ap, format);
//  hostif->dbgprint(hostif->dbgarg, format, ap);
  va_end(ap);
}

void ARMul_DebugPrint(ARMul_State *state, const char *format, ...)
{ va_list ap;
  va_start(ap, format);
  if(!(state->rdi_log & RDILog_NoDebug))
    state->hostif->dbgprint(state->hostif->dbgarg, format, ap);
  va_end(ap);
}

#define CONSOLE_PRINT_MAX_LEN 128

void ARMul_ConsolePrint_i(const Dbg_HostosInterface *hostif,
                          const char *format, ...)
{
  va_list ap;
  char buf[CONSOLE_PRINT_MAX_LEN],*p;
  
  va_start(ap, format);
  vsprintf(buf, format, ap);
  va_end(ap);
  
//  for (p=buf;*p;p++)
//    hostif->writec(hostif->hostosarg, *p);
}

void ARMul_ConsolePrint(ARMul_State *state, const char *format, ...)
{
  va_list ap;
  char buf[CONSOLE_PRINT_MAX_LEN],*p;
  
  va_start(ap, format);
  vsprintf(buf, format, ap);
  va_end(ap);
  
  for (p=buf;*p;p++)
    state->hostif->writec(state->hostif->hostosarg, *p);
}

static void putstring(ARMul_State *state, int len, const char *string)
{
  const char *p=string;
  int i;
  
  for (i=0;i<len;i++,p++)
    state->hostif->writec(state->hostif->hostosarg, *p);
  state->hostif->writec(state->hostif->hostosarg, '\n');
}

static unsigned int columns=77;          /* make this defineable */

/*
 * This function builds up characters into a buffer ('build') from
 * the printf string supplied, and then prints out that text once there
 * is a line-full, using some simple heuristics to decide where to break
 * the line.
 */

void ARMul_PrettyPrint(ARMul_State *state, const char *format, ...)
{
  va_list ap;
  static char build[CONSOLE_PRINT_MAX_LEN]="";
  static unsigned int len=0,lastspc=0,lastpunc=0;
  char buf[CONSOLE_PRINT_MAX_LEN];
  unsigned int j;
  
  va_start(ap, format);
  vsprintf(buf, format, ap);
  va_end(ap);
  
  j=0;
  
  while (1) {
    unsigned int i,brk;
    for (i=len;i<columns;j++)
      if (buf[j]=='\0') {
        len=i;
        return;
      } else if (buf[j]=='\n') {
        putstring(state,i,build);
        /* ARMul_DebugPrint(state,"%.*s\n",i,build); */
        i=len=lastspc=lastpunc=0;
      } else {
        build[i]=buf[j];
        if (isspace(buf[j])) {
          lastspc=i;
        } else if (buf[j]==',' || buf[j]==';' || buf[j]==':') {
          lastpunc=i;
        }
        i++;
      }
    /* Copied enough characters for a line */
    if (lastpunc) {             /* break at last punctuation... */
      if (lastspc-lastpunc > 10) /* ...unless there's a space much nearer */
        brk=lastspc;
      else
        brk=lastpunc+1;
    } else if (lastspc && lastspc>columns*3/4)
      /* otherwise break at the last space, as long as it isn't too far
       * back down the line. */
      brk=lastspc;
    else
      brk=columns;
    
    putstring(state,brk,build);
    /* ARMul_DebugPrint(state,"%.*s\n",brk,build); */
    
    while (brk<columns && isspace(build[brk]))
      brk++;
    
    build[0]=build[1]=' ';
    
    for (len=2;brk<columns;brk++,len++)
      build[len]=build[brk];
  }
}

void ARMul_DebugPause(ARMul_State *state)
{
  if(!(state->rdi_log & RDILog_NoDebug))
    state->hostif->dbgpause(state->hostif->dbgarg);
}

/***************************************************************************\
*       Call this routine to set ARMulator to model a certain processor     *
\***************************************************************************/

static const struct {
  char *option;
  unsigned long flag;
  char *verbose;
} ProcessorOption[] = {
  "LateAborts",   ARM_Abort7_Prop,            ", Late Aborts",
  "MultipleEarlyAborts",  ARM_Abort8_Prop,    "",
  "LongMultiply", ARM_Mult64_Prop,            ", Long Multiplies",
  "Halfword",     ARM_Halfword_Prop,          ", Half-word Support",
  "ThumbAware",   ARM_Code16_Prop,            ", Thumb-Aware",
  "Thumb",        ARM_Code16_Prop | ARM_Halfword_Prop | ARM_System32_Prop,
                                              ", Thumb",
  "Cached",       ARM_Cache_Prop,             ", Cached",
  "System32",     ARM_System32_Prop,          "",
  "Fix26",        ARM_Fix26_Prop,             ", Fixed 26-bit mode configuration",
  "Nexec",        ARM_Nexec_Prop,             "",
  "Debug",        ARM_Debug_Prop,             "",
  "Isync",        ARM_Isync_Prop,             "",
  "Lock",         ARM_Lock_Prop,              "",
  "StrongARMAware",    ARM_StrongARM_Prop,    "",
  "Prefetch",     ARM_ARM8_Prop,              "",
  "NoLDCSTC",     ARM_NoLDCSTC_Prop,          "",
  "NoCDP",        0, /* need to allocate a bit */  "",
  "SubPage",      ARM_SubPage_Prop,           "",
  "Multiply",     ARM_Mult32_Prop,            ", Multiplier",
  
  NULL, 0, NULL
  }, Architecture[] = {
  "1",  ARM_Arch_1,  NULL,
  "2",  ARM_Arch_2,  NULL,
  "2a", ARM_Arch_2a, NULL,
  "3",  ARM_Arch_3,  NULL,
  "3G", ARM_Arch_3G, NULL,
  "3M", ARM_Arch_3M, NULL,
  "4",  ARM_Arch_4,  NULL,
  "4T", ARM_Arch_4T, NULL,
  NULL, 0, NULL
  };

extern ARMul_MemStub *ARMul_Memories[];
extern ARMul_OSStub *ARMul_OSs[];

/*
 * A dummy clock function. Useful in circumstances where a clock that
 * always returns zero would be fatal, but where the memory interface
 * doesn't supply a clock function, and different runs of the program
 * must be repeatable.
 */
static unsigned long clock_counter(void *handle)
{
  static int counter=0;
  IGNORE(handle);
  return counter++;
}

void ARMul_SetReadClock(ARMul_State *state)
{
  char *option;
  /* If the user wants real rather than emulated time, force that here. */
  /* @@@ must be moved to after the memory interface is initialised */
  option=(void *)ToolConf_Lookup(state->config,"CLOCK");
  if (option) {
    if (ToolConf_Cmp(option,"REAL")) {
      state->mem.read_clock=NULL;
    } else if (ToolConf_Cmp(option,"COUNTER")) {
      state->mem.read_clock=clock_counter;
    } else if (!ToolConf_Cmp(option,"EMULATED")) { 
      ARMul_DebugPrint(state,"\nUnrecognised clock - '%s'\
 (assuming emulated).\n",
                       option);
    }
  }
}

/*
 * Find, in tconf, the config with name "confname", optionally
 * allowing chains of aliases.
 */

//
typedef void *toolconf;

toolconf ARMul_FindConfig(toolconf tconf,const char *confname)
{
  toolconf new;

  if (ToolConf_Cmp(confname,"DEFAULT")) {
    const char *newname;
    newname=(void *)ToolConf_Lookup(tconf,confname);
    if (newname) confname=newname;
  }
  
  new=(void *)ToolConf_FlatChild(tconf,confname);
  if (new==NULL) {
    char *option;
    toolconf new2;
    
    option=(void *)ToolConf_FlatLookup(tconf,confname);
    if (option==NULL) return NULL;
    /* "option" is of the form ME=OTHER
     * This means for processor "ME":
     *   -  Lookup the configuration for "OTHER"
     *   -  Lookup variant "ME" in that configuration
     */
    
    new=(void *)ToolConf_FlatChild(tconf,option);
    if (new==NULL) return NULL;
    
    new2=ARMul_FindConfig(new,confname);
    return new2 ? new2 : new;
  } else {
    return new;
  }
}    

armul_MemInit *ARMul_FindMemoryInterface(ARMul_State *state,
                                         const char *option,
                                         toolconf *wrconfig)
{
  int i;
  toolconf config,child;
  const char *model;
  
  IGNORE(state);
  
  if (option==NULL) option="DEFAULT";
  
  if ((config=(void *)ToolConf_Child(ARMul_ToolConfBase,"MEMORIES"))==NULL ||
      (model=(void *)ToolConf_Lookup(config,option))==NULL)
    return NULL;
  
  child=ARMul_FindConfig(config,option);
  
  if (model[0]=='\0')
    model=option;
  
  if (child && (option=(void *)ToolConf_Lookup(child,"MODEL"))!=NULL)
    model=option;
  
  /* Install a memory model */
  if (model) {
    for (i=0;ARMul_Memories[i];i++)
      if (ToolConf_Cmp(model,ARMul_Memories[i]->name)) {
        *wrconfig=child ? child : config;
        return ARMul_Memories[i]->init;
      }
  }
  return NULL;
}  

ARMul_Error ARMul_SelectProcessor(ARMul_State *state)
{
  char *option;
  unsigned int i;
  unsigned processor=0;
  int verbose=0;
  
  option=(void *)ToolConf_Lookup(state->config,"VERBOSE");
  if (option) verbose=ToolConf_AddFlag(option,0,1,TRUE);
  
  /* modify the processor from the config database */
  option=(void *)ToolConf_Lookup(state->config,"Architecture");
  if (option) {
    for (i=0;Architecture[i].option!=NULL;i++)
      if (ToolConf_Cmp(option,Architecture[i].option)) {
        processor|=Architecture[i].flag;
        if (verbose)
          ARMul_PrettyPrint(state,", Architecture v.%s",
                            Architecture[i].option);
      }
  }

  for (i=0;ProcessorOption[i].option!=NULL;i++) {
    char *option=(void *)ToolConf_Lookup(state->config,
                                 ProcessorOption[i].option);
    if (option) {
      processor=ToolConf_AddFlag(option,processor,
                                 ProcessorOption[i].flag,TRUE);
      if (verbose && (processor & ProcessorOption[i].flag))
        ARMul_PrettyPrint(state,ProcessorOption[i].verbose);
    }
  }

  if (processor & ARM_Fix26_Prop) {
    state->prog32Sig = LOW;
    state->data32Sig = LOW;
  } else {
    state->prog32Sig = HIGH;
    state->data32Sig = HIGH;
  }

  if (processor & ARM_Abort7_Prop) {
    if (processor & ARM_Abort8_Prop) {
      char *opta,*optb;
      opta=optb="<Error>";
      for (i=0;ProcessorOption[i].option!=NULL;i++)
        if (ProcessorOption[i].flag==ARM_Abort7_Prop) {
          opta=ProcessorOption[i].option;
          break;
        }
      for (i=0;ProcessorOption[i].option!=NULL;i++)
        if (ProcessorOption[i].flag==ARM_Abort8_Prop) {
          optb=ProcessorOption[i].option;
          break;
        }
      return ARMul_RaiseError(state,ARMulErr_IncompatibleOptions,
                              opta,optb);
    }
    state->lateabtSig = HIGH;
  } else
    state->lateabtSig = LOW;

  state->arm_config=((state->prog32Sig ? MMU_P : 0) |
                     (state->data32Sig ? MMU_D : 0) |
                     (state->bigendSig ? MMU_B : 0) |
                     (state->lateabtSig ? MMU_L : 0) |
                     (state->branchpredictSig ? MMU_Z : 0));
  
  option=(void *)ToolConf_Lookup(state->config,"MEMORY");
  state->mem_init=ARMul_FindMemoryInterface(state,option,&state->mem_config);
  if (state->mem_init==NULL)
    return ARMul_RaiseError(state,ARMulErr_NoMemoryType);

  option=(void *)ToolConf_Lookup(state->config,"COPROCESSORBUS");
  state->cp_init=ARMul_FindCPInterface(state,option,&state->cp_config);
  if (state->cp_init==NULL)
    return ARMul_RaiseError(state,ARMulErr_NoCopType);

  state->cp_sibling=NULL;

  /* All ARMulators can have OS models */

  /* Install an Operating System */
  option=(void *)ToolConf_Lookup(state->config,"OS");
  if (option) {
    for (i=0;ARMul_OSs[i];i++)
      if (ToolConf_Cmp(option,ARMul_OSs[i]->name)) {
        state->os_init=ARMul_OSs[i]->init;
        goto installed_os;
      }
  }
  /* no OS configured - default to No OS at all! */

 installed_os:
  state->Processor = processor;
  return ARMulErr_NoError;
}

/*
 * Instantiate all the "bare" models that are listed in the "Models"
 * part of the configuration file.
 * The entire list of known models is taken, and the model instantiated
 * if either an entry or a configuration is found for it.
 */

ARMul_Error ARMul_StartModels(ARMul_State *state)
{
  toolconf config;
  extern ARMul_ModelStub *ARMul_Models[];
  int i;
  ARMul_Error err;

  config=(void *)ToolConf_Child(ARMul_ToolConfBase,"MODELS");
  if (config==NULL) return ARMulErr_NoError; /* list of models not found */

  for (i=0; ARMul_Models[i]; i++) {
    const char *option=ARMul_Models[i]->name;
    if (ToolConf_Lookup(config,option)) {
      toolconf child=ARMul_FindConfig(config,option);
      err=ARMul_Models[i]->init(state,child ? child : config);
      if (err!=ARMulErr_NoError) return err;
    }
  }

  return ARMulErr_NoError;
}

/*
 * Given a processor mode, this routine returns the register bank that
 * will be accessed in that mode.
 */

static const char bankofmode[] = {
  USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
  USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, ABORTBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK,
  DUMMYBANK, DUMMYBANK, DUMMYBANK, USERBANK
  };

ARMword ARMul_ModeToBank(ARMul_State *state, ARMword mode)
{
  if (mode==CURRENTMODE) return state->Bank;
  mode &= MODEBITS;
  if (mode > (ARMword)((state->Processor & ARM_System32_Prop) ? SYSTEM32MODE : UNDEF32MODE))
    return DUMMYBANK;
  else
    return bankofmode[mode];
}

/*
 * This routine controls the saving and restoring of registers across mode
 * changes.  The regbank matrix is largely unused, only rows 13 and 14 are
 * used across all modes, 8 to 14 are used for FIQ, all others use the USER
 * column.  It's easier this way.  old and new parameter are modes numbers.
 * Notice the side effect of changing the Bank variable.
 */

ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode)
{
  unsigned i;
  ARMword oldbank = ARMul_ModeToBank(state, oldmode);
  
  state->Bank = ARMul_ModeToBank(state,newmode);
  if (oldbank != state->Bank) { /* really need to do it */
    switch (oldbank) { /* save away the old registers */
    case USERBANK:
    case IRQBANK:
    case SVCBANK:
    case ABORTBANK:
    case UNDEFBANK:
      if (state->Bank == FIQBANK)
        for (i = 8; i < 13; i++)
          state->RegBank[USERBANK][i] = state->Reg[i];
      state->RegBank[oldbank][13] = state->Reg[13];
      state->RegBank[oldbank][14] = state->Reg[14];
      break;
    case FIQBANK:
      for (i = 8; i < 15; i++)
        state->RegBank[FIQBANK][i] = state->Reg[i];
      break;
    case DUMMYBANK:
      for (i = 8; i < 15; i++)
        state->RegBank[DUMMYBANK][i] = 0;
      break;
    }
    switch (state->Bank) { /* restore the new registers */
    case USERBANK:
    case IRQBANK:
    case SVCBANK:
    case ABORTBANK:
    case UNDEFBANK:
      if (oldbank == FIQBANK)
        for (i = 8; i < 13; i++)
          state->Reg[i] = state->RegBank[USERBANK][i];
      state->Reg[13] = state->RegBank[state->Bank][13];
      state->Reg[14] = state->RegBank[state->Bank][14];
      break;
    case FIQBANK:
      for (i = 8; i < 15; i++)
        state->Reg[i] = state->RegBank[FIQBANK][i];
      break;
    case DUMMYBANK:
      for (i = 8; i < 15; i++)
        state->Reg[i] = 0;
      break;
    }
  }

  return newmode;
}

/*
 * Function that handles actually changing mode.
 * Calls SwitchMode and then the mode change callbacks
 */

ARMword ARMul_ChangeMode(ARMul_State *state,ARMword newmode)
{
  ARMword oldmode=state->Mode;

  ARMul_SwitchMode(state,oldmode,newmode);

  state->Mode=newmode;
  
  ARMul_CallModeChange(state,oldmode);
  ARMul_SetNtrans(state, -1);

  return newmode;
}

/*
 * Function that determines whether an instruction passes given the
 * current Flags.
 */
static const unsigned short psr_table[] = {
  /*
   * Each entry is for a particular PSR flags setting - BIT(n) of each entry
   * is set if that condition code (EQ ... NV) succeeds for that PSR setting.
   */
  0x56aa,0x6a6a,0x55a6,0x6966,
  0x66a9,0x6a69,0x66a5,0x6a65,
  0x6a9a,0x565a,0x6996,0x5556,
  0x6a99,0x6659,0x6a95,0x6655
};

unsigned ARMul_CondCheckInstr(ARMul_State *state,ARMword instr)
{
  return (psr_table[state->Flags] >> (instr>>28)) & 1;
}

/*
 * Method functions for accessing an ARMul_State
 */

/*
 * state->Exception is used to encode a variety of exception flags. call
 * this function when one of them changes - high or low.
 *
 * Things that can change:
 *   NresetSig
 *   NfiqSig
 *   NirqSig
 *   CPSR I/F flags
 *   trace
 *   EventSet
 */

void ARMul_SetException(ARMul_State *state)
{
  state->Exception = ((state->NresetSig == LOW) ||
                      (state->NfiqSig == LOW && !FFLAG) ||
                      (state->NirqSig == LOW && !IFLAG) ||
                      (state->hourglass != NULL) ||
                      (state->EventSet != 0));
}


/*
 * Raise an interrupt, etc.
 */
unsigned ARMul_SetNirq(ARMul_State *state,unsigned value)
{
  unsigned oldvalue=state->NirqSig;
  state->NirqSig=value;

  ARMul_SetException(state);

  return oldvalue;
}

unsigned ARMul_SetNfiq(ARMul_State *state,unsigned value)
{
  unsigned oldvalue=state->NfiqSig;
  state->NfiqSig=value;

  ARMul_SetException(state);

  return oldvalue;
}

unsigned ARMul_SetNreset(ARMul_State *state,unsigned value)
{
  unsigned oldvalue=state->NresetSig;
  state->NresetSig=value;

  ARMul_SetException(state);

  return oldvalue;
}

unsigned ARMul_SetNtrans(ARMul_State *state,int new)
{
  unsigned oldvalue=state->NtransSig;
  unsigned newvalue;

  newvalue = (new==-1) ? ((state->Mode & 3) ? HIGH : LOW) : new;

  if (oldvalue!=newvalue) {
    state->NtransSig=newvalue;
    ARMul_CallTransChange(state,oldvalue);
  }

  return oldvalue;
}

/*
 * Set various abort things
 */

/*
 * Return the current processor mode.
 */

ARMword ARMul_GetMode(ARMul_State *state)
{
  return state->Mode;
}


/*
 * Halt emulation at the end of this cycle
 */
void ARMul_HaltEmulation(ARMul_State *state,
                         unsigned end_condition)
{
  state->Emulate=STOP;
  state->EndCondition=end_condition;
}

unsigned ARMul_EndCondition(ARMul_State *state)
{
  return state->EndCondition;
}

/*
 * Return a pointer to the ARMulator's back channel to the debugger
 */
const Dbg_HostosInterface *ARMul_HostIf(ARMul_State *state)
{
  return (Dbg_HostosInterface *)state->hostif;
}


/*
 * Set/Return the memory size (used by debug monitor/memory models for
 * setting up stacks etc.)
 */
ARMword ARMul_SetMemSize(ARMul_State *state,ARMword size)
{
  ARMword old=state->MemSize;
  state->MemSize=size;
  return old;
}

ARMword ARMul_GetMemSize(ARMul_State *state)
{
  return state->MemSize;
}


/*
 * Set late aborts, bigend etc. - call upcalls
 */

ARMword ARMul_SetConfig(ARMul_State *state,ARMword changed,ARMword config)
{
  ARMword old=state->arm_config;

  if (state->Processor & ARM_Abort7_Prop)
    config |= MMU_L;

  if (state->Processor & ARM_Abort8_Prop)
    config &= ~MMU_L;

  if (state->Processor & ARM_Fix26_Prop)
    config &= ~(MMU_P | MMU_D);

  if (!(state->Processor & ARM_ARM8_Prop))
    config &= ~MMU_Z;

  config=(state->arm_config & ~changed) | (config & changed);
  config&=MMU_B | MMU_P | MMU_D | MMU_L | MMU_Z;

  if (config==old) return config;

  state->arm_config=config;

  state->bigendSig=(config >> MMU_B_bit) & 1;
  state->prog32Sig=(config >> MMU_P_bit) & 1;
  state->data32Sig=(config >> MMU_D_bit) & 1;
  state->lateabtSig=(config >> MMU_L_bit) & 1;
  state->branchpredictSig=(config >> MMU_Z_bit) & 1;

  ARMul_CallConfigChange(state,old);

  return old;
}

/*
 * Execute a program
 */

ARMword ARMul_DoProg(ARMul_State *state)
{
  return state->rdi.do_prog(state);
}

/*
 * Execute a single instruction
 */

ARMword ARMul_DoInstr(ARMul_State *state)
{
  return state->rdi.do_instr(state);
}

/*
 * Set/Get a normal register
 */

ARMword ARMul_GetReg(ARMul_State *state,unsigned mode,unsigned reg)
{
  return state->rdi.get_reg(state,mode,reg);
}
void ARMul_SetReg(ARMul_State *state,unsigned mode,unsigned reg,ARMword value)
{
  state->rdi.set_reg(state,mode,reg,value);
}

/*
 * Set/Get the PC
 */

ARMword ARMul_GetPC(ARMul_State *state)
{
  return state->rdi.get_pc(state);
}
void ARMul_SetPC(ARMul_State *state,ARMword value)
{
  state->rdi.set_pc(state,value);
}

/*
 * Set/Get R15 (PC + PSR flags in 26-bit modes)
 */
ARMword ARMul_GetR15(ARMul_State *state)
{
  return state->rdi.get_r15(state);
}
void ARMul_SetR15(ARMul_State *state,ARMword value)
{
  state->rdi.set_r15(state,value);
}

/*
 * Set/Get the CPSR
 */
ARMword ARMul_GetCPSR(ARMul_State *state)
{
  return state->rdi.get_cpsr(state);
}
void ARMul_SetCPSR(ARMul_State *state,ARMword value)
{
  state->rdi.set_cpsr(state,value);
}

/*
 * Set/Get an SPSR
 */
ARMword ARMul_GetSPSR(ARMul_State *state,ARMword mode)
{
  return state->rdi.get_spsr(state,mode);
}
void ARMul_SetSPSR(ARMul_State *state,ARMword mode,ARMword value)
{
  state->rdi.set_spsr(state,mode,value);
}

static armul_MemAccess *GetMemAccess(ARMul_State *state)
{
  if (state->Processor & ARM_StrongARM_Prop) {
    return state->mem.x.strongarm.access;
  } else if (state->Processor & ARM_ARM8_Prop) {
    return state->mem.x.arm8.access;
  } else {
    return state->mem.x.basic.access;
  }
}

/*
 * Memory access functions - @@@ needs modifying for new memory i/f things
 */
void ARMul_Icycles(ARMul_State *state, unsigned number, ARMword address)
{
  armul_MemAccess *mem_access=GetMemAccess(state);
  int hourglass_counter=8192;
  while (number && Hourglass()) {
    if (mem_access(state->mem.handle,address,0L,acc_Icycle)!=0)
      number--;
  }   
}

void ARMul_Ccycles(ARMul_State *state, unsigned number, ARMword address)
{
  armul_MemAccess *mem_access=GetMemAccess(state);
  int hourglass_counter=8192;
  while (number && Hourglass()) {
    if (mem_access(state->mem.handle,address,0L,acc_Ccycle)!=0)
      number--;
  }
}

static ARMword Read(ARMul_State *state,ARMword address,ARMul_acc acc)
{
  ARMword w;
  if (state->rdi_mem_access) {
    switch (state->rdi_mem_access(state,address,&w,acc)) {
    case 0: break;
    case 1: return w;
    case -1: state->abortSig=LOW; return w;
    }
  }
  if (GetMemAccess(state)(state->mem.handle,address,&w,acc)!=1) {
    state->abortSig=-1;
  }
  return w;
}

ARMword ARMul_ReadWord(ARMul_State *state, ARMword address)
{
  return Read(state,address,acc_ReadWord);
}

ARMword ARMul_ReadHalfWord(ARMul_State *state, ARMword address)
{
  return Read(state,address,acc_ReadHalfWord);
}

ARMword ARMul_ReadByte(ARMul_State *state, ARMword address)
{
  return Read(state,address,acc_ReadByte);
}

static void Write(ARMul_State *state,ARMword address,ARMword data,ARMul_acc acc)
{
  if (state->rdi_mem_access) {
    switch (state->rdi_mem_access(state,address,&data,acc)) {
    case 0: break;
    case 1: return;
    case -1: state->abortSig=LOW; return;
    }
  }
  if (GetMemAccess(state)(state->mem.handle,address,&data,acc)!=1) {
    state->abortSig=-1;
  }
}


void ARMul_WriteWord(ARMul_State *state, ARMword address, ARMword data)
{
  Write(state,address,data,acc_WriteWord);
}

void ARMul_WriteHalfWord(ARMul_State *state, ARMword address, ARMword data)
{
  Write(state,address,data,acc_WriteHalfWord);
}

void ARMul_WriteByte(ARMul_State *state, ARMword address, ARMword data)
{
  Write(state,address,data,acc_WriteByte);
}

/* Installed function to feed mode changes to the event handler */
static void trace_mode_changes(void *handle,ARMword old,ARMword new)
{
  ARMul_State *state=(ARMul_State *)handle;

  IGNORE(old);

  ARMul_RaiseEvent(state,CoreEvent_ModeChange,ARMul_GetPC(state),new);
}

static void trace_interrupts(void *handle,unsigned int which)
{
  ARMul_State *state=(ARMul_State *)handle;
  ARMword pc=ARMul_GetPC(state);

  if (which & ARMul_InterruptUpcallFIQ)
    ARMul_RaiseEvent(state,CoreEvent_FIQSpotted,pc,0);

  if (which & ARMul_InterruptUpcallIRQ)
    ARMul_RaiseEvent(state,CoreEvent_IRQSpotted,pc,0);

  if (which & ARMul_InterruptUpcallReset)
    ARMul_RaiseEvent(state,CoreEvent_Reset,pc,0);
}

/*
 * Return the ARM's property word
 */
ARMword ARMul_Properties(ARMul_State *state)
{
  return state->Processor;
}


/*
 * Return the RDI log level
 */
unsigned32 ARMul_RDILog(ARMul_State *state)
{
  return state->rdi_log;
}


/*
 * Return clock from the top-level memory model
 */

#ifndef CLOCKS_PER_SEC
#  ifdef CLK_TCK
#    define CLOCKS_PER_SEC CLK_TCK
#  else
/* assume 1000000 clocks/sec */
#    define CLOCKS_PER_SEC 1000000
#  endif
#endif

unsigned long ARMul_ReadClock(ARMul_State *state)
{
  if (state->mem.read_clock!=NULL) {
    return state->mem.read_clock(state->mem.handle);
  } else {
#if   CLOCKS_PER_SEC >= 1000000
#  define RANGE 1000000
#elif CLOCKS_PER_SEC >= 100000
#  define RANGE 100000
#elif CLOCKS_PER_SEC >= 10000
#  define RANGE 10000
#elif CLOCKS_PER_SEC >= 1000
#  define RANGE 1000
#elif CLOCKS_PER_SEC >= 100
#  define RANGE 100
#elif CLOCKS_PER_SEC >= 10
#  define RANGE 10
#else
#  define RANGE 1
#endif
    return (ARMword) (clock()*(1000000 / RANGE) / (CLOCKS_PER_SEC / RANGE));
  }
}

/*
 * Return a cycle count
 */
const ARMul_Cycles *ARMul_ReadCycles(ARMul_State *state)
{
  if (state->mem.read_cycles==NULL) return NULL;

  return state->mem.read_cycles(state->mem.handle);
}

/*
 * Branch to some SWI Handler code
 *
 * This code changes to SWI mode, and then gets the ARMulator to
 * start fetching from the specified address, as if a SWI handler had
 * decoded a SWI to be handled at that address and branched to it.
 */
void ARMul_SWIHandler(ARMul_State *state,ARMword address)
{
  ARMul_Abort(state,ARMSWIV,~0);
  ARMul_SetR15(state,address);
}


/*
 * This routine is returns the number of clock ticks since the last reset.
 */

unsigned long ARMul_Time(ARMul_State *state)
{
  const ARMul_Cycles *cycles;

  if (state->mem.read_cycles==NULL ||
      (cycles=state->mem.read_cycles(state->mem.handle))==NULL)
    return 0;

  return cycles->Total;
}

/*
 * This routine is used to call another routine after a certain number of
 * cycles have been executed. The first parameter is the number of cycles
 * delay before the function is called, the second argument is a pointer
 * to the function. A delay of zero doesn't work, just call the function.
 */

struct EventNode {              /* An event list node */
  armul_EventProc *func;        /* the function to call */
  void *handle;                 /* and the handle to pass it */
  unsigned long time;
  EventNode *next;
};

typedef_LIST(EventNode);

void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay,
                         armul_EventProc *what, void *handle)
{
  unsigned long when ;
  EventNode *event, **last;
  unsigned long now = ARMul_Time(state);

  if (state->EventSet++ == 0) state->Now = now;
  when = (state->Now + delay) % EVENTLISTSIZE;
  event = linklist_new(EventNode);
  event->func = what;
  event->handle = handle;
  event->time = now + delay;
  last = state->EventPtr + when;
  while (*last && (*last)->time < now+delay) {
    last = &((*last)->next);
  }
  event->next = *last;
  *last = event;
  ARMul_SetException(state);
}

/*
 * This routine is called at the beginning of every cycle, to invoke
 * scheduled events.
 */

static void InvokeList(ARMul_State *state, unsigned long now,
                       unsigned long from, unsigned long to)
/* invokes all the entries in a range */
{
  EventNode *anevent, **evtptr, **max;

  for (evtptr=state->EventPtr + from,max=state->EventPtr + to;
       evtptr<=max;evtptr++) {
    anevent = *evtptr;
    while (anevent && anevent->time<now) {
      struct EventNode *nextevent;
      
      anevent->func(anevent->handle);
      state->EventSet-- ;
      nextevent = anevent->next ;
      linklist_free(EventNode,anevent);
      anevent = nextevent;
    }
    *evtptr=anevent;
  }
}

void ARMul_InvokeEvent(ARMul_State *state)
{
  static unsigned long then, now;

  then = state->Now % EVENTLISTSIZE;
  now = state->Now = ARMul_Time(state);

  if (then < state->Now) /* schedule events */
    InvokeList(state,now,then,now % EVENTLISTSIZE) ;
  else if (then > state->Now) { /* need to wrap around the list */
    InvokeList(state,now,then,EVENTLISTSIZE-1L) ;
    InvokeList(state,now,0L,now % EVENTLISTSIZE) ;
  }
  ARMul_SetException(state);
}


/*
 * Code to register handlers and to call registered handlers
 */

struct UpcallNode {
  UpcallNode *next;
  union {
    armul_ModeChangeUpcall *mode;
    armul_TransChangeUpcall *trans;
    armul_ConfigChangeUpcall *config;
    armul_InterruptUpcall *interrupt;
    armul_UnkRDIInfoUpcall *rdi_info;
    struct {
      armul_Hourglass *proc;
      unsigned long counter,rate;
    } hourglass;
    armul_EventUpcall *trace_event;
    armul_ExitUpcall *exit;
  } upcall;
  void *handle;
};

typedef_LIST(UpcallNode);

/* Remove any (or all) handler by it's handle */
static int remove_handler(UpcallNode **list,UpcallNode *node)
{
  UpcallNode *p;

  while ((p=*list)!=NULL) {
    if (p==node) {
      *list=p->next;
      linklist_free(UpcallNode,p);
      return TRUE;
    }
    list=&p->next;
  }
  return FALSE;
}

/* Mode change handlers */
void *ARMul_InstallModeChangeHandler(ARMul_State *state,
                                     armul_ModeChangeUpcall *new,
                                     void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->mode_change;
  node->upcall.mode=new;
  node->handle=handle;

  state->mode_change=node;

  return (void *)node;
}

int ARMul_RemoveModeChangeHandler(ARMul_State *state,
                                  void *node)
{
  return remove_handler(&state->mode_change,(UpcallNode *)node);
}

void ARMul_CallModeChange(ARMul_State *state,ARMword old)
{
  UpcallNode *node;
  ARMword new=state->Mode;

  for (node=state->mode_change; node; node=node->next)
    node->upcall.mode(node->handle,old,new);
}


/* nTRANS change handlers */
void *ARMul_InstallTransChangeHandler(ARMul_State *state,
                                      armul_TransChangeUpcall *new,
                                      void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->trans_change;
  node->upcall.trans=new;
  node->handle=handle;

  state->trans_change=node;

  return (void *)node;
}

int ARMul_RemoveTransChangeHandler(ARMul_State *state,
                                  void *node)
{
  return remove_handler(&state->trans_change,(UpcallNode *)node);
}

void ARMul_CallTransChange(ARMul_State *state,unsigned old)
{
  UpcallNode *node;
  unsigned new=state->NtransSig;

  for (node=state->trans_change; node; node=node->next)
    node->upcall.trans(node->handle,old,new);
}


/* Config change handlers */
void *ARMul_InstallConfigChangeHandler(ARMul_State *state,
                                       armul_ConfigChangeUpcall *new,
                                       void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->config_change;
  node->upcall.config=new;
  node->handle=handle;

  state->config_change=node;

  return (void *)node;
}

int ARMul_RemoveConfigChangeHandler(ARMul_State *state,
                                    void *node)
{
  return remove_handler(&state->config_change,(UpcallNode *)node);
}

void ARMul_CallConfigChange(ARMul_State *state,ARMword old)
{
  UpcallNode *node;
  ARMword new=state->arm_config;

  for (node=state->config_change; node; node=node->next)
    node->upcall.config(node->handle,old,new);
}


/* Interrupt handlers */
void *ARMul_InstallInterruptHandler(ARMul_State *state,
                                    armul_InterruptUpcall *new,
                                    void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->interrupt;
  node->upcall.interrupt=new;
  node->handle=handle;

  state->interrupt=node;

  return (void *)node;
}

int ARMul_RemoveInterruptHandler(ARMul_State *state,
                                 void *node)
{
  return remove_handler(&state->interrupt,(UpcallNode *)node);
}

void ARMul_CallInterrupt(ARMul_State *state,unsigned int which)
{
  UpcallNode *node;

  for (node=state->interrupt; node; node=node->next)
    node->upcall.interrupt(node->handle,which);
}



/* RDI Info handler - unlike the other handlers, this can terminate
 * early */
void *ARMul_InstallUnkRDIInfoHandler(ARMul_State *state,
                                     armul_UnkRDIInfoUpcall *new,
                                     void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->rdi_info_upcall;
  node->upcall.rdi_info=new;
  node->handle=handle;

  state->rdi_info_upcall=node;

  return (void *)node;
}

int ARMul_RemoveUnkRDIInfoHandler(ARMul_State *state,
                                  void *node)
{
  return remove_handler(&state->rdi_info_upcall,(UpcallNode *)node);
}

int ARMul_UnknownRDIInfo(ARMul_State *state,unsigned type,
                         ARMword *arg1,ARMword *arg2)
{
  UpcallNode *node;

  for (node=state->rdi_info_upcall; node; node=node->next) {
    int rval=node->upcall.rdi_info(node->handle,type,arg1,arg2);
    if (rval!=RDIError_UnimplementedMessage) {
      return rval;
    }
  }

  return RDIError_UnimplementedMessage;
}


/* Hourglass functions */
void *ARMul_InstallHourglass(ARMul_State *state,
                             armul_Hourglass *new,
                             void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->hourglass;
  node->upcall.hourglass.proc=new;
  node->upcall.hourglass.rate=1;
  node->upcall.hourglass.counter=1;
  node->handle=handle;

  state->hourglass=node;

  ARMul_SetException(state);

  return (void *)node;
}

int ARMul_RemoveHourglass(ARMul_State *state,
                          void *node)
{
  int res=remove_handler(&state->hourglass,(UpcallNode *)node);
  ARMul_SetException(state);
  return res;
}

void ARMul_Hourglass(ARMul_State *state,ARMword pc,ARMword instr)
{
  UpcallNode *node;

  for (node=state->hourglass; node; node=node->next) {
    if (--node->upcall.hourglass.counter==0) {
      node->upcall.hourglass.proc(node->handle,pc,instr);
      node->upcall.hourglass.counter=node->upcall.hourglass.rate;
    }
  }
}

unsigned long ARMul_HourglassSetRate(ARMul_State *state,
                                     void *handle,
                                     unsigned long value)
{
  UpcallNode *p,*node=(UpcallNode *)handle;

  if (value!=0)
    for (p=state->hourglass; p; p=p->next)
      if (p==node) {
        unsigned long old=p->upcall.hourglass.rate;
        p->upcall.hourglass.rate=value;
        p->upcall.hourglass.counter=value;
        return old;
      }
  
  return 0;
}

/* Event tracing */
void * ARMul_InstallEventUpcall(ARMul_State *state,
                                armul_EventUpcall *trace,
                                void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->trace_event.upcall;
  node->upcall.trace_event=trace;
  node->handle=handle;

  if (state->trace_event.upcall==NULL) {
    state->trace_event.mode=ARMul_InstallModeChangeHandler(state,
                                                           trace_mode_changes,
                                                           state);
    state->trace_event.intr=ARMul_InstallInterruptHandler(state,
                                                          trace_interrupts,
                                                          state);
  }

  state->trace_event.upcall=node;
  
  return (void *)node;
}

int ARMul_RemoveEventUpcall(ARMul_State *state,void *node)
{
  if (remove_handler(&state->trace_event.upcall,(UpcallNode *)node)) {
    if (state->trace_event.upcall==NULL) {
      ARMul_RemoveModeChangeHandler(state,state->trace_event.mode);
      ARMul_RemoveInterruptHandler(state,state->trace_event.intr);
    }
    return TRUE;
  }
  return FALSE;
}

void ARMul_RaiseEvent(ARMul_State *state,unsigned int event,
                      ARMword addr1,ARMword addr2)
{
  UpcallNode *node;
    
  for (node=state->trace_event.upcall; node; node=node->next)
    node->upcall.trace_event(node->handle,event,addr1,addr2);
}


/* Exit handler */
void *ARMul_InstallExitHandler(ARMul_State *state,
                               armul_ExitUpcall *new,
                               void *handle)
{
  UpcallNode *node=linklist_new(UpcallNode);

  node->next=state->exit;
  node->upcall.exit=new;
  node->handle=handle;

  state->exit=node;

  return (void *)node;
}

int ARMul_RemoveExitHandler(ARMul_State *state,
                            void *node)
{
  return remove_handler(&state->exit,(UpcallNode *)node);
}

static void free_nodes(UpcallNode *node)
{
  UpcallNode *next;
  while (node) {
    next=node->next;
    linklist_free(UpcallNode,node);
    node=next;
  }
}

void ARMul_CallExit(ARMul_State *state)
{
  UpcallNode *node;

  for (node=state->exit; node; node=node->next)
    node->upcall.exit(node->handle);

  /* Free nodes */
  free_nodes(state->mode_change); state->mode_change=NULL;
  free_nodes(state->config_change); state->config_change=NULL;
  free_nodes(state->interrupt); state->interrupt=NULL;
  free_nodes(state->rdi_log_upcall); state->rdi_log_upcall=NULL;
  free_nodes(state->rdi_info_upcall); state->rdi_info_upcall=NULL;
  free_nodes(state->exit); state->exit=NULL;
}

/*
 * Function to be called if the model appears to have hung
 */
int ARMul_ModelBroken(ARMul_State *state)
{
  ARMul_ConsolePrint(state,"Core: Model broken (memory model has stopped responding?)\n");
  ARMul_HaltEmulation(state,RDIError_TargetBroken);

  state->broken=TRUE;

  return FALSE;                 /* so can be used in a "while (fetch==0 && Hung())" thing */
}


/*
 * Function to load and start-up the FPE
 */

#include "armfpe.h"

#define FPEEND 0x8000L

int ARMul_FPEInstall(ARMul_State *state)
{
  ARMword addr = fpe.hdr.imagebase;
  unsigned int i,j;
  ARMword bigendSig = ARMul_SetConfig(state,0,0) & MMU_B;
  struct fpedesc fpedesc;

  fpedesc.base = addr;
  fpedesc.regs = 0;
  if (addr + sizeof(fpe.code) > FPEEND) {
    ARMul_PrettyPrint(state, " FPE too big to load,");
    return FALSE;
  } else {
    for (i = 0; i < sizeof(fpe.code) - 4; i += 4) /* copy the code */
      ARMul_WriteWord(state, addr + i, fpe.code[i >> 2]);
    i = (sizeof(fpe.code) >> 2);
    
    while ((j = fpe.code[--i]) != 0xffffffff) {
      if (bigendSig && j < 0x80000000) {
        /* it's part of the string so swap it */
        j = (((j >> 0x18) & 0x000000ff) |
             ((j >> 0x08) & 0x0000ff00) |
             ((j << 0x08) & 0x00ff0000) |
             ((j << 0x18) & 0xff000000));
        ARMul_WriteWord(state, addr + (i<<2), j);
      }
    }
      
    fpedesc.regs = fpe.code[--i];
    fpedesc.version = (int)fpe.code[--i];
      
    if (fpedesc.version > 1) {
      /* reverse FPE/FPASC byte tables for versions > 1 */
      ARMword start, end;     /* region to be reversed */
      while ((end = fpe.code[--i]) != 0xffffffff) {
        start = fpe.code[--i];
          
        if (bigendSig)
          for (j = start; j < end; j += 4) {
            ARMword t = ARMul_ReadWord(state, j);
            t = (((t >> 0x18) & 0x000000ff) |
                 ((t >> 0x08) & 0x0000ff00) |
                 ((t << 0x08) & 0x00ff0000) |
                 ((t << 0x18) & 0xff000000));
            ARMul_WriteWord(state, j, t);
          }
      }
    }
    ARMul_PrettyPrint(state, ", FPE");
    ARMul_SetPC(state, fpe.hdr.imagebase + fpe.hdr.entry_br);
    ARMul_DoProg(state);
    if (ARMul_EndCondition(state) != 0) {
      ARMul_PrettyPrint(state, " initialisation failed");
      fpedesc.regs = 0;
    }
  }

  state->fpe=fpedesc;

  return TRUE;
}

/*
 * Return the FPE version number
 */
int ARMul_FPEVersion(ARMul_State *state)
{
  if (state->fpe.regs==0) return -1;
  return state->fpe.version;
}

/*
 * Function that returns TRUE if the supplied address is in the FPE
 */

int ARMul_FPEAddressInEmulator(ARMul_State *state,ARMword addr)
{
  if (state->fpe.regs==0) return FALSE;
  return (addr>=state->fpe.base && addr<FPEEND);
}

/*
 * Co-processor access functions
 */

/*
 * Return the "regwords" for a given co-processor
 */
unsigned char const *ARMul_CPRegWords(ARMul_State *state,unsigned CPnum)
{
  unsigned char const *rmap=state->CP[CPnum].reg_words;
  if (rmap==NULL) {
    if (state->fpe.regs!=0 && (CPnum==1 || CPnum==2)) {
      static unsigned const char fpe_rmap[]={10,  4, 4, 4, 4,  4, 4, 4, 4,  1, 1};
      return &fpe_rmap[0];
    }
    return NULL;
  }
  return rmap;
}

/*
 * Generic functions to read/write given co-processor registers.
 */

/* return a pointer to after the data read, or NULL on error */
ARMword *ARMul_CPRead(ARMul_State *state,unsigned CPnum,unsigned r,
                      ARMword *buffer)
{
  unsigned char const *rmap = state->CP[CPnum].reg_words;
  if (rmap == NULL) {
    if (state->fpe.regs!=0 && (CPnum==1 || CPnum==2)) {
      int w;
      /* check out FPE */
      ARMword word[4];
      switch (r) {
      case 0: case 1: case 2: case 3:
      case 4: case 5: case 6: case 7:
        for (w=0; w<4; w++)
          word[w]=ARMul_ReadWord(state,
                                 state->fpe.regs + (ARMword)r*16 + (ARMword)w*4);
        if (state->fpe.version == 0) {
          switch ((int)(word[3] >> 29)) {
          case 0: case 2: case 4: case 6: /* its unpacked, convert to extended */
            *buffer++ = 2; /* mark as extended */
          *buffer++ = (word[3] & 0x7fff) | (word[0] & 0x80000000); /* exp and sign */
            *buffer++ = word[1]; /* mantissa 1 */
            *buffer++ = word[2]; /* mantissa 2 */
            break;
          case 1: /* packed single */
            *buffer++ = 0; /* mark as single */
            *buffer++ = word[0]; /* sign, exp and mantissa */
            *buffer++ = word[1]; /* padding */
            *buffer++ = word[2]; /* padding */
            break;
          case 3: /* packed double */
            *buffer++ = 1; /* mark as double */
            *buffer++ = word[0]; /* sign, exp and mantissa1 */
            *buffer++ = word[1]; /* mantissa 2 */
            *buffer++ = word[2]; /* padding */
            break;
          case 5: /* packed extended */
            *buffer++ = 2; /* mark as extended */
            *buffer++ = word[0]; /* sign and exp */
            *buffer++ = word[1]; /* mantissa 1 */
            *buffer++ = word[2]; /* mantissa 2 */
            break;
          case 7 : /* packed decimal */
            *buffer++ = 3; /* mark as packed decimal */
            *buffer++ = word[0]; /* sign, exp and mantissa1 */
            *buffer++ = word[1]; /* mantissa 2 */
            *buffer++ = word[2]; /* mantissa 3 */
            break;
          }
        } else {
          *buffer++ = 4; /* mark as internal */
          *buffer++ = word[0]; /* sign, exp and mantissa1 */
          *buffer++ = word[1]; /* mantissa 2 */
          *buffer++ = word[2]; /* mantissa 3 */
        }
        return buffer;
        
      case 8:                   /* FPSR */
        *buffer++=ARMul_ReadWord(state,state->fpe.regs+128);
        return buffer;
        
      case 9:                   /* FPCR */
        *buffer++=0;
        return buffer;
        
      default:
        return buffer;
      }
    }
    return NULL;
  }
  
  state->CP[CPnum].read(state->CP[CPnum].handle, r, buffer);
  
  buffer+=rmap[r+1];

  return buffer;
}

/* Write co-processor registers */
const ARMword *ARMul_CPWrite(ARMul_State *state,unsigned CPnum,unsigned r,
                             const ARMword *buffer)
{
  unsigned char const *rmap = state->CP[CPnum].reg_words;
  if (rmap == NULL) {
    if (state->fpe.regs!=0 && (CPnum==1 || CPnum==2)) {
      /* check out FPE */
      switch (r) {
      case 0: case 1: case 2: case 3:
      case 4: case 5: case 6: case 7:
        if (state->fpe.version == 0) {
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16,buffer[1]);
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16 + 4,buffer[2]);
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16 + 8,buffer[3]);
          /* mark type */
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16 + 12,(buffer[0]*2 + 1)<<29);
        } else {
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16,buffer[1]);
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16 + 4,buffer[2]);
          ARMul_WriteWord(state,state->fpe.regs + (ARMword)r*16 + 8,buffer[3]);
        }
        buffer+=4;
        return buffer;

      case 8:                   /* FPSR */
        ARMul_WriteWord(state,state->fpe.regs + 128,*buffer++);
        return buffer;

      case 9:                   /* FPCR */
        return buffer;

      default:
        return buffer;
      }
    }
    return NULL;
  }
  
  state->CP[CPnum].write(state->CP[CPnum].handle, r, buffer);
  
  buffer+=rmap[r+1];
  
  return buffer;
}

/*
 * Call this routine once to set up the emulator's tables.
 */

ARMword ARMul_ImmedTable[4096] ; /* immediate DP LHS values */
char ARMul_BitList[256] ; /* number of bits in a byte table */

#define ROTATER(X, Y)  ( ((X) >> (Y)) | ((X) << (32-(Y))) )

void ARMul_EmulateInit(void)
{
  unsigned long i, j;

  for (i = 0 ; i < 4096 ; i++) { /* the values of 12 bit dp rhs's */
    ARMul_ImmedTable[i] = ROTATER(i & 0xffL,(i >> 7L) & 0x1eL);
  }

  for (i = 0 ; i < 256 ; ARMul_BitList[i++] = 0 ); /* how many bits in LSM */
  for (j = 1 ; j < 256 ; j <<= 1)
    for (i = 0 ; i < 256 ; i++)
      if ((i & j) > 0 )
        ARMul_BitList[i]++;

  for (i = 0 ; i < 256 ; i++)
    ARMul_BitList[i] *= 4; /* you always need 4 times these values */
}

#include "disass.h"

static char *disass_cb(dis_cb_type type, int32 offset, unsigned32 address,
                       int width, void *cb_arg, char *buf)
{
  IGNORE(type); IGNORE(offset); IGNORE(address); IGNORE(width); IGNORE(cb_arg);
  return buf;
}


char *ARMul_Disass(ARMword instr, ARMword address, ARMword cpsr)
{
  static char ch[5], dis[80], str[130];
  unsigned mode, i;
  
  mode = (unsigned)(cpsr & 0x1f);
  disass_32or26(instr, address, dis, NULL, disass_cb, mode > 3);
  for (i = 0; i < 4; i++) {
    unsigned char c = (char)(instr >> (i*8));
    ch[i] = (isprint(c) ? c : '.');
  }
  ch[4] = '\0';
  sprintf(str,"0x%08lx: %08lx %s %s", address, instr, ch, dis);
  return str;
}
