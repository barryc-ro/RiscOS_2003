/* prefetch unit model - simple approach */
/* Copyright (C) Advanced RISC Machines Limited, 1995. All rights reserved. */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

/* This model makes a lot of use of gotos, because of the nature of the
 * state machine. They are used mainly for doing the sort of cross-jump
 * optimisation that compilers often do anyway. However doing it by hand
 * kind of emphasises the fact that the tail bits of code are the same,
 * and only gives us one copy to maintain.
 * The meaning of each tail bit is given before the label.
 */

/* The PU model models both the prefetch unit/branch predictor and it keeps
 * the decode stage of the ARM as well. This means that the ARM core model
 * doesn't need to be able to handle cancelD type things.
 */

#include <stdio.h>              /* for debugging */
#include "armdefsp.h"
#include "armemu.h"             /* AL, etc. */
#include "armpu.h"

#ifndef NO_TABLE
/* This table was automatically generated by "buildtbl.c" */
static const unsigned short psr_table[] = {
  /*
   * Each entry is for a particular PSR flags setting - BIT(n) of each entry
   * is set if that condition code (EQ ... NV) succeeds for that PSR setting.
   */
  0x56aa,0x6a6a,0x55a6,0x6966,
  0x66a9,0x6a69,0x66a5,0x6a65,
  0x6a9a,0x565a,0x6996,0x5556,
  0x6a99,0x6659,0x6a95,0x6655
};
#endif

#if defined(ILOGGING) || defined(LOGGING)
extern FILE *logfile;
#endif
#ifdef ILOGGING
#define ilog(X) X
#endif
#ifdef LOGGING
#define log(X) X
#ifndef ilog
#define ilog(X) X
#endif
static char *log_message="normal";
#define logmessage(X) log_message=#X
#else
#define log(X)
#define logmessage(X)
#endif
#ifndef ilog
#define ilog(X)
#endif

typedef struct {
#define EXECUTE -2              /* pseudo-index into the fifo */
#define DECODE -1
  struct pu_entry {
    ARMword instr;              /* instruction */
    ARMword pc;                 /* it's PC value */
    int aborted;                /* whether it prefetch aborted */
  } decode,fifo[8];             /* decode stage and PU fifo */
#define MAX_WORDS 7             /* maximum of 7 words in the FIFO at once */
  enum pu_state {
    FetchInstr1,                /* non-seq normal instruction fetch next */
    FetchInstr,                 /* normal instruction fetch */
    SpottedBranch,              /* spotted a branch, do a normal fetch */
    FetchSpec1,                 /* non-seq speculative instruction fetch next */
    FetchSpec,                  /* speculative instruction fetch */
    NoFetchSpec,                /* would be speculatively fetching if we thought the
                                 * branch was going to be taken, but we don't */
    BranchWait,                 /* waiting until we can predict the branch */
    Calculate,                  /* predicting the branch */
    Correction                  /* cycle after branch target/skip fed to core */
#define Full             0x20   /* fifo is full */
#define Empty            0x40   /* decode is empty */
#define Correct          0x80   /* correction cycle */
  } state;
  struct {
    int place;                  /* where in the fifo things are to be place */
    ARMword pc;                 /* current PC for fetching instructions */
  } where,alternate,*cur;       /* alternate is shadow used during speculative fetches */
                                /* cur points to whichever is currently in use. */
  enum {
    NormalInDecode,             /* decode stage contains a normal instruction */
    DecodeEmpty,                /* decode stage is empty */
    TargetInDecode,             /* target of branch is in decode stage */
    DecodeTargetEmpty,          /* decode would contain target, but is empty */
    BranchInDecode,             /* branch itself is in decode stage */
    DecodeBranchEmpty,
    SkipInDecode,               /* instruction after branch is in decode stage */
    DecodeSkipEmpty,            /* would contain instruction after branch */
    LinkInDecode,               /* a "link" instruction is in the decode stage */
    DecodeLinkEmpty
    } in_decode;
  int predicting;               /* whether we're predicting branches */
  int spotted_branch;           /* where we spotted the branch */
  ARMword branch,branch_pc;     /* @@@ used for debug only */
  ARMword branch_cond;          /* condition code for branch */
  ARMword branch_target;        /* target address of branch */
  enum {
    PredictTaken,               /* a backwards normal branch */
    PredictNotTaken,            /* a forwards normal branch */
    BranchLink,                 /* branch with link */
    NotABranch                  /* no branch spotted */
    } predict;
  enum {
    PredictTaken_Taken,
    PredictTaken_NotTaken,
    PredictNotTaken_Taken,
    PredictNotTaken_NotTaken
    } correct;                  /* type of correction needed */
  int words;                    /* number of words in the fifo (including those
                                 * missing because of removal of spec's by model) */
  int decoded;                  /* a flag that indicates that the decode state was
                                 * empty at the last cycle - i.e. this instruction is
                                 * not ready to be fed to the core. */

#ifdef DEBUG
  /* debugging information only */
  struct pu_entry execute;      /* what we last fed to the core */
#endif

  int state_predicting;         /* state->predictSig copy */
  int twenty_six;               /* whether we're in a 26-bit mode now */

  ARMul_State *astate;
} PU;

#ifdef COUNT
#define count(X) X
int state_counter[0x100];
#else
#define count(X)
#endif


#ifndef DEBUG                           /* DEBUGGING */
#define DoDump(state,message)
#define announce(X)
#else
#define announce(X) if (!frazzle) puts(X)
int frazzle=1;
#define DoDump(pup,message) if (!frazzle) DumpPU(pup,message)
#endif

static void ShowState(PU *pup,FILE *f)
{
  switch (pup->state & ~(Full | Empty | Correct)) {
  case FetchInstr1: fputs("FetchInstr1",f); break;
  case FetchInstr: fputs("FetchInstr",f); break;
  case SpottedBranch: fputs("SpottedBranch",f); break;
  case FetchSpec1: fputs("FetchSpec1",f); break;
  case FetchSpec: fputs("FetchSpec",f); break;
  case NoFetchSpec: fputs("NoFetchSpec",f); break;
  case BranchWait: fputs("BranchWait",f); break;
  case Calculate: fputs("Calculate",f); break;
  case Correction: fputs("Correction",f); break;
  default:
    fprintf(f,"%x",pup->state);
    break;
  }
  if (pup->state & Full) fputs(" | Full",f);
  if (pup->state & Empty) fputs(" | Empty",f);
  if (pup->state & Correct) fputs(" | Correct",f);
  fprintf(f,"  (%d words)\n",pup->words);
}

#ifndef NODEBUG
#include "disass.h"
static char *cb_proc(dis_cb_type t,int32 offset,unsigned32 addr,
                     int width,void *arg,char *buf)
{
  IGNORE(t); IGNORE(offset); IGNORE(addr); IGNORE(width); IGNORE(arg);
  return buf;
}

static char *dis(unsigned32 pc,unsigned32 instr)
{
  static char buffer[256];
  disass(instr,pc,buffer,NULL,cb_proc);
  return buffer;
}

static void DumpPU(PU *pup,char *message)
{
  int i;
  char buffer[80];

  printf("%s: ",message);

  ShowState(pup,stdout);

  if (pup->predicting==FALSE)
    printf("[Branch prediction off] ");

#ifdef DEBUG
  printf("E  %08x %08x ",pup->execute.pc,pup->execute.instr);
  disass(pup->execute.instr,pup->execute.pc,buffer,NULL,cb_proc);
  puts(buffer);
#endif

  putchar('D');
  switch (pup->in_decode) {
  case NormalInDecode:     fputs("N ",stdout); break;
  case DecodeEmpty:        fputs("NE",stdout); break;
  case TargetInDecode:     fputs("T ",stdout); break;
  case DecodeTargetEmpty:  fputs("TE",stdout); break;
  case BranchInDecode:     fputs("B ",stdout); break;
  case DecodeBranchEmpty:  fputs("BE",stdout); break;
  case SkipInDecode:       fputs("S ",stdout); break;
  case DecodeSkipEmpty:    fputs("SE",stdout); break;
  case LinkInDecode:       fputs("L ",stdout); break;
  case DecodeLinkEmpty:    fputs("LE",stdout); break;
  default: fputs("? ",stdout); break;
  }

  printf("%08lx %08lx ",pup->decode.pc,pup->decode.instr);
  disass(pup->decode.instr,pup->decode.pc,buffer,NULL,cb_proc);
  puts(buffer);

  for (i=0;i<7;i++) {
    if (i==pup->where.place) break;
    disass(pup->fifo[i].instr,pup->fifo[i].pc,buffer,NULL,cb_proc);
    printf("%d%c%c%08lx %08lx %s\n",i,
           (i==pup->alternate.place) ? '>' : ' ',
           (i==pup->spotted_branch) ? 'B' : ' ',
           pup->fifo[i].pc,pup->fifo[i].instr,buffer);
  }
}
#else
#  define DumpPU(X,Y)
#endif

static void ShuffleDown(PU *pup)
{
  /* move the PU down 1 step */
  int n;
  
  announce("ShuffleDown");

  n=pup->where.place-1;
  if (n>=0) {
    pup->in_decode=NormalInDecode;
    pup->decoded=FALSE;
    if (pup->state & Empty) pup->state &= ~Empty;
    pup->decode=pup->fifo[0];
#if 0
    memmove((char *)&pup->fifo[0],(char *)&pup->fifo[1],n*sizeof(pup->fifo[0]));
#else
  { int i;
    for (i=0;i<n;i++)
      pup->fifo[i]=pup->fifo[i+1];
  }
#endif
    pup->where.place=n;
    pup->alternate.place--;
    /* Unlike the other shuffle procs, this one will not clear the
     * Full flag, since it is probably more efficient to do it externally.
     * The others are called from speculative states, so things are more
     * complicated. When this is called from a speculative state, we have
     * to do the check ourselves */
    pup->words--;
  } else {
    pup->in_decode=DecodeEmpty;
    pup->state|=Empty;
    ARMul_RaiseEvent(pup->astate,PUEvent_Empty,pup->where.pc,0);
  }
}

static void ShuffleDownLink(PU *pup)
{
  /* move the PU down 1 step, placing a Link into the decode stage */
  int n;
  
  announce("ShuffleDownLink");

  n=pup->where.place-1;
  if (n>=0) {
    pup->in_decode=LinkInDecode;
    pup->decoded=FALSE;
    if (pup->state & Empty) pup->state &= ~Empty;
    pup->decode.instr=0xe24fe004; /* SUB lr,pc,#4 */
    pup->decode.pc=pup->fifo[0].pc;
    pup->decode.aborted=pup->fifo[0].aborted; /* 0? */
#if 0
    memmove((char *)&pup->fifo[0],
            (char *)&pup->fifo[1],
            n*sizeof(pup->fifo[0]));
#else
  { int i;
    for (i=0;i<n;i++)
      pup->fifo[i]=pup->fifo[i+1];
  }
#endif
    pup->where.place=n;
    pup->alternate.place--;
    if (--pup->words<MAX_WORDS-1) pup->state &= ~Full;
  } else {
    pup->in_decode=DecodeEmpty;
    pup->state |= Empty;
    ARMul_RaiseEvent(pup->astate,PUEvent_Empty,pup->where.pc,0);
  }
}

static void ShuffleDownSkip(PU *pup)
{
  /* move the PU down 2 steps */
  int n;
  
  announce("ShuffleDownSkip");

  n=pup->where.place-2;
  if (n>=0) {
    pup->in_decode=SkipInDecode;
    pup->decoded=FALSE;
    if (pup->state & Empty) pup->state &= ~Empty;
    pup->decode=pup->fifo[1];
#if 0
    memmove((char *)&pup->fifo[0],
            (char *)&pup->fifo[2],
            n*sizeof(pup->fifo[0]));
#else
  { int i;
    for (i=0;i<n;i++)
      pup->fifo[i]=pup->fifo[i+2];
  }
#endif
    pup->where.place=n;
    pup->alternate.place-=2;
    /* removes two words from the FIFO */
    if ((pup->words-=2)<MAX_WORDS-1) pup->state &= ~Full;
  } else {
    pup->in_decode=DecodeSkipEmpty;
    pup->state |= Empty;
    pup->where.place=pup->words=0;
    ARMul_RaiseEvent(pup->astate,PUEvent_Empty,pup->where.pc,0);
  }
}

static void ShuffleDownSpec(PU *pup)
{
  /* move the PU down 1 step, but putting spec into decode stage */
  int n;
  
  announce("ShuffleDownSpec");

  n=pup->where.place-1;
  if (n>=pup->alternate.place) {
    pup->in_decode=TargetInDecode;
    pup->decoded=FALSE;
    if (pup->state & Empty) pup->state &= ~Empty;
    pup->decode=pup->fifo[pup->alternate.place];
#if 0
    memmove((char *)&pup->fifo[pup->alternate.place],
            (char *)&pup->fifo[pup->alternate.place+1],
            (n-pup->alternate.place)*sizeof(pup->fifo[0]));
#else
  { int i;
    for (i=pup->alternate.place;i<n;i++)
      pup->fifo[i]=pup->fifo[i+1];
  }
#endif
    pup->where.place=n;
    /* doesn't necessarily reduce the number of words in the FIFO */
    if (pup->alternate.place==0 &&
        --pup->words<MAX_WORDS-1) pup->state &= ~Full;
  } else {
    pup->in_decode=DecodeTargetEmpty;
    pup->state |= Empty;
    ARMul_RaiseEvent(pup->astate,PUEvent_Empty,pup->where.pc,0);
  }
}

static int FixupFIFO(ARMul_State *state,PU *pup)
{
  int cycles=0;
  announce("FixupFIFO");

  /* Called to sort out the FIFO contents */
  switch (pup->correct) {
  case PredictTaken_NotTaken:
    /* flush the speculatively fetched instructions */
    pup->where=pup->alternate;
    pup->words=pup->where.place;
    switch (pup->in_decode) {
    case NormalInDecode:
      pup->state=FetchInstr1;
      break;
    case TargetInDecode:
    case DecodeTargetEmpty:
    case BranchInDecode:
    case DecodeBranchEmpty:
    case LinkInDecode:
    case DecodeLinkEmpty:
      pup->in_decode=DecodeEmpty; /* fall through */
    case DecodeEmpty:
      pup->state=FetchInstr1 | Empty;
      DoDump(pup,"Correcting FIFO");
      ShuffleDown(pup);
      if (pup->words!=0) cycles=1;
      break;
    case SkipInDecode:
    case DecodeSkipEmpty:
      /* should not happen */
      break;
    }
    break;
  case PredictNotTaken_NotTaken:
    if (pup->state & Empty) {
      pup->state=FetchInstr | Empty;    /* continue fetching */
      pup->in_decode=DecodeEmpty;
      ShuffleDown(pup);
    } else
      pup->state=FetchInstr;    /* continue fetching */
    break;
  case PredictTaken_Taken: {
    int i,j,n;                  /* flush the other instructions */
    n=pup->where.place;
    for (i=pup->alternate.place,j=0;i<n;i++,j++) {
      pup->fifo[j]=pup->fifo[i];
    }
    pup->words=pup->where.place=j;
    if (pup->state & Empty) {
      /* else no instructions fetched, so act as NotTaken */
      pup->state=FetchInstr | Empty;
      pup->in_decode=DecodeEmpty;
      ShuffleDown(pup);
    } else {
      pup->state=FetchInstr;
      pup->in_decode=NormalInDecode;
    }
  }
    break;
  case PredictNotTaken_Taken:
    /* no target instructions fetched at all. */
    pup->state=FetchInstr1 | Empty;
    pup->in_decode=DecodeEmpty;
    pup->words=pup->where.place=0;
    pup->where.pc=pup->branch_target;
    break;
  }
  pup->predicting=pup->state_predicting;
  if (pup->words>=MAX_WORDS-1) {
    pup->state|=Full;
    ARMul_RaiseEvent(state,PUEvent_Full,pup->where.pc,0);
  }

  return 1;
}

static int PredictBranch(PU *pup,int i)
{
  /* Is there a branch in slot %d? */
  ARMword instr=pup->fifo[i].instr;
  int offset;

  pup->predict=NotABranch;

  if (((instr>>25)& 7)!=5)  /* B or BL */
    return 0;

  if ((instr & (1<<24)) && (instr>>28)!=AL)     /* conditional BL */
    return 0;

  if ((instr>>28)==NV)
    return 0;

  /* if (pup->fifo[i].aborted) return 0; -- never called for aborted instructions */

  if (instr & (1<<24))          /* branch link */
    pup->predict=BranchLink;
  else if ((instr>>28)==AL ||   /* always */
           (instr & (1<<23)))   /* backwards */
    pup->predict=PredictTaken;
  else                          /* forwards */
    pup->predict=PredictNotTaken;

  pup->branch=instr;            /* @@@ debug only */
  pup->branch_pc=pup->fifo[i].pc; /* @@@ this too. */

  pup->branch_cond=instr>>28;
  offset=((signed int)(instr<<8))>>6;
  pup->branch_target=pup->fifo[i].pc+8+offset; /* @@@ - wrong in 26-bit modes */
  if (pup->twenty_six) pup->branch_target&=0x3ffffffc;
  pup->spotted_branch=i;

  log(fprintf(logfile,"  branch spotted (%s) - words %d ",
              (pup->predict==BranchLink) ? "link" :
              (pup->predict==PredictTaken) ? "taken" : "not taken",
              pup->words);
      if (pup->predict==BranchLink || pup->predict==PredictTaken) {
        switch (pup->words) {
        case 0: fputs("3/1 cycles\n",logfile); break;
        case 1: fputs("2/2 cycles\n",logfile); break;
        case 2: fputs("1/2 cycles\n",logfile); break;
        default: fputs("0/2 cycles\n",logfile); break;
        }
      } else {
        switch (pup->words) {
        case 0: fputs("1/3 cycles\n",logfile); break;
        default: fputs("0/3 cycles\n",logfile); break;
        }
      })

  return 1;
}

/*
 * ARMul_8DoIdleCycles
 *
 * This is called for cycles where we are *not* on the bus (because the ARM is).
 * For the majority of cases there's nothing to be done for this function, cos
 * we would have just fetched instructions. However when we have spotted a branch
 * the PU can still do something useful.
 */
void ARMul_8DoIdleCycles(ARMul_State *state,int n)
{
  PU *pup=(PU *)state->proc.arm8.prefetch;

  log(fprintf(logfile,"%d idle %s : ",n,log_message));
  log(ShowState(pup,logfile));
  logmessage(normal);

  count(if (pup->state==FetchInstr)
        state_counter[FetchInstr]+=n);

  if (n==0) return;

  pup->decoded=TRUE;            /* any instruction in decode must be decoded by now */

  if (pup->state==FetchInstr) {
    return;
  }

  while (n--) {
    DoDump(pup,"DoIdleCycles");
    
    count(state_counter[pup->state]++);

    switch (pup->state) {
    case FetchSpec | Empty:
    case FetchSpec:             /* FetchInstr, but speculatively */
    case FetchInstr | Empty:
    case FetchInstr:            /* Fetch instructions, check if full */
    case FetchSpec | Full:      /* Just do Icycles and stay in this state */
    case FetchSpec | Full | Empty:
    case FetchInstr | Full:     /* Full, but during speculative fetching */
    case NoFetchSpec | Full:
    case NoFetchSpec | Empty:
    case NoFetchSpec:
    case BranchWait | Full:
    case BranchWait | Empty:
    case BranchWait:
    case FetchSpec1 | Full:
    case FetchSpec1 | Empty:
    case FetchSpec1 | Full | Empty:
    case FetchSpec1:            /* Starting a speculative fetch sequence */
    case FetchInstr1 | Full:
    case FetchInstr1 | Empty:   /* Just did a forced prefetch - flush */
    case FetchInstr1:           /* restarting real fetchs, but not forced */
      count(state_counter[pup->state]+=n;)
      return;                   /* can't do anything */
      
    case SpottedBranch:
      /* When a branch is spotted, it is too late to prevent issue of the
       * next request, so this will happen here. Once that request has been
       * issued, we go into the BranchWait state, where we are basically
       * waiting for the branch to enter the branch predictor, at which
       * point we start prediction.
       */
      pup->state=(pup->spotted_branch>=3) ? BranchWait : Calculate;
      /* @@@ pup->predicting=FALSE; */
      break;
      
    case SpottedBranch | Full:
      pup->state=(pup->spotted_branch>=3) ? (BranchWait | Full)
                                          : (Calculate | Full);
      /* pup->predicting=FALSE; @@@ */
      break;
      
    case SpottedBranch | Empty:
      pup->state=(pup->spotted_branch>=3) ? (BranchWait | Empty)
                                          : (Calculate | Empty);
      /* pup->predicting=FALSE; @@@ */
      break;
      
    case NoFetchSpec | Correct: /* correction cycle */
    case FetchSpec1 | Correct: /* Starting a speculative fetch sequence */
    case FetchSpec | Correct:
      pup->state=Correction;
      break;

    case NoFetchSpec | Empty | Correct:
    case FetchSpec1 | Empty | Correct:
    case FetchSpec | Empty | Correct:
      pup->state=Correction | Empty;
      break;
      
    case NoFetchSpec | Full | Correct:
    case FetchSpec1 | Full | Correct:
    case FetchSpec | Full | Correct:
      pup->state=Correction | Full;
      break;

    case Correction | Full:
    case Correction | Empty:
    case Correction | Full | Empty:
    case Correction:
      FixupFIFO(state,pup);
      break;
      
    case Calculate | Full:
    case Calculate | Empty:
    case Calculate:
      pup->alternate=pup->where;
      switch (pup->predict) {
      case PredictTaken:
      case BranchLink:
        pup->where.pc=pup->branch_target;
        pup->state=FetchSpec1 | (pup->state & (Empty | Full));
        break;
      case PredictNotTaken:
        /* do not fetch any instructions */
#if 0                           /* @@@ */
        pup->state=NoFetchSpec | (pup->state & (Empty | Full));
#endif
        pup->state=FetchSpec | (pup->state & (Empty | Full));
        break;
      default:                  /* error */
        ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): should not be in Calculate state\n");
        ARMul_ModelBroken(state);
        break;
      }
      break;
      
    default:
      ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): (idle) case %02x not handled - %08lx\n",
                         pup->state,state->Reg[15]);
      ARMul_ModelBroken(state);
      return;
    }
  }
  return;
}


/*
 * ARMul_8DoCycles
 *
 * When the PU has cycles on the bus, this function is called. Sometimes it
 * might be called erroneously, when the ARM still has cycles to perform, so
 * it checks and calls DoIdleCycles if appropriate. Most of the time there's
 * not much to be done - just fetch instructions and insert them into the
 * FIFO.
 */
void ARMul_8DoCycles(ARMul_State *state,int n)
{
  PU *pup=(PU *)state->proc.arm8.prefetch;
  armul_MemAccess2 *mem_access=state->mem.x.arm8.access2;
  void *mem_handle=state->mem.handle;
  ARMul_acc access_type;
  int buscycles=state->proc.arm8.busCycles;

  if (buscycles) {
    if (buscycles>n) {
      ARMul_8DoIdleCycles(state,n);
      state->proc.arm8.busCycles=buscycles-n;
      return;
    } else {
      state->proc.arm8.busCycles=0;
      n-=buscycles;
      ARMul_8DoIdleCycles(state,buscycles);
    }
  }

  log(fprintf(logfile,"%d %s :",n,log_message));
  log(ShowState(pup,logfile));
  logmessage(normal);

  while (n--) {
    DoDump(pup,"DoCycles");

    count(state_counter[pup->state]++);

    pup->decoded=TRUE;          /* any instruction in decode must be decoded by now */
    
    /* common case */
    if (pup->state==FetchInstr) {
      access_type=acc_LoadInstrS2;
      goto fetch_instruction;
    } else switch (pup->state) {
    case NoFetchSpec:
    case NoFetchSpec | Full:
    case NoFetchSpec | Empty:
    case FetchInstr | Full:     /* Full, but during speculative fetching */
    case FetchInstr1 | Full:
    case FetchSpec | Full:      /* Just do Icycles and stay in this state */
    case FetchSpec1 | Full:
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;
      
    case FetchInstr | Empty:
      /* instruction falls into the decode stage */
      pup->state=FetchInstr;
      pup->in_decode=NormalInDecode;
      access_type=acc_LoadInstrS2;
      /* we arrive here when we want to load some instructions, the first
       * of which will bypass the FIFO and go straight into the decode
       * slot. That is, from all the "Empty" states where instructions are
       * to be fetched. */
    fetch_instruction_empty: {
      ARMword pc=pup->where.pc;
      int place=pup->where.place;
      switch (mem_access(mem_handle,pc,
                         &pup->decode.instr,
                         &pup->fifo[place].instr,
                         access_type)) {
      case -1:                  /* aborted */
        /* @@@ need to stop fetching, mark the instruction as aborted iff
         * a non-speculative fetch (can do that slowly) etc. */
        pup->decode.aborted=1;
        pup->predicting=FALSE;
        pup->decode.instr=ARMul_ABORTWORD;
        pup->decode.pc=pc;
        pup->where.pc=pc+4;
        pup->decoded=FALSE;
        break;
      case 0:                   /* failed to fetch anything */
        pup->state|=Empty;      /* stay empty */
        pup->in_decode++;       /* from full to an empty type */
        /* @@@ should go into a NoFetchSpec state */
        /*
          pup->state=NoFetchSpec | (pup->state & (Empty | Full | Correct));
          */
        break;
      case 1:                   /* fetched 1 instruction */
        pup->decode.aborted=0;
        pup->decode.pc=pc;
        pup->where.pc=pc+4;
        pup->decoded=FALSE;     /* instruction will need a cycle to decode */
        break;
      case 2:
        pup->decode.aborted=0;
        pup->decode.pc=pc;
        pup->fifo[place].aborted=0;
        pup->fifo[place].pc=pc+4;
        pup->where.pc=pc+8;
        pup->where.place=place+1;
        pup->decoded=FALSE;     /* instruction will need a cycle to decode */
        if (pup->predicting) {
          if (PredictBranch(pup,place)) {
            pup->state=SpottedBranch; /* can't be full or empty */
            pup->predicting=FALSE;
          }
        }
        if (++pup->words>=MAX_WORDS-1) {
          pup->state|=Full;
          ARMul_RaiseEvent(state,PUEvent_Full,pup->where.pc,0);
        }
        break;
      }
    }
      break;
      
    case FetchInstr:            /* Fetch instructions */
      access_type=acc_LoadInstrS2;
      /* We arrive here from all the states where instructions are fetched
       * into the FIFO, including speculative fetches. The type of fetch
       * (i.e. N vs. S, spec vs. non-spec) will need to have been set up
       * before this label is branched to. */
    fetch_instruction: {
      ARMword pc=pup->where.pc;
      int place=pup->where.place;
      switch (mem_access(mem_handle,pc,
                         &pup->fifo[place].instr,
                         &pup->fifo[place+1].instr,
                         access_type)) {
      case -1:                  /* aborted */
        /* @@@ need to stop fetching, mark the instruction as aborted iff
         * a non-speculative fetch (can do that slowly) etc. */
        pup->fifo[place].instr=ARMul_ABORTWORD;
        pup->predicting=FALSE;
        pup->fifo[place].aborted=1;
        pup->fifo[place].pc=pc;
        pup->where.pc=pc+4;
        pup->where.place=place+1;
        pup->words++;
        break;
      case 0:                   /* failed to fetch anything */
        /* @@@ should go into a NoFetchSpec state */
        break;
      case 1:                   /* fetched 1 instruction */
        pup->fifo[place].aborted=0;
        pup->fifo[place].pc=pc;
        if (pup->predicting) {
          if (PredictBranch(pup,place)) {
            pup->state=SpottedBranch;
            pup->predicting=FALSE;
          }
        }
        pup->where.pc=pc+4;
        pup->where.place=place+1;
        pup->words++;
        break;
      case 2:
        pup->fifo[place].aborted=0;
        pup->fifo[place].pc=pc;
        pup->fifo[place+1].aborted=0;
        pup->fifo[place+1].pc=pc+4;
        if (pup->predicting) {
          if (PredictBranch(pup,place) ||
              PredictBranch(pup,place+1)) {
            pup->state=SpottedBranch;
            pup->predicting=FALSE;
          }
        }
        pup->where.pc=pc+8;
        pup->where.place=place+2;
        pup->words+=2;
        break;
      }
      if (pup->words>=MAX_WORDS-1) {            /* no more space */
        pup->state|=Full;
        ARMul_RaiseEvent(state,PUEvent_Full,pup->where.pc,0);
      }
    }
      break;
      
    case SpottedBranch:
      /* When a branch is spotted, it is too late to prevent issue of the
       * next request, so this will happen here. Once that request has been
       * issued, we go into the BranchWait state, where we are basically
       * waiting for the branch to enter the branch predictor, at which
       * point we start prediction.
       */
      pup->state=(pup->spotted_branch>=3) ? BranchWait : Calculate;
      /* pup->predicting=FALSE; @@@ */
      access_type=acc_LoadInstrS2;
      goto fetch_instruction;
      
    case SpottedBranch | Full:
      pup->state=(pup->spotted_branch>=3) ? (BranchWait | Full)
        : (Calculate | Full);
      /* pup->predicting=FALSE; @@@ */
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;
      
    case SpottedBranch | Empty:
      /* we get here because we have fed a bubble (really the branch) into the core
       * having spotted the branch. (we should have removed the branch too) */
      pup->state=(pup->spotted_branch>=3) ? (BranchWait | Empty) : (Calculate | Empty);
      /* pup->predicting=FALSE; @@@ */
      access_type=acc_LoadInstrS2;
      goto fetch_instruction; /* not empty */
      
    case BranchWait:
    case BranchWait | Full:
    case BranchWait | Empty:
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;
      
      /* Speculative instruction fetch states */
      
      /* NoFetchSpec handled above */
    case FetchSpec1:            /* Starting a speculative fetch sequence */
      pup->state=FetchSpec;
      /* pup->predicting=FALSE; @@@ */
      access_type=acc_LoadInstrN2Spec;
      goto fetch_instruction;
      
    case FetchSpec1 | Empty:    /* Starting a speculative fetch sequence */
      pup->state=FetchSpec;
      /* pup->predicting=FALSE; @@@ */
      access_type=acc_LoadInstrN2Spec;
      /* we arrive here from the speculative/empty states, since before
       * fetching instructions we need to decide what is going to be in
       * the decode stage, based on what type of branch prediction this
       * is. Effectively this is just a CSE of this case, and the branch
       * to the fetch_instruction_empty. */
    fetch_instruction_empty_spec:
      switch (pup->predict) {
      case BranchLink:
      case PredictTaken: pup->in_decode=TargetInDecode; break;
      case PredictNotTaken: pup->in_decode=SkipInDecode; break;
      case NotABranch: default: /* erk */ break;
      }
      goto fetch_instruction_empty;
      
    case FetchSpec:             /* FetchInstr, but speculatively */
      access_type=acc_LoadInstrS2Spec;
      goto fetch_instruction;

    case FetchSpec | Empty:     /* FetchInstr, but speculatively and empty */
      pup->state=FetchSpec;
      access_type=acc_LoadInstrS2Spec;
      goto fetch_instruction_empty_spec;
      
    case NoFetchSpec | Correct:
      pup->state=Correction;
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;

    case NoFetchSpec | Empty | Correct:
      pup->state=Correction | Empty;
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;


      /* Pre-correction states */
    case FetchSpec1 | Correct: /* Finishing a speculative fetch sequence */
      pup->state=Correction;
      access_type=acc_LoadInstrN2Spec;
      goto fetch_instruction;

    case FetchSpec1 | Empty | Correct:
      pup->state=Correction;
      access_type=acc_LoadInstrN2Spec;
      goto fetch_instruction_empty_spec;
      
    case FetchSpec | Correct:
      pup->state=Correction;
      access_type=acc_LoadInstrS2Spec;
      goto fetch_instruction;

    case FetchSpec | Empty | Correct:
      pup->state=Correction;
      access_type=acc_LoadInstrS2Spec;
      goto fetch_instruction_empty_spec;
      
    case NoFetchSpec | Full | Correct:
    case FetchSpec1 | Full | Correct:
    case FetchSpec | Full | Correct:
      pup->state=Correction | Full;
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;

    case NoFetchSpec | Full | Empty | Correct:
    case FetchSpec1 | Full | Empty | Correct:
    case FetchSpec | Full | Empty | Correct:
      pup->state=Correction;
      ShuffleDownSpec(pup);     /* eat empty hole */
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;
      
    case Correction | Full:
    case Correction | Empty:
    case Correction | Full | Empty:
    case Correction:
      n++;                      /* force going around the loop again */
      FixupFIFO(state,pup);
      break;

    case FetchInstr1:           /* restarting real fetchs, but not forced */
      pup->state=FetchInstr;
      access_type=acc_LoadInstrN2;
      goto fetch_instruction;
      
    case FetchInstr1 | Empty:   /* Just did a forced prefetch - flush */
      pup->state=FetchInstr;
      access_type=acc_LoadInstrN2;
      pup->in_decode=NormalInDecode;
      goto fetch_instruction_empty;
      
    case Calculate | Full:
    case Calculate | Empty:
    case Calculate:
      pup->alternate=pup->where;
      switch (pup->predict) {
      case PredictTaken:
      case BranchLink:
        pup->where.pc=pup->branch_target;
        pup->state=FetchSpec1 | (pup->state & (Empty | Full));
        break;
      case PredictNotTaken:
        /* do not fetch any instructions */
        pup->state=FetchSpec | (pup->state & (Empty | Full));
        break;
      default:                  /* error */
        ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): should not be in Calculate state\n");
        ARMul_ModelBroken(state);
        break;
      }
      mem_access(mem_handle,pup->where.pc,NULL,NULL,acc_Icycle);
      break;
      
    default:
      ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): case %03x not handled - %08lx\n",
                         pup->state,state->Reg[15]);
      ARMul_ModelBroken(state);
      return;
    }
  }

  DoDump(pup,"Leaving DoCycles");

  return;
}

/*
 * ARMul_8FetchInstr
 *
 * Function called by ARMulator to fetch an instruction for execution.
 * Normally we just feed an instruction out of the FIFO and then shuffle
 * the FIFO down. However occasionally we need to do more complex things
 * if there are branches to be sorted out. This function deals with
 * inserting correction cycles
 */
ARMword ARMul_8FetchInstr(ARMul_State *state,ARMword *pc)
{
  PU *pup=(PU *)state->proc.arm8.prefetch;
  ARMword instr_instr,instr_pc;
  int instr_aborted;

#define SETINSTR(I) \
  ((instr_instr=(I).instr),     \
   (instr_pc=(I).pc),           \
   (instr_aborted=(I).aborted))
  
  /* when we have to stall the prefetch unit, say because there isn't an
   * instruction to feed to the core, we want to effectively do
   * the stall cycle, and then do this state switch again. In such cases
   * we branch out of the switch back to here. */
 redo_switch:

  /* state_counter[pup->state]++; */

  DoDump(pup,"FetchInstr");

  if (pup->state==FetchInstr) {
  feed_instruction:
    if (pup->decoded) {
      SETINSTR(pup->decode);
      ShuffleDown(pup);
    } else {
      logmessage(decoding);
      ARMul_8DoCycles(state,1);
      goto redo_switch;
    }
  } else switch (pup->state) {
  case Calculate:
  case Calculate | Full:
  case Calculate | Empty:
    pup->alternate=pup->where;
  case FetchSpec1 | Full:
  case FetchSpec | Full:
  case NoFetchSpec | Full:
    /* these are all branch prediction states - so fall through to the
     * branch prediction handling states */
  case NoFetchSpec:
  case FetchSpec1:
  case FetchSpec:
  case NoFetchSpec | Empty:
  case FetchSpec1 | Empty:
  case FetchSpec | Empty:
    /* check to see if we're about to enter the correction cycle */
    switch (--pup->spotted_branch) {
    case EXECUTE: {
      ARMword removed=pup->branch_cond;

      ilog(fprintf(logfile,"%08x: %08x %s\n",pup->branch_pc,pup->branch,
                   dis(pup->branch_pc,pup->branch)); fflush(logfile);)

      /* the instruction we're about to feed to the core needs to be
       * corrected... */
      if (removed==AL ||        /* speed optimisation */
          ((psr_table[state->Flags] >> removed) & 1)) {
        /* branch *is* to be taken */
        pup->state|=Correct;
        announce("Branch to be taken");
        switch (pup->predict) {
        case BranchLink:
        case PredictTaken: pup->correct=PredictTaken_Taken; break;
        case PredictNotTaken: pup->correct=PredictNotTaken_Taken; break;
        default:
          ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): Branch taken - bad case %d\n",pup->predict);
          ARMul_ModelBroken(state);
          DumpPU(pup,"bad case");
          break;
        }
        switch (pup->in_decode) {
        case LinkInDecode:      /* correct prediction (can't have gone wrong!) */
        case TargetInDecode:    /* correct prediction */
          announce("Correctly predicted");
          break;
        case SkipInDecode:      /* in-correct prediction */
        case BranchInDecode:    /* in-correct lack of prediction */
          logmessage(cancelD);
          ARMul_8DoCycles(state,1);
          pup->state|=Empty;
          pup->in_decode++;     /* cancelD */
          /* The DoCycles will load a speculative instruction into the
           * decode slot. If we're not careful this will jump ahead of the
           * real instruction queue! */
          DoDump(pup,"cancelD/2");
          goto redo_switch;
        case DecodeSkipEmpty:
        case DecodeTargetEmpty:
        case DecodeEmpty:       /* nothing in decode */
          announce("Mispredicted");
          logmessage(mispredict - cancelE);
          ARMul_RaiseEvent(state,PUEvent_Mispredict,pup->where.pc,0);
          ARMul_8DoCycles(state,1); /* 1 correction cycle */
#if 0
          FixupFIFO(state,pup);
          /* ShuffleDown(pup); /* was in a state where something may have been
           * fetched */
          /* ShuffleDown doesn't do a "is empty?" check, so we do it here */
          /* if (pup->words<MAX_WORDS-1) pup->state&=~Full; */
#endif
          goto redo_switch;
        case NormalInDecode:    /* should not happen */
        case DecodeBranchEmpty: case DecodeLinkEmpty:
          ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): in_decode=%d - should not happen (line %d)\n",
                             pup->in_decode,__LINE__);
          ARMul_ModelBroken(state);
          DumpPU(pup,"invalid in_decode value\n");
          break;
        }
        if (!pup->decoded) {
          logmessage(decoding);
          ARMul_8DoCycles(state,1);
        }
        SETINSTR(pup->decode);
        ShuffleDownSpec(pup);   /* feed from spec queue for now */
        break;
      } else {
        /* branch is *not* to be taken */
        pup->state|=Correct;
        announce("Branch not taken");
        switch (pup->predict) {
        case PredictTaken: pup->correct=PredictTaken_NotTaken; break;
        case PredictNotTaken: pup->correct=PredictNotTaken_NotTaken; break;
        default:
          ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): Branch not taken - bad case %d\n",
                             pup->predict);
          ARMul_ModelBroken(state);
          DumpPU(pup,"bad case");
          break;
        }
        switch (pup->in_decode) {
        case TargetInDecode:    /* in-correct prediction */
        case BranchInDecode:    /* simulate fed to core, then cancelled */
          logmessage(cancelD);
          ARMul_8DoCycles(state,1);
          pup->state|=Empty;
          pup->in_decode++;     /* cancelD */
          /* The DoCycles will now load a speculative instruction into the
           * decode slot - we need to arrange for a non-target instruction
           * to fill it instead? */
          /* ShuffleDownReal(pup);      /* give a chance to do this correctly. */
          DoDump(pup,"cancelD/1");
          goto redo_switch;
        case DecodeSkipEmpty:
        case DecodeTargetEmpty:
        case DecodeEmpty:       /* nothing in decode */
          announce("Mispredicted");
          logmessage(mispredict - cancelE);
          ARMul_RaiseEvent(state,PUEvent_Mispredict,pup->where.pc,0);
          ARMul_8DoCycles(state,1); /* 1 correction cycle */
#if 0
          FixupFIFO(state,pup);
          ShuffleDown(pup);     /* branch already removed */
          /* ShuffleDown doesn't do a "is empty?" check, so we do it here */
          if (pup->words<MAX_WORDS-1) pup->state&=~Full;
#endif
          goto redo_switch;
        case SkipInDecode:      /* correctly predicted */
          announce("Correctly predicted");
          break;
        case NormalInDecode:    /* should not happen */
        case LinkInDecode: case DecodeBranchEmpty: case DecodeLinkEmpty:
          ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): in_decode=%d - should not happen (line %d)\n",
                             pup->in_decode,__LINE__);
          ARMul_ModelBroken(state);
          break;
        }
        goto feed_instruction;
      }
    }
      break;
    
    case DECODE:
      /* We need to feed a branch target into the decode stage,
       * but a "normal" instruction to execute */
      switch (pup->in_decode) {
      case BranchInDecode:
      case SkipInDecode:
      case LinkInDecode:
      case TargetInDecode:      /* should not happen */
      case DecodeSkipEmpty:
      case DecodeTargetEmpty:
        DumpPU(pup,"Branch/Skip/Link/TargetInDecode - should not happen\n");
        break;
      case DecodeEmpty:
        logmessage(decode empty);
        ARMul_8DoCycles(state,1); /* try to get an instruction */
      case NormalInDecode:
        if (!pup->decoded) {
          logmessage(decoding);
          ARMul_8DoCycles(state,1);
        }
        SETINSTR(pup->decode);
        switch (pup->predict) {
        case PredictTaken:
          ShuffleDown(pup);     /* remove the branch instruction */
          /* ShuffleDown doesn't do a "is empty?" check, so we do it here */
          if (pup->words<MAX_WORDS-1) pup->state&=~Full;
          /* feed in the branch target */
          ShuffleDownSpec(pup);
          break;
        case BranchLink:
          /* feed in a link */
          ShuffleDownLink(pup);
          break;
        case PredictNotTaken:
          /* feed in the instruction after the branch */
          ShuffleDownSkip(pup);
          break;
        default:
          ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): unhandled predict/1 %d\n",pup->predict);
          ARMul_ModelBroken(state);
          DumpPU(pup,"bad case");
          break;
        }
        break;
      }
      break;

    default:
      /* Keep feeding from the normal instruction stream */
      goto feed_instruction;
    }      
    break;


  case SpottedBranch | Full:
  case BranchWait | Full:
    /* we need to check if we are not full now */
    if (pup->words<7) pup->state&=~Full;
    /* drop into a "not full now" state */
    /* fall through to */
  case BranchWait:
  case SpottedBranch:
    if (!pup->decoded) {
      logmessage(decoding);
      ARMul_8DoCycles(state,1);
      goto redo_switch;
    }

    /* check to see if we're ready to branch predict yet */
    if (--pup->spotted_branch>=3) goto feed_instruction; /* act normally */
    pup->state=Calculate | (pup->state & Full);
    if (pup->spotted_branch!=DECODE) goto feed_instruction;

    /* we might be just about to feed the branch into the decode stage,
     * in fact, in which case we need to take some action */
    SETINSTR(pup->decode);
    switch (pup->predict) {
    case PredictTaken:
    case PredictNotTaken:
      ShuffleDown(pup);
      pup->in_decode=BranchInDecode;
      break;
    case BranchLink:
      /* feed in a link */
      ShuffleDownLink(pup);
      break;
    default:
      ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): unhandled predict/2 %d\n",pup->predict);
      ARMul_ModelBroken(state);
      DumpPU(pup,"bad case");
      break;
    }
    break;

  case BranchWait | Empty:
  case SpottedBranch | Empty:
  case FetchInstr | Empty:
  case FetchInstr1 | Empty:     /* don't have a word */
    logmessage(empty);
    ARMul_8DoCycles(state,1);

    /* we might have migrated to a branch-prediction state, and, since
     * we won't be in the (FetchInstr | Full) state, we might as well
     * redo the switch. This is an uncommon case */
    goto redo_switch;

  case FetchInstr | Full:
    /* we need to check if we are not full now */
    if (pup->words<7) pup->state=FetchInstr;
    /* drop into a "not full now" state */
  case FetchInstr:
  case FetchInstr1:
    /* We arrive at this label when we just want to feed the instruction
     * in the decode stage to the core to execute, and then proceed from
     * the normal instruction stream */
    goto feed_instruction;

  case Correction | Empty:
  case Correction | Full:
  case Correction | Full | Empty:
    /* if (pup->words<7) pup->state=Correction; no need to do this - Fixup does */
    /* drop into a "not full now" state */
  case Correction:
    FixupFIFO(state,pup);
    goto redo_switch;
    /* pup->state=FetchInstr1;  /* correction done now. @@@ */
    goto feed_instruction;

  default:
    ARMul_ConsolePrint(state,"\
Prefetch Unit (internal error): case %x not handled in FetchInstr %08lx\n",
                       pup->state,state->Reg[15]);
    ARMul_ModelBroken(state);
    DumpPU(pup,"bad case");
    break;
  }

  if (instr_aborted) {
    ARMword i;
    ARMul_PREFETCHABORT(i,instr_pc);
  }

  *pc=instr_pc;

  DoDump(pup,"Leaving FetchInstr");

  return instr_instr;
}

/*
 * ARMul_8Prefetch
 *
 * Function called by ARMulator to fake an instruction fetch. Like
 * FetchInstr, therefore, except the result is cached in the
 * state
 */
void ARMul_8Prefetch(ARMul_State *state)
{
  DoDump((PU *)state->proc.arm8.prefetch,"Prefetch");

  state->proc.arm8.prefetched.instr=ARMul_8FetchInstr(state,
                                                      &state->proc.arm8.prefetched.pc);

  state->NextInstr=PREFETCHED;
}

void ARMul_8ForcePrefetch(ARMul_State *state,ARMword pc)
{
  PU *pup=(PU *)state->proc.arm8.prefetch;

  announce("ARMul_8ForcePrefetch");
  log(fprintf(logfile,"  forced prefetch from %08x\n",pc));

  pup->state=FetchInstr1 | Empty;
  pup->in_decode=DecodeEmpty;
  pup->where.pc=pc;
  pup->where.place=0;           /* unnecessary except for sanity */
  pup->words=0;                 /* unnecessary except for sanity */
  pup->predicting=pup->state_predicting=state->branchpredictSig;
}

/*
 * Function to snoop writes to the prefetch unit, causing a flush
 * if necessary.
 * Writes from the debugger come to here
 */
static int CheckWrite(void *handle,ARMword address,ARMword *data,
                      ARMul_acc acc)
{
  ARMul_State *state=(ARMul_State *)handle;

  IGNORE(data);

  if (acc_WRITE(acc)) {
    int i;
    ARMword addr = address & ~3; /* word align address */
    PU *pu=(PU *)(state->proc.arm8.prefetch);
    
    /* For now we just abort writes to the PU - should really
     * try to do better
     */
    if (state->NextInstr==PREFETCHED &&
        state->proc.arm8.prefetched.pc==addr) {
      state->NextInstr=RESUME;
    } else if (pu->decode.pc==addr) {
      state->NextInstr=RESUME;
    } else for (i=0;i<pu->where.place;i++) {
      if (pu->fifo[i].pc==addr) {
        state->NextInstr=RESUME;
        return 0;
      }
    }
  }
  return 0;
}

static void ConfigChange(void *handle,ARMword old,ARMword new)
{
  PU *pup=(PU *)handle;
  IGNORE(old);
  announce("ARMul_8PredictSigChanging");
  pup->predicting=pup->state_predicting=(new & MMU_Z)?1:0;
}  

static void ModeChange(void *handle,ARMword old,ARMword new)
{
  PU *pup=(PU *)handle;
  IGNORE(old);
  pup->twenty_six=(new<USER32MODE);
}

static void Exit(void *handle)
{
#if 0
  int i;
  double m=0;
  for (i=0;i<0x100;i++) m+=state_counter[i];
  for (i=0;i<0x100;i++) if (state_counter[i]) {
#if 1
    int n;
    switch (i & ~(Full | Empty | Correct)) {
    case FetchInstr1: n=printf("FetchInstr1"); break;
    case FetchInstr: n=printf("FetchInstr"); break;
    case SpottedBranch: n=printf("SpottedBranch"); break;
    case FetchSpec1: n=printf("FetchSpec1"); break;
    case FetchSpec: n=printf("FetchSpec"); break;
    case NoFetchSpec: n=printf("NoFetchSpec"); break;
    case BranchWait: n=printf("BranchWait"); break;
    case Calculate: n=printf("Calculate"); break;
    case Correction: n=printf("Correction"); break;
    default: continue;
    }
    if (i & Full) n+=printf(" | Full");
    if (i & Empty) n+=printf(" | Empty");
    if (i & Correct) n+=printf(" | Correct");
    printf("%.*s",40-n,"");
#else
    printf("%3d: ",i);
#endif
    printf("%7d %6.2f%%\n",state_counter[i],100.0*(double)state_counter[i]/m);
  }
#endif
  free(handle);
}

ARMul_Error ARMul_8PUInit(ARMul_State *state)
{
  PU *pup=state->proc.arm8.prefetch=(void *)malloc(sizeof(PU));

  ARMul_PrettyPrint(state, ", Prefetch unit");

  if (state->proc.arm8.prefetch==NULL) {
    return ARMul_RaiseError(state,ARMulErr_InitFailPU);
  }
  
  pup->state=FetchInstr1 | Empty;
  pup->in_decode=DecodeEmpty;
  pup->where.pc=0;
  pup->where.place=0;           /* unnecessary except for sanity */
  pup->words=0;                 /* unnecessary except for sanity */
  pup->predicting=pup->state_predicting=state->branchpredictSig;
  pup->astate=state;

  ARMul_InstallConfigChangeHandler(state,ConfigChange,pup);
  ARMul_InstallModeChangeHandler(state,ModeChange,pup);
  ARMul_InstallExitHandler(state,Exit,pup);

  state->rdi_mem_access = CheckWrite;

  return ARMulErr_NoError;
}
