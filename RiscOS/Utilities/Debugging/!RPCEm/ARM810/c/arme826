/*
 * armemu.c - ARMulator main source code.
 * Copyright (C) 1991-96 Advanced RISC Machines Limited.
 * All rights reserved.
 * ARMulator is an ARM6/7/8 instruction set emulator.
 * It is cycle accurate, instruction or cycle based.
 *
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include "armdefsp.h"
#include "armemu.h"
#if defined(ARM8BASED)
#include "armpu.h"
#endif
#include "armsupp.h"

#define ARM8BASED

#if !defined(MODE32) && defined(CODE16)
#undef CODE16
#endif

//
typedef int int32;

/*
 * in non-16-bit modes generate versions of "change_instruction_set"
 * functions that aren't even passed this parameter (which is more
 * efficient than just ignoring it)
 */

#ifndef CODE16
#  define WriteSR15(state,src,change) \
  WriteSR15_32(state,src)
#  define LoadSMult(state,address,instr,WBBase,change) \
  LoadSMult_32(state,address,instr,WBBase)
#endif

static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr);
static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr);
static void WriteR15(ARMul_State *state, ARMword src);
static void WriteSR15(ARMul_State *state, ARMword src,
                      int change_instruction_set);
static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr);
static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address);
static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address);
static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address);
static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address);
static void LoadMult(ARMul_State *state, ARMword address,
                     ARMword instr, ARMword WBBase);
static void StoreMult(ARMul_State *state, ARMword address,
                      ARMword instr, ARMword WBBase);
static void LoadSMult(ARMul_State *state, ARMword address,
                      ARMword instr, ARMword WBBase,
                      int change_instruction_set);
static void StoreSMult(ARMul_State *state, ARMword address,
                       ARMword instr, ARMword WBBase);

static unsigned LoadHalfWord(ARMul_State *state, ARMword instr,
                             ARMword address);
static unsigned LoadSignedHalfWord(ARMul_State *state, ARMword instr,
                                   ARMword address);
static unsigned LoadSignedByte(ARMul_State *state, ARMword instr,
                               ARMword address);
static unsigned StoreHalfWord(ARMul_State *state, ARMword instr,
                              ARMword address);
static unsigned InstructionExtension(ARMul_State *state, ARMword instr);

#ifndef NO_TABLE
/* This table was automatically generated by "buildtbl.c" */
static const unsigned short psr_table[] = {
  /*
   * Each entry is for a particular PSR flags setting - BIT(n) of each entry
   * is set if that condition code (EQ ... NV) succeeds for that PSR setting.
   */
  0x56aa,0x6a6a,0x55a6,0x6966,
  0x66a9,0x6a69,0x66a5,0x6a65,
  0x6a9a,0x565a,0x6996,0x5556,
  0x6a99,0x6659,0x6a95,0x6655
};
#endif


/*
 * MULTIPLY routines
 *
 * These routines each return the number of I-cycles they will have
 * taken to execute.
 */

static int Mult32(ARMul_State *state, ARMword instr) {
/* Calculates a 32-bit result, from two operands.
 */
  ARMword Rm_Reg = state->Reg[MULRHSReg];

#ifdef ARM8BASED
  state->proc.arm8.interlock.req1=((1<<MULLHSReg) | (1<<MULRHSReg))<<16;
  if (MULaccbit) state->proc.arm8.interlock.req2=1<<MULACCReg;
#endif

  if (MULLHSReg == MULDESTReg) {
    UNDEF_MULDestEQOp1;
    state->Reg[MULDESTReg] = 0;
    if (MULsetbit) {
      CLEARN;
      SETZ;
    }
  }else if (MULDESTReg==15 || MULLHSReg==15 || MULRHSReg==15
            || (MULaccbit && MULACCReg==15)) {
    UNDEF_MULPCDest;
  }else{
    ARMword Rd_Reg = state->Reg[MULLHSReg] * Rm_Reg
                   + (MULaccbit ? state->Reg[MULACCReg] : 0);
    if (MULsetbit) {
      ARMul_NegZero(state,Rd_Reg);
    }
    state->Reg[MULDESTReg] = Rd_Reg;
  }

  if (!(state->Processor & ARM_Mult64_Prop)) {
    int bits=0;
    if (Rm_Reg>>16) bits+=16,Rm_Reg>>=16;
    if (Rm_Reg>>8) bits+=8,Rm_Reg>>=8;
    if (Rm_Reg>>4) bits+=4,Rm_Reg>>=4;
    if (Rm_Reg>>2) bits+=2,Rm_Reg>>=2;
    if (Rm_Reg>>1) bits+=1,Rm_Reg>>=1;
    return ARMul_MultTable[bits];
  }else {
    if (Rm_Reg>>31) Rm_Reg=~Rm_Reg; /* Get the positive version of Rm */
    return (Rm_Reg>=0x1000000 ? 4 :
            Rm_Reg>=0x10000 ? 3 :
            Rm_Reg>=0x100 ? 2 :
            1) + MULaccbit;
  }
}

#ifdef CYCLEBASED
static int MultRes(ARMul_State *state, ARMword instr)
{
  UNDEF_ReservedMult;
  if (state->Processor & ARM_Arch4_Prop) {
    ARMul_UndefInstr(state,instr);
    return 0;
  }
  return 1;
}
#endif

static int Mult64(ARMul_State *state, ARMword instr) {
/* Calculates a 64-bit result, from two operands.
 */
  ARMword Rn_Reg, Rm_Reg, ALo, AHi;
  ARMword RnLo, RmLo, RnHi, RmHi;
  ARMword LL, LH, HL, HH; /* Intermediate multiplies */
  ARMword C1, C2, C3; /* Carries */
  ARMword R1, R2; /* Intermediate summations */

  if (!(state->Processor & ARM_Mult64_Prop)) {
    UNDEF_ReservedMult;
    return 1;
  }

#ifdef ARM8BASED
  state->proc.arm8.interlock.req1=((1<<MULLHSReg) | (1<<MULRHSReg))<<16;
  if (MULaccbit) state->proc.arm8.interlock.req2=(1<<MULLOReg) | (1<<MULHIReg);
#endif

  /* Work out Rm here so it can be used for timings calculations even if
   * the instruction is illegal
   */
  Rm_Reg = state->Reg[MULRHSReg];

  if (MULLOReg==15 || MULHIReg==15 || MULLHSReg==15 || MULRHSReg==15) {
    UNDEF_MULPCDest;
  }else{
    if (MULLOReg==MULHIReg || MULHIReg==MULLHSReg || MULLHSReg==MULLOReg) {
      UNDEF_MULDestEQOp1;
    }

    if (MULaccbit) {
      ALo = state->Reg[MULLOReg];
      AHi = state->Reg[MULHIReg];
    }else{
      ALo = AHi = 0;
    }

    Rn_Reg = state->Reg[MULLHSReg];

    RnHi=(Rn_Reg>>16); RmHi=(Rm_Reg>>16);
    RnLo=Rn_Reg-(RnHi<<16); RmLo=Rm_Reg-(RmHi<<16);

    /* Extract the four sub-products */
    LL=RnLo*RmLo; LH=RnLo*RmHi; HL=RnHi*RmLo; HH=RnHi*RmHi;

    /* Calculate the carry into bits 32,33 from the low word. This is tricky
     * without a carry flag to use!
     *
     * Observe that, for A+B, there is a single-bit carry into bit 31,
     * and a single bit carry out. The carry in is Result(31) ^ A(31) ^ B(31),
     * since the low-order bit of an addition is the XOR of the summed bits.
     *
     * Thus:
     */

#define Add33(C,R,A,B) \
 ( (R)=(A)+(B), (C)=(((A)>>31) + ((B)>>31) + (((A)>>31)^((B)>>31)^((R)>>31)))>>1 )

    /*
     * Now regard A+B+C+D as (A+B)+(C+D). This is three simple binary
     * additions, each of which can generate a carry bit.
     */

    Add33(C1, R1, ALo, LL);
    Add33(C2, R2, (ARMword)LH<<16, (ARMword)HL<<16);
    /* (ARMword) casts added to above line to avoid Mac MPW C fault */
    Add33(C3, state->Reg[MULLOReg], R1, R2);

#undef Add33

    /* Forumulate the high word */
    state->Reg[MULHIReg] = AHi + (LH>>16) + (HL>>16) + HH + C1+C2+C3
                         - (MULsigbit ? (NEG(Rn_Reg)?Rm_Reg:0) + (NEG(Rm_Reg)?Rn_Reg:0) : 0);

    if (MULsetbit)
    {
      int tmp = state->Reg[MULHIReg];
      if (state->Reg[MULLOReg] != 0) tmp |= 1; /* ensure non-zero */
      ARMul_NegZero(state, tmp);
    }
  }

  if (Rm_Reg>>31 && MULsigbit) Rm_Reg=~Rm_Reg; /* Get the positive version of Rm_Reg */
  return (Rm_Reg>=0x1000000 ? 5 : Rm_Reg>=0x10000 ? 4 : Rm_Reg>=0x100 ? 3 : 2) + MULaccbit;
}

#if defined(applec) && !defined(__SC__)
#define split_switch
#endif

#ifdef split_switch

#ifdef CODE16
#  define PART(N,I,S,PC,IS) arm_part ## N (I,S,PC,IS)
#else
#  define PART(N,I,S,PC,IS) arm_part ## N (I,S,PC)
#endif

/* segmented to avoid mac 68K C 'local symbol table overflow' */
static void PART(0, ARMword instr, ARMul_State *state, ARMword pc,
                 unsigned int instruction_size)
{
    ARMword dest, lhs, rhs, temp; 
    IGNORE(pc);
    switch(BITS(20,25) | (0<<25))
    {
#define PART0
#include "armcore.c"
#undef PART0
    }
}
static void PART(1, ARMword instr, ARMul_State *state, ARMword pc,
                 unsigned int instruction_size)
{
    ARMword dest, lhs, rhs, temp;
    IGNORE(pc);
    switch(BITS(20,25) + (1<<(25-20+1)))
    {
#define PART1
#include "armcore.c"
#undef PART1
    }
}
static void PART(2, ARMword instr, ARMul_State *state, ARMword pc,
                 unsigned int instruction_size)
{
    ARMword dest, lhs, rhs, temp;
    switch(BITS(20,25) + (2<<(25-20+1)))
    {
#define PART2
#include "armcore.c"
#undef PART2
    }
}
static void PART(3, ARMword instr, ARMul_State *state, ARMword pc,
                 unsigned int instruction_size)
{
    ARMword dest, lhs, rhs, temp;
    int hourglass_counter=8192;
    switch(BITS(20,25) + (3<<(25-20+1)))
    {
#define PART3
#include "armcore.c"
#undef PART3
    }
}
#endif

/*
 * EMULATION of ARM6
 */

#ifdef ARM8BASED
#  ifdef MODE32
#    define ARMul_Emulate ARMul_8Emulate32
#  else
#    define ARMul_Emulate ARMul_8Emulate26
#  endif
#else
#  ifdef MODE32
#    define ARMul_Emulate ARMul_6Emulate32
#  else
#    define ARMul_Emulate ARMul_6Emulate26
#  endif
#endif

ARMword ARMul_Emulate(ARMul_State *state)
{
  ARMword instr,        /* the current instruction */
                   dest,        /* almost the DestBus */
                   temp,        /* ubiquitous third hand */
                   pc;          /* the address of the current instruction */
  ARMword lhs, rhs;             /* almost the ABus and BBus */
  int instruction_size; /* current instruction size (2 or 4 bytes) */
#ifndef ARM8BASED
  ARMul_acc cycle_type;
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
#endif

#ifdef ARM8BASED
  state->proc.arm8.busCycles=0;
#endif /* ARM8 */

/*
 * Execute the next instruction
 */
  
  instruction_size = INSTRUCTIONSIZE;
  
  if (state->NextInstr < PRIMEPIPE) {
    pc = state->pc;
  } else {
    pc = 0;                     /* just to remove a compiler warning */
  }

  do { /* just keep going */
    int hourglass_counter=8192;
#ifdef CODE16
    if (INSTRUCTION16STATE)
      switch (state->NextInstr) {
        /* One load is issued every time we need an instruction (rather
         * than fetching 2 at a time). Shift bits to get the instruction into
         * the lower bits of the pipeline variables.
         */
      case SEQ :
        state->Reg[15] += INSTRUCTION16SIZE; /* Advance the pipeline, and an S cycle */
        cycle_type=acc_LoadInstr16S;
      loadinstr16: {
        int prefetch;
        ARMword fetch_addr;

        pc+=INSTRUCTION16SIZE; /* Program counter advanced, and an S cycle */
        instr=state->proc.arm6.decoded;
        state->proc.arm6.decoded=state->proc.arm6.loaded;

        fetch_addr=pc+INSTRUCTION16SIZE*2;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.loaded,cycle_type);
        } while (prefetch==0);
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);

        state->proc.arm7.last_prefetch=prefetch;
      }
        break;

      case NONSEQ :
        state->Reg[15] += INSTRUCTION16SIZE; /* Advance the pipeline, and an N cycle */
        /* fall through to... */
      case PCINCEDNONSEQ :
        cycle_type=acc_LoadInstr16N;
        NORMALCYCLE;
        goto loadinstr16;

      case PCINCEDSEQ :         /* most common case? */
        cycle_type=acc_LoadInstr16S;
        NORMALCYCLE;
        goto loadinstr16;
        
      case RESUME : {           /* The program counter has been changed */
        ARMword newinstr;
        int prefetch;
        ARMword fetch_addr;

        instruction_size = INSTRUCTION16SIZE;
        pc = state->Reg[15];
#ifndef MODE32
        pc = pc & R15PCBITS;
#endif
        state->Reg[15] = pc + PCR15DIFFERENCE16;
        state->AbortAddr = 1;

        fetch_addr=pc;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &newinstr,acc_DontAccount(acc_LoadInstr16N));
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(newinstr,fetch_addr);
        instr=newinstr;         /* avoid passing ptr to instr out */

        fetch_addr+=INSTRUCTION16SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.decoded,acc_DontAccount(acc_LoadInstr16S));
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.decoded,fetch_addr);

        fetch_addr+=INSTRUCTION16SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.loaded,acc_DontAccount(acc_LoadInstr16S));
        } while (prefetch=0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);

        state->proc.arm7.last_prefetch=prefetch;
        NORMALCYCLE;
      }
        break;
        
      default: {                /* The program counter has been changed */
        ARMword newinstr;
        int prefetch;
        ARMword fetch_addr;

        instruction_size = INSTRUCTION16SIZE;
        pc = state->Reg[15];
#ifndef MODE32
        pc = pc & R15PCBITS;
#endif
        state->Reg[15] = pc + PCR15DIFFERENCE16;
        state->AbortAddr = 1;

        fetch_addr=pc;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,&newinstr,acc_LoadInstr16N);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(newinstr,fetch_addr);
        instr=newinstr;         /* Avoid passing ptr to instr out */

        fetch_addr+=INSTRUCTION16SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                          &state->proc.arm6.decoded,acc_LoadInstr16S);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.decoded,fetch_addr);

        fetch_addr+=INSTRUCTION16SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.loaded,acc_LoadInstr16S);
        } while (prefetch==0 && Hourglass()); 
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);

        state->proc.arm7.last_prefetch=prefetch;
        NORMALCYCLE;
      }
        break;
      }
    else
#endif

      switch (state->NextInstr) {
#ifndef ARM8BASED
      case SEQ:
        cycle_type=acc_LoadInstrS;
        state->Reg[15] += INSTRUCTION32SIZE; /* Advance the pipeline, and an S cycle */
      loadinstr32: {
        int prefetch;
        ARMword fetch_addr;

        pc += INSTRUCTION32SIZE; /* Program counter advanced, and an S cycle */
        instr = state->proc.arm6.decoded;
        state->proc.arm6.decoded = state->proc.arm6.loaded;

        fetch_addr=pc+INSTRUCTION32SIZE*2;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,&state->proc.arm6.loaded,
                              cycle_type);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);

        state->proc.arm7.last_prefetch=prefetch;
      }
        break;

      case NONSEQ :
        state->Reg[15] += INSTRUCTION32SIZE; /* Advance the pipeline, and an N cycle */
        /* fall through to ... */
      case PCINCEDNONSEQ :
        cycle_type=acc_LoadInstrN;
        NORMALCYCLE;
        goto loadinstr32;
        
      case PCINCEDSEQ :
        cycle_type=acc_LoadInstrS;
        NORMALCYCLE;
        goto loadinstr32;

#else /* ARM8 */
      case SEQ: {
        ARMword local_pc;
        instr=ARMul_8FetchInstr(state,&local_pc);
        pc=local_pc;
        state->Reg[15]=pc+8;
      }
        break;

      case PREFETCHED:
        instr=state->proc.arm8.prefetched.instr;
        pc=state->proc.arm8.prefetched.pc;
        state->Reg[15]=pc+8;
        NORMALCYCLE;
        break;
#endif /* ARM8 */
        
      case RESUME :
#ifndef ARM8BASED
      {         /* The program counter has been changed */
        /* @@@ ARM8 - How do we do this??? We need to RESUME the prefetch-unit
         * state too! */
        ARMword newinstr;
        int prefetch;
        ARMword fetch_addr;

        instruction_size = INSTRUCTION32SIZE;
        pc = state->Reg[15];
#ifndef MODE32
        pc = pc & R15PCBITS;
#endif
        state->Reg[15] = pc + PCR15DIFFERENCE32;
        state->AbortAddr = 1;

        fetch_addr=pc;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &newinstr,acc_DontAccount(acc_LoadInstrN));
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(newinstr,fetch_addr);
        instr=newinstr;

        fetch_addr+=INSTRUCTION32SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.decoded,acc_DontAccount(acc_LoadInstrS));
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.decoded,fetch_addr);
        
        fetch_addr+=INSTRUCTION32SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.loaded,acc_DontAccount(acc_LoadInstrS));
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);

        state->proc.arm7.last_prefetch=prefetch;
        NORMALCYCLE;
      }
        break;
#endif                          /* @@@ ARM8 just fall through for now */
        
      default: {                /* The program counter has been changed */
#ifndef ARM8BASED
        ARMword newinstr;
        int prefetch;
        ARMword fetch_addr;

        instruction_size = INSTRUCTION32SIZE;
        pc = state->Reg[15];
#ifndef MODE32
        pc = pc & R15PCBITS;
#endif
        state->Reg[15] = pc + PCR15DIFFERENCE32;
        state->AbortAddr = 1;

        fetch_addr=pc;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &newinstr,acc_LoadInstrN);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(newinstr,fetch_addr);
        instr=newinstr;

        fetch_addr+=INSTRUCTION32SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.decoded,acc_LoadInstrS);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.decoded,fetch_addr);
        
        fetch_addr+=INSTRUCTION32SIZE;
        do {
          prefetch=mem_access(mem_handle,fetch_addr,
                              &state->proc.arm6.loaded,acc_LoadInstrS);
        } while (prefetch==0 && Hourglass());
        if (prefetch==-1) ARMul_PREFETCHABORT(state->proc.arm6.loaded,fetch_addr);
        state->proc.arm7.last_prefetch=prefetch;
#else /* ARM8 */
        ARMword local_pc;
        instruction_size = INSTRUCTION32SIZE;
        pc = state->Reg[15];
#ifndef MODE32
        pc = pc & R15PCBITS;
#endif
        state->AbortAddr = 1;
        ARMul_8ForcePrefetch(state,pc);
        instr=ARMul_8FetchInstr(state,&local_pc);
        pc = local_pc;
        state->Reg[15]=pc+8;
        /* all interlocks will be cleared by this */
        state->proc.arm8.interlock.late=state->proc.arm8.interlock.early=0;
#endif /* ARM8 */

        NORMALCYCLE;
      }
        break;
      }
    
#ifdef ARM8BASED
    state->proc.arm8.takenIcycles=1;
#endif /* ARM8 */

    if (state->Exception) {
      /*
       * ARMulator is in an exceptional state, either:
       *   Event about to occur
       *   An ARM exception (FIQ/IRQ/Nreset)
       */
      if (state->EventSet) ARMul_InvokeEvent(state);

      if (!state->NresetSig || !state->NfiqSig || !state->NirqSig) {
        /* all the "sig"s are inverse, so we need to invert the bits when we
         * pass them to CallInterrupt - hence "^ 0x7"
         */
        ARMul_CallInterrupt(state, (((state->NresetSig<<2) |
                                     (state->NirqSig<<1) |
                                     (state->NfiqSig<<0)) ^ 0x7));
      }

      if (!state->NresetSig) {
        ARMul_Abort(state,ARMul_ResetV,instr);
        break;
      } else if (!state->NfiqSig && !FFLAG) {
        ARMul_Abort(state,ARMul_FIQV,instr);
        break;
      } else if (!state->NirqSig && !IFLAG) {
        ARMul_Abort(state,ARMul_IRQV,instr);
        break;
      }

      if (state->hourglass) {
        ARMul_Hourglass(state,pc,instr);
      }
    }
        
    if (state->CallDebug > 0) {
      instr = ARMul_Debug(state,pc,instr);
      if (state->Emulate < ONCE) {
#ifndef ARM8BASED
        state->NextInstr = RESUME;
#else
        state->proc.arm8.prefetched.instr=instr;
        state->proc.arm8.prefetched.pc=pc;
        state->NextInstr=PREFETCHED;
#endif
        break;
      }
    } else if (state->Emulate < ONCE) {
#ifndef ARM8BASED
      state->NextInstr = RESUME;
#else
      state->proc.arm8.prefetched.instr=instr;
      state->proc.arm8.prefetched.pc=pc;
      state->NextInstr=PREFETCHED;
#endif
      break;
    }
    
    state->NumInstrs++;

/*
 * Check state
 */

#ifdef CODE16
    if (INSTRUCTION16STATE) {
#if 1
      /*
       * just do this and rely on the CC failing in the "-1" case. that
       * removes a single comparison from the critical path on thumb
       */
      instr = ARMul_ProcessThumbInstr(state, instr);
#else
      if ((instr = ARMul_ProcessThumbInstr(state, instr)) == (ARMword)-1)
        goto code16resume;      /* @@@ why explicitly? the CC will fail anyway. */
#endif
    }
#endif

/*
 * Check the condition codes - this code is far, far better than the original
 * ARMulator in speed terms.
 */

        temp=TOPBITS(28);
        if (temp==AL ||             /* speed optimisation */
        ((psr_table[state->Flags] >> temp) & 1)) {

/*
 * Actual execution of instructions begins here
 */

      /* to get here the CC's MUST have matched */

#ifdef split_switch
      /*
       * sometimes this is faster than the 256-way switch, it seems to
       * vary wildly. What about a simple decision tree instead, with
       * the path optimised for the (presumably) more frequent "00" and
       * "01" cases.
       */
      switch ((int)BITS(26,27)) {
      case 0:                   /* about 55% of cases */
        /*
         * data processing - 00xxxx
         * PSR transfer    - 00xxxx
         * multiply        - 000000  (1001)
         * SWP             - 00010x  (1001)
         */
        PART(0, instr, state, pc, instruction_size);
        break;
      case 1:                   /* about 24% of cases */
        /*
         * single data transfer - 01x
         * undefined            - 011  (1)
         */
        PART(1, instr, state, pc, instruction_size);
        break;
      case 2:                   /* about 21% of cases */
        /*
         * multiple data transfer - 100
         * branch/branch and link - 101
         */        
        PART(2, instr, state, pc, instruction_size);
        break;
      case 3:                   /* less than 1% of cases */
        /*
         * CPDT - 110
         * CPDO - 1110  (0)
         * CPRT - 1110  (1)
         * SWIs - 1111
         */
        PART(3, instr, state, pc, instruction_size);
        break;
      }
#else
      switch ((int)BITS(20,27)) {
        /* include main switch core, not affected at all by mac changes */
#define PART0
#define PART1
#define PART2
#define PART3
#include "armcore.c"
      } /* 256 way main switch */
#endif
    }                           /* CC switch */

#if defined(CODE16) && 0
  code16resume:
#endif

#ifdef ARM8BASED
    if (state->proc.arm8.takenIcycles) {
      /*
       * some interlocks still to resolve.
       * This also means that there are now no new interlocks to deal with,
       * since it is required that when a new interlock is generated,
       * takenIcycles is set to zero (i.e. in load functions).
       */
      int cycles=ARMul_8InterlockCycles(state)+state->proc.arm8.takenIcycles;
      state->proc.arm8.interlock.late=(cycles>1) ? (state->proc.arm8.interlock.late>>16) : 0;
      ARMul_8DoCycles(state,cycles);
      state->proc.arm8.interlock.early=0;
    }
    
    /*
     * Interlocks are done at the start of an instruction, and, when done,
     * the number of outstanding Icycles (including 1 for the instruction
     * itself) are added on, and that counter is zeroed. So if that counter
     * is now zero, then interlocks must have already been resolved.
     */

#endif /* ARM8 */

    if (state->Emulate == ONCE)
      state->Emulate = STOP;
    else if (state->Emulate != RUN)
      break;
  } while (1); /* do loop */
  state->pc = pc;

  return(pc);
} /* Emulate 26/32 in instruction based mode */


/*
 * This routine evaluates most Data Processing register RHS's with the S
 * bit clear.  It is intended to be called from the macro DPRegRHS, which
 * filters the common case of an unshifted register with in line code
 */

static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base;

 base = RHSReg;

#ifdef ARM8BASED
 state->proc.arm8.takenIcycles=2;
#endif /* ARM8 */

 if (BIT(4)) { /* shift amount in a register */
#ifndef ARM8BASED
    int hourglass_counter=8192;
#endif
    UNDEF_Shift;
    INCPC;
#ifdef ARM8BASED
    state->proc.arm8.interlock.req1=(1<<base) | (1<<BITS(8,11));
    state->proc.arm8.interlock.req2=1<<LHSReg;
#endif /* ARM8 */

#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE;
    else
#endif
       base = state->Reg[base];
#ifndef ARM8BASED
    while (MEM_ACCESS(state)(state->mem.handle,0,NULL,acc_Icycle)==0 && Hourglass())
      ;
#endif /* ARM8 */

    shamt = state->Reg[BITS(8,11)] & 0xff;
    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base);
                  else if (shamt >= 32)
                     return(0);
                  else
                     return(base << shamt);
       case LSR : if (shamt == 0)
                     return(base);
                  else if (shamt >= 32)
                     return(0);
                  else
                     return(base >> shamt);
       case ASR : if (shamt == 0)
                     return(base);
                  else if (shamt >= 32)
                     return((ARMword)((long int)base >> 31L));
                  else
                     return((ARMword)((long int)base >> (int)shamt));
       case ROR : shamt &= 0x1f;
                  if (shamt == 0)
                     return(base);
                  else
                     return((base << (32 - shamt)) | (base >> shamt));
       }
    }
 else { /* shift amount is a constant */
#ifdef ARM8BASED
    state->proc.arm8.interlock.req1=(1<<base);
    state->proc.arm8.interlock.req2=1<<LHSReg;
#endif /* ARM8 */
#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE;
    else
#endif
    base = state->Reg[base];
    shamt = BITS(7,11);
    switch ((int)BITS(5,6)) {
       case LSL :
#ifdef ARM8BASED
         if (shamt<4) state->proc.arm8.takenIcycles=1;
#endif
                  return(base<<shamt);
       case LSR : if (shamt == 0)
                     return(0);
                  else
                     return(base >> shamt);
       case ASR : if (shamt == 0)
                     return((ARMword)((long int)base >> 31L));
                  else
                     return((ARMword)((long int)base >> (int)shamt));
       case ROR : if (shamt==0) /* its an RRX */
                     return((base >> 1) | (CFLAG << 31));
                  else
                     return((base << (32 - shamt)) | (base >> shamt));
       }
    }
 return(0); /* just to shut up lint */
 }

/*
 * This routine evaluates most Logical Data Processing register RHS's
 * with the S bit set.  It is intended to be called from the macro
 * DPSRegRHS, which filters the common case of an unshifted register
 * with in line code.
 */
static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base;

 base = RHSReg;

#ifdef ARM8BASED
 state->proc.arm8.takenIcycles=2;
#endif /* ARM8 */

 if (BIT(4)) { /* shift amount in a register */
#ifndef ARM8BASED
    int hourglass_counter=8192;
#endif
    UNDEF_Shift;
    INCPC;
#ifdef ARM8BASED
    state->proc.arm8.interlock.req1=(1<<base) | (1<<BITS(8,11));
    state->proc.arm8.interlock.req2=1<<LHSReg;
#endif /* ARM8 */

#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE;
    else
#endif
       base = state->Reg[base];

#ifndef ARM8BASED
    while (MEM_ACCESS(state)(state->mem.handle,0,NULL,acc_Icycle)==0 && Hourglass())
      ;
#endif

    shamt = state->Reg[BITS(8,11)] & 0xff;

    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base);
                  else if (shamt == 32) {
                     ASSIGNC(base & 1);
                     return(0);
                     }
                  else if (shamt > 32) {
                     CLEARC;
                     return(0);
                     }
                  else {
                     ASSIGNC((base >> (32-shamt)) & 1);
                     return(base << shamt);
                     }
       case LSR : if (shamt == 0)
                     return(base);
                  else if (shamt == 32) {
                     ASSIGNC(base >> 31);
                     return(0);
                     }
                  else if (shamt > 32) {
                     CLEARC;
                     return(0);
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1);
                     return(base >> shamt);
                     }
       case ASR : if (shamt == 0)
                     return(base);
                  else if (shamt >= 32) {
                     ASSIGNC(base >> 31L);
                     return((ARMword)((long int)base >> 31L));
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1);
                     return((ARMword)((long int)base >> (int)shamt));
                     }
       case ROR : if (shamt == 0)
                     return(base);
                  shamt &= 0x1f;
                  if (shamt == 0) {
                     ASSIGNC(base >> 31);
                     return(base);
                     }
                  else {
                     ASSIGNC((base >> (shamt-1)) & 1);
                     return((base << (32-shamt)) | (base >> shamt));
                     }
       }
    }
 else { /* shift amount is a constant */
#ifdef ARM8BASED
    state->proc.arm8.interlock.req1=(1<<base);
    state->proc.arm8.interlock.req2=1<<LHSReg;
#endif /* ARM8 */

#ifndef MODE32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE;
    else
#endif
       base = state->Reg[base];
    shamt = BITS(7,11);
    switch ((int)BITS(5,6)) {
       case LSL :
#ifdef ARM8BASED
         if (shamt<4) state->proc.arm8.takenIcycles=1;
#endif /* ARM8 */
                  ASSIGNC((base >> (32-shamt)) & 1);
                  return(base << shamt);
       case LSR : if (shamt == 0) {
                     ASSIGNC(base >> 31);
                     return(0);
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1);
                     return(base >> shamt);
                     }
       case ASR : if (shamt == 0) {
                     ASSIGNC(base >> 31L);
                     return((ARMword)((long int)base >> 31L));
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1);
                     return((ARMword)((long int)base >> (int)shamt));
                     }
       case ROR : if (shamt == 0) { /* its an RRX */
                     shamt = CFLAG;
                     ASSIGNC(base & 1);
                     return((base >> 1) | (shamt << 31));
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1);
                     return((base << (32-shamt)) | (base >> shamt));
                     }
       }
    }
 return(0); /* just to shut up lint */
 }

/*
 * This routine handles writes to register 15 when the S bit is not set.
 */

static void WriteR15(ARMul_State *state, ARMword src)
{
#ifdef MODE32
#ifdef CODE16
  state->Reg[15] = PCADDRESSBITS(src);
#else
 state->Reg[15] = src & PCBITS;
#endif
#else
 state->Reg[15] = (src & R15PCBITS) | ECC | ER15INT | EMODE;
 ARMul_R15Altered(state);
 state->Reg[15] = src & R15PCBITS;
#endif
 FLUSHPIPE;
 }

/*
 * This routine handles writes to register 15 when the S bit is set.
 */

static void WriteSR15(ARMul_State *state, ARMword src,
                      int change_instruction_set)
{
#ifdef MODE32
 state->Reg[15] = src;
 if (state->Bank > 0) {
    state->Cpsr = state->Spsr[state->Bank];
#ifdef CODE16
    if (change_instruction_set)
      SETINSTRUCTIONSET(CPSRINSTRUCTIONSET(state->Cpsr));
#endif
    ARMul_CPSRAltered(state);
  }
#ifdef CODE16
    state->Reg[15] = PCM;
#else
    state->Reg[15] &= PCBITS;
#endif
#else
 if (state->Bank == USERBANK)
    state->Reg[15] = (src & (CCBITS | R15PCBITS)) | ER15INT | EMODE;
 else
    state->Reg[15] = src;
 ARMul_R15Altered(state);
 state->Reg[15] = src & R15PCBITS;
#endif
 FLUSHPIPE;
}

/*
 * This routine evaluates most Load and Store register RHS's.  It is
 * intended to be called from the macro LSRegRHS, which filters the
 * common case of an unshifted register with in line code
 */

static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr)
{
  ARMword shamt, base;

 base = RHSReg;
#ifdef ARM8BASED
  state->proc.arm8.interlock.req1|=RHSReg;
#endif /* ARM8 */
#ifndef MODE32
 if (base == 15)
    base = ECC | ER15INT | R15PC | EMODE; /* Now forbidden, but .... */
 else
#endif
    base = state->Reg[base];

 shamt = BITS(7,11);
 switch ((int)BITS(5,6)) {
    case LSL : return(base << shamt);
    case LSR : if (shamt == 0)
                  return(0);
               else
                  return(base >> shamt);
    case ASR : if (shamt == 0)
                  return((ARMword)((long int)base >> 31L));
               else
                  return((ARMword)((long int)base >> (int)shamt));
    case ROR : if (shamt==0) /* its an RRX */
                  return((base >> 1) | (CFLAG << 31));
               else
                  return((base << (32-shamt)) | (base >> shamt));
    }
 return(0); /* just to shut up lint */
 }

/*
 * Load/Store handling functions
 */

/*
 * This function does the work of loading a word for a LDR instruction.
 */

static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword dest;
  int fetch;
  ARMword aborted=0;
  int hourglass_counter=8192;
#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

 BUSUSEDINCPCS;

#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  do {
    fetch=mem_access(mem_handle,address,&dest,acc_LoadWordN);
  } while (fetch==0 && Hourglass());
  if ((fetch<0 && (aborted=ARMul_DataAbortV)) || aborted) {
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }

#ifndef ARM8BASED
  if (address & 3) ARMul_Align(state,address,&dest);
#else /* ARM8 */

  if (address & 3) {
    ARMul_Align(state,address,&dest);
    state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
    state->proc.arm8.interlock.early=0;
  } else {
    state->proc.arm8.interlock.late=late;
    state->proc.arm8.interlock.early=1<<DESTReg;
  }
#endif /* ARM8 */

  WRITEDEST(dest);

#ifndef ARM8BASED
  while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
    ;
#endif /* ARM8 */

  return(DESTReg != LHSReg);
}

/*
 * This function does the work of loading a byte for a LDRB instruction.
 */

static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword dest;
  int fetch;
  ARMword aborted=0;
  int hourglass_counter=8192;
#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCS;
#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  do {
    fetch=mem_access(mem_handle,address,&dest,acc_LoadByte);
  } while (fetch==0 && Hourglass());
  if ((fetch<0 && (aborted=ARMul_DataAbortV)) || aborted) {
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }
  UNDEF_LSRBPC;

#ifdef ARM8BASED
  if ((address & 3)!=(ARMword)(state->bigendSig ? 3 : 0)) {
    state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
    state->proc.arm8.interlock.early=0;
  } else {
    state->proc.arm8.interlock.late=late;
    state->proc.arm8.interlock.early=1<<DESTReg;
  }
#endif /* ARM8 */

  WRITEDEST(dest);
#ifndef ARM8BASED
  while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
    ;
#endif /* ARM8 */
  return(DESTReg != LHSReg);
}


/*
 * This function does the work of loading a halfword
 */

static unsigned LoadHalfWord(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword dest;
  int fetch;
  ARMword aborted=0;
  int hourglass_counter=8192;
#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCS;
#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
   INTERNALABORT(aborted,address);
 }
#endif

  do {
    fetch=mem_access(mem_handle,address,&dest,acc_LoadHalfWord);
  } while (fetch==0 && Hourglass());
  if ((fetch<0 && (aborted=ARMul_DataAbortV))) {
    ARMul_Abort(state,ARMul_DataAbortV,address);
    return(state->lateabtSig);
  }
  if (address & 1) dest=((dest & 0xff) << 8) | (dest >> 8);

  UNDEF_LSRHPC;

#ifdef ARM8BASED
  if ((address & 2)!=(ARMword)(state->bigendSig ? 2 : 0)) {
    state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
    state->proc.arm8.interlock.early=0;
  } else {
    state->proc.arm8.interlock.late=late;
    state->proc.arm8.interlock.early=1<<DESTReg;
  }
#endif /* ARM8 */

  WRITEDEST(dest);

#ifndef ARM8BASED
  while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
    ;
#endif /* ARM8 */

  return(DESTReg != LHSReg);
}

/*
 * This function does the work of loading a signed halfword
 */

static unsigned LoadSignedHalfWord(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword dest;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCS;
#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  do {
    fetch=mem_access(mem_handle,address,&dest,acc_LoadHalfWord);
  } while (fetch==0 && Hourglass());
  if ((fetch<0 && (aborted=ARMul_DataAbortV)) || aborted) {
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }

#ifdef ARM8BASED
  state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
#endif /* ARM8 */
  if (address & 1) dest = ((dest & 0xff) << 8) | (dest >> 8);



  /* sign-extend word using a shift */
  dest=(ARMword)(((int32)(dest<<16))>>16);
  /* if (dest & 0x8000) dest |= 0xffff0000; */

  UNDEF_LSRHPC;
  WRITEDEST(dest);

#ifndef ARM8BASED
  while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
    ;
#endif /* ARM8 */

  return(DESTReg != LHSReg);
}

/*
 * This function does the work of storing a halfword for a STRH instruction.
 */

static unsigned StoreHalfWord(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  int fetch;
  ARMword aborted=0;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+
                 (BIT(22) ? 1 /* offset is immediate */: 2));
  state->proc.arm8.takenIcycles=0;        /* just done the single cycle, whatever */

  /* because we just took the instruction cycle, we must deal with inter-
   * locks ourselves */
  /* if a register offset, then we took an extra cycle, so there are now
   * no interlocks to worry about next time */
  if (BIT(22)) {
    state->proc.arm8.interlock.late=(state->proc.arm8.interlock.late>>16);
  } else {
    state->proc.arm8.interlock.late=0;
  }
  state->proc.arm8.interlock.early=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCN;

#ifdef MODE32
  do {
    fetch=mem_access(mem_handle,address,&DEST,acc_StoreHalfWord);
  } while (fetch==0 && Hourglass());
  if (fetch<0) aborted=ARMul_DataAbortV;
#else
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    ARMword null;
    INTERNALABORT(aborted,address);
    while (mem_access(mem_handle,address,&null,acc_LoadHalfWord))
      ;
  } else {
    if (DESTReg==15) {
      ARMword r15=ECC | ER15INT | R15PC | EMODE;
      do {
        fetch=mem_access(mem_handle,address,&r15,acc_StoreHalfWord);
      } while (fetch==0 && Hourglass());
    } else {
      do {
        fetch=mem_access(mem_handle,address,&DEST,acc_StoreHalfWord);
      } while (fetch==0 && Hourglass());
    }
    if (fetch<0) aborted=ARMul_DataAbortV;
  }
#endif

  if (aborted) {
    if (state->Processor & ARM_Abort7_Prop) {
      ARMword null;
#ifdef CODE16
      if (INSTRUCTION16STATE)
        while (mem_access(mem_handle,PC16,&null,acc_LoadInstr16S)==0 && Hourglass())
          ;
      else
#endif

#ifndef ARM8BASED
        while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
          ;
#else /* ARM8 */
        ARMul_8FetchInstr(state,&null);
#endif /* ARM8 */
    }
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }

 UNDEF_LSRHPC;
 return(TRUE);
}

/*
 * This function does the work of loading a signed byte.
 */

static unsigned LoadSignedByte(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword dest;
  int fetch;
  ARMword aborted=0;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCS;
#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  do {
    fetch=mem_access(mem_handle,address,&dest,acc_LoadByte);
  } while (fetch==0 && Hourglass());
  if ((fetch<0 && (aborted=ARMul_DataAbortV)) || aborted) {
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }
  UNDEF_LSRBPC;

#ifdef ARM8BASED
  state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
#endif

  /* sign-extend word using some signed-shifts */
  dest=(ARMword)(((int32)(dest<<24))>>24);
  /* if (dest & 0x80) dest |= 0xffffff00; */

  WRITEDEST(dest);

#ifndef ARM8BASED
  while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
    ;
#endif

  return(DESTReg != LHSReg);
}

/*
 * This function deals with all kinds of SWP and SWPB
 */
static unsigned Swap(ARMul_State *state,ARMword instr)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMul_acc acc=BIT(22) ? (acc_LoadByte | acc_rlw) : (acc_LoadWordN | acc_rlw);
  ARMword address=LHS;
  int hourglass_counter=8192;
#ifdef ARM8BASED
  ARMword late;
  unsigned int cycles=state->proc.arm8.takenIcycles;

  /* do interlocks before loading word */
  late=(cycles>1) ? 0 : (state->proc.arm8.interlock.late>>16);
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+cycles);
  state->proc.arm8.takenIcycles=0;

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  BUSUSEDINCPCS;
#ifndef MODE32
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    ARMword null;
    INTERNALABORT(state->Aborted,address);
    while (mem_access(mem_handle,address,&null,acc)==0 && Hourglass())
      ;
    while (mem_access(mem_handle,address,&null,acc)==0 && Hourglass())
          ;
    TAKEABORT;
  } else
#endif
  {
    ARMword dest;
    int fetch;
    do {
      fetch=mem_access(mem_handle,address,&dest,acc);
    } while (fetch==0 && Hourglass());
    if (fetch>0) {
      acc|=acc_Nrw;             /* read->write */
      do {
        fetch=mem_access(mem_handle,address,&state->Reg[RHSReg],acc);
      } while (fetch==0 && Hourglass());
    }
    if (fetch<0) {
      ARMul_Abort(state,ARMul_DataAbortV,address);
    } else {
#ifndef ARM8BASED
      if (!BIT(22) && (address & 3)) ARMul_Align(state,address,&dest);
#else /* ARM8 */

      if (!BIT(22) && (address & 3)) {
        ARMul_Align(state,address,&dest);
        state->proc.arm8.interlock.late=late | ((1<<16)<<DESTReg);
        state->proc.arm8.interlock.early=0;
      } else {
        state->proc.arm8.interlock.late=late;
        state->proc.arm8.interlock.early=1<<DESTReg;
      }
#endif /* ARM8 */
      DEST=dest;
    }
  }

  return FALSE;
}

/*
 * This function deals with instructions in the arithmetic and load-store
 * instruction spaces:
 *   -  Multiplies
 *   -  Long multiplies
 *   -  Swap/Swap Byte
 *   -  Load/Store Halfword
 *   -  Load Signed byte/halfword
 */
static unsigned InstructionExtension(ARMul_State *state, ARMword instr)
{
  /* instr is in the load/store instruction space */
  unsigned int op1=BITS(5,6);
  unsigned int prop=state->Processor;

  if (op1==0) {                 /* SWP and multiplies */    
    if (BIT(24)) {              /* SWP */
      if ((prop & ARM_Lock_Prop) && (BITS(20,23) & 0xb)==0)
        return Swap(state,instr);
    } else {                    /* multiply */
      op1=BITS(20,23);
      if (op1<4 && (prop & ARM_Mult32_Prop)) { /* short multiply */
        DoIcycles(Mult32(state,instr));
        return FALSE;
      } else if (op1>=8 && (prop & ARM_Mult64_Prop)) {
        /* long multiply */
        DoIcycles(Mult64(state,instr));
        return FALSE;
      }
    }
  } else if (prop & ARM_Halfword_Prop) { /* half word etc. */
    /* calculate address and pass on to LoadHalfWord */
    ARMword address,base;
    int wb;

    base=LHS;

    Bit22Interlock;

    if (BIT(22)) {              /* immediate offset */
      ARMword offset=(instr & 0x0f) | ((instr>>4) & 0xf0);
      address=(BIT(23)) ? (base+offset) : (base-offset);
    } else {            /* register offset */
      ARMword offset=state->Reg[RHSReg];
      address=(BIT(23)) ? (base+offset) : (base-offset);
    }

    if (BIT(24)) {              /* preindexed */
      base=address;
      wb=BIT(21);
    } else {                    /* postindexed */
      if (BIT(21)) {            /* write-back bit */
        if (state->Processor & ARM_Arch4_Prop) {
          ARMul_UndefInstr(state,instr);
          return FALSE;
        } else {
          ARMul_SetNtrans(state,LOW);
        }
        wb=0;
      } else {
        wb=1;
      }
    }

    if (BIT(20)) {              /* load */
      switch (op1) {
      default:
      case 1:                   /* %01 - unsigned halfword */
        wb&=LoadHalfWord(state,instr,base);
        break;
      case 2:                   /* %10 - signed byte */
        wb&=LoadSignedByte(state,instr,base);
        break;
      case 3:                   /* %11 - signed halfword */
        wb&=LoadSignedHalfWord(state,instr,base);
        break;
      }
    } else {                    /* store */
      if (op1==1) {             /* unsigned halfword */
        wb&=StoreHalfWord(state,instr,base);
      } else {
        ARMul_UndefInstr(state,instr); /* in all cases */
        return FALSE;
      }
    }

    if (wb) LSBase = address;

    if (BIT(21) && BIT(24)) {   /* write-back */
      ARMul_SetNtrans(state,HIGH);
    }

    return FALSE;
  }

  /* Not handled */
  if (state->Processor & ARM_Arch4_Prop) {
    ARMul_UndefInstr(state,instr);
    return FALSE;
  }

  return TRUE;
}


/*
 * This function does the work of storing a word from a STR instruction.
 */

static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+
                 (BIT(25) ? 2 /* offset is a register */: 1));
  state->proc.arm8.takenIcycles=0;        /* just taken the single cycle */

  /* because we just took the instruction cycle, we must deal with inter-
   * locks ourselves */
  /* if a register offset, then we took an extra cycle, so there are now
   * no interlocks to worry about next time */
  if (BIT(25)) {
    state->proc.arm8.interlock.late=0;
  } else {
    state->proc.arm8.interlock.late=(state->proc.arm8.interlock.late>>16);
  }
  state->proc.arm8.interlock.early=0;

  ARMul_8Prefetch(state);
#else                           /* ARM8 */
  /* Check for ARM7 abort bug */
  if ((state->Processor & ARM_SubPage_Prop) &&
      state->proc.arm7.last_prefetch==-1) {
    /* patch instruction in prefetch queue to be a SWI really */
    state->proc.arm7.decoded=0xefffffff;
  }
#endif /* ARM8 */

  BUSUSEDINCPCN;

#ifdef MODE32
  do {
    fetch=mem_access(mem_handle,address,&DEST,acc_StoreWordN);
  } while (fetch==0 && Hourglass());
  if (fetch<0) aborted=ARMul_DataAbortV;
#else
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    ARMword null;
    INTERNALABORT(aborted,address);
    while (mem_access(mem_handle,address,&null,acc_LoadWordN)==0 && Hourglass())
      ;
  } else {
    if (DESTReg == 15) {
      ARMword r15=ECC | ER15INT | R15PC | EMODE;
      do {
        fetch=mem_access(mem_handle,address,&r15,acc_StoreWordN);
      } while (fetch==0 && Hourglass());
    } else {
      do {
        fetch=mem_access(mem_handle,address,&DEST,acc_StoreWordN);
      } while (fetch==0 && Hourglass());
    }
    if (fetch<0) aborted=ARMul_DataAbortV;
  }
#endif

  if (aborted) {
    if (state->Processor & ARM_Abort7_Prop) {
      ARMword null;
#ifdef CODE16
      if (INSTRUCTION16STATE)
        while (mem_access(mem_handle,PC,&null,acc_LoadInstr16S)==0 && Hourglass())
          ;
      else
        while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
          ;
#else
      while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
        ;
#endif
    }
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }

  return(TRUE);
}

/*
 * This function does the work of storing a byte for a STRB instruction.
 */

static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+
                 (BIT(25) ? 2 /* offset is a register */ : 1));
  state->proc.arm8.takenIcycles=0;        /* just done the single cycle */

  /* because we just took the instruction cycle, we must deal with inter-
   * locks ourselves */
  /* if a register offset, then we took an extra cycle, so there are now
   * no interlocks to worry about next time */
  if (BIT(25)) {
    state->proc.arm8.interlock.late=0;
  } else {
    state->proc.arm8.interlock.late=(state->proc.arm8.interlock.late>>16);
  }
  state->proc.arm8.interlock.early=0;

  ARMul_8Prefetch(state);
#else
  /* Check for ARM7 abort bug */
  if ((state->Processor & ARM_SubPage_Prop) &&
      state->proc.arm7.last_prefetch==-1) {
    /* patch instruction in prefetch queue to be a SWI really */
    state->proc.arm7.decoded=0xefffffff;
  }
#endif /* ARM8 */

  BUSUSEDINCPCN;

#ifdef MODE32
  do {
    fetch=mem_access(mem_handle,address,&DEST,acc_StoreByte);
  } while (fetch==0 && Hourglass());
  if (fetch<0) aborted=ARMul_DataAbortV;
#else
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    ARMword null;
    INTERNALABORT(aborted,address);
    while (mem_access(mem_handle,address,&null,acc_LoadByte)==0 && Hourglass())
      ;
  } else {
    if (DESTReg == 15) {
      ARMword r15=ECC | ER15INT | R15PC | EMODE;
      do {
        fetch=mem_access(mem_handle,address,&r15,acc_StoreByte);
      } while (fetch==0 && Hourglass());
    } else {
      do {
        fetch=mem_access(mem_handle,address,&DEST,acc_StoreByte);
      } while (fetch==0 && Hourglass());
    }
    if (fetch<0) aborted=ARMul_DataAbortV;
  }
#endif
  if (aborted) {
    if (state->Processor & ARM_Abort7_Prop) {
      ARMword null;
#ifdef CODE16
      if (INSTRUCTION16STATE) 
        while (mem_access(mem_handle,PC16,&null,acc_LoadInstr16S)==0 && Hourglass())
          ;
      else
        while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
          ;
#else
      while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
        ;
#endif
    }
    ARMul_Abort(state,aborted,address);
    return(state->lateabtSig);
  }
  UNDEF_LSRBPC;
  return(TRUE);
}

/*
 * This function does the work of loading the registers listed in an LDM
 * instruction, when the S bit is clear.  The code here is always increment
 * after, it's up to the caller to get the input address correct. It handles
 * base register modification.
 */

#ifndef ARM8BASED
/* Single bandwidth load multiple */
static void LoadMult(ARMul_State *state, ARMword instr,
                     ARMword address, ARMword WBBase)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword btemp;
  ARMword *regp;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCS;

#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  /* Write-back base register */
  if (BIT(21) && LHSReg != 15)
    LSBase = WBBase;

  for (regp=&state->Reg[0],btemp=1;
       (instr & btemp)==0;
       regp++,btemp<<=1)
    ; /* N cycle first */

  if (btemp==(1<<16)) return;

  /* Check for ARM7 abort bug */
  if ((state->Processor & ARM_SubPage_Prop) &&
      state->proc.arm7.last_prefetch==-1 &&
      /* Only effects single-word store multiples */
      btemp==(instr & 0xffff)) {
    /* patch instruction in prefetch queue to be a SWI really */
    state->proc.arm7.decoded=0xefffffff;
  }

  btemp<<=1;

  if (!aborted) {
    do {
      fetch=mem_access(mem_handle,address,regp,acc_LoadWordN);
    } while (fetch==0 && Hourglass());
    regp++;
    if (fetch<0) {
      aborted = ARMul_DataAbortV;
      btemp<<=1;
      goto aborted_l;
    }
    for (;btemp<(1<<16);btemp<<=1,regp++)       /* S cycles from here on */
      if (instr & btemp) {      /* load this register */
        address += 4;
        do {
          fetch=mem_access(mem_handle,address,regp,acc_LoadWordS);
        } while (fetch==0 && Hourglass());
        if (fetch<0) {
          aborted = ARMul_DataAbortV;
          btemp<<=1;
          goto aborted_l;
        }
      }
    if (BIT(15)) {              /* PC is in the reg list */
#ifdef CODE16
      state->Reg[15] = PCM;
#else
      state->Reg[15] = PC;
#endif
      FLUSHPIPE;
    } 
    while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
      ;                         /* to write back the final register */
  } else {
    ARMword null;
    ARMword abort_addr;
#if !defined(MODE32)
    while (mem_access(mem_handle,address,&null,acc_LoadWordS)==0 && Hourglass())
      ;
#endif
  aborted_l:
    abort_addr=address;
    for (;btemp<(1<<16);btemp<<=1) /* S cycles from here on */
      if (instr & btemp) {      /* load this register */
        address += 4;
        do {
          fetch=mem_access(mem_handle,address,&null,acc_LoadWordS);
        } while (fetch==0 && Hourglass());
      }
    
    if (BIT(21) && LHSReg != 15) {
      LSBase=WBBase;
    }
    while (mem_access(mem_handle,0,NULL,acc_Icycle)==0 && Hourglass())
      ;                         /* to write back the final register */
    ARMul_Abort(state,aborted,abort_addr);
  }
}
#else                           /* ARM8 */
/* double bandwidth load */
static void LoadMult(ARMul_State *state, ARMword instr,
                     ARMword address, ARMword WBBase)
{
  armul_MemAccess2 *mem_access2=state->mem.x.arm8.access2;
  void *mem_handle=state->mem.handle;
  ARMword btemp1,btemp2;
  ARMword *regp1,*regp2;
  ARMword aborted=0;
  int reg1,reg2,last_reg=0;
  int bus_cycles=0;
  ARMword base=LSBase;
  int hourglass_counter=8192;

  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+2);
  state->proc.arm8.takenIcycles=0;        /* just done that cycle */

  ARMul_8Prefetch(state);

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;

  BUSUSEDINCPCS;

#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  /* Write-back base register */
  if (BIT(21) && LHSReg != 15)
    LSBase = WBBase;

  for (reg1=0,regp1=&state->Reg[0],btemp1=1;
       reg1<16 && (instr & btemp1)==0;
       reg1++,regp1++,btemp1<<=1)
    ; /* N cycle first */

  if (reg1==16) return;

  /* find the second register */
  for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp1<<1);
       reg2<16 && (instr & btemp2)==0;
       reg2++,regp2++,btemp2<<=1)
    ;

  bus_cycles=0;
  if (!aborted) {
    ARMul_acc access;
    if (reg2<16) access=acc_LoadWordN2;
    else access=acc_LoadWordN;
    do {
    retry_fetch:
      bus_cycles++;
      switch (mem_access2(mem_handle,address,regp1,regp2,access)) {
      case -1:                  /* aborted */
        aborted=ARMul_DataAbortV;
        goto aborted_l;

      case 0:                   /* got no words */
        if (Hourglass())
          goto retry_fetch;

      case 1:                   /* got one word */
        last_reg=btemp1;

        if (reg2<16) {
          address+=4;
          regp1=regp2;
          reg1=reg2;
          btemp1=btemp2;

          /* find the second register for the next loop */
          for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp2<<1);
               reg2<16 && (instr & btemp2)==0;
               reg2++,regp2++,btemp2<<=1)
            ;

          if (reg2<16) access=acc_LoadWordS2;
          else access=acc_LoadWordS;
        } else {
          access=0;
        }
        break;

      case 2:                   /* got two words */
        address+=8;
        last_reg=btemp1 | btemp2;

        /* find the first register for the next loop */
        for (reg1=reg2+1,regp1=regp2+1,btemp1=btemp2<<1;
             reg1<16 && (instr & btemp1)==0;
             reg1++,regp1++,btemp1<<=1)
          ;

        if (reg1<16) {
          /* find the second register for the next loop */
          for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp1<<1);
               reg2<16 && (instr & btemp2)==0;
               reg2++,regp2++,btemp2<<=1)
            ;
          if (reg2<16) access=acc_LoadWordS2;
          else access=acc_LoadWordS;
        } else {
          access=0;
        }
        break;
      }
    } while (access);
    if (BIT(15)) {              /* PC is in the reg list */
#ifdef CODE16
      state->Reg[15] = PCM;
#else
      state->Reg[15] = PC;
#endif
      FLUSHPIPE;
    }
  } else {
  aborted_l:
    if (BIT(21) && LHSReg != 15)
      LSBase=base;

    ARMul_Abort(state,aborted,address);
  }
  
  /* last register(s) fetched aren't available for the next instruction to use
   * two registers interlocked. */
  state->proc.arm8.interlock.early=last_reg;
  /* because we took an idle cycle earlier, there now can't be any late
   * interlocks from the last instruction. */
  state->proc.arm8.interlock.late=0;      /* no new lates */

  /* do "bus_cycles-1" cycles on the bus. The last bus cycle, signalled by
   * "state->proc.arm8.busCycles" has to be done after the following instruction
   * fetch. */
  if (BIT(15)) {
    /* take an extra cycle (which will be the idle one) */
    ARMul_8DoIdleCycles(state,bus_cycles);
    state->proc.arm8.busCycles=0;
  } else if (--bus_cycles>0) {
    ARMul_8DoIdleCycles(state,bus_cycles);
  }
}
#endif /* ARM8 */

/*
 * This function does the work of loading the registers listed in an LDM
 * instruction, when the S bit is set. The code here is always increment
 * after, it's up to the caller to get the input address correct. It handles
 * base-register modification.
 */

#ifndef ARM8BASED
static void LoadSMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase,
                      int change_instruction_set)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword btemp;
  ARMword *regp;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCS;

#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  if (!BIT(15) && state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE); /* temporary reg bank switch */
    UNDEF_LSMUserBankWb;
  }

  /* Write-back base register */
  if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

  for (btemp=1,regp=&state->Reg[0];
       btemp<(1<<16) && (instr & btemp)==0;
       btemp<<=1,regp++)
    ;                           /* N cycle first */

  if (btemp==(1<<16)) return;

  btemp<<=1;
  if (!aborted) {
    do {
      fetch=mem_access(mem_handle,address,regp,acc_LoadWordN);
    } while (fetch==0 && Hourglass());
    regp++;
    if (fetch<0) {
      aborted=ARMul_DataAbortV;
      goto aborted_l;
    }
    
    for (;btemp<(1<<16);btemp<<=1,regp++) /* S cycles from here on */
      if (instr & btemp) { /* load this register */
        address += 4;
        do {
          fetch=mem_access(mem_handle,address,regp,acc_LoadWordS);
        } while (fetch==0 && Hourglass());
        if (fetch<0) {
          aborted=ARMul_DataAbortV;
          goto aborted_l;
        }
      }
    
    if (BIT(15)) { /* PC is in the reg list */
#ifdef MODE32
      if (state->Mode != USER26MODE && state->Mode != USER32MODE
          && state->Mode != SYSTEM32MODE) {
        state->Cpsr = GETSPSR(state->Bank);
#ifdef CODE16
        if (change_instruction_set)
          SETINSTRUCTIONSET(CPSRINSTRUCTIONSET(state->Cpsr));
#endif
        ARMul_CPSRAltered(state);
      }
#ifdef CODE16
      state->Reg[15] = PCM;
#else
      state->Reg[15] = PC;
#endif
#else
      if (state->Mode == USER26MODE || state->Mode == USER32MODE) {
        /* protect bits in user mode */
        state->Flags=state->Reg[15]>>28;
      } else
        ARMul_R15Altered(state);
#endif
      FLUSHPIPE;
    }
  } else {
    ARMword null,abort_addr;
#ifndef MODE32
    while (mem_access(mem_handle,address,&null,acc_LoadWordS)==0 && Hourglass())
      ;
#endif
  aborted_l:
    abort_addr=address;
    for (;btemp<(1<<16);btemp<<=1) /* S cycles from here on */
      if (instr & btemp) { /* load this register */
        address += 4;
        while (mem_access(mem_handle,address,&null,acc_LoadWordS)==0 && Hourglass())
          ;
      }
    if (BIT(21) && LHSReg != 15)
      LSBase=WBBase;

    ARMul_Abort(state,aborted,abort_addr);
  }

  if (!BIT(15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    /* restore the correct bank */
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode);
}

#else                           /* ARM8 */

/* double bandwidth load */
static void LoadSMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase,
                      int change_instruction_set)
{
  armul_MemAccess2 *mem_access2=state->mem.x.arm8.access2;
  void *mem_handle=state->mem.handle;
  ARMword btemp1,btemp2;
  ARMword *regp1,*regp2;
  ARMword aborted=0;
  int reg1,reg2,last_reg=0;
  int bus_cycles=0;
  ARMword base=LSBase;
  int hourglass_counter=8192;

  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+2);
  state->proc.arm8.takenIcycles=0;        /* just done that cycle */

  ARMul_8Prefetch(state);

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;


  BUSUSEDINCPCS;

#ifndef MODE32
  if (VECTORLOAD(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
#endif

  if (!BIT(15) && state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE); /* temporary reg bank switch */
    UNDEF_LSMUserBankWb;
  }


  /* Write-back base register */
  if (BIT(21) && LHSReg != 15)
    LSBase = WBBase;

  for (reg1=0,regp1=&state->Reg[0],btemp1=1;
       reg1<16 && (instr & btemp1)==0;
       reg1++,regp1++,btemp1<<=1)
    ; /* N cycle first */
  
  if (reg1==16) return;

  /* find the second register */
  for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp1<<1);
       reg2<16 && (instr & btemp2)==0;
       reg2++,regp2++,btemp2<<=1)
    ;

  bus_cycles=0;
  if (!aborted) {
    ARMul_acc access;
    if (reg2<16) access=acc_LoadWordN2;
    else access=acc_LoadWordN;
    do {
    retry_fetch:
      bus_cycles++;
      switch (mem_access2(mem_handle,address,regp1,regp2,access)) {
      case -1:                  /* aborted */
        aborted=ARMul_DataAbortV;
        goto aborted_l;

      case 0:                   /* can't happen - indicates failed spec fetch */
        if (Hourglass())
          goto retry_fetch;

      case 1:                   /* got one word */
        last_reg=btemp1;

        if (reg2<16) {
          address+=4;
          regp1=regp2;
          reg1=reg2;
          btemp1=btemp2;

          /* find the second register for the next loop */
          for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp2<<1);
               reg2<16 && (instr & btemp2)==0;
               reg2++,regp2++,btemp2<<=1)
            ;

          if (reg2<16) access=acc_LoadWordS2;
          else access=acc_LoadWordS;
        } else {
          access=0;
        }
        break;

      case 2:                   /* got two words */
        address+=8;
        last_reg=btemp1 | btemp2;

        /* find the first register for the next loop */
        for (reg1=reg2+1,regp1=regp2+1,btemp1=btemp2<<1;
             reg1<16 && (instr & btemp1)==0;
             reg1++,regp1++,btemp1<<=1)
          ;

        if (reg1<16) {
          /* find the second register for the next loop */
          for ((reg2=reg1+1),(regp2=regp1+1),(btemp2=btemp1<<1);
               reg2<16 && (instr & btemp2)==0;
               reg2++,regp2++,btemp2<<=1)
            ;
          if (reg2<16) access=acc_LoadWordS2;
          else access=acc_LoadWordS;
        } else {
          access=0;
        }
        break;
      }
    } while (access);

  if (BIT(15)) { /* PC is in the reg list */
#ifdef MODE32
    if (state->Mode != USER26MODE && state->Mode != USER32MODE
        && state->Mode != SYSTEM32MODE) {
      state->Cpsr = GETSPSR(state->Bank);
#ifdef CODE16
      if (change_instruction_set)
        SETINSTRUCTIONSET(CPSRINSTRUCTIONSET(state->Cpsr));
#endif
      ARMul_CPSRAltered(state);
    }
#ifdef CODE16
    state->Reg[15] = PCM;
#else
    state->Reg[15] = PC;
#endif
#else
      if (state->Mode == USER26MODE || state->Mode == USER32MODE) {
        /* protect bits in user mode */
      state->Flags=state->Reg[15]>>28;
    } else
      ARMul_R15Altered(state);
#endif
    FLUSHPIPE;
  }
  } else {
  aborted_l:
    
    if (BIT(21) && LHSReg != 15)
      LSBase=base;

    ARMul_Abort(state,aborted,address);
  }
  
  if (!BIT(15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    /* restore the correct bank */
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode);

  /* last register(s) fetched aren't available for the next instruction to use
   * two registers interlocked. */
  state->proc.arm8.interlock.early=last_reg;
  /* because we took an idle cycle earlier, there now can't be any late
   * interlocks from the last instruction. */
  state->proc.arm8.interlock.late=0;      /* no new lates */

  /* do "bus_cycles-1" cycles on the bus. The last bus cycle, signalled by
   * "state->proc.arm8.busCycles" has to be done after the following instruction
   * fetch. */
  if (BIT(15)) {
    /* take an extra cycle (which will be the idle one) */
    ARMul_8DoIdleCycles(state,bus_cycles);
    state->proc.arm8.busCycles=0;
  } else if (--bus_cycles>0) {
    ARMul_8DoIdleCycles(state,bus_cycles);
  }
}
#endif /* ARM8 */

/*
 * This function does the work of storing the registers listed in an STM
 * instruction, when the S bit is clear.  The code here is always increment
 * after, it's up to the caller to get the input address correct. It handles
 * base register modification.
 */

/* @@@ Um... The abort handling in this code looks wrong to me - MJW */

static void StoreMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword btemp;
  ARMword dest = 0;
  ARMword aborted=0;
  ARMword *ptr;
  int fetch;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMword base=LSBase;
  int bus_cycles=0;

  /* we take an extra cycle here if:
   * - the base register is interlocked or
   * - we are only transferring one register
   * if both then, er, um... 2 extra cycles?
   */
  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+
                 (((instr & (instr-1))<<16) ? 1 /* >1 registers */ : 2));
  state->proc.arm8.takenIcycles=0;        /* done the single cycle */

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCN;

#ifndef MODE32
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }
  if (BIT(15))
    state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
#endif

  for (ptr=&state->Reg[0],btemp=1;
       btemp<(1<<16) && !(instr & btemp);
       ptr++,btemp<<=1);                /* N cycle first */

  if (btemp==(1<<16)) return;

  /* Check for ARM7 abort bug */
  if ((state->Processor & ARM_SubPage_Prop) &&
      state->proc.arm7.last_prefetch==-1 &&
      /* Only effects single-word store multiples */
      btemp==(instr & 0xffff)) {
    /* patch instruction in prefetch queue to be a SWI really */
    state->proc.arm7.decoded=0xefffffff;
  }


#ifdef ARM8BASED
  bus_cycles=1;
#endif /* ARM8 */

  /* First do the N cycle */
  if (!aborted) {
    btemp<<=1;
    do {
      fetch=mem_access(mem_handle,address,ptr,acc_StoreWordN);
    } while (fetch==0 && Hourglass());
    ptr++;
    if (fetch<0) {
      aborted=ARMul_DataAbortV;
      dest++;
      goto aborted_l;
    }

    /* Write-back base register */
    if (BIT(21) && LHSReg != 15)
      LSBase = WBBase;

    /* Now do the S cycles */
    for (; btemp < (1<<16); btemp<<=1,ptr++) /* S cycles from here on */
      if (instr & btemp) {        /* save this register */
        address += 4;
#ifdef ARM8BASED
        bus_cycles++;
#endif
        do {
          fetch=mem_access(mem_handle,address,ptr,acc_StoreWordS);
        } while (fetch==0 && Hourglass());
        if (fetch<0) {
          aborted = ARMul_DataAbortV;
          btemp<<=1;
          dest++; /* count the aborts */
          goto aborted_l;
        }
      }

#ifndef MODE32
    if (BIT(15) && !aborted)
      state->Reg[15] = PC;
#endif

  } else {
    ARMword null;
#ifndef ARM8BASED
#ifndef MODE32
    while (mem_access(mem_handle,address,&null,acc_StoreWordN)==0 && Hourglass())
      ;
#endif
  aborted_l:
    for (;btemp<(1<<16);btemp<<=1)
      if (instr & btemp) {      /* save this register */
        address += 4;
        while (mem_access(mem_handle,address,&null,acc_StoreWordS)==0 && Hourglass())
          ;
        dest++; /* count the aborts */
      }

    /* Write back base register */
    if (BIT(21) && LHSReg != 15)
      LSBase=WBBase;
#else                           /* ARM8 */
  aborted_l:
    /* Write back base register */
    if (BIT(21) && LHSReg != 15)
      LSBase=base;
#endif
    
    if ((state->Processor & ARM_Abort7_Prop) && dest == 0)
#ifdef CODE16
      if (INSTRUCTION16STATE)
        while (mem_access(mem_handle,PC16,&null,acc_LoadInstr16S)==0 && Hourglass())
          ;
      else
#endif
        while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
          ;
    ARMul_Abort(state,aborted,address);
  }

#ifdef ARM8BASED
  /* because we took an idle cycle earlier, there now can't be any late
   * interlocks from the last instruction. */
  state->proc.arm8.interlock.early=0;
  state->proc.arm8.interlock.late=0;      /* no new lates */

  if (--bus_cycles>0) {
    ARMul_8DoIdleCycles(state,bus_cycles);
  }
#endif /* ARM8 */
}

/*
 * This function does the work of storing the registers listed in an STM
 * instruction when the S bit is set.  The code here is always increment
 * after, it's up to the caller to get the input address correct. It handles
 * base-register modification.
 */

static void StoreSMult(ARMul_State *state, ARMword instr,
                       ARMword address, ARMword WBBase)
{
  armul_MemAccess *mem_access=MEM_ACCESS(state);
  void *mem_handle=state->mem.handle;
  ARMword btemp;
  ARMword dest = 0;
  ARMword *ptr;
  ARMword aborted=0;
  int fetch;
  int hourglass_counter=8192;

#ifdef ARM8BASED
  ARMword base=LSBase;
  int bus_cycles=0;

  ARMul_8DoCycles(state,ARMul_8InterlockCycles(state)+
                 (((instr & (instr-1))<<16) ? 1 /* >1 registers */ : 2));
  state->proc.arm8.takenIcycles=0;        /* done the single cycle */

  ARMul_8Prefetch(state);
#endif /* ARM8 */

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCN;

#ifndef MODE32
  if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(aborted,address);
  }

  if (BIT(15)) state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
#endif

  for (ptr=&state->Reg[0],btemp=1;
       (instr & btemp)==0;
       btemp<<=1,ptr++)
    ; /* N cycle first */

#ifdef ARM8BASED
  bus_cycles=1;
#endif /* ARM8 */

  if (btemp==(1<<16)) return;

  /* Check for ARM7 abort bug */
  if ((state->Processor & ARM_SubPage_Prop) &&
      state->proc.arm7.last_prefetch==-1 &&
      /* Only effects single-word store multiples */
      btemp==(instr & 0xffff)) {
    /* patch instruction in prefetch queue to be a SWI really */
    state->proc.arm7.decoded=0xefffffff;
  }

  if (state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE); /* Force User Bank */
    UNDEF_LSMUserBankWb;
  }

  /* First do the N cycle */
  if (!aborted) {
    btemp<<=1;
    do {
      fetch=mem_access(mem_handle,address,ptr,acc_StoreWordN);
    } while (fetch==0 && Hourglass());
    ptr++;
    if (fetch<0) aborted=ARMul_DataAbortV;

    /* Write-back base register */
    if (BIT(21) && LHSReg != 15)
      LSBase = WBBase;

    for (; btemp < (1<<16); btemp<<=1,ptr++) /* S cycles from here on */
      if (instr & btemp) { /* save this register */
        address += 4;
#ifdef ARM8BASED
        bus_cycles++;
#endif /* ARM8 */
        do {
          fetch=mem_access(mem_handle,address,ptr,acc_StoreWordS);
        } while (fetch==0 && Hourglass());
        if (fetch<0) {
          aborted = ARMul_DataAbortV;
          btemp<<=1;
          dest++; /* count the aborts */
          goto aborted_l;
        }
      }
    
    if (state->Mode != USER26MODE && state->Mode != USER32MODE)
      (void)ARMul_SwitchMode(state,USER26MODE,state->Mode); /* restore the correct bank */
    
#ifndef MODE32
    if (BIT(15) )
      state->Reg[15] = PC;
#endif

  } else {
    ARMword null;
    ARMword abort_addr;
#ifndef ARM8BASED
#ifndef MODE32
    while (mem_access(mem_handle,address,&null,acc_LoadWordN)==0 && Hourglass())
      ;
#endif
  aborted_l:
    abort_addr=address;
    for (; btemp<(1<<16);btemp<<=1)
      if (instr & btemp) { /* save this register */
        address += 4;
        while (mem_access(mem_handle,address,&null,acc_StoreWordS)==0 && Hourglass())
          ;
        dest++; /* count the aborts */
      }

    /* Write-back base register */
    if (BIT(21) && LHSReg != 15)
      LSBase=WBBase;
#else                           /* ARM8 */
  aborted_l:
    if (BIT(21) && LHSReg != 15)
      LSBase=base;

    abort_addr=address;
#endif
    
    if (state->Mode != USER26MODE && state->Mode != USER32MODE)
      (void)ARMul_SwitchMode(state,USER26MODE,state->Mode); /* restore the correct bank */

    if ((state->Processor & ARM_Abort7_Prop) && dest == 0)
#ifdef CODE16
      if (INSTRUCTION16STATE)
        while (mem_access(mem_handle,PC16,&null,acc_LoadInstr16S)==0 && Hourglass())
          ;
      else
#endif
        while (mem_access(mem_handle,PC,&null,acc_LoadInstrS)==0 && Hourglass())
          ;
    ARMul_Abort(state,aborted,abort_addr);
  }

#ifdef ARM8BASED
  /* because we took an idle cycle earlier, there now can't be any late
   * interlocks from the last instruction. */
  state->proc.arm8.interlock.early=0;
  state->proc.arm8.interlock.late=0;      /* no new lates */

  if (--bus_cycles>0) {
    ARMul_8DoIdleCycles(state,bus_cycles);
  }
#endif /* ARM8 */
}

