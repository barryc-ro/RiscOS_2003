/* Interface to the Monochrome LCD of the L7205
 * Thu 27th July 2000 DR Ellis
 */

#include "MLCD.h"
#include "wimp.h"
#include "utils.h"


MLCD mlcd;

int
MLCD_init ()
{
    fout ("Initialising MLCD\n");
    /* Pretend we've always reached the end of the line */
    mlcd.eof = 1;

    return 0;
}

#define BIT(DATA,B) ((DATA >> B) & 1)

AbortOrNot
MLCD_clock (
    BusState*   state
) {
    /* Check that the address is legal */
    if (state->address >= sizeof (mlcd))
    {
        fout ("Illegal memory access to MLCD %x\n", state->address);
        return DataAbort;
    }

    /* Act on the memory write */
    if (state->write)
    {
        WORDACCESS(&mlcd, state->address) = state->data;
        mlcd.eof = 1;
    } else {
        state->data = WORDACCESS(&mlcd, state->address);
    }

    return DataSuccess;
}

/* Going to sort this out soon. */
#if 0
typedef struct {
  int flags;
  int x;
  int y;
  int log2bpp;
  int frame;
  int term;
} ModeSel;

ModeSel mode={1,32,32,0,-1,-1};

typedef struct {
  int next;
  char name[12];
  int width;
  int height;
  int fbit,lbit;
  int image;
  int mask;
  int mode;
} Sprite;

Sprite cursor = {0,"cursor",0,0,0,31,0,0,19};

int *ctrans;
int wid,hei,cbpp;
int screen_size;
int screen_width;

void new_screen(void)
{
  int size;
  _kernel_swi_regs regs;

  if (hen <= hst || ven <= vst) return;

  size = mlcd.bpp * (mlcd.pixels + 1) * mlcd.lines / 2;
  screen_size = size;
  screen_width = mlcd.bpp * (mlcd.pixels / 16 - 1);
  size += 512+512;   // a bit + a bit for pallette one day

  if (san) {
    regs.r[0] = 1;
    regs.r[1] = san;
    _kernel_swi(OS_DynamicArea,&regs,&regs);
  }

  regs.r[0] = 0;
  regs.r[1] = -1;
  regs.r[2] = size;
  regs.r[3] = -1;
  regs.r[4] = 128;
  regs.r[5] = size;
  regs.r[6] = 0;
  regs.r[7] = 0;
  regs.r[8] = (int) "LinkUp Screen";
  if (!_kernel_swi(OS_DynamicArea,&regs,&regs)) {
    if (!san) atexit(remscr);
    san = regs.r[1];
    sad = (unsigned int *) regs.r[3];
  }
  else return;

  sad[0] = size;
  sad[2] = 16;
  _swix(OS_SpriteOp,_IN(0) | _IN(1),256+ 9,sad);

  mode.log2bpp = logbpp;
  regs.r[0] = 15+256;
  regs.r[1] = (int) sad;
  regs.r[2] = (int) "luscreen";
  regs.r[3] = 0;    // don't include palette
  regs.r[4] = hen-hst;
  regs.r[5] = ven-vst;
  regs.r[6] = (int) &mode;

  _kernel_swi(OS_SpriteOp,&regs,&regs);

  regs.r[0] = (int) &mode;
  regs.r[1] = (bpp>8) ? -1 : (int) palette;
  regs.r[2] = -1;
  regs.r[3] = -1;
  regs.r[4] = 0;
  regs.r[5] = 0;

  _kernel_swi(ColourTrans_SelectTable,&regs,&regs);

  if (ctrans) free (ctrans);
  ctrans = malloc(regs.r[4]);
  regs.r[4] = (int) ctrans;

  _kernel_swi(ColourTrans_SelectTable,&regs,&regs);

  wid = hen-hst;
  hei = ven-vst;
  cbpp = bpp;

  screen_word = (unsigned int *)(sad + sad[12]/4 +4);
  screen = (unsigned char *) screen_word;
  newsc = 1;
  palch = 0;
}
#endif

#define os_plot(a,b,c) _swix(OS_Plot,_IN(0) |_IN(1) |_IN(2),a,b,c)
void render_screen(WimpRedrawWindowBlock *block)
{
/*   _kernel_swi_regs regs;

   // draw border
   _swix(ColourTrans_SetGCOL,_IN(0) |_IN(3) |_IN(4),border<<8,128,0);

   if (!sad) {*/
     _swix(0x110,0);		// CLG
/*     return;
   } else {
     os_plot(68,block->visible_area.xmin-block->xscroll,block->visible_area.ymax-block->yscroll);
     os_plot(99,64+2*wid,-96);
     os_plot(99,-32,-32-2*hei);
     os_plot(99,-32-2*wid,32);
     os_plot(99,32,2*hei);
   }

   if (palch) {
     regs.r[0] = (int) &mode;
     regs.r[1] = (bpp>8) ? -1 : (int) palette;
     regs.r[2] = -1;
     regs.r[3] = -1;
     regs.r[4] = (int) ctrans;
     regs.r[5] = 0;

     _kernel_swi(ColourTrans_SelectTable,&regs,&regs);

   }

   regs.r[0] = 52+512;
   regs.r[1] = (int) sad;
   regs.r[2] = (int) (sad+4);
   regs.r[3] = 32 + block->visible_area.xmin - block->xscroll;
   regs.r[4] = -96 + block->visible_area.ymax - block->yscroll -2*hei;
   regs.r[5] = 0;
   regs.r[6] = 0;
   regs.r[7] = (int) ctrans;

  //fout ("About to render screen at %d,%d \n",regs.r[3],regs.r[4]);
  _kernel_swi(OS_SpriteOp,&regs,&regs);
*/
}
