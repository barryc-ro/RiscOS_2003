/**************************************************************************\
*                                                                          *
* ARMUL8 - an ARM8 emulator                                                *
* =========================                                                *
*                                                                          *
* Author:              D.J.Seal                                            *
* Development started: 12 January 1994                                     *
* Version:             Pre-release                                         *
*                                                                          *
* Copyright (C) Advanced RISC Machines Limited, 1994. All rights reserved. *
*                                                                          *
* Revising $Author$
* RCS $Revision$
* Checkin $Date$
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* pu.c: Routines to emulate the ARM8 prefetch unit                         *
*                                                                          *
\**************************************************************************/

#include "state.h"
#include "pu.h"
#define mask26(a) (a&0x3FFFFFF)

/**************************************************************************\
*                                                                          *
* Useful functions                                                         *
*                                                                          *
\**************************************************************************/

  char *bsm_str(val)
  int  val;
  {
    switch(val) {
      case PDPE : return("-----");
      case PDPEF: return("PDPEF");
      case PDPE2: return("PDPE2");
      case PDPE2F: return("PDP2F");
      case PDPE2W: return("PDP2w");
      case PDPEW: return("PDPEW");
      case TDPE : return("TDPE ");
      case TDPEF: return("TDPEF");
      case BDPE : return("BDPE ");
      case BDPEF: return("BDPEF");
      case BDPEW: return("BDPEW");
      case    PE: return("  PE ");
      case  ADPE: return(" ADPE");
      case CADAE: return("CADAE");
      case   CAE: return("C  AE");
      case CTDTE: return("CTDTE");
      case   CTE: return("C  TE");
      case CTDBE: return("CTDBE");
      case CADBE: return("CADBE");
      case   CBE: return("C  BE");
      case   CPE: return("C  PE");
      case  FINN: return(" FINN");
    }
    return("????");
  }

#ifdef DB_PU /*==========================================================*/

  char *cflags_str(val)
  int  val;
  {
    switch(val) {
      case 0x0: return("----");
      case 0x1: return("---V");
      case 0x2: return("--C-");
      case 0x3: return("--CV");
      case 0x4: return("-Z--");
      case 0x5: return("-Z-V");
      case 0x6: return("-ZC-");
      case 0x7: return("-ZCV");
      case 0x8: return("N---");
      case 0x9: return("N--V");
      case 0xA: return("N-C-");
      case 0xB: return("N-CV");
      case 0xC: return("NZ--");
      case 0xD: return("NZ-V");
      case 0xE: return("NZC-");
      case 0xF: return("NZCV");
    }
    return("????");
  }



  char *psm_str(val)
  int  val;
  {
    switch(val) {
      case IDLE: return("----");
      case CALC: return("CALC");
      case   F0: return("  F0");
      case  F0F: return(" F0F");
      case CORR: return("CORR");
      case PPRE: return("PPRE");
      case PRET: return("PRET");
      case DONE: return("DONE");
      case CPRE: return("CPRE");
      case CRET: return("CRET");
      case FPRE: return("FPRE");
      case NOSPEC: return("NOSP");
    }
    return("????");
  }

  char *nofetch_str(val)         int val; { if (val) return("N");  else return("-");  }
  char *instraccepted_str(val)   int val; { if (val) return("A");  else return("-");  }
  char *forcedprefetch_str(val)  int val; { if (val) return("F");  else return("-");  }
  char *addressinuse_str(val)    int val; { if (val) return("A");  else return("-");  }
  char *iexhausted_str(val)      int val; { if (val) return("IE"); else return("--"); }
  char *instructonrdata_str(val) int val; { if (val) return("R");  else return("-");  }
  char *nconfirm_str(val)        int val; { if (val) return("*");  else return(" ");  }
  char *canceld_str(val)         int val; { if (val) return("D");  else return("-");  }
  char *cancele_str(val)         int val; { if (val) return("E");  else return("-");  }

  char *rrequesti_str(valC,valP)
  int valC,valP;
  {
    if (valC)
    {
      if (valP) return("---"); else return("RIP");
    }
    else
    {
      if (valP) return("RIC"); else return("RIB");
    }
  }

  char *rrequestd_str(val)
  int val;
  {
    switch (val) {
      case RREQD_NONE: return("---");
      case RREQD_ONE:  return("RD1");
      case RREQD_TWO:  return("RD2");
    }
    return("non");
  }

  char *rresponse_str(val)
  int val;
  {
    switch (val) {
      case RRESP_NOTHING:    return("--");
      case RRESP_EXTABORT_D: return("XD");
      case RRESP_EXTABORT_I: return("XI");
      case RRESP_DATA1:      return("D1");
      case RRESP_DATA2:      return("D2");
      case RRESP_INSTR1:     return("I1");
      case RRESP_INSTR2:     return("I2");
    }
    return("??");
  }

  char *arequest_str(val)
  int val;
  {
    switch (val) {
      case AREQ_NONE:      return("none");
      case AREQ_LOAD:      return("LOAD");
      case AREQ_LOAD_M:    return("LD_M");
      case AREQ_LOAD_S:    return("LD_S");
      case AREQ_LOAD_SM:   return("LDSM");
      case AREQ_LOAD_B:    return("LD_B");
      case AREQ_LOAD_H:    return("LD_H");
      case AREQ_LOAD_X:    return("LD_X");
      case AREQ_LOAD_BX:   return("LDBX");
      case AREQ_FETCH:     return("FTCH");
      case AREQ_FETCH_S:   return("FT_S");
      case AREQ_SPEC:      return("SPEC");
      case AREQ_SPEC_S:    return("SP_S");
      case AREQ_STORE:     return("STOR");
      case AREQ_STORE_M:   return("ST_M");
      case AREQ_STORE_S:   return("ST_S");
      case AREQ_STORE_SM:  return("STSM");
      case AREQ_STORE_B:   return("ST_B");
      case AREQ_STORE_H:   return("ST_H");
      case AREQ_STORE_X:   return("ST_X");
      case AREQ_STORE_BX:  return("STBX");
      case AREQ_CONTROL:   return("CTRL");
    }
    return("????");
  }

  char *aresponse_str(val)
  int val;
  {
    switch (val) {
      case ARESP_NOTDONE: return("----");
      case ARESP_ABORT:   return("ABRT");
      case ARESP_DONE:    return("DONE");
    }
    return("????");
  }

/*------- used when in twenty six bit mode to mask the top 6 bits ------------*/


/*------- used by print_fifo_contents to see if fifo location used  ----------*/

#define in_range(a,r,w) ((r<=w) ? (((a>=r) && (a<w))) : (((a>=r) && (a<FIFO_SIZE)) || ((a<w) && (a>=0))))

/*------- prints out the fifo contents for debugging purposes ----------------*/

void print_fifo_contents(state)
armul8_state *state;
{
  int i,s;

  /* print the normal read/write contents */

  for (i=0; i<FIFO_SIZE; i++) {
    if     ((i==PUINT.fifo.read) && (i==PUINT.fifo.write)) printf(" #");
    else if (i==PUINT.fifo.read)                           printf(" <");
    else if (i==PUINT.fifo.write)                          printf(" >");
    else                                                   printf("  ");
    if (in_range(i,PUINT.fifo.read,PUINT.fifo.write))      printf("%08X",PUINT.fifo.PcPlus8[i]-8);
    else                                                   printf("--------");
  }
  printf(" =========%d============\n",PUINT.fifo.contents);

  /* print the alternate contents */

  for (i=0; i<FIFO_SIZE; i++) {
    if       (!PUINT.alternate.valid)                      printf("  ");
    else if ((i==PUINT.alternate.fifo_read) &&
             (i==PUINT.alternate.fifo_write))              printf(" #");
    else if  (i==PUINT.alternate.fifo_read)                printf(" <");
    else if  (i==PUINT.alternate.fifo_write)               printf(" >");
    else                                                   printf("  ");
    if (!PUINT.alternate.valid)                            printf("........");
    else if (in_range(i,PUINT.alternate.fifo_read,
                      PUINT.alternate.fifo_write))         printf("%08X",PUINT.fifo.PcPlus8[i]-8);
    else                                                   printf("--------");
  }
  if (PUINT.alternate.valid) printf(" ==%08X============\n",PUINT.alternate.address);
  else                       printf("\n");
}

#endif /*=================================================================*/

/*------- this function calculates the target address for a branch -----------*/

unsigned branch_target(pcplus8,instruct,TwentySixBit)
unsigned pcplus8,instruct;
int      TwentySixBit;
{
  instruct = (instruct & 0x00FFFFFF) << 2;
  if (instruct&0x02000000) {
    if (TwentySixBit) return(mask26(pcplus8+instruct-0x04000000));
    else              return(       pcplus8+instruct-0x04000000);
  }
  else {
    if (TwentySixBit) return(mask26(pcplus8+instruct));
    else              return(       pcplus8+instruct);
  }
}

/*------- these macros are used by the static branch prediction scheme -------*/

#define   is_branch(i) (((i>>25)&7)==5)
#define        link(i) (((i>>24)&1)==1)
#define   is_always(i) (((i>>28)&15)==14)
#define    is_never(i) (((i>>28)&15)==15)
#define is_forwards(i) (((i>>23)&1)==0)

#define NB  0  /* Not a branch: Not predicted              */
#define NT  1  /* Predicted not-taken and possibly removed */
#define TB  2  /* Predicted taken and possibly removed     */
#define TBL 4  /* Predicted taken but not removed          */

/*------- the static branch prediction scheme --------------------------------*/

int make_prediction(instruction)
unsigned32 instruction;
{
  if      (( is_never(instruction)) ||
           (!is_branch(instruction)))
                                return(NB);
  else if (link(instruction))
    if (is_always(instruction)) return(TBL);
    else                        return(NB);
  else if ((is_always(instruction)) ||
           (!is_forwards(instruction)))
                                return(TB);
  else                          return(NT);
}

/*------- macro used for incrementing and wrapping fifo pointers -------------*/

#if (FIFO_SIZE==2) || (FIFO_SIZE==4) || (FIFO_SIZE==8) || (FIFO_SIZE==16)
#define inc_fifo_ptr(p) p = (p+1)&(FIFO_SIZE-1)
#else
#define inc_fifo_ptr(p) p = ((p == FIFO_SIZE-1) ? 0 : p+1)
#endif

/*------- this function puts an instruction into the fifo ---------------------*/

void fifo_in(fifo, rdata, pcplus8, abort, predict_on, cycle)
FIFO *fifo;
unsigned32 rdata;
unsigned32 pcplus8;
int        abort,predict_on,cycle;
{
  if (fifo->contents == FIFO_SIZE) {
    fprintf(stderr,"PU ERROR: attempt to fit too much in FIFO at cycle %d\n",cycle);
    return;
  }

  fifo->Instruct[fifo->write] = rdata;
  fifo->PcPlus8[fifo->write]  = pcplus8;
  fifo->PAbort[fifo->write]   = abort;

  if ((predict_on) && (!abort)) fifo->branch[fifo->write] = make_prediction(rdata);
  else                          fifo->branch[fifo->write] = NB;

  inc_fifo_ptr(fifo->write);
  fifo->contents++;
}

/*------- this function reads an instruction from the fifo ---------------------*/

void fifo_out(fifo,cycle)
FIFO *fifo;
{
  if (fifo->contents == 0) {
    fprintf(stderr,"PU ERROR: attempt to read from empty FIFO at cycle %d\n",cycle);
    return;
  }
  inc_fifo_ptr(fifo->read);
  fifo->contents--;
}

/*------- this function flushes the fifo and is used during a ForcedPrefetch ---*/

void flush_fifo(fifo)
FIFO *fifo;
{
  fifo->contents=0;
  fifo->read  = 0;
  fifo->write = 0;
}

/*------- this macro reports an unexpected error associated with the bsm ------*/

#define bsm_error(a) (printf("Prefetch Unit ERROR: bsm_state = %s and %s at %d\n"\
                      ,bsm_str(PUINT.bsm),a,PUINT.cycle_count))

/**************************************************************************\
*                                                                          *
*    EARLY PHASE 1                                                         *
*                                                                          *
\**************************************************************************/

void armul8pu_earlyph1(state)
armul8_state *state;
{
  int nbl,cancelD,cancelE,predictb;

  if (ARM8_MEM.NConfirm) {
    /* printf("cycle = %d\n",PUINT.cycle_count); */
    return;
  }

  /*------------------------ RSM -----------------------------------------*/

  /* prefetch_abort contains both the RResponse of EXTABORT_I and the      */
  /* AResponse of ARESP_ABORT so that either method of signalling an abort */
  /* is noticed. When the abort does occur any old junk gets put into the  */
  /* fifo.                                                                 */

  /* correct_mis==0 is because we dont want instructions from an incorrect */
  /* prediction                                                            */

  /* !InstructOnRdata OR !InstrAccepted ensures that any instruction back  */
  /* from the cache that is not goig directly to the core (via Rdata) is   */
  /* saved. Also any instruction that was intended for the core directly   */
  /* from the cache but that the core does not accept is saved.            */

  if (!ARM8_MEM.NConfirm) {
    if ((PUINT.AResponseL==ARESP_DONE) ||
        (PUINT.AResponseL==ARESP_ABORT)) {
      PUINT.NewAddress = FALSE;
    }
    if (PUINT.NewAddress==FALSE) {
      if ((PUINT.RResponseL==RRESP_INSTR2) ||
          (PUINT.RResponseL==RRESP_INSTR1) ||
          (PUINT.prefetch_abort)) {
        if (PUINT.correct_mis==0) {
          if (((!CORE_PU.InstructOnRdata) || (!CORE_PU.InstrAccepted)) && (!CORE_PU.ForcedPrefetch)) {
            fifo_in(&PUINT.fifo,
                    PUINT.RdataL2,
                    PUINT.PuPc+8,
                    PUINT.prefetch_abort,
                    PUINT.predict_on,
                    PUINT.cycle_count);
          }
        }
        if (PUINT.RResponseL==RRESP_INSTR2) {
          PUINT.rsm = INSTR2;
        }
        else {
          PUINT.rsm = DEF;
        }
      }
      else {
        PUINT.rsm = DEF;
      }
    }
    else {
      PUINT.rsm = DEF;
    }
  }
  else {
    PUINT.rsm = DEF;
  }

  /*------------------------ fullsm --------------------------------------*/

  /* any instruction accepted by the core gets removed from the fifo      */

  if ((!ARM8_MEM.NConfirm) && (CORE_PU.InstrAccepted) && (!CORE_PU.NoFetch)) {
    PUINT.InstrConfirmed = TRUE;
    if (CORE_PU.InstructOnRdata==0) {
      fifo_out(&PUINT.fifo,PUINT.cycle_count);
    }
  }
  else {
    PUINT.InstrConfirmed    = FALSE;
  }

  /*----------------------------------------------------------------------*/

  PUINT.cycle_count++;

  PUINT.correct_misL = PUINT.correct_mis;

  /*------------------------ ASM -----------------------------------------*/

  if (!ARM8_MEM.NConfirm) {
    if ((ARM8_MEM.ARequest==AREQ_FETCH) || (ARM8_MEM.ARequest==AREQ_FETCH_S) ||
        (ARM8_MEM.ARequest==AREQ_SPEC)  || (ARM8_MEM.ARequest==AREQ_SPEC_S)) {
      PUINT.NewAddress = TRUE;
    }
  }

  ARM8_MEM.NRRequestIP = TRUE;    /* The default */

  /*----------------------- the prediction state machine ----------------*/

  predictb = PUINT.predict0 || PUINT.predict1 || PUINT.predict2;

#define correct_prediction    (PUINT.correct_cyc && (!PUINT.correct_mis))
#define not_correct_taken     (PUINT.correct_mis && ( PUINT.predict_taken))
#define not_correct_not_taken (PUINT.correct_mis && (!PUINT.predict_taken))

  switch (PUINT.psm) {
    case FPRE:
    case IDLE: if      (PUINT.predictf)   PUINT.psm = F0F;
               else if (      predictb)   PUINT.psm = CALC;
               else                       PUINT.psm = IDLE;
               break;
    case CALC: if (PUINT.AddressInUseL)   PUINT.psm = PRET;
               else                       PUINT.psm = PPRE;
    case PRET: if (PUINT.AddressInUseL)   PUINT.psm = PRET;
               else                       PUINT.psm = PPRE;
               break;
    case PPRE: if ((PUINT.AResponseL == ARESP_NOTDONE) && (!PUINT.correct_cyc) && (PUINT.bsmL!=FINN)) PUINT.psm = NOSPEC;
               else if (PUINT.bsmL == FINN) {
                 if      (PUINT.predictf) PUINT.psm = F0F;
                 else if (      predictb) PUINT.psm = CALC;
                 else                     PUINT.psm = IDLE;
               }
               else if (PUINT.BT_in_exec)  PUINT.psm = CORR;
               else if (correct_prediction) {
                 if      (PUINT.predictf) PUINT.psm = F0F;
                 else if (      predictb) PUINT.psm = CALC;
                 else                     PUINT.psm = IDLE;
               }
               else if (PUINT.correct_cyc) PUINT.psm = IDLE;
               else                        PUINT.psm = DONE;
               break;
    case NOSPEC: if (PUINT.correct_cyc || (PUINT.bsmL==FINN))    PUINT.psm = IDLE;
               break;
    case  F0F: if (PUINT.BT_in_exec)      PUINT.psm = CORR;
               else                       PUINT.psm = F0;
               break;
    case DONE:
    case   F0: if (PUINT.BT_in_exec)      PUINT.psm = CORR;
               break;
    case CORR: if (not_correct_not_taken) PUINT.psm = CPRE;
               else if (!PUINT.correct_mis) {
                 if      (PUINT.predictf) PUINT.psm = F0F;
                 else if (      predictb) PUINT.psm = CALC;
                 else                     PUINT.psm = IDLE;
               }
               else
                                          PUINT.psm = IDLE;
               break;
    case CPRE: if (!PUINT.correct_mis) {
                 if      (PUINT.predictf) PUINT.psm = F0F;
                 else if (      predictb) PUINT.psm = CALC;
                 else                     PUINT.psm = IDLE;
               }
               else                       PUINT.psm = IDLE;
               break;
    default:   printf("ERROR at %d, psm state unknown\n",PUINT.cycle_count);
  }

  PUINT.correct_cyc = ((PUINT.bsm==CAE)   ||
                       (PUINT.bsm==CTE)   ||
                       (PUINT.bsm==CTDBE) ||
                       (PUINT.bsm==CADBE) ||
                       (PUINT.bsm==CBE)   ||
                       (PUINT.bsm==CPE));

  if ((CORE_PU.ForcedPrefetch) && (!ARM8_MEM.NConfirm)) {
    PUINT.psm = FPRE;
    PUINT.alternate.valid = FALSE;  /* only for debug */
  }

  /*------------------------ pcsm ----------------------------------------*/

  if (!ARM8_MEM.NConfirm) {
    PUINT.OldPuPc = PUINT.PuPc;   /* OldPuPc is used when storing the second instruction */
    if ((PUINT.psm==FPRE) ||
        (PUINT.psm==PPRE) ||
        (PUINT.psm==CPRE)) {
      PUINT.PuPc = ARM8_MEM.VAddress;
    }
    else {
      PUINT.PuPc = PUINT.ProvPuPc;
    }
  }

  if (PUINT.psm==IDLE)
    PUINT.predict_BL = FALSE;

#define N_FLAG ((CORE_PU.CFlags & 8) != 0)
#define Z_FLAG ((CORE_PU.CFlags & 4) != 0)
#define C_FLAG ((CORE_PU.CFlags & 2) != 0)
#define V_FLAG ((CORE_PU.CFlags & 1) != 0)

  if (PUINT.correct_cyc) {
    switch (PUINT.target_ccs) {
      case COND_EQ: PUINT.correct_mis = !Z_FLAG;                       break;
      case COND_NE: PUINT.correct_mis =  Z_FLAG;                       break;
      case COND_CS: PUINT.correct_mis = !C_FLAG;                       break;
      case COND_CC: PUINT.correct_mis =  C_FLAG;                       break;
      case COND_MI: PUINT.correct_mis = !N_FLAG;                       break;
      case COND_PL: PUINT.correct_mis =  N_FLAG;                       break;
      case COND_VS: PUINT.correct_mis = !V_FLAG;                       break;
      case COND_VC: PUINT.correct_mis =  V_FLAG;                       break;
      case COND_HI: PUINT.correct_mis = !C_FLAG ||  Z_FLAG;            break;
      case COND_LS: PUINT.correct_mis =  C_FLAG && !Z_FLAG;            break;
      case COND_GE: PUINT.correct_mis =  N_FLAG ^ V_FLAG;              break;
      case COND_LT: PUINT.correct_mis = !N_FLAG ^ V_FLAG;              break;
      case COND_GT: PUINT.correct_mis =  Z_FLAG || ( N_FLAG ^ V_FLAG); break;
      case COND_LE: PUINT.correct_mis = !Z_FLAG && (!N_FLAG ^ V_FLAG); break;
      case COND_AL: PUINT.correct_mis = FALSE;                         break;
      case COND_NV: PUINT.correct_mis = TRUE;                          break;
    }
    if (!PUINT.predict_taken)
      PUINT.correct_mis = !PUINT.correct_mis;
  }
  else {
    PUINT.correct_mis = FALSE;
  }

  /*------------------------ nfior sm ------------------------------------*/

  cancelD = 0;
  cancelE = 0;

  nbl = !PUINT.predict_BL;

  if (CORE_PU.ForcedPrefetch) {
    cancelD = 1;
    cancelE = 1;
  }
  else if (PUINT.correct_cyc) {
    if (!PUINT.correct_mis && PUINT.predict_taken) {     /* correct predict taken */
      switch (PUINT.bsm) {
        case   CAE: { cancelD = 1; cancelE =   1; break; }
        case   CTE: {                             break; }
        case CTDBE: {              cancelE = nbl; break; }
        case CADBE: { cancelD = 1; cancelE = nbl; break; }
        case   CBE: { cancelD = 1; cancelE = nbl; break; }
        case   CPE: {                             break; }
        default: bsm_error("correction problem");
      }
    }
    else if (PUINT.correct_mis && PUINT.predict_taken) { /* not correct predict taken  */
                                                         /* BL never wrong (so no nbl) */
      switch (PUINT.bsm) {
        case   CAE: {                             break; }
        case   CTE: { cancelD = 1; cancelE = 1;   break; }
        case CTDBE: { cancelD = 1; cancelE = 1;   break; }
        case CADBE: {              cancelE = 1;   break; }
        case   CBE: { cancelD = 1; cancelE = 1;   break; }
        case   CPE: {                             break; }
        default: bsm_error("correction problem");
      }
    }
    else if (!PUINT.correct_mis && !PUINT.predict_taken) {  /* correct predict not-taken */
    }
    else if ( PUINT.correct_mis && !PUINT.predict_taken) {  /* not correct predict not-taken */
      switch (PUINT.bsm) {
        case   CAE: { cancelD = 1; cancelE =   1; break; }
        case   CTE: { bsm_error("unexpected");    break; }
        case CTDBE: { bsm_error("unexpected");    break; }
        case CADBE: { bsm_error("unexpected");    break; }
        case   CBE: { bsm_error("unexpected");    break; }
        case   CPE: { bsm_error("unexpected");    break; }
        default: bsm_error("correction problem");
      }
    }
  }

  CORE_PU.CancelD = cancelD;
  CORE_PU.CancelE = cancelE;

  PUINT.InstructOnRdataL = CORE_PU.InstructOnRdata;
}

/**************************************************************************\
*                                                                          *
*     LATE PHASE 1                                                         *
*                                                                          *
\**************************************************************************/

void armul8pu_lateph1(state)
armul8_state *state;
{

#ifdef DB_PU /*===========================================================*/

  char nc[120];
  char rdata[120];
  char aw[120];
  FILE *out;

  if (PUINT.debug_file) out = PUINT.debug_file;
  else                  out = stdout;

  if (ARM8_MEM.NConfirm) sprintf(nc,"                                   * ");
  else                   sprintf(nc,"                                     ");

  if (PUINT.rsm == INSTR2)
    sprintf(rdata," %08X ",ARM8_MEM.Rdata);
  else if (PUINT.debug_d2)
    sprintf(rdata,"(%08X)",ARM8_MEM.Rdata);
  else
     strcpy(rdata," -------- ");

  if (PUINT.debug_st) sprintf(aw,"(%08X)",ARM8_MEM.Wdata);
  else                 strcpy(aw,"          ");

  if (PUINT.debug_option)
    fprintf(out,"%s%s     %s           %s   %s%s         %s %s\n",
      nc,rdata,addressinuse_str(CORE_PU.AddressInUse),
      aw,canceld_str(CORE_PU.CancelD),
      cancele_str(CORE_PU.CancelE),
      psm_str(PUINT.psm),
      bsm_str(PUINT.bsm));

#endif /*=================================================================*/

  if (ARM8_MEM.NConfirm) return;

  PUINT.RdataL1 = ARM8_MEM.Rdata;
}

/**************************************************************************\
*                                                                          *
*    EARLY PHASE 2                                                         *
*                                                                          *
\**************************************************************************/

void armul8pu_earlyph2(state)
armul8_state *state;
{
  unsigned32 instruction;
  int Speculate;

  if (((PUINT.psm==CALC) || (PUINT.psm == PPRE) || (PUINT.psm==PRET) ||
       (PUINT.psm==DONE) || (PUINT.psm==F0)     || (PUINT.psm==F0F) ||
       (PUINT.psm==NOSPEC)) &&
      (PUINT.bsm!=FINN) && (!PUINT.correct_cyc))
    Speculate = TRUE;
  else
    Speculate = FALSE;

  /*------------------ predictm stuff -------------------------------------*/

  if (PUINT.InstructOnRdataL) instruction = PUINT.RdataL2;
  else                        instruction = CORE_PU.Instruct;

  PUINT.predictm = FALSE;

  if ((!PUINT.predict2) && (!PUINT.predict1) && (!PUINT.predict0) &&
      (!PUINT.predictf) && (PUINT.psm==IDLE) && (!PUINT.correct_misL)) {
    if (PUINT.InstrConfirmed) {
      if ((PUINT.predict_on) && (!PUINT.prefetch_abort)) {
/* I dont believe we can do this ! as the BL was not marked as IgnoreBranch */
        if (make_prediction(instruction)==TBL) {
          PUINT.predict_taken = TRUE;
          PUINT.predictm      = TRUE;
          PUINT.target        = branch_target(CORE_PU.PcPlus8,instruction,ARM8_MEM.TwentySixBit);
          if (ARM8_MEM.TwentySixBit) PUINT.target = mask26(PUINT.target);
          PUINT.target_ccs    = (instruction) >> 28;
          PUINT.predict_BL    = TRUE;
        }
        else if (make_prediction(instruction)==TB) {
          PUINT.predict_taken = TRUE;
          PUINT.predictm      = TRUE;
          PUINT.target        = branch_target(CORE_PU.PcPlus8,instruction,ARM8_MEM.TwentySixBit);
          if (ARM8_MEM.TwentySixBit) PUINT.target = mask26(PUINT.target);
          PUINT.target_ccs    = (instruction) >> 28;
          PUINT.predict_BL    = FALSE;
        }
      }
    }
  }

  PUINT.predictm = FALSE; /********* turn OFF predictm ***************/

  if (PUINT.predictm) {           /* underhand logic ! */
    PUINT.psm = CALC;
    PUINT.bsm = BDPEF;
  }

  /*---------- prefetch aborts can be signalled on either aresponse or ---*/
  /*           rresponse, ORing is done here. Note that NewAddress is a   */
  /*           flag indicting that there is has been as ARequest for new  */
  /*           instructions.                                              */

  PUINT.prefetch_abort = ((ARM8_MEM.RResponse==RRESP_EXTABORT_I) ||
                         ((ARM8_MEM.AResponse==ARESP_ABORT) && PUINT.NewAddress) &&
                          (!ARM8_MEM.NConfirm));

  /*------------------------ RSM -----------------------------------------*/

  /* if correct_mis was up in the last cycle then the instructions requested */
  /* at the beginning of that cycle are not wanted, hence the correct_misL=0 */

  if (!ARM8_MEM.NConfirm) {
    if ((PUINT.rsm == INSTR2) && (PUINT.correct_misL==0) && (PUINT.psm!=FPRE)) {
      fifo_in(&PUINT.fifo,PUINT.RdataL1,PUINT.OldPuPc+12,0,PUINT.predict_on,PUINT.cycle_count);
    }
  }

/*print_fifo_contents(state);*/

  if (!PUINT.NConfirmL) {
  /* this section should really have been in phase 1 */
    /*------ flush the fifo on a forced prefetch ---------------------------*/

    if      (PUINT.psm==FPRE) flush_fifo(&PUINT.fifo);

    /*------ if we are succeessfully doing the prefetch for a prediction ---*/
    /*       then we have finished with doing the old thread fetches and    */
    /*       it is now safe to take a copy of the old thread Pc and fifo    */
    /*       write pointer in case the prediction is incorrect.             */

    else if ((PUINT.psm == PPRE) && (!PUINT.correct_cyc)) {
      PUINT.alternate.valid      = TRUE;             /* only for debug */
      PUINT.alternate.address    = PUINT.ProvPuPc;
      PUINT.alternate.fifo_write = PUINT.fifo.write;
    }

    /*------ The following bsm states are only entered for one clock tick --*/
    /*       and are entered when all the instructions from the old thread  */
    /*       have entered the decode stage of the core. This means that it  */
    /*       is now safe to take a copy of the old thread fifo read pointer */
    /*       for coming back to in case the prediction is wrong.            */

    if (((PUINT.bsm == ADPE)  || (PUINT.bsm == PDPEF) || (PUINT.bsm == TDPEF)  ||
              (PUINT.bsm == BDPEF) || (PUINT.bsm == PDPE2F))) {
      PUINT.alternate.fifo_read = PUINT.fifo.read;
    }

    /*------ if the prediction is correct but we havent actually got back   */
    /*       any of the predicted thread yet (but we also know that the old */
    /*       thread is done with) then we treat this as a special case and  */
    /*       simply flush the fifo and ignore the alternate values (This is */
    /*       the "correct special case").                                   */

    if (((PUINT.psm == PRET) || (PUINT.psm==PPRE)) && correct_prediction) {
      flush_fifo(&PUINT.fifo);
    }

    /*       Then we switch to the predicted thread by read=alternate.write */
    /*       The "else" ensures that we dont do all this for the correct    */
    /*       special case above.                                            */
    /*       We ignore all this for the not-correct special case so that no */
    /*       alternative information is grabbed and the new thread is not   */
    /*       switched to. The new thread gets selected automatically by the */
    /*       fifo flush above.                                              */
    /*       Notice that BDPEW is in here in addition to the grabbing       */
    /*       alternate.fifo_read cases. This is because the fifo_write is   */
    /*       grabbed during this "waiting" period if the prefetch takes a   */
    /*       long time. Also the stricter conditions (over alternate.read   */
    /*       grabbing) are because we must get it exactly right here,       */
    /*       whereas the alternate.read grabbing can be overdone.           */

    else if (((PUINT.bsm == ADPE)  || (PUINT.bsm == PDPEF) || (PUINT.bsm == TDPEF)  ||
              (PUINT.bsm == BDPEF) || (PUINT.bsm == BDPEW) || (PUINT.bsm == PDPE2F)) &&
             (((PUINT.psm == PPRE) && (!PUINT.correct_cyc)) || (PUINT.psm == DONE))) {
      PUINT.alternate.valid     = TRUE;                  /* only for debug */
  /*    PUINT.alternate.fifo_read = PUINT.fifo.read;  */
      PUINT.fifo.read           = PUINT.alternate.fifo_write;
      PUINT.fifo.contents       = (PUINT.fifo.write-PUINT.fifo.read)&7;
    }
  }

  PUINT.NConfirmL = ARM8_MEM.NConfirm;

  /*------ This is where a mispredicted correction is done. Note that the */
  /*       not-correct predicted-taken does not need correcting as the    */
  /*       new thread is not selected anyway.                             */

  if (not_correct_taken && (PUINT.psm!=PPRE)) {
    PUINT.ProvPuPc      = PUINT.alternate.address;
    PUINT.fifo.read     = PUINT.alternate.fifo_read;
    PUINT.fifo.write    = PUINT.alternate.fifo_write;
    PUINT.fifo.contents = (PUINT.fifo.write-PUINT.fifo.read)&7;
  }
  else if (not_correct_not_taken) {
    PUINT.ProvPuPc      = PUINT.alternate.address;
    PUINT.fifo.write    = PUINT.alternate.fifo_write;
    PUINT.fifo.read     = 0;
    PUINT.fifo.write    = 0;
    PUINT.fifo.contents = 0;
  }

  if (PUINT.correct_cyc) PUINT.alternate.valid = FALSE;  /* only for debug */

  /*------------------------ fullsm ---------------------------------------*/

  /*    We stop prefetching ahead if the fifo gets dangerously full. This  */
  /*    depends on the possible outstanding request providing instructions */
  /*    We must have room for the instructions about to be returned and    */
  /*    for two more - we must assume that two might be returned from the  */
  /*    request that will go out if we dont stop prefetching, and that in  */
  /*    the meantime the core wont take any.                               */

  if ((ARM8_MEM.RResponse==RRESP_INSTR2) && (!ARM8_MEM.NConfirm)) {
    if ((FIFO_SIZE-PUINT.fifo.contents)>=5)  PUINT.PuFull = FALSE;
    else                                     PUINT.PuFull = TRUE;
  }
  else if (((ARM8_MEM.RResponse==RRESP_INSTR1) ||
            (ARM8_MEM.RResponse==RRESP_EXTABORT_I)) && (!ARM8_MEM.NConfirm)) {
    if ((FIFO_SIZE-PUINT.fifo.contents)>=4)  PUINT.PuFull = FALSE;
    else                                     PUINT.PuFull = TRUE;
  }
  else {
    if ((FIFO_SIZE-PUINT.fifo.contents)>=3)  PUINT.PuFull = FALSE;
    else                                     PUINT.PuFull = TRUE;
  }

  /*------------------------ pcsm ----------------------------------------*/

  /*    The provisional pupc (the address of instructions that will be    */
  /*    requested next) depends on the last pupc value incremented by the */
  /*    number of instructions that will be returned at the end of this   */
  /*    cycle. However if the correction of a misprediction is occuring   */
  /*    then we dont do this since the ProvPuPc has already be set to the */
  /*    alternate (saved) value.                                          */
  /*    Notice that in 26-bit mode we wrap the incrementing               */

  if (!PUINT.correct_mis) {
    if ((ARM8_MEM.RResponse==RRESP_INSTR2) && (!ARM8_MEM.NConfirm)) {
      PUINT.ProvPuPc = PUINT.PuPc + 8;
      if (ARM8_MEM.TwentySixBit) PUINT.ProvPuPc = mask26(PUINT.ProvPuPc);
    }
    else if (((ARM8_MEM.RResponse==RRESP_INSTR1) ||
              (ARM8_MEM.RResponse==RRESP_EXTABORT_I)) && (!ARM8_MEM.NConfirm)) {
      PUINT.ProvPuPc = PUINT.PuPc + 4;
      if (ARM8_MEM.TwentySixBit) PUINT.ProvPuPc = mask26(PUINT.ProvPuPc);
    }
    else {
      PUINT.ProvPuPc = PUINT.PuPc;
    }
  }

  /*--------------------- stop_prefetch ----------------------------------*/

  /*------ Must start prefetching again on any of the following cases ----*/

  if (!ARM8_MEM.NConfirm) {
    /*       Stop prefetching if an abort is indicated (seems sensible)     */
    if (PUINT.prefetch_abort && !PUINT.correct_mis) {
      PUINT.stop_prefetch = 1;
    }
    else if ((PUINT.psm == FPRE) ||
        ((PUINT.psm == PPRE) && (ARM8_MEM.AResponse!=ARESP_NOTDONE)) ||
        (PUINT.psm == CORR) ||
        (PUINT.correct_cyc) ||
        (PUINT.bsm==FINN)) {
      PUINT.stop_prefetch = 0;
    }

    else if ((PUINT.psm == PPRE) &&
             (ARM8_MEM.AResponse==ARESP_NOTDONE) &&
             (PUINT.correct_cyc==0) &&
             (PUINT.bsmL!=FINN)) PUINT.stop_prefetch = 1;

    /*       Stop prefetching as soon as prediction has returned one or     */
    /*       two instructions (thats all we need until the correction       */
    /*       cycle comes along and we regain our confidence.                */

    else if (PUINT.psm == DONE)  PUINT.stop_prefetch = 1;

    /*       Stop prefetching if we see a branch go into the fifo that we   */
    /*       are going to predict as taken.                                 */
    /*       Normally the correction cycle of the branch will restart the   */
    /*       prefetching, however there could have been a branch in the     */
    /*       pipeline that we didn't notice in which case the forced        */
    /*       prefetch will restart the prefetching                          */

    else if ((((FIFO_LAST1_BRANCH == TB) || (FIFO_LAST1_BRANCH == TBL)) &&
               (PUINT.fifo.contents>0)) ||
             (((FIFO_LAST2_BRANCH == TB) || (FIFO_LAST2_BRANCH == TBL)) &&
               (PUINT.fifo.contents>1))) {
      PUINT.stop_prefetch = 1;
    }

  }

  /*--------------------- ASM --------------------------------------------*/

  /*------ The prefetch unit is at liberty to ignore AddressInUse if it   */
  /*       has just cancelled an instruction in the execute stage, and    */
  /*       that instruction had only just entered (indicated by NewInstr) */
  /*       In fact in this particular case it is the responsibility of    */
  /*       the PU to drive ARequest to something sensible.                */

  PUINT.ignore_aiu = CORE_PU.CancelE && PUINT.NewInstrD;

  /*------ The prefetch for a prediction case ----------------------------*/
  /*       Stop_prefetch ensures that there is enough room for the        */
  /*       requested instructions.                                        */

  if ((PUINT.psm==PRET) || (PUINT.psm==CALC)) {
    if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
      ARM8_MEM.VAddress   = PUINT.target;
      if (Speculate) ARM8_MEM.ARequest = AREQ_SPEC;
      else           ARM8_MEM.ARequest = AREQ_FETCH;
      ARM8_MEM.NRRequestIP = FALSE;
    }
  }

  /*------ The prefetch for correcting a mispredicted not taken prediction*/
  /*       The fifo will be empty in this case.                           */

  else if (((PUINT.psm==CORR) && not_correct_not_taken)) {
    if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
      ARM8_MEM.VAddress    = PUINT.alternate.address;
      ARM8_MEM.ARequest    = AREQ_FETCH;
      ARM8_MEM.NRRequestIP = FALSE;
    }
    else {
      printf("ERROR: AddressInUse when trying to correct a predicted not\n");
      printf("       taken branch\n");
    }
  }

  /*------ The prefetch for correcting a mispredicted taken branch, note  */
  /*       that in this case ProvPuPc will have been restored from the    */
  /*       alternate value but it will not be sequential since there will */
  /*       have been a prediction prefetch in the meantime.               */
  /*       Stop_prefetch on spotting the branch together with the         */
  /*       prediction prefetch only getting one or two instructions       */
  /*       ensures that there is enough room in the fifo?                 */

  else if (PUINT.correct_mis) {
    if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
      ARM8_MEM.ARequest    = AREQ_FETCH;
      ARM8_MEM.VAddress    = PUINT.ProvPuPc;
      ARM8_MEM.NRRequestIP = FALSE;
    }
    else {
      printf("ERROR: AddressInUse when trying to correct a predicted\n");
      printf("       taken branch\n");
    }
  }

  else if (((PUINT.NonSeqD1) ||
            ((PUINT.psm == PPRE) && (ARM8_MEM.AResponse == ARESP_NOTDONE)) ||
            (ARM8_MEM.NConfirm)) && (!Speculate)) {
    if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
      ARM8_MEM.VAddress    = PUINT.ProvPuPc;
      ARM8_MEM.ARequest    = AREQ_FETCH;
      ARM8_MEM.NRRequestIP = FALSE;
    }
  }

  /*------ Normal prefetching case where whether to prefetch or not is    */
  /*       determined by how much room there is in the fifo and whether   */
  /*       stop_prefetch is set or not.                                   */
  /*       If IExhausted is up then we need an ARequest and a new address */
  /*       otherwise just the RRequest will do.                           */

  else if (!PUINT.PuFull && !PUINT.stop_prefetch) {
    if (ARM8_MEM.IExhausted) {
      if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
        if (Speculate)
          ARM8_MEM.ARequest  = AREQ_SPEC_S;
        else
          ARM8_MEM.ARequest  = AREQ_FETCH_S;
        ARM8_MEM.VAddress    = PUINT.ProvPuPc;
        ARM8_MEM.NRRequestIP = FALSE;
      }
    }
    else {
      ARM8_MEM.NRRequestIP = FALSE;
      if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
        ARM8_MEM.ARequest = AREQ_NONE;
      }
    }
  }

  /*------ This is the case where the prefetch unit does not actually     */
  /*       want any instructions but it is responsible for putting        */
  /*       something sensible onto ARequest.                              */

  else if (!CORE_PU.AddressInUse || PUINT.ignore_aiu) {
    ARM8_MEM.ARequest = AREQ_NONE;
  }

  /*------------------------ nfior sm ------------------------------------*/

  /* NoFetch is generated off whether the fifo has anything in it or not  */
  /* If it is empty however there still be instructions due to arrive on  */
  /* Rdata that could go directly to the core in which case NoFetch is    */
  /* cleared.                                                             */
  /* The AND with (psm==PPRE AND correct_mis) is for the special case where */
  /* the Predicted prefetch is outstanding BUT is incorrect and therefore   */
  /* should not be used to clear NoFetch since the instruction that will be */
  /* arriving is not required                                               */

  if (ARM8_MEM.NConfirm) {
    CORE_PU.NoFetch = 1;
  }
  else {
    if (PUINT.fifo.contents==0) {
      CORE_PU.InstructOnRdata = 1;
      if (((ARM8_MEM.RResponse == RRESP_INSTR2) ||
           (ARM8_MEM.RResponse == RRESP_INSTR1) ||
           (ARM8_MEM.RResponse == RRESP_EXTABORT_I)) &&
           (!(((PUINT.psm==PPRE) || (PUINT.bsm==CTE) ||
               (PUINT.bsm==CTDBE)) && PUINT.correct_mis))) {
        CORE_PU.NoFetch = 0;
      }
      else {
        CORE_PU.NoFetch = 1;
      }
    }
    else {
      CORE_PU.InstructOnRdata = 0;
      CORE_PU.NoFetch         = 0;
    }
  }

  /*------------------------ generate prediction bits --------------------*/

  /*----- The four prediction bits have the following meanings:           */
  /*      predictf: means that the instruction about to be presented to   */
  /*                the core on the Instruct bus is a predicted not-taken */
  /*                branch. The fifo read pointer is incremented by one so*/
  /*                that the following instruction actually goes into the */
  /*                core, and psm goes into F0 state.                     */
  /*      predict0: means that the instruction about to go into the core  */
  /*                is predicted taken branch. In the worst case this     */
  /*                results in a 2 cycle branch.                          */
  /*      predict1: means that the instruction about to go into the core  */
  /*                is the instruction preceding a predicted taken branch */
  /*                In the worst case this results in a one cycle branch  */
  /*      predict2: means that the instruction about to go into the core  */
  /*                is the instruction preceding an instruction that is   */
  /*                preceding a predicted taken branch. This will result  */
  /*                in a zero cycle branch.                               */

  PUINT.predictf = FALSE;
  PUINT.predict0 = FALSE;
  PUINT.predict1 = FALSE;
  PUINT.predict2 = FALSE;

  /*     firstly we only allow predictions from certain known states      */
  /*     These are when no prediction is outstanding, no forced prefetch  */
  /*     is in progress, or when the last prediction is in its potential  */
  /*     correction cycle and was correctl predicted.                     */

  if ((PUINT.psm!=FPRE) && (PUINT.psm!=F0) && (PUINT.psm!=F0F) && ((PUINT.bsm == PDPE) ||
       (((PUINT.bsm==CAE) ||
         (PUINT.bsm==CTE)   || (PUINT.bsm==CTDBE) || (PUINT.bsm==CADBE) ||
         (PUINT.bsm==CBE)   || (PUINT.bsm==FINN)) && (!PUINT.correct_mis)))) {

    /*   look 2 places back up the fifo in aticipation of a zero-cycle     */
    /*   branch. Note that TBL is intentionally not spotted here as we     */
    /*   cant have zero cycle BL's and this stops the prediction mechanism */
    /*   from removing the BL altogether.                                  */

    if ((PUINT.fifo.contents>2) &&
        (FIFO_2_BRANCH == TB)   &&
        (FIFO_1_BRANCH == NB)   &&
        (FIFO_0_BRANCH == NB)) {
        PUINT.predict_taken = TRUE;
        PUINT.predict2      = TRUE;
        PUINT.target        = branch_target(FIFO_2_PCPLUS8,FIFO_2_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs    = (FIFO_2_INSTRUCT) >> 28;
    }

    /*   look for potential 1-cycle branches                               */

    else if ((PUINT.fifo.contents>1) && (FIFO_1_BRANCH == TB) && (FIFO_0_BRANCH == NB)) {
        PUINT.predict_taken = TRUE;
        PUINT.predict1      = TRUE;
        PUINT.target        = branch_target(FIFO_1_PCPLUS8,FIFO_1_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs    = (FIFO_1_INSTRUCT) >> 28;
    }

    /*   and then for potential one-cyle branch and links                  */

    else if ((PUINT.fifo.contents>1) && (FIFO_1_BRANCH == TBL) && (FIFO_0_BRANCH == NB)) {
        PUINT.predict_taken = TRUE;
        PUINT.predict_BL    = TRUE;
        PUINT.predict1      = TRUE;
        PUINT.target        = branch_target(FIFO_1_PCPLUS8,FIFO_1_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs    = (FIFO_1_INSTRUCT) >> 28;
    }

    /*   look for a potential branch removal (predicted not-taken). Note   */
    /*   that we have to use the same conditions for accepting the case as */
    /*   the psm state machine is going to use as we are going to commit   */
    /*   to removing the branch before we get to making the choice in the  */
    /*   state machine itself.                                             */

    else if ((PUINT.fifo.contents>1) &&
             (FIFO_0_BRANCH == NT) &&
            ((PUINT.psm==IDLE) ||
            ((PUINT.psm==PPRE) && ((PUINT.bsm==FINN) || (correct_prediction))) ||
            ((PUINT.psm==CORR) && (!PUINT.correct_mis)) ||
            ((PUINT.psm==CPRE) && (!PUINT.correct_mis)))) {
        PUINT.predict_taken = FALSE;
        PUINT.predictf   = TRUE;
        PUINT.target     = branch_target(FIFO_0_PCPLUS8,FIFO_0_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs = (FIFO_0_INSTRUCT) >> 28;
        PUINT.alternate.address    = PUINT.target;
        PUINT.alternate.fifo_read = PUINT.fifo.write;
        PUINT.alternate.fifo_write  = PUINT.fifo.write;
        fifo_out(&PUINT.fifo,PUINT.cycle_count);
    }

    /*   finally we look for 2-cycle branches                              */

    else if ((PUINT.fifo.contents>0) &&
             (FIFO_0_BRANCH == TB)) {
        PUINT.predict_taken = TRUE;
        PUINT.predict0    = TRUE;
        PUINT.target      = branch_target(FIFO_0_PCPLUS8,FIFO_0_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs  = (FIFO_0_INSTRUCT) >> 28;
    }

    /*   and 2-cycle branche and links                                     */

    else if ((PUINT.fifo.contents>0) &&
             (FIFO_0_BRANCH == TBL)) {
        PUINT.predict_taken = TRUE;
        PUINT.predict0    = TRUE;
        PUINT.target      = branch_target(FIFO_0_PCPLUS8,FIFO_0_INSTRUCT,ARM8_MEM.TwentySixBit);
        PUINT.target_ccs  = (FIFO_0_INSTRUCT) >> 28;
        PUINT.predict_BL  = TRUE;
    }
  }

  /*------------------------ put out new instruction ---------------------*/

  /*    The instruction is always the value in the fifo pointed to the    */
  /*    by the read pointer. It may or may not be valid, NoFetch and      */
  /*    InstructOnRdata will sort this out. For InstructOnRdata set the   */
  /*    PcPlus8 and PAbort values must be selected from the internal      */
  /*    stuf rather than the fifo.                                        */

  CORE_PU.Instruct = PUINT.fifo.Instruct[PUINT.fifo.read];
  if (CORE_PU.InstructOnRdata) {
    CORE_PU.PcPlus8  = PUINT.PuPc + 8;
    CORE_PU.PAbort   = PUINT.prefetch_abort;
  }
  else {
    CORE_PU.PcPlus8  = PUINT.fifo.PcPlus8[PUINT.fifo.read];
    CORE_PU.PAbort   = PUINT.fifo.PAbort[PUINT.fifo.read];
  }

  /*------------------ ignore branch generation --------------------------*/

  /* predict0 asserted means a branch is just about to enter the core, we */
  /* need to assert IgnoreBranch if its a BL                              */

  if (PUINT.predict0)  CORE_PU.IgnoreBranch = PUINT.predict_BL;
  else                 CORE_PU.IgnoreBranch = 0;

  /*------------------ NoFetch generation due to corrects ----------------*/

  /* if we are correcting an incorrect predict not taken, then we dont    */
  /* have an instruction for the core as we are only just about to start  */
  /* the fetch to the target address                                      */
  /* this is an OR function as NoFetch may already be 1 due to fifo empty  */

  if ((PUINT.correct_mis) && (!PUINT.predict_taken)) CORE_PU.NoFetch = 1;

}

/**************************************************************************/

int new_prediction(new_pipe,new_decode,predictf,predict2,predict1,
                   predict0,done,not_bl,psm,default_state)
int new_pipe,new_decode,predictf,predict2,predict1,default_state;
int predict0,done,not_bl,psm;
{
  if (new_pipe || new_decode)  {
    if      (predictf || (psm == F0) || (psm == F0F))    return(ADPE);
    else if (predict2)                    return(PDPE2);
    else if (predict1 &&  done && not_bl) return(PDPEF);
    else if (predict0         )           return(BDPEF);
    else                                  return(PDPE);
  }
  return(default_state);
}

/**************************************************************************\
*                                                                          *
*     LATE PHASE 2                                                         *
*                                                                          *
\**************************************************************************/

void armul8pu_lateph2(state)
armul8_state *state;
{
//#ifdef DB_PU /*===========================================================*/

  char rdata[120];
  char aw[120];
  FILE *out;
  char rreq[5];
  int  new_decode,new_exec,in_progress,new_pipe,done,not_bl;

  if (!ARM8_MEM.NConfirm) {

    new_decode  =   CORE_PU.InstrAccepted && !CORE_PU.NoFetch  && !CORE_PU.NewInstr;
    new_exec    = (!CORE_PU.InstrAccepted ||  CORE_PU.NoFetch) &&  CORE_PU.NewInstr;
    new_pipe    =   CORE_PU.InstrAccepted && !CORE_PU.NoFetch  &&  CORE_PU.NewInstr;
    in_progress = PUINT.psm == PPRE;
    done        = (in_progress) || (PUINT.psm == DONE);
    not_bl      = !PUINT.predict_BL;

    /*----------------------------------------------------------------------*/
    /* new_decode new_exec                                                  */
    /*     1         1      F->D, D->E                                      */
    /*     1         0      F->D, E same                                    */
    /*     0         1        <D> D->E                                      */
    /*     0         0      ARM8 pipe not moved                             */
    /*----------------------------------------------------------------------*/

    /* if predict then the P branch instruction is in decode (=PD) */

    /* BT_in_exec is set by the entering of the correction states, in the
       VHDL it must be set by the state before and the condition for
       entering the correction states */

    PUINT.BT_in_exec = FALSE;

    PUINT.bsmL = PUINT.bsm;

    switch (PUINT.bsm) {
      case PDPE:   PUINT.bsm = new_prediction(new_pipe,new_decode,PUINT.predictf,
                                              PUINT.predict2,PUINT.predict1,
                                              PUINT.predict0,done,not_bl,PUINT.psm,PDPE);
                   break;
      case PDPE2:  if      (new_pipe)           PUINT.bsm = PDPE2F;
                   else if (new_decode)         bsm_error("lost P in decode");
                   else if (new_exec)           PUINT.bsm = PDPE2F; /* exception can do this */
                   break;
      case PDPE2F: if      (new_pipe && done)   PUINT.bsm = TDPE;
                   else if (new_pipe)           PUINT.bsm = BDPEF;
                   else if (new_decode)         bsm_error("lost P in decode");
                   else if (new_exec)           PUINT.bsm = PE;
                   else                         PUINT.bsm = PDPE2W;
                   break;
      case PE:     if      (new_exec)           PUINT.bsm = CPE;
                   break;
      case PDPE2W: if      (new_pipe && done)   PUINT.bsm = TDPE;
                   else if (new_pipe)           PUINT.bsm = BDPEW;
                   else if (new_decode)         bsm_error("lost P in decode");
                   else if (new_exec)           PUINT.bsm = PE;
                   break;
      case PDPEF:
      case PDPEW:  if      (new_pipe && done)   PUINT.bsm = TDPE;
                   else if (new_pipe)           PUINT.bsm = BDPEW;
                   else if (new_decode)         bsm_error("lost P in decode");
                   else if (new_exec)           bsm_error("lost P in execute");
                   else                         PUINT.bsm = PDPEW;
                   break;
      case ADPE:   if      (new_pipe)         { PUINT.bsm = CAE;   PUINT.BT_in_exec = TRUE; }
                   else if (new_decode)         bsm_error("lost an A in decode");
                   else if (new_exec)         { PUINT.bsm = CAE;   PUINT.BT_in_exec = TRUE; }
                   break;
      case TDPEF:
      case TDPE:   if      (new_pipe)         { PUINT.bsm = CTE;   PUINT.BT_in_exec = TRUE; }
                   else if (new_decode)         bsm_error("lost a T in decode");
                   else if (new_exec)         { PUINT.bsm = CTE;   PUINT.BT_in_exec = TRUE; }
                   else                         PUINT.bsm = TDPE;
                   break;
      case BDPEF:
      case BDPEW:  if      (new_pipe &&  done){ PUINT.bsm = CTDBE; PUINT.BT_in_exec = TRUE; }
                   else if (new_pipe && !done){ PUINT.bsm = CADBE; PUINT.BT_in_exec = TRUE; }
                   else if (new_decode)         bsm_error("lost a B in decode");
                   else if (new_exec)         { PUINT.bsm = CBE;   PUINT.BT_in_exec = TRUE; }
                   else                         PUINT.bsm = BDPEW;
                   break;
      case CAE:
      case CTE:
      case CPE:
      case CTDBE:
      case CADBE:
      case CBE:   if     ((!done && (PUINT.psm!=CORR)) && (PUINT.psm!=NOSPEC))   PUINT.bsm = FINN;
                  else if (!PUINT.correct_mis)
                    PUINT.bsm = new_prediction(new_pipe,new_decode,PUINT.predictf,
                                              PUINT.predict2,PUINT.predict1,
                                              PUINT.predict0,done,not_bl,PUINT.psm,PDPE);
                  else
                    PUINT.bsm = PDPE;
                  break;
      case FINN:  if     ((!done && (PUINT.psm!=CORR)) && (PUINT.psm!=NOSPEC))     PUINT.bsm = FINN;
                  else if (!PUINT.correct_mis)
                    PUINT.bsm = new_prediction(new_pipe,new_decode,PUINT.predictf,
                                              PUINT.predict2,PUINT.predict1,
                                              PUINT.predict0,done,not_bl,PUINT.psm,PDPE);
                  else
                    PUINT.bsm = PDPE;
                  break;
      default:    bsm_error("unknown state");
    }

    if (CORE_PU.ForcedPrefetch) PUINT.bsm = PDPE;

  } /* end of NConfirm section */

  /*------ When a speculative fetch is refused the next fetch must -------*/
  /*       forced into Non-sequential                                     */
  /*       The fact is remembered until we see a successful AREQ_FETCH    */
  /*       In addition an unconfirmed response response forces Non-seq    */

  if      (ARM8_MEM.ARequest  == AREQ_FETCH)
    PUINT.NonSeqD1 = FALSE;
  else if (((PUINT.psm == PPRE) && (ARM8_MEM.AResponse == ARESP_NOTDONE))
           || ARM8_MEM.NConfirm)
    PUINT.NonSeqD1 = TRUE;

#ifdef DB_PU
  if (PUINT.debug_option) {
    if (PUINT.debug_file) out = PUINT.debug_file;
    else                  out = stdout;

    PUINT.debug_d2=FALSE;
    if      (ARM8_MEM.RResponse==RRESP_INSTR2) sprintf(rdata," %08X ",ARM8_MEM.Rdata);
    else if (ARM8_MEM.RResponse==RRESP_INSTR1) sprintf(rdata," %08X ",ARM8_MEM.Rdata);
    else if (ARM8_MEM.RResponse==RRESP_DATA1)  sprintf(rdata,"(%08X)",ARM8_MEM.Rdata);
    else if (ARM8_MEM.RResponse==RRESP_DATA2) { sprintf(rdata,"(%08X)",ARM8_MEM.Rdata);
                                               PUINT.debug_d2 = TRUE; }
    else                                       strcpy(rdata," -------- ");

    if (ARM8_MEM.RRequestD) strcpy(rreq,rrequestd_str(ARM8_MEM.RRequestD));
    else                    strcpy(rreq,rrequesti_str(ARM8_MEM.NRRequestIC,
                                                      ARM8_MEM.NRRequestIP));

    PUINT.debug_st = (ARM8_MEM.ARequest==AREQ_STORE)
                     || (ARM8_MEM.ARequest==AREQ_STORE_M)
                     || (ARM8_MEM.ARequest==AREQ_STORE_S)
                     || (ARM8_MEM.ARequest==AREQ_STORE_SM)
                     || (ARM8_MEM.ARequest==AREQ_STORE_B)
                     || (ARM8_MEM.ARequest==AREQ_STORE_H)
                     || (ARM8_MEM.ARequest==AREQ_STORE_X)
                     || (ARM8_MEM.ARequest==AREQ_STORE_BX);

    if (ARM8_MEM.ARequest!=AREQ_NONE)   sprintf(aw," %08X ",ARM8_MEM.VAddress);
    else                                strcpy(aw," -------- ");

    if ((PUINT.cycle_count & 31) == 1) {
      fprintf(out,"\ncyc=PcPlus8-8=Instruct=I=N=R==RQ=RS===Rdata");
      fprintf(out,"==NeI=FP=A=AQ===AS===VAddress==C=DE=0=1=2=f=m==psm=NZCV=m=t=I\n\n");
    }

    fprintf(out,"%4d %08X %08X %s %s %s %s %s%s %s %d %s %s %s %s %s %d -- %d %d %d %d %d          %s\n",
      /*           1    2    3  4  5  6  7  88a  9 10 11 12 13 14 15 16    17 18 19 19a19b         22*/
      /*  1 */ PUINT.cycle_count,
      /*  2 */ CORE_PU.PcPlus8-8,
      /*  3 */ CORE_PU.Instruct,
      /*  4 */ instraccepted_str(CORE_PU.InstrAccepted),
      /*  5 */ nofetch_str(CORE_PU.NoFetch),
      /*  6 */ instructonrdata_str(CORE_PU.InstructOnRdata),
      /*  7 */ rreq,
      /* 14 */ rresponse_str(ARM8_MEM.RResponse),
      /* 8a */ nconfirm_str(ARM8_MEM.NConfirm),
      /*  9 */ rdata,
      /* 10 */ PUINT.fifo.contents,
      /* 11 */ forcedprefetch_str(CORE_PU.ForcedPrefetch),
      /* 12 */ addressinuse_str(CORE_PU.AddressInUse),
      /* 13 */ arequest_str(ARM8_MEM.ARequest),
      /*  8 */ aresponse_str(ARM8_MEM.AResponse),
      /* 15 */ aw,
      /* 16 */ PUINT.correct_mis,
      /* 17 */ PUINT.predict0,
      /* 18 */ PUINT.predict1,
      /* 19 */ PUINT.predict2,
      /* 19a*/ PUINT.predictf,
      /* 19b*/ PUINT.predictm,
      /* 22 */ cflags_str(CORE_PU.CFlags));
  }

#endif /*=================================================================*/

  PUINT.RdataL2 = ARM8_MEM.Rdata;


/*print_fifo_contents(state);*/

  PUINT.AddressInUseL = CORE_PU.AddressInUse && !PUINT.ignore_aiu;
  PUINT.NewInstrD     = CORE_PU.NewInstr;
  PUINT.AResponseL    = ARM8_MEM.AResponse;
  PUINT.RResponseL    = ARM8_MEM.RResponse;

}

/**************************************************************************\
*                                                                          *
*     PU INITIALISATION                                                    *
*                                                                          *
\**************************************************************************/

void armul8pu_init(state)
armul8_state *state;
{
  int i;

  PUINT.psm            = IDLE;
  PUINT.bsm            = PDPE;
  PUINT.rsm            = DEF;
  PUINT.PuFull         = FALSE;
  PUINT.NewAddress     = FALSE;
  PUINT.prefetch_abort = FALSE;
  PUINT.InstrConfirmed = FALSE;
  PUINT.PuPc           = 0;
  PUINT.ProvPuPc       = 0;
  PUINT.debug_option   = 0;
  PUINT.cycle_count    = 0;
  PUINT.stop_prefetch  = 0;
  PUINT.predict_on     = FALSE;
  PUINT.correct_mis    = 0;
  PUINT.correct_misL   = 0;
  PUINT.predict_BL     = FALSE;
  PUINT.correct_cyc    = 0;
  PUINT.NonSeqD1       = 1;

  PUINT.alternate.address    = 0;
  PUINT.alternate.fifo_write = 0;
  PUINT.alternate.fifo_read  = 0;
  PUINT.alternate.contents   = 0;

  PUINT.fifo.read     = 0;
  PUINT.fifo.write    = 0;
  PUINT.fifo.contents = 0;

  PUINT.debug_file = NULL;

  ARM8_MEM.ARequest    = AREQ_NONE;
  ARM8_MEM.NRRequestIP = TRUE;

  CORE_PU.InstructOnRdata = 0;
  CORE_PU.Instruct        = 0x0BAD0BAD;
  CORE_PU.PcPlus8         = 0x0BAD0BAD;
  CORE_PU.PAbort          = 0;
  CORE_PU.NoFetch         = 1;
  CORE_PU.IgnoreBranch    = 0;
  CORE_PU.CancelD         = 0;
  CORE_PU.CancelE         = 0;

}

/**************************************************************************\
*                                                                          *
* "Sneak preview" of whether CancelE will be asserted                      *
*                                                                          *
\**************************************************************************/

int armul8pu_notcancelling(armul8_state *state)
{
  return TRUE;  /* Null implementation (it is currently difficult to      */
                /* determine whether the instruction will be cancelled    */
                /* without moving almost all the earlyph1 code back into  */
                /* lateph2).                                              */
}

/**************************************************************************\
*                                                                          *
*     PU DEBUG routine                                                     *
*                                                                          *
\**************************************************************************/

#ifdef DB_PU

#define PRINT   0
#define LIST    1
#define OPEN    2
#define APPEND  3
#define FLUSH   4
#define CLOSE   5
#define PREDICT_ON  6
#define PREDICT_OFF 7

int db_pu(int debug_option,armul8_state *state)
{
  int i;

  switch (debug_option&DEBUG_OPTION) {
    case  PRINT: printf("PU debug state = %02X\n",PUINT.debug_option);
                 printf("%2d = this listing\n",PRINT);
                 printf("%2d = full state value listing\n",LIST);
                 printf("%2d = open  pu.out file\n",OPEN);
                 printf("%2d = open  pu.out file (append)\n",APPEND);
                 printf("%2d = flush buffer out to pu.out\n",FLUSH);
                 printf("%2d = close pu.out file\n",CLOSE);
                 printf("%2d = set prediction on\n",PREDICT_ON);
                 printf("%2d = set prediction off\n",PREDICT_OFF);
                 printf("else change the debug level\n");
                 printf("value>>%d = level(0-10)\n",DEBUG_LEVEL_SHIFT);
                 break;
                 PUINT.debug_option = 0;
    case  LIST:  printf("PU debug state listing\n");
                 printf("---------------------------------------------------\n");
                 printf("                    rsm = %d\n",PUINT.rsm);
                 printf("                 PuFull = %d\n",PUINT.PuFull);
                 printf("             NewAddress = %d\n",PUINT.NewAddress);
                 printf("               ProvPuPc = %d\n",PUINT.ProvPuPc);
                 printf("                   PuPc = %d\n",PUINT.PuPc);
                 printf("           debug_option = %d\n",PUINT.debug_option);
                 printf("            cycle_count = %d\n",PUINT.cycle_count);
                 printf("          stop_prefetch = %d\n",PUINT.stop_prefetch);
                 printf("             predict_on = %d\n",PUINT.predict_on);
                 printf(" alternate.address      = %08X\n",PUINT.alternate.address);
                 printf(" alternate.fifo_write    = %d\n",PUINT.alternate.fifo_write);
                 printf(" alternate.fifo_read   = %d\n",PUINT.alternate.fifo_read);
                 printf(" alternate.contents     = %d\n",PUINT.alternate.contents);
                 for (i=0; i<FIFO_SIZE; i++) {
                   printf(" fifo.Instruct[%2d]     = %08X\n",i,PUINT.fifo.Instruct[i]);
                   printf(" fifo.PcPlus8[%2d]      = %08X\n",i,PUINT.fifo.PcPlus8[i]);
                   printf(" fifo.PAbort[%2d]       = %d\n",i,PUINT.fifo.PAbort[i]);
                   printf(" fifo.branch[%2d]       = %d\n",i,PUINT.fifo.branch[i]);
                 }
                 printf(" fifo.read             = %d\n",PUINT.fifo.read);
                 printf(" fifo.write              = %d\n",PUINT.fifo.write);
                 printf(" fifo.contents          = %d\n",PUINT.fifo.contents);
                 printf("---------------------------------------------------\n");
                 break;
    case  OPEN:  PUINT.debug_file = fopen("pu.out","w");
                 if (!PUINT.debug_file) printf("PU: cant open pu.out\n");
                 else                   printf("PU: pu.out opened\n");
                 PUINT.debug_option = debug_option;
                 break;
    case APPEND: PUINT.debug_file = fopen("pu.out","a");
                 if (!PUINT.debug_file) printf("PU: cant open pu.out\n");
                 else                   printf("PU: pu.out opened for appending\n");
                 PUINT.debug_option = debug_option;
                 break;
    case  CLOSE: fclose(PUINT.debug_file);
                 printf("PU: pu.out closed\n");
                 PUINT.debug_file=NULL;
                 PUINT.debug_option = debug_option;
                 break;
    case  FLUSH: if (PUINT.debug_file) {
                   fflush(PUINT.debug_file);
                   printf("PU: pu.out output buffer flushed\n");
                 }
                 else printf("PU: pu.out isn't open\n");
                 break;
    case PREDICT_ON:  PUINT.predict_on = TRUE;
                      printf("PU: prediction is now on\n");
                      break;
    case PREDICT_OFF: PUINT.predict_on = FALSE;
                      printf("PU: prediction is now off\n");
                      break;
    default:     PUINT.debug_option = debug_option;
                 break;
  }
  return(0);
}

#endif
