/**************************************************************************\
*                                                                          *
* ARMUL8 - an ARM8 emulator                                                *
* =========================                                                *
*                                                                          *
* Author:              D.J.Seal                                            *
* Development started: 12 January 1994                                     *
* Revising $Author$
* RCS $Revision$
* Checkin $Date$
*                                                                          *
* Copyright (C) Advanced RISC Machines Limited, 1994. All rights reserved. *
*                                                                          *
\**************************************************************************/


/*******************************************\
*                                           *
*  eu.c: routines to emulate the ARM8 core  *
*                                           *
\*******************************************/

#include <stdlib.h>
#include <stdio.h>
#include "defs.h"
#include "state.h"
#include "eu.h"
#include "eu_i.h"
#include "eu_debug.h"
#include "swis.h"
#include "armul8.h"
#include "pu.h"

/********************************************************************\
*                                                                    *
* Definitions of the states that the Execute state machine can take. *
*                                                                    *
* Negative state numbers indicate states in which the instruction    *
* in the Execute stage of the pipeline may not really be being       *
* executed. This is important because these states must not be       *
* conditionally skipped.                                             *
*                                                                    *
\********************************************************************/

/* A dummy state used for the "instruction" before the start-up reset.    */

#define S_DUMMY        -5

/* The state for an instruction which has been cancelled by the Prefetch  */
/* Unit.                                                                  */

#define S_CANCELLED    -4

/* States associated with non-instruction exception entries (interrupts,  */
/* aborts, reset). The state diagram for these is:                        */
/*                                                                        */
/*       Exception detected                                               */
/*               |                                                        */
/*          +--------+                                                    */
/*          | EXCPSR |                                                    */
/*          +--------+                                                    */
/*               |                                                        */
/*          +---------+                                                   */
/*          | EXCPREF |                                                   */
/*          +---------+                                                   */
/*               |                                                        */
/*          +----------+                                                  */
/*          | EXCRADDR |                                                  */
/*          +----------+                                                  */
/*               |                                                        */
/*    Start next instruction                                              */
/*                                                                        */
/* This will normally be followed by another idle cycle because the       */
/* forced prefetch won't have produced any results yet.                   */

#define S_EXCPSR       -3
#define S_EXCPREF      -2
#define S_EXCRADDR     -1

/* The state for an instruction which is being conditionally skipped.     */

#define S_SKIPPED      0

/* States used to deal with situations where the PSR has changed (other   */
/* than the flags) and the real hardware will have to wait a couple of    */
/* cycles for register reading, interrupt registering, etc., to settle    */
/* down.                                                                  */
/*                                                                        */
/*      From various places                                               */
/*              |                                                         */
/*       +--------------+                                                 */
/*       | SETTLE2CYCLE |                                                 */
/*       +--------------+                                                 */
/*              |                                                         */
/*       +--------------+                                                 */
/*       | SETTLE1CYCLE |                                                 */
/*       +--------------+                                                 */
/*              |                                                         */
/*   Start next instruction                                               */

#define S_SETTLE2CYCLE 1
#define S_SETTLE1CYCLE 2

/* States used for branch instructions. The state diagram for these is:   */
/*                                                                        */
/*                   |  "no branch"                                       */
/*                   *---------+                                          */
/*  NOT("no branch") |         |                                          */
/*                   |         |                                          */
/*               +--------+    |                                          */
/*               | BRANCH |    |                                          */
/*               +--------+    |                                          */
/*                   |         |                                          */
/*                   +---------+                                          */
/*                   |                                                    */
/*               +--------+                                               */
/*               |  LINK  |                                               */
/*               +--------+                                               */
/*                   |                                                    */
/*        Start next instruction                                          */

#define S_BRANCH       3
#define S_LINK         4

/* States used for data processing instructions. The state diagram for    */
/* these is:                                                              */
/*                                                                        */
/*   Immediate data processing    Non-immediate data processing           */
/*       instruction start              instruction start                 */
/*           |                                |                           */
/*           |                                |                           */
/*           |                                |  Register shift           */
/*           |                                *-----------------+         */
/*           |                                |                 |         */
/*           |                       Constant |            +---------+    */
/*           |                          shift |            | DPGETRS |    */
/*           |                                |            +---------+    */
/*           |                                |                 |         */
/*           |                                +-----------------+         */
/*           |                                |                           */
/*           |                                |  Arithmetic,              */
/*           |  Dyadic                        |  complex shift            */
/*           *------------+       Logical OR  *--------------------+      */
/*           |            |      simple shift |                    |      */
/*   Monadic |            |                   |               +---------+ */
/*           |            |          Monadic  |  Dyadic       | DPSHIFT | */
/*           |            |             +-----*--------+      +---------+ */
/*           |            |             |              |           |      */
/*     +----------+ +----------+ +------------+ +------------+ +------+   */
/*     | DPIMMOP1 | | DPIMMOP2 | | DPSHIFTOP1 | | DPSHIFTOP2 | | DPOP |   */
/*     +----------+ +----------+ +------------+ +------------+ +------+   */
/*                                                                        */
/* Each of the five terminating "states" in this diagram is really a      */
/* cluster of three related states, suffixed "A" (for ALU), "P" (for PSR  */
/* update) and "F" (for Fetch) respectively, as follows:                  */
/*                                                                        */
/*           |                                                            */
/*           |  Rd=15            S=0                                      */
/*           *----------------*----------------------+                    */
/*           |                |                      |                    */
/*    Rd!=15 |            S=1 |                      |                    */
/*           |                |                      |                    */
/*      +---------+      +---------+            +---------+               */
/*      | DPxxxxA |      | DPxxxxP |            | DPxxxxF |               */
/*      +---------+      +---------+            +---------+               */
/*           |                |                      |                    */
/*  Start next instruction    |             Start next instruction        */
/*                            |                                           */
/*                            |  Comparison                               */
/*                            *-------------+                             */
/*                            |             |                             */
/*            NOT(Comparison) |             |                             */
/*                            |             |                             */
/*                      +----------+        |                             */
/*                      |  DPPREF  |        |                             */
/*                      | (shared) |        |                             */
/*                      +----------+        |                             */
/*                            |             |                             */
/*                       SETTLE1CYCLE  SETTLE2CYCLE                       */
/*                        (see above)   (see above)                       */


#define S_DPGETRS      5
#define S_DPIMMOP1A    6
#define S_DPIMMOP1P    7
#define S_DPIMMOP1F    8
#define S_DPIMMOP2A    9
#define S_DPIMMOP2P    10
#define S_DPIMMOP2F    11
#define S_DPSHIFTOP1A  12
#define S_DPSHIFTOP1P  13
#define S_DPSHIFTOP1F  14
#define S_DPSHIFTOP2A  15
#define S_DPSHIFTOP2P  16
#define S_DPSHIFTOP2F  17
#define S_DPSHIFT      18
#define S_DPOPA        19
#define S_DPOPP        20
#define S_DPOPF        21
#define S_DPPREF       22

/* States used for MRS instructions. The state diagram for these is:    */
/*                                                                      */
/*            |                                                         */
/*         +-----+                                                      */
/*         | MRS |                                                      */
/*         +-----+                                                      */
/*            |                                                         */
/* Start next instruction                                               */

#define S_MRS          23

/* States used for MSR instructions. The state diagram for these is:    */
/*                                                                      */
/*                           |                                          */
/*         Register operand  |  Immediate operand                       */
/*            +--------------*--------------+                           */
/*            |                             |                           */
/*         +-----+                      +--------+                      */
/*         | MSR |                      | MSRIMM |                      */
/*         +-----+                      +--------+                      */
/*            |                             |                           */
/*            +--------------+--------------+                           */
/*                           |                                          */
/*        Dest = SPSR        |  Dest = CPSR,                            */
/*        OR "_flg" variant  |  not "_flg" variant,                     */
/*                           |                                          */
/*            +--------------*--------------+                           */
/*            |                             |                           */
/* Start next instruction              SETTLE2CYCLE                     */
/*                                      (see above)                     */

#define S_MSR          24
#define S_MSRIMM       25

/* States used for STR instructions. The state diagram for these is:      */
/*                                                                        */
/*    Immediate offset      Register offset      Register offset          */
/*    instruction start     STR/STRB start       STRH start               */
/*           |                   |                    |                   */
/*           |              +----------+        +------------+            */
/*           |              | STRSHIFT |        | STRNOSHIFT |            */
/*       +--------+         +----------+        +------------+            */
/*       | STRIMM |              |                    |                   */
/*       +--------+              +------------+-------+                   */
/*           |                                |                           */
/*           |                            +-------+                       */
/*           |                            | STROP |                       */
/*           |                            +-------+                       */
/*           |                                |                           */
/*           +----------------+---------------+                           */
/*                            |                                           */
/*                 Start next instruction                                 */

#define S_STRIMM       26
#define S_STRSHIFT     27
#define S_STRNOSHIFT   28
#define S_STROP        29

/* States used for LDR instructions. The state diagram for these is:      */
/*                                                                        */
/*    Immediate offset    Register offset          Register offset        */
/*    instruction start   LDRH/LDRSH/LDRSB start   LDR/LDRB start         */
/*           |                |                        |                  */
/*           |                |          simple shift  |  complex shift   */
/*           |                |                 +------*-------+          */
/*           |                |                 |              |          */
/*           |                |                 |              |          */
/*           |                |                 |         +----------+    */
/*           |                |                 |         | LDRSHIFT |    */
/*       +--------+    +--------------+   +------------+  +----------+    */
/*       | LDRIMM |    | LDRNOSHIFTOP |   | LDRSHIFTOP |       |          */
/*       +--------+    +--------------+   +------------+   +-------+      */
/*           |                |                 |          | LDROP |      */
/*           |                |                 |          +-------+      */
/*           |                |                 |              |          */
/*           +----------------+---------+-------+--------------+          */
/*                                      |                                 */
/*                                      |  Rd = R15                       */
/*                                      *--------------+                  */
/*                            Rd != R15 |              |                  */
/*                                      |         +---------+             */
/*                                      |         | LDRWAIT |             */
/*                                      |         +---------+             */
/*                                      |              |                  */
/*                                      |         +---------+             */
/*                                      |         | LDRPREF |             */
/*                                      |         +---------+             */
/*                                      |              |                  */
/*                                      +--------------+                  */
/*                                      |                                 */
/*                           Start next instruction                       */

#define S_LDRIMM       30
#define S_LDRNOSHIFTOP 31
#define S_LDRSHIFTOP   32
#define S_LDRSHIFT     33
#define S_LDROP        34
#define S_LDRWAIT      35
#define S_LDRPREF      36

/* States used for STM instructions. The state diagram for these is quite */
/* simple, with just an initialisation state followed by a looping state. */
/* All the real complexity is in the extra information that is held in    */
/* other COREINT fields and in the transition rules.                      */
/*                                                                        */
/*               |                                                        */
/*          +---------+                                                   */
/*          | STMINIT |                                                   */
/*          +---------+                                                   */
/*               |                                                        */
/*               |<-------+                                               */
/*               |        |                                               */
/*          +---------+   |                                               */
/*          |   STM   |   |                                               */
/*          +---------+   |                                               */
/*               |        |                                               */
/*               *--------+                                               */
/*               |                                                        */
/*    Start next instruction                                              */

#define S_STMINIT      37
#define S_STM          38

/* States used for LDM instructions. The main part of the state diagram   */
/* is just an initialisation state followed by a looping state. The real  */
/* complexity of this is in the extra information that is held in other   */
/* COREINT fields and in the transition rules. In addition, there is      */
/* extra complexity associated with having to cater for LDMs which load   */
/* R15.                                                                   */
/*                                                                        */
/*               |                                                        */
/*          +---------+                                                   */
/*          | LDMINIT |                                                   */
/*          +---------+                                                   */
/*               |                                                        */
/*               |  Only R15 in register list                             */
/*               *------------------------+                               */
/*               |                        |                               */
/*               |<-------+               |                               */
/*               |        |               |                               */
/*          +---------+   |               |                               */
/*          |   LDM   |   |               |                               */
/*          +---------+   |               |                               */
/*               |        |               |                               */
/*               *--------+               |                               */
/*               |                        |                               */
/*               |                        |                               */
/*               |  R15 in register list  |                               */
/*               *----------------------->|                               */
/*   R15 not in  |                        |                               */
/*   register    |                   +---------+                          */
/*   list        |                   | LDMWAIT |                          */
/*               |                   +---------+                          */
/*               |                        |                               */
/*               |                   +---------+                          */
/*               |                   | LDMPREF |                          */
/*               |                   +---------+                          */
/*               |                        |       S bit set (LDM ...PC}^) */
/*               |                        *-------------------+           */
/*               |            S bit clear |                   |           */
/*               |           (LDM ...PC}) |                   |           */
/*               |                        |                   |           */
/*    Start next instruction   Start next instruction   SETTLE1CYCLE      */
/*                                                       (see above)      */

#define S_LDMINIT      39
#define S_LDM          40
#define S_LDMWAIT      41
#define S_LDMPREF      42

/* States associated with multiply and multiply-accumulate instructions.  */
/* The state diagram for these is:                                        */
/*                                                                        */
/*             |                                                          */
/*       +-----------+                                                    */
/*       | MULFIRST  |                                                    */
/*       +-----------+                                                    */
/*             |                                                          */
/*       +-----------+                                                    */
/*       | MULSECOND |                                                    */
/*       +-----------+                                                    */
/*             |                                                          */
/*             |<--------------------------------------+                  */
/*             |                                       |                  */
/*             |  "MulTerm" not asserted               |                  */
/*             *------------------------------+        |                  */
/*             |                              |        |                  */
/*             | "MulTerm" asserted      +---------+   |                  */
/*             |                         | MULLOOP |   |                  */
/*       +-----------+                   +---------+   |                  */
/*       | MULTERM1  |                        |        |                  */
/*       +-----------+                        +--------+                  */
/*             |                                                          */
/*             |  "Long" instruction                                      */
/*             *------------------------------+                           */
/*             |                              |                           */
/*             | "Word" instruction     +-----------+                     */
/*             |                        | MULTERM2  |                     */
/*             |                        +-----------+                     */
/*             |                              |                           */
/*             +------------------------------+                           */
/*             |                                                          */
/*  Start next instruction                                                */

#define S_MULFIRST     43
#define S_MULSECOND    44
#define S_MULLOOP      45
#define S_MULTERM1     46
#define S_MULTERM2     47

/* States associated with SWP instructions. The state diagram for these   */
/* is:                                                                    */
/*                                                                        */
/*             |                                                          */
/*       +-----------+                                                    */
/*       |  SWPLOAD  |                                                    */
/*       +-----------+                                                    */
/*             |                                                          */
/*       +-----------+                                                    */
/*       | SWPSTORE  |                                                    */
/*       +-----------+                                                    */
/*             |                                                          */
/*  Start next instruction                                                */

#define S_SWPLOAD      48
#define S_SWPSTORE     49

/* States associated with MRC instructions. The state diagram for these   */
/* is:                                                                    */
/*                                                                        */
/*             |                                                          */
/*             |    bounced                                               */
/*             *-------------------+                                      */
/*         not |                   |                                      */
/*     bounced |<---------------+  |                                      */
/*             |                |  |                                      */
/*          +-----+             |  |                                      */
/*          | MRC |             |  |                                      */
/*          +-----+             |  |                                      */
/*             |    busy-waited |  |                                      */
/*             *----------------+  |                                      */
/*   not busy- |                   |                                      */
/*      waited |    bounced        |                                      */
/*             *------------------>|                                      */
/*         not |                   |                                      */
/*     bounced |                   |                                      */
/*             |                UNDEFPSR                                  */
/*  Start next instruction     (see below)                                */
/*                                                                        */
/* Note that these states are currently used for CDP, LDC and STC         */
/* instructions as well as MRC. These instructions must always be bounced */
/* by the coprocessor if they are to be executed correctly. (This will    */
/* change and further states created for the other instructions when the  */
/* full coprocessor interface is implemented.)                            */

#define S_MRC          50

/* States associated with MCR instructions. The state diagram for these   */
/* is:                                                                    */
/*                                                                        */
/*             |                                                          */
/*             |    bounced                                               */
/*             *-------------------+                                      */
/*         not |                   |                                      */
/*     bounced |<---------------+  |                                      */
/*             |                |  |                                      */
/*          +-----+             |  |                                      */
/*          | MCR |             |  |                                      */
/*          +-----+             |  |                                      */
/*             |    busy-waited |  |                                      */
/*             *----------------+  |                                      */
/*   not busy- |                   |                                      */
/*    waited   |    bounced        |                                      */
/*             *------------------>|                                      */
/*         not |                   |                                      */
/*     bounced |                   |                                      */
/*             |                UNDEFPSR                                  */
/*  Start next instruction     (see below)                                */
/*                                                                        */
/* Note that these states are currently used for CDP, LDC and STC         */
/* instructions as well as MRC. These instructions must always be bounced */
/* by the coprocessor if they are to be executed correctly. (This will    */
/* change and further states created for the other instructions when the  */
/* full coprocessor interface is implemented.)                            */

#define S_MCR          51

/* States associated with instruction exception entries (SWIs and         */
/* undefined instructions). The state diagram for these is:               */
/*                                                                        */
/*      Exception detected                                                */
/*              |                                                         */
/*        +----------+                                                    */
/*        | UNDEFPSR |                                                    */
/*        +----------+                                                    */
/*              |                                                         */
/*        +-----------+                                                   */
/*        | UNDEFPREF |                                                   */
/*        +-----------+                                                   */
/*              |                                                         */
/*        +------------+                                                  */
/*        | UNDEFRADDR |                                                  */
/*        +------------+                                                  */
/*              |                                                         */
/*              |  intercepted SWI                                        */
/*              *--------------------------+                              */
/*    Undefined |                          |                              */
/*    instr. or |                   +-------------+                       */
/*   normal SWI |                   |  SWISETTLE  |                       */
/*              |                   +-------------+                       */
/*   Start next instruction                |                              */
/*                                         |<-------------------------+   */
/*                                         |                          |   */
/*                                         |  Memory access           |   */
/*                                         |   wanted                 |   */
/*                                         *----------------+         |   */
/*                                         |                |         |   */
/*                              End of SWI |                |         |   */
/*                            interception |           +---------+    |   */
/*                                  wanted |           | SWIMEM1 |    |   */
/*                                         |           +---------+    |   */
/*                                  +-------------+         |         |   */
/*                                  |  SWIRETPSR  |    +---------+    |   */
/*                                  +-------------+    | SWIMEM2 |    |   */
/*                                         |           +---------+    |   */
/*                                  +-------------+         |         |   */
/*                                  | SWIRETPREF  |         +---------+   */
/*                                  +-------------+                       */
/*                                         |                              */
/*                                  +-------------+                       */
/*                                  | SWIRETHALT  |                       */
/*                                  +-------------+                       */
/*                                         |                              */
/*                              Start next instruction                    */
/*                                                                        */
/* This will normally be followed by another idle cycle because the       */
/* forced prefetch won't have produced any results yet.                   */

#define S_UNDEFPSR     52
#define S_UNDEFPREF    53
#define S_UNDEFRADDR   54
#define S_SWISETTLE    55
#define S_SWIMEM1      56
#define S_SWIMEM2      57
#define S_SWIRETPSR    58
#define S_SWIRETPREF   59
#define S_SWIRETHALT   60

/*****************************************\
*                                         *
* Other core-specific macros, tables etc. *
*                                         *
\*****************************************/

/* For accessing Core internal state */
#define COREINT state->coreint

/* For accessing registers other than R15 as either an lvalue or an       */
/* rvalue.                                                                */
#define REG(i,mode) (COREINT.regs[RegMap[(i)][(mode)]])

/* For accessing the CPSR                                                 */
#define CPSR (COREINT.psrs[0])

/* For accessing the current mode, including the 26/32 bit distinction    */
#define MODE MODEBITS(CPSR)

/* To determine whether a specific mode is privileged.                    */
#define PRIVILEGED_MODE(mode) (BITS((mode),0,3) != 0x0)

/* To determine whether the current mode is privileged.                   */
#define PRIVILEGED PRIVILEGED_MODE(MODE)

/* For accessing a given mode's SPSR                                      */
#define SPSR(mode) (COREINT.psrs[SpsrMap[(mode)]])

/* Values used to indicate no register being read and no register being   */
/* written respectively. They are different to ensure that we don't see   */
/* an interlock between "no register being read" and "no register being   */
/* written".                                                              */
/*   Interlocks are also prevented between reads and writes of R15 (such  */
/* hazards are dealt with by careful sequencing, not interlocks and       */
/* forwarding) by the fact that writes of R15 never set the variable      */
/* which records the register to be written to 15. Unlike earlier         */
/* versions of this code, NOREADVAL is not 15: this is to allow           */
/* ARM8_EXTEND.ABus/BBus to be set to the PC value when R15 is genuinely  */
/* being read, but leave them unchanged when nothing is being read.       */

#define NOREADVAL  16
#define NOWRITEVAL 17

/* Whether a data processing instruction with a constant-shifted register */
/* as second operand or an LDR/STR with a register offset involves a      */
/* complex shift.                                                         */

#define COMPLEX_SHIFT(instr) (BITS((instr),5,6) || BITS((instr),9,11))

/* The register-mapping table assumed by the REG macro: this maps a       */
/* register number other than 15 and a mode number to the index in        */
/* COREINT.regs for the correct register. Illegal modes have all          */
/* registers mapped to 0 to make things go very wrong! (I believe this is */
/* not the same as current hardware does, by the way.)                    */
/*                                                                        */
/* The REG macro macro isn't used to write to R15 by architecturally      */
/* and attempts have been made in the code below to avoid doing so for    */
/* any architecturally undefined either (e.g. MRS with R15 as             */
/* destination). As an additional precaution to avoid the risk of array   */
/* bounds errors, this table will map attempts to write R15 into attempts */
/* to overwrite R0: this should lead to very incorrect behaviour by the   */
/* instructions concerned without the danger of random corruption of      */
/* memory.                                                                */

const static unsigned RegMap[16][32] =
  {{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
   { 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1},
   { 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     2, 2, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2},
   { 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3},
   { 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4},
   { 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     5, 5, 5, 5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 5},
   { 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     6, 6, 6, 6, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 6},
   { 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     7, 7, 7, 7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7},
   { 8,15, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     8,15, 8, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8},
   { 9,16, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     9,16, 9, 9, 0, 0, 0, 9, 0, 0, 0, 9, 0, 0, 0, 9},
   {10,17,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    10,17,10,10, 0, 0, 0,10, 0, 0, 0,10, 0, 0, 0,10},
   {11,18,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    11,18,11,11, 0, 0, 0,11, 0, 0, 0,11, 0, 0, 0,11},
   {12,19,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    12,19,12,12, 0, 0, 0,12, 0, 0, 0,12, 0, 0, 0,12},
   {13,20,22,24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    13,20,22,24, 0, 0, 0,26, 0, 0, 0,28, 0, 0, 0,13},
   {14,21,23,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    14,21,23,25, 0, 0, 0,27, 0, 0, 0,29, 0, 0, 0,14},
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};

/* The SPSR-mapping table assumed by the SPSR macro: this maps a mode     */
/* number to the index of COREINT.psrs for the correct register. User     */
/* modes, system mode and illegal modes use zero, the index of the CPSR   */
/* - this should be regarded as an indication that no such SPSR exists.   */

const static unsigned SpsrMap[32] =
  { 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0};

/* A table indicating whether a mode number is "good".                    */

const static int GoodMode[32] =
  { TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE, TRUE,
    FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE};

/************************************************\
*                                                *
* Routines to warn about UNPREDICTABLE behaviour *
*                                                *
\************************************************/

#define UNPRED_NV             0
#define UNPRED_NONZERO_RN     1
#define UNPRED_NONZERO_RD_32  2
#define UNPRED_BAD_COMPRD_26  3
#define UNPRED_R15S_IN_USER32 4
#define UNPRED_RS_IS_R15      5
#define UNPRED_R15_REGSHIFT   6
#define UNPRED_BADMRSMSR      7
#define UNPRED_MRSMSR_R15     8
#define UNPRED_MRSMSR_SPSR    9
#define UNPRED_R15WB          10
#define UNPRED_LOADWB         11
#define UNPRED_LDRBSTRB_R15   12
#define UNPRED_INDEX_R15      13
#define UNPRED_LOSTADDR       14
#define UNPRED_UNALIGNEDR15   15
#define UNPRED_UNALIGNEDHW    16
#define UNPRED_BASER15        17
#define UNPRED_EMPTYLIST      18
#define UNPRED_STM_WB         19
#define UNPRED_LDM_WB         20
#define UNPRED_USERBANK_WB    21
#define UNPRED_USERBANK_USER  22
#define UNPRED_LDMR15S_USER   23
#define UNPRED_BADMODE        24
#define UNPRED_MULTR15        25
#define UNPRED_MUL_RD         26
#define UNPRED_HW_NONZERO     27
#define UNPRED_SWPR15         28
#define UNPRED_SWPNONZERO     29
#define UNPRED_MCR_R15        30

/* Print a specific message about UNPREDICTABLE behaviour.                */
static void msg_unpredictable(unsigned32 instr,
                              unsigned32 pcval,
                              int        reason,
                              unsigned32 extra)
{
  fprintf(stderr,"WARNING: the instruction " UNSIGNED32_FMT " at address "
         UNSIGNED32_FMT " has\n", instr, pcval);
  fprintf(stderr,"  architecturally undefined effects in the current circumstances,\n");
  switch (reason)
  {
    case UNPRED_NV:
      fprintf(stderr,"  because it has an NV condition field.\n");
      break;

    case UNPRED_NONZERO_RN:
      fprintf(stderr,"  because the Rn field should be zero, and isn't.\n");
      break;

    case UNPRED_NONZERO_RD_32:
      fprintf(stderr,"  because the Rd field should be zero in the current 32-bit\n");
      fprintf(stderr,"  mode, and isn't.\n");
      break;

    case UNPRED_BAD_COMPRD_26:
      fprintf(stderr,"  because it is a comparison-type data processing instruction\n");
      fprintf(stderr,"  executing in a 26-bit mode, and its destination field is\n");
      fprintf(stderr,"  neither 0000 nor 1111.\n");
      break;

    case UNPRED_R15S_IN_USER32:
      fprintf(stderr,"  because it is a data processing instruction with destination\n");
      fprintf(stderr,"  R15 and the S bit set, and is being executed in 32-bit user\n");
      fprintf(stderr,"  or system mode.\n");
      break;

    case UNPRED_RS_IS_R15:
      fprintf(stderr,"  because it is a data processing instruction with a shift\n");
      fprintf(stderr,"  controlled by R15.\n");
      break;

    case UNPRED_R15_REGSHIFT:
      fprintf(stderr,"  because it is a data processing instruction with a register-\n");
      fprintf(stderr,"  controlled shift, and Rm or Rn is R15.\n");
      break;

    case UNPRED_BADMRSMSR:
      fprintf(stderr,"  because it is a MRS/MSR-like instruction, but does not have\n");
      fprintf(stderr,"  one of the bit patterns for the defined MSR/MRS instructions.\n");
      break;

    case UNPRED_MRSMSR_R15:
      fprintf(stderr,"  because it is a MRS/MSR instruction which reads or writes R15.\n");
      break;

    case UNPRED_MRSMSR_SPSR:
      fprintf(stderr,"  because it is a MRS/MSR instruction which accesses the SPSR\n");
      fprintf(stderr,"  in user or system mode.\n");
      break;

    case UNPRED_R15WB:
      fprintf(stderr,"  because it requires writeback to R15.\n");
      break;

    case UNPRED_LOADWB:
      fprintf(stderr,"  because it loads and writes back to the same register.\n");
      break;

    case UNPRED_LDRBSTRB_R15:
      fprintf(stderr,"  because it is a byte or halfword load or store of R15.\n");
      break;

    case UNPRED_INDEX_R15:
      fprintf(stderr,"  because it is an LDR or STR with R15 as index register.\n");
      break;

    case UNPRED_LOSTADDR:
      fprintf(stderr,"  because it is a post-indexed LDR or STR with base register\n");
      fprintf(stderr,"  and index register identical.\n");
      break;

    case UNPRED_UNALIGNEDR15:
      fprintf(stderr,"  because it attempts to load or store R15 from the\n");
      fprintf(stderr,"  non-word-aligned address " UNSIGNED32_FMT "\n", extra);
      break;

    case UNPRED_UNALIGNEDHW:
      fprintf(stderr,"  because it attempts to load or store a halfword from\n");
      fprintf(stderr,"  the non-halfword-aligned address " UNSIGNED32_FMT "\n", extra);
      break;

    case UNPRED_BASER15:
      fprintf(stderr,"  because it is an LDM or STM with R15 as base register.\n");
      break;

    case UNPRED_EMPTYLIST:
      fprintf(stderr,"  because it is an LDM or STM with an empty register list.\n");
      break;

    case UNPRED_STM_WB:
      fprintf(stderr,"  because it is an STM with writeback, the base register\n");
      fprintf(stderr,"  in the register list, and the base register not first in\n");
      fprintf(stderr,"  the register list.\n");
      break;

    case UNPRED_LDM_WB:
      fprintf(stderr,"  because it is an LDM with writeback and the base register\n");
      fprintf(stderr,"  in the register list.\n");
      break;

    case UNPRED_USERBANK_WB:
      fprintf(stderr,"  because it is a user bank LDM or STM with writeback.\n");
      break;

    case UNPRED_USERBANK_USER:
      fprintf(stderr,"  because it is a user bank LDM or STM in a user or system mode.\n");
      break;

    case UNPRED_LDMR15S_USER:
      fprintf(stderr,"  because it is an LDM with R15 in the register list and the\n");
      fprintf(stderr,"  S bit set, in 32-bit user or system mode.\n");
      break;

    case UNPRED_BADMODE:
      fprintf(stderr,"  because it attempts to set the mode bits in a PSR to the\n");
      fprintf(stderr,"  illegal combination " UNSIGNED32_FMT "\n", extra);
      break;

    case UNPRED_MULTR15:
      fprintf(stderr,"  because it is a multiply instruction with R15 as an operand.\n");
      break;

    case UNPRED_MUL_RD:
      fprintf(stderr,"  because it is a MUL instruction and bits 15:12 of the\n");
      fprintf(stderr,"  instruction are non-zero.\n");
      break;

    case UNPRED_HW_NONZERO:
      fprintf(stderr,"  because it is a halfword or signed byte LDR/STR with a\n");
      fprintf(stderr,"  register offset and bits 11:8 of the instruction are\n");
      fprintf(stderr,"  non-zero.\n");
      break;

    case UNPRED_SWPR15:
      fprintf(stderr,"  because it is a SWP instruction with R15 as an operand.\n");
      break;

    case UNPRED_SWPNONZERO:
      fprintf(stderr,"  because it is a SWP instruction with bits 11:8 nonzero.\n");
      break;

    case UNPRED_MCR_R15:
      fprintf(stderr,"  because it is an MCR instruction with R15 as an operand.\n");
      break;

#ifdef DB_CORE
    default:
      fprintf(stderr,"  because of a reason which hasn't been written into the\n");
      fprintf(stderr,"  'msg_unpredictable' routine (Internal error in eu.c).\n");
      break;
#endif
  }
  return;
}

/* Register a warning message about UNPREDICTABLE behaviour.              */
static void unpredictable(UnpredBuffer *buffer,
                          unsigned32 instr, int reason, unsigned32 extra)
{
  if (buffer->counter < UNPREDICTABLE_MESSAGE_LIMIT)
  {
    buffer->instrs[buffer->counter]  = instr;
    buffer->reasons[buffer->counter] = reason;
    buffer->extras[buffer->counter]  = extra;
  }
  buffer->counter++;
  return;
}

/* Empty out the buffer of messages about UNPREDICTABLE behaviour.        */
static void clear_unpredictable(UnpredBuffer *buffer)
{
  buffer->counter = 0;
  return;
}

/* Print out the buffered messages about UNPREDICTABLE behaviour. The     */
/* associated PC value is picked up from the Execute stage PCplus8 value  */
/* at this point.                                                         */
static void print_unpredictable(UnpredBuffer *buffer, unsigned32 pcplus8)
{
  int i;

  if (buffer->counter > 0)
  {
    if (buffer->counter <= UNPREDICTABLE_MESSAGE_LIMIT)
    {
      for (i=0; i < buffer->counter; i++)
        msg_unpredictable(buffer->instrs[i],
                          pcplus8 - 8,
                          buffer->reasons[i],
                          buffer->extras[i]);
      fprintf(stderr,"\n");
    }
    else
    {
      for (i=0; i < UNPREDICTABLE_MESSAGE_LIMIT; i++)
        msg_unpredictable(buffer->instrs[i],
                          pcplus8 - 8,
                          buffer->reasons[i],
                          buffer->extras[i]);
      fprintf(stderr,"WARNING: There are other reasons why the instruction specified\n");
      fprintf(stderr,"  above has architecturally undefined effects, but these are not\n");
      fprintf(stderr,"  being printed because of a message buffer limit.\n\n");
    }
  }

  return;
}

#ifdef DB_CORE
/*********************************************\
*                                             *
* A routine to warn about ERRONEOUS behaviour *
*                                             *
\*********************************************/

#define ERROR_UNIMPLEMENTED 0
#define ERROR_UNCOVEREDCASE 1
#define ERROR_DOUBLEALU     2
#define ERROR_LOSTINDECODE  3
#define ERROR_BADREGWRITE   4
#define ERROR_BOUNCEBUSY_D  5
#define ERROR_BOUNCEBUSY_E  6
#define ERROR_BADSWIREQUEST 7

static void error(int reason, int extra1, int extra2)
{
  printf("ERROR in eu.c: ");
  switch (reason)
  {
    case ERROR_UNIMPLEMENTED:
      printf("Unimplemented case %i.\n\n", extra1);
      break;

    case ERROR_UNCOVEREDCASE:
      printf("Uncovered case (%i) in switch statement %i.\n\n", extra1, extra2);
      break;

    case ERROR_DOUBLEALU:
      printf("Both an LDM register write and a normal ALU register\n");
      printf("  write are occurring in the same phase 2 - this isn't possible\n");
      printf("  on the real hardware.\n\n");
      break;

    case ERROR_LOSTINDECODE:
      printf("The core appears to have accepted a new instruction into\n");
      printf("  the Decode stage when the old one was still present.\n\n");
      break;

    case ERROR_BADREGWRITE:
      printf("Attempt to write the out-of-range register %i.\n\n", extra1);
      break;

    case ERROR_BOUNCEBUSY_D:
      printf("Coprocessor wants to both busy-wait and bounce Decode\n");
      printf("  stage instruction.\n\n");
      break;

    case ERROR_BOUNCEBUSY_E:
      printf("Coprocessor wants to both busy-wait and bounce Execute\n");
      printf("  stage instruction.\n\n");
      break;

    case ERROR_BADSWIREQUEST:
      printf("SWI interceptor made an invalid request (request no. %i).\n",
             extra1);
      printf("  SWI interception terminated.\n\n");
      break;

    default:
      printf("The reason for this error hasn't been written into the\n");
      printf("  'error' routine in eu.c.\n\n");
      break;
  }
  return;
}
#endif

/************************************************\
*                                                *
* A routine to test an ARM condition code: value *
* returned is non-zero if condition failed.      *
*                                                *
\************************************************/

static int cond_failed(
  unsigned32 instr,
  unsigned32 psr)
{
  int result;

  switch (instr >> 28)
  {
    case COND_EQ:
      result = !ZBIT(psr);
      break;

    case COND_NE:
      result = ZBIT(psr) != 0;
      break;

    case COND_CS:
      result = !CBIT(psr);
      break;

    case COND_CC:
      result = CBIT(psr) != 0;
      break;

    case COND_MI:
      result = !NBIT(psr);
      break;

    case COND_PL:
      result = NBIT(psr) != 0;
      break;

    case COND_VS:
      result = !VBIT(psr);
      break;

    case COND_VC:
      result = VBIT(psr) != 0;
      break;

    case COND_HI:
      result = !CBIT(psr) || ZBIT(psr);
      break;

    case COND_LS:
      result = CBIT(psr) && !ZBIT(psr);
      break;

    case COND_GE:
      result = (NBIT(psr) != 0) ^ (VBIT(psr) != 0);
      break;

    case COND_LT:
      result = (NBIT(psr) != 0) ^ (VBIT(psr) == 0);
      break;

    case COND_GT:
      result = ZBIT(psr) || ((NBIT(psr) != 0) ^ (VBIT(psr) != 0));
      break;

    case COND_LE:
      result = !ZBIT(psr) && ((NBIT(psr) != 0) ^ (VBIT(psr) == 0));
      break;

    case COND_AL:
      result = FALSE;
      break;

    case COND_NV:
      result = TRUE;
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, instr >> 28, 1);
      break;
#endif
  }

  return result;
}

/******************************\
*                              *
* A routine to do an ARM shift *
*                              *
\******************************/

static void shift(
  unsigned32 type,
  unsigned32 amount,
  unsigned32 *operand,
  unsigned32 *cflag,
  int        immediate)
{
  switch (type)
  {
    case SHIFT_LSL:
      /* LSL - if amount is zero, there's nothing to do.                  */
      if (amount>0)
      {
        if (amount <= 32)
          *cflag = (BIT(*operand,32-amount) != 0);
        else
          *cflag = 0;

        if (amount < 32)
          *operand = (*operand) << amount;
        else
          *operand = 0;
      }
      break;

    case SHIFT_LSR:
      /* LSR - if amount is zero, there's nothing to do if it is a non-   */
      /* immediate shift, and LSR #32 to do if it is an immediate shift.  */
      if ((amount==0) && (immediate))
        amount = 32;
      if (amount>0)
      {
        if (amount <= 32)
          *cflag = (BIT(*operand,amount-1) != 0);
        else
          *cflag = 0;

        if (amount < 32)
          *operand = (*operand) >> amount;
        else
          *operand = 0;
      }
      break;

    case SHIFT_ASR:
      /* ASR - if amount is zero, there's nothing to do if it is a non-   */
      /* immediate shift, and ASR #32 to do if it is an immediate shift.  */
      if ((amount==0) && (immediate))
        amount = 32;
      if (amount>0)
      {
        if (amount < 32)
        {
          *cflag = (BIT(*operand,amount-1) != 0);
          *operand = (unsigned32) (((int32) (*operand)) >> amount);
        }
        else
        {
          *cflag = (BIT(*operand,31) != 0);
          *operand = (unsigned32) (((int32) (*operand)) >> 31);
        }
      }
      break;

    case SHIFT_ROR_RRX:
      /* ROR - if amount is zero, there's nothing to do if it is a non-   */
      /* immediate shift, and RRX to do if it is an immediate shift.      */
      if (amount==0)
      {
        if (immediate)
        {
          unsigned32 temp;
          temp     = *cflag;
          *cflag   = (BIT(*operand,0) != 0);
          *operand = temp
                     ? (0x80000000 | ((*operand) >> 1))
                     : ((*operand) >> 1);
        }
      }
      else
      {
        amount   = amount & 0x1F;
        if (amount != 0)
          *operand = ((*operand) >> amount) | ((*operand) << (32-amount));
        *cflag   = (BIT(*operand,31) != 0);
      }
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, type, 2);
      break;
#endif
  }
  return;
}

/********************************\
*                                *
* A routine to do ALU operations *
*                                *
\********************************/

static unsigned32 aluop(
  unsigned32 operand1,
  unsigned32 operand2,
  unsigned32 carryin,
  unsigned32 opcode,
  unsigned32 *cflag,
  unsigned32 *vflag)
{
  unsigned32 result;

  switch (opcode)
  {
    case ALUOP_MOV:
      result = operand2;
      break;

    case ALUOP_MVN:
      result = ~operand2;
      break;

    case ALUOP_AND: case ALUOP_TST:
      result = operand1 & operand2;
      break;

    case ALUOP_BIC:
      result = operand1 & ~operand2;
      break;

    case ALUOP_ORR:
      result = operand1 | operand2;
      break;

    case ALUOP_EOR: case ALUOP_TEQ:
      result = operand1 ^ operand2;
      break;

    case ALUOP_ADD: case ALUOP_CMN:
      carryin = 0;
      /* Intentional fall-through to next case */

    case ALUOP_ADC:
      result = operand1 + operand2 + (carryin != 0);
      *cflag = carryin ? (result <= operand1) : (result < operand1);
      *vflag = (BIT((result ^ operand1) & (result ^ operand2), 31) != 0);
      break;

    case ALUOP_SUB: case ALUOP_CMP:
      carryin = 1;
      /* Intentional fall-through to next case */

    case ALUOP_SBC:
      result = operand1 + ~operand2 + (carryin != 0);
      *cflag = carryin ? (result <= operand1) : (result < operand1);
      *vflag = (BIT((result ^ operand1) & (result ^ ~operand2), 31) != 0);
      break;

    case ALUOP_RSB:
      carryin = 1;
      /* Intentional fall-through to next case */

    case ALUOP_RSC:
      result = operand2 + ~operand1 + (carryin != 0);
      *cflag = carryin ? (result <= operand2) : (result < operand2);
      *vflag = (BIT((result ^ operand2) & (result ^ ~operand1), 31) != 0);
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, opcode, 3);
      break;
#endif
  }
  return result;
}

/**************************************************************************\
*                                                                          *
* A routine to do the initial decoding of an instruction. Returns the      *
* required initial state of the state machine. Side effects: if the        *
* instruction is architecturally undefined (in a non-data-dependent way),  *
* the 'unpredictable' routine may have been called one or more times.      *
* Also, COREINT.newexcaddress may have been set, and it definitely will    *
* will have been set if the instruction is a SWI or an undefined           *
* instruction.                                                             *
*                                                                          *
\**************************************************************************/

static int InitialState(armul8_state *state, unsigned32 instr)
{
  unsigned32 basereg;
  int        result;

  /* First, warn about UNPREDICTABLE behaviour if the condition is NV.    */
  if (IFIELD_COND(instr) == COND_NV)
    unpredictable(COREINT.newunpredbuffer, instr, UNPRED_NV, 0);

  switch (BITS(instr,25,27))
  {

    case 0x0:
      if (!BIT(instr,4))
      {
        /* Non-immediate data processing with constant shift, or          */
        /* non-immediate MSR/MRS or unallocated MSR/MRS-like. Split       */
        /* according to bits 24:20.                                       */
        switch (IFIELD_DPOPS(instr))
        {

          case ALUOPS_AND: case ALUOPS_ANDS:
          case ALUOPS_EOR: case ALUOPS_EORS:
          case ALUOPS_SUB: case ALUOPS_SUBS:
          case ALUOPS_RSB: case ALUOPS_RSBS:
          case ALUOPS_ADD: case ALUOPS_ADDS:
          case ALUOPS_ADC: case ALUOPS_ADCS:
          case ALUOPS_SBC: case ALUOPS_SBCS:
          case ALUOPS_RSC: case ALUOPS_RSCS:
          case ALUOPS_ORR: case ALUOPS_ORRS:
          case ALUOPS_BIC: case ALUOPS_BICS:
            /* Dyadic data processing instruction with constant shift.    */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. 32-bit user/system mode, Rd = R15, S bit = 1.         */
            if ((IFIELD_RD(instr) == 0xF)
                 && DP_SBIT(instr)
                 && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15S_IN_USER32, 0);

            /* Choose correct new state. This is the shift-only state or  */
            /* a variant of the shift-and-operation state depending on    */
            /* whether we're doing a complex shift and arithmetic         */
            /* operation.                                                 */
            switch (IFIELD_DPOP(instr))
            {
              case ALUOP_SUB: case ALUOP_RSB:
              case ALUOP_ADD: case ALUOP_ADC:
              case ALUOP_SBC: case ALUOP_RSC:
                /* Arithmetic operations */
                if (COMPLEX_SHIFT(instr))         result = S_DPSHIFT;
                else if (IFIELD_RD(instr) != 0xF) result = S_DPSHIFTOP2A;
                else if (DP_SBIT(instr))          result = S_DPSHIFTOP2P;
                else                              result = S_DPSHIFTOP2F;
                break;

              case ALUOP_AND: case ALUOP_EOR:
              case ALUOP_ORR: case ALUOP_BIC:
                /* Logical operations */
                if (IFIELD_RD(instr) != 0xF) result = S_DPSHIFTOP2A;
                else if (DP_SBIT(instr))     result = S_DPSHIFTOP2P;
                else                         result = S_DPSHIFTOP2F;
                break;

#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, IFIELD_DPOP(instr), 4);
                break;
#endif
            }
            break;

          case ALUOPS_MOV: case ALUOPS_MOVS:
          case ALUOPS_MVN: case ALUOPS_MVNS:
            /* Monadic data processing instruction with constant shift.   */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rn field contains non-zeros.                          */
            /*   B. 32-bit user/system mode, Rd = R15, S bit = 1.         */
            if (IFIELD_RN(instr) != 0x0)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_NONZERO_RN, 0);
            if ((IFIELD_RD(instr) == 0xF)
                 && DP_SBIT(instr)
                 && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15S_IN_USER32, 0);

            /* Choose correct new state. This is always a variant of the  */
            /* shift-and-operation state (since there are no monadic      */
            /* arithmetic operations).                                    */
            if (IFIELD_RD(instr) != 0xF) result = S_DPSHIFTOP1A;
            else if (DP_SBIT(instr))     result = S_DPSHIFTOP1P;
            else                         result = S_DPSHIFTOP1F;
            break;

          case ALUOPS_TST:
          case ALUOPS_TEQ:
            /* Logical comparison-type data processing instructions with  */
            /* a constant shift.                                          */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rd field neither 0000 nor 1111 in 26-bit mode.        */
            /*   B. Rd field non-zero in 32-bit mode.                     */
            if (IFIELD_RD(instr) != 0x0)
            {
              if (MODE32(CPSR))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_NONZERO_RD_32, 0);
              else
              {
                if (IFIELD_RD(instr) != 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_BAD_COMPRD_26, 0);
              }
            }

            /* Choose correct new state. This is always a variant of the  */
            /* shift-and-operation state.                                 */
            if (IFIELD_RD(instr) != 0xF)      result = S_DPSHIFTOP2A;
            else /* S bit must be set, so: */ result = S_DPSHIFTOP2P;
            break;

          case ALUOPS_CMP:
          case ALUOPS_CMN:
            /* Arithmetic comparison-type data processing instructions    */
            /* with a constant shift.                                     */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rd field neither 0000 nor 1111 in 26-bit mode.        */
            /*   B. Rd field non-zero in 32-bit mode.                     */
            if (IFIELD_RD(instr) != 0x0)
            {
              if (MODE32(CPSR))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_NONZERO_RD_32, 0);
              else
              {
                if (IFIELD_RD(instr) != 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_BAD_COMPRD_26, 0);
              }
            }

            /* Choose correct new state. This is the shift-only state or  */
            /* a variant of the shift-and-operation state depending on    */
            /* whether we're doing a complex shift.                       */
            if (COMPLEX_SHIFT(instr))         result = S_DPSHIFT;
            else if (IFIELD_RD(instr) != 0xF) result = S_DPSHIFTOP2A;
            else /* S bit must be set, so: */ result = S_DPSHIFTOP2P;
            break;

          case ALUOPS_CTL1:
          case ALUOPS_CTL2:
          case ALUOPS_CTL3:
          case ALUOPS_CTL4:
            /* These are MRS/MSR-like instructions. Bits 7:5 should be    */
            /* zero for them to actually be MRS/MSRs - otherwise they are */
            /* unallocated instructions and should enter the undefined    */
            /* instruction trap.                                          */
            if (BITS(instr,5,7) != 0x0)
            {
              result  = S_UNDEFPSR;
              COREINT.newexcaddress = VECTOR_UNDEF;
            }
            else
            {
              /* First warn about UNPREDICTABLE cases - this means all    */
              /* but the few datasheet-specified cases. In each case,     */
              /* then enter the correct state.                            */
              switch (BITS(instr,21,22))
              {
                case 0x0:
                  if ((IFIELD_RN(instr) != 0xF)
                      || (IFIELD_RS(instr) != 0x0)
                      || (IFIELD_RM(instr) != 0x0))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_BADMRSMSR, 0);
                  else if (IFIELD_RD(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_R15, 0);
                  result = S_MRS;
                  break;

                case 0x1:
                  if ((BITS(instr,8,15) != 0xF0)
                      || ((BITS(instr,16,19) != 0x1)
                          && (BITS(instr,16,19) != 0x8)
                          && (BITS(instr,16,19) != 0x9)))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_BADMRSMSR, 0);
                  else if (IFIELD_RM(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_R15, 0);
                  result = S_MSR;
                  break;

                case 0x2:
                  if ((IFIELD_RN(instr) != 0xF)
                      || (IFIELD_RS(instr) != 0x0)
                      || (IFIELD_RM(instr) != 0x0))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_BADMRSMSR, 0);
                  else if (IFIELD_RD(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_R15, 0);
                  else if (!PRIVILEGED || (MODE == MODE_SYSTEM32))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_SPSR, 0);
                  result = S_MRS;
                  break;

                case 0x3:
                  if ((BITS(instr,8,15) != 0xF0)
                      || ((BITS(instr,16,19) != 0x1)
                          && (BITS(instr,16,19) != 0x8)
                          && (BITS(instr,16,19) != 0x9)))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_BADMRSMSR, 0);
                  else if (IFIELD_RM(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_R15, 0);
                  else if (!PRIVILEGED || (MODE == MODE_SYSTEM32))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_MRSMSR_SPSR, 0);
                  result = S_MSR;
                  break;

#ifdef DB_CORE
                default:
                  error(ERROR_UNCOVEREDCASE, BITS(instr,21,22), 5);
                  break;
#endif
              }
            }
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, IFIELD_DPOPS(instr), 6);
            break;
#endif
        }
      }
      else if (!BIT(instr,7))
      {
        /* Non-immediate data processing with register shift, or          */
        /* unallocated MSR/MRS-like.                                      */
        switch (IFIELD_DPOPS(instr))
        {

          case ALUOPS_AND: case ALUOPS_ANDS:
          case ALUOPS_EOR: case ALUOPS_EORS:
          case ALUOPS_SUB: case ALUOPS_SUBS:
          case ALUOPS_RSB: case ALUOPS_RSBS:
          case ALUOPS_ADD: case ALUOPS_ADDS:
          case ALUOPS_ADC: case ALUOPS_ADCS:
          case ALUOPS_SBC: case ALUOPS_SBCS:
          case ALUOPS_RSC: case ALUOPS_RSCS:
          case ALUOPS_ORR: case ALUOPS_ORRS:
          case ALUOPS_BIC: case ALUOPS_BICS:
            /* Dyadic data processing instruction with register shift.    */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rs = R15.                                             */
            /*   B. Rm = R15 or Rn = R15.                                 */
            /*   C. 32-bit user/system mode, Rd = R15, S bit = 1.         */
            if (IFIELD_RS(instr) == 0xF)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_RS_IS_R15, 0);
            if ((IFIELD_RM(instr) == 0xF) || (IFIELD_RN(instr) == 0xF))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15_REGSHIFT, 0);
            if ((IFIELD_RD(instr) == 0xF)
                 && DP_SBIT(instr)
                 && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15S_IN_USER32, 0);

            /* Choose correct new state. This is the shift-register-      */
            /* obtaining state in all cases.                              */
            result = S_DPGETRS;
            break;

          case ALUOPS_MOV: case ALUOPS_MOVS:
          case ALUOPS_MVN: case ALUOPS_MVNS:
            /* Monadic data processing instruction with register shift.   */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rn field contains non-zeros.                          */
            /*   B. Rs = R15.                                             */
            /*   C. Rm = R15.                                             */
            /*   D. 32-bit user/system mode, Rd=R15, S bit = 1.           */
            if (IFIELD_RN(instr) != 0x0)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_NONZERO_RN, 0);
            if (IFIELD_RS(instr) == 0xF)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_RS_IS_R15, 0);
            if (IFIELD_RM(instr) == 0xF)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15_REGSHIFT, 0);
            if ((IFIELD_RD(instr) == 0xF)
                 && DP_SBIT(instr)
                 && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15S_IN_USER32, 0);

            /* Choose correct new state. This is the shift-register-      */
            /* obtaining state in all cases.                              */
            result = S_DPGETRS;
            break;

          case ALUOPS_TST:
          case ALUOPS_TEQ:
          case ALUOPS_CMP:
          case ALUOPS_CMN:
            /* Comparison-type data processing instructions with a        */
            /* register shift.                                            */

            /* First warn about UNPREDICTABLE cases:                      */
            /*   A. Rd field neither 0000 nor 1111 in 26-bit mode.        */
            /*   B. Rd field non-zero in 32-bit mode.                     */
            /*   C. Rs = R15.                                             */
            /*   D. Rm = R15 or Rn = R15.                                 */
            if (IFIELD_RD(instr) != 0x0)
            {
              if (MODE32(CPSR))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_NONZERO_RD_32, 0);
              else
              {
                if (IFIELD_RD(instr) != 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_BAD_COMPRD_26, 0);
              }
            }
            if (IFIELD_RS(instr) == 0xF)
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_RS_IS_R15, 0);
            if ((IFIELD_RM(instr) == 0xF) || (IFIELD_RN(instr) == 0xF))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_R15_REGSHIFT, 0);

            /* Choose correct new state. This is the shift-register-      */
            /* obtaining state in all cases.                              */
            result = S_DPGETRS;
            break;

          case ALUOPS_CTL1:
          case ALUOPS_CTL2:
          case ALUOPS_CTL3:
          case ALUOPS_CTL4:
            /* These are entirely unallocated MRS/MSR-like instructions.  */
            result  = S_UNDEFPSR;
            COREINT.newexcaddress = VECTOR_UNDEF;
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, IFIELD_DPOPS(instr), 7);
            break;
#endif
        }
      }
      else
      {
        /* Multiply, SWP, STRH, LDRH, LDRSH, LDRSB or unallocated         */
        /* instructions in the same area. First split according to the    */
        /* values of bits 6 and 5, then according to the values of bits   */
        /* 24:20.                                                         */
        /*   The only exception possibility at this point is that we've   */
        /* got an undefined instruction. So we might as well set          */
        /* COREINT.newexcaddress to indicate that - it will simply be     */
        /* ignored if the instruction is defined.                         */
        COREINT.newexcaddress = VECTOR_UNDEF;
        switch (BITS(instr,5,6))
        {
          case 0x0:
            /* Multiplies, SWPs and unallocated instructions in the same  */
            /* area.                                                      */
            switch (BITS(instr,20,24))
            {
              case 0x00: result = S_MULFIRST;     break;
              case 0x01: result = S_MULFIRST;     break;
              case 0x02: result = S_MULFIRST;     break;
              case 0x03: result = S_MULFIRST;     break;
              case 0x04: result = S_UNDEFPSR;     break;
              case 0x05: result = S_UNDEFPSR;     break;
              case 0x06: result = S_UNDEFPSR;     break;
              case 0x07: result = S_UNDEFPSR;     break;
              case 0x08: result = S_MULFIRST;     break;
              case 0x09: result = S_MULFIRST;     break;
              case 0x0A: result = S_MULFIRST;     break;
              case 0x0B: result = S_MULFIRST;     break;
              case 0x0C: result = S_MULFIRST;     break;
              case 0x0D: result = S_MULFIRST;     break;
              case 0x0E: result = S_MULFIRST;     break;
              case 0x0F: result = S_MULFIRST;     break;
              case 0x10: result = S_SWPLOAD;      break;
              case 0x11: result = S_UNDEFPSR;     break;
              case 0x12: result = S_UNDEFPSR;     break;
              case 0x13: result = S_UNDEFPSR;     break;
              case 0x14: result = S_SWPLOAD;      break;
              case 0x15: result = S_UNDEFPSR;     break;
              case 0x16: result = S_UNDEFPSR;     break;
              case 0x17: result = S_UNDEFPSR;     break;
              case 0x18: result = S_UNDEFPSR;     break;
              case 0x19: result = S_UNDEFPSR;     break;
              case 0x1A: result = S_UNDEFPSR;     break;
              case 0x1B: result = S_UNDEFPSR;     break;
              case 0x1C: result = S_UNDEFPSR;     break;
              case 0x1D: result = S_UNDEFPSR;     break;
              case 0x1E: result = S_UNDEFPSR;     break;
              case 0x1F: result = S_UNDEFPSR;     break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, BITS(instr,20,24), 8);
                break;
#endif
            }

            /* Now check operand restrictions on each possible decoded    */
            /* instruction.                                               */
            switch (result)
            {
              case S_MULFIRST:
                /* UNPREDICTABLE cases for multiply instructions are:     */
                /*   A. Rd field ("Rn" in multiply instruction            */
                /*      documentation) non-zero in a MUL instruction;     */
                /*   B. Any register field indicating R15.                */
                if ((BITS(instr,21,24) == 0x0)
                    && (IFIELD_RD(instr) != 0x0))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_MUL_RD, 0);
                if ((IFIELD_RM(instr) == 0xF)
                    || (IFIELD_RS(instr) == 0xF)
                    || (IFIELD_RD(instr) == 0xF)
                    || (IFIELD_RN(instr) == 0xF))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_MULTR15, 0);
                break;

              case S_SWPLOAD:
                /* UNPREDICTABLE cases for SWP instructions are:          */
                /*   A. Any of Rn, Rd or Rm equal to R15.                 */
                /*   B. Rs field non-zero.                                */
                if ((IFIELD_RN(instr) == 0xF)
                    || (IFIELD_RD(instr) == 0xF)
                    || (IFIELD_RM(instr) == 0xF))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_SWPR15, 0);
                if (IFIELD_RS(instr) != 0x0)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_SWPNONZERO, 0);
                break;

              case S_UNDEFPSR:
                /* Nothing to check. */
                break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, result, 9);
                break;
#endif
            }
            break;

          case 0x1:
            /* LDRH, STRH and unallocated instructions in the same area.  */
            switch (BITS(instr,20,24))
            {
              case 0x00: result = S_STRNOSHIFT;   break;
              case 0x01: result = S_LDRNOSHIFTOP; break;
              case 0x02: result = S_UNDEFPSR;     break;
              case 0x03: result = S_UNDEFPSR;     break;
              case 0x04: result = S_STRIMM;       break;
              case 0x05: result = S_LDRIMM;       break;
              case 0x06: result = S_UNDEFPSR;     break;
              case 0x07: result = S_UNDEFPSR;     break;
              case 0x08: result = S_STRNOSHIFT;   break;
              case 0x09: result = S_LDRNOSHIFTOP; break;
              case 0x0A: result = S_UNDEFPSR;     break;
              case 0x0B: result = S_UNDEFPSR;     break;
              case 0x0C: result = S_STRIMM;       break;
              case 0x0D: result = S_LDRIMM;       break;
              case 0x0E: result = S_UNDEFPSR;     break;
              case 0x0F: result = S_UNDEFPSR;     break;
              case 0x10: result = S_STRNOSHIFT;   break;
              case 0x11: result = S_LDRNOSHIFTOP; break;
              case 0x12: result = S_STRNOSHIFT;   break;
              case 0x13: result = S_LDRNOSHIFTOP; break;
              case 0x14: result = S_STRIMM;       break;
              case 0x15: result = S_LDRIMM;       break;
              case 0x16: result = S_STRIMM;       break;
              case 0x17: result = S_LDRIMM;       break;
              case 0x18: result = S_STRNOSHIFT;   break;
              case 0x19: result = S_LDRNOSHIFTOP; break;
              case 0x1A: result = S_STRNOSHIFT;   break;
              case 0x1B: result = S_LDRNOSHIFTOP; break;
              case 0x1C: result = S_STRIMM;       break;
              case 0x1D: result = S_LDRIMM;       break;
              case 0x1E: result = S_STRIMM;       break;
              case 0x1F: result = S_LDRIMM;       break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, BITS(instr,20,24), 10);
                break;
#endif
            }

            /* Now check operand restrictions on each possible decoded    */
            /* instruction.                                               */
            switch (result)
            {
              case S_STRNOSHIFT:
              case S_LDRNOSHIFTOP:
                /* UNPREDICTABLE cases for STRH/LDRH/LDRSH/LDRSB with a   */
                /* register offset are:                                   */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load/store of R15.                                */
                /*   D. Offset register is R15.                           */
                /*   E. Post-indexed with base & index registers the      */
                /*      same.                                             */
                /*   F. Bits 11:8 of the instruction are non-zero.        */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if ((IFIELD_RN(instr) == IFIELD_RD(instr))
                      && DT_LBIT(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                if (IFIELD_RM(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_INDEX_R15, 0);
                if ((IFIELD_RN(instr) == IFIELD_RM(instr))
                    && !DT_PBIT(instr))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LOSTADDR, 0);
                if (IFIELD_RS(instr) != 0x0)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_HW_NONZERO, 0);
                break;

              case S_LDRIMM:
              case S_STRIMM:
                /* UNPREDICTABLE cases for STRH/LDRH/LDRSH/LDRSB with an  */
                /* immediate offset are:                                  */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load/store of R15.                                */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if ((IFIELD_RN(instr) == IFIELD_RD(instr))
                      && DT_LBIT(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                break;

              case S_UNDEFPSR:
                /* Nothing to check. */
                break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, result, 11);
                break;
#endif
            }
            break;

          case 0x2:
            /* LDRSB and unallocated instructions in the same area.       */
            switch (BITS(instr,20,24))
            {
              case 0x00: result = S_UNDEFPSR;     break;
              case 0x01: result = S_LDRNOSHIFTOP; break;
              case 0x02: result = S_UNDEFPSR;     break;
              case 0x03: result = S_UNDEFPSR;     break;
              case 0x04: result = S_UNDEFPSR;     break;
              case 0x05: result = S_LDRIMM;       break;
              case 0x06: result = S_UNDEFPSR;     break;
              case 0x07: result = S_UNDEFPSR;     break;
              case 0x08: result = S_UNDEFPSR;     break;
              case 0x09: result = S_LDRNOSHIFTOP; break;
              case 0x0A: result = S_UNDEFPSR;     break;
              case 0x0B: result = S_UNDEFPSR;     break;
              case 0x0C: result = S_UNDEFPSR;     break;
              case 0x0D: result = S_LDRIMM;       break;
              case 0x0E: result = S_UNDEFPSR;     break;
              case 0x0F: result = S_UNDEFPSR;     break;
              case 0x10: result = S_UNDEFPSR;     break;
              case 0x11: result = S_LDRNOSHIFTOP; break;
              case 0x12: result = S_UNDEFPSR;     break;
              case 0x13: result = S_LDRNOSHIFTOP; break;
              case 0x14: result = S_UNDEFPSR;     break;
              case 0x15: result = S_LDRIMM;       break;
              case 0x16: result = S_UNDEFPSR;     break;
              case 0x17: result = S_LDRIMM;       break;
              case 0x18: result = S_UNDEFPSR;     break;
              case 0x19: result = S_LDRNOSHIFTOP; break;
              case 0x1A: result = S_UNDEFPSR;     break;
              case 0x1B: result = S_LDRNOSHIFTOP; break;
              case 0x1C: result = S_UNDEFPSR;     break;
              case 0x1D: result = S_LDRIMM;       break;
              case 0x1E: result = S_UNDEFPSR;     break;
              case 0x1F: result = S_LDRIMM;       break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, BITS(instr,20,24), 12);
                break;
#endif
            }

            /* Now check operand restrictions on each possible decoded    */
            /* instruction.                                               */
            switch (result)
            {
              case S_LDRNOSHIFTOP:
                /* UNPREDICTABLE cases for LDRH/LDRSH/LDRSB with a        */
                /* register offset are:                                   */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load of R15.                                      */
                /*   D. Offset register is R15.                           */
                /*   E. Post-indexed with base & index registers the      */
                /*      same.                                             */
                /*   F. Bits 11:8 of the instruction are non-zero.        */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if (IFIELD_RN(instr) == IFIELD_RD(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                if (IFIELD_RM(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_INDEX_R15, 0);
                if ((IFIELD_RN(instr) == IFIELD_RM(instr))
                    && !DT_PBIT(instr))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LOSTADDR, 0);
                if (IFIELD_RS(instr) != 0x0)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_HW_NONZERO, 0);
                break;

              case S_LDRIMM:
                /* UNPREDICTABLE cases for LDRH/LDRSH/LDRSB with an       */
                /* immediate offset are:                                  */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load of R15.                                      */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if (IFIELD_RN(instr) == IFIELD_RD(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                break;

              case S_UNDEFPSR:
                /* Nothing to check. */
                break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, result, 13);
                break;
#endif
            }
            break;

          case 0x3:
            /* LDRSH and unallocated instructions in the same area.       */
            switch (BITS(instr,20,24))
            {
              case 0x00: result = S_UNDEFPSR;     break;
              case 0x01: result = S_LDRNOSHIFTOP; break;
              case 0x02: result = S_UNDEFPSR;     break;
              case 0x03: result = S_UNDEFPSR;     break;
              case 0x04: result = S_UNDEFPSR;     break;
              case 0x05: result = S_LDRIMM;       break;
              case 0x06: result = S_UNDEFPSR;     break;
              case 0x07: result = S_UNDEFPSR;     break;
              case 0x08: result = S_UNDEFPSR;     break;
              case 0x09: result = S_LDRNOSHIFTOP; break;
              case 0x0A: result = S_UNDEFPSR;     break;
              case 0x0B: result = S_UNDEFPSR;     break;
              case 0x0C: result = S_UNDEFPSR;     break;
              case 0x0D: result = S_LDRIMM;       break;
              case 0x0E: result = S_UNDEFPSR;     break;
              case 0x0F: result = S_UNDEFPSR;     break;
              case 0x10: result = S_UNDEFPSR;     break;
              case 0x11: result = S_LDRNOSHIFTOP; break;
              case 0x12: result = S_UNDEFPSR;     break;
              case 0x13: result = S_LDRNOSHIFTOP; break;
              case 0x14: result = S_UNDEFPSR;     break;
              case 0x15: result = S_LDRIMM;       break;
              case 0x16: result = S_UNDEFPSR;     break;
              case 0x17: result = S_LDRIMM;       break;
              case 0x18: result = S_UNDEFPSR;     break;
              case 0x19: result = S_LDRNOSHIFTOP; break;
              case 0x1A: result = S_UNDEFPSR;     break;
              case 0x1B: result = S_LDRNOSHIFTOP; break;
              case 0x1C: result = S_UNDEFPSR;     break;
              case 0x1D: result = S_LDRIMM;       break;
              case 0x1E: result = S_UNDEFPSR;     break;
              case 0x1F: result = S_LDRIMM;       break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, BITS(instr,20,24), 14);
                break;
#endif
            }

            /* Now check operand restrictions on each possible decoded    */
            /* instruction.                                               */
            switch (result)
            {
              case S_LDRNOSHIFTOP:
                /* UNPREDICTABLE cases for LDRH/LDRSH/LDRSB with a        */
                /* register offset are:                                   */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load of R15.                                      */
                /*   D. Offset register is R15.                           */
                /*   E. Post-indexed with base & index registers the      */
                /*      same.                                             */
                /*   F. Bits 11:8 of the instruction are non-zero.        */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if (IFIELD_RN(instr) == IFIELD_RD(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                if (IFIELD_RM(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_INDEX_R15, 0);
                if ((IFIELD_RN(instr) == IFIELD_RM(instr))
                    && !DT_PBIT(instr))
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LOSTADDR, 0);
                if (IFIELD_RS(instr) != 0x0)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_HW_NONZERO, 0);
                break;

              case S_LDRIMM:
                /* UNPREDICTABLE cases for LDRH/LDRSH/LDRSB with an       */
                /* immediate offset are:                                  */
                /*   A. Writeback or post-indexing with base register     */
                /*      R15.                                              */
                /*   B. Writeback and loading to the same register.       */
                /*   C. Load of R15.                                      */
                if (DT_WBIT(instr) || !DT_PBIT(instr))
                {
                  if (IFIELD_RN(instr) == 0xF)
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_R15WB, 0);
                  if (IFIELD_RN(instr) == IFIELD_RD(instr))
                    unpredictable(COREINT.newunpredbuffer,
                                  instr, UNPRED_LOADWB, 0);
                }
                if (IFIELD_RD(instr) == 0xF)
                  unpredictable(COREINT.newunpredbuffer,
                                instr, UNPRED_LDRBSTRB_R15, 0);
                break;

              case S_UNDEFPSR:
                /* Nothing to check. */
                break;
#ifdef DB_CORE
              default:
                error(ERROR_UNCOVEREDCASE, result, 15);
                break;
#endif
            }
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, BITS(instr,5,6), 16);
            break;
#endif
        }
      }
      break;

    case 0x1:
      /* Data processing or MSR with an immediate operand, or unallocated */
      /* MSR/MRS-like. Split according to bits 24:20.                     */
      switch (IFIELD_DPOPS(instr))
      {

        case ALUOPS_AND: case ALUOPS_ANDS:
        case ALUOPS_EOR: case ALUOPS_EORS:
        case ALUOPS_SUB: case ALUOPS_SUBS:
        case ALUOPS_RSB: case ALUOPS_RSBS:
        case ALUOPS_ADD: case ALUOPS_ADDS:
        case ALUOPS_ADC: case ALUOPS_ADCS:
        case ALUOPS_SBC: case ALUOPS_SBCS:
        case ALUOPS_RSC: case ALUOPS_RSCS:
        case ALUOPS_ORR: case ALUOPS_ORRS:
        case ALUOPS_BIC: case ALUOPS_BICS:
          /* Dyadic data processing instruction with immediate operand.   */

          /* First warn about UNPREDICTABLE cases:                        */
          /*   A. 32-bit user/system mode, Rd = R15, S bit = 1.           */
          if ((IFIELD_RD(instr) == 0xF)
               && DP_SBIT(instr)
               && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_R15S_IN_USER32, 0);

          /* Choose correct new state.                                    */
          if (IFIELD_RD(instr) != 0xF) result = S_DPIMMOP2A;
          else if (DP_SBIT(instr))     result = S_DPIMMOP2P;
          else                         result = S_DPIMMOP2F;
          break;

        case ALUOPS_MOV: case ALUOPS_MOVS:
        case ALUOPS_MVN: case ALUOPS_MVNS:
          /* Monadic data processing instruction with immediate operand.  */

          /* First warn about UNPREDICTABLE cases:                        */
          /*   A. Rn field contains non-zeros.                            */
          /*   B. 32-bit user/system mode, Rd = R15, S bit = 1.           */
          if (IFIELD_RN(instr) != 0x0)
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_NONZERO_RN, 0);
          if ((IFIELD_RD(instr) == 0xF)
               && DP_SBIT(instr)
               && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_R15S_IN_USER32, 0);

          /* Choose correct new state.                                    */
          if (IFIELD_RD(instr) != 0xF) result = S_DPIMMOP1A;
          else if (DP_SBIT(instr))     result = S_DPIMMOP1P;
          else                         result = S_DPIMMOP1F;
          break;

        case ALUOPS_TST:
        case ALUOPS_TEQ:
        case ALUOPS_CMP:
        case ALUOPS_CMN:
          /* Comparison-type data processing instructions with an         */
          /* immediate operand.                                           */

          /* First warn about UNPREDICTABLE cases:                        */
          /*   A. Rd field neither 0000 nor 1111 in 26-bit mode.          */
          /*   B. Rd field non-zero in 32-bit mode.                       */
          if (IFIELD_RD(instr) != 0x0)
          {
            if (MODE32(CPSR))
              unpredictable(COREINT.newunpredbuffer,
                            instr, UNPRED_NONZERO_RD_32, 0);
            else
            {
              if (IFIELD_RD(instr) != 0xF)
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_BAD_COMPRD_26, 0);
            }
          }

          /* Choose correct new state.                                    */
          if (IFIELD_RD(instr) != 0xF)            result = S_DPIMMOP2A;
          else /* S bit must be set, so: */       result = S_DPIMMOP2P;
          break;

        case ALUOPS_CTL1:
        case ALUOPS_CTL2:
        case ALUOPS_CTL3:
        case ALUOPS_CTL4:
          /* These are either unallocated MRS/MSR-like instructions or    */
          /* MSR instructions with immediate operands. If the latter,     */
          /* warn about UNPREDICTABLE cases.                              */
          switch (BITS(instr,21,22))
          {
            case 0x0:
              result  = S_UNDEFPSR;
              COREINT.newexcaddress = VECTOR_UNDEF;
              break;

            case 0x1:
              if ((IFIELD_RD(instr) != 0xF)
                  || ((BITS(instr,16,19) != 0x1)
                      && (BITS(instr,16,19) != 0x8)
                      && (BITS(instr,16,19) != 0x9)))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_BADMRSMSR, 0);

              result = S_MSRIMM;
              break;

            case 0x2:
              result  = S_UNDEFPSR;
              COREINT.newexcaddress = VECTOR_UNDEF;
              break;

            case 0x3:
              if ((IFIELD_RD(instr) != 0xF)
                  || ((BITS(instr,16,19) != 0x1)
                      && (BITS(instr,16,19) != 0x8)
                      && (BITS(instr,16,19) != 0x9)))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_BADMRSMSR, 0);
              else if (!PRIVILEGED || (MODE == MODE_SYSTEM32))
                unpredictable(COREINT.newunpredbuffer,
                              instr, UNPRED_MRSMSR_SPSR, 0);

              result = S_MSRIMM;
              break;

#ifdef DB_CORE
            default:
              error(ERROR_UNCOVEREDCASE, BITS(instr,21,22), 17);
              break;
#endif
          }
          break;

#ifdef DB_CORE
        default:
          error(ERROR_UNCOVEREDCASE, IFIELD_DPOPS(instr), 18);
          break;
#endif
      }
      break;

    case 0x2:
      /* LDR or STR with immediate offset. First check for the            */
      /* UNPREDICTABLE cases. These are:                                  */
      /*   A. Writeback or post-indexing with base register R15.          */
      /*   B. Writeback and loading to the same register.                 */
      /*   C. Byte load/store of R15.                                     */
      /* There is another unpredictable case (non-aligned load/store of   */
      /* R15), but that can't be checked for until we've got the address. */
      if (DT_WBIT(instr) || !DT_PBIT(instr))
      {
        if (IFIELD_RN(instr) == 0xF)
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_R15WB, 0);
        if ((IFIELD_RN(instr) == IFIELD_RD(instr)) && DT_LBIT(instr))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_LOADWB, 0);
      }
      if ((IFIELD_RD(instr) == 0xF) && DT_BBIT(instr))
        unpredictable(COREINT.newunpredbuffer,
                      instr, UNPRED_LDRBSTRB_R15, 0);

      /* Now enter the correct state - this basically just depends on     */
      /* whether we're dealing with an LDR or an STR.                     */
      if (DT_LBIT(instr))
        result = S_LDRIMM;
      else
        result = S_STRIMM;
      break;

    case 0x3:
      /* Either LDR or STR with a register offset, or UNDEFINED,          */
      /* controlled by bit 4:                                             */
      if (!BIT(instr,4))
      {
        /* LDR or STR with a register offset. First check for the         */
        /* UNPREDICTABLE cases. These are:                                */
        /*   A. Writeback or post-indexing with base register R15.        */
        /*   B. Writeback and loading to the same register.               */
        /*   C. Byte load/store of R15.                                   */
        /*   D. Offset register is R15.                                   */
        /*   E. Post-indexed with base & index registers the same.        */
        /* There is another unpredictable case (non-aligned load/store of */
        /* R15), but that can't be checked for until we've got the        */
        /* address.                                                       */
        if (DT_WBIT(instr) || !DT_PBIT(instr))
        {
          if (IFIELD_RN(instr) == 0xF)
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_R15WB, 0);
          if ((IFIELD_RN(instr) == IFIELD_RD(instr)) && DT_LBIT(instr))
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_LOADWB, 0);
        }
        if ((IFIELD_RD(instr) == 0xF) && DT_BBIT(instr))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_LDRBSTRB_R15, 0);
        if (IFIELD_RM(instr) == 0xF)
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_INDEX_R15, 0);
        if ((IFIELD_RN(instr) == IFIELD_RM(instr)) && !DT_PBIT(instr))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_LOSTADDR, 0);

        /* Now enter the correct state - this depends on whether we've    */
        /* got an STR or LDR, and if the latter, whether the shift is     */
        /* "complex".                                                     */
        if (!DT_LBIT(instr))           result = S_STRSHIFT;
        else if (COMPLEX_SHIFT(instr)) result = S_LDRSHIFT;
        else                           result = S_LDRSHIFTOP;
      }
      else
      {
        result  = S_UNDEFPSR;
        COREINT.newexcaddress = VECTOR_UNDEF;
      }
      break;

    case 0x4:
      /* This is an LDM or STM. Warn about UNPREDICTABLE cases that are   */
      /* shared between them:                                             */
      /*   A. Base register is R15.                                       */
      /*   B. No registers in the list.                                   */
      basereg = IFIELD_RN(instr);
      if (basereg == 0xF)
        unpredictable(COREINT.newunpredbuffer,
                      instr, UNPRED_BASER15, 0);
      if (BITS(instr,0,15) == 0x0000)
        unpredictable(COREINT.newunpredbuffer,
                      instr, UNPRED_EMPTYLIST, 0);

      if (!DT_LBIT(instr))
      {
        /* This is an STM. Warn about further UNPREDICTABLE cases:        */
        /*   A. Writeback with base register in list & not first in list. */
        /*   B. User bank transfer with writeback.                        */
        /*   C. User bank transfer in a user/system mode.                 */
        if (DT_WBIT(instr)
            && BIT(instr,basereg)
            && (basereg != 0)
            && (BITS(instr,0,basereg-1) != 0))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_STM_WB, 0);
        if (DTM_SBIT(instr) && DT_WBIT(instr))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_USERBANK_WB, 0);
        if (DTM_SBIT(instr) && (!PRIVILEGED || (MODE == MODE_SYSTEM32)))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_USERBANK_USER, 0);

        result = S_STMINIT;
      }
      else
      {
        /* This is an LDM. Warn about further UNPREDICTABLE cases:        */
        /*   A. Writeback with base register in list.                     */
        /*   B. User bank transfer (NB not including R15, otherwise it    */
        /*      isn't a user bank transfer) with writeback.               */
        /*   C. User bank transfer (same NB) in a user/system mode.       */
        /*   D. R15 in list and S bit set in 32-bit user/system mode.     */
        if (DT_WBIT(instr) && BIT(instr,basereg))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_LDM_WB, 0);
        if (DTM_SBIT(instr) && !BIT(instr,15) && DT_WBIT(instr))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_USERBANK_WB, 0);
        if (DTM_SBIT(instr) && !BIT(instr,15)
            && (!PRIVILEGED || (MODE == MODE_SYSTEM32)))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_USERBANK_USER, 0);
        if (DTM_SBIT(instr) && BIT(instr,15)
            && ((MODE == MODE_USER32) || (MODE == MODE_SYSTEM32)))
          unpredictable(COREINT.newunpredbuffer,
                        instr, UNPRED_LDMR15S_USER, 0);

        result = S_LDMINIT;
      }
      break;

    case 0x5:
      if (COREINT.nobranchD)
        result = S_LINK;
      else
        result = S_BRANCH;
      break;

    case 0x6:
      /* LDC or STC instruction: this is currently treated just like MRC, */
      /* with coprocessor being obliged to "bounce" it.                   */
      result = S_MRC;
      break;

    case 0x7:
      if (BIT(instr,24))
      {
        /* This is a SWI.                                                 */
        COREINT.newexcaddress = VECTOR_SWI;
        result                = S_UNDEFPSR;
      }
      else if (CP_RTnotDOBIT(instr))
      {
        /* This is an MRC or MCR.                                         */
        if (CP_MRCnotMCRBIT(instr))
          result = S_MRC;
        else
        {
          /* MCR instructions have an UNPREDICTABLE case when their Rd    */
          /* field is R15.                                                */
          if (IFIELD_RD(instr) == 0xF)
            unpredictable(COREINT.newunpredbuffer,
                          instr, UNPRED_MCR_R15, 0);

          result = S_MCR;
        }
      }
      else
      {
        /* This is a CDP, and is currently treated just like an MRC, with */
        /* the coprocessor being obliged to bounce it.                    */
        result = S_MRC;
      }
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, BITS(instr,25,27), 19);
      break;
#endif
  }

  return result;
}

/*******************************************************\
*                                                       *
* Routines to deal with LDM/STM priority encoding, etc. *
*                                                       *
\*******************************************************/

/* Given one of 0, 1, 2, 4, 8, 0x10, ..., 0x80000000, returns the         */
/* (low-endian) bit number of the set bit if it is one of bits 0..15, and */
/* returns NOWRITEVAL otherwise.                                          */

static unsigned32 bitno_in_LDMSTM(unsigned32 mask)
{
  /* Note: there are much more efficient tricks available to do what      */
  /* follows. It's also a *lot* less obvious that they work, and I don't  */
  /* believe this particular area is likely to be performance-critical,   */
  /* so I am not using them!                                              */
  unsigned32 i;

  for (i=0; i<16; i++)
  {
    if (mask == (((unsigned32) 1) << i))
      return i;
  }
  return NOWRITEVAL;
}

/* The following routine produces the next two registers from the list    */
/* and whether there are any more.                                        */

static void do_penc(armul8_state *state)
{
  unsigned32 reglist, lowbit;

  reglist = COREINT.ma_reglist;

  lowbit          = reglist & (-reglist);  /* Trick to isolate lowest bit */
  COREINT.ma_reg3 = bitno_in_LDMSTM(lowbit);
  reglist         &= ~lowbit;

  lowbit          = reglist & (-reglist);  /* Repeat to get second priority */
  COREINT.ma_reg4 = bitno_in_LDMSTM(lowbit);
  reglist         &= ~lowbit;

  lowbit          = reglist & (-reglist);  /* Then see whether there's any more */
  COREINT.ma_more = (bitno_in_LDMSTM(lowbit) != NOWRITEVAL);
}

/* The following routine initialises the priority encoding structure with a */
/* given register list and produces the first priority encodings.           */

static void init_penc(armul8_state *state, unsigned32 reglist)
{
  COREINT.ma_reglist = reglist;
  COREINT.ma_reg1    = NOWRITEVAL;
  COREINT.ma_reg2    = NOWRITEVAL;

  do_penc(state);
}

/* The following routine removes a given number of registers from the       */
/* register list and produces updated priority encodings. The number of     */
/* registers removed must be 0, 1 or 2.                                     */

static void update_penc(armul8_state *state)
{
  switch (COREINT.ma_remove)
  {
    case 0:
      break;

    case 1:
      COREINT.ma_reg1 = COREINT.ma_reg2;
      COREINT.ma_reg2 = COREINT.ma_reg3;
      /* Tricky code to remove bottommost bit from register list.           */
      COREINT.ma_reglist &= ~(COREINT.ma_reglist & (-COREINT.ma_reglist));
      break;

    case 2:
      COREINT.ma_reg1 = COREINT.ma_reg3;
      COREINT.ma_reg2 = COREINT.ma_reg4;
      /* Tricky code to remove two bottommost bits from register list.      */
      COREINT.ma_reglist &= ~(COREINT.ma_reglist & (-COREINT.ma_reglist));
      COREINT.ma_reglist &= ~(COREINT.ma_reglist & (-COREINT.ma_reglist));
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, COREINT.ma_remove, 20);
      break;
#endif
  }

  do_penc(state);
  return;
}

/* Count the bits in a word.                                                */

static unsigned32 bitcount(unsigned32 word)
{
  /* Add pairs of adjacent bits to give 16 values of 0-2. */
  word = (word & 0x55555555) + ((word >> 1) & 0x55555555);

  /* Add pairs of these to give 8 values of 0-4. */
  word = (word & 0x33333333) + ((word >> 2) & 0x33333333);

  /* Add pairs of these to give 4 values of 0-8. */
  word = (word & 0x0F0F0F0F) + ((word >> 4) & 0x0F0F0F0F);

  /* Add pairs of these to give 2 values of 0-16. Note we no longer need to */
  /* mask out bits that interfere with each other, since every sum from now */
  /* on will fit in a byte.                                                 */
  word = word + (word >> 8);

  /* Return the sum of the two values of 0-16. */
  return (word + (word >> 16)) & 0xFF;
}

/***************************************************\
*                                                   *
* Routine to reset all the core's state and outputs *
*                                                   *
\***************************************************/

static void reset_state(armul8_state *state)
{
  int i;

  /* Reset internal state                                                 */
  /* --------------------                                                 */

  COREINT.stateE         = S_EXCPSR;     /* Start of exception entry.     */
  COREINT.excaddress     = VECTOR_RESET;
  COREINT.interlocked    = FALSE;
  COREINT.busywaited     = FALSE;

  /* No need to initialise 'newstateE', 'newexcaddress' and               */
  /* 'newinterlocked' fields.                                             */

  COREINT.abusreg        = NOREADVAL;
  COREINT.bbusreg        = NOREADVAL;
  COREINT.aluforwarda    = FALSE;
  COREINT.aluforwardb    = FALSE;

  COREINT.intseqpt_base  = 0x00000000;   /* Though there should NOT be    */
  COREINT.intseqpt_sub4  = FALSE;        /*  any interrupts for a while!  */
  COREINT.newintseqpt_base = 0x00000008;
  COREINT.newintseqpt_sub4 = TRUE;
  COREINT.newinstr       = FALSE;        /* Exception sequence starting.  */

  /* No need to initialise the 'rdata', 'abus', 'bbus', 'carryhold',      */
  /* 'zerohold', 'carryhold2', 'zerohold2', 'shiftval' or 'feedback'      */
  /* fields.                                                              */

  COREINT.enterdecode    = FALSE;
  COREINT.enterexecute   = FALSE;

  /* Don't initialise COREINT.regs (better to have any dependencies on    */
  /* initial values of registers result in random behaviour). The same    */
  /* goes for the valid PSR bits, except for the mode bits and interrupt  */
  /* flags in the CPSR, but the reserved bits must be forced to zero.     */

  COREINT.psrs[0] = (COREINT.psrs[0] & FLAG_BITS)
                    | I_BIT | F_BIT | MODE_SVC32;
  for (i=1; i<6; i++) COREINT.psrs[i] &= PSR_BITS;

  /* Contents of Decode and Execute pipeline stages will be cancelled by  */
  /* the Prefetch Unit in a cycle or two, after we issue the forced       */
  /* prefetch and before the exception entry sequence completes.          */
  /*   So no need to initialise the 'instrD', 'abortedD', 'pcplus8D',     */
  /* 'cancelledD', 'nobranchD', 'instrE', 'abortedE', 'pcplus8E' or       */
  /* 'nobranchE' fields.                                                  */

  COREINT.areqE          = AREQ_NONE;  /* Starting with no outstanding    */
  COREINT.rreqE          = RREQD_NONE; /*  memory requests or register    */
  COREINT.writereg1E     = NOWRITEVAL; /*  writes. No need to initialise  */
  COREINT.writeflagsE    = 0;          /*  the 'writemodeX'               */
  COREINT.writereg2E     = NOWRITEVAL; /*  /'aluwrite_modeX'              */
  COREINT.aluwrite_regE  = NOWRITEVAL; /*  /'aluwrite_valueX' fields, nor */
  COREINT.newcpsrE       = CPSR;       /*  the 'pcplus8X' field, since    */
  COREINT.newspsrE       = SPSR(MODE); /*  they are only wanted for data  */
  COREINT.newspsr_modeE  = MODE;       /*  aborts. The 'base_regX' fields */
  COREINT.base_regE      = NOWRITEVAL; /*  are initialised for safety,    */
  COREINT.areqM          = AREQ_NONE;  /*  but there is no need to do the */
  COREINT.rreqM          = RREQD_NONE; /*  same for the 'base_modeX' or   */
  COREINT.writereg1M     = NOWRITEVAL; /*  'base_valueX' fields.          */
  COREINT.writeflagsM    = 0;
  COREINT.writereg2M     = NOWRITEVAL;
  COREINT.base_regM      = NOWRITEVAL;
  COREINT.storeM         = STORE_NOTHING; /* So no need to initialise the */
                                       /*  the 'storevalueM' field.       */
  COREINT.aluwrite_regM  = NOWRITEVAL;
  COREINT.newcpsrM       = CPSR;
  COREINT.newspsrM       = SPSR(MODE);
  COREINT.newspsr_modeM  = MODE;
  COREINT.areqW          = AREQ_NONE;
  COREINT.rreqW          = RREQD_NONE;
  COREINT.writereg1W     = NOWRITEVAL;
  COREINT.writeflagsW    = 0;
  COREINT.writereg2W     = NOWRITEVAL;

  /* None of the "multiple access" fields need to be initialised, since   */
  /* they are initialised by the first cycle of an LDM or STM, and not    */
  /* used outside LDM and STM instructions.                               */

  /* No warning messages about UNPREDICTABLE behaviour at this point.     */
  COREINT.newunpredbuffer = &COREINT.unpredbuffer1;
  clear_unpredictable(COREINT.newunpredbuffer);
  COREINT.unpredbuffer = &COREINT.unpredbuffer2;
  clear_unpredictable(COREINT.unpredbuffer);

  /* The 'lastinstr', 'lastpcplus8', 'laststate' and 'laststatus' fields  */
  /* need to be initialised differently depending whether this is a       */
  /* start-up reset or one caused by the interface 'Reset' signal.        */
  /* Initialising them is therefore left for the caller to do.            */

  /* Reset outputs in Core - Prefetch Unit interface                      */
  /* -----------------------------------------------                      */
  CORE_PU.ForcedPrefetch = FALSE;
  CORE_PU.AddressInUse   = TRUE;   /* To allow ARM8-memory initialisation */
  CORE_PU.InstrAccepted  = FALSE;
  CORE_PU.CFlags         = (unsigned) FLAGBITS(CPSR);
  CORE_PU.NewInstr       = FALSE;

  /* Reset outputs in ARM8 - memory interface                             */
  /* ----------------------------------------                             */
  ARM8_MEM.ARequest      = AREQ_NONE;
  ARM8_MEM.Privileged    = TRUE;
  ARM8_MEM.TwentySixBit  = FALSE;
  ARM8_MEM.RRequestD     = RREQD_NONE;
  ARM8_MEM.NRRequestIC   = TRUE;

  /* Reset outputs in ARM8 - Extension interface                          */
  /* -------------------------------------------                          */
  ARM8_EXTEND.MulEnable   = FALSE;
  ARM8_EXTEND.MulInit     = FALSE;
  ARM8_EXTEND.MulAcc      = FALSE;
  ARM8_EXTEND.MulSgn      = FALSE;
  ARM8_EXTEND.MulLong     = FALSE;
  ARM8_EXTEND.MulWrHigh   = FALSE;
  ARM8_EXTEND.Interlocked = FALSE;

  /* Reset outputs in ARM8 - Coprocessors interface                       */
  /* ----------------------------------------------                       */
  ARM8_COPROC.CEnterDecode  = FALSE;     /* So no need to set 'CInstruct' */
  ARM8_COPROC.CEnterExecute = FALSE;
  ARM8_COPROC.CExecute      = FALSE;
  ARM8_COPROC.Interlocked   = FALSE;

  return;
}

/****************************\
*                            *
* The initialisation routine *
*                            *
\****************************/

void armul8core_init(armul8_state *state)
{
  reset_state(state);

  /* For the purposes of the 'armul8core_lastinstr' call, we'll produce   */
  /* an unlikely instruction/PC/state combination (instruction 0x00000000 */
  /* at address 0x00000000 with a dummy state), plus something about the  */
  /* last instruction being "lost".                                       */
  COREINT.lastinstr   = 0x00000000;
  COREINT.lastpcplus8 = 0x00000008;
  COREINT.laststate   = S_DUMMY;
  COREINT.laststatus  = CORESTATUS_LOST;
}

/**************************************************************************\
*                                                                          *
* The "early" phase 1 routine                                              *
* ===========================                                              *
*                                                                          *
* Summary of things done by this routine:                                  *
*   1) Just-loaded data written to registers, or (if destination is R15)   *
*      preserved for a later forced prefetch in the same cycle.            *
*   2) Just-loaded data put on ABus and BBus if LDR forwarding is needed.  *
*   3) PSR writes performed.                                               *
*   4) Conditional skipping of instructions dealt with.                    *
*   5) AddressInUse signal in the Core-PU interface driven.                *
*   6) Wdata bus in the ARM8-Memory interface driven.                      *
*   7) MulWrHigh signal in the ARM8-extension (i.e. multiplier) interface  *
*      driven.                                                             *
*   8) CEnterDecode and CEnterExecute signals and CInstruct bus in the     *
*      ARM8-coprocessor interface driven.                                  *
*   9) CData bus in the ARM8-coprocessor interface driven for MCR          *
*      instructions.                                                       *
*                                                                          *
\**************************************************************************/

void armul8core_earlyph1(armul8_state *state)
{
#ifdef DB_CORE
  db_core_msg1("CORE: state is",COREINT.stateE);
  db_core_msg0("\n");
#endif

  /* The Rdata[] value may need to be written to a register, or to the B  */
  /* bus for a subsequent forced prefetch.                                */
  /*   Note that the Rdata[] value was picked up at the end of the        */
  /* previous 'armul8core_lateph2' call and that any byte rotations and   */
  /* extractions will have been done then. This doesn't reflect what the  */
  /* hardware does accurately, but makes it possible to produce correct   */
  /* results from 'armul8core_reginfo' without duplicating code.          */

  /* Write it to a register and do LDR forwarding if necessary.           */
  if (COREINT.writereg1W != NOWRITEVAL)
  {
    REG(COREINT.writereg1W, COREINT.writemodeW) = COREINT.rdata1;
#ifdef DB_CORE
    if ((COREINT.writereg1W < 0) || (COREINT.writereg1W > 14))
      error(ERROR_BADREGWRITE, COREINT.writereg1W, 0);
    db_core_msg1("CORE: LDR/LDM1 write of",COREINT.rdata1);
    db_core_msg1(" into register",COREINT.writereg1W);
    db_core_msg1(" in mode",COREINT.writemodeW);
    db_core_msg0("\n");
#endif

    /* Deal with LDR forwarding.                                          */
    if ((COREINT.writereg1W == COREINT.abusreg) && !COREINT.aluforwarda)
      ARM8_EXTEND.ABus = COREINT.rdata1;
    if ((COREINT.writereg1W == COREINT.bbusreg) && !COREINT.aluforwardb)
      ARM8_EXTEND.BBus = COREINT.rdata1;
  }

  /* Put the loaded value on to the B bus if necessary for a forced       */
  /* prefetch at the end of the cycle.                                    */
  if (COREINT.writeflagsW & WFLAG_TOBBUS)
    ARM8_EXTEND.BBus = COREINT.rdata1;

  /* Also do the SPSR->CPSR transfer for an LDM ...PC}^ at this point.    */
  if (COREINT.writeflagsW & WFLAG_SETPSR)
  {
    if (MODE32(CPSR))
      COREINT.newcpsrM = SPSR(COREINT.writemodeW);  /* Will be CPSR->CPSR */
                                              /* copy if user/system mode */
    else if (PRIVILEGED_MODE(COREINT.writemodeW))
      COREINT.newcpsrM = (CPSR & ~(FLAG_BITS | MASK_BITS | MODE26_BITS))
                         | (COREINT.rdata1 & (FLAG_BITS | MODE26_BITS))
                         | ((COREINT.rdata1 >> MASK26MOVE) & MASK_BITS);
    else
      COREINT.newcpsrM = (CPSR & ~FLAG_BITS) | (COREINT.rdata1 & FLAG_BITS);
  }

  /* Put the new PSR value(s) in their proper places.                     */
  CPSR             = COREINT.newcpsrM;

  if ((COREINT.newspsr_modeM != MODE_USER32)
      && (COREINT.newspsr_modeM != MODE_SYSTEM32)
      && (COREINT.newspsr_modeM != MODE_USER26))
    SPSR(COREINT.newspsr_modeM) = COREINT.newspsrM;

  /* Put out a data value on 'Wdata' if required.                         */
  if (COREINT.storeM != STORE_NOTHING)
  {
    if (COREINT.storeM == STORE_VALUE)
      ARM8_MEM.Wdata = COREINT.storevalueM;
    else
      ARM8_MEM.Wdata = ARM8_EXTEND.BBus;
#ifdef DB_CORE
    db_core_msg1("CORE: Wdata value written in ph1:", ARM8_MEM.Wdata);
    db_core_msg0("\n");
#endif
    COREINT.storeM = STORE_NOTHING;
  }

  /* Deal with conditionally skipped instructions, optimising the AL      */
  /* case. (Needs to be done now so that we can get AddressInUse right.)  */

  if ((IFIELD_COND(COREINT.instrE) != COND_AL)
      && COREINT.newinstr
      && (COREINT.stateE >= 0)            /* Not in interrupt entry, etc. */
      && cond_failed(COREINT.instrE,CPSR))
  {
    COREINT.stateE       = S_SKIPPED;
    COREINT.interlocked  = FALSE;
    COREINT.busywaited   = FALSE;
  }

  /* Work out whether to assert 'AddressInUse' to claim 'VAddress'.       */
  /*   Note that this doesn't pay attention to whether the instruction    */
  /* will be cancelled by the Prefetch Unit: the Prefetch Unit will       */
  /* factor this in.                                                      */
  switch (COREINT.stateE)
  {
    case S_EXCPREF:
    case S_BRANCH:
    case S_DPIMMOP1F:
    case S_DPIMMOP2F:
    case S_DPSHIFTOP1F:
    case S_DPSHIFTOP2F:
    case S_DPOPF:
    case S_DPPREF:
    case S_STRIMM:
    case S_STROP:
    case S_LDRIMM:
    case S_LDRSHIFTOP:
    case S_LDRNOSHIFTOP:
    case S_LDROP:
    case S_LDRPREF:
    case S_STMINIT:
    case S_STM:
    case S_LDMINIT:
    case S_LDM:
    case S_LDMPREF:
    case S_SWPLOAD:
    case S_SWPSTORE:
    case S_MCR:
    case S_UNDEFPREF:
    case S_SWISETTLE:
    case S_SWIMEM1:
    case S_SWIMEM2:
    case S_SWIRETPREF:
      CORE_PU.AddressInUse = TRUE;
      break;

    default:
      /* Not an error: this covers all the remaining states.              */
      CORE_PU.AddressInUse = FALSE;
      break;
  }

  /* Drive the MulWrHigh signal to the multiplier high if we're in the    */
  /* first termination cycle and it's a "long" multiply instruction.      */
  ARM8_EXTEND.MulWrHigh = (COREINT.stateE == S_MULTERM1)
                          && MUL_LBIT(COREINT.instrE);

  /* If an instruction has just advanced into the Decode stage, drive     */
  /* CEnterDecode high and either drive the Decode instruction on to      */
  /* CInstruct (if it is a coprocessor instruction) or drive the top two  */
  /* bits of CInstruct to ones (if it isn't).                             */
  /*   Otherwise, drive CEnterDecode low.                                 */
  ARM8_COPROC.CEnterDecode = COREINT.enterdecode;
  if (ARM8_COPROC.CEnterDecode)
  {
    if (COREINT.cancelledD
        || (BITS(COREINT.instrD,26,27) != 0x3)
        || (BITS(COREINT.instrD,24,25) == 0x3))
      ARM8_COPROC.CInstruct |= 0x3000000;
    else
      ARM8_COPROC.CInstruct = BITS(COREINT.instrD,0,25);
  }

  /* If an instruction has just advanced into the Execute stage, drive    */
  /* CEnterExecute high; otherwise, drive it low.                         */
  ARM8_COPROC.CEnterExecute = COREINT.enterexecute;

  /* Drive CData to the B bus value for MCR instructions. Note that the   */
  /* B bus value may have been driven in this same phase 1, but only by   */
  /* this routine itself, which is safe. (Whether this "forwarding to     */
  /* itself" has OK timing on the real silicon I doubt, but that will be  */
  /* dealt with by the interlock code.)                                   */
  if (COREINT.stateE == S_MCR)
    ARM8_COPROC.CData = ARM8_EXTEND.BBus;

  return;
}

/**************************************************************************\
*                                                                          *
* The "late" phase 1 routine                                               *
* ==========================                                               *
*                                                                          *
* Summary of things done by this routine:                                  *
*   1) Instructions cancelled as instructed by the PU;                     *
*   2) LDM/STM priority encoding updates;                                  *
*   3) Rdata, Abus, Bbus and MulC values read;                             *
*   4) Determine whether current memory responses indicate that a data     *
*      abort is happening.                                                 *
*   5) Advance the FIQ/IRQ "synchroniser" latches.                         *
* All but the last two must only be done for "real" phase 1s - i.e. if     *
* NConfirm is not asserted.                                                *
*                                                                          *
\**************************************************************************/

void armul8core_lateph1(armul8_state *state)
{
  if (!ARM8_MEM.NConfirm)
  {

    /* Deal with cancelling instructions.                                 */

    if (CORE_PU.CancelE && COREINT.newinstr)
    {
      COREINT.stateE      = S_CANCELLED;
      COREINT.interlocked = FALSE;
      COREINT.busywaited  = FALSE;
    }
    if (CORE_PU.CancelD)
      COREINT.cancelledD = TRUE;

    /* Do the priority encoding for STMs and LDMs.                        */

    if (!COREINT.interlocked)    /* Busy-waiting not possible for LDM/STM */
    {
      switch (COREINT.stateE)
      {
        case S_STMINIT:
          /* Initialise the priority encoder with the instruction's       */
          /* register list.                                               */
          init_penc(state, BITS(COREINT.instrE,0,15));
          break;

        case S_LDMINIT:
          /* Initialise the priority encoder with the instruction's       */
          /* register list, excluding R15 if it is present.               */
          init_penc(state, BITS(COREINT.instrE,0,14));
          break;

        case S_STM:
        case S_LDM:
          /* Advance the priority encoder by the amount worked out on the */
          /* last call to "armul8core_lateph2".                           */
          update_penc(state);
          break;

        default:
          /* Not an error - most instructions aren't LDM or STM!          */
          break;
      }
    }

    /* Pick up the Rdata, ABus, BBus and MulC values, in case they're     */
    /* wanted in early phase 2. (Note that it would be unsafe to pick     */
    /* them up in "armul8core_earlyph2": some other component of the      */
    /* system might have modified them by then.)                          */
    COREINT.rdata2 = ARM8_MEM.Rdata;
    COREINT.abus   = ARM8_EXTEND.ABus;
    COREINT.bbus   = ARM8_EXTEND.BBus;
    COREINT.mulc   = ARM8_EXTEND.MulC;

  }                   /* End of stuff only executed when NConfirm is low. */

  /* We're getting a data abort if we've got an ARequest in the Memory    */
  /* stage and an abort AResponse, or if we're getting a data abort       */
  /* RResponse.                                                           */
  COREINT.aborting =
    ((COREINT.areqM != AREQ_NONE) && (ARM8_MEM.AResponse == ARESP_ABORT))
    || (ARM8_MEM.RResponse == RRESP_EXTABORT_D);

  /* If we're in the appropriate state of a SWI interception sequence, an */
  /* abort must be signalled to the SWI interceptor rather than causing   */
  /* a data abort exception entry sequence to start.                      */
  /*   Note that recording the abort status for responses that turn out   */
  /* not to be confirmed doesn't matter: nothing will use the recorded    */
  /* value until the state machine advances to S_SWIMEM2, and at that     */
  /* point we'll have the correct confirmed results.                      */
  if (COREINT.stateE == S_SWIMEM1)
  {
    COREINT.core_swis.Status =
      COREINT.aborting ? SWISTATUS_ABORT : SWISTATUS_DONE;
    COREINT.aborting = FALSE;
  }

  /* Advance the IRQ/FIQ data to the second synchroniser latch.           */

  COREINT.fiq2 = COREINT.fiq1;
  COREINT.irq2 = COREINT.irq1;

  return;
}

/*************************************************************************\
*                                                                         *
* Definitions of the bits in the "todo" variable in the following routine *
*                                                                         *
\*************************************************************************/

/* Bit 0 = 1: 2nd operand is B bus shifted by a constant.                 */
#define TODO_2CSHIFT   ((unsigned32) 0x00000001)

/* Bit 1 = 1: 2nd operand is B bus shifted by a register.                 */
#define TODO_2RSHIFT   ((unsigned32) 0x00000002)

/* Bit 2 = 1: 2nd operand is a data processing immediate constant.        */
#define TODO_2DPCONS   ((unsigned32) 0x00000004)

/* Bit 3 = 1: 2nd operand is a branch instruction constant.               */
#define TODO_2BRCONS   ((unsigned32) 0x00000008)

/* Bit 4 = 1: 2nd operand is an LDR/STR constant.                         */
#define TODO_2LSCONS   ((unsigned32) 0x00000010)

/* Bit 5 = 1: 2nd operand is an LDC/STC constant.                         */
#define TODO_2CPCONS   ((unsigned32) 0x00000020)

/* Bit 6 = 1: 2nd operand is constant 0.                                  */
#define TODO_2ZEROCONS ((unsigned32) 0x00000040)

/* Bit 7 = 1: 2nd operand is constant 4.                                  */
#define TODO_2FOURCONS ((unsigned32) 0x00000080)

/* Bit 8 = 1: 2nd operand is the value in ALU feedback latch.             */
#define TODO_2FEEDBACK ((unsigned32) 0x00000100)

/* Bit 9 = 1: ALU operation is given by instruction bits 24:21.           */
#define TODO_OPINS     ((unsigned32) 0x00000200)

/* Bit 10 = 1: ALU operation is an addition.                              */
#define TODO_OPADD     ((unsigned32) 0x00000400)

/* Bit 11 = 1: ALU operation is an add-with-carry, and there are          */
/*             associated special effects for the Z and C flags.          */
#define TODO_OPADC     ((unsigned32) 0x00000800)

/* Bit 12 = 1: ALU operation is a subtraction.                            */
#define TODO_OPSUB     ((unsigned32) 0x00001000)

/* Bit 13 = 1: ALU operation is a move.                                   */
#define TODO_OPMOVE    ((unsigned32) 0x00002000)

/* Bit 14 = 1: "ALU operation" is to get a PSR value (for MRS).           */
#define TODO_OPPSR     ((unsigned32) 0x00004000)

/* Bit 15 = 1: "ALU operation" is to get the CData[] value (for MRC).     */
#define TODO_OPCDATA   ((unsigned32) 0x00008000)

/* Bit 16 = 1: Write result flags to CPSR.                                */
#define TODO_FLAGS     ((unsigned32) 0x00010000)

/* Bit 17 = 1: Do the PSR manipulations for an exception entry.           */
#define TODO_EXCPSR    ((unsigned32) 0x00020000)

/* Bit 18 = 1: Write bits 31:26, 1:0 of result (for 26-bit modes) or the  */
/*             current mode's SPSR (for 32-bit modes) to CPSR.            */
#define TODO_DPSR      ((unsigned32) 0x00040000)

/* Bit 19 = 1: Write bits 31:28 of result to the flags (for MRC).         */
#define TODO_DFLAGS    ((unsigned32) 0x00080000)

/* Bit 20 = 1: Write result to instruction-specified PSR (for MSR).       */
#define TODO_DIPSR     ((unsigned32) 0x00100000)

/* Bit 21 = 1: Send result to address bus.                                */
#define TODO_DADDR     ((unsigned32) 0x00200000)

/* Bit 22 = 1: Put the exception address on the bus for an exception      */
/*             entry.                                                     */
#define TODO_EXCADDR   ((unsigned32) 0x00400000)

/* Bit 23 = 1: Send A bus value to address bus.                           */
#define TODO_ABUSADDR  ((unsigned32) 0x00800000)

/* Bit 24 = 1: Send A bus value to shift amount latch.                    */
#define TODO_ABUSSHIFT ((unsigned32) 0x01000000)

/* Bit 25 = 1: 2 low order bits of the address should be remembered for   */
/*             byte rotation purposes.                                    */
#define TODO_BROT      ((unsigned32) 0x02000000)

/* Bit 26 = 1: 2 low order bits of the address select a byte to duplicate */
/*             in COREINT.storevalueM.                                    */
#define TODO_BDUP      ((unsigned32) 0x04000000)

/* Bit 27 = 1: Bit 1 of the address selects a halfword to duplicate in    */
/*             COREINT.storevalueM.                                       */
#define TODO_HDUP      ((unsigned32) 0x08000000)

/* Bit 28 = 1: Warn about UNPREDICTABLE behaviour if bottom two bits of   */
/*             address are not zeros.                                     */
#define TODO_BWARN     ((unsigned32) 0x10000000)

/* Bit 29 = 1: Do all the special processing associated with an STM.      */
#define TODO_STM       ((unsigned32) 0x20000000)

/* Bit 30 = 1: Do all the special processing associated with an LDM.      */
#define TODO_LDM       ((unsigned32) 0x40000000)

/**************************************************************************\
*                                                                          *
* The "early" phase 2 routine                                              *
* ===========================                                              *
*                                                                          *
* Summary of things done by this routine:                                  *
*   1) ALU results from previous cycle or just-loaded data written to      *
*      registers;                                                          *
*   2) Shifts and ALU operations performed;                                *
*   3) PSR reads performed;                                                *
*   4) New PSR values calculated;                                          *
*   5) Decision made as to whether this is the last Execute cycle of the   *
*      current instruction, and CORE_PU.NewInstr driven on the result;     *
*   6) Memory requests generated and driven on to the ARM8-Memory          *
*      interface;                                                          *
*   7) ForcedPrefetch and InstrAccepted signals and CFlags bus in the      *
*      Core-PU interface driven.                                           *
*   8) MulEnable, MulInit, MulAcc, MulSgn and MulLong signals driven in    *
*      Core-Extension (i.e. multiplier) interface.                         *
*   9) Determine the potential next state of the state machine, either by  *
*      advancing the current instruction to its next state or by decoding  *
*      the next instruction, depending on whether this is the last cycle   *
*      of the current instruction.                                         *
*  10) Determine which registers are being read on to the A and B buses    *
*      and drive them on to the ABus and BBus buses in the Core-Extension  *
*      interface. All ALU forwarding is done at this point.                *
*  11) Determine whether the next cycle will interlock, based on the same  *
*      assumption as the potential new state and the register reads were,  *
*      namely that the next cycle won't be the start of an exception       *
*      entry sequence, won't be conditionally skipped and won't be         *
*      cancelled by the Prefetch Unit. Drive this information to the       *
*      multiplier and coprocessors.                                        *
*  12) Drive the CExecute signal in the ARM8-coprocessor interface.        *
*                                                                          *
\**************************************************************************/

void armul8core_earlyph2(armul8_state *state)
{
  unsigned32 todo, instr, operand1, operand2, result, newc, newv;
  unsigned32 flags, fwd_flags, moretocome;
  unsigned32 address, ma_reg, carryin, mode, readrega, readregb;
  int        i;

#ifdef DB_CORE
  /* If there is both an ALU write and a phase 2 load write, something's  */
  /* wrong.                                                               */
  if ((COREINT.aluwrite_regM != NOWRITEVAL)
      && (COREINT.writereg2W != NOWRITEVAL))
    error(ERROR_DOUBLEALU, 0, 0);
#endif

  /* Complete the ALU write from the previous cycle if there is one.      */
  if (COREINT.aluwrite_regM != NOWRITEVAL)
  {
    REG(COREINT.aluwrite_regM,COREINT.aluwrite_modeM) = COREINT.aluwrite_valueM;
#ifdef DB_CORE
    if ((COREINT.aluwrite_regM < 0) || (COREINT.aluwrite_regM > 14))
      error(ERROR_BADREGWRITE, COREINT.aluwrite_regM, 0);
    db_core_msg1("CORE: ALU write of",COREINT.aluwrite_valueM);
    db_core_msg1(" into register",COREINT.aluwrite_regM);
    db_core_msg1(" in mode",COREINT.aluwrite_modeM);
    db_core_msg0("\n");
#endif
  }

  /* If there is a register to write from the Rdata[] bus, do so.         */
  if (COREINT.writereg2W != NOWRITEVAL)
  {
    REG(COREINT.writereg2W, COREINT.writemodeW) = COREINT.rdata2;
#ifdef DB_CORE
    if ((COREINT.writereg2W < 0) || (COREINT.writereg2W > 14))
      error(ERROR_BADREGWRITE, COREINT.writereg2W, 0);
    db_core_msg1("CORE: LDM2 write of",COREINT.rdata2);
    db_core_msg1(" into register",COREINT.writereg2W);
    db_core_msg1(" in mode",COREINT.writemodeW);
    db_core_msg0("\n");
#endif
  }

  /* Get the instruction into a temporary variable for brevity.           */
  instr = COREINT.instrE;

  /* Set up all the default actions we will take:                         */
  CORE_PU.ForcedPrefetch = FALSE;          /* No forced prefetch          */
  COREINT.areqE          = AREQ_NONE;      /* No memory requests          */
  COREINT.rreqE          = RREQD_NONE;
  COREINT.writereg1E     = NOWRITEVAL;     /* No registers being written  */
  COREINT.writereg2E     = NOWRITEVAL;     /*  from loaded data or the    */
  COREINT.aluwrite_regE  = NOWRITEVAL;     /*  ALU result.                */
  COREINT.writemodeE     = MODE;           /* Written registers will be   */
  COREINT.aluwrite_modeE = MODE;           /*  those for the current mode */
  COREINT.writeflagsE    = 0;              /* No special actions (byte    */
                                           /*  rotations, etc.) for       */
                                           /*  loaded data.               */
  COREINT.storeM         = STORE_NOTHING;  /* Wdata doesn't need driving  */
                                           /*  phase 1 of next cycle.     */
  COREINT.newcpsrE       = CPSR;           /* No PSR changes wanted next  */
  COREINT.newspsrE       = SPSR(MODE);     /* cycle.                      */
  fwd_flags              = CPSR & FLAG_BITS;
  COREINT.newspsr_modeE  = MODE;
  COREINT.carryhold2     = COREINT.carryhold;
  COREINT.zerohold2      = COREINT.zerohold;

  /* Main ALU decode: determine where the ALU/shifter operands are to     */
  /* come from, what it is to do with them, where the result is to go,    */
  /* etc.                                                                 */
  /*   We avoid doing the work if we're interlocked, busy-waited or       */
  /* aborting: in each case, we must do nothing this cycle, and in        */
  /* particular, must *not* generate memory requests.                     */
  todo = 0;
  if (!COREINT.interlocked && !COREINT.busywaited && !COREINT.aborting)
  {
    switch (COREINT.stateE)
    {
      case S_BRANCH:
        todo = TODO_2BRCONS ^ TODO_OPADD ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_LINK:
        if (BRANCH_LBIT(instr))
        {
          todo = TODO_2FOURCONS ^ TODO_OPSUB;
          COREINT.aluwrite_regE = 14;
        }
        break;

      case S_DPGETRS:
        todo = TODO_ABUSSHIFT;
        break;

      case S_DPSHIFT:
        if (BIT(instr,4))          /* I.e. if a register-controlled shift */
          todo = TODO_2RSHIFT ^ TODO_OPMOVE;
        else
          todo = TODO_2CSHIFT ^ TODO_OPMOVE;
        break;

      case S_DPSHIFTOP1A:
      case S_DPSHIFTOP2A:
        if (BIT(instr,4))          /* I.e. if a register-controlled shift */
          todo = TODO_2RSHIFT ^ TODO_OPINS;
        else
          todo = TODO_2CSHIFT ^ TODO_OPINS;
        if (!COMPARISON(instr))
          COREINT.aluwrite_regE = IFIELD_RD(instr);
        if (DP_SBIT(instr)) todo ^= TODO_FLAGS;
        break;

      case S_DPIMMOP1A:
      case S_DPIMMOP2A:
        todo = TODO_2DPCONS ^ TODO_OPINS;
        if (!COMPARISON(instr))
          COREINT.aluwrite_regE = IFIELD_RD(instr);
        if (DP_SBIT(instr)) todo ^= TODO_FLAGS;
        break;

      case S_DPOPA:
        todo = TODO_2FEEDBACK ^ TODO_OPINS;
        if (!COMPARISON(instr))
          COREINT.aluwrite_regE = IFIELD_RD(instr);
        if (DP_SBIT(instr)) todo ^= TODO_FLAGS;
        break;

      case S_DPSHIFTOP1P:
      case S_DPSHIFTOP2P:
        if (BIT(instr,4))          /* I.e. if a register-controlled shift */
          todo ^= TODO_2RSHIFT ^ TODO_OPINS ^ TODO_DPSR;
        else
          todo ^= TODO_2CSHIFT ^ TODO_OPINS ^ TODO_DPSR;
        break;

      case S_DPIMMOP1P:
      case S_DPIMMOP2P:
        todo ^= TODO_2DPCONS ^ TODO_OPINS ^ TODO_DPSR;
        break;

      case S_DPOPP:
        todo ^= TODO_2FEEDBACK ^ TODO_OPINS ^ TODO_DPSR;
        break;

      case S_DPPREF:
      case S_SWIRETPREF:
        /* Feed back the result obtained last time, rather than           */
        /* generating it again. (Problem with generating it again: PSR    */
        /* modifications may have changed C flag or 26-bit PC operand,    */
        /* and therefore changed the result.)                             */
        todo ^= TODO_2FEEDBACK ^ TODO_OPMOVE ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_DPSHIFTOP1F:
      case S_DPSHIFTOP2F:
        if (BIT(instr,4))          /* I.e. if a register-controlled shift */
          todo ^= TODO_2RSHIFT ^ TODO_OPINS ^ TODO_DADDR;
        else
          todo ^= TODO_2CSHIFT ^ TODO_OPINS ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_DPIMMOP1F:
      case S_DPIMMOP2F:
        todo ^= TODO_2DPCONS ^ TODO_OPINS ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_DPOPF:
        todo ^= TODO_2FEEDBACK ^ TODO_OPINS ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_MRS:
        todo = TODO_OPPSR;
        if (IFIELD_RD(instr) != 0xF)   /* Just to stop aray bounds errors */
          COREINT.aluwrite_regE = IFIELD_RD(instr);
        break;

      case S_MSR:
        todo = TODO_2CSHIFT ^ TODO_OPMOVE ^ TODO_DIPSR;
        break;

      case S_MSRIMM:
        todo = TODO_2DPCONS ^ TODO_OPMOVE ^ TODO_DIPSR;
        break;

      case S_STRSHIFT:
      case S_LDRSHIFT:
        todo = TODO_2CSHIFT ^ TODO_OPMOVE;
        break;

      case S_STRNOSHIFT:
        /* Second operand is the default unshifted B bus.                 */
        todo = TODO_OPMOVE;
        break;

      /* Tricky code here to generate the right one of TODO_2LSCONS,      */
      /* TODO_2CSHIFT and TODO_2FEEDBACK and nothing.                     */
      case S_LDRIMM:
      case S_STRIMM:
        todo ^= TODO_2LSCONS ^ TODO_2FEEDBACK;
      case S_LDROP:
      case S_STROP:
        todo ^= TODO_2FEEDBACK ^ TODO_2CSHIFT;
      case S_LDRSHIFTOP:
        todo ^= TODO_2CSHIFT;
      case S_LDRNOSHIFTOP:
        /* S_LDRNOSHIFTOP has the second operand equal to the default     */
        /* unshifted B bus.                                               */

        /* If destination register is R15, we will produce a warning      */
        /* about unpredictable behaviour if the address isn't word-       */
        /* aligned.                                                       */
        if (IFIELD_RD(instr) == 0xF) todo ^= TODO_BWARN;

        /* Deal with generating the address: first, is the index positive */
        /* or negative?                                                   */
        if (DT_UBIT(instr)) todo ^= TODO_OPADD; else todo ^= TODO_OPSUB;

        /* And deal with the differences between pre-indexed, pre-indexed */
        /* with writeback and post-indexed addressing.                    */
        if (DT_PBIT(instr))
        {
          todo ^= TODO_DADDR;
          if (DT_WBIT(instr))
          {
            if (IFIELD_RN(instr) != 0xF)   /* Prevent array bounds errors */
              COREINT.aluwrite_regE = IFIELD_RN(instr);
          }
        }
        else
        {
          todo ^= TODO_ABUSADDR;
          if (IFIELD_RN(instr) != 0xF)     /* Prevent array bounds errors */
            COREINT.aluwrite_regE = IFIELD_RN(instr);
        }

        /* Record the base register, its mode and its value, in case of a */
        /* data abort and thus the need to restore it.                    */
        COREINT.base_regE   = IFIELD_RN(instr);
        COREINT.base_modeE  = MODE;
        COREINT.base_valueE = COREINT.abus;

        /* Now split into loads and stores. First loads:                  */
        if (DT_LBIT(instr))
        {
          todo ^= TODO_BROT;
          if (DT_WnotHBIT(instr))
          {
            if (DT_BBIT(instr))
            {
              COREINT.areqE       = AREQ_LOAD_B;
              COREINT.writeflagsE |= WFLAG_BYTE;
              if (ARM8_EXT.BigEnd) COREINT.writeflagsE |= 3;
            }
            else
              COREINT.areqE       = AREQ_LOAD;
          }
          else
          {
            if (DTH_HBIT(instr))
            {
              COREINT.areqE       = AREQ_LOAD_H;
              COREINT.writeflagsE |= WFLAG_HALFWORD;
              if (ARM8_EXT.BigEnd) COREINT.writeflagsE |= 2;
            }
            else
            {
              COREINT.areqE       = AREQ_LOAD_B;
              COREINT.writeflagsE |= WFLAG_BYTE;
              if (ARM8_EXT.BigEnd) COREINT.writeflagsE |= 3;
            }
            if (DTH_SBIT(instr))
              COREINT.writeflagsE |= WFLAG_SIGNED;
          }

          COREINT.rreqE        = RREQD_ONE;
          COREINT.writeflagsE |= WFLAG_LATCH;
          if (IFIELD_RD(instr) == 0xF)
            COREINT.writeflagsE |= WFLAG_TOBBUS;
          else
            COREINT.writereg1E = IFIELD_RD(instr);
        }

        /* Now stores:                                                    */
        else
        {
          COREINT.storeM = STORE_VALUE;
          COREINT.storevalueM = COREINT.bbus;
          if (DT_WnotHBIT(instr))
          {
            if (DT_BBIT(instr))
            {
              todo ^= TODO_BDUP;
              COREINT.areqE = AREQ_STORE_B;
            }
            else
              COREINT.areqE = AREQ_STORE;
          }
          else
          {
            /* NB: must be STRH, since STRSH and STRSB don't exist.       */
            todo ^= TODO_HDUP;
            COREINT.areqE = AREQ_STORE_H;
          }
        }
        break;

      case S_LDRPREF:
      case S_LDMPREF:
        /* Second operand is the default B bus, where the loaded PC value */
        /* was placed at the start of the cycle.                          */
        todo                   = TODO_OPMOVE ^ TODO_DADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_STMINIT:
        /* Work out what to do. Note that most of the work required is    */
        /* concealed in the "TODO_STM" bit, including generation of the   */
        /* correct second operand for the addition/subtraction.           */
        todo = TODO_STM;

        /* Deal with the difference between a positive and a negative     */
        /* offset.                                                        */
        if (DT_UBIT(instr))
          todo ^= TODO_OPADD;
        else
          todo ^= TODO_OPSUB;

        /* Deal with writeback.                                           */
        if (DT_WBIT(instr))
        {
          if (IFIELD_RN(instr) != 0xF)     /* Prevent array bounds errors */
            COREINT.aluwrite_regE = IFIELD_RN(instr);
        }

        /* Record the base register, its mode and its value, in case of a */
        /* data abort and thus the need to restore it.                    */
        COREINT.base_regE   = IFIELD_RN(instr);
        COREINT.base_modeE  = MODE;
        COREINT.base_valueE = COREINT.abus;

        /* The first request will always be a single word store of the    */
        /* value that will be put on the B bus, with the "more to come"   */
        /* hint if there are at least two registers to store.             */
        COREINT.areqE  = (COREINT.ma_reg4 != NOWRITEVAL)
                         ? AREQ_STORE_M : AREQ_STORE;
        COREINT.storeM = STORE_BBUS;
        break;

      case S_STM:
        /* The "todo" list is simply to do all the work for an STM cycle! */
        todo = TODO_STM;

        /* The request is a sequential single word store unless we don't  */
        /* have a register to store - this only happens on a single       */
        /* register STM. We also need the "more to come" hint if there is */
        /* another register after this one.                               */
        if (COREINT.ma_reg3 != NOWRITEVAL)
        {
          COREINT.areqE  = (COREINT.ma_reg4 != NOWRITEVAL)
                           ? AREQ_STORE_SM : AREQ_STORE_S;
          COREINT.storeM = STORE_VALUE; /* NB: COREINT.storevalueM will   */
        }                               /* be set by TODO_STM code below. */
        break;

      case S_LDMINIT:
        /* Work out what to do. Note that most of the work required is    */
        /* concealed in the "TODO_LDM" bit, including generation of the   */
        /* correct second operand for the addition/subtraction.           */
        todo = TODO_LDM;

        /* Deal with the difference between a positive and a negative     */
        /* offset.                                                        */
        if (DT_UBIT(instr))
          todo ^= TODO_OPADD;
        else
          todo ^= TODO_OPSUB;

        /* Deal with writeback.                                           */
        if (DT_WBIT(instr))
        {
          if (IFIELD_RN(instr) != 0xF)     /* Prevent array bounds errors */
            COREINT.aluwrite_regE = IFIELD_RN(instr);
        }

        /* Record the base register, its mode and its value, in case of a */
        /* data abort and thus the need to restore it.                    */
        COREINT.base_regE   = IFIELD_RN(instr);
        COREINT.base_modeE  = MODE;
        COREINT.base_valueE = COREINT.abus;

        /* The first request is a suitable load. If there are two         */
        /* ordinary registers to be loaded in the priority encoder, we    */
        /* try to load them; if there is just one, we try to load it; if  */
        /* there are none, this must be an LDM of R15 only.               */
        COREINT.ma_doingR15 = (COREINT.ma_reg3 == NOWRITEVAL);
        if (COREINT.ma_doingR15)
        {
          COREINT.areqE       = AREQ_LOAD;
          COREINT.rreqE       = RREQD_ONE;
          COREINT.writeflagsE |= WFLAG_TOBBUS | WFLAG_LATCH;
          if (DTM_SBIT(instr))
            COREINT.writeflagsE |= WFLAG_SETPSR;
        }
        else
        {
          COREINT.writeflagsE |= WFLAG_LATCH;
          COREINT.writereg1E   = COREINT.ma_reg3;

          /* Cater for user bank LDMs by recording the mode of the        */
          /* registers to be written.                                     */
          COREINT.writemodeE = (DTM_SBIT(instr) && !BIT(instr,15))
                               ? MODE_USER32
                               : MODE;

          if (COREINT.ma_reg4 == NOWRITEVAL)
          {
            COREINT.areqE       = BIT(instr,15)
                                  ? AREQ_LOAD_M : AREQ_LOAD;
            COREINT.rreqE       = RREQD_ONE;
          }
          else
          {
            COREINT.areqE       = (COREINT.ma_more || BIT(instr,15))
                                  ? AREQ_LOAD_M : AREQ_LOAD;
            COREINT.rreqE       = RREQD_TWO;
            COREINT.writereg2E  = COREINT.ma_reg4;
          }
        }
        break;

      case S_LDM:
        /* The "todo" list is simply to do all the work for a standard    */
        /* LDM cycle (plus generating the second ALU operand for the      */
        /* address calculation, which isn't actually needed on a          */
        /* non-LDMINIT cycle, but is harmless and saves having a separate */
        /* "todo" fit for that purpose).                                  */
        todo = TODO_LDM;

        /* If R15 is not in the register list, we would ideally like the  */
        /* decision about whether this is the last cycle of the           */
        /* instruction to depend on whether we've got <2 or >=2 registers */
        /* still to be written. This depends on whether we're managing to */
        /* load two registers or just one this cycle. I.e. if we've got   */
        /* the RRESP_DATA1 response, we would like to look at whether     */
        /* COREINT.ma_reg3 is NOWRITEVAL; if we've got the RRESP_DATA2    */
        /* response, we would like to look at whether COREINT.ma_reg4 is  */
        /* NOWRITEVAL.                                                    */
        /*   Unfortunately, this is believed to lead to an excessively    */
        /* long control path on the real chip: newinstr would be          */
        /* generated too late if we have to wait to see what              */
        /* ARM8_MEM.RResponse is. So what we actually do is make the      */
        /* pessimistic assumption that we will only load 1 word; if this  */
        /* will lead to <2 register writes still being needed, this is    */
        /* the last cycle.                                                */
        /*   The drawback of this is that there will be a wasted extra    */
        /* cycle at the end of an LDM whenever (a) we get into a          */
        /* situation where 3 registers still need to be written, and      */
        /* (b) we ask the memory for two words and get both of them.      */
        /* (a) will occur on about half of all LDMs; (b) will sometimes   */
        /* not happen. So the overall impact on the LDM CPI should be a   */
        /* cost of somewhat less than 0.5.                                */
        /*                                                                */
        /* If R15 is in the register list, this is never the last cycle   */
        /* of the instruction.                                            */

        if (BIT(instr,15))
          COREINT.newinstr = FALSE;
        else
          COREINT.newinstr = (COREINT.ma_reg3 == NOWRITEVAL);

        /* Determine the next pair of registers to do, based on the       */
        /* memory response. (Note that the second case only matters when  */
        /* the response is RRESP_DATA1: other cases can happen, but are   */
        /* always associated with an abort, an NConfirmed cycle, or       */
        /* something similar.                                             */
        if (ARM8_MEM.RResponse == RRESP_DATA2)
        {
          COREINT.writereg1E = COREINT.ma_reg3;
          COREINT.writereg2E = COREINT.ma_reg4;
          moretocome         = COREINT.ma_more;
        }
        else
        {
          COREINT.writereg1E = COREINT.ma_reg2;
          COREINT.writereg2E = COREINT.ma_reg3;
          moretocome         = (COREINT.ma_reg4 != NOWRITEVAL);
        }

        /* Produce the request for one or two more words, or don't        */
        /* produce a request, depending on how many registers we still    */
        /* have to do and whether we need to load R15.                    */
        /*   Note that we will never get into state S_LDM when            */
        /* COREINT.ma_doingR15 is TRUE, so we only need to change its     */
        /* value if we are issuing the R15 load this time.                */

        if (COREINT.writereg1E != NOWRITEVAL)
        {
          COREINT.writeflagsE |= WFLAG_LATCH;
          if (COREINT.writereg2E != NOWRITEVAL)
          {
            COREINT.rreqE = RREQD_TWO;
            if (ARM8_MEM.DExhausted)
              COREINT.areqE = (moretocome || BIT(instr,15))
                              ? AREQ_LOAD_SM : AREQ_LOAD_S;
          }
          else
          {
            COREINT.rreqE = RREQD_ONE;
            if (ARM8_MEM.DExhausted)
              COREINT.areqE = BIT(instr,15)
                              ? AREQ_LOAD_SM : AREQ_LOAD_S;
          }
        }
        else if (BIT(instr,15))
        {
          COREINT.rreqE       = RREQD_ONE;
          COREINT.ma_doingR15 = TRUE;
          COREINT.writeflagsE |= WFLAG_TOBBUS | WFLAG_LATCH;
          if (DTM_SBIT(instr))
            COREINT.writeflagsE |= WFLAG_SETPSR;

          if (ARM8_MEM.DExhausted)
            COREINT.areqE = AREQ_LOAD_S;
        }

        /* Cater for user bank LDMs by recording the mode of the          */
        /* registers to be written.                                       */
        COREINT.writemodeE = (DTM_SBIT(instr) && !BIT(instr,15))
                             ? MODE_USER32
                             : MODE;

        break;

      case S_MULTERM1:
        /* Second operand is the default unshifted B bus. */
        todo = TODO_OPADC;
        COREINT.carryhold2 = COREINT.carryhold = (COREINT.mulc != 0);
        COREINT.zerohold2  = COREINT.zerohold  = 1;
        if (MUL_LBIT(instr))
        {
          if (IFIELD_RD(instr) != 0xF) /* Just to stop array bounds errors */
            COREINT.aluwrite_regE = IFIELD_RD(instr);
        }
        else
        {
          if (IFIELD_RN(instr) != 0xF) /* Just to stop array bounds errors */
            COREINT.aluwrite_regE = IFIELD_RN(instr);
          if (MUL_SBIT(instr))
            todo ^= TODO_FLAGS;
        }
        break;

      case S_MULTERM2:
        /* Second operand is the default unshifted B bus. */
        todo = TODO_OPADC;
        if (IFIELD_RN(instr) != 0xF)  /* Just to stop array bounds errors */
          COREINT.aluwrite_regE = IFIELD_RN(instr);
        if (MUL_SBIT(instr))
          todo ^= TODO_FLAGS;
        break;

      case S_SWPLOAD:
        todo = TODO_ABUSADDR ^ TODO_BROT;

        /* Record the base register, its mode and its value, in case of a */
        /* data abort and thus the need to restore it.                    */
        COREINT.base_regE   = IFIELD_RN(instr);
        COREINT.base_modeE  = MODE;
        COREINT.base_valueE = COREINT.abus;

        if (DT_BBIT(instr))
        {
          COREINT.areqE       = AREQ_LOAD_BX;
          COREINT.writeflagsE |= WFLAG_BYTE;
          if (ARM8_EXT.BigEnd) COREINT.writeflagsE |= 3;
        }
        else
          COREINT.areqE       = AREQ_LOAD_X;

        COREINT.rreqE = RREQD_ONE;

        /* We will latch the value that comes back from memory, but       */
        /* *not* indicate that it should be written to its destination    */
        /* register: this is put off until the SWPSTORE cycle in order    */
        /* to make certain that we haven't done anything irrevocable.     */
        COREINT.writeflagsE |= WFLAG_LATCH;

        break;

      case S_SWPSTORE:
        todo = TODO_ABUSADDR;

        COREINT.storeM = STORE_VALUE;
        COREINT.storevalueM = COREINT.bbus;

        if (DT_BBIT(instr))
        {
          todo ^= TODO_BDUP;
          COREINT.areqE = AREQ_STORE_BX;
        }
        else
          COREINT.areqE = AREQ_STORE_X;

        /* And do the put-off register write from the SWPLOAD cycle.      */
        if (IFIELD_RD(instr) != 0xF)  /* Just to stop array bounds errors */
          COREINT.writereg1E   = IFIELD_RD(instr);

        break;

      case S_MRC:
        todo = TODO_OPCDATA;
        if (IFIELD_RD(instr) == 0xF)
          todo ^= TODO_DFLAGS;
        else
          COREINT.aluwrite_regE = IFIELD_RD(instr);
        break;

      case S_MCR:
        /* Second operand is default unshifted B bus.                     */
        todo = TODO_OPMOVE ^ TODO_DADDR;
        COREINT.areqE = AREQ_CONTROL;
        break;

      case S_EXCPSR:
      case S_UNDEFPSR:
        todo = TODO_EXCPSR;
        break;

      case S_EXCPREF:
      case S_UNDEFPREF:
        todo                   = TODO_EXCADDR;
        CORE_PU.ForcedPrefetch = TRUE;
        COREINT.areqE          = AREQ_FETCH;
        break;

      case S_EXCRADDR:
      case S_UNDEFRADDR:
        switch (COREINT.excaddress)
        {
          case VECTOR_SWI:
          case VECTOR_UNDEF:
          case VECTOR_PABORT:
            todo = TODO_2FOURCONS ^ TODO_OPSUB;
            break;

          case VECTOR_DABORT:
            todo = TODO_2ZEROCONS ^ TODO_OPADD;
            break;

          case VECTOR_RESET:
          case VECTOR_IRQ:
          case VECTOR_FIQ:
            /* Need to generate correct return address plus 4. On the     */
            /* other hand, the interrupt sequence point which has just    */
            /* been put on the A and B buses may be 4 too big already!    */
            if (COREINT.intseqpt_sub4)
              todo = TODO_2ZEROCONS ^ TODO_OPADD;
            else
              todo = TODO_2FOURCONS ^ TODO_OPADD;
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, COREINT.excaddress, 22);
            break;
#endif
        }
        COREINT.aluwrite_regE = 14;
        break;

      case S_SWISETTLE:
        /* Construct initial SWI interception data structure, then ask    */
        /* the SWI interceptor what to do and do it just as though we     */
        /* were in the S_SWIMEM2 state.                                   */
        /*   Note that by this point, all registers have been updated for */
        /* the SWI entry sequence, so we can simply take copies of their  */
        /* values without looking for forwardings. (The last register to  */
        /* have been updated is R14_svc, at the start of this routine.)   */
        COREINT.core_swis.SWINumber = BITS(instr,0,23);
        COREINT.core_swis.Status    = SWISTATUS_NEW;
        COREINT.core_swis.Spsr      = SPSR(MODE_SVC32);
        for (i=0; i<15; i++)
          COREINT.core_swis.Regs[i] = REG(i, MODE_SVC32);
        /* Deliberate fall through to S_SWIMEM2 case.                     */

      case S_SWIMEM2:
        /* Ask the SWI interceptor what to do next.                       */
        armul8swis_process(&COREINT.core_swis, state->sim_info->cmdline2);

        /* Issue the appropriate requests.                                */
        switch (COREINT.core_swis.Request)
        {
          case SWIREQUEST_STR:
            COREINT.areqE       = AREQ_STORE;
            ARM8_MEM.VAddress   = COREINT.core_swis.Address;
            COREINT.storeM      = STORE_VALUE;
            COREINT.storevalueM = COREINT.core_swis.Data;
#ifdef DB_CORE
            db_core_msg1("CORE: VAddress value written in ph2:",
                         COREINT.core_swis.Address);
            db_core_msg0("\n");
#endif
            break;

          case SWIREQUEST_LDR:
            COREINT.areqE       = AREQ_LOAD;
            COREINT.rreqE       = RREQD_ONE;
            ARM8_MEM.VAddress   = COREINT.core_swis.Address;
#ifdef DB_CORE
            db_core_msg1("CORE: VAddress value written in ph2:",
                         COREINT.core_swis.Address);
            db_core_msg0("\n");
#endif
            break;

          case SWIREQUEST_STRB:
            COREINT.areqE       = AREQ_STORE_B;
            ARM8_MEM.VAddress   = COREINT.core_swis.Address;
            COREINT.storeM      = STORE_VALUE;
            COREINT.storevalueM = COREINT.core_swis.Data;
            todo ^= TODO_BDUP;
#ifdef DB_CORE
            db_core_msg1("CORE: VAddress value written in ph2:",
                         COREINT.core_swis.Address);
            db_core_msg0("\n");
#endif
            break;

          case SWIREQUEST_LDRB:
            COREINT.areqE       = AREQ_LOAD_B;
            COREINT.rreqE       = RREQD_ONE;
            ARM8_MEM.VAddress   = COREINT.core_swis.Address;
#ifdef DB_CORE
            db_core_msg1("CORE: VAddress value written in ph2:",
                         COREINT.core_swis.Address);
            db_core_msg0("\n");
#endif
            break;

          case SWIREQUEST_END:
          case SWIREQUEST_NOCPSRUPDATE:
          case SWIREQUEST_HALT:
            /* Transfer SPSR and flags back to their true places before   */
            /* next cycle wants to read them (later in this routine).     */
            SPSR(MODE_SVC32)    = COREINT.core_swis.Spsr;
            for (i=0; i<15; i++)
              REG(i,MODE_SVC32) = COREINT.core_swis.Regs[i];
            break;

          default:
            /* Do nothing for other requests.                             */
            break;
        }
        break;

      case S_SWIRETPSR:
        /* Update the CPSR unless we've been asked not to. Second operand */
        /* is default unshifted B bus.                                    */
        if (COREINT.core_swis.Request != SWIREQUEST_NOCPSRUPDATE)
          todo ^= TODO_OPMOVE ^ TODO_DPSR;
        break;

      case S_SWIRETHALT:
        /* Stop after this cycle if requested by the SWI interceptor.     */
        if (COREINT.core_swis.Request == SWIREQUEST_HALT)
          set_sim_state(COMM,state->sim_info);
        break;

      default:
        /* Not an error - quite a number of states don't do anything in   */
        /* armul8, just being there to keep the cycle counts right. E.g.  */
        /* the PSR settling states don't actually do anything in the      */
        /* Execute stage - they just let various chip state settle.       */
        break;
    }
  }

  /* Signal the requests. Note that this assumes (a) that control of      */
  /* 'ARequest' is arbitrated by means of 'AddressInUse', but the PU      */
  /* claims control back if it successfully cancels an instruction in the */
  /* Execute stage (note that the PU always had control if the            */
  /* instruction was cancelled at some earlier point); (b) that the Core  */
  /* has exclusive use of 'RRequestD' and 'NRRequestIC'.                  */
  /*   Note that CORE_PU.NewInstr is used rather than COREINT.newinstr -  */
  /* they can differ, with the former being TRUE and the latter FALSE, if */
  /* NConfirm, data abort, IRQ or FIQ occurs just before what would have  */
  /* been the first cycle of an instruction. This is in order to          */
  /* precisely match the conditions under which the PU attempts to drive  */
  /* the bus. Also note that although CORE_PU.NewInstr changes in this    */
  /* phase, it is legitimate to use it here rather than using a delayed   */
  /* version of it because it is only changed by this routine itself, at  */
  /* a later point than this one.                                         */

  ARM8_MEM.RRequestD   = COREINT.rreqE;
  ARM8_MEM.NRRequestIC = !CORE_PU.ForcedPrefetch;
  if (CORE_PU.AddressInUse && !(CORE_PU.CancelE && CORE_PU.NewInstr))
  {
    ARM8_MEM.ARequest = COREINT.areqE;
#ifdef DB_CORE
    db_core_msg1("CORE: ARequest issued in ph2:", COREINT.areqE);
    db_core_msg0("\n");
#endif
  }

  /* Also signal whether this is a privileged mode request. This just     */
  /* uses the standard test on the current mode, except when we're        */
  /* executing an LDRT or STRT.                                           */
  switch (COREINT.stateE)
  {
    case S_LDRSHIFTOP:
    /* No point in having "case S_LDRNOSHIFTOP:" here. */
    case S_LDROP:
    case S_STROP:
    case S_LDRIMM:
    case S_STRIMM:
      /* Note that the instructions one might think of as LDRHT, LDRSBT,  */
      /* etc., don't ever get here: they are filtered out at the decode   */
      /* stage. So we can happily use the simple rule "post-indexed AND W */
      /* bit set" to detect the unprivileged LDRs and STRs.               */
      ARM8_MEM.Privileged = (DT_PBIT(instr) || !DT_WBIT(instr)) && PRIVILEGED;
      break;

    default:
      ARM8_MEM.Privileged = PRIVILEGED;
      break;
  }

  /* And signal whether it is a 26-bit request.                           */
  ARM8_MEM.TwentySixBit = !MODE32(CPSR);

  /* Now do the shifter/ALU work. Note that the test here whether there   */
  /* is any work to do is not just for efficiency: it also stops things   */
  /* like the ALU feedback value being updated on an interlocked cycle,   */
  /* which can be important for some second cycle interlocks.             */
  if (todo != 0)
  {
    /* Get default unchanged values for C and V flags */
    newc     = (CBIT(CPSR) != 0);
    newv     = (VBIT(CPSR) != 0);

    /* Get first operand: easy, since it's always on the A bus if it      */
    /* exists at all. Also get the B bus as the default second operand -  */
    /* this will be modified or overridden below in most cases.           */
    operand1 = COREINT.abus;
    operand2 = COREINT.bbus;

    /* Get second operand */
    if (todo & TODO_2CSHIFT)              /* As B bus shifted by constant */
      shift(BITS(instr,5,6), BITS(instr,7,11), &operand2, &newc, TRUE);
    if (todo & TODO_2RSHIFT)              /* As B bus shifted by register */
      shift(BITS(instr,5,6), COREINT.shiftval, &operand2, &newc, FALSE);
    if (todo & TODO_2DPCONS)            /* As a data processing immediate */
    {
      operand2 = BITS(instr,0,7);
      shift(SHIFT_ROR_RRX, 2*BITS(instr,8,11), &operand2, &newc, FALSE);
    }
    if (todo & TODO_2BRCONS)                     /* As a branch immediate */
    {
      operand2 = BITS(instr,0,23) << 2;
      if (BIT(operand2,25)) operand2 |= (unsigned32) 0xFC000000;
    }
    if (todo & TODO_2LSCONS)                   /* An an LDR/STR immediate */
    {
      if (DT_WnotHBIT(instr))
        operand2 = BITS(instr,0,11);
      else
        operand2 = BITS(instr,0,3) | (BITS(instr,8,11) << 4);
    }
    if (todo & TODO_2CPCONS)                   /* An as LDC/STC immediate */
      operand2 = BITS(instr,0,7) << 2;
    if (todo & TODO_2ZEROCONS)                         /* As a constant 0 */
      operand2 = (unsigned32) 0x00000000;
    if (todo & TODO_2FOURCONS)                         /* As a constant 4 */
      operand2 = (unsigned32) 0x00000004;
    if (todo & TODO_2FEEDBACK)             /* As the feedback latch value */
      operand2 = COREINT.feedback;
    if (todo & (TODO_STM | TODO_LDM))             /* From registers count */
      operand2 = bitcount(BITS(instr,0,15)) << 2; /* in an LDM/STM        */

    /* Do the ALU operation. */
    if (todo & TODO_OPINS)         /* Specified by instruction bits 24:21 */
      result = aluop(operand1, operand2, (CBIT(CPSR) != 0),
                     IFIELD_DPOP(instr), &newc, &newv);
    if (todo & TODO_OPADD)                           /* A forced addition */
      result = aluop(operand1, operand2, 0, ALUOP_ADD, &newc, &newv);
    if (todo & TODO_OPADC)                     /* A forced add-with-carry */
      result = aluop(operand1, operand2, COREINT.carryhold,
                     ALUOP_ADC, &newc, &newv);
    if (todo & TODO_OPSUB)                        /* A forced subtraction */
      result = aluop(operand1, operand2, 0, ALUOP_SUB, &newc, &newv);
    if (todo & TODO_OPMOVE)                              /* A forced move */
      result = operand2;
    if (todo & TODO_OPPSR)               /* Get instruction-specified PSR */
      result = PSRXFER_SBIT(instr) ? SPSR(MODE) : CPSR;
    if (todo & TODO_OPCDATA)                         /* Get CData[] value */
      result = ARM8_COPROC.CData;

#ifdef DB_CORE
    if (todo & (TODO_OPINS | TODO_OPADD | TODO_OPADC | TODO_OPSUB | TODO_OPMOVE))
    {
      db_core_msg1("CORE: ALU op with op1 =",operand1);
      db_core_msg1(", op2 =",operand2);
      db_core_msg1(", result =",result);
      db_core_msg0("\n");
    }
#endif

    /* Determine the result flags, doing special actions for multiplies   */
    /* if necessary.                                                      */
    if (todo & TODO_OPADC)
    {
      COREINT.carryhold2 = (newc != 0);
      COREINT.zerohold2  = COREINT.zerohold && (result == 0);
      flags =   (COREINT.zerohold2 ? Z_BIT : (unsigned32) 0)
              | (newc              ? C_BIT : (unsigned32) 0)
              | (newv              ? V_BIT : (unsigned32) 0)
              | NBIT(result);
    }
    else
      flags =   ((result == 0) ? Z_BIT : (unsigned32) 0)
              | (newc          ? C_BIT : (unsigned32) 0)
              | (newv          ? V_BIT : (unsigned32) 0)
              | NBIT(result);

    /* Write flags if required. */
    if (todo & TODO_FLAGS)
    {
      COREINT.newcpsrE &= ~FLAG_BITS;
      COREINT.newcpsrE |= flags;
      fwd_flags        =  flags;
    }

    /* Do exception entry PSR manipulations if required. */

    if (todo & TODO_EXCPSR)
    {
      switch (COREINT.excaddress)
      {
        case VECTOR_RESET:
        case VECTOR_SWI:
#ifdef RISCOS_EMU
          COREINT.newspsr_modeE = MODE_SVC26;
#else
          COREINT.newspsr_modeE = MODE_SVC32;
#endif
          break;

        case VECTOR_UNDEF:
          COREINT.newspsr_modeE = MODE_UNDEF32;
          break;

        case VECTOR_PABORT:
        case VECTOR_DABORT:
          COREINT.newspsr_modeE = MODE_ABORT32;
          break;

        case VECTOR_IRQ:
          COREINT.newspsr_modeE = MODE_IRQ32;
          break;

        case VECTOR_FIQ:
          COREINT.newspsr_modeE = MODE_FIQ32;
          break;

#ifdef DB_CORE
        default:
          error(ERROR_UNCOVEREDCASE, COREINT.excaddress, 23);
          break;
#endif
      }
      COREINT.newspsrE = CPSR;
      COREINT.newcpsrE =
        (CPSR & ~MODE_BITS) | I_BIT | COREINT.newspsr_modeE;
      if ((COREINT.excaddress == VECTOR_FIQ)
          || (COREINT.excaddress == VECTOR_RESET))
        COREINT.newcpsrE |= F_BIT;
    }

    /* The result is the ALU value to write back to a register if such a  */
    /* write will occur (i.e. if COREINT.aluwrite_regE != NOWRITEVAL).    */
    /*   We also always write the result into the "ALU feedback latch"    */
    /* (as noted above, this is automatically avoided on an interlocked   */
    /* cycle because todo = 0 on such a cycle).                           */

    COREINT.aluwrite_valueE = COREINT.feedback = result;

    /* Write result to other registers, buses and latches as required.    */

    if (todo & TODO_DPSR)            /* To the CPSR in 26-bit modes or    */
    {                                /* move SPSR to CPSR in 32-bit modes */
      if (MODE32(CPSR))
      {
        /* DON'T set 'fwd_flags' here, for compatibility with VHDL model  */
        COREINT.newcpsrE = SPSR(MODE);         /* Will be CPSR->CPSR copy */
                                               /* in user/system mode     */
      }
      else
      {
        fwd_flags = result & FLAG_BITS;
        if (PRIVILEGED)
          COREINT.newcpsrE = (CPSR & ~(FLAG_BITS | MASK_BITS | MODE26_BITS))
                             | (result & (FLAG_BITS | MODE26_BITS))
                             | ((result >> MASK26MOVE) & MASK_BITS);
        else
          COREINT.newcpsrE = (CPSR & ~FLAG_BITS) | fwd_flags;
      }
    }

    if (todo & TODO_DFLAGS)               /* Bits 31:28 to the flags only */
    {
      fwd_flags = result & FLAG_BITS;
      COREINT.newcpsrE = (CPSR & ~FLAG_BITS) | fwd_flags;
    }

    if (todo & TODO_DIPSR)            /* To the instruction-specified PSR */
    {
      if (PSRXFER_SBIT(instr))
      {
        if (PSRXFER_CTLBIT(instr) && PRIVILEGED)
        {
          COREINT.newspsrE &= ~CTL_BITS;
          COREINT.newspsrE |= (result & CTL_BITS);
        }
        if (PSRXFER_FLGBIT(instr))
        {
          COREINT.newspsrE &= ~FLAG_BITS;
          COREINT.newspsrE |= (result & FLAG_BITS);
        }
        if (!GoodMode[MODEBITS(COREINT.newspsrE)])
          unpredictable(COREINT.unpredbuffer,
                        instr, UNPRED_BADMODE, MODEBITS(COREINT.newspsrE));
      }
      else
      {
        if (PSRXFER_CTLBIT(instr) && PRIVILEGED)
        {
          COREINT.newcpsrE &= ~CTL_BITS;
          COREINT.newcpsrE |= (result & CTL_BITS);
        }
        if (PSRXFER_FLGBIT(instr))
        {
          fwd_flags = result & FLAG_BITS;
          COREINT.newcpsrE &= ~FLAG_BITS;
          COREINT.newcpsrE |= fwd_flags;
        }
        if (!GoodMode[MODEBITS(COREINT.newcpsrE)])
          unpredictable(COREINT.unpredbuffer,
                        instr, UNPRED_BADMODE, MODEBITS(COREINT.newcpsrE));
      }
    }

    if (todo & TODO_DADDR)                          /* To the address bus */
      address = result;                 /* More done below in common code */

    /* Write exception address to registers, buses and latches as         */
    /* required.                                                          */

    if (todo & TODO_EXCADDR)                        /* To the address bus */
      address = COREINT.excaddress;     /* More done below in common code */

    /* Write A bus value to registers, buses and latches as required.     */

    if (todo & TODO_ABUSADDR)                       /* To the address bus */
      address = COREINT.abus;           /* More done below in common code */
    if (todo & TODO_ABUSSHIFT)                /* To the shift value latch */
      COREINT.shiftval = COREINT.abus & 0xFF;

    /* Some common code for all writes to the address bus, except those   */
    /* for LDM and STM.                                                   */

    if (todo & (TODO_DADDR | TODO_ABUSADDR | TODO_EXCADDR))
    {
      /* Mask out non-PC bits if this is a forced prefetch.               */
      if (COREINT.areqE == AREQ_FETCH)
      {
        if (MODE32(CPSR))
          address &= PC32_BITS;
        else
          address &= PC26_BITS;
      }

      /* And actually put the address on the bus.                         */
      ARM8_MEM.VAddress = address;

      /* If this is a forced prefetch, record the change to the new       */
      /* interrupt sequence point.                                        */
      if (CORE_PU.ForcedPrefetch)
      {
        COREINT.newintseqpt_base = address;
        COREINT.newintseqpt_sub4 = FALSE;
      }

#ifdef DB_CORE
      db_core_msg1("CORE: VAddress value written in ph2:",address);
      db_core_msg0("\n");
#endif
    }

    /* Do things associated with byte loads and stores. First thing is to */
    /* save the byte rotation amount - i.e. the bottom two bits of the    */
    /* address, exclusive-ORed with 3 if this is a bige-endian byte load, */
    /* with 2 if it is a big-endian halfword load and left unchanged      */
    /* otherwise. Previous code has already put the appropriate one of 0, */
    /* 2 or 3 into the bottom two bits of COREINT.writeflagsE, so all we  */
    /* have to do now is exclusive-OR in the bottom two bits of the       */
    /* address.                                                           */
    if (todo & TODO_BROT)
      COREINT.writeflagsE ^= (address & WFLAG_BOFFSET);

    /* Then do a byte- or halfword-duplication if needed.                 */
    if (todo & TODO_BDUP)
    {
      COREINT.storevalueM &= 0xFF;
      COREINT.storevalueM |= COREINT.storevalueM << 8;
      COREINT.storevalueM |= COREINT.storevalueM << 16;
    }
    if (todo & TODO_HDUP)
    {
      COREINT.storevalueM &= 0xFFFF;
      COREINT.storevalueM |= COREINT.storevalueM << 16;
    }

    /* Issue warnings about bad addresses:                                */
    /*   A. Load or store of PC from non-word-aligned address.            */
    if ((todo & TODO_BWARN) && (address & 0x03))
      unpredictable(COREINT.unpredbuffer,
                    instr, UNPRED_UNALIGNEDR15, address);
    /*   B. LDRH/LDRSH/STRH with non-halfword-aligned address.            */
    if (((COREINT.writeflagsE & WFLAG_HALFWORD)      /* (If an LDRH/LDRSH */
         || (todo & TODO_HDUP))                      /* OR an STRH)       */
        && (address & 1))                            /* and not aligned   */
      unpredictable(COREINT.unpredbuffer,
                    instr, UNPRED_UNALIGNEDHW, address);

    /* Do special stuff for STM if required. */
    if (todo & TODO_STM)
    {
      /* If start of STM, generate its starting address. If not, produce  */
      /* an incremented provisional updated address.                      */
      if (COREINT.stateE == S_STMINIT)
      {
        switch (BITS(instr,23,24))
        {
          case 0x0:     /* DA/ED variant */
            COREINT.ma_newaddress = result + 4;
            break;

          case 0x1:     /* IA/EA variant */
            COREINT.ma_newaddress = operand1;
            break;

          case 0x2:     /* DB/FD variant */
            COREINT.ma_newaddress = result;
            break;

          case 0x3:     /* IB/FA variant */
            COREINT.ma_newaddress = operand1 + 4;
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, BITS(instr,23,24), 24);
            break;
#endif
        }
      }
      else
        COREINT.ma_newaddress = COREINT.ma_address + 4;

      /* Now generate the correct address/data on the bus, depending on   */
      /* what type of request we're generating. Also, determine whether   */
      /* this is the last cycle of the STM and put this information into  */
      /* COREINT.newinstr.                                                */

      /* The address is simply the one we've just calculated.             */

      ARM8_MEM.VAddress = COREINT.ma_newaddress;
#ifdef DB_CORE
      db_core_msg1("CORE: VAddress value written in ph2:",
                   COREINT.ma_newaddress);
      db_core_msg0("\n");
#endif

      /* The data is the A bus value that was read last cycle for this    */
      /* pipeline use. Note that this isn't actually true of the STMINIT  */
      /* cycle, but that cycle uses the STORE_BBUS mechanism and so       */
      /* doesn't use the value of COREINT.storevalueM we create here.     */

      COREINT.storevalueM = COREINT.abus;

      /* We're terminating this cycle if there are no more registers to   */
      /* read *and* we're in the STM loop state (to ensure all register   */
      /* reads wanted actually occur for a 1 register STM).               */

      COREINT.newinstr =
        (COREINT.stateE == S_STM) && (COREINT.ma_reg4 == NOWRITEVAL);
    }

    /* Do special stuff for LDM if required. */
    if (todo & TODO_LDM)
    {
      /* If start of LDM, generate its starting address. If not, produce  */
      /* a provisional updated address based on the memory response.      */
      if (COREINT.stateE == S_LDMINIT)
      {
        switch (BITS(instr,23,24))
        {
          case 0x0:     /* DA/FA variant */
            COREINT.ma_newaddress = result + 4;
            break;

          case 0x1:     /* IA/FD variant */
            COREINT.ma_newaddress = operand1;
            break;

          case 0x2:     /* DB/EA variant */
            COREINT.ma_newaddress = result;
            break;

          case 0x3:     /* IB/ED variant */
            COREINT.ma_newaddress = operand1 + 4;
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, BITS(instr,23,24), 25);
            break;
#endif
        }
      }
      else
      {
        if (ARM8_MEM.RResponse == RRESP_DATA2)
          COREINT.ma_newaddress = COREINT.ma_address + 8;
        else
          COREINT.ma_newaddress = COREINT.ma_address + 4;
      }

      /* Now put the correct address on the bus if necessary.             */
      if ((COREINT.areqE == AREQ_LOAD) || (COREINT.areqE == AREQ_LOAD_M)
          || (COREINT.areqE == AREQ_LOAD_S) || (COREINT.areqE == AREQ_LOAD_SM))
      {
        ARM8_MEM.VAddress = COREINT.ma_newaddress;
#ifdef DB_CORE
        db_core_msg1("CORE: VAddress value written in ph2:",
                     COREINT.ma_newaddress);
        db_core_msg0("\n");
#endif
      }

    }
  }

  /* Forward the flags to the PU.                                    */
  CORE_PU.CFlags = (unsigned) FLAGBITS(fwd_flags);

  /* Decide whether this instruction is terminating and set the           */
  /* 'newinstr' state variable for the next cycle accordingly.            */
  /*                                                                      */
  /* Exception: if we're in the main looping state for STM or LDM, we've  */
  /* already determined this information above.                           */
  if (COREINT.interlocked || COREINT.busywaited)
    COREINT.newinstr = FALSE;
  else
  {
    switch (COREINT.stateE)
    {
      case S_EXCPSR:
      case S_EXCPREF:
      case S_SETTLE2CYCLE:
      case S_DPGETRS:
      case S_DPSHIFT:
      case S_DPIMMOP1P:
      case S_DPIMMOP2P:
      case S_DPSHIFTOP1P:
      case S_DPSHIFTOP2P:
      case S_DPOPP:
      case S_DPPREF:
      case S_BRANCH:
      case S_STRSHIFT:
      case S_STRNOSHIFT:
      case S_LDRSHIFT:
      case S_LDRWAIT:
      case S_STMINIT:
      case S_LDMINIT:
      case S_LDMWAIT:
      case S_MULFIRST:
      case S_MULSECOND:
      case S_MULLOOP:
      case S_SWPLOAD:
      case S_UNDEFPSR:
      case S_UNDEFPREF:
      case S_SWISETTLE:
      case S_SWIMEM1:
      case S_SWIMEM2:
      case S_SWIRETPSR:
      case S_SWIRETPREF:
        COREINT.newinstr = FALSE;
        break;

      case S_CANCELLED:
      case S_EXCRADDR:
      case S_SKIPPED:
      case S_SETTLE1CYCLE:
      case S_LINK:
      case S_DPIMMOP1A:
      case S_DPIMMOP2A:
      case S_DPSHIFTOP1A:
      case S_DPSHIFTOP2A:
      case S_DPOPA:
      case S_DPIMMOP1F:
      case S_DPIMMOP2F:
      case S_DPSHIFTOP1F:
      case S_DPSHIFTOP2F:
      case S_DPOPF:
      case S_MRS:
      case S_STRIMM:
      case S_STROP:
      case S_LDRPREF:
      case S_MULTERM2:
      case S_SWPSTORE:
      case S_MRC:
      case S_MCR:
      case S_SWIRETHALT:
        COREINT.newinstr = TRUE;
        break;

      case S_LDMPREF:
        /* Extra PSR settling time is needed if this is LDM ...PC}^.      */
        COREINT.newinstr = !DTM_SBIT(instr);
        break;

      case S_MSR:
      case S_MSRIMM:
        /* Extra PSR settling time is needed if this is a write to the    */
        /* CPSR and is writing to the control byte.                       */
        COREINT.newinstr =
          PSRXFER_SBIT(instr)
          || !PSRXFER_CTLBIT(instr);
        break;

      case S_LDRIMM:
      case S_LDRSHIFTOP:
      case S_LDRNOSHIFTOP:     /* Only occurs if invalid instruction used */
      case S_LDROP:
        COREINT.newinstr =
          (IFIELD_RD(instr) != 0xF);  /* Destination isn't R15 */
        break;

      case S_MULTERM1:
        COREINT.newinstr = (MUL_LBIT(instr) == 0);
        break;

      case S_STM:
      case S_LDM:
        /* COREINT.newinstr already determined above.                     */
        break;

      case S_UNDEFRADDR:
        /* We're completing this instruction unless this is a SWI and it  */
        /* is being intercepted.                                          */
        COREINT.newinstr = (BITS(instr,24,27) != 0xF)
                           || !armul8swis_recognise(BITS(instr,0,23),state);
        break;

#ifdef DB_CORE
      default:
        error(ERROR_UNCOVEREDCASE, COREINT.stateE, 26);
        break;
#endif
    }
  }

  /* The Prefetch Unit needs to be told whether an instruction is         */
  /* terminating, so that it can check the accuracy of its predictions at */
  /* the correct time.                                                    */

  CORE_PU.NewInstr = COREINT.newinstr;

  /* Accept a new instruction if we're not entering a data abort, and     */
  /* either the Decode or the Execute stage now contains a cancelled or   */
  /* terminating instruction. Note that the code above ensures that we    */
  /* can detect this for the Execute stage just by examining              */
  /* COREINT.newinstr.                                                    */
  CORE_PU.InstrAccepted =
    !COREINT.aborting && (COREINT.cancelledD || COREINT.newinstr);

  /* Determine how to drive the multiplier interface signals. Ideally, we */
  /* would decide on the next state of the state machine, then start up a */
  /* multiply on the cycle before it enters the Execute stage. However,   */
  /* this seems very likely to cause an excessively long control path.    */
  /*   So what this will do instead is drive the multiplier interface     */
  /* signals from the instruction in the Execute stage whenever that      */
  /* instruction is a multiply and still needs the multiplier, and        */
  /* otherwise drive them from whether the instruction in the Decode      */
  /* stage is a multiply instruction. When a multiply instruction is      */
  /* directly preceded by a multi-cycle non-multiply instruction, this    */
  /* will have the unfortunate side-effect of initialising the multiplier */
  /* one or more times with junk data before it is finally initialised    */
  /* with the correct data. This shouldn't cause any problems, apart from */
  /* some extra power consumption in the real silicon.                    */
  /*   This does also have the somewhat unfortunate side-effect that      */
  /* multiply instructions in the Decode stage have to be detected almost */
  /* every cycle. The code below only detects them when they're about to  */
  /* move into the Execute stage, so we end up doing multiple decodes of  */
  /* multiply instructions.                                               */

  /* If we're interlocked this cycle, we want to leave these signals      */
  /* alone (rather than changing them because the instruction is now in   */
  /* the Execute stage - this can lead to MulInit being dropped too       */
  /* early). The same is done for being busy-waited: this is almost       */
  /* certainly not important for the functionality, but we generally want */
  /* to treat being busy-waited and being interlocked identically as far  */
  /* as possible.                                                         */
  /*   Note that it is important here that being conditionally skipped    */
  /* or cancelled by CancelE earlier in this cycle reset the interlocked/ */
  /* busy-waited status, and so ensures that this code will run and drive */
  /* the interface according to the instruction now in the Decode stage.  */

  if (!COREINT.interlocked && !COREINT.busywaited)
  {
    /* First set the interface signals according to the instruction in    */
    /* the Decode stage.                                                  */
    ARM8_EXTEND.MulEnable =
    ARM8_EXTEND.MulInit   =
      (BITS(COREINT.instrD,24,27) == 0x0)
      && (BITS(COREINT.instrD,4,7) == 0x9);
    ARM8_EXTEND.MulAcc    = MUL_ABIT(COREINT.instrD) ? 1 : 0;
    ARM8_EXTEND.MulSgn    = MUL_UBIT(COREINT.instrD) ? 1 : 0;
    ARM8_EXTEND.MulLong   = MUL_LBIT(COREINT.instrD) ? 1 : 0;

    /* Then override with the instruction in the Execute stage if         */
    /* required.                                                          */
    switch (COREINT.stateE)
    {
      case S_MULFIRST:
        ARM8_EXTEND.MulEnable = TRUE;
        ARM8_EXTEND.MulInit   = FALSE;
        ARM8_EXTEND.MulAcc    = MUL_ABIT(COREINT.instrE) ? 1 : 0;
        ARM8_EXTEND.MulSgn    = MUL_UBIT(COREINT.instrE) ? 1 : 0;
        ARM8_EXTEND.MulLong   = MUL_LBIT(COREINT.instrE) ? 1 : 0;
        break;

      case S_MULSECOND:
      case S_MULLOOP:
        ARM8_EXTEND.MulEnable = !ARM8_EXTEND.MulTerm;
        ARM8_EXTEND.MulInit   = FALSE;
        ARM8_EXTEND.MulAcc    = MUL_ABIT(COREINT.instrE) ? 1 : 0;
        ARM8_EXTEND.MulSgn    = MUL_UBIT(COREINT.instrE) ? 1 : 0;
        ARM8_EXTEND.MulLong   = MUL_LBIT(COREINT.instrE) ? 1 : 0;
        break;

      case S_MULTERM1:
        /* We must only override the Decode stage instruction if this is  */
        /* not the last cycle of the instruction - i.e. if this is a      */
        /* "long" instruction.                                            */
        if (MUL_LBIT(COREINT.instrE))
        {
          ARM8_EXTEND.MulEnable = FALSE;
          ARM8_EXTEND.MulInit   = FALSE;
          ARM8_EXTEND.MulAcc    = MUL_ABIT(COREINT.instrE) ? 1 : 0;
          ARM8_EXTEND.MulSgn    = MUL_UBIT(COREINT.instrE) ? 1 : 0;
          ARM8_EXTEND.MulLong   = MUL_LBIT(COREINT.instrE) ? 1 : 0;
        }
        /* else keep the Decode stage versions.                           */
        break;

      default:
        /* Just keep the Decode stage versions.                           */
        break;
    }
  }

  /* Determine the potential new state of the Execute stage state         */
  /* machine, assuming no clock-stopping and no unpredictable exceptions  */
  /* (i.e. other than SWIs, undefined instructions and prefetch aborts).  */
  /*   This new state is what will determine the registers that get read. */
  /*   The primary thing controlling what this potential new state is is  */
  /* whether we're in the last cycle of the current instruction (in which */
  /* case, we must decode the Decode stage instruction) or not (in which  */
  /* case, we must advance the current instruction's state in an          */
  /* instruction-dependent way).                                          */

  if (COREINT.newinstr)
  {
    if (COREINT.cancelledD)
      COREINT.newstateE = S_CANCELLED;
    else if (COREINT.abortedD)
    {
      COREINT.newstateE     = S_EXCPSR;
      COREINT.newexcaddress = VECTOR_PABORT;
    }
    else
    {
      /* Shift attention to next instruction - note that this setting of  */
      /* 'instr' is necessary in order to make the register-reading code  */
      /* that follows read the right registers.                           */
      instr = COREINT.instrD;

      /* Choose first state of new instruction. (NB: May set              */
      /* COREINT.newexcaddress, and may produce potential messages about  */
      /* UNPREDICTABLE behaviour: we make certain the latter don't        */
      /* accumulate many times by clearing the Decode stage buffer.)      */
      clear_unpredictable(COREINT.newunpredbuffer);
      COREINT.newstateE = InitialState(state, instr);
    }
  }
  else if (!COREINT.interlocked && !COREINT.busywaited)
  {
    /* Choose the next state for this instruction. Note that some of      */
    /* these are simplified by the fact that we already know that the     */
    /* instruction is not terminating. I.e. we only need to choose        */
    /* between more than one possibility when the instruction may         */
    /* continue in more than one fashion, and not when it is merely a     */
    /* question of whether the instruction continues into a new state or  */
    /* terminates.                                                        */
    switch (COREINT.stateE)
    {
      case S_LDMPREF:
        /* Since it isn't terminating, this must be LDM ...PC}^.          */
      case S_SETTLE2CYCLE:
      case S_DPPREF:
        COREINT.newstateE = S_SETTLE1CYCLE;
        break;

      case S_EXCPSR:
        COREINT.newstateE = S_EXCPREF;
        break;

      case S_EXCPREF:
        COREINT.newstateE = S_EXCRADDR;
        break;

      case S_BRANCH:
        COREINT.newstateE = S_LINK;
        break;

      case S_DPGETRS:
        switch (IFIELD_DPOP(instr))
        {
          case ALUOP_SUB: case ALUOP_RSB:
          case ALUOP_ADD: case ALUOP_ADC:
          case ALUOP_SBC: case ALUOP_RSC:
          case ALUOP_CMP: case ALUOP_CMN:
            /* Arithmetic operations. If a complex shift, enter the two   */
            /* state sequence; otherwise, use the 1 state sequence.       */
            if (COMPLEX_SHIFT(instr))
              COREINT.newstateE = S_DPSHIFT;
            else if (IFIELD_RD(instr) != 0xF)
              COREINT.newstateE = S_DPSHIFTOP2A;
            else if (DP_SBIT(instr))
              COREINT.newstateE = S_DPSHIFTOP2P;
            else
              COREINT.newstateE = S_DPSHIFTOP2F;
            break;

          case ALUOP_AND: case ALUOP_EOR:
          case ALUOP_TST: case ALUOP_TEQ:
          case ALUOP_ORR: case ALUOP_BIC:
            /* Dyadic logical operations.                                 */
            if (IFIELD_RD(instr) != 0xF)
              COREINT.newstateE = S_DPSHIFTOP2A;
            else if (DP_SBIT(instr))
              COREINT.newstateE = S_DPSHIFTOP2P;
            else
              COREINT.newstateE = S_DPSHIFTOP2F;
            break;

          case ALUOP_MOV: case ALUOP_MVN:
            /* Monadic logical operations.                                */
            if (IFIELD_RD(instr) != 0xF)
              COREINT.newstateE = S_DPSHIFTOP1A;
            else if (DP_SBIT(instr))
              COREINT.newstateE = S_DPSHIFTOP1P;
            else
              COREINT.newstateE = S_DPSHIFTOP1F;
            break;

#ifdef DB_CORE
          default:
            error(ERROR_UNCOVEREDCASE, IFIELD_DPOP(instr), 27);
            break;
#endif
        }
        break;

      case S_DPSHIFT:
        if (IFIELD_RD(instr) != 0xF)
          COREINT.newstateE = S_DPOPA;
        else if (DP_SBIT(instr))
          COREINT.newstateE = S_DPOPP;
        else
          COREINT.newstateE = S_DPOPF;
        break;

      case S_DPIMMOP1P:
        if (COMPARISON(instr))
          COREINT.newstateE = S_SETTLE2CYCLE;
        else
          COREINT.newstateE = S_DPPREF;
        break;

      case S_DPIMMOP2P:
        if (COMPARISON(instr))
          COREINT.newstateE = S_SETTLE2CYCLE;
        else
          COREINT.newstateE = S_DPPREF;
        break;

      case S_DPSHIFTOP1P:
        if (COMPARISON(instr))
          COREINT.newstateE = S_SETTLE2CYCLE;
        else
          COREINT.newstateE = S_DPPREF;
        break;

      case S_DPSHIFTOP2P:
        if (COMPARISON(instr))
          COREINT.newstateE = S_SETTLE2CYCLE;
        else
          COREINT.newstateE = S_DPPREF;
        break;

      case S_DPOPP:
        if (COMPARISON(instr))
          COREINT.newstateE = S_SETTLE2CYCLE;
        else
          COREINT.newstateE = S_DPPREF;
        break;

      case S_MSR:
      case S_MSRIMM:
        /* We know it isn't terminating, so must be going into the PSR    */
        /* settling states.                                               */
        COREINT.newstateE = S_SETTLE2CYCLE;
        break;

      case S_STRSHIFT:
      case S_STRNOSHIFT:
        COREINT.newstateE = S_STROP;
        break;

      case S_LDRSHIFT:
        COREINT.newstateE = S_LDROP;
        break;

      case S_LDRIMM:
      case S_LDRSHIFTOP:
      case S_LDRNOSHIFTOP:     /* Only occurs if invalid instruction used */
      case S_LDROP:
        /* We know it isn't terminating, so must be going to the "wait"   */
        /* state while an R15 value is being loaded.                      */
        COREINT.newstateE = S_LDRWAIT;
        break;

      case S_LDRWAIT:
        COREINT.newstateE = S_LDRPREF;
        break;

      case S_STMINIT:
      case S_STM:
        COREINT.newstateE = S_STM;
        break;

      case S_LDMINIT:
      case S_LDM:
        /* If we're currently loading R15, we'll definitely enter the     */
        /* "forced prefetch" sequence next cycle; otherwise, we'll either */
        /* terminate or enter/re-enter the LDM loop. If we've got here,   */
        /* we know we're not terminating...                               */
        if (COREINT.ma_doingR15)
          COREINT.newstateE = S_LDMWAIT;
        else
          COREINT.newstateE = S_LDM;
        break;

      case S_LDMWAIT:
        COREINT.newstateE = S_LDMPREF;
        break;

      case S_MULFIRST:
        COREINT.newstateE = S_MULSECOND;
        break;

      case S_MULSECOND:
      case S_MULLOOP:
        if (ARM8_EXTEND.MulTerm)
          COREINT.newstateE = S_MULTERM1;
        else
          COREINT.newstateE = S_MULLOOP;
        break;

      case S_MULTERM1:
        /* Since we're not terminating, this must be a "long" instruction */
        /* and we have to do the second final addition cycle.             */
        COREINT.newstateE = S_MULTERM2;
        break;

      case S_SWPLOAD:
        COREINT.newstateE = S_SWPSTORE;
        break;

      case S_UNDEFPSR:
        COREINT.newstateE = S_UNDEFPREF;
        break;

      case S_UNDEFPREF:
        COREINT.newstateE = S_UNDEFRADDR;
        break;

      case S_UNDEFRADDR:
        /* Since we're not terminating, this must be an intercepted SWI.  */
        COREINT.newstateE = S_SWISETTLE;
        break;

      case S_SWIMEM1:
        COREINT.newstateE = S_SWIMEM2;
        break;

      case S_SWIRETPSR:
        COREINT.newstateE = S_SWIRETPREF;
        break;

      case S_SWISETTLE:
      case S_SWIMEM2:
        /* Choose next state based on SWI interceptor response.           */
        switch (COREINT.core_swis.Request)
        {
          case SWIREQUEST_STR:
          case SWIREQUEST_LDR:
          case SWIREQUEST_STRB:
          case SWIREQUEST_LDRB:
            COREINT.newstateE = S_SWIMEM1;
            break;

          case SWIREQUEST_END:
          case SWIREQUEST_NOCPSRUPDATE:
          case SWIREQUEST_HALT:
            COREINT.newstateE = S_SWIRETPSR;
            break;

          default:
#ifdef DB_CORE
            error(ERROR_BADSWIREQUEST, COREINT.core_swis.Request, 0);
#endif
            COREINT.newstateE = S_SWIRETPSR;
            break;
        }
        break;

      case S_SWIRETPREF:
        COREINT.newstateE = S_SWIRETHALT;
        break;

#ifdef DB_CORE
      default:
        /* States which are not included above are ones which should      */
        /* unconditionally terminate - i.e. for which the current value   */
        /* of COREINT.newinstr appears to be incorrect.                   */
        error(ERROR_UNCOVEREDCASE, COREINT.stateE, 28);
        break;
#endif
    }

  }

  /* Sort out which registers are being read on to the A and B buses.     */
  /*                                                                      */
  /* A number of special values are used during this code to indicate     */
  /* special values are to be read on to the buses, as follows (note all  */
  /* these values are unforwardable and don't cause interlocks, so all    */
  /* that matters is that these values are not equal to any of 0-15,      */
  /* NOREADVAL or NOWRITEVAL):                                            */
  /*                                                                      */
  /* * Read PC with PSR in 26-bit modes (A bus only).                     */

#define READ_PCSPECIAL 18

  /* * Put the Write stage instruction's PcPlus8 value on the bus, for    */
  /*   data aborts (A bus only).                                          */

#define READ_OLDPC     19

  /* * Put the interrupt sequence point on the bus, for interrupts (A bus */
  /*   only).                                                             */

#define READ_INTSEQ    20

  mode = MODE;               /* The presumed mode for most register reads */
  switch (COREINT.newstateE)
  {
    case S_STM:
      if (COREINT.ma_reg4 == NOWRITEVAL)       /* Second register in list */
        COREINT.abusreg = NOREADVAL;
      else if (COREINT.ma_reg4 == 15)          /* PC must be read with    */
        COREINT.abusreg = READ_PCSPECIAL;      /*  PSR in 26-bit modes.   */
      else
        COREINT.abusreg = COREINT.ma_reg4;
      if (COREINT.ma_reg3 == NOWRITEVAL)       /* First register in list  */
        COREINT.bbusreg = NOREADVAL;
      else
        COREINT.bbusreg = COREINT.ma_reg3;
      if (DTM_SBIT(instr))
        mode = MODE_USER32;                 /* Deal with "user bank" STMs */
      break;

    case S_CANCELLED:
    case S_EXCPSR:
    case S_EXCPREF:
    case S_SETTLE2CYCLE:
    case S_SETTLE1CYCLE:
    case S_DPIMMOP1A:
    case S_DPIMMOP1P:
    case S_DPIMMOP1F:
    case S_DPPREF:
    case S_MRS:
    case S_MSRIMM:
    case S_LDRWAIT:
    case S_LDRPREF:
    case S_LDM:
    case S_LDMWAIT:
    case S_LDMPREF:
    case S_MULLOOP:
    case S_MULTERM1:
    case S_MULTERM2:
    case S_MRC:
    case S_UNDEFPSR:
    case S_UNDEFPREF:
    case S_SWISETTLE:
    case S_SWIMEM1:
    case S_SWIMEM2:
    case S_SWIRETPREF:
    case S_SWIRETHALT:
      COREINT.abusreg = NOREADVAL;
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_EXCRADDR:
      switch (COREINT.excaddress)
      {
        case VECTOR_PABORT:
          COREINT.abusreg = 15;
          COREINT.bbusreg = NOREADVAL;
          break;

        case VECTOR_DABORT:
          COREINT.abusreg = READ_OLDPC;
          COREINT.bbusreg = NOREADVAL;
          break;

        case VECTOR_RESET:
        case VECTOR_IRQ:
        case VECTOR_FIQ:
          COREINT.abusreg = READ_INTSEQ;
          COREINT.bbusreg = NOREADVAL;
          break;

#ifdef DB_CORE
        default:
          error(ERROR_UNCOVEREDCASE, COREINT.excaddress, 29);
          break;
#endif
      }
      break;

    case S_UNDEFRADDR:
      COREINT.abusreg = 15;
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_BRANCH:
      COREINT.abusreg = 15;
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_LINK:
      COREINT.abusreg = READ_PCSPECIAL;
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_DPGETRS:
      COREINT.abusreg = IFIELD_RS(instr);
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_DPOPA:
    case S_DPOPP:
    case S_DPOPF:
    case S_DPIMMOP2A:
    case S_DPIMMOP2P:
    case S_DPIMMOP2F:
    case S_LDROP:
    case S_LDRIMM:
    case S_STMINIT:
    case S_LDMINIT:
    case S_SWPLOAD:
      COREINT.abusreg = IFIELD_RN(instr);
      COREINT.bbusreg = NOREADVAL;
      break;

    case S_DPSHIFTOP1A:
    case S_DPSHIFTOP1P:
    case S_DPSHIFTOP1F:
    case S_DPSHIFT:
    case S_MSR:
    case S_LDRSHIFT:
    case S_STRSHIFT:
    case S_STRNOSHIFT:
      COREINT.abusreg = NOREADVAL;
      COREINT.bbusreg = IFIELD_RM(instr);
      break;

    case S_DPSHIFTOP2A:
    case S_DPSHIFTOP2P:
    case S_DPSHIFTOP2F:
    case S_LDRSHIFTOP:
    case S_LDRNOSHIFTOP:
    case S_SWPSTORE:
      COREINT.abusreg = IFIELD_RN(instr);
      COREINT.bbusreg = IFIELD_RM(instr);
      break;

    case S_STRIMM:
    case S_STROP:
      COREINT.abusreg = IFIELD_RN(instr);
      COREINT.bbusreg = IFIELD_RD(instr);
      break;

    case S_MULFIRST:
      COREINT.abusreg = IFIELD_RS(instr);
      COREINT.bbusreg = IFIELD_RM(instr);
      break;

    case S_MULSECOND:
      if (MUL_ABIT(instr))
      {
        if (MUL_LBIT(instr))
          COREINT.abusreg = IFIELD_RN(instr);
        else
          COREINT.abusreg = NOREADVAL;
        COREINT.bbusreg = IFIELD_RD(instr);
      }
      else
      {
        COREINT.abusreg = NOREADVAL;
        COREINT.bbusreg = NOREADVAL;
      }
      break;

    case S_MCR:
      COREINT.abusreg = NOREADVAL;
      COREINT.bbusreg = IFIELD_RD(instr);
      break;

    case S_SWIRETPSR:
      COREINT.abusreg = NOREADVAL;
      COREINT.bbusreg = 14;
      break;

#ifdef DB_CORE
    default:
      error(ERROR_UNCOVEREDCASE, COREINT.newstateE, 30);
      break;
#endif
  }

  /* Now we're ready to drive the A and B bus values out to the core      */
  /* extension (multiplier). This needs to be done with ALU register      */
  /* forwarding taken into account.                                       */
  /*   Late ALU forwarding is no problem: it is only a hardware device to */
  /* ensure that we don't need to both write and read a register in the   */
  /* same phase 2, and is dealt with here simply by putting the register  */
  /* writing at the start of this routine and the register reading at the */
  /* end - i.e. so that this routine is capable of writing and reading a  */
  /* register in the same phase 2.                                        */
  /*   Early ALU forwarding does however have to be taken into account,   */
  /* with an exception to prevent an STM from forwarding its writeback    */
  /* value to its first register reads. We also remember whether we in    */
  /* fact did the early ALU forwarding, since LDR forwarding has to be    */
  /* inhibited in the following phase 1 if we did.                        */
  /*   Finally, when reading R15 with the PSR for 26-bit modes, life is a */
  /* bit complicated. The flag bits have to be forwarded, which means we  */
  /* should get them from 'fwd_flags'. The mode and interrupt mask bits   */
  /* needn't be, because of the PSR settling cycles which are allowed     */
  /* whenever these bits change, so they come from CPSR.                  */

  COREINT.aluforwarda =
    (COREINT.abusreg == COREINT.aluwrite_regE);

  if (COREINT.aluforwarda)
    ARM8_EXTEND.ABus = COREINT.aluwrite_valueE;
  else if (COREINT.abusreg < 15)
    ARM8_EXTEND.ABus = REG(COREINT.abusreg, mode);
  else if (COREINT.abusreg == 15)
    ARM8_EXTEND.ABus = COREINT.newinstr
                       ? COREINT.pcplus8D
                       : COREINT.pcplus8E;
  else if (COREINT.abusreg == READ_PCSPECIAL)
    ARM8_EXTEND.ABus = (COREINT.newinstr
                        ? COREINT.pcplus8D
                        : COREINT.pcplus8E)
                       | (BIT(MODE,4)
                         ? 0
                         : (fwd_flags
                            | ((CPSR & MASK_BITS) << MASK26MOVE)
                            | (CPSR & MODE26_BITS)));
  else if (COREINT.abusreg == READ_OLDPC)
    ARM8_EXTEND.ABus = COREINT.pcplus8W;
  else if (COREINT.abusreg == READ_INTSEQ)
    ARM8_EXTEND.ABus = COREINT.intseqpt_base;
  /* else COREINT.abusreg must be NOREADVAL, or some option which it      */
  /* shouldn't be able to be.                                             */

  COREINT.aluforwardb =
    (COREINT.bbusreg == COREINT.aluwrite_regE) && (COREINT.newstateE != S_STM);

  if (COREINT.aluforwardb)
    ARM8_EXTEND.BBus = COREINT.aluwrite_valueE;
  else if (COREINT.bbusreg < 15)
    ARM8_EXTEND.BBus = REG(COREINT.bbusreg, mode);
  else if (COREINT.bbusreg == 15)
    ARM8_EXTEND.BBus = (COREINT.newinstr
                        ? COREINT.pcplus8D
                        : COREINT.pcplus8E)
                       | (BIT(MODE,4)
                         ? 0
                         : (fwd_flags
                            | ((CPSR & MASK_BITS) << MASK26MOVE)
                            | (CPSR & MODE26_BITS)));
  /* else COREINT.bbusreg must be NOREADVAL, or some option which it      */
  /* shouldn't be able to be.                                             */

  /* Deal with interlock issues. First, recover which registers were read */
  /* this cycle. Note that if the registers which were read are any of    */
  /* the "special" values 15, NOREADVAL, READ_PCSPECIAL, READ_OLDPC or    */
  /* READ_INTSEQ, there is no chance of them indicating an interlock when */
  /* compared with the "registers to be written" variables, which are one */
  /* of 0-14 and NOWRITEVAL. This is exactly what is wanted, so there is  */
  /* no need for special cases for these values.                          */

  readrega = COREINT.abusreg;
  readregb = COREINT.bbusreg;

  /* Then check for an interlock. The criteria for this are complicated   */
  /* and are explained in detail in the ARM8 Interlocks document: this    */
  /* version of the source file uses the criteria in version 1.1 of the   */
  /* document.                                                            */

  COREINT.newinterlocked =

    /* First cycle A bus interlock.                                       */

    (COREINT.writereg1E == readrega)

    /* First cycle B bus interlock.                                       */

    || (COREINT.writereg1E == readregb)

    /* Special first cycle interlock for STMs.                            */

    || ((COREINT.writereg1E != NOWRITEVAL)
        && (COREINT.writeflagsE & (WFLAG_BOFFSET | WFLAG_SIGNED))
        && (COREINT.newstateE == S_STMINIT))

    /* Second cycle A bus interlock: byte rotation/sign extension case.   */

    || ((COREINT.writereg1M == readrega)
        && (COREINT.writeflagsM & (WFLAG_BOFFSET | WFLAG_SIGNED))
        && (COREINT.newstateE != S_MULFIRST))

    /* Second cycle B bus interlock: byte rotation/sign extension case.   */

    || ((COREINT.writereg1M == readregb)
        && (COREINT.writeflagsM & (WFLAG_BOFFSET | WFLAG_SIGNED))
        && (COREINT.newstateE != S_MULFIRST)
        && (COREINT.newstateE != S_STRIMM)
        && (COREINT.newstateE != S_STROP))

    /* Second cycle A/B bus interlock: no byte rotation/sign extension    */
    /* case. Note that all cases where this interlocks also interlock in  */
    /* the byte rotation/sign extension case, so there is no need to      */
    /* check whether there is a byte rotation or sign extension.          */

    || (((COREINT.writereg1M == readrega) || (COREINT.writereg1M == readregb))
        && ((COREINT.newstateE == S_MULSECOND) || (COREINT.newstateE == S_MCR)))

    /* A bus LDM interlock.                                               */

    || (COREINT.writereg2M == readrega)

    /* B bus LDM interlock.                                               */

    || (COREINT.writereg2M == readregb);

  /* Drive the results to the multiplier and the coprocessors.            */
  ARM8_EXTEND.Interlocked = COREINT.newinterlocked;
  ARM8_COPROC.Interlocked = COREINT.newinterlocked;

  /* Decide whether we want a coprocessor to complete execution of the    */
  /* current instruction. Most aspects of this are simply dealt with by   */
  /* testing the state at this point: in particular, a skipped, cancelled */
  /* or interrupted instruction will no longer be in a coprocessor        */
  /* instruction state at this point. Data aborts are an exception to     */
  /* this, however, since a data abort on the instruction before the      */
  /* coprocessor instruction can cause the coprocessor instruction to be  */
  /* "lost" without changing its state.                                   */
  switch (COREINT.stateE)
  {
    case S_MRC:
    case S_MCR:
      ARM8_COPROC.CExecute = !COREINT.aborting;
      break;

    default:
      ARM8_COPROC.CExecute = FALSE;
      break;
  }

  return;
}

/**************************************************************************\
*                                                                          *
* The "late" phase 2 routine                                               *
* ==========================                                               *
*                                                                          *
* Summary of things done by this routine:                                  *
*   1) Execute stage state is updated if appropriate.                      *
*   2) Pipeline advances are performed.                                    *
*   3) Other state changes such as updating the LDM/STM address occur.     *
*   4) All "clock-stopping" due to interlocks and/or memory delays is      *
*      processed by preventing state updates, pipeline advances, etc., as  *
*      appropriate.                                                        *
*   5) Rdata value read and if necessary modified to generate the value    *
*      that will be written to a register.                                 *
*   6) Coprocessor control signals for next phase 1 determined.            *
*   7) Advance the IRQ/FIQ "synchroniser" latches.                         *
*                                                                          *
\**************************************************************************/

void armul8core_lateph2(armul8_state *state)
{
  /* Record information required by the 'armul8core_lastinstr' call. Note */
  /* that we process it as little as possible at this point, so as to     */
  /* slow down emulation as little as possible.                           */
  COREINT.lastinstr   = COREINT.instrE;
  COREINT.lastpcplus8 = COREINT.pcplus8E;
  COREINT.laststate   = COREINT.stateE;
  COREINT.laststatus  = 0;

  /* If we're in the appropriate state of a SWI interception sequence and */
  /* doing a load, pick up the Rdata value and return it to the SWI       */
  /* interceptor. Note that it doesn't matter if we do this regardless of */
  /* whether the current responses are confirmed: we won't advance to     */
  /* state S_SWIMEM2 and actually use the results we got until we've got  */
  /* some confirmed results.                                              */

  if ((COREINT.stateE == S_SWIMEM1)
      && ((COREINT.core_swis.Request == SWIREQUEST_LDR)
          || (COREINT.core_swis.Request == SWIREQUEST_LDRB)))
  {
    unsigned32 byterot;

    byterot = COREINT.core_swis.Address & 3;
    if (ARM8_EXT.BigEnd && (COREINT.core_swis.Request == SWIREQUEST_LDRB))
      byterot ^= 3;

    switch (byterot)
    {
      case 0:
        COREINT.core_swis.Data = ARM8_MEM.Rdata;
        break;

      case 1:
        COREINT.core_swis.Data =
          (ARM8_MEM.Rdata >> 8) | (ARM8_MEM.Rdata << 24);
        break;

      case 2:
        COREINT.core_swis.Data =
          (ARM8_MEM.Rdata >> 16) | (ARM8_MEM.Rdata << 16);
        break;

      case 3:
        COREINT.core_swis.Data =
          (ARM8_MEM.Rdata >> 24) | (ARM8_MEM.Rdata << 8);
        break;

#ifdef DB_CORE
      default:
        error(ERROR_UNCOVEREDCASE, byterot, 31);
        break;
#endif
    }

    if (COREINT.core_swis.Request == SWIREQUEST_LDRB)
      COREINT.core_swis.Data &= 0xFF;
  }

  /* If the reset signal is asserted, we must reset everything...         */

  if (ARM8_EXT.Reset)
  {
    reset_state(state);
    COREINT.laststatus |= CORESTATUS_LOST;
  }

  /* Otherwise, if the last memory responses were not confirmed, there    */
  /* isn't really a new clock cycle starting. We must clear the Write     */
  /* stage of the pipeline (so that we don't write the junk data that is  */
  /* on Rdata to anywhere), and otherwise skip all the pipeline updating. */

  else if (ARM8_MEM.NConfirm)

  {
    COREINT.writereg1W  = NOWRITEVAL; /* Indicates no registers being     */
    COREINT.writereg2W  = NOWRITEVAL; /*  written                         */
    COREINT.writeflagsW = 0;          /* And we're also not interested in */
                                      /*  any values on the bus this      */
                                      /*  cycle for any other purposes.   */
    COREINT.newinstr    = FALSE;      /* Next cycle is definitely not the */
                                      /*  first cycle of the instruction  */
                                      /*  (needed to prevent a possible   */
                                      /*  successful conditional skip or  */
                                      /*  CancelE)                        */

    /* Also record the "delayed by memory" status in case of a call to    */
    /* 'armul8core_lastinstr'.                                            */
    COREINT.laststatus |= CORESTATUS_DELAYED;
  }

  /* We're not resetting, and we're getting a real clock cycle, so all    */
  /* pipeline stages will advance if appropriate.                         */

  else

  {

    /* Do the Memory stage -> Write stage advance.                        */
    COREINT.pcplus8W      = COREINT.pcplus8M;
    COREINT.areqW         = COREINT.areqM;
    COREINT.rreqW         = COREINT.rreqM;
    COREINT.writereg1W    = COREINT.writereg1M;
    COREINT.writereg2W    = COREINT.writereg2M;
    COREINT.writemodeW    = COREINT.writemodeM;
    COREINT.writeflagsW   = COREINT.writeflagsM;

    /* Clear the Memory stage just in case the Execute stage doesn't      */
    /* advance into it.                                                   */
    COREINT.areqM         = AREQ_NONE;
    COREINT.rreqM         = RREQD_NONE;
    COREINT.writereg1M    = NOWRITEVAL;
    COREINT.writereg2M    = NOWRITEVAL;
    COREINT.writeflagsM   = 0;
    COREINT.aluwrite_regM = NOWRITEVAL;
    COREINT.newcpsrM      = CPSR;
    COREINT.newspsrM      = SPSR(MODE);
    COREINT.newspsr_modeM = MODE;

    /* Set up a default indication to coprocessors that instructions are  */
    /* not advancing through the pipeline.                                */
    COREINT.enterdecode  = FALSE;
    COREINT.enterexecute = FALSE;

    /* The Execute stage won't advance into the Memory stage in two       */
    /* cases. In order of priority, we must:                              */
    /*   * Take a data abort if there is one.                             */
    /*   * Repeat the current Execute stage if we've got an interlock or  */
    /*     are being busy-waited.                                         */
    /* So first, look for a data abort. If we find one, we must not       */
    /* advance the Execute stage: instead, whatever instruction was there */
    /* must be "lost". In addition, we must enter the exception entry     */
    /* sequence, and we must prevent the Write stage using the incorrect  */
    /* data on the bus. Finally, we must do base register restoration for */
    /* the offending instruction, which we will do by replacing the ALU   */
    /* write of the lost instruction in the Execute stage.                */

    if (COREINT.aborting)
    {
      /* Enter exception entry sequence.                                  */
      COREINT.stateE      = S_EXCPSR;
      COREINT.excaddress  = VECTOR_DABORT;
      COREINT.interlocked = FALSE;
      COREINT.busywaited  = FALSE;
      COREINT.newinstr    = FALSE; /* Prevent CancelE affecting exception */

      /* Clear the Write stage.                                           */
      COREINT.writereg1W  = NOWRITEVAL;
      COREINT.writereg2W  = NOWRITEVAL;
      COREINT.writeflagsW = 0;

      /* Hijack the Memory stage to do base register restoration - but    */
      /* don't try to restore register 15!                                */
      if (COREINT.base_regM != 15)
      {
        COREINT.aluwrite_regM   = COREINT.base_regM;
        COREINT.aluwrite_modeM  = COREINT.base_modeM;
        COREINT.aluwrite_valueM = COREINT.base_valueM;
      }

      /* We don't want any buffered-up messages about UNPREDICTABLE       */
      /* behaviour, since they all relate to the "lost" instruction or to */
      /* the one following it.                                            */
      clear_unpredictable(COREINT.unpredbuffer);

      /* At this point, the Write stage is empty, the Memory stage is     */
      /* empty apart from the base register restoration, and the Execute  */
      /* stage has been "sidetracked" into the exception entry sequence,  */
      /* "losing" the instruction cycle we've just executed. The Decode   */
      /* stage instruction doesn't advance into the Execute stage, and    */
      /* will shortly be cancelled when the exception sequence forced     */
      /* prefetch occurs. We also know that CORE_PU.InstrAccepted wasn't  */
      /* asserted above, so nothing is trying to get into the Decode      */
      /* stage. So all we've still got to do is record the "lost" cycle.  */
      COREINT.laststatus |= CORESTATUS_LOST;
    }

    /* Otherwise, if there is an interlock, record the fact, update the   */
    /* interlocking information for next cycle and leave the Memory stage */
    /* empty; if there is no interlock, we can advance the Execute stage  */
    /* to the Memory stage.                                               */
    /*   Similarly for busy-waiting, but with the additional factors that */
    /* (a) busy-waiting must be interruptible; (b) busy-waiting may       */
    /* change to bouncing; (c) busy-waiting and interlocking may occur    */
    /* simultaneously.                                                    */

    else if (COREINT.interlocked | COREINT.busywaited)
    {
      if (COREINT.interlocked)
        COREINT.laststatus |= CORESTATUS_INTERLOCKED;
      COREINT.interlocked   = COREINT.newinterlocked;
      if (COREINT.busywaited)
      {
        COREINT.laststatus |= CORESTATUS_BUSYWAITED;
        if (!FBIT(CPSR) && (ARM8_EXT.Isync ? ARM8_EXT.Fiq : COREINT.fiq2))
        {
          COREINT.stateE      = S_EXCPSR;
          COREINT.excaddress  = VECTOR_FIQ;
          COREINT.interlocked = FALSE;
          COREINT.busywaited  = FALSE;
          COREINT.newinstr    = FALSE; /* Prevent CancelE affecting       */
                                       /* exception                       */
        }
        else if (!IBIT(CPSR) && (ARM8_EXT.Isync ? ARM8_EXT.Irq : COREINT.irq2))
        {
          COREINT.stateE      = S_EXCPSR;
          COREINT.excaddress  = VECTOR_IRQ;
          COREINT.interlocked = FALSE;
          COREINT.busywaited  = FALSE;
          COREINT.newinstr    = FALSE; /* Prevent CancelE affecting       */
                                       /* exception                       */
        }
        else if (ARM8_COPROC.CBounceE)
        {
#ifdef DB_CORE
          if (ARM8_COPROC.CBusyWaitE) error(ERROR_BOUNCEBUSY_E, 0, 0);
#endif
          COREINT.stateE      = S_UNDEFPSR;
          COREINT.excaddress  = VECTOR_UNDEF;
          COREINT.interlocked = FALSE;
          COREINT.busywaited  = FALSE;
        }
        else
          COREINT.busywaited = ARM8_COPROC.CBusyWaitE;
      }
    }
    else
    {
      /* Advance Execute stage requests into Memory stage.                */
      COREINT.pcplus8M        = COREINT.pcplus8E;
      if (COREINT.areqE == AREQ_FETCH)
        COREINT.areqM = AREQ_NONE;      /* Forget about forced prefetches */
      else                              /* - they now belong to the PU.   */
        COREINT.areqM = COREINT.areqE;
      COREINT.rreqM           = COREINT.rreqE;
      COREINT.writereg1M      = COREINT.writereg1E;
      COREINT.writereg2M      = COREINT.writereg2E;
      COREINT.writemodeM      = COREINT.writemodeE;
      COREINT.writeflagsM     = COREINT.writeflagsE;

      COREINT.aluwrite_regM   = COREINT.aluwrite_regE;
      COREINT.aluwrite_modeM  = COREINT.aluwrite_modeE;
      COREINT.aluwrite_valueM = COREINT.aluwrite_valueE;
      COREINT.newcpsrM        = COREINT.newcpsrE;
      COREINT.newspsrM        = COREINT.newspsrE;
      COREINT.newspsr_modeM   = COREINT.newspsr_modeE;

      COREINT.base_regM       = COREINT.base_regE;
      COREINT.base_modeM      = COREINT.base_modeE;
      COREINT.base_valueM     = COREINT.base_valueE;

      /* Also, update the C and Z flags for a two word multiplication     */
      /* termination, since we now know we really are advancing to the    */
      /* new state.                                                       */
      COREINT.carryhold       = COREINT.carryhold2;
      COREINT.zerohold        = COREINT.zerohold2;

      /* Deal with warnings about UNPREDICTABLE behaviour generated since */
      /* the last cycle. We want to print them out and flush the buffer   */
      /* containing them unless the current "instruction" is being        */
      /* cancelled. If it is being cancelled, we just want to flush the   */
      /* buffer without printing the warning messages.                    */
      /*   Note that this just checks for cancelled instructions and not  */
      /* for any other case where the "instruction" isn't really being    */
      /* executed (i.e. state number < 0). This doesn't make any real     */
      /* difference at present, since the other possibilities don't       */
      /* generate such warning messages, but allows for the faint         */
      /* possibility that they might at some point in the future.         */
      if (COREINT.stateE != S_CANCELLED)
        print_unpredictable(COREINT.unpredbuffer, COREINT.pcplus8E);
      clear_unpredictable(COREINT.unpredbuffer);

      /* What we do next depends on whether we've just finished an        */
      /* instruction. If so, we check for FIQs; if there is no FIQ, we    */
      /* check for IRQs; if there is neither a FIQ nor an IRQ, we enter   */
      /* the already-calculated first state of the new instruction (this  */
      /* precalculation already takes into account the exception entries  */
      /* for prefetch aborts, undefined instructions and SWIs).           */
      /*   If we haven't just finished an instruction, we simply enter    */
      /* the already-calculated next state of the current instruction.    */

      if (COREINT.newinstr)

      {
        /* Provided the old instruction has not been cancelled, this is   */
        /* an interrupt sequence point.                                   */
        if (COREINT.stateE != S_CANCELLED)
        {
          COREINT.intseqpt_base = COREINT.newintseqpt_base;
          COREINT.intseqpt_sub4 = COREINT.newintseqpt_sub4;
        }

#ifdef DBF_CORE
        /* If this is the end of an instruction, record the instruction   */
        /* in the "Executed Instruction Stream" file.                     */
        if (COREINT.stateE >= 0)
          db_core_eis(state);
#endif

        /* Advance the new instruction into the Execute stage.            */
        COREINT.instrE       = COREINT.instrD;
        COREINT.abortedE     = COREINT.abortedD;
        COREINT.pcplus8E     = COREINT.pcplus8D;
        COREINT.nobranchE    = COREINT.nobranchD;

        /* Start recording a new interrupt sequence point.                */
        COREINT.newintseqpt_base = COREINT.pcplus8E;
        COREINT.newintseqpt_sub4 = TRUE;

#ifdef DB_CORE
        /* Empty the Decode stage by marking its instruction as           */
        /* cancelled. (The reason for doing this is to allow debug code   */
        /* below to watch for cases when an instruction is lost in the    */
        /* Decode stage because a new instruction overwrites it before    */
        /* the instruction has moved on to the Execute stage.)            */
        COREINT.cancelledD = TRUE;
#endif

        /* Look out for interrupts and take the exception entry sequence  */
        /* if they are found.                                             */
        if (!FBIT(CPSR) && (ARM8_EXT.Isync ? ARM8_EXT.Fiq : COREINT.fiq2))
        {
          COREINT.stateE       = S_EXCPSR;
          COREINT.excaddress   = VECTOR_FIQ;
          COREINT.interlocked  = FALSE;
          COREINT.busywaited   = FALSE;
          COREINT.newinstr     = FALSE; /* Prevent CancelE affecting      */
                                        /* exception                      */
          COREINT.enterexecute = TRUE;  /* This is to mimic the fact that */
                                        /* the VHDL actually advances the */
                                        /* new instruction into the       */
                                        /* Execute stage, only to trans-  */
                                        /* form it into an interrupt      */
                                        /* exception entry 1 cycle later. */
        }
        else if (!IBIT(CPSR) && (ARM8_EXT.Isync ? ARM8_EXT.Irq : COREINT.irq2))
        {
          COREINT.stateE       = S_EXCPSR;
          COREINT.excaddress   = VECTOR_IRQ;
          COREINT.interlocked  = FALSE;
          COREINT.busywaited   = FALSE;
          COREINT.newinstr     = FALSE; /* Prevent CancelE affecting      */
                                        /* exception                      */
          COREINT.enterexecute = TRUE;  /* See corresponding comment for  */
                                        /* FIQ above.                     */
        }
        else
        {
          UnpredBuffer *tempptr;

          COREINT.stateE       = COREINT.newstateE;
          COREINT.excaddress   = COREINT.newexcaddress;
          COREINT.enterexecute = TRUE;
          COREINT.interlocked  = COREINT.newinterlocked;

          /* Transfer the Decode stage messages about UNPREDICTABLE       */
          /* behaviour to the Execute stage by pointer swapping.          */
          tempptr                 = COREINT.unpredbuffer;
          COREINT.unpredbuffer    = COREINT.newunpredbuffer;
          COREINT.newunpredbuffer = tempptr;

          /* Coprocessor instructions must initialise their "busy-waited" */
          /* status.                                                      */
          switch (COREINT.newstateE)
          {
            case S_MRC:
            case S_MCR:
              if (ARM8_COPROC.CBounceD)
              {
#ifdef DB_CORE
                if (ARM8_COPROC.CBusyWaitD) error(ERROR_BOUNCEBUSY_D, 0, 0);
#endif
                COREINT.stateE      = S_UNDEFPSR;
                COREINT.excaddress  = VECTOR_UNDEF;
                COREINT.interlocked = FALSE;
                COREINT.busywaited  = FALSE;
              }
              else
                COREINT.busywaited = ARM8_COPROC.CBusyWaitD;
              break;

            default:
              COREINT.busywaited = FALSE;
              break;
          }
        }
      }

      else /* If not a new instruction */

      {
        /* Do things associated with advancing LDMs and STMs as a result  */
        /* of the confirmed response from the memory system.              */
        switch (COREINT.stateE)
        {
          case S_STMINIT:
          case S_STM:
            COREINT.ma_address = COREINT.ma_newaddress;
            COREINT.ma_remove = 1;
            break;

          case S_LDMINIT:
          case S_LDM:
            COREINT.ma_address = COREINT.ma_newaddress;

            /* Work out how many registers to advance the priority        */
            /* encoder by next cycle - this is 2 if we're in the          */
            /* initialisation state, and the number of words the memory   */
            /* is returning to us this cycle otherwise.                   */
            /*   This is also the point at which we cancel the second     */
            /* register write request if only one data value is being     */
            /* returned. Note that it should *not* be done earlier: the   */
            /* request must not be cancelled until we've got a confirmed  */
            /* RRESP_DATA1 response.                                      */
            if ((COREINT.stateE == S_LDM)
                && (ARM8_MEM.RResponse == RRESP_DATA1))
            {
              COREINT.ma_remove  = 1;
              COREINT.writereg2W = NOWRITEVAL;
            }
            else
              COREINT.ma_remove = 2;
            break;

          default:
            /* Other instructions don't do anything here.                 */
            break;
        }

        /* Now advance the Execute stage state.                           */
        COREINT.stateE      = COREINT.newstateE;
        /* COREINT.excaddress is never relevant here.                     */
        COREINT.interlocked = COREINT.newinterlocked;
        COREINT.busywaited  = FALSE;  /* Must be: we're not already busy- */
                                      /* waited & not entering 1st cycle. */
      }
    }

    /* Now pick up the new instruction in the Decode stage if one has     */
    /* been accepted.                                                     */
    /*   Note that this relies on the Prefetch Unit to sort out the       */
    /* responses from the memory system even when the instruction will go */
    /* straight into the Core. (E.g. it must assert NoFetch if the memory */
    /* system requires it to wait for the instruction, and must combine   */
    /* MMU aborts and external aborts appropriately to generate           */
    /* CORE_PU.PAbort.) This is no problem, since these responses are     */
    /* provided by the memory system in phase 1.                          */

    if (CORE_PU.InstrAccepted)
    {
#ifdef DB_CORE
      if (!COREINT.cancelledD) error(ERROR_LOSTINDECODE, 0, 0);
#endif

      COREINT.instrD      = CORE_PU.InstructOnRdata
                            ? ARM8_MEM.Rdata
                            : CORE_PU.Instruct;
      COREINT.abortedD    = CORE_PU.PAbort;
      COREINT.pcplus8D    = CORE_PU.PcPlus8;
      COREINT.cancelledD  = CORE_PU.NoFetch;
      COREINT.nobranchD   = CORE_PU.IgnoreBranch;
      COREINT.enterdecode = TRUE;
    }
  }

  /* Pick up the Rdata value, in case it's wanted in early phase 1. (Note */
  /* that it would be unsafe to pick it up in "armul8core_earlyph1": some */
  /* other component of the system might have modified it by then.)       */
  /*   We also do any byte rotations and extractions that are required    */
  /* here, in order to allow 'armul8core_reginfo' to produce its results  */
  /* cleanly.                                                             */
  /*   Also, we save work by only doing this if the following early phase */
  /* 1 routine is actually going to want the value.                       */

  if (COREINT.writeflagsW & WFLAG_LATCH)
  {
    switch (COREINT.writeflagsW & WFLAG_BOFFSET)
    {
      case 0:
        COREINT.rdata1 = ARM8_MEM.Rdata;
        break;

      case 1:
        COREINT.rdata1 = (ARM8_MEM.Rdata >> 8) | (ARM8_MEM.Rdata << 24);
        break;

      case 2:
        COREINT.rdata1 = (ARM8_MEM.Rdata >> 16) | (ARM8_MEM.Rdata << 16);
        break;

      case 3:
        COREINT.rdata1 = (ARM8_MEM.Rdata >> 24) | (ARM8_MEM.Rdata << 8);
        break;

#ifdef DB_CORE
      default:
        error(ERROR_UNCOVEREDCASE, COREINT.writeflagsW & WFLAG_BOFFSET, 32);
        break;
#endif
    }

    if (COREINT.writeflagsW & WFLAG_BYTE)
    {
      COREINT.rdata1 &= 0xFF;
      if ((COREINT.writeflagsW & WFLAG_SIGNED) && BIT(COREINT.rdata1,7))
        COREINT.rdata1 |= 0xFFFFFF00;
    }

    if (COREINT.writeflagsW & WFLAG_HALFWORD)
    {
      COREINT.rdata1 &= 0xFFFF;
      if ((COREINT.writeflagsW & WFLAG_SIGNED) && BIT(COREINT.rdata1,15))
        COREINT.rdata1 |= 0xFFFF0000;
    }
  }

  /* Store away the IRQ/FIQ values, in case we're synchronising them.     */

  COREINT.fiq1 = ARM8_EXT.Fiq;
  COREINT.irq1 = ARM8_EXT.Irq;

  return;
}

/*****************************************************************\
*                                                                 *
* Procedure to get information about the last cycle's instruction *
*                                                                 *
\*****************************************************************/

void armul8core_lastinstr(armul8_state *state,
                          unsigned32   *address,
                          unsigned32   *instr,
                          unsigned     *status)
{
  *address = COREINT.lastpcplus8 - 8;
  *instr   = COREINT.lastinstr;
  *status  = COREINT.laststatus;
  if (*status == 0)
  {
    switch (COREINT.laststate)
    {
      case S_SKIPPED:
        *status |= CORESTATUS_SKIPPED;
        break;

      case S_CANCELLED:
        *status |= CORESTATUS_CANCELLED;
        break;

      case S_EXCPSR:
      case S_EXCPREF:
      case S_EXCRADDR:
        *status |= CORESTATUS_EXCEPTION;
        break;

      default:
        /* Nothing special about the state we're in.                      */
        break;
    }
  }
  return;
}

/*****************************************************************\
*                                                                 *
* Procedure to get information about the next cycle's instruction *
*                                                                 *
\*****************************************************************/

void armul8core_nextinstr(armul8_state *state,
                          unsigned32   *address,
                          unsigned32   *instr)
{
  *address = COREINT.pcplus8E - 8;
  *instr   = COREINT.instrE;
  return;
}

/***********************************************\
*                                               *
* Procedure to get information about a register *
*                                               *
\***********************************************/

void armul8core_reginfo(armul8_state *state,
                        int          regno,
                        int          mode,
                        unsigned32   *value,
                        unsigned     *changing,
                        unsigned     *known,
                        unsigned32   *newvalue1,
                        unsigned32   *newvalue2)
{
  /* Set up the default "not changing" return values.                     */
  *changing = 0;
  *known    = 0;

  /* If the register is not R15, pick up its value and then look for      */
  /* scheduled changes to it.                                             */

  if (regno != 15)
  {
    *value = REG(regno,mode);

    /* Now scan through possible writes to the register that will occur   */
    /* during the next four phases.                                       */
    /*   First phase 1: Register may change to the value just returned    */
    /* from memory.                                                       */
    if ((COREINT.writereg1W != NOWRITEVAL)
        && (RegMap[regno][mode]
            == RegMap[COREINT.writereg1W][COREINT.writemodeW]))
    {
      *changing  |= REGINFO_NEXTPHASE1;
      *known     |= REGINFO_NEXTPHASE1;
      *newvalue1 =  COREINT.rdata1;
    }

    /* First phase 2: Register may change either to the known ALU result  */
    /* or to the unknown value that will be returned from memory next     */
    /* phase. Note that these two should never occur simultaneously, and  */
    /* there is already a check in 'armul8core_earlyph2' that this indeed */
    /* does not occur.                                                    */
    if ((COREINT.aluwrite_regM != NOWRITEVAL)
        && (RegMap[regno][mode]
            == RegMap[COREINT.aluwrite_regM][COREINT.aluwrite_modeM]))
    {
      *changing  |= REGINFO_NEXTPHASE2;
      *known     |= REGINFO_NEXTPHASE2;
      *newvalue2 =  COREINT.aluwrite_valueM;
    }

    if ((COREINT.writereg2W != NOWRITEVAL)
        && (RegMap[regno][mode]
            == RegMap[COREINT.writereg2W][COREINT.writemodeW]))
      *changing |= REGINFO_NEXTPHASE2;

    /* Second phase 1: Register may change if we're initiating a memory   */
    /* cycle to load it.                                                  */
    if ((COREINT.writereg1M != NOWRITEVAL)
        && (RegMap[regno][mode]
            == RegMap[COREINT.writereg1M][COREINT.writemodeM]))
      *changing  |= REGINFO_FOLLOWINGPHASE1;

    /* Second phase 2: Register may change if we're initiating a memory   */
    /* cycle to load another register and it.                             */
    if ((COREINT.writereg2M != NOWRITEVAL)
        && (RegMap[regno][mode]
            == RegMap[COREINT.writereg2M][COREINT.writemodeM]))
      *changing |= REGINFO_FOLLOWINGPHASE2;
  }

  /* If the register is R15 and we're being asked about a 32-bit mode, we */
  /* simply report the current PcPlus8 value with no scheduled changes.   */

  else if (BIT(mode,4))
    *value = COREINT.pcplus8E;

  /* And if the register is R15 and we're being asked about a 26-bit      */
  /* mode, we report the current PcPlus8 value together with some CPSR    */
  /* bits, with a scheduled change on the next phase 1 to the current     */
  /* PcPlus8 value together with some new CPSR bits.                      */

  else
  {
    *value      = COREINT.pcplus8E
                  | (CPSR & FLAG_BITS)
                  | ((CPSR & MASK_BITS) << MASK26MOVE)
                  | (CPSR & MODE26_BITS);
    *changing  |= REGINFO_NEXTPHASE1;
    *known     |= REGINFO_NEXTPHASE1;
    *newvalue1  = COREINT.pcplus8E
                  | (COREINT.newcpsrM & FLAG_BITS)
                  | ((COREINT.newcpsrM & MASK_BITS) << MASK26MOVE)
                  | (COREINT.newcpsrM & MODE26_BITS);
  }

  return;
}

/*********************************************\
*                                             *
* Procedure to get information about the CPSR *
*                                             *
\*********************************************/

void armul8core_cpsrinfo(armul8_state *state,
                         unsigned32   *value,
                         unsigned32   *newvalue)
{
  *value    = CPSR;
  *newvalue = COREINT.newcpsrM;
  return;
}

/********************************************\
*                                            *
* Procedure to get information about an SPSR *
*                                            *
\********************************************/

int armul8core_spsrinfo(armul8_state *state,
                        int          mode,
                        unsigned32   *value,
                        unsigned32   *newvalue)
{
  *value    = SPSR(mode);
  if (SpsrMap[mode] == SpsrMap[COREINT.newspsr_modeM])
    *newvalue = COREINT.newspsrM;
  else
    *newvalue = *value;
  return (SpsrMap[mode] != 0);
}

/****************************************************************\
*                                                                *
* Procedure to identify the first "real" cycle of an instruction *
*                                                                *
\****************************************************************/

int armul8core_instrstart(armul8_state *state, unsigned32 *address)
{
  *address = COREINT.pcplus8E - 8;

  /* This is a "real" instruction start if (a) the Core's internal        */
  /* version of "newinstr" is set (note that this takes account of        */
  /* NConfirm); (b) we're in a state which is associated with an          */
  /* instruction (to take account of exception sequences, including       */
  /* prefetch abort, and already-cancelled instructions; (c) the Prefetch */
  /* Unit is not about to cancel the instruction.                         */

  return COREINT.newinstr
         && (COREINT.stateE >= 0)
         && armul8pu_notcancelling(state);
}
