#include "^.Armulator.armdefs.h"
#include "^.Armulator.armemu.h"
#include "FPA.h"

/*
 * Emulation of the FPA11 floating-point coprocessor.
 *
 * It's instruction-based only, and some minor details of the FPCR may
 * not be quite right, but it should be good enough to fool the punter
 * and the FPA Support Code.
 *
 * Asynchronous operation is simulated (roughly) by exceptions that
 * would be asynchronous always being taken by the next FP instruction -
 * on a real FPA it might be delayed for a number of instructions.
 *
 * Many algorithms have been copied from the FPASC. FPA behaviour has
 * been examined experimentally, and deduced from the FPASC.
 *
 * Kevin Bracey, December 1999
 */

#undef NE
#undef ADDCARRY
#undef ADCCARRY
#undef SUBCARRY
#undef SBCCARRY

typedef struct FPAvalue
{
    ARMword sue;
    ARMword mhi;
    ARMword mlo;
} FPAvalue;

typedef struct FPAwork
{
    FPAvalue OP1;
    FPAvalue OP2;
    ARMword RNDexp;
    ARMword Rarith;
} FPAwork;

#define StartMonadic ARMword OP1sue = w->OP1.sue, OP1mhi = w->OP1.mhi, OP1mlo = w->OP1.mlo, RNDexp, Rarith
#define StartDyadic ARMword OP1sue = w->OP1.sue, OP1mhi = w->OP1.mhi, OP1mlo = w->OP1.mlo, OP2sue = w->OP2.sue, OP2mhi = w->OP2.mhi, OP2mlo = w->OP2.mlo, RNDexp, Rarith
#define FinishArith w->OP1.sue = OP1sue; w->OP1.mhi = OP1mhi; w->OP1.mlo = OP1mlo; w->RNDexp = RNDexp; w->Rarith = Rarith; return ARMul_DONE;

static const FPAvalue FPAConstTable[8] =
{
    { 0x00000000, 0x00000000, 0x00000000 }, /*  0   */
    { 0x00003FFF, 0x80000000, 0x00000000 }, /*  1   */
    { 0x00004000, 0x80000000, 0x00000000 }, /*  2   */
    { 0x00004000, 0xC0000000, 0x00000000 }, /*  3   */
    { 0x00004001, 0x80000000, 0x00000000 }, /*  4   */
    { 0x00004001, 0xA0000000, 0x00000000 }, /*  5   */
    { 0x00003FFE, 0x80000000, 0x00000000 }, /*  0.5 */
    { 0x00004002, 0xA0000000, 0x00000000 }, /* 10   */
};

typedef struct FPA_State
{
    FPAvalue Reg[8];
    ARMword fpsr;
    ARMword fpcr;
} FPA_State;

static FPA_State FPA;

/* FPAvalue bits */
#define Sign     (1u<<31)
#define Uncommon (1u<<30)
#define ToExp_mask (0xFFFFFFFF - Sign - Uncommon)

/* Single precision fields */

#define SExp_len 8
#define SExp_pos 23
#define SExp_mask 0x7F800000
#define SExp_bias 0x7F

/* Double precision fields */

#define DExp_len 11
#define DExp_pos 20
#define DExp_mask 0x7FF00000
#define DExp_bias 0x3FF

/* Extended and Internal precision fields */

#define EIExp_len 15
#define EIExp_mask 0x7FFF
#define EIExp_bias 0x3FFF
#define EIUnits_bit (1u<<31)

/* FPSR bits */
#define SysID_pos  24
#define SysID_mask (0xFFu<<SysID_pos)
#define IXE (1u<<20)
#define UFE (1u<<19)
#define OFE (1u<<18)
#define DZE (1u<<17)
#define IOE (1u<<16)
#define AC (1u<<12)
#define EP (1u<<11)
#define SO (1u<<10)
#define NE (1u<<9)
#define ND (1u<<8)
#define IXC (1u<<4)
#define UFC (1u<<3)
#define OFC (1u<<2)
#define DZC (1u<<1)
#define IOC (1u<<0)

/* FPCR bits */
#define RU (1u<<31)
#define IE (1u<<28)
#define MO (1u<<27)
#define EO (1u<<26)
#define OP1_mask (15u<<20)
#define PR1_pos 19
#define PR1_mask (1u<<PR1_pos)
#define S1_mask (7u<<16)
#define OP2_mask (1u<<15)
#define DS_pos 12
#define DS_mask (7u<<DS_pos)
#define SB (1u<<11)
#define AB (1u<<10)
#define RE (1u<<9)
#define DA (1u<<8)
#define PR2_mask (1u<<7)
#define RM_pos 5
#define RM_mask (3u<<RM_pos)
#define OP3_mask (1u<<4)
#define S2_Ibit (1u<<3)
#define S2_mask (15)

#define PR_mask (PR1_mask+PR2_mask)
#define OP_mask (OP1_mask+OP2_mask+OP3_mask)

/* Rounding mode values */
#define RM_Nearest (0u<<RM_pos)
#define RM_PlusInf (1u<<RM_pos)
#define RM_MinusInf (2u<<RM_pos)
#define RM_Zero (3u<<RM_pos)

#define AU_mask (OP_mask | PR_mask | S1_mask | DS_mask | RM_mask | S2_mask)

/* Instruction bits */

#define DT_PR2 (1u<<15)
#define DT_PR1 (1u<<22)

#define DT_PR_mask (DT_PR1+DT_PR2)

#define size_S 0
#define size_D DT_PR2
#define size_E DT_PR1
#define size_P (DT_PR1+DT_PR2)

#define RT_ARMreg_pos 12

/* The following bit distinguishes CMF(E)s from CNF(E)s. */
#define CompNeg_bit (1u<<21)

/* The bit to indicate that the operation is monadic and not dyadic. */
#define DO_monadic (1u<<15)

/* The bit to indicate that this is a subtraction (SUF or RSF) rather than an
 * addition (ADF). */
#define SubNotAdd_bit (1u<<21)

/* The bit to indicate that this is a reverse subtraction (RSF) rather than
 * an addition or ordinary subtraction (ADF or SUF). */
#define RSF_bit (1u<<20)

/* The bit to indicate that this is a reverse division (RDF or FRD) rather
 * than a normal division (DVF or FDV). */
#define RevDiv_bit (1u<<20)

/* The bit to indicate that this is a "fast" multiplication or division (FML,
 * FDV or FRD), rather than the normal version (MUF, DVF or RDF). */
#define Fast_bit (1u<<23)

/* The bit to indicate that a move-type instruction (MVF, MNF or ABS) is an
 * MNF. */
#define MNF_bit (1u<<20)

/* The bit to indicate that a move-type instruction (MVF, MNF or ABS) is an
 * ABS. */
#define ABS_bit (1u<<21)

/* Comparison results */
#define Comp_GT 0x20000000u
#define Comp_EQ 0x60000000u
#define Comp_LT 0x80000000u


/* Macro to check pending exceptions. Placed at the top of all
 * instructions except RFC.
 */
#define CheckBounce if (FPA.fpcr & (SB|AB)) return ARMul_CANT

/* Synchronous bounce (unimplemented instruction etc). Set SB and
 * refuse instruction.
 */
#define SyncBounce do { FPA.fpcr |= SB; return ARMul_CANT; } while (0)

/* Arithmetic exceptions. Fill FPCR up with fields from instruction.
 * If emulating synchronous operation, also set SB and refuse the
 * instruction. Otherwise, set AB and accept the instruction. Next
 * FP instruction will bounce via CheckArith.
 */
#define PrepBounce(b) do { if (FPA.fpsr & SO)                         \
                            SyncBounce;                               \
                        FPA.fpcr = (instr & AU_mask) | AB | (b);      \
                        return ARMul_DONE;                            \
                      } while (0)

#define PrepBounceS(b) do {                                           \
                        FPA.fpcr = (instr & AU_mask) | AB | (b);      \
                        return ARMul_CANT;                            \
                      } while (0)

#define RoundBounce do { FPA.fpcr = fpcr;                              \
                         FPA.Reg[dest] = w->OP1;                       \
                         if (FPA.fpsr & SO)                            \
                             return ARMul_CANT;                        \
                         else                                          \
                             return ARMul_DONE;                        \
                       } while (0)

#define Denorm(mhi,mlo,grs,sh) do {                     \
                       ARMword words, t1, t2;           \
                       t1 = sh >> 5;                    \
                       t2 = sh &~ (t1 << 5);            \
                       words = t1;                      \
                       t1 = 32-t2;                      \
                       grs = mlo << t1;                 \
                       mlo = (mlo >> t2) | (mhi << t1); \
                       mhi = (mhi >> t2);               \
                       if (words == 1 || words >= 3)    \
                       {                                \
                           grs = grs | (grs << 2);      \
                           grs = mlo | (grs >> 2);      \
                           mlo = mhi;                   \
                           mhi = 0;                     \
                       }                                \
                       if (words >= 2)                  \
                       {                                \
                           grs |= mlo;                  \
                           grs = grs | (grs << 2);      \
                           grs = mhi | (grs >> 2);      \
                           mlo = 0;                     \
                           mhi = 0;                     \
                       }                                \
                     } while (0)

#define POS(i) ( (~(i)) >> 31 )
#define NEG(i) ( (i) >> 31 )

#define ADDCARRY(a,b,r)  (r < a)
#define ADCCARRY(a,b,r)  (NEG(a) && NEG(b) || \
                          NEG(a) && POS(r) || \
                          NEG(b) && POS(r))
#define SUBCARRY(a,b,r)  (a >= b)
#define SBCCARRY(a,b,r)  (NEG(a) && POS(b) || \
                          NEG(a) && POS(r) || \
                          POS(b) && POS(r))

#define Split16(resh, resl, src) do { resh = src >> 16; resl = src &~ (resh << 16); } while (0)

#define Mul64(resh, resl, op1h, op1l, op2, add) do {       \
                       ARMword t1, t2, t3, t4, c;          \
                       Split16(t1, t2, op2);               \
                       t3 = op1h * t1 + add;               \
                       t1 = op1l * t1;                     \
                       resl = t2 * op1l;                   \
                       t4 = resl;                          \
                       resl = t4 + (t1 << 16);             \
                       c = ADDCARRY(t4, (t1 << 16), resl); \
                       t3 = t3 + (t1 >> 16) + c;           \
                       t2 = op1h * t2;                     \
                       t4 = resl;                          \
                       resl = t4 + (t2 << 16);             \
                       c = ADDCARRY(t4, (t2 << 16), resl); \
                       resh = t3 + (t2 >> 16) + c;         \
                     } while (0)


static void RoundNum(ARMword RNDprm, long *RNDdirp, FPAwork *w, int *Movfp);

static void NormaliseOp(ARMword *mhip, ARMword *mlop, ARMword *RNDexpp)
{
    ARMword mhi = *mhip, mlo = *mlop, RNDexp = *RNDexpp;
    int shift;;

    if (mhi == 0)
    {
        mhi = mlo;
        mlo = 0;
        RNDexp -= 32;
    }
    shift = 0;
    if ((mhi >> 16) == 0) mhi <<= 16, shift += 16;
    if ((mhi >> 24) == 0) mhi <<=  8, shift +=  8;
    if ((mhi >> 28) == 0) mhi <<=  4, shift +=  4;
    if ((mhi >> 30) == 0) mhi <<=  2, shift +=  2;
    if ((mhi >> 31) == 0) mhi <<=  1, shift +=  1;

    *mhip = mhi | (mlo >> (32 - shift));
    *mlop = mlo << shift;
    *RNDexpp = RNDexp - shift;
}

static unsigned FPA_RFC(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    if (!state->NtransSig)
        SyncBounce;

    *value = FPA.fpcr;

    FPA.fpcr &=~ (SB|AB|DA);

    return ARMul_DONE;
}

static unsigned FPA_RFS(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    CheckBounce;

    *value = FPA.fpsr;

    return ARMul_DONE;
}

static unsigned FPA_FIX(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    FPAwork w;
    ARMword RNDprm, Rtmp;
    long RNDdir;
    int Movf;

    CheckBounce;

    /* Yes, we do support constants, even though the data sheet forbids it */
    if (instr & S2_Ibit)
        w.OP1 = FPAConstTable[instr & (S2_mask - S2_Ibit)];
    else
        w.OP1 = FPA.Reg[instr & S2_mask];

    if (w.OP1.sue & Uncommon)
        PrepBounceS(IE);

    w.Rarith = w.OP1.sue & ToExp_mask;
    w.OP1.sue &= Sign;

    /* Put the integer at the bottom of the mantissa */
    w.RNDexp = EIExp_bias + 63;
    if (w.RNDexp <= w.Rarith)
    {
        FPA.fpcr = AB | (instr & AU_mask); /* Not sure about IE flag - real FPA seems unpredictable */
        return ARMul_CANT;
    }

    Rtmp = w.RNDexp - w.Rarith;
    Denorm(w.OP1.mhi, w.OP1.mlo, w.Rarith, Rtmp);

    /* Round (extended, whichever direction) */
    RNDprm = (instr & RM_mask) | (2 << RM_pos+2);
    RNDdir = 0;
    RoundNum(RNDprm, &RNDdir, &w, &Movf); /* MO can't happen */

    if (w.OP1.sue) /* Negative */
    {
        ARMword c;
        Rtmp = w.OP1.mlo;
        w.OP1.mlo = -Rtmp; c = SUBCARRY(0, Rtmp, w.OP1.mlo);
        w.OP1.mhi = -w.OP1.mhi + c - 1;
    }

    /* Check top 33 bits all the same (ie signed 32-bit result) */
    Rtmp = NEG(w.OP1.mlo) ? 0xFFFFFFFF : 0;
    if (w.OP1.mhi != Rtmp)
    {
        FPA.fpcr = AB | (instr & AU_mask);
        if (RNDdir) FPA.fpcr |= IE; /* Still not sure about IE */
        return ARMul_CANT;
    }

    if (RNDdir)
    {
        /* Inexact.. */
        if (FPA.fpsr & IXE)
        {
            FPA.fpcr = IE | AB | RE | (instr & AU_mask);
            if (RNDdir > 0) FPA.fpcr |= RU;
        }
        else
            FPA.fpsr |= IXC;
    }

    *value = w.OP1.mlo;

    return ARMul_DONE;
}

static unsigned FPA_Compare(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    FPAwork w;

    CheckBounce;

    w.OP1 = FPA.Reg[(instr >> 16) & 7];

    if (instr & S2_Ibit)
        w.OP2 = FPAConstTable[instr & 7];
    else
        w.OP2 = FPA.Reg[instr & 7];

    if ((w.OP1.sue & Uncommon) || (w.OP2.sue & Uncommon))
        PrepBounceS(0);

    if (!(instr & CompNeg_bit))
        w.OP2.sue ^= Sign;

    if ((w.OP1.sue & EIExp_mask) == (w.OP2.sue & EIExp_mask) &&
        w.OP1.mhi == w.OP2.mhi &&
        w.OP1.mlo == w.OP2.mlo)
    {
        /* Equal magnitude. Result depends on signs */

        if ((w.OP1.sue ^ w.OP2.sue) & Sign)
            /* Signs different = equal (we're doing CNF, remember) */
            *value = Comp_EQ;
        else if ((w.OP1.sue & EIExp_mask) == 0 &&
                  w.OP1.mhi == 0 && w.OP1.mlo == 0)
            /* OP1 (and hence OP2) is a zero. They're equal */
            *value = Comp_EQ;
        else if (w.OP1.sue & Sign)
            *value = Comp_LT;
        else
            *value = Comp_GT;
    }
    else
    {
        /* Different magnitudes */
        if ((w.OP1.sue & EIExp_mask) > (w.OP2.sue & EIExp_mask))
            *value = (w.OP1.sue & Sign) ? Comp_LT : Comp_GT;
        else
            *value = (w.OP2.sue & Sign) ? Comp_LT : Comp_GT;
    }

    return ARMul_DONE;
}

static unsigned FPA_FLT(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    FPAwork w;
    ARMword RNDprm;
    int Movf;
    long RNDdir;
    ARMword dest = (instr & DS_mask) >> DS_pos;

    CheckBounce;

    w.OP1.mlo = 0;
    w.OP1.sue = value & Sign;
    if (w.OP1.sue)
    {
        w.OP1.mhi = -value;
    }
    else
    {
        w.OP1.mhi = value;
        if (w.OP1.mhi == 0)
        {
            w.RNDexp = 0;
            w.Rarith = 0;
            goto done;
        }
    }

    w.RNDexp = EIExp_bias + 31;
    w.Rarith = 0;

    NormaliseOp(&w.OP1.mhi, &w.OP1.mlo, &w.RNDexp);

  done:

    RNDprm = instr & (RM_mask|PR2_mask);
    RNDprm |= (instr & PR1_mask) >> (PR1_pos - (RM_pos + 3));
    RNDdir = 0;

    RoundNum(RNDprm, &RNDdir, &w, &Movf);

    w.OP1.sue |= w.RNDexp;
    if (RNDdir)
    {
        /* Inexact.. */
        if (FPA.fpsr & IXE)
            SyncBounce;         /* Can't we round bounce? FPA+FPASC docs imply we */
        else                    /* could, but I can't persuade my FPA11 to do it */
            FPA.fpsr |= IXC;
    }

    FPA.Reg[dest] = w.OP1;

    return ARMul_DONE;
}

static unsigned FPA_WFS(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    CheckBounce;

    FPA.fpsr = (FPA.fpsr & SysID_mask) | (value &~ SysID_mask);

    return ARMul_DONE;
}

static unsigned FPA_WFC(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    if (!state->NtransSig)
        SyncBounce;

    CheckBounce;

    FPA.fpcr = (FPA.fpcr &~ (SB|AB|DA)) | (value & (SB|AB|DA));

    return ARMul_DONE;
}

/* MVF, MNF, or ABS. */
static unsigned FPA_Move(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartMonadic;

    CheckBounce;

    if (OP1sue & Uncommon)
        PrepBounce(0);

    /* The operation is trivial; we just need to turn the input parameters into
     * the correct form for the output, fiddling with the sign. */
    RNDexp = OP1sue & ToExp_mask;
    OP1sue &= Sign;
    Rarith = 0;

    if (instr & MNF_bit)
        OP1sue ^= Sign;
    if (instr & ABS_bit)
        OP1sue &=~ Sign;

    FinishArith;
}

static unsigned FPA_URD(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartMonadic;

    CheckBounce;

    if (OP1sue & Uncommon)
        PrepBounce(0);

    Rarith = OP1sue & ToExp_mask;
    OP1sue &= Sign;

    /* How shall we shift it? What exponent do we want to
     * plonk the integer at the base of the mantissa? */
    RNDexp = EIExp_bias + 23;
    if (instr & PR2_mask) RNDexp = EIExp_bias + 52;
    if (instr & PR1_mask) RNDexp = EIExp_bias + 63;

    if (RNDexp <= Rarith)
    {
        /* The exponent is already as big as what we want. Just return it,
         * an the standard rounding will truncate to being an integer. */
        RNDexp = Rarith;
        Rarith = 0;
    }
    else
    {
        ARMword Rtmp = RNDexp - Rarith;
        /* We need to increase the exponent, and slide the mantissa down.
         * Then the rounding will get us to an integer. However, we will
         * be unnormalised, with the uncommon bit not set.
         * NRM is the instruction to sort this out (only other legal
         * operations are STFE/LDFE and SFM/LFM).
         */
        Denorm(OP1mhi, OP1mlo, Rarith, Rtmp);
    }

    FinishArith;
}

static unsigned FPA_NRM(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartMonadic;

    CheckBounce;

    if (OP1sue & Uncommon)
        PrepBounce(0);

    /* Remarkably similar to MVF, but we have to cope with URD results (ie
     * unnormalised values with the uncommon bit equal to zero)
     */

    RNDexp = OP1sue & ToExp_mask;
    OP1sue &= Sign;
    Rarith = 0;

    if ((OP1mhi & EIUnits_bit) == 0)
    {
        if ((OP1mhi | OP1mlo) == 0)
            /* It's a zero. Set the exponent field to zero */
            RNDexp = 0;
        else
            NormaliseOp(&OP1mhi, &OP1mlo, &RNDexp);
    }

    FinishArith;
}

/* ADF, SUF and RSF */
static unsigned FPA_AddSub(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartDyadic;
    ARMword Rtmp, Rtmp2, temp, R14;

    CheckBounce;

    if (OP1sue & Uncommon || OP2sue & Uncommon)
        PrepBounce(0);

    if (instr & SubNotAdd_bit)
        OP2sue ^= Sign;

    if (instr & RSF_bit)
        OP2sue ^= Sign, OP1sue ^= Sign;

    Rarith = OP1sue << (32-EIExp_len);
    temp = OP2sue << (32-EIExp_len);
    Rtmp = Rarith - temp;
    R14 = OP1sue ^ OP2sue;
    OP1sue &= Sign;
    RNDexp = Rarith >> (32-EIExp_len);
    if (Rarith == temp)
    {
        Rtmp2 = 0;
    }
    else
    {
        if (Rarith < temp)
        {
            Rarith = -Rtmp >> (32-EIExp_len);
            RNDexp += Rarith;
            Denorm(OP1mhi, OP1mlo, Rtmp, Rarith);
            Rtmp2 = 0;
        }
        else
        {
            Rarith = Rtmp >> (32-EIExp_len);
            Denorm(OP2mhi, OP2mlo, Rtmp2, Rarith);
            Rtmp = 0;
        }
    }

    if (!(R14 & Sign))
    {
        ARMword carry;

        /* Magnitude addition */
        Rarith = Rtmp + Rtmp2; /* one of Rtmp, Rtmp2 is 0, so no carry */
        temp = OP1mlo;
        OP1mlo = temp + OP2mlo; carry = ADDCARRY(temp, OP2mlo, OP1mlo);
        temp = OP1mhi;
        OP1mhi = temp + OP2mhi + carry; carry = ADCCARRY(temp, OP2mhi, OP1mhi);
        if (carry)
        {
            RNDexp += 1;

            Rarith = Rarith | (Rarith << 1);
            Rarith = (OP1mlo << 31) | (Rarith >> 1);
            OP1mlo = (OP1mhi << 31) | (OP1mlo >> 1);
            OP1mhi =     (1u << 31) | (OP1mhi >> 1);
        }
    }
    else
    {
        /* Magnitude subtraction */
        ARMword carry;

        Rarith = Rtmp - Rtmp2; carry = SUBCARRY(Rtmp, Rtmp2, Rarith);
        temp = OP1mlo;
        OP1mlo = temp - OP2mlo + carry - 1; carry = SBCCARRY(temp, OP2mlo, OP1mlo);
        temp = OP1mhi;
        OP1mhi = temp - OP2mhi + carry - 1; carry = SBCCARRY(temp, OP2mhi, OP1mhi);
        if (!carry)
        {
            /* Reverse sign and 2's complement mantissa */
            OP1sue ^= Sign;
            temp = Rarith;
            Rarith = 0 - temp; carry = SUBCARRY(0, temp, Rarith);
            temp = OP1mlo;
            OP1mlo = 0 - temp + carry - 1; carry = SBCCARRY(0, temp, OP1mlo);
            OP1mhi = 0 - OP1mhi + carry - 1;
        }

        if (!(OP1mhi & EIUnits_bit))
        {
            /* Need to normalise */
            OP1mhi = (OP1mhi << 1) | (OP1mlo >> 31);
            OP1mlo = (OP1mlo << 1) | (Rarith >> 31);
            Rarith = (Rarith << 1);
            RNDexp -= 1;

            /* Still not normalised? */
            if (!(OP1mhi & EIUnits_bit))
            {
                if (OP1mhi | OP1mlo)
                {
                    NormaliseOp(&OP1mhi, &OP1mlo, &RNDexp);
                }
                else
                {
                    /* It's a zero! */
                    if ((instr & RM_mask) == RM_MinusInf)
                        OP1sue = Sign;
                    else
                        OP1sue = 0;
                    RNDexp = 0;
                }
            }
        }

    }

    FinishArith;
}

static unsigned FPA_Mult(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartDyadic;
    ARMword Rtmp, Rtmp2, temp, c, z;

    CheckBounce;

    if (OP1sue & Uncommon || OP2sue & Uncommon)
        PrepBounce(IE);

    if (!(OP1mhi & OP2mhi & EIUnits_bit))
    {
        /* One of the operands is zero. */
        OP1sue = (OP1sue ^ OP2sue) & Sign;
        OP1mhi = 0;
        OP1mlo = 0;
        RNDexp = 0;
        Rarith = 0;
        FinishArith;
    }

    Rtmp = OP1sue & ToExp_mask;
    Rtmp2 = OP2sue & ToExp_mask;
    OP1sue = (OP1sue ^ OP2sue) & Sign;
    RNDexp = Rtmp + Rtmp2;
    RNDexp -= EIExp_bias - 1;

    if (!(instr & Fast_bit))
    {
        ARMword OP1sue, Rfpsr, Rins, R14;
        Split16(OP1sue, Rfpsr, OP1mhi);
        Mul64(OP1sue, Rfpsr, OP1sue, Rfpsr, OP2mhi, 0);
        Split16(Rins, R14, OP1mlo);
        Mul64(Rins, R14, Rins, R14, OP2mlo, 0);
        temp = Rfpsr;
        Rfpsr = temp + Rins; c = ADDCARRY(temp, Rins, Rfpsr);
        OP1sue += c;
        Rins = Rfpsr + R14; c = ADDCARRY(Rfpsr, R14, Rins);
        temp = Rfpsr;
        Rfpsr = temp + OP1sue + c; c = ADCCARRY(temp, OP1sue, Rfpsr);
        OP1sue += c;
        Rtmp = OP1mhi - OP1mlo; c = SUBCARRY(OP1mhi, OP1mlo, Rtmp); z = (Rtmp == 0);
        OP1mhi = 0;
        Rarith = 0;
        if (!c)
        {
            OP1mhi = ~OP1mhi;
            OP1mlo = OP2mhi - OP2mlo;
        }
        if (!z)
        {
            Rtmp2 = OP2mlo - OP2mhi; c = SUBCARRY(OP2mlo, OP2mhi, Rtmp2); z = (Rtmp2 == 0);
        }
        if (z)
            OP1mhi = 0;
        if (!c)
        {
            OP1mhi = ~OP1mhi;
            Rarith -= Rtmp;
        }
        Split16(OP2mhi, OP2mlo, Rtmp);
        Mul64(OP1mlo, Rarith, OP2mhi, OP2mlo, Rtmp2, Rarith);

        temp = Rarith;
        Rarith = Rins + temp; c = ADDCARRY(Rins, temp, Rarith);
        temp = OP1mlo;
        OP1mlo = Rfpsr + temp + c; c = ADCCARRY(Rfpsr, temp, OP1mlo);
        temp = OP1mhi;
        OP1mhi = OP1sue + temp + c; c = ADCCARRY(OP1sue, temp, OP1mhi);

        R14 |= (R14 << 2);
        Rarith |= (R14 >> 2);

        if (!(OP1mhi & EIUnits_bit))
        {
            /* Need to normalise */
            OP1mhi = (OP1mhi << 1) + (OP1mlo >> 31);
            OP1mlo = (OP1mlo << 1) + (Rarith >> 31);
            Rarith = (Rarith << 1);
            RNDexp -= 1;
        }
    }
    else
    {
        /* FML - assume the bottom 32-bits of the mantissas are zero */
        Split16(OP2mlo, Rarith, OP2mhi);
        Mul64(OP1mhi, OP1mlo, OP2mlo, Rarith, OP1mhi, 0);
        Rarith = 0;
        if (!(OP1mhi & EIUnits_bit))
        {
            /* Need to normalise */
            OP1mhi = (OP1mhi << 1) | (OP1mlo >> 31);
            OP1mlo = (OP1mlo << 1);
            RNDexp -= 1;
        }
    }

    FinishArith;
}

static unsigned FPA_Div(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    StartDyadic;
    ARMword Rtmp, c;
    ARMword Qmhi, Qmmi, Qmlo, bits, reqbits, OP1c, temp, shift;

    CheckBounce;

    if (OP1sue & Uncommon || OP2sue & Uncommon)
        PrepBounce(IE);

    /* Arrange it so OP1 is dividend, OP2 is divisor */
    if (instr & RevDiv_bit)
    {
        Rtmp = OP1sue; OP1sue = OP2sue; OP2sue = Rtmp;
        Rtmp = OP1mhi; OP1mhi = OP2mhi; OP2mhi = Rtmp;
        Rtmp = OP1mlo; OP1mlo = OP2mlo; OP2mlo = Rtmp;
    }

    /* Divide by zero? */
    if ((OP2mhi | OP2mlo) == 0)
        PrepBounce(IE);

    if ((OP1mhi | OP1mlo) == 0)
    {
        /* Dividend is 0, so result is zero */
        OP1sue = (OP1sue ^ OP2sue) & Sign;
        OP1mhi = 0;
        OP1mlo = 0;
        RNDexp = 0;
        Rarith = 0;
        FinishArith;

        return ARMul_DONE;
    }

    /* Get the result sign and prospective exponent */
    RNDexp = (OP1sue & ToExp_mask) - (OP2sue & ToExp_mask) + EIExp_bias;
    OP1sue = (OP1sue ^ OP2sue) & Sign;

    /* We do this by long division, just as the FPA does. The FPASC has
     * all sorts of clever stuff to do it fast, but it's very complex, and
     * not justified in this circumstance.
     *
     * (Qmhi,Qmmi,Qmlo) will be the quotient.
     * (OP1c,OP1mhi,OP1mlo) is the dividend - OP1c contains one bit only */
    OP1c = 0;
    Qmhi = Qmmi = Qmlo = 0;

    /* How many bits of quotient do we need? The number of bits in the
     * destination size, plus one guard bit, plus a round bit. We get the
     * sticky bit from the division remainder. */
    reqbits = 24 + 2;
    if (instr & PR2_mask) reqbits = 53 + 2;
    if (instr & PR1_mask) reqbits = 64 + 2;

    for (bits = 0; bits < reqbits && (OP1c | OP1mhi | OP1mlo); bits++)
    {
        /* Jack up the quotient */
        Qmhi = (Qmhi << 1) | (Qmmi >> 31);
        Qmmi = (Qmmi << 1) | (Qmlo >> 31);
        Qmlo = (Qmlo << 1);
        /* Work out the next bit */
        if (OP1c || OP2mhi < OP1mhi || (OP2mhi == OP1mhi && OP2mlo <= OP1mlo))
        {
            Qmlo |= 1;
            temp = OP1mlo;
            OP1mlo = temp - OP2mlo; c = SUBCARRY(temp, OP2mlo, OP1mlo);
            OP1mhi = OP1mhi - OP2mhi + c - 1;
            OP1c = 0;
        }
        /* Jack up the dividend */
        OP1c   =                 (OP1mhi >> 31);
        OP1mhi = (OP1mhi << 1) | (OP1mlo >> 31);
        OP1mlo = (OP1mlo << 1);
    }

    /* As we exit the loop, (Qmhi,Qmmi,Qmlo) contains <bits> bits of
     * quotient at the bottom. (OP1c,OP1mhi,OP1mlo) contains the remainder.
     * Pull the result up to the top.
     */
    shift = 96 - bits;

    while (shift >= 32)
    {
        Qmhi = Qmmi;
        Qmmi = Qmlo;
        Qmlo = 0;
        shift -= 32;
    }

    Qmhi = (Qmhi << shift) | (Qmmi >> (32-shift));
    Qmmi = (Qmmi << shift) | (Qmlo >> (32-shift));
    Qmlo = (Qmlo << shift);

    /* Now, Qmhi/mi/lo contains sufficient digits of quotient to
     * cover the result mantissa, plus one guard bit and one round bit.
     * Fill in the sticky bit by checking the remainder. */
    if (OP1c | OP1mhi | OP1mlo)
        Qmlo |= 1;

    OP1mhi = Qmhi;
    OP1mlo = Qmmi;
    Rarith = Qmlo;

    if (!(OP1mhi & EIUnits_bit))
    {
        /* Need to normalise */
        OP1mhi = (OP1mhi << 1) | (OP1mlo >> 31);
        OP1mlo = (OP1mlo << 1) | (Rarith >> 31);
        Rarith = (Rarith << 1);
        RNDexp -= 1;
    }

    FinishArith;

    return ARMul_DONE;
}

static unsigned FPA_LDF(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    static ARMword reg, wordcount, word[3];

    switch (type)
    {
        case ARMul_FIRST:
            if ((instr & DT_PR_mask) == size_P)
                SyncBounce;

            CheckBounce;
            reg = (instr >> 12) & 7;
            wordcount = 0;
            return ARMul_DONE;

        case ARMul_DATA:
        {
            FPAvalue *Reg = &FPA.Reg[reg];
            ARMword OP1sue, OP1mhi, OP1mlo, sign;
            int zero;

            word[wordcount++] = value;

            switch (instr & DT_PR_mask)
            {
            case size_S: /* only need one word, so must be ready */
                OP1sue = word[0] << 1;
                zero = (OP1sue == 0);
                sign = word[0] & Sign;
                OP1mhi = OP1sue << 7;  /* Fraction in mhi[30:8] */
                OP1sue = OP1sue >> 23; /* Exponent in sue[8:1] */
                if (!zero)
                {
                    /* Rebias exponent and fill in the units bit */
                    OP1sue += (EIExp_bias - SExp_bias) << 1;
                    OP1mhi |= EIUnits_bit;
                }
                OP1sue = sign | (OP1sue >> 1); /* Recombine sign+exponent */
                OP1mlo = 0;
                /* Uncommon if exponent is now 3F80 (denormalised) or 407F (NaN/inf) */
                if ((OP1sue & EIExp_mask) == 0x3F80 ||
                    (OP1sue & EIExp_mask) == 0x407F)
                    OP1sue |= Uncommon;
                Reg->sue = OP1sue;
                Reg->mhi = OP1mhi;
                Reg->mlo = OP1mlo;
                return ARMul_DONE;

            case size_D:
                if (wordcount < 2) return ARMul_INC;
                OP1sue = word[0] << 1;
                OP1mlo = word[1];
                zero = !(OP1sue | OP1mlo);
                sign = word[0] & Sign;
                OP1mhi = OP1sue << 10;          /* Frac. top in mhi[30:11] */
                OP1sue >>= 20;                  /* Exponent in sue[11:1] */
                OP1mhi |= OP1mlo >> 21;         /* Fraction in mhi[30:0],Mlo[31:11] */
                OP1mlo <<= 11;
                if (!zero)
                {
                    OP1sue += (EIExp_bias - DExp_bias) << 1;
                    OP1mhi |= EIUnits_bit;
                }
                OP1sue = sign | (OP1sue >> 1);
                /* Uncommon if exponent is now 3C00 or 43FF */
                if ((OP1sue & EIExp_mask) == 0x3C00 ||
                    (OP1sue & EIExp_mask) == 0x43FF)
                    OP1sue |= Uncommon;
                Reg->sue = OP1sue;
                Reg->mhi = OP1mhi;
                Reg->mlo = OP1mlo;
                return ARMul_DONE;

            case size_E:
                if (wordcount < 3) return ARMul_INC;
                OP1sue = word[0] & 0x80007FFF; /* Ignore reserved bits */
                OP1mhi = word[1];
                OP1mlo = word[2];
                /* Uncommon if exponent = max, or units not zero */
                if ((OP1sue & EIExp_mask) == 0x7FFF || !(OP1mhi & EIUnits_bit))
                    OP1sue |= Uncommon;
                /* Unless it's a zero */
                if ((OP1sue & EIExp_mask) == 0 && OP1mhi == 0 && OP1mlo == 0)
                    OP1sue &=~ Uncommon;
                Reg->sue = OP1sue;
                Reg->mhi = OP1mhi;
                Reg->mlo = OP1mlo;
                return ARMul_DONE;
            }
            break;
        }
    }
    return ARMul_DONE;
}

static unsigned FPA_STF(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    static ARMword word[3], wordcount, words;
    ARMword reg, RNDprm;
    long RNDdir;
    int Movf;
    FPAwork w;

    switch (type)
    {
        case ARMul_FIRST:
            if ((instr & DT_PR_mask) == size_P)
                SyncBounce;

            CheckBounce;
            reg = (instr >> 12) & 7;

            w.OP1 = FPA.Reg[reg];
            w.Rarith = 0;
            RNDdir = 0;
            RNDprm = 0;
            if (instr & DT_PR2) RNDprm |= (1u << (RM_pos + 2));
            if (instr & DT_PR1) RNDprm |= (2u << (RM_pos + 2));

            wordcount = 0;
            words = (RNDprm >> (RM_pos + 2)) + 1;

            switch (words)
            {
            case 1: /* STFS */
                w.RNDexp = w.OP1.sue & ToExp_mask;
                w.OP1.sue &= Sign;

                if (w.OP1.sue & Uncommon)
                {
                    /* Only uncommon value we can handle is a single-precision
                     * infinity or NaN (exponent = 407F, units bit set) */
                    if (w.RNDexp != 0x407F || (w.OP1.mhi & EIUnits_bit) == 0)
                        SyncBounce;
                }
                else
                {
                    /* Can handle any common number as long as its exponent is
                     * in range */
                    if ((w.RNDexp < 0x3F81 || w.RNDexp > 0x407E) && w.RNDexp != 0)
                        SyncBounce;
                }

                if ((w.OP1.mhi & EIUnits_bit) == 0)
                {
                    /* It's a zero. Already done */
                }
                else
                {
                    RoundNum(RNDprm, &RNDdir, &w, &Movf);
                    if (Movf)
                        SyncBounce;
                    if (RNDdir)
                    {
                        /* Inexact.. */
                        if (FPA.fpsr & IXE)
                            SyncBounce;
                        else
                            FPA.fpsr |= IXC;
                    }
                    w.OP1.mhi <<= 1; /* Discard units bit */
                    w.OP1.sue = w.OP1.sue |                           /* Sign */
                                (((w.RNDexp ^ 0x80) & 0xFF) << 23) |  /* Exponent */
                                (w.OP1.mhi >> 9);                     /* Mantissa */
                }
                word[0] = w.OP1.sue;
                return ARMul_DONE;

            case 2: /* STFD */
                w.RNDexp = w.OP1.sue & ToExp_mask;
                w.OP1.sue &= Sign;

                if (w.OP1.sue & Uncommon)
                {
                    /* Only uncommon value we can handle is a double-precision
                     * infinity or NaN (exponent = 43FF, units bit set) */
                    if (w.RNDexp != 0x43FF || (w.OP1.mhi & EIUnits_bit) == 0)
                        SyncBounce;
                }
                else
                {
                    /* Can handle any common number as long as its exponent is
                     * in range */
                    if ((w.RNDexp < 0x3C01 || w.RNDexp > 0x43FE) && w.RNDexp != 0)
                        SyncBounce;
                }

                if ((w.OP1.mhi & EIUnits_bit) == 0)
                {
                    /* It's a zero. Already done */
                }
                else
                {
                    RoundNum(RNDprm, &RNDdir, &w, &Movf);
                    if (Movf)
                        SyncBounce;
                    if (RNDdir)
                    {
                        /* Inexact.. */
                        if (FPA.fpsr & IXE)
                            SyncBounce;
                        else
                            FPA.fpsr |= IXC;
                    }
                    w.OP1.mhi <<= 1; /* Discard units bit */
                    w.OP1.sue = w.OP1.sue |                             /* Sign */
                                (((w.RNDexp ^ 0x400) & 0x7FF) << 20) |  /* Exponent */
                                (w.OP1.mhi >> 12);                      /* Mantissa */
                    w.OP1.mhi = (w.OP1.mhi << 20) | (w.OP1.mlo >> 11);
                }
                word[0] = w.OP1.sue;
                word[1] = w.OP1.mhi;
                return ARMul_DONE;

            case 3: /* STFE */
                w.RNDexp = w.OP1.sue & ToExp_mask;

                /* Only uncommon value we can handle is a double-precision
                 * infinity or NaN (exponent = 7FFF) */
                if ((w.OP1.sue & Uncommon) && w.RNDexp != 0x7FFF)
                    SyncBounce;

                word[0] = w.OP1.sue &~ Uncommon;
                word[1] = w.OP1.mhi;
                word[2] = w.OP1.mlo;
                return ARMul_DONE;
            }

        case ARMul_DATA:
            *value = word[wordcount++];
            if (wordcount == words)
                return ARMul_DONE;
            else
                return ARMul_INC;

        default: return ARMul_DONE;
    }

}

static unsigned FPA_MCR1(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    ARMword op = (instr >> 21) & 7;

    /* Do weird stuff to the instruction - copy bits 18:16 into 14:12. This is for the
     * benefit of FLT, but it happens to all FPRTs. The only place this should be
     * visible externally is on a FIX bounce. Also, we set bit 15 always (not sure
     * what exactly it should be set to)
     */

    instr &=~ 0x00007000;
    instr |= (instr & 0x00070000) >> 4;
    instr |= 0x00008000;

    switch (op)
    {
        case 0: return FPA_FLT(state, type, instr, value);
        case 1: return FPA_WFS(state, type, instr, value);
        case 2: return FPA_WFC(state, type, instr, value);
    }

    SyncBounce;
}

static unsigned FPA_MRC1(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    ARMword op = (instr >> 21) & 7;

    /* Do weird stuff to the instruction - copy bits 18:16 into 14:12. This is for the
     * benefit of FLT, but it happens to all FPRTs. The only place this should be
     * visible externally is on a FIX exception. Also, we set bit 15 always (not sure
     * what exactly it should be set to)
     */

    instr &=~ 0x00007000;
    instr |= (instr & 0x00070000) >> 4;
    instr |= 0x00008000;

    switch (op)
    {
        case 0: return FPA_FIX(state, type, instr, value);
        case 1: return FPA_RFS(state, type, instr, value);
        case 2: return FPA_RFC(state, type, instr, value);
        case 4:
        case 5:
        case 6:
        case 7: return FPA_Compare(state, type, instr, value);
    }

    SyncBounce;
}

/*
 * Rounding table. This is a 64 byte table: the byte with index N refers to a
 * case, controlled by the individual bits of N as follows:
 *
 * Bits 5,4 = 00: Rounding mode is to Nearest;
 * Bits 5,4 = 01: Rounding mode is to Plus Infinity;
 * Bits 5,4 = 10: Rounding mode is to Minus Infinity;
 * Bits 5,4 = 11: Rounding mode is to Zero;
 * Bit 3 = 0:     Value being rounded is positive;
 * Bit 3 = 1:     Value being rounded is negative;
 * Bit 2 = 0:     Value being rounded has a "round" bit of 0;
 * Bit 2 = 1:     Value being rounded has a "round" bit of 1;
 * Bit 1 = 0:     Value being rounded has a "sticky" bit of 0;
 * Bit 1 = 1:     Value being rounded has a "sticky" bit of 1;
 * Bit 0 = 0:     The Nearest tie case discrimination bit is 0;
 * Bit 0 = 1:     The Nearest tie case discrimination bit is 1.
 *
 * The "Nearest tie case discrimination bit" is 1 if the rounding direction
 * so far is negative, or if it is zero and the least significant bit of the
 * result mantissa is 1. It is 0 if the rounding direction so far is
 * positive, or if it is zero and the least significant bit of the result
 * mantissa is 0. If 1, it indicates that the tie case in rounding to Nearest
 * should be resolved by rounding up in magnitude; if 0, by rounding down.
 *
 * The entries in the table are:
 *   3 to indicate the result should be rounded up in magnitude;
 *   0 to indicate the result is exact;
 *   254 to indicate the result should be rounded down in magnitude;
 *
 * This encoding is chosen to have the following properties:
 *   Bit 0 is 1 if we need to increment the mantissa, 0 if not;
 *   Bit 1 is 1 if we need to update the direction of rounding so far;
 *   If bit 1 is 1, a suitable new value for the direction of rounding so
 *     far is the whole byte, shifted left by 24 bits.
 */
static const unsigned char RoundTable[64] =
{
    0,  0,254,254,254,  3,  3,  3,   /* Nearest, positive */
    0,  0,254,254,254,  3,  3,  3,   /* Nearest, negative */
    0,  0,  3,  3,  3,  3,  3,  3,   /* Plus infinity, positive */
    0,  0,254,254,254,254,254,254,   /* Plus infinity, negative */
    0,  0,254,254,254,254,254,254,   /* Minus infinity, positive */
    0,  0,  3,  3,  3,  3,  3,  3,   /* Minus infinity, negative */
    0,  0,254,254,254,254,254,254,   /* Zero, positive */
    0,  0,254,254,254,254,254,254    /* Zero, negative */
};

static void RoundNum(ARMword RNDprm, long *RNDdirp, FPAwork *w, int *Movfp)
{
    ARMword OP1sue, OP1mhi, OP1mlo, Rarith, RNDexp;
    ARMword Rtmp, round, sticky;
    long RNDdir;
    OP1sue = w->OP1.sue;
    OP1mhi = w->OP1.mhi;
    OP1mlo = w->OP1.mlo;
    Rarith = w->Rarith;
    RNDexp = w->RNDexp;
    RNDdir = *RNDdirp;

    *Movfp = 0;

    switch (RNDprm >> (RM_pos + 2))
    {
    case 0: /* Single - OP1mhi[31:8] are result, OP1mhi[7] is round,
             * OP1mhi[6:0], OP1mlo, Rarith are sticky */
        sticky = Rarith | OP1mlo | (OP1mhi << (32-7));
        round = (OP1mhi >> 7) & 1;
        /* We construct a rounding index as:
         * RRSRKT  (RR=round mode, S=sign, R=round bit, K=sticky, T=tie)
         */
        Rtmp = (OP1sue >> 28) | (RNDprm >> (RM_pos-4)) | (round << 2);
        if (sticky) Rtmp |= 2u;
        if (RNDdir < 0 || (RNDdir == 0 && (OP1mhi & (1u<<8))))
            Rtmp |= 1u;

        /* truncate the mantissa */
        OP1mhi &= 0xFFFFFF00;
        OP1mlo = 0;

        Rarith = RoundTable[Rtmp];
        if (Rarith & 1) /* Round up */
        {
            OP1mhi += 0x100;
            if (OP1mhi == 0) /* Mantissa overflow */
            {
                *Movfp = 1;
                OP1mhi = EIUnits_bit;
                RNDexp += 1;
            }
        }

        if (Rarith & 2) /* Adjust rounding direction */
            RNDdir = Rarith << 24;

        break;

    case 1: /* Double - OP1mhi, OP1mlo[31:11] are result, OP1mlo[10] is round,
             * OP1mlo[9:0], Rarith are sticky */
        sticky = Rarith | (OP1mlo << (32-10));
        round = (OP1mlo >> 10) & 1;
        /* Precision from RNDprm gets in here - compensate below */
        Rtmp = (OP1sue >> 28) | (RNDprm >> (RM_pos-4)) | (round << 2);
        if (sticky) Rtmp |= 2u;
        if (RNDdir < 0 || (RNDdir == 0) && (OP1mlo & (1u<<11)))
            Rtmp |= 1u;

        OP1mlo &= 0xFFFFF800;

        Rarith = RoundTable[Rtmp - 64];
        if (Rarith & 1) /* Round up */
        {
            OP1mlo += 0x800;
            if (OP1mlo == 0)
            {
                if (++OP1mhi == 0) /* Mantissa overflow */
                {
                    *Movfp = 1;
                    OP1mhi = EIUnits_bit;
                    RNDexp += 1;
                }
            }
        }

        if (Rarith & 2) /* Adjust rounding direction */
            RNDdir = Rarith << 24;

        break;

    case 2: /* Extended - OP1mhi, OP1mlo are result, Rarith[31] is round,
             * Rarith[30:0] is sticky */
        sticky = Rarith << 1;
        round = Rarith >> 31;
        /* Precision from RNDprm gets in here - compensate below */
        Rtmp = (OP1sue >> 28) | (RNDprm >> (RM_pos-4)) | (round << 2);
        if (sticky) Rtmp |= 2u;
        if (RNDdir < 0 || (RNDdir == 0) && (OP1mlo & 1))
            Rtmp |= 1u;

        Rarith = RoundTable[Rtmp - 128];
        if (Rarith & 1) /* Round up */
        {
            if (++OP1mlo == 0)
            {
                if (++OP1mhi == 0) /* Mantissa overflow */
                {
                    *Movfp = 1;
                    OP1mhi = EIUnits_bit;
                    RNDexp += 1;
                }
            }
        }

        if (Rarith & 2) /* Adjust rounding direction */
            RNDdir = Rarith << 24;

        break;
    }

    w->OP1.mhi = OP1mhi;
    w->OP1.mlo = OP1mlo;
    w->RNDexp = RNDexp;
    *RNDdirp  = RNDdir;
    w->Rarith = Rarith;
}

static const int FPEExpLimits[6] =
{
    0x3F81, 0x407E,
    0x3C01, 0x43FE,
    0x0000, 0x7FFE
};

static unsigned FPA_RoundResult(ARMul_State *state, unsigned type, ARMword instr, FPAwork *w)
{
    ARMword RNDprm, temp, fpcr;
    long RNDdir;
    int Movf;
    ARMword dest = (instr & DS_mask) >> DS_pos;

    /* Set up a 4-bit round/precision code in RNDprm, aligned
     * to the rounding field position */
    RNDprm = instr & (PR2_mask | RM_mask);
    RNDprm |= (instr & PR1_mask) >> (PR1_pos - (RM_pos + 3));
    RNDdir = 0;

    /* Start to sort out the potential FPCR if we do an AB. */
    fpcr = (instr & AU_mask) | AB | RE;

    RoundNum(RNDprm, &RNDdir, w, &Movf);

    if (Movf)
        fpcr |= MO;

    if (RNDdir)
    {
        fpcr |= IE;
        if (RNDdir > 0)
            fpcr |= RU;
    }

    /* Move overflow bit of exponent into EO bit in FPCR */
    if (w->RNDexp & 0x8000)
        fpcr |= EO;

    w->OP1.sue |= (w->RNDexp & EIExp_mask);

    temp = (RNDprm >> RM_pos) & 3;
    if ((signed) w->RNDexp < FPEExpLimits[temp*2] ||
        (signed) w->RNDexp > FPEExpLimits[temp*2+1])
    {
        /* Note: FPASC 1.07 seems to have a bug here, in that a zero
         * exponent (as found in a zero result) always causes a round to
         * single or double to take the underflow trap (if enabled).
         * The FPA itself, on the other hand, copes with zero results
         * correctly. So, the following code will trap on the FPE, but not
         * the FPA:  MOV R0,#UFE: WFS R0: MVFD F0,#3: MUFD F4,F0,#0
         *
         * We have to let an exact zero result through.
         */
        if (w->RNDexp || w->OP1.mhi || w->OP1.mlo || RNDdir)
            /* Exponent overflow. Whoops */
            RoundBounce;
    }

    if (RNDdir)
    {
        /* Inexact.. */
        if (FPA.fpsr & IXE)
            RoundBounce;
        else
            FPA.fpsr |= IXC;
    }

    FPA.Reg[dest] = w->OP1;

    return ARMul_DONE;
}

static unsigned FPA_Monadic(ARMul_State *state, unsigned type, ARMword instr)
{
    ARMword op = (instr >> 20) & 15;
    FPAwork w;
    unsigned result;

    if (instr & S2_Ibit)
        w.OP1 = FPAConstTable[instr & 7];
    else
        w.OP1 = FPA.Reg[instr & 7];

    switch (op)
    {
        case  0:
        case  1:
        case  2: result = FPA_Move(state, type, instr, &w); break;
        case 14: result = FPA_URD(state, type, instr, &w);  break;
        case 15: result = FPA_NRM(state, type, instr, &w);  break;
        default: SyncBounce;
    }

    if (result != ARMul_DONE)
        return result;

    return FPA_RoundResult(state, type, instr, &w);
}

static unsigned FPA_Dyadic(ARMul_State *state, unsigned type, ARMword instr)
{
    ARMword op = (instr >> 20) & 15;
    FPAwork w;
    unsigned result;

    w.OP1 = FPA.Reg[(instr >> 16) & 7];

    if (instr & S2_Ibit)
        w.OP2 = FPAConstTable[instr & 7];
    else
        w.OP2 = FPA.Reg[instr & 7];

    switch (op)
    {
        case  0:
        case  2:
        case  3: result = FPA_AddSub(state, type, instr, &w); break;

        case  1:
        case  9: result = FPA_Mult(state, type, instr, &w); break;

        case  4:
        case  5:
        case 10:
        case 11: result = FPA_Div(state, type, instr, &w); break;

        default: SyncBounce;
    }

    if (result != ARMul_DONE)
        return result;

    return FPA_RoundResult(state, type, instr, &w);
}

static unsigned FPA_CDP1(ARMul_State *state, unsigned type, ARMword instr)
{
    if ((instr & PR_mask) == PR_mask)
        SyncBounce;

    if (instr & (DO_monadic))
        return FPA_Monadic(state, type, instr);
    else
        return FPA_Dyadic(state, type, instr);
}

static unsigned FPA_LFM(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    static ARMword regcount, wordcount;
    static ARMword reg;

    switch (type)
    {
        case ARMul_FIRST:
            CheckBounce;
            reg = (instr >> 12) & 7;
            regcount = ((instr >> 21) & 2) + ((instr >> 15) & 1);
            if (regcount == 0) regcount = 4;
            wordcount = 0;
            return ARMul_DONE;

        case ARMul_DATA:
        {
            ARMword *data = (ARMword *) &FPA.Reg[reg];
            data[wordcount++] = value;
            if (wordcount == 3)
            {
                data[0] &= (Sign|Uncommon|EIExp_mask); /* Knock out reserved bits */
                /* Force uncommon bit on if the units bit is zero (unless it's a
                 * common zero), or if the exponent is maximum  */
                if ((data[1] & EIUnits_bit) == 0 && ((data[0]<<1)|data[1]|data[2])
                    || (data[0] & EIExp_mask) == 0x7FFF)
                    data[0] |= Uncommon;

                if (--regcount == 0)
                {
                    return ARMul_DONE;
                }
                else
                {
                    wordcount = 0;
                    reg = (reg + 1) & 7;
                }
            }
            return ARMul_INC;
        }

        default: return ARMul_DONE;
    }
}

static unsigned FPA_SFM(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    static ARMword regcount, wordcount;
    static ARMword reg;

    switch (type)
    {
        case ARMul_FIRST:
            CheckBounce;
            reg = (instr >> 12) & 7;
            regcount = ((instr >> 21) & 2) + ((instr >> 15) & 1);
            if (regcount == 0) regcount = 4;
            wordcount = 0;
            return ARMul_DONE;

        case ARMul_DATA:
        {
            const ARMword *data = (const ARMword *) &FPA.Reg[reg];
            *value = data[wordcount++];
            if (wordcount == 3)
            {
                if (--regcount == 0)
                {
                    return ARMul_DONE;
                }
                else
                {
                    wordcount = 0;
                    reg = (reg + 1) & 7;
                }
            }
            return ARMul_INC;
        }

        default: return ARMul_DONE;
    }
}

static unsigned FPA_MCR2(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
    SyncBounce;
}

static unsigned FPA_MRC2(ARMul_State *state, unsigned type, ARMword instr, ARMword *value)
{
    SyncBounce;
}

static unsigned FPA_CDP2(ARMul_State *state, unsigned type, ARMword instr)
{
    SyncBounce;
}


static unsigned FPA_Init(ARMul_State *state)
{
    FPA.fpcr = DA | SB | AB;
    FPA.fpsr = (FPA.fpsr &~ SysID_mask) | (0x81u << SysID_pos);

    return 0;
}

void FPA_Attach(ARMul_State *state)
{
    ARMul_CoProAttach(state, 1, FPA_Init, NULL,
                      FPA_LDF, FPA_STF, FPA_MRC1, FPA_MCR1, FPA_CDP1,
                      NULL, NULL, NULL);
    ARMul_CoProAttach(state, 2, NULL, NULL,
                      FPA_LFM, FPA_SFM, FPA_MRC2, FPA_MCR2, FPA_CDP2,
                      NULL, NULL, NULL);
}

#ifdef DEBUG
void dump_fp_regs(void)
{
    int i;
    fout("        FPCR=%8.8X FPSR=%8.8X", FPA.fpcr, FPA.fpsr);
    for (i=0; i<8; i++)
        fout(" F%d=%8.8X%8.8X%8.8X", i, FPA.Reg[i].sue, FPA.Reg[i].mhi, FPA.Reg[i].mlo);
    fout("\n");
}
#endif

