/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "wimp.h"
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "gadgets.h"
#include "menu.h"
#include "proginfo.h"
#include "iconbar.h"

#include "kernel.h"
#include "swis.h"
#include "constants.h"

ERROR_STRUCT( NOMEMORY, "NoStore" );
ERROR_STRUCT( NOTDIR,   "IsntDir" );

#define WimpVersion    350

static  WimpPollBlock  poll_block;
static  MessagesFD     messages;
static  IdBlock        id_block;

int task_handle          = 0;  /* Wimp task handle */
int iconbar_id           = 0;  /* ID iconbar object */
int menu_iconbar_id      = 0;  /* ID of iconbar menu object */

/*
 */
_kernel_oserror *
error_lookup(_kernel_oserror *err, char *sub)
{
  _kernel_swi_regs reg;

  reg.r[0] = (int)err;
  reg.r[1] = 0;
  reg.r[2] = 0;
  reg.r[3] = 0;
  reg.r[4] = (int)sub;
  reg.r[5] = 0;
  reg.r[6] = 0;
  reg.r[7] = 0;
  return (_kernel_swi(MessageTrans_ErrorLookup, &reg, &reg));
}

/*
 * remove CVS directories and /cvstag files
 */
_kernel_oserror *
remove_cvs(char *root, char *file, int *removed)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  char buffer[96];
  char *filename;
  int type;
  char *path;
  int rem;

  if ((path = malloc(strlen(root)+strlen(file)+5))==NULL)
    return (error_lookup(ERROR(NOMEMORY),NULL));

  strcpy(path,root);
  if (file)
  {
    strcat(path,".");
    strcat(path,file);
  }

  if (strcmp(filename,"/cvstag")==0)     /* .cvstag file */
  {
    reg.r[0] = 27; /* wipe */
    reg.r[1] = (int)path;
    reg.r[2] = 0;
    reg.r[3] = 1<<1;
    err=_kernel_swi(OS_FSControl,&reg,&reg);
    if (removed)
      *removed = 1;
    goto exit_gracefully;
  }
  else if (strcmp(filename,"CVS")==0)    /* CVS directory */
  {
    reg.r[0] = 27; /* wipe */
    reg.r[1] = (int)path;
    reg.r[2] = 0;
    reg.r[3] = 1<<0 | 1<<1;
    err=_kernel_swi(OS_FSControl,&reg,&reg);
    if (removed)
      *removed = 1;
    goto exit_gracefully;
  }

  reg.r[0] = 10;
  reg.r[1] = (int)path;
  reg.r[2] = (int)buffer;
  reg.r[3] = 1;
  reg.r[4] = 0;
  reg.r[5] = sizeof(buffer);
  reg.r[6] = NULL;
  do
  {
    ERR_GOTO(err,_kernel_swi(OS_GBPB,&reg,&reg));
    if (reg.r[4] != -1)
    {
      type = *(int*)(buffer+16);
      filename = buffer+20;
      if (type==2)
      {
        ERR_GOTO(err,remove_cvs(path,filename,&rem));
        if (rem)
          reg.r[4] = 0;
      }
      else
      {
        if (strcmp(filename,"/cvstag")==0)          /* .cvstag file */
        {
          ERR_GOTO(err,remove_cvs(path,filename,&rem));
          if (rem)
            reg.r[4] = 0;
        }
      }
    }
  } while (reg.r[4] != -1);
  if (removed)
    *removed = 0;

exit_gracefully:
  if (path)
    free(path);
  return (err);
}

/*
 * read catalogue info
 */
_kernel_oserror *
read_obj_type(char *path, int *type)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;

  reg.r[0] = 17;
  reg.r[1] = (int)path;
  ERR_GOTO(err,_kernel_swi(OS_File,&reg,&reg));
  *type = reg.r[0];

exit_gracefully:
  return (err);
}

/*
 * find out the object ids
 */
int
attach_other_handlers(int event_code,ToolboxEvent *event,
    			  IdBlock *id_block, void *handle)
{
  _kernel_oserror *err = NULL;
  char obj_name[50];
  int dummy;

  ERR_CHECK(err,toolbox_get_template_name(0,id_block->self_id,obj_name,
      				     sizeof(obj_name),&dummy));

  if (strcmp(obj_name, ICONBAR_NAME) == 0)
    iconbar_id = id_block->self_id;
  else if (strcmp(obj_name, MENU_ICONBAR_NAME) == 0)
    menu_iconbar_id = id_block->self_id;

  return 0;
}
/*
 * Event handler to be called when toolbox event 1 is generated (by click on the
 * 'Quit' entry of the iconbar menu.
 */
int
quit_event(int event_code, ToolboxEvent *event,IdBlock *id_block, void *handle)
{
  event_code = event_code;
  event = event;
  id_block = id_block;
  handle = handle;

  exit(0);
  return(1);
}

/*
 * Message handler to be called on receipt of a Quit or PreQuit message from
 * the Wimp.
 */
int
quit_message(WimpMessage *message, void *handle)
{
  message = message;
  handle = handle;

  exit(0);
  return(1);
}

/*
 * message_data_open
 *
 */
int
message_data_open(WimpMessage *message, void *handle)
{
  _kernel_oserror *err = NULL;
  WimpMessage msg;
  int obj_type;

  handle=handle;

  if (message->hdr.sender == task_handle)
    goto exit_gracefully;

  msg = *message;
  msg.hdr.your_ref = msg.hdr.my_ref;

  ERR_GOTO(err,read_obj_type(message->data.data_load_ack.leaf_name,&obj_type));
  if (obj_type!=2)
  {
    ERR_GOTO(err,
       error_lookup(ERROR(NOTDIR),message->data.data_load_ack.leaf_name));
  }
  _swix(Hourglass_On,0);
  ERR_GOTO(err,remove_cvs(message->data.data_load_ack.leaf_name,NULL,NULL));

  if (message->hdr.action_code == Wimp_MDataLoad)
    msg.hdr.action_code = Wimp_MDataLoadAck;

exit_gracefully:
  _swix(Hourglass_Off,0);
  wimp_send_message(Wimp_EUserMessage, &msg, msg.hdr.sender,0,0);
  if (err)
    wimp_report_error(err,0,0);

  return 1;
}

/*
 * Enter the correct version string into window
 */
int
initialise_proginfo(int event_code,ToolboxEvent *event,
    			    IdBlock *id_block, void *handle)
{
  proginfo_set_version(0,id_block->self_id,APP_VERSION);
  return 0;
}

/*
 * main
 */
int
main(int argc, char *argv[])
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int toolbox_events = 0;
  int wimp_messages  = 0;
  int event_code;

  event_initialise(&id_block);          /* initialise the event library. */
  event_set_mask(Wimp_Poll_NullMask); 	/* mask out un-required wimp events */

  ERR_GOTO(err,event_register_toolbox_handler(-1,Toolbox_ObjectAutoCreated,
      attach_other_handlers,NULL));

  /* register ourselves with the Toolbox. */
  ERR_GOTO(err,toolbox_initialise(0, WimpVersion, &wimp_messages,
      &toolbox_events,"<EraseCVS$Dir>",&messages,&id_block,0,0,0));

  /* Message handlers */
  ERR_GOTO(err,event_register_message_handler(Wimp_MQuit,
             quit_message,0));
  ERR_GOTO(err,event_register_message_handler(Wimp_MPreQuit,
             quit_message,0));
  ERR_GOTO(err,event_register_message_handler(Wimp_MDataLoad,
             message_data_open,0));

  /* Menu event handlers */
  ERR_GOTO(err,event_register_toolbox_handler(-1,MENU_EVENT_QUIT,
             quit_event,0));

  /* Window event handlers */
  ERR_GOTO(err,event_register_toolbox_handler(-1,ProgInfo_AboutToBeShown,
      initialise_proginfo,NULL));

  toolbox_get_sys_info(3,&reg);  /* Obtain wimp task handle */
  task_handle = reg.r[0];

  /* poll loop */
  while (TRUE)
    event_poll (&event_code, &poll_block, 0);

 exit_gracefully:
  if (err)
    wimp_report_error(err,0,0);

  return (0);
}
