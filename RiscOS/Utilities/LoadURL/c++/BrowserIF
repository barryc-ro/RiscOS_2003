/************************************************************************/
/* File:    FrescoComs.c                                                */
/* Purpose: File contains code to do with communicating with NCFresco.  */
/*          This takes the form of receiving display request messages   */
/*          and opening/closing web pages.                              */
/*                                                                      */
/* Author:  Ben Laughton <mailto:blaughton@acorn.com>                   */
/* History: 0.01  Mon 21st September 1998                               */
/*                Created.                                              */
/*          0.02  Thu 24th September 1998                               */
/*                SNB: Added some NCMail specific bits to original code.*/
/*          0.03  Mon 28th September 1998                               */
/*                BAL: Fixed bug stopping ncmail: commands with just one*/
/*                parameter causing a postmortem.                       */
/************************************************************************/

/* Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.
 */

/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
/* CLib */
#include <ctype.h>


// Email
#include "Email/Common/bool.h"
#include "Email/Common/list.h"

extern "C"
{
#include "Main.h"
#ifdef MemCheck_MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif
}

/* Local */

extern "C"
{
  #include "BrowserIF.h"
  #include "URLOpen.h"		/* From NCFresco's source */
}

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define URL_OFFSET       236
#define URL_PTR          (char *) 0x01800000

#define ARG_GRANULARITY  5

#define OS_Module_Claim  6
#define OS_Module_Free   7

/* Macro definitions */
#define M_unused(a) (void) (a)

// For some strange reason our C implementation of the 'offsetof' macro doesn't work in C++.
#undef offsetof
#define offsetof(type, member) \
    ((size_t)((char *)&(((type *)0)->member) - (char *)0))




/* -------------------------------------- TYPE DEFINITIONS -------------------------------------- */
typedef struct
{
    char *  name;
    bool (*handler) (char *, const char *const);
} scheme_handler_t;

typedef struct
{
    char *  page;
    bool (*fn) (int, url_param *);
} url_handler_t;

class RMABlockList : public ELib_list
{
    // Member functions
    public:
                       RMABlockList ();
        virtual       ~RMABlockList ();
        void *         Insert (const size_t  size);
        virtual void   Delete (void *const   ptr);
        void           FreeAllBlocks ();

    private:
        void *   claim_block (const size_t  size);
        void     free_block (void *const  ptr);

    // Data members
    private:
        int  count;
};




/* ------------------------------------ FUNCTION PROTOTYPES ------------------------------------- */

static bool  write_url_string (WimpMessage *const   message,
                               string_value *const  string_val,
                               const char *const    string,
                               const size_t         string_size);

static void  destroy_openurl_message (WimpMessage *const  message);

static const char *  extract_indirect_string (
                         const urlopen_data *const  openurl,
                         const string_value         indirect_string);

static bool  process_url (char *             url,
                          const char *const  body_filename);

static bool  process_ncmail (char *             url,
                             const char *const  body_filename);

static url_param *  process_ncmail_args_mem (char *      url,
                                             int *const  count);

static url_param *  process_ncmail_args_file (const char *const  filename,
                                              int *const         count);

static bool  process_mailto (char *             url,
                             const char *const  body_filename);


static bool  read_arg_name_file (FILE *const       fp,
                                 url_param *const  arg);

static bool  read_arg_value_file (FILE *const       fp,
                                  url_param *const  arg);

static bool  write_body_argument (FILE *const        in_file,
                                  const char *const  filename);

static bool  unescape_url_string (char *  string);




/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

static scheme_handler_t  scheme[] =
{
    { "NCMail", process_ncmail },
    { "mailto", process_mailto }
};

extern bool test (int num_args, url_param *  arg);
static url_handler_t  url_handler[] =
{
  /* Structure should be 'Page Type', 'Function to call ' */
    { "Test", test }
};

static url_handler_t  command_handler[] =
{
  /* Structure should be 'Page Type', 'Function to call ' */
    { "Test", test }
};

static RMABlockList  rma_list;

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

extern "C"
{

/************************************************************************/
/* browserif_loadurl                                                    */
/*                                                                      */
/* Function loads a URL into the specified target in the browser.       */
/*                                                                      */
/* Parameters: url    - URL to open.                                    */
/*             dbox   - true (specify target), false (use __top).       */
/*             target - target to use.                                  */
/*                                                                      */
/* Returns:    true or false.                                           */
/*                                                                      */
/************************************************************************/
extern bool browserif_loadurl(const char *const url, bool dbox, const char *const target)
{
    const size_t    url_size = strlen (url) + 1;
    WimpMessage     message;
    urlopen_data *  open = (urlopen_data *) &message.data;
    bool            rc = true;

    message.hdr.size = sizeof (message.hdr);

    if (dbox || url_size > sizeof (open->url))
    {
        /* Need to use indirect data in Open URL message */
        memset (&open->indirect,
                0,
                sizeof (open->indirect));

        message.hdr.size += sizeof (open->indirect);

        if (write_url_string (&message,
                              &open->indirect.url,
                              url,
                              url_size))
        {
            if (dbox)
            {
                if (!write_url_string (&message,
                                       &open->indirect.target,
                                       target,
                                       strlen (target)+1))
                {
                    if (open->indirect.url.ptr >= URL_PTR)
                    {
                        rma_list.Delete (open->indirect.url.ptr);
                    }
                    rc = false;
                }
            }
        }
    }
    else
    {
        message.hdr.size += url_size;
        memcpy (open->url,
                url,
                url_size);
    }

    dprintf(("UI_0", "URL to be sent is: %s\n", url));
    if (dbox)
      dprintf(("UI_0", "URL target is:     %s (len: %d)\n", target, strlen(target)));

    if (rc)
    {
        /* Ensure message size is a 4 byte multiple */
        message.hdr.size = (message.hdr.size + 3) & ~3;

        message.hdr.your_ref = 0;
        message.hdr.action_code = wimp_MOPENURL;

        if (wimp_send_message (Wimp_EUserMessageRecorded,
                               &message,
                               0,
                               0,
                               NULL))
        {
            destroy_openurl_message (&message);
        }
    }

    return rc;
}




extern int  browserif_bounced_msg_handler (int              event_code,
                                           WimpPollBlock *  event,
                                           IdBlock *        id_block,
                                           void *           handle)
{
    NB_UNUSED (event_code);
    NB_UNUSED (id_block);
    NB_UNUSED (handle);

    int  rc = 0;

    if (event->user_message_acknowledge.hdr.action_code == wimp_MOPENURL)
    {
        // Must be one of ours - we can only receive bounced messages
        // from ourself!

        destroy_openurl_message (&event->user_message_acknowledge);
        rc = 1;
    }

    return rc;
}




extern int  browserif_null_event_handler (int              event_code,
                                          WimpPollBlock *  event,
                                          IdBlock *        id_block,
                                          void *           handle)
{
    // This routine is a revolting hack to get around the deficiencies in the
    // ANT URL protocol, but it appears to be the only hack possible in the
    // context in which we are operating, so it'll have to do.
    //
    // The deficiency is as follows: if we send a URL with 'indirect' data
    // allocated from the RMA and a task (usually NCFresco) claims the message
    // then we never get to know about it because ANT didn't bother including an
    // 'acknowledge' message in their protocol.  This means we never know when
    // the RMA which we claimed for the message is no longer being used, hence
    // we can't ever be 100% sure that no other applications are using it,
    // therefore can never be 100% sure that it is safe to free it.  Lovely.
    //
    // The revolting hack relies on undocumented, implementation dependent
    // behaviour of the Wimp.  If *any* task has any Wimp messages in it's
    // message queue then *no* task will get any *null* events until *all* tasks
    // have had their Wimp messages delivered.  This means that whenever we
    // get a *null* event we can be sure that no tasks have any Open URL
    // messages waiting to be delivered to them, so we can free any RMA claimed
    // for previously sent messages.  The only slight flaw with this is when we
    // quit we can't be 100% sure that all apps have recieved any pending
    // messages, but we'll just have to lump it with this case.

    NB_UNUSED (event_code);
    NB_UNUSED (event);
    NB_UNUSED (id_block);
    NB_UNUSED (handle);

    rma_list.FreeAllBlocks ();

    return 0;
}




/************************************************************************/
/* browserif_openurl_msg_handler                                        */
/*                                                                      */
/* Handle OpenURL Wimp messages from the web browser.  If we handle     */
/* the URL type then ack the message.                                   */
/*                                                                      */
/* Parameters: Wimp message params.                                     */
/*                                                                      */
/* Returns:    TRUE (handled message), FALSE (didn't handle message).   */
/*                                                                      */
/************************************************************************/
int  browserif_openurl_msg_handler (WimpMessage *  message,
                                           void *         handle)
{
    urlopen_data *  openurl = (urlopen_data *) &message->data;
    const char *    url = NULL;
    const char *    body_filename = NULL;
    int             rc = 0;

    dprintf(("UI_0", "browserif_openurl_msg_handler entered\n"));
    dprintf(("UI_0", "URL: '%s'\n", (openurl->url) ? openurl->url : "null"));

    M_unused (handle);

    if (openurl->indirect.tag == 0)
    {
        /* Indirect URL */
        url = extract_indirect_string (openurl,
                                       openurl->indirect.url);
        /* For other fields need to check the message size to ensure that
         * the field is valid.  If this test passes then also need to check
         * actual value of field to see if it's filled in - yuck.
         */
        if (offsetof (WimpMessage, data) +
            offsetof (urlopen_data, indirect.body_file) < message->hdr.size)
        {
            /* Field might possibly contain valid data */
            body_filename = extract_indirect_string (
                                openurl,
                                openurl->indirect.body_file);
#ifdef MemCheck_MEMCHECK
            if (body_filename)
            {
                MemCheck_RegisterMiscBlock_String(body_filename);
            }
#endif
        }
    }
    else
    {
        /* Wimp message just contains URL */
        url = openurl->url;
    }

    if (url)
    {
#ifdef MemCheck_MEMCHECK
        MemCheck_RegisterMiscBlock_String(url);
#endif

        /* Not clear whether it is acceptable to overwrite the URL, so take a
         * copy for manipulation.
         */
        char *  working_copy_url;
        size_t  url_size = strlen (url) + 1;

        working_copy_url = malloc (url_size);
        if (working_copy_url)
        {
            memcpy (working_copy_url,
                    url,
                    url_size);

            rc = (int) process_url (working_copy_url,
                                    body_filename);

            free (working_copy_url);

            if (rc)
            {
                /* We handled the URL so we must acknowledge the Wimp message */
                dprintf(("UI_0", "sending URL message back\n"));
                message->hdr.your_ref = message->hdr.my_ref;

                (void) wimp_send_message (Wimp_EUserMessageAcknowledge,
                                          message,
                                          message->hdr.sender,
                                          0,
                                          NULL);
            }
        }
    }

#ifdef MemCheck_MEMCHECK
    MemCheck_UnRegisterMiscBlock(url);
    if (body_filename)
    {
        MemCheck_UnRegisterMiscBlock(body_filename);
    }
#endif

    return rc;
}

} // extern "C"




static bool  write_url_string (WimpMessage *const   message,
                               string_value *const  string_val,
                               const char *const    string,
                               const size_t         string_size)
{
    int   space_left = sizeof(WimpMessage) - message->hdr.size;
    bool  rc         = true;

    if (string_size <= space_left)
    {
        /* offset is relative to data start */
        string_val->offset = message->hdr.size - sizeof(message->hdr);
        memcpy (message->data.bytes + string_val->offset,
                string,
                string_size);
        message->hdr.size += string_size;
    }
    else
    {
        string_val->ptr = (char *) rma_list.Insert (string_size);
        if (string_val->ptr)
        {
             memcpy (string_val->ptr,
                     string,
                     string_size);
        }
        else
        {
            rc = false;
        }
    }

    return rc;
}




static void  destroy_openurl_message (WimpMessage *const  message)
{
    urlopen_data *  openurl = (urlopen_data *) &message->data;

    if (openurl->indirect.tag == 0)
    {
        // Message contains indirect data, possibly allocated from RMA
        if (openurl->indirect.url.ptr >= URL_PTR)
        {
            // RMA used to store URL
            rma_list.Delete (openurl->indirect.url.ptr);
        }

        if (offsetof (WimpMessage, data) +
            offsetof (urlopen_data, indirect.target) < message->hdr.size)
        {
            // Target field of message may contain data
            if (openurl->indirect.target.ptr >= URL_PTR)
            {
                // RMA used to store target
                rma_list.Delete (openurl->indirect.target.ptr);
            }
        }
    }
}




/************************************************************************/
/* extract_indirect_string                                              */
/*                                                                      */
/* Return a pointer to a character string given an indirected string    */
/* field from the (revolting) ANT URL protocol.                         */
/*                                                                      */
/* Parameters: openurl - pointer to OpenURL data area in Wimp message   */
/*             indirect_string - indirect string from OpenURL message   */
/*                                                                      */
/* Returns:    NULL (no string in field), otherwise pointer to string.  */
/*                                                                      */
/************************************************************************/
static const char *  extract_indirect_string (
                         const urlopen_data *const  openurl,
                         const string_value         indirect_string)
{
    char *  string = NULL;

    if (indirect_string.offset < URL_OFFSET)
    {
        string = ((char *) openurl) + indirect_string.offset;
    }
    else if (indirect_string.ptr >= URL_PTR)
    {
        string = indirect_string.ptr;
    }

    return string;
}



/************************************************************************/
/* process_url                                                          */
/*                                                                      */
/* Process a zero terminated URL, deciding whether or not we should     */
/* handle it.                                                           */
/*                                                                      */
/* Parameters: url  - pointer to URL.                                   */
/*             body_file - pointer to body filename (NULL if N/A)       */
/*                                                                      */
/* Returns:    true (handled URL), false (didn't handle URL).           */
/*                                                                      */
/************************************************************************/
static bool  process_url (char *             url,
                          const char *const  body_filename)
{
    bool  rc = false;
    char *  s;

    if (url)
    {
        /* Search for scheme delimiter ':' */
        s = strchr (url, ':');
        if (s)
        {
            int  i = 0;

            *s++ = 0;

            while (i < sizeof (scheme) / sizeof (scheme[0]))
            {
                if (nb_case_insensitive_strcmp (url, scheme[i].name) == 0)
                {
                    rc = (*scheme[i].handler) (s,
                                               body_filename);
                    break;
                }
                i++;
            }
        }
    }

    return rc;
}


/************************************************************************/
/* process_ncmail                                                       */
/*                                                                      */
/* Extract the variables from an NCMail URL in memory or a file and     */
/* forward them to the appropriate handling function.  Variables are of */
/* the form variable=value and are separated by '&'.                    */
/*                                                                      */
/* Parameters: url  - pointer to zero terminated url in memory.         */
/*             body_filename - name of file containing URL (NULL if N/A)*/
/*                                                                      */
/* Returns:    true (handled), false (not handled).                     */
/*                                                                      */
/************************************************************************/
static bool  process_ncmail (char *             url,
                             const char *const  body_filename)
{
    bool    rc = false;

    /* Skip over '/' */
    if (*url++ == '/')
    {
        int          count;
        url_param *  arg;

        if (body_filename)
        {
            arg = process_ncmail_args_file (body_filename,
                                            &count);
            nb_file_delete (1, (char *) body_filename, NULL);
        }
        else
        {
            arg = process_ncmail_args_mem (url,
                                           &count);
        }

        if (arg)
        {
            int  i = 0;

            /* First argument should be page */
            if (nb_case_insensitive_strcmp (arg[0].name, "page") == 0)
            {
                while (i < sizeof (url_handler) / sizeof (url_handler[0]))
                {
                    if (nb_case_insensitive_strcmp (arg[0].value, url_handler[i].page) == 0)
                    {
                        /* No need to give handler the page parameter */
                        (*url_handler[i].fn) (count - 1,
                                              &arg[1]);
                        rc = true;
                        break;
                    }

                    i++;
                }
            }
            /* But it might be "command" */
            else if (nb_case_insensitive_strcmp (arg[0].name, "command") == 0)
            {
                while (i < sizeof (command_handler) / sizeof (command_handler[0]))
                {
                    if (nb_case_insensitive_strcmp (arg[0].value, command_handler[i].page) == 0)
                    {
                        /* No need to give handler the page parameter */
                        (*command_handler[i].fn) (count - 1,
                                                  &arg[1]);
                        rc = true;
                        break;
                    }

                    i++;
                }
            }

            if (body_filename)
            {
                for (i = 0; i < count; ++i)
                {
                    if (arg[i].name)
                    {
                        free (arg[i].name);
                    }
                    if (arg[i].value)
                    {
                        free (arg[i].value);
                    }
                }
            }

            free (arg);
        }
    }

    return rc;
}




/************************************************************************/
/* process_ncmail_args_mem                                              */
/*                                                                      */
/* Process NCMail URLs where the scheme specific data is stored in      */
/* memory.                                                              */
/*                                                                      */
/* Parameters: s - pointer to tail of 0 terminated URL.                 */
/*             count - (output) number of parameters extracted from URL */
/*                                                                      */
/* Returns:    NULL (error), otherwise pointer to array of parameters   */
/*                                                                      */
/************************************************************************/
static url_param *  process_ncmail_args_mem (char *      s,
                                             int *const  count)
{
    url_param *  arg = NULL;

    *count = 0;

    /* Skip over '?' */
    if (*s++ == '?')
    {
        char *  name = s;

        while (s = strchr (s, '='), s != NULL)
        {
            /* Allocate space for arguments in blocks */
            if (*count % ARG_GRANULARITY == 0)
            {
                url_param *  temp = (url_param *)
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + ARG_GRANULARITY));

                if (!temp)
                {
                    goto cleanup;
                }

                arg = temp;
            }

            /* Store pointer to parameter name */
            if (!unescape_url_string (name))
            {
                goto cleanup;
            }

            arg[*count].name = name;

            /* Replace '=' with 0 to separate parameter name from value */
            *s++ = 0;

            /* Store pointer to parameter value */
            if (!unescape_url_string (s))
            {
                goto cleanup;
            }

            arg[*count].value = s;
            ++*count;

            /* Find parameter separator */
            s = strchr (s, '&');
            if (s)
            {
                /* Replace '&' with 0 to separate parameters */
                *s++ = 0;
                name = s;
            }
        };

        /* May need to allocate an extra element in the argument array
         * to hold the array terminator.
         */
        if (*count % ARG_GRANULARITY == 0)
        {
            url_param *  temp = (url_param *)
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + 1));

            if (!temp)
            {
                goto cleanup;
            }

            arg = temp;
        }

        /* Ensure arg list is properly terminated */
        arg[*count].name  = NULL;
        arg[*count].value = NULL;
    }
    return arg;

cleanup:
    if (arg)
    {
        free (arg);
    }

    return NULL;
}




/************************************************************************/
/* process_ncmail_args_file                                             */
/*                                                                      */
/* Process NCMail URLs where the scheme specific data is stored in      */
/* a file.                                                              */
/*                                                                      */
/* Parameters: filename - name of file containing scheme specific data  */
/*             count - (output) number of parameters extracted from URL */
/*                                                                      */
/* Returns:    NULL (error), otherwise pointer to array of parameters   */
/*                                                                      */
/************************************************************************/
static url_param *  process_ncmail_args_file (const char *const  filename,
                                              int *const         count)
{
    FILE *       fp;
    url_param *  arg = NULL;

    *count = 0;

    fp = fopen (filename, "r");
    if (fp)
    {
        /* Disclaimer: I wrote a version of this loop without the gotos,
         * but it was more difficult to follow, produced larger code and
         * would have been slower (though these last two would not have
         * been significant).
         */

        while (!feof (fp))
        {
            /* Allocate space for arguments in blocks */
            if (*count % ARG_GRANULARITY == 0)
            {
                url_param *  temp = (url_param *)
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + ARG_GRANULARITY));

                if (!temp)
                {
                    goto cleanup;
                }

                arg = temp;
            }

            if (!read_arg_name_file (fp,
                                     &arg[*count]))
            {
                goto cleanup;
            }

            /* Check for special case: 'body' argument's contents need
             * to be copied to another file, not memory.
             */
            if (nb_case_insensitive_strcmp (arg[*count].name, "body") == 0)
            {
                /* Body argument's value is the name of a file
                 * containing the real value.
                 */
                arg[*count].value = malloc (L_tmpnam + 1);
                if (arg[*count].value == NULL)
                {
                    free (arg[*count].name);
                    goto cleanup;
                }

#ifdef DEBUG
                static int32 work_round_ddt_fault = 0;
                sprintf(arg[*count].value, "<Wimp$ScrapDir>.%d", work_round_ddt_fault++);
#else
                tmpnam (arg[*count].value);
#endif
                if (!write_body_argument (fp,
                                          arg[*count].value))
                {
                    free (arg[*count].name);
                    goto cleanup;
                }
            }
            else
            {
                if (!read_arg_value_file (fp,
                                          &arg[*count]))
                {
                    goto cleanup;
                }
            }

            ++*count;
        };

        /* May need to allocate an extra element in the argument array
         * to hold the array terminator.
         */
        if (*count % ARG_GRANULARITY == 0)
        {
            url_param *  temp = (url_param *)
                    realloc (
                        arg,
                        sizeof (url_param) * (*count + 1));

            if (!temp)
            {
                goto cleanup;
            }
            arg = temp;
        }

        /* Ensure arg list is properly terminated */
        arg[*count].name  = NULL;
        arg[*count].value = NULL;

        fclose (fp);
    }
    return arg;

cleanup:
    fclose (fp);

    if (arg)
    {
        int i;

        for (i = 0; i < *count; ++i)
        {
            if (arg[i].name)
            {
                free (arg[i].name);
            }
            if (arg[i].value)
            {
                free (arg[i].value);
            }
        }
        free (arg);
    }

    return NULL;
}




/************************************************************************/
/* process_mailto                                                       */
/*                                                                      */
/* Process mailto: URL messages.                                        */
/*                                                                      */
/* Parameters: s  - contents of mailto: URL.                            */
/*             body_filename -                                          */
/*                                                                      */
/* Returns:    true (handled), false (not handled).                     */
/*                                                                      */
/************************************************************************/
static bool  process_mailto (char *             s,
                             const char *const  body_filename)
{
    bool  rc = false;

    if (body_filename)
    {
        size_t  body_file_size =
            nb_file_get_size (1,    // next parameter contains full path
                              (char *) body_filename,
                              NULL);

        s = malloc (body_file_size + 1);
        if (s)
        {
             FILE *  fp = fopen (body_filename, "rb");
             if (fp)
             {
                 if (fread (s,
                            sizeof (char),
                            body_file_size,
                            fp) == body_file_size)
                 {
                     rc = true;
                 }

                 fclose (fp);
             }

             if (rc == false)
             {
                 free (s);
                 s = NULL;
             }
        }
    }

    if (s)
    {
        rc = false;

        // Only support simple mailto as in RFC 1738
        // Assume that nul or any URL reserved char terminates the
        // mailbox name (not 100% sure about this since the original
        // RFC 1738 says that no characters are reserved in mailto
        // wherea RFC 2368 states that all URL reserved characters
        // in the mailbox name must be encoded.

        // Find terminating character
        char *  t = s + strcspn (s, "?=&");
        *t = 0;
        if (unescape_url_string (s))
        {
            url_param  param[2];
            param[0].name = "to";
            param[0].value = s;
            param[1].name = 0;
            param[1].value = 0;
//          mailto_send_message_request (1, param);
            rc = true;
        }

        if (body_filename)
        {
            free (s);
        }
    }

    return rc;
}




/************************************************************************/
/* read_arg_name_file                                                   */
/*                                                                      */
/* Read a parameter name from a file containing NCEmail scheme          */
/* specific data.                                                       */
/*                                                                      */
/* Parameters: fp - file handle                                         */
/*             arg - place to store parameter name                      */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  read_arg_name_file (FILE *const       fp,
                                 url_param *const  arg)
{
    bool       rc = false;
    long int   offset;

    arg->name  = NULL;

    /* Record current position in file */
    offset = ftell (fp);
    if (offset != -1)
    {
        int        name_len;

        /* Find length of parameter name */
        if (fscanf (fp,
                    "%*[^=]%n",
                    &name_len) != EOF)
        {
            if (name_len > 0)
            {
                /* Allocate memory to store parameter name */
                arg->name = malloc (name_len + 1);
                if (arg->name)
                {
                    /* Go back to initial position in file to do actual read */
                    if (fseek (fp,
                               offset,
                               SEEK_SET) == 0)
                    {
                        if (fscanf (fp,
                                    "%[^=]=",
                                    arg->name) == 1)
                        {
                            rc = true;
                        }
                    }
                }
            }
        }
    }

    if (rc == false)
    {
        if (arg->name)
        {
            free (arg->name);
        }
    }

    return rc;
}




/************************************************************************/
/* read_arg_value_file                                                  */
/*                                                                      */
/* Read a parameter value from a file containing NCEmail scheme         */
/* specific data.                                                       */
/*                                                                      */
/* Parameters: fp - file handle                                         */
/*             arg - place to store parameter value                     */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  read_arg_value_file (FILE *const       fp,
                                  url_param *const  arg)
{
    bool       rc = false;
    long int   offset;

    arg->value = NULL;

    /* Record current position in file */
    offset = ftell (fp);
    if (offset != -1)
    {
        int        value_len;

        /* Find length of parameter value */
        if (fscanf (fp,
                    "%*[^&]%n",
                    &value_len) != EOF)
        {
            /* Allocate memory to store parameter value */
            arg->value = malloc (value_len + 1);
            if (arg->value)
            {
                /* Go back to initial position in file to do actual read */
                if (fseek (fp,
                           offset,
                           SEEK_SET) == 0)
                {
                    if (fscanf (fp,
                                "%[^&]&",
                                arg->value) == 1)
                    {
                        if (unescape_url_string (arg->value))
                        {
                            rc = true;
                        }
                    }
                }
            }
        }
    }

    if (rc == false)
    {
        if (arg->value)
        {
            free (arg->value);
        }
    }

    return rc;
}




/************************************************************************/
/* write_body_argument                                                  */
/*                                                                      */
/* Write the value of an NCEmail 'body' argument to a file, peforming   */
/* any necessary character unescaping.                                  */
/*                                                                      */
/* Parameters: in_file - input file handle                              */
/*             filename - name of output file                           */
/*                                                                      */
/* Returns:    true (success), false (error)                            */
/*                                                                      */
/************************************************************************/
static bool  write_body_argument (FILE *const        in_file,
                                  const char *const  filename)
{
    bool    rc = true;
    FILE *  out_file;

    out_file = fopen (filename, "w");
    if (out_file == NULL)
    {
        rc = false;
    }
    else
    {
        int  c;

        while (rc && (c = fgetc (in_file)) != EOF)
        {
            switch (c)
            {
                case '%':    /* escape sequence */
                {
                    /* Expect two hex characters - this code nicked from
                     * c-client's quoted-printable decoding.
                     */
                    char  e;

                    c = fgetc (in_file);
                    if (! (isxdigit (c) &&
                           (e = fgetc (in_file)) != EOF &&
                           isxdigit (e)))
                    {
                        rc = false;
                        break;
                    }

                    if (isdigit (c))
                    {
                        c -= '0';
                    }
                    else
                    {
                        if (isupper (c))
                        {
                            c -= 'A' - 10;
                        }
                        else
                        {
                            c -= 'a' - 10;
                        }
                    }

                    if (isdigit (e))
                    {
                        e -= '0';
                    }
                    else
                    {
                        if (isupper (e))
                        {
                            e -= 'A' - 10;
                        }
                        else
                        {
                            e -= 'a' - 10;
                        }
                    }

                    if (fputc (e + (c << 4),
                              out_file) == EOF)
                    {
                        rc = false;
                    }
                    break;
                }

                case '+':
                    c = ' ';
                    /* drop through */

                default:
                    if (fputc (c, out_file) == EOF)
                    {
                        rc = false;
                    }
                    break;
            }
        }

        fclose (out_file);
        nb_file_lock(1, (char *) filename, NULL);
    }

    return rc;
}




/************************************************************************/
/* unescape_url_string                                                  */
/*                                                                      */
/* Perform any necessary character unescaping on a URL string passed    */
/* from NCFresco.  Unescaped data is never longer than escaped data,    */
/* so the processing is performed 'in place' without making a new copy  */
/* of the string.                                                       */
/*                                                                      */
/* Parameters: string - 0 terminated string to unescape                 */
/*                                                                      */
/* Returns:    true (successful), false (invalid data)                  */
/*                                                                      */
/************************************************************************/
static bool  unescape_url_string (char *  string)
{
    int     c;
    bool    rc = true;
    char *  s = string;
    char *  d = string;

    while (rc && (c = *s++) != 0)
    {
        switch (c)
        {
            case '%':    /* escape sequence */
            {
                /* Expect two hex characters - this code nicked from
                 * c-client's quoted-printable decoding.
                 */
                char  e;

                c = *s++;
                if (! (isxdigit (c) &&
                       (e = *s++) &&
                       isxdigit (e)))
                {
                    rc = false;
                    break;
                }

                if (isdigit (c))
                {
                    c -= '0';
                }
                else
                {
                    if (isupper (c))
                    {
                        c -= 'A' - 10;
                    }
                    else
                    {
                        c -= 'a' - 10;
                    }
                }

                if (isdigit (e))
                {
                    e -= '0';
                }
                else
                {
                    if (isupper (e))
                    {
                        e -= 'A' - 10;
                    }
                    else
                    {
                        e -= 'a' - 10;
                    }
                }

                *d++ = e + (c << 4);
                break;
            }

            case '+':
                c = ' ';
                /* fall through */

            default:
                *d++ = c;
                break;
        }
    }

    if (rc)
    {
        /* Ensure unescaped string is 0 terminated */
        *d = 0;
    }

    return rc;
}




/* ---------------------------------- CLASS MEMBER FUNCTIONS ------------------------------------ */

RMABlockList::RMABlockList ()
    : count (0)
{
}




RMABlockList::~RMABlockList ()
{
    FreeAllBlocks ();
}




void *  RMABlockList::Insert (const size_t  size)
{
    void *  p = claim_block (size);
    if (p)
    {
        // Block claimed successfully - insert at end of list
        End ();
        if (ELib_list::Insert (p))
        {
            // Insertion succeeded - increment count
            if (count++ == 0)
            {
                // Want null events
//              eng_null_events (true);
                if (event_register_wimp_handler (-1,
                                                 Wimp_ENull,
                                                 browserif_null_event_handler,
                                                 NULL))
                {
                    // Failed - free block
                    Delete (p);
                    p = 0;
                }
            }
        }
        else
        {
            // Insertion failed - free block
            free_block (p);
            p = 0;
        }
    }

    return p;
}




void  RMABlockList::Delete (void *const  p)
{
    void *  current = Current ();

    // If the current item is not the one we want then search the list to
    // find the required item
    if (current != p)
    {
        Start ();

        while (current = Current (), current && current != p)
        {
            Next ();
        }
    }

    if (current == p)
    {
        free_block (p);
        ELib_list::Delete ();
        if (--count == 0)
        {
            // Don't need null events any more
//          eng_null_events (false);
            (void) event_deregister_wimp_handler (-1,
                                                  Wimp_ENull,
                                                  browserif_null_event_handler,
                                                  NULL);
        }
    }
}




void RMABlockList::FreeAllBlocks ()
{
    for (Start (); !Nul (); Next ())
    {
        Delete (Current ());
    }
}




void *  RMABlockList::claim_block (const size_t  size)
{
    void *  p;

    if (_swix (OS_Module,
               _IN (0) | _IN (3) | _OUT (2),

               OS_Module_Claim,
               size,

               &p))
    {
        // Allocation failed
        p = 0;
    }

    return p;
}




void  RMABlockList::free_block (void *const  p)
{
    (void) _swix (OS_Module,
                  _IN (0) | _IN (2),

                  OS_Module_Free,
                  p);
}

bool test (int num_args, url_param *  arg)
{
  NB_UNUSED(num_args);
  NB_UNUSED(arg);
  return(true);
}

