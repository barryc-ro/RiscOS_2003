#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#ifdef __riscos
#include "swis.h"
#endif

/* Read word from (non-word-aligned) char *c */
#define GETWORD(c) (*(c) + (*((c)+1)<<8) + (*((c)+2)<<16) + (*((c)+3)<<3))

void getimage(char **image, int *ilenptr);
void readimage(int ilen);
void readexp(char *image, char *romtype);
void reados(int imageSize);
char *modinfo(char *base, char *info, int *total_size, int size);
char *memfind(char *mem, char *find);
#ifdef __riscos
void hourglass(int state);
#endif
fpos_t *strfind(char *find);
int fsize(char *fileName);
int findResourceFSBlockSize(void);
int fastFindResourceFSBlockSize(void);

static int flag_csv = 0;
static int flag_loc = 0;
static bool flag_ressize = false;
char q = 34;

FILE *imageFile;

/*
 * tidy things up before exit
 */
void
doexit(void)
{
#ifdef __riscos
  hourglass(0);
#endif
}

int main(int argc, char *argv[])
{
  int ilen;
  static char id[] = "ROM information lister. V1.06. © Acorn 1996-2000.";
  int i;
  int ifirst = 0; /* first none flag argument on command line */

  atexit(doexit);

  if (argc>=2)
  {
    /*
     * scan command line for flags
     */
    for (i=1; i<argc; i++)
    {
      if (!strcmp(argv[i],"-csv")||!strcmp(argv[i],"-csv"))
      {
        flag_csv = 1;
      }
      else if (!strcmp(argv[i],"-ressize")||!strcmp(argv[i],"ressize"))
      {
        flag_ressize = true;
      }
      else if (!strcmp(argv[i], "-loc")||!strcmp(argv[i], "loc"))
      {
        flag_loc = 1;
      }
      else if (*argv[i]!='-' && ifirst==0)
        ifirst=i;
    }

    printf("Generating ROM contents (%s)\n", id);

    if (ifirst>0)
    {

#ifdef __riscos
      hourglass(1);
#endif

      /* Open ROM image file */
      if ((imageFile = fopen(argv[ifirst], "rb"))!=NULL) {
        /* Calculate size of image file */
        ilen = fsize(argv[ifirst]);

        readimage(ilen);

        /* Tidy up */
        fclose(imageFile);
      }
      else {
        printf("Cannot open image file.\n");
        return EXIT_FAILURE;
      }

#ifdef __riscos
      hourglass(0);
#endif

return EXIT_SUCCESS;
    }
  }

  /*
   * bad parameters
   */
  fprintf(stderr, "%s\n\nGenerates a listing of the contents of an OS/Extension/Expansion ROM image.\n\n",id);
  fprintf(stderr, "Syntax:\tROMinfo <flags> <ROM image>\n\n");
  fprintf(stderr, "Flags:\n  -csv Output details in CSV format\n  -loc Output start positions of module in ROM\n  -ressize Output the size of the resourcefs area.\n");
  exit(EXIT_FAILURE);
}


#ifdef __riscos
/*
 * toggle hourglass
 */
void
hourglass(int state)
{
  if (state)
    _swix(Hourglass_On,0);
  else
    _swix(Hourglass_Off,0);
}
#endif

void getimage(char **image, int *ilenptr)
{

  // Find size of image
  fseek(imageFile, 0L, SEEK_END);
  *ilenptr = (size_t) ftell(imageFile);
  fseek(imageFile, 0L, SEEK_SET);

  // Alloc & read entire image
  if ((*image = malloc(*ilenptr)) == NULL)
  {
    fprintf(stderr, "Can't allocate %dK for image\n", (*ilenptr)/1024);
    exit(EXIT_FAILURE);
  }
  if (fread(*image, 1, *ilenptr, imageFile) != *ilenptr)
  {
    fprintf(stderr, "Can't read image file\n");
    exit(EXIT_FAILURE);
  }

  fclose(imageFile);
}


/*
 * Reads the image and prints blurb about image type etc.
 */
void readimage(int ilen) {
  char fileData = 0, *image;

  if (!flag_csv) {
    printf("Image size:    %d\n", ilen / 1024);
    printf("Image type:    ");
  }

  fileData = fgetc(imageFile);
  if (fileData == 0x80) {
    printf("Non-conformant expansion card\n");
  }
  else if (fileData & 0x10) {
    if (!flag_csv) {
      printf("RISC OS\n");
    }
    reados(ilen);
  }
  else if (fileData & 0x38) {
    printf("Extension ROM\n");
    getimage(&image, &ilen);
    readexp(image, "Extn ROM 1");
  }
  else {
    printf("Extension card\n");
    getimage(&image, &ilen);
    readexp(image, "Podule 1");
  }
}

/*
 * Reads an expansion/extension image header and prints blurb about it.
 */
void readexp(char *image, char *romtype)
{
  char *dptr;	/* Pointer into chunk directory, see PRM 4-127 */
  char *cptr;	/* Pointer at chunk (not necessarily word-aligned) */
  char info[256];
  int modno=0;
  int size=0;

  printf("Product type:   &%X\n", *(image+3) + (*(image+4) << 8));
  printf("Manufacturer:   &%X\n", *(image+5) + (*(image+6) << 8));
  printf("Country:        &%X\n", *(image+7));

  /* Check for presence of chunk directory */
  switch (*(image+1) & 3)
  {
  case 0:
  case 2:
    return;
  case 1:
    fprintf(stderr, "Invalid format: Can't have CD & !IS\n");
    exit(EXIT_FAILURE);
  }

  /* Enumerate chunks */
  dptr = image + 0x10;	/* First chunk = after ISP */
  while (*dptr)
  {
    cptr = image + *((int *) (dptr+4));

    switch (*dptr)
    {
    case 0x80:
      printf("Has loader\n");
      break;
    case 0x81:
      if (!(modno++))
        printf("\nNo. Position    Module Name             Description     Version Date             Size     Comment\n");
    printf("%3d %s %s\n", modno, romtype, modinfo(cptr, info, &size, 0));
      break;
    case 0x82:
      printf("BBC ROM\n");
      break;
    case 0x83:
      printf("Sprite\n");
      break;
    case 0xa0:
      printf("UNIX loader\n");
      break;
    case 0xf0:
      dptr = cptr - 8;	/* link */
      break;
    case 0xf1:
      printf("Serial number:  %s\n", cptr);
      break;
    case 0xf2:
      printf("Date of manuf:  %s\n", cptr);
      break;
    case 0xf3:
      printf("Mod. status:    %s\n", cptr);
      break;
    case 0xf4:
      printf("Place of manuf: %s\n", cptr);
      break;
    case 0xf5:
      printf("Description:    %s\n", cptr);
      break;
    case 0xf6:
      printf("Part number:    %s\n", cptr);
      break;
    case 0xf7:
      printf("Ethernet ID:    %X:%X:%X:%X:%X:%X\n", *cptr, *(cptr+1), *(cptr+2),
             *(cptr+3), *(cptr+4), *(cptr+5));
      break;
    case 0xf8:
      printf("Serial number:  &%X\n", *((int *) cptr));
      break;
    case 0xff:
      /* Empty chunk */
      break;
    default:
      printf("Reserved chunk: &%X\n", *dptr);
    }
    dptr += 8;
  }
}

/*
 * Reads an OS image file and prints out corresponding information
 */
void reados(int imageSize) {
  fpos_t *startPos;
  static char  *p, *dptr, *block;
  char info[256];
  int offset = 0, *size, modno = 0, totalsize = 0, resBlockSize = 0;
  long modOffset = 0;

  /*
   * Find the title string of the first module
   */
  startPos = strfind("UtilityModule");
  fsetpos(imageFile, startPos);

  if ((block = malloc(510)) != NULL)
  {
     /*
      * Grab data from file from start of title string back to (way) past
      * module header
      */
     fseek(imageFile, (497 * -1), SEEK_CUR);
     fread(block, 1, 510, imageFile);

     /*
      * Point p at 'U' in block of memory
      */
     p = (block + 497);

     dptr = (char *) (((int) p-0x14) & ~3);
     /*
      * Search back through block until p points at a position 0x10
      * back from module title i.e. the title block pointer in the
      * module header
      */
     while (*((int *) (dptr + 0x10)) != p-dptr) {
       dptr -= 4;
     }

     /*
      * Set file pointer back to 'U' in file
      */
     fsetpos(imageFile, startPos);
     /*
      * Calculate offset of module size field from title block
      */
     offset = (p - dptr + 4);
     /*
      * Set file pointer to module size field
      */
     fseek(imageFile, (long)(offset * -1), SEEK_CUR);

     if (flag_csv) {
       printf("\n\"Number\",\"Module name\",\"Revision\",\"Size\"\n");

       if ((size = malloc(1))!=NULL) {
         /*
          * Grab module size from file, file pointer now at module base
          * NOTE: size includes size of module + size of size field even
          * though it comes BEFORE the module base.
          */
         fread(size, 1, 4, imageFile);

         while (*size != 0) {
           free(block);

           if ((block = malloc(*size))!=NULL) {
             /*
              * Grab module from file to memory block, file pointer now at
              * next module size field
              */
             fread(block, 1, (*size - 4), imageFile);
             printf("\"%d\",%s\n", ++modno, modinfo(block, info, &totalsize, *size));
           }
           else {
             printf("Unable to allocate memory. 3\n");
           }

           /*
            * Read next size field
            */
           fread(size, 1, 4, imageFile);
         }

         free(size);
       }
       else {
         printf("Unable to allocate memory. 2\n");
       }

     }  /* END OF FLAG_CSV */
     else
       if (flag_loc) {

         printf("\nNo. Position   Location ByteSize Module Name             Description\n");

         modOffset = ftell(imageFile);

         if ((size = malloc(1))!=NULL)
         {
           fread(size, 1, 4, imageFile);

           while (*size != 0) {
             free(block);

             if ((block = malloc(*size))!=NULL) {
               fread(block, 1, (*size - 4), imageFile);
               printf("%3d System ROM %8ld %s\n", ++modno, modOffset, modinfo(block, info, &totalsize, *size));
             }
             else {
               printf("Unable to allocate memory. 3\n");
             }

             modOffset = ftell(imageFile);
             fread(size, 1, 4, imageFile);
           }

         printf("Total ROM size %dk\n", imageSize/1024);
         printf("Space utilised %dk (%d%%)\n",totalsize/1024, totalsize*100/imageSize);
         if (flag_ressize)
         {
           resBlockSize = fastFindResourceFSBlockSize();
           printf("ResourceFS block size %dk (%d%%)\n", resBlockSize/1024, resBlockSize*100/imageSize);
         }
         free(size);
         }
         else {
           printf("Unable to allocate memory. 2\n");
         }

       }  /* END OF FLAG_LOC */
     else {
       printf("\nNo. Position    Module Name             Description     Version Date             Size      Comment\n");

       if ((size = malloc(1))!=NULL) {
         fread(size, 1, 4, imageFile);

         while (*size != 0) {
           free(block);

           if ((block = malloc(*size))!=NULL) {
             fread(block, 1, (*size - 4), imageFile);
             printf("%3d System ROM  %s\n", ++modno, modinfo(block, info, &totalsize, *size));
           }
           else {
             printf("Unable to allocate memory. 3\n");
           }

           fread(size, 1, 4, imageFile);
         }

       printf("Total ROM size %dk\n", imageSize/1024);
       printf("Space utilised %dk (%d%%)\n",totalsize/1024, totalsize*100/imageSize);
       if (flag_ressize)
       {
         resBlockSize = fastFindResourceFSBlockSize();
         printf("ResourceFS block size %dk (%d%%)\n", resBlockSize/1024, resBlockSize*100/imageSize);
       }
       free(size);
       }
       else {
         printf("Unable to allocate memory. 2\n");
       }
     } /* END OF NO FLAG */
     free(block);
  }
  else {
    printf("Unable to allocate memory. 1\n");
  }
}




/*
 * Fills supplied info buffer with description of module pointed to by base.
 * Note that base may not be word-aligned.
 */
char *modinfo(char *base, char *info, int *total_size, int size)
{
  char *title, *desc, *ver, *p;

  (*total_size)+=size;

  /* Remove tabs from description, version and date fields */
  title = (char *) (base + GETWORD(base+0x10));

  desc = (char *) (base + GETWORD(base+0x14));
  while ((p = strrchr(desc, '\t')) != NULL)
    *p = '\0';

  ver = desc + strlen(desc) + 1;
  if (*ver == '\0') ver++;

  if (flag_csv)
  {
    p=ver;
    while (*p!='(')
      p++;
    *(p-1) = '\0';
    sprintf(info,"\"%s\",\"%s\",\"%.2fk\"",title,ver,((float)size)/1024.0);
  }
  else if (flag_loc)
  {
    p=ver;
    while (*p != '(')
      p++;
    *(p-1) = '\0';
    sprintf(info, "%8d %-24s%-16s", size, title, desc);
  }
  else
  {
    sprintf(info, "%-24s%-16s%-8.4s%-15.13s  %7.2fk  %s", title, desc, ver, ver+5, ((float)size)/1024.0, ver+18);
  }
  return info;
}




/*
 * Find an existing string in a block of memory. Returns pointer to string.
 */
char *memfind(char *mem, char *find)
{
  char *c = mem;

  do
  {
    while (*c != *find)
      c++;

    if (!(strcmp(c, find)))
      return c;

    c++;
  } while (1);
}

/*
 * Find an existing string in a file, returns file position of 1st char
 * of string
 */
fpos_t *strfind(char *find) {
  static fpos_t *filePos;
  unsigned int length = 0, found = 0;
  char *testString;
  length = strlen(find);
  if ((testString = malloc(length))!=NULL)
  {
    while (!found) {
      fgetpos(imageFile, filePos);
      fread(testString, 1, length, imageFile);
      if (!strncmp(testString, find, length)) {
        found = 1;
      }
      else {
        found = 0;
      }
     fseek(imageFile, (long)((length - 1) * -1), SEEK_CUR);
    }

  free(testString);
  return filePos;
  }
  else {
    printf("Unable to allocate memory\n");
  }
  return 0;
}

/*
 * Finds size of file, returns size in bytes
 */
int fsize(char *fileName) {
  _kernel_swi_regs regs;
  unsigned int size = 0;

  regs.r[0] = 23;
  regs.r[1] = (int)fileName;
  _kernel_swi(OS_File, &regs, &regs);

  size = regs.r[4];

  return size;
}

/*
 * Calculates size of ResourceFS block placed after modules in ROM image
 * It does this by locating the file pointer before the checksum and
 * searching byte-by-byte until it finds something that is not 0xFF.  It
 * is excruciatingly slooow...  (Why can't I make the HDD spin the other
 * way *grin?*)
 */
int findResourceFSBlockSize() {
  long endOfModules, endOfResourceFS;
  int resourceFSSize = 0;

  /* Set file pointer back to end of modules */
  fseek(imageFile, -4, SEEK_CUR);

  endOfModules = ftell(imageFile);

  /* Jump to beginning of checksum at end of file (checksum 20B long)*/
  fseek(imageFile, -32, SEEK_END);

  /* Walk back through file to end of ResourceFS block */
  /* Should reverse the HDD here... */
  while (fgetc(imageFile) == 0xFF) {
    fseek(imageFile, -2, SEEK_CUR);
  }

  endOfResourceFS = ftell(imageFile);

  resourceFSSize = (int)(endOfResourceFS - endOfModules);

  return resourceFSSize;
}

/*
 * This one will be marginally faster than the first one but may be less
 * reliable as if there is an 0xFF between where the search overshoots (
 * as it undoubtably will) and the end of the ResourceFS block this will
 * get picked up as the end of the block instead.  I don't know how much
 * of a worry this is.  If accuracy is a problem then use the function above
 */
int fastFindResourceFSBlockSize() {
  long endOfModules, endOfResourceFS;
  int resourceFSSize = 0;

  /* Set file pointer back to end of modules */
  fseek(imageFile, -4, SEEK_CUR);

  endOfModules = ftell(imageFile);

  /* Jump to beginning of checksum at end of file (checksum 20B long)*/
  fseek(imageFile, -32, SEEK_END);

  /* Walk back through file to end of ResourceFS block */
  while (fgetc(imageFile) == 0xFF) {
    fseek(imageFile, -65, SEEK_CUR);
  }
  while (fgetc(imageFile) != 0xFF) {
  }

  endOfResourceFS = ftell(imageFile);

  resourceFSSize = (int)(endOfResourceFS - endOfModules);

  return resourceFSSize;
}
