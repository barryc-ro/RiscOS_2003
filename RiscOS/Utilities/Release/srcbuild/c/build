/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* RISC OS Includes */
#include "kernel.h"
#include "swis.h"

/* Local includes */
#include "srcbuild.h"
#include "parse.h"
#include "riscos.h"

extern char *progname;
extern char *build_name;
extern char *build_dir;
extern char *image_filename;
extern char *log_filename;
extern char *image_size;
extern char *messages_filename;
extern char *module_type_names[];
extern char *joiner;
extern char *joiner_format;
extern char *sigstr;
extern char *signum;
extern char *base_address;
extern int verbose;
extern module_entry_t *module_database;
extern component_entry_t *component_database;

/* The contents of Alias$amu_machine */
static char *amu_machine = NULL;
void get_amu_machine(void);


/*
 * A nice veneer to OS_ReadVarVal
 */
static void misc_getenv (const char *variable, char *buffer, int buffer_size, int *nbytes)
{
  if (buffer == NULL)
  {
    _kernel_swi_regs r;

     r.r[0] = (int)variable;
     r.r[1] = NULL;
     r.r[2] = -1;
     r.r[3] = 0;
     r.r[4] = 0;

     _kernel_swi (OS_ReadVarVal, &r, &r);

     if (nbytes != NULL)
     {
       if (r.r[2] == 0)
         *nbytes = 0;
       else
       {
         *nbytes = ~r.r[2] + 1;
       }
     }
  }
  else
  {
    int len;

    _swix (OS_ReadVarVal, _INR(0,4) | _OUT(2),
           variable, buffer, buffer_size, 0, 0,
           &len);

    buffer[len] = '\0';

    if (nbytes != NULL)
    {
      *nbytes = len + 1;
    }
  }
}


/*
 * Veneer to OS_ReadVarVal that does it's own memory allocation, uses misc_getenv
 */
static char *misc_getenv_malloc (const char *variable)
{
  char *str;
  int len;

  misc_getenv (variable, NULL, 0, &len);

  if (len == 0)
    return NULL;
  else
  {
    str = malloc (len);
    misc_getenv (variable, str, len, &len);

    return str;
  }
}

extern podule_info_t podule_info;

/*
 * perform a amu_machine call with printf style parameter passing
 */
#pragma check_printf_formats
static int
amu_machinef(char *format, ...)
{
  char *full_format;
  char buffer[BUFFER_LEN];
  va_list list;
  int ret = 0;

  /* Create the full format string from the system call, by adding together the
     contents of Alias$amu_machine, and the format string passed into the function */
  full_format = malloc (strlen (amu_machine) + strlen (format) + 1);
  if (full_format)
  {
    strcpy (full_format, amu_machine);
    strcat (full_format, format);

    /* Take the format string and extract the arguments used in the format string */
    va_start (list, format);
    vsprintf(buffer,full_format, list);
    va_end(list);
    if (verbose) {
      printf("%s\n",buffer);
    }
    /* Free the temporary buffer */
    free (full_format);

    /* Call the command */
    ret = system(buffer);
  }
  else
  {
    /* Malloc failed, print an error message and quit */
    printf ("Malloc failed, memory exhausted. Exitting...\n");
    exit (EXIT_FAILURE);
  }

  return ret;
}
#pragma -v0


/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN];

  strcpy(buffer, build_dir);
  strcat(buffer, ".");
  if (prefix) {
    strcat(buffer, prefix);
    strcat(buffer, ".");
  }
  strcat(buffer, filename);

  switch (file_exists(buffer)) {
    case 0:
      if (mkdir(buffer, 0) == -1)
	error(1, "creating directory '%s'.", buffer);
      break;
    case 1:
      error(1, "found file %s when it should be a directory.", buffer);
  }
  return 0;
}

/* Construct a set of directories, one level at a time. Each arg is parsed for directory
 * separators too to enable arbitrary paths to be easily created.
 */
static int
_check_dir_v(char *prefix, ...)
{
  va_list ap;
  const char *arg;
  char buffer[BUFFER_LEN];

  buffer[0] = '\0';

  va_start(ap, prefix);
  for (arg = prefix; arg; arg = va_arg(ap, const char *)) {
      const char *next, *p;
      for (p = arg, next = NULL; *p; p = next)
      {
        if (*buffer) strcat(buffer, ".");
        next = p + strcspn(p, ".");
        strncat(strchr(buffer, '\0'), p, next - p);
        _check_dir(NULL, buffer);
        if (*next) ++next;
      }
  }
  va_end(ap);
  return 0;
}

/*
 * create the directories required by the build process
 */
int build_dirs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char *apcs = getenv("APCS");
  char *exportdir = apcs ? "Export.<APCS>" : "Export";

  _check_dir(NULL, IMAGES_DIR);
  _check_dir(NULL, INSTALL_DIR);
  _check_dir(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, SHADOW_DIR);
  _check_dir(BUILDSYS_DIR, LOGS_DIR);
  _check_dir(NULL, "Export");
  if (apcs) _check_dir(NULL, exportdir);
  _check_dir(exportdir, "Hdr");
  _check_dir(exportdir, "Hdr.Global");
  _check_dir(exportdir, "Hdr.Interface");
  _check_dir(exportdir, "Hdr.Interface2");
  _check_dir(NULL, "Export.Lib");
  if (num_of_territories > 0)
  {
    unsigned int loop;
    for (loop=0; loop < num_of_territories; loop++)
    {
      char temp_string[255]; /* Nasty hard-coded value */
      _check_dir(messages_filename, "Resources");
      _check_dir(messages_filename, "Resources.<Build>");
      _check_dir(messages_filename, "Resources.<Build>.<Build$LocaleListNumeric>");
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Resources2", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Resources", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.<Build>.<Build$LocaleListNumeric>.%s.Apps", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
    }
  }

  /* set the Resource$Dir environment variable */
  sprintf(buffer, "%s.%s."RESDIR".^",
	  build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);

  _check_dir(NULL, INSTALL_DIR);
  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    if (module->output != NULL) /* Ensure we don't try to create oflaofla directories... ;-) */
    {
      sprintf(buffer, "%s.%s", build_name, module->output);
      _check_dir(INSTALL_DIR, buffer);
    }
    component = component->next;
  }
  return 0;
}




int build_clean(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a ROM phase of a component if we do not have any sources... */
    {
      switch (type) {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case EXP:
        case DATA:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	  error(0, "running make clean on module '%s'.", component->name);
  	/*
  	 * no need for force clean now
  	 */
  	component->force_clean = FALSE;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  return 0;
}





int build_export_hdrs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do an export_hdrs phase of a component if we do not have any sources... */
    {
      switch (type)
      {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case EXP:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=hdrs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0) {
  	  error(0, "running make export (hdrs) on module '%s'.",
  		component->name);
  	}
  	break;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_hdrs phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  return 0;
}



int build_export_libs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do an export_libs phase of a component if we do not have any sources... */
    {
      switch (type)
      {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        case EXP:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=libs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"")  != 0) {
  	  error(0, "running make export (libs) on module '%s'.",
  		component->name);
  	}
  	break;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_libs phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  return 0;
}




int build_resources_(int generate_script)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char bbe_dir[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  module_type_t type;
  char* locale = NULL;


  if (!generate_script)
  {
    /* Read the numeric locale list */
    if ((locale = read_env(ENV_NUM_LOCALE)) == NULL)
    {
      error(1, "Could not read the numeric lcoale list system variable. */");
    }

    /*
     * Force a make clean on the messages module. Note that this is independent
     * of any settings in the module database or component database, apart from %messages.
     * We are assuming quite a lot about the Messages module here...
     */
    printf("\nCleaning Messages...\n");
    sprintf(buffer, "%s.%s", build_dir, messages_filename);

    printf("\nCleaning Messages directory %s...\n", buffer);
    if (chdir(buffer))
      error(0, "cannot locate '%s'", buffer);
    else
    {
      sprintf(buffer,"-k clean COMPONENT=Messages TARGET=Messages NUMLOCALE=%s", locale);
      if (amu_machinef(buffer) != 0)
        error(0, "running make clean on module 'Messages'.");
    }

    /* Free the numeric locale list sys var memory. */
    if (locale) /* Usual memory-tidying gubbins */
    {
      free (locale);
      locale = NULL;
    }

    /* Build all the resource directories that are required. Can only be done after they have been cleaned as above. */
    build_dirs();
  }

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
      case RES:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	{
	  error(0, "cannot locate '%s'", buffer);
	}
	else
        {
          if (num_of_territories > 0)
          {
            /* We have been given a list of territories - iterate down them */
            unsigned int loop;
            for (loop=0; loop < num_of_territories; loop++)
            {
              if (generate_script)
              {
                sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
                sprintf(scriptfilename, "-o %s.%s.BBE_Res.%s ", build_dir, bbe_dir, supported_territories[loop]);
                remove(scriptfilename + 3);
                _check_dir_v(bbe_dir, "BBE_Res", NULL);
              }
              else
              {
                *scriptfilename = '\0';
              }
              /* set the Resource$Dir and Locale environment variable to the current */
              sprintf(buffer, "%s", supported_territories[loop]);
              setenv("Locale", buffer);
              sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[loop]);
              setenv("Resource$Dir", buffer);
              get_amu_machine(); /* Reset amu_machine to include the new values */

              if (amu_machinef("-k resources %s%s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
                    scriptfilename,
		    component->options ? component->options : "",
		    component->name,
		    module->filename?"TARGET=":"",
		    module->filename?module->filename:"") != 0)
	      error(0, "running make resources on module '%s'.", component->name);
            }
          }
        }
    }
    component = component->next;
  }

  /* Finally change the locale back to the default one (the first in the list). */
  sprintf(buffer, "%s", supported_territories[0]);
  setenv("Locale", buffer);
  sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
  if (verbose)
  {
    printf ("Set Locale and Resource$Dir to %s\n", buffer);
  }

  return 0;
}

int build_resources(void)
{
  return build_resources_(0);
}

static void line_by_line_copy(FILE *dest, FILE *source)
{
  char buffer[BUFFER_LEN * 2];

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    fputc('\t', dest);
    if (strncmp("echo", buffer, sizeof("echo")-1) == 0)
    {
      fputc('@', dest);
    }
    fputs(buffer, dest);
  }
}

static void copy_file(const char *destination, const char *source)
{
  _swix(OS_FSControl, _INR(0,3), 26, source, destination, 1<<1 /* force */);
}

static void copy_rom_link_rules(FILE *dest, FILE *source, const char *aof_target, const char *componentname)
{
  char buffer[BUFFER_LEN * 2];
  char link_args[BUFFER_LEN];
  int skip_next;
  enum skip_flags {
    skip_read = 0,
    skip_ignore = 1,
    skip_copy = 2,
    skip_copy_and_ignore = (skip_ignore | skip_copy)
  };

  strcpy(link_args, "link -o linked.${TARGET} -rmf -base ${ADDRESS} aof.${TARGET}");

  while (fgets(buffer, sizeof(buffer), source) != NULL) {
    char *next, *p, *source_file = NULL;
    if (!isspace(buffer[4])) continue;
    buffer[4] = '\0';
    if (cstrcmp("link", buffer)) continue;
    buffer[4] = ' ';

    /* Parse this link command to determine where the source file is and what abssym file it is linking against */
    buffer[strcspn(buffer, "\r\n")] = '\0'; /* strip eol - zero terminate */
    skip_next = skip_ignore;
    for (p = buffer, next = NULL; *p; p = next) {
      next = p;
      while (*next && !isspace(*next)) ++next;
      if (*next) *next++ = '\0';
      while (*next && isspace(*next)) ++next;
      if (skip_next != skip_read)
      {
        if (skip_next & skip_copy)
        {
          strcat(link_args, p);
        }
        skip_next = 0;
        continue;
      }
      if (*p == '-') {
        if (cstrcmp(p+1, "base") == 0 || cstrcmp(p+1, "o") == 0 || cstrcmp(p+1, "linkversion") == 0) {
          skip_next = skip_ignore;
        }
        else if (cstrcmp(p+1, "symdefs") == 0 || cstrcmp(p+1, "S") == 0 || cstrcmp(p+1, "syms") == 0 || cstrcmp(p+1, "symbols") == 0) {
          sprintf(strchr(link_args, '\0'), " %s ", p);
          skip_next = skip_copy_and_ignore;
        }
        continue;
      }
      if (*p == '>')
      {
        skip_next = p[1] ? skip_read : skip_ignore;
        continue;
      }

      if (source_file == NULL)
        source_file = p;

      strcat(link_args, " ");
      strcat(link_args, p);
    }

    copy_file(aof_target, source_file);
    fprintf(dest,
      "rom_link:\n"
      "\t${MKDIR} linked\n\t%s\n"
      "\t@${CP} linked.${TARGET} ${LINKDIR}.${TARGET} ${CPFLAGS}\n\n",
      link_args);
  }
}


int
build_install_rom_(int generate_script);

int build_bbe(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char bbe_dir[BUFFER_LEN];
  char aof_target[BUFFER_LEN];
  char rom_link_name[BUFFER_LEN];
  char *end_bbe_dir;
  module_type_t type;
  FILE *makefile;
  FILE *rom_link_file;
  FILE *resources_file;

  build_resources_(1);
  build_install_rom_(1);

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case DATA:
      case RES:
        printf("\n%s...\n", component->name);
        sprintf(bbe_dir, "%s.%s.BBE.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path);
        end_bbe_dir = strchr(bbe_dir, '\0');
        _check_dir_v(bbe_dir, "aof", NULL);
        sprintf(aof_target, "%s.%s", build_dir, bbe_dir);
        strcpy(bbe_dir, aof_target);
        end_bbe_dir = strchr(bbe_dir, '\0');
        strcpy(aof_target, bbe_dir);
        strcat(aof_target, ".aof.");
        strcat(aof_target, module->filename?module->filename:component->name);
        strcpy(end_bbe_dir, ".Makefile");
        makefile = fopen(bbe_dir, "w");
        if (makefile != NULL)
        {
          time_t now;
          time(&now);
          fprintf(makefile,
            "# Binary Build Environment Makefile for %s\n"
            "#\n"
            "# Generated at %s"
            "#\n"
            "\n"
            "include Makefiles:StdTools\n"
            "\n"
            "resources: resources-${LOCALE}\n"
            "\t@echo ${COMPONENT}: resources exported\n"
            "\n"
            "\n",
            component->name,
            ctime(&now));
        }
        strcpy(end_bbe_dir, ".BBE_ROM.rom_link");
        strcpy(rom_link_name, bbe_dir);
        sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
        if (makefile == NULL)
        {
          error(0, "cannot open BBE makefile");
        }
        else if (chdir(buffer))
        {
          error(0, "cannot locate '%s'", buffer);
        }
        else
        {
          /* We have been given a list of territories - iterate down them */
          unsigned int loop, done_uk = 0;
          for (loop=0; loop < num_of_territories && !done_uk; loop++)
          {
            if (strcmp(supported_territories[loop], "UK") == 0) done_uk = 1;
          }
          for (loop=0; loop < num_of_territories; loop++)
          {
            char *locale;
            /* set the Resource$Dir and Locale environment variable to the current */
            if (!done_uk) {
              locale = "UK";
              done_uk = 1;
              --loop;
            }
            else {
              locale = supported_territories[loop];
            }
            setenv("Locale", locale);
            get_amu_machine(); /* Reset amu_machine to include the new values */
            *end_bbe_dir = '\0';

            if (amu_machinef("-k -f Makefiles:BBEExport bbe COMPONENTTYPE=%s %s BBEDIR=%s COMPONENT=%s %s%s",
                  module_type_names[type],
                  component->options ? component->options : "",
                  bbe_dir,
                  component->name,
                  module->filename?"TARGET=":"",
                  module->filename?module->filename:"") != 0)
              error(0, "running make bbe on module '%s'.", component->name);

            /* Now read the locale script */
            strcpy(end_bbe_dir, ".BBE_Res.");
            strcat(end_bbe_dir, locale);
            resources_file = fopen(bbe_dir, "r");
            if (resources_file == NULL)
            {
              error(0, "loading BBE resource phase on module '%s'.", component->name);
            }
            else
            {
              /* Write out the rules for generating this locale's resource export */
              fprintf(makefile, "resources-%s:\n", locale);
              line_by_line_copy(makefile, resources_file);
              fprintf(makefile, "\t@| End of resource export for locale %s\n\n", locale);
              fclose(resources_file);
            }
          }
        }
        rom_link_file = fopen(rom_link_name, "r");
        if (makefile)
        {
          if (rom_link_file)
          {
            copy_rom_link_rules(makefile, rom_link_file, aof_target, component->name);
          }
          fclose(makefile);
          makefile = NULL;
        }
        if (rom_link_file)
        {
          fclose(rom_link_file);
          rom_link_file = NULL;
        }
    }
    component = component->next;
  }

  /* Finally change the locale back to the default one (the first in the list). */
  sprintf(buffer, "%s", supported_territories[0]);
  setenv("Locale", buffer);
  sprintf(buffer, "%s.%s.Resources."RESDIR, build_dir, messages_filename, supported_territories[0]);
  setenv("Resource$Dir", buffer);
  if (verbose)
  {
    printf ("Set Locale and Resource$Dir to %s\n", buffer);
  }

  return 0;
}



int build_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);

//  printf("DBG: shadow file: %s\n", buffer);

  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
    if (!component->no_component_sources) /* We do not wish to do a clean phase of a component if we do not have any sources... */
    {
      switch (type) {
        case C:
        case ASM:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else {
  	  /*
  	   * do we want to force a clean build due to changes
  	   */
  	  if (component->force_clean) {
  	    printf("Forcing a clean build due to switch/option changes...\n");
  	    if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	      error(0, "running make clean on module '%s'.", component->name);
  	  }
  	  /*
  	   * find out what we are switching this module on
  	   */
  	  switch_on = NULL;
  	  if (component->switch_on)
  	    switch_on = component->switch_on;
  	  else if (module->switch_on)
  	    switch_on = module->switch_on;

  	  if (component->options || switch_on) {
  	    fprintf(fh_shadow, "%s ", component->name);
  	    if (switch_on) {
  	      fprintf(fh_shadow, "-switch %s ", switch_on);
  	    }
  	    if (component->options) {
  	      fprintf(fh_shadow, "-options %s", component->options);
  	    }
  	    fprintf(fh_shadow, "\n");
  	  }

  	  if (amu_machinef("-k rom %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	    error(0, "running make rom on module '%s'.", component->name);
  	}
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

static int ran_install_rom;

int
build_install_rom_(int generate_script)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  char scriptdirname[BUFFER_LEN];
  char scriptfilename[BUFFER_LEN];
  module_type_t type;
  unsigned long int position_in_rom = 0x03800000;
  int size;
  int number_of_modules;
  int position_forced = 0;

  if (base_address) {
    position_in_rom = strtoul (base_address, NULL, 0);
  }

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sprintf(output_path, "%s.%s.%s.%s", build_dir,
	    INSTALL_DIR, build_name, module->output);

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
	printf("\n%s...\n", component->name);
	if (module->filename == NULL) {
	  printf("No output file for this component\n");
	} else {
	  sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	  if (chdir(buffer))
	    error(0, "cannot locate '%s'", buffer);
	  else {
	    if (position_forced && type != DATA) {
	      printf("Component not linked into module chain\n");
	    }
	    else if (type == DATA) {
	      if (!component->force_position)
	        component->force_position = position_in_rom;
	      if (component->force_position < position_in_rom)
	        error(0, "component overlaps previous data");
	      else {
  	        position_forced = 1;
    	        position_in_rom = component->force_position;
    	      }
	    }
	    else if (type == KERNEL) {
	      if (component->force_position) {
	        if (component->force_position < position_in_rom)
	          error(0, "component overlaps previous data");
    	        position_in_rom = component->force_position;
    	      }
    	    }
            if (generate_script)
            {
              sprintf(scriptdirname, "%s.%s.BBE.%s.%s.%s", INSTALL_DIR, build_name, SOURCE_DIR, module->path, "BBE_ROM");
              _check_dir_v(scriptdirname, NULL);
              sprintf(scriptfilename, "-o %s.%s.rom_link ADDRESS=<Address>", build_dir, scriptdirname);
            }
            else
            {
              sprintf(scriptfilename, "ADDRESS=%lu", position_in_rom);
            }
	    switch (type) {
	      case C:
		/* if module is C, link things correctly */
		if (amu_machinef("rom_link %s LINKDIR=%s %s COMPONENT=%s %s%s",
                        scriptfilename,
			output_path,
			component->options ? component->options : "",
			component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make rom_link on module '%s'.",
			component->name);

		break;

	      default:
		if (amu_machinef("install_rom INSTDIR=%s %s COMPONENT=%s %s%s",
		 	output_path,
		 	component->options ? component->options : "",
		 	component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make install_rom on module '%s'.",
			component->name);

		break;
	    }
	  }
	  /* Need to stat the module file, display position in ROM */
	  sprintf(buffer, "%s.%s", output_path, module->filename);

	  if ((size = file_size(buffer)) == -1)
	    error(1, "cannot stat file '%s'.", buffer);

	  /* keep record of things for later */
	  component->position = position_in_rom;
	  component->size = size;

	  /* calculate position of next module in ROM */
	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
	  if (type != KERNEL && type != HAL)	/* add some magic if not kernel */
	    position_in_rom += 4;
	}
    }
    component = component->next;
  }

  /* display the ROM entries */
  banner('-');
  printf("\nSummary of linked ROM contents...\n\n");
  printf("Module name                Position in ROM  Module size\n");
  printf("-----------                ---------------  -----------\n");
  component = component_database;
  number_of_modules = 0;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case HAL:
      case DATA:
	if (module->filename != NULL) {
	  number_of_modules++;
	  printf("%-25s  %08lX         %08X\n", component->name,
		 component->position, component->size);
	}
	break;
    }
    component = component->next;
  }
  printf("\nTotal of %d modules.\n", number_of_modules);

  ran_install_rom = 1;

  return 0;
}

int
build_install_rom(void)
{
  return build_install_rom_(0);
}

/*
 * write stuff out to the given file in the format required by BigSplit
 */
static int joiner_format_bigsplit(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int hal_count = 0;
  int kernel_count = 0;
  int size_printed = 0;
  unsigned long base = 0x03800000;

  if (base_address) {
    base = strtoul (base_address, NULL, 0);
  }

  if (!ran_install_rom) {
    unsigned long int position_in_rom;
    int size;
    int position_forced = 0;
    char buffer[BUFFER_LEN];
    char output_path[BUFFER_LEN];

    /* Scan the sizes of the files to get positions */
    position_in_rom = base;

    component = component_database;
    while (component) {
      module = lookup_module(component->name);
      type = component->type;
      if (type == UNDEF)
        type = module->type;

      sprintf(output_path, "%s.%s.%s.%s", build_dir,
  	    INSTALL_DIR, build_name, module->output);

      switch (type) {
        case C:
        case ASM:
        case BAS:
        case KERNEL:
        case HAL:
        case DATA:
        if (module->filename != NULL)
        {
	  if (position_forced && type != DATA) {
	  }
	  else if (type == DATA) {
	    if (!component->force_position)
	      component->force_position = position_in_rom;
  	    position_forced = 1;
    	    position_in_rom = component->force_position;
	  }
	  else if (type == KERNEL) {
	    if (component->force_position)
              position_in_rom = component->force_position;
    	  }
  	  /* Need to stat the module file, display position in ROM */
  	  sprintf(buffer, "%s.%s", output_path, module->filename);

  	  if ((size = file_size(buffer)) == -1)
  	    error(1, "cannot stat file '%s'.", buffer);

  	  /* keep record of things for later */
  	  component->position = position_in_rom;
  	  component->size = size;

  	  /* calculate position of next module in ROM */
  	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
  	  if (type != KERNEL && type != HAL)	/* add some magic if not kernel */
  	    position_in_rom += 4;
        }
      }
      component = component->next;
    }
  }

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == HAL) {
      fprintf(fh, "HAL:%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
      hal_count++;
    }
    else if (type == KERNEL) {
      if (component->force_position)
        fprintf(fh, "%lu\n", component->force_position - base);
      fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
      kernel_count++;
    }

    if (hal_count + kernel_count == 1 && !size_printed) {
      /* write out the image filename */
      fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

      /* write out the image size and misc newline */
      fprintf(fh, "%d\n\n", atoi(image_size) * 1024);

      size_printed = 1;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  if (hal_count > 1)
    error(0, "you appear to have more than one HAL in this ROM");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%lu\n", component->position - base);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
        }
	break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by MakeExpROM
 */
static int joiner_format_makeexprom(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      kernel_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count >= 1)
    error(0, "you appear to have a kernel in an expansion ROM!");

  /* write out the image filename */
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

  /* write out the image size */
  fprintf(fh, "%d\n", atoi(image_size));

  /* write out podule product code */
  fprintf(fh, "%s\n", podule_info.product?podule_info.product:"");

  /* write out podule description */
  fprintf(fh, "%s\n", podule_info.descript?podule_info.descript:"");

  /* write out podule serial number */
  fprintf(fh, "%s\n", podule_info.serial?podule_info.serial:"");

  /* write out podule status bit */
  fprintf(fh, "%s\n", podule_info.status?podule_info.status:"");

  /* write out podule manufacturer */
  fprintf(fh, "%s\n", podule_info.manuf?podule_info.manuf:"");

  /* write out podule part number */
  fprintf(fh, "%s\n", podule_info.part?podule_info.part:"");

  /* write out podule date */
  fprintf(fh, "%s\n", podule_info.date?podule_info.date:"");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%ld\n", component->position - 0x03800000);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
        }
	break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}


int
build_join(void)
{
  char filename[BUFFER_LEN];
  char buffer[BUFFER_LEN];
  FILE *fh = NULL;

  /* get a temp filename */
  strcpy(filename, tmpnam(NULL));

  if ((fh = fopen(filename, "w")) == NULL)
    error(1, "cannot open temp file '%s'.", filename);

  /* contruct the joiner file */
  if (cstrcmp(joiner_format, "BigSplit") == 0)
    joiner_format_bigsplit(fh);
  else if (cstrcmp(joiner_format, "MakeExpROM") == 0)
    joiner_format_makeexprom(fh);
  else
    error(1, "Unknown joiner file format '%s'", joiner_format);

  fclose(fh);

  /* check which joiner we are using */
  if (cstrcmp(joiner, "bigsplit") == 0) {
    sprintf(buffer, "%s { < %s }", joiner, filename);
  } else if (cstrcmp(joiner, "bigsplit2") == 0) {
    /* we have some options to deal with */
    if (sigstr) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else if (signum) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else {
      sprintf(buffer, "%s -nosig ", joiner);
    }
    strcat(buffer, filename);
  }
  else if (cstrcmp(joiner, "makeexprom") == 0) {
    /* we have some options to deal with */
    sprintf(buffer, "%s { < %s }", joiner, filename);
  }
  /* dispatch the joiner */
  if (system(buffer) != 0)
    error(1, "running joiner '%s' with file '%s'.", joiner, filename);

  remove(filename);

  return 0;
}

/*
 * generate a list of all modules to be included in a ROM
 */
int
build_list(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
	   component->options ? component->options : "");
    component = component->next;
  }
  return 0;
}


void get_amu_machine(void)
{
  char *s;
  char buffer[300];

  if (amu_machine)
  {
    free (amu_machine);
  }

  /* Grab the sysvar */
  amu_machine = misc_getenv_malloc ("Alias$amu_machine");

  if (verbose)
  {
    printf("amu_machine now = %s\n", amu_machine);
  }

  /* Remove the trailing %*0 */
  if ((s = strrchr (amu_machine, '%')) != NULL)
    *s = '\0';

  /* gstrans it... */
  _swix (OS_GSTrans, _INR(0,3),
           amu_machine, buffer, 300, 0);
  strcpy (amu_machine, buffer);


  if (verbose)
  {
    printf("amu_machine now = %s\n", amu_machine);
  }

}



/*
 * Function to initialise the build system, currently only extracts the value of
 * Alias$amu_machine and stores it internally in the correct form for use in
 * amu_machinef() */
void build_init(void)
{
  get_amu_machine();
}


/*
 * do RAM install phase
 * Added by SNB (Mon 09th August 1999).
 */
int
build_install(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;


//  printf("DBG: build_dir: %s\n", build_dir);
//  printf("DBG: install_dir: %s\n", INSTALL_DIR);
//  printf("DBG: build_name: %s\n", build_name);
//
//  if (module->name == NULL)
//    printf("DBG: module_name: NULL\n");
//  else
//    printf("DBG: module_name: %s\n", module->name);
//  if (module->path == NULL)
//    printf("DBG: module_path: NULL\n");
//  else
//    printf("DBG: module_path: %s\n", module->path);
//  if (module->output == NULL)
//    printf("DBG: module_output: NULL\n");
//  else
//    printf("DBG: module_output: %s\n", module->output);
//  if (module->filename == NULL)
//    printf("DBG: module_filename: NULL\n");
//  else
//    printf("DBG: module_filename: %s\n", module->filename);
//  if (component->name == NULL)
//    printf("DBG: component_name: NULL\n");
//  else
//    printf("DBG: component_name: %s\n", component->name);
//  if (component->options == NULL)
//    printf("DBG: component_options: NULL\n");
//  else
//    printf("DBG: component_options: %s\n", component->options);
//  if (component->install == NULL)
//    printf("DBG: component_install: NULL\n");
//  else
//    printf("DBG: component_install: %s\n", component->install);

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case KERNEL:
      case HAL:
      case DATA:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else {
	  /*
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
	    printf("Forcing a clean build due to switch/option changes...\n");
	    if (amu_machinef("-k clean %s COMPONENT=%s",
		component->options ? component->options : "",
		component->name) != 0)
	      error(0, "running make clean on module '%s'.", component->name);
	  }
	  /*
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

          /* Setup Install Dir */
          sprintf(output_path, "<Install$Dir>.%s", build_name);
          /* If -install is set then add it to install dir */
          if (component->install != NULL)
          {
            strcat(output_path, ".");
            strcat(output_path, component->install);
          }
          else
          {
            /* Some components don't have an Output dir.  If it isn't specified then install to
             * <install$dir>.<build>.component->name
             */
            if (module->output != NULL)
            {
              strcat(output_path, ".");
              strcat(output_path, module->output);
            }
            else
            {
              strcat(output_path, ".");
              strcat(output_path, component->name);
            }
          }

/* 	  printf("DBG: amu_machine -k install %s COMPONENT=%s %s%s INSTDIR=%s\n", */
/* 		component->options ? component->options : "", */
/* 		component->name, */
/* 		module->filename?"TARGET=":"", */
/* 		module->filename?module->filename:"", */
/* 		output_path); */

	  if (amu_machinef("-k install %s COMPONENT=%s %s%s INSTDIR=%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"",
		output_path) != 0)
	    error(0, "running make rom on module '%s'.", component->name);
	}
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}
