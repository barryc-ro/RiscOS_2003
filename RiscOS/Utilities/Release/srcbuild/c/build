/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "srcbuild.h"
#include "parse.h"
#include "riscos.h"

extern char *progname;
extern char *build_name;
extern char *build_dir;
extern char *image_filename;
extern char *log_filename;
extern char *image_size;
extern char *messages_filename;
extern char *module_type_names[];
extern char *joiner;
extern char *joiner_format;
extern char *sigstr;
extern char *signum;
extern int verbose;
extern module_entry_t *module_database;
extern component_entry_t *component_database;

/* 
 * perform a system call with printf style parameter passing
 */
int
systemf(char *format, ...)
{
  char buffer[BUFFER_LEN];
  va_list list;

  va_start (list, format);
  vsprintf(buffer,format, list);
  va_end(list);
  if (verbose) {
    printf("%s\n",buffer);
  }
  return (system(buffer));
}

/* 
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN];

  strcpy(buffer, build_dir);
  strcat(buffer, ".");
  if (prefix) {
    strcat(buffer, prefix);
    strcat(buffer, ".");
  }
  strcat(buffer, filename);

/*   if (verbose) */
/*     printf("Check '%s'.\n",buffer); */

  switch (file_exists(buffer)) {
    case 0:
      if (mkdir(buffer, 0) == -1)
	error(1, "creating directory '%s'.", buffer);
      break;
    case 1:
      error(1, "found file %s when it should be a directory.", buffer);
  }
  return 0;
}

/* 
 * create the directories required by the build process
 */
int
build_dirs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];

  _check_dir(NULL, IMAGES_DIR);
  _check_dir(NULL, INSTALL_DIR);
  _check_dir(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, SHADOW_DIR);
  _check_dir(BUILDSYS_DIR, LOGS_DIR);
  _check_dir(NULL, "Export");
  _check_dir(NULL, "Export.Hdr");
  _check_dir(NULL, "Export.Hdr.Global");
  _check_dir(NULL, "Export.Hdr.Interface");
  _check_dir(NULL, "Export.Hdr.Interface2");
  _check_dir(NULL, "Export.Lib");
  _check_dir(messages_filename, "Resources");
  _check_dir(messages_filename, "Resources.<Locale>");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources2");
  _check_dir(messages_filename, "Resources.<Locale>.<Build>.Apps");

  /* set the Resource$Dir environment variable */
  sprintf(buffer, "%s.%s.Resources.<Locale>.<Build>",
	  build_dir, messages_filename);
  setenv("Resource$Dir", buffer);

  _check_dir(NULL, INSTALL_DIR);
  component = component_database;
  while (component) {
    module = lookup_module(component->name);

    sprintf(buffer, "%s.%s", build_name, module->output);
    _check_dir(INSTALL_DIR, buffer);
    component = component->next;
  }
  return 0;
}

int
build_clean(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	  error(0, "running make clean on module '%s'.", component->name);
	/* 
	 * no need for force clean now
	 */
	component->force_clean = FALSE;
    }
    component = component->next;
  }

  return 0;
}

int
build_export_hdrs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case EXP:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (systemf("amu_machine -k export PHASE=hdrs COMPONENT=%s %s%s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0) {
	  error(0, "running make export (hdrs) on module '%s'.",
		component->name);
	}
	break;
    }
    component = component->next;
  }

  return 0;
}

int
build_export_libs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case EXP:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (systemf("amu_machine -k export PHASE=libs COMPONENT=%s %s%s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"")  != 0) {
	  error(0, "running make export (libs) on module '%s'.",
		component->name);
	}
	break;
    }
    component = component->next;
  }

  return 0;
}

int
build_resources(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  /* 
   * Force a make clean on the messages module
   */
  component = component_database;
  while (component) {
    if (cstrcmp(component->name, "Messages") == 0) {
      module = lookup_module(component->name);
      printf("\nCleaning %s...\n", component->name);
      sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
      if (chdir(buffer))
	error(0, "cannot locate '%s'", buffer);
      else if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	error(0, "running make clean on module '%s'.", component->name);
    }
    component = component->next;
  }
  build_dirs();

  /* 
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case RES:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else if (systemf("amu_machine -k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	  error(0, "running make resources on module '%s'.", component->name);
    }
    component = component->next;
  }
  return 0;
}

int
build_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else {
	  /* 
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
	    printf("Forcing a clean build due to switch/option changes...\n");
	    if (systemf("amu_machine -k clean COMPONENT=%s %s%s",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	      error(0, "running make clean on module '%s'.", component->name);
	  }
	  /* 
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

	  if (systemf("amu_machine -k rom %s COMPONENT=%s %s%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"") != 0)
	    error(0, "running make rom on module '%s'.", component->name);
	}
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

int
build_install_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  module_type_t type;
  int position_in_rom = 0x03800000;
  int size;
  int number_of_modules;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sprintf(output_path, "%s.%s.%s.%s", build_dir,
	    INSTALL_DIR, build_name, module->output);

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
	printf("\n%s...\n", component->name);
	if (module->filename == NULL) {
	  printf("No output file for this component\n");
	} else {
	  sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	  if (chdir(buffer))
	    error(0, "cannot locate '%s'", buffer);
	  else {
	    switch (type) {
	      case C:
		/* if module is C, link things correctly */
		if (systemf("amu_machine rom_link ADDRESS=%d LINKDIR=%s %s COMPONENT=%s %s%s",
			position_in_rom, output_path,
			component->options ? component->options : "",
			component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make rom_link on module '%s'.",
			component->name);

		break;

	      default:
		if (systemf("amu_machine install_rom INSTDIR=%s %s COMPONENT=%s %s%s",
		 	output_path,
		 	component->options ? component->options : "",
		 	component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make install_rom on module '%s'.",
			component->name);

		break;
	    }
	  }
	  /* Need to stat the module file, display position in ROM */
	  sprintf(buffer, "%s.%s", output_path, module->filename);

	  if ((size = file_size(buffer)) == -1)
	    error(1, "cannot stat file '%s'.", buffer);

	  /* keep record of things for later */
	  component->position = position_in_rom;
	  component->size = size;

	  /* calculate position of next module in ROM */
	  position_in_rom += ((size + 3) & ~3);
	  if (type != KERNEL)	/* add some magic if not kernel */
	    position_in_rom += 4;
	}
    }
    component = component->next;
  }

  /* display the ROM entries */
  banner('-');
  printf("\nSummary of linked ROM contents...\n\n");
  printf("Module name                Position in ROM  Module size\n");
  printf("-----------                ---------------  -----------\n");
  component = component_database;
  number_of_modules = 0;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
	if (module->filename != NULL) {
	  number_of_modules++;
	  printf("%-25s  %08X         %08X\n", component->name,
		 component->position, component->size);
	}
	break;
    }
    component = component->next;
  }
  printf("\nTotal of %d modules.\n", number_of_modules);
  return 0;
}

/* 
 * write stuff out to the given file in the format required by BigSplit
 */
static int
joiner_format_bigsplit(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
      kernel_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  /* write out the image filename */
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

  /* write out the image size and misc newline */
  fprintf(fh, "%d\n\n", atoi(image_size) * 1024);

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
	if (module->filename != NULL)
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);

	break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

int
build_join(void)
{
  char filename[BUFFER_LEN];
  char buffer[BUFFER_LEN];
  FILE *fh = NULL;

  /* get a temp filename */
  strcpy(filename, tmpnam(NULL));

  if ((fh = fopen(filename, "w")) == NULL)
    error(1, "cannot open temp file '%s'.", filename);

  /* contruct the joiner file */
  if (cstrcmp(joiner_format, "BigSplit") == 0)
    joiner_format_bigsplit(fh);
  else
    error(1, "Unknown joiner file format '%s'", joiner_format);

  fclose(fh);

  /* check which joiner we are using */
  if (cstrcmp(joiner, "bigsplit") == 0) {
    sprintf(buffer, "%s { < %s }", joiner, filename);
  } else if (cstrcmp(joiner, "bigsplit2") == 0) {
    /* we have some options to deal with */
    if (sigstr) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else if (signum) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else {
      sprintf(buffer, "%s -nosig ", joiner);
    }
    strcat(buffer, filename);
  }
  /* dispatch the joiner */
  if (system(buffer) != 0)
    error(1, "running joiner '%s' with file '%s'.", joiner, filename);

  remove(filename);

  return 0;
}

/* 
 * generate a list of all modules to be included in a ROM
 */
int
build_list(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
	   component->options ? component->options : "");
    component = component->next;
  }
  return 0;
}
