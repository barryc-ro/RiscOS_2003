/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "srcbuild.h"
#include "riscos.h"

extern char *progname;
extern char *build_name;
extern char *build_dir;
extern char *source_dir;
extern char *image_filename;
extern char *log_filename;
extern char *image_size;
extern char *messages_filename;
extern char *module_type_names[];
extern int  verbose;
extern module_entry_t    *module_database;
extern component_entry_t *component_database;


/* 
 * check for existance of a directory before creating it
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN];
  
  strcpy(buffer,"");
  if (prefix)
  {
    strcat(buffer,prefix);
    strcat(buffer,".");
  }
  strcat(buffer,filename);
  
  if (verbose)
    printf("Checking directory '%s'.\n",buffer);
    
  switch (file_exists(buffer))
  {
    case 0 :
      if (mkdir(buffer,0)==-1)
        error(1,"creating directory '%s'.",buffer);
      break;
    case 1 :
      error(1,"found file %s when it should be a directory.",buffer);
  }  
  return 0;  
}

/* 
 * create the directories required by the build process
 */
int
build_dirs(void)
{
  _check_dir(NULL,        	"<Install$Dir>");
  _check_dir(build_dir,		SHADOW_DIR);
  _check_dir(build_dir,		LOGS_DIR);
  _check_dir(build_dir,   	"Export");
  _check_dir(build_dir,   	"Export.Hdr");
  _check_dir(build_dir,   	"Export.Hdr.Global");
  _check_dir(build_dir,   	"Export.Hdr.Interface");
  _check_dir(build_dir,   	"Export.Hdr.Interface2");
  _check_dir(build_dir,   	"Export.Lib");
  _check_dir(messages_filename,"Resources");
  _check_dir(messages_filename,"Resources.<Locale>");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Resources");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Resources2");
  _check_dir(messages_filename,"Resources.<Locale>.<Build>.Apps");
  return 0;
}

int
build_clean(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  module_type_t type;
  
  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    switch (type)
    {
      case ASM : case C : case BAS :
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s",source_dir,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu -k clean")!=0)
            error(0,"running make clean on module '%s'.",component->name);
        /* 
         * no need for force clean now
         */
        component->force_clean = FALSE;
    }
    component=component->next;
  }

  return 0;
}

int
build_export_hdrs(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    if (type == EXP)
    {
      printf("\n%s...\n",component->name);
      sprintf(buffer,"%s.%s",source_dir,module->path);
      if (chdir(buffer))
        error(0,"cannot locate '%s'",buffer);
      else
        if (system("amu -k export PHASE=hdrs")!=0)
          error(0,"running make export (hdrs) on module '%s'.",component->name);
    }
    component=component->next;
  }

  return 0;
}

int
build_export_libs(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    if (type == EXP)
    {
      printf("\n%s...\n",component->name);
      sprintf(buffer,"%s.%s",source_dir,module->path);
      if (chdir(buffer))
        error(0,"cannot locate '%s'",buffer);
      else
        if (system("amu -k export PHASE=libs")!=0)
          error(0,"running make export (libs) on module '%s'.",component->name);
    }
    component=component->next;
  }

  return 0;
}

int
build_resources(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    switch (type)
    {
      case C : case ASM : case BAS :	/* do we really need BAS ? */
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s",source_dir,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
          if (system("amu -k resources")!=0)
            error(0,"running make resources on module '%s'.",component->name);
    }
    component=component->next;
  }  
  return 0;
}

int
build_rom(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow=NULL;
  char *switch_on=NULL;
  module_type_t type;

  sprintf(buffer,"%s.%s.%s",build_dir,SHADOW_DIR,build_name);
  if ((fh_shadow=fopen(buffer,"w"))==NULL)
    error(1,"cannot open shadow file '%s'.",buffer);
    
  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    switch (type)
    {
      case C : case ASM : case BAS :	/* do we really need BAS ? */
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s",source_dir,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
        {
          /* 
           * do we want to force a clean build due to changes
           */
          if (component->force_clean)
          {
            printf("Forcing a clean build due to switch/option changes...\n");
            if (system("amu clean")!=0)
              error(0,"running make clean on module '%s'.",component->name);
          }
          
          /* 
           * find out what we are switching this module on
           */
          switch_on=NULL;
          if (component->switch_on)
            switch_on = component->switch_on;
          else if (module->switch_on)
            switch_on = module->switch_on;
          
          fprintf(fh_shadow,"%s %s %s\n",component->name,
          		component->options?component->options:"",
          		switch_on?switch_on:"");
          
          sprintf(buffer,"amu rom %s",component->options?component->options:"");
          if (system(buffer)!=0)
            error(0,"running make rom on module '%s'.",component->name);
        }
    }
    component=component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

int
build_install_rom(void)
{
  component_entry_t *component;
  module_entry_t    *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component)
  {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
      
    switch (type)
    {
      case C : case ASM : case BAS :	/* do we really need BAS ? */
        printf("\n%s...\n",component->name);
        sprintf(buffer,"%s.%s",source_dir,module->path);
        if (chdir(buffer))
          error(0,"cannot locate '%s'",buffer);
        else
        {
          sprintf(buffer,"amu -k install_rom INSTDIR=<Install$Dir>.%s",
          	build_name);
          if (system(buffer)!=0)
            error(0,"running make install_rom on module '%s'.",component->name);
        }
    }
    component=component->next;
  }  
  return 0;
}
