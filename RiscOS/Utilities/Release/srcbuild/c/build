/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

/* ANSI Includes */
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

/* RISC OS Includes */
#include "kernel.h"
#include "swis.h"

/* Local includes */
#include "srcbuild.h"
#include "parse.h"
#include "riscos.h"

extern char *progname;
extern char *build_name;
extern char *build_dir;
extern char *image_filename;
extern char *log_filename;
extern char *image_size;
extern char *messages_filename;
extern char *module_type_names[];
extern char *joiner;
extern char *joiner_format;
extern char *sigstr;
extern char *signum;
extern char *base_address;
extern int verbose;
extern module_entry_t *module_database;
extern component_entry_t *component_database;

/* The contents of Alias$amu_machine */
static char *amu_machine = NULL;
void get_amu_machine(void);


/*
 * A nice veneer to OS_ReadVarVal
 */
static void misc_getenv (const char *variable, char *buffer, int buffer_size, int *nbytes)
{
  if (buffer == NULL)
  {
    _kernel_swi_regs r;

     r.r[0] = (int)variable;
     r.r[1] = NULL;
     r.r[2] = -1;
     r.r[3] = 0;
     r.r[4] = 0;

     _kernel_swi (OS_ReadVarVal, &r, &r);

     if (nbytes != NULL)
     {
       if (r.r[2] == 0)
         *nbytes = 0;
       else
       {
         *nbytes = ~r.r[2] + 1;
       }
     }
  }
  else
  {
    int len;

    _swix (OS_ReadVarVal, _INR(0,4) | _OUT(2),
           variable, buffer, buffer_size, 0, 0,
           &len);

    buffer[len] = '\0';

    if (nbytes != NULL)
    {
      *nbytes = len + 1;
    }
  }
}


/*
 * Veneer to OS_ReadVarVal that does it's own memory allocation, uses misc_getenv
 */
static char *misc_getenv_malloc (const char *variable)
{
  char *str;
  int len;

  misc_getenv (variable, NULL, 0, &len);

  if (len == 0)
    return NULL;
  else
  {
    str = malloc (len);
    misc_getenv (variable, str, len, &len);

    return str;
  }
}

extern podule_info_t podule_info;

/*
 * perform a amu_machine call with printf style parameter passing
 */
static int
amu_machinef(char *format, ...)
{
  char *full_format;
  char buffer[BUFFER_LEN];
  va_list list;
  int ret = 0;

  /* Create the full format string from the system call, by adding together the
     contents of Alias$amu_machine, and the format string passed into the function */
  full_format = malloc (strlen (amu_machine) + strlen (format) + 1);
  if (full_format)
  {
    strcpy (full_format, amu_machine);
    strcat (full_format, format);

    /* Take the format string and extract the arguments used in the format string */
    va_start (list, format);
    vsprintf(buffer,full_format, list);
    va_end(list);
    if (verbose) {
      printf("%s\n",buffer);
    }
    /* Free the temporary buffer */
    free (full_format);

    /* Call the command */
    ret = system(buffer);
  }
  else
  {
    /* Malloc failed, print an error message and quit */
    printf ("Malloc failed, memory exhausted. Exitting...\n");
    exit (EXIT_FAILURE);
  }

  return ret;
}


/*
 * check for existance of a directory before creating it, prefix all dirs
 * with build_dir.
 */
static int
_check_dir(char *prefix, char *filename)
{
  char buffer[BUFFER_LEN];

  strcpy(buffer, build_dir);
  strcat(buffer, ".");
  if (prefix) {
    strcat(buffer, prefix);
    strcat(buffer, ".");
  }
  strcat(buffer, filename);

/*   if (verbose) */
/*     printf("Check '%s'.\n",buffer); */

  switch (file_exists(buffer)) {
    case 0:
      if (mkdir(buffer, 0) == -1)
	error(1, "creating directory '%s'.", buffer);
      break;
    case 1:
      error(1, "found file %s when it should be a directory.", buffer);
  }
  return 0;
}

/*
 * create the directories required by the build process
 */
int
build_dirs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char *apcs = getenv("APCS");
  char *exportdir = apcs ? "Export.<APCS>" : "Export";

  _check_dir(NULL, IMAGES_DIR);
  _check_dir(NULL, INSTALL_DIR);
  _check_dir(INSTALL_DIR, build_name);
  _check_dir(BUILDSYS_DIR, SHADOW_DIR);
  _check_dir(BUILDSYS_DIR, LOGS_DIR);
  _check_dir(NULL, "Export");
  if (apcs) _check_dir(NULL, exportdir);
  _check_dir(exportdir, "Hdr");
  _check_dir(exportdir, "Hdr.Global");
  _check_dir(exportdir, "Hdr.Interface");
  _check_dir(exportdir, "Hdr.Interface2");
  _check_dir(NULL, "Export.Lib");
  if (num_of_territories > 0)
  {
    unsigned int loop;
    for (loop=0; loop < num_of_territories; loop++)
    {
      char temp_string[255];
      _check_dir(messages_filename, "Resources");
      sprintf (temp_string, "Resources.%s", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.%s.<Build>", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.%s.<Build>.Resources2", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.%s.<Build>.Resources", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
      sprintf (temp_string, "Resources.%s.<Build>.Apps", supported_territories[loop]);
      _check_dir(messages_filename, temp_string);
    }
  }
  else
  {
    /* Just do it with the default locale from the envirobment file. */
    _check_dir(messages_filename, "Resources");
    _check_dir(messages_filename, "Resources.<Locale>");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Resources2");
    _check_dir(messages_filename, "Resources.<Locale>.<Build>.Apps");
  }

  /* set the Resource$Dir environment variable */
  sprintf(buffer, "%s.%s.Resources.<Locale>.<Build>",
	  build_dir, messages_filename);
  setenv("Resource$Dir", buffer);

  _check_dir(NULL, INSTALL_DIR);
  component = component_database;
  while (component) {
    module = lookup_module(component->name);

    sprintf(buffer, "%s.%s", build_name, module->output);
    _check_dir(INSTALL_DIR, buffer);
    component = component->next;
  }
  return 0;
}

int
build_clean(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do a ROM phase of a component if we do not have any sources... */
    {
      switch (type) {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case EXP:
        case DATA:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	  error(0, "running make clean on module '%s'.", component->name);
  	/*
  	 * no need for force clean now
  	 */
  	component->force_clean = FALSE;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running clean phase on this component.\n", component->name, component->name);
    }

    component = component->next;
  }

  return 0;
}

int
build_export_hdrs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do an export_hdrs phase of a component if we do not have any sources... */
    {
      switch (type)
      {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case DATA:
        case EXP:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=hdrs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0) {
  	  error(0, "running make export (hdrs) on module '%s'.",
  		component->name);
  	}
  	break;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_hdrs phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  return 0;
}

int
build_export_libs(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (!component->no_component_sources) /* We do not wish to do an export_libs phase of a component if we do not have any sources... */
    {
      switch (type)
      {
        case ASM:
        case C:
        case BAS:
        case KERNEL:
        case DATA:
        case EXP:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else if (amu_machinef("-k export %s PHASE=libs COMPONENT=%s %s%s",
  		component->options ? component->options:"",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"")  != 0) {
  	  error(0, "running make export (libs) on module '%s'.",
  		component->name);
  	}
  	break;
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running export_libs phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  return 0;
}

int
build_resources(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  module_type_t type;

  /*
   * Force a make clean on the messages module. Note that this is independent
   * of any settings in the module database or component database, apart from %messages.
   * We are assuming quite a lot about the Messages module here...
   */
  printf("\nCleaning Messages...\n");
  sprintf(buffer, "%s.%s", build_dir, messages_filename);
  if (chdir(buffer))
    error(0, "cannot locate '%s'", buffer);
  else if (amu_machinef("-k clean COMPONENT=Messages TARGET=Messages" ) != 0)
    error(0, "running make clean on module 'Messages'.");

  build_dirs();

  /*
   * now get on with rest
   */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case DATA:
      case RES:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	{
	  error(0, "cannot locate '%s'", buffer);
	}
	else
	{
          if (num_of_territories > 0)
          {
            /* We have been given a list of territories - iterate down them */
            unsigned int loop;
            for (loop=0; loop < num_of_territories; loop++)
            {
              /* set the Resource$Dir and Locale environment variable */
              sprintf(buffer, "%s", supported_territories[loop]);
              setenv("Locale", buffer);
              sprintf(buffer, "%s.%s.Resources.<Locale>.<Build>", build_dir, messages_filename);
              setenv("Resource$Dir", buffer);
              get_amu_machine(); /* Reset amu_machine to include the new values */

              if (amu_machinef("-k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
		    component->options ? component->options : "",
		    component->name,
		    module->filename?"TARGET=":"",
		    module->filename?module->filename:"") != 0)
	      error(0, "running make resources on module '%s'.", component->name);
            }
          }
          else
          {
            /* Use the original locale as set in the env file */
	    if (amu_machinef("-k resources %s RESDIR=<Resource$Dir>.Resources COMPONENT=%s %s%s",
		  component->options ? component->options : "",
		  component->name,
		  module->filename?"TARGET=":"",
		  module->filename?module->filename:"") != 0)
	    error(0, "running make resources on module '%s'.", component->name);
          }
	}
    }
    component = component->next;
  }
  return 0;
}

int
build_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);

//  printf("DBG: shadow file: %s\n", buffer);

  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;
    if (!component->no_component_sources) /* We do not wish to do a clean phase of a component if we do not have any sources... */
    {
      switch (type) {
        case C:
        case ASM:
        case BAS:
        case KERNEL:
        case DATA:
  	printf("\n%s...\n", component->name);
  	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
  	if (chdir(buffer))
  	  error(0, "cannot locate '%s'", buffer);
  	else {
  	  /*
  	   * do we want to force a clean build due to changes
  	   */
  	  if (component->force_clean) {
  	    printf("Forcing a clean build due to switch/option changes...\n");
  	    if (amu_machinef("-k clean %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	      error(0, "running make clean on module '%s'.", component->name);
  	  }
  	  /*
  	   * find out what we are switching this module on
  	   */
  	  switch_on = NULL;
  	  if (component->switch_on)
  	    switch_on = component->switch_on;
  	  else if (module->switch_on)
  	    switch_on = module->switch_on;

  	  if (component->options || switch_on) {
  	    fprintf(fh_shadow, "%s ", component->name);
  	    if (switch_on) {
  	      fprintf(fh_shadow, "-switch %s ", switch_on);
  	    }
  	    if (component->options) {
  	      fprintf(fh_shadow, "-options %s", component->options);
  	    }
  	    fprintf(fh_shadow, "\n");
  	  }

  	  if (amu_machinef("-k rom %s COMPONENT=%s %s%s",
  		component->options ? component->options : "",
  		component->name,
  		module->filename?"TARGET=":"",
  		module->filename?module->filename:"") != 0)
  	    error(0, "running make rom on module '%s'.", component->name);
  	}
      }
    }
    else
    {
      printf("\n%s...\nComponent %s: nosources flag passed in, therefore not running ROM phase on this component.\n", component->name, component->name);
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}

int
build_install_rom(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  module_type_t type;
  unsigned long int position_in_rom = 0x03800000;
  int size;
  int number_of_modules;
  int position_forced = 0;

  if (base_address) {
    position_in_rom = strtoul (base_address, NULL, 0);
  }

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    sprintf(output_path, "%s.%s.%s.%s", build_dir,
	    INSTALL_DIR, build_name, module->output);

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case KERNEL:
      case DATA:
	printf("\n%s...\n", component->name);
	if (module->filename == NULL) {
	  printf("No output file for this component\n");
	} else {
	  sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	  if (chdir(buffer))
	    error(0, "cannot locate '%s'", buffer);
	  else {
	    if (position_forced && type != DATA) {
	      printf("Component not linked into module chain\n");
	    }
	    else if (type == DATA) {
	      if (!component->force_position)
	        component->force_position = position_in_rom;
	      if (component->force_position < position_in_rom)
	        error(0, "component overlaps previous data");
	      else {
  	        position_forced = 1;
    	        position_in_rom = component->force_position;
    	      }
	    }
	    switch (type) {
	      case C:
		/* if module is C, link things correctly */
		if (amu_machinef("rom_link ADDRESS=%lu LINKDIR=%s %s COMPONENT=%s %s%s",
			position_in_rom, output_path,
			component->options ? component->options : "",
			component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make rom_link on module '%s'.",
			component->name);

		break;

	      default:
		if (amu_machinef("install_rom INSTDIR=%s %s COMPONENT=%s %s%s",
		 	output_path,
		 	component->options ? component->options : "",
		 	component->name,
			module->filename?"TARGET=":"",
			module->filename?module->filename:"") != 0)
		  error(1, "running make install_rom on module '%s'.",
			component->name);

		break;
	    }
	  }
	  /* Need to stat the module file, display position in ROM */
	  sprintf(buffer, "%s.%s", output_path, module->filename);

	  if ((size = file_size(buffer)) == -1)
	    error(1, "cannot stat file '%s'.", buffer);

	  /* keep record of things for later */
	  component->position = position_in_rom;
	  component->size = size;

	  /* calculate position of next module in ROM */
	  position_in_rom += (((unsigned long int) size + 3UL) & ~3UL);
	  if (type != KERNEL)	/* add some magic if not kernel */
	    position_in_rom += 4;
	}
    }
    component = component->next;
  }

  /* display the ROM entries */
  banner('-');
  printf("\nSummary of linked ROM contents...\n\n");
  printf("Module name                Position in ROM  Module size\n");
  printf("-----------                ---------------  -----------\n");
  component = component_database;
  number_of_modules = 0;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case KERNEL:
      case DATA:
	if (module->filename != NULL) {
	  number_of_modules++;
	  printf("%-25s  %08lX         %08X\n", component->name,
		 component->position, component->size);
	}
	break;
    }
    component = component->next;
  }
  printf("\nTotal of %d modules.\n", number_of_modules);
  return 0;
}

/*
 * write stuff out to the given file in the format required by BigSplit
 */
static int joiner_format_bigsplit(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
	      INSTALL_DIR, build_name, module->output, module->filename);
      kernel_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count > 1)
    error(0, "you appear to have more than one kernel in this ROM");
  else if (kernel_count < 1)
    error(0, "you seem to be missing a kernel in this ROM");

  /* write out the image filename */
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

  /* write out the image size and misc newline */
  fprintf(fh, "%d\n\n", atoi(image_size) * 1024);

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%ld\n", component->position - 0x03800000);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
        }
	break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}

/*
 * write stuff out to the given file in the format required by MakeExpROM
 */
static int joiner_format_makeexprom(FILE * fh)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;
  int kernel_count = 0;

  /* look for kernel */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    if (type == KERNEL) {
      kernel_count++;
    }
    component = component->next;
  }

  /* warn if things are not ok */
  if (kernel_count >= 1)
    error(0, "you appear to have a kernel in an expansion ROM!");

  /* write out the image filename */
  fprintf(fh, "%s.%s.%s\n", build_dir, IMAGES_DIR, image_filename);

  /* write out the image size */
  fprintf(fh, "%d\n", atoi(image_size));

  /* write out podule product code */
  fprintf(fh, "%s\n", podule_info.product?podule_info.product:"");

  /* write out podule description */
  fprintf(fh, "%s\n", podule_info.descript?podule_info.descript:"");

  /* write out podule serial number */
  fprintf(fh, "%s\n", podule_info.serial?podule_info.serial:"");

  /* write out podule status bit */
  fprintf(fh, "%s\n", podule_info.status?podule_info.status:"");

  /* write out podule manufacturer */
  fprintf(fh, "%s\n", podule_info.manuf?podule_info.manuf:"");

  /* write out podule part number */
  fprintf(fh, "%s\n", podule_info.part?podule_info.part:"");

  /* write out podule date */
  fprintf(fh, "%s\n", podule_info.date?podule_info.date:"");

  /* now write out the other modules in order */
  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    switch (type) {
      case ASM:
      case C:
      case BAS:
      case DATA:
	if (module->filename != NULL) {
	  if (type == DATA)
	    fprintf(fh, "%ld\n", component->position - 0x03800000);
	  fprintf(fh, "%s.%s.%s.%s.%s\n", build_dir,
		  INSTALL_DIR, build_name, module->output, module->filename);
        }
	break;
    }
    component = component->next;
  }
  fprintf(fh, "\n");

  return 0;
}


int
build_join(void)
{
  char filename[BUFFER_LEN];
  char buffer[BUFFER_LEN];
  FILE *fh = NULL;

  /* get a temp filename */
  strcpy(filename, tmpnam(NULL));

  if ((fh = fopen(filename, "w")) == NULL)
    error(1, "cannot open temp file '%s'.", filename);

  /* contruct the joiner file */
  if (cstrcmp(joiner_format, "BigSplit") == 0)
    joiner_format_bigsplit(fh);
  else if (cstrcmp(joiner_format, "MakeExpROM") == 0)
    joiner_format_makeexprom(fh);
  else
    error(1, "Unknown joiner file format '%s'", joiner_format);

  fclose(fh);

  /* check which joiner we are using */
  if (cstrcmp(joiner, "bigsplit") == 0) {
    sprintf(buffer, "%s { < %s }", joiner, filename);
  } else if (cstrcmp(joiner, "bigsplit2") == 0) {
    /* we have some options to deal with */
    if (sigstr) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else if (signum) {
      sprintf(buffer, "%s -sigstr %s ", joiner, sigstr);
    } else {
      sprintf(buffer, "%s -nosig ", joiner);
    }
    strcat(buffer, filename);
  }
  else if (cstrcmp(joiner, "makeexprom") == 0) {
    /* we have some options to deal with */
    sprintf(buffer, "%s { < %s }", joiner, filename);
  }
  /* dispatch the joiner */
  if (system(buffer) != 0)
    error(1, "running joiner '%s' with file '%s'.", joiner, filename);

//  remove(filename);

  return 0;
}

/*
 * generate a list of all modules to be included in a ROM
 */
int
build_list(void)
{
  component_entry_t *component;
  module_entry_t *module;
  module_type_t type;

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;

    printf("%-25s %-10s %s\n", component->name, module_type_names[(int) type],
	   component->options ? component->options : "");
    component = component->next;
  }
  return 0;
}


void get_amu_machine(void)
{
  char *s;
  char buffer[300];

  if (amu_machine)
  {
    free (amu_machine);
  }

  /* Grab the sysvar */
  amu_machine = misc_getenv_malloc ("Alias$amu_machine");

  if (verbose)
  {
    printf("amu_machine now = %s\n", amu_machine);
  }

  /* Remove the trailing %*0 */
  if ((s = strrchr (amu_machine, '%')) != NULL)
    *s = '\0';

  /* gstrans it... */
  _swix (OS_GSTrans, _INR(0,3),
           amu_machine, buffer, 300, 0);
  strcpy (amu_machine, buffer);


  if (verbose)
  {
    printf("amu_machine now = %s\n", amu_machine);
  }

}



/*
 * Function to initialise the build system, currently only extracts the value of
 * Alias$amu_machine and stores it internally in the correct form for use in
 * amu_machinef() */
void build_init(void)
{
  get_amu_machine();
}


/*
 * do RAM install phase
 * Added by SNB (Mon 09th August 1999).
 */
int
build_install(void)
{
  component_entry_t *component;
  module_entry_t *module;
  char buffer[BUFFER_LEN];
  char output_path[BUFFER_LEN];
  FILE *fh_shadow = NULL;
  char *switch_on = NULL;
  module_type_t type;

  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, build_name);
  if ((fh_shadow = fopen(buffer, "w")) == NULL)
    error(1, "cannot open shadow file '%s'.", buffer);

  component = component_database;
  while (component) {
    module = lookup_module(component->name);
    type = component->type;
    if (type == UNDEF)
      type = module->type;


//  printf("DBG: build_dir: %s\n", build_dir);
//  printf("DBG: install_dir: %s\n", INSTALL_DIR);
//  printf("DBG: build_name: %s\n", build_name);
//
//  if (module->name == NULL)
//    printf("DBG: module_name: NULL\n");
//  else
//    printf("DBG: module_name: %s\n", module->name);
//  if (module->path == NULL)
//    printf("DBG: module_path: NULL\n");
//  else
//    printf("DBG: module_path: %s\n", module->path);
//  if (module->output == NULL)
//    printf("DBG: module_output: NULL\n");
//  else
//    printf("DBG: module_output: %s\n", module->output);
//  if (module->filename == NULL)
//    printf("DBG: module_filename: NULL\n");
//  else
//    printf("DBG: module_filename: %s\n", module->filename);
//  if (component->name == NULL)
//    printf("DBG: component_name: NULL\n");
//  else
//    printf("DBG: component_name: %s\n", component->name);
//  if (component->options == NULL)
//    printf("DBG: component_options: NULL\n");
//  else
//    printf("DBG: component_options: %s\n", component->options);
//  if (component->install == NULL)
//    printf("DBG: component_install: NULL\n");
//  else
//    printf("DBG: component_install: %s\n", component->install);

    switch (type) {
      case C:
      case ASM:
      case BAS:
      case RES:
      case KERNEL:
      case DATA:
	printf("\n%s...\n", component->name);
	sprintf(buffer, "%s.%s.%s", build_dir, SOURCE_DIR, module->path);
	if (chdir(buffer))
	  error(0, "cannot locate '%s'", buffer);
	else {
	  /*
	   * do we want to force a clean build due to changes
	   */
	  if (component->force_clean) {
	    printf("Forcing a clean build due to switch/option changes...\n");
	    if (amu_machinef("-k clean %s COMPONENT=%s",
		component->options ? component->options : "",
		component->name) != 0)
	      error(0, "running make clean on module '%s'.", component->name);
	  }
	  /*
	   * find out what we are switching this module on
	   */
	  switch_on = NULL;
	  if (component->switch_on)
	    switch_on = component->switch_on;
	  else if (module->switch_on)
	    switch_on = module->switch_on;

	  if (component->options || switch_on) {
	    fprintf(fh_shadow, "%s ", component->name);
	    if (switch_on) {
	      fprintf(fh_shadow, "-switch %s ", switch_on);
	    }
	    if (component->options) {
	      fprintf(fh_shadow, "-options %s", component->options);
	    }
	    fprintf(fh_shadow, "\n");
	  }

          /* Setup Install Dir */
          sprintf(output_path, "<Install$Dir>.%s", build_name);
          /* If -install is set then add it to install dir */
          if (component->install != NULL)
          {
            strcat(output_path, ".");
            strcat(output_path, component->install);
          }
          else
          {
            /* Some components don't have an Output dir.  If it isn't specified then install to
             * <install$dir>.<build>.component->name
             */
            if (module->output != NULL)
            {
              strcat(output_path, ".");
              strcat(output_path, module->output);
            }
            else
            {
              strcat(output_path, ".");
              strcat(output_path, component->name);
            }
          }

/* 	  printf("DBG: amu_machine -k install %s COMPONENT=%s %s%s INSTDIR=%s\n", */
/* 		component->options ? component->options : "", */
/* 		component->name, */
/* 		module->filename?"TARGET=":"", */
/* 		module->filename?module->filename:"", */
/* 		output_path); */

	  if (amu_machinef("-k install %s COMPONENT=%s %s%s INSTDIR=%s",
		component->options ? component->options : "",
		component->name,
		module->filename?"TARGET=":"",
		module->filename?module->filename:"",
		output_path) != 0)
	    error(0, "running make rom on module '%s'.", component->name);
	}
    }
    component = component->next;
  }

  if (fh_shadow)
    fclose(fh_shadow);

  return 0;
}
