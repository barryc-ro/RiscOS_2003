/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdarg.h>
#include "srcbuild.h"
#include "build.h"
#include "parse.h"
#include "riscos.h"

/*
 * globals
 */
char *progname = NULL;
char *build_name = NULL;
char *build_dir = NULL;
char *image_filename = NULL;
char *log_filename = NULL;
char *messages_filename = NULL;
char *joiner = NULL;
char *joiner_format = NULL;
char *image_size = NULL;
podule_info_t podule_info =
{NULL, NULL, NULL, NULL, NULL, NULL, NULL};
char *sigstr = NULL;
char *signum = NULL;
char *base_address = NULL;
char *module_type_names[] =
{ALL_MODULE_TYPES(ARRAY_ENTRY)};
int verbose = FALSE;
int strict = FALSE;

module_entry_t *module_database = NULL;
component_entry_t *component_database = NULL;
error_entry_t *error_database = NULL;

static const action_t action_tbl[] =
{
  build_clean, "clean", "clean the build",
  build_export_hdrs, "export_hdrs", "export headers",
  build_export_libs, "export_libs", "export libraries",
  build_resources, "resources", "export resources",
  build_rom, "rom", "make modules for rom",
  build_install_rom, "install_rom", "install components",
  build_join, "join", "join modules to construct rom",
  build_list, "list", "list all modules to appear in rom",
  0, 0, 0, 0
};



/*
 * Set the system variables as appropriate on program finalisation.
 */
void set_sys_vars(int success)
{
  char buffer[BUFFER_LEN];
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, LOGS_DIR, log_filename);
  setenv("SrcBuild$LogfileLocation", buffer);
  sprintf(buffer, "%s.%s.%s", build_dir, IMAGES_DIR, image_filename);
  setenv("SrcBuild$ImageLocation", buffer);
  sprintf(buffer, "%d", success);
  setenv("SrcBuild$ReturnCode", buffer);
}



/*
 * send error message to stderr
 */
void
error(int fatal, char *format,...)
{
  va_list list;
  char buffer[BUFFER_LEN];
  error_entry_t *entry, *this;

  va_start(list, format);
  vsprintf(buffer, format, list);
  va_end(list);

  if (fatal || strict) {
    fprintf(stderr, "Fatal error ");
    strcat(buffer, "\n");
    fprintf(stderr, buffer);
    exit(EXIT_FAILURE);
  }
  if ((this = malloc(sizeof(error_entry_t))) == NULL)
    error(1, "%s: memory allocation error.", progname);

  this->message = strdup(buffer);
  this->next = NULL;
  printf("Error %s\n", this->message);

  if (error_database == NULL)
    error_database = this;
  else {
    entry = error_database;
    while (entry->next)
      entry = entry->next;
    entry->next = this;
  }
}

/*
 * look an entry by name and return its structure
 */
module_entry_t *
lookup_module(char *name)
{
  module_entry_t *entry = module_database;

  while (entry) {
    if (strcmp(entry->name, name) == 0)
      return (entry);
    entry = entry->next;
  }

  return (NULL);
}

/*
 * look an component entry by name and return its structure
 */
component_entry_t *
lookup_component(char *name)
{
  component_entry_t *entry = component_database;

  while (entry) {
    if (strcmp(entry->name, name) == 0)
      return (entry);
    entry = entry->next;
  }

  return (NULL);
}

/*
 * read the database into a linked list of records.
 */
int
read_module_database(void)
{
  FILE *file = NULL;
  char buffer[BUFFER_LEN];
  char *cp, *word = NULL;
  module_entry_t *entry, *this;
  int i, line_number = 0;

  /*
   * work out filename
   */
  sprintf(buffer, "%s.%s.%s", build_dir, BUILDSYS_DIR, MODULE_DB_FILE);
  if ((file = fopen(buffer, "r")) == NULL)
    error(1, "cannot open module database file %s.", buffer);

  if (verbose)
    printf("Using module database '%s'.\n", buffer);

  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#') {	/* ignore comments */
	cp = buffer;
	cp = extract_word(cp, &word, FALSE);	/* extract the name */
	if (word != NULL) {	/* ignore null lines */
	  if (lookup_module(word) != NULL) {
	    error(1, "duplicate '%s' entry in module database line %d.",
		  word, line_number);
	  }
	  /* allocate a new entry */
	  if ((this = malloc(sizeof(module_entry_t))) == NULL)
	    error(1, "memory allocation error.");

	  this->name = word;
	  word = NULL;
	  this->path = NULL;
	  this->output = NULL;
	  this->filename = NULL;
	  this->switch_on = NULL;
	  this->type = UNDEF;
	  this->next = module_database;
	  module_database = this;
	  entry = this;

	  cp = extract_word(cp, &word, FALSE);
	  for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
	    if (cstrcmp(word, module_type_names[i]) == 0) {
	      entry->type = (module_type_t) i;
	      free(word);
	      word = NULL;
	      break;
	    }
	  }
	  if (word != NULL) {	/* module type not found */
	    error(1, "unknown module type '%s' in module database line %d.",
		  word, line_number);
	  }
	  cp = extract_word(cp, &(entry->path), FALSE);
	  cp = extract_word(cp, &(entry->output), FALSE);
	  cp = extract_word(cp, &(entry->filename), FALSE);
	  cp = extract_word(cp, &(entry->switch_on), TRUE);
	}
      }
    }
  }

  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/*
 * read the shadow components file
 */
int
read_shadow_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp;
  char *name = NULL;
  char *options = NULL;
  char *switch_on = NULL;
  char *word = NULL;
  int options_same;
  int switch_same;
  component_entry_t *component;
  module_entry_t *module;

  /*
   * work out shadow components filename
   */
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, SHADOW_DIR, filename);
  if ((file = fopen(buffer, "r")) == NULL)
    return (0);

  if (verbose)
    printf("Using shadow components file '%s'.\n", buffer);

  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
      name = options = switch_on = NULL;

      chop_newline(buffer);
      cp = buffer;
      cp = extract_word(cp, &name, FALSE);	/* extract the name */

      if ((component = lookup_component(name)) != NULL) {
	while (cp) {		/* while there is still text on line */
	  /* get the options word */
	  cp = extract_word(cp, &word, FALSE);
	  if (cstrcmp(word, "-options") == 0) {
	    options = strdup(cp);	/* rest of line */
	  } else if (cstrcmp(word, "-switch") == 0) {
	    cp = extract_word(cp, &switch_on, TRUE);
	  }
	}
/*         printf("found option %s\n",CHK_STR(options)); */
/*         printf("found switch %s\n",CHK_STR(switch_on)); */
/*         printf("comp  option %s\n",CHK_STR(component->options)); */
/*         printf("comp  switch %s\n",CHK_STR(component->switch_on)); */

	options_same = FALSE;
	switch_same = FALSE;
	/* do we have any options */
	if (!component->options && !options)
	  options_same = TRUE;

	/* check out options first */
	if (component->options)
	  if (cstrcmp(component->options, options) == 0)
	    options_same = TRUE;

	/* now check out switches */
	if (component->switch_on) {
	  if (cstrcmp(component->switch_on, switch_on) == 0)
	    switch_same = TRUE;
	} else {
	  if ((module = lookup_module(name)) != NULL) {
	    if (module->switch_on) {
	      if (cstrcmp(component->switch_on, switch_on) == 0)
		switch_same = TRUE;
	    } else {
	      if (!switch_on)
		switch_same = TRUE;
	    }
	  }
	}
	/* mark the module for not needing clean */
	if (switch_same && options_same)
	  component->force_clean = FALSE;
      }
    }
  }
  fclose(file);

  if (name)
    free(name);
  if (options)
    free(options);
  if (switch_on)
    free(switch_on);
  if (word)
    free(word);

  return (0);
}

/*
 * read the components file into a linked list of records.
 */
int
read_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp, *word = NULL, *dependancy = NULL;
  component_entry_t *entry, *this;
  int i, line_number = 0;

  /*
   * work out components filename
   */
  sprintf(buffer, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, COMPONENTS_DIR, filename);
  if ((file = fopen(buffer, "r")) == NULL)
    error(1, "cannot open component database file '%s'.", buffer);

  if (verbose)
    printf("Using components file '%s'.\n", buffer);

  while (!feof(file)) {
    fgets(buffer, sizeof(buffer), file);
    if (!feof(file)) {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#') {	/* ignore comments */
	dependancy = NULL;

	cp = buffer;
	cp = extract_word(cp, &word, FALSE);	/* extract the name */
	if (word != NULL) {	/* ignore null lines */
	  if (cstrcmp(word, "%log") == 0) {	/* deal with log file */
	    cp = extract_word(cp, &log_filename, TRUE);
	  } else if (cstrcmp(word, "%image") == 0) {
	    /* deal with image file */
	    cp = extract_word(cp, &image_filename, TRUE);
	  } else if (cstrcmp(word, "%messages") == 0) {
	    /* deal with messages */
	    cp = extract_word(cp, &messages_filename, TRUE);
	  } else if (cstrcmp(word, "%joiner") == 0) {
	    /* deal with BigSplit et al */
	    cp = extract_word(cp, &joiner, FALSE);
	  } else if (cstrcmp(word, "%joinerformat") == 0) {
	    /* deal with format */
	    cp = extract_word(cp, &joiner_format, FALSE);
	  } else if (cstrcmp(word, "%poduleproduct") == 0) {
	    /* deal with podule bits */
	    cp = extract_word(cp, &(podule_info.product), FALSE);
	  } else if (cstrcmp(word, "%poduledescription") == 0) {
	    podule_info.descript = strdup(cp);
	  } else if (cstrcmp(word, "%poduleserial") == 0) {
	    cp = extract_word(cp, &(podule_info.serial), FALSE);
	  } else if (cstrcmp(word, "%podulestatus") == 0) {
	    cp = extract_word(cp, &(podule_info.status), FALSE);
	  } else if (cstrcmp(word, "%podulemanufacture") == 0) {
	    cp = extract_word(cp, &(podule_info.manuf), FALSE);
	  } else if (cstrcmp(word, "%podulepart") == 0) {
	    cp = extract_word(cp, &(podule_info.part), FALSE);
	  } else if (cstrcmp(word, "%poduledate") == 0) {
	    cp = extract_word(cp, &(podule_info.date), FALSE);
	  } else if (cstrcmp(word, "%sigstr") == 0) {
	    /* deal with the signature word eg NCOS */
	    cp = extract_word(cp, &sigstr, FALSE);
	    if (signum && sigstr) {
	      error(0, "dual signature declaration, using sigstr.");
	    }
	  } else if (cstrcmp(word, "%signum") == 0) {
	    cp = extract_word(cp, &signum, FALSE);
	    if (signum && sigstr) {
	      error(0, "dual signature declaration, using sigstr.");
	    }
	  } else if (cstrcmp(word, "%include") == 0) {
	    /* deal with includes */
	    cp = extract_word(cp, &word, FALSE);
	    if (cstrcmp(word, filename) == 0)
	      error(1, "cannot recursivly include '%s'.", filename);

	    if (read_component_database(word))	/* recurse */
	      goto exit_gracefully;
	  } else if (cstrcmp(word, "%baseaddress") == 0) {
	    cp = extract_word(cp, &base_address, FALSE);
	  } else {
	    if ((dependancy = strchr(word, ':')) != NULL) {
	      *dependancy = 0;
	      dependancy++;
	      if (lookup_component(dependancy) == NULL) {
		error(1, "attempt to depend '%s' on a non existant component "
		      "'%s' (line %d).", word, dependancy, line_number);
	      }
	    }
	    if (word[0] == '-') {	/* module to remove */
	      component_entry_t *last = NULL;
	      if ((entry = lookup_component(word + 1)) == NULL) {
		error(1, "attempt to remove non existant component '%s' "
		      "(line %d).", word + 1, line_number);
	      }
	      entry = component_database;
	      last = NULL;
	      while (strcmp(entry->name, word + 1) != 0) {
		last = entry;
		entry = entry->next;
	      }

	      if (last == NULL)
		component_database = entry->next;
	      else
		last->next = entry->next;
	      release_component(entry);

	    } else {
	      if (lookup_module(word) == NULL) {
		error(1, "'%s' entry (line %d) not found in module database.",
		      word, line_number);
	      }
	      /* look to see if entry exists already */
	      if ((entry = lookup_component(word)) == NULL) {
		/* allocate a new entry */
		if ((this = malloc(sizeof(component_entry_t))) == NULL)
		  error(1, "memory allocation error.");

		this->name = word;
		this->options = NULL;
		this->switch_on = NULL;
		this->next = NULL;
		this->type = UNDEF;
		this->next = NULL;
		this->force_clean = FALSE;	/* default state */
		this->force_position = 0;

		if (dependancy) {	/* we have some dependancy */
		  component_entry_t *tmp = lookup_component(dependancy);
		  this->next = tmp->next;
		  tmp->next = this;
		} else {
		  if (component_database == NULL)
		    component_database = this;
		  else {
		    entry = component_database;
		    while (entry->next)
		      entry = entry->next;
		    entry->next = this;
		  }
		}

		entry = this;
	      }
	      word = NULL;

	      while (cp) {	/* while there is still text on line */
		/* get the options word */
		cp = extract_word(cp, &word, FALSE);
		if (cstrcmp(word, "-options") == 0) {
		  entry->options = strdup(cp);	/* rest of line */
		  entry->force_clean = TRUE;
		} else if (cstrcmp(word, "-switch") == 0) {
		  cp = extract_word(cp, &(entry->switch_on), TRUE);
		  entry->force_clean = TRUE;
		} else if (cstrcmp(word, "-type") == 0) {
		  cp = extract_word(cp, &word, FALSE);
		  for (i = 0; i < sizeof(module_type_names) / sizeof(char *); i++) {
		    if (cstrcmp(word, module_type_names[i]) == 0) {
		      entry->type = (module_type_t) i;
		      free(word);
		      word = NULL;
		      break;
		    }
		  }
		  if (word != NULL) {	/* module type not found */
		    error(1, "unknown module type '%s' in module database "
			  "line %d.", word, line_number);
		  }
		} else if (cstrcmp(word, "-address") == 0) {
		  cp = extract_word(cp, &word, FALSE);
		  entry->force_position = (unsigned) strtol(word, NULL, 16);
		}
	      }
	    }
	  }
	}
      }
    }
  }
exit_gracefully:
  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/*
 * free up any mallocs
 */
void
release_module_database(void)
{
  module_entry_t *entry, *this;

  entry = module_database;
  while (entry) {
    if (entry->name)
      free(entry->name);
    if (entry->path)
      free(entry->path);
    if (entry->output)
      free(entry->output);
    if (entry->filename)
      free(entry->filename);
    if (entry->switch_on)
      free(entry->switch_on);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

void
release_component(component_entry_t * entry)
{
  if (entry->name)
    free(entry->name);
  if (entry->options)
    free(entry->options);
  if (entry->switch_on)
    free(entry->switch_on);
}

void
release_component_database(void)
{
  component_entry_t *entry, *this;

  entry = component_database;
  while (entry) {
    release_component(entry);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

void
release_error_database(void)
{
  error_entry_t *entry, *this;

  entry = error_database;
  while (entry) {
    if (entry->message)
      free(entry->message);
    this = entry;
    entry = entry->next;
    free(this);
  }
}

/*
 * print a banner of characters
 */
void
banner(char c)
{
  char buffer[BUFFER_LEN];
  memset(buffer, c, BUFFER_LEN);
  buffer[78] = 0;
  printf("%s\n", buffer);
}

/*
 * display usage info
 */
void
usage(void)
{
  const action_t *action;

  printf("Acorn '%s' version " APP_VERSION "\n\n", progname);

  printf("Usage: %s [options] <action>\n", progname);
  printf("Options:\n");
  printf("   -h, -help    : display this message\n");
  printf("   -v, -verbose : display more progress info\n");
  printf("   -s, -strict  : abort on non-fatal errors\n");
  printf("Actions:\n");

  for (action = &action_tbl[0]; action->call; action++)
    printf("   %-12s : %s\n", action->name, action->help);
}

/*
 * tidy up before quiting
 */
void
doexit(void)
{
  error_entry_t *entry;
  int error = 0;

  release_module_database();
  release_component_database();

  entry = error_database;
  while (entry) {
    if (error == 0)
      printf("Batched errors...\n");
    error++;
    printf("Error %s\n", entry->message);
    entry = entry->next;
  }

  if (error)
  {
    banner('-');
    set_sys_vars(0); /* Inform other programs that the build failed */
  }
  else
  {
    set_sys_vars(1); /* Inform other programs that the build was successful */
  }

  spool_close(log_filename);

  release_error_database();
  if (build_name)
    free(build_name);
  if (build_dir)
    free(build_dir);
  if (image_filename)
    free(image_filename);
  if (log_filename)
    free(log_filename);
  if (image_size)
    free(image_size);
  if (sigstr)
    free(sigstr);
  if (signum)
    free(signum);
  if (messages_filename)
    free(messages_filename);
  if (joiner)
    free(joiner);
  if (joiner_format)
    free(joiner_format);
  if (base_address)
    free(base_address);

  if (podule_info.product)
    free(podule_info.product);
  if (podule_info.descript)
    free(podule_info.descript);
  if (podule_info.serial)
    free(podule_info.serial);
  if (podule_info.status)
    free(podule_info.status);
  if (podule_info.manuf)
    free(podule_info.manuf);
  if (podule_info.part)
    free(podule_info.part);
  if (podule_info.date)
    free(podule_info.date);
}

int
main(int argc, char *argv[])
{
  const action_t *action;
  time_t now;
  int i, found, first;

  progname = argv[0];
  atexit(doexit);

  /*
   * sort out flags etc
   */
  for (i = 1; i < argc; i++) {
    if (argv[i][0] != '-')
      break;
    if ((cstrcmp(argv[i], "-h") == 0) || (cstrcmp(argv[i], "-help") == 0)) {
      usage();
      exit(EXIT_FAILURE);
    } else if ((cstrcmp(argv[i], "-v") == 0) || (cstrcmp(argv[i], "-verbose") == 0))
      verbose = TRUE;
    else if ((cstrcmp(argv[i], "-s") == 0) || (cstrcmp(argv[i], "-strict") == 0))
      strict = TRUE;
  }

  /*
   * check for action
   */
  if (argc < 2 || i >= argc) {
    usage();
    exit(EXIT_FAILURE);
  }
  first = i;			/* record first non flag argument */

  /*
   * we need to know Build$Dir and Build environment variables
   */
  if ((build_dir = read_env(ENV_BUILD_DIR)) == NULL)
    error(1, "cannot locate build directory, please run a !Env file.");

  if ((build_name = read_env(ENV_BUILD_NAME)) == NULL)
    error(1, "cannot identify build name, please run a !Env file.");

  if ((image_size = read_env(ENV_IMAGE_SIZE)) == NULL)
    error(1, "cannot establish a image size, please run a !Env file.");

  /*
   * read in our main files
   */
  read_module_database();
  read_component_database(build_name);
  read_shadow_component_database(build_name);
  build_dirs();
  /*
   * start spooling
   */
  spool_open(log_filename);
  banner('-');

  /*
   * display some banner info
   */
  now = time(NULL);
  printf("Started %s build : %s", build_name, asctime(localtime(&now)));


  if (verbose) {
    printf("Log filename       : %s\n", CHK_STR(log_filename));
    printf("Image filename     : %s\n", CHK_STR(image_filename));
    printf("Messages location  : %s\n", CHK_STR(messages_filename));
    printf("Image size         : %s\n", CHK_STR(image_size));
    printf("Joiner application : %s\n", CHK_STR(joiner));
    printf("Joiner format      : %s\n", CHK_STR(joiner_format));
    if (cstrcmp(joiner_format, "podule") == 0) {
      printf("Podule info ...\n");
      printf("  Product code        : %s\n", CHK_STR(podule_info.product));
      printf("  Description         : %s\n", CHK_STR(podule_info.descript));
      printf("  Serial              : %s\n", CHK_STR(podule_info.serial));
      printf("  Mod Status          : %s\n", CHK_STR(podule_info.status));
      printf("  Pace of manufacture : %s\n", CHK_STR(podule_info.manuf));
      printf("  Part number         : %s\n", CHK_STR(podule_info.part));
      printf("  Date                : %s\n", CHK_STR(podule_info.date));
    }
  }
  /*
   * dispatch the action
   */
  banner('-');
  for (i = first; i < argc; i++) {
    found = FALSE;
    for (action = &action_tbl[0]; action->call; action++) {
      if (cstrcmp(action->name, argv[i]) == 0) {
	found = TRUE;
	break;
      }
    }
    if (!found) {
      usage();
      exit(EXIT_FAILURE);
    }
    printf("Starting phase %s ...\n", action->name);
    (*(action->call)) ();
    banner('=');
  }

  now = time(NULL);
  printf("Finished %s build : %s", build_name, asctime(localtime(&now)));
  banner('-');

  return (0);
}

