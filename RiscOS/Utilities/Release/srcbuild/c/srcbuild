/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdarg.h>
#include "srcbuild.h"
#include "build.h"
#include "parse.h"
#include "riscos.h"

/* 
 * globals
 */
char *progname=NULL;
char *build_name=NULL;
char *build_dir=NULL;
char *image_filename=NULL;
char *log_filename=NULL;
char *messages_filename=NULL;
char *joiner=NULL;
char *joiner_format=NULL;
char *image_size=NULL;
podule_info_t podule_info = {NULL,NULL,NULL,NULL,NULL,NULL,NULL};
char *module_type_names[]={ALL_MODULE_TYPES(ARRAY_ENTRY)};
int  verbose=FALSE;
int  strict =FALSE;

module_entry_t    *module_database=NULL;
component_entry_t *component_database=NULL;
error_entry_t     *error_database=NULL;

static const action_t action_tbl[] = {
 build_clean,		"clean",	"clean the build",
 build_export_hdrs,	"export_hdrs",	"export headers",
 build_export_libs,	"export_libs",	"export libraries",
 build_resources,	"resources",	"export resources",
 build_rom,		"rom",		"make modules for rom",
 build_install_rom,	"install_rom",	"install components",
 build_join,		"join",		"join modules to construct rom",
 build_list,		"list",		"list all modules to appear in rom",
 0,0,0,0
};

/* 
 * send error message to stderr
 */
void
error(int fatal, char *format, ...)
{
  va_list list;
  char buffer[BUFFER_LEN];
  error_entry_t *entry,*this;
  
  va_start (list, format);
  vsprintf(buffer, format, list);
  va_end(list);
  
  if (fatal || strict)
  {
    fprintf(stderr,"Fatal error ");
    strcat(buffer,"\n");
    fprintf(stderr,buffer);
    exit(1);
  }
  
  if ((this=malloc(sizeof(error_entry_t)))==NULL)
    error(1,"%s: memory allocation error.",progname);
    
  this->message = strdup(buffer);
  this->next = NULL;
  printf("Error %s\n",this->message);
  
  if (error_database==NULL)
    error_database = this;
  else
  {
    entry = error_database;
    while (entry->next)
       entry=entry->next;
    entry->next = this;
  }
}

/* 
 * look an entry by name and return its structure
 */
module_entry_t *
lookup_module(char *name)
{
  module_entry_t *entry=module_database;

  while (entry)
  {
    if (strcmp(entry->name,name)==0)
      return (entry);
    entry=entry->next;
  }
  
  return (NULL);
}

/* 
 * look an component entry by name and return its structure
 */
component_entry_t *
lookup_component(char *name)
{
  component_entry_t *entry=component_database;

  while (entry)
  {
    if (strcmp(entry->name,name)==0)
      return (entry);
    entry=entry->next;
  }
    
  return (NULL);
}

/* 
 * read the database into a linked list of records.
 */
int
read_module_database(void)
{
  FILE *file=NULL;
  char buffer[BUFFER_LEN];
  char *cp,*word;
  module_entry_t *entry,*this;
  int i,line_number=0;
  
  /* 
   * work out filename
   */
  sprintf(buffer,"%s.%s.%s",build_dir,BUILDSYS_DIR,MODULE_DB_FILE);
  if ((file=fopen(buffer,"r"))==NULL)
    error(1,"cannot open module database file %s.",buffer);

  if (verbose)
    printf("Using module database '%s'.\n",buffer);
  
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#')  /* ignore comments */
      {
        cp=buffer;
        cp = extract_word(cp,&word,FALSE);  		/* extract the name */
        if (word!=NULL)					/* ignore null lines */
        {
          if (lookup_module(word)!=NULL)
          {
            error(1,"duplicate '%s' entry in module database line %d.",
            	word,line_number);
          }

          /* allocate a new entry */
          if ((this=malloc(sizeof(module_entry_t)))==NULL)
            error(1,"memory allocation error.");

    	  this->name = word;
  	  word=NULL;
          this->path      = NULL;
          this->output    = NULL;
          this->filename  = NULL;
          this->switch_on = NULL;
          this->type 	  = UNDEF;
          this->next      = module_database;
          module_database = this;
          entry = this;

          cp = extract_word(cp,&word,FALSE);
          for (i=0; i<sizeof(module_type_names)/sizeof(char*); i++)
          {
            if (cstrcmp(word,module_type_names[i])==0)
            {
              entry->type = (module_type_t)i;
              free(word);
              word=NULL;
              break;
            }
          }
          if (word!=NULL)		/* module type not found */
          {
            error(1,"unknown module type '%s' in module database line %d.",
            	word,line_number);
          }
          cp = extract_word(cp,&(entry->path),FALSE);
          cp = extract_word(cp,&(entry->output),FALSE);
          cp = extract_word(cp,&(entry->filename),FALSE);
          cp = extract_word(cp,&(entry->switch_on),TRUE);
        }
      }
    }
  }

  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/* 
 * read the shadow components file
 */
int
read_shadow_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp;
  char *name=NULL;
  char *options=NULL;
  char *switch_on=NULL;
  int options_same;
  int switch_same;
  component_entry_t *component;
  module_entry_t    *module;
  
  /* 
   * work out shadow components filename
   */
  sprintf(buffer,"%s.%s.%s.%s",build_dir,BUILDSYS_DIR,SHADOW_DIR,filename);
  if ((file=fopen(buffer,"r"))==NULL)
    return (0);

  if (verbose)
    printf("Using shadow components file '%s'.\n",buffer);
      
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
      if (name)      free(name);
      if (options)   free(options);
      if (switch_on) free(switch_on);
      name = options = switch_on = NULL;
      
      chop_newline(buffer);
      cp = buffer;
      cp = extract_word(cp,&name,FALSE);  		/* extract the name */
      
      if ((component = lookup_component(name))!=NULL)
      {
        cp = extract_word(cp,&options,FALSE);
        if (cstrcmp(options,"-")==0);
        {
          free(options);
          options=NULL;
        }
        cp = extract_word(cp,&switch_on,FALSE);
        if (cstrcmp(switch_on,"-")==0)
        {
          free(switch_on);
          switch_on=NULL;
        }
/*         printf("found option %s\n",CHK_STR(options)); */
/*         printf("found switch %s\n",CHK_STR(switch_on)); */
/*         printf("comp  option %s\n",CHK_STR(component->options)); */
/*         printf("comp  switch %s\n",CHK_STR(component->switch_on)); */

        options_same=FALSE;
        switch_same=FALSE;
        /* do we have any options */
	if (!component->options && !options)
	  options_same=TRUE;

        /* check out options first */
        if (component->options)
          if (cstrcmp(component->options,options)==0)
            options_same=TRUE;

        /* now check out switches */
        if (component->switch_on) {
          if (cstrcmp(component->switch_on,switch_on)==0)
            switch_same=TRUE;
        } else {
          if ((module=lookup_module(name))!=NULL) {
            if (module->switch_on) {
              if (cstrcmp(component->switch_on,switch_on)==0)
                switch_same=TRUE;
            } else {
              if (!switch_on)
                switch_same=TRUE;
            }
          }            
        }
        /* mark the module for not needing clean */
        if (switch_same && options_same)
          component->force_clean=FALSE;
      }
    }
  }
  fclose(file);
  
  if (name)      free(name);
  if (options)   free(options);
  if (switch_on) free(switch_on);
  
  return(0);
}

/* 
 * read the components file into a linked list of records.
 */
int
read_component_database(char *filename)
{
  FILE *file;
  char buffer[BUFFER_LEN];
  char *cp,*word=NULL,*dependancy=NULL;
  component_entry_t *entry,*this;
  int i,line_number=0;
  
  /* 
   * work out components filename
   */
  sprintf(buffer,"%s.%s.%s.%s",build_dir,BUILDSYS_DIR,COMPONENTS_DIR,filename);
  if ((file=fopen(buffer,"r"))==NULL)
    error(1,"cannot open component database file '%s'.",buffer);

  if (verbose)
    printf("Using components file '%s'.\n",buffer);
      
  while (!feof(file))
  {
    fgets(buffer,sizeof(buffer),file);
    if (!feof(file))
    {
      line_number++;
      chop_newline(buffer);
      if (buffer[0] != '#')  /* ignore comments */
      {
        if (word)
          free(word);
        dependancy=NULL;
          
        cp=buffer;
        cp = extract_word(cp,&word,FALSE);  		/* extract the name */
        if (word != NULL)				/* ignore null lines */
        {
          if (cstrcmp(word,"%log")==0)		/* deal with log file */
          {
            if (log_filename) free(log_filename);
            cp = extract_word(cp,&log_filename,TRUE);
          }
          else if (cstrcmp(word,"%image")==0)	/* deal with image file */
          {
            if (image_filename) free(image_filename);
            cp = extract_word(cp,&image_filename,TRUE);
          }
          else if (cstrcmp(word,"%messages")==0)/* deal with messages */
          {
            if (messages_filename) free(messages_filename);
            cp = extract_word(cp,&messages_filename,TRUE);
          }
          else if (cstrcmp(word,"%joiner")==0)	/* deal with BigSplit et al */
          {
            if (joiner) free(joiner);
            cp = extract_word(cp,&joiner,FALSE);
          }
          else if (cstrcmp(word,"%joinerformat")==0)/* deal with format */
          {
            if (joiner_format) free(joiner_format);
            cp = extract_word(cp,&joiner_format,FALSE);
          }
          else if (cstrcmp(word,"%poduleproduct")==0)/* deal with podule bits */
          {
            if (podule_info.product)  free(podule_info.product);
            cp = extract_word(cp,&(podule_info.product),FALSE);
          }
          else if (cstrcmp(word,"%poduledescription")==0)
          {
            if (podule_info.descript)  free(podule_info.descript);
            podule_info.descript = strdup(cp);
          }
          else if (cstrcmp(word,"%poduleserial")==0)
          {
            if (podule_info.serial)  free(podule_info.serial);
            cp = extract_word(cp,&(podule_info.serial),FALSE);
          }
          else if (cstrcmp(word,"%podulestatus")==0)
          {
            if (podule_info.status)  free(podule_info.status);
            cp = extract_word(cp,&(podule_info.status),FALSE);
          }
          else if (cstrcmp(word,"%podulemanufacture")==0)
          {
            if (podule_info.manuf)  free(podule_info.manuf);
            cp = extract_word(cp,&(podule_info.manuf),FALSE);
          }
          else if (cstrcmp(word,"%podulepart")==0)
          {
            if (podule_info.part)  free(podule_info.part);
            cp = extract_word(cp,&(podule_info.part),FALSE);
          }
          else if (cstrcmp(word,"%poduledate")==0)
          {
            if (podule_info.date)  free(podule_info.date);
            cp = extract_word(cp,&(podule_info.date),FALSE);
          }
          else if (cstrcmp(word,"%include")==0)	/* deal with includes */
          {
            free(word);
            cp = extract_word(cp,&word,FALSE);
            if (cstrcmp(word,filename)==0)
              error(1,"cannot recursivly include '%s'.",filename);

            if (read_component_database(word))	/* recurse */
              goto exit_gracefully;
          }
          else
          {
            if ((dependancy=strchr(word,':'))!=NULL)
            {
              *dependancy=0;
              dependancy++;
              if (lookup_component(dependancy)==NULL)
              {
                error(1,"attempt to depend '%s' on a non existant component "
                	"'%s' (line %d).",word,dependancy,line_number);
              }
            }
            if (word[0]=='-')		/* module to remove */
            {
              component_entry_t *last=NULL;
              if ((entry=lookup_component(word+1))==NULL)
              {
                error(1,"attempt to remove non existant component '%s' "
                	"(line %d).",word+1,line_number);
              }
              entry = component_database;
              last  = NULL;
	      while (strcmp(entry->name,word+1)!=0)
	      {
                last=entry;
                entry=entry->next;
              }

              if (last==NULL)
                component_database = entry->next;
              else
                last->next = entry->next;
              release_component(entry);
              
            }
            else
            {
              if (lookup_module(word)==NULL)
              {
                error(1,"'%s' entry (line %d) not found in module database.",
              		word,line_number);
              }
              /* look to see if entry exists already */
              if ((entry=lookup_component(word))==NULL)
              {
                /* allocate a new entry */
                if ((this=malloc(sizeof(component_entry_t)))==NULL)
                  error(1,"memory allocation error.");
  
      	        this->name        = word;
                this->options     = NULL;
                this->switch_on   = NULL;
                this->next        = NULL;
                this->type        = UNDEF;    
      	        this->next 	  = NULL;
      	        this->force_clean = FALSE;	/* default state */
      	        
      	        if (dependancy)			/* we have some dependancy */
      	        {
      	          component_entry_t *tmp=lookup_component(dependancy);
      	          this->next = tmp->next;
      	          tmp->next = this;
      	        }
      	        else
      	        {
        	  if (component_database==NULL)
      	            component_database = this;
      	          else
      	          {
      	            entry = component_database;
      	            while (entry->next)
      	              entry=entry->next;
                    entry->next = this;
                  }
      	        }
                  
                entry = this;
              }
              else
              {
                free(word);
              }
  	      word=NULL;
	    
      	      while (cp)		/* while there is still text on line */
      	      {
                cp = extract_word(cp,&word,FALSE);  /* get the options word */
        	if (cstrcmp(word,"-options")==0)
        	{
        	  cp = extract_word(cp,&(entry->options),FALSE);
        	  entry->force_clean = TRUE;
        	}
        	else if (cstrcmp(word,"-switch")==0)
                {
        	  cp = extract_word(cp,&(entry->switch_on),TRUE);
        	  entry->force_clean = TRUE;
        	}
        	else if (cstrcmp(word,"-type")==0)
        	{
                  free(word);			/* finished with this string */
                  cp = extract_word(cp,&word,FALSE);
                  for (i=0; i<sizeof(module_type_names)/sizeof(char*); i++)
                  {
                    if (cstrcmp(word,module_type_names[i])==0)
                    {
                      entry->type = (module_type_t)i;
                      free(word);
                      word=NULL;
                      break;
                    }
                  }
                  if (word!=NULL)		/* module type not found */
                  {
                    error(1,"unknown module type '%s' in module database "
                    	"line %d.",word,line_number);
                  }
                }      
              }
            }
          }
        }
      }
    }
  }
exit_gracefully:
  if (file)
    fclose(file);
  if (word)
    free(word);

  return (0);
}

/*
 * free up any mallocs
 */
void
release_module_database(void)
{
  module_entry_t *entry,*this;
  
  entry = module_database;
  while (entry)
  {
    if (entry->name)      free(entry->name);
    if (entry->path)      free(entry->path);
    if (entry->output)    free(entry->output);
    if (entry->filename)  free(entry->filename);
    if (entry->switch_on) free(entry->switch_on);
    this = entry;
    entry=entry->next;
    free(this);
  }
}

void
release_component(component_entry_t *entry)
{
  if (entry->name)      free(entry->name);
  if (entry->options)   free(entry->options);
  if (entry->switch_on) free(entry->switch_on);
}

void
release_component_database(void)
{
  component_entry_t *entry,*this;
  
  entry = component_database;
  while (entry)
  {
    release_component(entry);
    this = entry;
    entry=entry->next;
    free(this);
  }
}

void
release_error_database(void)
{
  error_entry_t *entry,*this;
  
  entry = error_database;
  while (entry)
  {
    if (entry->message) free(entry->message);
    this = entry;
    entry=entry->next;
    free(this);
  }
}

/* 
 * print a banner of characters
 */
void
banner(char c)
{
  char buffer[BUFFER_LEN];
  memset(buffer,c,BUFFER_LEN);
  buffer[78]=0;
  printf("%s\n",buffer);
}

/* 
 * display usage info
 */
void
usage(void)
{
  const action_t *action;

  printf("Acorn '%s' version " APP_VERSION "\n\n",progname);
  
  printf("Usage: %s [options] <action>\n",progname);
  printf("Options:\n");
  printf("   -h, -help    : display this message\n");
  printf("   -v, -verbose : display more progress info\n");
  printf("   -s, -strict  : abort on non-fatal errors\n");
  printf("Actions:\n");
  
  for (action = &action_tbl[0]; action->call; action++)
    printf("   %-12s : %s\n", action->name, action->help);
}

/* 
 * tidy up before quiting
 */
void
doexit(void)
{
  error_entry_t *entry;
  int error=0;
  
  release_module_database();
  release_component_database();
  
  entry = error_database;
  while (entry)
  {
    if (error==0)
      printf("Batched errors...\n");
    error++;
    printf("Error %s\n",entry->message);
    entry=entry->next;
  }
  
  if (error)
    banner('-');
    
  spool_close(log_filename);
    
  release_error_database();
  if (build_name)           free(build_name);
  if (build_dir)            free(build_dir);
  if (image_filename)       free(image_filename);
  if (log_filename)         free(log_filename);
  if (image_size)           free(image_size);
  if (messages_filename)    free(messages_filename);
  if (joiner)               free(joiner);
  if (joiner_format)        free(joiner_format);
  
  if (podule_info.product)  free(podule_info.product);
  if (podule_info.descript) free(podule_info.descript);
  if (podule_info.serial)   free(podule_info.serial);
  if (podule_info.status)   free(podule_info.status);
  if (podule_info.manuf)    free(podule_info.manuf);
  if (podule_info.part)     free(podule_info.part);
  if (podule_info.date)     free(podule_info.date);
}

int
main(int argc, char *argv[])
{
  const action_t *action;
  time_t now;
  int i,found,first;
  
  progname = argv[0];
  atexit(doexit);
  
  /* 
   * sort out flags etc
   */
  for (i=1; i<argc; i++)
  {
    if (argv[i][0] != '-')
      break;
    if ((cstrcmp(argv[i],"-h")==0) || (cstrcmp(argv[i],"-help")==0))
    {
      usage();
      exit(1);
    }
    else if ((cstrcmp(argv[i],"-v")==0) || (cstrcmp(argv[i],"-verbose")==0))
      verbose=TRUE;
    else if ((cstrcmp(argv[i],"-s")==0) || (cstrcmp(argv[i],"-strict")==0))
      strict=TRUE;
  }
  
  /* 
   * check for action
   */
  if (argc<2 || i>=argc)
  {
    usage();
    exit(1);
  }
  first = i; /* record first non flag argument */
  
  /* 
   * we need to know Build$Dir and Build environment variables
   */
  if ((build_dir=read_env(ENV_BUILD_DIR))==NULL)
    error(1,"cannot locate build directory, please run a !Env file.");

  if ((build_name=read_env(ENV_BUILD_NAME))==NULL)
    error(1,"cannot identify build name, please run a !Env file.");

  if ((image_size=read_env(ENV_IMAGE_SIZE))==NULL)
    error(1,"cannot establish a image size, please run a !Env file.");
   
  /* 
   * read in our main files
   */
  read_module_database();
  read_component_database(build_name);
  read_shadow_component_database(build_name);
  build_dirs();
  /* 
   * start spooling
   */
  spool_open(log_filename);
  banner('-');
  
  /* 
   * display some banner info
   */
  now = time(NULL);
  printf("Started %s build : %s",build_name,asctime(localtime(&now)));

  
  if (verbose)
  {
    printf("Log filename       : %s\n",CHK_STR(log_filename));
    printf("Image filename     : %s\n",CHK_STR(image_filename));
    printf("Messages location  : %s\n",CHK_STR(messages_filename));
    printf("Image size         : %s\n",CHK_STR(image_size));
    printf("Joiner application : %s\n",CHK_STR(joiner));
    printf("Joiner format      : %s\n",CHK_STR(joiner_format));
    if (cstrcmp(joiner_format,"podule")==0)
    {
      printf("Podule info ...\n");
      printf("  Product code        : %s\n",CHK_STR(podule_info.product));
      printf("  Description         : %s\n",CHK_STR(podule_info.descript));
      printf("  Serial              : %s\n",CHK_STR(podule_info.serial));
      printf("  Mod Status          : %s\n",CHK_STR(podule_info.status));
      printf("  Pace of manufacture : %s\n",CHK_STR(podule_info.manuf));
      printf("  Part number         : %s\n",CHK_STR(podule_info.part));
      printf("  Date                : %s\n",CHK_STR(podule_info.date));
    }
  }

  /* 
   * dispatch the action
   */
  banner('-');
  for (i=first; i<argc; i++)
  {
    found=FALSE;
    for (action = &action_tbl[0]; action->call; action++)
    {
      if (cstrcmp(action->name, argv[i])==0)
      {
        found=TRUE;
        break;
      }
    }
    if (!found)
    {
      usage();
      exit(1);
    }
    printf("Starting phase %s ...\n",action->name);
    (*(action->call))();
    banner('=');
  }

  
  now = time(NULL);
  printf("Finished %s build : %s",build_name,asctime(localtime(&now)));
  banner('-');
    
  return (0);
}
