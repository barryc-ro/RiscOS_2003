/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "kernel.h"
#include "swis.h"
#include "srcbuild.h"
#include "Global/Services.h"

/*
 * contains all non-portable functions
 */

/*
 * globals
 */
int spooling = FALSE;
extern char *build_dir;
extern int verbose;
/*
 * change working directory
 */
int
chdir(char *dir)
{
  _kernel_swi_regs reg;

  reg.r[0] = 0;
  reg.r[1] = (int) dir;
  if (_kernel_swi(OS_FSControl, &reg, &reg))
    return (-1);

  return (0);
}

/*
 * make directory
 */
int
mkdir(const char *dir, int mode)
{
  _kernel_swi_regs reg;
  reg.r[0] = 8;
  reg.r[1] = (int) dir;
  reg.r[4] = 0;
  if (_kernel_swi(OS_File, &reg, &reg))
    return (-1);

  return (0);
}

/*
 * open a spool session
 */
void
spool_open(char *file)
{
  _kernel_swi_regs reg;
  char buffer[BUFFER_LEN];

  reg.r[0] = 199; /* OS_Byte reason code to read/write the spool file handle */
  reg.r[1] = 0;
  reg.r[2] = 255; /* read and don't change */
  if (_kernel_swi(OS_Byte, &reg, &reg)) {
    error(0, "failed to read spooling filehandle.");
    return;
  }

  /* Were we already spooling? (either ourselves or somebody higher up!) */
  if (reg.r[1] != 0)
    return;

  sprintf(buffer, "spool %s.%s.%s.%s", build_dir, BUILDSYS_DIR, LOGS_DIR, file);

  if (verbose)
    printf("Opening log file '%s'.\n", buffer + strlen("spool") + 1);

  reg.r[0] = (int) buffer;
  if (_kernel_swi(OS_CLI, &reg, &reg))
    error(0, "failed to open log file %s.", buffer + strlen("spool") + 1);
  else
    spooling = TRUE;

}

/*
 * close a spool session
 */
void
spool_close(char *file)
{
  _kernel_swi_regs reg;
  FILE *fh = NULL;
  FILE *fhtmp = NULL;
  char filename[BUFFER_LEN];
  char tmp_filename[BUFFER_LEN];
  char c;

  if (!spooling)
    return;

  sprintf(filename, "%s.%s.%s.%s", build_dir, BUILDSYS_DIR, LOGS_DIR, file);

  if (verbose)
    printf("Closing log file '%s'.\n", filename);

  reg.r[0] = (int) "spool";
  if (_kernel_swi(OS_CLI, &reg, &reg))
    error(1, "cannot close spool to file '%s'", filename);

  spooling = FALSE;

  if ((fh = fopen(filename, "r")) == NULL)
    error(1, "cannot open log file '%s'.", filename);

  strcpy(tmp_filename, tmpnam(NULL));
  if ((fhtmp = fopen(tmp_filename, "w")) == NULL)
    error(1, "cannot open temp log file '%s'.", tmp_filename);

  while (!feof(fh)) {
    c = fgetc(fh);
    if (!feof(fh)) {
      if (c == 0x0d) {
	c = fgetc(fh);
	if (c != 0x0a)
	  fputc(0x0d, fhtmp);
      } else if (c == 0x0a) {
	c = fgetc(fh);
	if (c != 0x0d)
	  fputc(0x0a, fhtmp);
	else
	  c = 0x0a;
      }
      fputc(c, fhtmp);;
    }
  }

  fclose(fh);
  fclose(fhtmp);

  remove(filename);

  reg.r[0] = 26;		/* copy objects */
  reg.r[1] = (int) tmp_filename;
  reg.r[2] = (int) filename;
  reg.r[3] = 0;
  if (_kernel_swi(OS_FSControl, &reg, &reg))
    error(1, "moving log file '%s'.", file);

  remove(tmp_filename);
}

/*
 * returns    0 - doesn't exist
 *              1 - file found
 *              2 - directory found
 */
int
file_exists(char *file)
{
  _kernel_swi_regs reg;

  reg.r[0] = 23;		/* no paths */
  reg.r[1] = (int) file;
  _kernel_swi(OS_File, &reg, &reg);

  return (reg.r[0]);
}

/*
 * return the size of a file in bytes
 */
int
file_size(char *file)
{
  _kernel_swi_regs reg;

  reg.r[0] = 23;		/* no paths */
  reg.r[1] = (int) file;
  _kernel_swi(OS_File, &reg, &reg);

  return (reg.r[0] == 1 ? reg.r[4] : -1);
}

/*
 * set an environment variable
 */
int
setenv(char *name, char *value)
{
  if (DEBUG && verbose)
  {
    printf ("Setting %s to %s\n", name, value);
  }
  return (_kernel_setenv(name, value) == NULL) ? 0 : -1;
}


/*
 * return the country code number of a passed in country.
 * Returns -1 if it is not a valid country.
*/
int return_country_number(const char* country)
{
  _kernel_swi_regs reg;
  int return_value = 0;

  reg.r[1] = Service_International;
  reg.r[2] = 0;              /* sub-reason code 0 */
  reg.r[3] = (int)country;   /* The country we require (NULL terminated) */
  reg.r[4] = 0;
  _kernel_swi(OS_ServiceCall, &reg, &reg);

  if (reg.r[1] != 0)
    return_value = -1; /* Unrecognised country */
  else
    return_value = reg.r[4];

  return (return_value);
}

/*
 * copy objects (possibly an entire directory tree, possibly just a file)
 */
int copy_objects(const char *destination, const char *source)
{
  /* should be in riscos.c */
  return !!_swix(OS_FSControl, _INR(0,3), 26, source, destination, 1<<1 /* force */);
}

/*
 * delete objects (possibly an entire directory tree, possibly just a file)
 */

int wipe_objects(const char *source)
{
  return !!_swix(OS_FSControl, _INR(0,1)|_IN(3), 27, source, 1<<1 /* force */);
}
