/*
 * ROM Linker
 *
 * Copyright (C) Pace Micro Technology plc. 2001
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>

/* C library extension header files */
#include "prgname.h"
#include "err.h"
#include "hash.h"

/* Generic ROM linker header files */
#include "memory.h"
#include "romlinker.h"
#include "filereader.h"

/* ROM linker implementation header files */
#include "makerom.h"
#include "makeextrom.h"
#include "makeexprom.h"

#include "VersionNum"

/* Local data */

static char progname[32];
static HashTable arghash;
static const char **remaining_args;

static linker_characteristics *linker;
static linker_characteristics *linkers[] = {
  &makeexprom_linker_characteristics,
  &makeextrom_linker_characteristics,
  &makerom_linker_characteristics
};

/* Public data constants */
const unsigned long unassigned_position = -1UL;
const unsigned long unknown_size = -1UL;
int verbose = 0;

/* Public functions */

void romlinker_report_rom_summary(unsigned long size, unsigned long total)
{
  if (total > size) {
    err_fail("Image has overflowed by %li bytes!", total - size);
  }
  else {
    char floatstring[12];
    size -= total;
    sprintf(floatstring, "%.2f", ((double) size) / 1024);
    err_report("Image has %li bytes spare (%sK)", size, floatstring);
  }
}

unsigned long romlinker_strtoul(const char *s, char **end, int base)
{
  if (*s == '&') {
    base = 16;
    ++s;
  }
  return strtoul(s, end, base);
}

const char *find_parameter(const char *key)
{
  HashId id;
  return hash_lookup(arghash, key, &id) ? hash_value(arghash, id) : NULL;
}

const char *find_mandatory_parameter(const char *key)
{
  const char *param = find_parameter(key);
  if (!param) err_fail("missing mandatory parameter: '-%s'", key);
  return param;
}

const char *find_next_arg(void)
{
  return *remaining_args ? *remaining_args++ : NULL;
}


static const char **init_args(int argc, char *argv[])
{
  int i;

  arghash = fault_null(hash_cinew(argc), "Unable to construct argument table");

  for (i=1; i<argc && *argv[i] == '-'; ++i) {
    HashId id;
    if (hash_enter(arghash, argv[i]+1, &id)) {
      if (argv[i+1][0] == '-' || !argv[i+1]) {
        hash_assoc(arghash, id, "1");
      }
      else {
        hash_assoc(arghash, id, argv[++i]);
      }
    }
    else {
      err_fail("Duplicate option: '%s'", argv[i]);
    }
  }

  return (const char **) (argv + i);
}

/* Extract the options into the linker's private data structure */
static void load_linker_args(const linker_characteristics *linker)
{
  size_t mandatory_count = linker->mandatory_args;
  const char **keys;
  const char **vals;

  for (keys = linker->args, vals = linker->vals; *keys; ++keys, ++vals) {
    if (mandatory_count) {
      --mandatory_count;
      *vals = find_mandatory_parameter(*keys);
    }
    else {
      *vals = find_parameter(*keys);
    }
  }
}

module_list **module_add_to_list(module_list **list, const char *name, unsigned long position)
{
  module_list *entry;
  const size_t namelen = strlen(name) + 1;
  const size_t memlen = sizeof(**list) + namelen;

  entry = *list = safe_alloc(memlen);
  memcpy(entry + 1, name, namelen);
  entry->next = NULL;
  entry->filename = (void *) (entry + 1);
  entry->fixed_position = position;
  entry->size = filereader_filesize(entry->filename);
  entry->type = filereader_file_type(entry->filename);
  entry->memory_cache = NULL;

  if (entry->size == unknown_size) {
    err_fail("cannot read file '%s'", entry->filename);
  }

  if (verbose >= 2) {
    static int counter = 0;
    err_report("%4d %#.6lx %s", ++counter, entry->size, entry->filename);
  }

  return &entry->next;
}

size_t romlinker_load_module_list(FILE *f, module_list **list)
{
  size_t module_count = 0;
  const char *filename;
  unsigned long position = unassigned_position;

  while ((filename = readline(f)) != NULL) {
    if (isdigit(filename[0])) {
      char *end;
      position = romlinker_strtoul(filename, &end, 0);
      if (*end && !isspace(*end)) {
        err_fail("Bad module file format after %d module(s) added: %s",
          module_count, filename);
      }
    }
    else if (filename[0]) {
      list = module_add_to_list(list, filename, position);
      position = unassigned_position;
      ++module_count;
    }
  }

  return module_count;
}

int main(int argc, char *argv[])
{
  const char *romtype;
  const char *debuglevel;
  int i;

  err_init(program_name(argv[0], progname, sizeof(progname)));
  err_report("version %s", Module_HelpVersion);
  remaining_args = init_args(argc, argv);
  romtype = find_mandatory_parameter("format");

  for (i = 0, linker = NULL; i<sizeof(linkers)/sizeof(*linkers); ++i) {
    if (strcmp(linkers[i]->formatname, romtype) == 0) {
      linker = linkers[i];
    }
  }

  fault_null_const(linker, "Unrecognised format option '%s'", romtype);

  debuglevel = find_parameter("v");
  if (debuglevel) verbose = (int) romlinker_strtoul(debuglevel, NULL, 0);

  err_report("%s", linker->description);
  linker->init();
  load_linker_args(linker);
  if (linker->start()) {
    while (linker->add()) ;;
  }
  linker->finish();

  return 0;
}
