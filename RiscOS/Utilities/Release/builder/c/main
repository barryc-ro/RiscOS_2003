/************************************************************************/
/*                  Copyright 1997 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "wimp.h"
#include "toolbox.h"
#include "event.h"
#include "wimplib.h"
#include "gadgets.h"
#include "window.h"
#include "menu.h"
#include "proginfo.h"
#include "iconbar.h"

#include "resources.h"
#include "constants.h"
#include "msg.h"
#include "env.h"

#define WimpVersion    350

static  WimpPollBlock  poll_block;
static  MessagesFD     messages;
static  IdBlock        id_block;

int  task_handle          = 0;  /* Wimp task handle */
int  iconbar_id           = 0;  /* ID iconbar object */
int  menu_iconbar_id      = 0;  /* ID of iconbar menu object */
int  window_options_id	  = 0;  /* ID of build options window */
int  proginfo_id	  = 0;  /* ID of proginfo window */
char build_name[BUILD_NAME_SIZE];
int  defaults_read = 0;

/*
 * quit_event
 *
 * Event handler to be called when toolbox event 1 is generated (by click on the
 * 'Quit' entry of the iconbar menu.
 */
int
quit_event(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
  event_code = event_code;
  event = event;
  id_block = id_block;
  handle = handle;

  debug db_file_init(NULL);
  exit(0);
  return(1);
}

/*
 * quit_message
 *
 * Message handler to be called on receipt of a Quit or PreQuit message from the
 * Wimp.
 */
int
quit_message(WimpMessage *message, void *handle)
{
  message = message;
  handle = handle;

  debug db_file_init(NULL);
  exit(0);
  return(1);
}

/* 
 * read defaults file (if it exists) and populate window option buttons and
 * environment
 */
int
read_defaults(void)
{
  _kernel_oserror *err=NULL;
  FILE *fh=NULL;
  char str[1024];
  char *cp,*wd;
  int end_of_string=0;
  int i;

  if ((fh=fopen(DEFAULTS_FILE,"r"))!=NULL)
  {
    /* 
     * set all options off 
     */
    for (i=0; i<(sizeof(options)/sizeof(option_t)); i++)
    {
      ERR_GOTO(err,optionbutton_set_state(0,window_options_id,
  	      options[i].id,0));
    }
    /* 
     * read in line from file
     */
    fgets(str,sizeof(str),fh);
    if (!feof(fh))
    {
      cp=str;
      while (*cp!=0 && *cp!='\n')			/* terminate string */
        cp++;
      *cp=0;
      
      /* 
       * for each word in line
       */
      cp=str;
      do
      {
        while ((*cp==' ') || (*cp==9)) 			/* skip space chars */
          cp++;
          
        wd=cp;
        while ((*cp!=' ') && (*cp!=9) && (*cp!=0))	/* find end of word */
          cp++;
        if (*cp==0)
          end_of_string=1;
        else
          *cp=0;
        
  	for (i=0; i<(sizeof(options)/sizeof(option_t)); i++)
  	{  
  	  if (strcmp(options[i].name,wd)==0)
  	  { 
            ERR_GOTO(err,optionbutton_set_state(0,window_options_id,
  	      options[i].id,1));
  	    break;
  	  }
  	}
        cp++;
      } while (!end_of_string);
    }
  }
exit_gracefully:
  if (fh)
    fclose(fh);
  if (err)
    wimp_report_error(err,0,0);
  defaults_read = 1;
  
  return 0;  
}

/* 
 * save current options in a defaults file
 */
int 
write_defaults(void)
{
  _kernel_oserror *err=NULL;
  FILE *fh=NULL;
  int state;
  int i;
  
  if ((fh=fopen(DEFAULTS_FILE,"w"))==NULL)
  {
    ERR_CHECK_RETURN(err,msg_error_construct("def_write"));
  }
  
  for (i=0; i<(sizeof(options)/sizeof(option_t)); i++)
  {  
    ERR_CHECK_RETURN(err,optionbutton_get_state(0,window_options_id,
  	options[i].id,&state));
    if (state)
      fprintf(fh,"%s ",options[i].name);
  }
  fprintf(fh,"\n");    
  fclose(fh);
  
  return 0;
}

/*
 * attach_other_handlers
 */
int 
attach_other_handlers(int event_code,ToolboxEvent *event,
			IdBlock *id_block, void *handle)
{
  _kernel_oserror *err = NULL;
  char template_name[25];
  int i;
  
  ERR_CHECK(err,toolbox_get_template_name(0,id_block->self_id,template_name,
      				     sizeof(template_name),&i));

  if (strcmp(template_name, ICONBAR_NAME) == 0) {
    iconbar_id = id_block->self_id;
  } else if (strcmp(template_name, MENU_ICONBAR_NAME) == 0) {
    menu_iconbar_id = id_block->self_id;
  } else if (strcmp(template_name, WINDOW_OPTIONS_NAME) == 0) {
    window_options_id = id_block->self_id;
  } else if (strcmp(template_name, PROGINFO_NAME) ==0) {
    proginfo_id = id_block->self_id;
  }

  return 0;
}

/*
 * Enter the correct version string into window
 */
int
initialise_proginfo(int event_code,ToolboxEvent *event,
    			    IdBlock *id_block, void *handle)
{
  proginfo_set_version(0,id_block->self_id,APP_VERSION);
  return 0;
}

/*
 * populate the windows with data prior to them being opened
 */
int 
window_show(int event_code,ToolboxEvent *event,
    		       IdBlock *id_block, void *handle)
{
  _kernel_oserror *err=NULL;
  
  if (id_block->self_id == window_options_id)
  {
    if (!defaults_read)
      read_defaults();
    ERR_CHECK_RETURN(err,
    	env_populate(ENV_DIR,window_options_id,OPTIONS_GADGET_ENV));
  }

  return 0;
}

/* 
 * populate string set prior to it being shown
 */
int
stringset_show(int event_code,ToolboxEvent *event,
    		       IdBlock *id_block, void *handle)
{
  _kernel_oserror *err=NULL;
  if (id_block->self_id == window_options_id)
  {
    if (id_block->self_component == OPTIONS_GADGET_ENV)
    {
      ERR_CHECK_RETURN(err,
    	env_populate(ENV_DIR,window_options_id,OPTIONS_GADGET_ENV));
    }
  }
  return 0;
}

/* 
 * deal with new stringset value
 */
int
stringset_changed(int event_code,ToolboxEvent *event,
    		       IdBlock *id_block, void *handle)
{
  _kernel_oserror *err=NULL;
  
  if (id_block->self_id == window_options_id)
  {
    if (id_block->self_component == OPTIONS_GADGET_ENV)
    {
      ERR_CHECK_RETURN(err,
    	env_source(ENV_DIR,window_options_id,OPTIONS_GADGET_ENV));
    }
  }
  return 0;
}
/* 
 * deal with button presses
 */
int action_click(int event_code,ToolboxEvent *event,
    		       IdBlock *id_block, void *handle)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  char cmd[1024];
  int state;
  int i;
  
  if (id_block->self_id == window_options_id)
  {
    switch (id_block->self_component)
    {
      case OPTIONS_GADGET_EDIT :
        if (strlen(build_name))
        {
          sprintf(cmd,"Filer_Run %s.%s",BUILDSYS_DIR,build_name);
          reg.r[0] = (int)cmd;
          ERR_CHECK_RETURN(err,_kernel_swi(OS_CLI,&reg,&reg));
        }
        else
        {
          ERR_CHECK_RETURN(err,msg_error_construct("no_env"));
        }
        break;
        
      case OPTIONS_GADGET_BUILD :
        strcpy(cmd,BUILD_FILE);
        for (i=0; i<(sizeof(options)/sizeof(option_t)); i++)
        {
          ERR_CHECK_RETURN(err,optionbutton_get_state(0,window_options_id,
        	options[i].id,&state));
          if (state)
          {
            strcat(cmd," ");
            strcat(cmd,options[i].name);
          }
        }          
        reg.r[0] = (int)cmd;
        ERR_CHECK_RETURN(err,_kernel_swi(Wimp_StartTask,&reg,&reg));

        break;
        
      case OPTIONS_GADGET_SAVE :
        write_defaults();
        break;
    }
  }
  
  return 0;
}

/*
 * deal with clicks on the menus
 */
int
menu_selection(int event_code,ToolboxEvent *event,
    		       IdBlock *id_block, void *handle)
{
  _kernel_oserror *err=NULL;
  _kernel_swi_regs reg;
  if (id_block->self_id == menu_iconbar_id)
  {
    if (id_block->self_component == BARMENU_MODULE)
    {
      char cmd[BUILD_NAME_SIZE+10];
      sprintf(cmd,"Filer_Run %s.%s",BUILDSYS_DIR,MODULEDB);
      reg.r[0] = (int)cmd;
      ERR_CHECK_RETURN(err,_kernel_swi(OS_CLI,&reg,&reg));      
    }    
  }
  return (0);
}

/*
 * main initialisation
 */
int main()
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs reg;
  int toolbox_events = 0;
  int wimp_messages  = 0;
  int event_code;

  debug db_file_init(FILE_DEBUG);

  ERR_GOTO(err,msg_open_messages(FILENAME_MESSAGES));

  event_initialise(&id_block);          /* initialise the event library. */
  event_set_mask(Wimp_Poll_NullMask); 	/* mask out un-required wimp events */

  ERR_GOTO(err,event_register_toolbox_handler(-1,Toolbox_ObjectAutoCreated,
      attach_other_handlers,NULL));

  /* register ourselves with the Toolbox. */
  ERR_GOTO(err,toolbox_initialise(0, WimpVersion, &wimp_messages,
      &toolbox_events,APP_DIR,&messages,&id_block,0,0,0));

  /* Message handlers */
  ERR_GOTO(err,event_register_message_handler(Wimp_MQuit,
             quit_message,0));
  ERR_GOTO(err,event_register_message_handler(Wimp_MPreQuit,
             quit_message,0));

  /* Menu event handlers */
  ERR_GOTO(err,event_register_toolbox_handler(-1,MENU_EVENT_QUIT,
             quit_event,0));
  ERR_GOTO(err,event_register_toolbox_handler(-1,Menu_Selection,
             menu_selection,0));

  /* Window event handlers */
  ERR_GOTO(err,event_register_toolbox_handler(-1,ProgInfo_AboutToBeShown,
      initialise_proginfo,NULL));
  ERR_GOTO(err,event_register_toolbox_handler(-1,Window_AboutToBeShown,
      window_show,NULL));

  /* Gadget event handlers */
  ERR_GOTO(err,event_register_toolbox_handler(-1,StringSet_AboutToBeShown,
      stringset_show,NULL));
  ERR_GOTO(err,event_register_toolbox_handler(-1,StringSet_ValueChanged,
      stringset_changed,NULL));
  ERR_GOTO(err,event_register_toolbox_handler(-1,ActionButton_Selected,
      action_click,NULL));

  toolbox_get_sys_info(3,&reg);  /* Obtain wimp task handle */
  task_handle = reg.r[0];

  /* poll loop */
  while (TRUE)
    event_poll (&event_code, &poll_block, 0);

exit_gracefully:
  if (err != NULL)
    wimp_report_error(err,0,0);

  return (0);
}
