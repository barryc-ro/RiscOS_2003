;==========================================
;
;  s.PhotoCD
;
;  Photo CD support module
;
;  © 1993 Acorn Computers Ltd
;
;  Developed in association with 4Mation
;  Author: Paul LeBeau
;
;==========================================
;
; History:
;
;       Date        By      What was done
;
;       13 May 93
;    to ?? ??? 93   PRL     Created
;
;-----------------------------------------------------------------------------------



        GBLA    options
options SETA    {OPT}                ; turn off listing temporarily

        OPT     2


        GET     h.RegNames
        GET     h.SWInames
        GET     h.Macros

        GET     s.pcdformats
        GET     s.constants
        GET     s.switches
        GET     s.workspace
        GET     s.pcdswis

;        GET     h.tracemacro



        OPT     options


        LEADR   Module_LoadAddr



;-----------------------------------------------------------------------------------
;       Some vars
;-----------------------------------------------------------------------------------



PhotoCD_SWI_chunk      *       &46f40
PhotoCD_Err_chunk      *       &808600



Module_LoadAddr *       &fffffa00                       ; load and exec address for modules

Carry_flag      *       1<<29
Overflow_flag   *       1<<28
IRQ_flag        *       1<<27




;-----------------------------------------------------------------------------------
;       Module Header
;-----------------------------------------------------------------------------------



module_base

        DCD     module_start        - module_base       ; Start code
        DCD     module_initialise   - module_base       ; Init code
        DCD     module_finalise     - module_base       ; Release memory/kill tune routine
        DCD     module_service      - module_base       ; No service code
        DCD     module_title        - module_base       ; => Title string
        DCD     module_help         - module_base       ; => Help string
        DCD     module_commandtable - module_base       ; => Command table
        DCD     PhotoCD_SWI_chunk                       ; SWI chunk number
        DCD     module_swihandler   - module_base       ; SWI despatch code
        DCD     module_switable     - module_base       ; SWI names
        DCD     0



module_start         * module_base                      ; No start code
module_commandtable  * module_base                      ; No *commands




;-----------------------------------------------------------------------------------
;       Module name, copyright etc.
;-----------------------------------------------------------------------------------



module_title
        =       "PhotoCD", 0

        =       "© 1993 Acorn Computers Ltd", 0




;-----------------------------------------------------------------------------------
;       Module title and info for *Help modules
;-----------------------------------------------------------------------------------

Module_Version  *  23

                                  ; don't forget to update the above value!
module_help
        =       "PhotoCD Support", 9, "0.23 (08 Jan 1994)"

        [       Switch_PreRelease
        DCB     9, " (internal version only - not for release)"
        ]
        DCB     0
        ALIGN





;-----------------------------------------------------------------------------------
;       SWI name table
;-----------------------------------------------------------------------------------



module_switable

        DCB     "PhotoCD", 0               ; SWI group prefix


        DCB     "Open", 0                  ; Open an Overview of Image Pac.
        DCB     "Close", 0                 ; Close an Overview of Image Pac.

        DCB     "GetPacName", 0            ; Generate the image name for the given thambnail image. 
        DCB     "GetSize", 0               ; Return the size of the thumbnail or full image.
        DCB     "GetRotation", 0           ; Return the rotation of the thumbnail or full image.
        DCB     "GetCount", 0              ; Return the number of images/resolutions available.
        DCB     "GetBytesPerRow", 0        ; Returns the number of bytes required to represent a row
                                           ; of the image.
        DCB     "ReadImageInfo", 0         ; Return scanning information about the specified image.

        DCB     "GetBlock", 0              ; Read a block of image data from a thumbnail or full image.

        DCB     "ReadInfoFile", 0          ; Return information about the current PhotoCD.

        DCB     "IdentifyFile", 0          ; Check whether an unknown file is a PCD file or not.
        DCB     "ConvertCoord", 0          ; Convert between coords at different reolution steps.
        DCB     "ConvertYCCtoRGB", 0       ; Convert one or more YCC values to RGB values.
        ; reserve one here for RGBtoYCC?

        DCB     "MiscOp", 0                ; Perform miscellaneous functions.


        DCB     0
        ALIGN



;-----------------------------------------------------------------------------------
;       Initialise module
;-----------------------------------------------------------------------------------



module_initialise

        STMFD   sp!, {lr}


        LDR     r0, [r12]                               ; Get workspace address
        TEQ     r0, #0
        LDMNEFD sp!, {pc}^                              ; module already initialised


        ; check that we are running under >= RISC-OS 3.00
        MOV     r0, #&81
        MOV     r1, #0
        MOV     r2, #&ff
        SWI     XOS_Byte
        LDMVSFD sp!, {pc}

        CMP     r1, #&A3                                ; &A3 = RISCOS 3.00
        BGE     i_init

        ; Return error about not being RO3
        ADR     r0, NotRO3_errormsg
        LDMFD   sp!, {lr}
        ORRS    pc, lr,#Overflow_flag                   ; return V set without dropping out to USER mode



i_init
        ADR     r0, ResourceFiles                       ; register the messages file with ResourceFS
        SWI     XResourceFS_RegisterFiles
        LDMVSFD sp!, {pc}


        [ Switch_IncludeSprites
        ADR     r0, SpritesCLI
        SWI     XOS_CLI
        ; don't worry about errors, no big deal if sprites are not loaded
        ]


        ; claim some workspace

        MOV     r0, #6                                  ; Claim workspace
        LDR     r3, =sizeof_workspace
        SWI     XOS_Module
        LDMVSFD sp!, {pc}

        STR     r2, [r12]

        MOV     r12, r2


        ; initialise some values in the workspace

        MOV     r0, #0
        STR     r0, msgs_opened                         ; message-file-open flag
        STR     r0, pcd_firstpcdblock                   ; pointer to first pcd block in list (0 = none)

        STR     r0, gb_addr_4Basebuf                    ; quite large buffer used for 16Base images
                                                        ; (only claimed if 16Base images are wanted)

        STR     r0, gbp_addr_ictable                    ; buffer used holding ict
                                                        ; (only claimed if palette images are wanted)
        STR     r0, gbp_last_numpal                     ; number of entries in last palette passed

        [       Switch_ReadAheadBufferEnabled
        STR     r0, gb_ubufsize                         ; indicate that no buffer is in use
        STR     r0, gb_ubufpcdhandle
        ]


        LDMFD   sp!, {pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


NotRO3_errormsg    Error PhotoCD_Err_chunk+0, "PhotoCD support module requires RISC-OS 3.00 or later"


        LTORG


;-----------------------------------------------------------------------------------
;       Kill module
;-----------------------------------------------------------------------------------



module_finalise

        MOV     r4, r12
        LDR     r12, [r12]                              ; Get workspace address
        CMP     r12, #0
        MOVEQS  pc, lr                                  ; Module not initialised

;*** check here if we are in the middle of an operation?

        STMFD   sp!, {lr}


        ; Close any open files and free their pcd blocks

        LDR     r2, pcd_firstpcdblock                   ; pointer to first pcd
f_pcdfreeloop
        CMP     r2, #0                                  ; end of linked-list?
        BEQ     f_freebufs

        LDR     r3, [r2, #pcd_next]                     ; get pointer to next before we free this one
        LDR     r1, [r2, #pcd_filehandle]               ; file handle
        CMP     r1, #0                                  ; is it open?
        MOVNE   r0, #0
        SWINE   XOS_Find                                ; close it (ignoring errors)

        MOV     r0, #7                                  ; free block
        SWI     XOS_Module                              ; (ignore errors - try to free all the blocks)

        MOV     r2, r3
        B       f_pcdfreeloop


f_freebufs
        ; free any other claimed buffers
        LDR     r2, gb_addr_4Basebuf                    ; buffer used?
        TEQ     r2, #0
        MOVNE   r0, #7                                  ; yes - free it
        SWINE   XOS_Module

        LDR     r2, gbp_addr_ictable                    ; ict buffer used?
        TEQ     r2, #0
        MOVNE   r0, #7                                  ; yes - free it
        SWINE   XOS_Module


f_closemsgs
        ; Close messages file if it has been opened

        LDR     r0, msgs_opened
        TEQ     r0, #0
        ADRNE   r0, msgs_block
        SWINE   XMessageTrans_CloseFile
        MOV     r0, #0
        STR     r0, msgs_opened


        ; De-register the resource file
        ADR     r0, ResourceFiles
        SWI     XResourceFS_DeregisterFiles


        ; Free workspace
        MOV     r0, #7
        MOV     r2, r12
        SWI     XOS_Module

        MOV     r0, #0
        STR     r0, [r4]


        LDMFD   sp!, {pc}



;-----------------------------------------------------------------------------------
;       Service call handler
;-----------------------------------------------------------------------------------



module_service

        TEQ     r1, #&60                                ; Service_ResourceFSStarting ?
        MOVNES  pc, lr


        ; ResourceFS is being restarted, we need to re-register

        STMFD   sp!, {r0-r3,lr}

        ADR     r0, ResourceFiles                       ; r0 -> our ResourceFS block
        MOV     lr, pc                                  ; return to sch_exit
        MOV     pc, r2                                  ; re-register by calling supplied address

sch_exit
        LDMIA   sp!, {r0-r3, pc}^



;-----------------------------------------------------------------------------------
;       SWI handler code
;-----------------------------------------------------------------------------------



module_swihandler

        LDR     r12, [r12]

        CMP     r12, #0                                 ; module not initialised (eg not RO3)
        MOVEQS  pc, lr

        CMP     r11, #(EndOfJumpTable - JumpTable)/4    ; Check if swi offset in range
        ADDCC   pc, pc,r11,LSL #2                       ; Jump to code if it is
        B       UnknownSWI_error                        ; Otherwise generate error

JumpTable
        B       swi_Open
        B       swi_Close

        B       swi_GetPacName
        B       swi_GetSize
        B       swi_GetRotation
        B       swi_GetCount
        B       swi_GetBytesPerRow

        B       swi_ReadImageInfo

        B       swi_GetBlock

        B       swi_ReadInfoFile

        B       swi_IdentifyFile

        B       swi_ConvertCoord
        B       swi_ConvertYCCtoRGB

        B       swi_MiscOp


EndOfJumpTable



;-----------------------------------------------------------------------------------
;       Bad SWI routine
;-----------------------------------------------------------------------------------



UnknownSWI_error

        ADR     r0, UnknownSWI_errormsg                 ; point to error message
        B       ErrorLookup                             ; return with error flagged


UnknownSWI_errormsg    Error &1e6, "PCDBadSWI:SWI value out of range for module %0"



;-----------------------------------------------------------------------------------
;       Error/MsgTrans routines
;-----------------------------------------------------------------------------------

; On Entry
;   r0 -> error message token



ErrorLookup

        STMFD   sp!, {r1-r7, lr}
        BL      Error_OpenMsgsFile
        LDMVSFD sp!, {r1-r7, pc}

        ADR     r1, msgs_block
        MOV     r2, #0
        ADRL    r4, module_title
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup

        LDMFD   sp!, {r1-r7, pc}


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


Error_OpenMsgsFile

        STMDB   sp!, {r0-r2, lr}

        ADDS    r1, r1,#0                               ; clear V in case it's already set

        LDR     r1, msgs_opened                         ; messages file already opened?
        TEQ     r1, #0
        LDMNEFD sp!, {r0-r2, pc}

        ADR     r0, msgs_block
        ADR     r1, MessPathSpec
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        LDMVSFD sp!, {r0-r2, pc}

        MOV     r1, #1
        STR     r1, msgs_opened
        LDMFD   sp!, {r0-r2, pc}




;-----------------------------------------------------------------------------------
;       Error message file for ResourceFS
;-----------------------------------------------------------------------------------


MessPathSpec
        DCB     "Resources:$.Resources.PhotoCD.Messages"        ; Full path spec for 'MessageTrans_OpenFile'
        ALIGN

        [ Switch_IncludeSprites
SpritesCLI
        ; command to load PhotoCD sprites into Wimp pool
        DCB     "IconSprites Resources:$.Resources.PhotoCD.Sprites"
        ALIGN
        ]


ResourceFiles
        ResourceFile   "<PcdModuleSrc$Dir>.Resources.Messages",  "Resources.PhotoCD.Messages"

        [ Switch_IncludeSprites
        ResourceFile   "<PcdModuleSrc$Dir>.Resources.Sprites",   "Resources.PhotoCD.Sprites"
        ResourceFile   "<PcdModuleSrc$Dir>.Resources.Sprites22", "Resources.PhotoCD.Sprites22"
        ]

        DCD     0


        !       0, "Messages filename used is: <PcdModuleSrc$Dir>.Resources.Messages"



;-----------------------------------------------------------------------------------
;       Memory pointer validation routine
;-----------------------------------------------------------------------------------

; On Entry
;    R1 = memory location
;    R2 = block size
;
; On Exit
;    C set if address is bad


CheckAddress

        CMP     r1, #&8000
        ORRLOS  pc, lr,#Carry_flag                              ; Carry set indicates bad address

        STMFD   sp!, {r0,r1,lr}

        MOV     r0, r1
        ADD     r1, r1,r2
        SWI     XOS_ValidateAddress

ca_exit
        LDMFD   sp!, {r0,r1,pc}



;-----------------------------------------------------------------------------------
;       PhotoCD handle validation routine
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;
; On Exit
;    C set if handle is faulty


CheckPCDhandle

        STMFD   sp!, {r0-r2,lr}

        ; first, see if it is present in the linked list
        LDR     r1, pcd_firstpcdblock
cph_listloop
        CMP     r1, #0                                  ; have we reached end of list?
        BEQ     cph_exit
        CMP     r1, r0                                  ; does this ptr = pcd handle?
        BEQ     cph_found
        LDR     r1, [r1,#pcd_next]                      ; get next item in list
        B       cph_listloop

cph_found
        LDR     r1, [r0, #pcd_magic]
        LDR     r2, BlockID
        CMP     r1, r2
        BNE     cph_exit

        ADDS    r0, r0,#0                               ; clear C (indicates pcd handle is ok)
        LDMFD   sp!, {r0-r2,pc}                         ; and exit

cph_exit
        LDMFD   sp!, {r0-r2,lr}
        ORRS    pc, lr,#Carry_flag                      ; Carry set indicates bad address



;-----------------------------------------------------------------------------------
;       Overview Pac thumbnail number validation routine
;-----------------------------------------------------------------------------------

; On Entry
;    R1 = Thumbnail image number
;
; On Exit
;    V set and R0 points to error message if handle is faulty


CheckThumbNo

        STMFD   sp!, {r2, lr}

        LDR     r2, =opa_MaxThumbnails                  ; biggest thumbnail number allowed
        CMP     r1, r2
        BGT     ctn_badthbno
        CMP     r1, #1
        BGE     ctn_thbok

ctn_badthbno
        ; generate bad pac number error
        ADR     r0, BadThbNo_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r2, lr}
        ORRS    pc, lr,#Overflow_flag                   ; V set indicates bad address

ctn_thbok
        LDMFD   sp!, {r2, lr}
        BICS    pc, lr,#Overflow_flag                   ; clear V (indicates thumb no is ok)



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadThbNo_errormsg    Error PhotoCD_Err_chunk+9, "PCDBadThbNo"


       LTORG



;-----------------------------------------------------------------------------------
;       Routine to convert external transform value to internal format
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = external transform value
;         Valid values are 0,90,180 or 270, with possibly bit 31 (mirror) set
;
; On Exit
;    R0 = equivalent value in internal format
;         Format: like input but instead of 0->270°, rotation is 0->3
;    V set and R0 points to error message if value is faulty


ConvXformExtToInt

        STMFD   sp!, {r1-r2, lr}

        AND     r1, r0,#(1<<31)                         ; r1 = 'mirror' bit
        BIC     r0, r0,#(1<<31)                         ; now get rid of it from value

        MOV     r2, #0                                  ; counter
cxei_loop
        CMP     r0, #90                                 ; 'rotation' >= 90?
        BLT     cxei_loopdone                           ; no - we've extracted as many '90's
                                                        ;      as we can, so exit
        SUB     r0, r0,#90                              ; subtract 90 from 'rotation'
        ADD     r2, r2,#1                               ; increment counter
        CMP     r2, #3                                  ; reached '3' yet (the maximum) ?
        BLT     cxei_loop

cxei_loopdone
        CMP     r0, #0                                  ; is the final leftover 0?
        BNE     cxei_badval                             ; no - (value wasn't a multiple of 90)

        ORR     r0, r2,r1                               ; re-insert 'mirror' bit

        LDMFD   sp!, {r1-r2, lr}
        BICS    pc, lr,#Overflow_flag                   ; clear V (indicates value is ok)


cxei_badval
        ; generate bad pac number error
        ADR     r0, BadXform_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r1-r2, lr}
        ORRS    pc, lr,#Overflow_flag                   ; V flag indicates bad address



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadXform_errormsg    Error PhotoCD_Err_chunk+11, "PCDBadXform"



;-----------------------------------------------------------------------------------
;       Big-endian value reading functions
;-----------------------------------------------------------------------------------


getShort
        ; Read a big-endian short int (16 bits)
        ; On entry:  r2 = pointer to value
        ; On exit:   r1 = value
        ;            r2 updated
        ; Corrupts:  r11

        LDRB    r11, [r2],#1
        LDRB    r1, [r2],#1
        ADD     r1, r1,r11,ASL#8
        MOVS    pc, lr



getLong
        ; Read a big-endian long int (32 bits)
        ; On entry:  r2 = pointer to value
        ; On exit:   r1 = value
        ;            r2 updated
        ; Corrupts:  r10,r11

        LDRB    r11, [r2],#1
        LDRB    r10, [r2],#1
        ADD     r11, r10,r11,ASL#8
        LDRB    r10, [r2],#1
        ADD     r11, r10,r11,ASL#8
        LDRB    r10, [r2],#1
        ADD     r1, r10,r11,ASL#8
        MOVS    pc, lr



;-----------------------------------------------------------------------------------
;       Check the signature and version of in a recently
;       read in chunk from a PhotoCD file
;-----------------------------------------------------------------------------------

; On Entry
;    r1 = size of signature (no. of bytes to check)
;    r2 -> files signature
;    r6 -> what the signature should be
;
; On Exit
;    V set if signature or version is faulty


CheckSigAndVers

        STMFD   sp!, {r2, lr}

csav_loop
        LDRB    r3, [r2], #1
        LDRB    r4, [r6], #1
        CMP     r3, r4
        BNE     csav_badfile
        SUBS    r1, r1,#1
        BNE     csav_loop

        ; signature ok - check spec version file was created under

        LDRB    r4, [r2], #1                            ; major version number
        CMP     r4, #pcd_SpecVers_Maj
        BGT     csav_fileok                             ; greater than we need - ok
        LDREQB  r4, [r2], #1                            ; minor version number
        CMPEQ   r4, #pcd_SpecVers_Min                   ; if maj the same, check min
        BLT     csav_badfile                            ; if <maj or (=maj, <min) - bad file

csav_fileok
        ; file is ok - return
        LDMFD   sp!, {r2, lr}
        BICS    pc, lr,#Overflow_flag                   ; clear V (indicates value is ok)

csav_badfile
        LDMFD   sp!, {r2, lr}
        ORRS    pc, lr,#Overflow_flag                   ; set V to indicate fault






;***********************************************************************************
;
;       SWI call routines
;
;***********************************************************************************



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_Open
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = number indicating what of Pac we are opening
;           0 = Overview Pac
;         >=1 = Image Pac number N
;    R1 = pointer to filename of file to open
;         or file handle (if bit 0 of R2 set)
;    R2 = flags
;
; On Exit
;    R0 = PhotoCD handle (or error pointer)
;    R1 preserved
;    R2 preserved


swi_Open

        STMFD   sp!, {r0-r7, lr}


        TST     r2, #ocflag_fileisopen                  ; test the flag word
        BEQ     o_locatefile                            ; file is not already open branch

        ; make sure that filehandle describes a file that
        ; has actually been opened
        MOV     r0, #254                                ; read info on file handle
        SWI     XOS_Args
        TST     r0, #(1 << 11)                          ; is stream allocated?
        BEQ     o_testreadaccess                        ; yes - skip error return

        ; generate a 'file is not open' type error
        ADR     r0, BadFH_errormsg
        BL      ErrorLookup
        B       o_returnerr

o_testreadaccess
        ; make sure that we have read access to the file.
        ; At the present time, it is impossible to open a file
        ; without read access, but I feel a little pessimistic today.
        TST     r0, #(1 << 6)                           ; do we have read access?
        LDRNE   r5, [sp, #4]                            ; retrieve file handle
        BNE     o_fileisnowopen                         ; yes - do all the other setting up needed

        ; generate a 'no read access' type error
        ADR     r0, NoRead_errormsg
        BL      ErrorLookup
        B       o_returnerr


        ;- - - - - - - - - - - - - - - - - - - - - - - -


o_locatefile
        ; first, see if r1 is a file or directory

        MOV     r6, #0                                  ; using r6 as a flag (see later)

        CMP     r1, #0                                  ; if no filename supplied, then let
        BEQ     o_dirfound                              ; GetPacName generate the default for us

o_getinfo
        MOV     r0, #5                                  ; OSFile_ReadInfo
        SWI     XOS_File
        BVS     o_returnerr

        CMP     r0, #1                                  ; object is a file?
        BEQ     o_filefound

        CMP     r0, #2                                  ; object is a directory or image?
        CMPNE   r0, #3
        BEQ     o_dirfound

        ; object not found or is some sort of strange object
        ; - generate an appropriate error
o_generror
        MOV     r2, r0
        MOV     r0, #19
        SWI     XOS_File
        B       o_returnerr


o_dirfound
        ; R1 is a directory, assume that this a PhotoCD file structure
        ; root path, and try again.

        TEQ     r6, #0                                  ; if we have already tried treating filename
        BNE     o_generror                              ; as a directory, then give up and return error

        LDR     r0, [sp]                                ; retrieve r0 from stack
        MOV     r3, r1                                  ; r3 -> path name
        ADR     r1, cd_sectorbuffers                    ; use sector buffer for filename
        MOV     r2, #CDSectorSize                       ; buffer size
        SWI     XPhotoCD_GetPacName
        BVS     o_returnerr

        ; terminate the generated filename
        MOV     r6, #0
        STRB    r6, [r1, r2]                            ; (r2 returned from GetPacName)

        MOV     r6, #1
        B       o_getinfo


o_filefound
        ; r1 points to the file to try opening as a Pac

        MOV     r0, #&40
        SWI     XOS_Find
        BVS     o_returnerr
        MOV     r5, r0                                  ; preserve file handle


o_fileisnowopen
        ; file opened successfully, create a new pcd block

        LDR     r0, [sp]                                ; retrieve r0 from stack
        CMP     r0, #0                                  ; overview pac?
        LDREQ   r3, =sizeof_pcdovwpac                   ; get appropriate block size
        LDRNE   r3, =sizeof_pcdimgpac
        MOV     r0, #6                                  ; Claim workspace
        SWI     XOS_Module
        BVC     o_initpcd

        ; could not claim pcd block
        MOV     r0, #0                                  ; close the file before returning error
        MOV     r1, r5
        SWI     XOS_Find

        ADR     r0, CantOpen_errormsg
        BL      ErrorLookup
        B       o_returnerr



o_initpcd
        ; here: r2 -> new pcd block in RMA
        ;       r5 = file handle
        ;       r4 = file size

        ; mark pcd block with special id
        LDR     r0, BlockID
        STR     r0, [r2, #pcd_magic]                    ; write magic id to new block

        ; link in the new block to the linked list
        LDR     r0, pcd_firstpcdblock                   ; get current first block from workspace
        STR     r0, [r2, #pcd_next]                     ; point to it in new pcd block
        STR     r2, pcd_firstpcdblock                   ; make new pcd the first one in list

        STR     r5, [r2, #pcd_filehandle]               ; system filehandle
        STR     r4, [r2, #pcd_filesize]                 ; Pac filesize (r4 is filesize returned
                                                        ;    from OS_File,5 call above
        LDR     r0, [sp]                                ; retrieve pac no from stack
        STR     r0, [r2, #pcd_pacno]

        STR     r2, [sp]                                ; store pcd handle for returning from SWI

        MOV     r7, r2                                  ; preserve pcd handle


        ; process splits now, depending on which type of Pac this is

        CMP     r0, #0
        BNE     o_imagepac


o_overviewpac
        ; check that this is a valid Overview Pac
        ; - read an appropriate section of the file

        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r1, r5                                  ; file handle
        ADR     r2, cd_sectorbuffers                    ; temporary space to put it
        MOV     r3, #sizeof_opaheader                   ; how much to read
        MOV     r4, #opa_FilePos                        ; where from
        SWI     XOS_GBPB
        BVS     o_returnerr

        ADR     r0, BadOvwPac_errormsg                  ; set up r0 (a) in case of error (b) for o_checksigandvers
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        BNE     o_badfile                               ; no

        ADR     r2, cd_sectorbuffers                    ; restore r2
        ADR     r6, OPA_sig                             ; address of signature to check against
        MOV     r1, #7                                  ; size of signature
        BL      CheckSigAndVers
        BVS     o_badfile


        ; record the other info read in by the above OS_GBPB

        ADD     r2, r2, #opa_numimages                  ; r2 -> number of images
        BL      getShort                                ; read a big-endian short int
        STR     r1, [r7, #pcd_numimages]                ; store value in pcd block

        ; read in the set of thumbnail attributes/flags from the Pac
        MOV     r0, #4                                  ; read bytes using current file pointer
                                                        ; (should be pointing to correct place after last call)
        MOV     r1, r5                                  ; file handle
        ADD     r2, r7, #pcd_attributes                 ; temporary space to put it
        LDR     r3, =opa_MaxThumbnails                  ; how much to read
        SWI     XOS_GBPB
        BVS     o_returnerr
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        ADRNE   r0, BadOvwPac_errormsg
        BNE     o_badfile                               ; no


        LDMFD   sp!, {r0-r7, pc}^



o_imagepac
        ; check that this is a valid Image Pac
        ; - read an appropriate section of the file

        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r1, r5                                  ; file handle
        ADR     r2, cd_sectorbuffers                    ; temporary space to put it
        MOV     r3, #CDSectorSize                       ; how much to read
        MOV     r4, #ipi_FilePos                        ; where from
        SWI     XOS_GBPB
        BVS     o_returnerr

        ADR     r0, BadImgPac_errormsg                  ; set up r0 (a) in case of error (b) for o_checksigandvers
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        BNE     o_badfile                               ; no

        ADR     r2, cd_sectorbuffers                    ; restore r2
        ADR     r6, IPI_sig                             ; address of signature to check against
        MOV     r1, #7                                  ; size of signature
        BL      CheckSigAndVers
        BVS     o_badfile


        ; record other info we need from this file sector
        ; some useful information stored at offset 1536 in sector 2 of file

        ; NOTE: the 'pcd_imgno' and IPE related values are read here but
        ; they are not actually used anywhere.  They are presumably values
        ; that may be used in future versions of PhotoCD access software.

        ADD     r2, r2,#1536
        BL      getShort                                ; 'image no' (not used)
        STR     r1, [r7, #pcd_imgno]                    ; store in pcd block

        LDRB    r1, [r2],#1
        AND     r3, r1,#&3                              ; (bits 0&1) = default rotation
        STR     r3, [r7, #pcd_rotation]                 ; store in pcd block (stored as word; read as byte)

        ; find maximum resolution step of image
        AND     r3, r1,#&c                              ; (bits 2&3) = maximum resolution step
                                                        ;     (0 = Base; 1 = 4Base; 2 = 16Base)
        MOV     r3, r3,LSR#2
        ADD     r3, r3,#step_Base                       ; convert to standard res step value
        STR     r3, [r7, #pcd_maxstep]                  ; store in pcd block

        ; find out if image has an IPE
        ANDS    r3, r1,#&10                             ; (bit 4) = IPE claimed
        MOVNE   r3, #-1
        STR     r3, [r7, #pcd_ipeclaimed]               ; store in pcd block


        ; find position of start of 4Base image in file
        BL      getShort                                ; read sector offset of end of 4Base data
        CMP     r1, #0                                  ; 4Base data present?
        LDRNE   r0, =sector_4BaseICA                    ; yes - start of 4Base image data is at <sector_4BaseICA>
        MOVEQ   r0, #0                                  ; else zero the position value
        STR     r0, [r7, #pcd_pos4base]
        MOV     r3, r1                                  ; preserve '4Base_end'

        ; find position of start of 16Base image in file
        BL      getShort                                ; read sector offset of end of 16Base data
        CMP     r1, #0                                  ; 16Base data present?
        MOVNE   r0, r3                                  ; yes - start of 16Base image is at <4Base_end>
        MOVEQ   r0, #0
        STR     r0, [r7, #pcd_pos16base]
        MOV     r4, r1                                  ; preserve '16Base_end'

        ; find position of start of IPE in file
        BL      getShort                                ; read sector offset of end of IPE data
        CMP     r1, #0                                  ; IPE data present?
        BEQ     o_setipe                                ; no - set IPE position to 0
        CMP     r4, #0                                  ; is 16Base present?
        MOVNE   r1, r4                                  ; yes - start of IPE is at <16Base_end>
        BNE     o_setipe
        CMP     r3, #0                                  ; else: is 4Base present?
        MOVNE   r1, r3                                  ; yes - start of IPE is at <4Base_end>
        LDREQ   r1, =sector_4BaseICA                    ; else: start of IPE is where 4Base would have been
o_setipe
        STR     r1, [r7, #pcd_posipe]


        ; find huffman table ID for 4Base
        ADD     r2, r2,#11                              ; step on to where this byte is stored
        LDRB    r1, [r2]
        STR     r1, [r7, #pcd_huffid4]

        ; return now!
        LDMFD   sp!, {r0-r7, pc}^


o_returnerr
        STR     r0, [sp]
        LDMFD   sp!, {r0-r7, pc}


o_badfile
        BL      ErrorLookup                             ; messagetrans the error token
        STR     r0, [sp]                                ; store error pointer in stack for return

        ; close the Pac (close file and free memory)
        MOV     r0, r7
        LDR     r1, [sp, #8]                            ; get input flag word
        SWI     XPhotoCD_Close

        LDMFD   sp!, {r0-r7, lr}
        ORRS    pc, lr,#Overflow_flag                   ; set V



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


CantOpen_errormsg    Error PhotoCD_Err_chunk+5, "PCDCantOpen"
BadOvwPac_errormsg   Error PhotoCD_Err_chunk+7, "PCDBadOvwPac"
BadImgPac_errormsg   Error PhotoCD_Err_chunk+8, "PCDBadImgPac"

BadFH_errormsg       Error PhotoCD_Err_chunk+17, "PCDBadFH"
NoRead_errormsg      Error PhotoCD_Err_chunk+18, "PCDNoRead"



BlockID    DCB    "PRL!"

OPA_sig    DCB    "PCD_OPA"
           ALIGN                ; align allows ADR to find IPI_sig much more easily
IPI_sig    DCB    "PCD_IPI"
           ALIGN


           LTORG



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_Close
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle of Pac you wish to close.
;    R1 = flags
;
; On Exit
;    R0 preserved
;    R1 preserved


swi_Close

        STMFD   sp!, {r0-r4, lr}


        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     c_handleok                              ; handle is ok

        ADR     r0, BadHandle_errormsg                  ; return 'bad handle' error
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r4, pc}


c_handleok

        MOV     r3, r0                                  ; preserve pcd handle


        TST     r1, #ocflag_fileisopen                  ; test the flag word
        BNE     c_freemem                               ; 'leave open' set - avoid file closing


        ; close the file if it is open

        LDR     r1, [r3, #pcd_filehandle]               ; get file handle
        CMP     r1, #0                                  ; file open?
        MOVNE   r0, #0
        SWINE   XOS_Find                                ; close file (ignore errors)


c_freemem
        ;--- extricate pcd block from linked list and free it

        ; First, locate the block in the linked list.
        ; We know it must be there, because routine CheckPCDhandle said so.
        ; Actually, we are really locating the previous block, so we can
        ; update it's 'next' pointer when the block being closed is gone.

        ADR     r4, pcd_firstpcdblock
c_locateloop
        LDR     r2, [r4]                                ; get address of first/next block
        CMP     r2, r3                                  ; is this the one we want?
        BEQ     c_found                                 ; yep
        ADD     r4, r2,#pcd_next                        ; r4 -> address of next block
        B       c_locateloop

c_found
        ; here: r4 = address of 'next' pointer in previous block

        LDR     r2, [r3, #pcd_next]                     ; pointer to block after one bing removed
        STR     r2, [r4]                                ; prevblock[next] = currblock[next]

        ; free the block
        MOV     r0, #7
        MOV     r2, r3
        SWI     XOS_Module
        STRVS   r0, [sp]                                ; return error if any occurred


        [       Switch_ReadAheadBufferEnabled
        ; if this handle is the handle of the data in the ubuf,
        ; then make sure that GetBlock doesn't use the old data
        ; in the ubuf if the handle is reused for a new image!

        LDR     r0, gb_ubufpcdhandle                    ; handle of data in ubuf
        CMP     r3, r0                                  ; same as this one?
        MOVEQ   r0, #0                                  ; yes, reset 'handle-of-data-in-ubuf'
        STREQ   r0, gb_ubufpcdhandle
        ]


c_exit
        LDMFD   sp!, {r0-r4, pc}



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadHandle_errormsg    Error PhotoCD_Err_chunk+6, "PCDBadHandle"



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetPacName
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = number indicating which Pac we want the name of.
;          >=1 = Image Pac number N
;            0 = Overview Pac
;           -1 = Info file ("INFO/PCD")
;           -2 = Image copyright file ("RIGHTS.<r4>")
;    R1 = pointer to buffer
;    R2 = size of buffer
;    R3 = pointer to root path string indicating where
;         PhotoCD file structure can be found.
;    R4 = (only if R0 = -2)
;         pointer to name of copyright file
;
; On Exit
;    R0 preserved
;    R1 preserved
;    R2 = size of returned string
;    R3 preserved
;    R4 preserved


swi_GetPacName

        STMFD   sp!, {r1,r3-r6, lr}

        ; check that buffer address is sensible
        BL      CheckAddress
        BCC     gpn_checkpacno
        ADR     r0, BadBuff_errormsg
        BL      ErrorLookup
gpn_returnerr
        MOV     r2, #0
        LDMFD   sp!, {r1,r3-r6, pc}


gpn_checkpacno
        ; check that we have a sensible Pac/r0 number
        CMP     r0, #-2
        BLT     gpn_badr0
        LDR     r5, =9999
        CMP     r0, r5
        BLE     gpn_pacnumok

gpn_badr0
        ; generate bad pac number error
        ADR     r0, BadPacNo_errormsg
        BL      ErrorLookup
        B       gpn_returnerr


gpn_pacnumok
        ; if r3=0, use default path
        CMP     r3, #0
        ADREQ   r3, PCD_defpath

        MOV     r4, #0                                  ; output character count

        ; copy the supplied root path into buffer
        BL      gpn_copystr

        ; add a "." if not already present
        SUB     r5, r4,#1
        LDRB    r5, [r1, r5]
        CMP     r5, #"."
        MOVNE   r5, #"."
        STRNEB  r5, [r1,r4]
        ADDNE   r4, r4,#1


        ; now check: Overview Pac, Image Pac, or other?
        TEQ     r0, #0
        ADREQ   r3, PCD_ovw                             ; append Overview Pac filename and exit
        BEQ     gpn_copyandexit

        CMP     r0, #-1
        ADREQ   r3, PCD_info                            ; append Info file filename and exit
        BEQ     gpn_copyandexit

        CMP     r0, #-2
        BEQ     gpn_copyrightfile


        ; else: generate an Image Pac filename
        ADR     r3, PCD_img
        BL      gpn_copystr

        ; convert image number to ASCII
        MOV     lr, r0
        ADR     r3, gpn_decimal
gpn_ascii_loop1
        CMP     r4, r2
        BGE     gpn_exit

        LDR     r6, [r3],#4
        MOV     r5, #0
gpn_ascii_loop2
        CMP     r6, lr
        SUBLE   lr, lr,r6
        ADDLE   r5, r5,#1
        BLE     gpn_ascii_loop2

        ADD     r5, r5,#"0"
        STRB    r5, [r1,r4]
        ADD     r4, r4,#1

        CMP     r6, #1
        BGT     gpn_ascii_loop1


        ADR     r3, PCD_imga
        BL      gpn_copystr
        B       gpn_exit


        ;- - - - - - - - - - - - - - - - - - - - - - - -


gpn_copyrightfile
        ; generate a copyright file filename
        ADR     r3, PCD_cpyrt
        BL      gpn_copystr

        LDR     r3, [sp, #8]                            ; retrieve entry-r4 from stack


gpn_copyandexit
        BL      gpn_copystr

gpn_exit
        MOV     r2, r4
        LDMFD   sp!, {r1,r3-r6, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


gpn_copystr

        ; copy the string at r3 into the buffer at r1

        CMP     r4, r2                                  ; have we overflowed buffer?
        BGE     gpn_exit

        LDRB    r5, [r3],#1                             ; get a char from source string
        CMP     r5, #32                                 ; end of string?
        MOVLTS  pc, r14

        STRB    r5, [r1,r4]                             ; copy char
        ADD     r4, r4,#1
        B       gpn_copystr


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


PCD_defpath     DCB     "CDFS::0.$.", 0

PCD_ovw         DCB     "PHOTO_CD.OVERVIEW/PCD",0

PCD_img         DCB     "PHOTO_CD.IMAGES.IMG", 0
PCD_imga        DCB     "/PCD", 0

PCD_info        DCB     "PHOTO_CD.INFO/PCD", 0

PCD_cpyrt       DCB     "PHOTO_CD.RIGHTS.", 0

                ALIGN



gpn_decimal     DCD     1000
                DCD     100
                DCD     10
                DCD     1


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadPacNo_errormsg    Error PhotoCD_Err_chunk+4, "PCDBadPacNo"

BadBuff_errormsg     Error PhotoCD_Err_chunk+2, "PCDBadBuff"



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetSize
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle (or <=0 for none/no checks)
;    R1 = thumbnail image number (if this is an Overview Pac)
;    R2 = resolution step
;    R3 = transform
;
; On Exit
;    R0-R3 preserved
;    R4 = x size of image
;    R5 = y size of image



swi_GetSize


        STMFD   sp!, {r0-r3,r6, lr}

        MOV     r4, #0                                  ; something vaguely sensible to return by default
        MOV     r5, #0

        CMP     r0, #0                                  ; check for special value for r0
        BLE     gs_nopcdhandle


        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     gs_handleok                             ; handle is ok

        ADR     r0, BadHandle_errormsg                  ; return 'bad handle' error
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r3,r6, pc}


gs_handleok
        ; get Pac type (ie. Overview or Image)
        LDR     r6, [r0, #pcd_pacno]

        TEQ     r6, #0                                  ; is Pac an Image Pac?
        BNE     gs_imgpac

        ;- - - - - - - - - - - - - - - - - - - - - - - -

gs_ovwpac
        ; Pac is an Overview Pac - check the thumbnail number in R1
        BL      CheckThumbNo
        STRVS   r0, [sp]                                ; if bad no, return error
        LDMVSFD sp!, {r0-r3,r6, pc}

        ; check resolution step
        CMP     r2, #step_Base64
        BLT     gs_badresol
        CMP     r2, #step_Base16
        BGT     gs_badresol

        B       gs_convertr3

        ;- - - - - - - - - - - - - - - - - - - - - - - -

gs_imgpac
    ; check resolution step
        [       Switch_AllowBase64forIPacs
        CMP     r2, #step_Base64
        |
        CMP     r2, #step_Base16
        ]
        BLT     gs_badresol
        LDR     r1, [r0, #pcd_maxstep]                  ; max resolution available for this Image Pac
        CMP     r2, r1
        BGT     gs_badresol

        B       gs_convertr3

        ;- - - - - - - - - - - - - - - - - - - - - - - -

gs_nopcdhandle
        ; check resolution step
        CMP     r2, #step_Base64
        BLT     gs_badresol
        CMP     r2, #step_16Base
        BGT     gs_badresol

        ;- - - - - - - - - - - - - - - - - - - - - - - -

gs_convertr3
        MOV     r0, r3
        BL      ConvXformExtToInt                       ; convert external transform value to internal form
        STRVS   r0, [sp]                                ; if bad value, return error
        LDMVSFD sp!, {r0-r3,r6, pc}
        MOV     r3, r0

        ; here: r3 = transform in internal format

gs_readsize
        ADR     r4, ResXtable
        LDR     r4, [r4, r2,ASL#2]                      ; get picture width
        ADR     r5, ResYtable
        LDR     r5, [r5, r2,ASL#2]                      ; get picture height

        TST     r3, #1                                  ; test for odd number of 90° rotations
        MOVNE   r6, r4                                  ; yes - swap X and Y
        MOVNE   r4, r5
        MOVNE   r5, r6

        LDMFD   sp!, {r0-r3,r6, pc}^



        ; Generate bad resolution step error message

gs_badresol
        ADR     r0, BadResol_errormsg
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r3,r6, pc}



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadResol_errormsg    Error PhotoCD_Err_chunk+10, "PCDBadResol"


ResXtable
        DCD     x_Base64
        DCD     x_Base16
        DCD     x_Base4
        DCD     x_Base
        DCD     x_4Base
        DCD     x_16Base

ResYtable
        DCD     y_Base64
        DCD     y_Base16
        DCD     y_Base4
        DCD     y_Base
        DCD     y_4Base
        DCD     y_16Base



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetRotation
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;    R1 = thumbnail image number (if this is an Overview Pac)
;
; On Exit
;    R0 preserved
;    R1 preserved
;    R2 = transform


swi_GetRotation

        STMFD   sp!, {r0-r1,r3, lr}

        MOV     r2, #0                                  ; something vaguely sensible to return by default

        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     gr_handleok                             ; handle is ok

        ADR     r0, BadHandle_errormsg                  ; return 'bad handle' error
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r1,r3, pc}


gr_handleok
        ; get Pac type (ie. Overview or Image)
        LDR     r2, [r0, #pcd_pacno]

        CMP     r2, #0                                  ; is Pac an Image Pac?
        LDRNEB  r2, [r0, #pcd_rotation]                 ; yes - read orientation..
        BNE     gr_convdeg                              ; ..and return degrees equivalent


        ; Pac is an Overview Pac - check the thumbnail number in R1
        BL      CheckThumbNo
        STRVS   r0, [sp]                                ; if bad no, return error
        LDMVSFD sp!, {r0-r1,r3, pc}

        ; thumbnail no. is ok, read the rotation
        ADD     r0, r0, #pcd_attributes                 ; r0 -> attributes table
        SUB     r1, r1,#1
        LDRB    r2, [r0, r1]                            ; get the attribute byte
        AND     r2, r2,#3                               ; extract rotation bits

gr_convdeg
        ADR     r3, Rot_table
        LDR     r2, [r3, r2,ASL#2]                      ; convert value to degrees

        LDMFD   sp!, {r0-r1,r3, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


Rot_table  DCD     0
           DCD    90
           DCD   180
           DCD   270


           LTORG



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetCount
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;
; On Exit
;    R0 preserved
;    R1 = Resolutions available (for Image Pacs only)
;    R2 = Number of Images/Resolutions available


swi_GetCount

        STMFD   sp!, {lr}

        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     gc_handleok                             ; handle is ok

        addr    r0, BadHandle_errormsg                  ; return 'bad handle' error
        BL      ErrorLookup
        ;STR     r0, [sp]
        LDMFD   sp!, {pc}


gc_handleok

        LDR     r2, [r0, #pcd_pacno]                    ; get the Pac number of this pcd handle
        CMP     r2, #0
        BNE     gc_imagepac


gc_overviewpac
        ; PCD handle refers to an Overview Pac

        LDR     r2, [r0, #pcd_numimages]
        LDMFD   sp!, {pc}^


gc_imagepac
        ; PCD handle refers to an Image Pac

        STMFD   sp!, {r3}

smallressteps   *   ((1:SHL:step_Base) :OR: (1:SHL:step_Base4) :OR: (1:SHL:step_Base16))

        LDR     r3, [r0, #pcd_maxstep]

        ; is maxstep = 16Base?
        CMP     r3, #step_16Base
        MOVEQ   r1, #((1:SHL:step_16Base) :OR: (1:SHL:step_4Base) :OR: smallressteps)
        MOVEQ   r2, #(step_16Base - step_Base16 + 1)
        BEQ     gc_ip_exit

        ; else: is maxstep = 4Base?
        CMP     r3, #step_4Base
        MOVEQ   r1, #((1:SHL:step_4Base) :OR: smallressteps)
        MOVEQ   r2, #(step_4Base - step_Base16 + 1)
        BEQ     gc_ip_exit

        ; else: maxstep must= Base
        MOV     r1, #smallressteps
        MOV     r2, #(step_Base - step_Base16 + 1)

gc_ip_exit
        LDMFD   sp!, {r3, pc}^



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetBytesPerRow
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = width of image in pixels
;    R1 = pointer to PhotoCD Bitmap Data Block
;
; On Exit
;    R0 = number of bytes required to store one row
;    R1 preserved


swi_GetBytesPerRow

        STMFD   sp!, {r1-r2, lr}

        ; check for special case (r0 = -1)
        CMP     r0, #-1
        LDREQ   r2, [r1, #bdb_left]                     ; calculate width from coords
        LDREQ   r0, [r1, #bdb_right]
        SUBEQ   r0, r0,r2

        LDR     r2, [r1, #bdb_colourformat]             ; get colour format

        ; if colour format = greyscale, then rowbytes = width
        TEQ     r2, #colour_greyscale
        TEQNE   r2, #colour_palette
        BEQ     gbpr_exit

        ; if coloyr format = rgb or ycc, then rowbytes = width * columnoffset
        TEQ     r2, #colour_rgb
        TEQNE   r2, #colour_ycc
        LDREQ   r1, [r1, #bdb_columnoffset]
        MULEQ   r0, r1, r0
        BEQ     gbpr_exit


        ; if here: colour format is unknown - return error
        ADR     r0, BadColFmt_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r1-r2, pc}


gbpr_exit
        LDMFD   sp!, {r1-r2, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadColFmt_errormsg    Error PhotoCD_Err_chunk+13, "PCDBadColFmt"



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_ReadImageInfo
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;    R1 = pointer to buffer (of at least 356 bytes)
;
; On Exit
;    R0 preserved
;    R1 preserved


swi_ReadImageInfo

        STMFD   sp!, {r0-r5, lr}

        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     rii_checkpac                            ; handle is ok

        addr    r0, BadHandle_errormsg                  ; return 'bad handle' error
        BL      ErrorLookup
rii_returnerr
        STR     r0, [sp]
        LDMFD   sp!, {r0-r5, pc}


rii_checkpac
        ; check that this is an Image Pac and not an Overview Pac

        LDR     r5, [r0, #pcd_pacno]
        CMP     r5, #0
        BNE     rii_checkbuf
        ADR     r0, NotImgPac_errormsg
        BL      ErrorLookup
        B       rii_returnerr


rii_checkbuf
        ; check that buffer address is sensible

        LDR     r2, =sizeof_ipi                         ; should be 356 bytes
        BL      CheckAddress
        BCC     rii_readin
        addr    r0, BadBuff_errormsg
        BL      ErrorLookup
        B       rii_returnerr


rii_readin
        MOV     r5, r1                                  ; preserve buffer pointer

        SUB     r3, r2,#1                               ; how much to read  (sizeof_ipi - extra byte for terminator)
        MOV     r2, r1                                  ; temporary space to put it
        LDR     r1, [r0, #pcd_filehandle]               ; file handle
        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r4, #ipi_FilePos                        ; where from
        ADD     r4, r4,#sizeof_ipi_signature
        SWI     XOS_GBPB
        BVS     rii_returnerr
        ; we won't bother checking r3 here as it must be ok because
        ; this part of file must already have been read if PCD is open.


        ; info successfully read, do some big-endian -> little-endian
        ; conversion etc

        ADD     r5, r5,#2                               ; skip over version number
        BL      rii_swapshort                           ; do piwversion
        BL      rii_swapshort                           ; do magnification
        BL      rii_swaplong                            ; do scantime
        BL      rii_swaplong                            ; do modtime
        ADD     r5, r5,#(ipi_pixelsize-ipi_origmedia)   ; skip some info
        BL      rii_swapshort                           ; do pixelsize
        ; done all the swapping needed

        ; process the copyright filename
        ADD     r5, r5,#(ipi_copyrightfile-ipi_piwmaker)
        MOV     r0, #0                                  ; write safety termination byte
        STRB    r0, [r5, #(copyright_terminator-ipi_copyrightfile)]
rii_cpyrtloop
        LDRB    r0, [r5]

        CMP     r0, #32                                 ; check for any ctrl characters
        MOVLE   r0, #0
        STRLEB  r0, [r5],#1                             ; terminate with zero and exit
        BLE     rii_cpyrtdone

        CMP     r0, #127
        CMPNE   r0, #255                                ; c lib considers this (255) a terminator
        MOVEQ   r0, #0
        STREQB  r0, [r5],#1                             ; terminate with zero and exit
        BEQ     rii_cpyrtdone

        CMP     r0, #"."                                ; translate "." to "/"
        MOVEQ   r0, #"/"

        CMP     r0, #"\"                               ; translate "\" to "."
        MOVEQ   r0, #"."

        STRB    r0, [r5], #1
        B       rii_cpyrtloop


rii_cpyrtdone

        LDMFD   sp!, {r0-r5, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


rii_swapshort
        ; big-endian to little-endian conversion of
        ; two-byte value at r5.  Afterwards, r5 points
        ; to byte after the value.

        LDRB    r4, [r5,#1]                             ; read byte at location 1
        LDRB    r3, [r5]                                ; read byte at location 0
        STRB    r4, [r5],#1                             ; store byte 1 at location 0
        STRB    r3, [r5],#1                             ; store byte 0 at location 1
        MOVS    pc, lr


rii_swaplong
        ; big-endian to little-endian conversion of
        ; two-byte value at r5.  Afterwards, r5 points
        ; to byte after the value.

        MOV     r0, lr
        LDRB    r1, [r5],#1                             ; read byte at location 0
        BL      rii_swapshort                           ; swap middle two bytes
        LDRB    r2, [r5]                                ; read byte at location 3
        STRB    r1, [r5],#1                             ; store byte 0 at location 3
        STRB    r2, [r5,#-4]                            ; store byte 3 at location 0
        MOVS    pc, r0


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


NotImgPac_errormsg    Error PhotoCD_Err_chunk+12, "PCDNotImgPac"


        LTORG



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetBlock
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;    R1 = thumbnail image number (if this is an Overview Pac)
;    R2 = pointer to PhotoCD Bitmap Data Block
;    R3 = pointer to block of memory for the read bitmap
;    R4 = resolution step
;    R5 = transform
;    R6 = row stride
;
; On Exit
;    R0-R2 preserved (R0 -> error if error occurred)
;    R3 = buffer size required if that has been requested, otherwise preserved
;    R4-R6 preserved



        GET     s.getblock



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_ReadInfoFile
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = pointer to filename of PhotoCD info file.
;    R1 = pointer to buffer (of at least 38 bytes)
;    R2 = 0 if R0 is just the root directory of a standard
;           PhotoCD directory structure.
;         1 if R0 is a full pathname of a file.
;
; On Exit
;    R0 preserved
;    R1 preserved
;    R2 preserved


swi_ReadInfoFile

        STMFD   sp!, {r0-r6, lr}

        ; check that buffer address is sensible

        LDR     r2, =sizeof_info                        ; should be 356 bytes
        BL      CheckAddress
        BCC     rif_open
        addr    r0, BadBuff_errormsg
        BL      ErrorLookup
rif_returnerr
        STR     r0, [sp]
        LDMFD   sp!, {r0-r6, pc}


rif_open
        MOV     r5, r1                                  ; preserve buffer pointer

        LDR     r2, [sp, #8]                            ; retrieve r2
        TEQ     r2, #0
        MOVNE   r1, r0                                  ; r1 = filename (for OS_Find)
        BNE     rif_open2


        ; use GetPacName to generate filename
        MOV     r3, r0
        MOV     r0, #-1
        ADR     r1, cd_sectorbuffers                    ; use sector buffer for filename
        MOV     r2, #CDSectorSize                       ; buffer size
        SWI     XPhotoCD_GetPacName
        BVS     rif_returnerr

        ; terminate the generated filename
        MOV     r6, #0
        STRB    r6, [r1, r2]                            ; (r2 returned from GetPacName)
        B       rif_open2

        ; fall through to open file


rif_open2
        MOV     r0, #&44                                ; b2=directories give error

        SWI     XOS_Find
        BVS     rif_returnerr
        TEQ     r0, #0
        BNE     rif_readin

        ; generate a file not found error
        MOV     r2, #0
        MOV     r0, #19
        SWI     XOS_File
        B       rif_returnerr

rif_readin
        MOV     r6, r0                                  ; preserve file handle for later

        MOV     r1, r0                                  ; file handle
        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r2, r5                                  ; user-supplied buffer
        LDR     r3, =sizeof_info                        ; how much to read
        MOV     r4, #0                                  ; file pointer
        SWI     XOS_GBPB
        BL      rif_closefile
        BVS     rif_returnerr

        ADR     r0, BadInfo_errormsg                    ; set up r0 for in case of bad file
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        BNE     rif_badfile                             ; no

        MOV     r2, r5                                  ; restore r2
        addr    r6, PCD_info                            ; address of signature to check against
        MOV     r1, #8                                  ; size of signature
        BL      CheckSigAndVers
        BVS     rif_badfile

        ; info successfully read, do some little-endian -> big-endian
        ; conversion etc

        ADD     r5, r5,#(info_createtime)               ; skip first lot of info
        BL      rii_swaplong                            ; do createtime
        BL      rii_swaplong                            ; do modtime
        BL      rii_swapshort                           ; do numimages
        ; done all the swapping needed
        ; aside: there is also a three byte value ('Lead out start time') which
        ;        _might_ nead to be reversed - but we won't, for two reasons;
        ;        (a) I'm not sure what this value actually is, and
        ;        (b) the Windows library doesn't bother either.

        LDMFD   sp!, {r0-r6, pc}^


rif_badfile
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r6, pc}



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


rif_closefile
        ; close the file, preserving the status that is passed in
        STMFD   sp!, {r0-r1, lr}
        MOV     r0, #0
        MOV     r1, r6
        SWI     XOS_Find
        LDMFD   sp!, {r0-r1, pc}^


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadInfo_errormsg    Error PhotoCD_Err_chunk+14, "PCDBadInfo"




;-----------------------------------------------------------------------------------
;       SWI PhotoCD_IdentifyFile
;-----------------------------------------------------------------------------------

; On Entry
;    R1 = pointer to filename of file to identify
;
; On Exit
;    R0 = image pac type
;    R1 preserved


swi_IdentifyFile

        STMFD   sp!, {r1-r6, lr}


        ; check that this is a file

        MOV     r0, #5                                  ; OSFile_ReadInfo
        SWI     XOS_File
if_returnerr
        LDMVSFD sp!, {r1-r6, pc}

        TEQ     r0, #1                                  ; object is a file?
        BEQ     if_openfile

        ; object not found or is some sort of strange object
        ; - generate an appropriate error
        MOV     r2, r0
        MOV     r0, #19
        SWI     XOS_File
        B       if_returnerr


if_openfile
        ; open the file

        MOV     r0, #&40
        SWI     XOS_Find
        BVS     if_returnerr

        MOV     r5, r0                                  ; preserve file handle


        ; check to see if this looks like a valid Overview Pac

        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r1, r5                                  ; file handle
        ADR     r2, cd_sectorbuffers                    ; temporary space to put it
        MOV     r3, #sizeof_opaheader                   ; how much to read
        MOV     r4, #opa_FilePos                        ; where from
        SWI     XOS_GBPB
        BVS     if_returnerr
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        BNE     if_notpcd                               ; no

        ADR     r2, cd_sectorbuffers                    ; restore r2
        addr    r6, OPA_sig                             ; address of signature to check against
        MOV     r1, #7                                  ; size of signature
        BL      CheckSigAndVers
        MOVVC   r0, #0                                  ; it is an Overview Pac - return 0
        BVC     if_exit


        ; check to see if this looks like a valid Image Pac

        MOV     r0, #3                                  ; read bytes using specified file pointer
        MOV     r1, r5                                  ; file handle
        ADR     r2, cd_sectorbuffers                    ; temporary space to put it
        MOV     r3, #CDSectorSize                       ; how much to read
        MOV     r4, #ipi_FilePos                        ; where from
        SWI     XOS_GBPB
        BVS     if_returnerr
        CMP     r3, #0                                  ; all the bytes we wanted got read?
        BNE     if_notpcd                               ; no

        ADR     r2, cd_sectorbuffers                    ; restore r2
        addr    r6, IPI_sig                             ; address of signature to check against
        MOV     r1, #7                                  ; size of signature
        BL      CheckSigAndVers
        MOVVC   r0, #1                                  ; it is an Image Pac - return 1
        BVC     if_exit


        ; not matches found
if_notpcd
        MOV     r0, #0                                  ; close the file
        MOV     r1, r5
        SWI     XOS_Find

        MOV     r0, #-1                                 ; -1 indicates that we don't recognise the file

if_exit
        LDMFD   sp!, {r1-r6, pc}^



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_ConvertCoord
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = Coordinate value
;    R1 = Source Resolution step
;    R2 = Destination Resolution step
;
; On Exit
;    R0 = new coordinate value
;    R1 preserved
;    R2 preserved


swi_ConvertCoord

        STMFD   sp!, {r1-r3, lr}

        ; check source resolution step
        CMP     r1, #step_Base64
        BLT     cc_badresol
        CMP     r1, #step_16Base
        BGT     cc_badresol

        ; check destination resolution step
        CMP     r2, #step_Base64
        BLT     cc_badresol
        CMP     r2, #step_16Base
        BGT     cc_badresol

        ; As resolutions just increase as powers of 2,
        ; one can be converted to another by just shifting
        ; by the difference in their resolution step values.

        SUBS    r3, r2,r1                       ; difference in step value

        MOVPL   r0, r0,ASL r3                   ; dest > src to shift left/up
        BPL     cc_done

        RSB     r3, r3,#0                       ; dest < src so..
        MOVS    r0, r0,ASR r3                   ; ..shift down by -difference
        ADDCS   r0, r0,#1                       ; if C set (C=last bit shifted off),
                                                ;    then round up for better accuracy
cc_done
        LDMFD   sp!, {r1-r3, pc}^


        ; Generate bad resolution step error message

cc_badresol
        addr    r0, BadResol_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r1-r3, pc}



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_ConvertYCCtoRGB
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = Y (luminance) value (0..255)
;    R1 = C1 (chrominance 1) value (0..255)
;    R2 = C2 (chrominance 2) value (0..255)
;
; On Exit
;    R0 = red value (0..255)
;    R1 = green value (0..255)
;    R2 = blue value (0..255)


swi_ConvertYCCtoRGB

        ; check that sensible values were passed in

        CMP     r0, #255
        CMPLS   r1, #255                        ; Note: unsigned compares
        CMPLS   r2, #255
        BLS     cy2r_parsok

        ; generate bad ycc values error
        ADR     r0, BadYCC_errormsg
        B       ErrorLookup


cy2r_parsok

        STMFD   sp!, {r3-r5, lr}

        ADR     r3, cy2r_table_y

        ; calculate half of red (also happens to be part of green & blue)
        LDR     r0, [r3, r0, LSL #2]            ; r0 = table_y(y)

        MOV     r4, r1, LSL #2                  ; r4 = c1 (*4 for index)
        MOV     r5, r2, LSL #2                  ; r5 = c2 (*4 for index)

        ; calculate blue
        ADRL    r3, cy2r_table_c1b
        LDR     r2, [r3, r4]                    ; r2 (b) = table_c1b(c1)
        ADD     r2, r0, r2                      ; blue = y(y) + c1b(c1)
        MOV     r2, r2, ASR #12                 ; get rid of fractional part

        ; calculate green
        ADRL    r3, cy2r_table_c1g
        LDR     r1, [r3, r4]                    ; r1 (g) = table_c1g(c1)
        ADRL    r3, cy2r_table_c2g
        LDR     r4, [r3, r5]                    ; r4 = table_c2g(c2)
        ADD     r1, r1,r4
        ADD     r1, r0,r1                       ; green = y(y) + c1g(c1) + c2g(c2)
        MOV     r1, r1, ASR #12                 ; get rid of fractional part

        ; finish calculating red
        ADRL    r3, cy2r_table_c2r
        LDR     r4, [r3, r5]                    ; r4 = table_c2r(c2)
        ADD     r0, r0,r4                       ; red = y(y) + c2r(c2)
        MOV     r0, r0, ASR #12                 ; get rid of fractional part

        ; clamp RGB to the range [0..255]
        CMP     r0, #0
        MOVLT   r0, #0
        CMPGT   r0, #255
        MOVGT   r0, #255
        CMP     r1, #0
        MOVLT   r1, #0
        CMPGT   r1, #255
        MOVGT   r1, #255
        CMP     r2, #0
        MOVLT   r2, #0
        CMPGT   r2, #255
        MOVGT   r2, #255

        LDMFD   sp!, {r3-r5, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadYCC_errormsg    Error PhotoCD_Err_chunk+1, "PCDBadYCC"


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


; Tables for YCC to RGB conversion routine

        GBLA    index


cy2r_table_y

index   SETA    0
        WHILE   (index <= 255)

        DCD     (5564 * index + 2048)

index   SETA    index + 1
        WEND


cy2r_table_c2r

index   SETA    0
        WHILE   (index <= 255)

        DCD     (7461 * index - 1022138)

index   SETA    index + 1
        WEND


cy2r_table_c1g

index   SETA    0
        WHILE   (index <= 255)

        DCD     (274934 - 1762 * index)

index   SETA    index + 1
        WEND


cy2r_table_c2g

index   SETA    0
        WHILE   (index <= 255)

        DCD     (520268 - 3798 * index)

index   SETA    index + 1
        WEND


cy2r_table_c1b

index   SETA    0
        WHILE   (index <= 255)

        DCD     (9085 * index - 1417185)

index   SETA    index + 1
        WEND



;-----------------------------------------------------------------------------------
;       SWI PhotoCD_MiscOp
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = MiscOp reason code
;            0    Return PhotoCD module version
;            1    Return system filehandle used
;                  R1 = PhotoCD handle
;            2    Convert PhotoCD date stamp to RISC-OS format
;                  R1 = PhotoCD format date stamp
;                  R2 = pointer to five byte block
;
;         Other registers contain parameters (as required)
;
; On Exit
;    R0 preserved
;    R1 etc contain return value(s) as needed


swi_MiscOp

        CMP     r0, #0
        BNE     mo_rcode1

        ; MiscOp 0 - Return PhotoCD module version

        MOV     r1, #Module_Version
        MOVS    pc, lr


        ;- - - - - - - - - - - - - - - -


mo_rcode1
        CMP     r0, #1
        BNE     mo_rcode2

        ; MiscOp 1 - Return system filehandle used
        ;    R1 = PhotoCD handle

        STMFD   sp!, {r0, lr}

        MOV     r0, r1
        BL      CheckPCDhandle                  ; Check PCD handle is valid
        MOVCS   r1, #0                          ; Return 0 when invalid handle

        ; handle is valid - read the OS file handle from the structure
        LDR     r1, [r0, #pcd_filehandle]

mo1_exit
        LDMFD   sp!, {r0, pc}^


        ;- - - - - - - - - - - - - - - -


mo_rcode2
        CMP     r0, #2
        BNE     mo_badrcode

        ; MiscOp 2 - Convert PhotoCD date stamp to RISC-OS format
        ;    R1 = PhotoCD format date stamp
        ;    R2 = pointer to five byte block

        STMFD   sp!, {r0-r6, lr}

        ; Check the return buffer is valid
        MOV     r1, r2
        ADD     r2, r1,#5
        BL      CheckAddress
        BCC     mo2_buffok

        ADRL    r0, BadBuff_errormsg
        BL      ErrorLookup
        STR     r0, [sp]                        ; store r0 for return
        LDMFD   sp!, {r0-r6, pc}

mo2_buffok
        LDMFD   sp, {r0-r2}                     ; recover the parameters

        ; multiply by 100 (convert seconds to centiseconds)
        ; n * 100 = (n<<6 + n<<5 + n<<2)
        ; this is complicated though by the fact that we are
        ; working with a 40-bit number

        MOV     r4, r1,LSR #(32-6)              ; top 8 bits of (n<<6)
        MOV     r3, r1,ASL #6                   ; bot 32 bits of (n<<6)
        MOV     r6, r1,LSR #(32-5)              ; top 8 bits of (n<<5)
        MOV     r5, r1,ASL #5                   ; bot 32 bits of (n<<5)
        ADDS    r3, r3,r5                       ; add together
        ADC     r4, r4,r6
        MOV     r6, r1,LSR #(32-2)              ; top 8 bits of (n<<2)
        MOV     r5, r1,ASL #2                   ; bot 32 bits of (n<<2)
        ADDS    r3, r3,r5                       ; add together
        ADC     r4, r4,r6
        ; here r3,4 contain r1*100

        ; add in the RISC-OS equivalent of the 'Kodak' zero date
        ADR     r0, mo_Kodak_0_Time
        LDMIA   r0, {r5,r6}
        ADDS    r3, r3,r5                       ; add together
        ADC     r4, r4,r6

        ; now write out the result to the buffer
        ; write out the five bytes one at a time (buffer is not necessarily aligned)
        STRB    r3, [r2],#1
        MOV     r3, r3,LSR #8
        STRB    r3, [r2],#1
        MOV     r3, r3,LSR #8
        STRB    r3, [r2],#1
        MOV     r3, r3,LSR #8
        STRB    r3, [r2],#1
        STRB    r4, [r2],#1

        LDMFD   sp!, {r0-r6, pc}^



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


mo_Kodak_0_Time                    ; <00:00:00 on Jan 1 1970 UTC/GMT> in RISCOS format
        DCD     &6e996a00
        DCD     &33


mo_badrcode
        ADR     r0, BadMiscOp_errormsg
        B       ErrorLookup

BadMiscOp_errormsg    Error PhotoCD_Err_chunk+3, "PCDBadMiscOp"



;-----------------------------------------------------------------------------------


whoamI
        =       "Te kaituhi: Paul LeBeau o Aotearoa",0


        END

