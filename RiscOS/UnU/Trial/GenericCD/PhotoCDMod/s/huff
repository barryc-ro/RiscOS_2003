;==========================================
;
;  s.huff
;
;  Huffman decoding routines
;
;  Photo CD support module
;
;  © 1993 Acorn Computers Ltd
;
;  Developed in association with 4Mation
;  Author: Paul LeBeau
;
;==========================================



huff_setup4

; Set up everything required for huffman decoding for 4Base images


        STMFD   sp!, {r0, r2-r11, lr}

        LDR     r4, gb_pcdhandle
        LDR     r4, [r4, #pcd_pos4base]                 ; sector pos of start of 4Base data

        STR     r4, gb_dohuffman                        ; flag availability of huffman data
        TEQ     r4, #0
        BEQ     hs4_exit

        ; read in the huffman code table
        ADD     r2, r4,#4                               ; sector offset of code table
        LDR     r6, gb_addr_Y4codetable                 ; where to store the table itself
        BL      huff_readcodetable
        BVS     hs4_exit
        STR     r7, gb_Y4codetablesize                  ; store the returned table size


        ; initialise bit buffer and pointer
        MOV     r8, #0                                  ; bit buffer
        MOV     r9, #0                                  ; bit ptr
        ADR     r10, cd_sectorbuffers
        ADD     r10, r10,#gb_Y4huff_sectbufend          ; set sector buffer ptr to end
                                                        ; (as though it was empty)
        MOV     r11, #0                                 ; sector buffer bytes left


        ; find the sector that contains the start of the image data
        ADD     r2, r4,#3                               ; sector offset of line table
        LDR     r3, gb_firstline
        MOV     r3, r3,ASR#2                            ; line num passed is actually line/4
        BL      huff_findlinesector
        ADD     r2, r4,r2                               ; (sector offset returned is relative to ICA offset)

        ; point file pointer at this sector
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        MOV     r2, r2,ASL#11                           ; convert sectors to bytes
        SWI     XOS_Args
        BVS     hs4_exit

        ; find the start of the first line
        LDR     r3, gb_firstline
        LDR     r4, = ((1 << 15) - 1)
        BL      huff_findline
        BVS     gb_returnerr


        BL      huff_savevarsY4

hs4_exit
        LDMFD   sp!, {r0, r2-r11, pc}



;-----------------------------------------------------------------------------------



huff_setup16

; Set up everything required for huffman decoding for 16Base images


        STMFD   sp!, {r0, r2-r11, lr}

        LDR     r4, gb_pcdhandle
        LDR     r4, [r4, #pcd_pos16base]                ; sector pos of start of 16Base data

        STR     r4, gb_dohuffman                        ; flag availability of huffman data
        TEQ     r4, #0
        BEQ     hs16_exit


        ; read in the Y-component huffman code table
        ADD     r2, r4,#12                              ; sector offset of code table
        LDR     r6, gb_addr_Ycodetable
        BL      huff_readcodetable
        BVS     hs16_exit
        STR     r7, gb_Ycodetablesize                   ; store the returned table size

        ; read in the C1-component huffman code table
        LDR     r6, gb_addr_C1codetable
        BL      huff_readextracodetable
        BVS     hs16_exit
        STR     r7, gb_C1codetablesize                  ; store the returned table size

        ; read in the C2-component huffman code table
        LDR     r6, gb_addr_C2codetable
        BL      huff_readextracodetable
        BVS     hs16_exit
        STR     r7, gb_C2codetablesize                  ; store the returned table size


        ; find the sector that contains the start of the image data
        ADD     r2, r4,#10                              ; sector offset of line table
        LDR     r3, gb_y0
        BIC     r3, r3,#1                               ; clear bit 0 - even entry is Y data sector
                                                        ; offset, odd entry is C data sector offset
        BL      huff_findlinesector
        ADD     r2, r4,r2                               ; Y huffman data sector start position
        ADD     r5, r4,r3                               ; C1 and C2 huffman data sector start position


        ; --- initialise the Y component vars ---

        ; initialise bit buffer and pointer
        MOV     r8, #0                                  ; bit buffer
        MOV     r9, #0                                  ; bit ptr
        ADR     r10, cd_sectorbuffers
        ADD     r10, r10,#gb_Yhuff_sectbufend           ; set sector buffer ptr to end
                                                        ; (as though it was empty)
        MOV     r11, #0                                 ; sector buffer bytes left

        ; point file pointer at this sector
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        MOV     r2, r2,ASL#11                           ; convert sectors to bytes
        SWI     XOS_Args
        BVS     hs16_exit

        ; find the start of the first line
        LDR     r3, gb_y0
        LDR     r4, =  ((1 << 12) - 1)
        BL      huff_findline
        BVS     gb_returnerr

        BL      huff_savevarsY


        ; --- initialise the C1 component vars ---

        ; initialise bit buffer and pointer
        MOV     r8, #0                                  ; bit buffer
        MOV     r9, #0                                  ; bit ptr
        ADR     r10, cd_sectorbuffers
        ADD     r10, r10,#gb_C1huff_sectbufend          ; set sector buffer ptr to end
                                                        ; (as though it was empty)
        MOV     r11, #0                                 ; sector buffer bytes left

        ; point file pointer at this sector
        MOV     r0, #1
        ; r1 still valid from above
        MOV     r2, r5,ASL#11                           ; convert sectors to bytes
        SWI     XOS_Args
        BVS     hs16_exit

        ; find the start of the first line
        LDR     r3, gb_y0                               ; C residual lines are only half as
        BIC     r3, r3,#1                               ;   frequent as Y lines and are referenced
                                                        ;   by the 16Base coord (ie first line is 0,
                                                        ;   second line is 2, third is 4 etc)
        ORR     r3, r3,#(2 << 13)                       ; C1 type code
        LDR     r4, = ((1 << 15) - 1)
        BL      huff_findline
        BVS     gb_returnerr

        BL      huff_savevarsC1


        ; --- initialise the C2 component vars ---

        ; initialise bit buffer and pointer
        MOV     r8, #0                                  ; bit buffer
        MOV     r9, #0                                  ; bit ptr
        ADR     r10, cd_sectorbuffers
        ADD     r10, r10,#gb_C2huff_sectbufend          ; set sector buffer ptr to end
                                                        ; (as though it was empty)
        MOV     r11, #0                                 ; sector buffer bytes left

        ; point file pointer at this sector
        MOV     r0, #1
        ; r1 still valid from above
        MOV     r2, r5,ASL#11                           ; convert sectors to bytes
        SWI     XOS_Args
        BVS     hs16_exit

        ; find the start of the first line
        LDR     r3, gb_y0
        BIC     r3, r3,#1
        ORR     r3, r3,#(3 << 13)                       ; C2 type code
        LDR     r4, = ((1 << 15) - 1)
        BL      huff_findline
        BVS     gb_returnerr

        BL      huff_savevarsC2


hs16_exit
        LDMFD   sp!, {r0, r2-r11, pc}



;-----------------------------------------------------------------------------------



huff_findline

; For 4Base and 16Base images
; Searches the huffman data for the start of the line we want
;
; On Entry
;    r1 = file handle
;    r3 = line code we're after
;    r4 = line code mask
;         The line codes consist of:
;           4Base:  15-bit line no.
;          16Base:  2 type bits, 1 zero bit, 12-bit line number
;                   (type bits: Y = 0; C1 = 2; C2 = 3)
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count
;
; On Exit
;    r1 = file handle
;    C set on exit if couldn't find line

        STMFD   sp!, {r2-r5, lr}

        MOV     r5, #(2048+64)                          ; a max loop count so we don't get
                                                        ; stuck in an infinite loop
hfl4_loop
        BL      huff_findlinestart
        BVS     hfl4_bad                                ; something wrong, return 'fault'

        AND     r2, r2,r4                               ; mask out what we want
        CMP     r2, r3
        BEQ     hfl4_exit                               ; line found!

        SUBS    r5, r5,#1                               ; dec max loop count
        BGT     hfl4_loop

        ; exceed max loop count - something must've gone wrong
hfl4_bad
        LDMFD   sp!, {r2-r5, lr}
        ORRS    pc, lr,#Carry_flag                      ; set C

hfl4_exit
        ADDS    r0, r0,#0                               ; clear C
        LDMFD   sp!, {r2-r5, pc}



        LTORG


;-----------------------------------------------------------------------------------


huff_readextracodetable

; Called after 'huff_readcodetable' to read an additional
; (ie C1 and C2) huffman code table
;
; On Entry
;    r6 = pointer to code table to fill (Y or C1 or C2)

        STMFD   sp!, {lr}

        B       hrct_entry2



;-----------------------------------------------------------------------------------



huff_readcodetable

; Read in the huffman code table
;
; On Entry
;    r2 = sector offset of table
;    r6 = pointer to code table to fill (Y or C1 or C2)
;
; On Exit
;    r7 = table size


        STMFD   sp!, {lr}

        ; point file-pointer to stored code table
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        MOV     r2, r2,ASL#11                           ; convert sectors to bytes
        SWI     XOS_Args
        BVS     hrct_exit

hrct_entry2
        ; read number of entries
        SWI     XOS_BGet
        ;BCS    ???

        ADD     r7, r0,#1                               ; number of entries in table
        MOV     r5, r7

hrct_loop
        ; read code bit length
        SWI     XOS_BGet
        ADD     r2, r0,#1

        SWI     XOS_BGet
        MOV     r3, r0,LSL#8
        SWI     XOS_BGet
        ORR     r3, r3,r0

        RSB     r8, r2,#16                              ; amount of shift to get code to least sig bits
        MOV     r3, r3,LSR r8                           ; shift code down
        STR     r3, [r6],#4                             ; store code bits (in hct_code)

        STR     r2, [r6],#4                             ; store code length (in hct_len)

        ; read value corresponding to huffman code
        SWI     XOS_BGet
        MOV     r0, r0,LSL#24                           ; convert signed byte to signed word
        MOV     r0, r0,ASR#24
        STR     r0, [r6],#4                             ; store value in hct_val

        SUBS    r5, r5,#1
        BGT     hrct_loop


        ADDS    r0, r0,#0                               ; clear V
hrct_exit
        LDMFD   sp!, {pc}



;-----------------------------------------------------------------------------------



huff_findlinesector

; Find the sector offset of the sector containing the
; start of the huffman data for a particular line
;
; On Entry
;    r2 = sector offset of line offset table
;    r3 = line number (entry) we are looking for
;
; On Exit
;    r2 = sector offset to start looking for line data
;    r3 = next table entry (used for 16Base images)


        STMFD   sp!, {r0, lr}

        ; point file-pointer to stored code table
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        MOV     r2, r2,ASL#11                           ; convert sectors to bytes
        ADD     r2, r2,r3,ASL#1                         ; two bytes per entry
        SWI     XOS_Args
        BVS     hfls_exit

        ; read (two) big-endian 16bit sector offset values

        SWI     XOS_BGet
        MOV     r2, r0,LSL#8
        SWI     XOS_BGet
        ORR     r2, r2,r0

        SWI     XOS_BGet
        MOV     r3, r0,LSL#8
        SWI     XOS_BGet
        ORR     r3, r3,r0

        ADDS    r0, r0,#0                               ; clear V
hfls_exit
        LDMFD   sp!, {r0, pc}^



;-----------------------------------------------------------------------------------



huff_findlinestart

; Find the start of the next line in the huffman data
; by searching for an eol marker (23 '1's followed by a '0')
; Returns the line code stored with the marker.
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count
;
; On Exit
;    r2 = line code found


        STMFD   sp!, {r0-r1,r3-r4, lr}

        LDR     r3, =&fffffe

hfdls_loop
        ; make sure we have enough bits in bitbuffer
        CMP     r9, #24
        BGE     hfdls_check

        BL      huff_loadbyte                           ; insert another byte into bit buffer
        BVS     hfdls_exit

        B       hfdls_loop

hfdls_check
        TEQ     r3, r8,LSR#8                            ; is value in bitbuffer an eol marker?
        BEQ     hfdls_found

        ; no - prepare to try again

hfdls_nextbit
        MOV     r8, r8,LSL#1                            ; shift bit buffer up by one
        SUB     r9, r9,#1
        B       hfdls_loop                              ; try again


hfdls_found
        ; found an eol marker - read the accompanying line code

        ; first, get rid of the eol marker..
        MOV     r8, r8,LSL#24
        SUB     r9, r9,#24

        ; .. and make sure we have enough bits in bitbuffer
hfdls_loop2
        CMP     r9, #16
        BGE     hfdls_readcode

        BL      huff_loadbyte                           ; insert another byte into bit buffer
        BVS     hfdls_exit

        B       hfdls_loop2

hfdls_readcode
        MOV     r2, r8,LSR #17                          ; (line code is a 15bit value
                                                        ; with a '0' on the end)
        MOV     r8, r8,LSL#16
        SUB     r9, r9,#16


        ADDS    r0, r0,#0
hfdls_exit
        LDMFD   sp!, {r0-r1,r3-r4, pc}



        LTORG



;-----------------------------------------------------------------------------------



huff_savevarsY4

; Save the bitbuffer etc vars for the Y component residuals for 4Base decoding
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0-r2, lr}

        ; save the bit buffer and bit pointer
        STR     r8, gbh_bitbufferY4
        STR     r9, gbh_bitptrY4

        ; save the sector buffer ptr and count
        STR     r10, gbh_sectbufptrY4
        STR     r11, gbh_sectbufcountY4

        ; save where we are in file
        MOV     r0, #0
        ;LDR     r1, gb_pcdhandle                        ; get image pac handle
        ;LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        SWI     XOS_Args
        STRVC   r2, gbh_huffptrY4

        LDMFD   sp!, {r0-r2, pc}



;-----------------------------------------------------------------------------------



huff_loadvarsY4

; Reload the bitbuffer etc vars for the Y component residuals for 4Base decoding
;
; On Exit
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0,r2, lr}

        ; restore the bit buffer and bit pointer
        LDR     r8, gbh_bitbufferY4
        LDR     r9, gbh_bitptrY4

        ; restore the sector buffer ptr and count
        LDR     r10, gbh_sectbufptrY4
        LDR     r11, gbh_sectbufcountY4

        ; set file pointer to where we were
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        LDR     r2, gbh_huffptrY4
        SWI     XOS_Args

        LDMFD   sp!, {r0,r2, pc}



;-----------------------------------------------------------------------------------



huff_savevarsY

; Save the bitbuffer etc vars for the Y component residuals for 16Base decoding
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0-r2, lr}

        ; save the bit buffer and bit pointer
        STR     r8, gbh_bitbufferY
        STR     r9, gbh_bitptrY

        ; save the sector buffer ptr and count
        STR     r10, gbh_sectbufptrY
        STR     r11, gbh_sectbufcountY

        ; save where we are in file
        MOV     r0, #0
        ;LDR     r1, gb_pcdhandle                        ; get image pac handle
        ;LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        SWI     XOS_Args
        STRVC   r2, gbh_huffptrY

        LDMFD   sp!, {r0-r2, pc}



;-----------------------------------------------------------------------------------



huff_loadvarsY

; Reload the bitbuffer etc vars for the Y component residuals for 16Base decoding
;
; On Exit
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0,r2, lr}

        ; restore the bit buffer and bit pointer
        LDR     r8, gbh_bitbufferY
        LDR     r9, gbh_bitptrY

        ; restore the sector buffer ptr and count
        LDR     r10, gbh_sectbufptrY
        LDR     r11, gbh_sectbufcountY

        ; set file pointer to where we were
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        LDR     r2, gbh_huffptrY
        SWI     XOS_Args

        LDMFD   sp!, {r0,r2, pc}



;-----------------------------------------------------------------------------------



huff_savevarsC1

; Save the bitbuffer etc vars for the C1 components residuals for 16Base decoding
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


       STMFD   sp!, {r0-r2, lr}

         ; save the bit buffer and bit pointer
        STR     r8, gbh_bitbufferC1
        STR     r9, gbh_bitptrC1

        ; save the sector buffer ptr and count
        STR     r10, gbh_sectbufptrC1
        STR     r11, gbh_sectbufcountC1

        ; save where we are in file
        MOV     r0, #0
        ;LDR     r1, gb_pcdhandle                        ; get image pac handle
        ;LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        SWI     XOS_Args
        STRVC   r2, gbh_huffptrC1

        LDMFD   sp!, {r0-r2, pc}



;-----------------------------------------------------------------------------------



huff_loadvarsC1

; Reload the bitbuffer etc vars for the C1 components residuals for 16Base decoding
;
; On Exit
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0,r2, lr}

         ; restore the bit buffer and bit pointer
        LDR     r8, gbh_bitbufferC1
        LDR     r9, gbh_bitptrC1

        ; restore the sector buffer ptr and count
        LDR     r10, gbh_sectbufptrC1
        LDR     r11, gbh_sectbufcountC1

        ; set file pointer to where we were
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        LDR     r2, gbh_huffptrC1
        SWI     XOS_Args

        LDMFD   sp!, {r0,r2, pc}



;-----------------------------------------------------------------------------------



huff_savevarsC2

; Save the bitbuffer etc vars for the C2 components residuals for 16Base decoding
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0-r2, lr}

        ; save the bit buffer and bit pointer
        STR     r8, gbh_bitbufferC2
        STR     r9, gbh_bitptrC2

        ; save the sector buffer ptr and count
        STR     r10, gbh_sectbufptrC2
        STR     r11, gbh_sectbufcountC2

        ; save where we are in file
        MOV     r0, #0
        ;LDR     r1, gb_pcdhandle                        ; get image pac handle
        ;LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        SWI     XOS_Args
        STRVC   r2, gbh_huffptrC2

        LDMFD   sp!, {r0-r2, pc}



;-----------------------------------------------------------------------------------



huff_loadvarsC2

; Reload the bitbuffer etc vars for the C2 components residuals for 16Base decoding
;
; On Exit
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit ptr
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


        STMFD   sp!, {r0,r2, lr}

        ; restore the bit buffer and bit pointer
        LDR     r8, gbh_bitbufferC2
        LDR     r9, gbh_bitptrC2

        ; restore the sector buffer ptr and count
        LDR     r10, gbh_sectbufptrC2
        LDR     r11, gbh_sectbufcountC2

        ; set file pointer to where we were
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        LDR     r2, gbh_huffptrC2
        SWI     XOS_Args

        LDMFD   sp!, {r0,r2, pc}



;-----------------------------------------------------------------------------------



huff_apply4

; Apply huffman residuals to the values in the
; 'gb_lineoutbuf' buffer

        STMFD   sp!, {r2-r4, r8-r11, lr}

        ; check the 'apply residuals' flag
        LDR     r3, gb_dohuffman
        TEQ     r3, #0
        BEQ     ha4_exit

        LDR     r3, gb_numpixels

        ; check width of image - shouldn't ever happen, but just in case
        ;CMP     r3, #0
        ;LDMLEFD sp!, {r2-r4, r8-r11, pc}^


        BL      huff_loadvarsY4
        BVS     ha4_fault

        LDR     r2, gb_firstpixel                       ; first pixel in (4Base) huffman data
        CMP     r2, #0
        BLE     ha4_doit

        BL      huff_skipY4                             ; skip over the huffman codes for
                                                        ; the pixels up to the LHS one
        BVS     ha4_fault                               ; something wrong - just give up

ha4_doit
        LDR     r2, gb_addr_lineoutbuf                  ; buffer containing our awaiting YCC values

ha4_loop
        BL      huff_getacodeY4                         ; get next huffman code
        BVS     ha4_fault                               ; something wrong - just give up

        LDRB    r4, [r2]                                ; get Y value
        LDR     r0, [r0, #hct_val]                      ; get residual value
        ADDS    r4, r4,r0                               ; add it in
        ; clamp the value to range [0..255]
        MOVLTS  r4, #0
        CMPGE   r4, #255
        MOVGT   r4, #255
        STRB    r4, [r2],#3                             ; store and skip to next Y

        SUBS    r3, r3,#1
        BGT     ha4_loop

        BL      huff_findlinestart                      ; skip to end of line (for next time)
        BL      huff_savevarsY4

ha4_exit
        LDMFD   sp!, {r2-r4, r8-r11, pc}^


ha4_fault
        MOV     r3, #0
        STR     r3, gb_dohuffman                        ; fault has occurred - flag for no more
                                                        ; 'huffman-ing'
        LDMFD   sp!, {r2-r4, r8-r11, pc}^



;-----------------------------------------------------------------------------------


; huff_skip

; Skip a number of huffman codes
;
; On Entry
;    r1 = file handle
;    r2 = number of codes to skip
;    r8 = bit buffer
;    r9 = bit pointer
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count


huff_skipY4
        ; Skip a number of 4Base Y component huffman codes

        STMFD   sp!, {r2, lr}

        CMP     r2, #0
        LDMLEFD sp!, {r2, pc}^

hskipY4_loop
        BL      huff_getacodeY4                         ; get next huffman code
        BVS     hskipY4_exit                            ; something wrong - just give up

        SUBS    r2, r2,#1
        BGT     hskipY4_loop

        ADDS    r0, r0,#0                               ; clear V
hskipY4_exit
        LDMFD   sp!, {r2, pc}


        ;- - - - - - - - - - - - - - - - - - - - - - - -


huff_skipY
        ; Skip a number of 16Base Y component huffman codes

        STMFD   sp!, {r2, lr}

        CMP     r2, #0
        LDMLEFD sp!, {r2, pc}^

hskipY_loop
        BL      huff_getacodeY                          ; get next huffman code
        BVS     hskipY_exit                             ; something wrong - just give up

        SUBS    r2, r2,#1
        BGT     hskipY_loop

        ADDS    r0, r0,#0                               ; clear V
hskipY_exit
        LDMFD   sp!, {r2, pc}


        ;- - - - - - - - - - - - - - - - - - - - - - - -


huff_skipC1
        ; Skip a number of 16Base C1 component huffman codes

        STMFD   sp!, {r2, lr}

        CMP     r2, #0
        LDMLEFD sp!, {r2, pc}^

hskipC1_loop
        BL      huff_getacodeC1                         ; get next huffman code

        BVS     hskipC1_exit                            ; something wrong - just give up

        SUBS    r2, r2,#1
        BGT     hskipC1_loop

        ADDS    r0, r0,#0                               ; clear V
hskipC1_exit
        LDMFD   sp!, {r2, pc}


        ;- - - - - - - - - - - - - - - - - - - - - - - -


huff_skipC2
        ; Skip a number of 16Base C2 component huffman codes

        STMFD   sp!, {r2, lr}

        CMP     r2, #0
        LDMLEFD sp!, {r2, pc}^

hskipC2_loop
        BL      huff_getacodeC2                         ; get next huffman code
        BVS     hskipC2_exit                            ; something wrong - just give up

        SUBS    r2, r2,#1
        BGT     hskipC2_loop

        ADDS    r0, r0,#0                               ; clear V
hskipC2_exit
        LDMFD   sp!, {r2, pc}



;-----------------------------------------------------------------------------------


; huff_getacode

; Get a huffman code
;
; On Entry
;    r1 = file handle
;    r8 = bit buffer
;    r9 = bit pointer
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count
;
; On Exit
;    r0 = code in form of pointer to table entry


huff_getacodeY
        ; get a code from the 16Base Y codetable

        STMFD   sp!, {r2-r6, lr}

        LDR     r6, gb_addr_Ycodetable
        LDR     r2, gb_Ycodetablesize
        B       hgac_loop

        ;- - - - - - - - - - - - - - - - - - - - - - - -

huff_getacodeC1
        ; get a code from the 16Base C1 codetable

        STMFD   sp!, {r2-r6, lr}

        LDR     r6, gb_addr_C1codetable
        LDR     r2, gb_C1codetablesize
        B       hgac_loop

        ;- - - - - - - - - - - - - - - - - - - - - - - -

huff_getacodeC2
        ; get a code from the 16Base C2 codetable

        STMFD   sp!, {r2-r6, lr}

        LDR     r6, gb_addr_C2codetable
        LDR     r2, gb_C2codetablesize
        B       hgac_loop

        ;- - - - - - - - - - - - - - - - - - - - - - - -

huff_getacodeY4
        ; get a code from the 4Base Y codetable

        STMFD   sp!, {r2-r6, lr}

        LDR     r6, gb_addr_Y4codetable
        LDR     r2, gb_Y4codetablesize

        ;- - - - - - - - - - - - - - - - - - - - - - - -


hgac_loop
        ; get code length
        LDR     r5, [r6,#hct_len]

        ; ensure we have at least that many in bit buffer
hgac_ensureloop
        CMP     r9, r5
        BGE     hgac_check

        BL      huff_loadbyte                           ; insert another byte into bit buffer
        LDMVSFD sp!, {r2-r6, pc}

        B       hgac_ensureloop

hgac_check
        LDR     r4, [r6]                                ; get code value
        RSB     r3, r5,#32                              ; shift req to get code down to least sig bits
        TEQ     r4, r8,LSR r3                           ; shift bit buffer down and compare with code from table
        BNE     hgac_trynext                            ; not the same - try the next table entry

        ; a match found!
        MOV     r8, r8,LSL r5                           ; get rid of code from bit buffer
        SUB     r9, r9,r5

        ADDS    r0, r6,#0                               ; clear V (transferring r6->r0 in the process)
        LDMFD   sp!, {r2-r6, pc}                        ; return


hgac_trynext
        ADD     r6, r6,#sizeof_hctentry                 ; step to next entry

        SUBS    r2, r2,#1
        BGT     hgac_loop

        ; no match found
        ; - should never happen, but just in case, return the first entry
        ; in the table (which will probably have a value 0)

        ; - flag a fault condition
        LDMFD   sp!, {r2-r6, lr}
        ORRS    pc, lr,#Overflow_flag                   ; set V



;-----------------------------------------------------------------------------------



huff_loadbyte

; Insert a byte into the bit buffer from an intermediate sector buffer
;
; On Entry
;    r1  = file handle
;    r8  = bit buffer
;    r9  = bit pointer
;    r10 = sector buffer pointer
;    r11 = sector buffer remaining bytes count
;
; On Exit
;    r8-r11 updated

        STMFD   sp!, {r0-r3, lr}

        CMP     r11, #0                                 ; any bytes left in sector buffer?
        BGT     hlb_retbyte


        ; sector buffer is empty, refill it

        SUB     r10, r10,#CDSectorSize                  ; reset ptr to beginning of buffer
        MOV     r11, #CDSectorSize                      ; reset 'bytes left'

        MOV     r0, #4                                  ; read block from current file pointer
        MOV     r2, r10                                 ; set up r10 and r11
        MOV     r3, r11
        SWI     XOS_GBPB
        BVS     hlb_exit
        ; C set if not all bytes transferred, do anything for this?


hlb_retbyte
        LDRB    r0, [r10],#1                            ; retrieve a byte from the sector buffer
        SUB     r11, r11,#1                             ; decrement bytes remaining count
        RSB     r3, r9,#24                              ; calculate shift the for it
        ORR     r8, r8,r0,LSL r3                        ; insert byte into the bitbuffer
        ADDS    r9, r9,#8                               ; update bit ptr
                                                        ; ('S' ensures V cleared for return)

hlb_exit
        LDMFD   sp!, {r0-r3, pc}



;-----------------------------------------------------------------------------------



huff_apply16

; Takes the (up to) 4 lines of 4Base data in the buffer 'gb_addr_4Basebuf'
; and interpolates and applies residuals to generated the 16Base data which
; is then output
;
; On Entry
;    r9 = end of data in the 'gb_addr_4Basebuf' buffer


        STMFD   sp!, {r4,r6-r8,r10-r11, lr}


        LDR     r10, gb_addr_lineoutbufsave             ; 'outbuf1' (gb_lineoutbuf)
        LDR     r11, gb_addr_lineoutbuftmp2             ; 'outbuf2'

        LDR     r8, gb_addr_4Basebuf                    ; get pointer to special buffer
        LDR     r4, gb_rowinc

        LDR     r7, gb_x0
        LDR     r3, gb_x1
        SUB     r3, r3,r7                               ; true 16Base image width


        ; apply the C1 and C2 residuals to the 4Base pixels
        ; (before interpolation)
        LDR     r6, gb_pbdb                             ; retrieve bdb pointer
        LDR     r6, [r6, #bdb_colourformat]             ; colour format (grey/ycc/rgb)
        TEQ     r6, #colour_greyscale                   ; only do it if the C1 and C2 are
        BLNE    huff_apply16_doC1andC2                  ;    actually needed


        LDR     r6, gb_reallinestodo
        CMP     r6, #0                                  ; set up yet?
        BGT     ha16_blockstart


        ; if here, then this is the first time into this routine..

        LDR     r2, gb_y0
        LDR     r6, gb_y1
        SUB     r6, r6,r2
        STR     r6, gb_reallinestodo


        ; get 'row 0' and horizontally interpolate
        ; into 'outbuf1' (gb_lineoutbuf)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_exit

        MOV     r0, r10
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer


        ; if x0 odd, then we need to interp but not display
        ; the first line..
        TST     r7, #1
        BEQ     ha16_blockstarta

        ; x0 was odd, so we have read and process 'row 0'
        ; and use it for interpolating 'row 0+1', but not
        ; actually output it.
        ; (Ie: this bit of code is identical to that starting
        ; at label 'ha16_blockstarta' except that 'row 0'
        ; is not output)


        ; get 'row 1' and horizontally interpolate
        ; into 'outbuf2' (gb_lineoutbuftmp2)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_finish1

        MOV     r0, r11
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer

        ; get 'row 0+1' by interpolating between rows
        LDR     r0, gb_addr_lineoutbuftmp3
        MOV     r1, r10
        MOV     r2, r11
        ; r3 = number of pixels
        BL      gb_interp_row16                         ; r0 = interp r1 & r2

        B       ha16_blockstartb



ha16_blockstart

        ; there will be an interpolation waiting from the last
        ; chunk (because it needs the first line of this chunk)


        ; get 'row 0' and horizontally interpolate
        ; into 'outbuf1' (gb_lineoutbuf)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_finish2

        MOV     r0, r10
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer

        ; get 'row 3+0' by interpolating between rows
        LDR     r0, gb_addr_lineoutbuftmp3
        MOV     r1, r11
        MOV     r2, r10
        ; r3 = number of pixels
        BL      gb_interp_row16                         ; r0 = interp r1 & r2

        ; apply residuals to 'row 3'
        MOV     r2, r11
        BL      huff_apply16_Y

        ; output 'row 3'
        STR     r11, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

        ; apply residuals to 'row 3+0'
        LDR     r2, gb_addr_lineoutbuftmp3
        BL      huff_apply16_Y

        ; output 'row 3+0'
        STR     r2, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit


ha16_blockstarta

        ; get 'row 1' and horizontally interpolate
        ; into 'outbuf2' (gb_lineoutbuftmp2)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_finish1

        MOV     r0, r11
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer

        ; get 'row 0+1' by interpolating between rows
        LDR     r0, gb_addr_lineoutbuftmp3
        MOV     r1, r10
        MOV     r2, r11
        ; r3 = number of pixels
        BL      gb_interp_row16                         ; r0 = interp r1 & r2

        ; apply residuals to 'row 0'
        MOV     r2, r10
        BL      huff_apply16_Y

        ; output 'row 0'
        STR     r10, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

ha16_blockstartb
        ; apply residuals to 'row 0+1'
        LDR     r2, gb_addr_lineoutbuftmp3
        BL      huff_apply16_Y

        ; output 'row 0+1'
        STR     r2, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit


        ; get 'row 2' and horizontally interpolate
        ; into 'outbuf1' (gb_lineoutbuf)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_finish2

        MOV     r0, r10
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer

        ; get 'row 1+2' by interpolating between rows
        LDR     r0, gb_addr_lineoutbuftmp3
        MOV     r1, r11
        MOV     r2, r10
        ; r3 = number of pixels
        BL      gb_interp_row16                         ; r0 = interp r1 & r2

        ; apply residuals to 'row 1'
        MOV     r2, r11
        BL      huff_apply16_Y

        ; output 'row 1'
        STR     r11, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

        ; apply residuals to 'row 1+2'
        LDR     r2, gb_addr_lineoutbuftmp3
        BL      huff_apply16_Y

        ; output 'row 1+2'
        STR     r2, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit


        ; get 'row 3' and horizontally interpolate
        ; into 'outbuf2' (gb_lineoutbuftmp2)

        ; any rows left in 4 line 4Base buffer?
        CMP     r8, r9
        BGE     ha16_finish1

        MOV     r0, r11
        MOV     r1, r8                                  ; buffer of 4Base pixels
        MOV     r2, r7                                  ; x0
        BL      huff_interp_pix16
        ADD     r8, r8,#(3 * x_4Base)                   ; increment special buffer pointer

        ; get 'row 2+3' by interpolating between rows
        LDR     r0, gb_addr_lineoutbuftmp3
        MOV     r1, r10
        MOV     r2, r11
        ; r3 = number of pixels
        BL      gb_interp_row16                         ; r0 = interp r1 & r2

        ; apply residuals to 'row 2'
        MOV     r2, r10
        BL      huff_apply16_Y

        ; output 'row 2'
        STR     r10, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

        ; apply residuals to 'row 2+3'
        LDR     r2, gb_addr_lineoutbuftmp3
        BL      huff_apply16_Y

        ; output 'row 2+3'
        STR     r2, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

        ; we will leave row 3 in 'outbuf2' till the next block
        ; (of 4 lines) is processed - at which stage we can
        ; interpolate the other 16Base line (the one between
        ; row 3 of this block and row 0 of the next block)


ha16_finish2

        ; we branch to here if, when the check is made, we discover
        ; that there won't be anymore lines coming (into 'huff_apply16'),
        ; there is a line of values waiting in 'outbuf2' (r11)

        MOV     r10, r11                                ; put 'outbuf2' in the 'outbuf1' pointer
                                                        ; so that this one gets output instead
        ; fall through to 'proper' finish routine

ha16_finish1

        ; check the lines-to-do (4Base) value - if there are
        ; no more left, we should tidy up by outputting any
        ; lines that are waiting (should be no more than 2)
        ; before returning

        LDR     r0, [sp, #4]                            ; 2nd item on stack (should be entry-r6)
        CMP     r0, #0
        BGT     ha16_exit                               ; there are more to do, so safe to exit

        CMP     r6, #1                                  ; there are no '16Base' rows to do either
        BLT     ha16_exit                               ; ..so exit

        BEQ     ha16_finish_doline
        ; there are two (16Base) lines left to do, so we need to make
        ; a copy of the row so we can apply the last-line residuals to
        ; it before it's outputted.

        LDR     r0, gb_addr_lineoutbuftmp3              ; destination ('outbuf3')
        MOV     r1, r3                                  ; number of triplets
        copybuffer3x   r0,r10,r1


ha16_finish_doline
        ; apply residuals to waiting row
        MOV     r2, r10
        BL      huff_apply16_Y

        ; output waiting row
        STR     r10, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUBS    r6, r6,#1                               ; decrement 'reallinestodo'
        BLE     ha16_exit

        ; if here, then r6 ('reallinestodo') is still > 0
        ; the only way this could happen, is if we are at the
        ; last physical row of the image

        ; apply residuals to last row again (it has been copied to outbuf3)
        LDR     r2, gb_addr_lineoutbuftmp3
        ; r3 = number of pixels
        BL      huff_apply16_Y

        ; output waiting row
        STR     r2, gb_addr_lineoutbuf
        BL      gb_outputrow
        ADD     r5, r5,r4                               ; increment out pointer to start of next row
        SUB     r6, r6,#1                               ; decrement 'reallinestodo'


ha16_exit
        STR     r6, gb_reallinestodo

        ADDS    r0, r0,#0                               ; clear V
        LDMFD   sp!, {r4,r6-r8,r10-r11, pc}



;-----------------------------------------------------------------------------------



huff_interp_pix16

        ; r0 = buffer for the interpolated 16Base pixels
        ; r1 = buffer containing a line of 24bit 4Base pixels

        ; Note: only the correct number of 16Base pixels (ie y1-y0)
        ; are interpolated and copied into the buffer at r0.
        ; Ie. we may have to drop a pixel at the start or at the end.

        ; r2 = x0 (16Base)
        ; r3 = number of 16Base pixels we should end up with


        STMFD   sp!, {r1-r10, lr}

        LDRB    r4, [r1],#1                             ; read the first pixel
        LDRB    r5, [r1],#1
        LDRB    r6, [r1],#1

        RSB     r10, r2,#x_16Base                       ; pixels left till we hit RH edge of image

        ; if y0 is odd, we have to skip the first pixel
        TST     r2, #1
        BNE     hip16_loopa                             ; odd - skip the first pixel


hip16_loop

        STRB    r4, [r0],#1                             ; store the first pixel
        STRB    r5, [r0],#1
        STRB    r6, [r0],#1

        SUBS    r3, r3,#1                               ; decrement 'pixels left'
        BLE     hip16_exit                              ; none left - exit


hip16_loopa

        SUBS    r10, r10,#1                             ; decrement pixels-before-RHS
        BEQ     hip16_store2                            ; if we are on last pixel, then we can't
                                                        ; interpolate with the next pixel so just repeat it

        LDRB    r7, [r1],#1                             ; read the next pixel
        LDRB    r8, [r1],#1
        LDRB    r9, [r1],#1

        ; average first component
        ADD     r4, r4,r7
        MOVS    r4, r4,ASR#1
        ADDCS   r4, r4,#1

        ; average second component
        ADD     r5, r5,r8
        MOVS    r5, r5,ASR#1
        ADDCS   r5, r5,#1

        ; average third component
        ADD     r6, r6,r9
        MOVS    r6, r6,ASR#1
        ADDCS   r6, r6,#1

hip16_store2
        STRB    r4, [r0],#1                             ; store the interpolated component 1
        STRB    r5, [r0],#1                             ; store the interpolated component 2
        STRB    r6, [r0],#1                             ; store the interpolated component 3

        MOV     r4, r7                                  ; current = next
        MOV     r5, r8
        MOV     r6, r9


        SUB     r10, r10,#1                             ; decrement pixels-before-RHS

        SUBS    r3, r3,#1                               ; decrement count
        BGT     hip16_loop                              ; if count > 0 loop again


hip16_exit
        LDMFD   sp!, {r1-r10, pc}^



;-----------------------------------------------------------------------------------



gb_interp_row16
        ; create a row (at r0) that consists of pixels interpolated
        ; from the pixels in the rows pointed to by r1 and r2
        ; r3 = number of (24bit) pixels to do

        STMFD   sp!, {r3-r5, lr}

gbir16_loop
        LDRB    r4, [r1],#1
        LDRB    r5, [r2],#1

        ADD     r4, r4,r5                               ; average the two values
        MOVS    r4, r4,ASR#1
        ADDCS   r4, r4,#1

        STRB    r4, [r0],#1                             ; store the interpolated value


        LDRB    r4, [r1],#1
        LDRB    r5, [r2],#1

        ADD     r4, r4,r5                               ; average the two values
        MOVS    r4, r4,ASR#1
        ADDCS   r4, r4,#1

        STRB    r4, [r0],#1                             ; store the interpolated value


        LDRB    r4, [r1],#1
        LDRB    r5, [r2],#1

        ADD     r4, r4,r5                               ; average the two values
        MOVS    r4, r4,ASR#1
        ADDCS   r4, r4,#1

        STRB    r4, [r0],#1                             ; store the interpolated value


        SUBS    r3, r3,#1                               ; decrement count
        BGT     gbir16_loop                             ; if count > 0 loop again

        LDMFD   sp!, {r3-r5, pc}^



;-----------------------------------------------------------------------------------



huff_apply16_Y

; apply the luma values to values in the buffer at r0
;
; On Entry
;    r2 = buffer to apply luma residuals to
;         (note: buffer contains YCC triplets so we have
;          to apply the residuals to every third value)
;    r3 = number of pixels to do


        STMFD   sp!, {r2-r11, lr}

        ; check the 'apply residuals' flag
        LDR     r4, gb_dohuffman
        TEQ     r4, #0
        BEQ     ha16y_exit


        BL      huff_loadvarsY
        BVS     ha16y_fault

        MOV     r4, r2                                  ; temporary save of buffer address

        LDR     r2, gb_x0                               ; first pixel in (16Base) row
        CMP     r2, #0
        BLE     ha16y_doit

        BL      huff_skipY                              ; skip over the huffman codes for
                                                        ; the pixels up to the L/H one
        BVS     ha16y_fault                             ; something wrong - just give up

ha16y_doit
        MOV     r2, r4                                  ; recover buffer address

ha16y_loop
        BL      huff_getacodeY                          ; get next huffman code
        BVS     ha16y_fault                             ; something wrong - just give up

        LDRB    r4, [r2]                                ; get Y value
        LDR     r0, [r0, #hct_val]                      ; get residual value
        ADDS    r4, r4,r0                               ; add it in
        ; clamp the value to range [0..255]
        MOVLTS  r4, #0
        CMPGE   r4, #255
        MOVGT   r4, #255
        STRB    r4, [r2],#3                             ; store and skip to next Y

        SUBS    r3, r3,#1
        BGT     ha16y_loop

        ;--- find the start of the first line
        ; we make an assumption here (and also for the C1 and C2
        ; equivalent routines) that the next line start with a
        ; 'Y' type code (0) indicates the start of the next line
        ; of 'Y' residuals (ie it is assumed that lines are stored
        ; in increasing order of their row numbers).  This should
        ; be quite safe as it would be a pretty screwy file that
        ; didn't follow this pattern.  The original C code makes
        ; a similar (but slightly less rigorous) assumption.
        MOV r3, #(0 << 13)                               ; 0 = type code for a 'Y' line
        LDR r4, = (7 << 12)
        BL      huff_findline
        BL      huff_savevarsY

ha16y_exit
        LDMFD   sp!, {r2-r11, pc}^

ha16y_fault
        MOV     r2, #0
        STR     r2, gb_dohuffman                        ; fault has occurred - flag for no more
                                                        ; 'huffman-ing'
        LDMFD   sp!, {r2-r11, pc}^



;-----------------------------------------------------------------------------------



huff_apply16_doC1andC2

; apply the C1 and C2 residuals to the 4Base data before
; it is interpolated to give 16Base-resolution data
;
; On entry
;    r8 = pointer to first line of block of 4Base data
;    r9 = pointer to end of block


        STMFD   sp!, {lr}

        MOV     r2, r8

ha16dc_loop
        CMP     r2, r9
        BGE     ha16dc_exit

        BL      huff_apply16_C1                         ; apply the C1 residuals
        BL      huff_apply16_C2                         ; apply the C2 residuals

        ADD     r2, r2,#(3 * x_4Base)                   ; increment special buffer pointer

        B       ha16dc_loop

ha16dc_exit
        LDMFD   sp!, {pc}^



;-----------------------------------------------------------------------------------



huff_apply16_C1

; apply the chroma-1 values to values in the buffer at r0
;
; On Entry
;    r2 = buffer to apply chroma-1 residuals to
;         (note: buffer contains YCC triplets so we have
;          to apply the residuals to every third value)


        STMFD   sp!, {r2-r11, lr}

        ; check the 'apply residuals' flag
        LDR     r4, gb_dohuffman
        TEQ     r4, #0
        BEQ     ha16c1_exit


        BL      huff_loadvarsC1
        BVS     ha16c1_fault

        MOV     r4, r2                                  ; temporary save of buffer address

        LDR     r2, gb_firstpixel                       ; first pixel in (4Base) row
        CMP     r2, #0
        BLE     ha16c1_doit

        BL      huff_skipC1                             ; skip over the huffman codes for
                                                        ; the pixels up to the L/H one
        BVS     ha16c1_fault                            ; something wrong - just give up

ha16c1_doit
        ADD     r2, r4,#1                               ; recover buffer address
                                                        ; (first C1 is at second byte)
        LDR     r3, gb_numpixels

ha16c1_loop
        BL      huff_getacodeC1                         ; get next huffman code
        BVS     ha16c1_fault                            ; something wrong - just give up

        LDRB    r4, [r2]                                ; get C value
        LDR     r0, [r0, #hct_val]                      ; get residual value
        ADDS    r4, r4,r0                               ; add it in
        ; clamp the value to range [0..255]
        MOVLTS  r4, #0
        CMPGE   r4, #255
        MOVGT   r4, #255
        STRB    r4, [r2],#3                             ; store and skip to next Y

        SUBS    r3, r3,#1
        BGT     ha16c1_loop

        ; find the start of the next line
        MOV r3, #(2 << 13)                              ; 2 = type code for a 'C1' line
        LDR r4, = (7 << 12)
        BL      huff_findline

        BL      huff_savevarsC1

ha16c1_exit
        LDMFD   sp!, {r2-r11, pc}^

ha16c1_fault
        MOV     r2, #0
        STR     r2, gb_dohuffman                        ; fault has occurred - flag for no more
                                                        ; 'huffman-ing'
        LDMFD   sp!, {r2-r11, pc}^



;-----------------------------------------------------------------------------------



huff_apply16_C2

; apply the chroma-2 values to values in the buffer at r0
;
; On Entry
;    r2 = buffer to apply chroma-2 residuals to
;         (note: buffer contains YCC triplets so we have
;          to apply the residuals to every third value)


        STMFD   sp!, {r2-r11, lr}

        ; check the 'apply residuals' flag
        LDR     r4, gb_dohuffman
        TEQ     r4, #0
        BEQ     ha16c2_exit


        BL      huff_loadvarsC2
        BVS     ha16c2_fault

        MOV     r4, r2                                  ; temporary save of buffer address

        LDR     r2, gb_firstpixel                       ; first pixel in (4Base) row
        CMP     r2, #0
        BLE     ha16c2_doit

        BL      huff_skipC2                             ; skip over the huffman codes for
                                                        ; the pixels up to the L/H one
        BVS     ha16c2_fault                            ; something wrong - just give up

ha16c2_doit
        ADD     r2, r4,#2                               ; recover buffer address
                                                        ; (first C2 is at third byte)
        LDR     r3, gb_numpixels

ha16c2_loop
        BL      huff_getacodeC2                         ; get next huffman code
        BVS     ha16c2_fault                            ; something wrong - just give up

        LDRB    r4, [r2]                                ; get C value
        LDR     r0, [r0, #hct_val]                      ; get residual value
        ADDS    r4, r4,r0                               ; add it in
        ; clamp the value to range [0..255]
        MOVLTS  r4, #0
        CMPGE   r4, #255
        MOVGT   r4, #255
        STRB    r4, [r2],#3                             ; store and skip to next Y

        SUBS    r3, r3,#1
        BGT     ha16c2_loop

        ; find the start of the next line
        MOV r3, #(3 << 13)                              ; 3 = type code for a 'C2' line
        LDR r4, = (7 << 12)
        BL      huff_findline

        BL      huff_savevarsC2

ha16c2_exit
        LDMFD   sp!, {r2-r11, pc}^

ha16c2_fault
        MOV     r2, #0
        STR     r2, gb_dohuffman                        ; fault has occurred - flag for no more
                                                        ; 'huffman-ing'
        LDMFD   sp!, {r2-r11, pc}^



;-----------------------------------------------------------------------------------


        END
