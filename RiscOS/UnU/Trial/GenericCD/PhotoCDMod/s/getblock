;==========================================
;
;  s.getblock
;
;  Code for SWI PhotoCD_GetBlock and other
;  support routines
;
;  Photo CD support module
;
;  © 1993 Acorn Computers Ltd
;
;  Developed in association with 4Mation
;  Author: Paul LeBeau
;
;==========================================




;-----------------------------------------------------------------------------------
;       SWI PhotoCD_GetBlock
;-----------------------------------------------------------------------------------

; On Entry
;    R0 = PhotoCD handle
;    R1 = thumbnail image number (if this is an Overview Pac)
;    R2 = pointer to PhotoCD Bitmap Data Block
;    R3 = pointer to block of memory for the read bitmap
;    R4 = resolution step
;    R5 = transform
;    R6 = row stride
;    R7 = address of buffer to use for read-ahead caching
;    R8 = size of buffer (or -1 if PhotoCD can assume that
;         the buffer and the data in it are intact from
;         when the last call to PhotoCD_GetBlock returned.
;         This allows for the possibility that the buffer
;         has changed - for example if the buffer is in a
;         C flex block)
;
; On Exit
;    R0-R2 preserved (R0 -> error if error occurred)
;    R3 = buffer size required if that has been requested, otherwise preserved
;    R4-R6 preserved


swi_GetBlock

        STMFD   sp!, {r0-r9, lr}

        ; check that handle is valid

        BL      CheckPCDhandle
        BCC     gb_handleok                             ; handle is ok

        addr    r0, BadHandle_errormsg                  ; return 'bad handle' error
gb_lookuperr
        BL      ErrorLookup
gb_returnerr
        STR     r0, [sp]
        LDMFD   sp!, {r0-r9, pc}


gb_handleok

        STR     r0, gb_pcdhandle
        STR     r2, gb_pbdb                             ; preserve pbdb pointer
        STR     r4, gb_resstep                          ; preserve resolution step
        STR     r6, gb_stride                           ; preserve row stride


        [       Switch_ReadAheadBufferEnabled
        STR     r7, gb_ubufstart                        ; store buffer address

        CMP     r8, #-1                                 ; r8 = -1
        BNE     gb_firstuse
        ; if EQ, then we are requested to reuse the buffer
        ; - first check that buffer has been previously used

        LDR     r1, gb_ubufsize
        TEQ     r1, #0
        BEQ     gb_badubuf                              ; hasn't been used - tell user he's an idiot

        STR     r8, gb_ubufusedagain                    ; use of buffer is continued from last call
        LDR     r8, gb_ubufsize                         ; get old size ready for memory check
        B       gb_ubufcheck


gb_firstuse
        STR     r8, gb_ubufsize                         ; store buffer's size
        STR     r7, gb_ubufend                          ; amount of valid data in buffer
        STR     r7, gb_ubufptr
        MOV     r1, #0                                  ; indicate this is new buffer
        STR     r1, gb_ubufusedagain


gb_ubufcheck
        MOV     r1, r7
        MOVS    r2, r8
        BEQ     gb_ubufok                               ; don't do memory test if buffer not being used
        BL      CheckAddress
        BCS     gb_badubuf

gb_ubufok
        ]


        ; check the buffer address passed in
        ; (can only check the start address - don't know end address)
        MOV     r1, r3
        MOV     r2, #0
        BL      CheckAddress
        addr    r0, BadBuff_errormsg, "CS"
        BCS     gb_lookuperr


        ; retrieve r1 & r2
        LDR     r1, [sp, #4]
        LDR     r2, [sp, #8]


        ; setting up for output (and check colour format values etc)
        BL      gb_outputsetup
        STRVS   r0, [sp]                                ; if bad format, return error
        LDMVSFD sp!, {r0-r9, pc}


        ; convert transform value to internal form (gets checked at same time)
        MOV     r0, r5
        BL      ConvXformExtToInt                       ; convert external transform value to internal form
        STRVS   r0, [sp]                                ; if bad value, return error
        LDMVSFD sp!, {r0-r9, pc}
        MOV     r5, r0


        ; get Pac type (ie. Overview or Image)
        LDR     r0, gb_pcdhandle                        ; retrieve handle
        LDR     r7, [r0, #pcd_pacno]

        CMP     r7, #0                                  ; is Pac an Image Pac?
        BNE     gb_imgpac

        ;- - - - - - - - - - - - - - - - - - - - - - - -

gb_ovwpac
        ; Pac is an Overview Pac - check the thumbnail number in R1
        BL      CheckThumbNo
        STRVS   r0, [sp]                                ; if bad no, return error
        LDMVSFD sp!, {r0-r9, pc}

        ; check resolution step
        CMP     r4, #step_Base64
        BLT     gb_badresol
        CMP     r4, #step_Base16
        BGT     gb_badresol

        ; calculate file position of image data
        ; sector = 5 + (thumbnail_no - 1) * 18
        SUB     r1, r1,#1                              ; thumbnail_no - 1
        MOV     r1, r1,ASL#1                           ; times 18
        ADD     r1, r1,r1,ASL#3
        ADD     r1, r1,#5                              ; plus 5
        ; convert sectors to bytes
        MOV     r1, r1,ASL#11                          ; *2048 (bytes per sector)
        STR     r1, gb_fileptr

        B       gb_imagesize


        ;- - - - - - - - - - - - - - - - - - - - - - - -

ImagePacOffsets
        ; sector offsets of the start of image data for each resolution

        DCD     sector_Base16                          ; (Base64 used Base16 data)
        DCD     sector_Base16
        DCD     sector_Base4
        DCD     sector_Base
        DCD     0
        DCD     0

        ;- - - - - - - - - - - - - - - - - - - - - - - -


gb_imgpac
        ; check resolution step
        [       Switch_AllowBase64forIPacs
        CMP     r4, #step_Base64
        |
        CMP     r4, #step_Base16
        ]
        BLT     gb_badresol
        LDR     r1, [r0, #pcd_maxstep]                  ; max resolution available for this Image Pac
        CMP     r4, r1
        BGT     gb_badresol

        CMP     r4, #step_Base                          ; if step = 4Base or 16Base then..
        MOVGT   r7, #step_Base                          ;   fileptr = Base (these two highest resolutions
                                                        ;   are derived from the 'Base' image)
        MOVLE   r7, r4

        ; calculate file position of image data
        ADR     r1, ImagePacOffsets
        LDR     r1, [r1, r7,ASL#2]
        MOV     r1, r1,ASL#11                           ; convert sectors to number of bytes
        STR     r1, gb_fileptr


        ;- - - - - - - - - - - - - - - - - - - - - - - -


gb_imagesize

        addr    r7, ResXtable
        LDR     r7, [r7, r4,ASL#2]                      ; get picture width
        addr    r8, ResYtable
        LDR     r8, [r8, r4,ASL#2]                      ; get picture height

        STR     r7, gb_twidth                           ; keep in workspace
        STR     r8, gb_theight

        TEQ     r4, #step_Base64                        ; special case for half-size thumbnail
        MOVEQ   r7, r7,ASL#1                            ; physical image size is same as Base16
        MOVEQ   r8, r8,ASL#1

        STR     r7, gb_iwidth                           ; keep in workspace
        STR     r8, gb_iheight

        ; retrieve actual width/height
        ; Z should still be set if resolution = Base64
        MOVEQ   r7, r7,ASR#1
        MOVEQ   r8, r8,ASR#1

        ; portrait or landscape?
        TST     r5, #1                                  ; odd number of 90 degree rotations
        MOVNE   r0, r7
        MOVNE   r7, r8
        MOVNE   r8, r0

        ; r7 = max x (transformed)
        ; r8 = max y (transformed)


        ; check that coords are ok
        [ Switch_RiscOsStyleCoords

        LDR     r0, [r2, #bdb_left]
        LDR     r11, [r2, #bdb_bottom]
        LDR     r3, [r2, #bdb_right]
        LDR     r1, [r2, #bdb_top]
        ; up-end the Y coords
        SUB     r1, r8,r1
        SUB     r11, r8,r11
        ; coords are now in PhotoCD format (relative to the top left)

        |
        LDR     r0, [r2, #bdb_left]
        LDR     r1, [r2, #bdb_top]
        LDR     r3, [r2, #bdb_right]
        LDR     r11, [r2, #bdb_bottom]
        ]

        ; r0  = oleft
        ; r1  = otop
        ; r3  = oright
        ; r11 = obottom
        ; coords should now be in PhotoCD style coord values
        ; ie relative to top left

        ; check for special input case where all coords are zero (read whole image)
        TEQ     r0, #0
        TEQEQ   r1, #0
        TEQEQ   r3, #0
        TEQEQ   r11, #0
        MOVEQ   r3, r7                                  ; 'right' = max x
        MOVEQ   r11, r8                                 ; 'bottom' = max y
        MOVEQ   r9, r7                                  ; width = max x
        MOVEQ   r10, r8                                 ; height = max y
        BEQ     gb_store_wandh

gb_propertest
        CMP     r0, #0                                  ; oleft < 0?
        BLT     gb_badcoords
        CMP     r0, r7                                  ; or oleft >= owidth?
        BGE     gb_badcoords

        CMP     r3, r0                                  ; oright < oleft?
        BLT     gb_badcoords
        CMP     r3, r7                                  ; or oright > owidth?
        BGT     gb_badcoords

        CMP     r1, #0                                  ; otop < 0?
        BLT     gb_badcoords
        CMP     r1, r8                                  ; or otop >= oheight?
        BGE     gb_badcoords

        CMP     r11, r1                                 ; obottom < otop?
        BLT     gb_badcoords
        CMP     r11, r8                                 ; or obottom > oheight?
        BGT     gb_badcoords

        ; recalculate the actual image width and height

        SUB     r9, r3,r0                               ; owidth = oright-oleft
        SUB     r10, r11,r1                             ; oheight = obottom-otop

gb_store_wandh
        STR     r9, gb_owidth                           ; keep in workspace
        STR     r10, gb_oheight

        ; update coords in bdb for return to user

        LDR     lr, [r2, #bdb_flags]
        TST     lr, #bdbflag_updatecoords               ; test the 'update coords' flag
        MOVNE   lr, #0
        [ Switch_RiscOsStyleCoords
        STRNE   lr, [r2, #bdb_left]
        STRNE   lr, [r2, #bdb_bottom]
        STRNE   r9, [r2, #bdb_right]
        STRNE   r10, [r2, #bdb_top]
        |
        STRNE   lr, [r2, #bdb_left]
        STRNE   lr, [r2, #bdb_top]
        STRNE   r9, [r2, #bdb_right]
        STRNE   r10, [r2, #bdb_bottom]
        ]

        ; check whether a zero-width or zero-height image was requested!
        CMP     r9, #0
        CMPNE   r10, #0
        LDMEQFD sp!, {r0-r9, pc}^                       ; return successful (we did what was asked!)


        ; handle stride passed = 0
        ; (this causes a stride equal to the image width to be used)

        LDR     r6, gb_stride
        TEQ     r6, #0
        BNE     gb_strideok

        ; value was 0 - use swi PhotoCD_GetBytesPerRow
        ; to calculate a suitable value
        STMFD   sp!, {r0-r1}
        LDR     r0, gb_owidth                           ; output width in pixels
        LDR     r1, gb_pbdb
        SWI     XPhotoCD_GetBytesPerRow
        ADDVS   sp, sp,#8
        STRVS   r0, [sp]
        LDMVSFD sp!, {r0-r9, pc}

        STR     r0, gb_stride                           ; store it for routines to use
        LDMFD   sp!, {r0-r1}

gb_strideok


        ; calculate some transform-dependent values 

        LDR     lr, [r2, #bdb_columnoffset]             ; column offset
        LDR     r6, gb_stride                           ; stride

        SUB     r4, r9,#1
        MUL     r4, lr,r4                               ; r4 = offset of upper right of image

        SUB     r7, r10,#1
        MUL     r7, r6,r7                               ; r7 = offset of lower left of image

        TST     r5, #xform_Mirror                       ; transform includes a mirror operation?
        BIC     r5, r5,#xform_Mirror                    ; r5 = rotation
        BNE     gb_mirroredxforms

        ;non-mirrored transforms

        TEQ     r5, #0
        BNE     gb_rot90

        MOV     r9, #0                                  ; out = upper left
        STR     lr, gb_colinc                           ; colinc = columnoff
        STR     r6, gb_rowinc                           ; rowinc = stride
        STR     r1, gb_y0                               ; y0 = otop
        STR     r11, gb_y1                              ; y1 = obottom
        STR     r0, gb_x0                               ; x0 = oleft
        STR     r3, gb_x1                               ; x1 = oright
        B       gb_xvarsdone

gb_rot90
        TEQ     r5, #1
        BNE     gb_rot180

        MOV     r9, r7                                  ; out = lower left
        RSB     r8, r6,#0
        STR     r8, gb_colinc                           ; colinc = -stride
        STR     lr, gb_rowinc                           ; rowinc = columnoff
        STR     r0, gb_y0                               ; y0 = oleft
        STR     r3, gb_y1                               ; y1 = oright
        STR     r11, gb_x0                              ; x0 = obottom
        STR     r1, gb_x1                               ; x1 = otop
        B       gb_xvarsdone

gb_rot180
        TEQ     r5, #2
        BNE     gb_rot270

        ADD     r9, r4,r7                               ; out = lower right (lower left + upper right)
        RSB     r8, lr,#0
        STR     r8, gb_colinc                           ; colinc = -columnoff
        RSB     r8, r6,#0
        STR     r8, gb_rowinc                           ; rowinc = -stride
        STR     r11, gb_y0                              ; y0 = obottom
        STR     r1, gb_y1                               ; y1 = otop
        STR     r3, gb_x0                               ; x0 = oright
        STR     r0, gb_x1                               ; x1 = oleft
        B       gb_xvarsdone

gb_rot270
        ; must be a rotate by 270 degrees

        MOV     r9, r4                                  ; out = upper right
        STR     r6, gb_colinc                           ; colinc = stride
        RSB     r8, lr,#0
        STR     r8, gb_rowinc                           ; rowinc = -columnoff
        STR     r3, gb_y0                               ; y0 = oright
        STR     r0, gb_y1                               ; y1 = oleft
        STR     r1, gb_x0                               ; x0 = otop
        STR     r11, gb_x1                              ; x1 = obottom
        B       gb_xvarsdone


gb_mirroredxforms

        ;transforms that include a mirror

        TEQ     r5, #0
        BNE     gb_mir90

        MOV     r9, r4                                  ; out = upper right
        RSB     r8, lr,#0
        STR     r8, gb_colinc                           ; colinc = -columnoff
        STR     r6, gb_rowinc                           ; rowinc = stride
        STR     r1, gb_y0                               ; y0 = otop
        STR     r11, gb_y1                              ; y1 = obottom
        STR     r3, gb_x0                               ; x0 = oright
        STR     r0, gb_x1                               ; x1 = oleft
        B       gb_xvarsdone

gb_mir90
        TEQ     r5, #1
        BNE     gb_mir180

        MOV     r9, #0                                  ; out = upper left
        STR     r6, gb_colinc                           ; colinc = stride
        STR     lr, gb_rowinc                           ; rowinc = columnoff
        STR     r0, gb_y0                               ; y0 = oleft
        STR     r3, gb_y1                               ; y1 = oright
        STR     r1, gb_x0                               ; x0 = otop
        STR     r11, gb_x1                              ; x1 = obottom
        B       gb_xvarsdone

gb_mir180
        TEQ     r5, #2
        BNE     gb_mir270

        MOV     r9, r7                                  ; out = lower left
        STR     lr, gb_colinc                           ; colinc = columnoff
        RSB     r8, r6,#0
        STR     r8, gb_rowinc                           ; rowinc = -stride
        STR     r11, gb_y0                              ; y0 = obottom
        STR     r1, gb_y1                               ; y1 = otop
        STR     r0, gb_x0                               ; x0 = oleft
        STR     r3, gb_x1                               ; x1 = oright
        B       gb_xvarsdone

gb_mir270
        ; must be a mirror + rotate by 270 degrees

        ADD     r9, r4,r7                               ; out = lower right (lower left + upper right)
        RSB     r8, r6,#0
        STR     r8, gb_colinc                           ; colinc = -stride
        RSB     r8, lr,#0
        STR     r8, gb_rowinc                           ; rowinc = -columnoff
        STR     r3, gb_y0                               ; y0 = oright
        STR     r0, gb_y1                               ; y1 = oleft
        STR     r11, gb_x0                              ; x0 = obottom
        STR     r1, gb_x1                               ; x1 = otop



gb_xvarsdone

        ; actual start output address = user buffer + offset
        LDR     r5, [sp, #12]                           ; retrieve user buffer address
        ADD     r5, r5,r9

        ; ensure x0<x1 and y0<y1 after coord shuffle done above
        ADR     r1, gb_y0
        LDMIA   r1, {r8-r11}
        CMP     r8, r9                                  ; y0 > y1?
        LDRGT   r7, gb_theight                          ; actual full height of image
        SUBGT   r8, r7,r8
        SUBGT   r9, r7,r9
        CMP     r10, r11                                ; x0 > x1?
        LDRGT   r7, gb_twidth                           ; actual full width of image
        SUBGT   r10, r7,r10
        SUBGT   r11, r7,r11
        STMIA   r1, {r8-r11}                            ; rewrite


        ; set up line buffer component pointers

        ADR     r1, gb_bufY1
        LDR     r7, gb_iwidth
        ADR     r2, cd_sectorbuffers
        ADD     r2, r2,#sizeof_sectorbuffers            ; address of buffer 'gb_linebuffer'

        STR     r2, [r1],#4                             ; store pointer to bufY1
        ADD     r4, r2,r7
        STR     r4, [r1],#4                             ; store pointer to bufY2
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to bufC1
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to bufC2
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to buf2Y1
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2Y2
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2C1
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1]                                ; store pointer to buf2C2

        ADD     r4, r4,r7,ASR#1
        STR     r4, gb_addr_lineoutbuf                  ; store pointer to gb_lineoutbuf


        ; from this point on reading routines are resolution step dependent

        LDR     r4, gb_resstep                          ; retrieve resolution step
        TEQ     r4, #step_Base64                        ; half-size thumbnail?
        BEQ     gb_read_base64

        CMP     r4, #step_4Base                         ; 4Base image?
        BEQ     gb_read_4Base
        BGT     gb_read_16Base                          ; >4Base? - then is a 16Base image

        ; otherwise is just a plain YYCC image
        B       gb_read_normal



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


        ; Generate bad resolution step error message

gb_badresol
        addr    r0, BadResol_errormsg
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r9, pc}


        ;- - - - - - - - - - - - - - - - - - - - - - - -


        ; Generate bad resolution step error message

gb_badcoords
        ADR     r0, BadCoords_errormsg
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r9, pc}



        ;- - - - - - - - - - - - - - - - - - - - - - - -


        ; Generate bad user-buffer error message

gb_badubuf
        ADR     r0, BadUBuf_errormsg
        BL      ErrorLookup
        STR     r0, [sp]
        LDMFD   sp!, {r0-r9, pc}



;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadCoords_errormsg    Error PhotoCD_Err_chunk+15, "PCDBadCoords"
BadUBuf_errormsg      Error PhotoCD_Err_chunk+19, "PCDBadUBuf"



;-----------------------------------------------------------------------------------
;       Image reading/decoding routines for SWI PhotoCD_GetBlock
;-----------------------------------------------------------------------------------


;===================================================================================
;       Read a Base/64 image
;===================================================================================


gb_read_base64
        ; r2 = bufY1
        ; r4 = resolution step
        ; r5 = output pointer
        ; r7 = iwidth
        ; r8-r11 = y0,y1,x0,x1


        SUB     r6, r9,r8                               ; lines to read

        SUB     r0, r11,r10                             ; number of pixels that need to be done
        STR     r0, gb_numpixels                        ;    in each row

 ;disp_reg r8, "y0", "I"
 ;disp_reg r9, "y1", "I"
 ;disp_reg r10, "x0", "I"
 ;disp_reg r11, "x1", "I"
 ;disp_reg r6, "linestodo", "I"
 ;disp_reg r2, "bufY1"
 ;disp_reg r5, "out"
 ;disp_reg r7, "iwidth", "I"

        ; set file pointer to correct place
        ADD     r1, r7,r7,ASL#1                         ; (iwidth * 3)
        LDR     r2, gb_fileptr
        MLA     r2, r1,r8,r2                            ; add in offset to start of line y0
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        SWI     XOS_Args
        BVS     gb_returnerr

        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_setup
        ]


        ; calculate initial x read positions within line buffers
        LDR     r0, gb_bufY1
        ADD     r0, r0,r10,ASL#1                        ; yp1  -  lumanance ptr 1
        STR     r0, gb_yp1

        LDR     r0, gb_bufY2
        ADD     r0, r0,r10,ASL#1                        ; yp2  -  lumanance ptr 2
        STR     r0, gb_yp2

        LDR     r0, gb_bufC1
        ADD     r0, r0,r10                              ; c1p  -  chrominance 1 ptr
        STR     r0, gb_c1p

        LDR     r0, gb_bufC2
        ADD     r0, r0,r10                              ; c2p  -  chrominance 2 ptr
        STR     r0, gb_c2p

gbrb64_yloop
        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_bufY1
        LDR     r3, gb_iwidth
        ADD     r3, r3,r3,ASL#1                         ; * 3  (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?


        ; --- do a row ---

        LDR     r4, gb_numpixels                        ; pixels to do in row

        ; get first x pos to read from in each component line buffer
        LDR     r7, gb_yp1
        LDR     r8, gb_yp2
        LDR     r9, gb_c1p
        LDR     r10, gb_c2p

        LDR     r3, gb_addr_lineoutbuf

gbrb64_xloop
        LDRB    r0, [r7],#1                             ; pixel 1 from first Y row
        LDRB    r1, [r7],#1                             ; pixel 2 from first Y row
        ADD     r0, r0,r1
        LDRB    r1, [r8],#1                             ; pixel 1 from second Y row
        ADD     r0, r0,r1
        LDRB    r1, [r8],#1                             ; pixel 2 from second Y row
        ADD     r0, r0,r1
        ; average the four Y pixels
        MOVS    r0, r0,ASR#2                            ; divide by 4
        ADDCS   r0, r0,#1                               ; (round up if necessary)

        LDRB    r1, [r9],#1                             ; C1 pixel value for these 4 pixels
        LDRB    r2, [r10],#1                            ; C2 pixel value for these 4 pixels

        STRB    r0, [r3],#1                             ; store component 1 (Y or R)
        STRB    r1, [r3],#1                             ; store component 2 (C1 or G)
        STRB    r2, [r3],#1                             ; store component 3 (C2 or B)

        SUBS    r4, r4,#1                               ; decrement pixel count
        BGT     gbrb64_xloop                            ; go get another one!


        ; output the row to ther user's buffer

        LDR     r3, gb_numpixels
        BL      gb_outputrow

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        SUBS    r6, r6,#1                               ; decrement 'lines to do'
        BGT     gbrb64_yloop

        LDMFD   sp!, {r0-r9, pc}^



;===================================================================================


        ; Macro to copy triplets between buffers
        ; 'num' is number of triplets (ie num*3 bytes are copied)

        MACRO
$label  copybuffer3x   $dst,$src,$num
$label  STMFD   sp!, {r7-r9}
01
        LDMIA   $src!, {r7,r8,r9}
        STMIA   $dst!, {r7,r8,r9}
        SUBS    $num, $num,#4
        BGT     %bt01

        LDMFD   sp!, {r7-r9}
        MEND



;===================================================================================
;       Read images with resolutions from Base/16 up to Base
;===================================================================================


gb_read_normal
        ; r2 = bufY1
        ; r4 = resolution step
        ; r5 = output pointer
        ; r7 = iwidth
        ; r8-r11 = y0,y1,x0,x1


        SUB     r6, r9,r8                               ; lines to read

        STR     r10, gb_firstpixel

        SUB     r0, r11,r10                             ; number of pixels that need to be done
        STR     r0, gb_numpixels                        ;    in each row

 ;disp_reg r8, "y0", "I"
 ;disp_reg r9, "y1", "I"
 ;disp_reg r10, "x0", "I"
 ;disp_reg r11, "x1", "I"
 ;disp_reg r6, "linestodo", "I"
 ;disp_reg r2, "bufY1"
 ;disp_reg r5, "out"
 ;disp_reg r7, "iwidth", "I"
        AND     r0, r8,#1                               ; y0 odd?
        STR     r0, gb_skipfirstline                    ; first even row gets skipped


        ; calculate file pointer offset to read from
        MOV     r0, r8,ASR#1                            ; (y0 DIV 2)
        ADD     r1, r7,r7,ASL#1                         ; (iwidth * 3)
        LDR     r2, gb_fileptr                          ; start of image in Pac
        MLA     r2, r0,r1,r2
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        SWI     XOS_Args
        BVS     gb_returnerr

        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_setup
        ]


        ; calculate initial x read positions within line buffers

        LDR     r0, gb_bufY1
        ADD     r0, r0,r10                              ; yp1  -  Y ptr 1
        STR     r0, gb_yp1

        LDR     r0, gb_bufY2
        ADD     r0, r0,r10                              ; yp2  -  Y ptr 2
        STR     r0, gb_yp2

        LDR     r0, gb_bufC1
        ADD     r0, r0,r10,ASR#1                        ; c1p  -  C1 ptr 1
        STR     r0, gb_c1p

        LDR     r0, gb_bufC2
        ADD     r0, r0,r10,ASR#1                        ; c2p  -  C2 ptr 1
        STR     r0, gb_c2p

        LDR     r0, gb_buf2C1
        ADD     r0, r0,r10,ASR#1                        ; c12p  -  C1 ptr 2
        STR     r0, gb_c12p

        LDR     r0, gb_buf2C2
        ADD     r0, r0,r10,ASR#1                        ; c22p  -  C2 ptr 2
        STR     r0, gb_c22p


        ; calculate 'lastline' and 'lastpixel'
        ; - used for telling whether we are at the right or bottom extremity of the image
        LDR     r0, gb_iheight
        SUB     r0, r0,#2
        STR     r0, gb_lastline

        LDR     r0, gb_iwidth
        SUB     r0, r0,#1
        STR     r0, gb_lastpixel


        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_bufY1
        LDR     r3, gb_iwidth
        ADD     r3, r3,r3,ASL#1                         ; * 3  (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?


gbrn_yloop

        LDR     r1, gb_lastline
        CMP     r8, r1
        BGE     gbrn_dorows                             ; if on last line of image, don't read the (non-existing) next line

        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_buf2Y1
        LDR     r3, gb_iwidth
        ADD     r3, r3,r3,ASL#1                         ; * 3  (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?

gbrn_dorows

        LDR     r0, gb_skipfirstline                    ; does the first even row need to be skipped?
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNE   r0, gb_skipfirstline                    ; clear the flag for next time
        BNE     gbrn_oddrow                             ; skip the even row


        BL      gbrn_do_even_row                        ; calculate and store YCC values for row

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number

        SUB     r6, r6,#1                               ; decrement 'lines to do'


gbrn_oddrow

        CMP     r6, #0                                  ; lines remaining
        BLE     gbrn_return                             ; none -  exit


        BL      gbrn_do_odd_row                         ; calculate and store YCC values for row

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number


        ; copy 'next input line' down into 'current input line'
        LDR     r0, gb_bufY1
        LDR     r1, gb_buf2Y1
        LDR     r2, gb_iwidth                           ; (iwidth * 3) bytes will be copied
        copybuffer3x  r0,r1,r2


        SUBS    r6, r6,#1                               ; decrement 'lines to do'
        BGT     gbrn_yloop


gbrn_return
        LDMFD   sp!, {r0-r9, pc}^



;-----------------------------------------------------------------------------------



gbrn_do_even_row

        STMFD   sp!, {r5-r6,r9, lr}                     ; preserve r5 (out ptr) for beginning of
                                                        ; row (we need it to find start of next row

        LDR     r4, gb_numpixels                        ; pixels to do in row
        LDR     r5, gb_addr_lineoutbuf

        ; get first x pos to read from in each component line buffer
        LDR     r7, gb_yp1
        LDR     r9, gb_c1p
        LDR     r10, gb_c2p


        LDR     r6, gb_firstpixel
        TST     r6, #1
        BNE     gbrne_oddpix                            ; if x0 is odd, skip first (even) pixel

gbrne_xloop

        ; do an (even) pixel
        LDRB    r0, [r7],#1                             ; Y value
        LDRB    r1, [r9]                                ; C1 value
        LDRB    r2, [r10]                               ; C2 value

        STRB    r0, [r5],#1                             ; store Y
        STRB    r1, [r5],#1                             ; store C1
        STRB    r2, [r5],#1                             ; store C2

        ADD     r6, r6,#1                               ; increment 'current pixel'

        SUB     r4, r4,#1                               ; decrement pixel count


gbrne_oddpix

        CMP     r4, #0
        BLE     gbrne_return

        ; do an (odd) pixel
        LDRB    r0, [r7],#1                             ; Y value
        LDRB    r1, [r9],#1                             ; C1 value
        LDRB    r2, [r10],#1                            ; C2 value

        LDR     r3, gb_lastpixel
        CMP     r6, r3
        ; this is last pixel - no 'next', so use same C1 and C2 as last time
        BGE     gbrne1_store

        ; for odd pixel, interpolate C1 & C2 from the 'even' C1 & C2 either side of us
        LDRB    r3, [r9]                                ; next C1 value
        ADD     r1, r1,r3                               ; get average of the two
        MOVS    r1, r1,ASR#1
        ADDCS   r1, r1,#1                               ; (round up if necessary)
        LDRB    r3, [r10]                               ; next C2 value
        ADD     r2, r2,r3
        MOVS    r2, r2,ASR#1
        ADDCS   r2, r2,#1                               ; (round up if necessary)

gbrne1_store
        STRB    r0, [r5],#1                             ; store Y
        STRB    r1, [r5],#1                             ; store C1
        STRB    r2, [r5],#1                             ; store C2

        ADD     r6, r6,#1                               ; increment 'current pixel'

        SUBS    r4, r4,#1                               ; decrement pixel count
        BGT     gbrne_xloop                             ; go get another one!


gbrne_return
        LDMFD   sp!, {r5-r6,r9, pc}^



;-----------------------------------------------------------------------------------



gbrn_do_odd_row

        STMFD   sp!, {r5-r6,r8-r9, lr}                  ; preserve r5 (out ptr) for beginning of
                                                        ; row (we need it to find start of next row

        LDR     r4, gb_numpixels                        ; pixels to do in row
        LDR     r5, gb_addr_lineoutbuf

        ; get first x pos to read from in each component line buffer
        LDR     r3, gb_yp2
        STR     r3, gb_yp2curr
        LDR     r7, gb_c1p
        LDR     r8, gb_c2p
        LDR     r9, gb_c12p
        LDR     r10, gb_c22p

        LDR     r11, gb_pbdb                            ; retrieve bdb pointer

        LDR     r6, gb_firstpixel
        TST     r6, #1
        BNE     gbrno_oddpix                            ; if x0 is odd, skip first (even) pixel

gbrno_xloop

        ; do an (even) pixel
        LDR     r3, gb_yp2curr
        LDRB    r0, [r3],#1                             ; Y value
        STR     r3, gb_yp2curr

        LDR     r3, [r11, #bdb_colourformat]            ; colour format (grey/ycc/rgb)
        TEQ     r3, #colour_greyscale
        BEQ     gbrno0_store_Y                          ; skip C1 and C2 calculations

        ; not greyscale, so get the chrominance values
        LDRB    r1, [r7]                                ; C1 value
        LDRB    r3, [r9]                                ; next-row C1 value
        ADD     r1, r1,r3                               ; get average of the two values
        MOVS    r1, r1,ASR#1
        ADDCS   r1, r1,#1                               ; (round up if necessary)

        LDRB    r2, [r8]                                ; C2 value
        LDRB    r3, [r10]                               ; next-row C2 value
        ADD     r2, r2,r3
        MOVS    r2, r2,ASR#1
        ADDCS   r2, r2,#1

        STRB    r1, [r5,#1]                             ; store C1
        STRB    r2, [r5,#2]                             ; store C2

gbrno0_store_Y
        STRB    r0, [r5],#3                             ; store Y
                                                        ; and increment output ptr to next position
        ADD     r6, r6,#1                               ; increment 'current pixel'

        SUB     r4, r4,#1                               ; decrement pixel count


gbrno_oddpix

        CMP     r4, #0
        BLE     gbrno_return

        ; do an (odd) pixel
        LDR     r3, gb_yp2curr
        LDRB    r0, [r3],#1                             ; Y value
        STR     r3, gb_yp2curr

        LDR     r3, [r11, #bdb_colourformat]            ; colour format (grey/ycc/rgb)
        TEQ     r3, #colour_greyscale
        BEQ     gbrno1_store_Y                          ; skip C1 and C2 calculations

        ; not greyscale, so get the chrominance values
        LDR     r1, gb_lastpixel
        CMP     r6, r1
        BLT     gbrno1_4wayinterp

        ; this is last pixel - no 'next', so use same C1 and C2 as last time
        LDRB    r1, [r7]                                ; C1 value
        LDRB    r3, [r9]                                ; next-row C1 value
        ADD     r1, r1,r3                               ; get average of the two values
        MOVS    r1, r1,ASR#1
        ADDCS   r1, r1,#1                               ; (round up if necessary)

        LDRB    r2, [r8]                                ; C2 value
        LDRB    r3, [r10]                               ; next-row C2 value
        ADD     r2, r2,r3
        MOVS    r2, r2,ASR#1
        ADDCS   r2, r2,#1
        B       gbrno1_store

gbrno1_4wayinterp
        ; 4-way interpolation (average of 'last-C1-this-row', 'next-C1-this-row',
        ; 'last-C1-next-row' and 'next-C1-next-row') - ditto for C2

        LDRB    r1, [r7],#1                             ; 'last-C1-this-row'
        LDRB    r3, [r7]                                ; 'next-C1-this-row'
        ADD     r1, r1,r3
        LDRB    r3, [r9],#1                             ; 'last-C1-next-row'
        ADD     r1, r1,r3
        LDRB    r3, [r9]                                ; 'next-C1-next-row'
        ADD     r1, r1,r3
        MOVS    r1, r1,ASR#2                            ; average the values
        ADDCS   r1, r1,#1                               ; (round up if necessary)

        LDRB    r2, [r8],#1                             ; 'last-C2-this-row'
        LDRB    r3, [r8]                                ; 'next-C2-this-row'
        ADD     r2, r2,r3
        LDRB    r3, [r10],#1                            ; 'last-C2-next-row'
        ADD     r2, r2,r3
        LDRB    r3, [r10]                               ; 'next-C2-next-row'
        ADD     r2, r2,r3
        MOVS    r2, r2,ASR#2                            ; average the values
        ADDCS   r2, r2,#1                               ; (round up if necessary)


gbrno1_store
        STRB    r1, [r5,#1]                             ; store C1
        STRB    r2, [r5,#2]                             ; store C2

gbrno1_store_Y
        STRB    r0, [r5],#3                             ; store Y
                                                        ; and increment output ptr to next position
        ADD     r6, r6,#1                               ; increment 'current pixel'

        SUBS    r4, r4,#1                               ; decrement pixel count
        BGT     gbrno_xloop                             ; go get another one!


gbrno_return
        LDMFD   sp!, {r5-r6,r8-r9, pc}^



;-----------------------------------------------------------------------------------



gb_outputsetup

; Do any required setting up needed by 'gb_outputrow' (the output routine)
;
; On Entry
;    r2 = ptr to pbdb


        STMFD   sp!, {r1-r6, lr}

        LDR     r1, [r2, #bdb_colourformat]
        CMP     r1, #colour_greyscale
        BLT     gbos_badcolfmt
        CMP     r1, #colour_palette
        BGT     gbos_badcolfmt

        BNE     gbos_returnok                           ; if not 'palette' then no setup reqd


        ; check number of entries

        LDR     r5, [r2, #bdb_paletteentries]
        CMP     r5, #2
        BLT     gbos_badpal
        CMP     r5, #256
        BGT     gbos_badpal


        MOV     r4, r2                                  ; preserve pbdb pointer


        ; calculate CRC for passed palette

        MOV     r0, #0
        LDR     r1, [r4, #bdb_palettetable]             ; start address of palette table
        ADD     r2, r1, r5,ASL#2                        ; end = start + (noum_entries * 4)
        MOV     r3, #1                                  ; increment
        SWI     XOS_CRC
        MOVVC   r6, r0                                  ; preserve the CRC in r6
        LDRVS   r6, gbp_last_palCRC                     ; if error, then we don't know if
        EORVS   r6, r6,#1                               ;   table has changed, so ensure
                                                        ;   it gets re-generated


        ; Try and claim the ict buffer
        ; We will only claim it once (we won't bother freeing it afterwards)
        LDR     r0, gbp_addr_ictable
        TEQ     r0, #0
        BNE     gbos_ictclaimed

        MOV     r0, #6                                  ; Claim workspace
        MOV     r3, #(16*16*16) + (x_16Base*3*8)        ; num entries = (4bits per component)
                                                        ;    + space for err diff buffer
        SWI     XOS_Module
        BVS     gbos_exit

        STR     r2, gbp_addr_ictable                    ; save address of claimed ict buffer
        ADD     r2, r2,#(16*16*16)
        STR     r2, gbp_addr_errdiffbuf                 ; save address of error diff buffer

        B       gbos_genict                             ; now generate the ict


gbos_ictclaimed
        ; check the table.. it may already have been calculated

        LDR     r0, gbp_last_numpal
        TEQ     r5, r0                                  ; are the number of entries the same?
        LDREQ   r0, gbp_last_palCRC                     ; yes.. are the CRC the same alse?
        TEQEQ   r6, r0
        BEQ     gbos_returnok                           ; yes - we can assume table is ok as is


gbos_genict
        ; generate inverse colour table

        ; r4 = pbdb
        ; r5 = entries in palette table
        ; r6 = CRC for entries in palette

        STR     r5, gbp_last_numpal                     ; store numentries for comparison next time
        STR     r6, gbp_last_palCRC                     ; store CRC for comparison next time

        ; find some scratch space to use for distance buffer
        ; (size needed is (16*16*16)*4 = 16K)
        ; Since all this is before the linebuffers and output
        ; buffers are used, we can use them.

        ADR     r0, cd_sectorbuffers
        STR     r0, gbict_dbufloc

        BL      gbict_make


        ; now zero the error buffer

        LDR     r0, gbp_addr_errdiffbuf
        MOV     r1, #0
        MOV     r2, #(x_16Base*3*8)
gbos_edloop
        STR     r1, [r0],#8          ; (only need to zero first word of pair (pair=[err,temp_value]))
        SUBS    r2, r2,#8
        BGE     gbos_edloop


        ; initialise the 'direction' indicator

        STR     r1, gbp_direction


gbos_returnok
        ADDS    r0, r0,#1                               ; clear V
gbos_exit
        LDMFD   sp!, {r1-r6, pc}


        ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


gbos_badcolfmt
        ; if here: colour format is unknown - return error
        addr    r0, BadColFmt_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r1-r2, pc}


gbos_badpal
        ; if here: colour format is unknown - return error
        ADR     r0, BadPal_errormsg
        BL      ErrorLookup
        LDMFD   sp!, {r1-r2, pc}


;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


BadPal_errormsg    Error PhotoCD_Err_chunk+16, "PCDBadPal"



;-----------------------------------------------------------------------------------


gbict_make

; Routine to generate an inverse colour table
; Generates a table in which the entry &BGR is
; the palette entry of the colour closest to
; 24 bit colour &Rr,&Gg,&Bb

; Table is generated by calculating the distances
; (in RGB/YCC space) to the nearest palette entry
; and storing the entry number.  Routine is made
; efficient by using forward differences to find
; the distances

gbi_BITS    *  4                ; significant bits for each component
gbi_MAXCOL  *  (1 << gbi_BITS)  ; max size of value expressible by that
gbi_NBITS   *  (8 - gbi_BITS)   ; non-significant bits
gbi_X       *  (1 << gbi_NBITS) ; difference between values quantized to gbi_BITS bits
gbi_X2      *  (gbi_X * gbi_X)  ; gbi_X squared

        GBLL gbi_WEIGHTED
gbi_WEIGHTED SETL {TRUE}


        STMFD   sp!, {r0-r11, lr}


        ; first, we need to initialize the distance buffer
        MOV     r0, #-1                         ; max_unsigned_int
        LDR     r1, gbict_dbufloc
        MOV     r2, #(gbi_MAXCOL*gbi_MAXCOL*gbi_MAXCOL)
gbi_dinitloop
        STR     r0, [r1],#4
        SUBS    r2, r2,#1
        BGT     gbi_dinitloop


        MOV     r0, #0                          ; palette entry count
gbi_palloop
        LDR     r4, gb_pbdb
        LDR     r4, [r4, #bdb_palettetable]     ; palette table pointer
        LDR     r4, [r4, r0,LSL#2]              ; palette entry value

        MOV     r1, r4,LSR#8                    ; r
        AND     r1, r1,#&ff
        MOV     r2, r4,LSR#16                   ; g
        AND     r2, r2,#&ff
        MOV     r3, r4,LSR#24                   ; b

        SUB     r4, r1,#(gbi_X / 2)             ; rdist
        SUB     r5, r2,#(gbi_X / 2)             ; gdist
        SUB     r6, r3,#(gbi_X / 2)             ; bdist

        [ gbi_WEIGHTED
        MUL     r7, r4,r4
        MOV     r7, r7,ASL#1                    ; red weight = 2
        MUL     r4, r5,r5
        ADD     r4, r7,r4,ASL#2                 ; green weight = 4
        MLA     r4, r6,r6,r4                    ; dist = rdist^2 + gdist^2 + cbdist^2
        |
        MUL     r7, r4,r4
        MLA     r4, r5,r5,r7
        MLA     r4, r6,r6,r4                    ; dist = rdist^2 + gdist^2 + cbdist^2
        ]

        [ gbi_WEIGHTED
        MOV     r1, r1,LSL#(gbi_NBITS + 1)      ; rinc = 2 * (x2 - (r << gbi_NBITS))
        RSB     r1, r1,#(gbi_X2 * 2)
        MOV     r1, r1,ASL#1                    ; red weight = 2
        MOV     r2, r2,LSL#(gbi_NBITS + 1)      ; ginc = 2 * (x2 - (g << gbi_NBITS))
        RSB     r2, r2,#(gbi_X2 * 2)
        MOV     r2, r2,ASL#2                    ; green weight = 4
        MOV     r3, r3,LSL#(gbi_NBITS + 1)      ; binc = 2 * (x2 - (b << gbi_NBITS))
        RSB     r3, r3,#(gbi_X2 * 2)            ; (blue weight = 1)
        |
        MOV     r1, r1,LSL#(gbi_NBITS + 1)      ; rinc = 2 * (x2 - (r << gbi_NBITS))
        RSB     r1, r1,#(gbi_X2 * 2)
        MOV     r2, r2,LSL#(gbi_NBITS + 1)      ; ginc = 2 * (x2 - (g << gbi_NBITS))
        RSB     r2, r2,#(gbi_X2 * 2)
        MOV     r3, r3,LSL#(gbi_NBITS + 1)      ; binc = 2 * (x2 - (b << gbi_NBITS))
        RSB     r3, r3,#(gbi_X2 * 2)
        ]

        LDR     r7, gbict_dbufloc
        LDR     r8, gbp_addr_ictable

        MOV     r9, #gbi_MAXCOL                 ; b count
        MOV     r5, r3                          ; bxx = binc
gbi_bloop
        STR     r4, gbict_bdist                 ; preserve dist
        STR     r5, gbict_bxx

        MOV     r10, #gbi_MAXCOL                ; g count
        MOV     r5, r2                          ; gxx = ginc
gbi_gloop
        STR     r4, gbict_gdist                 ; preserve dist
        STR     r5, gbict_gxx

        MOV     r11, #gbi_MAXCOL                ; r count
        MOV     r5, r1                          ; rxx = rinc
gbi_rloop
        LDR     r6, [r7],#4
        CMP     r4, r6                          ; dist < existing-dist ?
        STRLO   r4, [r7,#-4]                    ; yes.. existing-dist = dist
        STRLOB  r0, [r8]                        ;       ictmapval = current col
        ADD     r8, r8,#1                       ; increment ict pointer

        ADD     r4, r4,r5                       ; dist += rxx
        [ gbi_WEIGHTED
        ADD     r5, r5,#(gbi_X2 * 2 * 2)        ; rxx += (x2 * 2) * red weight
        |
        ADD     r5, r5,#(gbi_X2 * 2)            ; rxx += (x2 * 2)
        ]

        SUBS    r11, r11,#1
        BGT     gbi_rloop


        LDR     r4, gbict_gdist
        LDR     r5, gbict_gxx
        ADD     r4, r4,r5                       ; dist += gxx
        [ gbi_WEIGHTED
        ADD     r5, r5,#(gbi_X2 * 2 * 4)        ; gxx += (x2 * 2) * green weight
        |
        ADD     r5, r5,#(gbi_X2 * 2)            ; gxx += (x2 * 2)
        ]

        SUBS    r10, r10,#1
        BGT     gbi_gloop


        LDR     r4, gbict_bdist
        LDR     r5, gbict_bxx
        ADD     r4, r4,r5                       ; dist += bxx
        ADD     r5, r5,#(gbi_X2 * 2)            ; bxx += (x2 * 2)

        SUBS    r9, r9,#1
        BGT     gbi_bloop


        ADD     r0, r0,#1
        LDR     r1, gbp_last_numpal             ; number of colours in current palette
        CMP     r0, r1
        BLT     gbi_palloop


        LDMFD   sp!, {r0-r11, pc}^



;-----------------------------------------------------------------------------------



gb_outputrow

; Takes the values from the final buffer (gb_lineoutbuf),
; converts them if necessary, and writes them out to the
; user's buffer
;
; On Entry
;    r3 = number of pixels in the row
;    r5 = ptr to current position in users buffer
;
; On Exit


        STMFD   sp!, {r0-r7, lr}

        LDR     r2, gb_pbdb
        LDR     r0, [r2, #bdb_colourformat]             ; colour format of output
        LDR     r6, [r2, #bdb_planeoffset]              ; offset between colour components

        LDR     r7, gb_colinc
        LDR     r4, gb_addr_lineoutbuf

        TEQ     r0, #colour_greyscale
        BEQ     gbor_singleloop

        TEQ     r0, #colour_rgb
        BEQ     gbor_rgbloop

        TEQ     r0, #colour_palette
        BEQ     gbor_palettemode

        ; otherwise fall through and just ouput plain YCC

gbor_yccloop
        LDRB    r0, [r4],#1
        LDRB    r1, [r4],#1
        LDRB    r2, [r4],#1

        STRB    r0, [r5]                                ; store component 1 (Y)
        STRB    r1, [r5, r6]                            ; store component 2 (C1)
        STRB    r2, [r5, r6,ASL#1]                      ; store component 3 (C2)

        ADD     r5, r5,r7                               ; increment output ptr to next pixel

        SUBS    r3, r3,#1                               ; decrement pixel count
        BGT     gbor_yccloop

        LDMFD   sp!, {r0-r7, pc}^


        ;- - - - - - - - - - - - - - - - - - - - - - - -


gbor_singleloop
        LDRB    r0, [r4],#3
        STRB    r0, [r5]                                ; store component 1 (Y)

        ADD     r5, r5,r7                               ; increment output ptr to next pixel

        SUBS    r3, r3,#1                               ; decrement pixel count
        BGT     gbor_singleloop

        LDMFD   sp!, {r0-r7, pc}^


        ;- - - - - - - - - - - - - - - - - - - - - - - -


gbor_rgbloop
        LDRB    r0, [r4],#1
        LDRB    r1, [r4],#1
        LDRB    r2, [r4],#1

        SWI     XPhotoCD_ConvertYCCtoRGB

        STRB    r0, [r5]                                ; store component 1 (Y)
        STRB    r1, [r5, r6]                            ; store component 2 (C1)
        STRB    r2, [r5, r6,ASL#1]                      ; store component 3 (C2)

        ADD     r5, r5,r7                               ; increment output ptr to next pixel

        SUBS    r3, r3,#1                               ; decrement pixel count
        BGT     gbor_rgbloop

        LDMFD   sp!, {r0-r7, pc}^


        ;- - - - - - - - - - - - - - - - - - - - - - - -


gbor_palettemode

        STMFD   sp!, {r8-r11}

        LDR     r6, gb_pbdb

        LDR     r0, [r6, #bdb_flags]
        TST     r0, #bdbflag_doerrordiff                ; error diffusion wanted?
        BNE     gbor_palerrdiff                         ; yes - branch to that loop


gbor_paletteloop
        LDRB    r0, [r4],#1
        LDRB    r1, [r4],#1
        LDRB    r2, [r4],#1

        ; if not a YCC palette, then convert to RGB
        LDR     r8, [r6, #bdb_flags]
        TST     r8, #bdbflag_YCCpalette
        SWIEQ   XPhotoCD_ConvertYCCtoRGB


        ; calculate ict index (&Rr,&Gg,&Bb => &BGR)
        MOV     r0, r0,LSR#4
        BIC     r1, r1,#&f
        ORR     r0, r0,r1
        BIC     r2, r2,#&f
        ORR     r0, r0,r2,LSL#4

        ; get palette entry number from ict table
        LDR     r9, gbp_addr_ictable
        LDRB    r0, [r9, r0]

        ; write palette value to user's buffer
        STRB    r0, [r5]                                ; store palette entry number


        ADD     r5, r5,r7                               ; increment output ptr to next pixel

        SUBS    r3, r3,#1                               ; decrement pixel count
        BGT     gbor_paletteloop


        LDMFD   sp!, {r8-r11}
        LDMFD   sp!, {r0-r7, pc}^


        ;- - - - - - - - - - - - - - - - - - - - - - - -

        ; Error diffusion routine
        ; Simple form of error diffusion - distributes half the
        ; error rightwards and the other half downwards.
        ; This is what the original C routines for the PC did.

        GBLL gbi_SERPENTINE
        ; serpentine = does alternate rows in different directions
;gbi_SERPENTINE SETL {FALSE}
gbi_SERPENTINE SETL {TRUE}


gbor_palerrdiff

        ; first, add in the errors from the previous line

        LDR     r8, gbp_addr_errdiffbuf                 ; buffer of errors from last line
        MOV     r10, r3
        LDR     r11, [r6, #bdb_flags]

gbor_adjustloop
        LDRB    r0, [r4],#1
        LDRB    r1, [r4],#1
        LDRB    r2, [r4],#1

        ; if not a YCC palette, then convert to RGB
        TST     r11, #bdbflag_YCCpalette
        SWIEQ   XPhotoCD_ConvertYCCtoRGB

        LDR     r9, [r8],#4           ; first word of pair is error
        ADD     r0, r0,r9,ASR#4       ; val += err/16
        STR     r0, [r8],#4           ; second word of pair is value

        LDR     r9, [r8],#4
        ADD     r1, r1,r9,ASR#4
        STR     r1, [r8],#4

        LDR     r9, [r8],#4
        ADD     r2, r2,r9,ASR#4
        STR     r2, [r8],#4

        SUBS    r10, r10,#1                             ; decrement pixel count
        BGT     gbor_adjustloop


        ; clear error buffer

        LDR     r8, gbp_addr_errdiffbuf                 ; buffer of errors from last line
        MOV     r10, r3
        MOV     r0, #0
gbor_zeroerrsloop
        STR     r0, [r8,#0]
        STR     r0, [r8,#8]
        STR     r0, [r8,#16]
        ADD     r8, r8,#24
        SUBS    r10, r10,#1
        BGT     gbor_zeroerrsloop


        ; initialise the error-from-last-pixel values
        MOV     r9,#0
        MOV     r10,#0
        MOV     r11,#0

        LDR     r4, gb_addr_lineoutbuf
        LDR     r8, gbp_addr_errdiffbuf                 ; buffer of errors from last line


        [ gbi_SERPENTINE
        LDR     r0, gbp_direction                       ; get direction
        EORS    r0, r0,#1                               ; update the value
        STR     r0, gbp_direction
        BEQ     gbor_palerrdiff2                        ; if value was 1 then do
        ]                                               ; right-to-left loop


        RSB     r3, r3,#0                               ; make count -ve as a flag to
                                                        ; indicate first time through loop

gbor_palerrdiffloop1
        ; do err diff from left to right

        LDR     r0, [r8,#4]
        LDR     r1, [r8,#12]
        LDR     r2, [r8,#20]

        ; add in the errors from the last pixel
        ADD     r0, r0,r9,ASR#4
        ADD     r1, r1,r10,ASR#4
        ADD     r2, r2,r11,ASR#4

        ; clamp the values to the range [0..255]
        CMP     r0, #0
        MOVLT   r0, #0
        CMP     r0, #255
        MOVGT   r0, #255

        CMP     r1, #0
        MOVLT   r1, #0
        CMP     r1, #255
        MOVGT   r1, #255

        CMP     r2, #0
        MOVLT   r2, #0
        CMP     r2, #255
        MOVGT   r2, #255

        ; calculate ict index (&Rr,&Gg,&Bb => &BGR)
        MOV     r10, r0,LSR#4
        BIC     r11, r1,#&f
        ORR     r10, r10,r11
        BIC     r11, r2,#&f
        ORR     r10, r10,r11,LSL#4

        ; get palette entry number from ict table
        LDR     r9, gbp_addr_ictable
        LDRB    lr, [r9, r10]

        ; write palette value to user's buffer
        STRB    lr, [r5]                                ; store palette entry number
        ADD     r5, r5,r7                               ; increment output ptr to next pixel

        ; get the palette entry components
        LDR     r9, [r6, #bdb_palettetable]             ; palette table pointer
        ADD     lr, r9,lr,LSL#2                         ; pointer to palette entry
        LDRB    r9, [lr,#1]
        LDRB    r10, [lr,#2]
        LDRB    r11, [lr,#3]

        ; calculate errors
        SUB     r9, r0,r9
        SUB     r10, r1,r10
        SUB     r11, r2,r11

        ; now distribute them

        ; 'xpos-1' error = error * 3/16
        CMP     r3, #0                                  ; first time through loop?
        RSBMI   r3, r3,#0
        BMI     gbor_pdl1_five                          ; yes - can't write out this error value

        ADD     r0, r9,r9,ASL#1
        LDR     lr, [r8,#(0-24)]
        ADD     r0, lr,r0
        STR     r0, [r8,#(0-24)]

        ADD     r1, r10,r10,ASL#1
        LDR     lr, [r8,#(8-24)]
        ADD     r1, lr,r1
        STR     r1, [r8,#(8-24)]

        ADD     r2, r11,r11,ASL#1
        LDR     lr, [r8,#(16-24)]
        ADD     r2, lr,r2
        STR     r2, [r8,#(16-24)]

gbor_pdl1_five
        ; 'xpos' error = error * 5/16
        ADD     r0, r9,r9,ASL#2
        LDR     lr, [r8,#0]
        ADD     r0, lr,r0
        STR     r0, [r8,#0]

        ADD     r1, r10,r10,ASL#2
        LDR     lr, [r8,#8]
        ADD     r1, lr,r1
        STR     r1, [r8,#8]

        ADD     r2, r11,r11,ASL#2
        LDR     lr, [r8,#16]
        ADD     r2, lr,r2
        STR     r2, [r8,#16]

        ; 'xpos+1' error = error * 1/16
        SUBS    r3, r3,#1                               ; decrement pixel count
        BLE     gbor_pdl1_exit                          ; if last then exit

        ; safe to write out 'xpos+1' error
        ; (don't need to *add* this in, the current value would be zero anyway)
        STR     r9, [r8,#(0+24)]
        STR     r10, [r8,#(8+24)]
        STR     r11, [r8,#(16+24)]

        ; next pixel on line gets 7/16 of error
        RSB     r9, r9,r9,ASL#3
        RSB     r10, r10,r10,ASL#3
        RSB     r11, r11,r11,ASL#3

        ADD     r8, r8,#24

        B       gbor_palerrdiffloop1


gbor_pdl1_exit

        LDMFD   sp!, {r8-r11}
        LDMFD   sp!, {r0-r7, pc}^


        ;- - - - - - - - - - - - - - - - - - - - - - - -


        [ gbi_SERPENTINE

gbor_palerrdiff2
        ; do err diff from right to left

        ; point to end of error buffer
        ADD     r0, r3,r3,ASL#1                         ; (width * 24)
        MOV     r0, r0,ASL#3
        SUB     r0, r0,#24
        ADD     r8, r8,r0

        MLA     r5, r3,r7,r5                            ; point to end of output row
        STR     r5, gbp_outend                          ; save for later


        RSB     r3, r3,#0                               ; make count -ve as a flag to
                                                        ; indicate first time through loop

gbor_palerrdiffloop2

        LDR     r0, [r8,#4]
        LDR     r1, [r8,#12]
        LDR     r2, [r8,#20]

        ; add in the errors from the last pixel
        ADD     r0, r0,r9,ASR#4
        ADD     r1, r1,r10,ASR#4
        ADD     r2, r2,r11,ASR#4

        ; clamp the values to the range [0..255]
        CMP     r0, #0
        MOVLT   r0, #0
        CMP     r0, #255
        MOVGT   r0, #255

        CMP     r1, #0
        MOVLT   r1, #0
        CMP     r1, #255
        MOVGT   r1, #255

        CMP     r2, #0
        MOVLT   r2, #0
        CMP     r2, #255
        MOVGT   r2, #255

        ; calculate ict index (&Rr,&Gg,&Bb => &BGR)
        MOV     r10, r0,LSR#4
        BIC     r11, r1,#&f
        ORR     r10, r10,r11
        BIC     r11, r2,#&f
        ORR     r10, r10,r11,LSL#4

        ; get palette entry number from ict table
        LDR     r9, gbp_addr_ictable
        LDRB    lr, [r9, r10]

        ; write palette value to user's buffer
        SUB     r5, r5,r7                               ; decrement to previous pixel
        STRB    lr, [r5]                                ; store palette entry number

        ; get the palette entry components
        LDR     r9, [r6, #bdb_palettetable]             ; palette table pointer
        ADD     lr, r9,lr,LSL#2                         ; pointer to palette entry
        LDRB    r9, [lr,#1]
        LDRB    r10, [lr,#2]
        LDRB    r11, [lr,#3]

        ; calculate errors
        SUB     r9, r0,r9
        SUB     r10, r1,r10
        SUB     r11, r2,r11

        ; now distribute them

        ; 'xpos-1' error = error * 3/16
        CMP     r3, #0                                  ; first time through loop?
        RSBMI   r3, r3,#0
        BMI     gbor_pdl2_five                          ; yes - can't write out this error value

        ADD     r0, r9,r9,ASL#1
        LDR     lr, [r8,#(0+24)]
        ADD     r0, lr,r0
        STR     r0, [r8,#(0+24)]

        ADD     r1, r10,r10,ASL#1
        LDR     lr, [r8,#(8+24)]
        ADD     r1, lr,r1
        STR     r1, [r8,#(8+24)]

        ADD     r2, r11,r11,ASL#1
        LDR     lr, [r8,#(16+24)]
        ADD     r2, lr,r2
        STR     r2, [r8,#(16+24)]

gbor_pdl2_five
        ; 'xpos' error = error * 5/16
        ADD     r0, r9,r9,ASL#2
        LDR     lr, [r8,#0]
        ADD     r0, lr,r0
        STR     r0, [r8,#0]

        ADD     r1, r10,r10,ASL#2
        LDR     lr, [r8,#8]
        ADD     r1, lr,r1
        STR     r1, [r8,#8]

        ADD     r2, r11,r11,ASL#2
        LDR     lr, [r8,#16]
        ADD     r2, lr,r2
        STR     r2, [r8,#16]

        ; 'xpos+1' error = error * 1/16
        SUBS    r3, r3,#1                               ; decrement pixel count
        BLE     gbor_pdl2_exit                          ; if last then exit

        ; safe to write out 'xpos+1' error
        ; (don't need to *add* this in, the current value would be zero anyway)
        STR     r9, [r8,#(0-24)]
        STR     r10, [r8,#(8-24)]
        STR     r11, [r8,#(16-24)]

        ; next pixel on line gets 7/16 of error
        RSB     r9, r9,r9,ASL#3
        RSB     r10, r10,r10,ASL#3
        RSB     r11, r11,r11,ASL#3

        ; loop for next pixel
        SUB     r8, r8,#24
        B       gbor_palerrdiffloop2


gbor_pdl2_exit

        LDR     r5, gbp_outend                          ; retrieve row end ready for
                                                        ; output of next row
        LDMFD   sp!, {r8-r11}
        LDMFD   sp!, {r0-r7, pc}^

        ]



;===================================================================================
;       Read a 4Base image
;===================================================================================



gb_read_4Base
        ; r2 = bufY1
        ; r4 = resolution step
        ; r5 = output pointer
        ; r7 = iwidth
        ; r8-r11 = y0,y1,x0,x1


        SUB     r6, r9,r8                               ; lines to read

        STR     r8, gb_firstline
        STR     r10, gb_firstpixel
 
        SUB     r0, r11,r10                             ; number of pixels that need to be done
        STR     r0, gb_numpixels                        ;    in each row


        AND     r0, r8,#3                               ; y0 mod 4
        STR     r0, gb_skipfirstline                    ; first even row gets skipped


        ; calculate file pointer offset to read from
        ; (note: 'Base' data forms the basis of this resolution)
        MOV     r0, r8,ASR#2                            ; (y0 DIV 2) / 2
        MOV     r7, #x_Base                             ; it is 'Base' data we're actually reading
        ADD     r1, r7,r7,ASL#1                         ; (iwidth * 3)
        LDR     r2, gb_fileptr                          ; start of image in Pac
        MLA     r2, r0,r1,r2
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        SWI     XOS_Args
        BVS     gb_returnerr

        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_setup
        ]

        BL      gb_savefileptr


        ; set up some buffer address pointers
        LDR     r0, gb_addr_lineoutbuf
        LDR     r1, = sizeof_lineoutbuf
        ADD     r0, r0,r1

        STR     r0, gb_addr_intlinebuffer
        LDR     r1, = sizeof_intlinebuffer
        ADD     r0, r0,r1
        STR     r0, gb_addr_tempbufC1
        LDR     r1, = sizeof_tempbufC
        ADD     r0, r0,r1
        STR     r0, gb_addr_tempbufC2
        ADD     r0, r0,r1

        STR     r0, gb_addr_Y4codetable


        ; calculate initial x read positions within line buffers

        LDR     r0, gb_bufY1
        ADD     r0, r0,r10                              ; yp1  -  Y ptr 1
        STR     r0, gb_yp1

        LDR     r0, gb_bufY2
        ADD     r0, r0,r10                              ; yp2  -  Y ptr 2
        STR     r0, gb_yp2

        LDR     r0, gb_bufC1
        ADD     r0, r0,r10,ASR#1                        ; c1p  -  C1 ptr 1
        STR     r0, gb_c1p

        LDR     r0, gb_bufC2
        ADD     r0, r0,r10,ASR#1                        ; c2p  -  C2 ptr 1
        STR     r0, gb_c2p

        LDR     r0, gb_buf2C1
        ADD     r0, r0,r10,ASR#1                        ; c12p  -  C1 ptr 2
        STR     r0, gb_c12p

        LDR     r0, gb_buf2C2
        ADD     r0, r0,r10,ASR#1                        ; c22p  -  C2 ptr 2
        STR     r0, gb_c22p


        ; calculate 'lastline' and 'lastpixel'
        ; - used for telling whether we are at the right or bottom extremity of the image
        LDR     r0, gb_iheight
        SUB     r0, r0,#4
        STR     r0, gb_lastline

        LDR     r0, gb_iwidth
        SUB     r0, r0,#1
        STR     r0, gb_lastpixel


        ; calculate the ptrs to the intermediate line buffers
        ; (the (half-resolution) 'Base' line data will be read
        ; into these buffers, then interpolated 2x into the
        ; 'real' line data buffers)
        ADR     r1, gb_bufY1i
        MOV     r7, #x_Base
        LDR     r2, gb_addr_intlinebuffer
        STR     r2, [r1],#4                             ; store pointer to bufY1i
        ADD     r4, r2,r7
        STR     r4, [r1],#4                             ; store pointer to bufY2i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to bufC1i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to bufC2i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to buf2Y1i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2Y2i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2C1i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1]                                ; store pointer to buf2C2i


        ; do some huffman setting up for the huffman decoding

        BL      huff_setup4                             ; set up code table vars etc
        MOVVS   r3, #0                                  ; if there was a problem, disable
        STRVS   r3, gb_dohuffman                        ;    the huffman stuff


        ; read in data for first line

        BL      gb_loadfileptr

        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_bufY1i
        MOV     r3, #x_Base
        ADD     r3, r3,r3,ASL#1                         ; (width * 3) (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?

        BL      gb_savefileptr



gbr4_yloop

        LDR     r1, gb_lastline
        CMP     r8, r1
        BGE     gbr4_dorows                             ; if on last line of image, don't read the (non-existing) next line


        BL      gb_loadfileptr

        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_buf2Y1i
        MOV     r3, #x_Base
        ADD     r3, r3,r3,ASL#1                         ; (width * 3) (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?

        BL      gb_savefileptr


gbr4_dorows

        LDR     r0, gb_skipfirstline                    ; do any rows need to be skipped?
        CMP     r0, #2                                  ; if y mod 4 = 2 or 3 then branch
        BLT     gbr4_ymod_0and1

        AND     r0, r0,#1                               ; even or odd row?
        STR     r0, gb_skipfirstline
        B       gbr4_ymod_2and3


        ; What we will do, is read the Base line data into intermediate buffers,
        ; and then interpolate from there into the main buffers, then we will
        ; use the row routines from the 'normal' resolutions above.
        ; The huffman residuals will be applied after we have generated a
        ; complete interpolated image.

gbr4_ymod_0and1

        ; --- interpolate the Y values
        LDR     r0, gb_bufY1
        LDR     r1, gb_bufY1i
        MOV     r2, #x_Base
        BL      gb_interp_pix                           ; interpolate bufY1 from bufY1i

        LDR     r0, gb_buf2Y1
        LDR     r1, gb_bufY2i
        BL      gb_interp_pix                           ; interpolate buf2Y1 from bufY2i

        LDR     r0, gb_bufY2                            ; interpolate row bufY2 from the
        LDR     r1, gb_bufY1                            ; previous and
        LDR     r2, gb_buf2Y1                           ; following rows
        LDR     r3, gb_iwidth
        BL      gb_interp_row

        ; --- interpolate the C1 values
        LDR     r0, gb_bufC1
        LDR     r1, gb_bufC1i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate bufC1 from bufC1i

        LDR     r0, gb_addr_tempbufC1
        LDR     r1, gb_buf2C1i
        BL      gb_interp_pix                           ; interpolate tempbufC1 from buf2C1i

        LDR     r0, gb_buf2C1                           ; interpolate row buf2C1 from the
        LDR     r1, gb_bufC1                            ; previous and
        LDR     r2, gb_addr_tempbufC1                   ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row

        ; --- interpolate the C2 values
        LDR     r0, gb_bufC2
        LDR     r1, gb_bufC2i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate bufC1 from bufC1i

        LDR     r0, gb_addr_tempbufC2
        LDR     r1, gb_buf2C2i
        BL      gb_interp_pix                           ; interpolate tempbufC1 from buf2C2i

        LDR     r0, gb_buf2C2                           ; interpolate row buf2C1 from the
        LDR     r1, gb_bufC2                            ; previous and
        LDR     r2, gb_addr_tempbufC2                   ; following rows
        BL      gb_interp_row


        LDR     r0, gb_skipfirstline                    ; does the first even row need to be skipped?
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNE   r0, gb_skipfirstline                    ; clear the flag for next time
        BNE     gbr4_ymod_1                             ; skip the even row

gbr4_ymod_0
        ; generate and write out row (Y mod 4) = 0
        BL      gbrn_do_even_row

        BL      huff_apply4                             ; apply huffman residuals

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number

        SUB     r6, r6,#1                               ; decrement 'lines to do'

gbr4_ymod_1
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr4_return                             ; none - interpolating finished

        ; generate and write out row (Y mod 4) = 1
        BL      gbrn_do_odd_row

        BL      huff_apply4                             ; apply huffman residuals

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number

        SUB     r6, r6,#1                               ; decrement 'lines to do'


        ; help out the mod2and3 section by giving them an interpolation
        ; that we have already done
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr4_return                             ; none - interpolating finished

        LDR     r0, gb_bufY1
        LDR     r1, gb_buf2Y1
        MOV     r2, #x_4Base                            ; (note: r2 needed for other '2and3' interp)
        MOV     r3, r2
gbr4_pre2and3_loop
        LDR     lr, [r1],#4
        STR     lr, [r0],#4
        SUBS    r3, r3,#4
        BGT     gbr4_pre2and3_loop

        B       gbr4_y23_2ndYinterp



gbr4_ymod_2and3

        CMP     r6, #0                                  ; lines remaining
        BLE     gbr4_return                             ; none - interpolating finished


        ; --- interpolate the Y values
        LDR     r0, gb_bufY1
        LDR     r1, gb_bufY2i
        MOV     r2, #x_Base
        BL      gb_interp_pix                           ; interpolate bufY1 from buf2Y1i

gbr4_y23_2ndYinterp
        LDR     r0, gb_buf2Y1
        LDR     r1, gb_buf2Y1i
        BL      gb_interp_pix                           ; interpolate buf2Y1 from buf2Y2i

        LDR     r0, gb_bufY2                            ; interpolate row bufY2 from the
        LDR     r1, gb_bufY1                            ; previous and
        LDR     r2, gb_buf2Y1                           ; following rows
        LDR     r3, gb_iwidth
        BL      gb_interp_row

        ; --- interpolate the C1 values
        LDR     r0, gb_addr_tempbufC1
        LDR     r1, gb_bufC1i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate tempbufC1 from bufC1i

        LDR     r0, gb_buf2C1
        LDR     r1, gb_buf2C1i
        BL      gb_interp_pix                           ; interpolate buf2C1 from buf2C1i

        LDR     r0, gb_bufC1                            ; interpolate row bufC1 from the
        LDR     r1, gb_addr_tempbufC1                   ; previous and
        LDR     r2, gb_buf2C1                           ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row

        ; --- interpolate the C2 values
        LDR     r0, gb_addr_tempbufC2
        LDR     r1, gb_bufC2i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate tempbufC2 from bufC2i

        LDR     r0, gb_buf2C2
        LDR     r1, gb_buf2C2i
        BL      gb_interp_pix                           ; interpolate buf2C2 from buf2C2i

        LDR     r0, gb_bufC2                            ; interpolate row bufC2 from the
        LDR     r1, gb_addr_tempbufC2                   ; previous and
        LDR     r2, gb_buf2C2                           ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row


        LDR     r0, gb_skipfirstline                    ; does the first even row need to be skipped?
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNE   r0, gb_skipfirstline                    ; clear the flag for next time
        BNE     gbr4_ymod_3                             ; skip the even row

gbr4_ymod_2
        ; generate and write out row (Y mod 4) = 2
        BL      gbrn_do_even_row

        BL      huff_apply4                             ; apply huffman residuals

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number

        SUB     r6, r6,#1                               ; decrement 'lines to do'

gbr4_ymod_3
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr4_return                             ; none - interpolating finished

        ; generate and write out row (Y mod 4) = 3
        BL      gbrn_do_odd_row

        BL      huff_apply4                             ; apply huffman residuals

        LDR     r3, gb_numpixels                        ; number of pixels to output
        BL      gb_outputrow                            ; output the row in the appropriate format

        LDR     r2, gb_rowinc
        ADD     r5, r5,r2                               ; increment out pointer to start of next row

        ADD     r8, r8,#1                               ; increment line number


        ; copy 'next input line' down into 'current input line'
        LDR     r0, gb_bufY1i
        LDR     r1, gb_buf2Y1i
        MOV     r2, #x_Base                             ; (width * 3) bytes will be copied
        copybuffer3x  r0,r1,r2


        SUBS    r6, r6,#1                               ; decrement 'lines to do'
        BGT     gbr4_yloop



gbr4_return
        LDMFD   sp!, {r0-r9, pc}^



        ;- - - - - - - - - - - - - - - - - - - - - - - -


        LTORG


        ;- - - - - - - - - - - - - - - - - - - - - - - -



gb_interp_pix
        ; Create a double length row (at r0) from the pixels at r1
        ; The extra inbetween pixels are interpolated
        ; r2 = number of pixels in the source buffer

        STMFD   sp!, {r2-r4, lr}

        LDRB    r3, [r1],#1
        SUB     r2, r2,#1
gbip_loop
        LDRB    r4, [r1],#1

        STRB    r3, [r0],#1                             ; store the first byte of the pair

        ADD     r3, r3,r4                               ; average the two values
        MOVS    r3, r3,ASR#1
        ADDCS   r3, r3,#1
        STRB    r3, [r0],#1                             ; store the interpolated value

        MOV     r3, r4

        SUBS    r2, r2,#1                               ; decrement count
        BGT     gbip_loop                               ; if count > 0 loop again

        ; for last byte there is no 'next' so just copy it
        STRB    r3, [r0],#1
        STRB    r3, [r0],#1

        LDMFD   sp!, {r2-r4, pc}^



        ;- - - - - - - - - - - - - - - - - - - - - - - -



gb_interp_row
        ; create a row (at r0) that consists of pixels interpolated
        ; from the pixels in the rows pointed to by r1 and r2
        ; r3 = number of pixels to do

        STMFD   sp!, {r3-r5, lr}

gbir_loop
        LDRB    r4, [r1],#1
        LDRB    r5, [r2],#1

        ADD     r4, r4,r5                               ; average the two values
        MOVS    r4, r4,ASR#1
        ADDCS   r4, r4,#1

        STRB    r4, [r0],#1                             ; store the interpolated value

        SUBS    r3, r3,#1                               ; decrement count
        BGT     gbir_loop                               ; if count > 0 loop again

        LDMFD   sp!, {r3-r5, pc}^



;-----------------------------------------------------------------------------------



gb_savefileptr

; Save file pointer
; (in anticipation of doing some huffman decoding)

        STMFD   sp!, {r0-r2, lr}

        ; save where we are in file
        MOV     r0, #0
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        SWI     XOS_Args
        STRVC   r2, gb_fileptr

        LDMFD   sp!, {r0-r2, pc}



;-----------------------------------------------------------------------------------



gb_loadfileptr

; Restore file pointer
; (in anticipation of reading some more (non-huffman) data)

        STMFD   sp!, {r0-r2, lr}

        ; set file pointer to where we were
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]               ; image pac file handle
        LDR     r2, gb_fileptr
        SWI     XOS_Args

        LDMFD   sp!, {r0-r2, pc}





;===================================================================================
;       Read a 16Base image
;===================================================================================


sizeof_extrabuf1   *   (4*3*x_4Base)
sizeof_linoutbuftmp *  (3*x_16Base)
sizeof_extrabufs   *   (sizeof_extrabuf1 + sizeof_linoutbuftmp*2)



gb_read_16Base
        ; r2 = bufY1
        ; r4 = resolution step
        ; r5 = output pointer
        ; r7 = iwidth
        ; r8-r11 = y0,y1,x0,x1

        ; For 16Base images we basically use a modified version of the
        ; 4Base reading code, in which we write four lines at a time into
        ; a buffer, and then do the necessary interpolations and residual
        ; applying to the values in that buffer.


        ; Try and claim the extra buffer we will need
        ; We will only claim it once (we won't bother freeing it afterwards)
        LDR     r0, gb_addr_4Basebuf
        TEQ     r0, #0
        BNE     gbr16_bufclaimed

        MOV     r0, #6                                  ; Claim workspace
        MOV     r3, #sizeof_extrabufs                   ; four lines of 4Base data needed
                                                        ; ..plus one to hold the last/prev
                                                        ;   line so we can do the last inter-
                                                        ;   polation when the new chunk is read
        SWI     XOS_Module
        STRVS   r0, [sp]                                ; return error message
        LDMVSFD sp!, {r0-r9, pc}

        STR     r2, gb_addr_4Basebuf                    ; save address of 4-line chunk buffer
        ADD     r2, r2,#sizeof_extrabuf1
        STR     r2, gb_addr_lineoutbuftmp2              ; save address of the temp 16Base-line buffer
        ADD     r2, r2,#sizeof_linoutbuftmp
        STR     r2, gb_addr_lineoutbuftmp3              ; save address of the temp 16Base-line buffer


gbr16_bufclaimed

        MOV     r2, #0                                  ; clear this count to 0
        STR     r2, gb_reallinestodo                    ; (properly set up in 'huff_apply16')


        ; convert the 16Base coords to 4Base equivalents for the reading routines
        MOV     r8, r8,ASR#1
        STR     r8, gb_firstline

        MOV     r9, r9,ASR#1
        CMP     r9, #y_4Base                            ; if y1 < height of 4Base then add
        ADDLT   r9, r9,#1                               ; one pixel on (needed to interpolate
                                                        ; the second row at the high resolution)

        SUB     r6, r9,r8                               ; lines to read

        MOV     r10, r10,ASR#1
        STR     r10, gb_firstpixel

        MOV     r11, r11,ASR#1
        CMP     r11, #x_4Base                           ; if x1 < width of 4Base then add
        ADDLT   r11, r11,#1                             ; one pixel on (needed to interpolate
                                                        ; the second pixel at the high resolution)

        SUB     r0, r11,r10                             ; number of pixels that need to be done
        STR     r0, gb_numpixels                        ;    in each row


        AND     r0, r8,#3                               ; y0 mod 8
        STR     r0, gb_skipfirstline                    ; first even row gets skipped


        ; calculate file pointer offset to read from
        ; (note: 'Base' data forms the basis of this resolution)
        MOV     r0, r8,ASR#2                            ; (y0 DIV 2) / 2
        MOV     r7, #x_Base                             ; it is 'Base' data we're actually reading
        ADD     r1, r7,r7,ASL#1                         ; (iwidth * 3)
        LDR     r2, gb_fileptr                          ; start of image in Pac
        MLA     r2, r0,r1,r2
        MOV     r0, #1
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        SWI     XOS_Args
        BVS     gb_returnerr

        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_setup
        ]

        BL      gb_savefileptr


        ; set up some buffer address pointers
        LDR     r0, gb_addr_lineoutbuf
        STR     r0, gb_addr_lineoutbufsave              ; preserve this pointer elsewhere as the
                                                        ; 'real' one will be mucked about with
        LDR     r1, = sizeof_lineoutbuf
        ADD     r0, r0,r1

        STR     r0, gb_addr_intlinebuffer
        LDR     r1, = sizeof_intlinebuffer
        ADD     r0, r0,r1
        STR     r0, gb_addr_tempbufC1
        LDR     r1, = sizeof_tempbufC
        ADD     r0, r0,r1
        STR     r0, gb_addr_tempbufC2
        ADD     r0, r0,r1

        STR     r0, gb_addr_Y4codetable
        LDR     r1, = sizeof_huffcodetable
        ADD     r0, r0,r1
        STR     r0, gb_addr_Ycodetable
        ADD     r0, r0,r1
        STR     r0, gb_addr_C1codetable
        ADD     r0, r0,r1
        STR     r0, gb_addr_C2codetable


        ; calculate initial x read positions within line buffers

        LDR     r0, gb_bufY1
        ADD     r0, r0,r10                              ; yp1  -  Y ptr 1
        STR     r0, gb_yp1

        LDR     r0, gb_bufY2
        ADD     r0, r0,r10                              ; yp2  -  Y ptr 2
        STR     r0, gb_yp2

        LDR     r0, gb_bufC1
        ADD     r0, r0,r10,ASR#1                        ; c1p  -  C1 ptr 1
        STR     r0, gb_c1p

        LDR     r0, gb_bufC2
        ADD     r0, r0,r10,ASR#1                        ; c2p  -  C2 ptr 1
        STR     r0, gb_c2p

        LDR     r0, gb_buf2C1
        ADD     r0, r0,r10,ASR#1                        ; c12p  -  C1 ptr 2
        STR     r0, gb_c12p

        LDR     r0, gb_buf2C2
        ADD     r0, r0,r10,ASR#1                        ; c22p  -  C2 ptr 2
        STR     r0, gb_c22p


        ; calculate 'lastline' and 'lastpixel'
        ; - used for telling whether we are at the right or bottom extremity of the image
        MOV     r0, #y_4Base
        SUB     r0, r0,#4
        STR     r0, gb_lastline

        MOV     r0, #x_4Base
        SUB     r0, r0,#1
        STR     r0, gb_lastpixel


        ; calculate the ptrs to the intermediate line buffers
        ; (the (quarter-resolution) 'Base' line data will be read
        ; into these buffers, then interpolated 2x into the
        ; 'real' line data buffers)
        ADR     r1, gb_bufY1i
        MOV     r7, #x_Base
        LDR     r2, gb_addr_intlinebuffer
        STR     r2, [r1],#4                             ; store pointer to bufY1i
        ADD     r4, r2,r7
        STR     r4, [r1],#4                             ; store pointer to bufY2i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to bufC1i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to bufC2i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1],#4                             ; store pointer to buf2Y1i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2Y2i
        ADD     r4, r4,r7
        STR     r4, [r1],#4                             ; store pointer to buf2C1i
        ADD     r4, r4,r7,ASR#1
        STR     r4, [r1]                                ; store pointer to buf2C2i


        ; do some huffman setting up for the huffman decoding

        BL      huff_setup4
        BLVC    huff_setup16                            ; set up code table vars etc
        MOVVS   r3, #0                                  ; if there was a problem, disable
        STRVS   r3, gb_dohuffman                        ;    the huffman stuff


        ; read in data for first line

        BL      gb_loadfileptr

        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_bufY1i
        MOV     r3, #x_Base
        ADD     r3, r3,r3,ASL#1                         ; (width * 3) (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?

        BL      gb_savefileptr



gbr16_yloop

        LDR     r1, gb_lastline
        CMP     r8, r1
        BGE     gbr16_dorows                             ; if on last line of image, don't read the (non-existing) next line


        BL      gb_loadfileptr

        MOV     r0, #4
        LDR     r1, gb_pcdhandle                        ; get image pac handle
        LDR     r1, [r1, #pcd_filehandle]
        LDR     r2, gb_buf2Y1i
        MOV     r3, #x_Base
        ADD     r3, r3,r3,ASL#1                         ; (width * 3) (Y + Y + C/2 + C/2)
        [       Switch_ReadAheadBufferEnabled
        BL      gbubuf_gbpb
        |
        SWI     XOS_GBPB
        ]
        BVS     gb_returnerr
        ; CS if not all bytes transferred, do anything for this?

        BL      gb_savefileptr


gbr16_dorows

        LDR     r9, gb_addr_4Basebuf                    ; get pointer to special buffer

        LDR     r0, gb_skipfirstline                    ; do any rows need to be skipped?
        CMP     r0, #2                                  ; if y mod 4 = 2 or 3 then branch
        BLT     gbr16_ymod_0and1

        AND     r0, r0,#1                               ; even or odd row?
        STR     r0, gb_skipfirstline
        B       gbr16_ymod_2and3


        ; What we will do, is read the Base line data into intermediate buffers,
        ; and then interpolate from there into the main buffers, then we will
        ; use the row routines from the 'normal' resolutions above.
        ; The huffman residuals will be applied after we have generated a
        ; complete interpolated image.

gbr16_ymod_0and1

        ; --- interpolate the Y values
        LDR     r0, gb_bufY1
        LDR     r1, gb_bufY1i
        MOV     r2, #x_Base
        BL      gb_interp_pix                           ; interpolate bufY1 from bufY1i

        LDR     r0, gb_buf2Y1
        LDR     r1, gb_bufY2i
        BL      gb_interp_pix                           ; interpolate buf2Y1 from bufY2i

        LDR     r0, gb_bufY2                            ; interpolate row bufY2 from the
        LDR     r1, gb_bufY1                            ; previous and
        LDR     r2, gb_buf2Y1                           ; following rows
        LDR     r3, gb_iwidth
        BL      gb_interp_row

        ; --- interpolate the C1 values
        LDR     r0, gb_bufC1
        LDR     r1, gb_bufC1i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate bufC1 from bufC1i

        LDR     r0, gb_addr_tempbufC1
        LDR     r1, gb_buf2C1i
        BL      gb_interp_pix                           ; interpolate tempbufC1 from buf2C1i

        LDR     r0, gb_buf2C1                           ; interpolate row buf2C1 from the
        LDR     r1, gb_bufC1                            ; previous and
        LDR     r2, gb_addr_tempbufC1                   ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row

        ; --- interpolate the C2 values
        LDR     r0, gb_bufC2
        LDR     r1, gb_bufC2i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate bufC1 from bufC1i

        LDR     r0, gb_addr_tempbufC2
        LDR     r1, gb_buf2C2i
        BL      gb_interp_pix                           ; interpolate tempbufC1 from buf2C2i

        LDR     r0, gb_buf2C2                           ; interpolate row buf2C1 from the
        LDR     r1, gb_bufC2                            ; previous and
        LDR     r2, gb_addr_tempbufC2                   ; following rows
        BL      gb_interp_row


        LDR     r0, gb_skipfirstline                    ; does the first even row need to be skipped?
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNE   r0, gb_skipfirstline                    ; clear the flag for next time
        BNE     gbr16_ymod_1                             ; skip the even row

gbr16_ymod_0
        ; generate and write out row (Y mod 4) = 0

        STR     r9, gb_addr_lineoutbuf                  ; fool following routines into writing to the
                                                        ; special buffer
        BL      gbrn_do_even_row

        BL      huff_apply4                             ; apply huffman residuals

        ADD     r8, r8,#1                               ; increment line number
        SUB     r6, r6,#1                               ; decrement 'lines to do'
        ADD     r9, r9,#(3 * x_4Base)                   ; increment special buffer pointer

gbr16_ymod_1
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr16_apply16andloop                    ; none - interpolating finished

        ; generate and write out row (Y mod 4) = 1

        STR     r9, gb_addr_lineoutbuf                  ; fool following routines into writing to the
                                                        ; special buffer
        BL      gbrn_do_odd_row

        BL      huff_apply4                             ; apply huffman residuals

        ADD     r8, r8,#1                               ; increment line number
        SUB     r6, r6,#1                               ; decrement 'lines to do'
        ADD     r9, r9,#(3 * x_4Base)                   ; increment special buffer pointer


        ; help out the mod2and3 section by giving them an interpolation
        ; that we have already done
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr16_apply16andloop                    ; none - interpolating finished

        LDR     r0, gb_bufY1
        LDR     r1, gb_buf2Y1
        MOV     r2, #x_Base                             ; (note: r2 needed for other '2and3' interp)
        MOV     r3, r2
gbr16_pre2and3_loop
        LDR     lr, [r1],#4
        STR     lr, [r0],#4
        SUBS    r3, r3,#2                               ; (only dec by 2 because count is halfsize)
        BGT     gbr16_pre2and3_loop

        B       gbr16_y23_2ndYinterp



gbr16_ymod_2and3

        CMP     r6, #0                                  ; lines remaining
        BLE     gbr16_apply16andloop                    ; none - interpolating finished


        ; --- interpolate the Y values
        LDR     r0, gb_bufY1
        LDR     r1, gb_bufY2i
        MOV     r2, #x_Base
        BL      gb_interp_pix                           ; interpolate bufY1 from buf2Y1i

gbr16_y23_2ndYinterp
        LDR     r0, gb_buf2Y1
        LDR     r1, gb_buf2Y1i
        BL      gb_interp_pix                           ; interpolate buf2Y1 from buf2Y2i

        LDR     r0, gb_bufY2                            ; interpolate row bufY2 from the
        LDR     r1, gb_bufY1                            ; previous and
        LDR     r2, gb_buf2Y1                           ; following rows
        LDR     r3, gb_iwidth
        BL      gb_interp_row

        ; --- interpolate the C1 values
        LDR     r0, gb_addr_tempbufC1
        LDR     r1, gb_bufC1i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate tempbufC1 from bufC1i

        LDR     r0, gb_buf2C1
        LDR     r1, gb_buf2C1i
        BL      gb_interp_pix                           ; interpolate buf2C1 from buf2C1i

        LDR     r0, gb_bufC1                            ; interpolate row bufC1 from the
        LDR     r1, gb_addr_tempbufC1                   ; previous and
        LDR     r2, gb_buf2C1                           ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row

        ; --- interpolate the C2 values
        LDR     r0, gb_addr_tempbufC2
        LDR     r1, gb_bufC2i
        MOV     r2, #x_Base4                            ; (chromas are half the size)
        BL      gb_interp_pix                           ; interpolate tempbufC2 from bufC2i

        LDR     r0, gb_buf2C2
        LDR     r1, gb_buf2C2i
        BL      gb_interp_pix                           ; interpolate buf2C2 from buf2C2i

        LDR     r0, gb_bufC2                            ; interpolate row bufC2 from the
        LDR     r1, gb_addr_tempbufC2                   ; previous and
        LDR     r2, gb_buf2C2                           ; following rows
        MOV     r3, r3,ASR#1                            ; (half the number of bytes for chromas)
        BL      gb_interp_row


        LDR     r0, gb_skipfirstline                    ; does the first even row need to be skipped?
        TEQ     r0, #0
        MOVNE   r0, #0
        STRNE   r0, gb_skipfirstline                    ; clear the flag for next time
        BNE     gbr16_ymod_3                             ; skip the even row

gbr16_ymod_2
        ; generate and write out row (Y mod 4) = 2

        STR     r9, gb_addr_lineoutbuf                  ; fool following routines into writing to the
                                                        ; special buffer
        BL      gbrn_do_even_row

        BL      huff_apply4                             ; apply huffman residuals

        ADD     r8, r8,#1                               ; increment line number
        SUB     r6, r6,#1                               ; decrement 'lines to do'
        ADD     r9, r9,#(3 * x_4Base)                   ; increment special buffer pointer

gbr16_ymod_3
        CMP     r6, #0                                  ; lines remaining
        BLE     gbr16_apply16andloop                    ; none - interpolating finished

        ; generate and write out row (Y mod 4) = 3

        STR     r9, gb_addr_lineoutbuf                  ; fool following routines into writing to the
                                                        ; special buffer
        BL      gbrn_do_odd_row

        BL      huff_apply4                             ; apply huffman residuals

        ADD     r8, r8,#1                               ; increment line number
        SUB     r6, r6,#1                               ; decrement 'lines to do'
        ADD     r9, r9,#(3 * x_4Base)                   ; increment special buffer pointer


        ; copy 'next input line' down into 'current input line'
        LDR     r0, gb_bufY1i
        LDR     r1, gb_buf2Y1i
        MOV     r2, #x_Base                             ; (width * 3) bytes will be copied
        copybuffer3x  r0,r1,r2


gbr16_apply16andloop

        BL      huff_apply16                            ; process the (up to) 4 lines of 4Base data


        CMP     r6, #0                                  ; check 'lines to do'
        BGT     gbr16_yloop



gbr16_return
        LDMFD   sp!, {r0-r9, pc}^



        ;- - - - - - - - - - - - - - - - - - - - - - - -


        LTORG


;-----------------------------------------------------------------------------------


        GET     s.gbubuf

        LNK     s.huff          ; get the huffman related routines

