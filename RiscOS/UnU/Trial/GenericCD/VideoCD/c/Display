/*=====================================================================================*/
/*                                                                                     */
/*  FILE:         !VideoCD.c.Display                                                   */
/*  DESCRIPTION:  Routines for creating and displaying a selection screen.  Not        */
/*                applicable when there is only one MPEG clip on the cd, the exception */
/*                to this being CursorsOff().                                          */
/*  AUTHOR:       crose@omi.co.uk                                                      */
/*  MODIFICATION HISTORY:                                                              */
/*    Date         Name                Description                                     */
/*    ----         ----                -----------                                     */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#undef  GLOBALS__

#include "common.h"
#include "display.h"
#include "stdio.h"
#include "string.h"
#include "swicall.h"

#ifdef MEMORY_TRACE
  #include "Memory.h"
#endif

#define OLD_TWITTER   /* OLD_TWITTER means that the old twitter module will be used.   */
                      /* NEW_TWITTER means that the new twitter module will be used.   */
                      /* Undefining OLD_TWITTER or NEW_TWITTER will result in no       */
                      /* twitter being applied.                                        */
                      /* Currently, the new twitter module is apparantly working, but  */
                      /* had no effect when used from within !AudioCD.                 */

#undef LOW_MEM        /* Defining LOW_MEM means that the JPEG backdrop image is scaled */
                      /* up whilst plotting to the screen and the shadow sprite for    */
                      /* holding it after reading it in from file and before plotting  */
                      /* to the screen, is the same size as the originally supplied    */
                      /* JPEG (i.e. smaller than screen size unless the original JPEG  */
                      /* is coincidentally the same size as the screen).  Undefining   */
                      /* LOW_MEM means that the JPEG is scaled up immediately when     */
                      /* read into the shadow sprite buffer and therefore the shadow   */
                      /* sprite buffer will most likely be larger than otherwise.  The */
                      /* advantage of doing this however, is that anti-twitter can be  */
                      /* applied before plotting to the screen because the image is    */
                      /* already screen size.                                          */

                      /* LOW_MEM defined requires some tidying up in terms of text     */
                      /* plotting positions, title rubout areas and so on.  Also need  */
                      /* to test supplying different sized JPEG backdrops.             */


static int xres,yres,xeig,yeig;
static int original_JPEG_pixel_width;
static int original_JPEG_pixel_height;

/*-------------------------------------------------------------------------------------*/
/*                            Internal Function Prototypes.                            */
/*-------------------------------------------------------------------------------------*/

static void ScreenDimensions(void);
static void CreateScreenDisplay(int *dma_id,int MPEG_file_count,
       struct coords *text_positions,char *title_list,int max_titles,
       struct rubout_buffer r[5],char **sprarea,int current_first_title_displayed);
static void ReadJPEGDimensions(void);
static int PrepareShadowSprite(int shadowsize,int MPEG_file_count,
       struct coords *text_positions,char *title_list,int max_titles,
       struct rubout_buffer r[5],char **sprarea,int current_first_title_displayed);
static void JPEGOverlay(char *jpegfile,char *sprarea);
static void TextOverlayWithoutTitles(int MPEG_file_count,char *sprarea,
       struct coords *text_positions);
static void ShowScreenDisplay(int dma_id,char *sprarea);
static void PlotCircles (struct coords *positions,int n);
static void ShowTitles(int start_from,char *title_list,int max_titles,
       struct coords *text_pos);
static int Fonts(char *font_name,int x_pt_size,int y_pt_size,int bkgrnd,int foregrnd);
static void InitTitlesRubout(struct rubout_buffer r[5],struct coords *text_positions);
static void PrintTitle(struct coords screen_pos,char *title);
static char * LocateNextTitle(char *buffer_index,char *buffer);
static void OverlayScrollArrows(struct coords *positions);
static void FillCoordsArray(struct coords *a,int index_start,int index_end,int x_inc,
       int y_dec,int x_start_val,int y_start_val);

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  SelectionScreen()                                                       */
/*  BEHAVIOUR: Creates and displays MPEG clip selection screen.  Not applicable if     */
/*             only one MPEG clip was found.  A scroll display is used if titles were  */
/*             found (on some music video cd's).  Otherwise the display is non         */
/*             scrolling and is made up of numbers only.                               */
/*  REQUIRES:  - 'MPEG_file_count', which is the number of MPEG files found on the cd. */
/*             - 'text_positions', which tells us where to plot text on the screen.    */
/*             - 'title_list', which is a null separator list of titles found, or NULL */
/*                if none were found during initialisation.                            */
/*             - 'max_titles', which is the number of titles in the titles list.       */
/*             - 'r', which is used for rubbing out titles when scrolling.             */
/*             - 'current_first_title_displayed', which indicates which of the titles  */
/*                in the title list is the first one displayed on the screen.          */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void SelectionScreen(int MPEG_file_count,struct coords *text_positions,                                       char *title_list,int max_titles,
                           struct rubout_buffer r[5],int current_first_title_displayed)
{
 int dma_id;
 char *sprarea = NULL;

   #ifdef FN_TRACE
     puts("SelectionScreen()");
   #endif

   CursorsOff();

   ScreenDimensions();

   CreateScreenDisplay(&dma_id,MPEG_file_count,text_positions,title_list,max_titles,r,
                       &sprarea,current_first_title_displayed);

   ShowScreenDisplay(dma_id,sprarea);

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  CreateScreenDisplay()                                                   */
/*  BEHAVIOUR: Creates a selection menu ready for plotting on the screen.              */
/*  REQUIRES:  - 'dma_id', which will be returned as the dynamic memory area no. for   */
/*                the shadow screen sprite.                                            */
/*             - 'MPEG_file_count', which is the number of MPEG files found on the cd. */
/*             - 'text_positions', which tells us where to plot the clip titles or     */
/*                title numbers.                                                       */
/*             - 'title_list', which is NULL if there aren't any titles.  Otherwise    */
/*                it's a null separator list of clip titles.                           */
/*             - 'max_titles', which is the no. of titles in the title list, if title  */
/*                list is not NULL.                                                    */
/*             - 'r', which is a 5 element array to be returned holding title back-    */
/*                grounds.  Used for erasing titles during scrolling (if titles exist) */
/*             - 'sprarea', which is the address of a pointer to the shadow screen     */
/*                sprite area.                                                         */
/*             - 'current_first_title_displayed', which identifies which title in the  */
/*                title list is the first one to be displayed on screen.  Irrelevant   */
/*                if there aren't any titles.                                          */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void CreateScreenDisplay(int *dma_id,int MPEG_file_count,
       struct coords *text_positions,char *title_list,int max_titles,
       struct rubout_buffer r[5],char **sprarea,int current_first_title_displayed)
{
   #ifdef FN_TRACE
     puts("CreateScreenDisplay()");
   #endif

   ReadJPEGDimensions();

   #ifdef LOW_MEM
      *dma_id = PrepareShadowSprite((original_JPEG_pixel_width*original_JPEG_pixel_height
                                     * 2)+16+300,MPEG_file_count,text_positions,
                                     title_list,max_titles,r,&(*sprarea),
                                     current_first_title_displayed);
   #else
      *dma_id = PrepareShadowSprite((xres*yres*2)+16+300,MPEG_file_count,text_positions,
                                     title_list,max_titles,r,&(*sprarea),
                                     current_first_title_displayed);
   #endif

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ShowScreenDisplay()                                                     */
/*  BEHAVIOUR: Plots shadow sprite to the screen.  Whether or not rescaling takes      */
/*             place at this stage depends upon the value of LOW_MEM, which is defined */
/*             and described at the start of this file.                                */
/*  REQUIRES:  - dma_id, via which the dynamic memory area containing the shadow       */
/*               sprite is accessed.                                                   */
/*             - 'shadow_screen_base', which points to the shadow control block (refer */
/*               PRM p.1-749).                                                         */
/*             - 'first_sprite_offset', which is the address of the sprite itself      */
/*               (refer PRM p.1-749).                                                  */
/*  PREREQUISITES: 'xres',and'yres', must have been initialised with a call to         */
/*                  ScreenDimensions().                                                */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ShowScreenDisplay(int dma_id,char *sprarea)
{
 int *scale = 0;
 int vdublk[2];
 int scrstart;     /* Start address of screen memory.                                  */
 int linelen;      /* Offset from a point on a line to the same point on the line      */
                   /* below.  For mode 50 this number will look ridiculous but it is   */
                   /* correct.                                                         */
 _kernel_oserror *err = NULL;
 #define STBFilter_FilterArea 0x84000

   #ifdef FN_TRACE
     puts("ShowScreenDisplay()");
   #endif

   #ifdef LOW_MEM
       if ((scale = malloc(16)) == NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",0,
            "Insufficient Memory.",FATAL);
   #endif

   /* Anti-twitter preparation.                                                        */

   vdublk[0] = 148;
   vdublk[1] = -1;
   if ((err = swi(OS_ReadVduVariables,R0,vdublk,R1,vdublk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);
   scrstart = vdublk[0];
   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,6,OUT,R2,&linelen,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);


   /* Scale factors.  Refer PRM p. 1-752.  Note that the scale factors are in pixels,  */
   /* not in OS coordinates.                                                           */

   #ifdef LOW_MEM
       *scale = xres;
       *(scale + 1) = yres;
       *(scale + 2) = original_JPEG_pixel_width;
       *(scale + 3) = original_JPEG_pixel_height;
   #endif

  /* Apply anti-twitter if LOW_MEM is not defined.  If LOW_MEM is defined, unless the  */
  /* original JPEG has the same dimensions as the screen, the image won't be of screen */
  /* size.  Anti-twitter should only be applied once the image is screen size.         */
  /* Hence if LOW_MEM is defined, anti-twitter is applied to screen memory later on    */
  /* *after* the image has been scaled up on the screen.                               */

   #ifndef LOW_MEM

       #ifdef NEW_TWITTER

         #error NEW_TWITTER without LOW_MEM doesn't work yet

          /* Anti-twitter the shadow sprite in place.
           * (int)sprarea + 16 holds the address of the sprite's control block.
           * The offset from the control block to the sprite image is held in the word
           * at byte 32 of the control block.
           */
          if ((err = swi(STBFilter_FilterArea,
                         R0,((int)sprarea + 16) +
                         *(((int *) ((int)sprarea + 16))+8),
                         R1,((int) sprarea + 16) +
                         *(((int *) ((int)sprarea + 16))+8),
                         R2,yres, R3,xres, R4,xres, R5,xres, R6,4, END))!=NULL)
               ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,
               err->errmess,WARNING);

          #ifdef DEVELOPMENT
            printf("area:%p, sprite:%p, image:%p, xres:%x, yres:%x\n",
            (int*) sprarea, (int*)((int)sprarea + 16),
            (int*) (((int)sprarea + 16) +
            *(((int *) ((int)sprarea + 16))+8)), xres, yres);
          #endif

       #endif

       #ifdef OLD_TWITTER
       if ((err = swi(STBFilter_FilterArea,
                      R0,((int)sprarea + 16) +
                      *(((int *) ((int)sprarea + 16))+8),
                      R1,xres*2, R2,xres, R3,yres, R4,0, R5,0,R6,xres,R7,yres,END))
                      != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,
            err->errmess,WARNING);

          #ifdef DEVELOPMENT
            printf("area:%p, sprite:%p, image:%p, xres:%x, yres:%x\n",
            (int*) sprarea, (int*)((int)sprarea + 16),
            (int*) (((int)sprarea + 16) +
            *(((int *) ((int)sprarea + 16))+8)), xres, yres);
          #endif

       #endif

   #endif

   if ((err = swi(OS_SpriteOp,R0,512+52,R1,sprarea+16,R2,
        (int)sprarea + 16,R3,0,R4,0,R5,0,R6,scale,R7,0,END))!=NULL)
          ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
          FATAL);

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif


   /* Anti-twitter.  If LOW_MEM is defined, anti-twitter must be applied after         */
   /* plotting to the screen (because before that the image is not the right size).    */
   /* If LOW_MEM is not defined, anti-twitter will have been applied earlier on prior  */
   /* to the screen plot.                                                              */

   #ifdef LOW_MEM

     #ifdef OLD_TWITTER
     if ((err = swi(STBFilter_FilterArea,R0,scrstart,R1,linelen,R2,xres,R3,yres,R4,0,R5,
          0,R6,xres,R7,yres,END)) != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,
            err->errmess,WARNING);
     #endif

     #ifdef NEW_TWITTER
       #error NEW_TWITTER with LOW_MEM doesn't work yet
     if ((err = swi(STBFilter_FilterArea,R0,scrstart,R1,scrstart,R2,yres,R3,linelen,R4,
          linelen,R5,xres,R6,4,END)) != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,
            err->errmess,WARNING);
     #endif

   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Remove the dynamic memory area which was used for holding the shadow sprite.     */
   if ((err = swi(OS_DynamicArea,R0,1,R1,dma_id,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
        FATAL);

   #ifdef LOW_MEM
      free(scale);
   #endif

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  PrepareShadowSprite()                                                   */
/*  BEHAVIOUR: Prepares an MPEG selection screen sprite in the current screen mode,    */
/*             with scrolling titles if there are any, or number only without          */
/*             scrolling if there aren't any titles.                                   */
/*  REQUIRES:  - 'shadowsize', which is the size of the sprite area required.          */
/*             - 'MPEG_file_count', which is the no. of MPEG files found on the cd.    */
/*             - 'text_positions', which gives us text plotting positions.             */
/*             - 'title_list', which is a null separator list of titles, or NULL if    */
/*                there aren't any titles.                                             */
/*             - 'max_titles', which tells us how many titles are in the title list,   */
/*                if the title list is not NULL.                                       */
/*             - 'r', which is a 5 element array to be returned for later use in       */
/*                erasing displayed titles during scrolling.                           */
/*             - 'sprarea', which is the address of a pointer to the selection shadow  */
/*                screen sprite area.                                                  */
/*             - 'current_first_title_displayed', which identifies which title in the  */
/*                title list is the first one to be displayed on screen (could change  */
/*                later as a result of scrolling).                                     */
/*  RETURNS:   dynamic memory area for the shadow sprite.                              */
/*  ASSUMPTIONS: 16bpp screen mode.                                                    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int PrepareShadowSprite(int shadowsize,int MPEG_file_count,
                               struct coords *text_positions,
                               char *title_list,int max_titles,struct rubout_buffer r[5],
                               char **sprarea,int current_first_title_displayed)
{
 int shadow_area_id;
 int *ptr;
 int base_check;
 int size_check;
 int width,height;
 _kernel_oserror *err = NULL;
 int spritemode;
 int max_check;
 int oldscb,oldsptr,oldsa;

   #ifdef FN_TRACE
     puts("PrepareShadowSprite()");
   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Find out the current screen mode.  The sprite will be created in that mode.      */
   if ((err = swi(OS_ScreenMode,R0,1,OUT,R1,&spritemode,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
        FATAL);

   /* Create the dynamic area.                                                         */
   if ((err = swi(OS_DynamicArea,R0,0,R1,-1,R2,shadowsize,R3,-1,R4,0,R5,shadowsize,R6,0,
        R7,0,R8,"shadow",OUT,R1,&shadow_area_id,R3,&(*sprarea),END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
         FATAL);

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Check that it hasn't created a dynamic area of size zero, this being a known bug */
   /* in the past.                                                                     */

   if ((err = swi(OS_DynamicArea,R0,2,R1,shadow_area_id,OUT,R2,&size_check,R3,
        &base_check,R5,&max_check,END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
         FATAL);

   /* Populate the first and third words of the sprite area control block.             */

   ptr = (int *)(*sprarea);
   *ptr = shadowsize;
   *(ptr + 2) = 16;   /* Byte offset to the sprite itself.                             */

   /* Initialise sprite area.                                                          */
   if ((err = swi(OS_SpriteOp,R0,512+9,R1,*sprarea,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
        FATAL);

   #ifdef LOW_MEM
     width = original_JPEG_pixel_width;
     height = original_JPEG_pixel_height;
   #else
     width = xres;
     height = yres;
   #endif

   /* Create the sprite.                                                               */
   if ((err = swi(OS_SpriteOp,R0,256+15,R1,*sprarea,R2,"shadow",R3,0,R4,
        width,R5,height,R6,spritemode,END)) != NULL)
          ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,
          err->errmess,FATAL);

   /* Write the JPEG backdrop image onto the newly created blank sprite.               */
   JPEGOverlay("VideoCD:Backdrop",*sprarea);

   if (title_list == NULL)
       TextOverlayWithoutTitles(MPEG_file_count,*sprarea,text_positions);
   else
   {
       if ((err = swi(OS_SpriteOp,R0,512+60,R1,*sprarea,R2,(int)(*sprarea) + 16,R3,0,OUT,
            R1,&oldscb,R2,&oldsptr,R3,&oldsa,END))!=NULL)
       ErrorHandler(__FILE__,__LINE__,"TextOverlayWithoutTitles()",err->errnum,
       err->errmess,FATAL);

       PlotCircles(text_positions,7);

       InitTitlesRubout(r,text_positions);

       ShowTitles(current_first_title_displayed,title_list,max_titles,text_positions);

       OverlayScrollArrows(text_positions);

       if ((err = swi(OS_SpriteOp,R0,256+60,R1,oldscb,R2,oldsptr,R3,oldsa,END))!=NULL)
            ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,
            FATAL);
   }

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   return shadow_area_id;

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  OverlayScrollArrows()                                                   */
/*  BEHAVIOUR: Plots scroll up and scroll down arrows onto the backdrop of the         */
/*             selection screen.  Not intended for use if there aren't any titles to   */
/*             display.                                                                */
/*  REQUIRES:  - 'positions', which are positions at which to display text, from which */
/*                we can work out where to display the scroll arrows.                  */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void OverlayScrollArrows(struct coords *positions)
{
 _kernel_oserror *err = NULL;
 char *sprarea = NULL;
 int sprsize;
 int *ptr = NULL;
 int pixtrans_size;
 char *pixtrans_table = NULL;

   #ifdef FN_TRACE
     puts("OverlayScrollArrows()");
   #endif

   sprsize = CheckSpriteExists("VideoCD:Up");
   sprsize += 4;   /* Bytes 0-4 (PRM p. 1-749) of the sprite area, are not stored as   */
                   /* part of the sprite file and hence are not included in the sprite */
                   /* size returned above.  Hence adjustment of sprsize.               */

   if ((sprarea = malloc(sprsize)) == NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",0,"Insufficient Memory.",
        WARNING);
        return;
   }

   /* Initialise sprite area.                                                          */
   ptr = (int *)sprarea;
   *ptr = sprsize;
   *(ptr + 2) = 16;  /* Offset to first sprite.                                        */
   if ((err = swi(OS_SpriteOp,R0,512+9,R1,sprarea,END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);
        free(sprarea);
        return;
   }

   /* Load sprite file.                                                                */
   if ((err = swi(OS_SpriteOp,R0,256+10,R1,sprarea,R2,"VideoCD:Up",END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);
        free(sprarea);
        return;
   }

   /* Set up a translation table (so that the arrow appears in the correct colour).    */
   /* First call returns size of buffer required, next call creates it.                */
   if ((err = swi(ColourTrans_SelectTable,R0,512,R1,(int)sprarea+16,R2,-1,R3,-1,
        R4,0,R5,3,OUT,R4,&pixtrans_size,END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);
        free(sprarea);
        return;
   }
   if ((pixtrans_table = malloc(pixtrans_size)) == NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",0,"Insufficient Memory",
        WARNING);
        free(sprarea);
        return;
   }
   if ((err = swi(ColourTrans_SelectTable,R0,512,R1,(int)sprarea + 16,R2,-1,R3,-1,R4,
        pixtrans_table,R5,3,END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);
        free(pixtrans_table);
        free(sprarea);
        return;
   }

   /* Plot sprite.  PutSpriteScaled is necessary as opposed to PutSprite, even though  */
   /* there is no scaling.  This is because we need to use the colour translation      */
   /* table for the scroll arrow to appear in it's original colour.                    */
   if ((err = swi(OS_SpriteOp,R0,512+52,R1,sprarea,R2,(int)sprarea+16,R3,
      ((positions[0].x)+6)<<xeig,R4,((positions[0].y) + 3)<<yeig,R5,0x08,
        R6,0,R7,pixtrans_table,END)) != NULL)
         ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
         WARNING);

   /* Flip sprite about x axis to point downwards instead of up.                       */
   if ((err = swi(OS_SpriteOp,R0,512+33,R1,sprarea,R2,(int)sprarea+16,END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);
        free(sprarea);
        free(pixtrans_table);
   }

   /* Plot sprite.                                                                     */
   if ((err = swi(OS_SpriteOp,R0,512+52,R1,sprarea,R2,(int)sprarea+16,R3,
      ((positions[6].x)+6)<<xeig,R4,(positions[6].y)<<yeig,R5,0x08,
        R6,0,R7,pixtrans_table,END)) != NULL)
         ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
         WARNING);

   /* Delete sprite, now that it's been plotted and is finished with.                  */
   if ((err = swi(OS_SpriteOp,R0,512+25,R1,sprarea,R2,(int)sprarea+16,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"OverlayScrollArrows()",err->errnum,err->errmess,
        WARNING);

   free(sprarea);
   free(pixtrans_table);

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  InitTitlesRubout()                                                      */
/*  BEHAVIOUR: Sets up title rubout buffers.  Applicable only to scrolling.  Scrolling */
/*             only applies if titles were found on the cd.                            */
/*  REQUIRES:  - 'r', which is the 5 element array of title backgrounds to be populated*/
/*             - 'text_pos', which contains coordinates at which to plot titles, and   */
/*                which therefore helps us to determine what areas of the screen to    */
/*                save in the rubout buffers.                                          */
/*  RETURNS:   populated rubout buffers in 'r'.                                        */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void InitTitlesRubout(struct rubout_buffer r[5],struct coords *text_pos)
{
 int i,j,k;
 int width;
 int height;
 int linelen;
 int vdublk[2];
 char *screen= NULL;
 int scrstart;
 char *buffer_ptr = NULL;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("InitTitlesRubout()");
   #endif

   vdublk[0] = 148;
   vdublk[1] = -1;
   if ((err = swi(OS_ReadVduVariables,R0,vdublk,R1,vdublk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);
   scrstart = vdublk[0];

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,6,OUT,R2,&linelen,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);

   width = (xres - (text_pos[1].x + 60))*2;    /* Define rubout buffer dimensions.     */
   height = 40;

   if (r[0].r == NULL)
   {
       for (i = 0; i < 5; i++)            /* Allocate memory for the rubout buffers.   */
       {
            if ((r[i].r = malloc(width*height)) == NULL)
                 ErrorHandler(__FILE__,__LINE__,"InitTitlesRubout()",0,
                 "Insufficient Memory.",FATAL);
            r[i].width = width;
            r[i].height = height;
       }
   }

   for (i = 0;i < 5; i++)                              /* Populate each rubout buffer. */
   {
      buffer_ptr = r[i].r;
      screen = (char *)(scrstart + (linelen * (yres - text_pos[i+1].y + 10))
                        + ((text_pos[i+1].x + 60) * 2) - (linelen * (height - 1)));

      for (j = 0; j < height; j++)
      {
           for (k = 0; k < width; k++)
                *buffer_ptr++ = *screen++;
           screen += (linelen - width);
      }
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  RuboutTitle()                                                           */
/*  BEHAVIOUR: Erases the specified title by redrawing the appropriate part of the     */
/*             backdrop (saved earlier in the rubout buffers) over the title text.     */
/*  REQUIRES:  - 'r', which is the rubout buffer to use, and 'text_pos', which is the  */
/*                corresponding position on screen for that particular rubout buffer.  */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void RuboutTitle(struct rubout_buffer r,struct coords text_pos)
{
 char *buffer = NULL;    /* Source (rubout buffer).   */
 char *screen = NULL;    /* Destination (screen).     */
 int i,j;
 int linelen;
 int scrstart;
 int vdublk[2];
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("RuboutTitle()");
   #endif

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,6,OUT,R2,&linelen,END)) != NULL)
     ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
     FATAL);

   vdublk[0] = 148;
   vdublk[1] = -1;
   if ((err = swi(OS_ReadVduVariables,R0,vdublk,R1,vdublk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);
   scrstart = vdublk[0];

   buffer = r.r;

   screen = (char *)(scrstart+ (linelen * (yres - text_pos.y + 10))
                     + ((text_pos.x + 60) * 2) - (linelen * (r.height - 1)));

   for (j = 0; j < (r.height); j++)
   {
        for (i = 0; i < (r.width); i++)
             *screen++ = *buffer++;

        screen += (linelen-(r.width));
   }

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ShowTitles()                                                            */
/*  BEHAVIOUR: Displays titles on the screen, beginning from the specified start       */
/*             title.  Only 5 titles at a time can be displayed, hence later use of    */
/*             scrolling.                                                              */
/*  REQUIRES:  - 'start_from', which is the title number to start the display at       */
/*                (counting from 1, not 0).                                            */
/*             - 'title_list', which is a null separator list of titles, NULL if there */
/*                aren't any titles.                                                   */
/*             - 'max_titles', which tells us how many titles are in the title list.   */
/*             - 'text_pos', which gives screen text plotting positions.               */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ShowTitles(int start_from,char *title_list,int max_titles,
       struct coords *text_pos)
{
 char *index;
 int screen_pos;
 int current_title;
 int i;
 int handle;
 int FontPaint_flags = 656;
 extern int iFontsVersion;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("ShowTitles()");
   #endif

   if (title_list == NULL)
   {
       ErrorHandler(__FILE__,__LINE__,"ShowTitles()",0,"No titles.",WARNING);
       return;
   }
   else if (start_from > max_titles)
        {
            ErrorHandler(__FILE__,__LINE__,"ShowTitles()",0,"Invalid display request.",
            WARNING);
            return;
        }
        else
             {
                 index = title_list;
                 for (i = 1; i != start_from; i++)   /* Find start position in the     */                       index += strlen(index) + 1;    /* titles list.                   */

                 handle = Fonts("Homerton.Bold",25,25,0,0xC89FF00);

                 screen_pos = 2;
                 current_title = start_from;

                 #ifdef DEVELOPMENT
                    printf("iFontsVersion = %d\n",iFontsVersion);
                 #endif

                 if (iFontsVersion >= 335)          /* Enable Dizzy's blending in      */
                     FontPaint_flags |= (1 << 11);  /* Font_Paint below.   See         */
                                                    /* Initialise() in main.c          */

                 while ((screen_pos <= 6) && (current_title <= max_titles))
                 {
                         if ((err = swi(Font_Paint,R0,handle,R1,index,R2,
                              FontPaint_flags,R3,((text_pos[screen_pos-1].x)+60)<<xeig,
                              R4,(text_pos[screen_pos-1].y)<<yeig,R7,strlen(index),END))
                              != NULL)
                                ErrorHandler(__FILE__,__LINE__,"ShowTitles()",
                                err->errnum,err->errmess,FATAL);

                         index += strlen(index) + 1;
                         screen_pos++;
                         current_title++;
                 }

                 if ((err = swi(Font_Paint,R0,handle,R1,"Eject",R2,FontPaint_flags,R3,
                             ((text_pos[screen_pos-1].x)+(xres/2)+100)<<xeig,R4,
                             (text_pos[screen_pos-1].y)<<yeig,R7,strlen("Eject"),END))
                              != NULL)
                                ErrorHandler(__FILE__,__LINE__,"ShowTitles()",
                                err->errnum,err->errmess,FATAL);

                 if ((err = swi(Font_LoseFont,R0,handle,END)) != NULL)
                      ErrorHandler(__FILE__,__LINE__,"ShowTitles()",
                      err->errnum,err->errmess,WARNING);
             }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ReadJPEGDimensions()                                                    */
/*  BEHAVIOUR: Reads the pixel width, and the height, of the user supplied JPEG back-  */
/*             drop.  Sets 'original_JPEG_pixel_width' and 'original_JPEG_pixel_       */
/*             height' accordingly.                                                    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ReadJPEGDimensions(void)
{
 _kernel_oserror *err = NULL;
 #define JPEG_FileInfo 0x49981

   #ifdef FN_TRACE
     puts("ReadJPEGDimensions()");
   #endif

   if ((err = swi(JPEG_FileInfo,R0,0,R1,"VideoCD:Backdrop",OUT,R2,
        &original_JPEG_pixel_width,R3,&original_JPEG_pixel_height,END)) != NULL)
          ErrorHandler(__FILE__,__LINE__,"ReadJPEGDimensions()",err->errnum,err->errmess,
          FATAL);

   #undef JPEG_FileInfo
}


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  JPEG Overlay()                                                          */
/*  BEHAVIOUR: Plots JPEG backdrop onto the shadow screen sprite.                      */
/*  REQUIRES:  - 'jpegfile', which is the name of the backdrop JPEG file.              */
/*             - 'sprarea', which points to the shadow sprite area.                    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void JPEGOverlay(char *jpegfile,char *sprarea)
{
 int oldscb,oldsptr,oldsa;
 int *scale;
 _kernel_oserror *err = NULL;
 #define JPEG_FileInfo 0x49981
 #define JPEG_PlotFileScaled 0x49983

   #ifdef FN_TRACE
     puts("JPEGOverlay()");
   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Switch output to the shadow sprite.                                              */
   if ((err = swi(OS_SpriteOp,R0,512+60,R1,sprarea,R2,(int)sprarea + 16,R3,0,OUT,R1,
        &oldscb,R2,&oldsptr,R3,&oldsa,END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL);

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   #ifdef LOW_MEM
     scale = 0;
   #else
         if ((scale = malloc(16)) == NULL)
              ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",0,"Insufficient Memory.",
                           FATAL);

         /* Scale factors.  Refer PRM p. 1-752.  Note that the scale factors are in    */
         /* pixels, not in OS coordinates.                                             */

         *scale = xres;
         *(scale + 1) = yres;
         *(scale + 2) = original_JPEG_pixel_width;
         *(scale + 3) = original_JPEG_pixel_height;
   #endif

   /* Plot the JPEG onto the shadow sprite.                                            */
   if ((err = swi(JPEG_PlotFileScaled,R0,jpegfile,R1,0,R2,0,R3,scale,R4,0,END))
        !=NULL)
          ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL);

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Turn output to the shadow sprite off.                                            */
   if ((err = swi(OS_SpriteOp,R0,256+60,R1,oldscb,R2,oldsptr,R3,oldsa,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL);

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   #ifdef LOW_MEM
     free(scale);
   #endif

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  PlotCircles()                                                           */
/*  BEHAVIOUR: Plots 'n' selection circles starting from the coordinates of the first  */
/*             on screen text position.                                                */
/*  REQUIRES:  - 'positions', which provide text plotting coordinates from which we    */
/*                can work out where to plot the selection circles.                    */
/*             - 'n', which is the number of circles to plot (7 if there are titles,   */
/*                otherwise the number of MPEG files which were found plus 1 for the   */
/*                eject option).                                                       */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void PlotCircles (struct coords *positions,int n)
{
 _kernel_oserror *err = NULL;
 int i;

   #ifdef FN_TRACE
     puts("PlotCircles()");
   #endif

   if ((err = swi(ColourTrans_SetGCOL,R0,0,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"PlotCircles()",err->errnum,err->errmess,FATAL);

   for (i = 0; i < n; i++)
   {
        if ((err = swi(OS_Plot,R0,4,R1,((positions[i].x)+15)<<xeig,R2,
           ((positions[i].y)+12)<<yeig,
             END)) != NULL)
             ErrorHandler(__FILE__,__LINE__,"PlotCircles()",err->errnum,err->errmess,
             FATAL);
        if ((err = swi(OS_Plot,R0,152 | 1,R1,15<<xeig,R2,15<<yeig,END)) != NULL)
             ErrorHandler(__FILE__,__LINE__,"PlotCircles()",err->errnum,err->errmess,
             FATAL);
   }

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  TextOverlayWithoutTitles()                                              */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

static void TextOverlayWithoutTitles(int MPEG_file_count,char *sprarea,
                                                struct coords *text_coords)
{
 int width;
 int height;
 int i;
 char digit[3];
 int handle;
 int x;
 int oldscb,oldsptr,oldsa;
 int FontPaint_flags = 529;
 extern int iFontsVersion;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("TextOverlayWithoutTitles()");
   #endif

   #ifdef LOW_MEM
     width = original_JPEG_pixel_width;
     height = original_JPEG_pixel_height;
   #else
     width = xres;
     height = yres;
   #endif

   /* Enable latest background blending.  This will only apply if the Font Manager     */
   /* Module is greater than or equal to version 335.                                  */
   if (iFontsVersion >= 335)
       FontPaint_flags |= (1 << 11);

   /* Switch output to the shadow sprite.                                              */
   if ((err = swi(OS_SpriteOp,R0,512+60,R1,sprarea,R2,(int)sprarea + 16,R3,0,OUT,R1,
        &oldscb,R2,&oldsptr,R3,&oldsa,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"TextOverlayWithoutTitles()",err->errnum,
        err->errmess,FATAL);

   if (MPEG_file_count > 6)
       PlotCircles(text_coords,MPEG_file_count);

    handle = Fonts("Homerton.Bold",25,25,0,0xC89FF00);

    for (i = 0; i < MPEG_file_count; i++)
    {
         sprintf(digit,"%d",i+1);

         if (i < 9)
             x = (text_coords[i].x) + 7;
         else
             x = text_coords[i].x;

         if ((err = swi(Font_Paint,R0,handle,R1,digit,R2,FontPaint_flags,R3,x<<xeig,R4,
              (text_coords[i].y)<<yeig,END)) != NULL)
               ErrorHandler(__FILE__,__LINE__,"TextOverlayWithoutTitles()",err->errnum,
               err->errmess,FATAL);
    }

    if ((err = swi(Font_Paint,R0,handle,R1,"Eject",R2,FontPaint_flags,R3,
        (text_coords[i].x)<<xeig,R4,(text_coords[i].y)<<yeig,END)) != NULL)
         ErrorHandler(__FILE__,__LINE__,"TextOverlayWithoutTitles()",err->errnum,
         err->errmess,FATAL);

    if ((err = swi(Font_LoseFont,R0,handle,END)) != NULL)
         ErrorHandler(__FILE__,__LINE__,"TextOverlayWithoutTitles()",err->errnum,
         err->errmess,WARNING);

   /* Turn output to the shadow sprite off.                                            */
   if ((err = swi(OS_SpriteOp,R0,256+60,R1,oldscb,R2,oldsptr,R3,oldsa,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  FillCoordsArray()                                                       */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void FillCoordsArray(struct coords *a,int index_start,int index_end,int x_inc,
                            int row_height,int x_start_val,int y_start_val)
{
 int i;
 int xval,yval;

   #ifdef FN_TRACE
     puts("FillCoordsArray()");
   #endif

   xval = x_start_val;
   yval = y_start_val;

   for (i = index_start; i <= index_end; i++)
   {
        a[i].x = xval;  a[i].y = yval;
        xval += x_inc;  yval -= row_height;
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ReadTrackTitles()                                                       */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern char * ReadTrackTitles(int *max_titles)
{
 FILE *fptr = NULL;
 char *title_list = NULL;
 char buffer[2048];
 int i,n,len = 0;
 int current_strlen;
 char *buffer_index = NULL;
 char *titles_index = NULL;


   #ifdef FN_TRACE
     puts("ReadTrackTitles()");
   #endif

   if ((fptr = fopen("CDFS:$.KARAOKE.KARINFO/US","r")) == NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",0,"Can't read track titles.",
        WARNING);
        return NULL;
   }

   if ((n = fread(buffer,1,2048,fptr)) != 2048)
   {
        ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",n,"2048 expected.",WARNING);

        if (n == 0)
        {
            ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",0,"KARINFO/US is empty.",
            WARNING);
            fclose(fptr);
            return NULL;
        }
   }
   fclose(fptr);

   #ifdef DEVELOPMENT
     buffer_index = buffer;
     printf("\nBuffer (2048) = ");
     for (i = 0; i < 2048;  printf("%c",*buffer_index),buffer_index++,i++);
     puts("\nBuffer End.");
   #endif

   *max_titles = 0;

   /*
      Pass 0 thru. the loop ---> calculate titles string length then malloc.
      Pass 1 thru. the loop ---> populate titles string then return it.
   */

   for (i = 0; i < 2; i++)
   {
        buffer_index = buffer;
        buffer_index = LocateNextTitle(buffer_index,buffer);

        while (*buffer_index == '\t')
        {
                if (((int)buffer_index + 2 - (int)buffer) < 2048)
                {
                  /*
                      Character sequence "|I|?" found, where '|I' is the tab character
                      (integer value 9), and '|?' is a control character representing
                      the length of the string following immediately after.
                  */

                      buffer_index++;

                      if (title_list == NULL)
                      {                                /* Add 1 to allow for null      */
                          len += (*buffer_index) + 1;  /* seperator.                   */
                          *max_titles += 1;
                      }

                      current_strlen = *buffer_index;  /* Doesn't include terminating  */
                                                       /* null character.              */
                      buffer_index++;

                  /*
                      buffer_index now points to the start of the text string.  Before
                      extracting the string perform a safety check to ensure that we're
                      still working within the bounds of 'buffer' and 'title_list'.
                  */
                      if (title_list != NULL)
                      {
                          if (((int)buffer_index + current_strlen - (int)buffer) > 2048)
                          {
                                ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",0,
                                "Exceeded buffer bounds.",WARNING);
                                free(title_list);
                                return NULL;
                          }

                          if (((int)titles_index + current_strlen + 1 - (int)title_list) >
                                len)
                          {
                                ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",0,
                                "Exceeded bounds of title list array.",WARNING);
                                free(title_list);
                                return NULL;
                          }

                          for (n = 0; n < current_strlen; n++)
                          {
                               *titles_index++ = *buffer_index++;
                          }
                      }

                      if (title_list != NULL)
                      {
                          if (*(titles_index-1) != '\0')
                          {
                              *titles_index = '\0';
                               titles_index++;
                          }
                      }
                }

                buffer_index = LocateNextTitle(buffer_index,buffer);
        }

        /*
           On the first pass (i == 0) we calculate the length of the title list string and
           then allocate memory below.  On the second pass (i == 1) we populate the
           title list string.
        */

        if (title_list == NULL)
        {
            if ((title_list = malloc(len)) == NULL)
            {
                 ErrorHandler(__FILE__,__LINE__,"ReadTrackTitles()",0,
                 "Insufficient Memory.",WARNING);
                 return NULL;
            }
            else
            {
                 titles_index = title_list;
            }
        }
   }

   #ifdef DEVELOPMENT
     printf("\nTitles:- ");
     titles_index = title_list;
     printf("len = %d\n",len);
     for (i = 0; i < len; i++)
     {
          if (*titles_index == '\0')
               putchar('\n');
          else
               putchar(*titles_index);
          titles_index++;
     }
     puts("Titles End");
   #endif

   return title_list;

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  LocateNextTitle()                                                       */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static char * LocateNextTitle(char *buffer_index,char *buffer)
{
 int pattern_found;
 int z;
 #define DONT_KNOW -1

   #ifdef FN_TRACE
     puts("LocateNextTitle()");
   #endif

   pattern_found = FALSE;

   while ((pattern_found == FALSE) && ((int)buffer_index - (int)buffer < 2046))
   {
           while ((*buffer_index != '\t') &&
                (((int)buffer_index - (int)buffer) < 2046))
                             buffer_index++;

           /* Read starting from and including the character following the tab.   */
           /* Stop when the next newline is encountered. If another tab character */
           /* is read before encountering the newline, this is not a track title. */

           z = 2;  /* Allow for e.g. |I|IBlue Jean. Otherwise if z is 1, you get
                      lue Jean displayed. */

           pattern_found = DONT_KNOW;
           while (((int)buffer_index - (int)buffer+ z < 2046) &&
                   (pattern_found == DONT_KNOW))
           {
                    if (*(buffer_index + z) == '\n')
                          pattern_found = TRUE;
                    else if (*(buffer_index + z) == '\t')
                         {
                               pattern_found = FALSE;
                               buffer_index += z;
                         }
                    z++;
           }
   }

   return buffer_index;
   #undef DONT_KNOW
}



/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  CheckSpriteExists()                                                     */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern int CheckSpriteExists(char *fname)
{
 _kernel_oserror *err = NULL;
 int type = 0;
 int sprsize = 0;

   #ifdef FN_TRACE
     puts("CheckSpriteExists() in Display.c");
   #endif

   if ((err = swi(OS_File,R0,17,R1,fname,OUT,R0,&type,R4,&sprsize,END))
        != NULL)
        ErrorHandler(__FILE__,__LINE__,"CheckSpriteExists()",err->errnum,err->errmess,
        FATAL);

   if (type != 1)
       ErrorHandler(__FILE__,__LINE__,"PointerSpriteExists()",0,"Couldn't find sprite",
       FATAL);

   if (sprsize == 0)
       ErrorHandler(__FILE__,__LINE__,"CheckSpriteExists()",0,
       "Sprite contains no data.",FATAL);

   return sprsize;

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Rubout()                                                                */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void Rubout(int item,struct coords *coord_table,int width,int height,
                   char *rubout_buffer)
{
 struct coords screen_pos;
 int i,j;
 int vdublk[2];
 int scrstart;
 int linelen;
 char *screen_ptr = NULL;
 char *buffer_ptr = NULL;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("Rubout()");
   #endif

   vdublk[0] = 148;
   vdublk[1] = -1;
   if ((err = swi(OS_ReadVduVariables,R0,vdublk,R1,vdublk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);
   scrstart = vdublk[0];

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,6,OUT,R2,&linelen,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL);

   screen_pos.x = coord_table[item-1].x;
   screen_pos.y = coord_table[item-1].y;
   screen_pos.y = screen_pos.y + height;
   screen_ptr = (char *) (scrstart + (linelen * (yres - screen_pos.y)) +
                          screen_pos.x * 2);
   buffer_ptr = rubout_buffer;
   for (j = 0; j < height; j++)
   {
        for (i = 0; i < width; *screen_ptr++ = *buffer_ptr++, i++);
        screen_ptr = screen_ptr + linelen - width;
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Fonts()                                                                 */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int Fonts(char *font_name,int x_pt_size,int y_pt_size,int bkgrnd,int foregrnd)
{
 _kernel_oserror *err = NULL;
 int handle = 0;

  #ifdef FN_TRACE
    puts("Fonts()");
  #endif

  if ((err = swi (Font_FindFont,R1,font_name,R2,x_pt_size*16,R3,y_pt_size*16,R4,0,R5,0,
       OUT,R0,&handle,END)) != NULL)
       ErrorHandler(__FILE__,__LINE__,"Fonts()",err->errnum,err->errmess,FATAL);

  if ((err = swi(Font_SetFont,R0,handle,END)) != NULL)
       ErrorHandler(__FILE__,__LINE__,"Fonts()",err->errnum,
       err->errmess,FATAL);

  /* Set the best range of anti-alias colours to match the background (R1) and        */
  /* foreground (R2) palette entries.                                                 */
     if ((err = swi(ColourTrans_SetFontColours,R0,handle,R1,bkgrnd,R2,foregrnd,R3,14,END))
          != NULL)
          ErrorHandler(__FILE__,__LINE__,"Fonts()",err->errnum,
          err->errmess,FATAL);

   /* Ensure that characters are printed at the current text cursor position using    */
   /* the current text foreground and background colours.                             */
      if ((err = swi(OS_WriteC,R0,4,END))!=NULL)
           ErrorHandler(__FILE__,__LINE__,"Fonts()",err->errnum,err->errmess,FATAL);

   return handle;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ScrollDown()                                                            */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void ScrollDown(int requested_number_of_lines,struct coords *text_positions,
                   struct rubout_buffer r[5],char *title_list,
                   int *current_first_title_displayed,int max_titles)
{int i = 1;
 char *index = NULL;
 int actual_number_of_lines = 0;
 int min_number_of_lines = 1;

   #ifdef FN_TRACE
     puts("ScrollDown()");
   #endif

   index = title_list;

   if ((strncmp("Copyright",title_list,strlen("Copyright"))) == NULL)
   {
        index += strlen(index) + 1;
        i++;
   }

   /* Only scroll down if we're not going to end up with blank display lines on the    */
   /* screen.  The significance of the '4' is that there are 5 text display lines on   */
   /* screen.                                                                          */
   if (((*current_first_title_displayed) + 5 - 1 + min_number_of_lines) <= max_titles)
   {
      while ((i != (*current_first_title_displayed) + requested_number_of_lines) &&
             ((i + 4) <= max_titles))
      {

              if (i + 1 <= (*current_first_title_displayed))
              {                                             /* Moving towards current  */
                  index += strlen(index) + 1;               /* first title displayed.  */
              }
              else if (i + 5 <= max_titles)
                   {                                        /* Proceeding beyond old   */
                       actual_number_of_lines++;            /* first title displayed.  */
                       index += strlen(index) + 1;          /* Validation necessary.   */
                   }
              i++;
      }

      if (actual_number_of_lines != requested_number_of_lines)
           requested_number_of_lines = actual_number_of_lines;

      *current_first_title_displayed += actual_number_of_lines;

      for (i = 1; i <= 5; i++)
      {
           RuboutTitle(r[i-1],text_positions[i]);
           PrintTitle(text_positions[i],index);
           index += strlen(index) + 1;
      }
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ScrollUp()                                                              */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void ScrollUp(int requested_number_of_lines,struct coords *text_positions,
                   struct rubout_buffer r[5],char *title_list,
                   int *current_first_title_displayed,int max_titles)
{int i = 1;
 char *index = NULL;
 int new_first_title_displayed;

   #ifdef FN_TRACE
     puts("ScrollUp()");
   #endif

   if ((*current_first_title_displayed) == 1)
         return;

   index = title_list;
   if ((strncmp("Copyright",title_list,strlen("Copyright"))) == NULL)
   {
        if (*current_first_title_displayed == 2)
             return;

        index += strlen(index) + 1;
        i++;
   }

   new_first_title_displayed = (*current_first_title_displayed) -
   requested_number_of_lines;

   /* Check that the move to the new current first title is valid.  If it isn't adjust */
   /* accordingly so that there are no blank display lines shown on screen.  E.g. if   */
   /* 'number_of_lines' to scroll is greater than 1, and if the requested scroll is    */
   /* going to leave blank title line/s on screen, reduce the scroll to the highest    */
   /* number which isn't going to give blank display lines.   Also ensure that we      */
   /* don't scroll too far back.                                                       */
   if ((new_first_title_displayed + 4) > max_titles)
        new_first_title_displayed = max_titles - 4;

   if (new_first_title_displayed < 1)
       new_first_title_displayed = 1;


   /* Move to new first display title in the titles list.                             */
   while (i != new_first_title_displayed)
   {
           index += strlen(index) + 1;
           i++;
   }

   for (i = 1; i <= 5; i++)
   {
        RuboutTitle(r[i-1],text_positions[i]);
        PrintTitle(text_positions[i],index);
        index += strlen(index) + 1;
   }

   *current_first_title_displayed = new_first_title_displayed;

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  PrintTitle()                                                            */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void PrintTitle(struct coords screen_pos,char *title)
{
 int handle;
 char *index = NULL;
 int FontPaint_flags = 656;
 extern int iFontsVersion;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("PrintTitle()");
   #endif

   handle = Fonts("Homerton.Bold",25,25,0,0xC89FF00);

   /* Enable background blending.  This can only happen if the Font Manager module is  */
   /* version 335 or above.                                                            */
   if (iFontsVersion >= 335)
       FontPaint_flags |= (1 << 11);

   if ((err = swi(Font_Paint,R0,handle,R1,title,R2,FontPaint_flags,R3,
      ((screen_pos.x)+60)<<xeig,R4,(screen_pos.y)<<yeig,R7,strlen(index),END)) != NULL)
          ErrorHandler(__FILE__,__LINE__,"PrintTitle()",err->errnum,err->errmess,FATAL);

   if ((err = swi(Font_LoseFont,R0,handle,END)) != NULL)
                      ErrorHandler(__FILE__,__LINE__,"ShowTitles()",
                      err->errnum,err->errmess,WARNING);

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  CreateTextCoords()                                                      */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern struct coords *CreateTextCoords(char *title_list,int MPEG_file_count)
{
 int current_y;
 struct coords *text_positions = NULL;

   #ifdef FN_TRACE
     puts("CreateTextCoords()");
   #endif

   ScreenDimensions();

   if (title_list == NULL)
   {
       if ((text_positions = calloc((MPEG_file_count + 1),(sizeof(struct coords))))
            == NULL)
              ErrorHandler(__FILE__,__LINE__,"CreateTextCoords()",0,
              "Insufficient Memory.",FATAL);

       current_y = yres - (yres/6);

       if (MPEG_file_count <= 6)
       {
           FillCoordsArray(text_positions,0,MPEG_file_count,0,yres/12,xres/2,
           yres-(yres/6));
       }
       else if (MPEG_file_count <= 13)
            {
                FillCoordsArray(text_positions,0,6,0,yres/10,xres/3,yres-(yres/6));
                FillCoordsArray(text_positions,7,MPEG_file_count,0,yres/10,xres-xres/3,
                                  yres-(yres/6));
            }
            else if (MPEG_file_count <= 20)
                 {
                     FillCoordsArray(text_positions,0,6,0,yres/10,xres/4,yres-yres/6);
                     FillCoordsArray(text_positions,7,13,0,yres/10,xres/2,yres-yres/6);
                     FillCoordsArray(text_positions,14,MPEG_file_count,0,yres/10,
                     xres-xres/4,yres-yres/6);
                 }
   }
   else
   {
      if ((text_positions = malloc(7*(sizeof(struct coords)))) == NULL)
           ErrorHandler(__FILE__,__LINE__,"CreateTextCoords()",0,"Insufficient Memory.",
           FATAL);

      FillCoordsArray(text_positions,0,6,0,yres/10,xres/6,yres-yres/6);
   }

   return text_positions;
}


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ScreenDimensions()                                                      */
/*  BEHAVIOUR: Sets xres and yres, which are the number of pixels horizontally and     */
/*             vertically in the current screen mode, and sets xeig and yeig, which    */
/*             are the number of bits by which a screen pixel position must be shifted */
/*             left to convert to it's corresponding OS coord.                         */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ScreenDimensions(void)
{
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("ScreenDimensions() in Display.c");
   #endif

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,11,OUT,R2,&xres,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL);

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,12,OUT,R2,&yres,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL);

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,4,OUT,R2,&xeig,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL);

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,5,OUT,R2,&yeig,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL);

   xres++; yres++;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:   CursorsOff()                                                           */
/*  BEHAVIOUR:  Ensures that cursors are turned off and don't appear on the screen.    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

extern void CursorsOff(void)
{
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("CursorsOff()");
   #endif

   if ((err = swi(OS_RemoveCursors,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"CursorsOff()",err->errnum,err->errmess,WARNING);
}
