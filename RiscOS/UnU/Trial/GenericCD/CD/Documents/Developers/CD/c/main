/*=====================================================================================*/
/*                                                                                     */
/*  FILE:  !cd.c.main                                                                  */
/*  DESCRIPTION:  Acts as a central controlling mechanism continuously monitoring the  */
/*                state of the cd drive.  Launches the appropriate cd application if a */
/*                known cd type is detected in the drive, and initiates closure of     */
/*                that application upon detecting that the disc has been ejected.      */
/*  AUTHOR:  crose@omi.co.uk                                                           */
/*                                                                                     */
/*=====================================================================================*/

#include "main.h"

/*-------------------------------------------------------------------------------------*/
/*                    Inclusion of standard C library headers.                         */
/*-------------------------------------------------------------------------------------*/

                          #include "stdio.h"
                          #include "stdlib.h"
                          #include "string.h"
                          #include "signal.h"
                          #include "time.h"

/*-------------------------------------------------------------------------------------*/
/*   Inclusion of SWI interface header.  Allows constructs of the type                 */
/*   err = swi(Wimp_Initialise,R0,310,R1,0x4B534154,R2,NULL,R3,msg_list,OUT,R1,        */
/*   &cd_task_handle,END);                                                             */
/*-------------------------------------------------------------------------------------*/

                          #include "swicall.h"

/*-------------------------------------------------------------------------------------*/
/*                Inclusion of RISC_OSLib header files.                                */
/*-------------------------------------------------------------------------------------*/

                          #include "wimp.h"

/*-------------------------------------------------------------------------------------*/
/*                   Inclusion of !cd header files.                                    */
/*-------------------------------------------------------------------------------------*/

                          #define GLOBALS
                             #include "common.h"
                          #undef GLOBALS
                          #include "init.h"
                          #include "cd_type.h"
                          #include "launch.h"
                          #include "cdpresent?.h"
                          #include "display.h"

                          #ifdef SCREEN_DUMP
                            #include "screens.h"
                          #endif

                          #define DECLARE__          /*  Avoid multiple declarations  */
                            #include "messages.h"    /*  of msg_list.                 */
                          #undef DECLARE__

                          #ifdef MEMORY_TRACE
                            #include "memory.h"
                          #endif

/*-------------------------------------------------------------------------------------*/
/*    Inclusion of David DeVorchik's window code used to display the splash screen.    */
/*-------------------------------------------------------------------------------------*/

                           #include "window.h"


/*-------------------------------------------------------------------------------------*/
/*                                 Function Prototypes.                                */
/*-------------------------------------------------------------------------------------*/

                        /* -- INTERNAL FUNCTIONS -- */

static void Initialise(void);

/*
   Enables !cd to trap errors such as division by zero, operating system error, bad
   memory access, and so on.  Initialises !cd as a wimptask.  Includes David DeVorchik's
   UpCallV initialisation code (for use when the STB is put into standby mode).  Displays
   the !cd splash (PleaseInsertCd) screen.  Allocates memory for polling the wimp (poll_
   blk), primarily used for receiving messages.  Sets up a CDFS control block, which is
   necessary for being able to access the cd drive using the CDFS Driver SWI's.  There
   must be one control block for each cd drive.  !cd assumes that there will never be
   more than one cd drive.  The cd block is created as a dynamic memory area, which
   allows any task launched by !cd access to the CDFS Driver SWI's using the same block
   of memory.
*/

static void Poll(int *tray_state);

/*
   Listens for messages from the other cd task, the implications of this being whether
   or not to display the splash (idle) screen.  Calls Idle() on null events. Idle()
   monitors the state of the cd drive, activating and deactivating the other cd task as
   and when appropriate.  (The splash screen will get displayed and hidden in response
   to start up and die messages from the other task.
*/

static void Idle(void);

/*
   Watches the cd drive and determines what type of cd is loaded, if any.  The
   appropriate application is subsequently launched.  If an unknown type of cd is
   detected in the drive, it will be ejected and the splash screen will reappear.
*/

static int DetectCdType(void);

/*
   Uses the "cd_type" library to determine what type of cd is present in the drive, thus
   enabling the correct application to be launched.
*/

static int MPEG_HardwarePresent(void);

/*
    Determines whether or not MPEG hardware is present.  This is necessary in
    determining whether or not to launch !VideoCD.  Returns TRUE if MPEG hardware is
    present, FALSE otherwise.
*/

static int MoveTray(int tray_state);

/*
    Opens the cd tray if it is closed.  Closes the cd tray if it is open.   Because
    CDFS does not provide a means of determining whether the tray is open or shut, !cd
    assumes that the tray is initially shut on power up and updates a toggle variable in
    response to handset initiated tray open/close requests.  !cd has to rely on this
    variable to tell whether the tray is currently open or closed and therefore whether
    to attempt to eject the tray or to close it.  If the user intermixes manual and
    remote tray operation, a second remote button press may sometimes be necessary
    because manually operated tray actions will not update the toggle variable.  Note
    that if CDFS attempts to do a tray close operation and fails (because the tray is
    already closed), it does not return an error.  Similarly tray open.  CDFS should
    provide a way of telling whether the tray is open or closed.
    Requires: tray_state, which indicates the current position of the tray.
    Returns:   - updated tray_state.
*/

static void SetErrorSystemVar(char *mess,char *file,int ln);
/* 
    Creates and sets a system variable called "err" with appropriate error diagnostics.      Error$Message and Error$Number may also have been set.  Error$Message and 
    Error$Number are nothing to do with !cd. 
    Requires: - 'mess', which is the error message.                                    
              - 'file', which is the file in which the error occurred.                 
              - 'ln', which is the line number in the file in which the error occurred. 
    Should only be called on FATAL error and assumes that 'ln' is never greater than 
    999999.  
*/                               

static void Finish(void);

/*
    !cd is designed to run forever.  Finish() shuts down !cd as a result of a fatal error
    occurring.  Following execution of this function it is advisable to carry out a
    hardware reset.
*/

/*-------------------------------------------------------------------------------------*/
/*                       External functions are declared in main.h                     */
/*-------------------------------------------------------------------------------------*/


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  main()                                                                  */
/*  BEHAVIOUR: Initialises as a wimp task and continuously monitors the state of the   */
/*             cd drive, launching the appropriate application when a compact disc is  */
/*             inserted into the drive.  While there is no cd present in the drive, a  */
/*             splash screen is displayed which indicates to the user that !cd is      */
/*             waiting for a cd to be inserted.  !cd runs forever, unless a fatal      */
/*             error occurs, at which point ErrorHandler() (see below) cleans up and   */
/*             finishes.                                                               */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
int main(void)
{
 int tray_state = TRAY_IN;

   #ifdef FN_TRACE
     puts("main()");
   #endif

   Initialise();

   #ifdef FORCE_FATAL_ERROR
     tray_state = 3/0;
   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   for (;;) Poll(&tray_state);
}
/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Initialise()                                                            */
/*  BEHAVIOUR: Sets up a list of the signal errors we want to catch, and which !cd     */
/*             would not be able to catch without this initialisation and              */
/*             SignalCatcher() at the end of main.c.  These types of errors include    */
/*             operating system error, division by zero, bad memory access, and so on. */
/*                                                                                     */
/*             Initialises !cd as a wimp task.                                         */
/*                                                                                     */
/*             CDSupport_Enable is associated with David DeVorchik's UpCallV module    */
/*             (for use when the STB is put into standby mode).                        */
/*                                                                                     */
/*             The splash (PleaseInsertCd) screen is brought up on a window which      */
/*             covers the whole screen.                                                */
/*                                                                                     */
/*             Memory (poll_blk) is allocated for use when polling the wimp and is     */
/*             primarily used for receiving messages from a task which !cd has         */
/*             launched.                                                               */
/*                                                                                     */
/*             InitCDFSDriverSWIS():- a CDFS control block is set up which is          */
/*             necessary for being able to access the cd drive using any of the CDFS   */
/*             Driver SWI's.  There must be one control block for each cd drive.  This */
/*             application assumes that there will never be more than one cd drive.    */
/*             The cd block is created as a dynamic memory area, which allows any task */
/*             launched by !cd access to the CDFS Driver SWI's using the same block of */
/*             memory.                                                                 */
/*                                                                                     */
/*             DriveStatus(first_access):- if there is no cd present in the drive      */
/*             during power up, CDFS thinks that there is a faulty cd present the      */
/*             first time it executes a CD_DriveStatus SWI call.  !cd would then act   */
/*             on this information by ejecting the non-existant faulty cd.  To         */
/*             overcome this, a first call to CD_DriveStatus is executed as part of    */
/*             !cd's initialisation sequence.  DriveStatus() is told that this is the  */
/*             first CD_DriveStatus call, and therefore does nothing to handle the     */
/*             (non-existant) error.                                                   */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void Initialise(void)
{
 int first_access = TRUE;
 _kernel_oserror *err;            /* SWI error handling pointer.                       */
 extern int poll_word_address;    /* Used in connection with David DeVorchik's UpCallV */
                                  /* (CDSupport) code.                                 */

   #ifdef FN_TRACE
     puts("Initialise()");
   #endif

   HourGlass(ON);

   Signals();

   if ((err = swi(Wimp_Initialise,R0,310,R1,0x4B534154,R2,NULL,R3,msg_list,OUT,R1,
        &cd_task_handle,END)) != NULL)
            goto fatal_error_exit;

   if ((err = swi(CDSupport_Enable,OUT,R0,&poll_word_address,END)) != NULL)
        goto fatal_error_exit;

   if ((hBackgroundWindow = CreateFullScreenWindow()) == NULL )
        goto fatal_error_exit;
   else
   {
        /* Show splash screen.                                                         */
        ShowWindow( hBackgroundWindow, TRUE );

        /* Enable keyboard input via the wimp.                                         */
        if ((err = swi(Wimp_SetCaretPosition,R0,hBackgroundWindow,R1,-1,R2,0,R3,0,R4,0,
           R5,0,END)) != NULL)
           ErrorHandler(__FILE__,__LINE__,"Initialise()",0,
           "Failed to claim keyboard input focus",WARNING);
   }

   if ((poll_blk = malloc(255)) == NULL)
        goto insufficient_memory_exit;

   InitCDFSDriverSWIS();

   DriveStatus(first_access);

   HourGlass(OFF);

   return;

   insufficient_memory_exit:
     ErrorHandler(__FILE__,__LINE__,"Initialise()",0,
                     "Insufficient Memory: 255 more bytes required.",FATAL);
     return;

   fatal_error_exit:
     ErrorHandler(__FILE__,__LINE__,"Initialise()",err->errnum,err->errmess,FATAL);
     return;


}
/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Poll()                                                                  */
/*  BEHAVIOUR: Listens for messages from the other cd task, the implications of this   */
/*             being whether or not to display the splash (idle) screen.  Calls Idle() */
/*             on null events. Idle() monitors the state of the cd drive, activating   */
/*             and deactivating the other cd task as and when appropriate.  (The       */
/*             splash screen will get displayed and hidden in response to start up and */
/*             die messages from the other task).                                      */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void Poll(int *tray_state)
{
 unsigned int mask = 0xC3872; /* 00000000000011000011100001110010 Refer PRM p.3-117    */
                            /* Determines which event codes get disabled.  Current     */
        /* mask setting indicates that we're only interested in null events (results   */
        /* in Idle() being called), and user messages.                                 */
 int event_code;    /* 0 (null event) is returned as a result of polling the wimp if   */
                    /* no other event has occurred, or event code 17 is returned       */
                    /* indicating that a message has arrived from the other task.      */
 _kernel_oserror *err;  /* SWI error handling pointer.                                 */
 int newtime;       /* Earliest time for a null reason code event is 100 centiseconds. */
 #define CD_TRAY 0x94       /* Blue button on the handset.                             */

   #ifdef FN_TRACE
     puts("Poll()");
   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   mask &= ~2;      /* Enable Redraw events. */

   /* Dizzy's UpCallV stuff. */
      mask &= ~( 1<< 13 );      /* Enable poll-word events */
      mask |=  (3 << 22);  	/* Scan poll word + at high priority */

   if ((err = swi(OS_ReadMonotonicTime,OUT,R0,&newtime,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Poll()",err->errnum,err->errmess,WARNING);

   if ((err = swi(Wimp_PollIdle,R0,mask,R1,poll_blk,R2,newtime+50,R3,poll_word_address,
        OUT,R0,&event_code,END)) != NULL)
         goto fatal_error_exit;

   switch (event_code)
   {
      case 0  : Idle();
                break;

      /* We get this event code just after starting up the first time only.  It comes */
      /* from the wimp.  Just after the splash screen has been drawn, the wimp thinks */
      /* that the screen has been damaged and needs redrawing so it overwrites the    */
      /* splash screen with what was there before, i.e. with a blank screen.  This    */
      /* doesn't happen if the screen is drawn on a null event because null events    */
      /* have the lowest priority and so the 'repair damaged screen' would occur      */
      /* after the splash screen has been displayed and noted as the current screen   */
      /* display.                                                                     */
      /* Note that this really should read the window handle from the event structure */
      case 1  : RedrawWindow( hBackgroundWindow );   /* Redraw splash screen.         */
                #ifdef SCREEN_DUMP
                   GrabScreen();
                #endif
                break;

      case 8  : if ((char)((*(poll_blk + 6))) == CD_TRAY)
                {
                     *tray_state = MoveTray(*tray_state);
                }
                break;

      /* Upon reciept of a Poll-Word non-zero event check to see if a sub-task is     */
      /* running, if it is then send it a die message, otherwise just kill the box.   */
      case 13 : if ((err = swi(CDSupport_Standby,R0,0,END)) != NULL)
                     ErrorHandler(__FILE__,__LINE__,"Poll()",err->errnum,err->errmess,
                     WARNING);

                if (other_task == ACTIVE)
                {
                    SendMessage(TASK_DIE,BROADCAST,NULL);
                    waiting_to_issue_cdsupport_standby = TRUE;
                }
                else
                {
		    if ( ( err = swi( CDSupport_Standby, R0, 1, END ) ) != NULL )
		    {
		      ErrorHandler(__FILE__,__LINE__, "Poll()", err->errnum,
		      err->errmess,
		      WARNING );
		    }
                }

                break;

      case 17 : ReadMessage();
                break;
   };

   return;

   fatal_error_exit:
     ErrorHandler(__FILE__,__LINE__,"Poll()",err->errnum,err->errmess,FATAL);
     return;

 #undef CD_TRAY
}
/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Idle()                                                                  */
/*  BEHAVIOUR: Watches the cd drive and determines what type of cd is loaded, if any.  */
/*             The appropriate application is subsequently launched.   If an unknown   */
/*             type of cd is detected in the drive, it will be ejected.                */
/*                                                                                     */
/*             !cd will execute a run file called "!RunCD" if it is able to locate     */
/*             such a file in the root directory of the compact disc.  "!RunCD" is     */
/*             responsible for tidying up after itself if an error conditon occurs     */
/*             during it's execution.                                                  */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void Idle(void)
{
 int cd_type;  /* Indicates the type of cd present and therefore which application to  */
               /* launch.  If not recognized, the cd will be ejected and splash screen */
               /* redisplayed.                                                         */
 int status;

   #ifdef FN_TRACE
     puts("Idle()");
   #endif

   #ifdef MEMORY_TRACE
     ShowMem(__FILE__,__LINE__);
   #endif

   /* If there's a cd present in the drive, and if the appropriate cd task hasn't      */
   /* been launched, and if !cd isn't waiting for a previously launched cd task to     */
   /* say that it's alive and well, or is not well and is about to die ....            */

   status = DriveStatus(NULL);
   if (status == DISC_PRESENT && other_task == NOT_ACTIVE && wait_for_ack == FALSE)
   {
       cd_type = DetectCdType();

       switch (cd_type)
       {
         case TYPE_PHOTO: Launch("WimpTask *RUN PhotoCD:!Run");
                          break;

         case TYPE_AUDIO: Launch("WimpTask *RUN AudioCD:!Run");
                          break;

         case TYPE_VIDEO: if (MPEG_HardwarePresent())
                          {
                              #ifdef DEVELOPMENT
                                puts("MPEG Hardware Present.");
                              #endif
                              Launch("WimpTask *RUN VideoCD:!Run");
                          }
                          else
                          {
                              #ifdef DEVELOPMENT
                                puts("MPEG Hardware Not Found.");
                              #endif
                              Eject();
                          }
                          break;

         case TYPE_RUNCD: Launch("CDFS:!RunCD");
                          break;

         case FAULTY_CD:  RejectCD(FAULTY_CD);
                          break;

         default :        RejectCD(UNKNOWN_CD);
                          break;
       }
   }
   /* If !cd is the first of the two tasks to detect that the cd has been ejected ...  */
   else if (other_task == ACTIVE && status == DISC_NOT_PRESENT)
        {
            /* Tell the other cd task to die.  If there was a problem with sending the */
            /* "You must die" message, !cd will close down and terminate as it is then */
            /* not safe to carry on.                                                   */
            SendMessage(msg_list[TASK_DIE_INDEX],BROADCAST,NULL);

            wait_for_ack = TRUE;  /* Don't do anything else until the new task has     */
                                  /* acknowledged receipt of the above message.        */
        }

}
/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  DetectCdType()                                                          */
/*  BEHAVIOUR: Uses the "cd_type" library to determine what type of cd is present in   */
/*             the drive, thus enabling the correct application to be launched.        */
/*  RETURNS:   TYPE_VIDEO, TYPE_RUNCD, TYPE_AUDIO, TYPE_PHOTO, or FAULTY_CD, depending */
/*             upon what type of cd is present in the drive.                           */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int DetectCdType(void)
{
 int type = TYPE_UNKNOWN;

   #ifdef FN_TRACE
     puts("DetectCdType()");
   #endif

   HourGlass(ON);

   type = IsItVideoCd();
   switch (type)
   {
     case TRUE:       type = TYPE_VIDEO;
                      goto normal_exit;
                      break;
     case FAULTY_CD:  goto bad_exit;
                      break;
   }

   type = IsItRunCd();
   switch (type)
   {
     case TRUE:       type = TYPE_RUNCD;
                      goto normal_exit;
                      break;
     case FAULTY_CD:  goto bad_exit;
                      break;
   }

   type = IsItAudioCd();
   switch (type)
   {
     case TRUE:       type = TYPE_AUDIO;
                      goto normal_exit;
                      break;
     case FAULTY_CD:  goto bad_exit;
                      break;
   }

   type = IsItPhotoCd();
   switch (type)
   {
     case TRUE:       type = TYPE_PHOTO;
                      goto normal_exit;
                      break;
     case FAULTY_CD:  goto bad_exit;
                      break;
   }

   normal_exit:
     HourGlass(OFF);
     return type;

   bad_exit:
     HourGlass(OFF);
     return FAULTY_CD;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  MPEG_HardwarePresent()                                                  */
/*  BEHAVIOUR: Determines whether or not MPEG hardware is present.  This is necessary  */
/*             in determining whether or not to launch !VideoCD.                       */
/*  RETURNS:   TRUE if MPEG hardware is present, FALSE otherwise.                      */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int MPEG_HardwarePresent(void)
{
 int MPEG_Hardware = FALSE;
 char buffer[256] = NULL;
 _kernel_oserror *err = NULL;

   /* Ref: spinner -> $.Func-Spec.Software.Falcon.Podule006.                           */

   if ((err = swi(Podule_ReadChunk,R0,0,R2,buffer,R3,0,END)) != NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"MPEG_HardwarePresent()",err->errnum,err->errmess,
        WARNING);
        MPEG_Hardware = FALSE;
   }
   else
   {
      if (strlen(buffer) > 255)
          ErrorHandler(__FILE__,__LINE__,"MPEG_HardwarePresent()",0,
          "Exceeded array bounds.",
          FATAL);

      /* If MPEG hardware not present, buffer will contain "Internal video hardware\0".*/
      /* If MPEG hardware present, buffer will contain "Internal MPEG1 hardware\0".    */

      if (strncmp("Internal MPEG1 hardware",buffer,22) == NULL)
          MPEG_Hardware = TRUE;
      else
          MPEG_Hardware = FALSE;
   }

   #ifdef DEVELOPMENT
     printf("\nMPEG_HardwarePresent() : %s.\n",buffer);
   #endif

   return MPEG_Hardware;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  MoveTray()                                                              */
/*  BEHAVIOUR: Opens the cd tray if it is closed.  Closes the cd tray if it is open.   */
/*             Because CDFS does not provide a means of determining whether the tray   */
/*             is open or shut, !cd assumes that the tray is initially shut on power   */
/*             up and updates a toggle variable in response to handset initiated tray  */
/*             open/close requests.  !cd has to rely on this variable to tell whether  */
/*             the tray is currently open or closed and therefore whether to attempt   */
/*             to eject the tray or to close it.  If the user intermixes manual and    */
/*             remote tray operation, a second remote button press may sometimes be    */
/*             necessary because manually operated tray actions will not update the    */
/*             toggle variable.  Note that if CDFS attempts to do a tray close         */
/*             operation and fails (because the tray is already closed), it does not   */
/*             return an error.  Similarly tray open.  CDFS should provide a way of    */
/*             telling whether the tray is open or closed.                             */
/*  REQUIRES:  - 'tray_state', which indicates the current position of the tray.       */
/*  RETURNS:   - updated tray_state.                                                   */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int MoveTray(int tray_state)
{
 _kernel_oserror *err = NULL;

   switch (tray_state)
   {
      case TRAY_OUT : if ((err = swi(CD_CloseDrawer,R7,cd_blk,END)) != NULL)
                      {
                           ErrorHandler(__FILE__,__LINE__,"MoveTray()",err->errnum,
                             err->errmess,WARNING);
                      }
                      else
                      {
                           tray_state = TRAY_IN;
                      }
                      break;
      case TRAY_IN  : if ((err = swi(CD_OpenDrawer,R7,cd_blk,END)) != NULL)
                      {
                           ErrorHandler(__FILE__,__LINE__,"MoveTray()",err->errnum,
                             err->errmess,WARNING);
                      }
                      else
                      {
                           tray_state = TRAY_OUT;
                      }
                      break;
   }

   return tray_state;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  RejectCD()                                                              */
/*  BEHAVIOUR: !cd is unable to identify the type of cd present in the drive, or the   */
/*             cd was found to be faulty.  Eject it so that !cd doesn't keep on        */
/*             detecting that an unknown or faulty cd is present and continuously      */
/*             tries to deal with it in a never ending loop.  Ejecting the cd and      */
/*             updating 'wait_for_ack' will result in the return of the splash screen. */
/*             'wait_for_ack' indicates that we don't have to wait for the new task to */
/*             send an I am alive or an I am dying message, seeing as it didn't start  */
/*             up in the first place.   If the cd drive is locked, it will get         */
/*             unlocked, although CDFS sometimes has a problem unlocking and ejecting  */
/*             cd's if they are faulty.  The good news is that the current version of  */
/*             !cd (version 1.09) does not lock the cd drawer.                         */
/*  REQUIRES:  - 'reason', which is FAULTY_CD or UNKNOWN_CD and which determines what  */
/*                type of feedback the user gets.                                      */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void RejectCD(int reason)
{
 time_t t;  /* Used to ensure that the user feedback icon is displayed for at least 6  */
            /* seconds.                                                                */

   #ifdef FN_TRACE
     puts("RejectCD()");
   #endif

   t = time(NULL);    /* Save the current time.                                        */

   switch (reason)
   {
     case FAULTY_CD:  ShowCdIcon(FAULTY_CD);
                      break;

     case UNKNOWN_CD: ShowCdIcon(UNKNOWN_CD);
                      break;

     default:         ErrorHandler(__FILE__,__LINE__,"RejectCD()",0,
                      "Unknown reason code.",WARNING);
                      break;
   }

   #ifdef SCREEN_DUMP
      GrabScreen();
   #endif

   Eject();
   wait_for_ack = FALSE;

   do {                               /* Ensure that the user feedback icon has been   */
   } while ((time(NULL) - t) < 6);    /* displayed for at least 6 seconds before       */
                                      /* removing it.                                  */

   splash_screen = HIDDEN;            /* Force splash screen to be redrawn.            */
   RedrawWindow(hBackgroundWindow);   /* This will delete the user feedback icon.      */

}
/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Eject()                                                                 */
/*  BEHAVIOUR: Ejects the cd from the drive.  An eject() request in theory overides    */
/*             the possibility of the drive being locked but in practice CDFS          */
/*             sometimes has a problem unlocking and / or ejecting faulty cd's.  !cd   */
/*             (version 1.09) does not lock the drawer at any stage.                   */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void Eject(void)
{
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE
     puts("Eject()");
   #endif

   if (other_task == NOT_ACTIVE)
       HourGlass(ON);

   if ((err = swi(OS_CLI,R0,"*CDFS:Unlock",END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Eject()",err->errnum,err->errmess,WARNING);

   if ((err = swi(CD_OpenDrawer,R7,cd_blk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Eject()",err->errnum,err->errmess,WARNING);
   else
   if ((err = swi(OS_CLI,R0,"*CDFS:Eject",END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Eject()",err->errnum,err->errmess,WARNING);

   if (other_task == NOT_ACTIVE)
       HourGlass(OFF);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  SignalCatcher()                                                         */
/*  BEHAVIOUR: Called when error interrupts occur (e.g. bad memory access, division by */
/*             zero, operating system error, and so on).  From here, we're able to     */
/*             pass the error to !cd's error handling function.  Refer PRM p. 4-302    */
/*             and Horspool's C programming book p. 173 for further info.  This        */
/*             functionality was successfully tested by introducing an "int a = 3/0;"  */
/*             i.e. division by zero, which is illegal, into display.c.                */
/*  PREREQUISITES: A call to Signals() must have been executed.  This specifies which  */
/*                 signals we're interested in catching (see init.c).                  */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void SignalCatcher(int code)
{
 char mess[50];

   #ifdef FN_TRACE
     puts("SignalCatcher()");
   #endif

   switch (code)
   {
     case SIGABRT : sprintf(mess,"Interrupt -> abort.\n");
                    break;
     case SIGFPE  : sprintf(mess,"Interrupt -> arithmetic exception.\n");
                    break;
     case SIGILL  : sprintf(mess,"Interrupt -> illegal instruction.\n");
                    break;
     case SIGINT  : sprintf(mess,"Interrupt -> attention request from user.\n");
                    break;
     case SIGSEGV : sprintf(mess,"Interrupt -> bad memory access.\n");
                    break;
     case SIGTERM : sprintf(mess,"Interrupt -> termination request.\n");
                    break;
     case SIGSTAK : sprintf(mess,"Interrupt -> stack overflow.\n");
                    break;
     case SIGUSR1 : sprintf(mess,"Interrupt -> user definable interrupt.\n");
                    break;
     case SIGUSR2 : sprintf(mess,"Interrupt -> user definable interrupt.\n");
                    break;
     case SIGOSERROR : sprintf(mess,"Interrupt -> operating system error.\n");
                    break;
     default      : sprintf(mess,"Interrupt -> interrupt code is unknown.\n");
                    break;
   }

   ErrorHandler(__FILE__,__LINE__,"SignalCatcher()",code,mess,FATAL);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ErrorHandler()                                                          */
/*  BEHAVIOUR: Error handler common to all files within !cd.  A fatal error will shut  */
/*             down !cd.  A warning error will not.  The DEVELOPMENT definition        */
/*             determines whether or not errors are reported.  It should be defined    */
/*             (or undefined) in the "common" header file since ErrorHandler() is used */
/*             by all of !cd's source files.  Note that some error messages form part  */
/*             of the runtime logic.  For example errors are generated whilst there is */
/*             no cd in the drive.  !cd relies on these errors to know whether or not  */
/*             a cd is present.                                                        */
/*  REQUIRES:  - 'file', which is the name of the source file from which the error     */
/*                originates.                                                          */
/*             - 'ln', which is the line number at which the error occurred.           */
/*             - 'fn', which is the name of the function from which the error          */
/*                originates.                                                          */
/*             - 'errnum', which is the error number.  Refer PRM p.1-42 for more info. */
/*             - 'mess', which is the error message string.                            */
/*             - 'level', which is the level of error.  This can be FATAL, resulting   */
/*                in a complete shut down of !cd and most probably requiring a         */
/*                subsequent hardware reset, or WARNING, in which case !cd carries on  */
/*                running.                                                             */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void ErrorHandler(char *file,int ln,char *fn, int errnum, char *mess, int level)
{
   #ifdef FN_TRACE
     puts("ErrorHandler()");
   #endif

   #ifdef DEVELOPMENT

      if (level == FATAL) puts("FATAL ERROR:");
          else if (level == WARNING) puts("WARNING:");
                   else puts("WARNING: Unknown error level in ErrorHandler.");

      printf("  Application: !cd\n");
      printf("  File: %s\n",file);
      printf("  Function: %s\n",fn);
      printf("  Line: %d\n",ln);
      printf("  Error number: %d\n",errnum);
      printf("  %s\n",mess);

   #endif

   if (level == FATAL)
   {
       SetErrorSystemVar(mess,file,ln);
       Finish();
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  SetErrorSystemVar()                                                     */
/*  BEHAVIOUR: Creates and sets a system variable called "err" with appropriate error  */
/*             diagnostics.  Error$Message and Error$Number may also have been set.    */
/*             Error$Message and Error$Number are nothing to do with !cd.              */
/*  REQUIRES: - 'mess', which is the error message.                                    */
/*            - 'file', which is the file in which the error occurred.                 */
/*            - 'ln', which is the line number in the file in which the error occurred */
/*  PREREQUISITES: Should only be called on FATAL error.                               */
/*  ASSUMPTIONS: - 'ln' is never greater than 999999.                                  */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void SetErrorSystemVar(char *mess,char *file,int ln)
{
 char *str = NULL;

   if ((str = calloc(strlen("Set err ")+
              strlen("Application:!CD,File:,Line:,Error message:")+
              strlen(file)+strlen("999999")+strlen(mess)+1,sizeof(char))) != NULL)
   {
        sprintf(str,"Set err Application:!CD,File:%s,Line:%d,Error message:%s",
        file,ln,mess);
        swi(OS_CLI,R0,str,END);
        free(str);
   }
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Finish()                                                                */
/*  BEHAVIOUR: !cd is designed to run forever.  Finish() shuts down !cd as a result of */
/*             a fatal error occurring.  Following execution of this function it is    */
/*             advisable to carry out a hardware reset.   Error levels within this     */
/*             function must all be WARNING, because FATAL would result in Error       */
/*             Handler() calling Finish() when we are actually already in Finish().    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void Finish(void)
{
 _kernel_oserror *err;  /* SWI error handling pointer.                                 */

   #ifdef FN_TRACE
     puts("Finish()");
   #endif

   /* Remove the dynamic memory area which was used for the CDFS control block.        */
   if (cd_blk != NULL)
       if ((err = swi(OS_DynamicArea,R0,1,R1,cd_blk_id,END))!=NULL)
            ErrorHandler(__FILE__,__LINE__,"Finish()",err->errnum,err->errmess,WARNING);

   /* Free up the malloc'd memory which was used for receiving messages from other     */
   /* tasks.                                                                           */
   if (poll_blk != NULL)
       free(poll_blk);

   /* Get rid of the window which was used for displaying the splash screen.           */
   DestroyWindow(hBackgroundWindow);

   if ((err = swi(CDSupport_Disable,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Finish()",err->errnum,err->errmess,WARNING);

   /* Inform the WIMP that !cd is about to terminate.                                  */
   if ((err = swi(Wimp_CloseDown,R0,cd_task_handle,R1,0x4B534154,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Finish()",err->errnum,err->errmess,WARNING);

   if ((err = swi(OS_Exit,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"Finish()",err->errnum,err->errmess,WARNING);
}
/*=====================================================================================*/
