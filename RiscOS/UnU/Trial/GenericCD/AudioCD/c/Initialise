/*=====================================================================================*/
/*                                                                                     */
/*  FILE:  !AudioCD.c.Initialise                                                       */
/*  DESCRIPTION:                                                                       */
/*  AUTHOR:  crose@omi.co.uk                                                           */
/*  MODIFICATION HISTORY:                                                              */
/*    Date         Name                Description                                     */
/*    ----         ----                -----------                                     */
/*                                                                                     */
/*=====================================================================================*/

#undef GLOBALS__

/*-------------------------------------------------------------------------------------*/
/*                       Inclusion of !AudioCD header files.                           */
/*-------------------------------------------------------------------------------------*/

#include "Initialise.h"
#include "Common.h"
#include "Display.h"
#include "Messages.h"
#include "ButtonOps.h"

#ifdef DEVELOPMENT__
  #include "Memory.h"
#endif

/*-------------------------------------------------------------------------------------*/
/*                       Inclusion of standard C header files.                         */
/*-------------------------------------------------------------------------------------*/

#if defined(DEVELOPMENT__) || defined(MEMORY_TRACE__) || defined(FN_TRACE__)
    #include "stdlib.h"
    #include "stdio.h"
#endif

#include "signal.h"

/*-------------------------------------------------------------------------------------*/
/*   Inclusion of SWI interface header.  Allows constructs of the type                 */
/*   err = swi(Wimp_Initialise,R0,310,R1,0x4B534154,R2,NULL,R3,msg_list,OUT,R1,        */
/*   &cd_task_handle,END);                                                             */
/*-------------------------------------------------------------------------------------*/

#include "swicall.h"

/*-------------------------------------------------------------------------------------*/
/*                         Internal Function Prototypes.                               */
/*-------------------------------------------------------------------------------------*/

static void CursorsOff(void);
static void ScreenDimensions(void);
static void ReadJPEGDimensions(void);
static void ButtonMeasurements(void);
static void TextDisplayAreaMeasurements(void);
static void CreateScreenDisplay(int *dma_id);
static void InitButtonSprites(void);
static int PrepareShadowSprite(int shadowsize);
static void JPEGOverlay(char *jpegfile);
static void ShowScreenDisplay(int dma_id);
static int GetLastTrackEndTime(int addressing_mode);
static int GetLogicalBlockAddress(int track);
static int ConvertFrameAddressToTimeOffset(int addressing_mode,int address);
static char AudioData(int track);
static int secs(int code);

/*-------------------------------------------------------------------------------------*/
/*                    Internal Global Variable Declarations.                           */
/*-------------------------------------------------------------------------------------*/

static int xres,yres;
static int original_JPEG_pixel_width;
static int original_JPEG_pixel_height;

/*-------------------------------------------------------------------------------------*/
/*                            Internal Macro Definitions.                              */
/*-------------------------------------------------------------------------------------*/

#undef LOW_MEM        /* Defining LOW_MEM means that the JPEG screen image is scaled   */
                      /* up whilst plotting to the screen and the shadow sprite for    */
                      /* holding it after reading it in from file and before plotting  */
                      /* to the screen, is the same size as the originally supplied    */
                      /* JPEG (i.e. smaller than screen size unless the original JPEG  */
                      /* is coincidentally the same size as the screen).  Undefining   */
                      /* LOW_MEM means that the JPEG is scaled up immediately when     */
                      /* read into the shadow sprite buffer and therefore the shadow   */
                      /* sprite buffer will most likely be larger than otherwise.  The */
                      /* advantage of doing this however, is that anti-twitter can be  */
                      /* applied before plotting to the screen because the image is    */
                      /* already screen size.                                          */


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  Signals()                                                               */
/*  BEHAVIOUR: !cd should trap *all* errors.  Executing this function as part of the   */
/*              initialisation sequence means that when certain errors occur which     */
/*              would not normally be trapped by !cd, !cd's SignalCatcher() function   */
/*              in main.c will get a look in and be able to handle them instead.       */
/*              These types of errors include division by zero, bad memory access, and */
/*              so on.  This functionality was tested by deliberately incorporating    */
/*              "int a = 3/0;" into display.c.  !cd was successful in catching the     */
/*              error via use of this code.  Refer PRM p.4-302 and Horspool's C        */
/*              programming book p. 173 for further info.                              */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

extern void Signals(void)
{
 int i;
 int signal_list[] = { SIGABRT, SIGFPE,
                       SIGILL,  SIGINT,
                       SIGSEGV, SIGTERM,
                       SIGSTAK, SIGUSR1,
                       SIGUSR2, SIGOSERROR};

   for (i = 0; i < 10; signal(signal_list[i],SignalCatcher),i++);
}


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void ScreenDisplay(void)
{
 int dma_id;

   #ifdef FN_TRACE__
     puts("ScreenDisplay()");
   #endif

   CursorsOff();
   ScreenDimensions();
   ButtonMeasurements();
   TextDisplayAreaMeasurements();
   CreateScreenDisplay(&dma_id);
   ShowScreenDisplay(dma_id);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

static void CursorsOff(void)
{
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("CursorsOff()");
   #endif

   if ((err = swi(OS_RemoveCursors,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"CursorsOff()",err->errnum,err->errmess,WARNING__);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void GetCDBlock(void)
{
 int *area_id;
 extern char *cd_blk;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("GetCDBlock()");
   #endif

   if ((area_id = malloc(4))==NULL)
        ErrorHandler(__FILE__,__LINE__,"GetCDBlock()",0,"Insufficient Memory.",FATAL__);

   if ((err = swi(OS_ReadVarVal,R0,"cdblk_area_id",R1,area_id,R2,4,R3,0,R4,0,OUT,
       R1,&area_id,END))!=NULL)
          ErrorHandler(__FILE__,__LINE__,"GetCDBlock()",err->errnum,err->errmess,FATAL__);

   if ((err = swi(OS_DynamicArea,R0,2,R1,*area_id,OUT,R3,&cd_blk,END))!=NULL)
          ErrorHandler(__FILE__,__LINE__,"GetCDBlock()",err->errnum,err->errmess,FATAL__);

   free(area_id);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ScreenDimensions(void)
{
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("ScreenDimensions()");
   #endif

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,11,OUT,R2,&xres,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL__);

   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,12,OUT,R2,&yres,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ScreenDimensions()",err->errnum,err->errmess,
        FATAL__);

   xres++; yres++;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  ReadJPEGDimensions()                                                    */
/*  BEHAVIOUR: Reads the pixel width, and the height, of the user supplied JPEG player */
/*             screen.  Sets 'original_JPEG_pixel_width' and 'original_JPEG_pixel_     */
/*             height' accordingly.                                                    */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ReadJPEGDimensions(void)
{
 _kernel_oserror *err = NULL;
 #define JPEG_FileInfo 0x49981

   #ifdef FN_TRACE__
     puts("ReadJPEGDimensions()");
   #endif

   if ((err = swi(JPEG_FileInfo,R0,0,R1,"AudioCD:Player",OUT,R2,
        &original_JPEG_pixel_width,R3,&original_JPEG_pixel_height,END)) != NULL)
          ErrorHandler(__FILE__,__LINE__,"ReadJPEGDimensions()",err->errnum,err->errmess,
          FATAL__);

   #undef JPEG_FileInfo
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void ButtonMeasurements(void)
{

 extern int button_start_posx,button_width,separation,eject_x1,eject_x2,stop_x1,stop_x2,
            pause_x1,pause_x2,back_x1,back_x2,play_x1,play_x2,forward_x1,forward_x2,
            button_low_y,button_high_y;

   #ifdef FN_TRACE__
     puts("ButtonMeasurements()");
   #endif

   button_start_posx = (xres/10)+(((xres-(xres/10))-(xres/10))/5);
   button_width = 60;
   separation = ((xres-(xres/10))-button_start_posx-(6*button_width))/6;
   eject_x1 = button_start_posx;
   eject_x2 = eject_x1 + button_width;
   stop_x1 = eject_x2 + separation;
   stop_x2 = stop_x1 + button_width;
   pause_x1 = stop_x2 + separation;
   pause_x2 = pause_x1 + button_width;
   back_x1 = pause_x2 + separation;
   back_x2 = back_x1 + button_width;
   play_x1 = back_x2 + separation;
   play_x2 = play_x1 + button_width;
   forward_x1 = play_x2 + separation;
   forward_x2 = forward_x1 + button_width;
   button_low_y = (yres/10)+(((yres/3)-(yres/10))/10);
   button_high_y = (yres/10)+((((yres/3)-(yres/10))/10)*3);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void TextDisplayAreaMeasurements(void)
{
 extern int text_area_x1,text_area_y1,text_area_width,text_area_height,
            track_text_area_x1,track_text_area_y1,time_text_area_x1,time_text_area_y1;

   #ifdef FN_TRACE__
     puts("TextDisplayAreaMeasurements()");
   #endif

   text_area_x1 = (((xres-(xres/10))-(xres/10))/2)+(xres/10);
   text_area_y1 = (yres/10)+(((yres/3)-(yres/10))/2)+(((yres/3)-(yres/10))/20);
   text_area_width = ((xres - (xres/10))-(xres/10))-(text_area_x1-(xres/10))-(((xres -
                       (xres/10))-(xres/10))/12);
   text_area_height = ((yres/3)-(yres/10))/5;
   track_text_area_x1 = text_area_x1 + 5;
   track_text_area_y1 = text_area_y1;
   time_text_area_x1 = text_area_x1 + 150;
   time_text_area_y1 = text_area_y1;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  CreateScreenDisplay()                                                   */
/*  BEHAVIOUR: Loads buttons sprite file into the sprite area pointed to by buttons_   */
/*             sprarea.  Loads JPEG screen display into a shadow sprite area ready for */
/*             plotting to the screen.  If LOW_MEM is defined, the shadow sprite has   */
/*             the same dimensions as the original JPEG and scaling up to full screen  */
/*             size does not occur until the point at which the image is plotted to    */
/*             the screen.  In this case, twitter must be applied *after* the image    */
/*             has been plotted on the screen.   If LOW_MEM is not defined, the        */
/*             JPEG is scaled up immediately to have the same dimensions as the screen.*/
/*             This obviously raises the mimimum amount of memory required but has the */
/*             advantage that twitter can be applied (using the new twitter module)    */
/*             before the image is plotted on the screen.  When twitter is applied on  */
/*             the screen, the user does see it being applied.  This is unsatisfactory.*/
/*             Both the old and the new twitter modules can twitter an area of memory  */
/*             that is not screen memory, but the area being twittered must be the     */
/*             size it's going to be when it's actually displayed.                     */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void CreateScreenDisplay(int *dma_id)
{

   #ifdef FN_TRACE__
     puts("CreateScreenDisplay()");
   #endif

   InitButtonSprites();
   ReadJPEGDimensions();

   #ifdef LOW_MEM
      *dma_id = PrepareShadowSprite((original_JPEG_pixel_width*
                                     original_JPEG_pixel_height
                                     * 2)+16+300);
   #else
      *dma_id = PrepareShadowSprite((xres*yres*2)+16+300);
   #endif
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void InitButtonSprites(void)
{
 int type = 0;
 int *ptr = NULL;
 extern int buttons_sprsize;
 extern char *buttons_sprarea;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("InitButtonSprites()");
   #endif

   /* Check that the buttons sprite file exists.  Type returned as 1 indicates that    */
   /* the object type found is a file.  Also check that it isn't an empty sprite file. */

   if ((err = swi(OS_File,R0,17,R1,BUTTONS_SPRITE,OUT,R0,&type,R4,&buttons_sprsize,END))
        !=NULL)
          ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",err->errnum,err->errmess,
          FATAL__);

   if (buttons_sprsize == 0)
       ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",0,
       "Buttons sprite contains no data.",FATAL__);

   buttons_sprsize = buttons_sprsize+44;

   if (type != 1)
       ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",type,
                    "Buttons spritefile does not exist.",FATAL__);

   if ((buttons_sprarea = malloc(buttons_sprsize+16))==NULL)
        ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",0,"Insuficient Memory.",
        FATAL__);

   ptr = (int *)buttons_sprarea;
   *ptr = buttons_sprsize;
   *(ptr+2) = 16;

   /* Initialise sprite area.                                                          */

   if ((err = swi(OS_SpriteOp,R0,512+9,R1,buttons_sprarea,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",err->errnum,err->errmess,
        FATAL__);

   /* Load sprite into the sprite area.                                                */

   if ((err = swi(OS_SpriteOp,R0,512+10,R1,buttons_sprarea,R2,BUTTONS_SPRITE,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"InitButtonSprites()",err->errnum,err->errmess,
        FATAL__);
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int PrepareShadowSprite(int shadowsize)
{
 extern char *shadow_screen_base;
 extern int shadow_first_sprite_offset;
 int shadow_area_id;
 int *ptr;
 int base_check;
 int size_check;
 int width,height;
 _kernel_oserror *err = NULL;
 int shadowspritemode;
 int max_check;

   #ifdef FN_TRACE__
     puts("PrepareShadowSprite()");
   #endif

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Find out the current screen mode.  The sprite will be created in that mode.      */
   if ((err = swi(OS_ScreenMode,R0,1,OUT,R1,&shadowspritemode,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
        FATAL__);

   /* Create the dynamic area.                                                         */
   if ((err = swi(OS_DynamicArea,R0,0,R1,-1,R2,shadowsize,R3,-1,R4,0,R5,shadowsize,R6,0,
        R7,0,R8,"shadow",OUT,R1,&shadow_area_id,R3,&shadow_screen_base,END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
         FATAL__);

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Check that it hasn't created a dynamic area of size zero, this being a known bug */
   /* in the past.                                                                     */

   if ((err = swi(OS_DynamicArea,R0,2,R1,shadow_area_id,OUT,R2,&size_check,R3,
        &base_check,R5,&max_check,END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
         FATAL__);

   /* Populate the first and third words of the sprite area control block.             */

   ptr = (int *)shadow_screen_base;
   *ptr = shadowsize;
   *(ptr + 2) = 16;   /* Byte offset to the sprite itself.                             */

   /* Initialise sprite area.                                                          */
   if ((err = swi(OS_SpriteOp,R0,512+9,R1,shadow_screen_base,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
        FATAL__);

   #ifdef LOW_MEM
     width = original_JPEG_pixel_width;
     height = original_JPEG_pixel_height;
   #else
     width = xres;
     height = yres;
   #endif

   /* Create the sprite.                                                               */
   if ((err = swi(OS_SpriteOp,R0,256+15,R1,shadow_screen_base,R2,"shadow",R3,0,R4,
        width,R5,height,R6,shadowspritemode,END)) != NULL)
          ErrorHandler(__FILE__,__LINE__,"PrepareShadowSprite()",err->errnum,err->errmess,
          FATAL__);

   /* Update 'shadow_first_sprite_offset' with the base address of the sprites control */
   /* block.  Note that this is not the same as the sprite AREA's control block.       */
   /* Refer p. 1-749 of the PRM for details.                                           */
   shadow_first_sprite_offset = (int)shadow_screen_base + 16;

   /* Write the JPEG player image onto the newly created blank sprite.                 */
   JPEGOverlay("AudioCD:Player");

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   return shadow_area_id;

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static void JPEGOverlay(char *jpegfile)
{
 int oldscb,oldsptr,oldsa;
 int *scale;
 extern char *shadow_screen_base;
 extern int shadow_first_sprite_offset;
 _kernel_oserror *err = NULL;
 #define JPEG_FileInfo 0x49981
 #define JPEG_PlotFileScaled 0x49983

   #ifdef FN_TRACE__
     puts("JPEGOverlay()");
   #endif

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Switch output to the shadow sprite.                                              */
   if ((err = swi(OS_SpriteOp,R0,512+60,R1,shadow_screen_base,R2,
        shadow_first_sprite_offset,R3,0,OUT,R1,&oldscb,R2,&oldsptr,R3,&oldsa,
        END))!=NULL)
         ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL__);

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   #ifdef LOW_MEM
     scale = 0;
   #else
         if ((scale = malloc(16)) == NULL)
              ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",0,"Insufficient Memory.",
                           FATAL__);

         /* Scale factors.  Refer PRM p. 1-752.  Note that the scale factors are in    */
         /* pixels, not in OS coordinates.                                             */

         *scale = xres;
         *(scale + 1) = yres;
         *(scale + 2) = original_JPEG_pixel_width;
         *(scale + 3) = original_JPEG_pixel_height;
   #endif

   /* Plot the JPEG onto the shadow sprite.                                            */
   if ((err = swi(JPEG_PlotFileScaled,R0,jpegfile,R1,0,R2,0,R3,scale,R4,0,END))
        !=NULL)
          ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL__);

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Turn output to the shadow sprite off.                                            */
   if ((err = swi(OS_SpriteOp,R0,256+60,R1,oldscb,R2,oldsptr,R3,oldsa,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"JPEGOverlay()",err->errnum,err->errmess,FATAL__);

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   #ifdef LOW_MEM
     free(scale);
   #endif

}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* n.b. tested this with a 300 by 200 original JPEG image.  Got successfully scaled
up to full screen size in mode 50. */

static void ShowScreenDisplay(int dma_id)
{
 extern char *shadow_screen_base;
 extern int shadow_first_sprite_offset;
 int *scale = 0;
 int vdublk[2];
 int linelen;
 int scrstart;
 _kernel_oserror *err = NULL;
 #define STBFilter_FilterArea 0x84000

   #ifdef FN_TRACE__
     puts("ShowScreenDisplay()");
   #endif

   #ifdef LOW_MEM
       if ((scale = malloc(16)) == NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",0,"Insufficient Memory.",
            FATAL__);
   #endif

   /* Anti-twitter preparation.                                                        */

   vdublk[0] = 148;
   vdublk[1] = -1;
   if ((err = swi(OS_ReadVduVariables,R0,vdublk,R1,vdublk,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL__);
   scrstart = vdublk[0];
   if ((err = swi(OS_ReadModeVariable,R0,-1,R1,6,OUT,R2,&linelen,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
                      FATAL__);


   /* Scale factors.  Refer PRM p. 1-752.  Note that the scale factors are in pixels,  */
   /* not in OS coordinates.                                                           */

   #ifdef LOW_MEM
       *scale = xres;
       *(scale + 1) = yres;
       *(scale + 2) = original_JPEG_pixel_width;
       *(scale + 3) = original_JPEG_pixel_height;
   #endif

   /* Apply anti-twitter if LOW_MEM is not defined.  If LOW_MEM is defined, unless the  */
   /* original JPEG has the same dimensions as the screen, the image won't be of screen */
   /* size.  Anti-twitter should only be applied once the image is screen size.         */
   /* Hence if LOW_MEM is defined, anti-twitter is applied to screen memory later on    */
   /* *after* the image has been scaled up on the screen.                               */

   #ifndef LOW_MEM

       #ifdef NEW_TWITTER

         #error NEW_TWITTER without LOW_MEM doesn't work yet

          /* Anti-twitter the shadow sprite in place.
           * shadow_first_sprite_offset holds the address of the sprite's control block.
           * The offset from the control block to the sprite image is held in the word
           * at byte 32 of the control block.
           */
          if ((err = swi(STBFilter_FilterArea,
                         R0,shadow_first_sprite_offset +
                         *(((int *) shadow_first_sprite_offset)+8),
                         R1,shadow_first_sprite_offset +
                         *(((int *) shadow_first_sprite_offset)+8),
                         R2,yres, R3,xres, R4,xres, R5,xres, R6,4, END))!=NULL)
               ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,
               err->errmess,WARNING__);

          #ifdef DEVELOPMENT__
            printf("area:%p, sprite:%p, image:%p, xres:%x, yres:%x\n",
            (int*) shadow_screen_base, (int*)shadow_first_sprite_offset,
            (int*) (shadow_first_sprite_offset +
            *(((int *) shadow_first_sprite_offset)+8)), xres, yres);
          #endif

       #endif

       #ifdef OLD_TWITTER
       if ((err = swi(STBFilter_FilterArea,
                      R0,shadow_first_sprite_offset +
                      *(((int *) shadow_first_sprite_offset)+8),
                      R1,xres*2, R2,xres, R3,yres, R4,0, R5,0,R6,xres,R7,yres,END))
                      != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
            WARNING__);

          #ifdef DEVELOPMENT__
            printf("area:%p, sprite:%p, image:%p, xres:%x, yres:%x\n",
            (int*) shadow_screen_base, (int*)shadow_first_sprite_offset,
            (int*) (shadow_first_sprite_offset +
            *(((int *) shadow_first_sprite_offset)+8)), xres, yres);
          #endif

       #endif

   #endif


   if ((err = swi(OS_SpriteOp,R0,512+52,R1,shadow_screen_base+16,R2,
        shadow_first_sprite_offset,R3,0,R4,0,R5,0,R6,scale,R7,0,END))!=NULL)
          ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
          FATAL__);

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif


   /* Anti-twitter.  If LOW_MEM is defined, anti-twitter must be applied after         */
   /* plotting to the screen (because before that the image is not the right size).    */
   /* If LOW_MEM is not defined, anti-twitter will have been applied earlier on prior  */
   /* to the screen plot.                                                              */

   #ifdef LOW_MEM

     #ifdef OLD_TWITTER
     if ((err = swi(STBFilter_FilterArea,R0,scrstart,R1,linelen,R2,xres,R3,yres,R4,0,R5,
          0,R6,xres,R7,yres,END)) != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
            WARNING__);
     #endif

     #ifdef NEW_TWITTER
       #error NEW_TWITTER with LOW_MEM doesn't work yet
     if ((err = swi(STBFilter_FilterArea,R0,scrstart,R1,scrstart,R2,yres,R3,linelen,R4,
          linelen,R5,xres,R6,4,END)) != NULL)
            ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
            WARNING__);
     #endif

   #endif

   #ifdef MEMORY_TRACE__
     ShowMem(__FILE__,__LINE__);
   #endif

   /* Remove the dynamic memory area which was used for holding the shadow sprite.     */
   if ((err = swi(OS_DynamicArea,R0,1,R1,dma_id,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ShowScreenDisplay()",err->errnum,err->errmess,
        FATAL__);

   #ifdef LOW_MEM
      free(scale);
   #endif

}


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern void KeyDefinitions(char *quit,char *empty)
{

   #ifdef FN_TRACE__
     puts("KeyDefinitions()");
   #endif

   *quit = 'Q';
   *empty = '\0';
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
extern int ExploreDisc(int *first_track,int *last_track,int *total_tracks)
{
 char *cd_wksp = NULL;
 int track;
 int start_time;
 int end_time;
 int last_end_time;
 int table_index = 0;
 int total_secs = 0;
 int lba;
 extern int *phys_tracks;
 extern int *start_times;
 extern int *end_times;
 extern char *cd_blk;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("ExploreDisc()");
   #endif

   if ((cd_wksp = malloc(256+100))==NULL)
        ErrorHandler(__FILE__,__LINE__,"ExploreDisc()",0,"Insufficient Memory.",FATAL__);

   if ((err = swi(CD_EnquireTrack,R0,0,R1,cd_wksp,R7,cd_blk,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ExploreDisc()",err->errnum,err->errmess,FATAL__);

   *first_track = *cd_wksp;
   *last_track = *(cd_wksp+1);

   free(cd_wksp);

   if (phys_tracks == NULL)
       if ((phys_tracks = malloc(((*last_track-*first_track+1)*4)+100))==NULL)
            ErrorHandler(__FILE__,__LINE__,"ExploreDisc()",0,"Insufficient Memory.",
            FATAL__);

   if (start_times == NULL)
       if ((start_times = malloc(((*last_track-*first_track+1)*4)+100))==NULL)
            ErrorHandler(__FILE__,__LINE__,"ExploreDisc()",0,"Insufficient Memory.",
            FATAL__);

   if (end_times == NULL)
       if ((end_times = malloc(((*last_track-*first_track+1)*4)+100))==NULL)
            ErrorHandler(__FILE__,__LINE__,"ExploreDisc()",0,"Insufficient Memory.",
            FATAL__);

   last_end_time = GetLastTrackEndTime(RED_BOOK_ADDRESSING__);

   for (track = *first_track; track <= *last_track; track++)
   {
        if (AudioData(track) != -1)
        {
            lba = GetLogicalBlockAddress(track);
            start_time = ConvertFrameAddressToTimeOffset(LOGICAL_BLOCK_ADDRESSING__,lba);
            if (track != *last_track)
            {
                lba = GetLogicalBlockAddress(track+1);
                end_time = ConvertFrameAddressToTimeOffset(LOGICAL_BLOCK_ADDRESSING__,
                           lba);
            }
            else
            {
                end_time = last_end_time;
            }

            table_index++;
            phys_tracks[table_index] = track;
            start_times[table_index] = start_time;
            end_times[table_index] = end_time;
            total_secs += secs(end_time) - secs(start_time);
        }
   }
   *total_tracks = table_index;

   return total_secs;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int GetLastTrackEndTime(int addressing_mode)
{
 int *cd_wksp = NULL;
 int last_track_end_time;
 extern char *cd_blk;
 _kernel_oserror *err = NULL;
 int datamode = -1;
 #define AUDIO__ 0

   #ifdef FN_TRACE__
     puts("GetLastTrackEndTime()");
   #endif

   if ((cd_wksp = malloc(8))==NULL)
        ErrorHandler(__FILE__,__LINE__,"GetLastTrackEndTime()",0,"Insufficient Memory.",
        FATAL__);

   if ((err = swi(CD_DiscUsed,R0,addressing_mode,R1,cd_wksp,R7,cd_blk,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"GetLastTrackEndTime()",err->errnum,err->errmess,
        FATAL__);

   last_track_end_time = (*cd_wksp) & 0xFFFFFF;      /* mm:ss:ff */

   /* Sometimes the end time returned is some frames out.  If this happens, fast      */
   /* forward may not work because the end time specified is invalid.  Readjust the   */
   /* end time if necessary.                                                          */

   while (datamode != AUDIO__)
   {
      if ((err = swi(CD_EnquireDataMode,R0,RED_BOOK_ADDRESSING__,R1,last_track_end_time,
           R7,cd_blk,OUT,R0,&datamode,END)) != NULL)
            ErrorHandler(__FILE__,__LINE__,"GetLastTrackEndTime()",err->errnum,
            err->errmess,WARNING__);

      last_track_end_time--;

      #ifdef DEVELOPMENT__
        printf("Adjusting last track end time: %d\n",last_track_end_time);
      #endif
   }

   free(cd_wksp);

   return last_track_end_time;

 #undef AUDIO__
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int GetLogicalBlockAddress(int track)
{
 int *cd_wksp = NULL;
 int lba;
 extern char *cd_blk;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("GetLogicalBlockAddress()");
   #endif

   if ((cd_wksp = malloc(5))==NULL)
        ErrorHandler(__FILE__,__LINE__,"GetLogicalBlockAddress()",0,
        "Insufficient Memory.",FATAL__);

   if ((err = swi(CD_EnquireTrack,R0,track,R1,cd_wksp,R7,cd_blk,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"GetLogicalBlockAddress()",err->errnum,
        err->errmess,FATAL__);

   lba = *cd_wksp;

   free(cd_wksp);


   return lba;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int ConvertFrameAddressToTimeOffset(int addressing_mode,int address)
{
 int rba;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("ConvertFrameAddressToTimeOffset()");
   #endif

   if ((err = swi(CD_ConvertToMSF,R0,addressing_mode,R1,address,OUT,R1,&rba,END))!=NULL)
        ErrorHandler(__FILE__,__LINE__,"ConvertFrameAddressToTimeOffset()",err->errnum,
        err->errmess,FATAL__);

   return rba;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static char AudioData(int track)
{
 char *cd_wksp = NULL;
 char result = FALSE__;
 extern char *cd_blk;
 _kernel_oserror *err = NULL;

   #ifdef FN_TRACE__
     puts("AudioData()");
   #endif

   if ((cd_wksp = malloc(5)) == NULL)
   {
        ErrorHandler(__FILE__,__LINE__,"AudioData()",0,
        "Insufficient Memory to check if data is audio: 256 additional bytes required.",
        WARNING__);
        result = FALSE__;
   }
   else
   {
        if ((err = swi(CD_EnquireTrack,R0,track,R1,cd_wksp,R7,cd_blk,END))!=NULL)
             ErrorHandler(__FILE__,__LINE__,"AudioData()",err->errnum,err->errmess,
             WARNING__);
        else
             if (( (*(cd_wksp+4) & 1)) == 0)
                 result = TRUE__;
             else
                 result = FALSE__;

        free(cd_wksp);

   }
   return result;
}

/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
static int secs(int code)
{

   #ifdef FN_TRACE__
     puts("secs()");
   #endif

   return ((code >> 16) & 0xFF) * 60 + ((code >> 8) & 0xFF);
}


/*=====================================================================================*/
/*                                                                                     */
/*  FUNCTION:  */
/*  BEHAVIOUR: */
/*                                                                                     */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

extern void PrepareCounterSprite(void)
{
 int counter_shadowspritemode;
 int *ptr = NULL;
 _kernel_oserror *err = NULL;
 extern char *counter_display_shadowsprite;
 int size;

   #ifdef FN_TRACE__
     puts("PrepareCounterSprite()");
   #endif

   if ((err = swi(OS_ScreenMode,R0,1,OUT,R1,&counter_shadowspritemode,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareCounterSprite()",err->errnum,err->errmess,
        FATAL__);

   counter_display_shadowsprite = malloc((100 * 30 * 2) + 44 + 16);
   if (counter_display_shadowsprite == NULL)
       ErrorHandler(__FILE__,__LINE__,"PrepareCounterSprite()",0,"Insufficient Memory.",
       FATAL__);

   size = (100 * 30 * 2) + 44 + 16;
   ptr = (int *)counter_display_shadowsprite;
   *(ptr) = size;
   *(ptr + 2) = 16;

   if ((err = swi(OS_SpriteOp,R0,512+9,R1,counter_display_shadowsprite,END)) != NULL)
        ErrorHandler(__FILE__,__LINE__,"PrepareCounterSprite()",err->errnum,err->errmess,
        FATAL__);

   if ((err = swi(OS_SpriteOp,R0,256+15,R1,counter_display_shadowsprite,R2,"counter",R3,
        0,R4,100,R5,24,R6,counter_shadowspritemode,END)) != NULL)
         ErrorHandler(__FILE__,__LINE__,"PrepareCounterSprite()",err->errnum,err->errmess,
         FATAL__);

}

