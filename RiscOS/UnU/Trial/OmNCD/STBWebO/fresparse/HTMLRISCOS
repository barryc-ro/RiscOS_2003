/* -*-c-*- */

/* 23-02-96 DAF         Changes for tables (23-1-96 DRAFT). */
/*                      &rh->stream changed to rh->curstream. */
/* 04-03-96 DAF         Checked using right function names for */
/*                      tables. Call routines on end of some */
/*                      groups. */
/* 26-03-96 DAF         Added new_aref_item() calls for table */
/*                      elements for ID=BLAH attribute. */
/*                      Word splitting in text_item_push_word() */
/*                      when ALIGN=CHAR active and present. */

THIS FILE IS OBSOLETE - USE htmlparser.c etc INSTEAD

/* Generate my RISC OS internal format from an HTML stream */

#include <string.h>
#include <ctype.h>
#include <assert.h>

#if 1
#if 0
#include "wimp.h"
#else
typedef struct {
    int x0,y0,x1,y1;
} wimp_box;
#define __wimp_h
#endif
#endif

#include "memwatch.h"

#include "HTMLRISCOS.h"
#include "HTMLPDTD.h"
#include "HTStream.h"
#include "SGML.h"

#include "rid.h"
#include "charsets.h"
#include "util.h"
#include "webfonts.h"
#include "url.h"

#include "filetypes.h"
#include "parsers.h"
#include "images.h"

#include "tables.h"
#include "myassert.h"

#include "indent.h"

#ifndef PARSE_DEBUG
#define PARSE_DEBUG 0
#endif


static BOOL include_frames = FALSE;

static void HTRISCOS_put_string (HTStructured * me, const char* s);
static void text_item_push_word(HTStructured * me, int flags);


void translate_escaped_text(char *src, char *dest, int len)
{
    int c;

    len--;

    while (len && (c = *src++) != 0)
    {
	if (c == '%')
	{
	    if (isxdigit(src[0]) && isxdigit(src[1]))
	    {
		char *base16 = "0123456789abcdef";
		int cc;

		cc = tolower(c);

		c = ( (strchr(base16, src[0]) - base16) << 4) + (strchr(base16, src[1]) - base16);

		src += 2;
	    }
	}
	else if (c == '&')
	{
	    char **entities;
	    char *p;
	    int low, hi;
	    int len;

	    entities = (char **) HTMLP_dtd.entity_names;

	    p = strchr(src, ';');
	    if (p)
	    {
		len = p - src;

		low = 0;
		hi = HTML_ENTITIES;

		while (low < hi)
		{
		    int split = (hi + low) >> 1;
		    int way;

		    way = strncmp(entities[split], src, len);
		    if (way == 0)
		    {
			c = ISO_Latin1[split][0];
			src += len; /* Skip the entity */
			src ++;	/* skip the semi-colon */
			break;
		    }
		    else if (way > 0)
		    {
			hi = split;
		    }
		    else
		    {
			low = split + 1;
		    }
		}
	    }
	}

	*dest++ = c;
	len--;
    }
    *dest = 0;
}

static void htmlriscos_colour(char *col, int *word)
{
    int w1, w2;

    if (col[0] == '#')
	col++;

    w1 = (int) strtol(col, NULL, 16);

    w2 =((w1 & 0xff0000) >> 8) |
	((w1 & 0xff00) << 8) |
	((w1 & 0xff) << 24);

    *word = w2;
}

static const char *skip_space(const char *s)
{
    if (s) while (*s && isspace(*s))
	s++;
    return s;
}

static void new_aref_item(HTStructured * me, const char *href, const char *name, const char *rel, const char *target)
{
    rid_aref_item *new;

    new = mm_calloc(1, sizeof(*new));

#if PARSE_DEBUG
    fprintf(stderr, "New A item.  href = '%s', name = '%s', rel = '%s'\n",
	    href ? href : "<none>",
	    name ? name : "<none>",
	    rel ? rel : "<none>" );
#endif

    if (href)
	new->href = strdup(skip_space(href));
    if (name)
	new->name = strdup(skip_space(name));
    if (rel)
	new->rel = strdup(skip_space(rel));
    if (target)
	new->target = strdup(skip_space(target));

    /* If we are trying to nest (illegally) and there is no body then mark the previous item */
    if (me->aref && me->aref->first == 0)
    {
	me->aref->first = me->rh->curstream->text_last;
    }

    rid_aref_item_connect(me->rh, new);
    me->aref = new;
}

static void new_form_item(HTStructured * me, const char *action, const char *method, const char *target)
{
    rid_form_item *new;

    new = mm_calloc(1, sizeof(*new));

#if PARSE_DEBUG
    fprintf(stderr, "New FORM item.  Method='%s', action='%s'\n",
	    method ? method : "<none>",
	    action ? action : "<none>" );
#endif

    new->action = strdup(action);

    new->method = (strcasecomp(method, "POST") == 0) ? rid_fm_POST : rid_fm_GET;
    if (target)
        new->target = strdup(skip_space(target));

    rid_form_item_connect(me->rh, new);
    me->form = new;
}

static void new_option_item(HTStructured * me, char *value, rid_input_flags flags)
{
    rid_option_item *new;

    if (me->form == NULL || me->form->selects == NULL)
	return;

    new = mm_calloc(1, sizeof(*new));

    new->flags = flags;
    if (value)
	new->value = strdup(value);

#if PARSE_DEBUG
    fprintf(stderr, "New OPTION item at %p, value='%s'(%p)\n", new, new->value ? new->value : "<None>", new->value);
#endif

    rid_option_item_connect(me->form->last_select, new);
}

static int frame_count_elements(const char *s)
{
    const char *ss;
    int n;

    n = 1;
    for (ss = s; *ss; ss++)
        if (*ss == ',')
            n++;

    return n;
}

static void parse_coords_list(const char *sin, int *vals, int n)
{
    char *s, *ss;
    s = strdup(sin);
    ss = strtok(s, ",");
    do
        *vals++ = atoi(ss);
    while ((ss = strtok(NULL, ",")) != 0);
    mm_free(s);
}

static int frame_parse_units(const char *sin, rid_stdunits **list_out, rid_frame_unit_totals *total)
{
    int n;
    const char *ss;
    char *s;
    rid_stdunits *up;

    // count commas
    n = frame_count_elements(sin);

    // there is no point in storing information about 1 row/col
    if (n == 1)
        return 1;

    // scan and decode the string
    up = *list_out = mm_calloc(sizeof(rid_stdunits), n);
    s = strdup(sin);
    ss = strtok(s, ",");

    // init the totals
    total->mult = total->pcent = total->px = 0;

    do
    {
        const char *e;
        ss = skip_space(ss);
        up->count = (float)strtod(ss, (char **)&e);
        e = skip_space(e);
        switch (*e)
        {
            case '*':
                up->type = rid_stdunit_MULT;
                if (up->count == 0)
                    up->count = 1;
                total->mult += up->count;
                break;
            case '%':
                up->type = rid_stdunit_PCENT;
                total->pcent += up->count;
                break;
            default:
                up->type = rid_stdunit_PX;
                total->px += up->count;
                break;
        }
        up++;
    }
    while ((ss = strtok(NULL, ",")) != 0);

    mm_free(s);

    return n;
}

static void new_frameset_item(HTStructured *me, const char *cols, const char *rows)
{
    rid_frame *container;
    rid_frameset_item *frameset;

#if 1 // PARSE_DEBUG
    fprintf(stderr, "New FRAMESET item. cols '%s' rows '%s'\n",
            cols ? cols : "<none>",
            rows ? rows : "<none>");
#endif
    if (!include_frames)
        return;

    // we can only have one top level frameset
    if (me->frameset == 0 && me->rh->frames != NULL)
        return;

    container = mm_calloc(sizeof(*container), 1);
    container->tag = rid_frame_tag_FRAMESET;

    frameset = &container->data.frameset;

    frameset->ncols = cols ? frame_parse_units(cols, &frameset->widths, &frameset->width_totals) : 1;
    frameset->nrows = rows ? frame_parse_units(rows, &frameset->heights, &frameset->height_totals) : 1;

    // link into the list of framesets
    if (me->frameset == 0)
        me->rh->frames = container;
    else
        rid_frame_connect(me->frameset_stack[me->frameset-1], container);

    // update total number of frames
    me->rh->nframes += frameset->ncols * frameset->nrows;

    // record current frameset
    me->frameset_stack[me->frameset++] = container;
}

static void new_frame_item(HTStructured *me, int mwidth, int mheight, const char *name, BOOL noresize, const char *scrolling, const char *src)
{
    rid_frame *container;
    rid_frame_item *frame;

#if 1 // PARSE_DEBUG
    fprintf(stderr, "New FRAME item. margin %d,%d name '%s' noresize %d scrolling '%s' src '%s'\n",
            mwidth, mheight,
            name ? name : "<none>",
            noresize,
            scrolling ? scrolling : "<none>",
            src ? src : "<none>");
#endif

    if (!include_frames)
        return;

    // if no framesets on the stack then ignore this frame
    if (!me->frameset)
        return;

    container = mm_calloc(sizeof(*container), 1);
    container->tag = rid_frame_tag_FRAME;

    frame = &container->data.frame;

    frame->marginwidth = mwidth < 0 ? 0 : mwidth;
    frame->marginheight = mheight < 0 ? 0 : mheight;
    frame->name = strdup(name);
    frame->noresize = noresize;

    frame->scrolling = rid_scrolling_AUTO;
    if (scrolling)
    {
        if (strcasecomp(scrolling, "yes") == 0)
            frame->scrolling = rid_scrolling_YES;
        else if (strcasecomp(scrolling, "no") == 0)
            frame->scrolling = rid_scrolling_NO;
    }
    frame->src = strdup(src);

    // link into the list of frames
    rid_frame_connect(me->frameset_stack[me->frameset-1], container);
}

static void new_map_item(HTStructured *me, const char *name)
{
    rid_map_item *map;

#if 1 // PARSE_DEBUG
    fprintf(stderr, "New MAP item. '%s'\n",
            name ? name : "<none>");
#endif
    map = mm_calloc(sizeof(*map), 1);

    map->name = strdup(name);

    // link into the list of maps
    map->next = me->rh->map_list;
    me->rh->map_list = map;

    // record current map
    me->map = map;
}

static void new_area_item(HTStructured *me, const char *shape, const char *coords, const char *href, const char *target, const char *alt)
{
    rid_area_item *area;

#if 1 // PARSE_DEBUG
    fprintf(stderr, "New AREA item. shape '%s' coords '%s' href '%s' target '%s' alt '%s'\n",
            shape ? shape : "<none>",
            coords ? coords : "<none>",
            href ? href : "<none>",
            target ? target : "<none>",
            alt ? alt: "<none>");
#endif
    // ignore if no map is open or if no coords
    if (me->map == NULL || coords == NULL)
        return;

    area = mm_calloc(sizeof(*area), 1);

    // microsoft define the paramters as having a four character abbreviation!
    if (shape == NULL || strncasecomp(shape, "RECT", 4) == 0)
    {
        area->type = rid_area_RECT;
        parse_coords_list(coords, &area->coords.rect.x0, 4);
    }
    else if (strncasecomp(shape, "CIRC", 4) == 0)
    {
        area->type = rid_area_CIRCLE;
        parse_coords_list(coords, &area->coords.circle.x, 3);
    }
    else if (strncasecomp(shape, "POLY", 4) == 0)
    {
        area->type = rid_area_POLYGON;
        area->coords.polygon.npoints = frame_count_elements(coords)/2;
        area->coords.polygon.point = mm_calloc(sizeof(intxy), area->coords.polygon.npoints+1);

        parse_coords_list(coords, &area->coords.polygon.point->x, area->coords.polygon.npoints);

        // check path is closed and close it if neceesary (hence +1 on malloc above
        {
            intxy *first = &area->coords.polygon.point[0];
            intxy *last = &area->coords.polygon.point[area->coords.polygon.npoints-1];
            if (first->x != last->x || first->y != last->y)
            {
                last[1] = *first;
                area->coords.polygon.npoints++;
            }
        }
    }

    if (href)
        area->href = strdup(skip_space(href));
    if (alt)
        area->alt = strdup(alt);
    if (target)
        area->target = strdup(target);

    // link into the list of areas
    rid_area_item_connect(me->map, area);
}

static void text_item_push_select(HTStructured * me, char *name, char *size, int multiple)
{
    rid_text_item_select *new;
    rid_text_item *nb;
    rid_select_item *sel;

    if (me->form == NULL)
	return;

    new = mm_calloc(1, sizeof(*new));
    nb = &(new->base);
    sel = mm_calloc(1, sizeof(*sel));
    new->select = sel;
    sel->ti = nb;

    sel->name = strdup(name);
    if (size == NULL)
	sel->size = -1;
    else
	sel->size = atoi(size);

    if (multiple)
	sel->flags |= rid_sf_MULTIPLE;

    rid_select_item_connect(me->form, sel);

    nb->tag = rid_tag_SELECT;
    nb->aref = me->aref;	/* Current anchor, or NULL */
    if (me->aref && me->aref->first == NULL)
	me->aref->first = nb;
    nb->st = me->sp[0].style;

    rid_text_item_connect(me->rh->curstream, nb);
}

static void text_item_push_textarea(HTStructured * me, char *name, char *rows, char *cols)
{
    rid_text_item_textarea *new;
    rid_text_item *nb;
    rid_textarea_item *ta;

    if (me->form == NULL)
	return;

    new = mm_calloc(1, sizeof(*new));
    nb = &(new->base);
    ta = mm_calloc(1, sizeof(*ta));
    new->area = ta;
    ta->display = nb;

    ta->name = strdup(name);

    if (rows)
	ta->rows = atoi(rows);
    if (cols)
	ta->cols = atoi(cols);

    if (ta->rows == 0)
	ta->rows = 1;

    if (ta->cols == 0)
	ta->cols = 20;

    rid_textarea_item_connect(me->form, ta);

    nb->tag = rid_tag_TEXTAREA;
    nb->aref = me->aref;	/* Current anchor, or NULL */
    if (me->aref && me->aref->first == NULL)
	me->aref->first = nb;
    nb->st = me->sp[0].style;

    rid_text_item_connect(me->rh->curstream, nb);
}

static void text_item_push_image(HTStructured * me, int flags, const char *src, const char *alt,
    int align, const char *bdr, const char *ww, const char *hh, const char *usemap, int ismap)
{
    rid_text_item_image *new;
    rid_text_item *nb;

    new = mm_calloc(1, sizeof(*new));
    nb = &(new->base);

#if PARSE_DEBUG
    fprintf(stderr, "New image item. src = '%s', alt = '%s', align = '%s' usemap = '%s'%s.\n",
	    src ? src : "<None>",
	    alt ? alt : "<None>",
	    align ? align : "<None>",
	    usemap ? usemap : "<None>",
	    ismap ? ", is a map" : "" );
#endif

    new->src = strdup(skip_space(src));
    new->alt = strdup(alt);
    if (usemap)
        new->usemap = strdup(skip_space(usemap));

    new->flags |= ismap ? rid_image_flag_ISMAP : 0;
    new->bwidth = bdr ? atoi(bdr) : 1;

    if (ww)
	new->ww = atoi(ww);
    if (hh)
	new->hh = atoi(hh);

    if (align)
    {
	if (strcasecomp(align, "top") == 0)
	    new->flags |= rid_image_flag_ATOP;
	else if (strcasecomp(align, "texttop") == 0)
	    new->flags |= (rid_image_flag_ATOP | rid_image_flag_ABSALIGN);
	else if (strcasecomp(align, "bottom") == 0)
	    new->flags |= rid_image_flag_ABOT;
	else if (strcasecomp(align, "baseline") == 0)
	    new->flags |= rid_image_flag_ABOT;
	else if (strcasecomp(align, "absbottom") == 0)
	    new->flags |= (rid_image_flag_ABOT | rid_image_flag_ABSALIGN);
	else if (strcasecomp(align, "absmiddle") == 0)
	    new->flags |= rid_image_flag_ABSALIGN;
	/* The default is middle so we don't really nbeed to test for it */
    }

    nb->tag = rid_tag_IMAGE;
    if (flags & FORCE_BREAK)
	nb->flag |= rid_flag_LINE_BREAK;
    if (me->sp[0].state & STK_STATE_LINES) /* We need to be able to have both flags set */
	nb->flag |= rid_flag_NO_BREAK;
    nb->aref = me->aref;	/* Current anchor, or NULL */
    if (me->aref && me->aref->first == NULL)
	me->aref->first = nb;
    nb->st = me->sp[0].style;

    rid_text_item_connect(me->rh->curstream, nb);
}

static void text_item_push_input(HTStructured * me, int flags, const BOOL *present, const char **value)
{
    rid_text_item_input *new;
    rid_text_item *nb = NULL;
    rid_input_item *in;
    rid_input_tag tag = (rid_input_tag) -1;
    char c;

    c = present[HTML_INPUT_TYPE] ? value[HTML_INPUT_TYPE][0] : 0;
    if (c == 'c' || c == 'C')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "CHECKBOX") == 0)
	    tag = rid_it_CHECK;
    }
    else if (c == 't' || c == 'T')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "TEXT") == 0)
	    tag = rid_it_TEXT;
    }
    else if (c == 'h' || c == 'H')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "HIDDEN") == 0)
	    tag = rid_it_HIDDEN;
    }
    else if (c == 'i' || c == 'I')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "IMAGE") == 0)
	    tag = rid_it_IMAGE;
    }
    else if (c == 'r' || c == 'R')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "RADIO") == 0)
	    tag = rid_it_RADIO;
	else if (strcasecomp(value[HTML_INPUT_TYPE], "RESET") == 0)
	    tag = rid_it_RESET;
    }
    else if (c == 'p' || c == 'P')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "PASSWORD") == 0)
	    tag = rid_it_PASSWD;
    }
    else if (c == 's' || c == 'S')
    {
	if (strcasecomp(value[HTML_INPUT_TYPE], "SUBMIT") == 0)
	    tag = rid_it_SUBMIT;
    }

    if (tag == -1)
	tag = rid_it_TEXT;

    in = mm_calloc(1, sizeof(*in));

    if (tag != rid_it_HIDDEN)
    {
	new = mm_calloc(1, sizeof(*new));
	new->input = in;
	nb = &(new->base);
	in->display = nb;
    }
    else
	new = NULL;

    in->tag = tag;

    if (present[HTML_INPUT_CHECKED])
	in->flags |= rid_if_CHECKED;
    if (present[HTML_INPUT_DISABLED])
	in->flags |= rid_if_DISABLED;

    if (present[HTML_INPUT_NAME])
	in->name = strdup(value[HTML_INPUT_NAME]);
    if (present[HTML_INPUT_VALUE])
	in->value = strdup(value[HTML_INPUT_VALUE]);
    if (present[HTML_INPUT_SRC])
	in->src = strdup(value[HTML_INPUT_SRC]);

    in->xsize = in->ysize = -1;
    if (present[HTML_INPUT_SIZE] && value[HTML_INPUT_SIZE])
    {
	sscanf(value[HTML_INPUT_SIZE], "%d,%d", &in->xsize, &in->ysize);
    }

    if (in->xsize == -1)
	in->xsize = 20;

    if (present[HTML_INPUT_MAX] && value[HTML_INPUT_MAX])
	in->max_len = atoi(value[HTML_INPUT_MAX]);

    if (in->max_len == 0)
	in->max_len = 256;

    if (me->form)
	rid_input_item_connect(me->form, in);

    switch (tag)
    {
    case rid_it_CHECK:
    case rid_it_RADIO:
	in->data.tick = ((in->flags & rid_if_CHECKED) != 0);
	break;
    case rid_it_TEXT:
    case rid_it_PASSWD:
	in->data.str = mm_malloc(in->max_len);
	if (in->value)
	    translate_escaped_text(in->value, in->data.str, in->max_len);
	else
	    in->data.str[0] = 0;
	break;
    case rid_it_IMAGE:
	if (present[HTML_INPUT_ALIGN])
	{
	    if (strcasecomp(value[HTML_INPUT_ALIGN], "top") == 0)
		in->data.image.flags |= rid_image_flag_ATOP;
	    else if (strcasecomp(value[HTML_INPUT_ALIGN], "bottom") == 0)
		in->data.image.flags |= rid_image_flag_ABOT;
	}
	break;
    }

#if PARSE_DEBUG
    fprintf(stderr, "New input item, type=%d, flags=%d, xsize=%d, ysize=%d, max_len=%d, name='%s', value='%s', src='%s', \n",
	    in->tag, in->flags, in->xsize, in->ysize, in->max_len,
	    in->name ? in->name : "<none>",
	    in->value ? in->value : "<none>",
	    in->src ? in->src : "<none>" );
#endif

    if (nb)
    {
	nb->tag = rid_tag_INPUT;
	if (flags & FORCE_BREAK)
	    nb->flag |= rid_flag_LINE_BREAK;
	if (me->sp[0].state & STK_STATE_LINES) /* We need to be able to have both flags set */
	    nb->flag |= rid_flag_NO_BREAK;
	nb->aref = me->aref;	/* Current anchor, or NULL */
	if (me->aref && me->aref->first == NULL)
	    me->aref->first = nb;
	nb->st = me->sp[0].style;

	rid_text_item_connect(me->rh->curstream, nb);
    }
}

static void push_fake_search_form(HTStructured * me, char *prompt)
{
    BOOL present[MAX_ATTRIBUTES];	/* Flags: attribute is present? */
    char * value[MAX_ATTRIBUTES];	/* malloc'd strings or NULL if none */
    rid_form_item *oldform;

    memset(present, 0, sizeof(present));
    memset(value, 0, sizeof(value));

    oldform = me->form;

    new_form_item(me, "", "GET", NULL);
    if (prompt)
	HTRISCOS_put_string(me, prompt);
    else
	HTRISCOS_put_string(me, "This document is an index.  Enter keywords here: ");

    text_item_push_word(me, 0);

    present[HTML_INPUT_TYPE] = TRUE;
    value[HTML_INPUT_TYPE] = "TEXT";

    text_item_push_input(me, 0, (const BOOL *) present, (const char **) value);

    value[HTML_INPUT_TYPE] = "SUBMIT";
    present[HTML_INPUT_VALUE] = 1;
    value[HTML_INPUT_VALUE] = "Search";

    text_item_push_input(me, 0, (const BOOL *) present, (const char **) value);

    me->form = oldform;
}

static void text_item_push_break(HTStructured * me, int line)
{
    rid_text_item *nb;

    nb = mm_calloc(1, sizeof(*nb));

#if PARSE_DEBUG
    fprintf(stderr, "Paragraph break%s.\n", line ? " with line" : "");
#endif

    nb->tag = line ? rid_tag_HLINE : rid_tag_PBREAK;
    nb->flag |= rid_flag_LINE_BREAK;
    nb->aref = me->aref;	/* Current anchor, or NULL */
    if (me->aref && me->aref->first == NULL)
	me->aref->first = nb;
    nb->st = me->sp[0].style;

    rid_text_item_connect(me->rh->curstream, nb);
}

static void text_item_push_bullet(HTStructured * me)
{
    rid_text_item_bullet *nbb;
    rid_text_item *nb;

    nbb = mm_calloc(1, sizeof(*nbb));
    nb = &(nbb->base);

#if PARSE_DEBUG
    fprintf(stderr, "Bullet mark, number = %d\n", me->sp[0].list_no);
#endif

    nb->tag = rid_tag_BULLET;
    nb->aref = me->aref;	/* Current anchor, or NULL */
    if (me->aref && me->aref->first == NULL)
	me->aref->first = nb;
    nb->st = me->sp[0].style;
    nbb->list_no = me->sp[0].list_no;

    rid_text_item_connect(me->rh->curstream, nb);
}


/*

Used to ensure tables have something between them. This is to meet
the requirement that rid_scan() doesn't encounter more than one table
per simple scan to keep the code much simpler.

*/

static void must_have_a_text_item(HTStructured *me)
{
        rid_text_item_text *new;
        rid_text_item *nb;

#if 0
        fprintf(stderr, "Forcing a new text item (eg due to table)\n");
#endif

	new = mm_calloc(1, sizeof(*new));
	nb = &(new->base);

        new->data_off = memzone_alloc(&me->rh->texts, 1);

	if (new->data_off != -1)
	{
	  	flexmem_noshift();
       		me->rh->texts.data[new->data_off] = 0;
	  	flexmem_shift();
	}

        nb->tag = rid_tag_TEXT;
/*        nb->flag |= rid_flag_LINE_BREAK;*/
       	nb->aref = me->aref;	/* Current anchor, or NULL */

#if 0
        /* Not certain should be doing this */
       	if (me->aref && me->aref->first == NULL)
       	    me->aref->first = nb;
#endif

       	nb->st = me->sp[0].style;
      	rid_text_item_connect(me->rh->curstream, nb);
}


/*	Character handling
**	------------------
**
*/
static void HTRISCOS_put_character (HTStructured * me, char c)
{
    int uc = (int)((unsigned char) c);

#if 1
    if (me->sp[0].tag_number == HTML_COMMENT)
	return;

    if (me->noframe)    // discard text if in noframe area
        return;

    if ( uc > 32 )		/* Nasty but very cheap test for white space, needs to be unsigned to work */
    {
	/* We have a non-whitespace character */
	if ((me->sp[0].state & STK_STATE_LINES) == 0 && me->white_count != 0)
	{
	    /* Word breaks and non-whitespace char following some white; need to make a new word */
	    text_item_push_word(me, 0);
	}
	/* Now either line breaks or no white space preceding, so push the character */
	*(me->write_ptr++) = (char) uc;
    }
    else
    {
	/* Have a white space char of some sort */
	/* We only put it in if we are not at the begining of the line or not stripping space or it's not the sort of space we strip */
	if (me->write_ptr != me->buf || !me->strip_space || ( (me->sp[0].state & STK_STATE_PRE) && (uc != '\n')) )
	{
	    /* Once we have something we stop stripping space */
	    me->strip_space = 0;

	    if ( (me->sp[0].state & STK_STATE_LINES) && (uc == '\n'))
	    {
		text_item_push_word(me, HARD_BREAK);
	    }
	    else if ( (me->sp[0].state & STK_STATE_PRE) && (uc == '\t'))
	    {
		do
		{
		    *(me->write_ptr++) = ' ';
		    me->white_count++;
		} while ( ((me->write_ptr - me->buf) % 8) != 0 );
	    }
	    else if ( (me->write_ptr == me->buf) && (uc == '\r'))
	    {
		/* We ditch carrage returns at the start of lines */
	    }
	    else if ((me->sp[0].state & (STK_STATE_PRE | STK_STATE_LINES)) || STRICT_SPACE)
	    {
		*(me->write_ptr++) = ' ';
		me->white_count++;
	    }
	    else
	    {
		if (me->white_count == 0 || (me->white_count == 1 && me->write_ptr[-2] == '.') )
		{
		    *(me->write_ptr++) = ' ';
		    me->white_count++;
		}
	    }
	}
    }

#else
    switch (me->sp[0].tag_number) {
    case HTML_COMMENT:
	break;			/* Ignore comment chars */

    case HTML_TITLE:		/* This is spacial-cased when the whole string is pushed */
    case HTML_LISTING:				/* Litteral text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
    case HTML_PRE:
    case HTML_TEXTAREA:		/* This is special-cased in the push too */
    case HTML_SELECT:		/* This is special-cased in the push too */
	if ( uc > 32 )		/* Nasty but very cheap test for white space, needs to be unsigned to work */
	{
	    *(me->write_ptr++) = (char) uc;
	}
	else
	{
	    if (me->write_ptr != me->buf || !me->strip_space)
	    {
		if (uc == '\n')
		{
		    /* Push the line break if it is not a blank line or we are not stripping space */
		    text_item_push_word(me, HARD_BREAK);
		}
		else if (uc == '\t')
		{
		    do
		    {
			*(me->write_ptr++) = ' ';
		    } while ( ((me->write_ptr - me->buf) % 8) != 0 );
		}
		else
		{
		    /* All other space is the same and we hold off doing anything about it until we have had it all */
		    *(me->write_ptr++) = ' ';
		}
	    }
	    else
	    {
		if (uc == '\n')
		    me->strip_space = 0;
	    }
	}
	break;

    default:
	if ( uc > 32 )		/* Nasty but very cheap test for white space, needs to be unsigned to work */
	{
	    /* The character is not white space */
	    if (me->white_count != 0)
	    {
		/* Non-whitespace char following some white; need to make a new word */
		text_item_push_word(me, 0);
	    }
	    /* Now no white space preceding, so no need to break */
	    *(me->write_ptr++) = (char) uc;
	}
	else
	{
	    /* We only add the space it we are not at the beging of the line or we are not stripping space */
	    if (me->write_ptr != me->buf || !me->strip_space)
	    {
		/* All space is the same and we hold off doing anything about it until we have had it all */
#if STRICT_SPACE
		*(me->write_ptr++) = ' ';
		me->white_count++;
#else
		if (me->white_count == 0 || (me->white_count == 1 && me->write_ptr[-2] == '.') )
		{
		    *(me->write_ptr++) = ' ';
		    me->white_count++;
		}
#endif
	    }
	}
	break;
    }				/* End of swicth */
#endif
}

/*	String handling
**	---------------
*/
static void HTRISCOS_put_string (HTStructured * me, const char* s)
{
    const char * p;
    for (p=s; *p; p++)
	HTRISCOS_put_character(me, *p);
}


static void HTRISCOS_write (HTStructured * me, const char* s, int l)
{
    const char * p;
    for(p=s; p<s+l; p++)
	HTRISCOS_put_character(me, *p);
}


/*	Start Element
**	-------------
**
**     	No attributes are put to the output		Henrik 07/03-94
**	Does no assumptions of WHAT element is started...
*/
static void HTRISCOS_start_element (
	HTStructured * 	me,
	int		element_number,
	const BOOL*	present,
	const char **	value)
{
    ROStyle	new_style;
    int		new_list;
    int		new_state;

#if PARSE_DEBUG
    fprintf(stderr, "<%s element %d '%s'>\n",
	    me->dtd->tags[element_number].contents != SGML_EMPTY ? "Start" : "Empty",
	    element_number,
	    me->dtd->tags[element_number].name);
#endif

    /* @@@@ This almost certainly wants to be a bit more careful about forcing line breaks */


    /* N.B. Items that produce temporary style changes should update new_style from me->sp[0].def_style */
    new_style = me->sp[0].style;

    new_state = me->sp[0].state;
    new_list  = me->sp[0].list_no;

    if (!me->noframe) switch (element_number)
    {
    case HTML_A:
	text_item_push_word(me, 0);
	/* Make a new aref and fill in its fields */
	new_aref_item(me,
		      present[HTML_A_HREF] ? value[HTML_A_HREF] : 0,		/* Addresss */
		      present[HTML_A_NAME] ? value[HTML_A_NAME] : 0,	/* Tag */
		      present[HTML_A_REL]  ? value[HTML_A_REL] : 0,
		      present[HTML_A_TARGET]  ? value[HTML_A_TARGET] : 0);
	break;

    case HTML_FORM:
	text_item_push_word(me, 0);
	/* Make a new form and fill in its fields */
	new_form_item(me,
		      present[HTML_FORM_ACTION] ? value[HTML_FORM_ACTION] : 0,
		      present[HTML_FORM_METHOD] ? value[HTML_FORM_METHOD] : 0,
		      present[HTML_FORM_TARGET] ? value[HTML_FORM_TARGET] : 0 );
	break;

    case HTML_FRAME:
        new_frame_item(me,
            present[HTML_FRAME_MARGINWIDTH] ? atoi(value[HTML_FRAME_MARGINWIDTH]) : 0,
            present[HTML_FRAME_MARGINHEIGHT] ? atoi(value[HTML_FRAME_MARGINHEIGHT]) : 0,
            present[HTML_FRAME_NAME] ? value[HTML_FRAME_NAME] : 0,
            present[HTML_FRAME_NORESIZE] ? 1 : 0,
            present[HTML_FRAME_SCROLLING] ? value[HTML_FRAME_SCROLLING] : 0,
            present[HTML_FRAME_SRC] ? value[HTML_FRAME_SRC] : 0);
        break;

    case HTML_FRAMESET:
        new_frameset_item(me,
            present[HTML_FRAMESET_COLS] ? value[HTML_FRAMESET_COLS] : 0,
            present[HTML_FRAMESET_ROWS] ? value[HTML_FRAMESET_ROWS] : 0);
        break;

    case HTML_NOFRAMES: // netscape 'spec' says this
    case HTML_NOFRAME:  // netscape site uses this...
        if (include_frames)
            me->noframe++;
        break;

    case HTML_TITLE:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	if (me->rh->title)
	{
	    mm_free(me->rh->title);
	    me->rh->title = NULL;
	}
	new_state |= STK_STATE_LINES;
	break;

    case HTML_META:
	if (present[HTML_META_CONTENT] && present[HTML_META_HTTPEQUIV])
	{
	    if (strcasecomp(value[HTML_META_HTTPEQUIV], "REFRESH") == 0)
	    {
                char *ss, *s = strdup(value[HTML_META_CONTENT]);

                ss = strtok(s, " ;\n\r");
                if (ss)
                {
                    int i = atoi(ss);
		    if (i > 0)
		        me->rh->refreshtime = i;
                    do
                    {
                        if (strncasecomp(ss, "url=", 4) == 0)
                        {
                            me->rh->refreshurl = strdup(ss+4);
                        }
                    }
                    while ((ss = strtok(NULL, " ;\n\r")) != NULL);
                }

                mm_free(s);
	    }
	    else if (strcasecomp(value[HTML_META_HTTPEQUIV], "Window-target") == 0)
	    {
	        me->rh->windowname = strdup(value[HTML_META_CONTENT]);
	    }
	}
	break;

    case HTML_BODY:
	text_item_push_word(me, 0);
	if (present[HTML_BODY_BACKGROUND])
	{
	    me->rh->bgt |= rid_bgt_IMAGE;
	    if (me->rh->tile.src)
		mm_free(me->rh->tile.src);
	    me->rh->tile.src = strdup(value[HTML_BODY_BACKGROUND]);
	}
	if (present[HTML_BODY_BGCOLOR])
	{
	    me->rh->bgt |= rid_bgt_COLOURS;
	    htmlriscos_colour((char*) value[HTML_BODY_BGCOLOR], &me->rh->colours.back);
	}
	if (present[HTML_BODY_TEXT])
	{
	    me->rh->bgt |= rid_bgt_FCOL;
	    htmlriscos_colour((char*) value[HTML_BODY_TEXT], &me->rh->colours.fore);
	}
	if (present[HTML_BODY_LINK])
	{
	    me->rh->bgt |= rid_bgt_LCOL;
	    htmlriscos_colour((char*) value[HTML_BODY_LINK], &me->rh->colours.link);
	}
	if (present[HTML_BODY_VLINK])
	{
	    me->rh->bgt |= rid_bgt_VCOL;
	    htmlriscos_colour((char*) value[HTML_BODY_VLINK], &me->rh->colours.vlink);
	}
	if (present[HTML_BODY_ALINK])
	{
	    me->rh->bgt |= rid_bgt_ACOL;
	    htmlriscos_colour((char*) value[HTML_BODY_ALINK], &me->rh->colours.alink);
	}
	break;

    case HTML_FONT:
	if (present[HTML_FONT_SIZE])
	{
	    int size;
	    size = (me->rh->bgt & rid_bgt_BASEFONT) ? me->rh->basefont : 3; /* Default font size is 3 */

            // some documents use <FONT SIZE> to mean (apparently) restore default, yuk!
            if (value[HTML_FONT_SIZE])
            {
	        if (value[HTML_FONT_SIZE][0] == '+')
		    size += atoi(value[HTML_FONT_SIZE]+1);
	        else if (value[HTML_FONT_SIZE][0] == '-')
		    size -= atoi(value[HTML_FONT_SIZE]+1);
	        else
		    size = atoi(value[HTML_FONT_SIZE]);

	        if (size < 1)
		    size = 1;
	        if (size > 7)
		    size = 7;
	    }

	    text_item_push_word(me, 0);
	    new_style.wf_index &= ~WEBFONT_SIZE_MASK;
	    new_style.wf_index |= (size - 1) << WEBFONT_SIZE_SHIFT;

#if PARSE_DEBUG
            fprintf(stderr, "FONT size %p '%s' %d\n", value[HTML_FONT_SIZE], value[HTML_FONT_SIZE], size);
#endif
	}
	break;

    case HTML_BASE:
	if (present[HTML_BASE_HREF])
	{
	    me->rh->base = strdup(value[HTML_BASE_HREF]);
	}
	if (present[HTML_BASE_TARGET])
	{
	    me->rh->basetarget = strdup(value[HTML_BASE_TARGET]);
	}
	break;

    case HTML_BASEFONT:
	break;

    case HTML_LISTING:				/* Litteral text */
    case HTML_XMP:
    case HTML_PLAINTEXT:
    case HTML_PRE:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	new_style.wf_index = WEBFONT_PRE;
	new_state |= (STK_STATE_PRE | STK_STATE_LINES);
	break;

    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
    case HTML_H7:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
        {
	    int wf = new_style.wf_index;

	    if (element_number == HTML_H1) wf = WEBFONT_H1;
	    else if (element_number == HTML_H2) wf = WEBFONT_H2;
	    else if (element_number == HTML_H3) wf = WEBFONT_H3;
	    else if (element_number == HTML_H4) wf = WEBFONT_H4;
	    else if (element_number == HTML_H5) wf = WEBFONT_H5;
	    else if (element_number == HTML_H6) wf = WEBFONT_H6;
	    else if (element_number == HTML_H7) wf = WEBFONT_H7;

	    new_style.wf_index = wf;
	    new_state &= ~(STK_STATE_PRE | STK_STATE_LINES);
	}
	break;

    case HTML_DL:
	/* The style pushed here gets modified by the <DD> and <DL> tags */
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	if (new_style.indent < (256-INDENT_WIDTH) )
	    new_style.indent += INDENT_WIDTH;
	break;

    case HTML_DT:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	if (me->sp[0].tag_number == HTML_DL)
	{
	    me->sp[0].style.indent = me->sp[1].style.indent + 2;
	    me->sp[0].style.wf_index = WEBFONT_DT;
	}
	break;

    case HTML_DD:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	if (me->sp[0].tag_number == HTML_DL)
	{
	    me->sp[0].style.indent = me->sp[1].style.indent + INDENT_WIDTH;
	    me->sp[0].style.wf_index = WEBFONT_DD;
	}
	break;

    case HTML_CENTER:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	new_style.flags |= rid_sf_CENTERED;
	break;

    case HTML_CODE:
    case HTML_KBD:
    case HTML_SAMP:
    case HTML_TT:
	text_item_push_word(me, 0);
	new_style.wf_index |= WEBFONT_FLAG_FIXED;
	break;

    case HTML_STRONG:
    case HTML_B:
	text_item_push_word(me, 0);
	new_style.wf_index |= WEBFONT_FLAG_BOLD;
	break;

    case HTML_EM:
    case HTML_VAR:
    case HTML_I:
	text_item_push_word(me, 0);
	new_style.wf_index |= WEBFONT_FLAG_ITALIC;
	break;

    case HTML_CITE:
	text_item_push_word(me, 0);
	new_style.wf_index = WEBFONT_CITE;
	break;

    case HTML_BLOCKQUOTE:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	new_style.wf_index = WEBFONT_BLOCK;
	if (new_style.indent < (256-INDENT_WIDTH) )
	    new_style.indent += INDENT_WIDTH;
	break;

    case HTML_UL:
    case HTML_OL:
    case HTML_MENU:
    case HTML_DIR:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	if (new_style.indent < (256-INDENT_WIDTH) )
	    new_style.indent += INDENT_WIDTH;
	new_list = 0;
	break;

    case HTML_LI:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	switch (me->sp[0].tag_number)
	{
	case HTML_OL:
	    me->sp[0].list_no++;
	    break;
	case HTML_UL:
	case HTML_MENU:
	case HTML_DIR:
	default:
	    break;
	}

	{
	    int oldindent = me->sp[0].style.indent;

	    if (oldindent >= INDENT_WIDTH)
		me->sp[0].style.indent -= INDENT_WIDTH;
	    text_item_push_bullet(me);
	    me->sp[0].style.indent = oldindent;
	}
	break;

    case HTML_IMG:
	text_item_push_word(me, 0);
	text_item_push_image(me, 0,
			     present[HTML_IMG_SRC]   ? value[HTML_IMG_SRC]    : 0,
			     present[HTML_IMG_ALT]   ? value[HTML_IMG_ALT]    : 0,
			     present[HTML_IMG_ALIGN] ? value[HTML_IMG_ALIGN]  : 0,
			     present[HTML_IMG_BORDER]? value[HTML_IMG_BORDER] : 0,
			     present[HTML_IMG_WIDTH] ? value[HTML_IMG_WIDTH]  : 0,
			     present[HTML_IMG_HEIGHT]? value[HTML_IMG_HEIGHT] : 0,
			     present[HTML_IMG_USEMAP] ? value[HTML_IMG_USEMAP] : 0,
			     present[HTML_IMG_ISMAP] ? 1 : 0);
	break;

    case HTML_INPUT:
	text_item_push_word(me, 0);
	text_item_push_input(me, 0, present, value);
	break;

    case HTML_P:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	text_item_push_break(me, 0);
	break;

    case HTML_HR:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	text_item_push_break(me, 1);
	break;

    case HTML_BR:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	break;

    case HTML_U:
	text_item_push_word(me, 0);
	new_style.flags |= rid_sf_UNDERLINE;
	break;

    case HTML_ISINDEX:
	me->rh->flags |= rid_hf_ISINDEX;
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	text_item_push_break(me, 1);

	push_fake_search_form(me, (char *) (present[HTML_INDEX_PROMPT] ? value[HTML_INDEX_PROMPT] : 0));

	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	text_item_push_break(me, 1);
	break;

    case HTML_SELECT:
	text_item_push_word(me, STRIP_SPACE);
	text_item_push_select(me,
			      (char *) (present[HTML_SELECT_NAME] ? value[HTML_SELECT_NAME] : 0),
			      (char *) (present[HTML_SELECT_SIZE] ? value[HTML_SELECT_SIZE] : 0),
			      present[HTML_SELECT_MULTIPLE] );
	new_state |= (STK_STATE_LINES);
	break;

    case HTML_OPTION:
	text_item_push_word(me, STRIP_SPACE);
	new_option_item(me,
			(char *) (present[HTML_OPTION_VALUE] ? value[HTML_OPTION_VALUE] : 0),
			(present[HTML_OPTION_DISABLED] ? rid_if_DISABLED : 0) + (present[HTML_OPTION_SELECTED] ? rid_if_CHECKED : 0) );
	break;

    case HTML_TEXTAREA:
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	text_item_push_textarea(me,
				(char *) (present[HTML_TEXTAREA_NAME] ? value[HTML_TEXTAREA_NAME] : 0),
				(char *) (present[HTML_TEXTAREA_ROWS] ? value[HTML_TEXTAREA_ROWS] : 0),
				(char *) (present[HTML_TEXTAREA_COLS] ? value[HTML_TEXTAREA_COLS] : 0) );
	new_state |= (STK_STATE_PRE | STK_STATE_LINES);
	break;

    case HTML_MAP:
	text_item_push_word(me, 0);
        new_map_item(me, present[HTML_MAP_NAME] ? value[HTML_MAP_NAME] : 0);
        break;
    case HTML_AREA:
	text_item_push_word(me, 0);
        new_area_item(me,
            (present[HTML_AREA_SHAPE] ? value[HTML_AREA_SHAPE] : 0),
            (present[HTML_AREA_COORDS] ? value[HTML_AREA_COORDS] : 0),
            (present[HTML_AREA_HREF] ? value[HTML_AREA_HREF] : 0),
            (present[HTML_AREA_TARGET] ? value[HTML_AREA_TARGET] : 0),
            (present[HTML_AREA_ALT] ? value[HTML_AREA_ALT] : 0));
        break;

    case HTML_SCRIPT:
	text_item_push_word(me, 0);
	me->noframe++;
	break;

    case HTML_CAPTION:
	text_item_push_word(me, STRIP_SPACE);
        if ( present[HTML_CAPTION_ID] && 
             value[HTML_CAPTION_ID] != NULL && 
             value[HTML_CAPTION_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_CAPTION_ID], NULL, NULL);                               
        new_style.flags |=
        table_start_caption(me,
                      V_OR_NULL(HTML_CAPTION_ALIGN),
                      V_OR_NULL(HTML_CAPTION_CLASS),
                      V_OR_NULL(HTML_CAPTION_DIR),
                      V_OR_NULL(HTML_CAPTION_ID),
                      V_OR_NULL(HTML_CAPTION_LANG),
                      V_OR_NULL(HTML_CAPTION_STYLE)
                     );
        break;
    case HTML_TABLE:
    {
        /* The start of a table or start of a row pushes a line break */
        char *border = NULL;
        if ( present[HTML_TABLE_BORDER] )
        {
          	border = (char*)value[HTML_TABLE_BORDER];
          	if (border == NULL)
          		border = "1";
        }
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE/*?*/);
        must_have_a_text_item(me);
        if ( present[HTML_TABLE_ID] && 
             value[HTML_TABLE_ID] != NULL && 
             value[HTML_TABLE_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_TABLE_ID], NULL, NULL);                               
        new_style.flags |=
        table_start_table(me,
                        (char *) (present[HTML_TABLE_ALIGN] ? value[HTML_TABLE_ALIGN] : NULL ),
			border,
                        (char *) (present[HTML_TABLE_CELLPADDING] ? value[HTML_TABLE_CELLPADDING] : NULL ),
                        (char *) (present[HTML_TABLE_CELLSPACING] ? value[HTML_TABLE_CELLSPACING] : NULL ),
                        (char *) (present[HTML_TABLE_CLASS] ? value[HTML_TABLE_CLASS] : NULL ),
                        (char *) (present[HTML_TABLE_COLS]  ? value[HTML_TABLE_COLS]  : NULL ),
                        (char *) (present[HTML_TABLE_DIR]   ? value[HTML_TABLE_DIR]   : NULL ),
                        (char *) (present[HTML_TABLE_FRAME] ? value[HTML_TABLE_FRAME] : NULL ),
                        (char *) (present[HTML_TABLE_ID]    ? value[HTML_TABLE_ID]    : NULL ),
                        (char *) (present[HTML_TABLE_LANG]  ? value[HTML_TABLE_LANG]  : NULL ),
                        (char *) (present[HTML_TABLE_RULES] ? value[HTML_TABLE_RULES] : NULL ),
                        (char *) (present[HTML_TABLE_STYLE] ? value[HTML_TABLE_STYLE] : NULL ),
                        (char *) (present[HTML_TABLE_WIDTH] ? value[HTML_TABLE_WIDTH] : NULL )
                       );
        new_style.indent = 0;
        break;
    }
    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
	text_item_push_word(me, STRIP_SPACE);
        ASSERT( HTML_THEAD_ATTRIBUTES == HTML_TFOOT_ATTRIBUTES);
        ASSERT( HTML_THEAD_ATTRIBUTES == HTML_TBODY_ATTRIBUTES);
        if ( present[HTML_THEAD_ID] && 
             value[HTML_THEAD_ID] != NULL && 
             value[HTML_THEAD_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_THEAD_ID], NULL, NULL);                               
        table_start_rowgroup(me, element_number,
                             V_OR_NULL(HTML_THEAD_ALIGN),
                             V_OR_NULL(HTML_THEAD_CHAR),
                             V_OR_NULL(HTML_THEAD_CHAROFF),
                             V_OR_NULL(HTML_THEAD_CLASS),
                             V_OR_NULL(HTML_THEAD_DIR),
                             V_OR_NULL(HTML_THEAD_ID),
                             V_OR_NULL(HTML_THEAD_LANG),
                             V_OR_NULL(HTML_THEAD_STYLE),
                             V_OR_NULL(HTML_THEAD_VALIGN)
                            );
        break;
    case HTML_COLGROUP:
	text_item_push_word(me, STRIP_SPACE);
        if ( present[HTML_COLGROUP_ID] && 
             value[HTML_COLGROUP_ID] != NULL && 
             value[HTML_COLGROUP_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_COLGROUP_ID], NULL, NULL);                               
        table_start_colgroup(me,
                           V_OR_NULL(HTML_COLGROUP_ALIGN),
                           V_OR_NULL(HTML_COLGROUP_CHAR),
                           V_OR_NULL(HTML_COLGROUP_CHAROFF),
                           V_OR_NULL(HTML_COLGROUP_CLASS),
                           V_OR_NULL(HTML_COLGROUP_DIR),
                           V_OR_NULL(HTML_COLGROUP_ID),
                           V_OR_NULL(HTML_COLGROUP_LANG),
                           V_OR_NULL(HTML_COLGROUP_SPAN),
                           V_OR_NULL(HTML_COLGROUP_STYLE),
                           V_OR_NULL(HTML_COLGROUP_VALIGN),
                           V_OR_NULL(HTML_COLGROUP_WIDTH)
                          );
        break;
    case HTML_COL:
	text_item_push_word(me, STRIP_SPACE);
        if ( present[HTML_COL_ID] && 
             value[HTML_COL_ID] != NULL && 
             value[HTML_COL_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_COL_ID], NULL, NULL);                               
        table_start_col(me,
                        V_OR_NULL(HTML_COL_ALIGN),
                        V_OR_NULL(HTML_COL_CHAR),
                        V_OR_NULL(HTML_COL_CHAROFF),
                        V_OR_NULL(HTML_COL_CLASS),
                        V_OR_NULL(HTML_COL_DIR),
                        V_OR_NULL(HTML_COL_ID),
                        V_OR_NULL(HTML_COL_LANG),
                        V_OR_NULL(HTML_COL_SPAN),
                        V_OR_NULL(HTML_COL_STYLE),
                        V_OR_NULL(HTML_COL_VALIGN),
                        V_OR_NULL(HTML_COL_WIDTH)
                       );
        break;
    case HTML_TR:
	text_item_push_word(me, STRIP_SPACE);
        if ( present[HTML_TR_ID] && 
             value[HTML_TR_ID] != NULL && 
             value[HTML_TR_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_TR_ID], NULL, NULL);                               
        table_start_tr(me,
                        V_OR_NULL(HTML_TR_ALIGN),
                        V_OR_NULL(HTML_TR_CHAR),
                        V_OR_NULL(HTML_TR_CHAROFF),
                        V_OR_NULL(HTML_TR_CLASS),
                        V_OR_NULL(HTML_TR_DIR),
                        V_OR_NULL(HTML_TR_ID),
                        V_OR_NULL(HTML_TR_LANG),
                        V_OR_NULL(HTML_TR_STYLE),
                        V_OR_NULL(HTML_TR_VALIGN)
                       );
	break;
    case HTML_TH:
    case HTML_TD:
	text_item_push_word(me, STRIP_SPACE);
        assert(HTML_TH_ATTRIBUTES == HTML_TD_ATTRIBUTES);
        if ( present[HTML_TD_ID] && 
             value[HTML_TD_ID] != NULL && 
             value[HTML_TD_ID][0] != 0 )
                new_aref_item(me, NULL, value[HTML_TD_ID], NULL, NULL);                               
	new_style = me->sp[0].def_style;
        if (element_number == HTML_TH)
        {
fprintf(stderr, "Choosing bold for TH\n");
        	new_style.wf_index |= WEBFONT_FLAG_BOLD;
        }
        new_style.flags |=	/* @@@@ This does no good as nothing is stacked for 'empty' elements */
        table_start_th_td(me, element_number,
                        V_OR_NULL(HTML_TD_ALIGN),
                        V_OR_NULL(HTML_TD_AXES),
                        V_OR_NULL(HTML_TD_AXIS),
                        V_OR_NULL(HTML_TD_CHAR),
                        V_OR_NULL(HTML_TD_CHAROFF),
                        V_OR_NULL(HTML_TD_CLASS),
                        V_OR_NULL(HTML_TD_COLSPAN),
                        V_OR_NULL(HTML_TD_DIR),
                        V_OR_NULL(HTML_TD_ID),
                        V_OR_NULL(HTML_TD_LANG),
                        present[HTML_TD_NOWRAP],
                        V_OR_NULL(HTML_TD_ROWSPAN),
                        V_OR_NULL(HTML_TD_STYLE),
                        V_OR_NULL(HTML_TD_VALIGN)
                );
        break;

    default:
	text_item_push_word(me, 0);
	break;
    }

    if (me->dtd->tags[element_number].contents != SGML_EMPTY)
    {
        if (me->sp == me->stack)
	{
	    fprintf(stderr, "HTML: ****** Maximum nesting of %d exceded!\n", MAX_NESTING);
	    me->rh->flags |= rid_hf_HTML_ERRS;
	    return;
	}
    	--(me->sp);
	me->sp[0].style = me->sp[0].def_style = new_style;	/* Stack new style */
	me->sp[0].state = new_state;	/* Stack new state */
	me->sp[0].list_no = new_list;	/* Stack new list position */
	me->sp[0].tag_number = element_number;
    }
    else
    {
      	/* Update the current style without stacking */
        me->sp[0].style = new_style;
    }

}


/*		End Element
**		-----------
**
**	Ends an markup element			Henrik 07/03-94
**	Does no assumptions of WHAT element is ended...
*/
static void HTRISCOS_end_element (HTStructured * me, int element_number)
{
#if PARSE_DEBUG
    fprintf(stderr, "<End element %d '%s'>\n", element_number, me->dtd->tags[element_number].name);
#endif

    switch (element_number)
    {
    case HTML_PRE:
    case HTML_DT:
    case HTML_DD:
    case HTML_DL:
    case HTML_H1:
    case HTML_H2:
    case HTML_H3:
    case HTML_H4:
    case HTML_H5:
    case HTML_H6:
    case HTML_H7:
    case HTML_TITLE:
    case HTML_BLOCKQUOTE:
    case HTML_UL:
    case HTML_OL:
    case HTML_MENU:
    case HTML_DIR:
    case HTML_FORM:
    case HTML_CENTER:
        if (!me->noframe)
	    text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	break;

    case HTML_FRAMESET:
        // unstack frameset, check level as we may be skipping framesets
        if (me->frameset > 0)
        {
            if (--me->frameset == 0)
                me->noframe++;
        }
        break;

    case HTML_NOFRAME:
    case HTML_NOFRAMES:
        me->noframe--;
        break;

    case HTML_MAP:
        me->map = NULL;
        break;

    case HTML_TABLE:
        if (!me->noframe)
        {
	    text_item_push_word(me, STRIP_SPACE);
            table_end_table(me);
            must_have_a_text_item(me);
	    text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
        }
        break;


    case HTML_COLGROUP:
        if (!me->noframe)
        {
	    text_item_push_word(me, STRIP_SPACE);
            table_end_colgroup(me);
        }
        break;

    case HTML_COL:
    case HTML_THEAD:
    case HTML_TFOOT:
    case HTML_TBODY:
    case HTML_TR:
    case HTML_TH:
    case HTML_TD:
        if (!me->noframe)
	    text_item_push_word(me, STRIP_SPACE);
        break;

    case HTML_SCRIPT:
	if (--me->noframe)
	    text_item_push_word(me, 0);
	break;

    default:
        if (!me->noframe)
	    text_item_push_word(me, 0);
	break;
    }

#ifdef CAREFUL			/* parser assumed to produce good nesting */
    if (element_number != me->sp[0].tag_number) {
        fprintf(stderr, "***** HTMLText: end of element %s when expecting end of %s\n",
		me->dtd->tags[element_number].name,
		me->dtd->tags[me->sp->tag_number].name);
		/* panic */
	me->rh->flags |= rid_hf_HTML_ERRS;
    }
#endif

    /* This test should not be needed but some people can't read the spec and give us bad HTML */
    if (me->dtd->tags[element_number].contents != SGML_EMPTY)
    {
	if (me->sp != me->stack + MAX_NESTING - 1)
	    me->sp++;				/* Pop state off stack */
	else
	{
	    fprintf(stderr, "***** Stack underrun\n");
	    me->rh->flags |= rid_hf_HTML_ERRS;
	}
    }

    switch (element_number)
    {
    case HTML_A:
	/* Clear the current anchor.  They are not supposed to be nested */
	if (me->aref && me->aref->first == NULL)
	    me->aref->first = me->rh->curstream->text_last;
	me->aref = 0;
	break;
    case HTML_FORM:
	/* Leaving the current form.  Again, it sould not be nested */
#if 0
	me->form = 0;
#endif
	break;
    }
}

/*		Expanding entities
**		------------------
**
*/
static void HTRISCOS_put_entity (HTStructured * me, int entity_number)
{
#if PARSE_DEBUG
    fprintf(stderr, "<E%02x>", entity_number );
#endif
    HTRISCOS_put_string(me, ISO_Latin1[entity_number]);
}


/*	Free an HTML object
**	-------------------
**
*/
static void HTRISCOS_free (HTStructured * me)
{
#if 0
    (*me->targetClass._free)(me->target);	/* ripple through */
#endif
    mm_free(me);
}


static void HTRISCOS_abort (HTStructured * me, HTError e)
{
    HTRISCOS_free(me);
}


/*	Structured Object Class
**	-----------------------
*/
static const HTStructuredClass HTRISCOSeration = /* As opposed to print etc */
{
	"HTMLToTeX",
	HTRISCOS_free,
	HTRISCOS_abort,
	HTRISCOS_put_character,        	HTRISCOS_put_string,	HTRISCOS_write,
	HTRISCOS_start_element, 	HTRISCOS_end_element,
	HTRISCOS_put_entity
};



extern HTStructured * HTMLToRiscos (HTStream * output)
{
    HTStructured* me = (HTStructured*) mm_calloc(1, sizeof(*me));

    if (me == NULL)
    {
	fprintf(stderr, "Couldn't get memory for HTStructured\n");
	return NULL;
    }
    me->isa = &HTRISCOSeration;
    me->dtd = &HTMLP_dtd;
    me->rh = (rid_header *) mm_calloc(1, sizeof(rid_header));
    if (me->rh == NULL)
    {
	fprintf(stderr, "Couldn't get memory for rid_header\n");
	mm_free(me);
	return NULL;
    }

    if (memzone_init(&(me->rh->texts), MEMZONE_CHUNKS) == FALSE)
    {
	fprintf(stderr, "Couldn't init memzone\n");

	mm_free(me->rh);
	mm_free(me);
	return NULL;
    }

    me->rh->curstream = & me->rh->stream;
    me->write_ptr = &(me->buf[0]);
    /* me->white_count = 0 */
    /* me->aref = NULL */
    /* me->table = NULL */

    me->sp = me->stack + MAX_NESTING - 1;
    me->sp->tag_number = -1;	/* INVALID */
    me->sp->style.wf_index = WEBFONT_BASE; /* Mark as base style */
    /* me->sp->style.flags = 0; */
    /* me->sp->style.indent = 0; */

    me->strip_space = STRIP_SPACE;

    return me;
}

rid_header *parse_some_file(char *fname, char *url, int ft)
{
    void *h;
    FILE *fp;
    char buffer[1024];
    pparse_details *ppd;

    for(ppd = file_parsers; ppd->ftype != -1 && ppd->ftype != ft; ppd++)
	;

    if (ppd->ftype == -1)
    {
	fprintf(stderr, "\n\n**** Broken lookup in file parser.  Contact ANT Ltd. ****\n\n");
	return 0;
    }

    h = ppd->new(url, ft);

    fp = fopen(fname, "r");
    if (fp == 0)
    {
	fprintf(stderr, "Can't open file\n");
	return 0;
    }

    while (!feof(fp))
    {
	int n;

	if ((n = fread(buffer, 1, sizeof(buffer), fp)) != 0)
	{
	    ppd->data(h, buffer, n, 1);
	}
    }

    fclose(fp);

    return ppd->close(h, fname);
}

rid_header *parse_html_file(char *fname, char *url)
{
    return parse_some_file(fname, url, FILETYPE_HTML);
}

void *pparse_html_new(char *url, int ft)
{
#if 1
        HTMLCTX *htmlctx = mm_calloc(1, sizeof(HTMLCTX));
        SGMLCTX *sgmlctx = sgml_new_context();

        sgmlctx->elements = elements;
        sgmlctx->chopper = sgml;
        sgmlctx-> = ;
        sgmlctx-> = ;
        sgmlctx-> = ;

#else
    HTStream *new;
    HTStructured* me;

    me = HTMLToRiscos(NULL);
    if (me == NULL)
	return NULL;

    new = SGML_new(&HTMLP_dtd, me );

    return new;
#endif
}

int pparse_html_data(void *h, char *buffer, int len, int more)
{
    HTStream *new = h;

    new->isa->put_block(new, buffer, len);

    return 1;
}

rid_header *pparse_html_rh(void *h)
{
    HTStream *new = h;
    rid_header *result;
    HTStructured* me;

    me = SGML_Get_Target(new);

    result = me->rh;

    return result;
}

rid_header *pparse_html_close(void *h, char *cfile)
{
    HTStream *new = h;
    rid_header *result;
    HTStructured* me;

    me = SGML_Get_Target(new);

    text_item_push_word(me, 0);

#if CAREFUL
    if (me->sp != me->stack + MAX_NESTING - 1)
	fprintf(stderr, "Stack not fully unwound, %d left\n", (me->sp - (me->stack + MAX_NESTING - 1)));
#endif

#if PARSE_DEBUG
    fprintf(stderr, "Exiting with title '%s'\n", me->rh->title ? me->rh->title : "<none>");
#endif
    result = me->rh;

    memzone_tidy(&(result->texts));

    new->isa->_free(new);

    return result;
}

void *pparse_text_new(char *url, int ft)
{
    HTStructured* me;

    me = HTMLToRiscos(NULL);
    if (me == NULL)
	return NULL;

    me->sp->style.wf_index = WEBFONT_PRE; /* Text files come out pre-formated */
    me->sp->tag_number = HTML_PRE;
    me->sp->state = STK_STATE_PRE | STK_STATE_LINES;
    me->write_ptr = me->buf;

    return me;
}

static void pparse_text_data_push_line(HTStructured* me)
{
    while (me->write_ptr > me->buf && me->write_ptr[-1] == ' ')
	me->write_ptr--;

    *me->write_ptr = 0;

    text_item_push_word(me, HARD_BREAK);
}

int pparse_text_data(void *h, char *buffer, int len, int more)
{
    HTStructured* me = h;

    while (len)
    {
	int c = *buffer;
	buffer++;
	len--;

	if (c == '\t')
	{
	    do
	    {
		*(me->write_ptr++) = ' ';
	    } while ( ((me->write_ptr - me->buf) % 8) != 0 );
	}
	else if (c == '\r' || c == '\n')
	{
	    if (c != *buffer && (*buffer == '\r' || *buffer == '\n'))
	    {
		buffer++;
		len--;
	    }

	    pparse_text_data_push_line(me);
	}
	else if (c < 32 || c == 127)
	    *me->write_ptr++ = '\267';
	else
	    *me->write_ptr++ = c;

	if (me->write_ptr >= (me->buf + 256) )
	    pparse_text_data_push_line(me);
    }

    return 1;
}

rid_header *pparse_text_rh(void *h)
{
    HTStructured* me = h;
    rid_header *result;

    result = me->rh;

    return result;
}

rid_header *pparse_text_close(void *h, char *cfile)
{
    HTStructured* me = h;
    rid_header *result;

    text_item_push_word(me, 0);

    result = me->rh;

    memzone_tidy(&(result->texts));

    mm_free(me);

    return result;
}

rid_header *parse_text_file(char *fname, char *url)
{
    return parse_some_file(fname, url, FILETYPE_TEXT);
}

typedef struct {
    image i;
    HTStructured* me;
    int already;
    int have_image;
    char *url;
} imp_str;

rid_header *pparse_image_close(void *h, char *cfile)
{
    imp_str *impp;
    rid_header *res;

    impp = (imp_str *) h;

    res = impp->me->rh;

    image_stream_end(impp->i, cfile);

    memzone_tidy(&(res->texts));

    mm_free(impp->me);

    mm_free(impp->url);

    mm_free(impp);

    return res;
}

rid_header *pparse_image_rh(void *h)
{
    imp_str *impp;
    rid_header *res;

    impp = (imp_str *) h;

    res = impp->me->rh;

    return res;
}

int pparse_image_data(void *h, char *buffer, int len, int more)
{
    imp_str *impp;

    impp = (imp_str *) h;

    if (!impp->have_image)
    {
	impp->have_image = TRUE;
	text_item_push_image(impp->me, FORCE_BREAK, impp->url, 0, 0, 0, 0, 0, 0, 0);
    }

    if (impp->i && impp->already == 0)
    {
	image_stream_data(impp->i, buffer, len, !more);
    }

    return TRUE;
}

void *pparse_image_new(char *url, int ft)
{
    imp_str *impp;

    impp = mm_calloc(1, sizeof(*impp));

    if (impp)
    {
	impp->me = HTMLToRiscos(NULL);

	if (impp->me == NULL)
	{
	    mm_free(impp);
	    return NULL;
	}

	impp->url = strdup(url);

	if (image_stream(url, ft, &impp->already, &impp->i) != 0)
	    impp->i = NULL;
    }

    return impp;
}

rid_header *parse_gif_file(char *fname, char *url)
{
    HTStructured* me;
    rid_header *result;

    me = HTMLToRiscos(NULL);

    if (me == NULL)
	return NULL;

    text_item_push_image(me, FORCE_BREAK, url, 0, 0, 0, 0, 0, 0, 0);

    result = me->rh;

    memzone_tidy(&(result->texts));

    mm_free(me);

    return result;
}

rid_header *parse_gopher_file(char *fname, char *url)
{
    return parse_some_file(fname, url, FILETYPE_GOPHER);
}

typedef struct {
    HTStructured* me;
    int used;
    char buffer[1024];
} gparse_str;

void *pparse_gopher_new(char *url, int ft)
{
    gparse_str *gp;

    gp = mm_malloc(sizeof(*gp));
    if (gp)
    {
	gp->me = HTMLToRiscos(NULL);

	if (gp->me == NULL)
	{
	    mm_free(gp);
	    return NULL;
	}

	gp->used = 0;
	gp->buffer[0] = 0;

	gp->me->sp->style.wf_index = WEBFONT_H1; /* Heading displayed at level 1 */
	gp->me->sp->tag_number = HTML_H1;

	HTRISCOS_put_string(gp->me, "Gopher Menu");
	text_item_push_word(gp->me, FORCE_BREAK | STRIP_SPACE);

	gp->me->sp->style.wf_index = WEBFONT_BASE; /* Text lines come out in base font */
	gp->me->sp->tag_number = -1;
    }

    return gp;
}

static void pparse_gopher_put_line(HTStructured* me, char *buffer)
{
    char type;
    char *entry, *object, *site = NULL, *port = NULL, *goplus = NULL;
    char newurl[1024];
    int n;
    int ft;
    char ibuf[32];

    type = buffer[0];

    entry = buffer + 1;
    object = strchr(buffer+1, '\t');
    if (object)
    {
	*object = 0;
	object++;

	site = strchr(object, '\t');
	if (site)
	{
	    *site = 0;
	    site++;

	    port = strchr(site, '\t');
	    if (port)
	    {
		*port = 0;
		port++;

		goplus = strchr(port, '\t');
		if (goplus)
		{
		    *goplus = 0;
		    goplus++;
		}
	    }

	}
    }

    if (port && (port[0] == 0  || (port[0] == '0' && port[1] == 0)) )
    {
	port = 0;
    }

    if (object && object[0] == 0)
    {
	object = 0;
    }
    else
    {
	object = url_escape_chars(object, "#;?:");
    }
#if 1
    fprintf(stderr, "Type='%c', entry='%s', object='%s', site='%s', port='%s'\n",
	    type,
	    entry ? entry : "<None>",
	    object ? object : "<None>",
	    site ? site : "<None>",
	    port ? port : "<None>" );
#endif
    newurl[0] = 0;

    switch (type)
    {
    case '0':		/* Document */
    case '1':		/* Directory */
    case '4':		/* BinHex */
    case '5':		/* DOS Binary */
    case '6':		/* UNIX uuencoded */
    case '9':		/* Random binary file */
    case 'g':		/* GIF file */
    case 'I':		/* Random image file */
    case '7':		/* Query item */
	/* Gopher item */
	strcpy(ibuf, "icontype:");
	ft = -1;
	switch (type)
	{
	default:
	case '0':		/* Document */
	case '4':		/* BinHex */
	case '6':		/* UNIX uuencoded */
	    ft = FILETYPE_TEXT;
	    break;
	case '1':		/* Directory */
	    strcat(ibuf, "directory");
	    break;
	case '7':		/* Query item */
	    strcat(ibuf, "query");
	    break;
	case '5':		/* DOS Binary */
	    ft = FILETYPE_DOS;
	    break;
	case '9':		/* Random binary file */
	case 'I':		/* Random image file */
	    ft = FILETYPE_DATA;
	    break;
	case 'g':		/* GIF file */
	    ft = FILETYPE_GIF;
	    break;
	}

	if (ft != -1)
	    sprintf(ibuf + strlen(ibuf), ",%03x", ft);

	if (site)
	{
	    strcat(newurl, "gopher://");
	    strcat(newurl, site);
	    if (port)
	    {
		strcat(newurl, ":");
		strcat(newurl, port);
	    }
	}
	strcat(newurl, "/");
	n = strlen(newurl);
	newurl[n] = type;
	newurl[n+1] = 0;
	if (object)
	{
	    strcat(newurl, object);
	}

	text_item_push_image(me, 0, ibuf, 0, 0, 0, 0, 0, 0, 0);

	new_aref_item(me, newurl, 0, 0, 0);

	HTRISCOS_put_string(me, entry);

	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	me->aref = NULL;
	break;
    case '8':
    case 'T':
	/* Telnet/tn3270 item */
	text_item_push_image(me, 0, "icontype:telnet", 0, 0, 0, 0, 0, 0, 0);

	if (site)
	{
	    strcat(newurl, type == '8' ? "telnet://" : "tn3270://" );
	    if (object)
	    {
		strcat(newurl, object);
		strcat(newurl, "@");
	    }
	    strcat(newurl, site);
	    if (port)
	    {
		strcat(newurl, ":");
		strcat(newurl, port);
	    }
	    new_aref_item(me, newurl, 0, 0, 0);
	}
	else
	    me->aref = NULL;
	HTRISCOS_put_string(me, entry);
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	me->aref = NULL;
	break;
    case 'h':		/* Hypertext */
	/* Gopher item */
	text_item_push_image(me, 0, "icontype:,faf", 0, 0, 0, 0, 0, 0, 0);

	if (object && strncmp(object, "GET ", 4) == 0)
	{
	    if (site)
	    {
		strcat(newurl, "http://");
		strcat(newurl, site);
		if (port)
		{
		    strcat(newurl, ":");
		    strcat(newurl, port);
		}
	    }

	    if (object)
	    {
		strcat(newurl, object + 4);
	    }
	    new_aref_item(me, newurl, 0, 0, 0);
	}

	HTRISCOS_put_string(me, entry);

	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	me->aref = NULL;
	break;
    case '2':		/* CSO */
    case '3':		/* Should not happen */
    default:
	/* Unknown item */
	text_item_push_image(me, 0, "icontype:blank", 0, 0, 0, 0, 0, 0, 0);

	HTRISCOS_put_string(me, entry);
	text_item_push_word(me, FORCE_BREAK | STRIP_SPACE);
	break;
    }

    if (object)
	mm_free(object);
}

int pparse_gopher_data(void *h, char *buffer, int len, int more)
{
    gparse_str *gp = h;

    while (len)
    {
	char c;
	int overflow;

	c = *buffer;
	buffer++;
	len--;

	overflow = (gp->used > (sizeof(gp->buffer) - 2));

	if (overflow || c == '\r' || c == '\n')
	{
	    if (!overflow && (c != *buffer) && (*buffer == '\r' || *buffer == '\n'))
	    {
		buffer++;
		len--;
	    }

	    if (gp->used > 1 || (gp->used == 1 && gp->buffer[0] != '.'))
	    {
		gp->buffer[gp->used] = 0;
		pparse_gopher_put_line(gp->me, gp->buffer);
		gp->used = 0;
		gp->buffer[0] = 0;
	    }
	}
	else
	{
	    gp->buffer[gp->used++] = c;
	}
    }

    return 1;
}

rid_header *pparse_gopher_rh(void *h)
{
    gparse_str *gp = h;

    return gp->me->rh;
}

rid_header *pparse_gopher_close(void *h, char *cfile)
{
    rid_header *result;
    gparse_str *gp = h;

    if (gp->used > 1 || (gp->used == 1 && gp->buffer[0] != '.'))
    {
	gp->buffer[gp->used] = 0;
	pparse_gopher_put_line(gp->me, gp->buffer);
	gp->used = 0;
	gp->buffer[0] = 0;
    }

    result = gp->me->rh;

    memzone_tidy(&(result->texts));

    mm_free(gp->me);
    mm_free(gp);

    return result;
}

void parse_frames(int yes)
{
    include_frames = yes == -1 ? !include_frames : yes;
}

pparse_details file_parsers[] = {
{ FILETYPE_HTML,	parse_html_file,	pparse_html_new,	pparse_html_data,	pparse_html_rh,	pparse_html_close },
{ FILETYPE_TEXT,	parse_text_file,	pparse_text_new,	pparse_text_data,	pparse_text_rh,	pparse_text_close },
{ FILETYPE_GOPHER,	parse_gopher_file,	pparse_gopher_new,	pparse_gopher_data,	pparse_gopher_rh,	pparse_gopher_close },
{ FILETYPE_ANY_IMAGE,	parse_gif_file,		pparse_image_new,	pparse_image_data,	pparse_image_rh,	pparse_image_close },

{ -1,			NULL,			NULL,			NULL,			NULL,		NULL	}
};
