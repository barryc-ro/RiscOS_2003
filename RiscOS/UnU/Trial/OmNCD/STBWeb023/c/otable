/* -*-c-*- */


/* otable.c */

/* Methods for table objects */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "drawftypes.h"
#include "wimp.h"
#include "font.h"
#include "bbc.h"

#include "interface.h"
#include "antweb.h"
#include "rid.h"
#include "webfonts.h"
#include "consts.h"
#include "config.h"
#include "util.h"
#include "render.h"
#include "rcolours.h"
#include "tables.h"

#include "object.h"
#include "version.h"
#include "dfsupport.h"


/* This just propogates the size to items below. */
/* Can't rely upon pos list being valid */
/* Can't get real size for table until have some width information */
/* for our surroundings. */

void otable_size(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
        rid_table_item *table = ((rid_text_item_table *)ti)->table;
        rid_table_caption *capt = table->caption;
        rid_table_cell *cell;
        int x = -1, y = 0;

        if ( capt != NULL )
        {
                for (ti = capt->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].size != NULL )
                        	(object_table[ti->tag].size)(ti, doc->rh, doc);
                }
        }

        while ( (cell = rid_next_root_cell(table, &x, &y)) != NULL)
        {
                if (cell->stream.text_list == NULL)
                        continue;
                for (ti = cell->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].size != NULL )
                             	(object_table[ti->tag].size)(ti, doc->rh, doc);
                }
        }
}


void otable_dispose(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
        rid_table_item *table = ((rid_text_item_table *)ti)->table;
        rid_table_caption *capt = table->caption;
        rid_table_cell *cell;
        int x = -1, y = 0;

        if ( capt != NULL )
        {
                for (ti = capt->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].dispose != NULL )
                        	(object_table[ti->tag].dispose)(ti, doc->rh, doc);
                }
        }

        while ( (cell = rid_next_root_cell(table, &x, &y)) != NULL)
        {
                if (cell->stream.text_list == NULL)
                        continue;
                for (ti = cell->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].dispose != NULL )
                             	(object_table[ti->tag].dispose)(ti, doc->rh, doc);
                }
        }
}

/* obviously, something needs doing here! */

char * otable_click(rid_text_item *ti, rid_header *rh, antweb_doc *doc, int x, int y, wimp_bbits bb)
{
  	return "";
}



/* this is a simple rendering of tables - horizontal adjacency is lost */

void otable_astext(rid_text_item *ti, rid_header *rh, FILE *f)
{
        rid_table_item *table = ((rid_text_item_table *)ti)->table;
        rid_table_caption *capt = table->caption;
        rid_table_cell *cell;
        int x = -1, y = 0;

        fputs("<TABLE>\n", f);

        if ( capt != NULL )
        {
                fputs("<CAPTION>\n", f);
                for (ti = capt->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].astext != NULL )
                        	(object_table[ti->tag].astext)(ti, rh, f);
                }
                fputs("</CAPTION>\n", f);
        }

        while ( (cell = rid_next_root_cell(table, &x, &y)) != NULL)
        {
                if (cell->stream.text_list == NULL)
                        continue;
                fprintf(f, "<CELL X=%d Y=%d>\n", cell->cell.x, cell->cell.y);
                for (ti = cell->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].astext != NULL )
                             	(object_table[ti->tag].astext)(ti, rh, f);
                }
                fputs("</CELL>\n", f);
        }

        fputs("</TABLE>\n", f);
}

/* Don't know if I can recurse like this */
/* No table border frame yet */
void otable_asdraw(rid_text_item *ti, antweb_doc *doc, int fh,
		  int x, int y, int *fileoff, wimp_box *bb)
{
        rid_table_item *table = ((rid_text_item_table *)ti)->table;
        rid_table_caption *capt = table->caption;
        rid_table_cell *cell;
        int xx = -1, yy = 0;

        if ( capt != NULL )
        {
                for (ti = capt->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].asdraw != NULL )
                        	(object_table[ti->tag].asdraw)(ti, doc, fh, x, y, fileoff, bb);
                }
        }

        while ( (cell = rid_next_root_cell(table, &xx, &yy)) != NULL)
        {
                if (cell->stream.text_list == NULL)
                        continue;
                for (ti = cell->stream.text_list; ti != NULL; ti = rid_scanf(ti) )
                {
                        if ( object_table[ti->tag].asdraw != NULL )
                        	(object_table[ti->tag].asdraw)(ti, doc, fh, x, y, fileoff, bb);
                }
        }
}

