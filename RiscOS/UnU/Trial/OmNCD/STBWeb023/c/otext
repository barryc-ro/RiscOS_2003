/* -*-c-*- */
/* CHANGE LOG

 *  8/5/96: SJM: added SUB and SUP.
 * 11/6/96: SJM: corrected underline position for SUB and SUP.
 * 13/6/96: SJM: added _update_highlight method.
 * 21/6/96: SJM: added boxing for selected text items.

 */

/* otext.c */

/* Methods for text objects */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "drawftypes.h"
#include "wimp.h"
#include "font.h"
#include "bbc.h"

#include "interface.h"
#include "antweb.h"
#include "rid.h"
#include "webfonts.h"
#include "consts.h"
#include "config.h"
#include "util.h"
#include "render.h"
#include "rcolours.h"

#include "object.h"
#include "version.h"
#include "dfsupport.h"

void otext_size(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
    rid_text_item_text *tit = (rid_text_item_text *) ti;
    font_string fs;
    struct webfont *wf;
    int len;

    wf = &webfonts[ti->st.wf_index];

    font_setfont(wf->handle);

    fs.x = 1 << 30;
    fs.y = 1 << 30;
    fs.split = -1;

    flexmem_noshift();
    fs.term = len = strlen(rh->texts.data + tit->data_off);
    fs.s = rh->texts.data + tit->data_off;
    font_strwidth(&fs);
    flexmem_shift();

    ti->pad = (fs.x / MILIPOINTS_PER_OSUNIT);

    fs.x = 1 << 30;
    fs.y = 1 << 30;
    fs.split = -1;

    flexmem_noshift();
    while(len && (rh->texts.data + tit->data_off)[len-1] == ' ')
	len--;
    fs.term = len;
    fs.s = rh->texts.data + tit->data_off;
    font_strwidth(&fs);
    flexmem_shift();

    ti->width = fs.x / MILIPOINTS_PER_OSUNIT;
    ti->pad -= ti->width;

    ti->max_up = wf->max_up;
    ti->max_down = wf->max_down;

    switch (ti->st.flags & (rid_sf_SUB|rid_sf_SUP))
    {
        case rid_sf_SUB:
            ti->max_down += wf->max_up/4;
            ti->max_up -= wf->max_up/4;
            break;

        case rid_sf_SUP:
            ti->max_down -= wf->max_up/2;
            ti->max_up += wf->max_up/2;
            break;
    }
}

static void draw_partial_box(BOOL first, BOOL last, int x, int y, int w, int h)
{
    if (first)
    {
        bbc_move(x, y);
        bbc_drawby(0, h);
    }
    else
        bbc_move(x, y + h);

    bbc_drawby(w, 0);

    if (last)
        bbc_drawby(0, - h);
    else
        bbc_moveby(0, - h);

    bbc_drawby(-w, 0);
}

void otext_redraw(rid_text_item *ti, rid_header *rh, antweb_doc *doc, int hpos, int bline, object_font_state *fs, wimp_box *g, int ox, int oy)
{
    rid_text_item_text *tit = (rid_text_item_text *) ti;
    int tfc;
    struct webfont *wf;
    int b;

    wf = &webfonts[ti->st.wf_index];

    if (fs->lf != wf->handle)
    {
	fs->lf = wf->handle;
	font_setfont(fs->lf);
    }

    if (fs->lfc != (tfc = render_text_link_colour(ti, doc) ) )
    {
	fs->lfc = tfc;
	render_set_font_colours(fs->lfc, render_colour_BACK, doc);
    }

#if 0
    fprintf(stderr, "rh = 0x%p, texts = 0x%p, data = 0x%p\n", rh, &(rh->texts), rh->texts.data);
#endif
    flexmem_noshift();

    // adjust base line for subscipts and superscripts
    b = bline;
    switch (ti->st.flags & (rid_sf_SUB|rid_sf_SUP))
    {
        case rid_sf_SUB:
            b -= wf->max_up/4;
            break;

        case rid_sf_SUP:
            b += wf->max_up/2;
            break;
    }
    font_paint(rh->texts.data + tit->data_off,
	       font_OSCOORDS + (config_display_blending ? 0x800 : 0), hpos, b);
#if 0
    fprintf(stderr, "'%s'\n", rh->texts.data + tit->data_off);
#endif
    flexmem_shift();

    if (ti->aref && ti->aref->href && (ti->flag & rid_flag_SELECTED))
    {
        BOOL first = ti->aref->first == ti;
        BOOL last = ti->next == NULL || ti->next->aref == NULL || ti->next->aref != ti->aref;
        BOOL first_in_line = ti == ti->line->first;
        BOOL last_in_line = ti->next == ti->line->next->first;
        int width = last || last_in_line ? ti->width : ti->width + ti->pad;
        int height = ti->max_up + ti->max_down - frontend_dy;

        first = first || first_in_line;
        last = last || last_in_line;

        if (fs->lfc != (tfc = render_link_colour(ti, doc) ) )
        {
	    fs->lfc = tfc;
	    render_set_colour(fs->lfc, doc);
	}

        draw_partial_box(first, last, hpos, b - ti->max_down, width, height);

#if ANTI_TWITTER
        if (first || first_in_line)
        {
            hpos += 2;
            width -= 2;
        }

        if (last || last_in_line)
            width -= 2;

        draw_partial_box(first, last, hpos, b - ti->max_down+2, width, height-4);
#endif
    }
    else if ((ti->st.flags & rid_sf_UNDERLINE) || ((doc->flags & doc_flag_UL_LINKS) && ti->aref && ti->aref->href) )
    {
        BOOL last = ti->next == ti->line->next->first;

	render_set_colour(fs->lfc, doc);
	bbc_move(hpos, b - 4);
	bbc_drawby(last ? ti->width : ti->width + ti->pad, 0);
#if ANTI_TWITTER
	bbc_move(hpos, b - 6);
	bbc_drawby(last ? ti->width : ti->width + ti->pad, 0);
#endif
    }
}

#if 0
void otext_dispose(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
}

char *otext_click(rid_text_item *ti, rid_header *rh, antweb_doc *doc, wimp_mousestr *m)
{
    return "";			/* Follow links, no fuss at all */
}
#endif

void otext_astext(rid_text_item *ti, rid_header *rh, FILE *f)
{
    rid_text_item_text *tit = (rid_text_item_text *) ti;

#if 0
    fprintf(stderr, "rh = 0x%p, texts = 0x%p, data = 0x%p\n", rh, &(rh->texts), rh->texts.data);
#endif
    flexmem_noshift();
    fputs(rh->texts.data + tit->data_off, f);
    flexmem_shift();
}

void otext_asdraw(rid_text_item *ti, antweb_doc *doc, int fh,
		  int x, int y, int *fileoff, wimp_box *bb)
{
    rid_text_item_text *tit = (rid_text_item_text *) ti;
    rid_header *rh = doc->rh;
    draw_textstrhdr txt;
    int len, l2;
    draw_textstyle dts = {0};
    int size;
    char zero[4] = {0,0,0,0};
    char *cp;
    wimp_box tb;

    flexmem_noshift();
    cp = rh->texts.data + tit->data_off;
    len = strlen(cp);
    while(len && cp[len-1] == ' ')
	len--;
    flexmem_shift();

    l2 = (len + 4) & (~3);

    size = (ti->st.wf_index & WEBFONT_SIZE_MASK) >> WEBFONT_SIZE_SHIFT;
    size = config_font_sizes[size];
    size *= 640;

    txt.tag = draw_OBJTEXT;
    txt.size = sizeof(txt) + l2;
    txt.bbox.x0 = x << 8;
    txt.bbox.y0 = (y - ti->max_down) << 8;
    txt.bbox.x1 = (x + ti->width) << 8;
    txt.bbox.y1 = (y + ti->max_up) << 8;
    txt.textcolour = (int) render_get_colour(render_link_colour(ti, doc), doc).word;
    txt.background = (int) render_get_colour(render_colour_BACK, doc).word;
    dts.fontref = (ti->st.wf_index & ((1 << WEBFONT_SIZE_SHIFT) - 1)) + 1;
    txt.textstyle = dts;
    txt.fsizex = size;
    txt.fsizey = size;
    txt.coord.x = x << 8;
    txt.coord.y = y << 8;

    tb.x0 = txt.bbox.x0 >> 8;
    tb.y0 = txt.bbox.y0 >> 8;
    tb.x1 = txt.bbox.x1 >> 8;
    tb.y1 = txt.bbox.y1 >> 8;

    df_stretch_bb(bb, &tb);

    df_write_data(fh, *fileoff, &txt, sizeof(txt));
    *fileoff += sizeof(txt);
    flexmem_noshift();
    df_write_data(fh, *fileoff, rh->texts.data + tit->data_off, len);
    flexmem_shift();
    *fileoff += len;
    df_write_data(fh, *fileoff, zero, l2 - len);
    *fileoff += l2-len;
}

void otext_update_highlight(rid_text_item *ti, antweb_doc *doc)
{
    wimp_box trim;
    memset(&trim, 0, sizeof(trim));

    trim.x1 = ti->pad + 2;
    antweb_update_item_trim(doc, ti, &trim, TRUE);
}

/* eof otext.c */
