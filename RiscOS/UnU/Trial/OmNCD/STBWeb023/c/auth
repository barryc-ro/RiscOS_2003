/* -*-c-*- */

/* auth.c */


/* CHANGE LOG
 *
 * 14/3/96: SJM: added auth_supported() call for access_find_realm
 */

/* Deal with user authentication.  We will keep this is a separate module
 * so that in the future we can cope with other simple authentication
 * protocols.  Trying to patch in the more sophisticated protocols that use
 * full-scale encryption of the data (not just of the authentication info)
 * will take a bit more work.  Authentication is only used on HTTP.  To
 * match an authentication we need to know the machine, the port and the
 * path.  We use a database that stores a pair of a triple and a pair:
 * ((machine, port, path), (name, passwd)).  We need a function that sets
 * an entry, a function the finds an entry and maybe one that removes it.
 * Setting an entry that already has an different setting overwrites as
 * this can only occur if the use has given an incorrect user,passwd pair.
 */

#ifndef DEBUG
#define DEBUG 0
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "memwatch.h"

#include "os.h"
#include "util.h"
#include "url.h"
#include "makeerror.h"
#include "config.h"

#include "auth.h"

extern int strcasecomp(char *s1, char *s2);
extern void translate_escaped_text(char *src, char *dest, int len);

typedef struct auth_realm {
    struct auth_realm *next, *prev;
    char *name;
    auth_type type;
    union {
	struct {
	    char *user;
	    char *passwd;
	} basic;
    } data;
} auth_realm;

typedef struct auth_item {
    struct auth_item *next, *prev;
    char *url;
    auth_realm *realm;
} auth_item;

typedef struct allow_item {
    union {
	unsigned int hash;
	char ch;
    } u;
    struct allow_item *next;
} allow_item;

static auth_realm *realm_first, *realm_last;
static auth_item *auth_first, *auth_last;

static allow_item *allow_list, *deny_list;

/* This needs to line up with the auth_type enum */
static char *auth_type_names[] = {
    "None",
    "Basic",
    "Pubkey",
    0
    };

static int auth_read_allow_file(char *fname, allow_item **head);
static int auth_test_allow(char *site, allow_item *list);


/* This function should read in a realm/method/data file */
void auth_init(void)
{
    realm_first = realm_last = NULL;
    auth_first = auth_last = NULL;

    auth_load_file(config_auth_file);

    allow_list = deny_list = NULL;

    if (config_allow_file)
	auth_read_allow_file(config_allow_file, &allow_list);

    if (config_deny_file)
	auth_read_allow_file(config_deny_file, &deny_list);
}

static int auth_get_type(char *type)
{
    int t;

    for (t=0; auth_type_names[t]; t++)
    {
        if (strcasecomp(auth_type_names[t], type) == 0)
            return t;
     }

    return -1;
}

int auth_supported(char *type)
{
    int t = auth_get_type(type);
    return t == auth_type_BASIC;
}

realm auth_add_realm(char *realm, char *type, char *user, char *passwd)
{
    auth_realm *a;
    int t;

    t = auth_get_type(type);

    if (t != auth_type_BASIC)
        return NULL;

    for(a = realm_first; a; a = a->next)
    {
	if (strcmp(realm, a->name) == 0)
	{
	    break;
	}
    }

    if (a == NULL)
    {
	a = mm_calloc(1, sizeof(*a));
	if (a == NULL)
	    return NULL;

	a->name = strdup(realm);

	if (realm_first)
	{
	    a->prev = realm_last;
	    realm_last->next = a;
	    realm_last = a;
	}
	else
	{
	    realm_first = realm_last = a;
	}
    }

    a->type = (auth_type) t;

    if (t == auth_type_BASIC)
    {
	if (a->data.basic.user)
	    mm_free(a->data.basic.user);
	a->data.basic.user = strdup(user);
	if (a->data.basic.passwd)
	    mm_free(a->data.basic.passwd);
	if (passwd)
	    a->data.basic.passwd = strdup(passwd);
	else
	    a->data.basic.passwd = NULL;
    }

    return a;
}

void auth_add(char *url, realm r)
{
    auth_item *a;

    for(a = auth_first; a; a = a->next)
    {
	if (strcmp(url, a->url) == 0)
	{
	    break;
	}
    }

    if (a == NULL)
    {
	a = mm_calloc(1, sizeof(*a));
	if (a == NULL)
	    return;

	a->url = strdup(url);

	if (auth_first)
	{
	    a->prev = auth_last;
	    auth_last->next = a;
	    auth_last = a;
	}
	else
	{
	    auth_first = auth_last = a;
	}
    }

    a->realm = r;

    return;
}

realm auth_lookup_realm(char *realm)
{
    auth_realm *a;
#if DEBUG
    fprintf(stderr, "Trying to look up realm '%s'... ", realm);
#endif
    for(a = realm_first; a; a = a->next)
    {
	if (strcmp(realm, a->name) == 0)
	{
#if DEBUG
	    fprintf(stderr, "Hit!\n");
#endif
	    return a;
	}
    }
#if DEBUG
    fprintf(stderr, "Miss.\n");
#endif
    return NULL;
}

/* Nasty lookup function just does a linear search.  One day I might do something better. */
auth_lookup_result auth_lookup(char *url, auth_type *type, char **user, char **passwd)
{
    auth_item *a;
#if DEBUG
    fprintf(stderr, "Trying to authorise URL='%s'\n", url);
#endif
    for(a = auth_first; a; a = a->next)
    {
	if (strncmp(url, a->url, strlen(a->url)) == 0)
	{
	    if (a->realm)
	    {
		*type = a->realm->type;
		*user = a->realm->data.basic.user;
		*passwd = a->realm->data.basic.passwd;
#if DEBUG
		fprintf(stderr, "Hit!\n");
#endif
		return auth_lookup_SUCCESS;
	    }
	    else
		return auth_lookup_NEED_DATA;
	}
    }
#if DEBUG
    fprintf(stderr, "Miss.\n");
#endif
    return auth_lookup_FAIL;
}

char *auth_lookup_string(char *url)
{
    auth_type type;
    char *user;
    char *passwd;
    char temp[256];
    static char buffer[256];

    if (auth_lookup(url, &type, &user, &passwd) == FALSE)
	return NULL;

    switch (type)
    {
    case auth_type_BASIC:
	sprintf(temp, "%s:%s", user, passwd);
	strcpy(buffer, "Basic ");
	uuencode(temp, buffer+6, sizeof(buffer)-6);
	break;
    default:
	fprintf(stderr, "Unknown auth type\n");
	strcpy(buffer, "UNKNOWN");
	break;
    }

    return buffer;
}

int auth_remove(char *url)
{
    return FALSE;
}

os_error *auth_write_realms(char *fname, auth_passwd_store pws)
{
    FILE *fh;
    auth_realm *rp;

    fh = fopen(fname, "w");

    if (fh == NULL)
	return makeerror(ERR_CANT_OPEN_AUTH_FILE);

#ifndef STBWEB
    fprintf(fh, "# Authorisation entries.\n# Realm name\tType\tuser\tpassword\n");
#endif

    for (rp = realm_first; rp; rp = rp->next)
    {
	char *escr, *escu = NULL, *escp = NULL;
	char uubuf[256];
	char *usep = "";
	char *type = NULL;


	escr = url_escape_chars(rp->name, " ");
	switch (rp->type)
	{
	case auth_type_BASIC:
	    type = auth_type_names[rp->type];
	    escu = url_escape_chars(rp->data.basic.user, " ");
	    escp = url_escape_chars(rp->data.basic.passwd, " ()");
	    break;
	}

	switch (pws)
	{
	case auth_passwd_NONE:
	    usep = "";
	    break;
	case auth_passwd_PLAIN:
	    usep = escp;
	    break;
	case auth_passwd_UUCODE:
	    uubuf[0] = '(';
	    uuencode(escp, uubuf+1, sizeof(uubuf) - 2);
	    strcat(uubuf, ")");
	    usep = uubuf;
	    break;
	}

	if (type)
	{
	    fprintf(fh, "%s\t%s\t%s\t%s\n", escr, type, escu, usep);
	}

	mm_free(escr);
	mm_free(escu);
	if (escp)
	    mm_free(escp);
    }

    fclose(fh);

    return NULL;
}

os_error *auth_load_file(char *fname)
{
    FILE *fh;
    char buffer[1024];

    fh = fopen(fname, "r");

    if (fh == NULL)
	return makeerror(ERR_CANT_OPEN_AUTH_FILE);

    while (!feof(fh))
    {
	if (fgets(buffer, sizeof(buffer), fh))
	{
	    char *r, *t, *u, *p;

	    r = strtok(buffer, " \t\n\r");
#if DEBUG
	    fprintf(stderr, "Read realm '%s'\n", r ? r : "<none>");
#endif
	    if (r && r[0] != '#')
	    {
		t = strtok(NULL, " \t\n\r");
		u = strtok(NULL, " \t\n\r");
		p = strtok(NULL, " \t\n\r");
#if DEBUG
		fprintf(stderr, "Type='%s', user='%s', passwd='%s'\n", t ? t : "<None>", u ? u : "<None>", p ? p : "<None>");
#endif
		if (t && u)
		{
		    unsigned char uucode[256];
		    char unescaped[256];

		    if (p && p[0] == '(')
		    {
			p[strlen(p)-1] = 0;
			uudecode(p+1, uucode, sizeof(uucode));
			p = (char *) uucode;
#if DEBUG
			fprintf(stderr, "Password uudecoded to '%s'\n", p);
#endif
		    }

		    translate_escaped_text(r, unescaped, sizeof(unescaped) );

		    auth_add_realm(unescaped, t, u, p);
		}
	    }
	}
    }

    fclose(fh);

    return NULL;
}

static int auth_read_allow_file(char *fname, allow_item **head)
{
    FILE *f;
    char buffer[256];

#if DEBUG
    fprintf(stderr, "Reading allow file '%s'\n", fname);
#endif

    f = fopen(fname, "r");

    if (f == NULL)
	return 0;

    while (!feof(f))
    {
	if (fgets(buffer, sizeof(buffer), f))
	{
	    char *p, *q;
	    allow_item *new;

	    p = strtok(buffer, " \t\n\r");
	    if (p == NULL || *p == '#' || *p == 0)
		continue;

	    for(q=p; *q; q++)
		*q = toupper(*q);

#if DEBUG
	    fprintf(stderr, "Addind list item '%s'\n", p);
#endif

	    new = mm_malloc(sizeof(*new) + strlen(p) + 1);
	    if (new)
	    {
		strcpy(&(new->u.ch) + 8, p);
		new->u.hash = string_hash(p);
		new->next = *head;
		*head = new;
	    }
	}
    }

    return 1;
}

static int auth_test_allow(char *site, allow_item *list)
{
    char buffer[256];
    unsigned int hash;
    char *p;

    p = strchr(site, '@');

    strcpy(buffer, p ? p+1 : site);

    p = strchr(buffer, ':');
    if (p)
	*p = 0;

    for(p=buffer; *p; p++)
	*p = toupper(*p);

#if DEBUG
    fprintf(stderr, "Checking site '%s'\n", buffer);
#endif

    hash = string_hash(buffer);

    while (list)
    {
#if DEBUG
	fprintf(stderr, "Testing against '%s'\n", &(list->u.ch) + 8);
#endif
	if ((list->u.hash == hash) && (strcmp(buffer, &(list->u.ch) + 8) == 0))
	    return 1;

	list = list->next;
    }

#if DEBUG
    fprintf(stderr, "No match\n");
#endif

    return 0;
}

int auth_check_allow_deny(char *site)
{
    if (config_allow_file)
	return auth_test_allow(site, allow_list);

    if (config_deny_file)
	return !auth_test_allow(site, deny_list);

    return 0;
}
