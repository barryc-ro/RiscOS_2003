/* -*-c-*- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "memwatch.h"

#include "wimp.h"
#include "msgs.h"
#include "font.h"
#include "swis.h"
#include "colourtran.h"
#include "bbc.h"
#include "print.h"
#include "visdelay.h"

#include "rid.h"
#include "antweb.h"
#include "webfonts.h"
#include "url.h"
#include "util.h"
#include "makeerror.h"
#include "images.h"

#include "status.h"

#include "filetypes.h"
#include "consts.h"
#include "object.h"
#include "auth.h"
#include "config.h"
#include "rcolours.h"

#include "interface.h"

#include "printing.h"

#ifndef DEBUG
#define DEBUG 1
#endif

#define MP2OS	(72000/180)

typedef struct _awp_job_str *awp_job;

/* Check pagination */
/* Given the scales page size (size/scale factor) return the number of pages in the document */
os_error *awp_check_pages(be_doc doc, int scale, int *pages);

os_error *awp_start_job(be_doc doc, int scale, int flags, awp_job *job);
os_error *awp_end_job(be_doc doc, awp_job job);

os_error *awp_render_page(be_doc doc, awp_job job, int page, int copies);	

struct _awp_job_str {
    print_pagesizestr psize;	/* Printer page size details */
    int job, oldjob;		/* File handles */
    awp_page_str *page;		/* The last page used */
    int page_no;		/* The number of the last page */
    int scale, flags;
    int pwidth, pheight;	/* The width and height of the paper in OS units */
    int old_doc_flags, old_bgt_flags;
    wimp_paletteword old_col_link, old_col_plain, old_col_back, old_col_cref;
};

os_error *awp_paginate(antweb_doc *doc, int plen, int flags);

static os_error *awp_open_printer(int *jobp)
{
    os_regset reg;
    os_error *ep;

    /* Open the printer: file */
    reg.r[0] = 0x80;  /* Output */
    reg.r[1] = (int) "Printer:";
    
    ep = os_find(&reg);

    if (ep == NULL)
	*jobp = reg.r[0];

    return ep;
}

static void awp_close_printer(int job)
{
    os_regset reg;
    
    reg.r[0] = 0;
    reg.r[1] = job;
    
    os_find(&reg);
}

static os_error *awp_old_render_page(antweb_doc *doc, awp_job job, int copies)
{
    wimp_box         box;
    int              more;
    wimp_redrawstr   r;
    awp_page_str *page;
    os_error *ep;

    /* Start to set up redraw struct for diagram */
    
#if DEBUG
    fprintf(stderr, "Calling drawpage, doc = 0x%08p\n", doc);
#endif
    ep = print_drawpage(copies, 0, 0, (print_box *) &box, &more, (int*) &page);
    if (ep)
	return ep;
    
#if DEBUG
    fprintf(stderr, "Page is 0x%08p, bounding box is: %d,%d,%d,%d\n", page, box.x0, box.y0, box.x1, box.y1);
#endif

    visdelay_percent((page->line->top * 100) / doc->rh->stream.height);

    /* Loop */
    while (more)
    {
#if DEBUG
	fprintf(stderr, "More data, page is 0x%08p, bounding box is: %d,%d,%d,%d\n", page, box.x0, box.y0, box.x1, box.y1);
#endif
	r.g = box;
	r.box.x0 = r.box.y0 = 0;
	r.scx = 0;
	r.box.x1 = job->pwidth;
#if 0
	r.box.y1 = job->pheight;
#else
	r.box.y1 = page->pheight;
#endif
	r.scy = page->line->top;

	backend_render_rectangle(&r, doc, 0);

#if DEBUG
	fprintf(stderr, "Getting next rectangle\n");
#endif
	/* Get next rectangle */
	print_getrectangle((print_box *) &box, &more, (int*) &page);
    }
    
#if DEBUG
    fprintf(stderr, "Done render\n");
#endif

    return ep;
}

void awp_free_pages(be_doc doc)
{
    awp_page_str *page, *p2;

    page = doc->paginate;
    while (page)
    {
	p2 = page->next;
	mm_free(page);
	page = p2;
    }

    doc->paginate = doc->last_page = NULL;
}

os_error *awp_paginate(antweb_doc *doc, int plen, int flags)
{
    awp_page_str *new;
    rid_pos_item *pi, *pi2;
    int page_top;

    if (doc->paginate)
	awp_free_pages(doc);

    pi = doc->rh->stream.pos_list;

    if (pi == NULL)
	return NULL;

    new = mm_calloc(1, sizeof(*new));
    new->doc = doc;
    new->line = pi;
    doc->paginate = doc->last_page = new;
    
    while(pi)
    {
	page_top = pi->top;

	pi2 = pi->next;

	while(pi2 && pi2->top > (page_top - plen))
	{
	    pi = pi2;
	    pi2 = pi2->next;
	}

	/* Three cases.  Either there are no more line (pi2 == NULL),
	   or the first line is longer than the page (new->line == pi) or
	   the line pi would not fit. */

	if (pi2 == NULL || new->line == pi)
	{
	    new->last = pi;
	    /* If we stopped because there was no more, or we stopped before we moved, move on */
	    pi = pi2;
	}
	else
	{
	    new->last = pi->prev;
	}

	new->pheight = (new->line->top - (new->last->top -
					  (new->last->max_up + new->last->max_down) ));

	new = mm_calloc(1, sizeof(*new));
	new->doc = doc;
	doc->last_page->next = new;
	new->prev = doc->last_page;
	doc->last_page = new;
	
	new->line = pi;
    }

    return NULL;
}

os_error *awp_check_pages(be_doc doc, int scale, int *pages)
{
    awp_page_str *page;
    int i;

    /* Every valid page has a first line pointer, the last page structure just marks the end */
    for (i=0,page = doc->paginate; page && page->line; i++, page = page->next)
	;

    *pages = i;

    return NULL;
}

os_error *awp_start_job(be_doc doc, int scale, int flags, awp_job *job)
{
    awp_job new;
    os_error *ep;
    int had_reformat = 0;

    new = mm_calloc(1, sizeof(*new));
    if (new == NULL)
	return makeerror(ERR_NO_MEMORY);

    visdelay_begin();
    
    new->scale = (scale << 16) / 100;
    new->flags = flags;

    ep = print_pagesize(&(new->psize));
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "Getting page size gave error '%s'\n", ep->errmess);
#endif
	goto err;
    }

    new->pwidth = (((new->psize.bbox.x1 - new->psize.bbox.x0 - (2000 * config_print_border)) *
		    100) /
		   (scale * MP2OS));
    new->pheight = (((new->psize.bbox.y1 - new->psize.bbox.y0 - (2000 * config_print_border)) *
		     100) /
		    (scale * MP2OS));

    if (flags & awp_print_SIDEWAYS)
    {
	int t;

	t = new->pheight;
	new->pheight = new->pwidth;
	new->pwidth = t;
    }

    doc->rh->stream.fwidth = new->pwidth;

    /* Reformat the the new paper width here */
    ep = antweb_document_format(doc, new->pwidth );
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "Reformat to page width gave error '%s'\n", ep->errmess);
#endif
	goto err;
    }
    had_reformat = 1;
    
    ep = awp_paginate(doc, new->pheight, 0);
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "paginate gave error '%s'\n", ep->errmess);
#endif
	goto err;
    }

    image_palette_change();

    /* Open printer file */
    ep = awp_open_printer(&new->job);
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "open printer gave error '%s'\n", ep->errmess);
#endif
	goto err;
    }
    
    /* Select job */
    ep = print_selectjob(new->job, doc->url, &new->oldjob);
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "Select job gave error '%s'\n", ep->errmess);
#endif
	goto err;
    }

#if DEBUG
    fprintf(stderr, "Declaring fonts\n");
#endif

    webfont_declare_printer_fonts();

    new->old_doc_flags = doc->flags;
    new->old_bgt_flags = doc->rh->bgt;

    new->old_col_link = config_colours[render_colour_AREF];
    new->old_col_cref = config_colours[render_colour_CREF];
    new->old_col_back = config_colours[render_colour_BACK];
    new->old_col_plain = config_colours[render_colour_PLAIN];

    if (flags & awp_print_NO_PICS)
	doc->flags |= doc_flag_NO_PICS;
    if (flags & awp_print_UNDERLINE)
	doc->flags |= doc_flag_UL_LINKS;
    else
	doc->flags &= ~doc_flag_UL_LINKS;
    if (flags & awp_print_NO_BACK)
	doc->rh->bgt &= ~(rid_bgt_COLOURS | rid_bgt_IMAGE | rid_bgt_FCOL | rid_bgt_LCOL);    
    if (flags & awp_print_NO_COLOUR)
    {
	config_colours[render_colour_AREF].word = 0;
	config_colours[render_colour_PLAIN].word = 0;
	config_colours[render_colour_CREF].word = 0;
	config_colours[render_colour_BACK].word = 0xffffff00;
    }
    doc->flags |= doc_flag_NO_FILL;

    *job = new;

    return NULL;

 err:
    /* What if we reformatted the text? */
    if (had_reformat)
    {
	fe_view_dimensions fvd;
	frontend_view_get_dimensions(doc->parent, &fvd);

	doc->rh->stream.fwidth = fvd.user_width;

	antweb_document_format(doc, fvd.user_width);
    }

    mm_free(new);
    return ep;
}

os_error *awp_end_job(be_doc doc, awp_job job)
{
    os_error *ep;
    fe_view_dimensions fvd;

    /* End job */
#if DEBUG
    fprintf(stderr, "Ending job\n");
#endif
    ep = print_endjob(job->job);
    if (ep)
    {
#if DEBUG
	fprintf(stderr, "Select job gave error '%s'\n", ep->errmess);
#endif
    }
    
    /* Close printer file */
#if DEBUG
    fprintf(stderr, "Closing file\n");
#endif
    awp_close_printer(job->job);

#if DEBUG
    fprintf(stderr, "Freeing pages\n");
#endif

    awp_free_pages(doc);
    
#if DEBUG
    fprintf(stderr, "Done printing!\n");
#endif

    doc->flags = job->old_doc_flags;
    doc->rh->bgt = job->old_bgt_flags;

    config_colours[render_colour_AREF] = job->old_col_link;
    config_colours[render_colour_CREF] = job->old_col_cref;
    config_colours[render_colour_BACK] = job->old_col_back;
    config_colours[render_colour_PLAIN] = job->old_col_plain;

    image_palette_change();

    mm_free(job);

    /* (Re)format to the display width */
    frontend_view_get_dimensions(doc->parent, &fvd);

    doc->rh->stream.fwidth = fvd.user_width;

    antweb_document_format(doc, fvd.user_width);

    visdelay_end();

    return ep;
}

os_error *awp_render_page(be_doc doc, awp_job job, int page, int copies)
{
    print_transmatstr  trans;
    print_positionstr  ppos;
    print_box pbox;
    os_error *ep;
    int bgcol;
    int yfix;
    int scale_pc = (job->scale * 100) >> 16;

    if (page != job->page_no)
    {
	fprintf(stderr, "Not a known page\n");

	if (job->page && page == (job->page_no + 1))
	{
	    fprintf(stderr, "Moving to the next page\n");
	    job->page_no++;
	    job->page = job->page->next;

	    if (job->page == NULL || job->page->next == NULL)
		return makeerror(ERR_BAD_PAGE);
	}
	else
	{
	    awp_page_str *pageptr;		/* The last page used */
	    int page_no;		/* The number of the last page */

	    fprintf(stderr, "Looking for the correct page\n");
	    
	    for(page_no = 1, pageptr = doc->paginate;
		page_no < page && pageptr && pageptr->line;
		page_no++, pageptr = pageptr->next)
	    {
#if DEBUG
		fprintf(stderr, "Looking for page %d, current page is %d at 0x%08p\n",
			page, page_no, pageptr);
#endif		
	    }
	    
	    if (page_no != page)
	    {
		return makeerror(ERR_BAD_PAGE);
	    }
	    
	    fprintf(stderr, "Page number %d is at 0x%08p\n", page_no, pageptr);
	    
	    job->page = pageptr;
	    job->page_no = page_no;
	}
    }

    pbox.x0 = 0;
    pbox.x1 = job->pwidth;
    pbox.y0 = 0;

    if (0)
    {
	pbox.y1 = job->pheight;
    }
    else
    {
	pbox.y1 = job->page->pheight;
    }

    /* In a bad worst case we have yfix can be the hight of the paper
     * in milipoints and the intermediate is 100 times this.  For A0
     * protrait this is 337,000,000 1/100ths of milipoints.  This does
     * not overflow a signed int. */

    yfix = (job->pheight - pbox.y1) * (scale_pc * MP2OS) / 100;

    if (job->flags & awp_print_SIDEWAYS)
    {
	trans.xx = 0;
	trans.xy = job->scale;
	trans.yx = -job->scale;
	trans.yy = 0;

	ppos.dx = job->psize.bbox.x1 - yfix - (1000 * config_print_border);
	ppos.dy = job->psize.bbox.y0 + (1000 * config_print_border);
    }
    else
    {
	trans.xx = job->scale;
	trans.xy = 0;
	trans.yx = 0;
	trans.yy = job->scale;

	ppos.dx = job->psize.bbox.x0 + (1000 * config_print_border);
	ppos.dy = job->psize.bbox.y0 + yfix + (1000 * config_print_border);
    }

#if DEBUG
    fprintf(stderr, "Giving rectangle:\n");
    fprintf(stderr, "Box = %d,%d,%d,%d\n", pbox.x0, pbox.y0, pbox.x1, pbox.y1 );
    fprintf(stderr, "Page position is %d,%d (%d,%d)\n", ppos.dx, ppos.dy, ppos.dx / MP2OS, ppos.dy / MP2OS);
    fprintf(stderr, "Page given is 0x%08p\n", job->page);
#endif

    bgcol = (job->flags & awp_print_NO_BACK) ?
	0xffffff00 : ((doc->rh->bgt & rid_bgt_COLOURS) ?
		      doc->rh->colours.back : (int) config_colours[render_colour_BACK].word);

    ep = print_giverectangle((int) job->page, &pbox, &trans, &ppos, bgcol);

    if (ep == NULL)
    {
	ep = awp_old_render_page(doc, job, copies);
#if DEBUG
	if (ep)
	    fprintf(stderr, "Render page gave error '%s'\n", ep->errmess);
#endif
    }

    return ep;
}

os_error *awp_print_document(be_doc doc, int scale, int flags, int copies)
{
    os_error *ep;
    int total_pages;
    awp_job job;
    int pfrom, pto;
    int inc, copy;
    int pageno;

    ep = awp_start_job(doc, scale, flags, &job);
    if (ep == NULL)
    {
	ep = awp_check_pages(doc, scale, &total_pages);
		    
	pfrom = 1;
	pto = total_pages;
		    
	/* @@@@ In here we need a whole stack of checks */
		    
	fprintf(stderr, "About to print doc 0x%08p, %d copies, from page %d to page %d, flags = 0x%02x\n",
		doc, copies, pfrom, pto, flags);
		    
	if (flags & awp_print_REVERSED)
	{
	    int t = pfrom;
	    
	    pfrom = pto;
	    pto = t - 1;
	    inc = -1;
	}
	else
	{
	    pto = pto + 1;
	    inc = 1;
	}
		    
	fprintf(stderr, "From %d to %d step %d\n", pfrom, pto, inc);
		    
	if (ep == NULL)
	{
	    for (copy = 0; ep == NULL && copy < ((flags & awp_print_COLLATED) ? copies : 1); copy++)
	    {
		for (pageno = pfrom; ep == NULL && pageno != pto; pageno += inc)
		{
		    fprintf(stderr, "About to print page %d\n", pageno);
		    
		    ep = awp_render_page(doc, job, pageno, (flags & awp_print_COLLATED) ? 1 : copies);
		}
	    }
	}			
	if (ep)
	    awp_end_job(doc, job);
	else
	    ep = awp_end_job(doc, job);
    }

    return ep;
}
