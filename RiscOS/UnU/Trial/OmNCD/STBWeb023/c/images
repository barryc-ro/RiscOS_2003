/* -*-c-*- */

/* Image cache for images in documents */

/*
 * 18/3/96: SJM: Added w and h parameters to image_render for scaling images
 * 21/3/96: SJM: changed webimage include, fixed wide_table bug with wimp_readpixtrans
 *  3/5/96: SJM: added display_scale use and changed unset tii->ww and hh to be -1 rather than 0
 * 18/6/96: NvS: Fixed scale-to-fit for non-square pixels.
 * 24/6/96: SJM: changed image callbacks to use #defines and extended progress to turn world.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "memwatch.h"

#include "os.h"
#include "sprite.h"
#include "wimp.h"
#include "bbc.h"
#include "swis.h"
#include "resspr.h"
#include "flex.h"
#include "visdelay.h"
#include "drawftypes.h"
#include "colourtran.h"
#include "alarm.h"

#include "images.h"
#include "access.h"

#include "status.h"

#include "util.h"
#include "makeerror.h"
#include "antweb.h"
#include "filetypes.h"
#include "config.h"
#include "rcolours.h"
#include "dfsupport.h"

#include "threads.h"
#include "version.h"

#ifndef NEW_WEBIMAGE
#define NEW_WEBIMAGE	1
#endif

#ifdef STBWEB
# if NEW_WEBIMAGE
#  include "libs/webimage/webimage.h"
# else
#  include "libs/webim_old/webimage.h"
# endif
#else
# include "../webimage/webimage.h"
#endif

#if !NEW_WEBIMAGE
# include "sprt2sprt.h"
#endif

/* Set debug to 2 or more for loads of detail on the image translation */
#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef FLEX
#define FLEX 1
#endif

#ifndef IMAGE_SCALE_TO_TAG
#define IMAGE_SCALE_TO_TAG 1
#endif

#define REAPER_POLL_TIME 500	/* Images arriving more than 5 seconds apart need to reload */

/*

 * In an HTML document an 'image' can be any objects fetched by a URL.
 * The object is usually some sort of displayable item like a .gif or
 * a .xbm file but it could just as well be a sounds file or an MPEG
 * movie.  Since images may be used several times within a document
 * (for example, a bitmap used for several bullet points), and since
 * when they are in sprite format an image may be rather large, it is
 * important to reuse image data wherever possible.  To this end
 * images have a reference count and the same image can be returned to
 * several users.

 * In this system an image is requested through the images subsystem
 * and is refered to by its URL.  At this time the image system is
 * given a function pointer and a data pointer for update callbacks.
 * The data pointer is usually the antweb_data for the document that
 * displays the image. for the document that wants to display the
 * image.  An image handle is returned and the image is reqested using
 * the access calls.  At any time the image handle can be used to
 * render the image onto the screen and to find out how large the
 * image is.  If the image has not been fetched the size and
 * appearance are that of a default icon.  If the image has been
 * fetched but it can not be draw (either because we have no converter
 * or because it is not a picture) then the size and appearance of the
 * file type icon is given.  If the appearance changes (for example
 * after a transfer is completed) then the function/data pointer pairs
 * are called to cause documents to be updated.  If a the same
 * function/data pointer pair is registered with the image more than
 * once it is only called once.

 */

typedef struct image_callback_str {
    int use_count;
    image_callback cb;
    void *h;
    struct image_callback_str *next;
} image_callback_str;

#define IMAGE_MAGIC 0x78e6b2c9

#if NEW_WEBIMAGE
typedef struct {
    int ftype;
} webimage_str;
#else
typedef char * (*webimage_start)(getsrc_func getsrc,
				 putdst_func putdst, seekdst_func seekdst, imagerec_func imrec,
				 void *user_get, void *user_put, BOOL blockdetail);

typedef struct {
    int ftype;
    webimage_start start;
} webimage_str;
#endif

typedef struct _image_info {
    int magic;
    struct _image_info *next, *prev;
    int use_count;
    char *url;
    char *ref;
    int data_so_far;
    int data_size;
    int file_load_addr;
    int file_exec_addr;
    unsigned int hash;
    char *cfile;
    int file_type;
    webimage_str *wi;
    image_flags flags;
    sprite_area **areap;
    sprite_area *our_area, *their_area, *cache_area;
    wimp_paletteword cache_bgcol;
    sprite_id id;
    char sname[12];		/* Used when we point to a file icon or the default icon */
    sprite_pixtrans *pt;	/* If non-NULL points to a pixel translation table */
    BOOL wide_table;
    int width, height;
    FILE *fh;			/* Used during reading the data */
    thread tt;
    int put_offset;
    image_callback_str *cblist;
    access_handle ah;
#if NEW_WEBIMAGE
    frame_rec *frame;
    int frames;
    int repeats;
    int cur_frame, cur_repeat;
    char errbuf[256];
#endif
} image_info_str;

#define wi_flag_MASK	0x01

static void image_fetch_next(void);

static image image_list, image_last;
static int being_fetched;

static int image_thread_data_size;
static char *image_thread_data_ptr;
static int image_thread_data_more;
static int image_thread_data_status;

static int image_white_byte(image im);

#if NEW_WEBIMAGE
static webimage_str translators[] = {
{ FILETYPE_SPRITE },
{ FILETYPE_GIF	},
{ FILETYPE_XBM	},
{ FILETYPE_JPEG	},
{ FILETYPE_PNG	},
{ FILETYPE_TIFF },
{ -1		}
};
#else
static webimage_str translators[] = {
{ FILETYPE_SPRITE,	&sprt2sprite	},
{ FILETYPE_GIF,		&gif2sprite	},
{ FILETYPE_XBM,		&xbm2sprite	},
{ FILETYPE_JPEG,	&jpg2sprite	},
#if 0
{ FILETYPE_PNG,		&png2sprite	},
#endif
{ -1, 			0		}
};
#endif

static im_gcf(int x, int y)
{
    int r;

    do
    {
	r = x % y;
	x = y;
	y = r;
    } while (y);

    return x;
}

static void image_reduce_scales(sprite_factors *facs)
{
    int r;

    r = im_gcf(facs->xmag, facs->xdiv);
    if (r != 1)
    {
	facs->xmag /= r;
	facs->xdiv /= r;
    }

    r = im_gcf(facs->ymag, facs->ydiv);
    if (r != 1)
    {
	facs->ymag /= r;
	facs->ydiv /= r;
    }

}


/*
 * If we have no data at all get some.
 * If we have more than enough return it with flag false.
 * If we have some or exactly enough return it with flag true.
 */

#if NEW_WEBIMAGE
static int new_image_get_bytes(char *buf, int buf_len, void *h, BOOL *flush)
{
    int rc;
#if DEBUG
    fprintf(stderr, "Asked for %d bytes, have %d bytes\n", buf_len, image_thread_data_size);
#endif
    if (image_thread_data_size == 0)
    {
	thread_wait("Need more data");
#if DEBUG
	fprintf(stderr, "Now have %d bytes\n", image_thread_data_size);
#endif
    }

    if (image_thread_data_size == 0)
	return -1;

    rc = (image_thread_data_size > buf_len) ? buf_len : image_thread_data_size;

    memcpy(buf, image_thread_data_ptr, rc);

    image_thread_data_ptr += rc;
    image_thread_data_size -= rc;

    *flush = (image_thread_data_size == 0);

    return rc;
}
#else
static int new_image_get_bytes(char *buf, int buf_len, void *h)
{
    int rc, data_back;

    if (image_thread_data_size >= buf_len)
    {
	memcpy(buf, image_thread_data_ptr, buf_len);
	image_thread_data_ptr += buf_len;
	image_thread_data_size -= buf_len;

	return buf_len;
    }

    rc = image_thread_data_size;
    if (image_thread_data_size)
    {
	memcpy(buf, image_thread_data_ptr, image_thread_data_size);
	buf += image_thread_data_size;
	buf_len -= image_thread_data_size;
    }

    do
    {
	thread_wait("Need more data");

	data_back = image_thread_data_size;

	if (data_back)
	{
	    int to_copy;

	    to_copy = (buf_len > image_thread_data_size) ? image_thread_data_size : buf_len;

	    memcpy(buf, image_thread_data_ptr, to_copy);
	    buf += to_copy;
	    buf_len -= to_copy;
	    image_thread_data_ptr += to_copy;
	    image_thread_data_size -= to_copy;

	    rc += to_copy;
	}

    } while (data_back && buf_len);

    return rc ? rc : -1;
}
#endif

static void image_put_bytes(char *buf, int buf_len, void *h)
{
    image i = (image) h;

#if DEBUG >= 2
    fprintf(stderr, "Putting 0x%x bytes at 0x%p to offset 0x%x\n", buf_len, buf, i->put_offset);
#endif

    if ( (i->put_offset + buf_len)  > i->our_area->size)
    {
	fprintf(stderr, "Too much image data: %x + %x > %x\n",
		i->put_offset, buf_len, i->our_area->size);
    }
    else
    {
	flexmem_noshift();
	memcpy(((char*) i->our_area) + i->put_offset, buf, buf_len);

	i->put_offset += buf_len;

	flexmem_shift();
    }

    if ((i->flags & image_flag_REALTHING) == 0)
    {
	int fill;

	i->areap = &(i->our_area);
	i->id.tag = sprite_id_name;
	i->id.s.name = i->sname;
	flexmem_noshift();
	strncpy(i->sname, ((sprite_header *) (i->our_area + 1))->name, 12);
	flexmem_shift();

	/* Fill with zero if we have no palette yet, use white if we can */
	fill = ((i->flags & image_flag_MASK) ?
		0 :		/* With a mask fill with zero */
		((i->put_offset < (sizeof(sprite_area) + sizeof(sprite_header))) ?
		 0xff :		/* Without a mask fill with 0xff */
		 image_white_byte(i)));	/* unless we can do better */

	flexmem_noshift();
	memset(((char*) i->our_area) + i->put_offset, fill, i->our_area->size - i->put_offset);
	flexmem_shift();

	if (i->pt)
	{
	    mm_free(i->pt);
	    i->pt = NULL;
	}

	i->flags |= image_flag_REALTHING/* | image_flag_RENDERABLE */;
#if DEBUG
	fprintf(stderr, "New sprite area at %p, sprite name %s, width = %d, height = %d\n",
		i->our_area, i->id.s.name, i->width, i->height);
#endif
    }

    /* only set renderable bit when palette has arrived */
    if ((i->flags & image_flag_RENDERABLE) == 0)
    {
        sprite_header *sph = (sprite_header *) ((char *)i->our_area + i->our_area->sproff);
        int pal_end = sph->mask > sph->image ? sph->mask : sph->image;

        if (i->put_offset >= sizeof(sprite_area) + pal_end)
        {
            i->flags |= image_flag_RENDERABLE;

	    if (i->pt)
	    {
	        mm_free(i->pt);
	        i->pt = NULL;
	    }
        }
    }

    i->flags |= image_flag_CHANGED;
}

static void image_seek_fn(int pos, void *h)
{
    image i = (image) h;

    i->put_offset = 16 + pos;
#if DEBUG >= 2
    fprintf(stderr, "Seeking to offset %d, put_offset=0x%x\n", pos, i->put_offset);
#endif
}

static BOOL image_rec_fn(image_rec *ir, void *h)
{
    image i = (image) h;
    int size;

#if DEBUG >= 2
    fprintf(stderr, "Given image_rec\n");
#endif

    size = ir->size;

    if (i->our_area)
    {
	int OK;

	OK = flex_extend((flex_ptr) &(i->our_area), size + 16);

	if (OK)
	{
#if NEW_WEBIMAGE
	    i->our_area->number = ir->frames;
#else
	    i->our_area->number = 1;
#endif
	    i->our_area->size = size+16;
	    i->our_area->freeoff = size + 16;
	}

	return OK;
    }

    i->width = ir->x;
    i->height = ir->y;

    if (ir->interlaced)
	i->flags |= image_flag_INTERLACED;

    if (ir->mask)
	i->flags |= image_flag_MASK;

#if FLEX
    if (flex_alloc((flex_ptr) &(i->our_area), size + 16) == FALSE)
    {
	fprintf(stderr, "Failed to get memory for image\n");
	i->flags |= (image_flag_ERROR | image_flag_CHANGED);
	return FALSE;
    }
#if DEBUG
    else
    {
	fprintf(stderr, "Flex alloc for %d bytes gave ptr %p\n", size+16, i->our_area);
    }
#endif
#else
    i->our_area = mm_malloc(size + 16);

    if (i->our_area == NULL)
    {
	fprintf(stderr, "Failed to get memory for image\n");
	return FALSE;
    }
#if DEBUG
    else
    {
	fprintf(stderr, "Malloc for %d bytes gave ptr %p\n", size+16, i->our_area);
    }
#endif
#endif

    memset(i->our_area, 0, sizeof(sprite_area) + sizeof(sprite_header));

    i->our_area->size = size+16;
    i->our_area->number = 1;
    i->our_area->sproff = 16;
    i->our_area->freeoff = size + 16;
#if DEBUG >= 2
    fprintf(stderr, "Sprite area is %d bytes at %p\n", size+16, i->our_area);
#endif

    i->put_offset = 16;

#if DEBUG >= 2
    fprintf(stderr, "have info; x=%d, y=%d\n", ir->x, ir->y);
#endif

    return TRUE;
}

static void image_set_error(image i)
{
    i->flags |= (image_flag_ERROR | image_flag_CHANGED);
    i->flags &= ~image_flag_RENDERABLE;

    i->their_area = resspr_area(); /* Wimp sprite area */
    i->areap = &(i->their_area);
    strcpy(i->sname, "sprerror");
    i->id.tag = sprite_id_name;
    i->id.s.name = i->sname;

    if (i->pt)
	mm_free(i->pt);
    i->pt = NULL;
}

static int bastard_main(int argc, char **argv)
{
#if NEW_WEBIMAGE == 0
    webimage_start start;
#endif
    char *result;
    void *i;
#if DEBUG
    fprintf(stderr, "Bastard_main called\n");
#endif

    i = (void *) argv;

#if NEW_WEBIMAGE
    result = img2sprite(&new_image_get_bytes,	/* Get bytes from source */
			&image_put_bytes,	/* Put bytes to dest */
			&image_seek_fn,	/* Seek to where to put bytes */
			&image_rec_fn,	/* Tell us about the image */
			i, i,		/* Handles for get and put */
			(((((image)i)->flags & image_flag_NO_BLOCKS) ? 0 : webimage_BLOCKDETAIL) +
			 (config_deep_images ? webimage_DEEPSPRITE : 0) ),
			((image)i)->errbuf);	/* Flags */

#else
    start = (webimage_start) ((int*)argc);
    result = start(&new_image_get_bytes,	/* Get bytes from source */
		   &image_put_bytes,	/* Put bytes to dest */
		   &image_seek_fn,	/* Seek to where to put bytes */
		   &image_rec_fn,	/* Tell us about the image */
		   i, i,		/* Handles for get and put */
		   (((((image)i)->flags & image_flag_NO_BLOCKS) ? 0 : webimage_BLOCKDETAIL) +
		    (config_deep_images ? webimage_DEEPSPRITE : 0) ) );	/* Flags */
#endif

#if DEBUG
    fprintf(stderr, "Bastard_main done\n");
#endif
    return (int) result;
}

static int image_thread_start(image i)
{
#if DEBUG
    fprintf(stderr, "About to start thread\n");
#endif
    image_thread_data_size = 0;
    image_thread_data_ptr = 0;
    image_thread_data_more = 0;
    image_thread_data_status = 0;
#if NEW_WEBIMAGE
    i->tt = thread_start(&bastard_main, 0, (char**) i, 4096);
#else
    i->tt = thread_start(&bastard_main, (int) i->wi->start, (char**) i, 4096);
#endif
#if DEBUG || 1
    fprintf(stderr, "New thread 0x%p\n", i->tt);
#endif
    return (i->tt != 0);
}

static int image_thread_process(image i, int fh, int from, int to)
{
    os_gbpbstr gpb;
    char buffer[4096];
    int len;

    while (from < to && i->tt->status == thread_ALIVE)
    {
#if DEBUG
	fprintf(stderr, "Loading some data\n");
#endif
	len = (to-from) > sizeof(buffer) ? sizeof(buffer) : (to-from);

	gpb.action = 3;
	gpb.file_handle = fh;
	gpb.data_addr = buffer;
	gpb.number = len;
	gpb.seq_point = from;
#if DEBUG >= 2
	fprintf(stderr, "Reading %d bytes from file %d.\n", len, fh);
#endif
	if (os_gbpb(&gpb) == NULL)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Sending %d bytes to the image thread.\n", len);
#endif
	    image_thread_data_size = len;
	    image_thread_data_ptr = buffer;
	    image_thread_data_more = ((from + len) < to);
#if DEBUG
	    fprintf(stderr, "Running thread again\n");
#endif
	    thread_run(i->tt);
	}

	from += len;
    }

    return (i->tt->status == thread_ALIVE);
}

static char *image_thread_end(image i)
{
    char *res;

    /* Call once to flush out any data in buffers */
    if (i->tt->status == thread_ALIVE)
    {
	image_thread_data_size = 0;
	image_thread_data_ptr = 0;
	image_thread_data_more = 0;
	thread_run(i->tt);
    }

    /* Call again to make sure we have stopped */
    if (i->tt->status == thread_ALIVE)
    {
	image_thread_data_size = 0;
	image_thread_data_ptr = 0;
	image_thread_data_more = 0;
	thread_run(i->tt);
    }

    if (i->tt->status == thread_ALIVE)
	res = "Thread did not finnish";
    else
	res = (char *) i->tt->rc;

    /* Clear up the thread */

    fprintf(stderr, "About to destroy thread 0x%p\n", i->tt);
    thread_destroy(i->tt);

    i->tt = NULL;

    return res;
}


static char *image_process(image i, char *cfile)
{
    int fh;
    os_regset r;
    os_error *ep;
    char *res;

    r.r[0] = 0x4f;
    r.r[1] = (int) cfile;

    ep = os_find(&r);
    if (ep)
	return ep->errmess;


    fh = r.r[0];

    i->flags |= image_flag_NO_BLOCKS;

    if (image_thread_start(i))
    {
	int size;

	r.r[0] = 2;
	r.r[1] = fh;
	r.r[2] = 0;

	os_args(&r);

	size = r.r[2];

	image_thread_process(i, fh, 0, (size>>1) );
	image_thread_process(i, fh, (size>>1), size );

	fprintf(stderr, "Calling image_thread_end() from image_process()\n");

	res = image_thread_end(i);
    }
    else
    {
	res = "Could not make thread";
    }

    r.r[0] = 0;
    r.r[1] = fh;

    os_find(&r);

    return res;
}

static char *image_process_to_end(image i, char *cfile)
{
    int fh;
    os_regset r;
    os_error *ep;
    char *res;
    int size;

    r.r[0] = 0x4f;
    r.r[1] = (int) cfile;

    ep = os_find(&r);
    if (ep)
	return ep->errmess;

    fh = r.r[0];

    r.r[0] = 2;
    r.r[1] = fh;
    r.r[2] = 0;

    os_args(&r);

    size = r.r[2];

    image_thread_process(i, fh, i->data_so_far, size );

    fprintf(stderr, "Calling image_thread_end() from image_process_to_end()\n");

    res = image_thread_end(i);

    r.r[0] = 0;
    r.r[1] = fh;

    os_find(&r);

    return res;
}

#if NEW_WEBIMAGE == 0
static webimage_str *image_lookup_wi(int ft)
{
    webimage_str *wi;

    for (wi = translators; wi->ftype != -1; wi++)
    {
	if (wi->ftype == ft)
	    break;
    }

    return (wi->ftype == -1) ? NULL : wi;
}
#endif

static void image_progress(void *h, int status, int size, int so_far, int fh, int ftype, char *url)
{
    image i = (image) h;
    BOOL more_data;

#if DEBUG
    fprintf(stderr, "Image progress in...\n");
#endif

    if (so_far == -1)
	so_far = 0;

    i->flags &= ~(image_flag_CHANGED);

    more_data = (i->data_so_far != so_far);
    if (more_data)
    {
	if (status == status_GETTING_BODY)
	{
#if NEW_WEBIMAGE == 0
	    if (i->wi == NULL)
	    {
		i->wi = image_lookup_wi(ftype);
	    }
#endif

#if NEW_WEBIMAGE
	    if (i->tt == NULL)
#else
	    if (i->tt == NULL && i->wi)
#endif
	    {
		i->flags &= ~image_flag_NO_BLOCKS;
		i->file_type = ftype;
		image_thread_start(i);
	    }
#if DEBUG
	    fprintf(stderr, "Data arriving; file=%d, last had %d, now got %d\n",
		    fh, i->data_so_far, so_far);
#endif
	    if (i->tt)
	    {
		image_thread_process(i, fh, i->data_so_far, so_far);
	    }
	}

	i->data_so_far = so_far;
	i->data_size = size;
    }

        /* SJM: always call callbacks so that world turns */
	if (i->cblist)
	{
	    image_callback_str *cb = i->cblist;
	    while (cb)
	    {
		int changed = (i->flags & image_flag_CHANGED) ? image_cb_status_UPDATE : more_data ? image_cb_status_WORLD : image_cb_status_NOACTION;
#if DEBUG
		fprintf(stderr, "Callback, handle=0x%p, uses=%d, next=0x%p, changed=%d\n",
			cb->h, cb->use_count, cb->next, changed);
#endif
		if (cb->cb && (cb->use_count > 0))
		    cb->cb(cb->h, (void*) i, changed);
		cb = cb->next;
	    }
	}

#if DEBUG
    fprintf(stderr, "...image progress out.\n");
#endif

}

static access_complete_flags image_completed(void *h, int status, char *cfile, char *url)
{
    int ft;
    image i = (image) h;
    char *err;

    being_fetched--;		/* I guess we should do this even if the handle is broken */
#if DEBUG
    fprintf(stderr, "Decremented fetching count, now %d\n", being_fetched);
#endif

    image_fetch_next();

    if (i->magic != IMAGE_MAGIC)
	return 0;

    i->ah = NULL;

    if (status == status_COMPLETED_FILE)
    {
	os_filestr ofs;

	i->cfile = strdup(cfile);
	i->flags |= image_flag_FETCHED;

	i->file_type = ft = file_type(cfile);

	ofs.action = 5;
	ofs.name = i->cfile;
	os_file(&ofs);

	i->file_load_addr = ofs.loadaddr;
	i->file_exec_addr = ofs.execaddr;
	i->data_size = ofs.start;

#if DEBUG
	fprintf(stderr, "Got the image file '%s', type 0x%03x\n", cfile, ft);
#endif

#if NEW_WEBIMAGE == 0
	if (i->wi == NULL)
	{
	    i->wi = image_lookup_wi(ft);
	}

	if (i->wi)
#endif
	{
	    visdelay_begin();

	    if (i->tt)
	    {
		err = image_process_to_end(i, cfile);
	    }
	    else
	    {
		err = image_process(i, cfile);
	    }

	    visdelay_end();

	    if (err == NULL)
		i->flags |= image_flag_RENDERABLE;
	    else
	    {
		fprintf(stderr, "Image error 1 = %s (%s)\n", err, cfile);

		if ((i->flags & image_flag_RENDERABLE) == 0)
		{
		    if (i->our_area)
		    {
#if DEBUG
			fprintf(stderr, "Freeing area from %p\n", i->our_area);
#endif
#if FLEX
			flex_free((flex_ptr) &i->our_area);
#else
			mm_free(i->our_area);
#endif
			i->our_area = NULL;
		    }
		    image_set_error(i);
		}
	    }
	}
    }

    if ((i->flags & image_flag_FETCHED) == 0)
    {
	image_set_error(i);

	fprintf(stderr, "Image access completed with error status: %d\n", status);
    }

    if (i->flags & image_flag_WAITING) /* Waitiong flag is still set if we came from the cache */
    {
	i->flags &= ~(image_flag_WAITING | image_flag_DEFERRED);
    }
    else
    {
	if (i->cblist)
	{
	    image_callback_str *cb = i->cblist;
	    while (cb)
	    {
		if (cb->cb && (cb->use_count > 0))
		    cb->cb(cb->h, (void*) i, image_cb_status_UPDATE);
		cb = cb->next;
	    }
	}
    }

    /* @@@@ Fire up the animation process here */

#if DEBUG
    fprintf(stderr, "Returning from image completed function\n");
#endif
    return (access_CACHE | access_KEEP); /* Cache the file and try to hold on to it */
}

// ----------------------------------------------------------

#ifdef STBWEB

static void *cooler_table = NULL;
static BOOL use_cooling = TRUE;

void image_get_cooler_table(void)
{
    FILE *f;
    f = fopen("<STBWeb$Dir>.Tab<TV$Type>", "rb");
    if (f)
    {
        if (flex_alloc(&cooler_table, 64*1024))
            fread(cooler_table, 64*1024, 1, f);
        else
            fprintf(stderr, "Failed to load cooler file\n");

        fclose(f);
    }
else
    fprintf(stderr, "Failed to open cooler file\n");
}

void image_toggle_cooling(void)
{
    use_cooling = !use_cooling;
}

static void image_cool_table(void *pt, int log2bpp)
{
    if (cooler_table && use_cooling)
    {
        int i, n_cols = 1 << (1 << log2bpp);

        short *tp = cooler_table;
        short *pp = pt;

fprintf(stderr, "img: Fixed up table size %d\n", n_cols);

        for (i = 0; i < n_cols; i++, pp++)
        {
            *pp = tp[*pp];
        }
    }
}

#endif

// ----------------------------------------------------------

int spriteextend_version;

void image_poll_reaper(int at, void *h)
{
#if 0
    imgreaper();
#endif
    alarm_set(alarm_timenow()+REAPER_POLL_TIME, image_poll_reaper, h);
}

os_error *image_init(void)
{
#if DEBUG
    fprintf(stderr, "Starting image code with debug enabled\n");
#endif
    image_list = image_last = NULL;
    being_fetched = 0;

    os_cli("Set "PROGRAM_NAME"$Temp 99");
    os_cli("RMEnsure SpriteExtend 0.99 Set "PROGRAM_NAME"$Temp 61");
    spriteextend_version = atoi(getenv(PROGRAM_NAME"$Temp"));

    image_poll_reaper(0, (void *) translators);	/* Use translators' address as a safe handle */

    return NULL;
}

os_error *image_tidyup(void)
{
    image i, ii;

    fprintf(stderr, "Image tidyup called\n");

    for (i=image_list; i != NULL; i = ii)
    {
#if DEBUG
	fprintf(stderr, "Disposing image at 0x%p, url = '%s'\n", i, i->url ? i->url : "<none>");
#endif

	if (i->ah)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Image tidyup Aborting access\n");
#endif
	    access_abort(i->ah);
	    being_fetched--;
	}

	if (i->url)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Dealing with URL\n");
#endif
	    access_unkeep(i->url);
	    mm_free(i->url);
	}

	if (i->ref)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Dealing with ref\n");
#endif
	    access_unkeep(i->ref);
	    mm_free(i->ref);
	}

	if (i->tt)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Ending thread\n");
#endif
	    fprintf(stderr, "Calling image_thread_end() from image_tidyup()\n");

	    image_thread_end(i);
	}

	if (i->pt)
	{
#if DEBUG >= 2
	    fprintf(stderr, "Freeing pixtrans table\n");
#endif
	    mm_free(i->pt);
	}

	ii = i->next;
	mm_free(i);
    }

    /* Remove the reaper function */
    alarm_removeall((void*) translators);

#if DEBUG
    fprintf(stderr, "Tidied up images\n");
#endif

    return NULL;
}

void image_palette_change(void)
{
    image i;

    for (i=image_list; i != NULL; i = i->next)
    {
	if (i->pt)
	{
	    mm_free(i->pt);
	    i->pt = NULL;
	}

        if (i->cache_area)
        {
#if FLEX
            flex_free((flex_ptr)&i->cache_area);
#else
            mm_free(i->cache_area);
#endif
            i->cache_area = NULL;
        }
    }
}

static void image_fetch_next(void)
{
    image i;

#if DEBUG
    fprintf(stderr, "Scaning image list\n");
#endif
    for (i=image_list; (being_fetched < config_max_files_fetching) && (i != NULL); i = i->next)
    {
	/* Pick ones that are waiting and not deferred */
	if ((i->flags & (image_flag_WAITING | image_flag_DEFERRED)) == image_flag_WAITING)
	{
	    os_error *ep;
	    int reload;

	    reload = (i->flags & image_flag_TO_RELOAD) ? access_NOCACHE : 0;

	    i->flags &= ~(image_flag_WAITING | image_flag_TO_RELOAD);

	    being_fetched++;	/* In case it comes from the cache we increment this here */
#if DEBUG
	    fprintf(stderr, "Incremented fetching count, now %d\n", being_fetched);
#endif
	    ep = access_url(i->url, reload, 0, 0, i->ref,
			    &image_progress, &image_completed, i, &(i->ah));

	    if (ep)
	    {
		i->ah = NULL;
		image_set_error(i);
		fprintf(stderr, "Error accessing image: %s\n", ep->errmess);
		being_fetched--; /* If we failed, decrement it again */
	    }
	}
    }
}

BOOL image_type_test(int ft)
{
    int i;

    for(i=0; translators[i].ftype != -1; i++)
    {
	if (translators[i].ftype == ft)
	    return TRUE;
    }

    return FALSE;
}

static os_error *find_area_and_info(image i, sprite_info *info)
{
    os_error *e;
    e = sprite_readsize(*i->areap, &i->id, info);
    if (e)
    {
        os_regset r;
        os_swix(Wimp_BaseOfSprites, &r);
        i->their_area = (sprite_area *)r.r[1];
        e = sprite_readsize(*i->areap, &i->id, info);
        if (e)
        {
            i->their_area = (sprite_area *)r.r[0];
            e = sprite_readsize(*i->areap, &i->id, info);
        }
    }
    return e;
}

static os_error *image_find_icontype(image i)
{
    char *path = strchr(i->url, ':') + 1;
    sprite_info info;
    os_error *e;

    i->sname[0] = 0;
    if (path[0] == ',')
    {
	sprintf(i->sname, "small_%s", path+1);
    }
    else if (path[0] == '.')
    {
	int ft = suffix_to_file_type(path+1);

	sprintf(i->sname, "small_%03x", ft == -1 ? 0xfff : ft);
    }
    else if (strcasecomp(path, "directory") == 0)
    {
	strcpy(i->sname, "small_dir");
    }

    if (i->sname[0])
    {
        /* look for file type icon */
        e = find_area_and_info(i, &info);
        if (e)
        {
            /* default to unknown file type */
            strcpy(i->sname, "small_xxx");
            e = find_area_and_info(i, &info);
        }
    }
    else
    {
        /* look for other icon */
	strcpy(i->sname, path);
	strcat(i->sname, "icon");

        e = find_area_and_info(i, &info);
        if (e)
        {
    	    strcpy(i->sname, path);
            e = find_area_and_info(i, &info);
        }
    }

    if (e)
    {
#if DEBUG
        fprintf(stderr, "find icontype: e '%s'\n", e->errmess);
#endif
        image_set_error(i);
        return e;
    }

    i->flags = image_flag_FETCHED | image_flag_RENDERABLE | image_flag_REALTHING;
    i->file_type = 0xff9;

    i->width = info.width;
    i->height = info.height;

    if (info.mask)
	i->flags |= image_flag_MASK;

    // do the callbacks
    if (i->cblist)
    {
	image_callback_str *cb = i->cblist;
	while (cb)
	{
	    if (cb->cb && (cb->use_count > 0))
	        cb->cb(cb->h, (void*) i, image_cb_status_UPDATE);
	    cb = cb->next;
	}
    }
    return NULL;
}

os_error *image_find(char *url, char *ref, int flags, image_callback cb, void *h, image *result)
{
    image i;
    unsigned int hash;
    image_callback_str *cbs;
    os_error *ep;

#if DEBUG
    fprintf(stderr, "Asked to find image '%s'\n", url);
#endif
    hash = string_hash(url);

    for(i = image_list; i != NULL; i = i->next)
    {
	if (i->hash == hash && strcmp(i->url, url) == 0)
	    break;
    }

    if (i)
    {
	i->use_count++;
	if ((flags & image_find_flag_DEFER) == 0 &&
	    (i->flags & image_flag_DEFERRED) != 0 )
	{
	    i->flags &= ~image_flag_DEFERRED;
	}
    }
    else
    {
#if DEBUG
	fprintf(stderr, "Making new image\n");
#endif
	i = mm_calloc(1, sizeof(*i));

	if (image_list)
	{
	    i->prev = image_last;
	    image_last->next = i;
	    image_last = i;
	}
	else
	{
	    image_list = image_last = i;
	}

	i->magic = IMAGE_MAGIC;
	i->use_count = 1;
	i->url = strdup(url);
	i->hash = hash;
	i->flags = image_flag_WAITING;
	if (flags & image_find_flag_DEFER)
	    i->flags |= image_flag_DEFERRED;
	i->their_area = resspr_area(); /* Wimp sprite area */
	i->areap = &(i->their_area);
	strcpy(i->sname, (flags & image_find_flag_DEFER) ? "deferred" : "unknown");
	i->id.tag = sprite_id_name;
	i->id.s.name = i->sname;
	i->width = 68;
	i->height = 68;
    }

    /* Use the first ref we see */
    if (ref && i->ref == NULL)
	i->ref = strdup(ref);

    *result = i;

    if (cb)
    {
	cbs = i->cblist;

	while (cbs && ((cb != cbs->cb) || (h != cbs->h)) )
	{
	    cbs = cbs->next;
	}

	if (cbs)
	{
	    cbs->use_count++;
	}
	else
	{
	    image_callback_str *new;

	    new = mm_calloc(1, sizeof(*new));
	    if (new)
	    {
		new->use_count = 1;
		new->cb = cb;
		new->h = h;

		new->next = i->cblist;
		i->cblist = new;
	    }
	}
    }

    ep = NULL;
    if (strncmp(url, "icontype:", sizeof("icontype:")-1) == 0)
    {
        ep = image_find_icontype(i);
    }
    else if ((i->cfile == NULL) &&
	(i->ah == NULL) &&
	((i->flags & (image_flag_ERROR | image_flag_STREAMING )) == 0) )
    {
	if (access_test_cache(url))
	{
	    being_fetched++;

	    /* If the file is already around then we don't care if it was deferred, do we? */
	    i->flags &= ~(image_flag_WAITING | image_flag_DEFERRED);

	    ep = access_url(url, 0, 0, 0, i->ref, &image_progress, &image_completed, i, &(i->ah));
	    if (ep)
	    {
		i->ah = NULL;
		image_set_error(i);
		fprintf(stderr, "Error accessing image: %s\n", ep->errmess);

		being_fetched--;
	    }
	}
	else
	{
#if DEBUG
	    fprintf(stderr, "Calling image_fetch_next()\n");
#endif
	    image_fetch_next();
	}
    }

    return ep;
}

/* Image_stream does NOT increment the use count.  This is done when the image is sized */
os_error *image_stream(char *url, int ft, int *already, image *result)
{
    image i;
    unsigned int hash;

#if DEBUG
    fprintf(stderr, "Making stream for image '%s'\n", url);
#endif
    hash = string_hash(url);

    for(i = image_list; i != NULL; i = i->next)
    {
	if (i->hash == hash && strcmp(i->url, url) == 0)
	    break;
    }

    if (!i)
    {
#if DEBUG
	fprintf(stderr, "Making new image\n");
#endif
	i = mm_calloc(1, sizeof(*i));

	if (image_list)
	{
	    i->prev = image_last;
	    image_last->next = i;
	    image_last = i;
	}
	else
	{
	    image_list = image_last = i;
	}

	/* i->flags does NOT get a waiting flag */
	i->magic = IMAGE_MAGIC;
	i->use_count = 0;
	i->url = strdup(url);
	i->hash = hash;
	i->their_area = resspr_area(); /* Wimp sprite area */
	i->areap = &(i->their_area);
	strcpy(i->sname, "unknown");
	i->id.tag = sprite_id_name;
	i->id.s.name = i->sname;
	i->width = 68;
	i->height = 68;
    }

    *result = i;

    if ((i->cfile == NULL) &&
	(i->ah == NULL) &&
	((i->flags & (image_flag_ERROR | image_flag_STREAMING)) == 0) )
    {
	*already = FALSE;
	i->flags |= image_flag_STREAMING;
	i->file_type = ft;
#if NEW_WEBIMAGE == 0
	i->wi = image_lookup_wi(ft);
#endif
	i->flags &= ~image_flag_NO_BLOCKS;
	image_thread_start(i);
    }
    else
    {
	*already = TRUE;
    }

    return NULL;
}

os_error *image_stream_data(image i, char *buffer, int len, int update)
{
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    i->flags &= ~(image_flag_CHANGED);

    if (i->tt && i->tt->status == thread_ALIVE)
    {
	image_thread_data_size = len;
	image_thread_data_ptr = buffer;
	image_thread_data_more = !update;

#if DEBUG
	fprintf(stderr, "Running thread from stream data\n");
#endif
	thread_run(i->tt);
    }

    i->data_so_far += len;
    i->data_size = -1;

    if (update && i->cblist)
    {
	image_callback_str *cb = i->cblist;
	while (cb)
	{
	    int changed = (i->flags & image_flag_CHANGED) ? image_cb_status_UPDATE : image_cb_status_NOACTION;
#if DEBUG
	    fprintf(stderr, "Callback, handle=0x%p, uses=%d, next=0x%p, changed=%d\n",
		    cb->h, cb->use_count, cb->next, changed);
#endif
	    if (cb->cb && (cb->use_count > 0))
		cb->cb(cb->h, (void*) i, changed);
	    cb = cb->next;
	}
    }

    return NULL;
}

os_error *image_stream_end(image i, char *cfile)
{
    char *res;
    os_filestr ofs;

    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    if (i->tt)
    {
	fprintf(stderr, "Calling image_thread_end() from image_stream_end()\n");

	res = image_thread_end(i);
    }
    else
    {
	res = "No thread to end";
    }

    i->flags |= image_flag_FETCHED;
    i->flags &= ~image_flag_STREAMING;

    if (cfile)
    {
	i->cfile = strdup(cfile);
	ofs.action = 5;
	ofs.name = i->cfile;
	os_file(&ofs);

	i->file_load_addr = ofs.loadaddr;
	i->file_exec_addr = ofs.execaddr;
	i->data_size = ofs.start;
    }

    if (res == NULL)
	i->flags |= image_flag_RENDERABLE;
    else
    {
	fprintf(stderr, "Image error 2 = %s\n", res);

	if (i->our_area)
	{
#if DEBUG
	    fprintf(stderr, "Freeing area from %p\n", i->our_area);
#endif
#if FLEX
	    flex_free((flex_ptr) &i->our_area);
#else
	    mm_free(i->our_area);
#endif
	    i->our_area = NULL;
	}
	image_set_error(i);
    }

    if (cfile && i->cblist)
    {
	image_callback_str *cb = i->cblist;
	while (cb)
	{
	    if (cb->cb && (cb->use_count > 0))
		cb->cb(cb->h, (void*) i, image_cb_status_UPDATE);
	    cb = cb->next;
	}
    }

    /* @@@@ Fire up the animation process here */

    return NULL;
}

os_error *image_loose(image i, image_callback cb, void *h)
{
    image_callback_str *cbs, *cbs2, **link;

    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

#if DEBUG
    fprintf(stderr, "Loose image called: '%s', use count %d\n", i->url ? i->url : "", i->use_count);
#endif

    link = &(i->cblist);
    cbs = i->cblist;
    while (cbs && ((cb != cbs->cb) || (h != cbs->h)) )
    {
	link = &(cbs->next);
	cbs = cbs->next;
    }

    if (cbs)
    {
	cbs->use_count--;
	if (cbs->use_count == 0)
	{
	    *link = cbs->next;
	    mm_free(cbs);
	}
    }

    i->use_count--;

    if (i->use_count == 0)
    {
#if DEBUG
	fprintf(stderr, "Use count now zero\n");
#endif
	cbs = i->cblist;
	while (cbs)
	{
	    cbs2 = cbs->next;
	    mm_free(cbs);
	    cbs = cbs2;
	}

	if (i->tt)
	{
	    fprintf(stderr, "Calling image_thread_end() from image_loose()\n");
	    image_thread_end(i);
	}

	if (i->ref)
	    mm_free(i->ref);

	if (i->url)
	{
	    if (i->ah)
	    {
#if DEBUG
		fprintf(stderr, "Loose image Aborting access\n");
#endif
		access_abort(i->ah);
		being_fetched--;
	    }
	    else
	    {
#if DEBUG
		fprintf(stderr, "Unkeeping the file\n");
#endif
		access_unkeep(i->url);
	    }
#if DEBUG
	    fprintf(stderr, "Freeing URL\n");
#endif
	    mm_free(i->url);
	}

	if (i->our_area)
	{
#if FLEX
	    flex_free((flex_ptr) &i->our_area);
#else
	    mm_free(i->our_area);
#endif
#if DEBUG
	    fprintf(stderr, "Freed area from %p\n", i->our_area);
#endif
	}

	if (i->cache_area)
	{
#if FLEX
	    flex_free((flex_ptr) &i->cache_area);
#else
	    mm_free(i->cache_area);
#endif
#if DEBUG
	    fprintf(stderr, "cache Freed area from %p\n", i->cache_area);
#endif
	}

	if (i->cfile)
	{
#if DEBUG
	    fprintf(stderr, "Freeing file name\n");
#endif
	    mm_free(i->cfile);
	}

#if DEBUG
	fprintf(stderr, "Unlinking from linked list\n");
#endif
	if (i->next)
	    i->next->prev = i->prev;
	else
	    image_last = i->prev;

	if (i->prev)
	    i->prev->next = i->next;
	else
	    image_list = i->next;

	if (i->pt)
	    mm_free(i->pt);

	i->magic = 0;
#if DEBUG
	fprintf(stderr, "Freeing image object\n");
#endif
	mm_free(i);
    }

#if DEBUG
    fprintf(stderr, "Loose image done\n");
#endif

    return NULL;
}

int image_memory_panic(void)
{
    image i;
    int freed = FALSE;

    fprintf(stderr, "Image memory panic called\n");

    for (i=image_list; i != NULL; i = i->next)
    {
	/* If we already have the image then dispose of it */
	if (i->our_area)
	{
	    freed = TRUE;
#if DEBUG
	    fprintf(stderr, "Need to dispose of the old image\n");
#endif
#if FLEX
	    flex_free((flex_ptr) &i->our_area);
#else
	    mm_free(i->our_area);
#endif
#if DEBUG
	    fprintf(stderr, "Freed area from %p\n", i->our_area);
#endif
	    i->our_area = NULL;

            if (i->cache_area)
            {
#if FLEX
	        flex_free((flex_ptr) &i->cache_area);
#else
	        mm_free(i->cache_area);
#endif
#if DEBUG
	        fprintf(stderr, "Freed cache area from %p\n", i->cache_area);
#endif
	        i->cache_area = NULL;
	    }

	    if (i->cfile)
	    {
#if DEBUG
		fprintf(stderr, "Freeing file name\n");
#endif
		mm_free(i->cfile);
		i->cfile = NULL;
	    }

	    if (i->pt)
	    {
		mm_free(i->pt);
		i->pt = NULL;
	    }

	    i->data_so_far = i->data_size = 0;
	    i->file_type = 0;
	    i->flags = image_flag_WAITING | image_flag_DEFERRED | image_flag_TO_RELOAD;
	    i->their_area = resspr_area(); /* Wimp sprite area */
	    i->areap = &(i->their_area);
	    strcpy(i->sname, "deferred");
	    i->id.tag = sprite_id_name;
	    i->id.s.name = i->sname;
	}
    }

    return freed;
}

os_error *image_flush(image i, int flags)
{
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    if (i->tt)
    {
	fprintf(stderr, "Calling image_thread_end() from image_flush()\n");
	image_thread_end(i);
    }

    if (i->url)
    {
	if (i->ah)
	{
#if DEBUG
	    fprintf(stderr, "Flush image Aborting access\n");
#endif
	    access_abort(i->ah);
	    being_fetched--;
	    i->ah = NULL;
	}
	else
	{
#if DEBUG
	    fprintf(stderr, "Unkeeping the file\n");
#endif
	    access_unkeep(i->url);
	}

	access_remove(i->url);
    }

    if (i->flags & image_flag_ERROR)
    {
	i->flags &= ~image_flag_ERROR;
	i->flags |= image_flag_TO_RELOAD | image_flag_WAITING;
    }

    /* If we already have the image then dispose of it */
    if (i->our_area)
    {
#if DEBUG
	fprintf(stderr, "Need to dispose of the old image\n");
#endif
#if FLEX
	flex_free((flex_ptr) &i->our_area);
#else
	mm_free(i->our_area);
#endif
#if DEBUG
	fprintf(stderr, "Freed area from %p\n", i->our_area);
#endif
	i->our_area = NULL;
	if (i->cache_area)
	{
#if FLEX
	    flex_free((flex_ptr) &i->cache_area);
#else
	    mm_free(i->cache_area);
#endif
#if DEBUG
	    fprintf(stderr, "Freed cache area from %p\n", i->cache_area);
#endif
	    i->cache_area = NULL;
	}

	if (i->cfile)
	{
#if DEBUG
	    fprintf(stderr, "Freeing file name\n");
#endif
	    mm_free(i->cfile);
	    i->cfile = NULL;
	}

	if (i->pt)
	{
	    mm_free(i->pt);
	    i->pt = NULL;
	}

	i->data_so_far = i->data_size = 0;
	i->file_type = 0;
	i->flags = image_flag_WAITING;
	i->flags |= image_flag_TO_RELOAD;
	i->their_area = resspr_area(); /* Wimp sprite area */
	i->areap = &(i->their_area);
	strcpy(i->sname, (flags & image_find_flag_DEFER) ? "deferred" : "unknown");
	i->id.tag = sprite_id_name;
	i->id.s.name = i->sname;

	if (i->cblist)
	{
	    image_callback_str *cb = i->cblist;
	    while (cb)
	    {
		if (cb->cb && (cb->use_count > 0))
		    cb->cb(cb->h, (void*) i, image_cb_status_UPDATE);
		cb = cb->next;
	    }
	}

    }

    if (flags & image_find_flag_DEFER)
	i->flags |= image_flag_DEFERRED;
    else
	i->flags &= ~image_flag_DEFERRED;

    /* Move the image to the front of the queue if we're not already */
    if (i->prev != NULL)
    {
#if DEBUG
	fprintf(stderr, "Moving the image to the front of the queue\n");
#endif
	if (i->next)
	    i->next->prev = i->prev;
	else
	    image_last = i->prev;

	i->prev->next = i->next;

	/* We were not the front of the queue before so there must be something in the queue */

	i->next = image_list;
	i->prev = NULL;
	image_list->prev = i;
	image_list = i;
    }

    /* Have a go at forcing it to be fetched.  If we fail (too busy) at least we will be next */

    if ((flags & image_find_flag_DEFER) == 0)
    {
#if DEBUG
	fprintf(stderr, "Calling for another fetch\n");
#endif
	image_fetch_next();
    }

    return NULL;
}

os_error *image_mark_to_flush(image i, int flags)
{
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    i->flags |= image_flag_TO_RELOAD;
    if (flags & image_find_flag_DEFER)
	i->flags |= image_flag_DEFERRED;

    return NULL;
}

os_error *image_flush_marked(void)
{
    image ii, ii2;

    ii = image_list;

    while (ii)
    {
	ii2 = ii->next;

	if (ii->flags & image_flag_TO_RELOAD)
	{
	    image_flush(ii, (ii->flags & image_flag_DEFERRED) ? image_find_flag_DEFER : 0);
	}

	ii = ii2;
    }

    return NULL;
}

os_error *image_data_size(image i, image_flags *flags, int *data_so_far, int *data_size)
{
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    if (flags)
	*flags = i->flags;
    if (data_so_far)
	*data_so_far = i->data_so_far;
    if (data_size)
	*data_size = i->data_size;

    return NULL;
}

os_error *image_file_info(image i, int *load, int *exec, int *size)
{
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    if (load)
	*load = i->file_load_addr;
    if (exec)
	*exec = i->file_exec_addr;
    if (size)
	*size = i->data_size;

    return NULL;
}

os_error *image_info(image i, int *width, int *height, int *bpp, image_flags *flags, int *filetype, char **url)
{
    os_error *ep = NULL;
    sprite_header *sph;
    int ex, ey, l2bpp;
    int lbit;

#if DEBUG
    fprintf(stderr, "Asked for image info\n");
#endif
    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	return makeerror(ERR_BAD_IMAGE_HANDLE);
    }

    if (width || height || bpp)
    {
	flexmem_noshift();

	if (i->id.tag == sprite_id_name)
	    ep = sprite_select_rp(*(i->areap), &(i->id), (sprite_ptr *) &sph);
	else
	    sph = (sprite_header *) i->id.s.addr;

#if DEBUG
	fprintf(stderr, "Sprite is at 0x%p, mode value is 0x%x\n", sph, sph ? sph->mode : 0);
#endif

	ex = bbc_modevar(sph->mode, bbc_XEigFactor);
	ey = bbc_modevar(sph->mode, bbc_YEigFactor);
	l2bpp = bbc_modevar(sph->mode, bbc_Log2BPP);

	if (ep)
	{
	    fprintf(stderr, "Error: %s\n", ep->errmess);
	}
	else
	{
	    lbit = (sph->mode > 255) ? 0 : sph->lbit;

	    if (width)
		*width = (((((sph->width+1) << 5) - lbit - (31 - sph->rbit)) >> l2bpp ) << ex);
	    if (height)
		*height = ((sph->height+1) << ey);
	    if (bpp)
		*bpp = 1 << l2bpp;
	}

	flexmem_shift();
    }

    if (flags)
	*flags = i->flags;
    if (filetype)
	*filetype = i->file_type;
    if (url)
	*url = i->url;

#if DEBUG
    fprintf(stderr, "Returning, width=%d, height=%d, flags=0x%x\n", width ? *width : 0, height ? *height : 0, flags ? *flags : 0);
#endif

    return ep;
}

static void fixup_scale(sprite_factors *facs, int scale_image)
{
    if (scale_image != 100)
    {
        facs->xmag *= scale_image;
        facs->xdiv *= 100;
        facs->ymag *= scale_image;
        facs->ydiv *= 100;
    }
}

void image_render(image i, int x, int y, int w, int h, int scale_image)
{
    os_error *ep = NULL;
    sprite_pixtrans *pt = NULL;
    sprite_factors facs;
    sprite_header *sph;
    sprite_area *area;
    sprite_id id;
    os_regset r;
    char buffer[12];
    BOOL wide_table;

#if DEBUG
    fprintf(stderr, "Asked to render image handle 0x%p at %d,%d\n", i, x, y);
#if DEBUG >= 2
    fprintf(stderr, "Sprite area is 0x%p, image pointer is 0x%p, name is %s\n",
	    *(i->areap), i->id.s.name, i->id.tag == sprite_id_name ? i->id.s.name : "<none>");
#endif
#endif

    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	fprintf(stderr, "Bad magic\n");
	return;
    }

    flexmem_noshift();

    wide_table = FALSE;

    if ( (i->flags & (image_flag_FETCHED | image_flag_RENDERABLE)) == image_flag_FETCHED)
    {
	sprintf(buffer, "file_%03x", i->file_type);

	ep = os_swix(Wimp_BaseOfSprites, &r);

	area = (sprite_area *) r.r[1];

	id.tag = sprite_id_name;
	id.s.name = buffer;

	ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);

	if (ep)
	{
	    area = (sprite_area *) r.r[0];
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	}

	if (ep)
	{
	    strcpy(buffer, "file_xxx");
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	}

	if (ep == 0)
	{
	    pt = mm_malloc(16);
	    id.tag = sprite_id_addr;
	    id.s.addr = sph;

	    ep = wimp_readpixtrans(area, &id, &facs, pt);
            if (!ep) fixup_scale(&facs, scale_image);
	}
    }
    else
    {
	area = *(i->areap);
	id = i->id;
	if (id.tag == sprite_id_name)
	{
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	    id.s.addr = sph;
	    id.tag = sprite_id_addr;
	}
	else
	    sph = (sprite_header *) id.s.addr;

	if (ep)
	{
	    fprintf(stderr, "Error1: %s\n", ep->errmess);
	    goto wayout;
	}

	if (i->pt == NULL)
	{
	    int sprite_log2bpp = bbc_modevar(sph->mode, bbc_Log2BPP);
	    /* If it is 16 colours or less and no palette use a WIMP palette */
#if 0
	    fprintf(stderr, "Pix trans table. bpp=%d, mask %x, image %x (sprite header %x)\n",
		    bbc_modevar(sph->mode, bbc_Log2BPP),
		    sph->mask, sph->image,
		    sizeof(sprite_header));
#endif
	    if ((sprite_log2bpp <= 2) &&
		((sph->mask == sizeof(sprite_header)) ||
		 (sph->image == sizeof(sprite_header)) ) )
	    {
#if 0
		fprintf(stderr, "Using WIMP table\n");
#endif
		pt = mm_malloc(16);

		ep = wimp_readpixtrans(area, &id, &facs, pt);
	    }
	    else
	    {
                int table_size;

		r.r[0] = (int) area;
		r.r[1] = (int) sph;
		r.r[2] = -1;
		r.r[3] = -1;
		r.r[4] = 0;
		r.r[5] = (1 << 0);
		if (spriteextend_version >= 99)
		    r.r[5] |= (1 << 4);   /* SJM: allow wide tables */

		ep = os_swix(ColourTrans_GenerateTable, &r);

		if (ep)
		{
		    fprintf(stderr, "Error2: %s\n", ep->errmess);
		    goto wayout;
		}

#if DEBUG >= 2
		fprintf(stderr, "About to mm_malloc %d bytes for pixel translation\n", r.r[4]);
#endif

		pt = mm_malloc(r.r[4]);
		if (pt == NULL)
		{
		    fprintf(stderr, "Malloc failed\n");
		    goto wayout;
		}

                /* SJM: check and see if a wide table was returned */
		wide_table = (r.r[4] >> (1 << sprite_log2bpp)) > 1;

#if 0
                table_size = r.r[4];
                fprintf(stderr, "table size %d bytes wide=%d\n", r.r[4], wide_table);
#endif

		r.r[4] = (int) pt;

#if 0
            {
                int j;
                for (j = 0; j <= 5; j++)
                    fprintf(stderr, "r%d=%8d (&%08x)\n", j, r.r[j], r.r[j]);
            }
#endif

                r.r[6] = r.r[7] = 0;
		ep = os_swix(ColourTrans_GenerateTable, &r);

#if 0
		if (ep)
		{
		    fprintf(stderr, "%x %s\n", ep->errnum, ep->errmess);
		}
		else
		{
		    int j, pal;

		    fprintf(stderr, "** header\n");
		    for (j = 0; j < sizeof(sprite_header); j += 4)
			fprintf(stderr, "%08x \n", *(int *)((char *)sph+j));

		    pal = sph->mask < sph->image ? sph->mask : sph->image;
		    if (pal != sizeof(sprite_header))
		    {
			fprintf(stderr, "** palette\n");
			for (j = sizeof(sprite_header); j < pal; j += 4)
			    fprintf(stderr, "%08x \n", *(int *)((char *)sph+j));
		    }

		    fprintf(stderr, "** pixtrans\n");
		    for (j = 0; j < table_size; j+=4)
			fprintf(stderr, "%08x \n", *(int *)(pt+j));
		}
#endif
#if 0
                if (!ep && wide_table && sprite_log2bpp < 4 && bbc_modevar(-1, bbc_Log2BPP) == 4 )
                    image_cool_table(pt, sprite_log2bpp);
#endif
	    }

	    i->pt = pt;
	    i->wide_table = wide_table;
	}
	else
	{
	    pt = i->pt;
	    wide_table = i->wide_table;
	}

	facs.xmag = 1 << bbc_modevar(sph->mode, bbc_XEigFactor);
	facs.xdiv = 1 << bbc_modevar(-1, bbc_XEigFactor);
	facs.ymag = 1 << bbc_modevar(sph->mode, bbc_YEigFactor);
	facs.ydiv = 1 << bbc_modevar(-1, bbc_YEigFactor);

#if IMAGE_SCALE_TO_TAG
        if ((i->flags & image_flag_REALTHING) && (w != -1 || h != -1))
        {
            double aspect = ((double)i->width * facs.xmag)/((double)i->height * facs.ymag);
            int ww, hh;
	    int dw, dh;

	    /* Web pages are described in terms of 90 dpi images so we need to adjust */

	    dw = i->width * facs.xmag / 2;
	    dh = i->height * facs.ymag / 2;

	    ww = w != -1 ? w : (int)(h * aspect);
	    hh = h != -1 ? h : (int)(w / aspect);

            facs.xmag *= ww;
            facs.xdiv *= dw;
            facs.ymag *= hh;
            facs.ydiv *= dh;
        }
        else
            fixup_scale(&facs, scale_image);
#else
        fixup_scale(&facs, scale_image);
#endif
    }

    image_reduce_scales(&facs);

    if (ep)
    {
	fprintf(stderr, "Error3: %s\n", ep->errmess);
	goto wayout;
    }

    ep = sprite_put_scaled(area, &id,
        (i->flags & image_flag_MASK ? 0x8 : 0) | (wide_table ? 0x20 : 0), x, y, &facs, pt);

    if (pt && pt != i->pt)	/* Only free it if you have not remembered it */
    {
#if DEBUG >= 2
	fprintf(stderr, "About to free pixel translation table\n");
#endif
	mm_free(pt);
    }

 wayout:
    flexmem_shift();
}

// ------------------------------------------------------------------------------------------

#define MAX_CACHE_BYTES (32*1024)

static int cceil(int top, int bottom)
{
    return (top + bottom - 1)/bottom;
}

struct os_mode_selector
   {  int flags;
      int xres;
      int yres;
      int log2_bpp;
      int frame_rate;
   };

static int get_mode_number(void)
{
    int mode;
    if (os_swi2r(os_X|OS_ScreenMode, 1, 0, 0, &mode) != NULL)
    {
        os_regset r;
        r.r[0] = 135;
        os_swix(OS_Byte, &r);
        mode = r.r[2];
    }

    if ((unsigned)mode > 255)
    {
        struct os_mode_selector *m = (struct os_mode_selector *)mode;
        mode = 1 + (m->log2_bpp+1)*0x08000000 +
            (180 >> bbc_modevar(-1, bbc_YEigFactor))*0x00004000 +
            (180 >> bbc_modevar(-1, bbc_XEigFactor))*0x00000002;
    }

#if 1
fprintf(stderr, "img: current sprite mode %08x\n", mode);
#endif

    return mode;
}

#define CACHE_SPRITE_NAME   "cache"

static BOOL image_build_cache_sprite(image i, int scale_image)
{
    int i_w, c_w, i_h, c_h;
    int bpp, size;
    sprite_id id;
    os_error *e;

    int i_w_os, c_w_os, i_h_os, c_h_os;
    sprite_factors facs;

    sprite_id our_id;
    sprite_header *our_sph;

    // we assume that if it has become invalidated we will have already
    // disposed of it
    if (i->cache_area)
        return TRUE;

#if 0
fprintf(stderr, "img: building cache sprite orig size %dx%d bg %x\n", i->width, i->height, i->cache_bgcol.word);
#endif

    // get the size of out cache image, use up to MAX_CACHE_BYTES on it
    i_w = i->width*scale_image/100;
    c_w = i_w*cceil(128, i_w);

    bpp = 1 << bbc_modevar(-1, bbc_Log2BPP);

    i_h = i->height*scale_image/100;
    c_h = i_h * cceil(MAX_CACHE_BYTES*8, i_h*c_w*bpp);

    size = ((c_w*bpp + 31)/32)*4*c_h;
    size += sizeof(sprite_header) + sizeof(sprite_area);

#if 0
fprintf(stderr, "img: scaled input %dx%d cache %dx%d size %d bytes\n", i_w, i_h, c_w, c_h, size);
#endif

    // allocate and init sprite area
#if FLEX
    if (flex_alloc((flex_ptr) &(i->cache_area), size) == FALSE)
#else
    if ((i->cache_area = mm_malloc(size)) == NULL)
#endif
    {
	fprintf(stderr, "Failed to get memory for cached image\n");
	return FALSE;
    }

    sprite_area_initialise(i->cache_area, size);

    // create sprite
    id.tag = sprite_id_addr;
    e = sprite_create_rp(i->cache_area, CACHE_SPRITE_NAME, sprite_nopalette, c_w, c_h, get_mode_number(), &id.s.addr);

    // get original sprite details
    our_id = i->id;
    if (our_id.tag == sprite_id_name)
    {
	e = sprite_select_rp(*i->areap, &our_id, (sprite_ptr *) &our_sph);
	our_id.s.addr = our_sph;
	our_id.tag = sprite_id_addr;
    }
    else
	our_sph = (sprite_header *) our_id.s.addr;

    // do main plot into cache sprite
    i_w_os = c_w_os = i_h_os = c_h_os = 0;
    if (!e)
    {
        sprite_state state;
        e = sprite_outputtosprite(i->cache_area, &id, NULL, &state);
        if (!e)
        {
            sprite_pixtrans *pt;
            BOOL wide_table;
            os_regset r;
            int table_size;

            // clear background if masked image
            if (i->flags & image_flag_MASK)
            {
                int junk;
                colourtran_setGCOL(i->cache_bgcol, (1<<8) | (1<<7), 0, &junk);
                bbc_clg();
            }

            // get plot details
            pt = NULL;
            wide_table = FALSE;

       	    r.r[0] = (int) *i->areap;
            r.r[1] = (int) our_sph;
            r.r[2] = -1;
            r.r[3] = -1;
    	    r.r[4] = 0;
    	    r.r[5] = (1 << 0);
            if (spriteextend_version >= 99)
    	        r.r[5] |= (1 << 4);   // SJM: allow wide tables

    	    e = os_swix(ColourTrans_GenerateTable, &r);
            if (!e)
            {
                table_size = r.r[4];
        	pt = malloc(r.r[4]);
                wide_table = (r.r[4] >> (1 << bbc_modevar(our_sph->mode, bbc_Log2BPP))) > 1;

    	        r.r[4] = (int) pt;
    	        e = os_swix(ColourTrans_GenerateTable, &r);
            }
            if (!e)
            {
                int p, q, flags;

                facs.xmag = 1 << bbc_modevar(our_sph->mode, bbc_XEigFactor);
                facs.xdiv = 1 << bbc_modevar(-1, bbc_XEigFactor);
                facs.ymag = 1 << bbc_modevar(our_sph->mode, bbc_YEigFactor);
                facs.ydiv = 1 << bbc_modevar(-1, bbc_YEigFactor);

                // get os sizes
                i_w_os = i_w*facs.xmag;
                i_h_os = i_h*facs.ymag;
                c_w_os = c_w*facs.xdiv;
                c_h_os = c_h*facs.ydiv;

                // adjust for display_scale
                fixup_scale(&facs, scale_image);

		image_reduce_scales(&facs);

                flags = (i->flags & image_flag_MASK ? 0x8 : 0) | (wide_table ? 0x20 : 0);
                for (q = 0; q < c_h_os; q += i_h_os)
	            for (p = 0; p < c_w_os; p += i_w_os)
                        sprite_put_scaled(*i->areap, &our_id, flags, p, q, &facs, pt);
            }

            // discard pixtrans here
            free(pt);
            sprite_restorestate(state);

#if 0
            fprintf(stderr, "img: os sizes in %d,%d out %d,%d\n", i_w_os, i_h_os, c_w_os, c_h_os);
            fprintf(stderr, "img: factors %d/%d %d/%d\n", facs.xmag, facs.xdiv, facs.ymag, facs.ydiv);
            fprintf(stderr, "img: pixtrans pt %p size %d wide %d\n", pt, table_size, wide_table);

            {
                int j;
                for (j = 0; j < table_size; j+=4)
                    fprintf(stderr, "%08x \n", *(int *)(pt+j));
            }
#endif
        }
#if 0
    fprintf(stderr, "img: plot main\n");
#endif
    }

    // tidy up
    if (!e)
    {
#if 0
        sprite_area_save(i->our_area, "<STBWeb$Dir>.^.in");
        sprite_area_save(i->cache_area, "<STBWeb$Dir>.^.out");
#endif
    }
    else
    {
#if FLEX
        flex_free((flex_ptr)&i->cache_area);
#else
        mm_free(i->cache_area);
#endif
        i->cache_area = NULL;

        fprintf(stderr, "img: error building cache sprite %x %s\n", e->errnum, e->errmess);
    }

    return e == NULL;
}

// ------------------------------------------------------------------------------------------

void image_tile(image i, int x, int y, wimp_box *bb, wimp_paletteword bgcol, int scale_image)
{
    sprite_id id;
    sprite_info info;
    int minp, minq, p, q, width, height;

#if 0
    fprintf(stderr, "Asked to tile image handle 0x%p at %d,%d\n", i, x, y);
#endif

    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	fprintf(stderr, "Bad magic\n");
	return;
    }

    if (i->flags & (image_flag_FETCHED | image_flag_RENDERABLE) != (image_flag_FETCHED | image_flag_RENDERABLE))
	return;

    flexmem_noshift();

    // if we have a mask and the bgcol changes then dispose of cache sprite
    if (bgcol.word != i->cache_bgcol.word)
    {
        if ((i->flags & image_flag_MASK) && i->cache_area)
        {
#if 1
    fprintf(stderr, "img: bgcol changed - discarding cached image\n");
#endif
            flex_free((flex_ptr)&i->cache_area);
            i->cache_area = NULL;
        }
        i->cache_bgcol = bgcol;
    }

    // build cache sprite if not in existence
    // if it fails then draw the background colour
    if (!image_build_cache_sprite(i, scale_image))
    {
        int junk;
        colourtran_setGCOL(bgcol, (1<<8) | (1<<7), 0, &junk);
        bbc_move(bb->x0, bb->y0);
	bbc_plot(bbc_RectangleFill + bbc_DrawAbsBack, bb->x1, bb->y1);
        return;
    }

    // get the sprite direct pointer
    id.tag = sprite_id_name;
    id.s.name = CACHE_SPRITE_NAME;
    sprite_select_rp(i->cache_area, &id, (sprite_ptr *) &id.s.addr);
    id.tag = sprite_id_addr;

    // read the sprite info
    sprite_readsize(i->cache_area, &id, &info);
    width  = info.width << bbc_modevar(-1, bbc_XEigFactor);
    height = info.height << bbc_modevar(-1, bbc_YEigFactor);

#if 0
    fprintf(stderr, "img: cache tile is '%s' %dx%d\n", strsafe(i->id.s.name), width, height);
#endif

    // get sprite plot phase
    minp = bb->x0 - ((bb->x0 - x) % width);
    if (bb->x0 < x)
	minp -= width;

    minq = bb->y0 - ((bb->y0 - y) % height);
    if (bb->y0 < y)
	minq -= height;

    // plot the sprite
    for (q=minq; q < bb->y1; q+= height)
	for (p=minp; p < bb->x1; p+= width)
            sprite_put_given(i->cache_area, &id, 0, p, q);

    flexmem_shift();
}

os_error *image_save_as_sprite(image i, char *fname)
{
    os_filestr fs;
    int *area;
    os_error *ep;

    flexmem_noshift();

    area = (int*) *(i->areap);

    fs.action =10;		/* Save with file type */
    fs.name = fname;
    fs.loadaddr = FILETYPE_SPRITE;
    fs.start = ((int) area) + 4;
    fs.end = ((int) area) + *area;

    ep = os_file(&fs);

    flexmem_shift();

    return ep;
}

void image_get_scales(image i, int *dx, int *dy)
{
    sprite_header *sph;
    sprite_area *area;
    sprite_id id;
    int mode;

    if (i == NULL || i->magic != IMAGE_MAGIC)
    {
	fprintf(stderr, "Bad magic\n");
	return;
    }

    if ((i->flags & image_flag_RENDERABLE) == 0)
    {
	*dx = 2;
	*dy = 2;
	return;
    }

    flexmem_noshift();

    area = *(i->areap);
    id = i->id;
    if (id.tag == sprite_id_name)
    {
	sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	id.s.addr = sph;
	id.tag = sprite_id_addr;
    }
    else
	sph = (sprite_header *) id.s.addr;

    mode = sph->mode;
    flexmem_shift();

    *dx = 1 << bbc_modevar(mode, bbc_XEigFactor);
    *dy = 1 << bbc_modevar(mode, bbc_YEigFactor);
}

void image_os_to_pixels(image im, int *px, int *py, int scale_image)
{
    int dx, dy;
    int x, y;

    image_get_scales(im, &dx, &dy);

    x = *px / dx;
    y = *py / dy;

    if (x < 0)
	x = 0;
    if (y < 0)
	y = 0;

    if (scale_image != 100)
    {
        x = x*100/scale_image;
        y = y*100/scale_image;
    }

    *px = x;
    *py = y;
}

int image_ave_col_n(image im, int n)
{
    int count[256];
    int palette[256];
    sprite_header *sphp;
    int lbit, rbit;
    int i,j,k;
    int cols = 1 << n;
    int mask = cols - 1;
    int *linep;
    os_regset r;
    os_error *ep;
    int reds, greens, blues;
    int pixcount;
#if DEBUG
    fprintf(stderr, "Calculating average over a %d colour image\n", cols);
#endif
    flexmem_noshift();

    if (im->id.tag == sprite_id_name)
	sprite_select_rp(*(im->areap), &(im->id), (sprite_ptr *) &sphp);
    else
	sphp = (sprite_header *) im->id.s.addr;

    lbit = (sphp->mode > 255) ? 0 : sphp->lbit;
    rbit = sphp->rbit;

    for (i = 0; i < cols; i++)
	count[i] = 0;

    linep = (int*) (((char*) sphp) + sphp->image);
    for (j=0; j < (sphp->height+1); j++)
    {
	for (i=0; i <= sphp->width; i++)
	{
	    int word = linep[i];
	    for (k=0; k < 32; k += n)
	    {
		int val;

		if ((i==0 && k < lbit) || (i == sphp->width && k > rbit))
		    continue;

		val = (word >> k) & mask;
		count[val]++;
	    }
	}
	linep += sphp->width + 1;
    }

    r.r[0] = (int) *(im->areap);
    r.r[1] = (int) im->id.s.addr;
    r.r[2] = (int) palette;
    r.r[3] = sizeof(palette);
    r.r[4] = ((im->id.tag == sprite_id_name) ? 0 : 1);

#if 1
    ep = os_swix(ColourTrans_ReadPalette, &r);
#endif

    flexmem_shift();

    pixcount = reds = greens = blues = 0;

    for (i=0; i < cols; i++)
    {
#if DEBUG >= 2
	fprintf(stderr, "col %d, count %d, palette 0x%08x\n", i, count[i], palette[i]);
#endif
	pixcount += count[i];

	reds += ((palette[i] >> 8) & 0xff) * count[i];
	greens += ((palette[i] >> 16) & 0xff) * count[i];
	blues += ((palette[i] >> 24) & 0xff) * count[i];
    }

    reds += (pixcount >> 1);
    reds /= pixcount;
    greens += (pixcount >> 1);
    greens /= pixcount;
    blues += (pixcount >> 1);
    blues /= pixcount;

    return (reds << 8) + (greens << 16) + (blues << 24);
}

int image_average_colour(image i)
{
    os_error *ep = NULL;
    sprite_header *sphp, sph;
    int l2bpp;
    int ave_col;
#if DEBUG
    fprintf(stderr, "Calculating average colour\n");
#endif
    if (i == NULL || i->magic != IMAGE_MAGIC)
	return (int) config_colours[render_colour_BACK].word;

    flexmem_noshift();

    if (i->id.tag == sprite_id_name)
	ep = sprite_select_rp(*(i->areap), &(i->id), (sprite_ptr *) &sphp);
    else
	sphp = (sprite_header *) i->id.s.addr;

    sph = *sphp;

    flexmem_shift();

    if (ep)
    {
	fprintf(stderr, "Error: %s\n", ep->errmess);
	ave_col = (int) config_colours[render_colour_BACK].word;
    }
    else
    {
	l2bpp = bbc_modevar(sph.mode, bbc_Log2BPP);
#if DEBUG
	fprintf(stderr, "Sprite mode value is 0x%x, l2bpp = %d\n", sph.mode, l2bpp);
#endif

	switch (l2bpp)
	{
	case 0:			/* 1bpp, 2 colours */
	case 1:			/* 2bpp, 4 colours */
	case 2:			/* 4bpp, 16 colours */
	case 3:			/* 8bpp, 256 colours */
	    ave_col = image_ave_col_n(i, 1 << l2bpp);
	    break;
	case 4:			/* 16bpp, 32K colours */
	case 5:			/* 32bpp, 16M colours */
	default:
	    ave_col = (int) config_colours[render_colour_BACK].word;
	    break;
	}
    }

    return ave_col;
}

static int image_white_byte(image im)
{
    int palette[512];
    sprite_header *sphp;
    int l2bpp;
    int i;
    int cols;
    int best, err, besterr;
    os_regset r;
    os_error *ep = NULL;

#if DEBUG
    fprintf(stderr, "Finding colour closest to white\n");
#endif
    flexmem_noshift();

    if (im->id.tag == sprite_id_name)
	sprite_select_rp(*(im->areap), &(im->id), (sprite_ptr *) &sphp);
    else
	sphp = (sprite_header *) im->id.s.addr;

    l2bpp = bbc_modevar(sphp->mode, bbc_Log2BPP);

    if (l2bpp <= 3)
    {
#if DEBUG
	fprintf(stderr, "Reading palette data.\n");
#endif
	r.r[0] = (int) *(im->areap);
	r.r[1] = (int) im->id.s.addr;
	r.r[2] = (int) palette;
	r.r[3] = sizeof(palette);
	r.r[4] = ((im->id.tag == sprite_id_name) ? (0<<0) : (1<<0) );

	ep = os_swix(ColourTrans_ReadPalette, &r);
    }
    flexmem_shift();

    if (l2bpp > 3)
	return 0xff;

    if (ep)
    {
	fprintf(stderr, "Error in best colour: %s\n", ep->errmess);
    }

    cols = 1 << (1 << l2bpp);

    best = -1;
    besterr = 0x7fffffff;

    for (i=0; i < cols; i++)
    {
	int dist;
#if DEBUG >= 2
	fprintf(stderr, "col %d, palette 0x%08x\n", i, palette[i]);
#endif
	dist = 0xff - ((palette[i] >> 24) & 0xff);
	err  = dist * dist;
	dist = 0xff - ((palette[i] >> 16) & 0xff);
	err += dist * dist;
	dist = 0xff - ((palette[i] >>  8) & 0xff);
	err += dist * dist;

#if DEBUG >= 2
	fprintf(stderr, "Err %d, best err %d, best %d\n", err, besterr, best);
#endif

	if (err < besterr)
	{
	    besterr = err;
	    best = i;
	}
    }

#if DEBUG
    fprintf(stderr, "Best colour is 0x%x\n", best);
#endif

    while (l2bpp < 3)
    {
	best |= (best << (1 << l2bpp));
	l2bpp++;
    }

#if DEBUG
    fprintf(stderr, "Best colour byte is 0x%x\n", best);
#endif

    return best;
}

void image_save_as_draw(image i, int fh, wimp_box *bb, int *fileoff)
{
    draw_objhdr obj;
    char buffer[12];
    sprite_header *sph;
    sprite_area *area;
    sprite_id id;
    os_regset r;
    os_error *ep = NULL;

    flexmem_noshift();

    if ( (i->flags & (image_flag_FETCHED | image_flag_RENDERABLE)) == image_flag_FETCHED)
    {
	sprintf(buffer, "file_%03x", i->file_type);

	ep = os_swix(Wimp_BaseOfSprites, &r);

	area = (sprite_area *) r.r[1];

	id.tag = sprite_id_name;
	id.s.name = buffer;

	ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);

	if (ep)
	{
	    area = (sprite_area *) r.r[0];
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	}

	if (ep)
	{
	    strcpy(buffer, "file_xxx");
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	}
    }
    else
    {
	area = *(i->areap);
	id = i->id;
	if (id.tag == sprite_id_name)
	{
	    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
	    id.s.addr = sph;
	    id.tag = sprite_id_addr;
	}
	else
	    sph = (sprite_header *) id.s.addr;
    }

    if (ep)
    {
	fprintf(stderr, "Error while saving sprite as draw: %s\n", ep->errmess);
	goto wayout;
    }

    obj.tag = draw_OBJSPRITE;
    obj.size = sizeof(obj) + sph->next;
    obj.bbox.x0 = bb->x0 << 8;
    obj.bbox.y0 = bb->y0 << 8;
    obj.bbox.x1 = bb->x1 << 8;
    obj.bbox.y1 = bb->y1 << 8;

    df_write_data(fh, *fileoff, &obj, sizeof(obj));
    *fileoff += sizeof(obj);
    df_write_data(fh, *fileoff, sph, sph->next);
    *fileoff += sph->next;

 wayout:
    flexmem_shift();
}
