/* rolib.c

 * Functions missing from the ROM version of RiscOSLib

 */

#include "bbc.h"
#include "font.h"
#include "sprite.h"
#include "wimp.h"

#define ReadPixTrans        (0x000400c0+45)
#define OS_SpriteOp         0x0000002E

os_error *wimp_readpixtrans(sprite_area *area, sprite_id *id,
                         sprite_factors *factors, sprite_pixtrans *pixtrans)
{
   os_regset r;
   os_error *e;

   if ((area == (sprite_area *)0) || (area == (sprite_area *)1))
   {
     r.r[0] = 0x0000;
     r.r[2] = (int) id->s.name;
   }
   else if ((id->tag) == sprite_id_name)
   {
     r.r[0] = 0x0100;
     r.r[2] = (int) id->s.name;
   }
   else if ((id->tag) == sprite_id_addr)
   {
     r.r[0] = 0x0200;
     r.r[2] = (int) id->s.addr;
   }

   r.r[1] = (int) area;
   r.r[6] = (int) factors;
   r.r[7] = (int) pixtrans;

   e = os_swix(ReadPixTrans, &r);
   return(e);
}

#define Converttopoints      0x40089

os_error *font_converttopoints(int x_os, int y_os, int *x_inch, int *y_inch)
{
   os_regset r;
   os_error *e;

   r.r[1] = x_os;
   r.r[2] = y_os;

   e = os_swix(Converttopoints, &r);

   *x_inch = r.r[1];
   *y_inch = r.r[2];

   return e;
}

// -----------------------------------------------------------------------------
// sprite functions not in the ROM plus their support routines

static os_error * sprite__op(os_regset *r)
{
  return os_swix(OS_SpriteOp, r);
}

/* Modify op if using sprite address is address, not name */
/* But only if using own sprite area */
static void setfromtag(int op, sprite_area *area, sprite_id *spr, os_regset *r)
{
  if (area == sprite_mainarea)
  {
    r->r[0] = op;
 /* r->r[1] unused */
  }
  else
  {
    r->r[1] = (int) area;
    if ((spr->tag) == sprite_id_addr)
    {
      r->r[0] = 512 + op;
      r->r[2] = (int) (spr->s.addr);
    }
    else
    {
      r->r[0] = 256 + op;
      r->r[2] = (int) (spr->s.name);
    }
  }
}

os_error *sprite_restorestate(sprite_state state)
{
  os_regset r;
  os_error *result;

  r.r[0] = state.r[0];
  r.r[1] = state.r[1];
  r.r[2] = state.r[2];
  r.r[3] = state.r[3];

  result = sprite__op(&r);
  return result;
}

os_error * sprite_put_given(sprite_area *area, sprite_id *spr, int gcol_action,
                            int x, int y)
{
  os_regset r;
  os_error *result;
  setfromtag(34, area, spr, &r);
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = gcol_action;
  result = sprite__op(&r);
  return result;
}

os_error *sprite_outputtosprite(sprite_area *area, sprite_id *id,
                                int *save_area, sprite_state *state)
{
  os_regset r;
  os_error *result;

  setfromtag(0x3c, area, id, &r);
  r.r[3] = (int) save_area;

  result = sprite__op(&r);
  if (result == NULL)
  {
    state->r[0] = r.r[0];
    state->r[1] = r.r[1];
    state->r[2] = r.r[2];
    state->r[3] = r.r[3];
  }
  return result;
}

os_error *bbc_moveby(int x, int y)
{
   return(bbc_plot(bbc_SolidBoth, x, y));
}

os_error *bbc_circle(int x, int y, int r)
{
   os_error *e = bbc_move(x, y);
   if (!e) e = bbc_plot(bbc_Circle + bbc_DrawAbsFore, x + r, y);
   return(e);
}

/* eof rolib.c */

