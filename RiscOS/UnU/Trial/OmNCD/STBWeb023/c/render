/* -*-c-*- */

/* render.c */

/*
 * 21/3/96: SJM: Took out RIM if anti-twittering, introduced render_colour_HIGHLIGHT for active link and cursor highlighting
 *               added render_item_outline
 * 2/4/96:  SJM: Changed render_link_colour to return HIGHLIGHT for all SELECTED items rather than just links.
 * 28/5/96: SJM: don't draw plinth if image isn't big enough
 * 24/6/96: SJM: added visited link colouring to render_link_colour, added render_text_link_colour.
 */

/* Bits of code to help with rendering */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "wimp.h"
#include "font.h"
#include "bbc.h"
#include "colourtran.h"
#include "swis.h"

#include "interface.h"
#include "rid.h"
#include "config.h"
#include "antweb.h"
#include "access.h"
#include "url.h"

#include "memwatch.h"
#include "render.h"
#include "rcolours.h"
#include "version.h"

void render_plinth(int bcol, int flags, int x, int y, int w, int h, antweb_doc *doc)
{
    int dx = frontend_dx, dy = frontend_dy;

    if ((flags & render_plinth_NOFILL) == 0 && w > 8 && h > 8)
    {
	render_set_colour(bcol, doc);
	bbc_rectanglefill(x + 4, y + 4, w - 8, h - 8);
    }

#if !ANTI_TWITTER
    if ((flags & render_plinth_RIM) && w > 13 && h > 13)
    {
	render_set_colour(render_colour_PLAIN, doc);
	bbc_rectangle(x + 6, y + 6, w - (dx + 12), h - (dy + 12));
    }
#endif

    render_set_colour((flags & render_plinth_IN) ? render_colour_LINE_L : render_colour_LINE_D, doc);
    if (w > 4+dx && h > 4+dy)
    {
        bbc_move(x , y);
        bbc_drawby(w - dx, 0);
        bbc_drawby(0, h - dy);
        bbc_move(x + 2 , y + 2);
        bbc_drawby(w - (4+dx), 0);
        bbc_drawby(0, h - (4+dy));
    }

    if ((flags & render_plinth_DOUBLE) && w > 12+dx && h > 12+dy)
    {
	bbc_move(x + 4, y + 4);
	bbc_drawby(0, h - (8+dy));
	bbc_drawby(w - (8+dx), 0);
	bbc_move(x + 6 , y + 6);
	bbc_drawby(0, h - (12+dy));
	bbc_drawby(w - (12+dx), 0);
    }

    render_set_colour((flags & render_plinth_IN) ? render_colour_LINE_D : render_colour_LINE_L, doc);
    if (w > 4+dx && h > 4+dy)
    {
        bbc_move(x , y);
        bbc_drawby(0, h - dy);
        bbc_drawby(w - dx, 0);
        bbc_move(x + 2 , y + 2);
        bbc_drawby(0, h - (4+dy));
        bbc_drawby(w - (4+dy), 0);
    }

    if ((flags & render_plinth_DOUBLE) && w > 12+dx && h > 12+dy)
    {
	bbc_move(x + 4 , y + 4);
	bbc_drawby(w - (8+dx), 0);
	bbc_drawby(0, h - (8+dy));
	bbc_move(x + 6 , y + 6);
	bbc_drawby(w - (12+dx), 0);
	bbc_drawby(0, h - (12+dy));
    }
}

static int colour_distance(wimp_paletteword c1, wimp_paletteword c2)
{
    int r,g,b;
    r = (c1.bytes.red - c2.bytes.red);
    g = (c1.bytes.green - c2.bytes.green);
    b = (c1.bytes.blue - c2.bytes.blue);
    return r*r + g*g + b*b;
}

wimp_paletteword render_get_colour(int colour, be_doc doc)
{
    wimp_paletteword pw;

    switch (colour)
    {
    case render_colour_BACK:
	if (doc &&
	    (doc->flags & doc_flag_DOC_COLOURS) &&
	    doc->rh &&
	    (doc->rh->bgt & rid_bgt_COLOURS) )
	{
	    pw.word = doc->rh->colours.back;
	    return pw;
	}
	break;
    case render_colour_AREF:
	if (doc &&
	    (doc->flags & doc_flag_DOC_COLOURS) &&
	    doc->rh &&
	    (doc->rh->bgt & rid_bgt_LCOL) )
	{
	    pw.word = doc->rh->colours.link;
	    return pw;
	}
	break;
    case render_colour_CREF:
	if (doc &&
	    (doc->flags & doc_flag_DOC_COLOURS) &&
	    doc->rh &&
	    (doc->rh->bgt & rid_bgt_VCOL) )
	{
	    pw.word = doc->rh->colours.vlink;
	    return pw;
	}
	break;
    case render_colour_PLAIN:
	if (doc &&
	    (doc->flags & doc_flag_DOC_COLOURS) &&
	    doc->rh &&
	    (doc->rh->bgt & rid_bgt_FCOL) )
	{
	    pw.word = doc->rh->colours.fore;
	    return pw;
	}
	break;
#if 0
    case render_colour_LINE_L:
    case render_colour_LINE_D:
        if (doc &&
            (doc->flags & doc_flag_DOC_COLOURS) &&
            doc->rh &&
	    (doc->rh->bgt & (rid_bgt_COLOURS|rid_bgt_IMAGE)) == rid_bgt_COLOURS &&
	    doc->rh->colours.back.word == config_colours[colour].word )
        {

        }
        break;
#endif
    case render_colour_HIGHLIGHT:
	if (doc &&
	    (doc->flags & doc_flag_DOC_COLOURS) &&
	    doc->rh &&
	    (doc->rh->bgt & rid_bgt_ACOL) )
	{
            wimp_paletteword col;

	    pw.word = doc->rh->colours.alink;

            col = render_get_colour(render_colour_AREF, doc);
            if (colour_distance(pw, col) < 64*64)
                pw.word = col.word ^ 0xffffff00;

            col = render_get_colour(render_colour_BACK, doc);
            if (colour_distance(pw, col) < 64*64)
                pw.word = col.word ^ 0xffffff00;

	    return pw;
	}
	break;
    }

    return config_colours[colour];
}

void render_set_colour(int colour, antweb_doc *doc)
{
    int junk;

    colourtran_setGCOL(render_get_colour(colour, doc), 0, 0, &junk);
}

void render_set_bg_colour(int colour, antweb_doc *doc)
{
    int junk;

    colourtran_setGCOL(render_get_colour(colour, doc), (1<<8) | (1<<7), 0, &junk);
}

void render_set_font_colours(int f, int b, antweb_doc *doc)
{
    int maxcols = (doc->flags & doc_flag_ANTIALIAS) ? 14 : 0;
    font fh;
    wimp_paletteword ff, bb;

    fh = 0;
    ff = render_get_colour(f, doc);
    bb = render_get_colour(b, doc);

    colourtran_setfontcolours(&fh, &bb, &ff, &maxcols);
}

/*
 * This is used for images (links and unlinks).
 */

int render_link_colour(rid_text_item *ti, antweb_doc *doc)
{
    int rcol;
    if (ti->flag & rid_flag_SELECTED)
	rcol = render_colour_HIGHLIGHT;
    else
        rcol = render_text_link_colour(ti, doc);
    return rcol;
}

/*
 * This is used for text links.
 */

int render_text_link_colour(rid_text_item *ti, antweb_doc *doc)
{
    int rcol;
    if (ti->aref == NULL || ti->aref->href == NULL)
	rcol = render_colour_PLAIN;
    else
    {
#if 0
	rcol = render_colour_AREF;
#else
	rid_aref_item *aref = ti->aref;

	rcol = render_colour_AREF;

        if ((aref->flags & rid_aref_CHECKED_CACHE) == 0)
        {
    	    char *linkval, *frag;

            linkval = url_join(BASE(doc), aref->href);
            if (linkval && (frag = strrchr(linkval, '#')) != NULL)
                *frag = 0;

	    if (linkval && access_test_cache(linkval))
                aref->flags |= (rid_aref_IN_CACHE | rid_aref_CHECKED_CACHE);
            else
                aref->flags |= rid_aref_CHECKED_CACHE;

	    if (linkval)
	        mm_free(linkval);
        }

        if (aref->flags & rid_aref_IN_CACHE)
	    rcol = render_colour_CREF;
#endif
    }
    return rcol;
}

void render_plot_icon(char *sprite, int x, int y)
{
    sprite_pixtrans pt[16];
    sprite_factors facs;
    sprite_header *sph;
    sprite_area *area;
    sprite_id id;
    os_regset r;
    os_error *ep;

    ep = os_swix(Wimp_BaseOfSprites, &r);

    if (ep)
	return;

    area = (sprite_area *) r.r[1];

    id.tag = sprite_id_name;
    id.s.name = sprite;

    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);

    if (ep)
    {
	area = (sprite_area *) r.r[0];
    }

    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);

    if (ep)
	return;

    id.tag = sprite_id_addr;
    id.s.addr = sph;

    ep = wimp_readpixtrans(area, &id, &facs, pt);

    if (ep)
	return;

    sprite_put_scaled(area, &id, 0x8, x, y, &facs, pt);
}


/* SJM */
void render_item_outline(rid_text_item *ti, int hpos, int bline)
{
    int dx, dy;

    dx = frontend_dx;
    dy = frontend_dy;

    bbc_move(hpos, bline - ti->max_down);
    bbc_drawby(ti->width - dx, 0);
    bbc_drawby(0, ti->max_down + ti->max_up - dy);
    bbc_drawby(- (ti->width - dx), 0);
    bbc_drawby(0, -(ti->max_down + ti->max_up - dy) );
#if ANTI_TWITTER
    bbc_move(hpos + 2, bline - ti->max_down + 2);
    bbc_drawby(ti->width - dx - 4, 0);
    bbc_drawby(0, ti->max_down + ti->max_up - dy - 4);
    bbc_drawby(- (ti->width - dx - 4), 0);
    bbc_drawby(0, -(ti->max_down + ti->max_up - dy - 4) );
#endif
}

/* eof render.c */
