/* -*-c-*- */

/* access.c */

/*
 * 26/3/96 SJM Added cookie support code in access_init, tidyup, http_fetch_start, http_fetch_alarm
 * 02/4/96 SJM Exported cache_insert and scrapfile_name.
 * 23/4/96 SJM Merged new changes
 * 16/5/96 SJM Made proxying ensure that the path is non-null
 * 23/5/96 SJM new cacheing scheme. cache_ functions moved to cache2. All cache_ calls routed through cache function table
 *             All cache functions now only access from here. Some more access wrappers to them for images.c and backend.c
 * 04/6/96 SJM keep count of cookies received in access_item and optionally write out cookie file at the end
 * 10/6/96 SJM changed User-Agent string to use PROGRAM_TITLE rather than PROGRAM_NAME
 * 14/6/96 SJM New config option to keep auth file up to date. Added saving to http_auth_rerequest
 *             find_realm checks for whether a scheme is supported before returning it. Now can cope with
 *             multiple WWW_AUTHENTICATE headers for different schemes. Took out error generation when user cancels authentication
 * 20/6/96 SJM Added auth auto-saving to ftp done. Started the auto redialling stuff.
 * 24/6/96 SJM Added visdelay around access_url(). Fixed memory leak in access_url (early returns).
 */

/* Functions for accessing URLs */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "memwatch.h"

#include "os.h"
#include "alarm.h"
#include "wimp.h"
#include "swis.h"
#include "akbd.h"
#include "sprite.h"
#include "visdelay.h"

/* Need to know about a struct sockaddr_in */
#include "sys/types.h"
#include "netinet/in.h"

#include "urlopen.h"
#define ACCESS_INTERNAL
#include "access.h"
#include "url.h"
#include "util.h"
#include "status.h"
#include "gopher.h"
#include "makeerror.h"
#include "auth.h"
#include "config.h"
#include "licence.h"
#include "interface.h"
#include "filetypes.h"
#include "dir2html.h"

#include "version.h"
#include "verstring.h"

#include "resolve.h"

#ifdef STBWEB
#include "webftp.h"
#include "http.h"
#include "webgopher.h"
#else
#include "../webftp/webftp.h"
#include "../http/httppub.h"
#include "../webgopher/gopherpub.h"
#endif

#include "cookie.h"

extern void translate_escaped_text(char *in, char *out, int len);

extern int strcasecomp(char *s1, char *s2);
extern int strncasecomp(char *s1, char *s2, int n);

#ifndef DEBUG
#define DEBUG 0
#endif

#ifndef DUMP_HEADERS
#define DUMP_HEADERS 1
#endif

#ifndef POLL_INTERVAL
#define POLL_INTERVAL	10	/* centi-seconds */
#endif

#ifndef FILE_POLL_INTERVAL
#define FILE_POLL_INTERVAL	3	/* centi-seconds */
#endif

#define FILE_INITIAL_CHUNK	0x400 /* 1K */
#define FILE_MAX_CHUNK		0x4000	/* 16K */

#define FTP_IDLE_TIME	(60000)	/* = 10 * 60 * 100 = 10 minutes in centi-seconds */

#define access_type_HTTP	1
#define access_type_GOPHER	2
#define access_type_FTP		3
#define access_type_FILE	4

typedef struct _access_item {
    int access_type;
    access_url_flags flags;
    char *dest_host;		/* This can be from the URL or from a proxy pointer */
    struct sockaddr_in addr;	/* The socket address for the current connection */
    char *request_string;	/* This will be either the path or the whole URL for a proxy */
    char *url;
    char *ofile;
    short ftype, ft_is_set;	/* 16 bits for file type and a flag to say it has been set */
    char *referer;
    alarm_handler next_fn;
    access_progress_fn progress;
    access_complete_fn complete;
    void *h;
    void *transport_handle;
    struct _access_item *redirect;
    struct _access_item *next, *prev;
    union {
	struct {
	    char *body_file;
	    int had_auth;	/* Set when the access was made with authentication */
	    int had_passwd;     /* Set if we hav eto ask the user for a password */
	    fe_passwd pw;	/* Used while we are waiting for a userid/passwd pair. */
            char *windowtarget; /* if we are targeting at a particular window */
            int cookie_count;   /* number of cookies received in headers */
	} http;
	struct {
	    int gopher_tag;
	} gopher;
	struct {
	    char *user;
	    char *passwd;
	    fe_passwd pw;	/* Used while we are waiting for a userid/passwd pair. */
	    int had_passwd;     /* Set if we hav eto ask the user for a password */
	} ftp;
	struct {
	    int fh;
	    int chunk;
	    int size;
	    int so_far;
	    char *fname;
	    int ofh;
	} file;
    } data;
#ifdef STBWEB
    struct
    {
        alarm_handler continue_fn;
    } redial;
#endif
} access_item;

/***************************************************************************/

char *access_schemes[] = {
    "file",
    "http",
    "gopher",
    "ftp",
    "icontype",

    NULL
    };

/***************************************************************************/

static void access_free_item(access_handle d);
static void access_unlink(access_handle h);
static void access_link(access_handle h);
static void access_redirect_progress(void *h, int status, int size, int so_far, int fh, int ftype, char *url);
static access_complete_flags access_redirect_complete(void *h, int status, char *cfile, char *url);
static void access_http_dns_alarm(int at, void *h);
static void access_http_fetch_alarm(int at, void *h);
static void access_gopher_dns_alarm(int at, void *h);
static void access_gopher_fetch_alarm(int at, void *h);
static void access_ftp_dns_alarm(int at, void *h);
static void access_ftp_fetch_alarm(int at, void *h);
static void access_file_fetch_alarm(int at, void *h);
static os_error *access_http_fetch_start(access_handle d);
static void access_reschedule(alarm_handler fn, access_handle d, int dt);
static void access_http_fetch_done(access_handle d, http_status_args *si);

static os_error *gopher_set_file_type(char *fname, char tag, int *ftptr);

/***************************************************************************/

static cache_functions *cache = NULL;

/***************************************************************************/

access_handle access_pending_list;
static int access_done_flag;	/* For forground fetches */

static http_header_item user_agent_hdr = {
    NULL,
    "User-Agent",
    PROGRAM_TITLE"/"VERSION_NUMBER SPECIAL_SUFFIX
    };

static http_header_item licence_hdr = {
    NULL,
    "X-Licensee",
    NULL
    };

static http_header_item content_type_hdr = {
    NULL,
    "Content-type",
    "application/x-www-form-urlencoded"
    };

static http_header_item accept_type_hdr = {
    NULL,
    "Accept",
    "text/html, image/gif, image/jpeg, image/pjpeg, image/png, */*; q=.2"
    };

static http_header_item authenticate_hdr = {
    NULL,
    "Authorization",
    NULL,
    };

static http_header_item referer_hdr = {
    NULL,
    "Referer",
    NULL,
    };

static http_header_item from_hdr = {
    NULL,
    "From",
    NULL,
    };

/* ------------------------------------------------------------------------------------- */

#ifdef STBWEB

#define status_REDIALLING   status_DNS

extern int frontend_is_interface_up(void);
extern int frontend_is_interface_down(void);

static void access_redial_alarm(int at, void *h);


static BOOL access_do_redial(access_handle d)
{
    /* are we already redialling */
    if (d->redial.continue_fn == 0)
        return TRUE;

    /* is the interface is down */
    if (frontend_is_interface_down())
    {
        os_cli("*Dial");

        if (d->progress)
            d->progress(d->h, status_REDIALLING, -1, -1, 0, -1, NULL);

        d->redial.continue_fn = access_http_dns_alarm;
        access_reschedule(access_redial_alarm, d, POLL_INTERVAL);

        return TRUE;
    }

    /* no - return normal error */
    return FALSE;
}

static void access_redial_alarm(int at, void *h)
{
    access_handle d = h;

    if (frontend_is_interface_up())
    {
	if (d->progress)
	    d->progress(d->h, status_REDIALLING, -1, -1, 0, -1, NULL);
	access_reschedule(&access_redial_alarm, d, POLL_INTERVAL);
    }
    else
    {
	if (d->progress)
	    d->progress(d->h, status_DNS, -1, -1, 0, -1, NULL);

	access_reschedule(d->redial.continue_fn, d, POLL_INTERVAL);
        d->redial.continue_fn = 0;
    }
}

#else

#define access_do_redial(d)    0
#define access_redial_alarm    0

#endif

/* ------------------------------------------------------------------------------------- */

static char *access_host_name_only(char *url)
{
    char *p, *q;
    char *scheme, *netloc, *path, *params, *query, *fragment;

    url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);

    p = strchr(netloc, '@');
    p = p ? p+1 : netloc;
    q = strchr(p, ':');
    if (q)
	*q = 0;

    q = strdup(p);

    url_free_parts(scheme, netloc, path, params, query, fragment);

    return q;
}

static void access_free_item(access_handle d)
{
    FREE(d->dest_host);
    FREE(d->request_string);
    FREE(d->url);
    FREE(d->referer);
    FREE(d->ofile);

    switch(d->access_type)
    {
    case access_type_HTTP:
	FREE(d->data.http.body_file);
	FREE(d->data.http.windowtarget);
	break;
    case access_type_FTP:
	FREE(d->data.ftp.user);
	FREE(d->data.ftp.passwd);
	break;
    case access_type_FILE:
	FREE(d->data.file.fname);
    }

    mm_free(d);
}

/* Unlinks but does not free */
static void access_unlink(access_handle h)
{
    if (h->prev)
	h->prev->next = h->next;
    else
	access_pending_list = h->next;

    if (h->next)
	h->next->prev = h->prev;
}

static void access_link(access_handle h)
{
    h->next = access_pending_list;
    h->prev = NULL;

    if (h->next)
	h->next->prev = h;

    access_pending_list = h;
}

static os_error *access_write_wimp_icon(char *name, char *fname)
{
    os_error *ep = NULL;
    os_regset r;
    sprite_area *area;
    sprite_header *sph;
    sprite_id id;
#if 0
    fprintf(stderr, "Saving icon '%s' into '%s'\n", name, fname);
#endif
    ep = os_swix(Wimp_BaseOfSprites, &r);

    area = (sprite_area *) r.r[1];

    id.tag = sprite_id_name;
    id.s.name = name;

    ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);

    if (ep)
    {
	area = (sprite_area *) r.r[0];
	ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
    }

    if (ep)
    {
	id.s.name = "small_xxx";
	ep = sprite_select_rp(area, &(id), (sprite_ptr *) &sph);
    }

    if (ep == 0)
    {
	int fh;
	os_gbpbstr gpb;
	sprite_area sa;

	r.r[0] = 0x8f;
	r.r[1] = (int) fname;

	ep = os_find(&r);

	fh = ep ? 0 : r.r[0];

	if (ep == 0)
	{
	    sa.number = 1;
	    sa.sproff = 16;
	    sa.freeoff = sph->next + 16;

	    gpb.action = 2;
	    gpb.file_handle = fh;
	    gpb.data_addr = &sa.number;
	    gpb.number = sizeof(sa) - sizeof(sa.size);

	    ep = os_gbpb(&gpb);
	}

	if (ep == 0)
	{
	    gpb.action = 2;
	    gpb.file_handle = fh;
	    gpb.data_addr = sph;
	    gpb.number = sph->next;

	    ep = os_gbpb(&gpb);
	}

	if (fh)
	{
	    os_error *ep2;

	    r.r[0] = 0;
	    r.r[1] = fh;

	    ep2 = os_find(&r);

	    if (ep == 0)
		ep = ep2;
	}

	if (ep == 0)
	    set_file_type(fname, FILETYPE_SPRITE);
    }

    return ep;
}

static void access_redirect_progress(void *h, int status, int size, int so_far, int fh, int ftype, char *url)
{
    access_handle d = (access_handle) h;

    if (d->progress)
	d->progress(d->h, status, size, so_far, fh, ftype, url);
}

static access_complete_flags access_redirect_complete(void *h, int status, char *cfile, char *url)
{
    access_complete_flags cache_it;

    access_handle d = (access_handle) h;

    cache_it = d->complete(d->h, status, cfile, url); /* Pass up the real URL, not the one they requested */
    d->redirect = NULL;

    access_unlink(d);
    access_free_item(d);

    return cache_it;
}

static os_error *gopher_set_file_type(char *fname, char tag, int *ftptr)
{
    os_filestr osf;
    int ft;

    switch (tag)
    {
    case '0':
	ft = FILETYPE_TEXT;
	break;
    case '1':
    case '7':
	ft = FILETYPE_GOPHER;
	break;
    case 'h':
	ft = FILETYPE_HTML;
	break;
    default:
	ft = FILETYPE_DATA;
	break;
    }

    osf.action = 18;
    osf.name = fname;
    osf.loadaddr = ft;

    if (ftptr)
	*ftptr = ft;

    return os_file(&osf);
}

static void access_gopher_close(void *handle, int flags)
{
    gopher_close_args goc;

    goc.in.handle = handle;
    goc.in.flags = flags;

    os_swix(WebGopher_Close, (os_regset *) &goc);
}

static os_error *access_gopher_fetch_start(access_handle d)
{
    gopher_open_args goo;
    os_error *ep = NULL;

    goo.in.addr = &d->addr;
    goo.in.object = d->request_string;
    goo.in.fname = d->ofile ? d->ofile : cache->scrapfile_name();

    ep = os_swix(WebGopher_Open, (os_regset *) &goo);

    d->transport_handle = goo.out.handle;

    return ep;
}

static void access_ftp_close(void *handle, int flags)
{
    ftp_close_args ftpc;

    ftpc.in.session = handle;
    ftpc.in.flags = flags;

    os_swix(WebFTP_Close, (os_regset *) &ftpc);
}

static os_error *access_ftp_fetch_start(access_handle d)
{
    ftp_open_args ftpo;
    os_error *ep = NULL;
#if 0
    fprintf(stderr, "Opening connection: host=0x%08x, port=0x%04x\n", (int) d->addr.sin_addr.s_addr, d->addr.sin_port);
#endif
    ftpo.in.addr = &d->addr;
    ftpo.in.user_name = d->data.ftp.user;
    ftpo.in.passwd = d->data.ftp.passwd;
    ftpo.in.acct = NULL;
    ftpo.in.path = d->request_string;
    ftpo.in.local_name = d->ofile ? d->ofile : cache->scrapfile_name();
    ftpo.in.flags = 0;
    ftpo.in.maxidle = FTP_IDLE_TIME;

    ep = os_swix(WebFTP_Open, (os_regset *) &ftpo);

    d->transport_handle = ftpo.out.session;

    return ep;
}

static void access_http_close(void *handle, int flags)
{
    http_close_args httpc;

    httpc.in.handle = handle;
    httpc.in.flags = flags;

    os_swix(HTTP_Close, (os_regset *) &httpc);
}


static os_error *access_http_fetch_start(access_handle d)
{
    http_header_item *hlist = NULL;
    char *auth_string;
    os_error *ep = NULL;
    http_open_args httpo;

    user_agent_hdr.next = hlist;
    hlist = &user_agent_hdr;

    accept_type_hdr.next = hlist;
    hlist = &accept_type_hdr;

    if (d->data.http.body_file)
    {
	content_type_hdr.next = hlist;
	hlist = &content_type_hdr;
    }

    if (d->referer)
    {
	referer_hdr.next = hlist;
	referer_hdr.value = d->referer;
	hlist = &referer_hdr;
    }

    if (licensee_string)
    {
	licence_hdr.next = hlist;
	licence_hdr.value = licensee_string;
	hlist = &licence_hdr;
    }

    if (config_email_addr)
    {
	from_hdr.next = hlist;
	from_hdr.value = config_email_addr;
	hlist = &from_hdr;
    }

    if ((auth_string = auth_lookup_string(d->url)) != NULL)
    {
	authenticate_hdr.next = hlist;
	authenticate_hdr.value = auth_string;

	hlist = &authenticate_hdr;
#if 0
	fprintf(stderr, "%s: %s\n", hlist->key, hlist->value);
#endif
	d->data.http.had_auth = 1;
    }

    if (config_cookie_enable)
        hlist = cookie_add_headers(hlist, d->url, FALSE); /* Not secure currently */

#if 0
    fprintf(stderr, "Opening connection to host 0x%08x, port 0x%04x, request '%s'\n",
	    (int) d->addr.sin_addr.s_addr, d->addr.sin_port, d->request_string);
#endif

    httpo.in.addr = &d->addr;
    httpo.in.object = d->request_string;
    httpo.in.headers = hlist;
    httpo.in.fname = d->ofile ? d->ofile : cache->scrapfile_name();
    httpo.in.bname = d->data.http.body_file;

    ep = os_swix(HTTP_Open, (os_regset *) &httpo);

    if (ep == NULL)
	d->transport_handle = httpo.out.handle;

    return ep;
}

static void access_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;

    d->next_fn(at, h);
}

static void access_reschedule(alarm_handler fn, access_handle d, int dt)
{
    d->next_fn = fn;

    if ((d->flags & access_FORGROUND) == 0)
	alarm_set(alarm_timenow() + dt, &access_alarm, d);
}

static void access_http_dns_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    int status;
    os_error *ep;

#if DEBUG
    fprintf(stderr, "HTTP resolving name '%s'\n", d->dest_host);
#endif

    ep = netloc_resolve(d->dest_host, 80, &status, &d->addr);
    if (ep == NULL)
    {
    }
    else if (access_do_redial(d))
    {
        return;
    }
    else
    {
#if DEBUG
	fprintf(stderr, "HTTP resolve failed, error:%s\n", ep->errmess);
#endif

	if (d->complete)
	    d->complete(d->h,status_FAIL_DNS, NULL, d->url);

	access_done_flag = 1;

	access_unlink(d);
	access_free_item(d);

	return;
    }

    if (status == 0)
    {
#if DEBUG
	fprintf(stderr, "HTTP resolve OK, starting fetch\n");
#endif

	ep = access_http_fetch_start(d);
	if (ep == NULL)
	{
#if DEBUG
	    fprintf(stderr, "HTTP fetch started OK.\n");
#endif

	    if (d->progress)
		d->progress(d->h, status_CONNECTING, -1, -1, 0, -1, NULL);
	    access_reschedule(&access_http_fetch_alarm, d, POLL_INTERVAL);
	}
        else if (access_do_redial(d))
        {
            return;
        }
	else
	{
#if 1
	    fprintf(stderr, "HTTP open failed, error = %s\n", ep->errmess);
#endif

	    if (d->complete)
		d->complete(d->h, status_FAIL_CONNECT, NULL, d->url);

	    access_done_flag = 1;

	    access_unlink(d);
	    access_free_item(d);
	}
    }
    else
    {
#if DEBUG
	fprintf(stderr, "HTTP DNS still going on\n");
#endif

	if (d->progress)
	    d->progress(d->h, status_DNS, -1, -1, 0, -1, NULL);
	access_reschedule(&access_http_dns_alarm, d, POLL_INTERVAL);
    }
}

static void access_http_auth_rerequest(access_handle d, realm rr)
{
    char *scheme, *netloc, *path, *params, *query, *fragment;
    char *prefix;

    url_parse(d->url, &scheme, &netloc, &path, &params, &query, &fragment);

    prefix = strrchr(path, '/');
    if (prefix)
	prefix[1] = 0;

    prefix = url_unparse(scheme, netloc, path, 0, 0, 0);
    url_free_parts(scheme, netloc, path, params, query, fragment);

    auth_add(prefix, rr);

    mm_free(prefix);

    access_http_close(d->transport_handle, http_close_DELETE_FILE);	/* Don't delete body; we still need it */
    d->transport_handle = NULL;

    access_url(d->url, d->flags, d->ofile, d->data.http.body_file, d->url,
	       &access_redirect_progress, &access_redirect_complete, d, &(d->redirect));
}

int access_http_find_realm(http_header_item *list, char **realm_name, char **realm_type)
{
    char *r_name = NULL, *r_type = NULL;

    for ( ; list; list = list->next)
    {
	if (strcasecomp("WWW-AUTHENTICATE", list->key) == 0)
	{
	    char *temp;
	    char *type;
	    char *name;

            /* parse authenticate line */
	    type = temp = strdup(list->value);

	    while (isspace(*type))
		type++;

	    type = strtok(type, " \t");

	    name = strtok(NULL, "=");
	    name = strtok(NULL, "\"");
#if 0
	    fprintf(stderr, "type='%s', realm='%s'\n", type, name);
#endif
            /* free last saved name/type */
            mm_free(r_name);
            mm_free(r_type);

            /* save this name/type, use none here as it makes auth easier */
	    r_name = strdup(name ? name : "<none>");
	    r_type = strdup(type);

            /* free containing string */
	    mm_free(temp);

            /* if we support this type then go to finish */
            if (auth_supported(type))
                break;
	}
    }

    /* write out what we have found -
     * will either be a supported authentication type
     * or else the last header found
     */

    *realm_name = r_name;
    *realm_type = r_type;

    return r_type != NULL;
}

void access_http_passwd_callback(fe_passwd pw, void *handle, char *user, char *password)
{
    access_handle d = (access_handle) handle;
    realm rr = NULL;
    http_status_args si;
    char *realm_name, *realm_type;

    d->data.http.pw = NULL;

    si.in.handle = d->transport_handle;

    os_swix(HTTP_Status, (os_regset *) &si);

    if (user)
    {
	access_http_find_realm(si.out.headers, &realm_name, &realm_type);

	rr = auth_add_realm(realm_name, realm_type, user, password);
	mm_free(realm_name);
	mm_free(realm_type);
    }

    if (rr == NULL)
    {
        /* only give error if the find_realm failed, not if the user cancelled */
        if (user)
	    frontend_complain(makeerror(ERR_BAD_AUTH));

	access_http_fetch_done(d, &si);
    }
    else
    {
        d->data.http.had_passwd = 1;        /* flag that we have added a new passwd to the list */
	access_http_auth_rerequest(d, rr);
    }
}

static void access_http_fetch_done(access_handle d, http_status_args *si)
{
    int cache_it;
    char *cfile;
#if 0
    fprintf(stderr, "Transfer complete for %s\n", d->url);
#endif
    /* Time to stop */

    cfile = strdup(si->out.fname);

    /* Temporary insertion in case the url is re-requested inside the completed call (e.g. for a GIF) */
    cache->insert(d->url, cfile, cache_flag_OURS | (si->out.data_size == -1 ? cache_flag_IGNORE_SIZE : 0));

    /* The http close does not need to delete the file as we have already if it was removed from the cache */
    access_http_close(d->transport_handle, http_close_DELETE_BODY );

    if (d->complete)
	cache_it = d->complete(d->h, si->out.status, cfile, d->url);
    else
	cache_it = 0;

    access_done_flag = 1;

    if (si->out.status == status_COMPLETED_FILE && si->out.rc == 200 )
    {
	if ( cache_it & access_KEEP )
	    cache->keep(d->url);
    }

    if (cache_it & access_OURS)
	cache->not_ours(cfile);

    /* It was put in the cache before the completed call but we take it out if we don't need it */
    if ((si->out.status != status_COMPLETED_FILE) ||
	(si->out.rc != 200) ||
	((cache_it & access_CACHE) == 0) )
    {
	cache->remove(d->url);
    }
    else
    {   /* might have to reread size at this point */
        if (si->out.data_size == -1 && cache->update_size)
            cache->update_size(cfile);
    }

    mm_free(cfile);

    /* Optionally update cookies and users if new ones were added */
    if (config_cookie_uptodate && d->data.http.cookie_count)
        cookie_write_file(config_cookie_file);

    if (d->data.http.had_passwd && config_passwords_uptodate)
        auth_write_realms(config_auth_file, config_auth_file_crypt ? auth_passwd_UUCODE : auth_passwd_PLAIN);

    access_unlink(d);
    access_free_item(d);
}

static void access_http_fetch_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    http_status_args si;

    si.in.handle = d->transport_handle;

    os_swix(HTTP_Status, (os_regset *) &si);

#if DEBUG
    fprintf(stderr, "HTTP status %d\n", si.out.status);
#endif

    if ((si.out.status >= status_GETTING_BODY) && (d->ft_is_set == 0) )
    {
	http_setfiletype_args httpft;

	httpft.in.handle = d->transport_handle;
	os_swix(HTTP_SetFileType, (os_regset *) &httpft);

	d->ftype = httpft.out.ftype;
	d->ft_is_set = 1;
    }

    if (si.out.status >= status_COMPLETED_FILE)
    {
	http_header_item *list;

#if DUMP_HEADERS
	fprintf(stderr, "\nHeaders...\n");
	for (list = si.out.headers; list; list = list->next)
	{
	    fprintf(stderr, "%s: %s\n", list->key, list->value);
	}
	fprintf(stderr, "\n");
#endif
	if ((si.out.rc / 100) == 3)
	{
	    for (list = si.out.headers; list; list = list->next)
	    {
		if (strcasecomp("LOCATION", list->key) == 0)
		{
		    char *new_url;

		    new_url = url_join(d->url, list->value);

		    if (new_url)
		    {
			os_error *ep;

			/* If we use Netscape posting we delete the body and do a GET */
			access_http_close(d->transport_handle,
					  (config_broken_formpost ?
					   http_close_DELETE_FILE | http_close_DELETE_BODY :
					   http_close_DELETE_FILE) );
			d->transport_handle = NULL;

			ep = access_url(new_url, d->flags, d->ofile,
					config_broken_formpost ? NULL : d->data.http.body_file,
					d->url,
					&access_redirect_progress, &access_redirect_complete,
					d, &(d->redirect));

			mm_free(new_url);
			return;
		    }
		}
            }
        }
        else
        {
	    for (list = si.out.headers; list; list = list->next)
	    {
		if (strcasecomp("WINDOW-TARGET", list->key) == 0)
                {
                    d->data.http.windowtarget = strdup(list->value);
                }
		if (config_cookie_enable && strcasecomp("SET-COOKIE", list->key) == 0)
                {
                    cookie_received_header(list->value, d->url);
                    d->data.http.cookie_count++;
                }
	    }
	}

	if (si.out.rc == 401)
	{
	    char *type;
	    char *realm_name;

	    /* Authentication failed.  There are three cases: a) we
	     * have no idea about this realm and we need a new realm
	     * entry, a new mapping to the realm from this URL and
	     * user and passwd data, b) we know about the realm but we
	     * did not know that this URL is in that realm; we need to
	     * add the mapping and c) we think we know both URL and
	     * realm but it seems to be wrong.
	     */

	    if (access_http_find_realm(si.out.headers, &realm_name, &type))
	    {
		realm rr;

		rr = auth_lookup_realm(realm_name);

		mm_free(type);

		if (rr)
		{
		    if (d->data.http.had_auth)
		    {
			frontend_complain(makeerror(ERR_BAD_PASSWD));
			rr = NULL;
		    }
		}

		if (rr == NULL)
		{
		    char *hname = access_host_name_only(d->url);
		    d->data.http.pw = frontend_passwd_raise(access_http_passwd_callback,
							    d, NULL, realm_name, hname);
		    mm_free(hname);
		}
		else
		{
		    access_http_auth_rerequest(d, rr);
		}

		mm_free(realm_name);

		return;
	    }

	    /* If we can't authenticate, just show the error to the user */
	}

	access_http_fetch_done(d, &si);
    }
    else
    {
	int readable = d->ft_is_set && ((si.out.rc / 100) == 2);

	/* Keep going */
	if (d->progress)
	    d->progress(d->h, si.out.status, si.out.data_size, si.out.data_so_far, si.out.ro_fh, readable ? d->ftype : -1, d->url );
	access_reschedule(&access_http_fetch_alarm, d, POLL_INTERVAL);
    }
}

static void access_gopher_dns_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    int status;
    os_error *ep;

    ep = netloc_resolve(d->dest_host, 70, &status, &d->addr);
    if (ep)
    {
	if (d->complete)
	    d->complete(d->h,status_FAIL_DNS, NULL, d->url);

	access_done_flag = 1;

	access_unlink(d);
	access_free_item(d);

	return;
    }

    if (status == 0)
    {
	ep = access_gopher_fetch_start(d);
	if (ep == NULL)
	{
	    if (d->progress)
		d->progress(d->h, status_CONNECTING, -1, -1, 0, -1, NULL);
	    access_reschedule(&access_gopher_fetch_alarm, d, POLL_INTERVAL);
	}
	else
	{
	    if (d->complete)
		d->complete(d->h, status_FAIL_CONNECT, NULL, d->url);

	    access_done_flag = 1;

	    access_unlink(d);
	    access_free_item(d);
	}
    }
    else
    {
	if (d->progress)
	    d->progress(d->h, status_DNS, -1, -1, 0, -1, NULL);
	access_reschedule(&access_gopher_dns_alarm, d, POLL_INTERVAL);
    }
}

static void access_gopher_fetch_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    gopher_status_args gos;
    int cache_it;
    os_error *ep;
    char *cfile;

    gos.in.handle = d->transport_handle;

    ep = os_swix(WebGopher_Status, (os_regset *) &gos);

    if (ep)
    {
#if 0
	fprintf(stderr, "WebGopher_Status: %s\n", ep->errmess);
#endif
	gos.out.status = status_FAIL_REQUEST;
    }

    if ((gos.out.status >= status_GETTING_BODY) && (d->ft_is_set == 0) )
    {
	int ft;
	gopher_set_file_type(gos.out.fname, d->data.gopher.gopher_tag, &ft);
	d->ftype = (short) ft;
	d->ft_is_set = 1;
    }

    if (gos.out.status >= status_COMPLETED_FILE)
    {
#if 0
	fprintf(stderr, "Transfer complete for %s\n", d->url);
#endif
	/* Time to stop */

	cfile = strdup(gos.out.fname);

	/* Temporary insertion in case the url is re-requested inside the completed call (e.g. for a GIF) */
	cache->insert(d->url, cfile, cache_flag_OURS);

	/* The http close does not need to delete the file as we have already if it was removed from the cache */
	access_gopher_close(d->transport_handle, 0);

	if (d->complete)
	    cache_it = d->complete(d->h, gos.out.status, cfile, d->url);
	else
	    cache_it = 0;

	access_done_flag = 1;

	if (gos.out.status == status_COMPLETED_FILE )
	{
	    if ( cache_it & access_KEEP )
		cache->keep(d->url);
	}

	if (cache_it & access_OURS)
	    cache->not_ours(cfile);

	/* It was put in the cache before the completed call but we take it out if we don't need it */
	if (gos.out.status != status_COMPLETED_FILE || (cache_it & access_CACHE) == 0)
	    cache->remove(d->url);

        mm_free(cfile);

	access_unlink(d);

	access_free_item(d);
    }
    else
    {
	int readable = d->ft_is_set;

	/* Keep going */
	if (d->progress)
	    d->progress(d->h, gos.out.status, -1, gos.out.data_so_far, gos.out.ro_fh, readable ? d->ftype : -1, d->url );
	access_reschedule(&access_gopher_fetch_alarm, d, POLL_INTERVAL);
    }
}

static void access_ftp_dns_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    int status;
    os_error *ep;
#if 0
    fprintf(stderr, "Resolving name '%s'\n", d->dest_host);
#endif
    ep = netloc_resolve(d->dest_host, 21, &status, &d->addr);
    if (ep)
    {
	if (d->complete)
	    d->complete(d->h,status_FAIL_DNS, NULL, d->url);

	access_done_flag = 1;

	access_unlink(d);
	access_free_item(d);

	return;
    }

    if (status == 0)
    {
#if 0
	fprintf(stderr, "Got address\n");
#endif
	ep = access_ftp_fetch_start(d);
	if (ep == NULL)
	{
	    if (d->progress)
		d->progress(d->h, status_CONNECTING, -1, -1, 0, -1, NULL);
	    access_reschedule(&access_ftp_fetch_alarm, d, POLL_INTERVAL);
	}
	else
	{
	    fprintf(stderr, "Failed connection wirth error '%s'\n", ep->errmess);

	    if (d->complete)
		d->complete(d->h, status_FAIL_CONNECT, NULL, d->url);

	    access_done_flag = 1;

	    access_unlink(d);
	    access_free_item(d);
	}
    }
    else
    {
#if 0
	fprintf(stderr, "Name not here yet\n");
#endif
	if (d->progress)
	    d->progress(d->h, status_DNS, -1, -1, 0, -1, NULL);
	access_reschedule(&access_ftp_dns_alarm, d, POLL_INTERVAL);
    }
}

static void access_ftp_fetch_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    ftp_status_args ftps;
    int cache_it;
    os_regset *rs = (os_regset *) &ftps;
    os_error *ep = NULL;
    int status;
#if 0
    fprintf(stderr, "Getting connection status\n");
#endif
    ftps.in.session = d->transport_handle;

    ep = os_swix(WebFTP_Status, rs);

    if (ep)
    {
#if 0
	fprintf(stderr, "WebFTP_Status: %s\n", ep->errmess);
#endif
	ftps.out.status = status_FAIL_REQUEST;
    }

    status = ftps.out.status;

    if ((status >= status_GETTING_BODY) && (d->ft_is_set == 0) )
    {
	char *slash = strrchr(d->url, '/');
	char *dot = strrchr(d->url, '.');
	int ft = -1;

	if ((status == status_COMPLETED_DIR) ||
	    (status == status_GETTING_DIRECTORY) )
	    ft = FILETYPE_HTML;
	else if (status == status_FAIL_REQUEST)
	    ft = FILETYPE_TEXT;
	else
	{
	    if (dot && (slash == NULL || slash < dot))
		ft = suffix_to_file_type(dot+1);

	    if (ft == -1)
	    {
		char *end;

		dot = strrchr(d->url, ',');
		if (dot && (slash == NULL || slash < dot))
		{
		    ft = (int) strtol(dot+1, &end, 16);
		    if (*end != 0 || end != (dot+4))
			ft = -1;
		}

		if (ft == -1)
		    ft = FILETYPE_TEXT;
	    }
	}

	set_file_type(ftps.out.local_name, ft);
	d->ftype = ft;
	d->ft_is_set = 1;
    }

    if (status >= status_COMPLETED_FILE)
    {
	char *cfile;

#if 0
	fprintf(stderr, "Transfer complete for %s\n", d->url);
#endif
	/* Time to stop */

	cfile = strdup(ftps.out.local_name);

	/* Temporary insertion in case the url is re-requested inside the completed call (e.g. for a GIF) */
	cache->insert(d->url, cfile, cache_flag_OURS);

#if 1
	/* The ftp close does not need to delete the file as we have already if it was removed from the cache */
	access_ftp_close(d->transport_handle, 0);
#endif

	if (status == status_COMPLETED_DIR)
	    status = status_COMPLETED_FILE;

	if (d->complete)
	    cache_it = d->complete(d->h, status, cfile, d->url);
	else
	    cache_it = 0;

	access_done_flag = 1;

	if (status == status_COMPLETED_FILE || status == status_COMPLETED_DIR )
	{
	    if ( cache_it & access_KEEP )
		cache->keep(d->url);
	}

	if (cache_it & access_OURS)
	    cache->not_ours(cfile);

	/* It was put in the cache before the completed call but we take it out if we don't need it */
	if (((status != status_COMPLETED_FILE) &&
	     (status != status_COMPLETED_DIR) ) ||
	    (cache_it & access_CACHE) == 0 )
	    cache->remove(d->url);
#if 0
	/* The ftp close does not need to delete the file as we have already if it was removed from the cache */
	access_ftp_close(d->transport_handle, 0);
#endif
	mm_free(cfile);

        if (d->data.ftp.had_passwd && config_passwords_uptodate)
            auth_write_realms(config_auth_file, config_auth_file_crypt ? auth_passwd_UUCODE : auth_passwd_PLAIN);

	access_unlink(d);

	access_free_item(d);
    }
    else
    {
	int readable = d->ft_is_set;

	/* Keep going */
	if (d->progress)
	    d->progress(d->h, status, ftps.out.data_total, ftps.out.data_so_far, ftps.out.ro_handle, readable ? d->ftype : -1, d->url );
	access_reschedule(&access_ftp_fetch_alarm, d, POLL_INTERVAL);
    }
}

static int access_ftp_check_pw(char *netloc, char **userp, char **pwdp, char **hostp)
{
    char *user;
    char *passwd;
    char *host;
    char *at, *colon;
#if 0
    fprintf(stderr, "Looking for user id and password in '%s'\n", netloc);
#endif
    at = strchr(netloc, '@');
    if (at)
    {
	*at = 0;
	host = strdup(at + 1);
	colon = strchr(netloc, ':');
	if (colon)
	{
	    *colon = 0;
	    passwd = strdup(colon + 1);
	}
	else
	    passwd = NULL;
	user = strdup(netloc);
    }
    else
    {
	user = strdup("anonymous");
	if (config_email_addr)
	    passwd = strdup(config_email_addr);
	else
	{
	    char buffer[64];
	    char buffer2[64];
	    char *p;
	    int len;

	    strcpy(buffer, PROGRAM_NAME"@");
	    len = strlen(buffer);

	    /* Read an old style host name */
	    os_read_var_val("Inet$HostName", buffer + len, sizeof(buffer) - len);
	    /* Read a new style domain */
	    os_read_var_val("Inet$LocalDomain", buffer2, sizeof(buffer));
	    /* If we have a new style domain */
	    if (buffer2[0])
	    {
		if ((p = strchr(buffer, '.')) != NULL)
		{
		    /* If the host name has a dot the overwrite the tail */
		    strcpy(p + 1, buffer2);
		}
		else
		{
		    /* If there is no dot append one if there was something and then append the domain name */
		    if (buffer[len] != 0)
			strcat(buffer, ".");
		    strcat(buffer, buffer2);
		}
	    }
	    /* After all that, if there is no host name then remove the '@' */
	    if (buffer[len] == 0)
		buffer[len-1] = 0;

	    passwd = strdup(buffer);
	}
	host = strdup(netloc);
    }
#if 0
    fprintf(stderr, "User='%s', passwd='%s', host='%s'\n",
	    user, passwd ? passwd : "<none>", host);
#endif
    if (hostp)
	*hostp = host;
    else
	mm_free(host);

    if (userp)
	*userp = user;
    else
	mm_free(user);

    if (pwdp)
	*pwdp = passwd;
    else
	mm_free(passwd);

    return (passwd != NULL);
}

static void access_copy_data(int inf, int outf, int start, int end)
{
    os_gbpbstr gps;
    char buffer[1024];
    int len;

    while (start < end)
    {
	len = end - start;
	if (len > sizeof(buffer))
	    len = sizeof(buffer);

	gps.action = 3;
	gps.file_handle = inf;
	gps.data_addr = buffer;
	gps.number = len;
	gps.seq_point = start;

	os_gbpb(&gps);

	gps.action = 1;
	gps.file_handle = outf;
	gps.data_addr = buffer;
	gps.number = len;
	gps.seq_point = start;

	os_gbpb(&gps);

	start += len;
    }
}

static void access_file_fetch_alarm(int at, void *h)
{
    access_handle d = (access_handle) h;
    os_regset r;

    if ( !(d->progress) || (d->data.file.so_far + d->data.file.chunk >= d->data.file.size))
    {
	if (d->data.file.ofh)
	{
	    access_copy_data(d->data.file.fh, d->data.file.ofh,
			     d->data.file.so_far, d->data.file.size);
	}

	/* We are done */
	if (d->data.file.fh)
	{
	    r.r[0] = 0;
	    r.r[1] = d->data.file.fh;
	    os_find(&r);
	    d->data.file.fh = 0;
	}

	if (d->data.file.ofh)
	{
	    r.r[0] = 0;
	    r.r[1] = d->data.file.ofh;
	    os_find(&r);
	    d->data.file.ofh = 0;
	}

	d->complete(d->h, status_COMPLETED_FILE, d->ofile ? d->ofile : d->data.file.fname, d->url);

	access_unlink(d);
	access_free_item(d);
    }
    else
    {
	/* More to do */
	if (d->data.file.ofh)
	{
	    access_copy_data(d->data.file.fh, d->data.file.ofh,
			     d->data.file.so_far, d->data.file.so_far + d->data.file.chunk);
	}

	d->data.file.so_far += d->data.file.chunk;

	d->progress(d->h, status_GETTING_BODY,
		    d->data.file.size, d->data.file.so_far,
		    d->data.file.ofh ? d->data.file.ofh : d->data.file.fh,
		    d->ftype, d->url );
	if (d->data.file.chunk < FILE_MAX_CHUNK)
	    d->data.file.chunk <<= 1;
	access_reschedule(&access_file_fetch_alarm, d, FILE_POLL_INTERVAL);
    }
}

int access_url_type_and_size(char *url, int *ftypep, int *sizep)
{
    char *scheme, *netloc, *path, *params, *query, *fragment;
    char *cfile, *cfile1;
    int ft = -1;

    *sizep = 0;

    cfile1 = cache->lookup(url);     /* cfile1 is original ptr so it can be freed */
    cfile = cfile1;

    url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);

    if (cfile == NULL && (strcasecomp(scheme, "file") == 0))
    {
	cfile = url_path_to_riscos(path);

	if (path_is_directory(cfile))
	{
	    *ftypep = FILETYPE_HTML;
	    return 0;
	}
    }

    if (cfile == NULL && (strcasecomp(scheme, "icontype") == 0))
    {
	*ftypep = FILETYPE_SPRITE;
	*sizep = 488;		/* They should all be this size if they have a mask */

	return 0;
    }

    if (cfile)
    {
	os_filestr ofs;
	os_error *ep;
	os_regset r;

	ofs.action = 5;
	ofs.name = cfile;

	ep = os_file(&ofs);

	if (ep == 0)
	    *sizep = ofs.start;

	if (ep || (ofs.action != 1 && ofs.action != 3))
	    ft = -1;
	else
	{
	    r.r[0] = 38;
	    r.r[1] = (int) ofs.name;
	    r.r[2] = ofs.loadaddr;
	    r.r[3] = ofs.execaddr;
	    r.r[4] = ofs.start;
	    r.r[5] = ofs.end;
	    r.r[6] = 1;

	    ep = os_swix(OS_FSControl, &r);
	    if (ep)
		ft = -1;
	    else
		ft = r.r[2];
	}
    }

    if (ft == -1)
    {
       	char *dot, *slash;

	slash = strrchr(path, '/');
	dot = strrchr(path, '.');

	if (dot != NULL && slash < dot && dot[1] != 0)
	{
	    dot++;

	    ft = suffix_to_file_type(dot);
	}
    }

    *ftypep = ft;

    url_free_parts(scheme, netloc, path, params, query, fragment);

    cache->lookup_free_name(cfile1);

    return (cfile != NULL);
}

static int access_match_host(char *host, char *matchlist)
{
    char *list;
    char *p;
    int hit;
    int len, l2;

    /* Skip past any user name or password */
    p = strchr(host, '@');
    if (p)
	host = p+1;

    /* No list? No match. */
    if (matchlist == 0)
	return 0;

    /* Better take a copy; strtok mangles the string */
    list = strdup(matchlist);
    /* And we are about to mangle the net location */
    host = strdup(host);

    /* Stop at a colon */
    p = strchr(host, ':');
    if (p)
	*p = 0;

    /* We need the length lots for doing tail matches */
    len = strlen(host);

    hit = 0;
    /* Let the domains be comma or space sepatared */
    p = strtok(list, " ,\n");

    while (p && !hit)
    {
	l2 = strlen(p);
	/* It's a hit is it's long enough for a tail match and we have such a match */
	hit = ((l2 <= len) && (strcasecomp(p, host + len - l2) == 0));

	/* If we hit save the bother of another token */
	if (!hit)
	    p = strtok(NULL, " ,\n");
    }

    mm_free(list);
    mm_free(host);

    return hit;
}

static os_error *access_new_http(char *url, access_url_flags flags, char *ofile, char *bfile, char *referer,
				 access_progress_fn progress, access_complete_fn complete,
				 void *h, access_handle *result, char *dest_host, char *request_string)
{
    access_handle d;
#if 0
    fprintf(stderr, "Making new access object\n");
#endif
    d = mm_calloc(1, sizeof(*d));

    d->access_type = access_type_HTTP;
    d->flags = flags;
    d->url = strdup(url);
    if (ofile)
	d->ofile = strdup(ofile);
    d->referer = strdup(referer);
    d->data.http.body_file = strdup(bfile);
    d->progress = progress;
    d->complete = complete;
    d->h = h;

    d->dest_host = strdup(dest_host);
    d->request_string = strdup(request_string);

    access_link(d);

    *result = d;

    access_done_flag = 0;

    access_http_dns_alarm(0, d);

    if (flags & access_FORGROUND)
    {
	while (!access_done_flag)
	    d->next_fn(0, d);
	*result = 0;
    }

    return NULL;
}

static os_error *access_new_ftp(char *url, access_url_flags flags, char *ofile, char *referer,
				access_progress_fn progress, access_complete_fn complete,
				void *h, access_handle *result, char *netloc, char *path)
{
    access_handle d;
    os_error *ep = NULL;

    if (config_proxy_ftp_on &&
	config_proxy_ftp &&
	!access_match_host(netloc, config_proxy_ftp_ignore))
    {
	char *aurl;

	aurl = url_unparse("ftp", netloc, path, 0, 0, 0);

	ep = access_new_http(url, flags, ofile, NULL, referer,
			     progress, complete, h,
			     result, config_proxy_ftp, aurl);
	mm_free(aurl);
    }
    else
    {
#if 0
	fprintf(stderr, "FTP access\n");
	fprintf(stderr, "Making new access object\n");
#endif
	d = mm_calloc(1, sizeof(*d));

	d->access_type = access_type_FTP;
	d->flags = flags;
	d->url = strdup(url);
	if (ofile)
	    d->ofile = strdup(ofile);
	d->progress = progress;
	d->complete = complete;
	d->h = h;
	access_link(d);

	if (access_ftp_check_pw(netloc, &(d->data.ftp.user), &(d->data.ftp.passwd),
				&(d->dest_host) ) == 0)
	{
	    d->data.ftp.passwd = strdup("");
	}

	d->request_string = strdup(path ? path : "/");
#if 0
	fprintf(stderr, "Host '%s'\nRequest '%s'\nUser '%s'\nPasswd '%s'\n",
		d->dest_host, d->request_string, d->data.ftp.user, d->data.ftp.passwd);
#endif
	*result = d;

	access_done_flag = 0;

	access_ftp_dns_alarm(0, d);

	if (flags & access_FORGROUND)
	{
	    while (!access_done_flag)
		d->next_fn(0, d);
	    *result = 0;
	}
    }

    return ep;
}

void access_ftp_passwd_callback(fe_passwd pw, void *handle, char *user, char *password)
{
    access_handle d = (access_handle) handle;
    realm rr = NULL;
    char *realm_name;
    char *scheme, *netloc, *path, *params, *query, *fragment;

    url_parse(d->url, &scheme, &netloc, &path, &params, &query, &fragment);

    realm_name = url_unparse(scheme, netloc, 0, 0, 0, 0);
#if 0
    fprintf(stderr, "New realm: %s\n", realm_name);
#endif
    d->data.ftp.pw = NULL;

    if (user)
    {
	rr = auth_add_realm(realm_name, "BASIC", user, password);
    }

    if (rr == NULL)
    {
	frontend_complain(makeerror(ERR_BAD_AUTH));
	/* @@@@ What do we do here ? */
	d->complete(d->h, status_FAIL_PASSWORD, NULL, d->url);

	access_done_flag = 1;

	access_unlink(d);
	access_free_item(d);
    }
    else
    {
	auth_add(realm_name, rr);
	d->data.ftp.had_passwd = 1;

	access_url(d->url, d->flags, d->ofile, NULL, d->url,
		   &access_redirect_progress, &access_redirect_complete, d, &(d->redirect));
    }

    mm_free(realm_name);
    url_free_parts(scheme, netloc, path, params, query, fragment);
}

static os_error *access_ftp_login(char *url, access_url_flags flags, char *ofile, char *referer,
				  access_progress_fn progress, access_complete_fn complete,
				  void *h, access_handle *result, char *user, char *path)
{
    access_handle d;
    os_error *ep = NULL;
    char *hname = access_host_name_only(url);

#if 0
    fprintf(stderr, "FTP login\n");
    fprintf(stderr, "Making new access object\n");
#endif
    d = mm_calloc(1, sizeof(*d));

    d->access_type = access_type_FTP;
    d->flags = flags;
    d->url = strdup(url);
    if (ofile)
	d->ofile = strdup(ofile);
    d->progress = progress;
    d->complete = complete;
    d->h = h;
    access_link(d);

    d->data.ftp.pw = frontend_passwd_raise(access_ftp_passwd_callback, d, user, "FTP", hname);

    mm_free(hname);

    *result = d;

    return ep;
}

os_error *access_url(char *url, access_url_flags flags, char *ofile, char *bfile, char *referer,
		     access_progress_fn progress, access_complete_fn complete,
		     void *h, access_handle *result)
{
    access_handle d;
    char *cfile;
    os_error *ep = NULL;

    visdelay_begin();

    fprintf(stderr, "access_url: %s from %s\n", url, referer ? referer : "<none>" );

    *result = 0;

    if (flags & access_NOCACHE)
    {
	cache->remove(url);
	cfile = NULL;
    }
    else
	cfile = cache->lookup(url);

    if (cfile)
    {
	FILE *f;
#if 1
	fprintf(stderr, "Cache hit on '%s'... testing if the file is still there.\n", cfile);
#endif
	f = fopen(cfile, "r");
	if (f)
	    fclose(f);
	else
	{
	    fprintf(stderr, "File not there, removing the cache entry.\n");

	    cache->remove(url);

	    cache->lookup_free_name(cfile);
	    cfile = NULL;
	}
    }

    if (cfile)
    {
	access_complete_flags fl;
	*result = NULL;
#if 0
	fprintf(stderr, "Cache hit... returning the cache file\n");
#endif

	if (ofile)
	{
	    os_regset r;

	    r.r[0] = 26;
	    r.r[1] = (int) cfile;
	    r.r[2] = (int) ofile;
	    r.r[3] = (1 << 1);		/* Ensure files are overwriten */

	    ep = os_swix(OS_FSControl, &r);
	}
	else
	    ep = NULL;

	if (ep == NULL)
	{
	    fl = complete(h, status_COMPLETED_FILE, ofile ? ofile : cfile, url);

	    if (fl & access_KEEP)
	    {
		cache->keep(url);
	    }
	}

	cache->lookup_free_name(cfile);
    }
    else
    {
	char *scheme, *netloc, *path, *params, *query, *fragment;

	url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);
#if 0
	fprintf(stderr, "Cache miss... trying to fetch file\n");
#endif

	if (netloc && netloc[0] && (config_allow_file || config_deny_file))
	{
	    if (!auth_check_allow_deny(netloc))
	    {
		ep = makeerror(ERR_ACCESS_DENIED);
	    }
	}

	if (ep)
	{
	    /* Pass on trying to handle URL.  We can't just return because we need to tidy up */
	}
	else if (strcasecomp(scheme, "file") == 0)
	{
	    int ft;
	    os_regset r;
	    int fh, ofh=0;

	    ep = NULL;
	    cfile = url_path_to_riscos(path);
	    if (cfile[strlen(cfile)-1] == '.')
		cfile[strlen(cfile)-1] = 0;

	    if (path_is_directory(cfile))
	    {
		char *path;

		path = cfile;
		cfile = strdup(ofile ? ofile : cache->scrapfile_name());

		ep = dir2html(path, cfile, 0);

		if (ep == NULL)
		{
		    access_complete_flags fl;

		    cache->insert(url, cfile, cache_flag_OURS);
		    fl = complete(h, status_COMPLETED_FILE, cfile, url);

		    if (fl & access_OURS)
			cache->not_ours(cfile);

		    if ((fl & access_CACHE) == 0)
			cache->remove(url);
		}

		mm_free(path);
		mm_free(cfile);
		*result = NULL;
	    }
	    else
	    {
		ft = file_type(cfile);

		if (ft == FILETYPE_URL)
		{
		    char new_url[256];
		    FILE *fh;

		    fh = fopen(cfile, "r");
		    if (fh && (fgets(new_url, sizeof(new_url), fh)))
		    {
			d = mm_calloc(1, sizeof(*d));

			d->access_type = access_type_FILE;
			d->flags = flags;
			d->url = strdup(url);
			d->ofile = strdup(ofile);

			d->progress = progress;
			d->complete = complete;
			d->h = h;
			access_link(d);

			ep = access_url(new_url, d->flags, d->ofile, NULL, referer,
					&access_redirect_progress, &access_redirect_complete,
					d, &(d->redirect));
		    }
		    else
		    {
			ep = makeerror(ERR_CANT_READ_FILE);
		    }

		    if (fh)
			fclose(fh);
		}
		else
		{
		    if (ft == -1)
		    {
			char *slash = strrchr(cfile, '/');
			char *dot = strrchr(cfile, '.');

			if (slash && (dot == NULL || dot < slash))
			{
			    *slash = 0;

			    if (suffix_to_file_type(slash+1) == (ft = file_type(cfile)) )
				ep = NULL;
			    else
				ep = makeerror(ERR_CANT_READ_FILE);
			}
			else
			{
			    ep = makeerror(ERR_CANT_READ_FILE);
			}
		    }

		    /* SJM: changed #if to be based on file type */
		    if (ft != FILETYPE_HTML && ft != FILETYPE_GOPHER && ft != FILETYPE_TEXT && !image_type_test(ft))
		    {
			if (ep == NULL)
			    complete(h, status_COMPLETED_FILE, cfile, url);

			mm_free(cfile);
			*result = NULL;
		    }
		    else
		    {
			r.r[0] = 0x4f;
			r.r[1] = (int) cfile;

			ep = os_find(&r);

			if (ep == NULL)
			    fh = r.r[0];
			else
			    fh = 0;

			if (ep == NULL && ofile)
			{
			    r.r[0] = 0x8f;
			    r.r[1] = (int) ofile;

			    ep = os_find(&r);

			    ofh = r.r[0];
			}

			if (ep == NULL)
			{
			    d = mm_calloc(1, sizeof(*d));

			    d->access_type = access_type_FILE;
			    d->flags = flags;
			    d->url = strdup(url);
			    if (ofile)
			    {
				d->ofile = strdup(ofile);
				set_file_type(ofile, ft);
			    }
			    d->progress = progress;
			    d->complete = complete;
			    d->h = h;
			    access_link(d);

			    d->data.file.fname = cfile;
			    d->ftype = ft;
			    d->data.file.fh = fh;
			    d->data.file.chunk = FILE_INITIAL_CHUNK;
			    d->data.file.ofh = ofh;

			    r.r[0] = 2;
			    r.r[1] = d->data.file.fh;

			    os_args(&r);

			    d->data.file.size = r.r[2];

			    access_reschedule(&access_file_fetch_alarm, d, FILE_POLL_INTERVAL);

			    *result = d;
			}
			else
			{
			    if (fh)
			    {
				r.r[0] = 0;
				r.r[1] = fh;

				os_find(&r);
			    }
			    mm_free(cfile);
			    *result = NULL;
			}
		    }
		}
	    }
	}
	else if (strcasecomp(scheme, "icontype") == 0)
	{
	    access_complete_flags fl;
	    char sname[32];
#if 0
	    fprintf(stderr, "Fetching icontype '%s'\n", path);
#endif
	    cfile = strdup(ofile ? ofile : cache->scrapfile_name());

	    if (path[0] == ',')
	    {
		sprintf(sname, "small_%s", path+1);
	    }
	    else if (path[0] == '.')
	    {
		int ft = suffix_to_file_type(path+1);

		sprintf(sname, "small_%03x", ft == -1 ? 0xfff : ft);
	    }
	    else if (strcasecomp(path, "directory") == 0)
	    {
		strcpy(sname, "small_dir");
	    }
	    else
	    {
		strcpy(sname, path);
		strcat(sname, "icon");
	    }

	    ep = access_write_wimp_icon(sname, cfile);

	    if (ep == NULL)
	    {
		cache->insert(url, cfile, cache_flag_OURS);

		fl = complete(h, status_COMPLETED_FILE, cfile, url);
	    }
	    else
	    {
		fl = 0;
	    }

	    if (fl & access_OURS)
		cache->not_ours(cfile);

	    if ((fl & access_CACHE) == 0)
		cache->remove(url);

            mm_free(cfile);

	    *result = NULL;
	}
	else if (strcasecomp(scheme, "http") == 0)
	{
	    char buffer[1000];

	    if (config_proxy_http_on &&
		config_proxy_http &&
		!access_match_host(netloc, config_proxy_http_ignore))
	    {
		ep = access_new_http(url, flags, ofile, bfile, referer, progress, complete, h, result, config_proxy_http, url);
	    }
	    else
	    {
		if (path)
		    strcpy(buffer, path);
		else
		    strcpy(buffer, "/");

		if (params)
		{
		    strcat(buffer, ";");
		    strcat(buffer, params);
		}

		if (query)
		{
		    strcat(buffer, "?");
		    strcat(buffer, query);
		}

		ep = access_new_http(url, flags, ofile, bfile, referer, progress, complete, h, result, netloc, buffer);
	    }
	}
	else if (strcasecomp(scheme, "gopher") == 0)
	{
	    if (config_proxy_gopher_on &&
		config_proxy_gopher &&
		!access_match_host(netloc, config_proxy_gopher_ignore))
	    {
		ep = access_new_http(url, flags, ofile, bfile, referer, progress, complete, h, result, config_proxy_gopher, url);
	    }
	    else
	    {
		if (path && path[0] && path[1] == '7' && query == NULL)
		{
		    /* A query link with no request; fake the link page */
		    char *cfile;
		    FILE *fh;

		    cfile = strdup(ofile ? ofile : cache->scrapfile_name());

		    fh = fopen(cfile, "w");
		    if (fh == NULL)
		    {
			*result = 0;
			ep = makeerror(ERR_CANT_READ_FILE);
		    }
		    else
		    {
			access_complete_flags fl;

			fprintf(fh, "<h1>Searchable Gopher Index</h1><isindex>\n");
			fclose(fh);

			set_file_type(cfile, FILETYPE_HTML);

			*result = NULL;

			fl = complete(h, status_COMPLETED_FILE, cfile, url);

			if (fl & access_CACHE)
			{
			    cache->insert(url, cfile, cache_flag_OURS);
			}

			if (fl & access_KEEP)
			{
			    cache->keep(url);
			}
		    }

                    mm_free(cfile);
		}
		else
		{
		    char buffer[1000];
#if 0
		    fprintf(stderr, "Making new access object\n");
#endif
		    d = mm_calloc(1, sizeof(*d));

		    d->access_type = access_type_GOPHER;
		    d->flags = flags;
		    d->url = strdup(url);
		    if (ofile)
			d->ofile = strdup(ofile);
		    d->progress = progress;
		    d->complete = complete;
		    d->h = h;
		    access_link(d);

		    d->dest_host = strdup(netloc);

		    if (path && path[0] && path[1])
		    {
			translate_escaped_text(path + 2, buffer, sizeof(buffer));
			d->data.gopher.gopher_tag = path[1];
		    }
		    else
		    {
			buffer[0] = 0;
			d->data.gopher.gopher_tag = '1';
		    }

		    if (query)
		    {
			char *eq;

			strcat(buffer, "\t");

			eq = strchr(query, '=');
			if (eq)
			{
			    strcat(buffer, eq+1);
			}
			else
			{
			    strcat(buffer, query);
			}
		    }

		    d->request_string = strdup(buffer);

		    *result = d;

		    access_done_flag = 0;

		    access_gopher_dns_alarm(0, d);

		    if (flags & access_FORGROUND)
		    {
			while (!access_done_flag)
			    d->next_fn(0, d);
			*result = 0;
		    }
		}
	    }
	}
	else if (strcasecomp(scheme, "ftp") == 0 /* && path[strlen(path)-1] != '/' */ )
	{
	    char *at, *colon;

	    at = strchr(netloc, '@');
	    colon = strchr(netloc, ':');

	    if (at && (colon == 0 || colon > at))
	    {
		auth_type type;
		auth_lookup_result r;
		char *user;
		char *passwd;
		realm rr;
#if 0
		fprintf(stderr, "Need to find a password\n");
#endif
		r = auth_lookup(url, &type, &user, &passwd);

		if (r != auth_lookup_SUCCESS)
		{
		    char temp[256];
		    sprintf(temp, "ftp://%s/", netloc);

		    rr = auth_lookup_realm(temp);

		    if (rr)
		    {
			auth_add(temp, rr);
			r = auth_lookup(url, &type, &user, &passwd);
		    }
		}

		if (r == auth_lookup_SUCCESS)
		{
		    char nlbuf[512];

		    sprintf(nlbuf, "%s%s%s@%s",
			    user,
			    passwd ? ":" : "",
			    passwd ? passwd : "",
			    at+1 );
#if 0
		    fprintf(stderr, "Password lookup succeded, new netloc is '%s'\n", nlbuf);
#endif
		    ep = access_new_ftp(url, flags, ofile, referer,
					progress, complete, h,
					result, nlbuf, path);
		}
		else
		{
		    *at = 0;
		    ep = access_ftp_login(url, flags, ofile, referer,
					  progress, complete, h,
					  result, netloc, path);
		}
	    }
	    else
	    {
		ep = access_new_ftp(url, flags, ofile, referer,
				    progress, complete, h,
				    result, netloc, path);
	    }
	}
	else
	{
	    /* If we get here then the transport is unknown */
	    frontend_url_punt(url, bfile);

	    ep = makeerror(ERR_USED_HELPER);
	}
#if 0
	fprintf(stderr, "Freeing parts\n");
#endif
	url_free_parts(scheme, netloc, path, params, query, fragment);
    }

    visdelay_end();

    return ep;
}

static os_error *access_cache_init(int size)
{
    char *scrap;

    cache = &old_cache_functions;

    scrap = getenv("Wimp$ScrapDir");
    if (scrap == NULL || scrap[0] == 0)
	return makeerror(ERR_NO_SCRAP_DIR);

/*    if (strncasecomp(scrap, "cache:", 6) == 0) */
    if (config_cache_items > 75)
        cache = &cachefs_cache_functions;

    return cache->init(size);
}

os_error *access_init(int size)
{
    os_error *ep;

    access_pending_list = NULL;

    ep = access_cache_init(size);

    if (!ep && config_cookie_enable)
        cookie_read_file(config_cookie_file);

    return ep;
}

int access_safe_to_quit(void)
{
    return (access_pending_list == NULL);
}

os_error *access_tidyup(void)
{
    access_handle d;

    d = access_pending_list;

    while (d)
    {
	access_handle dd = d->next;

	switch (d->access_type)
	{
	case access_type_HTTP:
	    if (d->transport_handle)
		access_http_close(d->transport_handle, http_close_DELETE_FILE | http_close_DELETE_BODY );
	    if (d->data.http.pw)
		frontend_passwd_dispose(d->data.http.pw);
	    break;
	case access_type_GOPHER:
	    if (d->transport_handle)
		access_gopher_close(d->transport_handle, http_close_DELETE_FILE);
	    break;
	case access_type_FTP:
	    if (d->transport_handle)
		access_ftp_close(d->transport_handle, http_close_DELETE_FILE);
	    if (d->data.ftp.pw)
		frontend_passwd_dispose(d->data.ftp.pw);
	    break;
	case access_type_FILE:
	    if (d->data.file.fh)
	    {
		os_regset r;

		r.r[0] = 0;
		r.r[1] = d->data.file.fh;
		os_find(&r);
		d->data.file.fh = 0;
	    }
	    break;
	}

	access_free_item(d);

	d = dd;
    }

    if (cache)
        cache->tidyup();

    if (config_cookie_enable)
        cookie_write_file(config_cookie_file);

    return NULL;
}

os_error *access_abort(access_handle d)
{
#if 1
    fprintf(stderr, "Access_abort called\n");
#endif
    if (d->redirect)
    {
#if 1
	fprintf(stderr, "Aborting redirection\n");
#endif
	access_abort(d->redirect);
    }

#if 1
    fprintf(stderr, "Removing alarms\n");
#endif
    alarm_removeall(d);
    /* If alarms were asyncronouse we would have to use this order */
#if 1
    fprintf(stderr, "Unlinking\n");
#endif
    access_unlink(d);

    switch (d->access_type)
    {
    case access_type_HTTP:
#if 1
	fprintf(stderr, "Aborting HTTP\n");
#endif
	if (d->transport_handle)
	    access_http_close(d->transport_handle, http_close_DELETE_FILE | http_close_DELETE_BODY );
	if (d->data.http.pw)
	    frontend_passwd_dispose(d->data.http.pw);
	break;
    case access_type_GOPHER:
#if 1
	fprintf(stderr, "Aborting Gopher\n");
#endif
	if (d->transport_handle)
	    access_gopher_close(d->transport_handle, http_close_DELETE_FILE);
	break;
    case access_type_FTP:
#if 1
	fprintf(stderr, "Aborting FTP\n");
#endif
	if (d->transport_handle)
	    access_ftp_close(d->transport_handle, http_close_DELETE_FILE);
	if (d->data.ftp.pw)
	    frontend_passwd_dispose(d->data.ftp.pw);
	break;
    case access_type_FILE:
#if 1
	fprintf(stderr, "Aborting FTP\n");
#endif
	if (d->data.file.fh)
	{
	    os_regset r;

	    r.r[0] = 0;
	    r.r[1] = d->data.file.fh;
	    os_find(&r);
	}
	break;
    }

#if 1
    fprintf(stderr, "About to free the access item\n");
#endif

    access_free_item(d);

#if 1
    fprintf(stderr, "Access_abort done.\n");
#endif

    return NULL;
}

/* wrappers for exporting cache functions */

void access_unkeep(char *url)
{
    cache->unkeep(url);
}

void access_remove(char *url)
{
    cache->remove(url);
}

void access_insert(char *url, char *file_name, cache_flags flags)
{
    cache->insert(url, file_name, flags);
}

char *access_scrapfile(void)
{
    return cache->scrapfile_name();
}

int access_test_cache(char *url)
{
    return cache->test(url);
}

/* eof access.c */
