/* -*-c-*- */

/* WIMP code for the ANTWeb WWW browser */

#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <locale.h>

#include "memwatch.h"

#include "coords.h"
#include "wimp.h"
#include "res.h"
#include "resspr.h"
#include "bbc.h"
#include "msgs.h"
#include "akbd.h"
#include "font.h"
#include "swis.h"
#include "alarm.h"
#include "kernel.h"
#include "flex.h"
#include "colourtran.h"
#include "visdelay.h"
#include "pointer.h"

#include "template.h"

#include "interface.h"
#include "access.h"
#include "stbview.h"
#include "webfonts.h"
#include "url.h"
#include "util.h"
#include "makeerror.h"
#include "images.h"
#include "urlopen.h"
#include "htmlpdtd.h"

#include "status.h"

#include "filetypes.h"
#include "consts.h"
#include "auth.h"
#include "hotlist.h"
#include "config.h"
#include "version.h"
#include "licence.h"
#include "rcolours.h"

#include "http.h"
#include "cookie.h"

#include "clipboard.h"
#include "printing.h"

#include "stbstatus.h"
#include "stbutils.h"
#include "stbmenu.h"
#include "stbhist.h"
#include "stbtb.h"
#include "stbfe.h"
#include "stbopen.h"
#include "fevents.h"

#ifndef NEW_WEBIMAGE
#define NEW_WEBIMAGE	1
#endif

#if NEW_WEBIMAGE
#include "libs/webimage/webimage.h"
#endif

#define ROUND(a) (((a)+1)&~1)

/* If HEAPCHECK is non-zero then heavy heap checking is enabled and you need to link with ansilib */
#ifndef HEAPCHECK
#define HEAPCHECK 0
#endif

#ifndef STBWEB_ROM
#define STBWEB_ROM 0
#endif

#define TRACE_FN

#define INFO_POLL_TIME	20	/* centi-seconds */

#define Y_SCROLL(h)     ROUND((h)*4/5)
#define Y_SCROLL_LINE   32
#define X_SCROLL        100

#define INTERNAL_PREFIX         "stbwebinternal:"
#define INTERNAL_PREFIX_SIZE    (sizeof(INTERNAL_PREFIX)-1)

#define SCRIPT_DIR              "<stbweb$dir>.scripts"
#define SCRIPT_LOADURL          SCRIPT_DIR".loadurl"
#define SCRIPT_PASSWD           SCRIPT_DIR".passwd"

#define CLIP_FILE       "<Wimp$ScrapDir>."PROGRAM_NAME"Clip"
#define CLIP_FILE_LEN   sizeof(CLIP_FILE)

/* -------------------------------------------------------------------------- */

#define TaskModule_RegisterService      0x4D302
#define TaskModule_DeRegisterService    0x4D303
#define wimp_MSERVICE                   0x4D300

#define Service_DiallerStatus           0xB4

#define dialler_DISCONNECTED            0
#define dialler_CONNECTED_OUTGOING      (1<<2)

/* -------------------------------------------------------------------------- */

//extern int strcasecomp(char *s1, char *s2);
//extern int strncasecomp(char *s1, char *s2, int n);

extern void parse_frames(int yes);
extern void image_get_cooler_table(void);

static void fe_drag(const wimp_mousestr *m);
static BOOL fe_resize(const wimp_mousestr *m);
static void fe_status_mode(fe_view v, int mode);

static int fe_check_download_finished(fe_view v);
static void check_pending_scroll(fe_view v);

static int fe_check_resize(fe_view start, int x, int y, wimp_box *box, int *handle, fe_view *resizing_v);
static os_error *fe_find_decode(const char *data);

static void fe_passwd_abort(void);
static void fe_passwd_decode(const char *query);

/* -------------------------------------------------------------------------- */

static wimp_t task_handle;

static BOOL use_toolbox = FALSE;
static char *progname;

int debug_level;

/* Used to point to a block in the RMA for a long URL */
static char *fe_stored_url = NULL;
static fe_passwd fe_current_passwd = NULL;

static char *fe_pending_url = NULL;
static char *fe_pending_bfile = NULL;

fe_view main_view = 0;
fe_view selected_view = 0;
static fe_view dbox_view = 0;

fe_view last_click_view = NULL;
static int last_click_x, last_click_y;

static be_item highlight_last_link = NULL;

static int fast_poll = 0;

static int connection_up = 1;
static int connection_count = 0;

/* ----------------------------------------------------------------------------------------------------- */

pointermode_t pointer_mode = (pointermode_t)-1;

static wimp_mousestr pointer_last_pos = { 0 };
static BOOL pointer_last_shift = FALSE;

void fe_pointer_mode_update(pointermode_t mode)
{
    switch (mode)
    {
        case pointermode_OFF:
//            case pointermode_INPUT:
//                if (config_mode_keyboard)
            os_cli("pointer 0");
            break;

        case pointermode_ON:
            if (pointer_mode != pointermode_ON)
                pointer_reset_shape();
            break;
    }
    pointer_mode = mode;
}

/* ----------------------------------------------------------------------------------------------------- */

typedef struct
{
    char *name;
    int x, y;       // hotspot
} pointer_info;

#define ptr_DEFAULT 0
#define ptr_HAND    1
#define ptr_MAP     2
#define ptr_CARET   3
#define ptr_CLICK   4
#define ptr_MENU    5

static pointer_info pointers[] =
{
    { NULL, 0, 0 },
    { "ptr_hand", 4, 0 },
    { "ptr_map", 16, 16 },
    { "ptr_caret", 4, 0 },
    { "ptr_click", 0, 22 },
    { "ptr_menu", 0, 4 },
    { "ptr_push", 4, 0 },
    { "ptr_resizew", 16, 0 },
    { "ptr_resizeh", 0, 16 }
};

#define fe_pointer_MAP              (1U<<31)
#define fe_pointer_DRAG             (1U<<30)
#define fe_pointer_RESIZE_WIDTH     (1U<<29)
#define fe_pointer_RESIZE_HEIGHT    (1U<<28)

static int fe_get_pointer_number(int item_flags)
{
    int ptr_num = 0;
    if (item_flags & be_item_info_USEMAP)
        ptr_num = 1;
    else if (item_flags & be_item_info_ISMAP)
        ptr_num = 1; //2;
    else if (item_flags & (be_item_info_BUTTON | be_item_info_ACTION))
        ptr_num = 1; //4;
    else if (item_flags & be_item_info_INPUT)
        ptr_num = 3;
    else if (item_flags & be_item_info_MENU)
        ptr_num = 1; // 5;
    else if (item_flags & be_item_info_LINK)
        ptr_num = 1;
    else if ((unsigned)item_flags & fe_pointer_MAP)   // force map for the map mode
        ptr_num = 2;
    else if ((unsigned)item_flags & fe_pointer_DRAG)   // dragging mode
        ptr_num = 6;
    else if ((unsigned)item_flags & fe_pointer_RESIZE_WIDTH)   // resize w
        ptr_num = 7;
    else if ((unsigned)item_flags & fe_pointer_RESIZE_HEIGHT)   // resize h
        ptr_num = 8;
    return ptr_num;
}

static int pointer_current = 0;

void fe_set_pointer(int item_flags)
{
    int num = fe_get_pointer_number(item_flags);

    if (num != pointer_current)
    {
        pointer_info *info = &pointers[num];

#if 0
        fprintf(stderr, "stbfe: set pointer %d '%s'\n", num, strsafe(info->name));
#endif

        if (info->name)
        {
            sprite_id id;
            id.tag = sprite_id_name;
            id.s.name = info->name;
            frontend_fatal_error(pointer_set_shape(resspr_area(), &id, info->x, info->y));
        }
        else
        {
            if (pointer_mode == pointermode_OFF)
                os_cli("pointer 0");
            else
                pointer_reset_shape();
        }

        pointer_current = num;
    }
}

/* ----------------------------------------------------------------------------------------------------- */

static BOOL fe_caretise(fe_view v)
{
    // if the highlighted object is actually an INPUT then place caret
    if (v->current_link)
    {
        int flags;

        if (frontend_complain(backend_item_info(v->displaying, v->current_link, &flags, NULL, NULL)) == NULL &&
            (flags & be_item_info_INPUT))
        {
            frontend_complain(backend_activate_link(v->displaying, v->current_link, wimp_BLEFT));
            return TRUE;
        }
    }
    return FALSE;
}

/* ----------------------------------------------------------------------------------------------------- */

static void fe_type_file(fe_view v, const char *file_name)
{
    FILE *f;
    if ((f = fopen(file_name, "r")) != NULL)
    {
        os_error *e = NULL;
        int used = TRUE;
        while (!e && !feof(f) && used)
            e = backend_doc_key(v->displaying, fgetc(f), &used);
        fclose(f);
    }
}

/* ----------------------------------------------------------------------------------------------------- */

static os_error *iterate_frames(fe_view top, os_error *(*fn)(fe_view v, void *handle), void *handle)
{
    fe_view v;
    os_error *e = NULL;
    for (v = top; !e && v; v = v->next)
    {
        e = fn(v, handle);

        if (!e && v->children)
            e = iterate_frames(v->children, fn, handle);
    }
    return e;
}

/* ----------------------------------------------------------------------------------------------------- */

/* Unused functions */

os_error *savedoc(char *url, char *leaf, int ft)
{
    return NULL;
    url = url;
    leaf = leaf;
    ft = ft;
}

void frontend_saver_last_name(char *fname)
{
    fname = fname;
}

/* ----------------------------------------------------------------------------------------------------- */

int frontend_view_visit(fe_view v, be_doc doc, char *url, char *title)
{
#ifdef TRACE_FN
fprintf(stderr, "frontend_view_visit url '%s' title '%s'\n", url ? url : "", title ? title : "");
#endif
    if (doc == NULL)    // lookup failed re visit the current one
    {
	char *durl;
	int f, ft;
	frontend_complain(makeerror(ERR_CANT_GET_URL));

	if (v->displaying)
	{
	    backend_doc_info(v->displaying, &f, &ft, &durl, NULL);
	    if (durl)
		frontend_view_status(v, sb_status_URL, durl );
	}

        session_log("", session_FAILED);

        if (use_toolbox)
            tb_status_update_fades(fe_find_top(v));

        fe_status_clear_fetch_only();

	v->fetching = NULL;
	return 1;
    }

    session_log(url, session_CONNECTED);

    if (v->fetching == doc)
	v->fetching = NULL;
    else
	fprintf(stderr, "Erroneous call to view visit\n");

    if (v->displaying)
    {
        if (fe_map_view() == v)
            fe_map_mode(NULL, NULL);

        backend_dispose_doc(v->displaying);
    }

    fe_dispose_view_children(v);

    v->displaying = doc;
    v->current_link = NULL;

    // check for special page instructions - but only on top page
    if (v->parent == NULL)
    {
        const char *s = backend_check_meta(doc, "BROWSERMODE");
        int mode = s == NULL ? fe_browser_mode_WEB :
            strcasecomp(s, "DESKTOP") == 0 ? fe_browser_mode_DESKTOP :
            strcasecomp(s, "DBOX") == 0 ? fe_browser_mode_DBOX :
            strcasecomp(s, "HOTLIST") == 0 ? fe_browser_mode_HOTLIST :
            strcasecomp(s, "HISTORY") == 0 ? fe_browser_mode_HISTORY :
            fe_browser_mode_WEB;

        switch (mode)
        {
            case fe_browser_mode_WEB:
                break;

            case fe_browser_mode_HOTLIST:
            case fe_browser_mode_HISTORY:
            case fe_browser_mode_DBOX:
                v->dont_add_to_history = TRUE;
                break;

            case fe_browser_mode_DESKTOP:
                v->dont_add_to_history = TRUE;

                mm_free(v->return_page);
                v->return_page = strdup(url);
                break;
        }

        fe_status_mode(v, mode);
    }

    v->pending_scroll = fe_history_visit(v, url, title);

    frontend_view_redraw(v, NULL);

    frontend_view_status(v, sb_status_URL, url);

    if (!fe_check_download_finished(v) || !v->pending_scroll)
        frontend_view_ensure_visable(v, -1, 0, 0);

    return 1;
}

/* ----------------------------------------------------------------------------------------------------- */

static char *checked(int flag)
{
    return flag ? "CHECKED" : "";
}

static void get_form_size(int *width, int *height)
{
    int char_height;
/*
    int char_width = webfonts[WEBFONT_TTY].space_width;
    *width = (text_safe_box.x1 - text_safe_box.x0)/char_width - 8;
 */
    *width = webfont_tty_width(text_safe_box.x1 - text_safe_box.x0, 0) - 8;

    char_height = webfonts[WEBFONT_TTY].max_up + webfonts[WEBFONT_TTY].max_down;
    *height = (text_safe_box.y1 - text_safe_box.y0)/char_height - 12;
}

static void fe_dbox_dispose(void)
{
    if (dbox_view)
    {
        if (selected_view == dbox_view)
        {
            fe_get_wimp_caret(main_view->w);
            selected_view = main_view;
        }

        fe_dispose_view(dbox_view);
        dbox_view = NULL;

        fe_status_mode(main_view, fe_browser_mode_WEB);

        if (main_view->displaying)
        {
            char *url;
            backend_doc_info(main_view->displaying, NULL, NULL, &url, NULL);
            frontend_view_status(main_view, sb_status_URL, url);
        }
    }
}

static fe_view fe_dbox_view(void)
{
    fe_frame_info info;

    fe_dbox_dispose();

    info.name = "__dbox";
    info.noresize = TRUE;
    info.scrolling = fe_scrolling_NO;
    info.margin = margin_box;

    if (use_toolbox && tb_is_status_showing())
        info.margin.y1 -= tb_status_height();

    frontend_complain(fe_new_view(NULL, &screen_box, &info, &dbox_view));

    return dbox_view;
}

/* ----------------------------------------------------------------------------------------------------- */

void fe_dbox_cancel(void)
{
    if (fe_current_passwd)
        fe_passwd_abort();
    else
        fe_dbox_dispose();
}

/* ----------------------------------------------------------------------------------------------------- */

static os_error *fe_mailto_decode(const char *bfile)
{
    fe_dbox_dispose();
    return NULL;
}

static os_error *fe_mailto_write_file(FILE *f, void *handle)
{
    int width, height;
    const char *to = (const char *)handle;

    fputs(msgs_lookup("mailT"), f);
    fputc('\n', f);

    get_form_size(&width, &height);

    fprintf(f, msgs_lookup("mail1"), width, to);
    fprintf(f, msgs_lookup("mail2"), width, "");
    fprintf(f, msgs_lookup("mail3"), width, height);

    fputs(msgs_lookup("mailF"), f);
    fputc('\n', f);

    return NULL;
}

static os_error *fe_open_mailto(const char *to)
{
    fe_view v = fe_dbox_view();
    fe_get_wimp_caret(v->w);
    fe_open_temp_file(v, fe_mailto_write_file, (void *)to);
    return NULL;
}

static BOOL can_do_mailto(void)
{
    char *s = msgs_lookup("mailT:");
    return s && s[0];
}

/* ----------------------------------------------------------------------------------------------------- */

static os_error *fe_version_write_file(FILE *f, void *handle)
{
    be_doc doc = handle;
    char *url, *title;

    fputs(msgs_lookup("versionT"), f);
    fputc('\n', f);

    url = title = NULL;
    backend_doc_info(doc, NULL, NULL, &url, &title);

    fprintf(f, msgs_lookup("version1"), fresco_version);
    fprintf(f, msgs_lookup("version2"),
        title ? title : "None",
        url);
    fprintf(f, msgs_lookup("version3"));

    fputs(msgs_lookup("versionF"), f);
    fputc('\n', f);

    return NULL;
    handle = handle;
}

os_error *fe_open_version(fe_view m)
{
    fe_view v = fe_dbox_view();
    fe_get_wimp_caret(v->w);
    fe_open_temp_file(v, fe_version_write_file, m->displaying);
    return NULL;
}

/* ----------------------------------------------------------------------------------------------------- */

static os_error *fe_display_options_decode(const char *data)
{
    fe_view v;

    fe_dbox_dispose();

    config_display_body_colours = strstr(data, "opt=bg") != 0;
    config_defer_images = strstr(data, "opt=img") == 0;

    v = main_view;
    v->flags &= ~(be_openurl_flag_BODY_COLOURS | be_openurl_flag_DEFER_IMAGES);
    v->flags |= (config_display_body_colours ? be_openurl_flag_BODY_COLOURS : 0) |
        (config_defer_images ? be_openurl_flag_DEFER_IMAGES : 0);

    if (v->browser_mode == fe_browser_mode_WEB)
    {
        backend_doc_set_flags(v->displaying,
            be_openurl_flag_BODY_COLOURS | be_openurl_flag_DEFER_IMAGES,
            v->flags & (be_openurl_flag_BODY_COLOURS | be_openurl_flag_DEFER_IMAGES));
        fe_refresh_screen(NULL);
    }

    return NULL;
}

static os_error *fe_display_options_write_file(FILE *f, void *handle)
{
    fputs(msgs_lookup("dispT"), f);
    fputc('\n', f);

    fprintf(f, msgs_lookup("disp1"), checked(config_display_body_colours));
    fprintf(f, msgs_lookup("disp2"), checked(!config_defer_images));

    fputs(msgs_lookup("dispF"), f);
    fputc('\n', f);

    return NULL;
    handle = handle;
}

os_error *fe_display_options_open(fe_view v)
{
    fe_view dv = fe_dbox_view();
    fe_get_wimp_caret(dv->w);
    fe_open_temp_file(dv, fe_display_options_write_file, v);
    return NULL;
}

/* ------------------------------------------------------------------------------------------- */

int fe_doc_flag_state(fe_view v, int flags)
{
    return v && (v->flags & flags);
}

os_error *fe_doc_flag_toggle(fe_view v, int flags)
{
    os_error *e = NULL;

    v->flags ^= flags;

    config_display_body_colours = (v->flags & be_openurl_flag_BODY_COLOURS) != 0;
    config_defer_images = (v->flags & be_openurl_flag_DEFER_IMAGES) != 0;

    if (v->browser_mode == fe_browser_mode_WEB)
    {
        e = backend_doc_set_flags(v->displaying, 0, flags);
        if (!e) fe_refresh_screen(NULL);
    }
    return e;
}

/* ----------------------------------------------------------------------------------------------------- */

static int print__copies = 1, print__ul = 1;

static os_error *fe_print_options_decode(const char *data)
{
    char *s;

    fe_dbox_dispose();

    s = extract_value(data, "copies=");
    print__copies = atoi(s);
    mm_free(s);

    s = extract_value(data, "scaling=");
    config_print_scale = atoi(s);
    mm_free(s);

    s = extract_value(data, "orient");
    config_print_sideways = strcmp(data, "side") == 0;
    mm_free(s);

    config_print_nopics = strstr(data, "f=pic") == 0;
    config_print_nocol = strstr(data, "f=col") == 0;
    config_print_nobg = strstr(data, "f=bg") == 0;
    config_print_collated = strstr(data, "f=collate") != 0;
    config_print_reversed = strstr(data, "f=rev") != 0;

    print__ul = strstr(data, "f=ul") != 0;

    return NULL;
}

static os_error *fe_print_options_write_file(FILE *f, void *handle)
{
    fputs(msgs_lookup("printT"), f);
    fputc('\n', f);

    fprintf(f, msgs_lookup("print1"), print__copies, checked(config_print_collated), checked(config_print_reversed));
    fprintf(f, msgs_lookup("print2"), checked(!config_print_sideways), checked(config_print_sideways));
    fprintf(f, msgs_lookup("print3"), config_print_scale);
    fprintf(f, msgs_lookup("print4"), checked(!config_print_nopics));
    fprintf(f, msgs_lookup("print5"), checked(!config_print_nocol));
    fprintf(f, msgs_lookup("print6"), checked(!config_print_nobg));
    fprintf(f, msgs_lookup("print7"), checked(print__ul));

    fputs(msgs_lookup("printF"), f);
    fputc('\n', f);

    return NULL;
    handle = handle;
}

os_error *fe_print_options_open(fe_view v)
{
#if 1
    fe_view dv = fe_dbox_view();
    fe_get_wimp_caret(dv->w);
    fe_open_temp_file(dv, fe_print_options_write_file, v);
#else
    return tb_print_options_open(v);
#endif
    return NULL;
}

int fe_print_possible(fe_view v)
{
    char *s = getenv("Printer$");
    return v && v->displaying && s != NULL && s[0] != 0;
}

const char *fe_printer_name(void)
{
    char *s = getenv("Printer$");
    return s ? s : "";
}

os_error *fe_print(fe_view v)
{
    char *s;

    s = getenv("Printer$");
    if (s == NULL || s[0] == 0)
        return makeerror(ERR_NO_PRINTER);

    return awp_print_document(v->displaying, config_print_scale,
        (config_print_nopics ? awp_print_NO_PICS : 0) |
        (config_print_nobg ? awp_print_NO_BACK : 0) |
        (config_print_nocol ? awp_print_NO_COLOUR : 0) |
        (print__ul ? awp_print_UNDERLINE : 0) |
        (config_print_sideways ? awp_print_SIDEWAYS : 0) |
        (config_print_collated ? awp_print_COLLATED : 0) |
        (config_print_reversed ? awp_print_REVERSED : 0),
        print__copies);
}

/* ----------------------------------------------------------------------------------------------------- */

static void fe_openurl_decode(char *query)
{
    char *url;

    url = extract_value(query, "url=");
    if (url)
    {
        char *url1 = check_url_prefix(url);
        frontend_open_url(url1, main_view, NULL, NULL, 0);
        mm_free(url1);
        mm_free(url);
    }
}

extern void hotlist_write_list(FILE *fout);

static os_error *fe_openurl_write_file(FILE *f, void *handle)
{
    int width, height;
    const char *url = (const char *)handle;

    fputs(msgs_lookup("openT"), f);
    fputc('\n', f);

    get_form_size(&width, &height);

    width -= 12;
    fprintf(f, msgs_lookup("open1"));
    fprintf(f, msgs_lookup("open2"), width, "");
    fprintf(f, msgs_lookup("open3"));

    hotlist_write_list(f);

    fputs(msgs_lookup("openF"), f);
    fputc('\n', f);

    return NULL;
}

os_error *fe_hotlist_open(fe_view v)
{
    os_error *e = NULL;
    char *url = NULL;
    if (v->displaying)
        e = backend_doc_info(v->displaying, NULL, NULL, &url, NULL);
    if (!e) fe_open_temp_file(v, fe_openurl_write_file, url);
    return e;
}

/* ----------------------------------------------------------------------------------------------------- */

static void fe_handle_pending_url(char *url, char *bfile)
{
    char *scheme, *netloc, *path, *params, *query, *fragment;
    os_error *e;

    url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);

    if (strcasecomp(scheme, "stbwebinternal") != 0)
    {
        frontend_open_url(url, NULL, NULL, NULL, 1);
    }
    // dbox type actions
    else if (strcasecomp(path, "cancel") == 0)
    {
        fe_dbox_cancel();
    }
    else if (strcasecomp(path, "displayoptions") == 0)
    {
        fe_display_options_decode(query);
    }
    else if (strcasecomp(path, "find") == 0)
    {
        fe_find_decode(query);
    }
    else if (strcasecomp(path, "mailto") == 0)
    {
        fe_mailto_decode(bfile);
    }
    else if (strcasecomp(path, "password") == 0)
    {
        fe_passwd_decode(query);
    }
    else if (strcasecomp(path, "printoptions") == 0)
    {
        fe_print_options_decode(query);
    }
    // internal commands
    else if (strcasecomp(path, "back") == 0)
    {
        fevent_handler(fevent_HISTORY_BACK + fevent_WINDOW, main_view);
    }
    else if (strcasecomp(path, "close") == 0)
    {
        fevent_handler(fevent_CLOSE, main_view);
    }
    else if (strcasecomp(path, "home") == 0)
    {
        fevent_handler(fevent_HOME, main_view);
    }
    else if (strcasecomp(path, "hotlist") == 0)
    {
        fevent_handler(fevent_HOTLIST_SHOW, main_view);
    }
    else if (strcasecomp(path, "loadurl") == 0)
    {
        fe_openurl_decode(query);
    }
    else if (strcasecomp(path, "playmovie") == 0)
    {
        int x, y;
        fe_view v;
        be_item ti;
        wimp_box box;

        x = last_click_x;
        y = last_click_y;
        v = last_click_view;

        ti = NULL;
        e = NULL;
        if (v)
            e = backend_doc_locate_item(v->displaying, &x, &y, &ti);

        if (!e && ti)
            e = backend_doc_item_bbox(v->displaying, ti, &box);

        if (!e && ti)
        {
            char *file, *args;
            char *scheme1, *netloc1, *path1, *params1, *query1, *fragment1;
            char buffer[256];

            file = extract_value(query, "url=");
            args = extract_value(query, "args=");
            url_parse(file, &scheme1, &netloc1, &path1, &params1, &query1, &fragment1);

            if (strcasecomp(scheme1, "file") == 0)
            {
                char *path2 = url_path_to_riscos(path1);
                coords_cvtstr cvt = fe_get_cvt(v);

                coords_point_toscreen((coords_pointstr *)&box.x0, &cvt);

                sprintf(buffer, "/%s -at %d,%d", path2, box.x0, box.y0);
                if (args)
                {
                    strcat(buffer, " ");
                    strcat(buffer, args);
                }
                wimp_starttask(buffer);
                mm_free(path2);
            }

            url_free_parts(scheme1, netloc1, path1, params1, query1, fragment1);
            mm_free(file);
        }
    }
    else
    {
        char buffer[256];
        sprintf(buffer, "%s %s", path, bfile ? bfile : query ? query : "");
        wimp_starttask(buffer);
    }

    url_free_parts(scheme, netloc, path, params, query, fragment);

    if (bfile)
        remove(bfile);
}

/* ------------------------------------------------------------------------------------------- */
// password handling
/* ------------------------------------------------------------------------------------------- */

static void fe_passwd_decode(const char *query)
{
    char *name, *pass;
    fe_passwd pw;

    if (!fe_current_passwd)
        return;

    name = extract_value(query, "name=");
    pass = extract_value(query, "pass=");

#if 1
fprintf(stderr, "name='%s'\n", name);
fprintf(stderr, "pass='%s'\n", pass);
#endif

    pw = fe_current_passwd;

    // do the callback and return control
    if (pw->cb)
        (pw->cb)(pw, pw->h, name, pass);

    frontend_passwd_dispose(pw);

    mm_free(name);
    mm_free(pass);
}

static os_error *fe_passwd_write_file(FILE *f, void *handle)
{
    fe_passwd pw = handle;
    int width, height;

    fputs(msgs_lookup("passwdT"), f);
    fputc('\n', f);

    get_form_size(&width, &height);

    fprintf(f, msgs_lookup("passwd1"), pw->realm ? pw->realm : "unknown", strsafe(pw->site));
    fprintf(f, msgs_lookup("passwd2"), width, width);

    fputs(msgs_lookup("passwdF"), f);
    fputc('\n', f);

    return NULL;
}

static void fe_passwd_abort(void)
{
    fe_passwd pw = fe_current_passwd;
    if (pw)
    {
        if (pw->cb)
            (pw->cb)(pw, pw->h, NULL, NULL);

        frontend_passwd_dispose(pw);
    }
}

fe_passwd frontend_passwd_raise(backend_passwd_callback cb, void *handle,
				char *user, char *realm, char *site)
{
    fe_passwd pw;
    fe_view dv;

#ifdef TRACE_FN
fprintf(stderr, "passwd_raise user '%s' realm '%s' site '%s'\n",
    user ? user : "", realm ? realm : "", site ? site : "");
#endif

    pw = mm_calloc(sizeof(*pw), 1);

    pw->cb = cb;
    pw->h = handle;

    pw->user = strdup(user);
    pw->realm = strdup(realm);
    pw->site = strdup(site);

    dv = fe_dbox_view();
    fe_get_wimp_caret(dv->w);
    fe_open_temp_file(dv, fe_passwd_write_file, pw);

    fe_current_passwd = pw;

    return pw;
}

void frontend_passwd_dispose(fe_passwd pw)
{
#ifdef TRACE_FN
fprintf(stderr, "passwd_dispose %p\n", pw);
#endif

    fe_dbox_dispose();

    mm_free(pw->user);
    mm_free(pw->realm);
    mm_free(pw->site);

    mm_free(pw);
    fe_current_passwd = NULL;
}

/* ------------------------------------------------------------------------------------------- */

static os_error *set_fetch_message(fe_view v)
{
    int waiting, fetching, fetched, errors, in_trans, so_far;
    char buffer[256];
    int n;
    os_error *e;

    e = backend_doc_images(v->displaying, &waiting, &fetching, &fetched, &errors, &in_trans, &so_far);
    if (!e)
    {
        if (v->fetch_of > 0)
            n = sprintf(buffer, msgs_lookup("stfp"), v->fetch_rx*100/v->fetch_of);
        else
            n = sprintf(buffer, msgs_lookup("stfb"), v->fetch_rx);

        n += sprintf(buffer+n, msgs_lookup("stim"), fetched + errors, fetching + waiting + fetched + errors);

        e = tb_status_set_message(NULL, buffer);
    }

    return e;
}

static void check_pending_scroll(fe_view v)
{
    if (v->pending_scroll)
    {
        wimp_box bb;
        int h, hh;

        frontend_view_bounds(v, &bb);

        h = bb.y1 - bb.y0;
        hh = h > -v->doc_height ? h : -v->doc_height;

        if (v->pending_scroll - h >= -hh)
        {
            frontend_view_ensure_visable(v, -1, v->pending_scroll, v->pending_scroll);
            v->pending_scroll = 0;
        }
    }
}

static int fe_check_download_finished(fe_view v)
{
    be_doc doc;
    int flags;
    int waiting, fetching, fetched, errors, in_trans, so_far;
    BOOL doc_done, img_done;

    // can't do the rest until visit() has been called
    if (v->fetching)
        return FALSE;

    if ((doc = v->displaying) == NULL)
        return FALSE;

    // see if doc is finished
    backend_doc_info(doc, &flags, NULL, NULL, NULL);
    doc_done = (flags & be_doc_info_FETCHING) == 0;

    if (doc_done)
    {
        // set fetch values so status is correct
        if (v->fetch_of > 0)
            v->fetch_rx = v->fetch_of;
    }

    // see if images are finished
    backend_doc_images(doc, &waiting, &fetching, &fetched, &errors, &in_trans, &so_far);
    img_done = (waiting + fetching) == 0;

    if (doc_done && img_done)
    {
        // check for highlightable link
        if (pointer_mode == pointermode_OFF)
        {
            if (v->w && frontend_view_has_caret(v))
            {
                v->current_link = backend_highlight_link(doc, v->current_link, be_link_VISIBLE | be_link_INCLUDE_CURRENT);
                fe_caretise(v);
            }
        }

        // update toolbar fades
        if (use_toolbox)
            tb_status_update_fades(fe_find_top(v));

        // get rid of temporary globe
        fe_status_clear_fetch_only();

        return TRUE;
    }
    else
    {
        frontend_view_status(v, sb_status_WORLD, NULL);
    }

    return FALSE;
}

/* ------------------------------------------------------------------------------------------- */

int frontend_view_status(fe_view v_orig, int status_type, char *info, ...)
{
    os_error *e = NULL;
    va_list ap;
    fe_view v;

    // go to top of stack
    v = fe_find_top(v_orig);

    va_start(ap, info);

#ifdef TRACE_FN
if (status_type != -1) fprintf(stderr, "view status %d '%s'\n", status_type, info ? info : "");
#endif
    switch (status_type)
    {
        case sb_status_WORLD:       // just mark time
            if (use_toolbox)
                tb_status_rotate();
            else
                e = statuswin_update_fetch_status(v, v->fetch_status);
            break;

        case sb_status_URL:         // called by backend_open_url - ie starting to connect
            if (use_toolbox)
            {
                if (v == v_orig)
                    e = tb_status_set_url(info);

                tb_status_update_fades(v);
            }
            else
            {
                statuswin_update_fetch_info(v, info);
                statuswin_draw_title(v, TRUE);
            }
            break;

        case sb_status_FETCHED:     // string giving amount of html document fetched
            if (use_toolbox)
            {
                v_orig->fetch_rx = va_arg(ap, int);
                v_orig->fetch_of = va_arg(ap, int);
                e = set_fetch_message(v_orig);
            }
            else
            {
                v->fetch_rx = va_arg(ap, int);
                v->fetch_of = va_arg(ap, int);

                v->fetch_document = v->fetch_of <= 0 ? 256 : v->fetch_rx*256/v->fetch_of;

                e = statuswin_update_fetch_status(v, v->fetch_status);
                if (!e) e = statuswin_update_fetch_info(v, info);
            }

            check_pending_scroll(v_orig);
            break;

        case sb_status_SENT:        // string giving amount of request data sent to server
        {
            int tx = va_arg(ap, int);
            int of = va_arg(ap, int);
            if (use_toolbox)
            {
                if (of > 0)
                    e = tb_status_set_messagef(NULL, msgs_lookup("stsp"), tx*100/of);
                else
                    e = tb_status_set_messagef(NULL, msgs_lookup("stsb"), tx);
            }
            else
            {
                e = statuswin_update_fetch_status(v, v->fetch_status);
                if (!e) e = statuswin_update_fetch_info(v, info);
            }
            break;
        }

        case sb_status_PROGRESS:    // token detailing progress aborted, fromcch, or status<HTTP error code>
        {
            int status = va_arg(ap, int);

            if (use_toolbox)
            {
/*
                char buf[256];
                strncpysafe(buf, msgs_lookup(info), sizeof(buf));
                if ((status == status_DNS || status == status_CONNECTING) && url)
                {
                    char *host;
                    url_parse(url, NULL, &host, NULL, NULL, NULL, NULL);

                    strlencat(buf, " (", sizeof(buf));
                    if (host) strlencat(buf, host, sizeof(buf));
                    strlencat(buf, ")", sizeof(buf));
                }
                e = tb_status_set_message(NULL, buf);
 */
                e = tb_status_set_message(NULL, msgs_lookup(info));
            }
            else
            {
                e = statuswin_update_fetch_status(v, status);
                if (!e) e = statuswin_update_fetch_info(v, msgs_lookup(info));
            }

            check_pending_scroll(v_orig);
            fe_check_download_finished(v_orig);
            break;
        }

        case sb_status_IMAGE:       // string giving images loaded
            if (use_toolbox)
            {
                e = set_fetch_message(v_orig);
            }
            else
            {
                int waiting, fetching, fetched, errors, in_trans, so_far;
                e = backend_doc_images(v->displaying, &waiting, &fetching, &fetched, &errors, &in_trans, &so_far);
                if (!e)
                {
                    int total = fetched + errors + waiting + fetching;
                    v->fetch_images = total ? (fetched + errors)*256/total : 256;
                }

                e = statuswin_update_fetch_status(v, v->fetch_status);
                if (!e) e = statuswin_update_fetch_info(v, info);
            }

            check_pending_scroll(v_orig);
            fe_check_download_finished(v_orig);
            break;

        case sb_status_ABORTED:
            if (use_toolbox)
            {
                e = tb_status_set_message(NULL, msgs_lookup("sta"));
            }
            else
            {
                e = statuswin_update_fetch_status(v, sb_status_PROGRESS_ABORTED);
                if (!e) e = statuswin_update_fetch_info(v, msgs_lookup("sta"));
            }

            fe_check_download_finished(v_orig);

            // get rid of temporary globe
            fe_status_clear_fetch_only();
            break;

        // these messages are sent by our null handler depending on
        // what's under the pointer or highlighted
        case sb_status_IDLE:
            break;

        case sb_status_LINK:
            break;

        case sb_status_MAP:
            break;

        case sb_status_HELPER:
            break;
        case sb_status_HELP:
            break;
    }

    va_end(ap);

    frontend_complain(e);

    return 0;
}

/* ------------------------------------------------------------------------------------------- */

int frontend_test_history(char *url)
{
    return fe_test_history(main_view, url);
}

/* ------------------------------------------------------------------------------------------- */
/*
 * Check with the registry to see if the interface is down.
 * Returns true if
  - primary interface is down
 */

typedef struct dib
{
   unsigned int         dib_swibase;    /* Module's SWI chunk number */
   char                *dib_name;       /* Eg "ea" and "slip" */
   unsigned int         dib_unit;       /* Unit number. First is 0, then consecutive */
   unsigned char       *dib_address;    /* 6 bytes of hardware address */
   char                *dib_module;     /* Eg "Ether3" */
   char                *dib_location;   /* Eg "Network expansion slot" */
/*   struct slot          dib_slot;        See above defintion */
} dci4_dib;

typedef struct mydiblist {

  unsigned int flags;     /* flag bits - see below */
  dci4_dib *dib_ptr;      /* pointer to a DCI4 compliant driver information block */
  struct mydiblist *next; /* next entry, or NULL for end of list */
} mydci4_diblist;

#define DIB_FLAG_PRIMARY 0x1   /* this is the primary interface as far as the registry is concerned */
#define DIB_FLAG_STATS   0x2   /* device driver supports statistics */
#define DIB_FLAG_STATUS  0x4   /* interface is working OK */
#define DIB_FLAG_UP      0x8   /* interface is UP */
#define DIB_FLAG_PTP     0x10  /* interface is point2point */

#define NCRegistry_EnumerateNetworkDrivers  0x4d380

static BOOL interface_is_down(void)
{
    mydci4_diblist *dib;

    /* if no registry then assume interface is OK */
    if (_swix(NCRegistry_EnumerateNetworkDrivers, _OUT(0), &dib) != NULL)
        return FALSE;

    for (; dib; dib = dib->next)
    {
        /* only concerned with the primary interface  */
        if (dib->flags & DIB_FLAG_PRIMARY)
        {
            /* if ppp and status OK and down */
            if (dib->dib_ptr && strcasecomp(dib->dib_ptr->dib_name, "ppp") == 0 &&
                (dib->flags & DIB_FLAG_STATUS) &&
                (dib->flags & DIB_FLAG_UP) == 0)
            {
                return TRUE;
            }

            break;
        }
    }

    return FALSE;
}

int frontend_is_interface_up(void)
{
    return connection_up = 1;
}

int frontend_is_interface_down(void)
{
    if (!connection_up)
        return 1;

    if (interface_is_down())
    {
        connection_up = 0;
        return 1;
    }
    return 0;
}

/* ------------------------------------------------------------------------------------------- */

void frontend_pass_doc(fe_view v, char *url, char *cfile, int ftype)
{
    wimp_msgstr msg;

#ifdef TRACE_FN
fprintf(stderr, "frontend_pass_doc url '%s'\n", url);
#endif

    fe_status_clear_fetch_only();

    memset(&msg, 0, sizeof(msg));
    msg.hdr.size = sizeof(wimp_msgstr);
    msg.hdr.action = wimp_MDATAOPEN;
    msg.data.dataopen.type = ftype;
    strcpy(msg.data.dataopen.name, cfile);
    frontend_fatal_error(wimp_sendmessage(wimp_ESENDWANTACK, &msg, 0));

    if (v)
	v->fetching = NULL;
}

void frontend_url_punt(char *url, char *bfile)
{
    wimp_eventstr e;
    urlopen_data *ud = (urlopen_data*) &(e.data.msg.data);
    int len;

#ifdef TRACE_FN
fprintf(stderr, "frontend_url_punt '%s'\n", url);
#endif

    fe_status_clear_fetch_only();

    if (strncasecomp(url, INTERNAL_PREFIX, INTERNAL_PREFIX_SIZE) == 0)
    {
        fe_pending_url = strdup(url);
        fe_pending_bfile = strdup(bfile);
        return;
    }

    if (fe_stored_url)
    {
	rma_free(fe_stored_url);
	fe_stored_url = NULL;
    }

    len = strlen(url);
    if (bfile) len += strlen(bfile) + 1;

    /* Use strictly less */
    if (len < sizeof(ud->url))
    {
	strcpy(ud->url, url);
	if (bfile)
	{
	    strcat(ud->url, " ");
	    strcat(ud->url, bfile);
	}
	e.data.msg.hdr.size = 20 + ((len + 4) & ~3);
    }
    else
    {
	ud->indirect.tag = 0;
	ud->indirect.url = fe_stored_url = rma_alloc(len + 1);
	if (ud->indirect.url)
	{
	    strcpy(ud->indirect.url, url);
	    if (bfile)
	    {
	        strcat(ud->indirect.url, " ");
	        strcat(ud->indirect.url, bfile);
	    }
	}
	e.data.msg.hdr.size = 20 + 8;
    }

    e.data.msg.hdr.your_ref = 0;
    e.data.msg.hdr.action = (wimp_msgaction) wimp_MOPENURL;

    frontend_fatal_error(wimp_sendmessage(wimp_ESENDWANTACK, &(e.data.msg), 0));
}

/* ------------------------------------------------------------------------------------------- */

static void fe_frame_resize(fe_view v, const wimp_box *box)
{
#if 1
fprintf(stderr, "resize: v %p frame to %4d,%4d %4d,%4d\n", v, box->x0, box->y0, box->x1, box->y1);
#endif
    v->box = *box;

    if (v->w)
        feutils_resize_window(&v->w, &v->margin, box,
            &v->x_scroll_bar, &v->y_scroll_bar,
            v->doc_width, -v->doc_height, v->scrolling);

    if (v->displaying)
        backend_reset_width(v->displaying, 0);

    if (v->w)
        fe_refresh_window(v->w, NULL);
}

/*
 * The method for refreshing assumes that the frames will always be presented in the same order
 */

void frontend_frame_layout(fe_view v, int nframes, fe_frame_info *info, int refresh_only)
{
    int i;
    coords_cvtstr cvt;
    fe_view child = NULL;

    if (!v)
        return;

    // get rid of the old layout before creating the new one
    if (refresh_only)
        child = v->children;
    else
        fe_dispose_view_children(v);

    // ensure at top of visible screen
    frontend_view_ensure_visable(v, -1, 0, 0);

    cvt = fe_get_cvt(v);
    for (i = 0; i < nframes; i++)
    {
        fe_frame_info *ip = &info[i];
        wimp_box box;

        box = *(wimp_box *)&ip->box;
        coords_box_toscreen(&box, &cvt);

        if (refresh_only)
        {
            if (child)
            {
                fe_frame_resize(child, &box);
                child = child->next;
            }
        }
        else
        {
            fe_view vv;

            /* correct for the margins we've put in
            if (v->parent != NULL)
                coords_offsetbox(&box, -v->margin.x0, -v->margin.y1, &box);
             */

            frontend_complain(fe_new_view(v, &box, ip, &vv));
            if (ip->src)
                frontend_complain(frontend_open_url(ip->src, vv, NULL, NULL, 0));
        }
    }
}

/* ------------------------------------------------------------------------------------------- */

os_error *fe_paste(fe_view v)
{
    static int list[2] = { FILETYPE_TEXT,-1 };
    wimp_msgdatasave datasave;
    datasave.w = v->w;
    datasave.i = -1;
    datasave.x = 0;
    datasave.y = 0;
    if (clipboard_Paste(list, &datasave))
        fe_type_file(v, CLIP_FILE);

    return NULL;
}

os_error *fe_paste_url(fe_view v)
{
    char *url;
    os_error *e;

    if (!v || !v->displaying)
        return NULL;

    e = NULL;
    if (v->dont_add_to_history)
        url = v->hist_at ? v->hist_at->url : NULL;
    else
        e = backend_doc_info(v->displaying, NULL, NULL, &url, NULL);

    if (!e && url)
    {
        int c, used = TRUE;
        while (!e && used && (c = *url++) != 0)
            e = backend_doc_key(v->displaying, c, &used);
    }

    return e;
}

/* ------------------------------------------------------------------------------------------- */

os_error *fe_handle_enter(fe_view v)
{
    int flags;
    char *link;
    os_error *e;
    void *im;
    wimp_box box;

    if (!v || !v->displaying || !v->current_link)
        return NULL;

    e = backend_item_info(v->displaying, v->current_link, &flags, &link, &im);
    if (!e)
        e = backend_doc_item_bbox(v->displaying, v->current_link, &box);
    if (!e)
    {
        if (flags & (be_item_info_ISMAP | be_item_info_USEMAP))
        {
            coords_pointstr p;
            coords_cvtstr cvt = fe_get_cvt(v);

            p.x = (box.x0 + box.x1)/2;
            p.y = (box.y0 + box.y1)/2;
            coords_point_toscreen(&p, &cvt);

            fe_pointer_set_position(p.x, p.y);
            fe_map_mode(v, v->current_link);
        }
        else if (flags & be_item_info_INPUT)
        {
            e = backend_activate_link(v->displaying, v->current_link, 0);
        }
        else
        {
            last_click_x = box.x0;
            last_click_y = box.y0;
            last_click_view = v;
            e = backend_activate_link(v->displaying, v->current_link, 0);
        }
    }

    return e;
}

/* ------------------------------------------------------------------------------------------- */
// key handlers
/* ------------------------------------------------------------------------------------------- */

BOOL fe_writeable_handle_keys(fe_view v, int key)
{
    int used = FALSE;

    if (v && v->displaying)
        backend_doc_key(v->displaying, key, &used);

    return used;
}

/* ------------------------------------------------------------------------------------------- */
// miscellaneous veneers between stbevent and backend
/* ------------------------------------------------------------------------------------------- */

static os_error *fe__abort_fetch_possible(fe_view v, void *handle)
{
    int *possible = handle;

    if (!v)
        return NULL;

    if (v->fetching)
    {
        (*possible)++;
        return NULL;
    }

    if (v->displaying)
    {
	int fl;
        int waiting, fetching, fetched, errors, in_trans, so_far;

	if (backend_doc_info(v->displaying, &fl, NULL, NULL, NULL) == NULL &&
	    (fl & be_doc_info_FETCHING) != 0)
        {
            (*possible)++;
      	    return NULL;
      	}

        if (backend_doc_images(v->displaying, &waiting, &fetching, &fetched, &errors, &in_trans, &so_far) == NULL &&
            (waiting + fetching) != 0)
        {
            (*possible)++;
      	    return NULL;
        }
    }

    return NULL;
}

int fe_abort_fetch_possible(fe_view v)
{
    int possible = 0;
    iterate_frames(v, fe__abort_fetch_possible, &possible);
    return possible != 0;
}

static os_error *fe__abort_fetch(fe_view v, void *handle)
{
    os_error *e = NULL;
    if (v->fetching)
    {
	backend_dispose_doc(v->fetching);
	v->fetching = NULL;

	frontend_view_status(v, sb_status_ABORTED, NULL);
        fe_status_clear_fetch_only();
    }
    else if (v->displaying)
    {
        e = backend_doc_abort(v->displaying);
    }
    return e;
    handle = handle;
}

os_error *fe_abort_fetch(fe_view v)
{
    return iterate_frames(v, fe__abort_fetch, NULL);
}

/* ------------------------------------------------------------------------------------------- */

os_error *fe_home(fe_view v)
{
    os_error *e;
    char *home_url;

    e = fe_file_to_url(config_doc_default, &home_url);

    if (!e && home_url)
    {
        if (config_mode_platform == platform_CAMB_TRIAL)
        {
            if (v->displaying)
            {
                char *url;
                e = backend_doc_info(v->displaying, NULL, NULL, &url, NULL);
                if (!e && strcasecomp(home_url, url) == 0)
                {
                    fe_message(msgs_lookup("goodbye:"));
                    exit(0);
                }
            }
        }

        if (!e)
            e = frontend_open_url(home_url, v, TARGET_TOP, NULL, 0);
    }
    return e;
}

/* ------------------------------------------------------------------------------------------- */

static fe_view fe_next_frame(fe_view v, BOOL next)
{
    do
    {
        if (v->children)
            v = next ? v->children : v->children_last;
        else if (next && v->next)
            v = v->next;
        else if (!next && v->prev)
            v = v->prev;
        else if (v->parent)
        {
            v = v->parent;
            if (next)
            {
                while (v && v->next == NULL)
                    v = v->parent;
                if (v)
                    v = v->next;
            }
            else
            {
                while (v && v->prev == NULL)
                    v = v->parent;
                if (v)
                    v = v->prev;
            }
        }
    }
    while (v && v->children);

    return v;
}

void fe_move_highlight_frame(fe_view v, BOOL next)
{
    fe_view vv;

    vv = fe_next_frame(v ? v : main_view, next);
    if (vv == NULL)
    {
        vv = main_view;
        if (next)
        {
            while (vv->children)
                vv = vv->children;
        }
        else
        {
            while (vv->children_last)
                vv = vv->children_last;
        }
    }

    if (v && v->displaying && v->current_link)
        backend_update_link(v->displaying, v->current_link, 0);

    if (vv)
    {
        fe_get_wimp_caret(vv->w);

        if (vv->displaying)
        {
            vv->current_link = backend_highlight_link(vv->displaying, NULL, (next ? 0 : be_link_BACK) | be_link_VISIBLE | be_link_DONT_HIGHLIGHT);

            if (vv->current_link)
            {
                if (!fe_caretise(vv))
                    backend_update_link(vv->displaying, vv->current_link, 1);
            }
            else
            {
                backend_place_caret(vv->displaying, NULL);
            }
        }
    }
}

void fe_move_highlight(fe_view v, int flags)
{
    be_item old_link, new_link;
    fe_view new_v;
    BOOL scrolled;

    if (!v || !v->displaying)
        return;

    pointer_mode = pointermode_ON;  // so that scroll_changed doesn't reposition highlight

    // if we had a caret shown then move from here
    // else from previous selection
    old_link = backend_place_caret(v->displaying, NULL);
    if (old_link == NULL)
        old_link = v->current_link;

    // try to move to next highlight if there is one
    new_link = backend_highlight_link(v->displaying, old_link, flags | be_link_DONT_WRAP | be_link_DONT_HIGHLIGHT);
    new_v = v;

    // if we have reached top/bottom of page then scroll and try again for a highlight
    if (new_link)
    {
        scrolled = FALSE;
    }
    else
    {
        scrolled = fe_view_scroll_y(v, flags & be_link_BACK ? +1 : -1);

        new_link = backend_highlight_link(v->displaying, old_link, flags | be_link_DONT_WRAP | be_link_DONT_HIGHLIGHT);

        /* if we couldn't scroll (bottom/top of page) try to move to next/prev frame */
        if (!new_link && !scrolled)
        {
            new_v = fe_next_frame(v, flags & be_link_BACK ? 0 : 1);

            /* don't want to wrap if this is the only frame */
            if (new_v == v)
                new_v = NULL;

            /* if can't move on then beep */
            if (new_v == NULL)
                bbc_vdu(7);
            else
            {
                /* else scroll new frame and find first visible link */
                fe_view_scroll_y(new_v, flags & be_link_BACK ? -3 : +3);
                new_link = backend_highlight_link(new_v->displaying, NULL, flags | be_link_DONT_HIGHLIGHT);
            }
        }
    }

    /* new_v == v, new_link != NULL: may have scrolled, new link         - update link
     * new_v == v, new_link == NULL: scrolled, no new link visible       - no action
     * new_v == NULL, couldn't scroll or change frame                    - beep
     * new_v != v, new_link != NULL: changed frame, new link             - update caret, link
     * new_v == v, new_link == NULL: changed frame, no new link visiible - update caret, old link
     */

    // if we have a new link or the frame has changed then update stuff
    if (new_v && (new_link || new_v != v))
    {
        new_v->current_link = new_link;

        if (old_link)
            backend_update_link(v->displaying, old_link, 0);

        // if the highlighted object is actually an INPUT then place caret
        if (!fe_caretise(new_v))
        {
            backend_update_link(new_v->displaying, new_link, 1);
            backend_place_caret(new_v->displaying, NULL);
        }
    }

    fe_pointer_mode_update(pointermode_OFF);
}

/* ------------------------------------------------------------------------------------------- */

/*
 * This is called when the clipboard is asked to save its data to an application
 */

static BOOL clip_save_text(const char *to, int file_type, void *handle)
{
    const char *from = clipboard_Data(NULL);
    return frontend_complain(os_swix4(OS_FSControl, 0x1A, from, to, 0)) == NULL;
    handle = handle;
    file_type = file_type;
}

static clipboard_itemstr clip_list_text[] =
{
    { 0xfff, 0, clip_save_text },
    { -1 }
};

static clipboard_itemstr clip_list_sprite[] =
{
    { 0xff9, 0, clip_save_text },
    { -1 }
};

/*
 * When destroying the clipboard then remove the file
 */

static void clip_destroy(void *data)
{
    char *file_name = clipboard_Data(NULL);
    remove(file_name);
    data = data;
}

int fe_copy_text_possible(fe_view v)
{
    return v && v->displaying;
}

void fe_copy_text_to_clipboard(fe_view v)
{
    clipboard_Destroy();    // must destroy first as we are reusing the filename
    if (backend_doc_saver_text(CLIP_FILE, v->displaying))
    {
        // register as the clip board - the filename is the data
        clipboard_CreateList(clip_list_text, clip_destroy, CLIP_FILE, CLIP_FILE_LEN, NULL);
    }
}

// if nothing selected then use the background image
static void *get_selected_image(fe_view v)
{
    be_item selected;
    void *im;

    if (!v || !v->displaying)
        return NULL;

    selected = backend_find_selected(v->displaying);
    if (!selected)
    {
        backend_item_info(v->displaying, NULL, NULL, NULL, &im);
        return im;
    }

    frontend_complain(backend_item_info(v->displaying, selected, NULL, NULL, &im));
    return im;
}

int fe_copy_image_possible(fe_view v)
{
    int flags;
    if (!v || !v->displaying)
        return FALSE;

    backend_doc_info(v->displaying, &flags, NULL, NULL, NULL);
    return (flags & be_doc_info_HAS_BG) != 0 || get_selected_image(v) != NULL;
}

void fe_copy_image_to_clipboard(fe_view v)
{
    void *im;

    im = get_selected_image(v);
    if (im)
    {
        clipboard_Destroy();    // must destroy first as we are reusing the filename

        if (backend_image_saver_sprite(CLIP_FILE, im))
        {
            // register as the clip board - the filename is the data
            clipboard_CreateList(clip_list_sprite, clip_destroy, CLIP_FILE, CLIP_FILE_LEN, NULL);
        }
    }
}

/* ------------------------------------------------------------------------------------------- */

/*
 *
 */

static os_error *fe_find_decode(const char *data)
{
    char *text, *dir, *casesense;

    fe_dbox_dispose();

    text = extract_value(data, "for=");
    dir = extract_value(data, "dir=");
    casesense = extract_value(data, "case=");

    fe_find(main_view, text,
        dir && strcmp(dir, "back") == 0,
        casesense && strcmp(casesense, "sense") == 0);

    mm_free(text);
    mm_free(dir);
    mm_free(casesense);

    return NULL;
}

static char *find__string = NULL;
static int find__backwards;
static int find__casesense;

static os_error *fe_find_write_file(FILE *f, void *handle)
{
    fputs(msgs_lookup("findT"), f);
    fputc('\n', f);

    fprintf(f, msgs_lookup("find1"), strsafe(find__string));
    fprintf(f, msgs_lookup("find2"), checked(find__casesense));
    fprintf(f, msgs_lookup("find3"), checked(!find__backwards),
        checked(find__backwards));

    fputs(msgs_lookup("findF"), f);
    fputc('\n', f);

    return NULL;
    handle = handle;
}

int fe_find_again_possible(fe_view v)
{
    return v && v->displaying && find__string && find__string[0];
}

void fe_find_again(fe_view v)
{
    char *s = strdup(find__string);
    fe_find(v, s, find__backwards, find__casesense);
    mm_free(s);
}

int fe_find_possible(fe_view v)
{
    return v && v->displaying;
}

os_error *fe_find_open(fe_view v)
{
    os_error *e = NULL;
    if (fe_find_possible(v))
    {
        wimp_box bb;
        fe_view dv;

        frontend_view_bounds(v, &bb);
#if 1
        fprintf(stderr, "find: bounds %d,%d %d,%d\n", bb.x0, bb.y0, bb.x1, bb.y1);
#endif

        bb.x0 = -1000;		/* Get the first on the line ignoring margins */
        backend_doc_locate_item(v->displaying, &bb.x0, &bb.y1, &v->find_last_item);

#if 1
        dv = fe_dbox_view();
        fe_get_wimp_caret(dv->w);
        fe_open_temp_file(dv, fe_find_write_file, v);
#else
        e = tb_find_open(v);
#endif
    }
    return e;
}

void fe_find(fe_view v, const char *text, int backwards, int casesense)
{
    if (!v || !v->displaying)
        return;

#if 1
    fprintf(stderr, "find: start item %p\n", v->find_last_item);
#endif

    mm_free(find__string);
    find__string = strdup(text);
    find__backwards = backwards;
    find__casesense = casesense;

    v->find_last_item = backend_find(v->displaying, v->find_last_item, (char *)text,
        (backwards ? be_find_BACKWARDS : 0) | (casesense ? 0 : be_find_CASELESS));

#if 1
    fprintf(stderr, "find: find item %p\n", v->find_last_item);
#endif

    if (v->find_last_item == NULL)
        bbc_vdu(7);
}

/* ------------------------------------------------------------------------------------------- */

os_error *fe_hotlist_add(fe_view v)
{
    char *url, *title;
    os_error *e;

    if (!v || !v->displaying || v->browser_mode != fe_browser_mode_WEB)
        return NULL;

    e = backend_doc_info(v->displaying, NULL, NULL, &url, &title);
    if (!e)
        e = hotlist_add(url, title);
    return e;
}

/*
 * If we are on the hotlist page then this wants to remove the selected item
 * else remove this page.
 */

os_error *fe_hotlist_remove(fe_view v)
{
    os_error *e;

    if (!v || !v->displaying)
        return NULL;

    if (v->browser_mode == fe_browser_mode_HOTLIST)
    {
        char *selected_url;
        be_item select = backend_find_selected(v->displaying);
        e = backend_item_info(v->displaying, select, NULL, &selected_url, NULL);
        if (!e && selected_url)
        {
            e = hotlist_remove(selected_url);
            if (!e) e = fe_hotlist_open(v);
        }
    }
    else
    {
        char *this_url;
        e = backend_doc_info(v->displaying, NULL, NULL, &this_url, NULL);
        if (!e) e = hotlist_remove(this_url);
    }
    return e;
}

/* ------------------------------------------------------------------------------------------- */

static os_error *fe_status_state(fe_view v, int state)
{
    BOOL is_open = tb_is_status_showing();
    BOOL new_state_open = state == -1 ? !is_open : state;

    if (new_state_open != is_open)
    {
        wimp_wstate state;

        // reopen window tiled with status window
        wimp_get_wind_state(v->w, &state);
        if (new_state_open)
        {
            v->margin.y1 = margin_box.y1 - tb_status_height();
        }
        else
        {
            v->margin.y1 = margin_box.y1;
        }
        wimp_open_wind(&state.o);

        // cause a reformat
        if (v->displaying)
        {
            frontend_view_set_dimensions(v, 0, 0);
            backend_reset_width(v->displaying, 0);
        }

        if (new_state_open)
        {
            tb_status_update_fades(v);
            tb_status_show(FALSE);
        }
        else
            tb_status_hide(FALSE);

        if (v->displaying && v->children)
            fe_refresh_window(v->w, NULL);

        v->status_open = new_state_open;
    }
    return NULL;
}

int fe_status_height_top(fe_view v)
{
    if (v->parent != NULL)
        return 0;
    if (!use_toolbox)
        return 0;
    return tb_is_status_showing() ? tb_status_height() : 0;
}

os_error *fe_status_toggle(fe_view v)
{
    os_error *e = NULL;

    v = fe_find_top(v);

    v->status_open = !v->status_open;

    if (use_toolbox)
        e = fe_status_state(v, v->status_open);
    else
        statuswin_toggle(v);

    return e;
}

void fe_status_clear_fetch_only(void)
{
    if (use_toolbox)
    {
        tb_status_hide(TRUE);
    }
    else
    {
        statuswin_clear(TRUE);
    }
}

void fe_status_open_fetch_only(fe_view v)
{
    if (use_toolbox)
    {
        tb_status_show(TRUE);
    }
    else
    {
        statuswin_open(v, TRUE);
    }
}

wimp_w fe_status_window_handle(void)
{
    return !use_toolbox ? statuswin_w : tb_is_status_showing() ? tb_status_w() : -1;
}

static void fe_status_mode(fe_view v, int mode)
{
    v->browser_mode = mode;

    if (use_toolbox)
    {
        if (mode == fe_browser_mode_DESKTOP || mode == fe_browser_mode_DBOX)    // if desktop mode then disable toolbar
            fe_status_state(fe_find_top(v), 0);
        else
            fe_status_state(fe_find_top(v), v->status_open);         // otherwise leave it in previous state
    }
    else
    {
        if (mode != fe_browser_mode_WEB)
            statuswin_clear(FALSE);
    }
}

os_error *fe_status_info_level(fe_view v, int level)
{
    if (use_toolbox)
    {
    }
    else
    {
        return statuswin_info_level(v, level);
    }
    return NULL;
}

/* ------------------------------------------------------------------------------------------- */

void fe_scroll_changed(fe_view v)
{
    if (use_toolbox)
    {
    }
    else
    {
        statuswin_refresh_slider(v);
    }

    if (pointer_mode == pointermode_OFF && v && v->displaying && v->current_link)
    {
        wimp_box box, bb;
        int dir;

        if (backend_doc_item_bbox(v->displaying, v->current_link, &box) == NULL)
        {
            frontend_view_bounds(v, &bb);

            dir = box.y1 < bb.y0 ? be_link_BACK : 0;
            v->current_link = backend_highlight_link(v->displaying, v->current_link, dir | be_link_VISIBLE | be_link_INCLUDE_CURRENT);
            fe_caretise(v);
        }
    }
}

/* ------------------------------------------------------------------------------------------- */

int fe_key_lookup(int chcode, const key_list *keys)
{
    const key_list *d;
    for (d = keys; d->key; d++)
        if (d->key == chcode)
        {
            if (d->flags & key_list_CLICK)
                fe_click_sound();

            if ((d->flags & key_list_REPEAT) == 0)
                _swix(OS_Byte, _IN(0), 0x78);

            return d->event;
        }
    return -1;
}

/* ------------------------------------------------------------------------------------------- */

void fe_menu_event_handler(int event)
{
    stbmenu_event_handler(event);
}

/* ------------------------------------------------------------------------------------------- */

BOOL fe_item_screen_box(fe_view v, be_item ti, wimp_box *box)
{
    coords_cvtstr cvt;

    if (!v || !ti || !v->displaying)
        return FALSE;

    backend_doc_item_bbox(v->displaying, ti, box);

    cvt = fe_get_cvt(v);
    coords_box_toscreen(box, &cvt);
    return TRUE;
}

void fe_fake_click(fe_view v, int x, int y)
{
    coords_cvtstr cvt;
    coords_pointstr p;

    if (!v || !v->displaying)
        return;

    cvt = fe_get_cvt(v);
    p.x = x;
    p.y = y;
    coords_point_toworkarea(&p, &cvt);

    last_click_x = p.x;
    last_click_y = p.y;
    last_click_view = v;

    backend_doc_click(v->displaying, p.x, p.y, wimp_BLEFT);
}

coords_cvtstr fe_get_cvt(fe_view v)
{
    coords_cvtstr cvt;
    if (v->w)
    {
        wimp_wstate state;
        if (frontend_complain(wimp_get_wind_state(v->w, &state)) != NULL)
            fprintf(stderr, "win %x v %p\n", v->w, v);
        return *(coords_cvtstr *)&state.o.box;
    }

    cvt.box = v->box;
    cvt.scx = cvt.scy = 0;
    return cvt;
}

/* ------------------------------------------------------------------------------------------- */
// Idle handling - status stuff
/* ------------------------------------------------------------------------------------------- */

static os_error *get_item_info(fe_view v, const wimp_mousestr *mp, int *flags, char **link)
{
    coords_pointstr p;
    coords_cvtstr cvt;
    be_item ti;
    os_error *e;

    p = *(coords_pointstr *)&mp->x;
    cvt = fe_get_cvt(v);
    coords_point_toworkarea(&p, &cvt);

    e = backend_doc_locate_item(v->displaying, &p.x, &p.y, &ti);
    if (!e) e = backend_item_pos_info(v->displaying, ti, p.x, p.y, flags, link, NULL);

    return e;
}

static void fe_update_link(fe_view v, int flags, const char *url)
{
    if (use_toolbox)
    {
        char buf[256];

        if (url && url[0])
        {
            strcpy(buf, msgs_lookup("lnk"));
            strlencat(buf, (char *)url, sizeof(buf));
        }
        else if (v->displaying)
        {
            if (akbd_pollsh())
            {
                char *url;
                backend_doc_info(v->displaying, NULL, NULL, &url, NULL);

                strcpy(buf, msgs_lookup("url"));
                strlencat(buf, url, sizeof(buf));
            }
            else
            {
                char *title;
                do
                {
                    backend_doc_info(v->displaying, NULL, NULL, NULL, &title);
                    if (!title)
                        v = v->parent;
                }
                while (v && !title);

                strcpy(buf, msgs_lookup("ttl"));
                strlencat(buf, title ? title : msgs_lookup("none"), sizeof(buf));
            }
        }

        tb_status_set_message(NULL, buf);
    }
    else
    {
        int type = fe_object_type_NONE;
        if (flags & (be_item_info_USEMAP | be_item_info_ISMAP))
            type = fe_object_type_MAP;
        else if (flags & (be_item_info_BUTTON | be_item_info_ACTION | be_item_info_INPUT | be_item_info_MENU))
            type = fe_object_type_FORM;
        else if (flags & be_item_info_LINK)
            type = fe_object_type_LINK;

        if (v->current_object_type != type)
        {
            v->current_object_type = type;
            statuswin_update_object_type(v, TRUE);
        }
    }
}

static fe_view find_view(wimp_w w)
{
    if (dbox_view && dbox_view->w == w)
        return dbox_view;

    return fe_find_window(main_view, w);
}

static void dump_views(fe_view top, int indent)
{
    fe_view v;
    for (v = top; v; v = v->next)
    {
        fprintf(stderr, "%*s v %p w %x\n", indent, "", v, v->w);
        if (v->children)
            dump_views(v->children, indent+2);
    }
}

static void fe_idle_handler(void)
{
    wimp_mousestr m;
    BOOL pointer_moved, highlight_moved, shift, shift_changed;
    fe_view v;

    int flags;
    char *link;

    frontend_fatal_error(wimp_get_point_info(&m));
    pointer_moved = m.x != pointer_last_pos.x || m.y != pointer_last_pos.y;

    shift = akbd_pollsh();
    shift_changed = shift != pointer_last_shift;

    // update last pointer position
    pointer_last_pos = m;
    pointer_last_shift = shift;

    v = find_view(m.w);

#if 0
if (pointer_moved)
{
    fprintf(stderr, "p %d,%d w %x v %p main %p\n", m.x, m.y, m.w, v, main_view);
    dump_views(main_view, 2);
}
#endif

    // are we dragging the page around?
    if (dragging_view)
    {
        tb_status_set_message(NULL, msgs_lookup("hscrl"));
        fe_drag(&m);
        return;
    }

    // are we resizing a frame?
    if (resizing_view)
    {
        tb_status_set_message(NULL, msgs_lookup("hrsz2"));
        fe_resize(&m);
        return;
    }

    flags = 0;
    link = NULL;

    // if map mode then move pointer and update links
    if (fe_map_view() != NULL)
    {
        // in map mode then update the link (if usemap)
        if (v)
        {
            get_item_info(v, &m, &flags, &link);
            if (pointer_moved)
                fe_update_link(v, flags, link);
        }

        // and check for the pointer moving
        fe_map_check_pointer_move(&m);
        return;
    }

    // if not over a view then get help message and exit
    if (!v)
    {
        // send a wimp message to ourselves so that the toolbox can dig out the help message.
        if (pointer_moved && use_toolbox && tb_is_status_showing())
        {
            wimp_msgstr msg;
            msg.hdr.size = sizeof(wimp_msghdr) + sizeof(wimp_msghelprequest);
            msg.hdr.your_ref = 0;
            msg.hdr.action = wimp_MHELPREQUEST;
            msg.data.helprequest.m = m;
            wimp_sendwmessage(wimp_ESEND, &msg, m.w, m.i);
        }

        if (!dragging_view && !resizing_view)
            fe_set_pointer(0);
        return;
    }

    highlight_moved = v->current_link != highlight_last_link;
    highlight_last_link = v->current_link;

    // if old mode then pulse a bit
    if (!use_toolbox)
    {
        fe_view vv = fe_find_top(v);
        if (vv && vv->fetch_document != 256)
            statuswin_update_fetch_status(vv, vv->fetch_status);
    }

    // if pointer is off (IR mode) update links from highlight
    if (pointer_mode == pointermode_OFF)
    {
        if (v->current_link)
            frontend_complain(backend_item_info(v->displaying, v->current_link, &flags, &link, NULL));

        if (highlight_moved)
            fe_update_link(v, flags, link);

        // check if the pointer has been moved and we need to go to pointer mode
        if (pointer_moved)
            fe_pointer_mode_update(pointermode_ON);
        return;
    }

    // if we are a frameset then select resizable pointer
    if (v->children)
    {
        int type = fe_check_resize(v, m.x, m.y, NULL, NULL, NULL);
#if 0
        if (type != be_resize_NONE)
            fprintf(stderr, "stbfe: resize %d\n", type);
#endif
        switch (type)
        {
            case be_resize_WIDTH:
                fe_set_pointer(fe_pointer_RESIZE_WIDTH);
                break;
            case be_resize_HEIGHT:
                fe_set_pointer(fe_pointer_RESIZE_HEIGHT);
                break;
            case be_resize_NONE:
                fe_set_pointer(0);
                break;
        }

        if (type != be_resize_NONE)
            tb_status_set_message(NULL, msgs_lookup("hrsz1"));

        return;
    }

    // otherwise update link from current position
    {
        get_item_info(v, &m, &flags, &link);
        if (pointer_moved || shift_changed)
            fe_update_link(v, flags, /* !akbd_pollsh() ? NULL : */ link);

        // don't want the pointer changing if on a blank section of a usemap
        if ((flags & be_item_info_USEMAP) && (!link || !*link))
            flags &= ~(be_item_info_USEMAP | be_item_info_ISMAP | be_item_info_LINK);

        // also update pointer shape
        fe_set_pointer(flags);
    }
}

/* ------------------------------------------------------------------------------------------- */
// dragging
/* ------------------------------------------------------------------------------------------- */

// these used by dragging and resizing
static int dragging_last_x, dragging_last_y;

// this used by dragging only
fe_view dragging_view = NULL;

static void fe_dragging_start(fe_view v, const wimp_mousestr *m)
{
    wimp_dragstr drag;
    wimp_box extent;
    coords_cvtstr cvt;
    wimp_mousestr mm;

    // check if we are still over the window we are ment to be dragging
    wimp_get_point_info(&mm);
    if (mm.w != m->w)
        return;

    cvt = fe_get_cvt(v);

    extent.x1 = v->doc_width - cvt.scx + cvt.box.x0 - v->margin.x1;
    extent.x0 =              - cvt.scx + cvt.box.x0 - v->margin.x0;
    extent.y0 = v->doc_height - cvt.scy + cvt.box.y1 - v->margin.y0;
    extent.y1 =               - cvt.scy + cvt.box.y1 - v->margin.y1;

    if (extent.x1 < cvt.box.x1)
        extent.x1 = cvt.box.x1;
    if (extent.x0 > cvt.box.x0)
        extent.x0 = cvt.box.x0;
    if (extent.y1 < cvt.box.y1)
        extent.y1 = cvt.box.y1;
    if (extent.y0 > cvt.box.y0)
        extent.y0 = cvt.box.y0;

    drag.window = v->w;
    drag.type = wimp_USER_HIDDEN;
    drag.parent.x0 = m->x - (extent.x1 - cvt.box.x1);
    drag.parent.x1 = m->x - (extent.x0 - cvt.box.x0);
    drag.parent.y0 = m->y - (extent.y1 - cvt.box.y1);
    drag.parent.y1 = m->y - (extent.y0 - cvt.box.y0);

#if 0
    fprintf(stderr, "dragging: start box %d,%d %d,%d\n", drag.parent.x0, drag.parent.y0, drag.parent.x1, drag.parent.y1);
#endif
    if (frontend_complain(wimp_drag_box(&drag)) == NULL)
    {
        dragging_view = v;
        dragging_last_x = m->x;
        dragging_last_y = m->y;
#if 1
        fprintf(stderr, "dragging: started at %d,%d\n", m->x, m->y);
#endif
        fe_set_pointer(fe_pointer_DRAG);
        fast_poll++;
    }
}

static void fe_drag(const wimp_mousestr *m)
{
    if (m->bbits == 0)
    {
        dragging_view = NULL;
        fe_set_pointer(0);
        fast_poll--;
#if 1
        fprintf(stderr, "dragging: buttons released\n");
#endif
    }
    else if (m->x != dragging_last_x || m->y != dragging_last_y)
    {
        wimp_wstate state;
#if 0
        fprintf(stderr, "dragging: view %p to %d,%d\n", dragging_view, m->x, m->y);
#endif
        if (frontend_complain(wimp_get_wind_state(dragging_view->w, &state)) == NULL)
        {
            state.o.x -= m->x - dragging_last_x;
            state.o.y -= m->y - dragging_last_y;
            frontend_complain(wimp_open_wind(&state.o));

            dragging_last_x = m->x;
            dragging_last_y = m->y;
        }
        else
        {
#if 1
            fprintf(stderr, "dragging: cancelled due to error\n");
#endif
            dragging_view = NULL;
            fe_set_pointer(0);
            fast_poll--;
        }
    }
}

/* ------------------------------------------------------------------------------------------- */

fe_view resizing_view = NULL;

static void fe_resizing_start(fe_view v, const wimp_mousestr *m, const wimp_box *bounds, int type)
{
    wimp_dragstr drag;

    resizing_view = v;                  // record the view containing the framese we are resizing

    drag.window = fe_find_top(v)->w;    // we aleays actually dragging the top window
    drag.type = wimp_USER_FIXED;
    drag.parent = *bounds;
    drag.box = *bounds;
    if (type == be_resize_WIDTH)
        drag.box.x0 = drag.box.x1 = m->x;
    else
        drag.box.y0 = drag.box.y1 = m->y;

#if 1
    fprintf(stderr, "resizing: start box %d,%d %d,%d\n", drag.parent.x0, drag.parent.y0, drag.parent.x1, drag.parent.y1);
#endif

    if (frontend_complain(wimp_drag_box(&drag)) == NULL)
    {
        dragging_last_x = m->x;
        dragging_last_y = m->y;
#if 1
        fprintf(stderr, "resizing: started at %d,%d\n", m->x, m->y);
#endif
    }
}

static BOOL fe_resize(const wimp_mousestr *m)
{
    if (m->bbits == 0)
    {
        fe_view v = resizing_view;
        coords_cvtstr cvt = fe_get_cvt(v);

        resizing_view = NULL;
#if 1
        fprintf(stderr, "resizing: buttons released\n");
#endif
        backend_frame_resize(v->displaying,
            coords_x_toworkarea(m->x, &cvt),
            coords_y_toworkarea(m->y, &cvt),
            v->resize_handle);

        fe_set_pointer(0);
        return TRUE;
    }
#if 0
    else if (m->x != dragging_last_x || m->y != dragging_last_y)
    {
#if 0
        fprintf(stderr, "resizing: view %p to %d,%d\n", resizing_view, m->x, m->y);
#endif
        dragging_last_x = m->x;
        dragging_last_y = m->y;
    }
#endif
    return FALSE;
}

void fe_resize_abort(void)
{
    if (resizing_view)
    {
        wimp_drag_box(NULL);

        resizing_view = NULL;
        fe_set_pointer(0);
    }
}

static int fe_check_resize(fe_view start, int x, int y, wimp_box *box, int *handle, fe_view *resizing_v)
{
    fe_view v;
    for (v = start; v; v = v->next)
    {
#if 0
        fprintf(stderr, "resize: view %p\n", v);
#endif
        if (v->displaying)
        {
            coords_cvtstr cvt = fe_get_cvt(v);

            int type = backend_frame_resize_bounds(v->displaying,
                coords_x_toworkarea(x, &cvt),
                coords_y_toworkarea(y, &cvt),
                box, handle);

            if (type != be_resize_NONE)
            {
                if (resizing_v)
                    *resizing_v = v;
                return type;
            }
        }

        if (v->children)
        {
            int type = fe_check_resize(v->children, x, y, box, handle, resizing_v);
            if (type != be_resize_NONE)
                return type;
        }
    }
    return be_resize_NONE;
}

/* ------------------------------------------------------------------------------------------- */

static int fe_mouse_handler(fe_view v, wimp_mousestr *m)
{
#ifdef TRACE_FN
    fprintf(stderr, "click: w %x view %s\n", m->w, v && v->name ? v->name : "<none>");
#endif

    if (!v)
        return FALSE;

    fe_get_wimp_caret(m->w);                                    // in case we had lost it
    fe_pointer_mode_update(pointermode_ON);

    switch (m->bbits)
    {
        case wimp_BMID:
            if (use_toolbox && v->browser_mode != fe_browser_mode_DESKTOP && v->browser_mode != fe_browser_mode_DBOX)
                fe_status_toggle(v);
            break;

        case wimp_BDRAGLEFT:
            if (v->displaying)
            {
                if (v->children)
                {
                    wimp_box box;
                    int type;
                    fe_view vv;
                    int resize_handle;

                    type = fe_check_resize(v, m->x, m->y, &box, &resize_handle, &vv);

                    if (type != be_resize_NONE)
                    {
                        coords_cvtstr cvt = fe_get_cvt(vv);
                        vv->resize_handle = resize_handle;
#if 0
                        fprintf(stderr, "stbfe: resize %d\n", type);
#endif
                        coords_box_toscreen(&box, &cvt);
                        fe_resizing_start(vv, m, &box, type);
                    }
                }
                else
                {
                    fe_dragging_start(v, m);
                }
            }
            break;

        case wimp_BLEFT:
        case wimp_BRIGHT:
            if (v->displaying)
            {
                wimp_wstate state;
                wimp_get_wind_state(m->w, &state);
                coords_point_toworkarea((coords_pointstr *)&m->x, (coords_cvtstr *)&state.o.box);

                last_click_x = m->x;
                last_click_y = m->y;
                last_click_view = v;
                backend_doc_click(v->displaying, m->x, m->y, m->bbits);
            }
            break;
    }

    return TRUE;
}

/* ------------------------------------------------------------------------------------------- */

typedef struct fe_redraw_box
{
    struct fe_redraw_box *next;
    wimp_box box;
} fe_redraw_box;

static void fe_redraw_handler(fe_view v, wimp_w w)
{
    fe_redraw_box *box_list = NULL;
    wimp_redrawstr r;
    int more;

#if 0
    fprintf(stderr, "redraw: w %x view %s\n", w, v && v->name ? v->name : "<none>");
#endif

    r.w = w;
    wimp_redraw_wind(&r, &more);

    while (more)
    {
        if (v)
        {
            if (v->displaying)
            {
                fe_redraw_box *box;

                box = mm_calloc(sizeof(fe_redraw_box), 1);

                box->box = r.g;
                coords_box_toworkarea(&box->box, (coords_cvtstr *)&r.box);

                box->next = box_list;
                box_list = box;
            }
            else
            {
                int gcol;
                colourtran_setGCOL(config_colours[render_colour_BACK], 0, 0, &gcol);
                bbc_rectanglefill(r.g.x0, r.g.y0, r.g.x1 - r.g.x0, r.g.y1 - r.g.y0);
            }
        }
        else
        {
            if (!tb_status_redraw(&r) &&
                !tb_find_redraw(&r) &&
                !tb_print_redraw(&r))
                /* do nothing */;
            fe_anti_twitter(&r.g);
        }
        wimp_get_rectangle(&r, &more);
    }

    while (box_list)
    {
        fe_redraw_box *next = box_list->next;

        frontend_view_update(v, &box_list->box, backend_render_rectangle, v->displaying, fe_update_WONT_PLOT_ALL);

        mm_free(box_list);
        box_list = next;
    }
}


/* ------------------------------------------------------------------------------------------- */
// Message handlers
/* ------------------------------------------------------------------------------------------- */

static void fe_doc_bounce(wimp_msgdataopen *dataopen)
{
    char buffer[256], *s;

    sprintf(buffer, "Alias$@RunType_%03x", dataopen->type);
    s = getenv(buffer);
    if (s && *s)
    {
        sprintf(buffer, "/%s", dataopen->name);
        frontend_complain(wimp_starttask(buffer));
    }
    else
        fe_report_error(msgs_lookup("nold"));
}

#define STBWEB_RETURNED_FRAMES "STBWeb$ReturnedFrames"

static void fe_url_bounce(urlopen_data* ud)
{
    /* We have got back a URL that no appliaction wanted to use.  Try to start an application */
    char buffer[262];	        /* 6 chars on the front for the 'Alias$' */
    char buffer2[256];
    char *url;
    char *scheme, *netloc, *path, *params, *query, *fragment;

    url = (ud->indirect.tag == 0) ? ud->indirect.url : ud->url;

    url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);

    // check for an unloaded external helper
    strcpy(buffer, "Alias$URLOpen_");
    strcat(buffer, scheme);

    os_read_var_val(buffer, buffer2, sizeof(buffer2));

    if (buffer2[0])
    {
        // run external helper
	strcat(buffer, " ");
	strncat(buffer, url, sizeof(buffer) - strlen(buffer) - 1);

        // clear return var
        _swix(OS_SetVarVal, _INR(0,2), STBWEB_RETURNED_FRAMES, NULL, -1);

	frontend_complain(wimp_starttask(buffer + 6));

        // check for any pages to load
        {
            char *s = getenv(STBWEB_RETURNED_FRAMES);
#if 0
fprintf(stderr, "stbfe: returned_frames'%s\n", s ? s : "<empty>");
#endif
            if (s)
            {
                char *ss;
                if ((ss = strtok(s, " ")) != NULL) do
                {
                    char *url, *target;
                    target = extract_value(ss, "target=");
                    url = extract_value(ss, "url=");

#if 0
fprintf(stderr, "stbfe: target='%s' url='%s'\n", target, url);
#endif

                    frontend_complain(frontend_open_url(url, main_view, target, NULL, 0));

                    mm_free(target);
                    mm_free(url);
                }
                while ((ss = strtok(NULL, " ")) != NULL);
            }
        }
    }
    // check for internal helper
    else if (strcasecomp(scheme, "mailto") == 0 && can_do_mailto())
    {
        frontend_complain(fe_open_mailto(path));
    }
    else
    {    // give error
        char tag[32], *s;
        sprintf(tag, "noscheme_%s:", scheme);
        s = msgs_lookup(tag);
        if (s && s[0])
            fe_report_error(s);
        else
	    frontend_complain(makeerrorf(ERR_UNSUPORTED_SCHEME, scheme ? scheme : msgs_lookup("none")));
    }

    url_free_parts(scheme, netloc, path, params, query, fragment);

    if (fe_stored_url)
    {
	rma_free(fe_stored_url);
	fe_stored_url = NULL;
    }
}

static void fe_mode_changed(void)
{
    int dx, dy;
    wimp_box old_screen;

    dx = frontend_dx;
    dy = frontend_dy;

    old_screen = screen_box;

    feutils_init_1();
    feutils_init_2();

    if ((frontend_dx != dx) || (frontend_dy != dy))
	frontend_complain(webfonts_init());

    frontend_complain(backend_screen_changed(be_change_MODE));

    if (use_toolbox && tb_is_status_showing())
    {
        tb_status_resize(screen_box.x1 - old_screen.x1, screen_box.y1 - old_screen.y1);
        tb_status_show(FALSE);
    }
}

static void fe_handle_dataopen(wimp_msgstr *msg)
{
    int ftype;

    ftype = msg->data.dataload.type;
    if (ftype == FILETYPE_HTML || ftype == FILETYPE_GOPHER || ftype == FILETYPE_URL)
    {
	frontend_complain(fe_show_file(main_view, msg->data.dataload.name, FALSE));

	msg->hdr.your_ref = msg->hdr.my_ref;
	msg->hdr.action = wimp_MDATALOADOK;
	frontend_fatal_error(wimp_sendmessage(wimp_ESEND, msg, msg->hdr.task));
    }
}

static void fe_handle_datasave(wimp_msgstr *msg)
{
    fe_view v = find_view(msg->data.dataload.w);

    if (v) switch (msg->data.dataload.type)
    {
        default:
            if (!image_type_test(msg->data.dataload.type))
                break;
            /* deliberate fall-through */
        case FILETYPE_TEXT:
        case FILETYPE_HTML:
        case FILETYPE_GOPHER:
        case FILETYPE_URL:
	    msg->hdr.your_ref = msg->hdr.my_ref;
    	    msg->hdr.action = wimp_MDATASAVEOK;
    	    frontend_fatal_error(wimp_sendmessage(wimp_ESEND, msg, msg->hdr.task));
            break;
    }
}

static void fe_handle_dataload(wimp_msgstr *msg)
{
    fe_view v = find_view(msg->data.dataload.w);
    BOOL handled = FALSE;

    if (!v)
        return;

    switch (msg->data.dataload.type)
    {
        case FILETYPE_TEXT:
            if (v->displaying == NULL)
	        frontend_complain(fe_show_file(v, msg->data.dataload.name, FALSE));
	    else
	        fe_type_file(v, msg->data.dataload.name);
            break;

        case FILETYPE_HTML:
        case FILETYPE_GOPHER:
        case FILETYPE_URL:
        case FILETYPE_DIRECTORY:
        case 0x2000:
	    frontend_complain(fe_show_file(v, msg->data.dataload.name, FALSE));
	    handled = TRUE;
            break;

        default:
            if (image_type_test(msg->data.dataload.type))
            {
	        frontend_complain(fe_show_file(v, msg->data.dataload.name, FALSE));
	        handled = TRUE;
	    }
            break;
    }

    if (handled)
    {
	msg->hdr.your_ref = msg->hdr.my_ref;
	msg->hdr.action = wimp_MDATALOADOK;
	frontend_fatal_error(wimp_sendmessage(wimp_ESEND, msg, msg->hdr.task));
    }
}

static void fe_handle_openurl(wimp_msgstr *msg)
{
    urlopen_data *ud = (urlopen_data*) &msg->data;
    char *url;
    char *scheme, *netloc, *path, *params, *query, *fragment;
    int i;

    url = (ud->indirect.tag == 0) ? ud->indirect.url : ud->url;

    url_parse(url, &scheme, &netloc, &path, &params, &query, &fragment);

    for(i=0; access_schemes[i]; i++)
    {
        if (strcasecomp(scheme, access_schemes[i]) == 0)
        {
            char *curl;
            int len;

            curl = strdup(url);
            len = strlen(curl);

            while(len && isspace(curl[len-1]))
                len--;

            curl[len] = 0;

            frontend_complain(frontend_open_url(curl, NULL, NULL, NULL, 0));

            mm_free(curl);

            msg->hdr.your_ref = msg->hdr.my_ref;
            frontend_fatal_error(wimp_sendmessage(wimp_EACK, msg, msg->hdr.task));
        }
    }

    url_free_parts(scheme, netloc, path, params, query, fragment);
}

/* ------------------------------------------------------------------------------------------- */

static void fe_handle_service_message(wimp_msgstr *msg)
{
    os_regset *r = (os_regset *)&msg->data.words[0];

#if 1
    fprintf(stderr, "stbfe: service %x r2=%d\n", r->r[1], r->r[2]);
#endif

    switch (r->r[1])
    {
        case Service_DiallerStatus:
        {
            int new_state = r->r[2];

            if (new_state != dialler_CONNECTED_OUTGOING)
            {
                /* only reload stuff on first connection */
                if (connection_count++ == 0)
                {
                    connection_up = 1;

                    auth_init();

                    if (config_cookie_enable)
                        cookie_read_file(config_cookie_file);
                }
            }
            break;
        }
    }
}

/* ------------------------------------------------------------------------------------------- */
// Main event process loop
/* ------------------------------------------------------------------------------------------- */

void fe_event_process(void)
{
    wimp_eventstr e;

    if (fe_pending_url)
    {
        fe_handle_pending_url(fe_pending_url, fe_pending_bfile);
        mm_free(fe_pending_bfile);
        mm_free(fe_pending_url);
        fe_pending_bfile = NULL;
        fe_pending_url = NULL;
    }

    // do the standard poll loop
    if (fast_poll)
    {
        frontend_fatal_error(wimp_poll((wimp_emask)(wimp_EMPTRLEAVE | wimp_EMPTRENTER), &e));
    }
    else
    {
        int next = alarm_timenow() + 20;
        int next_alarm_time;

        if (alarm_next(&next_alarm_time))
        {
            if (next > next_alarm_time)
                next = next_alarm_time;
        }

        frontend_fatal_error(wimp_pollidle((wimp_emask)(wimp_EMPTRLEAVE | wimp_EMPTRENTER), &e, next));
    }

    switch (e.e)
    {
        case wimp_ENULL:
            fe_idle_handler();

            // keep the alarms running
            {
                int time;
                if (alarm_next(&time) && alarm_timenow() >= time)
                    alarm_callnext();
            }
            break;

        case wimp_ECLOSE:
            wimp_close_wind(e.data.o.w);
            break;

        case wimp_EOPEN:
            wimp_open_wind(&e.data.o);
            break;

        case wimp_EBUT:
            if (!stbmenu_check_mouse(&e.data.but.m))
                fe_mouse_handler(find_view(e.data.but.m.w), &e.data.but.m);
	    break;

        case wimp_EKEY:
        {
            fe_view v = find_view(e.data.key.c.w);
#if 0
            fprintf(stderr, "key: view %p '%s' key %x\n", v, v && v->name ? v->name : "", e.data.key.chcode);
#endif

            fe_key_handler(v, &e, use_toolbox, v->browser_mode);
            break;
        }

        case wimp_EREDRAW:
            if (!statuswin_check_redraw(main_view, e.data.o.w) &&
                !stbmenu_check_redraw(e.data.o.w))
                fe_redraw_handler(find_view(e.data.o.w), e.data.o.w);
            break;

        case wimp_ELOSECARET:
        {
            fe_view v = find_view(e.data.c.w);
            if (v)
            {
                if (v->current_link)
                {
                    backend_update_link(v->displaying, v->current_link, 0);
                    v->current_link = NULL;
                }

                if (v == selected_view)
                {
                    fe_view v_top;

                    selected_view = NULL;

                    v_top = fe_find_top(v);
                    if (v_top && v_top != v)
                        fe_refresh_window(v_top->w, NULL);
                }
            }
            break;
        }

        case wimp_EGAINCARET:
        {
            fe_view v = find_view(e.data.c.w);
            fe_view v_top;

            selected_view = v;

            v_top = fe_find_top(v);
            if (v_top && v != v_top)
                fe_refresh_window(v_top->w, NULL);
            break;
        }

        case wimp_EPTRENTER:
            break;

        case wimp_EPTRLEAVE:
            break;

        case wimp_ESEND:
        case wimp_ESENDWANTACK:
        {
            wimp_msgstr *msg = &e.data.msg;
            if (!clipboard_eventhandler(&e, NULL))
                switch (msg->hdr.action)
            {
	        case wimp_MOPENURL:
	            fe_handle_openurl(&e.data.msg);
	            break;
 	        case wimp_MDATAOPEN:
		    fe_handle_dataopen(&e.data.msg);
		    break;
 	        case wimp_MDATALOAD:
		    fe_handle_dataload(&e.data.msg);
		    break;
 	        case wimp_MDATASAVE:
		    fe_handle_datasave(&e.data.msg);
		    break;
	        case wimp_MMODECHANGE:
	            fe_mode_changed();
	            break;
	        case wimp_PALETTECHANGE:
	            backend_screen_changed(be_change_PALETTE);
	            break;

                case wimp_MHELPREPLY:
                    if (use_toolbox)
                        tb_status_set_message(NULL, msg->data.helpreply.text);
                    break;

                case wimp_MSERVICE:
                    fe_handle_service_message(&e.data.msg);
                    break;

                case wimp_MCLOSEDOWN:
                    exit(0);
            }
            break;
        }

        case wimp_EACK:
            if (!clipboard_eventhandler(&e, NULL))
	        switch (e.data.msg.hdr.action)
	    {
	        case wimp_MOPENURL:
	            fe_url_bounce((urlopen_data*) &(e.data.msg.data));
	            break;

                case wimp_MDATAOPEN:
                    fe_doc_bounce(&e.data.msg.data.dataopen);
                    break;
	    }
	    break;

        case 0x200: // toolbox events
            tb_events((int *)&e.data, selected_view ? selected_view : main_view);
            break;
    }
}

/* ------------------------------------------------------------------------------------------- */
// Initialisation and finalisation
/* ------------------------------------------------------------------------------------------- */

/* Some bits nicked from wimpt to initialise the system */

typedef void SignalHandler(int);
static SignalHandler *oldhandler;

static void escape_handler(int sig)
{
   sig = sig; /* avoid compiler warning */
   (void) signal(SIGINT, &escape_handler);
}

static void handler(int signal)
{
   os_error er;
   er.errnum = 0;
   sprintf(
       er.errmess,
       msgs_lookup("fatal1:%s has suffered a fatal internal error (type=%i) and must exit immediately"),
       program_title,
       signal);
//   wimp_reporterror(&er, (wimp_errflags)0, program_title);
   fe_report_error(er.errmess);
}

static void signal_init(void)
{
    oldhandler = signal(SIGABRT, &handler);
    oldhandler = signal(SIGFPE, &handler);
    oldhandler = signal(SIGILL, &handler);
    oldhandler = signal(SIGINT, &escape_handler);
    oldhandler = signal(SIGSEGV, &handler);
    oldhandler = signal(SIGTERM, &handler);
}

static int my_wimp_initialise(int *message_list)
{
    os_regset r;
    r.r[0] = 350;
    r.r[1] = *(int *) "TASK";
    r.r[2] = (int) program_title;
    r.r[3] = (int) message_list;

    frontend_fatal_error(os_swix(Wimp_Initialise,&r));

    return r.r[1];
}

/* ------------------------------------------------------------------------------------------- */

static void fe_tidyup(void)
{
    fprintf(stderr, "\n*** Exit function called ***\n\n");

    _swix(TaskModule_DeRegisterService, _INR(0,2), 0, Service_DiallerStatus, task_handle);

    fe_dispose_view(main_view);
    main_view = 0;

    clipboard_Destroy();

    webfonts_tidyup();
    image_tidyup();
    /* Image needs to come before access in the tidyup because image used access */
    access_tidyup();

    if (fe_stored_url)
	rma_free(fe_stored_url);

    pointer_reset_shape();
    os_swix0(Hourglass_Smash);

    /* Before we go, look for memory leeks */
    mm_dump();
}

static int message_codes[] =
{
    wimp_MDATAOPEN,
    wimp_MDATALOAD,
    wimp_MDATALOADOK,
    wimp_MDATASAVE,
    wimp_MDATASAVEOK,
    Message_ClaimEntity,
    Message_DataRequest,
    wimp_MHELPREPLY,
    wimp_MOPENURL,
    wimp_MMODECHANGE,
    wimp_PALETTECHANGE,
    wimp_MSERVICE,
    wimp_MCLOSEDOWN
};

static BOOL fe_initialise(void)
{
    os_error *e;

#if HEAPCHECK
    void __heap_checking_on_all_allocates(void);
    void __heap_checking_on_all_deallocates(void);

    __heap_checking_on_all_allocates();
    __heap_checking_on_all_deallocates();
#endif
    /* Initialise the WIMP stuff */
    visdelay_init();
    visdelay_begin();

    atexit(&fe_tidyup);
    signal_init();

    if (use_toolbox)
    {
        task_handle = tb_init(message_codes);

        tb_res_init(program_name);
        tb_resspr_init();
        tb_msgs_init();
    }
    else
    {
        task_handle = my_wimp_initialise(message_codes);

        res_init(program_name);
        resspr_init();
        msgs_init();
    }
    fprintf(stderr, "task handle: %x\n", task_handle);

    /* Init our configuration */
    config_init();

    feutils_init_1();
    feutils_init_2();

    if (use_toolbox)
        tb_status_init();

    HTMLDTDTableFixup();
    parse_frames(config_display_frames);

    /* Init the ANTWeb bits */
    frontend_fatal_error(access_init(0));
    image_init();
    auth_init();

    /* Check the licence */
    if (frontend_complain(licence_init()) != NULL)
    {
	exit(0);
    }

    /* Now bring up the flex system->.. */
    flex_init(program_name);

    image_get_cooler_table();

#if NEW_WEBIMAGE
    imginit("<STBWeb$Dir>.DLLs.");
#endif

    /* ... and imidiately allow budging */
    // with ROM Risc OSLib budging is on by default
//    _kernel_register_slotextend(flex_budge);


    fe_stored_url = NULL;
    frontend_complain(webfonts_init());

    statuswin_sprite_init();

    {
        fe_frame_info info;
        info.name = "__top";
        info.noresize = TRUE;
        info.scrolling = fe_scrolling_NO;
        *(wimp_box *)&info.margin = margin_box;
        frontend_fatal_error(fe_new_view(NULL, &screen_box, &info, &main_view));
        main_view->status_open = TRUE;
    }

    fe_get_wimp_caret(main_view->w);

    e = (os_error *)_swix(TaskModule_RegisterService, _INR(0,2), 0, Service_DiallerStatus, task_handle);
    if (e)
        fprintf(stderr, "taskmodule: %x %s\n", e->errnum, e->errmess);

    // initialise pointer state, based on new SWI
#if 0
    {
        int pointer = 1;
        _swix(OS_Pointer, _IN(0) | _OUT(0), 2, &pointer);
        fe_pointer_mode_update(pointer ? pointermode_ON : pointermode_OFF);
    }
#endif
    frontend_fatal_error(wimp_get_point_info(&pointer_last_pos));

    visdelay_end();

    return 1;
}


/* ------------------------------------------------------------------------------------------- */

#if STBWEB_ROM
int __root_stack_size = 16*1024;
extern int disable_stack_extension;
#endif

int main(int argc, char **argv)
{
    int init_ok;

#if STBWEB_ROM
    disable_stack_extension = 1;
#endif

    setlocale(LC_ALL, "");
    setbuf(stderr, NULL);   // no caching

    progname = argv[0];
    argv++;
    argc--;

    if (argc > 0 && (strncmp(argv[0], "-x", 2)==0) )
    {
	debug_level = atoi(argv[0] + 2);
	argc--;
	argv++;
    }

    if (argc > 0 && strcmp(argv[0], "-t") == 0)
    {
        use_toolbox = TRUE;
	argc--;
	argv++;
    }

    init_ok = fe_initialise();

    if (init_ok)
    {
        char *welcome_url = NULL;

	while (argc > 0)
	{
            if (welcome_url == NULL)
            {
                // extract the first command line argument as welcome page
                if (strcasecomp(argv[0], "-URL") == 0)
                {
    		    argv++;
    		    argc--;
    		    welcome_url = strdup(argv[0]);
    		}
    		else
                    frontend_complain(fe_file_to_url(argv[0], &welcome_url));
            }

	    argv++;
	    argc--;
	}

        if (welcome_url)
        {
            frontend_complain(frontend_open_url(welcome_url, main_view, NULL, NULL, 0));
            mm_free(welcome_url);
            welcome_url = NULL;
        }
        else
        {
            fe_home(main_view);
        }

	/* The main event loop */
	while (TRUE)
	    fe_event_process();
    }

    return 0;
}

/* ------------------------------------------------------------------------------------------- */
// Hack functions
/* ------------------------------------------------------------------------------------------- */

// to cope with running possibly under the toolbox we have these functions here

#undef resspr_area
extern sprite_area *resspr_area(void);

#undef msgs_lookup
extern char *msgs_lookup(char *tag);

sprite_area *fe_resspr_area(void)
{
    return use_toolbox ? (sprite_area *)tb_resspr_area() : resspr_area();
}

char *fe_msgs_lookup(char *tag)
{
    return use_toolbox ? tb_msgs_lookup(tag) : msgs_lookup(tag);
}

/* ----------------------------------------------------------------------------------------------------- */

/*
fprintf(stderr, "scheme = %s\n", scheme ? scheme : "");
fprintf(stderr, "netloc = %s\n", netloc ? netloc : "");
fprintf(stderr, "path = %s\n", path ? path : "");
fprintf(stderr, "params = %s\n", params ? params : "");
fprintf(stderr, "query = %s\n", query ? query : "");
fprintf(stderr, "fragment = %s\n", fragment ? fragment : "");
 */
