/* -*-c-*- */

/* 01-03-96 DAF Handling of new table structures */
/* 21-03-96 DAF New formatter */
/* 26-03-96 DAF Rewrote borders more carefully */
/* 22-03-96 SJM new functions antweb_update_item_trim, antweb_handle_url, backend_item_pos_info
                added fetching to dispose_doc.
 * 26-03-96 SJM replaced calls to frontend_view_set_dim with be_set_dim which can reformat if a scroll bar
                has been added.
   01-04-96 SJM update backend_reset_width to cope with relaying frames
   02-04-96 SJM added backend_temp_file_name, backend_temp_file_register, backend_check_meta
   03-04-96 SJM added backend_select_item, backend_find_selected
   15-04-96 SJM fixed item_pos_info so ISMAP link doesn't overwrite USEMAP link,
                and so that coordinates are calculated properly.
   18-04-96 SJM disabled link following when ctrl held down (as with oimage_click()), make select instead
                make place_caret() return previous position
                make update_link also affect non-links.
   30-04-96 SJM added new fields to frontend_view_dimensions for laying out frames
                added hooks to layout for frame resizing in dispose_doc and new functions
   07-05-96 SJM image_tile change
   09-05-96 SJM Fixed goto_fragment. If fragment is first in document then ai->first==NULL.
   20-05-96 SJM in doc_abort discard any images that are coming down
   23-05-96 SJM calls to cache functions now go to access_ wrappers
   04-06-96 SJM new call to image_os_to_pixels for image coord translation
   11-06-96 SJM image_info() no longer does config image scaling so changes to offset this
   20-06-96 SJM added check for imagemap error in doc_pos_info.
   24-06-96 SJM removed use of basetarget. changed image_change fns to cope with image_cb_status_WORLD
 */

#if 0
#define TABDBG(X)       fprintf X
#else
#define TABDBG(X)
#endif
#define NTABDBG(X)

#if 0
#define LOCATEDBG(X)       fprintf X
#else
#define LOCATEDBG(X)
#endif

#if 0
#define FMTDBG(X)       fprintf X
#else
#define FMTDBG(X)
#endif
#define NFMTDBG(X)


/* WIMP code for the ANTWeb WWW browser */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "memwatch.h"

#include "wimp.h"
#include "msgs.h"
#include "font.h"
#include "swis.h"
#include "colourtran.h"
#include "bbc.h"
#include "alarm.h"
#include "akbd.h"

#include "rid.h"
#include "antweb.h"
#include "webfonts.h"
#include "url.h"
#include "util.h"
#include "makeerror.h"
#include "images.h"
#include "tables.h"
#include "indent.h"

#include "status.h"

#include "filetypes.h"
#include "consts.h"
#include "object.h"
#include "auth.h"
#include "config.h"
#include "parsers.h"

#include "interface.h"
#include "savedoc.h"

#include "render.h"
#include "rcolours.h"

#include "printing.h"
#include "drawfile.h"
#include "imagemap.h"
#include "layout.h"

#include "version.h"
#include "verstring.h"

#include "myassert.h"

#ifndef DEBUG_IMAGE_CHANGE
#define DEBUG_IMAGE_CHANGE 0
#endif

#ifndef RENDER_DEBUG
#define RENDER_DEBUG 0
#endif

#ifndef PP_DEBUG
#define PP_DEBUG 0
#endif

/* This is on its own because the include file that it is in includes lots of others */
extern int strcasecomp(const char *s1, const char *s2);
extern void rid_zero_widest_height_from_item(rid_text_item *item);

/**********************************************************************/

rid_text_item *antweb_prev_text_item(rid_text_item *ti);
static os_error *antweb_document_sizeitems(antweb_doc *doc);
static void antweb_doc_progress(void *h, int status, int size, int so_far, int fh, int ftype, char *url);
static access_complete_flags antweb_doc_complete(void *h, int status, char *cfile, char *url);
static void be_update_image_info(be_doc doc);
void antweb_doc_background_change(void *h, void *i, int status);
static void be_refresh_document(int at, void *h);
os_error *backend_stream_locate_item(rid_text_stream *st, int *x, int *y, be_item *ti);

void be_caption_stream_origin(rid_table_item *table, int *dx, int *dy);
void be_cell_stream_origin(rid_table_item *table, rid_table_cell *cell, int *dx, int *dy);

/* Used locally */
typedef struct {
  	int t, b, l, r;
} border_str;

/* Can be called with a cell or cell==NULL and x and y given */
static void be_cell_borders(rid_table_item *table, rid_table_cell *cell,
			    int x, int y, border_str *bb);

/*****************************************************************************

    item is a table.  i is an image handle.  Determine if the table contains
    an item using the image handle or not.

*/

extern int rid_table_holds_image(rid_text_item *item, void *i, antweb_doc *doc)
{
        rid_table_item *table = ((rid_text_item_table *)item)->table;
        rid_text_item *tabscan;
        rid_table_cell *cell;
        int x = -1, y = 0, have_image = FALSE;

        assert(item->tag == rid_tag_TABLE);

        if (table->caption)
        {
                for (tabscan = table->caption->stream.text_list;
                     tabscan != NULL;
                     tabscan = rid_scanf(tabscan) )
                {
                        if (tabscan->tag == rid_tag_TABLE)
                        {
			    if (rid_table_holds_image(tabscan, i, doc) )
			    {
                                have_image = TRUE;
                                break;
			    }
                        }
                        else if (object_table[tabscan->tag].imh != NULL &&
                                (object_table[tabscan->tag].imh)(tabscan, doc) == i)
                        {
                                have_image = TRUE;
                                break;
                        }
                }

        }

        if (!have_image)
        while ( (cell = rid_next_root_cell(table, &x, &y)) != NULL )
        {
                for (tabscan = cell->stream.text_list;
                     tabscan != NULL;
                     tabscan = rid_scanf(tabscan) )
                {
                        if (tabscan->tag == rid_tag_TABLE)
                        {
			    if (rid_table_holds_image(tabscan, i, doc) )
			    {
                                have_image = TRUE;
                                break;
			    }
                        }
                        else if (object_table[tabscan->tag].imh != NULL &&
                           (object_table[tabscan->tag].imh)(tabscan, doc) == i)
                        {
                                have_image = TRUE;
                                break;
                        }
                }
        }

        return have_image;
}


/**********************************************************************/


/*DAF*/
/*DAF*/
rid_text_item *antweb_prev_text_input(rid_text_item *ti, be_doc doc)
{
    while (ti)
    {
	if (ti && object_table[ti->tag].caret && (object_table[ti->tag].caret)(ti, doc->rh, doc, TRUE))
	    break;
	/*ti = antweb_prev_text_item(ti);*/
        ti = rid_scanbr(ti);
    }

    return ti;
}

/*DAF*/
/*DAF*/
rid_text_item *antweb_next_text_input(rid_text_item *ti, be_doc doc)
{
    while (ti)
    {
	if (ti && object_table[ti->tag].caret && (object_table[ti->tag].caret)(ti, doc->rh, doc, TRUE))
	    break;
	/*ti = ti->next;*/
        ti = rid_scanfr(ti);
    }

    return ti;
}


#define CLESS(x)	(cless ? toupper(x) : (x))

/*DAF*/
/*DAF*/
static int be_find_test_text(be_doc doc, be_item ti, char *text, int flags)
{
    rid_text_item_text *tit = (rid_text_item_text *) ti;
    rid_header *rh = doc->rh;
    char *p, *q;
    int c1;
    int i, j;
    int cless;
    int hit = 0;

    flexmem_noshift();

    cless = flags & be_find_CASELESS;

    c1 = CLESS(text[0]);
#if 0
    fprintf(stderr, "'%s'\n", rh->texts.data + tit->data_off);
#endif
    p = rh->texts.data + tit->data_off;

    for(i=0; p[i]; i++)
    {
	if( CLESS(p[i]) == c1)
	{
	    rid_text_item *ti2 = ti;
	    q = p+i+1;
	    j = 1;

	    while (text[j])
	    {
		while (*q == 0)
		{
		    rid_text_item_text *tit2;

		    /*do { ti2 = ti2->next;*/
		    /*} while (ti2 && ti2->tag != rid_tag_TEXT);*/
                    ti2 = rid_scan(ti2, SCAN_RECURSE | SCAN_FILTER | rid_tag_TEXT);

		    tit2 = (rid_text_item_text *) ti2;

		    if (tit2)
			q = rh->texts.data + tit2->data_off;
		    else
			break;
		}

		if ((*q == 0) || (CLESS(*q) != CLESS(text[j])) )
		    break;

		q++;
		j++;
	    }

	    if (text[j] == 0)
	    {
		hit = 1;
		break;
	    }
	}
    }

    flexmem_shift();

    return hit;
}

/*DAF*/
/*DAF*/
be_item backend_find(be_doc doc, be_item start, char *text, int flags)
{
    const int scan_flag = ((flags & be_find_BACKWARDS) ? SCAN_BACK : SCAN_FWD) | SCAN_RECURSE;

    if (text[0] == 0)
	return NULL;

    if (start == NULL)
    {
	start = (flags & be_find_BACKWARDS) ? doc->rh->stream.text_last : doc->rh->stream.text_list;
    }
    else
    {
	/*start = (flags & be_find_BACKWARDS) ? antweb_prev_text_item(start) : start->next;*/
        start = rid_scan(start, scan_flag);
    }

    while(start)
    {
	if ((start->tag == rid_tag_TEXT) && be_find_test_text(doc, start, text, flags))
	{
#if 1
	    wimp_box bb;

	    if (backend_doc_item_bbox(doc, start, &bb) == NULL)
		frontend_view_ensure_visable(doc->parent, 0, bb.y1, bb.y1);
#else
	    frontend_view_ensure_visable(doc->parent, 0, start->line->top, start->line->top);
#endif
	    return start;
	}
	/*start = (flags & be_find_BACKWARDS) ? antweb_prev_text_item(start) : start->next;*/
        start = rid_scan(start, scan_flag);
    }

    return NULL;
}

/* Work out the borders for a given cell */

static void be_cell_borders(rid_table_item *table, rid_table_cell *cell,
			    int x, int y, border_str *bb)
{
    if (cell == NULL)
    {
	cell = *CELLFOR(table, x, y);
    }
    else
    {
	x = cell->cell.x;
	y = cell->cell.y;
    }

    bb->t = table->rowhdrs[y].tborder;
    bb->b = table->rowhdrs[y + cell->span.y - 1].bborder;
    bb->l = table->colhdrs[x].lborder;
    bb->r = table->colhdrs[x + cell->span.x - 1].rborder;
}

/* Find the horizonlat offset (xx) and base line (yy) of a given item */

/*DAF*/
/*DAF*/
BOOL antweb_locate_item(rid_text_item *ti, int *xx, int *yy)
{
    rid_pos_item *pi = ti->line;
    rid_text_item *ti2;
    int hpos;

    if (pi == NULL)
        return FALSE;

    *yy = pi->top - pi->max_up;

    for (ti2 = pi->first, hpos=pi->left_margin;
         ti2 && ti2 != pi->next->first;
         ti2 = rid_scanf(ti2) /*ti2 = ti2->next*/ )
    {
	if (ti2 == ti)
	{
	    *xx = hpos;
	    if (ti->line->st->parent)
	    {
	        int px, py;
	        rid_text_item *par_table_ti;
	        rid_table_item *tabi;

	        if (ti->line->st->partype == rid_pt_CAPTION)
	        {
	          	rid_table_caption *capt = (rid_table_caption *) ti->line->st->parent;

	          	tabi = capt->table;

			/* Adjust offset to be within table */
			be_caption_stream_origin(tabi, &px, &py);
		        *xx += px;
		        *yy += py;
	        }
	        else
	        {
	          	rid_table_cell *cell = (rid_table_cell *) ti->line->st->parent;

			tabi = cell->parent;

			/* Adjust offset to be within table */
			be_cell_stream_origin(tabi, cell, &px, &py);
		        *xx += px;
		        *yy += py;
	        }

		par_table_ti = &(tabi->parent->base);

		/* Adjust offset to be within work area */
	        antweb_locate_item(par_table_ti ,&px, &py);

	        *xx += px;
	        *yy += py;
	        *yy += tabi->size.y;
	    }
	    return TRUE;
	}

	hpos += ti2->width;
	hpos += ti2->pad;
    }

    return FALSE;
}

os_error *backend_doc_item_bbox(be_doc doc, be_item ti, wimp_box *bb)
{
    if (ti == NULL)
	return makeerror(ERR_BAD_CONTEXT);

    if (!antweb_locate_item(ti, &(bb->x0), &(bb->y0)))
	return makeerror(ERR_BAD_CONTEXT);

    bb->x1 = bb->x0 + ti->width;
    bb->y1 = bb->y0 + ti->max_up;
    bb->y0 = bb->y0 - ti->max_down;

    return NULL;
}


/*****************************************************************************

Remember: we want the offset within the item, relative to
the base line of the item, which may not be the bottom
left pixel of the item.

Entry gives us an offset relative to 0,0 as leftmost point of
the baseline.

*/

/* Return the offset from the top left of the cell to the origin of the enclosed stream */

void be_caption_stream_origin(rid_table_item *table, int *dx, int *dy)
{
	*dx = 0;
	*dy = 0;
}

void be_cell_stream_origin(rid_table_item *table, rid_table_cell *cell, int *dx, int *dy)
{
        rid_valign_tag rvt;
	border_str bb;
 	int ddy;

	be_cell_borders(table, cell, 0, 0, &bb);

	*dx = table->colhdrs[cell->cell.x].offx + bb.l;
	*dy = table->rowhdrs[cell->cell.y].offy - bb.t;

	/* Sort out VALIGN bits */
        rid_getprop(table, cell->cell.x, cell->cell.y, rid_PROP_VALIGN, &rvt);

  	ddy = cell->size.y - bb.t - bb.b + cell->stream.height;	/* Note height is -ve */

  	switch (rvt)
  	{
  	  	case rid_vt_TOP:
  	  	case rid_vt_BASELINE:
  	  	default:
  	  		break;
  	  	case rid_vt_BOTTOM:
			*dy -= ddy;
  	  		break;
		case rid_vt_MIDDLE:
			*dy -= (ddy >> 1);
  	  		break;
  	}
}

void backend_table_locate_item(rid_table_item *table, int *xp, int *yp, be_item *ti)
{
        int x, y, tx = *xp, ty = *yp;
        be_item my_ti = NULL;
/*        rid_table_cell *cell;*/

        ty -= table->bborder;

        if (ty < 0)
        {
                LOCATEDBG((stderr, "Below the bottom border\n"));
                return;
        }

	y = table->cells.y - 1;
	while (y >= 0)
	{
                ty -= table->rowhdrs[y].sizey;

		if (ty < 0)
			break;
		y--;
	}


        if (ty < 0)
        {
                LOCATEDBG((stderr, "Matched vertically within row %d\n", y));

                tx -= table->lborder;

                if (tx < 0)
                {
                        LOCATEDBG((stderr, "In the left border\n"));
                        return;
                }

		x = 0;
		while (x < table->cells.x)
		{
                        tx -= table->colhdrs[x].sizex;

			if (tx < 0)
				break;
			x++;
		}

                if (tx < 0 && y >= 0)
                {
                        rid_table_cell *cell = *CELLFOR(table, x, y);

                        LOCATEDBG((stderr, "Matched horizontally within cell %d,%d - %s\n", x, y, cell ? "Occupied" : "No cell"));
			if (cell != NULL)
			{
				/* Find the offset within the table */
				be_cell_stream_origin(table, cell, &tx, &ty);
				tx = *xp - tx;
				/* Y offset is from top left, *yp is from bottom left */
				ty = (*yp - table->size.y) - ty;

                                backend_stream_locate_item(&cell->stream, &tx, &ty, &my_ti);

                                if (my_ti != NULL)
                                {
                                        LOCATEDBG((stderr, "Returning matched child item\n"));
                                        *xp = tx;
                                        *yp = ty;
                                        *ti = my_ti;
                                        return;
                                }
                        }
                }

                LOCATEDBG((stderr, "Either beyond right border or not over an item\n"));
                return;
        }

        LOCATEDBG((stderr, "Trying to match within caption\n"));

        if (table->caption != NULL)
        {
                backend_stream_locate_item(&table->caption->stream, &tx, &ty, &my_ti);

                if (my_ti != NULL)
                {
                        LOCATEDBG((stderr, "Matched in the caption\n"));
                        *xp = tx;
                        *yp = ty;
                        *ti = my_ti;
                        return;
                }
        }

        LOCATEDBG((stderr, "Failed to match any item - just returning the table\n"));

        return;
}


os_error *backend_stream_locate_item(rid_text_stream *st, int *x, int *y, be_item *ti)
{
    rid_pos_item *pi;
    rid_text_item *ti2;
    int hpos;

    if (st == NULL || st->pos_list == NULL)
        return NULL;

    /* Above the top ? */
    if (st->pos_list->top <= *y)
       return NULL;

    for (pi = st->pos_list; pi->next && pi->next->top > *y; pi = pi->next)
       ;

    if ( *x < -100)		/* A position way off to the left is taken as just wanting what is first on the line */
    {
	*ti = pi->first;
    }
    else if ( (pi->next == NULL) || (*x < pi->left_margin) )
    {
#if 0
	fprintf(stderr, "Pointer to left of all items\n");
#endif
    }
    else
    {
	for(hpos = pi->left_margin, ti2 = pi->first; ti2 != pi->next->first; ti2 = ti2->next)
	{
	    int ohpos = hpos;

	    hpos += ti2->width;
	    hpos += ti2->pad;

	    if (*x < hpos || ti2->width == -1)
	    {
#if 0
		fprintf(stderr, "Found item\n");
#endif
		*ti = ti2;
		*y -= (pi->top - pi->max_up);         /* Relative to baseline */
       		*x -= ohpos ;

                if (ti2->tag == rid_tag_TABLE)
                {
                    backend_table_locate_item( ((rid_text_item_table *)ti2)->table, x, y, ti);
                }
		break;
	    }
	}
    }

#if 0
    fprintf(stderr, "Locate pointer done: %p at %d, %d\n", *ti, *x, *y);
#endif

    return NULL;
}


/*DAF*/
/*DAF*/
os_error *backend_doc_locate_item(be_doc doc, int *x, int *y, be_item *ti)
{
#if 0
    fprintf(stderr, "Locate item: doc = %p, x=%d, y=%d\n", doc, *x, *y);
#endif
    *ti = NULL;

    if (doc == NULL || doc->rh == NULL || doc->rh->stream.pos_list == NULL)
	return NULL;

    return backend_stream_locate_item(&doc->rh->stream, x, y, ti);
}

/*
 * This function was split off from antweb_doc_click so that others can calls it, a target of
 * NULL will use the document default. a target of _blank forces a new window to open.
 */

os_error *antweb_handle_url(be_doc doc, const char *href, const char *query, const char *target)
{
    os_error *e = NULL;
    BOOL new_win = target && strcasecomp(target, "_blank") == 0;

    if (!href)
        return NULL;

    if (href[0] == '#' && !new_win)
    {
        /* Special case a move to a fragment in the same document and the same window */
        e = backend_goto_fragment(doc, (char *)&href[1]);
    }
    else
    {
	char *base;
	char *dest;

	base = url_join(BASE(doc), (char *)href);
	if (query && *query)
	{
	    dest = url_join(base, (char *)query);
	    mm_free(base);
	}
	else
	    dest = base;

	if (akbd_pollsh())
	{
	    e = savedoc(dest, "Document", -1);
	}
	else
	{
	    e = frontend_open_url(dest, new_win ? NULL : doc->parent, (char *)target, NULL, 0);
	}

	mm_free(dest);
    }
    return e;
}

/*
 * This function no longer follows links for objects that have a click function. The must
 * call antweb_handle_url or antweb_place_caret themselves.
 */

os_error *backend_doc_click(be_doc doc, int x, int y, wimp_bbits bb)
{
    rid_text_item *ti;
    os_error *ep;

    ep = backend_doc_locate_item(doc, &x, &y, &ti);

    if (ep)
	return ep;

    if (ti)
    {
        if (object_table[ti->tag].click != NULL)
        {
	    (object_table[ti->tag].click)(ti, doc->rh, doc, x, y, bb);
	}
	else if (ti->aref && ti->aref->href)
	{
	    if (akbd_pollctl())
	    {
	        backend_update_link(doc, ti, -1);
	    }
	    else
	    {
                if (config_display_time_activate)
                {
	            backend_update_link(doc, ti, -1);
                    wait_for_release(config_display_time_activate);
	            backend_update_link(doc, ti, -1);
    	        }

                frontend_complain(antweb_handle_url(doc, ti->aref->href, NULL,
                    bb & wimp_BRIGHT ? "_blank" : ti->aref->target));
            }
        }
        else
        {
	    antweb_place_caret(doc);
	}
    }
    else
    {
	antweb_place_caret(doc);
    }

    return NULL;
}

/*
 * This variant on backend_item_info takes the coords relative to the baseline and can thus decode the
 * link within a client side image map.
 */

os_error *backend_item_pos_info(be_doc doc, be_item ti, int x, int y, int *flags, char **link, void **im)
{
    int f = 0;
    void *imh = NULL;

#if 0
    fprintf(stderr, "Asked for info on item at %p\n", ti);
#endif

    if (link)
        *link = NULL;

    if (ti)
    {
        if (ti->tag == rid_tag_IMAGE && ((rid_text_item_image *)ti)->usemap)
        {
            f |= be_item_info_USEMAP;

            if (link)
            {
                rid_text_item_image *tii = (rid_text_item_image *)ti;
                rid_map_item *map;
                rid_area_item *area;

                map = imagemap_find_map(doc->rh, tii->usemap);
                if (map && (map->flags & rid_map_ERROR) == 0)
                {
                    int xx = x - (tii->bwidth * 2) - tii->hspace*2;
	            int yy = ((ti->max_up) - (tii->bwidth *2) - tii->vspace*2) - y;

                    image_os_to_pixels((image)tii->im, &xx, &yy, config_display_scale_image);

                    area = imagemap_find_area(map, xx, yy);
                    *link = area ? area->href : "";
                }
            }
        }

	if (ti->aref && ti->aref->href)
	{
	    f |= be_item_info_LINK;

	    if (link && !*link)
		*link = ti->aref->href;

	    if (ti->tag == rid_tag_IMAGE && ( ((rid_text_item_image *) ti)->flags & rid_image_flag_ISMAP) )
		f |= be_item_info_ISMAP;
	}

	if (ti->tag == rid_tag_INPUT)
	{
	    rid_text_item_input *tii = (rid_text_item_input *) ti;
	    rid_input_item *ii = tii->input;

	    switch (ii->tag)
	    {
	    case rid_it_TEXT:
	    case rid_it_PASSWD:
		f |= be_item_info_INPUT;
		break;
	    case rid_it_IMAGE:
	    case rid_it_SUBMIT:
		f |= be_item_info_ACTION;
		break;
	    case rid_it_RESET:
	    case rid_it_RADIO:
	    case rid_it_CHECK:
	    default:
		f |= be_item_info_BUTTON;
		break;
	    }
	}

        if (ti->tag == rid_tag_TEXTAREA)
            f |= be_item_info_INPUT;

        if (ti->tag == rid_tag_SELECT)
            f |= be_item_info_MENU;

	if (object_table[ti->tag].imh != NULL)
	    imh = (object_table[ti->tag].imh)(ti, doc);
    }
    else
    {
	if (doc != 0)
	{
	    if (doc->rh->bgt & rid_bgt_IMAGE)
	    {
		imh = doc->rh->tile.im;
	    }
	}
    }

    if (im)
    {
	*im = imh;
    }

    if (imh)
    {
	f |= be_item_info_IMAGE;
    }

    if (flags)
	*flags = f;
#if 0
    fprintf(stderr, "Info on item: flags = %d, link='%s'\n", f, ((f & be_item_info_LINK) && link && *link) ? *link : "<none>");
#endif
    return NULL;
}

os_error *backend_item_info(be_doc doc, be_item ti, int *flags, char **link, void **im)
{
    return backend_item_pos_info(doc, ti, 0, 0, flags, link, im);
}


/*DAF*/
/*DAF*/
os_error *backend_doc_info(be_doc doc, int *flags, int *ftype, char **url, char **title)
{
    int f = 0;

    if (doc->rh->flags & rid_hf_ISINDEX)
	f |= be_doc_info_ISINDEX;
    if (doc->rh->bgt & rid_bgt_IMAGE)
	f |= be_doc_info_HAS_BG;
    if (doc->rh->flags & rid_hf_HTML_ERRS)
	f |= be_doc_info_HTML_ERRS;
    if (access_test_cache(doc->url))
	f |= be_doc_info_IN_CACHE;
    if (doc->ah || doc->ph)
	f |= (be_doc_info_FETCHING | be_doc_info_INCOMPLETE);
    if (doc->flags & doc_flag_INCOMPLETE)
	f |= be_doc_info_INCOMPLETE;

    if (ftype)
    {
	/* Finding out the file type might be a pain, only do it if we need it */
	if (doc->cfile == NULL || (*ftype = file_type(doc->cfile)) == -1)
	    *ftype = FILETYPE_HTML;
    }

    if (url)
	*url = doc->url;
    if (title)
	*title = doc->rh ? doc->rh->title : NULL;

    if (flags)
	*flags = f;

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_doc_file_info(be_doc doc, int *ft, int *load, int *exec, int *size)
{
    if (ft)
    {
	if (doc->cfile == NULL || (*ft = file_type(doc->cfile)) == -1)
	    *ft = FILETYPE_HTML;
    }

    if (load)
	*load = doc->file_load_addr;
    if (exec)
	*exec = doc->file_exec_addr;
    if (size)
	*size = doc->file_size;

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_image_info(be_doc doc, void *imh, int *flags, int *ftype, char **url)
{
    image im = (image) imh;
    int fi;
    int f = 0;

    if (im == NULL)
	return makeerror(ERR_NOT_AN_IMAGE);

    image_info(im, 0, 0, 0, &fi, ftype, url);
    if (fi & image_flag_FETCHED)
	f |= be_image_info_FETCHED;

    if (fi & image_flag_RENDERABLE)
	f |= be_image_info_RENDERABLE;

    if (fi & image_flag_DEFERRED)
	f |= be_image_info_DEFERED;

    if (fi & image_flag_ERROR)
	f |= be_image_info_ERROR;

    if (fi & image_flag_INTERLACED)
	f |= be_image_info_INTERLACED;

    if (fi & image_flag_MASK)
	f |= be_image_info_MASK;

    if (flags)
	*flags = f;

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_image_size_info(be_doc doc, void *imh, int *width, int *height, int *bpp)
{
    image im = (image) imh;
    os_error *ep;
    int x, y;

    if (im == NULL)
	return makeerror(ERR_NOT_AN_IMAGE);

    ep = image_info(im, &x, &y, bpp, 0, 0, 0);
    if (ep)
	return ep;

    /* don't need image scaling here as image_ionfo returns real size */
    image_os_to_pixels(im, &x, &y, 100);

    if (width)
        *width = x;
    if (height)
        *height = y;

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_image_file_info(be_doc doc, void *imh, int *load, int *exec, int *size)
{
    image im = (image) imh;

    if (im == NULL)
	return makeerror(ERR_NOT_AN_IMAGE);

    return image_file_info(im, load, exec, size);
}

/*DAF*/
/*DAF*/
os_error *backend_doc_flush_image(be_doc doc, void *imh, int flags)
{
    rid_text_item *ti;
    os_error *ep = NULL;
    int ffi;
    rid_header *rh = doc->rh;

    ffi = (flags & be_openurl_flag_DEFER_IMAGES) ? image_find_flag_DEFER : 0;

    if (rh && rh->tile.im && (imh == 0 || imh == rh->tile.im))
	rh->tile.width = 0;

    if (imh)
    {
	ep = image_flush((image) imh, ffi);
    }
    else
    {
	if (rh)
	{
	    ti = rh->stream.text_list;

	    /* Free any data that we have added to the text list */
	    /* Scan through tables to catch contained images */
	    while (ti)
	    {
		if (object_table[ti->tag].imh != NULL)
		{
		    image i;

		    i = (object_table[ti->tag].imh)(ti, doc);

		    image_mark_to_flush(i, ffi);
		}

		/*ti = ti->next;*/
                ti = rid_scanfr(ti);
	    }

	    if (rh->tile.im)
		image_mark_to_flush(rh->tile.im, ffi);

	    ep = image_flush_marked();
	}
    }

    return ep;
}

/*DAF*/
/*DAF*/
os_error *backend_dispose_doc(be_doc doc)
{
    rid_text_item *ti;

    fprintf(stderr, "Disposing of doc 0x%p, url is '%s'\n", doc, doc->url ? doc->url : "<none>");

    alarm_removeall(doc);

    if (doc->ph)
    {
	doc->rh = ((pparse_details*)doc->pd)->close(doc->ph, NULL);
	doc->ph = NULL;
    }

    if (doc->rh)
    {
	ti = doc->rh->stream.text_list;

	/* Free any data that we have added to the text list */
        /* Tables sort themselves out */
	while (ti)
	{
            rid_text_item *ti_next = rid_scanf(ti);

	    if (object_table[ti->tag].dispose != NULL)
		(object_table[ti->tag].dispose)(ti, doc->rh, doc);

	    /*ti = ti->next;*/
            ti = ti_next;
	}

	if (doc->rh->tile.im)
	{
	    image_loose((image) (doc->rh->tile.im), &antweb_doc_background_change, doc);
	}

	rid_free(doc->rh);
    }

    if (doc->ah)
    {
#if 1
	fprintf(stderr, "Calling access_abort on 0x%p\n", doc->ah);
#endif
	access_abort(doc->ah);
    }

    if (doc->cfile)
	mm_free(doc->cfile);

    if (doc->url)
	mm_free(doc->url);

    if (doc->frag)
	mm_free(doc->frag);

    if (doc->paginate)
	awp_free_pages(doc);

    /* SJM if an imagemap is fetching then dispose of it */
    if (doc->fetching)
    {
#if 1
	fprintf(stderr, "backend: dispose imagemap 0x%p\n", doc->fetching);
#endif
        backend_dispose_doc(doc->fetching);
    }

    /* SJM free spacing list */
    layout_free_spacing_list(doc);

    doc->magic = 0;

    mm_free(doc);

#if 1
    fprintf(stderr, "Document disposed of\n");
#endif

    return NULL;
}

/*DAF*/
/*DAF*/
static void be_undate_image_stata(be_doc doc, void *i)
{
    image_flags f;
    int dsf, ds;

    image_data_size((image) i, &f, &dsf, &ds);

    if (f & image_flag_FETCHED)
	doc->im_fetched++;
    else if (f & image_flag_WAITING)
	doc->im_unfetched++;
    else if (f & image_flag_ERROR)
	doc->im_error++;
    else
    {
	doc->im_fetching++;
	doc->im_so_far += dsf;
	if (ds == -1)
	    doc->im_in_transit = ds;
	if (doc->im_in_transit != -1)
	    doc->im_in_transit += ds;
    }
}

/*DAF*/
/*DAF*/
static void be_update_image_info(be_doc doc)
{
    void *i;
    rid_text_item *ti;
    char buffer[256];
    char *punc = ":";

    if (doc == NULL || doc->rh == NULL || doc->rh->stream.text_list == NULL)
	return;

    doc->im_fetched = 0;
    doc->im_fetching = 0;
    doc->im_unfetched = 0;
    doc->im_error = 0;
    doc->im_in_transit = 0;
    doc->im_so_far = 0;

    for (ti = doc->rh->stream.text_list; ti; ti = rid_scanfr(ti) /*ti->next*/ )
    {
	if (object_table[ti->tag].imh != NULL && (i = (object_table[ti->tag].imh)(ti, doc)) != NULL)
	{
	    be_undate_image_stata(doc, i);
	}
    }

    if (doc->rh->tile.im)
	be_undate_image_stata(doc, doc->rh->tile.im);

    if (doc->im_fetching || doc->im_unfetched)
    {
	char buf2[16];
	strcpy(buffer, msgs_lookup("imdoing"));

	if (doc->im_unfetched)
	{
	    sprintf(buf2, "%s %d ", punc, doc->im_unfetched);
	    strlencat(buffer, buf2, 256);
	    strlencat(buffer, msgs_lookup("imwait"), 256);
	    punc = ",";
	}

	if (doc->im_so_far || doc->im_in_transit > 0)
	{
	    sprintf(buf2, "%s %d ", punc, doc->im_so_far);
	    strlencat(buffer, buf2, 256);

	    if (doc->im_in_transit > 0)
	    {
		strlencat(buffer, msgs_lookup("imof"), 256);
		sprintf(buf2, " %d ", doc->im_in_transit);
		strlencat(buffer, buf2, 256);
	    }

	    strlencat(buffer, msgs_lookup("imfrom"), 256);

	    punc = "";
	}

	if (doc->im_fetching)
	{
	    sprintf(buf2, "%s %d ", punc, doc->im_fetching);
	    strlencat(buffer, buf2, 256);
	    strlencat(buffer, msgs_lookup("imfetch"), 256);
	    punc = ",";
	}

	if (doc->im_fetched)
	{
	    sprintf(buf2, "%s %d ", punc, doc->im_fetched);
	    strlencat(buffer, buf2, 256);
	    strlencat(buffer, msgs_lookup("imfetched"), 256);
	    punc = ",";
	}

	if (doc->im_error)
	{
	    sprintf(buf2, "%s %d ", punc, doc->im_error);
	    strlencat(buffer, buf2, 256);
	    strlencat(buffer, msgs_lookup("imerrs"), 256);
	    punc = ",";
	}

	if (punc[0] == ',')
	    strlencat(buffer, ".", 256);
    }
    else
    {
	sprintf(buffer, msgs_lookup("imdone"), doc->im_error);
    }

    frontend_view_status(doc->parent, sb_status_IMAGE, buffer);
}

/*DAF*/
/*DAF*/
os_error *backend_screen_changed(int flags)
{
    image_palette_change();

    return NULL;
}

/*DAF*/
/*DAF*/
static void be_dummy_render(wimp_box *g)
{
    int junk;

    colourtran_setGCOL(config_colours[render_colour_BACK], (1<<8) | (1<<7), 0, &junk);

    bbc_move(g->x0, g->y0);
    bbc_plot(bbc_RectangleFill + bbc_DrawAbsBack, g->x1, g->y1);
}

/*--- Individual event routines for the window ---*/

int be_first_visable_cell(rid_table_item *table, int ox, int oy, wimp_box *g, int *xx, int *yy)
{
	int x,y;
	rid_table_cell *cell;

	for (y=0; y < table->cells.y; y++)
	{
		if ((oy + table->rowhdrs[y].offy - table->rowhdrs[y].sizey) < g->y1)
			break;
	}

	if (y == table->cells.y)
		return FALSE;

        *yy = y;
	*xx = x = 0;

	for(x=0; x < table->cells.x; x++)
	{
		cell = *CELLFOR(table, x, y);
		if (cell && (cell->cell.y < *yy))
		{
			*yy = cell->cell.y;
			*xx = cell->cell.x;
		}
	}

	return TRUE;
}

void backend_render_stream(rid_text_stream *stream,
                           antweb_doc *doc,
                           const int ox,           /* screen origin of text stream */
                           const int oy,
                           const int left,         /* Area being redrawn in local coords */
                           const int top,
                           const int right,
                           const int bot,
                           object_font_state *fs,
                           wimp_box *g,
                           const int update
                          );


void backend_render_table(rid_table_item *table,
                          antweb_doc *doc,
                          const int ox,           /* screen origin of text stream */
                          const int oy,
                          const int left,         /* Area being redrawn in local coords */
                          const int top,
                          const int right,
                          const int bot,
                          object_font_state *fs,
                          wimp_box *g,
                          const int update
                          )
{
#define XF              2       /* or frontend_dx */
#define YF              2       /* or frontend_dy */

        rid_table_caption *capt = table->caption;
        rid_table_cell *cell;
        int x = -1, y = 0;
	const capt_size = capt == NULL ? 0 : -capt->stream.height;
        const int rf = table->flags & rid_tf_3D_BORDERS;
        const int tb = table->tborder, bb = table->bborder, 
                  lb = table->lborder, rb = table->rborder;

#if RENDER_DEBUG
        fprintf(stderr, "Rendering table.  ox=%d, oy=%d.\n", ox, oy);
        fprintf(stderr, "Top work area = %d, bottom = %d\n", top, bot);
        fprintf(stderr, "Left = %d, right = %d, capt_size = %d\n", left, right, capt_size);
#endif


	if (table->cell_border.x || table->cell_border.y)
	{
        	TABDBG((stderr, "Draw the outer edges of the table\n"));

          	render_set_colour(rf ? render_colour_LINE_L : render_colour_PLAIN, doc);

	 	if (lb)
	 	{
	 	 	bbc_move(ox, oy - capt_size);
	 	 	bbc_drawby(0, -table->size.y + capt_size + YF);
                }

	 	if (tb)
	 	{
	 	 	bbc_move(ox, oy - capt_size);
	 	 	bbc_drawby(table->size.x - XF, 0);
                }

                if (rf)
                  	render_set_colour(render_colour_LINE_D, doc);

	 	if (bb)
	 	{
	 	 	bbc_move(ox, oy - table->size.y + YF);
	 	 	bbc_drawby(table->size.x - XF, 0);
                }

	 	if (rb)
	 	{
	 	 	bbc_move(ox + table->size.x - XF, oy - capt_size);
	 	 	bbc_drawby(0, -table->size.y + capt_size + YF);
                }

	}

	if (table->frame == rid_ft_BORDER && lb > XF && rb > XF && tb > YF && bb > YF)
	{
                TABDBG((stderr, "Draw the inner edges of the table\n"));

          	render_set_colour(rf ? render_colour_LINE_D : render_colour_PLAIN, doc);

                /* move bottom left */
 	 	bbc_move(ox + lb - XF, oy - table->size.y + bb);
                /* draw left edge upwards */
 	 	bbc_drawby(0, table->size.y - capt_size - tb - bb + YF);    
                /* draw top edge rightwards */
                bbc_drawby(table->size.x - lb - rb + XF, 0);

                /* now top right */
                if (rf)
                  	render_set_colour(render_colour_LINE_L, doc);

                /* draw right edge downwards */
 	 	bbc_drawby(0, - (table->size.y - capt_size - tb - bb + YF));    
                /* draw bottom edge leftwards */
                bbc_drawby(- (table->size.x - lb - rb + XF), 0);

#if 0
		render_plinth(0,
				render_plinth_NOFILL | render_plinth_IN,
				ox + lb - 1,
				oy + lb - 1,
				table->size.x - 2 * lb,
				-(table->size.y - 2 * lb),
				doc);
#endif
	}


	/* Then any cell borders - all or nothing exercise */
        /* We draw a line around the inside of the cell border */
        /* This is the only place should need to decompose how */
        /* we arrived at the row/col border values. could perhaps */
        /* add an extra line for group boundaries to emphasises them? */

	if (lb != 0)
	if (be_first_visable_cell(table, ox, oy, g, &x, &y))
	for (x--; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
	{
		if (cell->stream.text_list)
		{
	                int dx, dy, width;

			dy = table->rowhdrs[cell->cell.y].offy;

			if ((oy + dy) < g->y0)
			{
			    break;
			}
			else
			{
			    dx = table->colhdrs[cell->cell.x].offx;
			    width = cell->size.x;

			    if (((ox + dx) < g->x1) &&	/* Stream.left to left of clip.right */
	 		        ((ox + dx + width) > g->x0) )
			    {
				border_str bb;

			        be_cell_borders(table, cell, 0, 0, &bb);

			        bb.l -= table->cellpadding;
			        bb.r -= table->cellpadding;
	 		        bb.t -= table->cellpadding;
	 		        bb.b -= table->cellpadding;

				render_set_colour(rf ? render_colour_LINE_D : render_colour_PLAIN, doc);

                                /* move bottom left */
                                bbc_move(ox + table->colhdrs[x].offx + bb.l - XF,
                                         oy + table->rowhdrs[y].offy - cell->size.y + bb.b - YF);

                                /* draw top left upwards */
                                bbc_drawby(0, cell->size.y - bb.t - bb.b);
                                /* draw top right rightwards */
                                bbc_drawby(cell->size.x - bb.l - bb.r, 0);

                                if (rf)
                                  	render_set_colour(render_colour_LINE_L, doc);

                                /* draw bottom right, downwards */
                                bbc_drawby(0, - (cell->size.y - bb.t - bb.b));
                                /* draw bottom left, leftwards */
                                bbc_drawby(- (cell->size.x - bb.l - bb.r), 0);
                            }
                        }
	 	}
	}
	/* Any caption (and/or text that had nowhere to go */

        if ( capt != NULL )
        {
                const int dx = capt->off.x;
                const int dy = capt->off.y;

                backend_render_stream(
                        &capt->stream,
                        doc,
                        ox + dx,
                        oy + dy,
                        left,
                        top - dy,
                        right,
                        bot - dy,
                        fs,
                        g,
                        update );
        }

        /* Fill in cell contents */

	if (be_first_visable_cell(table, ox, oy, g, &x, &y))
        for (x--; (cell = rid_next_root_cell(table, &x, &y)) != NULL; )
        {
                int dx, dy;

		be_cell_stream_origin(table, cell, &dx, &dy);

		/* Note that we must terminate the search only when the whole cell falls below the clip */
		if ((oy + table->rowhdrs[cell->cell.y].offy) < g->y0)
		{
		    break;
		}
		else if (((ox + dx) < g->x1) &&	/* Stream.left to left of clip.right */
		    ((ox + dx + cell->stream.fwidth) > g->x0) ) /* Stream.right to right of clip.lrft */
		{
	                backend_render_stream(
        	                &cell->stream,
                	        doc,
				ox + dx,
				oy + dy,
                        	left,
                        	top - dy,
                        	right,
                        	bot - dy,
                        	fs,
                        	g,
                        	update );
                }
        }
}


void backend_render_stream(rid_text_stream *stream,
                           antweb_doc *doc,
                           const int ox,           /* screen origin of text stream */
                           const int oy,
                           const int left,         /* Area being redrawn in local coords */
                           const int top,
                           const int right,
                           const int bot,
                           object_font_state *fs,
                           wimp_box *g,
                           const int update
                          )
{
        rid_pos_item *pi;
        rid_text_item *ti;

        if (stream == NULL || stream->pos_list == NULL)
                return;

#if RENDER_DEBUG
        fprintf(stderr, "Rendering rectangle.  ox=%d, oy=%d.\n", ox, oy);
        fprintf(stderr, "Top work area = %d, bottom = %d\n", top, bot);
        fprintf(stderr, "Left = %d, right = %d\n", left, right);
	fprintf(stderr, "Scanning down\n");
#endif
	for (pi = stream->pos_list; pi->next && pi->next->top > top; pi = pi->next)
	{
#if RENDER_DEBUG
	    fprintf(stderr, "Skipping line, top=%d\n", pi->top);
#endif
	}

	for( ; pi && pi->top > bot; pi = pi->next)
	{
	    int hpos, bline;

#if RENDER_DEBUG
	    fprintf(stderr, "Got line in range, top=%d\n", pi->top);
#endif
	    hpos = ox + pi->left_margin;
	    bline = pi->top - pi->max_up + oy;

#if RENDER_DEBUG
	    fprintf(stderr, "Base line at %d, hpos starts at %d\n", bline, hpos);
#endif
	    for (ti = pi->first; ti && ti != pi->next->first; ti = rid_scanf(ti) /*ti->next*/ )
	    {
#if RENDER_DEBUG
	    	fprintf(stderr, "Item at %p hpos=%d, width=%d\n", ti, hpos, ti->width);
#endif
		if (hpos >= right)
		    break;
		if ((ti->width == -1) || ((hpos + ti->width + ti->pad) >= left) )
		{
                        if (ti->tag == rid_tag_TABLE)
                        {
                                const int dx = hpos - ox;
                                const int dy = (bline + ti->max_up) - oy;
#if RENDER_DEBUG
		                fprintf(stderr, "Rendering table at %d,%d, bias %d,%d\n", hpos, bline, dx, dy);
#endif
                                backend_render_table(
                                        ((rid_text_item_table*)ti)->table,
                                        doc,
                                        ox + dx,
                                        oy + dy,
                                        left,
                                        top - dy,
                                        right,
                                        bot - dy,
                                        fs,
                                        g,
                                        update );
                        }
                        else
                        {
#if RENDER_DEBUG
		              fprintf(stderr, "Rendering item at %d,%d\n", hpos, bline);
#endif
		              (object_table[ti->tag].redraw)(ti, doc->rh, doc, hpos, bline, fs, g, ox, oy);
                        }
		}

		hpos += ti->width;
		hpos += ti->pad;
	    }
	}

}

void backend_render_rectangle(wimp_redrawstr *rr, void *h, int update)
{
    antweb_doc *doc = (antweb_doc *) h;
/*    rid_pos_item *pi;*/
/*    rid_text_item *ti;*/
    int ox, oy;
    int top, bot;
    int left, right;
    object_font_state fs;
    rid_header *rh;
    int do_fill;

    if (doc == NULL || doc->rh == NULL || doc->rh->stream.pos_list == NULL)
    {
	be_dummy_render(&(rr->g));
	return;
    }

    rh = doc->rh;

    /* ox and oy are the screen coordinates of the work area origin */
    ox = rr->box.x0 - rr->scx;
    oy = rr->box.y1 - rr->scy;

#if RENDER_DEBUG
    fprintf(stderr, "Rendering rectangle.  ox=%d, oy=%d.\n", ox, oy);
#endif

    if (rh)
    {
	top = rr->g.y1 - oy;
	bot = rr->g.y0 - oy;

#if RENDER_DEBUG
	fprintf(stderr, "Top work area = %d, bottom = %d\n", top, bot);
#endif
	left = rr->g.x0;
	right = rr->g.x1;

	do_fill = ((doc->flags & doc_flag_NO_FILL) == 0) && (update == 0);

	if ((doc->flags & doc_flag_DOC_COLOURS) &&
	    (rh->bgt & rid_bgt_IMAGE) &&
	    rh->tile.im &&
	    (rh->tile.width != 0))
	{
	    int fi;

	    image_info((image) rh->tile.im, 0, 0, 0, &fi, NULL, NULL);

#if 0   /* new tile code means don't ever fill when there's an image */
	    /* If we have an image and there is no mask then don't bother to do the background fill */
	    if ((fi & image_flag_MASK) == 0)
#endif
		do_fill = 0;
	}

	if (do_fill)
	{
#if RENDER_DEBUG
	    fprintf(stderr, "Clearing background\n");
#endif
	    render_set_bg_colour(render_colour_BACK, doc);
	    bbc_move(rr->g.x0, rr->g.y0);
	    bbc_plot(bbc_RectangleFill + bbc_DrawAbsBack, rr->g.x1, rr->g.y1);
	}

	if ((doc->flags & doc_flag_DOC_COLOURS) &&
	    (update == 0) &&
	    (rh->bgt & rid_bgt_IMAGE) &&
	    rh->tile.im &&
	    (rh->tile.width != 0) )
	{
#if RENDER_DEBUG
	    fprintf(stderr, "Tiling background\n");
#endif

	    image_tile((image) rh->tile.im, ox, oy, &(rr->g), render_get_colour(render_colour_BACK, doc), config_display_scale_image);
	}

	fs.lf = fs.lfc = -1;

        /* Now into the recursive stream rendering function */

        backend_render_stream(
                &doc->rh->stream,
                doc,
                ox,
                oy,
                left,
                top,
                right,
                bot,
                &fs,
                &rr->g,
                update);
    }

#if GROSS_ANTI_TWITTER
    if (1)
    {
	char clibuf[256];
	sprintf(clibuf, "NHAntiTwitter %d %d %d %d",
		rr->g.x0, rr->g.y0,
		rr->g.x1 - rr->g.x0, rr->g.y1 - rr->g.y0);
	system(clibuf);
    }
#endif

#if RENDER_DEBUG
    fprintf(stderr, "Render done\n");
#endif
}


/*
 * This function allows a request to update part of an item. The trim box is the margin of the box
 * that shouldn't be touched.
 * wont_plot_all is TRUE if when this item is plotted it doesn't automatically redraw the background
 * eg text and radio items are true
 * textarea or checkboxes are false
 * this allows the anti-twittering redraw to stop multiple filtering occurring.
 */

/*DAF*/
/*DAF*/
void antweb_update_item_trim(antweb_doc *doc, rid_text_item *ti, wimp_box *trim, BOOL wont_plot_all)
{
#if 1
    wimp_box box;

    if ((doc->flags & doc_flag_DISPLAYING) == 0)
        return;

    if (backend_doc_item_bbox(doc, ti, &box) == NULL)
    {
        if (trim)
        {
            box.x0 += trim->x0;
            box.y1 += trim->y1;
            box.x1 += trim->x1;
            box.y0 += trim->y0;
        }

        frontend_view_update(doc->parent, &box, &backend_render_rectangle, doc, wont_plot_all);
    }
#else
    wimp_box box;
    int hpos;
    rid_text_item *ti2;
    rid_pos_item  *pi = ti->line;

    for(hpos = pi->left_margin, ti2 = pi->first;
        ti2 && ti2 != ti && ti2 != pi->next->first;
        ti2 = rid_scanf(ti2) /*ti2->next*/ )
    {
	hpos += ti2->width;
	hpos += ti2->pad;
    }

    box.x0 = hpos;
    box.x1 = hpos + ti->width + ti->pad + 2;

    box.y1 = pi->top;
    box.y0 = pi->top - (pi->max_up + pi->max_down);

    if (doc->flags & doc_flag_DISPLAYING)
	frontend_view_update(doc->parent, &box, &backend_render_rectangle, doc);
#endif
}

void antweb_update_item(antweb_doc *doc, rid_text_item *ti)
{
    antweb_update_item_trim(doc, ti, NULL, TRUE);
}

#define LEEWAY 64
static void be_ensure_buffer_space(char **buffer, int *len, int more)
{
    int curlen = strlen(*buffer);

    if (curlen + more >= *len)
    {
	*len = *len + more + LEEWAY;
	*buffer = realloc(*buffer, *len);
    }
}

/*DAF*/
/*DAF*/
static void antweb_append_query(char **buffer, char *name, char *value, int *len)
{
    /* Worst case the value will be three time its original size when escaped */

    be_ensure_buffer_space(buffer, len, (name ? strlen(name) : 0) + 3 * strlen(value) + 2);

    strcat(*buffer, "&");

    if (name)
    {
	strcat(*buffer, name);
	strcat(*buffer, "=");
    }
    url_escape_cat(*buffer, value, *len);
}

static void antweb_append_textarea(char **buffer, rid_textarea_item *tai, int *len)
{
    rid_textarea_line *tal;

    if (tai->name == NULL)
	return;

    be_ensure_buffer_space(buffer, len, strlen(tai->name) + 2);

    strcat(*buffer, "&");

    strcat(*buffer, tai->name);
    strcat(*buffer, "=");

    for(tal = tai->lines; tal; tal = tal->next)
    {
	be_ensure_buffer_space(buffer, len, 3 * strlen(tal->text) + 2);

	url_escape_cat(*buffer, tal->text, *len);
	if (tal->next)
	    strcat(*buffer, "%0d%0a");
    }
}

/*DAF*/
/*DAF*/
static void antweb_write_query(FILE *f, char *name, char *value, int *first)
{
    if (*first)
    {
	*first = FALSE;
    }
    else
    {
	fprintf(f, "&");
    }
    if (name)
	fprintf(f, "%s=", name);
    url_escape_to_file(value, f);
}

/*DAF*/
/*DAF*/
static void antweb_write_textarea(FILE *f, rid_textarea_item *tai, int *first)
{
    rid_textarea_line *tal;

    if (tai->name == NULL)
	return;

    if (*first)
    {
	*first = FALSE;
    }
    else
    {
	fprintf(f, "&");
    }
    fprintf(f, "%s=", tai->name);

    for(tal = tai->lines; tal; tal = tal->next)
    {
	url_escape_to_file(tal->text, f);
	if (tal->next)
	    fputs("%0d%0a", f);
    }
}

/* The 'right' flag indicates a right click */

/*DAF*/
/*DAF*/
void antweb_submit_form(antweb_doc *doc, rid_form_item *form, int right)
{
    os_error *ep = NULL;
    rid_input_item *iis;
    rid_select_item *sis;
    rid_option_item *ois;
    rid_textarea_item *tai;

#if 1
    fprintf(stderr, "Submit form: action='%s', method='%s'\n",
	    form->action ? form->action : "<none>",
	    (form->method == rid_fm_GET ?
	     "GET" :
	     (form->method == rid_fm_POST ?
	      "POST" :
	      "<unknown>") ) );
#endif

    switch(form->method)
    {
    case rid_fm_GET:
        {
	    char *buffer;
	    char *dest, *dest2;
	    int buf_size = 1000;

	    dest = url_join(BASE(doc), form->action);

	    buffer = mm_malloc(buf_size);
	    buffer[0] = 0;
	    for(iis = form->kids; iis; iis = iis->next)
	    {
		switch (iis->tag)
		{
		case rid_it_HIDDEN:
		    antweb_append_query(&buffer, iis->name, iis->value, &buf_size);
		    break;
		case rid_it_IMAGE:
		    if ((iis->name != NULL) && (iis->data.image.x != -1))
		    {
			char buf2[12];
			char buf3[128];

			strcpy(buf3, strsafe(iis->name));

			strcat(buf3, ".x");
			sprintf(buf2, "%d", iis->data.image.x);
			antweb_append_query(&buffer, buf3, buf2, &buf_size);

			buf3[strlen(buf3)-1] = 'y';
			sprintf(buf2, "%d", iis->data.image.y);
			antweb_append_query(&buffer, buf3, buf2, &buf_size);
		    }
		    break;
		case rid_it_TEXT:
		case rid_it_PASSWD:
		    antweb_append_query(&buffer, iis->name, iis->data.str, &buf_size);
		    break;
		case rid_it_CHECK:
		case rid_it_RADIO:
		    if (iis->data.tick)
		    {
			antweb_append_query(&buffer, iis->name,
					    iis->value ? iis->value : "on", &buf_size);
		    }
		    break;
		case rid_it_SUBMIT:
		    if (iis->data.tick && iis->name)
		    {
			antweb_append_query(&buffer, iis->name,
					    iis->value ? iis->value : "", &buf_size);
		    }
		    break;
		}
	    }
	    for(sis = form->selects; sis; sis = sis->next)
		for(ois = sis->options; ois; ois = ois->next)
		    if (ois->flags & rid_if_CHECKED)
			antweb_append_query(&buffer, sis->name,
					    ois->value ? ois->value : ois->text, &buf_size);

	    for(tai = form->texts; tai; tai = tai->next)
		antweb_append_textarea(&buffer, tai, &buf_size);

	    if (buffer[0] == 0)
		buffer[1] = 0;
	    buffer[0] = '?';
	    dest2 = url_join(dest, buffer);
	    mm_free(dest);
	    mm_free(buffer);

	    /* In theory the URL join can fail */
	    if (dest2)
	    {
#if 1
	    fprintf(stderr, "Query string is:\n'%s'\n", dest2);
#endif
		/* Never get a form query from the cache */
		ep = frontend_complain(frontend_open_url(dest2, right ? 0 : doc->parent,
							 form->target, NULL, 1));

		mm_free(dest2);
	    }
	    else
	    {
		frontend_complain(makeerror(ERR_BAD_FORM));
	    }
	}
	break;
    case rid_fm_POST:
        {
	    FILE *f;
	    char *fname;
	    int first = TRUE;
	    char *dest;

	    fname = strdup(tmpnam(0));
	    dest = strrchr(fname, 'x');
	    if (dest)
		*dest = 'y';
	    f = fopen(fname, "w");

	    for(iis = form->kids; iis; iis = iis->next)
	    {
		switch (iis->tag)
		{
		case rid_it_HIDDEN:
		    antweb_write_query(f, iis->name, iis->value, &first);
		    break;
		case rid_it_IMAGE:
		    if (iis->data.image.x != -1)
		    {
			char buf2[12];
			char buf3[128];

			strcpy(buf3, strsafe(iis->name));

			strcat(buf3, ".x");
			sprintf(buf2, "%d", iis->data.image.x);
			antweb_write_query(f, buf3, buf2, &first);

			buf3[strlen(buf3)-1] = 'y';
			sprintf(buf2, "%d", iis->data.image.y);
			antweb_write_query(f, buf3, buf2, &first);
		    }
		    break;
		case rid_it_TEXT:
		case rid_it_PASSWD:
		    antweb_write_query(f, iis->name, iis->data.str, &first);
		    break;
		case rid_it_CHECK:
		case rid_it_RADIO:
		    if (iis->data.tick)
		    {
			antweb_write_query(f, iis->name, iis->value ? iis->value : "on", &first);
		    }
		    break;
		case rid_it_SUBMIT:
		    if (iis->data.tick && iis->name)
		    {
			antweb_write_query(f, iis->name, iis->value ? iis->value : "", &first);
		    }
		    break;
		}
	    }

	    for(sis = form->selects; sis; sis = sis->next)
		for(ois = sis->options; ois; ois = ois->next)
		    if (ois->flags & rid_if_CHECKED)
			antweb_write_query(f, sis->name, ois->value ? ois->value : ois->text, &first);

	    for(tai = form->texts; tai; tai = tai->next)
		antweb_write_textarea(f, tai, &first);

	    fclose(f);

	    dest = url_join(BASE(doc), form->action);

	    ep = frontend_complain(frontend_open_url(dest, right ? 0 : doc->parent,
	        form->target, fname, 1)); /* Never get a form query from the cache */
	    mm_free(dest);
	}
	break;
    default:
	break;
    }

}

/*DAF*/
/*DAF*/
void antweb_place_caret(antweb_doc *doc)
{
    rid_text_item *ti = doc->input;

    if (ti && object_table[ti->tag].caret)
    {
	(object_table[ti->tag].caret)(ti, doc->rh, doc, FALSE);
    }
    else
    {
	/* Give the window the input focus but no visable caret */
	frontend_view_caret(doc->parent, 0, 0, -1, 0);
    }
}


/*DAF*/
/*DAF*/
static os_error *antweb_document_sizeitems(antweb_doc *doc)
{
    rid_text_item *ti;

fprintf(stderr, "antweb_document_sizeitems start\n");

    /* Pass one: size everything up */

    doc->im_error = doc->im_unfetched = doc->im_fetched = doc->im_fetching = 0;

    ti = doc->rh->stream.text_list;

    /* First do each individual item */
    while (ti)
    {   /* Tables will recurse on child objects */
	(object_table[ti->tag].size)(ti, doc->rh, doc);

        /* might be no pos list, so no scanfr() */
	/*ti = ti->next;*/
        ti = rid_scanf(ti);
    }

#if 1
    fprintf(stderr, "Sized items\nImages: %d waiting, %d fetching, %d fetched, %d errors.\n",
	    doc->im_unfetched, doc->im_fetching, doc->im_fetched, doc->im_error);

#endif

    return NULL;
}






static int antweb_formater_tidy_line(rid_pos_item *new, int width, int display_width)
{
    if ((new->first->st.flags & rid_sf_CENTERED ) && new->first->width != -1)
    {
	/* Only center things that can fit on the display */
	if (width < display_width)
	    new->left_margin += ((display_width - width) >> 1);
    }
    else if ((new->first->st.flags & rid_sf_RIGHTALIGN ) && new->first->width != -1)
    {
            new->left_margin += display_width - width;
    }

    return (new->max_up + new->max_down);
}


extern int be_margin_proc (rid_text_stream *stream, rid_text_item *item)
{
        return item == NULL ? 0 :
                item->st.indent * INDENT_UNIT;	/* NvS We no longer as a left gap */
}


/*****************************************************************************

    The new formatting routine. Why? It replaces two seperate routines with one
    and replaces multiple occurences of code sequences with one each. And it
    handles the ALIGN=CHAR stuff as well. There are still loose threads (eg
    widest and fmt->width).

    The margin_proc returns the offset from the left hand margin for the
    line.  This excludes any ALIGN=CHAR bias. A margin_proc must be supplied.

    The tidy_proc finishes the line.  It returns the height of the line.  It
    centers or right aligns any lines that need aligning.  It might also
    perform justification through sharing spare width (ie display_width-width).
    A tidy_proc must be supplied.

    The table_proc recurses on tables before they are examined.  It does not
    return anything.  A table_proc need not be supplied (ie use NULL).

    When alignment is active, the first occurence of the alignment character
    on each line must be vertically aligned.

    Items can mark themselves as never, maybe or always being followed by a
    line break.  We refuse a break for the first item on the line. We attempt
    to break if we are about to overflow the available space. This gives a
    basic line structure of:

    margin ( word pad ) * word

*/

#define DONT    0
#define MUST    1
#define MAYBE   2

#define DONE    0
#define MARGIN  1
#define WORD    2
#define TIDY    3

static char *split_names[] = { "DONT", "MUST", "MAYBE" };
static char *state_names[] = { "DONE", "MARGIN", "WORD", "TIDY" };

extern rid_pos_item *be_formater_loop_core( rid_text_stream *st, rid_text_item *this, rid_fmt_info *fmt, int flags)
{
        rid_pos_item *pos = NULL;
        int split = DONT;       /* Whether must, must not or maybe split word */
        int pad = 0;            /* holds padding from previous item */
        int align_margin = 0;   /* extra margin space due to character alignment */
        int left_margin = 0;    /* value for pos->left_margin if doing it */
        int width = 0;          /* total width of line so far */
        int state = MARGIN;     /* state machine control variable */
        int height = st->height;
        int widest = st->widest;
        const int display_width = st->fwidth;

        NFMTDBG((stderr, "be_formater_loop_core(%p, %p, %p, %x)\n", st, this, fmt, flags));
        NFMTDBG((stderr, "Entry: left %d, right %d, width %d\n", *fmt->left, *fmt->right, *fmt->width));

	if (this != NULL && this->tag == rid_tag_TABLE)
		(*fmt->table_proc) (st, this, fmt);

        while (state != DONE)
        {
                NFMTDBG((stderr, "format state: %s, split %s\n", state_names[state], split_names[split]));

                switch (state)
                {
                case MARGIN:
                        flags &= ~ rid_fmt_HAD_ALIGN;
                        align_margin = pad = 0;
                        split = DONT;
                        state = this == NULL ? DONE : WORD;
                        left_margin = state == DONE ? 0 : (*fmt->margin_proc) (st, this);
                        width = left_margin;
                        if ( (flags & rid_fmt_BUILD_POS) != 0 )
                        {
                                pos = mm_calloc(1, sizeof(*pos));
                                rid_pos_item_connect(st, pos);
                                pos->first = this;
                                pos->top = height;
                                pos->st = st;
                        }
                        NFMTDBG((stderr, "state now %s, left_margin %d\n", state_names[state], left_margin));
                        break;

                case WORD:
			/* Committed to adding this word to this line */

			ASSERT(split == DONT);

                        if ( (flags & rid_fmt_CHAR_ALIGN) != 0 && pad + width > *fmt->left)
                        {
                                *fmt->left = pad + width;
                                FMTDBG((stderr, "Increased left by %d to %d\n", \
                                	align_margin, *fmt->left));
                        }

                        width += pad + align_margin + this->width;
                        left_margin += align_margin;
                        pad = this->pad;
                        align_margin = 0;
                        split = MAYBE;

                        if ( (flags & rid_fmt_BUILD_POS) != 0 )
                        {
                                if (this->max_up > pos->max_up)       pos->max_up = this->max_up;
                                if (this->max_down > pos->max_down)   pos->max_down = this->max_down;
                                this->line = pos;
                        }

                        if      ( (this->flag & rid_flag_LINE_BREAK) != 0 )     { split = MUST; }
                        else if ( (this->flag & rid_flag_NO_BREAK) != 0 )       { split = DONT; }
                        else if ( (flags & rid_fmt_MIN_WIDTH) != 0 )            { split = MUST; }
                        else if ( (flags & rid_fmt_MAX_WIDTH) != 0 )            { split = DONT; }
			else							{ split = MAYBE;}

                        this = rid_scanf(this);
                        NFMTDBG((stderr, "DONT: added word: width %d, pad %d, next %p\n", width, pad, this));

                        if ( (flags & (rid_fmt_CHAR_ALIGN | rid_fmt_HAD_ALIGN)) == rid_fmt_CHAR_ALIGN &&
                              this->tag == rid_tag_TEXT &&
                              fmt->text_data[ ((rid_text_item_text *)this)->data_off] == fmt->align_char )
                        {
                                FMTDBG((stderr, "Character alignment triggered\n"));
                                flags |= rid_fmt_HAD_ALIGN;
                                if (pad + width < *fmt->left)
                                {
                                        align_margin = *fmt->left - width - pad;
                                        FMTDBG((stderr, "%d padding due to character alignment\n",\
                                        	align_margin));
                                }
                        }
                        else if (this->tag == rid_tag_TABLE)
                                (*fmt->table_proc) (st, this, fmt);

			if (split == MAYBE)
			{
                        	if ( align_margin + width + pad + this->width > display_width)
                        		{ split = MUST; }
                        	else
                        		{ split = DONT; }
	                        NFMTDBG((stderr, "Resolved MAYBE to %s split\n", \
	                        	split == DONT ? "DONT" : "MUST"));
                        }

                        if (this == NULL || split == MUST)
                        {
                                state = TIDY;
                        }
                        break;

                case TIDY:
                        if ( (flags & rid_fmt_CHAR_ALIGN) != 0 )
                        {
                                if ( (flags & rid_fmt_HAD_ALIGN) != 0 )
                                {
                                        if ( width - *fmt->left > *fmt->right )
                                                *fmt->right = width - *fmt->left;
                                }
                                else
                                {
                                        FMTDBG((stderr, "Align char %c not present - padding\n", fmt->align_char));
                                        if (width > *fmt->left)
                                        {
                                                *fmt->left = width;
                                                FMTDBG((stderr, "Increased left to %d\n", *fmt->left));
                                        }
                                        else
                                        {
                                                left_margin += *fmt->left - width;
                                                FMTDBG((stderr, "Increased left_margin by %d to %d\n", *fmt->left - width, left_margin));
                                                width = *fmt->left;
                                        }
                                }
                        }
                        if ( (flags & rid_fmt_BUILD_POS) != 0 )
                        {
                                pos->left_margin = left_margin;
                                height -= (*fmt->tidy_proc) (pos, width, display_width);
                        }
                        if (width > widest)
                                widest = width;
                        state = MARGIN;
                        break;
                }
        }

        if ( (flags & rid_fmt_CHAR_ALIGN) == 0 )
        {
                if (*fmt->left + *fmt->right > widest)
                        widest = *fmt->left + *fmt->right;
                if (widest > *fmt->width)
                        *fmt->width = widest;
                NFMTDBG((stderr, "Exit:  left %d, right %d, width %d\n", *fmt->left, *fmt->right, *fmt->width));
        }

        if ( (flags & rid_fmt_BUILD_POS) != 0 )
        {
                st->widest = widest;
                st->height = st->pos_last->top;

                NFMTDBG((stderr, "st->widest %d, st->height %d\n", st->widest, st->height));
        }


        return pos;
}

#undef DONT
#undef MUST
#undef MAYBE
#undef DONE
#undef MARGIN
#undef WORD
#undef TIDY


/*****************************************************************************/

extern int  dummy_tidy_proc(rid_pos_item *new, int width, int display_width)
{
  	return 0;
}

extern void dummy_table_proc(rid_text_stream *stream, rid_text_item *item, rid_fmt_info *parfmt)
{
  	return;
}

void be_formater_loop(rid_header *rh, rid_text_item *ti)
{
        rid_text_stream *st = &rh->stream;
        rid_fmt_info fmt;

        FMTDBG((stderr, "be_formater_loop - sizing\n"));

        memset(&fmt, 0, sizeof(fmt));
        memset(&st->width_info, 0, sizeof(st->width_info));

        fmt.margin_proc = &be_margin_proc;
        fmt.tidy_proc = &dummy_tidy_proc;
        fmt.table_proc = &dummy_table_proc;
        fmt.text_data = rh->texts.data;

        /* Then get min|max widths for tables */
        rid_size_stream(st, &fmt, 0);

        /* Do the actual format */

        FMTDBG((stderr, "be_formater_loop - building\n"));

        fmt.margin_proc = &be_margin_proc;
        fmt.tidy_proc = &antweb_formater_tidy_line;
        fmt.table_proc = &rid_table_share_width;

        be_formater_loop_core(st, ti, &fmt, rid_fmt_BUILD_POS);

        FMTDBG((stderr, "be_formater_loop done\n"));
#if 0
        dump_stream(st);
#endif
}


os_error *antweb_document_format(antweb_doc *doc, int user_width)
{
    rid_text_item *ti;

#if 1
    fprintf(stderr, "Document title: '%s' \n", doc->rh->title ? doc->rh->title : "<none>");

#endif

#if 0
    rid_free_pos(doc->rh->stream.pos_list);
    doc->rh->stream.pos_list = doc->rh->stream.pos_last = NULL;

    ti = doc->rh->stream.text_list;
    if (ti == NULL)
	return NULL;

    new = mm_calloc(1, sizeof(*new));

    doc->rh->stream.height = 0;
    doc->rh->stream.widest = 0;

    new = be_formater_loop(&doc->rh->stream, ti, new);
#else
    /* Include tables in free of pos items */
    rid_free_pos_tree(doc->rh->stream.pos_list);
    doc->rh->stream.pos_list = doc->rh->stream.pos_last = NULL;

    ti = doc->rh->stream.text_list;
    if (ti == NULL)
	return NULL;

    /* Zero w|h for all table descendent streams as well */
    rid_zero_widest_height(&doc->rh->stream);

    be_formater_loop(doc->rh, ti);

#endif

fprintf(stderr, "end antweb_document_format\n");


    return NULL;
}


/*DAF*/
/*DAF*/

static void be_document_reformat_tail(antweb_doc *doc, rid_text_item *oti, int user_width)
{
    int height;
    rid_text_item *ti;
    rid_pos_item *new, *tail;
    wimp_box bb;
#if 1
    fprintf(stderr, "Asked to reformat tail of doc %p from %p onwards.\n", doc, oti);
#endif
    bb.x0 = 0;

    if (oti)
	ti = oti->line->first;
    else
	ti = doc->rh->stream.text_list;

    if (ti == NULL)
	return;
#if 1
    fprintf(stderr, "Line start item is %p\n", ti);
#endif
    new = ti->line;
#if 1
    fprintf(stderr, "Line pos item 'new' is %p\n", new);
#endif

    /* Zero all existing widest and height values in nested items */
    rid_zero_widest_height_from_item(ti);

    /* Chop off the old list before the last non-empty entry. */
    if (new->prev)
	new->prev->next = NULL;
    else
	doc->rh->stream.pos_list = NULL;
#if 1
    fprintf(stderr, "Set the back pointer\n");
#endif
    doc->rh->stream.pos_last = new->prev;
#if 1
    fprintf(stderr, "Pos list chopped\n");
#endif

    /* The starting height is top of the old last line */

    doc->rh->stream.height = height = new->top;
    bb.y1 = height;

    /* Include tables in freeing of pos items */
    rid_free_pos_tree(new);

#if 1
    fprintf(stderr, "Calling the formatter loop\n");
#endif

    be_formater_loop(doc->rh, ti);

#if 1
    fprintf(stderr, "Formatter loop done\n");
#endif
    bb.x1 = doc->rh->stream.widest > user_width ? doc->rh->stream.widest : user_width;
    bb.y0 = doc->rh->stream.height;

    if (doc->parent && (doc->flags & doc_flag_DISPLAYING))
	frontend_view_redraw(doc->parent, &bb);
}

/*
 * This replacement for frontend_view_set_dimensions checks the return value. If set this means
 * that the horizontal width may have changed and should be reread and the document reformatted.
 */

static void be_set_dimensions(be_doc doc)
{
    if (frontend_view_set_dimensions(doc->parent,
        doc->rh->stream.widest, doc->rh->stream.height))
    {
        fe_view_dimensions fvd;
        frontend_view_get_dimensions(doc->parent, &fvd);

        doc->rh->stream.fwidth = fvd.user_width;

        antweb_document_format(doc, doc->rh->stream.fwidth);

        frontend_view_set_dimensions(doc->parent,
            doc->rh->stream.widest, doc->rh->stream.height);
    }
}

/*DAF*/
/*DAF*/
os_error *backend_reset_width(be_doc doc, int width)
{
    fe_view_dimensions fvd;

    if (doc->rh->frames)
    {
        /* always relay if this is called */
        frontend_view_get_dimensions(doc->parent, &fvd);

        layout_layout(doc, fvd.layout_width, fvd.layout_height, 1);

        doc->rh->stream.widest = fvd.wa_width;
        doc->rh->stream.height = fvd.wa_height;
    }
    else
    {
        int old_user_width = doc->rh->stream.fwidth;
        frontend_view_get_dimensions(doc->parent, &fvd);

        /* only reformat if the width has actually changed */
        if (old_user_width != fvd.user_width)
        {
            doc->rh->stream.fwidth = fvd.user_width;
            antweb_document_format(doc, doc->rh->stream.fwidth);

            be_set_dimensions(doc);
        }
    }

    if (frontend_view_has_caret(doc->parent))
        antweb_place_caret(doc);

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_goto_fragment(be_doc doc, char *frag)
{
    rid_aref_item *ai;
    int top;

    if (doc == NULL || doc->rh == NULL)
	return makeerror(ERR_BAD_DOCUMENT);

#if 1
    fprintf(stderr, "Going to fragment '%s'\n", frag ? frag : "<none>");
#endif
    if (frag)
    {
        rid_text_item *first;

	ai = doc->rh->aref_list;

	while (ai)
	{
	    if (ai->name && strcasecomp(ai->name, frag) == 0)
		break;
	    ai = ai->next;
	}

	if (ai == NULL)
	    return makeerror(ERR_NO_SUCH_FRAG);

        first = ai->first ? ai->first : doc->rh->stream.text_list;
	if (first && first->line)
	{
            top = first->line->top;
    	    frontend_view_ensure_visable(doc->parent, 0, top, top);
    	}
    }

    return NULL;
}

/*DAF*/
/*DAF*/
void be_update_image_size(antweb_doc *doc, void *i)
{
    rid_text_item *ti;

    for (ti = doc->rh->stream.text_list; ti; ti = rid_scanfr(ti) /*ti->next*/ )
    {
	if ((object_table[ti->tag].imh != NULL) &&
	    ((object_table[ti->tag].imh)(ti, doc) == i) )
	{
            assert(ti->tag !=rid_tag_TABLE);
	    (object_table[ti->tag].size)(ti, doc->rh, doc);
	}
    }
}

/* This function gets called as a callback when an image changes */

/* When an image changes it can be a) above the visable area, b)
 * intersecting with the visable area or c) below the visable area.
 * If it is below we can pretty much ignore the image; the reformat is
 * needed but we do not need any redraw.  If the image intersects with
 * the visable area the a redraw is needed at least for the image and
 * maybe for the rest of tyhe paragraph.  If the image is above the
 * visable area the we need to find out if it has caused any
 * reformatting.  We note the first visable object before and after
 * the reformat.  If the first visable object is still at the
 * beginning of a line after the reformat and no changes have fallen
 * within the old visable area then we can be sure that the format of
 * what was visable has not changed and we can try to get away with no
 * redrawing.  For good measure if we have not forced a whole-sale
 * redraw then we should update the images on the screen.  Maybe we
 * should even force a redraw since the new image may be trasparent.
 */
/*
    When an image is within a table (a table cell or a table caption) and
    it's size changes, then the redraw rectangle needs growing to enclose the
    table the image is contained within.  For reliable results, grow outwards
    until all parent tables have been included.  For more efficient results,
    when considering a table, resize and reformat it and then only include it
    if the old and new sizes are different.  If the sizes are different,
    likewise consider the next enclosing table, etc.  There's probably better
    still.

    This comes out pretty messy with tables.  Volunteers to rewrite it with
    better optimisations welcomed! Finding a better algorithm than cloning
the pos list would be excellent!

    To avoid having to think too much, if the image is contained
    anywhere within a table, we try to pretend the outermost table is what
    has changed.

    We now take a clone of the pos list and free it afterwards. This is
    more work but it should work correctly. Remember the free must be rid_free_pos()
and not rid_free_pos_tree(), as we don't wish to disturb any child pos lists.
When we perform the scan locating height, to obtain a pos pointer to remember,
this must be from the cloned pos list, as the existing pos list is about to
be freed by the format operation.

*/


/*DAF*/
/*DAF*/
void antweb_doc_image_change(void *h, void *i, int status)
{
    antweb_doc *doc = (antweb_doc *) h;
    int changed = FALSE;
    rid_pos_item *pi;
    rid_pos_item *clonedposlist = NULL;
    rid_text_item *first_ti;
    rid_text_item *ti;
    int top, bottom, line_top = 0;
    wimp_box bounds;
    int do_rid_size = 0;

#if DEBUG_IMAGE_CHANGE
    fprintf(stderr, "Image change called, doc=0x%p, status %d\n", doc, status);
#endif

    switch (status)
    {
        case image_cb_status_WORLD:
            frontend_view_status(doc->parent, sb_status_WORLD, NULL);
            return;

        case image_cb_status_NOACTION:
            be_update_image_info(doc);
            return;

        default:
            be_update_image_info(doc);
            break;
    }

    if ((doc->flags & doc_flag_DISPLAYING) == 0)
    {
	be_update_image_size(doc, i);
	return;
    }

    frontend_view_bounds(doc->parent, &bounds);

    top = bounds.y1;
    bottom = bounds.y0;

    if (doc->rh->stream.pos_list == NULL)	/* If the image is on disc then we can be called before the first format */
    {
#if DEBUG_IMAGE_CHANGE
	fprintf(stderr, "Image change quit early\n");
#endif
	return;
    }

    clonedposlist = rid_clone_pos_list(doc->rh->stream.pos_list);

    for (pi = clonedposlist; pi->next && pi->next->top > top; pi = pi->next)
	;

    first_ti = pi->first;		/* This is the first displayed item in the view */
    line_top = pi->top;

    ti = doc->rh->stream.text_list;
#if DEBUG_IMAGE_CHANGE
    fprintf(stderr, "Starting rescan\n");
#endif

    /* Need to scan recursively to actually find the images, but use */
    /* the outermost item when looking for redraw sizes, etc. */
    /* Pretty gruesome really. Go for region covered by table */
    /* and image, just in case. */

    while (ti)
    {
	if (object_table[ti->tag].imh != NULL && (object_table[ti->tag].imh)(ti, doc) == i)
	{
	    int ow, omu, omd;

	    ow = ti->width;
	    omu = ti->max_up;
	    omd = ti->max_down;

	    (object_table[ti->tag].size)(ti, doc->rh, doc);

	    if (ow != ti->width || omu != ti->max_up || omd != ti->max_down)
	    {
                rid_text_item *outeritem = rid_outermost_item(ti);

		if (ti->line->top < bottom) /* top of line below the bottom of view */
		    changed |= (1 << 2); /* Set bit for below */
		else if ( (ti->line->top - (ti->line->max_up + ti->line->max_down)) > top) /* Bottom of line above top of view */
		    changed |= (1 << 1); /* Set bit for above */
		else
		    changed |= (1 << 0); /* Set bit for in view */

		if (outeritem->line->top < bottom) /* top of line below the bottom of view */
		    changed |= (1 << 2); /* Set bit for below */
		else if ( (outeritem->line->top - (outeritem->line->max_up + outeritem->line->max_down)) > top) /* Bottom of line above top of view */
		    changed |= (1 << 1); /* Set bit for above */
		else
		    changed |= (1 << 0); /* Set bit for in view */
	    }
	}

        /* Needs pos list, hence moved above yucky nulling */
	ti = rid_scanfr(ti) /*ti->next*/ ;
    }

    if (changed)
    {
	int old_height;
	int net_shift, shift_pending;
	int top_of_zone;
	int is_shift_pending;
	rid_pos_item *opi;
	int new_bottom;
	wimp_box box;

	/* If we have the caret, hide it for the moment */
	if (frontend_view_has_caret(doc->parent))
	{
	    frontend_view_caret(doc->parent, 0, 0, -1, 0);
	}

	box = bounds;		/* We want x0 and x1 at the least */
#if DEBUG_IMAGE_CHANGE
	fprintf(stderr, "Changed = %d\n", changed);
#endif
	old_height = doc->rh->stream.height;

#if DEBUG_IMAGE_CHANGE
	fprintf(stderr, "About to reformat\n");
#endif

	antweb_document_format(doc, doc->rh->stream.fwidth);

#if DEBUG_IMAGE_CHANGE
	fprintf(stderr, "Reformat done\n");
#endif
	if (doc->rh->stream.height != old_height)
	{
#if DEBUG_IMAGE_CHANGE
	    fprintf(stderr, "Old height was %d, new height is %d\n",
		    doc->rh->stream.height, old_height);
#endif
	    be_set_dimensions(doc);
	}

#if DEBUG_IMAGE_CHANGE
	fprintf(stderr, "Checking what has changed\n");
#endif
	if (changed & 3)
	{
	    net_shift = 0;
	    is_shift_pending = TRUE;
	    shift_pending = first_ti->line->top - line_top;
	    top_of_zone = first_ti->line->top; /* Always in new format coordinates */

	    if (shift_pending != 0)
	    {
#if DEBUG_IMAGE_CHANGE
		fprintf(stderr, "Shift = %d\n", shift_pending);
#endif
		frontend_view_ensure_visable(doc->parent, -1, top + shift_pending, bottom + shift_pending);
	    }
	    new_bottom = bottom + shift_pending;
#if DEBUG_IMAGE_CHANGE
	    fprintf(stderr, "Scroll shift = %d\n", shift_pending);
#endif
	    /* For each line in the old view: */
	    for (opi = pi; opi && (opi->top > bottom); opi = opi->next)
	    {
		int reuse = FALSE;
#if DEBUG_IMAGE_CHANGE
		fprintf(stderr, "Looking at line that was at %d\n", opi->top);
#endif
		/* If there is nothing on the line or the new version of the line is out of view */
		if ((opi->first == NULL) || (opi->first->line->top < new_bottom))
		    break;

		if ((opi->next == NULL) ||
		    ((opi->first->line->next != NULL) &&
		     (opi->first->line->first == opi->first) &&
		     (opi->next->first == opi->first->line->next->first)))
		{
		    rid_text_item *tiscan;
		    int have_image = FALSE;

                    /* Prevent reuse if the image occurs in the outermost line being examined, */
                    /* or a table which is at the outermost level contains the image. */

		    for(tiscan = opi->first;
                        tiscan && (tiscan->line != opi->first->line->next);
                        tiscan = rid_scanf(tiscan) /*tiscan->next*/ )
		    {
#if DEBUG_IMAGE_CHANGE > 1
			fprintf(stderr, "<");
#endif
                        if (tiscan->tag == rid_tag_TABLE)
                        {
                                if (rid_table_holds_image(tiscan, i, doc))
                                {
                                        have_image = TRUE;
                                        break;
                                }
                        }
                        else if (object_table[tiscan->tag].imh != NULL && (object_table[tiscan->tag].imh)(tiscan, doc) == i)
			{
			    have_image = TRUE;
			    break;
			}
#if DEBUG_IMAGE_CHANGE > 1
			fprintf(stderr, ">");
#endif
		    }

		    if (!have_image)
			reuse = TRUE;
		}

#if DEBUG_IMAGE_CHANGE
		    fprintf(stderr, "Line reuse = %d\n", reuse);
#endif

		/* 	if the line is reusable: */
		if (reuse)
		{
		    /* 	if no shift pending: */
		    if (!is_shift_pending)
		    {
#if DEBUG_IMAGE_CHANGE
			fprintf(stderr, "Reuse line with no shift pending\n");
#endif
			/*	redraw from top of dirty zone to top of this line */
			box.y1 = top_of_zone;
			box.y0 = opi->first->line->top;
#if DEBUG_IMAGE_CHANGE
			fprintf(stderr, "Force redraw from %d to %d\n", box.y1, box.y0);
#endif
			frontend_view_redraw(doc->parent, &box);
			/*	set shift pending to shift needed for this line minus net shift so far */
			top_of_zone = opi->first->line->top;
			shift_pending = (opi->first->line->top - opi->top) - net_shift;
			is_shift_pending = TRUE;
#if DEBUG_IMAGE_CHANGE
			fprintf(stderr, "Set shift of %d pending from %d down\n", shift_pending, top_of_zone);
#endif
		    }
		}
		/* 	if the line is not reusable: */
		else
		{
		    /* 	if shift pending: */
		    if (is_shift_pending)
		    {
#if DEBUG_IMAGE_CHANGE
			fprintf(stderr, "Don't reuse line with a shift pending\n");
#endif
			if (shift_pending) /* Only work the effort is the shift is non-zero */
			{
			    /* shift from top of shift to above this line by shift pending */
			    box.y1 = top_of_zone - shift_pending;
			    box.y0 = new_bottom - shift_pending;
#if DEBUG_IMAGE_CHANGE
			    fprintf(stderr, "Non-zero shift, y1 = %d, y0 = %d, new y0 = %d\n",
				    box.y1, box.y0, box.y0 + shift_pending);
#endif
			    frontend_view_block_move(doc->parent, &box, box.x0, box.y0 + shift_pending );
			    /* add shift pending to net shift so far */
			    net_shift += shift_pending;
#if DEBUG_IMAGE_CHANGE
			    fprintf(stderr, "Net shift now %d\n", net_shift);
#endif
			}
			/* 		make top of this line as to of dirty zone */
			top_of_zone = opi->first->line->top;
			is_shift_pending = FALSE;
#if DEBUG_IMAGE_CHANGE
			fprintf(stderr, "Top of dirty zone = %d\n", top_of_zone);
#endif
		    }
		}
	    }

#if DEBUG_IMAGE_CHANGE
	    fprintf(stderr, "Finished scanning viable range\n");
#endif

	    /* if shift pending: */
	    if (is_shift_pending)
	    {
		if (shift_pending)
		{
		    /* 	shift from top of shift to bottom of view by shift pending */
		    box.y1 = top_of_zone - shift_pending;
		    box.y0 = new_bottom - shift_pending;
#if DEBUG_IMAGE_CHANGE
		    fprintf(stderr, "Non-zero shift (left over), y1 = %d, y0 = %d, new y0 = %d\n",
			    box.y1, box.y0, box.y0 + shift_pending);
#endif
		    frontend_view_block_move(doc->parent, &box, box.x0, box.y0 + shift_pending );
		}
	    }
	    /* else: */
	    else
	    {
		/* 	redraw from top of dirty to bottom of view */
		box.y1 = top_of_zone;
		box.y0 = new_bottom;
#if DEBUG_IMAGE_CHANGE
		fprintf(stderr, "Force redraw from %d to %d\n", box.y1, box.y0);
#endif
		frontend_view_redraw(doc->parent, &box);
	    }
	}

	if (frontend_view_has_caret(doc->parent))
	{
	    antweb_place_caret(doc);
	}
    }
    else
    {
	wimp_box bb;
/*	int x,y; */
	int flags;
	int do_redraw;
	int real_thing_flag;

/*	image_info(i, &x, &y, NULL, &flags, NULL, NULL); x,y not used */
	image_info(i, NULL, NULL, NULL, &flags, NULL, NULL);

	real_thing_flag = (flags & image_flag_REALTHING) ? rid_image_flag_REAL : 0;

	/* We need to redraw (rather than update) if there is a mask and the image is
	   interlace.  We also need to redraw if we have changed the real_thing flag. */
#if 0
	do_redraw = ((flags & image_flag_MASK) && (flags & image_flag_INTERLACED) );
#else
	do_redraw = 0;
#endif
	/* We took out the old list but we never did a reformat */
	/*doc->rh->stream.pos_list = oldposlist;*/
	/* Set this NULL to stop it being freed */
	/*oldposlist = NULL;*/

	/* The new image must be the same size.  Redraw the image when on the screen. 	*/
        /* This recurses through tables as well - should work okay */
	for (ti = first_ti; ti && (ti->line->top > bottom); ti = rid_scanfr(ti) /*ti->next*/ )
	{
	    if (object_table[ti->tag].imh != NULL && (object_table[ti->tag].imh)(ti, doc) == i)
	    {
		int rtc;
		rid_text_item_image* tii = (rid_text_item_image*) ti;

		rtc = (tii->flags & rid_image_flag_REAL) ^ real_thing_flag;

		/* rtc non-zero if it has changed */

		if (do_redraw || rtc)
		{
		    int x, y;
		    antweb_locate_item(ti, &x, &y);

		    bb.x0 = x;
		    bb.x1 = x + ti->width;
		    bb.y0 = y - ti->max_down;
		    bb.y1 = y + ti->max_up;

		    frontend_view_redraw(doc->parent, &bb);

		    if (real_thing_flag)
			tii->flags |= rid_image_flag_REAL;
		    else
			tii->flags &= ~rid_image_flag_REAL;
		}
		else
		{
		    /* SJM: masked images wont redraw all the screen */
		    antweb_update_item_trim(doc, ti, NULL,
		        (flags & image_flag_FETCHED ? 0 : fe_update_IMAGE_RENDERING) +
		        (flags & image_flag_MASK ? fe_update_WONT_PLOT_ALL : 0));
		}
	    }
	}
    }

    /* NOT rid_free_pos_tree() though */
    if (clonedposlist)
	rid_free_pos(clonedposlist);

#if DEBUG_IMAGE_CHANGE
    fprintf(stderr, "Image change finished\n");
#endif
}

/*DAF*/
/*DAF*/
void antweb_doc_background_change(void *h, void *i, int status)
{
    int width, height;
    int fl;
    antweb_doc *doc = (antweb_doc *) h;

    switch (status)
    {
        case image_cb_status_WORLD:
            frontend_view_status(doc->parent, sb_status_WORLD, NULL);
            return;

        case image_cb_status_NOACTION:
            be_update_image_info(doc);
            return;

        default:
            be_update_image_info(doc);
            break;
    }

    image_info((image) doc->rh->tile.im, &width, &height, 0, &fl, 0, 0);

    if ((fl & image_flag_FETCHED) && (fl & image_flag_RENDERABLE))
    {
	doc->rh->tile.width = width*config_display_scale_image/100;
	doc->rh->tile.height = height*config_display_scale_image/100;

	if (doc->flags & doc_flag_DISPLAYING)
	    frontend_view_redraw(doc->parent, NULL);

	/* If the BG colour is not set and the image has no mask set the BG colour to average */
	if (((doc->rh->bgt & rid_bgt_COLOURS) == 0) &&
	    ((fl & image_flag_MASK) == 0))
	{
	    fprintf(stderr, "Setting background colour\n");

	    doc->rh->bgt |= rid_bgt_COLOURS;
	    doc->rh->colours.back = image_average_colour(i);

	    fprintf(stderr, "New bg colour is 0x%08x\n", doc->rh->colours.back);
	}
    }
}

/*DAF*/
/*DAF*/
pparse_details *be_lookup_parser(int ft)
{
    int i;

    if (image_type_test(ft))
	ft = FILETYPE_ANY_IMAGE;

    for(i=0; file_parsers[i].ftype != -1 && file_parsers[i].ftype != ft; i++)
	;

    fprintf(stderr, "Using parser %d for file type 0x%03x\n", i, ft);

    return &file_parsers[i];
}

/*DAF*/
/*DAF*/
static void be_pparse_doc(antweb_doc *doc, int fh, int from, int to)
{
    char buffer[4096];
    os_gbpbstr gpb;
    int len;
    rid_text_item *ti;
    rid_header *rh;

    if (doc->rh == NULL)
	doc->rh = (((pparse_details*)doc->pd)->rh)(doc->ph);

    rh = doc->rh;

    ti = rh->stream.text_last;
#if PP_DEBUG
    fprintf(stderr, "Old last item is 0x%p\n", ti);
#endif
    while (from < to)
    {
	len = (to-from) > sizeof(buffer) ? sizeof(buffer) : (to-from);

	gpb.action = 3;
	gpb.file_handle = fh;
	gpb.data_addr = buffer;
	gpb.number = len;
	gpb.seq_point = from;
#if PP_DEBUG
	fprintf(stderr, "Reading %d bytes from file %d.\n", len, fh);
#endif
	if (os_gbpb(&gpb) == NULL)
	{
#if PP_DEBUG
	    fprintf(stderr, "Sending %d bytes to the parser.\n", len);
#endif
	    (((pparse_details*)doc->pd)->data)(doc->ph, buffer, len, (from + len) < to );
	}

	from += len;
    }

    if (ti == NULL)
    {
	ti = rh->stream.text_list;
#if PP_DEBUG
	fprintf(stderr, "No old value, first item is at 0x%p\n", ti);
#endif
    }
    else
    {
        /* Inefficient but correct - and easy! */
        if (ti->tag != rid_tag_TABLE)
	    /*ti = ti->next;*/
            ti = rid_scanf(ti);
#if PP_DEBUG
	fprintf(stderr, "Moved on from last item to 0x%p\n", ti);
#endif
    }
#if PP_DEBUG
    fprintf(stderr, "Sizing objects from 0x%p\n", ti);
#endif
    while (ti)
    {
	(object_table[ti->tag].size)(ti, rh, doc);

	/*ti = ti->next;*/
        ti = rid_scanf(ti);
    }


#if PP_DEBUG
    fprintf(stderr, "Done sizing\n");
#endif
}

/*DAF*/
/*DAF*/
static void be_doc_fetch_bg(antweb_doc *doc)
{
    char *url;
    url = url_join(BASE(doc), doc->rh->tile.src);

    image_find(url, BASE(doc), 0,
	       &antweb_doc_background_change, doc,
	       (image*) &(doc->rh->tile.im));

    antweb_doc_background_change(doc, doc->rh->tile.im, TRUE);

    mm_free(url);
}

/* This will tend to redraw tables as they are arriving. */
/* It should be okay once the </TABLE> has been processed. */

/*DAF*/
/*DAF*/
static void antweb_doc_progress(void *h, int status, int size, int so_far, int fh, int ftype, char *url)
{
    antweb_doc *doc = (antweb_doc *) h;
    char buffer[256];

    /* Make the world turn a little */
    frontend_view_status(doc->parent, sb_status_WORLD, NULL);

    if (status == doc->lstatus && so_far == doc->lbytes)
	return;

    if (so_far > 0 && ftype != -1 && fh && status == status_GETTING_BODY)
    {
	int lastptr = doc->lbytes;

	if (doc->lstatus != status_GETTING_BODY || lastptr == -1)
	    lastptr = 0;
#if PP_DEBUG
	fprintf(stderr, "Data arriving; type = 0x%03x, file=%d, last had %d, now got %d\n",
		ftype, fh, lastptr, so_far);
#endif
	if (doc->pd == NULL)
	    doc->pd = be_lookup_parser(ftype);

	if (doc->ph == NULL && ((pparse_details*)doc->pd)->new)
	{
#if PP_DEBUG
	    fprintf(stderr, "About to make a new parser stream\n");
#endif
	    doc->ph = (((pparse_details*)doc->pd)->new)(url, ftype);
	    if (doc->ph)
	    {
		if (doc->url == NULL)
		    doc->url = strdup(url);

		doc->rh = (((pparse_details*)doc->pd)->rh)(doc->ph);

		if (doc->rh->stream.text_last)
		{
#if PP_DEBUG
		    fprintf(stderr, "Sizing the first few items...\n");
#endif
		    antweb_document_sizeitems(doc);
#if PP_DEBUG
		    fprintf(stderr, "... done\n");
#endif
		}
	    }
	}

	if (doc->ph)
	{
	    rid_text_item *oti;
	    rid_form_item *ofi;
	    rid_select_item *osi;
	    rid_option_item *ooi;

	    oti = doc->rh->stream.text_last;
	    ofi = doc->rh->form_last;
	    osi = ofi ? ofi->last_select : NULL;
	    ooi = osi ? osi->last_option : NULL;
#if PP_DEBUG
	    fprintf(stderr, "Calling pparse from progress\n");
#endif
	    be_pparse_doc(doc, fh, lastptr, so_far);
#if PP_DEBUG
	    fprintf(stderr, "pparse from progress done\n");
#endif

            /* If the last item is a table, we must still be within the */
            /* table, so redisplaying it probably isn't a bad thing to do */
            /* Once the table is completed, another pad tag will be added */
            /* and we can skip over it as normal */

	    if (oti != doc->rh->stream.text_last ||
                oti->tag == rid_tag_TABLE ||
		ofi != doc->rh->form_last ||
		osi != (ofi ? ofi->last_select : NULL) ||
		ooi != (osi ? osi->last_option : NULL) )
	    {
#if PP_DEBUG
		fprintf(stderr, "Text list seems to have changed.\n");
#endif
		if ((doc->flags & doc_flag_DISPLAYING) == 0)
		{
		    fe_view_dimensions fvd;
		    frontend_view_get_dimensions(doc->parent, &fvd);

		    /* We assume we can use the title here because it is supposed to be
		       in the header and the header is supposed to come before the body. */

		    doc->rh->stream.fwidth = fvd.user_width;

		    antweb_document_format(doc, doc->rh->stream.fwidth);

#if PP_DEBUG || 1
		    fprintf(stderr, "Calling visit\n");
#endif
		    frontend_view_visit(doc->parent, doc, doc->url, doc->rh->title);

		    doc->flags |= doc_flag_DISPLAYING;

		    doc->input = NULL;

		    be_update_image_info(doc);

		    if (frontend_view_has_caret(doc->parent))
			antweb_place_caret(doc);

		    if (doc->rh->bgt & rid_bgt_IMAGE)
		    {
			be_doc_fetch_bg(doc);
		    }
		}
		else
		{
		    wimp_box bb;
		    rid_pos_item *hiline;

		    fprintf(stderr, "Tail changed, chacking for select items\n");
		    fprintf(stderr, "ofi=%p, osi=%p, ooi=%p\n", ofi, osi, ooi);

		    /* We had an option in the last visable select and
		       either the last form no longer has a select or
		       the last select of the last form is not the same */
		    if ((ooi || (osi && osi->last_option)) &&
			((!doc->rh->form_last->last_select) ||
			 (ooi != doc->rh->form_last->last_select->last_option) ) )
		    {
			/* dispose of the item and resize it */
			if (osi && osi->ti && object_table[osi->ti->tag].dispose)
			{
				(object_table[osi->ti->tag].dispose)(osi->ti, doc->rh, doc);
				(object_table[osi->ti->tag].size)(osi->ti, doc->rh, doc);
	                }

			/* Let's make sure we get it right */
			antweb_document_format(doc, doc->rh->stream.fwidth);

			/* Force a major redraw if the item is in or above the visable */
#if 0
			if (oti == NULL)
			    oti = doc->rh->stream.text_list;

			if (oti)
			{
			    hiline = ((oti->line->top > osi->ti->line->top) ?
				      oti->line :
				      osi->ti->line );
			    frontend_view_bounds(doc->parent, &bb);

			    if (hiline->top > bb.y0)
			    {
				bb.y1 = hiline->top;
				frontend_view_redraw(doc->parent, &bb);
			    }
			}
#else
			frontend_view_redraw(doc->parent, NULL);
#endif
		    }
		    else
		    {
#if PP_DEBUG
			fprintf(stderr, "Reformatting the tail\n");
#endif
			be_document_reformat_tail(doc, oti, doc->rh->stream.fwidth);
#if PP_DEBUG
			fprintf(stderr, "Tail reformat done\n");
#endif
		    }
		}

		be_set_dimensions(doc);
	    }
	}
    }

    doc->lstatus = status;
    doc->lbytes = so_far;

    if (status == status_GETTING_BODY || status == status_REQUEST_BODY)
    {
	if (size != -1)
	    sprintf(buffer, "(%d/%d, %d%%)", so_far, size, (so_far * 100) / size);
	else
	    sprintf(buffer, "(%d)", so_far);

	frontend_view_status(doc->parent,
			      status == status_GETTING_BODY ? sb_status_FETCHED : sb_status_SENT,
			      buffer, so_far, size);
    }
    else
    {
	sprintf(buffer, "status%03d", status);

	frontend_view_status(doc->parent, sb_status_PROGRESS, buffer, status);
    }

#if PP_DEBUG
    fprintf(stderr, "Progress done\n");
#endif

}

/*DAF*/
/*DAF*/
static os_error *be_parse_file_to_end(antweb_doc *doc)
{
    os_filestr osf;
    os_error *ep;
    int fsize;
    int fh;
    os_regset r;

    osf.action = 5;
    osf.name = doc->cfile;

    ep = os_file(&osf);

    if (ep)
	return ep;

    fsize = osf.start;

    fprintf(stderr, "Final file size is %d\n", fsize);

    r.r[0] = 0x4f;		/* Make errors rather than give a 0 handle */
    r.r[1] = (int) doc->cfile;

    ep = os_find(&r);
    if (ep)
	return ep;

    fh = r.r[0];
#if PP_DEBUG
    fprintf(stderr, "Opened file on handle %d\n", fh);
#endif
    if (doc->lbytes != fsize)
    {
#if PP_DEBUG
	fprintf(stderr, "Calling pparse from parse_to_end\n");
#endif
	be_pparse_doc(doc, fh, doc->lbytes, fsize);
#if PP_DEBUG
	fprintf(stderr, "pparse from parse_to_end done\n");
#endif
    }
#if PP_DEBUG
    fprintf(stderr, "Closing file %d\n", fh);
#endif
    r.r[0] = 0;
    r.r[1] = fh;

    os_find(&r);
#if PP_DEBUG
    fprintf(stderr, "Closing parser down\n");
#endif
    doc->rh = ((pparse_details*)doc->pd)->close(doc->ph, doc->cfile);
    doc->ph = NULL;
#if PP_DEBUG
    fprintf(stderr, "New rid_header at 0x%p\n", doc->rh);
#endif
    return NULL;
}

/*DAF*/
/*DAF*/
static access_complete_flags antweb_doc_complete(void *h, int status, char *cfile, char *url)
{
    antweb_doc *doc = (antweb_doc *) h;
    int ft;
    char buffer1[12];

    sprintf(buffer1, "status%03d", status);
    frontend_view_status(doc->parent, sb_status_PROGRESS, buffer1, status);

    doc->ah = NULL;

#if 1
    fprintf(stderr, "Access completed, doc=%p, status=%d, file='%s', url='%s'\n",
	    doc, status, cfile, url);
#endif

    if (status != status_COMPLETED_FILE)
    {
	frontend_view_visit(doc->parent, NULL, NULL, NULL);

	backend_dispose_doc(doc);
	return 0;
    }

    doc->cfile = strdup(cfile);
    if (doc->url == NULL)
	doc->url = strdup(url);

#if 1
    fprintf(stderr, "Completed opening %s\n", url);
    fprintf(stderr, "Cache file is '%s'\n", doc->cfile);
#endif


    ft = file_type(cfile);

    if (doc->pd == NULL)
	doc->pd = be_lookup_parser(ft);

    if (doc->ph || ((pparse_details*)doc->pd)->whole)
    {
	os_filestr ofs;
	int need_to_parse = (doc->ph == NULL);

	if (!need_to_parse)
	{
	    rid_text_item *oti;
	    rid_form_item *ofi;
	    rid_select_item *osi;
	    rid_option_item *ooi;

	    oti = doc->rh->stream.text_last;
	    ofi = doc->rh->form_last;
	    osi = ofi ? ofi->last_select : NULL;
	    ooi = osi ? osi->last_option : NULL;

	    be_parse_file_to_end(doc);

	    if (oti &&
		ofi == doc->rh->form_last &&
		osi == (ofi ? ofi->last_select : NULL) &&
		ooi == (osi ? osi->last_option : NULL) )
	    {
		if (oti != doc->rh->stream.text_last)
		    be_document_reformat_tail(doc, oti, doc->rh->stream.fwidth);
	    }
	    else
	    {
		fe_view_dimensions fvd;
		rid_pos_item *hiline;
		wimp_box bb;

		if ((ooi || (osi && osi->last_option)) &&
		    ((!doc->rh->form_last->last_select) ||
		     (ooi != doc->rh->form_last->last_select->last_option) ) )
		{
		    /* dispose of the item and resize it */
		    (object_table[osi->ti->tag].dispose)(osi->ti, doc->rh, doc);
		    (object_table[osi->ti->tag].size)(osi->ti, doc->rh, doc);
    		}

		frontend_view_get_dimensions(doc->parent, &fvd);

		doc->rh->stream.fwidth = fvd.user_width;

		antweb_document_format(doc, doc->rh->stream.fwidth);

		be_set_dimensions(doc);

		if (oti == NULL)
		    oti = doc->rh->stream.text_list;

		if (oti)
		{
		    hiline = ((ooi == NULL ||
			       oti->line->top > osi->ti->line->top) ?
			      oti->line :
			      osi->ti->line );
		    frontend_view_bounds(doc->parent, &bb);

		    if (hiline->top > bb.y0)
		    {
			bb.y1 = hiline->top;
			frontend_view_redraw(doc->parent, &bb);
		    }
		}
	    }
	}

	else
	    doc->rh = ((pparse_details*)doc->pd)->whole(doc->cfile, doc->url);

	ofs.action = 5;
	ofs.name = doc->cfile;

	os_file(&ofs);

	doc->file_load_addr = ofs.loadaddr;
	doc->file_exec_addr = ofs.execaddr;
	doc->file_size = ofs.start;

	if ((doc->flags & doc_flag_DISPLAYING) == 0)
	{
	    frontend_view_visit(doc->parent, doc, doc->url, doc->rh->title);

	    doc->flags |= doc_flag_DISPLAYING;

	    if (need_to_parse)	/* If we parsed on the way we sized then too. */
	    {
		fe_view_dimensions fvd;
		frontend_view_get_dimensions(doc->parent, &fvd);

		doc->rh->stream.fwidth = fvd.user_width;

		antweb_document_sizeitems(doc);
		antweb_document_format(doc, doc->rh->stream.fwidth);
	    }
	}

        /* SJM: layout frames */
        if (doc->rh->frames)
        {
            fe_view_dimensions fvd;
            frontend_view_get_dimensions(doc->parent, &fvd);

            layout_layout(doc, fvd.layout_width, fvd.layout_height, 0);

            doc->rh->stream.widest = fvd.wa_width;
            doc->rh->stream.height = fvd.wa_height;
        }

        /* SJM: check the images for external client-side imagemaps */
        frontend_complain(imagemap_check_all_images(doc));

        /* SJM: see if width changes and reformat */
        be_set_dimensions(doc);

	be_update_image_info(doc);

	if ((doc->rh->bgt & rid_bgt_IMAGE) && (doc->rh->tile.im == NULL))
	{
	    be_doc_fetch_bg(doc);
	}

        /* SJM: only place caret in input if not in keyboard mode */
	if (doc->rh->form_list && config_mode_keyboard == 0)
	{
	    rid_text_item *ti;

	    ti = antweb_next_text_input(doc->rh->stream.text_list, doc);

	    doc->input = ti;
	}
	else
	{
	    doc->input = NULL;
	}

	if (frontend_view_has_caret(doc->parent))
	{
	    doc->text_input_offset = -1;
	    antweb_place_caret(doc);
	}

	/* Override the visability of the caret */
	frontend_complain(backend_goto_fragment(doc, doc->frag));

	if (doc->rh->refreshtime != -1)
	    alarm_set(alarm_timenow()+(doc->rh->refreshtime * 100), be_refresh_document, doc);
    }
    else
    {
#if 1
	fprintf(stderr, "Got document of type 0x%03x, passing to the front end.\n", ft);
#endif
	frontend_pass_doc(doc->parent, doc->url, cfile, ft);
	backend_dispose_doc(doc);
    }

#if 1
    fprintf(stderr, "'Compleated' function done.\n");
#endif

    return access_CACHE;
}

/*DAF*/
/*DAF*/
os_error *backend_doc_abort(be_doc doc)
{
    if ((doc->flags & doc_flag_DISPLAYING) == 0)
	return NULL;

    if (doc->ah)
    {
#if 1
	fprintf(stderr, "Calling access_abort\n");
#endif
	access_abort(doc->ah);
	doc->ah = NULL;

	doc->flags |= doc_flag_INCOMPLETE;
    }

    if (doc->ph)
    {
	doc->rh = ((pparse_details*)doc->pd)->close(doc->ph, NULL);
	doc->ph = NULL;

	doc->flags |= doc_flag_INCOMPLETE;
    }

    if (doc->flags & doc_flag_INCOMPLETE)
	frontend_view_status(doc->parent, sb_status_PROGRESS, "aborted", sb_status_PROGRESS_ABORTED);

    return NULL;
}

/*DAF*/
/*DAF*/
extern os_error *backend_doc_set_flags(be_doc doc, int mask, int eor)
{
    if (mask & be_openurl_flag_ANTIALIAS)
	doc->flags &= ~doc_flag_ANTIALIAS;

    if (mask & be_openurl_flag_BODY_COLOURS)
	doc->flags &= ~doc_flag_DOC_COLOURS;

    if (mask & be_openurl_flag_DEFER_IMAGES)
	doc->flags &= ~doc_flag_DEFER_IMAGES;

    if (eor & be_openurl_flag_ANTIALIAS)
	doc->flags ^= doc_flag_ANTIALIAS;

    if (eor & be_openurl_flag_BODY_COLOURS)
	doc->flags ^= doc_flag_DOC_COLOURS;

    if (eor & be_openurl_flag_DEFER_IMAGES)
	doc->flags ^= doc_flag_DEFER_IMAGES;

    return NULL;
}

/*DAF*/
/*DAF*/
static void be_refresh_document(int at, void *h)
{
    be_doc doc = (be_doc) h;

    if (doc->url || doc->rh->refreshurl)
    {
	char *url = url_join(BASE(doc), doc->rh->refreshurl ? doc->rh->refreshurl : doc->url);
	frontend_complain(frontend_open_url(url, doc->parent, NULL, NULL, 1));
	mm_free(url);
    }
}

/*DAF*/
/*DAF*/
extern os_error *backend_open_url(fe_view v, be_doc *docp,
				  char *url, char *bfile, char *referer,
				  int flags)
{
    antweb_doc *new;
    os_error *ep;
    char *use_url;
    char *frag;

    *docp = new = mm_calloc(1, sizeof(antweb_doc));

    new->magic = ANTWEB_DOC_MAGIC;
    new->parent = v;

    if (config_display_links_underlined)
	new->flags |= doc_flag_UL_LINKS;

    if (flags & be_openurl_flag_ANTIALIAS)
	new->flags |= doc_flag_ANTIALIAS;

    if (flags & be_openurl_flag_BODY_COLOURS)
	new->flags |= doc_flag_DOC_COLOURS;

    if (flags & be_openurl_flag_DEFER_IMAGES)
	new->flags |= doc_flag_DEFER_IMAGES;

    use_url = strdup(url);
    if ( (frag = strrchr(use_url, '#')) != 0)
    {
	*frag = 0;
	new->frag = strdup(frag+1);
    }

#if 1
    fprintf(stderr, "Calling access function\n");
#endif

    ep = access_url(use_url, (flags & be_openurl_flag_NOCACHE) ? access_NOCACHE : 0,
		    NULL, bfile, referer,
		    &antweb_doc_progress, &antweb_doc_complete, new, &new->ah);

    mm_free(use_url);

    if (ep == 0)
    {
	frontend_view_status(v, sb_status_URL, url);
	if (new->ah == NULL)
	    frontend_view_status(v, sb_status_PROGRESS, "fromcch", sb_status_PROGRESS_LOCAL);
#if 1
	else
	    fprintf(stderr, "New access handle is 0x%p\n", new->ah);
#endif
    }
    else
    {
	if (ep->errnum == (ANTWEB_ERROR_BASE + ERR_USED_HELPER) )
	{
	    frontend_view_status(v, sb_status_HELPER, NULL);
	    ep = 0;
	}

	*docp = NULL;

	mm_free(new);
    }

    return ep;
}

/*DAF*/
/*DAF*/
BOOL backend_doc_saver_text(char *fname, void *h)
{
    be_doc doc = (be_doc) h;
    rid_header *rh = doc->rh;
    rid_pos_item *pi;
    rid_text_item *ti;
    FILE *f;

    f = fopen(fname, "w");
    if (f == NULL)
	return FALSE;

    for(pi = rh->stream.pos_list ; pi; pi = pi->next)
    {
	if (pi->first->st.indent)
	{
	    int i;
	    for (i=0; i < pi->first->st.indent; i++)
	    {
		fputc(' ', f);
	    }
	}

	for (ti = pi->first; ti && ti != pi->next->first; ti = rid_scanf(ti) /*ti->next*/ )
	{
            /* Table recurses to do cells - presentation not yet finalised! */
	    (object_table[ti->tag].astext)(ti, rh, f);
	}
	fputc('\n', f);
    }

    fclose(f);

    frontend_saver_last_name(fname);

    return TRUE;
}

/*DAF*/
/*DAF*/
BOOL backend_doc_saver_draw(char *fname, void *h)
{
    return drawfile_doc_saver_draw(fname, (be_doc) h);
}

/*DAF*/
/*DAF*/
BOOL backend_image_saver_sprite(char *fname, void *h)
{
    image im = (image) h;
    int OK;

    OK = (frontend_complain(image_save_as_sprite(im, fname)) == NULL);

    if (OK)
	frontend_saver_last_name(fname);

    return OK;
}

/*DAF*/
/*DAF*/
os_error *backend_doc_key(be_doc doc, int key, int *used)
{
    rid_text_item *ti = doc->input;

    *used = 0;

    if (ti && object_table[ti->tag].key)
    {
	*used = (object_table[ti->tag].key)(ti, doc->rh, doc, key);
	/* This is expected to do the redraw if needed */
    }

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_doc_cursor(be_doc doc, int motion, int *used)
{
    int redraw = FALSE;
    rid_text_item *ti = doc->input;
    rid_text_item *also_redraw = NULL;
    int old_offset = doc->text_input_offset;

    doc->text_input_offset = -1;

    *used = 0;

    if (ti == NULL)
	return NULL;

    redraw = TRUE;		/* The default case negates this if we don't use the key */
    also_redraw = ti;
    switch (motion)
    {
    case be_cursor_UP:
    case (be_cursor_UP | be_cursor_WRAP):
	/*ti = antweb_prev_text_item(ti);*/
        ti = rid_scanbr(ti);
        ti = antweb_prev_text_input(ti, doc);
	if (ti)
	{
	    break;
	}
	if (motion == 0)
	{
	    ti = doc->input;
	    redraw=FALSE;
	    break;
	}
	/* Otherwise fall through */
    case (be_cursor_DOWN | be_cursor_LIMIT):
	ti = antweb_prev_text_input(doc->rh->stream.text_last, doc);
	break;

    case be_cursor_DOWN:
    case (be_cursor_DOWN | be_cursor_WRAP):
	/*ti = ti->next;*/
        ti = rid_scanfr(ti);
	ti = antweb_next_text_input(ti, doc);
	if (ti)
	{
	    break;
	}
	if (motion == be_cursor_DOWN)
	{
	    ti = doc->input;
	    redraw=FALSE;
	    break;
	}
	/* Otherwise fall through */
    case (be_cursor_UP | be_cursor_LIMIT):
	ti = antweb_next_text_input(doc->rh->stream.text_list, doc);
	break;

    default:
	redraw=FALSE;
	also_redraw = NULL;
	break;
    }

    if (ti != doc->input)
    {
	doc->input = ti;
    }
    else
    {
	doc->text_input_offset = old_offset;
    }

    if (redraw)
    {
	antweb_update_item(doc, doc->input);

	if (also_redraw && also_redraw != doc->input)
	    antweb_update_item(doc, also_redraw);

	*used = TRUE;
    }

    return NULL;
}

/*DAF*/
/*DAF*/
os_error *backend_doc_images(be_doc doc, int *waiting, int *fetching, int *fetched, int *errors, int* in_trans, int *so_far)
{
    *waiting = doc->im_unfetched;
    *fetching = doc->im_fetching;
    *fetched = doc->im_fetched;
    *errors = doc->im_error;
    *in_trans = doc->im_in_transit;
    *so_far = doc->im_so_far;

    return NULL;
}

static int adjust_flag(int new_flag, int select)
{
    switch (select)
    {
        case -1:
            new_flag ^= rid_flag_SELECTED;
            break;
        case 1:
            new_flag |= rid_flag_SELECTED;
            break;
        case 0:
            new_flag &= ~rid_flag_SELECTED;
            break;
    }
    return new_flag;
}

static void be_update_item_highlight(be_doc doc, be_item ti)
{
    if (object_table[ti->tag].update_highlight)
        object_table[ti->tag].update_highlight(ti, doc);
    else
        antweb_update_item(doc, ti);
}

/*
 * if selected is -1 then it toggles the state of the selected bit
 */

void backend_update_link(be_doc doc, be_item item, int selected)
{
    be_item ti;

    if (item == NULL)
        return;

    /* if it isn't actually a link then toggle the flag anyway */
    if (item->aref == NULL)
    {
        item->flag = adjust_flag(item->flag, selected);
        be_update_item_highlight(doc, item);
        return;
    }

#if 0
    fprintf(stderr, "Aref to %s updating\n", item->aref->href);
#endif

    for (ti = item->aref->first; ti && ti->aref == item->aref; ti = rid_scanfr(ti))
    {
        ti->flag = adjust_flag(ti->flag, selected);
        be_update_item_highlight(doc, ti);
    }
}

static BOOL be_item_onscreen(be_doc doc, be_item ti, const wimp_box *bounds, int flags)
{
    wimp_box box;
    backend_doc_item_bbox(doc, ti, &box);
#if 0
    if (
       ((box.y1 > bounds->y0 && box.y1 <= bounds->y1) ||
        (box.y0 >= bounds->y0 && box.y0 < bounds->y1)) &&

       ((box.x1 > bounds->x0 && box.x1 <= bounds->x1) ||
        (box.x0 >= bounds->x0 && box.x0 < bounds->x1))
        )
        return TRUE;
#else
    if (flags & be_link_BACK)
    {
        if (box.y0 >= bounds->y0 && box.y0 < bounds->y1)
            return TRUE;
    }
    else
    {
        if (box.y1 > bounds->y0 && box.y1 <= bounds->y1)
            return TRUE;
    }
#endif
    return FALSE;
}


be_item backend_highlight_link(be_doc doc, be_item item, int flags)
{
    rid_aref_item *aref;
    be_item ti;
    wimp_box bounds, margins;
    const int scan_flags = SCAN_RECURSE | ( (flags & be_link_BACK) ? SCAN_BACK : SCAN_FWD );

#if 0
    fprintf(stderr, "Highlight from item %p, flags=0x%x\n", item, flags);
#endif

    if (item == NULL)
    {
	ti = (flags & be_link_BACK) ? doc->rh->stream.text_last : doc->rh->stream.text_list;
	aref = NULL;
    }
    else
    {
        if (flags & be_link_INCLUDE_CURRENT)
            ti = item;
        else
            ti = rid_scan(item, scan_flags);

	aref = item->aref;
    }

#if 0
    fprintf(stderr, "Start search at %p, aref=%p\n", ti, aref);
#endif

    frontend_view_bounds(doc->parent, &bounds);
    frontend_view_margins(doc->parent, &margins);
    bounds.x0 += margins.x0;
    bounds.y0 += margins.y0;
    bounds.x1 += margins.x1;
    bounds.y1 += margins.y1;

    while (ti)
    {
	if ((ti->tag == rid_tag_INPUT) ||
	    (ti->tag == rid_tag_TEXTAREA) ||
	    (ti->tag == rid_tag_SELECT) ||
	    (ti->tag == rid_tag_IMAGE && ((rid_text_item_image *)ti)->usemap) ||
	    (ti->aref && ti->aref->href && (ti->aref != aref || (flags & be_link_INCLUDE_CURRENT))) )
	{
	    if ((flags & be_link_VISIBLE) == 0 || be_item_onscreen(doc, ti, &bounds, flags))
	        break;
	}

        ti = rid_scan(ti, scan_flags);

#if 0
	fprintf(stderr, "ti=%p\n", ti);
#endif
    }

    if (ti == NULL && (flags & be_link_DONT_WRAP) == 0)
    {
	ti = (flags & be_link_BACK) ? doc->rh->stream.text_last : doc->rh->stream.text_list;

#if 0
	fprintf(stderr, "No link found, ti wraped to %p\n", ti);
#endif

	while (ti)
	{
	    if ((ti->tag == rid_tag_INPUT) ||
		(ti->tag == rid_tag_TEXTAREA) ||
		(ti->tag == rid_tag_SELECT) ||
	        (ti->tag == rid_tag_IMAGE && ((rid_text_item_image *)ti)->usemap) ||
		(ti->aref && ti->aref->href) )
            {
	        if ((flags & be_link_VISIBLE) == 0 || be_item_onscreen(doc, ti, &bounds, flags))
	            break;
            }

            ti = rid_scan(ti, scan_flags);
#if 0
	    fprintf(stderr, "ti=%p\n", ti);
#endif
	}
    }

    if ((flags & be_link_DONT_HIGHLIGHT) == 0)
    {
        /* de highlight original only if the highlight has ended up changing */
        if (item != ti && item)
            backend_update_link(doc, item, 0);

        if (ti)
        {
	    int x, y;

#if 0
	    fprintf(stderr, "New link at %p\n", ti);
#endif

	    if ((flags & be_link_VISIBLE) == 0 && antweb_locate_item(ti, &x, &y))
	        frontend_view_ensure_visable(doc->parent, x, y + ti->max_up, y - ti->max_down);

            if (item != ti)
                backend_update_link(doc, ti, 1);
        }
    }

#if 0
    fprintf(stderr, "About to return %p\n", ti);
#endif

    return ti;
}

os_error *backend_activate_link(be_doc doc, be_item item, int flags)
{
    int x, y;

    if (antweb_locate_item(item, &x, &y))
    {
        if (item->tag == rid_tag_INPUT)
            x += item->width;

	return backend_doc_click(doc, x, y, (flags & 1) ? wimp_BRIGHT : wimp_BLEFT );
    }
    else
	return NULL;
}

be_item backend_place_caret(be_doc doc, be_item item)
{
    be_item input = doc->input;
    doc->input = item;
    antweb_place_caret(doc);
    return input;
}

/* veneers onto access.c functions */

char *backend_temp_file_name(void)
{
    return access_scrapfile();
}

void backend_temp_file_register(char *url, char *file_name)
{
    access_insert(url, file_name, cache_flag_OURS);
}

const char *backend_check_meta(be_doc doc, const char *name)
{
    rid_meta_item *m;
    for (m = doc->rh->meta_list; m; m = m->next)
    {
        if ((m->name && strcasecomp(m->name, name) == 0) ||
            (m->httpequiv && strcasecomp(m->httpequiv, name) == 0))
            return m->content;
    }
    return NULL;
}

void backend_select_item(be_doc doc, be_item item, int select)
{
    int new_flag;

    /* alter the selection state of this item */
    new_flag = adjust_flag(item->flag, select);

    /* if the new item ends up selected then deselect everything else in the document */
    if (new_flag & rid_flag_SELECTED)
    {
	be_item ti = doc->rh->stream.text_list;
	while (ti)
	{
            if (ti->flag & rid_flag_SELECTED)
            {
                ti->flag &= ~rid_flag_SELECTED;
                be_update_item_highlight(doc, ti);
            }

            ti = rid_scan(ti, SCAN_RECURSE | SCAN_FWD);
	}
    }

    /* update the new item */
    item->flag = new_flag;
    be_update_item_highlight(doc, item);
}

be_item backend_find_selected(be_doc doc)
{
    be_item ti = doc->rh->stream.text_list;
    while (ti)
    {
        if (ti->flag & rid_flag_SELECTED)
            break;

        ti = rid_scan(ti, SCAN_RECURSE | SCAN_FWD);
    }
    return ti;
}

int backend_frame_resize_bounds(be_doc doc, int x, int y, wimp_box *box, int *handle)
{
    return layout_frame_resize_bounds(doc, x, y, box, handle);
}

void backend_frame_resize(be_doc doc, int x, int y, int handle)
{
    layout_frame_resize(doc, x, y, handle);
}

/* eof backend.c */
