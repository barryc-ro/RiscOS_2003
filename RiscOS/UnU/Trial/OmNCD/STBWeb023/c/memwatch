/* -*-c-*- */

/* memwatch.c */

/* 27/3/96: SJM: Change wimp_reporterror to frontend calls
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "assert.h"

#include "wimp.h"
#include "msgs.h"

#include "verstring.h"
#include "makeerror.h"

#include "images.h"

#include "unwind.h"
#include "interface.h"

#undef MEMWATCH

#ifndef MEMWATCH
#define MEMWATCH 1
#endif

/* Zero memory on freeing */
#ifndef MEMZERO
#define MEMZERO 0
#endif

char *none="<none>";

static os_error panicerr;

int mm_no_more_memory(void)
{
    strcpy(panicerr.errmess, msgs_lookup("memfatal"));
    panicerr.errnum = 0;

    frontend_fatal_error(&panicerr);
    exit(1);
    return 0;
}

int mm_can_we_recover(void)
{
    int r;

    r = image_memory_panic();

    if (r == 0)
    {
	return mm_no_more_memory();
    }

    strcpy(panicerr.errmess, msgs_lookup("memlow"));
    panicerr.errnum = 0;

//    wimp_reporterror(&panicerr, (wimp_errflags) (1<<4), program_name);
    frontend_complain(&panicerr);

    return r;
}

#if MEMWATCH >= 2

typedef struct mm_chain {
    struct mm_chain *next, *prev;
    int size;
    int magic;
    char *caller;
    char *caller2;
} mm_chain;

typedef struct {
    int magic;
} mm_tail;

#define RND(x) (((x)+3)&(~3))

#define MM_TAIL(m) (mm_tail *) (((char *) ((m)+1))+ RND((m)->size) );

#define MM_MAGIC_HEAD	0x563482fb
#define MM_MAGIC_TAIL	0x324dc839

static mm_chain *mm_first = NULL, *mm_last = NULL;

static void mm_link(mm_chain *m)
{
#if MEMWATCH >= 4
    fprintf(stderr, "mm_link: item at %p\n", m);
#endif
    if (mm_first)
    {
	m->prev = mm_last;
	m->next = NULL;
	mm_last->next = m;
	mm_last = m;
    }
    else
    {
	mm_first = mm_last = m;
	m->prev = m->next = 0;
    }
}

static void mm_unlink(mm_chain *m)
{
#if MEMWATCH >= 4
    fprintf(stderr, "mm_unlink: item at %p\n", m);
#endif
    if (m->prev)
	m->prev->next = m->next;
    else
	mm_first = m->next;

    if (m->next)
	m->next->prev = m->prev;
    else
	mm_last = m->prev;
}

void *mm_malloc(size_t x)
{
    mm_chain *new;
    mm_tail *tail;

#if MEMWATCH >= 3
    fprintf(stderr, "mm_malloc: item size 0x%x\n", x);
#endif
    new = malloc(x + sizeof(mm_chain) + sizeof(mm_tail));

    if (new == NULL)
	return NULL;

    new->size = x;
    new->magic = MM_MAGIC_HEAD;
#if MEMWATCH >= 4
    fprintf(stderr, "about to call caller()\n");
#endif
    new->caller = caller(1);
    new->caller2 = caller(2);

#if MEMWATCH >= 4
    fprintf(stderr, "caller() called\n");
#endif
    tail = MM_TAIL(new);
    tail->magic = MM_MAGIC_TAIL;

    mm_link(new);

    return (void*)(new+1);
}

void *mm_calloc(size_t x, size_t y)
{
    int size;
    mm_chain *new;
    mm_tail *tail;

    size = x * y;

#if MEMWATCH >= 3
    fprintf(stderr, "mm_calloc: item size 0x%x\n", size);
#endif
    new = calloc(1, size + sizeof(mm_chain) + sizeof(mm_tail));

    if (new == NULL)
	return NULL;

    new->size = size;
    new->magic = MM_MAGIC_HEAD;

#if MEMWATCH >= 4
    fprintf(stderr, "about to call caller()\n");
#endif
    new->caller = caller(1);
    new->caller2 = caller(2);

#if MEMWATCH >= 4
    fprintf(stderr, "caller() called\n");
#endif
    tail = MM_TAIL(new);
    tail->magic = MM_MAGIC_TAIL;

    mm_link(new);

    return (void*)(new+1);
}

void *mm_realloc(void *x, size_t y)
{
    mm_chain *m = ((mm_chain *) x)-1;
    mm_tail *tail;

#if MEMWATCH >= 3
    fprintf(stderr, "mm_realloc: item at %p, old size 0x%x, new size 0x%x, %s %s\n", x, m->size, y, caller(1), caller(2));
#endif

    tail = MM_TAIL(m);

    assert(m->magic == MM_MAGIC_HEAD);
    assert(tail->magic == MM_MAGIC_TAIL);

    mm_unlink(m);

    tail = MM_TAIL(m);
    tail->magic = 0;

#if MEMZERO
#error Realloc does not zero memory
#else
    m = realloc(m, y + sizeof(mm_chain) + sizeof(mm_tail));
#endif
    if (m == NULL)
	return NULL;

    m->size = y;

    tail = MM_TAIL(m);
    tail->magic = MM_MAGIC_TAIL;

    mm_link(m);

    return (void*) (m+1);
}

void mm_free(void *x)
{
    mm_chain *m;
    mm_tail *tail;

    if (x == NULL)
	return;

    m = ((mm_chain *) x)-1;

#if MEMWATCH >= 3
    fprintf(stderr, "mm_free: item at %p\n", x);
#endif
    tail = MM_TAIL(m);

    if ((m->magic != MM_MAGIC_HEAD) || (tail->magic != MM_MAGIC_TAIL))
    {
	int i;
	char *fnp;

	fprintf(stderr, "Problem freeing block at 0x%p, hmagic=0x%08x, tmagic=0x%08x\n",
		m, m->magic, tail->magic);

	i = 1;
	do
	{
	    fnp = caller(i);
	    if (fnp)
		fprintf(stderr, "mm_free caller(%d)='%s'\n", i, fnp);
	    i++;
	} while (fnp);
    }

    assert(m->magic == MM_MAGIC_HEAD);
    assert(tail->magic == MM_MAGIC_TAIL);

    m->magic = 0;
    tail->magic = 0;

    mm_unlink(m);
#if MEMZERO
    memset(m, 0, m->size + sizeof(mm_chain) + sizeof(mm_tail)));
#endif
    free(m);
}

void mm_ckeck(void)
{
    mm_chain *m, *m_last = NULL;
    mm_tail *t;
    int err = 0;

    for(m = mm_first; m; m = m->next)
    {
	if (m->magic != MM_MAGIC_HEAD)
	{
	    fprintf(stderr, "Bad magic number on head of item at %p\n", m);
	    err = 1;
	}

	t = MM_TAIL(m);

	if (t->magic != MM_MAGIC_TAIL)
	{
	    fprintf(stderr, "Bad magic number on tail of item at %p\n", m);
	    err = 1;
	}

	m_last = m;
    }

    if (m_last != mm_last)
    {
	fprintf(stderr, "Memory chain ends do not match up (%p != %p)\n", m_last, mm_last);
	err = 1;
    }

    if (err == 0)
    {
	fprintf(stderr, "Memory checks OK\n");
    }
}

void mm_summary(void)
{
}

void mm_dump(void)
{
    mm_chain *m, *m_last = NULL;
    mm_tail *t;
    int err = 0;

    for(m = mm_first; m; m = m->next)
    {
	if (m->magic != MM_MAGIC_HEAD)
	{
	    fprintf(stderr, "Bad magic number on head of item at %p\n", m);
	    err = 1;
	}

	t = MM_TAIL(m);

	if (t->magic != MM_MAGIC_TAIL)
	{
	    fprintf(stderr, "Bad magic number on tail of item at %p\n", m);
	    err = 1;
	}

	fprintf(stderr, "Block at 0x%08p, size=%6d, caller='%s', caller2='%s'\n",
		m, m->size, m->caller ? m->caller : none, m->caller2 ? m->caller2 : none);

	m_last = m;
    }

    if (m_last != mm_last)
    {
	fprintf(stderr, "Memory chain ends do not match up (%p != %p)\n", m_last, mm_last);
	err = 1;
    }

    if (err == 0)
    {
	fprintf(stderr, "Memory checks OK\n");
    }
}

#else

void *mm_malloc(size_t x)
{
    void *p;
    p=malloc(x);
    if (p)
	return p;

    mm_can_we_recover();

    p=malloc(x);
    if (p)
	return p;

    mm_no_more_memory();

    return NULL;
}

void *mm_calloc(size_t x, size_t y)
{
    void *p;
    p=calloc(x, y);
    if (p)
	return p;

    mm_can_we_recover();

    p=calloc(x, y);
    if (p)
	return p;

    mm_no_more_memory();

    return NULL;
}

void *mm_realloc(void *x, size_t y)
{
    void *p;
    p=realloc(x, y);
    if (p)
	return p;

    mm_can_we_recover();

    p=realloc(x, y);
    if (p)
	return p;

    mm_no_more_memory();

    return NULL;
}

void mm_free(void *x)
{
    free(x);
}

void mm_dump(void)
{
    fprintf(stderr, "Memwatch compiled at too low a level for mm_dump to do anything.\n");
}

void mm_summary(void)
{
    fprintf(stderr, "Memwatch compiled at too low a level for mm_summary to do anything.\n");
}

void mm_ckeck(void)
{
    fprintf(stderr, "Memwatch compiled at too low a level for mm_ckeck to do anything.\n");
}

#endif
