/* -*-c-*- */

/* obullet.c */

/*
 * 21/3/96: SJM: obullet_size comes from indent.h, bullet character from BULLET_CHAR
 */

/* Methods for bullet objects */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "wimp.h"
#include "drawftypes.h"

#include "interface.h"
#include "antweb.h"
#include "rid.h"
#include "webfonts.h"
#include "consts.h"
#include "config.h"
#include "render.h"
#include "rcolours.h"

#include "dfsupport.h"
#include "object.h"

#include "indent.h"

#ifndef BULLET_CHAR
#define BULLET_CHAR 0x8F
#endif

void obullet_size(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
    webfont *wf = &webfonts[ti->st.wf_index];

    /* Width comes from preformatted size */
    ti->width = INDENT_WIDTH*INDENT_UNIT;
    ti->pad = 0;
    /* Height and deapth come from the real font */
    ti->max_up = wf->max_up;
    ti->max_down = wf->max_down;
}

void obullet_redraw(rid_text_item *ti, rid_header *rh, antweb_doc *doc, int hpos, int bline, object_font_state *fs, wimp_box *g, int ox, int oy)
{
    char buffer[8];
    int tfc;
    font_string fstr;
    rid_text_item_bullet *tib = (rid_text_item_bullet*) ti;

    if (tib->list_no != 0)
	sprintf(buffer, "%d) ", tib->list_no);
    else
    {
	buffer[0] = BULLET_CHAR;
	buffer[1] = ' ';
	buffer[2] = 0;
    }

    if (fs->lf != webfonts[ti->st.wf_index].handle)
    {
	fs->lf = webfonts[ti->st.wf_index].handle;
	font_setfont(fs->lf);
    }

    fstr.x = 1 << 30;
    fstr.y = 1 << 30;
    fstr.split = -1;

    fstr.term = strlen(buffer);
    fstr.s = buffer;
    font_strwidth(&fstr);

    if (fs->lfc != (tfc = render_link_colour(ti, doc)) )
    {
	fs->lfc = tfc;
	render_set_font_colours(tfc, render_colour_BACK, doc);
    }
    font_paint(buffer, font_OSCOORDS + (config_display_blending ? 0x800 : 0),
	       hpos + ti->width - (fstr.x / MILIPOINTS_PER_OSUNIT), bline);

}

#if 0
void obullet_dispose(rid_text_item *ti, rid_header *rh, antweb_doc *doc)
{
}

char *obullet_click(rid_text_item *ti, rid_header *rh, antweb_doc *doc, wimp_mousestr *m)
{
    return "";			/* Follow links, no fuss at all */
}
#endif

void obullet_astext(rid_text_item *ti, rid_header *rh, FILE *f)
{
    rid_text_item_bullet *tib = (rid_text_item_bullet*) ti;

    if (tib->list_no == 0)
	fputs("      * ", f);
    else
    {
	char buffer[16];
	sprintf(buffer, "%6d) ", tib->list_no);
	buffer[4] = 0;
	fputs(buffer, f);
    }
}

void obullet_asdraw(rid_text_item *ti, antweb_doc *doc, int fh,
		  int x, int y, int *fileoff, wimp_box *bb)
{
    char buffer[8];
    rid_text_item_bullet *tib = (rid_text_item_bullet*) ti;
    draw_textstrhdr txt;
    int len;
    draw_textstyle dts = {0};
    int size;
    wimp_box tb;
    font_string fstr;
    int hp;

    if (tib->list_no != 0)
	sprintf(buffer, "%d) ", tib->list_no);
    else
    {
	buffer[0] = BULLET_CHAR;
	buffer[1] = ' ';
	buffer[2] = 0;
    }

    for (len = strlen(buffer); len < 8; len++)
	buffer[len] = 0;

    font_setfont(webfonts[ti->st.wf_index].handle);

    fstr.x = 1 << 30;
    fstr.y = 1 << 30;
    fstr.split = -1;

    fstr.term = strlen(buffer);
    fstr.s = buffer;
    font_strwidth(&fstr);

    size = (ti->st.wf_index & WEBFONT_SIZE_MASK) >> WEBFONT_SIZE_SHIFT;
    size = config_font_sizes[size];
    size *= 640;

    hp = x + ti->width - (fstr.x / MILIPOINTS_PER_OSUNIT);

    txt.tag = draw_OBJTEXT;
    txt.size = sizeof(txt) + len;
    txt.bbox.x0 = hp << 8;
    txt.bbox.y0 = (y - ti->max_down) << 8;
    txt.bbox.x1 = (x + ti->width) << 8;
    txt.bbox.y1 = (y + ti->max_up) << 8;
    txt.textcolour = (int) render_get_colour(render_link_colour(ti, doc), doc).word;
    txt.background = (int) render_get_colour(render_colour_BACK, doc).word;
    dts.fontref = (ti->st.wf_index & ((1 << WEBFONT_SIZE_SHIFT) - 1)) + 1;
    txt.textstyle = dts;
    txt.fsizex = size;
    txt.fsizey = size;
    txt.coord.x = hp << 8;
    txt.coord.y = y << 8;

    tb.x0 = txt.bbox.x0 >> 8;
    tb.y0 = txt.bbox.y0 >> 8;
    tb.x1 = txt.bbox.x1 >> 8;
    tb.y1 = txt.bbox.y1 >> 8;

    df_stretch_bb(bb, &tb);

    df_write_data(fh, *fileoff, &txt, sizeof(txt));
    *fileoff += sizeof(txt);
    df_write_data(fh, *fileoff, buffer, len);
    *fileoff += len;
}
