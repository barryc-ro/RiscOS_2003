/*	COMMANDS

Purpose : Command processors for RISC OS NFS

History :
Date	Who    Comments
-----------------------------------------------------------------------------

10/02/95  CP   Added code to pint out network accesses
23/02/95  KSR  Added nfs_boot() function
***************************************************************************/

#ifndef __NFSNFS_H
#include "NFS.h"
#endif

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif

/*
        Select NFS for a *NFS command
*/
_kernel_oserror *command_nfs
(
        char *arg_string,
        int argc
)
{
        _kernel_swi_regs r;

        arg_string = arg_string;
        argc = argc;

        r.r[0] = FSControl_SelectFilingSystem;
        r.r[1] = (int)NFSFilingSystemName;

        return _kernel_swi( XOS_Bit | OS_FSControl, &r, &r );
}

/*
        Encrypt a string for name checking
*/
static char *encryptstring
(
        char *string
)
{
        char *result = malloc( strlen( string ) + 1 );
        int i;

        if ( result )
        {
                for ( i = 0;
                        string[ i ];
                        i++ )
                {
                        result[ i ] = string[ i ] ^ 0x5b;
                }
                result[ i ] = '\0';
        }

        return result;
}

/*
        Switch to given user with password
*/
_kernel_oserror *process_nfsname
(
        char *username,
        char *password
)
{
        AUTH *authorisation;
        _kernel_oserror *err;
        auth_args aargs;
        auth_results *ares;
        unused_client *pcnfsd_client;
        char machname[MAX_MACHINE_NAME + 1];
        int len;
        int gids[NGRPS];

        /*
                Is the user nobody?
        */
        if ( caseless_strcmp( username, User_Nobody ) == 0 )
        {
                err = new_user(
                        &current_user,
                        User_Nobody,
                        NULL,
                        UNIX_MagicNumber_UID_Nobody,
                        UNIX_MagicNumber_GID_Nobody,
                        authunix_create_default() );
                return err;
        }

        /*
                The user isn't nobody, so we jolly well aught to have a host
        */
        if ( current_nameing_host == NULL )
        {
                return &mb_no_nameing_host;
        }

        /*
                No password, so assume empty string
        */
        if ( password == NULL )
        {
                password = "";
        }

        err = get_pcnfsd_client_for_host( &pcnfsd_client, current_nameing_host );
        if ( err )
                return err;

        aargs.aa_ident = encryptstring( username );
        aargs.aa_password = encryptstring( password );

        ares = pcnfsd_auth_1( &aargs, pcnfsd_client->client );

        free( aargs.aa_ident );
        free( aargs.aa_password );

        if ( ares )
        {
                release_client( pcnfsd_client );

                switch( ares->ar_stat )
                {
                case AUTH_RES_OK:
                        /* do nothing */
                        break;

                case AUTH_RES_FAKE:
                        return &mb_authorisation_failed;
                        break;
                default:
                case AUTH_RES_FAIL:
                        return &mb_authorisation_failed;
                        break;
                }
        }
        else
        {
                _kernel_oserror *err = (_kernel_oserror *)return_buffer;

                err->errnum = 0;
                strcpy( err->errmess, clnt_sperror( pcnfsd_client->client, "Authorising" ));

                release_client( pcnfsd_client );

                return err;
        }

        release_client( pcnfsd_client );

        gethostname(machname, MAX_MACHINE_NAME);
        machname[MAX_MACHINE_NAME] = 0;
        len = getgroups( NGRPS, gids );

        authorisation = authunix_create( machname, ares->ar_uid, ares->ar_gid, len, gids );

        return new_user( &current_user, username, current_nameing_host, (int)ares->ar_uid, (int)ares->ar_gid, authorisation );
}

/*
        Process *NFS:Logon command
*/
_kernel_oserror *command_nfsname
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_swi_regs r;
        _kernel_oserror *err;
        char *hostname;
        char *username;
        char *password;

        if ( argc == 0 )
        {
                /*
                        *Logon
                          Display the current NFSName.
                */
                if ( current_user == NULL )
                {
                        return &mb_no_user;
                }
                else
                {
                        err = lightweight_printf( "The current user is %0s\n", current_user->name );

                        if ( !err )
                        {
                                if ( current_nameing_host )
                                {
                                        err = lightweight_printf( "The current name server is %0s\n", current_nameing_host->host_name );
                                }
                                else
                                {
                                        err = lightweight_printf( "There is no current name server\n" );
                                }
                        }

                        return err;
                }
        }
        else
        {
                /*
                        *Logon [-Host <hostname>] [<username> [<password>]]
                          Set the current user
                */

                readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

                if ( readargs_buffer == NULL )
                        return &mb_malloc_failed;

                r.r[0] = (int)"host=h/k/g,username/g,password/g";
                r.r[1] = (int)arg_string;
                r.r[2] = (int)readargs_buffer;
                r.r[3] = ReadArgsBufferLen;

                err = _kernel_swi( XOS_Bit | OS_ReadArgs, &r, &r );

                if ( err )
                {
                        free( readargs_buffer );
                        return err;
                }

                hostname = username = password = NULL;

                err = readargs_getstring( &hostname, readargs_buffer, 0 );
                if ( !err )
                        err = readargs_getstring( &username, readargs_buffer, 1 );
                if ( !err )
                        err = readargs_getstring( &password, readargs_buffer, 2 );
                free( readargs_buffer );

                if ( !err )
                        err = new_host( &current_nameing_host, hostname );

                free( hostname );

                if ( err )
                {
                        if ( password )
                                free( password );
                        if ( username )
                                free( username );

                        return err;
                }

                /*
                        Are we specifying the user in this call?
                */
                if ( username == NULL )
                {
                        free( password );

                        return NULL;
                }

                /*
                        If user is not nobody and no password given then ask for one
                */
                if ( caseless_strcmp( username, User_Nobody ) != 0 &&
                     password == NULL &&
                     current_nameing_host != NULL )
                {
                        err = lightweight_printf( "Enter your password : " );
                        if ( !err )
                                err = askfor_password( &password );

                        if ( err )
                        {
                                free( username );
                                return err;
                        }
                }

                err = process_nfsname( username, password );

                free( username );
                free( password );

                return err;
        }
}

static _kernel_oserror *list_mountpoints_for_host
(
        char *hostname
)
{
        Chain_Link *link;
        char *last_hostname;
        MountPoint *mount_point;
        _kernel_oserror *err;

        /*
                Set link to point to the first element in the relevant list
                of mount points.
        */
        if ( hostname == NULL )
        {
                link = mount_point_list.forwards;
        }
        else
        {
                /*
                        Find the host with the given name
                */
                for ( link = host_list.forwards;
                      link->forwards != NULL &&
                          strcmp( ((Host *)Link_Wrapper( link ))->host_name, hostname ) != 0;
                      link = link->forwards )
                {
                        /* do nothing */
                }

                /*
                        Start along the list of mount points
                */
                if ( link->forwards != NULL )
                {
                        link = ((Host *)Link_Wrapper( link ))->mount_points.forwards;
                }
        }

        /*
                print column titles
        */
        err = lightweight_printf( Format_MountPoint_List, "Mount Name", "User", "Mount Path" );

        /*
                This is used to find out when the host changes and to print
                a line giving the new host
        */
        last_hostname = NULL;

        for ( ;
              !err &&
                  link->forwards;
              link = link->forwards )
        {
                mount_point = Link_Wrapper( link );

                /*
                        Check for the host changing. Note, a direct pointer to
                        the string comparison is appropriate here.
                */
                if ( mount_point->host->host_name != last_hostname )
                {
                        last_hostname = mount_point->host->host_name;
                        err = lightweight_printf( "Host: %0s\n", last_hostname );
                }

                if ( !err )
                        err = lightweight_printf( Format_MountPoint_List,
                                mount_point->mount_point_name,
                                mount_point->user->name,
                                mount_point->mount_path );
        }

        return err;
}

_kernel_oserror *nfs_mount_internal
(
        char *mountname,
        char *mountpath,
        Host *host,
        UserSpecification *user
)
{
        _kernel_oserror *err;
        _kernel_swi_regs r;
        MountPoint *new_mount_point;
        Chain_Link *link;
        fhstatus *res;
        unused_client *mount_client;

        /*
                Find the mount point ge this in the list of all mount points.
        */
        for ( link = mount_point_list.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) < 0;
              link = link->forwards )
        {
                /* do nothing */
        }

        /*
                If eq return an error
        */
        if ( link->forwards != NULL &&
               caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) == 0 )
                return &mb_duplicate_mount_point;

        new_mount_point = (MountPoint *)malloc( sizeof( MountPoint ));

        if ( new_mount_point == NULL )
                return &mb_malloc_failed;

        new_mount_point->mount_point_name = malloc( strlen( mountname ) + 1 );

        if ( new_mount_point->mount_point_name == NULL )
        {
                free( new_mount_point );
                return &mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_point_name, mountname );

        new_mount_point->mount_path = malloc( strlen( mountpath ) + 1 );

        if ( new_mount_point->mount_path == NULL )
        {
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return &mb_malloc_failed;
        }

        strcpy( new_mount_point->mount_path, mountpath );

        new_mount_point->host = host;
        new_mount_point->user = user;
        new_mount_point->being_dismounted = No;

        err = get_mount_client_for_mp( &mount_client, new_mount_point );
        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return err;
        }

        res = mountproc_mnt_1( &new_mount_point->mount_path, mount_client->client );
        err = rpcmount_to_riscos_err( res, new_mount_point, mount_client->client );
        release_client( mount_client );

        if ( err )
        {
                free( new_mount_point->mount_path );
                free( new_mount_point->mount_point_name );
                free( new_mount_point );

                return err;
        }

        new_mount_point->fhandle = *(nfs_fh *)(res->fhstatus_u.fhs_fhandle);
        host->usage_count++;
        user->usage_count++;
        initialise_header( &new_mount_point->open_files );

        insert_before_link( &new_mount_point->all_mount_points_link, new_mount_point, link );

        /*
                Find the mount point ge this in the list of mount points
                on this host.
        */
        for ( link = current_mounting_host->mount_points.forwards;
              link->forwards != NULL &&
                caseless_strcmp( ((MountPoint *)Link_Wrapper( link ))->mount_point_name, mountname ) <= 0;
              link = link->forwards )
        {
                /* do nothing */
        }

        insert_before_link( &new_mount_point->mount_points_per_host_link, new_mount_point, link );

        /*
                Tell the world about the new mount
        */
        r.r[1] = Service_NFS;
        return _kernel_swi( XOS_Bit | OS_ServiceCall, &r, &r );
}

/*
        All the parameters should be verified by here
*/
_kernel_oserror *nfs_mount
(
        char *hostname,
        char *mountname,
        char *mountpath
)
{
        _kernel_oserror *err;
        char *dirpath;

        /*
                Process the hostname into the current mounting host
        */
        err = new_host( &current_mounting_host, hostname );

        if ( !err &&
                current_mounting_host == NULL )
                err = &mb_no_mounting_host;

        if ( err )
                return err;

        if ( current_user == NULL )
                return &mb_no_user;

        /*
                Only mount if a mountpath is given, otherwise
                drop through to the directory setting bit.
        */
        if ( mountpath )
        {
                err = nfs_mount_internal( mountname, mountpath, current_mounting_host, current_user );
                if ( err )
                {
                        return err;
                }
        }

        if ( !find_mount( mountname ))
                return &mb_no_mount_point_found;

        /*
                Set directories to the mount.
                Don't winge if one of these fails.
        */
        dirpath = malloc( strlen( mountname ) + strlen( ":.$" ) + 1 );
        if ( dirpath != NULL )
        {
                sprintf( dirpath, ":%s.$", mountname );

                (void)set_directory( &current_directory, dirpath, "" );
                (void)set_directory( &previous_directory, dirpath, "" );
                (void)set_directory( &user_root_directory, dirpath, "" );
                (void)set_directory( &library_directory, dirpath, "" );

                free( dirpath );
        }

        return NULL;
}

_kernel_oserror *command_nfsmount
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_swi_regs r;
        char *hostname;
        char *mountname;
        char *mountpath;
        _kernel_oserror *err;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return &mb_malloc_failed;

        r.r[0] = (int)"host=h/k/g,mountname/g,mountpath/g";
        r.r[1] = (int)arg_string;
        r.r[2] = (int)readargs_buffer;
        r.r[3] = ReadArgsBufferLen;

        err = _kernel_swi( XOS_Bit | OS_ReadArgs, &r, &r );

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        hostname = mountname = mountpath = NULL;

        err = readargs_getstring( &hostname, readargs_buffer, 0 );
        if ( !err )
                err = readargs_getstring( &mountname, readargs_buffer, 1 );
        if ( !err )
                err = readargs_getstring( &mountpath, readargs_buffer, 2 );
        free( readargs_buffer );

        if ( mountname == NULL &&
             mountpath != NULL )
        {
                err = &mb_path_no_mount;
        }
        else if ( mountname == NULL &&
                  mountpath == NULL )
        {
                err = list_mountpoints_for_host( hostname );
        }
        else
        {
                if ( strchr( mountname, ' ' ) != NULL || strchr( mountname, ':' ) != NULL )
                        err = &mb_no_spaces_in_mount_name;

                if ( !err )
                        err = nfs_mount( hostname, mountname, mountpath );
        }

        free( hostname );
        free( mountname );
        free( mountpath );

        return err;

}

/*
        Call FileSwitch to close the given file
*/
static _kernel_oserror *nfs_forceclose
(
        OpenFile *file
)
{
        _kernel_swi_regs r;

        r.r[0] = 0;
        r.r[1] = file->fileswitch_handle;
        return _kernel_swi( XOS_Bit | OS_Find, &r, &r );
}

/*
        Close all files on the given mount and remove it from the mount
        chain.
*/
_kernel_oserror *nfs_dismount
(
        MountPoint *mount
)
{
        _kernel_oserror *err = NULL;
        _kernel_swi_regs r;
        _kernel_oserror *error_to_return = NULL;
        OpenFile *lastfile;
        FSEntry_Close_Parameter closeparm;
        unused_client *mount_client;

        /*
                If dismount called as a result of a dismount, do nothing
                at this level and let the top level dismount handle it.
                This occurs if a dismount of a spool mount is done - the
                top level dismount closes all files, thus causing the spool
                mount to be dismounted.
        */
        if ( mount->being_dismounted == Yes )
                return NULL;
        mount->being_dismounted = Yes;

        /*
                If FileSwitch failed to cause this file to close, then
                call FSEntry_Close ourselves. These parameters are set
                to 0 to indicate no change.

                THIS SHOULD ONLY BE NEEDED IN DIRE EMERGENCIES.
        */
        closeparm.info.load_exec.load_address = 0;
        closeparm.info.load_exec.execute_address = 0;

        while ( mount->open_files.forwards->forwards )
        {
                /*
                        Hold lastfile just in case FileSwitch botches is
                */
                lastfile = Link_Wrapper( mount->open_files.forwards );

                err = nfs_forceclose( lastfile );

                /*
                        Check that FileSwitch got it right
                */
                if ( lastfile == Link_Wrapper( mount->open_files.forwards ) )
                {
                        /*
                                FileSwitch botched it, so do it ourselves.
                                Errors at this stage are ignored.
                        */
                        closeparm.handle = (int)lastfile;
                        fsentry_close( &closeparm );
                }

                /*
                        Only return the first error
                */
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        /*
                Void all the directories:
                @, \, & and %
                Void the current mount point (used for nfs:$.)
        */
        if ( current_directory.mount_point == mount )
                current_directory.mount_point = NULL;

        if ( previous_directory.mount_point == mount )
                previous_directory.mount_point = NULL;

        if ( user_root_directory.mount_point == mount )
                user_root_directory.mount_point = NULL;

        if ( library_directory.mount_point == mount )
                library_directory.mount_point = NULL;

        err = get_mount_client_for_mp( &mount_client, mount );
        if ( err && !error_to_return )
                error_to_return = err;

        err = rpcmount_to_riscos_err( mountproc_umnt_1( &mount->mount_path, mount_client->client ), mount, mount_client->client );
        release_client( mount_client );

        if ( err && !error_to_return )
                error_to_return = err;

        cancel_all_caches_by_mount_point( mount );

        free( mount->mount_point_name );
        free( mount->mount_path );
        remove_link( &mount->all_mount_points_link );
        remove_link( &mount->mount_points_per_host_link );

        err = release_host( mount->host );
        if ( err && !error_to_return )
                error_to_return = err;

        err = release_user( mount->user );
        if ( err && !error_to_return )
                error_to_return = err;

        free( mount );

        /*
                Tell everybody about the dismount
        */
        r.r[1] = Service_NFS;
        err = _kernel_swi( XOS_Bit | OS_ServiceCall, &r, &r );
        if ( err && !error_to_return )
                error_to_return = err;

        return error_to_return;
}

_kernel_oserror *nfs_dismount_host
(
        Host *host
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( host->mount_points.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( host->mount_points.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *nfs_dismount_all
(
        void
)
{
        _kernel_oserror *err;
        _kernel_oserror *error_to_return = NULL;

        while( mount_point_list.forwards->forwards )
        {
                err = nfs_dismount( Link_Wrapper( mount_point_list.forwards ));
                if ( err && !error_to_return )
                        error_to_return = err;
        }

        return error_to_return;
}

_kernel_oserror *command_nfsdismount
(
        char *arg_string,
        int argc
)
{
        int *readargs_buffer;
        _kernel_oserror *err;
        YesNoAnswer is_host;
        char *objname;
        Chain_Link *link;
        _kernel_swi_regs r;
        MountPoint *mp;

        argc = argc;

        readargs_buffer = (int *)malloc( ReadArgsBufferLen * sizeof( *readargs_buffer ));

        if ( readargs_buffer == NULL )
                return &mb_malloc_failed;

        r.r[0] = (int)"host=/s,/g";
        r.r[1] = (int)arg_string;
        r.r[2] = (int)readargs_buffer;
        r.r[3] = ReadArgsBufferLen;

        err = _kernel_swi( XOS_Bit | OS_ReadArgs, &r, &r );

        if ( err )
        {
                free( readargs_buffer );
                return err;
        }

        objname = NULL;

        is_host = readargs_buffer[0] != 0;

        err = readargs_getstring( &objname, readargs_buffer, 1 );

        free( readargs_buffer );

        if ( !err )
        {
                if ( is_host )
                {
                        for ( link = host_list.forwards;
                                link->forwards != NULL &&
                                        strcmp( ((Host *)Link_Wrapper( link ))->host_name, objname ) != 0;
                                link = link->forwards )
                        {
                                /* do nothing */
                        }

                        if ( link->forwards )
                        {
                                err = nfs_dismount_host( Link_Wrapper( link ));
                        }
                        else
                        {
                                err = &mb_no_host_found;
                        }
                }
                else if ( objname )
                {
                        /*
                                Not a host, so must be a mount point
                        */

                        mp = find_mount( objname );

                        if ( mp )
                        {
                                err = nfs_dismount( mp );
                        }
                        else
                        {
                                err = &mb_no_mount_point_found;
                        }
                }
                else
                {
                        /*
                                Nothing specified, dismount the whole lot
                        */

                        err = nfs_dismount_all();
                }
        } /* endif readargs etc worked */

        if ( objname )
                free( objname );

        return err;
}

_kernel_oserror *command_nfsinfo
(
        char *arg_string,
        int argc
)
{
        Chain_Link *link;
        Host *host;
        UserSpecification *user;
        _kernel_oserror *err = NULL;

        arg_string = arg_string;
        argc = argc;

        err = lightweight_printf( "Host list:\n" );
        for ( link = host_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                host = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, usage = %1d\n", host->host_name, host->usage_count );
        }

        if ( !err )
                err = lightweight_printf( "\nCache hits %0d; Cache misses %1d\n", cache_hits, cache_misses);

#ifdef NETACCESSCOUNT
        if ( !err )
                err = lightweight_printf( "\nTotal network accesses %0d\n", NetAccessCountG);

#endif

        if ( !err )
                err = lightweight_printf( "\nUser list:\n" );
        for ( link = user_list.forwards;
                !err && link->forwards != NULL;
                link = link->forwards )
        {
                user = Link_Wrapper( link );
                err = lightweight_printf( "name=<%0s>, uid=<%1d>, gid=<%2d>, usage = %3d\n", user->name, user->uid, user->gid, user->usage_count );
        }

        if ( !err )
        {
                if ( current_directory.mount_point )
                {
                        err = lightweight_printf( "CSD: %0x, <%1s>\n", current_directory.mount_point, current_directory.full_path );
                }
                else
                {
                        err = lightweight_printf( "CSD: \"Unset\"\n" );
                }
        }

        if ( !err )
        {
                if ( previous_directory.mount_point )
                {
                        err = lightweight_printf( "PSD: %0x, <%1s>\n", previous_directory.mount_point, previous_directory.full_path );
                }
                else
                {
                        err = lightweight_printf( "PSD: \"Unset\"\n" );
                }
        }

        if ( !err )
        {
                if ( user_root_directory.mount_point )
                {
                        err = lightweight_printf( "URD: %0x, <%1s>\n", user_root_directory.mount_point, user_root_directory.full_path );
                }
                else
                {
                        err = lightweight_printf( "URD: \"Unset\"\n" );
                }
        }

        if ( !err )
        {
                if ( library_directory.mount_point )
                {
                        err = lightweight_printf( "Library: %0x, <%1s>\n", library_directory.mount_point, library_directory.full_path );
                }
                else
                {
                        err = lightweight_printf( "Library: \"Unset\"\n" );
                }
        }

        return err;
}

static _kernel_oserror *pr_justified
(
        char *string,
        int width
)
{
        _kernel_oserror *err = NULL;
        int slen = strlen( string );

        while ( !err && slen < width )
        {
                err = lightweight_printf( " " );
                slen++;
        }

        if ( !err )
                lightweight_printf( "%0s", string );

        return err;
}

static _kernel_oserror *convertswi(int swinum, long num, char *buffer, int len)
{
        _kernel_swi_regs r;
        r.r[0] = (int)num;
        r.r[1] = (int)buffer;
        r.r[2] = len;
        return _kernel_swi( swinum, &r, &r );
}


#define ConvBufSize 20

static _kernel_oserror *prtime(long time)
{
        _kernel_oserror *err;
        int i;
        char buf[ConvBufSize];
        static struct {
                int c_secs;             /* conversion units in secs */
                char * c_str;           /* unit string */
        } cunits [] = {
                {60*60*24*28, "months"},
                {60*60*24*7, "weeks"},
                {60*60*24, "days"},
                {60*60, "hours"},
                {60, "mins"},
                {1, "secs"}
        };

        if (time <= 0) {
                return lightweight_printf("EXPIRED\n");
        }
        for (i = 0; i < sizeof(cunits)/sizeof(cunits[0]); i++) {
                if (time >= cunits[i].c_secs)
                        break;
        }
        err = convertswi( OS_ConvertSpacedInteger4, time/cunits[i].c_secs, buf, sizeof( buf ));
        if (!err)
                err = lightweight_printf(buf);
        if (!err)
                err = lightweight_printf(" %0s", cunits[i].c_str);
        return err;
}

#define kb(b) ((b)/1024)

static _kernel_oserror *warn( utils_spacestr *space, char *mount_name )
{
        _kernel_oserror *err;
        utils_quotastr *squota = &space->sp.quota.space,
                       *fquota = &space->sp.quota.files;
        if (squota->hlim &&
             squota->usage >= squota->hlim)
        {
                err = lightweight_printf(
"Block limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (squota->slim &&
             squota->usage >= squota->slim)
        {
                err = lightweight_printf(
"Over disk quota on %0s, remove %1dK",
                      mount_name,
                      kb(squota->usage - squota->slim + 1 ) );
                if (err) return err;
                if (squota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(squota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }

        if (fquota->hlim &&
            fquota->usage >= fquota->hlim)
        {
                err = lightweight_printf(
"File count limit reached on %0s\n",
                      mount_name );
                if (err) return err;
        }
        else if (fquota->slim &&
            fquota->usage >= fquota->slim)
        {
                err = lightweight_printf(
"Over file quota on %0s, remove %1d file%2s",
                       mount_name,
                       fquota->usage - fquota->slim + 1,
                       ((fquota->usage - fquota->slim + 1) > 1 ? "s" : "" ) );
                if (err) return err;
                if (fquota->timeleft > 0)
                {
                        err = lightweight_printf(" within ");
                        if (err) return err;
                        err = prtime(fquota->timeleft);
                        if (err) return err;
                }
                err = lightweight_printf("\n");
                if (err) return err;
        }
        return NULL;
}


_kernel_oserror *command_free
(
        char *arg_string,
        int argc
)
{
        _kernel_oserror *err;
        utils_spacestr space;
        char user_free_buf[ConvBufSize];
        char usage_buf[ConvBufSize];
        char quota_buf[ConvBufSize];
        char limit_buf[ConvBufSize];
        utils_quotastr *squota = &space.sp.quota.space,   /* space quota struct */
                       *fquota = &space.sp.quota.files;   /* files quota struct */
        int maxwid = 0;

        if ( argc == 0 )
        {
                if ( current_directory.mount_point == NULL )
                        return &mb_no_current_mount_point;

                arg_string = current_directory.mount_point->mount_point_name;
        }
        else
        {
                space_reduce( arg_string );
        }

        err = utils_getfsspace( &space, arg_string );

        if (space.active_quota)
        {
                long free = (squota->slim > squota->usage) ? squota->slim - squota->usage : 0;
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(free), user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->usage), usage_buf, sizeof( usage_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->slim), quota_buf, sizeof( quota_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, kb(squota->hlim), limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, "K");
                strcat(usage_buf, "K");
                strcat(quota_buf, "K");
                strcat(limit_buf, "K");
        }
        else
        {
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bfree, user_free_buf, sizeof( user_free_buf ));
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.bavail, quota_buf, sizeof( quota_buf ));
                usage_buf[0] = '\0';
                if ( !err )
                        err = convertswi( OS_ConvertSpacedCardinal4, space.sp.statfs.blocks, limit_buf, sizeof( limit_buf ));
                strcat(user_free_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(quota_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
                strcat(limit_buf, (space.sp.statfs.bsize == 1024) ? "K" : " blocks");
        }

        if ( !err )
        {
                if ( strlen( user_free_buf ) > maxwid )
                        maxwid = strlen( user_free_buf );
                if ( strlen( usage_buf ) > maxwid )
                        maxwid = strlen( usage_buf );
                if ( strlen( quota_buf ) > maxwid )
                        maxwid = strlen( quota_buf );
                if ( strlen( limit_buf ) > maxwid )
                        maxwid = strlen( limit_buf );
        }
        if ( space.active_quota )
        {
                if ( !err )
                        err = lightweight_printf( "Bytes free   " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes used   " );
                if ( !err )
                        err = pr_justified( usage_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes quota  " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nBytes limit   " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }
        else  /* no quota; print out statfs info */
        {
                if ( !err )
                        err = lightweight_printf( "No quota on %0s\n", arg_string);
                if ( !err )
                        err = lightweight_printf( "Space on filing system:\nFree      " );
                if ( !err )
                        err = pr_justified( user_free_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nAvailable " );
                if ( !err )
                        err = pr_justified( quota_buf, maxwid );
                if ( !err )
                        err = lightweight_printf( "\nSize      " );
                if ( !err )
                        err = pr_justified( limit_buf, maxwid );
        }

        if ( !err )
                err = lightweight_printf( "\n" );

        if ( !err && space.active_quota
           && ( ( (squota->slim > 0) && (squota->usage > squota->slim) )
             || ( (fquota->slim > 0) && (fquota->usage > fquota->slim) ) ) )
        {
                err = warn( &space, arg_string );
        }

        return err;
}

_kernel_oserror *command_timeoffset
(
        char *arg_string,
        int argc
)
{
        argc = argc;
        time_offset_lo = atoi( arg_string ) * 6000;
        time_offset_hi = (unsigned int)( ((int)time_offset_lo) >> 31 );
        return NULL;
}

_kernel_oserror *command_cachetime
(
        char *arg_string,
        int argc
)
{
        argc = argc;
        out_of_date_time = atoi( arg_string );
        return NULL;
}

_kernel_oserror *nfs_boot
(
        void
)
{
        int first, nsecs, nread;
        int lasttime, curtime, elapsedtime;
        char server_adr[32], mount_path[64];
        _kernel_swi_regs r;
        _kernel_oserror *err;

        r.r[0] = (int)"Inet$BootServer";
        r.r[1] = (int)server_adr;
        r.r[2] = sizeof(server_adr);
        r.r[3] = 0;
        r.r[4] = 0;
        err = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
        if ( err != 0 )
            return ( err );
        nread = r.r[2];
        server_adr[nread] = 0;

        r.r[0] = (int)"Inet$MountPath";
        r.r[1] = (int)mount_path;
        r.r[2] = sizeof(mount_path);
        r.r[3] = 0;
        r.r[4] = 0;
        err = _kernel_swi(XOS_Bit | OS_ReadVarVal, &r, &r);
        nread = r.r[2];
        if (err != 0 || nread == 0)
            strcpy(mount_path, "/nfsboot");
        else
            mount_path[nread] = 0;

        printf("Trying to mount %s on server %s\n", mount_path, server_adr);
        first = 1;
        nsecs = 0;
        lasttime = time(0);
        do
        {
                err = nfs_mount( server_adr, "nfsboot", mount_path );
                if (!err)
                       break;
                curtime = time(0);
                elapsedtime = curtime - lasttime;
                if (elapsedtime < 5) 
                       continue;
                nsecs += elapsedtime;
                if (first) 
                {
                        printf("Waiting for response from boot server\n");
                        first = 0;
                }
                printf("Elapsed time: %d seconds\r", nsecs);
                lasttime = time(0);
        } while (1);

        r.r[0] = (int)"dir nfs::nfsboot.$";
         (void) _kernel_swi(XOS_Bit | OS_CLI, &r, &r);

        r.r[0] = (int)"run nfs::nfsboot.$.!NFSBoot";
        (void) _kernel_swi(XOS_Bit | OS_CLI, &r, &r);
        return ( err );
}
