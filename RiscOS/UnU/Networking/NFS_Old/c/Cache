/*	C.CACHE

Purpose : Handling of NFS caches

Functions :  attrcache_hash
	     lookupcache_hash
	     update_attrcache_at
	     update_attrcache
	     cancel_lookupcache_at
	     cancel_lookupcache
	     cancel_lookupcache_by_fhandle
	     cancel_lookupcache_by_mount_point
	     cancel_attrcache_at
	     cancel_attrcache_by_fhandle
	     cancel_attrcache_by_mount_point
	     cancel_all_caches_by_fhandle
	     cancel_all_caches_by_mount_point
	     nfs_getattr
	     nfs_setattr
	     update_lookupcache_at
	     update_lookupcache
	     nfs_lookup_basic
	     nfs_lookup
	     nfs_read
	     nfs_readmany
	     nfs_write
	     nfs_writemany
	     nfs_write_with_appendum
	     nfs_create
	     nfs_remove
	     nfs_rename
	     nfs_mkdir
	     nfs_rmdir

History :
Date	Who    Comments
-----------------------------------------------------------------------------
07/05/93 ??     INITIAL VERSION
12/01/95 CP     Removed function nfs_readdir since its functionality is
	       	totally replaced within Get_NFS_Directory.
	       	cancel_all_caches_by_fhandle now NOT static.  It can be
	       	exported (used in enumdir)
9/2/95	 CP	Increased the size of the cache to 50 - significant
	 	improvement found (65%->69% hit rate) on short test.
	 	Tending towards 75% in general use ?
21/2/95	 CP	Added better descriptions for each function.
****************************************************************************/

#ifndef __NFS_H
#include "NFS.h"
#endif

#ifdef NETACCESSCOUNT
extern unsigned int NetAccessCountG;
#endif


static struct timeval TIMEOUT = { 25, 0 };

#include "nfsrw.h"

#include <sys/time.h>

/*
        These numbers are about where significant roll-off in the
        cache's performance starts to happen.
*/
#define AttrCacheSize 50   /* was 23 */
#define LookupCacheSize 50 /* was 23 */

static struct attrcache_entry
{
        MountPoint *mount_point;
        nfs_fh fhandle;
        clock_t out_of_date_time;
        fattr nattr;
}       attrcache[ AttrCacheSize ];

static struct lookupcache_entry
{
        MountPoint *mount_point;
        nfs_fh dir;
        char *nfs_name;
        clock_t out_of_date_time;
        nfs_fh fhandle;
}       lookupcache[ LookupCacheSize ];


/********* cache operation overview ***************************************

There are 2 caches implemented in this file....one for the basic file
informaton, the other for the attributes for the files ('lookup' and 'attr'
caches).  Both are simple predefined arrays of suitable structures.

Entries are stored under a specific, almost unique 'hash' value made up from the mount point and  file ID.  This specifies where in the array to store the
data.

***************************************************************************/



/********* attrcache_hash **************************************************

Purpose : Generates the hash value for the attrcache entry.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to an nfs file handle

Returns : a hash value based on the _value_ of the mount point pointer &
	  fhandle, modulo (sizeof(cache)) (so it can't drop off the end of
	  the table !)

****************************************************************************/

static int attrcache_hash
(
        MountPoint *mount_point,
        nfs_fh *fhandle
)
{
        unsigned hash_val;
        char *rover;
        int i;

        rover = (char *)&mount_point;
        hash_val = rover[0] ^ (rover[1]<<1) ^ (rover[2]<<2) ^ (rover[3]<<3);

        for ( i = 0;
                i < FHSIZE;
                i++ )
        {
                hash_val = (hash_val << 1) ^ (hash_val >> 31) ^ fhandle->data[i];
        }

        return (int)(hash_val % AttrCacheSize);
} /* endfunction attrcache_hash */



/********* lookupcache_hash ************************************************

Purpose : Generates the hash value for the lookupcache entry.

Inputs : mount_point  ptr to the mount point information
         fhandle      ptr to  nfs file handle of the directory where the 	 	  	      file is
         nfs_name     ptr to the nfs name string of the file

Returns : a hash value based on the _address_ of the mount point, the
	  directory where the file is, and the name string, modulo
	  (sizeof(cache)) (so it can't drop off the end of the table !)

****************************************************************************/

static int lookupcache_hash
(
        MountPoint *mount_point,
        nfs_fh *dir,
        char *nfs_name
)
{
        unsigned hash_val;
        int i;

        hash_val = (int)mount_point;

        for ( i = 0;
                i < FHSIZE;
                i++ )
        {
                hash_val = ((hash_val << 1) | (hash_val >> 31)) + dir->data[i];
        }

        for ( i = 0;
                nfs_name[ i ];
                i++ )
        {
                hash_val = ((hash_val << 1) | (hash_val >> 31)) + nfs_name[i];
        }

        return (int)(hash_val % LookupCacheSize);
}  /* endfunction lookupcache_hash */




/********* update_attrcache_at **********************************************

Purpose : Actually update the values held at a specified position in the
	  attribute cache

Inputs :  mount_point  ptr to the mount point details
       	  fhandle      handle of the file to be put into the cache
       	  hash_val     hash value for the entry
       	  nattr	       attributes of the file

Returns : void.
	  Overwrites the cache entry in global array attrcache[hash_val]

****************************************************************************/

static void update_attrcache_at
(
        MountPoint *mount_point,
        nfs_fh *fhandle,
        int hash_val,
        fattr *nattr
)
{
        attrcache[ hash_val ].mount_point = mount_point;
        attrcache[ hash_val ].fhandle = *fhandle;
        attrcache[ hash_val ].out_of_date_time = clock() + out_of_date_time;
        attrcache[ hash_val ].nattr = *nattr;
} /* endfunction update_attrcache_at */


/********* update_attrcache *************************************************

Purpose : Update the values held at a specified position in the attribute
	  cache.  Generates the hash value, and passes it onto
	  update_attrcache_at.

Inputs :  mount_point  ptr to the mount point details
       	  fhandle      handle of the file to be put into the cache
       	  nattr	       attributes of the file

Returns : void.
	  Doesn't do a lot itself, really ...

****************************************************************************/

static void update_attrcache
(
        MountPoint *mount_point,
        nfs_fh *fhandle,
        fattr *nattr
)
{
        update_attrcache_at( mount_point, fhandle, attrcache_hash( mount_point, fhandle ), nattr );
}   /* endfunction update_attrcache */


/********* cancel_lookup_cache_at *******************************************

Purpose : Clears a single entry in the lookup cache

Inputs : hashval   position in array to clear

Returns : void
	  frees memory and sets values to 0 at specified entry in global
	  array lookupcache

****************************************************************************/

static void cancel_lookupcache_at( int hashval )
{
        lookupcache[ hashval ].mount_point = NULL;
        if ( lookupcache[ hashval ].nfs_name )
        {
                free( lookupcache[ hashval ].nfs_name );
                lookupcache[ hashval ].nfs_name = NULL;
        }
} /* endfunction cancel_lookupcache_at */


/********* cancel_lookup_cache **********************************************

Purpose : Clears a single entry in the lookup cache by calling
	  cancel_lookup_cache_at.

Inputs : mount_point  ptr to mount point information
       	 dir	      nfs file handle of directory holding file
       	 nfs_name     nfs name of the object to clear

Returns : void (doesn't do a lot itself !)

****************************************************************************/

static void cancel_lookupcache( MountPoint *mount_point, nfs_fh *dir, char *nfs_name )
{
        cancel_lookupcache_at( lookupcache_hash( mount_point, dir, nfs_name ));
} /* endfunction cancel_lookupcache */


/********* cancel_lookup_cache_by_fhandle ***********************************

Purpose : Clears the lookup cache entry associated with a file handle.  It
	  does a simple linear search of the cache entries to find the right
	  one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void
	  if there is an entry in global array lookupcache with a matching
	  filehandle, then it is cleared.

****************************************************************************/

static void cancel_lookupcache_by_fhandle( nfs_fh *fhandle )
{
        int i;

        for ( i = 0;
                i < LookupCacheSize;
                i++ )
        {
                if ( memcmp( &lookupcache[ i ].fhandle, fhandle, sizeof( nfs_fh )) == 0 )
                {
                        cancel_lookupcache_at( i );
                }
        }
} /* endfunction cancel_lookupcache_by_fhandle */



/********* cancel_lookup_cache_by_mount_point ******************************

Purpose : Clears the lookup cache entry associated with a mount point value.
	  It  does a simple linear search of the cache entries to find the
	  right one to clear.

Inputs :  mount_point  ptr to mount point of entry to clear

Returns : void
	  if there is an entry in global array lookupcache with a matching
	  mount point ptr, then it is cleared.

****************************************************************************/

static void cancel_lookupcache_by_mount_point( MountPoint *mount_point )
{
        int i;

        for ( i = 0;
                i < LookupCacheSize;
                i++ )
        {
                if ( lookupcache[ i ].mount_point == mount_point )
                {
                        cancel_lookupcache_at( i );
                }
        }
} /* endfunction cancel_lookupcache_by_mount_point */



/********* cancel_attr_cache_at *******************************************

Purpose : Clears a single entry in the attribute cache

Inputs : hashval   position in array to clear

Returns : void
	  frees memory and sets values to 0 at specified entry in global
	  array attrcache

****************************************************************************/

static void cancel_attrcache_at( int hashval )
{
        attrcache[ hashval ].mount_point = NULL;
} /* endfunction cancel_attrcache_at */



/********* cancel_attr_cache_by_fhandle *************************************

Purpose : Clears the attribute cache entry associated with a file handle.  It
	  does a simple linear search of the cache entries to find the right
	  one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void
	  if there is an entry in global array attrcache with a matching
	  filehandle, then it is cleared.

****************************************************************************/

static void cancel_attrcache_by_fhandle( nfs_fh *fhandle )
{
        int i;

        for ( i = 0;
                i < AttrCacheSize;
                i++ )
        {
                if ( memcmp( &attrcache[ i ].fhandle, fhandle, sizeof( nfs_fh )) == 0 )
                {
                        cancel_attrcache_at( i );
                }
        }
} /* endfunction cancel_attrcache_by_fhandle */


/********* cancel_attr_cache_by_mount_point ******************************

Purpose : Clears the attr cache entry associated with a mount point value.
	  It  does a simple linear search of the cache entries to find the
	  right one to clear.

Inputs :  mount_point  ptr to mount point of entry to clear

Returns : void
	  if there is an entry in global array attrcache with a matching
	  mount point ptr, then it is cleared.

****************************************************************************/

static void cancel_attrcache_by_mount_point( MountPoint *mount_point )
{
        int i;

        for ( i = 0;
                i < AttrCacheSize;
                i++ )
        {
                if ( attrcache[ i ].mount_point == mount_point )
                {
                        cancel_attrcache_at( i );
                }
        }
} /* endfunction cancel_attrcache_by_mount_point */


/********* cancel_all_caches_by_fhandle ***********************************

Purpose : Clears both lookup and attribute cache entries associated with a
	  file handle.  It does a simple linear search of the cache entries
	  to find the right one to clear.

Inputs :  fhandle  filehandle of entry to clear

Returns : void  Doesn't do a lot really, just calls other functions !

****************************************************************************/

void cancel_all_caches_by_fhandle( nfs_fh *fhandle )
{
        cancel_lookupcache_by_fhandle( fhandle );
        cancel_attrcache_by_fhandle( fhandle );
} /* endfunction cancel_all_caches_by_fhandle */



/********* cancel_all_caches_by_mount_point *********************************

Purpose : Clears both lookup and attribute cache entries associated with a
	  mount point ptr.  It does a simple linear search of the cache
	  entries to find the right one to clear.

Inputs :  mount_point  ptr to mountpoint data

Returns : void  Doesn't do a lot really, just calls other functions !

****************************************************************************/

void cancel_all_caches_by_mount_point( MountPoint *mount_point )
{
        cancel_lookupcache_by_mount_point( mount_point );
        cancel_attrcache_by_mount_point( mount_point );
} /* endfunction cancel_all_caches_by_mount_point */



/********* nfs_getattr ******************************************************

Purpose : Gets attributes for given file.  It will check the attribute cache
	  first, then will go to the network for the information if it wasn't
	  found, or had timed out.  Any fresh information is stored in the
	  cache.  Flushes all caches if data is stale (NFSERR_STALE)

Inputs : nattr        ptr to ptr, somewhere to put the result
       	 mount_point  ptr to mount point info
       	 fhandle      handle of file to get attributes for

Returns : NULL if OK, ptr to error if not (eg not found)
	  If successful, nattr holds the attribute information for the file.

****************************************************************************/

_kernel_oserror *nfs_getattr
(
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *fhandle
)
{
        _kernel_oserror *err;
        int hash_val = attrcache_hash( mount_point, fhandle );
        attrstat *getattr_res;
        unused_client *nfs_client;

        /*
                Check if cache entry is present, then check if it is too old to be useful.
                If all is OK use the cached entry, otherwise obtain the value from the server.
        */

        if ( attrcache[ hash_val ].mount_point == mount_point &&
             memcmp( &attrcache[ hash_val ].fhandle, fhandle, sizeof( *fhandle )) == 0 &&
             attrcache[ hash_val ].out_of_date_time > clock() )
        {
                cache_hits++;

                *nattr = &attrcache[ hash_val ].nattr;

                return NULL;
        }
        cache_misses++;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        getattr_res = nfsproc_getattr_2( fhandle, nfs_client->client );
        err = rpcnfs_to_riscos_err( getattr_res, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        update_attrcache_at( mount_point, fhandle, hash_val, &getattr_res->attrstat_u.attributes );

        *nattr = &attrcache[ hash_val ].nattr;

        return NULL;
}   /* endfunction nfs_getattr */



/********* nfs_setattr ******************************************************

Purpose : Sets attributes for given file.  This routine alters the attributes
	  of the file on the network, and updates the attribute cache.
	  Flushes all caches if data is found to be stale (NFSERR_STALE).

Inputs : nattrres     ptr to ptr, somewhere to store result
       	 mount_point  ptr to mount point info
       	 fhandle      handle of file to get attributes for
       	 nattr	      ptr to attribute information

Returns : NULL if OK, ptr to error if not (eg not found)
	  If successful, nattrres holds the attribute information for the
	  file?

****************************************************************************/

_kernel_oserror *nfs_setattr
(
        fattr **nattrres,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        sattr *nattr
)
{
        _kernel_oserror *err;
        sattrargs sargs;
        attrstat *sres;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        sargs.file = *fhandle;
        sargs.attributes = *nattr;

        sres = nfsproc_setattr_2( &sargs, nfs_client->client );
        err = rpcnfs_to_riscos_err( sres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }


        /*
                Update the attrcache with the returned result
        */
        update_attrcache( mount_point, fhandle, &sres->attrstat_u.attributes );

        *nattrres = &sres->attrstat_u.attributes;

        /*
                No error, so return NULL
        */
        return NULL;
}   /* endfunction nfs_setattr */



/********* update_lookupcache_at *******************************************

Purpose : Actually update the values held at a specified position in the
	  lookup cache.  routine explicitly cancels the appropriate entry
	  first.

Inputs :  mount_point  ptr to the mount point details
       	  dir	       ptr to handle of directory to be entered
       	  nfs_name     ptr to name string of file to be put into the cache
       	  hash_val     hash value for the entry
       	  fhandle      ptr to handle of file

Returns : void.
	  Overwrites the cache entry in global array lookupcache[hash_val]

****************************************************************************/

static void update_lookupcache_at
(
        MountPoint *mount_point,
        nfs_fh *dir,
        char *nfs_name,
        int hashval,
        nfs_fh *fhandle
)
{
        cancel_lookupcache_at( hashval );
        lookupcache[ hashval ].nfs_name = malloc( strlen( nfs_name ) + 1 );
        if ( lookupcache[ hashval ].nfs_name )
        {
                strcpy( lookupcache[ hashval ].nfs_name, nfs_name );
                lookupcache[ hashval ].mount_point = mount_point;
                lookupcache[ hashval ].dir = *dir;
                lookupcache[ hashval ].fhandle = *fhandle;
                lookupcache[ hashval ].out_of_date_time = clock() + out_of_date_time;
        }
}   /* endfunction update_lookupcache_at */



/********* update_lookupcache **********************************************

Purpose : Update the values held at a specified position in the
	  lookup cache, generating hashvalue on the way.

Inputs :  mount_point  ptr to the mount point details
       	  dir	       ptr to handle of directory to be entered
       	  nfs_name     ptr to name string of file to be put into the cache
       	  fhandle      ptr to handle of file

Returns : void.  Doesn't change anything directly

****************************************************************************/

static void update_lookupcache
(
        MountPoint *mount_point,
        nfs_fh *dir,
        char *nfs_name,
        nfs_fh *fhandle
)
{
        update_lookupcache_at( mount_point, dir, nfs_name, lookupcache_hash( mount_point, dir, nfs_name ), fhandle );
}   /* endfunction update_lookupcache */


/********* nfs_lookup_basic *************************************************

Purpose : Looks for given file.  First of all, the lookup cache is checked.
	  If the file is found, then its attributes are looked up in the
	  attribute cache and the routine returns.

          If the file is not found in the cache, then the network is
	  interrogated for it.  The caches are updated as necessary.

Inputs : fhandle      ptr to handle of file to find
         nattr        ptr to ptr, somewhere to store the attributes on
	 	      	  success
         mount_point  ptr to mount point info
         dir	      ptr to handle for parent directory
         filename     ptr to filename string

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled in with attribute data.
	  fhandle is filled in with the full details of the found file, if
	  	  the network is used
****************************************************************************/

static _kernel_oserror *nfs_lookup_basic
(
        nfs_fh *fhandle,
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename
)
{
        _kernel_oserror *err;
        diropargs dargs;
        diropres *dres;
        int hashval = lookupcache_hash( mount_point, dir, filename );
        unused_client *nfs_client;

        if ( lookupcache[ hashval ].mount_point == mount_point &&
                memcmp( &lookupcache[ hashval ].dir, dir, sizeof( *dir )) == 0 &&
                strcmp( lookupcache[ hashval ].nfs_name, filename ) == 0 &&
                lookupcache[ hashval ].out_of_date_time > clock() )
        {
                cache_hits++;
                *fhandle = lookupcache[ hashval ].fhandle;

                err = nfs_getattr( nattr, mount_point, fhandle );

                if ( !err )
                        return NULL;

                /*
                        If something has failed then fall through and do it
                        the hard way.
                */
        }
        cache_misses++;

        dargs.dir = *dir;
        dargs.name = filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        dres = nfsproc_lookup_2( &dargs, nfs_client->client );
        err = rpcnfs_to_riscos_err( dres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_noent )
                {
                        cancel_lookupcache_at( hashval );
                }
                else if ( err == &mb_nfserr_stale )
                {
                        cancel_all_caches_by_fhandle( dir );
                }

                return err;
        }

        *fhandle = dres->diropres_u.diropres.file;
        *nattr = &dres->diropres_u.diropres.attributes;

        update_lookupcache_at( mount_point, dir, filename, hashval, fhandle );
        update_attrcache( mount_point, fhandle, *nattr );

        return NULL;
}   /* endfunction nfs_lookup_basic */


/********* nfs_lookup *******************************************************

Purpose : Looks for given file, coping with softlinks.

Inputs : fhandle      ptr to handle of file to find
         nattr        ptr to ptr, somewhere to store the attributes on
	 	      	  success
         mount_point  ptr to mount point info
         dir	      ptr to handle for parent directory
         filename     ptr to filename string

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled in with attribute data.
	  fhandle is filled in with the full details of the found file, if
	  	  the network is used

****************************************************************************/

_kernel_oserror *nfs_lookup
(
        nfs_fh *fhandle,
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename
)
{
        _kernel_oserror *err;
        nfs_fh *used_dir = dir;
        char *used_filename = filename;
        int used_filename_len = strlen( filename );
        int filename_rover = 0;
        int softlink_resolutions_left = MAX_Soft_Link_Resolutions;
        readlinkres *rlres;
        int link_len;
        char *new_block;
        char *end_of_leaf;
        char *start_of_leaf;
        nfs_fh last_dir_found;
        YesNoAnswer went_via_soft_links = No;
        unused_client *nfs_client;

        do
        {
                /*
                        Determine the directory to search in.
                */
                if ( used_filename[ filename_rover ] == FileChar_NFSDirectorySeparator )
                {
                        /*
                                Starts with /, so must be root of mount point
                        */
                        used_dir = &mount_point->fhandle;
                        filename_rover++;
                }

                /*
                        Address of leaf to search for in the basic lookup.
                */
                start_of_leaf = &used_filename[ filename_rover ];

                /*
                        Skip filename_rover over this leaf name.
                */
                end_of_leaf = strchr( start_of_leaf, FileChar_NFSDirectorySeparator );
                if ( end_of_leaf )
                {
                        filename_rover = end_of_leaf - used_filename;
                }
                else
                {
                        filename_rover = used_filename_len;
                }

                /*
                        Force terminate the leaf (and resolve multiple /s at the same time).
                        Multiple /s may be caused if the last element of a soft link is
                        itself a soft link.
                */
                while( used_filename[ filename_rover ] == FileChar_NFSDirectorySeparator )
                        used_filename[ filename_rover++ ] = '\0';

                /*
                        Lookup that leaf name.
                */
                err = nfs_lookup_basic( fhandle, nattr, mount_point, used_dir, start_of_leaf );

                if ( err )
                        continue;

                /*
                        If its a soft link replace the path up to this soft link with
                        the soft link and resolve relative to here.
                */
                switch ( (*nattr)->mode & NFSMODE_FMT )
                {
                case NFSMODE_LNK:
                        /*
                                Woops we've run out of our tether!
                        */
                        if ( --softlink_resolutions_left < 0 )
                        {
                                err = &mb_too_many_soft_links;
                                continue;
                        }

                        went_via_soft_links = Yes;

                        /*
                                Get the value of the soft link.
                        */
                        err = get_nfs_client_for_mp( &nfs_client, mount_point );
                        if ( err )
                                continue;

                        rlres = nfsproc_readlink_2( fhandle, nfs_client->client );
                        err = rpcnfs_to_riscos_err( rlres, mount_point, nfs_client->client );
                        release_client( nfs_client );

                        if ( err )
                                continue;


                        /*
                                Attach to the front of the filename
                        */
                        if ( used_filename == filename )
                        {
                                /*
                                        used_filename was the name supplied - lets grab a fresh
                                        block as the caller would get upset otherwise.
                                */
                                used_filename_len = strlen( rlres->readlinkres_u.data );
                                new_block = malloc( used_filename_len + 1 );

                                if ( !new_block )
                                {
                                        err = &mb_malloc_failed;
                                        continue;
                                }

                                used_filename = new_block;
                                strcpy( used_filename, rlres->readlinkres_u.data );
                                filename_rover = 0;
                        }
                        else
                        {
                                /*
                                        used_filename wasn't name supplied so we can
                                        stretch the block we got.
                                */

                                /*
                                        String length of the soft link.
                                */
                                link_len = strlen( rlres->readlinkres_u.data );

                                /*
                                        Stretch (or shrink, possibly) the space to accomodate
                                        the soft link.
                                */
                                new_block = malloc( used_filename_len + link_len + 1 - filename_rover + 1 );

                                if ( !new_block )
                                {
                                        err = &mb_malloc_failed;
                                        continue;
                                }

                                /*
                                        Fill in the path continuation.
                                */
                                sprintf( new_block, "%s%c%s",
                                        rlres->readlinkres_u.data,
                                        FileChar_NFSDirectorySeparator,
                                        &used_filename[ filename_rover ] );

                                free( used_filename );
                                used_filename = new_block;

                                /*
                                        Adjust how long we think the full path is currently.
                                */
                                used_filename_len += link_len + 1 - filename_rover;

                                /*
                                        Start again from the soft link.
                                */
                                filename_rover = 0;
                        }
                        break;

                default:
                        if ( used_filename[ filename_rover ] )
                        {
                                /*
                                        There's more to resolve after this directory, so
                                        take a copy of this dir's handle and point dir at it.
                                        If this isn't a dir, then the lookup will go bang and
                                        we'll get an error that way.
                                */
                                last_dir_found = *fhandle;

                                used_dir = &last_dir_found;
                        }
                        break;
                }

                /*
                        At this stage, fhandle has been filled in and dir points
                        at the handle of the dir found or the dir searched in (if was a soft link found).
                */
        } while ( !err && used_filename[ filename_rover ] );

        if ( used_filename != filename )
                free( used_filename );

        /*
                Translate a not found whilst resolving a soft link into a soft link.
        */
        if ( err == &mb_nfserr_noent && went_via_soft_links )
        {
                err = nfs_lookup_basic( fhandle, nattr, mount_point, dir, filename );
        }

        return err;
}



/********* nfs_read *********************************************************

Purpose : Read data from a given file.  It is assumed that there is
	  sufficient memory allocated at readres_data to hold the maximum
	  requested data.  Note that routine will also update the attribute
	  cache entry for the file read from.  If stale data is detected
	  (NFSERR_STALE), then all cache entries for that file are cancelled.

Inputs : readres_len    ptr, for storing result
       	 readres_data	ptr, for storing result
       	 mount_point    ptr to mount point info
       	 fhandle	ptr to file handle of file to read
       	 offset		offset from start of file
       	 count		number of bytes to read

Returns : NULL if found OK, otherwise ptr to error
	  readres_len holds the number of bytes actually read
	  readres_data holds the actual data

****************************************************************************/

_kernel_oserror *nfs_read
(
        int *readres_len,
        char *readres_data,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        unsigned offset,
        int count
)
{
        _kernel_oserror *err;
        readargs rargs;
        readres *rres;
        readres res;
        unused_client *nfs_client;

        rargs.file = *fhandle;
        rargs.offset = offset;
        rargs.count = count;
        res.readres_u.reply.data.data_val = readres_data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        /* Not using nfsproc_read_2() saves copying the received data */

#ifdef NETACCESSCOUNT
NetAccessCountG++;
#endif
        if ( clnt_call( nfs_client->client, NFSPROC_READ, xdr_readargs, &rargs, xdr_readres, &res, TIMEOUT ) != RPC_SUCCESS )
        {
                rres = NULL;
        }
        else
        {
                rres = &res;
        }
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* upper levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif

        err = rpcnfs_to_riscos_err( rres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        *readres_len = rres->readres_u.reply.data.data_len;

        update_attrcache( mount_point, fhandle, &rres->readres_u.reply.attributes );

        return NULL;
}  /* endfunction nfs_read */



/********* nfs_readmany *****************************************************

Purpose : Reads multiple packets from NFS file.  If stale data encountered,
	  then the cache entries for the file are cancelled.  Otherwise the
	  attribute cache is updated.

Inputs : readres_len    ptr, for storing result
       	 readres_data	ptr, for storing result
       	 mount_point    ptr to mount point info
       	 fhandle	ptr to file handle of file to read
       	 offset		offset from start of file
       	 count		number of bytes to read


Returns : NULL if found OK, otherwise ptr to error
	  readres_len holds the number of bytes actually read
	  readres_data holds the actual data


****************************************************************************/

_kernel_oserror *nfs_readmany
(
        int *readres_len,
        char *readres_data,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        unsigned offset,
        int count
)
{
        fattr nattr;
        _kernel_oserror *err;
        err = nfsrw_readmany(readres_len, readres_data, mount_point, fhandle, offset, count, &nattr );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        update_attrcache( mount_point, fhandle, &nattr );

        return NULL;
} /* endfunction nfs_readmany */



/********* nfs_write *******************************************************

Purpose : Write data to a given file.  Note that routine will also update the
	  attribute  cache entry for the file read from.  If stale data is
	  detected  (NFSERR_STALE), then all cache entries for that file are
	  cancelled.

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

****************************************************************************/

_kernel_oserror *nfs_write
(
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        unsigned offset,
        char *data,
        int count
)
{
        _kernel_oserror *err;
        writeargs wargs;
        attrstat *wres;
        unused_client *nfs_client;

        wargs.file = *fhandle;
        wargs.offset = offset;
        wargs.data.data_len = count;
        wargs.data.data_val = data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        wres = nfsproc_write_2( &wargs, nfs_client->client );
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* upper levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        err = rpcnfs_to_riscos_err( wres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        *nattr = &wres->attrstat_u.attributes;

        update_attrcache( mount_point, fhandle, &wres->attrstat_u.attributes );

        return NULL;
}   /* endfunction nfs_write */



/********* nfs_writemany ***************************************************

Purpose : Write multiple packets of data to a given file.  Note that routine
	  will also update the  attribute  cache entry for the file read
	  from.  If stale data is  detected  (NFSERR_STALE), then all cache
	  entries for that file are  cancelled.

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

***************************************************************************/

_kernel_oserror *nfs_writemany
(
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        unsigned offset,
        char *data,
        int count
)
{
        _kernel_oserror *err;
        err = nfsrw_writemany( nattr, mount_point, fhandle, offset, data, count );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        update_attrcache( mount_point, fhandle, *nattr );

        return NULL;
}  /* endfunction nfs_writemany */



/********* nfs_write_with_appendum *****************************************

Purpose : Write data to a given file.  Note that routine will also update the
	  attribute  cache entry for the file read from.  If stale data is
	  detected  (NFSERR_STALE), then all cache entries for that file are
	  cancelled.

	  But what's the difference between this and nfs_write ?

Inputs : nattr         ptr to ptr, somewhere to store result
       	 mount_point   ptr to mount details
       	 fhandle       ptr to handle of file to write to
       	 offset	       offset in file to write data
       	 data	       ptr to data to write
       	 count	       number of bytes to write

Returns : NULL if found OK, otherwise ptr to error
	  nattr is filled with the attribute data of the file

****************************************************************************/

_kernel_oserror *nfs_write_with_appendum
(
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *fhandle,
        unsigned offset,
        bytes_with_appendum *data,
        unsigned count
)
{
        _kernel_oserror *err;
        writeargs_with_appendum wargs;
        attrstat *wres;
        unused_client *nfs_client;

        wargs.file = *fhandle;
        wargs.offset = offset;
        wargs.data.data_len = count;
        wargs.data.data_val = data;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 2;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        wres = nfsproc_write_with_appendum_2( &wargs, nfs_client->client );
#ifdef PROFILEIT
{
        _kernel_swi_regs r;
        r.r[1] = 1;     /* lower levels */
        _kernel_swi( 0xc0103, &r, &r );
}
#endif
        err = rpcnfs_to_riscos_err( wres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( fhandle );

                return err;
        }

        *nattr = &wres->attrstat_u.attributes;

        update_attrcache( mount_point, fhandle, &wres->attrstat_u.attributes );

        return NULL;
}  /* endfunction nfs_write_with_appendum */



/********* nfs_create *******************************************************

Purpose : Creates an NFS file.  The details of the new file are entered in
	  the caches, and the cache details of the directory where it is
	  created are cancelled ('cos it's just changed !)

Inputs :  fhandle       ptr, to store result
       	  nattr         ptr to ptr, to store result
       	  mount_point   ptr to mount details
       	  dir		ptr to handle of parent directory
       	  filename	ptr to name of file to create
       	  snattr	ptr to attributes of file to create

Returns :  NULL if OK, otherwise ptr to error
	   fhandle filled in with handle of new file
	   nattr filled in with attribute details of new file

****************************************************************************/

_kernel_oserror *nfs_create
(
        nfs_fh *fhandle,
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename,
        sattr *snattr
)
{
        _kernel_oserror *err;
        createargs cargs;
        diropres *cres;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        cargs.where.dir = *dir;
        cargs.where.name = filename;
        cargs.attributes = *snattr;

        cres = nfsproc_create_2( &cargs, nfs_client->client );
        err = rpcnfs_to_riscos_err( cres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( dir );

                return err;
        }

        *fhandle = cres->diropres_u.diropres.file;
        *nattr = &cres->diropres_u.diropres.attributes;

        update_attrcache( mount_point, fhandle, *nattr );
        update_lookupcache( mount_point, dir, filename, fhandle );

        /*
                Date last modified of directory will change.
        */
        cancel_attrcache_by_fhandle( dir );

        return NULL;
}  /* endfunction nfs_create */



/********* nfs_remove *******************************************************

Purpose : Removes (deletes) NFS file.  If this can be done, then all cache
	  entries for the file are cancelled.  Cache entry for parent dir
	  also cancelled since it has now changed.

Inputs : mount_point   ptr to mount details
       	 dir	       ptr to parent directory handle
       	 filename      ptr to filename string of file to delete

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_remove
(
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename
)
{
        _kernel_oserror *err;
        diropargs rargs;
        unused_client *nfs_client;

        rargs.dir = *dir;
        rargs.name = filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        err = rpcnfs_to_riscos_err( nfsproc_remove_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == &mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( dir );
        }
        else if ( !err )
        {
                cancel_lookupcache( mount_point, dir, filename );

                /*
                        Date last modified will change.
                */
                cancel_attrcache_by_fhandle( dir );
        }

        return err;
}  /* endfunction nfs_remove */



/********* nfs_rename *******************************************************

Purpose : Renames an NFS file.  Cache entries for the source are cancelled.
	  The cache is not automatically updated with the new details.

Inputs : mount_point   ptr to mount details
       	 to_dir	       ptr to handle of destination parent dir
       	 to_filename   ptr to filename string of destination
       	 from_dir      ptr to handle of source parent dir
       	 from_filename ptr to filename string of source

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_rename
(
        MountPoint *mount_point,
        nfs_fh *to_dir,
        char *to_filename,
        nfs_fh *from_dir,
        char *from_filename
)
{
        _kernel_oserror *err;
        renameargs rargs;
        unused_client *nfs_client;

        rargs.from.dir = *from_dir;
        rargs.from.name = from_filename;
        rargs.to.dir = *to_dir;
        rargs.to.name = to_filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        err = rpcnfs_to_riscos_err( nfsproc_rename_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == &mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( from_dir );
                cancel_all_caches_by_fhandle( to_dir );
        }
        else if ( err == &mb_nfserr_BadParameters )
        {
                err = &mb_BadRENAME;
        }
        else if ( !err )
        {
                cancel_lookupcache( mount_point, from_dir, from_filename );

                /*
                        Dates last modified will change.
                */
                cancel_attrcache_by_fhandle( from_dir );
                cancel_attrcache_by_fhandle( to_dir );
        }

        return err;
}  /* endfunction nfs_rename */



/********* nfs_mkdir ********************************************************

Purpose : Creates NFS directory.  Updates lookup cache with details of new
	  directory, and cancels cache entries for parent dir 'cos it's been
	  changed.

Inputs :  fhandle      ptr to handle, to be filled in
       	  nattr	       ptr to ptr, to be filled in
       	  mount_point  ptr to mount details
       	  dir	       ptr to handle of parent directory
       	  filename     ptr to name string for new directory
       	  snattr       ptr to new directory attributes

Returns : NULL if found OK, otherwise ptr to error
	  fhandle is filled in with the handle of the new directory
	  nattr filled in with attributes of new dir

****************************************************************************/

_kernel_oserror *nfs_mkdir
(
        nfs_fh *fhandle,
        fattr **nattr,
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename,
        sattr *snattr
)
{
        _kernel_oserror *err;
        createargs cargs;
        diropres *cres;
        unused_client *nfs_client;

        /*
                Get an NFS client
        */
        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        /*
                Set up the arguments and call the routine
        */
        cargs.where.dir = *dir;
        cargs.where.name = filename;
        cargs.attributes = *snattr;

        cres = nfsproc_mkdir_2( &cargs, nfs_client->client );
        err = rpcnfs_to_riscos_err( cres, mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err )
        {
                if ( err == &mb_nfserr_stale )
                        cancel_all_caches_by_fhandle( dir );

                return err;
        }

        *fhandle = cres->diropres_u.diropres.file;
        *nattr = &cres->diropres_u.diropres.attributes;

        /*
                Don't update the attrcache as it isn't returned correctly.
        */
        update_lookupcache( mount_point, dir, filename, fhandle );

        /*
                Date last modified will change.
        */
        cancel_attrcache_by_fhandle( dir );

        return NULL;
}  /* endfunction nfs_mkdir */



/********* nfs_rmdir ********************************************************

Purpose : Removes (deletes) nfs directory.  Cancels all cache entries for specified directory, and for the parent.

Inputs : mount_point   ptr to mount details
       	 dir	       ptr to handle of parent dir
       	 filename      ptr to name string of dir to delete

Returns : NULL if found OK, otherwise ptr to error

****************************************************************************/

_kernel_oserror *nfs_rmdir
(
        MountPoint *mount_point,
        nfs_fh *dir,
        char *filename
)
{
        _kernel_oserror *err;
        diropargs rargs;
        unused_client *nfs_client;

        rargs.dir = *dir;
        rargs.name = filename;

        err = get_nfs_client_for_mp( &nfs_client, mount_point );
        if ( err )
                return err;

        err = rpcnfs_to_riscos_err( nfsproc_rmdir_2( &rargs, nfs_client->client ), mount_point, nfs_client->client );
        release_client( nfs_client );

        if ( err == &mb_nfserr_stale )
        {
                cancel_all_caches_by_fhandle( dir );
        }
        else if ( !err )
        {
                cancel_lookupcache( mount_point, dir, filename );

                /*
                        Date last modified will change.
                */
                cancel_attrcache_by_fhandle( dir );
        }

        return err;
}   /* endfunction nfs_rmdir */

