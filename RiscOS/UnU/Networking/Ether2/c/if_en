/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright(c) 1994 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 */
#include "kernel.h"
#include "swis.h"
#include "delay.h"

#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/mbuf.h"
#include "sys/errno.h"

#include "int_hndlr.h"
#include "xcb.h"
#include "ioc.h"

#include "if_en.h"
#include "e2module.h"

/*
 * XXX TRACE XXX
 *
 * if someone could tell me why this value has
 * been altered to 700 (it is usually 100), I
 * would be really interested
 */
#define HZ 100

static struct en_softc *en_softc[XCB_MAX_ETHERNET_CARDS];

extern void en_io_out(), en_flush_out(), en_io_in();
extern char *ether_sprintf();

extern int callproto();

#define ENCARD_ROM(slot)	(XCB_ADDRESS(FAST, slot))
#define ENCARD_INT_STATUS(slot) (ENCARD_ROM(slot) + 0x2000)

#ifndef NULL
# define NULL 0
#endif

#define EN_TYPE 97

char en_lastlog[64] = { 0 };
char en_lasterr[64] = { 0 };

int encnt = 0;
char slotmap[XCB_SLOTS];
static int en_slots[XCB_SLOTS];

extern void *module_wsp;
struct int_hndlr intr_routine;
extern void en_log();
extern int en_irq_entry();
extern void enable_podule_irqs();
extern void disable_podule_irqs();

extern DibRef dibs[];

extern FilterSingleRef ieeefilter[XCB_MAX_ETHERNET_CARDS];
extern FilterSingleRef e2monitor[XCB_MAX_ETHERNET_CARDS];
extern FilterSingleRef e2sink[XCB_MAX_ETHERNET_CARDS];
extern FilterChainRef e2specific[XCB_MAX_ETHERNET_CARDS];

extern int (*address_filter)(u_int level, u_char *pack_hdr, u_char *mac_addr);

static int pdrops = 0;

/**********************************************************************/

static void nulldev(u_char c)
{
    u_char x;
    x = c;
}

/**********************************************************************/

/*
 * shutdown - go through the motions of taking the NIC off a live
 * network to allow recovery from a ring buffer overflow
 */
static void shutdown(NICRef nic, u_char *TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * test for transmit pending
     * issue the STOP command,
     * clear remote byte counters,
     * wait for RST to come up,
     * put the NIC into loopback,
     * issue the START command.
     */
    *TxPending = nic->command & TXP;
    nic->command = SEL_PAGE(0, NIC_STOPPED);
    nic->rbcr0 = nic->rbcr1 = 0;
    while( !(nic->isr & RST) )
	/* do nothing */
	;

    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);
    nic->command = SEL_PAGE(0, NIC_RUNNING);

    /*
     * acknowledge the RST bit also clear RDC which
     * decides to appear
     */
    nic->isr = (RST | RDC);
}

/**********************************************************************/

/*
 * abort_packet - stop the currently executing send_packet command
 */
static void abort_packet(struct en_softc *en, NICRef nic, u_char *buff_hdr)
{
    /*
     * send the ABORT DMA command, then move the
     * boundary pointer past the unwanted packet
     */
    nic->command = START_DMA(DMA_ABORT);
    nic->bnry = *(buff_hdr + 1);

    /*
     * throw away the data waiting for us at the DMA port
     */
    nulldev(*en->dma_port);
}

/**********************************************************************/

/*
 * drop_packet - discard packet data
 */
static void drop_packet(struct en_softc *en, int datalen)
{
    register volatile u_int *port = en->dma_port;
    int i;
    char buf[128 + 2];

    pdrops++;
    datalen -= PACK_HDR_LEN + CRC_LEN;
    for( i = datalen; i > 0; i -= 128 )
	en_io_in(port, buf, min(i, 128));
}

/**********************************************************************/

/*
 * en_read - read a packet out of the ring buffer (no trailers!)
 */
void en_read(struct en_softc *en, NICRef nic)
{
    register u_int databuff;
    register volatile u_int *port = en->dma_port;
    register struct mbuf *m, *m0 = NULL;
    /*
     * XXX
     *
     * pack_hdr *must* be word aligned - this fact is used by a
     * hacky test for broadcast addresses in the address filters
     */
    u_char pack_hdr[PACK_HDR_LEN];
    u_char buff_hdr[BUFF_HDR_LEN];
    u_short type;
    u_int datalen;
    u_int unit = en->en_unit;
    int i;
    FilterSingleRef fs = NULL;
    RxHdrRef hdr;

#ifdef DEBUG
# if 0
    Printf("\021\02en_read(%d)...", unit);
# else
    Printf("en_read(%d)...", unit);
# endif
#endif

    /* start the Send Packet command */
    *en->page_reg = ((HARD_RESET_OFF | IO_READ) << 16);
    nic->rbcr1 = 0x0f;
    nic->command = START_DMA(DMA_SENDP);

    /* read the buffer header */
    for( i = 0; i < BUFF_HDR_LEN; i += 2)
    {
	databuff = *port;
	buff_hdr[i] = databuff;
	buff_hdr[i + 1] = databuff >> 8;
    }

    /*
     * read the packet length from this header
     */
    datalen = *(u_short *)(buff_hdr + 2);
    if( datalen < (PACK_HDR_LEN + CRC_LEN) )
    {
#ifdef DEBUG
	Printf("bad length (%d) - aborting\n", datalen);
#endif
	abort_packet(en, nic, buff_hdr);
	return;
    }

    /*
     * read the packet header to get dest address, src address
     * and packet type.
     */
    for( i = 0; i < PACK_HDR_LEN; i += 2)
    {
	databuff = *port;
	pack_hdr[i] = databuff;
	pack_hdr[i + 1] = databuff >> 8;
    }

    /*
     * get the type, & decide if we can handle it
     */
    type = ntohs(*(u_short *)(pack_hdr + (2 * HW_ADDR_LEN)));

#ifdef DEBUG
# if 0
    Printf("type = %x\021\07\n", type);
# else
    Printf("type = %x\n", type);
# endif
#endif

    /*
     * 1st discrimination of frame type - is it
     * an IEEE 802.3 or an Ethernet 2.0 frame?
     */
    if( type <= ETHERMTU )
    {
	fs = ieeefilter[unit];
	SET_FRAMELEVEL(type, FRMLVL_IEEE);
    }

    /*
     * it's an Ethernet 2.0 frame, do we have
     * specific or sink filters active?
     */
    else if( e2specific[unit] || e2sink[unit] )
    {
	FilterChainRef fc;

	/*
	 * start by trying to match specific frame types
	 */
	for( fc = e2specific[unit]; fc; fc = fc->fc_next )
	    if( fc->fc_type == type )
	    {
		fs = &fc->fc_filter;
		SET_FRAMELEVEL(type, FRMLVL_E2SPECIFIC);
		break;
	    }

	/*
	 * default to sink filter if no specific matches
	 */
	if( !fc )
	{
	    fs = e2sink[unit];
	    SET_FRAMELEVEL(type, FRMLVL_E2SINK);
	}
    }

    /*
     * all we have left is the Ethernet 2.0 monitor
     */
    else
    {
	fs = e2monitor[unit];
	SET_FRAMELEVEL(type, FRMLVL_E2MONITOR);
    }

#ifdef OldCode
    /*
     * perform address level filtering - at the moment the
     * only filter we can possibly perform is discarding
     * broadcast packets (this driver does not support
     * multicast or promiscuous mode reception).
     */
    if( fs )
    {
	if( fs->fs_addrlevel == ADDRLVL_SPECIFIC && IS_BROADCAST(pack_hdr) )
	{
	    fs = NULL;
	    drop_packet(en, datalen);
	    goto dropcrc;
	}
    }
    else
    {
	/*
	 * no protocols want this frame
	 */
	drop_packet(en, datalen);
	goto dropcrc;
    }
#else
    if( fs )
    {
	/*
	 * use the filtering routine appropriate to
	 * the current level of packet reception
	 */
	if( address_filter(fs->fs_addrlevel, pack_hdr, (u_char *)en->en_addr) )
	{
	    fs = NULL;
	    drop_packet(en, datalen);
	    goto dropcrc;
	}
    }
    else
    {
	/*
	 * no protocols want this frame
	 */
	drop_packet(en, datalen);
	goto dropcrc;
    }
#endif
    
#ifdef OldCode
    if( (m = (m0 = m_get(M_DONTWAIT, MT_DATA))) == (struct mbuf *)0 )
    {
	fs = NULL;
	drop_packet(en, datalen);
	goto dropcrc;
    }
#else
    if( (m = (m0 = ALLOC_S(MINCONTIG, NULL))) == (struct mbuf *)0 )
    {
	fs = NULL;
	drop_packet(en, datalen);
	goto dropcrc;
    }
    m->m_type = MT_DATA;
#endif

    hdr = mtod(m0, RxHdrRef);
    m0->m_len = sizeof(RxHdr);

    hdr->rx_tag = 0;
    memcpy(hdr->rx_src_addr, pack_hdr + HW_ADDR_LEN, HW_ADDR_LEN);
    memcpy(hdr->rx_dst_addr, pack_hdr, HW_ADDR_LEN);
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    *(u_short *)(&hdr->_spad[0]) = 0;
    *(u_short *)(&hdr->_dpad[0]) = 0;

    /*
     * adjust datalen to account for bytes within the packet header
     * and the unwanted crc bytes at the end of the packet; read
     * data out of the packet into a large mbuf or an mbuf chain.
     */
    datalen -= (PACK_HDR_LEN + CRC_LEN);

#ifdef OldCode
    /*
     * XXX TRACE XXX
     *
     * this could be much more efficient with the new mbuf manager
     */
    for( i = datalen; i > 0; i -= (OLDMLEN - 2) )
    {
	/* allocate another mbuf */
	if( (m->m_next = m_get(M_DONTWAIT, MT_DATA)) == (struct mbuf *)0 )
	{
	    fs = NULL;
	    m_freem(m0);
	    drop_packet(en, i + PACK_HDR_LEN + CRC_LEN);
	    goto dropcrc;
	}

	m = m->m_next;
	en_io_in(port, mtod(m, u_char *), min(i, OLDMLEN - 2));
	m->m_len = min(i, OLDMLEN - 2);
    }
#else
    {
	struct mbuf *pd;

	/*
	 * XXX TRACE XXX
	 *
	 * I am slightly worried by the use of MLEN - 2 in the
	 * old code: I suspect that this was just a case of
	 * someone being conservative (and NOT COMMENTING THEIR
	 * CODE!), without understanding that the data overrun
	 * in the data copiers is already catered for safely in
	 * the fact that all mbufs have an even length.
	 *
	 * The original RISC iX drivers certainly use MLEN without
	 * any trouble.
	 */
	if( (m->m_next = ALLOC(datalen, NULL)) == NULL )
	{
	    fs = NULL;
	    drop_packet(en, datalen + PACK_HDR_LEN + CRC_LEN);
	    goto dropcrc;
	}

	/*
	 * run down the mbufs, filling them in
	 */
	for( pd = m->m_next; pd; pd = pd->m_next )
	{
	    pd->m_type = MT_DATA;
	    en_io_in(port, mtod(pd, char *), pd->m_len);
	    datalen -= pd->m_len;
	}

	if( datalen != 0 )
	    panic("BAD DATALEN");
    }
#endif

  dropcrc:
    /* now read the CRC bytes & drop them on the floor */
    for( i = 0; i < CRC_LEN; i += 2 )
	nulldev(*port);

    /*
     * check that remote DMA has completed
     */
    if( !(nic->isr & RDC) )
    {
	/*
	 * this is not yet a fatal error - give it
	 * a chance to recover then try again
	 */
	MICRODELAY(RDC_RECOVER_PERIOD);

	if( !(nic->isr & RDC) )
	{
	    sprintf(en_lastlog, "Unit %d: RDC failure in en_read\n",
		    en->en_unit);
	    type = 0;
	    abort_packet(en, nic, buff_hdr);
	    goto notify_protocol;
	}
    }

    /* acknowledge end of remote DMA */
    nic->isr = RDC;

  notify_protocol:
    if( fs )
	callproto(dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
    else if( m0 )
    {
#ifdef OldCode
	m_freem(m0);
#else
	FREEM(m0);
#endif
    }
}

/**********************************************************************/

/*
 * start_tx - send a transmit packet command to the NIC. MUST be called
 * at splet.
 */
static void start_tx(struct en_softc *en, NICRef nic)
{
    TxqRef txq = en->TxPending;

    /* set up the control registers */
    nic->tpsr = txq->TxStartPage;
    nic->tbcr0 = txq->TxByteCount;
    nic->tbcr1 = txq->TxByteCount >> 8;

    /* start the transmission */
    nic->command = START_DMA(DMA_IDLE) | TXP;
}

/**********************************************************************/

/*
 * startup - bring the NIC back onto a live network following a shutdown
 */
static void startup(struct en_softc *en, NICRef nic, u_char TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * take the NIC out of loopback & onto the live network
     */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /*
     * restart transmit if lost by shutdown
     */
    if( (TxPending) && !(nic->isr & (PTX | TXE)) )
	start_tx(en, nic);
}

/**********************************************************************/

/*
 * en_recv - deal with received packet interrupts
 */
void en_recv(struct en_softc *en, NICRef nic)
{
    u_char overflowed = 0;
    u_char current_page, TxPending;

    /*
     * loop until all packets read
     */
    while( (nic->isr & PRX) )
    {
	/*
	 * acknowledge this interrupt, then read where the
	 * start of the free buffer is
	 */
	nic->isr = PRX;
	nic->command = SEL_PAGE(1, NIC_RUNNING);
	current_page = nic->curr;
	nic->command = SEL_PAGE(0, NIC_RUNNING);

	/*
	 * loop until the boundary pointer reaches the start
	 * of the free buffer
	 */
	while( nic->bnry != current_page )
	{
	    /* increment count of received packets */
	    en->en_ipackets++;

	    /*
	     * check for receive ring overflows
	     */
	    if( (nic->isr & OVW) )
	    {
		++overflowed;
		shutdown(nic, &TxPending);

		/* remove a packet & acknowledge the overflow */
		en_read(en, nic);
		nic->isr = OVW;
	    }
	    else
		/* read next packet */
		en_read(en, nic);
	}
    }

    /* restart reception if necessary */
    if( overflowed )
    {
	startup(en, nic, TxPending);
    }
}

/**********************************************************************/

/*
 * tx_done - remove transmit request from head of queue, start next
 * transmit if required
 */
static void tx_done(struct en_softc *en, NICRef nic)
{
    TxqRef txdesc;

    /* act cautious */
    if( !en->TxPending )
    {
	sprintf(en_lasterr,"Unit %d: packet transmitted from empty queue",
		en->en_unit);
	return;
    }

    /* put this transmit request back into the free list */
    if( en->TxqFree )
    {
	for( txdesc = en->TxqFree; txdesc->TxNext; txdesc = txdesc->TxNext )
	    /* do nothing */
	    ;
	txdesc->TxNext = en->TxPending;
    }
    else
	en->TxqFree = en->TxPending;

    txdesc = en->TxPending->TxNext;
    en->TxPending->TxNext = (TxqRef)NULL;

    /* start next transmit if one there */
    if( (en->TxPending = txdesc) )
	start_tx(en, nic);
}

/**********************************************************************/

/*
 * en_txdone - remove a successfully transmitted packet from the queue,
 * then start next packet if necessary.
 */
void en_txdone(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count of
     * transmitted packets
     */
    nic->isr = PTX;
    en->en_opackets++;

    /* check for Signal Quality Error if this is appropriate */
    if( (en->en_flags & EN_SQETEST) &&
       !(nic->tsr & COL) && (nic->tsr & CDH) )
    {
	/* do not repeatedly send out this message */
	if( !(en->en_flags & EN_SQEINFORMED) )
	{
	    sprintf(en_lastlog,
		    "Unit %d: CD/Heartbeat failure "
		    "(is the AUI cable connected?)\n",
		    en->en_unit);
	    en->en_flags |= EN_SQEINFORMED;
	}
    }

    /* test for recovered collisions */
    if( nic->tsr & COL )
    {
	u_char n_colls = nic->ncr & 0x0f;

	en->ncoll += n_colls;
	en->en_collisions += n_colls;
	en->en_flags &= ~EN_SQETEST;
    }
    else
	en->en_flags |= EN_SQETEST;

    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_txfailed - `recover' from a transmit error. this means log the
 * failure then forget about the packet it happened on.
 */
static void en_txfailed(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count
     * of Tx errors
     */
    nic->isr = TXE;
    en->en_oerrors++;

    /* check for aborted transmit (excess collisions) */
    if( nic->tsr & ABT )
    {
	++en->nxscoll;
	en->en_collisions += 16;
    }

    /* check for FIFO underrun */
    if( nic->tsr & FU )
    {
	++en->nundrn;
    }

    /* now get rid of this transmit request */
    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_rxfailed - deal with receive errors. this means log them then
 * forget about them.
 */
void en_rxfailed(struct en_softc *en, NICRef nic)
{
    u_char err_count, max_count = 0;

    /*
     * acknowledge both the receive error & counter
     * overflow interrupts, then increment the count
     * of bad receives
     */
    nic->isr = (RXE | CNT);
    en->en_ierrors++;

    /* frame alignment errors */
    err_count = nic->cntr0;
    en->nfae += err_count;
    max_count = max(max_count, err_count);

    /* crc errors */
    err_count = nic->cntr1;
    en->ncrc += err_count;
    max_count = max(max_count, err_count);

    /* frames lost */
    err_count = nic->cntr2;
    en->nfrl += err_count;
    max_count = max(max_count, err_count);

    /*
     * if all these counters returned zero, then assume
     * problem was a fifo overrun. (a bit crude)
     */
    if( max_count == 0 )
    {
	++(en->novrn);
    }
}

/**********************************************************************/

/*
 * en_intr - entry point for ISR, steps are:
 *
 * 1 - handle all received packets
 *
 * 2 - deal with packet transmitted ints.
 *
 * 3 - check for transmit errors
 *
 * 4 - check for receive errors
 *
 * 5 - check for overwrite warning (should not happen - this is tested
 *     for within the receive packet code)
 *
 * 6 - deal with tally counter overflows
 *
 */
static void en_intr(int unit)
{
    register struct en_softc *en = en_softc[unit];
    register NICRef nic = en->Chip;
    u_char TxPending;

    /* loop until all ints cleared */
    while( nic->isr )
    {
	/* stage 1 - received packets */
	while( nic->isr & PRX )
	    en_recv(en, nic);

	/* stage 2 - transmitted packets */
	while( nic->isr & PTX )
	    en_txdone(en, nic);

	/* stage 3 - transmit errors */
	while( nic->isr & TXE )
	    en_txfailed(en, nic);

	/* stage 4 - receive errors */
	while( nic->isr & RXE )
	    en_rxfailed(en, nic);

	/* stage 5 - overwrite warning */
	while( nic->isr & OVW )
	    if( nic->isr & PRX )
		/* more packets have arrived so read them out */
		en_recv(en, nic);
	    else
	    {
		shutdown(nic, &TxPending);
		nic->isr = OVW;
		startup(en, nic, TxPending);
	    }

	/* stage 6 - tally counter overflow */
	while( nic->isr & CNT )
	    if( nic->isr & RXE )
		/* got more errors */
		en_rxfailed(en, nic);
	    else
	    {
		/* this is also bad news */
		sprintf(en_lastlog,"Count of error registers:\n"
		       "FAE: %x "
		       "CRC: %x "
		       "FRL: %x\n",
		       nic->cntr0, nic->cntr1, nic->cntr2);
		sprintf(en_lasterr,"en_intr: CNT with no receive errors");
	    }

	/* all over bar the shouting - test for extraneous bits */
	if( nic->isr & RDC )
	    sprintf(en_lasterr,"en_intr: RDC signalled");
	else if( nic->isr & RST )
	    sprintf(en_lasterr,"en_intr: RST signalled");
    }
}

/**********************************************************************/

/*
 * give the Ethernet card a hard reset
 */
static void en_reset_card(int slot)
{
     *((unsigned int *)ENCARD_PAGE_REG(slot)) = (HARD_RESET_ON << 16);
}

/**********************************************************************/

void decl_xcb_interrupt(int slot, struct int_hndlr *hndlr, int prior)
{
    _kernel_swi_regs rin, rout;
    static int claimed;

    if( claimed != 0x091067 ) /* Only claim the vector once ! */
    {
	intr_routine = *hndlr;
	rin.r[0] = 2;
	rin.r[1] = (int)en_irq_entry;
	rin.r[2] = (int)module_wsp;

	(void)_kernel_swi(XOS_Bit | OS_Claim, &rin, &rout);
	claimed = 0x091067;
    }
}

/**********************************************************************/

/*
 * high priority XCB card initialisation - reset the card
 */
static void en_init_high(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/*
 * low priority XCB card initialisation - first round with ints off
 * allocates memory for control structures; second round declares the driver
 * to the network interface code.
 */
static void en_init_low(int slot, int irqs_on)
{
    if( !irqs_on )
    {
	static int enunits;
	struct en_softc *en;
	int unit = enunits++;
	int i;
	u_int *romdata;

	/* record which logical slot this is */
	slotmap[slot] = unit;

	/*
	 * check for too many Ethernet (version I or II) cards.
	 */
	if (!xcb_add_ethernet_card (enunits, slot))
	    return;

	/* get some memory for the control structure */
	en = (struct en_softc *)malloc(sizeof(*en));
	memset ( (char *) en ,	0, sizeof(struct en_softc));
	en_softc[unit] = en;

	/* initialise the en_softc structure */
	en->en_unit = unit;
	en->en_slot = slot;
	en->en_flags = 0;
	en->Chip = (NICRef)ENCARD_NIC_REGS(slot);
	en->dma_port = (u_int *)ENCARD_REMOTE_DMA(slot);
	en->page_reg = (u_int *)ENCARD_PAGE_REG(slot);

	for( i = 0; i < MAXTXQ; ++i )
	{
	    en->TxqPool[i].TxNext = (i < (MAXTXQ - 1)) ?
				     &(en->TxqPool[(i + 1)]) : (TxqRef)NULL;
	    en->TxqPool[i].TxStartPage = i * PAGES_PER_TX;
	}
	en->TxqFree = en->TxqPool;
	en->TxPending = (TxqRef)NULL;

	/* read the Ethernet hardware address */
	for( i = 0, romdata = (u_int *)(ENCARD_ROM(slot) + HWADDR_ADDR);
	    i < HW_ADDR_LEN; ++i )
	    en->en_addr[i] = *romdata++;

	/* read & check the revision number */
	if( (en->en_rev = *((u_char *)(ENCARD_ROM(slot) + REVNO_ADDR))) == 0 ||
	   en->en_rev == 0xff )
	{
	    /* obsolete hardware */
	    sprintf(en_lasterr, "Ethernet II card in slot %d ignored *OBSOLETE"
		   " REVISION 0x%x*\n", slot, en->en_rev);
	    en->en_flags |= EN_FAULTY;
	    return;
	}

	/* declare the ISR to the XCB manager */
	en->en_handler.ih_fn = en_intr;
	en->en_handler.ih_farg = unit;
	decl_xcb_interrupt(slot, &(en->en_handler), PRIO_ET);

	/* declare the interrupt sense for old-fashioned machines */
	en->en_sense.flag = (int *)ENCARD_INT_STATUS(slot);
	en->en_sense.mask = EN_INTR_MASK;
    }
    else
    {
	int unit = slotmap[slot];
	struct en_softc *en;

	if( unit >= XCB_MAX_ETHERNET_CARDS )
	    return;
	else
	    en = en_softc[unit];

	/* run the diagnostics */
	(void)en_post(en, 0);
    }
}

/**********************************************************************/

/*
 * XCB shutdown entry point - reset the card
 */
static void en_shutdown(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/*
 * run power on self test for a card
 */
static int en_post(struct en_softc *en, int loopback_only)
{
    int retc;

    if( (en->en_flags & EN_FAULTY) )
	/* do not run the tests */
	return(0);

    /* bring the card out of reset */
    *en->page_reg = (HARD_RESET_OFF << 16);

    /* run the diagnostic tests */
    if( !(retc = en_run_diags(en, loopback_only)) &&
       !(en->en_flags & EN_RECOVERABLE_ERROR) )
	en->en_flags |= EN_FAULTY;

    /* put the reset back on & return status */
    *en->page_reg = (HARD_RESET_ON << 16);
    return(retc);
}

/**********************************************************************/

/*
 * configure the NIC for diagnostic tests
 */
static void en_setup_diags(struct en_softc *en, NICRef nic,
			   u_char loop_mode, u_char manual_crc)
{
    int i;

    /*
     * must ensure the NIC is stopped - the act of starting
     * initialises its internal FIFO pointers. must also clear any
     * previous loopback mode - can only enter a loopback mode from
     * normal operation
     */
    nic->tcr = LOOP_MODE(LIVE_NET);
    if( (nic->isr & RST) )
	/* clear any outstanding reset signal */
	nic->isr = RST;
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    for( i = 0; i < STP_TIMEO; ++i )
    {
	if( (nic->isr & RST) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == STP_TIMEO )
    {
	sprintf(en_lasterr, "Unit %d: NIC has not reset\n",
	    slotmap[en->en_slot]);
	return;
    }

    /*
     * now set tcr to required loopback mode and
     * CRC type, then clear interrupts & mask
     * them all out
     */
    nic->tcr = LOOP_MODE(loop_mode) | manual_crc;
    nic->isr = 0xff;
    nic->imr = 0;

    /*
     * set up data configuration register
     */
    nic->dcr = WTS | FIFO_THRESH(WORD_THRESH4);

    /*
     * set parameters on page 1 - MAC address
     */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * bring the NIC back to page 0, alive & kicking
     */
    nic->command = SEL_PAGE(0, NIC_RUNNING);
}

/**********************************************************************/

/*
 * calculate the Autodin II CRC for the passed data
 */
static u_char *calc_crc(u_char *data, int datalen)
{
    u_long crc, swap = 0;
    int i, j;
    static u_char retc[sizeof(crc)];

    crc = ~0;
    for( i = 0; i < datalen; ++i )
    {
	u_char next = *data++;
	for( j = 0; j < NBBY; ++j )
	{
	    if( (next & 1) ^ (crc >> 31) )
		crc = (crc << 1) ^ POLYNOMIAL;
	    else
		crc <<= 1;
	    next >>= 1;
	}
    }

    /* reverse, nibble swap & complement the result */
    for( i = 0; i < (NBBY * sizeof(crc)); ++i )
    {
	swap <<= 1;
	swap |= ((crc & 0x01) ? 1 : 0);
	crc >>= 1;
    }

    for( i = 0; i < sizeof(crc); ++i)
    {
	retc[i] = ~(swap & 0xff);
	swap >>= NBBY;
    }
    return(retc);
}

/**********************************************************************/

/*
 * build a loopback test packet - this is currently all zeros, plus an
 * appropriate CRC
 */
static void build_tpkt(struct en_softc *en, TestPacket *test_pack)
{
    int i;
    u_char *cptr;

    /*
     * check size of TestPacket to make sure no padding is present
     */
    if( sizeof(TestPacket) != (TESTP_LEN + CRC_LEN) )
	panic("en: bad size for TestPacket\n");

    /*
     * build a packet full of zeroes then fill in the source
     * and destination address
     */
    memset ((caddr_t)test_pack, 0, TESTP_LEN);
    memcpy ((caddr_t)test_pack->src_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);
    memcpy ((caddr_t)test_pack->dst_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);

    /*
     * calculate & fill in the packet's CRC
     */
    for( i = 0, cptr = calc_crc((u_char *)test_pack, TESTP_LEN);
	i < CRC_LEN; ++i, ++cptr)
	test_pack->crc_bytes[i] = *cptr;
}

/**********************************************************************/

/*
 * run loopback tests in given loopback mode. manual_crc is the CRC
 * source used to program tcr (0 if NIC is to generate CRC, !0 if
 * CRC not appended after transmit). routine returns 0 if test failed,
 * else !0
 */
static int en_loopback(struct en_softc *en, TestPacket *test_pack,
		       u_char loop_mode, u_char manual_crc)
{
    NICRef nic = en->Chip;
    int i, pack_len;

    /*
     * set up the NIC, then start the transmit
     */
    en_setup_diags(en, nic, loop_mode, manual_crc);
    pack_len = TESTP_LEN + ((manual_crc) ? CRC_LEN : 0);
    nic->tpsr = 0;
    nic->tbcr0 = pack_len << 1;
    nic->tbcr1 = pack_len >> 7;
    nic->command = START_DMA(DMA_IDLE) | TXP;

    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->isr & (PTX | TXE)) )
	    /* packet has gone out */
	    break;

	MICRODELAY(1000000 / HZ);

    }

    if( (loop_mode == LOOPBACK3) && (nic->isr == TXE || i == LB_TIMEO) )
	return(lb3_failed(en, nic));
    else if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) transmit timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * now wait for the receive to come in
     */
    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->rsr & (PRX | CRCE | FAE)) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) receive timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * check the result from the test
     */
    if( manual_crc )
    {
	if( (nic->isr & RXE) )
	{
	    sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC recognition\n",
		slotmap[en->en_slot], loop_mode, manual_crc);
	    return(0);
	}
    }
    else if( loop_mode != LOOPBACK3 )
    {
	u_char nic_crc, *ok_crc;

	/*
	 * junk unwanted data from the FIFO
	 */
	for( i = 0; i < N_JUNK; ++i )
	    nulldev(nic->fifo);

	/*
	 * now read the CRC back & check it against what is expected
	 */
	for(i = 0, ok_crc = test_pack->crc_bytes;
	    i < CRC_LEN; ++i, ++ok_crc )
	    if( (nic_crc = nic->fifo) != *ok_crc )
	    {
		sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC (%x != %x)\n",
		    slotmap[en->en_slot], loop_mode, manual_crc,
		    nic_crc, *ok_crc);
		return(0);
	    }
    }

    /* tests passed successfully */
    return(1);
}

/**********************************************************************/

/*
 * en_run_diags - run a set of internal diagnostics. return 0 if
 * something failed, else 1.
 */
static int en_run_diags(struct en_softc *en, int loopback_only)
{
    register int i;
    NICRef nic = en->Chip;
    TestPacket lback_data;
    u_char *dptr = (u_char *)(&lback_data);
    static int lb_sequence[] = { LOOPBACK1, LOOPBACK2, LOOPBACK3 };

    if( !loopback_only )
    {
	u_int pattern[PAT_LEN];

	/* build the test pattern */
	for( i = 0; i < (PAT_MID - 1); ++i)
	{
	    pattern[i] = O(i);
	    pattern[i + PAT_MID] = Z(i);
	}
	pattern[PAT_MID - 1] = 0;
	pattern[PAT_LEN - 1] = 0xffff;

	/* configure the NIC in an appropriate mode */
	en_setup_diags(en, en->Chip, LOOPBACK1, 0);

	/* run the test for all pages */
	for( i = 0; i < (NIC_BUFFER / NIC_PAGE); ++i )
	    if( !en_memtest(en, i, pattern) )
		return(0);
    }

    /*
     * run loopback tests - make sure the NIC is in some
     * sensible state, build the test packet & copy it
     * into on-card RAM
     */
    en_setup_diags(en, en->Chip, LOOPBACK1, 0);
    build_tpkt(en, &lback_data);

    *en->page_reg = ((HARD_RESET_OFF | IO_WRITE) << 16);
    nic->rbcr0 = ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    /*
     * the NIC is loaded using word wide transfers, but can only
     * read byte wide for loopback testing. Therefore need to
     * write each byte from the packet into a word of memory.
     */
    nic->rsar0 = nic->rsar1 = 0;
    nic->rbcr0 = sizeof(TestPacket) << 1;
    nic->rbcr1 = sizeof(TestPacket) >> 7;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0; i < sizeof(TestPacket); ++i, ++dptr )
	*en->dma_port = (*dptr << 16) | (*dptr << 24);

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote DMA failure\n",
	    slotmap[en->en_slot]);
	return(0);
    }
    else
	/* acknowledge the DMA completion */
	nic->isr = RDC;

    /* run a cable check before trying loopback tests */
    if( !check_cable(en) )
    {
	en->en_flags |= EN_RECOVERABLE_ERROR;
	return(0);
    }
    else
	en->en_flags &= ~EN_RECOVERABLE_ERROR;

    for( i = 0; i < (sizeof(lb_sequence) / sizeof(lb_sequence[0])); ++i )
    {
	register u_int mode = lb_sequence[i];

	if( !en_loopback(en, &lback_data, mode, 0) )
	    return(0);

	if( !en_loopback(en, &lback_data, mode, 1) )
	    return(0);
    }

    /*
     * all tests passed - return OK status
     */
    return(1);
}

/**********************************************************************/

/*
 * run a memory test on the given page
 */
static int en_memtest(struct en_softc *en, int page, u_int *pattern)
{
    NICRef nic = en->Chip;
    int i, j;
    u_int nextword;

    /*
     * write the pattern into RAM
     */
    *en->page_reg = ((HARD_RESET_OFF | IO_WRITE) << 16);
    nic->rbcr0 = ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = NIC_PAGE;
    nic->rbcr1 = NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0, j = 0; i < (NIC_PAGE >> 1); ++i )
    {
	*en->dma_port = (pattern[j] << 16);
	if( ++j == PAT_LEN )
	    j = 0;
    }

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote write has not completed\n",
	    slotmap[en->en_slot]);
	return(0);
    }
    else
	nic->isr = RDC;

    /* now do the read & check */
    *en->page_reg = ((HARD_RESET_OFF | IO_READ) << 16);
    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = NIC_PAGE;
    nic->rbcr1 = NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_READ);
    for( i = 0, j = 0; i < (NIC_PAGE >> 1); ++i )
    {
	if( (nextword = (*en->dma_port & 0xffff)) != pattern[j] )
	{
	    sprintf(en_lasterr,
		"Unit %d (slot %d): RAM failure page %d, word %d (%x != %x)\n",
		slotmap[en->en_slot], en->en_slot, page,
		i, nextword, pattern[j]);
	    return(0);
	}

	if( ++j == PAT_LEN )
	    j = 0;
    }

    /* finished OK */
    return(1);
}

/**********************************************************************/

/*
 * see what has gone wrong with mode 3 loopback (onto live net,
 * therefore susceptible to genuine collisions)
 */
static int lb3_failed(struct en_softc *en, NICRef nic)
{
    u_char txstat = nic->tsr;
    int unit = slotmap[en->en_slot];

    if( !(txstat & COL) )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (no COL)\n",
	    unit);
	return(0);
    }
    else if( (txstat & ABT) )
    {
	sprintf(en_lasterr, "Unit %d: bad termination\n",
	    unit);
	return(0);
    }
    else if( nic->ncr == 0 )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (COL with 0 collisions)\n",
	    unit);
	return(0);
    }
    else
    {
	return(1);
    }
}

/**********************************************************************/

/*
 * attempt to send test packet out in non-loopback mode, use
 * transmit status to work out whether or not the cabling is OK
 */
static int check_cable(struct en_softc *en)
{
    NICRef nic = en->Chip;
    int i, unit = slotmap[en->en_slot];
    char *errortype = NULL;

    /*
     * make sure the NIC is stopped, set it up, then mask out
     * interrupts and start it running
     */
    if( !en_setup(unit) )
    {
	sprintf(en_lasterr, "Could not run cable check for unit %d\n",
	    unit);
	return(0);
    }
    else
    {
	nic->imr = 0;
	nic->command = SEL_PAGE(0, NIC_RUNNING);
	nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);
    }

    nic->rsar0 = nic->rsar1 = 0;
    nic->tbcr0 = TESTP_LEN;
    nic->tbcr1 = TESTP_LEN >> 8;
    nic->command = START_DMA(DMA_IDLE) | TXP;

    /* wait until the packet is transmitted */
    for( i = 0; i < CC_TIMEO; ++i )
    {
	if( (nic->isr & (PTX | TXE)) )
	    break;
	MICRODELAY(1000000 / HZ);
    }

    if( i == CC_TIMEO || (nic->tsr & (CRS | CDH)) )
	errortype = "connected";
    else if( (nic->isr & TXE) )
	errortype = "terminated";

    if( errortype )
    {
	sprintf(en_lasterr, "Cable is not %s at unit %d\n",
	    errortype, unit);
	return(0);
    }
    else
	return(1);
}

/**********************************************************************/

/*
 * en_setup - initialise the NIC, but do not bring it up onto the network.
 * returns <> 0 if all OK, 0 if hardware determined to be faulty.
 */
static int en_setup(int unit)
{
    struct en_softc *en = en_softc[unit];
    NICRef nic = en->Chip;

    /* test for faulty hardware already detected */
    if( en->en_flags & EN_FAULTY )
	return(0);

    /* bring the card out of reset */
    *en->page_reg = (HARD_RESET_OFF << 16);

    /* wait for a bit 'till reset trickles through */
    MICRODELAY(25);

    /* initialise the command register */
    nic->command = CMD_INIT_VALUE;

    /*
     * set up the Data Configuration Register:
     *
     * 16-bit data transfers,
     * normal operation,
     * auto-initialise remote,
     * fifo threshold of 4 words.
     */
    nic->dcr = DCR_INIT_VALUE | FIFO_THRESH(WORD_THRESH4);

    /* clear remote byte count registers */
    nic->rbcr0 = nic->rbcr1 = 0;

    /*
     * set up the Receive Configuration Register:
     *
     * accept broadcast packets
     */
    nic->rcr = RCR_INIT_VALUE;

    /* put the NIC into loopback mode */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);

    /* set up the receive buffer ring */
    nic->bnry = nic->pstart = RX_START;
    nic->pstop = RX_END;

    /*
     * clear all bits in the ISR, then set up the IMR
     *
     * interrupts required:
     *
     * packet received,
     * packet transmitted,
     * receive error,
     * transmit error,
     * overwrite warning,
     * counter overflow.
     *
     * NOTE: write clear value to ISR twice to ensure all ints cleared
     */
    nic->isr = 0xff;
    nic->isr = 0xff;
    nic->imr = IMR_INIT_VALUE;

    /* select page 1 & set physical address */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * multicast filters: pass all multicast
     * packets (when AM bit is set in rcr)
     */
    nic->mar0 = nic->mar1 = nic->mar2 = nic->mar3 = 0xff;
    nic->mar4 = nic->mar5 = nic->mar6 = nic->mar7 = 0xff;

    /* set the current page register for remote DMA */
    nic->curr = RX_START;

    /* put the NIC back to page 0 */
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    /* all done OK */
    return(1);
}

/**********************************************************************/

/*
 * en_forcepost - set the EN_RECOVERABLE_ERROR flag; this will force
 * a power-on self-test when en_bringup() is called.
 */
void en_forcepost(int unit)
{
    en_softc[unit]->en_flags |= EN_RECOVERABLE_ERROR;
}

/**********************************************************************/

/*
 * en_bringup - bring the card up live onto the network - returns 0
 * if all OK, else errno.
 */
static int en_bringup(int unit)
{
    register struct en_softc *en = en_softc[unit];
    int s;

    /* do not do this if already running */
    if( en->en_flags & EN_RUNNING )
    {
	return(0);
    }

    /*
     * check to see that card passed diagnostic tests
     */
    if( (en->en_flags & EN_RECOVERABLE_ERROR) )
    {
	/* POST detected no network - try again */
	if( !en_post(en, 1) )
	    /*
	     * do not bring this network up - unit is either
	     * faulty or still has a recoverable error
	     */
	    return((en->en_flags & EN_FAULTY) ? ENXIO : ETIMEDOUT);
    }

    if( !en_setup(unit) )
	/*
	 * unit is faulty
	 */
	return(ENXIO);

    s = splet();

    /* set the NIC running, take it out of loopback mode */
    en->Chip->command = SEL_PAGE(0, NIC_RUNNING);
    en->Chip->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /* mark this interface as active */
    en->en_flags |= EN_RUNNING;

    /* all done */
    splx(s);
    return(0);
}

/**********************************************************************/

en_init(void)
{
    int i;
    u_char buffer[16];
    _kernel_oserror *e;
    _kernel_swi_regs rin,rout;
    int s;

    s = splet();
    for( i = 0; i < XCB_SLOTS; ++i )
    {
	en_slots[i] = 0;
	slotmap[i] = -1;

	rin.r[3] = i;
	if( (e =_kernel_swi(XOS_Bit | Podule_ReadID, &rin, &rout)) == NULL )
	{
	    rin.r[2] = (int)buffer;
	    rin.r[3] = i;
	    e =_kernel_swi(XOS_Bit | Podule_ReadHeader, &rin, &rout);

	    if( ((buffer[3]) | (buffer[4] << 8)) == EN_TYPE )
	    {
		en_slots[i] = (++encnt);
		en_init_high(i);
	    }
	}
    }

    if( encnt == 0 )
    {
	splx(s);
	return;
    }

    for( i = 0; i < XCB_SLOTS; ++i )
	if( en_slots[i] )
	    en_init_low (i, 0);

    splx(s);

    for( i = 0; i < XCB_SLOTS; i++ )
	if( en_slots[i] )
	    en_init_low (i, 1);

    rin.r[0] = (int)"Inet$EnCount";
    rin.r[1] = (int)&encnt;
    rin.r[2] = 4;
    rin.r[3] = 0;
    rin.r[4] = 1;
    _kernel_swi(XOS_Bit | OS_SetVarVal, &rin, &rout);

    rin.r[0] = (int)"Inet$EtherType";
    rin.r[1] = (int)"en0";
    rin.r[2] = 3;
    rin.r[3] = 0;
    rin.r[4] = 0;
    _kernel_swi(XOS_Bit | OS_SetVarVal, &rin, &rout);
}

/**********************************************************************/

int en_transmit(_kernel_swi_regs *r)
{
    u_int flags = r->r[0];
    u_int unit = r->r[1];
    u_int type = r->r[2];
    struct mbuf *m, *m0 = (struct mbuf *)(r->r[3]);
    char *edst = (char *)(r->r[4]);
    char *esrc = (flags & TX_FAKESOURCE) ? (char *)r->r[5] : 0;
    struct en_softc *en = en_softc[unit];
    int error = 0;
    int s = splet();

#ifdef DEBUG
    Printf("en_transmit: flags %d unit %d type %x m0 %x\n",
	   r->r[0], r->r[1], r->r[2], r->r[3]);
#endif

    if( flags >= TX_1STRESERVED )
	error = EINVAL;
    else if( unit >= encnt )
	error = ENXIO;
    else if( !(en->en_flags & EN_RUNNING) )
	error = ENETDOWN;

    /*
     * run down the supplied mbuf list, transmitting each
     * chain, until an error is flagged.  all mbuf chains
     * not transmitted before an error condition arises
     * are silently dropped
     */
    while( m0 )
    {
	m = m0;
	m0 = m0->m_list;

	if( !error )
	    error = tx_mbufs(en, m, edst, type, esrc);

	if( !(flags & TX_PROTOSDATA) )
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	}
    }

    /*
     * all done
     */
    splx(s);
    return (error);
}

/**********************************************************************/

int en_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int i;

    for( i = 0; i < XCB_SLOTS; i++ )
    {
	if( (en_slots[i]) && (*(int *)ENCARD_INT_STATUS(i) & 1) )
	{
	    set_irqsareoff();
	    en_intr(slotmap[i]);
	    clear_irqsareoff();
	    return (0);
	}
    }
    return (1);
}

/**********************************************************************/

void en_final(void)
{
    _kernel_oserror *e;
    _kernel_swi_regs rin, rout;
    int i;

    for( i = 0; i < 4; i++ )
    {
	if (en_slots[i])
	    en_shutdown (i);
    }

    rin.r[0] = 2;
    rin.r[1] = (int) en_irq_entry;
    rin.r[2] = (int) module_wsp;
    e = _kernel_swi(XOS_Bit | OS_Release, &rin, &rout);
}

/**********************************************************************/

u_char *en_addresses(int unit)
{
    struct en_softc *en = en_softc[unit];

    return((u_char *)en->en_addr);
}

/**********************************************************************/

prenstats(int flag)
{
    struct en_softc *en;
    int i, unit;
    int enfound = 0;
    int first = 1;
    int filters_active;

    for( unit = 0; unit < encnt; ++unit)
    {
	int slot;

	en = en_softc[unit];
	filters_active = 0;

	if( en->en_flags & EN_FAULTY )
	{
	    printf("Unit %d is FAULTY. Try machine reset to clear\n", unit);
	    continue;
	}

	if (first)
	    first = 0;
	else
	    printf("\n");

	if( encnt > 1 )
	    printf("Unit %d\n\n", unit);

	for( slot = 0; slot < XCB_SLOTS; ++slot )
	    if( slotmap[slot] == i )
		break;

	printf("%-18s", "Card Info");
	printf("Slot = %d, Ethernet address = %s\n\n",
	       slot, ether_sprintf(en->en_addr));
	printf("%-18s", "I/O Stats");
	printf("Rxframes = %d, Rxerrs = %d, Txframes = %d, Txerrs = %d\n",
	       en->en_ipackets, en->en_ierrors,
	       en->en_opackets, en->en_oerrors);
	printf("%-18s", " ");
	printf("Collisions = %d, NotforUs = %d\n",
	       en->en_collisions, pdrops);

	if( en->en_ierrors )
	{
	    printf("%-18s", "Rx errors");
	    printf("fae = %d, crc = %d, frl = %d, ovrn = %d\n",
		   en->nfae, en->ncrc, en->nfrl, en->novrn);
	}

	if( en->en_oerrors )
	{
	    printf("%-18s", "Tx errors");
	    printf("nxscoll = %d, nundrn = %d\n",
		   en->nxscoll, en->nundrn);
	}

	printf("\nActive Filters:\n");

	if( ieeefilter[unit] )
	{
	    ++filters_active;
	    printf("%-18s: handler @%x, r12 = %x\n", "IEEE",
		   (ieeefilter[unit])->fs_handler,
		   (ieeefilter[unit])->fs_pwptr);
	}

	if( e2monitor[unit] )
	{
	    ++filters_active;
	    printf("%-18s: handler @%x, r12 = %x\n", "Ethernet2 Monitor",
		   (e2monitor[unit])->fs_handler,
		   (e2monitor[unit])->fs_pwptr);
	}

	if( e2sink[unit] )
	{
	    ++filters_active;
	    printf("%-18s: handler @%x, r12 = %x\n", "Ethernet2 Sink",
		   (e2sink[unit])->fs_handler,
		   (e2sink[unit])->fs_pwptr);
	}

	if( e2specific[unit] )
	{
	    FilterChainRef fc = e2specific[unit];
	    char *firstline = "Specific Types";

	    ++filters_active;

	    while( fc )
	    {
		printf("%-18s: type %x, handler @%x, r12 = %x\n",
		       firstline, fc->fc_type, fc->fc_handler, fc->fc_pwptr);

		firstline = "";
		fc = fc->fc_next;
	    }
	}

	if( !filters_active )
	    printf("(no filters active)\n");
    }

    if( en_lastlog[0] )
    {
	printf("\n%-18s%s\n", "Driver Info", en_lastlog);
	en_lastlog[0] = 0;
    }

    if( en_lasterr[0] )
    {
	printf("%-18s%s\n", "Driver Error", en_lasterr);
	en_lasterr[0] = '\0';
    }

    return(enfound);
}

/**********************************************************************/

int xcb_add_ethernet_card(int unit, int slot)
{
    return( unit > XCB_MAX_ETHERNET_CARDS ? 0 : 1 );
}

/**********************************************************************/

/*
 * set_receive_level - either turn the hardware for the unit off
 * (if addrlevel = -1), or enable appropriate levels of packet
 * reception
 */
void set_receive_level(int unit, int addrlevel)
{
    if( addrlevel == -1 )
	/*
	 * take the hardware down
	 */
	enioctl(unit, 1, 0);
    else
    {
	u_char rcrbits = RCR_INIT_VALUE;

	if( addrlevel >= ADDRLVL_NORMAL )
	    /* broadcasts are OK */
	    rcrbits |= AB;

	if( addrlevel >= ADDRLVL_MULTICAST )
	    /* multicasts are OK */
	    rcrbits |= AM;

	if( addrlevel >= ADDRLVL_PROMISCUOUS )
	    rcrbits |= PRO;

#ifdef DEBUG
	Printf("\021\06set_receive_level: rcr = %x (addrlevel = %x)\021\07\n",
	       rcrbits, addrlevel);
#endif

	/*
	 * update the recieve control register on the chip
	 */
	en_softc[unit]->Chip->rcr = rcrbits;
    }
}

/**********************************************************************/

int enioctl(int unit, int cmd, int flag)
{
    register struct en_softc *en;
    int s, error = 0;

    if (unit < 0 || unit > 4)
	return (1);
    en = en_softc[unit];
    switch(cmd)
    {
      case 0:
	if( en->en_flags & EN_FAULTY )
	    return (1);
	error = en_bringup(unit);
	break;

      case 1:

	s = splet();

	/*
	 * log a message on next CD/Heartbeat error
	 */
	en->en_flags &= ~EN_SQEINFORMED;
	en->en_flags |= EN_SQETEST;

	if( (en->en_flags & EN_FAULTY) )
	{
	    en_reset_card(en->en_slot);
	    break;
	}

	if( flag == 0 && (en->en_flags & EN_RUNNING) )
	{
	    /* take the card down */
	    en_reset_card(en->en_slot);
	    en->en_flags &= ~EN_RUNNING;
	}
	else if( flag && !(en->en_flags & EN_RUNNING) )
	    error = en_bringup(unit);

	splx(s);
	break;

      default:
	break;
    }

    /* that's all */
    return(error);
}

/**********************************************************************/

static void load_packet(u_char *hw_dst, u_char *hw_src, u_short type,
			struct mbuf *m0, volatile u_int *port)
{
    u_int bytebuf = 0;

    /*
     * load up the packet destination, source, and type first
     */
    en_io_out(hw_dst, port, HW_ADDR_LEN, &bytebuf);
    en_io_out(hw_src, port, HW_ADDR_LEN, &bytebuf);
    en_io_out((u_char *)(&type), port, sizeof(u_short), &bytebuf);

    /* now load up the mbuf data */
    for( ; m0; m0 = m0->m_next)
    {
	en_io_out(mtod(m0, u_char *), port, m0->m_len, &bytebuf);
    }

    /* flush any odd bytes remaining */
    en_flush_output(port, &bytebuf);

    /* finished */
    return;
}

/**********************************************************************/

/*
 * tx_mbufs - copy packet out of mbuf chain into Tx buffer, and queue
 * the transmit request. returns 0 if all OK, else an appropriate errno.
 */
static int tx_mbufs(struct en_softc *en, struct mbuf *m0,
		    u_char *edst, int type, u_char *esrc)
{
    register struct mbuf *m;
    register int datalen;
    TxqRef txdesc;
    NICRef nic = en->Chip;
    int s, retries;
    u_char TxPending;

    /* count the length of the packet */
    for( datalen = PACK_HDR_LEN, m = m0; m; m = m->m_next )
	datalen += m->m_len;

    if( datalen > ETHERMAXP )
    {
	return(EMSGSIZE);
    }

    s = splet();

    /* check for a free transmit structure */
    if( (txdesc = en->TxqFree) == (TxqRef)NULL )
    {
	/* no free structures */
	splx(s);
	return(ENOBUFS);
    }
    else
    {
	/* pull this buffer off the chain */
	en->TxqFree = txdesc->TxNext;
	txdesc->TxNext = (TxqRef)NULL;
	txdesc->TxByteCount = max(datalen, (ETHERMIN + PACK_HDR_LEN));
    }

    /* loop until packet is loaded, or excessive retries have failed */
    for( retries = 0; retries <= MAX_RDC_RETRIES; ++retries )
    {
	/*
	 * define I/O direction, execute workaround for bug in remote
	 * write DMA, initialise remote DMA parameters, then load
	 * the packet
	 */
	*en->page_reg = ((HARD_RESET_OFF | IO_WRITE) << 16);
	nic->rbcr0 = ~0;
	nic->command = START_DMA(DMA_READ);

	MICRODELAY(1);
	nic->command = START_DMA(DMA_ABORT);

	nic->rsar0 = 0;
	nic->rsar1 = txdesc->TxStartPage;
	nic->rbcr0 = datalen;
	nic->rbcr1 = datalen >> 8;
	nic->command = START_DMA(DMA_WRITE);

	load_packet(edst, esrc?esrc:(u_char *)en->en_addr,
		    htons(type), m0, en->dma_port);

	if( !(nic->isr & RDC) )
	{
	    /*
	     * this is not yet a fatal error - give it
	     * a chance to recover then try again
	     */
	    MICRODELAY(RDC_RECOVER_PERIOD);
	}

	/* now test the RDC bit for real */
	if( !(nic->isr & RDC) )
	{
	    /*
	     * something *is* wrong - stop the NIC, then
	     * start it up again
	     */
	    shutdown(nic, &TxPending);
	    startup(en, nic, TxPending);
	}
	else
	{
	    /* transfer has completed OK */
	    nic->isr = RDC;
	    break;
	}
    }

    if( retries > MAX_RDC_RETRIES )
    {
	/*
	 * discarding this transmit - return transmit buffer
	 * to free chain & return error
	 */
	txdesc->TxNext = en->TxqFree;
	en->TxqFree = txdesc;
	sprintf(en_lastlog, "Unit %d: RDC failure in tx_mbufs()\n",
	    en->en_unit);

	splx(s);
	return(EIO);
    }

    /* is this the first packet in the queue? */
    if( en->TxPending == (TxqRef)NULL )
    {
	/* yes - kick start the NIC */
	en->TxPending = txdesc;
	start_tx(en, nic);
    }
    else
    {
	register TxqRef prev;
	for( prev = en->TxPending; prev->TxNext; prev = prev->TxNext )
	    /* do nothing */
	    ;

	prev->TxNext = txdesc;
    }

    /* all done */
    splx(s);
    return(0);
}

/**********************************************************************/

/* EOF if_en.c */
