/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright (c) 1989 Acorn Computers Ltd., Cambridge, England
 *
 * :RCS Log discontinued:
 */

#ifndef __armif_if_en_h
#define __armif_if_en_h

/*
 * definition of the NIC structure
 *
 * Each register is 8 bits wide, which maps onto a word in I/O space.
 * The Network Interface Controller itself has 48 registers, of which
 * a single page of 16 can accessed at any one time. Page 0 is the set
 * of registers used when the chip is up & running; page 1 defines
 * Ethernet Address and multicast filters; while page 2 allows access to
 * page 0 registers which should normally be left alone, but may be required
 * for debugging.
 */
typedef struct
{
    u_char reg;
    u_char pad[3];
} NIC_Reg;

typedef struct
{
    volatile NIC_Reg r0;
    volatile NIC_Reg r1;
    volatile NIC_Reg r2;
    volatile NIC_Reg r3;
    volatile NIC_Reg r4;
    volatile NIC_Reg r5;
    volatile NIC_Reg r6;
    volatile NIC_Reg r7;
    volatile NIC_Reg r8;
    volatile NIC_Reg r9;
    volatile NIC_Reg ra;
    volatile NIC_Reg rb;
    volatile NIC_Reg rc;
    volatile NIC_Reg rd;
    volatile NIC_Reg re;
    volatile NIC_Reg rf;
} NIC, *NICRef;

/* defines for registers that map onto the above structure */

/* page 0 (read) */
#define command r0.reg
#define clda0   r1.reg
#define clda1   r2.reg
#define bnry    r3.reg
#define tsr     r4.reg
#define ncr     r5.reg
#define fifo    r6.reg
#define isr     r7.reg
#define crd0a   r8.reg
#define crda1   r9.reg
#define rsr     rc.reg
#define cntr0   rd.reg
#define cntr1   re.reg
#define cntr2   rf.reg

/* page 0 (write) */
#define pstart  r1.reg
#define pstop   r2.reg
#define bnry    r3.reg
#define tpsr    r4.reg
#define tbcr0   r5.reg
#define tbcr1   r6.reg
#define rsar0   r8.reg
#define rsar1   r9.reg
#define rbcr0   ra.reg
#define rbcr1   rb.reg
#define rcr     rc.reg
#define tcr     rd.reg
#define dcr     re.reg
#define imr     rf.reg

/* page 1 */
#define par0    r1.reg
#define par1    r2.reg
#define par2    r3.reg
#define par3    r4.reg
#define par4    r5.reg
#define par5    r6.reg
#define curr    r7.reg
#define mar0    r8.reg
#define mar1    r9.reg
#define mar2    ra.reg
#define mar3    rb.reg
#define mar4    rc.reg
#define mar5    rd.reg
#define mar6    re.reg
#define mar7    rf.reg

/*
 * defines/macros for manipulating the command register
 *
 * NOTE: the page select bits can only be modified when the
 * remote DMA is idle, and the DMA commands can only be issued
 * when the NIC is running and in page 0.
 *
 */
#define STP             (1 << 0)
#define STA             (1 << 1)
#define TXP             (1 << 2)
#define DMA_READ        0x01
#define DMA_WRITE       0x02
#define DMA_SENDP       0x03
#define DMA_ABORT       0x04
#define DMA_IDLE        DMA_ABORT
#define DMA_SHIFT       3
#define PAGE_SHIFT      6
#define CMD_INIT_VALUE  0x21
#define NIC_STOPPED     0
#define NIC_RUNNING     1
#define NIC_LIVE(x)     ((x) ? STA : STP)
#define SEL_PAGE(x,y)   (((x) << PAGE_SHIFT) | (DMA_IDLE << DMA_SHIFT) |\
                         NIC_LIVE(y))
#define START_DMA(x)    (((x) << DMA_SHIFT) | STA)

/*
 * defines for bits in remaining registers
 */

/* isr/imr */
#define PRX             (1 << 0)
#define PTX             (1 << 1)
#define RXE             (1 << 2)
#define TXE             (1 << 3)
#define OVW             (1 << 4)
#define CNT             (1 << 5)
#define RDC             (1 << 6)
#define RST             (1 << 7)
#define IMR_INIT_VALUE  PRX | PTX | RXE | TXE | OVW | CNT

/* dcr */
#define WTS             (1 << 0)
#define BOS             (1 << 1)
#define LAS             (1 << 2)
#define LS              (1 << 3)
#define AUREM           (1 << 4)
#define FIFOT_SHIFT     5
#define WORD_THRESH1    0
#define WORD_THRESH2    1
#define WORD_THRESH4    2
#define WORD_THRESH6    3
#define DCR_INIT_VALUE  WTS | LS | AUREM
#define FIFO_THRESH(x)  ((x) << FIFOT_SHIFT)

/* tcr */
#define INCRC           (1 << 0)
#define ATD             (1 << 3)
#define OFST            (1 << 4)
#define LOOPM_SHIFT     1       
#define LIVE_NET        0
#define LOOPBACK1       1
#define LOOPBACK2       2
#define LOOPBACK3       3
#define TCR_INIT_VALUE  0
#define LOOP_MODE(x)    ((x) << LOOPM_SHIFT)

/* tsr */
#define TXOK            (1 << 0)
#define COL             (1 << 2)
#define ABT             (1 << 3)
#define CRS             (1 << 4)
#define FU              (1 << 5)
#define CDH             (1 << 6)
#define OWC             (1 << 7)

/* rcr */
#define SEP             (1 << 0)
#define ARUNT           (1 << 1)
#define AB              (1 << 2)
#define AM              (1 << 3)
#define PRO             (1 << 4)
#define MON             (1 << 5)
#define RCR_INIT_VALUE  (0)

/* rsr */
#define CRCE  (1 << 1)
#define FAE   (1 << 2)
#define FO    (1 << 3)
#define MPA   (1 << 4)
#define PHY   (1 << 5)
#define DIS   (1 << 6)
#define DFR   (1 << 7)

/*
 * packet field lengths
 */
#define HW_ADDR_LEN  6                         /* length of hardware address */
#define PACK_HDR_LEN ((2 * HW_ADDR_LEN) + 2)   /* bytes in packet header */
#define BUFF_HDR_LEN 4                         /* bytes in Rx buffer header */
#define CRC_LEN      4                         /* CRC bytes in a packet */
#define ETHERMAXP    (ETHERMTU + PACK_HDR_LEN) /* max packet size */

/*
 * NIC buffer management. The Ethernet II card has on board static RAM
 * which is split between transmit and receive buffers. All received
 * data is immediately read out into a chain of mbufs, whereas the driver
 * maintains a queue of pending transmissions which are currently in the
 * transmit buffer.
 *
 * Each member of the transmit buffer pool has an area of RAM reserved
 * for its use, this area being enough pages to store an ETHERMTU packet.
 * All RAM not reserved for a transmit buffer is used for the receive
 * buffer.
 *
 */
#define NIC_BUFFER   (64 * 1024)
#define NIC_PAGE     256                      /* buffer page size */

#define MAXTXQ       15
#define PAGES_PER_TX (((ETHERMAXP - 1) / NIC_PAGE) + 1)
#define TX_START     0
#define RX_START     (TX_START + (MAXTXQ * PAGES_PER_TX))
#define RX_END       (NIC_BUFFER / NIC_PAGE)

typedef struct _txq
{
    struct _txq *TxNext;
    u_short TxStartPage;
    u_short TxByteCount;
} Txq, *TxqRef; /* transmit queue */

/*
 * define I/O addresses used by the expansion card:
 * hardware in 'podule space'
 */
#define ENCARD_ROM(slot)        (XCB_ADDRESS(FAST, slot))
#define ENCARD_INT_STATUS(slot) (ENCARD_ROM(slot) + 0x2000)
#define ENCARD_PAGE_REG(slot)   (ENCARD_ROM(slot) + 0x3000)

#define HWADDR_ADDR     0x400   /* address in ROM of Ethernet h/w address */
#define REVNO_ADDR      0x424   /* address in ROM of card revision number */
/*
 * hardware in 'module space'
 */
#define MOD_ADDRESS(slot)        (0x3000000 + ((slot) << 14))
#define ENCARD_REMOTE_DMA(slot)  (MOD_ADDRESS(slot) + 0x2000)
#define ENCARD_NIC_REGS(slot)    (MOD_ADDRESS(slot) + 0x3000)

/*
 * bit twiddling macros for hardware registers
 */
#define HARD_RESET_BIT  (1 << 15)
#define HARD_RESET_OFF  HARD_RESET_BIT
#define HARD_RESET_ON   0

#define IO_DIR_BIT      (1 << 14)
#define IO_READ         IO_DIR_BIT
#define IO_WRITE        0

#define EN_INTR_MASK    (1 << 0)

/*
 * The en_softc structure is the main driver control block, one
 * per unit. It contains all information needed to access the 
 * ethernet card hardware.
 */
struct en_softc
{
    short   en_unit;                /* unit number */
    char    en_addr[6];             /* physical ethernet address */
    u_short en_flags;               /* always have some of these */
    u_char  en_slot;                /* physical slot number */
    u_char  en_rev;                 /* hardware revision number */
/* generic interface statistics */
    int     en_ipackets;            /* packets received on interface */
    int     en_ierrors;             /* input errors on interface */
    int     en_opackets;            /* packets sent on interface */
    int     en_oerrors;             /* output errors on interface */
    int     en_collisions;          /* collisions on csma interfaces */
    NICRef Chip;                    /* the hardware */
    volatile u_int *dma_port;       /* where remote DMA data appears */
    volatile u_int *page_reg;       /* EPROM page register, also contains
                                     * Software Reset bit, and indicates
                                     * I/O direction */
    Txq TxqPool[MAXTXQ];            /* pool of transmit structures */
    TxqRef TxqFree;                 /* chain of free transmit structures */
    TxqRef TxPending;               /* chain of pending transmits */
    struct int_hndlr en_handler;    /* interrupt handler structures */
    XCBIRQSense en_sense;           /* needed for old-fashioned backplanes */
    struct
    {
        u_int crc_count;            /* CRC failure */
        u_int fae_count;            /* Frame Alignmnt Errors */
        u_int frl_count;            /* Frames Lost (no resources) */
        u_int ovrn_count;           /* FIFO Overrun */
        u_int undrn_count;          /* FIFO Underrun */
        u_int coll_count;           /* Number of collisions that eventually
                                     * went out OK */
        u_int xscoll_count;         /* Number of excessive collisions */
    } errors;
};


/*
 * Flag Bits
 */
#define EN_FAULTY            (1 << 0)  /* Card is dead for some reason */
#define EN_RUNNING           (1 << 1)  /* Card is `live' on the network */
#define EN_SQETEST           (1 << 2)  /* CD/Heartbeat test is valid */
#define EN_SQEINFORMED       (1 << 3)  /* CD/Heartbeat failure logged */
#define EN_RECOVERABLE_ERROR (1 << 4)  /* Ethernet is not connected */

/*
 * members of the errors structure
 */
#define ncrc    errors.crc_count
#define nfae    errors.fae_count
#define nfrl    errors.frl_count
#define novrn   errors.ovrn_count
#define nundrn  errors.undrn_count
#define ncoll   errors.coll_count
#define nxscoll errors.xscoll_count

#ifdef KERNEL
extern struct en_softc *en_softc[]; /* array of control structures, indexed
                                     * on logical slot number */

extern int n_en;                    /* number of cards KERNEL is
                                     * configured for */
#endif /* KERNEL */

/*
 * memory testing
 */
#define PAT_LEN         34
#define PAT_MID         (PAT_LEN >> 1)
#define O(n)            (1 << n)
#define Z(n)            (O(n) ^ 0xffff)

/*
 * loopback testing
 */
#define LB_FIFOLEN      8           /* FIFO length during loopback */
#define TESTP_LEN       60          /* length of loopback test packet */
#define POLYNOMIAL      0x04c11db7  /* polynomial for CRC calculation */

/*
 * timeout values to use during POST
 */
#define CC_TIMEO        (HZ / 12)    /* cable checking (4) */
#define LB_TIMEO        (HZ / 8)    /* loopback transmissions */
#define STP_TIMEO       (HZ / 8)    /* STOP command to set RST */

/* no. of bytes to junk when reading CRC from FIFO */
#define N_JUNK          (TESTP_LEN % LB_FIFOLEN)

#if (N_JUNK > (LB_FIFOLEN - CRC_LEN))       /* does CRC wrap around
                                             * end of FIFO? */
 #ERROR: bad value for TESTP_LEN
#endif /* N_JUNK < 0 */

typedef struct _tp
{
    u_char src_addr[HW_ADDR_LEN];
    u_char dst_addr[HW_ADDR_LEN];
    u_short ptype;
    u_char bulk_data[TESTP_LEN - PACK_HDR_LEN];
    u_char crc_bytes[CRC_LEN];
} TestPacket;

/*
#if sizeof(TestPacket) != (TESTP_LEN + CRC_LEN)
 #ERROR: bad size for TestPacket typedef
#endif
*/

/*
 * Debug control
 */
#ifdef KERNEL
extern int en_block;

#define BLOCK_BROAD     (1 << 0)
#define BLOCK_STARTARP  (1 << 1)
#define BLOCK_PROM      (1 << 4)

#ifdef EN_DEBUG

extern int en_debug;
#define DoDebug(x)      (en_debug & (x))

#define DEBUG_ISR       (1 << 0)
#define DEBUG_RX        (1 << 1)
#define DEBUG_TX        (1 << 2)
#define DEBUG_TRAILERS  (1 << 3)
#define DEBUG_DATA_IN   (1 << 5)
#define DEBUG_DATA_OUT  (1 << 6)
#define DEBUG_MINIMUM   (1 << 8)
#define DEBUG_VERBOSE   (1 << 9)

#endif /* EN_DEBUG */
#endif /* KERNEL */

#define MAX_RDC_RETRIES         5               /* max. no of RDC failures */
#define RDC_RECOVER_PERIOD      10              /* delay to give RDC a
                                                 * chance to appear */

#define ETHERMTU  1500
#define ETHERMIN        (60-14)

/*
 * Assembler copy routines assume an even value for MLEN, check that
 * this is the case
 */
#ifdef OldCode
# if (OLDMLEN & 1)
#  ERROR: CANNOT COPE WITH CURRENT VALUE FOR MLEN
# endif
#endif /* OldCode */

#endif/*__armif_if_en_h*/

/* EOF if_en.h */
