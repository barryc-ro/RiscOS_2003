/*
 * ir.c		- IR driver.
 */

/*
 * 		Copyright 1996 Acorn Network Computing
 *
 * This material is the confidential trade secret and proprietary
 * information of Acorn Network Computing. It may not be reproduced,
 * used, sold, or transferred to any third party without the prior
 * written consent of Acorn Network Computing. All rights reserved.
 *
 */

/*
 * General flow of operations is:
 * - Wait for UpCall_DeviceRxDataPresent on our handle.
 * - Read up to four bytes (a packet worth) of data.
 * - Return if we havn't accumulated 4 bytes yet.
 * - Validate the packet by looking at the top bits; should be 1,0,0,0.
 * - Process the packet (process_raw()) depending on packet type in bits 0-3
 *   of byte 0:
 *   - If tag retirement packet call process_tags().
 *   - If data packet:
 *     - de-munge the packet from 4 to 3 bytes (demunge()).
 *     - Process the de-munged packet (process_X()) depending on the tag value
 *       in bits 0-3 of byte 0:
 *       - If ID pseudo-tag update the tag's pointer to a registry entry.
 *       - Otherwise process the packet depending on its sender's device type
 *         held in the registry entry associated with the tag value.
 *
 * A device may suddenly disappear leaving the OS in an awkward state (ie a
 * keyboard disappearing after sending a KeyDown, leading to the key being
 * stuck down). To prevent this, a timeout is set and context saved when
 * processing a packet that leaves the OS in a potentially awkward state.
 * The timeout is cancelled when the next packet from the device is received.
 * A cleanup routine which uses the saved context is called if the timeout goes
 * off.
 *
 * Performance tweaks:
 *   The resync code in the middle of ir_DeviceRxDataPresent() could be tidied.
 *   The C compiler doesn't seem to be very intelligent about bitfield handling.
 *
 * Not implemented:
 *   Keyboards that use the UDN bit instead of repeatedly resending while a key
 *   is down.
 *   Absolute pointer packets.
 *
 * Debugging:
 *   Undef DEBUG for release version.
 *   DEBUG=1 : Reports timeouts (#), discarded resends (!) and bogus data.
 *   DEBUG=2 : As above + tag registration & retirement, key up/downs.
 *   DEBUG=3 : As above + displays packet data.
 *   Define FAKEINPUT for remote simulation and debugging via a TCP/IP stream.
 */

#include <stdlib.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"
#include "serial.h"

#include "module.h"
#include "ir.h"
#include "irqs.h"
#include "registry.h"
#include "keytables.h"
#include "irp.h"

#define MIN(a,b)	(((a)<(b)) ? (a) : (b))
#define MAX(a,b)	(((a)>(b)) ? (a) : (b))

#if defined(POINTER) && !defined(KEYBOARD)
#  error POINTER support requires KEYBOARD support (POINTER is defined but not KEYBOARD)
#endif


/*
 * Constants
 */
#define SERIAL_PORT	"2"
#define SERIAL_BAUD	"9600"
#define SERIAL_DEVICE	"devices#baud" SERIAL_BAUD ";data8;stop1;noparity;nohandshake;size64;thres48:$.serial" SERIAL_PORT

#define NV_BYTE		0xE8		/* Our byte in non-volatile memory */
#define NV_BITS		0x0F		/* Bitmask of our bits in that byte */

/* Protocol-defined constants */
#define TAG_COUNT	14		/* Not including special tags */
#define TAG_ID_BASIC	0x0f		/* A special tag */
#define TAG_ID_EXTEND	0x0e		/* Another one */

#ifdef FAKEINPUT
#  define INPUTHOST	0x88aa8704	/* 136.170.135.4 = starman */
#  define INPUTPORT	8000
  _kernel_oserror ineterr = { 0, "Internet error" };
#endif

/*
 * Globals
 */
int in_handle=-1, out_handle=-1;	/* DeviceFS serial: handles */
int Flags = 0;

static void *PrivateWord;
static tag_info_t tags[TAG_COUNT];
static _kernel_oserror *err;
static unsigned char buffer[4], *next;	/* Read buffer and first free space */
static int pointer_relx = 0, pointer_rely = 0;	/* Relative pointer movement */


/*
 * Prototypes
 */
static void process_raw(unsigned int raw);
static void process_tags(unsigned int bitmask);
static void retire_tag(unsigned int tag_number);
static void process_handset(packet_t packet, tag_info_t *tag);
#ifdef KEYBOARD
static void process_keyboard(packet_t packet, tag_info_t *tag);
static void ir_keyb(int direction, unsigned int keyno, unsigned int mods);
#endif
#ifdef POINTER
static void process_pointer(packet_t packet, tag_info_t *tag);
#endif


/*------------------------------------------------------------------------------
 *
 *	Clean-up code
 */
void Disable( void )
{
  halt();				/* Tell micro to stop sending */
  Flags &= ~ENABLED;			/* Must do this before closing files */
  if (in_handle != -1)
  {
#ifdef FAKEINPUT
    _swix(OS_Release, _IN(0)|_IN(1)|_IN(2),
          EventV, module_event_entry, PrivateWord);
    socketclose(in_handle);
#else
    _swix(OS_Find, _INR(0,1), 0, in_handle);	/* Close input stream. */
#endif
    in_handle = -1;
  }
  if (out_handle != -1)
  {
    _swix(OS_Find, _INR(0,1), 0, out_handle);	/* Close output stream. */
    out_handle = -1;
  }
  process_tags(0);			/* Reset tag stuff and cancel timeouts*/
  _swix(OS_Release, _INR(0,2), UpcallV, module_upcall_entry, PrivateWord);
#ifdef POINTER
  _swix(OS_Release, _INR(0,2), PointerV, module_pointerv_entry, PrivateWord);
#endif
#ifdef KEYBOARD
  _swix(OS_Release, _INR(0,2), KeyV, module_keyv_entry, PrivateWord);
#endif
}


/*------------------------------------------------------------------------------
 *
 *	Grab vectors etc
 */
static _kernel_oserror *Enable( void )
{
  int i;
#ifndef FAKEINPUT
  ioctl_t ioctlblock = { IOCTL_FIFO_TRIG, 0, 0, 0, 1, 4 };
#endif

  in_handle = out_handle = -1;		/* Reset handles */

  /* Reset tag stuff */
  for (i=0; i<TAG_COUNT; i++)
  {
    tags[i].registry = NULL;
    tags[i].device_state.word = 0;
    tags[i].context.word = INACTIVE;
    tags[i].PrivateWord = PrivateWord;
    tags[i].tag_number = i;
  }

  err = _swix(OS_Claim, _INR(0,2), UpcallV, module_upcall_entry, PrivateWord);
#ifdef KEYBOARD
  if (!err) err = _swix(OS_Claim, _INR(0,2),KeyV,module_keyv_entry,PrivateWord);
#endif
#ifdef POINTER
  if (!err) err = _swix(OS_Claim, _INR(0,2), PointerV, module_pointerv_entry,
                        PrivateWord);
#endif
#ifdef FAKEINPUT
  {
    int i = 1;
    struct sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_port = htons(INPUTPORT);
    sin.sin_addr.s_addr = htonl(INPUTHOST);
    in_handle = socket(AF_INET, SOCK_STREAM, 0);
    socketioctl(in_handle, FIONBIO, &i);
    socketioctl(in_handle, FIOASYNC, &i);
    if ((connect(in_handle, (struct sockaddr*) &sin, sizeof(sin)) == -1) &&
      (errno != EINPROGRESS) && (errno != EWOULDBLOCK))
    {
      err = &ineterr;
      socketclose(in_handle);
    }
    if (!err) err = _swix(OS_Claim, _IN(0)|_IN(1)|_IN(2),
                          EventV, module_event_entry, PrivateWord);
  }

#else
  if (!err) err = _swix(OS_Find, _INR(0,1)|_OUT(0),
                        SERIAL_INPUT, SERIAL_DEVICE, &in_handle);
  /* set fifo trigger level to 4 on input */
  if (!err) err = _swix(OS_Args, _INR(0,2),
                        OSArgs_IOCtl, in_handle, &ioctlblock);
#endif
  if (!err) err = _swix(OS_Find, _INR(0,1)|_OUT(0),
                        SERIAL_OUTPUT, SERIAL_DEVICE, &out_handle);
  DEBUGFN(2, if (!err) db_printf("Handles: in:%d, out%d. pw=%p\n",
                                 in_handle, out_handle, PrivateWord));

  if (!err)
  {
    Flags |= ENABLED;
    next = buffer;

    reset(ir_getfamily());
  }
  else
  {
    Disable();
  }

  return err;
}


/*------------------------------------------------------------------------------
 *
 *	Module finalisation
 */
void ir_finalise( void *pw )
{
  NOT_USED( pw );

  if (Flags & ENABLED)
    Disable();
}


/*------------------------------------------------------------------------------
 *
 *	Module initialisation
 */
_kernel_oserror *ir_initialise( void *pw )
{
  PrivateWord = pw;

  err = Enable();

  return err;
}


/*------------------------------------------------------------------------------
 *
 *	Read and process data from serial stream. Called with irqs on.
 */
int ir_DeviceRxDataPresent(void)
{
  static int busy = FALSE, reentered = FALSE;
  int extent, i, notok;
  unsigned char *first;

  /* Prevent re-entry */
  if (busy)
  {
    reentered = TRUE;
    return TRUE;
  }
  busy = TRUE;

#ifdef FAKEINPUT
  extent = 4;
#else
  /* How much data? */
  _swix(OS_Args, _IN(0)|_IN(1)|_OUT(2), OSArgs_Extent, in_handle, &extent);
#endif

  while (extent)
  {
    /* Get up to a (raw) packet's worth of data.
     * We should have 1 to 4 bytes in the buffer after this call */
#ifdef FAKEINPUT
    if ((extent = socketread(in_handle, (char *) buffer, 4)) != 4)
    {
      busy = FALSE;
      return TRUE;
    }
    next = buffer+extent;
    *((u_long *) buffer) = ntohl(*((u_long *) buffer));
#else
    if (_swix(OS_GBPB, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_OUT(2),
              OSGBPB_Read, in_handle, next, MIN(extent,4-(next-buffer)),
              &next) )
    {
      DEBUGFN(1, db_printf("Read returned error!\n"));
      Disable();
      return TRUE;
    }
#endif

    /* Check validity of the raw packet */

    /* Check bit 7 of 1st byte set */
    if (!(*buffer & 0x80))
    {
      DEBUGFN(1, db_printf("Not a header!\n"));

      /* Find the first header packet */
      for (first=buffer+1; first<next; first++)
        if (*buffer & 0x80)
           break;

      /* Shift the data up so header packet is at the start of the buffer */
      for (i=0; i<(next-first); i++)
        buffer[i] = first[i];

      next += (buffer - first);
    }

    /* Check bits 7 of remaining bytes clear */
    do
    {
      notok = FALSE;
      for (first=buffer+1; first<next; first++)
        if (*first & 0x80)
        {
          DEBUGFN(1, db_printf("Not a whole packet!\n"));

          /* Shift the data up so header packet is at the start of the buffer */
          for (i=0; i<(next-first); i++)
            buffer[i] = first[i];

          next += (buffer - first);
          notok = TRUE;
          break;
        }
    } while (notok);

    /* If we've got a (raw) packet then process it */
    if ((next-buffer) == 4)
    {
      process_raw(*((unsigned int *) buffer));
      next = buffer;
    }

    /* More data? */
    /* Can be re-entered during OSArgs call so have to ensure correct extent:
     * if we miss the Upcall we won't be told about data being present again */
#ifndef FAKEINPUT
    do
    {
      reentered = FALSE;
      _swix(OS_Args, _IN(0)|_IN(1)|_OUT(2), OSArgs_Extent, in_handle, &extent);
#if 0	/* XXX test: force reentry */
db_printf("X"); for (i=0; i<1000000; i++); db_printf(reentered ? "!\n" : "Y\n");
#endif
    }
    while (reentered);
#endif
  };
  busy = FALSE;

  return TRUE;
}


/*------------------------------------------------------------------------------
 *
 *	Read configured family
 */
int ir_getfamily(void)
{
  int byte;
  _swix(OS_Byte, _INR(0,1)|_OUT(2), 0xA1, NV_BYTE, &byte);
  return(byte &= NV_BITS);
}


/*------------------------------------------------------------------------------
 *
 *	Set configured family
 */
void ir_setfamily(int family)
{
  int byte;

  /* Read, modify, write */
  _swix(OS_Byte, _INR(0,1)|_OUT(2), 0xA1, NV_BYTE, &byte);
  byte = (byte & ~NV_BITS) | (family & NV_BITS);
  _swix(OS_Byte, _INR(0,2), 0xA2, NV_BYTE, byte);

  /* Inform the micro of the change */
  if (Flags & ENABLED)
    reset(family);
}


/*------------------------------------------------------------------------------
 *
 *	Send a command to micro
 */
static void put_command(command_t command)
{
  /* Reopen our stream if it got shut */
  if (out_handle == -1)
  _swix(OS_Find, _INR(0,1)|_OUT(0), SERIAL_OUTPUT, SERIAL_DEVICE, &out_handle);

  DEBUGFN(2, db_printf("Command %02x\n", command.byte));
  _swix(OS_BPut, _INR(0,1), command, out_handle);
}


/*------------------------------------------------------------------------------
 *
 *	Send reset command to micro
 */
void reset(int family)
{
  command_t command;
  command.generic.command = CMD_RESET;
  command.generic.info = family;
  command.generic.topbit = 1;
  put_command(command);
}


/*------------------------------------------------------------------------------
 *
 *	Send halt command to micro
 */
void halt(void)
{
  command_t command;
  command.generic.command = CMD_HALT;
  command.generic.info = 0;
  command.generic.topbit = 1;
  put_command(command);
}


/*------------------------------------------------------------------------------
 *
 *	de-munge an incoming raw data packet (which is assumed to be valid)
 */
static packet_t demunge(unsigned int raw)
{
  packet_t packet;

  packet.word = (raw >> 8) |
                ((raw & 0x40) << 1) |
                ((raw & 0x20) << 10) |
                ((raw & 0x10) << 19);
  return packet;
}


/*------------------------------------------------------------------------------
 *
 *	Process a de-munged packet
 *
 * The registry packet handling stuff is pretty gross:
 * Some registry entries come in two packets; an extended followed by a basic,
 * while other ones just come in a single basic packet. This means that when we
 * get an extended registry packet we have to remember it so we can compare
 * its tag value with later basic packets and glue them together if they match.
 * Because we can be talking to 2 separate devices simulataneously, we have to
 * remember the last 2 extended packets received. This scheme will break if we
 * receive an extended packet with tag t, never receive the companion basic tag
 * (for whatever reason), and then later receive a basic packet from a different
 * device but which has been assigned the same tag t. If this happens we end up
 * with a bogus registry number for the second device.
 */
static void process(packet_t packet)
{
  tag_info_t *tag = tags+packet.generic.tag;
  int number, i, next_ext=0;
  struct
  {
    unsigned int ext_bits, ext_tag;
  } ext_state[2] = {{ -1, -1 }, { -1, -1 }};	/* A bit of state */

  DEBUGFN(3, db_printf("Data: %06x\n", packet.word));

  switch (packet.generic.tag)
  {
  case TAG_ID_EXTEND:
    ext_state[next_ext].ext_tag = packet.reg_extended.new_tag;
    ext_state[next_ext].ext_bits = (packet.reg_extended.num_hi << 24) |
                                   (packet.reg_extended.num_15 << 15) |
                                   (packet.reg_extended.num_lo << 16);
    DEBUGFN(2, db_printf("Remembering extended info for tag %d\n",
                         ext_state[next_ext].ext_tag));
    next_ext = 1 - next_ext;
    break;

  case TAG_ID_BASIC:				/* A new tag, oh joy */
    if (packet.reg_basic.new_tag == ext_state[0].ext_tag)
    {
      number = (packet.reg_basic.num_hi << 8) | packet.reg_basic.num_lo &
               ext_state[0].ext_bits;
      ext_state[0].ext_tag = -1;		/* Don't want this no more */
      next_ext = 0;
    }
    else if (packet.reg_basic.new_tag == ext_state[1].ext_tag)
    {
      number = (packet.reg_basic.num_hi << 8) | packet.reg_basic.num_lo &
               ext_state[1].ext_bits;
      ext_state[1].ext_tag = -1;		/* Don't want this no more */
      next_ext = 1;
    }
    else
      number = (packet.reg_basic.num_hi << 8) | packet.reg_basic.num_lo;


    /* Associate the tag with its registry entry (if we have one) */
    for (i=0; i<registry_entries; i++)
      if (number == registry[i].number)
      {
        /* Optimisation: Don't retire & re-register the tag if its the same */
        if (tags[packet.reg_basic.new_tag].registry != registry + i)
        {
          retire_tag(packet.reg_basic.new_tag);	/* Retire tag before re-use */
          tags[packet.reg_basic.new_tag].registry = registry + i;
          DEBUGFN(2,db_printf("Associating new tag %d with device %x, \"%s\"\n",
                             packet.reg_basic.new_tag, number, registry[i].id));
        }
        break;
      }
    if (i == registry_entries)
    {
      retire_tag(packet.reg_basic.new_tag);	/* Retire tag before re-use */
      DEBUGFN(2, db_printf("New tag %d: device %x is not in the registry!\n",
                           packet.reg_basic.new_tag, number));
    }
    break;

  default:					/* Its a normal packet */
    if (tag->registry != NULL)
    {
      switch (tag->registry->device_type)
      {
      case d_handset:
        process_handset(packet, tag);
        break;

#ifdef KEYBOARD
      case d_keyboard:
        process_keyboard(packet, tag);
        break;
#endif

#ifdef POINTER
      case d_pointer:
        process_pointer(packet, tag);
        break;
#endif

#if DEBUG>=1
      default:
        db_printf("Don't know what to do with a packet from device type %d!\n",
                  tag->registry->device_type);
#endif
      }
    }
#if DEBUG>=1
    else
    {
      db_printf("Received packet from device with unassigned tag %d!\n",
                packet.generic.tag);
    }
#endif
  }
}


/*------------------------------------------------------------------------------
 *
 *	Retire a tag.
 */
static void retire_tag(unsigned int tag_number)
{
  tag_info_t *tag = tags+tag_number;

  if (tag->registry != NULL)
  {
    DEBUGFN(2, db_printf("Retiring tag %d\n", tag_number));
    if (tag->context.word != INACTIVE)
    {
      ir_timeout(tag_number);			/* Force cleanup */
      ir_cancel_timeout(tag_number);
    }
    tag->registry = NULL;
  }
  tag->device_state.word = 0;
}


/*------------------------------------------------------------------------------
 *
 *	Process a tag-update packet.
 *
 * Tags which are not in use are 0 in the bitmask.
 */
static void process_tags(unsigned int bitmask)
{
  int i, b;

  for (i=0, b=1; i<TAG_COUNT; i++, b+=b)
    if (!(bitmask & b))
      retire_tag(i);
}


/*------------------------------------------------------------------------------
 *
 *	Process a raw packet
 */
static void process_raw(unsigned int raw)
{
  switch (raw & 7)
  {
  case 0:				/* Normal data packet */
    process(demunge(raw));
    break;

  case 1:				/* Tag retirement */
    process_tags(((raw & 0x7f00) >> 8) | ((raw & 0x70) << 3));
    break;

  default:
    DEBUGFN(1, db_printf("Bogus raw packet: type %d!\n", raw & 7));
  }
}


/*------------------------------------------------------------------------------
 *
 *	Set a device timeout
 */
static void ir_set_timeout(int tag_number, context_t context)
{
  tags[tag_number].context = context;
  _swix(OS_CallAfter,_INR(0,2),
        TIMEOUT_DELAY, timeout_preveneer, &(tags[tag_number].PrivateWord));
}


/*------------------------------------------------------------------------------
 *
 *	Cancel device timeout
 *
 * Also sets device's context to INACTIVE
 */
void ir_cancel_timeout(int tag_number)
{
  _swix(OS_RemoveTickerEvent, _INR(0,1),
        timeout_preveneer, &(tags[tag_number].PrivateWord));
  tags[tag_number].context.word = INACTIVE;
}


/*------------------------------------------------------------------------------
 *
 *	Device has timed out, do appropriate cleanup.
 */
void ir_timeout(int tag_number)
{
  context_t *context = &(tags[tag_number].context);

  DEBUGFN(1, (DEBUG<=1 ? db_printf("#") : db_printf("Device with tag %d timed out!\n", tag_number)));

  /* Timeout happened while being cancelled? */
  if (context->word == INACTIVE)
  {
    DEBUGFN(2, db_printf("no context to clean up!\n"));
    return;
  }

  switch (tags[tag_number].registry->device_type)
  {
#ifdef KEYBOARD
  case d_keyboard:
    ir_keyb(Key_KeyUp, context->keyboard.keyno, context->keyboard.mods);
    break;
#endif

#ifdef POINTER
  case d_pointer:
    if (context->pointer.buttons & BUT_SELECT)
      ir_keyb(Key_KeyUp, Key_Select, 0);
    if (context->pointer.buttons & BUT_MENU)
      ir_keyb(Key_KeyUp, Key_Menu, 0);
    break;
#endif

#if DEBUG>=1
  default:
    db_printf("Cleanup: Don't know how to clean up after device type %d!\n",
             tags[tag_number].registry->device_type);
#endif
  }
  context->word = INACTIVE;
}


/*------------------------------------------------------------------------------
 *
 *	Process a packet from a handset device
 */
static void process_handset(packet_t packet, tag_info_t *tag)
{
  unsigned int buffer_code;

#if DEBUG>=1
  if (tag->registry->packet_type != p_keyboard)
  {
    db_printf("Device %x says its a handset but sends packets of type %d!\n",
           tag->registry->number, tag->registry->packet_type);
    return;
  };
#endif

  buffer_code = handset_lookup(packet.keyboard.scancode, packet.keyboard.mods,
                               tag->registry->extra.table);

  /* If not in Standby mode, insert buffer_code into keyboard buffer */
  if ((buffer_code != -1) && !(Flags & STANDBY))
  {
    /* Ugh special case! Need to escape £ so it doesn't look like Ctrl-F3 */
    /* May need to escape other top-bit-set characters */
    if (buffer_code == '£')
      _swix(OS_Byte, _INR(0,2), 153, 0, 0);

    _swix(OS_Byte, _INR(0,2), 153, 0, buffer_code);
    DEBUGFN(2, db_printf("BufferCode: %x\n", buffer_code));
  }
}


#ifdef KEYBOARD
/*------------------------------------------------------------------------------
 *
 *	Process a packet from a keyboard device
 */
static void process_keyboard(packet_t packet, tag_info_t *tag)
{
  unsigned int tag_number = packet.generic.tag;
  context_t context, *old_context = &(tags[tag_number].context);

  context.keyboard.keyno = keyboard_lookup(packet.keyboard.scancode,
                                           packet.keyboard.mods,
                                           &(tag->device_state));
  if (context.keyboard.keyno != -1)
    context.keyboard.mods = packet.keyboard.mods;
  else
  {
    DEBUGFN(1, db_printf("Scancode %x, mods %x do not map to a key!\n",
                         packet.keyboard.scancode, packet.keyboard.mods));
    /* Old key(s) up, cancel timeout */
    if (old_context->word != INACTIVE)
    {
      ir_keyb(Key_KeyUp,old_context->keyboard.keyno,old_context->keyboard.mods);
      ir_cancel_timeout(tag_number);
    }
    return;
  }

#if DEBUG>=1
  if (tag->registry->packet_type != p_keyboard)
  {
    db_printf("Device %x says its a keyboard but sends packets of type %d!\n",
              tag->registry->number, tag->registry->packet_type);
    return;
  };
#endif

  /* Don't do anything on receipt of a packet resent due to missed ACK */
  if (!(packet.relative.resend && (old_context->word == context.word)))
  {
    if (packet.keyboard.repeat && (context.word == old_context->word))
    {
      /* Auto-repeat: Cancel the pending timeout, set a new one */
      ir_cancel_timeout(tag_number);
      ir_set_timeout(tag_number, context);
    }
    else
    {
      /* Don't do anything if its a resend due to lack of receipt of ACK */
      /* Different keys: Old key(s) up, cancel timeout */
      if (old_context->word != INACTIVE)
      {
        ir_keyb(Key_KeyUp, old_context->keyboard.keyno,
                old_context->keyboard.mods);
        ir_cancel_timeout(tag_number);
      }
      /* If not in standby: New key(s) down, set timeout */
      if (!(Flags & STANDBY))
      {
        ir_keyb(Key_KeyDown, context.keyboard.keyno, context.keyboard.mods);
        ir_set_timeout(tag_number, context);
      }
    }
  }
#if DEBUG>=1
  else
    db_printf("!");
#endif
}


/*------------------------------------------------------------------------------
 *
 *	Send key up / downs
 */
static void ir_keyb(int direction, unsigned int keyno, unsigned int mods)
{
  DEBUGFN(2, db_printf("%s: %x,%x\n",
                       (direction==Key_KeyUp ? "KeyUp" : "KeyDown"),
                       keyno, mods));

  if (direction == Key_KeyUp)
    _swix(OS_CallAVector, _INR(0,1)|_IN(9), direction, keyno, KeyV);

  if (mods & KEY_MOD_CTRL)
    _swix(OS_CallAVector, _INR(0,1)|_IN(9), direction, Key_CtrlL, KeyV);
  if (mods & KEY_MOD_SHIFT)
    _swix(OS_CallAVector, _INR(0,1)|_IN(9), direction, Key_ShiftL, KeyV);
  if (mods & KEY_MOD_ALT)
    _swix(OS_CallAVector, _INR(0,1)|_IN(9), direction, Key_AltL, KeyV);

  if (direction == Key_KeyDown)
    _swix(OS_CallAVector, _INR(0,1)|_IN(9), direction, keyno, KeyV);
}
#endif


#ifdef POINTER
/*------------------------------------------------------------------------------
 *
 *	Process a packet from a pointer device
 */
static void process_pointer(packet_t packet, tag_info_t *tag)
{
  unsigned int irq_status, tag_number = packet.generic.tag;
  context_t context, *old_context = &(tags[tag_number].context);

#if DEBUG>=1
  if (tag->registry->packet_type == p_absolute)
  {
    db_printf("Device %x sends absolute packets:- not yet supported!\n",
              tag->registry->number);
    return;
  };
  if (tag->registry->packet_type != p_relative)
  {
    db_printf("Device %x says its a pointer but sends packets of type %d!\n",
              tag->registry->number, tag->registry->packet_type);
    return;
  };
#endif

  if (packet.relative.buttons != 0)
    context.pointer.buttons = packet.relative.buttons;
  else
    context.word = INACTIVE;

  /* Don't do anything on receipt of a packet resent due to missed ACK */
  if (!(packet.relative.resend && (old_context->word == context.word)))
  {
    /*
     * Critical section: don't want a PointerV while we're updating our counters
     */
    irq_status = irqs_off();
    {
      pointer_relx += (packet.relative.x << tag->registry->extra.scale);
      pointer_rely += (packet.relative.y << tag->registry->extra.scale);
    }
    irqs_restore(irq_status);

    if ((context.word != INACTIVE) && (old_context->word == context.word))
    {
      /* Cancel the pending timeout, set a new one */
      ir_cancel_timeout(tag_number);
      ir_set_timeout(tag_number, context);
    }
    else
    {
      /* Different button(s): Old button(s) up, cancel timeout */
      if (old_context->word != INACTIVE)
      {
        if (old_context->pointer.buttons & BUT_SELECT)
          ir_keyb(Key_KeyUp, Key_Select, 0);
        if (old_context->pointer.buttons & BUT_MENU)
          ir_keyb(Key_KeyUp, Key_Menu, 0);
        ir_cancel_timeout(tag_number);
      }

      /* If not in standby: New button(s) down, set timeout */
      if ((context.word != INACTIVE) && !(Flags & STANDBY))
      {
        if (context.pointer.buttons & BUT_SELECT)
          ir_keyb(Key_KeyDown, Key_Select, 0);
        if (context.pointer.buttons & BUT_MENU)
          ir_keyb(Key_KeyDown, Key_Menu, 0);
        ir_set_timeout(tag_number, context);
      }
    }
  }
#if DEBUG>=1
  else
    db_printf("!");
#endif

}

/*------------------------------------------------------------------------------
 *
 *	Report pointer movement. Called with IRQs off.
 *
 * Returns non-zero if we had some movement to report.
 */
int ir_pointer_status(int *relx, int *rely)
{
  if (pointer_relx || pointer_rely)
  {
    *relx = pointer_relx;
    *rely = pointer_rely;
    pointer_relx = pointer_rely = 0;		/* Reset our counters */
    return TRUE;
  }
  return FALSE;
}
#endif


#ifdef FAKEINPUT
/*------------------------------------------------------------------------------
 *
 *	Debugging printf
 */
int db_printf(const char *format, ...)
{
  char buffer[80];
  va_list list;
  int rval;

  va_start(list, format);
  rval = vsprintf(buffer, format, list);
  va_end(list);

  if (in_handle!=-1)
    socketwrite(in_handle, buffer, strlen(buffer));
  else
    puts(buffer);

  return rval;
}
#endif
