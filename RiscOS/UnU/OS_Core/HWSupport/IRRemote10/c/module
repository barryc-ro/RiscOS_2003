/*
 * 	module.c	- RISC OS module related code.
 */

/*
 * 		Copyright 1996 Acorn Network Computing
 *
 * This material is the confidential trade secret and proprietary
 * information of Acorn Network Computing. It may not be reproduced,
 * used, sold, or transferred to any third party without the prior
 * written consent of Acorn Network Computing. All rights reserved.
 *
 */

/* From CLib */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "kernel.h"
#include "swis.h"

#include "module.h"
#include "ir.h"

/*
 * Globals
 */
#if !DEBUG
static _kernel_oserror *TinyError;	/* For tinystubs */
#endif


/*------------------------------------------------------------------------------
 *
 *	Module initialisation entry point.
 */
_kernel_oserror *module_initialise( char *cmd_tail, int podule_base, void *pw )
{
  _kernel_oserror *err = ir_initialise(pw);

  NOT_USED(cmd_tail);
  NOT_USED(podule_base);

#if !DEBUG
  /* Try to use TinyStubs if possible. */
  if ( !err ) TinyError = _swix( TinySupport_Share, _IN(0), pw );
#endif

  return err;
}


/*------------------------------------------------------------------------------
 *
 *	Module finalisation entry point.
 */
_kernel_oserror *module_finalise( char *cmd_tail, int podule_base, void *pw )
{
  NOT_USED(cmd_tail);
  NOT_USED(podule_base);

  ir_finalise(pw);

#if !DEBUG
  if ( TinyError == NULL ) _swix( TinySupport_Die, 0 );
#endif

  return NULL;
}


/*------------------------------------------------------------------------------
 *
 *	Module CLI handler
 *
 * Only one command, = configure irfamily 
 */
_kernel_oserror *module_cli_handler(char *arg_string, int arg_count,
                                    int cmd_no, void *pw)
{
  int family;
  char buffer[8], *c;

  NOT_USED(pw);
  NOT_USED(cmd_no);
  NOT_USED(arg_count);

  if ((int) arg_string == 0)		/* Configure with no args */
    _swix(OS_Write0, _IN(0), "IRFamily   <1-15> | Any\r\n");

  else if ((int) arg_string == 1)	/* Status */
  {
    _swix(OS_Write0, _IN(0), "IRFamily   ");
    family = ir_getfamily();
    if (family != 0)
    {
      _swix(OS_ConvertCardinal1, _INR(0,2)|_OUT(1), family, &buffer, 4, &c);
      *(c++) = '\r'; *(c++) = '\n'; *c = '\0'	;	/* Add CRLF */
      _swix(OS_Write0, _IN(0), buffer);
    }
    else
      _swix(OS_Write0, _IN(0), "Any\r\n");
  }
  else					/* Configure with args */
  {
    _kernel_oserror *err = _swix(OS_ReadUnsigned, _INR(0,2)|_OUT(2),
					   10|(1<<29), arg_string, 15, &family);
    if (err)
    {
      int i;

      for (i=0; i<3; i++)
        arg_string[i] = tolower(arg_string[i]);

      if (!strncmp(arg_string, "any", 3))
        ir_setfamily(0);
      else
        return (err);
    }
    else
      ir_setfamily(family);
  }
  return NULL;
}


/*------------------------------------------------------------------------------
 *
 *	Module service call entry point.
 */
void module_service(int service_no, _kernel_swi_regs *r, void *pw)
{
  NOT_USED(pw);
  NOT_USED(r);

  if (service_no == Service_ShutDownComplete)
    Flags |= STANDBY;
#ifdef SCALE
  else if (service_no == Service_ModeChange)
    ir_modechange();
#endif
}


/*------------------------------------------------------------------------------
 *
 *	Module upcall handler. Called with IRQs enabled.
 */
int module_upcall_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED( pw );

  if (((r->r[0] == UpCall_DeviceRxDataPresent) ||
       (r->r[0] == UpCall_DeviceThresAbove)) &&
       (r->r[1] == in_handle))
  {
#if DEBUG>0
    if (r->r[0] == UpCall_DeviceThresAbove) db_printf("Threshhold!\n");
#endif
    ir_DeviceRxDataPresent();
  }
  else if ((r->r[0] == UpCall_File) &&
           (r->r[9] == UpCall_File_Closing))	/* Handle streams *shutted */
  {
#ifndef FAKEINPUT
    if (r->r[1] == in_handle)		/* Fatal condition! */
      Disable();			/* Panic! */
#endif
    if (r->r[1] == out_handle)
      out_handle = -1;			/* Can recover from this later */
  }
  else if (r->r[0] == UpCall_Online)
    Flags &= ~STANDBY;

  return 1;
}


#ifdef FAKEINPUT
/*------------------------------------------------------------------------------
 *
 *	Module event handler.
 */
int module_event_handler(_kernel_swi_regs *r, void *pw)
{
  /* Assumes only requested event in CMHG is Internet */
  if ((r->r[1] == 1) && (r->r[2] == in_handle))	/* Pour moi? */
  {
    ir_DeviceRxDataPresent();
    return 0;	/* Claim */
  }

  return 1;	/* Don't claim */

}
#endif


/*------------------------------------------------------------------------------
 *
 *	Module timeout handler.
 *
 * In:
 *	r0 = tag value of device that timed out.
 *
 * Called by timeout_preveneer via the C IRQ handler module_timeout_entry.
 * Must return 1 so that timeout_preveneer can restore r0.
 */
int module_timeout_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED( pw );
  ir_timeout(r->r[0]);
  return 1;
}


#ifdef KEYBOARD
/*------------------------------------------------------------------------------
 *
 *	Module KeyV handler.
 */
int module_keyv_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED( pw );

  /* Enable / flush drivers */
  if (r->r[0] == Key_Enable)
  {
    /* Cancel pending timeout & make us and OS forget which key(s) are down */
/* XXX Should do: */
// for tag=0 to n
//   if registry.device_type==(d_keyboard||d_pointer) && context!=INACTIVE
//     ir_timeout(tag)
//     ir_cancel_timeout(tag)
  }
  return 1;				/* Don't claim */
}
#endif


#ifdef POINTER
/*------------------------------------------------------------------------------
 *
 *	Module PointerV handler. Called with IRQs disabled.
 *
 * We (at least currently) are not a real mouse (ie we don't have a MouseType
 * number assigned to us) so we ignore Pointer_Enumerate and _Selected reason
 * codes and merely sneak in and claim Pointer_Status (irrespective of
 * MouseType) when we've moved.
 */
int module_pointerv_handler(_kernel_swi_regs *r, void *pw)
{
  NOT_USED( pw );

  if ((r->r[0] == Pointer_Status) &&	/* Report status */
      (ir_pointer_status(&(r->r[2]), &(r->r[3]))))
    return 0;				/* Claim if we have movement */

  return 1;				/* Don't claim */
}
#endif
