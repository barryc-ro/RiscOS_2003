; > &.Hourglass.Hourglass

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Debug
        GET     Hdr:Services
	GET	Hdr:UpCall
        GET     Hdr:Hourglass
        GET     Hdr:MsgTrans
;        GET     Hdr:EcoMacros
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
	GET	Hdr:STBState

        GET     Time+Date



	GBLL	Debug
Debug		SETL    :LNOT: ReleaseVersion

  [	{FALSE}
Debug_Module	SETL	True
SWIClass        SETS    "DebugIt"
        ^       &49ec0
        AddSWI  Register
        AddSWI  DeRegister
        AddSWI  WriteC
        AddSWI  GetString
  ]


; The constants defining the Hourglass time behaviour

StartupDelay    * 33

MySWIChunkBase  * Module_SWISystemBase + HourglassSWI * Module_SWIChunkSize
 ASSERT MySWIChunkBase = Hourglass_On

; Workspace

        ^ 0, wp
HourglassDepth          #       4
OnCallAfter		#       1 		; non0 => we've got a CallAfter pending

        AlignSpace

RAMSpaceRequired       * :INDEX: @

ModuleStart
        DCD     0                               ; StartCode
        DCD     InitialisationCode-ModuleStart
        DCD     FinalisationCode-ModuleStart
        DCD     ServiceCall-ModuleStart
        DCD     TitleString-ModuleStart
        DCD     HelpString-ModuleStart
        DCD     0                                       ; HelpAndCommandKeywordTable
        DCD     MySWIChunkBase
        DCD     SWIHandlerCode-ModuleStart
        DCD     SWIDecodingTable-ModuleStart
        DCD     0                                       ; SWIDecodingCode


SWIDecodingTable
TitleString
        DCB     "Hourglass", 0  ; Share
        DCB     "On", 0
        DCB     "Off", 0
        DCB     "Smash", 0
        DCB     "Start", 0
        DCB     "Percentage", 0
        DCB     "LEDs", 0
        DCB     "Colours", 0
        DCB     0

                GBLS    OsString
OsString        SETS    " (STB) © Online Media"

HelpString
        DCB     "Hourglass", 9, "2.", CurrentVersion
  [	ReleaseVersion
        !       0, "Assembling Hourglass 2.$CurrentVersion$OsString"
  |
        DCB     "/", CurrentIteration
        !       0, "Assembling Hourglass 2.$CurrentVersion/$CurrentIteration$OsString"
  ]
        DCB     " (", CurrentDate, ")"
  [	:LNOT: ReleaseVersion
        DCB     " assembled  at ", CurrentTime, "."
  ]
        DCB     "$OsString", 0
        ALIGN

InitialisationCode ROUT
        Push    "r0-r2, lr"                             ; Push the same registers as Service
        LDR     r2, [ r12 ]                             ; Is our workspace here already?
        TEQ     r2, #0                                  ; If not this will be zero
        BNE     SoftInitialisation                      ; Don't claim if we already have workspace
        MOV     r0, #ModHandReason_Claim                ; Claim some workspace
        MOV     r3, #RAMSpaceRequired                   ; We need this much free space
        SWI     XOS_Module                              ; Claim RMA
        BVS     ErrorExitInit
        STR     r2, [ r12 ]                             ; Update the private word
SoftInitialisation
        MOV     wp, r2                                  ; Now point to my workspace
        MOV     r0, #UpCallV				; get on UpCallV
        ADR     r1, UpCallHandler
        MOV     r2, wp
        SWI     XOS_Claim
InitialiseWorkspace
        MOV     r14, #0
        STR     r14, HourglassDepth
ErrorExitInit
        STRVS   r0, [ sp, #0 ]
ExitInit
        Pull    "r0-r2, pc"

FinalisationCode ROUT
	Push	lr
        LDR     wp, [ r12 ]
        MOV     r0, #UpCallV				; get off UpCallV
        ADR     r1, UpCallHandler
        MOV     r2, wp
        SWI     XOS_Release
	Pull	pc

ServiceCall     ROUT
        CMP     r1, #Service_Reset                      ; is it reset ? EQ,CSet if so
        TEQNE   r1, #Service_Error*4,2                  ; or error ? EQ, CClear if so
        MOVNE   pc, lr

        LDR     wp, [ r12 ]                             ; get my private word
        BCS     DoServiceReset
        B       HourglassSmash                          ; All errors turn off the hourglass

DoServiceReset
        Push    "r0-r2, lr"
        MOV     r0, #253                                ; Now check reset was NOT hard
        MOV     r1, #0                                  ; Read last reset type,
        MOV     r2, #255
        SWI     XOS_Byte                                ; only do reset when it was soft
        BVS     ErrorExitInit
        TEQ     r1, #0                                  ; Was it a soft-reset
        BNE     ExitInit                                ; No, it was hard, so exit
        B       InitialiseWorkspace

SWIHandlerCode  ROUT
        LDR     wp, [ r12 ]
        CMP     r11, #(EndOfJumpTable - SWIJumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        B       UnknownSWIError
SWIJumpTable
        B       HourglassOn
        B       HourglassOff
        B       HourglassSmash
        B       HourglassStart
        B       HourglassPercentage
        B       HourglassLEDs
        B       HourglassColours
EndOfJumpTable

 ASSERT HourglassSWICheckValue-Hourglass_On=(EndOfJumpTable - SWIJumpTable)/4

UnknownSWIError
        Push    "r1-r7, lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        MOV     r1, #0                                  ; No message block
        MOV     r2, #0                                  ; No buffer
        ADR     r4, TitleString
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r7, pc"

        MakeErrorBlock     ModuleBadSWI

; *****************************************************************************
;
;       HourglassOn - Turn on after default startup delay
;
; in:   -
;
; out:  -
;

HourglassOn ROUT
        Push    "r0, lr"
        MOV     r0, #StartupDelay
        BL      HourglassStart
        STRVS   r0, [ sp ]
        Pull    "r0, pc"

; *****************************************************************************
;
;       HourglassStart - Turn on after specified delay
;       If already on, just increment depth count
;
; in:   R0 = delay in centiseconds (0 => never update hourglass)
;
; out:  -
;

HourglassStart ROUT
        LDR     r11, HourglassDepth
        ADD     r11, r11, #1                            ; update my depth count
        STR     r11, HourglassDepth
  [	Debug
	BREG	r11, "HourglassOn, new depth="
  ]
        CMP     r11, #1                                 ; on 1st entry, really do something
        MOVHI   pc, lr

        Push    "r0-r2, lr"

	MOV	r1, #1
        STRB	r1, OnCallAfter				; Flag that we're on CallAfter

        ADR	r1, MyCallRoutine			; routine called after delay
        MOV     r2, wp
	SWI	XOS_CallAfter

        STRVS   r0, [ sp ]
        Pull    "r0-r2, pc"

; *****************************************************************************
;
;       HourglassOff - If at outer level, turn off hourglass, else dec depth
;
; in:   -
;
; out:  -
;

HourglassOff ROUT
        Push    "r0-r2, lr"

        LDR     r0, HourglassDepth
        SUBS    r0, r0, #1			; update my depth count
	Pull    "r0-r2, pc", MI			; if already zero, do nothing

        STR     r0, HourglassDepth		; store back
  [	Debug
	BREG	r0, "HourglassOff, new depth="
  ]
        Pull    "r0-r2, pc", NE			; if not bottom, leave alone

        TEQP    PC, #SVC_mode+I_bit		; interrupts off for this bit cos don't
						;  want the callafter to happen here
	LDRB	r0, OnCallAfter			; Have we set up a CallAfter?
        TEQ     r0, #0				; If not this will be zero
	BNE	OffCallAfter

	TEQP    PC, #SVC_mode			; critical section is over
  [	Debug
	DLINE	"Less busy"
  ]
	SWI     XSTBState_Busy			; go less busy (r0 still holds 0)
        Pull    "r0-r2, pc",,^                  ; but don't return V set if the SWI returns an error

OffCallAfter
	ADR	r0, MyCallRoutine		; Cancel CallAfter
	MOV	r1, wp
	SWI	XOS_RemoveTickerEvent

	MOV	r0, #0				; no longer on CallAfter
	STRB	r0, OnCallAfter			; store back

        Pull    "r0-r2, pc",EQ, ^


; *****************************************************************************
;
;       HourglassSmash - Unconditionally turn off hourglass
;
; in:   -
;
; out:  -
;

HourglassSmash ROUT
        Push    "r0, r1, lr"
        LDR     r0, HourglassDepth
        CMP     r0, #0                                  ; if at top, ignore

        MOVNE   r0, #1                                  ; depth count becomes one
        STRNE   r0, HourglassDepth
        SWINE   XHourglass_Off                          ; to force turn-off

        Pull    "r0, r1, pc"

; *****************************************************************************
;
;       HourglassPercentage - Set percentage figures - ignored
;
; in:   -
;
; out:  -
;

HourglassPercentage ROUT
        MOV     pc, lr

; *****************************************************************************
;
;       HourglassLEDs - Set LED states (currently 2 of them) - ignored
;
; in:   -
;
; out:  R0 = old LED state = 0
;

HourglassLEDs ROUT
        MOV     r0, #0
        MOV     pc, lr

; *****************************************************************************
;
;       HourglassColours - Set the colours used for the hourglass - ignored
;
; in:   -
;
; out:  R0 = Old colour that was being used as colour 1 = &ffff00
;       R1 = Old colour that was being used as colour 3 = %ff0000
;

HourglassColours
	LDR     r0, =&ffff00
	LDR     r1, =&ff0000
        MOV     pc, lr

; *****************************************************************************
;
;       MyCallRoutine - CallAfter routine - starts flashing the LEDs
;
;	Called with interrupts disabled

MyCallRoutine ROUT
        Push    "r0, lr"

	MOV	r0, #0
	STRB	r0, OnCallAfter			; No longer waiting for a CallAfter

  [	Debug
	DLINE	"More busy"
  ]
	MOV	r0, #1
	SWI	XSTBState_Busy

	Pull	"r0, pc",,^                     ; Don't return errors from SWI.


; *****************************************************************************
;
;       UpCallHander
;

UpCallHandler	ROUT
	CMP	r0, #UpCall_Online		; Only interested in this one
	MOVNES	pc, lr

	Push	"r0, lr"
	SWI	XHourglass_Smash
	Pull	"r0, pc",, ^


  [	Debug
	InsertDebugRoutines
  ]

        END
