        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:MEMM.ARM600

        GET     Hdr:Proc
        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GBLL    ShowROMTimings
ShowROMTimings  SETL {TRUE}

        GET     hdr.StaticWS
        GET     hdr.Hardware


        GBLA    CAS
CAS     SETA    3

; This version assumes a RISC OS image starting 64K after us.

        AREA    |!!!ROMStart|, CODE, READONLY, PIC


; v8 is used as pointer to RISC OS entry table throughout pre-MMU stage.
        MACRO
        CallOSM $entry, $reg
        LDR     ip, [v8, #$entry*4]
        MOV     lr, pc
        ADD     pc, v8, ip
        MEND

        MACRO
        CallOS  $entry
        ASSERT  $entry <= HighestOSEntry
        MOV     lr, pc
        LDR     pc, OSentries + 4*$entry
        MEND

HAL_Base

Cirrus_header
        DCD     &ABCDDCBA                       ; magic word
        DCD     1                               ; header vision number
        DCD     Cirrus_header_end-Cirrus_header ; header size
        DCD     2_000                   ; no dload, no wdog, no RAM test
        DCD     0                               ; OEMID
        DCD     0                               ; OEMID
        DCD     0                               ; OEMID
        DCD     0                               ; OEMID
        DCD     1024*1024                       ; image size
        DCD     0                               ; image CRC (what algorithm?)
        DCD     start-Cirrus_header             ; image entry (offset or absolute?)
        DCD     0                               ; header CRC
Cirrus_header_end

        ASSERT  . - HAL_Base < 0x60
        %       0x60 - (. - HAL_Base)
ROMsize
        DCD     0                       ; patched in by build system

        ENTRY
start
        ; The Boot ROM has done god knows what. Kill it.

        MSR     CPSR_c, #F32_bit+I32_bit+SVC32_mode

        LDR     v2, =WATCHDOG_BASE
        LDR     a1, =&AA55
        STR     a1, [v2, #WATCHDOG]             ; disable the watchdog

        LDR     v2, =RTC_BASE
        MOV     a1, #0
        STR     a1, [v2, #RTCCR]                ; disable RTC interrupts
        STR     a1, [v2, #RTCEOI]               ; clear interrupts

        LDR     v2, =MAC_BASE                   ; reset the PHY (?)
        MOV     a1, #&C00
        STR     a1, [v2, #MIIDATA]
        LDR     a1, =&43E0
        STR     a1, [v2, #MIICMD]

        LDR     v2, =KEY_BASE
        MOV     a1, #1:SHL:15                   ; disable 3 key reset
        STR     a1, [v2, #SCANINIT]

        LDR     v2, =INT_BASE                   ; mask off all interrupts
        MVN     a1, #0
        STR     a1, [v2, #CLRIRQMSKA]
        STR     a1, [v2, #CLRIRQMSKB]
        STR     a1, [v2, #CLRFIQMSKA]
        STR     a1, [v2, #CLRFIQMSKB]

        ADRL    v1, HAL_Base + 64*1024          ; v1 -> RISC OS image

        LDR     v8, [v1, #OSHdr_Entries]
        ADD     v8, v8, v1                      ; v8 -> RISC OS entry table

        MOV     a1, #0
        CallOSM OS_InitARM

        LDR     v2, =SYSCON_BASE

        LDR     a1, [v2, #RSTCR]
        MOV     a2, #&AA
        ORR     a1, a1, #1:SHL:1                ; disable Key Matrix controller
        ORR     a1, a1, #1:SHL:27               ; GPIO on Key Matrix
        STR     a2, [v2, #SYSLOCK]
        STR     a1, [v2, #RSTCR]

        BL      sort_out_the_blasted_clocks

        BL      initialise_ram

        MOV     sp, #&1000                      ; Wahey! A stack!

        BL      initialise_rom

        MOV     a1, #4:SHL:8
        MOV     a2, #0
        ADR     a3, HAL_Base                    ; a3 = bottom of HAL, may be top of RAM
        CMP     a3, #16*1024*1024
        ADDHI   a3, a2, #16*1024*1024           ; 16 M fitted
        LDR     a4, =&FFFFFFFF
        MOV     ip, #0
        STR     ip, [sp, #-4]!
        CallOSM OS_AddRAM
        STR     a1, [sp]
        ADD     sp, sp, #4

        MOV     a4, a1
        MOV     a1, #OSStartFlag_POR
        ADRL    a2, HAL_Base + 64*1024          ; a2 -> RISC OS image
        ADR     a3, HALdescriptor
        CallOSM OS_Start


;        MRC     p15, 0, v3, c1, c0
;        ORR     v3, v3, #MMUC_I
;        MCR     p15, 0, v3, c1, c0

02      MOV     a1, #&00000000
01      STR     a1, [a1]
        ADD     a1, a1, #4
        TEQ     a1, #&01000000
        BNE     %BT01

        LDR     v2, =LED_BASE
        MOV     a1, #2_1101
02      STR     a1, [v2, #LEDDATA]
        MOV     a3, #1024*1024
01      SUBS    a3, a3, #1
        BNE     %BT01
        EOR     a1, a1, #2_0011
        B       %BT02


HALdescriptor   DATA
        DCD     0
        DCD     HAL_Base - HALdescriptor
        DCD     64*1024
        DCD     HAL_EntryTable - HALdescriptor
        DCD     HAL_Entries
        DCD     HAL_WsSize


        MACRO
        HALEntry $name
        ASSERT  (. - HAL_EntryTable) / 4 = EntryNo_$name
        DCD     $name - HAL_EntryTable
        MEND

        MACRO
        NullEntry
        DCD     HAL_Null - HAL_EntryTable
        MEND

        IMPORT   Video_init
        IMPORT   Interrupt_Init
        IMPORT   Matrix_Init
        IMPORT   Timer_Init
        IMPORT   IIC_Init
        IMPORT   USB_Init

        IMPORT   HAL_IRQEnable
        IMPORT   HAL_IRQDisable
        IMPORT   HAL_IRQClear
        IMPORT   HAL_IRQSource

        IMPORT   HAL_Timers
        IMPORT   HAL_TimerDevice
        IMPORT   HAL_TimerGranularity
        IMPORT   HAL_TimerMaxPeriod
        IMPORT   HAL_TimerSetPeriod
        IMPORT   HAL_TimerPeriod
        IMPORT   HAL_TimerReadCountdown

        IMPORT   HAL_CounterRate
        IMPORT   HAL_CounterPeriod
        IMPORT   HAL_CounterRead
        IMPORT   HAL_CounterDelay

        IMPORT   HAL_IICBuses
        IMPORT   HAL_IICType
        IMPORT   HAL_IICSetLines
        IMPORT   HAL_IICReadLines

        IMPORT   HAL_NVMemoryType

        IMPORT   HAL_VideoFlybackDevice
        IMPORT   HAL_Video_SetMode
        IMPORT   HAL_Video_WritePaletteEntry
        IMPORT   HAL_Video_WritePaletteEntries
        IMPORT   HAL_Video_ReadPaletteEntry
        IMPORT   HAL_Video_SetInterlace
        IMPORT   HAL_Video_SetBlank
        IMPORT   HAL_Video_SetPowerSave
        IMPORT   HAL_Video_UpdatePointer
        IMPORT   HAL_Video_SetDAG
        IMPORT   HAL_Video_VetMode
        IMPORT   HAL_Video_PixelFormats
        IMPORT   HAL_Video_Features
        IMPORT   HAL_Video_BufferAlignment
        IMPORT   HAL_Video_OutputFormat

        IMPORT   HAL_MatrixColumns
        IMPORT   HAL_MatrixScan
;
;        IMPORT   HAL_TouchscreenType
;        IMPORT   HAL_TouchscreenRead
;        IMPORT   HAL_TouchscreenMode
;        IMPORT   HAL_TouchscreenMeasure
;
;        IMPORT   HAL_MachineID

HAL_EntryTable  DATA
        HALEntry HAL_Init

        HALEntry HAL_IRQEnable
        HALEntry HAL_IRQDisable
        HALEntry HAL_IRQClear
        HALEntry HAL_IRQSource

        HALEntry HAL_Timers
        HALEntry HAL_TimerDevice
        HALEntry HAL_TimerGranularity
        HALEntry HAL_TimerMaxPeriod
        HALEntry HAL_TimerSetPeriod
        HALEntry HAL_TimerPeriod
        HALEntry HAL_TimerReadCountdown

        HALEntry HAL_CounterRate
        HALEntry HAL_CounterPeriod
        HALEntry HAL_CounterRead
        HALEntry HAL_CounterDelay

        HALEntry HAL_NVMemoryType
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry
        NullEntry

        HALEntry HAL_IICBuses
        HALEntry HAL_IICType
        HALEntry HAL_IICSetLines
        HALEntry HAL_IICReadLines

        HALEntry HAL_VideoFlybackDevice
        HALEntry HAL_Video_SetMode
        HALEntry HAL_Video_WritePaletteEntry
        HALEntry HAL_Video_WritePaletteEntries
        HALEntry HAL_Video_ReadPaletteEntry
        HALEntry HAL_Video_SetInterlace
        HALEntry HAL_Video_SetBlank
        HALEntry HAL_Video_SetPowerSave
        HALEntry HAL_Video_UpdatePointer
        HALEntry HAL_Video_SetDAG
        HALEntry HAL_Video_VetMode
        HALEntry HAL_Video_PixelFormats
        HALEntry HAL_Video_Features
        HALEntry HAL_Video_BufferAlignment
        HALEntry HAL_Video_OutputFormat

        HALEntry HAL_MatrixColumns
        HALEntry HAL_MatrixScan

        NullEntry ; HALEntry HAL_TouchscreenType
        NullEntry ; HALEntry HAL_TouchscreenRead
        NullEntry ; HALEntry HAL_TouchscreenMode
        NullEntry ; HALEntry HAL_TouchscreenMeasure

        NullEntry ; HALEntry HAL_MachineID

        NullEntry ; HALEntry HAL_ControllerAddress
        NullEntry ; HALEntry HAL_HardwareInfo
        NullEntry ; HALEntry HAL_SuperIOInfo

HAL_Entries     * (.-HAL_EntryTable)/4

sort_out_the_blasted_clocks
        LDR     v2, =SYSCON_BASE
        MOV     v5, #&AA

; First disconnect core clocks from PLLs (boot ROM has been messing)

        ; Switch ARM to "fastbus" mode (clocked from HCLK)
        MRC     p15, 0, v3, c1, c0
        BIC     v3, v3, #MMUC_iA+MMUC_nF
        MCR     p15, 0, v3, c1, c0

        LDR     v3, [v2, #FHDIV]
        BIC     v3, v3, #&00200000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #FHDIV]

        LDR     v3, [v2, #PLL0CFG]
        BIC     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL0CFG]
        LDR     v3, [v2, #PLL1CFG]
        BIC     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL1CFG]
        LDR     v3, [v2, #PLLIDIV]
        BIC     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLLIDIV]


        ; Enable all branches of trunk 0; PLL0 input from XTALI;
        ; trunk 0 source = PLL0/2 (184.32MHz); power up PLL0; divider source = PLL0;
        ; PLL multiplier = 100 (368.64MHz)
        LDR     v3, =&7A809064
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL0CFG]

        MOV     a1, #100
01      SUBS    a1, a1, #1                      ; arbitrary delay loop
        BNE     %BT01

        ; Enable input to inter-PLL divider; PLL0 output -> inter-PLL divider input
        ; Divider value = 96 (3.84MHz)
        LDR     v3, =&00008060
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLLIDIV]

 [ {FALSE}
        ; Enable /2 branch of trunk 1; PLL1 input from inter-PLL divider;
        ; trunk 1 source = PLL1/2 (192MHz); power up PLL1; divider source = PLL1;
        ; PLL multiplier = 100 (384MHz)
        LDR     v3, =&16809064
 |
        ; Enable all branches of trunk 1; PLL1 input from inter-PLL divider;
        ; trunk 1 source = PLL1/2 (192MHz); power up PLL1; divider source = PLL1;
        ; PLL multiplier = 100 (384MHz)
        LDR     v3, =&7E809064
 ]
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL1CFG]

        MOV     a1, #100
01      SUBS    a1, a1, #1                      ; arbitrary delay loop
        BNE     %BT01

        LDR     v3, =FHDIV_VAL
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #FHDIV]

        ; Secondary dividers (copied from the manual)
        LDR     v3, =&00008004
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #USBDIV]
        LDR     v3, =&800A8004
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #IRDADIV]
        LDR     v3, =&00148006
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #VIDDIV]
        LDR     v3, =&800F803C
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #I2SDIV]
        LDR     v3, =&F0008032
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #UARTDIV]
        LDR     v3, =&C0008032
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #SPIDIV]
        LDR     v3, =&A0048004
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #KTDIV]
        LDR     v3, =&80048024
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #WATCHDIV]

        ; Syncronously enable trunks 0 & 1
        LDR     v3, [v2, #PLL0CFG]
        ORR     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL0CFG]
        LDR     v3, [v2, #PLL1CFG]
        ORR     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLL1CFG]
        ; Enable slow clocks
        LDR     v3, [v2, #PLLIDIV]
        ORR     v3, v3, #&80000000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #PLLIDIV]

;        ; Select bus priority scheme with Raster at top
;        MOV     a1, #2
;        STR     v5, [v2, #SYSLOCK]
;        STR     a1, [v2, #SYSCFG]

        ; Switch FCLK and HCLK to PLL (whoosh)
        LDR     v3, [v2, #FHDIV]
        ORR     v3, v3, #&00200000
        STR     v5, [v2, #SYSLOCK]
        STR     v3, [v2, #FHDIV]

        ; Switch ARM to synchronous mode
        MRC     p15, 0, v3, c1, c0
        BIC     v3, v3, #MMUC_iA+MMUC_nF
        ORR     v3, v3, #MMUC_iA+MMUC_nF                ; *** Actually asynchronous until check OK
        MCR     p15, 0, v3, c1, c0

        MOV     pc, lr



initialise_ram
        LDR     v2, =SDRAMCFG_BASE
        MOV     v4, lr

        CMP     pc, #&02000000
        BLO     initialise_ram_skip


        MOV     a1, #100
        BL      wait

        ; Issue a NOP to the SDRAM
        MOV     v1, #2_11
        STR     v1, [v2, #SDRAMCFG1]

        MOV     a1, #200
        BL      wait

        ; Issue PRECHARGE ALL to the SDRAM
        MOV     v1, #2_01
        STR     v1, [v2, #SDRAMCFG1]

        ; Refresh every ten cycles
        MOV     v1, #10
        STR     v1, [v2, #SDRAMCFG2]

        ; Wait for 8 refreshes (80 cycles)
        MOV     a1, #(80*1000000/HCLK)+1
        BL      wait

        ; Refresh every 15.625us
        LDR     v1, =((HCLK/1000000)*15625)/1000
        STR     v1, [v2, #SDRAMCFG2]

        ; Enable MODE command
        MOV     v1, #2_10
        STR     v1, [v2, #SDRAMCFG1]

        ; Issue the MODE command to all 4 chip selects:
        ; CAS latency 2, sequential 4-word burst
 [ CAS = 2
        LDR     v1, =2_000000100010 :SHL: 12
 |
        LDR     v1, =2_000000110010 :SHL: 12
 ]
        MOV     a2, #&08000000
        LDR     a1, [v1], a2
        LDR     a1, [v1], a2
        LDR     a1, [v1], a2
        LDR     a1, [v1], a2

;        ; Back to NOP
;        MOV     v1, #2_00
;        STR     v1, [v2, #SDRAMCFG1]
;
;        ; Wait until SDRAM engine idle  (this seems to lock???)
;01      LDR     a1, [v2, #SDRAMCFG1]
;        TST     a1, #1:SHL:5
;        BNE     %BT01

        ; No auto precharge, RAS latency 2, CAS latency 2, 32-bit bus, clock enable always
        ; on, clock runs continuously, 4 bank 16-bit non-256Mbit devices.
        ;              ARRCCXCE-BTF-BTF-BTF-BTF-
 [ CAS = 2
        LDR     v1, =2_0101001001000100010001000
 |
        LDR     v1, =2_0101101001000100010001000
 ]
        STR     v1, [v2, #SDRAMCFG0]

initialise_ram_skip
        ; Refresh every 15.625us
        LDR     v1, =((HCLK/1000000)*15625)/1000
        STR     v1, [v2, #SDRAMCFG2]

        ; 256 cycle write buffer timeout
        MOV     v1, #256
        STR     v1, [v2, #SDRAMCFG3]

        ; Normal operation, write buffer and read buffer enabled
        MOV     v1, #2_1100
;        MOV     v1, #2_0000
        STR     v1, [v2, #SDRAMCFG1]

        MOV     pc, v4


; wait n microseconds (yuck)
wait
        MOV     a2, #50
        MUL     a1, a2, a1
01      SUBS    a1, a1, #1              ; 4 cycles min per loop, max 200MHz, so at least 20ns
        BNE     %BT01                   ; so 50 loops for one microsecond
        MOV     pc, lr

initialise_rom
        LDR     a4, =SMC_BASE
        MOV     a3, #&AA
        STR     a3, [a4, #SMCSWLOCK]
        ; Program 32-bit SRAM (super-fast) - 1 cycle read, write, 1 cycle turnaround
        ;              AT  B E              W     IDCY-
        ;                MW W E        WST2- WST1-
        LDR     a2, =2_00100011000000000000010000000000
        STR     a2, [a4, #SMCCR2]
        ; System ROM
        MOV     a3, #&AA
        STR     a3, [a4, #SMCSWLOCK]
        LDR     a2, =SYS_ROM_CFG
        STR     a2, [a4, #SMCCR0]
        MOV     pc, lr

 [ {FALSE}

; Timings for AMD AM29LV160DB-90EC flash (90ns access from CS, 35ns from IOE)
; Contention limit: 30ns
 [ PLL = 129
; cycle time = 31.00ns - 3 cycles from CS (93ns), 2 cycles from IOE (62-7=55ns), 1.5 cycle recovery
IOCS0 * 2_00010110110101
 |
; cycle time = 27.13ns
;   non-burst/Flash device
;   2 cycles from CS to OE (54.3+7=61.3ns)
;   2 cycles OE hold (54.3ns)
;   device outputs 90ns after CS, 35ns after OE; ie 25.6ns into OE, giving 28.7ns hold (L7205 needs 10ns)
;   1.5 cycle recovery (40.7-7=33.7ns) - Flash spec says 30ns
IOCS0 * 2_00010100100111
 ]

initialise_rom
        LDR     R3, =SMIREG_BASE                ; set up cycle times for ROM bank 0
        LDR     R0, [R3, #IOCFG1]
        MOV     R0, R0, LSR #16
        LDR     R1, =IOCS0
        ORR     R0, R1, R0, LSL #16
        STR     R0, [R3, #IOCFG1]

        LDR     R3, =SYSTEM_BASE
        STR     R0, [R3, #SYS_RESET_REMAP]      ; get rid of the boot ROM
        MOV     PC, LR

initialise_serial
        LDR     R3, =UART1_BASE
        MOV     R0, #&17        ; 9600 baud
        STRB    R0, [R3, #L_UBRLCR]
        MOV     R0, #0
        STRB    R0, [R3, #M_UBRLCR]
        MOV     R0, #2_0010000
        STRB    R0, [R3, #H_UBRLCR]
        MOV     R0, #2_00000001
        STRB    R0, [R3, #UARTCON]
        MOV     PC, LR

 ]

;--------------------------------------------------------------------------------------


HAL_Init
        Entry

        BL      SetUpOSEntries

        MOV     a1, #0
        MOV     a2, #&80000000
        MOV     a3, #&01000000
        CallOS  OS_MapInIO
        STR     a1, HW_Address

        MOV     a1, #0
        MOV     a2, #&08000000
        MOV     a3, #&08000000
        CallOS  OS_MapInIO

        MOV     a1, #0
        MOV     a2, #&2C000000
        MOV     a3, #&00100000
        CallOS  OS_MapInIO
        STR     a1, KEY_Address

        BL      Interrupt_Init

        BL      Timer_Init

        BL      Matrix_Init

        BL      Video_init

        BL      IIC_Init

        BL      USB_Init

        EXIT

; Initialise and relocate the entry table.
SetUpOSEntries  ROUT
        STR     a1, OSheader
        LDR     a2, [a1, #OSHdr_NumEntries]
        CMP     a2, #HighestOSEntry+1
        MOVHI   a2, #HighestOSEntry+1

        ADR     a3, OSentries
        LDR     a4, [a1, #OSHdr_Entries]
        ADD     a4, a4, a1

05      SUBS    a2, a2, #1
        LDR     ip, [a4, a2, LSL #2]
        ADD     ip, ip, a4
        STR     ip, [a3, a2, LSL #2]
        BNE     %BT05

        MOV     pc, lr


HAL_Null
        MOV     pc, lr

HAL_ControllerAddress
        MOV     a1, #0
        MOV     pc, lr

HAL_HardwareInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        STR     ip, [a3]
        MOV     pc, lr

HAL_SuperIOInfo
        MOV     ip, #0
        STR     ip, [a1]
        STR     ip, [a2]
        MOV     pc, lr

        LTORG


        END
