/*main.c - generate system variables for System application*/

/*From CLib*/
#include <stdio.h>
#include <string.h>

/*From OSLib*/
#include "macros.h"
#include "os.h"
#include "osgbpb.h"
#include "osmodule.h"

/*From Support*/
#include "x.h"

/* J R C  2nd Mar 1995  Sorts the path elements, rather than assuming they
                        come out in numerical order.
                        Use x-clear SWI's.
                        Match any numerical directory. Sort in numerical
                        order.
*/

#define ENTRY_LIMIT 32 /*Number path elements we can cope with.*/

x_STATIC_ERROR (Too_Many_Entries, 1, "Too many entries")

static int Compare (void const *i0, void const *i1)
      {return atoi (*(char **) i1) - atoi (*(char **) i0);}

/*
 * Return the version number of a ROM module.
 */
static int Module_Version(const char *module)
{
   int v = 0, m, s;
   char *name;
   x_exception x;

   m = 0, s = -1;
   x_TRY (&x)
      /*Bizarrely, this call only stops when it gets an error ...*/
      while (TRUE)
      {  m = osmodule_enumerate_rom_with_info (m, s, &s, &name, NULL,
            NULL, &v);

         if (strcmp (name, module) == 0)
            break;
      }
   x_CATCH (&x)
      ;

   return v >> 8;
}

int main (void)

{  char info [os_FILE_NAME_LIMIT + 1], system_path [1024 + 1],
      system_dir [1024 + 1], sys_path [os_CLI_LIMIT + 1],
      os_version [os_CLI_LIMIT + 1], *entries [ENTRY_LIMIT];
   int context, version, n, used, v, entry, entry_count;
   char *point;
   x_exception x;
   os_error *e;

   x_TRY (&x)
   {  /*Fix fault: ignore arguments, and read System$Dir instead. J R C
         20th Mar 1995*/
      os_read_var_val ("System$Dir", system_dir, sizeof system_dir, 0,
            os_VARTYPE_STRING, &used, NULL);
      system_dir [used] = '\0';

      /*Set Sys$Path*/
      sprintf (sys_path, "%s.", system_dir);
      os_set_var_val ("Sys$Path", (byte *) sys_path, strlen (sys_path), 0,
            os_VARTYPE_STRING, NULL);

      /*Which OS are we running under?*/
      e = xos_read_var_val ("Boot$OSVersion", os_version, sizeof os_version, 0,
            os_VARTYPE_STRING, &used, NULL, NULL);
      if (e->errnum == error_VAR_CANT_FIND)
      {
         /* Set it if not already set */
         sprintf(os_version, "%X0%n", Module_Version("UtilityModule")/16, &used);
         os_set_var_val("Boot$OSVersion", (byte *) os_version, used, 0,
                        os_VARTYPE_STRING, NULL);
      }
      else if (e)
         x_THROW(e);
      else
         os_version [used] = '\0';

      /* Turn "3.50" into "350" */
      if ((point = strchr(os_version, '.')) != NULL)
      {
         do
         {
            *point=*(point+1);
         }
         while (*++point);
         os_set_var_val("Boot$OSVersion", (byte *) os_version, used, 0,
                        os_VARTYPE_STRING, NULL);
     }

      sscanf (os_version, "%d%n", &version, (n = -1, &n));
      if (n == strlen (os_version))
      {  entry_count = 0;
         context = 0;
         while ((context = osgbpb_dir_entries (system_dir,
               (osgbpb_string_list *) info, 1, context, sizeof info, "*",
               NULL)) != osgbpb_NO_MORE)
         {  /*Check that the name is composed of digits.*/
            sscanf (info, "%d%n", &v, (n = -1, &n));

            if (n == strlen (info) && v <= version)
            {  /*Add this directory to our table.*/
               if (entry_count == ENTRY_LIMIT)
                  x_THROW (Too_Many_Entries);

               strcpy (entries [entry_count++] = x_alloc (strlen (info) + 1),
                     info);
            }
         }

         /*Sort the list we just made.*/
         qsort (entries, entry_count, sizeof *entries, &Compare);

         CLEAR (system_path);
         for (entry = 0; entry < entry_count; entry++)
         {  if (!EMPTY (system_path)) strcat (system_path, ",");
            sprintf (system_path + strlen (system_path), "Sys:%s.",
                 entries [entry]);
         }

         if (!EMPTY (system_path)) strcat (system_path, ",");
         strcat (system_path, sys_path);

         os_set_var_val ("System$Path", (byte *) system_path,
               strlen (system_path), 0, os_VARTYPE_STRING, NULL);
      }
   }
   x_CATCH (&x)
      ;

   x_EXIT (&x);
}
