////////////////////////////////////////////////////////////////////////////
// Nastily removed most of the error checking and added some of Alex Burr's
//   code that adds MPEG2 tables. However they're not really much use since
//   the Replay encoder doesn't yet know how to generate data using them.
//   These additions are noted in the comments.
//
// Pete Goodliffe (29 Jan 1998)

#if 0
#define DECODEDIAGS 1
#endif
/**********************************************************************
Copyright (c) 1991 MPEG/audio software simulation group, All Rights Reserved
decode.c
**********************************************************************/
/**********************************************************************
 * MPEG/audio coding/decoding software, work in progress              *
 *   NOT for public distribution until verified and approved by the   *
 *   MPEG/audio committee.  For further information, please contact   *
 *   Davis Pan, 508-493-2241, e-mail: pan@3d.enet.dec.com          *
 *                                                                    *
 * VERSION 3.9                                                       *
 *   changes made since last update:                                  *
 *   date   programmers         comment                               *
 * 2/25/91  Douglas Wong,       start of version 1.0 records          *
 *          Davis Pan                                                 *
 * 3/06/91  Douglas Wong        rename: setup.h to dedef.h            *
 *                                      dfilter to defilter           *
 *                                      dwindow to dewindow           *
 *                              integrated "quantizer", "scalefactor" *
 *                              combined window_samples routine into  *
 *                              filter samples                        *
 * 3/31/91  Bill Aspromonte     replaced read_filter by               *
 *                              create_syn_filter and introduced a    *
 *                              new Sub-Band Synthesis routine called *
 *                              SubBandSynthesis()                    *
 * 5/10/91  Vish (PRISM)        Ported to Macintosh and Unix.         *
 *                              Changed "out_fifo()" so that last     *
 *                              unfilled block is also written out.   *
 *                              "create_syn_filter()" was modified so *
 *                              that calculation precision is same as *
 *                              in specification tables.              *
 *                              Changed "decode_scale()" to reflect   *
 *                              specifications.                       *
 *                              Removed all routines used by          *
 *                              "synchronize_buffer()".  This is now  *
 *                              replaced by "seek_sync()".            *
 *                              Incorporated Jean-Georges Fritsch's   *
 *                              "bitstream.c" package.                *
 *                              Deleted "reconstruct_sample()".       *
 * 27jun91  dpwe (Aware)        Passed outFile and &sampFrames as     *
 *                              args to out_fifo() - were global.     *
 *                              Moved "alloc_*" reader to common.c.   *
 *                              alloc, sblimit, stereo passed via new *
 *                              'frame_params struct (were globals).  *
 *                              Added JOINT STEREO decoding, lyrs I&II*
 *                              Affects: decode_bitalloc,buffer_samps *
 *                              Plus a few other cleanups.            *
 * 6/10/91   Earle Jennings     conditional expansion added in        *
 *                              II_dequantize_sample to handle range  *
 *                              problems in MSDOS version             *
 * 8/8/91    Jens Spille        Change for MS-C6.00                   *
 *10/1/91    S.I. Sudharsanan,  Ported to IBM AIX platform.           *
 *           Don H. Lee,                                              *
 *           Peter W. Farrett                                         *
 *10/3/91    Don H. Lee         implemented CRC-16 error protection   *
 *                              newly introduced functions are        *
 *                              buffer_CRC and recover_CRC_error.     *
 * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
 *                              important fixes involved changing     *
 *                              16-bit ints to long or unsigned in    *
 *                              bit alloc routines for quant of 65535 *
 *                              and passing proper function args.     *
 *                              Removed "Other Joint Stereo" option   *
 *                              and made bitrate be total channel     *
 *                              bitrate, irrespective of the mode.    *
 *                              Fixed many small bugs & reorganized.  *
 * 7/27/92  Juan Pineda         Bug fix in SubBandSynthesis()         *
 **********************************************************************/

#include <stdio.h>
#include "mpa.h"
#include "fxptparams.h"
#include "soundtypes.h"
#include "frame.h"
#include "tables.h"
#include "bits.h"
#include "decode.h"

/***************************************************************/
/*                                                             */
/* This module contains the core of the decoder ie all the     */
/* computational routines. (Layer I and II only)               */
/* Functions are common to both layer unless                   */
/* otherwise specified.                                        */
/*                                                             */
/***************************************************************/

const unsigned char mx[64] =
{
#define MX(n) (((n)/3) << 2 | ((n) % 3))
    MX( 0), MX( 1), MX( 2), MX( 3), MX( 4), MX( 5), MX( 6), MX( 7),
    MX( 8), MX( 9), MX(10), MX(11), MX(12), MX(13), MX(14), MX(15),
    MX(16), MX(17), MX(18), MX(19), MX(20), MX(21), MX(22), MX(23),
    MX(24), MX(25), MX(26), MX(27), MX(28), MX(29), MX(30), MX(31),
    MX(32), MX(33), MX(34), MX(35), MX(36), MX(37), MX(38), MX(39),
    MX(40), MX(41), MX(42), MX(43), MX(44), MX(45), MX(46), MX(47),
    MX(48), MX(49), MX(50), MX(51), MX(52), MX(53), MX(54), MX(55),
    MX(56), MX(57), MX(58), MX(59), MX(60), MX(61), MX(62), MX(63)
};

const unsigned char pos_to_band[32] =
{
     0, 31,  1, 30,  3, 28,  2, 29,    7, 24,  6, 25,  4, 27,  5, 26,
    15, 16, 14, 17, 12, 19, 13, 18,    8, 23,  9, 22, 11, 20, 10, 21
};
const unsigned char band_to_pos[32] =
{
     0,  2,  6,  4, 12, 14, 10,  8,   24, 26, 30, 28, 20, 22, 18, 16,
    17, 19, 23, 21, 29, 31, 27, 25,    9, 11, 15, 13,  5,  7,  3,  1
};


/***************************************************************/
/*                                                             */
/* The following routines decode the system information        */
/*                                                             */
/***************************************************************/

/************ Layer I, Layer II & Layer III ******************/

int decode_header (FrameInfo *fi)
{
    /*
     * Check for minimal number of bits for header; we obviously need more
     * really, but this is OK for now.
     */
    int gotheader = ensure_bits (32+16); /* allow for CRC also */
    uint32 h = (gotheader ? getbits (32) : 0);
    int mode, layer, nchan, samprate; // added samprate 28 Jan 98
    uint32 bitrate;
    int slotbits, framesamples;
    if (!gotheader)
	return 0;
    fi->header = h;
    if (FR_SYNC(h) != 0xFFF)
    {
	/* must see sync bits or else die! */
//	fprintf (stderr, "Synchronisation error\n");
//	exit (1);
      return 0;
    }
    if (FR_ID(h) != 1)
    {
	/* require ISO/IEC 11172-3 format only */
//	fprintf (stderr, "Invalid ID bit in header\n");
//	exit (1);
      return 0;
    }
    if (FR_BITRATE_X(h) == 0)
    {
	/* Can't cope with free format! */
//	fprintf (stderr, "Can't decode free format stream\n");
//	exit (1);
      return 0;
    }
    fi->startpos = bitposition () - 32;	/* to allow for ancilliary data at end */
    /* Read the CRC now, if error protection is on for this frame */
    if (FR_PROT(h))
	fi->crc = getbits (16);
    mode = FR_MODE(h);
    layer = FR_LAYER(h);
    fi->nchan = nchan = (mode == MODE_MONO) ? 1 : 2;
    samprate = FR_SAMPRATE_X(h);                    // added 28 Jan 98
    //fi->ID=FR_ID(h); //this is never used anyway  // added 28 Jan 98
    if (FR_ID(h)) {                                 // added 28 Jan 98
      samprate = sample_rate1[samprate];            // added 28 Jan 98
      if (layer == 1)
      {
	bitrate = LI_bitrate_M1[FR_BITRATE_X(h)-1];// !!! different for MPEG2
	slotbits = 32;
	framesamples = 384;
	fi->sblimit = SBLIMIT;		/* always 32 subbands for layer I */
	                                // NSUBBAND in Alex's code //
      }
      else if (layer == 2)
      {
	bitrate = LII_bitrate_M1[FR_BITRATE_X(h)-1]; // !!! different for MPEG2
	slotbits = 8;
	framesamples = 1152;
	/* set sblimit & alloc */
	set_alloc_table (fi, samprate, bitrate / nchan,1); // altered 28 Jan
      }
      else if (layer == 3)
      {
//	fprintf (stderr, "Layer III not supported\n");
//	exit (1);
        return 0;
      }
      else
      {
//	fprintf (stderr, "Reserved layer field\n");
//	exit (1);
        return 0;
      }
    }      // added 28 Jan 98
    else{  // added this whole else block 28 Jan 98

      samprate = sample_rate2[samprate];
      if (layer == 1)
      {
	bitrate = LI_bitrate_M2[FR_BITRATE_X(h)-1];// !!! different for MPEG2
	slotbits = 32;
	framesamples = 384;
	fi->sblimit = SBLIMIT;		/* always 32 subbands for layer I */
	                                // NSUBBAND in Alex's code //
      }
      else if (layer == 2)
      {
	bitrate = LII_bitrate_M2[FR_BITRATE_X(h)-1]; // !!! different for MPEG2
	slotbits = 8;
	framesamples = 1152;
	/* set sblimit & alloc */
	set_alloc_table (fi, samprate, bitrate / nchan,0); // altered 28 Jan 98
      }
      else if (layer == 3)
      {
//	fprintf (stderr, "Layer III not supported\n");
//	exit (1);
        return 0;
      }
      else
      {
//	fprintf (stderr, "Reserved layer field\n");
//	exit (1);
        return 0;
      }
    }      // added 28 Jan 98
    if (samprate == 0)                     // added this check 28 Jan 98
    {
//	printf ("Invalid sample rate!\n");
//	exit (1);
        return 0;
    }
    /* Work out how many bits this frame occupies */
    fi->totalbits =
	(bitrate * framesamples / samprate) / slotbits * slotbits +
	    FR_PADDING(h) * slotbits;
    if (mode == MODE_JSTEREO)
    {
	const static uint8 jsbound_map[3][4] =
	{
	    {  4,  8, 12, 16 },
	    {  4,  8, 12, 16 },
	    {  0,  4,  8, 16 }
	};
        fi->jsbound = jsbound_map[layer-1][FR_MODEEXT(h)];
    }
    else
        fi->jsbound = fi->sblimit;
    return 1;				/* header decoded OK */
}

/* Handle any bits between end of coded data and start of next frame */
void decode_ancilliary_data (FrameInfo *fi)
{
    uint32 curpos = bitposition ();
    uint32 endpos = fi->startpos + fi->totalbits;
#if defined(DECODEDIAGS)
    fprintf (stderr, "%d bits of ancilliary data\n", endpos-curpos);
#endif
    while (curpos + 32 <= endpos)
    {
	(void) getbits (32);	/* just throw away for now! */
	curpos += 32;
    }
    if (curpos < endpos)
	(void) getbits (endpos - curpos);
}


/***************************************************************/
/*                                                             */
/* The bit allocation information is decoded. Layer I          */
/* has 4 bit per subband whereas Layer II is Ws and bit rate   */
/* dependent.                                                  */
/*                                                             */
/***************************************************************/

/**************************** Layer II *************/

int II_decode_bitalloc (int *bit_alloc, FrameInfo *fi)
{
    int band;
    int nchan = fi->nchan;
    int sblimit = fi->sblimit;
    int jsbound = fi->jsbound;
    al_table *alloc = fi->alloc;
    const unsigned char *bp;
    int *ball;
    int nsf;

//#if defined(DECODEDIAGS)
//    if (diags)
//	fprintf (stderr, "decode_bitalloc: pos %u nchan %d sblimit %d jsbound %d\n",
//		 bitposition(), nchan, sblimit, jsbound);
//#endif
    bp = band_to_pos;
    ball = bit_alloc;
    nsf = 0;
    for (band = 0; band < jsbound; ++band)
    {
	sb_alloc *ap = alloc->al[band];
	int nbit = ap[0].bits + 1;
	int chan;
	const int bandpos = *bp++;
	for (chan = 0; chan < nchan; ++chan)
	{
	    int b = getbits (nbit);
	    if (b)
	    {
		BITALL ba;
		ba.a = ap[b];
		ba.a.bandpos = bandpos;  ba.a.chan = chan; ba.a.js = 0;
		*ball++ = ba.i;
		++nsf;
//#if defined(DECODEDIAGS)
//		if (diags)
//		    fprintf (stderr, "s: bits %d b %d band %d pos %d chan %d\n", nbit, b, band, bandpos, chan);
//#endif
	    }
	}
    }
    for (band = jsbound; band < sblimit; ++band)
    {
	const sb_alloc *const ap = alloc->al[band];
	const int nbit = ap[0].bits + 1;
	const int b = getbits (nbit);
	const int bandpos = *bp++;
	if (b)
	{
	    BITALL ba;
	    ba.a = ap[b];
	    ba.a.bandpos = bandpos;		/* chan irrelevant */
	    ba.a.js = 1;
	    *ball++ = ba.i;
	    nsf += 2;
//#if defined(DECODEDIAGS)
//	    if (diags)
//		fprintf (stderr, "js: bits %d b %d band %d pos %d\n", nbit, b, band, bandpos);
//#endif
	}
    }
    *ball++ = -1;			/* terminate the list */
    return nsf;
}

uint32 II_decode_bitalloc_CRC (int *bit_alloc, FrameInfo *fi, unsigned int crc)
{
    int band;
    int nchan = fi->nchan;
    int sblimit = fi->sblimit;
    int jsbound = fi->jsbound;
    al_table *alloc = fi->alloc;
    const unsigned char *bp;
    int *ball, nsf;

    bp = band_to_pos;
    ball = (int *)bit_alloc;
    nsf = 0;
    for (band = 0; band < jsbound; ++band)
    {
	const sb_alloc *ap = alloc->al[band];
	const int bits = ap[0].bits + 1;
	const int bandpos = *bp++;
	int chan;
	for (chan = 0; chan < nchan; ++chan)
	{
	    const int b = getbits (bits);
	    crc = crc_step (crc, bits, b);
	    if (b)
	    {
		BITALL ba;
		ba.a = ap[b];
		ba.a.bandpos = bandpos;
		ba.a.js = 0;
		ba.a.chan = chan;
		*ball++ = ba.i;
		++nsf;
	    }
	}
    }
    for (band = jsbound; band < sblimit; ++band)
    {
	const sb_alloc *ap = alloc->al[band];
	const int nbit = ap[0].bits + 1;
	const int b = getbits (nbit);
	const int bandpos = *bp++;
	crc = crc_step (crc, nbit, b);
	if (b)
	{
	    BITALL ba;
	    ba.a = ap[b];
	    ba.a.bandpos = bandpos;
	    ba.a.js = 1;
	    ba.a.chan = 0;
	    *ball++ = ba.i;
	    nsf += 2;
	}
    }
    *ball++ = -1;			/* terminate the list */
    return crc | nsf << 16;
}

/**************************** Layer I *************/

void I_decode_bitalloc (unsigned int bit_alloc[2][SBLIMIT],
			FrameInfo *fi, unsigned int *crcp)
{
    int i,j;
    int nchan  = fi->nchan;
    int jsbound = fi->jsbound;
    unsigned int crc;

    if (crcp)
	crc = *crcp;
    for (i = 0; i < jsbound; ++i)
    {
	for (j = 0; j < nchan; ++j)
	{
	    int bits = getbits (4);
	    if (crcp)
		crc = crc_step (crc, 4, bits);
	    bit_alloc[j][i] = bits;
	}
    }
    for (i = jsbound; i < SBLIMIT; ++i)
    {
	int bits = getbits (4);
	if (crcp)
	    crc = crc_step (crc, 4, bits);
	for (j = 0; j < nchan; ++j)
	    bit_alloc[j][i] = bits;
    }
    *crcp = crc;
}

/***************************************************************/
/*                                                             */
/* The following two functions implement the layer I and II    */
/* format of scale factor extraction. Layer I involves reading */
/* 6 bit per subband as scale factor. Layer II requires reading*/
/* first the scfsi which in turn indicate the number of scale  */
/* factors transmitted.                                        */
/*    Layer I : I_decode_scale                                 */
/*   Layer II : II_decode_scale                                */
/*                                                             */
/***************************************************************/

/************************** Layer I stuff ************************/

void I_decode_scale(unsigned int bit_alloc[2][SBLIMIT],
		    unsigned char scale_index[2][3][SBLIMIT], FrameInfo *fi,
		    unsigned int *crcp)
{
    int i,j;
    int nchan = fi->nchan;
    unsigned int crc;

    if (crcp)
	crc = *crcp;
    for (i = 0; i < SBLIMIT; ++i)
    {
	for (j = 0; j < nchan; ++j)
	{
	    if (!bit_alloc[j][i])
		scale_index[j][0][i] = MX(SCALE_RANGE-1);
	    else                    /* 6 bit per scale factor */
	    {
		int sf = getbits (6);
		if (crcp)
		    crc = crc_step (crc, 6, sf);
		scale_index[j][0][i] = MX(sf);
	    }
	}
    }
    if (crcp)
	*crcp = crc;
}

/*************************** Layer II stuff ***************************/

void II_decode_scale_mono (int *bit_alloc, int nsf,
			   unsigned char scale_index[3][SBLIMIT],
			   FrameInfo *fi)
{
    int *ball;
    unsigned char scfsi[3*SBLIMIT];
    unsigned char *sia, *limit;
    BITALL ba;

    ball = (int *)bit_alloc;
    sia = scfsi;
    while ((ba.i = *ball++) != -1)
    {
	const int bandpos = ba.a.bandpos;
	const int sim = getbits (2);
	*sia++ = bandpos << 3 | sim;
    }
    limit = sia;
    sia = scfsi;
    while (sia < limit)
    {
	const int s = *sia++;
	const int bandpos = s >> 3;
	unsigned char * const sip = &scale_index[0][bandpos];
	int bits;
	switch (s & 3)
	{
	  case 0:		    /* all three scale factors transmitted */
	    bits = getbits (18);
	    break;

	  case 1:		    /* scale factor 1 & 3 transmitted, 2 = 1 */
	    bits = getbits (12);
	    bits = bits | (bits & 0xFC0) << 6;
	    break;

	  case 3:		    /* scale factor 1 & 2 transmitted, 3 = 2 */
	    bits = getbits (12);
	    bits = bits << 6 | (bits & 0x3F);
	    break;

	  case 2:		    /* only one scale factor transmitted, for all 3 */
	    bits = getbits (6);
	    bits = bits | bits << 6 | bits << 12;
	    break;
	}
	sip[0*SBLIMIT] = mx[bits >> 12];
	sip[1*SBLIMIT] = mx[bits >> 6 & 0x3F];
	sip[2*SBLIMIT] = mx[bits & 0x3F];
//#if defined(DECODEDIAGS)
//	if (diags)
//	    fprintf (stderr, "sfmx (%x %x %x)\n", sip[0*SBLIMIT], sip[1*SBLIMIT], sip[2*SBLIMIT]);
//#endif
    }
}

void II_decode_scale_stereo (int *bit_alloc, int nsf,
			     unsigned char scale_index[3][SBLIMIT][2],
			     FrameInfo *fi)
{
    int *ball;
    unsigned char scfsi[3*SBLIMIT*2];
    unsigned char *sia, *limit;
    BITALL ba;

    ball = (int *)bit_alloc;
    sia = scfsi;
//#if defined(DECODEDIAGS)
//    if (diags)
//	fprintf (stderr, "pos = %u, scfsi [ ", bitposition ());
//#endif
    while ((ba.i = *ball++) != -1)
    {
	const int bandpos = ba.a.bandpos;
	if (!ba.a.js)
	{
	    const int sim = getbits (2);
//#if defined(DECODEDIAGS)
//	    if (diags)
//		fprintf (stderr, "%d ", sim);
//#endif
	    *sia++ = bandpos << 3 | ba.a.chan << 2 | sim;
	}
	else
	{
	    const int sim = getbits (4);
//#if defined(DECODEDIAGS)
//	    if (diags)
//		fprintf (stderr, "%d/%d ", sim >> 2, sim & 3);
//#endif
	    *sia++ = bandpos << 3 | 0 << 2 | (sim >> 2);
	    *sia++ = bandpos << 3 | 1 << 2 | (sim & 3);
	}
    }
//#if defined(DECODEDIAGS)
//    fprintf (stderr, "]\n");
//#endif
    limit = sia;
    sia = scfsi;
    while (sia < limit)
    {
	const int s = *sia++;
	const int bandpos = s >> 3;
	const int chan = (s >> 2) & 1;
	unsigned char *const sip = &scale_index[0][bandpos][chan];
	int bits;
	switch (s & 3)
	{
	  case 0:		    /* all three scale factors transmitted */
	    bits = getbits (18);
	    break;

	  case 1:		    /* scale factor 1 & 3 transmitted, 2 = 1 */
	    bits = getbits (12);
	    bits = bits | (bits & 0xFC0) << 6;
	    break;

	  case 3:		    /* scale factor 1 & 2 transmitted, 3 = 2 */
	    bits = getbits (12);
	    bits = bits << 6 | (bits & 0x3F);
	    break;

	  case 2:		    /* only one scale factor transmitted, for all 3 */
	    bits = getbits (6);
	    bits = bits | bits << 6 | bits << 12;
	    break;
#if 0
	  case 4: case 5: case 6: case 7: /* fool compiler */
	  default:
	    break;
#endif
	}
	sip[0*SBLIMIT*2] = mx[bits >> 12];
	sip[1*SBLIMIT*2] = mx[bits >> 6 & 0x3F];
	sip[2*SBLIMIT*2] = mx[bits & 0x3F];
//#if defined(DECODEDIAGS)
//	if (diags)
//	    fprintf (stderr, "sfmx (%x %x %x)\n", sip[0*SBLIMIT*2], sip[1*SBLIMIT*2], sip[2*SBLIMIT*2]);
//#endif
    }
}

uint32 II_decode_scale_mono_CRC (int *bit_alloc, int nsf,
				 unsigned char scale_index[3][SBLIMIT],
				 FrameInfo *fi, unsigned int crc)
{
    int *ball;
    unsigned char scfsi[3*SBLIMIT];
    unsigned char *sia, *limit;
    BITALL ba;

    ball = (int *)bit_alloc;
    sia = scfsi;
    while ((ba.i = *ball++) != -1)
    {
	const int bandpos = ba.a.bandpos;
	const int sim = getbits (2);
	crc = crc_step (crc, 2, sim);
	*sia++ = bandpos << 3 | sim;
    }
    limit = sia;
    sia = scfsi;
    while (sia < limit)
    {
	const int s = *sia++;
	const int bandpos = s >> 3;
	unsigned char *sip = &scale_index[0][bandpos];
	int bits;
	switch (s & 3)
	{
	  case 0:		    /* all three scale factors transmitted */
	    bits = getbits (18);
	    break;

	  case 1:		    /* scale factor 1 & 3 transmitted, 2 = 1 */
	    bits = getbits (12);
	    bits = bits | (bits & 0xFC0) << 6;
	    break;

	  case 3:		    /* scale factor 1 & 2 transmitted, 3 = 2 */
	    bits = getbits (12);
	    bits = bits << 6 | (bits & 0x3F);
	    break;

	  case 2:		    /* only one scale factor transmitted, for all 3 */
	    bits = getbits (6);
	    bits = bits | bits << 6 | bits << 12;
	    break;
	}
	sip[0*SBLIMIT] = mx[bits >> 12];
	sip[1*SBLIMIT] = mx[bits >> 6 & 0x3F];
	sip[2*SBLIMIT] = mx[bits & 0x3F];
    }
    return crc;
}

uint32 II_decode_scale_stereo_CRC (int *bit_alloc, int nsf,
				   unsigned char scale_index[3][SBLIMIT][2],
				   FrameInfo *fi, unsigned int crc)
{
    int *ball;
    unsigned char scfsi[3*SBLIMIT*2];
    unsigned char *sia, *limit;
    BITALL ba;

    ball = (int *)bit_alloc;
    sia = scfsi;
    while ((ba.i = *ball++) != -1)
    {
	const int bandpos = ba.a.bandpos;
	if (!ba.a.js)
	{
	    const int sim = getbits (2);
	    crc = crc_step (crc, 2, sim);
	    *sia++ = bandpos << 3 | ba.a.chan << 2 | sim;
	}
	else
	{
	    const int sim = getbits (4);
	    crc = crc_step (crc, 4, sim);
	    *sia++ = bandpos << 3 | 0 << 2 | (sim >> 2);
	    *sia++ = bandpos << 3 | 1 << 2 | (sim & 3);
	}
    }
    limit = sia;
    sia = scfsi;
    while (sia < limit)
    {
	int s = *sia++;
	int bandpos = s >> 3;
	int chan = (s >> 2) & 1;
	unsigned char *sip = &scale_index[0][bandpos][chan];
	int bits;
	switch (s & 3)
	{
	  case 0:		    /* all three scale factors transmitted */
	    bits = getbits (18);
	    break;

	  case 1:		    /* scale factor 1 & 3 transmitted, 2 = 1 */
	    bits = getbits (12);
	    bits = bits | (bits & 0xFC0) << 6;
	    break;

	  case 3:		    /* scale factor 1 & 2 transmitted, 3 = 2 */
	    bits = getbits (12);
	    bits = bits << 6 | (bits & 0x3F);
	    break;

	  case 2:		    /* only one scale factor transmitted, for all 3 */
	    bits = getbits (6);
	    bits = bits | bits << 6 | bits << 12;
	    break;
	}
	sip[0*SBLIMIT*2] = mx[bits >> 12];
	sip[1*SBLIMIT*2] = mx[bits >> 6 & 0x3F];
	sip[2*SBLIMIT*2] = mx[bits & 0x3F];
//#if defined(DECODEDIAGS)
//	if (diags)
//	    fprintf (stderr, "sfmx (%d %d %d)\n",
//		     sip[0*SBLIMIT*2], sip[1*SBLIMIT*2], sip[2*SBLIMIT*2]);
//#endif
    }
    return crc;
}

/***************************************************************/
/*                                                             */
/*   The following two routines take care of reading the       */
/* compressed sample from the bit stream for both layer 1 and  */
/* layer 2. For layer 1, read the number of bits as indicated  */
/* by the bit_alloc information. For layer 2, if grouping is   */
/* indicated for a particular subband, then the sample size has*/
/* to be read from the bits_group and the merged samples has   */
/* to be decompose into the three distinct samples. Otherwise, */
/* it is the same for as layer one.                            */
/*                                                             */
/***************************************************************/

/******************************* Layer I stuff ******************/

void I_buffer_sample (unsigned int sample[2][3][SBLIMIT],
		      unsigned int bit_alloc[2][SBLIMIT], FrameInfo *fi)
{
    int i,j,k;
    int nchan = fi->nchan;
    int jsbound = fi->jsbound;
    unsigned int s;

    for (i=0;i<jsbound;i++) for (j=0;j<nchan;j++)
        if ( (k = bit_alloc[j][i]) == 0)
            sample[j][0][i] = 0;
        else
            sample[j][0][i] = (unsigned int) getbits (k+1);
    for (i=jsbound;i<SBLIMIT;i++) {
        if ( (k = bit_alloc[0][i]) == 0)
            s = 0;
        else
            s = (unsigned int)getbits (k+1);
        for (j=0;j<nchan;j++)
            sample[j][0][i]    = s;
    }
}

/***************************************************************/
/*                                                             */
/*   Restore the compressed sample to a factional number.      */
/*   first complement the MSB of the sample                    */
/*    for layer I :                                            */
/*    Use s = (s' + 2^(-nb+1) ) * 2^nb / (2^nb-1)              */
/*   for Layer II :                                            */
/*   Use the formula s = s' * c + d                            */
/*                                                             */
/***************************************************************/

/************************** Layer I stuff ************************/

//void I_dequantize_sample (unsigned int sample[2][3][SBLIMIT], float fraction[2][3][SBLIMIT],
//			  unsigned int bit_alloc[2][SBLIMIT], FrameInfo *fi)
//{
//    int i, nb, k;
//    int nchan = fi->nchan;
//
//    for (i=0;i<SBLIMIT;i++)
//        for (k=0;k<nchan;k++)
//            if (bit_alloc[k][i]) {
//                nb = bit_alloc[k][i] + 1;
//                if (((sample[k][0][i] >> nb-1) & 1) == 1) fraction[k][0][i] = 0;
//                else fraction[k][0][i] = -1;
//                fraction[k][0][i] += (float) (sample[k][0][i] & ((1<<nb-1)-1)) /
//                    (float) (1L<<nb-1);
//
//                fraction[k][0][i] =
//                    (float) (fraction[k][0][i]+1.0/(float)(1L<<nb-1)) *
//                        (float) (1L<<nb) / (float) ((1L<<nb)-1);
//            }
//            else fraction[k][0][i] = 0;
//}

/*************************************************************/
/*                                                           */
/*   Restore the original value of the sample ie multiply    */
/*    the fraction value by its scalefactor.                 */
/*                                                           */
/*************************************************************/

/**************************** Layer I stuff ******************************/

//void I_denormalize_sample (float fraction[2][3][SBLIMIT],
//			   unsigned char scale_index[2][3][SBLIMIT],
//			   FrameInfo *fi)
//{
//    int i,j;
//    int nchan = fi->nchan;
//    static double multiple[64] = {
//	2.00000000000000, 1.58740105196820, 1.25992104989487,
//	1.00000000000000, 0.79370052598410, 0.62996052494744, 0.50000000000000,
//	0.39685026299205, 0.31498026247372, 0.25000000000000, 0.19842513149602,
//	0.15749013123686, 0.12500000000000, 0.09921256574801, 0.07874506561843,
//	0.06250000000000, 0.04960628287401, 0.03937253280921, 0.03125000000000,
//	0.02480314143700, 0.01968626640461, 0.01562500000000, 0.01240157071850,
//	0.00984313320230, 0.00781250000000, 0.00620078535925, 0.00492156660115,
//	0.00390625000000, 0.00310039267963, 0.00246078330058, 0.00195312500000,
//	0.00155019633981, 0.00123039165029, 0.00097656250000, 0.00077509816991,
//	0.00061519582514, 0.00048828125000, 0.00038754908495, 0.00030759791257,
//	0.00024414062500, 0.00019377454248, 0.00015379895629, 0.00012207031250,
//	0.00009688727124, 0.00007689947814, 0.00006103515625, 0.00004844363562,
//	0.00003844973907, 0.00003051757813, 0.00002422181781, 0.00001922486954,
//	0.00001525878906, 0.00001211090890, 0.00000961243477, 0.00000762939453,
//	0.00000605545445, 0.00000480621738, 0.00000381469727, 0.00000302772723,
//	0.00000240310869, 0.00000190734863, 0.00000151386361, 0.00000120155435,
//	1E-20
//    };
//
//    for (i=0;i<SBLIMIT;i++) for (j=0;j<nchan;j++)
//        fraction[j][0][i] *= multiple[scale_index[j][0][i]];
//}

/********************************************************/
/* Composite fraction-input routines (layer II only)     */
/* Merge the functions of buffer/dequantize/denormalize */
/* into one operation, to maximise performance.         */
/********************************************************/

typedef struct { int cm1, d; } dqfr;
#define ONE (1 << MBITS)
#define DC(exp,fru,frl) { (int32) ((double)ONE * ((fru)-(frl)) / (frl)), \
			  (exp) >= FBITS ? 0 : 1 << (FBITS+1-(exp))  }
#define DCR(n) DC(n, 1 << (n), (1 << (n)) - 1)
const static dqfr dqtab[3+14] =
{
/* First 3 entries are for the special grouped sample sets */
    DC (2,4,3),
    DC (2,8,5),
    DC (2,16,9),
/* Remaining constants are used for non-grouped sample values */
    DCR (3),
    DCR (4),
    DCR (5),
    DCR (6),
    DCR (7),
    DCR (8),
    DCR (9),
    DCR (10),
    DCR (11),
    DCR (12),
    DCR (13),
    DCR (14),
    DCR (15),
    DCR (16),
};
#define CR2_1 1.25992104989487
#define CR2_2 1.58740105196820
#define CR2_1_M1 ((int32)((CR2_1 - 1.0) * ONE))
#define CR2_2_M1 ((int32)((CR2_2 - 1.0) * ONE))

#if defined(DIAGS)
int qxcount[17]; /* counts values at each quantisation level */
#endif

#pragma -z0
void II_obtain_sample_mono (int *bit_alloc,
			    unsigned char scale_index[SBLIMIT],
			    int32 fraction[3][SBLIMIT])
{
    BITALL ba;
    while ((ba.i = *bit_alloc++) != -1)
    {
	/* Yes, go read them in */
	int32 *frp = &fraction[0][ba.a.bandpos];
	int m = scale_index[ba.a.bandpos];
	const int b = ba.a.bits + 1;
	int32 samp0, samp1, samp2;
	int rsh;
	/* check for grouping in subband */
	if (!ba.a.group)
	{
	    /* No grouping */
	    const dqfr *dqp;
	    int32 cm1, d;
#if defined(DIAGS)
	    ++qxcount[3+ba.a.quant];
#endif
	    dqp = &dqtab[3+ba.a.quant];
	    /* No grouping */
	    samp0 = getbits (b*2);
	    samp2 = getbits (b) << (FBITS + 1 - b);
	    samp1 = (samp0 & (~(~0 << b))) << (FBITS + 1 - b);
	    samp0 = samp0 >> b << (FBITS + 1 - b);
	    cm1 = dqp->cm1;		/* all 'C' values are 1.n: get 0.n from entry */
	    d = dqp->d - (1 << FBITS); /* do 2's complement at same time */
	    samp0 += d;  samp0 += cm1 * samp0 >> MBITS;
	    samp1 += d;  samp1 += cm1 * samp1 >> MBITS;
	    samp2 += d;  samp2 += cm1 * samp2 >> MBITS;
	}
	else
	{
	    /*
	     * 3-element arithmetic grouping for bit_alloc = 3, 5, 9
	     * (bits = 5,7,10).  We use hand-crafted code for these
	     * cases: looks lengthy but compiler gets it right, and
	     * it's a lot quicker than using div, mod etc.
	     */
	    if (b == 5)
	    {
		/*
		 * Simplest case, 3 x 3-valued samples (0..2) each
		 * representing -2/3, 0 or +2/3.
		 */
		unsigned int c = getbits (5);
		int32 v = (int32)((1 << FBITS) * (2.0/3) + 0.5);
		samp2 = -v;
		if (c >= 2*3*3) { samp2 = v; c -= 2*3*3; }
		if (c >= 1*3*3) { samp2 = 0; c -= 1*3*3; }
		samp1 = -v;
		if (c >= 2*3) { samp1 = v; c -= 2*3; }
		if (c >= 1*3) { samp1 = 0; c -= 1*3; }
		samp0 = c * v;
		samp0 -= v;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else if (b == 7)
	    {
		/*
		 * Values 0..4, 0..4, 0..4 treated as merged base 5.
		 * Values 0..4 represent: { -4/5, -2/5, 0, 2/5, 4/5 }
		 */
		unsigned int c = getbits (7);
		int32 v = (int32)((1 << FBITS) * 2.0/5 + 0.5);
		samp2 = - (v * 2);
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 1*5*5) { samp2 += v;     c -= 1*5*5; }
		samp1 = - (v * 2);
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 1*5) { samp1 += v;     c -= 1*5; }
		samp0 = c * v;
		samp0 -= v * 2;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else
	    {
		/*
		 * Values 0..8, 0..8, 0..8 treated as merged base 9.
		 * Values 0..8 represent:
		 *   {-8/9 -6/9 -4/9 -2/9 0 +2/9  +4/9 +6/9 +8/9}
		 */
		unsigned int c = getbits (10);
		int32 v = (int32)((1 << FBITS) * 2.0/9 + 0.5);
		samp2 = -(v * 4);
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 2*9*9) { samp2 += v * 2; c -= 2*9*9; }
		if (c >= 1*9*9) { samp2 += v * 1; c -= 1*9*9; }
		samp1 = -(v * 4);
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 2*9) { samp1 += v * 2; c -= 2*9; }
		if (c >= 1*9) { samp1 += v * 1; c -= 1*9; }
		samp0 = c * v;
		samp0 -= v * 4;
#if defined(DIAGS)
		++qxcount[2];
#endif
	    }
	}
	rsh = ((m >> 2) + (FBITS > 15 ? FBITS - 15 : 0));
	if ((m & 3) == 0)
	{
	    samp0 <<= 1;
	    samp1 <<= 1;
	    samp2 <<= 1;
	}
	else
	{
	    int c;
	    if ((m & 3) == 1)
		c = CR2_2_M1;
	    else
		c = CR2_1_M1;
	    samp0 += (samp0 * c) >> MBITS;
	    samp1 += (samp1 * c) >> MBITS;
	    samp2 += (samp2 * c) >> MBITS;
	}
	frp[SBLIMIT*0] = samp0 >> rsh;
	frp[SBLIMIT*1] = samp1 >> rsh;
	frp[SBLIMIT*2] = samp2 >> rsh;
//#if defined(DECODEDIAGS)
//	if (diags)
//	    if (frp[SBLIMIT*0] >=32768 || frp[SBLIMIT*0] < -32768 ||
//		frp[SBLIMIT*1] >=32768 || frp[SBLIMIT*1] < -32768 ||
//		frp[SBLIMIT*2] >=32768 || frp[SBLIMIT*2] < -32768)
//	    {
//		fprintf (stderr, "obtain_mono overflow (band %d) (%d %d %d) ba %08x\n",
//			 pos_to_band[ba.a.bandpos], frp[SBLIMIT*0], frp[SBLIMIT*1], frp[SBLIMIT*2], ba.i);
//	    }
//#endif
    }
}
#pragma -z1

#pragma -z1
/* Full stereo only here */
void II_obtain_sample_stereo (int *bit_alloc,
			      unsigned char scale_index[SBLIMIT][2],
			      fsamp_S fraction[3][SBLIMIT])
{
    BITALL ba;
    while ((ba.i = *bit_alloc++) != -1)
    {
	/* Yes, go read them in */
	fsamp_M *frp = &fraction[0][ba.a.bandpos].d[ba.a.chan];
	int m = scale_index[ba.a.bandpos][ba.a.chan];
	const int b = ba.a.bits + 1;
	uint32 cx;
	int32 samp0, samp1, samp2;
	int rsh;

	if (!ba.a.group)
	{
	    /* Not grouped */
	    const dqfr *dqp = &dqtab[3+ba.a.quant];
	    int32 cm1, d;
#if defined(DIAGS)
	    ++qxcount[3+ba.a.quant];
#endif
#if 0
	    if (b <= 10)
	    {
		int mask;
		samp0 = getbits (b*3);
		mask = ~(~0 << b);
		samp2 = (samp0 & mask) << (FBITS + 1 - b);  samp0 >>= b;
		samp1 = (samp0 & mask) << (FBITS + 1 - b);  samp0 >>= b;
		samp0 =  samp0         << (FBITS + 1 - b);
	    }
	    else
#endif
	    {
		samp0 = getbits (b*2);
		samp2 = getbits (b) << (FBITS + 1 - b);
		samp1 = (samp0 & (~(~0 << b))) << (FBITS + 1 - b);
		samp0 = (uint32)samp0 >> b << (FBITS + 1 - b);
	    }
	    cm1 = dqp->cm1;
	    d = dqp->d - (1 << FBITS); /* do 2's complement at same time */
	    samp0 += d;  samp0 += cm1 * samp0 >> MBITS;
	    samp1 += d;  samp1 += cm1 * samp1 >> MBITS;
	    samp2 += d;  samp2 += cm1 * samp2 >> MBITS;
	    if ((m & 3) == 0)
	    {
		samp0 <<= 1;
		samp1 <<= 1;
		samp2 <<= 1;
	    }
	    else
	    {
		int c;
		if ((m & 3) == 1)
		    c = CR2_2_M1;
		else
		    c = CR2_1_M1;
		samp0 += (c * samp0) >> MBITS;
		samp1 += (c * samp1) >> MBITS;
		samp2 += (c * samp2) >> MBITS;
	    }
	    cx = 123456789;
	}
	else
	{
	    /*
	     * 3-element arithmetic grouping for bit_alloc = 3, 5, 9
	     * (bits = 5,7,10).  We use hand-crafted code for these
	     * cases: looks lengthy but compiler gets it right, and
	     * it's a lot quicker than using div, mod etc.
	     */
	    if (b == 5)
	    {
		/*
		 * Simplest case, 3 x 3-valued samples (0..2) each
		 * representing -2/3, 0 or +2/3.
		 */
		unsigned int c = getbits (5);
		int32 v;
		cx = c;
		if ((m & 3) == 0)
		    v = (int32)((1 << FBITS) * 2.0 * (2.0/3) + 0.5);
		else if ((m & 3) == 1)
		    v = (int32)((1 << FBITS) * CR2_2 * (2.0/3) + 0.5);
		else
		    v = (int32)((1 << FBITS) * CR2_1 * (2.0/3) + 0.5);
		samp2 = -v;
		if (c >= 2*3*3) { samp2 = v; c -= 2*3*3; }
		if (c >= 1*3*3) { samp2 = 0; c -= 1*3*3; }
		samp1 = -v;
		if (c >= 2*3) { samp1 = v; c -= 2*3; }
		if (c >= 1*3) { samp1 = 0; c -= 1*3; }
		samp0 = c * v;
		samp0 -= v;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else if (b == 7)
	    {
		/*
		 * Values 0..4, 0..4, 0..4 treated as merged base 5.
		 * Values 0..4 represent: { -4/5, -2/5, 0, 2/5, 4/5 }
		 */
		int32 v;
		uint32 c = getbits (7);
		cx = c;
		if ((m & 3) == 0)
		    v = (int32)((1 << FBITS) * 2.0 * (2.0/5) + 0.5);
		else if ((m & 3) == 1)
		    v = (int32)((1 << FBITS) * CR2_2 * (2.0/5) + 0.5);
		else
		    v = (int32)((1 << FBITS) * CR2_1 * (2.0/5) + 0.5);
		samp2 = - (v * 2);
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 1*5*5) { samp2 += v;     c -= 1*5*5; }
		samp1 = - (v * 2);
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 1*5) { samp1 += v;     c -= 1*5; }
		samp0 = c * v;
		samp0 -= v * 2;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else
	    {
		/*
		 * Values 0..8, 0..8, 0..8 treated as merged base 9.
		 * Values 0..8 represent:
		 *   {-8/9 -6/9 -4/9 -2/9 0 +2/9 +4/9 +6/9 +8/9}
		 */
		int32 v;
		uint32 c = getbits (10);
		cx = c;
		if ((m & 3) == 0)
		    v = (int32)((1 << FBITS) * 2.0   * (2.0/9) + 0.5);
		else if ((m & 3) == 1)
		    v = (int32)((1 << FBITS) * CR2_2 * (2.0/9) + 0.5);
		else
		    v = (int32)((1 << FBITS) * CR2_1 * (2.0/9) + 0.5);
		samp2 = -(v * 4);
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 2*9*9) { samp2 += v * 2; c -= 2*9*9; }
		if (c >= 1*9*9) { samp2 += v * 1; c -= 1*9*9; }
		samp1 = -(v * 4);
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 2*9) { samp1 += v * 2; c -= 2*9; }
		if (c >= 1*9) { samp1 += v * 1; c -= 1*9; }
		samp0 = c * v;
		samp0 -= v * 4;
#if defined(DIAGS)
		++qxcount[2];
#endif
	    }
	}
	rsh = ((m >> 2) + (FBITS > 15 ? FBITS - 15 : 0));
	frp[2*SBLIMIT*0] = samp0 >> rsh;
	frp[2*SBLIMIT*1] = samp1 >> rsh;
	frp[2*SBLIMIT*2] = samp2 >> rsh;
//#if defined(DECODEDIAGS)
//	if (diags)
//	    if (frp[2*SBLIMIT*0] >=32768 || frp[2*SBLIMIT*0] < -32768 ||
//		frp[2*SBLIMIT*1] >=32768 || frp[2*SBLIMIT*1] < -32768 ||
//		frp[2*SBLIMIT*2] >=32768 || frp[2*SBLIMIT*2] < -32768)
//	    {
//		fprintf (stderr, "obtain_s overflow (chan %d, band %d) (%d %d %d) c %d m %x ba %08x\n",
//			 ba.a.chan, pos_to_band[ba.a.bandpos],
//			 frp[2*SBLIMIT*0], frp[2*SBLIMIT*1], frp[2*SBLIMIT*2], cx, m, ba.i);
//	    }
//#endif
    }
}
#pragma -z1

#pragma -z1
/* Joint stereo case */
void II_obtain_sample_joint_stereo (int *bit_alloc,
				    unsigned char scale_index[SBLIMIT][2],
				    fsamp_S fraction[3][SBLIMIT])
{
    register BITALL ba;
    while ((ba.i = *bit_alloc++) != -1)
    {
	/* Yes, go read them in */
	fsamp_M *frp = &fraction[0][ba.a.bandpos].d[ba.a.chan];
	const unsigned char *sip = &scale_index[ba.a.bandpos][ba.a.chan];
	const int b = ba.a.bits + 1;
	int32 samp0, samp1, samp2;
	int m;
	m = *sip;
	if (ba.a.js)
	{
	    /* Joint stereo band: ba.a.chan is 0 so go get chan[1] value also */
	    /* put it in bits 15:8 of m, and put limit marker in bits 17:16 */
	    m |= sip[1] << 8 | 0x30000;
	}
	else
	    /* put limit marker in bits 9:8 */
	    m |= 0x300;

	if (!ba.a.group)
	{
	    /* Not grouped */
	    const dqfr *dqp = &dqtab[3+ba.a.quant];
	    int32 cm1, d;
#if defined(DIAGS)
	    ++qxcount[3+ba.a.quant];
#endif
	    /* No grouping */
#if 0
	    if (b <= 10)
	    {
		int mask;
		samp0 = getbits (b*3);
		mask = ~(~0 << b);
		samp2 = (samp0 & mask) << (FBITS + 1 - b);  samp0 >>= b;
		samp1 = (samp0 & mask) << (FBITS + 1 - b);  samp0 >>= b;
		samp0 =  samp0         << (FBITS + 1 - b);
	    }
	    else
#endif
	    {
		samp0 = getbits (b*2);
		samp2 = getbits (b) << (FBITS + 1 - b);
		samp1 = (samp0 & (~(~0 << b))) << (FBITS + 1 - b);
		samp0 = samp0 >> b << (FBITS + 1 - b);
	    }
	    cm1 = dqp->cm1;
	    d = dqp->d - (1 << FBITS); /* do 2's complement at same time */
	    samp0 += d;  samp0 += cm1 * samp0 >> MBITS;
	    samp1 += d;  samp1 += cm1 * samp1 >> MBITS;
	    samp2 += d;  samp2 += cm1 * samp2 >> MBITS;
	}
	else
	{
	    /*
	     * 3-element arithmetic grouping for bit_alloc = 3, 5, 9
	     * (bits = 5,7,10).  We use hand-crafted code for these
	     * cases: looks lengthy but compiler gets it right, and
	     * it's a lot quicker than using div, mod etc.
	     */
	    if (b == 5)
	    {
		/*
		 * Simplest case, 3 x 3-valued samples (0..2) each
		 * representing -2/3, 0 or +2/3.
		 */
		unsigned int c = getbits (5);
		int32 v = (int32)((1 << FBITS) * (2.0/3) + 0.5);
		samp2 = -v;
		if (c >= 2*3*3) { samp2 = v; c -= 2*3*3; }
		if (c >= 1*3*3) { samp2 = 0; c -= 1*3*3; }
		samp1 = -v;
		if (c >= 2*3) { samp1 = v; c -= 2*3; }
		if (c >= 1*3) { samp1 = 0; c -= 1*3; }
		samp0 = c * v;
		samp0 -= v;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else if (b == 7)
	    {
		/*
		 * Values 0..4, 0..4, 0..4 treated as merged base 5.
		 * Values 0..4 represent: { -4/5, -2/5, 0, 2/5, 4/5 }
		 */
		unsigned int c = getbits (7);
		int32 v = (int32)((1 << FBITS) * (2.0/5) + 0.5);
		samp2 = - (v * 2);
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 2*5*5) { samp2 += v * 2; c -= 2*5*5; }
		if (c >= 1*5*5) { samp2 += v;     c -= 1*5*5; }
		samp1 = - (v * 2);
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 2*5) { samp1 += v * 2; c -= 2*5; }
		if (c >= 1*5) { samp1 += v;     c -= 1*5; }
		samp0 = c * v;
		samp0 -= v * 2;
#if defined(DIAGS)
		++qxcount[1];
#endif
	    }
	    else
	    {
		/*
		 * Values 0..8, 0..8, 0..8 treated as merged base 9.
		 * Values 0..8 represent:
		 *   {-8/9 -6/9 -4/9 -2/9 0 +2/9  +4/9 +6/9 +8/9}
		 */
		unsigned int c = getbits (10);
		int32 v = (int32)((1 << FBITS) * (2.0/9) + 0.5);
		samp2 = -(v * 4);
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 4*9*9) { samp2 += v * 4; c -= 4*9*9; }
		if (c >= 2*9*9) { samp2 += v * 2; c -= 2*9*9; }
		if (c >= 1*9*9) { samp2 += v * 1; c -= 1*9*9; }
		samp1 = -(v * 4);
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 4*9) { samp1 += v * 4; c -= 4*9; }
		if (c >= 2*9) { samp1 += v * 2; c -= 2*9; }
		if (c >= 1*9) { samp1 += v * 1; c -= 1*9; }
		samp0 = c * v;
		samp0 -= v * 4;
#if defined(DIAGS)
		++qxcount[2];
#endif
	    }
	}
	for (;;)
	{
	    int s0 = samp0, s1 = samp1, s2 = samp2;
	    int rsh = (((m >> 2) & 0x1F) + (FBITS > 15 ? FBITS - 15 : 0));
	    if ((m & 3) == 0)
	    {
		s0 <<= 1;
		s1 <<= 1;
		s2 <<= 1;
	    }
	    else
	    {
		int c;
		if ((m & 3) == 1)
		    c = CR2_2_M1;
		else
		    c = CR2_1_M1;
		s0 += (c * samp0) >> MBITS;
		s1 += (c * samp1) >> MBITS;
		s2 += (c * samp2) >> MBITS;
	    }
	    frp[SBLIMIT*0*2] = s0 >> rsh;
	    frp[SBLIMIT*1*2] = s1 >> rsh;
	    frp[SBLIMIT*2*2] = s2 >> rsh;
//#if defined(DECODEDIAGS)
//	    if (diags)
//		if (frp[2*SBLIMIT*0] >=32768 || frp[2*SBLIMIT*0] < -32768 ||
//		    frp[2*SBLIMIT*1] >=32768 || frp[2*SBLIMIT*1] < -32768 ||
//		    frp[2*SBLIMIT*2] >=32768 || frp[2*SBLIMIT*2] < -32768)
//		{
//		    fprintf (stderr, "obtain_js overflow (chan %d, band %d) (%d %d %d) ba %08x\n",
//			     ba.a.chan, pos_to_band[ba.a.bandpos],
//			     frp[2*SBLIMIT*0], frp[2*SBLIMIT*1], frp[2*SBLIMIT*2], ba.i);
//		}
//#endif
	    m >>= 8;
	    if (m == 3)
		break;
	    ++frp;		/* step to next channel, for if joint stereo */
	}
    }
}
#pragma -z1


void  recover_CRC_error (int error_count, FrameInfo *fi, short *output/*, FILE *outFile*/)
{
    int  nchan = fi->nchan;
    int  num;
    int  samplesPerFrame, samplesPerSlot;
//    long  offset;
//    short tbuff[SBLIMIT*3*2];

    num = 3;
    if (FR_LAYER(fi->header)== 1) num = 1;

    samplesPerSlot = SBLIMIT * num * nchan;
    samplesPerFrame = samplesPerSlot * 32;

//    if (error_count == 1)
//    {   /* replicate previous error_free frame */
//	fprintf (stderr, "Coping with CRC error by replicating previous frame\n");
//        /* go back to the beginning of the previous frame */
//        offset = sizeof(short int) * samplesPerFrame;
//        fseek(outFile, -offset, SEEK_CUR);
//	fread(tbuff, sizeof(short), samplesPerFrame, outFile);
//    }
//    else
//    {                       /* mute the frame */
//	int i;
//	fprintf (stderr, "Coping with CRC error by muting frame\n");
//	for (i = 0; i < samplesPerFrame; ++i)
//	    tbuff[i] = 0;
//    }
//    fwrite(tbuff, sizeof(short), samplesPerFrame, outFile);

    // the New Way (TM) is to produce a mute frame and be happy (I hope)
    memset(output, 0, sizeof(short)*samplesPerFrame);
}

/* EOF decode.c */


