/**********************************************************************
Copyright (c) 1991 MPEG/audio software simulation group, All Rights Reserved
tonal.c
**********************************************************************/

///////////////////////////////////////////
// Standard C routines used:
//     pow, log10
//     cos, sin
//     memcpy

/**********************************************************************
 * MPEG/audio coding/decoding software, work in progress              *
 *   NOT for public distribution until verified and approved by the   *
 *   MPEG/audio committee.  For further information, please contact   *
 *   Davis Pan, 508-493-2241, e-mail: pan@3d.enet.dec.com             *
 *                                                                    *
 * VERSION 3.9t                                                       *
 *   changes made since last update:                                  *
 *   date   programmers         comment                               *
 * 2/25/91  Douglas Wong        start of version 1.1 records          *
 * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
 *                              updated I_psycho_one and II_psycho_one*
 * 3/11/91  W. J. Carter        Added Douglas Wong's updates dated    *
 *                              3/9/91 for I_Psycho_One() and for     *
 *                              II_Psycho_One().                      *
 * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
 *                              Located and fixed numerous software   *
 *                              bugs and table data errors.           *
 * 6/11/91  Davis Pan           corrected several bugs                *
 *                              based on comments from H. Fuchs       *
 * 01jul91  dpwe (Aware Inc.)   Made pow() args float                 *
 *                              Removed logical bug in I_tonal_label: *
 *                              Sometimes *tone returned == STOP      *
 * 7/10/91  Earle Jennings      no change necessary in port to MsDos  *
 * 11sep91  dpwe@aware.com      Subtracted 90.3dB from II_f_f_t peaks *
 * 10/1/91  Peter W. Farrett    Updated II_Psycho_One(),I_Psycho_One()*
 *                              to include comments.                  *
 *11/29/91  Masahiro Iwadare    Bug fix regarding POWERNORM           *
 *                              fixed several other miscellaneous bugs*
 * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
 *                              important fixes involved changing     *
 *                              16-bit ints to long or unsigned in    *
 *                              bit alloc routines for quant of 65535 *
 *                              and passing proper function args.     *
 *                              Removed "Other Joint Stereo" option   *
 *                              and made bitrate be total channel     *
 *                              bitrate, irrespective of the mode.    *
 *                              Fixed many small bugs & reorganized.  *
 * 2/12/92  Masahiro Iwadare    Fixed some potential bugs in          *
 *          Davis Pan           subsampling()                         *
 * 2/25/92  Masahiro Iwadare    Fixed some more potential bugs        *
 * 6/24/92  Tan Ah Peng         Modified window for FFT               *
 *                              (denominator N-1 to N)                *
 *                              Updated all critical band rate &      *
 *                              absolute threshold tables and critical*
 *                              boundaries for use with Layer I & II  *
 *                              Corrected boundary limits for tonal   *
 *                              component computation                 *
 *                              Placement of non-tonal component at   *
 *                              geometric mean of critical band       *
 *                              (previous placement method commented  *
 *                               out - can be used if desired)        *
 * 3/01/93  Mike Li             Infinite looping fix in noise_label() *
 * 3/19/93  Jens Spille         fixed integer overflow problem in     *
 *                              psychoacoutic model 1                 *
 * 3/19/93  Giorgio Dimino      modifications to better account for   *
 *                              tonal and non-tonal components        *
 * 5/28/93 Sriram Jayasimha     "London" mod. to psychoacoustic model1*
 * 8/05/93 Masahiro Iwadare     noise_label modification "option"     *
 **********************************************************************/

#include "common.h"
#include "encoder.h"
#include "tables.h"
#include "constants.h"

// constants
static FLOAT                 global_const_tmpA = {10};
#define fpFlt_10_            global_const_tmpA._i
static FLOAT                 global_const_tmpB = {7};
#define fpFlt_7_             global_const_tmpB._i
static FLOAT                 global_const_tmpC = {DBMIN};
#define fpFlt_DBMIN_         global_const_tmpC._i
static FLOAT                 global_const_tmpD = {12};
#define fpFlt_12_            global_const_tmpD._i
static FLOAT                 global_const_tmpE = {SCALE};
#define fpFlt_SCALE_         global_const_tmpE._i


#define LONDON                  /* enable "LONDON" modification */
#define MAKE_SENSE              /* enable "MAKE_SENSE" modification */
#define MI_OPTION               /* enable "MI_OPTION" modification */
/**********************************************************************/
/*
/*        This module implements the psychoacoustic model I for the
/* MPEG encoder layer II. It uses simplified tonal and noise masking
/* threshold analysis to generate SMR for the encoder bit allocation
/* routine.
/*
/**********************************************************************/

int crit_band;
int *cbound;
int sub_size;

void read_cbound(int lay, int freq)	/* this function reads in critical */
					/* band boundaries                 */
{
// int i,j,k;
// FILE *fp;
// char r[16], t[80];
//
// strcpy(r, "2cb1");
// r[0] = (char) lay + '0';
// r[3] = (char) freq + '0';
// if( !(fp = OpenTableFile(r)) ){       /* check boundary values */
//    printf("Please check %s boundary table\n",r);
//    exit(1);
// }
// fgets(t,80,fp);               /* read input for critical bands */
// sscanf(t,"%d\n",&crit_band);
// cbound = (int *) mem_alloc(sizeof(int) * crit_band, "cbound");
// for(i=0;i<crit_band;i++){   /* continue to read input for */
//    fgets(t,80,fp);            /* critical band boundaries   */
//    sscanf(t,"%d %d\n",&j, &k);
//    if(i==j) cbound[j] = k;
//    else {                     /* error */
//       printf("Please check index %d in cbound table %s\n",i,r);
//       exit(1);
//    }
// }
// fclose(fp);

    switch (lay) {
        case 1:
            switch (freq) {
                case 0:
                    cbound    = tables_1cb0;
                    crit_band = tables_crit_band_1_0;
                    break;
                case 1:
                    cbound    = tables_1cb1;
                    crit_band = tables_crit_band_1_1;
                    break;
                case 2:
                    cbound    = tables_1cb2;
                    crit_band = tables_crit_band_1_2;
                    break;
//ERR                default:
//                    printf("Arse\n");
//                    exit(1);
//                    break;
            }
            break;
        case 2:
            switch (freq) {
                case 0:
                    cbound    = tables_2cb0;
                    crit_band = tables_crit_band_2_0;
                    break;
                case 1:
                    cbound    = tables_2cb1;
                    crit_band = tables_crit_band_2_1;
                    break;
                case 2:
                    cbound    = tables_2cb2;
                    crit_band = tables_crit_band_2_2;
                    break;
//ERR                default:
//                    printf("Arse\n");
//                    exit(1);
//                    break;
            }
            break;
//ERR        default:
//            printf("Arse\n");
//            exit(1);
//            break;
        default: //ERR
            cbound    = tables_2cb0;
            crit_band = tables_crit_band_2_0;
            break;
    }
}

/* this function reads in frequency bands and bark values */
void read_freq_band(g_ptr *ltg, int lay, int freq)
{
// int i,j, k;
// double b,c;
// FILE *fp;
// char r[16], t[80];
//
// strcpy(r, "2th1");
// r[0] = (char) lay + '0';
// r[3] = (char) freq + '0';
// if( !(fp = OpenTableFile(r)) ){   /* check freq. values  */
//    printf("Please check frequency and cband table %s\n",r);
//    exit(1);
// }
// fgets(t,80,fp);              /* read input for freq. subbands */
// sscanf(t,"%d\n",&sub_size);
// *ltg = (g_ptr ) mem_alloc(sizeof(g_thres) * sub_size, "ltg");
// (*ltg)[0].line = 0;          /* initialize global masking threshold */
// (*ltg)[0].bark = 0;
// (*ltg)[0].hear = 0;
// for(i=1;i<sub_size;i++){    /* continue to read freq. subband */
//    fgets(t,80,fp);          /* and assign                     */
//    sscanf(t,"%d %d %lf %lf\n",&j, &k, &b, &c);
//    if(i == j){
//       (*ltg)[j].line = k;
//       (*ltg)[j].bark = b;
//       (*ltg)[j].hear = c;
//    }
//    else {                   /* error */
//       printf("Please check index %d in freq-cb table %s\n",i,r);
//       exit(1);
//    }
// }
// fclose(fp);

    switch (lay) {
        case 1:
            switch (freq) {
                case 0:
                    *ltg     = tables_1th0;
                    sub_size = tables_sub_size_1_0;
                    break;
                case 1:
                    *ltg     = tables_1th1;
                    sub_size = tables_sub_size_1_1;
                    break;
                case 2:
                    *ltg     = tables_1th2;
                    sub_size = tables_sub_size_1_2;
                    break;
//ERR                default:
//                    printf("Arse\n");
//                    exit(1);
//                    break;
            }
            break;
        case 2:
            switch (freq) {
                case 0:
                    *ltg     = tables_2th0;
                    sub_size = tables_sub_size_2_0;
                    break;
                case 1:
                    *ltg     = tables_2th1;
                    sub_size = tables_sub_size_2_1;
                    break;
                case 2:
                    *ltg     = tables_2th2;
                    sub_size = tables_sub_size_2_2;
                    break;
//ERR                default:
//                    printf("Arse\n");
//                    exit(1);
//                    break;
            }
            break;
//ERR        default:
//            printf("Arse\n");
//            exit(1);
//            break;
        default: //ERR
            *ltg     = tables_2th0;
            sub_size = tables_sub_size_2_0;
            break;
    }
}

/* this function calculates the global masking threshold     */
void make_map(mask power[HAN_SIZE], g_thres *ltg)
{
 int i,j;

 for(i=1;i<sub_size;i++) for(j=ltg[i-1].line;j<=ltg[i].line;j++)
    power[j].map = i;
}

FLOAT add_db(FLOAT a, FLOAT b)
{
 static FLOAT tmpA = {10};
 FLOAT val;
 a._i = fpDiv(a._i, tmpA._i);
 a._f = pow(10.0,a._f);
 b._i = fpDiv(b._i, tmpA._i);
 b._f = pow(10.0,b._f);
 val._f = log10(a._f+b._f);
 val._i = fpMul(tmpA._i, val._i);
 return val;
}

/****************************************************************
 *
 *        Fast Fourier transform of the input samples.
 *
 ****************************************************************/

/* this function calculates an FFT analysis for the freq. domain */
void II_f_f_t(FLOAT sample[FFT_SIZE], mask power[HAN_SIZE])
{
 // assignments to remove zero init PJG 18 Dec 1997
 int i,j,k,L,l=0;
 int ip, le, le1;
 FLOAT t_r, t_i, u_r, u_i;
 static int M, MM1, init = 0, N;
 DFFT x_r_actual = {{1}}, x_i_actual = {{1}}, energy_actual = {{1}}; // PJG 16 Dec 1997
 FLOAT *x_r = (FLOAT*) &x_r_actual, *x_i = (FLOAT*) &x_i_actual, *energy = (FLOAT*) &energy_actual;
 static IFFT rev_actual = {{1}}; // PJG 16 Dec 1997
 static D10 w_r_actual = {{1}}, w_i_actual = {{1}}; // PJG 16 Dec 1997
 static int *rev = rev_actual;
 static FLOAT *w_r = w_r_actual, *w_i = w_i_actual;

// x_r = (FLOAT *) mem_alloc(sizeof(DFFT), "x_r");
// x_i = (FLOAT *) mem_alloc(sizeof(DFFT), "x_i");
// energy = (FLOAT *) mem_alloc(sizeof(DFFT), "energy");
 for(i=0;i<FFT_SIZE;i++) x_r[i]._i = x_i[i]._i = energy[i]._i = const_0._i;
 if(!init){
//    rev = (int *) mem_alloc(sizeof(IFFT), "rev");
//    w_r = (FLOAT *) mem_alloc(sizeof(D10), "w_r");
//    w_i = (FLOAT *) mem_alloc(sizeof(D10), "w_i");
    M = 10;
    MM1 = 9;
    N = FFT_SIZE;
    for(L=0;L<M;L++){
       le = 1 << (M-L);
       le1 = le >> 1;
       w_r[L]._f = cos(PI/le1);
       w_i[L]._f = -sin(PI/le1);
    }
    for(i=0;i<FFT_SIZE;rev[i] = l,i++) for(j=0,l=0;j<10;j++){
       k=(i>>j) & 1;
       l |= (k<<9-j);
    }
    init = 1;
 }
 memcpy( (char *) x_r, (char *) sample, sizeof(FLOAT) * FFT_SIZE);
 for(L=0;L<MM1;L++){
    le = 1 << (M-L);
    le1 = le >> 1;
    u_r._i = const_1._i;
    u_i._i = const_0._i;
    for(j=0;j<le1;j++){
       for(i=j;i<N;i+=le){
          ip = i + le1;
          t_r._i = fpAdd(x_r[i]._i, x_r[ip]._i);
          t_i._i = fpAdd(x_i[i]._i, x_i[ip]._i);
          x_r[ip]._i = fpSub(x_r[i]._i, x_r[ip]._i);
          x_i[ip]._i = fpSub(x_i[i]._i, x_i[ip]._i);
          x_r[i]._i = t_r._i;
          x_i[i]._i = t_i._i;
          t_r._i = x_r[ip]._i;
          x_r[ip]._i = fpSub(fpMul(x_r[ip]._i, u_r._i), fpMul(x_i[ip]._i, u_i._i));
          x_i[ip]._i = fpAdd(fpMul(x_i[ip]._i, u_r._i), fpMul(t_r._i, u_i._i));
       }
       t_r._i = u_r._i;
       u_r._i = fpSub(fpMul(u_r._i, w_r[L]._i), fpMul(u_i._i, w_i[L]._i));
       u_i._i = fpAdd(fpMul(u_i._i, w_r[L]._i), fpMul(t_r._i, w_i[L]._i));
    }
 }
 for(i=0;i<N;i+=2){
    ip = i + 1;
    t_r._i = fpAdd(x_r[i]._i, x_r[ip]._i);
    t_i._i = fpAdd(x_i[i]._i, x_i[ip]._i);
    x_r[ip]._i = fpSub(x_r[i]._i, x_r[ip]._i);
    x_i[ip]._i = fpSub(x_i[i]._i, x_i[ip]._i);
    x_r[i]._i = t_r._i;
    x_i[i]._i = t_i._i;
    energy[i]._i = fpAdd(fpMul(x_r[i]._i, x_r[i]._i), fpMul(x_i[i]._i, x_i[i]._i));
 }
 for(i=0;i<FFT_SIZE;i++) if(i<rev[i]){
    t_r._i = energy[i]._i;
    energy[i]._i = energy[rev[i]]._i;
    energy[rev[i]]._i = t_r._i;
 }
 for(i=0;i<HAN_SIZE;i++){    /* calculate power density spectrum */
    static FLOAT tmpA = {1E-20};
    static FLOAT tmpB = {POWERNORM};
    if (fpLT(energy[i]._i, tmpA._i)) energy[i]._i = tmpA._i;
    //power[i].x._f = 10 * log10(energy[i]._f) + POWERNORM;
    power[i].x._f=log10(energy[i]._f); power[i].x._i=fpAdd(fpMul(fpFlt_10_,power[i].x._i), tmpB._i);
    power[i].next = STOP;
    power[i].type = FALSE;
 }
// mem_free((void **) &x_r);
// mem_free((void **) &x_i);
// mem_free((void **) &energy);
}

/****************************************************************
 *
 *         Window the incoming audio signal.
 *
 ****************************************************************/

/* this function calculates a Hann window for PCM (input) samples for a 1024-pt. FFT  */
void II_hann_win(FLOAT sample[FFT_SIZE])
{
 // assignment to remove zero init PJG 18 Dec 1997
 register int i;
 register FLOAT sqrt_8_over_3;
 static int init = 0;
 static DFFT window_actual = {{1}}; // PJG 16 Dec 1997
 static FLOAT *window = (FLOAT *) &window_actual;

 if(!init){  /* calculate window function for the Fourier transform */
//    window = (FLOAT *) mem_alloc(sizeof(DFFT), "window");
    sqrt_8_over_3._f = pow(8.0/3.0, 0.5);
    for(i=0;i<FFT_SIZE;i++){
       /* Hann window formula */
       window[i]._f=sqrt_8_over_3._f*0.5*(1-cos(2.0*PI*i/(FFT_SIZE)))/FFT_SIZE;
    }
    init = 1;
 }
 for(i=0;i<FFT_SIZE;i++) sample[i]._i = fpMul(sample[i]._i, window[i]._i);
}

/*******************************************************************/
/*
/*        This function finds the maximum spectral component in each
/* subband and return them to the encoder for time-domain threshold
/* determination.
/*
/*******************************************************************/
#ifndef LONDON
void II_pick_max(mask power[HAN_SIZE],FLOAT spike[SBLIMIT])
{
 FLOAT max;
 int i,j;

 for(i=0;i<HAN_SIZE;spike[i>>4]._i = max._i, i+=16)      /* calculate the      */
 for(j=0, max._i = const_DBMIN._i;j<16;j++)                    /* maximum spectral   */
    max._i = fpGT(max._i,power[i+j].x._i) ? max._i : power[i+j].x._i; /* component in each  */
}                                                  /* subband from bound */
                                                   /* 4-16               */
#else
void II_pick_max(mask power[HAN_SIZE],FLOAT spike[SBLIMIT])
{
 FLOAT sum;
 int i,j;

 for(i=0;i<HAN_SIZE;spike[i>>4]._f = 10.0*log10(sum._f), i+=16)
                                                   /* calculate the      */
 for(j=0, sum._f = pow(10.0,0.1*DBMIN);j<16;j++)      /* sum of spectral   */
   sum._f += pow(10.0,0.1*power[i+j].x._f);              /* component in each  */
}                                                  /* subband from bound */
                                                   /* 4-16               */
#endif

/****************************************************************
 *
 *        This function labels the tonal component in the power
 * spectrum.
 *
 ****************************************************************/

/* this function extracts (tonal) sinusoidals from the spectrum  */
void II_tonal_label(mask power[HAN_SIZE], int *tone)
{
 int i,j, last = LAST, first, run, last_but_one = LAST; /* dpwe */
 FLOAT max;

 *tone = LAST;
 for(i=2;i<HAN_SIZE-12;i++){
    if(fpGT(power[i].x._i,power[i-1].x._i) && fpGE(power[i].x._i,power[i+1].x._i)){
       power[i].type = TONE;
       power[i].next = LAST;
       if(last != LAST) power[last].next = i;
       else first = *tone = i;
       last = i;
    }
 }
 last = LAST;
 first = *tone;
 *tone = LAST;
 while(first != LAST){               /* the conditions for the tonal          */
    if(first<3 || first>500) run = 0;/* otherwise k+/-j will be out of bounds */
    else if(first<63) run = 2;       /* components in layer II, which         */
    else if(first<127) run = 3;      /* are the boundaries for calc.          */
    else if(first<255) run = 6;      /* the tonal components                  */
    else run = 12;
    max._i = fpSub(power[first].x._i, fpFlt_7_);        /* after calculation of tonal   */
    for(j=2;j<=run;j++)              /* components, set to local max */
       if(fpLT(max._i, power[first-j].x._i) || fpLT(max._i, power[first+j].x._i)){
          power[first].type = FALSE;
          break;
       }
    if(power[first].type == TONE){   /* extract tonal components */
       int help=first;
       if(*tone==LAST) *tone = first;
       while((power[help].next!=LAST)&&(power[help].next-first)<=run)
          help=power[help].next;
       help=power[help].next;
       power[first].next=help;
       if((first-last)<=run){
          if(last_but_one != LAST) power[last_but_one].next=first;
       }
       if(first>1 && first<500){     /* calculate the sum of the */
          FLOAT tmp;                /* powers of the components */
          tmp = add_db(power[first-1].x, power[first+1].x);
          power[first].x = add_db(power[first].x, tmp);
       }
       for(j=1;j<=run;j++){
          power[first-j].x._i = power[first+j].x._i = const_DBMIN._i;
          power[first-j].next = power[first+j].next = STOP;
          power[first-j].type = power[first+j].type = FALSE;
       }
       last_but_one=last;
       last = first;
       first = power[first].next;
    }
    else {
       int ll;
       if(last == LAST); /* *tone = power[first].next; dpwe */
       else power[last].next = power[first].next;
       ll = first;
       first = power[first].next;
       power[ll].next = STOP;
    }
 }
}

/****************************************************************/
/*
/*        This function groups all the remaining non-tonal
/* spectral lines into critical band where they are replaced by
/* one single line.
/*
/****************************************************************/

void noise_label(mask *power,int *noise,g_thres *ltg)
{
 int i,j, centre, last = LAST;
 FLOAT index, weight, sum;
                              /* calculate the remaining spectral */
 for(i=0;i<crit_band-1;i++){  /* lines for non-tonal components   */
     for(j=cbound[i],weight._i = const_0._i,sum._i = const_DBMIN._i;j<cbound[i+1];j++){
        if(power[j].type != TONE){
           if(fpNE(power[j].x._i, fpFlt_DBMIN_)){
              static FLOAT tmpA;
              sum = add_db(power[j].x,sum);
/* the line below and others under the "MAKE_SENSE" condition are an alternate
   interpretation of "geometric mean". This approach may make more sense but
   it has not been tested with hardware. */
#ifdef MAKE_SENSE
              //weight._f += pow(10.0, power[j].x._f/10.0) * (ltg[power[j].map].bark._f-i);
              tmpA._i = fpDiv(power[j].x._i, fpFlt_10_);
              tmpA._f = pow(10.0, tmpA._f);
              weight._i = fpAdd(weight._i, fpMul(tmpA._i, fpSub(ltg[power[j].map].bark._i,fpFlt(i))));
#endif
              power[j].x._i = const_DBMIN._i;
           }
        }   /*  check to see if the spectral line is low dB, and if  */
     }      /* so replace the center of the critical band, which is */
            /* the center freq. of the noise component              */

#ifdef MAKE_SENSE
     if(fpLE(sum._i, fpFlt_DBMIN_))  centre = (cbound[i+1]+cbound[i]) /2;
     else {
        static FLOAT tmpA;
        //index._f = weight._f/pow(10.0,sum._f/10.0);
        tmpA._i = fpDiv(sum._i, fpFlt_10_);
        tmpA._f = pow(10.0,tmpA._f);
        index._i = fpDiv(weight._i, tmpA._i);
        centre = cbound[i] + (int) (index._f * (float) (cbound[i+1]-cbound[i]) );
     }
#else
     index._f = (float)( ((float)cbound[i]) * ((float)(cbound[i+1]-1)) );
     centre = (int)(pow(index._f,0.5)+0.5);
#endif

    /* locate next non-tonal component until finished; */
    /* add to list of non-tonal components             */
#ifdef MI_OPTION
     /* Masahiro Iwadare's fix for infinite looping problem? */
     if(power[centre].type == TONE)
       if (power[centre+1].type == TONE) centre++; else centre--;
#else
     /* Mike Li's fix for infinite looping problem */
     if(power[centre].type == FALSE) centre++;

     if(power[centre].type == NOISE){
       if(fpGE(power[centre].x._i, ltg[power[i].map].hear._i)){
         if(fpGE(sum._i, ltg[power[i].map].hear._i)) sum = add_db(power[j].x,sum);
         else
         sum._i = power[centre].x._i;
       }
     }
#endif
     if(last == LAST) *noise = centre;
     else {
        power[centre].next = LAST;
        power[last].next = centre;
     }
     power[centre].x._i = sum._i;
     power[centre].type = NOISE;
     last = centre;
 }
}

/****************************************************************/
/*
/*        This function reduces the number of noise and tonal
/* component for further threshold analysis.
/*
/****************************************************************/

void subsampling(mask power[HAN_SIZE],g_thres *ltg,int *tone, int *noise)
{
 int i, old;

 i = *tone; old = STOP;    /* calculate tonal components for */
 while(i!=LAST){           /* reduction of spectral lines    */
    if(fpLT(power[i].x._i, ltg[power[i].map].hear._i)){
       power[i].type = FALSE;
       power[i].x._i = const_DBMIN._i;
       if(old == STOP) *tone = power[i].next;
       else power[old].next = power[i].next;
    }
    else old = i;
    i = power[i].next;
 }
 i = *noise; old = STOP;    /* calculate non-tonal components for */
 while(i!=LAST){            /* reduction of spectral lines        */
    if(fpLT(power[i].x._i, ltg[power[i].map].hear._i)){
       power[i].type = FALSE;
       power[i].x._i = const_DBMIN._i;
       if(old == STOP) *noise = power[i].next;
       else power[old].next = power[i].next;
    }
    else old = i;
    i = power[i].next;
 }
 i = *tone; old = STOP;
 while(i != LAST){                              /* if more than one */
    static FLOAT tmpA = {0.5};
    if(power[i].next == LAST)break;             /* tonal component  */
    if(fpLT(fpSub(ltg[power[power[i].next].map].bark._i,     /* is less than .5  */
       ltg[power[i].map].bark._i), tmpA._i)) {          /* bark, take the   */
       if(fpGT(power[power[i].next].x._i, power[i].x._i)){/* maximum          */
          if(old == STOP) *tone = power[i].next;
          else power[old].next = power[i].next;
          power[i].type = FALSE;
          power[i].x._i = const_DBMIN._i;
          i = power[i].next;
       }
       else {
          power[power[i].next].type = FALSE;
          power[power[i].next].x._i = const_DBMIN._i;
          power[i].next = power[power[i].next].next;
          old = i;
       }
    }
    else {
      old = i;
      i = power[i].next;
    }
 }
}

/****************************************************************/
/*
/*        This function calculates the individual threshold and
/* sum with the quiet threshold to find the global threshold.
/*
/****************************************************************/

void threshold(mask power[HAN_SIZE],g_thres *ltg,
	       int *tone, int *noise, int bit_rate)
{
 int k, t;
 FLOAT dz, tmps, vf;

 for(k=1;k<sub_size;k++){
    static FLOAT tmpA = {-1.525};
    static FLOAT tmpB = {0.275};
    static FLOAT tmpC = {4.5};
    static FLOAT tmpD = {0.4};
    static FLOAT tmpE = {0.15};
    static FLOAT tmpF = {0.175};
    static FLOAT tmpG = {0.5};

    // intergral constants
    static FLOAT C_tmpA = {3};
    #define fpFlt_3_ C_tmpA._i
    static FLOAT C_tmpB = {1};
    #define fpFlt_1_ C_tmpB._i
    static FLOAT C_tmpD = {17};
    #define fpFlt_17_ C_tmpD._i
    static FLOAT C_tmpE = {0};
    #define fpFlt_0_ C_tmpE._i
    static FLOAT C_tmpF = {8};
    #define fpFlt_8_ C_tmpF._i
    static FLOAT C_tmpG = {6};
    #define fpFlt_6_ C_tmpG._i

    ltg[k].x._i = const_DBMIN._i;
    t = *tone;          /* calculate individual masking threshold for */
    while(t != LAST){   /* components in order to find the global     */
       if(fpGE(fpSub(ltg[k].bark._i,ltg[power[t].map].bark._i), fpNeg(fpFlt_3_)) && /*threshold (LTG)*/
          fpLT(fpSub(ltg[k].bark._i,ltg[power[t].map].bark ._i),fpFlt_8_)){
          dz._i = fpSub(ltg[k].bark._i,ltg[power[t].map].bark._i); /* distance of bark value*/
          tmps._i = fpAdd(fpSub(fpSub(tmpA._i,fpMul(tmpB._i,ltg[power[t].map].bark._i)), tmpC._i), power[t].x._i);
             /* masking function for lower & upper slopes */
          if(fpLE(fpNeg(fpFlt_3_),dz._i) && fpLT(dz._i,fpNeg(fpFlt_1_))) vf._i = fpSub(fpMul(fpFlt_17_,fpAdd(dz._i,fpFlt_1_)), fpAdd(fpMul(tmpD._i,power[t].x._i),fpFlt_6_));
          else if(fpLE(fpNeg(fpFlt_1_),dz._i) && fpLT(dz._i,fpFlt_0_)) vf._i = fpMul(fpAdd(fpMul(tmpD._i,power[t].x._i), fpFlt_6_), dz._i);
          else if(fpLE(fpFlt_0_,dz._i) && fpLT(dz._i,fpFlt_1_)) vf._i = fpMul(fpNeg(fpFlt_17_),dz._i);
          else if(fpLE(fpFlt_1_,dz._i) && fpLT(dz._i,fpFlt_8_)) vf._i = fpSub(fpMul( fpNeg(fpSub(dz._i,fpFlt_1_)) , fpSub(fpFlt_17_,fpMul(tmpE._i,power[t].x._i)) ), fpFlt_17_);
          tmps._i = fpAdd(tmps._i, vf._i);
          ltg[k].x = add_db(ltg[k].x, tmps);
       }
       t = power[t].next;
    }

    t = *noise;        /* calculate individual masking threshold  */
    while(t != LAST){  /* for non-tonal components to find LTG    */
       if(fpGE(fpSub(ltg[k].bark._i,ltg[power[t].map].bark._i), fpNeg(fpFlt_3_)) &&
          fpLT(fpSub(ltg[k].bark._i,ltg[power[t].map].bark._i), fpFlt_8_)){
          dz._i = fpSub(ltg[k].bark._i,ltg[power[t].map].bark._i); /* distance of bark value */
          tmps._i = fpAdd(fpSub(fpSub(tmpA._i,fpMul(tmpF._i,ltg[power[t].map].bark._i)), tmpG._i), power[t].x._i);
             /* masking function for lower & upper slopes */
          if(fpLE(fpNeg(fpFlt_3_),dz._i) && fpLT(dz._i,fpNeg(fpFlt_1_))) vf._i = fpSub(fpMul(fpFlt_17_,fpAdd(dz._i,fpFlt_1_)), fpAdd(fpMul(tmpD._i,power[t].x._i),fpFlt_6_));
          else if(fpLE(fpNeg(fpFlt_1_),dz._i) && fpLT(dz._i,fpFlt_0_)) vf._i = fpMul(fpAdd(fpMul(tmpD._i,power[t].x._i),fpFlt_6_), dz._i);
          else if(fpLE(fpFlt_0_,dz._i) && fpLT(dz._i,fpFlt_1_)) vf._i = fpMul(fpNeg(fpFlt_17_),dz._i);
          else if(fpLE(fpFlt_1_,dz._i) && fpLT(dz._i,fpFlt_8_)) vf._i = fpSub(fpMul( fpNeg(fpSub(dz._i,fpFlt_1_)) , fpSub(fpFlt_17_,fpMul(tmpE._i,power[t].x._i)) ), fpFlt_17_);
          tmps._i = fpAdd(tmps._i, vf._i);
          ltg[k].x = add_db(ltg[k].x, tmps);
       }
       t = power[t].next;
    }
    if(bit_rate<96)ltg[k].x = add_db(ltg[k].hear, ltg[k].x);
    else {
      FLOAT val;
      val._i = fpSub(ltg[k].hear._i, fpFlt_12_);
      ltg[k].x = add_db(val, ltg[k].x);
    }
    #undef fpFlt_3_
 }
}

/****************************************************************/
/*
/*        This function finds the minimum masking threshold and
/* return the value to the encoder.
/*
/****************************************************************/

void II_minimum_mask(g_thres *ltg,FLOAT ltmin[SBLIMIT],int sblimit)
{
 FLOAT min;
 int i,j;

 j=1;
 for(i=0;i<sblimit;i++)
    if(j>=sub_size-1)                   /* check subband limit, and       */
       ltmin[i]._i = ltg[sub_size-1].hear._i; /* calculate the minimum masking  */
    else {                              /* level of LTMIN for each subband*/
       min._i = ltg[j].x._i;
       while(ltg[j].line>>4 == i && j < sub_size){
       if(fpGT(min._i,ltg[j].x._i))  min._i = ltg[j].x._i;
       j++;
    }
    ltmin[i]._i = min._i;
 }
}

/*****************************************************************/
/*
/*        This procedure is called in musicin to pick out the
/* smaller of the scalefactor or threshold.
/*
/*****************************************************************/

void II_smr(FLOAT ltmin[SBLIMIT],FLOAT spike[SBLIMIT],
	    FLOAT scale[SBLIMIT],int sblimit)
{
 int i;
 FLOAT max;

 for(i=0;i<sblimit;i++){                     /* determine the signal   */
    max._f = 20 * log10(scale[i]._f * 32768) - 10; /* level for each subband */
    if(fpGT(spike[i]._i,max._i)) max._i = spike[i]._i;         /* for the maximum scale  */
    max._i = fpSub(max._i, ltmin[i]._i);                         /* factors                */
    ltmin[i]._i = max._i;
 }
}

/****************************************************************/
/*
/*        This procedure calls all the necessary functions to
/* complete the psychoacoustic analysis.
/*
/****************************************************************/

void II_Psycho_One(short buffer[2][1152],FLOAT scale[2][SBLIMIT],
		   FLOAT ltmin[2][SBLIMIT],frame_params *fr_ps)
{
 // assigments to remove zero init PJG 18 Dec 1997
 layer *info = fr_ps->header;
 int   stereo = fr_ps->stereo;
 int   sblimit = fr_ps->sblimit;
 int k,i, tone=0, noise=0;
 static char init = 0;
 static int off[2] = {256,256};
 DFFT sample_actual = {{1}}; // PJG 16 Dec 1997
 FLOAT *sample = (FLOAT *) &sample_actual;
 D2SBL spike_actual = {{1}}; // PJG 16 Dec 1997
 DSBL *spike = (DSBL *) &spike_actual;
 static D1408 fft_buf_actual[2] = {{1}}; // PJG 16 Dec 1997
 static D1408 *fft_buf = fft_buf_actual;
 static mask power_actual[HAN_SIZE] = {{1}}; // PJG 16 Dec 1997
 static mask_ptr power = power_actual;
 static g_ptr ltg;

// sample = (FLOAT *) mem_alloc(sizeof(DFFT), "sample");
// spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
     /* call functions for critical boundaries, freq. */
 if(!init){  /* bands, bark values, and mapping */
//    fft_buf = (D1408 *) mem_alloc((long) sizeof(D1408) * 2, "fft_buf");
//    power = (mask_ptr ) mem_alloc(sizeof(mask) * HAN_SIZE, "power");
    read_cbound(info->lay,info->sampling_frequency);
    read_freq_band(&ltg,info->lay,info->sampling_frequency);
    make_map(power,ltg);
    for (i=0;i<1408;i++) fft_buf[0][i]._i = fft_buf[1][i]._i = const_0._i;
    init = 1;
 }
 for(k=0;k<stereo;k++){  /* check pcm input for 3 blocks of 384 samples */
    for(i=0;i<1152;i++) fft_buf[k][(i+off[k])%1408]._i= fpDiv(fpFlt(buffer[k][i]),fpFlt_SCALE_);
    for(i=0;i<FFT_SIZE;i++) sample[i]._i = fft_buf[k][(i+1216+off[k])%1408]._i;
    off[k] += 1152;
    off[k] %= 1408;
                            /* call functions for windowing PCM samples,*/
    II_hann_win(sample);    /* location of spectral components in each  */
    for(i=0;i<HAN_SIZE;i++) power[i].x._i = const_DBMIN._i;  /*subband with labeling*/
    II_f_f_t(sample, power);                     /*locate remaining non-*/
    II_pick_max(power, &spike[k][0]);            /*tonal sinusoidals,   */
    II_tonal_label(power, &tone);                /*reduce noise & tonal */
    noise_label(power, &noise, ltg);             /*components, find     */
    subsampling(power, ltg, &tone, &noise);      /*global & minimal     */
    threshold(power, ltg, &tone, &noise,         /*threshold, and sgnl- */
      bitrate[info->lay-1][info->bitrate_index]/stereo); /*to-mask ratio*/
    II_minimum_mask(ltg, &ltmin[k][0], sblimit);
    II_smr(&ltmin[k][0], &spike[k][0], &scale[k][0], sblimit);
 }
// mem_free((void **) &sample);
// mem_free((void **) &spike);
}

/**********************************************************************
 *
 *        This module implements the psychoacoustic model I for the
 * MPEG encoder layer I. It uses simplified tonal and noise masking
 * threshold analysis to generate SMR for the encoder bit allocation
 * routine.
 *
 **********************************************************************/

/****************************************************************
 *
 *        Fast Fourier transform of the input samples.
 *
 ****************************************************************/

/* this function calculates an FFT analysis for the freq. domain */
void I_f_f_t(FLOAT sample[FFT_SIZE/2],mask power[HAN_SIZE/2])
{
 // assignments to remove zero init PJG 18 Dec 1997
 int i,j,k,L,l=0;
 int ip, le, le1;
 FLOAT t_r, t_i, u_r, u_i;
 static int M, MM1, init = 0, N;
 DFFT2 x_r_actual = {{1}}, x_i_actual = {{1}}, energy_actual = {{1}}; // PJG 16 Dec 1997
 FLOAT *x_r = (FLOAT *) &x_r_actual, *x_i = (FLOAT *) &x_i_actual, *energy = (FLOAT *) &energy_actual;
 static IFFT2 rev_actual = {1}; // PJG 16 Dec 1997
 static int *rev = (int *) &rev_actual;
 static D9 w_r_actual = {{1}}, w_i_actual = {{1}}; // PJG 16 Dec 1997
 static FLOAT *w_r = (FLOAT *) &w_r_actual, *w_i = (FLOAT *) &w_i_actual;

// x_r = (FLOAT *) mem_alloc(sizeof(DFFT2), "x_r");
// x_i = (FLOAT *) mem_alloc(sizeof(DFFT2), "x_i");
// energy = (FLOAT *) mem_alloc(sizeof(DFFT2), "energy");
 for(i=0;i<FFT_SIZE/2;i++) x_r[i]._i = x_i[i]._i = energy[i]._i = const_0._i;
 if(!init){
//    rev = (int *) mem_alloc(sizeof(IFFT2), "rev");
//    w_r = (FLOAT *) mem_alloc(sizeof(D9), "w_r");
//    w_i = (FLOAT *) mem_alloc(sizeof(D9), "w_i");
    M = 9;
    MM1 = 8;
    N = FFT_SIZE/2;
    for(L=0;L<M;L++){
       le = 1 << (M-L);
       le1 = le >> 1;
       w_r[L]._f = cos(PI/le1);
       w_i[L]._f = -sin(PI/le1);
    }
    for(i=0;i<FFT_SIZE/2;rev[i] = l,i++) for(j=0,l=0;j<9;j++){
       k=(i>>j) & 1;
       l |= (k<<8-j);
    }
    init = 1;
 }
 memcpy( (char *) x_r, (char *) sample, sizeof(FLOAT) * FFT_SIZE/2);
 for(L=0;L<MM1;L++){
    le = 1 << (M-L);
    le1 = le >> 1;
    u_r._i = const_1._i;
    u_i._i = const_0._i;
    for(j=0;j<le1;j++){
       for(i=j;i<N;i+=le){
          ip = i + le1;
          t_r._i = fpAdd(x_r[i]._i, x_r[ip]._i);
          t_i._i = fpAdd(x_i[i]._i, x_i[ip]._i);
          x_r[ip]._i = fpSub(x_r[i]._i, x_r[ip]._i);
          x_i[ip]._i = fpSub(x_i[i]._i, x_i[ip]._i);
          x_r[i]._i = t_r._i;
          x_i[i]._i = t_i._i;
          t_r._i = x_r[ip]._i;
          x_r[ip]._i = fpSub(fpMul(x_r[ip]._i, u_r._i), fpMul(x_i[ip]._i, u_i._i));
          x_i[ip]._i = fpAdd(fpMul(x_i[ip]._i, u_r._i), fpMul(t_r._i, u_i._i));
       }
       t_r._i = u_r._i;
       u_r._i = fpSub(fpMul(u_r._i, w_r[L]._i), fpMul(u_i._i, w_i[L]._i));
       u_i._i = fpAdd(fpMul(u_i._i, w_r[L]._i), fpMul(t_r._i, w_i[L]._i));
    }
 }
 for(i=0;i<N;i+=2){
    ip = i + 1;
    t_r._i = fpAdd(x_r[i]._i, x_r[ip]._i);
    t_i._i = fpAdd(x_i[i]._i, x_i[ip]._i);
    x_r[ip]._i = fpSub(x_r[i]._i, x_r[ip]._i);
    x_i[ip]._i = fpSub(x_i[i]._i, x_i[ip]._i);
    x_r[i]._i = t_r._i;
    x_i[i]._i = t_i._i;
    energy[i]._i = fpAdd(fpMul(x_r[i]._i, x_r[i]._i), fpMul(x_i[i]._i, x_i[i]._i));
 }
 for(i=0;i<FFT_SIZE/2;i++) if(i<rev[i]){
    t_r._i = energy[i]._i;
    energy[i]._i = energy[rev[i]]._i;
    energy[rev[i]]._i = t_r._i;
 }
 for(i=0;i<HAN_SIZE/2;i++){                     /* calculate power  */
    static FLOAT tmpA = {1E-20}, tmpB, tmpC = {POWERNORM};
    if(fpLT(energy[i]._i, tmpA._i)) energy[i]._i = tmpA._i;    /* density spectrum */
       //power[i].x._f = 10 * log10(energy[i]._f) + POWERNORM;
       tmpB._f=log10(energy[i]._f);
       power[i].x._i = fpAdd(fpMul(fpFlt_10_, tmpB._i), tmpC._i);
       power[i].next = STOP;
       power[i].type = FALSE;
 }
// mem_free((void **) &x_r);
// mem_free((void **) &x_i);
// mem_free((void **) &energy);
}

/****************************************************************
 *
 *         Window the incoming audio signal.
 *
 ****************************************************************/

/* this function calculates a  */
/* Hann window for PCM (input) */
/* samples for a 512-pt. FFT   */
void I_hann_win(FLOAT sample[FFT_SIZE/2])
{
 // assignment to remove zero init 18 Dec 1997
 register int i;
 register FLOAT sqrt_8_over_3;
 static int init = 0;
 static DFFT2 window_actual = {{1}};
 static FLOAT *window = (FLOAT *) &window_actual;

 if(!init){  /* calculate window function for the Fourier transform */
//    window = (FLOAT *) mem_alloc(sizeof(DFFT2), "window");
    sqrt_8_over_3._f = pow(8.0/3.0, 0.5);
    for(i=0;i<FFT_SIZE/2;i++){
      /* Hann window formula */
      window[i]._f=sqrt_8_over_3._f*0.5*(1-cos(2.0*PI*i/(FFT_SIZE/2)))/(FFT_SIZE/2);
    }
    init = 1;
 }
 for(i=0;i<FFT_SIZE/2;i++) sample[i]._i = fpMul(sample[i]._i, window[i]._i);
}

/*******************************************************************/
/*
/*        This function finds the maximum spectral component in each
/* subband and return them to the encoder for time-domain threshold
/* determination.
/*
/*******************************************************************/
#ifndef LONDON
void I_pick_max(mask power[HAN_SIZE/2],FLOAT spike[SBLIMIT])
{
 FLOAT max;
 int i,j;

 /* calculate the spectral component in each subband */
 for(i=0;i<HAN_SIZE/2;spike[i>>3]._i = max._i, i+=8)
    for(j=0, max._i = const_DBMIN._i;j<8;j++) max._i = fpGT(max._i,power[i+j].x._i) ? max._i : power[i+j].x._i;
}
#else
void I_pick_max(mask power[HAN_SIZE],FLOAT spike[SBLIMIT])
{
 FLOAT sum;
 int i,j;

 for(i=0;i<HAN_SIZE/2;spike[i>>3]._f = 10.0*log10(sum._f), i+=8)
                                                   /* calculate the      */
 for(j=0, sum._f = pow(10.0,0.1*DBMIN);j<8;j++)       /* sum of spectral   */
   sum._f += pow(10.0,0.1*power[i+j].x._f);              /* component in each  */
}                                                  /* subband from bound */
#endif
/****************************************************************
 *
 *        This function labels the tonal component in the power
 * spectrum.
 *
 ****************************************************************/

/* this function extracts (tonal) sinusoidals from the spectrum */
void I_tonal_label(mask power[HAN_SIZE/2], int *tone)
{
 int i,j, last = LAST, first, run;
 FLOAT max;
 int last_but_one= LAST;

 *tone = LAST;
 for(i=2;i<HAN_SIZE/2-6;i++){
    if(fpGT(power[i].x._i,power[i-1].x._i) && fpGE(power[i].x._i,power[i+1].x._i)){
       power[i].type = TONE;
       power[i].next = LAST;
       if(last != LAST) power[last].next = i;
       else first = *tone = i;
       last = i;
    }
 }
 last = LAST;
 first = *tone;
 *tone = LAST;
 while(first != LAST){                /* conditions for the tonal     */
    if(first<3 || first>250) run = 0; /* otherwise k+/-j will be out of bounds*/
    else if(first<63) run = 2;        /* components in layer I, which */
    else if(first<127) run = 3;       /* are the boundaries for calc.   */
    else run = 6;                     /* the tonal components          */
    max._i = fpSub(power[first].x._i, fpFlt_7_);
    for(j=2;j<=run;j++)  /* after calc. of tonal components, set to loc.*/
       if(fpLT(max._i, power[first-j].x._i) || fpLT(max._i, power[first+j].x._i)){   /* max   */
          power[first].type = FALSE;
          break;
       }
    if(power[first].type == TONE){    /* extract tonal components */
       int help=first;
       if(*tone == LAST) *tone = first;
       while((power[help].next!=LAST)&&(power[help].next-first)<=run)
          help=power[help].next;
       help=power[help].next;
       power[first].next=help;
       if((first-last)<=run){
          if(last_but_one != LAST) power[last_but_one].next=first;
       }
       if(first>1 && first<255){     /* calculate the sum of the */
          FLOAT tmp;                /* powers of the components */
          tmp = add_db(power[first-1].x, power[first+1].x);
          power[first].x = add_db(power[first].x, tmp);
       }
       for(j=1;j<=run;j++){
          power[first-j].x._i = power[first+j].x._i = const_DBMIN._i;
          power[first-j].next = power[first+j].next = STOP; /*dpwe: 2nd was .x*/
          power[first-j].type = power[first+j].type = FALSE;
       }
       last_but_one=last;
       last = first;
       first = power[first].next;
    }
    else {
       int ll;
       if(last == LAST) ; /* *tone = power[first].next; dpwe */
       else power[last].next = power[first].next;
       ll = first;
       first = power[first].next;
       power[ll].next = STOP;
    }
 }
}

/****************************************************************/
/*
/*        This function finds the minimum masking threshold and
/* return the value to the encoder.
/*
/****************************************************************/

void I_minimum_mask(g_thres *ltg, FLOAT ltmin[SBLIMIT])
{
 FLOAT min;
 int i,j;

 j=1;
 for(i=0;i<SBLIMIT;i++)
    if(j>=sub_size-1)                   /* check subband limit, and       */
       ltmin[i]._i = ltg[sub_size-1].hear._i; /* calculate the minimum masking  */
    else {                              /* level of LTMIN for each subband*/
       min._i = ltg[j].x._i;
       while(ltg[j].line>>3 == i && j < sub_size){
          if (fpGT(min._i,ltg[j].x._i))  min._i = ltg[j].x._i;
          j++;
       }
       ltmin[i]._i = min._i;
    }
}

/*****************************************************************/
/*
/*        This procedure is called in musicin to pick out the
/* smaller of the scalefactor or threshold.
/*
/*****************************************************************/

void I_smr(FLOAT ltmin[SBLIMIT],FLOAT spike[SBLIMIT], FLOAT scale[SBLIMIT])
{
 int i;
 FLOAT max;

 for(i=0;i<SBLIMIT;i++){                      /* determine the signal   */
    max._f = 20 * log10(scale[i]._f * 32768) - 10;  /* level for each subband */
    if(fpGT(spike[i]._i,max._i)) max._i = spike[i]._i;          /* for the scalefactor    */
    max._i = fpSub(max._i, ltmin[i]._i);
    ltmin[i]._i = max._i;
 }
}

/****************************************************************/
/*
/*        This procedure calls all the necessary functions to
/* complete the psychoacoustic analysis.
/*
/****************************************************************/

void I_Psycho_One(short buffer[2][1152],FLOAT scale[2][SBLIMIT],
		  FLOAT ltmin[2][SBLIMIT],frame_params *fr_ps)
{
 // assignment to remove zero init PJG 18 Dec 1997
 int stereo = fr_ps->stereo;
 the_layer info = fr_ps->header;
 int k,i, tone=0, noise=0;
 static char init = 0;
 static int off[2] = {256,256};
 DFFT2 sample_actual = {{1}}; // PJG 16 Dec 1997
 FLOAT *sample = (FLOAT *) &sample_actual;
 D2SBL spike_actual = {{1}}; // PJG 16 Dec 1997
 DSBL *spike = (DSBL *) &spike_actual;
 static D640 fft_buf_actual[2] = {{1}}; // PJG 16 Dec 1997
 static D640 *fft_buf = fft_buf_actual;
 static mask power_actual[HAN_SIZE/2] = {{1}}; // PJG 16 Dec 1997
 static mask_ptr power = power_actual;
 static g_ptr ltg;

// sample = (FLOAT *) mem_alloc(sizeof(DFFT2), "sample");
// spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
            /* call functions for critical boundaries, freq. */
 if(!init){ /* bands, bark values, and mapping              */
//    fft_buf = (D640 *) mem_alloc(sizeof(D640) * 2, "fft_buf");
//    power = (mask_ptr) mem_alloc(sizeof(mask) * HAN_SIZE/2, "power");
    read_cbound(info->lay,info->sampling_frequency);
    read_freq_band(&ltg,info->lay,info->sampling_frequency);
    make_map(power,ltg);
    for(i=0;i<640;i++) fft_buf[0][i]._i = fft_buf[1][i]._i = const_0._i;
    init = 1;
 }
 for(k=0;k<stereo;k++){    /* check PCM input for a block of */
    for(i=0;i<384;i++)     /* 384 samples for a 512-pt. FFT  */
       fft_buf[k][(i+off[k])%640]._i= fpDiv(fpFlt(buffer[k][i]),fpFlt_SCALE_);
    for(i=0;i<FFT_SIZE/2;i++)
       sample[i]._i = fft_buf[k][(i+448+off[k])%640]._i;
    off[k] += 384;
    off[k] %= 640;
                        /* call functions for windowing PCM samples,   */
    I_hann_win(sample); /* location of spectral components in each     */
    for(i=0;i<HAN_SIZE/2;i++) power[i].x._i = const_DBMIN._i;   /* subband with    */
    I_f_f_t(sample, power);              /* labeling, locate remaining */
    I_pick_max(power, &spike[k][0]);     /* non-tonal sinusoidals,     */
    I_tonal_label(power, &tone);         /* reduce noise & tonal com., */
    noise_label(power, &noise, ltg);     /* find global & minimal      */
    subsampling(power, ltg, &tone, &noise);  /* threshold, and sgnl-   */
    threshold(power, ltg, &tone, &noise,     /* to-mask ratio          */
      bitrate[info->lay-1][info->bitrate_index]/stereo);
    I_minimum_mask(ltg, &ltmin[k][0]);
    I_smr(&ltmin[k][0], &spike[k][0], &scale[k][0]);
 }
// mem_free((void **) &sample);
// mem_free((void **) &spike);
}
