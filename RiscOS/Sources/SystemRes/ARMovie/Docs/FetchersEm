From: Paul Gardiner <paul@fsel.com>
Date: Fri, 22 Mar 1996 08:59:56 GMT
To: SWilson
Subject: Fetchers

Hi Sophie,
   Robin and I have been fiddling with this fetcher problem. Here's some
thoughts that have come out of our discussions. We don't know enough about the
guts of Replay to tell if the suggestions are reasonable. I think Robin has
more comments that he will send you later on.

Cheers,

Paul.

---------------------------------------------------------------------------

Fetchers: some random comments
------------------------------
Sophie has described fetchers in a very natural way, as an alternative to the
catalogue: in old-style Replay the catalogue is an interpretation of the file,
saying where chunks are, which bits are video, which bits are audio; in
new-style Replay the catalogue is a reference to a piece of code that loads and
interprets chunks.

There are various aspects of an implementation that may need discussing, some
mentioned below:

* File recognition: effectively deriving the information for a Replay header.

* Presenting header information to Replay.

* Replay's loading of fetchers.

* Replay's interface to fetchers.

It would be good if we can treat these almost completely independently.

File recognition.
----------------
We may be able to put off deciding exactly how this is to be done. We just need
to check that our interfaces don't rule out nice solutions to the problem.

Header presentation.
-------------------
The main question here seems to be between using a standardish Replay header or
passing values in memory (i.e., having Replay call a SWI).

The standardish Replay header provides a certain amount of flexibility. If
Replay were happy to be passed two files, one containing the data, and the
other containing the header, all sorts of possibilities open up. (If passed one
file, Replay would expect both data and header in that one file, as usual.)

* MovieFS could make alien films look like directories containing a single
file, which provides just the header. Replay would be passed both the header
and the image file itself.

* MovieFS could make alien films look like directories containing two files
(header and data, of course). Both would be passed to Replay.

* MovieFS could make alien films look like directories containing a single
header-and-data file. That one file would be passed to Replay.

* An application could generate headers for alien films, on demand, and place
them in a scrap directory. Both the alien film and the header would be passed
to Replay. (Works across NFS, of course).

* A film for which a header had previously been generated could be stored in an
ordinary directory with its header. Blah blah blah.

* A CD full of alien films could be supplied with a floppy full of headers.

The passing of values by Replay calling a SWI provides a much cleaner overall
system (no need for messy image filing systems at all), but it does rather tie
Replay to the recognition code (Replay can't call the SWI if the recognition
module isn't loaded). A way out of that one is to consider the recognition
module to be part of Replay, but that would mean us having to design an
extensible recogniser module before there could be a fetcher-using release of
Replay.

Replay's loading of fetchers.
----------------------------
There was a worry here that if fetchers were loaded in the same way as
decompressors then there would be no easy way to write them in C. That worry
seems to be unfounded: ARM coders can write nice lean fast fetchers, whereas C
coders can write a little ARM-code veneer that redirects to a module.

Replay's interface to fetchers.
------------------------------
We could start with the simplest interface that has any chance at all of
working, and then add features as required until we get something workable.

First attempt:
Assuming Replay has already obtained the information from reading the header or
calling the recognition SWI.

Three entry points: Open, Fetch, Close.

Open:
On Entry: R0=file handle
On Exit:  ---

Does what ever it needs to in readiness for calls to Fetch. It might have to
allocate some memory. It might even have to load a module! Is this okay? If not
fetcher writing will be a lot harder and slower.

Fetch:
On Entry: R0=address of buffer
          R1=size of buffer
On Exit:  R0=Pointer to Frame Index
          R1=Pointer to Sound Index

Fills the buffer and returns a description of the information it has loaded
(positions of frames and chunks of sound).

The frame index has the form:

Offset: 0  Number of frames in index
        4  Frame 1 start
        8  Size of Frame 1???
        12 Frame 2 start
        16 Size of Frame 2 ???
        ...

The sound index has the form:

Offset: 0  Number of sound chunks
        4  Start of sound chunk 1
        8  Size of sound chunk 1
        12 Start of sound chunk 2
        16 Size of sound chunk 2
        ...

Close:
On Entry: ---
On Exit:  ---

Shuts down fetcher.

---------------------------------------------------------------------------
Potential problems.

* Films need to be played from arbitrary start positions. A fourth fetcher
entry point could be added to support this.

SetTime:
On Entry: R0=time (16bit.16bit)
On Exit:  ---

The specified time may not correspond to a key frame, in which case perhaps the
fetcher should set to the latest earlier time that does correspond to a key
frame, returning that time in R0; Replay can then play silently and invisibly
for the difference of the times. Should a fetcher be free always to do this, or
should Replay pass a flag to the Open entry point or to SetTime, saying whether
to do it or not? Should there be a limit on how far back in time to look.
Perhaps:

SetTime:
On Entry: R0=requested time (16bit.16bit)
          R1=allowed drift
On Exit:  R0=actual time set

Then <allowed drift> = 0 implies <actual time set> = <requested time>

* The frame index returned by Fetch has frame sizes so that editing programs
can copy frames from place to place. Since thinking of this, we've realised
that there are occasions when it is useful for frames to include indirected
data; editing programs wouldn't be able to copy such frames without
understanding their structure. Can we get away without frame sizes? Should we
have another entry point (called Flatten say), which moves data about so as to
remove indirections? This would have a time overhead but would be used only by
editing suites. Can we ignore this for now?

* Frame positions and sizes are difficult to derive for the native
Replay-format fetcher.

* The frames-per-chunk field of the replay header cannot be given a definitive
value in the fetchers universe. What's the minimum amount of information that
Replay could work with?

* A fetcher can't necessarily know where frames are going to be, before filling
a buffer. So a fetcher can't avoid pulling in the odd half frame at the end of
a buffer. When a fetcher does pick up half a frame it can just not bother to
inform Replay that its there, and then on the next fetch, copy the half frame
to the beginning of the new buffer (to avoid rereading it). For this to work it
is important that, when calling Fetch, Replay ensures no corruption to the last
buffer (outside of the areas refered to by the indexes). Is it always
reasonable for Replay to guarantee this, or should Replay pass a flag to Fetch
saying whether the last buffer is okay?

* Currently we have MovieFS sending palettes to our decompressors by gluing
them on the front of frames. Doing this in a fetcher requires the moving of
just small amounts of data, providing were wishing only to do it to the first
frame in each buffer (as we do now). Gluing palettes on the beginning of frames
close to the middle of a buffer requires a large movement of memory.
Introducing data structures with indirection gets around this problem, but
makes the frame sizes a little meaningless, as mentioned above.

* We also send information to our sound-playing code by gluing it on the front
of the sound chunk. This doesn't look to be a problem really: we can just
ensure there's sufficient room in the buffer to place a copy of the header and
then return it as the first entry in the sound index.

* Because of the varying structure of alien-film formats, it is likely that the
first call to Fetch will provide Replay with different amounts of audio and
video data (in terms of playing time), and that some skewing of the data will
persist throughout playback.

* The latest Replay can play multiple films simultaneously. To play two films
of different types, clearly Replay needs to load two fetchers. If playing two
films of the same type, Replay could load two copies of the one required
fetcher, and have each copy know which film it was dealing with. It could
alternatively use a single fetcher, but some enrichment of the fetcher
interface would be required (i.e. 'Open' could return a 'fetching handle' that
must be passed back on calls to the other entry points).

* Version control: we will not get these interfaces right first time, and in
six months time will want to change things. How do we ensure that we don't have
Replay talking one language to a fetcher that speaks another? How do we, in the
future, write fetchers that work with all previous fetcher versions of Replay?
How does Sophie (if she wishes) write a Replay that can use any version of a
fetcher? We can't just put this off until it bites us - or can we? All we need
do is change the naming convention for the fetcher-code files on each revision:
Fetch, Fetchv2, Fetchv3, ... A developer of fetchers can then supply them all
if need be, and the particular version of Replay in use can pick the latest it
understands.

* Fetches from alien film files are going to produce noncontiguous sound data.
What do we do about that?

1) The fetcher can shove all the sound data into one lump, using a memory copy.
This requires an increase in storage space in every buffer.

2) The fetcher deliberately loads the sound data into consecutive locations in
memory. This ruins sequential access of files, and causes more short reads. To
circumvent this loss of performance, we require buffering; bad - not only do we
get back to MovieFS's situation, we still have to do memory copies, so no
better than 1.

3) The player could do the copy and amalgamate all sound data into one chunk.
This requires less memory as only two sound buffers would be required, rather
than a sound buffered sized piece of memory in every fetcher buffer.

4) The sound code could be altered to play from small indexed buffers. This
requires more complex sound code, and a possible loss of performance, but
whether this will outweigh the loss of performance from a memory copy is
unclear.

No 3 may be best for now: no rewriting of sound code, and no compromising of
the fetchers interface.

Date: Fri, 22 Mar 96 11:54:04 GMT
From: sproven@art.acorn.co.uk (Simon Proven)
To: SWilson
CC: TDobson, SCormie, JRedford
Subject: Re: New Irlam s/w (Tue Mar 12 14:30:04 1996)

>There is an update to the Flash of the Multimedia/Ethernet card
>in NFS::spinner.$.NCD.Sophie.update

I've found that using NFS 2.10 (instead of 2.27) stops the problems I've been
seeing with NFS on the EtherV card, so it's possible that NFS was at fault
(however there were no problems with NFS 2.27 with the EtherB driver).

Simon
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Mon,25 Mar 1996 15:09:49 mail was sent to Paul@fsel.com
and cc'd to Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
>Fetchers: some random comments
>------------------------------
>Sophie has described fetchers in a very natural way, as an alternative to the
>catalogue: in old-style Replay the catalogue is an interpretation of the file,
>saying where chunks are, which bits are video, which bits are audio; in
>new-style Replay the catalogue is a reference to a piece of code that loads and
>interprets chunks.

Too true.

>There are various aspects of an implementation that may need discussing, some
>mentioned below:

>* File recognition: effectively deriving the information for a Replay header.

And also providing the means to start the whole system in the first place (the
alternative being deliberately to place <ARMovie$Dir>.Player on the command
line to kick off playing a clip and to have programs call something that tells
them if a file can be played).

>* Presenting header information to Replay.

Most important.

>* Replay's loading of fetchers.

Must allow multiple fetchers to be used simultaneously.

>* Replay's interface to fetchers.

Must be simple and proof against upgrade.

>It would be good if we can treat these almost completely independently.

And it would also be good if we can finish all this soon (like within two
months). Did I mention that Oracle are likely to want this technology for the
Network Computer? (:-))

>File recognition.
>----------------
>We may be able to put off deciding exactly how this is to be done. We just need
>to check that our interfaces don't rule out nice solutions to the problem.

What's a playable file? How can users and programs tell? How do we provide a
very simple interface for the very simple minded programmers?

I'm biased towards sticking with the current situation - and maybe extending it
later on.

>Header presentation.
>-------------------
>The main question here seems to be between using a standardish Replay header or
>passing values in memory (i.e., having Replay call a SWI).

Well, the subsiduary question is the nature of the data in the header/dll
fetcher. In particular Replay has notions of knowing the allocation sizes for
practically everything after doing this.

>The standardish Replay header provides a certain amount of flexibility. If
>Replay were happy to be passed two files, one containing the data, and the
>other containing the header, all sorts of possibilities open up. (If passed one
>file, Replay would expect both data and header in that one file, as usual.)

Yes, there would be no problem in having two files, except for reaching the
second one (back to file recognition). If the header/dll fetcher block is
brewed on the spot, we could put another entry in it giving the data file name
or a file handle. There seem to be real problems passing the second file as a
parameter on the original command line since it means the caller of the Replay
system has to know the difference.

>* MovieFS could make alien films look like directories containing a single
>file, which provides just the header. Replay would be passed both the header
>and the image file itself.

>* MovieFS could make alien films look like directories containing two files
>(header and data, of course). Both would be passed to Replay.

>* MovieFS could make alien films look like directories containing a single
>header-and-data file. That one file would be passed to Replay.

>* An application could generate headers for alien films, on demand, and place
>them in a scrap directory. Both the alien film and the header would be passed
>to Replay. (Works across NFS, of course).

>* A film for which a header had previously been generated could be stored in an
>ordinary directory with its header. Blah blah blah.

>* A CD full of alien films could be supplied with a floppy full of headers.

Alternatively the header could permute into the data file by silly pointer
addresses. You're bound to have the header at offset 0, though.

>The passing of values by Replay calling a SWI provides a much cleaner overall
>system (no need for messy image filing systems at all), but it does rather tie
>Replay to the recognition code (Replay can't call the SWI if the recognition
>module isn't loaded). A way out of that one is to consider the recognition
>module to be part of Replay, but that would mean us having to design an
>extensible recogniser module before there could be a fetcher-using release of
>Replay.

This is definitely a nasty area. I would prefer to stick to a system where the
header triggers off the new activities, but this could included a combination
approach where there's nothing in the header except the hint to call the new
facility.

Actually, I'd prefer to stick to the current header...

>Replay's loading of fetchers.
>----------------------------
>There was a worry here that if fetchers were loaded in the same way as
>decompressors then there would be no easy way to write them in C. That worry
>seems to be unfounded: ARM coders can write nice lean fast fetchers, whereas C
>coders can write a little ARM-code veneer that redirects to a module.

We could make the interface between Replay and the fetcher much more like the C
calling sequence than the decompressor one was (mainly because the fetcher
doesn't need to be called in interrupt mode with IRQs enabled!) and (novelty)
use r14 for the return value, r0-r3 for parameters! However there are
inevitable problems with run time libraries. I don't mind calling an Initialise
Fetcher routine first, though.

The system must allow multiple fetchers to be used simultaneously, both of
different types and of the same type.

>Replay's interface to fetchers.
>------------------------------
>We could start with the simplest interface that has any chance at all of
>working, and then add features as required until we get something workable.

>First attempt:
>Assuming Replay has already obtained the information from reading the header or
>calling the recognition SWI.

>Three entry points: Open, Fetch, Close.

>Open:
>On Entry: R0=file handle
>On Exit:  ---

>Does what ever it needs to in readiness for calls to Fetch. It might have to
>allocate some memory. It might even have to load a module! Is this okay? If not
>fetcher writing will be a lot harder and slower.

Yes, this is OK provided that the module can retain state for several open
files simultaneously (WIMP definition of simultaneity).

>Fetch:
>On Entry: R0=address of buffer
>          R1=size of buffer
>On Exit:  R0=Pointer to Frame Index
>          R1=Pointer to Sound Index

>Fills the buffer and returns a description of the information it has loaded
>(positions of frames and chunks of sound).

Fills the buffer? Or provides at most one chunks worth of frames? Which chunk
number into the file are we? You can't simply give successive chunks since the
combination of -playfor and -loop could have it start back at the beginning
again. (see below for -startat)

>The frame index has the form:

>Offset: 0  Number of frames in index
>        4  Frame 1 start
>        8  Size of Frame 1???
>        12 Frame 2 start
>        16 Size of Frame 2 ???
>        ...

When playing the file, Replay cares little about these indexes, though it could
be modified to use them. It cares even less about compressed frame sizes and
has no particular way of using the information.

>The sound index has the form:

>Offset: 0  Number of sound chunks
>        4  Start of sound chunk 1
>        8  Size of sound chunk 1
>        12 Start of sound chunk 2
>        16 Size of sound chunk 2
>        ...

Yeesh. Very real problems with bull-dozing all the data together.

>Close:
>On Entry: ---
>On Exit:  ---

>Shuts down fetcher.

Super.

>---------------------------------------------------------------------------
>Potential problems.

>* Films need to be played from arbitrary start positions. A fourth fetcher
>entry point could be added to support this.

Replay has its own ideas on this: it really needs to know the closest chunk or
have a lobotomy. There's no time problem about decompressing from the start of
the closest chunk until the required frame is reached and this procedure does
ensure sound/video sync.

>SetTime:
>On Entry: R0=time (16bit.16bit)
>On Exit:  ---

Why not the value given to -startat?

>The specified time may not correspond to a key frame, in which case perhaps the
>fetcher should set to the latest earlier time that does correspond to a key
>frame, returning that time in R0; Replay can then play silently and invisibly
>for the difference of the times. Should a fetcher be free always to do this, or
>should Replay pass a flag to the Open entry point or to SetTime, saying whether
>to do it or not? Should there be a limit on how far back in time to look.

What will this do to the chunk structure of the file?????

>Perhaps:

>SetTime:
>On Entry: R0=requested time (16bit.16bit)
>          R1=allowed drift
>On Exit:  R0=actual time set

>Then <allowed drift> = 0 implies <actual time set> = <requested time>

>* The frame index returned by Fetch has frame sizes so that editing programs
>can copy frames from place to place. Since thinking of this, we've realised
>that there are occasions when it is useful for frames to include indirected
>data; editing programs wouldn't be able to copy such frames without
>understanding their structure. Can we get away without frame sizes? Should we
>have another entry point (called Flatten say), which moves data about so as to
>remove indirections? This would have a time overhead but would be used only by
>editing suites. Can we ignore this for now?

Yes. Its not part of our remit to design the world's best compressed file
editting application!

>* Frame positions and sizes are difficult to derive for the native
>Replay-format fetcher.

Nay, impossible! They can only be discovered by decompressing the file...

>* The frames-per-chunk field of the replay header cannot be given a definitive
>value in the fetchers universe. What's the minimum amount of information that
>Replay could work with?

Either a definitive value or Robin is going to have to recode Player for me!

Frames per chunk does allow simple computations to be made on latency for the
wimp and worst case computations on device bandwidth/buffer size. It never
trips over itself if it gets anomalously big/small numbers of frames into
memory (since it can't).

>* A fetcher can't necessarily know where frames are going to be, before filling
>a buffer. So a fetcher can't avoid pulling in the odd half frame at the end of
>a buffer. When a fetcher does pick up half a frame it can just not bother to
>inform Replay that its there, and then on the next fetch, copy the half frame
>to the beginning of the new buffer (to avoid rereading it). For this to work it
>is important that, when calling Fetch, Replay ensures no corruption to the last
>buffer (outside of the areas refered to by the indexes). Is it always
>reasonable for Replay to guarantee this, or should Replay pass a flag to Fetch
>saying whether the last buffer is okay?

I think its possible to guarantee this. Unless something nasty happens in
amalgamating the sound data.

>* Currently we have MovieFS sending palettes to our decompressors by gluing
>them on the front of frames. Doing this in a fetcher requires the moving of
>just small amounts of data, providing were wishing only to do it to the first
>frame in each buffer (as we do now). Gluing palettes on the beginning of frames
>close to the middle of a buffer requires a large movement of memory.
>Introducing data structures with indirection gets around this problem, but
>makes the frame sizes a little meaningless, as mentioned above.

I think the frame sizes are meaningless - we are really only trying to play
files, not become the Adobe Premiere of the western world.

>* We also send information to our sound-playing code by gluing it on the front
>of the sound chunk. This doesn't look to be a problem really: we can just
>ensure there's sufficient room in the buffer to place a copy of the header and
>then return it as the first entry in the sound index.

Yes.

>* Because of the varying structure of alien-film formats, it is likely that the
>first call to Fetch will provide Replay with different amounts of audio and
>video data (in terms of playing time), and that some skewing of the data will
>persist throughout playback.

Chunk sizes? File IO sizes? Will it maintain sync and speed without placing
greater requirements on the hardware (e.g. CD ROM drives are notoriously slow
at silly accesses).

>* The latest Replay can play multiple films simultaneously. To play two films
>of different types, clearly Replay needs to load two fetchers. If playing two

yes

>films of the same type, Replay could load two copies of the one required
>fetcher, and have each copy know which film it was dealing with. It could

which is fine as far as I'm concerned

>alternatively use a single fetcher, but some enrichment of the fetcher
>interface would be required (i.e. 'Open' could return a 'fetching handle' that
>must be passed back on calls to the other entry points).

also fine

>* Version control: we will not get these interfaces right first time, and in
>six months time will want to change things. How do we ensure that we don't have
>Replay talking one language to a fetcher that speaks another? How do we, in the

by never doing it!

>future, write fetchers that work with all previous fetcher versions of Replay?

by upgrading in lock step. It is permissable to change things en-masse if
needed (e.g. the colour space mapping programs and Replay have the same
incestuous relationship).

>How does Sophie (if she wishes) write a Replay that can use any version of a
>fetcher? We can't just put this off until it bites us - or can we? All we need

Yes.

>do is change the naming convention for the fetcher-code files on each revision:
>Fetch, Fetchv2, Fetchv3, ... A developer of fetchers can then supply them all
>if need be, and the particular version of Replay in use can pick the latest it
>understands.

If you insist. I still think you're making a mountain out of a molehill.

>* Fetches from alien film files are going to produce noncontiguous sound data.
>What do we do about that?

Something efficient, please.

>1) The fetcher can shove all the sound data into one lump, using a memory copy.
>This requires an increase in storage space in every buffer.

In which buffer? Surely I get data in the same agregate size? Or are you saying
that as well as the discontiguous layout, there's a contiguous lump at the end?

>2) The fetcher deliberately loads the sound data into consecutive locations in
>memory. This ruins sequential access of files, and causes more short reads. To
>circumvent this loss of performance, we require buffering; bad - not only do we
>get back to MovieFS's situation, we still have to do memory copies, so no
>better than 1.

Yes, no better.

>3) The player could do the copy and amalgamate all sound data into one chunk.
>This requires less memory as only two sound buffers would be required, rather
>than a sound buffered sized piece of memory in every fetcher buffer.

Actually, I think it comes to the same thing - for each of the file IO buffers,
there must exist enough extra memory to hold a contiguous version.

>4) The sound code could be altered to play from small indexed buffers. This
>requires more complex sound code, and a possible loss of performance, but
>whether this will outweigh the loss of performance from a memory copy is
>unclear.

The sound code already copies the data (which may have vanished before the
sound is emitted), so this might not cause any loss of performance. We'd have
to get all the sound code updated to the new spec of Sound Give Data, though.

>No 3 may be best for now: no rewriting of sound code, and no compromising of
>the fetchers interface.

Fine by me.

When shall we do it by?

--Sophie
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Mon, 25 Mar 1996 17:08:43 +0000 (GMT)

Hi,

Perhaps I ought to say a bit about the file you just got...

After I last spoke to you about Fetchers, I went away for the weekend, and
spent 4 hours sat on a coach. In that time I "brain dumped" into my Psion about
how fetchers should work. When I got back, I presented Paul with this file, and
he worked his way through it, finding problems and alternatives, and discussing
them with me.

The file you have just replied to was Pauls rewrite of my file. This was
written to try and raise all the possible questions we could think of and to
suggest some answers to them.

My original file was much more aimed at setting out a single solution to
everything.

While Pauls was was a very good document, I do feel it didn't make one or two
points as strongly as I would have liked them to be made. (This is not in any
way to be an attack on Pauls file, just an explaination of why you might detect
a slight shift in emphasis when I talk about it...)

:>* File recognition: effectively deriving the information for a Replay header.
:
:And also providing the means to start the whole system in the first place (the
:alternative being deliberately to place <ARMovie$Dir>.Player on the command
:line to kick off playing a clip and to have programs call something that tells
:them if a file can be played).

I described a fairly detailed idea for what started as a recognition module for
Replay. Basically, you have a central "Movie" module in memory that can be
called to identify a film. Other new modules can register recognition routines
with this. When the Movie module asks for a film to be recognised, it passes it
around its registered children to see if they can recognise it from its
structure.

In my original, suggestion this module was going to be rolled into the central
Replay system as described below. Paul very correctly pointed out that this
could be made a separate entity and could be considered separately. Hence the
fact it was treated individually above.

------

In my original scheme, Player would call the Movie Module, and the Movie module
would return "Fetcher: AVI" (say). Player could then load the fetcher, and call
that to get the header information. I like this idea for several reasons:

1) We no longer have any Image Filing system stuff, so it works on NFS, and
gives a clean interface.

2) The recognition module has no need to know how to extract the header info,
so stays small.

Paul however likes Image Filing systems and the existing ARMovie Header idea.
We all need to discuss this. I suspect you will have strong opinions on this.

--------

:>* Replay's loading of fetchers.
:
:Must allow multiple fetchers to be used simultaneously.

Yes. My original scheme was very careful to allow a single fetcher loaded into
memory to be run in multiple threads at once, using a "context handle". Paul
didn't like this for various reasons, but I remain unconvinced.

:Must be simple and proof against upgrade.

Yup. I described a whole protocol for this down to the register level, but Paul
correctly identified that as Implementation detail.

His alternative suggestion of having multiple versions of fetchers stored on
disc has the advantage that on average fetchers are smaller, but has various
disadvatages too.

:And it would also be good if we can finish all this soon (like within two
:months). Did I mention that Oracle are likely to want this technology for the
:Network Computer? (:-))

We are very keen to get this done asap if it means an NC tie in :-)

:What's a playable file? How can users and programs tell? How do we provide a
:very simple interface for the very simple minded programmers?

The recognition module seems a good solution.

:I'm biased towards sticking with the current situation - and maybe
:extending it later on.

I can see that. How much of this can be done piecemeal without sacrificing
efficiency is unclear to me.

:Well, the subsiduary question is the nature of the data in the header/dll
:fetcher. In particular Replay has notions of knowing the allocation sizes for
:practically everything after doing this.

Yes. My original thought of presenting data to Replay in 2 stages was for
exactly this reason.

First, the Player calls some routine (in my case the Movie module) to find out
what fetcher to use.

Second, the Player loads the fetcher, and that then presents all the data that
was there before (except the stuff I will describe below).

I like this 2 stage way of working as it means we have less in memory at a time
- the central Movie module needs only to be able to recognise files (For AE7s,
it looks for "ARMovie", for AVIs it looks for "RIFF" then "AVIList" etc) rather
than to extract the whole header data.

The only thing that needs to be allocated before the header stuff is known is
then the memory to hold the fetcher. This is an unavoidable overhead anyway, so
shouldn't be a problem.

:Yes, there would be no problem in having two files, except for reaching the
:second one (back to file recognition). If the header/dll fetcher block is
:brewed on the spot, we could put another entry in it giving the data file name
:or a file handle. There seem to be real problems passing the second file as a
:parameter on the original command line since it means the caller of the Replay
:system has to know the difference.

Yes. If we go with the Image Filing system version, then just having 1 file
seems the right thing to do to me (The consequences of pairs of files being
separated is something I don't want to think about).

If we ditch Image filing systems and make the header be presented to Replay by
calling the fetcher, the problem goes away.

:Alternatively the header could permute into the data file by silly pointer
:addresses. You're bound to have the header at offset 0, though.

True. But this means all the problems with Image Filing systems across NFS. We
have a way around this using redirection files on a local filing system, but
its not nice (IMHO). Particularly, when do you know it is safe to delete the
redirection file?

:This is definitely a nasty area. I would prefer to stick to a system where the
:header triggers off the new activities, but this could included a combination
:approach where there's nothing in the header except the hint to call the new
:facility.
:
:Actually, I'd prefer to stick to the current header...

We thought that would be your answer :-)

:We could make the interface between Replay and the fetcher much more
:like the C calling sequence than the decompressor one was (mainly
:because the fetcher doesn't need to be called in interrupt mode with
:IRQs enabled!) and (novelty) use r14 for the return value, r0-r3 for
:parameters! However there are inevitable problems with run time
:libraries. I don't mind calling an Initialise Fetcher routine first,
:though.

Yes.

:The system must allow multiple fetchers to be used simultaneously, both of
:different types and of the same type.

Yes. Does it need to allow the same fetcher to be used in 2 threads? This is
good for memory use...

:Yes, this is OK provided that the module can retain state for several open
:files simultaneously (WIMP definition of simultaneity).

Yes. My original scheme included a new header field that gave a size for a
"context" buffer. This buffer would be allocated by the player and passed in to
every Fetcher entry point. The fetcher would store all its state in theis
buffer.

Paul wasn't so keen on this (partly cos it makes writing stuff in C harder I
suspect).

My original thought was that this way Player would have total control over the
memory allocation, but Paul has since convinced me that this is less important.

:Fills the buffer? Or provides at most one chunks worth of frames? Which chunk
:number into the file are we? You can't simply give successive chunks since the
:combination of -playfor and -loop could have it start back at the beginning
:again. (see below for -startat)

Fills the buffer. This is something we really need to get straight. See below.

:When playing the file, Replay cares little about these indexes,
:though it could be modified to use them. It cares even less about
:compressed frame sizes and has no particular way of using the
:information.

OK. The point is this:

When playing AE7 files, you are guaranteed that one frame follows the next
exactly. When playing other files, this is NOT true. By providing indexes into
the file there is no problem here.

We obviously need to be able to say both of the following things:

"The first frame is here, and others are consecutive"
"This is an index as to where you can find frame data"

We appreciate that the frame size data is not important for the player but we
wondered if it would be nice to have. There are compelling reasons for dumping
it for now.

:Yeesh. Very real problems with bull-dozing all the data together.

Problems yes. Unfortunately unavoidable ones. Either the fetcher needs to
bulldoze it, or the sound stuff does. We have outlined alternatives below.

:>Close:
:>On Entry: ---
:>On Exit:  ---
:
:>Shuts down fetcher.
:
:Super.

Wow, an uncontested one :-)

:>* Films need to be played from arbitrary start positions. A fourth fetcher
:>entry point could be added to support this.
:
:Replay has its own ideas on this: it really needs to know the closest chunk or
:have a lobotomy. There's no time problem about decompressing from the start of
:the closest chunk until the required frame is reached and this procedure does
:ensure sound/video sync.

OK. You are assuming several things here:

1) We still run in chunks
2) We have a keyframe every chunk.

Neither of these may be true.

I will describe a better system later.

:Why not the value given to -startat?

Don't know the exact format of this off the top of my head, and its miles to
the nearest docs.

Basically, the time should be speicified in time, not in frames. This is cos
some film types have different spacings between frames according to whats
happening.

:What will this do to the chunk structure of the file?????

You are assuming chunks again.

:Yes. Its not part of our remit to design the world's best compressed file
:editting application!

I agree (but if we can get it for free, then leaving hooks such that films
*can* be edited is a bonus).

:Nay, impossible! They can only be discovered by decompressing the file...

Thus they are possible to discover. Just very hard. While this is not feasible
at Runtime, it may be possible to offer another "flatten" entry point. that
would do the job.

:>* The frames-per-chunk field of the replay header cannot be given a
:>definitive value in the fetchers universe. What's the minimum amount
:>of information that Replay could work with?
:
:Either a definitive value or Robin is going to have to recode Player for me!

Ah. Rats. Time to dust MoviePlay off then :-)

We really need to talk about this.

:Frames per chunk does allow simple computations to be made on latency for the
:wimp and worst case computations on device bandwidth/buffer size. It never
:trips over itself if it gets anomalously big/small numbers of frames into
:memory (since it can't).

Can't we provide a "guide" figure but feel free to squeeze more in if we can
manage it?

:I think its possible to guarantee this. Unless something nasty happens in
:amalgamating the sound data.

IMAO Amalgamating the sound data is the wrong way to go. Changing the sound
playback routines to play it back from an indexed chunk is better.

:I think the frame sizes are meaningless - we are really only trying to play
:files, not become the Adobe Premiere of the western world.

Sure.

:>* We also send information to our sound-playing code by gluing it on
:>the front of the sound chunk. This doesn't look to be a problem
:>really: we can just ensure there's sufficient room in the buffer to
:>place a copy of the header and then return it as the first entry in
:>the sound index.
:
:Yes.

But this *is* a big problem if you are going to insist on use bulldozing the
sound.

:>* Because of the varying structure of alien-film formats, it is
:>likely that the first call to Fetch will provide Replay with
:>different amounts of audio and video data (in terms of playing
:>time), and that some skewing of the data will persist throughout
:>playback.
:
:Chunk sizes? File IO sizes? Will it maintain sync and speed without placing
:greater requirements on the hardware (e.g. CD ROM drives are notoriously slow
:at silly accesses).

You're assuming chunks again. Part of the point of ditching Chunks is to ensure
that we *can* get good access to the hardware.

:>films of the same type, Replay could load two copies of the one required
:>fetcher, and have each copy know which film it was dealing with. It could
:
:which is fine as far as I'm concerned

But on low memory devices such as the NC, this is an undesirable overhead.

:>alternatively use a single fetcher, but some enrichment of the
:>fetcher interface would be required (i.e. 'Open' could return a
:>'fetching handle' that must be passed back on calls to the other
:>entry points).
:
:also fine

But much nicer...

:by upgrading in lock step. It is permissable to change things en-masse if
:needed (e.g. the colour space mapping programs and Replay have the same
:incestuous relationship).

But other programs that call the fetchers (like Editing suites) must have some
way of knowing what they are talking to.

:>* Fetches from alien film files are going to produce noncontiguous
:>sound data.  What do we do about that?
:
:Something efficient, please.

Fab. We can insist the sound code is rewritten then. >8*)

:>1) The fetcher can shove all the sound data into one lump, using a
:>memory copy.  This requires an increase in storage space in every
:>buffer.
:
:In which buffer? Surely I get data in the same agregate size? Or are
:you saying that as well as the discontiguous layout, there's a
:contiguous lump at the end?

I'm sorry. I really don't understand that...

The idea of the buffers from our point of view is that we can just load data
straight from the file, into the buffer, and then tell you where stuff in.

Consider us playing a film, from which we want to load 128K at a time, of which
at most 32K is sound. Then we have to ask for a buffer of 160K. We load the
128K in, and bulldoze the sound into the last 32K of the buffer, and pass back
a pointer to that.

:>3) The player could do the copy and amalgamate all sound data into
:>one chunk.  This requires less memory as only two sound buffers
:>would be required, rather than a sound buffered sized piece of
:>memory in every fetcher buffer.
:
:Actually, I think it comes to the same thing - for each of the file
:IO buffers, there must exist enough extra memory to hold a contiguous
:version.

In 1), we need each FileIO buffer to be 160K. In 3) the buffers need only be
128K, and we can have 2 extra buffers of 128K that the player can use.

[Number 4 snipped]
:The sound code already copies the data (which may have vanished before the
:sound is emitted), so this might not cause any loss of performance. We'd have
:to get all the sound code updated to the new spec of Sound Give Data, though.

Yes. In the long run, this is my fave.

:>No 3 may be best for now: no rewriting of sound code, and no compromising of
:>the fetchers interface.
:
:Fine by me.

But a suboptimal solution :-(

OK. Heres where we have to make some hard decisions:

1) Recognition system

What method are we going to use for recognising films? Do we have a Replay
specific "Movie" module, or do we generalise it to a "Recogniser" module that
can also recognise MIDI files, drawfiles, spritefiles, gifs etc? This would
enable a generic Media Player application be be built.

(Of course, for now we should work on a version that does enough for Replays
purposes, but leaves the way clear for future expansion.)

2) Header information recognition

Do we:
* Stick with the current Header situation and use Image Filing Systems to get
  around it?
* Ditch Image filing systems and call the fetcher to return a header in memory?
* Use Image Filing systems just enough to point Replay at the Fetcher and get
  the header from there?

3) Why does Replay need Chunks?

In the scheme we were outlining above, chunks would be forgotten.

(When playing an AE7 file, we would of course do the fetch in chunk sized
units, so no loss there.)

When we are loading frames from an AVI film, we have no "chunk" concept to work
from, and for unindexed films have no way of knowing what size chunks we can
easily fake. Our proposal above is that we load as much as possible into each
buffer and tell player precisely how much we have managed to get.

By keying everything on time, we avoid ever having to need to refer to chunks,
while losing no functionality.

If Player needs the concept of chunks internally we can work around it, but it
won't be as nice. (We have to prescan unindexed films, and will lose some
efficiency in fetches)...

4) Sound Code

Which of the described methods for doing sound do you prefer? There are
problems with headers on sound chunks that might be a problem.

2) How do we handle time?

Please can we key each frame on the time it is to appear? Please? Currently we
have to find the GCD of interframe times for Quicktime movies, and insert lots
of blank frames...

:When shall we do it by?

ASAP. While we have been silent on this for a while, we have been talking about
it between ourselves, and we are now at the stage at which we need to find out
how much of Player can be changed, and how much we need to work around things.

Robin

P.S. I am including the original "brain dump" file below. It needs a big pinch
of salt, but some of the ideas may be interesting.

P.P.S. I can't find it. I'll forward it when I can. Sorry.
-------------------------------------------------------------------------------
In a memo regarding Olympic venues: "All venues are to be           Robin Watts
non-smoking except for venues that have smoking."

From: Paul Gardiner <paul@fsel.com>
Date: Tue, 26 Mar 1996 13:48:22 GMT
To: SWilson
CC: Robin.Watts@comlab.oxford.ac.uk

Hi,
Here's the stuff Robin wrote on the bus. Apparently, I have the only intact
copy.

Cheers,
        Paul.

-----------------------------------------------------------------------------
Fetchers

First question: Why do we need to use an Image Filing System at al? In light of
the problems encountered using ImageFS's on NFS, surely a non-image filing
system scheme would be a better bet? There therefore follow 2 separae (but
similar) proposals. Image Filing System Version

MovieFS makes a film appear as an directory containing a single file. This file
is a header file in the following style:

ARMovie
Fetcher AVI

[Previous suggestions have had MovieFS generate the full ARMovie header. This
requires MovieFS not only to be able to recognise film types, but also to parse
them enough to generate a full ARMovie header from them. This requires a bigger
MovieFS, and a duplication of at least some of the code present in the fetcher.
There is a tradeoff here - for systems such as the NC we would rather have a
big MovieFS and small memory requirements for the fetchers. For RISC OS we
would prefer a small MovieFS and bigger fetchers... A policy decision is
needed.]

The Player then looks in a repository for fetchers
(!ARMovie.MovingLine.Fetchers if we follow precedent, I guess), and loads the
named fetcher from there. This fetcher is a block of ARMcode with the following
entry points explained below:

Offset: 0       Open
                4       Init
                8       Close
                12      Fetch
Open:
On Entry:       R0=Fetcher Protocol offered by player (or 0)
                R1=Pointer to pathname or 0 to read
                R2=Pointer to table (blank)
On Exit:        R0=Fetcher Protocol offered by fetcher
                R1=filehandle
The player suggests a fetcher protocol version to the fetcher. If the
fetcher cannot accept this version number,  it declines by exiting
immediately with the next smallest number it can accept in R0.

If R0=0 on entry the fetcher returns the maximum protocol version it
can handle.
If the number suggested *is* acceptable to the fetcher, then it
examines R1. If R1=0 it exits. This provides a method for finding what
protocol versions the fetcher can accept. Otherwise, it  opens the
file pointed to by R1.

It then reads the file, and fills in the following table (subject to
change in future fetcher protocol versions):

        0       Odd Blocksize
        4       Even Blocksize
        8       Frames per keyframe (or 0 if unknown)
        12      Frames per second (FP) (or 0 if unknown)
        16      Sample Rate (FP)
        20      Sound Type (Num)
        24      Sound Type (String) (12 bytes, 0 terminated)
        36      Sound Bits
        40      OSFTERHTIHF
        ...
        n       Context table size (bytes)
FP: 16 bit fixed point (is this acceptable?)
OSFTERHTIHF: Other stuff from the existing replay header that I have forgotten.

Init:
On Entry:       R0=Pointer to context table (blank)
                R1=filehandle
                R2=Start time of film (FP)
On Exit:

The init entry point prepares a context for the fetcher. The context
contains details like the filepointer of the file in use, and all the
internal, um... context of the fetcher for that file.
This means that one player process can play n films using just one
copy of the fetcher code, with n contexts.

Close:
On Entry:       R0=Pointer to context
On Exit:

Closes film.

Fetch:
On Entry:       R0=Context table
                R1=Buffer to fill
                R2=Previous buffer
On exit:        R2=Pointer to Frame Index
                R3=Pointer to Sound Index

When called, the fetcher fills the buffer with as much sound/video
data as possible, and returns pointers to the start of the indexes for
the data.

The frame index has the form:

Offset: 0       Number of frames in index
                4       Frame 1 offset
                8       Frame 2 offset
                ...

The sound index has the form:

Offset: 0       Number of sound chunks
                4       Offset of sound chunk 1
                8       Size of sound chunk 1
                12      Offset of sound chunk 2
                16      Size of sound chunk 2
                ...
(I seem to remember Sophie objecting before at the concept of the
fetcher returning non-contiguous blocks of sound as the sound fill
code becomes less efficient, but this seems the most preferable
solution.
1) The fetcher can shove all the sound data into one lump, using a
memory copy. This requires an increase in storage space in every
buffer.
2) The fetcher deliberately loads the sound data into consecutive
locations in memory. This ruins sequential access of files, and causes
more short reads. To circumvent this loss of performance, we require
buffering; bad - not only do we get back to MovieFS's situation, we
still have to do memory copies, so no better than 1.
3) The player could do the copy and amalgamate all sound data into 1
chunk. This requires less memory as only 2 sound buffers would be
required, rather than a sound buffered sized piece of memory in every
fetcher buffer.
4) The sound code could be altered to play from small indexed buffers.
This requires more complex sound code, and a possible loss of
performance, but whether this will outweigh the loss of performance
from a memory copy is unclear.)
It is clear that when loading buffers of an arbitrary size, the end of
the buffer may well contain an incomplete section of frame or sound
data. Rather than loading this data again next time around, a pointer
the the previous buffer is passed, and a memory copy can be done. This
eliminates a potential costly reseek for unbuffered media.

Non-Image Filing System Version

Why do we need an Image Filing System? Consider a scheme whereby we
have a Movie module in memory. When this starts up, it broadcasts a
Service_MovieStarting message.

Other modules picking this up that wish to register themselves with
the Movie module as providing recognition code, should then use the
Movie_RegisterIdentifier SWI.

Alternatively, a recognition module starting up after a movie module
can issue a Movie_RegisterIdentifier SWI at start up.

The player program, when asked to play a film can then interrogate the
Movie module via a SWI to find out what fetcher to use. The Movie
module passes the film around the modules for them to examine it, and
they return a the fetcher name to use. Movie passes this back to the
application, and the rest of the system performs as before.

Thus the Movie module offers 3 SWIs as below:

Movie_RegisterIdentifier
On Entry:       R0=Pointer to identifier routine
On Exit:

Movie_DeregisterIdentifier
On Entry:       R0=Pointer to previously registered routine
On Exit:

Movie_Identify:
On Entry:       R0=RISC OS Filehandle
                R1=Length of film in bytes (-1 for unknown)
                R2=Current Filetype
On Exit:        R2=Correct Filetype (if recognised)
                R4=Pointer to fetcher name (or NULL)

The routines registered with the Movie module are called as below:

On Entry:       R0=RISC OS Filehandle
                R1=Length of film in bytes (-1 for unknown)
                R2=Current Filetype
                R7=How hard to try
On Exit:        R2=Correct Filetype (if recogised)
                R4=Pointer to "Fetcher: name" (or NULL)

The Movie module first makes a "quick" pass through the registered
routines (with R7=0). Identifiers should do quick checks at this stage
(check Filetype, check "obvious" features (like "ARMovie")). If the
filetype is incorrectly set, then the recogniser must NOT accept first
time round.

If no routine claims the movie the first time round the film can be
passed around a second time. This time more "in depth" checks of the
film can be performed (such as hunting down a potential Quicktime
films structure for known atoms). At this stage the filetype passed in
may be ignored. This means that films downloaded from external sites
can be filetyped as they arrive.

This 2 stage examination of films is important as not all
films/samples can be trivially recognised by a simple examination.
Additionally it enables a system where subtypes of a file format can
be handled differently; for instance Quicktime VR films can be handled
by a different handler than standard Quicktime films, without the
standard Quicktime film handler knowing anything about Quicktime VR
films.
This scheme gives all the functionality of the Image Filing System
scheme above, with the advanntages that:

1) It uses no hacky image filing system, so works on older machines
and on NFS.
2) It provides an extensible system - rather than a Monolithic Movie
moduel knwoing everything, components of the system can be loaded as
required. (Should we really tell Sophie this? :-) )
3) The scheme can be expanded beyond Movies to recognise other file
types such as bitmaps, vector graphics etc, and the player can respond
appropiately. (The module would return "Viewer: PDFview" for acrobat
films for instance). This gives us a coherent "MediaPlayer".

Conclusion:

I believe that this scheme offers a clean,  efficient, extensible
interface between a player application and routines to parse the file,
and further introduces a system-wide solution to the problem of the
proliferation of media standards.

Care has been taken in the design of the interface to ensure that
components are simple to implement, and that there is a clean break
between the responsibilities of processes on either side of the
interface; no work should have to be done on both sides of the
interface.

In addition the interfaces have been designed to be upgradable in a
safe way, so the system can be tweaked in future years in reponse to
our experience with it and software will contine to work.

From: Paul Gardiner <paul@fsel.com>
Date: Tue, 26 Mar 1996 13:36:49 GMT
To: SWilson
CC: Robin.Watts@comlab.oxford.ac.uk
Subject: Re: Fetchers

>From: SWilson@om.acorn.co.uk (Sophie Wilson)
>
>>Fetchers: some random comments
>>------------------------------
>>Sophie has described fetchers in a very natural way, as an alternative to the
>>catalogue: in old-style Replay the catalogue is an interpretation of the file,
>>saying where chunks are, which bits are video, which bits are audio; in
>>new-style Replay the catalogue is a reference to a piece of code that loads and
>>interprets chunks.
>
>Too true.
>
>>There are various aspects of an implementation that may need discussing, some
>>mentioned below:
>
>>* File recognition: effectively deriving the information for a Replay header.
>
>And also providing the means to start the whole system in the first place (the
>alternative being deliberately to place <ARMovie$Dir>.Player on the command
>line to kick off playing a clip and to have programs call something that tells
>them if a file can be played).
>
>>* Presenting header information to Replay.
>
>Most important.
>
>>* Replay's loading of fetchers.
>
>Must allow multiple fetchers to be used simultaneously.
>
>>* Replay's interface to fetchers.
>
>Must be simple and proof against upgrade.
>
>>It would be good if we can treat these almost completely independently.
>
>And it would also be good if we can finish all this soon (like within two
>months). Did I mention that Oracle are likely to want this technology for the
>Network Computer? (:-))

That's interesting  (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-))

>>File recognition.
>>----------------
>>We may be able to put off deciding exactly how this is to be done. We just need
>>to check that our interfaces don't rule out nice solutions to the problem.
>
>What's a playable file? How can users and programs tell? How do we provide a
>very simple interface for the very simple minded programmers?
>
>I'm biased towards sticking with the current situation - and maybe extending it
>later on.

Me too

>>Header presentation.
>>-------------------
>>The main question here seems to be between using a standardish Replay header or
>>passing values in memory (i.e., having Replay call a SWI).
>
>Well, the subsiduary question is the nature of the data in the header/dll
>fetcher. In particular Replay has notions of knowing the allocation sizes for
>practically everything after doing this.

Hmm, now you come to mention it, the main question looks pretty unimportant
compared with the subsiduary one!

>>The standardish Replay header provides a certain amount of flexibility. If
>>Replay were happy to be passed two files, one containing the data, and the
>>other containing the header, all sorts of possibilities open up. (If passed one
>>file, Replay would expect both data and header in that one file, as usual.)
>
>Yes, there would be no problem in having two files, except for reaching the
>second one (back to file recognition). If the header/dll fetcher block is
>brewed on the spot, we could put another entry in it giving the data file name
>or a file handle. There seem to be real problems passing the second file as a
>parameter on the original command line since it means the caller of the Replay
>system has to know the difference.

If we stick on one of the first three suggestions below then Replay can know
for sure where the data is, once told where the header is. (We're working on
a filing system - rather than image filing system - version of MovieFS, which
will work over NFS).

>>* MovieFS could make alien films look like directories containing a single
>>file, which provides just the header. Replay would be passed both the header
>>and the image file itself.
>
>>* MovieFS could make alien films look like directories containing two files
>>(header and data, of course). Both would be passed to Replay.
>
>>* MovieFS could make alien films look like directories containing a single
>>header-and-data file. That one file would be passed to Replay.
>
>>* An application could generate headers for alien films, on demand, and place
>>them in a scrap directory. Both the alien film and the header would be passed
>>to Replay. (Works across NFS, of course).
>
>>* A film for which a header had previously been generated could be stored in an
>>ordinary directory with its header. Blah blah blah.
>
>>* A CD full of alien films could be supplied with a floppy full of headers.
>
>Alternatively the header could permute into the data file by silly pointer
>addresses. You're bound to have the header at offset 0, though.

Lost me there.

>>The passing of values by Replay calling a SWI provides a much cleaner overall
>>system (no need for messy image filing systems at all), but it does rather tie
>>Replay to the recognition code (Replay can't call the SWI if the recognition
>>module isn't loaded). A way out of that one is to consider the recognition
>>module to be part of Replay, but that would mean us having to design an
>>extensible recogniser module before there could be a fetcher-using release of
>>Replay.
>
>This is definitely a nasty area. I would prefer to stick to a system where the
>header triggers off the new activities, but this could included a combination
>approach where there's nothing in the header except the hint to call the new
>facility.
>
>Actually, I'd prefer to stick to the current header...

Me too

>>Replay's loading of fetchers.
>>----------------------------
>>There was a worry here that if fetchers were loaded in the same way as
>>decompressors then there would be no easy way to write them in C. That worry
>>seems to be unfounded: ARM coders can write nice lean fast fetchers, whereas C
>>coders can write a little ARM-code veneer that redirects to a module.
>
>We could make the interface between Replay and the fetcher much more like the C
>calling sequence than the decompressor one was (mainly because the fetcher
>doesn't need to be called in interrupt mode with IRQs enabled!) and (novelty)
>use r14 for the return value, r0-r3 for parameters! However there are
>inevitable problems with run time libraries. I don't mind calling an Initialise
>Fetcher routine first, though.

The veneer redirecting to a module allows for the use of run time libraries.

>The system must allow multiple fetchers to be used simultaneously, both of
>different types and of the same type.

No probs.

>>Replay's interface to fetchers.
>>------------------------------
>>We could start with the simplest interface that has any chance at all of
>>working, and then add features as required until we get something workable.
>
>>First attempt:
>>Assuming Replay has already obtained the information from reading the header or
>>calling the recognition SWI.
>
>>Three entry points: Open, Fetch, Close.
>
>>Open:
>>On Entry: R0=file handle
>>On Exit:  ---
>
>>Does what ever it needs to in readiness for calls to Fetch. It might have to
>>allocate some memory. It might even have to load a module! Is this okay? If not
>>fetcher writing will be a lot harder and slower.
>
>Yes, this is OK provided that the module can retain state for several open
>files simultaneously (WIMP definition of simultaneity).

Yes.

>>Fetch:
>>On Entry: R0=address of buffer
>>          R1=size of buffer
>>On Exit:  R0=Pointer to Frame Index
>>          R1=Pointer to Sound Index
>
>>Fills the buffer and returns a description of the information it has loaded
>>(positions of frames and chunks of sound).
>
>Fills the buffer? Or provides at most one chunks worth of frames? Which chunk
>number into the file are we? You can't simply give successive chunks since the
>combination of -playfor and -loop could have it start back at the beginning
>again. (see below for -startat)

Here we're getting to the sticky bit.  The trouble with AVIs and Quicktimes
is that they don't hold their data in large chunks.  Typical layout of an AVI
(although there are many others) is

SSSSSSSSFSFSFSFSFSFSFSFSFSFSFSFSFSFFFFFFFF

where F is frame and S is sound for a period of the same length as F.

This is a real pain when you want to generate Replay chunks; that's what the
current MovieFS needs its big buffers for.  I was hoping we could fetch a
buffer full and tell Replay where the bits are, but if we do that I can
guarantee the number of frames will vary between fetches and that the sound
and video data will be skewed.  Worse, some AVIs don't have indexes, so the
fetcher doesn't know where the bits are until it reads them.

>>The frame index has the form:
>
>>Offset: 0  Number of frames in index
>>        4  Frame 1 start
>>        8  Size of Frame 1???
>>        12 Frame 2 start
>>        16 Size of Frame 2 ???
>>        ...
>
>When playing the file, Replay cares little about these indexes, though it could
>be modified to use them. It cares even less about compressed frame sizes and
>has no particular way of using the information.

But the frames won't be consecutive in the buffer, so I think the indexes
will be needed.  Gladly drop the size, though.
(Although, see revolting idea at end of message.)

>>The sound index has the form:
>
>>Offset: 0  Number of sound chunks
>>        4  Start of sound chunk 1
>>        8  Size of sound chunk 1
>>        12 Start of sound chunk 2
>>        16 Size of sound chunk 2
>>        ...
>
>Yeesh. Very real problems with bull-dozing all the data together.

One argument for Replay doing the bull-dozing is that the code has to be
written only once, not once per fetcher. (Hidden agenda: you'd do it,
and we wouldn't have to (:-)) ).

>>Close:
>>On Entry: ---
>>On Exit:  ---
>
>>Shuts down fetcher.
>
>Super.
>
>>---------------------------------------------------------------------------
>>Potential problems.
>
>>* Films need to be played from arbitrary start positions. A fourth fetcher
>>entry point could be added to support this.
>
>Replay has its own ideas on this: it really needs to know the closest chunk or
>have a lobotomy. There's no time problem about decompressing from the start of
>the closest chunk until the required frame is reached and this procedure does
>ensure sound/video sync.

But there are no chunks really, that's what bothers me.  I don't really know
what to do about this one.

>>SetTime:
>>On Entry: R0=time (16bit.16bit)
>>On Exit:  ---
>
>Why not the value given to -startat?

Yes. much better

>>The specified time may not correspond to a key frame, in which case perhaps the
>>fetcher should set to the latest earlier time that does correspond to a key
>>frame, returning that time in R0; Replay can then play silently and invisibly
>>for the difference of the times. Should a fetcher be free always to do this, or
>>should Replay pass a flag to the Open entry point or to SetTime, saying whether
>>to do it or not? Should there be a limit on how far back in time to look.
>
>What will this do to the chunk structure of the file?????

Again, blah blah etc.  I don't know.

>>Perhaps:
>
>>SetTime:
>>On Entry: R0=requested time (16bit.16bit)
>>          R1=allowed drift
>>On Exit:  R0=actual time set
>
>>Then <allowed drift> = 0 implies <actual time set> = <requested time>
>
>>* The frame index returned by Fetch has frame sizes so that editing programs
>>can copy frames from place to place. Since thinking of this, we've realised
>>that there are occasions when it is useful for frames to include indirected
>>data; editing programs wouldn't be able to copy such frames without
>>understanding their structure. Can we get away without frame sizes? Should we
>>have another entry point (called Flatten say), which moves data about so as to
>>remove indirections? This would have a time overhead but would be used only by
>>editing suites. Can we ignore this for now?
>
>Yes. Its not part of our remit to design the world's best compressed file
>editting application!

Good.  Suits me.

>>* Frame positions and sizes are difficult to derive for the native
>>Replay-format fetcher.
>
>Nay, impossible! They can only be discovered by decompressing the file...

Do we need to special case this one then (unless we go for the revolting idea
at the end of this message)?

>>* The frames-per-chunk field of the replay header cannot be given a definitive
>>value in the fetchers universe. What's the minimum amount of information that
>>Replay could work with?
>
>Either a definitive value or Robin is going to have to recode Player for me!
>
>Frames per chunk does allow simple computations to be made on latency for the
>wimp and worst case computations on device bandwidth/buffer size. It never
>trips over itself if it gets anomalously big/small numbers of frames into
>memory (since it can't).

Hmm, that's a shame; we could really do with some flexibility there.
The only alternative seems to be to have the fetcher doing a lot of
copying from the last buffer to the new one - in the case of index-less
formats like FLI, an enormous amount of copying.  Also we will have
to ask replay to allocate buffers far larger than really needed just
to be completely sure we load at least as many frames as we promised
on each fetch.  If we load too many frames, we just don't tell Replay they're
there.  If we load too few, we've had it: there's nothing we can do.

>>* A fetcher can't necessarily know where frames are going to be, before filling
>>a buffer. So a fetcher can't avoid pulling in the odd half frame at the end of
>>a buffer. When a fetcher does pick up half a frame it can just not bother to
>>inform Replay that its there, and then on the next fetch, copy the half frame
>>to the beginning of the new buffer (to avoid rereading it). For this to work it
>>is important that, when calling Fetch, Replay ensures no corruption to the last
>>buffer (outside of the areas refered to by the indexes). Is it always
>>reasonable for Replay to guarantee this, or should Replay pass a flag to Fetch
>>saying whether the last buffer is okay?
>
>I think its possible to guarantee this. Unless something nasty happens in
>amalgamating the sound data.

Good, good.

>>* Currently we have MovieFS sending palettes to our decompressors by gluing
>>them on the front of frames. Doing this in a fetcher requires the moving of
>>just small amounts of data, providing were wishing only to do it to the first
>>frame in each buffer (as we do now). Gluing palettes on the beginning of frames
>>close to the middle of a buffer requires a large movement of memory.
>>Introducing data structures with indirection gets around this problem, but
>>makes the frame sizes a little meaningless, as mentioned above.
>
>I think the frame sizes are meaningless - we are really only trying to play
>files, not become the Adobe Premiere of the western world.

Great, that's the answer I hoped for.

>>* We also send information to our sound-playing code by gluing it on the front
>>of the sound chunk. This doesn't look to be a problem really: we can just
>>ensure there's sufficient room in the buffer to place a copy of the header and
>>then return it as the first entry in the sound index.
>
>Yes.

That was bound to be okay really, because its transparent to Replay.  I think
Robin told me he'd flagged a problem here, but we're now happy things are okay.

>>* Because of the varying structure of alien-film formats, it is likely that the
>>first call to Fetch will provide Replay with different amounts of audio and
>>video data (in terms of playing time), and that some skewing of the data will
>>persist throughout playback.
>
>Chunk sizes? File IO sizes? Will it maintain sync and speed without placing
>greater requirements on the hardware (e.g. CD ROM drives are notoriously slow
>at silly accesses).

Lost me again here.  This sounds like an important point, but I don't
immediately understand what you're saying.

>>* The latest Replay can play multiple films simultaneously. To play two films
>>of different types, clearly Replay needs to load two fetchers. If playing two
>
>yes
>
>>films of the same type, Replay could load two copies of the one required
>>fetcher, and have each copy know which film it was dealing with. It could
>
>which is fine as far as I'm concerned
>
>>alternatively use a single fetcher, but some enrichment of the fetcher
>>interface would be required (i.e. 'Open' could return a 'fetching handle' that
>>must be passed back on calls to the other entry points).
>
>also fine

I think I prefer the first option for its simplicity, both in the fetchers
and in Replay (less special cases), but it could be wasteful of memory for
large ARM coded fetchers. (Perhaps all the ARM coded ones will be nice and
small anyway.

>>* Version control: we will not get these interfaces right first time, and in
>>six months time will want to change things. How do we ensure that we don't have
>>Replay talking one language to a fetcher that speaks another? How do we, in the
>
>by never doing it!
>
>>future, write fetchers that work with all previous fetcher versions of Replay?
>
>by upgrading in lock step. It is permissable to change things en-masse if
>needed (e.g. the colour space mapping programs and Replay have the same
>incestuous relationship).
>
>>How does Sophie (if she wishes) write a Replay that can use any version of a
>>fetcher? We can't just put this off until it bites us - or can we? All we need
>
>Yes.
>
>>do is change the naming convention for the fetcher-code files on each revision:
>>Fetch, Fetchv2, Fetchv3, ... A developer of fetchers can then supply them all
>>if need be, and the particular version of Replay in use can pick the latest it
>>understands.
>
>If you insist. I still think you're making a mountain out of a molehill.

No insistence.  Glad to forget all that, for now at least.

>>* Fetches from alien film files are going to produce noncontiguous sound data.
>>What do we do about that?
>
>Something efficient, please.
>
>>1) The fetcher can shove all the sound data into one lump, using a memory copy.
>>This requires an increase in storage space in every buffer.
>
>In which buffer? Surely I get data in the same agregate size? Or are you saying
>that as well as the discontiguous layout, there's a contiguous lump at the end?
>
>>2) The fetcher deliberately loads the sound data into consecutive locations in
>>memory. This ruins sequential access of files, and causes more short reads. To
>>circumvent this loss of performance, we require buffering; bad - not only do we
>>get back to MovieFS's situation, we still have to do memory copies, so no
>>better than 1.
>
>Yes, no better.
>
>>3) The player could do the copy and amalgamate all sound data into one chunk.
>>This requires less memory as only two sound buffers would be required, rather
>>than a sound buffered sized piece of memory in every fetcher buffer.
>
>Actually, I think it comes to the same thing - for each of the file IO buffers,
>there must exist enough extra memory to hold a contiguous version.
>
>>4) The sound code could be altered to play from small indexed buffers. This
>>requires more complex sound code, and a possible loss of performance, but
>>whether this will outweigh the loss of performance from a memory copy is
>>unclear.
>
>The sound code already copies the data (which may have vanished before the
>sound is emitted), so this might not cause any loss of performance. We'd have
>to get all the sound code updated to the new spec of Sound Give Data, though.
>
>>No 3 may be best for now: no rewriting of sound code, and no compromising of
>>the fetchers interface.
>
>Fine by me.

Good.

>When shall we do it by?

Within the next two months seems perfectly reasonable for our part of this.

>--Sophie


Revolting idea: Fetchers faking true Replay chunks.
---------------------------------------------------

This is only worth considering if you really really really can't drop the
restriction of having a constant number of frames per fetch.

We make a small change to all our decompressors so that, rather than expecting
a list of compressed frames, they expect a list of frame-data start addresses.
Given such a list Rerplay can point the decompressor at the start and just
call the frame entry point N times.

We tell Replay, in the header, to allocate buffers of length
  4 * <frames per chunk> + <sound samples per chunk> + XXX

i.e.  <Indirected frames> <Sound> <Part of file>

XXX being the smallest size such that all parts of the file of that size
contain at least <frames per chunk frames>, and such that some other audio
constraint holds. (The big weakness here is that some formats make XXX
impossible to establish without pre-reading the whole file.

Anyway -
A fetch will fill up the XXX part of the buffer then fill in the addresses
of the frames in the first part of the buffer and bull-doze the sound into
the <sound> section.  As far as Replay is concerned it has been given a
standard Replay chunk.  The frames look a bit small (four bytes each) but
Replay doesn't care so long as the decompressors are happy.


The only nice thing about this is that it requires little change to Replay.

The bad things are many
  We can't always calculate XXX, so sometimes we will be forced to make it
  ten times bigger than necessary.

  Sound bull-dozing will have to be done from both the current buffer
  being filled, and the last.

  When the buffers are larger than necessary, large amounts of data will
  have to copied by the fetcher from one buffer to the next.  Worse cases
  are likely to be far worse than current MovieFS overheads.

Paul.
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Tue,26 Mar 1996 17:19:08 mail was sent to paul@fsel.com,Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
Its mega reply time - you and Paul are exceeding my answer rate!

]From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
]Subject: Re: Fetchers
]To: SWilson (Sophie Wilson)
]Date: Mon, 25 Mar 1996 17:08:43 +0000 (GMT)

]Hi,

]Perhaps I ought to say a bit about the file you just got...

]After I last spoke to you about Fetchers, I went away for the weekend, and
]spent 4 hours sat on a coach. In that time I "brain dumped" into my Psion about
]how fetchers should work. When I got back, I presented Paul with this file, and
]he worked his way through it, finding problems and alternatives, and discussing
]them with me.

]The file you have just replied to was Pauls rewrite of my file. This was
]written to try and raise all the possible questions we could think of and to
]suggest some answers to them.

]My original file was much more aimed at setting out a single solution to
]everything.

]While Pauls was was a very good document, I do feel it didn't make one or two
]points as strongly as I would have liked them to be made. (This is not in any
]way to be an attack on Pauls file, just an explaination of why you might detect
]a slight shift in emphasis when I talk about it...)

]:>* File recognition: effectively deriving the information for a Replay header.
]:
]:And also providing the means to start the whole system in the first place (the
]:alternative being deliberately to place <ARMovie$Dir>.Player on the command
]:line to kick off playing a clip and to have programs call something that tells
]:them if a file can be played).

]I described a fairly detailed idea for what started as a recognition module for
]Replay. Basically, you have a central "Movie" module in memory that can be
]called to identify a film. Other new modules can register recognition routines
]with this. When the Movie module asks for a film to be recognised, it passes it
]around its registered children to see if they can recognise it from its
]structure.

]In my original, suggestion this module was going to be rolled into the central
]Replay system as described below. Paul very correctly pointed out that this
]could be made a separate entity and could be considered separately. Hence the
]fact it was treated individually above.

]------

]In my original scheme, Player would call the Movie Module, and the Movie module
]would return "Fetcher: AVI" (say). Player could then load the fetcher, and call
]that to get the header information. I like this idea for several reasons:

]1) We no longer have any Image Filing system stuff, so it works on NFS, and
]gives a clean interface.

Yes, this is a big bonus - I am keen on things that work on NFS.

]2) The recognition module has no need to know how to extract the header info,
]so stays small.

]Paul however likes Image Filing systems and the existing ARMovie Header idea.
]We all need to discuss this. I suspect you will have strong opinions on this.

]--------

Not particularly strong, but I am worried about how the system gets called and
how it all works. The idea of two files doesn't worry me (the second one being
an ARMovie typed Header file containg enough to fake existing applications)
except for the matter of it being real or an image file and the whole thing
working on NFS.

]:>* Replay's loading of fetchers.
]:
]:Must allow multiple fetchers to be used simultaneously.

]Yes. My original scheme was very careful to allow a single fetcher loaded into
]memory to be run in multiple threads at once, using a "context handle". Paul
]didn't like this for various reasons, but I remain unconvinced.

Still OK to have multiple movies load multiple copies of the same fetcher if
required. It does make multiple instantiation and variable access much easier
to think about.

]:Must be simple and proof against upgrade.

]Yup. I described a whole protocol for this down to the register level, but Paul
]correctly identified that as Implementation detail.

]His alternative suggestion of having multiple versions of fetchers stored on
]disc has the advantage that on average fetchers are smaller, but has various
]disadvatages too.

Clearly there is always a trade off between small and simple and larger and
multifunction. I tend to go for small and simple with multiple instantiation
since I fundamentally believe that the only run size that matters is a single
task to run just one thing.

]:And it would also be good if we can finish all this soon (like within two
]:months). Did I mention that Oracle are likely to want this technology for the
]:Network Computer? (:-))

]We are very keen to get this done asap if it means an NC tie in :-)

Sooner, then. Yes, it is looking likely that Oracle will want Replay on the
NC to play AVI and QT files, but its not even beyond a few words in a VP's
email yet!

]:What's a playable file? How can users and programs tell? How do we provide a
]:very simple interface for the very simple minded programmers?

]The recognition module seems a good solution.

OK by me. Provided it is extensible. And provided that there is some
compatability path for old clients of Replay. I really don't expect Genesis,
Magpie etc to get rewritten! On the NC applications will be written anew
so this isn't as much of a problem.

]:I'm biased towards sticking with the current situation - and maybe
]:extending it later on.

]I can see that. How much of this can be done piecemeal without sacrificing
]efficiency is unclear to me.

In the end, I'm only worried about static memory efficiency of the system
when its not doing anything and dynamic processor usage when its playing
a file.

]:Well, the subsiduary question is the nature of the data in the header/dll
]:fetcher. In particular Replay has notions of knowing the allocation sizes for
]:practically everything after doing this.

]Yes. My original thought of presenting data to Replay in 2 stages was for
]exactly this reason.

]First, the Player calls some routine (in my case the Movie module) to find out
]what fetcher to use.

But how did it get to Player in the first place? If via an AE7 filetype, then
this implies a false header file approach. If via an FB2 filetype, then what
do other applications do (you're heading for a rewrite...)

]Second, the Player loads the fetcher, and that then presents all the data that
]was there before (except the stuff I will describe below).

Fine.

]I like this 2 stage way of working as it means we have less in memory at a time
]- the central Movie module needs only to be able to recognise files (For AE7s,
]it looks for "ARMovie", for AVIs it looks for "RIFF" then "AVIList" etc) rather
]than to extract the whole header data.

Its other programs recognising these files that I care about!

]The only thing that needs to be allocated before the header stuff is known is
]then the memory to hold the fetcher. This is an unavoidable overhead anyway, so
]shouldn't be a problem.

And it can be efficient by yet another ARMovie$Cache set of information.

]:Yes, there would be no problem in having two files, except for reaching the
]:second one (back to file recognition). If the header/dll fetcher block is
]:brewed on the spot, we could put another entry in it giving the data file name
]:or a file handle. There seem to be real problems passing the second file as a
]:parameter on the original command line since it means the caller of the Replay
]:system has to know the difference.

]Yes. If we go with the Image Filing system version, then just having 1 file
]seems the right thing to do to me (The consequences of pairs of files being
]separated is something I don't want to think about).

True. References to files are great things for computer scientists and absolute
disasters to everyone else!

]If we ditch Image filing systems and make the header be presented to Replay by
]calling the fetcher, the problem goes away.

But we get back to the compatability issue.

]:Alternatively the header could permute into the data file by silly pointer
]:addresses. You're bound to have the header at offset 0, though.

]True. But this means all the problems with Image Filing systems across NFS. We
]have a way around this using redirection files on a local filing system, but
]its not nice (IMHO). Particularly, when do you know it is safe to delete the
]redirection file?

]:This is definitely a nasty area. I would prefer to stick to a system where the
]:header triggers off the new activities, but this could included a combination
]:approach where there's nothing in the header except the hint to call the new
]:facility.
]:
]:Actually, I'd prefer to stick to the current header...

]We thought that would be your answer :-)

Actually I'm easier than that. I want to stick to as much current code as
possible unless someone else is going to do the rewrite(s). Player itself is
a bounded problem - the real issue is all those other people who read headers!
(of course, the bounded nature of the problem doesn't mean I have time to do
a great deal about it myself...)

]:We could make the interface between Replay and the fetcher much more
]:like the C calling sequence than the decompressor one was (mainly
]:because the fetcher doesn't need to be called in interrupt mode with
]:IRQs enabled!) and (novelty) use r14 for the return value, r0-r3 for
]:parameters! However there are inevitable problems with run time
]:libraries. I don't mind calling an Initialise Fetcher routine first,
]:though.

]Yes.

]:The system must allow multiple fetchers to be used simultaneously, both of
]:different types and of the same type.

]Yes. Does it need to allow the same fetcher to be used in 2 threads? This is
]good for memory use...

But only a tiny tweak on the memory used by two movies playing simultaneously.

]:Yes, this is OK provided that the module can retain state for several open
]:files simultaneously (WIMP definition of simultaneity).

]Yes. My original scheme included a new header field that gave a size for a
]"context" buffer. This buffer would be allocated by the player and passed in to
]every Fetcher entry point. The fetcher would store all its state in this
]buffer.

]Paul wasn't so keen on this (partly cos it makes writing stuff in C harder I
]suspect).

]My original thought was that this way Player would have total control over the
]memory allocation, but Paul has since convinced me that this is less important.

]:Fills the buffer? Or provides at most one chunks worth of frames? Which chunk
]:number into the file are we? You can't simply give successive chunks since the
]:combination of -playfor and -loop could have it start back at the beginning
]:again. (see below for -startat)

]Fills the buffer. This is something we really need to get straight. See below.

Player rewrite time again. Again, I won't have the time to do this, but I'm
happy for you to do so.

]:When playing the file, Replay cares little about these indexes,
]:though it could be modified to use them. It cares even less about
]:compressed frame sizes and has no particular way of using the
]:information.

]OK. The point is this:

]When playing AE7 files, you are guaranteed that one frame follows the next
]exactly. When playing other files, this is NOT true. By providing indexes into
]the file there is no problem here.

]We obviously need to be able to say both of the following things:

]"The first frame is here, and others are consecutive"
]"This is an index as to where you can find frame data"

]We appreciate that the frame size data is not important for the player but we
]wondered if it would be nice to have. There are compelling reasons for dumping
]it for now.

OK - indexes alone. This isn't a large rewrite and is hidden deep in Player
(even hidden from the rest of Player).

]:Yeesh. Very real problems with bull-dozing all the data together.

]Problems yes. Unfortunately unavoidable ones. Either the fetcher needs to
]bulldoze it, or the sound stuff does. We have outlined alternatives below.

]:>Close:
]:>On Entry: ---
]:>On Exit:  ---
]:
]:>Shuts down fetcher.
]:
]:Super.

]Wow, an uncontested one :-)

Open, use, close is a familiar model.

]:>* Films need to be played from arbitrary start positions. A fourth fetcher
]:>entry point could be added to support this.
]:
]:Replay has its own ideas on this: it really needs to know the closest chunk or
]:have a lobotomy. There's no time problem about decompressing from the start of
]:the closest chunk until the required frame is reached and this procedure does
]:ensure sound/video sync.

]OK. You are assuming several things here:

]1) We still run in chunks
]2) We have a keyframe every chunk.

]Neither of these may be true.

]I will describe a better system later.

...and you get to do the lobotomy

]:Why not the value given to -startat?

]Don't know the exact format of this off the top of my head, and its miles to
]the nearest docs.

]Basically, the time should be specified in time, not in frames. This is cos
]some film types have different spacings between frames according to whats
]happening.

-startat is specified in time. Centiseconds, to be precise.

]:What will this do to the chunk structure of the file?????

]You are assuming chunks again.

Indeed I am. I've had a lot of experience playing data efficiently off slow
CDROMs and chunks are one of the things that makes it possible. Replay can (and
does) play off slower CDROMs than QT and AVI - single speed drives are actually
useable - and as a consequence we have a large number of slow drives in the
market.

]:Yes. Its not part of our remit to design the world's best compressed file
]:editting application!

]I agree (but if we can get it for free, then leaving hooks such that films
]*can* be edited is a bonus).

Sure.

]:Nay, impossible! They can only be discovered by decompressing the file...

]Thus they are possible to discover. Just very hard. While this is not feasible
]at Runtime, it may be possible to offer another "flatten" entry point. that
]would do the job.

And, to be pernickity, its still impossible - the decompressors have to round
to byte sizes at the very least. (MovingBlocks outputs a bitstream which is
rounded) So you never get to know the compressed size.

]:>* The frames-per-chunk field of the replay header cannot be given a
]:>definitive value in the fetchers universe. What's the minimum amount
]:>of information that Replay could work with?
]:
]:Either a definitive value or Robin is going to have to recode Player for me!

]Ah. Rats. Time to dust MoviePlay off then :-)

]We really need to talk about this.

Sure. But I really do have limited time to code. I'm happy for Robin to code
the changes on behalf of Acorn, but Acorn would want complete rights to the
code to remain with them.

]:Frames per chunk does allow simple computations to be made on latency for the
]:wimp and worst case computations on device bandwidth/buffer size. It never
]:trips over itself if it gets anomalously big/small numbers of frames into
]:memory (since it can't).

]Can't we provide a "guide" figure but feel free to squeeze more in if we can
]manage it?

Its the squeezing in less that's the real problem (though squeezing in more may
also be a mistake if a file serving device (NFS, CDROM) is trying to stream
data efficiently).

]:I think its possible to guarantee this. Unless something nasty happens in
]:amalgamating the sound data.

]IMAO Amalgamating the sound data is the wrong way to go. Changing the sound
]playback routines to play it back from an indexed chunk is better.

OK. I think a rewrite of all sound routines and their callers is feasible.
Note that I might be wrong about this and we'd have to provide backwards
compatability.

]:I think the frame sizes are meaningless - we are really only trying to play
]:files, not become the Adobe Premiere of the western world.

]Sure.

]:>* We also send information to our sound-playing code by gluing it on
]:>the front of the sound chunk. This doesn't look to be a problem
]:>really: we can just ensure there's sufficient room in the buffer to
]:>place a copy of the header and then return it as the first entry in
]:>the sound index.
]:
]:Yes.

]But this *is* a big problem if you are going to insist on use bulldozing the
]sound.

So rewrite. I'm sure we can find an infinite number of monkeys somewhere.

]:>* Because of the varying structure of alien-film formats, it is
]:>likely that the first call to Fetch will provide Replay with
]:>different amounts of audio and video data (in terms of playing
]:>time), and that some skewing of the data will persist throughout
]:>playback.
]:
]:Chunk sizes? File IO sizes? Will it maintain sync and speed without placing
]:greater requirements on the hardware (e.g. CD ROM drives are notoriously slow
]:at silly accesses).

]You're assuming chunks again. Part of the point of ditching Chunks is to ensure
]that we *can* get good access to the hardware.

So why don't QT and AVI do as well as Replay? They flash the access light like
crazy and need high speed access drives with caches.

]:>films of the same type, Replay could load two copies of the one required
]:>fetcher, and have each copy know which film it was dealing with. It could
]:
]:which is fine as far as I'm concerned

]But on low memory devices such as the NC, this is an undesirable overhead.

and is unlikely to end up playing multiple files unless it has enough memory.
(or, is likely to play two files of different types (e.g. WAV and FLI))

]:>alternatively use a single fetcher, but some enrichment of the
]:>fetcher interface would be required (i.e. 'Open' could return a
]:>'fetching handle' that must be passed back on calls to the other
]:>entry points).
]:
]:also fine

]But much nicer...

]:by upgrading in lock step. It is permissable to change things en-masse if
]:needed (e.g. the colour space mapping programs and Replay have the same
]:incestuous relationship).

]But other programs that call the fetchers (like Editing suites) must have some
]way of knowing what they are talking to.

]:>* Fetches from alien film files are going to produce noncontiguous
]:>sound data.  What do we do about that?
]:
]:Something efficient, please.

]Fab. We can insist the sound code is rewritten then. >8*)

Yes, but guess who gets to recoder Player and write the new documentation
(and, just maybe, rewrite Acorn's source and interface with third parties).

Nothing's for free!

]:>1) The fetcher can shove all the sound data into one lump, using a
]:>memory copy.  This requires an increase in storage space in every
]:>buffer.
]:
]:In which buffer? Surely I get data in the same agregate size? Or are
]:you saying that as well as the discontiguous layout, there's a
]:contiguous lump at the end?

]I'm sorry. I really don't understand that...

]The idea of the buffers from our point of view is that we can just load data
]straight from the file, into the buffer, and then tell you where stuff in.

]Consider us playing a film, from which we want to load 128K at a time, of which
]at most 32K is sound. Then we have to ask for a buffer of 160K. We load the
]128K in, and bulldoze the sound into the last 32K of the buffer, and pass back
]a pointer to that.

]:>3) The player could do the copy and amalgamate all sound data into
]:>one chunk.  This requires less memory as only two sound buffers
]:>would be required, rather than a sound buffered sized piece of
]:>memory in every fetcher buffer.
]:
]:Actually, I think it comes to the same thing - for each of the file
]:IO buffers, there must exist enough extra memory to hold a contiguous
]:version.

]In 1), we need each FileIO buffer to be 160K. In 3) the buffers need only be
]128K, and we can have 2 extra buffers of 128K that the player can use.

][Number 4 snipped]
]:The sound code already copies the data (which may have vanished before the
]:sound is emitted), so this might not cause any loss of performance. We'd have
]:to get all the sound code updated to the new spec of Sound Give Data, though.

]Yes. In the long run, this is my fave.

]:>No 3 may be best for now: no rewriting of sound code, and no compromising of
]:>the fetchers interface.
]:
]:Fine by me.

]But a suboptimal solution :-(

]OK. Heres where we have to make some hard decisions:

]1) Recognition system

]What method are we going to use for recognising films? Do we have a Replay
]specific "Movie" module, or do we generalise it to a "Recogniser" module that
]can also recognise MIDI files, drawfiles, spritefiles, gifs etc? This would
]enable a generic Media Player application be be built.

I'd keep it movie specific. It would be a mistake to get too involved with
other types of data.

How do we rewrite the old apps??????????????????

](Of course, for now we should work on a version that does enough for Replays
]purposes, but leaves the way clear for future expansion.)

]2) Header information recognition

]Do we:
]* Stick with the current Header situation and use Image Filing Systems to get
]  around it?
]* Ditch Image filing systems and call the fetcher to return a header in memory?
]* Use Image Filing systems just enough to point Replay at the Fetcher and get
]  the header from there?

Don't know. We do need to work on NFS...

]3) Why does Replay need Chunks?

So that file IO gets really streamlined. Player ends up doing sector aligned
transfers of integral numbers of sectors and is able to issue the next request
without any other processing being done (i.e. before the rotational action of
the device has moved away from the next sector).

]In the scheme we were outlining above, chunks would be forgotten.

](When playing an AE7 file, we would of course do the fetch in chunk sized
]units, so no loss there.)

]When we are loading frames from an AVI film, we have no "chunk" concept to work
]from, and for unindexed films have no way of knowing what size chunks we can
]easily fake. Our proposal above is that we load as much as possible into each
]buffer and tell player precisely how much we have managed to get.

]By keying everything on time, we avoid ever having to need to refer to chunks,
]while losing no functionality.

]If Player needs the concept of chunks internally we can work around it, but it
]won't be as nice. (We have to prescan unindexed films, and will lose some
]efficiency in fetches)...

]4) Sound Code

]Which of the described methods for doing sound do you prefer? There are
]problems with headers on sound chunks that might be a problem.

Mildly prefer a rewrite, but would understand why people don't want to do it.

]2) How do we handle time?

]Please can we key each frame on the time it is to appear? Please? Currently we
]have to find the GCD of interframe times for Quicktime movies, and insert lots
]of blank frames...

Its Robin rewrite time!

]:When shall we do it by?

]ASAP. While we have been silent on this for a while, we have been talking about
]it between ourselves, and we are now at the stage at which we need to find out
]how much of Player can be changed, and how much we need to work around things.

It can all be changed. And the clock's ticking.

]Robin

]From: Paul Gardiner <paul@fsel.com>
]Date: Tue, 26 Mar 1996 13:48:22 GMT
]To: SWilson
]CC: Robin.Watts@comlab.oxford.ac.uk

]Hi,
]Here's the stuff Robin wrote on the bus. Apparently, I have the only intact
]copy.

]Cheers,
]        Paul.

]-----------------------------------------------------------------------------
]Fetchers

]First question: Why do we need to use an Image Filing System at al? In light of
]the problems encountered using ImageFS's on NFS, surely a non-image filing
]system scheme would be a better bet? There therefore follow 2 separae (but
]similar) proposals. Image Filing System Version

]MovieFS makes a film appear as an directory containing a single file. This file
]is a header file in the following style:

]ARMovie
]Fetcher AVI

][Previous suggestions have had MovieFS generate the full ARMovie header. This
]requires MovieFS not only to be able to recognise film types, but also to parse
]them enough to generate a full ARMovie header from them. This requires a bigger
]MovieFS, and a duplication of at least some of the code present in the fetcher.
]There is a tradeoff here - for systems such as the NC we would rather have a
]big MovieFS and small memory requirements for the fetchers. For RISC OS we
]would prefer a small MovieFS and bigger fetchers... A policy decision is
]needed.]

]The Player then looks in a repository for fetchers
](!ARMovie.MovingLine.Fetchers if we follow precedent, I guess), and loads the

Yes. I try to keep !ARMovie as empty as possible. Fetchers could (and maybe
should) be named rather than numbered like the decompressors (we could also
start naming decompressors in a new world).

]named fetcher from there. This fetcher is a block of ARMcode with the following
]entry points explained below:

]Offset: 0       Open
]                4       Init
]                8       Close
]                12      Fetch
]Open:
]On Entry:       R0=Fetcher Protocol offered by player (or 0)
]                R1=Pointer to pathname or 0 to read
]                R2=Pointer to table (blank)
]On Exit:        R0=Fetcher Protocol offered by fetcher
]                R1=filehandle
]The player suggests a fetcher protocol version to the fetcher. If the
]fetcher cannot accept this version number,  it declines by exiting
]immediately with the next smallest number it can accept in R0.

I think the time should be in here somewhere/how. Player reads consecutive
frames until it loops back to the start. But editors don't.

]If R0=0 on entry the fetcher returns the maximum protocol version it
]can handle.
]If the number suggested *is* acceptable to the fetcher, then it
]examines R1. If R1=0 it exits. This provides a method for finding what
]protocol versions the fetcher can accept. Otherwise, it  opens the
]file pointed to by R1.

]It then reads the file, and fills in the following table (subject to
]change in future fetcher protocol versions):

]        0       Odd Blocksize
]        4       Even Blocksize
]        8       Frames per keyframe (or 0 if unknown)
]        12      Frames per second (FP) (or 0 if unknown)
]        16      Sample Rate (FP)
]        20      Sound Type (Num)
]        24      Sound Type (String) (12 bytes, 0 terminated)
]        36      Sound Bits
]        40      OSFTERHTIHF
]        ...
]        n       Context table size (bytes)
]FP: 16 bit fixed point (is this acceptable?)
]OSFTERHTIHF: Other stuff from the existing replay header that I have forgotten.

]Init:
]On Entry:       R0=Pointer to context table (blank)
]                R1=filehandle
]                R2=Start time of film (FP)
]On Exit:

]The init entry point prepares a context for the fetcher. The context
]contains details like the filepointer of the file in use, and all the
]internal, um... context of the fetcher for that file.
]This means that one player process can play n films using just one
]copy of the fetcher code, with n contexts.

]Close:
]On Entry:       R0=Pointer to context
]On Exit:

]Closes film.

]Fetch:
]On Entry:       R0=Context table
]                R1=Buffer to fill
]                R2=Previous buffer
]On exit:        R2=Pointer to Frame Index
]                R3=Pointer to Sound Index

]When called, the fetcher fills the buffer with as much sound/video
]data as possible, and returns pointers to the start of the indexes for
]the data.

]The frame index has the form:

]Offset: 0       Number of frames in index
]                4       Frame 1 offset
]                8       Frame 2 offset
]                ...

]The sound index has the form:

]Offset: 0       Number of sound chunks
]                4       Offset of sound chunk 1
]                8       Size of sound chunk 1
]                12      Offset of sound chunk 2
]                16      Size of sound chunk 2
]                ...
](I seem to remember Sophie objecting before at the concept of the
]fetcher returning non-contiguous blocks of sound as the sound fill
]code becomes less efficient, but this seems the most preferable
]solution.
]1) The fetcher can shove all the sound data into one lump, using a
]memory copy. This requires an increase in storage space in every
]buffer.
]2) The fetcher deliberately loads the sound data into consecutive
]locations in memory. This ruins sequential access of files, and causes
]more short reads. To circumvent this loss of performance, we require
]buffering; bad - not only do we get back to MovieFS's situation, we
]still have to do memory copies, so no better than 1.
]3) The player could do the copy and amalgamate all sound data into 1
]chunk. This requires less memory as only 2 sound buffers would be
]required, rather than a sound buffered sized piece of memory in every
]fetcher buffer.
]4) The sound code could be altered to play from small indexed buffers.
]This requires more complex sound code, and a possible loss of
]performance, but whether this will outweigh the loss of performance
]from a memory copy is unclear.)
]It is clear that when loading buffers of an arbitrary size, the end of
]the buffer may well contain an incomplete section of frame or sound
]data. Rather than loading this data again next time around, a pointer
]the the previous buffer is passed, and a memory copy can be done. This
]eliminates a potential costly reseek for unbuffered media.

This is fine (and a good optimisation). The reseek could be awful even
on buffered media (some CDROMs have daft algorithms!).

]Non-Image Filing System Version

]Why do we need an Image Filing System? Consider a scheme whereby we
]have a Movie module in memory. When this starts up, it broadcasts a
]Service_MovieStarting message.

]Other modules picking this up that wish to register themselves with
]the Movie module as providing recognition code, should then use the
]Movie_RegisterIdentifier SWI.

]Alternatively, a recognition module starting up after a movie module
]can issue a Movie_RegisterIdentifier SWI at start up.

]The player program, when asked to play a film can then interrogate the
]Movie module via a SWI to find out what fetcher to use. The Movie
]module passes the film around the modules for them to examine it, and
]they return a the fetcher name to use. Movie passes this back to the
]application, and the rest of the system performs as before.

]Thus the Movie module offers 3 SWIs as below:

]Movie_RegisterIdentifier
]On Entry:       R0=Pointer to identifier routine
]On Exit:

]Movie_DeregisterIdentifier
]On Entry:       R0=Pointer to previously registered routine
]On Exit:

]Movie_Identify:
]On Entry:       R0=RISC OS Filehandle
]                R1=Length of film in bytes (-1 for unknown)
]                R2=Current Filetype
]On Exit:        R2=Correct Filetype (if recognised)
]                R4=Pointer to fetcher name (or NULL)
]
]The routines registered with the Movie module are called as below:

]On Entry:       R0=RISC OS Filehandle
]                R1=Length of film in bytes (-1 for unknown)
]                R2=Current Filetype
]                R7=How hard to try
]On Exit:        R2=Correct Filetype (if recogised)
]                R4=Pointer to "Fetcher: name" (or NULL)

]The Movie module first makes a "quick" pass through the registered
]routines (with R7=0). Identifiers should do quick checks at this stage
](check Filetype, check "obvious" features (like "ARMovie")). If the
]filetype is incorrectly set, then the recogniser must NOT accept first
]time round.

]If no routine claims the movie the first time round the film can be
]passed around a second time. This time more "in depth" checks of the
]film can be performed (such as hunting down a potential Quicktime
]films structure for known atoms). At this stage the filetype passed in
]may be ignored. This means that films downloaded from external sites
]can be filetyped as they arrive.

]This 2 stage examination of films is important as not all
]films/samples can be trivially recognised by a simple examination.
]Additionally it enables a system where subtypes of a file format can
]be handled differently; for instance Quicktime VR films can be handled
]by a different handler than standard Quicktime films, without the
]standard Quicktime film handler knowing anything about Quicktime VR
]films.
]This scheme gives all the functionality of the Image Filing System
]scheme above, with the advanntages that:

]1) It uses no hacky image filing system, so works on older machines
]and on NFS.
]2) It provides an extensible system - rather than a Monolithic Movie
]moduel knwoing everything, components of the system can be loaded as
]required. (Should we really tell Sophie this? :-) )
]3) The scheme can be expanded beyond Movies to recognise other file
]types such as bitmaps, vector graphics etc, and the player can respond
]appropiately. (The module would return "Viewer: PDFview" for acrobat
]films for instance). This gives us a coherent "MediaPlayer".

]Conclusion:

]I believe that this scheme offers a clean,  efficient, extensible
]interface between a player application and routines to parse the file,
]and further introduces a system-wide solution to the problem of the
]proliferation of media standards.

]Care has been taken in the design of the interface to ensure that
]components are simple to implement, and that there is a clean break
]between the responsibilities of processes on either side of the
]interface; no work should have to be done on both sides of the
]interface.

]In addition the interfaces have been designed to be upgradable in a
]safe way, so the system can be tweaked in future years in reponse to
]our experience with it and software will contine to work.

]From: Paul Gardiner <paul@fsel.com>
]Date: Tue, 26 Mar 1996 13:36:49 GMT
]To: SWilson
]CC: Robin.Watts@comlab.oxford.ac.uk
]Subject: Re: Fetchers

]>From: SWilson@om.acorn.co.uk (Sophie Wilson)
]>
]>>Fetchers: some random comments
]>>------------------------------
]>>Sophie has described fetchers in a very natural way, as an alternative to the
]>>catalogue: in old-style Replay the catalogue is an interpretation of the file,
]>>saying where chunks are, which bits are video, which bits are audio; in
]>>new-style Replay the catalogue is a reference to a piece of code that loads and
]>>interprets chunks.
]>
]>Too true.
]>
]>>There are various aspects of an implementation that may need discussing, some
]>>mentioned below:
]>
]>>* File recognition: effectively deriving the information for a Replay header.
]>
]>And also providing the means to start the whole system in the first place (the
]>alternative being deliberately to place <ARMovie$Dir>.Player on the command
]>line to kick off playing a clip and to have programs call something that tells
]>them if a file can be played).
]>
]>>* Presenting header information to Replay.
]>
]>Most important.
]>
]>>* Replay's loading of fetchers.
]>
]>Must allow multiple fetchers to be used simultaneously.
]>
]>>* Replay's interface to fetchers.
]>
]>Must be simple and proof against upgrade.
]>
]>>It would be good if we can treat these almost completely independently.
]>
]>And it would also be good if we can finish all this soon (like within two
]>months). Did I mention that Oracle are likely to want this technology for the
]>Network Computer? (:-))

]That's interesting  (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-)) (:-))

Isn't it just...

]>>File recognition.
]>>----------------
]>>We may be able to put off deciding exactly how this is to be done. We just need
]>>to check that our interfaces don't rule out nice solutions to the problem.
]>
]>What's a playable file? How can users and programs tell? How do we provide a
]>very simple interface for the very simple minded programmers?
]>
]>I'm biased towards sticking with the current situation - and maybe extending it
]>later on.

]Me too

But I also want it to work on NFS. Some change may be essential (which is a
shame).

]>>Header presentation.
]>>-------------------
]>>The main question here seems to be between using a standardish Replay header or
]>>passing values in memory (i.e., having Replay call a SWI).
]>
]>Well, the subsiduary question is the nature of the data in the header/dll
]>fetcher. In particular Replay has notions of knowing the allocation sizes for
]>practically everything after doing this.

]Hmm, now you come to mention it, the main question looks pretty unimportant
]compared with the subsiduary one!

Yes, its a biggy. Or a lot of rewrites.

]>>The standardish Replay header provides a certain amount of flexibility. If
]>>Replay were happy to be passed two files, one containing the data, and the
]>>other containing the header, all sorts of possibilities open up. (If passed one
]>>file, Replay would expect both data and header in that one file, as usual.)
]>
]>Yes, there would be no problem in having two files, except for reaching the
]>second one (back to file recognition). If the header/dll fetcher block is
]>brewed on the spot, we could put another entry in it giving the data file name
]>or a file handle. There seem to be real problems passing the second file as a
]>parameter on the original command line since it means the caller of the Replay
]>system has to know the difference.

]If we stick on one of the first three suggestions below then Replay can know
]for sure where the data is, once told where the header is. (We're working on
]a filing system - rather than image filing system - version of MovieFS, which
]will work over NFS).

Oh? How does this work?

]>>* MovieFS could make alien films look like directories containing a single
]>>file, which provides just the header. Replay would be passed both the header
]>>and the image file itself.
]>
]>>* MovieFS could make alien films look like directories containing two files
]>>(header and data, of course). Both would be passed to Replay.
]>
]>>* MovieFS could make alien films look like directories containing a single
]>>header-and-data file. That one file would be passed to Replay.
]>
]>>* An application could generate headers for alien films, on demand, and place
]>>them in a scrap directory. Both the alien film and the header would be passed
]>>to Replay. (Works across NFS, of course).
]>
]>>* A film for which a header had previously been generated could be stored in an
]>>ordinary directory with its header. Blah blah blah.
]>
]>>* A CD full of alien films could be supplied with a floppy full of headers.
]>
]>Alternatively the header could permute into the data file by silly pointer
]>addresses. You're bound to have the header at offset 0, though.

]Lost me there.

Because other people read headers of files to deal with Replay.

]>>The passing of values by Replay calling a SWI provides a much cleaner overall
]>>system (no need for messy image filing systems at all), but it does rather tie
]>>Replay to the recognition code (Replay can't call the SWI if the recognition
]>>module isn't loaded). A way out of that one is to consider the recognition
]>>module to be part of Replay, but that would mean us having to design an
]>>extensible recogniser module before there could be a fetcher-using release of
]>>Replay.
]>
]>This is definitely a nasty area. I would prefer to stick to a system where the
]>header triggers off the new activities, but this could included a combination
]>approach where there's nothing in the header except the hint to call the new
]>facility.
]>
]>Actually, I'd prefer to stick to the current header...

]Me too

I'm sure we can wind up Robin!

]>>Replay's loading of fetchers.
]>>----------------------------
]>>There was a worry here that if fetchers were loaded in the same way as
]>>decompressors then there would be no easy way to write them in C. That worry
]>>seems to be unfounded: ARM coders can write nice lean fast fetchers, whereas C
]>>coders can write a little ARM-code veneer that redirects to a module.
]>
]>We could make the interface between Replay and the fetcher much more like the C
]>calling sequence than the decompressor one was (mainly because the fetcher
]>doesn't need to be called in interrupt mode with IRQs enabled!) and (novelty)
]>use r14 for the return value, r0-r3 for parameters! However there are
]>inevitable problems with run time libraries. I don't mind calling an Initialise
]>Fetcher routine first, though.

]The veneer redirecting to a module allows for the use of run time libraries.

]>The system must allow multiple fetchers to be used simultaneously, both of
]>different types and of the same type.

]No probs.

]>>Replay's interface to fetchers.
]>>------------------------------
]>>We could start with the simplest interface that has any chance at all of
]>>working, and then add features as required until we get something workable.
]>
]>>First attempt:
]>>Assuming Replay has already obtained the information from reading the header or
]>>calling the recognition SWI.
]>
]>>Three entry points: Open, Fetch, Close.
]>
]>>Open:
]>>On Entry: R0=file handle
]>>On Exit:  ---
]>
]>>Does what ever it needs to in readiness for calls to Fetch. It might have to
]>>allocate some memory. It might even have to load a module! Is this okay? If not
]>>fetcher writing will be a lot harder and slower.
]>
]>Yes, this is OK provided that the module can retain state for several open
]>files simultaneously (WIMP definition of simultaneity).

]Yes.

]>>Fetch:
]>>On Entry: R0=address of buffer
]>>          R1=size of buffer
]>>On Exit:  R0=Pointer to Frame Index
]>>          R1=Pointer to Sound Index
]>
]>>Fills the buffer and returns a description of the information it has loaded
]>>(positions of frames and chunks of sound).
]>
]>Fills the buffer? Or provides at most one chunks worth of frames? Which chunk
]>number into the file are we? You can't simply give successive chunks since the
]>combination of -playfor and -loop could have it start back at the beginning
]>again. (see below for -startat)

]Here we're getting to the sticky bit.  The trouble with AVIs and Quicktimes
]is that they don't hold their data in large chunks.  Typical layout of an AVI
](although there are many others) is

]SSSSSSSSFSFSFSFSFSFSFSFSFSFSFSFSFSFFFFFFFF

]where F is frame and S is sound for a period of the same length as F.

That's even uglier than I thought.

]This is a real pain when you want to generate Replay chunks; that's what the
]current MovieFS needs its big buffers for.  I was hoping we could fetch a
]buffer full and tell Replay where the bits are, but if we do that I can
]guarantee the number of frames will vary between fetches and that the sound
]and video data will be skewed.  Worse, some AVIs don't have indexes, so the
]fetcher doesn't know where the bits are until it reads them.

Or perhaps that's the truly ugly bit. Adding indexes to Player is not hard -
I have enough time to do it.

]>>The frame index has the form:
]>
]>>Offset: 0  Number of frames in index
]>>        4  Frame 1 start
]>>        8  Size of Frame 1???
]>>        12 Frame 2 start
]>>        16 Size of Frame 2 ???
]>>        ...
]>
]>When playing the file, Replay cares little about these indexes, though it could
]>be modified to use them. It cares even less about compressed frame sizes and
]>has no particular way of using the information.

]But the frames won't be consecutive in the buffer, so I think the indexes
]will be needed.  Gladly drop the size, though.
](Although, see revolting idea at end of message.)

]>>The sound index has the form:
]>
]>>Offset: 0  Number of sound chunks
]>>        4  Start of sound chunk 1
]>>        8  Size of sound chunk 1
]>>        12 Start of sound chunk 2
]>>        16 Size of sound chunk 2
]>>        ...
]>
]>Yeesh. Very real problems with bull-dozing all the data together.

]One argument for Replay doing the bull-dozing is that the code has to be
]written only once, not once per fetcher. (Hidden agenda: you'd do it,
]and we wouldn't have to (:-)) ).

Yes, but I have no time, so if I do it, noone gets to use it since it
never gets done.

]>>Close:
]>>On Entry: ---
]>>On Exit:  ---
]>
]>>Shuts down fetcher.
]>
]>Super.
]>
]>>---------------------------------------------------------------------------
]>>Potential problems.
]>
]>>* Films need to be played from arbitrary start positions. A fourth fetcher
]>>entry point could be added to support this.
]>
]>Replay has its own ideas on this: it really needs to know the closest chunk or
]>have a lobotomy. There's no time problem about decompressing from the start of
]>the closest chunk until the required frame is reached and this procedure does
]>ensure sound/video sync.

]But there are no chunks really, that's what bothers me.  I don't really know
]what to do about this one.

]>>SetTime:
]>>On Entry: R0=time (16bit.16bit)
]>>On Exit:  ---
]>
]>Why not the value given to -startat?

]Yes. much better

It seems an obvious one to use. 32 bits of centiseconds is a long time. Longer
than any movie yet made :-).

]>>The specified time may not correspond to a key frame, in which case perhaps the
]>>fetcher should set to the latest earlier time that does correspond to a key
]>>frame, returning that time in R0; Replay can then play silently and invisibly
]>>for the difference of the times. Should a fetcher be free always to do this, or
]>>should Replay pass a flag to the Open entry point or to SetTime, saying whether
]>>to do it or not? Should there be a limit on how far back in time to look.
]>
]>What will this do to the chunk structure of the file?????

]Again, blah blah etc.  I don't know.

]>>Perhaps:
]>
]>>SetTime:
]>>On Entry: R0=requested time (16bit.16bit)
]>>          R1=allowed drift
]>>On Exit:  R0=actual time set
]>
]>>Then <allowed drift> = 0 implies <actual time set> = <requested time>
]>
]>>* The frame index returned by Fetch has frame sizes so that editing programs
]>>can copy frames from place to place. Since thinking of this, we've realised
]>>that there are occasions when it is useful for frames to include indirected
]>>data; editing programs wouldn't be able to copy such frames without
]>>understanding their structure. Can we get away without frame sizes? Should we
]>>have another entry point (called Flatten say), which moves data about so as to
]>>remove indirections? This would have a time overhead but would be used only by
]>>editing suites. Can we ignore this for now?
]>
]>Yes. Its not part of our remit to design the world's best compressed file
]>editting application!

]Good.  Suits me.

]>>* Frame positions and sizes are difficult to derive for the native
]>>Replay-format fetcher.
]>
]>Nay, impossible! They can only be discovered by decompressing the file...

]Do we need to special case this one then (unless we go for the revolting idea
]at the end of this message)?

Yes, a special case is OK. The codec i/f needn't change, all that needs to
change is the bit in Player where it calls the codec for successive frames.

]>>* The frames-per-chunk field of the replay header cannot be given a definitive
]>>value in the fetchers universe. What's the minimum amount of information that
]>>Replay could work with?
]>
]>Either a definitive value or Robin is going to have to recode Player for me!
]>
]>Frames per chunk does allow simple computations to be made on latency for the
]>wimp and worst case computations on device bandwidth/buffer size. It never
]>trips over itself if it gets anomalously big/small numbers of frames into
]>memory (since it can't).

]Hmm, that's a shame; we could really do with some flexibility there.
]The only alternative seems to be to have the fetcher doing a lot of
]copying from the last buffer to the new one - in the case of index-less
]formats like FLI, an enormous amount of copying.  Also we will have
]to ask replay to allocate buffers far larger than really needed just
]to be completely sure we load at least as many frames as we promised
]on each fetch.  If we load too many frames, we just don't tell Replay they're
]there.  If we load too few, we've had it: there's nothing we can do.

Too few is a real disaster. Too many with reused buffers is only a memcpy.

]>>* A fetcher can't necessarily know where frames are going to be, before filling
]>>a buffer. So a fetcher can't avoid pulling in the odd half frame at the end of
]>>a buffer. When a fetcher does pick up half a frame it can just not bother to
]>>inform Replay that its there, and then on the next fetch, copy the half frame
]>>to the beginning of the new buffer (to avoid rereading it). For this to work it
]>>is important that, when calling Fetch, Replay ensures no corruption to the last
]>>buffer (outside of the areas refered to by the indexes). Is it always
]>>reasonable for Replay to guarantee this, or should Replay pass a flag to Fetch
]>>saying whether the last buffer is okay?
]>
]>I think its possible to guarantee this. Unless something nasty happens in
]>amalgamating the sound data.

]Good, good.

]>>* Currently we have MovieFS sending palettes to our decompressors by gluing
]>>them on the front of frames. Doing this in a fetcher requires the moving of
]>>just small amounts of data, providing were wishing only to do it to the first
]>>frame in each buffer (as we do now). Gluing palettes on the beginning of frames
]>>close to the middle of a buffer requires a large movement of memory.
]>>Introducing data structures with indirection gets around this problem, but
]>>makes the frame sizes a little meaningless, as mentioned above.
]>
]>I think the frame sizes are meaningless - we are really only trying to play
]>files, not become the Adobe Premiere of the western world.

]Great, that's the answer I hoped for.

]>>* We also send information to our sound-playing code by gluing it on the front
]>>of the sound chunk. This doesn't look to be a problem really: we can just
]>>ensure there's sufficient room in the buffer to place a copy of the header and
]>>then return it as the first entry in the sound index.
]>
]>Yes.

]That was bound to be okay really, because its transparent to Replay.  I think
]Robin told me he'd flagged a problem here, but we're now happy things are okay.

]>>* Because of the varying structure of alien-film formats, it is likely that the
]>>first call to Fetch will provide Replay with different amounts of audio and
]>>video data (in terms of playing time), and that some skewing of the data will
]>>persist throughout playback.
]>
]>Chunk sizes? File IO sizes? Will it maintain sync and speed without placing
]>greater requirements on the hardware (e.g. CD ROM drives are notoriously slow
]>at silly accesses).

]Lost me again here.  This sounds like an important point, but I don't
]immediately understand what you're saying.

There was some stuff earlier in this reply. Basically the IO driver in Replay
can fetch the next chunk without any CPU work at all. This catches the disc
before rotation bites!

]>>* The latest Replay can play multiple films simultaneously. To play two films
]>>of different types, clearly Replay needs to load two fetchers. If playing two
]>
]>yes
]>
]>>films of the same type, Replay could load two copies of the one required
]>>fetcher, and have each copy know which film it was dealing with. It could
]>
]>which is fine as far as I'm concerned
]>
]>>alternatively use a single fetcher, but some enrichment of the fetcher
]>>interface would be required (i.e. 'Open' could return a 'fetching handle' that
]>>must be passed back on calls to the other entry points).
]>
]>also fine

]I think I prefer the first option for its simplicity, both in the fetchers
]and in Replay (less special cases), but it could be wasteful of memory for
]large ARM coded fetchers. (Perhaps all the ARM coded ones will be nice and
]small anyway.

I'm sure they will be :-)

]>>* Version control: we will not get these interfaces right first time, and in
]>>six months time will want to change things. How do we ensure that we don't have
]>>Replay talking one language to a fetcher that speaks another? How do we, in the
]>
]>by never doing it!
]>
]>>future, write fetchers that work with all previous fetcher versions of Replay?
]>
]>by upgrading in lock step. It is permissable to change things en-masse if
]>needed (e.g. the colour space mapping programs and Replay have the same
]>incestuous relationship).
]>
]>>How does Sophie (if she wishes) write a Replay that can use any version of a
]>>fetcher? We can't just put this off until it bites us - or can we? All we need
]>
]>Yes.
]>
]>>do is change the naming convention for the fetcher-code files on each revision:
]>>Fetch, Fetchv2, Fetchv3, ... A developer of fetchers can then supply them all
]>>if need be, and the particular version of Replay in use can pick the latest it
]>>understands.
]>
]>If you insist. I still think you're making a mountain out of a molehill.

]No insistence.  Glad to forget all that, for now at least.

]>>* Fetches from alien film files are going to produce noncontiguous sound data.
]>>What do we do about that?
]>
]>Something efficient, please.
]>
]>>1) The fetcher can shove all the sound data into one lump, using a memory copy.
]>>This requires an increase in storage space in every buffer.
]>
]>In which buffer? Surely I get data in the same agregate size? Or are you saying
]>that as well as the discontiguous layout, there's a contiguous lump at the end?
]>
]>>2) The fetcher deliberately loads the sound data into consecutive locations in
]>>memory. This ruins sequential access of files, and causes more short reads. To
]>>circumvent this loss of performance, we require buffering; bad - not only do we
]>>get back to MovieFS's situation, we still have to do memory copies, so no
]>>better than 1.
]>
]>Yes, no better.
]>
]>>3) The player could do the copy and amalgamate all sound data into one chunk.
]>>This requires less memory as only two sound buffers would be required, rather
]>>than a sound buffered sized piece of memory in every fetcher buffer.
]>
]>Actually, I think it comes to the same thing - for each of the file IO buffers,
]>there must exist enough extra memory to hold a contiguous version.
]>
]>>4) The sound code could be altered to play from small indexed buffers. This
]>>requires more complex sound code, and a possible loss of performance, but
]>>whether this will outweigh the loss of performance from a memory copy is
]>>unclear.
]>
]>The sound code already copies the data (which may have vanished before the
]>sound is emitted), so this might not cause any loss of performance. We'd have
]>to get all the sound code updated to the new spec of Sound Give Data, though.
]>
]>>No 3 may be best for now: no rewriting of sound code, and no compromising of
]>>the fetchers interface.
]>
]>Fine by me.

]Good.

]>When shall we do it by?

]Within the next two months seems perfectly reasonable for our part of this.

Delivery for end May, then. Suits me, provided the amount of work allocated to
me is commensurate with my workload. (don't you just love phrases like that?)

]>--Sophie


]Revolting idea: Fetchers faking true Replay chunks.
]---------------------------------------------------

]This is only worth considering if you really really really can't drop the
]restriction of having a constant number of frames per fetch.

]We make a small change to all our decompressors so that, rather than expecting
]a list of compressed frames, they expect a list of frame-data start addresses.
]Given such a list Rerplay can point the decompressor at the start and just
]call the frame entry point N times.

]We tell Replay, in the header, to allocate buffers of length
]  4 * <frames per chunk> + <sound samples per chunk> + XXX

]i.e.  <Indirected frames> <Sound> <Part of file>

]XXX being the smallest size such that all parts of the file of that size
]contain at least <frames per chunk frames>, and such that some other audio
]constraint holds. (The big weakness here is that some formats make XXX
]impossible to establish without pre-reading the whole file.

]Anyway -
]A fetch will fill up the XXX part of the buffer then fill in the addresses
]of the frames in the first part of the buffer and bull-doze the sound into
]the <sound> section.  As far as Replay is concerned it has been given a
]standard Replay chunk.  The frames look a bit small (four bytes each) but
]Replay doesn't care so long as the decompressors are happy.


]The only nice thing about this is that it requires little change to Replay.

]The bad things are many

True. I think if we're going to keep the AVI internal structure, its better
to make the changes in Player than trying to hide it.

]  We can't always calculate XXX, so sometimes we will be forced to make it
]  ten times bigger than necessary.

]  Sound bull-dozing will have to be done from both the current buffer
]  being filled, and the last.

]  When the buffers are larger than necessary, large amounts of data will
]  have to copied by the fetcher from one buffer to the next.  Worse cases
]  are likely to be far worse than current MovieFS overheads.

]Paul.

--Sophie

(phew - the mega reply took two elapsed hours due to interrupts!)
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Tue, 26 Mar 1996 18:35:46 +0000 (GMT)

In some randomly numbered message, Sophie Wilson said:
:
:Its mega reply time - you and Paul are exceeding my answer rate!

Sorry. I'll try and keep this down then.

:]Paul however likes Image Filing systems and the existing ARMovie Header idea.
:]We all need to discuss this. I suspect you will have strong opinions on this.
:
:Not particularly strong, but I am worried about how the system gets called and
:how it all works. The idea of two files doesn't worry me (the second one being
:an ARMovie typed Header file containg enough to fake existing applications)
:except for the matter of it being real or an image file and the whole thing
:working on NFS.

OK. Suppose for now we can get Image Filing systems working on NFS, and proceed
on that assumption.

Points I want clarification on:

1) Do we need programs such as Genesis to be able to play movies that require
fetchers without them being rewritten? Or can we assume that Genesis is happy
just playing AE7s?

If the answer is yes ("yes, genesis needs to be able to play movies that need
fetchers") then we are tied into a ImageFS system.

This being the case, how do you all feel about a central "MovieFS" module that
other modules register with.

These "Child" modules register a filetype, some recognition code, and a routine
that returns header information.

When a file is double clicked, if it is of a registered filetype, then MovieFS
calls the appropriate module, and is returned the info for the header.

MovieFS then fakes the header in the usual way (modified slightly to work over
NFS), and returns an ARMovie header with all the usual info in plus a "Fetcher"
field somewhere.

:Sooner, then. Yes, it is looking likely that Oracle will want Replay on the
:NC to play AVI and QT files, but its not even beyond a few words in a VP's
:email yet!

Fab. This means Acorn need to kick Ashurst hard about the legality of CinePak
though.

:OK by me. Provided it is extensible. And provided that there is some
:compatability path for old clients of Replay. I really don't expect Genesis,
:Magpie etc to get rewritten! On the NC applications will be written anew
:so this isn't as much of a problem.

Well, I guess the scheme I have just described works.

:But only a tiny tweak on the memory used by two movies playing simultaneously.

OOh. This is almost a devastating argument. Climbdown #1 for the day.

:]Fills the buffer. This is something we really need to get
:]straight. See below.
:
:Player rewrite time again. Again, I won't have the time to do this, but I'm
:happy for you to do so.

Hmmm. I will look at the source tonight if I get a chance.

:-startat is specified in time. Centiseconds, to be precise.

Climbdown #2: This is perfectly sensible (if Centisecond granularity is fine
enough - how small does the timecode system go?)

:Indeed I am. I've had a lot of experience playing data efficiently
:off slow CDROMs and chunks are one of the things that makes it
:possible. Replay can (and does) play off slower CDROMs than QT and
:AVI - single speed drives are actually useable - and as a consequence
:we have a large number of slow drives in the market.

OK. Just because we are proposing you ditch chunks, does NOT mean we are
proposing you lost this play's-from-just-fast-enough media.

We are organising stuff as much as possible so that we *can* just load slabs of
disc and return indexes to them.

The more "chunklike" we have to make each fetched block, the more processing we
have to do between reads. Hence the *less* the chance of us catching the next
sector in time.

(Idea: How about structuring the fetchers in 2 sections, so that 1 part is just
reading from disc, and another is doing the indexing in the background on a
CBAI? Would mean we got to catch sectors more often, but is probably infeasible
in the time. Ho hum.)

:Sure. But I really do have limited time to code. I'm happy for Robin to code
:the changes on behalf of Acorn, but Acorn would want complete rights to the
:code to remain with them.

OK. I want to assess the work involved before I agree to this...

:Its the squeezing in less that's the real problem (though squeezing
:in more may also be a mistake if a file serving device (NFS, CDROM)
:is trying to stream data efficiently).

In our scheme we would always be loading the same amount of data from the disc,
so squeezing in more would come simply to the streaming backing store...

:OK. I think a rewrite of all sound routines and their callers is feasible.
:Note that I might be wrong about this and we'd have to provide backwards
:compatability.

OK. I think this will all come out in the wash.

:So rewrite. I'm sure we can find an infinite number of monkeys somewhere.

But for every one of those Monkeys that produces Shakespeare there's another
thousand producing Linda La Plante... :-)

:So why don't QT and AVI do as well as Replay? They flash the access light like
:crazy and need high speed access drives with caches.

Because they have to work through 8E6 layers of DOS/WINDOWS/BIOS cruft.

Under our scheme the beautiful efficiency/simplicity of Replays disc access
would remain.

:Yes, but guess who gets to recoder Player and write the new documentation
:(and, just maybe, rewrite Acorn's source and interface with third parties).
:
:Nothing's for free!

TANSTAAFL!

:I'd keep it movie specific. It would be a mistake to get too involved with
:other types of data.

Climbdown #3: OK.
<Warning: Maximum permissible climbdowns for the day approaching>

:How do we rewrite the old apps??????????????????

We don't.

:Don't know. We do need to work on NFS...

Boy, I'm glad I've got a smart partner...

:]3) Why does Replay need Chunks?
:So that file IO gets really streamlined. Player ends up doing sector aligned
:transfers of integral numbers of sectors and is able to issue the next request
:without any other processing being done (i.e. before the rotational action of
:the device has moved away from the next sector).

But by forcing us to make chunks, you are losing exactly this!  Our scheme was
designed with "we must load 1 big continuous slab of file in each fetch" as the
central tenet. You are proposing we ditch this...

:And the clock's ticking.

You sound like my supervisor :-(

:Yes. I try to keep !ARMovie as empty as possible. Fetchers could (and maybe
:should) be named rather than numbered like the decompressors (we could also
:start naming decompressors in a new world).

Fetchers should be named.

[Open stuff snipped]
:I think the time should be in here somewhere/how. Player reads consecutive
:frames until it loops back to the start. But editors don't.

No. So open is only ever called once. This turns a filename into a filehandle,
and opens the file. SetTime should be a separate entry point.

:This is fine (and a good optimisation). The reseek could be awful even
:on buffered media (some CDROMs have daft algorithms!).

OK.

:But I also want it to work on NFS. Some change may be essential (which is a
:shame).

But I have a very smart partner...

:Yes, its a biggy. Or a lot of rewrites.

:Oh? How does this work?

We make a file somewhere else (<WimpScrap$Dir>.MovieFS.0000) of the appropriate
type that says contains:

Redirection
NFS::xxxxxxxxx.$.Fred/mov

:I'm sure we can wind up Robin!

Twang!

:[AVI chunks]
:That's even uglier than I thought.

It is.

:Or perhaps that's the truly ugly bit. Adding indexes to Player is not hard -
:I have enough time to do it.

Fab. This is good news - see below.

:]One argument for Replay doing the bull-dozing is that the code has to be
:]written only once, not once per fetcher. (Hidden agenda: you'd do it,
:]and we wouldn't have to (:-)) ).
:
:Yes, but I have no time, so if I do it, noone gets to use it since it
:never gets done.

Well, 1) This will be done by a monkey doing the sound rewrite, and even if its
not 2) making small changes to Replay like this is feasible for non-Sophies.

:Yes, a special case is OK. The codec i/f needn't change, all that needs to
:change is the bit in Player where it calls the codec for successive frames.

Thats what I thought.

:Too few is a real disaster. Too many with reused buffers is only a memcpy.

But a memcpy that is done between disc accesses - big enough to miss catching
the next sector perchance?

:]Within the next two months seems perfectly reasonable for our part of this.
:
:Delivery for end May, then. Suits me, provided the amount of work allocated to
:me is commensurate with my workload. (don't you just love phrases like that?)

Hell, I never wanted to be Dr Watts anyway...

:(phew - the mega replay took two elapsed hours due to interrupts!)

well, its taken me 40 minutes so far, but I've been ruthless about chopping
stuff out...

Given that you give us Indexed chunks, then we think we can fake Replay chunks
with minimal overheads...

Given an AVI film:

SSSSSSSSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF

Then we can take

SSSSSSSSFSFSFSFSFSFSFSFSFSFS to be the first chunk,
                    SSSSSSSSFSFSFSFSFSFSFSFSFS to be the second
                                      SSSSSSSSFSFSFSFSFSFSFSFSFS to be the 3rd
etc

And we just need to copy 8S's between fetches. This memcopy overhead may be
small enough to live with.

This means we still get to load consecutive blocks from the disc, but costs us
8*sound sample data set size in memory overhead per buffer.

At worst we can go with this for a first cut, and refine it later.

I will look at the Player Source as soon as I get a chance to try and assess
the work involved, but I don't want to promise anything until I am sure I can
manage it...

Ta,

Robin
-------------------------------------------------------------------------------
"Get this thing straight once and for all. The Policeman            Robin Watts
 isn't there to create disorder. The policeman is there to
 preserve disorder" - Mayor Richard Dayley
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
At Wed,27 Mar 1996 10:32:49 mail was sent to Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
>In some randomly numbered message, Sophie Wilson said:
>:
>:Its mega reply time - you and Paul are exceeding my answer rate!

>Sorry. I'll try and keep this down then.

Greatly appreciated.

>OK. Suppose for now we can get Image Filing systems working on NFS, and proceed
>on that assumption.

Is that a good assumption? If so, it seems to be the easiest way to go.

>Points I want clarification on:

>1) Do we need programs such as Genesis to be able to play movies that require
>fetchers without them being rewritten? Or can we assume that Genesis is happy
>just playing AE7s?

A big one. This doesn't affect NCs, since they have new programs, but I guess
the answer for all RISC OS machines is "people are unlikely to upgrade their
programs at the moment".

>If the answer is yes ("yes, genesis needs to be able to play movies that need
>fetchers") then we are tied into a ImageFS system.

This seems to be the case.

>This being the case, how do you all feel about a central "MovieFS" module that
>other modules register with.

Er... slight trepidation, but potentially OK.

>These "Child" modules register a filetype, some recognition code, and a routine
>that returns header information.

(at least!)

>When a file is double clicked, if it is of a registered filetype, then MovieFS
>calls the appropriate module, and is returned the info for the header.

>MovieFS then fakes the header in the usual way (modified slightly to work over
>NFS), and returns an ARMovie header with all the usual info in plus a "Fetcher"
>field somewhere.

Sort of today's MovieFS, but extensible? It does seem OK, and it does seem to
be a straightforward way to proceed. Subject to working on NFS!

How do Codec names get mapped? Is it expedient at this point to change the way
that Replay's Header works to allow textual names as well as numbers?

>:Sooner, then. Yes, it is looking likely that Oracle will want Replay on the
>:NC to play AVI and QT files, but its not even beyond a few words in a VP's
>:email yet!

>Fab. This means Acorn need to kick Ashurst hard about the legality of CinePak
>though.

Or someone needs to stump up the money for it. Clearly the ability to play an
AVI/QT file is not the same as the ability to play AVI/QT files which happen
to use Cinepak!

>:OK by me. Provided it is extensible. And provided that there is some
>:compatability path for old clients of Replay. I really don't expect Genesis,
>:Magpie etc to get rewritten! On the NC applications will be written anew
>:so this isn't as much of a problem.

>Well, I guess the scheme I have just described works.

Yes, subject to the NFS assumption.

>:But only a tiny tweak on the memory used by two movies playing simultaneously.

>OOh. This is almost a devastating argument. Climbdown #1 for the day.

Its not that devastating, and there's no need to treat it as a climbdown. This
is merely a structured discussion, not an argument :-).

>:]Fills the buffer. This is something we really need to get
>:]straight. See below.
>:
>:Player rewrite time again. Again, I won't have the time to do this, but I'm
>:happy for you to do so.

>Hmmm. I will look at the source tonight if I get a chance.

Did you? I think you have reasonably up to date source (you may even notice
that the sound only files bug is back!) and its not changing rapidly here (we
are still working on the clipping/painting bits)

>:-startat is specified in time. Centiseconds, to be precise.

>Climbdown #2: This is perfectly sensible (if Centisecond granularity is fine
>enough - how small does the timecode system go?)

Timecode resolves to frames. For the purposes of accurately representing 1/24,
1/25 and 1/30 of a second it uses 1/1800 as its granularity. Of course, this
obscures the fact that 1/30 isn't 1/30, but 1/29.97... Yes, I think a
centisecond resolution on frame times is sensible!

>:Indeed I am. I've had a lot of experience playing data efficiently
>:off slow CDROMs and chunks are one of the things that makes it
>:possible. Replay can (and does) play off slower CDROMs than QT and
>:AVI - single speed drives are actually useable - and as a consequence
>:we have a large number of slow drives in the market.

>OK. Just because we are proposing you ditch chunks, does NOT mean we are
>proposing you lost this play's-from-just-fast-enough media.

Good.

>We are organising stuff as much as possible so that we *can* just load slabs of
>disc and return indexes to them.

Yes, I appreciate that.

>The more "chunklike" we have to make each fetched block, the more processing we
>have to do between reads. Hence the *less* the chance of us catching the next
>sector in time.

And this.

>(Idea: How about structuring the fetchers in 2 sections, so that 1 part is just
>reading from disc, and another is doing the indexing in the background on a
>CBAI? Would mean we got to catch sectors more often, but is probably infeasible
>in the time. Ho hum.)

Essentially this is how Replay works. To do this, you would need the process
which drives the video decompressor to call you at the start of each chunk. It
might not even need to be CBAI'd, since it already runs at its own priority.
(this is separate from the aspect of using CBAI to set the priority of the
interrupt processes).

>:Sure. But I really do have limited time to code. I'm happy for Robin to code
>:the changes on behalf of Acorn, but Acorn would want complete rights to the
>:code to remain with them.

>OK. I want to assess the work involved before I agree to this...

You kept saying it was easy. Seriously, I don't want to put you under pressures
which make you mis-estimate the time something may take. To synchronise with
the NC work, we do need to do this on an accurate timescale. If this means we
have to find more people, its better to know NOW!

>:Its the squeezing in less that's the real problem (though squeezing
>:in more may also be a mistake if a file serving device (NFS, CDROM)
>:is trying to stream data efficiently).

>In our scheme we would always be loading the same amount of data from the disc,
>so squeezing in more would come simply to the streaming backing store...

But its the less frames potential that is really worrying - if the buffer
contains too few frames, then the -multi reschedule will mean the foreground
task resumes after the video has run out.

>:OK. I think a rewrite of all sound routines and their callers is feasible.
>:Note that I might be wrong about this and we'd have to provide backwards
>:compatability.

>OK. I think this will all come out in the wash.

>:So rewrite. I'm sure we can find an infinite number of monkeys somewhere.

>But for every one of those Monkeys that produces Shakespeare there's another
>thousand producing Linda La Plante... :-)

Actually, I enjoy some of her work. Such as The Governess.

>:So why don't QT and AVI do as well as Replay? They flash the access light like
>:crazy and need high speed access drives with caches.

>Because they have to work through 8E6 layers of DOS/WINDOWS/BIOS cruft.

No such cruft in the Mac, and it also goes blinking mad!

>Under our scheme the beautiful efficiency/simplicity of Replays disc access
>would remain.

:-)

>:Yes, but guess who gets to recoder Player and write the new documentation
>:(and, just maybe, rewrite Acorn's source and interface with third parties).
>:
>:Nothing's for free!

>TANSTAAFL!

Expense account lunches...

>:I'd keep it movie specific. It would be a mistake to get too involved with
>:other types of data.

>Climbdown #3: OK.
><Warning: Maximum permissible climbdowns for the day approaching>

Ah, only a warning - can safely ignore this - I'll wait for a fatal error.

>:How do we rewrite the old apps??????????????????

>We don't.

So do we want to drop AVIs into Genesis like we do now? I think we all agree
on yes, which implies the image file, header file approach.

>:Don't know. We do need to work on NFS...

>Boy, I'm glad I've got a smart partner...

Lucky you. I just get to work with smart ass companies :-)

>:]3) Why does Replay need Chunks?
>:So that file IO gets really streamlined. Player ends up doing sector aligned
>:transfers of integral numbers of sectors and is able to issue the next request
>:without any other processing being done (i.e. before the rotational action of
>:the device has moved away from the next sector).

>But by forcing us to make chunks, you are losing exactly this!  Our scheme was
>designed with "we must load 1 big continuous slab of file in each fetch" as the
>central tenet. You are proposing we ditch this...

No, I don't want you to ditch this, but I want to be sure that it really does
work. I think this means NO foreground process work apart from repetetive
calling of the disc driver: can you manage to do this?

>:And the clock's ticking.

>You sound like my supervisor :-(

Um. I have been a supervisor in the past. I think I sound more like a project
manager, but perhaps that's only an illusion. After all, my parents are both
teachers...

>:Yes. I try to keep !ARMovie as empty as possible. Fetchers could (and maybe
>:should) be named rather than numbered like the decompressors (we could also
>:start naming decompressors in a new world).

>Fetchers should be named.

OK. And the decompressors? This doesn't look like a tricky change in Player -
if VAL of decomp field is zero, then take string to first space or newline and
try this as the decomp identifier.

>[Open stuff snipped]
>:I think the time should be in here somewhere/how. Player reads consecutive
>:frames until it loops back to the start. But editors don't.

>No. So open is only ever called once. This turns a filename into a filehandle,
>and opens the file. SetTime should be a separate entry point.

I think I'm saying that the read chunk should carry a time parameter, (which is
essentially what happens in Replay presently - the catalogue is time ordered),
but I guess I don't really care. OK.

>:This is fine (and a good optimisation). The reseek could be awful even
>:on buffered media (some CDROMs have daft algorithms!).

>OK.

>:But I also want it to work on NFS. Some change may be essential (which is a
>:shame).

>But I have a very smart partner...

This sounds like boasting. Or are you attempting to influence Paul?

>:Yes, its a biggy. Or a lot of rewrites.

So how are you going to manage the allocation of the buffers: Player wants to
know at Header read time.

>:Oh? How does this work?

>We make a file somewhere else (<WimpScrap$Dir>.MovieFS.0000) of the appropriate
>type that say contains:

>Redirection
>NFS::xxxxxxxxx.$.Fred/mov

OK, so there's a reference to the real data, stored in a real file which is on
a filing system which you hope can be imaged? What happens when NFS is the only
file system and thus WimpScrap$Dir is stored on it????

>:[AVI chunks]
>:That's even uglier than I thought.

>It is.

(why oh why oh why!)

>:Or perhaps that's the truly ugly bit. Adding indexes to Player is not hard -
>:I have enough time to do it.

>Fab. This is good news - see below.

Of course, doing the sound work is beyond me. I'm talking only of the video
data.

>:]One argument for Replay doing the bull-dozing is that the code has to be
>:]written only once, not once per fetcher. (Hidden agenda: you'd do it,
>:]and we wouldn't have to (:-)) ).
>:
>:Yes, but I have no time, so if I do it, noone gets to use it since it
>:never gets done.

>Well, 1) This will be done by a monkey doing the sound rewrite, and even if its
>not 2) making small changes to Replay like this is feasible for non-Sophies.

But will they wreck it in the process? Changes to Player source is made by
only a small number of non-monkeys.

>:Too few is a real disaster. Too many with reused buffers is only a memcpy.

>But a memcpy that is done between disc accesses - big enough to miss catching
>the next sector perchance?

Yes, almost certainly. CDROMs are very fussy about how soon the next read
command is, though modern drives are beginning to be smarter (they use the
buffer to carry on reading after fulfilling the last request). I suppose it
will all depend on the average amount of memcpy and which drive is attached.

>:]Within the next two months seems perfectly reasonable for our part of this.
>:
>:Delivery for end May, then. Suits me, provided the amount of work allocated to
>:me is commensurate with my workload. (don't you just love phrases like that?)

>Hell, I never wanted to be Dr Watts anyway...

Sure you did.

>:(phew - the mega replay took two elapsed hours due to interrupts!)

>well, its taken me 40 minutes so far, but I've been ruthless about chopping
>stuff out...

>Given that you give us Indexed chunks, then we think we can fake Replay chunks
>with minimal overheads...

>Given an AVI film:

>SSSSSSSSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSFSF

>Then we can take

>SSSSSSSSFSFSFSFSFSFSFSFSFSFS to be the first chunk,
>                    SSSSSSSSFSFSFSFSFSFSFSFSFS to be the second
>                                      SSSSSSSSFSFSFSFSFSFSFSFSFS to be the 3rd
>etc

Don't understand where all the prefixed SSSSSSSS's come from.

>And we just need to copy 8S's between fetches. This memcopy overhead may be
>small enough to live with.

Still don't understand.

>This means we still get to load consecutive blocks from the disc, but costs us
>8*sound sample data set size in memory overhead per buffer.

And can this be predicted in advance (when Player reads the header?)

>At worst we can go with this for a first cut, and refine it later.

>I will look at the Player Source as soon as I get a chance to try and assess
>the work involved, but I don't want to promise anything until I am sure I can
>manage it...

Fine (see earlier)

>Ta,

>Robin

--Sophie
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Wed, 27 Mar 1996 11:25:51 +0000 (GMT)

In some randomly numbered message, Sophie Wilson said:
:
:>This being the case, how do you all feel about a central "MovieFS"
:>module that other modules register with.
:
:Er... slight trepidation, but potentially OK.

Why trepidation? Because it ties MovieFS into Replay?

:>These "Child" modules register a filetype, some recognition code,
:>and a routine that returns header information.
:
:(at least!)

Indeed.

:Sort of today's MovieFS, but extensible? It does seem OK, and it does seem to
:be a straightforward way to proceed. Subject to working on NFS!

Yes.

:How do Codec names get mapped? Is it expedient at this point to change the way
:that Replay's Header works to allow textual names as well as numbers?

I guess we need some way to register Codec names with the sub modules so you'd
register "RGB" "DIB" and "0x00000000" with the AVI module for uncompressed RGB,
and "raw" with the QT module for RGB.

:Or someone needs to stump up the money for it. Clearly the ability to play an
:AVI/QT file is not the same as the ability to play AVI/QT files which happen
:to use Cinepak!

Indeed. Stumping up cash looked to be very expensive last time Acorn talked to
Radius about it. (Unless Acorn in its new found embrace with Apple can get a
better deal that way...)

:>Hmmm. I will look at the source tonight if I get a chance.
:
:Did you? I think you have reasonably up to date source (you may even notice
:that the sound only files bug is back!) and its not changing rapidly here (we
:are still working on the clipping/painting bits)

I did, but only very breifly. Indications are that it might be OK... More
later.

:Timecode resolves to frames. For the purposes of accurately representing 1/24,
:1/25 and 1/30 of a second it uses 1/1800 as its granularity. Of course, this
:obscures the fact that 1/30 isn't 1/30, but 1/29.97... Yes, I think a
:centisecond resolution on frame times is sensible!

OK.

:You kept saying it was easy.

Did I? I never intended to. In redesigning a system from the ground up I belive
it would be easy, but I appreciate that making changes to existing source can
be a nightmare.

:Seriously, I don't want to put you under pressures which make you
:mis-estimate the time something may take. To synchronise with the NC
:work, we do need to do this on an accurate timescale. If this means
:we have to find more people, its better to know NOW!

Of course.

:But its the less frames potential that is really worrying - if the buffer
:contains too few frames, then the -multi reschedule will mean the foreground
:task resumes after the video has run out.

Surely this can be avoided by just having the background process not reschedule
more times than there are frames? Am I missing something here?

:OK. And the decompressors? This doesn't look like a tricky change in Player -
:if VAL of decomp field is zero, then take string to first space or newline and
:try this as the decomp identifier.

Seems reasonable. Do we take the opportunity to move names fetchers into a new
subdir (77 files and all that)?

:>But I have a very smart partner...
:This sounds like boasting. Or are you attempting to influence Paul?

We coded this redirection thing months ago the night after it was suggested; I
am forever being impressed by the degree of reuse he gets from his code.

It was intended as a solution to the "No filetypes on CDROM" problem, but it
fell down as we could never figure out when to delete the redirection file...

:OK, so there's a reference to the real data, stored in a real file
:which is on a filing system which you hope can be imaged? What
:happens when NFS is the only file system and thus WimpScrap$Dir is
:stored on it????

Well, either a RAM disc, or a full filing system. Paul is working on the full
filing system version I beleive.

   MovieFS##adfs::4.$.xxxx

or however it works...

:But will they wreck it in the process? Changes to Player source is made by
:only a small number of non-monkeys.

Surely the bulldozing should just be a small localised change...

:>But a memcpy that is done between disc accesses - big enough to miss
:>catching the next sector perchance?
:
:Yes, almost certainly. CDROMs are very fussy about how soon the next read
:command is, though modern drives are beginning to be smarter (they use the
:buffer to carry on reading after fulfilling the last request). I suppose it
:will all depend on the average amount of memcpy and which drive is attached.

Ick. Rats.

:>Hell, I never wanted to be Dr Watts anyway...
:Sure you did.

My PhD is in real turmoil at the moment. This is a distinctly uncomfortable
subject.

:>SSSSSSSSFSFSFSFSFSFSFSFSFSFS to be the first chunk,
:>                    SSSSSSSSFSFSFSFSFSFSFSFSFS to be the second
:>                                      SSSSSSSSFSFSFSFSFSFSFSFSFS to be the 3rd
:>etc
:
:Don't understand where all the prefixed SSSSSSSS's come from.

OK. In the first chunk we have

  SSSSSSSSFSFSFSFSFSFSFSFSFSFS
  12345678 9 0

We only actually use the numbered sound data. The remaining sound data has to
be copied into the next chunk... This gives the second chunk as:

               S S S S S S S SFSFSFSFSFSFSFSFSFSFS
               1 2 3 4 5 6 7 8 9 0

Which again needs 8 sound sample data sets copied into the next chunk...

:And can this be predicted in advance (when Player reads the header?)

Well, if we assume Indexed files (and preread those that don't have them - as
we do currently for FLIs), we can predict a chunk size with enough slackness in
it to allow for this.

We (or at least I) hadn't considered loading a slab of data from the disc, and
then indexing it later until yesterday. I have to discuss this with Paul.

OK. I looked at the player source yesterday night at midnight, and found that
(assuming I read the code right) fpf is the variable used to hold frames per
chunk.

This is used in 7 places in the code to calculate:

1) The first chunk to play from.
2) The first sound sample to play from.
3) The number of buffers to use.
4) The number of frames to play invisibly.
5) The end frame.
6) The start frame (I think - what is !rn%? The current frame number?)
7) And the value stored at .run

1, 2, 4 and 6 are given by the call to "set time" in the fetcher.

I think 3 can be calculated based on the figure we pass back as an
approximation.

5 can be returned by the fetcher; we hadn't considered this before, but it
isn't a biggy.

7 - I haven't figured out exactly what 7 is for yet, but I think (i.e. guess)
its the number of frames still to decompress from the current chunk. This can
be passed as part of the index data.

So at first glance it looks doable...

All this is subject to the usual disclaimer of possibly being entirely wrong...

Robin
-------------------------------------------------------------------------------
"We are not at war with Egypt, we are in armed conflict"            Robin Watts
                                          - Sir Anthony Eden
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
At Thu,28 Mar 1996 10:20:01 mail was sent to Robin.Watts@comlab.oxford.ac.uk
and cc'd to paul@fsel.com
About Re: Fetchers
Text:
Here we go again: mega reply to two messages!

]:>This being the case, how do you all feel about a central "MovieFS"
]:>module that other modules register with.
]:
]:Er... slight trepidation, but potentially OK.

]Why trepidation? Because it ties MovieFS into Replay?

Yes.

]:How do Codec names get mapped? Is it expedient at this point to change the way
]:that Replay's Header works to allow textual names as well as numbers?

]I guess we need some way to register Codec names with the sub modules so you'd
]register "RGB" "DIB" and "0x00000000" with the AVI module for uncompressed RGB,
]and "raw" with the QT module for RGB.

Or it really is time to have named codecs as I described before - if VAL of
codec field is 0, then try it as a literal name.

]:Or someone needs to stump up the money for it. Clearly the ability to play an
]:AVI/QT file is not the same as the ability to play AVI/QT files which happen
]:to use Cinepak!

]Indeed. Stumping up cash looked to be very expensive last time Acorn talked to
]Radius about it. (Unless Acorn in its new found embrace with Apple can get a
]better deal that way...)

No, but I might convince Oracle.

]:>Hmmm. I will look at the source tonight if I get a chance.
]:
]:Did you? I think you have reasonably up to date source (you may even notice
]:that the sound only files bug is back!) and its not changing rapidly here (we
]:are still working on the clipping/painting bits)

]I did, but only very breifly. Indications are that it might be OK... More
]later.

Good!

]:You kept saying it was easy.

]Did I? I never intended to. In redesigning a system from the ground up I belive
]it would be easy, but I appreciate that making changes to existing source can
]be a nightmare.

I suppose its different when you're trying to convince me to do it!

]:But its the less frames potential that is really worrying - if the buffer
]:contains too few frames, then the -multi reschedule will mean the foreground
]:task resumes after the video has run out.

]Surely this can be avoided by just having the background process not reschedule
]more times than there are frames? Am I missing something here?

Wrong reschedule: the foreground cooperatively reschedules on buffer fills, the
background tasks on VSync or frame groups (some number of frames, about 3).

]:OK. And the decompressors? This doesn't look like a tricky change in Player -
]:if VAL of decomp field is zero, then take string to first space or newline and
]:try this as the decomp identifier.

]Seems reasonable. Do we take the opportunity to move names fetchers into a new
]subdir (77 files and all that)?

Of course. Probably ARMovie.MovingLine.Fetchers.x

]:>But I have a very smart partner...
]:This sounds like boasting. Or are you attempting to influence Paul?

]We coded this redirection thing months ago the night after it was suggested; I
]am forever being impressed by the degree of reuse he gets from his code.

:-)

]It was intended as a solution to the "No filetypes on CDROM" problem, but it
]fell down as we could never figure out when to delete the redirection file...

And how is that different now?

]:OK, so there's a reference to the real data, stored in a real file
]:which is on a filing system which you hope can be imaged? What
]:happens when NFS is the only file system and thus WimpScrap$Dir is
]:stored on it????

]Well, either a RAM disc, or a full filing system. Paul is working on the full
]filing system version I believe.

]   MovieFS##adfs::4.$.xxxx

]or however it works...

MovieFS:adfs4.dollar.xxxx, probably.

]:But will they wreck it in the process? Changes to Player source is made by
]:only a small number of non-monkeys.

]Surely the bulldozing should just be a small localised change...

:-)

]:>But a memcpy that is done between disc accesses - big enough to miss
]:>catching the next sector perchance?
]:
]:Yes, almost certainly. CDROMs are very fussy about how soon the next read
]:command is, though modern drives are beginning to be smarter (they use the
]:buffer to carry on reading after fulfilling the last request). I suppose it
]:will all depend on the average amount of memcpy and which drive is attached.

]Ick. Rats.

Yes, I got most depressed on CDROMs - Replay worked on harddiscs beautifully
and it took me several months to make it work on a single speed CDROM. They
aren't designed for computer use at all!

]:>Hell, I never wanted to be Dr Watts anyway...
]:Sure you did.

]My PhD is in real turmoil at the moment. This is a distinctly uncomfortable
]subject.

Is there any way I/we can help?

]:>SSSSSSSSFSFSFSFSFSFSFSFSFSFS to be the first chunk,
]:>                    SSSSSSSSFSFSFSFSFSFSFSFSFS to be the second
]:>                                      SSSSSSSSFSFSFSFSFSFSFSFSFS to be the 3rd
]:>etc
]:
]:Don't understand where all the prefixed SSSSSSSS's come from.

]OK. In the first chunk we have

]  SSSSSSSSFSFSFSFSFSFSFSFSFSFS
]  12345678 9 0

You're joking of course! My god, what has gates created?

]We only actually use the numbered sound data. The remaining sound data has to
]be copied into the next chunk... This gives the second chunk as:

]               S S S S S S S SFSFSFSFSFSFSFSFSFSFS
]               1 2 3 4 5 6 7 8 9 0

]Which again needs 8 sound sample data sets copied into the next chunk...

]:And can this be predicted in advance (when Player reads the header?)

]Well, if we assume Indexed files (and preread those that don't have them - as
]we do currently for FLIs), we can predict a chunk size with enough slackness in
]it to allow for this.

]We (or at least I) hadn't considered loading a slab of data from the disc, and
]then indexing it later until yesterday. I have to discuss this with Paul.

(Blasted CDROMs)

]OK. I looked at the player source yesterday night at midnight, and found that
](assuming I read the code right) fpf is the variable used to hold frames per
]chunk.

]This is used in 7 places in the code to calculate:

]1) The first chunk to play from.
]2) The first sound sample to play from.
]3) The number of buffers to use.
]4) The number of frames to play invisibly.
]5) The end frame.
]6) The start frame (I think - what is !rn%? The current frame number?)
]7) And the value stored at .run

]1, 2, 4 and 6 are given by the call to "set time" in the fetcher.

]I think 3 can be calculated based on the figure we pass back as an
]approximation.

]5 can be returned by the fetcher; we hadn't considered this before, but it
]isn't a biggy.

]7 - I haven't figured out exactly what 7 is for yet, but I think (i.e. guess)
]its the number of frames still to decompress from the current chunk. This can
]be passed as part of the index data.

]So at first glance it looks doable...

]All this is subject to the usual disclaimer of possibly being entirely wrong...

Good.

]Robin

]Hi,

]Today being Wednesday, Paul is away from his email, and so he has just phoned
]me with a potential problem, and asked me to mail you about it. Any errors or
]unclear bits in the following are probably my fault in the speech -> concept ->
]text conversion process :-)

]-------
]1st question:

]What is a typical number of disc buffers used by the current ARMovie setup?

Replay Player's disc IO is double buffered, however in desperate straights
each buffer contains two chunks (i.e. the read block size is doubled). Each
buffer fill is compiled into a single GBPB call (unless the access parameter
for the drive is >1 when it makes lots of calls!). For CDROM and NFS access
is usually 0 (double chunks), though it can be pushed to 1 (single chunks).

]-------
]Consider a modified (fetchered) ARMovie playing a film in the case where we
]have 2 such buffers.

]While playing a film we are in a state where we have just finished loading the
]first disc buffer. We cannot load into the second buffer though until the first
]frame has been indexed (because until then there might still be data to copy
]from the second buffer back into the first).

Yes, this is the point of the chunk index - Player can dispatch the next GBPB
call immediately it completes the previous one. If you don't do this, then a
number of single/double speed drives with poor internal caching policies will
not work. This may be a price we have to pay if you can see no way around the
problem of having to index the slab that has just been loaded in order to load
the next one.

]The first slabs data is then "interpreted" (i.e. the indexes are generated, and
]part frames/excess sound etc is copied). At this point:

]1) We are now free to decompress these frames.
]2) The second buffer becomes free, by which time we have missed the next
]rotation.

yes. For the bad drives you have to recommand in the inter sector gap! For the
better drives, any time in the next sector will do - depending on the drive
this is up to 1/75 of a second (single speed - divide by the drive's speed).

]----------

]Now, this means we don't actually gain anything in the 2 disc buffer case by
]moving the Interpretation phase out of the foreground.

]To restate it, rather than each buffer being locked only by the frame data that
]is within them, they are also locked to the next buffer until the part frame
]data within them is copied forwards.

Which means you need to make the program have at least three buffers - that's a
large amount of extra memory use (300K or so more for a single speed CDROM).

]If ARMovie habitually runs with 2 disc buffers this is a problem. If with more,
]this may not be such a big deal.

]Do you have any ideas on this?

No. But this doesn't mean there aren't any, it just means I've spent too long
on the existing Player way of doing it to think of anything new!

]Robin

--Sophie

-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Thu, 28 Mar 1996 13:56:14 +0000 (GMT)
Cc: paul@formal.demon.co.uk

In some randomly numbered message, Sophie Wilson said:
:
:Or it really is time to have named codecs as I described before - if VAL of
:codec field is 0, then try it as a literal name.

But this doesn't solve the problem... Take for example the RGB 8 codec. This is
referred to by 3 different names in AVIs, and at least 1 different name in
Quicktimes. Rather than having 3 copies of the same decompressor on disc, we
want to be able to say "Associate "RGB ", "DIB " and 0x00000000 in AVIs and
"raw " in Quicktimes with decompressor "RGB8".

[CinePak]
:No, but I might convince Oracle.

Indeed. I *think* the figure quoted to Acorn included Radius actually doing the
port of both a compressor and decompressor. They might be prepared to lower
that a lot if they know they have no actual work to do.

:]Did I? I never intended to. In redesigning a system from the ground
:]up I belive it would be easy, but I appreciate that making changes
:]to existing source can be a nightmare.
:
:I suppose its different when you're trying to convince me to do it!

No, I am serious here. I never said it was easy. I merely believe that it is
theoretically possible (but whether it is practically possible in the time is a
good question), and a very desiarable thing to have.

:Wrong reschedule: the foreground cooperatively reschedules on buffer
:fills, the background tasks on VSync or frame groups (some number of
:frames, about 3).

I still don't see why the player can't avoid rescheduling if it knows there
aren't enough frames?

:]Seems reasonable. Do we take the opportunity to move names fetchers
:]into a new subdir (77 files and all that)?
:
:Of course. Probably ARMovie.MovingLine.Fetchers.x

Sorry. I meant Decompressors...

:]We coded this redirection thing months ago the night after it was
:]suggested; I am forever being impressed by the degree of reuse he
:]gets from his code.
:
::-)

Rats. Reading this back I have spotted a typo - it should be "He", not "We".

:And how is that different now?

Its not, but with the closer relationship with Replay this may be more soluble.
The real filing system solution may also help here - but there may well still
be problems with "old" apps working with new movie files...

(but there may be a way around this by trapping some FS entry points on NFS,
now I come to think of it...)

:]My PhD is in real turmoil at the moment. This is a distinctly uncomfortable
:]subject.
:
:Is there any way I/we can help?

I don't think so. Basically the PhD has lost out to WSS over the past 2 years,
and so I am playing catch up in a big way...

:You're joking of course! My god, what has gates created?

I wish...

:Replay Player's disc IO is double buffered, however in desperate straights
:each buffer contains two chunks (i.e. the read block size is doubled). Each
:buffer fill is compiled into a single GBPB call (unless the access parameter
:for the drive is >1 when it makes lots of calls!). For CDROM and NFS access
:is usually 0 (double chunks), though it can be pushed to 1 (single chunks).

Rats. This is a problem then.

:Yes, this is the point of the chunk index - Player can dispatch the next GBPB
:call immediately it completes the previous one. If you don't do this, then a
:number of single/double speed drives with poor internal caching policies will
:not work. This may be a price we have to pay if you can see no way around the
:problem of having to index the slab that has just been loaded in order to load
:the next one.

Yeah.

:yes. For the bad drives you have to recommand in the inter sector gap! For the
:better drives, any time in the next sector will do - depending on the drive
:this is up to 1/75 of a second (single speed - divide by the drive's speed).

Do we have any idea what proportion of "bad drives" we have out there?

As I see it there are 2 distinct actions involved in the indexing as described
at the moment.

First we have to produce an index, then we have copy any leftover data forward.

An alternative would be just to calculate how much data is going to be copied
forwards, and then use this as an offset into the buffer to load to.

For instance suppose the buffer we have just loaded contains

SSSSSFSFSFSFSFSFSFSFSF
            * * * * *

where the last F hasn't been completely loaded. Then by calculating the size of
the sections marked by *'s above to be xxxx, we can start the fetch of the next
chunk at offset xxxx into the next buffer, and copy the *'s over in the
background.

This will give us response well within the 1/75th of a second, but whether it
will be good enough to reschedule within the inter sector gap is anyones guess.

:Which means you need to make the program have at least three buffers
:- that's a large amount of extra memory use (300K or so more for a
:single speed CDROM).

Indeed. The scheme I have just outlined trades this off for a slightly greater
between-seeks workload.

:No. But this doesn't mean there aren't any, it just means I've spent too long
:on the existing Player way of doing it to think of anything new!

OK. This is "blue sky" here, so it may not be practical in the timescale...

Suppose we dump chunks entirely, and just have a disc buffer, guaranteed to be
big enough to hold enough space for the amount of sound data that is sent
before the video starts, plus a couple of frame/sound pairs of data.

We could then do a series of fetches (in sector or bigger sized blocks) in the
foreground treating it as a cyclic buffer. These fetches would only block if
the next slab they would read would overwrite some as yet undealt with data in
the buffer.

The decompress phase of ARMovie could then decompress from this buffer, and
keep a "Low water mark" of the active region. The fetchers would continually
push a "High water mark" forwards.

This would eliminate the need for us to ever do any copying of data (except in
the case when we reach the end of the buffer, when we would need to copy the
part data set to a previously allocated bit of space just before the start of
the buffer.

(maybe this copy could be eliminated with some cunning memory mapping - I don't
know enough about this).

The fetches could always reschedule immediately, and we wouldn't be forced into
having to know an index of frames...

The downside of course is that this is a major (total?) rewrite of the player,
and relies on files working in an inherently sequential way.

Robin
-------------------------------------------------------------------------------
Famous last words: Sir James Graham                                 Robin Watts
(British statesman, died 1861. As he rested after a heart attack...)
"Ah! I thought it was all over then."

From: Paul Gardiner <paul@fsel.com>
Date: Thu, 28 Mar 1996 09:09:35 GMT
To: SWilson
CC: Robin.Watts@comlab.oxford.ac.uk

Sorry I've gone quiet. Replying to all these messages hasn't been commensurate
with my workload over the last few days (:-)).

I should be able to have a look tonight.

Cheers,
        Paul.

From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Fetchers (what else? :-) )
To: SWilson (Sophie Wilson)
Date: Fri, 29 Mar 1996 16:28:45 +0000 (GMT)

Hi again,

Once again Paul is away from his mail, so it falls to me to forward one of his
ideas. Usual providos about my ineptitude at describing things apply...

For now lets assume that all files are indexed. (This is not unreasonable as it
will be merely require us to pre read unindexed files as we do now; its
undesirable, but not prohibitive).

Paul suggests a situation where we run the fetchers and interpreters in
parallel.

The current situation in ARMovie is that the disc fetcher is in the foreground,
and the decompress/paint/sound run in the background on interrupt (in
increasing order of priority).

Paul suggests inserting another layer into this situation, where we have the
fetcher in te foreground, and interpret/decompress/paint/sound on interrupt.

First thing we do is kick of a disc fetch. As this loads from the disc, the
fetcher already knows the positions of the data within the file (because we
have an indexed file by our earlier assumption). In the background therefore we
can copy left over data forwards from the previous disc buffer, and then make
an index of where the data will be in the buffer when the disc fetch
terminates.

By the time the disc fetch is over therefore we have already:

1) copied any leftover data from the other buffer into the new one
2) generated the index for the new buffer.
3) calculated how much data needs to be copied forwards into the next buffer.

We can then immediately kick off a fetch in the foreground again.

Neither I nor Paul can see any holes in this. Can you?

Robin (desperately hoping he catches Sophie before the weekend)
-------------------------------------------------------------------------------
Social Services Letter (Greenville County):                         Robin Watts
"Your food stamps will be stopped effective March 1992, because
 we have received notice that you passed away. May God bless you.
 You may reapply if there is a change in your circumstances."

-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Fri,29 Mar 1996 17:34:40 mail was sent to Robin.Watts@comlab.oxford.ac.uk
and cc'd to paul@fsel.com
About Re: Fetchers
Text:
>Hi again,

>Once again Paul is away from his mail, so it falls to me to forward one of his
>ideas. Usual providos about my ineptitude at describing things apply...

Fishing for compliments?

>For now lets assume that all files are indexed. (This is not unreasonable as it
>will be merely require us to pre read unindexed files as we do now; its
>undesirable, but not prohibitive).

OK.

>Paul suggests a situation where we run the fetchers and interpreters in
>parallel.

I'd have put the interpretation between Replay and the codec i/f so that it
could be distributed and always calculated just in time (one might have to have
a pipeline here where the decompression and interpretation were for different
buffers...) Let's go on with you idea:

>The current situation in ARMovie is that the disc fetcher is in the foreground,
>and the decompress/paint/sound run in the background on interrupt (in
>increasing order of priority).

Only if CBAI is in there. Currently it isn't, since if noone but Replay uses it
there's no advantage to using it. (and I got sick of maintaining two versions
of the master code, so getting CBAI back is more than a 1 second decisions).
Without CBAI the decompress/paint/sound run at equal levels of priority off the
interrupt and rely on some cunning about when interrupts are reenabled to
ensure completion will actually happen.

>Paul suggests inserting another layer into this situation, where we have the
>fetcher in the foreground, and interpret/decompress/paint/sound on interrupt.

OK: it does look as though interpretation must be moved out of the path of
starting the next disc GBPB operation. And moving it to the background is the
only place for it!

>First thing we do is kick of a disc fetch. As this loads from the disc, the
>fetcher already knows the positions of the data within the file (because we
>have an indexed file by our earlier assumption). In the background therefore we

which is how you arrive back at the same place as ARMovie files - there are
chunks in the world, kiddies.

>can copy left over data forwards from the previous disc buffer, and then make
>an index of where the data will be in the buffer when the disc fetch
>terminates.

yes. Actually there is another place to insert this - the thing which gives the
sound data to the sound code (also in the background in Player for very similar
reasons (plus the interlock problem - if you can't give sound data now because
the sound code hasn't quite finished playing what it already has, then you
still want to start the next disc operation).

>By the time the disc fetch is over therefore we have already:

>1) copied any leftover data from the other buffer into the new one
>2) generated the index for the new buffer.
>3) calculated how much data needs to be copied forwards into the next buffer.

You have to put in a fail safe interlock, though. The give sound data code may
fail to work (e.g. the movie is paused) and this has to eventually feed back to
the disc io. (and this might also affect your interpretation process since it
will still have a lock requiring data in the buffer to be left alone)

>We can then immediately kick off a fetch in the foreground again.

Yes.

>Neither I nor Paul can see any holes in this. Can you?

No. All the world is indexed (or do I mean chunked?)

>Robin (desperately hoping he catches Sophie before the weekend)

You did. Have a good one, it was supposed to be sunny.

--Sophie

Chief Scientist at Acorn Network Computing: ddi Cambridge (UK) 1223 518550

| Words are like rocks: they weigh you down.          |
| If birds could speak, they wouldn't be able to fly. |

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Fri, 29 Mar 1996 18:10:01 +0000 (GMT)

In some randomly numbered message, Sophie Wilson said:
:
:>Once again Paul is away from his mail, so it falls to me to forward
:>one of his ideas. Usual providos about my ineptitude at describing
:>things apply...
:
:Fishing for compliments?

No. Just trying to avoid making Paul look a wally when I misunderstand his
explanation and explain something totally different (and more stupid) to you.

I think perhaps you read to much subtlety into what I write :-/ WYSIWYG and all
that.

:>Paul suggests a situation where we run the fetchers and interpreters in
:>parallel.
:
:I'd have put the interpretation between Replay and the codec i/f so
:that it could be distributed and always calculated just in time (one
:might have to have a pipeline here where the decompression and
:interpretation were for different buffers...) Let's go on with you
:idea:

:>The current situation in ARMovie is that the disc fetcher is in the
:>foreground, and the decompress/paint/sound run in the background on
:>interrupt (in increasing order of priority).
:
:Only if CBAI is in there. Currently it isn't, since if noone but
:Replay uses it there's no advantage to using it. (and I got sick of
:maintaining two versions of the master code, so getting CBAI back is
:more than a 1 second decisions).  Without CBAI the
:decompress/paint/sound run at equal levels of priority off the
:interrupt and rely on some cunning about when interrupts are
:reenabled to ensure completion will actually happen.

I'm regretting mentioning the priorities now...

OK, but as I understand it the net effect (or net desired effect at least) is
that a decompress will never interrupt a paint or soundfill, the paint will
never interrupt a sound fill, and (obviously) the decompress will never
interrupt anything.

:OK: it does look as though interpretation must be moved out of the path of
:starting the next disc GBPB operation. And moving it to the background is the
:only place for it!

Yes.

:which is how you arrive back at the same place as ARMovie files - there are
:chunks in the world, kiddies.

Yes, but at a later date we may be able to rework the solution to avoid the
constant frames per chunk requirement. We can avoid it for now (and hence the 2
month deadline seems more easily achievable), but we keep our options open in
future.

:yes. Actually there is another place to insert this - the thing which
:gives the sound data to the sound code (also in the background in
:Player for very similar reasons (plus the interlock problem - if you
:can't give sound data now because the sound code hasn't quite
:finished playing what it already has, then you still want to start
:the next disc operation).

OK. I don't know enough to see the relative benefits. Exactly where the routine
is called is a matter for the discussion, but the final decision will probably
be down to whoever changes Player.

:>By the time the disc fetch is over therefore we have already:
:[Snip]
:You have to put in a fail safe interlock, though. The give sound data
:code may fail to work (e.g. the movie is paused) and this has to
:eventually feed back to the disc io. (and this might also affect your
:interpretation process since it will still have a lock requiring data
:in the buffer to be left alone)

Yes.

:No. All the world is indexed (or do I mean chunked?)

Indexed. Not chunked. We can write fetchers for which Indexed => Chunked at the
moment, but we can look at removing that restriction later to get better
performance.

:You did. Have a good one, it was supposed to be sunny.

Unlikely. My grandfather has just been rushed to hospital...

Robin
-------------------------------------------------------------------------------
A 9th Graders homework - Using a given word in context:             Robin Watts
Hotel: "I gave my girlfriend da crabs and the hotel everybody."
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Fri,29 Mar 1996 18:15:39 mail was sent to Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
]:>Once again Paul is away from his mail, so it falls to me to forward
]:>one of his ideas. Usual providos about my ineptitude at describing
]:>things apply...
]:
]:Fishing for compliments?

]No. Just trying to avoid making Paul look a wally when I misunderstand
]his explaination and explain something totally different (and more
]stupid) to you.

Hah.

]I think perhaps you read to much subtlety into what I write :-/
]WYSIWYG and all that.

Poking fun...

]:>Paul suggests a situation where we run the fetchers and interpreters in
]:>parallel.
]:
]:I'd have put the interpretation between Replay and the codec i/f so
]:that it could be distributed and always calculated just in time (one
]:might have to have a pipeline here where the decompression and
]:interpretation were for different buffers...) Let's go on with you
]:idea:

]:>The current situation in ARMovie is that the disc fetcher is in the
]:>foreground, and the decompress/paint/sound run in the background on
]:>interrupt (in increasing order of priority).
]:
]:Only if CBAI is in there. Currently it isn't, since if noone but
]:Replay uses it there's no advantage to using it. (and I got sick of
]:maintaining two versions of the master code, so getting CBAI back is
]:more than a 1 second decisions).  Without CBAI the
]:decompress/paint/sound run at equal levels of priority off the
]:interrupt and rely on some cunning about when interrupts are
]:reenabled to ensure completion will actually happen.

]I'm regretting mentioning the priorities now...

]OK, but as I understand it the net effect (or net desired effect at
]least) is that a decompress will never interrupt a paint or soundfill,
]the paint will never interrupt a sound fill, and (obviously) the
]decompress will never interrupt anything.

Yes.

]:OK: it does look as though interpretation must be moved out of the path of
]:starting the next disc GBPB operation. And moving it to the background is the
]:only place for it!

]Yes.

]:which is how you arrive back at the same place as ARMovie files - there are
]:chunks in the world, kiddies.

]Yes, but at a later date we may be able to rework the solution to
]avoid the constant frames per chunk requirement. We can avoid it for
]now (and hence the 2 month deadline seems more easily achievable), but
]we keep our options open in future.

Yes, your indexes have variable frames per chunk and arbitrarily positionned
components withing a chunk. This is superior (and complicated).

]:yes. Actually there is another place to insert this - the thing which
]:gives the sound data to the sound code (also in the background in
]:Player for very similar reasons (plus the interlock problem - if you
]:can't give sound data now because the sound code hasn't quite
]:finished playing what it already has, then you still want to start
]:the next disc operation).

]OK. I don't know enough to see the relative benefits. Exactly where
]the routine is called is a matter for the discussion, but the final
]decision will probably be down to whoever changes Player.

Step forward and take a bow, Robin.

]:>By the time the disc fetch is over therefore we have already:
]:[Snip]
]:You have to put in a fail safe interlock, though. The give sound data
]:code may fail to work (e.g. the movie is paused) and this has to
]:eventually feed back to the disc io. (and this might also affect your
]:interpretation process since it will still have a lock requiring data
]:in the buffer to be left alone)

]Yes.

]:No. All the world is indexed (or do I mean chunked?)

]Indexed. Not chunked. We can write fetchers for which Indexed =>
]Chunked at the moment, but we can look at removing that restriction
]later to get better performance.

OK. I'm just smug at arriving back somewhere near where I started.

]:You did. Have a good one, it was supposed to be sunny.

]Unlikely. My grandfather has just been rushed to hospital...

I'm sorry to hear that. Best wishes for a speedy recovery.

]Robin

--Sophie

Chief Scientist at Acorn Network Computing: ddi Cambridge (UK) 1223 518550

| Words are like rocks: they weigh you down.          |
| If birds could speak, they wouldn't be able to fly. |

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Fri, 29 Mar 1996 18:27:19 +0000 (GMT)

In some randomly numbered message, Sophie Wilson said:
:
:Poking fun...

Sounds like a book on programming the Commodore 64 in BASIC...

:Yes, your indexes have variable frames per chunk and arbitrarily positionned
:components withing a chunk. This is superior (and complicated).

Complicated? As in "overly complicated" or "more complicated, but copable with"
- do you see something here we are missing?

:]OK. I don't know enough to see the relative benefits. Exactly where
:]the routine is called is a matter for the discussion, but the final
:]decision will probably be down to whoever changes Player.
:
:Step forward and take a bow, Robin.

Oh, thanks :-)

:OK. I'm just smug at arriving back somewhere near where I started.

:-)

:I'm sorry to hear that. Best wishes for a speedy recovery.

Thanks,

Robin
-------------------------------------------------------------------------------
Huddled in the safety of a Pseudo-silk Kimono,                      Robin Watts
wearing bracelets of smoke, naked of understanding.

From: Paul Gardiner <paul@fsel.com>
Date: Mon, 1 Apr 1996 08:43:05 GMT
To: SWilson
CC: Robin.Watts@comlab.oxford.ac.uk
Subject: Re: Fetchers

Hi Sophie,

Looking at past email, it seems as though we have a workable fetchers interface
now. I've tried to write down my understanding of it below.

Cheers,
  Paul.

Robin's out of action for a few days (had to go home because of his
grandfather's illness).

-----------------------------------------------------------------------------

Fetchers: attempt at consolidation
----------------------------------

General
-------
Moving away from chunks looks really hard, so we have to make fetchers fake
them. Having Robin look at removing the constant frames-per-chunk condition
sounds worth a try (I've known him achieve equally unlikely goals), but none of
us want to put this on the critical path, especially Robin. The real pain for
us is that we still don't get to play FLIs without pre-reading, which was one
of our main hopes from using fetchers, but we'll survive :-(

Fetchers have to be more knowledgeable about the structure of films in the
chunked world. So it looks as though both the header generator (i.e., MovieFS)
and the fetcher need to analyse the film in detail (involving disc access) in
order to do their jobs. A way to have this analysis performed only once is to
set up a communication path from the header generator to the fetcher. That can
be achieved almost transparently to Replay by just retaining a catalogue-like
thing (even in the fetchers universe) and having Replay pass its offset to the
fetcher rather than trying to use it itself.

The way this works is by MovieFS, as well as faking the header, faking other
info concerning the file. The fetcher can read this extra info (the read
reducing to memory access) and save itself the trouble of deriving the
information for itself. Replay doesn't need to know anything about all this
except in passing the offset to the fetcher. In a way this is one less
departure from the old Replay: files still have catalogues, but their contents
are no longer any of Replay's business.

Possibly in the chunked universe it makes sense for Replay to ask for chunks by
number. I've worked that idea into the fetchers interface, but you or Robin may
have arguments against that move. As far as I can see, it again avoids change
to Replay: the current versions of Replay must index the chunk catalogue, so
the new version could just pass the index to the fetcher. We can also drop the
SetTime entry point: Replay must already work out which chunk it needs.

I'm absolutely certain that rewriting all the sound code is the right thing to
do ... one day ... long after our deadline. For now, the idea of having us
doing the change, or bringing other people in worries me. My preference is for
Replay to keep extra buffers, and where it would have just called the sound
code, it can first copy all the disconnected chunks into the buffer and then
call the sound code. If the structure of Player makes that very difficult, then
I'd much rather see the fetchers doing the job than go for the sound-code
rewrite option in the short time we've got.

File recognition.
----------------
We've fixed on the faking of ARMovie headers via some sort of MovieFS look
alike. That means recognition is easy, as far as Replay and Old Apps are
concerned: "Its got an ARMovie header on it so it must be one of mine".

Of course, the recognition problem hasn't disappeared its just moved back into
MovieFS, but there it looses the status of being a defined interface to Replay,
so the exact method doesn't have to be agreed as part of this current work, I
hope! (I rather like the solution Robin proposed, but promising that within the
two month deadline worries me.)

What I imagine for the first cut is a hacked (I mean carefully re-crafted >8*))
MovieFS that takes on two roles: it does the now simpler ARMovie faking (just
put a header on it); it also acts as a universal fetcher, called via a veneer
that would live in Replay's Fetcher directory. ("universal" meaning "handling
all the formats MovieFS currently handles".)

That would provide a Replay that was extensible in terms of adding fetchers,
but a combined MovieFS/Replay system that wasn't immediately extensible in
terms of recognition (unless something else generates the header, of course).
Is that enough for the two-month deadline?

The separate header file and data file idea seems to have little value, so
MovieFS should provide one file, with the data moved forward to make room for
the header (your suggestion years ago if I remember rightly).

NFS shouldn't be a problem assuming the method used by SparkFS works. You
should be able to view the contents of a sparkive across NFS by saying

*Filer_OpenDir SparkFS#<substitute # for : in pathname>:$

If that doesn't work then we're in trouble: it may be back to redirection
through RamFS, or drop the faking of headers altogether. If it does work then
there's no need for anything drastic (no need for any smartness on my behalf,
for example :-) ).

Header contents.
----------------
Headers don't change at all, except for the catalogue index gaining a fetcher
reference.

There was something about allowing decompressor names after a 0. Can't see any
problem with that.

Fetcher interface
-----------------
The main problem with initial suggestions was having Fetch do too much,
particularly the copying from the last buffer. Having Fetch interpret the
freshly loaded buffer isn't a problem in the chunked universe, because the call
to Open can have planned everything down to the last byte, but the copying
needs to be done in background during the fetch. We could name the new copying
entry point ReleaseLastBuffer, because that's what it does. Replay calls Fetch
to fill the new buffer, and arranges for ReleaseLastBuffer to be called in
background to make it safe to refill the previous buffer.

That scheme also allows us some room to experiment in the future with unindexed
files: we could write a fetcher for FLIs that thumbs its nose at disc access,
and does everything in the call to Fetch, which means no info is needed up
front. ReleaseLastBuffer could return immediately, in the knowledge that
Replay won't reuse the last buffer until the current fetch finishes. (Also, we
could cludge the too-few-frames problem by filling in with null frames.)

Three entry points: Open, Fetch, ReleaseLastBuffer, Close.

Open:
On Entry:       R0=file handle
                R1=catalogue offset
On Exit:        ---

Does what ever it needs to in readiness for calls to Fetch. Free to allocate
memory; may load a module.


Fetch:
On Entry:       R0=chunk number
                R1=address of buffer
On Exit:        R0=Pointer to Frame Index
                R1=Pointer to Sound Index

Fills the buffer and returns a description of the information it has loaded
(positions of frames and chunks of sound).

The frame index has the form:

Offset:         0       Frame 1 start
                4       Frame 2 start
                ...

A frame address of 0 can be used to inform the codec of a null frame and that
it just needs to copy the old frame buffer to the new one.

The sound index has the form:

Offset:         0       Number of sound chunks
                4       Start of sound chunk 1
                8       Size of sound chunk 1
                12      Start of sound chunk 2
                16      Size of sound chunk 2
                ...

ReleaseLastBuffer:
On Entry:       R0=chunk number
                R1=address of buffer (destination buffer)
On Exit:        ---

Copies across info from the last buffer. It may not need the values in R0 and
R1; they should be derivable by looking at the Fetch that's being interrupted,
but what if Replay's scheduling misses. Does Replay's scheduling ever miss?  In
any case, it might be useful for Replay to have the freedom to call Fetch and
ReleaseLastBuffer sequentially, where its not time critical.

Close:
On Entry:       ---
On Exit:        ---

Shuts down fetcher.
(I'm sure this ones wrong :-) )

---------------------------------------------------------------------------

Problems
--------

None. Its perfect :-)


Actually:
The fetchers will need buffers that have room for the disc fetch and the
copying. Does Replay use the buffer sizes to estimate fetch time or anything?
If so it will get an overly large result.

From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers (fwd)
To: paul@formal.demon.co.uk, SWilson (Sophie Wilson)
Date: Mon, 1 Apr 1996 15:42:49 +0100 (BST)

Hi,

In some randomly numbered message, Paul Gardiner said:
:
:Robin's out of action for a few days (had to go home because of his
:grandfather's illness).

Actually, I'm leaving this evening, so I'm still here at the moment...

:Moving away from chunks looks really hard, so we have to make fetchers
:fake them.  Having Robin look at removing the constant
:frames-per-chunk condition sounds worth a try (I've known him achieve
:equally unlikely goals), but none of us want to put this on the
:critical path, especially Robin.

Very true!

:The real pain for us is that we still don't get to play FLIs without
:pre-reading, which was one of our main hopes from using fetchers, but
:we'll survive :-(

Do we have to have "frozen" any of the interfaces after the 2 month period, or
will we be able to slightly bend them after that?

:A way to have this analysis performed only once is to set up a
:communication path from the header generator to the fetcher.  That
:can be achieved almost transparently to Replay by just retaining a
:catalogue-like thing (even in the fetchers universe) and having
:Replay pass its offset to the fetcher rather than trying to use it
:itself.

Hmmm... This is another interface. (one I hadn't considered before).

If we have to create this interface, I can see an arguemnt for putting this in
the file as well... So far we have maintained the possibility for films to be
"copied out", and this might be worth keeping. Currently this is primarily
useful for people that don't want the MovieFS buffer overhead, but this will be
much smaller with fetchers...  What do you both think about this?

:In a way this is one less departure from the old Replay: files still
:have catalogues, but their contents are no longer any of Replay's
:business.

This parallel supports my arguement that when a fetcher is used, the Catalogue
is just somewhere else in the file in a format specific to a given fetcher.
This is another problem on the plate of whoever gets to change Player.

On the other hand this flags a warning as another thing we need to allocate
memory (possibly quite a lot of memory) for. Having the fetcher work it out for
itself seems to have some attractions. (Not least in that it avoids morehacking
of Player.)

:Possibly in the chunked universe it makes sense for Replay to ask for
:chunks by number.

Probably sensible.

:I'm absolutely certain that rewriting all the sound code is the right thing
:to do ... one day ... long after our deadline.

Yes.

:For now, the idea of having us doing the change, or bringing other
:people in worries me.  My preference is for Replay to keep extra
:buffers, and where it would have just called the sound code, it can
:first copy all the disconnected chunks into the buffer and then call
:the sound code.

I looked the the player source last night, and this looks doable... (Subject to
usual disclaimer).

:(I rather like the solution Robin proposed, but promising that within
:the two month deadline worries me.)

This goes back to what I said about do the interfaces have to be frozen after 2
months or do we just need to be able to take a working snapshot that can be
refined later?

:That would provide a Replay that was extensible in terms of adding
:fetchers, but a combined MovieFS/Replay system that wasn't immediately
:extensible in terms of recognition (unless something else generates
:the header, of course).  Is that enough for the two-month deadline?

OK. We need to talk about this.

At the meeting we had with Stewart and Neil ages ago, we talked about a
possible business model for the way this would work.

The consensus at the end of the meeting was that we would work together to
produce:

1) a version of MovieFS capable of recognising AE7, and AVI Indeo files
2) a fetcher for Indeo files.
3) a fetcher for AE7 files
4) a version of MovieFS
5) a decompressor for Indeo data
6) Fetchers for other types of data
7) decompressors for other types of data
8) A MovieFS capable of being extended.

1,2,3,4,5 of these were to be licensed in a 1 off deal to Acorn for them to
distribute as they saw fit (within the desktop market). (Presumably this still
holds, just without 5, as this is being done elsewhere).

The idea was then that we would market 6,7,8 ourselves.

The STB/NC market was specifically excluded from our discussion.

This means that:

1) The standard version of Replay can play AVI Indeo files efficiently.
2) Replay is extensible in decompressors.
3) Replay is extensible in fetchers (subject to the "extender" licensing the
full MovieFS from us).

Most importantly (for us) anyone wanting to extend Replay by providing new
fetchers would need to license the full MovieFS module from us. This was felt
to be a reasonable compromise between us losing our "sole provider" (*) status,
and Acorn getting access to new formats.

Now, how you (Sophie) feel about this? This does tie ARMovie into a cutdown
(and less extensible) MovieFS. If you feel this is inappropriate then we need
to rediscuss this with Stewart on Wednesday.

:Headers don't change at all, except for the catalogue index gaining a
:fetcher reference.

OK. If you intend to allow films to be copied out (and it seems hard to see how
MovieFS can avoid this), then you can't just have an address in the film; it
might be replayed on a computer not using MovieFS, and that address would mean
nothing. This seems to militate a solution with the index in the file.

:There was something about allowing decompressor names after a 0.
:Can't see any problem with that.

Not quite. I think Sophie was advocating a hack^H^H^H^Htrick relying on the
behaviour of VAL in BASIC.

For instance:

VAL "FRED" = 0

(If I was doing it in C, I'd have used fscanf :-))

:The fetchers will need buffers that have room for the disc fetch and the
:copying.  Does Replay use the buffer sizes to estimate fetch time or
:anything?  If so it will get an overly large result.

Not as far as I understand it (though obviously Sophie can confirm/deny this.)

Robin

(* Apologies for bringing Michael Bolton into it...)
-------------------------------------------------------------------------------
Relax, Have a Cigar, Make yourself at home.                         Robin Watts
Hell is full of High Court Judges, Failed Saints.
We've got Cardinals, Archbishops, Barristers,
Certified Accountants, Music Critics, They're all here.

rom: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Fetchers
To: SWilson (Sophie Wilson)
Date: Thu, 4 Apr 1996 12:43:09 +0100 (BST)

Hi,

We had a meeting yesterday with Stewart at which we came to a conclusion that
looks like we can make a version of ARMovie/MovieFS that will satisfy both you
and him. The only slightly worrying thing is the timescale. He has a similar
deadline to you, and wants extensibility in recognition as well (whereas we had
agreed that you didn't need that for the version we are prototyping within the
2 month period.) This means we have more work to squeeze in at our end (but
hopefully not an unacheivable amount).

What we need to decide now is who will make the required changes to player.

You said at the beginning that you were prepared to do some coding, but not a
huge rewrite. Given that you said "I'm just smug at arriving back somewhere
near where I started", does that mean you consider the changes to Player to be
small enough that you will make them?

Changes I see neded in Player:

1) Recognise a "Fetcher" line somewhere in the header.
2) Load the fetchers.
3) Call open movie at start.
4) Call fetcher code in foreground.
5) Call "release last buffer" in background".
6) Call close Movie at end.
7) Write some code to bulldoze sound into buffers within Replay.

(I guess another question is "do we treat AE7 files as special case, or do we
write an AE7 fetcher?"; probably down to you to decide...)

While I think I now have a fairly good grasp of what Player is doing, it will
still be significantly more difficult for me to make the changes to Player than
for you, as you have far more familiarity with the code than I could ever have.
There is potential for me to get horribly bogged down here and make the time
scales impossible to meet.

Paul is away next week, so if the job of changing Player was to be left to me,
I would want to try and do as much as possible in that time...

I guess what I want to hear is "Don't worry Robin, I'll do it." :-)

Robin

-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Thu,04 Apr 1996 13:07:17 mail was sent to Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
OK, let's look at this bit by bit:

1) Recognise a "Fetcher" line somewhere in the header.

Easy. I will do this.

2) Load the fetchers.

Set ARMovie$CacheFetchxxx
allocate memory
*load <ARMovie$Dir>.MovingLine.Fetchers.xxx

Somewhat more amusing, but still easy. I will do this.

3) Call open movie at start.

CALL fetcher_open,filehandle,catoffset

4) Call fetcher code in foreground.

CALL fetcher_fetch,chunk,buff TO frameindexptr,soundindexptr

(didn't you want the address of the previous buffer???)
(what about the filehandle?)

Nominally easy, but also requires the frame index work in the relevant bit of
Player (trying to hide the bad news?). Plus Player calls this routine from at
least two places. Plus what do you do about the access parameter???? I will do
this provided there are a fixed number of frames in a chunk - otherwise its
over to you.

5) Call "release last buffer" in background.

CALL fetcher_release,chunk,buff
(filehandle?)

What are the calling conditions (processor mode, interrupt status) for this?
Its most natural to call this after the video decompressor has decompressed the
last frame in the index list - this currently happens with interrupts disabled
in IRQ mode, which has a critical processing time... There's also a complication
in that this bit of Player has no idea of chunk (or frame) numbers, but I guess
I can do something about that.

OK, I can do that.

6) Call close Movie at end.

CALL fetcher_close
(filehandle?)

OK, I can do that.

7) Write some code to bulldoze sound into buffers within Replay.

Another ugly. The real problem is when to do it, the secondary problem is the
extra store and CPU it takes.

OK.


Now to me it looks like around a week's work, all things considered. Plus
testing, reimplementation as we choose new routes and the odd fatal error. Plus
documentation etc.

But, yes, I think it will fit.

Note that the interfaces will end up frozen and intransigent - it will be nasty
to introduce new things with the possible exception of sound buffer fill
routines that take linked lists. Variable number of frames per chunk will still
be over the horizon. I don't know if leaving Player with all the code for
ARMovie style chunks or moving it out to a Fetcher is the best idea. I expect
it will stay inside Player (inertia rules) since its quite small.

There is one thing we've not mentionned so far: Player and CompLib both know
how to extract frames without reading the whole chunk. Can we add a

CALL fetcher_getframe,chunk,buff,frame

to support this. For predictably compressed movies, this is good!

--Sophie

Chief Scientist at Acorn Network Computing: ddi Cambridge (UK) 1223 518550

| Words are like rocks: they weigh you down.          |
| If birds could speak, they wouldn't be able to fly. |


+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Thu, 4 Apr 1996 13:56:18 +0100 (BST)

In some randomly numbered message, Sophie Wilson said:
:
:(didn't you want the address of the previous buffer???)

Nope. We know where the previous buffer was... We just need a guarantee that it
will still be intact.

:(what about the filehandle?)

Again we probably know that too.

:Nominally easy, but also requires the frame index work in the relevant bit of
:Player (trying to hide the bad news?).

OOps. Forgot that.

:Plus Player calls this routine from at least two places. Plus what do
:you do about the access parameter???? I will do this provided there
:are a fixed number of frames in a chunk - otherwise its over to you.

There are a fixed number of frames per chunk.

The access parameter is a good question - pass it in I guess - we can ignore it
or deal with it as required...

:(filehandle?)

We probably know it (Is it safe to assume this will not change throughout the
playing of a Movie?)

:What are the calling conditions (processor mode, interrupt status)
:for this?

Good question.

:Its most natural to call this after the video decompressor has
:decompressed the last frame in the index list - this currently
:happens with interrupts disabled in IRQ mode, which has a critical
:processing time...

Urm... Ideally we want to guarantee that we have released the last buffer by
the time we have finished the other disc fetch (so the next disc fetch can
start asap.)

I would have suggested doing it before all the buffers were decompressed, but I
just sat down and wrote a long explaination of why this would be better, and
talked myself out of my primary reason :-)

Having IRQs disabled could be a problem though as memory copies could take a
(realtively) long time...

My preference is for ReleaseLastFrame to be called as early as possible, with
interrupts reenabled... Then decompresses can interrupt it...

All this is gut feeling though with little logic to back it up.

:Another ugly. The real problem is when to do it, the secondary problem is the
:extra store and CPU it takes.

Don't know enough about the sound side of ARMovie to make a snap suggestion on
this.

:Now to me it looks like around a week's work, all things
:considered. Plus testing, reimplementation as we choose new routes
:and the odd fatal error. Plus documentation etc.
:
:But, yes, I think it will fit.

FAb.

:Note that the interfaces will end up frozen and intransigent - it
:will be nasty to introduce new things with the possible exception of
:sound buffer fill routines that take linked lists. Variable number of
:frames per chunk will still be over the horizon. I don't know if
:leaving Player with all the code for ARMovie style chunks or moving
:it out to a Fetcher is the best idea. I expect it will stay inside
:Player (inertia rules) since its quite small.

OK. If the frames per chunk needs to be changed in future then that will be a
whole new ballgame...

:There is one thing we've not mentionned so far: Player and CompLib both know
:how to extract frames without reading the whole chunk. Can we add a
:
:CALL fetcher_getframe,chunk,buff,frame
:
:to support this. For predictably compressed movies, this is good!

Don't follow this particularly. How can you know where to get frame 3 from an
AE7 chunk without doing the decompress to know the length?

Robin
-------------------------------------------------------------------------------
Turned on the weather man just after the news,                      Robin Watts
I needed sweet rain to wash away my blues.
He looked at the the chart, but he looked in vain,
Heavy cloud, but no rain.

-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
At Thu,04 Apr 1996 15:38:05 mail was sent to Robin.Watts@comlab.oxford.ac.uk
About Re: Fetchers
Text:
>The access parameter is a good question - pass it in I guess - we can ignore it
>or deal with it as required...

OK: I'll pass it on and fetchers process it according to the ProgIf document.

>:(filehandle?)

>We probably know it (Is it safe to assume this will not change throughout the
>playing of a Movie?)

Yes.

>:What are the calling conditions (processor mode, interrupt status)
>:for this?

>Good question.

Isn't it just.

>:Its most natural to call this after the video decompressor has
>:decompressed the last frame in the index list - this currently
>:happens with interrupts disabled in IRQ mode, which has a critical
>:processing time...

>Urm... Ideally we want to guarantee that we have released the last buffer by
>the time we have finished the other disc fetch (so the next disc fetch can
>start asap.)

>I would have suggested doing it before all the buffers were decompressed, but I
>just sat down and wrote a long explaination of why this would be better, and
>talked myself out of my primary reason :-)

>Having IRQs disabled could be a problem though as memory copies could take a
>(realtively) long time...

>My preference is for ReleaseLastFrame to be called as early as possible, with
>interrupts reenabled... Then decompresses can interrupt it...

>All this is gut feeling though with little logic to back it up.

I'm biased to calling you in IRQ mode with interrupts disabled. That way you
can deal with any critical areas yourself and then reenable interrupts if you
are going to take all day.

>:Another ugly. The real problem is when to do it, the secondary problem is the
>:extra store and CPU it takes.

>Don't know enough about the sound side of ARMovie to make a snap suggestion on
>this.

I'll keep thinking about it.

>:Now to me it looks like around a week's work, all things
>:considered. Plus testing, reimplementation as we choose new routes
>:and the odd fatal error. Plus documentation etc.
>:
>:But, yes, I think it will fit.

>FAb.

Its on the limit, though - I just don't get many programming days to the
working days and I'm off on holiday at the end of May for 2 weeks.

>:Note that the interfaces will end up frozen and intransigent - it
>:will be nasty to introduce new things with the possible exception of
>:sound buffer fill routines that take linked lists. Variable number of
>:frames per chunk will still be over the horizon. I don't know if
>:leaving Player with all the code for ARMovie style chunks or moving
>:it out to a Fetcher is the best idea. I expect it will stay inside
>:Player (inertia rules) since its quite small.

>OK. If the frames per chunk needs to be changed in future then that will be a
>whole new ballgame...

As long as you know.

>:There is one thing we've not mentionned so far: Player and CompLib both know
>:how to extract frames without reading the whole chunk. Can we add a
>:
>:CALL fetcher_getframe,chunk,buff,frame
>:
>:to support this. For predictably compressed movies, this is good!

>Don't follow this particularly. How can you know where to get frame 3 from an
>AE7 chunk without doing the decompress to know the length?

If the Info file says that the number of bits per pixel is known and the
compression does not mention TEMPORAL, then Player and CompLib can compute the
position of a frame in a chunk. Player uses this for very fast access to
uncompressed chunks when -playfor 0 (i.e. frame advance in !ARPlayer) and
CompLib uses it to avoid an enormous buffer for the chunk when compressing.
Fun, eh? For Fetchers we can do a similar thing without having to know that the
number of bits per pixel.

--Sophie
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
From: Robin Watts <Robin.Watts@comlab.ox.ac.uk>
Subject: Re: Fetchers
To: SWilson (Sophie Wilson)
Date: Thu, 4 Apr 1996 15:42:33 +0100 (BST)

In some randomly numbered message, Sophie Wilson said:
:
:I'm biased to calling you in IRQ mode with interrupts disabled. That way you
:can deal with any critical areas yourself and then reenable interrupts if you
:are going to take all day.

Fair enough. As long as we are *allowed* to reenable interrupts...

:Its on the limit, though - I just don't get many programming days to the
:working days and I'm off on holiday at the end of May for 2 weeks.

Tell me about it...

:If the Info file says that the number of bits per pixel is known and
:the compression does not mention TEMPORAL, then Player and CompLib
:can compute the position of a frame in a chunk. Player uses this for
:very fast access to uncompressed chunks when -playfor 0 (i.e. frame
:advance in !ARPlayer) and CompLib uses it to avoid an enormous buffer
:for the chunk when compressing.  Fun, eh? For Fetchers we can do a
:similar thing without having to know that the number of bits per
:pixel.

Aha. Righto.

Robin
-------------------------------------------------------------------------------
Lay my head on the Surgeon's Table.                                 Robin Watts
Take my fingerprints if you are able.
Pick my brain, Pick my pockets.
Steal my eyeballs and come back for the sockets.
Run every kind of test from A to Z,
And you'll still know nothing 'bout me.

From: Paul Gardiner <paul@fsel.com>
Date: Thu, 4 Apr 1996 14:32:54 GMT
To: Robin.Watts@comlab.ox.ac.uk
Cc: SWilson
Subject: Re: Fetchers (fwd)

>:Plus Player calls this routine from at least two places. Plus what do
>:you do about the access parameter???? I will do this provided there
>:are a fixed number of frames in a chunk - otherwise its over to you.
>
>There are a fixed number of frames per chunk.
>
>The access parameter is a good question - pass it in I guess - we can
>ignore it or deal with it as required...

What's an access parameter? If its something that can be derived from a file
handle, then we probably don't need to worry about it because Open can work it
out and store it. Still sounds like something I ought to understand, though.

>:What are the calling conditions (processor mode, interrupt status)
>:for this?
>
>Good question.
>
>:Its most natural to call this after the video decompressor has
>:decompressed the last frame in the index list - this currently
>:happens with interrupts disabled in IRQ mode, which has a critical
>:processing time...
>
>Urm... Ideally we want to guarantee that we have released the last
>buffer by the time we have finished the other disc fetch (so the next
>disc fetch can start asap.)
>
>I would have suggested doing it before all the buffers were
>decompressed, but I just sat down and wrote a long explaination of why
>this would be better, and talked myself out of my primary reason :-)
>
>Having IRQs disabled could be a problem though as memory copies could
>take a (realtively) long time...
>
>My preference is for ReleaseLastFrame to be called as early as
>possible, with interrupts reenabled... Then decompresses can interrupt
>it...
>
>All this is gut feeling though with little logic to back it up.

Strange, I have exactly the same gut fealing, and with no greater logic to back
it up; perhaps its because we're thinking of it as having the same priority as
the disc fetch, and making it the lowest priority background task is the
closest to that. Interrupts reenabled means finding somewhere safe for the
return address, though.

>:Now to me it looks like around a week's work, all things
>:considered. Plus testing, reimplementation as we choose new routes
>:and the odd fatal error. Plus documentation etc.
>:
>:But, yes, I think it will fit.
>
>FAb.

I can hear your sighs of releif from here. :-)

>:There is one thing we've not mentionned so far: Player and CompLib both know
>:how to extract frames without reading the whole chunk. Can we add a
>:
>:CALL fetcher_getframe,chunk,buff,frame
>:
>:to support this. For predictably compressed movies, this is good!
>
>Don't follow this particularly. How can you know where to get frame 3
>from an AE7 chunk without doing the decompress to know the length?

I think I see: MovingLines doesn't come under the heading of predictably
compressed. Looks okay so long as buff is big enough to take the whole chunk,
should loading it all be the only way the fetcher can do it. I guess only
Sophie can say whether the facility is useful enough to warrant a separate
entry point.

Paul.

