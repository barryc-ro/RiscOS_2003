
;	AREA	|Test$$Code|,CODE,READONLY

	GET	hdr.D<Decomp18$Variant>

	GET	hdr.plook

	EXPORT	doframe

;xpix	DCD	x	;these are in veneer
;ypix	DCD	y

crv	DCD	104597
cbu	DCD	132201
cgu	DCD	25675
cgv	DCD	53279
ccy	DCD	76309

;every temp register found can remove a MOV
;however, I'm already assuming 4 - t,r,g,b

	MACRO
	DORGB 	$rr,$rg,$rb,$rt,$ry,$ru,$rv

	STMFD	R13!,{$ru,$rv,$rr,$rg,$rb}
	LDR	$rt,ccy
	SUB	$ry,$ry,#16   ;combine with ADD below
	MUL	$ry,$rt,$ry
	ADD	$ry,$ry,#32768
	LDR	$rt,cbu
	MLA	$rb,$rt,$ru,$ry
	LDR	$rt,crv
        MLA	$rr,$rt,$rv,$ry
	LDR	$rt,cgu
	MUL	$ru,$rt,$ru
        LDR	$rt,cgv
	MLA	$rv,$rt,$rv,$ru
	SUB	$rg,$ry,$rv

;still need to clp and LSR 16


	MOV	$rv,#255

	MOV	$rr,$rr,ASR #16
 	MOVS	$rt,$rr,ASR #8
	EORNE	$rr,$rv,$rt,LSR #24

	MOV	$rg,$rg,ASR #16
 	MOVS	$rt,$rg,ASR #8
	EORNE	$rg,$rv,$rt,LSR #24

	MOV	$rb,$rb,ASR #16
 	MOVS	$rt,$rb,ASR #8
	EORNE	$rb,$rv,$rt,LSR #24

	ORR	$rt,$rg,$rb,LSL #8
	ORR	$rt,$rr,$rt,LSL #8
	LDMFD	R13!,{$ru,$rv,$rr,$rg,$rb}

	MEND



	MACRO
	fnwrite	$rout,$ra,$rb

 [ decsize = 1
	strb	$ra,[$rout],#1
	strb	$rb,[$rout],#1
 ]
 [ decsize = 2
	bic	$ra,$ra,#&ff0000
	bic	$ra,$ra,#&ff000000
	orr 	$ra,$ra,$rb,LSL #16
	stmia	$rout!,{$ra}
 ]
 [ decsize = 4
	stmia	$rout!,{$ra,$rb}
 ]


	MEND

	MACRO
	crush	$rn,$ri,$rj,$rm
			; reduce 00000000 YYYYYYYY UUUUUUUU VVVVVVVV
		      	; to	00000000 00000000 0YYYYYUU UUUVVVVV

;change this to go to 6Y5UV

	AND	$ri,$rm,$rn,LSR #16+3	;Ri <- VVVVV
	AND	$rj,$rm,$rn,LSR #8+3	;Rj <- UUUUU
	ORR	$ri,$rj,$ri,LSL #5	;ri <- VVVVVUUUUU
	AND	$rj,$rm,$rn,LSR #3	;rj <- YYYYY
	ORR	$rn,$rj,$ri,LSL #5	;rn <- VVVVVUUUUUYYYYY


	MEND

upnt	DCD 	0
vpnt	DCD 	0

doframe
;doframe(src[3],output,table)
;         r0     r1     r2
; r0->source pixel stream
; r1->destination row
; r2=number of rows left
; r3=dither pixel lookup table
; r4,5,6 Y,U,V pointer
; r7 -r11 unused
; r12=pixels left on this row pair
; r13->FD stack

	stmfd	r13!,{r1-r12,lr}
	ldr	r2,ypix
	ldmia	r0,{r4,r5,r6} 		;get Y,U,V pointers
	str	r5,upnt
	str	r6,vpnt


	ldr	r12,xpix
decy



; There is probably a faster (but larger) way of doing this
; if you can assume everything is word aligned.

;do first row
decx
 [ torgb=0
	ldrb	r7,[r4],#1		;000000Y1
	ldrb	r10,[r5],#1		;000000UU
	ldrb	r11,[r6],#1		;000000VV
	subs	r10,r10,#128
	bicmi	r10,r10,#&ff00
	sub	r11,r11,#128
	orr	r10,r10,r11, LSL #8	;0000VVUU
	orr	r7,r7,r10, LSL #8	;00VVUUY1
	ldrb	r8,[r4],#1		;000000Y2
	orr	r8,r8,r10, LSL #8	;00VVUUY2
 ]
 [ torgb=1
	ldrb	r7,[r4],#1		;000000Y1
	ldrb	r10,[r5],#1		;000000UU
	ldrb	r11,[r6],#1		;000000VV
	sub	r10,r10,#128
	sub	r11,r11,#128

	DORGB	r0,r1,r2,r9,r7,r10,r11
	ldrb	r7,[r4],#1
	DORGB	r0,r1,r2,r14,r7,r10,r11
	MOV	r7,r9
	MOV	r8,r14
 ]
;------do first 2 pixels

 [ mash=1
      MOV   r10, #&1F		;reusing R9, R10 ,R11

;      STMFD r13 !, {r9,r11,r4}
      crush 	r7 ,r9,r11,r10
      crush	r8 ,r9,r11,r10
;      LDMFD r13 !, {r9,r11,r4}
 ]
 [ mash = 3
 	;stuff for dec21 here
 ]
 [ ppl = 1
      plook	r7,r7,r3	; record patch table entry for first
      plook	r8,r8,r3	; ..                           second
 ]


      fnwrite  r1,r7,r8



; ------- check end of loops
	SUBS	r12,r12,#2        ; done 2 pixels
	bne	decx
	ands	r10,r2,#1
        bne	even		  ; even row?
	ldr	r5,upnt           ; restore U,V pointers
	ldr	r6,vpnt
	b	ahead

even	str	r5,upnt		  ; store new U,V pointers
	str	r6,vpnt
ahead	ldr	r12,xpix

	SUBS	r2,r2,#1          ; done a line
	bne	decy



	ldmfd	r13!,{r1-r12,pc}^


;	EXPORT	PatchTable
PatchTable
	ptable


	END
