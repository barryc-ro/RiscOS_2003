#include "hierProf.h"
#undef FASTSAC /* until looping bug fixed. */
/*********************************************************************
 * 	SAC Decoder Module
 * 	Algorithm as Specified in H26P Annex -E
 *              (c) 1995 BT Labs
 *
 *	Author:	Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

/*#include <stdio.h>*/
#include <string.h>

#include "config.h"
#include "global.h"

#define   q1    16384
#define   q2    32768
#define   q3    49152
#define   top   65535
#include  "profile.h"

#ifdef PROFILE
extern long int sactime=0;
clock_t tmptime=0;
#endif



/* local prototypes */
void bit_out_psc_layer();

/*********************************************************************
 * 	SAC Decoder Algorithm as Specified in H26P Annex -E
 *
 * 	Name:		decode_a_symbol
 *
 *	Description:	Decodes an Aritmetically Encoded Symbol
 *
 *	Input:		array holding cumulative freq. data
 *			also uses static data for decoding endpoints
 *			and code_value variable
 *
 *	Returns:	Index to relevant symbol model
 *
 *	Side Effects:	Modifies low, high, length, cum and code_value
 *
 *	Author:		Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

static long low, high, code_value, bit, length, sacindex, cum, zerorun=0;

int decode_a_symbol(int cumul_freq[ ])
{
  HierProf_FnStart("decode_a_symbol")
#ifdef FASTSAC
  long tmp;
#define RSIGN(n) ((n<0) ?1 : 0)
#define SIGN(n) ((n<0) ?-1 : 1)
#define GG(a,n) (n+(a>>14))
#define DD(n) (RSIGN(n) +(((SIGN(n)+GG(GG(n,n),n))>>14)))
#endif
#ifdef PROFILE
tmptime=clock();
#endif

  length = high - low + 1;
  cum = (-1 + (code_value - low + 1) * cumul_freq[0]) / length;
  for (sacindex = 1; cumul_freq[sacindex] > cum; sacindex++);
#ifdef FASTSAC
  tmp =  (length * cumul_freq[sacindex-1]);
  high= low -1 + DD(tmp);
  tmp = (length * cumul_freq[sacindex]) ;
  low+= DD(tmp);
#else
  high = low - 1 + (length * cumul_freq[sacindex-1]) / cumul_freq[0];
  low += (length * cumul_freq[sacindex]) / cumul_freq[0];
#endif
/*1*/
  for ( ; ; ) {
    if (high < q2) ;
    else if (low >= q2) {
/*2*/
      code_value -= q2;
      low -= q2;
      high -= q2;
    }
    else if (low >= q1 && high < q3) {
      code_value -= q1;
      low -= q1;
      high -= q1;
    }
/*3*/
    else {
      break;
    }

    low *= 2;
    high = 2*high + 1;
    bit_out_psc_layer();
    code_value = 2*code_value + bit;
  }
#ifdef PROFILE
  sactime +=(long int)(clock()-tmptime);
#endif

  HierProf_ReturnValue( (sacindex-1))
  HierProf_NonVoidFnStop()
}

/*********************************************************************
 *
 * 	Name:		decoder_reset
 *
 *	Description:	Fills Decoder FIFO after a fixed word length
 *			string has been detected.
 *
 *	Input:		None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Fills Arithmetic Decoder FIFO
 *
 *	Author:		Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

void decoder_reset( )
{
  HierProf_FnStart("decoder_reset")
  int i;
  zerorun = 0;			/* clear consecutive zero's counter */
  code_value = 0;
  low = 0;
  high = top;
  for (i = 1;   i <= 16;   i++) {
    bit_out_psc_layer();
    code_value = 2 * code_value + bit;
  }
  HierProf_VoidFnStop()
  /*if (trace)
    printf("Arithmetic Decoder Reset \n");*/
}

/*********************************************************************
 *
 * 	Name:		bit_out_psc_layer
 *
 *	Description:	Gets a bit from the Encoded Stream, Checks for
 *			and removes any PSC emulation prevention bits
 *			inserted at the decoder, provides 'zeros' to the
 *			Arithmetic Decoder FIFO to allow it to finish
 *			data prior to the next PSC. (Garbage bits)
 *
 *	Input:		None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Gets a bit from the Input Data Stream
 *
 *	Author:		Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

void bit_out_psc_layer()
{
  HierProf_FnStart("bit_out_psc_layer")
  if (showbits(17)!=1) { /* check for startcode in Arithmetic Decoder FIFO */

    bit = getbits1(1);

    if(zerorun > 13) {	/* if number of consecutive zeros = 14 */
      if (!bit) {
	/*if (trace)
	  printf("PSC/GBSC, Header Data, or Encoded Stream Error \n");*/
	zerorun = 1;
      }
      else { /* if there is a 'stuffing bit present */
	/*if (trace)
	  printf("Removing Startcode Emulation Prevention bit \n");*/
	bit = getbits1(1); 	/* overwrite the last bit */
	zerorun = !bit;	  	/* zerorun=1 if bit is a '0' */
      }
    }

    else { /* if consecutive zero's not exceeded 14 */

      if (!bit)
	zerorun++;
      else
	zerorun = 0;
    }

  } /* end of if !(showbits(17)) */

  else {
    bit = 0;
    /*if (trace)
      printf("Startcode Found:Finishing Arithmetic Decoding using 'Garbage bits'\n");*/
  }

   /*
   printf("lastbit = %ld bit = %ld zerorun = %ld \n", lastbit, bit, zerorun);
   lastbit = bit;                                                            */

				/* latent diagnostics */

HierProf_VoidFnStop()
}

