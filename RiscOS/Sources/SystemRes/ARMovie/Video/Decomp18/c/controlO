
// initalise it

#define GLOBAL
/*#include "size.h"*/
#include "err.h"
#include <stdio.h>
#include "config.h"
#include "global.h"
#include "swis.h" /*for debugging */

#include <stdlib.h>
/*#include "ModMalloc.h"  */         /* malloc replacement*/
#include "dy_malloc.h"

#define PARM_P 'MRAP' /* should be: ('P' | 'A' <<24 | 'R'<<16 | 'M'<<24)*/
#define PARM_S 'TUHS' /* should be: ('S' | 'H' <<24 | 'U'<<16 | 'T'<<24)*/

/*#define PLBUG1*/
/*#define PLBUG*/


int xsize, ysize;
int framenum;


/* code for return errors*/
os_error dyinerr = {1,"Could not get dynamic area                           "};
os_error dyexerr = {2,"Dynamic area extend failed                           "};
os_error parmerr = {3,"PARM not passed                                      "};
os_error othmerr = {4,"Init Error                                           "};
os_error dysherr = {1,"Dynamic area extend failed                           "};


extern void dosetxy(int xs,int ys);


os_error *InitEntry(int xs, int ys, int parm, int *list)
{
  int i, cc, size;

  dosetxy(xs,ys);
  if(parm != PARM_P)
  {
    sprintf(parmerr.errmess,"Got | %x | instead of PARM: %x \n",parm,PARM_P);
    return &parmerr;
  }
#ifdef PLBUG1
   /* debugging output */
/*   if (!(bugmsg=(unsigned char *)ModMalloc_Malloc(102400)))
      return &mallerr;*/
   sprintf((char *)bugmsg,"address: %x",(int)bugmsg);
   _swi(OS_SetVarVal,_IN(0) | _IN(1) | _IN(2) |_IN(3)|_IN(4),
       "ARMovie$blat",bugmsg,6,0,0);
   sprintf((char *)bugmsg,"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ");
   tmpc=bugmsg+200;

#endif

/* stuff filched from tmndec.c - init_decoder()*/
   ld=&base;
   xsize=xs;
   ysize=ys;
   framenum=tr_framenum=0;
   defer_bool=0;

#ifdef PLBUG
   sprintf((char *)bugmsg,"done init vars");
#endif

   /* These must be checked to make sure the file size is supported*/
   initbits(); /* getbits.c*/
#ifdef PLBUG
   sprintf((char *)bugmsg,"done initbits");
#endif
   /* initdecoder();  In the orig vers getheader is called first **panic** */

   if(dy_init())
      return &dyinerr;
/*   if (!(clp=(unsigned char *)ModMalloc_Malloc(1024)))
      return &mallerr;*/
   if (!(clp=(unsigned char *)dy_malloc(1024)))
      {
       if(dy_shut())
          return &dysherr;
       else
          return &dyexerr;
      }

#ifdef PLBUG
   sprintf((char *)bugmsg,"done first malloc");
#endif

   clp += 384;
   for (i=-384; i<640; i++)
     clp[i] = (i<0) ? 0 : ((i>255) ? 255 : i);

#ifdef PLBUG
   sprintf((char *)bugmsg,"done set clip");
#endif

   /* MPEG-1 = TMN parameters */
   matrix_coefficients = 5;

   horizontal_size = MBC*16;
   vertical_size = MBR*16;

   /* stuff about checking size goes here */

   /* set globals */
   mb_width = horizontal_size/16;
   mb_height = vertical_size/16;
   coded_picture_width = 16*mb_width;
   coded_picture_height = 16*mb_height;
   chrom_width =  coded_picture_width>>1;
   chrom_height = coded_picture_height>>1;
   blk_cnt = 6;
#ifdef PLBUG
   sprintf((char *)bugmsg,"done set consts");
#endif
   for (cc=0; cc<3; cc++) {
     if (cc==0)
       size = coded_picture_width*coded_picture_height;
     else
       size = chrom_width*chrom_height;

/*     if (!(refframe[cc] = (unsigned char *)ModMalloc_Malloc(size)))
       return &mallerr;*/
     if (!(refframe[cc] = (unsigned char *)dy_malloc(size)))
       {
         if(dy_shut())
	    return &dysherr;
	 else
	   return &dyexerr;
        }

/* debugging>
   sprintf(mallerr.errmess,"got address: %x ",(int)refframe[0]);
   sprintf((char*)bugmsg+100,"addmall: %x ==",(int)&mallerr);
   return &mallerr;
   <debugging */

/*     if (!(oldrefframe[cc] = (unsigned char *)ModMalloc_Malloc(size)))
       return &mallerr;*/
     if (!(oldrefframe[cc] = (unsigned char *)dy_malloc(size)))
       {
         if(dy_shut())
	    return &dysherr;
	 else
	   return &dyexerr;
       }

/*     if (!(bframe[cc] = (unsigned char *)ModMalloc_Malloc(size)))
       return &mallerr;*/
     if (!(bframe[cc] = (unsigned char *)dy_malloc(size)))
       {
        if(dy_shut())
	   return &dysherr;
	else
	  return &dyexerr;
       }
   }

#ifdef PLBUG
   sprintf((char *)bugmsg,"done many mallocs");
#endif

   for (cc=0; cc<3; cc++) {
     if (cc==0) {
       size = (coded_picture_width+64)*(coded_picture_height+64);
/*       if (!(edgeframeorig[cc] = (unsigned char *)ModMalloc_Malloc(size)))
 	return &mallerr;*/
       if (!(edgeframeorig[cc] = (unsigned char *)dy_malloc(size)))
 	{
          if(dy_shut())
	     return &dysherr;
	  else
	    return &dyexerr;
        }
       edgeframe[cc] = edgeframeorig[cc] + (coded_picture_width+64) * 32 + 32 ;


     }
     else {
       size = (chrom_width+32)*(chrom_height+32);
/*       if (!(edgeframeorig[cc] = (unsigned char *)ModMalloc_Malloc(size)))
 	return &mallerr;*/
       if (!(edgeframeorig[cc] = (unsigned char *)dy_malloc(size)))
 	{
	 if(dy_shut())
	    return &dysherr;
	 else
	   return &dyexerr;
        }
       edgeframe[cc] = edgeframeorig[cc] + (chrom_width+32) * 16 + 16;
     }
   }

#ifdef PLBUG
   sprintf((char *)bugmsg,"done more mallocs");
#endif

   if (expand) { /* This is probably superfluous*/
     for (cc=0; cc<3; cc++) {
       if (cc==0)
 	size = coded_picture_width*coded_picture_height*4;
       else
 	size = chrom_width*chrom_height*4;

/*       if (!(exnewframe[cc] = (unsigned char *)ModMalloc_Malloc(size)))
 	return &mallerr;*/
       if (!(exnewframe[cc] = (unsigned char *)dy_malloc(size)))
 	{
         if(dy_shut())
            return &dysherr;
         else
            return &dyexerr;
	}
     }
   }
#ifdef PLBUG
   sprintf((char *)bugmsg,"done expand");
#endif


   /* IDCT */
 /*  if (refidct)
     init_idctref();
   else
     init_idct();*/

#ifdef PLBUG
   sprintf((char *)bugmsg,"done idct init - ret now");
#endif

   return 0;

}
os_error *ShutEntry(int xs, int ys, int parm, int *list)
{
#ifdef PLBUG
   sprintf((char *)bugmsg,"entered shutentry");
#endif

/*  ModMalloc_FreeDownTo(clp);*/
   if(dy_shut())
     return &dysherr;
#ifdef PLBUG
   sprintf((char *)bugmsg,"freed mem");
#endif

  if (parm !=PARM_S)
  {
    /* This Should Never Happen (TM)*/
    sprintf(parmerr.errmess,"Got | %x | instead of SHUT: %x\n",parm ,PARM_S);
    return &parmerr;
  }
  return 0;
}


char * DecompEntry(char *source, char *output, char *prev, char *table)
{

#ifdef PLBUG
   sprintf((char *)bugmsg,"start decomp %d th frame",framenum);

   sprintf((char *)bugmsg+100,"frame %d ##",framenum);

 #endif

  ld->source = (unsigned char*)source;
  ld->dest =(unsigned char*)output;
  ld->table =(unsigned char*)table;
  ld->bitsthru =0;

#ifdef PLBUG
   sprintf((char *)bugmsg,"done set ld %d th frame",framenum);
#endif


 if(!defer_bool)
   getheader(); /* possible problems here */
#ifdef PLBUG
   sprintf((char *)bugmsg,"done get header %d th frame",framenum);
#endif


  getpicture(&framenum);
#ifdef PLBUG
   sprintf((char *)bugmsg,"done get picture %d th frame",framenum);
#endif

    /* it might be better to call storeframe() here rather than in
     * getpicture
     */
  framenum++;
  tr_framenum++;

#ifdef PLBUG
   sprintf((char *)bugmsg,"done inc frame %d th frame",framenum);
   sprintf((char *)tmpc,"| %x | %x ",(int)source,(int)ld->source);
#endif


  return ((char *)ld->source);
}


