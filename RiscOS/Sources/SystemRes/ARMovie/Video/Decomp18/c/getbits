#include "HierProf.h"
/* getbits.c, bit level routines                                            */

/*
 * tmndecode
 * Copyright (C) 1995 Telenor R&D
 *                    Karl Olav Lillevold <kol@nta.no>
 *
 * based on mpeg2decode, (C) 1994, MPEG Software Simulation Group
 * and mpeg2play, (C) 1994 Stefan Eckart
 *                         <stefan@lis.e-technik.tu-muenchen.de>
 *
 */

 /* Almost completely ditched. Could be rewritten in assembler
    once the rest is working.
 */


#include <stdlib.h>

#include "config.h"
#include "global.h"
/*#define PLBUG*/
#ifdef PLBUG
#include <stdio.h>
#endif

/* to mask the n least significant bits of an integer */

static unsigned int msk[33] =
{
  0x00000000,0x00000001,0x00000003,0x00000007,
  0x0000000f,0x0000001f,0x0000003f,0x0000007f,
  0x000000ff,0x000001ff,0x000003ff,0x000007ff,
  0x00000fff,0x00001fff,0x00003fff,0x00007fff,
  0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
  0x000fffff,0x001fffff,0x003fffff,0x007fffff,
  0x00ffffff,0x01ffffff,0x03ffffff,0x07ffffff,
  0x0fffffff,0x1fffffff,0x3fffffff,0x7fffffff,
  0xffffffff
};


/* initialize buffer, call once before first getbits or showbits */

void binitbits(unsigned char *i)

{
 /* ld->incnt = 0;
  ld->rdptr = ld->rdbfr + 2048;
  ld->bitcnt = 0;*/
  ld->bitsthru=0;
}

void fillbfr()    /* TO BE DISCARDED */
{
  /* int l;

  ld->inbfr[0] = ld->inbfr[8];
  ld->inbfr[1] = ld->inbfr[9];
  ld->inbfr[2] = ld->inbfr[10];
  ld->inbfr[3] = ld->inbfr[11];

  if (ld->rdptr>=ld->rdbfr+2048)
  {
    l = fread(ld->rdbfr,1,2048,ld->infile);
    ld->rdptr = ld->rdbfr;
    if (l<2048)
    {
      if (l<0)
        l = 0;

      while (l<2048)  */ /* Add recognizable sequence end code */ /*
      {
        ld->rdbfr[l++] = 0;
        ld->rdbfr[l++] = 0;
        ld->rdbfr[l++] = (1<<7) | (SE_CODE<<2);
      }
    }
  }

  for (l=0; l<8; l++)
    ld->inbfr[l+4] = ld->rdptr[l];

  ld->rdptr+= 8;
  ld->incnt+= 64; */
}


/* return next n bits (right adjusted) without advancing */

unsigned int bshowbits(n)
int n;
{
  HierProf_FnStart("showbits")
 /* Note -  This assumes the max n bits wanted is 25. Currently 22*/

  unsigned char *v;
  unsigned int b;
  int c;


  v = ld->source;
  b = (v[0]<<24) | (v[1]<<16) | (v[2]<<8) | v[3];
  c = 32-n-(ld->bitsthru);
  HierProf_ReturnValue( (b>>(c)) & msk[n])
  HierProf_NonVoidFnStop()
}


/* return next bit (could be made faster than getbits(1)) */

unsigned int bgetbits1()
{ HierProf_FnStart("getbits1")
  HierProf_ReturnValue( getbits(1))
  HierProf_VoidFnStop()
}


/* advance by n bits */

void bflushbits(n)
int n;
{
  HierProf_FnStart("flushbits")
  int t;
  t=(ld->bitsthru)+n;
  ld->bitsthru=(t%8);

  ld->source +=(t/8);
  HierProf_VoidFnStop()
  /*
  ld->bitcnt+= n;
  ld->incnt-= n;
  if (ld->incnt < 0)
    fillbfr(); */
}


/* return next n bits (right adjusted) */

unsigned int bgetbits(n)
int n;
{
  HierProf_FnStart("getbits")
   unsigned int l;

  l = showbits(n);
  flushbits(n);

  HierProf_ReturnValue( l)
  HierProf_NonVoidFnStop()
}
/*
unsigned int agetbits(n)
int n;
{
  HierProf_FnStart("getbits")
   unsigned int l;

  l = ashowbits(n);
  aflushbits(n);

  HierProf_ReturnValue( l)
  HierProf_NonVoidFnStop()
}

*/
