#include "HierProf.h"

/* gethdr.c, header decoding                                                */

/*
 * tmndecode
 * Copyright (C) 1995 Telenor R&D
 *                    Karl Olav Lillevold <kol@nta.no>
 *
 * based on mpeg2decode, (C) 1994, MPEG Software Simulation Group
 * and mpeg2play, (C) 1994 Stefan Eckart
 *                         <stefan@lis.e-technik.tu-muenchen.de>
 */


/*#include <stdio.h>*/

#include "config.h"
#include "global.h"

/* private prototypes */
static void getpicturehdr _ANSI_ARGS_((void));

/*
 * decode headers from one input stream
 * until an End of Sequence or picture start code
 * is found
 */

int getheader()
{
  HierProf_FnStart("getheader")
  unsigned int code, gob;
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth entered ");
#endif

  /* look for startcode */
  startcode();
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth after startcode");
#endif
  code = getbits(PSC_LENGTH);
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth aft PSC");
#endif

  gob = getbits(5);
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth aft gob");
#endif

  if (gob == SE_CODE)
    return 0;
  if (gob == 0) {
    getpicturehdr();
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth aft gph");
#endif

    if (syntax_arith_coding)		/* reset decoder after receiving */
      decoder_reset();	        /* fixed length PSC string */
  }
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gth at end");
#endif

  HierProf_ReturnValue( gob + 1)
  HierProf_NonVoidFnStop()
}


/* align to start of next startcode */

void startcode()
{
  HierProf_FnStart("startcode")
  /* search for new picture start code */
  while (showbits(PSC_LENGTH)!=1l)
  	 flushbits(1);
  HierProf_VoidFnStop()
}

/* decode picture header */

static void getpicturehdr()
{
  HierProf_FnStart("getpicturehdr")
  int pos, pei, tmp;
  static int prev_temp_ref;
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph entered");
#endif
  pos = ld->bitcnt;
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph set pos");
#endif
  prev_temp_ref = temp_ref;
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph sml var");
#endif
  temp_ref = getbits(8);
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph aft trf");
#endif
  trd = temp_ref - prev_temp_ref;
  if (trd < 0)
    trd += 256;
#ifdef TRDDIV
  if(trd!=0) itrd=TRDDIV/trd;
#endif

  tmp = getbits1(1); /* always "1" */
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph get 1 ");
#endif
/*  if (!tmp)
  {  if (!quiet)
      printf("warning: spare in picture header should be \"1\"\n");
  }  */
  tmp = getbits1(1); /* always "0" */
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph get 2 ");
#endif
 /* if (tmp)
    if (!quiet)
      printf("warning: H.261 distinction bit should be \"0\"\n");*/
  tmp = getbits1(1); /* split_screen_indicator */
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph get 3");
#endif
  /*if (tmp) {
    if (!quiet)
      printf("error: split-screen not supported in this version\n");
   exit (-1);
  } */
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph aft spl");
#endif
  tmp = getbits1(1); /* document_camera_indicator */
 /* if (tmp)
    if (!quiet)
      printf("warning: document camera indicator not supported in this version\n");*/
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph midspl   ");
#endif

  tmp = getbits1(1); /* freeze_picture_release */
/*  if (tmp)
    if (!quiet)
      printf("warning: frozen picture not supported in this version\n");*/
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph middle   ");
#endif

  source_format = getbits(3);
  pict_type = getbits1(1);
  mv_outside_frame = getbits1(1);
  long_vectors = (mv_outside_frame ? 1 : 0);
  syntax_arith_coding = getbits1(1);
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph synarith   ");
#endif

  adv_pred_mode = getbits1(1);
  mv_outside_frame = (adv_pred_mode ? 1 : mv_outside_frame);
  pb_frame = getbits1(1);
  quant = getbits(5);
  tmp = getbits1(1);
#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph fewmore   ");
#endif
  /*if (tmp) {
    if (!quiet)
      printf("error: CPM not supported in this version\n");
    exit(-1);
  } */
  if (pb_frame) {
    trb = getbits(3);
    bquant = getbits(2);
  }

  pei = getbits1(1);
pspare:
  if (pei) {
     /* extra info for possible future backward compatible additions */
    getbits(8);  /* not used */
    pei = getbits1(1);
    if (pei) goto pspare; /* keep on reading pspare until pei=0 */
  }


 /* if (verbose>0) {
    /*$printf("picture header (byte %d)\n",(pos>>3)-4);$*/
    /*if (verbose>1) {
      printf("  temp_ref=%d\n",temp_ref);*/
      /*$printf("  pict_type=%d\n",pict_type);
      printf("  source_format=%d\n", source_format);
      printf("  quant=%d\n",quant);
      if (syntax_arith_coding)
    	printf("  SAC coding mode used \n");
      if (mv_outside_frame)
	printf("  unrestricted motion vector mode used\n");
      if (adv_pred_mode)
	printf("  advanced prediction mode used\n");$*/
      /*if (pb_frame) {
	/*$printf("  pb-frames mode used\n");$*/
	/*printf("  trb=%d\n",trb);*/
	/*$printf("  bquant=%d\n", bquant);$
      } */

#ifdef PLBUG
  sprintf((char *)bugmsg+50,"gph at end");
#endif
 HierProf_VoidFnStop()
}


