/******	Keyboards.c *******************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Keyboard configuration plug-in
This file:	Keyboard handler routines

History:
Date		Who	Change
----------------------------------------------------------------------------
09/12/1997	BJGA	Added these headers
29/06/1998	BJGA	Removed code to support dedicated PC-type-delete handlers
30/06/1998	BJGA	Changed command from *Keyboard to *Country
			Bugfix: no * command was issued when changing to the default keyboard
11/08/1998	BJGA	Keyboard handler list now only includes countries
			for which a handler is currently loaded

\**************************************************************************/

/* Clib */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
/* Toolbox */
#include "wimplib.h"
/* Common */
#include "cmos.h"
#include "message.h"
#include "misc.h"
#include "str.h"
/* Local headers */
#include "Main.h"
#include "Keyboards.h"  /* includes prototypes for this file */

/* Statics */

#define Service_International 0x43

static const cmos territory_cmos = { 0x18, 0, 8 } ; /* Held as Territory EOR 1 */

static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space);

/******	getfullstring() ***************************************************\

Purpose:	Adds verbose handler name (as used on menu) to specified buffer
In:		Handler number, current territory number (for comparison),
		  buffer pointer / remaining passed by reference
Out:		If it fits, name is added to buffer;
		  buffer pointer / remaining adjusted to compensate

\**************************************************************************/

static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space)
{
  int written;
  char buf [100] = "";
  char sdefault [20];
  if (!_swi (OS_ServiceCall, _INR(1,5)|_RETURN(1)|_OUT(5), Service_International, 2, handler, buf, sizeof(buf), &written)) {
    /* handler number claimed */
    *(buf + written) = (char) 0; /* null-terminate */
    if (handler == current_territory) {
      /* is the default handler for this territory */
      message_lookup_buffer(sdefault,messages,"Default");
      strcpy (buf+written, sdefault);
      written += strlen (sdefault);
    }
    if (*space > written + 1) {
      strcpy (*buffer, buf);
      *buffer += strlen (buf) + 1;
      *space -= strlen (buf) + 1;
    }
    return TRUE;
  }
  return FALSE;
}

/******	keyboards_getavailable() ******************************************\

Purpose:	Builds a comma-separated, sorted list of available keyboard handlers
In:		Buffer to place result in
Out:		CRC of result

\**************************************************************************/

int keyboards_getavailable (char *buffer, int bufsize)
{
  int handlers = 0;
  int h;
  int country;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  int original_keyboard;
  int UK_addr;
  int UK_crc;
  char *handler_ptr [80];
  char *ptr;
  char *tmpbuf;
  ptr = tmpbuf = (char *) malloc (bufsize);
  
  /* Determine which handlers are available: step through all possible keyboards, and */
  /* assume that any that are not implemented will default to the UK handler. */
  /* InternationalKeyboard uses the same address to hold each installed handler, so we must */
  /* also compare the offsets therein. Only the first 32 bytes are required by the kernel. */
  original_keyboard = _swi (OS_Byte, _INR(0,1)|_RETURN(1), 71, 255);
  
  _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set UK keyboard */
  UK_addr = _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
  UK_crc = _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, UK_addr, UK_addr + 32, 1);
  
  for (country = 0; country < 127; country++)
  {
    int handler;
    int handler_addr;
    int handler_crc;
    _swi (OS_Byte, _INR(0,1), 71, country | 0x80); /* try to set keyboard */
    handler = _swi (OS_Byte, _INR(0,1)|_RETURN(1),71, 255); /* read it back again (may be different!) */
    handler_addr = _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
    handler_crc = _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, handler_addr, handler_addr + 32, 1);
    if (handler != 1)
    {
      if ((handler_addr != UK_addr) || (handler_addr == UK_addr && handler_crc != UK_crc))
      {
        handler_ptr [handlers] = ptr;
        if (getfullstring (country, territory, &ptr, &bufsize))
        {
          handlers++;
        }
      }
    }
  }
  
  /* Add on UK handler (assumed always present) and restore original keyboard */
  handler_ptr [handlers] = ptr;
  if (getfullstring (1, territory, &ptr, &bufsize))
  {
    handlers++;
  }
  _swi (OS_Byte, _INR(0,1), 71, original_keyboard | 0x80);
  
  /* Just in case there aren't any handlers at all (!) */
  if (handlers == 0) {
    handlers=1;
    strcpy ((char *) tmpbuf, message_lookup_direct(messages, "NoneAvail"));
  }
  
  _swi (OS_HeapSort, _INR(0,2), handlers, (int) handler_ptr, 4);
  
  ptr = buffer;
  for (h = 0; h < handlers; h++) {
    strcpy (ptr, handler_ptr [h]);
    ptr += strlen (handler_ptr [h]);
    *ptr = (h == handlers-1) ? 0 : ',';
    ptr += 1;
  }
  free (tmpbuf);
  return _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, (int) buffer, (int) buffer + strlen (buffer), 1);
}

/******	keyboards_get() ***************************************************\

Purpose:	Reads the current / default keyboard handler
In:		Buffer to place result in, and function to use
Out:		Buffer pointer, as passed in;
		  buffer holds (verbose) handler name

\**************************************************************************/

char *keyboards_get (char *buffer, int bufsize, int(get)(cmos item, void *messages))
{
  char *ptr = buffer;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  
  if (get == cmos_default || misc_fileisunreadable (status_file)) {
    /* default is default for current territory, ie the same number as the configured territory */
    /* no status file means configured keyboard is the default */
    if (!getfullstring (territory, territory, &ptr, &bufsize))
      str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
  }
  else {
    FILE *handle;
    if (NULL == (handle = fopen (status_file, "r"))) {
      if (!getfullstring (territory, territory, &ptr, &bufsize))
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
    }
    else {
      char line [100];
      int claimed, country;
      if (!misc_readline (line, sizeof (line), handle)) {
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery2"), bufsize);
      }
      else {
        if (!_swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, 8 + (int) line, &claimed, &country))
          str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
        if (claimed != 0) str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
        if (!getfullstring (country, territory, &ptr, &bufsize))
          str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
      }
      fclose (handle);
    }
  }
  return buffer;
}

/******	keyboards_set() ***************************************************\

Purpose:	Sets the current and configured keyboard handler
In:		Pointer to (verbose) handler name

\**************************************************************************/

void keyboards_set (char *value)
{
  char buf [100] = "Country ";
  char sdefault [20];
  
  char tmpbuf [3] [100];
  message_lookup_buffer(tmpbuf[0],messages,"Mystery");
  message_lookup_buffer(tmpbuf[1],messages,"Mystery2");
  message_lookup_buffer(tmpbuf[2],messages,"NoneAvail");
  if ((_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[0]) == 0)
    || (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[1]) == 0)
    || (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, value, tmpbuf[2]) == 0)) return; /* nothing we can do for these */

  str_cpy (buf + strlen (buf), value);
  message_lookup_buffer(sdefault,messages,"Default");
  if (_swi (Territory_Collate, _INR(0,3)|_RETURN(0), -1, (int) sdefault, (int) (buf + strlen (buf) - strlen (sdefault)), 1) == 0) {
    char command [256];
    sprintf (command, "Remove %s", status_file);          /* a lack of status file is sufficient to configure the default keyboard */
    _swi (OS_CLI, _IN(0), (int) command);
    /* Now issue the *Keyboard command */
    *(buf + str_len (buf) - str_len (sdefault)) = '\0'; /* remove suffix */
    _swi (OS_CLI, _IN(0), buf);
    return;
  }

  _swi (OS_CLI, _IN(0), buf);
  if (!misc_fileislocked (status_file)) {
    if (!_swix (OS_FSControl, _INR(0,3), 26, (int) "<KbdSetup$Dir>.Blank", (int) status_file, 2)) {
      FILE *handle;
      if (NULL != (handle = fopen (status_file, "a"))) {
        fprintf (handle, "%s\n", buf);
        fclose (handle);
      }
    }
  }
}
