/******	Keyboards.c *******************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Keyboard configuration plug-in
This file:	Keyboard handler routines

History:
Date		Who	Change
----------------------------------------------------------------------------
09/12/1997	BJGA	Added these headers
29/06/1998	BJGA	Removed code to support dedicated PC-type-delete handlers
30/06/1998	BJGA	Changed command from *Keyboard to *Country
			Bugfix: no * command was issued when changing to the default keyboard
11/08/1998	BJGA	Keyboard handler list now only includes countries
			for which a handler is currently loaded
27/08/1998	BJGA	Now compares whole keyboard handler table, rather than just its crc.
			keyboards_get() and keyboard_set() rewritten to deal with PreDesktop
			  instead of dedicated choice file, and also the Win95 key settings

\**************************************************************************/

/* Clib */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
/* Toolbox */
#include "wimplib.h"
/* Common */
#include "cmos.h"
#include "message.h"
#include "misc.h"
#include "str.h"
/* Local headers */
#include "Main.h"
#include "Keyboards.h"  /* includes prototypes for this file */

/* Statics */

#define Service_International 0x43

static const cmos territory_cmos = { 0x18, 0, 8 } ; /* Held as Territory EOR 1 */

static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space);

/******	getfullstring() ***************************************************\

Purpose:	Adds verbose handler name (as used on menu) to specified buffer
In:		Handler number, current territory number (for comparison),
		  buffer pointer / remaining passed by reference
Out:		If it fits, name is added to buffer;
		  buffer pointer / remaining adjusted to compensate

\**************************************************************************/

static BOOL getfullstring (int handler, int current_territory, char **buffer, int *space)
{
  int written;
  char buf [100] = "";
  char sdefault [20];
  if (!_swi (OS_ServiceCall, _INR(1,5)|_RETURN(1)|_OUT(5), Service_International, 2, handler, buf, sizeof(buf), &written)) {
    /* handler number claimed */
    *(buf + written) = (char) 0; /* null-terminate */
    if (handler == current_territory) {
      /* is the default handler for this territory */
      message_lookup_buffer(sdefault,messages,"Default");
      strcpy (buf+written, sdefault);
      written += strlen (sdefault);
    }
    if (*space > written + 1) {
      strcpy (*buffer, buf);
      *buffer += strlen (buf) + 1;
      *space -= strlen (buf) + 1;
    }
    return TRUE;
  }
  return FALSE;
}

/******	keyboards_getavailable() ******************************************\

Purpose:	Builds a comma-separated, sorted list of available keyboard handlers
In:		Buffer to place result in
Out:		CRC of result

\**************************************************************************/

int keyboards_getavailable (char *buffer, int bufsize)
{
  int handlers = 0;
  int h;
  int country;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;
  int original_keyboard;
  void *UK_addr;
  int UK_table [8];
  char *handler_ptr [100];
  char *ptr;
  char *tmpbuf;
  ptr = tmpbuf = (char *) malloc (bufsize);
  
  /* Determine which handlers are available: step through all possible keyboards, and */
  /* assume that any that are not implemented will default to the UK handler. */
  /* InternationalKeyboard uses the same address to hold each installed handler, so we must */
  /* also compare the offsets therein. Only the first 32 bytes are required by the kernel. */
  original_keyboard = _swi (OS_Byte, _INR(0,1)|_RETURN(1), 71, 255);
  
  _swi (OS_Byte, _INR(0,1), 71, 0x81); /* set UK keyboard */
  UK_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
  memcpy (UK_table, UK_addr, sizeof (int) * 8);
  
  for (country = 0; country < 127; country++)
  {
    int handler;
    void *handler_addr;
    _swi (OS_Byte, _INR(0,1), 71, country | 0x80); /* try to set keyboard */
    handler = _swi (OS_Byte, _INR(0,1)|_RETURN(1),71, 255); /* read it back again (may be different!) */
    handler_addr = (void *) _swi (OS_InstallKeyHandler, _IN(0)|_RETURN(0), 0);
    if (handler != 1)
    {
      if ((handler_addr != UK_addr) || 
          (handler_addr == UK_addr && (memcmp (handler_addr, UK_table, sizeof (int) * 8) != 0)))
      {
        handler_ptr [handlers] = ptr;
        if (getfullstring (country, territory, &ptr, &bufsize))
        {
          handlers++;
        }
      }
    }
  }
  
  /* Add on UK handler (assumed always present) and restore original keyboard */
  handler_ptr [handlers] = ptr;
  if (getfullstring (1, territory, &ptr, &bufsize))
  {
    handlers++;
  }
  _swi (OS_Byte, _INR(0,1), 71, original_keyboard | 0x80);
  
  _swi (OS_HeapSort, _INR(0,2), handlers, (int) handler_ptr, 4);
  
  ptr = buffer;
  for (h = 0; h < handlers; h++) {
    strcpy (ptr, handler_ptr [h]);
    ptr += strlen (handler_ptr [h]);
    *ptr = (h == handlers-1) ? 0 : ',';
    ptr += 1;
  }
  free (tmpbuf);
  return _swi (OS_CRC, _INR(0,3)|_RETURN(0), 0, (int) buffer, (int) buffer + strlen (buffer), 1);
}

/******	keyboards_get() ***************************************************\

Purpose:	Reads keyboard handler and key tasks details from PreDesktop
		(or default keyboard handler for territory and hardcoded default tasks)
In:		Buffer to place keyboard result in, and get function to use
Out:		Buffer pointer, as passed in;
		  buffer holds (verbose) handler name

\**************************************************************************/

char *keyboards_get (char *buffer, int bufsize, int(get)(cmos item, void *messages))
{
  char *ptr = buffer;
  int original_bufsize = bufsize;
  int territory = cmos_read (territory_cmos, NULL) ^ 1;  /* not get() */
  
  /* First, initialise settings as though there were no status file */
  if (!getfullstring (territory, territory, &ptr, &bufsize))
  {
    str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
  }
  Tasks_Acorn [0][0] = Tasks_Acorn [1][0] = Tasks_Acorn [2][0] = Tasks_Acorn [3][0] = '\0';
  Tasks_Menu [0][0]  = Tasks_Menu [1][0]  = Tasks_Menu [2][0]  = Tasks_Menu [3][0]  = '\0';
  
  /* Now differentiate between current and default configuration */
  if (get == cmos_default)
  {
    /* Keyboard handler already determined, we have hardcoded knowledge of Win95 defaults as follows: */
    str_cpy (Tasks_Acorn [0], "Filer_OpenDir Resources:$.Apps");
    str_cpy (Tasks_Acorn [2], "<Boot$Dir>");
    str_cpy (Tasks_Menu [0],  "Help_On");
    str_cpy (Tasks_Menu [1],  "Help_Off");
  }
  else
  {
    BOOL error = FALSE;
    FILE *handle = NULL;
    char line [1000];
    
    error = misc_fileisunreadable (status_file);
    
    if (!error)
    {
      handle = fopen (status_file, "r");
      if (handle == NULL) error = TRUE;
    }
    
    if (!error)
    {
      /* Find the start of our entry */
      do
      {
        fgets (line, sizeof (line), handle);
        str_cpy (line, line); /* null-terminate */
      }
      while (strncmp (line, "|Start Acorn KbdSetup ", 22) != 0 && !feof (handle));
      
      if (!feof (handle)) /* but if end of file *was* reached, defaults continue to apply */
      {
        int country;
        int claimed;
        
        /* Read lines until the end of our entry */
        do
        {
          fgets (line, sizeof (line), handle);
          str_cpy (line, line); /* null-terminate */
          
          if (strncmp (line, "Country ", 8) == 0)
          {
            error = (BOOL) _swix (OS_ServiceCall, _INR(1,3)|_OUT(1)|_OUT(4), Service_International, 0, line + 8, &claimed, &country);
            if (!error)
            {
              if (claimed != 0)
              {
                error = TRUE;
              }
              else
              {
                ptr = buffer;
                bufsize = original_bufsize;
                error = !getfullstring (country, territory, &ptr, &bufsize);
              }
            }
          }
          else if (strncmp (line, "Set Key$01C0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [0], line + 18);
          }
          else if (strncmp (line, "Set Key$01D0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [1], line + 18);
          }
          else if (strncmp (line, "Set Key$01E0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [2], line + 18);
          }
          else if (strncmp (line, "Set Key$01F0$Task ", 18) == 0)
          {
            str_cpy (Tasks_Acorn [3], line + 18);
          }
          else if (strncmp (line, "Set Key$01C1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [0], line + 18);
          }
          else if (strncmp (line, "Set Key$01D1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [1], line + 18);
          }
          else if (strncmp (line, "Set Key$01E1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [2], line + 18);
          }
          else if (strncmp (line, "Set Key$01F1$Task ", 18) == 0)
          {
            str_cpy (Tasks_Menu [3], line + 18);
          }
        }
        while (strcmp (line, "|End") !=0 && !feof (handle));
      }
      
      if (error)
      {
        /* Mark keyboard handler as "unrecognised" */
        str_ncpy (buffer, message_lookup_direct(messages,"Mystery"), bufsize);
      }
    }
    
    fclose (handle);
  }
  return buffer;
}

/******	keyboards_set() ***************************************************\

Purpose:	Sets the current and configured country and Win95 key tasks
In:		Pointer to (verbose) handler name

\**************************************************************************/

void keyboards_set (char *value)
{
  const char *file = "Pipe:$.KbdSetup";
  const char *predesktop = "<Choices$Write>.Boot.PreDesktop";
  char *version;
  FILE *f;
  char command [1024];
  WimpMessage block;
  int i;
  
  f = fopen (file, "w");
  if (f == NULL)
  {
    /* Can't open the temp file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swi (MessageTrans_ErrorLookup, _INR(0,7), &block, messages, 0, 0, file, 0, 0, 0);
  }
  
  /* Get version number string */
  version = message_lookup_direct(messages, "VersionNumber");
  
  /* Write file */
  fprintf (f, "|Variable\n");
  fprintf (f, "|Start Acorn KbdSetup %s Options\n", version);
  
  message_lookup_buffer(command /* used as a temp buffer */, messages, "Mystery");
  str_cpy (command, command); /* null terminate */
  if (strcmp (command, value) != 0) /* don't do any keyboard handler stuff if undefined */
  {
    char def_str [30];
    message_lookup_buffer(def_str, messages, "Default");
    str_cpy (def_str, def_str); /* null terminate */
    sprintf (command, "Country %s", value);
    if (strcmp (def_str, command + str_len (command) - str_len (def_str)) == 0)
    {
      * (command + str_len (command) - str_len (def_str)) = '\0'; /* truncate */
    }
    else
    {
      fprintf (f, "%s\n", command); /* add to file */
    }
    _swi (OS_CLI, _IN(0), command); /* set now in either case */
  }
  
  for (i = 0; i < 4; i++)
  {
    /* Do Acorn key */
    int code = 0x1C0 + i * 0x10;
    if (Tasks_Acorn [i][0] == '\0')
    {
      sprintf (command, "Unset Key$%04X$Task", code);
    }
    else
    {
      sprintf (command, "Set Key$%04X$Task %s", code, Tasks_Acorn [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);
    
    /* Do Menu key */
    code = 0x1C1 + i * 0x10;
    if (Tasks_Menu [i][0] == '\0')
    {
      sprintf (command, "Unset Key$%04X$Task", code);
    }
    else
    {
      sprintf (command, "Set Key$%04X$Task %s", code, Tasks_Menu [i]);
      fprintf (f, "%s\n", command);
    }
    _swi (OS_CLI, _IN(0), command);
  }
  
  fprintf (f, "|End\n");
  
  fclose (f);
  _swi (OS_File, _INR(0,2), 18 /* set type */, file, 0xFEB /* obey file */);
  
  /* Do the merge! */
  sprintf (command, "Install_Merge %s %s %s", predesktop, file, predesktop);
  _swi (OS_CLI, _IN(0), command);
  
  /* Broadcast the fact that the file has been updated */
  block.hdr.your_ref = 0;
  block.hdr.action_code = Wimp_MChoicesChanged;
  str_cpy (block.data.bytes, "Boot.PreDesktop");
  block.hdr.size = sizeof (block.hdr) + (~3 & (str_len (block.data.bytes) + 1 + 3));
  throw (wimp_send_message (17, &block, 0, 0, NULL));
}
