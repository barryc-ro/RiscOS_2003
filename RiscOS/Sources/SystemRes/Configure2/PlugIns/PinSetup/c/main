/*---------------------------------------------------------------------------*/
/* File:    c.main                                                           */
/* Purpose: Main WIMP shell for Pinboard configuration                       */
/* Author:  Richard Leggett                                                  */
/* History: 28-Oct-97: RML: Begun.                                           */
/*          04-Nov-97: RML: First version given for testing.                 */
/*          13-Nov-97: RML: Minor modifications                              */
/*          30-Jan-98: RML: Tidied up a little.                              */
/*          20-Mar-98: RML: Minor modifications                              */
/*          16-Apr-98: RML: Tiled JPEGs no longer allowed.                   */
/*          23-Apr-98: RML: Now greys out the IconiseStack menu if Iconise   */
/*                          to Icon or Iconise to Iconbar is selected.       */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "toolbox.h"
#include "colourdbox.h"
#include "event.h"
#include "common.h"
#include "window.h"
#include "defines.h"
#include "pinboard.h"
#include "wimplib.h"
#include "sprite.h"

#define VduCLG                  16
#define SpriteFileType          0xff9
#define JPEGFileType            0xc85
#define DefaultBackgroundColour 0x77777700

static unsigned int background_colour = DefaultBackgroundColour;
static MessagesFD   messages_desc;
static IdBlock      idb;
static char         messages_string[255];
static int          config_id;
static int          colourbox_id;
static int          current_tile = 1;
static char*        custom_filename;
static int          custom_filetype;
static int*         client_sprite_area;


/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

static void program_exit(void)
{
    exit(0);
}


/*---------------------------------------------------------------------------*
 * save_choices                                                              *
 *                                                                           *
 * Read the choices from the window and output a command file.               *
 *---------------------------------------------------------------------------*/

static void save_choices(void)
{
    char backdrop_command[1024];
    char pinboard_command[256];
    char string[1024];
    int  radio_on;
    int  grid_lock;
    int  selected;
    int  lighter;
    int  type;

    memset(backdrop_command, 0, 1024);
    memset(pinboard_command, 0, 256);
    error_trap(radiobutton_get_state(0, config_id, StandardTileRadio, 0, &radio_on), 0);    

    /* First work out the *Backdrop command */
    switch(radio_on)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            tile_filename(current_tile, lighter, string);
            sprintf(backdrop_command, "Backdrop -T %s", string);
            break;
            
        case CustomImageRadio:        
            if (custom_filename[0] != 0)
            {
                error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &type), 0);
                switch (type)
                {
                    case ScaledRadioButton: sprintf(string, "Backdrop -S"); break;
                    case CentredRadioButton: sprintf(string, "Backdrop -C"); break;
                    default: sprintf(string, "Backdrop -T"); break;
                }
                sprintf(backdrop_command, "%s %s", string, custom_filename);
            }
            break;
            
       default:
           sprintf(backdrop_command, "Backdrop -R");
           break;
    }

    /* Add the colour switch to the backdrop command */
    sprintf(string, " -Colour &%x", background_colour);
    strcat(backdrop_command, string);
    
    /* Now work out the *Pinboard command */
    sprintf(pinboard_command,"PinboardOptions");
    error_trap(optionbutton_get_state(0, config_id, GridLockOption, &grid_lock), 0);
    if (grid_lock) strcat(pinboard_command, " -G");

    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);
    switch (selected)
    {
        case 1: strcat(pinboard_command, " -ITIB"); break;
        case 2: strcat(pinboard_command, " -ITTL"); break;
        case 3: strcat(pinboard_command, " -ITBL"); break;
        case 4: strcat(pinboard_command, " -ITTR"); break;
        case 5: strcat(pinboard_command, " -ITBR"); break;
    }
    
    error_trap(stringset_get_selected(1, config_id, IconiseStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -ISV");

    error_trap(stringset_get_selected(1, config_id, TidyToMenu, &selected), 0);
    switch (selected)
    {
        case 0: strcat(pinboard_command, " -TTTL"); break;
        case 1: strcat(pinboard_command, " -TTBL"); break;
        case 2: strcat(pinboard_command, " -TTTR"); break;
        case 3: strcat(pinboard_command, " -TTBR"); break;
    }

    error_trap(stringset_get_selected(1, config_id, TidyStackMenu, &selected), 0);
    if (selected == 1) strcat(pinboard_command, " -TSV");

    /* Now write the commands to the choices file */
    error_trap(write_pinboard_choices(backdrop_command, pinboard_command), 0);        
}


/*---------------------------------------------------------------------------*
 * try_it                                                                    *
 *                                                                           *
 * User has clicked on 'Try' button, so make up a *Backdrop command and      *
 * execute it.                                                               *
 *---------------------------------------------------------------------------*/

static void try_it(void)
{
    char backdrop_string[1024];
    char string[64];
    int  lighter;
    int  option;
    int  radio;
    
    memset(backdrop_string, 0, 1024);
    error_trap(radiobutton_get_state(0, config_id, PlainColourRadio, 0, &option), 0);

    sprintf(backdrop_string, "Backdrop -Colour &%x", background_colour);

    switch(option)
    {
        case StandardTileRadio:
            error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);
            tile_filename(current_tile, lighter, string);
            strcat(backdrop_string, " -Tile ");
            strcat(backdrop_string, string);
            break;

        case CustomImageRadio:
            if (custom_filename[0] == 0) break;
            memset(string, 0, 64);
            error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio), 0);
            switch (radio)
            {
                case ScaledRadioButton: sprintf(string, " -Scale "); break;
                case TiledRadioButton: sprintf(string, " -Tile "); break;
                default: sprintf(string, " -Centre "); break;
            }
            strcat(backdrop_string, string);
            strcat(backdrop_string, custom_filename);
            break;

        case PlainColourRadio:
            strcat(backdrop_string, " -Remove");
            break;
    }

    error_trap(_swix(OS_CLI, _IN(0), backdrop_string), 0);
}


/*---------------------------------------------------------------------------*
 * update_background_colour_icon                                             *
 *                                                                           *
 * Update the background colour icon to display the user's choice of colour. *
 *---------------------------------------------------------------------------*/

static void update_background_colour_icon(void)
{
    _kernel_oserror *e;
    BBox             gadget_bbox;
    char            *sprite_addr;
    int             *sprite_data;
    int              width;
    int              height;
    int              i;

    e=sprite_find_address_of(client_sprite_area, "plain_col", &sprite_addr);
    if (!e) e=sprite_return_size(client_sprite_area, sprite_addr, &width, &height);

    /* Fill in the 'plain_col' sprite with the new colour */
    if (!e)
    {
        sprite_data = (int*) (sprite_addr + 44);

        for (i=0; i < (width*height); i++)
        {
            sprite_data[i] = background_colour>>8;
        }
    }
       
    /* Force a redraw of the 'plain_col' icon */
    error_trap(gadget_get_bbox(0, config_id, PlainColBox, &gadget_bbox), 0);
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * update_standard_tile_icon                                                 *
 *                                                                           *
 * Update the standard tile icon to display the user's choice of tile.       *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static void update_standard_tile_icon(void)
{
    BBox gadget_bbox;
    char tilename[128];
    int  lighter;
    
    error_trap(optionbutton_get_state(0, config_id, LighterOptionButton, &lighter), 0);

    /* Check if this tile exists. If not, then previous one must do, but that's already */
    /* displayed, so exit */
    if (!tile_filename(current_tile, lighter, tilename))
    {
        current_tile--;
        return;
    }
    
    /* Update sprite and redraw */
    error_trap(texture_into_sprite(client_sprite_area, tilename, 0, "std_tile"), 0);
    error_trap(gadget_get_bbox(0, config_id, StandardTileSprite, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}    


/*---------------------------------------------------------------------------*
 * redraw_custom_image_icon                                                  *
 *                                                                           *
 * Force a redraw of the custom_image icon                                   *
 *---------------------------------------------------------------------------*/

static void redraw_custom_image_icon(void)
{
    BBox gadget_bbox;

    error_trap(gadget_get_bbox(0, config_id, CustomDropZone, &gadget_bbox), 0);
    gadget_bbox.xmin += 8;
    gadget_bbox.xmax -= 8;
    gadget_bbox.ymin += 8;
    gadget_bbox.ymax -= 8;
    error_trap(window_force_redraw(0, config_id, &gadget_bbox), 0);
}


/*---------------------------------------------------------------------------*
 * update_custom_image_icon                                                  *
 *                                                                           *
 * Force an update of the custom image icon, so that it shows the user's     *
 * latest choice.                                                            *
 *---------------------------------------------------------------------------*/

static void update_custom_image_icon(void)
{
    int radio_on;
   
    error_trap(radiobutton_get_state(0, config_id, ScaledRadioButton, 0, &radio_on), 0);
    
    /* Prevent tiled JPEGs */
    if (custom_filetype == JPEGFileType)
    {
        grey_gadget(config_id, TiledRadioButton);

        if (radio_on == TiledRadioButton)
        {
            error_trap(radiobutton_set_state(0, config_id, CentredRadioButton, 1), 0);
            radio_on = CentredRadioButton;
        }
    }
    else
    {        
        ungrey_gadget(config_id, TiledRadioButton);
    }
 
    /* Create custom image icon */
    switch (custom_filetype)
    {
        case SpriteFileType:
            error_trap(do_custom_image_sprite(client_sprite_area, custom_filename,
                                              radio_on, background_colour), 0);
            redraw_custom_image_icon();
            break;

        case JPEGFileType:
            error_trap(do_custom_image_jpeg(client_sprite_area, custom_filename,
                                            radio_on, background_colour), 0);
            redraw_custom_image_icon();
            break;
    }
}    


/*---------------------------------------------------------------------------*
 * grey_backdrop_choices                                                     *
 *                                                                           *
 * Depending on which of the backdrop types (plain colour, standard tile or  *
 * custom image) is selected, grey appropriate options.                      *
 *                                                                           *
 * In: icon = id of the radio icon which is selected.                        *
 *---------------------------------------------------------------------------*/

static void grey_backdrop_choices(int icon)
{
    switch (icon)
    {
        case PlainColourRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;

        case StandardTileRadio:
            ungrey_gadget(config_id, LighterOptionButton);
            ungrey_gadget(config_id, TileUpArrow);
            ungrey_gadget(config_id, TileDownArrow);
            grey_gadget(config_id, ScaledRadioButton);
            grey_gadget(config_id, CentredRadioButton);
            grey_gadget(config_id, TiledRadioButton);
            break;
    
        case CustomImageRadio:
            grey_gadget(config_id, LighterOptionButton);
            grey_gadget(config_id, TileUpArrow);
            grey_gadget(config_id, TileDownArrow);
            ungrey_gadget(config_id, ScaledRadioButton);
            ungrey_gadget(config_id, CentredRadioButton);
            ungrey_gadget(config_id, TiledRadioButton);
            break;
    }
}


/*---------------------------------------------------------------------------*
 * parse_backdrop_command                                                    *
 *                                                                           *
 * Parse a *Backdrop command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Backdrop                                   *
 *                                                                           *
 * Globals: current_tile, background_colour, custom_filetype                 *
 *---------------------------------------------------------------------------*/

static void parse_backdrop_command(char *string)
{
    char  backdrop_args[] = "path,Centre=C/S,Tile=T/S,Scale=S/S,N=NoRecache/S,Remove=R/S,Colour/E";
    char *path;
    int   buffer[256];
    int   custom_radio = TiledRadioButton;
    int   backdrop_type;
    int   filetype;
    int   texture_no;
    int   is_lighter;

    error_trap(_swix(OS_ReadArgs, _INR(0,3), backdrop_args, string, buffer, 256*sizeof(int)), 0);

    /* Check for colour */
    if (buffer[6])
    {
        unsigned int  colour_block[2];
        char         *answer = ((char*)buffer[6] + 1);
        
        background_colour = (answer[3]<<24) + (answer[2]<<16) + (answer[1]<<8);
        update_background_colour_icon();
        colour_block[0] = background_colour;
        colour_block[1] = 0;
        error_trap(colourdbox_set_colour(0, colourbox_id, (int*)&colour_block), 0);
    }

    /* Are we tiled, scaled or centred? */
    if (buffer[1]) custom_radio = CentredRadioButton;
    if (buffer[2]) custom_radio = TiledRadioButton;
    if (buffer[3]) custom_radio = ScaledRadioButton;
    error_trap(radiobutton_set_state(0, config_id, custom_radio, 1), 0);
    
    /* If a pathname was specified, check it is a sprite or a JPEG */
    path = (char*)buffer[0];
    if (path != 0)
    {
        error_trap(_swix(OS_File, _INR(0,1)|_OUT(6), 23, path, &filetype), 0);
        if ((filetype != SpriteFileType) && (filetype != JPEGFileType)) path = 0;
    }
        
    /* Depending on the type of backdrop (plain colour, standard tile, custom image)... */            
    if (path == 0)
    {
        /* No pathname - use a plain colour */
        backdrop_type = PlainColourRadio;
   }
    else if (path_is_a_standard_texture(path, &texture_no, &is_lighter))
    {
        /* This is a standard tile */
        backdrop_type = StandardTileRadio;
        current_tile = texture_no;
        error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, is_lighter), 0);
        update_standard_tile_icon();        
    }    
    else
    {
        /* Custom image */
        backdrop_type = CustomImageRadio;
        strcpy(custom_filename, path);
        custom_filetype = filetype;
        update_custom_image_icon();
        update_standard_tile_icon();
    }

    /* Grey other icons as appropriate */
    error_trap(radiobutton_set_state(0, config_id, backdrop_type, 1), 0);
    grey_backdrop_choices(backdrop_type);
}


/*---------------------------------------------------------------------------*
 * parse_pinboard_command                                                    *
 *                                                                           *
 * Parse a *Pinboard command and set options in configure window as          *
 * appropriate.                                                              *
 *                                                                           *
 * In: string -> Parameters from *Pinboard                                   *
 *---------------------------------------------------------------------------*/

static void parse_pinboard_command(char *string)
{
    char pinboard_args[300];
    int  buffer[16];
    int  grid_lock = 0;
    int  iconise_to = 0;
    int  iconise_stack = 0;
    int  tidy_to = 0;
    int  tidy_stack = 0;
    int  n;

    strcpy(pinboard_args, "Grid=/S,IconiseToIconBar=ITIB/S,");
    strcat(pinboard_args, "IconiseToTopLeft=ITTL/S,IconiseToBottomLeft=ITBL/S,");
    strcat(pinboard_args, "IconiseToTopRight=ITTR/S,IconiseToBottomRight=ITBR/S,");
    strcat(pinboard_args, "IconiseStackVertical=ISV/S,");
    strcat(pinboard_args, "TidyToTopLeft=TTTL/S,TidyToBottomLeft=TTBL/S,");
    strcat(pinboard_args, "TidyToTopRight=TTTR/S,TidyToBottomRight=TTBR/S,");
    strcat(pinboard_args, "TidyStackVertical=TSV/S,");
    
    error_trap(_swix(OS_ReadArgs, _INR(0,3), pinboard_args, string, buffer, 16*sizeof(int)), 0);

    /* Read Grid lock option */
    if (buffer[0]) grid_lock = 1;
    else grid_lock = 0;

    /* Read Iconise to... options */
    for (n=1; n<=5; n++) if (buffer[n]) iconise_to = n;
    if (buffer[6]) iconise_stack = 1;
    else iconise_stack = 0;

    /* Read Tidy to... options */
    for (n=7; n<=10; n++) if (buffer[n]) tidy_to = n - 7;
    if (buffer[11]) tidy_stack = 1;
    else tidy_stack = 0;

    /* Update icons */
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, grid_lock), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)iconise_to), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)iconise_stack), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, (char*)tidy_to), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, (char*)tidy_stack), 0);
    
    /* Grey out iconise stack menu if iconise to iconbar or to icon */
    if (iconise_to < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);    
}


/*---------------------------------------------------------------------------*
 * read_choices                                                              *
 *                                                                           *
 * Read the *Pinboard and *Backdrop commands from the choices file.          *
 *---------------------------------------------------------------------------*/

static void read_choices(void)
{
    FILE *fp;
    char  string[1024];
    int   more = 1;

    /* Read current setup */
    fp=fopen(ChoicesFile, "r");
    if (fp)
    {
        while (more)
        {
            more=(int)fgets(string, 1024, fp);
            if (more)
            {
                if (strncmpa(string, "backdrop", 8)==0) parse_backdrop_command(string+9);
                else if (strncmpa(string, "pinboardoptions", 15)==0) parse_pinboard_command(string+16);
            }
        }
        fclose(fp);
    }
}    


/*---------------------------------------------------------------------------*
 * set_default_choices                                                       *
 *                                                                           *
 * Set the default choices.                                                  *
 *                                                                           *
 * Globals: current_tile, background_colour                                  *
 *---------------------------------------------------------------------------*/

static void set_default_choices(void)
{
    memset(custom_filename, 0, MaxFilenameSize);

    error_trap(radiobutton_set_state(0, config_id, StandardTileRadio, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, LighterOptionButton, 0), 0);
    error_trap(radiobutton_set_state(0, config_id, TiledRadioButton, 1), 0);
    error_trap(optionbutton_set_state(0, config_id, GridLockOption, 0), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseToMenu, (char*)4), 0);
    error_trap(stringset_set_selected(1, config_id, IconiseStackMenu, (char*)1), 0);
    error_trap(stringset_set_selected(1, config_id, TidyToMenu, 0), 0);
    error_trap(stringset_set_selected(1, config_id, TidyStackMenu, 0), 0);
    ungrey_gadget(config_id, IconiseStackMenu);

    background_colour = DefaultBackgroundColour;
    update_background_colour_icon();

    error_trap(texture_into_sprite(client_sprite_area,
                                   "<PinConfig$Dir>.Sprites",
                                   "cust_tile",
                                   "cust_tile"), 0);
    redraw_custom_image_icon();

    current_tile = 1;
    update_standard_tile_icon();    
}


/*-----------------------------------------------------------------------------------------------*
 *                                      Event handlers                                           *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * toolbox_error                                                             *
 *                                                                           *
 * Handler for errors from toolbox.                                          *
 *---------------------------------------------------------------------------*/

static int toolbox_error(int event_code, ToolboxEvent *event, IdBlock *id_block, void *handle)
{
    ToolboxErrorEvent *error_event = (ToolboxErrorEvent *)event;
    _kernel_oserror    err;

    strcpy(err.errmess, error_event->errmess);
    err.errnum = error_event->errnum;
    wimp_report_error(&err, 0, "Configure", 0, 0, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * default_key_handler                                                       *
 *                                                                           *
 * Handler for key presses.                                                  *
 *---------------------------------------------------------------------------*/

static int default_key_handler(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
   int key_code = event->key_pressed.key_code;

   wimp_process_key(key_code);

   return 1;
}


/*---------------------------------------------------------------------------*
 * action_selected                                                           *
 *                                                                           *
 * Handler for when action buttons are clicked on.                           *
 *---------------------------------------------------------------------------*/

static int action_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ActionButtonSelectedEvent *block = (ActionButtonSelectedEvent*) event_block;
    int                        icon = id_block->self_component;

    switch (icon)
    {
        case TryActionButton:
            try_it();
            break;

        case SetActionButton:
            save_choices();
            if ((block->hdr.flags & 7) == 0) program_exit(); /* Return pressed */
            if (block->hdr.flags & 4) program_exit();        /* Left button */
            break;

        case CancelActionButton:
            if ((block->hdr.flags & 7) == 0) program_exit(); /* Escape pressed */
            if (block->hdr.flags & 1) read_choices();        /* Right button */
            if (block->hdr.flags & 4) program_exit();        /* Left button */
            break;

        case DefaultActionButton:
            set_default_choices();
            break;
    }

    return 1;
}


/*---------------------------------------------------------------------------*
 * adjuster_clicked                                                          *
 *                                                                           *
 * Handler for when adjuster arrows are clicked.                             *
 *                                                                           *
 * Globals: current_tile                                                     *
 *---------------------------------------------------------------------------*/

static int adjuster_clicked(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    AdjusterClickedEvent *adjuster_block = (AdjusterClickedEvent*) event_block;
    int                   icon = id_block->self_component;

    if ((icon == TileUpArrow) || (icon == TileDownArrow))
    {
        if (adjuster_block->direction == 0) current_tile--;
        else current_tile++;
        
        if (current_tile<1) current_tile = 1;                      
        else update_standard_tile_icon();
    }
     
    return 1;
}


/*---------------------------------------------------------------------------*
 * colour_selected                                                           *
 *                                                                           *
 * Handler for colour selection from Colour Dialogue Box                     *
 *                                                                           *
 * Globals: background_colour                                                *
 *---------------------------------------------------------------------------*/

static int colour_selected(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    ColourDboxColourSelectedEvent *evblock = (ColourDboxColourSelectedEvent*) event_block;
    char                          *colour_block = (char*)evblock + 16;
    int                            state;
    
    background_colour = (colour_block[3]<<24) + (colour_block[2]<<16) + (colour_block[1]<<8);

    update_background_colour_icon();

    error_trap(radiobutton_get_state(0, config_id, CentredRadioButton, &state, 0), 0);
    if (state == 1) update_custom_image_icon();

    return 1;
}
   

/*---------------------------------------------------------------------------*
 * option_changed                                                            *
 *                                                                           *
 * Handler for option button changed events.                                 *
 *---------------------------------------------------------------------------*/

static int option_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
                
    if (icon == LighterOptionButton) update_standard_tile_icon();

    return 1;
}


/*---------------------------------------------------------------------------*
 * radio_changed                                                             *
 *                                                                           *
 * Handler for radio button changed events.                                  *
 *---------------------------------------------------------------------------*/

static int radio_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;

    switch (icon)
    {
        case ScaledRadioButton:
        case CentredRadioButton:
        case TiledRadioButton:
            update_custom_image_icon();
            break;
                    
        case PlainColourRadio:
        case StandardTileRadio:
        case CustomImageRadio:
            grey_backdrop_choices(icon);
            break;
    }
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * stringset_changed                                                         *
 *                                                                           *
 * Handle event when stringset value changes.                                *
 *---------------------------------------------------------------------------*/

static int stringset_changed(int event_code, ToolboxEvent *event_block, IdBlock *id_block, void *handle)
{
    int icon = id_block->self_component;
    int selected;

    /* We're only interested in the iconise to menu */
    if (icon != IconiseToMenu) return 1;
    
    error_trap(stringset_get_selected(1, config_id, IconiseToMenu, &selected), 0);    

    /* If Iconise to icon or iconise to iconbar, grey the iconise stack menu */
    if (selected < 2) grey_gadget(config_id, IconiseStackMenu);
    else ungrey_gadget(config_id, IconiseStackMenu);

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/
 
static int message_quit(WimpMessage *event, void *handler)
{
    program_exit();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * message_reopen                                                            *
 *                                                                           *
 * Called when we receive a message from Configure telling us to reopen our  *
 * window.                                                                   *
 *---------------------------------------------------------------------------*/

static int message_reopen(WimpMessage *event, void *handler)
{
    error_trap(toolbox_show_object(0, config_id, 0, 0, 0, 0), 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * message_dataload                                                          *
 *                                                                           *
 * Called when wimp dataload message received.                               *
 *                                                                           *
 * Globals: custom_filetype                                                  *
 *---------------------------------------------------------------------------*/
 
static int message_dataload(WimpMessage *event, void *handler)
{
    int object;
    int component;
    int window = event->data.data_load.destination_window;
    int icon = event->data.data_load.destination_icon;
    int filetype = event->data.data_load.file_type;
    
    error_trap(window_wimp_to_toolbox(0, window, icon, &object, &component), 0);

    if (object != config_id) return 1;
    if (component != CustomDropZone) return 1;
    if ((filetype != SpriteFileType) && (filetype != JPEGFileType)) return 1;
    
    error_trap(radiobutton_set_state(0, config_id, CustomImageRadio, 1), 0);
    grey_backdrop_choices(CustomImageRadio);
    
    custom_filetype = filetype;
    strcpy(custom_filename, event->data.data_load.leaf_name);
    update_custom_image_icon();

    return 1;
}


/*---------------------------------------------------------------------------*
 * close_window                                                              *
 *                                                                           *
 * Called when user has clicked on close icon of window.                     *
 *---------------------------------------------------------------------------*/

static int close_window(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();
    
    return 1;
}


/*-----------------------------------------------------------------------------------------------*
 *                              Program startup & Polling loop                                   *
 *-----------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*
 * open_configure_window                                                     *
 *                                                                           *
 * Called to open the configure window on screen and register handlers.      *
 *---------------------------------------------------------------------------*/

static void open_configure_window(int at_x, int at_y)
{
    BBox bbox;
    int  screenx;
    int  screeny;
    int  buffer[2];

    /* Create window */
    error_trap(toolbox_create_object(0, "PinConfig", &config_id), 1);
    error_trap(toolbox_create_object(0, "BGColDbox", &colourbox_id), 1);
    error_trap(popup_set_menu(0, config_id, PlainColourPopUp, colourbox_id), 1);
    update_standard_tile_icon();
    read_choices();

    /* Register handlers for the configure window */
    error_trap(event_register_toolbox_handler(-1,Toolbox_Error,toolbox_error,NULL) ,0);
    error_trap(event_register_wimp_handler(config_id, Wimp_ECloseWindow, close_window, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, Adjuster_Clicked, adjuster_clicked, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, ActionButton_Selected, action_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, OptionButton_StateChanged, option_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(-1, ColourDbox_ColourSelected, colour_selected, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, RadioButton_StateChanged, radio_changed, NULL), 0);
    error_trap(event_register_toolbox_handler(config_id, StringSet_ValueChanged, stringset_changed, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MDataLoad, message_dataload, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EKeyPressed, default_key_handler, NULL), 0);

    /* Work out positioning (unless it was supplied in the command line) */
    if ((at_x == -1) && (at_y == -1))
    {
        error_trap(common_read_screensize(&screenx, &screeny), 0);
        error_trap(window_get_extent(0, config_id, &bbox), 0);
        at_y = screeny - ((screeny+bbox.ymin)/2);
        at_x = (screenx - bbox.xmax)/2;
    }

    /* Show the window */
    buffer[0] = at_x;
    buffer[1] = at_y;
    error_trap(toolbox_show_object(0, config_id, 2, buffer, 0, 0), 0);
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *                                                                           *
 * Initialise toolbox etc.                                                   *
 *                                                                           *
 * Returns: 1 if everything went okay, 0 otherwise                           *
 *                                                                           *
 * Globals: custom_filename, client_sprite_area                              *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    static int mess_wanted[] = {Wimp_MQuit,
                                Wimp_MDataLoad,
                                Wimp_MOpenConfigWindow,
                                0};
    static int tbox_wanted[] = {Toolbox_Error,
                                Adjuster_Clicked,
                                ActionButton_Selected,
                                OptionButton_StateChanged,
                                ColourDbox_ColourSelected,
                                RadioButton_StateChanged,
                                Toolbox_ObjectAutoCreated,
                                StringSet_ValueChanged,
                                0};
    void      *sprptr;
    int        task_handle;

    custom_filename = malloc(MaxFilenameSize);
    if (!custom_filename) return 0;
    memset(custom_filename, 0, MaxFilenameSize);
                                
    error_trap(toolbox_initialise(0, 310, mess_wanted, tbox_wanted,
                                  "<PinConfig$Dir>", &messages_desc, &idb,
                                  0, &task_handle, &sprptr) ,1);
    client_sprite_area = (int*)sprptr;
    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_NullMask), 0);    
    messages_register(&messages_desc, messages_string);

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_message_handler(Wimp_MOpenConfigWindow, message_reopen, NULL), 0);

    return 1;
}
                                  

/*---------------------------------------------------------------------------*
 * main                                                                      *
 *                                                                           *
 * Main polling loop                                                         *
 *---------------------------------------------------------------------------*/

int main(int argc, char *argv[])
{
    WimpPollBlock wpb;
    int           event_code;
    int           openat_x = -1;
    int           openat_y = -1;

    /* Have we been passed any co-ordinates to open at? */
    if (strcmp(argv[1], "-openat") == 0)
    {
        openat_x = atoi(argv[2]);
        openat_y = atoi(argv[3]);
    }

    /* Do main initialisation */
    if (!main_initialise()) return 0;
    
    /* Open configure window */
    open_configure_window(openat_x, openat_y);

    /* Poll loop */
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, NULL), 0);
    }
    
    return 0;
}         

