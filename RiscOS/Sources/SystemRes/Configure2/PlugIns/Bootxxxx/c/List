/******	List.c ************************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	BootApps/BootBoot/BootRun
This file:	Handling routines for scrolling list

History:
Date		Who	Change
----------------------------------------------------------------------------
11/06/1998	BJGA	Created
12/06/1998	BJGA	Implemented static_FreeLists, static_FindRange,
			static_WordMatch, static_AddFileToLists and static_AddItem
15/06/1998	BJGA	Added detection of the Repeat command in static_AddFileToLists
			Added path translation code to static_AddItem
16/06/1998	BJGA	Added List_RedrawWindow, List_SetAll, List_HandleMouseClick
			and static_Examine; implemented static_Rearrange,
			static_SetExtent, static_ScrollTo, static_Refresh,
			static_RecalculateX and static_DetermineSprite
17/06/1998	BJGA	Added Dragging and DragType, plus "click-type" drag handling code
			Fixed icon drawing/detection to allow for different-sized sprites
18/06/1998	BJGA	Added List_HandleDragBox, List_RemoveSelection, static_CutItem,
			static_CopyItem, static_DeleteSelection and static_PasteList.
			Pane now reopened after resizing, in case it has shrunk.
19/06/1998	BJGA	Changes to various functions to allow non-editable lists to be
			rescanned without affecting the main list (for use in handling
			Message_ChoicesChanged when the main list is modified).
			Cases where a contiguous selection is moved on top of itself are
			now optimised out, and don't cause Modified flag to be set.
			static_Examine made global and renamed List_Examine.
			Commented out static_ScrollTo (not currently used, but potentially
			useful in future).
			Implemented List_Load, List_HandleFontChanged and List_Write.

\**************************************************************************/

/* CLib */
#include <stdlib.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
/* Toolbox */
#include "toolbox.h"
#include "wimplib.h"
#include "window.h"
/* ConfigureLib */
#include "misc.h"
#include "str.h"
/* Local headers */
#include "List.h"
#include "Main.h"

#define PREDESKTOP	"<Choices$Write>.Boot.PreDesktop"
#define DESKTOP		"<Choices$Write>.Boot.Desktop"

#define BIGNUM		(0x3FFFFFFFu)

#ifndef Wimp_AutoScroll
#define Wimp_AutoScroll	(0x400FD)
#endif

#define NULL_item	{ NULL, NULL, NULL, NULL, { 0, 0, 0, 0 }, 0, 0, FALSE, "", FALSE, FALSE }

/* Typedefs */

typedef struct
{
  int window_handle;
  BBox pause_zone;
  int pause_time;
  int state_change_handler;
  void *workspace;
}
MyWimpAutoScrollBlock;

typedef struct item
{
  struct item *next;
  struct item *prev;
  char *fullpath;
  char *path;
  BBox pos;
  int objecttype;
  int filetype;
  BOOL repeat;
  char sprite [13];
  BOOL halfsize;
  BOOL selected;
}
item;

typedef enum
{
  dragtype_selectrubber,
  dragtype_adjustrubber,
  dragtype_shiftselectrubber,
  dragtype_shiftadjustrubber,
  dragtype_movedrag,
  dragtype_copydrag
}
dragtype;

/* Global variables */

	BOOL	Dragging = FALSE;

static	item	PreListHead	= NULL_item;
static	item	PreListFoot	= NULL_item;
static	item	ListHead	= NULL_item;
static	item	ListFoot	= NULL_item;
static	item	PostListHead	= NULL_item;
static	item	PostListFoot	= NULL_item;
static	item	TempListHead	= NULL_item;
static	item	TempListFoot	= NULL_item;
static dragtype DragType;

/* Prototypes */

static void static_FreeLists (BOOL free_main);
static _kernel_oserror *static_FindRange (const char *file,
    const char *section, const char *company, const char *application,
    BOOL *found, unsigned int *start, unsigned int *end);
static _kernel_oserror *static_WordMatch (const char *line, const char *match,
    BOOL invert, BOOL *success, const char **after);
static _kernel_oserror *static_AddFileToLists (const char *file,
    unsigned int entry0, unsigned int entry1, BOOL ignore_main);
static _kernel_oserror *static_Rearrange (void);
static _kernel_oserror *static_SetExtent (void);
//static _kernel_oserror *static_ScrollTo (item *where);
static _kernel_oserror *static_Refresh (void);
static _kernel_oserror *static_AddItem (const char *path, BOOL repeat, item *ref, BOOL after, int type);
static _kernel_oserror *static_CutItem (item *link);
static _kernel_oserror *static_CopyItem (item *link);
static _kernel_oserror *static_DeleteSelection (item *list);
static _kernel_oserror *static_PasteList (item *before);
static _kernel_oserror *static_RecalculateX (item *link);
static _kernel_oserror *static_DetermineSprite (item *link);


/******	List_Read() *******************************************************\

Purpose:	Reads PreDesktop/Desktop to find appropriate operations
Out:		Error pointer

\**************************************************************************/

_kernel_oserror *List_Read (BOOL rescan)
{
  _kernel_oserror *err = NULL;
  BOOL found;
  unsigned int line_first;
  unsigned int line_last;
  BOOL preserve_main = FALSE;
  WimpGetWindowStateBlock state;
  int yfixed = 0;
  
  if (Modified && rescan)
  {
    preserve_main = TRUE;
  }
  
  /* Get old pane window state */
  err = window_get_wimp_handle (0, Pane_Obj, &(state.window_handle));
  if (!err) err = wimp_get_window_state (&state);
  /* Remember where top of main list was on screen (for rescans) */
  if (!err) yfixed = ListHead.next->pos.ymax + state.visible_area.ymax - state.yscroll;
  
  /* Free old list */
  static_FreeLists (!preserve_main);
  
  /* Scan PreDesktop file */
  
  #if APP == BOOTAPPS
  if (!err)
  {
    err = static_FindRange (PREDESKTOP, "ResApps", "Acorn", "BootApps", &found, &line_first, &line_last);
    if (!err && !found)
    {
      /* Entry doesn't exist, it'll go after all Acorn ResApps */
      err = static_FindRange (PREDESKTOP, "ResApps", "Acorn", NULL, &found, NULL, &line_last);
      if (!err && found)
      {
        line_first = line_last;
      }
      else if (!err && !found)
      {
        /* Acorn ResApps doesn't exist, entry will go after all ResApps */
        err = static_FindRange (PREDESKTOP, "ResApps", NULL, NULL, &found, NULL, &line_last);
        if (!err && found)
        {
          line_first = line_last;
        }
        else if (!err && !found)
        {
          /* ResApps doesn't exist, entry will go at end */
          line_first = line_last = BIGNUM;
        }
      }
    }
  }
  
  #else /* APP == BOOTBOOT or BOOTRUN */
  /* Our entry comes after this file */
  line_first = line_last = BIGNUM;
  
  #endif
  
  if (!err)
  {
    err = static_AddFileToLists (PREDESKTOP, line_first, line_last, preserve_main);
  }
  
  
  /* Scan Desktop file */
  
  #if   APP == BOOTAPPS
  /* Our entry comes before this file */
  line_first = line_last = 0;
  
  #elif APP == BOOTBOOT
  if (!err)
  {
    err = static_FindRange (DESKTOP, "Boot", "Acorn", "BootBoot", &found, &line_first, &line_last);
    if (!err && !found)
    {
      /* Entry doesn't exist, it'll go after all Acorn Boot */
      err = static_FindRange (DESKTOP, "Boot", "Acorn", NULL, &found, NULL, &line_last);
      if (!err && found)
      {
        line_first = line_last;
      }
      else if (!err && !found)
      {
        /* Acorn Boot doesn't exist, entry will go after all Boot */
        err = static_FindRange (DESKTOP, "Boot", NULL, NULL, &found, NULL, &line_last);
        if (!err && found)
        {
          line_first = line_last;
        }
        else if (!err && !found)
        {
          /* Boot doesn't exist, entry will go after all Auto */
          err = static_FindRange (DESKTOP, "Auto", NULL, NULL, &found, NULL, &line_last);
          if (!err && found)
          {
            line_first = line_last;
          }
          else if (!err && !found)
          {
            /* Auto doesn't exist, entry will go at end */
            line_first = line_last = BIGNUM;
          }
        }
      }
    }
  }
  
  #elif APP == BOOTRUN
  if (!err)
  {
    err = static_FindRange (DESKTOP, "Run", "Acorn", "BootRun", &found, &line_first, &line_last);
    if (!err && !found)
    {
      /* Entry doesn't exist, it'll go after all Acorn Run */
      err = static_FindRange (DESKTOP, "Run", "Acorn", NULL, &found, NULL, &line_last);
      if (!err && found)
      {
        line_first = line_last;
      }
      else if (!err && !found)
      {
        /* Acorn Run doesn't exist, entry will go after all Run */
        err = static_FindRange (DESKTOP, "Run", NULL, NULL, &found, NULL, &line_last);
        if (!err && found)
        {
          line_first = line_last;
        }
        else if (!err && !found)
        {
          /* Run doesn't exist, entry will go after all Boot */
          err = static_FindRange (DESKTOP, "Auto", NULL, NULL, &found, NULL, &line_last);
          if (!err && found)
          {
            line_first = line_last;
          }
          else if (!err && !found)
          {
            /* Boot doesn't exist, entry will go after all Auto */
            err = static_FindRange (DESKTOP, "Auto", NULL, NULL, &found, NULL, &line_last);
            if (!err && found)
            {
              line_first = line_last;
            }
            else if (!err && !found)
            {
              /* Auto doesn't exist, entry will go at end */
              line_first = line_last = BIGNUM;
            }
          }
        }
      }
    }
  }  
  
  #endif
  
  if (!err)
  {
    err = static_AddFileToLists (DESKTOP, line_first, line_last, preserve_main);
  }
  
  
  /* Reset layout and window states */
  if (!err) err = static_Rearrange ();
  if (!err) err = static_SetExtent ();
  
  /* Scroll window: if a rescan, try to keep editable list at same place on screen, */
  /* otherwise scroll to top of pane */
  if (!err) err = wimp_get_window_state (&state); /* it may have changed */
  if (!err)
  {
    if (rescan && ListHead.next->next != NULL)
    {
      state.yscroll = ListHead.next->pos.ymax + state.visible_area.ymax - yfixed;
    }
    else
    {
      state.yscroll = 0;
    }
    err = wimp_open_window ((WimpOpenWindowBlock *) &state);
  }
  
  /* Redraw whole pane */
  if (!err) err = static_Refresh ();
  
  if (!err && Modified && !rescan)
  {
    err = window_set_title (0, Window_Obj, Title_Unmodified);
    Modified = FALSE;
  }
  
  return err;
}

/******	List_Write() ******************************************************\

Purpose:	Merges the modified list back into (Pre)Desktop
In:		Mouse buttons
Out:		Error pointer

\**************************************************************************/

_kernel_oserror *List_Write (int buttons)
{
  _kernel_oserror *err = NULL;
  #if   APP == BOOTAPPS
  const char *file = "Pipe:$.BootApps";
  #elif APP == BOOTBOOT
  const char *file = "Pipe:$.BootBoot";
  #elif APP == BOOTRUN
  const char *file = "Pipe:$.BootRun";
  #endif
  FILE *f;
  item *ptr;
  char *version;
  
  f = fopen (file, "w");
  if (f == NULL)
  {
    /* Can't open the file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), file, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    /* Get version number string */
    err = _swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2), &messages, "VersionNumber", 0, &version);
  }
  
  if (!err)
  {
    /* Write file, as appropriate to the plug-in */
    #if   APP == BOOTAPPS
    
    fprintf (f, "|App Configure>*\n|Variable\n\n");
    fprintf (f, "|Start Acorn BootApps %s ResApps\n", version);
    
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      fprintf (f, "IfThere %s Then AddApp %s%s\n",
          ptr->path,
          ptr->path,
          (ptr->repeat == TRUE) ? ".!*" : "" );
    }
    
    #elif APP == BOOTBOOT
    
    fprintf (f, "|Section Boot>Auto\n|Variable\n\n");
    fprintf (f, "|Start Acorn BootBoot %s Boot\n", version);
    
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      fprintf (f, "IfThere %s Then %sFiler_Boot %s%s\n",
          ptr->path,
          (ptr->repeat == TRUE) ? "Repeat " : "",
          ptr->path,
          (ptr->repeat == TRUE) ? " -Applications -Tasks" : "" );
    }
    
    #elif APP == BOOTRUN
    
    fprintf (f, "|Section Run>Boot Run>Auto\n|Variable\n\n");
    fprintf (f, "|Start Acorn BootRun %s Run\n", version);
    
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      if (ptr->filetype == 0x1000 || ptr->filetype == 0x2000 || ptr->repeat == TRUE)
      {
        fprintf (f, "IfThere %s Then %sFiler_Boot %s%s\n",
            ptr->path,
            (ptr->repeat == TRUE) ? "Repeat " : "",
            ptr->path,
            (ptr->repeat == TRUE) ? " -Applications -Tasks" : "" );
      }
      fprintf (f, "IfThere %s Then %sFiler_Run %s%s\n",
          ptr->path,
          (ptr->repeat == TRUE) ? "Repeat " : "",
          ptr->path,
          (ptr->repeat == TRUE) ? " -Tasks" : "" );
    }
    
    #endif
    
    fprintf (f, "|End\n\n");
    
    fclose (f);
    
    err = _swix (OS_File, _INR(0,2), 18 /* set type */, file, 0xFEB /* obey file */);
  }
  if (!err)
  {
    /* Do the merge! */
    WimpMessage block;
    block.hdr.your_ref = 0;
    block.hdr.action_code = Wimp_MChoicesChanged;
    #if   APP == BOOTAPPS
    err = _swix (OS_CLI, _IN(0), "Install_Merge " PREDESKTOP " Pipe:$.BootApps " PREDESKTOP);
    str_cpy (block.data.bytes, "Boot.PreDesktop");
    #elif APP == BOOTBOOT
    err = _swix (OS_CLI, _IN(0), "Install_Merge " DESKTOP " Pipe:$.BootBoot " DESKTOP);
    str_cpy (block.data.bytes, "Boot.Desktop");
    #elif APP == BOOTRUN
    err = _swix (OS_CLI, _IN(0), "Install_Merge " DESKTOP " Pipe:$.BootRun " DESKTOP);
    str_cpy (block.data.bytes, "Boot.Desktop");
    #endif
    block.hdr.size = sizeof (block.hdr) + (~3 & (str_len (block.data.bytes) + 1 + 3));
    if (!err)
    {
      /* Broadcast the fact that the file has been updated */
      err = wimp_send_message (17, &block, 0, 0, NULL);
    }
  }
  
  /* Quit, or mark unmodified, according to buttons */
  if (!err)
  {
    if (0 == (buttons & ActionButton_Selected_Adjust))
    {
      Quit = TRUE;
    }
    else if (Modified)
    {
      err = window_set_title (0, Window_Obj, Title_Unmodified);
      Modified = FALSE;
    }
  }
  return err;
}

/******	List_RedrawWindow() ***********************************************\

Purpose:	Handles pane redraw
In:		Pane window handle

\**************************************************************************/

void List_RedrawWindow (int handle)
{
  WimpRedrawWindowBlock block;
  int more;
  block.window_handle = handle;
  throw (wimp_redraw_window (&block, &more));
  while (more)
  {
    item *ptr;
    WimpPlotIconBlock icon;
    int yorg = block.visible_area.ymax - block.yscroll;
    int y0;
    int y1;
    y0 = block.redraw_area.ymin - yorg;
    y1 = block.redraw_area.ymax - yorg;
    
    /* These aspects remain constant */
    icon.flags = 0x17000113;
    
    /* Step through list, identify icons that intersect the redraw rectangle */
    for (ptr = PreListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      int intersection_min = max(y0, ptr->pos.ymin);
      int intersection_max = min(y1, ptr->pos.ymax);
      if (intersection_max > intersection_min)
      {
        char val_str [14];
        icon.bbox = ptr->pos;
        icon.flags = 0x17400113;
        if (ptr->halfsize) icon.flags |= (1 << 11);
        icon.data.ist.buffer = ptr->fullpath;
        sprintf (val_str, "S%s", ptr->sprite);
        icon.data.ist.validation = val_str;
        icon.data.ist.buffer_size = str_len (ptr->fullpath);
        throw (wimp_plot_icon (&icon));
      }
    }
    
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      int intersection_min = max(y0, ptr->pos.ymin);
      int intersection_max = min(y1, ptr->pos.ymax);
      if (intersection_max > intersection_min)
      {
        char val_str [14];
        icon.bbox = ptr->pos;
        icon.flags = 0x17000113;
        if (ptr->selected) icon.flags |= (1 << 21);
        if (ptr->halfsize) icon.flags |= (1 << 11);
        icon.data.ist.buffer = ptr->fullpath;
        sprintf (val_str, "S%s", ptr->sprite);
        icon.data.ist.validation = val_str;
        icon.data.ist.buffer_size = str_len (ptr->fullpath);
        throw (wimp_plot_icon (&icon));
      }
    }
    
    for (ptr = PostListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      int intersection_min = max(y0, ptr->pos.ymin);
      int intersection_max = min(y1, ptr->pos.ymax);
      if (intersection_max > intersection_min)
      {
        char val_str [14];
        icon.bbox = ptr->pos;
        icon.flags = 0x17400113;
        if (ptr->halfsize) icon.flags |= (1 << 11);
        icon.data.ist.buffer = ptr->fullpath;
        sprintf (val_str, "S%s", ptr->sprite);
        icon.data.ist.validation = val_str;
        icon.data.ist.buffer_size = str_len (ptr->fullpath);
        throw (wimp_plot_icon (&icon));
      }
    }
    
    throw (wimp_get_rectangle (&block, &more));
  }  
}

/******	List_SetAll() *****************************************************\

Purpose:	Selects / deselects all editable items
In:		On or off

\**************************************************************************/

void List_SetAll (BOOL on)
{
  int handle;
  item *ptr;
  
  throw (window_get_wimp_handle (0, Pane_Obj, &handle));
  
  for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    if (ptr->selected != on)
    {
      ptr->selected = on;
      throw (wimp_force_redraw (handle, ptr->pos.xmin, ptr->pos.ymin, BIGNUM, ptr->pos.ymax));
    }
  }
}

/******	List_HandleMouseClick() *******************************************\

Purpose:	Processes mouse click events
In:		Pane window handle, work area x/y, mouse buttons

\**************************************************************************/

void List_HandleMouseClick (int handle, int x, int y, int b)
{
  item *which = (item *) List_Examine (x, y);
  static int click_x;
  static int click_y;
  static int click_b;
  static item *click_item;
  BOOL shift_pressed = _swi (OS_Byte, _INR(0,1)|_RETURN(1), 121 /* keyboard scan */, 0x80);
  
  switch (b)
  {
    case Wimp_MouseButtonSelect:
      click_x = x;
      click_y = y;
      click_b = b;
      click_item = which;
      
      switch ((int) which)
      {
        case 0: /* Not over anything */
          List_SetAll (FALSE);
          break;
          
        case 1: /* Over faded item */
          /* do nothing */
          break;
          
        default:
          if (which->selected != TRUE)
          {
            List_SetAll (FALSE);
            which->selected = TRUE;
            throw (wimp_force_redraw (handle, which->pos.xmin, which->pos.ymin, BIGNUM, which->pos.ymax));
          }
          break;
      }
      break;
      
    case Wimp_MouseButtonAdjust:
      click_x = x;
      click_y = y;
      click_b = b;
      click_item = which;
      
      if (which != NULL && which != (item *) 1)
      {
        which->selected = !which->selected;
        throw (wimp_force_redraw (handle, which->pos.xmin, which->pos.ymin, BIGNUM, which->pos.ymax));
      }
      break;
      
    case Wimp_MouseButtonSelect * 16: /* drag */
    case Wimp_MouseButtonAdjust * 16: /* drag */
      switch ((int) click_item)
      {
        WimpGetWindowStateBlock state;
        WimpDragBox block;
        MyWimpAutoScrollBlock ablock;
        
        case 0: /* Not over anything */
          if (click_b == Wimp_MouseButtonSelect && !shift_pressed)
          {
            DragType = dragtype_selectrubber;
          }
          else if (click_b == Wimp_MouseButtonAdjust && !shift_pressed)
          {
            DragType = dragtype_adjustrubber;
          }
          else if (click_b == Wimp_MouseButtonSelect && shift_pressed)
          {
            DragType = dragtype_shiftselectrubber;
          }
          else
          {
            DragType = dragtype_shiftadjustrubber;
          }
          
          state.window_handle = handle;
          throw (wimp_get_window_state (&state));
          
          block.wimp_window = handle;
          block.drag_type = Wimp_DragBox_DragRubberDash;
          block.dragging_box.xmin = click_x + state.visible_area.xmin - state.xscroll;
          block.dragging_box.ymin = click_y + state.visible_area.ymax - state.yscroll;
          block.dragging_box.xmax = block.dragging_box.xmin;
          block.dragging_box.ymax = block.dragging_box.ymin;
          block.parent_box.xmin = state.visible_area.xmin;
          block.parent_box.ymin = -BIGNUM;
          block.parent_box.xmax = state.visible_area.xmax;
          block.parent_box.ymax = +BIGNUM;
          _swi (Wimp_DragBox, _INR(1,3), &block, 0x4B534154, 3);
          
          ablock.window_handle = state.window_handle;
          ablock.pause_zone.xmin = 0;
          ablock.pause_zone.ymin = 12;
          ablock.pause_zone.xmax = 0;
          ablock.pause_zone.ymax = 12;
          ablock.pause_time = 0;
          ablock.state_change_handler = 1;
          _swi (Wimp_AutoScroll, _INR(0,1), 2, &ablock);
          
          Dragging = TRUE;
          break;
          
        case 1: /* Over faded item */
          /* do nothing */
          break;
          
        default:
          if (click_b == Wimp_MouseButtonAdjust && click_item->selected == FALSE)
          { /* undo the effect of the click */
            click_item->selected = TRUE;
            throw (wimp_force_redraw (handle,
                click_item->pos.xmin, click_item->pos.ymin, BIGNUM, click_item->pos.ymax));
          }
          
          if (!shift_pressed)
          {
            DragType = dragtype_movedrag;
          }
          else
          {
            DragType = dragtype_copydrag;
          }
          
          state.window_handle = handle;
          throw (wimp_get_window_state (&state));
          
          {
            item *ptr;
            /* Find bounds of the selection */
            block.dragging_box.xmin = 12;
            block.dragging_box.ymin = +BIGNUM;
            block.dragging_box.xmax = 12;
            block.dragging_box.ymax = -BIGNUM;
            for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
            {
              if (ptr->selected)
              {
                block.dragging_box.ymin = min(ptr->pos.ymin, block.dragging_box.ymin);
                block.dragging_box.xmax = max(ptr->pos.xmax, block.dragging_box.xmax);
                block.dragging_box.ymax = max(ptr->pos.ymax, block.dragging_box.ymax);
              }
            }
            block.dragging_box.xmin += state.visible_area.xmin - state.xscroll - 4;
            block.dragging_box.ymin += state.visible_area.ymax - state.yscroll - 4;
            block.dragging_box.xmax += state.visible_area.xmin - state.xscroll + 4;
            block.dragging_box.ymax += state.visible_area.ymax - state.yscroll + 4;
            
            /* Convert "click" coordinates back to screen-relative */
            x += state.visible_area.xmin - state.xscroll;
            y += state.visible_area.ymax - state.yscroll;
            
            /* Calculate dragbox's bounds */
            block.parent_box.xmin = state.visible_area.xmin + block.dragging_box.xmin - x;
            block.parent_box.xmax = state.visible_area.xmax + block.dragging_box.xmax - x;
            block.parent_box.ymin = -BIGNUM;
            block.parent_box.ymax = +BIGNUM;
            
            block.wimp_window = handle;
            block.drag_type = Wimp_DragBox_DragFixedDash;
            _swi (Wimp_DragBox, _INR(1,3), &block, 0x4B534154, 3);
            
            ablock.window_handle = state.window_handle;
            ablock.pause_zone.xmin = 0;
            ablock.pause_zone.ymin = 12;
            ablock.pause_zone.xmax = 0;
            ablock.pause_zone.ymax = 12;
            ablock.pause_time = 0;
            ablock.state_change_handler = 1;
            _swi (Wimp_AutoScroll, _INR(0,1), 2, &ablock);
          }
          Dragging = TRUE;
          break;
      }
      break;
      
    default: /* do nothing */
      break;
  }
}

/******	List_HandleDragBox() **********************************************\

Purpose:	Processes drag box events
In:		Pane window handle, final position of dragbox (work area coordinates)

\**************************************************************************/

void List_HandleDragBox (int handle, BBox pos)
{
  item *ptr;  
  switch (DragType)
  {
    case dragtype_selectrubber:
    case dragtype_adjustrubber:
      /* Find intersection of box with editable list */
      for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
      {
        BBox inter;
        inter.xmin = max(ptr->pos.xmin, pos.xmin);
        inter.ymin = max(ptr->pos.ymin, pos.ymin);
        inter.xmax = min(ptr->pos.xmax, pos.xmax);
        inter.ymax = min(ptr->pos.ymax, pos.ymax);
        if (inter.xmin < inter.xmax && inter.ymin < inter.ymax)
        {
          if (DragType == dragtype_selectrubber)
          {
            /* Turn item on */
            ptr->selected = TRUE;
          }
          else /* adjustrubber */
          {
            /* Toggle item */
            ptr->selected = !ptr->selected;
          }
          /* Update screen */
          throw (wimp_force_redraw (handle, ptr->pos.xmin, ptr->pos.ymin, ptr->pos.xmax, ptr->pos.ymax));
        }
      }
      break;
      
    case dragtype_shiftselectrubber:
    case dragtype_shiftadjustrubber:
      /* Find items that fall entirely within box */
      for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
      {
        if (ptr->pos.xmin >= pos.xmin && ptr->pos.ymin >= pos.ymin &&
            ptr->pos.xmax <= pos.xmax && ptr->pos.ymax <= pos.ymax)
        {
          if (DragType == dragtype_shiftselectrubber)
          {
            /* Turn item on */
            ptr->selected = TRUE;
          }
          else /* shiftadjustrubber */
          {
            /* Toggle item */
            ptr->selected = !ptr->selected;
          }
          /* Update screen */
          throw (wimp_force_redraw (handle, ptr->pos.xmin, ptr->pos.ymin, ptr->pos.xmax, ptr->pos.ymax));
        }
      }
      break;
      
    case dragtype_movedrag:
    case dragtype_copydrag:
      {
        int preop_selection_ymax = -BIGNUM;
        int preop_selection_ymin = +BIGNUM;
        int postop_selection_ymax = -BIGNUM;
        int postop_selection_ymin = +BIGNUM;
        int closest_distance = +BIGNUM;
        item *next;
        item *insert_before = &ListFoot;
        WimpGetPointerInfoBlock pointer;
        WimpGetWindowStateBlock state;
        BOOL changed = TRUE;
        
        /* Take note of where the pointer ended up (ignore dragbox position) */
        throw (wimp_get_pointer_info (&pointer));
        state.window_handle = handle;
        throw (wimp_get_window_state (&state));
        pointer.y -= state.visible_area.ymax - state.yscroll; /* convert to work area coords */
        
        /* Optimise out cases where no change will be taking place */
        /* This means moves where a contigouus selection is dropped on top of itself */
        if (DragType == dragtype_movedrag)
        {
          item *ptr = ListHead.next;
          item *sel_start = NULL;
          item *sel_end = NULL;
          
          for (; ptr->selected == FALSE && ptr->next != NULL; ptr = ptr->next) ;
          if (ptr->next != NULL) sel_start = ptr;
          for (; ptr->selected == TRUE  && ptr->next != NULL; ptr = ptr->next) ;
          if (sel_start != NULL) sel_end = ptr;
          for (; ptr->selected == FALSE && ptr->next != NULL; ptr = ptr->next) ;
          if (sel_start != NULL && ptr->next == NULL)
          {
            /* Selection is contiguous, were we moving it anywhere? */
            int sel_ymax = (sel_start->prev->pos.ymin + sel_start->prev->pos.ymax) / 2;
            int sel_ymin = (sel_end->pos.ymin + sel_end->pos.ymax) / 2;
            if (sel_start->prev->prev == NULL)
            {
              sel_ymax = +BIGNUM;
            }
            if (sel_end->next == NULL)
            {
              sel_ymin = -BIGNUM;
            }
            if (pointer.y <= sel_ymax && pointer.y > sel_ymin)
            {
              changed = FALSE;
            }
          }
        }
        
        if (changed)
        {
          
          /* Measure the position of the selection before the operation */
          for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
          {
            if (ptr->selected && ptr->pos.ymin < preop_selection_ymin)
            {
              preop_selection_ymin = ptr->pos.ymin;
            }
            if (ptr->selected && ptr->pos.ymax > preop_selection_ymax)
            {
              preop_selection_ymax = ptr->pos.ymax;
            }
          }
          
          /* Cut or copy the selection to the TempList */
          for (ptr = ListHead.next; ptr->next != NULL; ptr = next)
          {
            next = ptr->next;
            if (ptr->selected)
            {
              if (DragType == dragtype_movedrag)
              {
                throw (static_CutItem (ptr));
              }
              else /* dragtype_copydrag */
              {
                throw (static_CopyItem (ptr));
                ptr->selected = FALSE;
              }
            }
          }
          
          /* Find the nearest remaining item to the pointer */
          for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
          {
            int midpoint = (ptr->pos.ymin + ptr->pos.ymax) / 2;
            if (abs (pointer.y - midpoint) <= closest_distance)
            {
              closest_distance = abs (pointer.y - midpoint);
              if (pointer.y > midpoint)
              {
                insert_before = ptr;
              }
              else
              {
                insert_before = ptr->next;
              }
            }
          }
          
          /* Paste TempList back in */
          throw (static_PasteList (insert_before));
          throw (static_Rearrange ());
          throw (static_SetExtent ());
          
          /* Measure the position of the selection after the operation */
          for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
          {
            if (ptr->selected && ptr->pos.ymin < postop_selection_ymin)
            {
              postop_selection_ymin = ptr->pos.ymin;
            }
            if (ptr->selected && ptr->pos.ymax > postop_selection_ymax)
            {
              postop_selection_ymax = ptr->pos.ymax;
            }
          }
          
          /* Invalidate the appropriate part of the pane */
          if (DragType == dragtype_movedrag)
          {
            throw (wimp_force_redraw (handle,
                -BIGNUM, min(preop_selection_ymin, postop_selection_ymin),
                +BIGNUM, max(preop_selection_ymax, postop_selection_ymax)));
          }
          else /* dragtype_copydrag */
          {
            throw (wimp_force_redraw (handle, -BIGNUM, -BIGNUM,
                +BIGNUM, max(preop_selection_ymax, postop_selection_ymax)));
          }
          
          /* Update the title bar if necessary */
          if (Modified == FALSE)
          {
            throw (window_set_title (0, Window_Obj, Title_Modified));
            Modified = TRUE;
          }
        }
      }
      break;
  }
  Dragging = FALSE;
}

/******	List_RemoveSelection() ********************************************\

Purpose:	Handles "Remove selection" action button

\**************************************************************************/

void List_RemoveSelection (void)
{
  item *ptr = ListHead.next;
  
  /* Find whether there is a selection, and if so, where it starts */
  while (ptr->selected == FALSE && ptr->next != NULL)
  {
    ptr = ptr->next;
  }
  
  if (ptr->selected == TRUE)
  {
    /* Invalidate appropriate area */
    WimpGetWindowStateBlock state;
    throw (window_get_wimp_handle (0, Pane_Obj, &(state.window_handle)));
    throw (wimp_get_window_state (&state));
    throw (wimp_force_redraw (state.window_handle, -BIGNUM, -BIGNUM, +BIGNUM,
        ptr->pos.ymax + (state.visible_area.ymax - state.yscroll)));
    
    /* Remove and free links */
    throw (static_DeleteSelection (&ListHead));
    
    /* Sort out layout */
    throw (static_Rearrange ());
    throw (static_SetExtent ());
    
    /* Update the title bar if necessary */
    if (Modified == FALSE)
    {
      throw (window_set_title (0, Window_Obj, Title_Modified));
      Modified = TRUE;
    }
  }
}

/******	List_Load() *******************************************************\

Purpose:	Handles loading of files/apps/directories from Filer or Pinboard

\**************************************************************************/

void List_Load (const char *path, BOOL repeat)
{
  static BOOL initialised = FALSE;
  static item *insert_before;
  WimpGetWindowStateBlock state;
  item *ptr;
  
  /* Get pane window state */
  throw (window_get_wimp_handle (0, Pane_Obj, &(state.window_handle)));
  throw (wimp_get_window_state (&state));
  
  if (!initialised || path == NULL)
  {
    /* Work out where we're inserting the selection */
    int closest_distance = +BIGNUM;
    WimpGetPointerInfoBlock pointer;
    initialised = TRUE;
    
    /* Take note of where the pointer ended up */
    throw (wimp_get_pointer_info (&pointer));
    pointer.y -= state.visible_area.ymax - state.yscroll; /* convert to work area coords */
    
    /* Find the nearest item to the pointer */
    insert_before = &ListFoot; /* default */
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      int midpoint = (ptr->pos.ymin + ptr->pos.ymax) / 2;
      if (abs (pointer.y - midpoint) <= closest_distance)
      {
        closest_distance = abs (pointer.y - midpoint);
        if (pointer.y > midpoint)
        {
          insert_before = ptr;
        }
        else
        {
          insert_before = ptr->next;
        }
      }
    }
    
    /* Deselect the current selection (deleting it doesn't makes sense if it's not contiguous) */
    for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
    {
      if (ptr->selected)
      {
        ptr->selected = FALSE;
        throw (wimp_force_redraw (state.window_handle,
            ptr->pos.xmin, ptr->pos.ymin, ptr->pos.xmax, ptr->pos.ymax));
      }
    }
  }
  
  if (path != NULL)
  {
    /* Insert the new item */
    throw (static_AddItem (path, repeat, insert_before, FALSE, 1));
    insert_before->prev->selected = TRUE;
    throw (static_Rearrange ());
    throw (static_SetExtent ());
    
    /* Invalidate the appropriate part of the pane */
    throw (wimp_force_redraw (state.window_handle, -BIGNUM, -BIGNUM, +BIGNUM,
        insert_before->prev->pos.ymax));
    
    /* Update the title bar if necessary */
    if (Modified == FALSE)
    {
      throw (window_set_title (0, Window_Obj, Title_Modified));
      Modified = TRUE;
    }
  }
}

/******	List_HandleFontChanged() ******************************************\

Purpose:	Recalculates icon widths under the new desktop font

\**************************************************************************/

void List_HandleFontChanged (void)
{
  item *ptr;
  
  for (ptr = PreListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    throw (static_RecalculateX (ptr));
  }
  
  for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    throw (static_RecalculateX (ptr));
  }
  
  for (ptr = PostListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    throw (static_RecalculateX (ptr));
  }
}

/******	List_Examine() ****************************************************\

Purpose:	Checks to see what object is at a given position in the pane
In:		Work area x/y
Out:		Pointer to item, or NULL for no item, or 1 for faded item

\**************************************************************************/

int List_Examine (int x, int y)
{
  item *ptr;
  item *result = NULL;
  
  for (ptr = ListHead.next; result == NULL && ptr->next != NULL; ptr = ptr->next)
  {
    if ((ptr->pos.xmin <= x) && (x < ptr->pos.xmax) && (ptr->pos.ymin <= y) && (y < ptr->pos.ymax))
    {
      result = ptr;
    }
  }
  
  if (result == NULL)
  {
    for (ptr = PreListHead.next; result == NULL && ptr->next != NULL; ptr = ptr->next)
    {
      if ((ptr->pos.xmin <= x) && (x < ptr->pos.xmax) && (ptr->pos.ymin <= y) && (y < ptr->pos.ymax))
      {
        result = (item *) 1;
      }
    }    
  }
  
  if (result == NULL)
  {
    for (ptr = PostListHead.next; result == NULL && ptr->next != NULL; ptr = ptr->next)
    {
      if ((ptr->pos.xmin <= x) && (x < ptr->pos.xmax) && (ptr->pos.ymin <= y) && (y < ptr->pos.ymax))
      {
        result = (item *) 1;
      }
    }    
  }
  
  return (int) result;
}

/******	static_FreeLists() ************************************************\

Purpose:	Frees the linked lists
In:		Whether to free the main list as well

\**************************************************************************/

static void static_FreeLists (BOOL free_main)
{
  item *ptr;
  
  /* Step through PreList */
  ptr = PreListHead.next;
  while (ptr && ptr->next != NULL)
  {
    free (ptr->path);
    ptr = ptr->next;
    free (ptr->prev);
  }
  
  if (free_main)
  {
    /* Step through main List */
    ptr = ListHead.next;
    while (ptr && ptr->next != NULL)
    {
      free (ptr->path);
      ptr = ptr->next;
      free (ptr->prev);
    }
  }
  
  /* Step through PostList */
  ptr = PostListHead.next;
  while (ptr && ptr->next != NULL)
  {
    free (ptr->path);
    ptr = ptr->next;
    free (ptr->prev);
  }
  
  /* Step through TempList (shouldn't be necessary, but just in case) */
  ptr = TempListHead.next;
  while (ptr && ptr->next != NULL)
  {
    free (ptr->path);
    ptr = ptr->next;
    free (ptr->prev);
  }
  
  /* Now (re-)initialise headers */
  PreListHead.next = &PreListFoot;
  PreListFoot.prev = &PreListHead;
  if (free_main)
  {
    ListHead.next = &ListFoot;
    ListFoot.prev = &ListHead;
  }
  PostListHead.next = &PostListFoot;
  PostListFoot.prev = &PostListHead;
  TempListHead.next = &TempListFoot;
  TempListFoot.prev = &TempListHead;
}

/******	static_FindRange() ************************************************\

Purpose:	Finds the line range of an entry or set of entries within a file
In:		Filename, parameters of entry/ies, reference to return
		success boolean and start/end line numbers if successful
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_FindRange (const char *file,
    const char *section, const char *company, const char *application,
    BOOL *found, unsigned int *start, unsigned int *end)
{
  _kernel_oserror *err = NULL;
  FILE *f = fopen (file, "r");
  *found = FALSE;
  if (f == NULL)
  {
    /* Can't open the file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), file, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    /* Step through file, checking for lines that match our parameters */
    char line [1024];
    unsigned int lno = 0;
    while (!err && !*found && (BOOL) fgets (line, sizeof (line), f))
    {
      BOOL match;
      lno++;
      str_cpy (line, line); /* null-terminate */
      err = static_WordMatch (line, "|Start", TRUE, &match, NULL);
      if (!err && match) err = static_WordMatch (NULL, company, TRUE, &match, NULL);
      if (!err && match) err = static_WordMatch (NULL, application, TRUE, &match, NULL);
      if (!err && match) err = static_WordMatch (NULL, NULL, TRUE, &match, NULL);
      if (!err && match) err = static_WordMatch (NULL, section, TRUE, &match, NULL);
      if (!err && match)
      {
        /* Found the (inclusive) start, now find the end */
        if (start) *start = lno;
        if (end) *end = BIGNUM;
        while (!err && !*found && (BOOL) fgets (line, sizeof (line), f))
        {
          BOOL match;
          BOOL differs;
          lno++;
          str_cpy (line, line); /* null-terminate */
          err = static_WordMatch (line, "|Start", TRUE, &match, NULL);
          if (!err && match            ) err = static_WordMatch (NULL, company, FALSE, &differs, NULL);
          if (!err && match && !differs) err = static_WordMatch (NULL, application, FALSE, &differs, NULL);
          if (!err && match && !differs) err = static_WordMatch (NULL, NULL, FALSE, &differs, NULL);
          if (!err && match && !differs) err = static_WordMatch (NULL, section, FALSE, &differs, NULL);
          if (!err && match && differs)
          {
            /* Found the (exclusive) end */
            if (end) *end = lno;
            *found = TRUE;
          }
        }
        if (!err) *found = TRUE; /* just in case we never did find the end */
      }
    }
  }
  fclose (f);
  return err;
}

/******	static_WordMatch() ************************************************\

Purpose:	Finds a word within a string, and compares it case-
		insensitively with a supplied string
In:		Source string pointer (or NULL to continue along last string)
		Comparison string pointer (NULL means just advance by a word)
		Whether to look for equivalence (TRUE) or difference (FALSE)
		Reference to return success
		Reference to return pointer to next word
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_WordMatch (const char *line, const char *match,
    BOOL invert, BOOL *success, const char **after)
{
  _kernel_oserror *err = NULL;
  static const char *ptr = "";
  char *ptr2;
  int buflen = str_len (match) + 2;
  char *buffer;
  
  buffer = malloc (buflen);
  if (buffer == NULL)
  {
    /* Can't allocate memory to hold a writable copy of line for comparison purposes */
    _kernel_oserror block = { 0, "Err_Alloc" };
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), 0, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    if (line) ptr = line;
    
    if (match)
    {
      /* Copy a space-or-control-terminated bit of line into buffer */
      ptr2 = buffer;
      while (*ptr > ' ' && ptr2 < buffer + buflen - 1)
      {
        *ptr2 = *ptr;
        ptr++;
        ptr2++;
      }
      *ptr2 = '\0';
      
      /* Now get ptr to skip spaces, ready for the next call */
      while (*ptr == ' ')
      {
        ptr++;
      }
      
      /* Compare strings */
      err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, buffer, match, 1, success);
      if (invert)
      {
        *success = !*success;
      }
      
    }
    else
    {
      /* Skip word */
      while (*ptr > ' ')
      {
        ptr++;
      }
      /* Skip following spaces */
      while (*ptr == ' ')
      {
        ptr++;
      }
      /* Return as though we found an equivalence */
      *success = invert;
    }
    
    /* Return pointer if desired */
    if (after) *after = ptr;
  }
  
  free (buffer);
  
  return err;
}

/******	static_AddFileToLists() *******************************************\

Purpose:	Scans a file for appropriate commands, and adds them to
		the appropriate linked list
In:		Filename, first editable line number (inclusive),
		last editable line number (exclusive)
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_AddFileToLists (const char *file,
    unsigned int entry0, unsigned int entry1, BOOL ignore_main)
{
  _kernel_oserror *err = NULL;
  FILE *f = fopen (file, "r");
  if (f == NULL)
  {
    /* Can't open the file! Generate an error */
    _kernel_oserror block = { 0, "CantOpen" };
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), file, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    /* Scan one line at a time */
    char line [1024];
    unsigned int lno = 0;
    while (!err && (BOOL) fgets (line, sizeof (line), f))
    {
      BOOL success;
      BOOL repeated = FALSE;
      const char *nextword = line;
      lno++;
      do
      {
        BOOL found_repeat;
        err = static_WordMatch (nextword, "Repeat", TRUE, &found_repeat, NULL);
        if (found_repeat) repeated = TRUE;
        if (!err)
        {
          #if   APP == BOOTAPPS
          err = static_WordMatch (nextword, "AddApp", TRUE, &success, &nextword);
          #elif APP == BOOTBOOT
          err = static_WordMatch (nextword, "Filer_Boot", TRUE, &success, &nextword);
          #elif APP == BOOTRUN
          err = static_WordMatch (nextword, "Filer_Run", TRUE, &success, &nextword);
          #endif
        }
      }
      while (!err && !success && *nextword > ' ');
      if (!err && success && *nextword > ' ')
      {
        /* Found a command - object name is pointed to by 'nextword' */
        if (lno < entry0) /* place in prelist */
        {
          err = static_AddItem (nextword, repeated, &PreListFoot, FALSE, 0);
        }
        else if (lno < entry1) /* place in main list */
        {
          if (!ignore_main)
          {
            err = static_AddItem (nextword, repeated, &ListFoot, FALSE, 2);
          }
        }
        else /* place in postlist */
        {
          err = static_AddItem (nextword, repeated, &PostListFoot, FALSE, 0);
        }
      }
    }
  }
  fclose (f);
  return err;
}

/******	static_Rearrange() ************************************************\

Purpose:	(Re-)calculates the y positions of all items
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_Rearrange (void)
{
  _kernel_oserror *err = NULL;
  item *ptr;
  int y = 0;
  
  for (ptr = PreListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    y -= 12;
    ptr->pos.ymax = y;
    y -= 34;
    ptr->pos.ymin = y;
  }
  
  for (ptr = ListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    y -= 12;
    ptr->pos.ymax = y;
    y -= 34;
    ptr->pos.ymin = y;
  }
  
  for (ptr = PostListHead.next; ptr->next != NULL; ptr = ptr->next)
  {
    y -= 12;
    ptr->pos.ymax = y;
    y -= 34;
    ptr->pos.ymin = y;
  }
  
  return err;
}

/******	static_SetExtent() ************************************************\

Purpose:	Sets pane's extent to hold entire list
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_SetExtent (void)
{
  _kernel_oserror *err = NULL;
  static BOOL firsttime = TRUE;
  static BBox original;
  BBox extent;
  item *ptr = PostListFoot.prev;
  if (ptr->prev == NULL) ptr = ListFoot.prev;
  if (ptr->prev == NULL) ptr = PreListFoot.prev;
  
  if (firsttime)
  {
    err = window_get_extent (0, Pane_Obj, &original);
    firsttime = FALSE;
  }
  
  if (!err)
  {
    extent = original;
    if (ptr->prev != NULL)
    {
      extent.ymin = ptr->pos.ymin - 12;
      extent.ymin = min(extent.ymin, original.ymin);
    }
    err = window_set_extent (0, Pane_Obj, &extent);
  }
  
  if (!err)
  {
    /* Now re-open window, in case it's been shrunk and the scroll ofset needs auto-adjusting */
    err = toolbox_show_object (0, Pane_Obj,
        Toolbox_ShowObject_Default, NULL, NULL_ObjectId, NULL_ComponentId);
  }
  
  return err;
}

///****** static_ScrollTo() *************************************************\
//
//Purpose:	Ensures that a particular item is visible
//In:		Item pointer
//Out:		Error pointer
//
//\**************************************************************************/
//
//static _kernel_oserror *static_ScrollTo (item *where)
//{
//  _kernel_oserror *err = NULL;
//  WimpGetWindowStateBlock block;
//  err = window_get_wimp_handle (0, Pane_Obj, &(block.window_handle));
//  if (!err)
//  {
//    err = wimp_get_window_state (&block);
//  }
//  if (!err)
//  {
//    int wa_ymax = block.yscroll;
//    int wa_ymin = block.yscroll - (block.visible_area.ymax - block.visible_area.ymin);
//    if (where->pos.ymin < (wa_ymin + 12) || where->pos.ymax > (wa_ymax - 12))
//    {
//      block.yscroll = where->pos.ymax + 12;
//      err = wimp_open_window ((WimpOpenWindowBlock *) &block);
//    }
//  }
//  return err;
//}

/******	static_Refresh() **************************************************\

Purpose:	Marks the pane work area invalid
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_Refresh (void)
{
  _kernel_oserror *err = NULL;
  int handle;
  err = window_get_wimp_handle (0, Pane_Obj, &handle);
  if (!err)
  {
    err = wimp_force_redraw (handle, -BIGNUM, -BIGNUM, BIGNUM, BIGNUM);
  }
  return err;
}

/******	static_AddItem() **************************************************\

Purpose:	Adds an item to a linked list
In:		Path of object (space- or control-terminated)
		Whether *Repeat was used in command
		Pointer to adjoining link
		Whether to add after rather than before
		Path type: 0 => no translation
		           1 => full (try to map canonical to Boot-relative)
		           2 => relative (try to map Boot: to canonicalised)
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_AddItem (const char *path, BOOL repeat, item *ref, BOOL after, int type)
{
  _kernel_oserror *err = NULL;
  _kernel_oserror block = { 0, "Err_Alloc" };
  item *newitem = NULL;
  char *newitem_path = NULL;
  char *newitem_fullpath = NULL;
  char temp [256];
  const char *ptr;
  int diff;
  
  /* Count the length of the object name so we know how much memory to allocate */
  for (ptr = path; *ptr > ' '; ptr++);
  
  #if APP == BOOTAPPS
  /* Remove any trailing ".!*" */
  if (*(ptr-3) == '.' && *(ptr-2) == '!' && *(ptr-1) == '*')
  {
    ptr -= 3;
    repeat = TRUE;
  }
  #endif
  
  /* Allocate memory */
  newitem = malloc (sizeof (item));
  newitem_path = malloc (ptr - path + BootDiff + 1);
  newitem_fullpath = malloc (ptr - path + BootDiff + 1);
  if (!newitem || !newitem_path || !newitem_fullpath)
  {
    /* Allocation failed */
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), 0, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    /* Build and insert link */
    /* 1) Determine internal and external strings */
    switch (type)
    {
      case 1: /* ADFS::HardDisc4.$.!Boot. -> Boot:  or  ADFS::HardDisc4.$. -> Boot:^. */
        str_ncpy (newitem_fullpath, path, ptr - path + 1);
        str_ncpy (temp, newitem_fullpath, str_len (BootPath) + 1);
        err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, temp, BootPath, 1, &diff);
        if (!err && diff == 0)
        {
          sprintf (newitem_path, "Boot:%s", newitem_fullpath + str_len (BootPath));
        }
        else if (!err && diff != 0)
        {
          temp [str_len (BootHat)] = '\0';
          err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, temp, BootHat, 1, &diff);
          if (!err && diff == 0)
          {
            sprintf (newitem_path, "Boot:^.%s", newitem_fullpath + str_len (BootHat));
          }
          else if (!err && diff != 0)
          {
            str_cpy (newitem_path, newitem_fullpath);
          }
        }
        break;
        
      case 2: /* Boot:^. -> ADFS::HardDisc4.$.  or  Boot: -> ADFS::HardDisc4.$.!Boot. */
        str_ncpy (newitem_path, path, ptr - path + 1);
        str_ncpy (temp, newitem_path, 8);
        err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, temp, "Boot:^.", 1, &diff);
        if (!err && diff == 0)
        {
          sprintf (newitem_fullpath, "%s%s", BootHat, newitem_path + 7);
        }
        else if (!err && diff != 0)
        {
          temp [5] = '\0';
          err = _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1, temp, "Boot:", 1, &diff);
          if (!err && diff == 0)
          {
            sprintf (newitem_fullpath, "%s%s", BootPath, newitem_path + 5);
          }
          else if (!err && diff != 0)
          {
            str_cpy (newitem_fullpath, newitem_path);
          }
        }
        break;
        
      default: /* no translation */
        str_ncpy (newitem_path, path, ptr - path + 1);
        str_cpy (newitem_fullpath, newitem_path);
        break;
    }
    newitem->path = newitem_path;
    newitem->fullpath = newitem_fullpath;
    
    /* 2) Get object type / filetype */
    if (!err)
    {
      err = _swix (OS_File, _INR(0,1)|_OUT(0)|_OUT(6), 23,
          newitem_fullpath, &(newitem->objecttype), &(newitem->filetype));
    }
    
    /* 3) Get sprite name and size */
    if (!err)
    {
      err = static_DetermineSprite (newitem);
    }
    
    /* 4) Determine xmin / xmax */
    if (!err)
    {
      err = static_RecalculateX (newitem);
    }
    
    /* 5) Miscellaneous */
    if (!err)
    {
      newitem->repeat = repeat; /* Typically used by directories */
      newitem->selected = FALSE;
    }
    
    /* 6) Add link to list */
    if (!err)
    {
      if (after)
      {
        newitem->prev = ref;
        newitem->next = ref->next;
        ref->next->prev = newitem;
        ref->next = newitem;
      }
      else
      {
        newitem->next = ref;
        newitem->prev = ref->prev;
        ref->prev->next = newitem;
        ref->prev = newitem;
      }
    }
  }
  
  if (err)
  {
    /* Deallocate */
    free (newitem_fullpath);
    free (newitem_path);
    free (newitem);
  }
  
  return err;
}

/******	static_CutItem() **************************************************\

Purpose:	Cuts an item to the end of TempList
In:		Pointer to item
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_CutItem (item *link)
{
  _kernel_oserror *err = NULL;
  
  link->prev->next = link->next;
  link->next->prev = link->prev;
  
  link->prev = TempListFoot.prev;
  link->next = &TempListFoot;
  
  TempListFoot.prev->next = link;
  TempListFoot.prev = link;
  
  return err;
}

/******	static_CopyItem() *************************************************\

Purpose:	Copies an item to the end of TempList
In:		Pointer to item
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_CopyItem (item *link)
{
  _kernel_oserror *err = NULL;
  item *newlink = NULL;
  char *newfullpath = NULL;
  char *newpath = NULL;
  
  newlink = malloc (sizeof (item));
  newfullpath = malloc (str_len (link->fullpath) + 1);
  newpath = malloc (str_len (link->path) + 1);
  
  if (!newlink || !newfullpath || !newpath)
  {
    /* Oh dear, free TempList and return error */
    _kernel_oserror block = { 0, "Err_Alloc" };
    
    free (newpath);
    free (newfullpath);
    free (newlink);
    
    static_DeleteSelection (&TempListHead);
    
    _swix (MessageTrans_ErrorLookup, _INR(0,7), &block, messages,
        &ErrorBuffer, sizeof (ErrorBuffer), 0, 0, 0, 0);
    err = &ErrorBuffer;
  }
  else
  {
    *newlink = *link;
    
    newlink->fullpath = newfullpath;
    str_cpy (newfullpath, link->fullpath);
    newlink->path = newpath;
    str_cpy (newpath, link->path);
    
    newlink->prev = TempListFoot.prev;
    newlink->next = &TempListFoot;
    
    TempListFoot.prev->next = newlink;
    TempListFoot.prev = newlink;
  }
  
  return err;
}

/******	static_DeleteSelection() ******************************************\

Purpose:	Deletes all the selected items from a list
In:		Pointer to list header
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_DeleteSelection (item *list)
{
  _kernel_oserror *err = NULL;
  item *ptr;
  item *next;
  
  for (ptr = list->next; ptr->next != NULL; ptr = next)
  {
    next = ptr->next;
    if (ptr->selected)
    {
      ptr->prev->next = ptr->next;
      ptr->next->prev = ptr->prev;
      free (ptr->path);
      free (ptr->fullpath);
      free (ptr);
    }
  }
  
  return err;
}

/******	static_PasteList() ************************************************\

Purpose:	Moves TempList wholesale into another list
In:		Pointer to insert in front of
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_PasteList (item *before)
{
  _kernel_oserror *err = NULL;
  
  TempListHead.next->prev = before->prev;
  TempListFoot.prev->next = before;
  
  before->prev->next = TempListHead.next;
  before->prev = TempListFoot.prev;
  
  TempListHead.next = &TempListFoot;
  TempListFoot.prev = &TempListHead;
  
  return err;
}

/******	static_RecalculateX() *********************************************\

Purpose:	Works out icon x min/max for the given link, for the current
		desktop font
In:		Pointer to item to update
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_RecalculateX (item *link)
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs r;
  int width;
  int sprite_mode;
  int dx;
  
  link->pos.xmin = 12;
  
  r.r[0] = 1;
  r.r[1] = (int) (link->fullpath);
  r.r[2] = 0;
  err = wimp_text_op (&r);
  
  if (!err)
  {
    err = _swix (Wimp_SpriteOp , _IN(0)|_IN(2)|_OUT(3)|_OUT(6), 40, link->sprite, &width, &sprite_mode);
    if (link->halfsize)
    {
      width /= 2;
    }
  }
  if (!err)
  {
    err = _swix (OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1/*sprite_mode*/, 4 /* xeig */, &dx);
    dx = 1 << dx;
  }
  
  if (!err)
  {
    link->pos.xmax = 12 + (width * dx) + 10 + r.r[0];
  }
  
  return err;
}

/******	static_DetermineSprite() ******************************************\

Purpose:	Works out Wimp sprite to use for the given link, and whether
		it needs to be displayed at half size
In:		Pointer to item to update
Out:		Error pointer

\**************************************************************************/

static _kernel_oserror *static_DetermineSprite (item *link)
{
  _kernel_oserror *err = NULL;
  
  if (link->objecttype == 0)
  {
    /* Display unknown filetype icon */
    str_cpy (link->sprite, "small_xxx");
    link->halfsize = FALSE;
  }
  
  else if (link->filetype == 0x2000)
  {
    /* Find application sprite */
    char expanded [1024];
    err = _swix (OS_GSTrans, _INR(0,2), link->fullpath, expanded, sizeof (expanded));
    if (!err)
    {
      char appspr [13] = "sm";
      char *ptr = expanded + str_len (expanded);
      while (*(ptr-1) != '.' && *(ptr-1) != ':')
      {
        ptr--;
      }
      str_ncpy (appspr + 2, ptr, 11); /* Just the first 10 characters of a long filename */
      
      if (NULL == _swix (Wimp_SpriteOp, _IN(0)|_IN(2), 40, appspr)) /* sm!foo */
      {
        str_cpy (link->sprite, appspr);
        link->halfsize = FALSE;
      }
      else if (NULL == _swix (Wimp_SpriteOp, _IN(0)|_IN(2), 40, appspr + 2)) /* !foo */
      {
        str_cpy (link->sprite, appspr + 2);
        link->halfsize = TRUE;
      }
      else
      {
        str_cpy (link->sprite, "small_app");
        link->halfsize = FALSE;
      }
    }
  }
  
  else if (link->objecttype == 2)
  {
    /* Display standard directory sprite */
    str_cpy (link->sprite, "small_dir");
    link->halfsize = FALSE;
  }
  
  else if (link->filetype == -1)
  {
    /* Display load/exec filetype sprite, or unknown filetype sprite if that doesn't exist */
    if (NULL == _swix (Wimp_SpriteOp, _IN(0)|_IN(2), 40, "small_lxa"))
    {
      str_cpy (link->sprite, "small_lxa");
    }
    else
    {
      str_cpy (link->sprite, "small_xxx");
    }
    link->halfsize = FALSE;
  }
  
  else
  {
    /* Find filetype sprite */
    char file_nnn [13];
    char small_nnn [13];
    sprintf (file_nnn, "file_%03x", link->filetype);
    sprintf (small_nnn, "small_%03x", link->filetype);
    if (NULL == _swix (Wimp_SpriteOp, _IN(0)|_IN(2), 40, small_nnn))
    {
      str_cpy (link->sprite, small_nnn);
      link->halfsize = FALSE;
    }
    else if (NULL == _swix (Wimp_SpriteOp, _IN(0)|_IN(2), 40, file_nnn))
    {
      str_cpy (link->sprite, file_nnn);
      link->halfsize = TRUE;
    }
    else
    {
      str_cpy (link->sprite, "small_xxx");
      link->halfsize = FALSE;
    }
  }
  return err;
}
