/******	Merge.c ***********************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Boot/Font/SysMerge
This file:	Directory scanning and merging

History:
Date		Who	Change
----------------------------------------------------------------------------
02/06/1998	BJGA	Created
03/06/1998	BJGA	Implemented Merge_ScanDir and static_Throw
04/06/1998	BJGA	Added code to support LogDir, CheckSys, FontInstall
			  and to recognise when there is nothing to do.
			Doesn't recognise main directory as an empty directory.
			Restores hourglass after errors.
			Implemented Merge_AddToList, Merge_FreeAgenda,
			  Merge_RedrawWindow and Merge_SetExtent.
05/06/1998	BJGA	Added Merge_HandleMouseClick and Merge_SetAll
08/06/1998	BJGA	Added Merge_StartMerge
09/06/1998	BJGA	Merge_ScanDir, Merge_DoOp, Merge_AddToList and
			Merge_SetExtent made static. Added static_AgendaMerge
			and static_BlindMerge; created Merge_BuildAgenda out of
			ToolboxE.c. Implemented static_DoOp. Merge_RedrawWindow
			acquires Wimp_UpdateWindow functionality, which is used
			wherever appropriate. Added static_EnsureDirectory.
10/06/1998	BJGA	Added Merge_CheckIfOverIcon. Added hourglass code to
			static_AgendaMerge. Fixed work-completed detection bug.
			Ensured percentages > 99% are never requested of Hourglass.
11/06/1998	BJGA	Bugfixes: (1) if user clicked on Restart during an agenda
			merge, went into an infinite loop (2) after an error
			button had been pressed, error box appeared to be
			positioned between the window and the pane.
14/10/1998	BJGA	Bugfix: logdir wasn't unset after an agenda merge

\**************************************************************************/

/* CLib */
#include <stdlib.h>
#include <stdio.h>
#include "kernel.h"
#include "swis.h"
/* Toolbox */
#include "wimplib.h"
#include "window.h"
/* ConfigureLib */
#include "message.h"
#include "misc.h"
#include "str.h"
/* Loacl headers */
#include "Main.h"
#include "Merge.h"

/* Constants */

#define errnoblock_INSTALLER	0x814F00
#define errno_BAD_OBEY		((int) errnoblock_INSTALLER + 0x00)
#define errno_IS_A_DIR		((int) errnoblock_INSTALLER + 0x02)
#define errno_ISNT_AN_OBEY	((int) errnoblock_INSTALLER + 0x03)
#define errno_NO_ANY		((int) errnoblock_INSTALLER + 0x06)

/* Typedefs */

typedef enum
{
  operation_update,     /* 0: *Install_Update */
  operation_merge,      /* 1: *Install_Merge (falls back to 0) */
  operation_remove,     /* 2: *Install_Remove */
  operation_cdir,       /* 3: *CDir */
  operation_checksys,   /* 4: *Install_CheckSystem */
  operation_fontinst,   /* 5: *FontInstall */
  operation_logdir      /* 6: *Install_LogDir (hidden from GUI) */
}
operation;

typedef enum
{
  interr_none,          /* 0: success */
  interr_retry,         /* 1: error, user clicked on Retry or pressed Return */
  interr_skip,          /* 2: error, user clicked on Skip or pressed Escape */
  interr_restart,       /* 3: error, user clicked on Restart */
  interr_abort,         /* 4: error, user clicked on Abort */
  interr_nothing,       /* 5: nothing to do (only returned by top ScanDir call) */
  interr_unfinished     /* 6: operation(s) was/were skipped (only returned by static_AgendaMerge) */
}
interr;

typedef struct agendaitem
{
  struct agendaitem *next;
  char *subpath;
  operation op;
  BOOL on;
  BOOL initially_on;
  char *gui_text;
  int y0;
  int y1;
}
agendaitem;

typedef struct catitem
{
  struct catitem *next;
  char *leaf;
  int filetype;
  int load;
  int exec;
}
catitem;

typedef struct
{
  unsigned int load_addr;
  unsigned int exec_addr;
  unsigned int length;
  unsigned int attr;
  unsigned int object_type;
  unsigned int file_type;
  char         name[256];
}
osgbpb_file;

/* Static global variables */

static	agendaitem	*Agenda = NULL;
static	agendaitem	*AgendaEnd = NULL;
static	BOOL		found_font;
static	BOOL		stuff_done;

/* Prototypes */

static interr static_AgendaMerge (void);
static interr static_BlindMerge (void);
static interr static_ScanDir (const char *subdir, float pc0, float pc1,
    BOOL findfiles, BOOL findfonts, BOOL filetime,
    BOOL ignoreapps, BOOL ignorefiles, BOOL ignorebacklog,
    interr (process) (const char *, operation, BOOL, BOOL *) );
static interr static_DoOp (const char *subpath, operation op,
    BOOL isfont, BOOL *skipped);
static interr static_AddToList (const char *subpath, operation op,
    BOOL isfont, BOOL *skipped);
static _kernel_oserror *static_EnsureDirectory (char *path);
static void static_SetExtent (void);
static void static_WarnNothingToDo (void);
static interr static_Throw (_kernel_oserror *error, const char *obj);


/******	Merge_StartMerge() ************************************************\

Purpose:	Performs the actions of a click on the Merge action button
In:		Mouse button state of click
Out:		TRUE => success, FALSE => failure

\**************************************************************************/

BOOL Merge_StartMerge (int buttons)
{
  BOOL result;
  
  if (State == state_agenda)
  {
    result = (interr_none == static_AgendaMerge ());
  }
  else
  {
    result = (interr_none == static_BlindMerge ());
  }
  
  if (result == TRUE)
  {
    if (0 == (buttons & ActionButton_Selected_Adjust))
    {
      Quit = TRUE;
    }
    else
    {
      throw (displayfield_set_value (0, Window_Obj, Window_DISPLAY, ""));
      Main_ChangeState (state_clean);
    }
  }
  return result;
}

/******	Merge_RedrawWindow() **********************************************\

Purpose:	Does a redraw of the pane window to plot the agenda list
In:		Pane's window handle
		Whether to use Wimp_UpdateWindow instead of Wimp_RedrawWindow
		Coordinates to pass to Wimp_UpdateWindow (if applicable)

\**************************************************************************/

void Merge_RedrawWindow (int handle, BOOL update, int x0, int y0, int x1, int y1)
{
  WimpRedrawWindowBlock block;
  int more;
  block.window_handle = handle;
  block.visible_area.xmin = x0; /* These are ignored by Wimp_RedrawWindow */
  block.visible_area.ymin = y0;
  block.visible_area.xmax = x1;
  block.visible_area.ymax = y1;
  if (update)
  {
    throw (wimp_update_window (&block, &more));
  }
  else
  {
    throw (wimp_redraw_window (&block, &more));
  }
  while (more)
  {
    agendaitem *ptr = Agenda;
    WimpPlotIconBlock icon;
    int yorg = block.visible_area.ymax - block.yscroll;
    int y0;
    int y1;
    y0 = block.redraw_area.ymin - yorg;
    y1 = block.redraw_area.ymax - yorg;
    
    /* These aspects remain constant */
    icon.bbox.xmin = 12;
    icon.bbox.xmax = 0xFFFFFF;
    icon.flags = 0x17000113;
    
    /* Step through list, identify icons that intersect the redraw rectangle */
    for (ptr = Agenda; ptr != NULL; ptr = ptr->next)
    {
      int intersection_min = max(y0, ptr->y0);
      int intersection_max = min(y1, ptr->y1);
      if ((intersection_max > intersection_min) && (ptr->op != operation_logdir))
      {
        icon.bbox.ymin = ptr->y0;
        icon.bbox.ymax = ptr->y1;
        icon.data.ist.buffer = ptr->gui_text;
        icon.data.ist.validation = ptr->on ? "Sopton" : "Soptoff";
        icon.data.ist.buffer_size = str_len (ptr->gui_text);
        throw (wimp_plot_icon (&icon));
      }
    }
    
    throw (wimp_get_rectangle (&block, &more));
  }
}

/******	Merge_HandleMouseClick() ******************************************\

Purpose:	If the click is over an option button, toggles its state
In:		Pane window handle, work area x/y of click

\**************************************************************************/

void Merge_HandleMouseClick (int handle, int x, int y)
{
  agendaitem *ptr = Agenda;
  for (; ptr != NULL; ptr = ptr->next)
  {
    if ((ptr->y0 <= y) && (y < ptr->y1) && (x >= 12) && (ptr->op != operation_logdir))
    {
      _kernel_swi_regs r;
      r.r[0] = 1;
      r.r[1] = (int) (ptr->gui_text);
      r.r[2] = 0;
      throw (wimp_text_op (&r));
      if (x < 12 + 44 + 6 + r.r[0] + 6)
      {
        ptr->on = !ptr->on;
        Merge_RedrawWindow (handle, TRUE, 12, ptr->y0, 12 + 44, ptr->y1);
      }
    }
  }
}

/******	Merge_CheckIfOverIcon() *******************************************\

Purpose:	Returns whether a point is over an agenda item
In:		x/y work area coordinates
Out:		TRUE => over an icon

\**************************************************************************/

BOOL Merge_CheckIfOverIcon (int x, int y)
{
  BOOL result = FALSE;
  agendaitem *ptr = Agenda;
  for (; ptr != NULL; ptr = ptr->next)
  {
    if ((ptr->y0 <= y) && (y < ptr->y1) && (x >= 12) && (ptr->op != operation_logdir))
    {
      _kernel_swi_regs r;
      r.r[0] = 1;
      r.r[1] = (int) (ptr->gui_text);
      r.r[2] = 0;
      throw (wimp_text_op (&r));
      if (x < 12 + 44 + 6 + r.r[0] + 6)
      {
        result = TRUE;
      }
    }
  }
  return result;
}

/******	Merge_SetAll() ****************************************************\

Purpose:	Switches all options on or off (excluding logdir commands)
In:		New value for (agendaitem).on

\**************************************************************************/

void Merge_SetAll (BOOL on)
{
  agendaitem *ptr = Agenda;
  int pane_handle;
  for (; ptr != NULL; ptr = ptr->next)
  {
    if (ptr->op != operation_logdir)
    {
      ptr->on = on;
    }
  }
  throw (window_get_wimp_handle (0, Pane_Obj, &pane_handle));
  Merge_RedrawWindow (pane_handle, TRUE, 12, -0xFFFFFF, 12 + 44, 0xFFFFFF);
}

/******	Merge_FreeAgenda() ************************************************\

Purpose:	Frees memory allocated to the agenda list

\**************************************************************************/

void Merge_FreeAgenda (void)
{
  agendaitem *ptr;
  agendaitem *next;
  for (ptr = Agenda; ptr != NULL; ptr= next)
  {
    next = ptr->next;
    free (ptr->subpath);
    free (ptr->gui_text);
    free (ptr);
  }
  AgendaEnd = Agenda = NULL;
}

/******	Merge_BuildAgenda() ***********************************************\

Purpose:	Sets up the agenda list

\**************************************************************************/

void Merge_BuildAgenda (void)
{
  interr err;
  do
  {
    _swix (Hourglass_On, 0);
    _swix (Hourglass_Percentage, _IN(0), 0);
    #if   APP == BOOTMERGE
    err = static_ScanDir ("", 0.0, 100.0, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, static_AddToList);
    #elif APP == FONTMERGE
    err = static_ScanDir ("", 0.0, 100.0, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, static_AddToList);
    #elif APP == SYSMERGE
    err = static_ScanDir ("", 0.0, 100.0, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, static_AddToList);
    #endif
    _swix (Hourglass_Off, 0);
    if (err)
    {
      Merge_FreeAgenda ();
    }
  }
  while (err == interr_restart);
  
  if (err == interr_nothing)
  {
    static_WarnNothingToDo ();
  }
  if (!err)
  {
    static_SetExtent ();
    Main_ChangeState (state_agenda);
  }
}

/******	static_AgendaMerge() **********************************************\

Purpose:	Performs a merge based upon the agenda list
Out:		Resultant error

\**************************************************************************/

static interr static_AgendaMerge (void)
{
  interr err = interr_none;
  int count = 0;
  WimpGetWindowStateBlock block;
  int pane_height;
  BOOL skipped;
  BOOL finished = TRUE;
  agendaitem *ptr;
  
  /* Initialise, and check that there is something to do! */
  throw (window_get_wimp_handle (0, Pane_Obj, &(block.window_handle)));
  throw (wimp_get_window_state (&block));
  pane_height = block.visible_area.ymax - block.visible_area.ymin;
  
  for (ptr = Agenda; ptr != NULL; ptr = ptr->next)
  {
    ptr->initially_on = ptr->on;
    if (ptr->op != operation_logdir && ptr->on == TRUE)
    {
      count++;
    }
  }
  
  if (count == 0)
  {
    /* Everything's switched off - complain! */
    err = interr_nothing;
    static_WarnNothingToDo ();
  }
  else
  {
    float fraction = ((float) 1) / ((float) count);
    
    /* "Restart" gets us back to here */
    do
    {
      err = interr_none;
      
      /* Reset hourglass */
      count = 0;
      _swix (Hourglass_On, 0);
      _swix (Hourglass_Percentage, _IN(0), 0);
      
      /* Reset option buttons to their original state */
      for (ptr = Agenda; ptr != NULL; ptr = ptr->next)
      {
        if (ptr->on != ptr->initially_on)
        {
          Merge_RedrawWindow (block.window_handle, TRUE, 12, ptr->y0, 12 + 44, ptr->y1);
          ptr->on = ptr->initially_on;
        }
      }
      
      /* Loop through enabled options */
      for (ptr = Agenda; !err && ptr != NULL; ptr = ptr->next)
      {
        if (ptr->on)
        {
          /* Realign pane if necessary so that we can see the option */
          if (ptr->y0 < (block.yscroll - pane_height + 12)
              || ptr->y1 > (block.yscroll - 12))
          {
            block.yscroll = ptr->y1 + 12;
            wimp_open_window ((WimpOpenWindowBlock *) &block);
            Merge_RedrawWindow (block.window_handle, FALSE, 0, 0, 0, 0);
          }
          
          /* Do it! */
          err = static_DoOp (ptr->subpath, ptr->op, 0, &skipped);
          
          /* Update option button to indicate if operation was sucessful */
          if (!err && !skipped)
          {
            ptr->on = FALSE;
            Merge_RedrawWindow (block.window_handle, TRUE, 12, ptr->y0, 12 + 44, ptr->y1);
          }
          if (skipped)
          {
            finished = FALSE;
          }
          
          /* Update hourglass */
          count++;
          {
            int percent = (int) ( ((float) 100) * ((float) count) * fraction );
            if (percent > 99) percent = 99;
            _swix (Hourglass_Percentage, _IN(0), percent);
          }
        }
      }
      
      /* Switch off hourglass */
      _swix (Hourglass_Off, 0);
    }
    while (err == interr_restart);
    
    if (!err && !finished)
    {
      /* At least one item was skipped - scroll window to show the first and return error */
      for (ptr = Agenda; ptr != NULL && ptr->on == FALSE; ptr = ptr->next);
      if (ptr)
      {
        block.yscroll = ptr->y1 + 12;
        wimp_open_window ((WimpOpenWindowBlock *) &block);
      }
      err = interr_unfinished;
    }
    
    /* Reset logdir unconditionally - in case there was a memory allocation error */
    _swix (OS_CLI, _IN(0), "Install_NoLogDir");
    
  }
  
  return err;
}

/******	static_BlindMerge() ***********************************************\

Purpose:	Performs a merge without an agenda list having been set up
Out:		Resultant error

\**************************************************************************/

static interr static_BlindMerge (void)
{
  interr err;
  do
  {
    _swix (Hourglass_On, 0);
    _swix (Hourglass_Percentage, _IN(0), 0);
    #if   APP == BOOTMERGE
    err = static_ScanDir ("", 0.0, 100.0, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, static_DoOp);
    #elif APP == FONTMERGE
    err = static_ScanDir ("", 0.0, 100.0, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, static_DoOp);
    #elif APP == SYSMERGE
    err = static_ScanDir ("", 0.0, 100.0, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, static_DoOp);
    #endif
    _swix (Hourglass_Off, 0);
  }
  while (err == interr_restart);
  
  if (err == interr_nothing)
  {
    static_WarnNothingToDo ();
  }
  return err;
}

/******	static_ScanDir() **************************************************\

Purpose:	Megaroutine to search for suitable objects within a directory
In:		Path segment from main directories down to this directory
		Starting percentage-done for this directory
		Finishing percentage-done for this directory
		Whether to act upon files/empty directories
		  (&DEADDEAD files are always acted upon)
		Whether to act upon fonts
		Whether to allocate hourglass time to files
		  (subdirectories always get a share)
		Whether to ignore subdirectories that are application dirs
		Whether to ignore files (doesn't apply recursively)
		Whether to ignore Backup and Log (doesn't apply recursively)
		Function to call for each suitable object found
		  (should be either static_DoOp or static_AddToList)
Out:		Internal error number: skip and retry never returned from here
Notes:		Function is recursive

\**************************************************************************/

static interr static_ScanDir (const char *subdir, float pc0, float pc1,
    BOOL findfiles, BOOL findfonts, BOOL filetime,
    BOOL ignoreapps, BOOL ignorefiles, BOOL ignorebacklog,
    interr (process) (const char *, operation, BOOL, BOOL *) )
{
  interr err;
  osgbpb_file gbpb_buf;
  _kernel_oserror err_alloc = { 0, "Not enough free memory" };
  _swix (MessageTrans_Lookup, _INR(0,7), &messages, "Err_Alloc", err_alloc.errmess,
      sizeof (err_alloc.errmess), -1, NULL, NULL, NULL, NULL);
  
  do
  {
    int offset = 0;
    int nread = -1;
    int weight_tot = 0;
    int weight_cum = 0;
    catitem *Cat = NULL;
    catitem *CatEnd = NULL;
    BOOL IsSystemDir = FALSE;
    char *SourceSub = malloc (str_len (Source) + 1 +  str_len (subdir) + 1);
    char *DestSub = malloc (str_len (Destination) + 1 +  str_len (subdir) + 1);
    
    /* Things that need resetting every retry */
    err = interr_none;
    if (*subdir == '\0')
    {
      found_font = FALSE;
      stuff_done = FALSE;
    }
    
    /* Build SourceSub and DestSub, determine if destination is !System */
    if (!SourceSub || !DestSub) err = static_Throw (&err_alloc, subdir);
    if (!err)
    {
      int diff;
      sprintf (SourceSub, "%s%s%s", Source,
                                    (*subdir=='\0') ? "" : ".",
                                    subdir);
      sprintf (DestSub, "%s%s%s", Destination,
                                  (*subdir=='\0') ? "" : ".",
                                  subdir);
      err = static_Throw (_swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
          DestSub, SystemDir, 1 /* ignore case */, &diff), subdir);
      if (diff == 0) IsSystemDir = TRUE;
    }
    
    /* Set the log file and backup directory */
    if (!err && (*subdir == '\0' || IsSystemDir))
    {
      #if   APP == BOOTMERGE
      if (*subdir == '\0')
      {
        err = process (BootDir, operation_logdir, FALSE, NULL);
      }
      else
      {
        err = process (SystemDir, operation_logdir, FALSE, NULL);
      }
      #elif APP == FONTMERGE
      err = process (BootDir, operation_logdir, FALSE, NULL);
      #elif APP == SYSMERGE
      err = process (SystemDir, operation_logdir, FALSE, NULL);
      #endif
    }
    
    /* Scan the directory, build list of directory contents */
    if (!err)
    {
      do
      {
        catitem *newitem = NULL;
        char *newname = NULL;
        err = static_Throw (_swix (OS_GBPB, _INR(0,6)|_OUTR(3,4), 12, SourceSub,
            &gbpb_buf, 1, offset, sizeof (gbpb_buf), 0, &nread, &offset), subdir);
        if (nread && !err)
        {
          newitem = malloc (sizeof (catitem));
          newname = malloc (str_len (gbpb_buf.name) + 1);
          if (!newitem || !newname)
          {
            free (newitem);
            free (newname);
            err = static_Throw (&err_alloc, subdir);
          }
        }
        if (nread && !err)
        {
          if (CatEnd == NULL)
          {
            Cat = CatEnd = newitem;
          }
          else
          {
            CatEnd->next = newitem;
            CatEnd = newitem;
          }
          str_cpy (newname, gbpb_buf.name);
          newitem->next = NULL;
          newitem->leaf = newname;
          newitem->filetype = gbpb_buf.file_type;
          newitem->load = gbpb_buf.load_addr;
          newitem->exec = gbpb_buf.exec_addr;
        }
      }
      while (offset != -1 && !err);
    }
    
    if (!err)
    {
      /* Update hourglass to reflect time taken so far (assumed 1/20 of available) */
      pc0 += (pc1 - pc0) / 20;
      _swix (Hourglass_Percentage, _IN(0), (int) pc0);
      
      
      /* Check to see if we are a font directory */
      if (findfonts)
      {
        BOOL isafont = FALSE;
        catitem *ptr;
        char start [7]; /* sufficient to hold "IntMet" */
        for (ptr = Cat; !err && ptr != NULL; ptr = ptr->next)
        {
          int diff;
          str_ncpy (start, ptr->leaf, sizeof (start));
          err = static_Throw (_swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
              start, "IntMet", 1 /* ignore case */, &diff), subdir);
          if (diff == 0) isafont = TRUE;
        }
        if (!err && isafont)
        {
          /* We are a font directory! */
          err = process (subdir, operation_update, TRUE, NULL);
          found_font = TRUE; /* mark that we need to do a *FontInstall at end */
          findfiles = FALSE; /* fiddle flag so we only look for fonts below */
        }
      }
    }
    
    /* Check to see if we are an empty directory (excluding main directory!) */
    if (!err)
    {
      if (findfiles && Cat == NULL && *subdir != '\0')
      {
        err = process (subdir, operation_cdir, FALSE, NULL);
      }
    }
    
    /* Strip out unwanted objects, and find total task "weight" */
    if (!err)
    {
      catitem *ptr = Cat;
      catitem *prev = (catitem *) &Cat; /* so prev->next starts at list head */
      while (!err && ptr != NULL)
      {
        BOOL strip = FALSE;
        int isbackup = 1;
        int islog = 1;
        if (ignorebacklog)
        {
          err = static_Throw (_swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
              ptr->leaf, "Backup", 1 /* ignore case */, &isbackup), subdir);
        }
        if (!err && ignorebacklog)
        {
          err = static_Throw (_swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
              ptr->leaf, "Log", 1 /* ignore case */, &islog), subdir);
        }
        if (!err && (isbackup == 0 || islog == 0))
        {
          strip = TRUE;
        }
        if (!err && (isbackup != 0 && islog != 0))
        {
          switch (ptr->filetype)
          {
            case 0x2000: /* application directories */
              if (ignoreapps)
              {
                strip = TRUE;
              }
              else
              {
                weight_tot += 4;
              }
              break;
            case 0x1000: /* directories */
              weight_tot += 4;
              break;
            case -1: /* untyped files */
              if (ptr->load == 0xDEADDEAD && ptr->exec == 0xDEADDEAD)
              {
                ptr->filetype = 0x3000; /* special type to identify corpse */
                if (filetime) weight_tot += 1;
              }
              else if (ignorefiles || !findfiles)
              {
                strip = TRUE;
              }
              else
              {
                if (filetime) weight_tot += 1;
              }
              break;
            default: /* miscellaneous filetypes */
              if (ignorefiles || !findfiles)
              {
                strip = TRUE;
              }
              else
              {
                if (filetime) weight_tot += 1;
              }
              break;
          }
        }
        if (strip)
        {
          prev->next = ptr->next;
          free (ptr);
          ptr = prev->next;
        }
        else
        {
          prev = ptr;
          ptr = ptr->next;
        }
      }
    }
    
    /* Step through list, performing required action */
    if (!err)
    {
      catitem *ptr;
      float pertot;
      if (weight_tot == 0.0)
      {
        pertot = (float) 1;
      }
      else
      {
        pertot = ((float) 1) / ((float) weight_tot);
      }
      for (ptr = Cat; !err && ptr != NULL; ptr = ptr->next)
      {
        char *object = malloc (str_len (subdir) + 1 + str_len (ptr->leaf) + 1);
        if (!object)
        {
          err = static_Throw (&err_alloc, subdir);
        }
        else
        {
          sprintf (object, "%s%s%s", subdir,
                                     (*subdir=='\0') ? "" : ".",
                                     ptr->leaf);
          switch (ptr->filetype)
          {
            case 0x3000: /* corpse - remove */
              err = process (object, operation_remove, FALSE, NULL);
              if (filetime) weight_cum += 1;
              break;
            case 0x2000:
            case 0x1000: /* directory - recurse */
              err = static_ScanDir (object,
                  pc0 + (pc1-pc0) * weight_cum * pertot,
                  pc0 + (pc1-pc0) * ((int) (weight_cum + 4)) * pertot,
                  findfiles, findfonts, filetime, ignoreapps, FALSE, FALSE, process);
              weight_cum += 4;
              break;
            case 0xFEB:
            case 0xFEA:
            case 0xFD7: /* obey - try merging first */
              err = process (object, operation_merge, FALSE, NULL);
              if (filetime) weight_cum += 1;
              break;
            default: /* miscellaneous file - update */
              err = process (object, operation_update, FALSE, NULL);
              if (filetime) weight_cum += 1;
              break;
          }
          /* Update hourglass to reflect time taken so far */
          if (!err)
          {
            int percent = (int) (pc0 + (pc1-pc0) * ((float) weight_cum) * pertot);
            if (percent > 99) percent = 99;
            _swix (Hourglass_Percentage, _IN(0), percent);
          }
        }
        free (object);
      }
    }
    
    /* Handle completion of !System specially */
    if (!err && IsSystemDir)
    {
      err = process ("", operation_checksys, FALSE, NULL);
      #if APP == BOOTMERGE
      if (!err) err = process (BootDir, operation_logdir, FALSE, NULL);
      #endif
    }
    
    /* Finish off if this was the top-level call */
    if (*subdir == '\0')
    {
      /* Do a *FontInstall if we found any fonts */
      if (!err && found_font)
      {
        err = process ("", operation_fontinst, FALSE, NULL);
      }
      /* Warn user if there's nothing to do */
      if (!err && !stuff_done)
      {
        err = interr_nothing;
      }
      /* Reset logdir unconditionally - in case there was a memory allocation error */
      /* This will do no harm if we're only building an agenda */
      _swix (OS_CLI, _IN(0), "Install_NoLogDir");
    }
    
    /* Free memory */
    {
      catitem *ptr, *next;
      for (ptr = Cat; ptr != NULL; ptr = next)
      {
        next = ptr->next;
        free (ptr->leaf);
        free (ptr);
      }
    }
    free (DestSub);
    free (SourceSub);
  }
  while (err == interr_retry);
  
  if (err == interr_skip)
  {
    err = interr_none;
  }
  return err;
}

/******	static_DoOp() *****************************************************\

Purpose:	Actually performs a file operation
In:		Path segment from main directories down to this object
		Operation code
		isfont -- ignored
		Reference to pass back whether operation was performed
		  (or NULL if this is not required)
Out:		Internal error number: skip and retry never returned from here

\**************************************************************************/

static interr static_DoOp (const char *subpath, operation op, BOOL isfont, BOOL *skipped)
{
  interr err;
  char command [1024]; /* new command line limit */
  _kernel_oserror *oserror;
  _kernel_oserror err_alloc = { 0, "Not enough free memory" };
  _swix (MessageTrans_Lookup, _INR(0,7), &messages, "Err_Alloc", err_alloc.errmess,
      sizeof (err_alloc.errmess), -1, NULL, NULL, NULL, NULL);
  if (op != operation_logdir) stuff_done = TRUE;
  if (skipped) *skipped = FALSE;
  
  do
  {
    char *src_path = malloc (str_len (Source) + 1 + str_len (subpath) + 1);
    char *dest_path = malloc (str_len (Destination) + 1 + str_len (subpath) + 1);
    
    /* Things that need resetting every retry */
    err = interr_none;
    
    if (!src_path || !dest_path)
    {
      err = static_Throw (&err_alloc, subpath);
    }
    
    if (!err && op <= operation_cdir)
    {
      sprintf (src_path, "%s.%s", Source, subpath);
      sprintf (dest_path, "%s.%s", Destination, subpath);
    }
    
    if (!err)
    {
      switch (op)
      {
        case operation_update:
          sprintf (command, "Install_Update %s %s", src_path, dest_path);
          oserror = _swix (OS_CLI, _IN(0), command);
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_merge:
          sprintf (command, "Install_Merge %s %s %s", dest_path, src_path, dest_path);
          oserror = _swix (OS_CLI, _IN(0), command);
          if (oserror->errnum == errno_BAD_OBEY
              || oserror->errnum == errno_NO_ANY
              || oserror->errnum == errno_IS_A_DIR
              || oserror->errnum == errno_ISNT_AN_OBEY)
          {
            sprintf (command, "Install_Update %s %s", src_path, dest_path);
            oserror = _swix (OS_CLI, _IN(0), command);
          }
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_remove:
          sprintf (command, "Install_Remove %s", dest_path);
          oserror = _swix (OS_CLI, _IN(0), command);
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_cdir:
          oserror = static_EnsureDirectory (dest_path);
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_checksys:
          sprintf (command, "Install_CheckSystem");
          oserror = _swix (OS_CLI, _IN(0), command);
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_fontinst:
          sprintf (command, "FontInstall");
          oserror = _swix (OS_CLI, _IN(0), command);
          err = static_Throw (oserror, subpath);
          break;
          
        case operation_logdir:
          sprintf (command, "Install_LogDir %s", subpath);
          oserror = _swix (OS_CLI, _IN(0), command);
          err = static_Throw (oserror, subpath);
          break;
      }
    }
    
    free (dest_path);
    free (src_path);
  }
  while (err == interr_retry);
  
  if (err == interr_skip)
  {
    err = interr_none;
    if (skipped) *skipped = TRUE;
  }
  return err;
}

/******	static_AddToList() ************************************************\

Purpose:	Adds a file operation to the agenda list
In:		Path segment from main directories down to this object
		Operation code
		Whether object is a font (ie "Add face" rather than "Add")
		skipped -- ignored
Out:		Internal error number: skip and retry never returned from here

\**************************************************************************/

static interr static_AddToList (const char *subpath, operation op, BOOL isfont, BOOL *skipped)
{
  interr err;
  _kernel_oserror err_alloc = { 0, "Not enough free memory" };
  _swix (MessageTrans_Lookup, _INR(0,7), &messages, "Err_Alloc", err_alloc.errmess,
      sizeof (err_alloc.errmess), -1, NULL, NULL, NULL, NULL);
  
  do
  {
    int dest_type;
    char *dest_path = malloc (str_len (Destination) + 1 + str_len (subpath) + 1);
    char *icontext = NULL;
    char *subpath_copy = malloc (str_len (subpath) + 1);
    agendaitem *newitem = malloc (sizeof (agendaitem));
    char *op_text;
    char *face_text = "";
    
    /* Things that need resetting every retry */
    err = interr_none;
    
    if (!dest_path || !newitem || !subpath_copy)
    {
      err = static_Throw (&err_alloc, subpath);
    }
    
    /*
    ** Code to generate icon text string, taking into account whether destination
    ** object already exists or not.
    **
    ** This takes an overly simplistic view - it should ideally use all the checks
    ** that are present in the Installer module, but to do so would require rather
    ** more programming time than is available. Instead, we'll just examine the
    ** object type at the destination object...
    */
    if (!err && op <= operation_cdir)
    {
      sprintf (dest_path, "%s.%s", Destination, subpath);
      err = static_Throw (_swix (OS_File, _INR(0,1)|_OUT(0), 23,
          dest_path, &dest_type), subpath);
    }
    if (!err && isfont)
    {
      err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
          &messages, "Face", 0, &face_text), subpath);
    }
    if (!err)
    {
      switch (op)
      {
        case operation_update:
        case operation_merge:
          if (dest_type == 0)
          {
            err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                &messages, "OpAdd", 0, &op_text), subpath);
            op = operation_update; /* can't merge with a void! */
          }
          else
          {
            err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                &messages, "OpUpd", 0, &op_text), subpath);
          }
          break;
        case operation_remove:
          if (dest_type == 0)
          {
            err = interr_skip; /* don't list this operation */
          }
          else
          {
            err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                &messages, "OpDel", 0, &op_text), subpath);
          }
          break;
        case operation_cdir:
          if (dest_type == 0)
          {
            err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
                &messages, "OpDir", 0, &op_text), subpath);
          }
          else
          {
            err = interr_skip; /* don't list this operation */
          }
          break;
        case operation_checksys:
          err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
              &messages, "OpSys", 0, &op_text), subpath);
          break;
        case operation_fontinst:
          err = static_Throw (_swix (MessageTrans_Lookup, _INR(0,2)|_OUT(2),
              &messages, "OpFnt", 0, &op_text), subpath);
          break;
        case operation_logdir:
          op_text = "";
          break;
      }
    }
    if (!err)
    {
      icontext = malloc (str_len (op_text) + str_len (face_text)
          + str_len (subpath) + 1);
      if (!icontext) err = static_Throw (&err_alloc, subpath);
    }
    if (!err)
    {
      /* Everything's okay, go and build link */
      str_cpy (subpath_copy, subpath);
      sprintf (icontext, "%s%s%s", op_text, face_text, subpath);
      newitem->next = NULL;
      newitem->subpath = subpath_copy;
      newitem->op = op;
      newitem->on = TRUE;
      newitem->gui_text = icontext;
      if (Agenda == NULL)
      {
        newitem->y1 = -12;
        newitem->y0 = -12 - 44;
        Agenda = AgendaEnd = newitem;
      }
      else
      {
        newitem->y1 = AgendaEnd->y0 - 12;
        newitem->y0 = newitem->y1 - 44;
        AgendaEnd->next = newitem;
        AgendaEnd = newitem;
      }
      if (op == operation_logdir)
      {
        newitem->y0 += 56; /* don't show a gap in the list! */
      }
      else
      {
        stuff_done = TRUE;
      }
    }
    
    /* Free memory as applicable */
    if (err)
    {
      free (icontext);
      free (newitem);
      free (subpath_copy);
    }
    free (dest_path);
  }
  while (err == interr_retry);
  
  if (err == interr_skip)
  {
    err = interr_none;
  }
  return err;
}

/******	static_EnsureDirectory() ******************************************\

Purpose:	Ensures a directory exists; if not, it creates it, plus any
		parent directories that don't exist. If any parent "directory"
		is actually a file, no action is taken.
In:		Pathname (must be not const, but will be restored at exit)
Out:		Pointer to error block
Notes:		Recursive

\**************************************************************************/

static _kernel_oserror *static_EnsureDirectory (char *dir)
{
  _kernel_oserror *err = NULL;
  int type;
  
  /* Examine the object we're now looking at */
  err = _swix (OS_File, _INR(0,1)|_OUT(0), 23, dir, &type);
  if (!err && type == 0)
  {
    /* Create our parent directory */
    int lastperiod = str_len (dir) - 1;
    while (lastperiod > 0 && *(dir + lastperiod) != '.')
    {
      lastperiod--;
    }
    *(dir + lastperiod) = '\0'; /* gives the next object up */
    err = static_EnsureDirectory (dir);
    *(dir + lastperiod) = '.'; /* restores the string to the way it was */
    
    /* Now create our own directory */
    if (!err) err = _swix (OS_File, _INR(0,1)|_IN(4), 8, dir, 0);
  }
  /* Otherwise, we have either a directory (ie our work is already done) or a file (in which case, */
  /* an error will be reported by the calling function when it tries to create the next directory down) */
  
  return err;
}

/******	static_SetExtent() ************************************************\

Purpose:	Sets the extent of the pane to fit the agenda list

\**************************************************************************/

static void static_SetExtent (void)
{
  WimpGetWindowStateBlock pane_state;
  BBox ext = { 0, 0, 0, 0 };
  throw (window_get_wimp_handle (0, Pane_Obj, &(pane_state.window_handle)));
  throw (wimp_get_window_state (&pane_state));
  ext.xmax = pane_state.visible_area.xmax - pane_state.visible_area.xmin;
  ext.ymin = pane_state.visible_area.ymin - pane_state.visible_area.ymax;
  if (AgendaEnd)
  {
    int bottom;
    bottom = AgendaEnd->y0 - 12; /* leaving the bottom border */
    ext.ymin = min(ext.ymin, bottom);
  }
  throw (window_set_extent (0, Pane_Obj, &ext));
}

/******	static_WarnNothingToDo() ******************************************\

Purpose:	Displays "Nothing to do" information bulletin

\**************************************************************************/

static void static_WarnNothingToDo (void)
{
  _kernel_oserror err_nowork = { 0, "Err_NoWork" };
  wimp_report_error (_swix (MessageTrans_ErrorLookup, _INR(0,7), &err_nowork, &messages, 0, 0, 0, 0, 0, 0),
      Wimp_ReportError_OK + (1u << 8) + (1u << 9), message_lookup_direct(messages,"_TaskName"),
      message_lookup_direct(messages,"_ConfigSprite"), (void *) 1, 0);
}

/******	static_Throw() ****************************************************\

Purpose:	Asks user what to do about an error
In:		Standard RISC OS error block (or NULL to return immediately)
		Object being processed at the time
Out:		Error action to perform

\**************************************************************************/

static interr static_Throw (_kernel_oserror *error, const char *obj)
{
  interr result = interr_none;
  if (error != NULL)
  {
    _kernel_oserror err2;
    char *ptr, *limit;
    char taskname [32] = "Error";  /* Fallbacks in case message lookup fails */
    char spritename [12] = "switcher";
    char buttons [64] = "Retry,Skip,Restart,Abort";
    
    /* Build error message prefixed by context */
    err2.errnum = error->errnum;
    ptr = err2.errmess;
    limit = ptr + sizeof (err2.errmess);
    if (*obj != '\0')
    {
      str_ncpy (ptr, obj, limit-ptr);
      ptr += str_len (obj);
      if (ptr >= limit) ptr = limit - 1;
      str_ncpy (ptr, ": ", limit-ptr);
      ptr += 2;
      if (ptr >= limit) ptr = limit - 1;
    }
    str_ncpy (ptr, error->errmess, limit-ptr);
    
    /* Get relevant message tokens */
    _swix (MessageTrans_Lookup, _INR(0,7), &messages, "_TaskName",
        taskname, sizeof (taskname), 0, 0, 0, 0);
    _swix (MessageTrans_Lookup, _INR(0,7), &messages, "_ConfigSprite",
        spritename, sizeof (spritename), 0, 0, 0, 0);
    _swix (MessageTrans_Lookup, _INR(0,7), &messages, "Actions",
        buttons, sizeof (buttons), 0, 0, 0, 0);
    
    result = (interr) (-2 + wimp_report_error (&err2, (1u << 8) + (2u << 9),
        taskname, spritename, (void *) 1, buttons));
    
    /* Redraw our windows on top of error box (!) */
    {
      WimpRedrawWindowBlock block;
      int more;
      window_get_wimp_handle (0, Window_Obj, &(block.window_handle));
      wimp_redraw_window (&block, &more);
      while (more)
      {
        wimp_get_rectangle (&block, &more);
      }
      
      window_get_wimp_handle (0, Pane_Obj, &more);
      Merge_RedrawWindow (more, FALSE, 0, 0, 0, 0);
    }
    
    /* Restore hourglass for remainder of operation */
    _swix (Hourglass_On, 0);
  }
  return result;
}
