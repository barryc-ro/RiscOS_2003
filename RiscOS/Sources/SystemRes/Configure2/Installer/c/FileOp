/******	FileOp.c **********************************************************\

Project:	Ursula (RISC OS for Risc PC II)
Component:	Configure Installer module (for SysMerge/FontMerge/BootMerge)
This file:	Lower-level file operations, for use by File.c

History:
Date		Who	Change
----------------------------------------------------------------------------
09/01/1998	BJGA	Created
15/01/1998	BJGA	Created static_ReadMessages and static_WriteMessages
20/01/1998	BJGA	Added FileOp_Init and FileOp_Final
21/01/1998	BJGA	Bugfixed FileOp_Init/Final, started static_ReadMessages
22/01/1998	BJGA	Bugfixes, more development on static_ReadMessages
23/01/1998	BJGA	Completed static_ReadMessages,
			  implemented static_WriteMessages, static_FreeMessages,
			  static_CompareEncodings and static_CompareFonts
26/01/1998	BJGA	Implemented FileOp_AddFontToken, FileOp_RemoveFontToken and
			  static_FindNewDefaultFace; separated static_InsertFontStruct
			  into separate function; started FileOp_EnsureFontMessages
27/01/1998	BJGA	Implemented font message file building by directory scan (ie,
			  completed FileOp_EnsureFontMessages and added static_ScanDirForFonts);
			  implemented FileOp_CopyFile, FileOp_RemoveObject, FileOp_DeleteObject,
			  FileOp_RemoveComponents, FileOp_BuildTree and FileOp_RemoveTree;
			  bugfixed FileOp_AddFontToken;
28/01/1998	BJGA	Downgraded Remove/DeleteObject to non-recursive Remove/DeleteFile;
			  added |recursive| parameter to Remove/DeleteComponents (doing the recursion
			  by hand allows proper removal of fonts or modules inside directories);
			  pre-write removal of font messages file now passes through File_Backup
29/01/1998	BJGA	Bugfix to FileOp_WriteMessages file removal code;
			  Remove/DeleteComponents combined into BackupComponents, which calls File_Backup
			  for each component individually (eg so that component modules/fonts are
			  removed consistently with directly-specified modules/fonts);
			  FileOp_BuildTree can now remove parent-files (optionally via File_Backup);
			  lock attribute of files is now overridden during rename in FileOp_RemoveFile;
			  FileOp_RemoveTree now overrides lock attribute on empty directories;
			  implemented FileOp_CopyComponents

\**************************************************************************/

/* CLib */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "kernel.h"
/* Common */
#include "message.h"
#include "str.h"
/* local headers */
#include "Defs.h"
#include "File.h"
#include "FileOp.h"
#include "Housekeep.h"
#include "Mess.h"
#include "Modver.h"

#define LINE_LENGTH	256	/* max length of line allowed for font Messages */

#define BUFFER_SIZE	128	/* size of buffer to allocate for copying (in K) */

struct string_list
{
  struct string_list *next;
  char *name;
};

typedef struct string_list font_encoding;
typedef struct string_list font_face_rule_list;

struct font_family
{
  struct font_family *next;
  char *name;
  struct font_face *faces;
  struct font_face *default_face;
};

struct font_face
{
  struct font_face *next;
  BOOL language;
  char *alias;
  char *full_name;
  char *name; /* this will point to tail of full_name */
  int priority; /* as calculated from the Messages file list */
  struct font_family *family;
};

typedef struct font_family font_family;
typedef struct font_face font_face;

typedef struct
{
  font_encoding *BEncodings;
  font_encoding *Encodings;
  font_family *Fonts;
}
font_messages;

typedef struct
{
  unsigned int load_addr;
  unsigned int exec_addr;
  unsigned int length;
  unsigned int attr;
  unsigned int object_type;
  unsigned int file_type;
  char         name[256];
} osgbpb_file;

typedef struct
{
  void *addr;
  int len;
} copybuf_desc;

static _kernel_oserror *static_ReadMessages (const char *file, font_messages *mess);
static _kernel_oserror *static_WriteMessages (const char *file, font_messages *mess);
static int static_CompareEncodings (const void *p1, const void *p2);
static int static_CompareFonts (const void *p1, const void *p2);
static void static_FreeMessages (font_messages *mess);
static _kernel_oserror *static_InsertFontStruct (font_messages *mess, const char *font, const char *alias,
    BOOL language, BOOL def_face, font_family **family_out);
static void static_FindNewDefaultFace (font_family *family);
static _kernel_oserror *static_ScanDirForFonts (const char *fontroot, const char *subdir, font_messages *mess);

static font_face_rule_list *Rule = NULL;
static char *RuleString;


/******	FileOp_Init() *****************************************************\

Purpose:	Reads the font face ordering rule from the Messages into a
		  static linked list
Out:		Pointer to error block
Note:		Linked list is built so that first link points to first rule

\**************************************************************************/

_kernel_oserror *FileOp_Init (void)
{
  _kernel_oserror *err = NULL;
  char *string0,
       *ptr;
  BOOL more = TRUE;
  font_face_rule_list **rule_ptr = &Rule;
  
  string0 = message_lookup_direct(messages, "FontRule");
  RuleString = malloc (str_len (string0) + 1);
  if (RuleString == 0) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  if (!err)
  {
    str_cpy (RuleString, string0);
    
    ptr = RuleString;
    while (more && !err)
    {
      *rule_ptr = malloc (sizeof (font_face_rule_list));
      if (*rule_ptr == 0) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
      if (!err)
      {
        (*rule_ptr)->name = ptr;
        (*rule_ptr)->next = NULL;
        rule_ptr = &((*rule_ptr)->next);
        ptr--;
        do
        {
          ptr++;
          more = (*ptr != '\0');
        }
        while (more && *ptr != ',');
        *ptr++ = '\0';
      }
    }
  }
  
  /* FileOp_Final will be called for us if err != NULL */
  return err;
}

/******	FileOp_Final() ****************************************************\

Purpose:	Deallocates memory used by FileOp_Init

\**************************************************************************/

void FileOp_Final (void)
{
  font_face_rule_list *ptr = Rule,
                      *next;
  
  while (ptr != NULL)
  {
    next = ptr->next;
    free (ptr);
    ptr = next;
  }
  
  free (RuleString);
}

/******	FileOp_AddFontToken() *********************************************\

Purpose:	Adds a font token to a font messages file
In:		Font identifier, name of message file to update
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_AddFontToken (const char *font, const char *mfile, BOOL language)
{
  _kernel_oserror *err = NULL;
  font_messages mess;
  font_family *family;
  
  /* Read the old messages file */
  err = static_ReadMessages (mfile, &mess);
  
  /* Add the new token */
  if (!err) err = static_InsertFontStruct (&mess, font, "", language, FALSE, &family);
  
  /* Update default face for this family */
  if (!err) static_FindNewDefaultFace (family);
  
  /* Write the new messages file */
  if (!err) err = static_WriteMessages (mfile, &mess);
  
#ifdef debug_DRY_RUN
  if (!err) printf ("Added font %s to message file %s\n", font, mfile);
#endif
  
  return err;
}

/******	FileOp_RemoveFontToken() ******************************************\

Purpose:	Removes a font token from a font messages file
In:		Font identifier, name of message file to update
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_RemoveFontToken (const char *font, const char *mfile)
{
  _kernel_oserror *err = NULL;
  font_messages mess;
  font_family *family = NULL;
  font_face *face,
            *next_face,
            **to_face;
  int diff;
  BOOL found = FALSE;
  
  /* Read the old messages file */
  err = static_ReadMessages (mfile, &mess);
  
  /* Find match(es) for the token */
  if (!err)
  {
    for (family = mess.Fonts; family != NULL && !err; family = family->next)
    {
      for (face = family->faces; face != NULL && !err; face = next_face)
      {
        next_face = face->next;
        err = Mess_CacheError (_swix (Territory_Collate, _INR(0,3)|_OUT(0),
            -1, font, face->full_name, 1, &diff)); /* case insensitive */
        if (!err && diff == 0)
        {
          /* Found a match - remove from list and deallocate */
          found = TRUE;
          for (to_face = &(family->faces); *to_face != face; to_face = &((*to_face)->next));
          *to_face = face->next;
          free (face->alias);
          free (face->full_name);
          free (face);
        }
      }
      if (found) break;
    }
  }
  
  /* Update default face for this family */
  if (!err && family != NULL) static_FindNewDefaultFace (family);
  
  /* Write the new messages file */
  if (!err) err = static_WriteMessages (mfile, &mess);
  
#ifdef debug_DRY_RUN
  if (!err) printf ("Removed font %s from message file %s\n", font, mfile);
#endif
  
  return err;
}

/******	FileOp_EnsureFontMessages() ***************************************\

Purpose:	If the given font messages file doesn't exists, builds it from
		a neighbouring file for a different territory, or if none exist,
		scans the font directory to build one from scratch
In:		Name of message file to ensure
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_EnsureFontMessages (const char *messages, int parent_length)
{
  _kernel_oserror *err = NULL;
  int type,
      other_type;
  char *temp_path = NULL;
  font_messages mess;
  font_encoding *encoding;
  font_family *family;
  font_face *face;
  osgbpb_file *gbpb_buf = NULL;
  
  /* Examine the object type of the pathname we've been passed */
  err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0), 17, (int) messages, &type));
  if (!err && (type & 1) == 0)
  {
    temp_path = malloc (parent_length + 12); /* build string for wildcarded messages files */
    if (temp_path == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  }
  if (!err && (type & 1) == 0)
  {
    str_ncpy (temp_path, messages, parent_length + 1);
    str_cpy (temp_path + parent_length, ".Messages#*");
    err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0), 17, (int) temp_path, &other_type));
  }
  if (!err && (type & 1) == 0 && (other_type & 1) == 1)
  {
    
#ifdef debug_DRY_RUN
printf ("Building message file %s by example\n", messages);
#endif
    /* Build message file from other message file */
    
    /* Read messages file */
    err = static_ReadMessages (temp_path, &mess);
    if (!err)
    {
      
      /* Wipe the aliases */
      for (family = mess.Fonts; family != NULL; family = family->next)
      {
        for (face = family->faces; face != NULL; face = face->next)
        {
          *face->alias = '\0';
        }
      }
      
      /* Write messages file */
      err = static_WriteMessages (messages, &mess);
    }
  }
  else if (!err && (type & 1) == 0 && (other_type & 1) == 0)
  {
    
#ifdef debug_DRY_RUN
printf ("Building message file %s by scanning directories\n", messages);
#endif
    /* Build message file by scanning directory */
    
    /* Initialise */
    memset (&mess, 0, sizeof (mess));
    
    /* Scan the Encodings directory (if any) for files */
    str_cpy (temp_path + parent_length, ".Encodings");
    err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0), 17, temp_path, &type));
    if (!err)
    {
      gbpb_buf = malloc (sizeof (*gbpb_buf));
      if (gbpb_buf == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
    }
    if (!err && type & 2)
    {
      int offset = 0,
          nread = -1;
      do
      {
        err = Mess_CacheError (_swix (OS_GBPB, _INR(0,6)|_OUTR(3,4), 12,
            (int) temp_path, (int) gbpb_buf, 1, offset, sizeof (*gbpb_buf), "*", &nread, &offset));
        if (nread && gbpb_buf->object_type & 1 && !err) /* only interested in files */
        {
          if (gbpb_buf->name[0] == '/')
          {
            /* Add a base encoding */
            encoding = malloc (sizeof (font_encoding));
            if (encoding == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
            if (!err)
            {
              encoding->next = mess.BEncodings;
              mess.BEncodings = encoding;
              encoding->name = malloc (str_len (gbpb_buf->name)); /* + 1 for terminator, - 1 for '/' */
              if (encoding->name == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
              if (!err) str_cpy (encoding->name, gbpb_buf->name + 1);
#ifdef debug_FONT_MESS
printf("New base encoding: %08x next: %08x: name: %s\n", (int)encoding, (int)encoding->next, encoding->name);
#endif
            }
          }
          else
          {
            /* Add an encoding */
            encoding = malloc (sizeof (font_encoding));
            if (encoding == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
            if (!err)
            {
              encoding->next = mess.Encodings;
              mess.Encodings = encoding;
              encoding->name = malloc (str_len (gbpb_buf->name) + 1);
              if (encoding->name == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
              if (!err) str_cpy (encoding->name, gbpb_buf->name);
#ifdef debug_FONT_MESS
printf("New encoding: %08x next: %08x: name: %s\n", (int)encoding, (int)encoding->next, encoding->name);
#endif
            }
          }
        }
      }
      while (offset != -1 && !err);
    }
    
    /* Recursively scan for IntMet* files */
    if (!err)
    {
      *(temp_path + parent_length) = '\0'; /* truncate to just fontdir */
      err = static_ScanDirForFonts (temp_path, "", &mess);
    }
    
    /* Establish defaults for each face */
    if (!err)
    {
      for (family = mess.Fonts; family != NULL; family = family->next)
      {
        static_FindNewDefaultFace (family);
      }
      

      /* Write new messages file */
      err = static_WriteMessages (messages, &mess);
    }
  }
  
  free (gbpb_buf);
  free (temp_path);
  return err;
}

/******	FileOp_CopyFile() *************************************************\

Purpose:	Copies a file
In:		Source/dest pathnames
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_CopyFile (const char *source, const char *dest)
{
  _kernel_oserror *err = NULL;
  copybuf_desc buf;
  char *dest_rw;

  dest_rw = malloc (str_len (dest) + 1);
  if (dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
#ifdef debug_DRY_RUN
printf ("Copying file %s to %s\n", source, dest);
#else
  if (!err)
  {
    str_cpy (dest_rw, dest);
    err = FileOp_BuildTree (dest_rw, TRUE);
  }
  if (!err)
  {
    buf.len = BUFFER_SIZE * 1024;
    buf.addr = malloc (buf.len);
    err = Mess_CacheError (_swix (OS_FSControl, _INR(0,3)|_IN(8), 26 /* Copy */,
        source, dest, buf.addr ? 0x2002 : 0x0002 /* Force; Use buffer if valid */, &buf));
    free (buf.addr);
  }
#endif
  free (dest_rw);
  return err;
}

/******	FileOp_RemoveFile() ***********************************************\

Purpose:	Moves a file
In:		Source/dest pathnames
Out:		Pointer to error block
Notes:		Typically moves to a backup location - this will be on the
		  same device, so a rename operation is actually used

\**************************************************************************/

_kernel_oserror *FileOp_RemoveFile (const char *source, const char *dest)
{
  _kernel_oserror *err = NULL;
  char *source_rw,
       *dest_rw;

  source_rw = malloc (str_len (source) + 1);
  dest_rw = malloc (str_len (dest) + 1);
  if (source_rw == NULL || dest_rw == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
#ifdef debug_DRY_RUN
printf ("Removing file %s to %s\n", source, dest);
#else
  if (!err)
  {
    /* We're only implementing a single-version backup, so we must remove any existing object at backup */
    /* If one doesn't already exist, we don't want to generate an error, so throw away error pointer */
    _swix (OS_FSControl, _INR(0,1)|_IN(3), 27 /* Wipe */, dest, 0x003 /* Force; Recurse */);
  }
  if (!err)
  {
    str_cpy (dest_rw, dest);
    err = FileOp_BuildTree (dest_rw, FALSE);
  }
  if (!err)
  {
    int attr,
        attr_orig = 0;
    
    /* Force lock attribute off */
    err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(5), 17, source, &attr_orig));
    attr = attr_orig; /* default */
    if (!err && (attr_orig & 8)) /* only touch the disc if absolutely necessary */
    {
      attr = attr_orig & ~8;
      err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_IN(5), 4, source, attr));
    }
    
    /* Move file */
    if (!err)
    {
      err = Mess_CacheError (_swix (OS_FSControl, _INR(0,2), 25 /* Rename */, source, dest));
    }
    
    /* Restore original permission if necessary */
    if (!err)
    {
      if (attr_orig != attr) _swix (OS_File, _INR(0,1)|_IN(5), 4, dest, attr_orig);
    }
  }
  if (!err)
  {
    str_cpy (source_rw, source);
    FileOp_RemoveTree (source_rw);
  }
#endif
  free (dest_rw);
  free (source_rw);
  return err;
}

/******	FileOp_DeleteFile() ***********************************************\

Purpose:	Deletes a file
In:		Object pathname
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_DeleteFile (const char *object)
{
  _kernel_oserror *err = NULL;
  char *object_rw;

  object_rw = malloc (str_len (object) + 1);
  if (object_rw == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
#ifdef debug_DRY_RUN
printf ("Deleting file %s\n", object);
#else
  if (!err)
  {
    err = Mess_CacheError (_swix (OS_FSControl, _INR(0,1)|_IN(3), 27 /* Wipe */, object, 0x002 /* Force */));
  }
  if (!err)
  {
    str_cpy (object_rw, object);
    FileOp_RemoveTree (object_rw);
  }
#endif
  free (object_rw);
  return err;
}

/******	FileOp_CopyComponents() *******************************************\

Purpose:	Copies the component files of a directory (non-recursively)
In:		Pathnames of directories to copy from/to
Out:		Pointer to error block

\**************************************************************************/

_kernel_oserror *FileOp_CopyComponents (const char *source, const char *dest)
{
  _kernel_oserror *err = NULL;
  char *dest_rw = NULL;
  osgbpb_file *gbpb_buf = NULL;
  
  dest_rw = malloc (str_len (dest) + 2);
  gbpb_buf = malloc (sizeof (*gbpb_buf));
  if (dest_rw == NULL || gbpb_buf == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
#ifdef debug_DRY_RUN
printf ("Copying components of %s to %s non-recursively\n", source, dest);
IGNORE(object);
IGNORE(offset);
IGNORE(nread);
#else
  if (!err)
  {
    sprintf (dest_rw, "%s.", dest); /* the extra '.' ensures the |dest| directory itself is also created */
    err = FileOp_BuildTree (dest_rw, TRUE);
  }
  if (!err)
  {
    int offset = 0,
        nread = -1;
    char *source_o = NULL,
         *dest_o = NULL;
    copybuf_desc buf;
    
    buf.len = BUFFER_SIZE * 1024;
    buf.addr = malloc (buf.len);
    
    do
    {
      err = Mess_CacheError (_swix (OS_GBPB, _INR(0,6)|_OUTR(3,4), 12,
          (int) source, (int) gbpb_buf, 1, offset, sizeof (*gbpb_buf), "*", &nread, &offset));
      if (nread && gbpb_buf->object_type & 1 && !err) /* restrict to files */
      {
        /* Construct the source and destination pathnames of the current object */
        source_o = malloc (str_len (source) + 1 + str_len (gbpb_buf->name) + 1);
        dest_o = malloc (str_len (dest) + 1 + str_len (gbpb_buf->name) + 1);
        if (source_o == NULL || dest_o == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
        if (!err)
        {
          sprintf (source_o, "%s.%s", source, gbpb_buf->name);
          sprintf (dest_o, "%s.%s", dest, gbpb_buf->name);
          
          /* Copy the object */
          err = Mess_CacheError (_swix (OS_FSControl, _INR(0,3)|_IN(8), 26 /* Copy */,
              source_o, dest_o, buf.addr ? 0x2002 : 0x0002 /* Force; Use buffer if valid */, &buf));
        }
        free (dest_o);
        free (source_o);
      }
    }
    while (offset != -1 && !err);
    
    free (buf.addr);
  }
#endif
  
  free (gbpb_buf);
  free (dest_rw);
  return err;
}

/******	FileOp_BackupComponents() *****************************************\

Purpose:	Removes or deletes component files of a directory
In:		Pathnames of directory, whether to process it recursively
Out:		Pointer to error block
Notes:		Uses File_Backup on each object (file, font or directory)
		to allow correct removal of fonts and modules, and to determine
		whether to use deletion or removal

\**************************************************************************/

_kernel_oserror *FileOp_BackupComponents (const char *dir, BOOL recursive)
{
  _kernel_oserror *err = NULL;
  char *object = NULL,
       *dir_rw = NULL;
  osgbpb_file *gbpb_buf = NULL;
  int offset = 0,
      nread = -1;
  
  dir_rw = malloc (str_len (dir) + 2);
  gbpb_buf = malloc (sizeof (*gbpb_buf));
  if (dir_rw == NULL || gbpb_buf == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  if (!err)
  {
#ifdef debug_DRY_RUN
printf ("Removing components of %s %srecursively\n", dir, recursive ? "" : "non-");
IGNORE(object);
IGNORE(offset);
IGNORE(nread);
#else
    do
    {
      err = Mess_CacheError (_swix (OS_GBPB, _INR(0,6)|_OUTR(3,4), 12,
          (int) dir, (int) gbpb_buf, 1, offset, sizeof (*gbpb_buf), "*", &nread, &offset));
      if (nread && !err && (gbpb_buf->object_type & 1 || recursive)) /* restrict to files unless recursive */
      {
        /* Construct the pathname of the current object */
        object = malloc (str_len (dir) + 1 + str_len (gbpb_buf->name) + 1);
        if (object == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
        if (!err)
        {
          sprintf (object, "%s.%s", dir, gbpb_buf->name);
          /* Determine if it's a special case */
          err = File_DiagnoseFont (object, (int *) &(gbpb_buf->file_type), NULL);
          if (!err)
          {
            int ver = -1;
            if (gbpb_buf->file_type == 0xFFA) ver = Modver_Read (object);
            
            /* Do the backup */
            err = File_Backup (object, recursive, gbpb_buf->object_type, gbpb_buf->file_type, ver);
            
            /* If we just removed the last component, FileOp_RemoveTree will have nuked the directory too */
            /* and so we must stop; otherwise, the makeup of the directory has changed, and we need to */
            /* start enumerating again from offset 0 */
            if (!err)
            {
              int type = 0;
              err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0), 17, dir, &type));
              offset = (type & 2) ? 0 : -1;
            }
          }
        }
        free (object);
      }
    }
    while (offset != -1 && !err);
#endif
  }
  
  /* In case it was an empty directory, we must try removing the directory tree explicitly */
  if (!err)
  {
    sprintf (dir_rw, "%s.", dir);
    FileOp_RemoveTree (dir_rw);
  }
  
  free (gbpb_buf);
  free (dir_rw);
  return err;
}

/******	FileOp_BuildTree() ************************************************\

Purpose:	Ensures the directory tree can hold the given object,
		even if this involves having to remove/delete files
In:		Pathname (must not be const, but will be restored at exit),
		whether to call File_Backup for parent-files or not
		(ie. so no further backup when it's already in the backup structure)
Out:		Pointer to error block
Notes:		Recursive

\**************************************************************************/

_kernel_oserror *FileOp_BuildTree (char *file, BOOL backup)
{
  _kernel_oserror *err = NULL;
  int lastperiod = 0;
#ifdef debug_DRY_RUN
printf ("Building directories above %s\n", file);
IGNORE(backup);
IGNORE(lastperiod);
#else
  for (lastperiod = str_len (file) - 1; lastperiod > 0 && *(file + lastperiod) != '.'; lastperiod--);
  if (lastperiod > 0) /* this should always be true, but just in case, return NULL otherwise */
  {
    int type,
        filetype;
    
    *(file + lastperiod) = '\0'; /* gives the next object up */
    
    /* Examine the object we're now looking at */
    err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0)|_OUT(6), 23, file, &type, &filetype));
    if (!err)
    {
      switch (type)
      {
        case 0:
          /* Create our parent directory */
          err = FileOp_BuildTree (file, backup);
          /* Now create our own directory */
          if (!err) err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_IN(4), 8, file, 0));
          break;
          
        case 1:
          /* There's a file here - delete it or back it up, as appropriate */
          if (backup)
          {
            int ver = -1; /* Just in case it was a module */
            if (filetype == 0xFFA) ver = Modver_Read (file);
            err = File_Backup (file, TRUE, 1 /* type */, filetype, ver);
          }
          else
          {
            err = Mess_CacheError (_swix (OS_FSControl, _INR(0,1)|_IN(3), 27 /* Wipe */, file, 2 /* Force */));
          }
          /* Now create our own directory */
          if (!err) err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_IN(4), 8, file, 0));
          break;
          
        default:
          /* There's already a directory here - simply return */
          break;
      }
    }
    
    *(file + lastperiod) = '.'; /* restores the string to the way it was on entry */
  }
#endif
  return err;
}

/******	FileOp_RemoveTree() ***********************************************\

Purpose:	Removes unnecessary directory structure above the (just vacated) object
In:		Pathname (must not be const, but will be restored at exit)
Out:		Pointer to error block
Notes:		Recursive

\**************************************************************************/

void FileOp_RemoveTree (char *file)
{
  int lastperiod = 0;
#ifdef debug_DRY_RUN
printf ("Removing empty directories above %s\n", file);
IGNORE(lastperiod);
#else
  for (lastperiod = str_len (file) - 1; lastperiod > 0 && *(file + lastperiod) != '.'; lastperiod--);
  if (lastperiod > 0) /* this should always be true, but just in case, don't do anything */
  {
    int attr = 0; /* default in case first attribute read fails */
    
    *(file + lastperiod) = '\0'; /* gives the next directory up */
    
    /* Force lock attribute off */
    _swix (OS_File, _INR(0,1)|_OUT(5), 17, file, &attr);
    if (attr & 8) _swix (OS_File, _INR(0,1)|_IN(5), 4, file, attr & ~8);
    
    if (NULL == _swix (OS_File, _INR(0,1), 6, (int) file)) /* equivalent to *Remove */
    {
      /* Directory deleted successfully, try parent next */
      FileOp_RemoveTree (file);
    }
    *(file + lastperiod) = '.'; /* restores the string to the way it was on entry */
  }
#endif
  return;
}

/******	static_ReadMessages() *********************************************\

Purpose:	Allocates and builds struct / linked lists of
		  the contents of a fonts messages file
In:		Name of messages file, pointer to top of struct
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_ReadMessages (const char *file, font_messages *mess)
{
  _kernel_oserror *err = NULL;
  int attr,
      attr_orig = 0,
      fl = 0, /* file length */
      fp = 0, /* file pointer */
      fh = 0; /* file handle */
  char *line = NULL,
       *ptr,
       *ident,
       *alias;
  BOOL valid_line,
       default_face;
  font_encoding *new_enc;
  
#ifdef debug_FONT_MESS
printf("Reading messages file '%s':\n", file);
#endif
  
  /* Initialise struct */
  memset (mess, 0, sizeof (*mess));
  
  /* Force user read access permission */
  err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUTR(4,5), 17, file, &fl, &attr_orig));
  attr = attr_orig; /* default */
  if (!err && !(attr_orig & 1)) /* only touch the disc if absolutely necessary */
  {
    attr = attr_orig | 1;
    err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_IN(5), 4, file, attr));
  }
  
  /* Openin, no path, error if directory or absent */
  if (!err)
  {
    err = Mess_CacheError (_swix (OS_Find, _INR(0,2)|_OUT(0), 0x4F, file, NULL, &fh));
  }
  
  /* Allocate memory to hold each line of the file one at a time */
  if (!err)
  {
    line = malloc (LINE_LENGTH + 1);
    if (line == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  }
  
  while (fp < fl && !err)
  {
    /* Fill the buffer as far as possible from the file */
    err = Mess_CacheError (_swix (OS_GBPB, _INR(0,4)|_OUT(2), 3, fh, line, LINE_LENGTH, fp, &ptr));
    if (!err)
    {
      *ptr = '\n'; /* terminator after either LINE_LENGTH bytes, or at end of file */
      
      /* Parse the line: identify the token type, font identifier and alias */
      ptr = line;
      ident = NULL;
      alias = NULL;
      valid_line = FALSE;
      default_face = FALSE;
      do
      {
        if (*ptr == '_' && !ident && !alias)
        {
          *ptr = '\0';
          ident = ptr + 1;
        }
        if (*ptr == ':' && ident && !alias)
        {
          *ptr = '\0';
          alias = ptr + 1;
        }
        if (*ptr == '\n' && ident && alias)
        {
          valid_line = TRUE;
        }
      }
      while (*ptr++ != '\n');
      
      /* Advance the file pointer by the length of the line */
      fp += (ptr - line);
      
      if (valid_line)
      {
        /* Continue parsing */
        if (*(ptr - 2) == '*')
        {
          *(ptr - 2) = '\0';
          default_face = TRUE;
        }
        *(ptr - 1) = '\0';
        
        /* token names are case-sensitive */
        if (strcmp (line, "BEncoding") == 0)
        {
          /* Add a base encoding */
          new_enc = malloc (sizeof (font_encoding));
          if (new_enc == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
          if (!err)
          {
            new_enc->next = mess->BEncodings;
            mess->BEncodings = new_enc;
            new_enc->name = malloc (strlen (ident) + 1);
            if (new_enc->name == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
            if (!err) strcpy (new_enc->name, ident);
#ifdef debug_FONT_MESS
printf("New base encoding: %08x next: %08x: name: %s\n", (int)new_enc, (int)new_enc->next, new_enc->name);
#endif
          }
        }
        if (strcmp (line, "Encoding") == 0)
        {
          /* Add an encoding */
          new_enc = malloc (sizeof (font_encoding));
          if (new_enc == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
          if (!err)
          {
            new_enc->next = mess->Encodings;
            mess->Encodings = new_enc;
            new_enc->name = malloc (strlen (ident) + 1);
            if (new_enc->name == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
            if (!err) strcpy (new_enc->name, ident);
#ifdef debug_FONT_MESS
printf("New encoding: %08x next: %08x: name: %s\n", (int)new_enc, (int)new_enc->next, new_enc->name);
#endif
          }
        }
        if ((strcmp (line, "Font") == 0) || (strcmp (line, "LFont") == 0))
        {
          /* Add a font face */
          static_InsertFontStruct (mess, ident, alias, (*line == 'L'), default_face, NULL);
        }
      }
    }
  }
  
  /* Deallocate buffer */
  free (line);
  
  /* Close file */
  if (fh != 0) _swix (OS_Find, _INR(0,1), 0, fh);
  
  /* Restore original permission if necessary */
  if (attr_orig != attr) _swix (OS_File, _INR(0,1)|_IN(5), 4, file, attr_orig);
  
  /* If there's been an error, free any allocated memory */
  if (err) static_FreeMessages (mess);
  
  return err;
}

/******	static_WriteMessages() ********************************************\

Purpose:	Sorts, writes to file, and deallocates
		  font messages file struct / linked lists
In:		Name of messages file, pointer to top of struct
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_WriteMessages (const char *file, font_messages *mess)
{
  _kernel_oserror *err = NULL;
  font_encoding *enc;
  font_family *fam;
  font_face *face;
  font_encoding **bencoding_a = NULL;
  font_encoding **encoding_a = NULL;
  font_face **font_a = NULL;
  int file_type = 0,
      file_filetype = 0,
      bencodings = 0,
      encodings = 0,
      fonts = 0,
      count = 0;
  FILE *out = NULL;
  
  /* Make sure any existing object at the Messages file location is removed */
  err = Mess_CacheError (_swix (OS_File, _INR(0,1)|_OUT(0)|_OUT(6), 17, file, &file_type, &file_filetype));
  if (file_type == 3) file_type = 1;
  if (!err && file_type == 2)
  {
    err = File_DiagnoseFont (file, &file_filetype, NULL);
  }
  if (!err && file_type > 0)
  {
    int file_ver = -1; /* Just in case we're overwriting a module */
    if (file_filetype == 0xFFA) file_ver = Modver_Read (file);
    err = File_Backup (file, TRUE, file_type, file_filetype, file_ver);
  }
  if (!err)
  {
    
    /* First count how many encodings/fonts we have, so we know how much memory to allocate */
    for (enc = mess->BEncodings; enc != NULL; enc = enc->next)
    {
      bencodings++;
    }
    for (enc = mess->Encodings; enc != NULL; enc = enc->next)
    {
      encodings++;
    }
    for (fam = mess->Fonts; fam != NULL; fam = fam->next)
    {
      for (face = fam->faces; face != NULL; face = face->next)
      {
        fonts++;
      }
    }
    
    /* Allocate arrays */
    bencoding_a = malloc (bencodings * sizeof (font_encoding *) + 1);
    encoding_a = malloc (encodings * sizeof (font_encoding *) + 1);
    font_a = malloc (fonts * sizeof (font_face *) + 1);
    if (!bencoding_a || !encoding_a || !font_a) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
    if (!err)
    {
      
      /* Fill arrays */
      for (count = 0, enc = mess->BEncodings; enc != NULL; enc = enc->next)
      {
        bencoding_a [count++] = enc;
      }
      for (count = 0, enc = mess->Encodings; enc != NULL; enc = enc->next)
      {
        encoding_a [count++] = enc;
      }
      for (count = 0, fam = mess->Fonts; fam != NULL; fam = fam->next)
      {
        for (face = fam->faces; face != NULL; face = face->next)
        {
          font_a [count++] = face;
        }
      }
      
      /* Now sort the arrays */
      if (bencodings > 1)
      {
        qsort (bencoding_a, bencodings, sizeof (font_encoding *), static_CompareEncodings);
      }
      if (encodings > 1)
      {
        qsort (encoding_a, encodings, sizeof (font_encoding *), static_CompareEncodings);
      }
      if (fonts > 1)
      {
        qsort (font_a, fonts, sizeof (font_face *), static_CompareFonts);
      }
      
#ifdef debug_FONT_MESS
      printf("Writing to messages file '%s':\n", file);
      out = stdout;
#else
      out = fopen (file, "w");
      if (out == NULL) err = Mess_GenerateError ("CantOpen", errno_DONT_CARE, 1, file);
#endif
    }
    if (!err)
    {
      
      /* Write out the file */
      for (count = 0; count < bencodings; count++)
      {
        fprintf (out, "BEncoding_%s:\n", bencoding_a[count]->name);
      }
      for (count = 0; count < encodings; count++)
      {
        fprintf (out, "Encoding_%s:\n", encoding_a[count]->name);
      }
      for (count = 0; count < fonts; count++)
      {
        fprintf (out, "%sFont_%s:%s%s\n", font_a[count]->language ? "L" : "",
                                          font_a[count]->full_name,
                                          font_a[count]->alias,
                                          (font_a[count] == font_a[count]->family->default_face) ? "*" : "");
      }
      
#ifndef debug_FONT_MESS
      fclose (out);
#endif
    }
  }
  free (font_a);
  free (encoding_a);
  free (bencoding_a);
  static_FreeMessages (mess);
  return err;
}

/******	static_CompareEncodings() *****************************************\

Purpose:	qsort() callback for comparing encodings
In:		Pointers to font_encoding struct pointers
Out:		Difference

\**************************************************************************/

static int static_CompareEncodings (const void *p1, const void *p2)
{
  int diff = 0; /* default, in case the swi fails */
  _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
      (** (font_encoding **) p1).name, (** (font_encoding **) p2).name, 1 /* case insensitive */, &diff);
  return diff;
}

/******	static_CompareFonts() *********************************************\

Purpose:	qsort() callback for comparing font names
In:		Pointers to font_face struct pointers
Out:		Difference

\**************************************************************************/

static int static_CompareFonts (const void *p1, const void *p2)
{
  int diff = 0; /* default, in case the swi fails */
  _swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
      (** (font_face **) p1).full_name, (** (font_face **) p2).full_name, 1 /* case insensitive */, &diff);
  return diff;
}

/******	static_FreeMessages() *********************************************\

Purpose:	Deallocates any memory used by a struct font_messages
In:		Pointer to struct

\**************************************************************************/

static void static_FreeMessages (font_messages *mess)
{
  void *next;
  font_encoding *enc;
  font_family *fam;
  font_face *face;
  
  for (enc = mess->BEncodings; enc != NULL; enc = next)
  {
    next = enc->next;
    free (enc->name);
    free (enc);
  }
  
  for (enc = mess->Encodings; enc != NULL; enc = next)
  {
    next = enc->next;
    free (enc->name);
    free (enc);
  }
  
  for (fam = mess->Fonts; fam != NULL; fam = next)
  {
    for (face = fam->faces; face != NULL; face = next)
    {
      next = face->next;
      free (face->alias);
      free (face->full_name);
      free (face);
    }
    next = fam->next;
    free (fam->name);
    free (fam);
  }
  return;
}

/******	static_InsertFontStruct() *****************************************\

Purpose:	Inserts a new font face into a font_messages struct
In:		Struct pointer, details of font, reference to use to return family struct pointer
Out:		Pointer to error block

\**************************************************************************/

static _kernel_oserror *static_InsertFontStruct (font_messages *mess, const char *font, const char *alias,
    BOOL language, BOOL def_face, font_family **family_out)
{
  _kernel_oserror *err = NULL;
  font_family *new_fam = NULL;
  font_face *new_face;
  char *family,
       *face;
  
  /* First identify the family and face parts of the identifier */
  family = malloc (str_len (font) + 1);
  if (family == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  if (!err)
  {
    str_cpy (family, font);
    for (face = family; *face != '.' && *face != '\0'; face++);
    if (*face == '.') *face++ = '\0';
    /* face now points to the face name (may be a null string) and family points to family alone */
    
    /* See if the family already exists */
    for (new_fam = mess->Fonts; new_fam != NULL; new_fam = new_fam->next)
    {
      int diff;
      err = Mess_CacheError (_swix (Territory_Collate, _INR(0,3)|_OUT(0),
          -1, family, new_fam->name, 1, &diff)); /* case insensitive */
      if (diff == 0 || err) break;
    }
    /* If not, create a new one */
    if (!err && new_fam == NULL)
    {
      new_fam = malloc (sizeof (font_family));
      if (new_fam == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
      if (!err)
      {
        memset (new_fam, 0, sizeof (*new_fam));
        new_fam->next = mess->Fonts;
        mess->Fonts = new_fam;
        new_fam->name = malloc (strlen (family) + 1);
        if (new_fam->name == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
        if (!err) strcpy (new_fam->name, family);
#ifdef debug_FONT_MESS
printf("New family: %08x next: %08x: name: %s\n", (int)new_fam, (int)new_fam->next, new_fam->name);
#endif
      }
    }
    
    /* Now add the new face to the family */
    if (!err)
    {
      new_face = malloc (sizeof (font_face));
      if (new_face == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
      if (!err)
      {
        memset (new_face, 0, sizeof (*new_face));
        
        new_face->next = new_fam->faces;
        new_fam->faces = new_face;
        
        if (def_face) new_fam->default_face = new_face;

        new_face->language = language;
        
        new_face->alias = malloc (strlen (alias) + 1);

        new_face->full_name = malloc (strlen (family) + 1 + strlen (face) + 1);
        
        new_face->family = new_fam;
        
        if (new_face->alias == NULL || new_face->full_name == NULL)
        {
          err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
        }
        if (!err)
        {
          font_face_rule_list *rule;
          int rule_no = 1,
              index = 0;
          
          strcpy (new_face->alias, alias);
          
          sprintf (new_face->full_name, "%s%s%n%s", family, (*face=='\0' ? "" : "."), &index, face);
          
          new_face->name = new_face->full_name + index;
          
          for (rule = Rule; rule != NULL; rule = rule->next, rule_no++)
          {
            int diff;
            err = Mess_CacheError (_swix (Territory_Collate, _INR(0,3)|_OUT(0),
                -1, rule->name, new_face->name, 1, &diff)); /* case insensitive */
            if (diff == 0 || err) break;
          }
          if (!err && rule != NULL) new_face->priority = rule_no;
          
#ifdef debug_FONT_MESS
printf("New face in family '%s': %08x next: %08x: language: %d alias: '%s' fullname: '%s' "
"name: '%s' priority: %d default: '%s'\n", new_face->family->name, (int)new_face, (int)new_face->next,
new_face->language, new_face->alias, new_face->full_name, new_face->name, new_face->priority,
new_fam->default_face ? new_fam->default_face->name : "");
#endif
        }
      }
    }
  }
  
  if (!err && family_out != NULL) *family_out = new_fam;
  
  free (family);
  return err;
}

/******	static_FindNewDefaultFace() ***************************************\

Purpose:	Scans a font family to find a new default face for the family
In:		Pointer to family struct

\**************************************************************************/

static void static_FindNewDefaultFace (font_family *family)
{
  font_face *face;
  int priority = 0x40000000;
  
  family->default_face = NULL;
  
  for (face = family->faces; face != NULL; face = face->next)
  {
    if (face->priority != 0 && face->priority < priority)
    {
      family->default_face = face;
      priority = face->priority;
    }
  }
  
  return;
}

/******	static_ScanDirForFonts() ******************************************\

Purpose:	Finds fonts below a given directory, and adds them to the linked list
In:		Main font directory (without trailing '.'),
		  subdirectory to scan (ie, if successful, == font identifier)
		  and |font_messages| struct to add font to
Out:		Pointer to error block
Notes:		Function is recursive

\**************************************************************************/

static _kernel_oserror *static_ScanDirForFonts (const char *fontroot, const char *subdir, font_messages *mess)
{
  _kernel_oserror *err = NULL;
  osgbpb_file *gbpb_buf;
  char *dirtoscan,
       *subsubdir = NULL;
  
  /* Build the directory name to scan, and scan it */
  gbpb_buf = malloc (sizeof (*gbpb_buf));
  dirtoscan = malloc (str_len (fontroot) + 1 + str_len (subdir) + 1);
  if (gbpb_buf == NULL || dirtoscan == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
  if (!err)
  {
    int offset = 0,
        nread = -1;
    sprintf (dirtoscan, "%s%s%s", fontroot, (*subdir == '\0') ? "" : ".", subdir);
    do
    {
      err = Mess_CacheError (_swix (OS_GBPB, _INR(0,6)|_OUTR(3,4), 12,
          (int) dirtoscan, (int) gbpb_buf, 1, offset, sizeof (*gbpb_buf), "*", &nread, &offset));
      if (nread && gbpb_buf->object_type & 1 && *subdir != '\0' && !err)
      {
        /* Check for an IntMet* file, except in root */
        int diff;
        char intmet_lastchar = *(gbpb_buf->name + str_len(gbpb_buf->name) - 1);
        *(gbpb_buf->name + 6) = '\0'; /* truncate, ready for comparison */
        err = Mess_CacheError (_swix (Territory_Collate, _INR(0,3)|_OUT(0), -1,
            (int) gbpb_buf->name, (int) "IntMet", 1, &diff)); /* case insensitive */
        if (!err && diff == 0)
        {
          /* Found a font */
          BOOL language = (intmet_lastchar >= '0' && intmet_lastchar <= '9');
          err = static_InsertFontStruct (mess, subdir, "", language, FALSE, NULL);
        }
      }
      else if (nread && gbpb_buf->object_type & 2 && !err)
      {
        /* Check subdirectories */
        subsubdir = malloc (str_len (subdir) + 1 + str_len (gbpb_buf->name) + 1);
        if (subsubdir == NULL) err = Mess_GenerateError ("NoMem", errno_DONT_CARE, 0);
        if (!err)
        {
          sprintf (subsubdir, "%s%s%s", subdir, (*subdir == '\0') ? "" : ".", gbpb_buf->name);
          err = static_ScanDirForFonts (fontroot, subsubdir, mess); /* recurse */
        }
        free (subsubdir);
      }
    }
    while (offset != -1 && !err);
  }
  
  free (dirtoscan);
  free (gbpb_buf);
  return err;
}
