   10DEFPROCSWIS
   20LOCAL er$
   30er$="SWIS"
   40PRINT "PROCSWIS"
   50[OPT I%
   80\ ------------------- SWI Code --------------
  100.swiControlWord%    \ Provides the address of a control word
  110                    \ used by Replay for 1 if n playback
  120                    \ On entry:
  130                    \    none
  140                    \ On exit:
  150                    \    R0 = control word address
  170    ADD   R0,R12,#work_ControlWord%
  180    MOV   PC,R14
  210\ -------------
  240.swiInstallHandler%            \ Install a linear handler
  250                               \ On entry:
  260                               \  R0 = Handler address
  270                               \  R1 = parameter to pass
  280                               \  R2 = flags
  290                               \  R3 = name of handler
  300                               \  R4 = Type if bit 0 of flags = 1
  310                               \ On exit:
  320                               \  R0 = Handler number
  330    STMDB R13!,{R1-R12,R14}
  350    CMP   R0,#0                     \ Check handler address non-zero
  360    LDMEQIA R13!,{R1-R12,PC}^
  380    ADD   R8,R12,#work_handlerTable% \ Get address of table
  390    MOV   R6,#handlerMax%            \ Maximum number available
  410    \ Look first for handler already exists
  430.swiInstallHandlerCheckSlot%
  450    LDR   R5,[R8,#handler_Address%]
  460    CMP   R5,R0                         \ Check address
  470    BNE   swiInstallHandlerCheckNext%   \ Not equal
  490    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
  500    CMP   R7,R1
  510    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry
  530.swiInstallHandlerCheckNext%
  550    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  560    SUBS  R6,R6,#1
  570    BNE   swiInstallHandlerCheckSlot%
  590    \ OK so doesn't already exist
  600    \ Now look for an empty slot
  620    ADD   R8,R12,#work_handlerTable% \ Get address of table
  630    MOV   R6,#handlerMax%            \ Maximum number available
  650.swiInstallHandlerFindSlot%
  670    LDR   R5,[R8,#handler_Address%]
  680    CMP   R5,#0
  690    BEQ   swiInstallHandlerGo%       \ Free slot
  710    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  720    SUBS  R6,R6,#1
  730    BNE   swiInstallHandlerFindSlot%
  750    \ No more slots available
  770    B     installMaxError%
  790.swiInstallHandlerGo%                \ OK So enter new handler
  800                                     \ R8 = slot pointer
  810    BL     stopSound%                \ Make sure nothing happening
  830    STR    R0,[R8,#handler_Address%]
  840    STR    R1,[R8,#handler_Parameter%]
  850    STR    R2,[R8,#handler_Flags%]
  870    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
  880    MOVEQ  R4,#handlerType_Default%
  890    STR    R4,[R8,#handler_Type%]     \ Type
  910    \ Set handler type variables
  930    RSB   R0,R6,#handlerMax%    \ Handler number
  950    BL    setHandlerType%
  970    \ Name
  990    ADD    R5,R8,#handler_Name%       \ Position of name
 1000    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
 1010    SUB    R2,R2,#1
 1030.swiInstallHandlerNameLoop%
 1050    LDRB   R7,[R3],#1
 1060    STRB   R7,[R5],#1
 1070    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
 1080    MOVEQ  R7,#0
 1090    STREQB R7,[R5]
 1110    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached
 1130    BNE    swiInstallHandlerNameLoop%  \ Carry on with name
 1160    \ And initialise the other parameters in the table
 1180    MOV    R0,#0                       \ Volume LR
 1190    SUB    R0,R0,#1                    \ = &FFFF FFFF
 1200    STR    R0,[R8,#handler_Volume%]
 1220    MOV    R0,R8                       \ Set up scaled volume
 1230    BL     scaleHandlerVolume%
 1260    MOV    R0,#0
 1270    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined
 1290    MOV    R0,#1<<24
 1300    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1
 1330.swiInstallHandlerExit%
 1350    BL    startSound%                   \ Set sound going again and provoke a driver check
 1370    RSB   R0,R6,#handlerMax%            \ Return handler number
 1380    ADD   R0,R0,#1                      \ In the range 1 - handlerMax
 1410    LDMIA R13!,{R1-R12,PC}^
 1430\
 1450.installMaxError%
 1460    LDMIA R13!,{R1-R12,R14}
 1470    ADR   R0,installMaxMesg%
 1480    ORRS  PC,R14,#Overflow_Flag
 1490.installMaxMesg%
 1500    EQUD  &1E6
 1510    EQUS  "Maximum nunber of handlers reached"
 1520    EQUB  0
 1530    ALIGN
 1540\
 1570\ -----------
 1590.swiRemoveHandler%           \ Remove a particular handler
 1600                             \ Slot number in R0, 1 - 10
 1610    STMDB R13!,{R0-R12,R14}
 1640    ADD   R1,R12,#work_handlerTable%
 1650    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 1670    CMP   R0,#0                      \ If <0 then error
 1680    BLT   swiHandlerNumError%
 1700    CMP   R0,#handlerMax%            \ If > max then error
 1710    BGE   swiHandlerNumError%
 1730    MOV   R3,#handlerTableLen%
 1740    MLA   R2,R3,R0,R1
 1760    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
 1770    CMP   R1,#0
 1780    BEQ   swiHandlerExistError%       \ If not then exit
 1800    BL    stopSound%         \ Stop sound and wait for end of buffer fill
 1820    MOV   R0,#0                       \ Remove involves simply setting Address to 0
 1830    STR   R0,[R2,#handler_Address%]
 1850    BL    startSound%
 1880    LDMIA R13!,{R0-R12,PC}^
 1900\
 1910.swiHandlerNumError%
 1920    LDMIA R13!,{R0-R12,R14}
 1930.swiHandlerNumError1%
 1940    ADR   R0,HandlerNumMesg%
 1950    ORRS  PC,R14,#Overflow_Flag
 1960.HandlerNumMesg%
 1970    EQUD  &1E6
 1980    EQUS  "Handler number out of range"
 1990    EQUB  0
 2000    ALIGN
 2010\
 2030.swiHandlerExistError%
 2040    LDMIA R13!,{R0-R12,R14}
 2050.swiHandlerExistError1%
 2060    ADR   R0,HandlerExistMesg%
 2070    ORRS  PC,R14,#Overflow_Flag
 2080.HandlerExistMesg%
 2090    EQUD  &1E6
 2100    EQUS  "Handler not installed"
 2110    EQUB  0
 2120    ALIGN
 2130\
 2160\ -----------
 2180.swiHandlerType% \ Set the type of the handler
 2190                 \ On entry:
 2200                 \    R0 = handler number
 2210                 \    R1 = Type
 2220                 \ On exit:
 2240    STMDB R13!,{R6-R12,R14}
 2260    MOV   R7,R1   \ Type into R7
 2280    ADD   R1,R12,#work_handlerTable%
 2290    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2310    CMP   R0,#0                      \ If <0 then error
 2320    LDMLTIA R13!,{R6-R12,R14}
 2330    BLT   swiHandlerNumError1%
 2350    CMP   R0,#handlerMax%            \ If > max then error
 2360    LDMGEIA R13!,{R6-R12,R14}
 2370    BGE   swiHandlerNumError1%
 2390    MOV   R3,#handlerTableLen%
 2400    MLA   R6,R3,R0,R1
 2420    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2430    CMP   R1,#0
 2440    LDMEQIA R13!,{R6-R12,R14}
 2450    BEQ   swiHandlerExistError1%       \ If not then exit
 2470    \ R0 = Handler number (0-n)
 2490    LDR   R4,[R6,#handler_Type%]
 2500    BL    clearHandlerType%
 2520    STR   R7,[R6,#handler_Type%]
 2530    MOV   R4,R7
 2540    BL    setHandlerType%
 2560    LDMIA R13!,{R6-R12,PC}
 2590\ -----------
 2610.swiHandlerInfo%   \ R0 = handler number
 2620                   \ On exit:
 2630                   \ R0 = number of next available handler or 0 for none
 2640                   \ R1 = flags
 2650                   \ R2 = name
 2660                   \ R3 = Sample frequency
 2670                   \ R4 = Sample type
 2680                   \ R5 = Volume
 2700    STMDB R13!,{R6-R12,R14}
 2720    ADD   R1,R12,#work_handlerTable%
 2730    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2750    CMP   R0,#0                      \ If <0 then error
 2760    LDMLTIA R13!,{R6-R12,R14}
 2770    BLT   swiHandlerNumError1%
 2790    CMP   R0,#handlerMax%            \ If > max then error
 2800    LDMGEIA R13!,{R6-R12,R14}
 2810    BGE   swiHandlerNumError1%
 2830    MOV   R3,#handlerTableLen%
 2840    MLA   R6,R3,R0,R1
 2860    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2870    CMP   R1,#0
 2880    LDMEQIA R13!,{R6-R12,R14}
 2890    BEQ   swiHandlerExistError1%       \ If not then exit
 2910    \ Get handler values
 2930    LDR   R1,[R6,#handler_Flags%]
 2940    ADD   R2,R6,#handler_Name%
 2950    LDR   R3,[R6,#handler_SampleFrequency%]
 2960    LDR   R4,[R6,#handler_Type%]
 2970    LDR   R5,[R6,#handler_Volume%]
 2990    \ Now find next handler
 3010.swiHandlerInfoLoop%
 3030    ADD   R0,R0,#1
 3040    CMP   R0,#handlerMax%
 3050    MOVEQ R0,#0
 3060    BEQ   swiHandlerInfoExit%
 3080    ADD   R6,R6,#handlerTableLen%    \ Try next one
 3090    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
 3100    CMP   R7,#0
 3110    BEQ   swiHandlerInfoLoop%        \ No, then try next one
 3130.swiHandlerInfoExit%
 3150    LDMIA R13!,{R6-R12,PC}^
 3170\ -----------
 3190.swiSampleRate%          \ Either set the current driver rate
 3200                         \ or set the rate for a particular handler
 3210                         \ On entry:
 3220                         \ R0 = 0 for set driver rate
 3230                         \    > 0 for handler number
 3240                         \ R1 = sample frequency required
 3250                         \      if 0 then use current rate
 3260                         \ On exit:
 3270                         \ R1 = actual sample rate
 3280                         \ R2 = sample period
 3290                         \ R3 = fractional step used get the required rate
 3310    STMDB R13!,{R4-R12,R14}
 3340    CMP   R0,#0
 3350    BNE   swiSampleRateDo%
 3370    \     Set driver rate
 3390    MOV   R0,R1              \ Move rate into R0
 3400    BL    newSampleRate%     \ Sets new rate across all handlers
 3410                             \ all registers preserved
 3430    LDR   R0,[R12,#work_SampleFrequency%]
 3450    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
 3460                              \ return fraction in R0
 3490    B     swiSampleRateExit%
 3520.swiSampleRateDo%
 3540    \ Find handler
 3560    ADD   R2,R12,#work_handlerTable%
 3570    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 3590    CMP   R0,#0                      \ If <0 then error
 3600    LDMLTIA R13!,{R4-R12,R14}
 3610    BLT   swiHandlerNumError1%
 3630    CMP   R0,#handlerMax%            \ If > max then error
 3640    LDMGEIA R13!,{R4-R12,R14}
 3650    BGE   swiHandlerNumError1%
 3670    MOV   R3,#handlerTableLen%
 3680    MLA   R6,R3,R0,R2
 3700    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
 3710    CMP   R2,#0
 3720    LDMEQIA R13!,{R4-R12,R14}
 3730    BEQ   swiHandlerExistError1%       \ If not then exit
 3750    \   Get fraction
 3770    CMP   R1,#0
 3780    LDREQ R0,[R12,#work_SampleFrequency%]
 3790    MOVNE R0,R1
 3800    BL    sampleRateFraction%          \ Return fraction in R0
 3820    \  Store values in handler table
 3840    CMP   R1,#0
 3850    LDREQ R1,[R12,#work_SampleFrequency%]
 3860    STR   R1,[R6,#handler_SampleFrequency%]
 3870    STR   R0,[R6,#handler_Fraction%]
 3890.swiSampleRateExit%
 3910    MOV   R3,R0                         \ Set up return values
 3920    LDR   R1,[R12,#work_SampleFrequency%]
 3930    LDR   R2,[R12,#work_SamplePeriod%]
 3950    LDMIA R13!,{R4-R12,PC}^
 3970\ -----------
 3990.swiHandlerVolume%           \ Set a handler's volume
 4000                             \ On entry:
 4010                             \ R0 = handler number
 4020                             \ R1 = LR volume to set
 4030                             \ On exit:
 4040                             \ R1 = current volume
 4060    STMDB R13!,{R0,R2-R12,R14}
 4080    \ Find handler
 4100    ADD   R4,R12,#work_handlerTable%
 4110    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4130    CMP   R0,#0                      \ If <0 then error
 4140    LDMLTIA R13!,{R0,R1,R3-R12,R14}
 4150    BLT   swiHandlerNumError1%
 4170    CMP   R0,#handlerMax%            \ If > max then error
 4180    LDMGEIA R13!,{R0,R1,R3-R12,R14}
 4190    BGE   swiHandlerNumError1%
 4210    MOV   R3,#handlerTableLen%
 4220    MLA   R6,R3,R0,R4
 4240    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
 4250    CMP   R4,#0
 4260    LDMEQIA R13!,{R0,R1,R3-R12,R14}
 4270    BEQ   swiHandlerExistError1%       \ If not then exit
 4290    STR   R1,[R6,#handler_Volume%]     \ Set volume
 4300    MOV   R0,R6
 4310    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr
 4330    LDR   R1,[R6,#handler_Volume%]     \ Read result
 4350    LDMIA R13!,{R0,R2-R12,PC}^
 4370\ -----------
 4390.swiHandlerSampleType%        \ Not in this version
 4410    STMDB R13!,{R0-R12,R14}
 4440    LDMIA R13!,{R0-R12,PC}^
 4460\ -----------
 4480.swiHandlerPause%             \ Not in this version
 4500    STMDB R13!,{R0-R12,R14}
 4530    LDMIA R13!,{R0-R12,PC}^
 4550\ -----------
 4570.swiInstallDriver%  \ Install or make active a driver
 4580                    \ R0 = Pointer to driver table address
 4590                    \      or 1 = Linear
 4600                    \      or 2 = Log
 4610                    \ R1 = parameter to pass driver in R12 when called
 4620                    \ R2 = flags
 4630                    \ R3 = Volume
 4650    STMDB R13!,{R0-R12,R14}
 4670    \ If R0 = 1 or 2 then Linear or Log
 4680    \ Otherwise regard this as a new driver
 4700    CMP   R0,#2
 4710    BGT   swiInstallDriverTable%
 4730    CMP   R0,#1
 4740    BNE   swiInstallDriverLog%
 4760    BL    installLinearDriver%
 4780    B     swiInstallDriverExit%
 4800.swiInstallDriverLog%
 4820\    CMP   R0,#2
 4830\    BLEQ  installLogDriver%
 4850    B     swiInstallDriverExit%
 4880.swiInstallDriverTable%
 4900    BL    installDriver%               \ Simply pass on to this routine
 4930.swiInstallDriverExit%
 4950    LDMIA R13!,{R0-R12,PC}^
 4970\ -----------
 4990.swiDriverNumError%
 5000    LDMIA R13!,{R0-R12,R14}
 5010.swiDriverNumError1%
 5020    ADR   R0,DriverNumMesg%
 5030    ORRS  PC,R14,#Overflow_Flag
 5040.DriverNumMesg%
 5050    EQUD  &1E6
 5060    EQUS  "Driver number out of range"
 5070    EQUB  0
 5080    ALIGN
 5090\
 5110.swiDriverExistError%
 5120    LDMIA R13!,{R0-R12,R14}
 5130.swiDriverExistError1%
 5140    ADR   R0,DriverExistMesg%
 5150    ORRS  PC,R14,#Overflow_Flag
 5160.DriverExistMesg%
 5170    EQUD  &1E6
 5180    EQUS  "Driver not installed"
 5190    EQUB  0
 5200    ALIGN
 5210\
 5230.swiRemoveDriverError%
 5240    LDMIA R13!,{R0-R12,R14}
 5250    ADR   R0,swiRemoveDriverMesg%
 5260    ORRS  PC,R14,#Overflow_Flag
 5270.swiRemoveDriverMesg%
 5280    EQUD  &1E6
 5290    EQUS  "Cannot remove the default driver"
 5300    EQUB  0
 5310    ALIGN
 5320\
 5340\ -----------
 5360.swiRemoveDriver%      \ Remove a driver from the driver table
 5370                       \ On entry:
 5380                       \   R0 = driver number
 5390                       \        cannot remove driver 1 as this is the default driver
 5410    STMDB R13!,{R0-R12,R14}
 5430    \ First check parameter
 5450    ADD   R4,R12,#work_driverTable%
 5460    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 5480    CMP   R0,#0                      \ < 0
 5490    BLT   swiDriverNumError%
 5510    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver
 5530    CMP   R0,#driverMax%             \ >= max
 5540    BGE   swiDriverNumError%
 5560    \ Does the driver exist?
 5580    MOV   R3,#driverTableLen%
 5590    MLA   R6,R3,R0,R4
 5610    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 5620    CMP   R4,#0
 5630    BEQ   swiDriverExistError%         \ If not then exit
 5650    \ is driver current
 5670    SUB   R4,R6,R12
 5680    LDR   R0,[R12,#work_currentDriver%]
 5690    CMP   R4,R0
 5700    BNE   swiRemoveDriverNext%
 5720    \ if it is then release it first
 5740    BL    releaseDriver%
 5760    \ and make sure at least the default driver is installed instead
 5780    MOV   R0,#1              \ Default driver
 5790    BL    swiInstallDriver%
 5810.swiRemoveDriverNext%
 5830    \ Now remove the driver entry
 5850    MOV   R0,#0
 5860    STR   R0,[R6,#driver_Address%]
 5880    LDMIA R13!,{R0-R12,PC}^
 5900\ -----------
 5920.swiDriverInfo%   \ R0 = driver number
 5930                  \ On exit:
 5940                  \ R0 = number of next available driver or 0 for none
 5950                  \ R1 = flags
 5960                  \ R2 = name
 5970                  \ R3 = Volume
 5980                  \ R4 = Overrun count
 6000    STMDB R13!,{R5-R12,R14}
 6020    ADD   R4,R12,#work_driverTable%
 6030    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6050    CMP   R0,#0                      \ < 0
 6060    LDMLTIA R13!,{R5-R12,R14}
 6070    BLT   swiDriverNumError1%
 6090    CMP   R0,#driverMax%             \ >= max
 6100    LDMGEIA R13!,{R5-R12,R14}
 6110    BGE   swiDriverNumError1%
 6130    \ Does the driver exist?
 6150    MOV   R3,#driverTableLen%
 6160    MLA   R6,R3,R0,R4
 6180    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6190    CMP   R4,#0
 6200    LDMEQIA R13!,{R5-R12,R14}
 6210    BEQ   swiDriverExistError1%         \ If not then exit
 6230    \ Get driver values
 6250\    LDR   R1,[R6,#driver_Flags%]
 6260    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
 6270    ADD   R4,R4,R12
 6280    CMP   R4,R6
 6290    MOVEQ R1,#1        \ 1 if current
 6300    MOVNE R1,#0        \ 0 if not
 6320    ADD   R2,R6,#driver_Name%
 6330    LDR   R3,[R6,#driver_Volume%]
 6350    \ Now find next driver, if it exists
 6370.swiDriverInfoLoop%
 6390    ADD   R0,R0,#1
 6400    CMP   R0,#driverMax%
 6410    MOVEQ R0,#0
 6420    BEQ   swiDriverInfoExit%
 6440    ADD   R6,R6,#driverTableLen%    \ Try next one
 6450    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
 6460    CMP   R7,#0
 6470    BEQ   swiDriverInfoLoop%        \ No, then try next one
 6490.swiDriverInfoExit%
 6510    LDR   R4,[R12,#work_callBack_Count%]
 6530    LDMIA R13!,{R5-R12,PC}^
 6550\ -----------
 6570.swiDriverVolume%            \ Set the volume for a driver
 6580                             \ On entry:
 6590                             \    R0 = driver number
 6600                             \    R1 = new volume
 6610                             \ On exit:
 6620                             \    R0 = current volume
 6630    STMDB R13!,{R1-R12,R14}
 6650    ADD   R4,R12,#work_driverTable%
 6660    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6680    CMP   R0,#0                      \ < 0
 6690    LDMLTIA R13!,{R1-R12,R14}
 6700    BLT   swiDriverNumError1%
 6720    CMP   R0,#driverMax%             \ >= max
 6730    LDMGEIA R13!,{R1-R12,R14}
 6740    BGE   swiDriverNumError1%
 6760    \ Does the driver exist?
 6780    MOV   R3,#driverTableLen%
 6790    MLA   R6,R3,R0,R4
 6810    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6820    CMP   R4,#0
 6830    LDMEQIA R13!,{R1-R12,R14}
 6840    BEQ   swiDriverExistError1%         \ If not then exit
 6860    MOV   R0,R1      \ Volume
 6870    MOV   R1,R6      \ Table address
 6880    BL    driverVolume%                 \ Set driver volume to R0
 6900    \ Note that when the driver's volume changes, all handler scaled
 6910    \ volumes may need to be reset
 6930    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
 6940    ADD   R0,R0,R12
 6950    CMP   R0,R6
 6970    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes
 6990    LDR   R0,[R6,#driver_Volume%]       \ Return volume
 7010    LDMIA R13!,{R1-R12,PC}^
 7030\ ----------------
 7050.swiDriverMixer%             \ Set or read the mixer for a driver
 7060                             \ On entry:
 7070                             \    R0 = driver number
 7080                             \    R1 = function   0 = read, 1 = set
 7090                             \    R2 = mixer number
 7100                             \    R3 = value if set
 7110                             \ On exit:
 7120                             \    R0 preserved
 7130                             \    R1 = no of mixers
 7140                             \    R2 = value
 7150                             \    R3 = name
 7170    STMDB R13!,{R0,R4-R12,R14}
 7190    ADD   R4,R12,#work_driverTable%
 7200    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 7220    CMP   R0,#0                      \ < 0
 7230    LDMLTIA R13!,{R0,R4-R12,R14}
 7240    BLT   swiDriverNumError1%
 7260    CMP   R0,#driverMax%             \ >= max
 7270    LDMGEIA R13!,{R0,R4-R12,R14}
 7280    BGE   swiDriverNumError1%
 7300    \ Does the driver exist?
 7320    MOV   R3,#driverTableLen%
 7330    MLA   R6,R3,R0,R4
 7350    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 7360    CMP   R4,#0
 7370    LDMEQIA R13!,{R1-R12,R14}
 7380    BEQ   swiDriverExistError1%         \ If not then exit
 7400    MOV   R0,R1         \ Function code
 7410    MOV   R1,R2         \ Mixer number
 7420    MOV   R2,R3         \ Value
 7430    MOV   R3,R6         \ Driver table pointer
 7450    BL    driverMixer%
 7480    LDMIA R13!,{R0,R4-R12,PC}^
 7490]
 7500ENDPROC
