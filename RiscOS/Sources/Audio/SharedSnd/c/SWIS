DEFPROCSWIS
LOCAL er$
er$="SWIS"
PRINT "PROCSWIS"
[OPT I%


\ ------------------- SWI Code --------------

.swiControlWord%    \ Provides the address of a control word
                    \ used by Replay for 1 if n playback
                    \ On entry:
                    \    none
                    \ On exit:
                    \    R0 = control word address

    ADD   R0,R12,#work_ControlWord%
    MOV   PC,R14


\ -------------

]
IF debug1% THEN
[OPT I%

.swiTest% \ Test stuff

    STMDB R13!,{R14}


    LDMIA R13!,{PC}

\----------

.swiInfo% \ Get info

    STMDB R13!,{R14}

    LDR   R0,[R12,#work_SampleFrequency%]
    LDR   R1,[R12,#work_SamplePeriod%]

    LDMIA R13!,{PC}


\ ---------

]
ENDIF
[OPT I%

.swiInstallHandler%            \ Install a linear handler
                               \ On entry:
                               \  R0 = Handler address
                               \  R1 = parameter to pass
                               \  R2 = flags
                               \  R3 = name of handler
                               \  R4 = Type if bit 0 of flags = 1
                               \ On exit:
                               \  R0 = Handler number
    STMDB R13!,{R1-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Install handler"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    CMP   R0,#0                     \ Check handler address non-zero
    LDMEQIA R13!,{R1-R12,PC}^

    ADD   R8,R12,#work_handlerTable% \ Get address of table
    MOV   R6,#handlerMax%            \ Maximum number available

    \ Look first for handler already exists

.swiInstallHandlerCheckSlot%

    LDR   R5,[R8,#handler_Address%]
    CMP   R5,R0                         \ Check address
    BNE   swiInstallHandlerCheckNext%   \ Not equal

    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
    CMP   R7,R1
    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry

.swiInstallHandlerCheckNext%

    ADD   R8,R8,#handlerTableLen%   \ Try next slot
    SUBS  R6,R6,#1
    BNE   swiInstallHandlerCheckSlot%

    \ OK so doesn't already exist
    \ Now look for an empty slot

    ADD   R8,R12,#work_handlerTable% \ Get address of table
    MOV   R6,#handlerMax%            \ Maximum number available

.swiInstallHandlerFindSlot%

    LDR   R5,[R8,#handler_Address%]
    CMP   R5,#0
    BEQ   swiInstallHandlerGo%       \ Free slot

    ADD   R8,R8,#handlerTableLen%   \ Try next slot
    SUBS  R6,R6,#1
    BNE   swiInstallHandlerFindSlot%

    \ No more slots available

    B     installMaxError%

.swiInstallHandlerGo%                \ OK So enter new handler
                                     \ R8 = slot pointer
    BL     stopSound%                \ Make sure nothing happening

    STR    R0,[R8,#handler_Address%]
    STR    R1,[R8,#handler_Parameter%]
    STR    R2,[R8,#handler_Flags%]

    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
    MOVEQ  R4,#handlerType_Default%
    STR    R4,[R8,#handler_Type%]     \ Type

    \ Set handler type variables

    RSB   R0,R6,#handlerMax%    \ Handler number

    BL    setHandlerType%

    \ Name

    ADD    R5,R8,#handler_Name%       \ Position of name
    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
    SUB    R2,R2,#1

.swiInstallHandlerNameLoop%

    LDRB   R7,[R3],#1
    STRB   R7,[R5],#1
    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
    MOVEQ  R7,#0
    STREQB R7,[R5]

    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached

    BNE    swiInstallHandlerNameLoop%  \ Carry on with name


    \ And initialise the other parameters in the table

    MOV    R0,#0                       \ Volume LR
    SUB    R0,R0,#1                    \ = &FFFF FFFF
    STR    R0,[R8,#handler_Volume%]

    MOV    R0,R8                       \ Set up scaled volume
    BL     scaleHandlerVolume%


    MOV    R0,#0
    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined

    MOV    R0,#1<<24
    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1


.swiInstallHandlerExit%

    BL    startSound%                   \ Set sound going again and provoke a driver check

    RSB   R0,R6,#handlerMax%            \ Return handler number
    ADD   R0,R0,#1                      \ In the range 1 - handlerMax


    LDMIA R13!,{R1-R12,PC}^

\

.installMaxError%
    LDMIA R13!,{R1-R12,R14}
    ADR   R0,installMaxMesg%
    ORRS  PC,R14,#Overflow_Flag
.installMaxMesg%
    EQUD  &1E6
    EQUS  "Maximum nunber of handlers reached"
    EQUB  0
    ALIGN
\


\ -----------

.swiRemoveHandler%           \ Remove a particular handler
                             \ Slot number in R0, 1 - 10
    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Remove handler"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    BLT   swiHandlerNumError%

    CMP   R0,#handlerMax%            \ If > max then error
    BGE   swiHandlerNumError%

    MOV   R3,#handlerTableLen%
    MLA   R2,R3,R0,R1

    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    BEQ   swiHandlerExistError%       \ If not then exit

    \ R0 = Handler number (0-n)

    LDR   R4,[R2,#handler_Type%]
    BL    clearHandlerType%

    BL    stopSound%         \ Stop sound and wait for end of buffer fill

    MOV   R0,#0                       \ Remove involves simply setting Address to 0
    STR   R0,[R2,#handler_Address%]

    BL    startSound%


    LDMIA R13!,{R0-R12,PC}^

\
.swiHandlerNumError%
    LDMIA R13!,{R0-R12,R14}
.swiHandlerNumError1%
    ADR   R0,HandlerNumMesg%
    ORRS  PC,R14,#Overflow_Flag
.HandlerNumMesg%
    EQUD  &1E6
    EQUS  "Handler number out of range"
    EQUB  0
    ALIGN
\

.swiHandlerExistError%
    LDMIA R13!,{R0-R12,R14}
.swiHandlerExistError1%
    ADR   R0,HandlerExistMesg%
    ORRS  PC,R14,#Overflow_Flag
.HandlerExistMesg%
    EQUD  &1E6
    EQUS  "Handler not installed"
    EQUB  0
    ALIGN
\


\ -----------

.swiHandlerType% \ Set the type of the handler
                 \ On entry:
                 \    R0 = handler number
                 \    R1 = Type
                 \ On exit:

    STMDB R13!,{R6-R12,R14}

    MOV   R7,R1   \ Type into R7

    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R6-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R6-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R1

    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    LDMEQIA R13!,{R6-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \ R0 = Handler number (0-n)

    LDR   R4,[R6,#handler_Type%]
    BL    clearHandlerType%

    STR   R7,[R6,#handler_Type%]
    MOV   R4,R7
    BL    setHandlerType%

    LDMIA R13!,{R6-R12,PC}


\ -----------

.swiHandlerInfo%   \ R0 = handler number
                   \ On exit:
                   \ R0 = number of next available handler or 0 for none
                   \ R1 = flags
                   \ R2 = name
                   \ R3 = Sample frequency
                   \ R4 = Sample type
                   \ R5 = Volume

    STMDB R13!,{R6-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler info"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R1,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R6-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R6-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R1

    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R1,#0
    LDMEQIA R13!,{R6-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \ Get handler values

    LDR   R1,[R6,#handler_Flags%]
    ADD   R2,R6,#handler_Name%
    LDR   R3,[R6,#handler_SampleFrequency%]
    LDR   R4,[R6,#handler_Type%]
    LDR   R5,[R6,#handler_Volume%]

    \ Now find next handler

.swiHandlerInfoLoop%

    ADD   R0,R0,#1
    CMP   R0,#handlerMax%
    MOVEQ R0,#0
    BEQ   swiHandlerInfoExit%

    ADD   R6,R6,#handlerTableLen%    \ Try next one
    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
    CMP   R7,#0
    BEQ   swiHandlerInfoLoop%        \ No, then try next one

.swiHandlerInfoExit%

    LDMIA R13!,{R6-R12,PC}^

\ -----------

.swiSampleRate%          \ Either set the current driver rate
                         \ or set the rate for a particular handler
                         \ On entry:
                         \ R0 = 0 for set driver rate
                         \    > 0 for handler number
                         \ R1 = sample frequency required
                         \      if 0 then use current rate
                         \ On exit:
                         \ R1 = actual sample rate
                         \ R2 = sample period
                         \ R3 = fractional step used get the required rate

    STMDB R13!,{R4-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Sample rate"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    CMP   R0,#0
    BNE   swiSampleRateDo%

    \     Set driver rate

    MOV   R0,R1              \ Move rate into R0
    BL    newSampleRate%     \ Sets new rate across all handlers
                             \ all registers preserved

    LDR   R0,[R12,#work_SampleFrequency%]

    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
                              \ return fraction in R0


    B     swiSampleRateExit%


.swiSampleRateDo%

    \ Find handler

    ADD   R2,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R4-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R4-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R2

    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R2,#0
    LDMEQIA R13!,{R4-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    \   Get fraction

    CMP   R1,#0
    LDREQ R0,[R12,#work_SampleFrequency%]
    MOVNE R0,R1
    BL    sampleRateFraction%          \ Return fraction in R0

    \  Store values in handler table

    CMP   R1,#0
    LDREQ R1,[R12,#work_SampleFrequency%]
    STR   R1,[R6,#handler_SampleFrequency%]
    STR   R0,[R6,#handler_Fraction%]

.swiSampleRateExit%

    MOV   R3,R0                         \ Set up return values
    LDR   R1,[R12,#work_SampleFrequency%]
    LDR   R2,[R12,#work_SamplePeriod%]

    LDMIA R13!,{R4-R12,PC}^

\ -----------

.swiHandlerVolume%           \ Set a handler's volume
                             \ On entry:
                             \ R0 = handler number
                             \ R1 = LR volume to set
                             \ On exit:
                             \ R1 = current volume

    STMDB R13!,{R0,R2-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler Volume"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    \ Find handler

    ADD   R4,R12,#work_handlerTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ If <0 then error
    LDMLTIA R13!,{R0,R1,R3-R12,R14}
    BLT   swiHandlerNumError1%

    CMP   R0,#handlerMax%            \ If > max then error
    LDMGEIA R13!,{R0,R1,R3-R12,R14}
    BGE   swiHandlerNumError1%

    MOV   R3,#handlerTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R0,R1,R3-R12,R14}
    BEQ   swiHandlerExistError1%       \ If not then exit

    STR   R1,[R6,#handler_Volume%]     \ Set volume
    MOV   R0,R6
    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr

    LDR   R1,[R6,#handler_Volume%]     \ Read result

    LDMIA R13!,{R0,R2-R12,PC}^

\ -----------

.swiHandlerSampleType%        \ Not in this version

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler sample type"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    LDMIA R13!,{R0-R12,PC}^

\ -----------

.swiHandlerPause%             \ Not in this version

    STMDB R13!,{R0-R12,R14}
]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Handler pause"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    LDMIA R13!,{R0-R12,PC}^

\ -----------

.swiInstallDriver%  \ Install or make active a driver
                    \ R0 = Pointer to driver table address
                    \      or 1 = Linear
                    \      or 2 = Log
                    \ R1 = parameter to pass driver in R12 when called
                    \ R2 = flags
                    \ R3 = Volume

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Install driver"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

    \ If R0 = 1 or 2 then Linear or Log
    \ Otherwise regard this as a new driver

    CMP   R0,#2
    BGT   swiInstallDriverTable%

    CMP   R0,#1
    BNE   swiInstallDriverLog%

    BL    installLinearDriver%

    B     swiInstallDriverExit%

.swiInstallDriverLog%

]
IF doLog% THEN
[OPT I%

    CMP   R0,#2
    BLEQ  installLogDriver%

]
ENDIF
[OPT I%

    B     swiInstallDriverExit%


.swiInstallDriverTable%

    BL    installDriver%               \ Simply pass on to this routine


.swiInstallDriverExit%

    LDMIA R13!,{R0-R12,PC}^

\ -----------

.swiDriverNumError%
    LDMIA R13!,{R0-R12,R14}
.swiDriverNumError1%
    ADR   R0,DriverNumMesg%
    ORRS  PC,R14,#Overflow_Flag
.DriverNumMesg%
    EQUD  &1E6
    EQUS  "Driver number out of range"
    EQUB  0
    ALIGN
\

.swiDriverExistError%
    LDMIA R13!,{R0-R12,R14}
.swiDriverExistError1%
    ADR   R0,DriverExistMesg%
    ORRS  PC,R14,#Overflow_Flag
.DriverExistMesg%
    EQUD  &1E6
    EQUS  "Driver not installed"
    EQUB  0
    ALIGN
\

.swiRemoveDriverError%
    LDMIA R13!,{R0-R12,R14}
    ADR   R0,swiRemoveDriverMesg%
    ORRS  PC,R14,#Overflow_Flag
.swiRemoveDriverMesg%
    EQUD  &1E6
    EQUS  "Cannot remove the default driver"
    EQUB  0
    ALIGN
\

\ -----------

.swiRemoveDriver%      \ Remove a driver from the driver table
                       \ On entry:
                       \   R0 = driver number
                       \        cannot remove driver 1 as this is the default driver

    STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Remove Driver"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    \ First check parameter

    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    BLT   swiDriverNumError%

    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver

    CMP   R0,#driverMax%             \ >= max
    BGE   swiDriverNumError%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    BEQ   swiDriverExistError%         \ If not then exit

    \ is driver current

    SUB   R4,R6,R12
    LDR   R0,[R12,#work_currentDriver%]
    CMP   R4,R0
    BNE   swiRemoveDriverNext%

    \ if it is then release it first

    BL    releaseDriver%

    \ and make sure at least the default driver is installed instead

    MOV   R0,#1              \ Default driver
    BL    swiInstallDriver%

.swiRemoveDriverNext%

    \ Now remove the driver entry

    MOV   R0,#0
    STR   R0,[R6,#driver_Address%]

    LDMIA R13!,{R0-R12,PC}^

\ -----------

.swiDriverInfo%   \ R0 = driver number
                  \ On exit:
                  \ R0 = number of next available driver or 0 for none
                  \ R1 = flags
                  \ R2 = name
                  \ R3 = Volume
                  \ R4 = Overrun count

    STMDB R13!,{R5-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver info"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R5-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R5-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R5-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    \ Get driver values

\    LDR   R1,[R6,#driver_Flags%]
    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
    ADD   R4,R4,R12
    CMP   R4,R6
    MOVEQ R1,#1        \ 1 if current
    MOVNE R1,#0        \ 0 if not

    ADD   R2,R6,#driver_Name%
    LDR   R3,[R6,#driver_Volume%]

    \ Now find next driver, if it exists

.swiDriverInfoLoop%

    ADD   R0,R0,#1
    CMP   R0,#driverMax%
    MOVEQ R0,#0
    BEQ   swiDriverInfoExit%

    ADD   R6,R6,#driverTableLen%    \ Try next one
    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
    CMP   R7,#0
    BEQ   swiDriverInfoLoop%        \ No, then try next one

.swiDriverInfoExit%

    LDR   R4,[R12,#work_callBack_Count%]

    LDMIA R13!,{R5-R12,PC}^

\ -----------

.swiDriverVolume%            \ Set the volume for a driver
                             \ On entry:
                             \    R0 = driver number
                             \    R1 = new volume
                             \ On exit:
                             \    R0 = current volume
    STMDB R13!,{R1-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver volume"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%


    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R1-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R1-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R1-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    MOV   R0,R1      \ Volume
    MOV   R1,R6      \ Table address
    BL    driverVolume%                 \ Set driver volume to R0

    \ Note that when the driver's volume changes, all handler scaled
    \ volumes may need to be reset

    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
    ADD   R0,R0,R12
    CMP   R0,R6

    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes

    LDR   R0,[R6,#driver_Volume%]       \ Return volume

    LDMIA R13!,{R1-R12,PC}^

\ ----------------

.swiDriverMixer%             \ Set or read the mixer for a driver
                             \ On entry:
                             \    R0 = driver number
                             \    R1 = function   0 = read, 1 = set
                             \    R2 = mixer number
                             \    R3 = value if set
                             \ On exit:
                             \    R0 preserved
                             \    R1 = no of mixers
                             \    R2 = value
                             \    R3 = name

    STMDB R13!,{R0,R4-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver mixer"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%



    ADD   R4,R12,#work_driverTable%
    SUB   R0,R0,#1                   \ 1-10 becomes 0-9

    CMP   R0,#0                      \ < 0
    LDMLTIA R13!,{R0,R4-R12,R14}
    BLT   swiDriverNumError1%

    CMP   R0,#driverMax%             \ >= max
    LDMGEIA R13!,{R0,R4-R12,R14}
    BGE   swiDriverNumError1%

    \ Does the driver exist?

    MOV   R3,#driverTableLen%
    MLA   R6,R3,R0,R4

    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
    CMP   R4,#0
    LDMEQIA R13!,{R1-R12,R14}
    BEQ   swiDriverExistError1%         \ If not then exit

    MOV   R0,R1         \ Function code
    MOV   R1,R2         \ Mixer number
    MOV   R2,R3         \ Value
    MOV   R3,R6         \ Driver table pointer

    BL    driverMixer%


    LDMIA R13!,{R0,R4-R12,PC}^
]
ENDPROC
