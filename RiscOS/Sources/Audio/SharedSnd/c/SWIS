   10DEFPROCSWIS
   20LOCAL er$
   30er$="SWIS"
   40PRINT "PROCSWIS"
   50[OPT I%
   60
   70
   80\ ------------------- SWI Code --------------
   90
  100.swiControlWord%    \ Provides the address of a control word
  110                    \ used by Replay for 1 if n playback
  120                    \ On entry:
  130                    \    none
  140                    \ On exit:
  150                    \    R0 = control word address
  160
  170    ADD   R0,R12,#work_ControlWord%
  180    MOV   PC,R14
  190
  200
  210\ -------------
  220
  230]
  240IF debug1% THEN
  250[OPT I%
  260
  270.swiTest% \ Test stuff
  280
  290    STMDB R13!,{R14}
  300
  310
  320    LDMIA R13!,{PC}
  330
  340\----------
  350
  360.swiInfo% \ Get info
  370
  380    STMDB R13!,{R14}
  390
  400    LDR   R0,[R12,#work_SampleFrequency%]
  410    LDR   R1,[R12,#work_SamplePeriod%]
  420
  430    LDMIA R13!,{PC}
  440
  450
  460\ ---------
  470
  480]
  490ENDIF
  500[OPT I%
  510
  520.swiInstallHandler%            \ Install a linear handler
  530                               \ On entry:
  540                               \  R0 = Handler address
  550                               \  R1 = parameter to pass
  560                               \  R2 = flags
  570                               \  R3 = name of handler
  580                               \  R4 = Type if bit 0 of flags = 1
  590                               \ On exit:
  600                               \  R0 = Handler number
  610    STMDB R13!,{R1-R12,R14}
  620
  630]
  640IF debug% THEN
  650[OPT I%
  660    SWI "XOS_WriteS"
  670    EQUS "Install handler"+CHR$(0):ALIGN
  680    SWI "XOS_NewLine"
  690]
  700ENDIF
  710[OPT I%
  720
  730    CMP   R0,#0                     \ Check handler address non-zero
  740    LDMEQIA R13!,{R1-R12,PC}^
  750
  760    ADD   R8,R12,#work_handlerTable% \ Get address of table
  770    MOV   R6,#handlerMax%            \ Maximum number available
  780
  790    \ Look first for handler already exists
  800
  810.swiInstallHandlerCheckSlot%
  820
  830    LDR   R5,[R8,#handler_Address%]
  840    CMP   R5,R0                         \ Check address
  850    BNE   swiInstallHandlerCheckNext%   \ Not equal
  860
  870    LDR   R7,[R8,#handler_Parameter%]   \ Check parameter
  880    CMP   R7,R1
  890    BEQ   swiInstallHandlerGo%          \ Address & Parameter are same so tidy rest of entry
  900
  910.swiInstallHandlerCheckNext%
  920
  930    ADD   R8,R8,#handlerTableLen%   \ Try next slot
  940    SUBS  R6,R6,#1
  950    BNE   swiInstallHandlerCheckSlot%
  960
  970    \ OK so doesn't already exist
  980    \ Now look for an empty slot
  990
 1000    ADD   R8,R12,#work_handlerTable% \ Get address of table
 1010    MOV   R6,#handlerMax%            \ Maximum number available
 1020
 1030.swiInstallHandlerFindSlot%
 1040
 1050    LDR   R5,[R8,#handler_Address%]
 1060    CMP   R5,#0
 1070    BEQ   swiInstallHandlerGo%       \ Free slot
 1080
 1090    ADD   R8,R8,#handlerTableLen%   \ Try next slot
 1100    SUBS  R6,R6,#1
 1110    BNE   swiInstallHandlerFindSlot%
 1120
 1130    \ No more slots available
 1140
 1150    B     installMaxError%
 1160
 1170.swiInstallHandlerGo%                \ OK So enter new handler
 1180                                     \ R8 = slot pointer
 1190    BL     stopSound%                \ Make sure nothing happening
 1200
 1210    STR    R0,[R8,#handler_Address%]
 1220    STR    R1,[R8,#handler_Parameter%]
 1230    STR    R2,[R8,#handler_Flags%]
 1240
 1250    TST    R2,#1    \ Type in R4 if flags bit 0 set, otherwise set to 0 (immediate)
 1260    MOVEQ  R4,#handlerType_Default%
 1270    STR    R4,[R8,#handler_Type%]     \ Type
 1280
 1290    \ Set handler type variables
 1300
 1310    RSB   R0,R6,#handlerMax%    \ Handler number
 1320
 1330    BL    setHandlerType%
 1340
 1350    \ Name
 1360
 1370    ADD    R5,R8,#handler_Name%       \ Position of name
 1380    MOV    R2,#handlerNameLen%        \ Make sure we don't overflow
 1390    SUB    R2,R2,#1
 1400
 1410.swiInstallHandlerNameLoop%
 1420
 1430    LDRB   R7,[R3],#1
 1440    STRB   R7,[R5],#1
 1450    SUBS   R2,R2,#1     \ If we have reached 31 then force a 0 into name buffer
 1460    MOVEQ  R7,#0
 1470    STREQB R7,[R5]
 1480
 1490    CMPNE  R7,#0        \ Look for 0 terminator if end of name length not reached
 1500
 1510    BNE    swiInstallHandlerNameLoop%  \ Carry on with name
 1520
 1530
 1540    \ And initialise the other parameters in the table
 1550
 1560    MOV    R0,#0                       \ Volume LR
 1570    SUB    R0,R0,#1                    \ = &FFFF FFFF
 1580    STR    R0,[R8,#handler_Volume%]
 1590
 1600    MOV    R0,R8                       \ Set up scaled volume
 1610    BL     scaleHandlerVolume%
 1620
 1630
 1640    MOV    R0,#0
 1650    STR    R0,[R8,#handler_SampleFrequency%] \ Rate not defined
 1660
 1670    MOV    R0,#1<<24
 1680    STR    R0,[R8,#handler_Fraction%]   \ Initialise fraction to 1
 1690
 1700
 1710.swiInstallHandlerExit%
 1720
 1730    BL    startSound%                   \ Set sound going again and provoke a driver check
 1740
 1750    RSB   R0,R6,#handlerMax%            \ Return handler number
 1760    ADD   R0,R0,#1                      \ In the range 1 - handlerMax
 1770
 1780
 1790    LDMIA R13!,{R1-R12,PC}^
 1800
 1810\
 1820
 1830.installMaxError%
 1840    LDMIA R13!,{R1-R12,R14}
 1850    ADR   R0,installMaxMesg%
 1860    ORRS  PC,R14,#Overflow_Flag
 1870.installMaxMesg%
 1880    EQUD  &1E6
 1890    EQUS  "Maximum nunber of handlers reached"
 1900    EQUB  0
 1910    ALIGN
 1920\
 1930
 1940
 1950\ -----------
 1960
 1970.swiRemoveHandler%           \ Remove a particular handler
 1980                             \ Slot number in R0, 1 - 10
 1990    STMDB R13!,{R0-R12,R14}
 2000
 2010]
 2020IF debug% THEN
 2030[OPT I%
 2040    SWI "XOS_WriteS"
 2050    EQUS "Remove handler"+CHR$(0):ALIGN
 2060    SWI "XOS_NewLine"
 2070]
 2080ENDIF
 2090[OPT I%
 2100
 2110    ADD   R1,R12,#work_handlerTable%
 2120    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2130
 2140    CMP   R0,#0                      \ If <0 then error
 2150    BLT   swiHandlerNumError%
 2160
 2170    CMP   R0,#handlerMax%            \ If > max then error
 2180    BGE   swiHandlerNumError%
 2190
 2200    MOV   R3,#handlerTableLen%
 2210    MLA   R2,R3,R0,R1
 2220
 2230    LDR   R1,[R2,#handler_Address%]   \ Does this handler exist?
 2240    CMP   R1,#0
 2250    BEQ   swiHandlerExistError%       \ If not then exit
 2260
 2270    \ R0 = Handler number (0-n)
 2280
 2290    LDR   R4,[R2,#handler_Type%]
 2300    BL    clearHandlerType%
 2310
 2320    BL    stopSound%         \ Stop sound and wait for end of buffer fill
 2330
 2340    MOV   R0,#0                       \ Remove involves simply setting Address to 0
 2350    STR   R0,[R2,#handler_Address%]
 2360
 2370    BL    startSound%
 2380
 2390
 2400    LDMIA R13!,{R0-R12,PC}^
 2410
 2420\
 2430.swiHandlerNumError%
 2440    LDMIA R13!,{R0-R12,R14}
 2450.swiHandlerNumError1%
 2460    ADR   R0,HandlerNumMesg%
 2470    ORRS  PC,R14,#Overflow_Flag
 2480.HandlerNumMesg%
 2490    EQUD  &1E6
 2500    EQUS  "Handler number out of range"
 2510    EQUB  0
 2520    ALIGN
 2530\
 2540
 2550.swiHandlerExistError%
 2560    LDMIA R13!,{R0-R12,R14}
 2570.swiHandlerExistError1%
 2580    ADR   R0,HandlerExistMesg%
 2590    ORRS  PC,R14,#Overflow_Flag
 2600.HandlerExistMesg%
 2610    EQUD  &1E6
 2620    EQUS  "Handler not installed"
 2630    EQUB  0
 2640    ALIGN
 2650\
 2660
 2670
 2680\ -----------
 2690
 2700.swiHandlerType% \ Set the type of the handler
 2710                 \ On entry:
 2720                 \    R0 = handler number
 2730                 \    R1 = Type
 2740                 \ On exit:
 2750
 2760    STMDB R13!,{R6-R12,R14}
 2770
 2780    MOV   R7,R1   \ Type into R7
 2790
 2800    ADD   R1,R12,#work_handlerTable%
 2810    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 2820
 2830    CMP   R0,#0                      \ If <0 then error
 2840    LDMLTIA R13!,{R6-R12,R14}
 2850    BLT   swiHandlerNumError1%
 2860
 2870    CMP   R0,#handlerMax%            \ If > max then error
 2880    LDMGEIA R13!,{R6-R12,R14}
 2890    BGE   swiHandlerNumError1%
 2900
 2910    MOV   R3,#handlerTableLen%
 2920    MLA   R6,R3,R0,R1
 2930
 2940    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 2950    CMP   R1,#0
 2960    LDMEQIA R13!,{R6-R12,R14}
 2970    BEQ   swiHandlerExistError1%       \ If not then exit
 2980
 2990    \ R0 = Handler number (0-n)
 3000
 3010    LDR   R4,[R6,#handler_Type%]
 3020    BL    clearHandlerType%
 3030
 3040    STR   R7,[R6,#handler_Type%]
 3050    MOV   R4,R7
 3060    BL    setHandlerType%
 3070
 3080    LDMIA R13!,{R6-R12,PC}
 3090
 3100
 3110\ -----------
 3120
 3130.swiHandlerInfo%   \ R0 = handler number
 3140                   \ On exit:
 3150                   \ R0 = number of next available handler or 0 for none
 3160                   \ R1 = flags
 3170                   \ R2 = name
 3180                   \ R3 = Sample frequency
 3190                   \ R4 = Sample type
 3200                   \ R5 = Volume
 3210
 3220    STMDB R13!,{R6-R12,R14}
 3230
 3240]
 3250IF debug% THEN
 3260[OPT I%
 3270    SWI "XOS_WriteS"
 3280    EQUS "Handler info"+CHR$(0):ALIGN
 3290    SWI "XOS_NewLine"
 3300]
 3310ENDIF
 3320[OPT I%
 3330
 3340
 3350
 3360    ADD   R1,R12,#work_handlerTable%
 3370    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 3380
 3390    CMP   R0,#0                      \ If <0 then error
 3400    LDMLTIA R13!,{R6-R12,R14}
 3410    BLT   swiHandlerNumError1%
 3420
 3430    CMP   R0,#handlerMax%            \ If > max then error
 3440    LDMGEIA R13!,{R6-R12,R14}
 3450    BGE   swiHandlerNumError1%
 3460
 3470    MOV   R3,#handlerTableLen%
 3480    MLA   R6,R3,R0,R1
 3490
 3500    LDR   R1,[R6,#handler_Address%]   \ Does this handler exist?
 3510    CMP   R1,#0
 3520    LDMEQIA R13!,{R6-R12,R14}
 3530    BEQ   swiHandlerExistError1%       \ If not then exit
 3540
 3550    \ Get handler values
 3560
 3570    LDR   R1,[R6,#handler_Flags%]
 3580    ADD   R2,R6,#handler_Name%
 3590    LDR   R3,[R6,#handler_SampleFrequency%]
 3600    LDR   R4,[R6,#handler_Type%]
 3610    LDR   R5,[R6,#handler_Volume%]
 3620
 3630    \ Now find next handler
 3640
 3650.swiHandlerInfoLoop%
 3660
 3670    ADD   R0,R0,#1
 3680    CMP   R0,#handlerMax%
 3690    MOVEQ R0,#0
 3700    BEQ   swiHandlerInfoExit%
 3710
 3720    ADD   R6,R6,#handlerTableLen%    \ Try next one
 3730    LDR   R7,[R6,#handler_Address%]  \ Does it exist?
 3740    CMP   R7,#0
 3750    BEQ   swiHandlerInfoLoop%        \ No, then try next one
 3760
 3770.swiHandlerInfoExit%
 3780
 3790    LDMIA R13!,{R6-R12,PC}^
 3800
 3810\ -----------
 3820
 3830.swiSampleRate%          \ Either set the current driver rate
 3840                         \ or set the rate for a particular handler
 3850                         \ On entry:
 3860                         \ R0 = 0 for set driver rate
 3870                         \    > 0 for handler number
 3880                         \ R1 = sample frequency required
 3890                         \      if 0 then use current rate
 3900                         \ On exit:
 3910                         \ R1 = actual sample rate
 3920                         \ R2 = sample period
 3930                         \ R3 = fractional step used get the required rate
 3940
 3950    STMDB R13!,{R4-R12,R14}
 3960
 3970]
 3980IF debug% THEN
 3990[OPT I%
 4000    SWI "XOS_WriteS"
 4010    EQUS "Sample rate"+CHR$(0):ALIGN
 4020    SWI "XOS_NewLine"
 4030]
 4040ENDIF
 4050[OPT I%
 4060
 4070
 4080    CMP   R0,#0
 4090    BNE   swiSampleRateDo%
 4100
 4110    \     Set driver rate
 4120
 4130    MOV   R0,R1              \ Move rate into R0
 4140    BL    newSampleRate%     \ Sets new rate across all handlers
 4150                             \ all registers preserved
 4160
 4170    LDR   R0,[R12,#work_SampleFrequency%]
 4180
 4190    BL    sampleRateFraction% \ Get fraction value with R0 = frequency
 4200                              \ return fraction in R0
 4210
 4220
 4230    B     swiSampleRateExit%
 4240
 4250
 4260.swiSampleRateDo%
 4270
 4280    \ Find handler
 4290
 4300    ADD   R2,R12,#work_handlerTable%
 4310    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4320
 4330    CMP   R0,#0                      \ If <0 then error
 4340    LDMLTIA R13!,{R4-R12,R14}
 4350    BLT   swiHandlerNumError1%
 4360
 4370    CMP   R0,#handlerMax%            \ If > max then error
 4380    LDMGEIA R13!,{R4-R12,R14}
 4390    BGE   swiHandlerNumError1%
 4400
 4410    MOV   R3,#handlerTableLen%
 4420    MLA   R6,R3,R0,R2
 4430
 4440    LDR   R2,[R6,#handler_Address%]   \ Does this handler exist?
 4450    CMP   R2,#0
 4460    LDMEQIA R13!,{R4-R12,R14}
 4470    BEQ   swiHandlerExistError1%       \ If not then exit
 4480
 4490    \   Get fraction
 4500
 4510    CMP   R1,#0
 4520    LDREQ R0,[R12,#work_SampleFrequency%]
 4530    MOVNE R0,R1
 4540    BL    sampleRateFraction%          \ Return fraction in R0
 4550
 4560    \  Store values in handler table
 4570
 4580    CMP   R1,#0
 4590    LDREQ R1,[R12,#work_SampleFrequency%]
 4600    STR   R1,[R6,#handler_SampleFrequency%]
 4610    STR   R0,[R6,#handler_Fraction%]
 4620
 4630.swiSampleRateExit%
 4640
 4650    MOV   R3,R0                         \ Set up return values
 4660    LDR   R1,[R12,#work_SampleFrequency%]
 4670    LDR   R2,[R12,#work_SamplePeriod%]
 4680
 4690    LDMIA R13!,{R4-R12,PC}^
 4700
 4710\ -----------
 4720
 4730.swiHandlerVolume%           \ Set a handler's volume
 4740                             \ On entry:
 4750                             \ R0 = handler number
 4760                             \ R1 = LR volume to set
 4770                             \ On exit:
 4780                             \ R1 = current volume
 4790
 4800    STMDB R13!,{R0,R2-R12,R14}
 4810
 4820]
 4830IF debug% THEN
 4840[OPT I%
 4850    SWI "XOS_WriteS"
 4860    EQUS "Handler Volume"+CHR$(0):ALIGN
 4870    SWI "XOS_NewLine"
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920
 4930
 4940    \ Find handler
 4950
 4960    ADD   R4,R12,#work_handlerTable%
 4970    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 4980
 4990    CMP   R0,#0                      \ If <0 then error
 5000    LDMLTIA R13!,{R0,R1,R3-R12,R14}
 5010    BLT   swiHandlerNumError1%
 5020
 5030    CMP   R0,#handlerMax%            \ If > max then error
 5040    LDMGEIA R13!,{R0,R1,R3-R12,R14}
 5050    BGE   swiHandlerNumError1%
 5060
 5070    MOV   R3,#handlerTableLen%
 5080    MLA   R6,R3,R0,R4
 5090
 5100    LDR   R4,[R6,#handler_Address%]   \ Does this handler exist?
 5110    CMP   R4,#0
 5120    LDMEQIA R13!,{R0,R1,R3-R12,R14}
 5130    BEQ   swiHandlerExistError1%       \ If not then exit
 5140
 5150    STR   R1,[R6,#handler_Volume%]     \ Set volume
 5160    MOV   R0,R6
 5170    BL    scaleHandlerVolume%          \ R0 = handler table entry ptr
 5180
 5190    LDR   R1,[R6,#handler_Volume%]     \ Read result
 5200
 5210    LDMIA R13!,{R0,R2-R12,PC}^
 5220
 5230\ -----------
 5240
 5250.swiHandlerSampleType%        \ Not in this version
 5260
 5270    STMDB R13!,{R0-R12,R14}
 5280
 5290]
 5300IF debug% THEN
 5310[OPT I%
 5320    SWI "XOS_WriteS"
 5330    EQUS "Handler sample type"+CHR$(0):ALIGN
 5340    SWI "XOS_NewLine"
 5350]
 5360ENDIF
 5370[OPT I%
 5380
 5390
 5400
 5410    LDMIA R13!,{R0-R12,PC}^
 5420
 5430\ -----------
 5440
 5450.swiHandlerPause%             \ Not in this version
 5460
 5470    STMDB R13!,{R0-R12,R14}
 5480]
 5490IF debug% THEN
 5500[OPT I%
 5510    SWI "XOS_WriteS"
 5520    EQUS "Handler pause"+CHR$(0):ALIGN
 5530    SWI "XOS_NewLine"
 5540]
 5550ENDIF
 5560[OPT I%
 5570
 5580
 5590
 5600    LDMIA R13!,{R0-R12,PC}^
 5610
 5620\ -----------
 5630
 5640.swiInstallDriver%  \ Install or make active a driver
 5650                    \ R0 = Pointer to driver table address
 5660                    \      or 1 = Linear
 5670                    \      or 2 = Log
 5680                    \ R1 = parameter to pass driver in R12 when called
 5690                    \ R2 = flags
 5700                    \ R3 = Volume
 5710
 5720    STMDB R13!,{R0-R12,R14}
 5730
 5740]
 5750IF debug% THEN
 5760[OPT I%
 5770    SWI "XOS_WriteS"
 5780    EQUS "Install driver"+CHR$(0):ALIGN
 5790    SWI "XOS_NewLine"
 5800]
 5810ENDIF
 5820[OPT I%
 5830
 5840    \ If R0 = 1 or 2 then Linear or Log
 5850    \ Otherwise regard this as a new driver
 5860
 5870    CMP   R0,#2
 5880    BGT   swiInstallDriverTable%
 5890
 5900    CMP   R0,#1
 5910    BNE   swiInstallDriverLog%
 5920
 5930    BL    installLinearDriver%
 5940
 5950    B     swiInstallDriverExit%
 5960
 5970.swiInstallDriverLog%
 5980
 5990]
 6000IF doLog% THEN
 6010[OPT I%
 6020
 6030    CMP   R0,#2
 6040    BLEQ  installLogDriver%
 6050
 6060]
 6070ENDIF
 6080[OPT I%
 6090
 6100    B     swiInstallDriverExit%
 6110
 6120
 6130.swiInstallDriverTable%
 6140
 6150    BL    installDriver%               \ Simply pass on to this routine
 6160
 6170
 6180.swiInstallDriverExit%
 6190
 6200    LDMIA R13!,{R0-R12,PC}^
 6210
 6220\ -----------
 6230
 6240.swiDriverNumError%
 6250    LDMIA R13!,{R0-R12,R14}
 6260.swiDriverNumError1%
 6270    ADR   R0,DriverNumMesg%
 6280    ORRS  PC,R14,#Overflow_Flag
 6290.DriverNumMesg%
 6300    EQUD  &1E6
 6310    EQUS  "Driver number out of range"
 6320    EQUB  0
 6330    ALIGN
 6340\
 6350
 6360.swiDriverExistError%
 6370    LDMIA R13!,{R0-R12,R14}
 6380.swiDriverExistError1%
 6390    ADR   R0,DriverExistMesg%
 6400    ORRS  PC,R14,#Overflow_Flag
 6410.DriverExistMesg%
 6420    EQUD  &1E6
 6430    EQUS  "Driver not installed"
 6440    EQUB  0
 6450    ALIGN
 6460\
 6470
 6480.swiRemoveDriverError%
 6490    LDMIA R13!,{R0-R12,R14}
 6500    ADR   R0,swiRemoveDriverMesg%
 6510    ORRS  PC,R14,#Overflow_Flag
 6520.swiRemoveDriverMesg%
 6530    EQUD  &1E6
 6540    EQUS  "Cannot remove the default driver"
 6550    EQUB  0
 6560    ALIGN
 6570\
 6580
 6590\ -----------
 6600
 6610.swiRemoveDriver%      \ Remove a driver from the driver table
 6620                       \ On entry:
 6630                       \   R0 = driver number
 6640                       \        cannot remove driver 1 as this is the default driver
 6650
 6660    STMDB R13!,{R0-R12,R14}
 6670
 6680]
 6690IF debug% THEN
 6700[OPT I%
 6710    SWI "XOS_WriteS"
 6720    EQUS "Remove Driver"+CHR$(0):ALIGN
 6730    SWI "XOS_NewLine"
 6740]
 6750ENDIF
 6760[OPT I%
 6770
 6780
 6790    \ First check parameter
 6800
 6810    ADD   R4,R12,#work_driverTable%
 6820    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 6830
 6840    CMP   R0,#0                      \ < 0
 6850    BLT   swiDriverNumError%
 6860
 6870    BEQ   swiRemoveDriverError%      \ = 0 , cannot remove the default driver
 6880
 6890    CMP   R0,#driverMax%             \ >= max
 6900    BGE   swiDriverNumError%
 6910
 6920    \ Does the driver exist?
 6930
 6940    MOV   R3,#driverTableLen%
 6950    MLA   R6,R3,R0,R4
 6960
 6970    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 6980    CMP   R4,#0
 6990    BEQ   swiDriverExistError%         \ If not then exit
 7000
 7010    \ is driver current
 7020
 7030    SUB   R4,R6,R12
 7040    LDR   R0,[R12,#work_currentDriver%]
 7050    CMP   R4,R0
 7060    BNE   swiRemoveDriverNext%
 7070
 7080    \ if it is then release it first
 7090
 7100    BL    releaseDriver%
 7110
 7120    \ and make sure at least the default driver is installed instead
 7130
 7140    MOV   R0,#1              \ Default driver
 7150    BL    swiInstallDriver%
 7160
 7170.swiRemoveDriverNext%
 7180
 7190    \ Now remove the driver entry
 7200
 7210    MOV   R0,#0
 7220    STR   R0,[R6,#driver_Address%]
 7230
 7240    LDMIA R13!,{R0-R12,PC}^
 7250
 7260\ -----------
 7270
 7280.swiDriverInfo%   \ R0 = driver number
 7290                  \ On exit:
 7300                  \ R0 = number of next available driver or 0 for none
 7310                  \ R1 = flags
 7320                  \ R2 = name
 7330                  \ R3 = Volume
 7340                  \ R4 = Overrun count
 7350
 7360    STMDB R13!,{R5-R12,R14}
 7370
 7380]
 7390IF debug% THEN
 7400[OPT I%
 7410    SWI "XOS_WriteS"
 7420    EQUS "Driver info"+CHR$(0):ALIGN
 7430    SWI "XOS_NewLine"
 7440]
 7450ENDIF
 7460[OPT I%
 7470
 7480
 7490
 7500    ADD   R4,R12,#work_driverTable%
 7510    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 7520
 7530    CMP   R0,#0                      \ < 0
 7540    LDMLTIA R13!,{R5-R12,R14}
 7550    BLT   swiDriverNumError1%
 7560
 7570    CMP   R0,#driverMax%             \ >= max
 7580    LDMGEIA R13!,{R5-R12,R14}
 7590    BGE   swiDriverNumError1%
 7600
 7610    \ Does the driver exist?
 7620
 7630    MOV   R3,#driverTableLen%
 7640    MLA   R6,R3,R0,R4
 7650
 7660    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 7670    CMP   R4,#0
 7680    LDMEQIA R13!,{R5-R12,R14}
 7690    BEQ   swiDriverExistError1%         \ If not then exit
 7700
 7710    \ Get driver values
 7720
 7730\    LDR   R1,[R6,#driver_Flags%]
 7740    LDR   R4,[R12,#work_currentDriver%] \ Set flag according to = current driver
 7750    ADD   R4,R4,R12
 7760    CMP   R4,R6
 7770    MOVEQ R1,#1        \ 1 if current
 7780    MOVNE R1,#0        \ 0 if not
 7790
 7800    ADD   R2,R6,#driver_Name%
 7810    LDR   R3,[R6,#driver_Volume%]
 7820
 7830    \ Now find next driver, if it exists
 7840
 7850.swiDriverInfoLoop%
 7860
 7870    ADD   R0,R0,#1
 7880    CMP   R0,#driverMax%
 7890    MOVEQ R0,#0
 7900    BEQ   swiDriverInfoExit%
 7910
 7920    ADD   R6,R6,#driverTableLen%    \ Try next one
 7930    LDR   R7,[R6,#driver_Address%]  \ Does it exist?
 7940    CMP   R7,#0
 7950    BEQ   swiDriverInfoLoop%        \ No, then try next one
 7960
 7970.swiDriverInfoExit%
 7980
 7990    LDR   R4,[R12,#work_callBack_Count%]
 8000
 8010    LDMIA R13!,{R5-R12,PC}^
 8020
 8030\ -----------
 8040
 8050.swiDriverVolume%            \ Set the volume for a driver
 8060                             \ On entry:
 8070                             \    R0 = driver number
 8080                             \    R1 = new volume
 8090                             \ On exit:
 8100                             \    R0 = current volume
 8110    STMDB R13!,{R1-R12,R14}
 8120
 8130]
 8140IF debug% THEN
 8150[OPT I%
 8160    SWI "XOS_WriteS"
 8170    EQUS "Driver volume"+CHR$(0):ALIGN
 8180    SWI "XOS_NewLine"
 8190]
 8200ENDIF
 8210[OPT I%
 8220
 8230
 8240    ADD   R4,R12,#work_driverTable%
 8250    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8260
 8270    CMP   R0,#0                      \ < 0
 8280    LDMLTIA R13!,{R1-R12,R14}
 8290    BLT   swiDriverNumError1%
 8300
 8310    CMP   R0,#driverMax%             \ >= max
 8320    LDMGEIA R13!,{R1-R12,R14}
 8330    BGE   swiDriverNumError1%
 8340
 8350    \ Does the driver exist?
 8360
 8370    MOV   R3,#driverTableLen%
 8380    MLA   R6,R3,R0,R4
 8390
 8400    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 8410    CMP   R4,#0
 8420    LDMEQIA R13!,{R1-R12,R14}
 8430    BEQ   swiDriverExistError1%         \ If not then exit
 8440
 8450    MOV   R0,R1      \ Volume
 8460    MOV   R1,R6      \ Table address
 8470    BL    driverVolume%                 \ Set driver volume to R0
 8480
 8490    \ Note that when the driver's volume changes, all handler scaled
 8500    \ volumes may need to be reset
 8510
 8520    LDR   R0,[R12,#work_currentDriver%] \ Is this driver current?
 8530    ADD   R0,R0,R12
 8540    CMP   R0,R6
 8550
 8560    BLEQ  scaleAllHandlerVolumes%       \ If so scale all volumes
 8570
 8580    LDR   R0,[R6,#driver_Volume%]       \ Return volume
 8590
 8600    LDMIA R13!,{R1-R12,PC}^
 8610
 8620\ ----------------
 8630
 8640.swiDriverMixer%             \ Set or read the mixer for a driver
 8650                             \ On entry:
 8660                             \    R0 = driver number
 8670                             \    R1 = function   0 = read, 1 = set
 8680                             \    R2 = mixer number
 8690                             \    R3 = value if set
 8700                             \ On exit:
 8710                             \    R0 preserved
 8720                             \    R1 = no of mixers
 8730                             \    R2 = value
 8740                             \    R3 = name
 8750
 8760    STMDB R13!,{R0,R4-R12,R14}
 8770
 8780]
 8790IF debug% THEN
 8800[OPT I%
 8810    SWI "XOS_WriteS"
 8820    EQUS "Driver mixer"+CHR$(0):ALIGN
 8830    SWI "XOS_NewLine"
 8840]
 8850ENDIF
 8860[OPT I%
 8870
 8880
 8890
 8900    ADD   R4,R12,#work_driverTable%
 8910    SUB   R0,R0,#1                   \ 1-10 becomes 0-9
 8920
 8930    CMP   R0,#0                      \ < 0
 8940    LDMLTIA R13!,{R0,R4-R12,R14}
 8950    BLT   swiDriverNumError1%
 8960
 8970    CMP   R0,#driverMax%             \ >= max
 8980    LDMGEIA R13!,{R0,R4-R12,R14}
 8990    BGE   swiDriverNumError1%
 9000
 9010    \ Does the driver exist?
 9020
 9030    MOV   R3,#driverTableLen%
 9040    MLA   R6,R3,R0,R4
 9050
 9060    LDR   R4,[R6,#driver_Address%]     \ Does this handler exist?
 9070    CMP   R4,#0
 9080    LDMEQIA R13!,{R1-R12,R14}
 9090    BEQ   swiDriverExistError1%         \ If not then exit
 9100
 9110    MOV   R0,R1         \ Function code
 9120    MOV   R1,R2         \ Mixer number
 9130    MOV   R2,R3         \ Value
 9140    MOV   R3,R6         \ Driver table pointer
 9150
 9160    BL    driverMixer%
 9170
 9180
 9190    LDMIA R13!,{R0,R4-R12,PC}^
 9200]
 9210ENDPROC
