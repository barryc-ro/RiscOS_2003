   20The driver will typically be the 16 bit DMA handler with all parameters
   30set as required, or the log driver for 8 bit support.
   40If it is the 8 bit driver then there is some conversion required to set the
   50parameters correctly.
   60This is indicated by passing a call address in the driver block which would
   70otherwise be 0.
   90DEFPROCDrivers
  100LOCAL er$,debug%
  110er$="Drivers"
  120debug%=FALSE
  130PRINT "PROCDrivers"
  140[OPT I%
  160\ -------------------------------- Driver routines ---------------------------
  180.installDefaultDriver%   \  The default driver will either be (in order of preference)
  190                         \      Sound_LinearHandler
  200                         \   or Sound_ChannelHandler
  220                         \  This routine looks to see what is available and installs
  230                         \  the appropriate driver.
  250    STMDB R13!,{R14}
  270    \ First see if Sound_LinearHandler exists
  290    \ This rely's on the fact that the old SoundDMA module will respond to all
  300    \ SWI's outside it's range with a 0
  310    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on
  330    MOV   R0,#0
  340    SWI   Sound_Mode%    \  Check configured for 16 Bit support
  360]
  370IF debug% THEN
  380[OPT I%
  390    SWI "XOS_WriteS"
  400    EQUS "Sound mode = "+CHR$(0):ALIGN
  410    MOV  R10,R0
  420    BL   printR10
  430]
  440ENDIF
  450[OPT I%
  470    CMP   R0,#0          \ R0 = 1 If 16 bit support is on
  490    MOVEQ R1,#1  \ Log
  500    MOVNE R1,#2  \ Linear
  520    STR   R1,[R12,#work_currentDriver%]
  540    \ BLEQ  installLogDriver%
  550    BLNE  installLinearDriver%
  570    LDMIA R13!,{PC}^
  590\ -----------
  610.installDriver%     \ Install driver
  620                    \ R0 = Pointer to driver table
  630                    \ R1 = parameter to pass driver in R12 when called
  640                    \ R2 = flags
  650                    \ R3 = Driver name
  670    STMDB R13!,{R0-R6,R14}
  690    BL    releaseDriver%     \ release the currently active driver
  710    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table
  730    STR   R0,[R6,#driver_Address%]   \ Table address
  740    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
  750    STR   R2,[R6,#driver_Flags%]
  760    STR   R3,[R6,#driver_Name%]
  780    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
  790    STR   R0,[R6,#driver_Volume%]
  810    BL    driverInitialise% \ Initialise this driver
  830    LDR   R0,[R6,#driver_Volume%]
  840    MOV   R1,R6             \ Driver table
  850    BL    driverVolume%     \ Initialise driver volume
  870    LDMIA R13!,{R0-R6,PC}
  880\
  900.installDriverError%
  910   LDMIA R13!,{R0-R5,R14}
  920   ADR   R0,installDriverErrMesg%
  930   ORRS  PC,R14,#Overflow_Flag
  940\
  950.installDriverErrMesg%
  960    EQUD  &1E6
  970    EQUS  "Cannot install driver"
  980    EQUB  0
  990    ALIGN
 1000\
 1020\ -----------
 1040.driverInitialise%    \ Initialise a new driver
 1050                      \ R0 = driver table slot
 1060                      \ Return with R0 = 0 if failed
 1080    STMDB R13!,{R1-R12,R14}
 1100    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1120    LDR   R0,[R6,#driver_Address%]
 1130    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1150    BL    clearCallBackBuffer%
 1170    BL    getFillR0%
 1180    \ ADR   R0,fill%   \ Main fill call address
 1200    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1210    STMDB R13!,{R12}                    \ Stack R12
 1220    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1230    STMDB R13!,{PC}                     \ Put return address on the stack
 1240    MOV   PC,R2                         \ And call driver install entry
 1250    MOV   R0,R0
 1260    LDMIA R13!,{R12}                    \ Retrieve R12
 1280    CMP   R0,#0  \ = 0 if install failed
 1300    MOVNE R0,#0
 1310    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions
 1330    BL    startSound%                   \ Make sure that sound is active
 1350    LDMIA R13!,{R1-R12,PC}
 1370\ ------------
 1390.driverCheck%   \ Call initialise to make sure that the current driver is still active
 1410    STMDB R13!,{R0-R12,R14}
 1430    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1440    LDR   R0,[R6,#driver_Address%]
 1460    CMP   R0,#0                          \ Is there a driver installed?
 1470    BEQ   driverCheckExit%
 1490    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1510    BL    getFillR0%
 1520    \ ADR   R0,fill%                    \ R0 = Handler address
 1530    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1540    STMDB R13!,{R12}                    \ Stack R12
 1550    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1560    STMDB R13!,{PC}                     \ Put return address on the stack
 1570    MOV   PC,R2                         \ And call driver install entry
 1580    MOV   R0,R0
 1590    LDMIA R13!,{R12}                    \ Retrieve R12
 1610    MOV   R0,#0
 1620    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
 1640.driverCheckExit%
 1660    LDMIA R13!,{R0-R12,PC}^
 1690\-------------
 1710.releaseDriver%
 1730    STMDB R13!,{R0-R12,R14}
 1750    BL    stopSound%
 1770    ADD   R0,R12,#work_driverTable%    \ driver Table slot
 1780    LDR   R1,[R0,#driver_Address%]
 1800    CMP   R1,#0
 1810    BEQ   releaseDriverExit%
 1830    LDR   R1,[R1,#driverEntry_Remove%]
 1840    STMDB R13!,{R12}                     \ Stack R12
 1850    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
 1860    STMDB R13!,{PC}                      \ Stack return address
 1870    MOV   PC,R1                          \ Call driver, no other parameters
 1880    MOV   R0,R0
 1890    LDMIA R13!,{R12}                     \ Retrieve R12
 1910.releaseDriverExit%
 1930    LDMIA R13!,{R0-R12,PC}
 1950\ ----------------
 1970.driverSampleRate%  \ Call driver sample rate entry
 1980                    \ On entry:
 1990                    \ R0 = 0 to read
 2000                    \    > 0 for sample frequency required
 2010                    \ On exit:
 2020                    \ R0 = current frequency
 2040    STMDB R13!,{R14}
 2060    \ Get or set current frequency
 2080    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2090    LDR   R2,[R1,#driver_Address%]
 2110    CMP   R2,#0                 \ Return 0 for failed
 2120    MOVEQ R0,#0
 2130    BEQ   driverSampleRateExit%
 2150    LDR   R2,[R1,#driver_Address%]
 2160    LDR   R2,[R2,#driverEntry_SampleRate%]
 2170    STMDB R13!,{R12}                       \ Stack R12
 2180    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2190    STMDB R13!,{PC}                        \ Stack return address
 2200    MOV   PC,R2                            \ Call driver, no other parameters
 2210    MOV   R0,R0
 2220    LDMIA R13!,{R12}                       \ Retrieve R12
 2240    \  R0 = current frequency
 2260.driverSampleRateExit%
 2280    LDMIA R13!,{PC}
 2310\ ----------
 2330.driverVolume%  \ Set the new volume for a driver
 2340                \ On entry:
 2350                \   R0 = new LR volume
 2360                \   R1 = driver table
 2370                \ On exit:
 2380                \   R0 = volume scaling required by handler to achieve this volume
 2390                \   So if driver cannot scale volume then R0 = entry value and handler
 2400                \   will have to do all the work
 2410                \   If driver can scale then typically it will return &FFFFFFFF to
 2420                \   tell handler not to scale volume at all
 2440    STMDB R13!,{R1-R12,R14}
 2460    \ Get or set current volume
 2480    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2490    LDR   R2,[R1,#driver_Address%]
 2510    CMP   R2,#0
 2520    BEQ   driverVolumeExit%
 2540    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
 2550    CMP   R2,#0
 2560    STR   R0,[R1,#driver_Volume%]          \ Store it
 2570    BEQ   driverVolumeStore%               \ Return with R0 as set
 2590    STMDB R13!,{R1,R12}                       \ Stack R12
 2600    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2610    STMDB R13!,{PC}                        \ Stack return address
 2620    MOV   PC,R2                            \ Call driver, no other parameters
 2630    MOV   R0,R0
 2640    LDMIA R13!,{R1,R12}                       \ Retrieve R12
 2660.driverVolumeStore%
 2680]
 2690IF debug% THEN
 2700[OPT I%
 2710    SWI "XOS_WriteS"
 2720    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
 2730    MOV R10,R0
 2740    BL  printR10
 2750]
 2760ENDIF
 2770[OPT I%
 2790    \  R0 = actual volume
 2810    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers
 2830.driverVolumeExit%
 2850    LDMIA R13!,{R1-R12,PC}
 2880\ -----------
 2900.driverMixer%  \ Call driver's mixer entry
 2910               \ On entry:
 2920               \    R0 = Function code,  0 = read,  1 = set
 2930               \    R1 = mixer number
 2940               \    R2 = value if to set
 2950               \    R3 = driver pointer
 2960               \ On exit:
 2970               \    R1 = number of mixers
 2980               \    R2 = current value
 2990               \    R3 = mixer name
 3010    STMDB R13!,{R4-R12,R14}
 3030    CMP   R3,#0
 3040    BEQ   driverMixerExit%
 3060    LDR   R4,[R3,#driver_Address%]
 3070    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
 3080    CMP   R4,#0
 3090    BEQ   driverMixerExit%                 \ No mixer entry
 3110    STMDB R13!,{R12}                       \ Stack R12
 3120    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 3130    STMDB R13!,{PC}                        \ Stack return address
 3140    MOV   PC,R4                            \ Call driver, no other parameters
 3150    MOV   R0,R0
 3160    LDMIA R13!,{R12}                       \ Retrieve R12
 3180.driverMixerExit%
 3200    LDMIA R13!,{R4-R12,PC}
 3220]
 3230ENDPROC
