
The driver will typically be the 16 bit DMA handler with all parameters
set as required, or the log driver for 8 bit support.
If it is the 8 bit driver then there is some conversion required to set the
parameters correctly.
This is indicated by passing a call address in the driver block which would
otherwise be 0.

DEFPROCDrivers
LOCAL er$,debug%
er$="Drivers"
debug%=FALSE
PRINT "PROCDrivers"
[OPT I%

\ -------------------------------- Driver routines ---------------------------

.installDefaultDriver%   \  The default driver will either be (in order of preference)
                         \      Sound_LinearHandler
                         \   or Sound_ChannelHandler

                         \  This routine looks to see what is available and installs
                         \  the appropriate driver.

    STMDB R13!,{R14}

    \ First see if Sound_LinearHandler exists

    \ This relies on the fact that the old SoundDMA module will respond to all
    \ SWI's outside its range with a 0
    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on

    MOV   R0,#0
    SWI   Sound_Mode%    \  Check configured for 16 Bit support

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Sound mode = "+CHR$(0):ALIGN
    MOV  R10,R0
    BL   printR10
]
ENDIF
[OPT I%

    CMP   R0,#0          \ R0 = 1 If 16 bit support is on

    MOVEQ R1,#1  \ Log
    MOVNE R1,#2  \ Linear

    STR   R1,[R12,#work_currentDriver%]

]
IF doLog% THEN
[OPT I%

    BNE   installDefaultDriverNotLog%
    BLEQ  installLogDriver%
    B     installDefaultDriverExit%
.installDefaultDriverNotLog%
]
ENDIF
[OPT I%

    BLNE  installLinearDriver%

.installDefaultDriverExit%
    LDMIA R13!,{PC}

\ -----------

.installDriver%     \ Install driver
                    \ R0 = Pointer to driver table
                    \ R1 = parameter to pass driver in R12 when called
                    \ R2 = flags
                    \ R3 = Driver name

    STMDB R13!,{R0-R6,R14}

    BL    releaseDriver%     \ release the currently active driver

    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table

    STR   R0,[R6,#driver_Address%]   \ Table address
    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
    STR   R2,[R6,#driver_Flags%]
    STR   R3,[R6,#driver_Name%]

    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
    STR   R0,[R6,#driver_Volume%]

    BL    driverInitialise% \ Initialise this driver

    LDR   R0,[R6,#driver_Volume%]
    MOV   R1,R6             \ Driver table
    BL    driverVolume%     \ Initialise driver volume

    LDMIA R13!,{R0-R6,PC}
\


\ -----------

.driverInitialise%    \ Initialise a new driver
                      \ R0 = driver table slot
                      \ Return with R0 = 0 if failed

    STMDB R13!,{R1-R12,R14}

    ADD   R6,R12,#work_driverTable%    \ driver Table slot

    LDR   R0,[R6,#driver_Address%]
    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address

    BL    clearCallBackBuffer%

    BL    getFillR0%
    \ ADR   R0,fill%   \ Main fill call address

    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
    STMDB R13!,{R12}                    \ Stack R12
    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
    STMDB R13!,{PC}                     \ Put return address on the stack
    MOV   PC,R2                         \ And call driver install entry
    MOV   R0,R0
    LDMIA R13!,{R12}                    \ Retrieve R12

    CMP   R0,#0  \ = 0 if install failed

    MOVNE R0,#0
    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions

    BL    startSound%                   \ Make sure that sound is active

    LDMIA R13!,{R1-R12,PC}

\ ------------

.driverCheck%   \ Call initialise to make sure that the current driver is still active

    STMDB R13!,{R0-R12,R14}

    ADD   R6,R12,#work_driverTable%    \ driver Table slot
    LDR   R0,[R6,#driver_Address%]

    CMP   R0,#0                          \ Is there a driver installed?
    BEQ   driverCheckExit%

    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address

    BL    getFillR0%
    \ ADR   R0,fill%                    \ R0 = Handler address
    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
    STMDB R13!,{R12}                    \ Stack R12
    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
    STMDB R13!,{PC}                     \ Put return address on the stack
    MOV   PC,R2                         \ And call driver install entry
    MOV   R0,R0
    LDMIA R13!,{R12}                    \ Retrieve R12

    MOV   R0,#0
    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag

.driverCheckExit%

    CMP   PC,PC                         \ also clears V in 32-bit mode
    LDMEQIA R13!,{R0-R12,PC}            \ 32-bit SWI exit; NZC corrupted, V clear
    LDMIA R13!,{R0-R12,PC}^             \ 26-bit SWI exit; NZC preserved, V clear


\-------------

.releaseDriver%

    STMDB R13!,{R0-R12,R14}

    BL    stopSound%

    ADD   R0,R12,#work_driverTable%    \ driver Table slot
    LDR   R1,[R0,#driver_Address%]

    CMP   R1,#0
    BEQ   releaseDriverExit%

    LDR   R1,[R1,#driverEntry_Remove%]
    STMDB R13!,{R12}                     \ Stack R12
    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
    STMDB R13!,{PC}                      \ Stack return address
    MOV   PC,R1                          \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                     \ Retrieve R12

.releaseDriverExit%

    LDMIA R13!,{R0-R12,PC}

\ ----------------

.driverSampleRate%  \ Call driver sample rate entry
                    \ On entry:
                    \ R0 = 0 to read
                    \    > 0 for sample frequency required
                    \ On exit:
                    \ R0 = current frequency

    STMDB R13!,{R14}

    \ Get or set current frequency

    ADD   R1,R12,#work_driverTable%    \ driver Table slot
    LDR   R2,[R1,#driver_Address%]

    CMP   R2,#0                 \ Return 0 for failed
    MOVEQ R0,#0
    BEQ   driverSampleRateExit%

    LDR   R2,[R1,#driver_Address%]
    LDR   R2,[R2,#driverEntry_SampleRate%]
    STMDB R13!,{R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R2                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                       \ Retrieve R12

    \  R0 = current frequency

.driverSampleRateExit%

    LDMIA R13!,{PC}


\ ----------

.driverVolume%  \ Set the new volume for a driver
                \ On entry:
                \   R0 = new LR volume
                \   R1 = driver table
                \ On exit:
                \   R0 = volume scaling required by handler to achieve this volume
                \   So if driver cannot scale volume then R0 = entry value and handler
                \   will have to do all the work
                \   If driver can scale then typically it will return &FFFFFFFF to
                \   tell handler not to scale volume at all

    STMDB R13!,{R1-R12,R14}

    \ Get or set current volume

    ADD   R1,R12,#work_driverTable%    \ driver Table slot
    LDR   R2,[R1,#driver_Address%]

    CMP   R2,#0
    BEQ   driverVolumeExit%

    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
    CMP   R2,#0
    STR   R0,[R1,#driver_Volume%]          \ Store it
    BEQ   driverVolumeStore%               \ Return with R0 as set

    STMDB R13!,{R1,R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R2                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R1,R12}                       \ Retrieve R12

.driverVolumeStore%

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
    MOV R10,R0
    BL  printR10
]
ENDIF
[OPT I%

    \  R0 = actual volume

    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers

.driverVolumeExit%

    LDMIA R13!,{R1-R12,PC}


\ -----------

.driverMixer%  \ Call driver's mixer entry
               \ On entry:
               \    R0 = Function code,  0 = read,  1 = set
               \    R1 = mixer number
               \    R2 = value if to set
               \    R3 = driver pointer
               \ On exit:
               \    R1 = number of mixers
               \    R2 = current value
               \    R3 = mixer name

    STMDB R13!,{R4-R12,R14}

    CMP   R3,#0
    BEQ   driverMixerExit%

    LDR   R4,[R3,#driver_Address%]
    LDR   R4,[R4,#driverEntry_Mixer%]      \ There may not be an entry
    CMP   R4,#0
    BEQ   driverMixerExit%                 \ No mixer entry

    STMDB R13!,{R12}                       \ Stack R12
    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
    STMDB R13!,{PC}                        \ Stack return address
    MOV   PC,R4                            \ Call driver, no other parameters
    MOV   R0,R0
    LDMIA R13!,{R12}                       \ Retrieve R12

.driverMixerExit%

    LDMIA R13!,{R4-R12,PC}

]
ENDPROC
