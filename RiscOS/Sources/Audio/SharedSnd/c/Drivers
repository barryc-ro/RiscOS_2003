   10
   20The driver will typically be the 16 bit DMA handler with all parameters
   30set as required, or the log driver for 8 bit support.
   40If it is the 8 bit driver then there is some conversion required to set the
   50parameters correctly.
   60This is indicated by passing a call address in the driver block which would
   70otherwise be 0.
   80
   90DEFPROCDrivers
  100LOCAL er$,debug%
  110er$="Drivers"
  120debug%=FALSE
  130PRINT "PROCDrivers"
  140[OPT I%
  150
  160\ -------------------------------- Driver routines ---------------------------
  170
  180.installDefaultDriver%   \  The default driver will either be (in order of preference)
  190                         \      Sound_LinearHandler
  200                         \   or Sound_ChannelHandler
  210
  220                         \  This routine looks to see what is available and installs
  230                         \  the appropriate driver.
  240
  250    STMDB R13!,{R14}
  260
  270    \ First see if Sound_LinearHandler exists
  280
  290    \ This rely's on the fact that the old SoundDMA module will respond to all
  300    \ SWI's outside it's range with a 0
  310    \ but the 16 bit SoundDMA will respond with a 1 if 16 bit is on
  320
  330    MOV   R0,#0
  340    SWI   Sound_Mode%    \  Check configured for 16 Bit support
  350
  360]
  370IF debug% THEN
  380[OPT I%
  390    SWI "XOS_WriteS"
  400    EQUS "Sound mode = "+CHR$(0):ALIGN
  410    MOV  R10,R0
  420    BL   printR10
  430]
  440ENDIF
  450[OPT I%
  460
  470    CMP   R0,#0          \ R0 = 1 If 16 bit support is on
  480
  490    MOVEQ R1,#1  \ Log
  500    MOVNE R1,#2  \ Linear
  510
  520    STR   R1,[R12,#work_currentDriver%]
  530
  540]
  550IF doLog% THEN
  560[OPT I%
  570
  580    BLEQ  installLogDriver%
  590]
  600ENDIF
  610[OPT I%
  620
  630    BLNE  installLinearDriver%
  640
  650    LDMIA R13!,{PC}^
  660
  670\ -----------
  680
  690.installDriver%     \ Install driver
  700                    \ R0 = Pointer to driver table
  710                    \ R1 = parameter to pass driver in R12 when called
  720                    \ R2 = flags
  730                    \ R3 = Driver name
  740
  750    STMDB R13!,{R0-R6,R14}
  760
  770    BL    releaseDriver%     \ release the currently active driver
  780
  790    ADD   R6,R12,#work_driverTable%  \ Get pointer to driver table
  800
  810    STR   R0,[R6,#driver_Address%]   \ Table address
  820    STR   R1,[R6,#driver_Parameter%] \ Driver R12 parameter
  830    STR   R2,[R6,#driver_Flags%]
  840    STR   R3,[R6,#driver_Name%]
  850
  860    MVN   R0,#0                      \ Initialise driver volume to LR = &FFFF FFFF
  870    STR   R0,[R6,#driver_Volume%]
  880
  890    BL    driverInitialise% \ Initialise this driver
  900
  910    LDR   R0,[R6,#driver_Volume%]
  920    MOV   R1,R6             \ Driver table
  930    BL    driverVolume%     \ Initialise driver volume
  940
  950    LDMIA R13!,{R0-R6,PC}
  960\
  970
  980.installDriverError%
  990   LDMIA R13!,{R0-R5,R14}
 1000   ADR   R0,installDriverErrMesg%
 1010   ORRS  PC,R14,#Overflow_Flag
 1020\
 1030.installDriverErrMesg%
 1040    EQUD  &1E6
 1050    EQUS  "Cannot install driver"
 1060    EQUB  0
 1070    ALIGN
 1080\
 1090
 1100\ -----------
 1110
 1120.driverInitialise%    \ Initialise a new driver
 1130                      \ R0 = driver table slot
 1140                      \ Return with R0 = 0 if failed
 1150
 1160    STMDB R13!,{R1-R12,R14}
 1170
 1180    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1190
 1200    LDR   R0,[R6,#driver_Address%]
 1210    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1220
 1230    BL    clearCallBackBuffer%
 1240
 1250    BL    getFillR0%
 1260    \ ADR   R0,fill%   \ Main fill call address
 1270
 1280    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1290    STMDB R13!,{R12}                    \ Stack R12
 1300    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1310    STMDB R13!,{PC}                     \ Put return address on the stack
 1320    MOV   PC,R2                         \ And call driver install entry
 1330    MOV   R0,R0
 1340    LDMIA R13!,{R12}                    \ Retrieve R12
 1350
 1360    CMP   R0,#0  \ = 0 if install failed
 1370
 1380    MOVNE R0,#0
 1390    BLNE  newSampleRate%                \ Get rate and set up sample period & fractions
 1400
 1410    BL    startSound%                   \ Make sure that sound is active
 1420
 1430    LDMIA R13!,{R1-R12,PC}
 1440
 1450\ ------------
 1460
 1470.driverCheck%   \ Call initialise to make sure that the current driver is still active
 1480
 1490    STMDB R13!,{R0-R12,R14}
 1500
 1510    ADD   R6,R12,#work_driverTable%    \ driver Table slot
 1520    LDR   R0,[R6,#driver_Address%]
 1530
 1540    CMP   R0,#0                          \ Is there a driver installed?
 1550    BEQ   driverCheckExit%
 1560
 1570    LDR   R2,[R0,#driverEntry_Install%] \ R2 = Call address
 1580
 1590    BL    getFillR0%
 1600    \ ADR   R0,fill%                    \ R0 = Handler address
 1610    LDR   R1,[R12,#work_privateWord%]   \ R1 = parameter
 1620    STMDB R13!,{R12}                    \ Stack R12
 1630    LDR   R12,[R6,#driver_Parameter%]   \ Called with R12 = parameter
 1640    STMDB R13!,{PC}                     \ Put return address on the stack
 1650    MOV   PC,R2                         \ And call driver install entry
 1660    MOV   R0,R0
 1670    LDMIA R13!,{R12}                    \ Retrieve R12
 1680
 1690    MOV   R0,#0
 1700    STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
 1710
 1720.driverCheckExit%
 1730
 1740    LDMIA R13!,{R0-R12,PC}^
 1750
 1760
 1770\-------------
 1780
 1790.releaseDriver%
 1800
 1810    STMDB R13!,{R0-R12,R14}
 1820
 1830    BL    stopSound%
 1840
 1850    ADD   R0,R12,#work_driverTable%    \ driver Table slot
 1860    LDR   R1,[R0,#driver_Address%]
 1870
 1880    CMP   R1,#0
 1890    BEQ   releaseDriverExit%
 1900
 1910    LDR   R1,[R1,#driverEntry_Remove%]
 1920    STMDB R13!,{R12}                     \ Stack R12
 1930    LDR   R12,[R0,#driver_Parameter%]    \ Get driver's R12
 1940    STMDB R13!,{PC}                      \ Stack return address
 1950    MOV   PC,R1                          \ Call driver, no other parameters
 1960    MOV   R0,R0
 1970    LDMIA R13!,{R12}                     \ Retrieve R12
 1980
 1990.releaseDriverExit%
 2000
 2010    LDMIA R13!,{R0-R12,PC}
 2020
 2030\ ----------------
 2040
 2050.driverSampleRate%  \ Call driver sample rate entry
 2060                    \ On entry:
 2070                    \ R0 = 0 to read
 2080                    \    > 0 for sample frequency required
 2090                    \ On exit:
 2100                    \ R0 = current frequency
 2110
 2120    STMDB R13!,{R14}
 2130
 2140    \ Get or set current frequency
 2150
 2160    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2170    LDR   R2,[R1,#driver_Address%]
 2180
 2190    CMP   R2,#0                 \ Return 0 for failed
 2200    MOVEQ R0,#0
 2210    BEQ   driverSampleRateExit%
 2220
 2230    LDR   R2,[R1,#driver_Address%]
 2240    LDR   R2,[R2,#driverEntry_SampleRate%]
 2250    STMDB R13!,{R12}                       \ Stack R12
 2260    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2270    STMDB R13!,{PC}                        \ Stack return address
 2280    MOV   PC,R2                            \ Call driver, no other parameters
 2290    MOV   R0,R0
 2300    LDMIA R13!,{R12}                       \ Retrieve R12
 2310
 2320    \  R0 = current frequency
 2330
 2340.driverSampleRateExit%
 2350
 2360    LDMIA R13!,{PC}
 2370
 2380
 2390\ ----------
 2400
 2410.driverVolume%  \ Set the new volume for a driver
 2420                \ On entry:
 2430                \   R0 = new LR volume
 2440                \   R1 = driver table
 2450                \ On exit:
 2460                \   R0 = volume scaling required by handler to achieve this volume
 2470                \   So if driver cannot scale volume then R0 = entry value and handler
 2480                \   will have to do all the work
 2490                \   If driver can scale then typically it will return &FFFFFFFF to
 2500                \   tell handler not to scale volume at all
 2510
 2520    STMDB R13!,{R1-R12,R14}
 2530
 2540    \ Get or set current volume
 2550
 2560    ADD   R1,R12,#work_driverTable%    \ driver Table slot
 2570    LDR   R2,[R1,#driver_Address%]
 2580
 2590    CMP   R2,#0
 2600    BEQ   driverVolumeExit%
 2610
 2620    LDR   R2,[R2,#driverEntry_Volume%]     \ There may not be an entry
 2630    CMP   R2,#0
 2640    STR   R0,[R1,#driver_Volume%]          \ Store it
 2650    BEQ   driverVolumeStore%               \ Return with R0 as set
 2660
 2670    STMDB R13!,{R1,R12}                       \ Stack R12
 2680    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 2690    STMDB R13!,{PC}                        \ Stack return address
 2700    MOV   PC,R2                            \ Call driver, no other parameters
 2710    MOV   R0,R0
 2720    LDMIA R13!,{R1,R12}                       \ Retrieve R12
 2730
 2740.driverVolumeStore%
 2750
 2760]
 2770IF debug% THEN
 2780[OPT I%
 2790    SWI "XOS_WriteS"
 2800    EQUS "Store scaled driver volume: "+CHR$(0):ALIGN
 2810    MOV R10,R0
 2820    BL  printR10
 2830]
 2840ENDIF
 2850[OPT I%
 2860
 2870    \  R0 = actual volume
 2880
 2890    STR   R0,[R1,#driver_VolumeScaled%]    \ The volume to use when scaling handlers
 2900
 2910.driverVolumeExit%
 2920
 2930    LDMIA R13!,{R1-R12,PC}
 2940
 2950
 2960\ -----------
 2970
 2980.driverMixer%  \ Call driver's mixer entry
 2990               \ On entry:
 3000               \    R0 = Function code,  0 = read,  1 = set
 3010               \    R1 = mixer number
 3020               \    R2 = value if to set
 3030               \    R3 = driver pointer
 3040               \ On exit:
 3050               \    R1 = number of mixers
 3060               \    R2 = current value
 3070               \    R3 = mixer name
 3080
 3090    STMDB R13!,{R4-R12,R14}
 3100
 3110    CMP   R3,#0
 3120    BEQ   driverMixerExit%
 3130
 3140    LDR   R4,[R3,#driver_Address%]
 3150    LDR   R4,[R4,#driverEntry_Volume%]     \ There may not be an entry
 3160    CMP   R4,#0
 3170    BEQ   driverMixerExit%                 \ No mixer entry
 3180
 3190    STMDB R13!,{R12}                       \ Stack R12
 3200    LDR   R12,[R1,#driver_Parameter%]      \ Get driver's R12
 3210    STMDB R13!,{PC}                        \ Stack return address
 3220    MOV   PC,R4                            \ Call driver, no other parameters
 3230    MOV   R0,R0
 3240    LDMIA R13!,{R12}                       \ Retrieve R12
 3250
 3260.driverMixerExit%
 3270
 3280    LDMIA R13!,{R4-R12,PC}
 3290
 3300]
 3310ENDPROC
