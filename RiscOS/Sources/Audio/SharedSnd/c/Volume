   10DEFPROCVolume
   20LOCAL er$,debug%
   30er$="Volume"
   40debug%=FALSE
   50PRINT "PROCVolume"
   60[OPT I%
   80\ -------------------------------- Volume routines ------------------------
  110.scaleAllHandlerVolumes%  \ Set the actual volumes for all handlers
  120                          \ typically called after driver volume has changed
  130                          \ should also be called when System volume has changed
  150   STMDB R13!,{R0-R12,R14}
  170   ADD   R0,R12,#work_handlerTable%   \ Get handler table
  180   MOV   R6,#handlerMax%              \ Count
  200.scaleAllHandlerVolumesLoop%
  220   LDR   R1,[R0,#handler_Address%]    \ Is there a driver here?
  230   CMP   R1,#0
  240   BLNE  scaleHandlerVolume%
  260   ADD   R0,R0,#handlerTableLen%
  270   SUBS  R6,R6,#1
  280   BNE   scaleAllHandlerVolumesLoop%
  300   LDMIA R13!,{R0-R12,PC}
  320\ ----------
  340.scaleHandlerVolume%  \ Using all available volume info
  350                      \ set up the real volume for the handler
  360                      \ as passed to fill routine
  370                      \ On entry R0 = handler table
  390   STMDB R13!,{R0-R5,R14}
  410   LDR   R4,[R0,#handler_Volume%]
  430   \ Scale according to R0 = Driver volume (if driver cannot use it)
  440   \                    R4 = Handler volume
  460   MOV   R5,R0         \ Store handler address
  480   \ Get the driver scaled volume
  500   ADD   R0,R12,#work_driverTable%
  510   LDR   R1,[R0,#driver_Address%]
  520   CMP   R1,#0                        \ Check driver exists
  530   BEQ   scaleHandlerVolumeStore%     \ Don't change volume if no driver
  550   LDR   R0,[R0,#driver_VolumeScaled%]   \ Driver scaled volume
  560]
  570IF debug% THEN
  580[OPT I%
  590    SWI "XOS_WriteS"
  600    EQUS "Driver volume = "+CHR$(0):ALIGN
  610    MOV  R10,R0
  620    BL   printR10
  630]
  640ENDIF
  650[OPT I%
  670   MOV   R1,#0
  680   SUB   R1,R1,#1
  690   CMP   R0,R1                   \ No driver scaling required
  710   BEQ   scaleHandlerVolumeStore%
  730   \     R0 = LR, R4 = LR, Scale accordingly....
  750   MOV   R1,R0,LSR #16  \ R1 = L1
  760   MOV   R0,R0,LSL #16
  770   MOV   R0,R0,LSR #16  \ R0 = R1
  790   MOV   R3,R4,LSR #16  \ R3 = L2
  800   MOV   R4,R4,LSL #16
  810   MOV   R4,R4,LSR #16  \ R4 = R2
  830   MUL   R2,R0,R4
  840   MOV   R2,R2,LSR #16  \ R2 = R
  860   MUL   R0,R1,R3
  870   MOV   R0,R0,LSR #16  \ R0 = L
  890   ADD   R4,R2,R0,LSL #16 \ R4 = LLRR
  910.scaleHandlerVolumeStore%
  930]
  940IF debug% THEN
  950[OPT I%
  960    SWI "XOS_WriteS"
  970    EQUS "Scaled volume = "+CHR$(0):ALIGN
  980    MOV  R10,R4
  990    BL   printR10
 1000]
 1010ENDIF
 1020[OPT I%
 1050   STR   R4,[R5,#handler_VolumeScaled%]
 1070   LDMIA R13!,{R0-R5,PC}
 1110]
 1120ENDPROC
