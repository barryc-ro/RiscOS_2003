DEFPROCVolume
LOCAL er$,debug%
er$="Volume"
debug%=FALSE
PRINT "PROCVolume"
[OPT I%

\ -------------------------------- Volume routines ------------------------


.scaleAllHandlerVolumes%  \ Set the actual volumes for all handlers
                          \ typically called after driver volume has changed
                          \ should also be called when System volume has changed

   STMDB R13!,{R0-R12,R14}

   ADD   R0,R12,#work_handlerTable%   \ Get handler table
   MOV   R6,#handlerMax%              \ Count

.scaleAllHandlerVolumesLoop%

   LDR   R1,[R0,#handler_Address%]    \ Is there a driver here?
   CMP   R1,#0
   BLNE  scaleHandlerVolume%

   ADD   R0,R0,#handlerTableLen%
   SUBS  R6,R6,#1
   BNE   scaleAllHandlerVolumesLoop%

   LDMIA R13!,{R0-R12,PC}

\ ----------

.scaleHandlerVolume%  \ Using all available volume info
                      \ set up the real volume for the handler
                      \ as passed to fill routine
                      \ On entry R0 = handler table

   STMDB R13!,{R0-R5,R14}

   LDR   R4,[R0,#handler_Volume%]

   \ Scale according to R0 = Driver volume (if driver cannot use it)
   \                    R4 = Handler volume

   MOV   R5,R0         \ Store handler address

   \ Get the driver scaled volume

   ADD   R0,R12,#work_driverTable%
   LDR   R1,[R0,#driver_Address%]
   CMP   R1,#0                        \ Check driver exists
   BEQ   scaleHandlerVolumeStore%     \ Don't change volume if no driver

   LDR   R0,[R0,#driver_VolumeScaled%]   \ Driver scaled volume
]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Driver volume = "+CHR$(0):ALIGN
    MOV  R10,R0
    BL   printR10
]
ENDIF
[OPT I%

   MOV   R1,#0
   SUB   R1,R1,#1
   CMP   R0,R1                   \ No driver scaling required

   BEQ   scaleHandlerVolumeStore%

   \     R0 = LR, R4 = LR, Scale accordingly....

   MOV   R1,R0,LSR #16  \ R1 = L1
   MOV   R0,R0,LSL #16
   MOV   R0,R0,LSR #16  \ R0 = R1

   MOV   R3,R4,LSR #16  \ R3 = L2
   MOV   R4,R4,LSL #16
   MOV   R4,R4,LSR #16  \ R4 = R2

   MUL   R2,R0,R4
   MOV   R2,R2,LSR #16  \ R2 = R

   MUL   R0,R1,R3
   MOV   R0,R0,LSR #16  \ R0 = L

   ADD   R4,R2,R0,LSL #16 \ R4 = LLRR

.scaleHandlerVolumeStore%

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "Scaled volume = "+CHR$(0):ALIGN
    MOV  R10,R4
    BL   printR10
]
ENDIF
[OPT I%


   STR   R4,[R5,#handler_VolumeScaled%]

   LDMIA R13!,{R0-R5,PC}



]
ENDPROC
