DEFPROCSampleRate
LOCAL er$
er$="Sample Rate"
PRINT "PROCSampleRate"
[OPT I%

\ ------------------------------- Sample rate routines ----------------------

.newRate%  \ Used from handler routine to sort out details
           \ R0 = New frequency

   STMDB R13!,{R0-R12,R14}

   \ Need new sample period in R1

    LDR   R6,rateConst%
    MOV   R2,R0
    BL    clockCalc%

    MOV   R1,R3   \ Return sample period in R1


\   LDR   R3,rateConst%   \ R3.R2
\   MOV   R2,#0
\   MOV   R4,R0    \ DIV frequency
\
\   BL    div      \ R3 = Sample period
\
\   MOV   R1,R3

   BL    newSampleRateSet%

   LDMIA R13!,{R0-R12,PC}



\ ------------------



.newSampleRate% \ The sample rate has changed,  sort it out
                \ On entry R0 = 0 to read, >0 to set new rate = R0

   STMDB R13!,{R0-R12,R14}

]
IF debug% THEN
[OPT I%
    SWI "XOS_WriteS"
    EQUS "New sample rate"+CHR$(0):ALIGN
    SWI "XOS_NewLine"
]
ENDIF
[OPT I%

   BL    sampleRate%  \ Returns R0 = frequency, R1 = period

   LDR   R2,[R12,#work_SampleFrequency%] \ Has the rate changed?
   CMP   R0,R2
   BEQ   newSampleRateExit%  \ Nothing to do

   BL    stopSound%        \ Stop play and wait for fill to finish

   STR   R0,[R12,#work_SampleFrequency%]  \ Store frequency
   STR   R1,[R12,#work_SamplePeriod%]     \ Store sample period

   \     then calculate the fractional step for each handler

   ADD   R1,R12,#work_handlerTable%   \ Get handler table

   MOV   R6,#handlerMax%              \ Count

.newSampleRateLoop%

   LDR   R0,[R1,#handler_Address%]    \ Is there a handler here?
   CMP   R0,#0
   BEQ   newSampleRateNext%

   LDR   R0,[R1,#handler_SampleFrequency%]
   CMP   R0,#0
   BEQ   newSampleRateNext%                    \ No rate stored

   BL    sampleRateFraction%

   STR   R0,[R1,#handler_Fraction%]

.newSampleRateNext%

   ADD   R1,R1,#handlerTableLen%
   SUBS  R6,R6,#1
   BNE   newSampleRateLoop%

   BL    startSound%       \ Start sound again

.newSampleRateExit%

    LDMIA R13!,{R0-R12,PC}

\ ---------

.newSampleRateSet%

    STMDB R13!,{R14}

   STR   R0,[R12,#work_SampleFrequency%]  \ Store frequency
   STR   R1,[R12,#work_SamplePeriod%]     \ Store sample period

   \     then calculate the fractional step for each handler

   ADD   R1,R12,#work_handlerTable%   \ Get handler table

   MOV   R6,#handlerMax%              \ Count

.newSampleRateSetLoop%

   LDR   R0,[R1,#handler_Address%]    \ Is there a handler here?
   CMP   R0,#0
   BEQ   newSampleRateSetNext%

   LDR   R0,[R1,#handler_SampleFrequency%]
   CMP   R0,#0
   BEQ   newSampleRateSetNext%                    \ No rate stored

   BL    sampleRateFraction%

   STR   R0,[R1,#handler_Fraction%]

.newSampleRateSetNext%

   ADD   R1,R1,#handlerTableLen%
   SUBS  R6,R6,#1
   BNE   newSampleRateSetLoop%

   LDMIA R13!,{PC}


\ ---------

.sampleRate%        \ Set or read sample rate

                    \ On entry:
                    \ R0 = 0 to read
                    \    > 0 for sample frequency required
                    \ On exit:
                    \ R0 = current frequency      (provided by driver)
                    \ R1 = current sample period  (calculated by shared sound)

    STMDB R13!,{R2-R12,R14}

    BL    driverSampleRate%                \ Get current rate from driver
    CMP   R0,#0                            \ Failed if 0
    BEQ   sampleRateExit%

    \ R0  will return sample frequency.....

    \ Now calculate sample period

\    LDR   R3,rateConst%   \ R3.R2
\    MOV   R2,#0
\    MOV   R4,R0    \ DIV frequency
\
\    BL    div

    LDR   R6,rateConst%
    MOV   R2,R0
    BL    clockCalc%

    MOV   R1,R3   \ Return sample period in R1

.sampleRateExit%

    LDMIA R13!,{R2-R12,PC}

\----------

.sampleRateFraction%    \ Get the fractional step required for given rate and current rate
                        \ On entry:
                        \   R0 = Frequency required
                        \ On exit:
                        \   R0 = Fraction in 8.24
    STMDB R13!,{R1-R12,R14}

    LDR   R2,[R12,#work_SampleFrequency%]    \ Current frequency
    MOV   R6,R0                              \ Frequency required

    BL    clockCalc%       \ Returns fraction in R3

    MOV   R0,R3            \ Return in R0

    LDMIA R13!,{R1-R12,PC}

\ ------------------

.rateConst%   EQUD &3D090000
\

.clockCalc% \ Calculate  fraction count
            \ Pass rate in R6, actual rate in R2
  STMDB R13!,{R14}

  MOV R9,R2      \ Store actual rate
  MOV R4,R2      \ actual rate ready for next calculation

  MOV R2,#0      \ Calculate whole part
  MOV R3,R6
  \ R4=actual rate
  BL div
  MOV R10,R3
                \ Calculate fraction
                \ R2 = Remainder from above
  MOV R3,#0
  \ R4=actual rate
  MOV R4,R9
  BL div

  MOV R3,R3,LSR #8 \ 24 Bit fraction
  ADD R3,R3,R10,LSL #24 \ 8 Bit whole part

  LDMIA R13!,{PC}^
\
.div \ Divide R3.R2 by R4 , R3 = result, R2 = remainder
  MOV R5,#32 \ Number of bits in divisor
.dloop
  MOVS  R3,R3,LSL #1
  MOV   R2,R2,LSL #1
  ORRCS R2,R2,#1
  CMPS  R2,R4
  BCC   dnext
  SBC   R2,R2,R4
  ADD   R3,R3,#1
.dnext
  SUBS  R5,R5,#1
  BNE dloop
  MOV PC,R14
\
]
ENDPROC
