   10
   20The process involves receiving a 'fill this buffer' instruction
   30from a driver.
   40The fill code then fills and mixes any available data from
   50any immediate handlers whith each handler doing it's own mixing.
   60Then any call back streams are called to give any available data
   70with the fill code mixing it.
   80Finally, call back streams are called to make sure that the call
   90back buffer is full.
  100At the end of each call back call process handlers can be called.
  110The same handler code for each stage can be used with flags to
  120indicate which type of handler is being processed ans with the
  130data pointers set appropriately.
  140
  150
  160DEFPROCHandler
  170LOCAL er$,debug%
  180er$="Handler"
  190debug%=FALSE
  200PRINT "PROCHandler"
  210CBAIDisableInt%=TRUE
  220[OPT I%
  230
  240
  250\-------------------------- Sound Handler Code ------------------------
  260
  270.stopSound% \ Make sure nothing is happening
  280
  290   STMDB R13!,{R0,R14}
  300
  310   MOV   R0,#1
  320   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine
  330
  340   \ Now wait until no sound is happening
  350
  360.stopSoundLoop%
  370
  380   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
  390   CMP   R0,#0
  400   BNE   stopSoundLoop%
  410
  420   LDMIA R13!,{R0,PC}
  430
  440\ -----------
  450
  460.startSound% \ Set handler going again
  470
  480  STMDB R13!,{R0,R14}
  490
  500  MOV   R0,#0
  510  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
  520
  530  \ Should check that there is a current driver and that it is active...
  540
  550  LDMIA R13!,{R0,PC}
  560
  570\ -------------------------------
  580
  590.getFillR0%
  600
  610  ADR   R0,fill%
  620  MOV   PC,R14
  630
  640\ ----
  650
  660.fill%   \ Main fill call for output driver
  670         \ Can be called by a 16 or 8 bit driver
  680         \ It needs to collect and mix data into the final buffer
  690         \ converting the data if necessary.
  700         \ On entry:
  710         \    R0 = parameter, this should be the SharedSound R12 value
  720         \    R1 = base of buffer
  730         \    R2 = end of buffer
  740         \    R3 = flags
  750         \    R4 = sample frequency or period
  760         \ Added:
  770         \    R5 = sample period
  780
  790   STMDB R13!,{R0-R12,R14}
  800
  810   LDR   R12,[R0]
  820
  830   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
  840   CMP   R0,#1
  850   BEQ   fillExit%
  860
  870   MOV   R0,#1
  880   STR   R0,[R12,#work_SoundActive%]    \ Flag active
  890
  900   \ If there is data in the buffer then this is shown in R3
  910
  920   MOV   R5,R4
  930   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
  940   CMP   R4,R5
  950
  960   BLNE  rateChange%                             \ Set a call back to change values
  970
  980   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now
  990
 1000   \ First call any immediate handlers
 1010
 1020   LDR   R6,[R12,#work_ImmediateHandlers%]
 1030   CMP   R6,#0
 1040   MOVNE R6,#handlerType_Immediate%
 1050   BLNE  handler%
 1060
 1070   \ Now get any callBack buffers and mix in
 1080
 1090   LDR   R6,[R12,#work_CallBackHandlers%]
 1100   CMP   R6,#0
 1110   BEQ   fillExit%
 1120
 1130   BL    addCallBackBuffer%
 1140
 1150   \ Finally initiate any callbacks required
 1160
 1170   BL    callBackHandlerProcess%
 1180
 1190
 1200.fillExit%
 1210
 1220   MOV   R0,#0
 1230   STR   R0,[R12,#work_SoundActive%]    \ Flag finished
 1240
 1250   LDMIA R13!,{R0-R12,PC}
 1260
 1270\ ------------------
 1280
 1290.rateChange%     \ Issue a call back to change the rate values
 1300
 1310   STMDB R13!,{R0,R1,R14}
 1320
 1330]
 1340IF doCallBack% THEN
 1350[OPT I%
 1360
 1370   ADR   R0,rateChangeCallBack%
 1380   LDR   R1,[R12,#work_privateWord%]
 1390
 1400   SWI   "OS_AddCallBack"
 1410
 1420   LDMIA R13!,{R0,R1,PC}^
 1430
 1440
 1450]
 1460ELSE
 1470[OPT I%
 1480
 1490   MOV   R0,R5   \ New frequency
 1500   BL    newRate%
 1510
 1520   LDMIA R13!,{R0,R1,PC}^
 1530
 1540]
 1550ENDIF
 1560[OPT I%
 1570
 1580
 1590\ ---------
 1600
 1610
 1620]
 1630IF doCallBack% THEN
 1640[OPT I%
 1650
 1660
 1670.rateChangeCallBack%
 1680
 1690   STMDB R13!,{R0-R12,R14}
 1700
 1710   LDR   R12,[R12]         \ Get workspace pointer
 1720
 1730   \     First get current sample frequency and sample period
 1740   \     This is provided by the SampleRate routine
 1750
 1760   MOV   R0,#0          \ Function code read
 1770
 1780   BL    newSampleRate%
 1790
 1800   LDMIA R13!,{R0-R12,PC}^
 1810
 1820]
 1830ENDIF
 1840[OPT I%
 1850
 1860
 1870\ ---------------- Handler stuff ---------------
 1880
 1890.handler% \ Dummy fill code
 1900          \ Used to pass on control to chain of handlers
 1910          \ The flags indicate which handlers to call
 1920          \ There are three types - immediate, callback and process
 1930          \ On entry:
 1940          \    R0 = parameter, this should be the SharedSound R12 value
 1950          \    R1 = base of buffer
 1960          \    R2 = end of buffer
 1970          \    R3 = flags
 1980          \    R4 = sample frequency
 1990          \    R5 = sample period
 2000          \    R6 = Handler type
 2010
 2020          \ Added by SharedSound before calling handlers
 2030
 2040          \    R6 = fraction step
 2050          \    R7 = LR Volume
 2060
 2070   STMDB R13!,{R0-R2,R4-R12,R14}
 2080
 2090   \ Now call each handler in turn, if they match the flag type
 2100
 2110   MOV   R11,R6 \ Handler type
 2120
 2130   ADD   R8,R12,#work_handlerTable%       \ Address of table
 2140   MOV   R9,#handlerMax%                  \ Handler count
 2150
 2160.handlerLoop%
 2170
 2180   LDR   R10,[R8,#handler_Type%]
 2190   CMP   R10,R11
 2200   BNE   handlerNext%
 2210
 2220   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
 2230   CMP   R10,#0
 2240   BEQ   handlerNext%
 2250
 2260   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2270
 2280   LDR   R0,[R8,#handler_Parameter%]
 2290   LDR   R6,[R8,#handler_Fraction%]
 2300   LDR   R7,[R8,#handler_VolumeScaled%]
 2310
 2320   MOV   R14,PC
 2330   MOV   PC,R10                            \ Jump to address
 2340\   MOVNV R0,R0
 2350
 2360.handlerReturn%
 2370
 2380   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 2390
 2400.handlerNext%
 2410
 2420   ADD   R8,R8,#handlerTableLen%
 2430   SUBS  R9,R9,#1
 2440   BNE   handlerLoop%
 2450
 2460
 2470.handlerExit%
 2480
 2490   LDMIA R13!,{R0-R2,R4-R12,PC}
 2500
 2510\ ------------------- Call Back Handler routines
 2520
 2530.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%
 2540
 2550\ ----
 2560
 2570.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
 2580                     \ On entry:
 2590                     \    R1 = base of buffer
 2600                     \    R2 = end of buffer
 2610                     \    R3 = flags
 2620                     \    R4 = sample frequency
 2630                     \    R5 = sample period
 2640                     \ On exit:
 2650                     \    call back data mixed in if there is some
 2660
 2670   STMDB R13!,{R0-R12,R14}
 2680
 2690   SUB   R6,R2,R1
 2700   LDR   R7,[R12,#work_CallBack_BufferSize%]
 2710
 2720   CMP   R6,R7
 2730
 2740   \ If the buffer size has changed then need to make changes...
 2750
 2760   STR   R6,[R12,#work_CallBack_BufferSize%]
 2770
 2780   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
 2790   CMP   R5,#0
 2800   BGT   addCallBackBuffer_OK%
 2810
 2820   \ Need to flag an overrun
 2830
 2840   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
 2850   CMP   R5,#1
 2860
 2870   \ If there are no full buffers and the call back is active then we have overrun
 2880
 2890   LDREQ R7,[R12,#work_callBack_Count%]   \ If so then increment count and return
 2900   ADDEQ R7,R7,#1
 2910   STREQ R7,[R12,#work_callBack_Count%]
 2920
 2930   \ Need to do a volume shift on the buffer to effectivly mix an empty buffer
 2940   \ into the existing data
 2950   \ This avoids volume fluctuations
 2960
 2970   \ R1 = Start of SoundDMA buffer
 2980   \ R2 = End of SoundDMA buffer
 2990   \ R6 = Length
 3000
 3010.addCallBackBuffer_VolumeShiftLoop%
 3020
 3030   LDMIA R1,{R3-R6}
 3040
 3050   \ Shift volumes
 3060
 3070]
 3080work1%=11:work2%=12
 3090FOR getReg%=3 TO 6
 3100[OPT I%
 3110
 3120  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3130  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3140
 3150  MOV   work1%,work1%,ASR #1     \ DIV 2
 3160
 3170  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3180
 3190  TST   getReg%,#1<<15           \ Remove any low bit
 3200  EORNE getReg%,getReg%,#1<<15
 3210
 3220  ADD   getReg%,getReg%,work1%,LSR #16
 3230
 3240]
 3250NEXT
 3260[OPT I%
 3270
 3280   STMIA R1!,{R3-R6}
 3290
 3300   CMP   R1,R2
 3310   BLT   addCallBackBuffer_VolumeShiftLoop%
 3320
 3330   B     addCallBackBuffer_Exit%   \ No data available
 3340
 3350.addCallBackBuffer_OK%  \ There are buffers available so use one of these
 3360
 3370   \ R1 = Start of SoundDMA buffer
 3380   \ R2 = End of SoundDMA buffer
 3390   \ R6 = Length
 3400
 3410   LDR   R5,work_CallBack_BufferVal%
 3420   ADD   R5,R5,R12
 3430   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3440   MLA   R0,R6,R7,R5                                    \ Buffer position
 3450
 3460   \ R0 = Source buffer
 3470   \ R1 = DMA buffer
 3480   \ R2 = DMA buffer end
 3490   \ R3 = Fill flags
 3500
 3510   \ Copy across (mixing??)
 3520
 3530   TST  R3,#1
 3540   BNE  addCallBackBuffer_Mix%
 3550
 3560   \ No mixing
 3570
 3580.addCallBackBuffer_Loop%
 3590
 3600   LDMIA R0!,{R3-R6}
 3610   STMIA R1!,{R3-R6}
 3620
 3630   CMP   R1,R2
 3640   BLT   addCallBackBuffer_Loop%
 3650
 3660   B    addCallBackBuffer_Final%
 3670
 3680
 3690.addCallBackBuffer_Mix%
 3700
 3710   STMDB R13!,{R12}
 3720
 3730.addCallBackBufferMix_Loop%
 3740
 3750   LDMIA R0!,{R3-R6}
 3760   LDMIA R1,{R7-R10}
 3770
 3780]
 3790work1%=11:work2%=12
 3800FOR getReg%=3 TO 6
 3810mixReg%=getReg%+4
 3820[OPT I%
 3830
 3840  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 3850  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 3860
 3870  MOV   work1%,work1%,ASR #1     \ DIV 2
 3880
 3890  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3900
 3910  TST   getReg%,#1<<15           \ Remove any low bit
 3920  EORNE getReg%,getReg%,#1<<15
 3930
 3940  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
 3950  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg
 3960
 3970  MOV   work2%,work2%,ASR #1     \ DIV 2
 3980
 3990  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2
 4000
 4010  TST   mixReg%,#1<<15           \ Remove any low bit
 4020  EORNE mixReg%,mixReg%,#1<<15
 4030
 4040  \ Now mix
 4050
 4060  ADD   getReg%,getReg%,mixReg%
 4070  ADD   work1%,work1%,work2%
 4080
 4090  ADD   getReg%,getReg%,work1%,LSR #16
 4100
 4110
 4120
 4130]
 4140NEXT
 4150[OPT I%
 4160
 4170   STMIA R1!,{R3-R6}
 4180
 4190   CMP   R1,R2
 4200   BLT   addCallBackBufferMix_Loop%
 4210
 4220   LDMIA R13!,{R12}
 4230
 4240.addCallBackBuffer_Final%
 4250
 4260   \ Increment current SoundDMA buffer
 4270
 4280   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4290   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
 4300   ADD   R7,R7,#1
 4310   CMP   R7,R8
 4320   MOVGE R7,#0
 4330   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 4340
 4350   \ Decrement full count
 4360
 4370   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
 4380   SUBS  R8,R8,#1
 4390   MOVLT R8,#0
 4400   STR   R8,[R12,#work_CallBack_BufferFullCount%]
 4410
 4420.addCallBackBuffer_Exit%
 4430
 4440   LDMIA R13!,{R0-R12,PC}
 4450
 4460\ -------------------------------
 4470
 4480.callBackHandlerProcess%
 4490          \ On entry:
 4500          \    R1 = base of buffer
 4510          \    R2 = end of buffer
 4520          \    R3 = flags
 4530          \    R4 = sample frequency
 4540          \    R5 = sample period
 4550
 4560   STMDB R13!,{R0-R12,R14}
 4570
 4580   SUB   R6,R2,R1
 4590   STR   R6,[R12,#work_CallBack_BufferSize%]
 4600   STR   R3,[R12,#work_CallBack_Flags%]
 4610   STR   R4,[R12,#work_CallBack_SampleFrequency%]
 4620   STR   R5,[R12,#work_CallBack_SamplePeriod%]
 4630
 4640   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4650   CMP   R5,#1
 4660   BEQ   callBackHandlerProcess_Exit%
 4670
 4680   MOV   R5,#1
 4690   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 4700
 4710   \ Set up new call back
 4720
 4730]
 4740IF doCBAI% THEN
 4750[OPT I%
 4760
 4770   \ Either by CBAI
 4780
 4790   LDR   R0,[R12,#work_CBAIActive%]
 4800   CMP   R0,#1
 4810
 4820   ADREQ R0,CBAIRoutine%
 4830   STREQ R0,[R12,#work_PollWord%]
 4840   BEQ   callBackHandlerProcess_Exit%
 4850
 4860   \ Or by old style Call backs
 4870
 4880]
 4890ENDIF
 4900[OPT I%
 4910
 4920   ADR   R0,doHandlerCallBack%
 4930   LDR   R1,[R12,#work_privateWord%]
 4940
 4950MOV   R9,PC
 4960ORR   R8,R9,#SVC_Mode%
 4970TEQP  R8,#0
 4980MOV   R0,R0
 4990STMFD R13!,{R14}
 5000
 5010   SWI   "XOS_AddCallBack"
 5020
 5030LDMFD R13!,{R14}
 5040TEQP  R9,#0
 5050MOV   R0,R0
 5060
 5070.callBackHandlerProcess_Exit%
 5080
 5090   LDMIA R13!,{R0-R12,PC}
 5100
 5110\ -------
 5120
 5130
 5140
 5150\ ---------------
 5160
 5170.doHandlerCallBack%  \ Called by call back system
 5180                     \ Needs to call the handler with the right parameters
 5190
 5200   STMDB R13!,{R0-R12,R14}
 5210
 5220   LDR   R12,[R12]
 5230
 5240]
 5250IF debug% THEN
 5260[OPT I%
 5270    SWI "XOS_WriteS"
 5280    EQUS "Handler call back"+CHR$(0):ALIGN
 5290    SWI  "XOS_NewLine"
 5300]
 5310ENDIF
 5320[OPT I%
 5330
 5340   \ From the start and end get the length and offset into the buffer
 5350   \ by the current OutBuffer value
 5360
 5370   LDR   R10,[R12,#work_CallBack_BufferSize%]
 5380   LDR   R0,[R12,#work_privateWord%]
 5390   LDR   R3,[R12,#work_CallBack_Flags%]
 5400   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
 5410   LDR   R5,[R12,#work_CallBack_SamplePeriod%]
 5420
 5430.doHandlerCallBack_Loop%
 5440
 5450   \ R10 = Buffer length
 5460
 5470   LDR   R2,work_CallBack_BufferVal%
 5480   ADD   R2,R2,R12
 5490   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5500   MLA   R1,R10,R7,R2                              \ Buffer address
 5510
 5520   ADD   R2,R1,R10
 5530
 5540   MOV   R3,#0                           \ Buffer invalid
 5550
 5560   LDR   R8,[R12,#work_CallBackHandlers%]
 5570   CMP   R8,#0
 5580   MOVNE R6,#handlerType_CallBack%
 5590   BLNE  handler%
 5600
 5610   LDR   R8,[R12,#work_ProcessHandlers%]
 5620   CMP   R8,#0
 5630   MOVNE R6,#handlerType_Process%
 5640   BLNE  handler%
 5650
 5660]:IF NOT CBAIDisableInt% THEN
 5670[OPT I%
 5680
 5690   MOV  R8,PC
 5700   ORR  R9,R8,#Iflag%
 5710   TEQP R9,#0                  ; interrupts -> disabled
 5720]
 5730ENDIF
 5740[OPT I%
 5750
 5760   \ increment full count
 5770   \ Increment out buffer
 5780
 5790   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5800   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
 5810   ADD   R7,R7,#1
 5820   CMP   R7,R9
 5830   MOVGE R7,#0
 5840   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 5850
 5860   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
 5870   ADD   R7,R7,#1
 5880   CMP   R7,R9
 5890   MOVGT R7,R9
 5900   STR   R7,[R12,#work_CallBack_BufferFullCount%]
 5910
 5920]:IF NOT CBAIDisableInt% THEN
 5930[OPT I%
 5940
 5950   TEQP R8,#0                  ; Interrupts reenabled
 5960]
 5970ENDIF
 5980[OPT I%
 5990
 6000   \ Check for full count = max
 6010   \ Loop round if not
 6020
 6030   CMP   R7,R9
 6040   BLT   doHandlerCallBack_Loop%
 6050
 6060   \ Otherwise we have filled all the buffers and can return
 6070
 6080]:IF NOT CBAIDisableInt% THEN
 6090[OPT I%
 6100
 6110   MOV  R8,PC
 6120   ORR  R9,R8,#Iflag%
 6130   TEQP R9,#0                 ; interrupts -> disabled
 6140]
 6150ENDIF
 6160[OPT I%
 6170
 6180   MOV   R5,#0
 6190   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed
 6200
 6210]:IF NOT CBAIDisableInt% THEN
 6220[OPT I%
 6230
 6240   TEQP R8,#0                  ; Interrupts reenabled
 6250]
 6260ENDIF
 6270[OPT I%
 6280
 6290   LDMIA R13!,{R0-R12,PC}
 6300
 6310
 6320\ ---------------
 6330
 6340.clearCallBackBuffer%  \ Initialise the call back buffer to 0
 6350
 6360
 6370     STMDB R13!,{R0-R12,R14}
 6380
 6390     MOV   R0,#0
 6400     MOV   R1,#0
 6410     MOV   R2,#0
 6420     MOV   R3,#0
 6430
 6440     LDR   R4,work_CallBack_BufferVal%
 6450     ADD   R4,R4,R12
 6460     ADD   R5,R4,#callBackBufferLen%
 6470
 6480.clearCallBackBuffer_Loop%
 6490
 6500     STMIA R4!,{R0-R3}
 6510     CMP   R4,R5
 6520     BLT   clearCallBackBuffer_Loop%
 6530
 6540     LDMIA R13!,{R0-R12,PC}
 6550
 6560
 6570\ ---------------
 6580
 6590.setHandlerType%  \ Set the corresponding bit for this handler's number & type
 6600                  \ On entry:
 6610                  \    R0 = Handler number
 6620                  \    R4 = Type
 6630
 6640    STMDB R13!,{R0-R4,R14}
 6650
 6660    MOV   R1,#1
 6670    MOV   R0,R1,LSL R0          \ As a bit
 6680
 6690    CMP   R4,#handlerType_Immediate%
 6700    LDREQ R1,[R12,#work_ImmediateHandlers%]
 6710    ORREQ R1,R1,R0
 6720    STREQ R1,[R12,#work_ImmediateHandlers%]
 6730
 6740    CMP   R4,#handlerType_CallBack%
 6750    LDREQ R1,[R12,#work_CallBackHandlers%]
 6760    ORREQ R1,R1,R0
 6770    STREQ R1,[R12,#work_CallBackHandlers%]
 6780
 6790    CMP   R4,#handlerType_Process%
 6800    LDREQ R1,[R12,#work_ProcessHandlers%]
 6810    ORREQ R1,R1,R0
 6820    STREQ R1,[R12,#work_ProcessHandlers%]
 6830
 6840    LDMIA R13!,{R0-R4,PC}
 6850
 6860\ ---------
 6870
 6880.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
 6890                    \ On entry:
 6900                    \    R0 = Handler number
 6910                    \    R4 = Type
 6920
 6930    STMDB R13!,{R0-R4,R14}
 6940
 6950    MOV   R1,#1
 6960    MOV   R0,R1,LSL R0          \ As a bit
 6970
 6980    CMP   R4,#handlerType_Immediate%
 6990    LDREQ R1,[R12,#work_ImmediateHandlers%]
 7000    BICEQ R1,R1,R0
 7010    STREQ R1,[R12,#work_ImmediateHandlers%]
 7020
 7030    CMP   R4,#handlerType_CallBack%
 7040    LDREQ R1,[R12,#work_CallBackHandlers%]
 7050    BICEQ R1,R1,R0
 7060    STREQ R1,[R12,#work_CallBackHandlers%]
 7070
 7080    CMP   R4,#handlerType_Process%
 7090    LDREQ R1,[R12,#work_ProcessHandlers%]
 7100    BICEQ R1,R1,R0
 7110    STREQ R1,[R12,#work_ProcessHandlers%]
 7120
 7130    LDMIA R13!,{R0-R4,PC}
 7140
 7150
 7160\ -------------------- CBAI -----------------
 7170
 7180]
 7190IF doCBAI% THEN
 7200[OPT I%
 7210
 7220.InstallCBAI%  \ Install the CBAI stuff if module exists
 7230
 7240     STMDB R13!,{R0-R12,R14}
 7250
 7260     MOV   R0,#0
 7270     STR   R0,[R12,#work_PollWord%]
 7280
 7290     MOV   R0,#0
 7300     ADR   R1,CBAIString%
 7310     SWI   "XOS_SWINumberFromString"
 7320
 7330     MOVVC R0,#1
 7340     MOVVS R0,#0
 7350     STR   R0,[R12,#work_CBAIActive%]
 7360
 7370     ADDVC R0,R12,#work_PollWord%
 7380     MOVVC R1,#&100000       \ Scheduling class
 7390     LDRVC R2,[R12,#work_privateWord%]
 7400     SWIVC "XCBAI_RegisterPollWord"
 7410
 7420     LDMIA R13!,{R0-R12,PC}
 7430
 7440\ -----------------
 7450
 7460.CBAIString% EQUS "CBAI_RegisterPollWord"
 7470             EQUB 0
 7480             ALIGN
 7490
 7500\ -----------------
 7510
 7520.RemoveCBAI% \ De-register the CBAI pollword
 7530
 7540     STMDB R13!,{R0-R12,R14}
 7550
 7560     LDR   R0,[R12,#work_CBAIActive%]
 7570     CMP   R0,#1
 7580
 7590     ADDEQ R0,R12,#work_PollWord%
 7600     SWIEQ "CBAI_DeregisterPollWord"
 7610
 7620     MOV   R0,#0
 7630     STR   R0,[R12,#work_CBAIActive%]
 7640
 7650     LDMIA R13!,{R0-R12,PC}
 7660
 7670\ -----------------
 7680
 7690.CBAIRoutine%  \ Call back routine to call call back addresses
 7700
 7710     STMDB R13!,{R0-R12}
 7720
 7730\     MOV   R9,PC
 7740\     ORR   R8,R9,#SVC_Mode%
 7750\     TEQP  R8,#0
 7760\     MOV   R0,R0
 7770\     STMFD R13!,{R14}
 7780
 7790]:IF CBAIDisableInt% THEN
 7800[OPT I%
 7810
 7820   MOV  R8,PC
 7830   ORR  R9,R8,#Iflag%
 7840   TEQP R9,#0                  ; interrupts -> disabled
 7850]
 7860ENDIF
 7870[OPT I%
 7880
 7890     BL    doHandlerCallBack%
 7900
 7910]:IF CBAIDisableInt% THEN
 7920[OPT I%
 7930
 7940   TEQP R8,#0                  ; Interrupts reenabled
 7950]
 7960ENDIF
 7970[OPT I%
 7980
 7990\     LDMFD R13!,{R14}
 8000\     TEQP  R9,#0
 8010\     MOV   R0,R0
 8020
 8030     LDMIA R13!,{R0-R12,PC}
 8040
 8050\ -----------------
 8060]
 8070ENDIF
 8080[OPT I%
 8090
 8100]
 8110ENDPROC
 8120
