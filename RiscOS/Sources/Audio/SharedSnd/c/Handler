   20The process involves receiving a 'fill this buffer' instruction
   30from a driver.
   40The fill code then fills and mixes any available data from
   50any immediate handlers whith each handler doing it's own mixing.
   60Then any call back streams are called to give any available data
   70with the fill code mixing it.
   80Finally, call back streams are called to make sure that the call
   90back buffer is full.
  100At the end of each call back call process handlers can be called.
  110The same handler code for each stage can be used with flags to
  120indicate which type of handler is being processed ans with the
  130data pointers set appropriately.
  160DEFPROCHandler
  170LOCAL er$
  180er$="Handler"
  190PRINT "PROCHandler"
  200[OPT I%
  230\-------------------------- Sound Handler Code ------------------------
  250.stopSound% \ Make sure nothing is happening
  270   STMDB R13!,{R0,R14}
  290   MOV   R0,#1
  300   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine
  320   \ Now wait until no sound is happening
  340.stopSoundLoop%
  360   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
  370   CMP   R0,#0
  380   BNE   stopSoundLoop%
  400   LDMIA R13!,{R0,PC}
  420\ -----------
  440.startSound% \ Set handler going again
  460  STMDB R13!,{R0,R14}
  480  MOV   R0,#0
  490  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag
  510  \ Should check that there is a current driver and that it is active...
  530  LDMIA R13!,{R0,PC}
  550\ -------------------------------
  570.getFillR0%
  590  ADR   R0,fill%
  600  MOV   PC,R14
  620\ ----
  640.fill%   \ Main fill call for output driver
  650         \ Can be called by a 16 or 8 bit driver
  660         \ It needs to collect and mix data into the final buffer
  670         \ converting the data if necessary.
  680         \ On entry:
  690         \    R0 = parameter, this should be the SharedSound R12 value
  700         \    R1 = base of buffer
  710         \    R2 = end of buffer
  720         \    R3 = flags
  730         \    R4 = sample frequency or period
  740         \ Added:
  750         \    R5 = sample period
  770   STMDB R13!,{R0-R12,R14}
  790   LDR   R12,[R0]
  810   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
  820   CMP   R0,#1
  830   BEQ   fillExit%
  850   MOV   R0,#1
  860   STR   R0,[R12,#work_SoundActive%]    \ Flag active
  880   \ If there is data in the buffer then this is shown in R3
  900   MOV   R5,R4
  910   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
  920   CMP   R4,R5
  940   BLNE  rateChange%                             \ Set a call back to change values
  960   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now
  980   \ First call any immediate handlers
 1000   LDR   R6,[R12,#work_ImmediateHandlers%]
 1010   CMP   R6,#0
 1020   MOVNE R6,#handlerType_Immediate%
 1030   BLNE  handler%
 1050   \ Now get any callBack buffers and mix in
 1070   LDR   R6,[R12,#work_CallBackHandlers%]
 1080   CMP   R6,#0
 1090   BEQ   fillExit%
 1110   BL    addCallBackBuffer%
 1130   \ Finally initiate any callbacks required
 1150   BL    callBackHandlerProcess%
 1180.fillExit%
 1200   MOV   R0,#0
 1210   STR   R0,[R12,#work_SoundActive%]    \ Flag finished
 1230   LDMIA R13!,{R0-R12,PC}
 1250\ ------------------
 1270.rateChange%     \ Issue a call back to change the rate values
 1290   STMDB R13!,{R0,R1,R14}
 1310   MOV   R0,R5   \ New frequency
 1320   BL    newRate%
 1340   LDMIA R13!,{R0,R1,PC}^
 1370\ ---------------- Handler stuff ---------------
 1390.handler% \ Dummy fill code
 1400          \ Used to pass on control to chain of handlers
 1410          \ The flags indicate which handlers to call
 1420          \ There are three types - immediate, callback and process
 1430          \ On entry:
 1440          \    R0 = parameter, this should be the SharedSound R12 value
 1450          \    R1 = base of buffer
 1460          \    R2 = end of buffer
 1470          \    R3 = flags
 1480          \    R4 = sample frequency
 1490          \    R5 = sample period
 1500          \    R6 = Handler type
 1520          \ Added by SharedSound before calling handlers
 1540          \    R6 = fraction step
 1550          \    R7 = LR Volume
 1570   STMDB R13!,{R0-R2,R4-R12,R14}
 1590   \ Now call each handler in turn, if they match the flag type
 1610   MOV   R11,R6 \ Handler type
 1630   ADD   R8,R12,#work_handlerTable%       \ Address of table
 1640   MOV   R9,#handlerMax%                  \ Handler count
 1660.handlerLoop%
 1680   LDR   R10,[R8,#handler_Type%]
 1690   CMP   R10,R11
 1700   BNE   handlerNext%
 1720   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
 1730   CMP   R10,#0
 1740   BEQ   handlerNext%
 1760   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 1780   LDR   R0,[R8,#handler_Parameter%]
 1790   LDR   R6,[R8,#handler_Fraction%]
 1800   LDR   R7,[R8,#handler_VolumeScaled%]
 1820   MOV   R14,PC
 1830   MOV   PC,R10                            \ Jump to address
 1840\   MOVNV R0,R0
 1860.handlerReturn%
 1880   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved
 1900.handlerNext%
 1920   ADD   R8,R8,#handlerTableLen%
 1930   SUBS  R9,R9,#1
 1940   BNE   handlerLoop%
 1970.handlerExit%
 1990   LDMIA R13!,{R0-R2,R4-R12,PC}
 2010\ ------------------- Call Back Handler routines
 2030.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%
 2050\ ----
 2070.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
 2080                     \ On entry:
 2090                     \    R1 = base of buffer
 2100                     \    R2 = end of buffer
 2110                     \    R3 = flags
 2120                     \    R4 = sample frequency
 2130                     \    R5 = sample period
 2140                     \ On exit:
 2150                     \    call back data mixed in if there is some
 2170   STMDB R13!,{R0-R12,R14}
 2190   SUB   R6,R2,R1
 2200   LDR   R7,[R12,#work_CallBack_BufferSize%]
 2220   CMP   R6,R7
 2240   \ If the buffer size has changed then need to make changes...
 2260   STR   R6,[R12,#work_CallBack_BufferSize%]
 2280   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
 2290   CMP   R5,#0
 2300   BGT   addCallBackBuffer_OK%
 2320   \ Need to flag an overrun
 2340   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
 2350   CMP   R5,#1
 2370   \ If there are no full buffers and the call back is active then we have overrun
 2390   LDREQ R6,[R12,#work_callBack_Count%]   \ If so then increment count and return
 2400   ADDEQ R6,R6,#1
 2410   STREQ R6,[R12,#work_callBack_Count%]
 2430   B     addCallBackBuffer_Exit%   \ No data available
 2450.addCallBackBuffer_OK%  \ There are buffers available so use one of these
 2470   \ R1 = Start of SoundDMA buffer
 2480   \ R2 = End of SoundDMA buffer
 2490   \ R6 = Length
 2510   LDR   R5,work_CallBack_BufferVal%
 2520   ADD   R5,R5,R12
 2530   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 2540   MLA   R0,R6,R7,R5                                    \ Buffer position
 2560   \ R0 = Source buffer
 2570   \ R1 = DMA buffer
 2580   \ R2 = DMA buffer end
 2590   \ R3 = Fill flags
 2610   \ Copy across (mixing??)
 2630   TST  R3,#1
 2640   BNE  addCallBackBuffer_Mix%
 2660   \ No mixing
 2680.addCallBackBuffer_Loop%
 2700   LDMIA R0!,{R3-R6}
 2710   STMIA R1!,{R3-R6}
 2730   CMP   R1,R2
 2740   BLT   addCallBackBuffer_Loop%
 2760   B    addCallBackBuffer_Final%
 2790.addCallBackBuffer_Mix%
 2810   STMDB R13!,{R12}
 2830.addCallBackBufferMix_Loop%
 2850   LDMIA R0!,{R3-R6}
 2860   LDMIA R1,{R7-R10}
 2880]
 2890work1%=11:work2%=12
 2900FOR getReg%=3 TO 6
 2910mixReg%=getReg%+4
 2920[OPT I%
 2940  MOV   work1%,getReg%,LSL #16          \ Put right into work1
 2950  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg
 2970  MOV   work1%,work1%,ASR #1     \ DIV 2
 2990  MOV   getReg%,getReg%,ASR #1   \ DIV 2
 3010  TST   getReg%,#1<<15           \ Remove any low bit
 3020  EORNE getReg%,getReg%,#1<<15
 3040  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
 3050  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg
 3070  MOV   work2%,work2%,ASR #1     \ DIV 2
 3090  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2
 3110  TST   mixReg%,#1<<15           \ Remove any low bit
 3120  EORNE mixReg%,mixReg%,#1<<15
 3140  \ Now mix
 3160  ADD   getReg%,getReg%,mixReg%
 3170  ADD   work1%,work1%,work2%
 3190  ADD   getReg%,getReg%,work1%,LSR #16
 3230]
 3240NEXT
 3250[OPT I%
 3270   STMIA R1!,{R3-R6}
 3290   CMP   R1,R2
 3300   BLT   addCallBackBufferMix_Loop%
 3320   LDMIA R13!,{R12}
 3340.addCallBackBuffer_Final%
 3360   \ Increment current SoundDMA buffer
 3380   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3390   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
 3400   ADD   R7,R7,#1
 3410   CMP   R7,R8
 3420   MOVGE R7,#0
 3430   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
 3450   \ Decrement full count
 3470   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
 3480   SUBS  R8,R8,#1
 3490   MOVLT R8,#0
 3500   STR   R8,[R12,#work_CallBack_BufferFullCount%]
 3520.addCallBackBuffer_Exit%
 3540   LDMIA R13!,{R0-R12,PC}
 3560\ -------------------------------
 3580.callBackHandlerProcess%
 3590          \ On entry:
 3600          \    R1 = base of buffer
 3610          \    R2 = end of buffer
 3620          \    R3 = flags
 3630          \    R4 = sample frequency
 3640          \    R5 = sample period
 3660   STMDB R13!,{R0-R12,R14}
 3680   SUB   R6,R2,R1
 3690   STR   R6,[R12,#work_CallBack_BufferSize%]
 3700   STR   R3,[R12,#work_CallBack_Flags%]
 3710   STR   R4,[R12,#work_CallBack_SampleFrequency%]
 3720   STR   R5,[R12,#work_CallBack_SamplePeriod%]
 3740   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 3750   CMP   R5,#1
 3760   BEQ   callBackHandlerProcess_Exit%
 3780   MOV   R5,#1
 3790   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
 3810   \ Set up new call back
 3830   ADR   R0,doHandlerCallBack%
 3840   LDR   R1,[R12,#work_privateWord%]
 3860MOV   R9,PC
 3870ORR   R8,R9,#SVC_Mode%
 3880TEQP  R8,#0
 3890MOV   R0,R0
 3900STMFD R13!,{R14}
 3920   SWI   "XOS_AddCallBack"
 3940LDMFD R13!,{R14}
 3950TEQP  R9,#0
 3960MOV   R0,R0
 3980.callBackHandlerProcess_Exit%
 4000   LDMIA R13!,{R0-R12,PC}
 4020\ -------
 4060\ ---------------
 4080.doHandlerCallBack%  \ Called by call back system
 4090                     \ Needs to call the handler with the right parameters
 4110   STMDB R13!,{R0-R12,R14}
 4130   LDR   R12,[R12]
 4150   \ From the start and end get the length and offset into the buffer
 4160   \ by the current OutBuffer value
 4180   LDR   R10,[R12,#work_CallBack_BufferSize%]
 4190   LDR   R0,[R12,#work_privateWord%]
 4200   LDR   R3,[R12,#work_CallBack_Flags%]
 4210   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
 4220   LDR   R5,[R12,#work_CallBack_SamplePeriod%]
 4240.doHandlerCallBack_Loop%
 4260   \ R10 = Buffer length
 4280   LDR   R2,work_CallBack_BufferVal%
 4290   ADD   R2,R2,R12
 4300   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4310   MLA   R1,R10,R7,R2                              \ Buffer address
 4330   ADD   R2,R1,R10
 4350   MOV   R3,#0                           \ Buffer invalid
 4370   LDR   R8,[R12,#work_CallBackHandlers%]
 4380   CMP   R8,#0
 4390   MOVNE R6,#handlerType_CallBack%
 4400   BLNE  handler%
 4420   LDR   R8,[R12,#work_ProcessHandlers%]
 4430   CMP   R8,#0
 4440   MOVNE R6,#handlerType_Process%
 4450   BLNE  handler%
 4470   MOV  R8,PC
 4480   ORR  R9,R8,#Iflag%
 4490   TEQP R9,#0                  ; interrupts -> disabled
 4510   \ increment full count
 4520   \ Increment out buffer
 4540   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4550   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
 4560   ADD   R7,R7,#1
 4570   CMP   R7,R9
 4580   MOVGE R7,#0
 4590   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
 4610   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
 4620   ADD   R7,R7,#1
 4630   CMP   R7,R9
 4640   MOVGT R7,R9
 4650   STR   R7,[R12,#work_CallBack_BufferFullCount%]
 4670   TEQP R8,#0                  ; Interrupts reenabled
 4690   \ Check for full count = max
 4700   \ Loop round if not
 4720   CMP   R7,R9
 4730   BLT   doHandlerCallBack_Loop%
 4750   \ Otherwise we have filled all the buffers and can return
 4770   MOV  R8,PC
 4780   ORR  R9,R8,#Iflag%
 4790   TEQP R9,#0                 ; interrupts -> disabled
 4810   MOV   R5,#0
 4820   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed
 4840   TEQP R8,#0                  ; Interrupts reenabled
 4860   LDMIA R13!,{R0-R12,PC}
 4890\ ---------------
 4910.clearCallBackBuffer%  \ Initialise the call back buffer to 0
 4940     STMDB R13!,{R0-R12,R14}
 4960     MOV   R0,#0
 4970     MOV   R1,#0
 4980     MOV   R2,#0
 4990     MOV   R3,#0
 5010     LDR   R4,work_CallBack_BufferVal%
 5020     ADD   R4,R4,R12
 5030     ADD   R5,R4,#callBackBufferLen%
 5050.clearCallBackBuffer_Loop%
 5070     STMIA R4!,{R0-R3}
 5080     CMP   R4,R5
 5090     BLT   clearCallBackBuffer_Loop%
 5110     LDMIA R13!,{R0-R12,PC}
 5140\ ---------------
 5160.setHandlerType%  \ Set the corresponding bit for this handler's number & type
 5170                  \ On entry:
 5180                  \    R0 = Handler number
 5190                  \    R4 = Type
 5210    STMDB R13!,{R0-R4,R14}
 5230    MOV   R1,#1
 5240    MOV   R0,R1,LSL R0          \ As a bit
 5260    CMP   R4,#handlerType_Immediate%
 5270    LDREQ R1,[R12,#work_ImmediateHandlers%]
 5280    ORREQ R1,R1,R0
 5290    STREQ R1,[R12,#work_ImmediateHandlers%]
 5310    CMP   R4,#handlerType_CallBack%
 5320    LDREQ R1,[R12,#work_CallBackHandlers%]
 5330    ORREQ R1,R1,R0
 5340    STREQ R1,[R12,#work_CallBackHandlers%]
 5360    CMP   R4,#handlerType_Process%
 5370    LDREQ R1,[R12,#work_ProcessHandlers%]
 5380    ORREQ R1,R1,R0
 5390    STREQ R1,[R12,#work_ProcessHandlers%]
 5410    LDMIA R13!,{R0-R4,PC}
 5430\ ---------
 5450.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
 5460                    \ On entry:
 5470                    \    R0 = Handler number
 5480                    \    R4 = Type
 5500    STMDB R13!,{R0-R4,R14}
 5520    MOV   R1,#1
 5530    MOV   R0,R1,LSL R0          \ As a bit
 5550    CMP   R4,#handlerType_Immediate%
 5560    LDREQ R1,[R12,#work_ImmediateHandlers%]
 5570    BICEQ R1,R1,R0
 5580    STREQ R1,[R12,#work_ImmediateHandlers%]
 5600    CMP   R4,#handlerType_CallBack%
 5610    LDREQ R1,[R12,#work_CallBackHandlers%]
 5620    BICEQ R1,R1,R0
 5630    STREQ R1,[R12,#work_CallBackHandlers%]
 5650    CMP   R4,#handlerType_Process%
 5660    LDREQ R1,[R12,#work_ProcessHandlers%]
 5670    BICEQ R1,R1,R0
 5680    STREQ R1,[R12,#work_ProcessHandlers%]
 5700    LDMIA R13!,{R0-R4,PC}
 5730\ --------
 5740]
 5750ENDPROC
