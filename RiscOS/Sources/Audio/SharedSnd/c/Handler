
The process involves receiving a 'fill this buffer' instruction
from a driver.
The fill code then fills and mixes any available data from
any immediate handlers whith each handler doing it's own mixing.
Then any call back streams are called to give any available data
with the fill code mixing it.
Finally, call back streams are called to make sure that the call
back buffer is full.
At the end of each call back call process handlers can be called.
The same handler code for each stage can be used with flags to
indicate which type of handler is being processed ans with the
data pointers set appropriately.


DEFPROCHandler
LOCAL er$,debug%
er$="Handler"
debug%=FALSE
PRINT "PROCHandler"
CBAIDisableInt%=TRUE
[OPT I%


\-------------------------- Sound Handler Code ------------------------

.stopSound% \ Make sure nothing is happening

   STMDB R13!,{R0,R14}

   MOV   R0,#1
   STR   R0,[R12,#work_SoundPause%]    \ Pause flag for handler routine

   \ Now wait until no sound is happening

.stopSoundLoop%

   LDR   R0,[R12,#work_SoundActive%]   \ This will be set to 0 at then end of a fill
   CMP   R0,#0
   BNE   stopSoundLoop%

   LDMIA R13!,{R0,PC}

\ -----------

.startSound% \ Set handler going again

  STMDB R13!,{R0,R14}

  MOV   R0,#0
  STR   R0,[R12,#work_SoundPause%]  \ Clear the pause flag

  \ Should check that there is a current driver and that it is active...

  LDMIA R13!,{R0,PC}

\ -------------------------------

.getFillR0%

  ADR   R0,fill%
  MOV   PC,R14

\ ----

.fill%   \ Main fill call for output driver
         \ Can be called by a 16 or 8 bit driver
         \ It needs to collect and mix data into the final buffer
         \ converting the data if necessary.
         \ On entry:
         \    R0 = parameter, this should be the SharedSound R12 value
         \    R1 = base of buffer
         \    R2 = end of buffer
         \    R3 = flags
         \    R4 = sample frequency or period
         \ Added:
         \    R5 = sample period

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R0]

   LDR   R0,[R12,#work_SoundPause%]     \ Are we in pause state
   CMP   R0,#1
   BEQ   fillExit%

   MOV   R0,#1
   STR   R0,[R12,#work_SoundActive%]    \ Flag active

   \ If there is data in the buffer then this is shown in R3

   MOV   R5,R4
   LDR   R4,[R12,#work_SampleFrequency%]         \ Put current rate into R4
   CMP   R4,R5

   BLNE  rateChange%                             \ Set a call back to change values

   LDR   R5,[R12,#work_SamplePeriod%]            \ Use old values for now

   \ First call any immediate handlers

   LDR   R6,[R12,#work_ImmediateHandlers%]
   CMP   R6,#0
   MOVNE R6,#handlerType_Immediate%
   BLNE  handler%

   \ Now get any callBack buffers and mix in

   LDR   R6,[R12,#work_CallBackHandlers%]
   CMP   R6,#0
   BEQ   fillExit%

   BL    addCallBackBuffer%

   \ Finally initiate any callbacks required

   BL    callBackHandlerProcess%


.fillExit%

   MOV   R0,#0
   STR   R0,[R12,#work_SoundActive%]    \ Flag finished

   LDMIA R13!,{R0-R12,PC}

\ ------------------

.rateChange%     \ Issue a call back to change the rate values

   STMDB R13!,{R0,R1,R14}

]
IF doCallBack% THEN
[OPT I%

   ADR   R0,rateChangeCallBack%
   LDR   R1,[R12,#work_privateWord%]

   SWI   "OS_AddCallBack"

   LDMIA R13!,{R0,R1,PC}


]
ELSE
[OPT I%

   MOV   R0,R5   \ New frequency
   BL    newRate%

   LDMIA R13!,{R0,R1,PC}

]
ENDIF
[OPT I%


\ ---------


]
IF doCallBack% THEN
[OPT I%


.rateChangeCallBack%

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R12]         \ Get workspace pointer

   \     First get current sample frequency and sample period
   \     This is provided by the SampleRate routine

   MOV   R0,#0          \ Function code read

   BL    newSampleRate%

   LDMIA R13!,{R0-R12,PC}

]
ENDIF
[OPT I%


\ ---------------- Handler stuff ---------------

.handler% \ Dummy fill code
          \ Used to pass on control to chain of handlers
          \ The flags indicate which handlers to call
          \ There are three types - immediate, callback and process
          \ On entry:
          \    R0 = parameter, this should be the SharedSound R12 value
          \    R1 = base of buffer
          \    R2 = end of buffer
          \    R3 = flags
          \    R4 = sample frequency
          \    R5 = sample period
          \    R6 = Handler type

          \ Added by SharedSound before calling handlers

          \    R6 = fraction step
          \    R7 = LR Volume

   STMDB R13!,{R0-R2,R4-R12,R14}

   \ Now call each handler in turn, if they match the flag type

   MOV   R11,R6 \ Handler type

   ADD   R8,R12,#work_handlerTable%       \ Address of table
   MOV   R9,#handlerMax%                  \ Handler count

.handlerLoop%

   LDR   R10,[R8,#handler_Type%]
   CMP   R10,R11
   BNE   handlerNext%

   LDR   R10,[R8,#handler_Address%]        \ Does this slot contain a handler?
   CMP   R10,#0
   BEQ   handlerNext%

   STMDB R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved

   LDR   R0,[R8,#handler_Parameter%]
   LDR   R6,[R8,#handler_Fraction%]
   LDR   R7,[R8,#handler_VolumeScaled%]

   MOV   R14,PC
   MOV   PC,R10                            \ Jump to address
\   MOVNV R0,R0

.handlerReturn%

   LDMIA R13!,{R1,R2,R4,R5,R8,R9,R11,R12}      \ Will need these preserved

.handlerNext%

   ADD   R8,R8,#handlerTableLen%
   SUBS  R9,R9,#1
   BNE   handlerLoop%


.handlerExit%

   LDMIA R13!,{R0-R2,R4-R12,PC}

\ ------------------- Call Back Handler routines

.work_CallBack_BufferVal% EQUD work_CallBack_Buffer%

\ ----

.addCallBackBuffer%  \ Get pointer to call back buffer if it exists
                     \ On entry:
                     \    R1 = base of buffer
                     \    R2 = end of buffer
                     \    R3 = flags
                     \    R4 = sample frequency
                     \    R5 = sample period
                     \ On exit:
                     \    call back data mixed in if there is some

   STMDB R13!,{R0-R12,R14}

   SUB   R6,R2,R1
   LDR   R7,[R12,#work_CallBack_BufferSize%]

   CMP   R6,R7

   \ If the buffer size has changed then need to make changes...

   STR   R6,[R12,#work_CallBack_BufferSize%]

   LDR   R5,[R12,#work_CallBack_BufferFullCount%]  \ Are there any full buffers?
   CMP   R5,#0
   BGT   addCallBackBuffer_OK%

   \ Need to flag an overrun

   LDR   R5,[R12,#work_callBack_Active%]  \ Is the old call back active?
   CMP   R5,#1

   \ If there are no full buffers and the call back is active then we have overrun

   LDREQ R7,[R12,#work_callBack_Count%]   \ If so then increment count and return
   ADDEQ R7,R7,#1
   STREQ R7,[R12,#work_callBack_Count%]

   \ Need to do a volume shift on the buffer to effectivly mix an empty buffer
   \ into the existing data
   \ This avoids volume fluctuations

   \ R1 = Start of SoundDMA buffer
   \ R2 = End of SoundDMA buffer
   \ R6 = Length

.addCallBackBuffer_VolumeShiftLoop%

   LDMIA R1,{R3-R6}

   \ Shift volumes

]
work1%=11:work2%=12
FOR getReg%=3 TO 6
[OPT I%

  MOV   work1%,getReg%,LSL #16          \ Put right into work1
  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg

  MOV   work1%,work1%,ASR #1     \ DIV 2

  MOV   getReg%,getReg%,ASR #1   \ DIV 2

  TST   getReg%,#1<<15           \ Remove any low bit
  EORNE getReg%,getReg%,#1<<15

  ADD   getReg%,getReg%,work1%,LSR #16

]
NEXT
[OPT I%

   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBuffer_VolumeShiftLoop%

   B     addCallBackBuffer_Exit%   \ No data available

.addCallBackBuffer_OK%  \ There are buffers available so use one of these

   \ R1 = Start of SoundDMA buffer
   \ R2 = End of SoundDMA buffer
   \ R6 = Length

   LDR   R5,work_CallBack_BufferVal%
   ADD   R5,R5,R12
   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
   MLA   R0,R6,R7,R5                                    \ Buffer position

   \ R0 = Source buffer
   \ R1 = DMA buffer
   \ R2 = DMA buffer end
   \ R3 = Fill flags

   \ Copy across (mixing??)

   TST  R3,#1
   BNE  addCallBackBuffer_Mix%

   \ No mixing

.addCallBackBuffer_Loop%

   LDMIA R0!,{R3-R6}
   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBuffer_Loop%

   B    addCallBackBuffer_Final%


.addCallBackBuffer_Mix%

   STMDB R13!,{R12}

.addCallBackBufferMix_Loop%

   LDMIA R0!,{R3-R6}
   LDMIA R1,{R7-R10}

]
work1%=11:work2%=12
FOR getReg%=3 TO 6
mixReg%=getReg%+4
[OPT I%

  MOV   work1%,getReg%,LSL #16          \ Put right into work1
  EOR   getReg%,getReg%,work1%,LSR #16  \ and left in getReg

  MOV   work1%,work1%,ASR #1     \ DIV 2

  MOV   getReg%,getReg%,ASR #1   \ DIV 2

  TST   getReg%,#1<<15           \ Remove any low bit
  EORNE getReg%,getReg%,#1<<15

  MOV   work2%,mixReg%,LSL #16          \ Put right into work2
  EOR   mixReg%,mixReg%,work2%,LSR #16  \ and left in mixReg

  MOV   work2%,work2%,ASR #1     \ DIV 2

  MOV   mixReg%,mixReg%,ASR #1   \ DIV 2

  TST   mixReg%,#1<<15           \ Remove any low bit
  EORNE mixReg%,mixReg%,#1<<15

  \ Now mix

  ADD   getReg%,getReg%,mixReg%
  ADD   work1%,work1%,work2%

  ADD   getReg%,getReg%,work1%,LSR #16



]
NEXT
[OPT I%

   STMIA R1!,{R3-R6}

   CMP   R1,R2
   BLT   addCallBackBufferMix_Loop%

   LDMIA R13!,{R12}

.addCallBackBuffer_Final%

   \ Increment current SoundDMA buffer

   LDR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]
   LDR   R8,[R12,#work_CallBack_numCallBackBuffers%]
   ADD   R7,R7,#1
   CMP   R7,R8
   MOVGE R7,#0
   STR   R7,[R12,#work_CallBack_CurrentSoundBuffer%]

   \ Decrement full count

   LDR   R8,[R12,#work_CallBack_BufferFullCount%]
   SUBS  R8,R8,#1
   MOVLT R8,#0
   STR   R8,[R12,#work_CallBack_BufferFullCount%]

.addCallBackBuffer_Exit%

   LDMIA R13!,{R0-R12,PC}

\ -------------------------------

.callBackHandlerProcess%
          \ On entry:
          \    R1 = base of buffer
          \    R2 = end of buffer
          \    R3 = flags
          \    R4 = sample frequency
          \    R5 = sample period

   STMDB R13!,{R0-R12,R14}

   SUB   R6,R2,R1
   STR   R6,[R12,#work_CallBack_BufferSize%]
   STR   R3,[R12,#work_CallBack_Flags%]
   STR   R4,[R12,#work_CallBack_SampleFrequency%]
   STR   R5,[R12,#work_CallBack_SamplePeriod%]

   LDR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag
   CMP   R5,#1
   BEQ   callBackHandlerProcess_Exit%

   MOV   R5,#1
   STR   R5,[R12,#work_callBack_Active%]  \ Set the call back active flag

   \ Set up new call back

]
IF doCBAI% THEN
[OPT I%

   \ Either by CBAI

   LDR   R0,[R12,#work_CBAIActive%]
   CMP   R0,#1

   ADREQ R0,CBAIRoutine%
   STREQ R0,[R12,#work_PollWord%]
   BEQ   callBackHandlerProcess_Exit%

   \ Or by old style Call backs

]
ENDIF
[OPT I%

   ADR   R0,doHandlerCallBack%
   LDR   R1,[R12,#work_privateWord%]

TEQ   PC,PC
MRSEQ R9,CPSR          \ if in 32-bit mode, R9 = CPSR
MOVNE R9,PC            \ if in 26-bit mode, R9 = PC+PSR
ORR   R8,R9,#SVC_Mode% \ preserves 32-bitness
MSREQ CPSR_c,R8
TEQNEP R8,#0
MOV   R0,R0
STMFD R13!,{R14}

   SWI   "XOS_AddCallBack"

LDMFD R13!,{R14}
TEQ   PC,PC
MSREQ CPSR_c,R9
TEQNEP R9,#0
MOV   R0,R0

.callBackHandlerProcess_Exit%

   LDMIA R13!,{R0-R12,PC}

\ -------



\ ---------------

.doHandlerCallBack%  \ Called by call back system
                     \ Needs to call the handler with the right parameters

   STMDB R13!,{R0-R12,R14}

   LDR   R12,[R12]

]
IF debug% THEN
[OPT I%
\ If you uncomment this, uncomment the switch to SVC mode in CBAIRoutine% too
\    SWI "XOS_WriteS"
\    EQUS "Handler call back"+CHR$(0):ALIGN
\    SWI  "XOS_NewLine"
]
ENDIF
[OPT I%

   \ From the start and end get the length and offset into the buffer
   \ by the current OutBuffer value

   LDR   R10,[R12,#work_CallBack_BufferSize%]
   LDR   R0,[R12,#work_privateWord%]
   LDR   R3,[R12,#work_CallBack_Flags%]
   LDR   R4,[R12,#work_CallBack_SampleFrequency%]
   LDR   R5,[R12,#work_CallBack_SamplePeriod%]

.doHandlerCallBack_Loop%

   \ R10 = Buffer length

   LDR   R2,work_CallBack_BufferVal%
   ADD   R2,R2,R12
   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
   MLA   R1,R10,R7,R2                              \ Buffer address

   ADD   R2,R1,R10

   MOV   R3,#0                           \ Buffer invalid

   LDR   R8,[R12,#work_CallBackHandlers%]
   CMP   R8,#0
   MOVNE R6,#handlerType_CallBack%
   BLNE  handler%

   LDR   R8,[R12,#work_ProcessHandlers%]
   CMP   R8,#0
   MOVNE R6,#handlerType_Process%
   BLNE  handler%

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; disable interrupts
   TEQ   PC,PC
   MRSEQ R8,CPSR
   MOVNE R8,PC
   ORREQ R9,R8,#I32flag%
   ORRNE R9,R8,#Iflag%
   MSREQ CPSR_c,R9
   TEQNEP R9,#0
]
ENDIF
[OPT I%

   \ increment full count
   \ Increment out buffer

   LDR   R7,[R12,#work_CallBack_CurrentOutBuffer%]
   LDR   R9,[R12,#work_CallBack_numCallBackBuffers%]
   ADD   R7,R7,#1
   CMP   R7,R9
   MOVGE R7,#0
   STR   R7,[R12,#work_CallBack_CurrentOutBuffer%]

   LDR   R7,[R12,#work_CallBack_BufferFullCount%]
   ADD   R7,R7,#1
   CMP   R7,R9
   MOVGT R7,R9
   STR   R7,[R12,#work_CallBack_BufferFullCount%]

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; restore interrupt state
   TEQ   PC,PC
   MSREQ CPSR_c,R8
   TEQNEP R8,#0
]
ENDIF
[OPT I%

   \ Check for full count = max
   \ Loop round if not

   CMP   R7,R9
   BLT   doHandlerCallBack_Loop%

   \ Otherwise we have filled all the buffers and can return

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; disable interrupts
   TEQ   PC,PC
   MRSEQ R8,CPSR
   MOVNE R8,PC
   ORREQ R9,R8,#I32flag%
   ORRNE R9,R8,#Iflag%
   MSREQ CPSR_c,R9
   TEQNEP R9,#0
]
ENDIF
[OPT I%

   MOV   R5,#0
   STR   R5,[R12,#work_callBack_Active%]  \ Call back completed

]:IF NOT CBAIDisableInt% THEN
[OPT I%

   ; restore interrupt state
   TEQ   PC,PC
   MSREQ CPSR_c,R8
   TEQNEP R8,#0
]
ENDIF
[OPT I%

   LDMIA R13!,{R0-R12,PC}


\ ---------------

.clearCallBackBuffer%  \ Initialise the call back buffer to 0


     STMDB R13!,{R0-R12,R14}

     MOV   R0,#0
     MOV   R1,#0
     MOV   R2,#0
     MOV   R3,#0

     LDR   R4,work_CallBack_BufferVal%
     ADD   R4,R4,R12
     ADD   R5,R4,#callBackBufferLen%

.clearCallBackBuffer_Loop%

     STMIA R4!,{R0-R3}
     CMP   R4,R5
     BLT   clearCallBackBuffer_Loop%

     LDMIA R13!,{R0-R12,PC}


\ ---------------

.setHandlerType%  \ Set the corresponding bit for this handler's number & type
                  \ On entry:
                  \    R0 = Handler number
                  \    R4 = Type

    STMDB R13!,{R0-R4,R14}

    MOV   R1,#1
    MOV   R0,R1,LSL R0          \ As a bit

    CMP   R4,#handlerType_Immediate%
    LDREQ R1,[R12,#work_ImmediateHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_ImmediateHandlers%]

    CMP   R4,#handlerType_CallBack%
    LDREQ R1,[R12,#work_CallBackHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_CallBackHandlers%]

    CMP   R4,#handlerType_Process%
    LDREQ R1,[R12,#work_ProcessHandlers%]
    ORREQ R1,R1,R0
    STREQ R1,[R12,#work_ProcessHandlers%]

    LDMIA R13!,{R0-R4,PC}

\ ---------

.clearHandlerType%  \ Clear the corresponding bit for this handler's number & type
                    \ On entry:
                    \    R0 = Handler number
                    \    R4 = Type

    STMDB R13!,{R0-R4,R14}

    MOV   R1,#1
    MOV   R0,R1,LSL R0          \ As a bit

    CMP   R4,#handlerType_Immediate%
    LDREQ R1,[R12,#work_ImmediateHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_ImmediateHandlers%]

    CMP   R4,#handlerType_CallBack%
    LDREQ R1,[R12,#work_CallBackHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_CallBackHandlers%]

    CMP   R4,#handlerType_Process%
    LDREQ R1,[R12,#work_ProcessHandlers%]
    BICEQ R1,R1,R0
    STREQ R1,[R12,#work_ProcessHandlers%]

    LDMIA R13!,{R0-R4,PC}


\ -------------------- CBAI -----------------

]
IF doCBAI% THEN
[OPT I%

.InstallCBAI%  \ Install the CBAI stuff if module exists

     STMDB R13!,{R0-R12,R14}

     MOV   R0,#0
     STR   R0,[R12,#work_PollWord%]

     MOV   R0,#0
     ADR   R1,CBAIString%
     SWI   "XOS_SWINumberFromString"

     MOVVC R0,#1
     MOVVS R0,#0
     STR   R0,[R12,#work_CBAIActive%]

     ADDVC R0,R12,#work_PollWord%
     MOVVC R1,#&100000       \ Scheduling class
     LDRVC R2,[R12,#work_privateWord%]
     SWIVC "XCBAI_RegisterPollWord"

     LDMIA R13!,{R0-R12,PC}

\ -----------------

.CBAIString% EQUS "CBAI_RegisterPollWord"
             EQUB 0
             ALIGN

\ -----------------

.RemoveCBAI% \ De-register the CBAI pollword

     STMDB R13!,{R0-R12,R14}

     LDR   R0,[R12,#work_CBAIActive%]
     CMP   R0,#1

     ADDEQ R0,R12,#work_PollWord%
     SWIEQ "XCBAI_DeregisterPollWord"

     MOV   R0,#0
     STR   R0,[R12,#work_CBAIActive%]

     LDMIA R13!,{R0-R12,PC}

\ -----------------

.CBAIRoutine%  \ Call back routine to call call back addresses

     STMDB R13!,{R0-R12}

\     TEQ   PC,PC
\     MRSEQ R9,CPSR
\     MOVNE R9,PC
\     ORR   R8,R9,#SVC_mode%
\     MSREQ CPSR_c,R8
\     TEQNEP R8,#0
\     MOV   R0,R0
\     STMFD R13!,{R14}

]:IF CBAIDisableInt% THEN
[OPT I%

     ; disable interrupts
     TEQ   PC,PC
     MRSEQ R8,CPSR
     MOVNE R8,PC
     ORREQ R9,R8,#I32flag%
     ORRNE R9,R8,#Iflag%
     MSREQ CPSR_c,R9
     TEQNEP R9,#0
]
ENDIF
[OPT I%

     BL    doHandlerCallBack%

]:IF CBAIDisableInt% THEN
[OPT I%

     ; restore interrupt state
     TEQ   PC,PC
     MSREQ CPSR_c,R8
     TEQNEP R8,#0
]
ENDIF
[OPT I%

\     LDMFD R13!,{R14}
\     TEQ   PC,PC
\     MSREQ CPSR_c,R9
\     TEQNEP R9,#0
\     MOV   R0,R0

     LDMIA R13!,{R0-R12,PC}

\ -----------------
]
ENDIF
[OPT I%

]
ENDPROC

