/* File:    main.c
 * Purpose: SoundCtrl module initialisation and finalisation entry points
 * Author:  Timothy Roddis
 * History: 22-Aug-9: TGR: created
 */

/* ANSI headers */

#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <locale.h>

/* RISC OS headers */

#include "kernel.h"
#include "swis.h"

/* Commonlib headers */

#include "defines.h"
#include "dbmalloc.h"
#include "debug.h"
#include "msgs.h"
#include "swiextra.h"

/* Local CDFSDriver headers */

#include "module.h"
#include "globals.h"
#include "errors.h"

#include "ss.h"
#include "irq.h"
#include "delay.h"

static _kernel_oserror *init_pnp (void);

/* Initialise modules.
 *
 * on entry:
 *    cmd_tail is the command tail (ignored)
 *    podule_base  (ignored)
 *    pw is the private word (ignored)
 *
 * on exit:
 *    module has successfully initialised or else and error block is returned
 */

_kernel_oserror *main_initialise (char *cmd_tail, int podule_base, void *pw) {

   int i;
   _kernel_oserror     *e;
#ifndef ROM
    extern int messages_file(void);
#endif

   DEBUG debug_set_var_names (Module_Title"$Debug", Module_Title"$HexDump");

   DEBUG debug_output ("i", Module_Title": INITIALISING\n");

   IGNORE (cmd_tail);
   IGNORE (podule_base);
   IGNORE (pw);

#ifdef ROM
   external messages file?
#endif


#ifndef ROM
   if ((e = _swix (ResourceFS_RegisterFiles, I0, messages_file())) != NULL) {
     return e; // Could be made NULL to protect module against future inability to kill it
   }
#endif

   msgs_open_file("Resources:Resources."Module_Title".Messages");

   for (i = 0; i < sizeof global_dma / sizeof (GlobalDMAChan); i++) {
     global_dma[i].reg_handle = -1; /* Okay, so it's a hack */
   }

   e = init_pnp ();

   if (e) return e;

   DEBUG debug_output ("i", Module_Title": INITIALISATION COMPLETE (pw is %08x, *pw is %08x)\n", pw, *(unsigned*)pw);

   return NULL;
}

_kernel_oserror *main_finalise (int fatal, int podule_base, void *pw) {

//   _kernel_oserror     *e;
    int i;
#ifndef ROM
    extern int       messages_file(void);
#endif

   DEBUG debug_output ("i", Module_Title": FINALISING\n");

   IGNORE (fatal);
   IGNORE (podule_base);
   IGNORE (pw);

   /* check through DMA handles, deregistering any set up */

   for (i = 0; i < sizeof global_dma / sizeof (GlobalDMAChan); i++) {
     if (global_dma[i].reg_handle != -1) {

       if (global_dma[i].tag) {
         _swix (DMA_TerminateTransfer, I0|I1, 0, global_dma[i].tag);
       }

       DEBUG debug_output ("i", Module_Title": deregistering internal channel %d, handle %08x\n",
                           i, global_dma[i].reg_handle);

       _swix (DMA_DeregisterChannel,
              I0,
              global_dma[i].reg_handle);
     }
   }
#if AD1816_EnableIRQs
     /* release these vectors, just in case we had claimed them */

#if AD1816_Podule
     _swix (OS_ReleaseDeviceVector, I0||I1|I2|I3|I4,
            OS_Devices_ExpansionCardIRQ,
            irq_handle_play,
            *(unsigned int *)pw,
            SS_IRQStatus,
            SS_PI);
     _swix (OS_ReleaseDeviceVector, I0||I1|I2|I3|I4,
            OS_Devices_ExpansionCardIRQ,
            irq_handle_capture,
            *(unsigned int *)pw,
            SS_IRQStatus,
            SS_CI);
#else
kjhkjhdg
#endif
#endif

   msgs_close_file();

//   dbmalloc_chkheap();

#ifndef ROM
   _swix (ResourceFS_DeregisterFiles, I0, messages_file());

//   DEBUG if (e) debug_output ("i", "CDFSDriver: error deregistering: %d, \"%s\"\n", e->errnum, e->errmess);

#endif

   DEBUG debug_output ("i", Module_Title": FINALISATION COMPLETE\n");

   return NULL;
}

_kernel_oserror *init_pnp (void) {

#if TRUE
  unsigned int i, csn;
  Bool flag;

//  *PNP_Addr  = PNP_CSN;
//  DEBUG debug_output ("i", Module_Title": CSN is %d\n", *PNP_Read);
//  if (*PNP_Read) {//if (*PNP_Read == AD1816_CSN) {
//    DEBUG debug_output ("i", Module_Title": Already initialised\n");
//     return NULL;
//  }

  *PNP_Addr  = PNP_CfgCtrl;
  *PNP_Write = PNP_CfgCtrl_Reset | PNP_CfgCtrl_WaitForKey | PNP_CfgCtrl_ResetCSN;

  delay_loop (PNP_DelayTime);

  *PNP_Addr = 0;
  *PNP_Addr = 0;

  for (i=0; i < sizeof PNP_LFSRKey / sizeof (char); i++) {
    *PNP_Addr = PNP_LFSRKey[i];
  }
  *PNP_Addr  = PNP_Wake;
  *PNP_Write = 0;

  *PNP_Addr  = PNP_SetReadPort;
  *PNP_Write = PNP_ConvertToISA (PNP_Read)>>2;

  *PNP_Addr = PNP_Isolate;

  flag = FALSE;

  for (i=0; i < 72 && !flag; i++) {
    unsigned int a,b;

    a = *PNP_Read;
    b = *PNP_Read;

    if (a == PNP_Isolation_Sequence (0) && b == PNP_Isolation_Sequence (1)) {
      flag = TRUE;
    }
  }
  if (!flag) {
    DEBUG debug_output ("i", Module_Title": hardware not found\n");

//    return msgs_make_error (Error_HWNotFound);
  }

  *PNP_Addr  = PNP_CSN;
  *PNP_Write = AD1816_CSN;

  csn = *PNP_Read;

  DEBUG debug_output ("i", Module_Title": CSN = %d\n", csn);

  *PNP_Addr  = PNP_Wake;
  *PNP_Write = AD1816_CSN;

  *PNP_Addr  = PNP_LogDev;
  *PNP_Write = AD1816_LogDev_Codec;

  *PNP_Addr  = IO_DescHi(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_SBBase) >> 8;

  *PNP_Addr  = IO_DescLo(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_SBBase) & 0xff;

  *PNP_Addr  = IO_DescHi(1);
  *PNP_Write = PNP_ConvertToISA (AD1816_AdlibBase) >> 8;

  *PNP_Addr  = IO_DescLo(1);
  *PNP_Write = PNP_ConvertToISA (AD1816_AdlibBase) & 0xff;

  *PNP_Addr  = IO_DescHi(2);
  *PNP_Write = PNP_ConvertToISA (AD1816_SSBase) >> 8;

  *PNP_Addr  = IO_DescLo(2);
  *PNP_Write = PNP_ConvertToISA (AD1816_SSBase) & 0xff;

  *PNP_Addr  = IRQ_ReqDesc(0);
  *PNP_Write = AD1816_IRQ;

  *PNP_Addr  = IRQ_TypeDesc(0);
  *PNP_Write = AD1816_IRQType;

  *PNP_Addr  = DMA_ChanDesc(0);
  *PNP_Write = AD1816_DMA_Playback;

  *PNP_Addr  = DMA_ChanDesc(1);
  *PNP_Write = AD1816_DMA_Capture;

  *PNP_Addr  = PNP_Activate;
  *PNP_Write = PNP_Activate_Activate;

  *PNP_Addr  = PNP_LogDev;
  *PNP_Write = AD1816_LogDev_MIDI;

  *PNP_Addr  = IO_DescHi(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_MIDIBase) >> 8;

  *PNP_Addr  = IO_DescLo(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_MIDIBase) & 0xff;

  *PNP_Addr  = IRQ_ReqDesc(0);
  *PNP_Write = MIDI_IRQ;

  *PNP_Addr  = IRQ_TypeDesc(0);
  *PNP_Write = MIDI_IRQType;

  *PNP_Addr  = PNP_Activate;
  *PNP_Write = PNP_Activate_Activate;

  *PNP_Addr  = PNP_LogDev;
  *PNP_Write = AD1816_LogDev_GamePort;

  *PNP_Addr  = IO_DescHi(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_GameBase) >> 8;

  *PNP_Addr  = IO_DescLo(0);
  *PNP_Write = PNP_ConvertToISA (AD1816_GameBase) & 0xff;

  *PNP_Addr  = PNP_Activate;
  *PNP_Write = PNP_Activate_Activate;

  *PNP_Addr  = PNP_CfgCtrl;
  *PNP_Write = PNP_CfgCtrl_WaitForKey;

  delay_loop (PNP_DelayTime);

  *SS_IndAddr = SSInd_ChipCfg;
  SS_Write16(SS_IndData, SS_Read16(SS_IndData) & ~SSInd_CDE | SSInd_WSE | SSInd_CNP);

  *SS_IndAddr = SSInd_HWVol;
  SS_Write16(SS_IndData, 0);
#endif

  return NULL;
}
