#define DIAGS 1
#undef DIAGS
/* filter.c */
#include <stdio.h>

#include "mpa.h"
#include "fxptparams.h"
#include "soundtypes.h"
#include "sdata.h"
#include "filter.h"
#include "use_asm.h"


#define WCSHIFT	16			/* for coeffs as rep'd below, 1.0 = 65536 */
#define WCADJ	2			/* adjustment to fit in storage and also prods in 32-bit accumulator */
#define WCSCALE (WCSHIFT-WCADJ)		/* to scale back acc for result */

#define WCHALF 	(1 << (WCADJ-1))
#define X(c) 	(((c)+WCHALF) >> WCADJ)

#define WCOFFSET (1 << WCSCALE-1)
#define WDESCALE(x) ((x) >> WCSCALE)	/* assuming x was initialised to WCOFFSET before summation */
#define DESCALE_CLIP(x,d) { int ax_ = (x) >> WCSCALE, t = ax_>>31;  \
			    if ((ax_>>15) != t) ax_ = 0x7FFF ^ (unsigned int)t >> 16; \
			    d = ax_; }

#define FORMA 2
#define FORMC 3
#define FORMD 1

#define M1 (FORMA << 0 | FORMC << 2 | FORMC << 4 | FORMC << 6)
#define M2 (FORMA << 0 | FORMC << 2 | FORMC << 4 | FORMA << 6)
#define M3 (FORMA << 0 | FORMD << 2 | FORMC << 4 | FORMA << 6)

#define A(a,b) X(a),X(b)
#define A1(a,b) (M1<<8 | X(a)), X(b)
#define A2(a,b) (M2<<8 | X(a)), X(b)
#define A3(a,b) (M3<<8 | X(a)), X(b)
#define B(a,b) X(a), X(b)
#define C(a,b) X(a), X(b)
#define D(a,b) X(a), X(b)

windowc window_G16[8+8+15*16] =
{
     X(75038), X(29), X(213), X(459), X(2037), X(5153), X(6574), X(37489), /* w256, w32,w64,...w224 */
     X(104), X(1567), X(9727), X(64019), X(9975), X(45), X(146), X(5),     /* w48, w112, w176, w240, w208, w144, w80, w16 */

/*	 A		B		C		B		C		B		C		B       */
     A1(1,   26),  B( 31,  208),   C(218,  401),  B( 519, 2063),  C(2000, 4788),  B(5517, 7134),  C(5959,35640), B(39336, 74992),   
     A1(1,   24),  B( 35,  202),   C(222,  347),  B( 581, 2080),  C(1952, 4425),  B(5879, 7640),  C(5288,33791), B(41176, 74856),   
     A1(1,   21),  B( 38,  196),   C(225,  294),  B( 645, 2087),  C(1893, 4063),  B(6237, 8092),  C(4561,31947), B(43006, 74630),   
     A1(1,   19),  B( 41,  190),   C(227,  244),  B( 711, 2085),  C(1822, 3705),  B(6589, 8492),  C(3776,30112), B(44821, 74313),   
     A1(1,   17),  B( 45,  183),   C(228,  197),  B( 779, 2075),  C(1739, 3351),  B(6935, 8840),  C(2935,28289), B(46617, 73908),   
     A1(1,   16),  B( 49,  176),   C(228,  153),  B( 848, 2057),  C(1644, 3004),  B(7271, 9139),  C(2037,26482), B(48390, 73415),   
     A1(2,   14),  B( 53,  169),   C(227,  111),  B( 919, 2032),  C(1535, 2663),  B(7597, 9389),  C(1082,24694), B(50137, 72835),   
     A1(2,   13),  B( 58,  161),   C(224,   72),  B( 991, 2001),  C(1414, 2330),  B(7910, 9592),  C(  70,22929), B(51853, 72169),   

/*	A		B		C		B		C		B		A		B       */
     A2(2,   11),  B( 63,  154),   C(221,   36),  B(1064, 1962),  C(1280, 2006),  B(8209, 9750),  A( 998,21189), B(53534, 71420),   
     A2(2,   10),  B( 68,  147),   C(215,    2),  B(1137, 1919),  C(1131, 1692),  B(8491, 9863),  A(2122,19478), B(55178, 70590),
/*	A		B		D		B		C		B		A		B        */
     A3(3,    9),  B( 73,  139),   D(208,   29),  B(1210, 1870),   C(970, 1388),  B(8755, 9935),  A(3300,17799), B(56778, 69679),   
     A3(3,    8),  B( 79,  132),   D(200,   57),  B(1283, 1817),   C(794, 1095),  B(8998, 9966),  A(4533,16155), B(58333, 68692),   
     A3(4,    7),  B( 85,  125),   D(189,   83),  B(1356, 1759),   C(605,  814),  B(9219, 9959),  A(5818,14548), B(59838, 67629),   
     A3(4,    7),  B( 91,  117),   D(177,  106),  B(1428, 1698),   C(402,  545),  B(9416, 9916),  A(7154,12980), B(61289, 66494),   
     A3(5,    6),  B( 97,  111),   D(163,  127),  B(1498, 1634),   C(185,  288),  B(9585, 9838),  A(8540,11455), B(62684, 65290),
};


#if 0
int window_X16[16*16] =
{
     X(75038), X(29), X(213), X(459), X(2037), X(5153), X(6574), X(37489), /* w256, w32,w64,...w224 */
     X(104), X(1567), X(9727), X(64019), X(9975), X(45), X(146), X(5),     /* w48, w112, w176, w240, w208, w144, w80, w16 */

/*	 A		B		C		B		C		B		C		B       */
     A1(1,   26),  B( 31,  208),   C(218,  401),  B( 519, 2063),  C(2000, 4788),  B(5517, 7134),  C(5959,35640), B(39336, 74992),   
     A1(1,   24),  B( 35,  202),   C(222,  347),  B( 581, 2080),  C(1952, 4425),  B(5879, 7640),  C(5288,33791), B(41176, 74856),   
     A1(1,   21),  B( 38,  196),   C(225,  294),  B( 645, 2087),  C(1893, 4063),  B(6237, 8092),  C(4561,31947), B(43006, 74630),   
     A1(1,   19),  B( 41,  190),   C(227,  244),  B( 711, 2085),  C(1822, 3705),  B(6589, 8492),  C(3776,30112), B(44821, 74313),   
     A1(1,   17),  B( 45,  183),   C(228,  197),  B( 779, 2075),  C(1739, 3351),  B(6935, 8840),  C(2935,28289), B(46617, 73908),   
     A1(1,   16),  B( 49,  176),   C(228,  153),  B( 848, 2057),  C(1644, 3004),  B(7271, 9139),  C(2037,26482), B(48390, 73415),   
     A1(2,   14),  B( 53,  169),   C(227,  111),  B( 919, 2032),  C(1535, 2663),  B(7597, 9389),  C(1082,24694), B(50137, 72835),   
     A1(2,   13),  B( 58,  161),   C(224,   72),  B( 991, 2001),  C(1414, 2330),  B(7910, 9592),  C(  70,22929), B(51853, 72169),   

/*	A		B		C		B		C		B		A		B       */
     A2(2,   11),  B( 63,  154),   C(221,   36),  B(1064, 1962),  C(1280, 2006),  B(8209, 9750),  A( 998,21189), B(53534, 71420),   
     A2(2,   10),  B( 68,  147),   C(215,    2),  B(1137, 1919),  C(1131, 1692),  B(8491, 9863),  A(2122,19478), B(55178, 70590),
/*	A		B		D		B		C		B		A		B        */
     A3(3,    9),  B( 73,  139),   D(208,   29),  B(1210, 1870),   C(970, 1388),  B(8755, 9935),  A(3300,17799), B(56778, 69679),   
     A3(3,    8),  B( 79,  132),   D(200,   57),  B(1283, 1817),   C(794, 1095),  B(8998, 9966),  A(4533,16155), B(58333, 68692),   
     A3(4,    7),  B( 85,  125),   D(189,   83),  B(1356, 1759),   C(605,  814),  B(9219, 9959),  A(5818,14548), B(59838, 67629),   
     A3(4,    7),  B( 91,  117),   D(177,  106),  B(1428, 1698),   C(402,  545),  B(9416, 9916),  A(7154,12980), B(61289, 66494),   
     A3(5,    6),  B( 97,  111),   D(163,  127),  B(1498, 1634),   C(185,  288),  B(9585, 9838),  A(8540,11455), B(62684, 65290),
};
#endif

#if USE_ASM && 0
extern void filter_M  (sdata_M *data, int16 *out);
#else
# if 1 && 0

void filter_M (sdata_M * volatile data, int16 * volatile out)
{
}
# else
void filter_M  (sdata_M * volatile data, int16 * volatile out)
{
    windowc * volatile window = window_G16;
    windowc *wp;
    sdata_M * volatile dl;
    wp = window_G16;
    /* Compute out[0] and out[16] */
    if (1) {
	int ax;
	sdata_M *dh;
	int i, vl, vh, w;
	/* First out[0]:
	 * s00= +w256*g8s00 
	 *	-w032*g1s32 +w032*gFs32
	 *	+w064*g2s00 +w064*gEs00
	 *	-w096*g3s32 +w096*gDs32
	 *	+w128*g4s00 +w128*gCs00
	 *	-w160*g5s32 +w160*gBs32
	 *	+w192*g6s00 +w192*gAs00
	 *	-w224*g7s32 +w224*g9s32
	 */
	w = *wp++;			/* w256 */
	vl = data[8];
	ax = vl * w + WCOFFSET;
	dl = &data[1]; dh = &data[15];
	do
	{
	    vl = *dl++; vh = *dh--;
	    if (((int)wp & 2) != 0)		/* CHEAT: WE KNOW THAT window_G16 starts on 0 MOD 4 byte address */
		vl = -vl;
	    w = *wp++;
	    ax += (vl + vh) * w;
	} while (dl < dh);
	DESCALE_CLIP(ax, out[0]);
	/*
	 * Now compute out[16] from the s48 values from the input data:
	 * s16 = +w016*gFs48 -w048*g1s48 -w080*gDs48 -w112*g3s48 +w144*gBs48 -w176*g5s48 +w208*g9s48 -w240*g7s48 
	 *     = -w048*g1s48 -w112*g3s48 -w176*g5s48 -w240*g7s48 +w208*g9s48 +w144*gBs48 -w080*gDs48 +w016*gFs48 
	 * The coefficients are order as we need them for sequential access to the data values.  Accumulate
	 * the -ve of each product (for greater efficiency - uses MLA) and negate at the end.
	 */ 
	dl = &data[16*16*2+1];
	ax = WCOFFSET;
	for (i = 1 << 0; i < (1 << 8); i <<= 1)
	{
	    w = *wp++;
	    vl = *dl; dl += 2;
	    if (i & (1<<4 | 1<<5 | 1<<7))
		vl = -vl;
	    ax += vl * w;
	}
	DESCALE_CLIP(-ax, out[16]);
    }
    dl = &data[16*1*2+0]; 
    for (;;)
    {
	int32 al, ah;
	int map;
	uint32 wa, wb;
	sdata_M *dh;
	dh = dl + 15;
	al = WCOFFSET; ah = WCOFFSET;
	wa = *(uint32 *)wp; wp += 2; wb = wa >> 16; wa ^= wb << 16;
	map = wa >> 8; wa &= 0xFF;
	for (;;)
	{
	    int32 xl, xh;
	    xl = *dl++; xh = *dh--;
	    switch (map & 3)
	    {
	      case 0:			/* to fool the compiler */
	      case 5:
	      default:
		break;
	      case FORMA:
		al += wb * xh;
		ah += wa * xh;
		ah += wb * xl;
		xl = -xl;     
		al += wa * xl;
		break;
	      case FORMC:
		al += wa * xl;
		al += wb * xh;
		ah += wb * xl;
		xh = -xh;     
		ah += wa * xh;
		break;
	      case FORMD:
		/* form D */
		al += wa * xl;
		xl = -xl;     
		xh = -xh;     
		al += wb * xh;
		ah += wb * xl;
		ah += wa * xh;
		break;
	    }
	    /* Always followed by a form B pair */
	    wa = *(uint32 *)wp; wp += 2; wb = wa >> 16; wa ^= wb << 16;
	    xl = *dl++;
	    xh = *dh--;
	    al += wb * xh;
	    xl = -xl;     
	    xh = -xh;     
	    al += wa * xl;
	    ah += wa * xh;
	    ah += wb * xl;
	    map >>= 2;
	    if (map == 0) 
		break;
	    wa = *(uint32 *)wp; wp += 2; wb = wa >> 16; wa ^= wb << 16;
	}
	dl = dl + 8 + 16;			/* step to end and skip the intermediate block */
	if (1) 
	{
	    int16 *op = out;
	    int i = ((wp - window) >> 4) - 1;
	    DESCALE_CLIP(al, op[i]);
	    DESCALE_CLIP(ah, op[32-i]);
	    if (i == 15)
		break;
	}
    }
}
# endif
#endif

/* EOF filter.c */

