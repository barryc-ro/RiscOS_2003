/* Module C interface */
/* SoundFX            */
/*
 * (C) Acorn NC 1997
 *
 * Author: Alberto Bonamico
 * Date:   14/3/97
 *
 * History:
 *
 * 14/3/97  AB    Coding complete
 *
 * This is the main source file for the SoundFX module for the Acorn NC 1.RCA
 * project
 */

/* SYSTEM INCLUDES */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <kernel.h>
#include <swis.h>

/* MACROS         */

#define IGNORE(p) (p=p)

/* CONSTANTS      */

#define MAX       50
#define MAX_LEN   128
#define MAX_ESA   11

#define PLAYING   1
#define DELETING  1
#define UPDATING  1

/* Strings        */

#define MAPFILE   "<SoundFXSounds$Path>EventMap\0"
#define SYSVAR    "SoundFXSounds$Path\0"
#define PATH      "Resources:$.Resources.SoundFX.Sounds.\0"
#define FILEPLAY        "fileplay -file \0"
#define FILESTOP        "fileplay -stop\0"
#define EVENT_ERROR     "Event not found\0"
#define FILE_ERROR      "File not found\0"
#define NEW             "New (event,file) added\0"
#define DELETED         "Event found and deleted\0"

/* reason codes for SoundFX SWI calls */

#define FX_VERSION 0
#define FX_PLAY    1
#define FX_STOP    2
#define FX_EVENT   3

/* reason codes for SoundFX line commands */

#define FXPLAY              0
#define FXTRIGGER           1
#define FXSTOP              2
#define FXEVENT             3
#define FXREMOVEEVENT       4
#define FXEVENTCLEARALL     5
#define FXLIST              6

/* reason codes for lookup procedure       */

#define LOOKUP_EVENT        0
#define LOOKUP_FILE         1
#define LOOKUP_OVERRIDE     2
#define LOOKUP_DELETE       3
#define LOOKUP_SHOW         4
#define LOOKUP_DEL_ALL      5
#define LOOKUP_LIST         6

/* GLOBALS             */

static _kernel_oserror SoundFX_error = { 0x4ef40, "SoundFX: Unknown SWI\n" };
static _kernel_oserror SoundFX_version = { 0x4ef40, "SoundFX: Version 1.00, 14 Mar 1997\n" };
static _kernel_oserror SoundFX_file_error = { 0x4ef40, "SoundFX: " FILE_ERROR };
static _kernel_oserror SoundFX_event_error = { 0x4ef40, "SoundFX: " EVENT_ERROR };
static _kernel_oserror SoundFX_event_file = { 0x4ef40, "SoundFX: event and file added\n" };
static _kernel_oserror SoundFX_event_deleted = { 0x4ef40, "SoundFX: event and file deleted\n" };
static _kernel_oserror SoundFX_delete_all = { 0x4ef40, "SoundFX: ALL event mappings deleted\n" };

struct event_table {
       char event[MAX_ESA];
       char file[MAX_LEN];
    } ev_tab[MAX];

/* FUNCTION PROTOTYPES */

int SoundFXPlay(char* string);
int SoundFXTrigger(char* string);
int SoundFXStop(void);
int SoundFXList(void);
int SoundFXEvent(char* string);
int SoundFXRemoveEvent(char* string);
int SoundFXEventClearAll(void);
char *lookup(int field, char* event);


/* FUNCTIONS    */

_kernel_oserror *SoundFX_swi(int swi_no, _kernel_swi_regs *in,_kernel_swi_regs *out, void *private_word)
{

 IGNORE(private_word);

 switch ( swi_no )
   {
   case FX_VERSION : /* SoundFX_Version , SYS 0x4ef40 */
          {
          return &SoundFX_version;
          }
   case FX_PLAY : /* SoundFX_Play , SYS 0x4ef41 */
          {
           if ( in->r[0] == 0)
            {
            if (SoundFXTrigger((char *) in->r[1]) == PLAYING )
               return (_kernel_oserror *) NULL;
            else
               return &SoundFX_event_error;
            }

           if ( in->r[0] == 1)
            {
             if ( SoundFXPlay((char *) in->r[1]) == PLAYING )
               return (_kernel_oserror *) NULL;
             else
               return &SoundFX_file_error;
            }
          }
   case FX_STOP : /* SoundFX_Stop , SYS 0x4ef42 */
          {
           SoundFXStop();
           return (_kernel_oserror *) NULL;
          }
   case FX_EVENT : /* SoundFX_Event , SYS 0x4ef43 */
          {
          switch ( in->r[0] )
           {
           case 0 :
            {
            if ( in->r[2] == -1 )
               {
                if ( lookup( LOOKUP_DEL_ALL, (char *) in->r[2] ) == NULL )
                   return &SoundFX_delete_all;
               }
            strcat((char *) in->r[2]," ");
            strcat((char *) in->r[2],(char *) in->r[1]);
            if ( SoundFXEvent( (char *) in->r[2] ) == UPDATING )
              return &SoundFX_event_file;
            else
              return &SoundFX_event_error;
            }
           case 1 :
                {
                if ( SoundFXRemoveEvent((char *) in->r[2]) == DELETING )
                   return &SoundFX_event_deleted;
                else
                   return &SoundFX_event_error;
                }
           case 2 :
                {
                if ( lookup( LOOKUP_SHOW, (char *) in->r[2] ) == NULL )
                   return &SoundFX_event_error;
                else
                   return NULL;
                }
           } /* switch */
          } /* case FX_EVENT */
   default : return &SoundFX_error;
   } /* switch */
}

_kernel_oserror *SoundFX_init(char* cmd_tail, int podule_base, void *pw)
{
  int len = 0;
  FILE *map;
  _kernel_oserror *err = NULL;
  int format=0,i=0,j=0;
  char *str,ch,*event_no,*event_name;

  IGNORE(podule_base);
  IGNORE(pw);

  len = strlen (PATH);

  err = _swix (OS_SetVarVal,_IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4), SYSVAR, PATH, len, 0, 4);

  if ( ( map=fopen(MAPFILE,"r") ) == NULL )
    {
    printf("Error while opening file %s \n",MAPFILE);
    exit(1);
    }

  fscanf(map,"%s %d\n",str,&format);

  while( !feof(map) )
  {
  ch = fgetc(map);
  if ( ch == '#' ) fgets(str,128,map);
  if ( ch == '0' )
     {
     event_no = ev_tab[i].event;
     fgets(str,128,map);

     event_no[0] = ch;

     for (j = 1; j < MAX_ESA-1;j++)
      {
      event_no[j] = str[j-1];
      }
     event_no[MAX_ESA-1] = '\0';

     event_name = ev_tab[i].file;

     j=10;
     while( str[j] != NULL )
      {
      event_name[j-10] = str[j];
      j++;
      }

     event_name[j-11] = '\0';
     strcpy(ev_tab[i].file,event_name);
     i++;
     }
   }

 fclose(map);
 return (_kernel_oserror *) NULL;
}

_kernel_oserror *SoundFX_commands(char *argv, int argc, int cmd_no, void *pw)
{

IGNORE(argc);
IGNORE(pw);

switch ( cmd_no )
   {
   case FXPLAY :
          {
          if ( SoundFXPlay(argv) != PLAYING )
          return &SoundFX_file_error;
          break;
          }
   case FXTRIGGER :
          {
          if ( SoundFXTrigger(argv) != PLAYING )
          return &SoundFX_event_error;
          break;
          }
   case FXSTOP :
          {
           SoundFXStop();
           break;
          }
   case FXEVENT :
          {
           SoundFXEvent(argv);
           break;
          }
   case FXREMOVEEVENT :
          {
           if ( SoundFXRemoveEvent(argv) != DELETING )
           return &SoundFX_event_error;
           break;
          }
   case FXEVENTCLEARALL :
          {
           if ( SoundFXEventClearAll() != DELETING )
           return &SoundFX_delete_all;
           break;
          }
   case FXLIST :
          {
           lookup(LOOKUP_LIST,NULL);
           break;
          }
   default :
           printf("Other commands\n");
   }
return NULL;
}

int SoundFXPlay(char* file)
{
  char *event,path[80],fileplay[80];

if ( (event = lookup(LOOKUP_FILE,file)) != NULL )
 {
 strcpy(path,PATH);
 strcat(path,event);

 strcpy(fileplay,FILEPLAY);
 strcat(fileplay,path);

 _swix (OS_CLI,_IN(0),fileplay);
 return PLAYING;
 }
 return NULL;
}

int SoundFXTrigger(char* event)
{
_kernel_oserror *err;
char *e=event;
char path[80],*file,fileplay[128];
int i=0;

 while (e[i] >= ' ' || e[i] == '\t')
 {
 e[i]=event[i];
 i++;
 }
 e[i]='\0';

if ( (file = lookup(LOOKUP_EVENT,event)) != NULL )
 {
 strcpy(path,PATH);
 strcat(path,file);
 strcpy(fileplay,FILEPLAY);
 strcat(fileplay,path);
 err = _swix (OS_CLI,_IN(0),fileplay);
 return PLAYING;
 }
return NULL;
}

int SoundFXStop()
{
 _kernel_oserror *err;
 char filestop[25];

strcpy(filestop,FILESTOP);
err = _swix (OS_CLI,_IN(0),filestop);

return NULL;
}

int SoundFXEvent(char* event)
{
 if ( lookup(LOOKUP_OVERRIDE,event) != NULL)
   return UPDATING;
 else
   return NULL;
}

int SoundFXRemoveEvent(char* event)
{
  if ( lookup(LOOKUP_DELETE,event) != NULL)
     return DELETING;
  else
     return NULL;
}

int SoundFXEventClearAll()
{
if ( lookup( LOOKUP_DEL_ALL, NULL) != NULL )
   return DELETING;
else
   return NULL;
}


char *lookup(int field, char* event)
{

char *file=event;
char *event_num=event;
int i=0,ref=0,j=0;

if (field == LOOKUP_EVENT)
 {
 while (event_num[i] >= ' ' || event_num[i] == '\t')
 {
 event_num[i]=event[i];
 i++;
 }
 event_num[i]='\0';

 for (i=0;i<MAX;i++)
     {
     if ( strcmp(ev_tab[i].file,"")==0) break;
     if ( strcmp(ev_tab[i].event,event_num)==0 )
        return ev_tab[i].file;
     }
  }

if (field == LOOKUP_FILE)
 {
 while (file[i] >= ' ' || file[i] == '\t')
 {
 file[i]=event[i];
 i++;
 }
 file[i]='\0';

 for (i=0;i<MAX;i++)
     {
     if ( strcmp(ev_tab[i].file,"")==0)
       return NULL;

     if ( strcmp(ev_tab[i].file,file)==0 )
        return ev_tab[i].file;
     }
 }

if (field == LOOKUP_OVERRIDE)
 {
  while (event_num[i] > ' ')
   {
   event_num[i]=event[i];
   i++;
   }
   event_num[i]='\0';
   ref = ++i;

   for (i=0;i<MAX;i++)
     {
     if ( strcmp(ev_tab[i].event,event_num)==0 )
       {
         j = ref;
        while (event_num[j] >= ' ')
         {
         file[j-ref]=event[j];
         j++;
         }
         file[j-ref]='\0';
        strcpy(ev_tab[i].file,file);

        return ev_tab[i].file;
       }
     else
     if ( strcmp(ev_tab[i].file,"")==0 || strcmp(ev_tab[i].file,"empty")==0 )
        {
        strcpy(ev_tab[i].event,event_num);

          j = ref;
         while (event_num[j] >= ' ')
          {
          file[j-ref]=event[j];
          j++;
          }
          file[j-ref]='\0';

        strcpy(ev_tab[i].file,file);
        return NEW;
      }
     }
 }

if (field==LOOKUP_DELETE)
 {
 while (event_num[i] >= ' ' || event_num[i] == '\t')
 {
 event_num[i]=event[i];
 i++;
 }
 event_num[i]='\0';

 for (i=0;i<MAX;i++)
     {
     if ( strcmp(ev_tab[i].file,"")==0) return NULL;
     if ( strcmp(ev_tab[i].event,event_num)==0 )
        {
        strcpy(ev_tab[i].event,"empty\0");
        strcpy(ev_tab[i].file,"empty\0");
        return DELETED;
        }
     }
  }

if (field==LOOKUP_SHOW)
 {
 while (event_num[i] >= ' ' || event_num[i] == '\t')
 {
 event_num[i]=event[i];
 i++;
 }
 event_num[i]='\0';

 for (i=0;i<MAX;i++)
     {
     if ( strcmp(ev_tab[i].file,"")==0) return NULL;
     if ( strcmp(ev_tab[i].event,event_num)==0 )
        {
        printf("Event: %s\n",ev_tab[i].event);
        printf("File : %s\n",ev_tab[i].file);
        return ev_tab[i].file;
        }
     }
  }

if (field==LOOKUP_DEL_ALL)
 {
 for (i=0;i<MAX;i++)
     {
     strcpy(ev_tab[i].event,"");
     strcpy(ev_tab[i].file,"");
     }
 return DELETED;
 }

if (field==LOOKUP_LIST)
 {
 for (i=0;i<MAX;i++)
     {
     if (strcmp(ev_tab[i].file,"")==0) return NULL;
     if (strcmp(ev_tab[i].file,"empty")!=0)
        printf("Event number: %s -+- File name: %s\n",ev_tab[i].event,ev_tab[i].file);
     }
 }

return NULL;
}

int main(int argc, char* argv[])
{
/*
_kernel_oserror *err = NULL;
 err = _swix (OS_CLI,_IN(0),"fileplay -file $.Video.Replay.Sound.Wav.HAL.HAL/wav");
*/
return 1;
}
