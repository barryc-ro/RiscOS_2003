#include "Desk.Event.h"
#include "Desk.LinkList.h"
#include "Desk.DeskMem.h"
#include "Desk.Error2.h"
#include "Desk.Debug.h"

#include "^.Task.h"
#include "^.Broad.h"



static void	Desk_Event_ClaimOrReleaseMessages( 
			Desk_event_claimorreleasefn	fn, 
			Desk_window_handle		window, 
			Desk_icon_handle		icon, 
			Desk_event_handler		handler, 
			void*				reference
			)
	{
	fn( Desk_event_USERMESSAGE, window, icon, handler, reference);
	fn( Desk_event_USERMESSAGERECORDED, window, icon, handler, reference);
	fn( Desk_event_ACK, window, icon, handler, reference);
	}






typedef struct	{
	Desk_linklist_header		header;
	Desk_message_action*		messages;
	TaskModule_broad_handler	handler;
	void*				reference;
	}
	TaskModule_broad_block;





static Desk_bool	TaskModule_Broad_MessageHandler( Desk_event_pollblock* event, void* reference)
	{
	TaskModule_broad_block*	b = (TaskModule_broad_block*) reference;
	int			i;
	
	Desk_Debug_Printf( Desk_error_PLACE "TaskModule_Broad_MessageHandler called for message action 0x%x\n", event->data.message.header.action);
	
	if ( !b->handler)	return Desk_bool_FALSE;
	
	for ( i=0; b->messages[i]; i++)	{
		if ( b->messages[i] == event->data.message.header.action)	{
			Desk_Debug_Printf( Desk_error_PLACE "Calling handler at 0x%p, pw=0x%p\n", b->handler, b->reference);
			TaskModule_Broad_CallHandler( event->type, &event->data.message, b->reference, b->handler);
			break;
			}
		}
	
	return Desk_bool_FALSE;
	}



void	TaskModule_Broad_Register( int flags, Desk_message_action* messages, TaskModule_broad_handler handler, void* reference)
	{
	TaskModule_block*		app	= &TaskModule_globalblock;
	TaskModule_broad_block*		b = NULL;
	int				nummess;
	int				i;
	
	Desk_Debug_Printf( Desk_error_PLACE "TaskModule_Broad_Register called\n");
	
	for ( nummess=0; messages[ nummess] != 0; nummess++)	{
		Desk_Debug_Printf( "0x%x\t", messages[ nummess]);
		}
	Desk_Debug_Printf( "\n");
	
	
	b = Desk_DeskMem_MallocType( TaskModule_broad_block);
	
	Desk_Error2_Try	{
		b->messages	= NULL;
		b->messages	= Desk_DeskMem_CallocType( 1+nummess, Desk_message_action);
		
		b->handler	= handler;
		b->reference	= reference;
		
		for ( i=0; i<nummess; i++)	b->messages[i] = messages[i];
		b->messages[i] = (Desk_message_action) 0;
		
		Desk_LinkList_AddToTail( &app->broad, &b->header);
		
		Desk_Event_ClaimOrReleaseMessages( Desk_Event_Claim, Desk_event_ANY, Desk_event_ANY, TaskModule_Broad_MessageHandler, b);
		}
	Desk_Error2_Catch	{
		Desk_DeskMem_Free( b->messages);
		Desk_DeskMem_Free( b);
		Desk_Error2_ReThrow();
		}
	Desk_Error2_EndCatch
	
	Desk_UNUSED( flags);
	}



void	TaskModule_Broad_DeRegister( int flags, Desk_message_action* messages, TaskModule_broad_handler handler, void* reference)
	{
	TaskModule_block*	app	= &TaskModule_globalblock;
	TaskModule_broad_block*	b;
	
	Desk_Debug_Printf( Desk_error_PLACE "TaskModule_Broad_DeRegister called\n");
	
	for	(
		b = Desk_LinkList_FirstItem( &app->broad);
		b;
		)
		{
		TaskModule_broad_block*	next = Desk_LinkList_NextItem( &b->header);
		if ( b->handler == handler && b->reference == reference)	{
			Desk_Event_ClaimOrReleaseMessages( Desk_Event_Release, Desk_event_ANY, Desk_event_ANY, TaskModule_Broad_MessageHandler, b);
			Desk_LinkList_Unlink( &app->broad, &b->header);
			Desk_DeskMem_Free( b->messages);
			Desk_DeskMem_Free( b);
			}
		b = next;
		}
	
	Desk_UNUSED( messages);
	Desk_UNUSED( flags);
	}


