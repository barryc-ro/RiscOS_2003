<html>
<head>
  <title>
    TaskModule Software Functional Specification
  </title>
</head>

<body BGCOLOR="#ffffff">


<center>
<h1>TaskModule Software Functional Specification</h1>
</center>

<p>
<hr>


<pre>
Distribution:	Acorn Restricted
Author(s):	Steve Cormie, <a href="mailto:jsmith@acorn.com">Julian Smith</a>
CVS ID:		$Id$
CVS revision:	$Revision$
CVS date:	$Date$
</pre>

<hr>

<h2> Contents </h2>
<ul>
  <li> <a href="#history">      History </a>
  <li> <a href="#outstanding">  Outstanding issues </a>
  <li> <a href="#overview">     Overview </a>
  <li> <a href="#user">         Programmer interface </a>
  <li> <a href="#enhancements"> Future enhancements </a>
</ul>

<hr>

<h2> <a name="history"> History </a> </h2>

<pre>
        0.01 JS  05-Jun-96 First created.
	0.02 SMC 11-Jun-96 Reorganised and firmed up.
	0.03 JS  14-Jun-96 Added SWI TaskModule_StartTask.
	0.04 JS  17-Jun-96 Added allocated SWI numbers.
	0.05 JS  24-Jun-96 Service-call handling moved into
	                   standard spec, and allocated SWI
	                   numbers.
	                   Added detection of broadcast messages
	                   for non-task modules.
	0.06 JS  24-Jun-96 Added message number for Message_Service.
	0.07 JS  24-Jun-96 TaskModule_DeRegisterService can now
	                   deregister all services calls registered
	                   with a task.
	0.08 JS  24-Jun-96 Only r0-r9 are sent in Message_Service.
	0.09 JS  27-Jun-96 Carified task handle=0 in 
	                   TaskModule_(De)RegisterService.
	0.10 JS  03 Jul 96 Now copes with Event 18 messages which
	                   are acknowledged.
	0.14 JS  13 Mar 1997	Added support for sending non-message
				events with TaskModule_SendMessage.
	0.15 JS  23 Apr 1997	Added TaskModule_ForceRedraw, for use
				by (for example) IconHigh.

             JS  18 Aug 1997	Added TaskModule_AddCallBack,
				TaskModule_RemoveCallBack

$Log$

</pre>

<hr>

<h2> <a name="outstanding"> Outstanding issues </a> </h2>
<P>

<hr>

<h2> <a name="overview"> Overview </a> </h2>
<P>
This document contains the software functional specification for the
TaskModule module.
<p>
The module is intended to give modules limited access to the Wimp
message system and, similarly, non-module Wimp tasks limited access to
OS notification functions eg. service calls.
<p>
This is done by enabling Wimp messages to be sent from non-tasks via a
TaskModule SWI, and the sending of Wimp messages containing service-call
information to those tasks that request them.
<P> Italicised text is used where issues are still to be decided or
where contents are liable to change.

<hr>

<h2> <a name="user"> Programmer interface </a> </h2>
<P>
TaskModule provides the following SWIs:
<P>
<h3>TaskModule_SendMessage (SWI &4D300)</h3>
<P>
Send a Wimp message from a non-task.
<P>
<pre>
<B>On entry:</B>
	r0 = flags:
		Bit 0:	If set, r6 specifies the event number, and r4-r5
			are ignored.
			Otherwise, r6 is ignored, and the event
			number used is 17 (r4=0) or 18 (r4 non-0).
		Bits 1-31 reserved (must be 0).
	r1 = message block as used by Wimp_SendMessage
	r2 = destination task handle/window (or 0 to broadcast)
	r3 = icon (c.f. Wimp_SendMessage)
	r4 = reply handler, or 0. Ignored if bit 0 of r0 is set.
	r5 = r12 value with which to call r4-function (ignored if r4=0
		or bit 0 of r0 is set).
	r6 = event number (ignored unless bit 0 of r0 is set).
<B>On exit:</B>
	All registers preserved
</pre>

<p>
This SWI enables modules to send Wimp messages and receive their
replies, without them having to be full module-tasks, optionally
providing the address of a function to be called with any reply.
It is intended for use by modules which only send messages infrequently,
to avoid the complexity of making the module into a task.

<p>
If bit 0 of r0 is 0 and r4 (reply handler) is not 0 then r4 is taken to
be a pointer to a function to call with any reply to the message which
was sent. TaskModule_SendMessage sends the message as event number 18,
so there will always be a reply of some sort (either event 17/18 from a
task, or event 19 denoting no reply) sent to the reply handler.

<p>
There is one exception to this - if a receiver acknowledges the message
with a reply with Wimp event number 19, this prevents any sort of reply
being sent back to TaskModule (See PRMs 3-197). This means that
TaskModule could potentially be left waiting for a reply forever.

<p>
To cope with this, TaskModule registers a handler for null-events as
well as message-events each time it sends a message. These event-claims
and the data associated with the message-reply detection are freed on
receipt of either a reply to the message or a null-event.

<p>
Because null-events are only delivered at lower pririty than messages,
this mechanism ensures that 1) TaskModule cleans up its data-structure
for acknowledged messages and 2) null-events are only actually delivered
to TaskModule when a message is acknowleged.

<p>
If bit 0 of r0 is 0 and r4 is 0 then TaskModule_SendMessage sends the
message as event number 17, and any reply is ignored.

<p>
If bit 0 of r0 is set, then TaskModule_SendMessage will send a Wimp
event with number specified by r6 (eg r6=1 sends a redraw event).
Although this can be used to send messages (r6=17 or 18), note that
TaskModule will not call any function pointed to by r4. This facility is
only available when bit 0 of r0 is unset.

<p>
The reply handler is called in SVC mode as follows, and is allowed to call
TaskModule SWIs.
<P>
<pre>
<B>On entry:</B>
	r0 = Wimp event number (17, 18 or 19)
	r1 = Pointer to message block
	r12= private word (r5 in original call to TaskModule_SendMessage)
<B>On exit:</B>
	All registers preserved
</pre>


<p>
<h3>TaskModule_StartTask (SWI &4D301)</h3>

<p>
<pre>
<b>On entry:</b>
	r0 = pointer to *command to be executed with Wimp_StartTask.
	r1 = pointer to function to be called with information
		returned in r0 by Wimp_StartTask, or 0.
	r2 = r12 value with which to call r1 function.
<b>On exit</b>
	All registers preserved.
</pre>

This provides non-tasks with access to the Wimp_StartTask SWI (PRM
3-177). 

Wimp_StartTask is called at some future time by the wimp-task
part of TaskModule, and any call-back function (address in r1 on entry)
is then called in SVC mode with the returned registers from
Wimp_StartTask.

The conditions for the call-back function are:

<pre>
<b>On entry</b>
	r0 = handle of task started, if it is still alive; 0 otherwise.
	r12= private word (r2 in original call to TaskModule_StartTask).
	SVC mode.
<b>On exit</b>
	All registers preserved
</pre>



<hr>

<P>
<H3>TaskModule_RegisterService (SWI &4D302)</H3>
<P>
Register interest in a service call.
<P>
<pre>
<B>On entry:</B>
	r0 = flags
	r1 = service number
	r2 = task handle
<B>On exit:</B>
	All registers preserved
</pre>
<p>
This is for use by non-module tasks which want to hear about a specific
service calls. The task is notified of service calls using the following Wimp
message.
<P>
<H3>Message_Service (&4D300) </H3>
<pre>
	r1+20 = register set r0-r9
</pre>

<p>
NB, only r0-r9 are sent because these are all that are available to
TaskModule from its CMHG veneer.

<p>
Calling with r2 (task handle) = 0 results in the message being broadcast.

<p>
The task deregisters interest in a service call using:
<P>
<H3>TaskModule_DeRegisterService (SWI &4D303)</H3>
<P>
De-register interest in a service call.
<P>
<pre>
On entry:
	r0 = flags
	r1 = service number, or 0 to deregister all the task's services.
	r2 = task handle
On exit:
	All registers preserved
</pre>
<p>

<p>
R0-r2 should be the same as in a previous call to
TaskModule_RegisterService (including the case where r2=0, messages are
broadcast), except that r1=0 deregisters all the task's service-call
registrations.

<p>
r2=0 only effects service-call broadcasts, not specific-task
service-call messages.

<p>
Thus r1=r2=0 will deregister all service-call broadcasts. It won't
de-register registrations for specific tasks.

TaskModule looks for applications quitting using Service_WimpCloseDown and de-
registers service call interest automatically. 

<p>
However, it is expected that applications call SWI
TaskModule_DeRegisterService before they exit for all registered
service-calls, eg with r1=0.

<P>



<p>
<H3>TaskModule_RegisterBroadcastMessage (SWI &4D304)</h3>
<p>
This is for use by non-task modules which want to hear about broadcast
Wimp messages. 
<pre> On entry:
	r0 = Flags (must be 0)
	r1 = Pointer to list of messages, terminated by 0 word.
	     An empty list means all broadcast messages, as in
	     Wimp_Initialise (see PRMs 5a-666)
	     r1 = 0 means no messages (which is pointless of course)
	r2 = Address of handler routine.
	r3 = r12 value with which to call handler.
On exit:
	All registers preserved.
</pre>

The handler routine is called in SVC mode as follows:
<pre>
<B>On entry:</B>
	r0 = Wimp event number (17, 18 or 19)
	r1 = Pointer to message block
	r12= private word (r3 in original call to TaskModule_RegisterBroadcastMessage)
<B>On exit:</B>
	All registers preserved
</pre>

The module can unregister interest in broadcast messages using:

<p>
<H3>TaskModule_UnRegisterBroadcastMessage (SWI &4D305)</h3>
<p>
<pre>
On entry:
	r0 = Flags (must be 0)
	r1 = Reserved (must be 0)
	r2 = Address of handler routine, as passed to
	     TaskModule_RegisterBroadcastMessage
	r3 = r12 value, as passed to TaskModule_RegisterBroadcastMessage
On exit:
	All registers preserved.
</pre>

It is impractical for TaskModule to keep track of modules quitting, so
all client modules' finalisation code <em>must</em> ensure that all
broadcast-handlers are unregistered.


<p>
<H3>TaskModule_ForceRedraw (SWI &4D306)</h3>
<p>
<pre>
On entry:
	r0-r4 as in Wimp_ForceRedraw (PRMs 3-150). ie:
		r0 = window handle
		r1-r4 = rectangle to be redrawn
On exit:
	All registers preserved.
</pre>

This calls <code>Wimp_ForceRedraw</code> with the given values of r0-r4,
from within TaskModule's task. This SWI is provided because one cannot
call <code>Wimp_ForceRedraw</code> from (for example) a transient
callback, because an application might be in a redraw loop at the time.
If this is attempted, the redrawing application can receive a
<code>Get_Rectangle not called correctly</code> error.


<p>
<h3>TaskModule_AddCallBack (0x4d307)</h3>
<p>
<pre>
	On entry:
		r0 = flags.
			Bit 0:	0 - call back after TaskModule
					receives a nonzero pollword
					event.
				1 - callback after TaskModule
					receives a null event.
			Other bits reserved - must be 0.
		r1 = address of handler routine.
		r2 = r12 value with which to call handler routine.
	On exit:
		all registers preserved.	
</pre>

<p>
The handler routine is called by TaskModule's task, either in response
to TaskModule's pollword being nonzero (r0 bit 0 unset), or when
TaskModule receives a null event (r0 bit 0 set).

<p>
r0 bit 0 unset can be used to guarantee that one isn't in the middle of
a redraw loop, allowing calls to (for example) Wimp_SetCaret.

<p>
r0 bit 0 set will return after a longer delay, as null events are sent
out at lower priority than nonzero pollword events. It can be used to
get control after sending a non-message event to a task with
TaskModule_SendMessage, when one wants control after the event has been
handled.

<p>
The conditions for the handler routine are:
	
<pre>
	On extry:
		ARM is in SVC mode.
		r12 = value passed in r2 to
			TaskModule_AddCallBack
	On exit:
		All registers preserved.
</pre>

This SWI can be called from within an interrupt
handler.




<H3>TaskModule_RemoveCallBack (0x4d308)</H3>
<p>
<pre>
	On entry:
		r0-r3 are values used in a previous call to
			TaskModule_AddCallBack.
	On exit:
		all registers preserved.
</pre>	

Cancels a callback added previously with TaskModule_AddCallBack.






<hr>


<h2> <a name="enhancements"> Future enhancements </a> </h2>
<p>
<H3>UpCall notification</H3>
<p>
It might be useful to make TaskModule provide non-module applications
with Wimp message versions of UpCalls, especially UpCall 3 (file being
modified).
</body>
</html>

