; s.Messages
;
; Handle incoming Wimp messages.

message_bounced
        Push    "LR"

        LDR     r0, [r1,#ms_action]
        LDR     r14, =Message_WindowInfo
        TEQ     r0,r14
        BEQ     bounced_WindowInfo

        Pull    "PC"

message_received

        Push    "LR"

        LDR     r0, [r1,#ms_action]             ; Get message action.

        LDR     r14,=Message_ModeChange
        TEQ     r0, r14
        BEQ     ModeChange

        LDR     r14,=Message_FontChanged
        TEQ     r0, r14
        BEQ     FontChanged

        LDR     r14,=Message_PaletteChange
        TEQ     r0, r14
        BEQ     PaletteChange

        LDR     r14,=Message_FilerSelection
        TEQ     r0, r14
        BEQ     FilerSelection

        TEQ     r0,#Message_DataLoad
        BEQ     DataLoad

        TEQ     r0,#Message_DataSaveAck
        BEQ     DataSaveAck

        LDR     r14,=Message_MenusDeleted
        TEQ     r0,r14
        BEQ     MenuDeleted

        LDR     r14, =Message_IconizeAt
        TEQ     r0, r14
        BEQ     IconizeAt

        LDR     r14, =Message_Iconize
        TEQ     r0, r14
        BEQ     Iconize

        LDR     r14, =Message_WindowInfo
        TEQ     r0, r14
        BEQ     WindowInfo

        LDR     r14, =Message_TaskNameIs
        TEQ     r0, r14
        BEQ     got_task_name

        LDR     r14, =Message_WindowClosed
        TEQ     r0, r14
        BEQ     close_window

        LDR     r14, =Message_TaskCloseDown
        TEQ     r0, r14
        BEQ     close_task

        TEQ     r0, #Message_SaveDesktop
        BEQ     DesktopSave


        LDR     r14, =Message_HelpRequest
        TEQ     r0, r14
        BEQ     HelpRequest

        TEQ     r0,#Message_Quit
        Pull    "PC",NE

        BL      FreeIconList
        BL      FreeBufferedList
        LDR     r0,mytaskhandle
        LDR     r1,taskidentifier
        SWI     XWimp_CloseDown
        MOV     r0,#0
        STR     r0,mytaskhandle
        SWI     XOS_Exit

        Pull    "PC"

DataLoad ROUT

        Debug   pi,"Data load "

      [ debugpi
        LDR     r14,[r1,#ms_size]
        ADD     r14,r1,r14
        SUB     r14,r14,#8
        LDMIA   r14,{r0,r14}
        Debug   pi,"x,y = ",r0,r14
      ]

        LDR     r0,[r1,#20]                     ; Window handle
        CMP     r0,#0
        BLT     IconbarDataLoad                 ; Iconbar !

        MOV     r0,#37                  ; Canonicalise path
        ADD     r1,r1,#44               ; -> path
        ADR     r2,dataarea
        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#256
        SWI     XOS_FSControl
        Pull    "PC",VS
        DebugS  pi,"Full Path is : ",r2
        RSB     r3,r5,#&100
        ADD     r3,r3,#1

        LDR     r6,NextPosition
        LDR     r7,NextPosition+4

        LDR     r1,backdrop_handle
        Debug   pi,"backdrop handle is ",r1
        BL      GetMonotonicID
        MOV     r0,#BufferReason_Remove
        BL      BufferIcon
        MOV     r0,#BufferReason_AddAtXY
        BL      BufferIcon

        ADD     r6,r6,#grid_x_spacing
        LDR     r14,DragBBox+8
        CMP     r6,r14
        LDRGE   r6,DragBBox
        SUBGE   r7,r7,#grid_y_spacing
        STR     r6,NextPosition
        STR     r7,NextPosition+4

        Pull    "PC"

IconbarDataLoad

        MOV     r0,#37                  ; Canonicalise path
        ADD     r1,r1,#44               ; -> path
        ADR     r2,dataarea
        MOV     r3,#0
        MOV     r4,#0
        MOV     r5,#256
        SWI     XOS_FSControl
        Pull    "PC",VS
        DebugS  pi,"Full Path is : ",r2
        RSB     r3,r5,#&100
        ADD     r3,r3,#1

        MOV     r1,#-2
        BL      GetMonotonicID
        MOV     r0,#BufferReason_Remove
        BL      BufferIcon
        MOV     r0,#BufferReason_AddNewTinyDir
        BL      BufferIcon

        Pull    "PC"

FilerSelection  ROUT

        ADD     r14,r1,#ms_data
        LDMIA   r14,{r0-r10}
        Debug   pi,"Filer selection BBOX: ",r0,r1,r2,r3
        Debug   pi,"Item width, height: ",r4,r5
        Debug   pi,"Display mode: ",r6
        Debug   pi,"Selection BBOX: ",r7,r8,r9,r10
; for small icon /full into, drag box will be wildly out.
        TST     r6,#3
        SUBNE   r14,r2,r0
        MOVNE   r14,r14, ASR #1
        SUBNE   r14,r14,#68+12

        ADDNE   r2,r2,r14
        ADDNE   r0,r0,r14
        ADDNE   R1,r1,#16
        ADDNE   r3,r3,#16

        ; Subtract grid_y_spacing from each y co-ord.
        SUB     r1, r1, #grid_y_spacing
        SUB     r3, r3, #grid_y_spacing

        ; Ensure box isn't off screen
        Push    "r4, r5"
        LDR     r5, Screen_x1
        SUB     r4, r2, r0
        CMP     r0, #0                 ; if x1<0
        MOVLT   r2, r4                 ;   then x2 = bbox_width
        MOVLT   r0, #0                 ;    and x1 = 0
        CMP     r2, r5                 ; if x2>screen_width
        SUBGT   r0, r5, r4             ;   then x1 = screen_width - bbox_width
        MOVGT   r2, r5                 ;    and x2 = screen_width

        LDR     r5, icon_bar_height
        SUB     r5, r5, #grid_y_spacing
        SUB     r4, r3, r1
        CMP     r1, r5                 ; if y1<icon_bar_height
        ADDLT   r3, r5, r4             ;   then y2 = icon_bar_height + bbox_height
        MOVLT   r1, r5                 ;    and y1 = icon_bar_height       
        LDR     r5, Screen_y1
        SUB     r5, r5, #grid_y_spacing
        CMP     r3, r5                 ; if y2>screen_height
        SUBGT   r1, r5, r4             ;   then y1 = screen_height - bbox_height
        MOVGT   r3, r5                 ;    and y2 = screen_height
        Pull    "r4, r5"

        ADR     r14,DragBBox
        STMIA   r14,{r0-r3}
                        
        ADR     r14,NextPosition
        STMIA   r14,{r0,r3}                     ; x0,y1 of next position

        Pull    "pc"


DataSaveAck     ROUT
        Debug   pi,"DataSaveAck received."

        LDR     r14,DragType
        TEQ     r14,#DragType_Save
        BEQ     Save_DataSaveAck


; Now that we have the directory to send to, start sending the files.

        ADD     r0,r1,#44
        ADR     r1,dest_directory
        BL      Copy_r0r1

00
        LDRB    r14,[r1],#-1
        CMP     r14,#"."
        BNE     %BT00
        MOV     r14,#0
        STRB    r14,[r1,#1]


        LDR     r10,Icon_list
01
        CMP     r10,#0
        Pull    "PC",EQ

        LDR     r3,DragWindow
        ADR     r1,dataarea
        LDR     r0,[r10,#ic_window]      ; Not in drag window.
        TEQ     r0,r3
        BNE     %FT10

        LDR     r0,[r10,#ic_icon]
        STR     r3,[r1]
        STR     r0,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "PC",VS

        LDR     r0,[r1,#24]
        TST     r0,#selected
        BEQ     %FT10                   ; Not selected

        MOV     r0,#0
        STR     r0,[r1,#8]
        CMP     r3,#0
        MOVGT   r0,#is_selected
        MOVLT   r0,#selected
        STR     r0,[r1,#12]
        SWI     XWimp_SetIconState      ; Deselect

        CMP     r3,#0
        LDRGE   r0,Pinboard_Selected
        LDRLE   r0,TinyDirs_Selected
        SUB     r0,r0,#1
        STRGE   r0,Pinboard_Selected
        STRLE   r0,TinyDirs_Selected
        Debug   pi,"Selected icons = ",r0

; Check for recursive copy

        MOV     r0,#-1
        SWI     XTerritory_UpperCaseTable
        Pull    "PC",VS
        MOV     r14,r0

        ADD     r0,r10,#ic_path
        ADR     r1,dest_directory
        DebugS  pi,"Source: ",r0
        DebugS  pi,"Dest: ",r1
02
        LDRB    r3, [r0], #1    ;       Source char
        LDRB    r3, [r14, r3]
        LDRB    r4, [r1], #1    ;       Dest char
        LDRB    r4, [r14, r4]
        CMP     r3,#32
        BLE     %FT03
        CMP     r3,r4
        BEQ     %BT02
        B       %FT04
03
        Debug   pi,"Check terminating char ",r4
        CMP     r4,#"."
        CMPNE   r4,#32
        ADRLE   r0,ErrorBlock_Pinboard_CopyRecursive
        BLLE    msgtrans_errorlookup
        Pull    "PC",VS

04
        Debug   pi,"Copy not recursive"
        BL      read_copy_options
        Debug   pi,"Copy options read"

; Check free RAM. If less than 64k then there is not enough for a FilerAction task to do the copying
        MOV     r0, #-1
        MOV     r1, #-1
        SWI     XWimp_SlotSize
        Pull    "PC",VS

        Debug   pi,"Next slot is ",r1

; If not enough for FilerAction then *COPY
        CMP     r1, #Filer_Action_Memory_CopyRename
        BLT     do_copy

        Debug   pi,"Enough memory"

; Check configuration bit, do * copy if no interactive filer copy.
        MOV     r0,#ReadCMOS
        MOV     r1,#FileSwitchCMOS
        SWI     XOS_Byte
        TST     R2,#4
        BNE     do_copy

        Debug   pi,"Configuration OK"

; Start FilerAction
        ADR     r0, FilerAction_command
        SWI     XWimp_StartTask
        Pull    "PC",VS
        CMP     r0, #0
        BEQ     do_copy

        Debug   pi,"Filer action started"

; Select source directory
        MOV     r8, r0
        ADD     r0, r10, #ic_path
        ADR     r1, dataarea
        BL      Copy_r0r1

        ADR     r14,dataarea
        MOV     r3,r14
05
        LDRB    r2,[r14],#1
        CMP     r2,#"."
        SUBEQ   r3,r14,#1
        CMP     r2,#32
        BGT     %BT05

        MOV     r0,#0
        STRB    r0,[r3],#1              ; Get just the directory name.

        MOV     r0, r8
        ADR     r1, dataarea
        DebugS  pi,"Source directory: ",r1
        SWI     XFilerAction_SendSelectedDirectory

; Select source file
        MOV     r1, r3
        DebugS  pi,"source file: ",r1
        SWI     XFilerAction_SendSelectedFile

; Perform the copy
; r1 = reason code, r2 = options, r3 -> destination directory, r4 = length of destination directory name

        MOV     r1, #Action_Copying
        LDR     r2, filer_action_copy_options
        ADR     r3, dest_directory
        MOV     r4, r3
06
        LDRB    r5, [r4], #1
        CMP     r5, #32
        BGT     %BT06
        SUB     r4, r4, r3
        MOV     r0,r8
        SWI     XFilerAction_SendStartOperation

10
        LDR     r10,[r10,#ic_next]
        B       %BT01

do_copy                                 ; There isn't enough memory to invoke FIlerAct or FilerAct is disabled
                                        ; by configuration.

        ADR     r0, Copy_command
        SWI     XWimp_CommandWindow
        Pull    "PC",VS

        ADR     r0, dataarea            ; Copy *copy command to dataarea
        ADR     r1, Copy_command
        BL      Copy_r1r0

        ADD     r1, r10, #ic_path       ; Append filename
        BL      Copy_r1r0

        MOV     r2, #" "                ; Change null terminator to space
        STRB    r2, [r0],#1
        ADR     r1, dest_directory
        BL      Copy_r1r0

; Append leafname
        MOV     r2, #"."
        STRB    r2, [r0],#1


        ADD     r3, r10, #ic_path
        MOV     r4,r3
11
        LDRB    r14,[r3],#1
        CMP     r14,#"."
        MOVEQ   r4,r3
        CMP     r14,#32
        BGT     %BT11

        MOV     r1, r4
        BL      Copy_r1r0


        MOV     r2, #" "                ; Append options
        STRB    r2, [r0],#1
        ADR     r1, copy_options
        BL      Copy_r1r0


        ADR     r0, dataarea            ; Do the copy
        SWI     XOS_CLI
        BVS     %FT20

        MOV     r0, #0
        SWI     XWimp_CommandWindow
        Pull    "PC",VS

        B       %BT10

20
        BL      ReportError
        MOV     r0,#-1
        SWI     XWimp_CommandWindow
        Pull    "PC"

FilerAction_command
        DCB     "Filer_action",0
Copy_command
        DCB     "Copy "
        ALIGN

        MakeErrorBlock  Pinboard_CopyRecursive
        ALIGN

IntMenuDeleted
        Push    "LR"
MenuDeleted

        LDR     r8,soft_selection_window
        CMP     r8,#0
        Debug   me,"Soft selection window is ",r8
        Pull    "PC",EQ

        ADRGT   r0,Pinboard_Selected
        ADRLT   r0,TinyDirs_Selected
        LDR     r1,[r0]
        SUBS    r1,r1,#1
        MOVMIS  r1,#0
        STREQ   r1,[r0]

        ADR     r1,dataarea
        STR     r8,[r1]
        LDR     r14,soft_selection_icon
        Debug   me,"icon is ",r14
        STR     r14,[r1,#4]
        MOV     r14,#0
        STR     r14,[r1,#8]
        CMP     r8,#0
        MOVLT   r14,#selected
        MOVGT   r14,#is_selected
        STR     r14,[r1,#12]
        SWI     XWimp_SetIconState
        Pull    "PC",VS

        MOV     r14,#0
        STR     r14,soft_selection_window

        Pull    "PC"

IconizeAt
        LDR     r0, [r1, #28]
        STR     r0, IconizeAtX
        LDR     r0, [r1, #32]
        STR     r0, IconizeAtY
        LDR     r0, [r1, #36]
        STR     r0, IconizeAtFlags        
        
        Pull    "PC"

filenamestring DCB "$.MB",0

Iconize

        LDR     r0,Pinboard_options
        TST     r0,#PinboardOption_NoIconize
        Pull    "PC",NE

        LDR      R0, [r1,#ms_myref]
        STR      R0, [r1,#ms_yourref]
        MOV      R0, #19                ; Ack the message.
        LDR      R2, [r1,#ms_taskhandle]
        SWI      XWimp_SendMessage
        Pull     "PC",VS

        LDR      r3,[r1,#ms_data]
        STR      r3,iconized_window     ; Save window handle.

        LDR      r2,[r1,#ms_data+4]
        STR      r2,iconized_task       ; Save task id.

        MOV      r0,#0
        STRB     r0,[r1,#ms_data+8+10]  ; Truncate title string to 10 chars.

        ADD      r0,r1,#ms_data+8       ; Save the title string
        ADR      r1,window_title
        BL       Copy_r0r1

        ADR      r1,dataarea
        MOV      r0,#ms_data+4          ; Send WindowInfo message.
        STR      r0,[r1]                ; one word of data.
        MOV      r0,#0
        STR      r0,[r1,#ms_myref]
        STR      r0,[r1,#ms_yourref]
        LDR      r0,=Message_WindowInfo
        STR      r0,[r1,#ms_action]
        STR      r3,[r1,#ms_data]

        MOV      r0,#18                 ; Recorded message.
        SWI      XWimp_SendMessage

        Pull     "PC"

WindowInfo     ROUT

        Debug   ic,"Got WindowInfo"

        LDR     r0,[r1,#ms_size]
        CMP     r0,#24
        BGT     %FT01                ; Size > 24 this is a reply to my request.

        LDR     r0,[r1,#ms_taskhandle]
        LDR     r2,mytaskhandle

        CMP     r0,r2                ;  Did I send it ?
        LDRNE   r0,Pinboard_options
        ORRNE   r0,r0,#PinboardOption_NoIconize
        STRNE   r0,Pinboard_options
        BLNE    ReopenWindows        ; Someone else sent it , reopen all windows

        Pull    "PC"

01
        MOV      r0,#0
        STRB     r0,[r1,#ms_data+16+10]       ; Force terminator after 10 chars.
        ADD      r0,r1,#ms_data+16            ; Save the title string
        ADR      r1,window_title
        BL       Copy_r0r1

        ADR      r1,dataarea
        B        got_task_name        ; pretend it's a TaskNameIs message.

bounced_WindowInfo

        Debug    ic,"Bounced windowinfo"

        MOV       R0,#ms_data+4           ; Get task name (for sprite_name)
        STR       R0,[R1]
        MOV       R0,#0
        STR       r0,[r1,#ms_myref]
        STR       r0,[r1,#ms_yourref]
        LDR       r0,=Message_TaskNameRq
        STR       r0,[r1,#ms_action]
        LDR       R0,iconized_task
        STR       r0,[r1,#ms_data]
        MOV       r0,#17
        MOV       r2,#0                   ; Broadcast.
        SWI       XWimp_SendMessage

        Pull     "PC"

 [ iconise_to_iconbar
w_iconbar_flags DCD &1700310b
 ]
w_icon_flags    DCD &4000a50b
;w_icon_flags    DCD &4700A50B

icon_sprite   DCB  "ic_",0
default_icon  DCB  "ic_?",0

       ASSERT (?default_icon)<15

       ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; got_task_name
;
; We've got a name for the window we're iconising.

got_task_name
       ; Allocate buffer space
       MOV      r3, #w_block_size
       MOV      r0, #ModHandReason_Claim
       SWI      XOS_Module
       Pull     "PC",VS

       ; Delete duplicate icons.
       Push     "r0-r11"
       LDR      r5, iconized_window
       BL       int_close_window
       Pull     "r0-r11"

       ; Fill info
       MOV      r0,#-1
       STR      r0,[r2,#w_icon_handle]

       MOV      r0,#"S"
       STR      r0,[r2,#w_sprite_prefix]

       ADR      r0,icon_sprite            ; copy sprite prefix
       ADD      r1,r2,#w_sprite_name
       BL       Copy_r0r1

       ADR      r1,dataarea
       ADD      r3,r1,#ms_data+8
       ADD      r0,r2,#w_sprite_name       ;  and task name.
       MOV      r4,#?icon_sprite-1

01
       LDRB     r5,[r3],#1
       CMP      r5,#&20                   ; Up to space or terminator.
       BLE      %FT02
       STRB     r5,[r0,r4]
       ADD      r4,r4,#1
       CMP      r4,#14                    ; or 13 characters.
       BLT      %BT01

02     MOV      r5,#0                     ; Store zero terminator.
       STRB     r5,[r0,r4]

       MOV     r11, r2

       ADD     r2,  r2,#w_sprite_name
       MOV     r0,  #SpriteReason_ReadSpriteSize
       SWI     XWimp_SpriteOp
       ADDVS   r1, r11, #w_sprite_name
       ADRVS   r0, default_icon
       BLVS    Copy_r0r1

       ; Read window info.
       ADR      r1,dataarea
       LDR      r0,iconized_window
       STR      r0,[r1]
       STR      r0,[r11,#w_window_handle]
       SWI      XWimp_GetWindowState

       ADD      r1,r1,#4
       LDMIA    r1,{r3-r8}
       Debug    ic,"window pos ",r3,r4,r5,r6,r7,r8
       ADD      r1,r11,#w_window_pos
       STMIA    r1,{r3-r8}

       Debug    ic,"window pos ",r3,r4,r5,r6,r7,r8

       LDR      r0,iconized_task
       STR      r0,[r11,#w_task]

       ADR      r0,window_title           ; Copy window title.
       ADD      r1,r11,#w_window_title
       BL       Copy_r0r1

       ; Open window with -3
       ADR      r1,dataarea
       MOV      r0,#-3
       STR      r0,[r1,#28]

       MOV      r0,#2     ; Open window
       LDR      r2,iconized_task
       SWI      XWimp_SendMessage

       Debug    ic,"Sent open request"


; Get position
 [ iconise_to_iconbar
       LDR      lr, Pinboard_options
       TST      lr, #PinboardOption_IconiseToIconBar
       BNE      %FT00
 ]

       LDR      r0,[r11,#w_window_pos]

       ADD      r0,r0,#grid_x_spacing :SHR: 1
       STR      r0,iconize_x

       Debug    ic,"X ",r0

       LDR      r0,[r11,#w_window_pos+4]
       LDR      r1,[r11,#w_window_pos+12]
       SUB      r1,r1,#grid_y_spacing :SHR: 1
       STR      r1,iconize_y

       ; First see if shift+close was used to do the iconising. If so, ignore corner settings.
       LDR      r0, IconizeAtFlags
       TST      r0, #IconizeAtFlag_ShiftCloseIcon
       BNE      %FT09
       
       ; Are we using the corner settings? If so, get the position the icon will go in.
       TST      lr, #PinboardOption_UseWinToCorner
       Push     "lr"
       BLNE     get_iconise_position
       Pull     "lr"

       ; If using a corner, or the iconbar, then skip ahead.
       TST      lr, #PinboardOption_UseWinToCorner
       BNE      %FT00
       TST      lr, #PinboardOption_IconiseToIconBar
       BNE      %FT00

09     ; We're iconising to the pointer, either because this was set or because the iconising
       ; was done by Shift clicking on the close icon of a window.
       LDR      r0, IconizeAtX     ; If there's a value waiting from a Message_IconizeAt
       CMP      r0, #-1            ; then use that,
       BEQ      %FT00              ; otherwise use the default position (so skip ahead)
       STR      r0, iconize_x
       LDR      r0, IconizeAtY
       STR      r0, iconize_y

00
       ; Reset the IconizeAt copy
       MOV     r0, #-1
       STR     r0, IconizeAtX
       STR     r0, IconizeAtY

       ADD     r2, r11, #w_sprite_name

       MOV     r0, #SpriteReason_ReadSpriteSize
       SWI     XWimp_SpriteOp

       ADD     r9,r11,#w_window_title
       ADD     r10,r11,#w_sprite_prefix

; Valid registers r6 = sprite mode, r3,r4 = sprite width,height, r9->icon name,r10->sprite name,r11->icon
; Adjust to get OS units
       MOVVC   r0, r6                          ; creation mode of sprite
       MOVVC   r1, #VduExt_XEigFactor
       SWIVC   XOS_ReadModeVariable
       MOVVC   r5, r3, LSL r2
       MOVVC   r3, #0
       MOVVC   r1, #VduExt_YEigFactor
       SWIVC   XOS_ReadModeVariable
       Pull    "PC",VS
       MOV     r6, r4, LSL r2
       ADD     r6, r6, #36
       MOV     r4, #0
       MOV     r3, #0

       ; Check length of name
       MOV     R0,#1
       MOV     R1,R9
       Push    "R2"
       MOV     R2,#0
       SWI     XWimp_TextOp
       Pull    "R2"
       CMP     R5,R0
       MOVLT   R5,R0

       ; Get flags and name
       ADR     r1, dataarea
       LDR     r0, backdrop_handle

 [ iconise_to_iconbar
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        SUBNE   r6, r6, #16
        MOVNE   r4, #-16
 ]

        STMIA   r1!, {r0,r3,r4,r5,r6}
 [ iconise_to_iconbar
        LDRNE   r6, w_iconbar_flags
        LDREQ   r6, w_icon_flags
 |
        LDR     r6, w_icon_flags
 ]
        ADD     r10, r11, #w_sprite_prefix
        MOV     r14, #32
        STMIA   r1!, {r6,r9,r10,r14}

        ; Create the icon
        ADR     r1,dataarea             ; create iconbar entry

 [ iconise_to_iconbar
        LDR     lr, Pinboard_options
        TST     lr, #PinboardOption_IconiseToIconBar
        MOVNE   r0, #-2
        STRNE   r0, [r1]
        BNE     %FT10
 ]

        LDR     r0,backdrop_handle
        STR     r0,[r1],#4
        LDMIA   r1,{r3-r6}
        LDR     r9,iconize_y
        LDR     r8,icon_bar_height
        CMP     r8,r9
        MOVGT   r9,r8
        LDR     r8,iconize_x
        
        ; Check if we're iconising to the close icon
        LDR     r3, IconizeAtFlags
        TST     r3, #IconizeAtFlag_ShiftCloseIcon
        BNE     %FT02
        TSTEQ   lr, #PinboardOption_UseWinToCorner
        BEQ     %FT02

        ; We're iconising to a corner - centre icon.
        Push    "r0-r1"
        MOV     r3, r8
        MOV     r4, r9
        MOV     r0, #grid_x_spacing
        SUBS    r1, r0, r5
        ADDS    r3, r3, r1, LSR #1
        Pull    "r0-r1"
        B       %FT04

02      ; Tweak x positioning of the icon if we're iconising to the close icon
        Debug   ic,"r3 x y",r3,r8,r9
        ADD     r3,r3,r8
        SUBS    r3,r3,r5, LSR #1
        MOVCC   r3,#0
        ADD     r4,r4,r9

04        
        ADD     r5,r3,r5
        ADD     r6,r6,r9
        LDR     r8,w_icon_flags
        Debug   ic,"Lock to grid ",r3
        ;BL      lock_to_grid
        Debug   ic,"Lock to grid returned"
        
        STMIA   r1,{r3-r6,r8}
        Debug   ic,"Bounding box is ",r3,r4,r5,r6
        SUB     r1,r1,#4
10
        LDR     r8, [r1]
        Push    "r8"          ; stick the window handle (backdrop or iconbar) on stack
                
        SWI     XWimp_CreateIcon
        ADRVC   r1,dataarea
        STRVC   r0,[r1,#4]
        MOVVC   r8,#0
        STRVC   r8,[r1,#8]
        STRVC   r8,[r1,#12]
        MOVVC   r8,r0
        SWIVC   XWimp_SetIconState

        Pull    "r0"                     ; get window handle back off stack.
        STR     r0, [r11, #w_icon_id]    ; store window handle
        STRVC   r8, [r11,#w_icon_handle] ; store icon handle

       ; Reset IconizeAtFlags
       MOV     r0, #0
       STR     r0, IconizeAtFlags

       ; (r11=Pointer) Link to list.
       LDR      r0,iconized_ptr
       STR      r0,[r11,#w_next_ptr]
       CMP      r0,#0                    ; If next exsists link to it.
       STRNE    r11,[r0,#w_prev_ptr]
       STR      r11,iconized_ptr         ;  First on the list.
       MOV      r0,#0
       STR      r0,[r11,#w_prev_ptr]     ; No previous.

       ; Install icon (Zoom ?)
 [ drag_on_iconise
        ADR     r1, dataarea
        LDR     r2, [r1, #4]            ; Get back icon handle.
        SWI     XWimp_GetPointerInfo
        LDMVCIA r1, {r10,r11}           ; Get current pointer position.
        BVC     Iconized_Drag           ; Start drag.
 ]
       LDR      r0, Window_Icons
       ADD      r0, r0, #1
       STR      r0, Window_Icons
       Pull     "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; int_close_window

int_close_window                  ; fake close window ( r5=handle )
        Push    "LR"
        B       close_window_entry


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window

close_window
        LDR      R0, [r1,#ms_myref]
        STR      R0, [r1,#ms_yourref]
        MOV      R0, #19                ; Ack the message.
        LDR      R2, [r1,#ms_taskhandle]
        SWI      XWimp_SendMessage
        Pull     "PC",VS

        LDR     r5,[r1,#ms_data]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_window_entry

close_window_entry
        Push    "R7"

        Debug   ic,"window closed ",r5
        
01      BL      find_window

        CMP     r7,#0
        Pull    "R7,PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; close_task

close_task

        LDR     r5,[r1,#ms_taskhandle]

        Debug   ic,"Task close ",r5

01      BL      find_task
        CMP     r7,#0
        Pull    "PC",EQ
        BL      delete_window      ; Preserves r5.
        B       %BT01


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_iconise_position
;
; Decide where to put the icon for a window that's just been iconized.
; The process involves choosing a location, then searching first the window list, then the
; file list, to see if the space is occupied. If it is, then we move to the next space
; (dependent on PinboardOption_WinToCorner...) and check through each list again.
;
; In: Nothing.
;
; Out: The memory locations iconise_x and iconise_y are set to the position for the icon.
;      All regs preserved.

get_iconise_position ENTRY

        Push    "r0-r12"

        LDR     r2, Pinboard_options                ; Pinboard options
        ORR     r2, r2, #PinboardFlag_UseWindowList ; Start with the window list
        STR     r2, Pinboard_options
        ADR     r0, bounding_box                    ; Screen bouding box

        LDR     r1, [r0, #8]                        ; Decide on initial left/right positioning
        TST     r2, #PinboardOption_WinToCornerLR   ; 0 = Left (EQ), 1 = Right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing

        LDR     r1, [r0, #12]                       ; Decide on initial up/down positioning
        TST     r2, #PinboardOption_WinToCornerTB   ; 0 = Top (EQ), 1 = Bottom (NE)
        SUBEQ   r4, r1, #grid_y_spacing
        LDRNE   r4, icon_bar_height
                 
        SUB     sp, sp, #48                         ; Increase stack - we'll use it for getting icon data

        ; Now loop through linked list of icons and see if they present a problem (occupy the space that
        ; our 'proposed' icon is going to use). If so, try another space. If not, then we can use the coords. 
        ; (Surely there's an easier way?)
        ; r2 = options
        ; r3 = iconize_x
        ; r4 = iconize_y
        ; r3-r6 = attempted bounding box
        ; r11 -> current iconized icon we're checking
        ; r10 -> bounding box of the icon we're checking
        
10 ; tryagain
        ORR     r2, r2, #PinboardFlag_UseWindowList ; reset the list we're using to the window_list
        STR     r2, Pinboard_options
        LDR     r11, iconized_ptr                   ; location of first icon data
        CMP     r11, #0                             ; check there's actuallly icons in this list
        BNE     %FT20
        
        BIC     r2, r2, #PinboardFlag_UseWindowList ; There weren't any icons in the window_list
        STR     r2, Pinboard_options                ; so move to the file list.
        LDR     r11, Icon_list

20 ; nexticon
        CMP     r11, #0                             ; check for the end of the list
        BEQ     %FT86
        MOV     r9, sp
        BL      get_next_icon_bbox                  ; Get the next bounding box
        CMP     r10, #0
        BEQ     %FT80                               ; if bbox -> 0, icon was not on backdrop - go to next
        
        ADD     r5, r3, #grid_x_spacing             ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10] 
        CMP     r5, r7                              ; Check proposed x2 <= icon x1
        BLE     %FT80                               ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                              ; Check proposed x1 >= icon x2
        BGE     %FT80                               ; If it is, then this icon presents no problems - try next
        
        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                              ; Check proposed y2 <= icon y1
        BLE     %FT80                               ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                              ; Check proposed y1 >= store y2
        BGE     %FT80                               ; If it is, then this icon presents no problems

        ; The bounds checks have failed - the stored icon overlaps with our proposed one.
        ; So, we've got to move onto the next possible slot on the pinboard.
        BL  find_next_x_and_y
        BNE %FT84
        B   %BT10
        
80 ; try_next
        BL      get_next_icon_block
        B       %BT20                               ; Next icon - go back and check it

84 ; screen_full
        B       %FT88
 
86 ; got_one
        STR     r3, iconize_x
        STR     r4, iconize_y
                
88 ; exit
        ADD     sp, sp, #48
        Pull    "r0-r12"
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_box
;
; Given a pointer to a data block, find the icon's bounding box.
; PinboardFlag_UseWindowList sets if the block is in the window or file list
;
; In: r2 = Pinboard_options
;     r11 -> icon data block
;     r9  -> 40 byte block of temporary memory (typically stack)
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;             if r10 is zero, icon is not on backdrop.
;      r0, r1 corrupted

get_next_icon_bbox ENTRY

        MOV     r10, #0        
        TST     r2, #PinboardFlag_UseWindowList ; Is the data -> by r9 in the window or file list?
        BNE     %FT20

10      ; find the icon handle from the file icon list
        LDR     r0, [r11, #ic_icon]
        B       %FT30
        
20      ; find the icon handle from the window icon list
        LDR     r0, backdrop_handle
        LDR     r1, [r11, #w_icon_id]
        CMP     r0, r1
        EXIT    NE                              ; icon not on backdrop - exit
        LDR     r0, [r11, #w_icon_handle]

30      ; found an icon handle - get it's bounding box
        STR     r0, [r9, #4]
        LDR     r0, backdrop_handle
        STR     r0, [r9]
        MOV     r1, r9
        SWI     Wimp_GetIconState
        ADD     r10, r1, #8
        
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; get_next_icon_block
;
; Given an icon data block, find the next icon in the linked list. Includes
; both file icon list and window icon list. PinboardFlag_UseWindowList
; indicates if we are currently on the window list (set) or file list
; (clear). If we've reached the end of the window list, we'll move to
; the file list, but not vice-versa.
;
; In:  r2 = Pinboard_options
;      r11 -> icon data block
;
; Out: r10 -> bounding box (which will be 16 bytes within the 40 bytes)
;      r0, r1 corrupted

get_next_icon_block ENTRY

        TST     r2, #PinboardFlag_UseWindowList
        LDRNE   r11, [r11, #w_next_ptr]    ; if iconised window
        LDREQ   r11, [r11, #ic_next]       ; if file icon
        CMP     r11, #0
        EXIT    NE
        
        TST     r2, #PinboardFlag_UseWindowList
        EXIT    EQ                         ; if this is the file list, we can go no further
        
        BIC     r2, r2, #PinboardFlag_UseWindowList
        STR     r2, Pinboard_options
        LDR     r11, Icon_list
        
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; find_next_x_and_y
;
; What are x and y co-ordinates of the next spot on the grid?
;
; In: r2 = pinboard options
;     r3 = x co-ord.
;     r4 = y co-ord.
;
; Out: r3, r4 = x and y co-ordinates
;      NE     = Screen full
;      EQ     = Found new position (in r3, r4)
;      r0, r1 = corrupted.

find_next_x_and_y ENTRY

        ; Which way are we stacking?
        TST     r2, #PinboardOption_WinToCornerHV ; 0 = Stack horizontally (EQ), 1 = Stack vertically (NE)
        BEQ     %FT20                             ; if we're stacking horizontally, skip to different code.
        
        ; Right, we're stacking vertically - move y up/down by one icon
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = move down (EQ), 1 = move up (NE)
        ADDNE   r4, r4, #grid_y_spacing           
        SUBEQ   r4, r4, #grid_y_spacing

        ; Check we're still on the screen
        LDR     r0, icon_bar_height
        CMP     r4, r0                            
        BLT     %FT16                             ; We're off the bottom - move x and reset y.
        ADR     r0, bounding_box
        LDR     r1, [r0, #12]
        SUB     r1, r1, #grid_y_spacing
        CMP     r4, r1
        BGT     %FT16                             ; We're off the top - moce x and reset y.
        
        ; We are still on the screen, so now go back and check and see if this new position is okay.
        B       %FT30

16 ; move_x
        ; we've reached the top/bottom of a vertical stack, so move x left/right by one icon
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = move right (EQ), 1 = move left (NE)
        SUBNES  r3, r3, #grid_x_spacing
        ADDEQ   r3, r3, #grid_x_spacing

        ; reset y to the top/bottom
        ADR     r0, bounding_box
        LDR     r1, [r0, #12]
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = top (EQ), 1 = bottom (NE)
        LDRNE   r4, icon_bar_height
        SUBEQ   r4, r1, #grid_y_spacing

        ; has x reached the screen edge (ie. screen full) ?
        CMP     r3, #0
        BLT     %F40
        
        LDR     r1, [r0, #8]
        CMP     r3, r1
        BLT     %FT30
        B       %FT40

20 ; not_here_horiz
        ; we're stacking horizontally, so move x left/right by one icon
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        ADDEQ   r3, r3, #grid_x_spacing
        SUBNES  r3, r3, #grid_x_spacing
        
        ; Check we're still on the screen
        CMP     r3, #0
        BLT     %FT26                             ; We're off the left - move y and reset x.
        ADR     r0, bounding_box
        LDR     r1, [r0, #8]
        SUB     r1, r1, #grid_x_spacing
        CMP     r3, r1
        BGT     %FT26                             ; We're off the right - move y and reset x.
        
        ; We are still on the screen, so now go back and check and see if this new position is okay.
        B       %FT30
        
26 ; move_y
        ; we've reached the edge of a horizontal stack, so move y up/down by one icon
        TST     r2, #PinboardOption_WinToCornerTB ; 0 = move down (EQ), 1 = move up (NE)
        ADDNE   r4, r4, #grid_y_spacing
        SUBEQS  r4, r4, #grid_y_spacing
        
        ; reset x to the left/right
        ADR     r0, bounding_box
        LDR     r1, [r0, #8]
        TST     r2, #PinboardOption_WinToCornerLR ; 0 = left (EQ), 1 = right (NE)
        MOVEQ   r3, #0
        SUBNE   r3, r1, #grid_x_spacing
        
        ; has y reached the screen edge (ie. screen full) ?
        CMP     r4, #0
        BLT     %FT40
        LDR     r1, [r0, #12]
        CMP     r4, r1
        BLT     %FT30
        B       %FT40

30 ; exit_check_okay

        MOV     r0, #24
        CMP     r0, #24
        EXIT

40 ; exit_screen_full

        MOV     r0, #24
        CMP     r0, #23
        EXIT

        LNK     s.Help
