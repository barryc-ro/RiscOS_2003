; s.MenuSelect
;                 
; Handle menu selections

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; menu_selection
;
; In: r1 -> 256 byte block returned by Wimp_Poll, of which...
;                r1+0 item in main menu which was selected
;                r1+4 item in first submenu which was selected
;                r1+8 item in second submenu which was selected
;                etc.
;
; Out: registers may be corrupted - returning to wimp poll.

menu_selection ROUT

        Push    "LR"

        Debug   pi,"Menu selection"

        ADR     r1,PointerInfo
        SWI     XWimp_GetPointerInfo
        Pull    "PC",VS
        ADR     r1,dataarea

        LDR     r14,CurrentMenu
        TEQ     r14,#Menu_Pinboard  
        BEQ     pinboard_menu_selection
        TEQ     r14,#Menu_TinyDirs
        BEQ     tinydirs_menu_selection                
        TEQ     r14,#Menu_TinyDirsIcon
        BEQ     tinydirs_icon_menu_selection

        Pull    "PC"     

reopen_tinydirs_icon_menu

        Debug   pi,"Reopen tinydirs icon menu"

        LDR     r14,PointerInfo+8
        Debug   pi,"buttons ",r14
        TST     r14,#1
        BNE     TinyDirsIcon_Menu
        Pull    "PC"

tinydirs_icon_menu_selection ROUT

        ADR     r2,reopen_tinydirs_icon_menu
        Push    "r2"

        LDR     r14,[r1]
        ADD     PC,PC,R14,ASL #2
        Pull    "PC"  
        
        ;Pull    "PC"                    
        B       QuitTinyDirs

QuitTinyDirs
        LDR     r0,Pinboard_options
        BIC     r0,r0,#PinboardOption_TinyDirs
        STR     r0,Pinboard_options
         
        LDR     r0,TinyDirs_Handle
        CMP     r0,#0
        Pull    "PC",LT

        ADR     r1,dataarea
        STR     r0,[r1,#4]
        MOV     r0,#-2
        STR     r0,[r1]
        SWI     XWimp_DeleteIcon
               
        MOV     r0,#-1
        STR     r0,TinyDirs_Handle   
        Pull    "r14,PC"

reopen_tinydirs_menu

        Debug   pi,"Reopen tinydirs menu"

        LDR     r14,PointerInfo+8
        Debug   pi,"buttons ",r14
        TST     r14,#1
        BNE     recreate_iconbar_menu
        Pull    "PC"

tinydirs_menu_selection ROUT 

        ADR     r2,reopen_tinydirs_menu
        Push    "r2"

        LDR     r14,[r1]
        ADD     PC,PC,R14,ASL #2
        Pull    "PC"

        B       SelectAllIconbar        ; 1
        B       ClearIconbarSelection   ; 2
        B       RemoveIconbarSelection  ; 3
        B       OpenParent              ; 4   

SelectAllIconbar ROUT
        Debug   pi,"SelectAllIconbar"

        MOV     r0,#-2
        BL      SelectFileIcons
        Pull    "PC"

ClearIconbarSelection

        Debug   pi,"CleariconbarSelection"
        MOV     r0,#-2
        BL      DeselectFileIcons
        Pull    "PC"

RemoveIconbarSelection
        Debug   pi,"Remove Iconbar"

        MOV     r0,#-2
        BL      RemoveIcons

        Pull    "PC"

OpenParent      ROUT

        LDR     r5,[r1,#4]

        MOV     r0,#-2
        ADR     r1,dataarea
        MOV     r2,#is_selected
        MOV     r3,#is_selected
        SWI     XWimp_WhichIcon
        Pull    "PC",VS
                          
01
        LDR     r2,[r1],#4
        MOV     r1,#-2
        BL      FindIcon
        BNE     %BT01

        ADR     r1,dataarea
        ADR     r0,OpenParent_command
        BL      Copy_r0r1

        ADD     r0,r2,#ic_path
        BL      Copy_r0r1
                           
        MOV     r2,#-1
        ADR     r0,dataarea
02
        LDRB    r14,[r0],#1
        CMP     r14,#"."
        SUBEQ   r2,r0,#1
        CMP     r14,#32
        BGE     %BT02

        MOV     r0,#0
        CMP     r2,#-1
        STRNEB  r0,[r2]
                      
        ADR     r0,dataarea
        DebugS  td,"Command is ",r0
        SWI     XOS_CLI

        Pull    "PC"
                       
OpenParent_command      DCB     "Filer_OpenDir ",0
                        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; reopen_pinboard_menu
;
; Called after dealing with a menu selection, to reopen the menu if a
; right mouse click was used on the selection.

reopen_pinboard_menu

        Debug   pi,"Reopen pinboard menu"

        LDR     r14,PointerInfo+8
        Debug   pi,"buttons ",r14
        TST     r14,#1
        BNE     recreate_pinboard_menu
        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; pinboard_menu_selection
;
; Deal with selections from the pinboard menu
;
; In: r1 -> Wimp_Poll block, specifically R1+0 contains the number of the
;           item in the main pinboard menu which was selected.

pinboard_menu_selection

        ADR     r2,reopen_pinboard_menu ; Make sure this function is called when we've delt with
        Push    "r2"                    ; selection, so that menu is reopened if Right button was used

        LDR     r14,[r1]
        ADD     PC,PC,R14,ASL #2
        Pull    "PC"

        B       selection_menu_selection ; 0
        B       selectall_menu_selection ; 1
        B       ClearSelection           ; 2
        B       options_menu_selection   ; 3
        B       Save                     ; 4
        [ show_backdrop_options
        B       MakeBackdrop             ; 5
        B       RemoveBackdrop           ; 6
        ]


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; selectall_menu_selection
;
; Deal with a selection from the Select all submenu.
;
; In: r1 -> Wimp_Poll bloc, specifically, R1 + 4 contains the number of
;           the item selected from the Select all submenu.

selectall_menu_selection

        LDR     r14, [r1, #4]
        ADD     pc, pc, r14, ASL #2
        B       SelectAll                ; -1 - Just a click on SelectAll without moving to the menu
        
        B       SelectAllFiles           ; 0 - Select files
        B       SelectAllWindows         ; 1 - Select windows
        B       SelectAll                ; 2


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; selection_menu_selection
;
; Deal with a selection from the Selection submenu.
;
; In: r1 -> Wimp_Poll bloc, specifically, R1 + 4 contains the number of
;           the item selected from the Selection submenu.

selection_menu_selection

        LDR     r14, [r1, #4]
        ADD     pc, pc, r14, ASL #2
        Pull    "pc"
        
        B      Tidy                     ; 0
        B      OpenSelection            ; 1 - Open
        B      Remove                   ; 2


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; option_menu_selection
;
; Deal with a selection from the options submenu.
;
; In: r1 -> Wimp_Poll bloc, specifically, R1 + 4 contains the number of
;           the item selected from the options submenu.

options_menu_selection

        LDR     r14, [r1, #4]
        ADD     PC, PC, R14, ASL #2
        Pull    "PC"
        
        B       IconiseWindowOpt    ; 0
        B       TidyToMenuOpt       ; 1
        B       Grid                ; 2


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Tidy
;
; The 'Tidy' option was selected.

Tidy               
        Debug   pi,"Tidy"

        LDR     r0, Pinboard_options
        ORR     r0, r0, #PinboardFlag_TidyWindows
        STR     r0, Pinboard_options
        BL      tidy_icons

        LDR     r0, Pinboard_options
        BIC     r0, r0, #PinboardFlag_TidyWindows
        STR     r0, Pinboard_options
        BL      tidy_icons

        ;MOV     r0,r5
        LDR     r0,backdrop_handle
        MOV     r1,#-1
        MOV     r2,#-1
        MOV     r3,#&80000
        MOV     r4,#&80000
        SWI     XWimp_ForceRedraw                                

        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Grid
;
; The 'Grid lock' option was selected.

Grid
        Debug   pi,"Grid"

        LDR     r14,Pinboard_options
        EOR     r14,r14,#PinboardOption_Grid
        STR     r14,Pinboard_options

        Pull    "PC"

Remove
        Debug   pi,"Remove"

        LDR     r0,backdrop_handle
        BL      RemoveIcons

        Pull    "PC"

SelectAll
        
        Debug   pi,"SelectAll"
        
        LDR     r0,backdrop_handle
        BL      SelectAllIcons
        Pull    "PC"
        
SelectAllFiles
       
        LDR     r0, backdrop_handle
        BL      DeselectAllIcons
        BL      SelectFileIcons
        Pull    "PC"
        
SelectAllWindows

        LDR     r0, backdrop_handle
        BL      DeselectAllIcons
        BL      SelectWindowIcons
        Pull    "PC"        

ClearSelection

        Debug   pi,"ClearSelection"
        LDR     r0,backdrop_handle
        BL      DeselectAllIcons
        Pull    "PC"

MakeBackdrop

        Debug   pi,"MakeBackdrop"

        LDR     r5,[r1,#4]

        LDR     r0,backdrop_handle
        ADR     r1,dataarea
        MOV     r2,#is_selected
        MOV     r3,#is_selected
        SWI     XWimp_WhichIcon
        Pull    "PC",VS

        LDR     r2,[r1]           
        LDR     r1,backdrop_handle
        BL      FindIcon
        Pull    "PC",NE

        ADR     r1,dataarea
        ADR     r0,backdrop_command
        BL      Copy_r0r1

        ADD     r0,r2,#ic_path
        BL      Copy_r0r1
                      
        ADR     r0,dataarea
        MOV     r1,#"s"
        TEQ     r5,#1 
        MOVEQ   r1,#"c"
        TEQ     r5,#2
        MOVEQ   r1,#"t"
        STRB    r1,[r0,#10]
        DebugS  pi,"Command is ",r0
        SWI     XOS_CLI
        BVC     %FT01

        Push    "r0"                    ; Preserve error
        LDR     r0,backdrop_handle
        MOV     r1,#0
        MOV     r2,#0
        MOV     r3,#&80000
        MOV     r4,#&80000
        SWI     XWimp_ForceRedraw
        Pull    "r0"
        SETV

01
        Pull    "PC"

RemoveBackdrop
        BL      ClearBackdrop
        Pull    "PC"

Save
        BL      IntSave_KeyPressed
        Debug   pi,"Save"
        Pull    "PC"

           
backdrop_command        DCB     "Backdrop -? ",0
        ALIGN


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; IconiseWindowOpt
;
; Handles a click on the 'Iconise' submenu.
;
; In: r1-> Wimp_Poll block, specifically, R1 + 8 contains the item within
;          the iconise submenu which was selected.

IconiseWindowOpt

        LDR     r0, Pinboard_options
        LDR     r5, [r1, #8]
        
        CMP     r5, #2
        BLT     %FT10
        CMP     r5, #6
        BLT     %FT20

        ; Clcik on 'Stack horizontally' or 'Stack vertically'
        CMP     r5, #6
        BICEQ   r0, r0, #PinboardOption_WinToCornerHV
        CMP     r5, #7
        ORREQ   r0, r0, #PinboardOption_WinToCornerHV
        
        B       %FT50
        
10      ; Click on either 'At close icon' or 'To iconbar'
        BICLT   r0, r0, #PinboardOption_UseWinToCorner
        CMP     r5, #0
        BICEQ   r0, r0, #PinboardOption_IconiseToIconBar
        CMP     r5, #1
        ORREQ   r0, r0, #PinboardOption_IconiseToIconBar
        B       %FT50
        
20      ; Click on a corner option
        BIC     r0, r0, #PinboardOption_IconiseToIconBar
        SUB     r5, r5, #2
        TST     r5, #1
        ORRNE   r0, r0, #PinboardOption_WinToCornerTB
        BICEQ   r0, r0, #PinboardOption_WinToCornerTB
        TST     r5, #2
        ORRNE   r0, r0, #PinboardOption_WinToCornerLR
        BICEQ   r0, r0, #PinboardOption_WinToCornerLR
         
        ORR     r0, r0, #PinboardOption_UseWinToCorner

50        
        STR     r0, Pinboard_options
        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; TidyToMenuOpt
;
; Handles a click on the 'Tidy to' submenu.
;
; In: r1-> Wimp_Poll block, specifically R1+8 stores the item within the
;          Tidy to submenu which was selected.

TidyToMenuOpt

        LDR     r0, Pinboard_options
        LDR     r5, [r1, #8]
        CMP     r5, #4
        BLT     %FT20
10
        CMP     r5, #4
        BICEQ   r0, r0, #PinboardOption_TidyToCornerHV
        CMP     r5, #5
        ORREQ   r0, r0, #PinboardOption_TidyToCornerHV
        B       %FT30
20
        TST     r5, #1
        ORRNE   r0, r0, #PinboardOption_TidyToCornerTB
        BICEQ   r0, r0, #PinboardOption_TidyToCornerTB
        TST     r5, #2
        ORRNE   r0, r0, #PinboardOption_TidyToCornerLR
        BICEQ   r0, r0, #PinboardOption_TidyToCornerLR
30        
        STR     r0, Pinboard_options
        Pull    "PC"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_icons
;
; Tidies either the file icons or the window icons. Which is done depends
; on the value PinboardFlag_TidyWindows (set tidy window icons, clear
; tidy files).
;
; In:  Nothing.
;
; Out: All regs preserved.

tidy_icons ENTRY "r0-r11"

        LDR     r8, Pinboard_options                ; Pinboard options
        TST     r8, #PinboardFlag_TidyWindows
        BICNE   r8, r8, #PinboardFlag_UseWindowList ; Set UseWindowList flag for later (oposite
        ORREQ   r8, r8, #PinboardFlag_UseWindowList ; of TidyWindows flag)
        STR     r8, Pinboard_options
        
        ADR     r0, bounding_box                    ; Screen bouding box
        SUB     sp, sp, #48                         ; Increase stack (we'll use it for getting icon data)
        MOV     r9, sp                              ; r9 is now data pointer

        ; Decide on initial left/right positioning
        LDR     r1, [r0, #8]                        ; load screen max_x
        TST     r8, #PinboardFlag_TidyWindows       ; see if we're dealing with windows or files
        MOVNE   r2, #PinboardOption_WinToCornerLR   ; if windows, then we'll test WinToCornerLR bit
        MOVEQ   r2, #PinboardOption_TidyToCornerLR  ; if files, then we'll test TidyToCornerLR bit
        TST     r8, r2                              ; test the bit
        MOVEQ   r2, #0                              ; if not set, then use left of screen
        SUBNE   r2, r1, #grid_x_spacing             ; if set, then use right of screen

        ; Decide on initial up/down positiong
        LDR    r1, [r0, #12]                        ; load screen max_y
        TST    r8, #PinboardFlag_TidyWindows        ; see if we're dealing with windows or files 
        MOVNE  r3, #PinboardOption_WinToCornerTB    ; if windows, then we'll test WinToCornerTB
        MOVEQ  r3, #PinboardOption_TidyToCornerTB   ; if files, then we'll test TidyToCornerTB
        TST    r8, r3                               ; test the bit
        SUBEQ  r3, r1, #grid_y_spacing              ; if not set, then use top of screen
        LDRNE  r3, icon_bar_height                  ; if set, then use bottom of screen


        ; Check initial position for clash, if we're doing files.
        TST     r8, #PinboardFlag_TidyWindows
        BNE     %F44
        MOV     r4, r3
        MOV     r3, r2
        BL      tidy_find_next_free
        MOV     r2, r3
        MOV     r3, r4

44 ; Where's the icon data?
        TST     r8, #PinboardFlag_TidyWindows
        LDRNE   r11, iconized_ptr                   ; First window icon in list
        LDREQ   r11, Icon_list                      ; First file icon in list

; At this point:  r2, r3 - x & y
;                 r9     - 48 byte data pointer
;                 r8     - Options
;                 r11    - icon data
        
50 ; Get next
        CMP     r11, #0                             ; end of list?
        BEQ     %FT80
        
        LDR     r0, backdrop_handle                 ; What's the backdrop handle
        LDR     r1, [r11, #ic_window]               ; What's the window handle
        CMP     r0, r1                              ; Is the icon on the backdrop?
        BNE     %FT70                               ; Not on backdrop, jump ahead
        
        MOV     r1, r9                              ; Find icon handle of next icon
        STR     r0, [r1]                            
        LDR     r0, [r11, #ic_icon]
        STR     r0, [r1, #4]                        
        SWI     Wimp_GetIconState                   

        LDR     r4, [r1, #24]                       ; icon flags
        TST     r4, #is_selected                    ; check if selected
        BEQ     %FT70                               ; if not, skip

        LDR     r4, [r1, #8]                        ; How wide is the icon?
        LDR     r5, [r1, #16]
        SUB     r6, r5, r4
        LDR     r4, [r1, #12]                       ; How tall is the icon?
        LDR     r5, [r1, #20]
        SUB     r7, r5, r4

        Push    "r2"
        MOV     r0, #grid_x_spacing                 ; Adjust for centre alignment
        SUBS    r1, r0, r6                          ; x1
        ADDS    r2, r2, r1, LSR #1                  ; x2
        ADD     r4, r2, r6                          ; x2
        ADD     r5, r3, r7                          ; y2

        TST     r8, #PinboardFlag_TidyWindows
        STREQ   r2, [r11, #ic_x]                    ; store x
        STREQ   r3, [r11, #ic_y]                    ; store y

        LDR     r0, backdrop_handle
        LDR     r1, [r11, #ic_icon]
        SWI     Wimp_ResizeIcon                     ; Move icon to new x and y
        Pull    "r2"
                                                    
        MOV     r4, r3                              ; Register swapping - r3, r4 should contain x, y
        MOV     r3, r2
        TST     r8, #PinboardFlag_TidyWindows
        MOVEQ   r2, r8, LSR #3
        MOVNE   r2, r8
        BL      find_next_x_and_y
        BL      tidy_find_next_free
        MOV     r2, r3
        MOV     r3, r4

70      ; next_icon
        LDR     r11, [r11, #ic_next]
        B       %BT50

80      ; Exit
        ADD     sp, sp, #48
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; tidy_find_next_free
;
; Given an initial grid position, check if it's space is occupied. If it
; is, then move to the next position and try again.
;
; In: r3, r4 = x and y co-ordinates
;
; Out: r3, r4  = next free slot
;      r0 - r2 = corrupted.

tidy_find_next_free ENTRY

        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_TidyWindows
        EXIT    NE

10
        LDR     r2, Pinboard_options
        BL      is_something_there
        EXIT    NE
        MOV     r2, r2, LSR #3
        BL      find_next_x_and_y
        B       %BT10
        
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; is_something_there
;
; Test if a grid position is occupied. As to which list of icons is
; checked depends on the value of PinboardFlag_UseWindowList. If set,
; then the window list is searched, else the file list.
;
; In: r3, r4 = x and y co-ordinate of grid position
;
; Out: EQ if something there, NE if not.
;      All regs. preserved.

is_something_there ENTRY "r2, r5-r11"

        LDR     r2, Pinboard_options
        TST     r2, #PinboardFlag_UseWindowList
        LDRNE   r11, iconized_ptr                 ; first window in list?
        LDREQ   r11, Icon_list                    ; or first icon in list?
        SUB     sp, sp, #40                       ; grab some stack space to put data block
        MOV     r9, sp

20      ; next icon
        CMP     r11, #0                           ; is this the end of the linked list?
        BEQ     %FT90
        BL      get_next_icon_bbox                ; get the icon's bounding box
        CMP     r10, #0                           ; icon not on backdrop if r10 is zero
        BEQ     %FT80
        
        ADD     r5, r3, #grid_x_spacing           ; make r3, r4, r5, r6 the proposed bounding box.
        ADD     r6, r4, #grid_y_spacing

        ; Check the proposed icon's left and right bounds against the current stored icon
        LDR     r7, [r10] 
        CMP     r5, r7                            ; Check proposed x2 <= icon x1
        BLE     %FT80                             ; If it is, then this icon presents no problems - try next
        LDR     r7, [r10, #8]
        CMP     r3, r7                            ; Check proposed x1 >= icon x2
        BGE     %FT80                             ; If it is, then this icon presents no problems - try next
        
        ; Check the proposed icon's top and bottom bounds against the current stored icon
        LDR     r7, [r10, #4]
        CMP     r6, r7                            ; Check proposed y2 <= icon y1
        BLE     %FT80                             ; If it is, then this icon present no problems.
        LDR     r7, [r10, #12]
        CMP     r4, r7                            ; Check proposed y1 >= store y2
        BGE     %FT80                             ; If it is, then this icon presents no problems
        
70      ; Exit EQ
        ADD     sp, sp, #40
        CMP     sp, sp
        EXIT

80      ; this icon doesn't occupy the space - try next
        LDR     r11, [r11, #ic_next]
        B       %BT20

90      ; something ISN'T there - Exit NE
        ADD     sp, sp, #40
        CMP     sp, #0
        EXIT        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; next_grid_row_or_column
;
; Depending on PinboardOption_WinToCornerXX, return the X and Y
; co-ordinate of the start of the next row or column.
;
; In: r2     = options
;     r3, r4 = x and y co-ordinate of grid position

;
; Out: r3, r4 = x and y co-ordinate of next row or column

next_grid_row_or_column ENTRY "r5"

        ADR     r5, bounding_box
        TST     r2, #PinboardOption_WinToCornerHV ; Are we dealing with rows or columns?
        BNE     %FT20
        
10      ; rows - reset x to left/right and move up/down a row
        LDR     r0, [r5, #8] ; x2
        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r0, #grid_x_spacing
        MOVEQ   r3, #0

        TST     r2, #PinboardOption_WinToCornerTB
        ADDNE   r4, r4, #grid_y_spacing
        SUBEQ   r4, r4, #grid_y_spacing

        ; Check we haven't moved up/down too far
        LDR     r0, [r5, #12] ; y2
        SUB     r0, r0, #grid_y_spacing
        CMP     r4, r0
        SUBGT   r4, r4, #grid_y_spacing

        LDR     r0, icon_bar_height
        CMP     r4, r0
        ADDLT   r4, r4, #grid_y_spacing
        EXIT

20      ; columns - reset y to top/bottom and move left/right a column
        LDR     r0, [r5, #12] ; y2
        TST     r2, #PinboardOption_WinToCornerTB
        LDRNE   r4, icon_bar_height
        SUBEQ   r4, r0, #grid_y_spacing
        
        TST     r2, #PinboardOption_WinToCornerLR
        SUBNE   r3, r3, #grid_x_spacing
        ADDEQ   r3, r3, #grid_x_spacing

        ; Check we haven't moved left/right too far
        LDR     r0, [r5, #8] ; x2
        SUB     r0, r0, #grid_x_spacing
        CMP     r3, r0
        SUBGT   r3, r3, #grid_x_spacing
        
        CMP     r3, #0
        ADDLT   r3, r3, #grid_x_spacing
        EXIT


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OpenSelection
;
; Called when user clicks on Selection->Open to open all selected windows/files

OpenSelection

        BL      OpenWindows
        BL      OpenFiles
        BL      ClearSelection
        Pull    "pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OpenWindows
;
; Open all selected iconised windows on the backdrop

OpenWindows ENTRY

01
        ADR     r1, dataarea
        LDR     r7, iconized_ptr
02
        CMP     r7, #0                   ; Have we reached end of list?
        EXIT    EQ
        LDR     r0, [r7, #ic_window]     ; Get handle of window which this icon is in
        LDR     r2, backdrop_handle
        CMP     r0, r2                   ; Check it's the backdrop
        BNE     %FT05
        
        STR     r0, [r1]
        LDR     r0, [r7, #ic_icon]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState       ; Get state of the icon
        EXIT    VS

        LDR     r0, [r1, #24]
        TST     r0, #is_selected         ; Check it's selected
        BEQ     %FT05
        BL      reopen_window            ; If it is, reopen the window. Go back and start again from
        ;LDR     r0, Window_Icons
        ;SUB     r0, r0, #1               ; Update number of window icons
        ;STR     r0, Window_Icons
        ;LDR     r0, Windows_Selected
        ;SUB     r0, r0, #1
        ;STR     r0, Windows_Selected

        B       %BT01                    ; first icon (because list has changed).

05
        LDR     r7, [r7, #ic_next]       ; Get next icon
        B       %BT02        


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OpenFiles
;
; Open all selected files on the backdrop

OpenFiles ENTRY

        LDR     r7, Icon_list
        
02
        CMP     r7, #0                   ; is this the last icon?
        EXIT    EQ
        LDR     r0, [r7, #ic_window]
        LDR     r2, backdrop_handle
        CMP     r0, r2                   ; check icon is on backdrop
        BNE     %FT05
      
        ADR     r1, dataarea
        STR     r0, [r1]
        LDR     r0, [r7, #ic_icon]
        STR     r0, [r1, #4]
        SWI     XWimp_GetIconState       ; get icon's state
        EXIT    VS
        
        LDR     r0, [r1, #24]
        TST     r0, #is_selected         ; check if icon is selected
        BEQ     %FT05

        ; Filer_Run the file
        ADR     r1, dataarea
        ADR     r0, FilerRunCom          ; Filer_Run
        BL      Copy_r0r1
        ADD     r0, r7, #ic_path         ; filename
        BL      Copy_r0r1
        ADR     r0, dataarea
        SWI     XOS_CLI
        EXIT    VS
        
05
        LDR     r7, [r7, #ic_next]
        B       %BT02

FilerRunCom        DCB     "Filer_Run ",0

        LNK     s.Tail
        
