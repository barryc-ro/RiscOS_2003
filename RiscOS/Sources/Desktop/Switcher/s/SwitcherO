; > Sources.Switcher

;;-----------------------------------------------------------------------------
;; Wimp utility:  Task Manager
;;
;; Change list
;;
;; 10-Mar-88    0.01    File created
;;                      Task display window implemented
;; 14-Mar-88            Iconbar stuff added
;; 25-Mar-88    0.02    Rely on Wimp loading sprite (Switcher)
;; 25-Mar-88    0.03    Read values of dx,dy on mode change
;; 13-Apr-88            Implement Task Quit menu entry
;; 21-Apr-88    0.04    Ensure that Switcher re-ialises on *RMTidy
;; 22-Apr-88    0.05    Respond to changes in a task's slot size by repainting
;; 22-Apr-88    0.06    Support hot keys (f1,shift-f4)
;; 17-May-88            Remove Cancel option from error window
;; 17-May-88            Menu needed to get task window (& move up a bit)
;; 17-May-88            Use Desktop_Switcher to avoid confusing the punter
;; 17-May-88    0.07    Add code to frugalise RMA & disallow *Desktop_Switcher
;; 17-May-88    0.08    Change text in iconbar menu
;; 24-May-88    0.09    Call svc_modechange on startup to ensure data is read
;; 24-May-88    0.10    Implement 'New Task' entry on iconbar menu
;;  6-Jun-88            Change 'New Task' to 'New task'
;;  6-Jun-88    0.11    Change 'Shell' to *Commands
;;  8-Jun-88    0.12    Implement Message_PreQuit
;;  8-Jul-88            Change menu colours to suit GBartram's defaults
;; 21-Jul-88    0.13    Put Font Cache area indicator into list
;;  2-Aug-88    0.14    Implement draggable task slots
;;  2-Aug-88    0.15    Removed f1 (*command) hot key
;; 10-Aug-88            Fix bug: recalculate memory map when task slot changes
;; 10-Aug-88    0.16    Fix bug: move task to application area if slot changes
;; 18-Aug-88            Change module name to TaskManager
;; 18-Aug-88    0.17    Allow RAM disc slot to be dragged (dynamic area 5)
;; 19-Aug-88            Fudge: max RAM disc size = 1920k
;; 19-Aug-88    0.18    Change so icon size is calculated not assumed
;; 19-Aug-88    0.19    Restart RAMFS Filer if RAM disc slot is dragged
;; 24-Aug-88    0.20    Change *commands key to f12 (c-s-f12 for exit)
;;  2-Sep-88    0.21    Remove 1920k limit on RAM disc
;;  9-Sep-88    0.22    Implement Message_TaskNameRq / Message_TaskNameIs
;;  4-Oct-88    0.23    Don't get null events unless task display is open
;; ==================== Risc OS 2.00 release version
;; 20-Oct-88            Change to use new Make procedures
;; 23-May-89    0.24    Change flag to stop dragging if error occurs
;; 31-Jan-90 ========== Set 'bigmac' true for Fox version (version 0.30 fix)
;; 25-May-89            If dragging on insert/delete row, scroll other way
;; 25-May-89    0.25    Allow SELECT/ADJUST on iconbar icon to open display
;; 14-Sep-89            Add menu options for Shutdown and state saving
;;  3-Oct-89    0.26    Set up auto-boot icon correctly
;;  4-Oct-89    0.27    Use inclusive parent box for Save dragging (Wimp's fault)
;;  6-Oct-89    0.28    Abort desktop save if Message_SaveDesktop is acknowledged
;;  6-Oct-89    0.29    Act on auto-boot icon setting
;; 17-Oct-89            Fix bug: max max should be 16Mb, not 4Mb
;;              0.30    Watch for >1 task starting between 2 Service_StartWimp's
;; 19-Oct-89    0.31    Scrub that, and watch for Message_TaskStarted
;; 20-Oct-89    0.32    Include flag word in PreQuit message
;; 27-Oct-89            Issue Service_WimpSaveDesktop for ColourTrans
;; 27-Oct-89    0.33    Include flag word in Message_SaveDesktop
;; 27-Oct-89    0.34    Check sender's task handle on receipt of c-s-f12
;; 30-Oct-89    0.35    Implement auto-saving of desktop
;;  8-Nov-89    0.36    Convert to use MessageTrans module
;; 13-Nov-89    0.37    Fix bug: set submenus correctly on Service_MessageFileClosed
;; 14-Nov-89    0.38    Ignore c-s-f12 if sent by quitreceiver
;;  5-Dec-89    0.39    Display Shutdown dbox rather than exitting
;;  6-Dec-89    0.40    Don't close savedbox if file dragged onto it, and read pointer posn first
;;  8-Dec-89            Recalculate slot size on null events (without Service_MemoryMoved)
;;  8-Dec-89    0.41    Implement *ChangeDynamicArea [-fontsize] [-spritesize] [-ramfssize]
;;  9-Dec-89    0.42    Suppress "Memory in use" errors when dragging bars
;; 31-Jan-90            Implement 'bigmac' switch for Fox version
;; 19-Feb-90    0.43    Include resource files within module
;; 26-Feb-90    0.44    Create icon using new prioritised Wimp_CreateIcon
;;                      Centred shutdown box on screen.
;;                      Added restart icon to shutdown dbox.
;;                      Added 'Create task window' menu entry and hot key (Shift-F12)
;;                      Changed Ctrl-Sh-F12 key to be Shutdown not Exit.
;; 03-Sep-90    0.45    Moved F12 function (command line) to Ctrl-F12.
;; 25-Sep-90            Fixed bug, restart shutdown killed switcher !
;;                      Fixed bug, only turn hourglass off before *Shutdown command, not
;; 25-Sep-90    0.46    on Ctrl-Sh-F12.
;; 17-Nov-90    0.47    Added SWI handler code and SWI TaskManager_TaskNameFromHandle
;; 16-Jan-90    0.48    Added info box to switcher.
;; 07-Mar-91    0.49    Get OS version number from OSByte 0.
;; 28-Mar-91    0.50    Added command line when no input focus. (conditional on CommandLine)
;;                      Added MessagesList and pass 300 to Wimp_Initialise
;;                      Changed F12 again, F12 = Command line Ctrl-F12 = task window.
;;                      Shift-F12 is used by Wimp for toggle iconbar.
;; 25-May-91    0.51    Added SWI TaskManager_EnumerateTasks
;; 29-May-91    0.52    Changed info box to use new template
;; 31-May-91    0.53    Moved iconbar icon down a bit to cope with larger acorn.
;; 22-Jul-91    0.54    Fixed bug, errors not reported from find font
;;                      Only find the font when the menu is up.
;; 29-Jul-91    0.55    Issue Service_Shutdown and Service_ShutdownComplete
;; 29-Jul-91    0.56    Scan savedesk filename to see if it's a boot file and configure filing system and drive.
;;              0.57    Fixed bug; address exception if desktop save file dragged into !Edit
;;              0.59    Bug fixes.
;; 15-Jan-92            Added <RETURN> to restart the desktop - and useful it is too!
;; 15-Jan-92            Added shutdown due to power loss dialogue box - displayed on first null event.
;; 16-Jan-92            Added two states to 'shutdown due to xyz' message - read from messages file.
;; 16-Jan-92            Bug fix: [RP-0095] allow -rma on ChangeDynamicArea
;; 16-Jan-92            Bug fix: [RP-0096] bad parameters on ChangeDynamicArea no longer go poohey!
;; 16-Jan-92            Add Switcher_Shutdown SWI.
;; 17-Jan-92            Added setting of CMOS bits to indicate shutdown state.
;; 17-Jan-92            Added flag decoding to stop pre-quit and stop restart dialogue being displayed.
;; 18-Jan-92            Bug fix: modify CMOS bits sometimes gets it wrong.
;; 18-Jan-92            Removed "-rma" from ChangeDynamicArea due to being loogied on by "Memory in use".
;; 18-Jan-92    0.60    Bug fix: Added interactive help for about operating system dialogue box.
;; 20-Jan-92            Added support for Drag-a-Sprite to switcher save dialogue box.
;; 20-Jan-92            Bug fix: RP-0295 use of curly quotes.
;; 20-Jan-92            Bug fix: RP-0709 illegal window handle on save error.
;; 20-Jan-92            Bug fix: G-RR-2267 save dialogue disappears before messages sent.
;; 20-Jan-92            Bug fix: G-RO-8315 interactive help and switcher killing tasks.
;; 20-Jan-92            Bug fix: internal sequence of setting CMOS state bits.
;; 20-Jan-92            Bug fix: G-RO-5950 finished internationalisation, ie. message look ups.
;; 20-Jan-92            Made it possible to assemble a stand alone version - with resources present.
;; 21-Jan-92            Bug fix: No stack / workspace on startup / SWI despatch.
;; 21-Jan-92    0.61    Bug fix: We no longer register our resources, handled by messages module.
;; 29-Jan-92            Added the sending of Message_Shutdown.
;; 29-Jan-92            Added trapping of UpCall 1,2 (media not present / media search).
;; 29-Jan-92    0.62    Removed all conditional code.
;; 03-Feb-92    0.63    Tweek for svc_MessagesFileClose.
;; 03-Feb-92    0.64    Bug fix: Stack in balance in menu decoding fixed.
;; 06-Feb-92    0.65    Lose font on die entry without workspace.
;; 11-Feb-92            Messages changed for Dr Tim and Martin Chipati.
;; 11-Feb-92            Bug fix: Clicking on OK button gets rid of the dialogue.
;; 11-Feb-92    0.66    Tidyed up the losing of workspace + fonts.
;; 13-Feb-92            Bug fix: menu deletion handling.
;; 15-Feb-92    0.67    Bug fix: correctly loses the font after a selection.
;; 21-Feb-92    0.68    Bug fix: Report error when saving boot file.
;; 12-Mar-92            Bug fix: Issues the shutdown via a WimpTask SWI.
;; 12-Mar-92    0.69    Bug fix: Loses font correctly on startup. [RP-1627]
;; 16-Mar-92    0.70    Remove sexed quotes from messages. RP-1271.
;; 02-Apr-92    0.71    Change info box font to Trinity to match title
;;                      screen G-RO-6153.
;; 02-Apr-92  0.72 OSS  Fixed template memory allocation to ask the wimp
;;                      how much memory needed - M-RP-0920. Put "power"
;;                      window (forced power shutdown) back into Templates!
;;                      Fixed bug - used to crash if !Help started in boot
;;                      sequence and forcible power-down window displayed.
;;                      Changed font in info box in Templates file to 32
;;                      point Trinity.Medium to match the code, thus the
;;                      font system doesn't find an uneeded font style
;;                      and size on Wimp_LoadTemplate.
;; 11-Apr-92  0.73 JSR  Fix Ctrl-Shft-F12 shutdown sequence to start in the
;;                      same way as a Menu=>ShutDown sequence. This prevents
;;                      the RAM disc being blown away without warning. RP-2302
;;                      Fix error returns from Wimp_CreateMenu to get
;;                      reported properly RP-2337.
;; 24-Apr-92    0.74    Fix to Shutdown SWI to trigger shutdown properly.
;; 25-Apr-92    0.75    Corrected type in power up dialogue.
;; ==================== Risc OS 2.00 release version
;; 28-May-92            Bug fix: address exception on info dialogue box when clicking with <menu>
;; 28-May-92            Changed to use new constant for swapping SysInfo - incase it changes
;; 10-Aug-92    0.76    Bug fix: template file using invalid colours for some icons
;; 15-Jul-93    0.79    (TMD) uses ReadDynamicArea on  platforms
;;                      NK - logarithmic memory bars added so that large memory eg. on Medusa
;;                      can be displayed sensibly. Added support for Dynamic Dyanic Areas (sic)
;;                      Updated templates to use 3D
;; 02-Sep-93    0.81    (SC) Use -1 in OS_ReadDynamicArea call to get max app space size
;; 16-Sep-93    0.82    Updated templates so that large memory displays fit on screen. (ugh!)
;;                      possible to drag slots so that all memory used. reorganised calc
;;                      memory map so that FindMemMapEntries not used.
;; 07-Oct-93    0.83    Fixed magical Boot file bug.
;; 18-Nov-93    0.84    doesn't reinit ramfs with only 4k
;; 01-Dec-93    0.85    fixed info year
;; 06-Dec-93    0.86    Removed auto boot option
;; 18-Jan-94    0.87    Fixed drag bars under Medusa.
;; 31-Jan-94    0.88    Does wimp_pollidle, increased task name size -> 32 chars
;; 21-Jul-94    0.89    Fix bug MED-03056
;; 23-Aug-94    0.90    SMC: Fix for MED-00079, now looks up comand help/syntax in messages file
;; 28-Oct-94    0.91    SMC: Added directed comments to Messages file for message tokenisation.
;; 23-May-95    0.96    JRC: Set access of written file to wr/r.
;; 21-Jun-95    0.97    RCM: On Stork, shutdown will now switch hardware off instead of
;;                      displaying shutdown/startup dbox.
;; 22-Jun-95    0.98    RCM: Add 'Freeze' entry to iconbar menu - active only on Stork
;;                      greyed out on other machines.
;;  1-Aug-95    0.99    JRC: Fix MED-5439: divide SWI table size by 4.
;;  7-Aug-95    1.00    RCM: 'setfreezeentry' was expecting Portable_ReadFeatures to return its
;;                      flags in the wrong register.
;;------------------------------------------------------------------------------------

        GET     Version

                GBLL    Swapping        ; Is it a swapping wimp?
Swapping        SETL    {FALSE}

                GBLL    SteppedMem      ; does the memory bar go up in steps or linear
SteppedMem       SETL    {TRUE}

                GBLL    standalone      ; cope with not registering with ResourceFS
standalone      SETL    {TRUE}

                GBLL    readareas       ; find sizes of real dynamic areas using OS_ReadDynamicArea
readareas       SETL    {TRUE}

                GBLL    DynamicAreas    ; Can cope with app-dynamic areas
DynamicAreas    SETL    {TRUE}

                GBLL    SwitchOff       ;Perform switch off on shutdown iff hardware supports it
SwitchOff       SETL    {TRUE}

                GBLL    Freeze          ;Freeze entry on menu
Freeze          SETL    {TRUE}

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:CMOS
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:VduExt
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:FileTypes
        GET     Hdr:NewErrors
        GET     Hdr:Sprite
        GET     Hdr:Variables
        GET     Hdr:Wimp
        GET     Hdr:WimpSpace
        GET     Hdr:Messages
        GET     Hdr:Proc
        GET     Hdr:MsgTrans
        GET     Hdr:ResourceFS
        GET     Hdr:Hourglass
        GET     Hdr:Font
        GET     Hdr:FileCore
        GET     Hdr:Switcher
        GET     Hdr:UpCall
        GET     Hdr:MsgMenus
        GET     Hdr:DragASprit
        GET     Hdr:Portable
        GET     Hdr:NDRDebug

        GBLL    hostvdu
hostvdu SETL    true

        GBLL    debug
        GBLL    debugxx
        GBLL    debugsw
        GBLL    debugab
        GBLL    debugsh
        GBLL    debugin
        GBLL    debugmn
        GBLL    debugif
        GBLL    debugkey

debug   SETL    false
debugxx SETL    false                   ; misc bits
debugsw SETL    false                   ; SWIs
debugab SETL    false                   ; Auto boot settings
debugsh SETL    false                   ; shutdown and restart bits
debugin SETL    false                   ; internationalisation bits
debugmn SETL    false                   ; menu handling
debugif SETL    false                   ; info box bits
debugkey  SETL  false

        ^       1
        AddError Switcher_BadTemplate,   "Template has wrong number of icons"
        AddError Switcher_CantFindBlock, "Can't find block"
        AddError UnknownTask,            "Task not known"
        AddError CantStartSwitcher,      "Use *Desktop to start the Task Manager"
        AddError NotRunning,             "Task Manager not active"

        MACRO
$l      MyError $blockdude,$c,$nostack,$j
$l      ADR$c$j R0,ErrorBlock_$blockdude
      [ "$nostack"<>""
        BL$c    lookup_erroralt
       |
        BL$c    lookup_error            ; assumes stack + workspace!
      ]
        MEND

;;-----------------------------------------------------------------------------
;; Register usage
;;-----------------------------------------------------------------------------

wsptr   RN      R12
userblk RN      R11

scy     RN      R11             ; re-used
scx     RN      R10
y1      RN      R9              ; register usage as in Wimp
x1      RN      R8
y0      RN      R7
x0      RN      R6
cy1     RN      R5
cx1     RN      R4
cy0     RN      R3
cx0     RN      R2


;;-----------------------------------------------------------------------------
;; Constants
;;-----------------------------------------------------------------------------

bignum          *       &10000000

;
; icon numbers in template file
;

ic_0            *       1

                ^       ic_0       ; NB: 1 added so 0 ==> no icon

ic_applichdr    #       1
ic_sysmemory    #       1
ic_modules      #       1
ic_dynamareas   #       1
ic_taskname     #       1          ; used for all tasks
ic_memoryK      #       1
ic_memoryBar    #       1
ic_slotname     #       1
ic_slotBar      #       1
ic_freename     #       1
ic_freeBar      #       1
ic_sys1         #       1          ; screen
ic_sys2         #       1          ; cursor/system/sound
ic_sys3         #       1          ; sys heap
ic_sys4         #       1          ; rma heap
ic_sys5         #       1          ; font cache
ic_sys6         #       1          ; sys sprites
ic_sys7         #       1          ; ram disc
ic_sys8         #       1          ; applications (free)
ic_sys9         #       1          ; applications (used)
ic_sys10        #       1          ; sys workspace
ic_totalname    #       1
ic_rmafree      #       1
ic_largestname  #       1
ic_cdaname      #       1
            [   Swapping
ic_swapfree     #       1
ic_swapused     #       1
ic_swapBar      #       1
            ]
numicons        *       @-1        ; allow for 1 added at the start

nareas          *       10         ; number of memory areas
notdynamic      *       &FF        ; flag ==> not a dynamic area

;
; icon row RMA block format
;
                ^       0
icb_link        #       4
icb_icon1       #       1
icb_icon2       #       1
icb_icon3       #       1
icb_height      #       1
icb_memsize     #       4
icb_size1       #       0          ; size if no name present
icb_taskage     #       4          ; 'age' of task (for saving desktop)
icb_taskhandle  #       4
icb_taskname    #       32
icb_size2       #       0


;;-----------------------------------------------------------------------------
;; Workspace allocation
;;-----------------------------------------------------------------------------

                ^       0,R12

mytaskhandle    #       4               ; put here so we know where it is
privateword     #       4
filertaskhandle #       4
shutdownflags   #       4
lastshutdown    #       4

pollword        #       0               ; encompasses file handle and memoryupdated
savedesk_handle #       1               ; file handle of deskboot file
memoryupdated   #       1               ; flags set => Service_MemoryMoved called
changetext      #       1               ; non-zero then update text icon
shutdown_swi    #       1               ; non-zero to indicate shutdown SWI issued

savedesk_taskhandle     #       4       ; handle of task to send dataload to
savedesk_loadmess       #       4       ; pointer to dataload message block
savedesk_nexttask       #       4       ; age of next task to consider
ml_savedbox     #       4               ; length of mb_savedbox
autosave        #       4               ; flag for savestate

menuclick       #       4               ; non-zero then called during decodemenu

global_taskage  #       4       ; for sorting tasks into order of creation

h_switcher      #       4       ; task window handle
wlink           #       4
windowx         #       4
windowy         #       4

dragBar         #       4       ; 0 if task display closed, -1 if open
                                ; >0 if dragging, -2 if just finished
menuhandle      #       4
prequitref      #       4
quitref         #       4
quitreceiver    #       4

dx              #       4       ; set up on Service_ModeChange
dy              #       4       ;
log2px          #       4       ;; vdu output block here
log2py          #       4       ;;
xwindlimit      #       4       ;;
ywindlimit      #       4       ;;

menutask        #       4       ; task handle of [menu_userblk]
recalc_extent   #       1
medusa_kernel   #       1
stepped_mem     #       1
errorendeddrag  #       1       ; last drag wasn't a save but an error prematurely ended it

        AlignSpace      16
pollblock       #       &200

stackbot        #       &200
stacktop        #       0

iconbariconhandle  #    4
h_shutdown      #       4

h_powerdown     #       4

messagedata     #       4       ; pointer to 16-byte message file descriptor
m_iconbarmenu_width #   4       ; original width of iconbarmenu

menu_userblk    #       4       ; pointer to task block

       AlignSpace       16

mb_newtask      #       &80             ; *command to pass to Wimp_StartTask
mb_taskname     #       40              ; Task '<taskname>'

ram_menustart   #       0
 [ Freeze
m_iconbarmenu   #       m_headersize+mi_size* 9
 |
m_iconbarmenu   #       m_headersize+mi_size* 8
 ]
m_task          #       m_headersize+mi_size* 1
m_newtask       #       m_headersize+mi_size* 1

ram_menuend     #       0

mm_info     *       m_iconbarmenu + m_headersize + mi_submenu + mi_size * mo_ic_info

mm_savedbox     *       m_iconbarmenu + m_headersize + mi_submenu + mi_size * mo_ic_savestate

h_savedbox      #       4               ; copied into mm_savedbox in CopyMenus
max_mem_drag    #       4               ; maximum memory for next drag

        [ standalone
    ! 0, "maximum drag at ":CC: :STR: :INDEX: max_mem_drag
        ]

shutdownflag    #       1               ; checked after shutdown finishes
savedragbutton  #       1
ramfsflag       #       1               ; version 0.41 onwards: set => re- RAMFSFiler
                #       1
mb_savedbox     #       4               ; set up when template loaded

shutdown_dbox   #       4

info_handle     #       4
version_icon    *       3

nextstring      #       4               ; -> next string to be put into icon / =-1 for OS version
keycount        #       1               ; index into string for the next character
                #       3               ; some more unused bits

info_font       #       4
author_icon     *       2

        AlignSpace      64

AuthorsText     #       40              ; modified string as required
AuthorsTextCopy #       40              ; temp copy made on startup from template

VersionBuffer   #       40

TaskName        #       40

; OSS pointer to where we have currently got to in using the indirected
; data area on the end. The memory is tacked onto the end of the workspace,
; after the window data for the task display.

ind_data_ptr    #       4               ; OSS Always points to start of data.
ind_data_curr   #       4               ; OSS How far we have got through it.
ind_data_end    #       4               ; OSS End of indirected data.

; OSS The task window comes directly on the end, so the existing code
; that uses ADR and LR straight into this data stil works.

wdef_header     #       0
maxwork         *       :INDEX:@

filler_header   #       84
wdef_nicons     #       4
wdef_icons      #       0


; values to put into shutdownflag

flg_nothing     *       0
flg_exit        *       1
flg_shutdown    *       2


; icon handles in "save" dbox

saveicon_file           *       0       ; file icon (filetype = Desktop)
saveicon_name           *       1       ; writeable icon (name)
saveicon_ok             *       2       ; OK box
saveicon_autoboot       *       3       ; option to auto-boot on reset
saveicon_autosave       *       4       ; option to auto-save on exit or shutdown

; icon handles in "power" dbox

powericon_message       *       0       ; warning text string
powericon_warning       *       1       ; sprite (warning symbol)

; state flags

state_normal            *       0:SHL:6 ; last power down was normal
state_shutdownfailed    *       1:SHL:6 ; shutdown was not completed
state_shutdowncomplete  *       2:SHL:6 ; shutdown completed
state_exit              *       bignum  ; internal use only - set on TaskManager_Shutdown

;;----------------------------------------------------------------------------
;; Module header
;;----------------------------------------------------------------------------

        LEADR   Module_LoadAddr

        ASSERT  (.=Module_BaseAddr)

MySWIBase       *       Module_SWISystemBase + SwitcherSWI * Module_SWIChunkSize

        DCD     Start          - Module_BaseAddr
        DCD     Init           - Module_BaseAddr
        DCD     Die            - Module_BaseAddr
        DCD     Service        - Module_BaseAddr
        DCD     Title          - Module_BaseAddr
        DCD     Helpstr        - Module_BaseAddr
        DCD     Helptable      - Module_BaseAddr
        DCD     MySWIBase
        DCD     Switcher_SWIdecode  - Module_BaseAddr
        DCD     Switcher_SWInames   - Module_BaseAddr
        DCD     0
 [ International_Help <> 0
        DCD     str_messagefile - Module_BaseAddr
 |
        DCD     0
 ]

Helpstr =       "Task Manager",9,"$VString ($Date)"
      [ debug
        =       " Development version"
      ]
      [ standalone
        =       " (Stand Alone)"
      ]
        =       0
        ALIGN

Helptable
switchercommand
        Command Desktop_TaskManager,0,0,International_Help
        Command ChangeDynamicArea,255,0,International_Help
        DCB     0

  [ International_Help <> 0
ChangeDynamicArea_Help          DCB     "HTMGCDA",0
ChangeDynamicArea_Syntax        DCB     "STMGCDA",0

Desktop_TaskManager_Help        DCB     "HTMGDTM",0
Desktop_TaskManager_Syntax      DCB     "HTMGDTM",0
  |
ChangeDynamicArea_Help
        DCB     "Allows the size of the font cache, system sprite area and RAM disc to be set up."
        DCB     13
ChangeDynamicArea_Syntax
        DCB     "Syntax: *ChangeDynamicArea [-FontSize <n>[K]] [-SpriteSize <n>[K]] [-RamFsSize <n>[K]]"
        DCB     0

Desktop_TaskManager_Help
        DCB     "The Task Manager module provides task management "
        DCB     "under the Desktop.",13,10
        DCB     "Do not use *Desktop_TaskManager, use *Desktop instead.",0

Desktop_TaskManager_Syntax
        DCB     "Syntax: *Desktop_"    ; drop through!
  ]
Title   DCB     "TaskManager",0
        ALIGN

;------------------------------------------------------------------------------
; Command decoding
;------------------------------------------------------------------------------

fontarea        *       4               ; font cache dynamic area number
spritearea      *       3               ; sprite area
ramfsarea       *       5               ; RAM disc area

                ^       0
vec_fontsize    #       4               ; fields in output vector
vec_spritesize  #       4
vec_ramfssize   #       4
ss_outputvec    *       &100

Keydef  DCB     "FontSize/K,SpriteSize/K,RamFsSize/K"
        DCB     0
        ALIGN

; NB: R12 -> private word (don't use workspace, as it may not be present)

ChangeDynamicArea_Code  ROUT
        Push    "R11,LR"
        MOV     R11,sp                  ; remember stack for later
;
        SUB     sp,sp,#ss_outputvec     ; local workspace
;
; scan the comand line by calling OS_ReadArgs
;
        MOV     R1,R0                   ; R1 = input string
        ADR     R0,Keydef               ; R0 = key defion string
        MOV     R2,sp                   ; R2 = output vector
        MOV     R3,#ss_outputvec        ; R3 = max output vector length
        SWI     XOS_ReadArgs
;
; scan the resulting vector for known fields
;
        MOVVC   R0,#fontarea
        LDRVC   R1,[sp,#vec_fontsize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#spritearea
        LDRVC   R1,[sp,#vec_spritesize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOVVC   R0,#ramfsarea           ; NB: do RAMFS last so others get done if it fails
        LDRVC   R1,[sp,#vec_ramfssize]
        BLVC    changeR0R1              ; R0 = area number, R1 = size required

        MOV     sp,R11                  ; restore stack
        Pull    "R11,PC"

; In    R0 = dynamic area number
;       R1 -> string specifying size required (<=0 => don't bother)
; Out   calls OS_ChangeDynamicArea, which gives Service_MemoryMoved
;       this is intercepted, and sets [memoryupdated]
;       this causes a pollword event:
;           which calls set_memory for all memory slots
;           if the RAM disc slot size changes to/from 0
;               [ramfsflag] is set
;               unless dragging the ram slot bar:
;                   reramfsfiler re-ialises the RAMFSFiler
;                   otherwise it waits till the bar is dropped

changeR0R1      ROUT
        Push    "R0-R3,LR"

        CMP     R1,#0
        Pull    "R0-R3,PC",LE

        SWI     XOS_ReadDynamicArea     ; R1 = current size of area
        MOVVC   R3,R1

        LDRVC   R1,[sp,#1*4]
        BLVC    getK                    ; R1 = new amount required

        LDRVC   R0,[sp,#0*4]
        SUBVC   R1,R1,R3                ; R1 = change required
        SWIVC   XOS_ChangeDynamicArea

        STRVS   R0,[sp]
        Pull    "R0-R3,PC"


; In    R1 --> string
; Out   R1 = parameter value (number)
; Errors: "Bad number"
;

getK    ROUT
        Push    "R2-R3,LR"
;
        MOV     R0,#10
        SWI     XOS_ReadUnsigned
        Pull    "R2-R3,PC",VS
;
        LDRB    R3,[R1]                 ; if terminator is "K" or "k",
        UpperCase R3, R14
        TEQ     R3,#"K"
        ADDEQ   R1,R1,#1
        MOVEQ   R2,R2,LSL #10           ; multiply by 1024
;
        LDRB    R14,[R1]                ; check terminator
        RSBS    R14,R14,#" "+1          ; ensure GT set if OK
        MyError BadNumb,LE              ; "Bad number"
;
        MOVVC   R1,R2                   ; R1 = answer
        Pull    "R2-R3,PC"
        MakeInternatErrorBlock BadNumb,,E04

;..............................................................................

; In    R0 -> command line
;       R12 -> private word (NB: we may not have any workspace!)

Desktop_TaskManager_Code  ROUT
        Push    "LR"

        LDR     r14, [r12]
        CMP     r14, #0
        BLE     %FT01

        LDR     r14, [r14, #:INDEX:mytaskhandle]
        CMP     r14, #0
        MOVEQ   r2, r0                  ; r2 --> command tail
        MOVEQ   r0, #ModHandReason_Enter
        ADREQL  r1, Title
        SWIEQ   XOS_Module
01
        MyError CantStartSwitcher,,,L
        Pull    "PC"

;------------------------------------------------------------------------------
; Decode SWIs recieved by the module.
;------------------------------------------------------------------------------

Switcher_SWIdecode ROUT

        Push    "LR"

        TEQP    PC,#SVC_mode            ; Ensure that IRQs are re-enabled
        LDR     wsptr,[R12]
        CMP     wsptr,#0                ; is the switcher active?
        MyError NotRunning,LE
        Pull    "PC",VS                 ; return if not

        CMP     R11,#(%10-%00)/4        ; remember to divide by 4 JRC 1st Aug 1995
        ADDCC   PC,PC,R11,LSL #2        ; handle the SWI if in a valid range
        B       %FT10
00
        B       SWITaskManager_TaskNameFromHandle
        B       SWITaskManager_EnumerateTasks
        B       SWITaskManager_Shutdown
10
        MyError NaffSWI
        Pull    "PC"                    ; return an error if the SWI is invalid

        MakeInternatErrorBlock NaffSWI,,BadSWI
        MakeInternatErrorBlock UnknownTask,,E02
        MakeInternatErrorBlock NotRunning,,E07

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Switcher_SWInames
        =       "TaskManager",0
        =       "TaskNameFromHandle",0
        =       "EnumerateTasks",0
        =       "Shutdown",0
        =       0
        ALIGN

;------------------------------------------------------------------------------
;
; TaskManager_TaskNameFromHandle
;
; Return the pointer to the task name relating to the task handle specified,
; you should copy this to your own workspace rather than assuming that its
; still safe at the pointer specified.
;
; in    R0 = handle
; out   R0 -> task name
;
;------------------------------------------------------------------------------

SWITaskManager_TaskNameFromHandle

        Push    "R1-R7"

        BL      findtask                        ; locate task from handle
        ADDGE   R0,userblk,#icb_taskname
        Pull    "R1-R7,PC",GE,^

        MyError UnknownTask
        Pull    "R1-R7,LR"
        ORRS    PC,LR,#V_bit                    ; return error if not able to find task

;------------------------------------------------------------------------------
;
; TaskManager_EnumerateTasks
;
; Enumerate all tasks currently active within the desktop (or known by the
; Task Manager).  The task name should always be copied to your own local
; workspace.
;
; in   R0 - 0 For first call or value from last call
;      R1 -> Word aligned Buffer
;      R2 = Buffer length
;
; out  R0 =  <0 If no more entries else value to pass to nect call
;      R1 -> First unused word in buffer
;      R2 = Number of unused bytes in buffer
;
;      [R1] - Filled with entries of the form:
;            [0]  =  Task handle.
;            [4]  -> Task name (This should be copied away and not used in place)
;            [8]  =  Amount of memory (in K) used by the task.
;            [12] =  Flags:
;                          bit 0  1 - Module task
;                                 0 - Application task.
;                          bit  1 1 - Slot bar can be dragged
;                                 0 - Slot bar cannot be dragged
;                          bits 2-31 reserved and are 0.
;
;------------------------------------------------------------------------------

SWITaskManager_EnumerateTasks ROUT

        Push    "R3-R5"

        CMP     R0,#0
        ADREQL  R0,wlink-icb_link

01      CMP     R2,#16                  ; Is there enough space in the buffer?
        LDRGE   R0,[R0,#icb_link]
        CMPGE   R0,#0                   ; Is this last entry?
        Pull    "R3-R5,PC",LT,^
        LDRB    R14,[R0,#icb_icon1]
        TEQ     R14,#ic_taskname
        BNE     %BT01

        LDR     R14,[R0,#icb_taskhandle]
        [ DynamicAreas
        CMP     R14,#0
        BEQ     %BT01
        ]
        STR     R14,[R1],#4
        ADD     R14,R0,#icb_taskname
        STR     R14,[R1],#4
        LDR     R14,[R0,#icb_memsize]
        STR     R14,[R1],#4
        MOV     R3,#0
        LDRB    R14,[R0,#icb_icon2]
        TEQ     R14,#ic_memoryK
        ORRNE   R3,R3,#1                ; Module task
        LDREQB  R14,[R0,#icb_icon3]
        TEQEQ   R14,#ic_slotBar
        ORREQ   R3,R3,#2                ; Bar can be dragged.
        STR     R3,[R1],#4
        SUB     R2,R2,#16
        B       %BT01

;------------------------------------------------------------------------------
;
; TaskManager_Shutdown implementation
;
; This call allows you to start the shutdown sequence of the desktop controlling
; the actions performed.
;
; in    R0 = flags relating to shutdown being performed
;               bit 0 set => don't display restart dialogue (eq. Exit)
;               bit 1 set => don't broadcast a PreQuit message
;               bit 2 set => flag as portable powerdown in CMOS
;               bit 3 set => send a Message_Shutdown
;               bit 4 set => reject UpCall_Media search
; out   -
;
;------------------------------------------------------------------------------

SWITaskManager_Shutdown Push "R0-R2"

        STR     R0,shutdownflags        ; store the internal flags
;
        LDR     R0,=state_exit
        STR     R0,lastshutdown         ; internal state to indicate we need to close down
;
        MOV     r0, #&ff
        STRB    r0, shutdown_swi
;
        MOV     R0,#UpCallV             ; its about to go bang!
        ADR     R1,upcallroutine
        ADR     R2,shutdownflags
        SWI     XOS_Claim               ; claim the UpCall routine
;
        Pull    "R0-R2,PC"

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; Handle UpCalls 1,2 if recieved and attempt to return that the media is not
; present if the flags word at [r2] iindicates that we must bounce UpCall's
; received.

upcallroutine
        TEQ     R0,#UpCall_MediaNotPresent
        TEQNE   R0,#UpCall_MediaNotKnown
        MOVNES  PC,LR                   ; if not one we want then carry on

        Push    "R1,LR"
        LDR     R1,[R12]
        TST     R1,#shutdownbit_RejectMediaSearch
        Pull    "R1,PC",EQ,^            ; if rejecting media search then exit

        MOV     R0,#-1                  ; nar-ne-nar-nar its not there!
        Pull    "R1,LR,PC",,^

;..............................................................................


Service ROUT
        Debug   xx,"Service ",r1

        TEQ     R1,#Service_StartWimp
        BEQ     svc_startwimp

        TEQ     R1,#Service_StartedWimp
        BEQ     svc_startedwimp

        TEQ     R1,#Service_Reset
        BEQ     svc_reset

      [ standalone
        [ {FALSE}
        DevMessage        "                Development Task Manager (",VString,")          - NOT FOR SALE"
        ]
        TEQ     R1,#Service_ResourceFSStarting
        BEQ     svc_resourcefsstarting
      ]

        LDR     wp, [r12]               ; the following routines need w/s
        CMP     wp, #0
        MOVLE   pc, lr

        TEQ     R1,#Service_MessageFileClosed
        BEQ     svc_messagefileclosed

        TEQ     R1,#Service_StartFiler
        STREQ   R0,filertaskhandle      ; for restarting RAMFS Filer
      [ debugxx
        BNE     %FT88
        Debug   xx,"Filer starting, handle is ",r0
88
      ]

        TEQ     R1,#Service_FilerDying
      [ debugxx
        BNE     %FT88
        Debug   xx,"filer dying"
88
      ]
        MOVEQ   R1,#0
        STREQ   R1,filertaskhandle
        MOVEQ   R1,#Service_FilerDying  ; preserve R1 !!!

        TEQ     R1,#Service_ModeChange
        BEQ     svc_modechange

        [ DynamicAreas
        TEQ     R1,#Service_DynamicAreaCreate
        BEQ     service_dynamicareacreate

        TEQ     R1,#Service_DynamicAreaRenumber
        BEQ     service_dynamicarearenumber

        TEQ     R1,#Service_DynamicAreaRemove
        BEQ     delete_dynamicarea
        ]

        TEQ     R1,#Service_MemoryMoved
        ASSERT  memoryupdated = pollword+1
        STREQB  R1,memoryupdated        ; non-0 ==> has been changed

        MOV     PC,LR

      [ standalone
svc_resourcefsstarting
        Push    "r0, lr"

        ADRL    r0, resourcefsfiles
        MOV     lr, pc                  ; LR -> return address
        MOV     pc, r2                  ; R2 -> address to call

        Pull    "r0, pc",,^
      ]

svc_startwimp
        Push    "r2,lr"

        LDR     r2, [r12]
        CMP     r2, #0
        Pull    "r2, pc", NE           ; don't claim service unless = 0

        BL      getworkspace
        ADRVCL  r0, switchercommand
        MOVVC   r1, #0                  ; Claim service

        Pull    "r2, pc"

;..............................................................................

svc_startedwimp
        Push    "lr"

        LDR     r14, [r12]
        CMP     r14, #-1
        MOVEQ   r14, #0                  ; unset flag (so user can retry)
        STREQ   r14, [r12]

        Pull    "pc"

svc_messagefileclosed
        Push    "r0,lr"

        BL      CopyMenus

        Pull    "r0,pc",,^

svc_reset
        Push    "R0-R6,LR"
;
        LDR     wp,[R12]                ; get the workspace pointer
        BL      freeworkspace           ; and attempt to free workspace if worked
;
        Pull    "R0-R6,PC",,^

;...........................................................................

; OSS This routine needs stack. R8 holds the accumuating indirect data size.

getworkspace ENTRY "r0-r8"
        LDR     r2, [r12]               ; do we have any workspace?
        CMP     r2, #0
        MOVNE   r12, r2
        EXITS   NE

; OSS Work out how much extra space needed for templates.

        ADRL    r1, templatefname       ; Switcher:Templates
        SWI     XWimp_OpenTemplate
        BVS     get_err

        MOV     r8, #0                  ; Count indirect space in r8.

        ADRL    r5, wn_grabkeys
        BL      template_space

        ADRVC   r5, wn_info
        BLVC    template_space

        ADRVC   r5, wn_savedbox
        BLVC    template_space

        ADRVC   r5, wn_switcher
        BLVC    template_space
        MOVVC   r7, r1                  ; Main window - space in r7.
        ADDVC   r7, r7, #3
        BICVC   r7, r7, #3              ; Round to word size.

        ADRVC   r5, wn_shutdown
        BLVC    template_space

        ADRVC   r5, wn_powerdown
        BLVC    template_space

        MOVVC   r1, #0
        MOVVS   r1, r0
        SWI     XWimp_CloseTemplate
        TEQ     r1, #0
        MOVNE   r0, r1
        SETV    NE
get_err
        STRVS   r0, [sp]
        EXIT    VS

; OSS Now claim workspace since we know the size needed.

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =maxwork
        ADD     r3, r3, r8              ; Indirected data
        ADD     r3, r3, r7              ; Main window
        SWI     XOS_Module
        MOVVS   r2, #-1                 ; avoid looping
        STR     r2, [r12]
        STRVC   r12, [r2, #:INDEX:privateword]
        MOV     wsptr,R2
        BVS     get_err

        MOV     r0, #0
        STR     r0, mytaskhandle
        STR     r0, messagedata
        STR     r0, filertaskhandle     ; for RAMFS Filer stuff
        STRB    r0,errorendeddrag
        MOV     R0, #-1
        STR     R0, wlink

; OSS Fill in initial and end pointer to indirected data, after the main
; window buffer.

        ADRL    r0, wdef_header         ; Address of end of workspace.
        ADD     r0, r0, r7              ; Add size of main window data
        STR     r0, ind_data_ptr        ; to give indirected start.
        ADD     r0, r0, r8              ; Add size of indirected data
        STR     r0, ind_data_end        ; to give end of indirected.

        EXIT

;...........................................................................

; OSS Function used to calculate memory needed for templates.

; Entry: R5 -> template name
;        R8 = memory used for indirect icons so far
; Exit:  R8 = indirected size for tis window added
;        R1 = Space required for main window buffer

template_space ROUT
        Push    "R1-R6,LR"

        MOV     r1, #-1                 ; Get size
        LDMIA   R5,{R4-R6}              ; Make a copy on the stack
        Push    "R4-R6"                 ; (the Wimp will write back the name)
        MOV     r4, #-1                 ; No fonts
        MOV     R5,R13                  ; R5 --> identifier
        MOV     R6,#0                   ; R6 = 0 ==> search whole of index
        SWI     XWimp_LoadTemplate
        ADD     R13,R13,#12             ; correct stack first!
        Pull    "R1-R6,PC",VS
;
        TEQ     R6,#0                   ; R6=0 ==> template entry not found
        MyError WimpNoTemplate,EQ,,L

        ADDVC   r8, r8, r2              ; Accumlate indirect size.
        ADDVC   r8, r8, #3
        BICVC   r8, r8, #3              ; Round up to word size.

        STRVC   r1, [sp]                ; Buffer space into r1 on stack
;
        Pull    "R1-R6,PC"

;...........................................................................

; Corrupts r0-r6

freeworkspace ROUT

        CMP     wp, #0                  ; clears V
        MOVLE   pc, lr
;
        MOV     r6, lr                  ; can't use stack on exit if USR mode
;
        BL      deallocatemessagedata   ; can use stack until block freed
;
        MOV     R0,#UpCallV             ; its about to go bang vector!
        ADR     R1,upcallroutine
        ADR     R2,shutdownflags
        SWI     XOS_Release             ; release my owner-ship if I have any!
;
        BL      removetochange          ; remove possible text changing handler
;
        LDR     r0, mytaskhandle
        CMP     r0, #0
        LDRGT   r1, taskidentifier
        SWIGT   XWimp_CloseDown         ; ignore errors from this

        LDR     R4,wlink                ; deallocate task blocks
01
        SUBS    R2,R4,#0
        LDRGT   R4,[R2,#icb_link]
        MOVGT   R0,#ModHandReason_Free
        SWIGT   XOS_Module
        CMP     R4,#0                   ; in case V set
        BGT     %BT01
;
        BL      deallocate_loadmess     ; stack not yet deallocated
        BL      losefont                ; and then lose the font
;
        MOV     r2, r12
        LDR     r12, privateword
        MOV     r14, #0                 ; reset flag word anyway
        STR     r14, [r12]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module

        MOV     pc, r6

svc_modechange
        Push    "R0-R3,LR"              ; here r12 --> workspace
                                        ; NB also called from within Start
        ADR     R0,vduinput
        ADRL    R1,log2px
        SWI     XOS_ReadVduVariables
        LDMIA   R1,{R2,R3}              ; log2px, log2py
        MOV     R14,#1
        MOV     R2,R14,LSL R2
        MOV     R3,R14,LSL R3
        ASSERT  dx = log2px-8
        ASSERT  dy = log2px-4
        STMDB   R1,{R2,R3}              ; dx, dy (leave log2px/y intact)

        Pull    "R0-R3,PC",,^

refind_font
        Push    "r0-r7,LR"

        BL      losefont                ; lose the font
        BVS     %FT01

        ADR     R1,InfoBoxFont
        MOVS    R2,#32*16
        MOV     R3,#32*16
        MOV     R4,#0                   ; locate the font at the current resolution
        MOV     R5,#0
        SWI     XFont_FindFont
        BVS     %FT01

        STR     R0,info_font

        MOV     R2,R0,ASL #24
        MOV     R3,#&ff:SHL:24          ; modify the icon state to reflect the new icon state
        LDR     R0,info_handle
        MOV     R1,#0
        ADR     R14,pollblock
        STMIA   R14,{R0-R3}
        MOV     R1,R14
        SWI     XWimp_SetIconState

01      STRVS   r0,[sp]
        Pull    "r0-r7,PC"

InfoBoxFont
        =      "Trinity.Medium",0
        ALIGN

vduinput
        DCD     VduExt_XEigFactor
        DCD     VduExt_YEigFactor
        DCD     VduExt_XWindLimit
        DCD     VduExt_YWindLimit
        DCD     -1


;;----------------------------------------------------------------------------
;; Errors
;;----------------------------------------------------------------------------

        MakeInternatErrorBlock CantStartSwitcher,,UseDesk

Init    Push    "R0,LR"

; initialise Switcher$Path if not already done

        ADR     R0, Path
        MOV     R2, #-1
        MOV     R3, #0
        MOV     R4, #VarType_Expanded
        SWI     XOS_ReadVarVal          ; returns R2=0 if doesn't exist
        CMP     R2, #0                  ; clears V as well!

        ADREQ   R0, Path
        ADREQ   R1, PathDefault
        MOVEQ   R2, #?PathDefault
        MOVEQ   R3, #0
        MOVEQ   R4, #VarType_String
        SWIEQ   XOS_SetVarVal


      [ standalone
        ADRL    R0, resourcefsfiles
        SWI     XResourceFS_RegisterFiles
      ]

        Pull    "R0,PC",,^

Path            DCB     "Switcher$Path"
                DCB     0
PathDefault     DCB     "Resources:$.Resources.Switcher."
                DCB     0
                ALIGN

;..............................................................................

Die
        Push    "R0-R6,LR"
;
        LDR     wp, [r12]
;
      [ standalone
        ADRL    R0, resourcefsfiles
        SWI     XResourceFS_DeregisterFiles ; ignore errors
      ]
;
        BL      freeworkspace           ; attempt to release workspace
;
        Pull    "R0-R6,PC"

taskidentifier  DCB     "TASK"


;;----------------------------------------------------------------------------
;; Entry point
;;----------------------------------------------------------------------------

                ASSERT  ((.-Module_BaseAddr):AND:3)=0

wn_switcher     DCB     "taskmenu",0

                ALIGN
wn_grabkeys     DCB     "grabkeys",0            ; must be word-aligned

                ALIGN
wn_info         DCB     "proginfo",0            ; must be word-aligned

                ALIGN
wn_savedbox     DCB     "save",0                ; must be word-aligned

                ALIGN
wn_shutdown     DCB     "shutdown",0            ; must be word-aligned

                ALIGN
wn_powerdown    DCB     "power",0               ; must be word-aligned

str_boot        DCB     "!Boot",0
str_armboot     DCB     "!ArmBoot",0
str_altboot     DCB     "<Choices$Write>.Boot.Tasks",0
str_altbootfn   DCB     "<Choices$Write>.Boot.Tasks.!Boot",0

templatefname   DCB     "Switcher:Templates",0   ; relies on Wimp$Path ; AMcC 18-Oct-94 changed from Template3D
switchertitle   DCB     "task",0
                ALIGN

MessagesList    DCD     Message_HelpRequest
                DCD     Message_DataSaveAck
                DCD     Message_MenusDeleted
                DCD     Message_SaveDesktop
                DCD     Message_SetSlot
                DCD     Message_PreQuit
                DCD     Message_TaskStarted
                DCD     Message_SlotSize
                DCD     Message_TaskNameRq
                DCD     Message_Swap
                DCD     Message_TaskCloseDown
                DCD     Message_TaskInitialise
                DCD     Message_ModeChange
                DCD     0
                ALIGN

Start   LDR     wp, [r12]               ; get workspace pointer
        MOV     sp, #bignum             ; ensure stack pointer is invalid

        MyError CantStartSwitcher,,NoChuffinStack

        CMP     wp, #0
        SWILE   OS_GenerateError

        LDR     r14, mytaskhandle       ; mustn't be already running
        CMP     r14, #0
        SWIGT   OS_GenerateError

        ADRL    sp, stacktop            ; STACK IS NOW VALID!

        ADR     R1,switchertitle        ; -> token
        ADRL    R2,TaskName
        MOV     R3,#?TaskName           ; R2,R3 = -> buffer, size of buffer
        BL      lookup_nopars
        BVS     ErrorAbort              ; cannot ignore th error

        MOV     r0, #300                ; we know about wimp 3.00 and have a messages list.
        LDR     r1, taskidentifier
        ADRL    r2, TaskName
        ADR     r3,MessagesList
        SWI     Wimp_Initialise

        LDR     R14,=273
        CMP     R0,R14                  ; needs Wimp with new iconbar stuff
        BCC     ErrorOldWimp

        STR     R1,mytaskhandle
;
; initialise sundry silly persons workspace
;
        LDR     r14, ind_data_ptr
        STR     r14, ind_data_curr      ; Move to start of indirected data.
        MOV     R14,#0
        STR     R14,global_taskage
        STR     R14,savedesk_loadmess
        ASSERT  savedesk_handle = pollword + 0
        ASSERT  memoryupdated = pollword + 1
        ASSERT  changetext = pollword +2
        STR     R14,pollword
        STR     R14,shutdownflags       ; reset shutdown flags
        STRB    R14,ramfsflag           ; set => re-init RAMFSFiler
        STR     R14,info_font           ; tag as having lost workspace
        STR     R14,prequitref
        STR     R14,quitref
        STR     R14,dragBar             ; task display closed
        STRB    R14,mb_newtask
        STR     R14,shutdown_dbox
        STR     R14,h_powerdown         ; no powerdown dialogue yet!
;
        BL      svc_modechange          ; ensure this data is set up
;
; read window definitions from template file
;
        ADRL    R1,templatefname        ; Switcher:Templates
        SWI     XWimp_OpenTemplate
        BVS     ErrorAbort
;
        ADR     R4,pollblock
        MOV     R0,#0
        MOV     R1,#65                  ; = 256 bytes (plus caution)

01      STR     R0,[R4],#4
        SUBS    R1,R1,#1
        BNE     %BT01
;
        ADR     R4,pollblock
        ADRL    R1,wdef_header
        ADRL    R5,wn_info

        BL      int_loadtemplate
        BVS     ErrorCloseTemplate
        ADRL    R1,wdef_header

        ADR     R0,pollblock

01      LDRB    R14,[R0],#1
        TEQ     R14,#0
        BEQ     %BT01                   ; loop until first non-zero byte is located

        ADR     R14,pollblock
        SUB     R0,R0,R14
        SUB     R0,R0,#1
        STR     R0,info_font            ; find the font handle

        ADD     R14,R1,#(w_icons+i_size*version_icon+i_data) ; Point icon at right text.
        ADRL    R0,VersionBuffer+8
        STR     R0,[R14]

        ADD     R14,R1,#(w_icons+i_size*author_icon+i_data)
        LDR     R2,[R14]

        ADR     R0,AuthorsText
        STR     R0,[R14]                ; change the text pointer

        ADRL    R8,AuthorsTextCopy      ; temporary buffer

01      LDRB    R14,[R2],#1
        STRB    R14,[R0],#1
        STRB    R14,[R8],#1
        CMP     R14,#32                 ; finished copying title away yet?
        BGE     %BT01                   ; loop back until finished

        SWIVC   XWimp_CreateWindow      ; create window (handle =R0)
        BVS     ErrorCloseTemplate
;
        STR     R0,info_handle          ; sub menu window handle
;
        ADRL    R1,wdef_header
        ADR     R5,wn_savedbox
        BL      loadtemplate
        SWIVC   XWimp_CreateWindow
        ADRVCL  R14,h_savedbox          ; fill in submenu pointer
        STRVC   R0,[R14]

        MOVVC   R0,#ReadCMOS
        MOVVC   R1,#FileLangCMOS
        SWIVC   XOS_Byte
        BVS     ErrorCloseTemplate

        LDR     R14,wdef_icons + i_size*saveicon_name + i_data+8
        ADRL    R1,ml_savedbox
        STR     R14,[R1]

        LDR     R1,wdef_icons + i_size*saveicon_name + i_data
        ADRL    R14,mb_savedbox
        STR     R1,[R14]

        [ {TRUE}
        Push    "R0-R1,R3-R5"
        MOV     R0,#17                  ; no search
        ADRL    R1,str_altboot
        SWI     XOS_File
        BVS     %FT00
        TEQ     R0,#2
        BNE     %FT00
        ADRL    R2,str_altbootfn
        Pull    "R0-R1,R3-R5"
        B       %FT01
00
        CLRV
        Pull    "R0-R1,R3-R5"
        ]
        [ {FALSE}
        ; bad idea according to JR
        TEQ     R2,#fsnumber_net
        ADREQL  R2,str_armboot
        ADRNEL  R2,str_boot
        |
        ADRL	R2,str_boot
        ]
01      LDRB    R14,[R2],#1             ; copy in appropriate boot filename
        STRB    R14,[R1],#1
        TEQ     R14,#0
        BNE     %BT01

        ADRL    R1,wdef_header
        ADR     R5,wn_switcher          ; must be word-aligned (makes a copy)
        BL      loadtemplate
        BVS     ErrorCloseTemplate
        LDR     R14,wdef_nicons
        TEQ     R14,#numicons
        MyError Switcher_BadTemplate,NE
        BVS     ErrorCloseTemplate
        MOV     R14,#0
        STR     R14,wdef_nicons         ; construct them on the fly!
;
        SWI     XWimp_CreateWindow
        STRVC   R0,h_switcher           ; remember window handle
;
        ADRVC   R1,pollblock            ; temporary workspace
        ADRVC   R5,wn_grabkeys
        BLVC    loadtemplate
        SWIVC   XWimp_CreateWindow
        MOVVC   R1,#-bignum
        MOVVC   R2,#-bignum
        ADDVC   R3,R1,#100
        ADDVC   R4,R2,#100
        MOVVC   R5,#0
        MOVVC   R6,#0
        MOVVC   R7,#-1                  ; open at front
        Push    "R0-R7"
        MOVVC   R1,sp
        SWIVC   XWimp_OpenWindow
        ADD     sp,sp,#4*8

        ADRVC   R1,pollblock
        ADRVC   R5,wn_shutdown
        BLVC    loadtemplate
        SWIVC   XWimp_CreateWindow
        STRVC   R0,h_shutdown           ; create the shutdown window
        BVS     %FT10                   ; if errored then skip over this dinkey bit
;
        MOV     R0,#ReadCMOS
        LDR     R1,=FileSwitchCMOS
        SWI     XOS_Byte                ; get back PowerStatus CMOS
        ANDS    R6,R2,#SwitcherShutdownCMOSBits
        STR     R6,lastshutdown         ; store state of last shutdown
        BEQ     %FT10                   ; if >0 then load template, otherwise don't bother

        ADRNE   R1,pollblock
        ADRNE   R5,wn_powerdown
        BLNE    loadtemplate            ; get the template
;
        LDR     R2,[R1,#(i_data+ii_buffer)+w_icons]
        LDR     R3,[R1,#(i_data+ii_length)+w_icons]
        Debug   sh,"Load message into buffer, size =",R2,R3
;
        SWINE   XWimp_CreateWindow      ; create the PowerDown window (handle back in R0)
        STR     R0,h_powerdown
;
        LDR     R0,=&3050
        ORR     R0,R0,R6,LSL #2         ; combine to make suitable token
        Debug   sh,"Token of message to read =",R0
        Push    "R0"                    ; push onto the stack ready to look up
        MOV     R1,sp
        BL      lookup_nopars
        ADD     sp,sp,#4                ; balance the stack after filling in icon name
10      BVS     ErrorCloseTemplate
;
        SWI     XWimp_CloseTemplate
        BLVC    CopyMenus               ; do this after loading templates
        BLVC    losefont                ; lose the font again
;
; create iconbar entry
;
        ADRVC   r14, icondef            ; icon flags + data
        LDMVCIA r14, {x0,y0,x1,y1}
        Push    "x0,y0,x1,y1"

        MOVVC   r0, #SpriteReason_ReadSpriteSize
        ADRVC   r2, icondef+4                   ; r2 -> sprite name
        SWIVC   XWimp_SpriteOp                  ; r3, r4 = pixel size

        MOVVC   r0, r6                          ; creation mode of sprite

        MOVVC   r1, #VduExt_XEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   x0, #0
        ADDVC   x1, x0, r3, LSL r2              ; pixel size depends on sprite

        MOVVC   r1, #VduExt_YEigFactor
        SWIVC   XOS_ReadModeVariable
        MOVVC   y0, #-8
        ADDVC   y1, y0, r4, LSL r2

        MOVVC   r0, #-8
        Push    "r0,x0,y0,x1,y1"
        LDRVC   r0, =WimpPriority_TaskManager
        MOVVC   R1,sp                           ; create iconbar entry
        SWIVC   XWimp_CreateIcon
        STRVC   R0,iconbariconhandle            ; for *Shutdown!
;
        ADD     sp,sp,#36                       ; correct stack

; what kernel are we running on?
        BVS     %FT07
        MOV     R0,#134
        SWI     XOS_ReadDynamicArea             ; is there a kernel free pool
        MOV     R0,#0
        MOV     R1,#0
        BVS     %FT05
        MOV     R0,#1
        CMP     R2,#4*1024*1024                 ; Is max size > 4 Meg?
        MOVGT   R1,#1
05
        STRB    R0,medusa_kernel
        STRB    R1,stepped_mem
        CLRV
07

;
; build up initial data structure for window display
;

        BLVC    setupwindowblocks
        BVS     ErrorAbort
;
        ADR     r0, com_unset                   ; "*Unset SaveDesk$File"
        SWI     XOS_CLI
;
; Update MOS version in the dialogue box
;
        MOV     R0,#0
        MOV     R1,#0
        SWI     XOS_Byte                        ; get error with version message.

        ADD     R0,R0,#4
        ADRL    R1,VersionBuffer                ; skip error number and copy the string

01      LDRB    R14,[R0],#1
        STRB    R14,[R1],#1
        CMP     R14,#0
        BNE     %BT01                           ; copy the string into the buffer;
;
        B       repollwimp                      ; reports errors and carries on

        LTORG

com_unset DCB   "%Unset SaveDesk$File", 0
          ALIGN

        MakeInternatErrorBlock  Switcher_BadTemplate,,E00

icondef         DCD     &D7006002               ; flags
                DCB     "switcher",0            ; data
                ALIGN

ErrorCloseTemplate
        Push    "R0"
        SWI     XWimp_CloseTemplate
        Pull    "R0"

ErrorAbort
        MOV     R1,#2                   ; cancel only
        ADRL    R2,TaskName
        SWI     XWimp_ReportError

        BL      freeworkspace           ; on exit R12 --> private word
        MOV     R14,#-1                 ; error in initialisation
        STR     R14,[R12]
        SWI     OS_Exit
        LTORG

ErrorOldWimp
        SWI     XWimp_CloseDown
        SWI     XOS_WriteI+4            ; just in case (old Wimp!)
        MyError WimpNotPresent

ErrorNoWimp
        SWI     OS_GenerateError        ; can't use Wimp to report error!

        MakeInternatErrorBlock WimpNotPresent,,NoWimp ; "Window Manager not present / too old"

;;----------------------------------------------------------------------------
;; Polling loop
;;----------------------------------------------------------------------------
;
; errors in polling subroutines are reported at the top of the loop
; the program then continues where it left off
;

repollwimp
;        wsaddr  R1,pollblock,VS
;        MOVVS   R2,#0
;        STRVS   R2,[R1]
        ADRVSL  R2,TaskName
        MOVVS   R1,#1                   ; OK button
        STRVSB    R1,errorendeddrag
        SWIVS   XWimp_ReportError
;
        MOV     R0,#null_bit :OR: pointerchange_bits
        LDR     R14,dragBar
        CMP     R14,#0
;
        Debug   sh,"ShutDown state (prior to Wimp_Poll) =",#lastshutdown
;
        LDREQ   R14,lastshutdown        ; what sort was the previous shutdown?
        CMPEQ   R14,#0
        BICNE   R0,R0,#null_bit         ; need null events if task window open or previous shutdown was a failure
        ORR     R0,R0,#pollword_enable
        wsaddr  R1,pollblock            ; must be at least 256 bytes
        MOV     R2,#0                   ; in case Wimp older than 2.53
        wsaddr  R3,pollword             ; if non-zero, give a poll word event
        BL      MyXWimp_Poll
        BVS     repollwimp

;       Debug   xx,"R2 on exit from Wimp_Poll =",R2
;
        ADR     LR,repollwimp
        CMP     R0,#(endjptable-jptable)/4
        ADDCC   PC,PC,R0,LSL #2
        MOV     PC,LR

jptable
        B       null_event              ;  0
        B       redraw_window           ;  1
        B       open_window             ;  2
        B       close_window            ;  3
        MOV     PC,LR                   ;  4  pointer leaving window
        MOV     PC,LR                   ;  5  pointer entering window
        B       mouse_click             ;  6
        B       drag_complete           ;  7
        B       key_pressed             ;  8
        B       menu_selection          ;  9
        MOV     PC,LR                   ; 10  scroll request
        MOV     PC,LR                   ; 11
        MOV     PC,LR                   ; 12  gain caret
        B       pollword_event          ; 13  pollword non-zero
        MOV     PC,LR                   ; 14
        MOV     PC,LR                   ; 15
        MOV     PC,LR                   ; 16
        B       messagereceived         ; 17
        B       messagereceived_rec     ; 18
        B       messagereceived_rtn     ; 19
endjptable


;;----------------------------------------------------------------------------
;; Window Open/Close etc.
;;----------------------------------------------------------------------------

;
; Entry:  R1 --> block to put window in
;         R5 --> window identifier (word-aligned)
; Exit:   data read into block
;         error if template entry not known
;

loadtemplate ENTRY "r4"
        MOV     r4,#-1
        BL      int_loadtemplate
        EXIT

int_loadtemplate
        Push    "R1-R7,LR"

;                                       ; R1 --> buffer for window definition
        LDR     R2,ind_data_curr        ; R2 --> buffer for indirected icons
        LDR     R3,ind_data_end         ; R3 --> buffer end
        LDMIA   R5,{R5-R7}              ; make a copy on the stack
        Push    "R5-R7"                 ; (the Wimp will write back the name)
        MOV     R5,R13                  ; R5 --> identifier
        MOV     R6,#0                   ; R6 = 0 ==> search whole of index
        SWI     XWimp_LoadTemplate
        ADD     R13,R13,#12             ; correct stack first!
        Pull    "R1-R7,PC",VS
;
        TEQ     R6,#0                   ; R6=0 ==> template entry not found
        MyError WimpNoTemplate,EQ
        STRVC   R2,ind_data_curr
;
        Pull    "R1-R7,PC"

        MakeInternatErrorBlock  WimpNoTemplate,,E06

open_window
        SWI     XWimp_OpenWindow
        MOV     PC,LR

close_window
        MOV     R0,#0                   ; assume it's the task window
        STR     R0,dragBar
        SWI     XWimp_CloseWindow
        MOV     PC,LR

front_window
        Push    "LR"
        SUB     sp,sp,#u_windowstate    ; handle,x0,y0,x1,y1,scx,scy,bh,flags
        MOV     R1,sp
        STR     R0,[R1]
        SWI     XWimp_GetWindowState    ; read initial info
        MOVVC   R14,#-1
        STRVC   R14,[R1,#u_bhandle]     ; open at top
        SWIVC   XWimp_OpenWindow
        ADD     sp,sp,#u_windowstate    ; correct stack
        Pull    "PC"

; in    R0 = handle of window
;       R1 -> buffer to be used
; out   R1 -> block ready to open the window centred
;             [pollblock] corrupt!

centre_window
        Push    "R0-R1,LR"

        MOV     R0,#-1
        MOV     R1,#4
        SWI     XOS_ReadModeVariable    ; Get XEig
        MOV     R3,R2

        MOV     R1,#5
        SWI     XOS_ReadModeVariable    ; Get YEig
        MOV     R4,R2

        MOV     R1,#11
        SWI     XOS_ReadModeVariable    ; Get X pixels.
        MOV     R3,R2,ASL R3            ; X size in OS Units

        MOV     R1,#12
        SWI     XOS_ReadModeVariable    ; Get Y pixels.
        MOV     R4,R2,ASL R4            ; Y size in OS Units.

        Pull    "R0-R1"                 ; restore the handle of the window
        STR     R0,[R1]
        SWI     XWimp_GetWindowState    ; read initial info
        BVS     %FT01

        MOV     R14,#-1
        STR     R14,[R1,#u_bhandle]     ; open at top

        LDR     R14,[R1,#u_wax1]        ; Set correct x position.
        LDR     R5,[R1,#u_wax0]
        SUB     R5,R14,R5
        MOV     R5,R5,LSR #1            ; Half x size.
        MOV     R3,R3,LSR #1            ; Half screen x size.
        SUB     R14,R3,R5
        STR     R14,[R1,#u_wax0]
        ADD     R14,R3,R5
        STR     R14,[R1,#u_wax1]

        LDR     R14,[R1,#u_way1]        ; Set correct y position.
        LDR     R5,[R1,#u_way0]
        SUB     R5,R14,R5
        MOV     R5,R5,LSR #1            ; Half y size.
        MOV     R4,R4,LSR #1            ; Half screen x size.
        SUB     R14,R4,R5
        STR     R14,[R1,#u_way0]
        ADD     R14,R4,R5
        STR     R14,[R1,#u_way1]
01
        Pull    "PC"

; In    y0 = amount to scroll window by (+ve => scroll down)
; Out   R0 -> error block if V set
;       R0 corrupt if V clear

scrolltaskwindow ROUT
        LDR     R0,h_switcher

scroll_window
        Push    "R1,cx0,cy0,cx1,cy1,x1,y1,LR"

        STR     R0,[sp,#-u_windowstate]!
        MOV     R1,sp
        SWI     XWimp_GetWindowState    ; read initial info
        BVS     %FT99

        LDMIA   R1,{R0,cx0,cy0,cx1,cy1,x1,y1}
        SUB     y1,y1,y0                ; scroll up/down
        LDR     R14,wdef_header+w_wey1
        SUBS    R14,y1,R14              ; can't scroll off the top
        SUBGT   cy1,cy1,R14             ; so move top of window down
        SUBGT   y1,y1,R14
        STMIA   R1,{R0,cx0,cy0,cx1,cy1,x1,y1}
        SWI     XWimp_OpenWindow
99
        ADD     sp,sp,#u_windowstate    ; correct stack
        Pull    "R1,cx0,cy0,cx1,cy1,x1,y1,PC"

;;----------------------------------------------------------------------------
;; Set up initial window block list
;;----------------------------------------------------------------------------

;
; Entry:  standard icon definitions read into wdef_icons
; Exit:   wlink --> first block in chain (in RMA)
;         each block describes the appearance of one row in the window
;

setupwindowblocks ROUT
        Push    "R1-R4,LR"
;
        ADRL    R2,wlink - icb_link
;
; application tasks:
;
        MOV     R1,#ic_applichdr
        BL      allocateblock           ; R2 --> block afterwards
        LDRVC   R1,=ic_slotname:OR:(ic_memoryK:SHL:8):OR:(ic_slotBar:SHL:16)
        BLVC    allocateblock
        LDRVC   R1,=ic_freename:OR:(ic_memoryK:SHL:8):OR:(ic_freeBar:SHL:16)
        BLVC    allocateblock
      [ Swapping                        ; Check if there is a swap file.
        Push    "R0"
        BVS     %FT02
        MOV     R0,#WimpSysInfo_Swapping
        SWI     XWimp_ReadSysInfo       ; R0 -> flag , size , used.
        BVS     %FT02
        LDR     R14,[R0]
        CMP     R14,#0
        BEQ     %FT02
        LDR     R14,[R0,#4]
        CMP     R14,#0
        BEQ     %FT01
        LDRVC   R1,=ic_swapfree:OR:(ic_memoryK:SHL:8):OR:(ic_swapBar:SHL:16)
        BLVC    allocateblock
01
        LDRVC   R1,=ic_swapused:OR:(ic_memoryK:SHL:8):OR:(ic_swapBar:SHL:16)
        BLVC    allocateblock
02
        Pull    "R0"
      ]
;
; module tasks:
;
        MOVVC   R1,#ic_modules
        BLVC    allocateblock
        LDRVC   R1,=ic_rmafree:OR:(ic_memoryK:SHL:8):OR:(ic_memoryBar:SHL:16)
        BLVC    allocateblock
        ADDVC   R1,R1,#1
        BLVC    allocateblock
;
; memory map:
;
        MOVVC   R1,#ic_sysmemory
        BLVC    allocateblock
        MOVVC   R4,#ic_sys1
        MOVVC   R3,#nareas+1            ; include total
01
        ADRL    R14,dynamicareas-ic_sys1
        LDRB    R14,[R14,R4]            ; can this area be moved?
        TEQ     R14,#notdynamic
        ORRNE   R1,R4,#ic_slotBar:SHL:16
        ORREQ   R1,R4,#ic_memoryBar:SHL:16
        ORR     R1,R1,#ic_memoryK:SHL:8
        BLVC    allocateblock
        BVS     %FT02
        ADD     R4,R4,#1
        SUBS    R3,R3,#1
        BNE     %BT01
02
        [ DynamicAreas
        LDRB    R1,medusa_kernel
        CMP     R1,#0
        BEQ     %FT03
        MOVVC   R1,#ic_dynamareas
        BLVC    allocateblock
03
        ]
;
; set up memory sizes for various fields
;
        BLVC    calc_memorymap
        BLVC    calc_slotsize
        BLVC    calc_rmasize
;
        MOVVC   R0,#ic_totalname
        BLVC    findblock
        LDRVC   R1,[userblk,#icb_memsize]
        BLVC    calcbarcoords
        ADRVCL  R1,wdef_header+w_wex0
        LDMVCIA R1,{cx0,cy0,cx1,cy1}
        ADDVC   cx1,x1,#16              ; right-hand extent = bar + a bit
        STRVC   cx1,wdef_header+w_wex1
        STRVC   cx1,wdef_icons+(ic_applichdr-1)*i_size+i_bbx1
        STRVC   cx1,wdef_icons+(ic_sysmemory-1)*i_size+i_bbx1
        [ DynamicAreas
        LDRB    R0,medusa_kernel
        CMP     R0,#0
        BEQ     %FT04
        STRVC   cx1,wdef_icons+(ic_dynamareas-1)*i_size+i_bbx1
04
        ]
        STRVC   cx1,wdef_icons+(ic_modules-1)*i_size+i_bbx1
        LDRVC   R0,h_switcher
        SWIVC   XWimp_SetExtent         ; R1 --> cx0,cy0,cx1,cy1
;
        Pull    "R1-R4,PC"
        LTORG

;-----------------------------------------------

calc_memorymap
        Push    "R1-R9,userblk,LR"
;
        MOV     R0,#ic_sys1
        BL      findblock               ; userblk --> first item in chain

        [ :LNOT: readareas
;
        SWIVC   XOS_ReadMemMapInfo      ; R0 = page size, R1 = no of pages
        MOVVC   R3,R1,LSL #2
        ADDVC   R3,R3,R3,LSL #1         ; R3 = 12 * no of pages
        ADDVC   R3,R3,#4                ; allow for terminator
        MOVVC   R0,#ModHandReason_Claim
        SWIVC   XOS_Module              ; R2 --> block
        Pull    "R1-R9,userblk,PC",VS
;
        MOV     R0,R2
01
        SUBS    R1,R1,#1                ; pages R1-1 to 0
        STRGE   R1,[R0],#12
        BGT     %BT01
        MOV     R14,#-1                 ; terminator
        STR     R14,[R0]
        MOV     R0,R2
        SWI     XOS_ReadMemMapEntries   ; can't give errors (I hope)
        Pull    "R1-R9,userblk,PC",VS
;
; analyse pages by comparing addresses with known locations
;
        ]
        MOV     R9, #0                  ; R9=total (initially 0)
        MOV     R0, #nareas+1           ; number of areas + 1 for total
11
        Push    "R9"
        SUBS    R0,R0,#1
        BNE     %BT11
;

        [ :LNOT: readareas
        SWI     XOS_ReadMemMapInfo      ; R0 = page size (again)
;
        Push    "R2"                    ; remember block address
01
        LDR     R14,[R2],#4
        CMP     R14,#0                  ; terminator?
        BLT     gotcounts
;
        ADR     R1,thresholds
        LDR     R3,[R2],#8              ; R3 = address of this page
        MOV     R4,#0                   ; R4 = counter index
02
        LDR     R14,[R1],#4
        CMP     R3,R14                  ; is R3 >= next threshold?
        ADDCS   R4,R4,#1                ; on to next one
        BCS     %BT02
        ADR     R14,ttrtable
        LDRB    R4,[R14,R4]             ; translate to real number (+ 1)
        LDR     R14,[sp,R4,LSL #2]
        ADD     R14,R14,R0              ; add in page size
        STR     R14,[sp,R4,LSL #2]
        ADD     R9,R9,R0                ; total
        B       %BT01

gotcounts
        Pull    "R2"                    ; deallocate the heap block
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module              ; ignore errors
;
        STR     R9,[sp,#nareas*4]       ; put into array (last one)
        ]

 [ readareas
        MOV     r0,#32*1024
        STR     r0, [sp, #1*4]          ; cursor sound DMA, fixed size.
        STR     r0, [sp, #9*4]
        MOV     r0, #0                  ; system heap
        SWI     XOS_ReadDynamicArea
        ADDVC   r1, r1, #8*1024         ; add on svcstk amount
        STRVC   r1, [sp, #2*4]
        MOV     r0, #1                  ; RMA
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #3*4]
        MOV     r0, #2                  ; screen
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #0*4]
        MOV     r0, #3                  ; sprites
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #5*4]
        MOV     r0, #4                  ; fonts
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #4*4]
        MOV     r0, #5                  ; ramdisc
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #6*4]
        LDRB    R0,medusa_kernel
        CMP     R0,#0
        BEQ     %FT05
        MOV     r0,#6+128                   ; freepool
        SWI     XOS_ReadDynamicArea
        STRVC   r1, [sp, #7*4]
        STRVC   r2, [sp,#nareas*4]           ; total memory in system
05
        MOV     r1,#0                   ; add up used memory
        MOV     r0,#ic_taskname
        BL      findblock
33
        LDRVC   r14,[userblk,#icb_memsize]
        ADDVC   r1,r1,r14
        LDRVC   userblk,[userblk,#icb_link]
        BVS     %FT35
        LDRB    R14,[userblk,#icb_icon1]
        TEQ     R14,#ic_taskname
        BEQ     %BT33
35
        CLRV
        STR     r1,[sp,#8*4]
 ]
;
        MOV     R0,#ic_sys1
        BL      findblock               ; userblk,x0,y0 --> first item
;
        MOV     R3,#nareas+1            ; number to do
01
        Pull    "R1"
        BL      set_memory
        SUBS    R3,R3,#1
        LDRNEB  R14,[userblk,#icb_height]
        SUBNE   y0,y0,R14
        LDRNE   userblk,[userblk,#icb_link]
        BNE     %BT01

        BL      reinitramfsfiler        ; in case RAM disc slot changed

        Pull    "R1-R9,userblk,PC"

ttrtable                        ; 1 added due to R2 on stack
        DCB     10              ; system workspace (0..&7FFF)
        DCB     8               ; applications (free)
        DCB     7               ; RAM disc
        DCB     6               ; system sprites
        DCB     4               ; rma
        DCB     3               ; system heap/stack
        DCB     5               ; font cache
        DCB     2               ; cursor/sound
        DCB     9               ; applications (used)
        DCB     1               ; screen
        ASSERT  (.-ttrtable)=nareas

dynamicareas
        DCB     2               ; screen
        DCB     notdynamic      ; cursor/sound
        DCB     0               ; system heap/stack
        DCB     1               ; rma
        DCB     4               ; font cache
        DCB     3               ; system sprites
        DCB     5               ; RAM disc
        DCB     notdynamic      ; applications (free)
        DCB     notdynamic      ; applications (used)
        DCB     notdynamic      ; system workspace (0..&7FFF)
        DCB     notdynamic      ; total
        ASSERT  (.-dynamicareas)=nareas+1
        ALIGN

thresholds                      ; system workspace
        DCD         &8000       ; applications (free)
        DCD      &1000000       ; RAM disc
        DCD      &1400000       ; system sprites
        DCD      &1800000       ; rma
        DCD      &1C00000       ; system heap/stack
        DCD      &1E00000       ; font cache
        DCD      &1F00000       ; cursor/sound
        DCD      &1F08000       ; applications (used)
        DCD      &1F80000       ; screen
        DCD     &7FFFFFFF
        ASSERT  (.-thresholds)=nareas*4

;-----------------------------------------------

calc_slotsize
      [ Swapping                        ; Get swap file sizes.
        Push    "R0-R3,x0,y0,userblk,LR"
        MOV     R0,#WimpSysInfo_Swapping
        SWI     XWimp_ReadSysInfo
        Pull    "R0-R3,x0,y0,userblk,PC",VS
        LDR     R1,[R0]
        CMP     R1,#0
        BEQ     %FT02
        LDR     R1,[R0,#4]
        LDR     R2,[R0,#8]
        CMP     R1,#0
        BEQ     %FT01
        SUB     R1,R1,R2
        LDRB    R14,[userblk,#icb_height]
        SUB     y0,y0,R14
        MOV     R0,#ic_swapfree
        BL      findblock               ; x0,y0 = top-left of row
        Pull    "R0-R3,x0,y0,userblk,PC",VS
        BL      set_memory                      ; R1 = new memsize
01
        MOVVC   R1,R2
        LDRVCB  R14,[userblk,#icb_height]
        SUBVC   y0,y0,R14
        MOVVC   R0,#ic_swapused
        BLVC    findblock               ; x0,y0 = top-left of row
        Pull    "R0-R3,x0,y0,userblk,PC",VS
        BLVC    set_memory                      ; R1 = new memsize
02
        Pull    "R0"
      |
        Push    "R1-R3,x0,y0,userblk,LR"
      ]
;
        MOV     R0,#-1
        MOV     R1,#-1
        SWI     XWimp_SlotSize
        Pull    "R1-R3,x0,y0,userblk,PC",VS
;
        SUBS    R2,R2,R1                ; free = free - slot size
        ADDLT   R1,R1,R2                ; can't be < 0
        MOVLT   R2,#0
        MOV     R0,#ic_slotname
        BL      findblock               ; x0,y0 = top-left of row
        Pull    "R1-R3,x0,y0,userblk,PC",VS
;
        BL      set_memory                      ; R1 = new memsize
        MOVVC   R1,R2                           ; userblk,x0,y0 set up
        LDRVCB  R14,[userblk,#icb_height]
        SUBVC   y0,y0,R14
        LDRVC   userblk,[userblk,#icb_link]
        BLVC    set_memory                      ; R1 = new memsize
;
        Pull    "R1-R3,x0,y0,userblk,PC"

;
; In    R1 = new memsize field
;       [userblk,#icb_memsize] = old memsize field
;       x0,y0 = top-left of area to invalidate
;       [userblk,#icb_height] = height of row
; Out   memsize field updated, and screen too if different
;       [ramfsflag] set if RAM disc slot changes to/from 0

set_memory
        Push    "R1-R4,x0,y0,x1,y1,LR"

        LDR     R14,[userblk,#icb_memsize]
        TEQ     R1,R14
        Pull    "R1-R4,x0,y0,x1,y1,PC",EQ

      [ Swapping
        B       %FT01
int_set_memory
        Push    "R1-R4,x0,y0,x1,y1,LR"
        LDR     R14,[userblk,#icb_memsize]
01
      ]


        [ {TRUE}
; MED-00375 fix (S Cormie)
        CMP     R14,#0
        BLT     %FT02
        CMP     R14,#8*1024             ; 8k is real RAMFS minimum
        CMPCS   R1,#8*1024
        BCS     %FT02                   ; old and new >=8k
        LDRB    R14,[userblk,#icb_icon1]
        CMP     R14,#ic_sys7
        ASSERT  ic_sys7 <> 0
        STREQB  R14,ramfsflag           ; this is the RAM disc
02
        |
        CMP     R14,#0                  ; old size = -1 => don't set flag
        CMPGT   R1,#0                   ; otherwise set if old/new size = 0
        LDREQB  R14,[userblk,#icb_icon1]
        CMPEQ   R14,#ic_sys7            ; and this is the RAM disc,
        ASSERT  ic_sys7 <> 0
        STREQB  R14,ramfsflag           ; set [ramfsflag]
        ]

        wsaddr  R14,wdef_icons+(ic_memoryK-1)*i_size+i_bbx0
        LDMIA   R14,{R1-R4}
        SUB     R14,R4,R2
        MOV     R4,y0
        SUB     R2,R4,R14
        LDR     R0,h_switcher
        SWI     XWimp_ForceRedraw       ; redraw textual memory box
        Pull    "R1-R4,x0,y0,x1,y1,PC",VS

        Push    "x0,y0"
        LDR     R1,[userblk,#icb_memsize]
        BL      calcbarcoords           ; x0,y0,x1,y1 = box coords
        Pull    "x0,y0"
        MOV     R3,x1                   ; R3 = first x-coord
        LDR     R1,[sp,#0*4]
        STR     R1,[userblk,#icb_memsize]
        BL      calcbarcoords
        CMP     R3,x1
        LDR     R14,dx
        SUBLT   x0,R3,R14,ASL #1        ; include old border if growing !
        SUBGE   x0,x1,R14               ; include new border if shrinking
        MOVGE   x1,R3
        Push    "x0,y0,x1,y1"
        Pull    "R1-R4"
        LDR     R0,h_switcher
        SWI     XWimp_ForceRedraw       ; redraw bar

        Pull    "R1-R4,x0,y0,x1,y1,PC"

;-----------------------------------------------

calc_rmasize
        Push    "R1-R3,x0,y0,userblk,LR"
;
        MOV     R0,#ModHandReason_RMADesc
        SWI     XOS_Module
        MOVVC   R0,#ic_rmafree
        BLVC    findblock
        Pull    "R1-R3,x0,y0,userblk,PC",VS
;
        MOV     R1,R3                           ; total free rma memory
        BL      set_memory
        LDRB    R14,[userblk,#icb_height]
        SUB     y0,y0,R14
        LDR     userblk,[userblk,#icb_link]
        MOV     R1,R2                           ; largest block claimable
        BL      set_memory
;
        Pull    "R1-R3,x0,y0,userblk,PC"

;-----------------------------------------------

;
; Entry:  R0 = icon number to find (left-hand one only)
;         [wlink] --> list of blocks
; Exit:   userblk --> block (if found)
; Errors: block not found
;

findblock
        Push    "LR"
;
        LDR     userblk,wlink
        LDR     x0,wdef_header+w_wex0
        LDR     y0,wdef_header+w_wey1
01
        CMP     userblk,#0
        BLT     %FT02
        LDRB    R14,[userblk,#icb_icon1]
        TEQ     R14,R0
        LDRNEB  R14,[userblk,#icb_height]
        SUBNE   y0,y0,R14
        LDRNE   userblk,[userblk,#icb_link]
        BNE     %BT01
;
        Pull    "PC"
02
        MyError Switcher_CantFindBlock
        Pull    "PC"
        MakeInternatErrorBlock Switcher_CantFindBlock,,E01

;
; Entry:  cx0,cy0 = coords of mouse pointer (rel. to window)
;         [wlink] --> list of blocks
; Exit:   userblk --> block (<=0 if not found)
;         x0,y0 = coords of top-left of row
;

findclick
        Push    "LR"
;
        LDR     userblk,wlink
        LDR     x0,wdef_header+w_wex0
        LDR     y0,wdef_header+w_wey1
01
        LDRB    R14,[userblk,#icb_height]
        SUB     R14,y0,R14
        CMP     cy0,R14
        MOVLT   y0,R14
        LDRLT   userblk,[userblk,#icb_link]
        BLT     %BT01
;
        Pull    "PC"

;
; Entry:  R1 = icon numbers/flag word to put into block
;         R2 --> previous block
;         R3 --> text (if R1b = ic_taskname)
; Exit:   R2 --> current block (allocated in RMA)
;         [old R2,#icb_link] = new R2
;         [new R2,#icb_link] = -1
;         name copied into block if R1b suitable
;

allocateblock
        Push    "R3-R5,LR"
;
        MOV     R4,R2
        AND     R14,R1,#&FF
        CMP     R14,#ic_dynamareas
        MOVLE   R5,#56                  ; height of row
        MOVGT   R5,#40
        TEQ     R14,#ic_taskname
        TEQNE   R14,#ic_cdaname
        MOVNE   R3,#icb_size1
        MOVEQ   R3,#icb_size2
        MOV     R0,#ModHandReason_Claim
        SWI     XOS_Module
        Pull    "R3-R5,PC",VS
;
        STR     R2,[R4,#icb_link]
        STR     R1,[R2,#icb_icon1]      ; actually set up all 4 bytes
        MOV     R14,#-1
        STR     R14,[R2,#icb_link]
        STR     R14,[R2,#icb_memsize]
        STRB    R5,[R2,#icb_height]
        Pull    "R3-R5,PC",NE           ; don't copy name unless it's a task
;
        LDR     R14,global_taskage      ; for sorting tasks into order
        ADD     R14,R14,#1              ; (used when saving desktop)
        STR     R14,global_taskage
        STR     R14,[R2,#icb_taskage]
        Debug   xx,"New task's age =",R14

        LDR     R3,[sp,#0*4]
        ADD     R4,R2,#icb_taskname
        MOV     R0,#icb_size2-icb_taskname
01
        SUBS    R0,R0,#1
        MOVLE   R14,#0                  ; terminator
        LDRGTB  R14,[R3],#1
        STRB    R14,[R4],#1
        CMP     R14,#32
        BGE     %BT01
;
        Pull    "R3-R5,PC"


;;----------------------------------------------------------------------------
;; Redraw_Window
;;----------------------------------------------------------------------------

redraw_window
        Push    "LR"
;
        SWI     XWimp_RedrawWindow
        Pull    "PC",VS
;
        LDMIA   R1,{cx0,x0,y0,x1,y1,scx,scy}
        SUB     x0,x0,scx
        SUB     y0,y1,scy
        STR     x0,windowx              ; remember window origin
        STR     y0,windowy

drawloop
        TEQ     R0,#0
        Pull    "PC",EQ
;
        Push    "R1"
;
; draw the rows that intersect with the clip rectangle
; Entry:  R1 --> pollblock (containing redraw data)
;
        ADD     R14,R1,#r_gwx0
        LDMIA   R14,{cx0,cy0,cx1,cy1}
        LDR     x0,windowx
        LDR     y0,windowy
        SUB     cx0,cx0,x0
        SUB     cy0,cy0,y0
        SUB     cx1,cx1,x0
        SUB     cy1,cy1,y0
;
        LDR     x0,wdef_header+w_wex0   ; start at top-left of extent
        LDR     y0,wdef_header+w_wey1
;
; (bodge for now - just draw the lot)
; x0,y0 = coords of top-left of current row
;
        LDR     userblk,wlink           ; userblk --> current row block
01
        CMP     y0,cy0
        LDRGTB  R14,[userblk,#icb_height]
        SUBGT   R14,y0,R14
        CMPGT   cy1,R14
        BLE     %FT02
;
        LDRB    R0,[userblk,#icb_icon1]
        BL      ploticon
        LDRB    R0,[userblk,#icb_icon2]
        BL      ploticon
        LDRB    R0,[userblk,#icb_icon3]
        BL      ploticon
02
        LDRB    R14,[userblk,#icb_height]
        SUB     y0,y0,R14               ; suitable offset (in row block)
        LDR     userblk,[userblk,#icb_link]
        CMP     userblk,#0
        BGT     %BT01
;
        Pull    "R1"
        SWI     XWimp_GetRectangle
        BVC     drawloop
;
        Pull    "PC"

;
; Entry:  R0 = icon 'template' number
;         x0,y0 = coords of top-left of current row
;         userblk --> relevant RMA block
; Exit:   icon plotted, all registers except R0,flags preserved
;         copy of icon is made on the stack, so the original is preserved
;
; Special icons:
;         ic_taskname     use task name in [userblk,#icb_taskname..]
;         ic_memoryK      use memory size in [userblk,#icb_memsize]
;         ic_memoryBar    use memory size in [userblk,#icb_memsize]
;         ic_slotBar      ditto
;         ic_freeBar      ditto
;

ploticon
        TEQ     R0,#0
        MOVEQ   PC,LR
;
        Push    "R0-R9,LR"
;
        ADRL    R1,wdef_icons-i_size    ; icon number is +1 (0 = none)
        ADD     R1,R1,R0,LSL #i_shift
        LDMIA   R1,{R2-R9}              ; 8 words = 32 bytes (1 icon)
        Push    "R2-R9"
        MOV     R1,sp                   ; R1 --> copy of icon (on stack)
        ASSERT  i_bbx0=0
        ASSERT  cx0=R2                  ; cx0,cy0,cx1,cy1 = icon box
;
        LDR     x0,[sp,#i_size+6*4]     ; get these back
        LDR     y0,[sp,#i_size+7*4]
;
        TEQ     R0,#ic_taskname
        TEQNE   R0,#ic_cdaname
        ADDEQ   R14,userblk,#icb_taskname
        STREQ   R14,[R1,#i_data+0]      ; indirected icon address
        TEQ     R0,#ic_memoryK
        BLEQ    setmemstring
;
        TEQ     R0,#ic_memoryBar
        TEQNE   R0,#ic_slotBar
        TEQNE   R0,#ic_freeBar
      [ Swapping
        TEQNE   R0,#ic_swapBar
      ]
        BLEQ    setmembar               ; alters y0 (to bodge height)
;
        SUB     cy0,cy0,cy1
        MOV     cy1,y0
        ADD     cy0,cy0,cy1
;
        STMIA   R1,{cx0,cy0,cx1,cy1}
        SWI     XWimp_PlotIcon          ; R1 --> icon definition
        ADD     sp,sp,#i_size
;
        Pull    "R0-R9,PC",,^

;
; Entry:  R1 --> icon definition
;         [userblk,#icb_memsize] = memory size (bytes)
;

setmemstring
        Push    "R0-R2,LR"
;
        LDR     R0,[userblk,#icb_memsize]
        MOV     R0,R0,ASR #10           ; R0 = memory size in K
        ADD     R1,R1,#i_data           ; R1 --> buffer
        MOV     R2,#11                  ; R2 = buffer size-1 (for "K")
        SWI     XOS_ConvertInteger4
        MOVVS   R14,#"?"                ; use "?" to report errors!
        MOVVC   R14,#"K"
        STRB    R14,[R1],#1
        MOV     R14,#0
        STRB    R14,[R1],#1
;
        Pull    "R0-R2,PC",,^

;
; Entry:  R1 --> icon definition
;         cx0,cy0,cx1,cy1 = current position of icon
;         x0,y0 = position of row within window
;         [userblk,#icb_memsize] = memory size (bytes)
; Exit:   cx1 updated to reflect the number of pages
;

setmembar
        Push    "R0-R1,userblk,LR"
;
        LDR     R14,wdef_icons+i_size*(ic_memoryK-1)+i_bby1
        LDR     R0,wdef_icons+i_size*(ic_memoryBar-1)+i_bby1
        SUB     R0,R0,R14
        ADD     y0,y0,R0                ; bodge y0 to move bar a bit
;
        LDR     R14,[userblk,#icb_memsize]
        CMP     R14,#0
        MOVLE   R14,#is_deleted         ; mark deleted if null
        STRLE   R14,[R1,#i_flags]
        Pull    "R0-R1,userblk,PC",LE,^
;
        SUB     cx1,cx1,cx0             ; multiply by unit size
        [ SteppedMem
        Push    "R0-R3"
        LDRB    R0,medusa_kernel
        CMP     R0,#0
        BEQ     %FT05
        MOV     cx1,cx1, LSR #2         ; divide unit size by 4 on Medusa
        LDRB    R0,stepped_mem
        CMP     R0,#0
        BEQ     %FT05
        MOV     R1,R14
        MOV     R3,#0
        MOV     R0,#0
        MOV     R2,#512*1024
03
        CMP     R1,R2
        ADDLT   R14,R3,R1, LSR R0
        BLT     %FT05
        ADD     R3,R3,#512*1024
        SUB     R1,R1,R2
        ADD     R0,R0,#1
        MOV     R2,R2, LSL #1
        B       %BT03
05
        Pull    "R0-R3"
        ]

        MUL     userblk,R14,cx1         ; hope we don't get overflow!
        SWI     XOS_ReadMemMapInfo      ; R0 = page size
        DivRem  cx1,userblk,R0, R14     ; userblk = number of pages
        ADD     cx1,cx0,cx1
;
        Pull    "R0-R1,userblk,PC",,^

;
; Entry:  R1 = value to be represented by the bar
;         x0,y0 = position of row within window
;         userblk --> row block
; Exit:   x0,y0,x1,y1 = coords of bar within window
;

calcbarcoords
        Push    "R0-R1,cy1,LR"
        [ SteppedMem
        LDRB    R14,stepped_mem
        CMP     R14,#0
        BEQ     %FT07
        MOV     R14,#0
        MOV     R0,#0
        MOV     cy1,#512*1024
03
        CMP     R1,cy1
        ADDLT   R1,R14,R1, LSR R0
        BLT     %FT05
        ADD     R14,R14,#512*1024
        SUB     R1,R1,cy1
        ADD     R0,R0,#1
        MOV     cy1,cy1, LSL #1
        B       %BT03
05
07
        ]
;
        LDR     R14,wdef_icons+i_size*(ic_memoryK-1)+i_bby1
        LDR     R0,wdef_icons+i_size*(ic_memoryBar-1)+i_bby1
        SUB     R0,R0,R14
        ADD     cy1,y0,R0               ; bodge y0 to move bar a bit
;
        ADRL    R0,wdef_icons-i_size+i_bbx0
        LDRB    R14,[userblk,#icb_icon3]
        ADD     R14,R0,R14,LSL #i_shift
        LDMIA   R14,{x0,y0,x1,y1}
        SUB     R14,y1,y0
        MOV     y1,cy1
        SUB     y0,y1,R14
;
        SUB     x1,x1,x0                ; multiply by unit size

        LDRB    cy1,medusa_kernel
        CMP     cy1,#0
        MOVNE   x1,x1,LSR #2            ; use 4x fewer OS units on Medusa

        MUL     cy1,R1,x1               ; hope we don't get overflow!
        SWI     XOS_ReadMemMapInfo      ; R0 = page size
        DivRem  x1,cy1,R0, R14
        LDR     R14,dx
        CMP     x1,R14
        MOVLT   x1,R14                  ; bar must be at least 1 pixel wide
        ADD     x1,x0,x1                ; (to ensure border fits!)
;
        Pull    "R0-R1,cy1,PC",,^


;;----------------------------------------------------------------------------
;; Message passing
;;----------------------------------------------------------------------------

;
; Entry:  R0 = reason code
;         R1 --> message to send
;         R2 = task handle to send to
; Exit:   buffer copied to stack and sent using Wimp_SendMessage
;         R2 = my_ref field on exit from Wimp_SendMessage
;

sendmessage
        Push    "R3,R4,LR"
;
        LDR     R3,[R1,#ms_size]
        SUB     sp,sp,R3
        MOV     R4,sp
01
        LDR     R14,[R1],#4
        STR     R14,[R4],#4
        SUBS    R3,R3,#4
        BNE     %BT01
;
        MOV     R1,sp
        SWI     XWimp_SendMessage
        LDRVC   R2,[sp,#ms_myref]       ; remember myref field
        MOV     sp,R4                   ; R4 --> end of buffer (= old sp)
;
        Pull    "R3,R4,PC"


messagereceived_rec
messagereceived
        Push    "LR"

        LDR     R0,[R1,#ms_action]

        LDR     R14,=Message_HelpRequest
        TEQ     R0,R14
        BEQ     returnhelp

        TEQ     R0,#Message_DataSaveAck
        BEQ     mes_datasaveack

        LDR     R14,=Message_MenusDeleted
        TEQ     R0,R14
        BLEQ    losefont                ; lose font for dialogue
        BLEQ    removetochange          ; remove possible text changing routine
        Pull    "PC",EQ

        TEQ     R0,#Message_Quit
        BNE     trytaskinit
;
        LDR     R0,[R1,#ms_myref]
        LDR     R14,quitref             ; ignore my own message
        TEQ     R0,R14
   ;    LDREQ   R14,quitreceiver        ; (unless it was explicit?)
   ;    TEQEQ   R14,#0                  ; if commented out, you can't kill it!
        Pull    "PC",EQ

        B       exitanddie
        LTORG

messagereceived_rtn
        LDR     R0,[R1,#ms_action]
        LDR     R2,[R1,#ms_myref]

        TEQ     R0,#Message_SaveDesktop
        BEQ     savedesk_bounced        ; LR is on stack

        Push    "LR"

        LDR     R14,=Message_SetSlot
        TEQ     R0,R14
        BEQ     task_cantslot
;
        TEQ     R0,#Message_PreQuit     ; is this the end of the PreQuit phase?
        LDREQ   R14,prequitref
        TEQEQ   R2,R14
        BEQ     done_prequit
;
        TEQ     R0,#Message_Quit
        LDREQ   R14,quitref
        TEQEQ   R2,R14
        Pull    "PC",NE                 ; ignore ALL BUT my own message

; everyone else has closed down - now look at [shutdownflag]

        LDRB    R14,shutdownflag
        TEQ     R14,#flg_shutdown
        BEQ     doshutdown

doexitbits
        B       exitanddie
        LTORG

doshutdown
        SWI     XHourglass_On           ; ensure switched HourGlass on

        ADR     R0,str_shutdown
        SWI     XOS_CLI                 ; ignore errors

        MOV     R0,#-2
        LDR     R1,iconbariconhandle
        Push    "R0,R1"
        MOV     R1,sp
        SWI     XWimp_DeleteIcon        ; ignore errors
        ADD     sp,sp,#8

        ADRL    R1,h_switcher           ; close main window
        BL      close_window

        MOV     R1,#-1                  ; close menus
        SWI     XWimp_CreateMenu

        SWI     XHourglass_Off          ; remove the Hourglass
;
        LDR     R0,shutdownflags
        TST     R0,#shutdownbit_ModifyStateCMOS
        LDRNE   R2,=state_shutdowncomplete
        BLNE    writestate              ; if modifying CMOS then flag as correctly shutdown
;
        TST     R0,#shutdownbit_NoRestartDialogue
        BNE     %FT10                   ; then exit the desktop having disabled the hourglass
 [ SwitchOff
        SWI     XPortable_ReadFeatures
        BVC     %FT10                   ;VC, on Stork, so don't put up restart dbox cos we have software switch off
 ]
;
        LDR     R0,h_shutdown
        SUB     sp,sp,#u_windowstate    ; get suitable buffer
        MOV     R1,sp
        BL      centre_window           ; open the shutdown window centred to the screen (R1 -> window block)
        SWIVC   XWimp_OpenWindow
;
        LDRVC   R0,h_shutdown
        MOVVC   R1,#-1
        MOVVC   R2,#bignum
        MOVVC   R3,#bignum
        MOVVC   R4,#0
        MOVVC   R5,#0
        SWIVC   XWimp_SetCaretPosition  ; Give shutdown window caret
01
        ADD     sp,sp,#u_windowstate    ; correct stack

        MOV     R0,#-1
        STR     R0,shutdown_dbox        ; shutdown dbox now on screen.
10
        MOV     R1,#Service_ShutDownComplete
        SWI     XOS_ServiceCall         ; Broadcast to inform the world that the shutdown is complete
;
        LDR     R0,shutdownflags        ; do I need to display the restart dialogue?
        TST     R0,#shutdownbit_NoRestartDialogue
        BNE     doexitbits
 [ SwitchOff
        SWI     XPortable_ReadFeatures
        BVC     %FT31                   ;VC, its a portable
        CLRV                            ;VS, not a portable, must clear V to suppress
        B       %FT33                   ;    the 'SWI &42FC5 not known' error
31
        MOV     R0, #PortableBMUC_RemovePower   ;Throw the switch Egor
        SWI     XPortable_CommandBMU            ;
32
        BVC     %BT32                   ;VC, command accepted so loop until power disappears
        B       %BT31                   ;VS, switch off command gave an error!, try again
                                ;RCM says: comment out above branch to get the error reported
33
 ]
;
        Pull    "PC"                    ; just loop to ensure redraw!

str_shutdown    DCB     "WimpTask ShutDown", 0
                ALIGN

str_restart     DCB     "Desktop -File <Desktop$File>", 0
str_restart1    DCB     "Desktop",0
restart_varname DCB     "Desktop$File",0
                ALIGN

restart BL      freeworkspace

        SWI     XOS_Reset               ; on RISC OS 3.5 and above, do total reset
        CLRV

        ADR     r0,restart_varname
        MOV     r2,#-1
        MOV     r3,#0
        MOV     r4,#3
        SWI     XOS_ReadVarVal

        CMP     r2,#0
        ADRNE   r0,str_restart
        ADREQ   r0,str_restart1
        SWI     XOS_CLI                 ; ignore errors
        SWI     OS_Exit

;..............................................................................

done_prequit
        ADR     R1,msg_quit
        LDR     R2,quitreceiver         ; broadcast / single task
        TEQ     R2,#0
        MOVEQ   R0,#User_Message_Recorded  ; ackowledgeable message
        MOVNE   R0,#User_Message        ; (not if single task being killed)
        BL      sendmessage             ; must copy message into RAM
        STRVC   R2,quitref              ; check myref on exit
        Pull    "PC"

msg_quit
        DCD     20                      ; size
        DCD     0                       ; task handle
        DCD     0                       ; my_ref
        DCD     0                       ; your_ref
        DCD     Message_Quit            ; action

;
; Reply to Message_DataSave - block contains full filename
; If 'estimated size' -ve, don't copy full filename
;

mes_datasaveack

; when this message is recieved then we must close the menu down

        Push    "R1"                            ; preserve that bogus message pointer
        ASSERT  button_right_drag < &100
        LDRB    R14,savedragbutton              ; unless dragged using ADJUST,
        TST     R14,#button_right_drag          ; close the menu tree
        MOVEQ   R1,#-1
        SWIEQ   XWimp_CreateMenu
        Pull    "R1"                            ; restore the message block pointer!

; acknowledge message immediately, since we need to send other messages

        MOV     R0,#User_Message_Acknowledge    ; acknowledge this immediately
        LDR     R2,[R1,#ms_taskhandle]
        STR     R2,savedesk_taskhandle
        LDR     R4,[R1,#ms_myref]               ; this field crapped on by Wimp
        SWI     XWimp_SendMessage

; claim block to store message in - we'll reply with a Message_DataLoad

        MOVVC   R0,#ModHandReason_Claim
        LDRVC   R3,[R1,#ms_size]
        SWIVC   XOS_Module
        Pull    "PC",VS

;        ADRL    R14,savedesk_loadmess
;        STR     R2,[R14]
        STR     R2,savedesk_loadmess

        Push    "R1,R2"
01      LDR     R14,[R1],#4             ; save message away for later
        STR     R14,[R2],#4
        SUBS    R3,R3,#4                ; must be a whole number of words
        BNE     %BT01
        Pull    "R1,R2"

        STR     R4,[R2,#ms_yourref]     ; for later
        MOV     R14,#Message_DataLoad   ; for later
        STR     R14,[R2,#ms_action]

; replace our filename unless this is a scrap file

        LDR     R14,[R1,#msDataTransfer_filesize]
        CMP     R14,#0
        BLT     %FT02

        ADD     R2,R1,#msDataTransfer_filename
        LDR     R3,mb_savedbox
01      LDRB    R14,[R2],#1
        STRB    R14,[R3],#1
        CMP     R14,#0                  ; defined to be zero-terminated
        BNE     %BT01

; now save to the file

02      BL      explicitsave            ; set up [autosave] and [shutdownflag]
        ADDVC   R1,R1,#msDataTransfer_filename
        BLVC    savestate_bydragging

        Pull    "PC"

;...............................................................................

; check for task initialising / closing down

trytaskinit
        LDR     R14,=Message_TaskStarted        ; task wants to be renumbered
        TEQ     R0,R14
        BEQ     task_renumber

        LDR     R14,=Message_SlotSize
        TEQ     R0,R14
        BEQ     task_newslot
        LDR     R14,=Message_TaskNameRq      ; someone wants to know the name
        TEQ     R0,R14
        BEQ     task_namerq
      [ Swapping
        LDR     R14,=Message_Swap
        TEQ     R0,R14
        BEQ     mes_swap
      ]
        LDR     R14,=Message_TaskCloseDown
        TEQ     R0,R14
        BEQ     task_closedown
        LDR     R14,=Message_TaskInitialise
        TEQ     R0,R14
        Pull    "PC",NE                         ; what?

; this code can also be reached from task_newslot, if the task had no memory

task_initialise
        LDR     R0,[R1,#ms_taskhandle]  ; R0 = task handle
        BL      findtask                ; delete if it already exists
        BLGE    deletetask
;
        LDR     R6,[R1,#ms_taskhandle]  ; this is the task handle
        LDR     R5,[R1,#ms_data+4]      ; memory usage
        TEQ     R5,#0
        MOVNE   R7,#ic_slotname         ; decide where to put task
        MOVEQ   R7,#ic_rmafree
        ADD     R3,R1,#ms_data+8        ; R3 --> task name
        LDR     R4,wlink
        ASSERT  y1=R9
        LDR     y1,wdef_header+w_wey1   ; y1 = y-coord of slot
01
        MOV     R2,R4                   ; R2 --> previous block
        LDRB    R14,[R2,#icb_height]
        SUB     y1,y1,R14               ; y1 = top of next slot
        LDR     R4,[R2,#icb_link]
        LDRB    R14,[R4,#icb_icon1]     ; is this the slot field?
        TEQ     R14,R7
        BNE     %BT01
;
        MOV     R1,#ic_taskname         ; no memory display for utils
        TEQ     R7,#ic_slotname
        LDREQ   R14,=(ic_memoryK:SHL:8):OR:(ic_slotBar:SHL:16)
        ORREQ   R1,R1,R14
        BL      allocateblock           ; R4 --> next block
        STR     R4,[R2,#icb_link]       ; link into the chain
        STR     R5,[R2,#icb_memsize]    ; R5 = memory usage (see above)
        STR     R6,[R2,#icb_taskhandle]
;
        MOV     userblk,R2              ; userblk --> row block
        BL      calc_extent
        BL      insertrow               ; y1 = y-coord
        BL      calc_slotsize           ; some memory may have disappeared
        BL      calc_memorymap
;
        MOV     R5,#-1                  ; new slot size (-1 => can you do it?)
        BL      message_setslot
        Pull    "PC"

; re-order task for desktop saving purposes (ie. Filer)

task_renumber
        LDR     R0,[R1,#ms_taskhandle]
        BL      findtask
        LDRGE   R14,global_taskage      ; if found, update task's age
        ADDGE   R14,R14,#1
        STRGE   R14,global_taskage
        STRGE   R14,[userblk,#icb_taskage]
        Debug   xx,"Task's new age =",R14
        Pull    "PC"

; find out whether the task understands slot dragging

message_setslot
        Push    "LR"
;
        MOV     R0,#28                  ; size
        MOV     R3,#0                   ; your_ref
        LDR     R4,=Message_SetSlot     ; action
        LDR     R6,[userblk,#icb_taskhandle]
        Push    "R0-R6"                 ; R5 = new slot size
        MOV     R0,#User_Message_Recorded   ; needs acknowledgement
        MOV     R1,sp
        MOV     R2,R6
        SWI     XWimp_SendMessage
        ADD     sp,sp,#28
;
        Pull    "PC"
        LTORG

; request to return name of a given task

task_namerq
        LDR     R0,[R1,#msTaskName_taskhandle]
        BL      findtask
        Pull    "PC",LT                 ; not found (don't reply)

        LDR     R14,=Message_TaskNameIs
        STR     R14,[R1,#ms_action]
        LDR     R14,[userblk,#icb_memsize]
        STR     R14,[R1,#msTaskName_slotsize]
        ADD     R0,userblk,#icb_taskname
        ADD     R2,R1,#msTaskName_taskname
        BL      copyr0r2
        ADD     r2,r2,#4
        BIC     r2,r2,#3
        SUB     r2,r2,r1
        STR     r2,[r1,#ms_size]
        LDR     R14,[r1,#ms_myref]
        STR     R14,[r1,#ms_yourref]    ; acknowledge message
        MOV     R0,#User_Message
        LDR     R2,[R1,#ms_taskhandle]
        SWI     XWimp_SendMessage
        Pull    "PC"

; (see message_setslot above): task didn't respond - make slot undraggable

task_cantslot
        LDR     R0,[R1,#msSetSlot_taskhandle]
        BL      findtask                ; userblk --> icon block, R2 --> link
        Pull    "PC",LT                 ; y1 = top y-coord
;
        MOV     R14,#ic_memoryBar       ; show that this can't be dragged
        STRB    R14,[userblk,#icb_icon3]
;
        LDR     R1,[userblk,#icb_memsize]
        MOV     R14,#0
        STR     R14,[userblk,#icb_memsize]
        BL      set_memory              ; redraws the whole bar
;
        LDR     R14,dragBar             ; stop dragging now, to avoid flicker
        TEQ     R14,userblk
        MOVEQ   R14,#-1                 ; task window open, no drag bar
        STREQ   R14,dragBar
;
        Pull    "PC"

     [  Swapping

; Task swapped in or out

mes_swap
        LDR     R0,[R1,#ms_data]        ; R0 = task handle
        BL      findtask                ; userblk --> icon block, R2 --> link
        Pull    "PC",LT                 ; LT ==> not found

        LDR     R14,[R1,#ms_data+4]
        CMP     R14,#0
        MOVNE   R14,#ic_swapBar
        MOVEQ   R14,#ic_memoryBar
        STRB    R14,[userblk,#icb_icon3]

        LDR     R1,[userblk,#icb_memsize]      ; new current slot size
        MOV     R14,#0
        STR     R14,[userblk,#icb_memsize]
        BL      int_set_memory              ; set size for this task
        BL      calc_slotsize

        Pull    "PC"
     ]

; task slot size altered

task_newslot
        LDR     R0,[R1,#ms_taskhandle]  ; R0 = task handle
        BL      findtask                ; userblk --> icon block, R2 --> link
        Pull    "PC",LT                 ; LT ==> not found
;
        LDRB    R14,[userblk,#icb_icon2]
        TEQ     R14,#ic_memoryK         ; is this an application task?
        BNE     bodge_newtask           ; treat as if the task was restarting

        LDR     R1,[R1,#ms_data+0]      ; new current slot size
        BL      set_memory              ; set size for this task
        BL      calc_slotsize
        BL      calc_memorymap          ; used/free application slots will move
        Pull    "PC"

; task didn't have any memory previously - move into application list

bodge_newtask
        LDR     R14,[R1,#ms_data+0]     ; get new current slot size
        STR     R14,[R1,#ms_data+4]     ; set up new memory use for 'new' task
                                        ; NB: CAOPointer field is garbage
        ADD     R0,userblk,#icb_taskname
        ADD     R2,R1,#ms_data+8        ; pretend the task is restarting
        BL      copyr0r2
        B       task_initialise

; task has closed down - remove it from the list

task_closedown
        LDR     R0,[R1,#ms_taskhandle]  ; R0 = task handle
        BL      findtask                ; userblk --> icon block, R2 --> link
        Pull    "PC",LT                 ; LT ==> not found
;
        BL      deletetask
;
        BL      calc_extent
        BL      calc_slotsize           ; some memory may have returned
        BL      calc_memorymap
        Pull    "PC"

;..............................................................................

; In    userblk -> task block
; Out   task block deleted, window updated

deletetask
        Push    "R1,R2,y0,y1,LR"

        LDR     R14,dragBar
        TEQ     R14,userblk
        MOVEQ   R14,#-1
        STREQ   R14,dragBar

        LDRB    y1,[userblk,#icb_height]
        LDR     R14,[userblk,#icb_link]      ; remove from chain
        STR     R14,[R2,#icb_link]
        MOV     R0,#ModHandReason_Free
        MOV     R2,userblk
        SWI     XOS_Module              ; deallocate from heap
        BL      deleterow               ; y0 = top of row, y1 = height

        Pull    "R1,R2,y0,y1,PC"

;..............................................................................

; Entry:  R0 = task handle to find
;         [wlink] --> list of blocks
; Exit:   LT ==> not found, else:
;         userblk --> block
;         R2 --> previous block
;         x0,y0 = top-left of relevant block

findtask
        Push    "LR"
;
        Push   "r0"
        MOV    R0,R0, ASL #16
        MOV    R0,R0, LSR #16

        ADRL    R2,wlink-icb_link
        LDR     x0,wdef_header+w_wex0
        LDR     y0,wdef_header+w_wey1
01
        LDR     userblk,[R2,#icb_link]
        CMP     userblk,#0
        Pull    "r0,PC",LT

        LDRB    R14,[userblk,#icb_icon1]
        TEQ     R14,#ic_taskname
        BNE     %FT02
        LDR    R14,[userblk,#icb_taskhandle]
        MOV    R14,R14, ASL #16
        MOV    R14,R14, LSR #16
        TEQ    R14,R0                  ; same task?
02
        LDRNEB  R14,[userblk,#icb_height]
        SUBNE   y0,y0,R14
        MOVNE   R2,userblk
        BNE     %BT01
;
        Pull    "r0,PC"

;..............................................................................

; Entry:  userblk -> row block
;              y1  = y-coord of top of row

insertrow
        Push    "R1-R6,y0,LR"
;
        MOV     R1,#-bignum             ; R1,R2 = bottom-left of source
        MOV     R2,#-bignum
        MOV     R3,#bignum              ; R3,R4 = top-right of source
        MOV     R4,y1
        MOV     R5,R1
        LDRB    y0,[userblk,#icb_height]
        SUB     R6,R2,y0                ; R5,R6 = bottom-left of destination
        LDR     R0,h_switcher
        SWI     XWimp_BlockCopy
;
        SUBVC   R2,R4,y0                ; invalidate R1,R4-y0, R3,R4
        LDRVC   R0,h_switcher
        SWIVC   XWimp_ForceRedraw
        Pull    "R1-R6,y0,PC",VS

        LDR     R14,dragBar             ; if dragging or just finished,
        CMP     R14,#0                  ; keep the bar in the same place
        CMPNE   R14,#-1
        BLNE    scrolltaskwindow        ; y0 = amount to scroll by

        Pull    "R1-R6,y0,PC"

;..............................................................................

; Entry:  y0 = top of deleted row
;         y1 = height of deleted row

deleterow
        Push    "R1-R6,y0,LR"

        MOV     R1,#-bignum             ; R1,R2 = bottom-left of source
        MOV     R2,#-bignum
        MOV     R3,#bignum              ; R3,R4 = top-right of source
        SUB     R4,y0,y1
        MOV     R5,R1
        ADD     R6,R2,y1                ; R5,R6 = bottom-left of destination
        LDR     R0,h_switcher
        SWI     XWimp_BlockCopy
        Pull    "R1-R6,y0,PC",VS

        LDR     R14,dragBar             ; if dragging or just finished,
        CMP     R14,#0                  ; keep the bar in the same place
        CMPNE   R14,#-1
        RSBNE   y0,y1,#0
        BLNE    scrolltaskwindow        ; y0 = amount to scroll by

        Pull    "R1-R6,y0,PC"

;..............................................................................

; Entry:  [wlink] --> list of icon row blocks
; Exit:   extent of switcher window reprogrammed
;         window re-opened in same position

calc_extent
        Push    "R1-R2,x0,y0,x1,y1,LR"
;
        MOV     R1,#0
        LDR     R2,wlink
01
        LDRB    R14,[R2,#icb_height]
        ADD     R1,R1,R14
        LDR     R2,[R2,#icb_link]
        CMP     R2,#0
        MOVGT   R0,R2
        BGT     %BT01
; R0 holds last icon ptr, if this is 'Dynamic Areas' then don't display it
        LDRB    R14,[R0,#icb_icon1]
        CMP     R14,#ic_dynamareas
        LDREQB  R14,[R0,#icb_height]
        SUBEQ   R1,R1,R14
;
        ADRL    R14,wdef_header+w_wex0
        LDMIA   R14,{x0,y0,x1,y1}
        SUB     y0,y1,R1                ; calculate new extent
        Push    "x0,y0,x1,y1"
        MOV     R1,sp
        LDR     R0,h_switcher
        SWI     XWimp_SetExtent
        LDRVC   R0,h_switcher
        STR     R0,[sp,#-u_windowstate+4*4]!    ; (allow for 4 words on stack)
        MOVVC   R1,sp
        SWIVC   XWimp_GetWindowState
        BVS     %FT01
        LDR     R14,[R1,#u_wflags]
        TST     R14,#ws_open
        SWINE   XWimp_OpenWindow        ; open at same position
01
        ADD     sp,sp,#u_windowstate
;
        Pull    "R1-R2,x0,y0,x1,y1,PC"

;;----------------------------------------------------------------------------
;; Interactive help
;;----------------------------------------------------------------------------

; In    r1 -> message block containing help request
;       LR stacked
; Out   Message_HelpReply sent

str_h   DCB     "H", 0                  ; token for %2 (task display window)
str_s   DCB     "S", 0                  ; token for %2 (save dbox)
str_i   DCB     "I", 0                  ; token for %2 (info dbox)
str_p   DCB     "p", 0                  ; token for %2 (power down box)

str_slotbar DCB "Red", 0
str_noslot  DCB "Grn", 0
        ALIGN

returnhelp
        ASSERT  userblk <> r10
        ASSERT  y1 < r10
        ASSERT  cy1 < r10
        MOV     r10, sp                 ; restored later

        ADR     r6, str_h
        LDR     r2, [r1, #ms_data + b_window]
        LDR     r3, [r1, #ms_data + b_icon]

; try Task Display window

        LDR     r0, h_switcher
        CMP     r2, r0
        BNE     %FT01

        Push    "cx0-y1"
        LDR     cx0, [r1, #ms_data + b_x]
        LDR     cy0, [r1, #ms_data + b_y]
        BL      relmousecoords
        BLVC    findclick               ; userblk -> parameter
        Pull    "cx0-y1"
        BVS     %FT99

        MOV     r0, #&FF                ; not in menu
        B       gothelpindex

; try iconbar icon

01      CMP     r2, #iconbar_whandle    ; try iconbar icon
        MOVEQ   userblk, #-2
        MOVEQ   r0, #&FF
        BEQ     gothelpindex

; try save dbox

        LDR     r14, h_savedbox
        CMP     r2, r14
        BNE     %FT02

        ASSERT  gi_size = 40            ; window, icon, iconblk
        Push    "r1-r11"                ; r1, plus 10 registers
        ADD     r1, sp, #4
        SWI     XWimp_GetIconState
        BVS     %FT99
        LDR     r14, [r1, #gi_iconblock + i_flags]
        LDR     r1, [sp], #4 + gi_size
        TST     r14, #is_inverted
        MOVEQ   userblk, #-3            ; -3 => not selected
        MOVNE   userblk, #-4            ; -4 => selected
        ADR     r6, str_s               ; "This is the save dbox"
        MOV     r0, r3                  ; r0 = icon handle
        B       gothelpindex

; try OS information dialogue box

02      LDR     R14, info_handle
        CMP     R2,R14
        ADREQ   R6,str_i                ; "This is the information box"
        MOVEQ   userblk, #-1
        MOVEQ   R0,#&FF
        BEQ     gothelpindex

; try power down window

        LDR     R14, h_powerdown
        CMP     R2,R14
        ADREQ   R6,str_p                ; Token for forced shutdown
        MOVEQ   userblk, #-1
        MOVEQ   R0,#&FF
        BEQ     gothelpindex

; try menu item

        CMP     r3, #0                  ; no help if not on an item
        BLT     %FT99

        Push    "r1, r2-r4"
        ADD     r1, sp, #4              ; r1 -> buffer for result
        MOV     r0, #1
        SWI     XWimp_GetMenuState
        Pull    "r1, r2-r4"             ; r2, r3 = menu selections
        BVS     %FT99

        ADDS    r0, r2, #1              ; NB: item -1 is translated into 0
        ADDGTS  r14, r3, #1
        ADDGT   r0, r0, r14, LSL #4     ; r0 = first entry + 16*second entry

        LDR     userblk, menu_userblk   ; userblk for this menu

; userblk -> object this thing relates to (possibly via the menu)
; r0 = menu index pair (&FF => not in a menu)
; r6 -> token which will be used for %2 (window title)

gothelpindex
        SUB     sp, sp, #&80            ; make room for buffer
        Push    "r0-r5"
        MOV     r1, r6                  ; r1 -> token
        ADD     r2, sp, #4*6
        MOV     r3, #&80
        BL      lookup_nopars           ; sets r4-r7=0 for the call
        BVS     %FT99
        Pull    "r0-r5"
        MOV     r6, sp                  ; %2 = "This is the Task Manager window.|M"

        ADD     r1, r1, #ms_data
        MOV     r14, #"H"
        STRB    r14, [r1], #1

; set r7 -> parameter 3 (whether or not the slot can be dragged)

        Push    "r0-r3"
        ADRL    r1, str_noslot
        CMP     userblk, #0
        BLE     %FT01
        LDRB    r14, [userblk, #icb_icon3]
        TEQ     r14, #ic_slotBar
        TEQNE   r14, #ic_freeBar
        ADREQL  r1, str_slotbar
01      MOV     r2, #0                  ; read in place
        BL      lookup_nopars
        BVS     %FT99
        MOV     r7, r2                  ; r7 -> parameter 3
        Pull    "r0-r3"

; set r5 -> parameter 1 (amount of memory in this slot)

        STR     r1, [sp, #-16]!         ; make room for memory string

        MOV     r5, #0
        CMP     userblk, #0
        MOVLE   r4, #0
        BLE     %FT01

        LDRB    r14, [userblk, #icb_icon2]
        TEQ     r14, #ic_memoryK
        ADDEQ   r5, sp, #4
        SUBEQ   r1, sp, #i_data-4       ; r1+i_data = buffer on stack
        BLEQ    setmemstring

        LDRB    r14, [userblk, #icb_icon1]
        TEQ     r14, #ic_taskname
        TEQNE   r14, #ic_cdaname
        ADDEQ   r4, userblk, #icb_taskname
        BEQ     %FT11
        ADRL    r4, wdef_icons + i_flags - ic_0*i_size
        LDR     r14, [r4, r14, LSL #i_shift]!
        TST     r14, #if_indirected
        ADDEQ   r4, r4, #i_data-i_flags
        LDRNE   r4, [r4, #i_data-i_flags]
11
        LDRB    userblk, [userblk, #icb_icon1]
01
        Pull    "r1"

; now work out the second letter of the help token

        ADR     r14, toklettertab
        CMP     userblk, #tokletterend-toklettertab
        LDRLTB  r14, [r14, userblk]
        MOVGE   r14, #"."
        TEQ     r5, #0                  ; if no memory bar,
        ORREQ   r14, r14, #&20          ; make letter lower-case
        STRB    r14, [r1], #1

        MOV     r2, #3
        SWI     XOS_ConvertHex2

        SUBVC   r1, r0, #2              ; r1 -> token
        MOVVC   r2, r1                  ; r2 -> output buffer
        MOVVC   r3, #256-ms_data        ; r3 = buffer size
        BLVC    allocatemessagedata
        SWIVC   XMessageTrans_Lookup

        ADD     sp, sp, #12             ; restore stack

; send the Message_HelpReply

        SUBVC   r1, r2, #ms_data
        ADDVC   r3, r3, #4 + ms_data    ; include terminator
        BICVC   r3, r3, #3
        STRVC   r3, [r1, #ms_size]
        LDRVC   r14, [r1, #ms_myref]
        STRVC   r14, [r1, #ms_yourref]
        LDRVC   r14, =Message_HelpReply
        STRVC   r14, [r1, #ms_action]
        MOVVC   r0, #User_Message
        LDRVC   r2, [r1, #ms_taskhandle]
        SWIVC   XWimp_SendMessage
99
        MOV     sp, r10

        Pull    "PC"            ; LR stacked from messagereceived

        DCB     "s"             ; save dbox: r0 = icon (inverted)
        DCB     "q"             ; save dbox: r0 = icon (not inverted)
        DCB     "i"             ; iconbar
        DCB     "w"             ; in window, not on a task
toklettertab
        DCB     "."
        DCB     "x"             ; ic_applichdr
        DCB     "y"             ; ic_sysmemory
        DCB     "z"             ; ic_modules
        DCB     "d"             ; ic_dynamareas
        DCB     "T"             ; ic_taskname
        DCB     "."             ;                       ic_memoryK
        DCB     "."             ;                       ic_memoryBar
        DCB     "n"             ; ic_slotname
        DCB     "."             ;                       ic_slotBar
        DCB     "f"             ; ic_freename
        DCB     "."             ;                       ic_freeBar
        DCB     "S"             ; screen
        DCB     "C"             ; cursor/system/sound
        DCB     "H"             ; sys heap
        DCB     "M"             ; rma heap (module area)
        DCB     "F"             ; font cache
        DCB     "P"             ; sys sprites
        DCB     "R"             ; ram disc
        DCB     "B"             ; applications (free)
        DCB     "U"             ; applications (used)
        DCB     "Z"             ; sys workspace
        DCB     "E"             ; ic_totalname
        DCB     "Q"             ; ic_rmafree
        DCB     "L"             ; ic_largestname (largest contiguous block in RMA)
        DCB     "D"             ; ic_cdaname
tokletterend

; .............................................................................

; In    r1 -> token
;       r2 -> buffer
;       r3 = buffer size
; Out   r0 corrupt if VC, else r0 -> error block if VS
;       r3 = size of string excluding terminator

lookup_nopars ENTRY "r4-r7"

        BL      allocatemessagedata     ; r0 -> file desc
        MOVVC   r4, #0
        MOVVC   r5, #0
        MOVVC   r6, #0
        MOVVC   r7, #0
        SWIVC   XMessageTrans_Lookup

        EXIT

;..............................................................................

; In    R0 -> error block
; Out   R0 -> resolved error block and  V set!

lookup_error
        Push    "R1-R8,LR"
        BL      lookup_erroralt
        Pull    "R1-R8,PC"

; hand crafted routine that does not require any stack to perform an error
; look up - use with caution!!!

; in    R0 -> error block
; out   R0 -> resolve error block

lookup_erroralt ROUT

        MOV     R8,R14
        MOV     R4,R0                   ; preserve original error pointer

        MOV     R0,#ModHandReason_Claim
        MOV     R3,#16
        SWI     XOS_Module              ; attempt to claim workspace block
        MOVVS   PC,R8                   ; exit if failed to get workspace

        MOV     R0,R2
        ADR     R1,str_messagefile
        MOV     R2,#0                   ; no user buffer
        SWI     XMessageTrans_OpenFile

        MOVVC   R1,R0
        MOV     R0,R4                   ; R1 -> blk, R0 -> error
        MOVVC   R2,#0                   ; no user buffer
        ADRVCL  R4,Title
        MOVVC   R5,#0
        MOVVC   R6,#0
        MOVVC   R7,#0                   ; no parameter substitution
        SWIVC   XMessageTrans_ErrorLookup

        MOV     R3,R0                   ; preserve the error block pointer
        MOV     R0,R1
        SWI     XMessageTrans_CloseFile ; attempt to close the file (ignore any errors)

        MOV     R0,#ModHandReason_Free
        MOV     R2,R1
        SWI     XOS_Module              ; release our workspace (ignore any errors)

        MOV     R0,R3
        ORRS    PC,R8,#V_bit            ; return with R0 -> error and oVerflow set

;..............................................................................

; In    [messagedata] -> message file desc (0 => not yet opened)
; Out   r0 = [messagedata] -> message file desc (opened if not already open)

allocatemessagedata ENTRY "r1-r3"

        LDR     r0, messagedata
        CMP     r0, #0
        EXIT    NE

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #16
        SWI     XOS_Module

        STRVC   r2, messagedata

        MOVVC   r0, r2
        ADRVC   r1, str_messagefile
        MOVVC   r2, #0                          ; no user buffer
        SWIVC   XMessageTrans_OpenFile

        BLVS    deallocatemessagedata           ; preserves error state

        LDRVC   r0, messagedata
        EXIT

str_messagefile DCB     "Switcher:Messages", 0
                ALIGN

;..............................................................................

; In    [messagedata] -> message file desc, or = 0 if not loaded
; Out   [messagedata] = 0, OS_Module (Free) called if required, error preserved

deallocatemessagedata ENTRY "r0,r2"

        LDR     r2, messagedata
        MOVS    r0, r2
        EXITS   EQ

        MOV     r14, #0
        STR     r14, messagedata

        SWI     XMessageTrans_CloseFile         ; tell the MessageTrans module

        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module

        EXITS

;;----------------------------------------------------------------------------
;; Mouse click decoding
;;----------------------------------------------------------------------------

;       LDMIA   R1,{mousex,mousey,buttons,window,icon}

mouse_click
        Push    "LR"
;
        LDR     R14,[R1,#b_buttons]

        Debug   xx,"Mouse click buttons:",R14

        TEQ     R14,#button_middle
        BEQ     click_menu
        TEQ     R14,#button_right
        BEQ     click_adjust
        TEQ     R14,#button_left
        BEQ     click_select
        TEQ     R14,#button_left_drag
        ASSERT  drag_adjust = drag_select
        TEQNE   R14,#button_right_drag
        BEQ     drag_select

        Pull    "PC"

click_select
click_adjust
        LDR     R0,[R1,#b_window]

        LDR     R14,h_powerdown         ; was it the power down dialogue
        TEQ     R0,R14
        BEQ     power_click

        LDR     R14,h_shutdown          ; click in restart dialogue?
        TEQ     R0,R14
        BEQ     restart

        LDR     R14,h_savedbox
        TEQ     R0,R14
        BEQ     dbox_click

        LDR     R14,h_switcher          ; click in task window?
        TEQ     R0,R14                  ; no => assume iconbar icon
        BEQ     switcher_click

        CMP     R0,#iconbar_whandle
        BEQ     openswitcher
        Pull    "PC"                    ; ignore it if none of these

power_click
        MOV     R1,#-1                  ; remove the dialogue
        SWI     XWimp_CreateMenu
;
        Pull    "PC",,^

switcher_click
        LDMIA   R1,{cx0,cy0}            ; cx0,cy0 = mouse click coords
        BL      relmousecoords          ; cx0,cy0 rel; cx1,cy1 = origin
        BLVC    findclick               ; userblk --> block; x0,y0 set up
        Pull    "PC",VS
        CMP     userblk,#0
        Pull    "PC",LE
        LDRB    R0,[userblk,#icb_icon3]         ; get slider icon
        TEQ     R0,#ic_slotBar
        TEQNE   R0,#ic_freeBar
        Pull    "PC",NE
;
        Push    "R2"
        MOV     R0,#-1
        MOV     R1,#-1
        SWI     XWimp_SlotSize          ; R2 = max total free memory
        MOV     R1,R2                   ; R1 = max total free memory
        Pull    "R2"

        LDRB    R0,[userblk,#icb_icon1] ; unless it's a wimp memory slot,
        TEQ     R0,#ic_slotname
        TEQNE   R0,#ic_freename
        LDRNE   R14,[userblk,#icb_memsize]
        ADDNE   R1,R1,R14               ; we can also add on the current size!

 [ readareas
        Push    "r1,r2"
;        MOV     r14, #16*1024*1024      ; max max = 16Mb, can't find out max app space size yet
        MOV     r1, #-1                 ; will drop through to read app space size

        TEQ     r0, #ic_freename
        MOVEQ   r1, #&86                ; free bar restricted by size of free pool

        TEQ     r0, #ic_sys4            ; RMA
        MOVEQ   r1, #&81
        TEQ     r0, #ic_sys6            ; system sprites
        MOVEQ   r1, #&83
        TEQ     r0, #ic_sys7            ; RAM disc
        MOVEQ   r1, #&85
        TEQ     r0, #ic_sys1            ; screen
        MOVEQ   r1, #&82
        TEQ     r0, #ic_sys3            ; sys heap
        MOVEQ   r1, #&80
        TEQ     r0, #ic_sys5            ; font cache
        MOVEQ   r1, #&84
        TEQ     r0, #ic_cdaname
        LDREQ   r1, [userblk,#icb_taskage] ; DA number
        MOVS    r0, r1
        BEQ     notdyn
        SWI     XOS_ReadDynamicArea     ; out: r0 = base address, r1 = cur.size, r2 = max size
        MOVVC   r14, r2
notdyn
        Pull    "r1,r2"
        CMP     r1, r14
        MOVHI   r1, r14
 |
        MOV     R14,#16*1024*1024       ; max max = 16Mb
        TEQ     R0,#ic_sys4             ; max rma = 4Mb
        TEQNE   R0,#ic_sys6             ; max system sprites = 4Mb
        TEQNE   R0,#ic_sys7             ; max RAM disc = 4Mb
        MOVEQ   R14,#4*1024*1024
        TEQ     R0,#ic_sys1
        MOVEQ   R14,#480*1024           ; max screen size = 480k
        TEQ     R0,#ic_sys3
        MOVEQ   R14,#2048*1024          ; max system heap = 2048k
        TEQ     R0,#ic_sys5
        MOVEQ   R14,#1024*1024          ; max font cache = 1024k
        CMP     R1,R14
        MOVGT   R1,R14                  ; can't get bigger than this limit
 ]
        STR     R1,max_mem_drag
        BL      calcbarcoords           ; x0,y0,x1,y1 = coords of bar for R1
        ADD     x1,x1,#1                ; round it up
        CMP     cx0,x0
        CMPGE   cy0,y0
        CMPGE   x1,cx0
        CMPGE   y1,cy0
        Pull    "PC",LT
;
        LDR     R0,h_switcher
        MOV     R1,#7                   ; invisible dragbox
        ADD     x0,x0,cx1
        ADD     y0,y0,cy1
        ADD     x1,x1,cx1
        ADD     y1,y1,cy1
        Push    "R0,R1,cx0,cy0,cx1,cy1,x0,y0,x1,y1"

        MOV     R1,#0
        STRB    R1,errorendeddrag

        MOV     R1,sp
        SWI     XWimp_DragBox
        ADD     sp,sp,#10*4
        STRVC   userblk,dragBar         ; dragging a slider bar
        Pull    "PC"

; Drag event on save dbox - start dragging the file icon

drag_select
drag_adjust
        STRB    R14,savedragbutton      ; remember button used for drag

        LDR     R0,[R1,#b_window]
        LDR     R14,h_savedbox
        TEQ     R0,R14
        LDREQ   R14,[R1,#b_icon]
        TEQEQ   R14,#saveicon_file      ; file icon?
        Pull    "PC",NE

        ASSERT  b_x = 0
        LDMIA   R1,{cx0,cy0}
        LDR     R0,[R1,#b_window]!
        BL      relmousecoords          ; cx0,cy0 = rel coords,
                                        ; cx1,cy1 = window origin
        ASSERT  b_icon = b_window+4
        SWI     XWimp_GetIconState

; cope with Drag-a-Sprite being used for icon dragging

        Push    "R1"
        MOV     R0,#ReadCMOS
        LDR     R1,=FileSwitchCMOS
        SWI     XOS_Byte
        MOVVS   R2,#0                   ; if cannot read the byte then null it
        TST     R2,#DragASpriteCMOSBit
        Pull    "R1"
        BNE     %FT10

        ADD     R1,R1,#8+i_bbx0
        LDMIA   R1,{x0,y0,x1,y1}

        SUB     x0,x0,cx0               ; x0,y0,x1,y1 = parent bbox
        SUB     y0,y0,cy0
        SUB     x1,x1,cx0
        SUB     y1,y1,cy0

        LDR     cx0,xwindlimit
        LDR     R14,log2px
        ADD     x1,x1,cx0,LSL R14       ; x1 = parent box rhs

        LDR     cy0,ywindlimit
        LDR     R14,log2py
        ADD     y1,y1,cy0,LSL R14       ; x1 = parent box top

        Push    "x0,y0,x1,y1"

        LDMIA   R1,{x0,y0,x1,y1}        ; get icon bounds back

        ADD     x0,x0,cx1               ; x0,y0,x1,y1 = initial box coords
        ADD     y0,y0,cy1
        ADD     x1,x1,cx1
        ADD     y1,y1,cy1

        LDR     R0,h_savedbox
        MOV     R1,#5                   ; user drag of fixed size box
        Push    "R0,R1,x0,y0,x1,y1"     ; other 4 coords already stacked
        MOV     R1,sp
        SWIVC   XWimp_DragBox           ; V could have been set further up!
        ADD     sp,sp,#10*4

        Pull    "PC"

; attempt to use drag a sprite 'cos CMOS says to!

10      ADD     R1,R1,#8
        LDMIA   R1,{x0,y0,x1,y1}        ; get the bounding box of the icon
        ADD     R2,R1,#20               ; -> sprite name to be used

        ADD     x0,x0,cx1
        ADD     y0,y0,cy1
        ADD     x1,x1,cx1
        ADD     y1,y1,cy1

        Push    "x0,y0,x1,y1"           ; push bounding box of icon to move

        MOV     R3,SP
        MOV     R1,#1
        LDR     R0,=DS_HJustify_Centre :OR: DS_VJustify_Centre :OR: DS_BoundTo_Screen :OR: DS_Bound_Pointer :OR: DS_DropShadow_Present
        SWI     XDragASprite_Start

        ADD     SP,SP,#4*4
        Pull    "PC"                    ; having started drag then exit

; click in dbox - try "OK" box

dbox_click
        LDR     R14,[R1,#b_icon]
        TEQ     R14,#saveicon_autoboot
        BEQ     click_autoboot

        TEQ     R14,#saveicon_ok        ; "OK" box
        Pull    "PC",NE

        LDR     R14,[R1,#b_buttons]     ; close menu tree unless right button used
        TST     R14,#button_right
        MOVEQ   R1,#-1
        SWIEQ   XWimp_CreateMenu
        BVC     gosavestate

        Pull    "PC"

; click on auto-boot icon - set up the autoboot CMOS bit

click_autoboot
        LDR     R0,h_savedbox
        MOV     R1,#saveicon_autoboot
        Push    "R0,R1,R2-R9"           ; window, icon, 8 words
        MOV     R1,sp
        SWI     XWimp_GetIconState
        LDRVC   R3,[R1,#8+i_flags]      ; R3 = icon flag word
        ADD     sp,sp,#10*4

        MOVVC   R0,#ReadCMOS
        MOVVC   R1,#DBTBCMOS
        SWIVC   XOS_Byte

        TST     R3,#is_inverted
        ORRNE   R2,R2,#&10              ; enable auto-boot
        BICEQ   R2,R2,#&10              ; disable auto-boot

        Debug   xx,"Write CMOS: R0,R1,R2,R3 =",R0,R1,R2,R3

        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte
        Pull    "PC"

;
; Entry:  R0 = window handle
;         cx0,cy0 = absolute mouse coords
; Exit:   cx0,cy0 = mouse coords rel. to window origin
;         cx1,cy1 = window origin in screen coords
;

relmousecoords
        Push    "R1,x0,y0,x1,y1,LR"
;
        STR     R0,[sp,#-u_windowstate]!
        MOV     R1,sp
        SWI     XWimp_GetWindowState
        LDMVCIA R1,{R0,cx1,cy1,x0,y0,x1,y1}
        SUB     cx1,cx1,x1
        SUB     cy1,y0,y1
        SUB     cx0,cx0,cx1
        SUB     cy0,cy0,cy1
        ADD     sp,sp,#u_windowstate
;
        Pull    "R1,x0,y0,x1,y1,PC"

;-------------------------------------------------------------------------------

; Null event - used to drag memory bars and also to check on rma size

null_event      ROUT

        Push    "LR"
;
        Debug   sh,"ShutDown state (null event handling) =",#lastshutdown
;
        LDR     R14,lastshutdown
        TEQ     R14,#state_normal       ; was the last shutdown due to a power failure?
        BEQ     %FT10                   ; no, so ignore the event
;
        MOV     R0,#state_normal
        STR     R0,lastshutdown         ; flag last shutdown as reported - avoid nasty infinate loop
;
        TEQ     R14,#state_exit         ; quit the desktop? if not then display dinkey box
        BNE     %FT05
;
        LDR     R6,shutdownflags
        TST     R6,#shutdownbit_SendShutdownMessage
        BEQ     goshutdown
;
        MOV     R0,#4*7                 ; size of message to send
        MOV     R1,#0
        MOV     R2,#0
        MOV     R3,#0                   ; your_ref =0 - original message
        LDR     R4,=Message_Shutdown
        MOV     R5,#0                   ; reserved flags
        Push    "R0-R6"
;
        LDR     R0,=User_Message
        MOV     R1,sp                   ; R1 -> block / R2 = broadcast
        SWI     Wimp_SendMessage
;
        ADD     sp,sp,#4*7
        B       goshutdown              ; start the shutdown sequence
05
        LDR     R0,h_powerdown          ; get handle of power down warning dialogue
        ADR     R1,pollblock
        BL      centre_window           ; centre the window
;
        LDR     R2,[R1,#u_wax0]
        LDR     R3,[R1,#u_way1]         ; centre openinig X,Y coordinates
        LDR     R1,h_powerdown
        SWI     XWimp_CreateMenu        ; create the window
        SWIVC   XOS_WriteI +7           ; and jingle jangle the jingely jangely thing
;
        LDR     R2,=state_normal
        BL      writestate              ; set state of reset back to normal
;
        Pull    "PC"
10
        LDR     R14,dragBar             ; finished the message passing phase
        CMP     R14,#-2                 ; at the end of a drag
        MOVEQ   R14,#-1
        STREQ   R14,dragBar

        LDRB    R14,recalc_extent
        CMP     R14,#0
        MOVNE   R14,#0
        STRNEB  R14,recalc_extent
        BLNE    calc_extent

; this stuff is now dealt with in the poll word stuff

        BL      calc_rmasize
        BL      calc_slotsize           ; next slot can change without Service_MemoryMoved

; if dragging a bar, look at the mouse position

        LDR     userblk,dragBar
        CMP     userblk,#0
        Pull    "PC",LE

        SUB     sp,sp,#b_size
        MOV     R1,sp
        SWI     XWimp_GetPointerInfo
        LDMIA   R1,{cx0,cy0}
        ADD     sp,sp,#b_size
        LDR     R0,h_switcher
        BL      relmousecoords          ; cx0,cy0 = coords rel. to window

        LDRB    R14,[userblk,#icb_icon3]
        ADRL    R0,wdef_icons-i_size+i_bbx0
        ADD     R14,R0,R14,LSL #i_shift
        LDMIA   R14,{x0,y0,x1,y1}
        SUB     x1,x1,x0                ; x1 = unit size
        SUBS    cx0,cx0,x0              ; cx0 = offset to mouse pointer
        MOVLT   cx0,#0                  ; can't go below 0!
        SWI     XOS_ReadMemMapInfo      ; R0 = page size, R1 = npages
        MUL     R0,cx0,R0
        [ SteppedMem
; Steped memory bar rather than linear, see algorithm in doc.
        Push    "R2-R4"
        LDRB    R2,medusa_kernel
        CMP     R2,#0
        BEQ     %FT05
        MOV     x1,x1,LSR #2            ; use 4x fewer OS units on Medusa
        LDRB    R2,stepped_mem
        CMP     R2,#0
        BEQ     %FT05
        MOV     R2,#512*1024            ; 512k
        MUL     R4,R2,x1                ; x1 small
        MOV     R2,R4
        MOV     R3,#0
        MOV     R14,#0
        MOV     R1,R0
03
        CMP     R1,R4
        ADDLT   R0,R14,R1, LSL R3       ; want result in R0
        BLT     %FT05
        ADD     R14,R14,R2
        SUB     R1,R1,R4
        ADD     R3,R3,#1
        MOV     R2,R2, LSL #1
        B       %BT03
05
        Pull    "R2-R4"
        ]
        DivRem  R1,R0,x1, R14           ; R1 = new memory size

        LDRB    R14,[userblk,#icb_icon1]
        TEQ     R14,#ic_taskname        ; dragging a task slot?
        BEQ     settaskslot

        TEQ     R14,#ic_cdaname         ; dragging a dynamic area
        BEQ     setcdamem

        SUBS    R14,R14,#ic_sys1
        BLT     setwimpslot

        ADRL    R0,dynamicareas
        LDRB    R0,[R0,R14]             ; R0 = dynamic area number
        LDR     R14,[userblk,#icb_memsize]

; NK 0.80 check max size of area
        [ false
        Push    "R0-R2,R14"
        ORR     R0,R0,#128              ; want max size, nb. if DDA's come through here
                                        ; then do cmp with 256.
        SWI     XOS_ReadDynamicArea
        Pull    "R0-R1"
        CMP     R1,R2
        MOVGT   R1,R2
        Pull    "R2,R14"
        |
        Push    "R0"
        LDR     R0,max_mem_drag
        CMP     R1,R0
        MOVGT   R1,R0
        Pull    "R0"
        ]
        SUB     R1,R1,R14               ; R1 = change in area size
        SWI     XOS_ChangeDynamicArea
        BVC     %FT01

        LDR     R14,[R0]                ; ignore "Unable to move memory"
        LDR     R1,=ErrorNumber_ChDynamNotAllMoved
        TEQ     R14,R1                  ; ignore "Memory in use" too
        LDRNE   R1,=ErrorNumber_AplWSpaceInUse
        TEQNE   R14,R1
        CLRV    EQ
01
        BLVC    calc_memorymap          ; will be done later anyway

        MOVVS   R14,#-1                 ; cancel drag if error
        STRVS   R14,dragBar             ; (-1 => task window open)

        Pull    "PC"
        LTORG

; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

; in    R2 = state to put into CMOS in bits 0-1
; out   -

writestate ROUT
        Push    "R0-R3,LR"
;
        MOV     R3,R2                   ; take state into temp register
;
        MOV     R0,#ReadCMOS
        LDR     R1,=FileSwitchCMOS
        SWI     XOS_Byte                ; get the state back
        BICVC   R2,R2,#SwitcherShutdownCMOSBits
        ORRVC   R2,R2,R3
        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte                ; and write it back into CMOS
;
        Pull    "R0-R3,PC",,^

;..............................................................................

setwimpslot     ROUT

        LDR     R14,max_mem_drag
        CMP     R1,R14
        MOVGT   R1,R14                          ; restrict drag by ammount available

        LDRB    R14,[userblk,#icb_icon3]
        TEQ     R14,#ic_freeBar         ; if free bar,
        BNE     %FT01
        Push    "R1"
        MOV     R0,#-1
        MOV     R1,#-1
        SWI     XWimp_SlotSize          ; R2 = total free memory
        Pull    "R1"
        SUB     R1,R2,R1                ; R1 = total - freebar
; under Medusa it's possible to drag the free, such that the next > app space

        Push    R1
        MOV     R0,#-1
        MOV     R1,#-1
        SWI     XOS_ReadDynamicArea
        Pull    R1
        CMP     R1,R2
        MOVGT   R1,R2                   ; limit next by app slot size

01
        MOV     R0,#-1
        CMP     R1,#0
        MOVLT   R1,#0
        SWI     XWimp_SlotSize          ; set proposed slot size
        BL      calc_slotsize
        MOVVS   R14,#-1                 ; cancel drag if error
        STRVS   R14,dragBar             ; (-1 => task window open)

        Pull    "PC"

setcdamem
        ; R1 is proposed new memory
        LDR     R0,max_mem_drag
        CMP     R1,R0
        MOVGT   R1,R0                           ; restrict drag by ammount available

        MOV     R3,R1
        LDR     R0,[userblk,#icb_taskage]       ; area number
        CMP     R0,#128
        ORRLT   R0,R0,#128                      ; want max size as well
        SWI     XOS_ReadDynamicArea
        MOV     R0,R3
        BVS     %FT02
        CMP     R0,R2
        MOVGT   R0,R2
        MOV     R3,R1
        SUBS    R1,R0,R1                           ; is proposed size the current size?
        MOV     R4,R1
        Pull    "PC",EQ
        ; R1 is change in size
        LDR     R0,[userblk,#icb_taskage]
        SWI     XOS_ChangeDynamicArea
;        BVS     %FT02                  ; hmm may cause an error, but suceed
        ; R1 is actual change (unsigned)
        CMP     R1,#0
        Pull    "PC",EQ
        CMP     R4,#0
        ADDGT   R1,R1,R3                        ; R3 is the current size, R4 might only be valid in sign
        SUBLT   R1,R3,R1

updatecdamem
        LDR     y0,wdef_header+w_wey1
        LDR     R0,wlink
01
        CMP     R0,userblk
        LDRNEB  R14,[R0,#icb_height]
        SUBNE   y0,y0,R14
        LDRNE   R0,[R0,#icb_link]
        BNE     %BT01
        LDR     x0,wdef_header+w_wex0
        BL      set_memory
02
        CLRV
        Pull    "PC"

settaskslot     ROUT
        MOV     R5,R1                   ; R1 = proposed new slot size
        BL      message_setslot         ; send to [userblk,#icb_taskhandle]
        MOVVS   R14,#-1                 ; cancel drag if error
        STRVS   R14,dragBar             ; (-1 => task window open)

        Pull    "PC"

;..............................................................................

; Setup a CallAfter to call the routine, which inturn issues a CallBack
; and finally the text will get changed.

setuptochange ENTRY ""

        LDR     R0,=100                 ; call ~1 second from now!
        ADR     R1,gettext_callafter
        MOV     R2,WsPtr                ; -> workspace / routine
        SWI     XOS_CallAfter

        EXIT

;..............................................................................

; Remove to change - remove possible CallAfter and CallBack routines.

removetochange ENTRY "R0-R1"

        ADR     R0,gettext_callafter
        MOV     R1,WsPtr
        SWI     XOS_RemoveTickerEvent   ; remove possible CallAfter routine

        MOV     R0,#-1
        STR     R0,nextstring           ; flag to get default text
        BL      gettext                 ; and then ensure that the default text is present

        EXIT

;..............................................................................

; This routine handles the call-after (IRQ mode) and issues a callback!

gettext_callafter

        MOV     R0,#-1
        STRB    R0,changetext           ; flag to change the string
        MOV     PC,LR

;..............................................................................

; Update the scrolling message string with the latest update, if the flag
; is -1 then we simply use the default string, otherwise we assume its
; the pointer to a meaningful message.

gettext ENTRY   "R0-R5"

        MOV     R0,#0
        STRB    R0,changetext           ; don't change text again (until next time non-zero)

        LDR     R3,nextstring           ; -> next string
        MOVS    R0,R3
        ADRMIL  R0,AuthorsTextCopy      ; -> copy of the string
        ADR     R1,AuthorsText          ; -> buffer to put the string into

10      LDRB    R2,[R0],#1
        STRB    R2,[R1],#1              ; copy the character
        CMP     R2,#32
        BGE     %BT10                   ; loop back until it has all been copied

        CMP     R3,#-1                  ; was it the default text?
        BLE     %FT20                   ; having copied then exit

        LDRB    R2,[R0]
        TEQ     R2,#0                   ; any more messages?
        MOVEQ   R0,#-1
        STR     R0,nextstring           ; adjust the next string pointer correctly

        BL      setuptochange

20      SUB     sp,sp,#si_size          ; allocate a buffer
        MOV     R1,sp                   ; -> buffer

        LDR     R2,info_handle
        MOV     R3,#author_icon         ; window, icon handles
        MOV     R4,#if_text
        MOV     R5,R4
;
        STMIA   R1,{R2-R5}              ; setup a suitable block
        SWI     XWimp_SetIconState      ; and update the icon (should get redrawn)

        ADD     sp,sp,#si_size
        EXITS

;-------------------------------------------------------------------------------

; In    [dragBar] -> block of icon that was being dragged
; Out   [dragBar] = -1
;       restart filing systems if we just dragged the RAM disc slot

drag_complete   ROUT
        Push    "LR"

        LDRB    userblk,errorendeddrag
        TEQ     userblk,#0
        MOVNE   userblk,#0
        STRNEB  userblk,errorendeddrag
        Pull    "PC",NE

        LDR     userblk,dragBar         ; if null,
        CMP     userblk,#0              ; this must be a save drag
        BLE     drag_savecomplete

; stop dragging (window is open)

        MOV     R14,#-2                 ; flag for insert/delete row
        STR     R14,dragBar

; if we were dragging the RAM disc bar, this might have been postponed

        BL      reinitramfsfiler

        Pull    "PC"


; Restart RAMFSFiler if [ramfsflag] set and not dragging the RAMFS bar
; In    [filertaskhandle] set up from Service_StartFiler
; Out   All filing systems restarted (including RAMFSFiler)

reinitramfsfiler  ROUT
        Push    "R1-R2,LR"
        LDR     R14,dragBar             ; check whether we're dragging the RAMFS bar
        CMP     R14,#0
        LDRGTB  R14,[R14,#icb_icon1]
        ASSERT  ic_sys7 > 0             ; can't match unless we ARE dragging
        CMP     R14,#ic_sys7
        LDRNEB  R14,ramfsflag           ; does RAMFSFiler need it?
        CMPNE   R14,#0
        Pull    "R1-R2,PC",EQ
        Debug   xx,"Restart RAMFS filer "

        MOV     R14,#0                  ; mark as 'done'
        STRB    R14,ramfsflag

01      MOV     R1,#Service_StartFiler
        LDR     R0,filertaskhandle      ; should be set up by now,
        Debug   xx,"filertaskhandle ",r0
        CMP     R0,#0
        Pull    "R1-R2,PC",LE           ; unless the filer is dead!
        Debug   xx,"Restart RAMFS filer II"
        SWI     XOS_ServiceCall
        TEQ     R1,#0
      [ debugxx
        BNE     %FT88
        DebugS  xx,"Command ",r0
88
      ]
        SWIEQ   XWimp_StartTask         ; claimed
        BEQ     %BT01

        MOV     R1,#Service_StartedFiler
        SWI     XOS_ServiceCall         ; finished

        LDR     R14,[userblk,#icb_memsize]

        [ {TRUE}
; S Cormie fix for MED-00375
        CMP     R14,#8*1024             ; must be >= 8k
        MOVLT   R0,#User_Message
        ADRLT   R1,filermessage
        LDRLT   R2,filertaskhandle
        SWILT   XWimp_SendMessage
        |
        TEQ     R14,#0                  ; if no ram disc,
        MOVEQ   R0,#User_Message        ; close all directories 'ram: ...'
        ADREQ   R1,filermessage
        LDREQ   R2,filertaskhandle
        SWIEQ   XWimp_SendMessage
        ]

        Pull    "R1-R2,PC"

filermessage
        DCD     endmess-filermessage
        DCD     0
        DCD     0
        DCD     0
        DCD     Message_FilerCloseDir
        DCD     fsnumber_ramfs
        DCD     0
        DCB     "ram:",0
        ALIGN
endmess

;-------------------------------------------------------------------------------

; Finished dragging a "save" box
; Send Message_DataSave to find out where to save to

drag_savecomplete  ROUT

        SWI     XDragASprite_Stop               ; allow Drag-a-Sprite to tidy up!
        MOV     R2,R1                           ; save message pointer

        ASSERT  b_x = 0
        ADDVC   R1,R2,#msDataTransfer_x         ; get mouse posn
        SWIVC   XWimp_GetPointerInfo            ; in convenient(-ish) place
        Pull    "PC",VS

        LDR     R3,[R1,#b_window]               ; ignore this if window = savedbox
        LDR     R14,h_savedbox
        TEQ     R3,R14
        Pull    "PC",EQ

        MOV     R1,R2                           ; R1 -> message block

        LDR     R2,[R1,#msDataTransfer_x + b_window]
        LDR     R3,[R1,#msDataTransfer_x + b_icon]
        STR     R2,[R1,#msDataTransfer_window]
        STR     R3,[R1,#msDataTransfer_icon]

        MOV     R14,#0
        STR     R14,[R1,#ms_yourref]
        MOV     R14,#Message_DataSave
        STR     R14,[R1,#ms_action]
        MOV     R14,#0                          ; don't know the size
        STR     R14,[R1,#msDataTransfer_filesize]
        LDR     R14,=FileType_Desktop
        STR     R14,[R1,#msDataTransfer_filetype]

        LDR     R4,mb_savedbox
        MOV     R5,R4
01      LDRB    R14,[R4],#1             ; find start of leafname
        TEQ     R14,#"."
        MOVEQ   R5,R4
        CMP     R14,#32
        BHI     %BT01

        ADD     R0,R1,#msDataTransfer_filename
02      LDRB    R14,[R5],#1
        STRB    R14,[R0],#1
        CMP     R14,#32
        BHI     %BT02
        MOV     R14,#0                  ; ensure proper terminator
        STRB    R14,[R0,#-1]

        ADD     R0,R0,#3
        BIC     R0,R0,#3
        SUB     R0,R0,R1
        STR     R0,[R1,#ms_size]

        MOV     R0,#User_Message        ; don't care if no reply
        SWI     XWimp_SendMessage

        Pull    "PC"

;-----------------------------------------------------------------------------

; Poll Word non-zero: either memoryupdated or savedesk_handle set
;
; memoryupdated:    Recalculate slot sizes, and re-init RAMFSFiler
;
; savedesk_handle:  Someone acknowledged the Message_SaveDesktop
;                   The save should be aborted, and the file removed
;
; changetext:       Update scrolling text messages

pollword_event
        Push    "LR"

        LDRB    R14,changetext
        TEQ     R14,#0
        BLNE    gettext
        Pull    "PC",NE

        LDRB    R14,memoryupdated
        TEQ     R14,#0
        BEQ     %FT01
        [ DynamicAreas
        BL      calc_dynamicareas
        ]
        BL      calc_memorymap
        BL      calc_slotsize
        MOV     R14,#0
        STRB    R14,memoryupdated
01
        LDRB    R14,savedesk_handle
        TEQ     R14,#0
        BLNE    abortsavedesk

        LDRB    R14, shutdown_swi
        TEQ     R14, #0
        MOVNE   R14, #0
        STRNEB  R14, shutdown_swi

        Pull    "PC"

; if Message_SaveDesk is acknowledged, abort the save and delete the file

abortsavedesk
        Push    "R0,LR"

        BL      closesavedesk           ; close file and zero handle

; now delete the file (whether or not it was a scrap file)

        MOV     R0,#OSFile_Delete       ; this acts like *Remove
        LDR     R1,savedesk_loadmess    ; filename may not be in mb_savedbox
        TEQ     R1,#0
        ADREQL  R1,mb_savedbox          ; must have been a straight save
        LDREQ   R1,[R1]
        ADDNE   R1,R1,#msDataTransfer_filename
        DebugS  xx,"Deleting boot file:",R1
        SWI     XOS_File

        BL      deallocate_loadmess     ; don't send the Message_DataLoad

        Pull    "R0,PC",,^              ; preserve error state

;.............................................................................

; Message_SaveDesktop bounced: Continue with next task
; In    LR on stack (called from messagereceived_rtn)

savedesk_bounced
        Push    "LR"                    ; this used to be done on pollword_event

        LDR     R0,savedesk_nexttask
        Debug   xx,"savedesk_nexttask =",R0
        MOV     R1,#bignum              ; earliest so far

        LDR     R2,wlink                ; R2 -> first block in list
01      LDRB    R14,[R2,#icb_icon1]
        TEQ     R14,#ic_taskname
        BNE     %FT02
        [ DynamicAreas
        LDR     R14,[R2,#icb_taskhandle]    ; zero taskhandle means DA
        CMP     R14,#0
        BEQ     %FT02
        ]
        LDR     R14,[R2,#icb_taskage]
        CMP     R14,R0                  ; if later than savedesk_nexttask,
        CMPHI   R1,R14                  ; and earlier than any so far,
        MOVHI   R1,R14
        MOVHI   R3,R2
02      LDR     R2,[R2,#icb_link]
        CMP     R2,#0
        BGT     %BT01

; R1 = age of next task found, R3 -> task's icon block

        CMP     R1,#bignum              ; if none found, we've finished!
        BEQ     donesavedesk

        STR     R1,savedesk_nexttask    ; for next time

        MOV     R0,#msSaveDesktop_size  ; R0, R1,R3 = size, <>, <>
        MOV     R4,#0                   ; R4 = your_ref
        MOV     R5,#Message_SaveDesktop ; R5 = action
        LDRB    R6,savedesk_handle      ; file handles are bytes only
        MOV     R7,#0                   ; R7 = flag word (currently reserved)
        ASSERT  msSaveDesktop_size = 28
        Push    "R0,R1,R3,R4,R5,R6,R7"

        MOV     R0,#User_Message_Recorded   ; do next one when this bounces
        MOV     R1,sp
        LDR     R2,[R3,#icb_taskhandle]
        Debug   xx,"Send Message_SaveDesktop to task",R2
        SWI     XWimp_SendMessage
        ADD     sp,sp,#msSaveDesktop_size

        Pull    "PC"

donesavedesk
        BL      closesavedesk           ; close file handle
        Pull    "PC",VS

; now scan filename and see if we should set the !Boot options

      [ {FALSE}
        LDR     R1,savedesk_loadmess
        CMP     R1,#0
        BEQ     %FT01                   ; scan name if no data transfer
        LDR     R14,[R1,#msDataTransfer_filesize]
        CMP     R14,#0
        BLT     %FT02                   ; don't scan name if name not used
01
      ]

; Recognised filename formats are:
;       <notnetfs>[#<anything>]:[:<discname>.]$.!Boot
;       net[#<fsname>]:&.!ArmBoot

02
        LDR     R1,savedesk_loadmess
        CMP     R1,#0
        MOVNE   R0,#User_Message        ; send Message_DataLoad if required
        LDRNE   R2,savedesk_taskhandle
        SWINE   XWimp_SendMessage

        BL      deallocate_loadmess     ; keeps any outstanding error
        BVC     continuequit            ; carry on after auto-saving

        Pull    "PC"

;.............................................................................

; In    [savedesk_loadmess] -> message block
; Out   [savedesk_loadmess] = 0, block deleted

deallocate_loadmess
        Push    "R0-R2,LR"

        LDR     R2,savedesk_loadmess
        CMP     R2,#0
        MOVNE   R14,#0
        STRNE   R14,savedesk_loadmess
        MOVNE   R0,#ModHandReason_Free
        SWINE   XOS_Module

        Pull    "R0-R2,PC",,^           ; preserve old error

;;----------------------------------------------------------------------------
;; 'Hot key' decoding
;;----------------------------------------------------------------------------

; In    R1 -> poll block
;       R2 = sender's task handle (0 => it's a 'real' keypress)

key_pressed
        Push    "LR"

        LDR     R0,[R1,#wc_char]        ; R0 = key code

        Debug   key,"Task Manager Received key ",R0

        LDR     R3,[R1,#wc_handle]      ; don't corrupt R2
        LDR     R14,h_savedbox
        TEQ     R3,R14
        TEQEQ   R0,#13                  ; RETURN in save dbox => save file
        BEQ     key_savestate

        LDR     R3,[R1,#wc_handle]
        LDR     R14,h_shutdown
        TEQ     R3,R14
        TEQEQ   R0,#13                  ; RETURN in shutdown box => restart
        BEQ     restart

        LDR     R14,=&1EC               ; Ctrl-F12
        TEQ     R0,R14
        BEQ     key_taskwindow

        LDR     R14,=&1CC               ; f12
        TEQ     R0,R14
        BEQ     key_shellcli

        LDR     R14,=&1FC               ; ctrl-shift-f12
        TEQ     R0,R14
        BEQ     key_quitall

        SWI     XWimp_ProcessKey        ; pass it on!

        Pull    "PC"
        LTORG

;;----------------------------------------------------------------------------
;; Menu decoding
;;----------------------------------------------------------------------------

mstr_taskwindow DCB     "M02a", 0       ; "Task display"
mstr_task       DCB     "M02b", 0       ; "Task '%0'"
nullname        DCB     0               ; if no task name
                ALIGN
keys            DCB     "TEAM"

copyr0r2
        Push    "LR"
01
        LDRB    R14,[R0],#1
        STRB    R14,[R2],#1
        TEQ     R14,#0
        BNE     %BT01
        SUB     R2,R2,#1
        Pull    "PC"

;..............................................................................

click_menu
        MOV     R0,#0
        STR     R0,menuclick            ; internal flag to indicate if I need to make a menu?
;
        LDR     R0,[R1,#b_window]
        LDR     R14,info_handle
        CMP     R0,R14                  ; is it the info dialogue
        LDREQ   R14,[R1,#b_icon]
        TEQEQ   R14,#author_icon        ; bug fix: ddv address exception on dialogue
        BNE     notinfobox
;
        LDRB    R2,keycount             ; get the key counter
        TEQ     R2,#255
        Pull    "PC",EQ                 ; if not valid then exit
;
        Push    "R1-R4"

        LDMIA   R1,{cx0,cy0}            ; get the mouse coordinates
        BL      relmousecoords          ; convert to offsets into th window
;
; assumes R1 -> suitable buffer / R0 = window handle
;
        STR     R0,[R1,#gi_handle]
        MOV     R0,#author_icon
        STR     R0,[R1,#gi_iconhandle]
        SWI     XWimp_GetIconState      ; read the information on the iocon
;
        LDR     R3,[R1,#gi_iconblock +i_bbx0]
        SUB     R3,cx0,R3

        SUB     R3,R3,#16
        MOV     R3,R3,LSR #4            ; calculate the offset into the string
;
        LDR     R4,[R1,#gi_iconblock +i_flags]
        TST     R4,#if_text
        TSTNE   R4,#if_indirected       ; are the flags valid?
        MOVEQ   R0,#-1
        [       false
        LDRNE   R0,[R1,#gi_iconblock +i_data +ii_buffer]
        LDRNEB  R0,[R0,R3]              ; get the character
        BICNE   R0,R0,#32               ; ensure lowercase - bodge arama!
;
        LDRB    R2,keycount             ; restore the key count (corrupt earlier)
        ADR     R3,keys
        LDRB    R3,[R3,R2]              ; get the expected character
;
        TEQ     R0,R3                   ; are they correct
        ADDEQ   R2,R2,#1                ; if they are then increase the index
        MOVNE   R2,#-1
        |
        LDRNEB    R2,keycount
        ADDNE   R2,R2,#1
        MOVEQ   R2,#-1
        ]
        STRB    R2,keycount             ; increase until all read
;
        TEQ     R2,#?keys
        Pull    "R1-R4,PC",NE           ; if not correct count then exit
;
; locate heros list at the end of the ROM
;
        MOV     R0,#ModHandReason_EnumerateROM_Modules
        MOV     R1,#0
        MOV     R2,#-1                  ; look for utility module, in main ROM
        SWI     XOS_Module

        MOV     R0,#ModHandReason_LookupName
        MOV     R1,R3
        SWI     XOS_Module              ; then get its real address

        SUB     R0,R3,#4                ; word prior contains link to next module

10      LDR     R1,[R0]                 ; get offset to next module
        CMP     R1,#0
        ADDNE   R0,R0,R1                ; not end of list so address next one and loop
        BNE     %BT10

        ADD     R0,R0,#4
        STR     R0,nextstring           ; pointer to start of heros list

        BL      setuptochange           ; setup ready to start changing messages

        Pull    "R1-R4,PC"              ; then return 'cos all done

;..............................................................................

notinfobox
        LDR     R14,h_switcher
        CMP     R0,R14                  ; task window handle
        BEQ     noticonbar

        CMP     R0,#iconbar_whandle     ; forget it unless iconbar
        Pull    "PC",NE

        ADRL    R0,mstr_taskwindow
        MOV     R4,#0
        BL      make_mb_taskname        ; R2 = no of chars in buffer

        LDR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_task
        BIC     R14,R14,#is_shaded
        STR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_task
        MOV     R14,#-1
        STR     R14,m_iconbarmenu+m_headersize+mi_submenu+mi_size* mo_ic_task
 [ Freeze
        BL      setfreezeentry
        MOV     R14,#96 + 9*44 - 12     ; 1 extra menu entry (Info)
 |
        MOV     R14,#96 + 8*44 - 12     ; 1 extra menu entry (Info)
 ]
        STR     R14,[R1,#b_y]           ; fake mouse y-coord
        MOV     userblk,#-2             ; copied into [menutask]
        B       zapwidth

noticonbar
        LDMIA   R1,{cx0,cy0}            ; cx0,cy0 = mouse click coords
        BL      relmousecoords          ; cx0,cy0 rel; cx1,cy1 = origin
        BLVC    findclick               ; userblk --> block; x0,y0 set up
        Pull    "PC",VS
;
        CMP     userblk,#0
        BLE     nottask1
;
        LDRB    R14,[userblk,#icb_icon1]
        TEQ     R14,#ic_taskname
        [ DynamicAreas
        BNE     %FT01
        LDR     R14,[userblk,#icb_taskhandle]
        CMP     R14,#0
        BNE     %FT02
        MOV     userblk,#-1
01
        ]
        MOVNE   userblk,#-1             ; copied into [menutask]
02
nottask1
        CMP     userblk,#0
        LDR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_task
        ORRLE   R14,R14,#is_shaded
        BICGT   R14,R14,#is_shaded
        STR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_task
        ADRL    R14,m_task
        STR     R14,m_iconbarmenu+m_headersize+mi_submenu+mi_size* mo_ic_task
 [ Freeze
        BL      setfreezeentry
 ]
        ADRL    R0,mstr_task
        ADRLEL  R4,nullname
        ADDGT   R4,userblk,#icb_taskname
        BL      make_mb_taskname                ; R2 = no of chars in result

; R2 = number of characters in mo_ic_task menu entry

zapwidth
        Pull    "PC",VS

        MOV     R2,R2,LSL #4            ; multiply by 16
        ADD     R2,R2,#12               ; and add 12
        LDR     r14, m_iconbarmenu_width
        CMP     r2, r14
        MOVLT   r2, r14
;
        STR     R2,m_iconbarmenu+m_itemwidth
;
gomenu
        CMP     userblk,#0
        STR     userblk,menu_userblk    ; for help stuff
        LDRGT   userblk,[userblk,#icb_taskhandle]
        STR     userblk,menutask

; set up 'auto-boot' icon to appropriate state

        Push    "R1"
        MOV     R0,#ReadCMOS
        MOV     R1,#DBTBCMOS            ; auto-boot bit is in here
        SWI     XOS_Byte
        TST     R2,#&10                 ; (bit 4 in fact)
        MOVEQ   R3,#0
        MOVNE   R3,#is_inverted
        MOV     R4,#is_inverted
        LDRVC   R1,h_savedbox
        MOV     R2,#saveicon_autoboot
        Push    "R1-R4"
        MOV     R1,sp
        SWIVC   XWimp_SetIconState
        ADD     sp,sp,#4*4
        Pull    "R1"
        Pull    "PC",VS
;
; set up 'auto-save' icon to "off", so it must be explicitly selected
;
        LDR     R2,h_savedbox
        MOV     R3,#saveicon_autosave
        MOV     R4,#0
        MOV     R14,#is_inverted
        Push    "R1-R4,R14"             ; save R1 and set up stack
        ADD     R1,sp,#4
        SWIVC   XWimp_SetIconState
        LDR     R1,[sp],#5*4            ; restore R1 and correct stack
;
        LDR     R0,menuclick
        CMP     R0,#0                   ; need to open the menu?
        BNE     %FT10
;
        LDMIA   R1,{R2,R3}              ; mouse x,y (may be faked)
        ADRL    R1,m_iconbarmenu
        STR     R1,menuhandle
        LDR     R14,[R1,#16]            ; get menu width
        SUB     R2,R2,R14,ASR #1        ; ensure mouse ptr is in middle
        ADD     R3,R3,#12
        SWIVC   XWimp_CreateMenu        ; bugfix
        Pull    "PC",VS

        MOV     R0,#0
        STRB    R0,keycount             ; reset the index into the key counter loop
10
        BL      refind_font
        Pull    "PC"

 [ Freeze
setfreezeentry
        ENTRY   "R0, R1"
        SWI     XPortable_ReadFeatures          ;Bitset returned in R1
        MOVVS   R1,#0
        TST     R1,#PortableFeature_Stop
        LDR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_freeze
        ORREQ   R14,R14,#is_shaded
        BICNE   R14,R14,#is_shaded
        STR     R14,m_iconbarmenu+m_headersize+mi_iconflags+mi_size* mo_ic_freeze
        EXITS
 ]

;........................................................................

; In    R0 -> token to use
;       R4 -> parameter 0
; Out   R2 = size of result, put in [mb_taskname..]
;       VC => R0 corrupt, VS => R0 -> error block

make_mb_taskname ENTRY "r1,r3-r7"

        MOV     r1, r0                  ; r1 -> token
        BL      allocatemessagedata
        wsaddr  r2, mb_taskname, VC
        MOVVC   r3, #?mb_taskname
        MOVVC   r5, #0
        MOVVC   r6, #0
        MOVVC   r7, #0
        SWIVC   XMessageTrans_Lookup

        MOVVC   r2, r3                  ; r2 = size of result

        EXIT

;........................................................................

menu_selection
        Push    "LR"
;
        BL      losefont                ; attempt to lose the font used for the info dialogue
;
        MOV     R2,R1                   ; R2 --> list of selections
        SUB     sp,sp,#b_size
        MOV     R1,sp
        SWI     XWimp_GetPointerInfo
;
        Debug   mn,"Pointer info at",R1
        Debug   mn,"Menu selection information",R2
;
        LDR     R1,menuhandle           ; R1 = menu handle
        BL      decodemenu
;
        ADD     sp,sp,#b_size           ; balance the stack correctly
        Pull    "PC"

;........................................................................
;
; Entry:  R1 --> menu
;         R2 --> list of selections
;

decodemenu
        Push    "LR"
;
decodelp
        ADRL    R14,m_iconbarmenu
        TEQ     R1,R14
        Pull    "PC",NE

        Debug   mn,"Must be a valid menu",R1

sel_iconbar
        MOV     R14,#flg_exit           ; default action if used
        STRB    R14,shutdownflag

        LDR     R14,[R2],#4             ; top-level menu
        TEQ     R14,#mo_ic_newtask
        BEQ     gonewtask
        TEQ     R14,#mo_ic_task
        BEQ     gotask
        TEQ     R14,#mo_ic_exit
        BEQ     goexit
 [ Freeze
        TEQ     R14,#mo_ic_freeze
        BEQ     gofreeze
 ]
        TEQ     R14,#mo_ic_shutdown
        BEQ     goshutdown
        TEQ     R14,#mo_ic_taskw
        BEQ     key_taskwindow
        TEQ     R14,#mo_ic_shell
        Pull    "PC",NE
;

key_shellcli
        ADR     R0,shellcommand
        SWI     XWimp_StartTask
        Pull    "PC"

key_taskwindow
        MOV     R0,#0
        SWI     XWimp_ReadSysInfo
        TEQ     R0,#1                                   ; are we the only task running?
        Pull    "PC",EQ
        ADRL    R0,taskcommand
        SWI     XWimp_StartTask
        Pull    "PC"

gonewtask
        LDR     R14,[R2],#4
        TEQ     R14,#0
        ADREQ   R0,mb_newtask
        SWIEQ   XWimp_StartTask
        Pull    "PC"

gotask
        LDR     R14,menutask
        CMP     R14,#-2
        BNE     %FT01

openswitcher
        BL      calc_memorymap          ; recalculate for good measure
        BL      calc_slotsize
        BL      calc_rmasize
        LDR     R0,h_switcher
        BL      front_window
        MOVVC   R14,#-1                 ; task window is now open
        STRVC   R14,dragBar
        Pull    "PC"

01      LDR     R14,[R2],#4             ; only entry is quit
        TEQ     R14,#mo_ts_quit
        Pull    "PC",NE
;
        LDR     R2,menutask             ; task to be killed
        BL      %FT10
;
        MOV     userblk,#-1             ; no task has been selected
        STR     userblk,menuclick
        B       nottask1
10
        Push    "LR"
        B       goquitit

;........................................................................

; R2=0 => This has been called in response to a 'real' keypress,
; R2<>0=> A message has been sent to restart the closedown sequence
;         In the latter case shutdownflag must be left unaltered.
;
; Also, if R2 = [quitreceiver], supress the closedown!
; This is because after stopping the PreQuit, tasks restart by sending a
; ctrl-shift-f12, and this is only valid if the PreQuit was in fact a
; broadcast.

key_quitall
        TEQ     R2,#0
        BNE     %FT01
        LDR     R14,shutdown_dbox       ; Is shutdown dbox on screen ?
        CMP     R14,#0
        BNE     exitanddie
;
        B       goshutdown
01
        LDR     R14,quitreceiver        ; if this is the quitreceiver,
        TEQ     R2,R14                  ; then we should only close IT down
        BEQ     done_prequit
        B       continuequit            ; forget the auto-save this time

;..............................................................................

; Exit and die, this routine attempts to tidy up when the application is
; about to die.

exitanddie
        BL      freeworkspace
        MOV     R1,#0
        SWI     OS_Exit                 ; blow 'im away

;..............................................................................

; Lose the font currently claimed for the dialogue box.

losefont ENTRY "R0"
        LDR     R0,info_font
        CMP     R0,#0                   ; font currently claimed?
        SWINE   XFont_LoseFont          ; yes, so release it
        MOV     R0,#0
        STR     R0,info_font            ; and then tag as removed
        EXITS

;........................................................................

; We can get here by:
;       selecting the menu option in the parent menu
;       clicking "OK" in the dbox
;       pressing RETURN in the dbox
; Only proceed if the file contains at least one "."

key_savestate
        MOV     R1,#-1                  ; always remove menu tree for this
        SWI     XWimp_CreateMenu

gosavestate
        BLVC    explicitsave            ; set up [autosave] and [shutdownflag]
        Pull    "PC",VS

        LDR     R1,mb_savedbox
01      LDRB    R14,[R1],#1
        TEQ     R14,#"."
        BEQ     startsave
        CMP     R14,#32
        BHI     %BT01
        MyError NoDotInFilename
        Pull    "PC"
        MakeInternatErrorBlock NoDotInFilename,,E05

;.............................................................................

; In    icon in savedbox selected or not
; Out   [autosave]=0 if icon was not selected, non-0 otherwise
;       [shutdownflag] = flg_nothing (ie. this is an explicit save operation)

explicitsave
        Push    "R1,LR"

        MOV     R14,#flg_nothing        ; this is an explicit save
        STRB    R14,shutdownflag

        LDR     R0,h_savedbox
        MOV     R1,#saveicon_autosave
        Push    "R0,R1,R2-R9"           ; window, icon, 8 words
        MOV     R1,sp
        SWI     XWimp_GetIconState
        LDRVC   R14,[R1,#8+i_flags]     ; R14 = icon flag word
        ADD     sp,sp,#10*4

        AND     R14,R14,#is_inverted
        STR     R14,autosave            ; non-zero => auto-saving enabled

        Pull    "R1,PC"

 [ Freeze
;.............................................................................
;
; We don't check the machine type before issueing the 'Portable_Stop' SWI as
; the menu entry should have been greyed out if the hardware can't do it.

gofreeze
        MOV     R1,#-1                  ; always remove menu tree for this
        SWI     XWimp_CreateMenu

        SWI     XPortable_Stop          ; freeze machine
                                        ;VC, frozen then awakened OK
                                        ;VS, failed, so report error
        Pull    "PC"
 ]
;........................................................................

; In    "<SaveDesk$File>" = auto-save file (if set)
;       [shutdownflag] = what to do after saving the state
; Out   If auto-saving, goes to startsave with [autosave] non-0
;       If not, goes to continuequit

goexit
        ADR     R0,str_savedesk         ; R0 -> "SaveDesk$File"
        LDR     R1,mb_savedbox          ; R1 -> buffer
        LDR     R2,ml_savedbox          ; R2 = length of buffer
        SUB     R2,R2,#1                ; make room for terminator
        MOV     R3,#0                   ; R3 = 0
        MOV     R4,#VarType_Expanded    ; R4 = 3 => expand macros
        SWI     XOS_ReadVarVal          ; VS => variable not found
        BVS     continuequit

        MOV     R14,#0                  ; append terminator
        STRB    R14,[R1,R2]
        MOV     R14,#1                  ; enable auto-save for this file
        STR     R14,autosave
        B       startsave

str_savedesk    DCB     "SaveDesk$File", 0
                ALIGN

;........................................................................

; In    [autosave] non-0 => output "Set SaveDesk$File <Desktop$File>"
;       [shutdownflag] => what to do after saving

startsave
        LDR     R1,mb_savedbox
        BL      savestate
        Pull    "PC"                    ; when that's finished, continue!

;........................................................................

; Come here to carry on after saving the state

; In    [shutdownflag] = what to do after quitting the applications

continuequit
        LDRB    R14,shutdownflag
        CMP     R14,#flg_nothing        ; CLRV
        Pull    "PC",EQ
        MOV     R2,#0                   ; broadcast

goquitit
        STR     R2,quitreceiver
        MOV     R0,#24                  ; size
        MOV     R3,#0                   ; your_ref
        MOV     R4,#Message_PreQuit     ; action
        MOVS    R5,R2                   ; 0 => desktop being quitted
        MOVNE   R5,#1                   ; 1 => just this task
        Push    "R0-R5"
        MOV     R0,#User_Message_Recorded  ; ackowledgeable message
        MOV     R1,sp
        LDR     R6,shutdownflags
        TST     R6,#shutdownbit_NoPreQuit
        LDRNE   R2,mytaskhandle         ; if no pre-quit then send it to me
        BL      sendmessage
        STRVC   R2,prequitref           ; check myref on exit
        ADD     sp,sp,#24
        Pull    "PC"

goshutdown
        MOV     R14,#flg_shutdown       ; shut down when all that lot finishes
        STRB    R14,shutdownflag
;
        LDR     R6,shutdownflags
        TST     R6,#shutdownbit_ModifyStateCMOS
        Push    "R2",NE
        LDRNE   R2,=state_shutdownfailed
        BLNE    writestate              ; set state of CMOS to indicate shutdown started
        Pull    "R2",NE
;
        MOV     r1,#Service_ShutDown
        SWI     XOS_ServiceCall
        TEQ     R1,#0                   ; Service claimed, don't shut down.
        Pull    "PC",EQ
;
        B       goexit

shellcommand    DCB     "ShellCLI",0
taskcommand     DCB     "TaskWindow -Display",0
                ALIGN

;...............................................................................

; Initiate the process of saving the state
;
; In:   R1 -> full filename
;       [autosave] <> 0 => output "Set SaveDesk$File <Desktop$File>" line
; Out:  [savedesk_handle] = file handle (starts save process off)
;       [savedesk_nexttask] = 0 (start at first task in list)
;
; Task Manager itself starts the ball rolling by outputting:
;
;       | Desktop boot file, saved at <time+date>
;
;       Set SaveDesk$File <Desktop$File>          (if [autosave] true)
;

savestate
        Push    "LR"
        BL      deallocate_loadmess     ; just in case
        Pull    "LR"                    ; drop through

savestate_bydragging
        Push    "R1-R5,LR"

        MOV     R0,#OSFile_CreateStamp  ; first create empty file,
        LDR     R2,=FileType_Desktop    ; so that the stamp is correct
        MOV     R4,#0
        MOV     R5,#0                   ; zero length initially
        SWI     XOS_File
        Pull    "R1-R5,PC",VS

        MOVVC   R0,#OSFind_ReadFile :OR: open_write
        SWIVC   XOS_Find                ; use update so we keep filetype
        Pull    "R1-R5,PC",VS
        ASSERT  savedesk_handle = pollword
        STRVCB  R0,savedesk_handle      ; part of poll word
        MOVVC   R14,#0
        STRVC   R14,savedesk_nexttask   ; next task to ask for a command

; OSS Get time for comment at top of auotboot file.

        MOVVC   R0,#14                  ; read CMOS clock
        ADRVC   R1,pollblock
        MOVVC   R14,#3
        STRVCB  R14,[R1]                ; reason code = 3 => read 5-byte time
        SWIVC   XOS_Word
        MOVVC   R0,R1
        ADDVC   R1,R1,#5                ; 5 bytes needed for time
        LDRVC   R2,=(?pollblock-5)
        SWIVC   XOS_ConvertStandardDateAndTime

; OSS Lookup the comment at the start of the desktop boot file. It is looked
; up into a buffer since it needs to be NULL and not LF terminated.

        MOVVC   r4, r0                  ; Time in %0
        SUBVC   r3, r2, #1              ; Remaining buffer size
        ADDVC   r2, r1, #1              ; Rest of buffer after NULL
        ADRVCL  r1, str_header          ; Message token
        BLVC    allocatemessagedata     ; r0 -> file desc
        MOVVC   r5, #0
        MOVVC   r6, #0
        MOVVC   r7, #0
        SWIVC   XMessageTrans_GSLookup
        BLVC    writestr                ; Write message in R2
        BLVS    abortsavedesk           ; preserves error state
        Pull    "R1-R5,PC",VS

        LDR     R14,autosave            ; if auto-saving enabled,
        TEQ     R14,#0                  ; output "Set SaveDesk$File <Desktop$File>"
        BEQ     %FT01
        ADRVCL  R2,str_setsavedesk
        BLVC    writestr
01
        MOVVC   R0,#-1
        MOVVC   R1,#-1
        SWIVC   XWimp_SlotSize          ; R1 = next slot size
        ADRVCL  R2,str_wimpslot
        BLVC    setmemcommand           ; "*WimpSlot -next <n>K"

        MOVVC   R0,#fontarea
        ADRVCL  R2,str_fontsize
        BLVC    setareacommand          ; "*ChangeDynamicArea -FontSize <n>K"

        MOVVC   R0,#spritearea
        ADRVCL  R2,str_spritesize
        BLVC    setareacommand          ; "*ChangeDynamicArea -SpriteSize <n>K"

        MOVVC   R0,#ramfsarea
        ADRVCL  R2,str_ramfssize
        BLVC    setareacommand          ; "*ChangeDynamicArea -RamFsSize <n>K"

        MOVVC   R0,#0                   ; R0 = flag word on entry
        LDRVCB  R2,savedesk_handle      ; R2 = file handle on entry
        MOVVC   R1,#Service_WimpSaveDesktop
        SWIVC   XOS_ServiceCall
        TEQVC   R1,#0                   ; claimed => R0 -> error block
        SETV    EQ

        BLVS    abortsavedesk           ; preserves error state
        BLVC    savedesk_bounced        ; send the first message

        ADR     r1,pollblock
        LDR     r2,h_savedbox
        STR     r2,[r1]
        MOV     r2,#3                   ; Boot option icon
        STR     r2,[r1,#4]
        SWI     XWimp_GetIconState
        Pull    "R1-R5,PC",VS

        LDR     r2,[r1,#8+16]
        TST     r2,#is_inverted
      [ debugab
        BNE     %FT91
        Debug   ab,"Auto boot option disabled."
91
      ]
        Pull    "r1-r5,PC",EQ

        LDR     r1,[sp]
        DebugS  ab,"State saved in file ",r1

        MOV     r2,#-1
        MOV     r14,r1
01
        LDRB    r0,[r14],#1
        CMP     r0,#"."
        MOVEQ   r2,r14
        CMP     r0,#32
        BGE     %BT01

        CMP     r2,#-1
        Pull    "r1-r5,PC",EQ   ; No '.' in pathname, can't be a boot file.

        LDRB    r0,[r2,#-2]     ; R0 = character before last '.'

        TEQ     r0,#"$"
       [ debugab
        BEQ     %FT92
        Debug   ab,"Not in a root directory."
92
       ]
        Pull    "r1-r5,PC",NE

        LDRB    r0,[r2],#1
        TEQ     r0,#"!"
        LDREQB  r0,[r2],#1
        BICEQ   r0,r0,#&20
        TEQ     r0,#"B"
        LDREQB  r0,[r2],#1
        BICEQ   r0,r0,#&20
        TEQ     r0,#"O"
        LDREQB  r0,[r2],#1
        BICEQ   r0,r0,#&20
        TEQ     r0,#"O"
        LDREQB  r0,[r2],#1
        BICEQ   r0,r0,#&20
        TEQ     r0,#"T"
       [ debugab
        BEQ     %FT92
        Debug   ab,"Not a boot file."
92
       ]
        Pull    "r1-r5,PC",NE


        ADRL    r0,filecore_prefix
        ADR     r2,pollblock
        BL      copyr0r2                ; r2 -> terminator

        MOV     r14,r1
01
        LDRB    r0,[r14],#1
        STRB    r0,[r2],#1
        TEQ     r0,#"#"
        TEQNE   r0,#":"
        BNE     %BT01
        MOV     r0,#0
        STRB    r0,[r2,#-1]

        Push    "r1"
        MOV     r0,#ModHandReason_MakePreferred
        ADR     r1,pollblock
        DebugS  ab,"Looking for module ",r1
        SWI     XOS_Module
        Pull    "r1"
       [ debugab
        BVC     %FT93
        ADD     r14,r0,#4
        DebugS  ab,"Error is ",r14
93
       ]
        Pull     "r1-r5,PC",VS,^

        Debug   ab,"Module found."


        ADR     r2,pollblock
        MOV     r14,r1
01
        LDRB    r0,[r14],#1
        CMP     r0,#":"
        BNE     %BT01
        ADD     r14,r14,#1              ; r14 -> Start of disc name
02
        LDRB    r0,[r14],#1
        STRB    r0,[r2],#1
        CMP     r0,#"."
        BNE     %BT02
        MOV     r0,#0
        STRB    r0,[r2,#-1]
        ADR     r0,pollblock
        Debug   ab,"Disc name is ",r0

        Push    "r1,r8"
        ADR     r1,pollblock+64
        MOV     r8,#0
        SWI     XFileCore_DescribeDisc
        Pull    "r1,r8"
        Pull    "r1-r5,PC",VS

        LDR     r0,pollblock+64+12
        MOV     r3,r0,LSR #29
        Debug   ab,"Drive number is ",r3

        ADRL    r0,driveconfig
        ADR     r2,pollblock
        BL      copyr0r2                ; r2 -> terminator

        Push    "r1"
        MOV     r0,r3
        MOV     r1,r2
        MOV     r2,#256
        SWI     XOS_ConvertCardinal1
        Pull    "r1"
        Pull    "r1-r5,PC",VS
        ADR     r0,pollblock
        DebugS  ab,"Command is ",r0
        SWI     XOS_CLI
        Pull    "r1-r5,PC",VS

        ADRL    r0,fsconfig
        ADR     r2,pollblock
        BL      copyr0r2                ; r2 -> terminator

        MOV     r14,r1
01
        LDRB    r0,[r14],#1
        STRB    r0,[r2],#1
        TEQ     r0,#"#"
        TEQNE   r0,#":"
        BNE     %BT01
        MOV     r0,#0
        STRB    r0,[r2,#-1]
        ADR     r0,pollblock
        DebugS  ab,"Command is ",r0
        SWI     XOS_CLI
        Pull    "r1-r5,PC",VS

        ADR     r14,pollblock
01
        LDRB    r0,[r1],#1
        STRB    r0,[r14],#1
        TEQ     r0,#"."
        MOVEQ   r2,r14
        CMP     r0,#32
        BGE     %BT01

        MOV     r0,#0
        STRB    r0,[r2,#-1]
        ADR     r1,pollblock

        MOV     r0,#FSControl_WriteBootOption
        MOV     r2,#2
        SWI     XOS_FSControl
        Pull    "r1-r5,PC",VS

        MOV     R0,#ReadCMOS
        MOV     R1,#DBTBCMOS
        SWI     XOS_Byte
        ORR     R2,R2,#&10              ; enable auto-boot
        MOVVC   R0,#WriteCMOS
        SWIVC   XOS_Byte

        Pull    "R1-R5,PC"

str_header      DCB     "Boot", 0
str_setsavedesk DCB     "Set SaveDesk$File <Desktop$File>", 10, 0

fsconfig        DCB     "Configure FileSystem ",0
filecore_prefix DCB     "FileCore%",0
driveconfig     DCB     "Configure Drive ",0
                ALIGN

;............................................................................

; In    R0 = dynamic area number
;       R2 -> command prefix
;       [savedesk_handle] = file handle
; Out   "*ChangeDynamicArea -xxx <n>K" written to file

setareacommand
        Push    "R1-R2,LR"

        MOV     R1,#0
        SWI     XOS_ReadDynamicArea     ; doesn't touch R2
        BLVC    setmemcommand           ; R1 = value to set, R2 -> prefix

        Pull    "R1-R2,PC"

;............................................................................

; In    R1 = amount of memory to set (a whole number of K)
;       R2 -> command prefix
;       [savedesk_handle] = file handle
; Out   "<prefix><n>K" written to file

setmemcommand
        Push    "R1-R2,LR"

        BL      writestr                ; output prefix

        SUB     sp,sp,#8
        MOVVC   R0,R1,ASR #10           ; R0 = size in K
        MOVVC   R1,sp
        MOVVC   R2,#8                   ; allows for up to 9999999K
        SWIVC   XOS_ConvertCardinal4
        MOVVC   R2,R0                   ; R2 -> number
        BLVC    writestr
        ADD     sp,sp,#8

        ADRVC   R2,str_K                ; R2 -> "K", newline
        BLVC    writestr

        Pull    "R1-R2,PC"

str_wimpslot    DCB     "WimpSlot -next ", 0
str_fontsize    DCB     "ChangeDynamicArea -FontSize ", 0
str_spritesize  DCB     "ChangeDynamicArea -SpriteSize ", 0
str_ramfssize   DCB     "ChangeDynamicArea -RamFsSize ", 0
str_K           DCB     "K",10,0
                ALIGN

;............................................................................

; In    [savedesk_handle] = file handle (0 => none open)
; Out   [savedesk_handle] = 0, file closed
;       R0,V preserved if no error when closing

closesavedesk
        Push    "R0-R1,R5,LR"

        MOV     R0,#0
        LDRB    R1,savedesk_handle
        STRB    R0,savedesk_handle      ; write handle to 0

        TEQ     R1,#0                   ; preserve V
        Pull    "R0-R1,R5,PC",EQ        ; return if no file (keep old error)

        SWI     XOS_Find                ; close file if there was one
        STRVS   R0,[sp]                 ; return error from close
        Pull    "R0-R1,R5,PC",VS

        ;Set the file attributes to wr/r. JRC 22nd May 1995
        MOV     R0, #4                  ; OSFile_WriteAttr
        LDR     R1, mb_savedbox
        MOV     R5, #&13                ; OSFile_AttrOwnerRead :OR: OSFile_AttrOwnerWrite :OR: OSFile_AttrWorldRead
        SWI     OS_File
        STRVS   R0,[sp]                 ; return error from write attr
        Pull    "R0-R1,R5,PC",VS

        Pull    "R0-R1,R5,PC",,^        ; otherwise keep old error

;.............................................................................

; In    R2 -> string to output
;       [savedesk_handle] = file handle to output to
; Out   string output to file

writenewline
        ADR     R2,str_newline          ; write CHR$(10)

writestr
        Push    "R1-R2,LR"

        LDRB    R1,savedesk_handle      ; only 1 byte handle
01      LDRB    R0,[R2],#1              ; write bytes from [R2..]
        TEQ     R0,#0
        SWINE   XOS_BPut
        Pull    "R1-R2,PC",VS
        BNE     %BT01

        Pull    "R1-R2,PC"

str_newline     = 10,0
                ALIGN

;;----------------------------------------------------------------------------
;; Menu definitions
;;----------------------------------------------------------------------------

rom_menustart

m_iconbarmenu   Menu    T00
mo_ic_info      Item    M00
mo_ic_newtask   Item    M01,m_newtask
mo_ic_task      Item    M02,m_task
mo_ic_shell     Item    M03
mo_ic_taskw     Item    M04
mo_ic_savestate Item    M05
mo_ic_exit      Item    M06
 [ Freeze
mo_ic_freeze    Item    M07
 ]
mo_ic_shutdown  Item    M08

m_task          Menu    T02
mo_ts_quit      Item    M12

m_newtask       Menu    T01
mo_nt_oscli     Item    M11,,W

                DCB     0               ; terminator
                ALIGN

;.............................................................................

CopyMenus ENTRY "r1-r7"

        ADR     r1, mb_newtask                          ; set up writeable field
        MOV     r2, #0
        MOV     r3, #?mb_newtask
        ADRL    r14, m_newtask + m_headersize + mo_nt_oscli * mi_size + mi_icondata
        STMIA   r14, {r1-r3}

        BL      allocatemessagedata
        ADRVC   r1, rom_menustart
        wsaddr  r2, ram_menustart, VC
        MOVVC   r3, #ram_menuend-ram_menustart
        SWIVC   XMessageTrans_MakeMenus
        EXIT    VS

        LDR     r14, info_handle
        STR     r14, mm_info

        LDR     r14, h_savedbox
        STR     r14, mm_savedbox

        wsaddr  r14, mb_taskname
        STR     r14, m_iconbarmenu + m_headersize + mo_ic_task * mi_size + mi_icondata

        LDR     r1, =12*16 + 12                         ; correct width of m_newtask
        LDR     r14, m_newtask + m_itemwidth
        CMP     r1, r14
        STRGT   r1, m_newtask + m_itemwidth

        LDR     r14, m_iconbarmenu + m_itemwidth
        STR     r14, m_iconbarmenu_width                ; save for later

        EXIT
        LTORG

;;----------------------------------------------------------------------------
;; Included resource files
;;----------------------------------------------------------------------------

       [ standalone
resourcefsfiles
        ResourceFile Resources.UK.Messages, Resources.Switcher.Messages
       [ Swapping
        ResourceFile Resources.UK.SwpTemp,   Resources.Switcher.Templates
       |
        ResourceFile Resources.UK.Templates, Resources.Switcher.Templates ; AMcC 18-Oct-94 changed from Template3D
       ]
        DCD     0
      ]

        [ DynamicAreas
; new stuff required for Medusa Dynamic Areas

calc_dynamicareas
; must find out what dynamic areas there are (apart from 0-6), create icon for them if they previously
; didn't exist (using icb_taskage as the area number and pretend they are a task) or delete the icon
; if they have been deleted. ic_dynamareas is in the window link, and all icons should appear after this.
; new routines: delete_dynamicarea, create_dynamicarea, update_dynamicarea, find_dynamicarea
        Push    "R0-R9,lr"
        MOV     R1,#-1                  ; start
01
        MOV     R0,#3                   ; enumerate dynanamic areas
        SWI     XOS_DynamicArea
        Pull    "R0-R9,PC",VS
        CMP     R1,#-1
        Pull    "R0-R9,PC",EQ
        CMP     R1,#6
        BLGT    found_an_area
        Pull    "R0-R9,PC",VS
        B       %BT01

found_an_area
; R1 is a dynamic area (must be preserved)
        Push    "R1,lr"
        BL      update_dynamicarea      ; returns EQ if area couldn't be found
        BLEQ    create_dynamicarea
        Pull    "R1,PC"

update_dynamicarea
        Push    "R1,lr"
        BL      find_dynamicarea
        Pull    "R1,PC",EQ
        MOV     R0,#2                   ; get info
        SWI     XOS_DynamicArea
        LDR     R1,[R9,#icb_memsize]
        CMP     R1,R2
        BNE     %FT01
        MOVS    R1,#1                   ; don't want Z flag set
        Pull    "R1,PC"
01
        MOV     R1,R2
        MOV     userblk,R9
        Push    "R0-R9"
        Push    "PC"
        B       updatecdamem            ; returns with Pull PC
        NOP
        NOP
        Pull    "R0-R9"
        MOVS    R1,#1
        Pull    "R1,PC"

find_dynamicarea
; look for R1 area in window's icons, if it can't be found return EQ, otherwise R9 points to block
; R8 points to previous icon
        Push    "lr"
        LDR     R9,wlink
01
        LDRB    R14,[R9,#icb_icon1]
        CMP     R14,#ic_dynamareas               ; icon must appear after 'Dynamic Areas:'
        MOV     R8,R9
        LDR     R9,[R9,#icb_link]
        BNE     %BT01
; R9 now points to first icon after title
03
        CMP     R9,#-1
        Pull    "PC",EQ                         ; no more DA icons
        LDR     R14,[R9,#icb_taskage]
        CMP     R1,R14
        BNE     %FT05
        MOVS    R1,R1                           ; must be non zero
        Pull    "PC",NE
05
        MOV     R8,R9
        LDR     R9,[R9,#icb_link]
        B       %BT03

create_dynamicarea
; R1 is area to create, R8 is the icon to create it after.
; returns R8 as created icon
        Push    "R0-R7,lr"
        Push    "R8"
        MOV     R0,#2
        SWI     XOS_DynamicArea
        ; R2 is the memsize, R8 is the string we use
        ADDVS   SP,SP,#4
        Pull    "R0-R7,PC",VS
        MOV     R1,#ic_cdaname
        TST     R4,#128                         ; is it dragable ?
        MOV     R14,#ic_memoryK:SHL:8
        ORREQ   R14,R14,#ic_slotBar:SHL:16
        ORRNE   R14,R14,#ic_memoryBar:SHL:16
        ORR     R1,R1,R14
        MOV     R5,R2
        MOV     R3,R8
        Pull    "R2"                            ; previous icon
        BL      allocateblock
        LDR     R1,[SP,#4]
        Pull    "R0-R7,PC",VS
        STR     R1,[R2,#icb_taskage]            ; DA number
        STR     R5,[R2,#icb_memsize]
        MOV     R3,#0
        STR     R3,[R2,#icb_taskhandle]
        MOV     R8,R2
        BL      calc_extent
        Pull    "R0-R7,PC"

delete_dynamicarea
; R2 is area to delete
        Push    "R0-R3,y0,y1,lr"
        MOV     y0,#0
        STRB    R1,recalc_extent
        LDR     R0,wlink
04
        CMP     R0,#-1
        Pull    "R0-R3,y0,y1,PC",EQ             ; whoops, we've no record of what the kernel is trying to delete
        LDRB    R14,[R0,#icb_icon1]
        CMP     R14,#ic_cdaname                 ; is it a dynamic area
        MOVNE   R3,R0
        LDRNE   R0,[R0,#icb_link]
        BNE     %BT04
        LDR     R14,[R0,#icb_taskage]           ; area number
        LDRB    y1,[R0,#icb_height]
        CMP     R14,R2
        MOVNE   R3,R0
        LDRNE   R0,[R0,#icb_link]
        SUBNE   y0,y0,y1
        BNE     %BT04
; R0 is area to delete, R3 is previous area, y0 and y1 are set up for delete row.
        MOV     R2,R0
        Push    "R0-R4"                         ; Force part of window to be redrawn
        LDR     R0,h_switcher
        MOV     R4,y0
        MOV     R1,#-bignum
        MOV     R3,#bignum
        MOV     R2,#-bignum
        SWI     XWimp_ForceRedraw
        Pull    "R0-R4"
        LDR     R0,[R2,#icb_link]
        STR     R0,[R3,#icb_link]               ; set previous icon to point to one after this.
        MOV     R0,#ModHandReason_Free
        SWI     XOS_Module
        BL      calc_extent
        Pull    "R0-R3,y0,y1,PC"

service_dynamicareacreate
        STRB    R1,recalc_extent
        Push    "R1,R8-R9,lr"
        MOV     R1,R2
        BL      find_dynamicarea
        BLEQ    create_dynamicarea
        Pull    "R1,R8-R9,PC"

service_dynamicarearenumber
        Push    "R1,R8-R9,lr"
        MOV     R1,R2
        BL      find_dynamicarea
        STR     R3,[R9,#icb_taskage]
        Pull    "R1,R8-R9,PC"

        ]

;;----------------------------------------------------------------------------
;; Debugging routines
;;----------------------------------------------------------------------------

      [ debug
        InsertNDRDebugRoutines
      ]

MyXWimp_Poll ENTRY "R0-R3"
        LDR     R14,dragBar
        CMP     R14,#0
        BLE     %FT05
        SWI     XWimp_Poll
        STMIA   sp,{R0,R1}
        EXITS
05
        CLRV
        SWI     XOS_ReadMonotonicTime
        ADDVC   R2,R0,#10                       ; poll 0.1 secs
        LDR     R0,[SP]
        BVS     %FT10
        SWI     XWimp_PollIdle
        STMIA   sp,{R0,R1}
        EXITS
10
        LDR     R0,[sp]
        SWI     XWimp_Poll
        STMIA   sp,{R0,R1}
        EXITS

        END
