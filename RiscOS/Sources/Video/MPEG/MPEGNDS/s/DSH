; >s.DSH
; Descriptor Handler
; Copyright © Pace Micro Technology plc, 2002
; All rights reserved.


; ******************************************************
; *
; * Register the descriptor handler for this stream.
; *
; * In...
; *   R11	= pointer to client block
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Register_DSH Entry "R1-R3"
	DAWriteS "RegDsH()", LF
	; Register...
	MOV	R0, #DESCRIPTOR_FLAGS
	MOV	R1, #DESCRIPTOR_TAG
	ADR	R2, DescriptorHandler
	MOV	R3, CL
	SWI	XMPEGControl_RegisterDescriptorHandler
	EXIT


; ******************************************************
; *
; * Deregister the descriptor handler for this client.
; *
; * In...
; *   R11	= pointer to client block
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Deregister_DSH Entry "R1-R3"
	DAWriteS "DeregDsH()", LF
	; Deregister...
	MOV	R0, #DESCRIPTOR_FLAGS
	MOV	R1, #DESCRIPTOR_TAG
	ADR	R2, DescriptorHandler
	MOV	R3, CL
	SWI	XMPEGControl_DeregisterDescriptorHandler
	EXIT


; ******************************************************
; *
; * Reset the buffers for the descriptor handler on this stream.
; *
; * In...
; *   R10	= pointer to stream block
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R14	= preserved
; *
Reset_DSH ROUT
	MOV	R0, #0
	STR	R0, [SB, #SB_DSH_Fetched]
 [ CA_INIT <> 0
	MOV	R0, #CA_INIT
 ]
	STR	R0, [SB, #SB_DSH_Remain]
	MOV	PC, LR


; ******************************************************
; *
; * Despatch the appropriate routine for this descriptor handler based upon the
; * reason code passed in R0. Try to do the most speed-critical things fastest.
; *
; * In...
; *   R0	= reason code
; *   R12	= CL block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R3	= depends upon R0 on entry
; *   R4-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescriptorHandler ROUT
	CMP	R0, #DHReason_DataTransfer
	BEQ	DescriptorHandler_DataTransfer
	BLO	DescriptorHandler_OpenStream
	CMP	R0, #DHReason_ResetStream
	BEQ	DescriptorHandler_ResetStream
	BLO	DescriptorHandler_CloseStream
	; Unknown reason codes do nothing.
	MOV	PC, LR


; ******************************************************
; *
; * DESCRIPTOR HANDLER - OPEN STREAM (REASON 0)
; *
; * In...
; *   R0	= reason code (0)
; *   R1	= stream flags (as passed to MPEGControl_OpenStream)
; *   R2	= control stream handle
; *   R12	= CL block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= descriptor stream handle - SB pointer (or pointer to error block)
; *   R1-R2	= corrupted
; *   R3-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescriptorHandler_OpenStream Entry "R3-R11"
	; Arrange registers in the order we want them...
	MOV	CL, R12			; CL (R11) = parent client block pointer
	LDR	WS, [CL, #CL_WS]	; WS (R12) = MPEGNDS module workspace pointer
	DAWriteS "DsH_OpenS()", LF
	; Create a stream block (SB) to store information from and about this stream...
	BL	Claim_SB
	BVS	%FT00
	; Initialise some stuff in the SB...
	STR	R2, [SB, #SB_CSH]
	BL	Reset_DSH
	; Call the client's OpenStream handler function...
	MOV	R0, #0
	MOV	R1, R2
	LDR	R4, [CL, #CL_OpenStream]
	BL	Call_Veneer
	STRVC	R0, [SB, #SB_Handle]
	; Return the SB pointer as our descriptor stream handle...
	MOVVC	R0, SB
00	; (or an error)...
	EXIT


; ******************************************************
; *
; * DESCRIPTOR HANDLER - DATA TRANSFER (REASON 1)
; *
; * In...
; *   R0	= reason code (1)
; *   R1	= flags (should be zero)
; *   R2	= SB pointer
; *   R3	= pointer to bitstream packet descriptor chain
; *   R12	= CL block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R3	= corrupted
; *   R4-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescriptorHandler_DataTransfer Entry "R4-R6, R10-R11"
	; Arrange registers in the order we want them...
	MOV	CL, R12			; CL (R11) = parent client block pointer
	LDR	WS, [CL, #CL_WS]	; WS (R12) = MPEGNDS module workspace pointer
	MOV	SB, R2			; SB (R10) = stream block pointer
	DAWriteS "DsH_Data()", LF

	;
	; Register usage...
	;   R0 = scratch
	;   R1 = number of bytes copied into our buffer
	;   R2 = pointer to bytes to copy in packet
	;   R3 = bitstream packet descriptor pointer
	;   R4 = number of bytes to copy from packet
	;   R5 = pointer to base of our buffer
	;   R6 = number of bytes left before we call the client
	;

	LDR	R1, [SB, #SB_DSH_Fetched]
	ADD	R5, SB, #SB_DSH_Buffer
00	; If this data is the start of the descriptor, reset our buffer...
	DAWriteS "  DsH:NewPacket", LF
	LDR	R0, [R3, #PacketDescriptor_Flags]
	TST	R0, #PacketDescriptorFlags_MPEGStart
	BLNE	Reset_DSH
	; Skip this CA descriptor if it had the wrong CA_system_ID...
	LDR	R6, [SB, #SB_DSH_Remain]
	CMP	R6, #CA_SKIP
	BEQ	%FT06
	DAWriteS "  DsH:NoSkip", LF
	; Copy the bytes from this packet into our buffer...
	LDR	R4, [R3, #PacketDescriptor_Length]
	LDR	R2, [R3, #PacketDescriptor_Start]
	TEQ	R4, #0
	BEQ	%FT06
	DAWriteS "  DsH:BCpy", LF
	LDRB	R0, [R2], #1
	CMP	R1, #6
	STRB	R0, [R5, R1]
	ADD	R1, R1, #1
	BHS	%FT01
	ADD	PC, PC, R1, LSL #2
	NOP
	B	%FT05
	B       %FT03	; We've got the number of bytes remaining
	B       %FT05
	B       %FT04	; We've got the CA_system ID
	B       %FT05
	; We've got the stream PID - register the PEH (if not done yet)...
	LDR	R0, [SB, #SB_Flags]
	TST	R0, #SB_Flags_PEH
	BNE	%FT01
	LDR	R0, [R5, #2]
	MOV	R0, R0, LSR #16
	BIC	R0, R0, #0xE000
	STR	R0, [SB, #SB_ECMPID]
	BL	Register_PEH

01	; Decrement our count of bytes left of the descriptor...
	SUBS	R6, R6, #1
	STR	R6, [SB, #SB_DSH_Remain]
	BNE	%FT05
	; If there are no more bytes for this descriptor, pass the data the client...
	SUBS	R0, R1, #6
	BEQ	%FT02		; No private_data_bytes - don't bother the client
	DAWriteS "  DsH:Call", LF
	Push	"R1-R4"
	LDR	R1, [SB, #SB_Handle]
	ADD	R2, R5, #6
	MOV	R3, R0
	LDR	R4, [CL, #CL_CADescriptor]
	MOV	R0, #0
	BL	Call_Veneer
	Pull	"R1-R4"
02	; Reset our buffer to empty...
	BL	Reset_DSH
	B	%FT05

03	; Store the number of bytes remaining for future reference...
	STR	R0, [SB, #SB_DSH_Remain]
	B	%FT05

04	; Compare the CA_system_ID against the client's to skip unwanted packets...
	LDR	R0, [R5, #2]
	LDR	R14, [CL, #CL_CASID]
	MOV	R0, R0, LSL #16
	TEQ	R0, R14, LSL #16
	MOVNE	R0, #CA_SKIP
	STRNE	R0, [SB, #SB_DSH_Remain]
	B	%FT05

05	; Move on to the next byte of the packet...
	SUBS	R4, R4, #1
	BNE	%BT00
06	; Move on to the next packet descriptor (if any)...
	LDR	R3, [R3, #PacketDescriptor_Link]
	TEQ	R3, #0
	BNE	%BT00
	; Store the bytes copied back into the SB...
	STR	R1, [SB, #SB_DSH_Fetched]
	DAWriteS "  DsH:Done", LF
	EXIT


; ******************************************************
; *
; * DESCRIPTOR HANDLER - CLOSE STREAM (REASON 2)
; *
; * In...
; *   R0	= reason code (2)
; *   R1	= flags (as passed to MPEGControl_CloseStream)
; *   R2	= SB pointer
; *   R12	= CL block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R2	= corrupted
; *   R3-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescriptorHandler_CloseStream Entry "R4, R10-R11"
	; Arrange registers in the order we want them...
	MOV	CL, R12			; CL (R11) = parent client block pointer
	LDR	WS, [CL, #CL_WS]	; WS (R12) = MPEGNDS module workspace pointer
	MOV	SB, R2			; SB (R10) = stream block pointer
	DAWriteS "DsH_Close()", LF
	; Call the client's CloseStream handler function...
	MOV	R0, #0
	LDR	R1, [SB, #SB_Handle]
	LDR	R4, [CL, #CL_CloseStream]
	BL	Call_Veneer
	; Free the stream block for this stream (also deregisters PEH and PDH, if any)...
	BLVC	Free_SB
	EXIT


; ******************************************************
; *
; * DESCRIPTOR HANDLER - RESET STREAM (REASON 3)
; *
; * In...
; *   R0	= reason code (3)
; *   R1	= flags (as passed to MPEGControl_ResetStream)
; *   R2	= SB pointer
; *   R12	= CL block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R2	= corrupted
; *   R3-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescriptorHandler_ResetStream Entry "R4, R10-R11"
	; Arrange registers in the order we want them...
	MOV	CL, R12			; CL (R11) = parent client block pointer
	LDR	WS, [CL, #CL_WS]	; WS (R12) = MPEGNDS module workspace pointer
	MOV	SB, R2			; SB (R10) = stream block pointer
	DAWriteS "DsH_Reset()", LF
	; Call the client's ResetStream handler function...
	MOV	R0, #0
	LDR	R1, [SB, #SB_Handle]
	LDR	R4, [CL, #CL_ResetStream]
	BL	Call_Veneer
	; Reset some of the buffers for this stream...
	BLVC	Reset_DSH
	; Exit (with possible error)...
	EXIT


	END
