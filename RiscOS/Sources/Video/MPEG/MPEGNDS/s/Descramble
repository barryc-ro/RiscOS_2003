; >s.Descramble
; Copyright © Pace Micro Technology plc, 2001
; All rights reserved.
;
; Descrambler handler specific code. MPEG NDS registers a descrambler handler
; with MPEGControl after it has passed one complete ECM payload to the client
; for processing. The handler is deregistered when the stream closes.


; ******************************************************
; *
; * Our payload descrambling handler entry point. Despatch to the appropriate
; * subroutine with the minimal amount of fuss.
; *
; * In...
; *   R0	= reason code (0..3)
; *   R12	= DSH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   Depends upon reason code
; *
DescramblingHandler ROUT
	CMP	R0, #PSHReason_DescramblePacket
	BEQ	DescramblingHandler_DataTransfer	; R0=1
	BLO	DescramblingHandler_OpenStream		; R0=0
	CMP	R0, #PSHReason_ResetStream
	BLO	DescramblingHandler_CloseStream		; R0=2
	; R0>=3...


; ******************************************************
; *
; * A ResetStream event has been detected for the stream which is being
; * processed by this descrambling handler. Throw-away and buffered TS packet
; * payload.
; *
; * In...
; *   R0	= reason code (3)
; *   R1	= reset stream flags (as for MPEGControl_ResetStream)
; *   R2	= PDH block pointer
; *   R12	= DSH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescramblingHandler_ResetStream Entry "R4, R9-R11"
	LDR	R11, [R12, #DSH_ClientBlock]
	MOV	R10, R12
	MOV	R9, R2
	LDR	R12, [R11, #CL_ModuleWorkspace]
	; R9  = PDH block pointer
	; R10 = DSH block pointer
	; R11 = client block pointer
	; R12 = module workspace pointer

	DAWriteS "  ResetStream", 10

	; Call the client's ResetStream handler function...
	MOV	R0, #0
	LDR	R1, [R10, #DSH_ClientHandle]
	LDR	R4, [R11, #CL_ResetStream]
	BL	Call_Veneer
	; Reset bitstream packet to be empty...
	BL	PDH_Reinit
	EXIT


; ******************************************************
; *
; * An OpenStream event has been detected for the stream which is being
; * processed by this descrambling handler. Create a block of useful info for
; * this stream. This will be passed in R2 in further calls to our descrambling
; * handlers
; *
; * In...
; *   R0	= reason code (0)
; *   R1	= stream flags (as for MPEGControl_OpenStream)
; *   R2	= control stream handle
; *   R12	= DSH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= PDH block pointer (or pointer to error block)
; *   R1	= corrupted
; *   R2-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescramblingHandler_OpenStream Entry "R2-R4, R9-R11"
	LDR	R11, [R12, #DSH_ClientBlock]
	MOV	R10, R12
	LDR	R12, [R11, #CL_ModuleWorkspace]
	; R10 = DSH block pointer
	; R11 = client block pointer
	; R12 = module workspace pointer

	DAWriteS "  OpenStream", 10

	; Store the control stream handle in the DSH block...
	STR	R2, [R10, #DSH_ControlStreamHandle]
	; Claim and initialise a PDH block for this stream...
	MOV	R3, #PDH_BLOCK_SIZE
	BL	Client_Claim
	BVS	PDHerr
	MOV	R9, R2
	BL	PDH_Initialise
	; Call the client's OpenStream handler function...
	MOV	R0, #0
	LDR	R1, [R10, #DSH_ControlStreamHandle]
	LDR	R4, [R11, #CL_OpenStream]
	BL	Call_Veneer
	; Store the client's handle for this stream in the DSH block...
	STR	R0, [R10, #DSH_ClientHandle]
	MOV	R0, R2
PDHerr	EXIT


; ******************************************************
; *
; * A CloseStream event has been detected for the stream which is being
; * processed by this descrambling handler. Deregister this handler and then
; * delink and free the PDH block.
; *
; * In...
; *   R0	= reason code (2)
; *   R1	= flags (unused)
; *   R2	= PDH block pointer
; *   R12	= DSH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R2	= corrupted
; *   R3-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescramblingHandler_CloseStream Entry "R3-R4, R9-R11"
	LDR	R11, [R12, #DSH_ClientBlock]
	MOV	R10, R12
	MOV	R9, R2
	LDR	R12, [R11, #CL_ModuleWorkspace]
	; R9  = PDH block pointer
	; R10 = DSH block pointer
	; R11 = client block pointer
	; R12 = module workspace pointer

	DAWriteS "  CloseStream", 10

;	; Deregister the payload descrambling handler...
;	MOV	R0, #DESCRAMBLER_FLAGS
;	ADR	R2, DescramblingHandler
;	MOV	R3, R10
;	LDR	R4, [R10, #DSH_ControlStreamHandle]
;	SWI	XMPEGControl_DeregisterPayloadDescramblingHandler	; Ignore errors
	; Call the client's CloseStream handler function...
	MOV	R0, #0
	LDR	R1, [R10, #DSH_ClientHandle]
	LDR	R4, [R11, #CL_CloseStream]
	BL	Call_Veneer
	; Delink and free the PDH block...
	MOV	R2, R9
	BL	Client_Free
	EXIT


; ******************************************************
; *
; * Some more TS packet payload has arrived. Copy it into our bitstream packet
; * and see if we have enough to call the client's descrambler code.
; *
; * In...
; *   R0	= reason code (1)
; *   R1	= flags (unused)
; *   R2	= PDH block pointer
; *   R3	= pointer to bitstream packet descriptor chain
; *   R8	= number of bytes remaining in transport stream packet
; *   R9	= transport_scrambling_control bit field
; *   R12	= DSH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R2	= corrupted
; *   R3	= zero if more chunks needed, else pointer to our descriptor
; *   R4-R11	= preserved
; *   R12	= corrupted
; *   R13	= preserved
; *   R14	= corrupted
; *
DescramblingHandler_DataTransfer Entry "R4-R5, R7-R11"
	MOV	R7, R9, LSR #6
	LDR	R11, [R12, #DSH_ClientBlock]
	MOV	R10, R12
	MOV	R9, R2
	LDR	R12, [R11, #CL_ModuleWorkspace]
	; R9  = PDH block pointer
	; R10 = DSH block pointer
	; R11 = client block pointer
	; R12 = module workspace pointer
	;

	DAWriteS "+"

	; Copy this chunk of the payload...
	LDR	R2, [R3, #PacketDescriptor_Length]
	LDR	R0, [R3, #PacketDescriptor_Start]
	LDR	R4, [R9, #PDH_Packet]
	ADD	R1, R4, #BITSTREAM_SIZE
	ADD	R5, R2, R8
	SUB	R1, R1, R5
	LDR	R14, [R9, #PDH_Flags]
	; If this is the first chunk, get our packet descriptor fully
	; initialised...
	TST	R14, #PDH_Flags_FirstChunk
	BEQ	%FT00
	BIC	R14, R14, #PDH_Flags_FirstChunk
	STR	R14, [R9, #PDH_Flags]
	LDR	R14, [R3, #PacketDescriptor_Flags]
	STR	R1, [R9, #PDH_First]
	STR	R14, [R4, #PacketDescriptor_Flags]
  [ PDH_TEST
	LDR	R14, [R3, #PacketDescriptor_PTS]
	STR	R14, [R4, #PacketDescriptor_PTS]
	LDR	R14, [R3, #PacketDescriptor_PTS+4]
	STR	R14, [R4, #PacketDescriptor_PTS+4]
	LDR	R14, [R3, #PacketDescriptor_DTS]
	STR	R14, [R4, #PacketDescriptor_DTS]
	LDR	R14, [R3, #PacketDescriptor_DTS+4]
	STR	R14, [R4, #PacketDescriptor_DTS+4]
	LDR	R14, [R3, #PacketDescriptor_FullLength]
	STR	R14, [R4, #PacketDescriptor_FullLength]
  ];PDH_TEST
	STR	R1, [R4, #PacketDescriptor_Start]
	STR	R5, [R4, #PacketDescriptor_Length]
00	BL	Safe_Copy
	; Call the free routine for this bitstream packet...
	MOV	R0, R3
	BL	Call_Bitstream_FreeRoutine
	; Have we got a complete TS packet payload (is R8=0)?
	TEQ	R8, #0
	MOVNE	R3, #0
	EXIT	NE

	DAWriteS "|", 10

	; Yes - pass the TS packet payload to the descrambler...
	LDR	R5, [R9, #PDH_Packet]
	LDR	R2, [R9, #PDH_First]
	ADD	R0, R5, #BITSTREAM_SIZE
	SUB	R3, R0, R2
	BIC	R3, R3, #15
	SUB	R2, R0, R3
	AND	R0, R7, #3
	LDR	R1, [R10, #DSH_ClientHandle]
	LDR	R4, [R11, #CL_Descrambler]
	;
	; R0 = flags
	; R1 = handle
	; R2 = pointer to block
	; R3 = size of block
	;
	BL	Call_Veneer
	; Set flag to indicate next fetch is first chunk...
	LDR	R14, [R9, #PDH_Flags]
	ORR	R14, R14, #PDH_Flags_FirstChunk
	STR	R14, [R9, #PDH_Flags]
	; If the previous packet was successfully descrambled, claim a new one
	; for the next payload to go into an pass the descrambled packet on to
	; the MPEG system. Otherwise, throw the (still scrambled) data away and
	; re-use the bitstream packet for the next payload...
	TEQ	R0, #0
	LDREQ	R2, [R9, #PDH_Packet]
	MOVEQ	R5, #0
	BLNE	Bitstream_Claim
	STR	R2, [R9, #PDH_Packet]
	; Return pointer to our descrambled bitstream packet in R3 (or zero if
	; we threw the data away)...
	MOV	R3, R5
	EXIT


; ******************************************************
; *
; * Initialise the PDH flags word and claim a bitstream packet for use by our
; * handler on this stream.
; *
; * In...
; *   R9	= PDH block pointer
; *   R12	= module workspace pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
PDH_Initialise Entry "R2"
	BL	PDH_Reinit
	BL	Bitstream_Claim
	STR	R2, [R9, #PDH_Packet]
	EXIT


; ******************************************************
; *
; * Reinitialise the flags word in our PDH block to indicate that our bitstream
; * packet has yet to contain any TS packet payload.
; *
; * In...
; *   R9	= PDH block pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R13	= preserved
; *   R14	= corrupted
; *
PDH_Reinit Entry
	LDR	R14, [R9, #PDH_Flags]
	ORR	R14, R14, #PDH_Flags_FirstChunk
	STR	R14, [R9, #PDH_Flags]
	EXIT


	END
