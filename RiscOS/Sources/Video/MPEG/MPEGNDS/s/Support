; >s.Support
; Copyright © Pace Micro Technology plc, 2001
; All rights reserved.
;
; Various support routines, mainly those routines which are common to more than
; one source file.


; ******************************************************
; *
; * Veneer for calling the C function pointed to by R4 on entry. Any parameters
; * to the function should be passed in R0-R3. On exit, R0 will contain the
; * result returned by the function (if any).
; *
; * In...
; *   R0-R3	= parameters to pass into C function
; *   R4	= pointer to C function to call
; *   R11	= pointer to client block
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= return value or corrupted
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Call_Veneer Entry "R1-R3, R10-R12"
	; Preserve whatever relocation modifiers are at the base of the SVC stack...
	MOV	sl, sp, LSR #20
	MOV	sl, sl, LSL #20
	LDMIA	sl, {r12, r14}
	Push	"r12, r14"
	; Load our client's relocation modifiers from our module workspace...
	ADD	r12, r11, #CL_RelocModifiers
	LDMIA	r12, {r12, r14}
	MOV	fp, #0
	; Store them at the base of the svc stack...
	STMIA	sl, {r12, r14}
	ADD	sl,sl,#|_Lib$Reloc$Off|
	; Branch (with link) into the client function...
	MOV	fp, #0
	MOV	lr, pc
	MOV	pc, R4
	; Restore the original relocation modifiers to the base of the SVC stack...
	Pull	"r11, r14"
	SUB	sl,sl,#|_Lib$Reloc$Off|
	STMIA	sl, {r11, r14}
	EXIT


; ******************************************************
; *
; * Free all of the client blocks in the client list. The list is reset to
; * empty. We don't bother to deregister any handlers for the client at this
; * point - it is assumed that they are already released.
; *
; * In...
; *   R12	= module workspace pointer
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0	= corrupted
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Free_All_Clients Entry "R1-R2"
	LDR	R2, [R12, #WS_ClientList]
	TEQ	R2, #0
	EXIT	EQ
00	LDR	R1, [R2, #CL_Next]
	MOV	R0, #ModHandReason_Free
	SWI	XOS_Module
	MOVS	R2, R1
	BNE	%BT00
	STR	R2, [R12, #WS_ClientList]
	EXIT


; ******************************************************
; *
; * Claim a block of memory and add it to the list of claimed blocks for this
; * registered client.
; *
; * In...
; *   R3	= size in bytes of block to claim
; *   R11	= pointer to client block
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1	= preserved
; *   R2	= pointer to claimed block
; *   R3-R13	= preserved
; *   R14	= corrupted
; *
Client_Claim Entry
	MOV	R0, #ModHandReason_Claim
	SWI	XOS_Module
	EXIT	VS
	LDR	R0, [R11, #CL_ClaimList]
	STR	R2, [R11, #CL_ClaimList]
	STR	R0, [R2, #4]			; Assumes word 4 is next ptr
	TEQ	R0, #0
	STRNE	R2, [R0, #0]			; Assumes word 0 is prev ptr
	MOV	R0, #0
	STR	R0, [R2, #0]			; Assumes word 0 is prev ptr
	EXIT


; ******************************************************
; *
; * Delink the specified block from the list of blocks claimed for the
; * specified client, then free that block.
; *
; * In...
; *   R2	= pointer to block to free
; *   R11	= pointer to client block
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Client_Free Entry "R2"
	LDR	R14, [R2, #4]			; Assumes word 4 is next ptr
	LDR	R0, [R2, #0]			; Assumes word 0 is prev ptr
	TEQ	R0, #0
	STREQ	R14, [R11, #CL_ClaimList]
	STRNE	R14, [R0, #4]			; Assumes word 4 is next ptr
	TEQ	R14, #0
	STRNE	R0, [R14, #0]			; Assumes word 0 is prev ptr
	MOV	R0, #ModHandReason_Free
	SWI	XOS_Module
	EXIT


; ******************************************************
; *
; * Pop the head bitstream packet from the free list. Claim a new one if the
; * free list is empty.
; *
; * In...
; *   R12	= module workspace pointer
; * Out...
; *   R0	= corrupted (or pointer to error block)
; *   R1	= preserved
; *   R2	= pointer to bitstream packet descriptor
; *   R3-R13	= preserved
; *   R14	= corrupted
; *
Bitstream_Claim Entry "R3"
	; Return head item if free list is not empty...
	SCPSR	I_bit, 0, R14,, R3
	LDR	R2, [R12, #WS_FreeList]
	TEQ	R2, #0
	BEQ	%FT00
	LDR	R0, [R2, #PacketDescriptor_Link]
	STR	R0, [R12, #WS_FreeList]
	RestPSR	R3
	MOV	R0, #0
	STR	R0, [R2, #PacketDescriptor_Link]
	EXIT
00	; Otherwise, claim and initialise a block of RMA...
	RestPSR	R3
	MOV	R0, #ModHandReason_Claim
	MOV	R3, #BITSTREAM_SIZE
	SWI	XOS_Module
	EXIT	VS
	;
	; It is assumed that the block returned lies four bytes beyond a quad-
	; word boundary.
	;
	; Initialise the descriptor for this bitstream buffer...
	MOV	R0, #0
	STR	R0, [R2, #PacketDescriptor_Link]
	ADR	R0, Bitstream_Free
	STR	R0, [R2, #PacketDescriptor_FreeRoutine]
	STR	R12, [R2, #PacketDescriptor_FreeWorkspace]
	ADD	R0, R2, #BITSTREAM_HDR_SIZE
	STR	R0, [R2, #PacketDescriptor_Start]
	;
	; 0..3	PacketDescriptor_Link			next pointer when in free list
	; 4..7	PacketDescriptor_FreeRoutine		pointer to free routine
	; 8..11	PacketDescriptor_FreeWorkspace		pointer to free routine's workspace
	;12..15	PacketDescriptor_Start			pointer to start of buffer
	;16..19	PacketDescriptor_Length			length of data in buffer
	;20..23	PacketDescriptor_BufferDescriptor	undefined
	;24..27	PacketDescriptor_Flags			flags word
	;
	EXIT


; ******************************************************
; *
; * Add the specified bitstream packets to the free list for our module.
; *
; * In...
; *   R0	= bitstream buffer descriptor pointer
; * Out...
; *   R0	= corrupted
; *   R1-R13	= preserved
; *   R14	= corrupted
; *
Bitstream_Free Entry "R1, R11-R12"
	SCPSR	I_bit, 0, R14,, R11
00	LDR	R14, [R0, #PacketDescriptor_Link]
	LDR	R1, [R12, #WS_FreeList]
	STR	R0, [R12, #WS_FreeList]
	STR	R1, [R0, #PacketDescriptor_Link]
	MOVS	R0, R14
	BNE	%BT00
	RestPSR	R11
	EXIT


; ******************************************************
; *
; * Free all of the bitstream packets which are in the free list back into the
; * RMA. Store zero as the free list head pointer to indicate that there are no
; * packets available.
; *
; * In...
; *   R12	= module workspace pointer
; * Out...
; *   R0-R13	= preserved
; *   R14	= corrupted
; *
Release_Free_List Entry "R0-R2"
	LDR	R2, [R12, #WS_FreeList]
	TEQ	R2, #0
	EXIT	EQ
	MOV	R0, #ModHandReason_Free
00	LDR	R1, [R2, #PacketDescriptor_Link]
	SWI	XOS_Module
	MOVS	R2, R1
	BNE	%BT00
	STR	R2, [R12, #WS_FreeList]
	EXIT


; ******************************************************
; *
; * Call the free routine for the owner of the specified bitstream packet. This
; * is used in the case when we are freeing a bitstream packet, rather than
; * letting some other part of the MPEG system (i.e. for a packet which we have
; * swallowed).
; *
; * In...
; *   R0	= pointer to bitstream packet descriptor chain
; * Out...
; *   R0	= zero
; *   R1-R14	= preserved
; *
Call_Bitstream_FreeRoutine Entry "R1, R12"
	MOV	R12, #0
00	LDR	R1, [R0, #PacketDescriptor_Link]
	STR	R12, [R0, #PacketDescriptor_Link]
;	LDR	R12, [R0, #PacketDescriptor_FreeWorkspace] <- callee does this!!
	MOV	LR, PC
	LDR	PC, [R0, #PacketDescriptor_FreeRoutine]
	MOVS	R0, R1
	BNE	%BT00
	EXIT


; ******************************************************
; *
; * Call the block_copy routine and preserve all registers (other than LR).
; *
; * In...
; *   R0	= pointer to base of source block
; *   R1	= pointer to base of destination block
; *   R2	= number of bytes to copy
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R13	= preserved
; *   R14	= corrupted
; *
Safe_Copy Entry	 "R0-R5"
	BL	 Block_Copy
	EXIT


; ******************************************************
; *
; * Copy bytes from one location to another. These blocks are not allowed to
; * overlap. The size of the block to copy can be from 0 to 0x7FFFFFFF bytes.
; *
; * The alignment of the source and destination can be any byte boundary. If
; * the two blocks are at the same byte alignment, and the block to copy is
; * sufficiently large, we perform a fast copy using four word LDM/STM pairs.
; *
; * If it's a small block (i.e. smaller than 16 bytes), we do a very simple
; * byte load/store copy loop.
; *
; * For larger blocks where the source and destination pointers are not
; * co-aligned, we do a copy loop using a non-word-aligned load and a
; * word-aligned store.
; *
; * In...
; *   R0	= pointer to base of source block
; *   R1	= pointer to base of destination block
; *   R2	= number of bytes to copy
; *   R13	= full-descending stack pointer
; *   R14	= return address
; * Out...
; *   R0-R1	= corrupted
; *   R2	= zero
; *   R3-R5	= corrupted
; *   R6-R13	= preserved
; *   R14	= corrupted
; *
Block_Copy ROUT
	; Early exit if there are no bytes to copy...
	CMP	R2, #0
	MOVLE	PC, LR
	; Are there enough bytes to copy to warrent the heavy-duty routine?
	CMP	R2, #16
	BLO	%FT09
	; Early exit if start and end pointers are the same
	EORS	R4, R0, R1
	MOVEQ	PC, LR
	;
	; *** PUSH LR ONTO STACK ***
	;
	Entry
	; Are both pointers at the same byte alignment?
	ANDS	R4, R4, #2_11
	BEQ	%FT06
	; We've got more than a few bytes to copy and the source and destination
	; pointers are not at the same byte alignment. So we'll word-align the
	; destination pointer first, dump any trailing bytes at the end of the
	; block to copy (leaving only whole words of the destination block). We
	; can then do the rest of the copy with word loads and stores and some
	; register shuffling.
	ANDS	R4, R1, #2_11
	BEQ	%FT00
	; Get the destination pointer up to a word boundary...
	CMP	R4, #2_10
	LDRB	R3,  [R0], #1
	LDRLSB	R5,  [R0], #1
	LDRLOB	R14, [R0], #1
	STRB	R3,  [R1], #1
	STRLSB	R5,  [R1], #1
	STRLOB	R14, [R1], #1
	RSB	R4, R4, #4
	SUB	R2, R2, R4
00	; Get the number of bytes to copy down to a whole number of words...
	ANDS	R3, R2, #2_11
	BEQ	%FT01
	BIC	R2, R2, #2_11
	ADD	R5, R0, R2
	ADD	R14, R1, R2
	CMP	R3, #2_10
	LDRB	R3, [R5]
	LDRHSB	R4, [R5, #1]
	LDRHIB	R5, [R5, #2]
	STRB	R3, [R14]
	STRHSB	R4, [R14, #1]
	STRHIB	R5, [R14, #2]
01	; Load the first (non-word-aligned) word of the source...
	AND	R3, R0, #2_11
	LDR	R4, [R0], #4
	CMP	R3, #2_10
	BHI	%FT05
	BEQ	%FT03
02	; When dest ptr is word-aligned, src ptr is at word + 1 byte...
	BIC	R5, R4, #&FF000000
	LDR	R4, [R0], #4	; Unaligned load
	SUBS	R2, R2, #4
	AND	R3, R4, #&FF000000
	ORR	R3, R3, R5
	STR	R3, [R1], #4	; Word-aligned store
	BNE	%BT02
	EXIT
03	; When dest ptr is word-aligned, src ptr is at word + 2 bytes...
	MOV	R14, #&FF00
	ORR	R14, R14, #&00FF
04	AND	R5, R4, R14
	LDR	R4, [R0], #4	; Unaligned load
	SUBS	R2, R2, #4
	BIC	R3, R4, R14
	ORR	R3, R3, R5
	STR	R3, [R1], #4	; Word-aligned store
	BNE	%BT04
	EXIT
05	; When dest ptr is word-aligned, src ptr is at word + 3 bytes...
	AND	R5, R4, #&000000FF
	LDR	R4, [R0], #4	; Unaligned load
	SUBS	R2, R2, #4
	BIC	R3, R4, #&000000FF
	ORR	R3, R3, R5
	STR	R3, [R1], #4	; Word-aligned store
	BNE	%BT05
	EXIT
06	; The source and destination pointers are at the same alignment.
	; Get both of the base addresses up to a word boundary...
	ANDS	R4, R0, #2_11
	BEQ	%FT07
	CMP	R4, #2_10
	LDRB	R3,  [R0], #1
	LDRLSB	R5,  [R0], #1
	LDRLOB	R14, [R0], #1
	STRB	R3,  [R1], #1
	STRLSB	R5,  [R1], #1
	STRLOB	R14, [R1], #1
	RSB	R4, R4, #4
	SUB	R2, R2, R4
07	; Copy any bytes at the end of the block so we're left with word
	; copies...
	ANDS	R3, R2, #2_11
	BEQ	%FT08
	BIC	R2, R2, #2_11
	ADD	R5, R0, R2
	ADD	R14, R1, R2
	CMP	R3, #2_10
	LDRB	R3, [R5]
	LDRHSB	R4, [R5, #1]
	LDRHIB	R5, [R5, #2]
	STRB	R3, [R14]
	STRHSB	R4, [R14, #1]
	STRHIB	R5, [R14, #2]
08	; The source and destination pointers are both on a word boundary and
	; any trailing bytes at the end of the block to copy have been copied.
	; This leaves a simple block of word copies. Keep copying quad-word
	; blocks until there are less than 16 bytes remaining...
	CMP	R2, #16
	ADDLO	PC, PC, R2, LSL #2
	; Copy four words and loop (or exit if finished)...
	LDMIA	R0 !, {R3-R5, R14}
	SUBS	R2, R2, #16
	STMIA	R1 !, {R3-R5, R14}
	BNE	%BT08
	EXIT
	; Copy the last word and exit...
	LDR	R3, [R0], #4
	Pull	"LR"
	STR	R3, [R1], #4
	MOV	PC, LR
	; Copy the last two words and exit...
	LDMIA	R0 !, {R2, R5}
	STMIA	R1 !, {R2, R5}
	EXIT
	DCI	0
	; Copy the last three words and exit...
	LDMIA	R0 !, {R3-R5}
	STMIA	R1 !, {R3-R5}
	EXIT
	DCI	0
09	; Simple byte copy for when source and destination blocks are at a
	; different byte alignment and the number of bytes to copy is fairly
	; small. Simple byte load, byte store loop.
	LDRB	R4, [R0], #1
	SUBS	R2, R2, #1
	STRB	R4, [R1], #1
	BNE	%BT09
	MOV	PC, LR


BadSWI_Err Entry
	ADR	R0, BadSWI_ErrBlk
	MOV	R1, #0
	MOV	R2, #0
	ADRL	R4, Mod_Title
	SWI	XMessageTrans_ErrorLookup
	SETV
	EXIT
BadSWI_ErrBlk
	DCD	0x1E6
	DCB	"BadSWI", 0
	ALIGN


Reg_Err	ADR	R0, Reg_ErrBlk
	SETV
	Pull	"R1-R11, PC"
Reg_ErrBlk
	DCD	ErrBase + 0
	DCB	"MPEG NDS already has registered client functions. "
	DCB	"Deregister them first.", 0
	ALIGN


Dereg_Err
	ADR	R0, Dereg_ErrBlk
	SETV
	Pull	"R1-R11, PC"
Dereg_ErrBlk
	DCD	ErrBase + 1
	DCB	"No client functions have been registered with MPEG NDS.", 0
	ALIGN


	END
