; > Module
; Source for MPEG 2 Video Module

; ***********************************
; ***	 C h a n g e   L i s t	  ***
; ***********************************

; Date	     Who  Version	Description
; ----	     ---  -------	-----------
; 17-May-94  TMD  0.01		Started work
; 03-Jun-94  TMD  0.02		Variable transparency now possible in 16bpp
; 08-Jun-94  TMD  0.03		Added SWI MPEGVideo_CardControl
; 13-Jun-94  TMD  0.04		Added bodge for audio IRQ booboo
; 24-Jun-94  TMD  0.05		Started putting synchronisation stuff in
; 07-Jul-94  TMD  0.06		New stuffing strategy implemented - stuff on a callback from TickerV
; 18-Jul-94  TMD  0.10		Release for Malcolm's trip
; 22-Jul-94  TMD  0.11		Added SyncOffset command
; 29-Jul-94  TMD  0.13		Modified CloseStream behaviour to wait until empty unless paused, in which case junk data
; 17-Aug-94  TMD  0.14		Made transition from pause or slomo to normal set the SCR to the last received PTS
;				 before sending Play command.
; 18-Aug-94  TMD  0.15		Added MPEGVideo_ReadParameters (Read time code)
; 19-Aug-94  TMD  0.16		Started putting in skip to GOP or sequence header stuff (incomplete)
; 22-Aug-94  TMD  0.17		On close, if still in initial pause state, then send Play command.
; 22-Aug-94  TMD  0.18		(Conditionally) enable IRQs inside TickerV during foreground stuffing.
; 26-Aug-94  TMD  0.19		Only enable IRQs in TickerV if not doing AudioIRQBodge.
; 31-Aug-94  TMD  0.20		(Conditionally) select fast (type C) podule access.
; 31-Aug-94  TMD  0.21		Added support for directly calling SetSCR.
; 01-Sep-94  TMD  0.22		Added code to time completion of previous command.
; 05-Sep-94  TMD  0.23		(Conditionally) throw away PTSs if they are within a range of the last one sent.
; 08-Sep-94  TMD  0.24		Pass flags to MPEGControl_Play
; 08-Sep-94  TMD  0.25		Started to add MPEG still capability
; 09-Sep-94  TMD  0.26		(Conditionally) throw away SCRs if they are within a range of the last one sent.
; 09-Sep-94  TMD  0.27		(Conditionally) check packets for more than one picture_start code
; 12-Sep-94  TMD  0.28		Added reason code 2 (Update Control register) to MPEGVideo_CardControl
;				Check existence of system variable 'TVOn' to determine whether to enable CTRL0, CTRL1 on init
; 10-Oct-94  TMD  0.29		If waiting for stream to close, don't stop sending an incomplete packet in order to check it.
; 12-Oct-94  TMD  0.30		Don't print warning message on zero-length packets
; 20-Oct-94  TMD  0.31		Fixed stack-imbalance in MyAudioIRQRoutine
; 07-Nov-94  TMD  0.32		Remember speed setting if received while pre-buffering
; 07-Nov-94  TMD  0.33		When we start playing, set the SCR to the last received PTS value, so -noaudio works from
;				 middle of file
; 16-Nov-94  TMD  0.34		Changes to support MPEG 2 indeterminate-length packets.
; 05-Dec-94  TMD  0.35		Reverse length correction for odd-length packets
; 07-Dec-94  TMD  0.36		Start putting in skipping until GOP or sequence_header by blanking display
;				 until we get the appropriate IRQ from CL450
; 12-Dec-94  TMD  0.37		Separate out the options for SEQ, GOP or PIC skipping.
; 14-Dec-94  TMD  0.38		Created 'M' variant for CC/Wild Vision Movie Magic card.
; 14-Dec-94  TMD  0.39		Added 'NoInterlace' bit to video flags
; 15-Dec-94  TMD  0.40		Fixed accidental V set returning when pausing while pre-buffering.
;				Fixed CloseStream hanging if we aborted while pre-buffering.
; 15-Dec-94  TMD  0.41		Always enable PIC-V IRQ but don't unblank on it unless the appropriate bit
;				is set in VideoStructure_Flags. This is because SEQ-V and GOP IRQs seem to be
;				inhibited on certain clips if PIC-V is not also enabled.
; 17-Feb-95  TMD  0.42		Change product-type matching code for recognition of podule:
;				 No longer match &0000 in any version
;				 Do allow &00F9 in all versions (as well as &00FF in non-'M' versions)
; 06-Mar-95  TMD  0.43		Added MPEGVideo_ResetStream (initial implementation)
; 16-Mar-95  TMD  0.44		Fixed bug which cleared -nocls and -nopalettechange flags if skipping to pic,seq, or gop
; 28-Apr-95  TMD  2.00		MPEG 2 L64002 version, adapted from MPEG 1 CL450 version
; 25-Jan-96  TMD  2.01		New version for Rev.C chip
; 11-Sep-96  TMD  2.02		Make modulator boost bit reflect CTRL1
; 11-Sep-96  TMD  2.03		Check product type at run time to determine whether to program Japanese DACs or not
; 18-Oct-96  TMD  2.04		Provide MPEGVideo_ReadParameters(5) to check if display ready
; 19-Nov-96  TMD  2.05		Put in MPEGVideo/Audio_ResetStream that does a full reset of L64002.
; 20-Nov-96  TMD  2.06		Put in stuff that clears frame buffers in DRAM to black explicitly.
; 21-Nov-96  TMD  2.07		Put back SAA7167 stuff, executed only if cardtype is not STB2_MPEG2 or STB1_MPEG2.
; 27-Nov-96  TMD  2.08		Put in stuff to cope with crappy fast files.
; 28-Nov-96  TMD  2.09		Put in code to allow proper synchronisation on video-only I-frame-only movies.
; 02-Dec-96  TMD  2.10		Count video packets in order to know if we've received a whole picture to decode yet.
; 14-Jan-97  TMD  2.11		Revert to AllowSyncOnIFrames, rather than counting packets, since pictures can be bigger
;				 than one packet.
; 11-Feb-97  TMD  2.12		Add debugging for bottom-field-first movies.
; 12-Feb-97  TMD  2.13		Modify palette programming to be suitable for non-Macrovision 16bpp use
; 14-Feb-97  TMD  2.14		Wait for 3 sequence headers + 4 fields before unblanking, as a test
; 14-Feb-97  TMD  2.15		Added MPEGVideo_ReadParameters(4) implementation - read video buffer fullness
; 14-Feb-97  TMD  2.16		Added programmable number of sequence headers + fields to wait for before unblanking
; 10-Mar-97  TMD  2.17		Added code to count video channel underruns, but it doesn't work yet!
; 11-Mar-97  TMD  2.18		Do freeze field on pause.
; 11-Mar-97  TMD  2.19		Added MPEGAudio_MuteSound.
; 13-Mar-97  TMD  2.20		Keep record of whether we received a sequence header or picture header first after reset.
; 02-Apr-97  TMD  2.21		On init, set ModulatorBoost bit as well as CTRL0/1 if TVOn variable set.
; 14-Apr-97  TMD  2.22		Another attempt to get CountUnderruns to work (at least 0 or non-zero).
; 15-Apr-97  TMD  2.23		Put in Stats SWI.
; 18-Apr-97  TMD  2.24		Added record of first packet received (including PTS) after a resetstream.
;				Keep record of last and cumulative ErrorStatus bytes.
; 21-Apr-97  TMD  2.25		Added in statistic for time of 1st vid recon error after last video reset.
; 22-Apr-97  TMD  2.26		Added option to capture first packet sent to FIFO by FIQ code.
; 23-Apr-97  TMD  2.27		Preserve audio mute status over ResetStream.
; 24-Apr-97  TMD  2.28		(Conditionally) Only enable IRQs in VideoTickerVCallBack if actually called from callback,
;				 rather than direct on TickerV.
; 29-Apr-97  TMD  2.29		Drive ModulatorBoost from CTRL0, not CTRL1, so still enabled in Macrovision mode.
; 28-May-97  TMD  2.30		Program border colour to only set ED[0], to be suitable for non-Macrovision use.
; 05-Jun-97  TMD  2.31		Attempt to protect against electric surges by holding reset active for 10ms
; 21-Aug-97  TMD  2.32		Remove surge protection, make it wait for vsync before resetting L64002.
; 29-Oct-97  TMD  2.33		(Conditionally) Added commands for access to registers.
; 03-Nov-97  TMD  2.34		Started stuff for trick play mode support (incomplete so disabled).
; 05-Nov-97  TMD  2.35		Disable IRQs in AudioMuteSound, AudioSendPlay, AudioSendPause, AudioPlayFastFrame,
;				 AudioPlaySlowFrame around access to banked registers.
; 07-Nov-97  TMD  2.36		Enable trick play support
; 10-Nov-97  TMD  2.37		Fix CheckErrorStatus so it saves lr_svc around the SWI call.
; 10-Nov-97  TMD  2.38		Remove TrickPlay stuff so above fix can be tested.
; 11-Nov-97  TMD  2.39		Put TrickPlay back in again.
; 11-Nov-97  TMD  2.40		Use correct TrickPlay code!
; 14-Nov-97  TMD  2.41		Only enable trick play fixes when trick play mode is indicated, and structure flags enable them.
; 14-Nov-97  TMD  2.42		Don't check for incomplete PES packet if not doing trickplay packet length fix
; 20-Nov-97  TMD  2.43		Fix setting of TrickPlay variable in VideoResetStream.
; 20-Nov-97  TMD  2.44		(Conditionally) only do underrun fix on odd fields.
; 20-Nov-97  TMD  2.45		(Conditionally) freeze field if stopping the decoder to prevent underruns.
; 21-Nov-97  TMD  2.46		Zero TrickStopFreeze on ResetStream as well as OpenStream
; 08-Jan-98  TMD  2.47		Attempt to cope with QSIF images (well at least don't scale horiz to fill screen)
; 16-Jan-98  TMD  2.48		(Conditionally) attempt to fix audio squawk problem.
; 16-Jan-98  TMD  2.49		Fix bug in system buffer parsing of MPEG2 PES packet, revealed by above fix.
; 10-Feb-98  TMD  2.50		On real STB2200, use video structure flags to choose PAL or NTSC.
; 11-Feb-98  TMD  2.51		Re-register program element handlers on Service_MPEGControlStarting.
;

	LEADR	Module_LoadAddr

TAB	*	9
LF	*	10
FF	*	12
CR	*	13

ControlRegisterSoftCopy * &1584

VIDC	*	&03500000

MPEG_sequence_header_code	*	&B3
MPEG_group_start_code		*	&B8

L64002_Registers_Ptr	RN	11	; use R11 to point to L64002 registers
DRAMControlSoftCopy	*	&D0	; used for DRAMRead macro

	GBLL	NYI
NYI	SETL	{FALSE}			; flags to use for bits that are not yet implemented

	GBLL	DoPEH
DoPEH	SETL	{TRUE}			; register program element handler

	GBLL	ClearFrameBuffers
ClearFrameBuffers SETL {TRUE}		; clear frame buffers to black on init

	GBLL	CountFieldInversions
CountFieldInversions SETL {FALSE}	; count number of fields where Bottom/Top != Even/Odd

	GBLL	PerformFieldInversion
PerformFieldInversion SETL {FALSE}	; allow field inversion (DEBUG ONLY)

	GBLL	ProgrammableBlanking
ProgrammableBlanking SETL {TRUE}	; wait for programmable number of sequence headers + fields before unblanking

	GBLL	CountUnderruns
CountUnderruns SETL {TRUE}		; count video channel underruns

	GBLL	Save1stFullPacket
Save1stFullPacket SETL {FALSE}		; save 1st packet after open/reset, including PTS

	GBLL	Save1stFIQPacket
Save1stFIQPacket SETL {FALSE}		; save 1st packet sent to video FIFO from FIQ routine

	GBLL	PreserveIRQStateInTickerVStuffing
PreserveIRQStateInTickerVStuffing SETL {FALSE}	; if true, don't enable IRQs if stuffing directly from TickerV

	ASSERT	:LNOT: (Save1stFullPacket :LAND: Save1stFIQPacket)	; can't have both

	GBLL	SaveAPacket
SaveAPacket SETL Save1stFullPacket :LOR: Save1stFIQPacket

	GBLL	HoldResetFor10ms
HoldResetFor10ms	SETL	{FALSE}	; try holding reset low for 10ms to protect against electric surge

	GBLL	RegDebug
RegDebug SETL	{TRUE}			; allow L64002 register access thru *-commands

	GBLL	NobbleL64002VideoPacketLengths ; set video packet lengths to zero as written to L64002
NobbleL64002VideoPacketLengths SETL {FALSE}

	GBLL	FudgeZeroLengthPackets	; whether to always fudge zero length packets
FudgeZeroLengthPackets SETL {FALSE}	; only do it during trick play

	GBLL	TrickPlaySupport
TrickPlaySupport SETL {TRUE}		; enable checking for conditional support for trick play

	GBLL	UnderrunFixOnlyOnOddFields
UnderrunFixOnlyOnOddFields SETL {TRUE}	; try this cos we only want to do freeze field on odd fields too

	GBLL	FreezeFieldOnTrickStop
FreezeFieldOnTrickStop	SETL	{TRUE}	; freeze field at the same time as stopping the decoder for underrun fix

	GBLL	FudgeQSIF
FudgeQSIF SETL	{TRUE}			; if image is SIF or lower resolution, scale to 2 x xres horizontally

	GBLL	AudioSquawkFix1		; attempt to fix audio squawk problem by padding video packet headers to a
AudioSquawkFix1 SETL {TRUE}		; multiple of 8 bytes.

	GBLL	AudioSquawkFix2		; attempt to fix audio squawk problem by padding audio packet headers to a
AudioSquawkFix2 SETL {FALSE}		; multiple of 8 bytes.

; Structure of a PTS list entry

			^	0
PTSList_PTS		#	4	; bits 31..0 of PTS
PTSList_AddressPointer	#	4	; bit 0 = bit 32 of PTS, bits 10..31 = address pointer (in units of 8 bytes)
PTSListSize		*	@

VideoPTSListEntries	*	256	; for now
AudioPTSListEntries	*	256	; for now

MaxPTSError		*	3600	; at 25 frames/second, this is 1 frame

; Picture coding types

PictureCodingType_I	*	1
PictureCodingType_P	*	2
PictureCodingType_B	*	3

; Picture rate indices

PictureRate_23976	*	1
PictureRate_24000	*	2
PictureRate_25000	*	3
PictureRate_29970	*	4
PictureRate_30000	*	5
PictureRate_50000	*	6
PictureRate_59994	*	7
PictureRate_60000	*	8

; Structure of a streaminfo structure (one for audio and one for video)

			^	0
SI_ChannelBufferStart	#	4	; L64002 byte address of start of channel buffer
SI_ChannelBufferEnd	#	4	; L64002 byte address of end+1 of channel buffer
SI_PTSListPtr		#	4	; Address of corresponding PTS List
SI_PTSListReadPtr	#	4	; read pointer for list, in range 0..PTSListEntries-1
SI_PTSListWritePtr	#	4	; write pointer for same
SI_PTSListSize		#	4	; size of this PTS List
SI_PTSListOverruns	#	4	; number of overruns of PTS list
SI_SISPtr		#	4	; pointer to appropriate SIS structure
SISize			*	@

; Structure of a streaminfo system structure

			^	0
SIS_SystemBufferStart	#	4	; L64002 byte address of start of system buffer
SIS_SystemBufferEnd	#	4	; L64002 byte address of end+1 of system buffer
SIS_SystemBufferReadPtr	#	4	; L64002 byte address of where we've read to in system buffer
SIS_SystemBufferWritePtr #	4	; Last known value of SystemBufferWritePtr (in bytes)
SIS_DuffChannelAddresses #	4	; count of how many duff channel addresses found in system buffer
SIS_DuffSystemContents	#	4	; count of how many times we got rubbish in the system buffer
SIS_AddressOfLastDuff	#	4	; DRAM address where last rubbish in system buffer appeared
SIS_SystemUnderruns	#	4	; number of underruns of system buffer
SIS_SystemWrite0Group	#	4	; L64002 register group for system write ptr 0
SIS_SystemWrite0Reg	#	4	; L64002 register within group for system write ptr 0
SISSize			*	@

; Workspace declarations

			^	0, wp

; Variables valid outside of open stream

Podule_Base		#	4	; address of base of podule
Podule_ControlStatus1	#	4	; address of podule control/status 1 register
Podule_ControlStatus2	#	4	; address of podule control/status 2 register
L64002_Registers	#	4	; base address of L64002 registers
L64002_Audio_Data_Write #	4	; audio data write address
L64002_Video_Data_Write #	4	; direct writing of video data (not using FIFO)
FIFO_8_Bit_Write	#	4	; 8 bit FIFO writes
FIFO_16_Bit_Write	#	4	; 16 bit FIFO writes
FIFO_32_Bit_Write	#	4	; 32 bit FIFO writes

PoduleControlSoftCopy	#	4	; soft copy of combined control registers 1 (bits 0..7) and 2 (bits 8..15)
PoduleHeaderBuffer	#	16	; used to read podule headers
SyncOffset		#	4	; amount to add to clock values
CommonInterruptVectorsClaimed #	4	; NZ => interrupt vectors common to audio + video claimed
VideoInterruptVectorsClaimed #	4	; NZ => video interrupt vectors claimed
AudioInterruptVectorsClaimed #	4	; NZ => audio interrupt vectors claimed
VideoCallBackRequested	#	4	; whether a callback is outstanding
AudioCallBackRequested	#	4	; whether a callback is outstanding

VideoControlStreamHandle #	4	; control stream handle passed in to MPEGVideo_OpenStream
AudioControlStreamHandle #	4	; control stream handle passed in to MPEGAudio_OpenStream


; Variables only valid while stream open: general

IRQCounts		#	16*4	; counts of each type of IRQ we've had
Status0SoftCopy		#	4	; soft copy of status 0 register
SCROffset		#	8	; offset to add to H/W SCR to get current S/W SCR

; Variables only valid while stream open: video

VideoPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
VideoPacketListTailPtr	#	4	; pointer to tail of list
VideoChannelBufferSize	#	4	; size of video channel buffer, in bytes
VideoVBVSize		#	4	; size of video needed before unpausing
VideoInfoStructure	#	SISize
VideoSystemInfoStructure #	SISSize

BorderLeft		#	4	; left hand border
BorderTop		#	4	; top border

UnknownLengthPacket	#	4	; points to 1st packet in chain forming an indeterminate length packet, or zero if none
					; (only allowed in video stream, fortunately)

VideoAmountReceived	#	4	; amount of video data received
VideoPreFilling		#	4	; NZ => pre-filling
VideoStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
VideoStreamFlags	#	4	; stream flags
VideoSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
VideoLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
VideoNumberOfPTSs	#	4	; number of PTSs sent
VideoAmountQueued	#	4	; amount passed to background FIQ process
VideoPTSInCount		#	4	; number of video PTSs received from MPEGControl
DecodedFieldCount	#	4	; -1 when inactive or decoder not yet started, else number of fields after decoder start
					; until we've unblanked, then -2
FIQSlotWritePtr		#	4	; address within FIQSlotSpace to write next (address,length) pair to
VideoPostedPTS		#	8	; PTS posted for comparison on start of next odd field
VideoNumberOfPostedPTSs	#	4	; number of video PTSs posted for comparison
VideoSkips		#	4	; number of skipped frames
VideoRepeats		#	4	; number of repeated frames
VideoPTSPictureTypeCounts #	0	; counts of number of PTSs on I, P and B type pictures
			#	4	; dummy entry for type 0
VideoPTSPictureTypeCount_I #	4	; number of PTSs on I-pictures
VideoPTSPictureTypeCount_P #	4	; number of PTSs on P-pictures
VideoPTSPictureTypeCount_B #	4	; number of PTSs on B-pictures
VideoMinPTSDifference	#	4	; worst negative difference between PTS and SCR
VideoMaxPTSDifference	#	4	; worst positive difference between PTS and SCR
LastVideoPTSErrorSign	#	4	; SGN(last PTS-SCR) ie 0,-1 or 1; we only skip or repeat if 2 contiguous errors of same sign
PendingFreezeState	#	4	; 1 => should be frozen, 0 => should be unfrozen
FreezeUpdate		#	4	; 1 => freeze state has been updated
 [ FreezeFieldOnTrickStop
TrickStopFreeze		#	4	; additional freeze flag for trick play, OR'd with PendingFreezeState
 ]
FirstItemReceived	#	4	; 0 => not received anything since last reset, 1 => sequence, 2 => picture
 [ CountUnderruns
VideoChannelUnderruns	#	4	; number of video channel underruns
UnderrunIRQState	#	4	; 0 => still waiting to start
					; 1 => on next active field enable the underrun IRQ
					; 2 => already enabled it once
 ]

; Variables only valid while stream open: audio

AudioPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
AudioPacketListTailPtr	#	4	; pointer to tail of list
AudioChannelBufferSize	#	4	; size of audio channel buffer, in bytes
AudioInfoStructure	#	SISize
AudioSystemInfoStructure #	SISSize

AudioChannelBufferReadPtr #	4	; Last known value of AudioChannelBufferReadPtr (in bytes)

AudioPreFilling		#	4	; NZ => pre-filling
AudioStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
AudioStreamFlags	#	4	; stream flags
AudioSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
AudioLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
AudioNumberOfPTSs	#	4	; number of PTSs sent
AudioAmountSent		#	4	; amount of data sent
AudioPTSInCount		#	4	; number of audio PTSs received from MPEGControl

AudioSampleRate		#	4	; -1 for unknown, 0..7 => 22.05, 24, 16, reserved, 44.1, 48, 32, reserved
AudioResyncDelay	#	4	; counts down number of centisecond ticks till we check audio buffer fullness again
AudioFasts		#	4	; number of audio frames played "fast"
AudioSlows		#	4	; number of audio frames played "slow"
AudioMuted		#	4	; non-zero => audio muted
LastAudioBufferFullness	#	4	; last audio buffer fullness after stuffing
AudioBufferChecks	#	4	; number of checks on audio buffer fullness
AudioDiscardedDataCount #	4	; number of bytes of audio data flushed out of audio channel buffer on last
					;  MPEGVideo_ResetStream call, to be used to compute total audio discard on subsequent
					;  MPEGAudio_ResetStream call. Reset to -1 on OpenStream or after MPEGAudio_ResetStream
 [ AllowSyncOnIFrames
SyncMode		#	4	; 0 when syncing on I-frames disabled
					; 1 when syncing on I-frames is enabled, but had no PTSs yet
					; 2 after first PTS has been used to write SCR
AnchorPostedPTSs	#	4*8	; 4 PTS slots for anchor frames, used for I-frame synching
AnchorPostedPTSWritePtr #	4	; write pointer for AnchorPostedPTSs, increments from 0 indefinitely, bottom 2 bits indicate
					; next slot
AnchorPostedPTSReadPtr	#	4	; where to read from (increments indefinitely)
AnchorFIFOOverruns	#	4	; number of times the AnchorPTS FIFO overran
 ]
 [ CountVideoPackets
 ASSERT :LNOT: AllowSyncOnIFrames	; the two modes of operation are incompatible!
SyncMode		#	4	; 0 when normal syncing, 1 when relying on counting packets
VideoPacketsReceived	#	4	; reset to 0 on ResetStream, incremented on each start of MPEG packet received
VideoPicturesReceived	#	4	; reset to 0 on ResetStream, incremented on each PictureDecode interrupt
VideoOKCount		#	4	; number of times we didn't have to repeat
VideoSyncPos		#	4	; where we are in stats array
 ]
 [ VetSCRValues
VetSCRState		#	4	; 0 => awaiting 1st SCR, 1 => last SCR was good, 2 => last SCR was bad
GoodSCROffset		#	4	; SCR-<monotonic time>*900, for the last good SCR value
BadSCROffset		#	4	; ditto, for the last bad SCR value
BadSCRCount		#	4	; count of the number of bad SCR values
SCRAcceptableRange	*	&6000	; about a 1/4 of a second, in 90kHz units
 ]
 [ CountFieldInversions
FieldInversions		#	4	; number of field inversions observed
 ]
 [ PerformFieldInversion
FieldInversionState	#	4	; 2 => freeze decoder next BAV IRQ
					; 1 => unfreeze decoder next BAV IRQ
					; 0 => finished freezing/unfreezing
 ]

; New stuff for L64002

IRSoftCopy		#	4	; soft copies of interrupt mask registers
DRAMBuffer		#	8	; temporary buffer for reading L64002 DRAM into
DRAMBufferAddress	#	4	; base address correponding to contents of DRAM buffer
CardProductType		#	4	; product type of MPEG 2 card (or -1 if unrecognised)

SequenceCount		#	4	; number of sequences to wait for before starting to count fields before unblanking
BlankedSequences	#	4	; initialiser for SequenceCount
BlankedFields		#	4	; number of fields to wait for each time we reset

LastErrorStatus		#	4	; last value of ErrorStatus byte
CumulativeErrorStatus	#	4	; logical OR of all ErrorStatus bytes
VidRecErrors		#	4	; number of video reconstruction errors
ContextErrors		#	4	; number of context errors
VLCErrors		#	4	; number of VLC errors
TimeOfLastVideoReset	#	4	; monotonic time after last reset
TimeOffsetOfVRError	#	4	; time between last video reset and 1st occurrence of video recon error (-1 if none)


; Areas copied out of Aux FIFO

VideoSequenceData		#	0
VideoSequence_HorizontalSize	#	2
VideoSequence_VerticalSize	#	2
VideoSequence_PelAspectRatio	#	1
VideoSequence_PictureRate	#	1
VideoSequence_BitRate		#	3
VideoSequence_VBVBufferSize	#	2
VideoSequence_Misc		#	1

SequenceExtensionData		#	7
DisplayExtensionData		#	9
GroupOfPicturesData		#	6

PictureData			#	0
Picture_TemporalReference	#	2
Picture_PictureCodingType	#	1
Picture_VBVDelay		#	2

QuantMatrixExtensionData	#	1
PanAndScanExtensionData		#	7
PictureCodingExtensionData	#	20

	AlignSpace

 [ SkippingCode
StartSkipCode		#	4	; bottom byte of start code to skip to initially, or zero if no skip
 ]

VideoStructureFlags	#	4
VideoInputType		#	4	; specifies what format of input is passed to MPEG2Video
CurrentHorizontalSize	#	4	; specifies what horiz size was at last sequence header
CurrentVerticalSize	#	4	; ditto for vertical size
CurrentTVFormat		#	4	; ditto for TV format (0=PAL, 1=NTSC)
CurrentOutputWidth	#	4	; either 704 or 720 as appropriate

 [ SaveAPacket
SavedPacketLength	#	4	; 0 => no packet saved yet, else length of 1st packet
FirstPacket		#	184	; 1st (up to) 184 bytes of 1st packet
  [ Save1stFullPacket
SavedPacketPTS		#	8	; PTS on 1st packet
  ]
 ]

 [ TrickPlaySupport
TrickStops		#	4	; number of times code stopped the decoder
TrickStarts		#	4	; number of times code started the decoder
TrickPlayMode		#	4	; NZ => we're doing Oracle-style trick play
 ]

; Large blocks

VideoPTSList		#	PTSListSize * VideoPTSListEntries
AudioPTSList		#	PTSListSize * AudioPTSListEntries

 [ CountVideoPackets
VideoSyncStats		#	&400*8	; pairs of packets, pictures at the time of BeginActiveVideo(odd field)
 ]

 [ FullLengthStats
LengthStatsArraySize	*	8192	; room for this number of entries (each 1 word full length)
LengthStatsPosition	#	4	; position in array
LengthStatsArray	#	LengthStatsArraySize *4
 ]

 [ international
MessageFile_Block #	16
MessageFile_Open  #	4
 ]

Module_WorkspaceSize * :INDEX: @

VideoPreFillSize	*	200*1024	; amount to send before starting - goes up to 224K for MPEG 2
AudioPreFillSize	*	4096

; The following are 1st guesses

AudioBufferLowWaterMark *	&0C00		; 3 K
AudioBufferHighWaterMark *	&1400		; 5 K
AudioResyncRepeat *		10		; 10cs between successive attempts at going fast or slow

	GBLL	debug
debug	SETL	{FALSE}

	MACRO
	DLine	$string, $cc, $inverse
 [ debug
	DLINE	$string, $cc, $inverse
 ]
	MEND

	MACRO
	DReg	$reg, $string, $cc, $routine
 [ debug
	DREG	$reg, $string, $cc, $routine
 ]
	MEND

; **************** Module code starts here **********************

Module_BaseAddr

	&	0				; no app start entry
	&	Mod_Init    -Module_BaseAddr
	&	Mod_Die	    -Module_BaseAddr
	&	Mod_Service -Module_BaseAddr
	&	Mod_Title   -Module_BaseAddr
	&	Mod_HelpStr -Module_BaseAddr
	&	Mod_HC_Table-Module_BaseAddr
	&	MPEGVideoSWI_Base ; SWI chunk
	&	Mod_SWIHandler-Module_BaseAddr
	&	Mod_SWITable-Module_BaseAddr
	&	0				; no swi name decode entry

Mod_Title
	=	"MPEG2Video", 0

Mod_HelpStr
	=	"MPEG2Video", TAB, "2.51 (11 Feb 1998)", 0
	ALIGN

Mod_SWITable
	=	"MPEGVideo", 0
	=	"OpenStream", 0
	=	"FullPackets", 0
	=	"CloseStream", 0
	=	"Play", 0
	=	"SetSpeed", 0
	=	"CardControl", 0
	=	"SetSCR", 0
	=	"ReadParameters", 0
	=	"ResetStream", 0
	=	"DisplayStill", 0
	=	"Stats", 0
	 =	 0
	ALIGN

Mod_HC_Table
	Command SyncOffset, 1, 1
	Command VideoInfo, 0, 0
 [ RegDebug
	Command ReadL64002, 2, 1
	Command WriteL64002, 3, 2
	Command	PacketInfo, 0, 0
 ]
	=	0

SyncOffset_Help
	=	"*SyncOffset sets the offset to be added to the clock value"
	=	" before programming into the L64002.", CR
SyncOffset_Syntax
	=	"Syntax: *SyncOffset <value>", 0
VideoInfo_Help
	=	"*VideoInfo outputs debugging info.", CR
VideoInfo_Syntax
	=	"Syntax: *VideoInfo", 0
	ALIGN

; **************************************************************************
;
;	Mod_Init - Initialisation entry
;

debug SETL {FALSE}

Mod_Init Entry
	LDR	r2, [R12]		; have we got workspace yet ?
	TEQ	r2, #0
	BNE	%FT05

	MOV	r0, #ModHandReason_Claim
	LDR	r3, =Module_WorkspaceSize
	SWI	XOS_Module
	EXIT	VS

; r2 -> workspace

	STR	r2, [r12]		; save address in my workspace pointer,
					; so Tutu can free it for me when I die
05
	MOV	r12, r2

	DLine	"Calling FindPoduleNumber"

	BL	FindPoduleNumber
	EXIT	VS

	DLine	"Calling Podule_ReadInfo"

	MOV	r0, #Podule_ReadInfo_EASILogical
	ADR	r1, Podule_Base
	MOV	r2, #4
	SWI	XPodule_ReadInfo
	EXIT	VS

	LDR	r0, Podule_Base
	ADD	r1, r0, #Offset_Podule_ControlStatus1
	STR	r1, Podule_ControlStatus1
	ADD	r1, r0, #Offset_Podule_ControlStatus2
	STR	r1, Podule_ControlStatus2
	ADD	r1, r0, #Offset_L64002_Registers
	STR	r1, L64002_Registers
	ADD	r1, r0, #Offset_L64002_Audio_Data_Write
	STR	r1, L64002_Audio_Data_Write
	ADD	r1, r0, #Offset_L64002_Video_Data_Write
	STR	r1, L64002_Video_Data_Write
	ADD	r1, r0, #Offset_FIFO_8_Bit_Write
	STR	r1, FIFO_8_Bit_Write
	ADD	r1, r0, #Offset_FIFO_16_Bit_Write
	STR	r1, FIFO_16_Bit_Write
	ADD	r1, r0, #Offset_FIFO_32_Bit_Write
	STR	r1, FIFO_32_Bit_Write

	MOV	r0, #0
	STR	r0, CommonInterruptVectorsClaimed
	STR	r0, VideoInterruptVectorsClaimed
	STR	r0, AudioInterruptVectorsClaimed
	STR	r0, SyncOffset
	STR	r0, VideoAmountReceived
	STR	r0, VideoCallBackRequested
	STR	r0, AudioCallBackRequested
	STR	r0, VideoControlStreamHandle
	STR	r0, AudioControlStreamHandle
	STR	r0, AudioResyncDelay
	STR	r0, AudioFasts
	STR	r0, AudioSlows
	STR	r0, AudioBufferChecks

	ADR	r0, VideoPTSList
	STR	r0, VideoInfoStructure+SI_PTSListPtr
	MOV	r0, #VideoPTSListEntries
	STR	r0, VideoInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_VideoSystemWrite0_Addr1
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_VideoSystemWrite0_Addr2
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Reg

	ADRL	r0, AudioPTSList
	STR	r0, AudioInfoStructure+SI_PTSListPtr
	MOV	r0, #AudioPTSListEntries
	STR	r0, AudioInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_AudioSystemWrite0_Addr1
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_AudioSystemWrite0_Addr2
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Reg
	ADR	r0, AudioSystemInfoStructure
	STR	r0, AudioInfoStructure+SI_SISPtr		; system buffer for audio is always the audio system buffer

	BL	InitSAA7167		; only needs doing once, so do it here

; Now read existence of variable 'TVOn' to see whether to set CTRL0 and CTRL1 on or off

	Push	"r0,r1"
	ADR	r0, TVOnString
	MOV	r1, #0
	MOV	r2, #-1
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	Pull	"r0,r1"

	DLine	"Initialising Control registers"

	TEQ	r2, #0
	MOVEQ	r2, #MPEG2PoduleControl_CLKSelect	; var doesn't exist, so TV off
	MOVNE	r2, #MPEG2PoduleControl_ModulatorBoost :OR: MPEG2PoduleControl_CTRL1 :OR: MPEG2PoduleControl_CTRL0 :OR: MPEG2PoduleControl_CLKSelect ; var exists, TV on
	STR	r2, PoduleControlSoftCopy
	LDR	r1, Podule_ControlStatus1
	STRB	r2, [r1]
	LDR	r1, Podule_ControlStatus2
	MOV	r2, r2, LSR #8
	STRB	r2, [r1]

	DLine	"Returned from initialising Control registers"

; now claim unknown SWI vector, to trap the MPEGAudio SWIs

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Claim

 [ DoPEH
	BL	RegisterPEHHandlers
 ]

	CLRV
	EXIT

TVOnString
	=	"TVOn", 0
	ALIGN

	LTORG

; **************************************************************************
;
;	Mod_Die - Die entry
;

Mod_Die Entry
	LDR	wp, [r12]

	BL	CheckStreamOpen
	BNE	%FT90					; [there's a stream open so refuse to die]

 [ DoPEH
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
 ]

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Release

	CLRV
	EXIT

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"MPEG2Video cannot die as there is a stream open to it", 0
	ALIGN

; **************************************************************************
;
;	Mod_Service - Main entry point for services
;
; in:	R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
	TEQ	r1, #Service_PreReset
 [ DoPEH
	TEQNE	r1, #Service_MPEGControlStarting
 ]
	MOVNE	pc, lr			; if not pre-reset or MPEGControl_Starting, do nothing

	LDR	wp, [r12]
 [ DoPEH
	TEQ	r1, #Service_MPEGControlStarting
	BEQ	RegisterPEHHandlers
 ]
	Push	"lr"
	BL	VideoReleaseInterruptVectors
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors
	Pull	"pc"

 [ DoPEH
; it's Service_MPEGControlStarting

RegisterPEHHandlers Entry "r0-r3"
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
	EXIT
 ]

; **************************************************************************
;
;	Mod_SWIHandler - Main entry point for SWIs
;
; in:	r11 = SWI number
;

Mod_SWIHandler ROUT
	LDR	r12, [wp]
	CMP	r11, #(%FT20-%FT10) :SHR: 2
	ADDCC	pc, pc, r11, LSL #2
	B	NoSuchSWI
10
	B	VideoOpenStream		; open stream
	B	VideoFullPackets	; new data
	B	VideoCloseStream	; close stream
	B	VideoPlay		; start playing
	B	VideoSetSpeed		; may encompass pause/slow/fast/rewind
	B	CardControl		; general control of MPEG card (used by audio module)
	B	VideoSetSCR		; set SCR value in L64002
	B	ReadParameters		; read various parameters
	B	VideoResetStream	; discard data and reset
	B	DisplayStill		; display 2-field MPEG still picture
	B	VideoStats		; return statistics
20
NoSuchSWI
	ADRL	r0, NoSuchSWIError
	SETV
	MOV	pc, lr

; **************************************************************************
;
;	UnknownSWI - Entry point for UKSWIV, to trap MPEGAudio SWIs
;
; in:	r11 = SWI number
;	r0-r8 as per SWI entry

UnknownSWI Entry
	LDR	lr, =MPEGAudioSWI_Base
	SUB	lr, r11, lr
	CMP	lr, #MPEGAudio_MuteSound + 1 - MPEGAudioSWI_Base
	EXIT	HI			; [not an MPEGAudio SWI that we know about]

	STR	r11, [sp]		; overwrite pass-on address with r11
	MOV	r11, lr
	MOV	lr, pc
	ADD	pc, pc, r11, LSL #2
	Pull	"r11, pc"		; restore r11 and exit claiming vector
	B	AudioOpenStream
	B	AudioFullPackets
	B	AudioCloseStream
	B	AudioPlay
	B	AudioSetSpeed
	B	AudioSkipFrame
	B	AudioRepeatFrame
	B	AudioResetStream
	B	AudioMuteSound

	LTORG

debug SETL {FALSE}

 [ DoPEH
; **************************************************************************
;
;	VideoStreamHandler - Handler for video stream
;
; in:	r0 = reason code
;	r12 = wp
;	Others as appropriate

VideoStreamHandler ROUT
	CMP	r0, #(VideoHandlerDespatchTableEnd - VideoHandlerDespatchTable) :SHR: 2
	ADDCC	pc, pc, r0, LSL #2
	B	UnknownHandlerReasonCode
VideoHandlerDespatchTable
	B	VSH_OpenStream
	B	VSH_DataTransfer
	B	VSH_CloseStream
VideoHandlerDespatchTableEnd

UnknownHandlerReasonCode
	ADRL	r0, UnknownHandlerReasonError
	SETV
	MOV	pc, lr

UnknownHandlerReasonError
	&	0
	=	"Unknown video handler reason code", 0
	ALIGN

; VSH_OpenStream
; Don't bother to do much here yet, as MPEGVideo_OpenStream is still issued
; Just return a non-zero handle

; VSH_CloseStream - do nowt

VSH_OpenStream
	MOV	r0, #1
VSH_CloseStream
	CLRV
	MOV	pc, lr

; VSH_DataTransfer
; Just move the packet descriptor pointer (in r3) into r2 (we can corrupt r0-r3)

VSH_DataTransfer
	MOV	r2, r3
	B	VideoFullPackets

 ] ; DoPEH
; **************************************************************************
;
;	VideoOpenStream - Open MPEG video stream
;
; in:	r0 = flags
;	r1 = control stream handle
;	r2 -> video parameters structure
;
; out:  r0 = video stream handle
;

VideoOpenStream Entry "r1,r2, r11"
	LDR	r11, L64002_Registers
	STR	r0, VideoStreamFlags
	STR	r1, VideoControlStreamHandle

	LDR	lr, [r2, #VideoStructure_Flags]
	STR	lr, VideoStructureFlags

	TST	lr, #VideoStructureFlags_InputTypeExtension
	LDRNE	lr, [r2, #VideoStructure_InputType]	; if input type specified, use it
	MOVEQ	lr, #0					; else indicate unknown
	STR	lr, VideoInputType

 [ ProgrammableBlanking
	LDR	lr, VideoStructureFlags
	TST	lr, #VideoStructureFlags_BlankingExtension
	LDRNE	lr, [r2, #VideoStructure_BlankedSequences]
	MOVEQ	lr, #1
	STR	lr, BlankedSequences
	LDRNE	lr, [r2, #VideoStructure_BlankedFields]
	MOVEQ	lr, #16
	STR	lr, BlankedFields
 |
	MOV	lr, #1
	STR	lr, BlankedSequences
	MOV	lr, #16
	STR	lr, BlankedFields
 ]
	MOV	r1, #0
	STR	r1, VideoStreamClosing
	STR	r1, VideoAmountReceived
	STR	r1, VideoNumberOfPTSs
	STR	r1, VideoPacketListHeadPtr
	STR	r1, VideoPacketListTailPtr
	STR	r1, VideoPTSInCount
	STR	r1, VideoInfoStructure+SI_PTSListOverruns
	STR	r1, VideoSkips
	STR	r1, VideoRepeats
	STR	r1, VideoNumberOfPostedPTSs
	STR	r1, VideoPTSPictureTypeCounts +0
	STR	r1, VideoPTSPictureTypeCounts +4
	STR	r1, VideoPTSPictureTypeCounts +8
	STR	r1, VideoPTSPictureTypeCounts +12
	STR	r1, VideoMinPTSDifference
	STR	r1, VideoMaxPTSDifference
	STR	r1, PendingFreezeState
	STR	r1, FreezeUpdate
 [ AllowSyncOnIFrames
	STR	r1, SyncMode					; don't enable sync on I frames until an appropriate ResetStream
	STR	r1, AnchorFIFOOverruns
 ]
 [ TrickPlaySupport
	STR	r1, TrickStops
	STR	r1, TrickStarts
	STR	r1, TrickPlayMode				; indicate not doing trick play
 ]
 [ CountVideoPackets
	STR	r1, SyncMode					; normal syncing until a reset stream
 ]
 [ CountFieldInversions
	STR	r1, FieldInversions
 ]
 [ PerformFieldInversion
	STR	r1, FieldInversionState
 ]
 [ FullLengthStats
	STR	r1, LengthStatsPosition
 ]
 [ CountUnderruns
	STR	r1, VideoChannelUnderruns
	STR	r1, UnderrunIRQState
 ]
	BL	VideoReset

	LDR	r1, [r2, #VideoStructure_BorderLeft]
	STR	r1, BorderLeft

	LDR	r1, [r2, #VideoStructure_BorderTop]
	STR	r1, BorderTop

	LDR	r1, [r2, #VideoStructure_ScreenMode]
	CMP	r1, #-1
	MOVNE	r0, #0
	SWINE	XOS_ScreenMode

	LDR	r1, VideoStructureFlags
 [ NYI ; SkipByBlanking
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr :OR: VideoStructureFlags_SkipToGOP :OR: VideoStructureFlags_SkipToPic
	BEQ	%FT25
	MOV	r0, #1		; blank screen
	BL	SetBlank

	MOV	r0, #0
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr	; if skipping to sequence
	ORRNE	r0, r0, #CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V	; then enable SEQ-V IRQ and also PIC-V so it works
	TST	r1, #VideoStructureFlags_SkipToGOP		; if skipping to GOP
	ORRNE	r0, r0, #CL450IRQ_GOP :OR: CL450IRQ_PIC_V	; then enable GOP IRQ and also PIC-V so it works
	TST	r1, #VideoStructureFlags_SkipToPic
	ORRNE	r0, r0, #CL450IRQ_PIC_V
	Push	"r1"
	MOV	r1, #0
	BL	EnableDisableIRQs
	Pull	"r1"
25
 ]

 [ SkippingCode
	MOV	r0, #0
	TST	r1, #VideoStructureFlags_SkipToGOP
	MOVNE	r0, #MPEG_group_start_code
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr	; NB this overrides GOP skip
	MOVNE	r0, #MPEG_sequence_header_code
	STR	r0, StartSkipCode
 ]

	TST	r1, #VideoStructureFlags_NoInterlace
	Push	"r1, r2"
	MOVNE	r1, #MPEG2PoduleControl_InterlaceDisable	; either disable interlace
	MOVEQ	r1, #0						; or enable it
	MVN	r2, #MPEG2PoduleControl_InterlaceDisable	; r2 = AND mask
	BL	UpdateControlRegister
	Pull	"r1, r2"

	TST	r1, #VideoStructureFlags_DontCLS
	BNE	%FT30

; *** NB Following code assumes 16bpp screen mode ***

	Push	"r1"
	MOV	r0, #&10		; store &F000
	MOV	r1, #&F000
	SWI	XOS_SetColour
	SWI	XOS_WriteI + 16
	Pull	"r1"

30
	TST	r1, #VideoStructureFlags_DontChangePalette
	BNE	%FT50			; [don't change palette]

; first program External Register in VIDC20 to enable EClk

	LDR	r0, =&C0001007
	MOV	r1, #VIDC
	STR	r0, [r1]

; *** NB Following code assumes 16bpp mode ***
; program entries 0 to 15
; - entries 0 to 7 output 0 on ext (solid colours)
; - entries 8 to 15 output 15 on ext (transparent) - NB no individual RGB transparency on MPEG 2 card

	Push	"r2, r3, r4, r9"
	MOV	r0, #15
40
	MOV	r1, #16
	SWI	XOS_ReadPalette
	BVS	%FT90

	BIC	r2, r2, #&FF
	TST	r0, #8
	ORRNE	r2, r2, #&10		; only set ED[0] which controls RGB switch, not ED[3] which controls Macrovision switch
	MOV	r4, #2
	MOV	r9, #&23
	SWI	XOS_CallAVector
	BVS	%FT90
	SUBS	r0, r0, #1
	BPL	%BT40

; program border colour to be transparent also

	MOV	r0, #0
	MOV	r1, #24
	MOV	r2, #&10		; 28-May-97 TMD Correct border colour also to only set ED[0]
	MOV	r4, #2
	MOV	r9, #&23
	SWI	XOS_CallAVector
	BVS	%FT90

	Pull	"r2, r3, r4, r9"
50
 [ {FALSE}
	LDR	r1, [r2, #VideoStructure_Flags]
	TST	r1, #VideoStructureFlags_NTSC
	MOVEQ	r0, #VF_PAL
	MOVNE	r0, #VF_NTSC
	BL	SetVideoFormat
 ]

	LDR	r0, BorderLeft
	LDR	r1, BorderTop
	BL	SetBorder

	BL	SetWindow

	MOV	r0, r12
	CLRV
	EXIT

	LTORG

90
	Pull	"r2, r3, r4, r9"
	SETV
	EXIT

debug SETL {FALSE}

SlowMotion
NewPacket
SetVideoFormat
SetBorder
SetWindow
AudioSkipFrame
AudioRepeatFrame
AudioSlowMotion
AudioFlushBitstream
	MOV	pc, lr


InitStream_Common Entry "r0-r2"

; zero counts of IRQs

	MOV	r0, #0
	ADR	r1, IRQCounts
	MOV	r2, #16
10
	STR	r0, [r1], #4
	SUBS	r2, r2, #1
	BNE	%BT10

					; set up soft copy of Status 0 register
	STR	r0, Status0SoftCopy	; (all video streams enabled, don't reset channel buffer on error)

	LDR	r0, =&FFFE		; all IRQs disabled, video decoder stopped
	STR	r0, IRSoftCopy

	BL	InitL64002
	BL	CommonClaimInterruptVectors
	EXIT

	LTORG

; **************************************************************************
;
;	VideoSetSpeed - Set speed of MPEG stream
;
; in:	r0 = flags
;	r1 = video stream handle
;	r2 = speed indicator
;	       0    = paused
;	       1    = normal speed
;	       2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

VideoSetSpeed Entry "r0-r2, r11"
	LDR	r11, L64002_Registers
	CMP	r2, #8		; don't allow speeds slower than 8
	EXIT	HI

	LDR	r0, VideoSpeedSetting
	TST	r0, #&80000000  ; if pre-buffering
	ORRNE	r2, r2, #&80000000 ; then still pre-buffering, but may have speed setting after
	STR	r2, VideoSpeedSetting

	CMP	r2, #1
	BLT	%FT10		; pause (or pre-buffering)
	BEQ	%FT20		; normal speed

	MOV	r0, r2
	BL	SlowMotion
	EXIT

10
	BL	VideoSendPause
	CLRV
	EXIT

20
	ADR	lr, VideoLastPTS
	LDMIA	lr, {r0, r1}
	BL	WriteSCR
	BL	VideoSendPlay
	EXIT

; **************************************************************************
;
;	VideoPlay - Start going
;
; in:	r0 = flags
;	r1 = video stream handle
;
; out:  -
;

VideoPlay Entry "r0,r2, r11"
	LDR	r2, VideoSpeedSetting
	BIC	r2, r2, #&80000000	; clear pre-buffering bit
	STR	r2, VideoSpeedSetting
	BL	VideoSetSpeed
	EXIT

debug SETL {FALSE}

; **************************************************************************
;
;	VideoFullPackets - Here's some more data
;
; in:	r0 = flags
;	r1 = video stream handle
;	r2 -> one or more linked bitstream packets

VideoFullPackets Entry "r0,r11"
	DLine	"MPEGVideo_FullPackets called"
	LDR	r11, [r2, #PacketDescriptor_Length]
	DReg	r11, "Packet length = "
	LDR	lr, [r2, #PacketDescriptor_Flags]
	DReg	lr, "Packet flags = "
	CMP	r11, #0
	BGE	%FT01					; only complain about -ve length
	DREG	r11, "Packet length = "
01
 [ Save1stFullPacket
	LDR	lr, SavedPacketLength
	TEQ	lr, #0
	BNE	%FT05					; [already saved, so skip]
	CMP	r11, #?FirstPacket			; if bigger than we've room for
	MOVHI	r11, #?FirstPacket			; reduce size
	STR	r11, SavedPacketLength
	ADR	r0, FirstPacket
	LDR	lr, [r2, #PacketDescriptor_Start]
	Push	"r1"
02
	SUBS	r11, r11, #1				; copy the packet into saved area
	LDRCSB	r1, [lr, r11]
	STRCSB	r1, [r0, r11]
	BHI	%BT02
	LDR	r1, [r2, #PacketDescriptor_Flags]	; save PTS, or -1 if none
	TST	r1, #PacketDescriptorFlags_PTSValid
	MOVEQ	r1, #-1
	LDRNE	r1, [r2, #PacketDescriptor_PTS +0]
	STR	r1, SavedPacketPTS +0
	LDRNEB	r1, [r2, #PacketDescriptor_PTS +4]
	STR	r1, SavedPacketPTS +4
	Pull	"r1"
05
 ]
	LDR	r11, L64002_Registers
	MOV	r0, pc
	Push	"r0"
	ORR	lr, r0, #I_bit
	TEQP	lr, #0					; disable IRQs round this bit

	LDR	r0, VideoPacketListTailPtr
	TEQ	r0, #0					; if nothing on list
	STREQ	r2, VideoPacketListHeadPtr		; then point head at new packets
	STRNE	r2, [r0, #PacketDescriptor_Link]	; else tail!link = packet
10
	LDR	r0, [r2, #PacketDescriptor_Length]
	LDR	lr, VideoAmountReceived
	ADD	lr, lr, r0
	STR	lr, VideoAmountReceived

	LDR	r0, [r2, #PacketDescriptor_Flags]
	TST	r0, #PacketDescriptorFlags_PTSValid	; if packet has a valid PTS (ie is start of an MPEG packet)
	ORRNE	r0, r0, #PacketDescriptorFlags_Unchecked
	STRNE	r0, [r2, #PacketDescriptor_Flags]

	TST	r0, #PacketDescriptorFlags_MPEGStart	; is it the start of a new packet?
	BEQ	%FT30					; [no, so skip this]
	LDR	lr, UnknownLengthPacket			; if it is, check to see if we have an indeterminate length packet in progress
	TEQ	lr, #0
	BEQ	%FT20
	Push	"r0,r1"
 [ FullLengthStats
	ADRL	r0, LengthStatsPosition
	LDR	r1, [r0]
	ADD	r1, r1, #1
	CMP	r1, #LengthStatsArraySize
	STRLE	r1, [r0]
	ADDLE	r0, r0, r1, LSL #2
	LDRLE	r1, [lr, #PacketDescriptor_FullLength]
	STRLE	r1, [r0]
 ]

	LDR	r0, [lr, #PacketDescriptor_Flags]	; there are no more sections in the indeterminate length packet,
	BIC	r0, r0, #PacketDescriptorFlags_FullLengthUnknown ;  so clear the bit
	STR	r0, [lr, #PacketDescriptor_Flags]
	MOV	r0, #0
	STR	r0, UnknownLengthPacket			; and clear the pointer to it
	Pull	"r0,r1"
20
 [ TrickPlaySupport
	LDR	lr, TrickPlayMode
	TEQ	lr, #0
	LDRNE	lr, VideoStructureFlags
	TSTNE	lr, #VideoStructureFlags_TrickPlayPacketLengthFix
	ORRNE	r0, r0, #PacketDescriptorFlags_FullLengthUnknown	; pretend was unknown length
	STRNE	r0, [r2, #PacketDescriptor_Flags]
 ]
	TST	r0, #PacketDescriptorFlags_FullLengthUnknown ; is the new packet of unknown length
	MOVNE	r0, #0
	STRNE	r0, [r2, #PacketDescriptor_FullLength]  ; if so, then zero its full length
 [ TrickPlaySupport

; lr is set above to either zero (if TrickPlayMode=0), or to VideoStructureFlags, so it's OK to just test if the
; packet length bit is set, since it definitely won't be if we're not doing trick play

	TSTNE	lr, #VideoStructureFlags_TrickPlayPacketLengthFix
 ]
 [ FudgeZeroLengthPackets :LOR: TrickPlaySupport
	STRNE	r2, UnknownLengthPacket			; set up pointer to unknown length packet, if doing trick play or always
							;  fudging
 ]
30
	LDR	r0, UnknownLengthPacket			; if we are working out the length
	TEQ	r0, #0
	BEQ	%FT40
	Push	"r1"
	LDR	r1, [r0, #PacketDescriptor_FullLength]
	LDR	lr, [r2, #PacketDescriptor_Length]
	ADD	r1, r1, lr
	STR	r1, [r0, #PacketDescriptor_FullLength]  ; update total length
	Pull	"r1"
40
	LDR	r0, [r2, #PacketDescriptor_Link]	; go down list of packets to end
	TEQ	r0, #0
	MOVNE	r2, r0
	BNE	%BT10

	STR	r2, VideoPacketListTailPtr		; store new tail pointer
	Pull	"r0"
	TEQP	r0, #0					; restore IRQ state

	EXIT

debug SETL {FALSE}

; **************************************************************************
;
;	VideoCloseStream - Close MPEG video stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGVideo_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:	r0 = flags
;	r1 = Video stream handle
;

VideoCloseStream Entry "r0-r2,r11"
	LDR	r11, L64002_Registers

	LDR	r0, UnknownLengthPacket			; do we have an indeterminate-length packet pending?
	TEQ	r0, #0					; if so then length is now complete
	LDRNE	lr, [r0, #PacketDescriptor_Flags]
	BICNE	lr, lr, #PacketDescriptorFlags_FullLengthUnknown
	STRNE	lr, [r0, #PacketDescriptor_Flags]
	MOVNE	lr, #0
	STRNE	lr, UnknownLengthPacket			; and no unknown packet now

	LDR	r0, VideoSpeedSetting
	TEQ	r0, #0
	BEQ	%FT50					; [it was paused, so junk data]

	BPL	%FT10					; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

	TEQ	r0, #&80000000
	BEQ	%FT50

   [ SendPlaySWI
	BLCS	VideoIssuePlaySWI
   |
	BLCS	VideoSendPlay
   ]

; wait for data to empty

10
	MOV	r0, #1					; indicate to multiple picture packet checker that we won't get
	STR	r0, VideoStreamClosing			; any more data, so don't hang around
20
	TEQP	pc, #0
	NOP						; allow callbacks
	SWI	OS_EnterOS

	LDR	r0, VideoPacketListHeadPtr		; do we have any outstanding packets?
	CMP	r0, #0					; V := 0
	BNE	%BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
	MOV	r0, #2
	STR	r0, VideoStreamClosing
60
	LDR	r0, VideoPacketListHeadPtr
	CMP	r0, #0				; V := 0
	BLNE	VideoFreePacket
	BNE	%BT60
70
	BL	VideoReleaseInterruptVectors
	LDR	r0, AudioControlStreamHandle		; if audio not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, VideoControlStreamHandle		; stream no longer open
	EXIT

; **************************************************************************
;
;	CardControl - Various hardware and interrupt control functions
;

BadCardControlReason
	ADRL	r0, BadCardControlReasonError
	SETV
	MOV	pc, lr

CardControl ROUT
	CMP	r0, #CardControlBadReason
	ADDCC	pc, pc, r0, LSL #2
	B	BadCardControlReason
10
	B	ClaimAudioIRQ
	B	ReleaseAudioIRQ
	B	UpdateControlRegisterMPEG1Style
	B	ControlPowerDown
	B	BadCardControlReason	; SendMacroCommand
	B	BadCardControlReason	; SetColourMode
	B	ReadStatusRegister
	ASSERT  CardControlBadReason :SHL: 2 = {PC}-%BT10

; in:	r0 = reason code (0=Claim audio IRQ)
;	r1 -> audio interrupt routine
;	r2 = workspace pointer for audio IRQ
;
; out:  -

ClaimAudioIRQ * BadCardControlReason

; in:	r0 = reason code (1=Release audio IRQ)
;
; out:  -

ReleaseAudioIRQ * BadCardControlReason

; in:	r0 = reason code (2=Update Control register)
;	r1 = EOR mask
;	r2 = AND mask
;
; out:  r1 = old value of control register
;	r2 = new value of control register
;
; Performs CR = (CR AND r2) EOR r1

UpdateControlRegisterMPEG1Style Entry "r0"
; Bits 3 to 7 of the values correspond to bits 11 to 15 of our logical value
; Other bits are ignored

	MVN	r0, #&F800			; mask of bits to leave alone 0..10,16..31
	ORR	r2, r0, r2, LSL #8		; merge with bits to leave alone in bits 11..15
	MOV	r1, r1, LSL #8			; shift up EOR mask
	BIC	r1, r1, r0			; then knock out bits we're not allowed to touch
	TST	r2, #MPEG2PoduleControl_CTRL0	; make modulator boost bit reflect CTRL0 (not CTRL1 as previously)
	BICEQ	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	TST	r1, #MPEG2PoduleControl_CTRL0	; in EOR mask as well as AND mask
	BICEQ	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	BL	UpdateControlRegister
	MOV	r0, #&F8			; valid bits to return
	AND	r1, r0, r1, LSR #8		; shift down + mask old control register value
	AND	r2, r0, r2, LSR #8		; and the same for the new value
	EXIT

UpdateControlRegister Entry "r0"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round atomic update

	LDR	lr, PoduleControlSoftCopy
	AND	r2, r2, lr
	EOR	r2, r2, r1
	MOV	r2, r2, LSL #16
	MOV	r2, r2, LSR #16			; knock off bits 16..31
	STR	r2, PoduleControlSoftCopy	; update soft copy, r2 = new value
	MOV	r1, lr				; r1 = old value
	LDR	lr, Podule_ControlStatus1
	STRB	r2, [lr]			; update hardware
	LDR	lr, Podule_ControlStatus2
	MOV	r2, r2, ROR #8
	STRB	r2, [lr]
	MOV	r2, r2, ROR #24			; put back to original value

	TEQP	r0, #0
	EXIT


; in:	r0 = reason code (3=Control power down)
;	r1 bit 0 = 0 => Place MPEG card in normal running state
;		   1 => Place MPEG card in power down state (stop CL450 GCLK)
;	   bits 1..31 reserved, should be zero
; out:	-

ControlPowerDown * BadCardControlReason

; in:	r0 = reason code (6=Read status register)
;
; out:	r1 = value of status register (actually two 8-bit registers combined into 16)
;

ReadStatusRegister Entry
	LDR	lr, Podule_ControlStatus1	; merge Status1
	LDRB	r1, [lr]
	LDR	lr, Podule_ControlStatus2	; and Status2
	LDRB	lr, [lr]
	ORR	r1, r1, lr, LSL #8
	CLRV
	EXIT

; **************************************************************************
;
;	VideoSetSCR - SWI to set the SCR value
;
; in:	r0 = flags
;	r1 = bits 0..31 of SCR
;	r2 = bit 32 of SCR

VideoSetSCR  Entry "r0-r2,r11"
	LDR	r0, SyncOffset
	ADDS	r1, r1, r0
	ADDCS	r2, r2, #1
 [ SuppressNegativeSCRs
	CMP	r2, #0
	EXIT	LT
 ]
	LDR	r11, L64002_Registers
	MOV	r0, r1
	MOV	r1, r2

	BL	WriteSCR
	EXIT

; **************************************************************************
;
;	ReadParameters - Read various stream parameters
;
; in:	r0 = reason code
;	  0 => read time code and temporal reference
;	       out: r1 = time code: bits 0..5	= time_code_pictures
;				    bits 6..11  = time_code_seconds
;				    bits 12..17 = time_code_minutes
;				    bits 18..22 = time_code_hours
;				    bit  23	= drop_frame_flag
;		    r2 = temporal_reference
;	  1 => read direct access parameters for SetSCR
;	       out: r1 = address of SetSCR routine
;		    r2 = workspace value for SetSCR routine
;	  2 => read various locations
;		in: r1 = index of location to read:
;			  0 => CompletionTime
;			  1 => MaxCompletionTime
;	       out: r2 = value
;	  3 => read current SCR value
;		out: r1 = bits 0..31 of SCR
;		     r2 = bit  32    of SCR
;	  4 => read buffer fullness
;		out: r1 = number of bytes in internal buffer
;	  5 => check display ready
;		out: r1 = 1 if 1st picture has been displayed yet, 0 if not

ReadParameters ROUT
	CMP	r0, #ReadParametersBadReason
	ADDCC	pc, pc, r0, LSL #2
	B	BadReadParametersReason
10
	B	ReadTimeCode
	B	ReadSetSCRParameters
	B	ReadDebugInfo
	B	UserReadSCR
	B	ReadBufferFullness
	B	CheckDisplayReady
	ASSERT  ReadParametersBadReason = ({PC} - %BT10) :SHR: 2

BadReadParametersReason
	ADRL	r0, BadReadParametersReasonError
	SETV
	MOV	pc, lr

ReadTimeCode ROUT
	MOV	r1, #0
	MOV	r2, #0
	MOV	pc, lr

ReadSetSCRParameters ROUT
	ADR	r1, VideoSetSCR
	MOV	r2, wp
	CLRV
	MOV	pc, lr

ReadDebugInfo ROUT
	ADR	r2, DebugVarTable
	CMP	r1, #(DebugVarTableEnd - DebugVarTable) :SHR: 2
	LDRCC	r2, [r2, r1, LSL #2]		; get offset of variable
	MOVCS	r2, #-1
	CMP	r2, #-1
	LDRNE	r2, [wp, r2]
	CLRV
	MOV	pc, lr

DebugVarTable
	&	-1
	&	-1
	&	:INDEX: VideoLastPTS +0		; low word of last PTS sent to L64002
	&	:INDEX: VideoNumberOfPTSs
	&	:INDEX: SCROffset
	&	:INDEX: VideoSkips
	&	:INDEX: VideoRepeats
	&	:INDEX: AudioFasts
	&	:INDEX: AudioSlows
	&	:INDEX: LastAudioBufferFullness
	&	:INDEX: AudioBufferChecks
DebugVarTableEnd

UserReadSCR Entry "r11"
	BL	CheckStreamOpen
	MOVEQ	r1, #0				; if no stream open, return zero
	MOVEQ	r2, #0
	EXIT	EQ
	LDR	r11, L64002_Registers
	BL	ReadSCR
	EXIT

; CheckStreamOpen - returns NE if audio or video stream open, all registers preserved

CheckStreamOpen Entry
	LDR	lr, VideoControlStreamHandle
	TEQ	lr, #0
	LDREQ	lr, AudioControlStreamHandle
	TEQEQ	lr, #0
	EXIT

; ReadBufferFullness - return r1 = amount of data in video buffers

ReadBufferFullness Entry "r2,r11"
	LDR	r1, VideoControlStreamHandle
	TEQ	r1, #0			; if no video stream open, return 0 in r1
	EXIT	EQ
	LDR	r11, L64002_Registers
	BL	VideoGetBufferFullness	; returns it in r2
	MOV	r1, r2
	EXIT

CheckDisplayReady Entry
	LDR	r1, DecodedFieldCount
	CMP	r1, #-2			; have we displayed 1st field (value -2)
	MOVEQ	r1, #1			; if so then return 1
	MOVNE	r1, #0			; else return 0
	EXIT

; **************************************************************************
;
;	VideoResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = video stream handle
;
; out:	r2 = estimate of number of bytes discarded

; In this implementation it also resets the audio system as well, since we have to reset the whole L64002 to do this.
; If an audio stream is open at the time, then, in the anticipation that we will shortly be getting an MPEGAudio_ResetStream,
; we first find out how much audio data is being thrown away from the audio channel buffer, and save this away in the variable
; AudioDiscardedDataCount.
;
; When the MPEGAudio_ResetStream is issued, we see that the variable is non-zero, and use that value, and don't reset the device.
; However we do at that point free all the audio packets, adding onto this length. We then set the variable back to -1.

VideoResetStream Entry "r0-r2, r11"
	LDR	r11, L64002_Registers

	MOV	r2, #2					; pretend we're closing, so we don't send any more data to it in background
	STR	r2, VideoStreamClosing
	STR	r2, AudioStreamClosing

	BL	VideoReleaseInterruptVectors
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors

 [ TrickPlaySupport
	TST	r0, #ResetStreamFlags_TrickPlayMode
	MOVEQ	r2, #0
	MOVNE	r2, #1
	STR	r2, TrickPlayMode
 ]

 [ AllowSyncOnIFrames :LOR: CountVideoPackets
	MOV	r2, #0					; assume we're not going to enable I-Frame syncing
	TST	r0, #ResetStreamFlags_AudioPresent
	BNE	%FT08					; [audio present, so don't use I-frame syncing]
	LDR	lr, VideoStructureFlags
	TST	lr, #VideoStructureFlags_IFrameSyncWhenNoAudio
	MOVNE	lr, #0
  [ AllowSyncOnIFrames
	STRNE	lr, AnchorPostedPTSWritePtr		; zero write pointer
	STRNE	lr, AnchorPostedPTSReadPtr		; and read ptr
  ]
  [ CountVideoPackets
	STRNE	lr, VideoPacketsReceived
	STRNE	lr, VideoPicturesReceived
	STRNE	lr, VideoOKCount
	STRNE	lr, VideoSyncPos
  ]
	MOVNE	r2, #1
08
	STR	r2, SyncMode
 ]

	LDR	lr, AudioControlStreamHandle		; is there an audio stream open?
	TEQ	lr, #0
	BEQ	%FT10					; [if not then skip]

	BL	AudioGetBufferFullness
	STR	r2, AudioDiscardedDataCount
10

	BL	VideoGetBufferFullness			; returns fullness in r2
	LDR	r0, VideoPacketListHeadPtr
20
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	VideoFreePacket				; and free the packet
	BNE	%BT20					; then loop

	STR	r2, [sp, #2*4]				; update returned r2 value with byte count

	BL	VideoReset

	MOV	r0, #0
	STR	r0, VideoStreamClosing
 [ SkippingCode
	STR	r0, StartSkipCode
 ]
 [ CountUnderruns
	STR	r0, UnderrunIRQState			; wait again until prefill over, then reenable underrun IRQ
 ]
	CLRV
	EXIT

; **************************************************************************
;
;	VideoReset - Reset stuff for video stream - common to MPEGVideo_OpenStream and MPEGVideo_ResetStream
;

VideoReset Entry "r0"
	MOV	r0, #0
	STR	r0, UnknownLengthPacket				; no unknown length packet pending
	STR	r0, VideoInfoStructure+SI_PTSListReadPtr	; reset pointers to PTS lists
	STR	r0, VideoInfoStructure+SI_PTSListWritePtr
	STR	r0, LastVideoPTSErrorSign			; no PTSs received since reset
	STR	r0, VideoLastPTS +0				; no last PTS value
	STR	r0, VideoLastPTS +4
	STR	r0, VideoAmountQueued				; nothing queued yet
	STR	r0, FirstItemReceived				; no sequence or picture received
	STR	r0, LastErrorStatus
	STR	r0, CumulativeErrorStatus
	STR	r0, VidRecErrors
	STR	r0, ContextErrors
	STR	r0, VLCErrors
 [ FreezeFieldOnTrickStop
	STR	r0, TrickStopFreeze
 ]
 [ SaveAPacket
	STR	r0, SavedPacketLength				; throw away any saved packet
 ]
	MOV	r0, #1
	STR	r0, VideoPreFilling				; we are now pre-filling

	MOV	r0, #-1
	STR	r0, DecodedFieldCount				; not got good display yet
	STR	r0, VideoPostedPTS+4				; indicate no posted PTS
	LDR	r0, BlankedSequences				; start counting this number of sequence headers
	STR	r0, SequenceCount

	LDR	r0, =VideoPreFillSize
	STR	r0, VideoVBVSize

	MOV	r0, #&80000001					; indicate pre-buffering, but would otherwise be playing
	STR	r0, VideoSpeedSetting

	BL	InitStream_Common
	BL	VideoClaimInterruptVectors

	MOV	r0, #-1
	STR	r0, TimeOffsetOfVRError

	SWI	XOS_ReadMonotonicTime
	STR	r0, TimeOfLastVideoReset			; remember time of last video reset

	EXIT

; **************************************************************************
;
;	VideoGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

VideoGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, VideoChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, VideoChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	DisplayStill - Display MPEG still picture
;
; in:	r0 = flags
;

DisplayStill Entry "r0-r2,r11"
 [ NYI
	LDR	r11, CL450_Registers

	MOV	r0, #0
	STR	r0, VideoPreFilling	; don't go sending any play commands!

	MOV	r0, #1			; we're sort of playing!
	STR	r0, VideoSpeedSetting

	MOV	r0, #0			; wait for completion
	ADR	r1, DisplayStillCommand
	BL	SendMacroCommand
 ]
	CLRV
	EXIT

; **************************************************************************
;
;	VideoSendPlay - Start decoder playing

VideoSendPlay Entry "r0,r1"
	MOV	r0, #IR_DecodeStatus	; enable video decoder by setting bit 0 of IR0
	MVN	r1, r0
	BL	UpdateIR
	MOV	r0, #0
	STR	r0, PendingFreezeState	; should be unfrozen
	MOV	r0, #1
	STR	r0, FreezeUpdate	; need an update
 [ CountUnderruns
	LDR	r0, UnderrunIRQState
	TEQ	r0, #0			; if not enabled the IRQ already
	MOVEQ	r0, #1			; then enable it next active field
	STR	r0, UnderrunIRQState
 ]
	EXIT

; **************************************************************************
;
;	VideoSendPause - Pause video decoder

VideoSendPause Entry "r0,r1"
	MOV	r0, #0		; disable video decoder by clearing bit 0 of IR0
	MVN	r1, #IR_DecodeStatus
	BL	UpdateIR
	MOV	r0, #1
	STR	r0, PendingFreezeState	; should be frozen
	STR	r0, FreezeUpdate	; need an update
	EXIT

; **************************************************************************
;
;	FindPoduleNumber
;
; in:	-
;
; out:  r3 = podule number, if VC, otherwise corrupted
;	All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
	SWI	XPodule_ReturnNumber		; find out number of podules
	BVS	%FT90

	SUB	r1, r0, #1			; maximum podule number
	ADR	r0, PoduleVariableName
	BL	ReadNumericVariable
	BVS	%FT05

	MOV	r3, r0				; copy value into r3
	BL	ReadProductType			; get card type anyway, so we can tell whether to use Japanese DAC sound
	B	%FT20

PoduleVariableName
	=	"MPEG2$PoduleNumber", 0
	ALIGN

05
	MOV	r3, r1				; r3 = max podule number
10
	BL	ReadProductType
	BVS	%FT15
	LDR	lr, =ProdType_STB1_MPEG2	; check for MPEG 2 podule for STB 1
	TEQ	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2	; or for STB2/2
	TEQNE	r0, lr
	BEQ	%FT20
15
	SUBS	r3, r3, #1
	BPL	%BT10
	ADRL	r0, NoPoduleError
	SETV
90
	STR	r0, [sp]
	EXIT

	LTORG

; It's this podule

20
	STR	r0, CardProductType
  [ FastPoduleAccess
	MOV	r0, #3			; set access type 'C'
  |
	MOV	r0, #1			; set access type 'A'
  ]
	SWI	XPodule_SetSpeed
	STRVS	r0, [sp]
	EXIT

; ReadProductType
;
; in: r3 = podule
; out: r0 = type
; Corrupts PoduleHeaderBuffer

ReadProductType Entry "r2"
	ADR	r2, PoduleHeaderBuffer
	SWI	XPodule_ReadHeader
	MOVVS	r0, #-1
	EXIT	VS

	LDRB	r0, [r2, #3]
	LDRB	r2, [r2, #4]
	ORR	r0, r0, r2, LSL #8
	EXIT

debug SETL {FALSE}

; **************************************************************************
;
;	ReadNumericVariable - Read numeric value of variable
;
; in:	r0 -> variable name
;	r1 = maximum value of variable
;
; out:	r0 = value of variable if V=0, else -> error ptr
;	Corrupts PoduleHeaderBuffer
;

ReadNumericVariable Entry "r1-r4"
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	EXIT	VS

	MOV	lr, #0
	STRB	lr, [r1, r2]			; terminate string

	LDR	r2, [sp, #0*4]			; reload maximum value
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	MOVVC	r0, r2				; if no error, put value in r0
	EXIT

; **************************************************************************
;
;	InitL64002 - Initialise L64002
;
;

InitL64002 Entry "r0-r2,r11"
        MOV	r0, #19
	SWI	XOS_Byte			; wait for vsync, to minimize screen disruption (hopefully)

	MOV	r1, #0
	MVN	r2, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset	; clear bit ie reset L64002 + FIFO
	BL	UpdateControlRegister

 [ HoldResetFor10ms
	SWI	XOS_ReadMonotonicTime
	ADD	r1, r0, #2
01
	SWI	XOS_ReadMonotonicTime
	TEQ	r0, r1
	BNE	%BT01
 ]

	MOV	r1, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset
	MVN	r2, r1				; deassert reset on FIFO + L64002
	BL	UpdateControlRegister

	LDR	r11, L64002_Registers
	ADRL	r0, SetupData
	ADRL	r1, SetupDataEnd
02
	LDRB	r2, [r0], #1			; register (group) number
	LDRB	lr, [r0], #1			; value
	STRB	lr, [r11, r2, LSL #L64002_Register_Address_Shift]
	CMP	r0, r1
	BCC	%BT02

; now program Audio Output Register, taking into account the card type
; STB2_MPEG2 needs

	LDR	r0, CardProductType
	LDR	lr, =ProdType_STB2_MPEG2
	TEQ	r0, lr
	MOVEQ	r0, #AudioModeControl_DACsAreJap	; if STB2/2, DACs are Japanese type
	MOVNE	r0, #AudioModeControl_DACsAreI2S	; else normal
	WriteRegI r0, AudioModeControl, lr

; now try to read variable which sets VideoOutputModeControl

	ADR	r0, VideoOutputVarName
	MOV	r1, #&FF
	BL	ReadNumericVariable
	MOVVS	r0, #&52			; default to proper value for master mode
	WriteRegI r0, VideoOutputModeControl, lr

; now set up General register and FIFO destination appropriate to the stream type

	LDR	lr, VideoInputType
	TEQ	lr, #0
	BEQ	%FT10			; if field not present, or if type unknown, do normal behaviour
	CMP	lr, #VideoInputType_SystemOrProgramStream
	BHI	%FT10			; type we haven't come across, so use default behaviour
	ADR	r0, %FT05
	LDRB	r0, [r0, lr]
	B	%FT15

	LTORG

05
	=	&00			; should never be used
	=	General_ParallelInput :OR: General_AVElementary
	=	General_ParallelInput :OR: General_AVPESPackets
	=	General_ParallelInput :OR: General_SystemStream
	ALIGN

VideoOutputVarName
	=	"MPEG2$VideoOutputMode", 0
	ALIGN

10
	LDR	r0, VideoStreamFlags
	TST	r0, #StreamFlags_PassThroughToVideo
	MOVEQ	r0, #General_ParallelInput :OR: General_AVPESPackets
	MOVNE	r0, #General_ParallelInput :OR: General_SystemStream	; select system stream mode
15
	DReg	r0, "Setting register 5 to "
	ORR	r1, r0, #General_ResetBuffersAndFIFOs
	WriteReg r1, General		; set up mode, and reset system buffers and data FIFOs in L64002
	WriteReg r0, General		; unreset FIFOs

	MVN	r2, #MPEG2PoduleControl_SystemNotSeparate		; AND mask
	TEQ	r0, #General_ParallelInput :OR: General_SystemStream	; if system stream
	ADREQ	r1, AudioSystemInfoStructure				; then system buffer for video is audio system buffer
	ADRNE	r1, VideoSystemInfoStructure				; else system buffer for video is video system buffer
	STR	r1, VideoInfoStructure+SI_SISPtr
	MVNEQ	r1, r2							; then feed fifo to audio input
	MOVNE	r1, #0							; else feed to video input
	BL	UpdateControlRegister					; route FIFO through to appropriate place

 [ ClearFrameBuffers
	DRAMFill &038600, &65400, 0, r0, r1, r2		; fill first luma frame with zero
;	DRAMFill &09DA00, &32A00, 0, r0, r1, r2		; fill first chroma frames with 0 (green)
	DRAMFill &09DA00, &32A00, &80, r0, r1, r2	; fill first chroma frames with &80 (black)
	DRAMCopyB &038600, &0D0400, &65400, r0, r1	; copy first luma to second
	DRAMCopyB &09DA00, &135800, &32A00, r0, r1	; copy first chroma to second (can't do this at same time as luma, cos
							; DRAM transfers are limited to 64K words)
	DRAMCopyB &038600, &168200, &65400, r0, r1	; copy first luma to third
	DRAMCopyB &09DA00, &1CD600, &32A00, r0, r1	; copy first chroma to third
	B	%FT20
	LTORG
20
 ]

; now enable channel buffers

	MOV	r0, #&80
	WriteReg r0, Status0

	MOV	r0, #352
	STR	r0, CurrentHorizontalSize
	MOV	r0, #288
	STR	r0, CurrentVerticalSize
	MOV	r0, #0
	STR	r0, CurrentTVFormat

; now read addresses of various buffer registers

	ReadRegI r0, VideoChannelBufferStart0
	ReadRegI r1, VideoChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, VideoChannelBufferEnd0
	ReadRegI lr, VideoChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, VideoInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, VideoChannelBufferSize

	ReadRegI r0, AudioChannelBufferStart0
	ReadRegI r1, AudioChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, AudioChannelBufferEnd0
	ReadRegI lr, AudioChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, AudioInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, AudioChannelBufferSize

	ReadRegI r0, VideoPESBufferStart0
	ReadRegI r1, VideoPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, VideoSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, VideoSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, VideoSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, VideoSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, VideoPESBufferEnd0
	ReadRegI r1, VideoPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferEnd

	ReadRegI r0, AudioPESBufferStart0
	ReadRegI r1, AudioPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, AudioSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, AudioPESBufferEnd0
	ReadRegI r1, AudioPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferEnd

	MOV	r0, #0
	MOV	r1, #0
	BL	WriteSCR			; set SCR to zero

	CLRV
	EXIT

	LTORG

debug SETL {FALSE}

; **************************************************************************

Delay	Entry "r0,r1"
	MOV	r1, r0
	SWI	XOS_ReadMonotonicTime
	ADD	r1, r1, r0
10
	SWI	XOS_ReadMonotonicTime
	CMP	r0, r1
	BMI	%BT10
	EXIT

 [ CountUnderruns
VideoEnabledIRQs * IR_PictureStartCodeDetect :OR: IR_BeginVerticalBlank :OR: IR_BeginActiveVideo
VideoIRQsToDisable * VideoEnabledIRQs :OR: IR_VideoChannelBufferUnderflow
 |
VideoEnabledIRQs * IR_PictureStartCodeDetect :OR: IR_BeginVerticalBlank :OR: IR_BeginActiveVideo
VideoIRQsToDisable * VideoEnabledIRQs
 ]
AudioEnabledIRQs * IR_AudioSyncCodeDetect
CommonEnabledIRQs * IR_SCRStatus

VideoClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #TickerV
	ADRL	r1, VideoTickerV
	MOV	r2, wp
	SWI	XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:VideoEnabledIRQs
	BL	UpdateIR

	BL	ClaimFIQs

	MOV	r0, #1
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #TickerV
	ADRL	r1, AudioTickerV
	MOV	r2, wp
	SWI	XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:AudioEnabledIRQs
	BL	UpdateIR

	MOV	r0, #1
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT

CommonClaimInterruptVectors Entry "r0-r4,r11"
	LDR	r0, CommonInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #IOMD_Podule_DevNo
	ADR	r1, MPEGIRQHandler
	MOV	r2, wp
	LDR	r3, Podule_ControlStatus1
	MOV	r4, #MPEG2PoduleStatus1_IRQActive
	SWI	XOS_ClaimDeviceVector
	EXIT	VS

	MOV	r1, #MPEG2PoduleControl_L64002IRQEnable
	MVN	r2, r1
	BL	UpdateControlRegister		; turn on IRQs

	MOV	r0, #IOC
	MOV	r1, pc
	TEQP	pc, #SVC_mode + I_bit		; disable IRQs while modifying mask B
	LDRB	r2, [r0, #IOCIRQMSKB]
	ORR	r2, r2, #podule_IRQ_bit
	STRB	r2, [r0, #IOCIRQMSKB]
	TEQP	r1, #0

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

	MOV	r0, #1
	STR	r0, CommonInterruptVectorsClaimed
	CLRV
	EXIT

VideoReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	BL	ReleaseFIQs

	LDR	r11, L64002_Registers
	LDR	r0, =VideoIRQsToDisable		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

	MOV	r0, #TickerV
	ADRL	r1, VideoTickerV
	MOV	r2, wp
	SWI	XOS_Release

	ADRL	r0, VideoTickerVCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	LDR	r11, L64002_Registers
	LDR	r0, =AudioEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

	MOV	r0, #TickerV
	ADRL	r1, AudioTickerV
	MOV	r2, wp
	SWI	XOS_Release

	ADRL	r0, AudioTickerVCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT


CommonReleaseInterruptVectors Entry "r0-r4, r11"
	LDR	r0, CommonInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	LDR	r11, L64002_Registers
	MOV	r0, #CommonEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

	MOV	r1, #0
;	 MVN	 r2, #MPEG2PoduleControl_L64002IRQEnable :OR: MPEG2PoduleControl_NotL64002Reset
	MVN	r2, #MPEG2PoduleControl_L64002IRQEnable
	BL	UpdateControlRegister		; turn off IRQs but don't reset L64002

	MOV	r0, #IOMD_Podule_DevNo
	ADR	r1, MPEGIRQHandler
	MOV	r2, wp
	LDR	r3, Podule_ControlStatus1
	MOV	r4, #MPEG2PoduleStatus1_IRQActive
	SWI	XOS_ReleaseDeviceVector

	MOV	r0, #0
	STR	r0, CommonInterruptVectorsClaimed
	EXIT

ClaimFIQs Entry "r0-r3"
	MOV	r1, #Service_ClaimFIQ
	SWI	XOS_ServiceCall

; enable FIQ on card, but don't enable it in IOMD
; (we only enable it in IOMD when we have data to send, and the FIQ process disables it in IOMD when there's no data left -
; since these are just write operations, rather than read-modify-write it simplifies things, rather than have the foreground
; disable FIQs while modifying the control register)

	MOV	r1, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	MVN	r2, r1				; enable FIFO FIQ on card
	BL	UpdateControlRegister

	LDR	r0, FIQLDRPCInstr
	ADRL	r1, FIQCodeStart
	MOV	r2, #0
	ADR	r3, FIQSpaceStart
	STMIA	r3, {r0-r2}			; set up LDR PC instruction at &1C and PC to load, zero FIQAmountSent

	ADR	r0, FIQSlotSpace
	STR	r0, FIQSlotWritePtr		; point FIQ slot write ptr at start of slots

 [ Save1stFIQPacket
	ADR	r0, FIQWorkspacePtr
	STR	wp, [r0]			; need to reference our workspace
 ]

; zero out all the FIQ data slots

	ADR	r0, FIQSlotSpace
	MOV	r1, #0
	MOV	r2, #FIQSlotSpaceSize
10
	STR	r1, [r0], #4
	SUBS	r2, r2, #4
	BNE	%BT10

	LDR	r2, FIFO_32_Bit_Write
	LDR	r3, FIFO_8_Bit_Write

	MOV	r0, pc
	BIC	r1, r0, #3
	ORR	r1, r1, #FIQ_mode
	TEQP	r1, #0				; enter FIQ mode
	NOP

	ADR	r8, FIQSlotSpace		; point at first slot
	MOV	r9, r2				; r9 -> 32-bit FIFO writes
	MOV	r10, r3				; r10 -> 8-bit FIFO writes
	ADR	r13, FIQStackEnd		; and set up FIQ stack pointer

	TEQP	r0, #0				; go back to SVC mode
	NOP

	EXIT

FIQLDRPCInstr
	LDR	pc, %FT95
95

ReleaseFIQs Entry "r0-r2"
	MOV	r1, #0
	MVN	r2, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	BL	UpdateControlRegister		; disable FIFO FIQ on card

	MOV	r1, #Service_ReleaseFIQ
	SWI	XOS_ServiceCall
	EXIT

; **************************************************************************
;
;	InitSAA7167 - Initialise IIC D-to-A converter/mixer chip

InitSAA7167 Entry "r0-r2"
	LDR	r0, CardProductType
	LDR	lr, =ProdType_STB1_MPEG2
	TEQ	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2
	TEQNE	r0, lr
	EXIT	EQ				; if either of those, the 7167 is not on the card, so exit

; must be old-style card

	MOV	r0, #IICAddress_SAA7167
	ADR	r1, SAA7167InitBlock0
	MOV	r2, #2
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

; Initially we only program register 0 in this device, which has the following bits:-

; Bits 1..0: FMTC1/FMTC0 = 10 => YUV 2:1:1 CCIR656
; Bit 2:     KINV=1 => EXTKEY= LOW for Mprg, HIGH for Computer
; Bit 3:     KEN=1 Key connected to ED0
; Bit 4:     DRP=0 => 2's Complement UV data
; Bits 7..5: KMOD2/1/0 = 000 => Use EXTernal KEY

SAA7167InitBlock0
	=	0, 2_00001110

; **************************************************************************
;
;	MPEGIRQHandler - Handler for IRQs off MPEG card
;
; in:	-
; out:  r0-r3 may be corrupted

MPEGIRQHandler Entry "r11"
	LDR	r3, Podule_ControlStatus1
	LDRB	r3, [r3]

	TST	r3, #MPEG2PoduleStatus1_NotL64002Interrupt
	BLEQ	L64002IRQ
 [ {FALSE}
	TST	r3, #MPEG2PoduleStatus1_FIFONotEmpty
	BLEQ	FIFOIRQ

KillIRQExit
	TEQP	pc, #SVC_mode + I_bit
	MOV	r0, r0
	Push	"lr"
	BL	ReleaseIRQVector
	Pull	"lr"
	TEQP	pc, #IRQ_mode + I_bit
	MOV	r0, r0
 ]
	EXIT

	LTORG

; **************************************************************************
;
;	L64002IRQ - Handler for L64002 IRQs
;
; in:	-
; out:  r0-r2, r11 may be corrupted

L64002IRQ Entry "r3"
	LDR	r11, L64002_Registers
	ReadReg	r0, IR0				; this clears all interrupts in Status 0
	ReadReg r1, IR1				; ditto for Status 1
	ORR	r0, r0, r1, LSL #8		; form 1 word with all IRQs in
	LDR	r1, IRSoftCopy
	ORR	r1, r1, #1			; video enable bit doesn't count
	BICS	r0, r0, r1			; only look at bits that are actually enabled
	EXIT	EQ				; [none, so exit]
	ADR	r1, IRQCounts
	MOV	r3, #0
10
	MOVS	r0, r0, LSR #1
	LDRCS	r2, [r1, r3, LSL #2]
	ADDCS	r2, r2, #1
	STRCS	r2, [r1, r3, LSL #2]
	BLCS	DespatchIRQ
	ADD	r3, r3, #1
	BNE	%BT10
	EXIT

DespatchIRQ Entry "r0-r3"
	ADR	r0, IRQDespatchTable
	LDR	r1, [r0, r3, LSL #2]
	MOV	lr, pc
	ADD	pc, r0, r1
	EXITS

IRQDespatchTable
	&	IgnoreIRQ - IRQDespatchTable		; Decode Status
	&	IgnoreIRQ - IRQDespatchTable		; User Data FIFO Ready
	&	IgnoreIRQ - IRQDespatchTable		; Decode Error
	&	AudioSyncCodeIRQ - IRQDespatchTable	; Audio Sync Code detected
	&	PictureStartCodeIRQ - IRQDespatchTable  ; Picture Start Code detect
	&	SCRStatusIRQ - IRQDespatchTable		; System Clock Reference Status
	&	IgnoreIRQ - IRQDespatchTable		; Pack Data Ready
	&	IgnoreIRQ - IRQDespatchTable		; DRAM Transfer Done
	&	IgnoreIRQ - IRQDespatchTable		; Audio Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable		; Video Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable		; Audio Channel Buffer Underflow
 [ CountUnderruns
	&	VideoChannelUnderrunIRQ - IRQDespatchTable ; Video Channel Buffer Underflow
 |
	&	IgnoreIRQ - IRQDespatchTable		; Video Channel Buffer Underflow
 ]
	&	BeginActiveVideo - IRQDespatchTable	; Begin Active Video
	&	BeginVerticalBlank - IRQDespatchTable	; Begin Vertical Blank
	&	IgnoreIRQ - IRQDespatchTable		; Audio PES Data Ready (don't use this as not all data is there
							;  when IRQ happens)
	&	IgnoreIRQ - IRQDespatchTable		; Video PES Data Ready

IgnoreIRQ
	MOV	pc, lr

; Audio Sync Code Detect IRQ
; r0-r3 can be junked

AudioSyncCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working audio sync code read ptr, so read that instead

	ReadRegI r0, AudioSyncCodeRead0
	ReadRegI lr, AudioSyncCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, AudioSyncCodeRead2
	ORR	r0, r0, lr, LSL #16

 |
; read the Audio Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, AudioInfoStructure
	BL	CheckSystemBuffer		; read any audio system buffer data

	BL	ProcessAudioReadPtr		; compare audio channel buffer read ptr in r0 with audio PTS list entries

	ReadRegI r0, AudioParameter0
	ReadRegI r1, AudioParameter1
	AND	r0, r0, #3			; get bottom 2 bits of audio rate
	TST	r1, #&80			; if RATE bit set
	ORRNE	r0, r0, #4			; then set bit 2 of combined rate
	STR	r0, AudioSampleRate

	ADR	r1, SampleRateProgTable
	LDR	r1, [r1, r0, LSL #2]		; extract 3 bytes of registers
	WriteRegI r1, AudioFrequencyNMOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNMOSCNOSC1, lr
	EXIT

	MACRO
	SampleRateInfo	$n, $nm
	=	($nm) :AND: &FF								; Register 6.49
	=	($n) :AND: &FF								; Register 6.50
	=	((($nm) :SHR: 8) :AND: 15) :OR: (((($n) :SHR: 8) :AND: 3) :SHL: 4)	; Register 6.51
	=	0									; padding
	MEND

SampleRateProgTable
	SampleRateInfo	98, -1777		; 22.05 kHz
	SampleRateInfo	64, -1061		; 24 kHz
	SampleRateInfo	128, -3247		; 16 kHz
	SampleRateInfo	0, 0
	SampleRateInfo	196, -1679		; 44.1 kHz
	SampleRateInfo	128, -997		; 48 kHz
	SampleRateInfo	256, -3119		; 32 kHz
	SampleRateInfo	0, 0

; Picture Start Code IRQ
; We use this to read the Aux FIFO and check the video system buffer
; r0-r3 can be junked

PictureStartCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working picture start code read ptr, so read that instead
	ReadRegI r0, PictureStartCodeRead0
	ReadRegI lr, PictureStartCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PictureStartCodeRead2
	ORR	r0, r0, lr, LSL #16
 |
; read the Video Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, VideoInfoStructure
	BL	CheckSystemBuffer		; read any video system buffer data

	BL	ProcessAuxFIFO			; ensure we have updated picture type before checking for PTS being valid

	BL	ProcessVideoReadPtr
	LDR	lr, FirstItemReceived
	TEQ	lr, #0				; if not received picture or sequence yet
	MOVEQ	lr, #2
	STREQ	lr, FirstItemReceived		; then indicate picture first
	EXIT

ProcessAuxFIFO Entry "r0-r2"
10
	ReadReg r0, Status0			; determine if Aux FIFO has any data in it
	AND	r1, r0, #L64002_Status0_ADFSBits
	TEQ	r1, #L64002_Status0_AuxDataFIFOEmpty ; if no data
	EXIT	EQ				; then exit

	AND	r0, r0, #L64002_Status0_AuxIDBits
	MOV	r0, r0, LSR #L64002_Status0_AuxIDShift
	CMP	r0, #3
	BCC	%FT20
	ReadRegI r0, AuxiliaryDataFIFO		; not recognised, so read a byte from FIFO
	B	%BT10				; and loop

20
	ADR	r1, AuxInfoTable
	LDR	r1, [r1, r0, LSL #2]
	ADD	r2, wp, r1, LSR #8		; r2 -> area to dump info to
	AND	r1, r1, #&FF			; r1 = length of data
30
	ReadRegI lr, AuxiliaryDataFIFO
	STRB	lr, [r2], #1
	SUBS	r1, r1, #1
	BNE	%BT30

	TEQ	r0, #0				; is it sequence data?
	BNE	%BT10				; [no, so skip]

	LDR	lr, FirstItemReceived
	TEQ	lr, #0				; if not received picture or sequence yet
	MOVEQ	lr, #1
	STREQ	lr, FirstItemReceived		; then indicate sequence first

	LDRB	r0, VideoSequence_VBVBufferSize +0
	LDRB	r1, VideoSequence_VBVBufferSize +1
	ORR	r0, r1, r0, LSL #8		; VBV buffer size in units of 16K bits, ie 2K bytes
	MOV	r0, r0, LSL #11			; convert to bytes
	LDR	r1, VideoChannelBufferSize	; but don't exceed video channel buffer size
	CMP	r0, r1
	MOVHI	r0, r1
	STR	r0, VideoVBVSize

	LDRB	r0, VideoSequence_HorizontalSize +0	; *high* byte of horiz size
	LDRB	lr, VideoSequence_HorizontalSize +1	; *low* byte of horiz size
	ORR	r0, lr, r0, LSL #8			; r0 = xres

	LDRB	r1, VideoSequence_VerticalSize +0	; high byte of vertical size
	LDRB	lr, VideoSequence_VerticalSize +1	; low byte of vertical size
	ORR	r1, lr, r1, LSL #8			; r1 = yres

	LDR	lr, CardProductType			; check what type of card it is
	CMP	lr, #-1					; if unknown, then assume it's my vanilla card
	BEQ	%FT40					; so work out PAL/NTSC from frame rate

	LDR	lr, VideoStructureFlags			; else check video structure flags
	TST	lr, #VideoStructureFlags_NTSC		; if requesting NTSC output
	MOVNE	r2, #1					; then use it
	MOVEQ	r2, #0					; else use PAL
	B	%FT50

; For now set up the video output mode as per the source material wrt PAL/NTSC
; cos I know my TV can do both.

40
	LDRB	r2, VideoSequence_PictureRate		; r2 = picture rate index
	CMP	r2, #PictureRate_25000			; if more than 25Hz
	MOVHI	r2, #1					; indicate NTSC
	MOVLS	r2, #0					; else indicate PAL
50
	BL	SetupScreenMode

	LDR	lr, SequenceCount
	SUBS	lr, lr, #1				; decrement sequence count
	STRCS	lr, SequenceCount			; if >= 0, store back
	BHI	%BT10					; only start decoded field count once we get to zero

	LDR	lr, DecodedFieldCount
	CMP	lr, #-1					; if waiting for good sequence data
	MOVEQ	lr, #0					; then set count to 0
	STREQ	lr, DecodedFieldCount
	B	%BT10					; go back for more data from Aux FIFO

AuxInfoTable
	&	12 :OR: ((:INDEX: VideoSequenceData)   :SHL: 8)
	&	6  :OR: ((:INDEX: GroupOfPicturesData) :SHL: 8)
	&	5  :OR: ((:INDEX: PictureData)	       :SHL: 8)


; Begin Vertical Blank interrupt
; r0-r3 can be junked

BeginVerticalBlank Entry
	LDR	r0, DecodedFieldCount
	CMP	r0, #0
	EXIT	LT
	ADD	r0, r0, #1
	LDR	lr, BlankedFields		; number of fields after decode start that it's safe to unblank screen
	CMP	r0, lr
	MOVCS	r0, #-2				; reset to -2 so no more unblanking, and we know display is safe
	STR	r0, DecodedFieldCount
	EXIT	CC

	ReadRegI r0, OSDControl
	BIC	r0, r0, #OSDControl_VideoBlack	; unblank
	WriteRegI r0, OSDControl, r1

 [ PerformFieldInversion
	MOV	r0, #2
	STR	r0, FieldInversionState
 ]
	EXIT

 [ TrickPlaySupport
	MACRO
	DoUnderrunFix
        LDR	r0, TrickPlayMode
	TEQ	r0, #0				; if not doing trick play
	LDRNE	r0, VideoStructureFlags
	TSTNE	r0, #VideoStructureFlags_TrickPlayUnderrunFix ; or underrun fix not enabled
	BEQ	%FT09				; then skip this stuff

	LDR	r0, VideoPreFilling
	TEQ	r0, #0
	BNE	%FT09				; [prefilling, so don't start decoder]

	LDR	r0, VideoStreamClosing
	CMP	r0, #1				; if shutting down then we'd better restart decoder
	BCS	%FT04				; so that buffers can empty, so set C=1

	BL	VideoGetBufferFullness		; else check if we have enough data in video channel
;	LDR	r0, VideoVBVSize
	LDR	r0, =VideoPreFillSize
	CMP	r2, r0
04
	MVN	r1, #IR_DecodeStatus
	MVNCS	r0, r1				; if enough, start decoder
	ADRCS	r2, TrickStarts
	MOVCS	r3, #0				; unfreeze field
	MOVCC	r0, #0				; if not, stop it
	ADRCC	r2, TrickStops
	MOVCC	r3, #1				; freeze field
	BL	UpdateIR

	LDR	lr, [r2]
	ADD	lr, lr, #1			; increment either TrickStops or TrickStarts
	STR	lr, [r2]

  [ FreezeFieldOnTrickStop
	STR	r3, TrickStopFreeze
	MOV	r0, #1
	STR	r0, FreezeUpdate
  ]
09
	MEND
 ] ; TrickPlaySupport

; Begin Active Video interrupt
; r0-r3 can be junked

BeginActiveVideo Entry "r4,r5,r8"

 [ TrickPlaySupport :LAND: :LNOT: UnderrunFixOnlyOnOddFields
	DoUnderrunFix
 ]

 [ PerformFieldInversion
	LDR	r0, FieldInversionState		; 2 => freeze, 1 => unfreeze, 0 => do nowt
	CMP	r0, #1
	BCC	%FT05
	ReadRegI r1, DisplayMode0
	ORRHI	r1, r1, #2			; if freezing, set bit
	BICEQ	r1, r1, #2			; if unfreezing, clear bit
	WriteRegI r1, DisplayMode0, lr
	Push	"r0"
	MOVHI	r0, #0				; stop decoder
	MOVEQ	r0, #1				; start decoder
	MVN	r1, #1
	BL	UpdateIR
	Pull	"r0"
	SUB	r0, r0, #1			; decrement state
	STR	r0, FieldInversionState		; and store back
05
 ]
	ReadRegI r0, DisplayControllerStatus
 [ CountFieldInversions
	AND	r0, r0, #3
	TEQ	r0, #0				; if not 0
	TEQNE	r0, #3				; or 3
	LDRNE	r1, FieldInversions		; then fields have inverted
	ADDNE	r1, r1, #1
	STRNE	r1, FieldInversions
 ]
	TST	r0, #1				; check if an odd field
	EXIT	NE				; [it's not, so exit]

 [ TrickPlaySupport :LAND: UnderrunFixOnlyOnOddFields
	DoUnderrunFix
 ]
; now check for pending freeze update

	LDR	r1, FreezeUpdate
	TEQ	r1, #0
	BEQ	%FT07
	LDR	r1, PendingFreezeState
	TEQ	r1, #0				; if 0 then unfrozen, so write 0
  [ FreezeFieldOnTrickStop
	LDREQ	r1, TrickStopFreeze
	TEQEQ	r1, #0
  ]
	MOVNE	r1, #DisplayMode0_FreezeField	; else frozen, so write FreezeField bit to 1
	WriteRegI r1, DisplayMode0, lr
	MOV	r1, #0
	STR	r1, FreezeUpdate
07


 [ CountUnderruns
	LDR	r1, UnderrunIRQState
	TEQ	r1, #1
	MOVEQ	r1, #2				; indicate complete
	STREQ	r1, UnderrunIRQState
	MOVEQ	r0, #0				; enable underrun IRQ
	MVNEQ	r1, #IR_VideoChannelBufferUnderflow
	BLEQ	UpdateIR
 ]

 [ CountVideoPackets
	LDR	r1, SyncMode			; if we're counting video packets for sync
	TEQ	r1, #0				; then do count here, else do normal sync
	BEQ	%FT10

	ADR	r8, VideoInfoStructure
	BL	CheckSystemBuffer		; read any video system buffer data, in case we're stalled

	LDR	r1, VideoPacketsReceived
	LDR	lr, VideoPicturesReceived

; now add to stats data

	LDR	r0, VideoSyncPos
	CMP	r0, #?VideoSyncStats
	ADRCCL	r4, VideoSyncStats
	ADDCC	r4, r4, r0
	STMCCIA	r4, {r1,lr}			; store packets, pictures
	ADDCC	r0, r0, #8
	STRCC	r0, VideoSyncPos

	SUBS	r1, r1, lr
	CMP	r1, #1
	LDRGT	lr, VideoOKCount
	ADDGT	lr, lr, #1
	STRGT	lr, VideoOKCount
	EXIT	GT				; if had more packets than pictures, OK to let go

	MOV	r1, #VideoTrickModes_Repeat
	WriteRegI r1, VideoTrickModes, lr	; else force a repeat
	LDR	lr, VideoRepeats
	ADD	lr, lr, #1
	STR	lr, VideoRepeats
	EXIT
10
 ]

 [ AllowSyncOnIFrames
	LDR	r1, SyncMode
	TEQ	r1, #0
	ADREQ	r5, VideoPostedPTS		; point at normal sync posted PTS
	MOVEQ	r4, #-1				; indicate normal syncing
	BEQ	%FT15				; normal syncing

	LDR	lr, AnchorPostedPTSWritePtr	; get FIFO write pointer
	SUBS	lr, lr, #2			; move back two
	EXIT	CC				; if not already written 2 words in there then exit
	LDR	r4, AnchorPostedPTSReadPtr
	CMP	r4, lr				; if we've read as many as we've written-2
	EXIT	CS				; then exit
	AND	lr, r4, #3			; wrap around FIFO
	ADR	r1, AnchorPostedPTSs		; point at FIFO
	ADD	r5, r1, lr, LSL #3		; point at correct entry
15
 |
	ADR	r5, VideoPostedPTS
 ]
	LDMIA	r5, {r0, r3}			; get posted PTS
	TEQ	r3, #0
	BMI	SkipPostedPTS			; no PTS posted, so exit

 [ :LNOT: AllowSyncOnIFrames
	MOV	lr, #-1
	STR	lr, [r5, #4]			; cancel posted PTS
 ]
	LDR	lr, VideoStreamFlags
	TST	lr, #StreamFlags_NoLipSync
	BNE	SkipPostedPTS

	ReadRegI lr, VideoTrickModes
	TST	lr, #VideoTrickModes_ValidBits
	BNE	SkipPostedPTS			; still a skip or repeat in operation

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if normal syncing, skip this
	BEQ	%FT18
; If SyncMode flag = 1, then this is the first PTS after the ResetStream,
; so use this to write the SCR instead of comparing

	LDR	lr, SyncMode
	TEQ	lr, #1
	BNE	%FT18

	MOV	r1, r3				; put bit 33 into r1 (WriteSCR takes r0,r1)
	BL	WriteSCR
	MOV	lr, #2
	STR	lr, SyncMode			; indicate we've done one
	B	SkipPostedPTS			; and remove this PTS from list
18
 ]
	BL	ReadSCR				; read SCR in r1, r2
	SUBS	r0, r0, r1
	SBC	r3, r3, r2			; form PTS - SCR
	ANDS	r3, r3, #1			; only interested in bit32 of difference
	LDR	r3, =MaxPTSError
	BNE	%FT50				; [PTS < SCR]

; PTS > SCR - see if it's more than about a frame (3600 ticks)

	CMP	r0, r3
	MOVCC	lr, #0
	STRCC	lr, LastVideoPTSErrorSign	; last one was within range
	BCC	SkipPostedPTS			; not sufficiently out

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if we're doing I-frame syncing
	BNE	%FT40				; don't bother with hysteresis
 ]
	LDR	lr, LastVideoPTSErrorSign	; was last error positive as well?
	TEQ	lr, #1
	MOVNE	lr, #1				; if not, then store current direction
	STRNE	lr, LastVideoPTSErrorSign
	BNE	SkipPostedPTS			; but don't repeat this time
40

	LDR	lr, VideoRepeats		; one more repeat
	ADD	lr, lr, #1
	STR	lr, VideoRepeats

	LDR	lr, VideoMaxPTSDifference
	CMP	r0, lr
	STRGT	r0, VideoMaxPTSDifference

	MOV	r0, #VideoTrickModes_Repeat
	WriteRegI r0, VideoTrickModes, lr
	EXIT

50
	ADDS	r0, r0, r3			; if within approx one frame
	MOVCS	lr, #0
	STRCS	lr, LastVideoPTSErrorSign	; last one was within range
	BCS	SkipPostedPTS			; don't do anything

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if we're doing I-frame syncing
	BNE	%FT55				; don't bother with hysteresis
 ]
	LDR	lr, LastVideoPTSErrorSign	; was last error negative as well?
	CMP	lr, #-1
	MOVNE	lr, #-1
	STRNE	lr, LastVideoPTSErrorSign	; if not, then store current direction
	BNE	SkipPostedPTS			; but don't skip this time
55
	LDR	lr, VideoSkips
	ADD	lr, lr, #1
	STR	lr, VideoSkips

	SUB	r0, r0, r3
	LDR	lr, VideoMinPTSDifference
	CMP	r0, lr
	STRLT	r0, VideoMinPTSDifference

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; are we syncing on I-frames
	MOVEQ	r0, #VideoTrickModes_SkipB
	MOVNE	r0, #VideoTrickModes_SkipAny
 |
	MOV	r0, #VideoTrickModes_SkipB
 ]
	WriteRegI r0, VideoTrickModes, lr
SkipPostedPTS
 [ AllowSyncOnIFrames
	MOV	lr, #-1
	STR	lr, [r5, #4]			; cancel posted PTS
	ADD	r4, r4, #1			; discard this PTS
	STR	r4, AnchorPostedPTSReadPtr	; and store back read ptr
 ]
	EXIT


; SCR Status IRQ
; r0-r3 can be junked

SCRStatusIRQ Entry "r0"
	BL	CheckErrorStatus
	EXIT

	MACRO
	DoDRAMGetByte	$underrun
	BL	DRAMGetByte
	BVS	$underrun
	MEND

 [ CountUnderruns
; Video Channel underrun IRQ

VideoChannelUnderrunIRQ Entry
	LDR	lr, VideoChannelUnderruns
	ADD	lr, lr, #1
	STR	lr, VideoChannelUnderruns

; now disable buffer underflow interrupt, so it doesn't happen again
	MOV	r0, #IR_VideoChannelBufferUnderflow ; set the bit to disable the IRQ
	MVN	r1, #IR_VideoChannelBufferUnderflow
	BL	UpdateIR
	EXIT
 ]

; **************************************************************************
;
;	SetupScreenMode - Program screen mode registers in L64002
;
; in:	r0 = xres
;	r1 = yres
;	r2 = 0 for PAL, 1 for NTSC
;
; out:	-


SetupScreenMode Entry "r2-r5"
 [ {FALSE} ; debug x 2 size
	MOV	r0, r0, LSR #1
	MOV	r1, r1, LSR #1
 ]
	ASSERT	CurrentVerticalSize = CurrentHorizontalSize + 4
	ASSERT	CurrentTVFormat = CurrentHorizontalSize + 8
	ADR	lr, CurrentHorizontalSize
	LDMIA	lr, {r3-r5}			; load old settings

	TEQ	r0, r3
	TEQEQ	r1, r4
	TEQEQ	r2, r5
	EXIT	EQ				; all the same, so do nothing

	STMIA	lr, {r0-r2}			; save out new parameters

	CMP	r1, #288			; if more than 288
	MOVHI	r3, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_InterlaceChromaFieldRepeatFilterChroma
						; then full interlaced picture
	MOVLS	r3, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_ProgressiveFilterLuma
						; else just SIF
	WriteRegI r3, DisplayMode1, lr

 [ FudgeQSIF
	MOVLS	r3, r0, LSL #1			; if SIF or less, use width = 2 x xres
	BLS	%FT05
 ]
	MOV	r3, #704
	BL	GetHCF
	MOV	r4, r3				; save HCF of (xres, 704)

	MOV	r3, #720
	BL	GetHCF				; get HCF of (xres, 720)
	CMP	r3, r4
	ORRHI	r2, r2, #2			; if HCF is higher with 720, set bit 1 of TV format to form index into table
	MOVHI	r3, #720
	MOVLS	r3, #704
	STR	r3, CurrentOutputWidth
05
	MOV	r4, r0, LSL #8			; r4 = xres*256
	DivRem	r5, r4, r3, lr			; r5 = xres*256/outputwidth, r4 = remainder
	TEQ	r4, #0				; if remainder non-zero
	ADDNE	r5, r5, #1			; round up
	WriteRegI r5, RasterMapperIncrement, lr	; write raster mapper increment

; now work out MainReadsPerLine/DisplayWidth registers, including top bits which are determined by PAL/NTSC

	ADD	r3, r0, #7
	MOV	r3, r3, LSR #3			; xres/8
	TST	r2, #1				; if PAL
	ORREQ	r3, r3, #&80			; then set top bit
	WriteRegI r3, MainReadsPerLine, lr	; and write to MainReadsPerLine
	WriteRegI r3, DisplayWidth, lr		; and DisplayWidth

	ADR	lr, ScreenParamsTable
	LDR	r3, [lr, r2, LSL #2]
	ADD	r3, lr, r3			; r3 -> table for appropriate mode
10
	LDR	r4, [r3], #4
	CMP	r4, #-1
	EXIT	EQ
	WriteReg r4, AIR			; byte 0 is index within bank
	MOV	r4, r4, LSR #8			; byte 1 is register value
	MOV	lr, r4, LSR #8			; byte 2 is register number
	STRB	r4, [r11, lr, LSL #L64002_Register_Address_Shift]
	B	%BT10

; GetHCF - r3 = highest common factor of r0 and r3

GetHCF	Entry "r0, r1"
	CMP	r0, r3				; ensure r0 >= r3 before we start
	EORCC	r0, r0, r3
	EORCC	r3, r3, r0
	EORCC	r0, r0, r3
10
	DivRem	r1, r0, r3, lr			; r1 = r0/r3; r0=r0 mod r3
	TEQ	r0, #0				; if remainder non-zero
	MOVNE	r0, r3				; then shuffle up numbers
	MOVNE	r3, r1
	BNE	%BT10				; and loop
	EXIT					; else exit with r3 = HCF

ScreenParamsTable
	&	ScreenParamsPAL704-ScreenParamsTable
	&	ScreenParamsNTSC704-ScreenParamsTable
	&	ScreenParamsPAL720-ScreenParamsTable
	&	ScreenParamsNTSC720-ScreenParamsTable

	MACRO
	MakeRegisterEntry $reg, $value
	&	L64002_$reg._Addr2 :OR: (($value):SHL:8) :OR: (L64002_$reg._Addr1 :SHL: (16-L64002_Register_Address_Shift))
	MEND

	MACRO
$label	MakeScreenParams $hsw,$eqw,$ser,$hbl,$hfln,$actim, $prebl,$mnln,$postbl,$preeqhln,$serhln,$posteqhln,$scanhln
$label
	ASSERT	$hsw :AND: :NOT: &FF = 0
	ASSERT	$eqw :AND: :NOT: &FF = 0
	ASSERT	$ser :AND: :NOT: &3FF = 0
	ASSERT  $hbl :AND: :NOT: &1FF = 0
	ASSERT	$actim :AND: :NOT: &3FF = 0
	ASSERT	$hfln :AND: :NOT: &3FF = 0
	ASSERT	$prebl :AND: :NOT: &1F = 0
	ASSERT	$preeqhln :AND: :NOT: 7 = 0
	ASSERT	$postbl :AND: :NOT: &1F = 0
	ASSERT	$posteqhln :AND: :NOT: 7 = 0
	ASSERT	$mnln :AND: :NOT: &3F = 0
	ASSERT	$serhln :AND: :NOT: 7 = 0
	ASSERT	$scanhln :AND: :NOT: &1FF = 0
	MakeRegisterEntry HorizSyncWidth, $hsw
	MakeRegisterEntry EqualizationPulseWidth, $eqw
	MakeRegisterEntry SerrationPulseWidth, ($ser :AND: &FF)
	MakeRegisterEntry HorizBlankPulseWidth, ($hbl :AND: &FF)
	MakeRegisterEntry ActiveImageDone, ($actim :AND: &FF)
	MakeRegisterEntry HalfLineTime, ($hfln :AND: &FF)
	MakeRegisterEntry UpperBits, ($ser:SHR:8) :OR: (($hbl:SHR:8):SHL:2) :OR: (($actim:SHR:8):SHL:3) :OR: (($hfln:SHR:8):SHL:5)
	MakeRegisterEntry VertiPreBlankEqualization, ($preeqhln :SHL: 5) :OR: $prebl
	MakeRegisterEntry VertiPostBlankEqualization, ($posteqhln :SHL: 5) :OR: $postbl
	MakeRegisterEntry VertiMainSerrationLines, ($serhln :SHL: 5) :OR: ($mnln :AND: &1F)
	MakeRegisterEntry VertiScanHalfLines, ($scanhln :AND: &FF)
	&	-1
	MEND

ScreenParamsPAL704	MakeScreenParams 127,62,737,276,863,820, 23,36,1,5,5,5,305
ScreenParamsPAL720	MakeScreenParams 127,62,737,260,863,836, 23,36,1,5,5,5,305
ScreenParamsNTSC704	MakeScreenParams 129,64,729,256,857,806, 17,30,5,6,6,6,253
ScreenParamsNTSC720	MakeScreenParams 129,64,729,240,857,822, 17,30,5,6,6,6,253

; **************************************************************************
;
;	CheckSystemBuffer - Check contents of system buffer for packet headers with PTSs
;			    and add them to the PTSList
;
; in:	r8 -> audio or video info structure
;	r11 -> L64002 registers
;	IRQ mode, IRQs disabled
;
; out:	All registers preserved

CheckSystemBuffer Entry "r0-r9"
	LDR	r9, [r8, #SI_SISPtr]		; r9 -> streaminfo system structure
	MOV	r0, #-1
	STR	r0, DRAMBufferAddress		; invalidate any data already in buffer
	LDR	r0, [r9, #SIS_SystemWrite0Reg]
	STRB	r0, [r11, #L64002_AIR]
	LDR	r0, [r9, #SIS_SystemWrite0Group]
	LDRB	r0, [r11, r0]			; read system buffer write ptr LSB
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #&03			; mask off wrapping bits for now
	ORR	r0, r0, lr, LSL #16
	MOV	r0, r0, LSL #3			; r0 = byte address of system buffer write address
	STR	r0, [r9, #SIS_SystemBufferWritePtr] ; last reading of write pointer
	LDR	r1, [r9, #SIS_SystemBufferReadPtr]

;	LDR	r2, [r8, #SI_PTSListReadPtr]
;	LDR	r3, [r8, #SI_PTSListWritePtr]
;	LDR	r4, [r8, #SI_PTSListPtr]
10
	STR	r1, [r9, #SIS_SystemBufferReadPtr] ; save where we're at
	TEQ	r0, r1				; is there any data for us?
	EXIT	EQ				; [no, then exit]
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70				; not a system start code, skip to next word
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #1
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	MOV	r8, #0				; by default indicate not a packet header we're interested in
	MOV	lr, r5, LSR #4
	TEQ	lr, #&E				; stream ids &E0-&EF are video packets
	ADREQ	r8, VideoInfoStructure
	TEQ	lr, #&C				; stream ids &C0-&DF are audio packets
	TEQNE	lr, #&D
	ADREQ	r8, AudioInfoStructure
	TEQ	r8, #0
	BEQ	%FT75				; [not packet code of interest, check for pack or system header]
 [ CountVideoPackets
	TEQ	lr, #&E
	LDREQ	lr, VideoPacketsReceived
	ADDEQ	lr, lr, #1
	STREQ	lr, VideoPacketsReceived
 ]
	BL	DRAMGetByte			; get length hi
	BLVC	DRAMGetByte			; get length lo
	BVS	UnderrunExit
20
	DoDRAMGetByte UnderrunExit		; skip stuffing bytes (the MPEGControl module and/or L64002 may have removed them)
	TEQ	r5, #&FF
	BEQ	%BT20

	MOV	lr, r5, LSR #6
	TEQ	lr, #1				; is there an STB_buffer_scale/size?
	BNE	%FT30
	BL	DRAMGetByte			; skip 2nd byte of STB_buffer_scale/size
	BLVC	DRAMGetByte			; get next byte
	BVS	UnderrunExit
30
	MOV	lr, r5, LSR #6
	TEQ	lr, #2				; is it MPEG 2 PES?
	BEQ	%FT60

	MOVS	lr, r5, LSR #4
	BEQ	%FT55				; [no PTS or DTS]
	TEQ	lr, #2
	BNE	%FT50				; [not PTS on its own]

	BL	GetClockReference		; returns PTS value in r6, r7
	BVS	UnderrunExit
32
	BL	RoundUpToWord			; round up to whole word boundary
	ADD	r1, r1, #5			; address starts at offset 5 in this word
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #24+2		; hi-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #16+2		; mid-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #8+2		; lo-byte of pointer

; now check the address for sanity, as the L64002 seems to put in duff ones now and again

	MOV	lr, r7, LSR #10-3		; convert to byte address
	BIC	lr, lr, #&1E00000		; knock out wrap bits
	LDR	r5, [r8, #SI_ChannelBufferStart]
	CMP	lr, r5				; is it below start of channel buffer
	BCC	%FT34
	LDR	r5, [r8, #SI_ChannelBufferEnd]
	CMP	lr, r5				; or after the end of it?
	BCC	%FT36
34
	LDR	lr, [r9, #SIS_DuffChannelAddresses] ; increment count of gaffs
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffChannelAddresses]
	B	%BT10				; don't output item (no need to round up as we're already there)

36
; r7 now holds bit 32 of PTS in bit 0, and pointer field in bits 10..31 (including wrap bits)

	LDR	r4, [r8, #SI_PTSListPtr]	; load appropriate PTS list ptr
	LDR	r3, [r8, #SI_PTSListWritePtr]	; and offset
	ADD	lr, r4, r3, LSL #3
	STMIA	lr, {r6, r7}

	ADD	r3, r3, #1
	LDR	lr, [r8, #SI_PTSListSize]
	TEQ	r3, lr				; wrap PTS list index
	MOVEQ	r3, #0
	LDR	r2, [r8, #SI_PTSListReadPtr]
	TEQ	r3, r2				; if full then exit
	BEQ	%FT40
	STR	r3, [r8, #SI_PTSListWritePtr]	; then store back
	B	%BT10

40
	LDR	lr, [r8, #SI_PTSListOverruns]	; increment count of PTS list overruns
	ADD	lr, lr, #1
	STR	lr, [r8, #SI_PTSListOverruns]
	B	%BT10

UnderrunExit
	EXIT

; not MPEG 2, and not just &0F, and not just PTS, so check for PTS+DTS

50
	TEQ	lr, #3				; check if PTS+DTS
	BNE	%FT70				; [not that]

; it's PTS + DTS

	BL	GetClockReference		; get PTS
	BVS	UnderrunExit
	Push	"r7"
	MOV	r7, #5				; now skip DTS
	BL	SkipR7Bytes
	Pull	"r7"
	BVS	UnderrunExit
	B	%BT32				; pass PTS to code that reads ptr field

; no PTS or DTS, so skip pointer field to complete item

55
	BL	RoundUpToWord			; round up to whole word boundary
	DoDRAMGetByte UnderrunExit		; check pointer field there
	BL	RoundUpToWord			; round up again to skip whole word
	B	%BT10

; it's an MPEG 2 PES packet

60
	DoDRAMGetByte UnderrunExit		; get flags byte
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit		; get header length
	TST	r7, #&80
	BEQ	%FT65				; no PTS or DTS
	SUB	r5, r5, #5			; adjust header length to account for PTS we're about to extract
	Push	"r5, r7"			; save remaining header length + a slot for saving r7 later
	BL	DRAMGetByte			; get 1st byte of PTS
	BLVC	GetClockReference
	Pull	"r5, r7", VS			; if we underrun, flatten stack
	BVS	UnderrunExit			; and exit indicating underrun

	STR	r7, [sp, #4]			; save high word temporarily
	Pull	"r7"				; restore count of bytes to skip
	BL	SkipR7Bytes
	Pull	"r7"				; restore high word of PTS
	BVS	UnderrunExit			; if skip failed indicate underrun
	B	%BT32				; go to code that reads ptr field

; MPEG 2 PES with no PTS

65
	MOV	r7, r5				; skip rest of header
	BL	SkipR7Bytes
	BVS	UnderrunExit
	B	%BT55				; then skip pointer field

; we got rubbish in system buffer

70
	LDR	lr, [r9, #SIS_DuffSystemContents] ; increment count of number of times we had crap
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffSystemContents]
	STR	r1, [r9, #SIS_AddressOfLastDuff]
	BL	RoundUpToWord			; round up to whole word boundary
	B	%BT10				; for now just go onto next entry

; not packet header, so check for pack header or system header

75
	TEQ	r5, #&BA			; is it a pack header?
	BNE	%FT80

; a pack header is either a total of 12 bytes (MPEG 1) or 14 bytes + up to 7 bytes of
; &FF stuffing (MPEG2) (which the L64002 skips), so the system buffer usage is always 2 words

	BL	RoundUpToWord			; skip rest of 1st word
	DoDRAMGetByte UnderrunExit		; check 2nd word is there
	BL	RoundUpToWord			; round up to next one
	B	%BT10				; then go back for more

; not packet or pack header - check for system header

80
	TEQ	r5, #&BB			; is it a system header
	BNE	%BT70				; if not then rubbish
	DoDRAMGetByte UnderrunExit		; get high byte of length
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit
	ORRS	r7, r5, r7, LSL #8		; r7 = number of additional bytes
	BEQ	%FT85				; no more bytes to skip

	BL	SkipR7Bytes			; skip rest of system header
	BVS	UnderrunExit
85
	BL	RoundUpToWord			; skip to start of next word
	B	%BT10				; now go back for more


SkipR7Bytes Entry
10
	BL	DRAMGetByte
	EXIT	VS
	SUBS	r7, r7, #1			; decrement count of bytes to skip
	BNE	%BT10
	EXIT					; exit (V=0 from SUBS)


GetClockReference ROUT
	Push	"lr"
	AND	r5, r5, #&0E				; extract bits 3..1
	MOV	r7, r5, LSR #3				; r7 = bit 32 in bit 0
	Push	"r7"					; save for later, together with bomb-out address
	MOV	r7, r5, LSL #31-2			; r7 = bits 31,30
	BL	DRAMGetByte				; get bits 29..22 in bits 7..0
	ORRVC	r7, r7, r5, LSL #22			; r7 = bits 31..22
	BLVC	DRAMGetByte				; get bits 21..15 in bits 7..1
	MOVVC	r5, r5, LSR #1
	ORRVC	r7, r7, r5, LSL #15			; r7 = bits 31..15
	BLVC	DRAMGetByte				; get bits 14..7 in bits 7..0
	ORRVC	r7, r7, r5, LSL #7			; r7 = bits 31..7
	BLVC	DRAMGetByte				; get bits 6..0 in bits 7..1
	ORRVC	r6, r7, r5, LSR #1			; r6 = bits 31..0
	Pull	"r7,pc"

RoundUpToWord Entry
	ADD	r1, r1, #7
	BIC	r1, r1, #7
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXIT

DRAMGetByte Entry "r2,r3"
	ADR	r5, DRAMBuffer
	LDR	lr, DRAMBufferAddress
	EOR	lr, lr, r1				; differences between DRAM buffer address and required address
	BICS	lr, lr, #7				; is it in the same word?
	BNE	%FT10					; no, so fetch DRAM
05
	AND	lr, r1, #7
	LDRB	r5, [r5, lr]				; load from buffer
	ADD	r1, r1, #1				; advance read ptr
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXITS

10
	BIC	lr, r1, #7				; form base word address
	TEQ	lr, r0					; are we in same word as write ptr
	BEQ	%FT90					; if so then we've underrun

	STR	lr, DRAMBufferAddress			; save base address of buffer

	DRAMRead r2, r3, r1, lr				; perform read from location (r1 BIC 7) and put contents in r2,r3
	STMIA	r5, {r2, r3}				; store 8-bytes in buffer
	B	%BT05

90
	LDR	lr, [r9, #SIS_SystemUnderruns]
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_SystemUnderruns]
	PullEnv
	ORRS	pc, lr, #V_bit				; set V, preserving other flags

; **************************************************************************
;
;	ProcessAudioReadPtr - Compare passed in audio read ptr with AudioPTSList
;			      and if the sync code has a corresponding PTS, set SCR to it
;
; in:	r0 = audio channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> audio info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be junked

ProcessAudioReadPtr Entry

; we have to adjust for the fact that the audio sync code register points 16 (not 8 as in the manual) bytes further on
; than the address containing the audio sync code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #16 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	MOV	lr, r0, LSR #6				; convert back to byte offset for storage
	STR	lr, AudioChannelBufferReadPtr

	BL	CheckPTSList
	TEQ	r1, #0
	EXIT	MI					; if no PTS, just exit

 [ VetSCRValues
	MOV	r2, pc
	BIC	r3, r2, #3
	TEQP	r3, #SVC_mode				; enter SVC mode so we can save lr_svc
	NOP

	Push	"lr"					; save lr_svc
	BL	PerformSCRVetting			; if SCR bad, don't use it
	BLEQ	WriteSCR
	Pull	"lr"					; restore lr_svc

	TEQP	r2, #0					; restore original mode
	NOP
 |
	BL	WriteSCR
 ]
	EXIT

; **************************************************************************
;
;	CheckPTSList - Check video or audio PTS list for comparable item
;
; in:	r0 = channel buffer ptr to compare, shifted up to top of word (so that clock arithmetic can be used)
;	r8 -> VideoInfoStructure or AudioInfoStructure
;
; out:	If there is an appropriate PTS then
;	 r0 = bits 0..31 of PTS
;	 r1 = bit 32 of PTS (in bit 0)
;	else
;	 r0 = undefined
;	 r1 = -1
;	endif

CheckPTSList Entry "r2-r7,r9"
	LDR	r1, [r8, #SI_PTSListWritePtr]
	LDR	r2, [r8, #SI_PTSListReadPtr]
	LDR	r3, [r8, #SI_PTSListPtr]
	LDR	r9, [r8, #SI_PTSListSize]
	MOV	r7, #-1					; indicate no valid PTS yet
10
	TEQ	r2, r1					; have we run out?
	BEQ	%FT90					; then exit

	ADD	r4, r3, r2, LSL #3			; point at next read entry
	LDMIA	r4, {r4, r5}
	BIC	lr, r5, #1				; knock out bit 32 of PTS
	CMP	r0, lr					; check if value of read ptr is less than next PTS (using clock arithmetic)
	BMI	%FT90					; if so, then next PTS hasn't happened yet

	MOV	r6, r4					; make record of highest PTS so far with address field <= current read ptr
	AND	r7, r5, #1				; r7 = bit 32 of PTS

	ADD	r2, r2, #1				; advance read ptr
	TEQ	r2, r9					; wrap it
	MOVEQ	r2, #0
	B	%BT10

; no more PTSs with address <= read ptr, so if we've had one, set SCR to that, else just exit

90
	STR	r2, [r8, #SI_PTSListReadPtr]
	MOV	r0, r6
	MOV	r1, r7
	EXIT

; **************************************************************************
;
;	ProcessVideoReadPtr - Compare passed in video read ptr with VideoPTSList
;			      and if the picture start has a corresponding PTS, post it for
;			      comparison with the SCR on a future vsync IRQ
;
; in:	r0 = video channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> video info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be corrupted

ProcessVideoReadPtr Entry
	LDR	lr, AudioControlStreamHandle		; if no audio stream playing, don't do any syncing
	TEQ	lr, #0
	EXIT	EQ

; we have to adjust for the fact that the picture start code register points 48 bytes further on than the address containing
; the picture start code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #48 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	BL	CheckPTSList				; PTS if any comes back in r0,r1 (r1<0 if invalid)
	TEQ	r1, #0
	BMI	%FT10					; if no PTS, don't increment video PTS picture type counts

	LDRB	r2, Picture_PictureCodingType
	ADR	lr, VideoPTSPictureTypeCounts
	CMP	r2, #4
	LDRCC	r3, [lr, r2, LSL #2]
	ADDCC	r3, r3, #1
	STRCC	r3, [lr, r2, LSL #2]

10
 [ AllowSyncOnIFrames
	LDR	lr, SyncMode
	TEQ	lr, #0					; are we syncing to I-frames?
	BEQ	%FT30

; syncing to I-frames, so verify it is an anchor frame, else don't post it

	TEQ	r2, #PictureCodingType_P
	TEQNE	r2, #PictureCodingType_I
	EXIT	NE					; oh hell, it's a B-picture - don't try to post it

	LDR	lr, AnchorPostedPTSWritePtr
	ADR	r3, AnchorPostedPTSs
	AND	r2, lr, #3
	ADD	r3, r3, r2, LSL #3			; r3 -> slot to fill
	STMIA	r3, {r0, r1}				; store posted PTS
	ADD	r2, r2, #1
	AND	r2, r2, #3				; where WritePtr would point next (wrapped)
	LDR	r0, AnchorPostedPTSReadPtr
	AND	r0, r0, #3
	TEQ	r0, r2					; if would point to same place, then overrun
	LDREQ	lr, AnchorFIFOOverruns			; increment overrun count
	ADDEQ	lr, lr, #1
	STREQ	lr, AnchorFIFOOverruns
	EXIT	EQ					; and don't increment write ptr or number of posted PTSs

	ADD	lr, lr, #1				; advance unwrapped write ptr
	STR	lr, AnchorPostedPTSWritePtr		; and store back

	B	%FT50
30
 ]
 [ CountVideoPackets
	LDR	lr, SyncMode
	TEQ	lr, #0					; are we counting packets for sync
	BEQ	%FT30					; no, so do normal sync
	LDR	lr, VideoPicturesReceived		; else increment picture count
	ADD	lr, lr, #1
	STR	lr, VideoPicturesReceived
	EXIT						; and exit
30
 ]
	TEQ	r1, #0					; if doing normal syncing and no PTS, don't post it
	EXIT	MI

	TEQ	r2, #PictureCodingType_B		; is it a B picture?
	EXIT	NE					; if not exit for now

	LDR	lr, VideoPostedPTS +4			; is there already one posted that hasn't been used?
	TEQ	lr, #0					; less than 0 => empty
	EXIT	PL

	ADR	r3, VideoPostedPTS
	STMIA	r3, {r0, r1}				; post PTS for comparison on next odd field vsync IRQ
50
	LDR	r0, VideoNumberOfPostedPTSs
	ADD	r0, r0, #1
	STR	r0, VideoNumberOfPostedPTSs

	EXIT

 [ VetSCRValues
; **************************************************************************
;
;	PerformSCRVetting - Check SCR for sensibility, and reject if not
;
; in:	r0 = bottom 32 bits of SCR
;	r1 = bit 32 of SCR
;	IRQ mode
;
; out:	NE => reject this SCR value

PerformSCRVetting Entry "r2,r3"
	LDR	r3, VetSCRState
	CMP	r3, #1
	BCS	%FT20

; we're awaiting the 1st SCR

	LDR	r2, AudioSpeedSetting
	TEQ	r2, #1			; only exit this state if in normal play mode
	BNE	%FT10			; return EQ, but do nothing
	BL	ConvertSCRToOffset
	STR	r2, GoodSCROffset
05
	MOV	r2, #1
	STR	r2, VetSCRState
10
	TEQ	r0, r0			; set EQ
	EXIT

20
	BL	ConvertSCRToOffset	; convert new SCR into an offset from 100Hz time
	LDR	lr, GoodSCROffset	; get last good offset
30
	SUBS	lr, lr, r2		; compute difference
	RSBMI	lr, lr, #0		; compute absolute difference
	CMP	lr, #SCRAcceptableRange	; is it within range
	STRCC	r2, GoodSCROffset	; yes, then store new good offset
	BCC	%BT05			; then mark last one as good, and exit EQ

; we're out of range of the last good one, but are we consistent with the last bad one?

	CMP	r3, #2			; was the last one bad?
	STRNE	r2, BadSCROffset	; if not, then store this as the 1st bad one
	MOVNE	r2, #2			; indicate last one was bad
	STRNE	r2, VetSCRState
	LDRNE	r2, BadSCRCount		; increment count of bad ones
	ADDNE	r2, r2, #1
	STRNE	r2, BadSCRCount
	EXIT	NE			; and exit NE, indicating last one bad

	LDR	lr, BadSCROffset	; get last bad offset
	MOV	r3, #1			; pretend last one was good, so we don't drop thru again
	B	%BT30

ConvertSCRToOffset ROUT
	Push	"r0,lr"
	SWI	XOS_ReadMonotonicTime	; returns in r0
	MOV	lr, #900		; SCR is in 90kHz ticks, monotonic time is in 100Hz units
	MUL	r2, lr, r0		; make into 90kHz units (don't care about overflow)
	Pull	"r0"
	SUB	r2, r0, r2		; SCR - MT*900
	Pull	"pc"

 ] ; VetSCRValues

; **************************************************************************
;
;	VideoTickerV - Entry point for TickerV IRQ for video

VideoTickerV Entry "r0-r2"
	LDR	r0, VideoCallBackRequested	; is a callback already requested
	TEQ	r0, #0
	EXIT	NE				; if so, don't ask for another
	MOV	r2, pc
	ORR	r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
	TEQP	r1, #0
	NOP
	Push	"r14"
	LDR	r0, VideoStreamFlags
	TST	r0, #StreamFlags_UseCallBacks
	BEQ	%FT20				; [stuff directly]

	ADR	r0, VideoTickerVCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	MOVVC	r0, #1
	STRVC	r0, VideoCallBackRequested	; indicate that we've requested a callback
10
	Pull	"r14"
	TEQP	r2, #0
	NOP
	EXIT

20
	MOV	r0, #1
	STR	r0, VideoCallBackRequested
	BL	VideoTickerVNonCallBack
	B	%BT10

 [ PreserveIRQStateInTickerVStuffing
; new code - only enable IRQs if it's a real callback, not direct in TickerV
VideoTickerVCallBack Entry
  [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
  ]
	PullEnv
VideoTickerVNonCallBack Entry "r0,r1, r11"
 |
; old code
VideoTickerVNonCallBack
VideoTickerVCallBack Entry "r0,r1, r11"
  [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
  ]
 ]
	LDR	r11, L64002_Registers
	BL	VideoCheckEndOfPreFill	; start playing if sent enough
	BL	VideoFreeUsedPackets
	BL	VideoDoStuffWithData
	MOV	r0, #0
	STR	r0, VideoCallBackRequested
	EXIT

	LTORG

VideoDoStuffWithData Entry "r0-r2"
	LDR	r0, VideoStreamClosing  ; if stream closing (ie value = 2)
	CMP	r0, #1			; don't send any more data
	EXIT	HI

	LDR	r0, VideoPacketListHeadPtr

; find any data we haven't passed to background yet

10
	TEQ	r0, #0						; any more data
	EXIT	EQ						; [no, so exit]
	LDR	r1, [r0, #PacketDescriptor_Flags]		; have we passed this packet
	TST	r1, #PacketDescriptorFlags_PassedToBackground
	BLEQ	PassPacketToBackground				; if not then do so
	LDRNE	r0, [r0, #PacketDescriptor_Link]		; if we can still send more, then go on to next packet
	BNE	%BT10
	EXIT

 [ MultiplePicturePacketsChecks
; **************************************************************************
;
;	CheckForMultiplePictures - Check packet for multiple picture_start codes
;
; in:	r0 -> packet descriptor for first packet within MPEG packet
;	r1 = flags for packet
;
; out:  EQ => packet is OK to send
;	NE => packet is incomplete so hasn't been checked - don't send it yet
;	r1 = updated flags
;	All other registers preserved

CheckForMultiplePictures Entry "r0,r2-r8"
	LDR	r2, [r0, #PacketDescriptor_FullLength]
	MOV	r3, r0
10
	LDR	r4, [r3, #PacketDescriptor_Length]
	SUBS	r2, r2, r4
	BLE	%FT20
	LDR	r3, [r3, #PacketDescriptor_Link]
	CMP	r3, #1		; if link <> 0
	BCS	%BT10		; then loop

; incomplete packet, so exit NE to indicate this

	LDR	r3, VideoStreamClosing
	TEQ	r3, #1		; are we going to get any more data?
	EXIT	NE		; we might, so exit NE indicating incomplete

	B	CFMPBadPacket	; else we'd best mark it as dodgy, just in case

; packet is complete, so let's check it (r0 -> first part packet, r3 -> last)

20
	LDR	r2, [r0, #PacketDescriptor_PTS]
	LDR	lr, =BadPacketPTS
	TEQ	r2, lr
	MOVNE	r8, #0
	MOVEQ	r8, #1

	LDR	r2, [r0, #PacketDescriptor_Start]
	LDR	r4, [r0, #PacketDescriptor_Length]
	MOV	r7, #0			; number of picture_start codes in packet

30
	MOV	r6, #0			; state
32
	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00
	BNE	%BT32
34
	MOV	r6, #1
	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00 00
	BNE	%BT30
	MOV	r6, #2

	BL	CFMPgetbyte
	TEQ	r5, #1		; check for 00 00 01
	SUBNE	r2, r2, #1	; if not then could be (00) 00 00
	ADDNE	r4, r4, #1	; adjust length back as well
	BNE	%BT34
	MOV	r6, #3

	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00 00 01 00 (picture start code)
	BNE	%BT30

	ADD	r7, r7, #1	; one more picture start code
	CMP	r7, #1
	BHI	CFMPBadPacket	; if more than 1 then definitely bad
	B	%BT30		; else loop

BadPacketPTS	*	&D4B20
	LTORG

CFMPgetbyte
	SUBS	r4, r4, #1
	LDRGEB  r5, [r2], #1
	MOVGE	pc, lr
	TEQ	r0, r3
	LDRNE	r0, [r0, #PacketDescriptor_Link]
	LDRNE	r2, [r0, #PacketDescriptor_Start]
	LDRNE	r4, [r0, #PacketDescriptor_Length]
	BNE	CFMPgetbyte

; we've run out of data to check

	TEQ	r8, #1
	STREQ	r7, CheckedBadPacket

 [ {FALSE}	; try rule where only two whole picture_start codes make a bad packet
	TEQ	r7, #0		; if no picture_start codes
	TEQNE	r6, #0		; or 1 picture_start code and no partial ones
 ]
	B	CFMPGoodPacket  ; then OK
CFMPBadPacket
	BIC	r1, r1, #PacketDescriptorFlags_PTSValid ; else clear PTS valid bit
	LDR	lr, MultiPacketCount
	ADD	lr, lr, #1
	STR	lr, MultiPacketCount
	CMP	lr, #MPDebugArraySize	; if run out of debug array
	BCS	CFMPGoodPacket		; then skip this bit
	ADR	r0, MPDebugArray-4
	ADD	lr, r0, lr, LSL #2	; point at where to store PTS
	LDR	r0, [sp]		; reload ptr to first partial packet
	LDR	r0, [r0, #PacketDescriptor_PTS] ; load bottom 32 bits of PTS for this packet
	STR	r0, [lr]
CFMPGoodPacket
	BIC	r1, r1, #PacketDescriptorFlags_Unchecked
	LDR	r0, [sp]		; reload ptr to first partial packet
	STR	r1, [r0, #PacketDescriptor_Flags]	; save flags
	TEQ	r0, r0			; indicate packet has been checked
	EXIT
 ]

; **************************************************************************
;
;	PassPacketToBackground - Pass a packet to background FIQ process
;
; in:	r0 -> packet
;	r1 = packet flags
;
; out:	NE if managed to pass this packet to background
;	EQ if couldn't, cos all slots full

PassPacketToBackground Entry "r1-r5,r11"
 [ UseWholePackets
	BL	VideoSendNewPacketIfNecessary		; if start of MPEG packet, put in packet header slot if poss.
	BNE	%FT90
 ]
	ASSERT	PacketDescriptor_Length = PacketDescriptor_Start + 4
	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	BNE	%FT90					; [all slots full]

	ADD	r4, r0, #PacketDescriptor_Start
	LDMIA	r4, {r4, r5}				; get address, length of this packet

 [ CheckBufferFullness
	LDR	lr, VideoPreFilling
	TEQ	lr, #0
	BNE	%FT10					; pre-filling, so assume OK
	LDR	r11, L64002_Registers
	BL	VideoGetBufferFullness			; read buffer fullness into r2
	LDR	lr, VideoAmountQueued
	ADD	r2, r2, lr				; add on amount already queued
	ADR	lr, FIQAmountSent
	LDR	lr, [lr]
	SUB	r2, r2, lr				; but subtract amount already sent
	ADD	r2, r2, #MPEG2Podule_FIFOLength + 8*1024 ; and add a possibly full FIFO, plus some slack in the channel buffer
	ADD	r2, r2, r5				; add on length of this packet
	LDR	lr, VideoChannelBufferSize
	CMP	r2, lr					; if this is more than total buffer size
	BHI	%FT90					; then don't pass this packet yet
10
 ]
	ORR	r1, r1, #PacketDescriptorFlags_PassedToBackground ; indicate passed to bgd
	STR	r1, [r0, #PacketDescriptor_Flags]	; do this *before* passing to bgd, in case it's bloody quick

	MOV	lr, r0
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in slot (NB may start going straight away)

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	TEQ	r3, #0					; r3 <> 0, so set NE
	EXIT

90
	TEQ	r0, r0					; set EQ, indicating failure
	EXIT

; **************************************************************************
;
;	WriteSCR - Write to system clock reference value by adjusting software offset
;
; in:	r0 = bits [31..0] of SCR
;	r1 = bit 32 of SCR, in bit 0
;	r11 -> L64002_Registers

WriteSCR Entry "r0-r4"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we update

	MOV	r3, r1					; save new hi word of value
	BL	ReadSCR					; r1 = old value lo, r2 = old value hi
	SUBS	r0, r0, r1				; r0 = (new value - old value) lo word
	SBC	r1, r3, r2				; r1 = (new value - old value) hi word

	ADR	lr, SCROffset
	LDMIA	lr, {r2, r3}				; r2 = old offset lo, r3 = old offset hi
	ADDS	r2, r2, r0				; r2 = new offset lo = new value - old value + old offset
	ADC	r3, r3, r1				; r3 = new offset hi
	STMIA	lr, {r2, r3}				; update offsets
	EXITS

; **************************************************************************
;
;	ReadSCR - Read current value of SCR bits using H/W and software offset
;
; in:	-
;
; out:	r1 = bits [31..0] of SCR
;	r2 = bit 32 of SCR, in bit 0

ReadSCR Entry	"r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we read this

	ReadRegI r1, SCR0
	ReadRegI r2, SCR1

	BL	CheckErrorStatus			; process bits in ErrorStatus register, returns r0 = error status
	TST	r0, #ErrorStatus_SCROverflow
	BEQ	%FT10

	ReadRegI r1, SCR0				; if overflowed, it may have done so before or after we read the
	ReadRegI r2, SCR1				; registers before, so read them again (won't have time to overflow again)
10
	ORR	lr, r1, r2, LSL #8
	ADR	r1, SCROffset				; load software offset (will have been updated
	LDMIA	r1, {r1, r2}				; if necessary by CheckErrorStatus)
	ADDS	r1, r1, lr				; and add it on
	ADC	r2, r2, #0
	EXITS

; **************************************************************************
;
;	CheckErrorStatus - Check various bits in ErrorStatus register and act on them
;
; in:	r11 -> L64002_Registers
;	IRQs disabled
;
; out:	r0 = value of ErrorStatus register

CheckErrorStatus Entry "r1,r2"
	ReadRegI r0, ErrorStatus
	STR	r0, LastErrorStatus
	LDR	lr, CumulativeErrorStatus
	ORR	lr, lr, r0
	STR	lr, CumulativeErrorStatus
	TST	r0, #ErrorStatus_VideoReconstructionError
	BEQ	%FT10
	LDR	lr, VidRecErrors
	ADD	lr, lr, #1
	STR	lr, VidRecErrors
	LDR	lr, TimeOffsetOfVRError
	CMP	lr, #-1				; if already had a vid recon error since last video reset
	BNE	%FT10				; then skip

	MOV	r1, pc
	ORR	r2, r1, #SVC_mode		; switch to SVC_mode so we can save lr_svc
	TEQP	r2, #0
	NOP
	Push	"r0, lr"
	SWI	XOS_ReadMonotonicTime
	LDR	lr, TimeOfLastVideoReset
	SUB	r0, r0, lr
	STR	r0, TimeOffsetOfVRError
	Pull	"r0, lr"
	TEQP	r1, #0				; switch back to previous mode
	NOP
10
	TST	r0, #ErrorStatus_ContextError
	LDRNE	lr, ContextErrors
	ADDNE	lr, lr, #1
	STRNE	lr, ContextErrors
	TST	r0, #ErrorStatus_VLCError
	LDRNE	lr, VLCErrors
	ADDNE	lr, lr, #1
	STRNE	lr, VLCErrors

	TST	r0, #ErrorStatus_SCROverflow
	EXIT	EQ
	ADR	lr, SCROffset
	LDMIA	lr, {r1, r2}
	ADDS	r1, r1, #1 :SHL: 16
	ADC	r2, r2, #0
	STMIA	lr, {r1, r2}
	EXIT

; **************************************************************************
;
;	VideoFreeUsedPackets - Go through packet list freeing any used packets

VideoFreeUsedPackets Entry "r0-r3"
10
	LDR	r0, VideoPacketListHeadPtr
	TEQ	r0, #0
	LDRNE	lr, [r0, #PacketDescriptor_Flags]	; if we have a packet, has it all been sent?
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	EXIT	EQ
 [ {TRUE}
; we've found a packet that needs freeing, so go down chain until we find the last
; one that needs freeing
	MOV	r1, r0					; save pointer to 1st one
20
	LDR	r2, [r1, #PacketDescriptor_Link]	; if there is a next node
	TEQ	r2, #0
	LDRNE	lr, [r2, #PacketDescriptor_Flags]	; and it's all sent
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	MOVNE	r1, r2					; then move to that one
	BNE	%BT20					; and loop

	MOV	r3, pc
	ORR	lr, r3, #I_bit				; disable IRQs round this bit
	TEQP	lr, #0					; (may be unnecessary)

	STR	r2, VideoPacketListHeadPtr		; update head
	TEQ	r2, #0					; and if no more
	STREQ	r2, VideoPacketListTailPtr		; zero tail

	TEQP	r3, #0					; restore IRQs
	MOV	r2, #0
	STR	r2, [r1, #PacketDescriptor_Link]	; terminate link at last freeable packet

	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine] ; free nodes
	EXIT

 |
	BL	VideoFreePacket				; if so then free it
	B	%BT10
 ]

; **************************************************************************
;
;	VideoCheckEndOfPreFill - Check if we've sent enough to pre-fill buffer, so we can unpause it

VideoCheckEndOfPreFill Entry "r0"
	LDR	lr, VideoPreFilling			; are we still in pre-fill
	CMP	lr, #0
	EXIT	EQ					; already playing

	ADR	lr, FIQAmountSent
	LDR	lr, [lr]				; check amount FIQ process has transmitted

	LDR	r0, VideoVBVSize
	CMP	lr, r0
	MOVCS	lr, #0
	STRCS	lr, VideoPreFilling
;	STRCS	lr, DecodedFieldCount			; This is now done when we receive sequence header decode
   [ SendPlaySWI
	BLCS	VideoIssuePlaySWI
   |
	BLCS	VideoSendPlay
   ]
	EXIT


 [ SendPlaySWI

VideoIssuePlaySWI Entry "r0,r1"
	MOV	r0, #StreamFlags_VideoPresent	; indicate video now ready
	LDR	r1, VideoControlStreamHandle
	SWI	XMPEGControl_Play

	EXIT
 ]

; **************************************************************************
;
;	Data stuffing FIQ code

; FIQ register allocation:

; Outside FIQ routine:
;  r8 -> current slot to process
;  r9 -> 32-bit FIFO write address (16 bit address = r9-4)
;  r10 -> 8-bit FIFO write address
;  r13 -> FIQ stack
; Inside routine:
;  r0 -> data
;  r1 = remaining contiguous length we can do this FIQ
;  r2-r7,r11,r14 used to load data
;  r12 = amount of space left in FIFO after this lump
;

; FIQ slot node format

		^	0
FIQSlot_Address #	4
FIQSlot_Length	#	4
FIQSlot_Packet	#	4

FIQSlotSize	*	:INDEX: @

; FIQ workspace layout

		^	&1C
FIQSpaceStart	#	4			; slot for LDR PC, &20
FIQSpacePCLoad	#	4			; slot for address of FIQ routine in module code
FIQAmountSent	#	4			; amount of data sent by FIQ process
 [ Save1stFIQPacket
FIQWorkspacePtr	#	4
 ]
		#	9*4			; 9 words needed for FIQ stack to save r0-r7,r14
FIQStackEnd	#	0

		#	(&100-@) :MOD: FIQSlotSize	; align so that slot space ends on a slot boundary

FIQSlotSpace	#	&100 - @

FIQSlotSpaceSize *	?FIQSlotSpace
	ASSERT	FIQSlotSpaceSize >= FIQSlotSize

FIQCodeStart Entry "r0-r7"			; may not need all these
	MOV	r1, #MPEG2Podule_FIFOLength	; how much we can do now
05
	ASSERT	FIQSlot_Length = FIQSlot_Address +4
	LDMIA	r8, {r0, r2}			; load address + length
	TEQ	r0, #0				; if address zero
	BEQ	%FT90				; then no more data, so disable FIQ in IOMD and exit
10
	SUBS	r12, r1, r2			; amount of FIQ space left after this packet
	MOVCS	r1, r2				; if >=0 then do packet amount in this lump
	MOVCS	r2, #0				; and packet done after this
	RSBCC	r2, r12, #0			; else packet has -r12 left after this FIFO lump
	MOVCC	r12, #0				; and no FIFO space after this packet
	STR	r2, [r8, #FIQSlot_Length]	; store updated length for next time

	ADR	r3, FIQAmountSent
	LDR	r4, [r3]			; add on amount about to be sent
 [ Save1stFIQPacket
	CMP	r4, #?FirstPacket		; if not sent 184 bytes yet
	BCC	%FT95				; then jump to code that saves away the packet
15
 ]
	ADD	r4, r4, r1
	STR	r4, [r3]

	TST	r0, #3
	BNE	%FT40				; do part words
20
	SUBS	r1, r1, #8*4			; enough for 8 whole words?
	LDMCSIA r0!, {r2-r7,r11,r14}
	STMCSIA r9, {r2-r7,r11,r14}
	BHI	%BT20

	ADDCC	r1, r1, #8*4			; if insufficient then revert
30
	SUBS	r1, r1, #4			; enough for 1 whole word
	LDRCS	r2, [r0], #4
	STRCS	r2, [r9]
	BHI	%BT30

;	ADDCC	r1, r1, #4			; (not necessary - we only need to look at bottom 2 bits now)

	TST	r1, #2
	LDRNE	r2, [r0], #2
	STRNE	r2, [r9, #-4]			; write to 16-bit FIFO address

	TST	r1, #1
	LDRNEB	r2, [r0], #1
	STRNEB	r2, [r10]			; write to 8-bit FIFO address

; finished doing that lump

35
	LDR	r2, [r8, #FIQSlot_Length]	; get remaining size
	TEQ	r2, #0				; if some left
	STRNE	r0, [r8, #FIQSlot_Address]	; then update address
	BNE	%FT36

; none left, so mark as finished, and advance to next

	LDR	r3, [r8, #FIQSlot_Packet]	; find real packet descriptor (if any - NB packet header slots don't have one)
	TEQ	r3, #0
	LDRNE	r2, [r3, #PacketDescriptor_Flags] ; mark packet as all sent
	ORRNE	r2, r2, #PacketDescriptorFlags_AllSent
	STRNE	r2, [r3, #PacketDescriptor_Flags]
	MOV	r0, #0				; zero address to store in slot, to mark it as empty
	STR	r0, [r8, #FIQSlot_Address]
	ADD	r8, r8, #FIQSlotSize		; advance to next slot
	CMP	r8, #&100			; wrap if necessary
	ADREQ	r8, FIQSlotSpace
36
	MOVS	r1, r12				; restore amount of space left in FIFO
	BNE	%BT05				; if some then go back and try to do it
37
	PullEnv
	SUBS	pc, lr, #4			; exit from FIQ

; data address not word aligned, so do bytes until it is

40
	SUBS	r1, r1, #1			; if no more bytes left
	BCC	%BT35				; then finished doing that lump
	LDRB	r2, [r0], #1
	STRB	r2, [r10]			; write to 8-bit FIFO address

	TST	r0, #3				; if still not aligned
	BNE	%BT40				; then loop
	B	%BT20				; else enter main section

; no more data, so disable FIQ until we have some

90
	MOV	r1, #IOC
	STRB	r0, [r1, #IOCFIQMSK]		; zero FIQ mask to disable our FIQ
	B	%BT37

 [ Save1stFIQPacket
95
	MOV	r7, r12				; save r12 value in r7 so we can use r12 as wsptr
	ADR	r12, FIQWorkspacePtr
	LDR	r12, [r12]
	ADD	r2, r4, r1			; total length we will have done after this packet
	CMP	r2, #?FirstPacket
	MOVHI	r2, #?FirstPacket		; r2 = total amount we have saved away after this
	STR	r2, SavedPacketLength
	ADR	r5, FirstPacket
	ADD	r5, r5, r4			; advance pointer to where we're up to
	SUB	r2, r2, r4			; and decrement length to how much remaining to do
96
	SUBS	r2, r2, #1			; go backwards through packet
	LDRCSB	r6, [r0, r2]
	STRCSB	r6, [r5, r2]
	BHI	%BT96
	MOV	r12, r7				; put r12 back
	B	%BT15				; and rejoin main code
 ]

; **************************************************************************
;
;	UpdateIR - Atomically update interrupt registers and soft copies
;
; in:	r0 = EOR mask
;	r1 = AND mask

UpdateIR Entry "r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	r2, IRSoftCopy
	AND	r2, r2, r1
	EOR	r2, r2, r0
	STR	r2, IRSoftCopy

	WriteReg r2, IR0
	MOV	r2, r2, LSR #8
	WriteReg r2, IR1
	EXITS

 [ UseWholePackets
; **************************************************************************
;
;	VideoSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:	r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

VideoSendNewPacketIfNecessary Entry "r1-r5, r11"
	LDR	r1, VideoStreamFlags
	EOR	r1, r1, #StreamFlags_PassThroughToVideo
	TST	r1, #StreamFlags_PassThroughToVideo
	EXIT	EQ					; if passing through, don't put our own packet headers on it

	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart	; is it start of an MPEG packet?
	EXIT	EQ					; [no, so no packet header required, exit EQ => try to send data]

 [ FudgeZeroLengthPackets :LOR: TrickPlaySupport
	TST	r1, #PacketDescriptorFlags_FullLengthUnknown	; is it a packet of indeterminate length?
  [ :LNOT: FudgeZeroLengthPackets			; if we're not fudging them all, check we're in correct mode
	LDRNE	r3, TrickPlayMode
	TEQNE	r3, #0					; need to be in TrickPlayMode
	LDRNE	r3, VideoStructureFlags
	TSTNE	r3, #VideoStructureFlags_TrickPlayPacketLengthFix ; and with packet length fixing enabled
  ]
	EXIT	NE					; [yes, so we must wait for length to be determined, exit NE => wait]
 ]

	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	EXIT	NE					; [all slots full, so don't try to send data]

; we need to create a FIQ slot containing the data to send for the packet header
; rather than allocating a new RMA block, we can reuse the 16 bytes in the packet header allocated for the PTS and DTS (yuk!)

 [ AudioSquawkFix1

; Bug 4-20 on the L64002 bug sheet describes something similar sounding to the audio squawk problem, albeit with
; serial input of data. It claims it only happens if the PES packet header is not a multiple of 8 bytes.
; So try padding video packets to a multiple of 8 bytes.
; Unfortunately MPEG 1 system stream format packet header stuffing bytes get discarded in the holding register and don't
; make it into the system buffer, so we have to use MPEG 2 PES packet header instead.
; This takes the form: 00 00 01 E0 lenhi lenlo flags1(80) flags2(00 if no PTS or 80 if PTS) hdrlen
; followed by hdrlen bytes of flags and stuffing (not looked at by L64002)
; in our case we set hdrlen to 7 then add either (5 PTS + 2 FF) or 7 FF

	MOV	lr, #&FFFFFF07
	STR	lr, [r0, #PacketDescriptor_PTS+8]
	MOV	lr, #&FFFFFFFF
	STR	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, #&00800000				; flags1 byte is 80, flags2 byte is 00 for no PTS
	TST	r1, #PacketDescriptorFlags_PTSValid
	STREQ	lr, [r0, #PacketDescriptor_PTS+4]	; no PTS
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS
	ORR	lr, lr, #&80000000			; if PTS then set flags2 byte to 80
	STR	lr, [r0, #PacketDescriptor_PTS+4]	; store it *after* reading real PTS

	MOV	lr, r4, LSR #29				; lr = bits 31..29 in bits 2..0
	ORR	lr, lr, r5, LSL #3			; lr = bits 32..29 in bits 3..0
	ORR	lr, lr, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+9]	; store in packet header block
	MOV	lr, r4, LSR #22				; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+10]	; (only stores bottom 8 bits)
	MOV	lr, r4, LSR #14				; lr = bits 21..14 in bits 7..0
	ORR	lr, lr, #1				; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+11]
	MOV	lr, r4, LSR #7				; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, r4, LSL #1				; lr = bits 6..0 in bits 7..1
	ORR	lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+13]

	MOV	r5, pc
	ORR	lr, r5, #I_bit
	TEQP	lr, #0
	LDR	lr, VideoPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, VideoPTSInCount
	TEQP	r5, #0

30
	MOV	r5, #16					; now padded to 16 bytes whether PTS or not
 |
	TST	r1, #PacketDescriptorFlags_PTSValid
	MOVEQ	lr, #&0F				; termination for no PTS
	STREQB	lr, [r0, #PacketDescriptor_PTS+6]
	MOVEQ	r5, #7					; if no PTS, then just 7 extra bytes
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS

	MOV	lr, r4, LSR #29				; lr = bits 31..29 in bits 2..0
	ORR	lr, lr, r5, LSL #3			; lr = bits 32..29 in bits 3..0
	ORR	lr, lr, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+6]	; store in packet header block
	MOV	lr, r4, LSR #22				; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+7]	; (only stores bottom 8 bits)
	MOV	lr, r4, LSR #14				; lr = bits 21..14 in bits 7..0
	ORR	lr, lr, #1				; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+8]
	MOV	lr, r4, LSR #7				; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+9]
	MOV	lr, r4, LSL #1				; lr = bits 6..0 in bits 7..1
	ORR	lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+10]

	MOV	r5, pc
	ORR	lr, r5, #I_bit
	TEQP	lr, #0
	LDR	lr, VideoPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, VideoPTSInCount
	TEQP	r5, #0

	MOV	r5, #11
30
 ]
	LDR	lr, =&E0010000
	STR	lr, [r0, #PacketDescriptor_PTS+0]	; video packet start code

	LDR	r4, [r0, #PacketDescriptor_FullLength]	; get length of packet payload
	TEQ	r4, #0					; if zero, then leave it at zero
	ADDNE	r4, r4, r5				; else add on length of packet header
	SUBNE	r4, r4, #6				; but don't count start code or length in total length
 [ NobbleL64002VideoPacketLengths
	MOV	r4, #0					; store zero length in packet
 ]
	MOV	lr, r4, LSR #8
	STRB	lr, [r0, #PacketDescriptor_PTS+4]	; store len hi
	STRB	r4, [r0, #PacketDescriptor_PTS+5]	; store len lo

	ADD	r4, r0, #PacketDescriptor_PTS		; point r4 at new packet header
	MOV	lr, #0					; packet field must be zero, cos it's a fake lump
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in FIQ slot

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

	BIC	r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
	STR	r1, [r0, #PacketDescriptor_Flags]	; we don't send hdr again

 [ CountVideoPackets :LAND: {FALSE}
	LDR	lr, VideoPacketsReceived
	ADD	lr, lr, #1
	STR	lr, VideoPacketsReceived
 ]

	TEQ	r0, r0					; set EQ state, so we attempt to send data
	EXIT

	LTORG

 ] ; UseWholePackets

; **************************************************************************
;
;	VideoFreePacket - Free a packet
;
; in:	r0 -> packet descriptor
;	(r11 -> L64002_Registers)
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;	Also updates VideoPacketListHeadPtr, VideoPacketListTailPtr
;	Flags must be preserved
;

VideoFreePacket ROUT
	Push	"r1, lr"
	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0				; disable IRQs round this

	LDR	lr, [r0, #PacketDescriptor_Link]
	STR	lr, VideoPacketListHeadPtr	; update VideoPacketListHeadPtr
	TEQ	lr, #0				; and if no more,
	STREQ	lr, VideoPacketListTailPtr	; then zero VideoPacketListTailPtr

	TEQP	r1, #0				; restore IRQ state

	Push	"lr"
	MOV	lr, #0
	STR	lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
						; (we might want to be able to free multiple packets eventually)
	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine]
	Pull	"r0,r1, pc",,^			   ; exit preserving flags

; **************************************************************************
;
;	SyncOffset_Code - Set offset added to SCR values before programming

SyncOffset_Code Entry
	LDR	wp, [r12]

	LDRB	r1, [r0, #0]
	TEQ	r1, #"-"
	ADDEQ	r0, r0, #1
	MOVEQ	r6, #1
	MOVNE	r6, #0
	MOV	r1, r0
	MOV	r0, #10 :OR: (1:SHL:31) ; insist on space or ctrl char terminator, base 10
	SWI	XOS_ReadUnsigned
	EXIT	VS

	TEQ	r6, #0
	RSBNE	r2, r2, #0
	STR	r2, SyncOffset
	EXIT

; **************************************************************************
;
;	VideoInfo_Code - Output debugging info

VideoInfo_Code Entry "r8"
	LDR	wp, [r12]
	DLINE	"Audio Sample rate: ", cc
	LDR	r0, AudioSampleRate
	ADD	r0, r0, #1
	CMP	r0, #8+1
	BCS	%FT10
	ADRL	lr, AudioSampleRateStringOffsets
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, r0, lr
	SWI	XOS_Write0
	SWIVC	XOS_NewLine
	EXIT	VS
10
	DLINE	"Sequence layer data: ", cc
	ADR	r0, VideoSequenceData
	MOV	r1, #12
	BL	OutputHexBlock
	DLINE	""

 [ VetSCRValues
	LDR	r0, BadSCRCount
	DREG	r0, "Bad SCRs = "
 ]

	LDR	r0, DRAMBufferAddress
	DREG	r0, "DRAM buffer holds contents of address "
	DLINE	"...which are: ", cc
	ADR	r0, DRAMBuffer
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""

	LDR	r0, AudioChannelBufferReadPtr
	DREG	r0, "AudioChannelBufferReadPtr = "

	LDR	r0, AudioPTSInCount
	DREG	r0, "AudioPTSInCount = "

	LDR	r0, AudioFasts
	DREG	r0, "AudioFasts = "
	LDR	r0, AudioSlows
	DREG	r0, "AudioSlows = "

	LDR	r0, VideoSkips
	DREG	r0, "Video skips = "
	LDR	r0, VideoRepeats
	DREG	r0, "Video repeats = "
	LDR	r0, VideoPTSInCount
	DREG	r0, "Number of video PTSs that came in = "
	LDR	r0, VideoNumberOfPostedPTSs
	DREG	r0, "Number of posted video PTSs = "
	LDR	r0, VideoPTSPictureTypeCount_I
	DREG	r0, "Number of I-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_P
	DREG	r0, "Number of P-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_B
	DREG	r0, "Number of B-pictures with PTS = "
	LDR	r0, VideoMinPTSDifference
	DREG	r0, "Most negative PTS-SCR = "
	LDR	r0, VideoMaxPTSDifference
	DREG	r0, "Most positive PTS-SCR = "
 [ AllowSyncOnIFrames
	LDR	r0, SyncMode
	DREG	r0, "Sync mode flag = "
	LDR	r0, AnchorFIFOOverruns
	DREG	r0, "Anchor FIFO overruns = "
	LDR	r0, AnchorPostedPTSWritePtr
	DREG	r0, "Anchor PTSs written = "
	LDR	r0, AnchorPostedPTSReadPtr
	DREG	r0, "Anchor PTSs read = "
 ]
 [ CountVideoPackets
	LDR	r0, SyncMode
	DREG	r0, "Sync mode flag = "
	LDR	r0, VideoPacketsReceived
	DREG	r0, "Video packets received = "
	LDR	r0, VideoPicturesReceived
	DREG	r0, "Video pictures received = "
	LDR	r0, VideoOKCount
	DREG	r0, "Number of times no repeat necessary = "

	DLINE	"Video sync statistics"
	DLINE	"  Packets  Pictures"
	LDR	r0, VideoSyncPos
	ADRL	r1, VideoSyncStats
20
	SUBS	r0, r0, #8
	BCC	%FT30
	LDMIA	r1!, {r2, r3}
	DREG	r2, "  ", cc
	DREG	r3, " "
	B	%BT20

30
 ]
 [ TrickPlaySupport
	LDR	r0, TrickStops
	DREG	r0, "Trick stops = "
	LDR	r0, TrickStarts
	DREG	r0, "Trick starts = "
 ]
	LDR	r0, CurrentHorizontalSize
	DREG	r0, "Horizontal size = "
	LDR	r0, CurrentVerticalSize
	DREG	r0, "Vertical size = "
	LDR	r0, CurrentOutputWidth
	DREG	r0, "Horizontal display output size = "
	LDR	r0, VideoVBVSize
	DREG	r0, "Video VBV size = "
	LDR	r0, VideoPreFilling
	DREG	r0, "Video prefilling = "
	LDR	r0, AudioPreFilling
	DREG	r0, "Audio prefilling = "
 [ CountFieldInversions
	LDR	r0, FieldInversions
	DREG	r0, "Field inversions = "
 ]
	LDR	r0, BlankedSequences
	DREG	r0, "Blanked sequences = "
	LDR	r0, BlankedFields
	DREG	r0, "Blanked fields = "

	DLINE	"First item received was: ", cc
	LDR	r0, FirstItemReceived
	CMP	r0, #2
	MOVHI	r0, #3
	ADR	lr, ItemMapTable
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, lr, r0
	SWI	XOS_Write0
	SWI	XOS_NewLine

 [ CountUnderruns
	LDR	r0, VideoChannelUnderruns
	DREG	r0, "Video channel underruns = "
 ]
	DLINE	"** Audio info **"
	ADR	r8, AudioInfoStructure
	BL	OutputInfo

	DLINE	"** Video info **"
	ADR	r8, VideoInfoStructure
	BL	OutputInfo

 [ SaveAPacket
	LDR	r1, SavedPacketLength
	TEQ	r1, #0
	BNE	%FT40
	DLINE	"No saved video packet"
	B	%FT50
40
  [ Save1stFullPacket
	DLINE	"1st video PTS: ", cc
	LDR	r0, SavedPacketPTS +4
	CMP	r0, #-1
	BNE	%FT45
	DLINE	"none"
	B	%FT47
45
	ADR	r0, SavedPacketPTS +4
	MOV	r3, #5
46
	LDRB	r2, [r0], #-1
	BREG	r2, " ", cc
	SUBS	r3, r3, #1
	BNE	%BT46
	DLINE	""
47
	DLINE	"Saved 1st video packet:"
  |
	DLINE	"Saved 1st FIQ packet:"
  ]
	ADR	r0, FirstPacket
	BL	OutputHexBlock
	DLINE	""
50
 ]
	LDR	r0, LastErrorStatus
	DREG	r0, "Last ErrorStatus = "
	LDR	r0, CumulativeErrorStatus
	DREG	r0, "Cumulative ErrorStatus = "
	LDR	r0, VidRecErrors
	DREG	r0, "Video reconstruction errors = "
	LDR	r0, ContextErrors
	DREG	r0, "Context errors = "
	LDR	r0, VLCErrors
	DREG	r0, "VLC errors = "

	CLRV
	EXIT

ItemMapTable
	&	NothingString-ItemMapTable
	&	SequenceString-ItemMapTable
	&	PictureString-ItemMapTable
	&	UnknownString-ItemMapTable

NothingString	=	"nothing", 0
SequenceString	=	"a sequence header", 0
PictureString	=	"a picture header", 0
UnknownString	=	"unknown", 0
	ALIGN

OutputInfo Entry
	LDR	lr, [r8, #SI_SISPtr]
	LDR	r0, [lr, #SIS_SystemUnderruns]
	DREG	r0, "System buffer underruns = "
	LDR	r0, [lr, #SIS_DuffChannelAddresses]
	DREG	r0, "Duff channel addresses = "
	LDR	r0, [lr, #SIS_DuffSystemContents]
	DREG	r0, "Duff system buffer contents = "
	LDR	r0, [lr, #SIS_AddressOfLastDuff]
	DREG	r0, "Last duff contents address = "
	LDR	r0, [lr, #SIS_SystemBufferStart]
	DREG	r0, "SystemBufferStart = "
	LDR	r0, [lr, #SIS_SystemBufferEnd]
	DREG	r0, "SystemBufferEnd = "
	LDR	r0, [lr, #SIS_SystemBufferReadPtr]
	DREG	r0, "SystemBufferReadPtr = "
	LDR	r0, [lr, #SIS_SystemBufferWritePtr]
	DREG	r0, "SystemBufferWritePtr = "

	LDR	r2, [r8, #SI_PTSListReadPtr]
	DREG	r2, "PTSListReadPtr = "
	LDR	r3, [r8, #SI_PTSListWritePtr]
	DREG	r3, "PTSListWritePtr = "
	LDR	r0, [r8, #SI_PTSListOverruns]
	DREG	r0, "PTS list overruns = "

 [ {FALSE}
	LDR	r4, [r8, #SI_PTSListPtr]
	LDR	r5, [r8, #SI_PTSListSize]
	DLINE	"PTS List data:"
10
	TEQ	r2, r3
	BEQ	%FT20
	ADD	r0, r4, r2, LSL #3
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""
	ADD	r2, r2, #1
	TEQ	r2, r5
	MOVEQ	r2, #0
	B	%BT10
20
 ]
	CLRV
	EXIT


OutputHexBlock Entry "r0-r2"
10
	LDRB	r2, [r0], #1
	BREG	r2, " ", cc
	SUBS	r1, r1, #1
	BNE	%BT10
	EXIT

AudioSampleRateStringOffsets
	&	SRUK-AudioSampleRateStringOffsets
	&	SR2205-AudioSampleRateStringOffsets
	&	SR2400-AudioSampleRateStringOffsets
	&	SR1600-AudioSampleRateStringOffsets
	&	SRReserved-AudioSampleRateStringOffsets
	&	SR4410-AudioSampleRateStringOffsets
	&	SR4800-AudioSampleRateStringOffsets
	&	SR3200-AudioSampleRateStringOffsets
	&	SRReserved-AudioSampleRateStringOffsets

SRUK	=	"Unknown", 0
SRReserved =	"Reserved", 0
SR2205	=	"22.05kHz", 0
SR2400	=	"24kHz", 0
SR1600	=	"16kHz", 0
SR4410  =	"44.1kHz", 0
SR4800  =	"48kHz", 0
SR3200  =	"32kHz", 0
	ALIGN

; **************************************************************************

 [ RegDebug
ReadL64002_Help
	=	"*ReadL64002 reads an L64002 register.", CR
ReadL64002_Syntax
	=	"Syntax: *ReadL64002 <group> [<index>]", 0
WriteL64002_Help
	=	"*WriteL64002 writes an L64002 register.", CR
WriteL64002_Syntax
	=	"Syntax: *WriteL64002 <group> [<index>] <value>", 0
PacketInfo_Help
	=	"*PacketInfo gives info on video and audio packets held by MPEG2Video", CR
PacketInfo_Syntax
	=	"Syntax: *PacketInfo", 0
	ALIGN


; **************************************************************************
;
;	ReadL64002_Code - Entry point for *ReadL64002 command
;
; Syntax: ReadL64002 <group> [<index>]
; (index is required on groups 6 and 7)

ReadL64002_Code Entry "r11"
	LDR	wp, [r12]
	LDR	r11, L64002_Registers

	MOV	r4, r1					; r4 = number of parameters we had
	MOV	r1, r0					; r1 -> command tail
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #7					; maximum value for group
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r5, r2					; r5 = group
	CMP	r5, #6
	BCS	%FT50					; [reading group 6 or 7, so need index]

; not a banked group, so should be at end of line

	TEQ	r4, #1					; if correct number of parameters
	LDREQB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; then read data
	BEQ	%FT70					; and branch to display code
TooManyParams
	ADRL	r0, TooManyParametersError
	SETV
	EXIT

50
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #63					; maximum value of index is 63
	SWI	XOS_ReadUnsigned
	EXIT	VS

; r5 = group, r2 = index

	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0					; disable IRQs while we do this

	ReadReg r3, AIR					; preserve old AIR
	WriteReg r2, AIR				; set new AIR
	LDRB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; then read data
	WriteReg r3, AIR

	TEQP	r1, #0					; restore IRQ status
70
	DREG	r0, "Value is &"
	CLRV
	EXIT

; **************************************************************************
;
;	WriteL64002_Code - Entry point for *WriteL64002 command
;
; Syntax: WriteL64002 <group> [<index>] <value>
; (index is required on groups 6 and 7)

WriteL64002_Code ALTENTRY
	LDR	wp, [r12]
	LDR	r11, L64002_Registers

	MOV	r4, r1					; r4 = number of parameters we had
	MOV	r1, r0					; r1 -> command tail
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #7					; maximum value for group
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r5, r2					; r5 = group
	CMP	r5, #6
	BCS	%FT50					; [reading group 6 or 7, so need index]

; not a banked group, so should only have 2 parameters

	TEQ	r4, #2					; if incorrect number of parameters
	BNE	TooManyParams

	MOV	r0, #10 :OR: (1:SHL:30)			; restrict value to 0 to 255
	SWI	XOS_ReadUnsigned
	EXIT	VS

	STRB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; write data
	B	%FT70					; and branch to common exit code

50
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #63					; maximum value of index is 63
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r4, r2					; r4 = index

; now read value

	MOV	r0, #10 :OR: (1:SHL:30)			; restrict value to 0 to 255
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0					; disable IRQs while we do this

	ReadReg r3, AIR					; preserve old AIR
	WriteReg r4, AIR				; set new AIR
	STRB	r2, [r11, r5, LSL #L64002_Register_Address_Shift] ; then write data
	WriteReg r3, AIR

	TEQP	r1, #0					; restore IRQ status
70
	CLRV
	EXIT

PacketInfo_Code Entry
	LDR	wp, [r12]

	LDR	r0, VideoPacketListHeadPtr
	BL	CountPackets
	DREG	r1, "Number of video packets = &"
	DREG	r2, "Video packet data length = &"

	LDR	r0, AudioPacketListHeadPtr
	BL	CountPackets
	DREG	r1, "Number of audio packets = &"
	DREG	r2, "Audio packet data length = &"

	CLRV
	EXIT

CountPackets Entry
	MOV	lr, pc
	ORR	lr, lr, #I_bit			; disable IRQs so atomic
	TEQP	lr, #0

	MOV	r1, #0
	MOV	r2, #0
10
	TEQ	r0, #0
	ADDNE	r1, r1, #1			; increment number of packets
	LDRNE	r3, [r0, #PacketDescriptor_Length]
	ADDNE	r2, r2, r3
	LDRNE	r0, [r0, #PacketDescriptor_Link]
	BNE	%BT10

	EXITS					; exit restoring IRQ state

 ] ; RegDebug

; **************************************************************************
;
;	VideoStats - Entry point for MPEGVideo_Stats SWI - Return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = video stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

	MACRO
	StatsTableEntry	$tag, $value
 [ :BASE: ($value) = 12
	&	$tag, :INDEX: ($value)
 |
	ASSERT	:BASE: $value = 15
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

VideoStats	Entry "r2, r5-r6"

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	EXIT	EQ				; then exit

	ADR	r6, VideoStatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [wp, lr]
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

Stats_LengthOfPendingVideoPackets Entry "r0,r1"
	MOV	r0, pc
	ORR	r0, r0, #I_bit			; disable IRQs so atomic
	TEQP	r0, #0

	MOV	r6, #0
	LDR	lr, VideoPacketListHeadPtr
10
	TEQ	lr, #0
	LDRNE	r1, [lr, #PacketDescriptor_Length]
	ADDNE	r6, r6, r1
	LDRNE	lr, [lr, #PacketDescriptor_Link]
	BNE	%BT10
	EXITS					; exit restoring IRQ state

VideoStatsTable
 [ CountUnderruns
	StatsTableEntry &1000, VideoChannelUnderruns
 ]
	StatsTableEntry &1001, VideoAmountReceived
;	StatsTableEntry &1002, AmountSent
;	StatsTableEntry &1003, IRQCounts + 3*4
;  [ RegisterLastFullness
;	StatsTableEntry &1004, LastFullness
;  ]
;	StatsTableEntry &1005, LastAmountSent
;	StatsTableEntry &1006, NumberOfResets
;  [ DontFlushOnEmpty
;	StatsTableEntry &1007, LastFlushDidntHappen
;  ]
;	StatsTableEntry &1008, SpeedSetting
;  [ TrapUnderruns :LOR: CheckCountUnderrunsBit
;	StatsTableEntry &1009, UnderrunCondition
;  ]
;	StatsTableEntry &100A, LastCommandSent
	StatsTableEntry &100B, Stats_LengthOfPendingVideoPackets
	StatsTableEntry &100C, CumulativeErrorStatus
	StatsTableEntry &100D, VidRecErrors
	StatsTableEntry &100E, ContextErrors
	StatsTableEntry &100F, VLCErrors
	StatsTableEntry &1010, TimeOffsetOfVRError

	&	-1

; **************************************************************************
;
;	AudioOpenStream - Open MPEG audio stream
;
; in:	r0 = flags
;	r1 = control stream handle
;	r2 -> audio parameters structure
;
; out:  r0 = audio stream handle
;

AudioOpenStream Entry "r1,r2, r11"
	LDR	r11, L64002_Registers
	STR	r0, AudioStreamFlags
	STR	r1, AudioControlStreamHandle

	MOV	r0, #0
	STR	r0, AudioStreamClosing
	STR	r0, AudioNumberOfPTSs
	STR	r0, AudioInfoStructure+SI_PTSListOverruns
	STR	r0, AudioPacketListHeadPtr
	STR	r0, AudioPacketListTailPtr
	STR	r0, AudioPTSInCount
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioFasts
	STR	r0, AudioSlows
	STR	r0, AudioMuted

	MOV	r0, #-1
	STR	r0, AudioDiscardedDataCount

	BL	AudioReset

	MOV	r0, r12
	CLRV
	EXIT

; **************************************************************************
;
;	AudioFullPackets - Here's some more data
;
; in:	r0 = flags
;	r1 = audio stream handle
;	r2 -> one or more linked bitstream packets

AudioFullPackets Entry "r0,r11"
	LDR	r11, [r2, #PacketDescriptor_Length]
	CMP	r11, #0
	BGE	%FT01					; only complain about -ve length
	DREG	r11, "Packet length = "
01
	LDR	r11, L64002_Registers
	MOV	r0, pc
	Push	"r0"
	ORR	lr, r0, #I_bit
	TEQP	lr, #0					; disable IRQs round this bit

	LDR	r0, AudioPacketListTailPtr
	TEQ	r0, #0					; if nothing on list
	STREQ	r2, AudioPacketListHeadPtr		; then point head at new packets
	STRNE	r2, [r0, #PacketDescriptor_Link]	; else tail!link = packet
10
	LDR	r0, [r2, #PacketDescriptor_Link]	; go down list of packets to end
	TEQ	r0, #0
	MOVNE	r2, r0
	BNE	%BT10

	STR	r2, AudioPacketListTailPtr		; store new tail pointer
	Pull	"r0"
	TEQP	r0, #0					; restore IRQ state

	EXIT

; **************************************************************************
;
;	AudioCloseStream - Close MPEG audio stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGAudio_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:	r0 = flags
;	r1 = audio stream handle
;

AudioCloseStream Entry "r0-r2,r11"
	LDR	r11, L64002_Registers

	LDR	r0, AudioSpeedSetting
	TEQ	r0, #0
	BEQ	%FT50					; [it was paused, so junk data]

	BPL	%FT10					; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

	TEQ	r0, #&80000000
	BEQ	%FT50

   [ SendPlaySWI
	BLCS	AudioIssuePlaySWI
   |
	BLCS	AudioSendPlay
   ]

; wait for data to empty

10
	MOV	r0, #1					; indicate to multiple picture packet checker that we won't get
	STR	r0, AudioStreamClosing			; any more data, so don't hang around
20
	TEQP	pc, #0
	NOP						; allow callbacks
	SWI	OS_EnterOS

	LDR	r0, AudioPacketListHeadPtr		; do we have any outstanding packets?
	CMP	r0, #0					; V := 0
	BNE	%BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
	MOV	r0, #2
	STR	r0, AudioStreamClosing
60
	LDR	r0, AudioPacketListHeadPtr
	CMP	r0, #0				; V := 0
	BLNE	AudioFreePacket
	BNE	%BT60
70
	BL	AudioReleaseInterruptVectors
	LDR	r0, VideoControlStreamHandle		; if video not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, AudioControlStreamHandle		; stream no longer open
	EXIT

; **************************************************************************
;
;	AudioPlay - Start going
;
; in:	r0 = flags
;	r1 = audio stream handle
;
; out:  -
;

AudioPlay Entry "r0,r2, r11"
	LDR	r2, AudioSpeedSetting
	BIC	r2, r2, #&80000000	; clear pre-buffering bit
	STR	r2, AudioSpeedSetting
	BL	AudioSetSpeed
	EXIT

; **************************************************************************
;
;	AudioSetSpeed - Set speed of MPEG stream
;
; in:	r0 = flags
;	r1 = audio stream handle
;	r2 = speed indicator
;	       0    = paused
;	       1    = normal speed
;	       2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

AudioSetSpeed Entry "r0-r2, r11"
	LDR	r11, L64002_Registers
	CMP	r2, #8					; don't allow speeds slower than 8
	EXIT	HI

	LDR	r0, AudioSpeedSetting
	TST	r0, #&80000000				; if pre-buffering
	ORRNE	r2, r2, #&80000000			; then still pre-buffering, but may have speed setting after
	STR	r2, AudioSpeedSetting

	CMP	r2, #1
 [ VetSCRValues
	MOVNE	lr, #0					; if pause or slo-mo, reset vetting state
	STRNE	lr, VetSCRState				; until we receive 1st SCR after return to normal play
 ]
	BLT	%FT10					; pause (or pre-buffering)
	BEQ	%FT20					; normal speed

	MOV	r0, r2
	BL	AudioSlowMotion
	EXIT

10
	BL	AudioSendPause
	CLRV
	EXIT

20
	BL	AudioSendPlay
	EXIT

 [ SendPlaySWI

AudioIssuePlaySWI Entry "r0,r1"
	MOV	r0, #StreamFlags_AudioPresent	; indicate audio now ready
	LDR	r1, AudioControlStreamHandle
	SWI	XMPEGControl_Play

	EXIT
 ]

; **************************************************************************
;
;	AudioResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = audio stream handle
;
; out:	r2 = estimate of number of bytes discarded

AudioResetStream Entry "r0-r2"
	LDR	r11, L64002_Registers

	MOV	r2, #2				; pretend we're closing, so we don't send any more data to it in background
	STR	r2, AudioStreamClosing

	LDR	r2, AudioDiscardedDataCount	; if we've already just had an MPEGVideo_ResetStream
	CMP	r2, #-1				; then the audio channel buffer's already been flushed
	BNE	%FT10

	BL	AudioGetBufferFullness		; else find current fullness (returns it in r2)
	BL	VideoReleaseInterruptVectors	; just in case
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors

10
	MOV	r0, #-1
	STR	r0, AudioDiscardedDataCount	; zero it for next time

	LDR	r0, AudioPacketListHeadPtr
20
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	AudioFreePacket				; and free the packet
	BNE	%BT20					; then loop

	STR	r2, [sp, #2*4]			; update returned r2 value with byte count

	BL	AudioReset

	MOV	r0, #0
	STR	r0, AudioStreamClosing

	CLRV
	EXIT

; **************************************************************************
;
;	AudioReset - Reset vars and stuff common to OpenStream and ResetStream
;

AudioReset Entry "r0"
	MOV	r0, #0
	STR	r0, AudioAmountSent
	STR	r0, AudioInfoStructure+SI_PTSListReadPtr
	STR	r0, AudioInfoStructure+SI_PTSListWritePtr
	STR	r0, AudioResyncDelay
	STR	r0, AudioLastPTS +0			; zero LastPTS record
	STR	r0, AudioLastPTS +4

 [ VetSCRValues
	STR	r0, VetSCRState				; indicate awaiting first SCR
	STR	r0, BadSCRCount				; no bad'uns yet
 ]
	MOV	r0, #1
	STR	r0, AudioPreFilling

	MOV	r0, #-1			; set audio sample rate to unknown
	STR	r0, AudioSampleRate

	MOV	r0, #&80000001		; indicate pre-buffering, but would otherwise be playing normal speed
	STR	r0, AudioSpeedSetting

	LDR	r0, VideoControlStreamHandle
	TEQ	r0, #0
	BLEQ	InitStream_Common
	BL	AudioClaimInterruptVectors

	LDR	r0, AudioMuted
	BL	AudioMuteSound

	EXIT

; **************************************************************************
;
;	AudioFreePacket - Free a packet
;
; in:	r0 -> packet descriptor
;	(r11 -> CL450_Registers)
;	IRQs disabled
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;	Also updates AudioPacketListHeadPtr, AudioPacketListTailPtr
;	Flags must be preserved
;

AudioFreePacket ROUT
	Push	"r1, lr"
	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0				; disable IRQs round this

	LDR	lr, [r0, #PacketDescriptor_Link]
	STR	lr, AudioPacketListHeadPtr	; update AudioPacketListHeadPtr
	TEQ	lr, #0				; and if no more,
	STREQ	lr, AudioPacketListTailPtr	; then zero AudioPacketListTailPtr

	TEQP	r1, #0				; restore IRQ state

	Push	"lr"
	MOV	lr, #0
	STR	lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
						; (we might want to be able to free multiple packets eventually)
	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine]
	Pull	"r0,r1, pc",,^			   ; exit preserving flags

; **************************************************************************
;
;	AudioMuteSound - Mute/unmute sound
;
; in:	r0 = flags
;	  bit 0 = 1   => sound off
;		= 0   => sound on
;	  bits 1..31 reserved - should be zero
;	(r1 = audio stream handle)
;
; out:  -
;

AudioMuteSound Entry "r0, r11"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	LDR	r11, L64002_Registers
	ReadRegI lr, AudioModeControl
	ANDS	r0, r0, #1
	STR	r0, AudioMuted
	BICEQ	lr, lr, #AudioModeControl_AudioSoftMute	; EQ => not muted
	ORRNE	lr, lr, #AudioModeControl_AudioSoftMute ; NE => muted
	WriteRegI lr, AudioModeControl, r0

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSendPlay - Start decoder playing

AudioSendPlay Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Play
	WriteRegI r0, AudioTrickModes, lr

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSendPause - Stop decoder playing

AudioSendPause Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Pause
	WriteRegI r0, AudioTrickModes, lr

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

AudioGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, AudioChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, AudioChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	AudioTickerV - Audio TickerV routine

AudioTickerV Entry "r0-r2"
	LDR	r0, AudioCallBackRequested	; is a callback already requested
	TEQ	r0, #0
	EXIT	NE				; if so, don't ask for another
	MOV	r2, pc
	ORR	r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
	TEQP	r1, #0
	NOP
	Push	"r14"
	LDR	r0, AudioStreamFlags
	TST	r0, #StreamFlags_UseCallBacks
	BEQ	%FT20				; [stuff directly]

	ADR	r0, AudioTickerVCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	MOVVC	r0, #1
	STRVC	r0, AudioCallBackRequested	; indicate that we've requested a callback
10
	Pull	"r14"
	TEQP	r2, #0
	NOP
	EXIT

20
	MOV	r0, #1
	STR	r0, AudioCallBackRequested
	BL	AudioTickerVCallBack
	B	%BT10

	LTORG

AudioTickerVCallBack Entry "r0,r1, r11"
 [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
 ]
	LDR	r11, L64002_Registers
	BL	AudioDoStuffWithData
	MOV	r0, #0
	STR	r0, AudioCallBackRequested
	EXIT

	LTORG

AudioDoStuffWithData Entry "r0"
	LDR	r0, AudioStreamClosing	; if stream closing (ie value = 2)
	CMP	r0, #1			; don't send any more data
	EXIT	HI
05
	LDR	r0, AudioPacketListHeadPtr
	TEQ	r0, #0			; do we have any data?
	BEQ	%FT50			; [no, so skip]

 [ UseWholePackets
	BL	AudioSendNewPacketIfNecessary
	BLEQ	AudioSendData
 |
	BL	AudioSendData
 ]
	BLEQ	AudioFreePacket
	BEQ	%BT05
50
	BL	AudioDoStreamSync	; check buffer fullness
	EXIT

; **************************************************************************
;
;	AudioDoStreamSync - Synchronise to stream (if required)
;
; in:	r11 -> L64002_Registers
; out:  -

AudioDoStreamSync Entry "r0-r2"
	LDR	r0, AudioStreamClosing		; if not active, exit
	TEQ	r0, #0
	EXIT	NE

	LDR	r0, AudioSpeedSetting
	TEQ	r0, #0				; if paused (0) or pre-filling (bit 31 set)
	EXIT	LS				; then exit

	LDR	r0, AudioStreamFlags
	TST	r0, #StreamFlags_SyncToStream	; if not syncing to stream
	EXIT	EQ				; then exit

	LDR	r0, AudioResyncDelay
	SUBS	r0, r0, #1
	STRCS	r0, AudioResyncDelay
	EXIT	CS

	BL	AudioGetBufferFullness		; returned in r2
	STR	r2, LastAudioBufferFullness
	LDR	lr, AudioBufferChecks
	ADD	lr, lr, #1
	STR	lr, AudioBufferChecks

	LDR	r1, =AudioBufferLowWaterMark
	CMP	r2, r1
	MOVCC	r1, #AudioResyncRepeat-1
	STRCC	r1, AudioResyncDelay
	BLCC	AudioPlaySlowFrame

	LDR	r1, =AudioBufferHighWaterMark
	CMP	r2, r1
	MOVCS	r1, #AudioResyncRepeat-1
	STRCS	r1, AudioResyncDelay
	BLCS	AudioPlayFastFrame
	EXIT

; **************************************************************************
;
;	AudioPlayFastFrame - Play one audio frame fast
;
; in:	r11 -> L64002 registers
;
; out:  -

AudioPlayFastFrame Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Fast
	WriteRegI r0, AudioTrickModes, lr

	LDR	lr, AudioFasts
	ADD	lr, lr, #1
	STR	lr, AudioFasts
	EXITS					; exit restoring IRQ state

; **************************************************************************
;
;	AudioPlaySlowFrame - Play one audio frame slow
;
; in:	r11 -> L64002 registers
;
; out:  -

AudioPlaySlowFrame Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Slow
	WriteRegI r0, AudioTrickModes, lr

	LDR	lr, AudioSlows
	ADD	lr, lr, #1
	STR	lr, AudioSlows
	EXITS					; exit restoring IRQ state

 [ UseWholePackets
; **************************************************************************
;
;	AudioSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:	r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

AudioSendNewPacketIfNecessary Entry "r1-r5, r11"
;	BL	CheckForSyncWord
;	EXIT	NE
	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart	; is it start of an MPEG packet?
	EXIT	EQ					; [no, so no packet header required, exit EQ => try to send data]

	LDR	r11, L64002_Registers

	ReadReg	r2, Status0
	TST	r2, #L64002_Status0_AudioChannelReady
	BNE	%FT10					; [is some space free in buffer]

	CMP	pc, #0					; set NE, ie not OK to continue
	EXIT

10
	LDR	r2, L64002_Audio_Data_Write
	MOV	r3, #0
	BL	AudioWaitAndSendByte			; send 1st byte of start code
	BL	AudioWaitAndSendByte			; send 2nd byte of start code
	MOV	r3, #1
	BL	AudioWaitAndSendByte			; send 3rd byte of start code
	MOV	r3, #&C0
	BL	AudioWaitAndSendByte			; send 4th byte of start code
	LDR	r4, [r0, #PacketDescriptor_FullLength]
	TST	r1, #PacketDescriptorFlags_PTSValid
	BEQ	%FT30
	MOV	r3, pc
	ORR	lr, r3, #I_bit
	TEQP	lr, #0
	LDR	lr, AudioPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, AudioPTSInCount
	TEQP	r3, #0
30
 [ AudioSquawkFix2

; Bug 4-20 on the L64002 bug sheet describes something similar sounding to the audio squawk problem, albeit with
; serial input of data. It claims it only happens if the PES packet header is not a multiple of 8 bytes.
; So try padding audio packets to 8 bytes if no PTS or 16 bytes if there is a PTS.

	ADDEQ	r4, r4, #2				; add on two for FF 0F bytes if no PTS
	ADDNE	r4, r4, #10				; add on ten for 5 padding + 5 PTS
	MOV	r3, r4, LSR #8
	BL	AudioWaitAndSendByte			; send hi byte of length
	AND	r3, r4, #&FF
	BL	AudioWaitAndSendByte			; send lo byte of length
	MOV	r3, #&FF				; always send at least one byte of padding
	BL	AudioWaitAndSendByte
	MOVEQ	r3, #&0F				; no PTS, so send terminating code
	BEQ	%FT50

	BL	AudioWaitAndSendByte			; send 4 more padding bytes before PTS (r3 = &FF)
	BL	AudioWaitAndSendByte
	BL	AudioWaitAndSendByte
	BL	AudioWaitAndSendByte

	LDR	r4, [r0, #PacketDescriptor_PTS]		; get bits 31..0 of PTS
	LDR	r5, [r0, #PacketDescriptor_PTS+4]	; get bit 32 of PTS
	MOV	r3, r4, LSR #29				; r3 = bits 31..29 in bits 2..0
	ORR	r3, r3, r5, LSL #3			; r3 = bits 32..29 in bits 3..0
	ORR	r3, r3, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSR #22				; r3 = bits 29..22 in bits 7..0
	BL	AudioWaitAndSendByte			; (only stores bottom 8 bits)
	MOV	r3, r4, LSR #14				; r3 = bits 21..14 in bits 7..0
	ORR	r3, r3, #1				; force bit 0 to 1 (marker)
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSR #7				; r3 = bits 14..7 in bits 7..0
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSL #1				; r3 = bits 6..0 in bits 7..1
	ORR	r3, r3, #1
50
 |
	ADDEQ	r4, r4, #1				; add on one for 0F byte if no PTS
	ADDNE	r4, r4, #5				; add on five for PTS
	MOV	r3, r4, LSR #8
	BL	AudioWaitAndSendByte			; send hi byte of length
	AND	r3, r4, #&FF
	BL	AudioWaitAndSendByte			; send lo byte of length
	MOVEQ	r3, #&0F				; no PTS, so send terminating code
	BEQ	%FT50

	LDR	r4, [r0, #PacketDescriptor_PTS]		; get bits 31..0 of PTS
	LDR	r5, [r0, #PacketDescriptor_PTS+4]	; get bit 32 of PTS
	MOV	r3, r4, LSR #29				; r3 = bits 31..29 in bits 2..0
	ORR	r3, r3, r5, LSL #3			; r3 = bits 32..29 in bits 3..0
	ORR	r3, r3, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSR #22				; r3 = bits 29..22 in bits 7..0
	BL	AudioWaitAndSendByte			; (only stores bottom 8 bits)
	MOV	r3, r4, LSR #14				; r3 = bits 21..14 in bits 7..0
	ORR	r3, r3, #1				; force bit 0 to 1 (marker)
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSR #7				; r3 = bits 14..7 in bits 7..0
	BL	AudioWaitAndSendByte
	MOV	r3, r4, LSL #1				; r3 = bits 6..0 in bits 7..1
	ORR	r3, r3, #1
50
 ]
	BL	AudioWaitAndSendByte
	BIC	r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
	STR	r1, [r0, #PacketDescriptor_Flags]	; we don't send hdr again
	TEQ	r0, r0					; set EQ state, so we attempt to send data
	EXIT

AudioWaitAndSendByte Entry
10
	ReadReg	lr, Status0
	TST	lr, #L64002_Status0_AudioChannelReady
	BEQ	%BT10
	STRB	r3, [r2]
	EXITS

 ] ; UseWholePackets

; **************************************************************************
;
;	AudioSendData - Send a block of data
;
; in:	r0 -> packet descriptor
;	r11 -> L64002_Registers
;
; out:	EQ => used up all data in this packet

AudioSendData Entry "r0-r4"
	LDR	r1, [r0, #PacketDescriptor_Start]
	LDR	r3, [r0, #PacketDescriptor_Length]
	CMP	r3, #0					; zero length?
	EXIT	EQ

	BL	AudioGetBufferFullness
	LDR	lr, AudioChannelBufferSize
	SUB	r2, lr, r2				; amount of free space in audio channel buffer

	CMP	r2, r3					; if more than packet size
	MOVHI	r2, r3					; then do packet amount

	MOV	r3, r2					; number left to do (save r2 for later)
	LDR	lr, L64002_Audio_Data_Write
10
	ReadReg	r4, Status0
	TST	r4, #L64002_Status0_AudioChannelReady
	BEQ	%FT15					; [not ready, so exit]

	LDRB	r4, [r1], #1
	STRB	r4, [lr]
	SUBS	r3, r3, #1
	BNE	%BT10
15
	SUB	r2, r2, r3				; number of bytes sent

	LDR	r4, [r0, #PacketDescriptor_Length]
	SUB	r4, r4, r2				; decrement remaining length
	STR	r4, [r0, #PacketDescriptor_Length]

	LDR	lr, AudioAmountSent
	ADD	lr, lr, r2
	STR	lr, AudioAmountSent

	LDR	r3, AudioPreFilling
	TEQ	r3, #0
	BEQ	%FT20

	LDR	r3, =AudioPreFillSize
	CMP	lr, r3
	MOVCS	lr, #0
	STRCS	lr, AudioPreFilling
	BLCS	AudioIssuePlaySWI
20
	STR	r1, [r0, #PacketDescriptor_Start]
	TEQ	r4, #0
	EXIT

; **************************************************************************
;
;	Message stuff


 [ international
CopyError ENTRY "r1-r7"
	BL	open_messagefile
	EXIT	VS
	ADR	r1, MessageFile_Block
	MOV	r2, #0
	LDR	r4, [sp]	; R1 (parameter) -> R4
	MOV	r5, #0
	MOV	r6, #0
	MOV	r7, #0
	SWI	XMessageTrans_ErrorLookup
	EXIT

message_filename
	DCB	"Resources:$.Resources.ARM600.Messages", 0
	ALIGN

open_messagefile ENTRY "r0-r2"
	LDR	r0, MessageFile_Open
	CMP	r0, #0
	EXIT	NE
	ADR	r0, MessageFile_Block
	ADR	r1, message_filename
	MOV	r2, #0
	SWI	XMessageTrans_OpenFile
	STRVS	r0, [sp]
	EXIT	VS
	MOV	r0, #1
	STR	r0, MessageFile_Open
	EXIT

write_r0_message ENTRY "r0-r7"
	BL	open_messagefile
	STRVS	r0, [sp]
	EXIT	VS
	MOV	r1, r0
	ADR	r0, MessageFile_Block
	MOV	r2, #0
	MOV	r4, #0
	MOV	r5, #0
	MOV	r6, #0
	MOV	r7, #0
	SWI	XMessageTrans_Lookup
	STRVS	r0, [sp]
	EXIT	VS
10	LDRB	r0, [r2], #1
	CMP	r0, #" "
	SWICS	XOS_WriteC
	STRVS	r0, [sp]
	EXIT	VS
	BCS	%B10
	SWI	XOS_NewLine
	EXIT
 |
write_r0_message ENTRY "r0"
	SWI	XOS_Write0
	STRVS	r0, [sp]
	EXIT
 ]

SetupData
	BIN	"$SetupFile"
SetupDataEnd

	InsertDebugRoutines

	END
