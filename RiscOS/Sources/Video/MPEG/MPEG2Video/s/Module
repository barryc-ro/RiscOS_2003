; > Module
; Source for MPEG 2 Video Module

; ***********************************
; ***	 C h a n g e   L i s t	  ***
; ***********************************

; Date	     Who  Version	Description
; ----	     ---  -------	-----------
; 17-May-94  TMD  0.01		Started work
; 03-Jun-94  TMD  0.02		Variable transparency now possible in 16bpp
; 08-Jun-94  TMD  0.03		Added SWI MPEGVideo_CardControl
; 13-Jun-94  TMD  0.04		Added bodge for audio IRQ booboo
; 24-Jun-94  TMD  0.05		Started putting synchronisation stuff in
; 07-Jul-94  TMD  0.06		New stuffing strategy implemented - stuff on a callback from TickerV
; 18-Jul-94  TMD  0.10		Release for Malcolm's trip
; 22-Jul-94  TMD  0.11		Added SyncOffset command
; 29-Jul-94  TMD  0.13		Modified CloseStream behaviour to wait until empty unless paused, in which case junk data
; 17-Aug-94  TMD  0.14		Made transition from pause or slomo to normal set the SCR to the last received PTS
;				 before sending Play command.
; 18-Aug-94  TMD  0.15		Added MPEGVideo_ReadParameters (Read time code)
; 19-Aug-94  TMD  0.16		Started putting in skip to GOP or sequence header stuff (incomplete)
; 22-Aug-94  TMD  0.17		On close, if still in initial pause state, then send Play command.
; 22-Aug-94  TMD  0.18		(Conditionally) enable IRQs inside TickerV during foreground stuffing.
; 26-Aug-94  TMD  0.19		Only enable IRQs in TickerV if not doing AudioIRQBodge.
; 31-Aug-94  TMD  0.20		(Conditionally) select fast (type C) podule access.
; 31-Aug-94  TMD  0.21		Added support for directly calling SetSCR.
; 01-Sep-94  TMD  0.22		Added code to time completion of previous command.
; 05-Sep-94  TMD  0.23		(Conditionally) throw away PTSs if they are within a range of the last one sent.
; 08-Sep-94  TMD  0.24		Pass flags to MPEGControl_Play
; 08-Sep-94  TMD  0.25		Started to add MPEG still capability
; 09-Sep-94  TMD  0.26		(Conditionally) throw away SCRs if they are within a range of the last one sent.
; 09-Sep-94  TMD  0.27		(Conditionally) check packets for more than one picture_start code
; 12-Sep-94  TMD  0.28		Added reason code 2 (Update Control register) to MPEGVideo_CardControl
;				Check existence of system variable 'TVOn' to determine whether to enable CTRL0, CTRL1 on init
; 10-Oct-94  TMD  0.29		If waiting for stream to close, don't stop sending an incomplete packet in order to check it.
; 12-Oct-94  TMD  0.30		Don't print warning message on zero-length packets
; 20-Oct-94  TMD  0.31		Fixed stack-imbalance in MyAudioIRQRoutine
; 07-Nov-94  TMD  0.32		Remember speed setting if received while pre-buffering
; 07-Nov-94  TMD  0.33		When we start playing, set the SCR to the last received PTS value, so -noaudio works from
;				 middle of file
; 16-Nov-94  TMD  0.34		Changes to support MPEG 2 indeterminate-length packets.
; 05-Dec-94  TMD  0.35		Reverse length correction for odd-length packets
; 07-Dec-94  TMD  0.36		Start putting in skipping until GOP or sequence_header by blanking display
;				 until we get the appropriate IRQ from CL450
; 12-Dec-94  TMD  0.37		Separate out the options for SEQ, GOP or PIC skipping.
; 14-Dec-94  TMD  0.38		Created 'M' variant for CC/Wild Vision Movie Magic card.
; 14-Dec-94  TMD  0.39		Added 'NoInterlace' bit to video flags
; 15-Dec-94  TMD  0.40		Fixed accidental V set returning when pausing while pre-buffering.
;				Fixed CloseStream hanging if we aborted while pre-buffering.
; 15-Dec-94  TMD  0.41		Always enable PIC-V IRQ but don't unblank on it unless the appropriate bit
;				is set in VideoStructure_Flags. This is because SEQ-V and GOP IRQs seem to be
;				inhibited on certain clips if PIC-V is not also enabled.
; 17-Feb-95  TMD  0.42		Change product-type matching code for recognition of podule:
;				 No longer match &0000 in any version
;				 Do allow &00F9 in all versions (as well as &00FF in non-'M' versions)
; 06-Mar-95  TMD  0.43		Added MPEGVideo_ResetStream (initial implementation)
; 16-Mar-95  TMD  0.44		Fixed bug which cleared -nocls and -nopalettechange flags if skipping to pic,seq, or gop
; 28-Apr-95  TMD  2.00		MPEG 2 L64002 version, adapted from MPEG 1 CL450 version
; 25-Jan-96  TMD  2.01		New version for Rev.C chip
; 11-Sep-96  TMD  2.02		Make modulator boost bit reflect CTRL1
; 11-Sep-96  TMD  2.03		Check product type at run time to determine whether to program Japanese DACs or not
; 18-Oct-96  TMD  2.04		Provide MPEGVideo_ReadParameters(5) to check if display ready
; 19-Nov-96  TMD  2.05		Put in MPEGVideo/Audio_ResetStream that does a full reset of L64002.
; 20-Nov-96  TMD  2.06		Put in stuff that clears frame buffers in DRAM to black explicitly.
; 21-Nov-96  TMD  2.07		Put back SAA7167 stuff, executed only if cardtype is not STB2_MPEG2 or STB1_MPEG2.
; 27-Nov-96  TMD  2.08		Put in stuff to cope with crappy fast files.
; 28-Nov-96  TMD  2.09		Put in code to allow proper synchronisation on video-only I-frame-only movies.
; 02-Dec-96  TMD  2.10		Count video packets in order to know if we've received a whole picture to decode yet.
; 14-Jan-97  TMD  2.11		Revert to AllowSyncOnIFrames, rather than counting packets, since pictures can be bigger
;				 than one packet.
; 11-Feb-97  TMD  2.12		Add debugging for bottom-field-first movies.
; 12-Feb-97  TMD  2.13		Modify palette programming to be suitable for non-Macrovision 16bpp use
; 14-Feb-97  TMD  2.14		Wait for 3 sequence headers + 4 fields before unblanking, as a test
; 14-Feb-97  TMD  2.15		Added MPEGVideo_ReadParameters(4) implementation - read video buffer fullness
; 14-Feb-97  TMD  2.16		Added programmable number of sequence headers + fields to wait for before unblanking
; 10-Mar-97  TMD  2.17		Added code to count video channel underruns, but it doesn't work yet!
; 11-Mar-97  TMD  2.18		Do freeze field on pause.
; 11-Mar-97  TMD  2.19		Added MPEGAudio_MuteSound.
; 13-Mar-97  TMD  2.20		Keep record of whether we received a sequence header or picture header first after reset.
; 02-Apr-97  TMD  2.21		On init, set ModulatorBoost bit as well as CTRL0/1 if TVOn variable set.
; 14-Apr-97  TMD  2.22		Another attempt to get CountUnderruns to work (at least 0 or non-zero).
; 15-Apr-97  TMD  2.23		Put in Stats SWI.
; 18-Apr-97  TMD  2.24		Added record of first packet received (including PTS) after a resetstream.
;				Keep record of last and cumulative ErrorStatus bytes.
; 21-Apr-97  TMD  2.25		Added in statistic for time of 1st vid recon error after last video reset.
; 22-Apr-97  TMD  2.26		Added option to capture first packet sent to FIFO by FIQ code.
; 23-Apr-97  TMD  2.27		Preserve audio mute status over ResetStream.
; 24-Apr-97  TMD  2.28		(Conditionally) Only enable IRQs in VideoTickerVCallBack if actually called from callback,
;				 rather than direct on TickerV.
; 29-Apr-97  TMD  2.29		Drive ModulatorBoost from CTRL0, not CTRL1, so still enabled in Macrovision mode.
; 28-May-97  TMD  2.30		Program border colour to only set ED[0], to be suitable for non-Macrovision use.
; 05-Jun-97  TMD  2.31		Attempt to protect against electric surges by holding reset active for 10ms
; 21-Aug-97  TMD  2.32		Remove surge protection, make it wait for vsync before resetting L64002.
; 29-Oct-97  TMD  2.33		(Conditionally) Added commands for access to registers.
; 03-Nov-97  TMD  2.34		Started stuff for trick play mode support (incomplete so disabled).
; 05-Nov-97  TMD  2.35		Disable IRQs in AudioMuteSound, AudioSendPlay, AudioSendPause, AudioPlayFastFrame,
;				 AudioPlaySlowFrame around access to banked registers.
; 07-Nov-97  TMD  2.36		Enable trick play support
; 10-Nov-97  TMD  2.37		Fix CheckErrorStatus so it saves lr_svc around the SWI call.
; 10-Nov-97  TMD  2.38		Remove TrickPlay stuff so above fix can be tested.
; 11-Nov-97  TMD  2.39		Put TrickPlay back in again.
; 11-Nov-97  TMD  2.40		Use correct TrickPlay code!
; 14-Nov-97  TMD  2.41		Only enable trick play fixes when trick play mode is indicated, and structure flags enable them.
; 14-Nov-97  TMD  2.42		Don't check for incomplete PES packet if not doing trickplay packet length fix
; 20-Nov-97  TMD  2.43		Fix setting of TrickPlay variable in VideoResetStream.
; 20-Nov-97  TMD  2.44		(Conditionally) only do underrun fix on odd fields.
; 20-Nov-97  TMD  2.45		(Conditionally) freeze field if stopping the decoder to prevent underruns.
; 21-Nov-97  TMD  2.46		Zero TrickStopFreeze on ResetStream as well as OpenStream
; 08-Jan-98  TMD  2.47		Attempt to cope with QSIF images (well at least don't scale horiz to fill screen)
; 16-Jan-98  TMD  2.48		(Conditionally) attempt to fix audio squawk problem.
; 16-Jan-98  TMD  2.49		Fix bug in system buffer parsing of MPEG2 PES packet, revealed by above fix.
; 10-Feb-98  TMD  2.50		On real STB2200, use video structure flags to choose PAL or NTSC.
; 11-Feb-98  TMD  2.51		Re-register program element handlers on Service_MPEGControlStarting.
; 11-Mar-98  TMD  2.52		(Conditionally) put in RAMFS debugging
; 11-Mar-98  TMD  2.53		Make audio packetisation use MPEG2 PES as per video, with multiple of 8 bytes packet header
; 11-Mar-98  TMD  2.54		Discard initial video/audio packets until we get start of MPEG packet on each
; 20-Apr-98  TMD  2.55		Adjust horizontal scaler to take aspect_ratio_information into account
; 09-Oct-98  TMD  2.56		Add dual mono and mute-on-error support.
; 21-Oct-98  TMD  2.57		(Conditionally) call InitL64002 on module initialisation (to avoid green screen).
; 23-Oct-98  TMD  2.58		Fix dual mono code so it doesn't crash (hopefully!)
; 03-Nov-98  TMD  2.59		Disable InitL64002OnModuleInit
; 03-Nov-98  TMD  2.60		Put back VideoStats to how it was before I put in and removed AudioStats
; 04-Nov-98  TMD  2.61		Fix unknown SWI handler so Audio_Stats and Audio_SoundVolume don't barf, and
;				 reenable InitL64002OnModuleInit as that wasn't the problem.
; 10-Nov-98  TMD  2.62		Fix bug in AudioDoStreamSync - might do syncing when in prefilling, or
;				 might not do syncing when it should.
; 11-Nov-98  TMD  2.63		Record start and end times for receiving audio data, and total audio bytes received.
; 12-Nov-98  TMD  2.64		(Conditionally) increase audio-to-stream thresholds to 16K +/- 8K (including data received
;				 but not yet delivered to L64002) instead of 4K +/- 1K.
; 18-Nov-98  TMD  2.65		Read variables to determine audio prefill size and low/high water thresholds
; 19-Nov-98  TMD  2.66		Timeout of audio packet header send, and count occurences of this.
; 19-Nov-98  TMD  2.67		(Conditionally) check amount of space in audio channel buffer before sending PES packet header.
; 25-Nov-98  TMD  2.68		Fix aspect ratio for reserved values, and initialise current value.
; 26-Nov-98  TMD  2.69		Increase audio buffer free space allowance to 64 bytes for packet header stuffing.
;				Record minimum and maximum delay between audio packets arriving.
; 26-Nov-98  TMD  2.70		Record first time that audio played frame slow, and first packet header send timeout
; 26-Nov-98  TMD  2.71		Restructure code that sends audio packet headers so can give up and try later.
; 27-Nov-98  TMD  2.72		Removed some debugging code which is now obsolete.
; 03-Dec-98  TMD  2.73		Remove CheckAudioFullnessForHeaders flag (obsolete).
;				Make square-pixel aspect ratio value produce standard 4:3 output (scaling down doesn't work).
; 07-Dec-98  TMD  2.74		(Conditionally) support slow-motion (on servers with flow-control).
; 07-Dec-98  TMD  2.75		Fix muting problem introduced by slow-mo code.
; 07-Dec-98  TMD  2.76		Zero TrickStopFreeze on switch to normal play.
; 25-Jan-99  NDT  2.77		Added partial support for STB3 style card.
; 29-Jan-99  BJGA 2.78          Added mapping of CTRL0 and CTRL1 bits from Control Register 2 to IOMD CLINES (as in STB3).
; 09-Feb-99  BJGA 2.79          Bugfix: UpdateControlRegister_ bitfield tests now account for r1/r2 being shifted 8 bits left...
; 04-Mar-99  NDT  2.80          Updated to use PortMan if the SCART control bits are in IOMD.
;                                This actually works if STBState also uses PortMan, as STBState will no longer trample on the SCART bits.
; 17-Mar-99  BJGA 2.81          Disables FIQs in IOMD in ReleaseFIQs.
; 07-Apr-99  BJGA 2.81-4.3.2.1  Implemented extraction of DiviCom format line 21 (closed captions) data from picture layer user data using the L64002's
;                                user data FIFO, its reordering into display order, and the passing of the data to the Macrovision module for encoding.
; 23-Apr-99  BJGA 2.81-4.3.2.4  Aux data FIFO parsing enhanced - now interruptible, so we can start reading it on the DataFIFOReady IRQ (bug 30,
;                                errata sheet v3.0) and can handle extension layer data (needed by pulldown). Extension data initialised suitably.
;                                Software-controlled 3:2 pulldown implemented on a picture-by-picture basis (bugs 2 and 23, errata sheet v3.0).
;                                DisplayMode0 no longer corrupted when doing a freeze update. No longer outputs captions while the screen is blanked.
; 28-Apr-99  BJGA 2.81-4.3.2.5  Added facility to register routines to handle line 21 data. This replaces the old code which calls the Macrovision module
;                                directly; the additional module MPEGCaptions will in future be required in order to pass the data on to the Macrovision module.
; 29-Apr-99  BJGA 2.81-4.3.2.6  Now EraseCaptions goes through the caption handler system too.
; 09-Apr-99  AR   2.82          Loaded MPEG2$VideoBufferPreFill and compared to VBVSize and sequence header VBVSize the minimum of these 3 is stored as VBVSize.
; 10-May-99  BJGA 2.83          Folded in the 2.81 development branch. NB: the v2.82 change is better expressed as:
;                                (a) the system variable can override the default prefill VBVSize; (b) the sequence header VBVSize is capped at the prefill VBVSize
; 12-May-99  BJGA 2.84          Fixed a bit of null pointer dereferencing that crept in when no caption handlers were registered.
; 28-May-99  BJGA 2.85          Moved the part of the code that extracts data about a new access unit and schedules it for use in calculating the future 3:2 pulldown
;                                state away from the picture start code interrupt code, and into the auxiliary FIFO parsing code. Fixes field inversion artifacts.
; 21-Jun-99  BJGA 2.86          Added MPEG2$HorizontalShift variable.
; 23-Jun-99  BJGA 2.87          Implemented StartVideoAtSeqHdr code.
;

	LEADR	Module_LoadAddr

TAB	*	9
LF	*	10
FF	*	12
CR	*	13

VIDC	*	&03500000

MPEG_sequence_header_code	*	&B3
MPEG_group_start_code		*	&B8

L64002_Registers_Ptr	RN	11	; use R11 to point to L64002 registers
DRAMControlSoftCopy	*	&D0	; used for DRAMRead macro

	GBLL	NYI
NYI	SETL	{FALSE}			; flags to use for bits that are not yet implemented

	GBLL	DoPEH
DoPEH	SETL	{TRUE}			; register program element handler

	GBLL	ClearFrameBuffers
ClearFrameBuffers SETL {TRUE}		; clear frame buffers to black on init

	GBLL	CountFieldInversions
CountFieldInversions SETL {TRUE}	; count number of fields where Bottom/Top != Even/Odd

	GBLL	PerformFieldInversion
PerformFieldInversion SETL {FALSE}	; allow field inversion (DEBUG ONLY)

	GBLL	ProgrammableBlanking
ProgrammableBlanking SETL {TRUE}	; wait for programmable number of sequence headers + fields before unblanking

	GBLL	CountUnderruns
CountUnderruns SETL {TRUE}		; count video channel underruns

	GBLL	Save1stFullPacket
Save1stFullPacket SETL {FALSE}		; save 1st packet after open/reset, including PTS

	GBLL	Save1stFIQPacket
Save1stFIQPacket SETL {FALSE}		; save 1st packet sent to video FIFO from FIQ routine

	GBLL	PreserveIRQStateInTickerVStuffing
PreserveIRQStateInTickerVStuffing SETL {FALSE}	; if true, don't enable IRQs if stuffing directly from TickerV

	ASSERT	:LNOT: (Save1stFullPacket :LAND: Save1stFIQPacket)	; can't have both

	GBLL	SaveAPacket
SaveAPacket SETL Save1stFullPacket :LOR: Save1stFIQPacket

	GBLL	HoldResetFor10ms
HoldResetFor10ms	SETL	{FALSE}	; try holding reset low for 10ms to protect against electric surge

	GBLL	RegDebug
RegDebug SETL	{TRUE}			; allow L64002 register access thru *-commands

	GBLL	NobbleL64002VideoPacketLengths ; set video packet lengths to zero as written to L64002
NobbleL64002VideoPacketLengths SETL {FALSE}

	GBLL	FudgeZeroLengthPackets	; whether to always fudge zero length packets
FudgeZeroLengthPackets SETL {FALSE}	; only do it during trick play

	GBLL	TrickPlaySupport
TrickPlaySupport SETL {TRUE}		; enable checking for conditional support for trick play

	GBLL	UnderrunFixOnlyOnOddFields
UnderrunFixOnlyOnOddFields SETL {TRUE}	; try this cos we only want to do freeze field on odd fields too

	GBLL	FreezeFieldOnTrickStop
FreezeFieldOnTrickStop	SETL	{TRUE}	; freeze field at the same time as stopping the decoder for underrun fix

	GBLL	FudgeQSIF
FudgeQSIF SETL	{TRUE}			; if image is SIF or lower resolution, scale to 2 x xres horizontally

	GBLL	AudioSquawkFix1		; attempt to fix audio squawk problem by padding video packet headers to a
AudioSquawkFix1 SETL {TRUE}		; multiple of 8 bytes.

	GBLL	AudioDebug
AudioDebug SETL {FALSE}			; capture audio data to a memory block

	GBLL	DiscardPartialPackets
DiscardPartialPackets	SETL {TRUE}	; discard initial partial PES packet for both video/audio

	GBLL	CheckAspectRatio
CheckAspectRatio SETL {TRUE}		; adjust picture size to cope with 16:9 and 2.21:1 aspect ratios

	GBLL	InitL64002OnModuleInit
InitL64002OnModuleInit SETL {FALSE}	; call InitL64002 to set screen to black on module initialisation

	GBLL	AudioStats
AudioStats SETL {TRUE}			; gather statistics on arrival of audio data

	GBLL	BigAudioThresholds
BigAudioThresholds SETL {TRUE}		; start with more audio data buffered, and use a larger threshold range

	GBLL	SlowMotionSupport
SlowMotionSupport SETL {TRUE}		; support MPEGVideo/Audio_SetSpeed, from 2 to 8

        GBLL    SCARTCTRLRegistersAreInIOMD
SCARTCTRLRegistersAreInIOMD SETL {FALSE}
 [ :DEF: IOMD_C_MPEG_CTRL_0 :LAND: :DEF: IOMD_C_MPEG_CTRL_1
   [ (IOMD_C_MPEG_CTRL_0 :OR: IOMD_C_MPEG_CTRL_1)<>0
SCARTCTRLRegistersAreInIOMD SETL {TRUE} ; map UpdateControlRegister_CTRL0/1 bits to IOMD_C_MPEG_CTRL_0/1 bits using PortMan
   ]
 ]

        GBLL    Captions
Captions SETL   {TRUE}                  ; extract closed captions and exended data service from the picture header user data

        GBLL    Pulldown
Pulldown SETL   {TRUE}                  ; work around L64002's bugs in 3:2 pull-down support

        GBLL    StartVideoAtSeqHdr
StartVideoAtSeqHdr SETL {TRUE}          ; this helps initial synchronisation

        GBLL    HShiftVariable
HShiftVariable  SETL    {TRUE}          ; allow horizontal shifting of MPEG video under system variable control

DefaultHShift   *       -11

        GBLL    dadebug_module          ; these are only strictly necessary if the module is
        GBLL    debug_irqsafe           ; being built against an old version of Hdr:NdrDebug

debug           SETL    false           ; false turns off all NdrDebug debugging
dadebug_module  SETL    true            ; the only debug output method that'll work in IRQ mode
debug_irqsafe   SETL    true            ; only conditional so that other users of NdrDebug are insulated from the change
                GBLL    debugpulldown
debugpulldown   SETL    false           ; 3:2 pulldown debug
                GBLL    debugskip
debugskip       SETL    false           ; StartVideoAtSeqHdr debug


; Structure of a PTS list entry

			^	0
PTSList_PTS		#	4	; bits 31..0 of PTS
PTSList_AddressPointer	#	4	; bit 0 = bit 32 of PTS, bits 10..31 = address pointer (in units of 8 bytes)
PTSListSize		*	@

VideoPTSListEntries	*	256	; for now
AudioPTSListEntries	*	256	; for now

MaxPTSError		*	3600	; at 25 frames/second, this is 1 frame

; Picture coding types

PictureCodingType_I	*	1
PictureCodingType_P	*	2
PictureCodingType_B	*	3

; Picture rate indices

PictureRate_23976	*	1
PictureRate_24000	*	2
PictureRate_25000	*	3
PictureRate_29970	*	4
PictureRate_30000	*	5
PictureRate_50000	*	6
PictureRate_59994	*	7
PictureRate_60000	*	8

; Structure of a streaminfo structure (one for audio and one for video)

			^	0
SI_ChannelBufferStart	#	4	; L64002 byte address of start of channel buffer
SI_ChannelBufferEnd	#	4	; L64002 byte address of end+1 of channel buffer
SI_PTSListPtr		#	4	; Address of corresponding PTS List
SI_PTSListReadPtr	#	4	; read pointer for list, in range 0..PTSListEntries-1
SI_PTSListWritePtr	#	4	; write pointer for same
SI_PTSListSize		#	4	; size of this PTS List
SI_PTSListOverruns	#	4	; number of overruns of PTS list
SI_SISPtr		#	4	; pointer to appropriate SIS structure
SISize			*	@

; Structure of a streaminfo system structure

			^	0
SIS_SystemBufferStart	#	4	; L64002 byte address of start of system buffer
SIS_SystemBufferEnd	#	4	; L64002 byte address of end+1 of system buffer
SIS_SystemBufferReadPtr	#	4	; L64002 byte address of where we've read to in system buffer
SIS_SystemBufferWritePtr #	4	; Last known value of SystemBufferWritePtr (in bytes)
SIS_DuffChannelAddresses #	4	; count of how many duff channel addresses found in system buffer
SIS_DuffSystemContents	#	4	; count of how many times we got rubbish in the system buffer
SIS_AddressOfLastDuff	#	4	; DRAM address where last rubbish in system buffer appeared
SIS_SystemUnderruns	#	4	; number of underruns of system buffer
SIS_SystemWrite0Group	#	4	; L64002 register group for system write ptr 0
SIS_SystemWrite0Reg	#	4	; L64002 register within group for system write ptr 0
SISSize			*	@

 [ StartVideoAtSeqHdr

 ; Structure of a queued FullPackets call

                        ^       0
FPQ_Next                #       4       ; link
FPQ_VideoAudio          #       4       ; 0 => video, 1 => audio
FPQ_Flags               #       4       ; as passed in r0 to FullPackets
FPQ_StreamHandle        #       4       ; as passed in r1 to FullPackets
FPQ_PacketList          #       4       ; as passed in r2 to FullPackets
FPQSize                 *       @

 ]

; Workspace declarations

			^	0, wp

; Variables valid outside of open stream

Podule_Base		#	4	; address of base of podule
Podule_ControlStatus1	#	4	; address of podule control/status 1 register
Podule_ControlStatus2	#	4	; address of podule control/status 2 register
L64002_Registers	#	4	; base address of L64002 registers
L64002_Audio_Data_Write #	4	; audio data write address
L64002_Video_Data_Write #	4	; direct writing of video data (not using FIFO)
FIFO_8_Bit_Write	#	4	; 8 bit FIFO writes
FIFO_16_Bit_Write	#	4	; 16 bit FIFO writes
FIFO_32_Bit_Write	#	4	; 32 bit FIFO writes

PoduleControlSoftCopy	#	4	; soft copy of combined control registers 1 (bits 0..7) and 2 (bits 8..15)
PoduleHeaderBuffer	#	16	; used to read podule headers
SyncOffset		#	4	; amount to add to clock values
CommonInterruptVectorsClaimed #	4	; NZ => interrupt vectors common to audio + video claimed
VideoInterruptVectorsClaimed #	4	; NZ => video interrupt vectors claimed
AudioInterruptVectorsClaimed #	4	; NZ => audio interrupt vectors claimed
VideoCallBackRequested	#	4	; whether a callback is outstanding
AudioCallBackRequested	#	4	; whether a callback is outstanding

VideoControlStreamHandle #	4	; control stream handle passed in to MPEGVideo_OpenStream
AudioControlStreamHandle #	4	; control stream handle passed in to MPEGAudio_OpenStream


; Variables only valid while stream open: general

IRQCounts		#	16*4	; counts of each type of IRQ we've had
Status0SoftCopy		#	4	; soft copy of status 0 register
SCROffset		#	8	; offset to add to H/W SCR to get current S/W SCR

; Variables only valid while stream open: video

VideoPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
VideoPacketListTailPtr	#	4	; pointer to tail of list
VideoChannelBufferSize	#	4	; size of video channel buffer, in bytes
VideoVBVSize		#	4	; size of video needed before unpausing
VideoInfoStructure	#	SISize
VideoSystemInfoStructure #	SISSize

BorderLeft		#	4	; left hand border
BorderTop		#	4	; top border

UnknownLengthPacket	#	4	; points to 1st packet in chain forming an indeterminate length packet, or zero if none
					; (only allowed in video stream, fortunately)

VideoAmountReceived	#	4	; amount of video data received
VideoPreFilling		#	4	; NZ => pre-filling
VideoStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
VideoStreamFlags	#	4	; stream flags
VideoSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
VideoLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
VideoNumberOfPTSs	#	4	; number of PTSs sent
VideoAmountQueued	#	4	; amount passed to background FIQ process
VideoPTSInCount		#	4	; number of video PTSs received from MPEGControl
DecodedFieldCount	#	4	; -1 when inactive or decoder not yet started, else number of fields after decoder start
					; until we've unblanked, then -2
FIQSlotWritePtr		#	4	; address within FIQSlotSpace to write next (address,length) pair to
VideoPostedPTS		#	8	; PTS posted for comparison on start of next odd field
VideoNumberOfPostedPTSs	#	4	; number of video PTSs posted for comparison
VideoSkips		#	4	; number of skipped frames
VideoRepeats		#	4	; number of repeated frames
VideoPTSPictureTypeCounts #	0	; counts of number of PTSs on I, P and B type pictures
			#	4	; dummy entry for type 0
VideoPTSPictureTypeCount_I #	4	; number of PTSs on I-pictures
VideoPTSPictureTypeCount_P #	4	; number of PTSs on P-pictures
VideoPTSPictureTypeCount_B #	4	; number of PTSs on B-pictures
VideoMinPTSDifference	#	4	; worst negative difference between PTS and SCR
VideoMaxPTSDifference	#	4	; worst positive difference between PTS and SCR
LastVideoPTSErrorSign	#	4	; SGN(last PTS-SCR) ie 0,-1 or 1; we only skip or repeat if 2 contiguous errors of same sign
PendingFreezeState	#	4	; 1 => should be frozen, 0 => should be unfrozen
FreezeUpdate		#	4	; 1 => freeze state has been updated
 [ FreezeFieldOnTrickStop
TrickStopFreeze		#	4	; additional freeze flag for trick play, OR'd with PendingFreezeState
 ]
FirstItemReceived	#	4	; 0 => not received anything since last reset, 1 => sequence, 2 => picture
 [ CountUnderruns
VideoChannelUnderruns	#	4	; number of video channel underruns
UnderrunIRQState	#	4	; 0 => still waiting to start
					; 1 => on next active field enable the underrun IRQ
					; 2 => already enabled it once
 ]
 [ SlowMotionSupport
VideoSpeedCount		#	4	; counter incremented during slow motion to control speed
 ]

; Variables only valid while stream open: audio

AudioPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
AudioPacketListTailPtr	#	4	; pointer to tail of list
AudioChannelBufferSize	#	4	; size of audio channel buffer, in bytes
AudioInfoStructure	#	SISize
AudioSystemInfoStructure #	SISSize

AudioChannelBufferReadPtr #	4	; Last known value of AudioChannelBufferReadPtr (in bytes)

AudioPreFilling		#	4	; NZ => pre-filling
AudioStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
AudioStreamFlags	#	4	; stream flags
AudioFlags		#	4	; flags from audio parameters structure
AudioSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
AudioLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
AudioNumberOfPTSs	#	4	; number of PTSs sent
AudioAmountSent		#	4	; amount of data sent
AudioPTSInCount		#	4	; number of audio PTSs received from MPEGControl

AudioSampleRate		#	4	; -1 for unknown, 0..7 => 22.05, 24, 16, reserved, 44.1, 48, 32, reserved
DualMonoChannelSpecifier #	4	; indicates what mode of dual mono to select
AudioChannelMode	#	4	; copy of what hardware says is the current stream type, or -1 if undefined
AudioResyncDelay	#	4	; counts down number of centisecond ticks till we check audio buffer fullness again
AudioFasts		#	4	; number of audio frames played "fast"
AudioSlows		#	4	; number of audio frames played "slow"
AudioMuted		#	4	; non-zero => audio muted
LastAudioBufferFullness	#	4	; last audio buffer fullness after stuffing
AudioBufferChecks	#	4	; number of checks on audio buffer fullness
AudioDiscardedDataCount #	4	; number of bytes of audio data flushed out of audio channel buffer on last
					;  MPEGVideo_ResetStream call, to be used to compute total audio discard on subsequent
					;  MPEGAudio_ResetStream call. Reset to -1 on OpenStream or after MPEGAudio_ResetStream
AudioPreFillSize	#	4	; amount of prefilling needed
AudioBufferLowWaterMark	#	4	; if we have less than this, play audio slowly
AudioBufferHighWaterMark #	4	; if we have more than this, play audio fast
AudioPacketSendTimeouts	#	4	; number of times the code to send an audio packet header timed out

 [ AudioStats
AudioStartTime		#	4	; time when first data was received
AudioLastTime		#	4	; time when last data was received
AudioAmountReceived	#	4	; amount of audio data received
AudioMaxTimeDifference	#	4	; maximum delay between one lot of audio data and next
AudioTimeOffsetToFirstSlow #	4	; time offset from first audio data arriving to first audio slow frame
 ]

 [ AllowSyncOnIFrames
SyncMode		#	4	; 0 when syncing on I-frames disabled
					; 1 when syncing on I-frames is enabled, but had no PTSs yet
					; 2 after first PTS has been used to write SCR
AnchorPostedPTSs	#	4*8	; 4 PTS slots for anchor frames, used for I-frame synching
AnchorPostedPTSWritePtr #	4	; write pointer for AnchorPostedPTSs, increments from 0 indefinitely, bottom 2 bits indicate
					; next slot
AnchorPostedPTSReadPtr	#	4	; where to read from (increments indefinitely)
AnchorFIFOOverruns	#	4	; number of times the AnchorPTS FIFO overran
 ]
 [ CountVideoPackets
 ASSERT :LNOT: AllowSyncOnIFrames	; the two modes of operation are incompatible!
SyncMode		#	4	; 0 when normal syncing, 1 when relying on counting packets
VideoPacketsReceived	#	4	; reset to 0 on ResetStream, incremented on each start of MPEG packet received
VideoPicturesReceived	#	4	; reset to 0 on ResetStream, incremented on each PictureDecode interrupt
VideoOKCount		#	4	; number of times we didn't have to repeat
VideoSyncPos		#	4	; where we are in stats array
 ]
 [ VetSCRValues
VetSCRState		#	4	; 0 => awaiting 1st SCR, 1 => last SCR was good, 2 => last SCR was bad
GoodSCROffset		#	4	; SCR-<monotonic time>*900, for the last good SCR value
BadSCROffset		#	4	; ditto, for the last bad SCR value
BadSCRCount		#	4	; count of the number of bad SCR values
SCRAcceptableRange	*	&6000	; about a 1/4 of a second, in 90kHz units
 ]
 [ CountFieldInversions
FieldInversions		#	4	; number of field inversions observed
 ]
 [ PerformFieldInversion
FieldInversionState	#	4	; 2 => freeze decoder next BAV IRQ
					; 1 => unfreeze decoder next BAV IRQ
					; 0 => finished freezing/unfreezing
 ]

; New stuff for L64002

IRSoftCopy		#	4	; soft copies of interrupt mask registers
DRAMBuffer		#	8	; temporary buffer for reading L64002 DRAM into
DRAMBufferAddress	#	4	; base address correponding to contents of DRAM buffer
CardProductType		#	4	; product type of MPEG 2 card (or -1 if unrecognised)

SequenceCount		#	4	; number of sequences to wait for before starting to count fields before unblanking
BlankedSequences	#	4	; initialiser for SequenceCount
BlankedFields		#	4	; number of fields to wait for each time we reset

LastErrorStatus		#	4	; last value of ErrorStatus byte
CumulativeErrorStatus	#	4	; logical OR of all ErrorStatus bytes
VidRecErrors		#	4	; number of video reconstruction errors
ContextErrors		#	4	; number of context errors
VLCErrors		#	4	; number of VLC errors
TimeOfLastVideoReset	#	4	; monotonic time after last reset
TimeOffsetOfVRError	#	4	; time between last video reset and 1st occurrence of video recon error (-1 if none)


; Areas copied out of Aux FIFO

VideoSequenceData                       #       0       ; 12 in total
VideoSequence_HorizontalSize            #       2
VideoSequence_VerticalSize              #       2
VideoSequence_PelAspectRatio            #       1
VideoSequence_PictureRate               #       1
VideoSequence_BitRate                   #       3
VideoSequence_VBVBufferSize             #       2
VideoSequence_Misc                      #       1           ; constrained_parameters_flag, load_intra_quantiser_matrix, load_non_intra_quantiser_matrix
VideoSequenceDataEnd                    #       0

SequenceExtensionData                   #       0       ; 8 in total
SequenceExtension_ExtensionID           #       1
SequenceExtension_ProfileAndLevel       #       1
SequenceExtension_ProgressiveSequence   #       1           ; progressive_sequence now has its own byte, separate from:
SequenceExtension_Misc1                 #       1           ; chroma_format, horizontal_size_extension and vertical_size_extension
SequenceExtension_BitRateExtension      #       2
SequenceExtension_VBVBufferSizeExtension #      1
SequenceExtension_Misc2                 #       1           ; low_delay, frame_rate_extension_n and frame_rate_extension_d
SequenceExtensionDataEnd                #       0

DisplayExtensionData                    #       0       ; 9 in total
DisplayExtension_ExtensionID            #       1
DisplayExtension_Misc                   #       1           ; video_format and colour_description
DisplayExtension_ColourPrimaries        #       1
DisplayExtension_TransferCharacteristics #      1
DisplayExtension_MatrixCoefficients     #       1
DisplayExtension_HorizontalDimension    #       2
DisplayExtension_VerticalDimension      #       2
DisplayExtensionDataEnd                 #       0

GroupOfPicturesData                     #       0       ; 6 in total
GroupOfPictures_TimeCode                #       4
GroupOfPictures_ClosedGOP               #       1
GroupOfPictures_BrokenLink              #       1
GroupOfPicturesDataEnd                  #       0

PictureData                             #       0       ; 5 in total
Picture_TemporalReference               #       2
Picture_PictureCodingType               #       1
Picture_VBVDelay                        #       2
PictureDataEnd                          #       0

PictureCodingExtensionData              #       0       ; 20 in total
PictureCodingExtension_ExtensionID      #       1
PictureCodingExtension_ForwardHorizontalFCode # 1
PictureCodingExtension_ForwardVerticalFCode #   1
PictureCodingExtension_BackwardHorizontalFCode # 1
PictureCodingExtension_BackwardVerticalFCode #  1
PictureCodingExtension_IntraDCPrecision #       1
PictureCodingExtension_PictureStructure #       1
PictureCodingExtension_TopFieldFirst    #       1
PictureCodingExtension_FramePredictionFrameDCT # 1
PictureCodingExtension_ConcealmentMotionVectors # 1
PictureCodingExtension_QScaleType       #       1
PictureCodingExtension_IntraVLCFormat   #       1
PictureCodingExtension_AlternateScan    #       1
PictureCodingExtension_RepeatFirstField #       1
PictureCodingExtension_ChromaPostProcessingType # 1
PictureCodingExtension_ProgressiveFrame #       1
PictureCodingExtension_CompositeDisplayFlag #   1
PictureCodingExtension_Misc             #       1           ; v_axis, field_sequence and sub_carrier
PictureCodingExtension_BurstAmplitude   #       1
PictureCodingExtension_SubCarrierPhase  #       1
PictureCodingExtensionDataEnd           #       0

QuantMatrixExtensionData                #       0       ; 1 in total
QuantMatrixExtension_ExtensionID        #       1
QuantMatrixExtensionDataEnd             #       0

CopyrightExtensionData                  #       0       ; 14 in total
CopyrightExtension_ExtensionID          #       1
CopyrightExtension_CopyrightFlag        #       1
CopyrightExtension_CopyrightIdentifier  #       1
CopyrightExtension_OriginalOrCopy       #       1
CopyrightExtension_Reserved             #       1
CopyrightExtension_CopyrightNumber1     #       3           ; 20 most sig bits    \
CopyrightExtension_CopyrightNumber2     #       3           ; 22 middle sig bits   >  the L64002 does *not* recombine these into the original 8-byte number
CopyrightExtension_CopyrightNumber3     #       3           ; 22 least sig bits   /
CopyrightExtensionDataEnd               #       0

PanAndScanExtensionData                 #       0       ; 19 in total
PanAndScanExtension_ExtensionID         #       1
PanAndScanExtension_Field1_HorizontalOffsetInteger # 2      ; data is present for as many fields as the picture is intended to be displayed for
PanAndScanExtension_Field1_HorizontalOffsetSubPel # 1
PanAndScanExtension_Field1_VerticalOffsetInteger # 2
PanAndScanExtension_Field1_VerticalOffsetSubPel # 1
PanAndScanExtension_Field2_HorizontalOffsetInteger # 2
PanAndScanExtension_Field2_HorizontalOffsetSubPel # 1
PanAndScanExtension_Field2_VerticalOffsetInteger # 2
PanAndScanExtension_Field2_VerticalOffsetSubPel # 1
PanAndScanExtension_Field3_HorizontalOffsetInteger # 2
PanAndScanExtension_Field3_HorizontalOffsetSubPel # 1
PanAndScanExtension_Field3_VerticalOffsetInteger # 2
PanAndScanExtension_Field3_VerticalOffsetSubPel # 1
PanAndScanExtensionDataEnd              #       0

	AlignSpace

 [ Captions
; State variables for user data FIFO parsing
UserData_State          #       4       ; -3  => waiting for dataLength
                                        ; -2  => waiting for dataType
                                        ; -1  => waiting for extDataType
                                        ; >=0 => waiting for nth dataByte
UserData_dataLength     #       1
UserData_dataType       #       1
UserData_extDataType    #       1
UserData_NBytes         #       1       ; number of data bytes (may differ from dataLength if we support C-Cube format)
        ASSERT (3 :AND: :INDEX: @) = 0  ; should be word aligned to simplify rescheduling anchor frame data
UserData_dataBytes      #       4
UserData_OldCCDataBytes #       4       ; caption dataBytes from previous anchor frame
UserData_OldEDSDataBytes #      4       ; extended data dataBytes from previous anchor frame

Handlers                #       4       ; head of a linked list of handlers
HandlersMagic           #       4       ; is the list still valid from before the module was reinitialised? (yucky, I know)
magicword_handlers      *     &54504143 ; 'CAPT'
 ]

 [ StartVideoAtSeqHdr
FullPacketsQueue        #       4       ; queue of FullPackets calls
FullPacketsFree         #       4       ; unused links (not freed until finalisation, to ease memory fragmentation)
LastVideoDTS0           #       4       ; bits 0-31 = bits 0-31 of the last DTS recorded in the video stream
LastVideoDTS1           #       4       ; bit 0 = bit 32 of the DTS; or -1 if no DTS has yet been found
SkippingToSeqHdr        #       1       ; 0 => not skipping, 1 => discarding video packets
StartCodeSearchState    #       1       ; 0 => nothing found, 1 => found &00, 2 => found &0000, 3 => found &000001
DeferVideoStart         #       1       ; 0 => start video at same time as audio, 1 => start video at LastVideoDTS[0,1]
FirstAudioPTS           #       1       ; 0 => we've had at least one audio PES header, 1 => the next one will be the first
        AlignSpace
 ]

 [ SkippingCode
StartSkipCode		#	4	; bottom byte of start code to skip to initially, or zero if no skip
 ]

VideoStructureFlags	#	4
VideoInputType		#	4	; specifies what format of input is passed to MPEG2Video
CurrentHorizontalSize	#	4	; specifies what horiz size was at last sequence header
CurrentVerticalSize	#	4	; ditto for vertical size
CurrentTVFormat		#	4	; ditto for TV format (0=PAL, 1=NTSC)
 [ CheckAspectRatio
CurrentAspectRatio	#	4	; ditto for aspect ratio
 ]
CurrentOutputWidth	#	4	; either 704 or 720 as appropriate

 [ SaveAPacket
SavedPacketLength	#	4	; 0 => no packet saved yet, else length of 1st packet
FirstPacket		#	184	; 1st (up to) 184 bytes of 1st packet
  [ Save1stFullPacket
SavedPacketPTS		#	8	; PTS on 1st packet
  ]
 ]

 [ TrickPlaySupport
TrickStops		#	4	; number of times code stopped the decoder
TrickStarts		#	4	; number of times code started the decoder
TrickPlayMode		#	4	; NZ => we're doing Oracle-style trick play
 ]
 [ DiscardPartialPackets
VideoHadFirstPacket	#	4	; 0 until had first PES packet header
AudioHadFirstPacket	#	4	; ditto
 ]

 [ AudioDebug
AudioCaptureBlockLength	#	4	; length of captured data
 ]

 [ Pulldown
AuxData_LastKnownLayer  #       4       ; used to determine when to reset coroutine - useful for error recovery
AuxData_CoPC            #       4       ; return address in coroutine (preserved across calls to ProcessAuxFIFO)
AuxData_CoSP            #       4       ; stack pointer for coroutine (preserved across calls to ProcessAuxFIFO)
AuxData_ExtSP           #       4       ; to save sp_irq in during the coroutine
AuxData_Stack           #       4*30    ; fixed-size stack for coroutine - 12ish words needed for ProcessVideoSequenceData, 25 words for Debug macro
AuxData_StackTop        #       0

PU_Countdown            #       4       ; field count until next PU boundary
PU_EstCountdown         #       4       ; estimated field count, assuming the previous PU boundary was correctly determined
LastAnchorAUInvalid     #       1       ; 1 => FirstField_LastAnchorAU is invalid, 0 => it is valid
FirstField_LastAnchorAU #       1       ; \                                   /  held-over anchor frame access unit
FirstField_FuturePU     #       1       ;  \  values of top_field_first for  /   next-but-one presentation unit
FirstField_NextPU       #       1       ;  /                                 \   next presentation unit
FirstField_CurrentPU    #       1       ; /                                   \  currently-displayed presentation unit
EvenOddIndicator        #       1       ; 0 => currently in an odd field, 1 => currently in an even field

        AlignSpace
 ]

 [ HShiftVariable
HShift                  #       4       ; shift displayed frame right by this (signed) amount; measured in 1/720th of displayed frame width
 ]

        AlignSpace 16

; Large blocks

VideoPTSList		#	PTSListSize * VideoPTSListEntries
AudioPTSList		#	PTSListSize * AudioPTSListEntries

 [ CountVideoPackets
VideoSyncStats		#	&400*8	; pairs of packets, pictures at the time of BeginActiveVideo(odd field)
 ]

 [ FullLengthStats
LengthStatsArraySize	*	8192	; room for this number of entries (each 1 word full length)
LengthStatsPosition	#	4	; position in array
LengthStatsArray	#	LengthStatsArraySize *4
 ]

 [ AudioDebug
AudioCaptureBlockMaxLen	*	512*1024
AudioCaptureBlock	#	AudioCaptureBlockMaxLen
 ]

 [ international
MessageFile_Block #	16
MessageFile_Open  #	4
 ]

Module_WorkspaceSize * :INDEX: @

VideoPreFillSize	*	200*1024	; amount to send before starting - goes up to 224K for MPEG 2
 [ BigAudioThresholds
DefaultAudioBufferLowWaterMark	*	8*1024
DefaultAudioBufferHighWaterMark *	24*1024
DefaultAudioPreFillSize		*	16*1024
 |
DefaultAudioBufferLowWaterMark	*	3*1024
DefaultAudioBufferHighWaterMark *	5*1024
DefaultAudioPreFillSize		*	4*1024
 ]

; The following are 1st guesses

AudioResyncRepeat *		10		; 10cs between successive attempts at going fast or slow

	GBLL	xdebug
xdebug	SETL	{FALSE}

	MACRO
	DLine	$string, $cc, $inverse
 [ xdebug
	DLINE	$string, $cc, $inverse
 ]
	MEND

	MACRO
	DReg	$reg, $string, $cc, $routine
 [ xdebug
	DREG	$reg, $string, $cc, $routine
 ]
	MEND

; **************** Module code starts here **********************

Module_BaseAddr

	&	0				; no app start entry
	&	Mod_Init    -Module_BaseAddr
	&	Mod_Die	    -Module_BaseAddr
	&	Mod_Service -Module_BaseAddr
	&	Mod_Title   -Module_BaseAddr
	&	Mod_HelpStr -Module_BaseAddr
	&	Mod_HC_Table-Module_BaseAddr
	&	MPEGVideoSWI_Base ; SWI chunk
	&	Mod_SWIHandler-Module_BaseAddr
	&	Mod_SWITable-Module_BaseAddr
	&	0				; no swi name decode entry

Mod_Title
	=	"MPEG2Video", 0

Mod_HelpStr
	=	"MPEG2Video", TAB, "$Module_MajorVersion ($Module_Date)"
        [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
	=       0
	ALIGN

Mod_SWITable
	=	"MPEGVideo", 0
	=	"OpenStream", 0
	=	"FullPackets", 0
	=	"CloseStream", 0
	=	"Play", 0
	=	"SetSpeed", 0
	=	"CardControl", 0
	=	"SetSCR", 0
	=	"ReadParameters", 0
	=	"ResetStream", 0
	=	"DisplayStill", 0
	=	"Stats", 0
	 =	 0
	ALIGN

Mod_HC_Table
	Command SyncOffset, 1, 1
	Command VideoInfo, 0, 0
 [ RegDebug
	Command ReadL64002, 2, 1
	Command WriteL64002, 3, 2
	Command	PacketInfo, 0, 0
 ]
 [ AudioDebug
	Command SaveAudio, 1, 1
 ]
	=	0

SyncOffset_Help
	=	"*SyncOffset sets the offset to be added to the clock value"
	=	" before programming into the L64002.", CR
SyncOffset_Syntax
	=	"Syntax: *SyncOffset <value>", 0
VideoInfo_Help
	=	"*VideoInfo outputs debugging info.", CR
VideoInfo_Syntax
	=	"Syntax: *VideoInfo", 0
	ALIGN

; **************************************************************************
;
;	Mod_Init - Initialisation entry
;

xdebug  SETL    {FALSE}

Mod_Init Entry
	LDR	r2, [R12]		; have we got workspace yet ?
	TEQ	r2, #0
	BNE	%FT05

	MOV	r0, #ModHandReason_Claim
	LDR	r3, =Module_WorkspaceSize
	SWI	XOS_Module
	EXIT	VS

; r2 -> workspace

	STR	r2, [r12]		; save address in my workspace pointer,
					; so Tutu can free it for me when I die
05
	MOV	r12, r2

        Debug_Open "VideoDebug"

	DLine	"Calling FindPoduleNumber"

	BL	FindPoduleNumber
	EXIT	VS

	DLine	"Calling Podule_ReadInfo"

	MOV	r0, #Podule_ReadInfo_EASILogical
	ADR	r1, Podule_Base
	MOV	r2, #4
	SWI	XPodule_ReadInfo
	EXIT	VS

	LDR	r0, Podule_Base
	ADD	r1, r0, #Offset_Podule_ControlStatus1
	STR	r1, Podule_ControlStatus1
	ADD	r1, r0, #Offset_Podule_ControlStatus2
	STR	r1, Podule_ControlStatus2
	ADD	r1, r0, #Offset_L64002_Registers
	STR	r1, L64002_Registers
	ADD	r1, r0, #Offset_L64002_Audio_Data_Write
	STR	r1, L64002_Audio_Data_Write
	ADD	r1, r0, #Offset_L64002_Video_Data_Write
	STR	r1, L64002_Video_Data_Write
	ADD	r1, r0, #Offset_FIFO_8_Bit_Write
	STR	r1, FIFO_8_Bit_Write
	ADD	r1, r0, #Offset_FIFO_16_Bit_Write
	STR	r1, FIFO_16_Bit_Write
	ADD	r1, r0, #Offset_FIFO_32_Bit_Write
	STR	r1, FIFO_32_Bit_Write

	MOV	r0, #0
	STR	r0, CommonInterruptVectorsClaimed
	STR	r0, VideoInterruptVectorsClaimed
	STR	r0, AudioInterruptVectorsClaimed
	STR	r0, SyncOffset
	STR	r0, VideoAmountReceived
	STR	r0, VideoCallBackRequested
	STR	r0, AudioCallBackRequested
	STR	r0, VideoControlStreamHandle
	STR	r0, AudioControlStreamHandle
	STR	r0, AudioResyncDelay
	STR	r0, AudioFasts
	STR	r0, AudioSlows
	STR	r0, AudioBufferChecks
      [ StartVideoAtSeqHdr
        Debug   skip, "Initialising queues"
        STR     r0, FullPacketsQueue
        STR     r0, FullPacketsFree
      ]
      [ Captions
        LDR     r1, =magicword_handlers :AND: &FFFFFF00 ; do in two stages
        ORR     r1, r1, #magicword_handlers :AND: &FF   ; to reduce chances of misinterpretation
        LDR     r2, HandlersMagic
        TEQ     r1, r2
        STRNE   r0, Handlers
        STRNE   r1, HandlersMagic
      ]

	ADR	r0, VideoPTSList
	STR	r0, VideoInfoStructure+SI_PTSListPtr
	MOV	r0, #VideoPTSListEntries
	STR	r0, VideoInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_VideoSystemWrite0_Addr1
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_VideoSystemWrite0_Addr2
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Reg

	ADRL	r0, AudioPTSList
	STR	r0, AudioInfoStructure+SI_PTSListPtr
	MOV	r0, #AudioPTSListEntries
	STR	r0, AudioInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_AudioSystemWrite0_Addr1
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_AudioSystemWrite0_Addr2
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Reg
	ADR	r0, AudioSystemInfoStructure
	STR	r0, AudioInfoStructure+SI_SISPtr		; system buffer for audio is always the audio system buffer

	BL	InitSAA7167		; only needs doing once, so do it here

; Now read existence of variable 'TVOn' to see whether to set CTRL0 and CTRL1 on or off

	Push	"r0,r1"
	ADR	r0, TVOnString
	MOV	r1, #0
	MOV	r2, #-1
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	Pull	"r0,r1"

	DLine	"Initialising Control registers"

	TEQ	r2, #0					; *** Flags set
 [ MPEG2PoduleControl_CLKSelect <> 0			; If r2=0 don't bother setting it to zero.
	MOVEQ	r2, #MPEG2PoduleControl_CLKSelect	; var doesn't exist, so TV off
 ]
	MOVNE	r2, #MPEG2PoduleControl_ModulatorBoost :OR: MPEG2PoduleControl_CTRL1 :OR: MPEG2PoduleControl_CTRL0 :OR: MPEG2PoduleControl_CLKSelect ; var exists, TV on
	; Preserve the flags during this bit.
	STR	r2, PoduleControlSoftCopy
	LDR	r1, Podule_ControlStatus1
	STRB	r2, [r1]
	LDR	r1, Podule_ControlStatus2
	MOV	r2, r2, LSR #8
	STRB	r2, [r1]

	; Some systems have the scart control bits in IOMD
 [ SCARTCTRLRegistersAreInIOMD
	; The flags should still be set from that TEQ up there.
	MOVEQ	r0, #1					; var doesn't exist, so TV off
	MOVNE	r0, #3					; var exists, TV on
	ADR	r1, SCART_TV_String
	MOV	r2, r0
	SWI	XPortMan_AccessBit
	MOV	r0, r2
	ADR	r1, SCART_CVBS_String
	SWI	XPortMan_AccessBit
 ]

	DLine	"Returned from initialising Control registers"

 [ InitL64002OnModuleInit
	MOV	r0, #0
	STR	r0, VideoInputType	; unknown video input type
	STR	r0, VideoStreamFlags
	BL	InitL64002
 ]

; now claim unknown SWI vector, to trap the MPEGAudio SWIs

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Claim

 [ DoPEH
	BL	RegisterPEHHandlers
 ]

	CLRV
	EXIT

TVOnString
	=	"TVOn", 0
 [ SCARTCTRLRegistersAreInIOMD
SCART_TV_String
	=	"SCART_TV", 0
SCART_CVBS_String
	=	"SCART_CVBS", 0
 ]
	ALIGN

        InsertNDRDebugRoutines

	LTORG

; **************************************************************************
;
;	Mod_Die - Die entry
;

Mod_Die Entry
	LDR	wp, [r12]

	BL	CheckStreamOpen
	BNE	%FT90					; [there's a stream open so refuse to die]

 [ DoPEH
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
 ]
 [ StartVideoAtSeqHdr
        Debug   skip, "Freeing queues"
        LDR     r3, FullPacketsQueue
        BL      FreeFullPacketsLinkedList
        LDR     r3, FullPacketsFree
        BL      FreeFullPacketsLinkedList
 ]

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Release

        Debug_Close

	CLRV
	EXIT

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"MPEG2Video cannot die as there is a stream open to it", 0
	ALIGN

; **************************************************************************
;
;	Mod_Service - Main entry point for services
;
; in:	R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
	TEQ	r1, #Service_PreReset
 [ DoPEH
	TEQNE	r1, #Service_MPEGControlStarting
 ]
	MOVNE	pc, lr			; if not pre-reset or MPEGControl_Starting, do nothing

	LDR	wp, [r12]
 [ DoPEH
	TEQ	r1, #Service_MPEGControlStarting
	BEQ	RegisterPEHHandlers
 ]
	Push	"lr"
	BL	VideoReleaseInterruptVectors
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors
	Pull	"pc"

 [ DoPEH
; it's Service_MPEGControlStarting

RegisterPEHHandlers Entry "r0-r3"
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
	EXIT
 ]

; **************************************************************************
;
;	Mod_SWIHandler - Main entry point for SWIs
;
; in:	r11 = SWI number
;

Mod_SWIHandler ROUT
	LDR	r12, [wp]
	CMP	r11, #(%FT20-%FT10) :SHR: 2
	ADDCC	pc, pc, r11, LSL #2
	B	NoSuchSWI
10
	B	VideoOpenStream		; open stream
	B	VideoFullPackets	; new data
	B	VideoCloseStream	; close stream
	B	VideoPlay		; start playing
	B	VideoSetSpeed		; may encompass pause/slow/fast/rewind
	B	CardControl		; general control of MPEG card (used by audio module)
	B	VideoSetSCR		; set SCR value in L64002
	B	ReadParameters		; read various parameters
	B	VideoResetStream	; discard data and reset
	B	DisplayStill		; display 2-field MPEG still picture
	B	VideoStats		; return statistics
      [ Captions
        B       RegisterHandler         ; register handler routine
        B       DeregisterHandler       ; deregister handler routine
      ]
20
NoSuchSWI
	ADRL	r0, NoSuchSWIError
	SETV
	MOV	pc, lr

; **************************************************************************
;
;	UnknownSWI - Entry point for UKSWIV, to trap MPEGAudio SWIs
;
; in:	r11 = SWI number
;	r0-r8 as per SWI entry

UnknownSWI Entry
	LDR	lr, =MPEGAudioSWI_Base
	SUB	lr, r11, lr
	CMP	lr, #MPEGAudio_SetAudioParameters + 1 - MPEGAudioSWI_Base
	EXIT	HI			; [not an MPEGAudio SWI that we know about]

	Push	"r11"			; save r11
	MOV	r11, lr			; r11 = SWI offset
	MOV	lr, pc
	ADD	pc, pc, r11, LSL #2
	Pull	"r11, lr, pc"		; restore r11 and exit claiming vector
	B	AudioOpenStream
	B	AudioFullPackets
	B	AudioCloseStream
	B	AudioPlay
	B	AudioSetSpeed
	B	AudioSkipFrame
	B	AudioRepeatFrame
	B	AudioResetStream
	B	AudioMuteSound
	Pull	"r11, pc"		; we don't do AudioSoundVolume, so restore r11 and pass on
	Pull	"r11, pc"		; ditto for AudioStats
	B	AudioSetAudioParameters

	LTORG

xdebug  SETL    {FALSE}

 [ DoPEH
; **************************************************************************
;
;	VideoStreamHandler - Handler for video stream
;
; in:	r0 = reason code
;	r12 = wp
;	Others as appropriate

VideoStreamHandler ROUT
	CMP	r0, #(VideoHandlerDespatchTableEnd - VideoHandlerDespatchTable) :SHR: 2
	ADDCC	pc, pc, r0, LSL #2
	B	UnknownHandlerReasonCode
VideoHandlerDespatchTable
	B	VSH_OpenStream
	B	VSH_DataTransfer
	B	VSH_CloseStream
VideoHandlerDespatchTableEnd

UnknownHandlerReasonCode
	ADRL	r0, UnknownHandlerReasonError
	SETV
	MOV	pc, lr

UnknownHandlerReasonError
	&	0
	=	"Unknown video handler reason code", 0
	ALIGN

; VSH_OpenStream
; Don't bother to do much here yet, as MPEGVideo_OpenStream is still issued
; Just return a non-zero handle

; VSH_CloseStream - do nowt

VSH_OpenStream
	MOV	r0, #1
VSH_CloseStream
	CLRV
	MOV	pc, lr

; VSH_DataTransfer
; Just move the packet descriptor pointer (in r3) into r2 (we can corrupt r0-r3)

VSH_DataTransfer
	MOV	r2, r3
	B	VideoFullPackets

 ] ; DoPEH
; **************************************************************************
;
;	VideoOpenStream - Open MPEG video stream
;
; in:	r0 = flags
;	r1 = control stream handle
;	r2 -> video parameters structure
;
; out:  r0 = video stream handle
;

VideoOpenStream Entry "r1,r2, r11"
	LDR	r11, L64002_Registers
	STR	r0, VideoStreamFlags
	STR	r1, VideoControlStreamHandle

	LDR	lr, [r2, #VideoStructure_Flags]
	STR	lr, VideoStructureFlags

	TST	lr, #VideoStructureFlags_InputTypeExtension
	LDRNE	lr, [r2, #VideoStructure_InputType]	; if input type specified, use it
	MOVEQ	lr, #0					; else indicate unknown
	STR	lr, VideoInputType

 [ ProgrammableBlanking
	LDR	lr, VideoStructureFlags
	TST	lr, #VideoStructureFlags_BlankingExtension
	LDRNE	lr, [r2, #VideoStructure_BlankedSequences]
	MOVEQ	lr, #1
	STR	lr, BlankedSequences
	LDRNE	lr, [r2, #VideoStructure_BlankedFields]
	MOVEQ	lr, #16
	STR	lr, BlankedFields
 |
	MOV	lr, #1
	STR	lr, BlankedSequences
	MOV	lr, #16
	STR	lr, BlankedFields
 ]
	MOV	r1, #0
	STR	r1, VideoStreamClosing
	STR	r1, VideoAmountReceived
	STR	r1, VideoNumberOfPTSs
	STR	r1, VideoPacketListHeadPtr
	STR	r1, VideoPacketListTailPtr
	STR	r1, VideoPTSInCount
	STR	r1, VideoInfoStructure+SI_PTSListOverruns
	STR	r1, VideoSkips
	STR	r1, VideoRepeats
	STR	r1, VideoNumberOfPostedPTSs
	STR	r1, VideoPTSPictureTypeCounts +0
	STR	r1, VideoPTSPictureTypeCounts +4
	STR	r1, VideoPTSPictureTypeCounts +8
	STR	r1, VideoPTSPictureTypeCounts +12
	STR	r1, VideoMinPTSDifference
	STR	r1, VideoMaxPTSDifference
	STR	r1, PendingFreezeState
	STR	r1, FreezeUpdate
 [ AllowSyncOnIFrames
	STR	r1, SyncMode					; don't enable sync on I frames until an appropriate ResetStream
	STR	r1, AnchorFIFOOverruns
 ]
 [ TrickPlaySupport
	STR	r1, TrickStops
	STR	r1, TrickStarts
	STR	r1, TrickPlayMode				; indicate not doing trick play
 ]
 [ CountVideoPackets
	STR	r1, SyncMode					; normal syncing until a reset stream
 ]
 [ CountFieldInversions
	STR	r1, FieldInversions
 ]
 [ PerformFieldInversion
	STR	r1, FieldInversionState
 ]
 [ FullLengthStats
	STR	r1, LengthStatsPosition
 ]
 [ CountUnderruns
	STR	r1, VideoChannelUnderruns
	STR	r1, UnderrunIRQState
 ]
 [ StartVideoAtSeqHdr
        AND     lr, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        TEQ     lr, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        MOVEQ   lr, #1                                          ; only skip to sequence header if there are both video and audio in the new stream
        MOVNE   lr, #0
        STRB    lr, SkippingToSeqHdr
 ]
	BL	VideoReset

	LDR	r1, [r2, #VideoStructure_BorderLeft]
	STR	r1, BorderLeft

	LDR	r1, [r2, #VideoStructure_BorderTop]
	STR	r1, BorderTop

	LDR	r1, [r2, #VideoStructure_ScreenMode]
	CMP	r1, #-1
	MOVNE	r0, #0
	SWINE	XOS_ScreenMode

	LDR	r1, VideoStructureFlags
 [ NYI ; SkipByBlanking
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr :OR: VideoStructureFlags_SkipToGOP :OR: VideoStructureFlags_SkipToPic
	BEQ	%FT25
	MOV	r0, #1		; blank screen
	BL	SetBlank

	MOV	r0, #0
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr	; if skipping to sequence
	ORRNE	r0, r0, #CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V	; then enable SEQ-V IRQ and also PIC-V so it works
	TST	r1, #VideoStructureFlags_SkipToGOP		; if skipping to GOP
	ORRNE	r0, r0, #CL450IRQ_GOP :OR: CL450IRQ_PIC_V	; then enable GOP IRQ and also PIC-V so it works
	TST	r1, #VideoStructureFlags_SkipToPic
	ORRNE	r0, r0, #CL450IRQ_PIC_V
	Push	"r1"
	MOV	r1, #0
	BL	EnableDisableIRQs
	Pull	"r1"
25
 ]

 [ SkippingCode
	MOV	r0, #0
	TST	r1, #VideoStructureFlags_SkipToGOP
	MOVNE	r0, #MPEG_group_start_code
	TST	r1, #VideoStructureFlags_SkipToSequenceHdr	; NB this overrides GOP skip
	MOVNE	r0, #MPEG_sequence_header_code
	STR	r0, StartSkipCode
 ]

 [ MPEG2PoduleControl_InterlaceDisable <> 0			; Not available on some systems
	TST	r1, #VideoStructureFlags_NoInterlace
	Push	"r1, r2"
	MOVNE	r1, #MPEG2PoduleControl_InterlaceDisable	; either disable interlace
	MOVEQ	r1, #0						; or enable it
	MVN	r2, #MPEG2PoduleControl_InterlaceDisable	; r2 = AND mask
	BL	UpdateControlRegister
	Pull	"r1, r2"
 ]

 [ HShiftVariable
        Push    "r3, r4"                        ; preserve r3, r4 over call
        Push    "r0-r3"                         ; preserve r0-r2 over call, plus one word for buffer
        ADR     r0, HorizontalShiftString       ; variable name
        ADD     r1, sp, #3*4                    ; buffer is on stack
        MOV     r2, #4                          ; space for the expected signed integer
        MOV     r3, #0                          ; first call
        MOV     r4, #0                          ; don't expand to string
        SWI     XOS_ReadVarVal                  ; read variable
        Pull    "r0-r3"                         ; restore r0-r2 and load result into r3
        MOVVS   r3, #DefaultHShift              ; default if variable undefined
        TEQ     r4, #1
        MOVNE   r3, #DefaultHShift              ; also default if it wasn't an integer variable
        STR     r3, HShift
        Pull    "r3, r4"                        ; restore r3, r4
 ]

	TST	r1, #VideoStructureFlags_DontCLS
	BNE	%FT30

; *** NB Following code assumes 16bpp screen mode ***

	Push	"r1"
	MOV	r0, #&10		; store &F000
	MOV	r1, #&F000
	SWI	XOS_SetColour
	SWI	XOS_WriteI + 16
	Pull	"r1"

30
	TST	r1, #VideoStructureFlags_DontChangePalette
	BNE	%FT50			; [don't change palette]

; first program External Register in VIDC20 to enable EClk

	LDR	r0, =&C0001007
	MOV	r1, #VIDC
	STR	r0, [r1]

; *** NB Following code assumes 16bpp mode ***
; program entries 0 to 15
; - entries 0 to 7 output 0 on ext (solid colours)
; - entries 8 to 15 output 15 on ext (transparent) - NB no individual RGB transparency on MPEG 2 card

	Push	"r2, r3, r4, r9"
	MOV	r0, #15
40
	MOV	r1, #16
	SWI	XOS_ReadPalette
	BVS	%FT90

	BIC	r2, r2, #&FF
	TST	r0, #8
	ORRNE	r2, r2, #&10		; only set ED[0] which controls RGB switch, not ED[3] which controls Macrovision switch
	MOV	r4, #2
	MOV	r9, #&23
	SWI	XOS_CallAVector
	BVS	%FT90
	SUBS	r0, r0, #1
	BPL	%BT40

; program border colour to be transparent also

	MOV	r0, #0
	MOV	r1, #24
	MOV	r2, #&10		; 28-May-97 TMD Correct border colour also to only set ED[0]
	MOV	r4, #2
	MOV	r9, #&23
	SWI	XOS_CallAVector
	BVS	%FT90

	Pull	"r2, r3, r4, r9"
50
 [ {FALSE}
	LDR	r1, [r2, #VideoStructure_Flags]
	TST	r1, #VideoStructureFlags_NTSC
	MOVEQ	r0, #VF_PAL
	MOVNE	r0, #VF_NTSC
	BL	SetVideoFormat
 ]

	LDR	r0, BorderLeft
	LDR	r1, BorderTop
	BL	SetBorder

	BL	SetWindow

	MOV	r0, r12
	CLRV
	EXIT

	LTORG

90
	Pull	"r2, r3, r4, r9"
	SETV
	EXIT

 [ HShiftVariable
HorizontalShiftString
        =       "MPEG2$HorizontalShift", 0
        ALIGN
 ]

xdebug  SETL    {FALSE}

VideoSlowMotion
NewPacket
SetVideoFormat
SetBorder
SetWindow
AudioSkipFrame
AudioRepeatFrame
AudioSlowMotion
AudioFlushBitstream
	MOV	pc, lr


InitStream_Common Entry "r0-r2"

; zero counts of IRQs

	MOV	r0, #0
	ADR	r1, IRQCounts
	MOV	r2, #16
10
	STR	r0, [r1], #4
	SUBS	r2, r2, #1
	BNE	%BT10

					; set up soft copy of Status 0 register
	STR	r0, Status0SoftCopy	; (all video streams enabled, don't reset channel buffer on error)

	LDR	r0, =&FFFE		; all IRQs disabled, video decoder stopped
	STR	r0, IRSoftCopy

	BL	InitL64002
	BL	CommonClaimInterruptVectors
	EXIT

	LTORG

; **************************************************************************
;
;	VideoSetSpeed - Set speed of MPEG stream
;
; in:	r0 = flags
;	r1 = video stream handle
;	r2 = speed indicator
;	       0    = paused
;	       1    = normal speed
;	       2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

VideoSetSpeed Entry "r0-r2, r11"
	LDR	r11, L64002_Registers
	CMP	r2, #8			; don't allow speeds slower than 8
	MOVHI	r2, #8

 [ :LNOT: SlowMotionSupport
	CMP	r2, #1			; if don't support slow motion
	MOVHI	r2, #1			; treat 2 to 8 as 1 (normal play)
 ]

	LDR	r0, VideoSpeedSetting
	TST	r0, #&80000000  	; if pre-buffering
	ORRNE	r2, r2, #&80000000 	; then still pre-buffering, but may have speed setting after
	STR	r2, VideoSpeedSetting

	CMP	r2, #1
	BLT	%FT20			; pause (or pre-buffering)
 [ SlowMotionSupport
	MOVNE	lr, #0
	STRNE	lr, VideoSpeedCount	; if slow motion, set count to 0
	BNE	%FT15			; and put into play mode
 ]
10
 [ StartVideoAtSeqHdr
        ADR     lr, VideoLastPTS
        LDMIA   lr, {r0, r1}
        TEQ     r0, #0
        TEQEQ   r1, #0                  ; if VideoLastPTS still holds 0,0 then it's probably still invalid from prebuffering stage
        BLNE    WriteSCR                ; set SCR from last video PTS that was posted, if it appears to be valid
 |
	ADR	lr, VideoLastPTS	; set SCR from last video PTS that was posted
	LDMIA	lr, {r0, r1}
	BL	WriteSCR
 ]
 [ SlowMotionSupport
	MOV	lr, #0
	STR	lr, TrickStopFreeze	; ensure no left-over slow-mo freeze
 ]
15
	BL	VideoSendPlay
	CLRV
	EXIT

20
	BL	VideoSendPause
	CLRV
	EXIT

; **************************************************************************
;
;	VideoPlay - Start going
;
; in:	r0 = flags
;	r1 = video stream handle
;
; out:  -
;

VideoPlay Entry "r0,r2, r11"
      [ StartVideoAtSeqHdr
        LDRB    lr, DeferVideoStart
        TEQ     lr, #1
        EXIT    EQ                      ; don't start yet if deferred
      ]
	LDR	r2, VideoSpeedSetting
	BIC	r2, r2, #&80000000	; clear pre-buffering bit
	STR	r2, VideoSpeedSetting
	BL	VideoSetSpeed
	EXIT

xdebug  SETL    {FALSE}

; **************************************************************************
;
;	VideoFullPackets - Here's some more data
;
; in:	r0 = flags
;	r1 = video stream handle
;	r2 -> one or more linked bitstream packets

VideoFullPackets Entry "r0,r2,r11"
 [ xdebug
	DLine	"MPEGVideo_FullPackets called"
	LDR	lr, [r2, #PacketDescriptor_Flags]
	DREG	lr, "Packet flags = "
	LDR	r11, [r2, #PacketDescriptor_Length]
	DREG	r11, "Packet length = "
 ]
 [ DiscardPartialPackets
	LDR	lr, VideoHadFirstPacket
	TEQ	lr, #0
	BNE	%FT20					; not skipping partial PES packet
10
	LDR	lr, [r2, #PacketDescriptor_Flags]	; check if packet is start of MPEG packet
	TST	lr, #PacketDescriptorFlags_MPEGStart
	MOVNE	lr, #1					; it is, so indicate we've had 1st packet
	STRNE	lr, VideoHadFirstPacket
	BNE	%FT20					; then continue
	BL	DiscardPacket				; it isn't the start, so throw packet away
	TEQ	r2, #0					; if more packets
	BNE	%BT10					; then loop
	EXIT						; else exit
20
 ]
 [ StartVideoAtSeqHdr
        LDRB    lr, SkippingToSeqHdr
        TEQ     lr, #1
        BEQ     %FT21
        BL      int_video_full_packets                  ; if we're not skipping, process packets normally
        EXIT
21
        Push    "r3"                                    ; otherwise, queue the call
        BL      NewFullPacketsLink
        MOVVC   lr, #0
        STRVC   lr, [r3, #FPQ_VideoAudio]
        STRVC   r0, [r3, #FPQ_Flags]
        STRVC   r1, [r3, #FPQ_StreamHandle]
        STRVC   r2, [r3, #FPQ_PacketList]
        Pull    "r3"
        EXIT    VS
        Debug   skip, "Queuing VideoFullPackets call"

        BL      ProcessQueuedVideoPackets               ; may or may not call int_video_full_packets and int_audio_full_packets
        EXIT


int_video_full_packets Entry "r0,r11"
 ]
 [ Save1stFullPacket
	LDR	r11, [r2, #PacketDescriptor_Length]
	LDR	lr, SavedPacketLength
	TEQ	lr, #0
	BNE	%FT40					; [already saved, so skip]
	CMP	r11, #?FirstPacket			; if bigger than we've room for
	MOVHI	r11, #?FirstPacket			; reduce size
	STR	r11, SavedPacketLength
	ADR	r0, FirstPacket
	LDR	lr, [r2, #PacketDescriptor_Start]
	Push	"r1"
35
	SUBS	r11, r11, #1				; copy the packet into saved area
	LDRCSB	r1, [lr, r11]
	STRCSB	r1, [r0, r11]
	BHI	%BT35
	LDR	r1, [r2, #PacketDescriptor_Flags]	; save PTS, or -1 if none
	TST	r1, #PacketDescriptorFlags_PTSValid
	MOVEQ	r1, #-1
	LDRNE	r1, [r2, #PacketDescriptor_PTS +0]
	STR	r1, SavedPacketPTS +0
	LDRNEB	r1, [r2, #PacketDescriptor_PTS +4]
	STR	r1, SavedPacketPTS +4
	Pull	"r1"
40
 ]
	LDR	r11, L64002_Registers
	MOV	r0, pc
	Push	"r0"
	ORR	lr, r0, #I_bit
	TEQP	lr, #0					; disable IRQs round this bit

	LDR	r0, VideoPacketListTailPtr
	TEQ	r0, #0					; if nothing on list
	STREQ	r2, VideoPacketListHeadPtr		; then point head at new packets
	STRNE	r2, [r0, #PacketDescriptor_Link]	; else tail!link = packet
50
	LDR	r0, [r2, #PacketDescriptor_Length]
	LDR	lr, VideoAmountReceived
	ADD	lr, lr, r0
	STR	lr, VideoAmountReceived

	LDR	r0, [r2, #PacketDescriptor_Flags]
	TST	r0, #PacketDescriptorFlags_PTSValid	; if packet has a valid PTS (ie is start of an MPEG packet)
	ORRNE	r0, r0, #PacketDescriptorFlags_Unchecked
	STRNE	r0, [r2, #PacketDescriptor_Flags]

	TST	r0, #PacketDescriptorFlags_MPEGStart	; is it the start of a new packet?
	BEQ	%FT70					; [no, so skip this]
	LDR	lr, UnknownLengthPacket			; if it is, check to see if we have an indeterminate length packet in progress
	TEQ	lr, #0
	BEQ	%FT60
	Push	"r0,r1"
 [ FullLengthStats
	ADRL	r0, LengthStatsPosition
	LDR	r1, [r0]
	ADD	r1, r1, #1
	CMP	r1, #LengthStatsArraySize
	STRLE	r1, [r0]
	ADDLE	r0, r0, r1, LSL #2
	LDRLE	r1, [lr, #PacketDescriptor_FullLength]
	STRLE	r1, [r0]
 ]

	LDR	r0, [lr, #PacketDescriptor_Flags]	; there are no more sections in the indeterminate length packet,
	BIC	r0, r0, #PacketDescriptorFlags_FullLengthUnknown ;  so clear the bit
	STR	r0, [lr, #PacketDescriptor_Flags]
	MOV	r0, #0
	STR	r0, UnknownLengthPacket			; and clear the pointer to it
	Pull	"r0,r1"
60
 [ TrickPlaySupport
	LDR	lr, TrickPlayMode
	TEQ	lr, #0
	LDRNE	lr, VideoStructureFlags
	TSTNE	lr, #VideoStructureFlags_TrickPlayPacketLengthFix
	ORRNE	r0, r0, #PacketDescriptorFlags_FullLengthUnknown	; pretend was unknown length
	STRNE	r0, [r2, #PacketDescriptor_Flags]
 ]
	TST	r0, #PacketDescriptorFlags_FullLengthUnknown ; is the new packet of unknown length
	MOVNE	r0, #0
	STRNE	r0, [r2, #PacketDescriptor_FullLength]  ; if so, then zero its full length
 [ TrickPlaySupport

; lr is set above to either zero (if TrickPlayMode=0), or to VideoStructureFlags, so it's OK to just test if the
; packet length bit is set, since it definitely won't be if we're not doing trick play

	TSTNE	lr, #VideoStructureFlags_TrickPlayPacketLengthFix
 ]
 [ FudgeZeroLengthPackets :LOR: TrickPlaySupport
	STRNE	r2, UnknownLengthPacket			; set up pointer to unknown length packet, if doing trick play or always
							;  fudging
 ]
70
	LDR	r0, UnknownLengthPacket			; if we are working out the length
	TEQ	r0, #0
	BEQ	%FT80
	Push	"r1"
	LDR	r1, [r0, #PacketDescriptor_FullLength]
	LDR	lr, [r2, #PacketDescriptor_Length]
	ADD	r1, r1, lr
	STR	r1, [r0, #PacketDescriptor_FullLength]  ; update total length
	Pull	"r1"
80
	LDR	r0, [r2, #PacketDescriptor_Link]	; go down list of packets to end
	TEQ	r0, #0
	MOVNE	r2, r0
	BNE	%BT50

	STR	r2, VideoPacketListTailPtr		; store new tail pointer
	Pull	"r0"
	TEQP	r0, #0					; restore IRQ state

	EXIT

 [ StartVideoAtSeqHdr

; ProcessQueuedVideoPackets
;
; Checks the packets referenced by the new FullPackets link to see if they contain a sequence header
; If so, then previous video packets are freed and subsequent ones are passed to int_video_full_packets
; If not, then some or all of them are left queuing
;
; in:   r2 -> first packet belonging to this FullPackets link

ProcessQueuedVideoPackets
        Entry   "r0-r7"
        Debug   skip, "Entering ProcessQueuedVideoPackets, r2 =", r2
        MOV     r3, r2
30      TEQ     r3, #0
        EXIT    EQ                                      ; run out of packets, and still no sequence header, so exit with things still queued

        LDR     r7, [r3, #PacketDescriptor_Flags]
        TST     r7, #PacketDescriptorFlags_MPEGStart    ; if it's the first in a PES packet, free all previous video packets
        MOVNE   r4, #0
        BLNE    DiscardSelectedPackets

        TST     r7, #PacketDescriptorFlags_DTSValid     ; if the packet has a DTS, remember it
        ADDNE   lr, r3, #PacketDescriptor_DTS
        ADDEQ   lr, r3, #PacketDescriptor_PTS           ; if there's a PTS but no DTS, DTS equals PTS
        TST     r7, #PacketDescriptorFlags_PTSValid :OR: PacketDescriptorFlags_DTSValid
        BEQ     %FT35
        LDMIA   lr, {r5, r6}
        LDR     lr, =6000                               ; fudge factor: the L64002's video decoder seems to need this much warning to initialise itself
        SUBS    r5, r5, lr
        SBC     r6, r6, #0
        ADR     lr, LastVideoDTS0
        STMIA   lr, {r5, r6}

35      LDR     r4, [r3, #PacketDescriptor_Start]       ; r4 -> start of packet data
        LDR     r5, [r3, #PacketDescriptor_Length]
        ADD     r5, r5, r4                              ; r5 -> end of packet data
        LDRB    r6, StartCodeSearchState
40      TEQ     r4, r5                                  ; processed all data?
        STREQB  r6, StartCodeSearchState                ; store search state
        LDREQ   r3, [r3, #FPQ_Next]                     ; and try next packet (if any)
        BEQ     %BT30
        LDRB    lr, [r4], #1                            ; get a byte of packet data
        TEQ     lr, #&B3
        TEQEQ   r6, #3                                  ; if we've got a complete sequence header start code
        BEQ     %FT50                                   ; then break from the loop
        TEQ     lr, #&01
        TEQEQ   r6, #2                                  ; if &01 follows 2 or more &00s
        MOVEQ   r6, #3                                  ; then up the search state to 3
        BEQ     %BT40
        CMP     r6, #3                                  ; if we've got an uninteresting start code
        CMPLT   lr, #&01                                ; or new byte is nonzero ( => not in a start code prefix)
        MOVGE   r6, #0                                  ; then reset search state to 0
        BGE     %BT40
        TEQ     r6, #0                                  ; we got a zero
        MOVEQ   r6, #1                                  ; either it's the first zero (set state to 1)
        MOVNE   r6, #2                                  ; or we've had two or more in a row (set state to 2)
        B       %BT40

50      ; We've found the first sequence header!
        ; Note that we don't need to queue FullPackets calls from now on
        MOV     r0, #0
        STRB    r0, SkippingToSeqHdr

        ; Pass all remaining packets to int_video/audio_full_packets, freeing FullPackets links when done
        ; If we find an audio packet with a PTS earlier than the video start DTS, then set DeferVideoStart to 1
        ADR     r5, LastVideoDTS0
        LDMIA   r5, {r5, r6}
60      LDR     r3, FullPacketsQueue
        TEQ     r3, #0                                  ; done all FullPackets links?
        EXIT    EQ
        LDR     r0, [r3, #FPQ_Flags]
        LDR     r1, [r3, #FPQ_StreamHandle]
        LDR     r2, [r3, #FPQ_PacketList]
        LDR     lr, [r3, #FPQ_VideoAudio]
        TEQ     lr, #0
        BEQ     %FT69
        ; Look for audio PTSs in the audio FullPackets call
        TEQ     r6, #0
        BMI     %FT63                                   ; if video DTS invalid, don't bother comparing with audio PTSs
        MOV     r4, r2                                  ; r4 points at each packet sequentially
61      TEQ     r4, #0
        BEQ     %FT63                                   ; break from loop when no more packets
        LDR     lr, [r4, #PacketDescriptor_Flags]
        TST     lr, #PacketDescriptorFlags_PTSValid
        BEQ     %FT62                                   ; skip next bit if no timestamp (audio never has DTS)
        ADD     r7, r4, #PacketDescriptor_PTS
        LDMIA   r7, {r7, lr}
        SUBS    r7, r5, r7                              ; find video DTS - audio PTS
        SBC     lr, r6, lr
        TST     lr, #1                                  ; test sign bit of result
        MOVEQ   lr, #1
        STREQB  lr, DeferVideoStart
62      LDR     r4, [r4, #PacketDescriptor_Link]
        B       %BT61
63      BL      int_audio_full_packets
        B       %FT70
69      BL      int_video_full_packets
70      ADR     r0, FullPacketsQueue - FPQ_Next
        MOV     r1, r3
        BL      DeleteFullPacketsLink
        B       %BT60

; NewFullPacketsLink
;
; Creates a new link, first by checking the free list, and failing that,
; by claiming RMA, then places it at the end of the list
;
; out:  r3 -> new link
;       V set if error

NewFullPacketsLink
        Entry   "r0,r2"
        LDR     r3, FullPacketsFree
        CMP     r3, #0                          ; also clears V
        BEQ     %FT10
        ; Get a link from the free list
        LDR     r0, [r3, #FPQ_Next]
        STR     r0, FullPacketsFree
        B       %FT20
10      ; Get a link from RMA
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #FPQSize
        SWI     XOS_Module
        EXIT    VS
        MOV     r3, r2
20      ; Add link to end of list
        ADR     r0, FullPacketsQueue - FPQ_Next
30      LDR     r2, [r0, #FPQ_Next]
        TEQ     r2, #0
        MOVNE   r0, r2
        BNE     %BT30
        STR     r2, [r3, #FPQ_Next]             ; zero the next pointer in the new link
        STR     r3, [r0, #FPQ_Next]             ; point previous link at it
        Debug   skip, "NewFullPacketsLink: new link is", r3
        EXIT

; DeleteFullPacketsLink
;
; Moves a FullPackets link to the free list
;
; in:   r0 -> link before the one to be deleted
;       r1 -> link to be deleted

DeleteFullPacketsLink
        Entry
        Debug   skip, "DeleteFullPacketsLink: r0, r1 =", r0, r1
        LDR     lr, [r1, #FPQ_Next]
        STR     lr, [r0, #FPQ_Next]             ; remove from active list
        LDR     lr, FullPacketsFree
        STR     lr, [r1, #FPQ_Next]
        STR     r1, FullPacketsFree             ; and add to the free list
        EXITS

; DiscardSelectedPackets
;
; Discards packets and FullPackets links according to certain criteria
;
; in:   r3: if you find this packet, do not discard it, nor subsequent packets
;       r4 = 0 (discard packets from video FullPackets links) or 1 (audio)

DiscardSelectedPackets
        Entry   "r0-r2, r7, r8"
        Debug   skip, "Entering DiscardSelectedPackets: r3, r4 =", r3, r4
        ADR     r0, FullPacketsQueue - FPQ_Next
01      LDR     r1, [r0, #FPQ_Next]     ; r0 stays pointing at previous link, so we can update its next pointer
        TEQ     r1, #0
        EXIT    EQ                      ; exit if we've processed all FullPackets links
        LDR     lr, [r1, #FPQ_VideoAudio]
        TEQ     lr, r4                  ; if the FullPackets link is the wrong video/audio type
        MOVNE   r0, r1                  ; then move on to the next link
        BNE     %BT01
        ; now r1 -> next FullPackets link of the correct video/audio type
        LDR     r2, [r1, #FPQ_PacketList]
02      TEQ     r2, #0                  ; last packet in the list?
        BNE     %FT03
        BL      DeleteFullPacketsLink   ; if so, then free the FullPackets link,
        B       %BT01                   ; and move on to the next link
03      ; r2 -> next bitstream buffer to discard
        TEQ     r2, r3                  ; stop discarding packets if we reach r3
        STREQ   r2, [r1, #FPQ_PacketList]
        EXIT    EQ
        BL      DiscardPacket           ; also updates r2 to point to next packet
        B       %BT02

; FreeFullPacketsLinkedList
;
; Actually frees the RMA blocks making up the list
;
; in:   r3 -> first link in list (or 0 if none)
; out:  r0, r2 corrupted

FreeFullPacketsLinkedList
        Entry
        Debug   skip, "FreeFullPacketsLinkedList: r3 =", r3
        ASSERT  FPQ_Next = 0
01      MOVS    r2, r3
        EXITS   EQ
        LDR     r3, [r2, #FPQ_Next]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        B       %BT01
 ]

xdebug  SETL    {FALSE}

; **************************************************************************
;
;	VideoCloseStream - Close MPEG video stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGVideo_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:	r0 = flags
;	r1 = Video stream handle
;

VideoCloseStream Entry "r0-r2,r11"
	LDR	r11, L64002_Registers

	LDR	r0, UnknownLengthPacket			; do we have an indeterminate-length packet pending?
	TEQ	r0, #0					; if so then length is now complete
	LDRNE	lr, [r0, #PacketDescriptor_Flags]
	BICNE	lr, lr, #PacketDescriptorFlags_FullLengthUnknown
	STRNE	lr, [r0, #PacketDescriptor_Flags]
	MOVNE	lr, #0
	STRNE	lr, UnknownLengthPacket			; and no unknown packet now

	LDR	r0, VideoSpeedSetting
	TEQ	r0, #0
	BEQ	%FT50					; [it was paused, so junk data]

	BPL	%FT10					; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

	TEQ	r0, #&80000000
	BEQ	%FT50

   [ SendPlaySWI
	BLCS	VideoIssuePlaySWI
   |
	BLCS	VideoSendPlay
   ]

; wait for data to empty

10
	MOV	r0, #1					; indicate to multiple picture packet checker that we won't get
	STR	r0, VideoStreamClosing			; any more data, so don't hang around
20
	TEQP	pc, #0
	NOP						; allow callbacks
	SWI	OS_EnterOS

	LDR	r0, VideoPacketListHeadPtr		; do we have any outstanding packets?
	CMP	r0, #0					; V := 0
	BNE	%BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
	MOV	r0, #2
	STR	r0, VideoStreamClosing
60
	LDR	r0, VideoPacketListHeadPtr
	CMP	r0, #0				; V := 0
	BLNE	VideoFreePacket
	BNE	%BT60
70
      [ StartVideoAtSeqHdr
        Debug   skip, "Discarding queued calls on CloseStream"
        Push    "r3-r4"
        MOV     r3, #0
        MOV     r4, #0                                  ; discard all queued VideoFullPackets calls
        BL      DiscardSelectedPackets
        MOV     r4, #1                                  ; discard all queued AudioFullPackets calls
        BL      DiscardSelectedPackets
        Pull    "r3-r4"
      ]
	BL	VideoReleaseInterruptVectors
	LDR	r0, AudioControlStreamHandle		; if audio not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, VideoControlStreamHandle		; stream no longer open
      [ Captions
        BL      EraseCaptions                           ; so they don't stay on screen when we're back to the browser
      ]
	EXIT

; **************************************************************************
;
;	CardControl - Various hardware and interrupt control functions
;

BadCardControlReason
	ADRL	r0, BadCardControlReasonError
	SETV
	MOV	pc, lr

CardControl ROUT
	CMP	r0, #CardControlBadReason
	ADDCC	pc, pc, r0, LSL #2
	B	BadCardControlReason
10
	B	ClaimAudioIRQ
	B	ReleaseAudioIRQ
	B	UpdateControlRegisterMPEG1Style
	B	ControlPowerDown
	B	BadCardControlReason	; SendMacroCommand
	B	BadCardControlReason	; SetColourMode
	B	ReadStatusRegister
	ASSERT  CardControlBadReason :SHL: 2 = {PC}-%BT10

; in:	r0 = reason code (0=Claim audio IRQ)
;	r1 -> audio interrupt routine
;	r2 = workspace pointer for audio IRQ
;
; out:  -

ClaimAudioIRQ * BadCardControlReason

; in:	r0 = reason code (1=Release audio IRQ)
;
; out:  -

ReleaseAudioIRQ * BadCardControlReason

; in:	r0 = reason code (2=Update Control register)
;	r1 = EOR mask
;	r2 = AND mask
;
; out:  r1 = old value of control register
;	r2 = new value of control register
;
; Performs CR = (CR AND r2) EOR r1

UpdateControlRegisterMPEG1Style Entry "r0"
; Bits 3 to 7 of the values correspond to bits 11 to 15 of our logical value
; Other bits are ignored

	MVN	r0, #&F800			; mask of bits to leave alone 0..10,16..31
	ORR	r2, r0, r2, LSL #8		; merge with bits to leave alone in bits 11..15
	MOV	r1, r1, LSL #8			; shift up EOR mask
	BIC	r1, r1, r0			; then knock out bits we're not allowed to touch
	TST	r2, #MPEG2PoduleControl_CTRL0	; make modulator boost bit reflect CTRL0 (not CTRL1 as previously)
	BICEQ	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	TST	r1, #MPEG2PoduleControl_CTRL0	; in EOR mask as well as AND mask
	BICEQ	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	BL	UpdateControlRegister
	MOV	r0, #&F8			; valid bits to return
	AND	r1, r0, r1, LSR #8		; shift down + mask old control register value
	AND	r2, r0, r2, LSR #8		; and the same for the new value
	EXIT

; UpdateControlRegister - Update the MPEG control register
; On entry:
;   r1 = EOR value
;   r2 = AND value
; On exit:
;   r1 = old value
;   r2 = new value

UpdateControlRegister Entry "r0"
 [ SCARTCTRLRegistersAreInIOMD
	Push	"r1, r3, r4"
	MOV	r3, #0
	MOV	r4, #0

	; Set control bit 0
	MOV	r0, #0
	TST	r1, #UpdateControlRegister_CTRL0 :SHL: 8
	EORNE	r0, r0, #2
	TST	r2, #UpdateControlRegister_CTRL0 :SHL: 8
	EOREQ	r0, r0, #3
	ADRL	r1, SCART_TV_String
	SWI	XPortMan_AccessBit
	TST	r0, #1
	ORREQ	r3, r3, #UpdateControlRegister_CTRL0 :SHL: 8
	TST	r0, #2
	ORREQ	r4, r4, #UpdateControlRegister_CTRL0 :SHL: 8

	; Set control bit 1
	LDMIA	r13, {r1}
	MOV	r0, #0
	TST	r1, #UpdateControlRegister_CTRL1 :SHL: 8
	EORNE	r0, r0, #2
	TST	r2, #UpdateControlRegister_CTRL1 :SHL: 8
	EOREQ	r0, r0, #3
	ADRL	r1, SCART_CVBS_String
	SWI	XPortMan_AccessBit
	TST	r0, #1
	ORREQ	r3, r3, #UpdateControlRegister_CTRL1 :SHL: 8
	TST	r0, #2
	ORREQ	r4, r4, #UpdateControlRegister_CTRL1 :SHL: 8
	Pull	"r1"
 ]

	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round atomic update

	LDR	lr, PoduleControlSoftCopy
	AND	r2, r2, lr
	EOR	r2, r2, r1
	MOV	r2, r2, LSL #16
	MOV	r2, r2, LSR #16			; knock off bits 16..31
	STR	r2, PoduleControlSoftCopy	; update soft copy, r2 = new value
	MOV	r1, lr				; r1 = old value
	LDR	lr, Podule_ControlStatus1
	STRB	r2, [lr]			; update hardware
	LDR	lr, Podule_ControlStatus2
	MOV	r2, r2, ROR #8
	STRB	r2, [lr]
	MOV	r2, r2, ROR #24			; put back to original value

	TEQP	r0, #0

 [ SCARTCTRLRegistersAreInIOMD
	; Clear the bits from the Podule register
	BIC	r1, r1, #(UpdateControlRegister_CTRL0:OR:UpdateControlRegister_CTRL1) :SHL: 8
	BIC	r2, r2, #(UpdateControlRegister_CTRL0:OR:UpdateControlRegister_CTRL1) :SHL: 8
	; Get them from PortMan
	ORR	r1, r1, r3
	ORR	r2, r2, r4
        Pull    "r3, r4"
 ]
	EXIT


; in:	r0 = reason code (3=Control power down)
;	r1 bit 0 = 0 => Place MPEG card in normal running state
;		   1 => Place MPEG card in power down state (stop CL450 GCLK)
;	   bits 1..31 reserved, should be zero
; out:	-

ControlPowerDown * BadCardControlReason

; in:	r0 = reason code (6=Read status register)
;
; out:	r1 = value of status register (actually two 8-bit registers combined into 16)
;

ReadStatusRegister Entry
	LDR	lr, Podule_ControlStatus1	; merge Status1
	LDRB	r1, [lr]
	LDR	lr, Podule_ControlStatus2	; and Status2
	LDRB	lr, [lr]
	ORR	r1, r1, lr, LSL #8
	CLRV
	EXIT

; **************************************************************************
;
;	VideoSetSCR - SWI to set the SCR value
;
; in:	r0 = flags
;	r1 = bits 0..31 of SCR
;	r2 = bit 32 of SCR

VideoSetSCR  Entry "r0-r2,r11"
	LDR	r0, SyncOffset
	ADDS	r1, r1, r0
	ADDCS	r2, r2, #1
 [ SuppressNegativeSCRs
	CMP	r2, #0
	EXIT	LT
 ]
	LDR	r11, L64002_Registers
	MOV	r0, r1
	MOV	r1, r2

	BL	WriteSCR
	EXIT

; **************************************************************************
;
;	ReadParameters - Read various stream parameters
;
; in:	r0 = reason code
;	  0 => read time code and temporal reference
;	       out: r1 = time code: bits 0..5	= time_code_pictures
;				    bits 6..11  = time_code_seconds
;				    bits 12..17 = time_code_minutes
;				    bits 18..22 = time_code_hours
;				    bit  23	= drop_frame_flag
;		    r2 = temporal_reference
;	  1 => read direct access parameters for SetSCR
;	       out: r1 = address of SetSCR routine
;		    r2 = workspace value for SetSCR routine
;	  2 => read various locations
;		in: r1 = index of location to read:
;			  0 => CompletionTime
;			  1 => MaxCompletionTime
;	       out: r2 = value
;	  3 => read current SCR value
;		out: r1 = bits 0..31 of SCR
;		     r2 = bit  32    of SCR
;	  4 => read buffer fullness
;		out: r1 = number of bytes in internal buffer
;	  5 => check display ready
;		out: r1 = 1 if 1st picture has been displayed yet, 0 if not

ReadParameters ROUT
	CMP	r0, #ReadParametersBadReason
	ADDCC	pc, pc, r0, LSL #2
	B	BadReadParametersReason
10
	B	ReadTimeCode
	B	ReadSetSCRParameters
	B	ReadDebugInfo
	B	UserReadSCR
	B	ReadBufferFullness
	B	CheckDisplayReady
	ASSERT  ReadParametersBadReason = ({PC} - %BT10) :SHR: 2

BadReadParametersReason
	ADRL	r0, BadReadParametersReasonError
	SETV
	MOV	pc, lr

ReadTimeCode ROUT
	MOV	r1, #0
	MOV	r2, #0
	MOV	pc, lr

ReadSetSCRParameters ROUT
	ADR	r1, VideoSetSCR
	MOV	r2, wp
	CLRV
	MOV	pc, lr

ReadDebugInfo ROUT
	ADR	r2, DebugVarTable
	CMP	r1, #(DebugVarTableEnd - DebugVarTable) :SHR: 2
	LDRCC	r2, [r2, r1, LSL #2]		; get offset of variable
	MOVCS	r2, #-1
	CMP	r2, #-1
	LDRNE	r2, [wp, r2]
	CLRV
	MOV	pc, lr

DebugVarTable
	&	-1
	&	-1
	&	:INDEX: VideoLastPTS +0		; low word of last PTS sent to L64002
	&	:INDEX: VideoNumberOfPTSs
	&	:INDEX: SCROffset
	&	:INDEX: VideoSkips
	&	:INDEX: VideoRepeats
	&	:INDEX: AudioFasts
	&	:INDEX: AudioSlows
	&	:INDEX: LastAudioBufferFullness
	&	:INDEX: AudioBufferChecks
DebugVarTableEnd

UserReadSCR Entry "r11"
	BL	CheckStreamOpen
	MOVEQ	r1, #0				; if no stream open, return zero
	MOVEQ	r2, #0
	EXIT	EQ
	LDR	r11, L64002_Registers
	BL	ReadSCR
	EXIT

; CheckStreamOpen - returns NE if audio or video stream open, all registers preserved

CheckStreamOpen Entry
	LDR	lr, VideoControlStreamHandle
	TEQ	lr, #0
	LDREQ	lr, AudioControlStreamHandle
	TEQEQ	lr, #0
	EXIT

; ReadBufferFullness - return r1 = amount of data in video buffers

ReadBufferFullness Entry "r2,r11"
	LDR	r1, VideoControlStreamHandle
	TEQ	r1, #0			; if no video stream open, return 0 in r1
	EXIT	EQ
	LDR	r11, L64002_Registers
	BL	VideoGetBufferFullness	; returns it in r2
	MOV	r1, r2
	EXIT

CheckDisplayReady Entry
	LDR	r1, DecodedFieldCount
	CMP	r1, #-2			; have we displayed 1st field (value -2)
	MOVEQ	r1, #1			; if so then return 1
	MOVNE	r1, #0			; else return 0
	EXIT

; **************************************************************************
;
;	VideoResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = video stream handle
;
; out:	r2 = estimate of number of bytes discarded

; In this implementation it also resets the audio system as well, since we have to reset the whole L64002 to do this.
; If an audio stream is open at the time, then, in the anticipation that we will shortly be getting an MPEGAudio_ResetStream,
; we first find out how much audio data is being thrown away from the audio channel buffer, and save this away in the variable
; AudioDiscardedDataCount.
;
; When the MPEGAudio_ResetStream is issued, we see that the variable is non-zero, and use that value, and don't reset the device.
; However we do at that point free all the audio packets, adding onto this length. We then set the variable back to -1.

VideoResetStream Entry "r0-r2, r11"
	LDR	r11, L64002_Registers

	MOV	r2, #2					; pretend we're closing, so we don't send any more data to it in background
	STR	r2, VideoStreamClosing
	STR	r2, AudioStreamClosing

	BL	VideoReleaseInterruptVectors
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors

 [ TrickPlaySupport
	TST	r0, #ResetStreamFlags_TrickPlayMode
	MOVEQ	r2, #0
	MOVNE	r2, #1
	STR	r2, TrickPlayMode
 ]

 [ AllowSyncOnIFrames :LOR: CountVideoPackets
	MOV	r2, #0					; assume we're not going to enable I-Frame syncing
	TST	r0, #ResetStreamFlags_AudioPresent
	BNE	%FT08					; [audio present, so don't use I-frame syncing]
	LDR	lr, VideoStructureFlags
	TST	lr, #VideoStructureFlags_IFrameSyncWhenNoAudio
	MOVNE	lr, #0
  [ AllowSyncOnIFrames
	STRNE	lr, AnchorPostedPTSWritePtr		; zero write pointer
	STRNE	lr, AnchorPostedPTSReadPtr		; and read ptr
  ]
  [ CountVideoPackets
	STRNE	lr, VideoPacketsReceived
	STRNE	lr, VideoPicturesReceived
	STRNE	lr, VideoOKCount
	STRNE	lr, VideoSyncPos
  ]
	MOVNE	r2, #1
08
	STR	r2, SyncMode
 ]

 [ StartVideoAtSeqHdr
        Debug   skip, "Discarding queued calls on ResetStream"
        Push    "r3-r4"
        MOV     r3, #0
        MOV     r4, #0                                  ; discard all queued VideoFullPackets calls
        BL      DiscardSelectedPackets
        MOV     r4, #1                                  ; discard all queued AudioFullPackets calls
        BL      DiscardSelectedPackets
        Pull    "r3-r4"

        ASSERT  StreamFlags_VideoPresent = ResetStreamFlags_VideoPresent
        ASSERT  StreamFlags_AudioPresent = ResetStreamFlags_AudioPresent
        LDR     lr, VideoStreamFlags
        AND     lr, lr, r0
        AND     lr, lr, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        TEQ     lr, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        MOVEQ   lr, #1                                  ; only skip to sequence header if there are both video and audio in the new stream
        MOVNE   lr, #0
        STRB    lr, SkippingToSeqHdr
 ]
	LDR	lr, AudioControlStreamHandle		; is there an audio stream open?
	TEQ	lr, #0
	BEQ	%FT10					; [if not then skip]

	BL	AudioGetBufferFullness
	STR	r2, AudioDiscardedDataCount
10

	BL	VideoGetBufferFullness			; returns fullness in r2
	LDR	r0, VideoPacketListHeadPtr
20
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	VideoFreePacket				; and free the packet
	BNE	%BT20					; then loop

	STR	r2, [sp, #2*4]				; update returned r2 value with byte count

	BL	VideoReset

	MOV	r0, #0
	STR	r0, VideoStreamClosing
 [ SkippingCode
	STR	r0, StartSkipCode
 ]
 [ CountUnderruns
	STR	r0, UnderrunIRQState			; wait again until prefill over, then reenable underrun IRQ
 ]
	CLRV
	EXIT

; **************************************************************************
;
;	VideoReset - Reset stuff for video stream - common to MPEGVideo_OpenStream and MPEGVideo_ResetStream
;

VideoReset Entry "r0"
	MOV	r0, #0
	STR	r0, UnknownLengthPacket				; no unknown length packet pending
	STR	r0, VideoInfoStructure+SI_PTSListReadPtr	; reset pointers to PTS lists
	STR	r0, VideoInfoStructure+SI_PTSListWritePtr
	STR	r0, LastVideoPTSErrorSign			; no PTSs received since reset
	STR	r0, VideoLastPTS +0				; no last PTS value
	STR	r0, VideoLastPTS +4
	STR	r0, VideoAmountQueued				; nothing queued yet
	STR	r0, FirstItemReceived				; no sequence or picture received
	STR	r0, LastErrorStatus
	STR	r0, CumulativeErrorStatus
	STR	r0, VidRecErrors
	STR	r0, ContextErrors
	STR	r0, VLCErrors
 [ FreezeFieldOnTrickStop
	STR	r0, TrickStopFreeze
 ]
 [ SaveAPacket
	STR	r0, SavedPacketLength				; throw away any saved packet
 ]
 [ DiscardPartialPackets
	STR	r0, VideoHadFirstPacket				; not had PES packet
	STR	r0, AudioHadFirstPacket
 ]
 [ StartVideoAtSeqHdr
        STRB    r0, StartCodeSearchState                        ; mark no start code found
        STRB    r0, DeferVideoStart                             ; by default, start video at same time as audio
        MOV     r0, #1
        STRB    r0, FirstAudioPTS                               ; the next PES header we process will be the first one
        MOV     r0, #-1
        STR     r0, LastVideoDTS0                               ; mark DTS invalid
        Debug   skip, "ResetStream: last video DTS marked invalid"
 ]
	MOV	r0, #1
	STR	r0, VideoPreFilling				; we are now pre-filling

	MOV	r0, #-1
	STR	r0, DecodedFieldCount				; not got good display yet
	STR	r0, VideoPostedPTS+4				; indicate no posted PTS
	LDR	r0, BlankedSequences				; start counting this number of sequence headers
	STR	r0, SequenceCount

	Push    "r1"
	MOV	r1, #&FFFFFFFF					; maximum value
        ADR	r0, VideoBufferPreFillString
	BL	ReadNumericVariable
	LDRVS	r0, =VideoPreFillSize
	STR	r0, VideoVBVSize
	Pull    "r1"

	MOV	r0, #&80000001					; indicate pre-buffering, but would otherwise be playing
	STR	r0, VideoSpeedSetting

      [ Captions
        MOV     r0, #-3
        STR     r0, UserData_State                              ; reinitialise user data parser
        MOV     r0, #-1
        STR     r0, UserData_dataLength
        STR     r0, UserData_dataBytes                          ; this lets us see if any user data has been received at all
        MOV     r0, #0
        STR     r0, UserData_OldCCDataBytes
        STR     r0, UserData_OldEDSDataBytes                    ; don't send any data for first anchor frame
        BL      EraseCaptions                                   ; clear captions overlay
      ]

      [ Pulldown
        MOV     r0, #-1                                         ; won't match with any previous layer ID
        STR     r0, AuxData_LastKnownLayer
        STR     r0, PU_Countdown                                ; this won't reach zero in a hurry
        STR     r0, PU_EstCountdown                             ; we have no useful estimate yet
        MOV     r0, #1
        STRB    r0, LastAnchorAUInvalid                         ; no data for a held-over anchor frame yet
        Debug   pulldown, "Last Anchor AU marked invalid"
        STRB    r0, FirstField_FuturePU                         ; these all default to top field first PU's
        STRB    r0, FirstField_NextPU
        STRB    r0, FirstField_CurrentPU
        ReadRegI r0, DisplayControllerStatus
        AND     r0, r0, #1                                      ; extract even/odd field bit
        STRB    r0, EvenOddIndicator
        BL      InitialiseAuxData                               ; most video streams don't contain all the extensions, so set up some sensible defaults
      ]

	BL	InitStream_Common
	BL	VideoClaimInterruptVectors

	MOV	r0, #-1
	STR	r0, TimeOffsetOfVRError

	SWI	XOS_ReadMonotonicTime
	STR	r0, TimeOfLastVideoReset			; remember time of last video reset

        CLRV
	EXIT

VideoBufferPreFillString
	=	"MPEG2$VideoBufferPreFill", 0
	ALIGN

      [ Captions
EraseCaptions
        Entry   "r0-r2,r8"
        MOV     r0, #6                                          ; odd fields, calculate parity bits, flush buffer
        ADR     r1, EraseCaptions_OddField_Start
        MOV     r2, #EraseCaptions_OddField_End-EraseCaptions_OddField_Start
        MOV     r8, #1
        BL      CallHandler                                     ; clear captions channels 1 and 2

        MOV     r0, #7                                          ; even fields, calculate parity bits, flush buffer
        ADR     r1, EraseCaptions_EvenField_Start
        MOV     r2, #EraseCaptions_EvenField_End-EraseCaptions_EvenField_Start
        MOV     r8, #2
        BL      CallHandler                                     ; clear captions channels 3 and 4
        EXITS

EraseCaptions_OddField_Start
        =       &14, &2C, &14, &2C              ; Erase Displayed Memory, captions channel 1
        =       &1C, &2C, &1C, &2C              ; Erase Displayed Memory, captions channel 2
        =       &14, &2E, &14, &2E              ; Erase Nondisplayed Memory, captions channel 1
        =       &1C, &2E, &1C, &2E              ; Erase Nondisplayed Memory, captions channel 2
EraseCaptions_OddField_End

EraseCaptions_EvenField_Start
        =       &15, &2C, &15, &2C              ; Erase Displayed Memory, captions channel 3
        =       &1D, &2C, &1D, &2C              ; Erase Displayed Memory, captions channel 4
        =       &15, &2E, &15, &2E              ; Erase Nondisplayed Memory, captions channel 3
        =       &1D, &2E, &1D, &2E              ; Erase Nondisplayed Memory, captions channel 4
EraseCaptions_EvenField_End
        ALIGN
      ]

      [ Pulldown
        GBLA    AuxInit_ByteCount

        MACRO
        AuxInit $block
AuxInit_ByteCount SETA (:INDEX: $block.DataEnd - :INDEX: $block.Data)
        &       :INDEX: $block.Data
        &       AuxInit_ByteCount
01
        MEND

        MACRO
        AuxInitEnd
        ASSERT  (. - %BT01) = AuxInit_ByteCount
        ALIGN
        MEND

InitialiseAuxData
        Entry   "r0-r3"
        ADR     r3, AuxDataInitialisationTable
01      LDR     r1, [r3], #4    ; initialise pointer for next block
        CMP     r1, #-1         ; or is it the end of the list?
        EXITS   EQ
        ADD     r1, r1, wp      ; convert from ws offset to absolute address
        LDR     r2, [r3], #4    ; byte count
02      LDRB    r0, [r3], #1
        STRB    r0, [r1], #1    ; transfer byte
        SUBS    r2, r2, #1
        BNE     %BT02
        ADD     r3, r3, #3
        BIC     r3, r3, #3      ; align r3 to next word boundary
        B       %BT01

AuxDataInitialisationTable
        ; Most video streams do not contain all the extensions, so we need to define these default values.
        ; When playing MPEG-1 video streams, there are no extensions by definition.
        ; Note, each extension_ID is initialised to 0 to flag that the extension has not yet been found in this stream.

        AuxInit SequenceExtension
        =       &00             ; extension_ID
        =       &4A             ; profile_and_level_indication          = main profile at low level
        =       &01             ; progressive_sequence
        =       &10             ; chroma_format, horizontal_size_extension, vertical_size_extension
        =       &00, &00        ; bit_rate_extension
        =       &00             ; vbv_buffer_size_extension
        =       &00             ; low_delay, frame_rate_extension_n, frame_rate_extension_d
        AuxInitEnd

        AuxInit DisplayExtension
        =       &00             ; extension_ID
        =       &01             ; video_format, colour_description      = component video, colour fields not present
        =       &FF             ; colour_primaries
        =       &FF             ; transfer_characteristics
        =       &FF             ; matrix_coefficients
        =       &00, &00        ; display_horizontal_size
        =       &00, &00        ; display_vertical_size
        AuxInitEnd

        AuxInit PictureCodingExtension
        =       &00             ; extension_ID
        =       &0F             ; f_code[0][0]                          = unused
        =       &0F             ; f_code[0][1]                          = unused
        =       &0F             ; f_code[1][0]                          = unused
        =       &0F             ; f_code[1][1]                          = unused
        =       &00             ; intra_dc_precision
        =       &03             ; picture_structure                     = frame
        =       &00             ; top_field_first
        =       &01             ; frame_pred_frame_dct
        =       &00             ; concealment_motion_vectors
        =       &01             ; q_scale_type
        =       &01             ; intra_vlc_format
        =       &00             ; alternate_scan
        =       &00             ; repeat_first_field
        =       &01             ; chroma_420_type
        =       &01             ; progressive_frame
        =       &00             ; composite_display_flag
        =       &FF             ; v_axis, field_sequence, sub_carrier
        =       &FF             ; burst_amplitude
        =       &FF             ; sub_carrier_phase
        AuxInitEnd

        AuxInit QuantMatrixExtension
        =       &00             ; extension_ID
        AuxInitEnd

        AuxInit CopyrightExtension
        =       &00             ; extension_ID
        =       &00             ; copyright_flag
        =       &00             ; copyright_identifier
        =       &01             ; original_or_copy
        =       &00             ; reserved
        =       &00, &00, &00   ; copyright_number_1
        =       &00, &00, &00   ; copyright_number_2
        =       &00, &00, &00   ; copyright_number_3
        AuxInitEnd

        AuxInit PanAndScanExtension
        =       &00             ; extension_ID
        =       &00, &00        ; frame_centre_horizontal_offset (integer part)
        =       &00             ; frame_centre_horizontal_offset (fractional part)
        =       &00, &00        ; frame_centre_vertical_offset (integer part)
        =       &00             ; frame_centre_vertical_offset (fractional part)
        =       &00, &00        ; frame_centre_horizontal_offset (integer part)
        =       &00             ; frame_centre_horizontal_offset (fractional part)
        =       &00, &00        ; frame_centre_vertical_offset (integer part)
        =       &00             ; frame_centre_vertical_offset (fractional part)
        =       &00, &00        ; frame_centre_horizontal_offset (integer part)
        =       &00             ; frame_centre_horizontal_offset (fractional part)
        =       &00, &00        ; frame_centre_vertical_offset (integer part)
        =       &00             ; frame_centre_vertical_offset (fractional part)
        AuxInitEnd

        &       -1      ; terminates the list
      ]

; **************************************************************************
;
;	VideoGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

VideoGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, VideoChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, VideoChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	DisplayStill - Display MPEG still picture
;
; in:	r0 = flags
;

DisplayStill Entry "r0-r2,r11"
 [ NYI
	LDR	r11, CL450_Registers

	MOV	r0, #0
	STR	r0, VideoPreFilling	; don't go sending any play commands!

	MOV	r0, #1			; we're sort of playing!
	STR	r0, VideoSpeedSetting

	MOV	r0, #0			; wait for completion
	ADR	r1, DisplayStillCommand
	BL	SendMacroCommand
 ]
	CLRV
	EXIT

; **************************************************************************
;
;	VideoSendPlay - Start decoder playing

VideoSendPlay Entry "r0,r1"
	MOV	r0, #IR_DecodeStatus	; enable video decoder by setting bit 0 of IR0
	MVN	r1, r0
	BL	UpdateIR
	MOV	r0, #0
	STR	r0, PendingFreezeState	; should be unfrozen
	MOV	r0, #1
	STR	r0, FreezeUpdate	; need an update
 [ CountUnderruns
	LDR	r0, UnderrunIRQState
	TEQ	r0, #0			; if not enabled the IRQ already
	MOVEQ	r0, #1			; then enable it next active field
	STR	r0, UnderrunIRQState
 ]
	EXIT

; **************************************************************************
;
;	VideoSendPause - Pause video decoder

VideoSendPause Entry "r0,r1"
	MOV	r0, #0		; disable video decoder by clearing bit 0 of IR0
	MVN	r1, #IR_DecodeStatus
	BL	UpdateIR
	MOV	r0, #1
	STR	r0, PendingFreezeState	; should be frozen
	STR	r0, FreezeUpdate	; need an update
	EXIT

; **************************************************************************
;
;	FindPoduleNumber
;
; in:	-
;
; out:  r3 = podule number, if VC, otherwise corrupted
;	All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
	SWI	XPodule_ReturnNumber		; find out number of podules
	BVS	%FT90

	SUB	r1, r0, #1			; maximum podule number
	ADR	r0, PoduleVariableName
	BL	ReadNumericVariable
	BVS	%FT05

	MOV	r3, r0				; copy value into r3
	BL	ReadProductType			; get card type anyway, so we can tell whether to use Japanese DAC sound
	B	%FT20

PoduleVariableName
	=	"MPEG2$PoduleNumber", 0
	ALIGN

05
	MOV	r3, r1				; r3 = max podule number
10
	BL	ReadProductType
	BVS	%FT15
	LDR	lr, =ProdType_STB1_MPEG2	; check for MPEG 2 podule for STB 1
	TEQ	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2	; or for STB2/2
	TEQNE	r0, lr
	BEQ	%FT20
15
	SUBS	r3, r3, #1
	BPL	%BT10
	ADRL	r0, NoPoduleError
	SETV
90
	STR	r0, [sp]
	EXIT

	LTORG

; It's this podule

20
	STR	r0, CardProductType
  [ FastPoduleAccess
	MOV	r0, #3			; set access type 'C'
  |
	MOV	r0, #1			; set access type 'A'
  ]
	SWI	XPodule_SetSpeed
	STRVS	r0, [sp]
	EXIT

; ReadProductType
;
; in: r3 = podule
; out: r0 = type
; Corrupts PoduleHeaderBuffer

ReadProductType Entry "r2"
	ADR	r2, PoduleHeaderBuffer
	SWI	XPodule_ReadHeader
	MOVVS	r0, #-1
	EXIT	VS

	LDRB	r0, [r2, #3]
	LDRB	r2, [r2, #4]
	ORR	r0, r0, r2, LSL #8
	EXIT

xdebug  SETL    {FALSE}

; **************************************************************************
;
;	ReadNumericVariable - Read numeric value of variable
;
; in:	r0 -> variable name
;	r1 = maximum value of variable
;
; out:	r0 = value of variable if V=0, else -> error ptr
;	Corrupts PoduleHeaderBuffer
;

ReadNumericVariable Entry "r1-r4"
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	EXIT	VS

	MOV	lr, #0
	STRB	lr, [r1, r2]			; terminate string

	LDR	r2, [sp, #0*4]			; reload maximum value
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	MOVVC	r0, r2				; if no error, put value in r0
	EXIT

; **************************************************************************
;
;	InitL64002 - Initialise L64002
;
;

InitL64002 Entry "r0-r2,r11"
        MOV	r0, #19
	SWI	XOS_Byte			; wait for vsync, to minimize screen disruption (hopefully)

	MOV	r1, #0
	MVN	r2, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset	; clear bit ie reset L64002 + FIFO
	BL	UpdateControlRegister

 [ HoldResetFor10ms
	SWI	XOS_ReadMonotonicTime
	ADD	r1, r0, #2
01
	SWI	XOS_ReadMonotonicTime
	TEQ	r0, r1
	BNE	%BT01
 ]

	MOV	r1, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset
	MVN	r2, r1				; deassert reset on FIFO + L64002
	BL	UpdateControlRegister

	LDR	r11, L64002_Registers
	ADRL	r0, SetupData
	ADRL	r1, SetupDataEnd
02
	LDRB	r2, [r0], #1			; register (group) number
	LDRB	lr, [r0], #1			; value
	STRB	lr, [r11, r2, LSL #L64002_Register_Address_Shift]
	CMP	r0, r1
	BCC	%BT02

; now program Audio Output Register, taking into account the card type
; STB2_MPEG2 needs

	LDR	r0, CardProductType
	LDR	lr, =ProdType_STB2_MPEG2
	TEQ	r0, lr
	MOVEQ	r0, #AudioModeControl_DACsAreJap	; if STB2/2, DACs are Japanese type
	MOVNE	r0, #AudioModeControl_DACsAreI2S	; else normal
	WriteRegI r0, AudioModeControl, lr

; now try to read variable which sets VideoOutputModeControl

	ADR	r0, VideoOutputVarName
	MOV	r1, #&FF
	BL	ReadNumericVariable
	MOVVS	r0, #&52			; default to proper value for master mode
	WriteRegI r0, VideoOutputModeControl, lr

; now set up General register and FIFO destination appropriate to the stream type

	LDR	lr, VideoInputType
	TEQ	lr, #0
	BEQ	%FT10			; if field not present, or if type unknown, do normal behaviour
	CMP	lr, #VideoInputType_SystemOrProgramStream
	BHI	%FT10			; type we haven't come across, so use default behaviour
	ADR	r0, %FT05
	LDRB	r0, [r0, lr]
	B	%FT15

	LTORG

05
	=	&00			; should never be used
	=	General_ParallelInput :OR: General_AVElementary
	=	General_ParallelInput :OR: General_AVPESPackets
	=	General_ParallelInput :OR: General_SystemStream
	ALIGN

VideoOutputVarName
	=	"MPEG2$VideoOutputMode", 0
	ALIGN

10
	LDR	r0, VideoStreamFlags
	TST	r0, #StreamFlags_PassThroughToVideo
	MOVEQ	r0, #General_ParallelInput :OR: General_AVPESPackets
	MOVNE	r0, #General_ParallelInput :OR: General_SystemStream	; select system stream mode
15
	DReg	r0, "Setting register 5 to "
	ORR	r1, r0, #General_ResetBuffersAndFIFOs
	WriteReg r1, General		; set up mode, and reset system buffers and data FIFOs in L64002
	WriteReg r0, General		; unreset FIFOs

	MVN	r2, #MPEG2PoduleControl_SystemNotSeparate		; AND mask
	TEQ	r0, #General_ParallelInput :OR: General_SystemStream	; if system stream
	ADREQ	r1, AudioSystemInfoStructure				; then system buffer for video is audio system buffer
	ADRNE	r1, VideoSystemInfoStructure				; else system buffer for video is video system buffer
	STR	r1, VideoInfoStructure+SI_SISPtr
	MVNEQ	r1, r2							; then feed fifo to audio input
	MOVNE	r1, #0							; else feed to video input
	BL	UpdateControlRegister					; route FIFO through to appropriate place

 [ ClearFrameBuffers
	DRAMFill &038600, &65400, 0, r0, r1, r2		; fill first luma frame with zero
;	DRAMFill &09DA00, &32A00, 0, r0, r1, r2		; fill first chroma frames with 0 (green)
	DRAMFill &09DA00, &32A00, &80, r0, r1, r2	; fill first chroma frames with &80 (black)
	DRAMCopyB &038600, &0D0400, &65400, r0, r1	; copy first luma to second
	DRAMCopyB &09DA00, &135800, &32A00, r0, r1	; copy first chroma to second (can't do this at same time as luma, cos
							; DRAM transfers are limited to 64K words)
	DRAMCopyB &038600, &168200, &65400, r0, r1	; copy first luma to third
	DRAMCopyB &09DA00, &1CD600, &32A00, r0, r1	; copy first chroma to third
	B	%FT20
	LTORG
20
 ]

; now enable channel buffers

	MOV	r0, #&80
	WriteReg r0, Status0

	MOV	r0, #352
	STR	r0, CurrentHorizontalSize
	MOV	r0, #288
	STR	r0, CurrentVerticalSize
	MOV	r0, #0
	STR	r0, CurrentTVFormat
 [ CheckAspectRatio
	MOV	r0, #2		; 4:3
	STR	r0, CurrentAspectRatio
 ]

; now read addresses of various buffer registers

	ReadRegI r0, VideoChannelBufferStart0
	ReadRegI r1, VideoChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, VideoChannelBufferEnd0
	ReadRegI lr, VideoChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, VideoInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, VideoChannelBufferSize

	ReadRegI r0, AudioChannelBufferStart0
	ReadRegI r1, AudioChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, AudioChannelBufferEnd0
	ReadRegI lr, AudioChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, AudioInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, AudioChannelBufferSize

	ReadRegI r0, VideoPESBufferStart0
	ReadRegI r1, VideoPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, VideoSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, VideoSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, VideoSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, VideoSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, VideoPESBufferEnd0
	ReadRegI r1, VideoPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferEnd

	ReadRegI r0, AudioPESBufferStart0
	ReadRegI r1, AudioPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, AudioSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, AudioPESBufferEnd0
	ReadRegI r1, AudioPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferEnd

	MOV	r0, #0
	MOV	r1, #0
	BL	WriteSCR			; set SCR to zero

	CLRV
	EXIT

	LTORG

xdebug  SETL    {FALSE}

; **************************************************************************

 [ Pulldown
VideoEnabledIRQs * IR_UserDataFIFOReady :OR: IR_PictureStartCodeDetect :OR: IR_BeginVerticalBlank :OR: IR_BeginActiveVideo
 |
VideoEnabledIRQs * IR_PictureStartCodeDetect :OR: IR_BeginVerticalBlank :OR: IR_BeginActiveVideo
 ]
 [ CountUnderruns
VideoIRQsToDisable * VideoEnabledIRQs :OR: IR_VideoChannelBufferUnderflow
 |
VideoIRQsToDisable * VideoEnabledIRQs
 ]
AudioEnabledIRQs * IR_AudioSyncCodeDetect
CommonEnabledIRQs * IR_SCRStatus

VideoClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #TickerV
	ADRL	r1, VideoTickerV
	MOV	r2, wp
	SWI	XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:VideoEnabledIRQs
	BL	UpdateIR

	BL	ClaimFIQs

	MOV	r0, #1
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #TickerV
	ADRL	r1, AudioTickerV
	MOV	r2, wp
	SWI	XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:AudioEnabledIRQs
	BL	UpdateIR

	MOV	r0, #1
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT

CommonClaimInterruptVectors Entry "r0-r4,r11"
	LDR	r0, CommonInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

	MOV	r0, #IOMD_Podule_DevNo
	ADR	r1, MPEGIRQHandler
	MOV	r2, wp
	LDR	r3, Podule_ControlStatus1
	MOV	r4, #MPEG2PoduleStatus1_IRQActive
	SWI	XOS_ClaimDeviceVector
	EXIT	VS

	MOV	r1, #MPEG2PoduleControl_L64002IRQEnable
	MVN	r2, r1
	BL	UpdateControlRegister		; turn on IRQs

	MOV	r0, #IOC
	MOV	r1, pc
	TEQP	pc, #SVC_mode + I_bit		; disable IRQs while modifying mask B
	LDRB	r2, [r0, #IOCIRQMSKB]
	ORR	r2, r2, #podule_IRQ_bit
	STRB	r2, [r0, #IOCIRQMSKB]
	TEQP	r1, #0

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

	MOV	r0, #1
	STR	r0, CommonInterruptVectorsClaimed
	CLRV
	EXIT

VideoReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	BL	ReleaseFIQs

	LDR	r11, L64002_Registers
	LDR	r0, =VideoIRQsToDisable		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

	MOV	r0, #TickerV
	ADRL	r1, VideoTickerV
	MOV	r2, wp
	SWI	XOS_Release

	ADRL	r0, VideoTickerVCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	LDR	r11, L64002_Registers
	LDR	r0, =AudioEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

	MOV	r0, #TickerV
	ADRL	r1, AudioTickerV
	MOV	r2, wp
	SWI	XOS_Release

	ADRL	r0, AudioTickerVCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT


CommonReleaseInterruptVectors Entry "r0-r4, r11"
	LDR	r0, CommonInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	LDR	r11, L64002_Registers
	MOV	r0, #CommonEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

	MOV	r1, #0
;	 MVN	 r2, #MPEG2PoduleControl_L64002IRQEnable :OR: MPEG2PoduleControl_NotL64002Reset
	MVN	r2, #MPEG2PoduleControl_L64002IRQEnable
	BL	UpdateControlRegister		; turn off IRQs but don't reset L64002

	MOV	r0, #IOMD_Podule_DevNo
	ADR	r1, MPEGIRQHandler
	MOV	r2, wp
	LDR	r3, Podule_ControlStatus1
	MOV	r4, #MPEG2PoduleStatus1_IRQActive
	SWI	XOS_ReleaseDeviceVector

	MOV	r0, #0
	STR	r0, CommonInterruptVectorsClaimed
	EXIT

ClaimFIQs Entry "r0-r3"
	MOV	r1, #Service_ClaimFIQ
	SWI	XOS_ServiceCall

; enable FIQ on card, but don't enable it in IOMD
; (we only enable it in IOMD when we have data to send, and the FIQ process disables it in IOMD when there's no data left -
; since these are just write operations, rather than read-modify-write it simplifies things, rather than have the foreground
; disable FIQs while modifying the control register)

	MOV	r1, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	MVN	r2, r1				; enable FIFO FIQ on card
	BL	UpdateControlRegister

	LDR	r0, FIQLDRPCInstr
	ADRL	r1, FIQCodeStart
	MOV	r2, #0
	ADR	r3, FIQSpaceStart
	STMIA	r3, {r0-r2}			; set up LDR PC instruction at &1C and PC to load, zero FIQAmountSent

	ADR	r0, FIQSlotSpace
	STR	r0, FIQSlotWritePtr		; point FIQ slot write ptr at start of slots

 [ Save1stFIQPacket
	ADR	r0, FIQWorkspacePtr
	STR	wp, [r0]			; need to reference our workspace
 ]

; zero out all the FIQ data slots

	ADR	r0, FIQSlotSpace
	MOV	r1, #0
	MOV	r2, #FIQSlotSpaceSize
10
	STR	r1, [r0], #4
	SUBS	r2, r2, #4
	BNE	%BT10

	LDR	r2, FIFO_32_Bit_Write
	LDR	r3, FIFO_8_Bit_Write

	MOV	r0, pc
	BIC	r1, r0, #3
	ORR	r1, r1, #FIQ_mode
	TEQP	r1, #0				; enter FIQ mode
	NOP

	ADR	r8, FIQSlotSpace		; point at first slot
	MOV	r9, r2				; r9 -> 32-bit FIFO writes
	MOV	r10, r3				; r10 -> 8-bit FIFO writes
	ADR	r13, FIQStackEnd		; and set up FIQ stack pointer

	TEQP	r0, #0				; go back to SVC mode
	NOP

	EXIT

FIQLDRPCInstr
	LDR	pc, %FT95
95

ReleaseFIQs Entry "r0-r2"
        MOV     r0, #0
        MOV     r1, #IOC
        STRB    r0, [r1, #IOCFIQMSK]            ; disable FIQs in IOMD

	MOV	r1, #0
	MVN	r2, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	BL	UpdateControlRegister		; disable FIFO FIQ on card

	MOV	r1, #Service_ReleaseFIQ
	SWI	XOS_ServiceCall
	EXIT

; **************************************************************************
;
;	InitSAA7167 - Initialise IIC D-to-A converter/mixer chip

InitSAA7167 Entry "r0-r2"
	LDR	r0, CardProductType
	LDR	lr, =ProdType_STB1_MPEG2
	TEQ	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2
	TEQNE	r0, lr
	EXIT	EQ				; if either of those, the 7167 is not on the card, so exit

; must be old-style card

	MOV	r0, #IICAddress_SAA7167
	ADR	r1, SAA7167InitBlock0
	MOV	r2, #2
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

; Initially we only program register 0 in this device, which has the following bits:-

; Bits 1..0: FMTC1/FMTC0 = 10 => YUV 2:1:1 CCIR656
; Bit 2:     KINV=1 => EXTKEY= LOW for Mprg, HIGH for Computer
; Bit 3:     KEN=1 Key connected to ED0
; Bit 4:     DRP=0 => 2's Complement UV data
; Bits 7..5: KMOD2/1/0 = 000 => Use EXTernal KEY

SAA7167InitBlock0
	=	0, 2_00001110

; **************************************************************************
;
;	MPEGIRQHandler - Handler for IRQs off MPEG card
;
; in:	-
; out:  r0-r3 may be corrupted

MPEGIRQHandler Entry "r11"
	LDR	r3, Podule_ControlStatus1
	LDRB	r3, [r3]

	TST	r3, #MPEG2PoduleStatus1_NotL64002Interrupt
	BLEQ	L64002IRQ
 [ {FALSE}
	TST	r3, #MPEG2PoduleStatus1_FIFONotEmpty
	BLEQ	FIFOIRQ

KillIRQExit
	TEQP	pc, #SVC_mode + I_bit
	MOV	r0, r0
	Push	"lr"
	BL	ReleaseIRQVector
	Pull	"lr"
	TEQP	pc, #IRQ_mode + I_bit
	MOV	r0, r0
 ]
	EXIT

	LTORG

; **************************************************************************
;
;	L64002IRQ - Handler for L64002 IRQs
;
; in:	-
; out:  r0-r2, r11 may be corrupted

L64002IRQ Entry "r3"
	LDR	r11, L64002_Registers
	ReadReg	r0, IR0				; this clears all interrupts in Status 0
	ReadReg r1, IR1				; ditto for Status 1
	ORR	r0, r0, r1, LSL #8		; form 1 word with all IRQs in
	LDR	r1, IRSoftCopy
	ORR	r1, r1, #1			; video enable bit doesn't count
	BICS	r0, r0, r1			; only look at bits that are actually enabled
	EXIT	EQ				; [none, so exit]
	ADR	r1, IRQCounts
	MOV	r3, #0
10
	MOVS	r0, r0, LSR #1
	LDRCS	r2, [r1, r3, LSL #2]
	ADDCS	r2, r2, #1
	STRCS	r2, [r1, r3, LSL #2]
	BLCS	DespatchIRQ
	ADD	r3, r3, #1
	BNE	%BT10
	EXIT

DespatchIRQ Entry "r0-r3"
	ADR	r0, IRQDespatchTable
	LDR	r1, [r0, r3, LSL #2]
	MOV	lr, pc
	ADD	pc, r0, r1
	EXITS

IRQDespatchTable
	&	IgnoreIRQ - IRQDespatchTable		; Decode Status
 [ Pulldown
        &       DataFIFOReadyIRQ - IRQDespatchTable     ; Data FIFO Ready
 |
	&	IgnoreIRQ - IRQDespatchTable		; Data FIFO Ready
 ]
	&	IgnoreIRQ - IRQDespatchTable		; Decode Error
	&	AudioSyncCodeIRQ - IRQDespatchTable	; Audio Sync Code detected
	&	PictureStartCodeIRQ - IRQDespatchTable  ; Picture Start Code detect
	&	SCRStatusIRQ - IRQDespatchTable		; System Clock Reference Status
	&	IgnoreIRQ - IRQDespatchTable		; Pack Data Ready
	&	IgnoreIRQ - IRQDespatchTable		; DRAM Transfer Done
	&	IgnoreIRQ - IRQDespatchTable		; Audio Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable		; Video Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable		; Audio Channel Buffer Underflow
 [ CountUnderruns
	&	VideoChannelUnderrunIRQ - IRQDespatchTable ; Video Channel Buffer Underflow
 |
	&	IgnoreIRQ - IRQDespatchTable		; Video Channel Buffer Underflow
 ]
	&	BeginActiveVideo - IRQDespatchTable	; Begin Active Video
	&	BeginVerticalBlank - IRQDespatchTable	; Begin Vertical Blank
	&	IgnoreIRQ - IRQDespatchTable		; Audio PES Data Ready (don't use this as not all data is there
							;  when IRQ happens)
	&	IgnoreIRQ - IRQDespatchTable		; Video PES Data Ready

IgnoreIRQ
	MOV	pc, lr


; Data FIFO Ready IRQ
; We use this to read the Aux and User Data FIFOs
; r0-r3 can be junked

 [ Pulldown
DataFIFOReadyIRQ Entry "r8"

	BL	ProcessAuxFIFO			; ensure we have updated picture type before reordering User Data
      [ Captions
        BL      ProcessUserDataFIFO
      ]
	EXIT
 ]


; Audio Sync Code Detect IRQ
; r0-r3 can be junked

AudioSyncCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working audio sync code read ptr, so read that instead

	ReadRegI r0, AudioSyncCodeRead0
	ReadRegI lr, AudioSyncCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, AudioSyncCodeRead2
	ORR	r0, r0, lr, LSL #16

 |
; read the Audio Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, AudioInfoStructure
	BL	CheckSystemBuffer		; read any audio system buffer data

	BL	ProcessAudioReadPtr		; compare audio channel buffer read ptr in r0 with audio PTS list entries

	ReadRegI r0, AudioParameter0
	AND	r1, r0, #3 :SHL: 2		; extract bits which say stereo, joint stereo, dual mono or mono
	MOV	r1, r1, LSR #2
	STR	r1, AudioChannelMode
	ReadRegI r1, AudioParameter1
	AND	r0, r0, #3			; get bottom 2 bits of audio rate
	TST	r1, #&80			; if RATE bit set
	ORRNE	r0, r0, #4			; then set bit 2 of combined rate
	STR	r0, AudioSampleRate
 [ SlowMotionSupport
	LDR	r1, AudioSpeedSetting		; read speed setting
	CMP	r1, #2				; if negative (prefilling) or 0 or 1 then use speed factor 1
	SUBGE	r1, r1, #1			; else advance table entry offset by 8 words for each factor above 1
	ORRGE	r0, r0, r1, LSL #3
 ]
	ADR	r1, SampleRateProgTable
	LDR	r1, [r1, r0, LSL #2]		; extract 3 bytes of registers
	WriteRegI r1, AudioFrequencyNMOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNMOSCNOSC1, lr
	EXIT

	MACRO
	SampleRateInfo	$n, $nm
	=	($nm) :AND: &FF								; Register 6.49
	=	($n) :AND: &FF								; Register 6.50
	=	((($nm) :SHR: 8) :AND: 15) :OR: (((($n) :SHR: 8) :AND: 3) :SHL: 4)	; Register 6.51
	=	0									; padding
	MEND

SampleRateProgTable
	SampleRateInfo	98, -1777		; 22.05 kHz
	SampleRateInfo	64, -1061		; 24 kHz
	SampleRateInfo	128, -3247		; 16 kHz
	SampleRateInfo	0, 0
	SampleRateInfo	196, -1679		; 44.1 kHz
	SampleRateInfo	128, -997		; 48 kHz
	SampleRateInfo	256, -3119		; 32 kHz
	SampleRateInfo	0, 0
 [ SlowMotionSupport
	SampleRateInfo	49, -1826		; 22.05 kHz, speed 1/2
	SampleRateInfo	32, -1093		; 24 kHz, speed 1/2
	SampleRateInfo	64, -3311		; 16 kHz, speed 1/2
	SampleRateInfo	0, 0
	SampleRateInfo	98, -1777		; 44.1 kHz, speed 1/2
	SampleRateInfo	64, -1061		; 48 kHz, speed 1/2
	SampleRateInfo	128, -3247		; 32 kHz, speed 1/2
	SampleRateInfo	0, 0
	SampleRateInfo	68, -3835		; 22.05 kHz, speed 1/3
	SampleRateInfo	64, -3311		; 24 kHz, speed 1/3
	SampleRateInfo	49, -3827		; 16 kHz, speed 1/3
	SampleRateInfo	0, 0
	SampleRateInfo	103, -2853		; 44.1 kHz, speed 1/3
	SampleRateInfo	128, -3247		; 48 kHz, speed 1/3
	SampleRateInfo	69, -2660		; 32 kHz, speed 1/3
	SampleRateInfo	0, 0
	SampleRateInfo	49, -3701		; 22.05 kHz, speed 1/4
	SampleRateInfo	16, -1109		; 24 kHz, speed 1/4
	SampleRateInfo	32, -3343		; 16 kHz, speed 1/4
	SampleRateInfo	0, 0
	SampleRateInfo	49, -1826		; 44.1 kHz, speed 1/4
	SampleRateInfo	32, -1093		; 48 kHz, speed 1/4
	SampleRateInfo	64, -3311		; 32 kHz, speed 1/4
	SampleRateInfo	0, 0
	SampleRateInfo	3, -284			; 22.05 kHz, speed 1/5
	SampleRateInfo	46, -3997		; 24 kHz, speed 1/5
	SampleRateInfo	6, -785			; 16 kHz, speed 1/5
	SampleRateInfo	0, 0
	SampleRateInfo	83, -3887		; 44.1 kHz, speed 1/5
	SampleRateInfo	73, -3135		; 48 kHz, speed 1/5
	SampleRateInfo	61, -3960		; 32 kHz, speed 1/5
	SampleRateInfo	0, 0
	SampleRateInfo	34, -3869		; 22.05 kHz, speed 1/6
	SampleRateInfo	32, -3343		; 24 kHz, speed 1/6
	SampleRateInfo	5, -786			; 16 kHz, speed 1/6
	SampleRateInfo	0, 0
	SampleRateInfo	68, -3835		; 44.1 kHz, speed 1/6
	SampleRateInfo	64, -3311		; 48 kHz, speed 1/6
	SampleRateInfo	49, -3827		; 32 kHz, speed 1/6
	SampleRateInfo	0, 0
	SampleRateInfo	14, -1861		; 22.05 kHz, speed 1/7
	SampleRateInfo	21, -2563		; 24 kHz, speed 1/7
	SampleRateInfo	7, -1285		; 16 kHz, speed 1/7
	SampleRateInfo	0, 0
	SampleRateInfo	28, -1847		; 44.1 kHz, speed 1/7
	SampleRateInfo	65, -3934		; 48 kHz, speed 1/7
	SampleRateInfo	7, -639			; 32 kHz, speed 1/7
	SampleRateInfo	0, 0
	SampleRateInfo	16, -2433		; 22.05 kHz, speed 1/8
	SampleRateInfo	8, -1117		; 24 kHz, speed 1/8
	SampleRateInfo	16, -3359		; 16 kHz, speed 1/8
	SampleRateInfo	0, 0
	SampleRateInfo	49, -3701		; 44.1 kHz, speed 1/8
	SampleRateInfo	16, -1109		; 48 kHz, speed 1/8
	SampleRateInfo	32, -3343		; 32 kHz, speed 1/8
	SampleRateInfo	0, 0
 ]


; Picture Start Code IRQ
; We use this to read the Aux FIFO and check the video system buffer
; r0-r3 can be junked

PictureStartCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working picture start code read ptr, so read that instead
	ReadRegI r0, PictureStartCodeRead0
	ReadRegI lr, PictureStartCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PictureStartCodeRead2
	ORR	r0, r0, lr, LSL #16
 |
; read the Video Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, VideoInfoStructure
	BL	CheckSystemBuffer		; read any video system buffer data

	BL	ProcessAuxFIFO			; ensure we have updated picture type before checking for PTS being valid
                                                ; even if we've read this on the Data FIFO Ready IRQ, some more data may have arrived since
      [ Captions :LAND: :LNOT: Pulldown
        BL      ProcessUserDataFIFO             ; With Pulldown's enhanced Aux FIFO code, this can be read on the Data FIFO Ready interrupt instead
      ]

	BL	ProcessVideoReadPtr
	LDR	lr, FirstItemReceived
	TEQ	lr, #0				; if not received picture or sequence yet
	MOVEQ	lr, #2
	STREQ	lr, FirstItemReceived		; then indicate picture first
	EXIT


ProcessAuxFIFO Entry "r0-r3"
10
	ReadReg r0, Status0			; determine if Aux FIFO has any data in it
	AND	r1, r0, #L64002_Status0_ADFSBits
	TEQ	r1, #L64002_Status0_AuxDataFIFOEmpty ; if no data
	EXIT	EQ				; then exit

	AND	r0, r0, #L64002_Status0_AuxIDBits
	MOV	r0, r0, LSR #L64002_Status0_AuxIDShift
 [ Pulldown
        ; New code that checks buffer fullness before each read, and also deals with extension data.
        ; It uses a simple coroutine system to achieve this, since the state machine would otherwise become rather complex.

        LDR     r1, AuxData_LastKnownLayer
        STR     r0, AuxData_LastKnownLayer      ; store new layer, whatever happens
        STR     sp, AuxData_ExtSP
        TEQ     r0, r1
        ADRNE   sp, AuxData_StackTop            ; if layer ID has changed, reinitialise coroutine sp
        BNE     ProcessAuxFIFO_NewLayer         ; and go back to start of coroutine
        ReadRegI r0, AuxiliaryDataFIFO          ; else read a byte from the auxiliary data FIFO,
        LDR     sp, AuxData_CoSP                ; restore the coroutine sp
        LDR     pc, AuxData_CoPC                ; and resume the coroutine at the point where we left off

        ; Either way, the coroutine eventually BL's back here:
ProcessAuxFIFO_GetByte
        STR     lr, AuxData_CoPC
        STR     sp, AuxData_CoSP
        LDR     sp, AuxData_ExtSP
        B       %BT10


        ; Now the coroutine code.

ProcessAuxFIFO_NewLayer
; Entry: r0 = layer ID
;        wp -> module workspace
;        sp -> top of a small fixed-size stack
; Does not exit (except when calls to ProcessAuxFIFO_GetByte fail to return)
; r4-r12 must be preserved between calls to ProcessAuxFIFO_GetByte
; Calls to ProcessAuxFIFO_GetByte return next byte in r0, preserve wp and sp and corrupt all other registers
        ADR     r1, %FT01
        CMP     r0, #(%FT02 - %FT01) :SHR: 2
        ADDLO   pc, r1, r0, LSL #2
        B       ProcessAuxFIFO_Unknown
01      B       ProcessAuxFIFO_SequenceHeader
        B       ProcessAuxFIFO_GroupOfPicturesHeader
        B       ProcessAuxFIFO_PictureHeader
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_Extension
02

ProcessAuxFIFO_Extension
        BL      ProcessAuxFIFO_GetByte      ; extension ID is determined by first data byte
; r0 = extension ID
        ADR     r1, %FT01
        CMP     r0, #(%FT02 - %FT01) :SHR: 2
        ADDLO   pc, r1, r0, LSL #2
        B       ProcessAuxFIFO_Unknown
01      B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_SequenceExtension
        B       ProcessAuxFIFO_SequenceDisplayExtension
        B       ProcessAuxFIFO_QuantMatrixExtension
        B       ProcessAuxFIFO_CopyrightExtension
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_Unknown
        B       ProcessAuxFIFO_PictureDisplayExtension
        B       ProcessAuxFIFO_PictureCodingExtension
02

ProcessAuxFIFO_Unknown
; General handling of unrecognised data: loop indefinitely (ie until layer ID changes)
        BL      ProcessAuxFIFO_GetByte
        B       ProcessAuxFIFO_Unknown

ProcessAuxFIFO_GetMultipleBytes
; Entry: r1 -> buffer to place auxiliary FIFO bytes into
;        r2 -> byte above top of buffer
; Exit:  r0 = last byte read
;        r1 = r2 on entry
        Entry
01
        Push    "r1, r2"
        BL      ProcessAuxFIFO_GetByte
        Pull    "r1, r2"
        STRB    r0, [r1], #1
        CMP     r1, r2
        BLO     %BT01
        EXIT


ProcessAuxFIFO_SequenceHeader                   ; L64002 spec calls this "Video Sequence"
        ADRL    r1, VideoSequenceData
        ADRL    r2, VideoSequenceDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        BL      ProcessVideoSequenceData        ; special actions to carry out as soon as the sequence header is received
        B       ProcessAuxFIFO_Unknown          ; discard any trailing data

ProcessAuxFIFO_SequenceExtension
        STRB    r0, SequenceExtension_ExtensionID
        ADRL    r1, SequenceExtension_ProfileAndLevel
        ADRL    r2, SequenceExtensionDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        B       ProcessAuxFIFO_Extension        ; get next extension block

ProcessAuxFIFO_SequenceDisplayExtension         ; L64002 spec calls this just "Display Extension"
        STRB    r0, DisplayExtension_ExtensionID
        BL      ProcessAuxFIFO_GetByte
        STRB    r0, DisplayExtension_Misc
        TST     r0, #1                                   ; if colour_description is set
        ADRNEL  r1, DisplayExtension_ColourPrimaries     ; then colour_primaries, transfer_characteristics and matrix_coefficients fields are present
        ADREQL  r1, DisplayExtension_HorizontalDimension ; else skip to horizontal_dimension
        ADRL    r2, DisplayExtensionDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        B       ProcessAuxFIFO_Extension        ; get next extension block

ProcessAuxFIFO_GroupOfPicturesHeader
        ADRL    r1, GroupOfPicturesData
        ADRL    r2, GroupOfPicturesDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        B       ProcessAuxFIFO_Unknown          ; discard any trailing data

ProcessAuxFIFO_PictureHeader
        ADRL    r1, PictureData
        ADRL    r2, PictureDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        B       ProcessAuxFIFO_Unknown          ; discard any trailing data

ProcessAuxFIFO_PictureCodingExtension
        STRB    r0, PictureCodingExtension_ExtensionID
        ADRL    r1, PictureCodingExtension_ForwardHorizontalFCode
        ADRL    r2, PictureCodingExtension_Misc
        BL      ProcessAuxFIFO_GetMultipleBytes
        TST     r0, #1                          ; if composite_display_flag is set,
        ADRNEL  r2, PictureCodingExtensionDataEnd
        BLNE    ProcessAuxFIFO_GetMultipleBytes ; then get five extra fields in three bytes
        BL      ProcessPictureCodingExtensionData ; schedule information for use in calculating pulldown status
        B       ProcessAuxFIFO_Extension        ; get next extension block

ProcessAuxFIFO_QuantMatrixExtension
        STRB    r0, QuantMatrixExtension_ExtensionID
        B       ProcessAuxFIFO_Extension        ; no further information is placed in auxiliary FIFO for this extension block

ProcessAuxFIFO_CopyrightExtension
        STRB    r0, CopyrightExtension_ExtensionID
        ADRL    r1, CopyrightExtension_CopyrightFlag
        ADRL    r2, CopyrightExtensionDataEnd
        BL      ProcessAuxFIFO_GetMultipleBytes
        B       ProcessAuxFIFO_Extension        ; get next extension block

ProcessAuxFIFO_PictureDisplayExtension          ; L64002 spec calls this "Pan and Scan Extension"
        STRB    r0, PanAndScanExtension_ExtensionID
        MOV     r3, #1                          ; number of frame_centre_offsets defaults to 1
        LDRB    r0, SequenceExtension_ProgressiveSequence
        TEQ     r0, #1
        BNE     %FT01
        LDRB    r0, PictureCodingExtension_RepeatFirstField
        TEQ     r0, #1
        BNE     %FT10                           ; a single progressive frame => r3 = 1
        LDRB    r0, PictureCodingExtension_TopFieldFirst
        TEQ     r0, #1
        MOVNE   r3, #2                          ; two progressive frames => r3 = 2
        MOVEQ   r3, #3                          ; three progressive frames => r3 = 3
        B       %FT10
01      LDRB    r0, PictureCodingExtension_PictureStructure
        TEQ     r0, #3
        BNE     %FT10                           ; a single field => r3 = 1
        LDRB    r0, PictureCodingExtension_RepeatFirstField
        TEQ     r0, #1
        MOVNE   r3, #2                          ; a normal interlaced frame with two fields => r3 = 2
        MOVEQ   r3, #3                          ; an interlaced frame with pulldown to make three fields => r3 = 3
        ; drop through...
10      ADRL    r1, PanAndScanExtension_Field1_HorizontalOffsetInteger
20      ADD     r2, r1, #PanAndScanExtension_Field2_HorizontalOffsetInteger - PanAndScanExtension_Field1_HorizontalOffsetInteger
        Push    "r3"
        BL      ProcessAuxFIFO_GetMultipleBytes
        Pull    "r3"
        SUBS    r3, r3, #1
        BNE     %BT20                           ; get as many frame_centre_offset blocks as are needed
        B       ProcessAuxFIFO_Extension        ; get next extension block

 |
; The original (rather simpler) aux data FIFO parsing code...

	CMP	r0, #3
	BCC	%FT20
	ReadRegI r0, AuxiliaryDataFIFO		; not recognised, so read a byte from FIFO
	B	%BT10				; and loop

20
	ADR	r1, AuxInfoTable
	LDR	r1, [r1, r0, LSL #2]
	ADD	r2, wp, r1, LSR #8		; r2 -> area to dump info to
	AND	r1, r1, #&FF			; r1 = length of data
30
	ReadRegI lr, AuxiliaryDataFIFO
	STRB	lr, [r2], #1
	SUBS	r1, r1, #1
	BNE	%BT30

	TEQ	r0, #0				; is it sequence data?
	BLEQ    ProcessVideoSequenceData
	B	%BT10

AuxInfoTable
	&	12 :OR: ((:INDEX: VideoSequenceData)   :SHL: 8)
	&	6  :OR: ((:INDEX: GroupOfPicturesData) :SHL: 8)
	&	5  :OR: ((:INDEX: PictureData)	       :SHL: 8)

 ] ; Pulldown

ProcessVideoSequenceData
        Entry
	LDR	lr, FirstItemReceived
	TEQ	lr, #0				; if not received picture or sequence yet
	MOVEQ	lr, #1
	STREQ	lr, FirstItemReceived		; then indicate sequence first

	LDRB	r0, VideoSequence_VBVBufferSize +0
	LDRB	r1, VideoSequence_VBVBufferSize +1
	ORR	r0, r1, r0, LSL #8		; VBV buffer size in units of 16K bits, ie 2K bytes
	MOV	r0, r0, LSL #11			; convert to bytes
	LDR	r1, VideoChannelBufferSize	; but don't exceed video channel buffer size
	CMP	r0, r1
	MOVHI	r0, r1
	LDR     r1, VideoVBVSize  ; compare min of channel size with sequence buffer size
	CMP     r0, r1
	MOVHI   r0, r1  ; move the min into R0 and store as VBVSize
	STR	r0, VideoVBVSize

	LDRB	r0, VideoSequence_HorizontalSize +0	; *high* byte of horiz size
	LDRB	lr, VideoSequence_HorizontalSize +1	; *low* byte of horiz size
	ORR	r0, lr, r0, LSL #8			; r0 = xres

	LDRB	r1, VideoSequence_VerticalSize +0	; high byte of vertical size
	LDRB	lr, VideoSequence_VerticalSize +1	; low byte of vertical size
	ORR	r1, lr, r1, LSL #8			; r1 = yres

 [ CheckAspectRatio
	LDRB	r3, VideoSequence_PelAspectRatio
 ]

	LDR	lr, CardProductType			; check what type of card it is
	CMP	lr, #-1					; if unknown, then assume it's my vanilla card
	BEQ	%FT40					; so work out PAL/NTSC from frame rate

	LDR	lr, VideoStructureFlags			; else check video structure flags
	TST	lr, #VideoStructureFlags_NTSC		; if requesting NTSC output
	MOVNE	r2, #1					; then use it
	MOVEQ	r2, #0					; else use PAL
	B	%FT50

; For now set up the video output mode as per the source material wrt PAL/NTSC
; cos I know my TV can do both.

40
	LDRB	r2, VideoSequence_PictureRate		; r2 = picture rate index
	CMP	r2, #PictureRate_25000			; if more than 25Hz
	MOVHI	r2, #1					; indicate NTSC
	MOVLS	r2, #0					; else indicate PAL
50
	BL	SetupScreenMode

	LDR	lr, SequenceCount
	SUBS	lr, lr, #1				; decrement sequence count
	STRCS	lr, SequenceCount			; if >= 0, store back
	EXIT	HI					; only start decoded field count once we get to zero

	LDR	lr, DecodedFieldCount
	CMP	lr, #-1					; if waiting for good sequence data
	MOVEQ	lr, #0					; then set count to 0
	STREQ	lr, DecodedFieldCount
	EXIT						; go back for more data from Aux FIFO


 [ Captions
ProcessUserDataFIFO Entry "r0-r3"
10
        ReadReg r0, Status1                     ; determine if user data FIFO has any data in it
        AND     r1, r0, #L64002_Status1_UDFSBits
        TEQ     r1, #L64002_Status1_UserDataFIFOEmpty ; if no data
        EXIT    EQ                              ; then exit

        ReadRegI r1, UserDataFIFO               ; remove byte from FIFO
        AND     r0, r0, #L64002_Status1_UDIDBits
        TEQ     r0, #L64002_Status1_UDID_Picture
        BNE     %BT10                           ; if not the layer we're interested in, then loop

        LDR     r2, UserData_State
        MVNS    r14, r2, ASR #1                 ; Test r2: C = bit 0, N = NOT (bit 31), Z set if r2 = -1 or -2
        BMI     %FT50                           ; handle dataBytes   (State >= 0)
        BCC     %FT30                           ; handle dataType    (State = -2)
        BEQ     %FT40                           ; handle extDataType (State = -1)
                                                ; drop through and handle dataLength (State = -3)
20
        TEQ     r1, #0                          ; is it null-byte padding?
        BEQ     %BT10                           ; ignore it if so
        ASSERT  (3 :AND: :INDEX: UserData_dataLength) = 0
        ASSERT  (:INDEX: UserData_NBytes = :INDEX: UserData_dataLength + 3)
        ORR     r1, r1, r1, LSL #24             ; in DiviCom format, dataLength == number of data bytes
        STR     r1, UserData_dataLength         ; also initialises dataType and extDataType to 0
        MOV     r0, #0
        STR     r0, UserData_dataBytes          ; initialise dataBytes to 0
        MOV     r2, #-2
        STR     r2, UserData_State              ; look for dataType next
        B       %BT10
30
        STRB    r1, UserData_dataType
        TEQ     r1, #&FF                        ; is there an extDataType field?
        MOVEQ   r2, #-1                         ; look for it if so
        MOVNE   r2, #0                          ; else look for first data byte
        STR     r2, UserData_State
        B       %BT10
40
        STRB    r1, UserData_extDataType
        MOV     r2, #0
        STR     r2, UserData_State              ; look for first data byte next
        B       %BT10
50
        CMP     r2, #4
        ADRLO   r0, UserData_dataBytes
        STRLOB  r1, [r0, r2]                    ; only store the first 4 bytes
        LDRB    r0, UserData_NBytes
        ADD     r2, r2, #1
        TEQ     r2, r0                          ; have we got the whole packet now?
        MOVEQ   r2, #-3                         ; reset state back to the beginning if so
        STR     r2, UserData_State              ; else leave it incremented
        BNE     %BT10                           ; and go back for some more

        ; Now we can safely process the complete packet - start by checking the data type
        LDRB    r0, UserData_dataType
        TEQ     r0, #&09                        ; if not closed captions
        TEQNE   r0, #&0a                        ; or extended data service
        BNE     %BT10                           ; then junk the packet

      [ TrickPlaySupport
        ; If we're in trick play mode, don't output anything
        LDR     lr, TrickPlayMode
        TEQ     lr, #0
        BNE     %BT10
      ]

        LDR     lr, DecodedFieldCount
        CMP     lr, #-2                         ; if screen is still blanked,
        BNE     %BT10                           ; then don't output anything on line 21 either

        ; If an anchor frame, then switch data bytes with data bytes from previous anchor frame
        TEQ     r0, #&09
        ADREQ   r3, UserData_OldCCDataBytes
        ADRNE   r3, UserData_OldEDSDataBytes    ; select appropriate holding buffer for the data type
        LDRB    r1, Picture_PictureCodingType
        TEQ     r1, #1                          ; if an I-picture
        TEQNE   r1, #2                          ; or a P-picture, then swap them
        LDREQ   r1, [r3]
        LDREQ   r2, UserData_dataBytes
        STREQ   r1, UserData_dataBytes
        STREQ   r2, [r3]

        ; Check how many bytes to send
        MOV     r2, #4
        LDRNE   r1, UserData_dataBytes          ; if Z set, r1 already contains this!
        TST     r1, #&7F :SHL: 24
        TSTEQ   r1, #&7F :SHL: 16
        MOVEQ   r2, #2                          ; second two bytes are nulls, so don't send them
        TSTEQ   r1, #&7F :SHL: 8
        TSTEQ   r1, #&7F :SHL: 0
        BEQ     %BT10                           ; don't send anything if all four bytes are nulls

        ; Set up r0 and r1 for the SWI too
        TEQ     r0, #&09                        ; was it captions or extended data? (r0 still contains dataType)
        MOVEQ   r0, #0
        MOVNE   r0, #1
        ADR     r1, UserData_dataBytes
        Push    "r8"
        ADD     r8, r0, #1                      ; handler number is 1 for odd fields, 2 for even fields
        BL      CallHandler
        Pull    "r8"
        B       %BT10                           ; finished with packet
 ]

 [ Pulldown
ProcessPictureCodingExtensionData
        Entry   "r0,r1"
        LDRB    r14, Picture_PictureCodingType
        ReadRegI r0, VideoTrickModes
        AND     r0, r0, #VideoTrickModes_SkipAny
        TEQ     r0, #VideoTrickModes_SkipB      ; if skipping B-pictures
        TEQEQ   r14, #3                         ; and this is a B-picture
        ASSERT  VideoTrickModes_SkipB = 1       ; then flag that we're going to skip this AU
        MOVNE   r0, #0                          ; else flag that we're going to decode it
        ASSERT  :LNOT: AllowSyncOnIFrames       ; this code isn't able to cope properly with skipping anchor frames

        LDRB    r1, PictureCodingExtension_TopFieldFirst
        TEQ     r14, #1                         ; if an I-picture
        TEQNE   r14, #2                         ; or a P-picture
        LDREQB  r14, SequenceExtension_Misc2
        TSTEQ   r14, #1:SHL:7                   ; and low_delay flag is clear
        ADREQL  r14, FirstField_LastAnchorAU
        SWPEQB  r1, r1, [r14]                   ; then swap details with the previous anchor frame

        LDREQB  r14, LastAnchorAUInvalid
        EOREQS  r14, r14, #1                    ; so now EQ => we swapped details AND the details we got were invalid
        STREQB  r14, LastAnchorAUInvalid        ; either validate the new held-over details and leave FuturePU alone (which will make NextPU a 2-field frame)
        TEQNE   r0, #1                          ; or, unless we're skipping this AU (r0 remains set from above),
        STRNEB  r1, FirstField_FuturePU         ; store the new details for FuturePU

        LDRB    r0, EvenOddIndicator
        LDRB    r1, FirstField_NextPU
        Debug   pulldown, "New AU; EvenOddIndicator, FirstField_NextPU =", r0, r1
        TEQ     r0, r1                          ; if these match
        MOVEQ   r0, #2                          ; then there are definitely 2 fields to the next PU boundary
        BEQ     %FT10
        LDRB    r0, FirstField_CurrentPU        ; if we've got here, then there are an odd number of fields to the next PU boundary, 1 or 3
        TEQ     r0, r1                          ; if the current PU is two fields long,
        MOVEQ   r0, #1                          ; then it's got to be 1 field
        BEQ     %FT10
        LDR     r0, PU_EstCountdown             ; see if the estimate can help
        TEQ     r0, #0                          ; if it's negative (perhaps because of stalling)
        MOVMI   r0, #1                          ; then guess 1 field
10      STR     r0, PU_Countdown
        Debug   pulldown, "Countdown initialised to", r0
        EXITS
 ]


; Begin Vertical Blank interrupt
; r0-r3 can be junked

BeginVerticalBlank Entry
	LDR	r0, DecodedFieldCount
	CMP	r0, #0
	EXIT	LT
	ADD	r0, r0, #1
	LDR	lr, BlankedFields		; number of fields after decode start that it's safe to unblank screen
	CMP	r0, lr
	MOVCS	r0, #-2				; reset to -2 so no more unblanking, and we know display is safe
	STR	r0, DecodedFieldCount
	EXIT	CC

	ReadRegI r0, OSDControl
	BIC	r0, r0, #OSDControl_VideoBlack	; unblank
	WriteRegI r0, OSDControl, r1

 [ PerformFieldInversion
	MOV	r0, #2
	STR	r0, FieldInversionState
 ]
	EXIT

; DoUnderrunFix - used in Begin Active Video interrupt

 [ TrickPlaySupport :LOR: SlowMotionSupport
	MACRO
	DoUnderrunFix
	LDR	r0, VideoPreFilling
	TEQ	r0, #0
	BNE	%FT09				; [prefilling, so don't start decoder]

	LDR	r0, VideoStreamClosing
	CMP	r0, #1				; if shutting down then we'd better restart decoder
	BCS	%FT04				; so that buffers can empty, so set C=1

 [ SlowMotionSupport
	LDR	r0, VideoSpeedSetting
	CMP	r0, #2
	BLT	%FT03				; [not slow motion, so check trick play]
	LDR	lr, VideoSpeedCount		; load count of where we are in slow-motion sequence
	ADD	lr, lr, #1			; increment it
	CMP	lr, r0				; if >= speed setting
	MOVCS	lr, #0				; then reset to zero
	STR	lr, VideoSpeedCount		; always store back
	B	%FT04				; skip trick play check (CS => start decoder, CC => stop)
 ]

 [ TrickPlaySupport
03
        LDR	r0, TrickPlayMode
	TEQ	r0, #0				; if not doing trick play
	LDRNE	r0, VideoStructureFlags
	TSTNE	r0, #VideoStructureFlags_TrickPlayUnderrunFix ; or underrun fix not enabled
	BEQ	%FT09				; then skip this stuff
	BL	VideoGetBufferFullness		; else check if we have enough data in video channel
;	LDR	r0, VideoVBVSize
	LDR	r0, =VideoPreFillSize
	CMP	r2, r0
 ]
04
	MVN	r1, #IR_DecodeStatus
	MVNCS	r0, r1				; if enough, start decoder
	ADRCS	r2, TrickStarts
	MOVCS	r3, #0				; unfreeze field
	MOVCC	r0, #0				; if not, stop it
	ADRCC	r2, TrickStops
	MOVCC	r3, #1				; freeze field
	BL	UpdateIR

	LDR	lr, [r2]
	ADD	lr, lr, #1			; increment either TrickStops or TrickStarts
	STR	lr, [r2]

  [ FreezeFieldOnTrickStop
	STR	r3, TrickStopFreeze
	MOV	r0, #1
	STR	r0, FreezeUpdate
  ]
 [ :LNOT: TrickPlaySupport
03						; jump to here if not check for trick play stuff
 ]
09
	MEND
 ] ; TrickPlaySupport :LOR: SlowMotionSupport

; Begin Active Video interrupt
; r0-r3 can be junked

BeginActiveVideo Entry "r4,r5,r8"

 [ (TrickPlaySupport :LOR: SlowMotionSupport) :LAND: :LNOT: UnderrunFixOnlyOnOddFields
	DoUnderrunFix
 ]

 [ PerformFieldInversion
	LDR	r0, FieldInversionState		; 2 => freeze, 1 => unfreeze, 0 => do nowt
	CMP	r0, #1
	BCC	%FT05
	ReadRegI r1, DisplayMode0
	ORRHI	r1, r1, #2			; if freezing, set bit
	BICEQ	r1, r1, #2			; if unfreezing, clear bit
	WriteRegI r1, DisplayMode0, lr
	Push	"r0"
	MOVHI	r0, #0				; stop decoder
	MOVEQ	r0, #1				; start decoder
	MVN	r1, #1
	BL	UpdateIR
	Pull	"r0"
	SUB	r0, r0, #1			; decrement state
	STR	r0, FieldInversionState		; and store back
05
 ]
	ReadRegI r0, DisplayControllerStatus
 [ CountFieldInversions
	AND	r0, r0, #3
	TEQ	r0, #0				; if not 0
	TEQNE	r0, #3				; or 3
	LDRNE	r1, FieldInversions		; then fields have inverted
	ADDNE	r1, r1, #1
	STRNE	r1, FieldInversions
 ]
 [ Pulldown
        ANDS    r0, r0, #1                      ; extract even/odd field indicator bit
        STRB    r0, EvenOddIndicator            ; and cache it for reference in ProcessPictureCodingExtensionData
        Debug   pulldown, "EvenOddIndicator set to", r0
        BNE     %FT20                           ; if an even field then skip all the odd field actions
 |
	TST	r0, #1				; check if an odd field
	EXIT	NE				; [it's not, so exit]
 ]

 [ (TrickPlaySupport :LOR: SlowMotionSupport) :LAND: UnderrunFixOnlyOnOddFields
	DoUnderrunFix
 ]
; now check for pending freeze update

	LDR	r1, FreezeUpdate
	TEQ	r1, #0
	BEQ	%FT07
	LDR	r1, PendingFreezeState
	TEQ	r1, #0
  [ FreezeFieldOnTrickStop
	LDREQ	r1, TrickStopFreeze
	TEQEQ	r1, #0
  ]
        ReadRegI r1, DisplayMode0
        BICEQ   r1, r1, #DisplayMode0_FreezeField ; if 0 then unfrozen, so write FreezeField bit to 0
        ORRNE   r1, r1, #DisplayMode0_FreezeField ; else frozen, so write FreezeField bit to 1
	WriteRegI r1, DisplayMode0, lr
	MOV	r1, #0
	STR	r1, FreezeUpdate
07


 [ CountUnderruns
	LDR	r1, UnderrunIRQState
	TEQ	r1, #1
	MOVEQ	r1, #2				; indicate complete
	STREQ	r1, UnderrunIRQState
	MOVEQ	r0, #0				; enable underrun IRQ
	MVNEQ	r1, #IR_VideoChannelBufferUnderflow
	BLEQ	UpdateIR
 ]

 [ Pulldown
20
        LDR     r0, PU_Countdown
        LDR     r1, PU_EstCountdown
        ReadRegI r14, DisplayMode0
        TST     r14, #DisplayMode0_FreezeField :OR: DisplayMode0_FreezeFrame
        SUBEQ   r1, r1, #1
        SUBEQS  r0, r0, #1                      ; only decrement field count if we're not frozen
        STR     r0, PU_Countdown
        STR     r1, PU_EstCountdown
        Debug   pulldown, "BeginActiveVideo: Countdown, EstCountdown set to", r0, r1
        EXIT    NE                              ; if frozen, or unless PU_Countdown has reached 0, exit

        ReadRegI r0, VideoTrickModes
        TST     r0, #VideoTrickModes_Repeat
        BNE     %FT21                           ; if we're repeating a picture, we need to hang around for another two fields for the PU boundary
        AND     r0, r0, #VideoTrickModes_SkipAny
        TEQ     r0, #VideoTrickModes_SkipB      ; similarly if a skip has failed
        BNE     %FT22                           ; note that the SkipB flag may also be set if we're still waiting for a B picture
21      MOV     r0, #2
        STR     r0, PU_Countdown
        Debug   pulldown, "Countdown reset to 2"
        EXIT
22

; We're at the start of a new Presentation Unit, so we can now deal with synchronisation and pulldown

        LDRB    r0, FirstField_NextPU
        LDRB    r1, FirstField_FuturePU
        STRB    r0, FirstField_CurrentPU
        STRB    r1, FirstField_NextPU           ; shuffle the flags along by one PU
        Debug   pulldown, "New PU: FirstField_Current/NextPU =", r0, r1

        ReadRegI r14, DisplayMode0
        TEQ     r0, r1
        MOVEQ   r0, #2                          ; if the next PU starts on the same field type, it should normally be a 2-field PU
        MOVNE   r0, #3                          ; otherwise, it should normally be a 3-field PU
        STR     r0, PU_EstCountdown
        Debug   pulldown, "EstCountdown initialised to", r0
        BICEQ   r14, r14, #1:SHL:3              ; disable pulldown for a 2-field PU (DisplayMode0 = 2_xxx000xx)
        ORRNE   r14, r14, #1:SHL:3              ; enable pulldown for a 3-field PU (DisplayMode0 = 2_xxx010xx)
        WriteRegI r14, DisplayMode0, r0
 ]

 [ CountVideoPackets
	LDR	r1, SyncMode			; if we're counting video packets for sync
	TEQ	r1, #0				; then do count here, else do normal sync
	BEQ	%FT10

	ADR	r8, VideoInfoStructure
	BL	CheckSystemBuffer		; read any video system buffer data, in case we're stalled

	LDR	r1, VideoPacketsReceived
	LDR	lr, VideoPicturesReceived

; now add to stats data

	LDR	r0, VideoSyncPos
	CMP	r0, #?VideoSyncStats
	ADRCCL	r4, VideoSyncStats
	ADDCC	r4, r4, r0
	STMCCIA	r4, {r1,lr}			; store packets, pictures
	ADDCC	r0, r0, #8
	STRCC	r0, VideoSyncPos

	SUBS	r1, r1, lr
	CMP	r1, #1
	LDRGT	lr, VideoOKCount
	ADDGT	lr, lr, #1
	STRGT	lr, VideoOKCount
	EXIT	GT				; if had more packets than pictures, OK to let go

	MOV	r1, #VideoTrickModes_Repeat
	WriteRegI r1, VideoTrickModes, lr	; else force a repeat
	LDR	lr, VideoRepeats
	ADD	lr, lr, #1
	STR	lr, VideoRepeats
	EXIT
10
 ]

 [ AllowSyncOnIFrames
	LDR	r1, SyncMode
	TEQ	r1, #0
	ADREQ	r5, VideoPostedPTS		; point at normal sync posted PTS
	MOVEQ	r4, #-1				; indicate normal syncing
	BEQ	%FT15				; normal syncing

	LDR	lr, AnchorPostedPTSWritePtr	; get FIFO write pointer
	SUBS	lr, lr, #2			; move back two
	EXIT	CC				; if not already written 2 words in there then exit
	LDR	r4, AnchorPostedPTSReadPtr
	CMP	r4, lr				; if we've read as many as we've written-2
	EXIT	CS				; then exit
	AND	lr, r4, #3			; wrap around FIFO
	ADR	r1, AnchorPostedPTSs		; point at FIFO
	ADD	r5, r1, lr, LSL #3		; point at correct entry
15
 |
	ADR	r5, VideoPostedPTS
 ]
	LDMIA	r5, {r0, r3}			; get posted PTS
	TEQ	r3, #0
	BMI	SkipPostedPTS			; no PTS posted, so exit

 [ :LNOT: AllowSyncOnIFrames
	MOV	lr, #-1
	STR	lr, [r5, #4]			; cancel posted PTS
 ]
 [ SlowMotionSupport
	LDR	lr, VideoSpeedSetting
	CMP	lr, #2				; if doing slow-motion
	BGE	SkipPostedPTS			; then don't perform video-to-audio sync
 ]
	LDR	lr, VideoStreamFlags
	TST	lr, #StreamFlags_NoLipSync
	BNE	SkipPostedPTS

	ReadRegI lr, VideoTrickModes
	TST	lr, #VideoTrickModes_ValidBits
	BNE	SkipPostedPTS			; still a skip or repeat in operation

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if normal syncing, skip this
	BEQ	%FT18
; If SyncMode flag = 1, then this is the first PTS after the ResetStream,
; so use this to write the SCR instead of comparing

	LDR	lr, SyncMode
	TEQ	lr, #1
	BNE	%FT18

	MOV	r1, r3				; put bit 33 into r1 (WriteSCR takes r0,r1)
	BL	WriteSCR
	MOV	lr, #2
	STR	lr, SyncMode			; indicate we've done one
	B	SkipPostedPTS			; and remove this PTS from list
18
 ]
	BL	ReadSCR				; read SCR in r1, r2
	SUBS	r0, r0, r1
	SBC	r3, r3, r2			; form PTS - SCR
	ANDS	r3, r3, #1			; only interested in bit32 of difference
	LDR	r3, =MaxPTSError
	BNE	%FT50				; [PTS < SCR]

; PTS > SCR - see if it's more than about a frame (3600 ticks)

	CMP	r0, r3
	MOVCC	lr, #0
	STRCC	lr, LastVideoPTSErrorSign	; last one was within range
	BCC	SkipPostedPTS			; not sufficiently out

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if we're doing I-frame syncing
	BNE	%FT40				; don't bother with hysteresis
 ]
	LDR	lr, LastVideoPTSErrorSign	; was last error positive as well?
	TEQ	lr, #1
	MOVNE	lr, #1				; if not, then store current direction
	STRNE	lr, LastVideoPTSErrorSign
	BNE	SkipPostedPTS			; but don't repeat this time
40

	LDR	lr, VideoRepeats		; one more repeat
	ADD	lr, lr, #1
	STR	lr, VideoRepeats

	LDR	lr, VideoMaxPTSDifference
	CMP	r0, lr
	STRGT	r0, VideoMaxPTSDifference

	MOV	r0, #VideoTrickModes_Repeat
	WriteRegI r0, VideoTrickModes, lr
	EXIT

50
	ADDS	r0, r0, r3			; if within approx one frame
	MOVCS	lr, #0
	STRCS	lr, LastVideoPTSErrorSign	; last one was within range
	BCS	SkipPostedPTS			; don't do anything

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; if we're doing I-frame syncing
	BNE	%FT55				; don't bother with hysteresis
 ]
	LDR	lr, LastVideoPTSErrorSign	; was last error negative as well?
	CMP	lr, #-1
	MOVNE	lr, #-1
	STRNE	lr, LastVideoPTSErrorSign	; if not, then store current direction
	BNE	SkipPostedPTS			; but don't skip this time
55
	LDR	lr, VideoSkips
	ADD	lr, lr, #1
	STR	lr, VideoSkips

	SUB	r0, r0, r3
	LDR	lr, VideoMinPTSDifference
	CMP	r0, lr
	STRLT	r0, VideoMinPTSDifference

 [ AllowSyncOnIFrames
	CMP	r4, #-1				; are we syncing on I-frames
	MOVEQ	r0, #VideoTrickModes_SkipB
	MOVNE	r0, #VideoTrickModes_SkipAny
 |
	MOV	r0, #VideoTrickModes_SkipB
 ]
	WriteRegI r0, VideoTrickModes, lr
SkipPostedPTS
 [ AllowSyncOnIFrames
	MOV	lr, #-1
	STR	lr, [r5, #4]			; cancel posted PTS
	ADD	r4, r4, #1			; discard this PTS
	STR	r4, AnchorPostedPTSReadPtr	; and store back read ptr
 ]
	EXIT


; SCR Status IRQ
; r0-r3 can be junked

SCRStatusIRQ Entry "r0"
	BL	CheckErrorStatus
      [ StartVideoAtSeqHdr
        ; We may have got here because it's time to start the video off
        LDRB    r0, DeferVideoStart
        TEQ     r0, #0                          ; if not deferring video start
        LDRNE   r0, VideoSpeedSetting
        TSTNE   r0, #&80000000                  ; or we've already started playing
        LDRNEB  r0, FirstAudioPTS
        TEQNE   r0, #1                          ; or if SCR hasn't yet been initialised by first audio PTS
        EXIT    EQ                              ; then exit now
        BL      ReadSCR                         ; get SCR in r1, r2
        ADR     r0, LastVideoDTS0
        LDMIA   r0, {r0, r3}                    ; get video start time in r0, r3
        SUBS    r1, r0, r1                      ; find video DTS - current SCR
        SBC     r2, r3, r2
        TST     r2, #1                          ; test sign bit
        EXIT    EQ                              ; exit if we haven't reached video start time yet
        LDR     r2, VideoSpeedSetting
        BIC     r2, r2, #&80000000              ; clear pre-buffering bit
        STR     r2, VideoSpeedSetting
        BL      VideoSetSpeed
      ]
	EXIT

	MACRO
	DoDRAMGetByte	$underrun
	BL	DRAMGetByte
	BVS	$underrun
	MEND

 [ CountUnderruns
; Video Channel underrun IRQ

VideoChannelUnderrunIRQ Entry
	LDR	lr, VideoChannelUnderruns
	ADD	lr, lr, #1
	STR	lr, VideoChannelUnderruns

; now disable buffer underflow interrupt, so it doesn't happen again
	MOV	r0, #IR_VideoChannelBufferUnderflow ; set the bit to disable the IRQ
	MVN	r1, #IR_VideoChannelBufferUnderflow
	BL	UpdateIR
	EXIT
 ]

; **************************************************************************
;
;	SetupScreenMode - Program screen mode registers in L64002
;
; in:	r0 = xres
;	r1 = yres
;	r2 = 0 for PAL, 1 for NTSC
;	r3 = aspect ratio
;
; out:	-


SetupScreenMode Entry "r2-r7"
 [ {FALSE} ; debug x 2 size
	MOV	r0, r0, LSR #1
	MOV	r1, r1, LSR #1
 ]
	ASSERT	CurrentVerticalSize = CurrentHorizontalSize + 4
	ASSERT	CurrentTVFormat = CurrentHorizontalSize + 8
	ADR	lr, CurrentHorizontalSize
 [ CheckAspectRatio
	LDMIA	lr, {r4-r7}			; load old settings
	TEQ	r0, r4
	TEQEQ	r1, r5
	TEQEQ	r2, r6
	TEQEQ	r3, r7
	EXIT	EQ				; all the same, so do nothing
	STMIA	lr, {r0-r3}			; save out new parameters
 |
	LDMIA	lr, {r4-r6}			; load old settings

	TEQ	r0, r4
	TEQEQ	r1, r5
	TEQEQ	r2, r6
	EXIT	EQ				; all the same, so do nothing
	STMIA	lr, {r0-r2}			; save out new parameters
 ]

	CMP	r1, #288			; if more than 288
	MOVHI	r4, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_InterlaceChromaFieldRepeatFilterChroma
						; then full interlaced picture
	MOVLS	r4, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_ProgressiveFilterLuma
						; else just SIF
	WriteRegI r4, DisplayMode1, lr

 [ CheckAspectRatio
	ADR	r4, AspectRatios
	CMP	r3, #5				; if outside range
	MOVCS	r3, #2				; then pretend it's 4:3 (used to be erroneously 1)
	LDR	r4, [r4, r3, LSL #2]		; get word with num (bits 15:0) den (bits 31:16)
	MOV	r5, r4, LSR #16			; denominator
	BIC	r4, r4, r5, LSL #16		; numerator
	MUL	r4, r0, r4			; numerator * xres
	DivRem	r6, r4, r5, lr			; numerator * xres / denominator
 [ HShiftVariable
        ; We shift displayed frame right by pretending that the displayed frame encompasses a larger proportion of
        ; the decoded frame (actually, double the increase specified by the system variable, once for each side)
        ; to have the effect of reducing the number of undisplayed pixels we calculate for the left-hand edge.
        ; Moving the displayed frame left falls out naturally, just by using a negative value for the system variable.
        LDR     r3, HShift
        ADD     r3, r3, #360                    ; multiply by (720 + 2 * shift)
        MUL     r4, r6, r3
        MOV     r3, #360                        ; divide by 720
        DivRem  r5, r4, r3, lr
        SUB     r4, r0, r5                      ; total number of undisplayed pixels on LHS (I'm not really bothered if it's -ve)
 |
	SUBS	r4, r0, r6			; total number of undisplayed pixels
	MOVCC	r4, #0				; if -ve then put it at left-hand edge, too complicated to blank LHS
 ]
	MOV	r4, r4, LSL #2			; undisplayed width at LHS, in 1/8th pixel units
	MOV	r5, r4, LSR #6			; amount in whole (8-byte) words
	BIC	r4, r4, r5, LSL #6		; remainder
	WriteRegI r4, PanAndScan8thPelOrigin, lr
	WriteRegI r5, PanAndScanLumaWordOrigin0, lr
	WriteRegI r5, PanAndScanChromaWordOrigin0, lr
	MOV	r5, r5, LSR #8
	WriteRegI r5, PanAndScanLumaWordOrigin1, lr
	WriteRegI r5, PanAndScanChromaWordOrigin1, lr
	MOV	r0, r6				; use new value as width
 ]
 [ FudgeQSIF
	CMP	r1, #288
	MOVLS	r4, r0, LSL #1			; if SIF or less, use width = 2 x xres
	BLS	%FT05
 ]
	MOV	r4, #704
	BL	GetHCF
	MOV	r5, r4				; save HCF of (xres, 704)

	MOV	r4, #720
	BL	GetHCF				; get HCF of (xres, 720)
	CMP	r4, r5
	ORRHI	r2, r2, #2			; if HCF is higher with 720, set bit 1 of TV format to form index into table
	MOVHI	r4, #720
	MOVLS	r4, #704
05
	STR	r4, CurrentOutputWidth
	MOV	r5, r0, LSL #8			; r5 = xres*256
	DivRem	r6, r5, r4, lr			; r6 = xres*256/outputwidth, r5 = remainder
	TEQ	r5, #0				; if remainder non-zero
	ADDNE	r6, r6, #1			; round up
	WriteRegI r6, RasterMapperIncrement, lr	; write raster mapper increment

; now work out MainReadsPerLine/DisplayWidth registers, including top bits which are determined by PAL/NTSC

	ADD	r3, r0, #7
	MOV	r3, r3, LSR #3			; xres/8
	TST	r2, #1				; if PAL
	ORREQ	r3, r3, #&80			; then set top bit
	WriteRegI r3, MainReadsPerLine, lr	; and write to MainReadsPerLine
	WriteRegI r3, DisplayWidth, lr		; and DisplayWidth

	ADR	lr, ScreenParamsTable
	LDR	r3, [lr, r2, LSL #2]
	ADD	r3, lr, r3			; r3 -> table for appropriate mode
10
	LDR	r4, [r3], #4
	CMP	r4, #-1
	EXIT	EQ
	WriteReg r4, AIR			; byte 0 is index within bank
	MOV	r4, r4, LSR #8			; byte 1 is register value
	MOV	lr, r4, LSR #8			; byte 2 is register number
	STRB	r4, [r11, lr, LSL #L64002_Register_Address_Shift]
	B	%BT10

 [ CheckAspectRatio
AspectRatios
	&	1 :OR: (1 << 16)		; forbidden - use 4:3
	&	1 :OR: (1 << 16)		; square pixels - but use 4:3 anyway cos we can't scale down
	&	1 :OR: (1 << 16)		; 4:3
	&	3 :OR: (4 << 16)		; 16:9
	&	400 :OR: (663 << 16)		; 2.21:1
 ]

; GetHCF - r4 = highest common factor of r0 and r4

GetHCF	Entry "r0, r1"
	CMP	r0, r4				; ensure r0 >= r4 before we start
	EORCC	r0, r0, r4
	EORCC	r4, r4, r0
	EORCC	r0, r0, r4
10
	DivRem	r1, r0, r4, lr			; r1 = r0/r4; r0=r0 mod r4
	TEQ	r0, #0				; if remainder non-zero
	MOVNE	r0, r4				; then shuffle up numbers
	MOVNE	r4, r1
	BNE	%BT10				; and loop
	EXIT					; else exit with r4 = HCF

ScreenParamsTable
	&	ScreenParamsPAL704-ScreenParamsTable
	&	ScreenParamsNTSC704-ScreenParamsTable
	&	ScreenParamsPAL720-ScreenParamsTable
	&	ScreenParamsNTSC720-ScreenParamsTable

	MACRO
	MakeRegisterEntry $reg, $value
	&	L64002_$reg._Addr2 :OR: (($value):SHL:8) :OR: (L64002_$reg._Addr1 :SHL: (16-L64002_Register_Address_Shift))
	MEND

	MACRO
$label	MakeScreenParams $hsw,$eqw,$ser,$hbl,$hfln,$actim, $prebl,$mnln,$postbl,$preeqhln,$serhln,$posteqhln,$scanhln
$label
	ASSERT	$hsw :AND: :NOT: &FF = 0
	ASSERT	$eqw :AND: :NOT: &FF = 0
	ASSERT	$ser :AND: :NOT: &3FF = 0
	ASSERT  $hbl :AND: :NOT: &1FF = 0
	ASSERT	$actim :AND: :NOT: &3FF = 0
	ASSERT	$hfln :AND: :NOT: &3FF = 0
	ASSERT	$prebl :AND: :NOT: &1F = 0
	ASSERT	$preeqhln :AND: :NOT: 7 = 0
	ASSERT	$postbl :AND: :NOT: &1F = 0
	ASSERT	$posteqhln :AND: :NOT: 7 = 0
	ASSERT	$mnln :AND: :NOT: &3F = 0
	ASSERT	$serhln :AND: :NOT: 7 = 0
	ASSERT	$scanhln :AND: :NOT: &1FF = 0
	MakeRegisterEntry HorizSyncWidth, $hsw
	MakeRegisterEntry EqualizationPulseWidth, $eqw
	MakeRegisterEntry SerrationPulseWidth, ($ser :AND: &FF)
	MakeRegisterEntry HorizBlankPulseWidth, ($hbl :AND: &FF)
	MakeRegisterEntry ActiveImageDone, ($actim :AND: &FF)
	MakeRegisterEntry HalfLineTime, ($hfln :AND: &FF)
	MakeRegisterEntry UpperBits, ($ser:SHR:8) :OR: (($hbl:SHR:8):SHL:2) :OR: (($actim:SHR:8):SHL:3) :OR: (($hfln:SHR:8):SHL:5)
	MakeRegisterEntry VertiPreBlankEqualization, ($preeqhln :SHL: 5) :OR: $prebl
	MakeRegisterEntry VertiPostBlankEqualization, ($posteqhln :SHL: 5) :OR: $postbl
	MakeRegisterEntry VertiMainSerrationLines, ($serhln :SHL: 5) :OR: ($mnln :AND: &1F)
	MakeRegisterEntry VertiScanHalfLines, ($scanhln :AND: &FF)
	&	-1
	MEND

ScreenParamsPAL704	MakeScreenParams 127,62,737,276,863,820, 23,36,1,5,5,5,305
ScreenParamsPAL720	MakeScreenParams 127,62,737,260,863,836, 23,36,1,5,5,5,305
ScreenParamsNTSC704	MakeScreenParams 129,64,729,256,857,806, 17,30,5,6,6,6,253
ScreenParamsNTSC720	MakeScreenParams 129,64,729,240,857,822, 17,30,5,6,6,6,253

; **************************************************************************
;
;	CheckSystemBuffer - Check contents of system buffer for packet headers with PTSs
;			    and add them to the PTSList
;
; in:	r8 -> audio or video info structure
;	r11 -> L64002 registers
;	IRQ mode, IRQs disabled
;
; out:	All registers preserved

CheckSystemBuffer Entry "r0-r9"
	LDR	r9, [r8, #SI_SISPtr]		; r9 -> streaminfo system structure
	MOV	r0, #-1
	STR	r0, DRAMBufferAddress		; invalidate any data already in buffer
	LDR	r0, [r9, #SIS_SystemWrite0Reg]
	STRB	r0, [r11, #L64002_AIR]
	LDR	r0, [r9, #SIS_SystemWrite0Group]
	LDRB	r0, [r11, r0]			; read system buffer write ptr LSB
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #&03			; mask off wrapping bits for now
	ORR	r0, r0, lr, LSL #16
	MOV	r0, r0, LSL #3			; r0 = byte address of system buffer write address
	STR	r0, [r9, #SIS_SystemBufferWritePtr] ; last reading of write pointer
	LDR	r1, [r9, #SIS_SystemBufferReadPtr]

;	LDR	r2, [r8, #SI_PTSListReadPtr]
;	LDR	r3, [r8, #SI_PTSListWritePtr]
;	LDR	r4, [r8, #SI_PTSListPtr]
10
	STR	r1, [r9, #SIS_SystemBufferReadPtr] ; save where we're at
	TEQ	r0, r1				; is there any data for us?
	EXIT	EQ				; [no, then exit]
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70				; not a system start code, skip to next word
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #1
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	MOV	r8, #0				; by default indicate not a packet header we're interested in
	MOV	lr, r5, LSR #4
	TEQ	lr, #&E				; stream ids &E0-&EF are video packets
	ADREQ	r8, VideoInfoStructure
	TEQ	lr, #&C				; stream ids &C0-&DF are audio packets
	TEQNE	lr, #&D
	ADREQ	r8, AudioInfoStructure
	TEQ	r8, #0
	BEQ	%FT75				; [not packet code of interest, check for pack or system header]
 [ CountVideoPackets
	TEQ	lr, #&E
	LDREQ	lr, VideoPacketsReceived
	ADDEQ	lr, lr, #1
	STREQ	lr, VideoPacketsReceived
 ]
	BL	DRAMGetByte			; get length hi
	BLVC	DRAMGetByte			; get length lo
	BVS	UnderrunExit
20
	DoDRAMGetByte UnderrunExit		; skip stuffing bytes (the MPEGControl module and/or L64002 may have removed them)
	TEQ	r5, #&FF
	BEQ	%BT20

	MOV	lr, r5, LSR #6
	TEQ	lr, #1				; is there an STB_buffer_scale/size?
	BNE	%FT30
	BL	DRAMGetByte			; skip 2nd byte of STB_buffer_scale/size
	BLVC	DRAMGetByte			; get next byte
	BVS	UnderrunExit
30
	MOV	lr, r5, LSR #6
	TEQ	lr, #2				; is it MPEG 2 PES?
	BEQ	%FT60

	MOVS	lr, r5, LSR #4
	BEQ	%FT55				; [no PTS or DTS]
	TEQ	lr, #2
	BNE	%FT50				; [not PTS on its own]

	BL	GetClockReference		; returns PTS value in r6, r7
	BVS	UnderrunExit
32
	BL	RoundUpToWord			; round up to whole word boundary
	ADD	r1, r1, #5			; address starts at offset 5 in this word
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #24+2		; hi-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #16+2		; mid-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #8+2		; lo-byte of pointer

; now check the address for sanity, as the L64002 seems to put in duff ones now and again

	MOV	lr, r7, LSR #10-3		; convert to byte address
	BIC	lr, lr, #&1E00000		; knock out wrap bits
	LDR	r5, [r8, #SI_ChannelBufferStart]
	CMP	lr, r5				; is it below start of channel buffer
	BCC	%FT34
	LDR	r5, [r8, #SI_ChannelBufferEnd]
	CMP	lr, r5				; or after the end of it?
	BCC	%FT36
34
	LDR	lr, [r9, #SIS_DuffChannelAddresses] ; increment count of gaffs
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffChannelAddresses]
	B	%BT10				; don't output item (no need to round up as we're already there)

36
; r7 now holds bit 32 of PTS in bit 0, and pointer field in bits 10..31 (including wrap bits)

	LDR	r4, [r8, #SI_PTSListPtr]	; load appropriate PTS list ptr
	LDR	r3, [r8, #SI_PTSListWritePtr]	; and offset
	ADD	lr, r4, r3, LSL #3
	STMIA	lr, {r6, r7}

	ADD	r3, r3, #1
	LDR	lr, [r8, #SI_PTSListSize]
	TEQ	r3, lr				; wrap PTS list index
	MOVEQ	r3, #0
	LDR	r2, [r8, #SI_PTSListReadPtr]
	TEQ	r3, r2				; if full then exit
	BEQ	%FT40
	STR	r3, [r8, #SI_PTSListWritePtr]	; then store back
	B	%BT10

40
	LDR	lr, [r8, #SI_PTSListOverruns]	; increment count of PTS list overruns
	ADD	lr, lr, #1
	STR	lr, [r8, #SI_PTSListOverruns]
	B	%BT10

UnderrunExit
	EXIT

; not MPEG 2, and not just &0F, and not just PTS, so check for PTS+DTS

50
	TEQ	lr, #3				; check if PTS+DTS
	BNE	%FT70				; [not that]

; it's PTS + DTS

	BL	GetClockReference		; get PTS
	BVS	UnderrunExit
	Push	"r7"
	MOV	r7, #5				; now skip DTS
	BL	SkipR7Bytes
	Pull	"r7"
	BVS	UnderrunExit
	B	%BT32				; pass PTS to code that reads ptr field

; no PTS or DTS, so skip pointer field to complete item

55
	BL	RoundUpToWord			; round up to whole word boundary
	DoDRAMGetByte UnderrunExit		; check pointer field there
	BL	RoundUpToWord			; round up again to skip whole word
	B	%BT10

; it's an MPEG 2 PES packet

60
	DoDRAMGetByte UnderrunExit		; get flags byte
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit		; get header length
	TST	r7, #&80
	BEQ	%FT65				; no PTS or DTS
	SUB	r5, r5, #5			; adjust header length to account for PTS we're about to extract
	Push	"r5, r7"			; save remaining header length + a slot for saving r7 later
	BL	DRAMGetByte			; get 1st byte of PTS
	BLVC	GetClockReference
	Pull	"r5, r7", VS			; if we underrun, flatten stack
	BVS	UnderrunExit			; and exit indicating underrun

	STR	r7, [sp, #4]			; save high word temporarily
	Pull	"r7"				; restore count of bytes to skip
	BL	SkipR7Bytes
	Pull	"r7"				; restore high word of PTS
	BVS	UnderrunExit			; if skip failed indicate underrun
	B	%BT32				; go to code that reads ptr field

; MPEG 2 PES with no PTS

65
	MOV	r7, r5				; skip rest of header
	BL	SkipR7Bytes
	BVS	UnderrunExit
	B	%BT55				; then skip pointer field

; we got rubbish in system buffer

70
	LDR	lr, [r9, #SIS_DuffSystemContents] ; increment count of number of times we had crap
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffSystemContents]
	STR	r1, [r9, #SIS_AddressOfLastDuff]
	BL	RoundUpToWord			; round up to whole word boundary
	B	%BT10				; for now just go onto next entry

; not packet header, so check for pack header or system header

75
	TEQ	r5, #&BA			; is it a pack header?
	BNE	%FT80

; a pack header is either a total of 12 bytes (MPEG 1) or 14 bytes + up to 7 bytes of
; &FF stuffing (MPEG2) (which the L64002 skips), so the system buffer usage is always 2 words

	BL	RoundUpToWord			; skip rest of 1st word
	DoDRAMGetByte UnderrunExit		; check 2nd word is there
	BL	RoundUpToWord			; round up to next one
	B	%BT10				; then go back for more

; not packet or pack header - check for system header

80
	TEQ	r5, #&BB			; is it a system header
	BNE	%BT70				; if not then rubbish
	DoDRAMGetByte UnderrunExit		; get high byte of length
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit
	ORRS	r7, r5, r7, LSL #8		; r7 = number of additional bytes
	BEQ	%FT85				; no more bytes to skip

	BL	SkipR7Bytes			; skip rest of system header
	BVS	UnderrunExit
85
	BL	RoundUpToWord			; skip to start of next word
	B	%BT10				; now go back for more


SkipR7Bytes Entry
10
	BL	DRAMGetByte
	EXIT	VS
	SUBS	r7, r7, #1			; decrement count of bytes to skip
	BNE	%BT10
	EXIT					; exit (V=0 from SUBS)


GetClockReference ROUT
	Push	"lr"
	AND	r5, r5, #&0E				; extract bits 3..1
	MOV	r7, r5, LSR #3				; r7 = bit 32 in bit 0
	Push	"r7"					; save for later, together with bomb-out address
	MOV	r7, r5, LSL #31-2			; r7 = bits 31,30
	BL	DRAMGetByte				; get bits 29..22 in bits 7..0
	ORRVC	r7, r7, r5, LSL #22			; r7 = bits 31..22
	BLVC	DRAMGetByte				; get bits 21..15 in bits 7..1
	MOVVC	r5, r5, LSR #1
	ORRVC	r7, r7, r5, LSL #15			; r7 = bits 31..15
	BLVC	DRAMGetByte				; get bits 14..7 in bits 7..0
	ORRVC	r7, r7, r5, LSL #7			; r7 = bits 31..7
	BLVC	DRAMGetByte				; get bits 6..0 in bits 7..1
	ORRVC	r6, r7, r5, LSR #1			; r6 = bits 31..0
	Pull	"r7,pc"

RoundUpToWord Entry
	ADD	r1, r1, #7
	BIC	r1, r1, #7
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXIT

DRAMGetByte Entry "r2,r3"
	ADR	r5, DRAMBuffer
	LDR	lr, DRAMBufferAddress
	EOR	lr, lr, r1				; differences between DRAM buffer address and required address
	BICS	lr, lr, #7				; is it in the same word?
	BNE	%FT10					; no, so fetch DRAM
05
	AND	lr, r1, #7
	LDRB	r5, [r5, lr]				; load from buffer
	ADD	r1, r1, #1				; advance read ptr
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXITS

10
	BIC	lr, r1, #7				; form base word address
	TEQ	lr, r0					; are we in same word as write ptr
	BEQ	%FT90					; if so then we've underrun

	STR	lr, DRAMBufferAddress			; save base address of buffer

	DRAMRead r2, r3, r1, lr				; perform read from location (r1 BIC 7) and put contents in r2,r3
	STMIA	r5, {r2, r3}				; store 8-bytes in buffer
	B	%BT05

90
	LDR	lr, [r9, #SIS_SystemUnderruns]
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_SystemUnderruns]
	PullEnv
	ORRS	pc, lr, #V_bit				; set V, preserving other flags

; **************************************************************************
;
;	ProcessAudioReadPtr - Compare passed in audio read ptr with AudioPTSList
;			      and if the sync code has a corresponding PTS, set SCR to it
;
; in:	r0 = audio channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> audio info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be junked

ProcessAudioReadPtr Entry

; we have to adjust for the fact that the audio sync code register points 16 (not 8 as in the manual) bytes further on
; than the address containing the audio sync code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #16 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	MOV	lr, r0, LSR #6				; convert back to byte offset for storage
	STR	lr, AudioChannelBufferReadPtr

	BL	CheckPTSList
	TEQ	r1, #0
	EXIT	MI					; if no PTS, just exit

      [ StartVideoAtSeqHdr
        LDRB    lr, FirstAudioPTS
        TEQ     lr, #1
        BNE     %FT90
        ; The first time, set the SCR from the audio PTS unconditionally
        MOV     lr, #0
        STRB    lr, FirstAudioPTS
        BL      WriteSCR
        ; Now we can work out what to set the L64002 SCR compare value to to trigger video start
        LDR     r2, LastVideoDTS0                       ; bottom 32 bits of LastVideoDTS
        LDR     r3, SCROffset                           ; bottom 32 bits of SCROffset
        SUB     r2, r2, r3                              ; find difference (only bottom 16 bits will be used)
        MOV     r3, r2, LSR#8                           ; so r3 bits 0-7 are SCR bits 8-15
        WriteRegI r2, SCRCompare0, lr
        WriteRegI r3, SCRCompare1, lr
        EXIT
90
      ]

 [ VetSCRValues
	MOV	r2, pc
	BIC	r3, r2, #3
	TEQP	r3, #SVC_mode				; enter SVC mode so we can save lr_svc
	NOP

	Push	"lr"					; save lr_svc
	BL	PerformSCRVetting			; if SCR bad, don't use it
	BLEQ	WriteSCR
	Pull	"lr"					; restore lr_svc

	TEQP	r2, #0					; restore original mode
	NOP
 |
	BL	WriteSCR
 ]
	EXIT

; **************************************************************************
;
;	CheckPTSList - Check video or audio PTS list for comparable item
;
; in:	r0 = channel buffer ptr to compare, shifted up to top of word (so that clock arithmetic can be used)
;	r8 -> VideoInfoStructure or AudioInfoStructure
;
; out:	If there is an appropriate PTS then
;	 r0 = bits 0..31 of PTS
;	 r1 = bit 32 of PTS (in bit 0)
;	else
;	 r0 = undefined
;	 r1 = -1
;	endif

CheckPTSList Entry "r2-r7,r9"
	LDR	r1, [r8, #SI_PTSListWritePtr]
	LDR	r2, [r8, #SI_PTSListReadPtr]
	LDR	r3, [r8, #SI_PTSListPtr]
	LDR	r9, [r8, #SI_PTSListSize]
	MOV	r7, #-1					; indicate no valid PTS yet
10
	TEQ	r2, r1					; have we run out?
	BEQ	%FT90					; then exit

	ADD	r4, r3, r2, LSL #3			; point at next read entry
	LDMIA	r4, {r4, r5}
	BIC	lr, r5, #1				; knock out bit 32 of PTS
	CMP	r0, lr					; check if value of read ptr is less than next PTS (using clock arithmetic)
	BMI	%FT90					; if so, then next PTS hasn't happened yet

	MOV	r6, r4					; make record of highest PTS so far with address field <= current read ptr
	AND	r7, r5, #1				; r7 = bit 32 of PTS

	ADD	r2, r2, #1				; advance read ptr
	TEQ	r2, r9					; wrap it
	MOVEQ	r2, #0
	B	%BT10

; no more PTSs with address <= read ptr, so if we've had one, set SCR to that, else just exit

90
	STR	r2, [r8, #SI_PTSListReadPtr]
	MOV	r0, r6
	MOV	r1, r7
	EXIT

; **************************************************************************
;
;	ProcessVideoReadPtr - Compare passed in video read ptr with VideoPTSList
;			      and if the picture start has a corresponding PTS, post it for
;			      comparison with the SCR on a future vsync IRQ
;
; in:	r0 = video channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> video info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be corrupted

ProcessVideoReadPtr Entry
	LDR	lr, AudioControlStreamHandle		; if no audio stream playing, don't do any syncing
	TEQ	lr, #0
	EXIT	EQ

; we have to adjust for the fact that the picture start code register points 48 bytes further on than the address containing
; the picture start code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #48 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	BL	CheckPTSList				; PTS if any comes back in r0,r1 (r1<0 if invalid)
	TEQ	r1, #0
	BMI	%FT10					; if no PTS, don't increment video PTS picture type counts

	LDRB	r2, Picture_PictureCodingType
	ADR	lr, VideoPTSPictureTypeCounts
	CMP	r2, #4
	LDRCC	r3, [lr, r2, LSL #2]
	ADDCC	r3, r3, #1
	STRCC	r3, [lr, r2, LSL #2]

10
 [ AllowSyncOnIFrames
	LDR	lr, SyncMode
	TEQ	lr, #0					; are we syncing to I-frames?
	BEQ	%FT30

; syncing to I-frames, so verify it is an anchor frame, else don't post it

	TEQ	r2, #PictureCodingType_P
	TEQNE	r2, #PictureCodingType_I
	EXIT	NE					; oh hell, it's a B-picture - don't try to post it

	LDR	lr, AnchorPostedPTSWritePtr
	ADR	r3, AnchorPostedPTSs
	AND	r2, lr, #3
	ADD	r3, r3, r2, LSL #3			; r3 -> slot to fill
	STMIA	r3, {r0, r1}				; store posted PTS
	ADD	r2, r2, #1
	AND	r2, r2, #3				; where WritePtr would point next (wrapped)
	LDR	r0, AnchorPostedPTSReadPtr
	AND	r0, r0, #3
	TEQ	r0, r2					; if would point to same place, then overrun
	LDREQ	lr, AnchorFIFOOverruns			; increment overrun count
	ADDEQ	lr, lr, #1
	STREQ	lr, AnchorFIFOOverruns
	EXIT	EQ					; and don't increment write ptr or number of posted PTSs

	ADD	lr, lr, #1				; advance unwrapped write ptr
	STR	lr, AnchorPostedPTSWritePtr		; and store back

	B	%FT50
30
 ]
 [ CountVideoPackets
	LDR	lr, SyncMode
	TEQ	lr, #0					; are we counting packets for sync
	BEQ	%FT30					; no, so do normal sync
	LDR	lr, VideoPicturesReceived		; else increment picture count
	ADD	lr, lr, #1
	STR	lr, VideoPicturesReceived
	EXIT						; and exit
30
 ]
	TEQ	r1, #0					; if doing normal syncing and no PTS, don't post it
	EXIT	MI

	TEQ	r2, #PictureCodingType_B		; is it a B picture?
	EXIT	NE					; if not exit for now

	LDR	lr, VideoPostedPTS +4			; is there already one posted that hasn't been used?
	TEQ	lr, #0					; less than 0 => empty
	EXIT	PL

	ADR	r3, VideoPostedPTS
	STMIA	r3, {r0, r1}				; post PTS for comparison on next odd field vsync IRQ
 [ SlowMotionSupport
	ADR	r3, VideoLastPTS
	STMIA	r3, {r0, r1}				; and save for slow-motion support too
 ]
50
	LDR	r0, VideoNumberOfPostedPTSs
	ADD	r0, r0, #1
	STR	r0, VideoNumberOfPostedPTSs

	EXIT

 [ VetSCRValues
; **************************************************************************
;
;	PerformSCRVetting - Check SCR for sensibility, and reject if not
;
; in:	r0 = bottom 32 bits of SCR
;	r1 = bit 32 of SCR
;	IRQ mode
;
; out:	NE => reject this SCR value

PerformSCRVetting Entry "r2,r3"
	LDR	r3, VetSCRState
	CMP	r3, #1
	BCS	%FT20

; we're awaiting the 1st SCR

	LDR	r2, AudioSpeedSetting
	TEQ	r2, #1			; only exit this state if in normal play mode
	BNE	%FT10			; return EQ, but do nothing
	BL	ConvertSCRToOffset
	STR	r2, GoodSCROffset
05
	MOV	r2, #1
	STR	r2, VetSCRState
10
	TEQ	r0, r0			; set EQ
	EXIT

20
	BL	ConvertSCRToOffset	; convert new SCR into an offset from 100Hz time
	LDR	lr, GoodSCROffset	; get last good offset
30
	SUBS	lr, lr, r2		; compute difference
	RSBMI	lr, lr, #0		; compute absolute difference
	CMP	lr, #SCRAcceptableRange	; is it within range
	STRCC	r2, GoodSCROffset	; yes, then store new good offset
	BCC	%BT05			; then mark last one as good, and exit EQ

; we're out of range of the last good one, but are we consistent with the last bad one?

	CMP	r3, #2			; was the last one bad?
	STRNE	r2, BadSCROffset	; if not, then store this as the 1st bad one
	MOVNE	r2, #2			; indicate last one was bad
	STRNE	r2, VetSCRState
	LDRNE	r2, BadSCRCount		; increment count of bad ones
	ADDNE	r2, r2, #1
	STRNE	r2, BadSCRCount
	EXIT	NE			; and exit NE, indicating last one bad

	LDR	lr, BadSCROffset	; get last bad offset
	MOV	r3, #1			; pretend last one was good, so we don't drop thru again
	B	%BT30

ConvertSCRToOffset ROUT
	Push	"r0,lr"
	SWI	XOS_ReadMonotonicTime	; returns in r0
	MOV	lr, #900		; SCR is in 90kHz ticks, monotonic time is in 100Hz units
	MUL	r2, lr, r0		; make into 90kHz units (don't care about overflow)
	Pull	"r0"
	SUB	r2, r0, r2		; SCR - MT*900
	Pull	"pc"

 ] ; VetSCRValues

; **************************************************************************
;
;	VideoTickerV - Entry point for TickerV IRQ for video

VideoTickerV Entry "r0-r2"
	LDR	r0, VideoCallBackRequested	; is a callback already requested
	TEQ	r0, #0
	EXIT	NE				; if so, don't ask for another
	MOV	r2, pc
	ORR	r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
	TEQP	r1, #0
	NOP
	Push	"r14"
	LDR	r0, VideoStreamFlags
	TST	r0, #StreamFlags_UseCallBacks
	BEQ	%FT20				; [stuff directly]

	ADR	r0, VideoTickerVCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	MOVVC	r0, #1
	STRVC	r0, VideoCallBackRequested	; indicate that we've requested a callback
10
	Pull	"r14"
	TEQP	r2, #0
	NOP
	EXIT

20
	MOV	r0, #1
	STR	r0, VideoCallBackRequested
	BL	VideoTickerVNonCallBack
	B	%BT10

 [ PreserveIRQStateInTickerVStuffing
; new code - only enable IRQs if it's a real callback, not direct in TickerV
VideoTickerVCallBack Entry
  [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
  ]
	PullEnv
VideoTickerVNonCallBack Entry "r0,r1, r11"
 |
; old code
VideoTickerVNonCallBack
VideoTickerVCallBack Entry "r0,r1, r11"
  [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
  ]
 ]
	LDR	r11, L64002_Registers
	BL	VideoCheckEndOfPreFill	; start playing if sent enough
	BL	VideoFreeUsedPackets
	BL	VideoDoStuffWithData
	MOV	r0, #0
	STR	r0, VideoCallBackRequested
	EXIT

	LTORG

VideoDoStuffWithData Entry "r0-r2"
	LDR	r0, VideoStreamClosing  ; if stream closing (ie value = 2)
	CMP	r0, #1			; don't send any more data
	EXIT	HI

	LDR	r0, VideoPacketListHeadPtr

; find any data we haven't passed to background yet

10
	TEQ	r0, #0						; any more data
	EXIT	EQ						; [no, so exit]
	LDR	r1, [r0, #PacketDescriptor_Flags]		; have we passed this packet
	TST	r1, #PacketDescriptorFlags_PassedToBackground
	BLEQ	PassPacketToBackground				; if not then do so
	LDRNE	r0, [r0, #PacketDescriptor_Link]		; if we can still send more, then go on to next packet
	BNE	%BT10
	EXIT

 [ MultiplePicturePacketsChecks
; **************************************************************************
;
;	CheckForMultiplePictures - Check packet for multiple picture_start codes
;
; in:	r0 -> packet descriptor for first packet within MPEG packet
;	r1 = flags for packet
;
; out:  EQ => packet is OK to send
;	NE => packet is incomplete so hasn't been checked - don't send it yet
;	r1 = updated flags
;	All other registers preserved

CheckForMultiplePictures Entry "r0,r2-r8"
	LDR	r2, [r0, #PacketDescriptor_FullLength]
	MOV	r3, r0
10
	LDR	r4, [r3, #PacketDescriptor_Length]
	SUBS	r2, r2, r4
	BLE	%FT20
	LDR	r3, [r3, #PacketDescriptor_Link]
	CMP	r3, #1		; if link <> 0
	BCS	%BT10		; then loop

; incomplete packet, so exit NE to indicate this

	LDR	r3, VideoStreamClosing
	TEQ	r3, #1		; are we going to get any more data?
	EXIT	NE		; we might, so exit NE indicating incomplete

	B	CFMPBadPacket	; else we'd best mark it as dodgy, just in case

; packet is complete, so let's check it (r0 -> first part packet, r3 -> last)

20
	LDR	r2, [r0, #PacketDescriptor_PTS]
	LDR	lr, =BadPacketPTS
	TEQ	r2, lr
	MOVNE	r8, #0
	MOVEQ	r8, #1

	LDR	r2, [r0, #PacketDescriptor_Start]
	LDR	r4, [r0, #PacketDescriptor_Length]
	MOV	r7, #0			; number of picture_start codes in packet

30
	MOV	r6, #0			; state
32
	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00
	BNE	%BT32
34
	MOV	r6, #1
	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00 00
	BNE	%BT30
	MOV	r6, #2

	BL	CFMPgetbyte
	TEQ	r5, #1		; check for 00 00 01
	SUBNE	r2, r2, #1	; if not then could be (00) 00 00
	ADDNE	r4, r4, #1	; adjust length back as well
	BNE	%BT34
	MOV	r6, #3

	BL	CFMPgetbyte
	TEQ	r5, #0		; check for 00 00 01 00 (picture start code)
	BNE	%BT30

	ADD	r7, r7, #1	; one more picture start code
	CMP	r7, #1
	BHI	CFMPBadPacket	; if more than 1 then definitely bad
	B	%BT30		; else loop

BadPacketPTS	*	&D4B20
	LTORG

CFMPgetbyte
	SUBS	r4, r4, #1
	LDRGEB  r5, [r2], #1
	MOVGE	pc, lr
	TEQ	r0, r3
	LDRNE	r0, [r0, #PacketDescriptor_Link]
	LDRNE	r2, [r0, #PacketDescriptor_Start]
	LDRNE	r4, [r0, #PacketDescriptor_Length]
	BNE	CFMPgetbyte

; we've run out of data to check

	TEQ	r8, #1
	STREQ	r7, CheckedBadPacket

 [ {FALSE}	; try rule where only two whole picture_start codes make a bad packet
	TEQ	r7, #0		; if no picture_start codes
	TEQNE	r6, #0		; or 1 picture_start code and no partial ones
 ]
	B	CFMPGoodPacket  ; then OK
CFMPBadPacket
	BIC	r1, r1, #PacketDescriptorFlags_PTSValid ; else clear PTS valid bit
	LDR	lr, MultiPacketCount
	ADD	lr, lr, #1
	STR	lr, MultiPacketCount
	CMP	lr, #MPDebugArraySize	; if run out of debug array
	BCS	CFMPGoodPacket		; then skip this bit
	ADR	r0, MPDebugArray-4
	ADD	lr, r0, lr, LSL #2	; point at where to store PTS
	LDR	r0, [sp]		; reload ptr to first partial packet
	LDR	r0, [r0, #PacketDescriptor_PTS] ; load bottom 32 bits of PTS for this packet
	STR	r0, [lr]
CFMPGoodPacket
	BIC	r1, r1, #PacketDescriptorFlags_Unchecked
	LDR	r0, [sp]		; reload ptr to first partial packet
	STR	r1, [r0, #PacketDescriptor_Flags]	; save flags
	TEQ	r0, r0			; indicate packet has been checked
	EXIT
 ]

; **************************************************************************
;
;	PassPacketToBackground - Pass a packet to background FIQ process
;
; in:	r0 -> packet
;	r1 = packet flags
;
; out:	NE if managed to pass this packet to background
;	EQ if couldn't, cos all slots full

PassPacketToBackground Entry "r1-r5,r11"
 [ UseWholePackets
	BL	VideoSendNewPacketIfNecessary		; if start of MPEG packet, put in packet header slot if poss.
	BNE	%FT90
 ]
	ASSERT	PacketDescriptor_Length = PacketDescriptor_Start + 4
	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	BNE	%FT90					; [all slots full]

	ADD	r4, r0, #PacketDescriptor_Start
	LDMIA	r4, {r4, r5}				; get address, length of this packet

 [ CheckBufferFullness
	LDR	lr, VideoPreFilling
	TEQ	lr, #0
	BNE	%FT10					; pre-filling, so assume OK
	LDR	r11, L64002_Registers
	BL	VideoGetBufferFullness			; read buffer fullness into r2
	LDR	lr, VideoAmountQueued
	ADD	r2, r2, lr				; add on amount already queued
	ADR	lr, FIQAmountSent
	LDR	lr, [lr]
	SUB	r2, r2, lr				; but subtract amount already sent
	ADD	r2, r2, #MPEG2Podule_FIFOLength + 8*1024 ; and add a possibly full FIFO, plus some slack in the channel buffer
	ADD	r2, r2, r5				; add on length of this packet
	LDR	lr, VideoChannelBufferSize
	CMP	r2, lr					; if this is more than total buffer size
	BHI	%FT90					; then don't pass this packet yet
10
 ]
	ORR	r1, r1, #PacketDescriptorFlags_PassedToBackground ; indicate passed to bgd
	STR	r1, [r0, #PacketDescriptor_Flags]	; do this *before* passing to bgd, in case it's bloody quick

	MOV	lr, r0
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in slot (NB may start going straight away)

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	TEQ	r3, #0					; r3 <> 0, so set NE
	EXIT

90
	TEQ	r0, r0					; set EQ, indicating failure
	EXIT

; **************************************************************************
;
;	WriteSCR - Write to system clock reference value by adjusting software offset
;
; in:	r0 = bits [31..0] of SCR
;	r1 = bit 32 of SCR, in bit 0
;	r11 -> L64002_Registers

WriteSCR Entry "r0-r4"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we update

	MOV	r3, r1					; save new hi word of value
	BL	ReadSCR					; r1 = old value lo, r2 = old value hi
	SUBS	r0, r0, r1				; r0 = (new value - old value) lo word
	SBC	r1, r3, r2				; r1 = (new value - old value) hi word

	ADR	lr, SCROffset
	LDMIA	lr, {r2, r3}				; r2 = old offset lo, r3 = old offset hi
	ADDS	r2, r2, r0				; r2 = new offset lo = new value - old value + old offset
	ADC	r3, r3, r1				; r3 = new offset hi
	STMIA	lr, {r2, r3}				; update offsets
	EXITS

; **************************************************************************
;
;	ReadSCR - Read current value of SCR bits using H/W and software offset
;
; in:	-
;
; out:	r1 = bits [31..0] of SCR
;	r2 = bit 32 of SCR, in bit 0

ReadSCR Entry	"r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we read this

	ReadRegI r1, SCR0
	ReadRegI r2, SCR1

	BL	CheckErrorStatus			; process bits in ErrorStatus register, returns r0 = error status
	TST	r0, #ErrorStatus_SCROverflow
	BEQ	%FT10

	ReadRegI r1, SCR0				; if overflowed, it may have done so before or after we read the
	ReadRegI r2, SCR1				; registers before, so read them again (won't have time to overflow again)
10
	ORR	lr, r1, r2, LSL #8
	ADR	r1, SCROffset				; load software offset (will have been updated
	LDMIA	r1, {r1, r2}				; if necessary by CheckErrorStatus)
	ADDS	r1, r1, lr				; and add it on
	ADC	r2, r2, #0
	EXITS

; **************************************************************************
;
;	CheckErrorStatus - Check various bits in ErrorStatus register and act on them
;
; in:	r11 -> L64002_Registers
;	IRQs disabled
;
; out:	r0 = value of ErrorStatus register

CheckErrorStatus Entry "r1,r2"
	ReadRegI r0, ErrorStatus
	STR	r0, LastErrorStatus
	LDR	lr, CumulativeErrorStatus
	ORR	lr, lr, r0
	STR	lr, CumulativeErrorStatus
	TST	r0, #ErrorStatus_VideoReconstructionError
	BEQ	%FT10
	LDR	lr, VidRecErrors
	ADD	lr, lr, #1
	STR	lr, VidRecErrors
	LDR	lr, TimeOffsetOfVRError
	CMP	lr, #-1				; if already had a vid recon error since last video reset
	BNE	%FT10				; then skip

	MOV	r1, pc
	ORR	r2, r1, #SVC_mode		; switch to SVC_mode so we can save lr_svc
	TEQP	r2, #0
	NOP
	Push	"r0, lr"
	SWI	XOS_ReadMonotonicTime
	LDR	lr, TimeOfLastVideoReset
	SUB	r0, r0, lr
	STR	r0, TimeOffsetOfVRError
	Pull	"r0, lr"
	TEQP	r1, #0				; switch back to previous mode
	NOP
10
	TST	r0, #ErrorStatus_ContextError
	LDRNE	lr, ContextErrors
	ADDNE	lr, lr, #1
	STRNE	lr, ContextErrors
	TST	r0, #ErrorStatus_VLCError
	LDRNE	lr, VLCErrors
	ADDNE	lr, lr, #1
	STRNE	lr, VLCErrors

	TST	r0, #ErrorStatus_SCROverflow
	EXIT	EQ
	ADR	lr, SCROffset
	LDMIA	lr, {r1, r2}
	ADDS	r1, r1, #1 :SHL: 16
	ADC	r2, r2, #0
	STMIA	lr, {r1, r2}
	EXIT

; **************************************************************************
;
;	VideoFreeUsedPackets - Go through packet list freeing any used packets

VideoFreeUsedPackets Entry "r0-r3"
10
	LDR	r0, VideoPacketListHeadPtr
	TEQ	r0, #0
	LDRNE	lr, [r0, #PacketDescriptor_Flags]	; if we have a packet, has it all been sent?
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	EXIT	EQ
 [ {TRUE}
; we've found a packet that needs freeing, so go down chain until we find the last
; one that needs freeing
	MOV	r1, r0					; save pointer to 1st one
20
	LDR	r2, [r1, #PacketDescriptor_Link]	; if there is a next node
	TEQ	r2, #0
	LDRNE	lr, [r2, #PacketDescriptor_Flags]	; and it's all sent
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	MOVNE	r1, r2					; then move to that one
	BNE	%BT20					; and loop

	MOV	r3, pc
	ORR	lr, r3, #I_bit				; disable IRQs round this bit
	TEQP	lr, #0					; (may be unnecessary)

	STR	r2, VideoPacketListHeadPtr		; update head
	TEQ	r2, #0					; and if no more
	STREQ	r2, VideoPacketListTailPtr		; zero tail

	TEQP	r3, #0					; restore IRQs
	MOV	r2, #0
	STR	r2, [r1, #PacketDescriptor_Link]	; terminate link at last freeable packet

	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine] ; free nodes
	EXIT

 |
	BL	VideoFreePacket				; if so then free it
	B	%BT10
 ]

; **************************************************************************
;
;	VideoCheckEndOfPreFill - Check if we've sent enough to pre-fill buffer, so we can unpause it

VideoCheckEndOfPreFill Entry "r0"
	LDR	lr, VideoPreFilling			; are we still in pre-fill
	CMP	lr, #0
	EXIT	EQ					; already playing

	ADR	lr, FIQAmountSent
	LDR	lr, [lr]				; check amount FIQ process has transmitted

	LDR	r0, VideoVBVSize
	CMP	lr, r0
	MOVCS	lr, #0
	STRCS	lr, VideoPreFilling
;	STRCS	lr, DecodedFieldCount			; This is now done when we receive sequence header decode
   [ SendPlaySWI
	BLCS	VideoIssuePlaySWI
   |
	BLCS	VideoSendPlay
   ]
	EXIT


 [ SendPlaySWI

VideoIssuePlaySWI Entry "r0,r1"
	MOV	r0, #StreamFlags_VideoPresent	; indicate video now ready
	LDR	r1, VideoControlStreamHandle
	SWI	XMPEGControl_Play

	EXIT
 ]

; **************************************************************************
;
;	Data stuffing FIQ code

; FIQ register allocation:

; Outside FIQ routine:
;  r8 -> current slot to process
;  r9 -> 32-bit FIFO write address (16 bit address = r9-4)
;  r10 -> 8-bit FIFO write address
;  r13 -> FIQ stack
; Inside routine:
;  r0 -> data
;  r1 = remaining contiguous length we can do this FIQ
;  r2-r7,r11,r14 used to load data
;  r12 = amount of space left in FIFO after this lump
;

; FIQ slot node format

		^	0
FIQSlot_Address #	4
FIQSlot_Length	#	4
FIQSlot_Packet	#	4

FIQSlotSize	*	:INDEX: @

; FIQ workspace layout

		^	&1C
FIQSpaceStart	#	4			; slot for LDR PC, &20
FIQSpacePCLoad	#	4			; slot for address of FIQ routine in module code
FIQAmountSent	#	4			; amount of data sent by FIQ process
 [ Save1stFIQPacket
FIQWorkspacePtr	#	4
 ]
		#	9*4			; 9 words needed for FIQ stack to save r0-r7,r14
FIQStackEnd	#	0

		#	(&100-@) :MOD: FIQSlotSize	; align so that slot space ends on a slot boundary

FIQSlotSpace	#	&100 - @

FIQSlotSpaceSize *	?FIQSlotSpace
	ASSERT	FIQSlotSpaceSize >= FIQSlotSize

FIQCodeStart Entry "r0-r7"			; may not need all these
	MOV	r1, #MPEG2Podule_FIFOLength	; how much we can do now
05
	ASSERT	FIQSlot_Length = FIQSlot_Address +4
	LDMIA	r8, {r0, r2}			; load address + length
	TEQ	r0, #0				; if address zero
	BEQ	%FT90				; then no more data, so disable FIQ in IOMD and exit
10
	SUBS	r12, r1, r2			; amount of FIQ space left after this packet
	MOVCS	r1, r2				; if >=0 then do packet amount in this lump
	MOVCS	r2, #0				; and packet done after this
	RSBCC	r2, r12, #0			; else packet has -r12 left after this FIFO lump
	MOVCC	r12, #0				; and no FIFO space after this packet
	STR	r2, [r8, #FIQSlot_Length]	; store updated length for next time

	ADR	r3, FIQAmountSent
	LDR	r4, [r3]			; add on amount about to be sent
 [ Save1stFIQPacket
	CMP	r4, #?FirstPacket		; if not sent 184 bytes yet
	BCC	%FT95				; then jump to code that saves away the packet
15
 ]
	ADD	r4, r4, r1
	STR	r4, [r3]

	TST	r0, #3
	BNE	%FT40				; do part words
20
	SUBS	r1, r1, #8*4			; enough for 8 whole words?
	LDMCSIA r0!, {r2-r7,r11,r14}
	STMCSIA r9, {r2-r7,r11,r14}
	BHI	%BT20

	ADDCC	r1, r1, #8*4			; if insufficient then revert
30
	SUBS	r1, r1, #4			; enough for 1 whole word
	LDRCS	r2, [r0], #4
	STRCS	r2, [r9]
	BHI	%BT30

;	ADDCC	r1, r1, #4			; (not necessary - we only need to look at bottom 2 bits now)

	TST	r1, #2
	LDRNE	r2, [r0], #2
	STRNE	r2, [r9, #-4]			; write to 16-bit FIFO address

	TST	r1, #1
	LDRNEB	r2, [r0], #1
	STRNEB	r2, [r10]			; write to 8-bit FIFO address

; finished doing that lump

35
	LDR	r2, [r8, #FIQSlot_Length]	; get remaining size
	TEQ	r2, #0				; if some left
	STRNE	r0, [r8, #FIQSlot_Address]	; then update address
	BNE	%FT36

; none left, so mark as finished, and advance to next

	LDR	r3, [r8, #FIQSlot_Packet]	; find real packet descriptor (if any - NB packet header slots don't have one)
	TEQ	r3, #0
	LDRNE	r2, [r3, #PacketDescriptor_Flags] ; mark packet as all sent
	ORRNE	r2, r2, #PacketDescriptorFlags_AllSent
	STRNE	r2, [r3, #PacketDescriptor_Flags]
	MOV	r0, #0				; zero address to store in slot, to mark it as empty
	STR	r0, [r8, #FIQSlot_Address]
	ADD	r8, r8, #FIQSlotSize		; advance to next slot
	CMP	r8, #&100			; wrap if necessary
	ADREQ	r8, FIQSlotSpace
36
	MOVS	r1, r12				; restore amount of space left in FIFO
	BNE	%BT05				; if some then go back and try to do it
37
	PullEnv
	SUBS	pc, lr, #4			; exit from FIQ

; data address not word aligned, so do bytes until it is

40
	SUBS	r1, r1, #1			; if no more bytes left
	BCC	%BT35				; then finished doing that lump
	LDRB	r2, [r0], #1
	STRB	r2, [r10]			; write to 8-bit FIFO address

	TST	r0, #3				; if still not aligned
	BNE	%BT40				; then loop
	B	%BT20				; else enter main section

; no more data, so disable FIQ until we have some

90
	MOV	r1, #IOC
	STRB	r0, [r1, #IOCFIQMSK]		; zero FIQ mask to disable our FIQ
	B	%BT37

 [ Save1stFIQPacket
95
	MOV	r7, r12				; save r12 value in r7 so we can use r12 as wsptr
	ADR	r12, FIQWorkspacePtr
	LDR	r12, [r12]
	ADD	r2, r4, r1			; total length we will have done after this packet
	CMP	r2, #?FirstPacket
	MOVHI	r2, #?FirstPacket		; r2 = total amount we have saved away after this
	STR	r2, SavedPacketLength
	ADR	r5, FirstPacket
	ADD	r5, r5, r4			; advance pointer to where we're up to
	SUB	r2, r2, r4			; and decrement length to how much remaining to do
96
	SUBS	r2, r2, #1			; go backwards through packet
	LDRCSB	r6, [r0, r2]
	STRCSB	r6, [r5, r2]
	BHI	%BT96
	MOV	r12, r7				; put r12 back
	B	%BT15				; and rejoin main code
 ]

; **************************************************************************
;
;	UpdateIR - Atomically update interrupt registers and soft copies
;
; in:	r0 = EOR mask
;	r1 = AND mask

UpdateIR Entry "r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	r2, IRSoftCopy
	AND	r2, r2, r1
	EOR	r2, r2, r0
	STR	r2, IRSoftCopy

	WriteReg r2, IR0
	MOV	r2, r2, LSR #8
	WriteReg r2, IR1
	EXITS

 [ UseWholePackets
; **************************************************************************
;
;	VideoSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:	r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

VideoSendNewPacketIfNecessary Entry "r1-r5, r11"
	LDR	r1, VideoStreamFlags
	EOR	r1, r1, #StreamFlags_PassThroughToVideo
	TST	r1, #StreamFlags_PassThroughToVideo
	EXIT	EQ					; if passing through, don't put our own packet headers on it

	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart	; is it start of an MPEG packet?
	EXIT	EQ					; [no, so no packet header required, exit EQ => try to send data]

 [ FudgeZeroLengthPackets :LOR: TrickPlaySupport
	TST	r1, #PacketDescriptorFlags_FullLengthUnknown	; is it a packet of indeterminate length?
  [ :LNOT: FudgeZeroLengthPackets			; if we're not fudging them all, check we're in correct mode
	LDRNE	r3, TrickPlayMode
	TEQNE	r3, #0					; need to be in TrickPlayMode
	LDRNE	r3, VideoStructureFlags
	TSTNE	r3, #VideoStructureFlags_TrickPlayPacketLengthFix ; and with packet length fixing enabled
  ]
	EXIT	NE					; [yes, so we must wait for length to be determined, exit NE => wait]
 ]

	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	EXIT	NE					; [all slots full, so don't try to send data]

; we need to create a FIQ slot containing the data to send for the packet header
; rather than allocating a new RMA block, we can reuse the 16 bytes in the packet header allocated for the PTS and DTS (yuk!)

 [ AudioSquawkFix1

; Bug 4-20 on the L64002 bug sheet describes something similar sounding to the audio squawk problem, albeit with
; serial input of data. It claims it only happens if the PES packet header is not a multiple of 8 bytes.
; So try padding video packets to a multiple of 8 bytes.
; Unfortunately MPEG 1 system stream format packet header stuffing bytes get discarded in the holding register and don't
; make it into the system buffer, so we have to use MPEG 2 PES packet header instead.
; This takes the form: 00 00 01 E0 lenhi lenlo flags1(80) flags2(00 if no PTS or 80 if PTS) hdrlen
; followed by hdrlen bytes of flags and stuffing (not looked at by L64002)
; in our case we set hdrlen to 7 then add either (5 PTS + 2 FF) or 7 FF

	MOV	lr, #&FFFFFF07
	STR	lr, [r0, #PacketDescriptor_PTS+8]
	MOV	lr, #&FFFFFFFF
	STR	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, #&00800000				; flags1 byte is 80, flags2 byte is 00 for no PTS
	TST	r1, #PacketDescriptorFlags_PTSValid
	STREQ	lr, [r0, #PacketDescriptor_PTS+4]	; no PTS
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS
	ORR	lr, lr, #&80000000			; if PTS then set flags2 byte to 80
	STR	lr, [r0, #PacketDescriptor_PTS+4]	; store it *after* reading real PTS

	MOV	lr, r4, LSR #29				; lr = bits 31..29 in bits 2..0
	ORR	lr, lr, r5, LSL #3			; lr = bits 32..29 in bits 3..0
	ORR	lr, lr, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+9]	; store in packet header block
	MOV	lr, r4, LSR #22				; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+10]	; (only stores bottom 8 bits)
	MOV	lr, r4, LSR #14				; lr = bits 21..14 in bits 7..0
	ORR	lr, lr, #1				; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+11]
	MOV	lr, r4, LSR #7				; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, r4, LSL #1				; lr = bits 6..0 in bits 7..1
	ORR	lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+13]

	MOV	r5, pc
	ORR	lr, r5, #I_bit
	TEQP	lr, #0
	LDR	lr, VideoPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, VideoPTSInCount
	TEQP	r5, #0

30
	MOV	r5, #16					; now padded to 16 bytes whether PTS or not
 |
	TST	r1, #PacketDescriptorFlags_PTSValid
	MOVEQ	lr, #&0F				; termination for no PTS
	STREQB	lr, [r0, #PacketDescriptor_PTS+6]
	MOVEQ	r5, #7					; if no PTS, then just 7 extra bytes
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS

	MOV	lr, r4, LSR #29				; lr = bits 31..29 in bits 2..0
	ORR	lr, lr, r5, LSL #3			; lr = bits 32..29 in bits 3..0
	ORR	lr, lr, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+6]	; store in packet header block
	MOV	lr, r4, LSR #22				; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+7]	; (only stores bottom 8 bits)
	MOV	lr, r4, LSR #14				; lr = bits 21..14 in bits 7..0
	ORR	lr, lr, #1				; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+8]
	MOV	lr, r4, LSR #7				; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+9]
	MOV	lr, r4, LSL #1				; lr = bits 6..0 in bits 7..1
	ORR	lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+10]

	MOV	r5, pc
	ORR	lr, r5, #I_bit
	TEQP	lr, #0
	LDR	lr, VideoPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, VideoPTSInCount
	TEQP	r5, #0

	MOV	r5, #11
30
 ]
	LDR	lr, =&E0010000
	STR	lr, [r0, #PacketDescriptor_PTS+0]	; video packet start code

	LDR	r4, [r0, #PacketDescriptor_FullLength]	; get length of packet payload
	TEQ	r4, #0					; if zero, then leave it at zero
	ADDNE	r4, r4, r5				; else add on length of packet header
	SUBNE	r4, r4, #6				; but don't count start code or length in total length
 [ NobbleL64002VideoPacketLengths
	MOV	r4, #0					; store zero length in packet
 ]
	MOV	lr, r4, LSR #8
	STRB	lr, [r0, #PacketDescriptor_PTS+4]	; store len hi
	STRB	r4, [r0, #PacketDescriptor_PTS+5]	; store len lo

	ADD	r4, r0, #PacketDescriptor_PTS		; point r4 at new packet header
	MOV	lr, #0					; packet field must be zero, cos it's a fake lump
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in FIQ slot

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

	BIC	r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
	STR	r1, [r0, #PacketDescriptor_Flags]	; we don't send hdr again

 [ CountVideoPackets :LAND: {FALSE}
	LDR	lr, VideoPacketsReceived
	ADD	lr, lr, #1
	STR	lr, VideoPacketsReceived
 ]

	TEQ	r0, r0					; set EQ state, so we attempt to send data
	EXIT

	LTORG

 ] ; UseWholePackets

; **************************************************************************
;
;	VideoFreePacket - Free a packet
;
; in:	r0 -> packet descriptor
;	(r11 -> L64002_Registers)
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;	Also updates VideoPacketListHeadPtr, VideoPacketListTailPtr
;	Flags must be preserved
;

VideoFreePacket ROUT
	Push	"r1, lr"
	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0				; disable IRQs round this

	LDR	lr, [r0, #PacketDescriptor_Link]
	STR	lr, VideoPacketListHeadPtr	; update VideoPacketListHeadPtr
	TEQ	lr, #0				; and if no more,
	STREQ	lr, VideoPacketListTailPtr	; then zero VideoPacketListTailPtr

	TEQP	r1, #0				; restore IRQ state

	Push	"lr"
	MOV	lr, #0
	STR	lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
						; (we might want to be able to free multiple packets eventually)
	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine]
	Pull	"r0,r1, pc",,^			   ; exit preserving flags

; **************************************************************************
;
;	SyncOffset_Code - Set offset added to SCR values before programming

SyncOffset_Code Entry
	LDR	wp, [r12]

	LDRB	r1, [r0, #0]
	TEQ	r1, #"-"
	ADDEQ	r0, r0, #1
	MOVEQ	r6, #1
	MOVNE	r6, #0
	MOV	r1, r0
	MOV	r0, #10 :OR: (1:SHL:31) ; insist on space or ctrl char terminator, base 10
	SWI	XOS_ReadUnsigned
	EXIT	VS

	TEQ	r6, #0
	RSBNE	r2, r2, #0
	STR	r2, SyncOffset
	EXIT

; **************************************************************************
;
;	VideoInfo_Code - Output debugging info

VideoInfo_Code Entry "r8"
	LDR	wp, [r12]
	DLINE	"Audio Sample rate: ", cc
	LDR	r0, AudioSampleRate
	ADD	r0, r0, #1
	CMP	r0, #8+1
	BCS	%FT10
	ADRL	lr, AudioSampleRateStringOffsets
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, r0, lr
	SWI	XOS_Write0
	SWIVC	XOS_NewLine
	EXIT	VS
10
 [ Pulldown
        MACRO
        DAuxBlock $block, $extension
      [ "$extension" <> ""
        LDRB    r0, $block._ExtensionID
        TEQ     r0, #0
        BNE     %FT01
        DLINE   "$block layer data not found"
        B       %FT02
      ]
01
	DLINE	"$block layer data: ", cc
	ADRL	r0, $block.Data
	MOV	r1, #:INDEX: $block.DataEnd - :INDEX: $block.Data
	BL	OutputHexBlock
	DLINE	""
02
	MEND

	DAuxBlock VideoSequence
	DAuxBlock SequenceExtension, extension
	DAuxBlock DisplayExtension, extension
	DAuxBlock GroupOfPictures
	DAuxBlock Picture
	DAuxBlock PictureCodingExtension, extension
	DAuxBlock QuantMatrixExtension, extension
	DAuxBlock CopyrightExtension, extension
	DAuxBlock PanAndScanExtension, extension
 |
	DLINE	"Sequence layer data: ", cc
	ADR	r0, VideoSequenceData
	MOV	r1, #12
	BL	OutputHexBlock
	DLINE	""
 ]

 [ VetSCRValues
	LDR	r0, BadSCRCount
	DREG	r0, "Bad SCRs = "
 ]

	LDR	r0, DRAMBufferAddress
	DREG	r0, "DRAM buffer holds contents of address "
	DLINE	"...which are: ", cc
	ADR	r0, DRAMBuffer
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""

	LDR	r0, AudioChannelBufferReadPtr
	DREG	r0, "AudioChannelBufferReadPtr = "

	LDR	r0, AudioPTSInCount
	DREG	r0, "AudioPTSInCount = "

	LDR	r0, AudioFasts
	DREG	r0, "AudioFasts = "
	LDR	r0, AudioSlows
	DREG	r0, "AudioSlows = "

 [ AudioStats
	LDR	r0, AudioAmountReceived
	DREG	r0, "Audio data received = "
	LDR	r0, AudioStartTime
	LDR	r1, AudioLastTime
	SUB	r0, r1, r0
	DREG	r0, "...in time "

	LDR	r0, AudioMaxTimeDifference
	DREG	r0, "Maximum time between audio packets = "

        LDR	r0, AudioTimeOffsetToFirstSlow
	DREG	r0, "Time offset to first audio slow = "
 ]
	LDR	r0, AudioPacketSendTimeouts
	DREG	r0, "Number of timeouts on audio packet header sends = "


	LDR	r0, VideoSkips
	DREG	r0, "Video skips = "
	LDR	r0, VideoRepeats
	DREG	r0, "Video repeats = "
	LDR	r0, VideoPTSInCount
	DREG	r0, "Number of video PTSs that came in = "
	LDR	r0, VideoNumberOfPostedPTSs
	DREG	r0, "Number of posted video PTSs = "
	LDR	r0, VideoPTSPictureTypeCount_I
	DREG	r0, "Number of I-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_P
	DREG	r0, "Number of P-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_B
	DREG	r0, "Number of B-pictures with PTS = "
	LDR	r0, VideoMinPTSDifference
	DREG	r0, "Most negative PTS-SCR = "
	LDR	r0, VideoMaxPTSDifference
	DREG	r0, "Most positive PTS-SCR = "
 [ AllowSyncOnIFrames
	LDR	r0, SyncMode
	DREG	r0, "Sync mode flag = "
	LDR	r0, AnchorFIFOOverruns
	DREG	r0, "Anchor FIFO overruns = "
	LDR	r0, AnchorPostedPTSWritePtr
	DREG	r0, "Anchor PTSs written = "
	LDR	r0, AnchorPostedPTSReadPtr
	DREG	r0, "Anchor PTSs read = "
 ]
 [ CountVideoPackets
	LDR	r0, SyncMode
	DREG	r0, "Sync mode flag = "
	LDR	r0, VideoPacketsReceived
	DREG	r0, "Video packets received = "
	LDR	r0, VideoPicturesReceived
	DREG	r0, "Video pictures received = "
	LDR	r0, VideoOKCount
	DREG	r0, "Number of times no repeat necessary = "

	DLINE	"Video sync statistics"
	DLINE	"  Packets  Pictures"
	LDR	r0, VideoSyncPos
	ADRL	r1, VideoSyncStats
20
	SUBS	r0, r0, #8
	BCC	%FT30
	LDMIA	r1!, {r2, r3}
	DREG	r2, "  ", cc
	DREG	r3, " "
	B	%BT20

30
 ]
 [ TrickPlaySupport
	LDR	r0, TrickStops
	DREG	r0, "Trick stops = "
	LDR	r0, TrickStarts
	DREG	r0, "Trick starts = "
 ]
	LDR	r0, CurrentHorizontalSize
	DREG	r0, "Horizontal size = "
	LDR	r0, CurrentVerticalSize
	DREG	r0, "Vertical size = "
	LDR	r0, CurrentOutputWidth
	DREG	r0, "Horizontal display output size = "
	LDR	r0, VideoVBVSize
	DREG	r0, "Video VBV size = "
	LDR	r0, VideoPreFilling
	DREG	r0, "Video prefilling = "
	LDR	r0, AudioPreFilling
	DREG	r0, "Audio prefilling = "
 [ StartVideoAtSeqHdr
        LDRB    r0, SkippingToSeqHdr
        DREG    r0, "Skipping to sequence header = "
        LDRB    r0, DeferVideoStart
        DREG    r0, "Deferred video start = "
 ]
 [ CountFieldInversions
	LDR	r0, FieldInversions
	DREG	r0, "Field inversions = "
 ]
	LDR	r0, BlankedSequences
	DREG	r0, "Blanked sequences = "
	LDR	r0, BlankedFields
	DREG	r0, "Blanked fields = "

	DLINE	"First item received was: ", cc
	LDR	r0, FirstItemReceived
	CMP	r0, #2
	MOVHI	r0, #3
	ADR	lr, ItemMapTable
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, lr, r0
	SWI	XOS_Write0
	SWI	XOS_NewLine

 [ CountUnderruns
	LDR	r0, VideoChannelUnderruns
	DREG	r0, "Video channel underruns = "
 ]
	DLINE	"** Audio info **"
	ADR	r8, AudioInfoStructure
	BL	OutputInfo

	DLINE	"** Video info **"
	ADR	r8, VideoInfoStructure
	BL	OutputInfo

 [ SaveAPacket
	LDR	r1, SavedPacketLength
	TEQ	r1, #0
	BNE	%FT40
	DLINE	"No saved video packet"
	B	%FT50
40
  [ Save1stFullPacket
	DLINE	"1st video PTS: ", cc
	LDR	r0, SavedPacketPTS +4
	CMP	r0, #-1
	BNE	%FT45
	DLINE	"none"
	B	%FT47
45
	ADR	r0, SavedPacketPTS +4
	MOV	r3, #5
46
	LDRB	r2, [r0], #-1
	BREG	r2, " ", cc
	SUBS	r3, r3, #1
	BNE	%BT46
	DLINE	""
47
	DLINE	"Saved 1st video packet:"
  |
	DLINE	"Saved 1st FIQ packet:"
  ]
	ADR	r0, FirstPacket
	BL	OutputHexBlock
	DLINE	""
50
 ]
	LDR	r0, LastErrorStatus
	DREG	r0, "Last ErrorStatus = "
	LDR	r0, CumulativeErrorStatus
	DREG	r0, "Cumulative ErrorStatus = "
	LDR	r0, VidRecErrors
	DREG	r0, "Video reconstruction errors = "
	LDR	r0, ContextErrors
	DREG	r0, "Context errors = "
	LDR	r0, VLCErrors
	DREG	r0, "VLC errors = "

 [ {FALSE} ; this is probably only useful during development
        DLINE   "Interrupt counts: "
        ADR     r4, IRQCounts
        MOV     r5, #1
01      LDR     r6, [r4, r5, LSL #2]
        BREG    r5,, cc
        DREG    r6
        ADD     r5, r5, #1
        CMP     r5, #16
        BNE     %BT01
 ]
 [ Captions
        LDRB    r0, UserData_dataLength
        BREG    r0, "Last user data packet: length ", cc
        LDRB    r0, UserData_dataType
        BREG    r0, " type ", cc
        TEQ     r0, #&FF
        BNE     %FT01
        LDRB    r0, UserData_extDataType
        BREG    r0,, cc
01      LDR     r0, UserData_dataBytes
        DLINE   " data", cc
01
        BREG    r0,, cc
        MOVS    r0, r0, LSR #8
        BNE     %BT01
        DLINE   ""
 ]

	CLRV
	EXIT

ItemMapTable
	&	NothingString-ItemMapTable
	&	SequenceString-ItemMapTable
	&	PictureString-ItemMapTable
	&	UnknownString-ItemMapTable

NothingString	=	"nothing", 0
SequenceString	=	"a sequence header", 0
PictureString	=	"a picture header", 0
UnknownString	=	"unknown", 0
	ALIGN

OutputInfo Entry
	LDR	lr, [r8, #SI_SISPtr]
	LDR	r0, [lr, #SIS_SystemUnderruns]
	DREG	r0, "System buffer underruns = "
	LDR	r0, [lr, #SIS_DuffChannelAddresses]
	DREG	r0, "Duff channel addresses = "
	LDR	r0, [lr, #SIS_DuffSystemContents]
	DREG	r0, "Duff system buffer contents = "
	LDR	r0, [lr, #SIS_AddressOfLastDuff]
	DREG	r0, "Last duff contents address = "
	LDR	r0, [lr, #SIS_SystemBufferStart]
	DREG	r0, "SystemBufferStart = "
	LDR	r0, [lr, #SIS_SystemBufferEnd]
	DREG	r0, "SystemBufferEnd = "
	LDR	r0, [lr, #SIS_SystemBufferReadPtr]
	DREG	r0, "SystemBufferReadPtr = "
	LDR	r0, [lr, #SIS_SystemBufferWritePtr]
	DREG	r0, "SystemBufferWritePtr = "

	LDR	r2, [r8, #SI_PTSListReadPtr]
	DREG	r2, "PTSListReadPtr = "
	LDR	r3, [r8, #SI_PTSListWritePtr]
	DREG	r3, "PTSListWritePtr = "
	LDR	r0, [r8, #SI_PTSListOverruns]
	DREG	r0, "PTS list overruns = "

 [ {FALSE}
	LDR	r4, [r8, #SI_PTSListPtr]
	LDR	r5, [r8, #SI_PTSListSize]
	DLINE	"PTS List data:"
10
	TEQ	r2, r3
	BEQ	%FT20
	ADD	r0, r4, r2, LSL #3
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""
	ADD	r2, r2, #1
	TEQ	r2, r5
	MOVEQ	r2, #0
	B	%BT10
20
 ]
	CLRV
	EXIT


OutputHexBlock Entry "r0-r2"
10
	LDRB	r2, [r0], #1
	BREG	r2, " ", cc
	SUBS	r1, r1, #1
	BNE	%BT10
	EXIT

AudioSampleRateStringOffsets
	&	SRUK-AudioSampleRateStringOffsets
	&	SR2205-AudioSampleRateStringOffsets
	&	SR2400-AudioSampleRateStringOffsets
	&	SR1600-AudioSampleRateStringOffsets
	&	SRReserved-AudioSampleRateStringOffsets
	&	SR4410-AudioSampleRateStringOffsets
	&	SR4800-AudioSampleRateStringOffsets
	&	SR3200-AudioSampleRateStringOffsets
	&	SRReserved-AudioSampleRateStringOffsets

SRUK	=	"Unknown", 0
SRReserved =	"Reserved", 0
SR2205	=	"22.05kHz", 0
SR2400	=	"24kHz", 0
SR1600	=	"16kHz", 0
SR4410  =	"44.1kHz", 0
SR4800  =	"48kHz", 0
SR3200  =	"32kHz", 0
	ALIGN

; **************************************************************************

 [ RegDebug
ReadL64002_Help
	=	"*ReadL64002 reads an L64002 register.", CR
ReadL64002_Syntax
	=	"Syntax: *ReadL64002 <group> [<index>]", 0
WriteL64002_Help
	=	"*WriteL64002 writes an L64002 register.", CR
WriteL64002_Syntax
	=	"Syntax: *WriteL64002 <group> [<index>] <value>", 0
PacketInfo_Help
	=	"*PacketInfo gives info on video and audio packets held by MPEG2Video", CR
PacketInfo_Syntax
	=	"Syntax: *PacketInfo", 0
	ALIGN


; **************************************************************************
;
;	ReadL64002_Code - Entry point for *ReadL64002 command
;
; Syntax: ReadL64002 <group> [<index>]
; (index is required on groups 6 and 7)

ReadL64002_Code Entry "r11"
	LDR	wp, [r12]
	LDR	r11, L64002_Registers

	MOV	r4, r1					; r4 = number of parameters we had
	MOV	r1, r0					; r1 -> command tail
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #7					; maximum value for group
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r5, r2					; r5 = group
	CMP	r5, #6
	BCS	%FT50					; [reading group 6 or 7, so need index]

; not a banked group, so should be at end of line

	TEQ	r4, #1					; if correct number of parameters
	LDREQB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; then read data
	BEQ	%FT70					; and branch to display code
TooManyParams
	ADRL	r0, TooManyParametersError
	SETV
	EXIT

50
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #63					; maximum value of index is 63
	SWI	XOS_ReadUnsigned
	EXIT	VS

; r5 = group, r2 = index

	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0					; disable IRQs while we do this

	ReadReg r3, AIR					; preserve old AIR
	WriteReg r2, AIR				; set new AIR
	LDRB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; then read data
	WriteReg r3, AIR

	TEQP	r1, #0					; restore IRQ status
70
	DREG	r0, "Value is &"
	CLRV
	EXIT

; **************************************************************************
;
;	WriteL64002_Code - Entry point for *WriteL64002 command
;
; Syntax: WriteL64002 <group> [<index>] <value>
; (index is required on groups 6 and 7)

WriteL64002_Code ALTENTRY
	LDR	wp, [r12]
	LDR	r11, L64002_Registers

	MOV	r4, r1					; r4 = number of parameters we had
	MOV	r1, r0					; r1 -> command tail
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #7					; maximum value for group
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r5, r2					; r5 = group
	CMP	r5, #6
	BCS	%FT50					; [reading group 6 or 7, so need index]

; not a banked group, so should only have 2 parameters

	TEQ	r4, #2					; if incorrect number of parameters
	BNE	TooManyParams

	MOV	r0, #10 :OR: (1:SHL:30)			; restrict value to 0 to 255
	SWI	XOS_ReadUnsigned
	EXIT	VS

	STRB	r0, [r11, r5, LSL #L64002_Register_Address_Shift] ; write data
	B	%FT70					; and branch to common exit code

50
	MOV	r0, #10 :OR: (1:SHL:29) :OR: (1:SHL:31) ; space or ctrl terminator, base 10,
							; limit of 0 to R2 inclusive
	MOV	r2, #63					; maximum value of index is 63
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r4, r2					; r4 = index

; now read value

	MOV	r0, #10 :OR: (1:SHL:30)			; restrict value to 0 to 255
	SWI	XOS_ReadUnsigned
	EXIT	VS

	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0					; disable IRQs while we do this

	ReadReg r3, AIR					; preserve old AIR
	WriteReg r4, AIR				; set new AIR
	STRB	r2, [r11, r5, LSL #L64002_Register_Address_Shift] ; then write data
	WriteReg r3, AIR

	TEQP	r1, #0					; restore IRQ status
70
	CLRV
	EXIT

PacketInfo_Code Entry
	LDR	wp, [r12]

	LDR	r0, VideoPacketListHeadPtr
	BL	CountPackets
	DREG	r1, "Number of video packets = &"
	DREG	r2, "Video packet data length = &"

	LDR	r0, AudioPacketListHeadPtr
	BL	CountPackets
	DREG	r1, "Number of audio packets = &"
	DREG	r2, "Audio packet data length = &"

	CLRV
	EXIT

CountPackets Entry
	MOV	lr, pc
	ORR	lr, lr, #I_bit			; disable IRQs so atomic
	TEQP	lr, #0

	MOV	r1, #0
	MOV	r2, #0
10
	TEQ	r0, #0
	ADDNE	r1, r1, #1			; increment number of packets
	LDRNE	r3, [r0, #PacketDescriptor_Length]
	ADDNE	r2, r2, r3
	LDRNE	r0, [r0, #PacketDescriptor_Link]
	BNE	%BT10

	EXITS					; exit restoring IRQ state

 ] ; RegDebug

 [ AudioDebug
SaveAudio_Help
	=	"*SaveAudio saves the captured audio block to a file.", CR
SaveAudio_Syntax
	=	"Syntax: *SaveAudio <filename>", 0
	ALIGN

SaveAudio_Code Entry
	LDR	wp, [r12]
	MOV	r1, r0				; r1 -> command tail ie the filename
	MOV	r0, #&80
	SWI	XOS_Find
	EXIT	VS
	MOV	r1, r0				; put handle into r1
	MOV	r0, #2				; write at ptr
	ADRL	r2, AudioCaptureBlock		; r2 = start address
	LDR	r3, AudioCaptureBlockLength
	SWI	XOS_GBPB
	MOV	r0, #0
	SWI	XOS_Find
	EXIT
 ]

; **************************************************************************
;
;	VideoStats - Entry point for MPEGVideo_Stats SWI - Return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = video stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

	MACRO
	StatsTableEntry	$tag, $value
 [ :BASE: ($value) = 12
	&	$tag, :INDEX: ($value)
 |
	ASSERT	:BASE: $value = 15
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

VideoStats	Entry "r2, r5-r6"

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	EXIT	EQ				; then exit

	ADR	r6, VideoStatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [wp, lr]
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats


Stats_LengthOfPendingVideoPackets Entry "r0,r1"
	MOV	r0, pc
	ORR	r0, r0, #I_bit			; disable IRQs so atomic
	TEQP	r0, #0

	MOV	r6, #0
	LDR	lr, VideoPacketListHeadPtr
10
	TEQ	lr, #0
	LDRNE	r1, [lr, #PacketDescriptor_Length]
	ADDNE	r6, r6, r1
	LDRNE	lr, [lr, #PacketDescriptor_Link]
	BNE	%BT10
	EXITS					; exit restoring IRQ state

VideoStatsTable
 [ CountUnderruns
	StatsTableEntry &1000, VideoChannelUnderruns
 ]
	StatsTableEntry &1001, VideoAmountReceived
;	StatsTableEntry &1002, AmountSent
;	StatsTableEntry &1003, IRQCounts + 3*4
;  [ RegisterLastFullness
;	StatsTableEntry &1004, LastFullness
;  ]
;	StatsTableEntry &1005, LastAmountSent
;	StatsTableEntry &1006, NumberOfResets
;  [ DontFlushOnEmpty
;	StatsTableEntry &1007, LastFlushDidntHappen
;  ]
;	StatsTableEntry &1008, SpeedSetting
;  [ TrapUnderruns :LOR: CheckCountUnderrunsBit
;	StatsTableEntry &1009, UnderrunCondition
;  ]
;	StatsTableEntry &100A, LastCommandSent
	StatsTableEntry &100B, Stats_LengthOfPendingVideoPackets
	StatsTableEntry &100C, CumulativeErrorStatus
	StatsTableEntry &100D, VidRecErrors
	StatsTableEntry &100E, ContextErrors
	StatsTableEntry &100F, VLCErrors
	StatsTableEntry &1010, TimeOffsetOfVRError

	&	-1

 [ Captions
; Structure of a link in a handler list
                                ^       0
Handler_Next                    #       4       ; -> next link
Handler_Number                  #       4       ; event number that this handler services
Handler_Addr                    #       4       ; address of handler
Handler_Wsptr                   #       4       ; handler's workspace pointer
HandlerSize                     *       @

; **************************************************************************
;
;       RegisterHandler - Entry point for MPEGVideo_RegisterHandler SWI
;
; in:   r0 = handler number
;       r1 -> handler routine
;       r2 -> handler workspace
;
; out:
;       All registers preserved
;

RegisterHandler Entry "r0-r6"
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #HandlerSize
        SWI     XOS_Module              ; claim a new handler block
        STRVS   r0, [sp]
        EXIT    VS

        LDR     r0, Handlers            ; this will become the "next" link
        LDMIA   sp, {r1, r3, r4}        ; get caller r0, r1, r2
        STMIA   r2, {r0, r1, r3-r4}     ; store Next, Number, Addr, Wsptr
        STR     r2, Handlers            ; now that the link is complete, insert it at the head of the list
        EXITS

; **************************************************************************
;
;       DeregisterHandler - Entry point for MPEGVideo_DeregisterHandler SWI
;
; in:   r0 = handler number
;       r1 -> handler routine
;       r2 -> handler workspace
;
; out:
;       All registers preserved
;

DeregisterHandler Entry "r0,r2-r7"
        ADR     r3, Handlers - Handler_Next
01      LDR     r4, [r3, #Handler_Next]
        TEQ     r4, #0                  ; reached the end of the list?
        EXIT    EQ

        ADD     r5, r4, #Handler_Number
        LDMIA   r5, {r5-r7}             ; get details of this handler
        TEQ     r0, r5
        TEQEQ   r1, r6
        TEQEQ   r2, r7
        MOVNE   r3, r4
        BNE     %BT01                   ; loop if not an exact match

        LDR     r5, [r4, #Handler_Next]
        STR     r5, [r3, #Handler_Next] ; remove link from list

        MOV     r0, #ModHandReason_Free
        MOV     r2, r4
        SWI     XOS_Module              ; then free the handler block
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       CallHandler - Used to generate an event at one or more handlers of the same type
;
; in:   r0-r7 hold parameters to the handler routine
;       r8 = handler number
;       Processor is in IRQ mode, interrupts disabled
;
; out:
;       All registers preserved
;

CallHandler Entry "r9"
        MOV     r9, pc
        ORR     lr, r9, #SVC_mode
        TEQP    lr, #0                  ; switch to SVC mode
        NOP
        Push    "r9, r10, r12, r14"

        LDR     r9, Handlers            ; the last time we'll need our own r12 for a while
        TEQ     r9, #0
        BEQ     %FT90
10      LDR     r14, [r9, #Handler_Number]
        TEQ     r8, r14                 ; is it the correct type of handler?
        BNE     %FT20

        ; Call the handler
        LDR     r12, [r9, #Handler_Wsptr] ; get handler workspace pointer
        LDR     r10, [r9, #Handler_Addr]
        MOV     r14, pc                 ; return address = pc + 8
        MOV     pc, r10                 ; BL to the handler routine
        TEQ     r8, #0                  ; was it claimed?

20      ; EQ => we called a handler and it claimed the event
        LDRNE   r9, [r9, #Handler_Next]
        TEQNE   r9, #0
        BNE     %BT10                   ; exit if the event was claimed, or if we ran out of handlers; else loop
90
        Pull    "r9, r10, r12, r14"
        TEQP    r9, #0                  ; restore original processor mode
        NOP
        EXIT
 ]

; **************************************************************************
;
;	AudioOpenStream - Open MPEG audio stream
;
; in:	r0 = flags
;	r1 = control stream handle
;	r2 -> audio parameters structure
;
; out:  r0 = audio stream handle
;

AudioOpenStream Entry "r1,r2, r11"
 [ {FALSE}
	Push	"r0"
	SWI	XOS_WriteI+22
	SWI	XOS_WriteI+12
	DREG	r2, "Audio parameters structure = "
	SWI	OS_ReadC
	Pull	"r0"
 ]
	LDR	r11, L64002_Registers
	STR	r0, AudioStreamFlags
	STR	r1, AudioControlStreamHandle

	MOV	r0, #0
	STR	r0, AudioStreamClosing
	STR	r0, AudioNumberOfPTSs
	STR	r0, AudioInfoStructure+SI_PTSListOverruns
	STR	r0, AudioPacketListHeadPtr
	STR	r0, AudioPacketListTailPtr
	STR	r0, AudioPTSInCount
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioFasts
	STR	r0, AudioSlows
	STR	r0, AudioMuted
	STR	r0, DualMonoChannelSpecifier	; default (stereo)
	STR	r0, AudioFlags			; default
	STR	r0, AudioPacketSendTimeouts

	MOV	r0, #-1
	STR	r0, AudioDiscardedDataCount
	STR	r0, AudioChannelMode		; don't know what mode yet

	TEQ	r2, #0
	BEQ	%FT50				; no audio structure
	LDR	r0, [r2, #AudioStructure_FormatType]
	TEQ	r0, #AudioStructureFormatType_Normal
	BNE	%FT50				; unknown structure format
	LDR	r0, [r2, #AudioStructure_Flags]
	STR	r0, AudioFlags			; save value for later
	TST	r0, #AudioStructureFlags_SpecifyDualMonoChannels
	LDRNE	r0, [r2, #AudioStructure_DualChannelSpecifier]
	STRNE	r0, DualMonoChannelSpecifier	; override default
50
	MOV	r1, #&FFFFFFFF			; maximum value
        ADR	r0, AudioBufferPreFillString
	BL	ReadNumericVariable
	LDRVS	r0, =DefaultAudioPreFillSize
	STR	r0, AudioPreFillSize

        ADR	r0, AudioBufferLowWaterMarkString
	BL	ReadNumericVariable
	LDRVS	r0, =DefaultAudioBufferLowWaterMark
	STR	r0, AudioBufferLowWaterMark

        ADR	r0, AudioBufferHighWaterMarkString
	BL	ReadNumericVariable
	LDRVS	r0, =DefaultAudioBufferHighWaterMark
	STR	r0, AudioBufferHighWaterMark

	BL	AudioReset

	MOV	r0, r12
	CLRV
	EXIT

AudioBufferPreFillString
	=	"MPEG2$AudioBufferPreFill", 0
AudioBufferLowWaterMarkString
	=	"MPEG2$AudioBufferLowWaterMark", 0
AudioBufferHighWaterMarkString
	=	"MPEG2$AudioBufferHighWaterMark", 0
	ALIGN

; **************************************************************************
;
;	AudioFullPackets - Here's some more data
;
; in:	r0 = flags
;	r1 = audio stream handle
;	r2 -> one or more linked bitstream packets

AudioFullPackets Entry "r0,r11"
 [ DiscardPartialPackets
	LDR	lr, AudioHadFirstPacket
	TEQ	lr, #0
	BNE	%FT20					; not skipping partial PES packet
10
	LDR	lr, [r2, #PacketDescriptor_Flags]	; check if packet is start of MPEG packet
	TST	lr, #PacketDescriptorFlags_MPEGStart
	MOVNE	lr, #1					; it is, so indicate we've had 1st packet
	STRNE	lr, AudioHadFirstPacket
	BNE	%FT20					; then continue
	BL	DiscardPacket				; it isn't the start, so throw packet away
	TEQ	r2, #0					; if more packets
	BNE	%BT10					; then loop
	EXIT						; else exit
20
 ]
 [ StartVideoAtSeqHdr
        LDRB    lr, SkippingToSeqHdr
        TEQ     lr, #1
        BEQ     %FT21
        BL      int_audio_full_packets                  ; if we're not skipping video, process packets normally
        EXIT
21
        Push    "r3"                                    ; otherwise, just queue the call
        BL      NewFullPacketsLink
        MOVVC   lr, #1
        STRVC   lr, [r3, #FPQ_VideoAudio]
        STRVC   r0, [r3, #FPQ_Flags]
        STRVC   r1, [r3, #FPQ_StreamHandle]
        STRVC   r2, [r3, #FPQ_PacketList]
        Pull    "r3"
        Debug   skip, "Queuing AudioFullPackets call"
        EXIT


int_audio_full_packets Entry "r0,r11"
 ]
 [ AudioDebug
	Push	"r1-r5"
	MOV	r0, r2
	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart	; is it start of an MPEG packet?
	BEQ	%FT40
	MOV	r3, #0
	BL	AudioSendDebug				; send 1st byte of start code
	BL	AudioSendDebug				; send 2nd byte of start code
	MOV	r3, #1
	BL	AudioSendDebug				; send 3rd byte of start code
	MOV	r3, #&C0
	BL	AudioSendDebug				; send 4th byte of start code
	LDR	r4, [r0, #PacketDescriptor_FullLength]
	TST	r1, #PacketDescriptorFlags_PTSValid

; Bug 4-20 on the L64002 bug sheet describes something similar sounding to the audio squawk problem, albeit with
; serial input of data. It claims it only happens if the PES packet header is not a multiple of 8 bytes.
; So try padding audio packet headers (using MPEG2 PES packet header) to 16 bytes.

	ADD	r4, r4, #10				; add on ten for flags1, flags2, hdrlen, then either 7 pad or 5 PTS+2 pad
	MOV	r3, r4, LSR #8
	BL	AudioSendDebug				; send hi byte of length
	AND	r3, r4, #&FF
	BL	AudioSendDebug				; send lo byte of length
	MOV	r3, #&80				; flags1 (&80)
	BL	AudioSendDebug
	MOVEQ	r3, #&00				; flags2 (&00 if no PTS, &80 if is)
	BL	AudioSendDebug
	MOV	r3, #7					; header len
	BL	AudioSendDebug

	MOVEQ	r3, #&FF				; pad with FF if no PTS
	LDRNE	r4, [r0, #PacketDescriptor_PTS]		; get bits 31..0 of PTS
	LDRNE	r5, [r0, #PacketDescriptor_PTS+4]	; get bit 32 of PTS
	MOVNE	r3, r4, LSR #29				; r3 = bits 31..29 in bits 2..0
	ORRNE	r3, r3, r5, LSL #3			; r3 = bits 32..29 in bits 3..0
	ORRNE	r3, r3, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	BL	AudioSendDebug
	MOVNE	r3, r4, LSR #22				; r3 = bits 29..22 in bits 7..0
	BL	AudioSendDebug				; (only stores bottom 8 bits)
	MOVNE	r3, r4, LSR #14				; r3 = bits 21..14 in bits 7..0
	ORRNE	r3, r3, #1				; force bit 0 to 1 (marker)
	BL	AudioSendDebug
	MOVNE	r3, r4, LSR #7				; r3 = bits 14..7 in bits 7..0
	BL	AudioSendDebug
	MOVNE	r3, r4, LSL #1				; r3 = bits 6..0 in bits 7..1
	ORRNE	r3, r3, #1
	BL	AudioSendDebug
	MOV	r3, #&FF
	BL	AudioSendDebug				; 2 further padding bytes
	BL	AudioSendDebug
40
	LDR	r0, AudioCaptureBlockLength
	RSBS	r11, r0, #AudioCaptureBlockMaxLen	; bytes free
	BLE	%FT60					; if <=0 then block full
	LDR	r1, [r2, #PacketDescriptor_Length]
	CMP	r1, r11					; find min(packet length, bytes free)
	MOVCC	r11, r1
	ADRL	r1, AudioCaptureBlock
	ADD	r1, r1, r0				; r1 -> free space
	ADD	r0, r0, r11				; r0 = new length
	LDR	r2, [r2, #PacketDescriptor_Start]
50
	LDRB	lr, [r2], #1
	STRB	lr, [r1], #1
	SUBS	r11, r11, #1
	BNE	%BT50
	STR	r0, AudioCaptureBlockLength
60
	Pull	"r1-r5"
 ]
	LDR	r11, L64002_Registers
	MOV	r0, pc
	Push	"r0"
	ORR	lr, r0, #I_bit
	TEQP	lr, #0					; disable IRQs round this bit

	LDR	r0, AudioPacketListTailPtr
	TEQ	r0, #0					; if nothing on list
	STREQ	r2, AudioPacketListHeadPtr		; then point head at new packets
	STRNE	r2, [r0, #PacketDescriptor_Link]	; else tail!link = packet
 [ AudioStats
	SWI	XOS_ReadMonotonicTime			; read current time
	LDR	lr, AudioStartTime			; if start time not yet recorded (0)
	TEQ	lr, #0
	STREQ	r0, AudioStartTime			; then first lot of audio data, so save start time
	BEQ	%FT70
	Push	"r0"					; save new lasttime
	LDR	lr, AudioLastTime			; if not first, then calculate how long since last data
	SUB	r0, r0, lr
	LDR	lr, AudioMaxTimeDifference		; adjust max...
	CMP	r0, lr
	STRHI	r0, AudioMaxTimeDifference
	Pull	"r0"
70
	STR	r0, AudioLastTime			; always store last time audio data received
	LDR	lr, AudioAmountReceived			; load count of bytes received
 ]
80
 [ AudioStats
	LDR	r0, [r2, #PacketDescriptor_Length]	; for each packet, add length onto total count
	ADD	lr, lr, r0
 ]
	LDR	r0, [r2, #PacketDescriptor_Link]	; go down list of packets to end
	TEQ	r0, #0
	MOVNE	r2, r0
	BNE	%BT80

 [ AudioStats
	STR	lr, AudioAmountReceived			; save total bytes received
 ]
	STR	r2, AudioPacketListTailPtr		; store new tail pointer
	Pull	"r0"
	TEQP	r0, #0					; restore IRQ state

	EXIT

 [ AudioDebug
AudioSendDebug Entry "r0"
	LDR	lr, AudioCaptureBlockLength
	CMP	lr, #AudioCaptureBlockMaxLen
	EXITS	CS
	ADRL	r0, AudioCaptureBlock
	ADD	r0, r0, lr
	STRB	r3, [r0]
	ADD	lr, lr, #1
	STR	lr, AudioCaptureBlockLength
	EXITS
 ]
 [ DiscardPartialPackets :LOR: StartVideoAtSeqHdr
; in: r2 -> packet to discard by calling packet free routine
; out: r2 -> next packet
; This routine is used instead of FreePacket because the packet
; is not yet on the packet list

DiscardPacket	Entry "r0"
	MOV	r0, r2
	LDR	r2, [r0, #PacketDescriptor_Link]
	MOV	lr, #0
	STR	lr, [r0, #PacketDescriptor_Link]	; terminate this packet
	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine]
	EXIT
 ]

; **************************************************************************
;
;	AudioCloseStream - Close MPEG audio stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGAudio_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:	r0 = flags
;	r1 = audio stream handle
;

AudioCloseStream Entry "r0-r2,r11"
	LDR	r11, L64002_Registers

	LDR	r0, AudioSpeedSetting
	TEQ	r0, #0
	BEQ	%FT50					; [it was paused, so junk data]

	BPL	%FT10					; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

	TEQ	r0, #&80000000
	BEQ	%FT50

   [ SendPlaySWI
	BLCS	AudioIssuePlaySWI
   |
	BLCS	AudioSendPlay
   ]

; wait for data to empty

10
	MOV	r0, #1					; indicate to multiple picture packet checker that we won't get
	STR	r0, AudioStreamClosing			; any more data, so don't hang around
20
	TEQP	pc, #0
	NOP						; allow callbacks
	SWI	OS_EnterOS

	LDR	r0, AudioPacketListHeadPtr		; do we have any outstanding packets?
	CMP	r0, #0					; V := 0
	BNE	%BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
	MOV	r0, #2
	STR	r0, AudioStreamClosing
60
	LDR	r0, AudioPacketListHeadPtr
	CMP	r0, #0				; V := 0
	BLNE	AudioFreePacket
	BNE	%BT60
70
	BL	AudioReleaseInterruptVectors
	LDR	r0, VideoControlStreamHandle		; if video not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, AudioControlStreamHandle		; stream no longer open
	EXIT

; **************************************************************************
;
;	AudioPlay - Start going
;
; in:	r0 = flags
;	r1 = audio stream handle
;
; out:  -
;

AudioPlay Entry "r0,r2, r11"
	LDR	r2, AudioSpeedSetting
	BIC	r2, r2, #&80000000	; clear pre-buffering bit
	STR	r2, AudioSpeedSetting
	BL	AudioSetSpeed
	EXIT

; **************************************************************************
;
;	AudioSetSpeed - Set speed of MPEG stream
;
; in:	r0 = flags
;	r1 = audio stream handle
;	r2 = speed indicator
;	       0    = paused
;	       1    = normal speed
;	       2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

AudioSetSpeed Entry "r0-r2, r11"
	LDR	r11, L64002_Registers
	CMP	r2, #8					; don't allow speeds slower than 8
	MOVHI	r2, #8

 [ :LNOT: SlowMotionSupport
	CMP	r2, #1					; if don't support slow motion
	MOVHI	r2, #1					; treat 2 to 8 as 1 (normal play)
 ]

	LDR	r0, AudioSpeedSetting
	TST	r0, #&80000000				; if pre-buffering
	ORRNE	r2, r2, #&80000000			; then still pre-buffering, but may have speed setting after
	STR	r2, AudioSpeedSetting

	CMP	r2, #1
 [ VetSCRValues
	MOVNE	lr, #0					; if pause or slo-mo, reset vetting state
	STRNE	lr, VetSCRState				; until we receive 1st SCR after return to normal play
 ]
	BLT	%FT20					; [pause (or pre-buffering)]
 [ SlowMotionSupport
	BEQ	%FT10					; [normal speed]
	BL	UpdateMute				; mute the sound
	BL	AudioSendPlay				; but ensure playing
	CLRV
	EXIT
 ]
10
	BL	AudioSendPlay				; normal speed - play
 [ SlowMotionSupport
	BL	UpdateMute				; and unmute if slow motion supported
 ]
	CLRV
	EXIT

20
	BL	AudioSendPause				; set pause mode - no need to do UpdateMute
							; - we can defer it to when they hit play again
	CLRV
	EXIT


 [ SendPlaySWI

AudioIssuePlaySWI Entry "r0,r1"
	MOV	r0, #StreamFlags_AudioPresent	; indicate audio now ready
	LDR	r1, AudioControlStreamHandle
	SWI	XMPEGControl_Play

	EXIT
 ]

; **************************************************************************
;
;	AudioResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = audio stream handle
;
; out:	r2 = estimate of number of bytes discarded

AudioResetStream Entry "r0-r2"
	LDR	r11, L64002_Registers

	MOV	r2, #2				; pretend we're closing, so we don't send any more data to it in background
	STR	r2, AudioStreamClosing

	LDR	r2, AudioDiscardedDataCount	; if we've already just had an MPEGVideo_ResetStream
	CMP	r2, #-1				; then the audio channel buffer's already been flushed
	BNE	%FT10

	BL	AudioGetBufferFullness		; else find current fullness (returns it in r2)
	BL	VideoReleaseInterruptVectors	; just in case
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors

10
	MOV	r0, #-1
	STR	r0, AudioDiscardedDataCount	; zero it for next time

	LDR	r0, AudioPacketListHeadPtr
20
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	AudioFreePacket				; and free the packet
	BNE	%BT20					; then loop

	STR	r2, [sp, #2*4]			; update returned r2 value with byte count

	BL	AudioReset

	MOV	r0, #0
	STR	r0, AudioStreamClosing

	CLRV
	EXIT

; **************************************************************************
;
;	AudioReset - Reset vars and stuff common to OpenStream and ResetStream
;

AudioReset Entry "r0"
	MOV	r0, #0
	STR	r0, AudioAmountSent
	STR	r0, AudioInfoStructure+SI_PTSListReadPtr
	STR	r0, AudioInfoStructure+SI_PTSListWritePtr
	STR	r0, AudioResyncDelay
	STR	r0, AudioLastPTS +0			; zero LastPTS record
	STR	r0, AudioLastPTS +4
 [ AudioStats
	STR	r0, AudioStartTime
	STR	r0, AudioLastTime
	STR	r0, AudioAmountReceived
	STR	r0, AudioMaxTimeDifference
 ]

 [ VetSCRValues
	STR	r0, VetSCRState				; indicate awaiting first SCR
	STR	r0, BadSCRCount				; no bad'uns yet
 ]

 [ AudioDebug
	STR	r0, AudioCaptureBlockLength		; zero record of captured amount
 ]
	MOV	r0, #1
	STR	r0, AudioPreFilling

	MOV	r0, #-1			; set audio sample rate to unknown
	STR	r0, AudioSampleRate
 [ AudioStats
	STR	r0, AudioTimeOffsetToFirstSlow
 ]
	MOV	r0, #&80000001		; indicate pre-buffering, but would otherwise be playing normal speed
	STR	r0, AudioSpeedSetting

	LDR	r0, VideoControlStreamHandle
	TEQ	r0, #0
	BLEQ	InitStream_Common
	BL	AudioClaimInterruptVectors

	LDR	r0, AudioMuted
	BL	AudioMuteSound

	LDR	r0, DualMonoChannelSpecifier
	BL	AudioSetDualMonoChannels

	BL	AudioSetErrorMode	; look at audio flags to determine whether to mute on errors

	EXIT

; **************************************************************************
;
;	AudioFreePacket - Free a packet
;
; in:	r0 -> packet descriptor
;	(r11 -> CL450_Registers)
;	IRQs disabled
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;	Also updates AudioPacketListHeadPtr, AudioPacketListTailPtr
;	Flags must be preserved
;

AudioFreePacket ROUT
	Push	"r1, lr"
	MOV	r1, pc
	ORR	lr, r1, #I_bit
	TEQP	lr, #0				; disable IRQs round this

	LDR	lr, [r0, #PacketDescriptor_Link]
	STR	lr, AudioPacketListHeadPtr	; update AudioPacketListHeadPtr
	TEQ	lr, #0				; and if no more,
	STREQ	lr, AudioPacketListTailPtr	; then zero AudioPacketListTailPtr

	TEQP	r1, #0				; restore IRQ state

	Push	"lr"
	MOV	lr, #0
	STR	lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
						; (we might want to be able to free multiple packets eventually)
	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine]
	Pull	"r0,r1, pc",,^			   ; exit preserving flags

; **************************************************************************
;
;	AudioMuteSound - Mute/unmute sound
;
; in:	r0 = flags
;	  bit 0 = 1   => sound off
;		= 0   => sound on
;	  bits 1..31 reserved - should be zero
;	(r1 = audio stream handle)
;
; out:  -
;

AudioMuteSound Entry "r0"
	AND	r0, r0, #1
	STR	r0, AudioMuted
	BL	UpdateMute
	EXIT

UpdateMute Entry "r0, r11"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	LDR	r0, AudioMuted
	TEQ	r0, #0
 [ SlowMotionSupport
	BNE	%FT10					; if user says mute then definitely mute
	LDR	lr, AudioSpeedSetting			; if user says sound
	CMP	lr, #2					; but audio in slow-mo
	MOVGE	r0, #1					; then mute anyway
	TEQ	r0, #0					; set NE if want to mute
10
 ]
	LDR	r11, L64002_Registers
	ReadRegI lr, AudioModeControl
	BICEQ	lr, lr, #AudioModeControl_AudioSoftMute	; EQ => not muted
	ORRNE	lr, lr, #AudioModeControl_AudioSoftMute ; NE => muted
	WriteRegI lr, AudioModeControl, r0

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSetErrorMode - Set/clear bit controlling mute-on-errors
;

AudioSetErrorMode Entry "r0, r11"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	LDR	r11, L64002_Registers
	ReadRegI lr, AudioModeControl
	LDR	r0, AudioFlags
	TST	r0, #AudioStructureFlags_MuteAudioOnErrors
	BICEQ	lr, lr, #AudioModeControl_AudioMuteOnErrors
	ORRNE	lr, lr, #AudioModeControl_AudioMuteOnErrors
	WriteRegI lr, AudioModeControl, r0

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSetAudioParameters - Do various stuff to audio
;
; in:	r0 = reason code
;	r1 = audio stream handle
;	Other registers depend on reason code

AudioSetAudioParameters ROUT
	CMP	r0, #(AudioSetAudioParametersTableEnd - AudioSetAudioParametersTable) :SHR: 2
	ADDCC	pc, pc, r0, LSL #2
	B	UnknownSetAudioParametersReasonCode
AudioSetAudioParametersTable
	B	AudioSetAudioParameters_MuteOnErrors
	B	AudioSetAudioParameters_DualChannelModeSpecifier
AudioSetAudioParametersTableEnd

UnknownSetAudioParametersReasonCode
	ADRL	r0, BadSetParametersReasonError
	SETV
	MOV	pc, lr

; AudioSetAudioParameters_MuteOnErrors
;
; in:	r0 = reason code (0)
;	r1 = audio stream handle
;	r2 = 0 => don't mute audio on errors
;	     1 => mute audio on errors
;	     -1 => read current state
;
; out:	r2 = old state

AudioSetAudioParameters_MuteOnErrors Entry "r0"
	LDR	lr, AudioFlags
	MOV	r0, lr
	ASSERT	AudioStructureFlags_MuteAudioOnErrors = 1
	CMP	r2, #1
	BICCC	r0, r0, #AudioStructureFlags_MuteAudioOnErrors
	ORREQ	r0, r0, #AudioStructureFlags_MuteAudioOnErrors
	STRLS	r0, AudioFlags
	BLLS	AudioSetErrorMode
	ANDS	r0, r0, #AudioStructureFlags_MuteAudioOnErrors
	EXIT

; AudioSetAudioParameters_DualChannelModeSpecifier
;
; in:	r0 = reason code (1)
;	r1 = audio stream handle
;	r2 = dual channel mode specifier, or -1 to read
;
; out:	r2 = old dual channel mode specifier
;	r3 = current channel type (0 = stereo, 1 = joint stereo, 2 = dual mono, 3 = mono, -1 = unknown)

AudioSetAudioParameters_DualChannelModeSpecifier Entry "r0"
	AND	r0, r2, #3		    ; only bottom 2 bits significant
	CMP	r2, #-1
	LDR	r2, DualMonoChannelSpecifier
	STRNE	r0, DualMonoChannelSpecifier
	BLNE	AudioSetDualMonoChannels
	LDR	r3, AudioChannelMode
	EXIT

; **************************************************************************
;
;	AudioSendPlay - Start decoder playing

AudioSendPlay Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Play
	WriteRegI r0, AudioTrickModes, lr

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSendPause - Stop decoder playing

AudioSendPause Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Pause
	WriteRegI r0, AudioTrickModes, lr

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioSetDualMonoChannels - Set which channels are heard for dual mono
;
; in:	r0 = dual mono selector (00 = stereo, 01 = left, 10 = right)
;

AudioSetDualMonoChannels Entry "r0, r1, r11"
	MOV	lr, pc
	ORR	lr, lr, #I_bit				; disable IRQs around Read/WriteRegI called from fgd
	TEQP	lr, #0

	LDR	r11, L64002_Registers
	ReadRegI r1, AudioTrickModes
	AND	r1, r1, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_DualMonoSelectMask
	AND	r0, r0, #3				; mask off any unwanted bits
	ORR	r1, r1, r0, LSL #AudioTrickModes_DualMonoSelectShift
	WriteRegI r1, AudioTrickModes, lr

	EXITS						; exit restoring IRQ state

; **************************************************************************
;
;	AudioGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

AudioGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, AudioChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, AudioChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	AudioTickerV - Audio TickerV routine

AudioTickerV Entry "r0-r2"
	LDR	r0, AudioCallBackRequested	; is a callback already requested
	TEQ	r0, #0
	EXIT	NE				; if so, don't ask for another
	MOV	r2, pc
	ORR	r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
	TEQP	r1, #0
	NOP
	Push	"r14"
	LDR	r0, AudioStreamFlags
	TST	r0, #StreamFlags_UseCallBacks
	BEQ	%FT20				; [stuff directly]

	ADR	r0, AudioTickerVCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	MOVVC	r0, #1
	STRVC	r0, AudioCallBackRequested	; indicate that we've requested a callback
10
	Pull	"r14"
	TEQP	r2, #0
	NOP
	EXIT

20
	MOV	r0, #1
	STR	r0, AudioCallBackRequested
	BL	AudioTickerVCallBack
	B	%BT10

	LTORG

AudioTickerVCallBack Entry "r0,r1, r11"
 [ EnableIRQsInTickerV
	MOV	lr, pc
	BIC	lr, lr, #I_bit		; enable IRQs
	TEQP	lr, #0
 ]
	LDR	r11, L64002_Registers
	BL	AudioDoStuffWithData
	MOV	r0, #0
	STR	r0, AudioCallBackRequested
	EXIT

	LTORG

AudioDoStuffWithData Entry "r0"
	LDR	r0, AudioStreamClosing	; if stream closing (ie value = 2)
	CMP	r0, #1			; don't send any more data
	EXIT	HI
05
	LDR	r0, AudioPacketListHeadPtr
	TEQ	r0, #0			; do we have any data?
	BEQ	%FT50			; [no, so skip]

 [ UseWholePackets
	BL	AudioSendNewPacketIfNecessary
	BLEQ	AudioSendData
 |
	BL	AudioSendData
 ]
	BLEQ	AudioFreePacket
	BEQ	%BT05
50
	BL	AudioDoStreamSync	; check buffer fullness
	EXIT

; **************************************************************************
;
;	AudioDoStreamSync - Synchronise to stream (if required)
;
; in:	r11 -> L64002_Registers
; out:  -

AudioDoStreamSync Entry "r0-r2"
	LDR	r0, AudioStreamClosing		; if not active, exit
	TEQ	r0, #0
	EXIT	NE

	LDR	r0, AudioSpeedSetting
 [ {TRUE}
; TMD fix bug 10-Nov-98 - LS is wrong since it is true if C=0 or Z=1, but carry not affected by
; TEQ r0, #0, and we want the signed comparison anyway!
	CMP	r0, #0				; if paused (0) or pre-filling (bit 31 set)
	EXIT	LE				; then exit
 |
	TEQ	r0, #0				; if paused (0) or pre-filling (bit 31 set)
	EXIT	LS				; then exit
 ]

	LDR	r0, AudioStreamFlags
	TST	r0, #StreamFlags_SyncToStream	; if not syncing to stream
	EXIT	EQ				; then exit

	LDR	r0, AudioResyncDelay
	SUBS	r0, r0, #1
	STRCS	r0, AudioResyncDelay
	EXIT	CS

	BL	AudioGetBufferFullness		; returned in r2
	STR	r2, LastAudioBufferFullness
 [ BigAudioThresholds
	LDR	lr, AudioAmountReceived
	ADD	r2, r2, lr			; add on amount received
	LDR	lr, AudioAmountSent
	SUB	r2, r2, lr			; but take off what's already sent
 ]
	LDR	lr, AudioBufferChecks
	ADD	lr, lr, #1
	STR	lr, AudioBufferChecks

	LDR	r1, AudioBufferLowWaterMark
	CMP	r2, r1
	MOVCC	r1, #AudioResyncRepeat-1
	STRCC	r1, AudioResyncDelay
	BLCC	AudioPlaySlowFrame

	LDR	r1, AudioBufferHighWaterMark
	CMP	r2, r1
	MOVCS	r1, #AudioResyncRepeat-1
	STRCS	r1, AudioResyncDelay
	BLCS	AudioPlayFastFrame
	EXIT

; **************************************************************************
;
;	AudioPlayFastFrame - Play one audio frame fast
;
; in:	r11 -> L64002 registers
;
; out:  -

AudioPlayFastFrame Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Fast
	WriteRegI r0, AudioTrickModes, lr

	LDR	lr, AudioFasts
	ADD	lr, lr, #1
	STR	lr, AudioFasts
	EXITS					; exit restoring IRQ state

; **************************************************************************
;
;	AudioPlaySlowFrame - Play one audio frame slow
;
; in:	r11 -> L64002 registers
;
; out:  -

AudioPlaySlowFrame Entry "r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; disable IRQs round access

 [ AudioStats
	LDR	r0, AudioTimeOffsetToFirstSlow
	CMP	r0, #-1
	BNE	%FT10
	SWI	XOS_ReadMonotonicTime
	LDR	lr, AudioStartTime
	SUB	r0, r0, lr			; offset from time of first audio packet
	STR	r0, AudioTimeOffsetToFirstSlow
10
 ]
	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Slow
	WriteRegI r0, AudioTrickModes, lr

	LDR	lr, AudioSlows
	ADD	lr, lr, #1
	STR	lr, AudioSlows
	EXITS					; exit restoring IRQ state

 [ UseWholePackets
; **************************************************************************
;
;	AudioSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:	r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

AudioSendNewPacketIfNecessary Entry "r1-r5, r11"
	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart	; is it start of an MPEG packet?
	EXIT	EQ					; [no, so no packet header required, exit EQ => try to send data]

	TST	r1, #PacketDescriptorFlags_AudioPacketHeaderStuffing
	BNE	%FT40

; we've just come in to this packet, so prepare packet header for stuffing

; Bug 4-20 on the L64002 bug sheet describes something similar sounding to the audio squawk problem, albeit with
; serial input of data. It claims it only happens if the PES packet header is not a multiple of 8 bytes.
; So try padding audio packets to a multiple of 8 bytes.
; Unfortunately MPEG 1 system stream format packet header stuffing bytes get discarded in the holding register and don't
; make it into the system buffer, so we have to use MPEG 2 PES packet header instead.
; This takes the form: 00 00 01 C0 lenhi lenlo flags1(80) flags2(00 if no PTS or 80 if PTS) hdrlen
; followed by hdrlen bytes of flags and stuffing (not looked at by L64002)
; in our case we set hdrlen to 7 then add either (5 PTS + 2 FF) or 7 FF

	MOV	lr, #&FFFFFF07
	STR	lr, [r0, #PacketDescriptor_PTS+8]
	MOV	lr, #&FFFFFFFF
	STR	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, #&00800000				; flags1 byte is 80, flags2 byte is 00 for no PTS
	TST	r1, #PacketDescriptorFlags_PTSValid
	STREQ	lr, [r0, #PacketDescriptor_PTS+4]	; no PTS
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS
	ORR	lr, lr, #&80000000			; if PTS then set flags2 byte to 80
	STR	lr, [r0, #PacketDescriptor_PTS+4]	; store it *after* reading real PTS

	MOV	lr, r4, LSR #29				; lr = bits 31..29 in bits 2..0
	ORR	lr, lr, r5, LSL #3			; lr = bits 32..29 in bits 3..0
	ORR	lr, lr, #&21				; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+9]	; store in packet header block
	MOV	lr, r4, LSR #22				; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+10]	; (only stores bottom 8 bits)
	MOV	lr, r4, LSR #14				; lr = bits 21..14 in bits 7..0
	ORR	lr, lr, #1				; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+11]
	MOV	lr, r4, LSR #7				; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+12]
	MOV	lr, r4, LSL #1				; lr = bits 6..0 in bits 7..1
	ORR	lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+13]

	MOV	r5, pc
	ORR	lr, r5, #I_bit
	TEQP	lr, #0
	LDR	lr, AudioPTSInCount			; increment count of PTS's coming in
	ADD	lr, lr, #1
	STR	lr, AudioPTSInCount
	TEQP	r5, #0

30
	LDR	lr, =&C0010000
	STR	lr, [r0, #PacketDescriptor_PTS+0]	; audio packet start code

	LDR	r4, [r0, #PacketDescriptor_FullLength]
	ADD	r4, r4, #16-6				; add on length of new header, not including
							; start code or packet length
	MOV	lr, r4, LSR #8
	STRB	lr, [r0, #PacketDescriptor_PTS+4]	; store len hi
	STRB	r4, [r0, #PacketDescriptor_PTS+5]	; store len lo

	ORR	r1, r1, #PacketDescriptorFlags_AudioPacketHeaderStuffing
	STR	r1, [r0, #PacketDescriptor_Flags]	; indicate in middle of sending
	MOV	r3, #16					; number of bytes to do
	STR	r3, [r0, #PacketDescriptor_BSn]

; and drop thru to...

40
; in middle of sending audio packet header stored in PTS/DTS data; BSn holds no. of bytes still to do

	LDR	r11, L64002_Registers
	LDR	r2, L64002_Audio_Data_Write
	LDR	r4, [r0, #PacketDescriptor_BSn]		; number of bytes still to do
	ADD	r3, r0, #PacketDescriptor_PTS + 16	; r3 -> after end of block
	SUB	r3, r3, r4				; move back to start of data still to send
50
	ReadReg	lr, Status0
	TST	lr, #L64002_Status0_AudioChannelReady
	STREQ	r4, [r0, #PacketDescriptor_BSn]		; store amount still to do
	BEQ	%FT60					; not ready to accept more data
	LDRB	lr, [r3], #1
	STRB	lr, [r2]
	SUBS	r4, r4, #1
	BNE	%BT50

	BIC	r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit
	BIC	r1, r1, #PacketDescriptorFlags_AudioPacketHeaderStuffing ; and clear packet stuffing bit just in case
	STR	r1, [r0, #PacketDescriptor_Flags]	; so if run out of buffer part way thru, we don't send hdr again
	TEQ	r0, r0					; set EQ state, so we attempt to send data
	EXIT

; exit indicating not completely sent packet header

60
	CMP	pc, #0					; set NE, ie not OK to continue
	EXIT

  [ {FALSE} ; no longer used
AudioWaitAndSendByte
	Push	"r0, lr"
	MOV	r0, #1024				; check if read to accept audio data 1024 times
10
	ReadReg	lr, Status0
	TST	lr, #L64002_Status0_AudioChannelReady	; if ready to accept data
	BNE	%FT20					; then skip
	SUBS	r0, r0, #1				; else decrement count
	BNE	%BT10					; if not expired, try again
	LDR	r0, AudioPacketSendTimeouts		; increment number of timeouts
	ADD	r0, r0, #1
	STR	r0, AudioPacketSendTimeouts
	Pull	"r0, lr"
	CMP	pc, #0					; set NE so we will try again later, but it's really
							; broken since we've sent part of the header
	EXIT						; exit from AudioSendNewPacketIfNecessary

20
	STRB	r3, [r2]
	Pull	"r0, pc",,^
  ] ; {FALSE}

 ] ; UseWholePackets

; **************************************************************************
;
;	AudioSendData - Send a block of data
;
; in:	r0 -> packet descriptor
;	r11 -> L64002_Registers
;
; out:	EQ => used up all data in this packet

AudioSendData Entry "r0-r4"
	LDR	r1, [r0, #PacketDescriptor_Start]
	LDR	r3, [r0, #PacketDescriptor_Length]
	CMP	r3, #0					; zero length?
	EXIT	EQ

	BL	AudioGetBufferFullness
	LDR	lr, AudioChannelBufferSize
	SUB	r2, lr, r2				; amount of free space in audio channel buffer

	CMP	r2, r3					; if more than packet size
	MOVHI	r2, r3					; then do packet amount

	MOV	r3, r2					; number left to do (save r2 for later)
	LDR	lr, L64002_Audio_Data_Write
10
	ReadReg	r4, Status0
	TST	r4, #L64002_Status0_AudioChannelReady
	BEQ	%FT15					; [not ready, so exit]

	LDRB	r4, [r1], #1
	STRB	r4, [lr]
	SUBS	r3, r3, #1
	BNE	%BT10
15
	SUB	r2, r2, r3				; number of bytes sent

	LDR	r4, [r0, #PacketDescriptor_Length]
	SUB	r4, r4, r2				; decrement remaining length
	STR	r4, [r0, #PacketDescriptor_Length]

	LDR	lr, AudioAmountSent
	ADD	lr, lr, r2
	STR	lr, AudioAmountSent

	LDR	r3, AudioPreFilling
	TEQ	r3, #0
	BEQ	%FT20

 [ BigAudioThresholds
	LDR	lr, AudioAmountReceived			; use amount received not amount sent, since prefillsize > buffer size
 ]
	LDR	r3, AudioPreFillSize
	CMP	lr, r3
	MOVCS	lr, #0
	STRCS	lr, AudioPreFilling
	BLCS	AudioIssuePlaySWI
20
	STR	r1, [r0, #PacketDescriptor_Start]
	TEQ	r4, #0
	EXIT

; **************************************************************************
;
;	Message stuff


 [ international
CopyError ENTRY "r1-r7"
	BL	open_messagefile
	EXIT	VS
	ADR	r1, MessageFile_Block
	MOV	r2, #0
	LDR	r4, [sp]	; R1 (parameter) -> R4
	MOV	r5, #0
	MOV	r6, #0
	MOV	r7, #0
	SWI	XMessageTrans_ErrorLookup
	EXIT

message_filename
	DCB	"Resources:$.Resources.ARM600.Messages", 0
	ALIGN

open_messagefile ENTRY "r0-r2"
	LDR	r0, MessageFile_Open
	CMP	r0, #0
	EXIT	NE
	ADR	r0, MessageFile_Block
	ADR	r1, message_filename
	MOV	r2, #0
	SWI	XMessageTrans_OpenFile
	STRVS	r0, [sp]
	EXIT	VS
	MOV	r0, #1
	STR	r0, MessageFile_Open
	EXIT

write_r0_message ENTRY "r0-r7"
	BL	open_messagefile
	STRVS	r0, [sp]
	EXIT	VS
	MOV	r1, r0
	ADR	r0, MessageFile_Block
	MOV	r2, #0
	MOV	r4, #0
	MOV	r5, #0
	MOV	r6, #0
	MOV	r7, #0
	SWI	XMessageTrans_Lookup
	STRVS	r0, [sp]
	EXIT	VS
10	LDRB	r0, [r2], #1
	CMP	r0, #" "
	SWICS	XOS_WriteC
	STRVS	r0, [sp]
	EXIT	VS
	BCS	%B10
	SWI	XOS_NewLine
	EXIT
 |
write_r0_message ENTRY "r0"
	SWI	XOS_Write0
	STRVS	r0, [sp]
	EXIT
 ]

SetupData
	BIN	"$SetupFile"
SetupDataEnd

	InsertDebugRoutines

	END
