; > Module
; Source for MPEG 2 Video Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 17-May-94  TMD  0.01		Started work
; 03-Jun-94  TMD  0.02		Variable transparency now possible in 16bpp
; 08-Jun-94  TMD  0.03          Added SWI MPEGVideo_CardControl
; 13-Jun-94  TMD  0.04          Added bodge for audio IRQ booboo
; 24-Jun-94  TMD  0.05          Started putting synchronisation stuff in
; 07-Jul-94  TMD  0.06          New stuffing strategy implemented - stuff on a callback from TickerV
; 18-Jul-94  TMD  0.10          Release for Malcolm's trip
; 22-Jul-94  TMD  0.11          Added SyncOffset command
; 29-Jul-94  TMD  0.13          Modified CloseStream behaviour to wait until empty unless paused, in which case junk data
; 17-Aug-94  TMD  0.14          Made transition from pause or slomo to normal set the SCR to the last received PTS
;                                before sending Play command.
; 18-Aug-94  TMD  0.15          Added MPEGVideo_ReadParameters (Read time code)
; 19-Aug-94  TMD  0.16          Started putting in skip to GOP or sequence header stuff (incomplete)
; 22-Aug-94  TMD  0.17          On close, if still in initial pause state, then send Play command.
; 22-Aug-94  TMD  0.18          (Conditionally) enable IRQs inside TickerV during foreground stuffing.
; 26-Aug-94  TMD  0.19          Only enable IRQs in TickerV if not doing AudioIRQBodge.
; 31-Aug-94  TMD  0.20          (Conditionally) select fast (type C) podule access.
; 31-Aug-94  TMD  0.21          Added support for directly calling SetSCR.
; 01-Sep-94  TMD  0.22          Added code to time completion of previous command.
; 05-Sep-94  TMD  0.23          (Conditionally) throw away PTSs if they are within a range of the last one sent.
; 08-Sep-94  TMD  0.24          Pass flags to MPEGControl_Play
; 08-Sep-94  TMD  0.25          Started to add MPEG still capability
; 09-Sep-94  TMD  0.26          (Conditionally) throw away SCRs if they are within a range of the last one sent.
; 09-Sep-94  TMD  0.27          (Conditionally) check packets for more than one picture_start code
; 12-Sep-94  TMD  0.28          Added reason code 2 (Update Control register) to MPEGVideo_CardControl
;                               Check existence of system variable 'TVOn' to determine whether to enable CTRL0, CTRL1 on init
; 10-Oct-94  TMD  0.29          If waiting for stream to close, don't stop sending an incomplete packet in order to check it.
; 12-Oct-94  TMD  0.30          Don't print warning message on zero-length packets
; 20-Oct-94  TMD  0.31          Fixed stack-imbalance in MyAudioIRQRoutine
; 07-Nov-94  TMD  0.32          Remember speed setting if received while pre-buffering
; 07-Nov-94  TMD  0.33          When we start playing, set the SCR to the last received PTS value, so -noaudio works from
;                                middle of file
; 16-Nov-94  TMD  0.34          Changes to support MPEG 2 indeterminate-length packets.
; 05-Dec-94  TMD  0.35          Reverse length correction for odd-length packets
; 07-Dec-94  TMD  0.36          Start putting in skipping until GOP or sequence_header by blanking display
;                                until we get the appropriate IRQ from CL450
; 12-Dec-94  TMD  0.37          Separate out the options for SEQ, GOP or PIC skipping.
; 14-Dec-94  TMD  0.38          Created 'M' variant for CC/Wild Vision Movie Magic card.
; 14-Dec-94  TMD  0.39          Added 'NoInterlace' bit to video flags
; 15-Dec-94  TMD  0.40          Fixed accidental V set returning when pausing while pre-buffering.
;                               Fixed CloseStream hanging if we aborted while pre-buffering.
; 15-Dec-94  TMD  0.41          Always enable PIC-V IRQ but don't unblank on it unless the appropriate bit
;                               is set in VideoStructure_Flags. This is because SEQ-V and GOP IRQs seem to be
;                               inhibited on certain clips if PIC-V is not also enabled.
; 17-Feb-95  TMD  0.42		Change product-type matching code for recognition of podule:
;				 No longer match &0000 in any version
;				 Do allow &00F9 in all versions (as well as &00FF in non-'M' versions)
; 06-Mar-95  TMD  0.43		Added MPEGVideo_ResetStream (initial implementation)
; 16-Mar-95  TMD  0.44		Fixed bug which cleared -nocls and -nopalettechange flags if skipping to pic,seq, or gop
; 28-Apr-95  TMD  2.00		MPEG 2 L64002 version, adapted from MPEG 1 CL450 version
; 25-Jan-96  TMD  2.01		New version for Rev.C chip
; 11-Sep-96  TMD  2.02		Make modulator boost bit reflect CTRL1
; 11-Sep-96  TMD  2.03		Check product type at run time to determine whether to program Japanese DACs or not
;

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

ControlRegisterSoftCopy * &1584

VIDC    *       &03500000

MPEG_sequence_header_code       *       &B3
MPEG_group_start_code           *       &B8

L64002_Registers_Ptr	RN	11	; use R11 to point to L64002 registers
DRAMControlSoftCopy	*	&D0	; used for DRAMRead macro

	GBLL	NYI
NYI	SETL	{FALSE}			; flags to use for bits that are not yet implemented

	GBLL	DoPEH
DoPEH	SETL	{FALSE}			; register program element handler

; Structure of a PTS list entry

			^	0
PTSList_PTS		#	4	; bits 31..0 of PTS
PTSList_AddressPointer	#	4	; bit 0 = bit 32 of PTS, bits 10..31 = address pointer (in units of 8 bytes)
PTSListSize		*	@

VideoPTSListEntries	*	256	; for now
AudioPTSListEntries	*	256	; for now

MaxPTSError		*	3600	; at 25 frames/second, this is 1 frame

; Picture coding types

PictureCodingType_I	*	1
PictureCodingType_P	*	2
PictureCodingType_B	*	3

; Picture rate indices

PictureRate_23976	*	1
PictureRate_24000	*	2
PictureRate_25000	*	3
PictureRate_29970	*	4
PictureRate_30000	*	5
PictureRate_50000	*	6
PictureRate_59994	*	7
PictureRate_60000	*	8

; Structure of a streaminfo structure (one for audio and one for video)

			^	0
SI_ChannelBufferStart	#	4	; L64002 byte address of start of channel buffer
SI_ChannelBufferEnd	#	4	; L64002 byte address of end+1 of channel buffer
SI_PTSListPtr		#	4	; Address of corresponding PTS List
SI_PTSListReadPtr	#	4	; read pointer for list, in range 0..PTSListEntries-1
SI_PTSListWritePtr	#	4	; write pointer for same
SI_PTSListSize		#	4	; size of this PTS List
SI_PTSListOverruns	#	4	; number of overruns of PTS list
SI_SISPtr		#	4	; pointer to appropriate SIS structure
SISize			*	@

; Structure of a streaminfo system structure

			^	0
SIS_SystemBufferStart	#	4	; L64002 byte address of start of system buffer
SIS_SystemBufferEnd	#	4	; L64002 byte address of end+1 of system buffer
SIS_SystemBufferReadPtr	#	4	; L64002 byte address of where we've read to in system buffer
SIS_SystemBufferWritePtr #	4	; Last known value of SystemBufferWritePtr (in bytes)
SIS_DuffChannelAddresses #	4	; count of how many duff channel addresses found in system buffer
SIS_DuffSystemContents	#	4	; count of how many times we got rubbish in the system buffer
SIS_AddressOfLastDuff	#	4	; DRAM address where last rubbish in system buffer appeared
SIS_SystemUnderruns	#	4	; number of underruns of system buffer
SIS_SystemWrite0Group	#	4	; L64002 register group for system write ptr 0
SIS_SystemWrite0Reg	#	4	; L64002 register within group for system write ptr 0
SISSize			*	@

; Workspace declarations

			^	0, wp

; Variables valid outside of open stream

Podule_Base             #       4       ; address of base of podule
Podule_ControlStatus1   #       4       ; address of podule control/status 1 register
Podule_ControlStatus2   #       4       ; address of podule control/status 2 register
L64002_Registers	#	4	; base address of L64002 registers
L64002_Audio_Data_Write #	4	; audio data write address
L64002_Video_Data_Write #	4	; direct writing of video data (not using FIFO)
FIFO_8_Bit_Write	#	4	; 8 bit FIFO writes
FIFO_16_Bit_Write	#	4	; 16 bit FIFO writes
FIFO_32_Bit_Write	#	4	; 32 bit FIFO writes

PoduleControlSoftCopy	#       4	; soft copy of combined control registers 1 (bits 0..7) and 2 (bits 8..15)
PoduleHeaderBuffer      #       16      ; used to read podule headers
SyncOffset              #       4       ; amount to add to clock values
CommonInterruptVectorsClaimed #	4       ; NZ => interrupt vectors common to audio + video claimed
VideoInterruptVectorsClaimed #	4	; NZ => video interrupt vectors claimed
AudioInterruptVectorsClaimed #	4	; NZ => audio interrupt vectors claimed
VideoCallBackRequested	#	4	; whether a callback is outstanding
AudioCallBackRequested	#	4	; whether a callback is outstanding

VideoControlStreamHandle #	4	; control stream handle passed in to MPEGVideo_OpenStream
AudioControlStreamHandle #	4	; control stream handle passed in to MPEGAudio_OpenStream


; Variables only valid while stream open: general

IRQCounts               #       16*4    ; counts of each type of IRQ we've had
Status0SoftCopy		#	4	; soft copy of status 0 register
SCROffset		#	8	; offset to add to H/W SCR to get current S/W SCR

; Variables only valid while stream open: video

VideoPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
VideoPacketListTailPtr	#	4	; pointer to tail of list
VideoChannelBufferSize	#	4	; size of video channel buffer, in bytes
VideoVBVSize		#	4	; size of video needed before unpausing
VideoInfoStructure	#	SISize
VideoSystemInfoStructure #	SISSize

BorderLeft              #       4       ; left hand border
BorderTop               #       4       ; top border

UnknownLengthPacket	#	4	; points to 1st packet in chain forming an indeterminate length packet, or zero if none
					; (only allowed in video stream, fortunately)

VideoPreFilling		#	4	; NZ => pre-filling
VideoStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
VideoStreamFlags	#	4	; stream flags
VideoSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
VideoLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
VideoNumberOfPTSs	#	4	; number of PTSs sent
VideoAmountQueued	#	4	; amount passed to background FIQ process
VideoPTSInCount		#	4	; number of video PTSs received from MPEGControl
DecodedFieldCount	#	4	; -1 when inactive or decoder not yet started, else number of fields after decoder start
					; until we've unblanked, then -1 again
FIQSlotWritePtr		#	4	; address within FIQSlotSpace to write next (address,length) pair to
VideoPostedPTS		#	8	; PTS posted for comparison on start of next odd field
VideoNumberOfPostedPTSs	#	4	; number of video PTSs posted for comparison
VideoSkips		#	4	; number of skipped frames
VideoRepeats		#	4	; number of repeated frames
VideoPTSPictureTypeCounts #	0	; counts of number of PTSs on I, P and B type pictures
			#	4	; dummy entry for type 0
VideoPTSPictureTypeCount_I #	4	; number of PTSs on I-pictures
VideoPTSPictureTypeCount_P #	4	; number of PTSs on P-pictures
VideoPTSPictureTypeCount_B #	4	; number of PTSs on B-pictures
VideoMinPTSDifference	#	4	; worst negative difference between PTS and SCR
VideoMaxPTSDifference	#	4	; worst positive difference between PTS and SCR
LastVideoPTSErrorSign	#	4	; SGN(last PTS-SCR) ie 0,-1 or 1; we only skip or repeat if 2 contiguous errors of same sign

; Variables only valid while stream open: audio

AudioPacketListHeadPtr	#	4	; pointer to head of list of packet descriptors
AudioPacketListTailPtr	#	4	; pointer to tail of list
AudioChannelBufferSize	#	4	; size of audio channel buffer, in bytes
AudioInfoStructure	#	SISize
AudioSystemInfoStructure #	SISSize

AudioChannelBufferReadPtr #	4	; Last known value of AudioChannelBufferReadPtr (in bytes)

AudioPreFilling		#	4	; NZ => pre-filling
AudioStreamClosing	#	4	; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang around
					; on partial packet at end; 2 => don't send any more.
AudioStreamFlags	#	4	; stream flags
AudioSpeedSetting	#	4	; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
AudioLastPTS		#	8	; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
AudioNumberOfPTSs	#	4	; number of PTSs sent
AudioAmountSent		#	4	; amount of data sent
AudioPTSInCount		#	4	; number of audio PTSs received from MPEGControl

AudioSampleRate		#	4	; -1 for unknown, 0..7 => 22.05, 24, 16, reserved, 44.1, 48, 32, reserved
AudioResyncDelay	#	4	; counts down number of centisecond ticks till we check audio buffer fullness again
AudioFasts		#	4	; number of audio frames played "fast"
AudioSlows		#	4	; number of audio frames played "slow"
LastAudioBufferFullness	#	4	; last audio buffer fullness after stuffing
AudioBufferChecks	#	4	; number of checks on audio buffer fullness

 [ VetSCRValues
VetSCRState		#	4	; 0 => awaiting 1st SCR, 1 => last SCR was good, 2 => last SCR was bad
GoodSCROffset		#	4	; SCR-<monotonic time>*900, for the last good SCR value
BadSCROffset		#	4	; ditto, for the last bad SCR value
BadSCRCount		#	4	; count of the number of bad SCR values
SCRAcceptableRange	*	&6000	; about a 1/4 of a second, in 90kHz units
 ]

; New stuff for L64002

IRSoftCopy		#	4	; soft copies of interrupt mask registers
DRAMBuffer		#	8	; temporary buffer for reading L64002 DRAM into
DRAMBufferAddress	#	4	; base address correponding to contents of DRAM buffer
CardProductType		#	4	; product type of MPEG 2 card (or -1 if unrecognised)

; Areas copied out of Aux FIFO

VideoSequenceData		#	0
VideoSequence_HorizontalSize	#	2
VideoSequence_VerticalSize	#	2
VideoSequence_PelAspectRatio	#	1
VideoSequence_PictureRate	#	1
VideoSequence_BitRate		#	3
VideoSequence_VBVBufferSize	#	2
VideoSequence_Misc		#	1

SequenceExtensionData		#	7
DisplayExtensionData		#	9
GroupOfPicturesData		#	6

PictureData			#	0
Picture_TemporalReference	#	2
Picture_PictureCodingType	#	1
Picture_VBVDelay		#	2

QuantMatrixExtensionData 	#	1
PanAndScanExtensionData 	#	7
PictureCodingExtensionData	#	20

	AlignSpace

 [ SkippingCode
StartSkipCode           #       4       ; bottom byte of start code to skip to initially, or zero if no skip
 ]

VideoStructureFlags     #       4
VideoInputType		#	4	; specifies what format of input is passed to MPEG2Video
CurrentHorizontalSize	#	4	; specifies what horiz size was at last sequence header
CurrentVerticalSize	#	4	; ditto for vertical size
CurrentTVFormat		#	4	; ditto for TV format (0=PAL, 1=NTSC)
CurrentOutputWidth	#	4	; either 704 or 720 as appropriate

; Large blocks

VideoPTSList		#	PTSListSize * VideoPTSListEntries
AudioPTSList		#	PTSListSize * AudioPTSListEntries

 [ FullLengthStats
LengthStatsArraySize    *       8192    ; room for this number of entries (each 1 word full length)
LengthStatsPosition     #       4       ; position in array
LengthStatsArray        #       LengthStatsArraySize *4
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

Module_WorkspaceSize * :INDEX: @

VideoPreFillSize	*	200*1024	; amount to send before starting - goes up to 224K for MPEG 2
AudioPreFillSize	*	4096

; The following are 1st guesses

AudioBufferLowWaterMark *	&0C00		; 3 K
AudioBufferHighWaterMark *	&1400		; 5 K
AudioResyncRepeat * 		10		; 10cs between successive attempts at going fast or slow

        GBLL    debug
debug   SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   $string, $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, $string, $cc, $routine
 ]
        MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGVideoSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "MPEG2Video", 0

Mod_HelpStr
        =       "MPEG2Video", TAB, "2.03 (11 Sep 1996)", 0
        ALIGN

Mod_SWITable
        =       "MPEGVideo", 0
        =       "OpenStream", 0
        =       "FullPackets", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
        =       "CardControl", 0
        =       "SetSCR", 0
        =       "ReadParameters", 0
	=	"ResetStream", 0
        =       "DisplayStill", 0
        =       0
        ALIGN

Mod_HC_Table
        Command SyncOffset, 1, 1
        Command VideoInfo, 0, 0
        =       0

SyncOffset_Help
        =       "*SyncOffset sets the offset to be added to the clock value"
        =       " before programming into the L64002.", CR
SyncOffset_Syntax
        =       "Syntax: *SyncOffset <value>", 0
VideoInfo_Help
        =       "*VideoInfo outputs debugging info.", CR
VideoInfo_Syntax
        =       "Syntax: *VideoInfo", 0
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

debug SETL {FALSE}

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

	DLine	"Calling FindPoduleNumber"

        BL      FindPoduleNumber
        EXIT    VS

	DLine	"Calling Podule_ReadInfo"

        MOV     r0, #Podule_ReadInfo_EASILogical
        ADR     r1, Podule_Base
        MOV     r2, #4
        SWI     XPodule_ReadInfo
        EXIT    VS

        LDR     r0, Podule_Base
        ADD     r1, r0, #Offset_Podule_ControlStatus1
        STR     r1, Podule_ControlStatus1
	ADD	r1, r0, #Offset_Podule_ControlStatus2
	STR	r1, Podule_ControlStatus2
	ADD	r1, r0, #Offset_L64002_Registers
	STR	r1, L64002_Registers
	ADD	r1, r0, #Offset_L64002_Audio_Data_Write
	STR	r1, L64002_Audio_Data_Write
	ADD	r1, r0, #Offset_L64002_Video_Data_Write
	STR	r1, L64002_Video_Data_Write
	ADD	r1, r0, #Offset_FIFO_8_Bit_Write
	STR	r1, FIFO_8_Bit_Write
	ADD	r1, r0, #Offset_FIFO_16_Bit_Write
	STR	r1, FIFO_16_Bit_Write
	ADD	r1, r0, #Offset_FIFO_32_Bit_Write
	STR	r1, FIFO_32_Bit_Write

        MOV     r0, #0
        STR     r0, CommonInterruptVectorsClaimed
	STR	r0, VideoInterruptVectorsClaimed
	STR	r0, AudioInterruptVectorsClaimed
        STR     r0, SyncOffset
	STR	r0, VideoCallBackRequested
	STR	r0, AudioCallBackRequested
	STR	r0, VideoControlStreamHandle
	STR	r0, AudioControlStreamHandle
	STR	r0, AudioResyncDelay
	STR	r0, AudioFasts
	STR	r0, AudioSlows
	STR	r0, AudioBufferChecks

	ADR	r0, VideoPTSList
	STR	r0, VideoInfoStructure+SI_PTSListPtr
	MOV	r0, #VideoPTSListEntries
	STR	r0, VideoInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_VideoSystemWrite0_Addr1
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_VideoSystemWrite0_Addr2
	STR	r0, VideoSystemInfoStructure+SIS_SystemWrite0Reg

	ADRL	r0, AudioPTSList
	STR	r0, AudioInfoStructure+SI_PTSListPtr
	MOV	r0, #AudioPTSListEntries
	STR	r0, AudioInfoStructure+SI_PTSListSize
	MOV	r0, #L64002_AudioSystemWrite0_Addr1
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Group
	MOV	r0, #L64002_AudioSystemWrite0_Addr2
	STR	r0, AudioSystemInfoStructure+SIS_SystemWrite0Reg
	ADR	r0, AudioSystemInfoStructure
	STR	r0, AudioInfoStructure+SI_SISPtr		; system buffer for audio is always the audio system buffer

 [ BoardIssue < 3
	DLine	"Initing SAA7167"

	BL	InitSAA7167		; only needs doing once, so do it here
 ]

; Now read existence of variable 'TVOn' to see whether to set CTRL0 and CTRL1 on or off

        Push    "r0,r1"
        ADR     r0, TVOnString
        MOV     r1, #0
        MOV     r2, #-1
        MOV     r3, #0
        MOV     r4, #0
        SWI     XOS_ReadVarVal
        Pull    "r0,r1"

	DLine	"Initialising Control registers"

        TEQ     r2, #0
        MOVEQ   r2, #MPEG2PoduleControl_CLKSelect       ; var doesn't exist, so TV off
        MOVNE   r2, #MPEG2PoduleControl_CTRL1 :OR: MPEG2PoduleControl_CTRL0 :OR: MPEG2PoduleControl_CLKSelect ; var exists, TV on
        STR     r2, PoduleControlSoftCopy
	LDR	r1, Podule_ControlStatus1
	STRB	r2, [r1]
	LDR	r1, Podule_ControlStatus2
	MOV	r2, r2, LSR #8
	STRB	r2, [r1]

        DLine	"Returned from initialising Control registers"

; now claim unknown SWI vector, to trap the MPEGAudio SWIs

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Claim

 [ DoPEH
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_RegisterProgramElementHandler
 ]

	CLRV
        EXIT

TVOnString
        =       "TVOn", 0
        ALIGN

	LTORG

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

	BL	CheckStreamOpen
	BNE	%FT90					; [there's a stream open so refuse to die]

 [ DoPEH
	MOV	r0, #0			; flags
	MOV	r1, #1			; MPEG 2 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
	MOV	r0, #0			; flags
	MOV	r1, #2			; MPEG 1 video stream type
	ADR	r2, VideoStreamHandler
	MOV	r3, wp
	SWI	XMPEGControl_DeregisterProgramElementHandler
 ]

	MOV	r0, #UKSWIV
	ADR	r1, UnknownSWI
	MOV	r2, wp
	SWI	XOS_Release

        CLRV
        EXIT

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"MPEG2Video cannot die as there is a stream open to it", 0
	ALIGN

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
	TEQ	r1, #Service_PreReset
	MOVNE	pc, lr			; if not pre-reset, do nothing

	LDR	wp, [r12]
	Push	"lr"
	BL	VideoReleaseInterruptVectors
	BL	AudioReleaseInterruptVectors
	BL	CommonReleaseInterruptVectors
	Pull	"pc"

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #MPEGVideoSWICheckValue - MPEGVideoSWI_Base
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
        B       VideoOpenStream		; open stream
        B       VideoFullPackets	; new data
        B       VideoCloseStream	; close stream
        B       VideoPlay		; start playing
        B       VideoSetSpeed		; may encompass pause/slow/fast/rewind
        B       CardControl		; general control of MPEG card (used by audio module)
        B       VideoSetSCR          	; set SCR value in L64002
        B       ReadParameters  	; read various parameters
	B	VideoResetStream	; discard data and reset
        B       DisplayStill    	; display 2-field MPEG still picture

NoSuchSWI
        ADRL    r0, NoSuchSWIError
        SETV
        MOV     pc, lr

; **************************************************************************
;
;	UnknownSWI - Entry point for UKSWIV, to trap MPEGAudio SWIs
;
; in:	r11 = SWI number
;	r0-r8 as per SWI entry

UnknownSWI Entry
	LDR	lr, =MPEGAudioSWI_Base
	SUB	lr, r11, lr
	CMP	lr, #MPEGAudio_MuteSound + 1 - MPEGAudioSWI_Base
	EXIT	HI			; [not an MPEGAudio SWI that we know about]

	STR	r11, [sp]		; overwrite pass-on address with r11
	MOV	r11, lr
	MOV	lr, pc
	ADD	pc, pc, r11, LSL #2
	Pull	"r11, pc"		; restore r11 and exit claiming vector
	B	AudioOpenStream
	B	AudioFullPackets
	B	AudioCloseStream
	B	AudioPlay
	B	AudioSetSpeed
	B	AudioSkipFrame
	B	AudioRepeatFrame
	B	AudioResetStream
	B	AudioMuteSound

debug SETL {FALSE}

 [ DoPEH
; **************************************************************************
;
;	VideoStreamHandler - Handler for video stream
;
; in:	r0 = reason code
;	r12 = wp
;	Others as appropriate

VideoStreamHandler ROUT
        CMP     r0, #(VideoHandlerDespatchTableEnd - VideoHandlerDespatchTable) :SHR: 2
        ADDCC   pc, pc, r0, LSL #2
	B	UnknownHandlerReasonCode
VideoHandlerDespatchTable
	B	VSH_OpenStream
	B	VSH_DataTransfer
	B	VSH_CloseStream
VideoHandlerDespatchTableEnd

UnknownHandlerReasonCode
        ADRL    r0, UnknownHandlerReasonError
        SETV
        MOV     pc, lr

UnknownHandlerReasonError
	&	0
	=	"Unknown video handler reason code", 0
	ALIGN

; VSH_OpenStream
; Don't bother to do much here yet, as MPEGVideo_OpenStream is still issued
; Just return a non-zero handle

; VSH_CloseStream - do nowt

VSH_OpenStream
	MOV	r0, #1
VSH_CloseStream
	CLRV
	MOV	pc, lr

; VSH_DataTransfer
; Just move the packet descriptor pointer (in r3) into r2 (we can corrupt r0-r3)

VSH_DataTransfer
	MOV	r2, r3
	B	VideoFullPackets

 ] ; DoPEH
; **************************************************************************
;
;       VideoOpenStream - Open MPEG video stream
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> video parameters structure
;
; out:  r0 = video stream handle
;

VideoOpenStream Entry "r1,r2, r11"
        LDR     r11, L64002_Registers
        STR     r0, VideoStreamFlags
        STR     r1, VideoControlStreamHandle

	LDR	lr, [r2, #VideoStructure_Flags]
	STR	lr, VideoStructureFlags

	TST	lr, #VideoStructureFlags_InputTypeExtension
	LDRNE	lr, [r2, #VideoStructure_InputType]	; if input type specified, use it
	MOVEQ	lr, #0					; else indicate unknown
	STR	lr, VideoInputType

        MOV     r1, #0
        STR     r1, VideoStreamClosing
        STR     r1, VideoNumberOfPTSs
        STR     r1, UnknownLengthPacket
        STR     r1, VideoPacketListHeadPtr
        STR     r1, VideoPacketListTailPtr
	STR	r1, VideoPTSInCount
	STR	r1, VideoInfoStructure+SI_PTSListReadPtr
	STR	r1, VideoInfoStructure+SI_PTSListWritePtr
	STR	r1, VideoInfoStructure+SI_PTSListOverruns
	STR	r1, VideoSkips
	STR	r1, VideoRepeats
	STR	r1, VideoNumberOfPostedPTSs
	STR	r1, VideoPTSPictureTypeCounts +0
	STR	r1, VideoPTSPictureTypeCounts +4
	STR	r1, VideoPTSPictureTypeCounts +8
	STR	r1, VideoPTSPictureTypeCounts +12
	STR	r1, VideoMinPTSDifference
	STR	r1, VideoMaxPTSDifference
	STR	r1, LastVideoPTSErrorSign

 [ FullLengthStats
        STR     r1, LengthStatsPosition
 ]

	MOV	r1, #-1
	STR	r1, DecodedFieldCount
	STR	r1, VideoPostedPTS+4	; indicate no posted PTS

	LDR	r1, =VideoPreFillSize
	STR	r1, VideoVBVSize

        MOV     r1, #&80000001          ; indicate pre-buffering, but would otherwise be playing normal speed
        STR     r1, VideoSpeedSetting

	BL	InitStream_Common
	BL	VideoClaimInterruptVectors

        LDR     r1, [r2, #VideoStructure_BorderLeft]
        STR     r1, BorderLeft

        LDR     r1, [r2, #VideoStructure_BorderTop]
        STR     r1, BorderTop

        LDR     r1, [r2, #VideoStructure_ScreenMode]
        CMP     r1, #-1
        MOVNE   r0, #0
        SWINE   XOS_ScreenMode

        LDR     r1, [r2, #VideoStructure_Flags]
 [ NYI ; SkipByBlanking
        STR     r1, VideoStructureFlags
        TST     r1, #VideoStructureFlags_SkipToSequenceHdr :OR: VideoStructureFlags_SkipToGOP :OR: VideoStructureFlags_SkipToPic
        BEQ     %FT25
        MOV     r0, #1          ; blank screen
        BL      SetBlank

        MOV     r0, #0
        TST     r1, #VideoStructureFlags_SkipToSequenceHdr      ; if skipping to sequence
        ORRNE   r0, r0, #CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V     ; then enable SEQ-V IRQ and also PIC-V so it works
        TST     r1, #VideoStructureFlags_SkipToGOP              ; if skipping to GOP
        ORRNE   r0, r0, #CL450IRQ_GOP :OR: CL450IRQ_PIC_V       ; then enable GOP IRQ and also PIC-V so it works
        TST     r1, #VideoStructureFlags_SkipToPic
        ORRNE   r0, r0, #CL450IRQ_PIC_V
	Push	"r1"
        MOV     r1, #0
        BL      EnableDisableIRQs
	Pull	"r1"
25
 ]

 [ SkippingCode
        MOV     r0, #0
        TST     r1, #VideoStructureFlags_SkipToGOP
        MOVNE   r0, #MPEG_group_start_code
        TST     r1, #VideoStructureFlags_SkipToSequenceHdr      ; NB this overrides GOP skip
        MOVNE   r0, #MPEG_sequence_header_code
        STR     r0, StartSkipCode
 ]

        TST     r1, #VideoStructureFlags_NoInterlace
        Push    "r1, r2"
        MOVNE   r1, #MPEG2PoduleControl_InterlaceDisable        ; either disable interlace
        MOVEQ   r1, #0                                          ; or enable it
        MVN     r2, #MPEG2PoduleControl_InterlaceDisable        ; r2 = AND mask
        BL      UpdateControlRegister
        Pull    "r1, r2"

        TST     r1, #VideoStructureFlags_DontCLS
        BNE     %FT30

; *** NB Following code assumes 16bpp screen mode ***

        Push    "r1"
        MOV     r0, #&10                ; store &F000
        MOV     r1, #&F000
        SWI     XOS_SetColour
        SWI     XOS_WriteI + 16
        Pull    "r1"

30
        TST     r1, #VideoStructureFlags_DontChangePalette
        BNE     %FT50                   ; [don't change palette]

; first program External Register in VIDC20 to enable EClk

        LDR     r0, =&C0001007
        MOV     r1, #VIDC
        STR     r0, [r1]

; *** NB Following code assumes 16bpp mode ***
; program entries 0 to 15
; - entries 0 to 7 output 0 on ext (solid colours)
; - entries 8 to 15 output 15 on ext (transparent) - NB no individual RGB transparency on MPEG 2 card

        Push    "r2, r3, r4, r9"
        MOV     r0, #15
40
        MOV     r1, #16
        SWI     XOS_ReadPalette
        BVS     %FT90

        BIC     r2, r2, #&FF
        TST     r0, #8
        ORRNE   r2, r2, #&F0
        MOV     r4, #2
        MOV     r9, #&23
        SWI     XOS_CallAVector
        BVS     %FT90
        SUBS    r0, r0, #1
        BPL     %BT40

; also program border colour to be transparent also

        MOV     r0, #0
        MOV     r1, #24
        MOV     r2, #&F0
        MOV     r4, #2
        MOV     r9, #&23
        SWI     XOS_CallAVector
        BVS     %FT90

        Pull    "r2, r3, r4, r9"
50
        LDR     r1, [r2, #VideoStructure_Flags]
        TST     r1, #VideoStructureFlags_NTSC
 [ {FALSE}
        MOVEQ   r0, #VF_PAL
        MOVNE   r0, #VF_NTSC
        BL      SetVideoFormat
 ]

        LDR     r0, BorderLeft
        LDR     r1, BorderTop
        BL      SetBorder

        BL      SetWindow

        MOV     r0, #0
        MOV     r1, #0
        ADR     lr, VideoLastPTS
        STMIA   lr, {r0, r1}            ; zero LastPTS record

	MOV	r0, #1
	STR	r0, VideoPreFilling
        MOV     r0, #0
	STR	r0, VideoAmountQueued

        MOV     r0, r12
        CLRV
        EXIT

90
        Pull    "r2, r3, r4, r9"
        SETV
        EXIT

debug SETL {FALSE}

SlowMotion
NewPacket
SetVideoFormat
SetBorder
SetWindow
AudioSkipFrame
AudioRepeatFrame
AudioMuteSound
AudioSlowMotion
AudioFlushBitstream
	MOV	pc, lr


InitStream_Common Entry "r0-r2"

; zero counts of IRQs

	MOV	r0, #0
        ADR     r1, IRQCounts
        MOV     r2, #16
10
        STR     r0, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT10

					; set up soft copy of Status 0 register
	STR	r0, Status0SoftCopy	; (all video streams enabled, don't reset channel buffer on error)

	LDR	r0, =&FFFE		; all IRQs disabled, video decoder stopped
	STR	r0, IRSoftCopy

	BL      InitL64002
	BL	CommonClaimInterruptVectors
 	EXIT

; **************************************************************************
;
;       VideoSetSpeed - Set speed of MPEG stream
;
; in:   r0 = flags
;       r1 = video stream handle
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

VideoSetSpeed Entry "r0-r2, r11"
        LDR     r11, L64002_Registers
        CMP     r2, #8          ; don't allow speeds slower than 8
        EXIT    HI

        LDR     r0, VideoSpeedSetting
        TST     r0, #&80000000  ; if pre-buffering
        ORRNE   r2, r2, #&80000000 ; then still pre-buffering, but may have speed setting after
        STR     r2, VideoSpeedSetting

        CMP     r2, #1
        BLT     %FT10           ; pause (or pre-buffering)
        BEQ     %FT20           ; normal speed

        MOV     r0, r2
        BL      SlowMotion
        EXIT

10
        BL      VideoSendPause
        CLRV
        EXIT

20
        ADR     lr, VideoLastPTS
        LDMIA   lr, {r0, r1}
        BL      WriteSCR
        BL      VideoSendPlay
        EXIT

; **************************************************************************
;
;       VideoPlay - Start going
;
; in:   r0 = flags
;       r1 = video stream handle
;
; out:  -
;

VideoPlay Entry "r0,r2, r11"
        LDR     r2, VideoSpeedSetting
        BIC     r2, r2, #&80000000      ; clear pre-buffering bit
        STR     r2, VideoSpeedSetting
        BL      VideoSetSpeed
        EXIT

debug SETL {FALSE}

; **************************************************************************
;
;       VideoFullPackets - Here's some more data
;
; in:   r0 = flags
;       r1 = video stream handle
;       r2 -> one or more linked bitstream packets

VideoFullPackets Entry "r0,r11"
	DLine	"MPEGVideo_FullPackets called"
        LDR     r11, [r2, #PacketDescriptor_Length]
	DReg	r11, "Packet length = "
	LDR	lr, [r2, #PacketDescriptor_Flags]
	DReg	lr, "Packet flags = "
        CMP     r11, #0
        BGE     %FT01                                   ; only complain about -ve length
        DREG    r11, "Packet length = "
01
        LDR     r11, L64002_Registers
        MOV     r0, pc
        Push    "r0"
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                                  ; disable IRQs round this bit

        LDR     r0, VideoPacketListTailPtr
        TEQ     r0, #0                                  ; if nothing on list
        STREQ   r2, VideoPacketListHeadPtr		; then point head at new packets
        STRNE   r2, [r0, #PacketDescriptor_Link]        ; else tail!link = packet
10
        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_PTSValid     ; if packet has a valid PTS (ie is start of an MPEG packet)
        ORRNE   r0, r0, #PacketDescriptorFlags_Unchecked
        STRNE   r0, [r2, #PacketDescriptor_Flags]

        TST     r0, #PacketDescriptorFlags_MPEGStart    ; is it the start of a new packet?
        BEQ     %FT30                                   ; [no, so skip this]
        LDR     lr, UnknownLengthPacket                 ; if it is, check to see if we have an indeterminate length packet in progress
        TEQ     lr, #0
        BEQ     %FT20
        Push    "r0,r1"
 [ FullLengthStats
        ADRL    r0, LengthStatsPosition
        LDR     r1, [r0]
        ADD     r1, r1, #1
        CMP     r1, #LengthStatsArraySize
        STRLE   r1, [r0]
        ADDLE   r0, r0, r1, LSL #2
        LDRLE   r1, [lr, #PacketDescriptor_FullLength]
        STRLE   r1, [r0]
 ]

        LDR     r0, [lr, #PacketDescriptor_Flags]       ; there are no more sections in the indeterminate length packet, so clear the bit
        BIC     r0, r0, #PacketDescriptorFlags_FullLengthUnknown
        STR     r0, [lr, #PacketDescriptor_Flags]
        MOV     r0, #0
        STR     r0, UnknownLengthPacket                 ; and clear the pointer to it
        Pull    "r0,r1"
20
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown ; is the new packet of unknown length
 [ FudgeZeroLengthPackets
        STRNE   r2, UnknownLengthPacket                 ; if so, then set up pointer to it
 ]
        MOVNE   r0, #0
        STRNE   r0, [r2, #PacketDescriptor_FullLength]  ; and zero its full length
30
        LDR     r0, UnknownLengthPacket                 ; if we are working out the length
        TEQ     r0, #0
        BEQ     %FT40
        Push    "r1"
        LDR     r1, [r0, #PacketDescriptor_FullLength]
        LDR     lr, [r2, #PacketDescriptor_Length]
        ADD     r1, r1, lr
        STR     r1, [r0, #PacketDescriptor_FullLength]  ; update total length
        Pull    "r1"
40
        LDR     r0, [r2, #PacketDescriptor_Link]        ; go down list of packets to end
        TEQ     r0, #0
        MOVNE   r2, r0
        BNE     %BT10

        STR     r2, VideoPacketListTailPtr		; store new tail pointer
        Pull    "r0"
        TEQP    r0, #0                                  ; restore IRQ state

        EXIT

debug SETL {FALSE}

; **************************************************************************
;
;       VideoCloseStream - Close MPEG video stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGVideo_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:   r0 = flags
;       r1 = Video stream handle
;

VideoCloseStream Entry "r0-r2,r11"
        LDR     r11, L64002_Registers

        LDR     r0, UnknownLengthPacket                 ; do we have an indeterminate-length packet pending?
        TEQ     r0, #0                                  ; if so then length is now complete
        LDRNE   lr, [r0, #PacketDescriptor_Flags]
        BICNE   lr, lr, #PacketDescriptorFlags_FullLengthUnknown
        STRNE   lr, [r0, #PacketDescriptor_Flags]
        MOVNE   lr, #0
        STRNE   lr, UnknownLengthPacket                 ; and no unknown packet now

        LDR     r0, VideoSpeedSetting
        TEQ     r0, #0
        BEQ     %FT50                                   ; [it was paused, so junk data]

        BPL     %FT10                                   ; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

        TEQ     r0, #&80000000
        BEQ     %FT50

   [ SendPlaySWI
        BLCS    VideoIssuePlaySWI
   |
        BLCS    VideoSendPlay
   ]

; wait for data to empty

10
        MOV     r0, #1                                  ; indicate to multiple picture packet checker that we won't get
        STR     r0, VideoStreamClosing			; any more data, so don't hang around
20
        TEQP    pc, #0
        NOP                                             ; allow callbacks
        SWI     OS_EnterOS

        LDR     r0, VideoPacketListHeadPtr		; do we have any outstanding packets?
        CMP     r0, #0                                  ; V := 0
        BNE     %BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
        MOV     r0, #2
        STR     r0, VideoStreamClosing
60
        LDR     r0, VideoPacketListHeadPtr
        CMP     r0, #0                          ; V := 0
        BLNE    VideoFreePacket
        BNE     %BT60
70
	BL	VideoReleaseInterruptVectors
	LDR	r0, AudioControlStreamHandle		; if audio not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, VideoControlStreamHandle		; stream no longer open
        EXIT

; **************************************************************************
;
;       CardControl - Various hardware and interrupt control functions
;

BadCardControlReason
        ADRL    r0, BadCardControlReasonError
        SETV
        MOV     pc, lr

CardControl ROUT
        CMP     r0, #CardControlBadReason
        ADDCC   pc, pc, r0, LSL #2
        B       BadCardControlReason
10
        B       ClaimAudioIRQ
        B       ReleaseAudioIRQ
        B       UpdateControlRegisterMPEG1Style
	B	ControlPowerDown
	B	BadCardControlReason	; SendMacroCommand
	B	BadCardControlReason	; SetColourMode
	B	ReadStatusRegister
        ASSERT  CardControlBadReason :SHL: 2 = {PC}-%BT10

; in:   r0 = reason code (0=Claim audio IRQ)
;       r1 -> audio interrupt routine
;       r2 = workspace pointer for audio IRQ
;
; out:  -

ClaimAudioIRQ * BadCardControlReason

; in:   r0 = reason code (1=Release audio IRQ)
;
; out:  -

ReleaseAudioIRQ * BadCardControlReason

; in:   r0 = reason code (2=Update Control register)
;       r1 = EOR mask
;       r2 = AND mask
;
; out:  r1 = old value of control register
;       r2 = new value of control register
;
; Performs CR = (CR AND r2) EOR r1

UpdateControlRegisterMPEG1Style Entry "r0"
; Bits 3 to 7 of the values correspond to bits 11 to 15 of our logical value
; Other bits are ignored

	MVN	r0, #&F800			; mask of bits to leave alone 0..10,16..31
	ORR	r2, r0, r2, LSL #8		; merge with bits to leave alone in bits 11..15
	MOV	r1, r1, LSL #8			; shift up EOR mask
	BIC	r1, r1, r0			; then knock out bits we're not allowed to touch
	TST	r2, #MPEG2PoduleControl_CTRL1	; make modulator boost bit reflect CTRL1
	BICEQ	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r2, r2, #MPEG2PoduleControl_ModulatorBoost
	TST	r1, #MPEG2PoduleControl_CTRL1	; in EOR mask as well as AND mask
	BICEQ	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	ORRNE	r1, r1, #MPEG2PoduleControl_ModulatorBoost
	BL	UpdateControlRegister
	MOV	r0, #&F8			; valid bits to return
	AND	r1, r0, r1, LSR #8		; shift down + mask old control register value
	AND	r2, r0, r2, LSR #8		; and the same for the new value
	EXIT

UpdateControlRegister Entry "r0"
        MOV     r0, pc
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                          ; disable IRQs round atomic update

        LDR     lr, PoduleControlSoftCopy
        AND     r2, r2, lr
        EOR     r2, r2, r1
	MOV	r2, r2, LSL #16
	MOV	r2, r2, LSR #16			; knock off bits 16..31
        STR     r2, PoduleControlSoftCopy       ; update soft copy, r2 = new value
        MOV     r1, lr                          ; r1 = old value
        LDR     lr, Podule_ControlStatus1
        STRB    r2, [lr]                        ; update hardware
	LDR	lr, Podule_ControlStatus2
	MOV	r2, r2, ROR #8
	STRB	r2, [lr]
	MOV	r2, r2, ROR #24			; put back to original value

        TEQP    r0, #0
        EXIT


; in:	r0 = reason code (3=Control power down)
;	r1 bit 0 = 0 => Place MPEG card in normal running state
;		   1 => Place MPEG card in power down state (stop CL450 GCLK)
;	   bits 1..31 reserved, should be zero
; out:	-

ControlPowerDown * BadCardControlReason

; in:	r0 = reason code (6=Read status register)
;
; out:	r1 = value of status register (actually two 8-bit registers combined into 16)
;

ReadStatusRegister Entry
	LDR	lr, Podule_ControlStatus1	; merge Status1
	LDRB	r1, [lr]
	LDR	lr, Podule_ControlStatus2	; and Status2
	LDRB	lr, [lr]
	ORR	r1, r1, lr, LSL #8
	CLRV
	EXIT

; **************************************************************************
;
;       VideoSetSCR - SWI to set the SCR value
;
; in:   r0 = flags
;       r1 = bits 0..31 of SCR
;       r2 = bit 32 of SCR

VideoSetSCR  Entry "r0-r2,r11"
        LDR     r0, SyncOffset
        ADDS    r1, r1, r0
        ADDCS   r2, r2, #1
 [ SuppressNegativeSCRs
        CMP     r2, #0
        EXIT    LT
 ]
        LDR     r11, L64002_Registers
        MOV     r0, r1
        MOV     r1, r2

        BL      WriteSCR
        EXIT

; **************************************************************************
;
;       ReadParameters - Read various stream parameters
;
; in:   r0 = reason code
;         0 => read time code and temporal reference
;              out: r1 = time code: bits 0..5   = time_code_pictures
;                                   bits 6..11  = time_code_seconds
;                                   bits 12..17 = time_code_minutes
;                                   bits 18..22 = time_code_hours
;                                   bit  23     = drop_frame_flag
;                   r2 = temporal_reference
;         1 => read direct access parameters for SetSCR
;              out: r1 = address of SetSCR routine
;                   r2 = workspace value for SetSCR routine
;         2 => read various locations
;               in: r1 = index of location to read:
;                         0 => CompletionTime
;                         1 => MaxCompletionTime
;              out: r2 = value
;	  3 => read current SCR value
;		out: r1 = bits 0..31 of SCR
;		     r2 = bit  32    of SCR
;

ReadParameters ROUT
        CMP     r0, #ReadParametersBadReason
        ADDCC   pc, pc, r0, LSL #2
        B       BadReadParametersReason
10
        B       ReadTimeCode
        B       ReadSetSCRParameters
        B       ReadDebugInfo
	B	UserReadSCR
	B	BadReadParametersReason	; ReadBufferFullness
	B	BadReadParametersReason	; CheckDisplayReady
        ASSERT  ReadParametersBadReason = ({PC} - %BT10) :SHR: 2

BadReadParametersReason
        ADRL    r0, BadReadParametersReasonError
        SETV
        MOV     pc, lr

ReadTimeCode ROUT
	MOV	r1, #0
	MOV	r2, #0
	MOV	pc, lr

ReadSetSCRParameters ROUT
        ADR     r1, VideoSetSCR
        MOV     r2, wp
        CLRV
        MOV     pc, lr

ReadDebugInfo ROUT
        ADR     r2, DebugVarTable
	CMP	r1, #(DebugVarTableEnd - DebugVarTable) :SHR: 2
        LDRCC   r2, [r2, r1, LSL #2]            ; get offset of variable
	MOVCS	r2, #-1
	CMP	r2, #-1
        LDRNE   r2, [wp, r2]
        CLRV
        MOV     pc, lr

DebugVarTable
        &       -1
        &       -1
        &       :INDEX: VideoLastPTS +0		; low word of last PTS sent to L64002
        &       :INDEX: VideoNumberOfPTSs
	&	:INDEX: SCROffset
	&	:INDEX: VideoSkips
	&	:INDEX: VideoRepeats
	&	:INDEX: AudioFasts
	&	:INDEX: AudioSlows
	&	:INDEX: LastAudioBufferFullness
	&	:INDEX: AudioBufferChecks
DebugVarTableEnd

UserReadSCR Entry "r11"
	BL	CheckStreamOpen
	MOVEQ	r1, #0				; if no stream open, return zero
	MOVEQ	r2, #0
	EXIT	EQ
	LDR	r11, L64002_Registers
	BL	ReadSCR
	EXIT

; CheckStreamOpen - returns NE if audio or video stream open, all registers preserved

CheckStreamOpen Entry
	LDR	lr, VideoControlStreamHandle
	TEQ	lr, #0
	LDREQ	lr, AudioControlStreamHandle
	TEQEQ	lr, #0
	EXIT

; **************************************************************************
;
;	VideoResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = video stream handle
;
; out:	r2 = estimate of number of bytes discarded

VideoResetStream Entry "r0-r2"
 [ {TRUE}
	MOV	r2, #0				; indicate no bytes discarded
 |
	LDR	r11, L64002_Registers

	MOV	r2, #2				; pretend we're closing, so we don't send any more data to it in background
	STR	r2, VideoStreamClosing

	BL	VideoGetBufferFullness		; returns fullness in r2
	LDR	r0, VideoPacketListHeadPtr
10
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	VideoFreePacket				; and free the packet
	BNE	%BT10					; then loop

	STR	r2, [sp, #2*4]			; update returned r2 value with byte count

	MOV	r0, #0
	STR	r0, VideoStreamClosing
	STR	r0, UnknownLengthPacket
 [ SkippingCode
	STR	r0, StartSkipCode
 ]
	MOV	r0, #1
	STR	r0, VideoPreFilling
	MOV	r0, #&80000001
	STR	r0, VideoSpeedSetting

	MOV	r2, #2_110			; restore default sequence parameters, and
	BL	VideoFlushBitstream		; resume only on sequence header
 ]
	CLRV
	EXIT

; **************************************************************************
;
;	VideoGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

VideoGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, VideoChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, VideoChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	VideoFlushBitstream - Send FlushBitstream command
;
; in:	r2 = flags to pass to command
;
; out:	-
;

VideoFlushBitstream Entry "r0-r2"
	BL	CommonReleaseInterruptVectors
	ADR	lr, FIQAmountSent
	MOV	r0, #0
	STR	r0, [lr]
	BL	InitStream_Common

 [ {FALSE}
	LDR	r0, Status0SoftCopy
	BIC	r0, r0, #L64002_Status0_ChannelStatus ; reset channel buffers
	WriteReg r0, Status0
	ORR	r0, r0, #L64002_Status0_ChannelStatus ; then re-enable them
	WriteReg r0, Status0
	ReadRegI r0, OSDControl
	ORR	r0, r0, #OSDControl_VideoBlack		; blank video
	WriteRegI r0, OSDControl, r1
	MOV	r0, #0
	MVN	r1, #1
	BL	UpdateIR				; stop decoding

	ADR	lr, FIQAmountSent
	MOV	r0, #0
	STR	r0, [lr]
 ]

	CLRV
	EXIT

; **************************************************************************
;
;       DisplayStill - Display MPEG still picture
;
; in:   r0 = flags
;

DisplayStill Entry "r0-r2,r11"
 [ NYI
        LDR     r11, CL450_Registers

        MOV     r0, #0
        STR     r0, VideoPreFilling  	; don't go sending any play commands!

        MOV     r0, #1          	; we're sort of playing!
        STR     r0, VideoSpeedSetting

        MOV     r0, #0          	; wait for completion
        ADR     r1, DisplayStillCommand
        BL      SendMacroCommand
 ]
        CLRV
        EXIT

; **************************************************************************
;
;	VideoSendPlay - Start decoder playing

VideoSendPlay Entry "r0,r1"
	MOV	r0, #1		; enable video decoder by setting bit 0 of IR0
	MVN	r1, #1
	BL	UpdateIR
	EXIT

; **************************************************************************
;
;	VideoSendPause - Pause video decoder

VideoSendPause Entry "r0,r1"
	MOV	r0, #0		; disable video decoder by clearing bit 0 of IR0
	MVN	r1, #1
	BL	UpdateIR
	EXIT

; **************************************************************************
;
;       FindPoduleNumber
;
; in:   -
;
; out:  r3 = podule number, if VC, otherwise corrupted
;       All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
	SWI	XPodule_ReturnNumber		; find out number of podules
	BVS	%FT90

	SUB	r1, r0, #1			; maximum podule number
	ADR	r0, PoduleVariableName
	BL	ReadNumericVariable
	BVS	%FT05

	MOV	r3, r0				; copy value into r3
	BL	ReadProductType			; get card type anyway, so we can tell whether to use Japanese DAC sound
	B	%FT20

PoduleVariableName
	=	"MPEG2$PoduleNumber", 0
	ALIGN

05
        MOV     r3, r1		              	; r3 = max podule number
10
	BL	ReadProductType
        BVS     %FT15
	LDR	lr, =ProdType_STB1_MPEG2	; check for MPEG 2 podule for STB 1
        TEQ     r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2	; or for STB2/2
	TEQNE	r0, lr
        BEQ     %FT20
15
        SUBS    r3, r3, #1
        BPL     %BT10
        ADRL    r0, NoPoduleError
        SETV
90
        STR     r0, [sp]
	EXIT

; It's this podule

20
	STR	r0, CardProductType
  [ FastPoduleAccess
        MOV     r0, #3                  ; set access type 'C'
  |
        MOV     r0, #1                  ; set access type 'A'
  ]
        SWI     XPodule_SetSpeed
	STRVS	r0, [sp]
        EXIT

; ReadProductType
;
; in: r3 = podule
; out: r0 = type
; Corrupts PoduleHeaderBuffer

ReadProductType Entry "r2"
	ADR	r2, PoduleHeaderBuffer
	SWI	XPodule_ReadHeader
	MOVVS	r0, #-1
	EXIT	VS

	LDRB	r0, [r2, #3]
	LDRB	r2, [r2, #4]
	ORR	r0, r0, r2, LSL #8
	EXIT

debug SETL {FALSE}

; **************************************************************************
;
;	ReadNumericVariable - Read numeric value of variable
;
; in:	r0 -> variable name
;	r1 = maximum value of variable
;
; out:	r0 = value of variable if V=0, else -> error ptr
;	Corrupts PoduleHeaderBuffer
;

ReadNumericVariable Entry "r1-r4"
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	EXIT	VS

	MOV	lr, #0
	STRB	lr, [r1, r2]			; terminate string

	LDR	r2, [sp, #0*4]			; reload maximum value
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	MOVVC	r0, r2				; if no error, put value in r0
	EXIT

; **************************************************************************
;
;       InitL64002 - Initialise L64002
;
;

InitL64002 Entry "r0-r2,r11"
        MOV     r1, #0
        MVN     r2, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset	; clear bit ie reset L64002 + FIFO
        BL      UpdateControlRegister

        MOV     r1, #MPEG2PoduleControl_NotL64002Reset :OR: MPEG2PoduleControl_NotDataFIFOReset
        MVN     r2, r1				; deassert reset on FIFO + L64002
        BL      UpdateControlRegister

        LDR     r11, L64002_Registers
	ADRL	r0, SetupData
	ADRL	r1, SetupDataEnd
02
	LDRB	r2, [r0], #1			; register (group) number
	LDRB	lr, [r0], #1			; value
	STRB	lr, [r11, r2, LSL #L64002_Register_Address_Shift]
	CMP	r0, r1
	BCC	%BT02

; now program Audio Output Register, taking into account the card type
; STB2_MPEG2 needs

	LDR	r0, CardProductType
	LDR	lr, =ProdType_STB2_MPEG2
	TEQ	r0, lr
	MOVEQ	r0, #AudioModeControl_DACsAreJap	; if STB2/2, DACs are Japanese type
	MOVNE	r0, #AudioModeControl_DACsAreI2S	; else normal
	WriteRegI r0, AudioModeControl, lr

; now try to read variable which sets VideoOutputModeControl

	ADR	r0, VideoOutputVarName
	MOV	r1, #&FF
	BL	ReadNumericVariable
	MOVVS	r0, #&52			; default to proper value for master mode
	WriteRegI r0, VideoOutputModeControl, lr

; now set up General register and FIFO destination appropriate to the stream type

	LDR	lr, VideoInputType
	TEQ	lr, #0
	BEQ	%FT10			; if field not present, or if type unknown, do normal behaviour
	CMP	lr, #VideoInputType_SystemOrProgramStream
	BHI	%FT10			; type we haven't come across, so use default behaviour
	ADR	r0, %FT05
	LDRB	r0, [r0, lr]
	B	%FT15

05
	=	&00			; should never be used
	=	General_ParallelInput :OR: General_AVElementary
	=	General_ParallelInput :OR: General_AVPESPackets
	=	General_ParallelInput :OR: General_SystemStream
	ALIGN

VideoOutputVarName
	=	"MPEG2$VideoOutputMode", 0
	ALIGN

10
	LDR	r0, VideoStreamFlags
	TST	r0, #StreamFlags_PassThroughToVideo
	MOVEQ	r0, #General_ParallelInput :OR: General_AVPESPackets
	MOVNE	r0, #General_ParallelInput :OR: General_SystemStream	; select system stream mode
15
	DReg	r0, "Setting register 5 to "
	ORR	r1, r0, #General_ResetBuffersAndFIFOs
	WriteReg r1, General		; set up mode, and reset system buffers and data FIFOs in L64002
	WriteReg r0, General		; unreset FIFOs

	MVN	r2, #MPEG2PoduleControl_SystemNotSeparate		; AND mask
	TEQ	r0, #General_ParallelInput :OR: General_SystemStream	; if system stream
	ADREQ	r1, AudioSystemInfoStructure				; then system buffer for video is audio system buffer
	ADRNE	r1, VideoSystemInfoStructure				; else system buffer for video is video system buffer
	STR	r1, VideoInfoStructure+SI_SISPtr
	MVNEQ	r1, r2					 		; then feed fifo to audio input
	MOVNE	r1, #0							; else feed to video input
	BL	UpdateControlRegister					; route FIFO through to appropriate place

; now enable channel buffers

	MOV	r0, #&80
	WriteReg r0, Status0

	MOV	r0, #352
	STR	r0, CurrentHorizontalSize
	MOV	r0, #288
	STR	r0, CurrentVerticalSize
	MOV	r0, #0
	STR	r0, CurrentTVFormat

; now read addresses of various buffer registers

	ReadRegI r0, VideoChannelBufferStart0
	ReadRegI r1, VideoChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, VideoChannelBufferEnd0
	ReadRegI lr, VideoChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, VideoInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, VideoChannelBufferSize

	ReadRegI r0, AudioChannelBufferStart0
	ReadRegI r1, AudioChannelBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioInfoStructure+SI_ChannelBufferStart

	ReadRegI r1, AudioChannelBufferEnd0
	ReadRegI lr, AudioChannelBufferEnd1
	ORR	r1, r1, lr, LSL #8
	MOV	r1, r1, LSL #BufferPointerShift
	ADD	r1, r1, #1 :SHL: BufferPointerShift	; add 1 unit cos end inclusive
	STR	r1, AudioInfoStructure+SI_ChannelBufferEnd
	SUBS	r0, r1, r0			; end - start
	STR	r0, AudioChannelBufferSize

	ReadRegI r0, VideoPESBufferStart0
	ReadRegI r1, VideoPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, VideoSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, VideoSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, VideoSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, VideoSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, VideoPESBufferEnd0
	ReadRegI r1, VideoPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, VideoSystemInfoStructure+SIS_SystemBufferEnd

	ReadRegI r0, AudioPESBufferStart0
	ReadRegI r1, AudioPESBufferStart1
	ORR	r0, r0, r1, LSL #8
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferStart
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferReadPtr
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferWritePtr
	MOV	r0, #0
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioSystemInfoStructure+SIS_DuffSystemContents
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	MOV	r0, #-1
	STR	r0, AudioSystemInfoStructure+SIS_AddressOfLastDuff

	ReadRegI r0, AudioPESBufferEnd0
	ReadRegI r1, AudioPESBufferEnd1
	ORR	r0, r0, r1, LSL #8
	ADD	r0, r0, #1
	MOV	r0, r0, LSL #BufferPointerShift
	STR	r0, AudioSystemInfoStructure+SIS_SystemBufferEnd

	MOV	r0, #0
	MOV	r1, #0
	BL	WriteSCR			; set SCR to zero

	CLRV
	EXIT

debug SETL {FALSE}

; **************************************************************************

Delay   Entry "r0,r1"
        MOV     r1, r0
        SWI     XOS_ReadMonotonicTime
        ADD     r1, r1, r0
10
        SWI     XOS_ReadMonotonicTime
        CMP     r0, r1
        BMI     %BT10
        EXIT

VideoEnabledIRQs * IR_PictureStartCodeDetect :OR: IR_BeginVerticalBlank :OR: IR_BeginActiveVideo
AudioEnabledIRQs * IR_AudioSyncCodeDetect
CommonEnabledIRQs * IR_SCRStatus

VideoClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

        MOV     r0, #TickerV
        ADRL    r1, VideoTickerV
        MOV     r2, wp
        SWI     XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:VideoEnabledIRQs
	BL	UpdateIR

	BL	ClaimFIQs

	MOV	r0, #1
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioClaimInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	NE				; non-zero => already claimed

        MOV     r0, #TickerV
        ADRL    r1, AudioTickerV
        MOV     r2, wp
        SWI     XOS_Claim
	EXIT	VS

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	LDR	r1, =:NOT:AudioEnabledIRQs
	BL	UpdateIR

	MOV	r0, #1
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT

CommonClaimInterruptVectors Entry "r0-r4,r11"
        LDR     r0, CommonInterruptVectorsClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    NE                              ; non-zero => already claimed

        MOV     r0, #IOMD_Podule_DevNo
        ADR     r1, MPEGIRQHandler
        MOV     r2, wp
        LDR     r3, Podule_ControlStatus1
        MOV     r4, #MPEG2PoduleStatus1_IRQActive
        SWI     XOS_ClaimDeviceVector
        EXIT    VS

        MOV     r1, #MPEG2PoduleControl_L64002IRQEnable
        MVN     r2, r1
        BL      UpdateControlRegister           ; turn on IRQs

        MOV     r0, #IOC
        MOV     r1, pc
        TEQP    pc, #SVC_mode + I_bit           ; disable IRQs while modifying mask B
        LDRB    r2, [r0, #IOCIRQMSKB]
        ORR     r2, r2, #podule_IRQ_bit
        STRB    r2, [r0, #IOCIRQMSKB]
        TEQP    r1, #0

	LDR	r11, L64002_Registers
	MOV	r0, #0				; NB bits that are *clear* are enabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

        MOV     r0, #1
        STR     r0, CommonInterruptVectorsClaimed
        CLRV
        EXIT

VideoReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, VideoInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	BL	ReleaseFIQs

	LDR	r11, L64002_Registers
	LDR	r0, =VideoEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

        MOV     r0, #TickerV
        ADRL	r1, VideoTickerV
        MOV     r2, wp
        SWI     XOS_Release

        ADRL	r0, VideoTickerVCallBack
        MOV     r1, wp
        SWI     XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, VideoInterruptVectorsClaimed
	CLRV
	EXIT

AudioReleaseInterruptVectors Entry "r0-r2,r11"
	LDR	r0, AudioInterruptVectorsClaimed
	CMP	r0, #0				; V:=0
	EXIT	EQ				; non-zero => already claimed

	LDR	r11, L64002_Registers
	LDR	r0, =AudioEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, r0
	BL	UpdateIR

        MOV     r0, #TickerV
        ADRL	r1, AudioTickerV
        MOV     r2, wp
        SWI     XOS_Release

        ADRL	r0, AudioTickerVCallBack
        MOV     r1, wp
        SWI     XOS_RemoveCallBack

	MOV	r0, #0
	STR	r0, AudioInterruptVectorsClaimed
	CLRV
	EXIT


CommonReleaseInterruptVectors Entry "r0-r4, r11"
        LDR     r0, CommonInterruptVectorsClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    EQ                              ; non-zero => already claimed

	LDR	r11, L64002_Registers
	MOV	r0, #CommonEnabledIRQs		; NB bits that are *set* are disabled
	MVN	r1, #CommonEnabledIRQs
	BL	UpdateIR

        MOV     r1, #0
;        MVN     r2, #MPEG2PoduleControl_L64002IRQEnable :OR: MPEG2PoduleControl_NotL64002Reset
        MVN     r2, #MPEG2PoduleControl_L64002IRQEnable
        BL      UpdateControlRegister           ; turn off IRQs but don't reset L64002

        MOV     r0, #IOMD_Podule_DevNo
        ADR     r1, MPEGIRQHandler
        MOV     r2, wp
        LDR     r3, Podule_ControlStatus1
        MOV     r4, #MPEG2PoduleStatus1_IRQActive
        SWI     XOS_ReleaseDeviceVector

        MOV     r0, #0
        STR     r0, CommonInterruptVectorsClaimed
        EXIT

ClaimFIQs Entry "r0-r3"
	MOV	r1, #Service_ClaimFIQ
	SWI	XOS_ServiceCall

; enable FIQ on card, but don't enable it in IOMD
; (we only enable it in IOMD when we have data to send, and the FIQ process disables it in IOMD when there's no data left -
; since these are just write operations, rather than read-modify-write it simplifies things, rather than have the foreground
; disable FIQs while modifying the control register)

	MOV	r1, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	MVN	r2, r1				; enable FIFO FIQ on card
	BL	UpdateControlRegister

	LDR	r0, FIQLDRPCInstr
	ADRL	r1, FIQCodeStart
	MOV	r2, #0
	ADR	r3, FIQSpaceStart
	STMIA	r3, {r0-r2}			; set up LDR PC instruction at &1C and PC to load, zero FIQAmountSent

	ADR	r0, FIQSlotSpace
	STR	r0, FIQSlotWritePtr		; point FIQ slot write ptr at start of slots

; zero out all the FIQ data slots

	ADR	r0, FIQSlotSpace
	MOV	r1, #0
	MOV	r2, #FIQSlotSpaceSize
10
	STR	r1, [r0], #4
	SUBS	r2, r2, #4
	BNE	%BT10

	LDR	r2, FIFO_32_Bit_Write
	LDR	r3, FIFO_8_Bit_Write

	MOV	r0, pc
	BIC	r1, r0, #3
	ORR	r1, r1, #FIQ_mode
	TEQP	r1, #0				; enter FIQ mode
	NOP

	ADR	r8, FIQSlotSpace		; point at first slot
	MOV	r9, r2				; r9 -> 32-bit FIFO writes
	MOV	r10, r3				; r10 -> 8-bit FIFO writes
	ADR	r13, FIQStackEnd		; and set up FIQ stack pointer

	TEQP	r0, #0				; go back to SVC mode
	NOP

	EXIT

FIQLDRPCInstr
	LDR	pc, %FT95
95

ReleaseFIQs Entry "r0-r2"
	MOV	r1, #0
	MVN	r2, #MPEG2PoduleControl_FIFOEmptyFIQEnable
	BL	UpdateControlRegister		; disable FIFO FIQ on card

	MOV	r1, #Service_ReleaseFIQ
	SWI	XOS_ServiceCall
	EXIT

 [ BoardIssue < 3
; **************************************************************************
;
;	InitSAA7167 - Initialise IIC D-to-A converter/mixer chip

InitSAA7167 Entry "r0-r2"
	MOV	r0, #IICAddress_SAA7167
	ADR	r1, SAA7167InitBlock0
	MOV	r2, #2
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

; Initially we only program register 0 in this device, which has the following bits:-

; Bits 1..0: FMTC1/FMTC0 = 10 => YUV 2:1:1 CCIR656
; Bit 2:     KINV=1 => EXTKEY= LOW for Mprg, HIGH for Computer
; Bit 3:     KEN=1 Key connected to ED0
; Bit 4:     DRP=0 => 2's Complement UV data
; Bits 7..5: KMOD2/1/0 = 000 => Use EXTernal KEY

SAA7167InitBlock0
	=	0, 2_00001110

 ]
; **************************************************************************
;
;       MPEGIRQHandler - Handler for IRQs off MPEG card
;
; in:   -
; out:  r0-r3 may be corrupted

MPEGIRQHandler Entry "r11"
        LDR     r3, Podule_ControlStatus1
        LDRB    r3, [r3]

        TST     r3, #MPEG2PoduleStatus1_NotL64002Interrupt
        BLEQ    L64002IRQ
 [ {FALSE}
        TST     r3, #MPEG2PoduleStatus1_FIFONotEmpty
        BLEQ    FIFOIRQ

KillIRQExit
        TEQP    pc, #SVC_mode + I_bit
        MOV     r0, r0
        Push    "lr"
        BL      ReleaseIRQVector
        Pull    "lr"
        TEQP    pc, #IRQ_mode + I_bit
        MOV     r0, r0
 ]
        EXIT

        LTORG

; **************************************************************************
;
;       L64002IRQ - Handler for L64002 IRQs
;
; in:   -
; out:  r0-r2, r11 may be corrupted

L64002IRQ Entry "r3"
	LDR	r11, L64002_Registers
	ReadReg	r0, IR0				; this clears all interrupts in Status 0
	ReadReg r1, IR1				; ditto for Status 1
	ORR	r0, r0, r1, LSL #8		; form 1 word with all IRQs in
	LDR	r1, IRSoftCopy
	ORR	r1, r1, #1			; video enable bit doesn't count
	BICS	r0, r0, r1			; only look at bits that are actually enabled
	EXIT	EQ				; [none, so exit]
	ADR	r1, IRQCounts
	MOV	r3, #0
10
	MOVS	r0, r0, LSR #1
	LDRCS	r2, [r1, r3, LSL #2]
	ADDCS	r2, r2, #1
	STRCS	r2, [r1, r3, LSL #2]
	BLCS	DespatchIRQ
	ADD	r3, r3, #1
	BNE	%BT10
	EXIT

DespatchIRQ Entry "r0-r3"
	ADR	r0, IRQDespatchTable
	LDR	r1, [r0, r3, LSL #2]
	MOV	lr, pc
	ADD	pc, r0, r1
	EXITS

IRQDespatchTable
	&	IgnoreIRQ - IRQDespatchTable	; Decode Status
	&	IgnoreIRQ - IRQDespatchTable	; User Data FIFO Ready
	&	IgnoreIRQ - IRQDespatchTable	; Decode Error
	&	AudioSyncCodeIRQ - IRQDespatchTable	; Audio Sync Code detected
	&	PictureStartCodeIRQ - IRQDespatchTable  ; Picture Start Code detect
	&	SCRStatusIRQ - IRQDespatchTable	; System Clock Reference Status
	&	IgnoreIRQ - IRQDespatchTable	; Pack Data Ready
	&	IgnoreIRQ - IRQDespatchTable	; DRAM Transfer Done
	&	IgnoreIRQ - IRQDespatchTable	; Audio Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable	; Video Channel Buffer Overflow
	&	IgnoreIRQ - IRQDespatchTable	; Audio Channel Buffer Underflow
	&	IgnoreIRQ - IRQDespatchTable	; Video Channel Buffer Underflow
	&	BeginActiveVideo - IRQDespatchTable	; Begin Active Video
	&	BeginVerticalBlank - IRQDespatchTable	; Begin Vertical Blank
	&	IgnoreIRQ - IRQDespatchTable	; Audio PES Data Ready (don't use this as not all data is there when IRQ happens)
	&	IgnoreIRQ - IRQDespatchTable	; Video PES Data Ready

IgnoreIRQ
	MOV	pc, lr

; Audio Sync Code Detect IRQ
; r0-r3 can be junked

AudioSyncCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working audio sync code read ptr, so read that instead

	ReadRegI r0, AudioSyncCodeRead0
	ReadRegI lr, AudioSyncCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, AudioSyncCodeRead2
	ORR	r0, r0, lr, LSL #16

 |
; read the Audio Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, AudioInfoStructure
	BL	CheckSystemBuffer		; read any audio system buffer data

	BL	ProcessAudioReadPtr		; compare audio channel buffer read ptr in r0 with audio PTS list entries

	ReadRegI r0, AudioParameter0
	ReadRegI r1, AudioParameter1
	AND	r0, r0, #3			; get bottom 2 bits of audio rate
	TST	r1, #&80			; if RATE bit set
	ORRNE	r0, r0, #4			; then set bit 2 of combined rate
	STR	r0, AudioSampleRate

	ADR	r1, SampleRateProgTable
	LDR	r1, [r1, r0, LSL #2]		; extract 3 bytes of registers
	WriteRegI r1, AudioFrequencyNMOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNOSC0, lr
	MOV	r1, r1, LSR #8
	WriteRegI r1, AudioFrequencyNMOSCNOSC1, lr
	EXIT

	MACRO
	SampleRateInfo	$n, $nm
	=	($nm) :AND: &FF								; Register 6.49
	=	($n) :AND: &FF								; Register 6.50
	=	((($nm) :SHR: 8) :AND: 15) :OR: (((($n) :SHR: 8) :AND: 3) :SHL: 4)	; Register 6.51
	=	0									; padding
	MEND

SampleRateProgTable
	SampleRateInfo	98, -1777		; 22.05 kHz
	SampleRateInfo	64, -1061		; 24 kHz
	SampleRateInfo	128, -3247		; 16 kHz
	SampleRateInfo	0, 0
	SampleRateInfo	196, -1679		; 44.1 kHz
	SampleRateInfo	128, -997		; 48 kHz
	SampleRateInfo	256, -3119		; 32 kHz
	SampleRateInfo	0, 0

; Picture Start Code IRQ
; We use this to read the Aux FIFO and check the video system buffer
; r0-r3 can be junked

PictureStartCodeIRQ Entry "r8"

 [ Revision >= RevC
; Luxury - we have working picture start code read ptr, so read that instead
	ReadRegI r0, PictureStartCodeRead0
	ReadRegI lr, PictureStartCodeRead1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PictureStartCodeRead2
	ORR	r0, r0, lr, LSL #16
 |
; read the Video Channel Buffer read ptr as soon as possible (ie here),
; so we catch it before it moves on too much

	ReadRegI r0, VideoChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	ORR	r0, r0, lr, LSL #16
 ]
	ADR	r8, VideoInfoStructure
	BL	CheckSystemBuffer		; read any video system buffer data

	BL	ProcessAuxFIFO			; ensure we have updated picture type before checking for PTS being valid

	BL	ProcessVideoReadPtr
	EXIT

ProcessAuxFIFO Entry "r0-r2"
10
	ReadReg r0, Status0			; determine if Aux FIFO has any data in it
	AND	r1, r0, #L64002_Status0_ADFSBits
	TEQ	r1, #L64002_Status0_AuxDataFIFOEmpty ; if no data
	EXIT	EQ				; then exit

	AND	r0, r0, #L64002_Status0_AuxIDBits
	MOV	r0, r0, LSR #L64002_Status0_AuxIDShift
	CMP	r0, #3
	BCC	%FT20
	ReadRegI r0, AuxiliaryDataFIFO		; not recognised, so read a byte from FIFO
	B	%BT10				; and loop

20
	ADR	r1, AuxInfoTable
	LDR	r1, [r1, r0, LSL #2]
	ADD	r2, wp, r1, LSR #8		; r2 -> area to dump info to
	AND	r1, r1, #&FF			; r1 = length of data
30
	ReadRegI lr, AuxiliaryDataFIFO
	STRB	lr, [r2], #1
	SUBS	r1, r1, #1
	BNE	%BT30

	TEQ	r0, #0				; is it sequence data?
	BNE	%BT10				; [no, so skip]

	LDRB	r0, VideoSequence_VBVBufferSize +0
	LDRB	r1, VideoSequence_VBVBufferSize +1
	ORR	r0, r1, r0, LSL #8		; VBV buffer size in units of 16K bits, ie 2K bytes
	MOV	r0, r0, LSL #11			; convert to bytes
	LDR	r1, VideoChannelBufferSize	; but don't exceed video channel buffer size
	CMP	r0, r1
	MOVHI	r0, r1
	STR	r0, VideoVBVSize

	LDRB	r0, VideoSequence_HorizontalSize +0 	; *high* byte of horiz size
	LDRB	lr, VideoSequence_HorizontalSize +1	; *low* byte of horiz size
	ORR	r0, lr, r0, LSL #8			; r0 = xres

	LDRB	r1, VideoSequence_VerticalSize +0	; high byte of vertical size
	LDRB	lr, VideoSequence_VerticalSize +1	; low byte of vertical size
	ORR	r1, lr, r1, LSL #8			; r1 = yres

; For now set up the video output mode as per the source material wrt PAL/NTSC
; cos I know my TV can do both. Eventually we'll have to skip/repeat frames to adjust for
; the incoming picture rate differing from the outgoing rate

	LDRB	r2, VideoSequence_PictureRate		; r2 = picture rate index
	CMP	r2, #PictureRate_25000			; if more than 25Hz
	MOVHI	r2, #1					; indicate NTSC
	MOVLS	r2, #0					; else indicate PAL

	BL	SetupScreenMode
	B	%BT10					; go back for more data from Aux FIFO

AuxInfoTable
	&	12 :OR: ((:INDEX: VideoSequenceData)   :SHL: 8)
	&	6  :OR: ((:INDEX: GroupOfPicturesData) :SHL: 8)
	&	5  :OR: ((:INDEX: PictureData)         :SHL: 8)


; Begin Vertical Blank interrupt
; r0-r3 can be junked

BeginVerticalBlank Entry
	LDR	r0, DecodedFieldCount
	CMP	r0, #0
	EXIT	LT
	ADD	r0, r0, #1
	CMP	r0, #4				; number of fields after decode start that it's safe to unblank screen
	MOVCS	r0, #-1				; reset to -1 so no more unblanking
	STR	r0, DecodedFieldCount
	EXIT	CC

	ReadRegI r0, OSDControl
	BIC	r0, r0, #OSDControl_VideoBlack	; unblank
	WriteRegI r0, OSDControl, r1
	EXIT

; Begin Active Video interrupt
; r0-r3 can be junked

BeginActiveVideo Entry
	ReadRegI r0, DisplayControllerStatus
	TST	r0, #1				; check if an odd field
	EXIT	NE				; [it's not, so exit]

	ADR	r0, VideoPostedPTS
	LDMIA	r0, {r0, r3}			; get posted PTS
	TEQ	r3, #0
	EXIT	MI				; no PTS posted, so exit

	MOV	lr, #-1
	STR	lr, VideoPostedPTS +4		; cancel it

	LDR	lr, VideoStreamFlags
	TST	lr, #StreamFlags_NoLipSync
	EXIT	NE

	ReadRegI lr, VideoTrickModes
	TST	lr, #VideoTrickModes_ValidBits
	EXIT	NE				; still a skip or repeat in operation

	BL	ReadSCR				; read SCR in r1, r2
	SUBS	r0, r0, r1
	SBC	r3, r3, r2			; form PTS - SCR
	ANDS	r3, r3, #1			; only interested in bit32 of difference
	LDR	r3, =MaxPTSError
	BNE	%FT50				; [PTS < SCR]

; PTS > SCR - see if it's more than about a frame (3600 ticks)

	CMP	r0, r3
	MOVCC	lr, #0
	STRCC	lr, LastVideoPTSErrorSign	; last one was within range
	EXIT	CC				; not sufficiently out
20
	LDR	lr, LastVideoPTSErrorSign	; was last error positive as well?
	TEQ	lr, #1
	MOVNE	lr, #1				; if not, then store current direction
	STRNE	lr, LastVideoPTSErrorSign
	EXIT	NE				; but don't repeat this time

	LDR	lr, VideoRepeats		; one more repeat
	ADD	lr, lr, #1
	STR	lr, VideoRepeats

	LDR	lr, VideoMaxPTSDifference
	CMP	r0, lr
	STRGT	r0, VideoMaxPTSDifference

	MOV	r0, #VideoTrickModes_Repeat
	WriteRegI r0, VideoTrickModes, lr
	EXIT

50
	ADDS	r0, r0, r3			; if within approx one frame
	MOVCS	lr, #0
	STRCS	lr, LastVideoPTSErrorSign	; last one was within range
	EXIT	CS				; don't do anything

	LDR	lr, LastVideoPTSErrorSign	; was last error negative as well?
	CMP	lr, #-1
	MOVNE	lr, #-1
	STRNE	lr, LastVideoPTSErrorSign	; if not, then store current direction
	EXIT	NE				; but don't skip this time

	LDR	lr, VideoSkips
	ADD	lr, lr, #1
	STR	lr, VideoSkips

	SUB	r0, r0, r3
	LDR	lr, VideoMinPTSDifference
	CMP	r0, lr
	STRLT	r0, VideoMinPTSDifference

	MOV	r0, #VideoTrickModes_SkipB
	WriteRegI r0, VideoTrickModes, lr
	EXIT


; SCR Status IRQ
; r0-r3 can be junked

SCRStatusIRQ Entry "r0"
	BL	CheckErrorStatus
	EXIT

	MACRO
	DoDRAMGetByte	$underrun
	BL	DRAMGetByte
	BVS	$underrun
	MEND

; **************************************************************************
;
;	SetupScreenMode - Program screen mode registers in L64002
;
; in:	r0 = xres
;	r1 = yres
;	r2 = 0 for PAL, 1 for NTSC
;
; out:	-


SetupScreenMode Entry "r2-r5"
 [ {FALSE} ; debug x 2 size
	MOV	r0, r0, LSR #1
	MOV	r1, r1, LSR #1
 ]
	ASSERT	CurrentVerticalSize = CurrentHorizontalSize + 4
	ASSERT	CurrentTVFormat = CurrentHorizontalSize + 8
	ADR	lr, CurrentHorizontalSize
	LDMIA	lr, {r3-r5}			; load old settings

	TEQ	r0, r3
	TEQEQ	r1, r4
	TEQEQ	r2, r5
	EXIT	EQ				; all the same, so do nothing

	STMIA	lr, {r0-r2}			; save out new parameters

	CMP	r1, #288			; if more than 288
	MOVHI	r3, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_InterlaceChromaFieldRepeatFilterChroma
						; then full interlaced picture
	MOVLS	r3, #DisplayMode1_HorizontalFilterEnable :OR: DisplayMode1_ProgressiveFilterLuma
						; else just SIF
	WriteRegI r3, DisplayMode1, lr

	MOV	r3, #704
	BL	GetHCF
	MOV	r4, r3				; save HCF of (xres, 704)

	MOV	r3, #720
	BL	GetHCF				; get HCF of (xres, 720)
	CMP	r3, r4
	ORRHI	r2, r2, #2			; if HCF is higher with 720, set bit 1 of TV format to form index into table
	MOVHI	r3, #720
	MOVLS	r3, #704
	STR	r3, CurrentOutputWidth

	MOV	r4, r0, LSL #8			; r4 = xres*256
	DivRem	r5, r4, r3, lr			; r5 = xres*256/outputwidth, r4 = remainder
	TEQ	r4, #0				; if remainder non-zero
	ADDNE	r5, r5, #1			; round up
	WriteRegI r5, RasterMapperIncrement, lr	; write raster mapper increment

; now work out MainReadsPerLine/DisplayWidth registers, including top bits which are determined by PAL/NTSC

	ADD	r3, r0, #7
	MOV	r3, r3, LSR #3			; xres/8
	TST	r2, #1				; if PAL
	ORREQ	r3, r3, #&80			; then set top bit
	WriteRegI r3, MainReadsPerLine, lr	; and write to MainReadsPerLine
	WriteRegI r3, DisplayWidth, lr		; and DisplayWidth

	ADR	lr, ScreenParamsTable
	LDR	r3, [lr, r2, LSL #2]
	ADD	r3, lr, r3			; r3 -> table for appropriate mode
10
	LDR	r4, [r3], #4
	CMP	r4, #-1
	EXIT	EQ
	WriteReg r4, AIR			; byte 0 is index within bank
	MOV	r4, r4, LSR #8			; byte 1 is register value
	MOV	lr, r4, LSR #8			; byte 2 is register number
	STRB	r4, [r11, lr, LSL #L64002_Register_Address_Shift]
	B	%BT10

; GetHCF - r3 = highest common factor of r0 and r3

GetHCF	Entry "r0, r1"
	CMP	r0, r3				; ensure r0 >= r3 before we start
	EORCC	r0, r0, r3
	EORCC	r3, r3, r0
	EORCC	r0, r0, r3
10
	DivRem	r1, r0, r3, lr			; r1 = r0/r3; r0=r0 mod r3
	TEQ	r0, #0				; if remainder non-zero
	MOVNE	r0, r3				; then shuffle up numbers
	MOVNE	r3, r1
	BNE	%BT10				; and loop
	EXIT					; else exit with r3 = HCF

ScreenParamsTable
	&	ScreenParamsPAL704-ScreenParamsTable
	&	ScreenParamsNTSC704-ScreenParamsTable
	&	ScreenParamsPAL720-ScreenParamsTable
	&	ScreenParamsNTSC720-ScreenParamsTable

	MACRO
	MakeRegisterEntry $reg, $value
	&	L64002_$reg._Addr2 :OR: (($value):SHL:8) :OR: (L64002_$reg._Addr1 :SHL: (16-L64002_Register_Address_Shift))
	MEND

	MACRO
$label	MakeScreenParams $hsw,$eqw,$ser,$hbl,$hfln,$actim, $prebl,$mnln,$postbl,$preeqhln,$serhln,$posteqhln,$scanhln
$label
	ASSERT	$hsw :AND: :NOT: &FF = 0
	ASSERT	$eqw :AND: :NOT: &FF = 0
	ASSERT	$ser :AND: :NOT: &3FF = 0
	ASSERT  $hbl :AND: :NOT: &1FF = 0
	ASSERT	$actim :AND: :NOT: &3FF = 0
	ASSERT	$hfln :AND: :NOT: &3FF = 0
	ASSERT	$prebl :AND: :NOT: &1F = 0
	ASSERT	$preeqhln :AND: :NOT: 7 = 0
	ASSERT	$postbl :AND: :NOT: &1F = 0
	ASSERT	$posteqhln :AND: :NOT: 7 = 0
	ASSERT	$mnln :AND: :NOT: &3F = 0
	ASSERT	$serhln :AND: :NOT: 7 = 0
	ASSERT	$scanhln :AND: :NOT: &1FF = 0
	MakeRegisterEntry HorizSyncWidth, $hsw
	MakeRegisterEntry EqualizationPulseWidth, $eqw
	MakeRegisterEntry SerrationPulseWidth, ($ser :AND: &FF)
	MakeRegisterEntry HorizBlankPulseWidth, ($hbl :AND: &FF)
	MakeRegisterEntry ActiveImageDone, ($actim :AND: &FF)
	MakeRegisterEntry HalfLineTime, ($hfln :AND: &FF)
	MakeRegisterEntry UpperBits, ($ser:SHR:8) :OR: (($hbl:SHR:8):SHL:2) :OR: (($actim:SHR:8):SHL:3) :OR: (($hfln:SHR:8):SHL:5)
	MakeRegisterEntry VertiPreBlankEqualization, ($preeqhln :SHL: 5) :OR: $prebl
	MakeRegisterEntry VertiPostBlankEqualization, ($posteqhln :SHL: 5) :OR: $postbl
	MakeRegisterEntry VertiMainSerrationLines, ($serhln :SHL: 5) :OR: ($mnln :AND: &1F)
	MakeRegisterEntry VertiScanHalfLines, ($scanhln :AND: &FF)
	&	-1
	MEND

ScreenParamsPAL704	MakeScreenParams 127,62,737,276,863,820, 23,36,1,5,5,5,305
ScreenParamsPAL720	MakeScreenParams 127,62,737,260,863,836, 23,36,1,5,5,5,305
ScreenParamsNTSC704	MakeScreenParams 129,64,729,256,857,806, 17,30,5,6,6,6,253
ScreenParamsNTSC720	MakeScreenParams 129,64,729,240,857,822, 17,30,5,6,6,6,253

; **************************************************************************
;
;	CheckSystemBuffer - Check contents of system buffer for packet headers with PTSs
;			    and add them to the PTSList
;
; in:	r8 -> audio or video info structure
;	r11 -> L64002 registers
;	IRQ mode, IRQs disabled
;
; out:	All registers preserved

CheckSystemBuffer Entry "r0-r9"
	LDR	r9, [r8, #SI_SISPtr]		; r9 -> streaminfo system structure
	MOV	r0, #-1
	STR	r0, DRAMBufferAddress		; invalidate any data already in buffer
	LDR	r0, [r9, #SIS_SystemWrite0Reg]
	STRB	r0, [r11, #L64002_AIR]
	LDR	r0, [r9, #SIS_SystemWrite0Group]
	LDRB	r0, [r11, r0]			; read system buffer write ptr LSB
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r0, r0, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #&03			; mask off wrapping bits for now
	ORR	r0, r0, lr, LSL #16
	MOV	r0, r0, LSL #3			; r0 = byte address of system buffer write address
	STR	r0, [r9, #SIS_SystemBufferWritePtr] ; last reading of write pointer
	LDR	r1, [r9, #SIS_SystemBufferReadPtr]

;	LDR	r2, [r8, #SI_PTSListReadPtr]
;	LDR	r3, [r8, #SI_PTSListWritePtr]
;	LDR	r4, [r8, #SI_PTSListPtr]
10
	STR	r1, [r9, #SIS_SystemBufferReadPtr] ; save where we're at
	TEQ	r0, r1				; is there any data for us?
	EXIT	EQ				; [no, then exit]
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70				; not a system start code, skip to next word
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #0
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	TEQ	r5, #1
	BNE	%FT70
	DoDRAMGetByte UnderrunExit
	MOV	r8, #0				; by default indicate not a packet header we're interested in
	MOV	lr, r5, LSR #4
	TEQ	lr, #&E				; stream ids &E0-&EF are video packets
	ADREQ	r8, VideoInfoStructure
	TEQ	lr, #&C				; stream ids &C0-&DF are audio packets
	TEQNE	lr, #&D
	ADREQ	r8, AudioInfoStructure
	TEQ	r8, #0
	BEQ	%FT75				; [not packet code of interest, check for pack or system header]
	BL	DRAMGetByte			; get length hi
	BLVC	DRAMGetByte			; get length lo
	BVS	UnderrunExit
20
	DoDRAMGetByte UnderrunExit		; skip stuffing bytes (the MPEGControl module and/or L64002 may have removed them)
	TEQ	r5, #&FF
	BEQ	%BT20

	MOV	lr, r5, LSR #6
	TEQ	lr, #1				; is there an STB_buffer_scale/size?
	BNE	%FT30
	BL	DRAMGetByte			; skip 2nd byte of STB_buffer_scale/size
	BLVC	DRAMGetByte			; get next byte
	BVS	UnderrunExit
30
	MOV	lr, r5, LSR #6
	TEQ	lr, #2				; is it MPEG 2 PES?
	BEQ	%FT60

	MOVS	lr, r5, LSR #4
	BEQ	%FT55				; [no PTS or DTS]
	TEQ	lr, #2
	BNE	%FT50				; [not PTS on its own]

	BL	GetClockReference		; returns PTS value in r6, r7
	BVS	UnderrunExit
32
	BL	RoundUpToWord			; round up to whole word boundary
	ADD	r1, r1, #5			; address starts at offset 5 in this word
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #24+2		; hi-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #16+2		; mid-byte of pointer
	DoDRAMGetByte UnderrunExit
	ORR	r7, r7, r5, LSL #8+2		; lo-byte of pointer

; now check the address for sanity, as the L64002 seems to put in duff ones now and again

	MOV	lr, r7, LSR #10-3		; convert to byte address
	BIC	lr, lr, #&1E00000		; knock out wrap bits
	LDR	r5, [r8, #SI_ChannelBufferStart]
	CMP	lr, r5				; is it below start of channel buffer
	BCC	%FT34
	LDR	r5, [r8, #SI_ChannelBufferEnd]
	CMP	lr, r5				; or after the end of it?
	BCC	%FT36
34
	LDR	lr, [r9, #SIS_DuffChannelAddresses] ; increment count of gaffs
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffChannelAddresses]
	B	%BT10				; don't output item (no need to round up as we're already there)

36
; r7 now holds bit 32 of PTS in bit 0, and pointer field in bits 10..31 (including wrap bits)

	LDR	r4, [r8, #SI_PTSListPtr]	; load appropriate PTS list ptr
	LDR	r3, [r8, #SI_PTSListWritePtr]	; and offset
	ADD	lr, r4, r3, LSL #3
	STMIA	lr, {r6, r7}

	ADD	r3, r3, #1
	LDR	lr, [r8, #SI_PTSListSize]
	TEQ	r3, lr				; wrap PTS list index
	MOVEQ	r3, #0
	LDR	r2, [r8, #SI_PTSListReadPtr]
	TEQ	r3, r2				; if full then exit
	BEQ	%FT40
	STR	r3, [r8, #SI_PTSListWritePtr]	; then store back
	B	%BT10

40
	LDR	lr, [r8, #SI_PTSListOverruns]	; increment count of PTS list overruns
	ADD	lr, lr, #1
	STR	lr, [r8, #SI_PTSListOverruns]
	B	%BT10

UnderrunExit
	EXIT

; not MPEG 2, and not just &0F, and not just PTS, so check for PTS+DTS

50
	TEQ	lr, #3				; check if PTS+DTS
	BNE	%FT70				; [not that]

; it's PTS + DTS

	BL	GetClockReference		; get PTS
	BVS	UnderrunExit
	Push	"r7"
	MOV	r7, #5				; now skip DTS
	BL	SkipR7Bytes
	Pull	"r7"
	BVS	UnderrunExit
	B	%BT32				; pass PTS to code that reads ptr field

; no PTS or DTS, so skip pointer field to complete item

55
	BL	RoundUpToWord			; round up to whole word boundary
	DoDRAMGetByte UnderrunExit		; check pointer field there
	BL	RoundUpToWord			; round up again to skip whole word
	B	%BT10

; it's an MPEG 2 PES packet

60
	DoDRAMGetByte UnderrunExit		; get flags byte
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit		; get header length
	TST	r7, #&80
	BEQ	%FT65				; no PTS or DTS
	DoDRAMGetByte UnderrunExit		; get 1st byte of PTS
	SUB	r5, r5, #5			; adjust header length to account for PTS we're about to extract
	Push	"r5, r7"			; save remaining header length + a slot for saving r7 later
	BL	GetClockReference
	Pull	"r5, r7", VS			; if we underrun, flatten stack
	BVS	UnderrunExit			; and exit indicating underrun

	STR	r7, [sp, #4]			; save high word temporarily
	Pull	"r7"				; restore count of bytes to skip
	BL	SkipR7Bytes
	Pull	"r7"				; restore high word of PTS
	BVS	UnderrunExit			; if skip failed indicate underrun
	B	%BT32				; go to code that reads ptr field

; MPEG 2 PES with no PTS

65
	MOV	r7, r5				; skip rest of header
	BL	SkipR7Bytes
	BVS	UnderrunExit
	B	%BT55				; then skip pointer field

; we got rubbish in system buffer

70
	LDR	lr, [r9, #SIS_DuffSystemContents] ; increment count of number of times we had crap
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_DuffSystemContents]
	STR	r1, [r9, #SIS_AddressOfLastDuff]
	BL	RoundUpToWord			; round up to whole word boundary
	B	%BT10				; for now just go onto next entry

; not packet header, so check for pack header or system header

75
	TEQ	r5, #&BA			; is it a pack header?
	BNE	%FT80

; a pack header is either a total of 12 bytes (MPEG 1) or 14 bytes + up to 7 bytes of
; &FF stuffing (MPEG2) (which the L64002 skips), so the system buffer usage is always 2 words

	BL	RoundUpToWord			; skip rest of 1st word
	DoDRAMGetByte UnderrunExit		; check 2nd word is there
	BL	RoundUpToWord			; round up to next one
	B	%BT10				; then go back for more

; not packet or pack header - check for system header

80
	TEQ	r5, #&BB			; is it a system header
	BNE	%BT70				; if not then rubbish
	DoDRAMGetByte UnderrunExit		; get high byte of length
	MOV	r7, r5
	DoDRAMGetByte UnderrunExit
	ORRS	r7, r5, r7, LSL #8		; r7 = number of additional bytes
	BEQ	%FT85				; no more bytes to skip

	BL	SkipR7Bytes			; skip rest of system header
	BVS	UnderrunExit
85
	BL	RoundUpToWord			; skip to start of next word
	B	%BT10				; now go back for more


SkipR7Bytes Entry
10
	BL	DRAMGetByte
	EXIT	VS
	SUBS	r7, r7, #1			; decrement count of bytes to skip
	BNE	%BT10
	EXIT					; exit (V=0 from SUBS)


GetClockReference ROUT
	Push	"lr"
	AND	r5, r5, #&0E				; extract bits 3..1
	MOV	r7, r5, LSR #3				; r7 = bit 32 in bit 0
	Push	"r7"					; save for later, together with bomb-out address
	MOV     r7, r5, LSL #31-2			; r7 = bits 31,30
	BL	DRAMGetByte				; get bits 29..22 in bits 7..0
	ORRVC	r7, r7, r5, LSL #22			; r7 = bits 31..22
	BLVC	DRAMGetByte				; get bits 21..15 in bits 7..1
	MOVVC	r5, r5, LSR #1
	ORRVC	r7, r7, r5, LSL #15			; r7 = bits 31..15
	BLVC	DRAMGetByte				; get bits 14..7 in bits 7..0
	ORRVC	r7, r7, r5, LSL #7			; r7 = bits 31..7
	BLVC	DRAMGetByte				; get bits 6..0 in bits 7..1
	ORRVC	r6, r7, r5, LSR #1			; r6 = bits 31..0
	Pull    "r7,pc"

RoundUpToWord Entry
	ADD	r1, r1, #7
	BIC	r1, r1, #7
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXIT

DRAMGetByte Entry "r2,r3"
	ADR	r5, DRAMBuffer
	LDR	lr, DRAMBufferAddress
	EOR	lr, lr, r1				; differences between DRAM buffer address and required address
	BICS	lr, lr, #7				; is it in the same word?
	BNE	%FT10					; no, so fetch DRAM
05
	AND	lr, r1, #7
	LDRB	r5, [r5, lr]				; load from buffer
	ADD	r1, r1, #1				; advance read ptr
	LDR	lr, [r9, #SIS_SystemBufferEnd]		; wrap DRAM address within system buffer
	TEQ	r1, lr
	LDREQ	r1, [r9, #SIS_SystemBufferStart]
	EXITS

10
	BIC	lr, r1, #7				; form base word address
	TEQ	lr, r0					; are we in same word as write ptr
	BEQ	%FT90					; if so then we've underrun

	STR	lr, DRAMBufferAddress			; save base address of buffer

	DRAMRead r2, r3, r1, lr				; perform read from location (r1 BIC 7) and put contents in r2,r3
	STMIA	r5, {r2, r3}				; store 8-bytes in buffer
	B	%BT05

90
	LDR	lr, [r9, #SIS_SystemUnderruns]
	ADD	lr, lr, #1
	STR	lr, [r9, #SIS_SystemUnderruns]
	PullEnv
	ORRS	pc, lr, #V_bit				; set V, preserving other flags

; **************************************************************************
;
;	ProcessAudioReadPtr - Compare passed in audio read ptr with AudioPTSList
;			      and if the sync code has a corresponding PTS, set SCR to it
;
; in:	r0 = audio channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> audio info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be junked

ProcessAudioReadPtr Entry

; we have to adjust for the fact that the audio sync code register points 16 (not 8 as in the manual) bytes further on
; than the address containing the audio sync code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #16 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	MOV	lr, r0, LSR #6				; convert back to byte offset for storage
	STR	lr, AudioChannelBufferReadPtr

	BL	CheckPTSList
        TEQ	r1, #0
	EXIT	MI					; if no PTS, just exit

 [ VetSCRValues
	MOV	r2, pc
	BIC	r3, r2, #3
	TEQP	r3, #SVC_mode				; enter SVC mode so we can save lr_svc
	NOP

	Push	"lr"					; save lr_svc
	BL	PerformSCRVetting			; if SCR bad, don't use it
	BLEQ	WriteSCR
	Pull	"lr"					; restore lr_svc

	TEQP	r2, #0					; restore original mode
	NOP
 |
	BL	WriteSCR
 ]
	EXIT

; **************************************************************************
;
;	CheckPTSList - Check video or audio PTS list for comparable item
;
; in:	r0 = channel buffer ptr to compare, shifted up to top of word (so that clock arithmetic can be used)
;	r8 -> VideoInfoStructure or AudioInfoStructure
;
; out:	If there is an appropriate PTS then
;	 r0 = bits 0..31 of PTS
;	 r1 = bit 32 of PTS (in bit 0)
;	else
;	 r0 = undefined
;	 r1 = -1
;	endif

CheckPTSList Entry "r2-r7,r9"
	LDR	r1, [r8, #SI_PTSListWritePtr]
	LDR	r2, [r8, #SI_PTSListReadPtr]
	LDR	r3, [r8, #SI_PTSListPtr]
	LDR	r9, [r8, #SI_PTSListSize]
	MOV	r7, #-1					; indicate no valid PTS yet
10
	TEQ	r2, r1					; have we run out?
	BEQ	%FT90					; then exit

	ADD	r4, r3, r2, LSL #3			; point at next read entry
	LDMIA	r4, {r4, r5}
	BIC	lr, r5, #1				; knock out bit 32 of PTS
	CMP	r0, lr					; check if value of read ptr is less than next PTS (using clock arithmetic)
	BMI	%FT90					; if so, then next PTS hasn't happened yet

	MOV	r6, r4					; make record of highest PTS so far with address field <= current read ptr
	AND	r7, r5, #1				; r7 = bit 32 of PTS

	ADD	r2, r2, #1				; advance read ptr
	TEQ	r2, r9					; wrap it
	MOVEQ	r2, #0
	B	%BT10

; no more PTSs with address <= read ptr, so if we've had one, set SCR to that, else just exit

90
	STR	r2, [r8, #SI_PTSListReadPtr]
	MOV	r0, r6
	MOV	r1, r7
	EXIT

; **************************************************************************
;
;	ProcessVideoReadPtr - Compare passed in video read ptr with VideoPTSList
;			      and if the picture start has a corresponding PTS, post it for
;			      comparison with the SCR on a future vsync IRQ
;
; in:	r0 = video channel buffer read ptr (in units of 8 bytes, with wrapping bits at top)
;	r8 -> video info structure
;	r11 -> L64002 registers
;
; out:	r0-r3 may be corrupted

ProcessVideoReadPtr Entry
	LDR	lr, AudioControlStreamHandle		; if no audio stream playing, don't do any syncing
	TEQ	lr, #0
	EXIT	EQ

; we have to adjust for the fact that the picture start code register points 48 bytes further on than the address containing
; the picture start code

	MOV	r0, r0, ROR #18				; move pointer bits to top 18 bits, and wrap bits to bits 0..3
	SUB	r0, r0, #48 :SHL: 11			; make adjustment
	LDR	lr, [r8, #SI_ChannelBufferStart]
	SUBS	lr, r0, lr, LSL #11			; make value relative to start of channel buffer
	LDRCC	r0, [r8, #SI_ChannelBufferEnd]		; if below, then point at buffer end
	ADDCC	r0, lr, r0, LSL #11			; add negative amount onto it to find new position (preserving wrap bits)
	ADDCC	r0, r0, #&0F				; and decrement wrap bits modulo 16 avoiding underflow
	BICCC	r0, r0, #&10				; make sure bit 4 is clear
	MOV	r0, r0, ROR #4				; now move wrap bits to bits 31..28

	BL	CheckPTSList				; PTS if any comes back in r0,r1 (r1<0 if invalid)
        TEQ	r1, #0
	EXIT	MI					; if no PTS, just exit

	LDRB	r2, Picture_PictureCodingType
	ADR	lr, VideoPTSPictureTypeCounts
	CMP	r2, #4
	LDRCC	r3, [lr, r2, LSL #2]
	ADDCC	r3, r3, #1
	STRCC	r3, [lr, r2, LSL #2]

	TEQ	r2, #PictureCodingType_B		; is it a B picture?
	EXIT	NE					; if not exit for now

	LDR	r2, VideoPostedPTS +4			; is there already one posted that hasn't been used?
	TEQ	r2, #0					; less than 0 => empty
	EXIT	PL

	ADR	r2, VideoPostedPTS
	STMIA	r2, {r0, r1}				; post PTS for comparison on next odd field vsync IRQ

	LDR	r0, VideoNumberOfPostedPTSs
	ADD	r0, r0, #1
	STR	r0, VideoNumberOfPostedPTSs

	EXIT

 [ VetSCRValues
; **************************************************************************
;
;	PerformSCRVetting - Check SCR for sensibility, and reject if not
;
; in:	r0 = bottom 32 bits of SCR
;	r1 = bit 32 of SCR
;	IRQ mode
;
; out:	NE => reject this SCR value

PerformSCRVetting Entry "r2,r3"
	LDR	r3, VetSCRState
	CMP	r3, #1
	BCS	%FT20

; we're awaiting the 1st SCR

	LDR	r2, AudioSpeedSetting
	TEQ	r2, #1			; only exit this state if in normal play mode
	BNE	%FT10                   ; return EQ, but do nothing
	BL	ConvertSCRToOffset
	STR	r2, GoodSCROffset
05
	MOV	r2, #1
	STR	r2, VetSCRState
10
	TEQ	r0, r0			; set EQ
	EXIT

20
	BL	ConvertSCRToOffset	; convert new SCR into an offset from 100Hz time
	LDR	lr, GoodSCROffset	; get last good offset
30
	SUBS	lr, lr, r2		; compute difference
	RSBMI	lr, lr, #0		; compute absolute difference
	CMP	lr, #SCRAcceptableRange	; is it within range
	STRCC	r2, GoodSCROffset	; yes, then store new good offset
	BCC	%BT05			; then mark last one as good, and exit EQ

; we're out of range of the last good one, but are we consistent with the last bad one?

	CMP	r3, #2			; was the last one bad?
	STRNE	r2, BadSCROffset	; if not, then store this as the 1st bad one
	MOVNE	r2, #2			; indicate last one was bad
	STRNE	r2, VetSCRState
	LDRNE	r2, BadSCRCount		; increment count of bad ones
	ADDNE	r2, r2, #1
	STRNE	r2, BadSCRCount
	EXIT	NE			; and exit NE, indicating last one bad

	LDR	lr, BadSCROffset	; get last bad offset
	MOV	r3, #1			; pretend last one was good, so we don't drop thru again
	B	%BT30

ConvertSCRToOffset ROUT
	Push	"r0,lr"
	SWI	XOS_ReadMonotonicTime	; returns in r0
	MOV	lr, #900		; SCR is in 90kHz ticks, monotonic time is in 100Hz units
	MUL	r2, lr, r0		; make into 90kHz units (don't care about overflow)
	Pull	"r0"
	SUB	r2, r0, r2		; SCR - MT*900
	Pull	"pc"

 ] ; VetSCRValues

; **************************************************************************
;
;	VideoTickerV - Entry point for TickerV IRQ for video

VideoTickerV Entry "r0-r2"
        LDR     r0, VideoCallBackRequested	; is a callback already requested
        TEQ     r0, #0
        EXIT    NE				; if so, don't ask for another
        MOV     r2, pc
        ORR     r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
        TEQP    r1, #0
        NOP
        Push    "r14"
        LDR     r0, VideoStreamFlags
        TST     r0, #StreamFlags_UseCallBacks
        BEQ     %FT20				; [stuff directly]

        ADR     r0, VideoTickerVCallBack
        MOV     r1, wp
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVC   r0, VideoCallBackRequested	; indicate that we've requested a callback
10
        Pull    "r14"
        TEQP    r2, #0
        NOP
        EXIT

20
        MOV     r0, #1
        STR     r0, VideoCallBackRequested
        BL      VideoTickerVCallBack
        B       %BT10

VideoTickerVCallBack Entry "r0,r1, r11"
 [ EnableIRQsInTickerV
        MOV     lr, pc
        BIC     lr, lr, #I_bit          ; enable IRQs
        TEQP    lr, #0
 ]
        LDR     r11, L64002_Registers
	BL	VideoCheckEndOfPreFill	; start playing if sent enough
	BL	VideoFreeUsedPackets
        BL      VideoDoStuffWithData
        MOV     r0, #0
        STR     r0, VideoCallBackRequested
        EXIT

        LTORG

VideoDoStuffWithData Entry "r0-r2"
        LDR     r0, VideoStreamClosing  ; if stream closing (ie value = 2)
        CMP     r0, #1                  ; don't send any more data
        EXIT    HI

        LDR     r0, VideoPacketListHeadPtr

; find any data we haven't passed to background yet

10
        TEQ     r0, #0                  			; any more data
	EXIT	EQ						; [no, so exit]
	LDR	r1, [r0, #PacketDescriptor_Flags]		; have we passed this packet
	TST	r1, #PacketDescriptorFlags_PassedToBackground
	BLEQ	PassPacketToBackground				; if not then do so
	LDRNE	r0, [r0, #PacketDescriptor_Link]		; if we can still send more, then go on to next packet
	BNE	%BT10
	EXIT

 [ MultiplePicturePacketsChecks
; **************************************************************************
;
;       CheckForMultiplePictures - Check packet for multiple picture_start codes
;
; in:   r0 -> packet descriptor for first packet within MPEG packet
;       r1 = flags for packet
;
; out:  EQ => packet is OK to send
;       NE => packet is incomplete so hasn't been checked - don't send it yet
;       r1 = updated flags
;       All other registers preserved

CheckForMultiplePictures Entry "r0,r2-r8"
        LDR     r2, [r0, #PacketDescriptor_FullLength]
        MOV     r3, r0
10
        LDR     r4, [r3, #PacketDescriptor_Length]
        SUBS    r2, r2, r4
        BLE     %FT20
        LDR     r3, [r3, #PacketDescriptor_Link]
        CMP     r3, #1          ; if link <> 0
        BCS     %BT10           ; then loop

; incomplete packet, so exit NE to indicate this

        LDR     r3, VideoStreamClosing
        TEQ     r3, #1          ; are we going to get any more data?
        EXIT    NE              ; we might, so exit NE indicating incomplete

        B       CFMPBadPacket   ; else we'd best mark it as dodgy, just in case

; packet is complete, so let's check it (r0 -> first part packet, r3 -> last)

20
        LDR     r2, [r0, #PacketDescriptor_PTS]
        LDR     lr, =BadPacketPTS
        TEQ     r2, lr
        MOVNE   r8, #0
        MOVEQ   r8, #1

        LDR     r2, [r0, #PacketDescriptor_Start]
        LDR     r4, [r0, #PacketDescriptor_Length]
        MOV     r7, #0                  ; number of picture_start codes in packet

30
        MOV     r6, #0                  ; state
32
        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00
        BNE     %BT32
34
        MOV     r6, #1
        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00 00
        BNE     %BT30
        MOV     r6, #2

        BL      CFMPgetbyte
        TEQ     r5, #1          ; check for 00 00 01
        SUBNE   r2, r2, #1      ; if not then could be (00) 00 00
        ADDNE   r4, r4, #1      ; adjust length back as well
        BNE     %BT34
        MOV     r6, #3

        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00 00 01 00 (picture start code)
        BNE     %BT30

        ADD     r7, r7, #1      ; one more picture start code
        CMP     r7, #1
        BHI     CFMPBadPacket   ; if more than 1 then definitely bad
        B       %BT30           ; else loop

BadPacketPTS    *       &D4B20
        LTORG

CFMPgetbyte
        SUBS    r4, r4, #1
        LDRGEB  r5, [r2], #1
        MOVGE   pc, lr
        TEQ     r0, r3
        LDRNE   r0, [r0, #PacketDescriptor_Link]
        LDRNE   r2, [r0, #PacketDescriptor_Start]
        LDRNE   r4, [r0, #PacketDescriptor_Length]
        BNE     CFMPgetbyte

; we've run out of data to check

        TEQ     r8, #1
        STREQ   r7, CheckedBadPacket

 [ {FALSE}      ; try rule where only two whole picture_start codes make a bad packet
        TEQ     r7, #0          ; if no picture_start codes
        TEQNE   r6, #0          ; or 1 picture_start code and no partial ones
 ]
        B       CFMPGoodPacket  ; then OK
CFMPBadPacket
        BIC     r1, r1, #PacketDescriptorFlags_PTSValid ; else clear PTS valid bit
        LDR     lr, MultiPacketCount
        ADD     lr, lr, #1
        STR     lr, MultiPacketCount
        CMP     lr, #MPDebugArraySize   ; if run out of debug array
        BCS     CFMPGoodPacket          ; then skip this bit
        ADR     r0, MPDebugArray-4
        ADD     lr, r0, lr, LSL #2      ; point at where to store PTS
        LDR     r0, [sp]                ; reload ptr to first partial packet
        LDR     r0, [r0, #PacketDescriptor_PTS] ; load bottom 32 bits of PTS for this packet
        STR     r0, [lr]
CFMPGoodPacket
        BIC     r1, r1, #PacketDescriptorFlags_Unchecked
        LDR     r0, [sp]                ; reload ptr to first partial packet
        STR     r1, [r0, #PacketDescriptor_Flags]       ; save flags
        TEQ     r0, r0                  ; indicate packet has been checked
        EXIT
 ]

; **************************************************************************
;
;	PassPacketToBackground - Pass a packet to background FIQ process
;
; in:	r0 -> packet
;	r1 = packet flags
;
; out:	NE if managed to pass this packet to background
;	EQ if couldn't, cos all slots full

PassPacketToBackground Entry "r1-r5,r11"
 [ UseWholePackets
	BL	VideoSendNewPacketIfNecessary		; if start of MPEG packet, put in packet header slot if poss.
	BNE	%FT90
 ]
	ASSERT	PacketDescriptor_Length = PacketDescriptor_Start + 4
	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	BNE	%FT90					; [all slots full]

	ADD	r4, r0, #PacketDescriptor_Start
	LDMIA	r4, {r4, r5}				; get address, length of this packet

 [ CheckBufferFullness
	LDR	lr, VideoPreFilling
	TEQ	lr, #0
	BNE	%FT10					; pre-filling, so assume OK
	LDR	r11, L64002_Registers
	BL	VideoGetBufferFullness			; read buffer fullness into r2
	LDR	lr, VideoAmountQueued
	ADD	r2, r2, lr				; add on amount already queued
	ADR	lr, FIQAmountSent
	LDR	lr, [lr]
	SUB	r2, r2, lr				; but subtract amount already sent
	ADD	r2, r2, #MPEG2Podule_FIFOLength + 8*1024 ; and add a possibly full FIFO, plus some slack in the channel buffer
	ADD	r2, r2, r5				; add on length of this packet
	LDR	lr, VideoChannelBufferSize
	CMP	r2, lr					; if this is more than total buffer size
	BHI	%FT90					; then don't pass this packet yet
10
 ]
	ORR	r1, r1, #PacketDescriptorFlags_PassedToBackground ; indicate passed to bgd
	STR	r1, [r0, #PacketDescriptor_Flags]	; do this *before* passing to bgd, in case it's bloody quick

	MOV	lr, r0
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in slot (NB may start going straight away)

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	TEQ	r3, #0					; r3 <> 0, so set NE
	EXIT

90
	TEQ	r0, r0					; set EQ, indicating failure
	EXIT

; **************************************************************************
;
;	WriteSCR - Write to system clock reference value by adjusting software offset
;
; in:	r0 = bits [31..0] of SCR
;	r1 = bit 32 of SCR, in bit 0
;	r11 -> L64002_Registers

WriteSCR Entry "r0-r4"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we update

	MOV	r3, r1					; save new hi word of value
	BL	ReadSCR					; r1 = old value lo, r2 = old value hi
	SUBS	r0, r0, r1				; r0 = (new value - old value) lo word
	SBC	r1, r3, r2				; r1 = (new value - old value) hi word

	ADR	lr, SCROffset
	LDMIA	lr, {r2, r3}				; r2 = old offset lo, r3 = old offset hi
	ADDS	r2, r2, r0				; r2 = new offset lo = new value - old value + old offset
	ADC	r3, r3, r1				; r3 = new offset hi
	STMIA	lr, {r2, r3}				; update offsets
	EXITS

; **************************************************************************
;
;	ReadSCR - Read current value of SCR bits using H/W and software offset
;
; in:	-
;
; out:	r1 = bits [31..0] of SCR
;	r2 = bit 32 of SCR, in bit 0

ReadSCR Entry	"r0"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0					; disable IRQs while we read this

	ReadRegI r1, SCR0
	ReadRegI r2, SCR1

	BL	CheckErrorStatus			; process bits in ErrorStatus register, returns r0 = error status
	TST	r0, #ErrorStatus_SCROverflow
	BEQ	%FT10

	ReadRegI r1, SCR0				; if overflowed, it may have done so before or after we read the
	ReadRegI r2, SCR1				; registers before, so read them again (won't have time to overflow again)
10
	ORR	lr, r1, r2, LSL #8
	ADR	r1, SCROffset				; load software offset (will have been updated
	LDMIA	r1, {r1, r2}				; if necessary by CheckErrorStatus)
	ADDS	r1, r1, lr				; and add it on
	ADC	r2, r2, #0
	EXITS

; **************************************************************************
;
;	CheckErrorStatus - Check various bits in ErrorStatus register and act on them
;
; in:	r11 -> L64002_Registers
;	IRQs disabled
;
; out:	r0 = value of ErrorStatus register

CheckErrorStatus Entry "r1,r2"
	ReadRegI r0, ErrorStatus
	TST	r0, #ErrorStatus_SCROverflow
	EXIT	EQ
	ADR	lr, SCROffset
	LDMIA	lr, {r1, r2}
	ADDS	r1, r1, #1 :SHL: 16
	ADC	r2, r2, #0
	STMIA	lr, {r1, r2}
	EXIT

; **************************************************************************
;
;	VideoFreeUsedPackets - Go through packet list freeing any used packets

VideoFreeUsedPackets Entry "r0-r3"
10
	LDR	r0, VideoPacketListHeadPtr
	TEQ	r0, #0
	LDRNE	lr, [r0, #PacketDescriptor_Flags]	; if we have a packet, has it all been sent?
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	EXIT	EQ
 [ {TRUE}
; we've found a packet that needs freeing, so go down chain until we find the last
; one that needs freeing
	MOV	r1, r0					; save pointer to 1st one
20
	LDR	r2, [r1, #PacketDescriptor_Link]	; if there is a next node
	TEQ	r2, #0
	LDRNE	lr, [r2, #PacketDescriptor_Flags]	; and it's all sent
	TSTNE	lr, #PacketDescriptorFlags_AllSent
	MOVNE	r1, r2					; then move to that one
	BNE	%BT20					; and loop

	MOV	r3, pc
	ORR	lr, r3, #I_bit				; disable IRQs round this bit
	TEQP	lr, #0					; (may be unnecessary)

	STR	r2, VideoPacketListHeadPtr		; update head
	TEQ	r2, #0					; and if no more
	STREQ	r2, VideoPacketListTailPtr		; zero tail

	TEQP	r3, #0					; restore IRQs
	MOV	r2, #0
	STR	r2, [r1, #PacketDescriptor_Link]	; terminate link at last freeable packet

	MOV	lr, pc
	LDR	pc, [r0, #PacketDescriptor_FreeRoutine] ; free nodes
	EXIT

 |
	BL	VideoFreePacket				; if so then free it
	B	%BT10
 ]

; **************************************************************************
;
;	VideoCheckEndOfPreFill - Check if we've sent enough to pre-fill buffer, so we can unpause it

VideoCheckEndOfPreFill Entry "r0"
	LDR	lr, VideoPreFilling			; are we still in pre-fill
	CMP	lr, #0
	EXIT	EQ					; already playing

	ADR	lr, FIQAmountSent
	LDR	lr, [lr]				; check amount FIQ process has transmitted

	LDR	r0, VideoVBVSize
	CMP	lr, r0
	MOVCS	lr, #0
	STRCS	lr, VideoPreFilling
	STRCS	lr, DecodedFieldCount			; decoder now going
   [ SendPlaySWI
        BLCS    VideoIssuePlaySWI
   |
        BLCS    VideoSendPlay
   ]
	EXIT


 [ SendPlaySWI

VideoIssuePlaySWI Entry "r0,r1"
        MOV     r0, #StreamFlags_VideoPresent   ; indicate video now ready
        LDR     r1, VideoControlStreamHandle
        SWI     XMPEGControl_Play

        EXIT
 ]

; **************************************************************************
;
;	Data stuffing FIQ code

; FIQ register allocation:

; Outside FIQ routine:
;  r8 -> current slot to process
;  r9 -> 32-bit FIFO write address (16 bit address = r9-4)
;  r10 -> 8-bit FIFO write address
;  r13 -> FIQ stack
; Inside routine:
;  r0 -> data
;  r1 = remaining contiguous length we can do this FIQ
;  r2-r7,r11,r14 used to load data
;  r12 = amount of space left in FIFO after this lump
;

; FIQ slot node format

		^	0
FIQSlot_Address #	4
FIQSlot_Length	#	4
FIQSlot_Packet	#	4

FIQSlotSize	*	:INDEX: @

; FIQ workspace layout

		^	&1C
FIQSpaceStart	#	4			; slot for LDR PC, &20
FIQSpacePCLoad	#	4			; slot for address of FIQ routine in module code
FIQAmountSent	#	4			; amount of data sent by FIQ process
		#	9*4			; 9 words needed for FIQ stack to save r0-r7,r14
FIQStackEnd	#	0

		#	(&100-@) :MOD: FIQSlotSize	; align so that slot space ends on a slot boundary

FIQSlotSpace	#	&100 - @

FIQSlotSpaceSize *	?FIQSlotSpace
	ASSERT	FIQSlotSpaceSize >= FIQSlotSize

FIQCodeStart Entry "r0-r7"			; may not need all these
	MOV	r1, #MPEG2Podule_FIFOLength	; how much we can do now
05
	ASSERT	FIQSlot_Length = FIQSlot_Address +4
	LDMIA	r8, {r0, r2}			; load address + length
	TEQ	r0, #0				; if address zero
	BEQ	%FT90				; then no more data, so disable FIQ in IOMD and exit
10
	SUBS	r12, r1, r2			; amount of FIQ space left after this packet
	MOVCS	r1, r2				; if >=0 then do packet amount in this lump
	MOVCS	r2, #0				; and packet done after this
	RSBCC	r2, r12, #0			; else packet has -r12 left after this FIFO lump
	MOVCC	r12, #0				; and no FIFO space after this packet
	STR	r2, [r8, #FIQSlot_Length]	; store updated length for next time

	ADR	r3, FIQAmountSent
	LDR	r4, [r3]			; add on amount about to be sent
	ADD	r4, r4, r1
	STR	r4, [r3]

	TST	r0, #3
	BNE	%FT40				; do part words
20
	SUBS	r1, r1, #8*4			; enough for 8 whole words?
	LDMCSIA r0!, {r2-r7,r11,r14}
	STMCSIA r9, {r2-r7,r11,r14}
	BHI	%BT20

	ADDCC	r1, r1, #8*4			; if insufficient then revert
30
	SUBS	r1, r1, #4			; enough for 1 whole word
	LDRCS	r2, [r0], #4
	STRCS	r2, [r9]
	BHI	%BT30

;	ADDCC	r1, r1, #4			; (not necessary - we only need to look at bottom 2 bits now)

	TST	r1, #2
	LDRNE	r2, [r0], #2
	STRNE	r2, [r9, #-4]			; write to 16-bit FIFO address

	TST	r1, #1
	LDRNEB	r2, [r0], #1
	STRNEB	r2, [r10]			; write to 8-bit FIFO address

; finished doing that lump

35
	LDR	r2, [r8, #FIQSlot_Length]	; get remaining size
	TEQ	r2, #0				; if some left
	STRNE	r0, [r8, #FIQSlot_Address]	; then update address
	BNE	%FT36

; none left, so mark as finished, and advance to next

	LDR	r3, [r8, #FIQSlot_Packet]	; find real packet descriptor (if any - NB packet header slots don't have one)
	TEQ	r3, #0
	LDRNE	r2, [r3, #PacketDescriptor_Flags] ; mark packet as all sent
	ORRNE	r2, r2, #PacketDescriptorFlags_AllSent
	STRNE	r2, [r3, #PacketDescriptor_Flags]
	MOV	r0, #0				; zero address to store in slot, to mark it as empty
	STR	r0, [r8, #FIQSlot_Address]
	ADD	r8, r8, #FIQSlotSize		; advance to next slot
	CMP	r8, #&100			; wrap if necessary
	ADREQ	r8, FIQSlotSpace
36
	MOVS	r1, r12				; restore amount of space left in FIFO
	BNE	%BT05				; if some then go back and try to do it
37
	PullEnv
	SUBS	pc, lr, #4			; exit from FIQ

; data address not word aligned, so do bytes until it is

40
	SUBS	r1, r1, #1			; if no more bytes left
	BCC	%BT35				; then finished doing that lump
	LDRB	r2, [r0], #1
	STRB	r2, [r10]			; write to 8-bit FIFO address

	TST	r0, #3				; if still not aligned
	BNE	%BT40				; then loop
	B	%BT20				; else enter main section

; no more data, so disable FIQ until we have some

90
	MOV	r1, #IOC
	STRB	r0, [r1, #IOCFIQMSK]		; zero FIQ mask to disable our FIQ
	B	%BT37


; **************************************************************************
;
;	UpdateIR - Atomically update interrupt registers and soft copies
;
; in:	r0 = EOR mask
;	r1 = AND mask

UpdateIR Entry "r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	r2, IRSoftCopy
	AND	r2, r2, r1
	EOR	r2, r2, r0
	STR	r2, IRSoftCopy

	WriteReg r2, IR0
	MOV	r2, r2, LSR #8
	WriteReg r2, IR1
	EXITS

 [ UseWholePackets
; **************************************************************************
;
;       VideoSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:   r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

VideoSendNewPacketIfNecessary Entry "r1-r5, r11"
	LDR	r1, VideoStreamFlags
	EOR	r1, r1, #StreamFlags_PassThroughToVideo
	TST	r1, #StreamFlags_PassThroughToVideo
	EXIT	EQ					; if passing through, don't put our own packet headers on it

	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart    ; is it start of an MPEG packet?
	EXIT	EQ                                      ; [no, so no packet header required, exit EQ => try to send data]

	LDR	r3, FIQSlotWritePtr
	LDR	lr, [r3, #FIQSlot_Address]
	TEQ	lr, #0
	EXIT	NE					; [all slots full, so don't try to send data]

; we need to create a FIQ slot containing the data to send for the packet header
; rather than allocating a new RMA block, we can reuse the 16 bytes in the packet header allocated for the PTS and DTS (yuk!)

	TST	r1, #PacketDescriptorFlags_PTSValid
	MOVEQ	lr, #&0F				; termination for no PTS
	STREQB	lr, [r0, #PacketDescriptor_PTS+6]
	MOVEQ	r5, #7					; if no PTS, then just 7 extra bytes
	BEQ	%FT30

	ADD	r4, r0, #PacketDescriptor_PTS
	LDMIA	r4, {r4, r5}				; r4 = bits 31..0 of PTS; r5 = bit 32 of PTS

        MOV     lr, r4, LSR #29                         ; lr = bits 31..29 in bits 2..0
        ORR     lr, lr, r5, LSL #3                      ; lr = bits 32..29 in bits 3..0
        ORR     lr, lr, #&21                            ; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+6]	; store in packet header block
        MOV     lr, r4, LSR #22                         ; lr = bits 29..22 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+7]	; (only stores bottom 8 bits)
        MOV     lr, r4, LSR #14                         ; lr = bits 21..14 in bits 7..0
        ORR     lr, lr, #1                              ; force bit 0 to 1 (marker)
	STRB	lr, [r0, #PacketDescriptor_PTS+8]
        MOV     lr, r4, LSR #7                          ; lr = bits 14..7 in bits 7..0
	STRB	lr, [r0, #PacketDescriptor_PTS+9]
        MOV     lr, r4, LSL #1                          ; lr = bits 6..0 in bits 7..1
        ORR     lr, lr, #1
	STRB	lr, [r0, #PacketDescriptor_PTS+10]

        MOV     r5, pc
        ORR     lr, r5, #I_bit
        TEQP    lr, #0
        LDR     lr, VideoPTSInCount			; increment count of PTS's coming in
        ADD     lr, lr, #1
        STR     lr, VideoPTSInCount
        TEQP    r5, #0

	MOV	r5, #11
30
	LDR	lr, =&E0010000
	STR	lr, [r0, #PacketDescriptor_PTS+0]	; video packet start code

        LDR     r4, [r0, #PacketDescriptor_FullLength]	; get length of packet payload
	TEQ	r4, #0					; if zero, then leave it at zero
	ADDNE	r4, r4, r5				; else add on length of packet header
	SUBNE	r4, r4, #6				; but don't count start code or length in total length
	MOV	lr, r4, LSR #8
	STRB	lr, [r0, #PacketDescriptor_PTS+4]	; store len hi
	STRB	r4, [r0, #PacketDescriptor_PTS+5]	; store len lo

	ADD	r4, r0, #PacketDescriptor_PTS		; point r4 at new packet header
	MOV	lr, #0					; packet field must be zero, cos it's a fake lump
	STMIA	r3!, {r4, r5, lr}			; store address, length, packet in FIQ slot

	CMP	r3, #&100
	ADREQ	r3, FIQSlotSpace			; with wrap
	STR	r3, FIQSlotWritePtr

	LDR	r2, VideoAmountQueued
	ADD	r2, r2, r5
	STR	r2, VideoAmountQueued

	MOV	r2, #podule_FIQ_bit			; enable FIQ process
	MOV	lr, #IOC
	STR	r2, [lr, #IOCFIQMSK]

        BIC     r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
        STR     r1, [r0, #PacketDescriptor_Flags]       ; we don't send hdr again
        TEQ     r0, r0                                  ; set EQ state, so we attempt to send data
        EXIT

 ] ; UseWholePackets

; **************************************************************************
;
;       VideoFreePacket - Free a packet
;
; in:   r0 -> packet descriptor
;       (r11 -> L64002_Registers)
;       IRQs disabled
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;       Also updates VideoPacketListHeadPtr, VideoPacketListTailPtr
;       Flags must be preserved
;

VideoFreePacket ROUT
        Push    "r1, lr"
        MOV     r1, pc
        ORR     lr, r1, #I_bit
        TEQP    lr, #0                          ; disable IRQs round this

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, VideoPacketListHeadPtr	; update VideoPacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, VideoPacketListTailPtr	; then zero VideoPacketListTailPtr

        TEQP    r1, #0                          ; restore IRQ state

        Push    "lr"
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
        MOV     lr, pc
        LDR     pc, [r0, #PacketDescriptor_FreeRoutine]
        Pull    "r0,r1, pc",,^                     ; exit preserving flags

; **************************************************************************
;
;       SyncOffset_Code - Set offset added to SCR values before programming

SyncOffset_Code Entry
        LDR     wp, [r12]

        LDRB    r1, [r0, #0]
        TEQ     r1, #"-"
        ADDEQ   r0, r0, #1
        MOVEQ   r6, #1
        MOVNE   r6, #0
        MOV     r1, r0
        MOV     r0, #10 :OR: (1:SHL:31) ; insist on space or ctrl char terminator, base 10
        SWI     XOS_ReadUnsigned
        EXIT    VS

        TEQ     r6, #0
        RSBNE   r2, r2, #0
        STR     r2, SyncOffset
        EXIT

; **************************************************************************
;
;       VideoInfo_Code - Output debugging info

VideoInfo_Code Entry "r8"
        LDR     wp, [r12]
        DLINE   "Audio Sample rate: ", cc
        LDR     r0, AudioSampleRate
	ADD	r0, r0, #1
	CMP	r0, #8+1
	BCS	%FT10
        ADRL    lr, AudioSampleRateStringOffsets
        LDR     r0, [lr, r0, LSL #2]
        ADD     r0, r0, lr
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
	EXIT	VS
10
	DLINE	"Sequence layer data: ", cc
	ADR	r0, VideoSequenceData
	MOV	r1, #12
	BL	OutputHexBlock
	DLINE	""

 [ VetSCRValues
	LDR	r0, BadSCRCount
	DREG	r0, "Bad SCRs = "
 ]

	LDR	r0, DRAMBufferAddress
	DREG	r0, "DRAM buffer holds contents of address "
	DLINE	"...which are: ", cc
	ADR	r0, DRAMBuffer
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""

	LDR	r0, AudioChannelBufferReadPtr
	DREG	r0, "AudioChannelBufferReadPtr = "

	LDR	r0, AudioPTSInCount
	DREG	r0, "AudioPTSInCount = "

	LDR	r0, AudioFasts
	DREG	r0, "AudioFasts = "
	LDR	r0, AudioSlows
	DREG	r0, "AudioSlows = "

	LDR	r0, VideoSkips
	DREG	r0, "Video skips = "
	LDR	r0, VideoRepeats
	DREG	r0, "Video repeats = "
	LDR	r0, VideoPTSInCount
	DREG	r0, "Number of video PTSs that came in = "
	LDR	r0, VideoNumberOfPostedPTSs
	DREG	r0, "Number of posted video PTSs = "
	LDR	r0, VideoPTSPictureTypeCount_I
	DREG	r0, "Number of I-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_P
	DREG	r0, "Number of P-pictures with PTS = "
	LDR	r0, VideoPTSPictureTypeCount_B
	DREG	r0, "Number of B-pictures with PTS = "
	LDR	r0, VideoMinPTSDifference
	DREG	r0, "Most negative PTS-SCR = "
	LDR	r0, VideoMaxPTSDifference
	DREG	r0, "Most positive PTS-SCR = "

	LDR	r0, CurrentHorizontalSize
	DREG	r0, "Horizontal size = "
	LDR	r0, CurrentVerticalSize
	DREG	r0, "Vertical size = "
	LDR	r0, CurrentOutputWidth
	DREG	r0, "Horizontal display output size = "
	LDR	r0, VideoVBVSize
	DREG	r0, "Video VBV size = "

	DLINE	"** Audio info **"
	ADR	r8, AudioInfoStructure
	BL	OutputInfo

	DLINE	"** Video info **"
	ADR	r8, VideoInfoStructure
	BL	OutputInfo

	CLRV
	EXIT


OutputInfo Entry
	LDR	lr, [r8, #SI_SISPtr]
	LDR	r0, [lr, #SIS_SystemUnderruns]
	DREG	r0, "System buffer underruns = "
	LDR	r0, [lr, #SIS_DuffChannelAddresses]
	DREG	r0, "Duff channel addresses = "
	LDR	r0, [lr, #SIS_DuffSystemContents]
	DREG	r0, "Duff system buffer contents = "
	LDR	r0, [lr, #SIS_AddressOfLastDuff]
	DREG	r0, "Last duff contents address = "
	LDR	r0, [lr, #SIS_SystemBufferStart]
	DREG	r0, "SystemBufferStart = "
	LDR	r0, [lr, #SIS_SystemBufferEnd]
	DREG	r0, "SystemBufferEnd = "
	LDR	r0, [lr, #SIS_SystemBufferReadPtr]
	DREG	r0, "SystemBufferReadPtr = "
	LDR	r0, [lr, #SIS_SystemBufferWritePtr]
	DREG	r0, "SystemBufferWritePtr = "

	LDR	r2, [r8, #SI_PTSListReadPtr]
	DREG	r2, "PTSListReadPtr = "
	LDR	r3, [r8, #SI_PTSListWritePtr]
	DREG	r3, "PTSListWritePtr = "
	LDR	r0, [r8, #SI_PTSListOverruns]
	DREG	r0, "PTS list overruns = "
	LDR	r4, [r8, #SI_PTSListPtr]
	LDR	r5, [r8, #SI_PTSListSize]

	DLINE	"PTS List data:"
10
	TEQ	r2, r3
	BEQ	%FT20
	ADD	r0, r4, r2, LSL #3
	MOV	r1, #8
	BL	OutputHexBlock
	DLINE	""
	ADD	r2, r2, #1
	TEQ	r2, r5
	MOVEQ	r2, #0
	B	%BT10
20
        CLRV
        EXIT


OutputHexBlock Entry "r0-r2"
10
	LDRB	r2, [r0], #1
	BREG	r2, " ", cc
	SUBS	r1, r1, #1
	BNE	%BT10
	EXIT

AudioSampleRateStringOffsets
	&	SRUK-AudioSampleRateStringOffsets
	&	SR2205-AudioSampleRateStringOffsets
	&	SR2400-AudioSampleRateStringOffsets
	&	SR1600-AudioSampleRateStringOffsets
	&	SRReserved-AudioSampleRateStringOffsets
        &       SR4410-AudioSampleRateStringOffsets
        &       SR4800-AudioSampleRateStringOffsets
        &       SR3200-AudioSampleRateStringOffsets
        &       SRReserved-AudioSampleRateStringOffsets

SRUK    =       "Unknown", 0
SRReserved =	"Reserved", 0
SR2205	=	"22.05kHz", 0
SR2400	=	"24kHz", 0
SR1600	=	"16kHz", 0
SR4410  =       "44.1kHz", 0
SR4800  =       "48kHz", 0
SR3200  =       "32kHz", 0
        ALIGN

; **************************************************************************
;
;       AudioOpenStream - Open MPEG audio stream
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> audio parameters structure
;
; out:  r0 = audio stream handle
;

AudioOpenStream Entry "r1,r2, r11"
        LDR     r11, L64002_Registers
        STR     r0, AudioStreamFlags
        STR     r1, AudioControlStreamHandle

        MOV     r1, #0
        STR     r1, AudioStreamClosing
        STR     r1, AudioNumberOfPTSs

        MOV     r0, #0
	STR	r0, AudioAmountSent
	STR	r0, AudioInfoStructure+SI_PTSListReadPtr
	STR	r0, AudioInfoStructure+SI_PTSListWritePtr
	STR	r0, AudioInfoStructure+SI_PTSListOverruns
	STR	r0, AudioPacketListHeadPtr
	STR	r0, AudioPacketListTailPtr
	STR	r0, AudioPTSInCount
	STR	r0, AudioSystemInfoStructure+SIS_SystemUnderruns
	STR	r0, AudioSystemInfoStructure+SIS_DuffChannelAddresses
	STR	r0, AudioResyncDelay
	STR	r0, AudioFasts
	STR	r0, AudioSlows

 [ VetSCRValues
	STR	r0, VetSCRState				; indicate awaiting first SCR
	STR	r0, BadSCRCount				; no bad'uns yet
 ]

        MOV     r1, #0
        ADR     lr, AudioLastPTS
        STMIA   lr, {r0, r1}            ; zero LastPTS record

	MOV	r0, #1
	STR	r0, AudioPreFilling

	MOV	r0, #-1			; set audio sample rate to unknown
	STR	r0, AudioSampleRate
        MOV     r0, #&80000001          ; indicate pre-buffering, but would otherwise be playing normal speed
        STR     r0, AudioSpeedSetting

	LDR	r0, VideoControlStreamHandle
	TEQ	r0, #0
	BLEQ	InitStream_Common
	BL	AudioClaimInterruptVectors
        MOV     r0, r12
        CLRV
        EXIT

; **************************************************************************
;
;       AudioFullPackets - Here's some more data
;
; in:   r0 = flags
;       r1 = audio stream handle
;       r2 -> one or more linked bitstream packets

AudioFullPackets Entry "r0,r11"
        LDR     r11, [r2, #PacketDescriptor_Length]
        CMP     r11, #0
        BGE     %FT01                                   ; only complain about -ve length
        DREG    r11, "Packet length = "
01
        LDR     r11, L64002_Registers
        MOV     r0, pc
        Push    "r0"
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                                  ; disable IRQs round this bit

        LDR     r0, AudioPacketListTailPtr
        TEQ     r0, #0                                  ; if nothing on list
        STREQ   r2, AudioPacketListHeadPtr		; then point head at new packets
        STRNE   r2, [r0, #PacketDescriptor_Link]        ; else tail!link = packet
10
        LDR     r0, [r2, #PacketDescriptor_Link]        ; go down list of packets to end
        TEQ     r0, #0
        MOVNE   r2, r0
        BNE     %BT10

        STR     r2, AudioPacketListTailPtr		; store new tail pointer
        Pull    "r0"
        TEQP    r0, #0                                  ; restore IRQ state

        EXIT

; **************************************************************************
;
;       AudioCloseStream - Close MPEG audio stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGAudio_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:   r0 = flags
;       r1 = audio stream handle
;

AudioCloseStream Entry "r0-r2,r11"
        LDR     r11, L64002_Registers

        LDR     r0, AudioSpeedSetting
        TEQ     r0, #0
        BEQ     %FT50                                   ; [it was paused, so junk data]

        BPL     %FT10                                   ; [not pre-buffering, so wait for data to empty]

; we get a close while we're still waiting for the buffer to get full enough
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

        TEQ     r0, #&80000000
        BEQ     %FT50

   [ SendPlaySWI
        BLCS    AudioIssuePlaySWI
   |
        BLCS    AudioSendPlay
   ]

; wait for data to empty

10
        MOV     r0, #1                                  ; indicate to multiple picture packet checker that we won't get
        STR     r0, AudioStreamClosing			; any more data, so don't hang around
20
        TEQP    pc, #0
        NOP                                             ; allow callbacks
        SWI     OS_EnterOS

        LDR     r0, AudioPacketListHeadPtr		; do we have any outstanding packets?
        CMP     r0, #0                                  ; V := 0
        BNE     %BT20
	B	%FT70

; we're paused, so mark stream as closing, and free all packets

50
        MOV     r0, #2
        STR     r0, AudioStreamClosing
60
        LDR     r0, AudioPacketListHeadPtr
        CMP     r0, #0                          ; V := 0
        BLNE    AudioFreePacket
        BNE     %BT60
70
	BL	AudioReleaseInterruptVectors
	LDR	r0, VideoControlStreamHandle		; if video not open
	TEQ	r0, #0
	BLEQ	CommonReleaseInterruptVectors		; then shut whole lot down
	MOV	r0, #0
	STR	r0, AudioControlStreamHandle		; stream no longer open
        EXIT

; **************************************************************************
;
;       AudioPlay - Start going
;
; in:   r0 = flags
;       r1 = audio stream handle
;
; out:  -
;

AudioPlay Entry "r0,r2, r11"
        LDR     r2, AudioSpeedSetting
        BIC     r2, r2, #&80000000      ; clear pre-buffering bit
        STR     r2, AudioSpeedSetting
        BL      AudioSetSpeed
        EXIT

; **************************************************************************
;
;       AudioSetSpeed - Set speed of MPEG stream
;
; in:   r0 = flags
;       r1 = audio stream handle
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

AudioSetSpeed Entry "r0-r2, r11"
        LDR     r11, L64002_Registers
	CMP	r2, #8					; don't allow speeds slower than 8
        EXIT    HI

        LDR     r0, AudioSpeedSetting
	TST	r0, #&80000000				; if pre-buffering
	ORRNE	r2, r2, #&80000000			; then still pre-buffering, but may have speed setting after
        STR     r2, AudioSpeedSetting

        CMP     r2, #1
 [ VetSCRValues
	MOVNE	lr, #0					; if pause or slo-mo, reset vetting state
	STRNE	lr, VetSCRState				; until we receive 1st SCR after return to normal play
 ]
	BLT	%FT10					; pause (or pre-buffering)
	BEQ	%FT20					; normal speed

        MOV     r0, r2
        BL      AudioSlowMotion
        EXIT

10
        BL      AudioSendPause
        CLRV
        EXIT

20
        BL      AudioSendPlay
        EXIT

; **************************************************************************
;
;	AudioResetStream - Discard all data and reset L64002
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = audio stream handle
;
; out:	r2 = estimate of number of bytes discarded

AudioResetStream Entry "r0-r2"
	LDR	r11, L64002_Registers

	MOV	r2, #2				; pretend we're closing, so we don't send any more data to it in background
	STR	r2, AudioStreamClosing

	BL	AudioGetBufferFullness		; returns fullness in r2
	LDR	r0, AudioPacketListHeadPtr
10
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	AudioFreePacket				; and free the packet
	BNE	%BT10					; then loop

	STR	r2, [sp, #2*4]			; update returned r2 value with byte count

	MOV	r0, #0
	STR	r0, AudioStreamClosing
 [ VetSCRValues
	STR	r0, VetSCRState			; awaiting first SCR again
 ]
	MOV	r0, #1
	STR	r0, AudioPreFilling
	MOV	r0, #&80000001
	STR	r0, AudioSpeedSetting

	BL	AudioFlushBitstream

	CLRV
	EXIT

 [ SendPlaySWI

AudioIssuePlaySWI Entry "r0,r1"
        MOV     r0, #StreamFlags_AudioPresent   ; indicate audio now ready
        LDR     r1, AudioControlStreamHandle
        SWI     XMPEGControl_Play

        EXIT
 ]

; **************************************************************************
;
;       AudioFreePacket - Free a packet
;
; in:   r0 -> packet descriptor
;       (r11 -> CL450_Registers)
;       IRQs disabled
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;       Also updates AudioPacketListHeadPtr, AudioPacketListTailPtr
;       Flags must be preserved
;

AudioFreePacket ROUT
        Push    "r1, lr"
        MOV     r1, pc
        ORR     lr, r1, #I_bit
        TEQP    lr, #0                          ; disable IRQs round this

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, AudioPacketListHeadPtr	; update AudioPacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, AudioPacketListTailPtr	; then zero AudioPacketListTailPtr

        TEQP    r1, #0                          ; restore IRQ state

        Push    "lr"
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
        MOV     lr, pc
        LDR     pc, [r0, #PacketDescriptor_FreeRoutine]
        Pull    "r0,r1, pc",,^                     ; exit preserving flags

; **************************************************************************
;
;	AudioSendPlay - Start decoder playing

AudioSendPlay Entry "r0"
	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Play
	WriteRegI r0, AudioTrickModes, lr
	EXIT

; **************************************************************************
;
;	AudioSendPause - Stop decoder playing

AudioSendPause Entry "r0"
	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Pause
	WriteRegI r0, AudioTrickModes, lr
	EXIT

; **************************************************************************
;
;	AudioGetBufferFullness - Read buffer fullness from L64002
;
; in:	r11 -> L64002_Registers
;
; out:	r2 = fullness (in bytes)
;

AudioGetBufferFullness Entry "r0, r1"
	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access

	ReadRegI r1, AudioChannelBufferWrite0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r1, r1, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r1, r1, lr, LSL #16		; r1 is now complete write ptr, in units of 8 bytes

	ReadRegI r2, AudioChannelBufferRead0
	ReadRegI lr, PreviouslyReadPtr1
	ORR	r2, r2, lr, LSL #8
	ReadRegI lr, PreviouslyReadPtr2
	AND	lr, lr, #3			; don't include wrap bits
	ORR	r2, r2, lr, LSL #16		; r2 is now complete read ptr, in units of 8 bytes

	SUBS	r2, r1, r2			; r2 = write - read
	MOV	r2, r2, LSL #3			; convert to bytes
	LDRCC	r1, AudioChannelBufferSize	; if negative then
	ADDCC	r2, r2, r1			; adjust for wraparound

	TEQP	r0, #0

	CLRV
	EXIT

; **************************************************************************
;
;	AudioTickerV - Audio TickerV routine

AudioTickerV Entry "r0-r2"
        LDR     r0, AudioCallBackRequested	; is a callback already requested
        TEQ     r0, #0
        EXIT    NE				; if so, don't ask for another
        MOV     r2, pc
        ORR     r1, r2, #SVC_mode		; go into SVC mode to save lr_svc so we can SWI
        TEQP    r1, #0
        NOP
        Push    "r14"
        LDR     r0, AudioStreamFlags
        TST     r0, #StreamFlags_UseCallBacks
        BEQ     %FT20				; [stuff directly]

        ADR     r0, AudioTickerVCallBack
        MOV     r1, wp
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVC   r0, AudioCallBackRequested	; indicate that we've requested a callback
10
        Pull    "r14"
        TEQP    r2, #0
        NOP
        EXIT

20
        MOV     r0, #1
        STR     r0, AudioCallBackRequested
        BL      AudioTickerVCallBack
        B       %BT10

        LTORG

AudioTickerVCallBack Entry "r0,r1, r11"
 [ EnableIRQsInTickerV
        MOV     lr, pc
        BIC     lr, lr, #I_bit          ; enable IRQs
        TEQP    lr, #0
 ]
        LDR     r11, L64002_Registers
        BL      AudioDoStuffWithData
        MOV     r0, #0
        STR     r0, AudioCallBackRequested
        EXIT

        LTORG

AudioDoStuffWithData Entry "r0"
        LDR     r0, AudioStreamClosing	; if stream closing (ie value = 2)
        CMP     r0, #1                  ; don't send any more data
        EXIT    HI
05
        LDR     r0, AudioPacketListHeadPtr
        TEQ     r0, #0                  ; do we have any data?
	BEQ	%FT50			; [no, so skip]

 [ UseWholePackets
	BL	AudioSendNewPacketIfNecessary
	BLEQ	AudioSendData
 |
        BL      AudioSendData
 ]
        BLEQ    AudioFreePacket
        BEQ     %BT05
50
	BL	AudioDoStreamSync	; check buffer fullness
        EXIT

; **************************************************************************
;
;       AudioDoStreamSync - Synchronise to stream (if required)
;
; in:   r11 -> L64002_Registers
; out:  -

AudioDoStreamSync Entry "r0-r2"
        LDR     r0, AudioStreamClosing		; if not active, exit
        TEQ     r0, #0
        EXIT    NE

	LDR	r0, AudioSpeedSetting
	TEQ	r0, #0				; if paused (0) or pre-filling (bit 31 set)
	EXIT	LS				; then exit

        LDR     r0, AudioStreamFlags
        TST     r0, #StreamFlags_SyncToStream	; if not syncing to stream
        EXIT    EQ				; then exit

        LDR     r0, AudioResyncDelay
        SUBS    r0, r0, #1
        STRCS   r0, AudioResyncDelay
        EXIT    CS

	BL	AudioGetBufferFullness		; returned in r2
	STR	r2, LastAudioBufferFullness
	LDR	lr, AudioBufferChecks
	ADD	lr, lr, #1
	STR	lr, AudioBufferChecks

        LDR     r1, =AudioBufferLowWaterMark
        CMP     r2, r1
        MOVCC   r1, #AudioResyncRepeat-1
        STRCC   r1, AudioResyncDelay
        BLCC    AudioPlaySlowFrame

        LDR     r1, =AudioBufferHighWaterMark
        CMP     r2, r1
        MOVCS   r1, #AudioResyncRepeat-1
        STRCS   r1, AudioResyncDelay
        BLCS    AudioPlayFastFrame
        EXIT

; **************************************************************************
;
;       AudioPlayFastFrame - Play one audio frame fast
;
; in:   r11 -> L64002 registers
;
; out:  -

AudioPlayFastFrame Entry "r0"
	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Fast
	WriteRegI r0, AudioTrickModes, lr

        LDR     lr, AudioFasts
        ADD     lr, lr, #1
        STR     lr, AudioFasts
        CLRV
        EXIT

; **************************************************************************
;
;       AudioPlaySlowFrame - Play one audio frame slow
;
; in:   r11 -> L64002 registers
;
; out:  -

AudioPlaySlowFrame Entry "r0"
	ReadRegI r0, AudioTrickModes
	AND	r0, r0, #AudioTrickModes_ValidBits :AND: :NOT: AudioTrickModes_PausePlayFastSlowBits
	ORR	r0, r0, #AudioTrickModes_Slow
	WriteRegI r0, AudioTrickModes, lr

        LDR     lr, AudioSlows
        ADD     lr, lr, #1
        STR     lr, AudioSlows
        CLRV
        EXIT

 [ UseWholePackets
; **************************************************************************
;
;       AudioSendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:   r0 -> packet descriptor
; out:  EQ => ok to send actual data, NE => don't try - we're not ready yet
;

AudioSendNewPacketIfNecessary Entry "r1-r5, r11"
;	BL	CheckForSyncWord
;	EXIT	NE
	LDR	r1, [r0, #PacketDescriptor_Flags]
	TST	r1, #PacketDescriptorFlags_MPEGStart    ; is it start of an MPEG packet?
	EXIT	EQ                                      ; [no, so no packet header required, exit EQ => try to send data]

	LDR	r11, L64002_Registers

	ReadReg	r2, Status0
	TST	r2, #L64002_Status0_AudioChannelReady
	BNE	%FT10					; [is some space free in buffer]

	CMP	pc, #0					; set NE, ie not OK to continue
	EXIT

10
        LDR     r2, L64002_Audio_Data_Write
        MOV     r3, #0
        BL	AudioWaitAndSendByte			; send 1st byte of start code
        BL	AudioWaitAndSendByte			; send 2nd byte of start code
        MOV     r3, #1
        BL	AudioWaitAndSendByte			; send 3rd byte of start code
        MOV     r3, #&C0
        BL	AudioWaitAndSendByte			; send 4th byte of start code
        LDR     r4, [r0, #PacketDescriptor_FullLength]
        TST     r1, #PacketDescriptorFlags_PTSValid
        BEQ     %FT30
        MOV     r3, pc
        ORR     lr, r3, #I_bit
        TEQP    lr, #0
        LDR     lr, AudioPTSInCount			; increment count of PTS's coming in
        ADD     lr, lr, #1
        STR     lr, AudioPTSInCount
        TEQP    r3, #0
30
        ADDEQ   r4, r4, #1                              ; add on one for 0F byte if no PTS
        ADDNE   r4, r4, #5                              ; add on five for PTS
        MOV     r3, r4, LSR #8
        BL	AudioWaitAndSendByte			; send hi byte of length
        AND     r3, r4, #&FF
        BL	AudioWaitAndSendByte			; send lo byte of length
        MOVEQ   r3, #&0F                                ; no PTS, so send terminating code
        BEQ     %FT50

        LDR     r4, [r0, #PacketDescriptor_PTS]         ; get bits 31..0 of PTS
        LDR     r5, [r0, #PacketDescriptor_PTS+4]       ; get bit 32 of PTS
        MOV     r3, r4, LSR #29                         ; r3 = bits 31..29 in bits 2..0
        ORR     r3, r3, r5, LSL #3                      ; r3 = bits 32..29 in bits 3..0
        ORR     r3, r3, #&21                            ; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
        BL	AudioWaitAndSendByte
        MOV     r3, r4, LSR #22                         ; r3 = bits 29..22 in bits 7..0
        BL	AudioWaitAndSendByte			; (only stores bottom 8 bits)
        MOV     r3, r4, LSR #14                         ; r3 = bits 21..14 in bits 7..0
        ORR     r3, r3, #1                              ; force bit 0 to 1 (marker)
	BL	AudioWaitAndSendByte
        MOV     r3, r4, LSR #7                          ; r3 = bits 14..7 in bits 7..0
	BL	AudioWaitAndSendByte
        MOV     r3, r4, LSL #1                          ; r3 = bits 6..0 in bits 7..1
        ORR     r3, r3, #1
50
	BL	AudioWaitAndSendByte
        BIC     r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
        STR     r1, [r0, #PacketDescriptor_Flags]       ; we don't send hdr again
        TEQ     r0, r0                                  ; set EQ state, so we attempt to send data
        EXIT

AudioWaitAndSendByte Entry
10
	ReadReg	lr, Status0
	TST	lr, #L64002_Status0_AudioChannelReady
	BEQ	%BT10
	STRB	r3, [r2]
	EXITS

 ] ; UseWholePackets

; **************************************************************************
;
;       AudioSendData - Send a block of data
;
; in:   r0 -> packet descriptor
;       r11 -> L64002_Registers
;
; out:	EQ => used up all data in this packet

AudioSendData Entry "r0-r4"
        LDR     r1, [r0, #PacketDescriptor_Start]
        LDR     r3, [r0, #PacketDescriptor_Length]
        CMP     r3, #0                  		; zero length?
        EXIT    EQ

	BL	AudioGetBufferFullness
	LDR	lr, AudioChannelBufferSize
	SUB	r2, lr, r2				; amount of free space in audio channel buffer

	CMP	r2, r3					; if more than packet size
	MOVHI	r2, r3					; then do packet amount

	MOV	r3, r2					; number left to do (save r2 for later)
	LDR	lr, L64002_Audio_Data_Write
10
	ReadReg	r4, Status0
	TST	r4, #L64002_Status0_AudioChannelReady
	BEQ	%FT15					; [not ready, so exit]

	LDRB	r4, [r1], #1
	STRB	r4, [lr]
	SUBS	r3, r3, #1
	BNE	%BT10
15
	SUB	r2, r2, r3				; number of bytes sent

        LDR     r4, [r0, #PacketDescriptor_Length]
        SUB     r4, r4, r2				; decrement remaining length
	STR	r4, [r0, #PacketDescriptor_Length]

	LDR	lr, AudioAmountSent
	ADD	lr, lr, r2
	STR	lr, AudioAmountSent

        LDR     r3, AudioPreFilling
	TEQ	r3, #0
	BEQ	%FT20

	LDR	r3, =AudioPreFillSize
	CMP	lr, r3
	MOVCS	lr, #0
	STRCS	lr, AudioPreFilling
        BLCS    AudioIssuePlaySWI
20
        STR     r1, [r0, #PacketDescriptor_Start]
        TEQ     r4, #0
        EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

SetupData
        BIN     "$SetupFile"
SetupDataEnd

        InsertDebugRoutines

        END
