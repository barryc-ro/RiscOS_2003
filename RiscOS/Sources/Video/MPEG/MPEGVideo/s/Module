; > Module
; Source for MPEG Video Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 17-May-94  TMD  0.01          Started work
; 03-Jun-94  TMD  0.02          Variable transparency now possible in 16bpp
; 08-Jun-94  TMD  0.03          Added SWI MPEGVideo_CardControl
; 13-Jun-94  TMD  0.04          Added bodge for audio IRQ booboo
; 24-Jun-94  TMD  0.05          Started putting synchronisation stuff in
; 07-Jul-94  TMD  0.06          New stuffing strategy implemented - stuff on a callback from TickerV
; 18-Jul-94  TMD  0.10          Release for Malcolm's trip
; 22-Jul-94  TMD  0.11          Added SyncOffset command
; 29-Jul-94  TMD  0.13          Modified CloseStream behaviour to wait until empty unless paused, in which case junk data
; 17-Aug-94  TMD  0.14          Made transition from pause or slomo to normal set the SCR to the last received PTS
;                                before sending Play command.
; 18-Aug-94  TMD  0.15          Added MPEGVideo_ReadParameters (Read time code)
; 19-Aug-94  TMD  0.16          Started putting in skip to GOP or sequence header stuff (incomplete)
; 22-Aug-94  TMD  0.17          On close, if still in initial pause state, then send Play command.
; 22-Aug-94  TMD  0.18          (Conditionally) enable IRQs inside TickerV during foreground stuffing.
; 26-Aug-94  TMD  0.19          Only enable IRQs in TickerV if not doing AudioIRQBodge.
; 31-Aug-94  TMD  0.20          (Conditionally) select fast (type C) podule access.
; 31-Aug-94  TMD  0.21          Added support for directly calling SetSCR.
; 01-Sep-94  TMD  0.22          Added code to time completion of previous command.
; 05-Sep-94  TMD  0.23          (Conditionally) throw away PTSs if they are within a range of the last one sent.
; 08-Sep-94  TMD  0.24          Pass flags to MPEGControl_Play
; 08-Sep-94  TMD  0.25          Started to add MPEG still capability
; 09-Sep-94  TMD  0.26          (Conditionally) throw away SCRs if they are withing a range of the last one sent.
; 09-Sep-94  TMD  0.27          (Conditionally) check packets for more than one picture_start code
; 12-Sep-94  TMD  0.28          Added reason code 2 (Update Control register) to MPEGVideo_CardControl
;                               Check existence of system variable 'TVOn' to determine whether to enable CTRL0, CTRL1 on init
; 10-Oct-94  TMD  0.29          If waiting for stream to close, don't stop sending an incomplete packet in order to check it.
; 12-Oct-94  TMD  0.30          Don't print warning message on zero-length packets
; 20-Oct-94  TMD  0.31          Fixed stack-imbalance in MyAudioIRQRoutine
; 07-Nov-94  TMD  0.32          Remember speed setting if received while pre-buffering
; 07-Nov-94  TMD  0.33          When we start playing, set the SCR to the last received PTS value, so -noaudio works from
;                                middle of file
; 16-Nov-94  TMD  0.34          Changes to support MPEG 2 indeterminate-length packets.
; 05-Dec-94  TMD  0.35          Reverse length correction for odd-length packets
; 07-Dec-94  TMD  0.36          Start putting in skipping until GOP or sequence_header by blanking display
;                                until we get the appropriate IRQ from CL450
; 12-Dec-94  TMD  0.37          Separate out the options for SEQ, GOP or PIC skipping.
; 14-Dec-94  TMD  0.38          Created 'M' variant for CC/Wild Vision Movie Magic card.
; 14-Dec-94  TMD  0.39          Added 'NoInterlace' bit to video flags
; 15-Dec-94  TMD  0.40          Fixed accidental V set returning when pausing while pre-buffering.
;                               Fixed CloseStream hanging if we aborted while pre-buffering.
; 15-Dec-94  TMD  0.41          Always enable PIC-V IRQ but don't unblank on it unless the appropriate bit
;                               is set in VideoStructure_Flags. This is because SEQ-V and GOP IRQs seem to be
;                               inhibited on certain clips if PIC-V is not also enabled.
; 17-Feb-95  TMD  0.42		Change product-type matching code for recognition of podule:
;				 No longer match &0000 in any version
;				 Do allow &00F9 in all versions (as well as &00FF in non-'M' versions)
; 06-Mar-95  TMD  0.43		Added MPEGVideo_ResetStream (initial implementation)
; 16-Mar-95  TMD  0.44		Fixed bug which cleared -nocls and -nopalettechange flags if skipping to pic,seq, or gop
; 01-May-95  TMD  0.45		Added call to read current SCR value (MPEGVideo_ReadParameters(3))
; 02-May-95  TMD  0.46		Update to detect STB2 product type, and add extra functionality:-
;				 Add bit 8 to control register, and change default value;
;				 Copy bit 6 to modulator/not boost register;
;				 Handle MPEGVideo_CardControl(3) to stop/restart CL450 clock, including resending micro-code
;				 on restart.
; 03-May-95  TMD  0.47		On STB2, default value of control register should select VIDC20 IIS sound, not AV110 sound.
; 11-May-95  TMD  0.48		Incorporate new micro-code version (2.17) and radically alter specification of
;				 MPEGVideo_DisplayStill.
; 12-May-95  TMD  0.49		Allow skipping of SetVideoFormat(), SetBorder() and SetWindow() for subsequent DisplayStills.
; 05-Jun-95  TMD  0.50		On Roadster, allow module to stay alive so that MPEGVideo_CardControl works for STBState module,
;				 but there's no CL450 so don't try to talk to it.
; 26-Jun-95  TMD  0.51		If not on STB2, still initialise CL450 on module init.
; 12-Jul-95  MT   0.52          Support for new MPEGAudio module, which can cause PFIQ from AV110: allow AV110NoIRQ
;                               bit to be totally ignored; also (with TMD) improved handling of -ve SyncOffsets.
; 10-Aug-95  TMD  0.53		More debugging in VideoInfo
;				If not in 16bpp mode, don't do palette reprogramming, but *do* set VIDC20 External Register.
;
; 23-Aug-95  TMD  0.54		Added support for starting paused but with 1st picture visible.
; 24-Aug-95  TMD  0.55		Correct failure to initialise PendingPause variable.
; 29-Aug-95  TMD  0.56		Correct failure to restore IRQ state on exit from ReadSCR (in SendMacroCommand)
;				Fix SendMacroCommand not initialising HOST_raddr for each read (so ReadSCR works now).
; 05-Sep-95  TMD  0.57		If CloseStream called while pre-buffering, call Play directly not via SWI.
; 19-Sep-95  TMD  0.58		Added PauseAfterResetStream option.
; 10-Oct-95  TMD  0.59		Add option to check system variable MPEG$PoduleNumber for override on podule number.
; 13-Oct-95  TMD  0.60		Made the zeroing of all CL450 DRAM an option (set to FALSE at the moment).
; 16-Oct-95  TMD  0.61		Start investigating why doesn't always work without zeroing of DRAM.
; 16-Oct-95  TMD  0.62		Zero the one location in the DRAM that seems to cause the blobby problem.
; 24-Oct-95  TMD  0.63		Added ReadParameters(4) - read buffer fullness (for debugging).
; 25-Oct-95  TMD  0.64		(Conditionally) enable underrun interrupts.
; 25-Oct-95  TMD  0.65		(Conditionally) skip initial non-MPEG-start packets. This fixes the problem when
;				 repositioning within an MPEG-2 TS where after the ResetStream, data was sent without a
;				 preceding NewPacket command, which puts the CL450 into the mode where it ignores PTSs.
; 26-Oct-95  TMD  0.66		Blank screen on ResetStream, if flag set in VideoStructureFlags (doesn't work properly).
; 31-Oct-95  TMD  0.67		(Conditionally) record last buffer fullness before FlushBitstream.
; 01-Nov-95  TMD  0.68		Apply fix for microcode bug 2007 (ie FlushBitstream crashing on full buffer)
; 01-Nov-95  TMD  0.69		If in pause mode when ResetStream issued, issue Play command before waiting for not-full.
; 06-Nov-95  TMD  0.70		More debugging info added.
; 06-Nov-95  TMD  0.71		(Conditionally) don't sent FlushBitstream command if we haven't sent any data nor any
;				 NewPacket command since the last ResetStream.
; 08-Nov-95  TMD  0.72		More debugging info added.
; 09-Nov-95  TMD  0.73		Write SCR to zero in ResetStream. Use correct header for STB2_MPEG0 product type.
; 09-Nov-95  TMD  0.74		Undid various debugging workarounds.
; 10-Nov-95  TMD  0.75		More debugging info!
; 13-Nov-95  TMD  0.76		Stay in user mode throughout wait for data to drain.
; 20-Nov-95  TMD  0.77		Check StreamFlags_StartPaused passed to ResetStream.
; 23-Nov-95  TMD  0.78		Disable underrun traps - believed to cause frequent crashes at present.
; 23-Nov-95  TMD  0.79		Issue dummy OS_ReadEscapeState SWI inside data drain loop, so that callbacks go off on
;				 exit from the SWIs, if IRQ callbacks have been indefinitely postponed due to RISC OS bug.
; 24-Nov-95  TMD  0.80		Add support for generating YUV output, for Macrovision use.
; 29-Nov-95  TMD  0.81		Removed debugging in ResetStream.
; 14-Dec-95  TMD  0.82		Try setting border colour before SetBlank, cos it looks like SetBlank is just sampling the
;				 border colour at the time, to fill the window, and not updating it when the border colour
;				 is changed later.
; 14-Dec-95  TMD  0.83		Added new CardControl reason code to send macro commands directly.
; 15-Jan-96  TMD  0.84		Added new CardControl reason code to dynamically switch between RGB and YUV output.
; 17-Jan-96  TMD  0.85		Added new flag bit to disable vertical auto-centering.
; 22-Jan-96  TMD  0.86		Added new ReadParameters reason code to check display is ready (not yet functional).
; 24-Jan-96  TMD  0.87		Put in delay after unblank before DisplayReady variable is set.
; 06-Mar-96  TMD  0.88		Make trapping of underruns a run-time option.
; 07-Mar-96  TMD  0.89		Add MPEGVideo_Stats.
; 20-Mar-96  TMD  0.90		Add (conditional) manual skipping of video data until sequence header after ResetStream.
;				This is currently conditioned out.
;				Add Service_PreReset handler.
; 20-May-96  TMD  0.91		Try removing multiple picture packet checks when not using 2.00 microcode.

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

ControlRegisterSoftCopy * &1584

VIDC    *       &03500000

MPEG_sequence_header_code       *       &B3
MPEG_group_start_code           *       &B8

        ^       0, wp

 [ DebugStats
RetryCountArray         #       16*4    ; array of 16 words - element[i] is number of times retry count fell in range i
MaxRetries              #       4       ; maximum number of retries we had to do on sending
 ]
 [ UseRDY
StreamState             #       4       ; state-machine state
OutstandingDataSize     #       4       ; length in bytes of data required to
                                        ; complete NewPacket length
 |
CallBackRequested       #       4       ; whether a callback is outstanding
 ]

IRQCounts               #       16*4    ; counts of each type of IRQ we've had

Podule_Base             #       4       ; address of base of podule
Podule_ControlStatus    #       4       ; address of podule control/status register
CL450_Base              #       4       ; base address of CL450
CL450_DRAM              #       4       ; base address of CL450 DRAM
CL450_Registers         #       4       ; base address of CL450 registers
CL450_CMEM              #       4       ; base address of CL450 CMEM
AV110_Base              #       4       ; base address of AV110
CL450_Clock_Disable	#	4	; register that controls CL450 clock stop on STB2

MCode_init_PC           #       4       ; micro-code initial PC value
MCode_imem_dram         #       4       ; limit of instruction memory
MCode_num_segments      #       4       ; number of segments

PoduleControlSoftCopy   #       4       ; soft copy of control register

PoduleHeaderBuffer      #       16      ; used to read podule headers

ControlStreamHandle     #       4

IRQVectorClaimed        #       4       ; NZ => device vector claimed
EventVectorClaimed	#	4	; NZ => event vector claimed

InterruptMaskCommand    #       5*4     ; command block for sending
                                        ; SetInterruptMask commands
AccessSCRCommand        #       5*4     ; command block for sending
                                        ; AccessSCR commands
NewPacketCommand        #       5*4     ; command block for sending
                                        ; NewPacket commands
SetBorderCommand        #       5*4     ; command block for sending
                                        ; SetBorder commands
SlowMotionCommand       #       5*4     ; command block for sending
                                        ; SlowMotion commands
SetVideoFormatCommand   #       5*4     ; command block for sending
                                        ; SetVideoFormat commands
InquireBufferFullnessCommand #	5*4	; command block for sending
					; InquireBufferFullness commands
FlushBitstreamCommand	#	5*4	; command block for sending
					; FlushBitstream commands
SetColorModeCommand	#	5*4	; command block for sending
					; SetColorMode commands

PacketListHeadPtr       #       4       ; pointer to head of list of packet descriptors
PacketListTailPtr       #       4       ; pointer to tail of list

TrailingByte            #       4       ; 0 if no trailing byte, else 2^31 + byte value

BorderLeft              #       4       ; left hand border
BorderTop               #       4       ; top border

AudioIRQWorkspace       #       4       ; workspace for audio IRQ code
AudioIRQRoutine         #       4       ; routine for audio IRQ

UnknownLengthPacket     #       4       ; points to 1st packet in chain forming an indeterminate length packet, or zero if none

 [ PreFillBuffer
AmountSent              #       4       ; amount of data sent (-1 => finished with pre-fill)
 ]
AmountReceived		#	4	; amount of data received
StreamClosing           #       4       ; 0 normally; 1 => we won't receive any more data - keep sending, but don't hang aroud
                                        ; on partial packet at end; 2 => don't send any more.
SyncOffset              #       4       ; amount to add to clock values
StreamFlags             #       4       ; stream flags
SpeedSetting            #       4       ; speed 0 => paused, 1 => normal, 2..8 => slow-mo, bit 31 set => paused during pre-buffering
LastPTS                 #       8       ; last PTS value rec'd, used to set SCR after switching from slow-motion to normal play
LastSCR                 #       8       ; last SCR value rec'd
NumberOfPTSs            #       4       ; number of PTSs sent
 [ SkippingCode
StartSkipCode           #       4       ; bottom byte of start code to skip to initially, or zero if no skip
 ]
CompletionTime          #       4       ; Timer 1 counter after last command completed
MaxCompletionTime       #       4       ; Maximum value of completion time

CardType		#	4	; 1 => RISC PC, STB1; 2 => STB2
StillPacketListTailPtr	#	4	; pointer to tail end of still picture packet list
PendingPause		#	4	; 0 unless there is a pending pause on startup, in which case 1
 [ RegisterLastFullness
LastFullness		#	4	; record of last buffer fullness before FlushBitstream
 ]
LastAmountSent		#	4	; record of AmountSent before last ResetStream
DisplayReady		#	4	; 0 if 1st picture not displayed yet, else number of frames since we unblanked,
					; up to a maximum of DisplayReadyLatency

VideoStructureFlags     #       4
SetBlankCommand         #       5*4     ; command block for sending
                                        ; SetBlank commands
LastCommandSent		#	4	; 0 => pause, 1 => play, 2..4 => slow motion, -1 => none
NumberOfResets		#	4	; number of resetstreams since file was opened

 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
UnderrunCount		#	4	; number of underrun conditions since stream opened
UnderrunCondition	#	4	; 0 => normal operation, 1 => underrun condition, so if new data arrives then
					; clear InterruptStatus after sending data
 ]

 [ SkipInitialNonMPEGStarts
HadProperPacketStart	#	4	; 0 => still waiting for first MPEG packet start, 1 otherwise
 ]

 [ ManuallySkipToSequence
SkippingToSequence	#	4	; 0 => normal operation, 1 => skipping to sequence header after resetstream
 ]

 [ DontFlushOnEmpty
StartedSending		#	4	; 0 until first NewPacket command is sent, afterwards 1
LastFlushDidntHappen	#	4	; 0 unless last flush wasn't performed, in which case 1
 ]

 [ MultiplePicturePacketsChecks
MPDebugArraySize * 100
MultiPacketCount        #       4       ; Count of packets with more than 1 picture start code
MPDebugArrayPtr         #       4       ; Pointer to array, for external reading
CheckedBadPacket        #       4       ; Whether we saw the dodgy packet
MPDebugArray            #       MPDebugArraySize *4
 ]

 [ FullLengthStats
LengthStatsArraySize    *       8192    ; room for this number of entries (each 1 word full length)
LengthStatsPosition     #       4       ; position in array
LengthStatsArray        #       LengthStatsArraySize *4
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

Module_WorkspaceSize * :INDEX: @

 [ PreFillBuffer
PreFillSize     *       46*1024         ; the actual size of the buffer on the CL450
 ]

 [ SkipPTSs
PTSSkipRange    *       40960           ; if PTS is within ± ~4/9 seconds of last one, skip it (40960 is a valid immediate)
 ]

 [ SkipSCRs
SCRSkipRange    *       40960           ; if SCR is within ± ~4/9 seconds of last one, skip it (40960 is a valid immediate)
 ]

VideoFIFOThreshold      *       8*1024  ; must be 8K free when get RDY IRQ
 [ UseRDY

; Values in StreamState

                           ^ 0

StreamState_WaitingForRDY  # 1  ; waiting for CL450 RDY IRQ
                                ; (may or may not have data)

StreamState_WaitingForData # 1  ; waiting for data

 |
NumberOfRetries * 16
 ]

; Card types

		^	1
CardType_STB1	#	1
CardType_STB2	#	1
CardType_Roadster #	1

DisplayReadyLatency	*	3	; two vsyncs after initial indication of readiness

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

        GBLL    debug
debug   SETL    {FALSE}

 [ UseRDY
        MACRO
        CheckForReady   $temp, $temp2
  [ DebugStats
        MOV     $temp2, #0
10
        LDR     $temp, [r11, #CMEM_dmactrl]
        TST     $temp, #&100
        ADDEQ   $temp2, $temp2, #1
        BEQ     %BT10

        LDR     $temp, MaxRetries
        CMP     $temp2, $temp
        STRHI   $temp2, MaxRetries

; now work out which slot to increment

;        MOV     $temp2, $temp2, LSR #8
        CMP     $temp2, #15
        MOVHI   $temp2, #15
        ADR     $temp, RetryCountArray
        ADD     $temp2, $temp, $temp2, LSL #2
        LDR     $temp, [$temp2, #0]
        ADD     $temp, $temp, #1
        STR     $temp, [$temp2, #0]

  |
10
        LDR     $temp, [r11, #CMEM_dmactrl]
        TST     $temp, #&100
        BEQ     %BT10
  ]
        MEND
 |
        MACRO
        CheckForReady   $temp, $temp2, $exitroutine
        MOV     $temp2, #NumberOfRetries
10
        LDR     $temp, [r11, #CMEM_dmactrl]
        TST     $temp, #&100
        BNE     %FT20
        SUBS    $temp2, $temp2, #1
        BNE     %BT10
        B       $exitroutine
20
        MEND
 ]

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   $string, $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, $string, $cc, $routine
 ]
        MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGVideoSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "MPEGVideo", 0

Mod_HelpStr
        =       "MPEGVideo", TAB, "0.91 (20 May 1996)"
 [ CL450MCode <> "DRAM2_00"
	=	" (with $CL450MCode microcode)"
 ]
	= 0
        ALIGN

Mod_SWITable
        =       "MPEGVideo", 0
        =       "OpenStream", 0
        =       "FullPackets", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
        =       "CardControl", 0
        =       "SetSCR", 0
        =       "ReadParameters", 0
	=	"ResetStream", 0
        =       "DisplayStill", 0
	=	"Stats", 0
        =       0
        ALIGN

Mod_HC_Table
        Command SyncOffset, 1, 1
        Command VideoInfo, 0, 0
        =       0

SyncOffset_Help
        =       "*SyncOffset sets the offset to be added to the clock value"
        =       " before programming into the CL450.", CR
SyncOffset_Syntax
        =       "Syntax: *SyncOffset <value>", 0
VideoInfo_Help
        =       "*VideoInfo outputs debugging info.", CR
VideoInfo_Syntax
        =       "Syntax: *VideoInfo", 0
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        BL      FindPoduleNumber
        EXIT    VS

        MOV     r0, #0
        STR     r0, IRQVectorClaimed
	STR	r0, EventVectorClaimed
        STR     r0, PacketListHeadPtr
        STR     r0, PacketListTailPtr
        STR     r0, TrailingByte
        STR     r0, SyncOffset
	STR	r0, AmountReceived
	STR	r0, DisplayReady
 [ UseRDY
        STR     r0, OutstandingDataSize
 |
        STR     r0, CallBackRequested
 ]
 [ DebugStats
        STR     r0, MaxRetries
 ]

        ADR     r1, IRQCounts
        MOV     r2, #16
10
        STR     r0, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT10

 [ DebugStats
        ADR     r1, RetryCountArray
        MOV     r2, #16
10
        STR     r0, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT10
 ]

        STR     r0, InterruptMaskCommand +8     ; put zero as HMEM[2..4]
        STR     r0, InterruptMaskCommand +12    ; for SetInterruptMask
        STR     r0, InterruptMaskCommand +16    ; commands

        STR     r0, AccessSCRCommand +16        ; zero HMEM[4] for AccessSCR

        STR     r0, SlowMotionCommand +8
        STR     r0, SlowMotionCommand +12
        STR     r0, SlowMotionCommand +16

        STR     r0, SetVideoFormatCommand +8
        STR     r0, SetVideoFormatCommand +12
        STR     r0, SetVideoFormatCommand +16

	STR	r0, InquireBufferFullnessCommand +4
	STR	r0, InquireBufferFullnessCommand +8
	STR	r0, InquireBufferFullnessCommand +12
	STR	r0, InquireBufferFullnessCommand +16

	STR	r0, FlushBitstreamCommand +8
	STR	r0, FlushBitstreamCommand +12
	STR	r0, FlushBitstreamCommand +16

        STR     r0, SetBlankCommand +8
        STR     r0, SetBlankCommand +12
        STR     r0, SetBlankCommand +16

	STR	r0, SetColorModeCommand +8
	STR	r0, SetColorModeCommand +12
	STR	r0, SetColorModeCommand +16

        LDR     r0, =MacroCommand_SetBlank
        STR     r0, SetBlankCommand +0

        LDR     r0, =MacroCommand_SetInterruptMask
        STR     r0, InterruptMaskCommand +0

        LDR     r0, =MacroCommand_AccessSCR
        STR     r0, AccessSCRCommand +0

        LDR     r0, =MacroCommand_NewPacket
        STR     r0, NewPacketCommand +0

        LDR     r0, =MacroCommand_SetBorder
        STR     r0, SetBorderCommand +0

        LDR     r0, =MacroCommand_SlowMotion
        STR     r0, SlowMotionCommand +0

        LDR     r0, =MacroCommand_SetVideoFormat
        STR     r0, SetVideoFormatCommand +0

	LDR	r0, =MacroCommand_InquireBufferFullness
	STR	r0, InquireBufferFullnessCommand +0

	LDR	r0, =MacroCommand_FlushBitstream
	STR	r0, FlushBitstreamCommand +0

	LDR	r0, =MacroCommand_SetColorMode
	STR	r0, SetColorModeCommand +0

        ADRL    r0, MyAudioIRQRoutine
        STR     r0, AudioIRQRoutine
        STR     r12, AudioIRQWorkspace

        MOV     r0, #Podule_ReadInfo_EASILogical
        ADR     r1, Podule_Base
        MOV     r2, #4
        SWI     XPodule_ReadInfo
 [ CheckPoduleVariable
	MOVVS	r0, r3, LSL #24				; if get error, then do it by hand, as it might be a
	ORRVS	r0, r0, #&88000000			; podule without an EPROM
	STRVS	r0, Podule_Base
 |
        EXIT    VS
 ]

        LDR     r0, Podule_Base
        ADD     r1, r0, #Offset_Podule_ControlStatus
        STR     r1, Podule_ControlStatus

        ADD     r1, r0, #Offset_CL450_Base
        DReg    r1, "CL450_Base = "
        STR     r1, CL450_Base
        ADD     r1, r0, #Offset_CL450_DRAM
        STR     r1, CL450_DRAM
        ADD     r1, r0, #Offset_CL450_Registers
        DReg    r1, "CL450_Registers = "
        STR     r1, CL450_Registers
        ADD     r1, r0, #Offset_CL450_CMEM
        STR     r1, CL450_CMEM
        ADD     r1, r0, #Offset_AV110_Base
        STR     r1, AV110_Base
	ADD	r1, r0, #Offset_CL450_Clock_Disable
	STR	r1, CL450_Clock_Disable

; Now read existence of variable 'TVOn' to see whether to set CTRL0 and CTRL1 on or off

        Push    "r0,r1"
        ADR     r0, TVOnString
        MOV     r1, #0
        MOV     r2, #-1
        MOV     r3, #0
        MOV     r4, #0
        SWI     XOS_ReadVarVal
        Pull    "r0,r1"
        TEQ     r2, #0
	MOV	r1, #MPEGPoduleControl_CLKSelect :OR: MPEGPoduleControl_NotAV110Reset	; base value if var doesn't exit ie TV off
	ORRNE	r1, r1, #MPEGPoduleControl_CTRL1 :OR: MPEGPoduleControl_CTRL0		; var exists, TV on

	LDR	r2, CardType
	TEQ	r2, #CardType_STB2
	TEQNE	r2, #CardType_Roadster
	ORREQ	r1, r1, #MPEGPoduleControl_I2SSelect_VIDC20	; on STB2 or Roadster, select VIDC20 IIS sound by default

	Push	"r2"
	MOV	r2, #0					; AND mask is zero
	BL	UpdateControlRegister
	Pull	"r2"

	MOV	r1, #0					; turn on power to CL450 clock
	BL	ControlPowerDown			; reinitialise CL450 and claim IRQs
							; NB on Roadster this turns off the clock and then exits
	EXIT

TVOnString
        =       "TVOn", 0
        ALIGN

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

        BL      ReleaseIRQVector

        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

 [ TrapPreReset
Mod_Service ROUT
	TEQ	r1, #Service_PreReset
	MOVNES	pc, lr
	Push	"r0-r6, lr"
	LDR	wp, [r12]
	BL	ReleaseIRQVector	; stop our podule from interrupting
	Pull	"r0-r6, pc"

 |
Mod_Service * Module_BaseAddr   ; nothing to do yet!
 ]

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #MPEGVideoSWICheckValue - MPEGVideoSWI_Base
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
00
        B       OpenStream      ; open stream
        B       FullPackets     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
        B       CardControl     ; general control of MPEG card (used by audio module)
        B       SetSCR          ; send AccessSCR command
        B       ReadParameters  ; read various parameters
	B	ResetStream	; discard data and reset
        B       DisplayStill    ; display 2-field MPEG still picture
	B	Stats		; return statistics
	ASSERT  {PC}-%00 = (MPEGVideoSWICheckValue-MPEGVideoSWI_Base) :SHL: 2

NoSuchSWI
        ADRL    r0, NoSuchSWIError
        SETV
        MOV     pc, lr

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> video parameters structure
;
; out:  r0 = video stream handle
;

OpenStream Entry "r1,r2, r11"
 [ {FALSE}
	ORR	r0, r0, #StreamFlags_UseCallBacks
 ]
        STR     r0, StreamFlags
        LDR     r11, CL450_Registers
        STR     r1, ControlStreamHandle

	BL	ReleaseVSyncEvent		; in case they didn't close the stream last time

        MOV     r1, #0
        STR     r1, StreamClosing
        STR     r1, CompletionTime
        STR     r1, MaxCompletionTime
        STR     r1, NumberOfPTSs
        STR     r1, UnknownLengthPacket
	STR	r1, LastAmountSent
	STR	r1, NumberOfResets
	STR	r1, DisplayReady
 [ DontFlushOnEmpty
	STR	r1, StartedSending
	STR	r1, LastFlushDidntHappen
 ]
 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
	STR	r1, UnderrunCount
	STR	r1, UnderrunCondition
 ]
 [ SkipInitialNonMPEGStarts
	STR	r1, HadProperPacketStart
 ]
 [ ManuallySkipToSequence
	STR	r1, SkippingToSequence
 ]
 [ FullLengthStats
        STR     r1, LengthStatsPosition
 ]
 [ MultiplePicturePacketsChecks
        STR     r1, MultiPacketCount

        MOV     r1, #-1
        STR     r1, CheckedBadPacket
	STR	r1, LastCommandSent			; no command sent yet

        ADR     r1, MPDebugArray
        STR     r1, MPDebugArrayPtr
 ]

	ANDS	lr, r0, #StreamFlags_StartPaused	; if start paused
	MOVNE	lr, #1					; then set pending pause flag, else clear it
	STR	lr, PendingPause

	BL	ProcessVideoStructure

        MOV     r0, #0
        MOV     r1, #0
        ADR     lr, LastPTS
        STMIA   lr, {r0, r1}            ; zero LastPTS record

        ADR     lr, LastSCR
        STMIA   lr, {r0, r1}            ; zero LastSCR record

        BL      WriteSCR                ; set SCR to zero

 [ PreFillBuffer
        MOV     r0, #&80000001          ; indicate pre-buffering, but would otherwise be playing normal speed
        STR     r0, SpeedSetting
        MOV     r0, #0
        STR     r0, AmountSent
	STR	r0, AmountReceived
        BL      SendPause
 |
        DLine   "Sending PLAY command"

        BL      SendPlay                ; then start it off

        DLine   "Successfully sent PLAY command"
 ]

 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
  [ CheckCountUnderrunsBit :LAND: :LNOT: TrapUnderruns
	LDR	r0, VideoStructureFlags			; check if underrun counting is enabled at runtime
	TST	r0, #VideoStructureFlags_CountUnderruns
	BEQ	%FT90
  ]
	MOV	r0, #CL450IRQ_UND	; enable underrun interrupts
	MOV	r1, #0
	BL	EnableDisableIRQs
90
 ]

        MOV     r0, r12
        CLRV
        EXIT

; **************************************************************************
;
;       ProcessVideoStructure - Handle all fields in video structure
;
; in:   r2 -> video parameters structure
;	r11 -> CL450 registers
;
; out:  All registers preserved
;

ProcessVideoStructure Entry "r0,r1"
        LDR     r1, [r2, #VideoStructure_Flags]
        STR     r1, VideoStructureFlags

        LDR     lr, [r2, #VideoStructure_BorderLeft]
        STR     lr, BorderLeft

        LDR     lr, [r2, #VideoStructure_BorderTop]
	TST	r1, #VideoStructureFlags_UseBorderTop
	MOVEQ	lr, #0					; if not using border top, use zero for auto-centering
        STR     lr, BorderTop

        LDR     r1, [r2, #VideoStructure_ScreenMode]
        CMP     r1, #-1
        MOVNE   r0, #0
        SWINE   XOS_ScreenMode

	LDR	r1, VideoStructureFlags
	TST	r1, #VideoStructureFlags_DontSetBorder
	BNE	%FT60

	Push	"r1-r3"
	TST	r1, #VideoStructureFlags_OutputYUVNotRGB
	MOVEQ	r2, #0			; RGB => R = 0
	MOVEQ	r3, #0			;   and GB = 0
	MOVNE	r2, #&80		; YUV => Cr=&80
	MOVNE	r3, #&80		;  and  Cb=&80 and Y=0
        LDR     r0, BorderLeft
        LDR     r1, BorderTop
        BL      SetBorder		; try setting border *before* doing SetBlank
	Pull	"r1-r3"
60

        TST     r1, #VideoStructureFlags_SkipToSequenceHdr :OR: VideoStructureFlags_SkipToGOP :OR: VideoStructureFlags_SkipToPic
        MOVNE   r0, #1          ; blank screen
        BLNE    SetBlank

        MOV     r0, #0
        TST     r1, #VideoStructureFlags_SkipToSequenceHdr	; if skipping to sequence header
	TSTEQ   r1, #VideoStructureFlags_BlankOnResetStream	; or blanking on ResetStream
        ORRNE   r0, r0, #CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V     ; then enable SEQ-V IRQ and also PIC-V so it works
        TST     r1, #VideoStructureFlags_SkipToGOP              ; if skipping to GOP
        ORRNE   r0, r0, #CL450IRQ_GOP :OR: CL450IRQ_PIC_V       ; then enable GOP IRQ and also PIC-V so it works
        TST     r1, #VideoStructureFlags_SkipToPic
        ORRNE   r0, r0, #CL450IRQ_PIC_V
	Push	"r1"
        MOV     r1, #0
        BL      EnableDisableIRQs
	Pull	"r1"

 [ SkippingCode
        MOV     r0, #0
        TST     r1, #VideoStructureFlags_SkipToGOP
        MOVNE   r0, #MPEG_group_start_code
        TST     r1, #VideoStructureFlags_SkipToSequenceHdr      ; NB this overrides GOP skip
        MOVNE   r0, #MPEG_sequence_header_code
        STR     r0, StartSkipCode
 ]

        TST     r1, #VideoStructureFlags_NoInterlace
        Push    "r1, r2"
        MOVNE   r1, #MPEGPoduleControl_InterlaceDisable         ; either disable interlace
        MOVEQ   r1, #0                                          ; or enable it
        MVN     r2, #MPEGPoduleControl_InterlaceDisable         ; r2 = AND mask
        BL      UpdateControlRegister
        Pull    "r1, r2"

        TST     r1, #VideoStructureFlags_DontCLS
        BNE     %FT05

; *** NB Following code assumes 16bpp screen mode ***

        Push    "r1"
        MOV     r0, #&10                ; store &F000
        MOV     r1, #&F000
        SWI     XOS_SetColour
        SWI     XOS_WriteI + 16
        Pull    "r1"

05
        TST     r1, #VideoStructureFlags_DontChangePalette
        BNE     %FT50                   ; [don't change palette]

; first program External Register in VIDC20 to enable EClk

        LDR     r0, =&C0001007
        MOV     r1, #VIDC
        STR     r0, [r1]

; Now check if we're in 16bpp mode - if not don't program palette
; - do this check *after* programming External Register

	Push	"r2"
	MOV	r0, #-1			; read for current mode
	MOV	r1, #VduExt_Log2BPP	; log2 bits-per-pixel
	SWI	XOS_ReadModeVariable
	TEQ	r2, #4			; check for 2^4 = 16 bits-per-pixel
	Pull	"r2"
	BNE	%FT50

; *** NB Following code assumes 16bpp mode ***
; program entries 0 to 15
; - entries 0 to 7 output 0 on ext (solid colours)
; - entries 8 to 15 output 0 to 7 on ext (various transparent effects)

        Push    "r2, r3, r4, r9"
        MOV     r0, #15
10
        MOV     r1, #16
        SWI     XOS_ReadPalette
        BVS     %FT90

        BIC     r2, r2, #&FF
        TST     r0, #8
        ANDNE   r4, r0, #7
        ORRNE   r2, r2, r4, LSL #4
        MOV     r4, #2
        MOV     r9, #&23
        SWI     XOS_CallAVector
        BVS     %FT90
        SUBS    r0, r0, #1
        BPL     %BT10

; also program border colour to be transparent also

        MOV     r0, #0
        MOV     r1, #24
        MOV     r2, #&F0
        MOV     r4, #2
        MOV     r9, #&23
        SWI     XOS_CallAVector
        BVS     %FT90

        Pull    "r2, r3, r4, r9"
50

; Now enable RDY interrupt, so we know when it's ready for data

 [ UseRDY
        DLine   "About to enable RDY IRQ"

        MOV     r0, #CL450IRQ_RDY       ; enable this
        MOV     r1, #0                  ; don't disable any
        BL      EnableDisableIRQs

        DLine   "Successfully enabled RDY"
 ]

        LDR     r1, [r2, #VideoStructure_Flags]
	TST	r1, #VideoStructureFlags_OutputYUVNotRGB
	MOVEQ	r0, #1			; if clear, use RGB
	MOVNE	r0, #0			; else use YUV
	BL	SetColorMode

	TST	r1, #VideoStructureFlags_DontSetVideoFormat
	BNE	%FT55

        TST     r1, #VideoStructureFlags_NTSC
        MOVEQ   r0, #VF_PAL
        MOVNE   r0, #VF_NTSC
        BL      SetVideoFormat
55
	TST	r1, #VideoStructureFlags_DontSetWindow
        BLEQ    SetWindow
	CLRV
	EXIT

; error exit

90
        Pull    "r2, r3, r4, r9"
	STR	r0, [sp]
	EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of MPEG stream
;
; in:   r0 = flags
;       r1 = video stream handle
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0-r2, r11"
        CMP     r2, #8          ; don't allow speeds slower than 8
        EXIT    HI

	MOV	lr, #0
	STR	lr, PendingPause ; disable any pending pause on a speed change

SetSpeedAltEntry
        LDR     r11, CL450_Registers

	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0		; disable IRQs

        LDR     r0, SpeedSetting
        TST     r0, #&80000000  ; if pre-buffering
        ORRNE   r2, r2, #&80000000 ; then still pre-buffering, but may have speed setting after
        STR     r2, SpeedSetting

        CMP     r2, #1
        BLT     %FT10           ; pause (or pre-buffering)
        BEQ     %FT20           ; normal speed

        MOV     r0, r2
        BL      SlowMotion
        EXITS

10
        BL      SendPause
        EXITS

20
        ADR     lr, LastPTS
        LDMIA   lr, {r0, r1}
        BL      WriteSCR
        BL      SendPlay
        EXITS

SetSpeedDontCancelPause ALTENTRY
	B	SetSpeedAltEntry

; **************************************************************************
;
;       Play - Start going
;
; in:   r0 = flags
;       r1 = video stream handle
;
; out:  -
;

Play Entry "r0,r2, r11"
        LDR     r2, SpeedSetting
        BIC     r2, r2, #&80000000      ; clear pre-buffering bit
        STR     r2, SpeedSetting
        BL      SetSpeedDontCancelPause
        EXIT

; **************************************************************************
;
;       FullPackets - Here's some more data
;
; in:   r0 = flags
;       r1 = video stream handle
;       r2 -> one or more linked bitstream packets

FullPackets Entry "r0,r11"
        LDR     r11, [r2, #PacketDescriptor_Length]
        CMP     r11, #0
        BGE     %FT01                                   ; only complain about -ve length
        DREG    r11, "Packet length = "
01
        LDR     r11, CL450_Registers
        MOV     r0, pc
        Push    "r0"
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                                  ; disable IRQs round this bit

        LDR     r0, PacketListTailPtr
        TEQ     r0, #0                                  ; if nothing on list
        STREQ   r2, PacketListHeadPtr                   ; then point head at new packets
        STRNE   r2, [r0, #PacketDescriptor_Link]        ; else tail!link = packet
10
	LDR	r0, [r2, #PacketDescriptor_Length]
	LDR	lr, AmountReceived
	ADD	lr, lr, r0
	STR	lr, AmountReceived

        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_PTSValid     ; if packet has a valid PTS (ie is start of an MPEG packet)
        ORRNE   r0, r0, #PacketDescriptorFlags_Unchecked
        STRNE   r0, [r2, #PacketDescriptor_Flags]

        TST     r0, #PacketDescriptorFlags_MPEGStart    ; is it the start of a new packet?
        BEQ     %FT30                                   ; [no, so skip this]
        LDR     lr, UnknownLengthPacket                 ; if it is, check to see if we have an indeterminate length packet in progress
        TEQ     lr, #0
        BEQ     %FT20
        Push    "r0,r1"
 [ FullLengthStats
        ADRL    r0, LengthStatsPosition
        LDR     r1, [r0]
        ADD     r1, r1, #1
        CMP     r1, #LengthStatsArraySize
        STRLE   r1, [r0]
        ADDLE   r0, r0, r1, LSL #2
        LDRLE   r1, [lr, #PacketDescriptor_FullLength]
        STRLE   r1, [r0]
 ]

        LDR     r0, [lr, #PacketDescriptor_Flags]       ; there are no more sections in the indeterminate length packet, so clear the bit
        BIC     r0, r0, #PacketDescriptorFlags_FullLengthUnknown
        STR     r0, [lr, #PacketDescriptor_Flags]
        MOV     r0, #0
        STR     r0, UnknownLengthPacket                 ; and clear the pointer to it
        Pull    "r0,r1"
20
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown ; is the new packet of unknown length
        STRNE   r2, UnknownLengthPacket                 ; if so, then set up pointer to it
        MOVNE   r0, #0
        STRNE   r0, [r2, #PacketDescriptor_FullLength]  ; and zero its full length
30
        LDR     r0, UnknownLengthPacket                 ; if we are working out the length
        TEQ     r0, #0
        BEQ     %FT40
        Push    "r1"
        LDR     r1, [r0, #PacketDescriptor_FullLength]
        LDR     lr, [r2, #PacketDescriptor_Length]
        ADD     r1, r1, lr
        STR     r1, [r0, #PacketDescriptor_FullLength]  ; update total length
        Pull    "r1"
40
        LDR     r0, [r2, #PacketDescriptor_Link]        ; go down list of packets to end
        TEQ     r0, #0
        MOVNE   r2, r0
        BNE     %BT10

        STR     r2, PacketListTailPtr                   ; store new tail pointer
 [ UseRDY
        LDR     r1, StreamState                         ; load up stream state, *before* restoring IRQ state
 ]
        Pull    "r0"
        TEQP    r0, #0                                  ; restore IRQ state

 [ UseRDY
        TEQ     r1, #StreamState_WaitingForRDY          ; if we were waiting for RDY
        EXIT    EQ                                      ; then let IRQ send data

        BL      DoStuffWithData
 ]
        EXIT

; **************************************************************************
;
;       CloseStream - Close MPEG video stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGVideo_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:   r0 = flags
;       r1 = Video stream handle
;

CloseStream Entry "r0-r2,r11"
        LDR     r11, CL450_Registers

        LDR     r0, UnknownLengthPacket                 ; do we have an indeterminate-length packet pending?
        TEQ     r0, #0                                  ; if so then length is now complete
        LDRNE   lr, [r0, #PacketDescriptor_Flags]
        BICNE   lr, lr, #PacketDescriptorFlags_FullLengthUnknown
        STRNE   lr, [r0, #PacketDescriptor_Flags]
        MOVNE   lr, #0
        STRNE   lr, UnknownLengthPacket                 ; and no unknown packet now

        LDR     r0, SpeedSetting
        TEQ     r0, #0
        BEQ     %FT50                                   ; [it was paused, so junk data]

        BPL     %FT10                                   ; [not pre-buffering, so wait for data to empty]

; We got a close while we're still waiting for the buffer to get full enough
; This won't happen with the latest MPEGControl module, so we must be operating with an old one
; if speed=&80000000 then we aborted or were otherwise put in pause mode while pre-buffering, so junk data

        TEQ     r0, #&80000000
        BEQ     %FT50

; Issue Play directly to ourselves, not via SWI, since audio may not ever be ready

	BL	Play

; wait for data to empty

10
        MOV     r0, #1                                  ; indicate to multiple picture packet checker that we won't get
        STR     r0, StreamClosing                       ; any more data, so don't hang around

	BL	WaitForDataToDrain
20
	BL	ReleaseVSyncEvent
	CLRV
	EXIT


; we're paused, so mark stream as closing, and free all packets

50
        MOV     r0, #2
        STR     r0, StreamClosing
60
        LDR     r0, PacketListHeadPtr
        CMP     r0, #0                          ; V := 0
        BLNE    FreePacket
        BNE     %BT60
	B	%BT20

; **************************************************************************
;
;       WaitForDataToDrain - Wait until all data sent
;

WaitForDataToDrain Entry "r0"
 [ {TRUE}

; Go into user mode for entire duration of waiting to drain, so that any IRQ will immediately
; trigger off a callback, rather than it being more likely to interrupt while in SVC mode

        TEQP    pc, #0
        NOP                                             ; allow callbacks
10
	SWI	XOS_ReadEscapeState			; IRQ callbacks may be buggered, so ensure SWI callbacks go off!
        LDR     r0, PacketListHeadPtr                   ; do we have any outstanding packets?
        CMP     r0, #0                                  ; V := 0
        BNE     %BT10

        SWI     OS_EnterOS
 |
10
        TEQP    pc, #0
        NOP                                             ; allow callbacks
        SWI     OS_EnterOS

        LDR     r0, PacketListHeadPtr                   ; do we have any outstanding packets?
        CMP     r0, #0                                  ; V := 0
        BNE     %BT10
 ]
        EXIT

; **************************************************************************
;
;       CardControl - Various hardware and interrupt control functions
;

CardControl ROUT
        CMP     r0, #CardControlBadReason
        ADDCC   pc, pc, r0, LSL #2
        B       BadCardControlReason
10
        B       ClaimAudioIRQ
        B       ReleaseAudioIRQ
        B       UpdateControlRegister
	B	ControlPowerDown
	B	SendMacroCommandSWI
	B	SetColourModeSWI
        ASSERT  CardControlBadReason :SHL: 2 = {PC}-%BT10

; in:   r0 = reason code (0=Claim audio IRQ)
;       r1 -> audio interrupt routine
;       r2 = workspace pointer for audio IRQ
;
; out:  -

ClaimAudioIRQ Entry "r0"
        MOV     r0, r2                  ; move to r0, so it's in order for STM
        ADR     lr, AudioIRQWorkspace
        ASSERT  AudioIRQRoutine = AudioIRQWorkspace +4
        STMIA   lr, {r0,r1}
        CLRV
        EXIT

; in:   r0 = reason code (1=Release audio IRQ)
;
; out:  -

ReleaseAudioIRQ Entry "r0"
        ADR     r0, AudioIRQWorkspace
        ASSERT  AudioIRQRoutine = AudioIRQWorkspace +4
        ADRL    lr, MyAudioIRQRoutine
        STMIA   r0, {r12, lr}
        CLRV
        EXIT

; in:   r0 = reason code (2=Update Control register)
;       r1 = EOR mask
;       r2 = AND mask
;
; out:  r1 = old value of control register
;       r2 = new value of control register
;
; Performs CR = (CR AND r2) EOR r1

UpdateControlRegister Entry "r0,r3"
        MOV     r0, pc
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                          ; disable IRQs round atomic update

        LDR     lr, PoduleControlSoftCopy
        AND     r2, r2, lr
        EOR     r2, r2, r1
	MOV	r2, r2, LSL #(31-8)		; knock off all bits except bits 0..8
	MOV	r2, r2, LSR #(31-8)
        STR     r2, PoduleControlSoftCopy       ; update soft copy, r2 = new value
        MOV     r1, lr                          ; r1 = old value
        LDR     lr, Podule_ControlStatus
        STR     r2, [lr]                        ; update hardware (NB STR not STRB
					        ; for compatibility with STB2 H/W)
	LDR	r3, CardType
	TEQ	r3, #CardType_STB2		; if STB2
	TEQNE	r3, #CardType_Roadster		; or Roadster then
	MOVEQ	r3, r2, LSR #6			; put bit 6 of control register into bit 0
	ANDEQ	r3, r3, #1			; remove other bits and store in modulator/not boost register
	STREQB	r3, [lr, #Offset_Podule_ModulatorBoost - Offset_Podule_ControlStatus]

        TEQP    r0, #0
        EXIT

; in:	r0 = reason code (3=Control power down)
;	r1 bit 0 = 0 => Place MPEG card in normal running state
;		   1 => Place MPEG card in power down state (stop CL450 GCLK)
;	   bits 1..31 reserved, should be zero
; out:	-

ControlPowerDown Entry "r0,r1"
	LDR	lr, CardType
	TEQ	lr, #CardType_Roadster		; if Roadster
	MOVEQ	r1, #1				; then always power down clock
	TEQNE	lr, #CardType_STB2
	BNE	%FT05				; if not STB2 or Roadster, always initialise chip
	TST	r1, #1
	BNE	%FT10

; Re-enabling power

	LDR	lr, CL450_Clock_Disable
	MOV	r0, #0
	STRB	r0, [lr]			; reenable CL450 clock
05
	BL	InitCL450
	BLVC	ClaimIRQVector
	STRVS	r0, [sp]
	EXIT

; Turning off power

10
	BL	ReleaseIRQVector
	LDR	lr, CL450_Clock_Disable
	MOV	r0, #1				; stop CL450 clock
	STRB	r0, [lr]
	CLRV
	EXIT

; in:	r0 = reason code (4=Send macro command)
;	r1 to r5 contain the command code and parameters
;
; out:	Always waits for completion

SendMacroCommandSWI Entry "r0-r5"
	LDR	r11, CL450_Registers
	ADD	r1, sp, #4			; point at r1-r5
	MOV	r0, #0
	BL	SendMacroCommand
	CLRV
	EXIT

BadCardControlReason
        ADRL    r0, BadCardControlReasonError
        SETV
        MOV     pc, lr

; in:	r0 = reason code (5=Set colour mode)
;	r1 = 0 => RGB
;	     1 => YUV
;
; out:	-

SetColourModeSWI Entry "r0-r3"
	LDR	r11, CL450_Registers
	CMP	r1, #1
	BHI	%FT50				; bad value for output

	Push	"r1"
	MOVCC	r2, #0			; RGB => R = 0
	MOVCC	r3, #0			;   and GB = 0
	MOVCS	r2, #&80		; YUV => Cr=&80
	MOVCS	r3, #&80		;  and  Cb=&80 and Y=0
        LDR     r0, BorderLeft
        LDR     r1, BorderTop
        BL      SetBorder
	Pull	"r1"			; restore RGB/YUV flag
	EOR	r0, r1, #1		; r0 is opposite way round for CL450
	BL	SetColorMode
	CLRV
	EXIT

50
	ADRL	r0, BadColourModeError
	STR	r0, [sp]
	SETV
	EXIT

; **************************************************************************
;
;       SetSCR - SWI to set the SCR value
;
; in:   r0 = flags
;       r1 = bits 0..31 of SCR
;       r2 = bit 32 of SCR

SetSCR  Entry "r0-r2,r11"
        LDR     r0, SyncOffset
        ADDS    r1, r1, r0
        ADCS    r2, r2, r0, ASR #31
 [ SuppressNegativeSCRs
	BNE	%FT90
 ]
        LDR     r11, CL450_Registers
        MOV     r0, r1
        MOV     r1, r2

 [ SkipSCRs
        LDR     lr, LastSCR
        SUBS    lr, lr, r0              ; get difference from last SCR to this one
        RSBMI   lr, lr, #0              ; take absolute value
        CMP     lr, #SCRSkipRange       ; if inside range
        BCC	%FT90                   ; then exit
 ]

        ADR     lr, LastSCR
        STMIA   lr, {r0, r1}

        BL      WriteSCR
90
	CLRV
        EXIT

; **************************************************************************
;
;       ReadParameters - Read various stream parameters
;
; in:   r0 = reason code
;         0 => read time code and temporal reference
;              out: r1 = time code: bits 0..5   = time_code_pictures
;                                   bits 6..11  = time_code_seconds
;                                   bits 12..17 = time_code_minutes
;                                   bits 18..22 = time_code_hours
;                                   bit  23     = drop_frame_flag
;                   r2 = temporal_reference
;         1 => read direct access parameters for SetSCR
;              out: r1 = address of SetSCR routine
;                   r2 = workspace value for SetSCR routine
;         2 => read various locations
;               in: r1 = index of location to read:
;                         0 => CompletionTime
;                         1 => MaxCompletionTime
;              out: r2 = value
;	  3 => read current SCR value
;		out: r1 = bits 0..31 of SCR
;		     r2 = bit  32    of SCR
;	  4 => read buffer fullness
;		out: r1 = number of bytes in internal buffer
;	  5 => check display ready
;		out: r1 = 1 if 1st picture has been displayed yet, 0 if not
;

ReadParameters ROUT
        CMP     r0, #ReadParametersBadReason
        ADDCC   pc, pc, r0, LSL #2
        B       BadReadParametersReason
05
        B       ReadTimeCode
        B       ReadSetSCRParameters
        B       ReadDebugInfo
	B	ReadSCR
	B	ReadBufferFullness
	B	CheckDisplayReady
        ASSERT  ReadParametersBadReason = ({PC} - %BT05) :SHR: 2

BadReadParametersReason
        ADRL    r0, BadReadParametersReasonError
        SETV
        MOV     pc, lr

ReadTimeCode Entry "r0,r3, r11"
        LDR     r11, CL450_DRAM
        MOV     r0, pc
        ORR     lr, r0, #I_bit          ; disable IRQs round this bit
        TEQP    lr, #0
10
        LDR     r1, [r11, #PIC_SEM]
        MOVS    r1, r1, LSL #16         ; only look at bottom 16 bits
        BNE     %BT10
        MOV     r1, #1                  ; any value other than 0 or &4242
        STR     r1, [r11, #PIC_SEM]

; delay for at least 0.5µs

        MOV     r1, #IOC
        STRB    r1, [r1, #Timer0LR]
        LDRB    r2, [r1, #Timer0CL]
20
        STRB    r1, [r1, #Timer0LR]
        LDRB    r3, [r1, #Timer0CL]
        TEQ     r3, r2
        BEQ     %BT20

        LDR     r1, [r11, #PIC_SEM]             ; now read semaphore
        MOV     r1, r1, LSL #16
        TEQ     r1, #1 :SHL: 16                 ; if not our value
        BNE     %BT10                           ; then try again

        LDR     r3, =&FFFF
        LDR     r1, [r11, #TIME_CODE_0]
        LDR     r2, [r11, #TIME_CODE_1]
        AND     r1, r1, r3
        AND     r2, r2, r3
        ORR     r1, r2, r1, LSL #12
        LDR     r2, [r11, #TEMPORAL_REFERENCE]
        AND     r2, r2, r3

        MOV     r3, #0
        STR     r3, [r11, #PIC_SEM]             ; clear picture group semaphore

        TEQP    r0, #0                          ; restore IRQ status

        CLRV
        EXIT

        LTORG

ReadSetSCRParameters ROUT
        ADR     r1, SetSCR
        MOV     r2, wp
        CLRV
        MOV     pc, lr

ReadBufferFullness Entry "r2,r11"
	LDR	r11, CL450_Registers
	BL	GetBufferFullness		; returns it in r2
	MOV	r1, r2
	CLRV
	EXIT

CheckDisplayReady Entry
	LDR	r1, DisplayReady
	CMP	r1, #DisplayReadyLatency
	MOVCC	r1, #0				; if not got there yet, return 0
	MOVCS	r1, #1				; else return 1
	CLRV
	EXIT

ReadDebugInfo ROUT
        ADR     r2, DebugVarTable
        LDR     r2, [r2, r1, LSL #2]            ; get offset of variable
        LDR     r2, [wp, r2]
        CLRV
        MOV     pc, lr

DebugVarTable
        &       :INDEX: CompletionTime
        &       :INDEX: MaxCompletionTime
        &       :INDEX: LastPTS +0              ; low word of last PTS sent to CL450
        &       :INDEX: NumberOfPTSs
        &       :INDEX: LastSCR +0              ; low word of last SCR received
 [ MultiplePicturePacketsChecks
        &       :INDEX: MultiPacketCount
        &       :INDEX: MPDebugArrayPtr
        &       :INDEX: CheckedBadPacket
 ]

; **************************************************************************
;
;	ResetStream - Discard all data and reset CL450
;
; in:	r0 = flags
;	  bit 0 set => video data in new stream
;	  bit 1 set => audio data in new stream
;	r1 = video stream handle
;
; out:	r2 = estimate of number of bytes discarded

ResetStream Entry "r0-r3"
	LDR	r11, CL450_Registers

	MOV	r2, #2				; pretend we're closing, so we don't send any more data to it in background
	STR	r2, StreamClosing

	LDR	lr, NumberOfResets
	ADD	lr, lr, #1
	STR	lr, NumberOfResets		; count number of resetstreams

	ANDS	lr, r0, #StreamFlags_StartPaused	; if start paused
	MOVNE	lr, #1					; then set pending pause flag, else clear it
	STR	lr, PendingPause

	BL	GetBufferFullness		; returns fullness in r2
	LDR	r0, PacketListHeadPtr
10
	TEQ	r0, #0					; any more packets?
	LDRNE	lr, [r0, #PacketDescriptor_Length]	; if so then add up length
	ADDNE	r2, r2, lr
	BLNE	FreePacket				; and free the packet
	BNE	%BT10					; then loop

	LDR	lr, TrailingByte
	TEQ	lr, #0
	ADDNE	r2, r2, #1			; add 1 if we had a trailing byte to send

	STR	r2, [sp, #2*4]			; update returned r2 value with byte count

	MOV	r0, #0
	STR	r0, TrailingByte
	STR	r0, UnknownLengthPacket
 [ SkippingCode
	STR	r0, StartSkipCode
 ]
 [ SkipInitialNonMPEGStarts
	STR	r0, HadProperPacketStart
 ]
 [ ManuallySkipToSequence
	MOV	r0, #1				; we need to skip until we get sequence header
	STR	r0, SkippingToSequence
 ]

        MOV     r0, #0
        MOV     r1, #0
        ADR     lr, LastPTS
        STMIA   lr, {r0, r1}            ; zero LastPTS record

        ADR     lr, LastSCR
        STMIA   lr, {r0, r1}            ; zero LastSCR record

        BL      WriteSCR                ; set SCR to zero

 [ PreFillBuffer
	LDR	r3, AmountSent			; keep a record of last amount sent before ResetStream
	STR	r3, LastAmountSent
	STR	r0, AmountSent
	MOV	r0, #&80000001
	STR	r0, SpeedSetting
 ]

	LDR	r3, VideoStructureFlags
	TST	r3, #VideoStructureFlags_BlankOnResetStream
	MOVNE	r0, #1				; blank screen during transition
	BLNE	SetBlank

 [ BugFix_2007
	BL	SendPlay			; ensure not in pause mode
20
	BL	GetBufferFullness		; get fullness
	LDR	r0, =CL450FullThreshold		; if very nearly full
	CMP	r2, r0
	BCC	%FT25
	SWI	XOS_ReadMonotonicTime
	ADD	r2, r0, #10
22
	SWI	XOS_ReadMonotonicTime
	CMP	r0, r2
	BMI	%BT22
	B	%BT20
25
 ]

	MOV	r0, #19
	SWI	XOS_Byte			; wait for vsync, as FlushBitstream can cause screen disruption otherwise

 [ RegisterLastFullness
	BL	GetBufferFullness		; get fullness again, closer to time of flush
	STR	r2, LastFullness
 ]
 [ DontFlushOnEmpty
	LDR	r0, StartedSending		; if we haven't even sent a NewPacket command after the last flush
	TEQ	r0, #0
	MOVEQ	r0, #1				; indicate last reset didn't flush
	BEQ	%FT30				; and don't send another flush
 ]

	MOV	r2, #2_110			; restore default sequence parameters, and
	BL	FlushBitstream			; resume only on sequence header

 [ DontFlushOnEmpty
	MOV	r0, #0
	STR	r0, StartedSending
30
	STR	r0, LastFlushDidntHappen	; store 0 or 1 for flush/not flush
 ]

 [ PauseAfterResetStream
	BL	SendPause			; send pause command
 ]
	MOV	r0, #0
	STR	r0, StreamClosing		; can send data again now

	CLRV
	EXIT

; **************************************************************************
;
;	GetBufferFullness - Read buffer fullness from CL450
;
; in:	-
;
; out:	r2 = fullness (in bytes)
;

GetBufferFullness Entry "r0, r1"
	MOV	r0, #0				; wait for completion
	ADR	r1, InquireBufferFullnessCommand
	BL	SendMacroCommand

	MOV	r0, pc
	ORR	lr, r0, #I_bit
	TEQP	lr, #0				; disable IRQs round access to HOST_raddr

	LDR	r1, [r11, #HOST_raddr]		; read old value of HOST_raddr
	AND	r1, r1, #&0F			; only bits 0..3 are valid
	MOV	r2, #&0B			; buffer fullness index
	STR	r2, [r11, #HOST_raddr]
	LDR	r2, [r11, #HOST_rdata]		; read data
	STR	r1, [r11, #HOST_raddr]		; restore old HOST_raddr

	TEQP	r0, #0
	MOV	r2, r2, LSL #16
	MOV	r2, r2, LSR #16			; only bits 0..15 valid
	EXIT

; **************************************************************************
;
;	FlushBitstream - Send FlushBitstream command
;
; in:	r2 = flags to pass to command
;
; out:	-
;

FlushBitstream Entry "r0, r1"
	MOV	r0, #0				; wait for completion
	ADR	r1, FlushBitstreamCommand
	STR	r2, [r1, #1*4]			; store command parameter
	BL	SendMacroCommand
	EXIT

; **************************************************************************
;
;       DisplayStill - Display MPEG still picture
;
; in:   r0 = flags
;		bit 0 set => continuation from a previous picture
;	r1 -> video parameters structure
;	r2 -> buffer containing data
;	r3 = size of buffer (in bytes)
;

DisplayStill Entry "r0-r7,r11"
        LDR     r11, CL450_Registers

	MOV	r4, r2				; move buffer pointer to r4
	MOV	r5, r3				; move buffer length to r5

	MOV	r2, r1
	TST	r0, #1
	BNE	%FT05
	BL	ProcessVideoStructure		; select screen mode etc
	BVS	%FT99
05
        MOV     r0, #-1				; don't send any play commands automatically
        STR     r0, AmountSent

	MOV	r0, #0
	STR	r0, StreamClosing
	STR	r0, UnknownLengthPacket
	STR	r0, PacketListHeadPtr
	STR	r0, PacketListTailPtr
	STR	r0, TrailingByte
	MOV	r6, #0				; head ptr
	MOV	r7, #0				; tail ptr

; now allocate packets

10
	Push	"r3"
	MOV	r0, #ModHandReason_Claim
	MOV	r3, #PacketDescriptorSize
	SWI	XOS_Module
	Pull	"r3"
	BVS	%FT95				; if failed to allocate packet descriptor then tidy up

	MOV	r0, #0
	STR	r0, [r2, #PacketDescriptor_Link]
	ADR	r0, FreeStillPacket
	STR	r0, [r2, #PacketDescriptor_FreeRoutine]
	STR	wp, [r2, #PacketDescriptor_FreeWorkspace]
	STR	r4, [r2, #PacketDescriptor_Start]
	CMP	r5, #&FF00
	MOVHI	r0, #&FF00
	MOVLS	r0, r5
	SUB	r5, r5, r0			; remaining length
	ADD	r4, r4, r0
	STR	r0, [r2, #PacketDescriptor_Length]
	STR	r0, [r2, #PacketDescriptor_FullLength]
	MOV	r0, #PacketDescriptorFlags_MPEGStart
	STR	r0, [r2, #PacketDescriptor_Flags]

	TEQ	r6, #0				; if first node
	MOVEQ	r6, r2				; then store in head
	STRNE	r2, [r7, #PacketDescriptor_Link] ; else tail->link = node
	MOV	r7, r2				; tail = node
	TEQ	r5, #0
	BNE	%BT10

	LDR	r0, [sp]			; get old r0
	TST	r0, #1
	BLNE	SendStillData			; if subsequent, send 0th copy of data

	BL	SendPlay			; start playing

	TST	r0, #2
	BLEQ	SendStillData			; send 1st copy of data

        MOV     r0, #0          		; wait for completion
        ADR     r1, DisplayStillCommand
        BL      SendMacroCommand		; send DisplayStill() command

	BL	SendStillData			; send 2nd copy of data
	BL	SendStillData			; send 3rd copy of data

	CLRV					; indicate success
95
	BL	FreeStillPacketDescriptors
99
	STRVS	r0, [sp]
	EXIT

DisplayStillCommand
        &       MacroCommand_DisplayStill
        &       0, 0, 0, 0

; **************************************************************************
;
;	FreeStillPacketDescriptors - Free packet descriptors at end of still
;
; in:	r6 -> list of packets
;
; out:	All registers preserved, including flags

FreeStillPacketDescriptors Entry "r0,r2,r6"
10
	TEQ	r6, #0
	EXITS	EQ					; exit preserving flags

	MOV	r0, #ModHandReason_Free
	MOV	r2, r6
	LDR	r6, [r6, #PacketDescriptor_Link]	; extract link before freeing (!)
	SWI	XOS_Module				; ignore errors
	B	%BT10

; **************************************************************************
;
;	SendStillData - Send one copy of still data
;
; in:	r6 -> list of packets
;
; out:	Flags preserved
;

SendStillData Entry "r0"
	MOV	r0, #0
	STR	r0, StillPacketListTailPtr
	MOV	r2, r6
	BL	FullPackets

	BL	WaitForDataToDrain
	EXITS

; **************************************************************************
;
;	FreeStillPacket - Free routine for DisplayStill packets
;
; in:	r0 -> packet descriptor

FreeStillPacket Entry "r1"
	MOV	lr, pc
	ORR	r1, lr, #I_bit
	TEQP	r1, #0					; disable IRQs round this

	LDR	r1, StillPacketListTailPtr		; if not last
	TEQ	r1, #0
	STRNE	r0, [r1, #PacketDescriptor_Link]	; then tail->link = node
	STR	r0, StillPacketListTailPtr		; tail = node

	TEQP	lr, #0
	CLRV
	EXIT

; **************************************************************************
;
;	FindPoduleNumber
;
; in:   -
;
; out:  r3 = podule number, if VC, otherwise corrupted
;	Also sets up CardType variable
;       All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
 [ CheckPoduleVariable
	Push	"r3,r4"
	ADR	r0, PoduleVariableName
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	Pull	"r3,r4"
	BVS	%FT05

	MOV	r0, #0
	STRB	r0, [r1, r2]			; terminate string

	Push	"r1"
	SWI	XPodule_ReturnNumber
	Pull	"r1"
	BVS	%FT90

	SUB	r2, r0, #1			; maximum podule number
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	BVS	%FT05

	MOV	r3, r2				; copy value into r3
	MOV	r0, #CardType_STB1
	STR	r0, CardType
	EXIT

PoduleVariableName
	=	"MPEG$PoduleNumber", 0
	ALIGN

05
 ]
        SWI     XPodule_ReturnNumber
        BVS     %FT90
        SUB     r3, r0, #1              ; r6 = max podule number
        ADR     r2, PoduleHeaderBuffer
10
        SWI     XPodule_ReadHeader
        BVS     %FT20
        LDRB    r0, [r2, #3]
        LDRB    r1, [r2, #4]

; This code changed by TMD 17-Feb-95
; No longer allow &0000 in any version
; 'M' version allows &00F9 (as before)
; Other versions allow &00FF or &00F9

        ORR     r0, r0, r1, LSL #8
	MOV	r1, #0
 [ NewProductType
        CMP     r0, #ProdType_MPEGDecoder
 |
	CMP	r0, #ProdType_MPEGDecoder ; allow new
        CMPNE   r0, #&FF                ; or old types
 ]
	MOVEQ	r1, #CardType_STB1	; RISC PC or STB1 type
	LDR	lr, =ProdType_STB2_MPEG1 ; is it STB2 type
	TEQ	r0, lr
	MOVEQ	r1, #CardType_STB2	; indicate as such
	LDR	lr, =ProdType_STB2_MPEG0 ; is it Roadster (ie no MPEG hardware)
	TEQ	r0, lr
	MOVEQ	r1, #CardType_Roadster	; indicate as such
	TEQ	r1, #0			; if neither
        BEQ     %FT20			; then not this podule
	STR	r1, CardType		; save card type

; It's this podule

 [ FastPoduleAccess
        MOV     r0, #3                  ; set access type 'C'
 |
        MOV     r0, #1                  ; set access type 'A'
 ]
        SWI     XPodule_SetSpeed
        BVS     %FT90
        EXIT

20
        SUBS    r3, r3, #1
        BPL     %BT10
        ADRL    r0, NoPoduleError
        SETV
90
        STR     r0, [sp]
        EXIT

; **************************************************************************
;
;       InitCL450 - Initialise CL450
;
;

InitCL450 Entry "r0-r2,r11"
 [ UseRDY
        MOV     r0, #StreamState_WaitingForRDY
        STR     r0, StreamState
 ]

        MOV     r1, #0
        MVN     r2, #MPEGPoduleControl_NotCL450Reset            ; clear bit ie reset CL450
        BL      UpdateControlRegister

        MOV     r1, #MPEGPoduleControl_NotCL450Reset
        MVN     r2, #MPEGPoduleControl_NotCL450Reset            ; deassert reset
        BL      UpdateControlRegister

        LDR     r11, CL450_Registers
        MOV     r0, #CMEM_control_Rst
        STR     r0, [r11, #CMEM_control]        ; reset CL450

        MOV     r0, #0
        STR     r0, [r11, #CMEM_control]        ; release reset
        STR     r0, [r11, #CPU_control]         ; disable CL450 CPU

        LDR     r1, =RefCntValue                ; refresh counter
        STR     r1, [r11, #DRAM_refcnt]

        LDR     r1, =HOST_control_Int :OR: HOST_control_Fixed1
        STR     r1, [r11, #HOST_control]        ; not interrupting, non-vectored IRQ

        STR     r0, [r11, #CMEM_dmactrl]        ; don't assert CFLEVEL

        MOV     r1, #15
        STR     r1, [r11, #HOST_raddr]          ; select HMEM[15]

        MOV     r2, #1                          ; set HMEM[15] to 1 so we can see when
        STR     r2, [r11, #HOST_rdata]          ; CL450 has set it back to zero

        MOV     r1, #15
        STR     r1, [r11, #HOST_raddr]

        LDR     r2, [r11, #HOST_rdata]
        AND     r2, r2, #15
        TEQ     r2, #1
        BNE     %FT95

        DLine   "Sending micro-code"

        BL      SendMicroCode

        DLine   "Came back from sending micro-code"

        MOV     r1, #15
        STR     r1, [r11, #HOST_raddr]

        LDR     r2, [r11, #HOST_rdata]
        AND     r2, r2, #15
        TEQ     r2, #1
        BNE     %FT95

        DLine   "Starting CL450 CPU"
        MOV     r2, #1
        STR     r2, [r11, #CPU_control]

        DLine   "Waiting for CL450 to complete initialisation"
10
        STR     r1, [r11, #HOST_raddr]
        LDR     r2, [r11, #HOST_rdata]
        MOVS    r2, r2, LSL #16
        BEQ     %FT20
        SWI     XOS_ReadEscapeState
        BCS     %FT90
        DLine   ".",cc
        B       %BT10

20
        DLine   ""
        DLine   "CL450 micro-code initialised"

; Must clear VIE (and AIC) bits *after* initialisation of micro-code
; since version 2.00 of micro-code sets VIE to 1

        LDR     r2, =HOST_control_Int :OR: HOST_control_Fixed1
        STR     r2, [r11, #HOST_control]        ; not interrupting, non-vectored IRQ

        MOV     r0, #0                  ; no IRQs to start off
        BL      SetInterruptMask

        CLRV
        EXIT

90
        MOV     r0, #&7E
        SWI     XOS_Byte
        ADRL    r0, EscapeError
        B       %FT97

95
        DReg    r2, "HMEM[15] = "
        ADRL    r0, HMEM15not1Error
97
        STR     r0, [sp]
        SETV
        EXIT

        LTORG

Delay   Entry "r0,r1"
        MOV     r1, r0
        SWI     XOS_ReadMonotonicTime
        ADD     r1, r1, r0
10
        SWI     XOS_ReadMonotonicTime
        CMP     r0, r1
        BMI     %BT10
        EXIT

SendMicroCode Entry
	BL	InitDRAM
; First check microcode block header

        ADRL    r0, MicroCode
        LDRB    r1, [r0], #1
        TEQ     r1, #&C3                ; test for magic number
        BNE     %FT99
        LDRB    r1, [r0], #1
        TEQ     r1, #&C3                ; test for magic number
        BNE     %FT99
        LDRB    r1, [r0], #1            ; rev_hi
        DReg    r1, "rev_hi = "
        LDRB    r1, [r0], #1            ; rev_lo
        DReg    r1, "rev_lo = "
        uilsbf16        r1, r2
        DReg    r1, "productID = "
        uilsbf16        r1, r2
        DReg    r1, "init_PC = "
        STR     r1, MCode_init_PC
        uilsbf16        r1, r2
        DReg    r1, "imem_dram = "
        STR     r1, MCode_imem_dram
        uilsbf32        r1, r2
        DReg    r1, "exe_length = "
        uilsbf16        r1, r2
        DReg    r1, "num_segments = "
        STR     r1, MCode_num_segments
        uilsbf32        r1, r2
        DReg    r1, "reserved = "
        ADD     r0, r0, #80             ; skip comment string

; now get segments

10
        LDR     r1, MCode_num_segments
        SUBS    r1, r1, #1
        BCC     %FT20
        STR     r1, MCode_num_segments
        BL      CodeSegment
        B       %BT10
20
        ADRL    r1, MicroCodeEnd
        TEQ     r0, r1
        ADRNEL  r0, WrongLengthError
        BNE     ErrorExit

        LDR     r1, MCode_init_PC
        STR     r1, [r11, #CPU_pc]

        CLRV
        EXIT

99
        ADRL    r0, BadMCodeError
ErrorExit
        SETV
        EXIT

CodeSegment Entry "r3-r5"
        uilsbf32        r3, r1          ; r3 = seg_length
        DReg    r3, "seg_length = "
        uilsbf32        r4, r1          ; r4 = seg_address
        DReg    r4, "seg_address = "
        LDR     r5, CL450_DRAM
        ADD     r5, r5, r4, LSL #1
        Push    "r0, r3"                ; save ptr to segment + size for later
10
        LDRB    r1, [r0], #1
        LDRB    r2, [r0], #1
        ORR     r1, r2, r1, LSL #8
        STR     r1, [r5], #4
        SUBS    r3, r3, #2
        BNE     %BT10
        Pull    "r2, r3"
        LDR     r5, MCode_imem_dram
        SUBS    r4, r4, r5              ; seg_address-imem_dram
        BCC     %FT90                   ; not IMEM
        CMP     r4, #UCODE_CACHE_END*4
        BCS     %FT90
        TST     r4, #3
        BNE     %FT99
        DLine   "IMEM segment"
        MOV     r0, r2                  ; move ptr back to start of segment
        MOV     r4, r4, LSR #1
        STR     r4, [r11, #CPU_iaddr]
20
        LDRB    r1, [r0], #1
        LDRB    r2, [r0], #1
        ORR     r1, r2, r1, LSL #8
        STR     r1, [r11, #CPU_imem]
        SUBS    r3, r3, #2
        BNE     %BT20

90
        CLRV
        EXIT

99
        ADRL    r0, MisalignedIMEMError
        SETV
        EXIT

 [ ZeroAllDRAM
InitDRAM Entry
	LDR	r0, CL450_DRAM		; zero 1MB of space
	MOV	r1, #1024*1024
	MOV	r2, #0
	BL	fillblock
	EXIT

fillblock Entry "r0-r3"
        MOV     r3, r2
        TST     r1, #4
        BEQ     %FT10
        STR     r2, [r0], #4
        SUBS    r1, r1, #4
        EXIT    EQ
10
        STMIA   r0!, {r2, r3}
        SUBS    r1, r1, #8
        BNE     %BT10
        EXIT
 |
InitDRAM Entry
	LDR	r0, CL450_DRAM
	LDR	r1, =&804*2		; this location seems to need zeroing for the decoder to work properly
	MOV	r2, #0
	STR	r2, [r0, r1]
	EXIT
 ]

; **************************************************************************
;
;       SendMacroCommand - Send a macro command to CL450
;
; in:   r0 = flags
;         bit 0 set => don't wait for completion
;	  bit 1 set => get completion time info
;	  bit 2 set => dump results back into block
;       r1 -> 5 words of command parameters
;       r11 -> CL450_Registers

SendMacroCommand Entry "r2, r3"

; Disable IRQs round this section, so that
; a) An IRQ can't start another command after we think the last one
;    has finished, and
; b) We don't re-enter under IRQ and stomp on the foreground's command
;    parameters

 [ {FALSE}
        LDR     r3, [r1, #0]
        DREG    r3,"Command ",cc
        LDR     r3, [r1, #4]
        DREG    r3," ",cc
        LDR     r3, [r1, #8]
        DREG    r3," ",cc
        LDR     r3, [r1, #12]
        DREG    r3," ",cc
        LDR     r3, [r1, #16]
        DREG    r3," "
 ]
        MOV     r3, pc
        ORR     lr, r3, #I_bit          ; disable IRQs round this
        TEQP    lr, #0

        TST     r0, #2                  ; if require timing information
        MOVNE   lr, #&FF                ; set timer 1 latch to FFFF
        MOVNE   r2, #IOC
        STRNEB  lr, [r2, #Timer1LL]
        STRNEB  lr, [r2, #Timer1LH]
        STRNEB  lr, [r2, #Timer1GO]
10
        LDR     lr, [r11, #HOST_newcmd]
        TST     lr, #1                  ; wait for previous command to finish
        BNE     %BT10

        MOV     lr, #0
        STR     lr, [r11, #HOST_raddr]
20
        LDR     r2, [r1, lr, LSL #2]
        STR     r2, [r11, #HOST_rdata]
        ADD     lr, lr, #1
        TEQ     lr, #5
        BNE     %BT20

        MOV     lr, #1
        STR     lr, [r11, #HOST_newcmd]

	TST	r0, #4			; if need results
	BNE	%FT50			; then skip this

        TEQP    r3, #0                  ; restore IRQ state

        TST     r0, #1                  ; if not waiting
        BNE     %FT40                   ; then exit
30
        LDR     lr, [r11, #HOST_newcmd]
        TST     lr, #1                  ; wait for completion
        BNE     %BT30

; at this point we know that our command has been accepted, though there
; may be one in the pipeline from an IRQ process

40
        TST     r0, #2
        BEQ     %FT15

        MOV     r2, #IOC
        STRB    lr, [r2, #Timer1LR]
        LDRB    lr, [r2, #Timer1CL]
        EOR     lr, lr, #&FF
        LDRB    r2, [r2, #Timer1CH]
        EOR     r2, r2, #&FF
        ORR     lr, lr, r2, LSL #8
        STR     lr, CompletionTime
        LDR     r2, MaxCompletionTime
        CMP     lr, r2
        STRHI   lr, MaxCompletionTime
15

        EXIT

; we need to dump the results back in the block

50
        LDR     lr, [r11, #HOST_newcmd]
        TST     lr, #1                  ; wait for completion
        BNE     %BT50

	MOV	lr, #1
60
	STR	lr, [r11, #HOST_raddr]	; set PTR each time
	LDR	r2, [r11, #HOST_rdata]	; read results
	MOV	r2, r2, LSL #16
	MOV	r2, r2, LSR #16
	STR	r2, [r1, lr, LSL #2]
	ADD	lr, lr, #1
	TEQ	lr, #5
	BNE	%BT60

	TEQP	r3, #0			; restore IRQ state

	EXIT

; **************************************************************************
;
;       SendPlay - Issue Play command
;
; in:   r11 -> CL450_Registers
; out:	Flags preserved

SendPlay Entry   "r0, r1"
        MOV     r0, #0          ; wait for completion
        ADR     r1, PlayCommand
        BL      SendMacroCommand
        MOV     r0, #1
        STR     r0, SpeedSetting
	STR	r0, LastCommandSent	; indicate last command sent was play
        EXITS

PlayCommand
        &       MacroCommand_Play
        &       0, 0, 0, 0

; **************************************************************************
;
;       SendPause - Issue Pause command
;
; in:   r11 -> CL450_Registers

SendPause Entry   "r0, r1"
        MOV     r0, #0          ; wait for completion
	STR	r0, LastCommandSent	; indicate last command sent was pause
        ADR     r1, PauseCommand
        BL      SendMacroCommand
        EXIT

PauseCommand
        &       MacroCommand_Pause
        &       0, 0, 0, 0

; **************************************************************************
;
;       SetColorMode - Issue SetColorMode command with default
;
; in:	r0 = 0 for YUV, 1 for RGB
;	r11 -> CL450_Registers

SetColorMode Entry "r0, r1"
	STR	r0, SetColorModeCommand +4	; store command parameter
        MOV     r0, #0  ; wait for completion
        ADR     r1, SetColorModeCommand
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       SetVideoFormat - Issue SetVideoFormat command with default
;
; in:   r0 = VF_PAL or VF_NTSC
;       r11 -> CL450_Registers

SetVideoFormat Entry "r0, r1"
        STR     r0, SetVideoFormatCommand +4    ; store command parameter
        MOV     r0, #0  ; wait for completion
        ADR     r1, SetVideoFormatCommand
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       SetWindow - Issue SetWindow command with default
;
; in:   r11 -> CL450_Registers

SetWindow Entry "r0, r1"
        MOV     r0, #0  ; wait for completion
        ADR     r1, DefaultWindowCommand
        BL      SendMacroCommand
        EXIT

DefaultWindowCommand
        &       MacroCommand_SetWindow
        &       0               ; horizontal offset of output window
        &       0               ; vertical offset of output window
        &       0               ; auto width
        &       0               ; auto height

; **************************************************************************
;
;       SetThreshold - Issue SetThreshold command with default
;
; in:   r11 -> CL450_Registers

SetThreshold Entry "r0, r1"
        MOV     r0, #0  ; wait for completion
        ADR     r1, DefaultThresholdCommand
        BL      SendMacroCommand
        EXIT

DefaultThresholdCommand
        &       MacroCommand_SetThreshold
        &       VideoFIFOThreshold
        &       0, 0, 0

; **************************************************************************
;
;       SetInterruptMask - Issue SetInterruptMask command with default
;
; in:   r11 -> CL450_Registers

SetInterruptMask Entry "r0, r1"
        ADR     r1, InterruptMaskCommand
        STR     r0, [r1, #4]            ; store mask in command
                                        ; (also readable later)
SetInterruptMaskEntry
        MOV     r0, #0                  ; wait for completion
        BL      SendMacroCommand
        EXIT

SetInterruptMaskFromStore ALTENTRY
        ADR     r1, InterruptMaskCommand
        B       SetInterruptMaskEntry

; **************************************************************************
;
;       SlowMotion - Issue SlowMotion command with parameter
;
; in:   r0 = speed (2-8)
;       r11 -> CL450_Registers

SlowMotion Entry "r0, r1"
        ADR     r1, SlowMotionCommand
        STR     r0, [r1, #4]            ; store mask in command
	STR	r0, LastCommandSent	; save last command sent
        MOV     r0, #0                  ; wait for completion
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       SetBlank - Issue SetBlank command with parameter
;
; in:   r0 = 1 to blank, 0 to unblank
;       r11 -> CL450_Registers

SetBlank Entry "r0, r1"
        ADR     r1, SetBlankCommand
        STR     r0, [r1, #4]            ; store mask in command
        MOV     r0, #0                  ; wait for completion
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       SetBorder - Issue SetBorder command with default
;
; in:   r11 -> CL450_Registers
;       r0 = left coordinate
;       r1 = top coordinate
;	r2 = rBorder
;	r3 = gbBorder

SetBorder Entry "r0-r2"
        ADR     lr, SetBorderCommand
 [ AutoCenteringHoriz
        MOV     r0, #0
 ]
	STMIB	lr, {r0-r3}		; store left, top, rBorder, gbBorder at offset 4,8,12,16
        MOV     r0, #0                  ; wait for completion
        MOV     r1, lr
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       WriteSCR - Issue AccessSCR command to set SCR
;
; in:   r11 -> CL450_Registers
;       r0 = bits [0..31] of SCR
;       r1 = bit 32 of SCR (in bit 0)

WriteSCR Entry "r0,r1"
        MOV     lr, r0, LSR #30         ; lr = bits [30..31] in bits [0..1]
        EOR     r0, r0, lr, LSL #30     ; knock out those bits in r0
        ORR     r1, lr, r1, LSL #2      ; r1 = bits [30..32] in bits [0..2]
        ADR     lr, AccessSCRCommand
        STR     r1, [lr, #1*4]          ; bits 30..32 and R/W = 0(W) (bit15)
        MOV     r1, r0, LSR #15         ; bits 15..29 in bits 0..14
        EOR     r0, r0, r1, LSL #15     ; knock out those bits too
        STR     r1, [lr, #2*4]          ; bits 15..29
        STR     r0, [lr, #3*4]          ; bits 0..14

        MOV     r0, #2                  ; wait for completion, get timing info
        MOV     r1, lr
        BL      SendMacroCommand
        EXIT

; **************************************************************************
;
;       ReadSCR - Issue AccessSCR command to read SCR
;
; in:   -
; out:	r1 = bits [0..31] of SCR
;       r2 = bit 32 of SCR (in bit 0)
;	r11 corrupt

ReadSCR Entry	"r0"
	LDR	r11, CL450_Registers
	ADR	r1, AccessSCRCommand
	MOV	lr, #1 :SHL: 15
	STR	lr, [r1, #1*4]
	MOV	lr, #0
	STR	lr, [r1, #2*4]
	STR	lr, [r1, #3*4]

        MOV     r0, #4			; wait for completion, get results
        BL      SendMacroCommand

	LDR	lr, [r1, #1*4]		; get bits 32..30, in bits 2..0
	LDR	r2, [r1, #2*4]		; get bits 29..15, in bits 14..0
	MOV	r2, r2, LSL #(31-14)
	LDR	r1, [r1, #3*4]		; get bits 14..0, in bits 14..0
	MOV	r1, r1, LSL #(31-14)	; remove other bits
	MOV	r1, r1, LSR #(31-14)
	ORR	r1, r1, r2, LSR #(31-29) ; r1 = bits 29..0
	ORRS	r1, r1, lr, LSL #30	; r1 = bits 31..0, carry = bit 32
	MOVCC	r2, #0
	MOVCS	r2, #1
	CLRV
	EXIT

; **************************************************************************
;
;       NewPacket - Issue NewPacket command
;
; in:   r11 -> CL450_Registers
;       r0 = bits [0..31] of PTS
;       r1 = bit 32 of PTS (in bit 0)
;       r2 = PTS valid flag (0 => not valid, 1 => valid)
;       r3 = packet length

NewPacket Entry "r0,r1"
 [ SuppressNegativePTSs
        TEQ     r1, #0                  ; if bit 32 of PTS set
        MOVNE   r2, #0                  ; then mark as invalid
 ]
        TEQ     r2, #0                  ; if PTS not valid
        BEQ     %FT20                   ; skip this bit

 [ SkipPTSs
        LDR     lr, LastPTS
        SUBS    lr, lr, r0              ; get difference from last PTS to this one
        RSBMI   lr, lr, #0              ; take absolute value
        CMP     lr, #PTSSkipRange       ; if inside range
        MOVCC   r2, #0                  ; then mark as invalid
        BCC     %FT20
 ]
        ADR     lr, LastPTS             ; save away
        STMIA   lr, {r0, r1}

        LDR     lr, NumberOfPTSs        ; increment count of PTSs we've sent
        ADD     lr, lr, #1
        STR     lr, NumberOfPTSs
20
        MOV     lr, r0, LSR #30         ; lr = bits [30..31] in bits [0..1]
        EOR     r0, r0, lr, LSL #30     ; knock out those bits in r0
        ORR     r1, lr, r1, LSL #2      ; r1 = bits [30..32] in bits [0..2]
        ORR     r1, r1, r2, LSL #15     ; move validity flag to bit 15
        ADR     lr, NewPacketCommand
        STR     r3, [lr, #1*4]          ; store packet length
        STR     r1, [lr, #2*4]          ; bits 30..32 and R/W = 0(W) (bit15)
        MOV     r1, r0, LSR #15         ; bits 15..29 in bits 0..14
        EOR     r0, r0, r1, LSL #15     ; knock out those bits too
        STR     r1, [lr, #3*4]          ; bits 15..29
        STR     r0, [lr, #4*4]          ; bits 0..14

        MOV     r0, #0                  ; wait for completion
        MOV     r1, lr
        BL      SendMacroCommand

 [ DontFlushOnEmpty
	ASSERT	SkipInitialNonMPEGStarts	; ensure we don't send any data before 1st NewPacket command
	MOV	r0, #1
	STR	r0, StartedSending	; we've send a NewPacket command, so any ResetStream must do a real FlushBitstream
 ]

        EXIT

; **************************************************************************
;
;       EnableDisableIRQs - Enable and/or disable IRQs
;
; in:   r11 -> CL450_Registers
;       r0 = mask of IRQs to enable
;       r1 = mask of IRQs to disable

EnableDisableIRQs Entry "r0-r3"

        MOV     r3, pc
        ORR     lr, r3, #I_bit                  ; disable IRQs round this bit
        TEQP    lr, #0

        ADR     lr, InterruptMaskCommand
        LDR     r2, [lr, #4]
        BIC     r2, r2, r1
        ORR     r0, r0, r2
        STR     r0, [lr, #4]

        TEQP    r3, #0                          ; restore IRQ status
        BL      SetInterruptMaskFromStore

        EXIT

ClaimIRQVector Entry "r0-r4"
        LDR     r0, IRQVectorClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    NE                              ; non-zero => already claimed

        MOV     r0, #IOMD_Podule_DevNo
        ADR     r1, MPEGIRQHandler
        MOV     r2, wp
        LDR     r3, Podule_ControlStatus
        MOV     r4, #MPEGPoduleStatus_IRQStatus
        SWI     XOS_ClaimDeviceVector
        EXIT    VS

        MOV     r1, #MPEGPoduleControl_IRQEnable
        MVN     r2, #MPEGPoduleControl_IRQEnable
        BL      UpdateControlRegister           ; turn on IRQs

 [ AudioIRQBodge
        MOV     r0, #TickerV
        ADR     r1, AudioIRQ
        MOV     r2, wp
        SWI     XOS_Claim

        MOV     r0, #IrqV
        ADR     r1, DummyIrqV
        MOV     r2, wp
        SWI     XOS_Claim
 ]

 [ :LNOT: UseRDY
        MOV     r0, #TickerV
        ADR     r1, VideoTickerV
        MOV     r2, wp
        SWI     XOS_Claim
 ]

        MOV     r0, #IOC
        MOV     r1, pc
        TEQP    pc, #SVC_mode + I_bit           ; disable IRQs while modifying mask B
        LDRB    r2, [r0, #IOCIRQMSKB]
        ORR     r2, r2, #podule_IRQ_bit
        STRB    r2, [r0, #IOCIRQMSKB]
        TEQP    r1, #0

        MOV     r0, #1
        STR     r0, IRQVectorClaimed
        CLRV
        EXIT

ReleaseIRQVector Entry "r0-r4, r11"
        LDR     r0, IRQVectorClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    EQ                              ; non-zero => already claimed

        MOV     r0, #0
        STR     r0, IRQVectorClaimed

 [ :LNOT: UseRDY
        MOV     r0, #TickerV
        ADR     r1, VideoTickerV
        MOV     r2, wp
        SWI     XOS_Release

        ADR     r0, VideoTickerVCallBack
        MOV     r1, wp
        SWI     XOS_RemoveCallBack
 ]

 [ AudioIRQBodge
        MOV     r0, #IrqV
        ADR     r1, DummyIrqV
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r0, #TickerV
        ADR     r1, AudioIRQ
        MOV     r2, wp
        SWI     XOS_Release
 ]

        LDR     r11, CL450_Registers
        MOV     r0, #0                          ; disable all IRQs
        BL      SetInterruptMask

        MOV     r1, #0
        MVN     r2, #MPEGPoduleControl_IRQEnable :OR: MPEGPoduleControl_NotCL450Reset
        BL      UpdateControlRegister           ; turn off IRQs and reset CL450

        MOV     r0, #IOMD_Podule_DevNo
        ADR     r1, MPEGIRQHandler
        MOV     r2, wp
        LDR     r3, Podule_ControlStatus
        MOV     r4, #MPEGPoduleStatus_IRQStatus
        SWI     XOS_ReleaseDeviceVector
        EXIT

; **************************************************************************
;
;       MPEGIRQHandler - Handler for IRQs off MPEG card
;
; in:   -
; out:  r0-r3 may be corrupted

MPEGIRQHandler Entry "r11"
        LDR     r3, Podule_ControlStatus
        LDRB    r3, [r3]

        TST     r3, #MPEGPoduleStatus_CL450NoIRQ
        BLEQ    VideoIRQ

 [ :LNOT: AudioIRQBodge
	LDR	lr, AudioIRQRoutine
	CMN	lr, #1					; if =-1, ignore audio status bit
	BEQ	%FT10
        TST     r3, #MPEGPoduleStatus_AV110NoIRQ
        BLEQ    AudioIRQ                ; NB This corrupts r12
10
 ]

 [ {FALSE}
KillIRQExit
        TEQP    pc, #SVC_mode + I_bit
        MOV     r0, r0
        Push    "lr"
        BL      ReleaseIRQVector
        Pull    "lr"
        TEQP    pc, #IRQ_mode + I_bit
        MOV     r0, r0
 ]
        EXIT

 [ {FALSE}
WeirdIRQ
        MOV     lr, #VIDC
        LDR     r0, =&40FFFFFF
        STR     r0, [lr]
        B       KillIRQExit
 ]

        LTORG

AudioIRQ ROUT
        Push    "r0,r1,r3,r14"          ; save r0,r1,r3 + create space for stacked Interrupt Request register
        LDR     r3, AV110_Base
        LDRB    r0, [r3, #AV110_INTR_0]
        LDRB    r1, [r3, #AV110_INTR_1]
        ORRS    r0, r0, r1, LSL #8
 [ AudioIRQBodge
        Pull    "r0,r1,r3,pc", EQ       ; if real IRQs not working and not requesting then no need to call audio module
                                        ; (if real IRQs *are* working then we need to call audio module to clear it)
 ]
        STR     r0, [sp, #3*4]
        Pull    "r0,r1,r3"
        ADR     r12, AudioIRQWorkspace
        LDMIA   r12, {r12, pc}

 [ AudioIRQBodge

; this routine is required to prevent the kernel seeing the transient pulses from the AV110 and then disabling all
; podule IRQs because it couldn't find a cause of the IRQ

DummyIrqV ROUT
        Push    "r0,r1,r3,r14"          ; save r0,r1,r3 + create space for stacked Interrupt Request register
        LDR     r3, AV110_Base
        LDRB    r0, [r3, #AV110_INTR_0]
        LDRB    r1, [r3, #AV110_INTR_1]
        ORRS    r0, r0, r1, LSL #8
        Pull    "r0,r1,r3,pc", EQ
        LDR     lr, [sp, #4*4]          ; lr for claiming vector
        STR     r0, [sp, #4*4]
        Pull    "r0,r1,r3"
        ADD     sp, sp, #4
        ADR     r12, AudioIRQWorkspace
        LDMIA   r12, {r12, pc}
 ]

MyAudioIRQRoutine ROUT
 [ AudioIRQBodge
        Pull    "r12"
        MOV     pc, lr
 |
        ADD     sp, sp, #4                      ; junk stacked audio IRQ interrupt status (bug fix 20-Oct-94)
        Push    "r0, lr"
        LDR     lr, AV110_Base
        MOV     r0, #0
        STRB    r0, [lr, #AV110_INTR_EN_0]      ; disable all audio IRQs, for now
        STRB    r0, [lr, #AV110_INTR_EN_1]
        LDR     lr, Podule_Base
        STRB    lr, [lr, #Offset_EPROM]         ; write to EPROM clears latched IRQ
        Pull    "r0, pc"
 ]

; Video IRQ entry - r3 must be preserved

VideoIRQ Entry "r3"

; for now, just keep counts of how many IRQs we've had of each type

        LDR     r11, CL450_Registers
        LDR     r0, [r11, #HOST_control]
        BIC     r0, r0, #&3F00                  ; preserve bits 15, 14, 0; set other bits to zero
        BIC     r0, r0, #&007E
        ORR     r0, r0, #&80                    ; clear IRQ bit
        STR     r0, [r11, #HOST_control]

        LDR     r0, [r11, #HOST_raddr]          ; preserve HOST_raddr for foreground operations
        MOV     r1, #&0A                        ; access interrupt status
        STR     r1, [r11, #HOST_raddr]
        LDR     r2, [r11, #HOST_rdata]          ; r2 = IRQ status
 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
  [ CheckCountUnderrunsBit :LAND: :LNOT: TrapUnderruns
	LDR	lr, VideoStructureFlags
	TST	lr, #VideoStructureFlags_CountUnderruns
	BICEQ	r2, r2, #CL450IRQ_UND		; if not counting underruns then pretend bit wasn't set
  ]
	TST	r2, #CL450IRQ_UND		; have we underrun - only set status to zero if not
        STREQ   r1, [r11, #HOST_raddr]          ; rewrite index to IRQ status location
        MOVEQ   r1, #0
        STREQ   r1, [r11, #HOST_rdata]          ; IRQ status := 0
	LDRNE	r1, UnderrunCount		; if underrun then increment count of underruns
	ADDNE	r1, r1, #1
	STRNE	r1, UnderrunCount
	MOVNE	r1, #1				; and indicate we are in an underrun condition
	STRNE	r1, UnderrunCondition		; so that the arrival of new data can clear interrupt status
 |
        STR     r1, [r11, #HOST_raddr]          ; rewrite index to IRQ status location
        MOV     r1, #0
        STR     r1, [r11, #HOST_rdata]          ; IRQ status := 0
 ]
        AND     r0, r0, #&0F
        STR     r0, [r11, #HOST_raddr]          ; restore index for foreground task

 [ {TRUE}
        ADR     lr, IRQCounts
        MOV     r0, #1
10
        TST     r2, r0
        LDRNE   r1, [lr]
        ADDNE   r1, r1, #1
        STRNE   r1, [lr], #4
        ADDEQ   lr, lr, #4
        MOV     r0, r0, LSL #1
        TEQ     r0, #&10000
        BNE     %BT10
 ]

 [ UseRDY
        TST     r2, #CL450IRQ_RDY
        BLNE    ProcessIRQ_RDY
 ]

        TST     r2, #CL450IRQ_GOP :OR: CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V
        BLNE    PerformUnblanking

        EXIT

        LTORG

 [ TrapUnderruns :LOR: CheckCountUnderrunsBit

; We've had some more data since the underrun, so it should be safe to clear InterruptStatus
; which will allow interrupts to happen again.

; in: r11 -> CL450_Registers

ClearInterruptStatus Entry "r0,r1"
	MOV	lr, pc
	ORR	lr, lr, #I_bit			; disable IRQs while we do this
	TEQP	lr, #0

        LDR     r0, [r11, #HOST_raddr]          ; preserve HOST_raddr for foreground operations
        MOV     r1, #&0A                        ; access interrupt status
        STR     r1, [r11, #HOST_raddr]
	MOV	r1, #0				; zero it
	STR	r1, [r11, #HOST_rdata]

        AND     r0, r0, #&0F
        STR     r0, [r11, #HOST_raddr]          ; restore index for foreground task
	EXITS					; exit, restoring IRQ state
 ]

PerformUnblanking Entry
        LDR     lr, VideoStructureFlags
        TST     lr, #VideoStructureFlags_SkipToSequenceHdr	; if not skipping to sequence header
	TSTEQ   lr, #VideoStructureFlags_BlankOnResetStream	; and not blanking on ResetStream
        BICEQ   r2, r2, #CL450IRQ_SEQ_V				; then ignore SEQ_V interrupts
        TST     lr, #VideoStructureFlags_SkipToGOP
        BICEQ   r2, r2, #CL450IRQ_GOP
        TST     lr, #VideoStructureFlags_SkipToPic
        BICEQ   r2, r2, #CL450IRQ_PIC_V
        TST     r2, #CL450IRQ_SEQ_V :OR: CL450IRQ_GOP :OR: CL450IRQ_PIC_V
        EXIT    EQ

        BIC     r2, r2, #CL450IRQ_GOP :OR: CL450IRQ_SEQ_V :OR: CL450IRQ_PIC_V

        LDR     lr, SetBlankCommand +4
        TEQ     lr, #0                          ; are we blank?
	EXIT	EQ				; [no, so exit]

	MOV	r0, #1
	STR	r0, DisplayReady		; start display ready count up
	BL	ClaimVSyncEvent

        MOV     r0, #0                          ; if so, then unblank
        BL      SetBlank

	LDR	lr, PendingPause
	TEQ	lr, #0
	EXIT	EQ				; nothing more to do unless we're starting paused

	MOV	r2, #0				; enter pause mode (this automatically cancels the pending pause)
	BL	SetSpeed

        EXIT

ClaimVSyncEvent Entry "r0-r3"
	LDR	lr, EventVectorClaimed
	TEQ	lr, #0
	EXITS	NE

; we're entered in IRQ mode, so must save lr_svc

	MOV	r3, pc
	ORR	r0, r3, #SVC_mode
	TEQP	r0, #0
	NOP

	Push	"lr"
	MOV	r0, #EventV
	ADR	r1, MyEventRoutine
	MOV	r2, wp
	SWI	XOS_Claim

	MOVVC	r0, #14
	MOVVC	r1, #4				; vsync event
	SWIVC	XOS_Byte

	MOVVC	lr, #1
	STRVC	lr, EventVectorClaimed
	Pull	"lr"

	TEQP	r3, #0
	NOP

	EXITS

ReleaseVSyncEvent Entry "r0-r2"
	LDR	lr, EventVectorClaimed
	TEQ	lr, #0
	EXITS	EQ

	MOV	r0, #13
	MOV	r1, #4
	SWI	XOS_Byte
	MOV	r0, #EventV
	ADR	r1, MyEventRoutine
	MOV	r2, wp
	SWI	XOS_Release

	MOV	lr, #0
	STR	lr, EventVectorClaimed
	EXITS

MyEventRoutine Entry
	TEQ	r0, #4				; is it vsync event?
	EXIT	NE				; [no, so exit]
	LDR	lr, DisplayReady		; read displayready count
	TEQ	lr, #0				; if zero we haven't started yet
	EXIT	EQ				; so exit
	ADD	lr, lr, #1			; else increment count
	CMP	lr, #DisplayReadyLatency	; but stop if we get to limit
	STRLS	lr, DisplayReady
	EXIT

 [ UseRDY
; **************************************************************************
;
;       ProcessIRQ_RDY - Handle RDY interrupt
;
; in:   r2 = mask of CL450 interrupt causes
;       r3 = mask of podule interrupt causes
;       r11 -> CL450_Registers
;       IRQ mode, IRQs disabled
;
; out:  r2 := r2 AND NOT CL450IRQ_RDY
;       r3 preserved
;       r0,r1 corrupted

ProcessIRQ_RDY Entry "r2,r3"
        BIC     r2, r2, #CL450IRQ_RDY   ; knock out mask
        LDR     r0, StreamState
        TEQ     r0, #StreamState_WaitingForRDY ; if not waiting for RDY
        EXIT    NE

        MOV     r0, pc
        ORR     lr, r0, #SVC_mode       ; go into SVC mode
        TEQP    lr, #0
        NOP
        Push    "r14"
        BL      DoStuffWithData
        Pull    "r14"
        TEQP    r0, #0
        NOP
        EXIT                            ; then ignore
 ]

 [ :LNOT: UseRDY
VideoTickerV Entry "r0-r2"
        LDR     r0, CallBackRequested           ; is a callback already requested
        TEQ     r0, #0
        EXIT    NE                              ; if so, don't ask for another
        MOV     r2, pc
        ORR     r1, r2, #SVC_mode               ; go into SVC mode to save lr_svc so we can SWI
        TEQP    r1, #0
        NOP
        Push    "r14"
        LDR     r0, StreamFlags
        TST     r0, #StreamFlags_UseCallBacks
        BEQ     %FT20                           ; [stuff directly]

        ADR     r0, VideoTickerVCallBack
        MOV     r1, wp
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVC   r0, CallBackRequested           ; indicate that we've requested a callback
10
        Pull    "r14"
        TEQP    r2, #0
        NOP
        EXIT

20
        MOV     r0, #1
        STR     r0, CallBackRequested
        BL      VideoTickerVCallBack
        B       %BT10

        LTORG

VideoTickerVCallBack Entry "r0,r1, r11"
 [ EnableIRQsInTickerV
        MOV     lr, pc
        BIC     lr, lr, #I_bit          ; enable IRQs
        TEQP    lr, #0
 ]
        LDR     r11, CL450_Registers
        BL      DoStuffWithData
        MOV     r0, #0
        STR     r0, CallBackRequested
        EXIT

        LTORG
 ]

DoStuffWithData Entry "r0-r2"
	LDR	lr, DisplayReady	; if we've got to the stage that the
	CMP	lr, #DisplayReadyLatency ; display is valid
	BLEQ	ReleaseVSyncEvent	; then don't need the event vector any more

        LDR     r0, StreamClosing       ; if stream closing (ie value = 2)
        CMP     r0, #1                  ; don't send any more data
        EXIT    HI
05
        LDR     r0, PacketListHeadPtr
        TEQ     r0, #0                  ; do we have any data?
        BNE     %FT10                   ; [yes, so start sending it]

; no data, but CL450 ready, so set state to waiting for data

 [ UseRDY
  [ {FALSE}                             ; try leaving RDY enabled all the time
        MOV     r0, #0
        MOV     r1, #CL450IRQ_RDY
        BL      EnableDisableIRQs
  ]

        MOV     r0, #StreamState_WaitingForData
        STR     r0, StreamState
 ]
        EXIT

; send data

10
 [ SkippingCode
        LDR     r1, StartSkipCode
        TEQ     r1, #0
        BNE     PerformSkipping
 ]

 [ SkipInitialNonMPEGStarts
	LDR	r1, HadProperPacketStart		; have we already had a proper MPEG packet start?
	TEQ	r1, #0
        LDREQ   r1, [r0, #PacketDescriptor_Flags]	; if not, then is this packet a true MPEG packet start?
        TSTEQ   r1, #PacketDescriptorFlags_MPEGStart    ; if not, then we must skip this packet, otherwise we'd
	BEQ	%FT20					; start sending data before the first NewPacket command
	MOV	r1, #1					; we're OK from now on
	STR	r1, HadProperPacketStart		; (at least until the next ResetStream)
 ]

        BL      SendNewPacketIfNecessary
        EXIT    NE                                      ; don't know if PTS on packet is safe yet, due to incomplete packet
        BL      SendData
 [ UseRDY
20
        BL      FreePacket                              ; in: r0 -> packet, out: r0 -> next packet
        LDR     r1, OutstandingDataSize                 ; can we send any more data
        TEQ     r1, #0                                  ; without waiting for RDY
        BNE     %BT05                                   ; if so then try again

; might need to re-cancel any pending RDY IRQ here, just in case one is already
; buffered up from before we sent the NewPacket() command

        MOV     r0, #StreamState_WaitingForRDY
        STR     r0, StreamState

 |
20
        BLEQ    FreePacket
        BEQ     %BT05
 ]
StuffExit
        EXIT

 [ SkippingCode
PerformSkipping Entry "r3-r7"
05
        LDR     r4, [r0, #PacketDescriptor_Start]
        LDR     r3, [r0, #PacketDescriptor_Length]
        MOV     r6, #0                                  ; offset in this packet
10
        CMP     r6, r3
        BCS     %FT90                                   ; [no start code in buffer]
        LDRB    lr, [r4, r6]
        CMP     lr, #0
        ADDNE   r6, r6, #1
        BNE     %BT10

        MOV     r5, r0                                  ; r5 -> current packet
        MOV     r2, r6                                  ; save offset in packet holding zero

        BL      GetNextVideoByte
        CMP     r7, #0                                  ; check for 2nd zero
        BNE     %FT80


80
        ... to be continued

90
        BL      FreePacket                              ; free this packet, it's no use
        TEQ     r0, #0                                  ; if any more
        BNE     %BT05                                   ; then loop
        B       StuffExit
 ]

; Send NewPacket command to CL450 if necessary
; Exits EQ if OK to try to send data, NE if can't check packet yet (incomplete)

SendNewPacketIfNecessary Entry "r0"
        LDR     r1, [r0, #PacketDescriptor_Flags]
        TST     r1, #PacketDescriptorFlags_MPEGStart    ; is it start of an MPEG packet?
        EXIT    EQ                                      ; [no, then no NewPacket() required, exit EQ => OK to send data]

        TST     r1, #PacketDescriptorFlags_FullLengthUnknown ; do we have a packet of indeterminate length?
        EXIT    NE                                      ; [yes, so we must wait for its length to be determined]

 [ ManuallySkipToSequence
	LDR	lr, SkippingToSequence			; are we skipping?
	TEQ	lr, #0
	BLNE	PerformSkipToSequence
	EXIT	NE
 ]

 [ MultiplePicturePacketsChecks
        TST     r1, #PacketDescriptorFlags_Unchecked
        BLNE    CheckForMultiplePictures                ; if this returns NE, then incomplete packet
        EXIT    NE
 ]

 [ :LNOT: UseRDY
        BIC     r1, r1, #PacketDescriptorFlags_MPEGStart ; cancel this flag so we don't resend NewPacket
        STR     r1, [r0, #PacketDescriptor_Flags]       ; if we use part of packet
 ]
 [ SendPTS
        LDR     r2, StreamFlags
        TST     r2, #StreamFlags_NoVideoPTSs
        BICNE   r1, r1, #PacketDescriptorFlags_PTSValid
 |
        BIC     r1, r1, #PacketDescriptorFlags_PTSValid
 ]

 [ ShowPTS
        TST     r1, #PacketDescriptorFlags_PTSValid
        BEQ     %FT10
        LDR     r2, TrailingByte
        TEQ     r2, #0
        SWIEQ   XOS_WriteI+"P"
        SWINE   XOS_WriteI+"p"
10
 ]
        LDR     r3, [r0, #PacketDescriptor_FullLength]  ; use length of complete packet
        LDR     r2, TrailingByte                        ; see if trailing byte
        TEQ     r2, #&80000000                          ; do we have a trailing byte of zero?
                                                        ; (ie potentially 1st byte of picture_start code)
        BICEQ   r1, r1, #PacketDescriptorFlags_PTSValid ; yes, then junk PTS
        TEQ     r2, #0
        AND     r2, r3, #1                              ; r2 = 0 if even length, 1 if odd length
 [ FixOddLengthPackets
        RSBEQ   r2, r2, #0                              ; shorten initial odd packet, lengthen if trailing byte
 |
        RSBNE   r2, r2, #0                              ; if trailing byte and odd length then r2 = -1
 ]
        ADD     r3, r3, r2                              ; adjust length

 [ UseRDY
        LDR     r2, OutstandingDataSize
        ADD     r2, r2, r3
        STR     r2, OutstandingDataSize
 ]
        TST     r1, #PacketDescriptorFlags_PTSValid     ; if PTS valid
        MOVNE   r2, #1                                  ; indicate it's valid
        LDRNE   r1, [r0, #PacketDescriptor_PTS +4]      ; then load up PTS hi
        LDRNE   r0, [r0, #PacketDescriptor_PTS +0]      ; and PTS lo (overwriting r0)
        MOVEQ   r2, #0                                  ; else indicate invalid
        MOVEQ   r1, #0                                  ; and use zero for safety
        MOVEQ   r0, #0
        BL      NewPacket
        TEQ     r0, r0                                  ; set EQ (OK to try to send data)
        EXIT

 [ MultiplePicturePacketsChecks
; **************************************************************************
;
;       CheckForMultiplePictures - Check packet for multiple picture_start codes
;
; in:   r0 -> packet descriptor for first packet within MPEG packet
;       r1 = flags for packet
;
; out:  EQ => packet is OK to send
;       NE => packet is incomplete so hasn't been checked - don't send it yet
;       r1 = updated flags
;       All other registers preserved

CheckForMultiplePictures Entry "r0,r2-r8"
        LDR     r2, [r0, #PacketDescriptor_FullLength]
        MOV     r3, r0
10
        LDR     r4, [r3, #PacketDescriptor_Length]
        SUBS    r2, r2, r4
        BLE     %FT20
        LDR     r3, [r3, #PacketDescriptor_Link]
        CMP     r3, #1          ; if link <> 0
        BCS     %BT10           ; then loop

; incomplete packet, so exit NE to indicate this

        LDR     r3, StreamClosing
        TEQ     r3, #1          ; are we going to get any more data?
        EXIT    NE              ; we might, so exit NE indicating incomplete

        B       CFMPBadPacket   ; else we'd best mark it as dodgy, just in case

; packet is complete, so let's check it (r0 -> first part packet, r3 -> last)

20
        LDR     r2, [r0, #PacketDescriptor_PTS]
        LDR     lr, =BadPacketPTS
        TEQ     r2, lr
        MOVNE   r8, #0
        MOVEQ   r8, #1

        LDR     r2, [r0, #PacketDescriptor_Start]
        LDR     r4, [r0, #PacketDescriptor_Length]
        MOV     r7, #0                  ; number of picture_start codes in packet

30
        MOV     r6, #0                  ; state
32
        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00
        BNE     %BT32
34
        MOV     r6, #1
        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00 00
        BNE     %BT30
        MOV     r6, #2

        BL      CFMPgetbyte
        TEQ     r5, #1          ; check for 00 00 01
        SUBNE   r2, r2, #1      ; if not then could be (00) 00 00
        ADDNE   r4, r4, #1      ; adjust length back as well
        BNE     %BT34
        MOV     r6, #3

        BL      CFMPgetbyte
        TEQ     r5, #0          ; check for 00 00 01 00 (picture start code)
        BNE     %BT30

        ADD     r7, r7, #1      ; one more picture start code
        CMP     r7, #1
        BHI     CFMPBadPacket   ; if more than 1 then definitely bad
        B       %BT30           ; else loop

BadPacketPTS    *       &D4B20
        LTORG

CFMPgetbyte
        SUBS    r4, r4, #1
        LDRGEB  r5, [r2], #1
        MOVGE   pc, lr
        TEQ     r0, r3
        LDRNE   r0, [r0, #PacketDescriptor_Link]
        LDRNE   r2, [r0, #PacketDescriptor_Start]
        LDRNE   r4, [r0, #PacketDescriptor_Length]
        BNE     CFMPgetbyte

; we've run out of data to check

        TEQ     r8, #1
        STREQ   r7, CheckedBadPacket

 [ {FALSE}      ; try rule where only two whole picture_start codes make a bad packet
        TEQ     r7, #0          ; if no picture_start codes
        TEQNE   r6, #0          ; or 1 picture_start code and no partial ones
 ]
        B       CFMPGoodPacket  ; then OK
CFMPBadPacket
        BIC     r1, r1, #PacketDescriptorFlags_PTSValid ; else clear PTS valid bit
        LDR     lr, MultiPacketCount
        ADD     lr, lr, #1
        STR     lr, MultiPacketCount
        CMP     lr, #MPDebugArraySize   ; if run out of debug array
        BCS     CFMPGoodPacket          ; then skip this bit
        ADR     r0, MPDebugArray-4
        ADD     lr, r0, lr, LSL #2      ; point at where to store PTS
        LDR     r0, [sp]                ; reload ptr to first partial packet
        LDR     r0, [r0, #PacketDescriptor_PTS] ; load bottom 32 bits of PTS for this packet
        STR     r0, [lr]
CFMPGoodPacket
        BIC     r1, r1, #PacketDescriptorFlags_Unchecked
        LDR     r0, [sp]                ; reload ptr to first partial packet
        STR     r1, [r0, #PacketDescriptor_Flags]       ; save flags
        TEQ     r0, r0                  ; indicate packet has been checked
        EXIT
 ]

 [ ManuallySkipToSequence
; **************************************************************************
;
;	PerformSkipToSequence - Skip data until we get a sequence header
;
; in:   r0 -> packet descriptor for first packet within MPEG packet
;       r1 = flags for packet
;
; out:  EQ => packet is OK to send
;       NE => packet is incomplete so hasn't been checked - don't send it yet
;       r1 = updated flags
;       All other registers preserved

PerformSkipToSequence Entry "r0,r2-r8"
05
        LDR     r2, [r0, #PacketDescriptor_FullLength]
        MOV     r3, r0
10
        LDR     r4, [r3, #PacketDescriptor_Length]
        SUBS    r2, r2, r4
        BLE     %FT20
        LDR     r3, [r3, #PacketDescriptor_Link]
        CMP     r3, #1          ; if link <> 0
        BCS     %BT10           ; then loop

; incomplete packet, so exit NE to indicate this

        LDR     r3, StreamClosing
        TEQ     r3, #1          ; if we're not going to get any more
	TEQNE	r3, #2		; then return EQ indicating OK to send data
	EXIT			; else return NE indicating wait until more data arrives

; packet is complete, so let's check it (r0 -> first part packet, r3 -> last)

20
	LDR	r8, [r0, #PacketDescriptor_FullLength]	; reload full length of packet

        LDR     r2, [r0, #PacketDescriptor_Start]
        LDR     r4, [r0, #PacketDescriptor_Length]
30
	CMP	r4, #4
	BCC	%FT45		; if fewer than 4 bytes left, give up looking for seq hdr

        BL      PSTSgetbyte
        TEQ     r5, #0          ; check for 00
        BNE     %BT30

        BL      PSTSgetbyte
        TEQ     r5, #0          ; check for 00 00
        BNE     %BT30

        BL      PSTSgetbyte
        TEQ     r5, #1          ; check for 00 00 01; if not then could be (00) 00 00
	ADDNE	r8, r8, #2
	ADDNE	r4, r4, #2	; put back two bytes
	SUBNE	r2, r2, #2
	BNE	%BT30

        BL      PSTSgetbyte
        TEQ     r5, #&B3        ; check for 00 00 01 B3 (sequence header code)
        BNE     %BT30

	MOV	r6, r0		; r6 -> packet descriptor containing 1st byte
	SUB	r7, r2, #4	; r2 -> 1st byte

; we've found a sequence header
; r6 -> packet which contained sequence header
; r7 -> start of sequence header code
; r8+4 = new full length of packet

; first free all the packets before packet r6

	LDR	r0, [sp]	; reload original packet pointer
40
	TEQ	r0, r6
	BLNE	FreePacket
	BNE	%BT40

	STR	r0, [sp]	; store new packet descriptor pointer
	LDR	lr, [r0, #PacketDescriptor_Start]
	SUB	lr, r7, lr	; new start - old start = bytes lost in this packet
	STR	r7, [r0, #PacketDescriptor_Start]
	ADD	r8, r8, #4	; add on size of sequence header code itself
	STR	r8, [r0, #PacketDescriptor_FullLength]
	LDR	r7, [r0, #PacketDescriptor_Length]
	SUB	r7, r7, lr
	STR	r7, [r0, #PacketDescriptor_Length]
	MOV	lr, #PacketDescriptorFlags_MPEGStart
	STR	lr, [r0, #PacketDescriptor_Flags]	; make this packet an MPEG packet start,
							; junk any PTS/DTS cos it might not be valid any more
	MOV	r1, lr
	MOV	lr, #0
	STR	lr, SkippingToSequence

	TEQ	r0, r0					; set EQ, cos it's OK now
	EXIT

45
	TEQ	r0, r3
        LDRNE   r0, [r0, #PacketDescriptor_Link]
        LDRNE   r2, [r0, #PacketDescriptor_Start]
        LDRNE   r4, [r0, #PacketDescriptor_Length]
	BNE	%BT30
	B	%FT47

PSTSgetbyte
	SUB	r8, r8, #1
        SUBS    r4, r4, #1
        LDRGEB  r5, [r2], #1
        MOVGE   pc, lr
        TEQ     r0, r3
        LDRNE   r0, [r0, #PacketDescriptor_Link]
        LDRNE   r2, [r0, #PacketDescriptor_Start]
        LDRNE   r4, [r0, #PacketDescriptor_Length]
        BNE     PSTSgetbyte

; we've run out of data to check, therefore there is no sequence header in this full packet
; so free all the packets from r0 to r3 inclusive

47
	LDR	r0, [sp]				; restore original packet descriptor pointer
50
	TEQ	r0, r3
	BLNE	FreePacket
	BNE	%BT50

	BL	FreePacket				; free the last one as well
	STR	r0, [sp]				; update idea of what is start ptr
	TEQ	r0, #0					; if new pointer non-zero
	BNE	%BT05					; then loop back to start + try again

	STR	r0, HadProperPacketStart		; not had a proper packet start yet

	TEQ	r0, #1					; set NE, to indicate incomplete
	EXIT
 ]

; **************************************************************************
;
;       SendData - Send a block of data
;
; in:   r0 -> packet descriptor
;       r11 -> CL450_Registers
;
; out:  r1-r3 corrupted
;       EQ => used up all data in this packet

SendData Entry "r4-r7"
        LDR     r3, CL450_CMEM
        LDR     r1, [r0, #PacketDescriptor_Start]
        LDR     r2, [r0, #PacketDescriptor_Length]
        CMP     r2, #0                  ; zero length?
        EXIT    EQ
;        MOVLT   pc, #0                  ; ** debugging **
        LDR     r4, TrailingByte
        TEQ     r4, #0                  ; is there an outstanding byte?
        BEQ     %FT10                   ; [no so skip this]

 [ UseRDY
        CheckForReady   r5, r7
 |
        MOV     r5, #0
        STR     r5, TrailingByte
        CheckForReady   r5, r7, NotReady
 ]
        LDRB    r5, [r1], #1
        ORR     r4, r5, r4, LSL #8      ; (bit 31 of r4 gets lost!)
        STMIA   r3, {r4}
        SUBS    r2, r2, #1
        BEQ     %FT95
10
 [ UseRDY
        SUBS    r2, r2, #2              ; are there at least 2 bytes left?
        BCC     %FT95
        CheckForReady   r6, r7
 |
        CheckForReady   r6, r7, NotReady
        SUBS    r2, r2, #2              ; are there at least 2 bytes left?
        BCC     %FT95
 ]
        LDRB    r4, [r1], #1
        LDRB    r5, [r1], #1
        ORR     r4, r5, r4, LSL #8
        SUBS    r2, r2, #2
        BCC     %FT90
        LDRB    r5, [r1], #1
        LDRB    r6, [r1], #1
        ORR     r5, r6, r5, LSL #8
        STMIA   r3, {r4, r5}
        B       %BT10

90
        STMIA   r3, {r4}
95
        ANDS    r4, r2, #1              ; if no odd byte left, r4=0
        LDRNEB  r4, [r1], #1            ; else load odd byte
        ORRNE   r4, r4, #&80000000      ; and set flag bit to ensure non-zero
        STR     r4, TrailingByte

 [ UseRDY
        LDR     r4, OutstandingDataSize
        LDR     r2, [r0, #PacketDescriptor_Length]      ; reload length
        SUB     r4, r4, r2
        STR     r4, OutstandingDataSize
        EXIT
 |
        MOV     r2, #0                                  ; none left
NotReady
  [ PreFillBuffer
        LDR     r4, [r0, #PacketDescriptor_Length]
   [ TrapUnderruns :LOR: CheckCountUnderrunsBit
        SUBS    r4, r4, r2                              ; r4 = number of bytes sent
	LDRNE	r3, UnderrunCondition			; if we sent some bytes, and there was an underrun
	TEQNE	r3, #0
	BLNE	ClearInterruptStatus			; then we should be able to zero InterruptStatus again
   |
        SUB     r4, r4, r2                              ; r4 = number of bytes sent
   ]
        LDR     r3, AmountSent
        CMP     r3, #0                                  ; if we've already gone past pre-fill stage
        BLT     %FT98                                   ; then skip
        ADD     r3, r3, r4
        LDR     r4, =PreFillSize
        CMP     r3, r4
        MOVCS   r3, #-1
        STR     r3, AmountSent
   [ SendPlaySWI
        BLCS    IssuePlaySWI
   |
        BLCS    SendPlay
   ]
98
  ]
        STR     r1, [r0, #PacketDescriptor_Start]
        STR     r2, [r0, #PacketDescriptor_Length]
        TEQ     r2, #0
        EXIT
 ]

 [ SendPlaySWI

IssuePlaySWI Entry "r0,r1"
        MOV     r0, #StreamFlags_VideoPresent   ; indicate video now ready
        LDR     r1, ControlStreamHandle
        SWI     XMPEGControl_Play
        EXIT
 ]

; **************************************************************************
;
;       FreePacket - Free a packet
;
; in:   r0 -> packet descriptor
;       (r11 -> CL450_Registers)
;       IRQs disabled
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;       Also updates PacketListHeadPtr, PacketListTailPtr
;       Flags must be preserved
;

FreePacket ROUT
        Push    "r1, lr"
        MOV     r1, pc
        ORR     lr, r1, #I_bit
        TEQP    lr, #0                          ; disable IRQs round this

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, PacketListHeadPtr           ; update PacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, PacketListTailPtr           ; then zero PacketListTailPtr

        TEQP    r1, #0                          ; restore IRQ state

        Push    "lr"
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
        MOV     lr, pc
        LDR     pc, [r0, #PacketDescriptor_FreeRoutine]
        Pull    "r0,r1, pc",,^                     ; exit preserving flags

; **************************************************************************
;
;       SyncOffset_Code - Set offset added to SCR values before programming

SyncOffset_Code Entry
        LDR     wp, [r12]

        LDRB    r1, [r0, #0]
        TEQ     r1, #"-"
        ADDEQ   r0, r0, #1
        MOVEQ   r6, #1
        MOVNE   r6, #0
        MOV     r1, r0
        MOV     r0, #10 :OR: (1:SHL:31) ; insist on space or ctrl char terminator, base 10
        SWI     XOS_ReadUnsigned
        EXIT    VS

        TEQ     r6, #0
        RSBNE   r2, r2, #0
        STR     r2, SyncOffset
        EXIT

; **************************************************************************
;
;	Stats - Entry point for MPEGVideo_Stats SWI - Return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = video stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

	MACRO
	StatsTableEntry	$tag, $value
 [ :BASE: ($value) = 12
	&	$tag, :INDEX: ($value)
 |
	ASSERT	:BASE: $value = 15
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

Stats	Entry "r2, r5-r6"

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	EXIT	EQ				; then exit

	ADR	r6, StatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [wp, lr]
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

Stats_LengthOfPendingPackets Entry "r0,r1"
	MOV	r0, pc
	ORR	r0, r0, #I_bit			; disable IRQs so atomic
	TEQP	r0, #0

	MOV	r6, #0
	LDR	lr, PacketListHeadPtr
10
	TEQ	lr, #0
	LDRNE	r1, [lr, #PacketDescriptor_Length]
	ADDNE	r6, r6, r1
	LDRNE	lr, [lr, #PacketDescriptor_Link]
	BNE	%BT10
	EXITS					; exit restoring IRQ state

StatsTable
 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
	StatsTableEntry &1000, UnderrunCount
 ]
	StatsTableEntry &1001, AmountReceived
	StatsTableEntry &1002, AmountSent
	StatsTableEntry &1003, IRQCounts + 3*4
 [ RegisterLastFullness
	StatsTableEntry &1004, LastFullness
 ]
	StatsTableEntry &1005, LastAmountSent
	StatsTableEntry &1006, NumberOfResets
 [ DontFlushOnEmpty
	StatsTableEntry &1007, LastFlushDidntHappen
 ]
	StatsTableEntry &1008, SpeedSetting
 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
	StatsTableEntry &1009, UnderrunCondition
 ]
	StatsTableEntry &100A, LastCommandSent
	StatsTableEntry &100B, Stats_LengthOfPendingPackets
	&	-1

; **************************************************************************
;
;       VideoInfo_Code - Output debugging info

VideoInfo_Code Entry
        LDR     wp, [r12]

	LDR	lr, StreamFlags
	DREG	lr, "StreamFlags = &"

	LDR	lr, AmountReceived
	DREG	lr, "AmountReceived = &"

	LDR	lr, AmountSent
	DREG	lr, "AmountSent = &"

 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
	LDR	lr, UnderrunCount
	DREG	lr, "Number of underruns = &"
 ]

	LDR	lr, IRQCounts + 3*4		; load number of SEQ-V IRQs
	DREG	lr, "SEQ-V IRQS = &"

 [ RegisterLastFullness
	LDR	lr, LastFullness
	DREG	lr, "Last buffer fullness = &"
 ]

	LDR	lr, LastAmountSent
	DREG	lr, "Last amount sent = &"

	LDR	lr, NumberOfResets
	DREG	lr, "Number of ResetStreams = &"

 [ DontFlushOnEmpty
	LDR	lr, LastFlushDidntHappen
	TEQ	lr, #0
	BEQ	%FT03
	DLINE	"** Last flush didn't happen **"
03
 ]

	LDR	lr, SpeedSetting
	DREG	lr, "SpeedSetting = &"

 [ TrapUnderruns :LOR: CheckCountUnderrunsBit
	LDR	lr, UnderrunCondition
	TEQ	lr, #0
	BEQ	%FT05
	DLINE	"** In underrun condition at present **"
05
 ]

	MOV	r0, pc
	ORR	r1, r0, #I_bit
	TEQP	r1, #0

	MOV	r2, #0
	LDR	lr, PacketListHeadPtr
07
	TEQ	lr, #0
	LDRNE	r3, [lr, #PacketDescriptor_Length]
	ADDNE	r2, r2, r3
	LDRNE	lr, [lr, #PacketDescriptor_Link]
	BNE	%BT07

	TEQP	r0, #0
	DREG	r2, "Length of pending packets = &"

	LDR	lr, LastCommandSent
	DREG	lr, "Last command sent = "

 [ FullLengthStats
        DLINE   "Full lengths of packets"
        ADRL    r0, LengthStatsPosition
        LDR     r1, [r0], #4
10
        SUBS    r1, r1, #1
        BCC     %FT20
        LDR     r2, [r0], #4
        DREG    r2, " "
        B       %BT10
20
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

MicroCode
        BIN     "$CL450MCode"
MicroCodeEnd

        InsertDebugRoutines

        END
