; > Module
; Source for MPEG Control Module
; Output to file version

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 01-Jun-94  TMD  0.01          Started work (after a false start in 'C')
; 18-Jul-94  TMD  0.10          Release for Malcolm's trip
; 23-Aug-94  TMD  0.18          Added debug code for unknown MPEGControl SWI
;                               Now copes with multiple packets being freed at once
;                               Added checks for negative packet/full packet length
; 08-Sep-94  TMD  0.19          Put in flags in MPEGControl_Play, so both audio and video
;                               need to be ready before it plays
; 17-Oct-94  TMD  0.20          Put in incoming data rate measurement
; 20-Oct-94  TMD  0.21          If playing elemental video or audio stream, clear other bit in NotReadyBits
; 21-Oct-94  TMD  0.22          If playing elemental video or audio stream, chop up buffers into packets < 64K
; 01-Nov-94  TMD  0.23          Attempt to recover from negative length packets
; 14-Nov-94  TMD  0.24          Fix SWI despatch to use correct SWI limit
; 07-Feb-95  TMD  0.25		Made die entry free packet descriptors on free list
; 07-Feb-95  TMD  0.26		Fixed bug OMI-00006 (if opening audio fails, now closes already opened video stream)
; 06-Mar-95  TMD  0.27		Added MPEGControl_ResetStream
; 29-Mar-95  TMD  0.28		Debug version to check ICL server problem
; 06-Apr-95  TMD  0.29		(Conditionally) fake a zero PTS on audio-only stream packets
; 06-Apr-95  TMD  0.30		Don't zero DataReceived on Play SWI, as we've already received some by then!
; 24-May-95  TMD  0.31		Added MPEGControl_MuteSound
; 08-Jun-95  TMD  0.32		Check StreamFlags_PassThroughToVideo
; 21-Jul-95  TMD  0.33		Added detection of iso_11172_end_code (&000001B9)
; 28-Jul-95  TMD  0.34		Created file variant
; 08-Feb-96  TMD  0.35		Fix FreeBuffer routine not setting up r12 when a routine address is specified rather than a SWI.
; 09-Aug-96  TMD  0.36		Ignore SelectProgram SWI
; 17-Apr-97  TMD  0.37		Ignore Stats SWI
;				Added CaptureToDynArea option
; 18-Apr-97  TMD  0.38		Only capture while stream open
; 18-Apr-97  TMD  0.39		Added circular buffer option
;

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

                GBLL    UseSVCStack
UseSVCStack     SETL     {TRUE}

                GBLL    AutoABSDetect
AutoABSDetect   SETL    {TRUE}                          ; automatically detect audio-only files

                GBLL    ErrorRecovery
ErrorRecovery   SETL    {TRUE}                          ; attempt to recover from -ve length packets

		GBLL	ICLDebug
ICLDebug	SETL	{FALSE}

		GBLL	DVBSupport
DVBSupport	SETL	{FALSE}

		GBLL	CaptureToDynArea
CaptureToDynArea SETL	{FALSE}				; copy buffers into a dynamic area and leave it there

		GBLL	CircularBuffer
CircularBuffer	SETL	{FALSE}				; reuse buffer in a circular fashion

		GBLL	CreateDynArea
CreateDynArea	SETL	DVBSupport :LOR: CaptureToDynArea

 [ UseSVCStack
InternalStack           *       &01C01000               ; half way down normal SVC stack
 |
InternalStackSize       *       4096                    ; could probably work with much less
 ]

; If playing elemental streams, we need to chop up large buffers longer than 64K into smaller
; chunks, because the maximum MPEG packet size is 64K

MaxMPEGPacketLength     *       &FF00                   ; allow some space for packet headers as well

; Control stream handle structure

                        ^       0
CSH_StreamFlags         #       4
CSH_VideoStreamHandle   #       4
CSH_AudioStreamHandle   #       4
CSH_InternalSP          #       4                       ; internal stack pointer for coroutines
CSH_ExternalSP          #       4                       ; external stack pointer for coroutines
CSH_NotReadyBits        #       4                       ; bits indicating which elemental modules are not yet ready to play
 [ SendFirstSCR
CSH_SendNextSCR         #       4                       ; flag indicating we should send next SCR to video module
 ]
CSH_StartTime           #       4                       ; time stream was opened
CSH_LastTime            #       4                       ; last time data was received
CSH_DataReceived        #       4                       ; amount of data received
CSH_EndOfStreamReceived	#	4			; 0 normally, 1 when end of stream code has been received

 [ DataRateStats
DataCountPeriod         *       300                     ; seconds in 1 period
DataCountArraySize      *       100                     ; allow for 100 periods at present
CSH_DataCounts          #       DataCountArraySize * 4  ; one word per minute
 ]

 [ :LNOT: UseSVCStack
CSH_InternalStack       #       InternalStackSize       ; stack for coroutines
CSH_InternalStackEnd    #       0
 ]
CSHSize                 *       @


                        ^       0, wp

FreePacketListHeadPtr   #       4       ; pointer to head of list of free packet descriptors
FreePacketListTailPtr   #       4       ; pointer to tail of list

SWIInstruction          #       8       ; SWI + Pull pc

DebugFileHandle		#	4

 [ CreateDynArea
  [ CaptureToDynArea
   [ CircularBuffer
dyn_area_size		*	30000*376
DynAreaTotal		#	4	; total amount received, including wraps
   |
dyn_area_size		*	10*1024*1024
   ]
DynAreaOffset		#	4	; offset into dynamic area of next data
  |
dyn_area_size		*	256*1024
StreamFlags		#	4	; includes StreamFlags_DVB
  ]
DynAreaNumber		#	4	; dynamic area number of RAM block for copying buffer data before GBPB
DynAreaAddress		#	4	; logical base address of same
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

ControlStreamHandle     #       CSHSize ; goes at the end cos likely to be long (with stack)
                                        ; NB this could be dynamically allocated on OpenStream eventually

Module_WorkspaceSize * :INDEX: @

; ** Debugging macros **

        GBLL    debug
debug   SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   $string, $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, $string, $cc, $routine
 ]
        MEND

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGControlSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "MPEGControl", 0

Mod_HelpStr
        =       "MPEGControl", TAB, "0.39 (18 Apr 1997)"
 [ CaptureToDynArea
  [ CircularBuffer
	=	" (Output to circular dynamic area version)"
  |
	=	" (Output to dynamic area version)"
  ]
 |
	=	" (Output to file version)"
 ]
 [ ICLDebug
	=	" ICL Debug"
 ]
	=	0
        ALIGN

Mod_SWITable
        =       "MPEGControl", 0
        =       "OpenStream", 0
        =       "FullBuffers", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
	=	"ResetStream", 0
	=	"MuteSound", 0
	=	"SoundVolume", 0
	=	"SelectProgram", 0
	=	"Stats", 0
        =       0

Mod_HC_Table
        Command CtrlInfo, 0, 0
 [ CaptureToDynArea
	Command SaveOutput, 1, 1
 ]
        =       0


CtrlInfo_Help
        =       "*CtrlInfo outputs debugging info.", CR
CtrlInfo_Syntax
        =       "Syntax: *CtrlInfo", 0
 [ CaptureToDynArea
SaveOutput_Help
	=	"*SaveOutput saves captured MPEG data to a file.", CR
SaveOutput_Syntax
	=	"Syntax: *SaveOutput <filename>", 0
 ]
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, FreePacketListHeadPtr
        STR     r0, FreePacketListTailPtr

	MOV	r0, #StreamFlags_StreamClosing
	STR	r0, ControlStreamHandle+CSH_StreamFlags	; indicate no stream open

 [ CreateDynArea
	MOV	r0, #-1			; no area in existence
	STR	r0, DynAreaNumber
 ]
 [ CaptureToDynArea
	BL	create_area
	EXIT	VS
 ]
        LDR     r0, PullPCInstruction
        STR     r0, SWIInstruction +4

        CLRV
        EXIT

PullPCInstruction
        Pull    PC

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; Free all the packets on our free list

	LDR	r1, FreePacketListHeadPtr
10
	MOVS	r2, r1					; are there any more nodes to free?
	BEQ	%FT90					; [no, so skip]
	LDR	r1, [r2, #PacketDescriptor_Link]	; get link to next
	MOV	r0, #ModHandReason_Free			; free this one
	SWI	XOS_Module
	B	%BT10					; and try again

90
 [ CaptureToDynArea
	BL	remove_area
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #(SWIBTableEnd-SWIBTable) :SHR: 2
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
SWIBTable
        B       OpenStream      ; open stream
        B       FullBuffers     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
	B	ResetStream	; discard data and reset devices
	B	MuteSound	; mute/unmute sound
	B	SoundVolume	; set sound volume
	B	SelectProgram	; select program
	B	Stats		; output statistics
SWIBTableEnd

;	ASSERT  (MPEGControlSWICheckValue - MPEGControlSWI_Base)*4 = {PC} - SWIBTable

SelectProgram
	CLRV
	MOV	pc, lr

NoSuchSWI
        Push    "lr"
        SWI     XOS_WriteI+22
        SWI     XOS_WriteI+12
        DREG    r11, "Unknown MPEGControl SWI - offset from base = "
        DLINE   "Press any key"
        SWI     XOS_ReadC
        ADR     r0, NoSuchSWIError
	Pull	"lr"
Stats
        SETV
        MOV	pc, lr

NoSuchSWIError
        &       0
        =       "No such MPEGControl SWI", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control parameters structure
;       r2 = video parameters structure
;       r3 = audio parameters structure
;
; out:  r0 = control stream handle (for now)
;

OpenStream Entry "r1"
	STR	r0, ControlStreamHandle+CSH_StreamFlags
 [ DVBSupport
	STR	r0, StreamFlags
	TST	r0, #StreamFlags_DVB
	BEQ	%FT10
	BL	create_area
	EXIT	VS
10
 ]
 [ CaptureToDynArea
	MOV	r0, #0
	STR	r0, DynAreaOffset	; reset back to start of dyn area
  [ CircularBuffer
	STR	r0, DynAreaTotal
  ]

	ADR	r0, ControlStreamHandle	; ctrl handle
	EXIT
 |
	MOV	r0, #&80
	ADR	r1, CtrlDebugFilename
	SWI	XOS_Find
	STRVC	r0, DebugFileHandle
  [ DVBSupport
	BLVS	remove_area
  ]
	EXIT

CtrlDebugFilename
	=	"<MPEGCtrlDebug>", 0
	ALIGN

 ]

; **************************************************************************
;
;       Play - Start audio and video playing (if both ready)
;
; in:   r0 = flags
;            bit 0 set => video module ready to play
;            bit 1 set => audio module ready to play
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

Play    Entry "r0-r3"
	CLRV
	EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of play on MPEG stream
;
; in:   r0 = flags
;       r1 = external stream handle (assumed for now)
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0-r3"
        CLRV
        EXIT

; **************************************************************************
;
;       MuteSound - Mute/unmute sound
;
; in:   r0 = flags
;		bit 0 = 0 => sound on
;		        1 => sound off
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

MuteSound Entry "r0-r3"
	CLRV
        EXIT

; **************************************************************************
;
;       SoundVolume - Set/read sound volume
;
; in:   r0 = flags (zero for now)
;       r1 = external stream handle (assumed for now)
;	r2 = -1 => read volume
;	   = 0..256 => set volume (logarithmic)
;
; out:  r2 = old volume
;

SoundVolume Entry "r0-r3"
	CLRV
	EXIT

; **************************************************************************
;
;       FullBuffers - Here's some more data
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> one or more linked bitstream buffers

FullBuffers Entry "r0-r4"
 [ :LNOT: CaptureToDynArea
	LDR	r1, DebugFileHandle
 ]
10
	Push	"r2"
	LDR	r3, [r2, #BufferDescriptor_Length]
	LDR	r2, [r2, #BufferDescriptor_Start]
 [ CaptureToDynArea
	ADR	r1, ControlStreamHandle
	LDR	r0, [r1, #CSH_StreamFlags]
	TST	r0, #StreamFlags_StreamClosing
	BNE	%FT60			; stream closed
	LDR	lr, =dyn_area_size
	LDR	r1, DynAreaOffset
	RSBS	lr, r1, lr
	BLS	%FT60			; no room left
	Push	"r3, r5-r11"
	CMP	r3, lr			; do the minimum of amount given and space left
	MOVHI	r3, lr
	LDR	r0, DynAreaAddress
	ADD	r0, r0, r1
	ADD	r1, r1, r3
  [ CircularBuffer
	LDR	lr, =dyn_area_size
	TEQ	r1, lr
	MOVEQ	r1, #0
	STR	r1, DynAreaOffset
	LDR	r1, DynAreaTotal
	ADD	r1, r1, r3
	STR	r1, DynAreaTotal
  |
	STR	r1, DynAreaOffset
  ]
 ]
 [ DVBSupport
	LDR	r0, StreamFlags
	TST	r0, #StreamFlags_DVB
	BEQ	%FT50
	LDR	r0, DynAreaAddress
	Push	"r3, r5-r11"
 ]
 [ CreateDynArea
15
	TST	r0, #3
	TSTEQ	r2, #3			; if either source or destination are not word-aligned
	LDRNEB	lr, [r2], #1		; then copy single bytes
	STRNEB	lr, [r0], #1
	SUBNES	r3, r3, #1		; until they are, or until we run out of data
	BNE	%BT15

20
	SUBS	r3, r3, #8*4
	LDMCSIA	r2!, {r4-r11}
	STMCSIA	r0!, {r4-r11}
	BHI	%BT20
	ADDCC	r3, r3, #8*4
30
	SUBS	r3, r3, #4
	LDMCSIA	r2!, {r4}
	STMCSIA r0!, {r4}
	BHI	%BT30
	ADDCC	r3, r3, #4
35
	SUBS	r3, r3, #1
	LDRCSB	r4, [r2], #1
	STRCSB	r4, [r0], #1
	BHI	%BT35
	Pull	"r3, r5-r11"
	LDR	r2, DynAreaAddress
50
 ] ; CreateDynArea
 [ :LNOT: CaptureToDynArea
	MOV	r0, #2					; write bytes using current ptr
	SWI	XOS_GBPB
 ]
60
	Pull	"r2"
65
        LDR     r4, [r2, #BufferDescriptor_Link]        ; load link

	MOV	lr, #0
        STR     lr, [r2, #BufferDescriptor_Link] ; only free one buffer
        MOV     r1, r2
        BL      FreeBuffer

        MOVS    r2, r4                  ; put link back into r2
        BNE     %BT10                   ; and if more buffers, loop
        CLRV
        EXIT

; **************************************************************************
;
;       CloseStream - Close the stream
;
; in:   r0 = flags
;       r1 = control stream handle
;

CloseStream Entry "r0,r1"
	MOV	r0, #StreamFlags_StreamClosing
	STR	r0, [r1, #CSH_StreamFlags]	; indicate stream closing

 [ :LNOT: CaptureToDynArea
	LDR	r1, DebugFileHandle
	MOV	r0, #0
	SWI	XOS_Find
 ]

 [ DVBSupport
	BL	remove_area
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       FreePackets - Called by video/audio devices to free a packet
;
; in:   r0 -> packet descriptor (for now)
;
; out:  -
;

FreePackets Entry "r0-r5, wp"
        MOV     r1, r0
        LDR     wp, [r1, #PacketDescriptor_FreeWorkspace]
10
        LDR     r2, [r1, #PacketDescriptor_BufferDescriptor]    ; get parent buffer pointer

        MOV     r3, pc
        ORR     lr, r3, #I_bit                          ; disable IRQs round this bit
        TEQP    lr, #0

; decrement outstanding packet count for buffer (atomically)

        LDR     lr, [r2, #BufferDescriptor_Packets]     ; (needs to be atomic)
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

; add this packet descriptor to free list

        LDR     r4, FreePacketListTailPtr
        TEQ     r4, #0                                  ; if no packets currently free
        STREQ   r1, FreePacketListHeadPtr               ; then point head at new free packets
        STRNE   r1, [r4, #PacketDescriptor_Link]        ; else tail!link = packet
        STR     r1, FreePacketListTailPtr               ; store new tail ptr

        LDR     r4, [r1, #PacketDescriptor_Link]        ; go down to next packet on passed list
        MOV     r5, #0
        STR     r5, [r1, #PacketDescriptor_Link]        ; detach packet

        TEQP    r3, #0                                  ; restore IRQ state

        TEQ     lr, #0                                  ; if all buffer data has been used, then free buffer
        STREQ   lr, [r2, #BufferDescriptor_Link]        ; only free one buffer
        MOVEQ   r1, r2
        BLEQ    FreeBuffer

        MOVS    r1, r4                                  ; are we at end of passed list?
        BNE     %BT10                                   ; no, so loop

        EXIT

; **************************************************************************
;
;	ResetStream - Discard data and reset devices
;
; in:	r0 = flags
;		bit 0 set => new stream has video data
;		bit 1 set => new stream has audio data
;	r1 = control stream handle
;
; out:	r2 = estimate of amount of discarded video data, in bytes
;	r3 = estimate of amount of discarded audio data, in bytes
;

ResetStream Entry "r0-r3"
	MOV	r0, #OSArgs_SetEXT
	LDR	r1, DebugFileHandle
	MOV	r2, #0			; set extent to zero
	SWI	XOS_Args
        CLRV
        EXIT

; **************************************************************************
;
;       FreeBuffer - Call owner of buffer to free it
;
; in:   r1 -> buffer descriptor
;
; out:  -
;

FreeBuffer Entry "r0-r2,r12"
        LDR     r2, [r1, #BufferDescriptor_FreeRoutine]
        TEQ     r2, #0          ; check for SWI interface
        BEQ     %FT10

; routine interface

	LDR	r12, [r1, #BufferDescriptor_FreeWorkspace]	; setup workspace ptr
        MOV     r0, #3
        MOV     lr, pc
        MOV     pc, r2
        EXIT

; swi interface

10
        LDR     r2, [r1, #BufferDescriptor_FreeWorkspace]
        ORR     r2, r2, #&EF000000
        STR     r2, SWIInstruction +0
        MOV     r2, r1
	MOV	r0, #0
        MOV     r1, #0
        BL      %FT20
        EXIT

20
        Push    "lr"
        ADR     pc, SWIInstruction

 [ {FALSE}
; **************************************************************************
;
;       Coroutine stuff
;
; Entry parameters for coroutines:
;  r0-r4 are passed in
;  r5-r11 hold their value across calls
;
;       r0 = flags on entry to FullBuffers
;       r1 = control stream handle
;       r2 -> buffers
;       r3 -> start of first buffer's data (current position during call)
;       r4 -> end of first buffer's data
;
;       r5
;       r6
;       r7 holds return from getbyte, getnextstartcode
;       r8 remaining length of packet
;       r9
;       r10 video/audio selector for packet
;       r11 packet descriptor in preparation

CallCoroutines Entry "r5-r11"
        STR     sp, [r1, #CSH_ExternalSP]
        LDR     sp, [r1, #CSH_InternalSP]
        EXIT

; cowait

cowait  ALTENTRY
        STR     sp, [r1, #CSH_InternalSP]       ; save internal stack pointer
        LDR     sp, [r1, #CSH_ExternalSP]
        EXIT

; coinit
;
; in:   r1 -> control stream handle
; out:  -
;

coinit  ALTENTRY                                ; must push same stuff as CoWait pulls
        STR     sp, [r1, #CSH_ExternalSP]
 [ UseSVCStack
        LDR     sp, =InternalStack
 |
        LDR     r3, =CSH_InternalStackEnd
        ADD     sp, r1, r3
 ]
        BL      cowait

; and when we come back, drop thru to...

	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_PassThroughToVideo
	BNE	PassThroughToVideo


 [ AutoABSDetect
        LDRB    r7, [r3, #0]                            ; if first byte = &FF, then audio-only file
        TEQ     r7, #&FF
        LDREQ   r10, [r1, #CSH_NotReadyBits]            ; it's audio-only, so don't make audio wait for video
        BICEQ   r10, r10, #StreamFlags_VideoPresent
        STREQ   r10, [r1, #CSH_NotReadyBits]
        MOVEQ   r10, #StreamFlags_AudioPresent          ; indicate all audio packets
        BEQ     allvidoraudloop
 ]

waitforstartcode
        BL      getnextstartcode
        CMP     r7, #&B9				; TMD 21-Jul-95 - changed to include end-of-stream code
        BCS     notallvideo

        SUB     r3, r3, #4                              ; move pointer back to start of start code
                                                        ; (hopefully this won't cross block boundary!)
 [ ICLDebug
	Push	"r1,r3"
	LDR	r3, [r2, #BufferDescriptor_Start]
	SWI	XOS_WriteI+22
	SWI	XOS_WriteI+12
	MOV	r10, #0
00
	LDRB	r1, [r3, r10]
	BL	Tutu_Byte
	SWI	XOS_WriteI+32
	SWI	XOS_WriteI+32
	ADD	r10, r10, #1
	TEQ	r10, #64
	BNE	%BT00
	Pull	"r1,r3"
 ]

PassThroughToVideo
        LDR     r10, [r1, #CSH_NotReadyBits]            ; it's video-only, so don't make video wait for audio
        BIC     r10, r10, #StreamFlags_AudioPresent
        STR     r10, [r1, #CSH_NotReadyBits]

        MOV     r10, #StreamFlags_VideoPresent ; indicate all video packets
allvidoraudloop
        LDR     r0, [r1, #CSH_StreamFlags]
        TST     r0, r10
        BEQ     %FT10
05
        BL      GetPacketDescriptor
        MOV     r11, r0
        SUB     r7, r4, r3
        CMP     r7, #MaxMPEGPacketLength
        MOVHI   r7, #MaxMPEGPacketLength
        STR     r7, [r11, #PacketDescriptor_FullLength]
        MOV     lr, #PacketDescriptorFlags_MPEGStart
 [ GeneratePTSsForAudioOnly
	TEQ	r10, #StreamFlags_AudioPresent		; if an audio-only stream
	ORREQ	lr, lr, #PacketDescriptorFlags_PTSValid	; then generate a fake PTS of zero
        STR     lr, [r11, #PacketDescriptor_Flags]
	MOVEQ	lr, #0
	STREQ	lr, [r11, #PacketDescriptor_PTS+0]
	STREQ	lr, [r11, #PacketDescriptor_PTS+4]
 |
        STR     lr, [r11, #PacketDescriptor_Flags]
 ]
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer
        ADD     r7, r3, r7                              ; point at end of this packet
        BL      sendvidaudblock
        TEQ     r7, r4                                  ; have we got to end of buffer?
        MOVNE   r3, r7                                  ; if not, then move start
        BNE     %BT05                                   ; and create another packet
10
        BL      nextbuffer
        B       allvidoraudloop

notallvideo
        MOV     r10, #0                                 ; by default we're not interested in this packet
        TEQ     r7, #&E0                                ; if a video packet
        MOVEQ   r10, #StreamFlags_VideoPresent          ; then mark as such
        TEQ     r7, #&C0                                ; if audio packet
        MOVEQ   r10, #StreamFlags_AudioPresent          ; then mark as such
        LDR     r0, [r1, #CSH_StreamFlags]              ; load stream flags
        TST     r0, r10                                 ; if not a packet we're interested in
        BEQ     notvidaudpacket
        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_MPEGStart
        STR     r7, [r11, #PacketDescriptor_Flags]

        BL      getbyte                                 ; get bits 8-15 of length
        MOV     r8, r7
        BL      getbyte                                 ; get bits 0-7 of length
        ORR     r8, r7, r8, LSL #8                      ; r8 = length to go
skipstuffing
        BL      getbytedeccount
        TEQ     r7, #&FF
        BEQ     skipstuffing

        MOV     r9, r7, LSR #6
        TEQ     r9, #1
        BNE     notSTD
        AND     r9, r7, #&3F                            ; get bottom 6 bits of 1st byte
        BL      getbytedeccount                         ; get 2nd byte of STD-buffer-scale+size
        ORR     r9, r7, r9, LSL #8                      ; merge bytes
        TST     r9, #&2000                              ; test STD_buffer_scale bit
        BICNE   r9, r9, #&2000                          ; if set, then knock it out
        MOVNE   r9, r9, LSL #10                         ; and value is in units of 1024 bytes
        MOVEQ   r9, r9, LSL #7                          ; else value is in units of 128 bytes
        STR     r9, [r11, #PacketDescriptor_BSn]        ; store BSn field
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_BSnValid ; set BSn valid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        BL      getbytedeccount                         ; get byte after
notSTD
        MOVS    r9, r7, LSR #4                          ; get top 4 bits of next byte, and put bit 3 into carry
        TEQ     r9, #2                                  ; check for PTS only (doesn't affect carry)
        BNE     notPTS                                  ; carry now holds bit 32 of PTS
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid  ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]

vidaudpacketcommon
        STR     r8, [r11, #PacketDescriptor_FullLength] ; save full length of MPEG packet data (ignoring buffer breaks)
 [ :LNOT: ErrorRecovery
        CMP     r8, #0                                  ; ** debugging **
        BLT     badfulllength
 ]
        TEQ     r3, r4                                  ; ensure we've got at least one byte to send
        BLEQ    nextbuffer
vidaudpacketcontinue
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer

        CMP     r8, #0                                  ; negative length packet?
        BLT     badlength
        ADD     r7, r3, r8                              ; end of video packet (if it was all in this buffer)
        CMP     r7, r4                                  ; is it all within this buffer?
        BHI     notallinbuff

        BL      sendvidaudblock
        MOV     r3, r7                                  ; start from end of video block data
errorcontinue
        BL      getnextstartcode
        B       notallvideo

 [ ErrorRecovery
badlength
        Push    "r0"
        MOV     r0, r11                                 ; r0 -> packet
        BL      FreePackets                             ; free it (possibly also freeing buffer)
        Pull    "r0"
        B       errorcontinue
 |
badlength
        SWI     XOS_WriteI + 22
        SWI     XOS_WriteI + 12
        DREG    r8, "Ctrl packet length = "
        SWI     XOS_ReadC
        MOV     pc, #0

badfulllength
        SWI     XOS_WriteI + 22
        SWI     XOS_WriteI + 12
        DREG    r8, "Ctrl packet full length = "
        SWI     XOS_ReadC
        MOV     pc, #0
 ]

notallinbuff
        SUB     r8, r7, r4                              ; r8 = amount of excess
        MOV     r7, r4
        BL      sendvidaudblock                         ; send this amount
        BL      nextbuffer

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_Flags]
        STR     r7, [r11, #PacketDescriptor_FullLength]
        B       vidaudpacketcontinue

notPTS
        TEQ     r9, #3
        BNE     vidaudpacketcommon                      ; not PTS+DTS, so must be plain
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}

        BL      getbytedeccount                         ; get first byte of DTS, with %0001 at front
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}

        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid :OR: PacketDescriptorFlags_DTSValid
                                                        ; set PTSValid + DTSValid bits in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        B       vidaudpacketcommon

; This routine gets a 33-bit PTS, DTS or SCR from the stream
;
; in:   r7 = first byte (including bits 32..30)
; out:  r7 = low 32 bits
;       r9 = bit 32 in bit 0

getclockreference ROUT
        Push    "lr"
        AND     r7, r7, #&0E                            ; extract bits 3..1
        MOV     r9, r7, LSR #3                          ; r9 = bit 32 in bit 0
        Push    "r9"                                    ; save for later
        MOV     r9, r7, LSL #31-2                       ; r9 = bits 31,30
        BL      getbytedeccount                         ; get bits 29..22 in bits 7..0
        ORR     r9, r9, r7, LSL #22                     ; r9 = bits 31..22
        BL      getbytedeccount                         ; get bits 21..15 in bits 7..1
        MOV     r7, r7, LSR #1
        ORR     r9, r9, r7, LSL #15                     ; r1 = bits 31..15
        BL      getbytedeccount                         ; get bits 14..7 in bits 7..0
        ORR     r9, r9, r7, LSL #7                      ; r1 = bits 31..7
        BL      getbytedeccount                         ; get bits 6..0 in bits 7..1
        ORR     r7, r9, r7, LSR #1                      ; r9 = bits 31..0
        Pull    "r9, pc"

incrementpacketcount Entry "r0"
        MOV     r0, pc
        ORR     lr, r0, #I_bit                          ; disable IRQs
        TEQP    lr, #0

        LDR     lr, [r2, #BufferDescriptor_Packets]
        ADD     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        TEQP    r0, #0                                  ; restore IRQ state
        EXIT

notvidaudpacket
        CMP     r7, #&BC                ; is it a packet header
        BCS     packettoskip
 [ SendFirstSCR
        TEQ     r7, #&BA                ; is it a pack header
        BNE     %FT20                   ; no, then nothing to do
        LDR     r7, [r1, #CSH_SendNextSCR]
        TEQ     r7, #0                  ; should we send it
        BEQ     %FT20                   ; [no, cos we've already sent one, or there's no video active]
        MOV     r7, #0
        STR     r7, [r1, #CSH_SendNextSCR] ; don't send any more

        BL      getbyte                 ; get bits 32..30 in bits 3..1
        BL      getclockreference
        Push    "r0-r2"

        DREG    r7, "Low SCR = "
        DREG    r9, "High SCR = "

        MOV     r0, #0
        MOV     r1, r7
        MOV     r2, r9
        SWI     XMPEGVideo_SetSCR

        MOV     r0, #&03500000
        LDR     r1, =&400000FF
        STR     r1, [r0]

        Pull    "r0-r2"
20
 ]
	TEQ	r7, #&B9				; is it end-of-stream marker
	MOVEQ	lr, #1
	STREQ	lr, [r1, #CSH_EndOfStreamReceived]	; indicate we've received end-of-stream marker

        BL      getnextstartcode
        B       notallvideo

        LTORG

packettoskip
        BL      getbyte                 ; get bits 8-15 of length
        MOV     r8, r7
        BL      getbyte                 ; get bits 0-7 of length
        ORR     r8, r7, r8, LSL #8      ; r8 = length to go

notvideopacketcommon
        ADD     r7, r3, r8              ; end of packet (if it was all in this buffer)
        CMP     r7, r4                  ; is it all within this buffer?
        BCS     notallinbuff2

        MOV     r3, r7                  ; start from end of block data
        BL      getnextstartcode
        B       notallvideo

notallinbuff2
        SUB     r8, r7, r4              ; r8 = amount of excess
        BL      nextbuffer
        B       notvideopacketcommon


getnextstartcode
        Push    "lr"
getnextstartcodeloop
        BL      getbyte                 ; look for 1st zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
        BL      getbyte                 ; look for 2nd zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
gottwozeros
        BL      getbyte                 ; look for "1" of start code
        CMP     r7, #1
        BCC     gottwozeros             ; if 3rd zero, then not start code, but we've got two zeros
        BNE     getnextstartcodeloop    ; not zero or one, so look for 1st zero again
        BL      getbyte                 ; get start code reason
        Pull    "pc"

getbytedeccount
        SUB     r8, r8, #1              ; decrement count of bytes remaining
getbyte
        CMP     r3, r4
        LDRCCB  r7, [r3], #1
        MOVCC   pc, r14

        Push    "lr"
        BL      nextbuffer
        Pull    "lr"
        B       getbyte

 [ {TRUE}
nextbuffer *    cowait
 |
nextbuffer
        LDR     r2, [r2, #BufferDescriptor_Link]        ; go onto next buffer being added
        TEQ     r2, #0                                  ; if there is one, then
        LDRNE   r3, [r2, #BufferDescriptor_Start]       ; load start address
        LDRNE   r4, [r2, #BufferDescriptor_Length]      ; load length
        ADDNE   r4, r3, r4                              ; convert to end address
        MOVNE   pc, lr
        B       cowait                                  ; else wait for another buffer
 ]

; **************************************************************************
;
;       sendvidaudblock - send block of video/audio data
;
; in:
;       r1 = control stream handle
;       (r2 -> buffer descriptor)
;       r3 -> start of block to send (not necessarily start of buffer))
;       (r4 -> end of buffer)
;       r7 -> end of block to send (+1))
;       r10 = start code for video or audio packet so we know which
;       r11 -> packet descriptor (filled in apart from Length field)

sendvidaudblock Entry "r0-r2"
        SUB     r0, r7, r3
        STR     r0, [r11, #PacketDescriptor_Length]
        MOV     r0, #0                  ; flags for MPEGVideo/Audio_FullPackets
        MOV     r2, r11
        TEQ     r10, #StreamFlags_VideoPresent
        BNE     sendaudioblock

; drop thru to...

debug SETL {FALSE}

sendvideoblock
        DLine   "Video packet"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_FullPackets
        DLine   "Exiting video packet"
        CLRV
        EXIT

sendaudioblock
        DLine   "Audio packet"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_FullPackets
        DLine   "Exiting audio packet"
        CLRV
        EXIT

debug SETL {FALSE}

; **************************************************************************
;
;       GetPacketDescriptor - Get a packet descriptor from free list, or RMA if that fails
;
; in:   r12 -> module workspace
;
; out:  r0 -> packet descriptor
;

GetPacketDescriptor Entry "r1"
        MOV     r1, pc
        ORR     lr, r1, #I_bit                  ; disable IRQs

        LDR     r0, FreePacketListHeadPtr
        TEQ     r0, #0
        BEQ     %FT10                           ; [no free packet descriptors]

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, FreePacketListHeadPtr       ; update FreePacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, FreePacketListTailPtr       ; then zero FreePacketListTailPtr

        TEQP    r1, #0                          ; restore IRQs
05
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
; now fill in some of the fields
        ADRL    r1, FreePackets
        STR     r1, [r0, #PacketDescriptor_FreeRoutine]
        STR     wp, [r0, #PacketDescriptor_FreeWorkspace]
        CLRV
        EXIT

10
        TEQP    r1, #0                          ; restore IRQ state
        Push    "r2, r3"
        MOV     r3, #PacketDescriptorSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVC   r0, r2
        Pull    "r2, r3"
        BVC     %BT05
        EXIT

 ] ; {FALSE}

; **************************************************************************
;
;       CtrlInfo_Code - Code to handle CtrlInfo command
;
; in:   -
; out:  -

CtrlInfo_Code Entry
        LDR     wp, [r12]
        ADR     r1, ControlStreamHandle

        DLINE   "Bytes received = ", cc

        LDR     r0, [r1, #CSH_DataReceived]
        BL      DecimalOutput
        DLINE   ""
        MOV     r2, r0

        DLINE   "In time ", cc
        LDR     r0, [r1, #CSH_LastTime]
        LDR     r3, [r1, #CSH_StartTime]
        SUB     r0, r0, r3
        BL      DecimalOutput
        DLINE   " cs"

        TEQ     r0, #0
        BEQ     %FT10

; we want to perform (bytes*100)/cs, but bytes*100 might overflow 32 bits
; so we do bytes/cs then multiply fractional part by 100 and add on

        DivRem  r3, r2, r0, r4
        MOV     r4, #100
        MUL     r2, r4, r2              ; multiply fractional part by 100
        DivRem  r5, r2, r0, r14         ; and divide by denominator
        Push    "r0"                    ; save amount of time for later
        MLA     r0, r3, r4, r5          ; add on original value*100
        DLINE   "Average data rate = ", cc
        BL      DecimalOutput
        DLINE   " bytes/second"
        Pull    "r0"
 [ DataRateStats
; r0 = number of centiseconds since starting

        LDR     lr, =DataCountPeriod*100
        DivRem  r2, r0, lr, r3          ; r2 = number of periods since starting
        CMP     r2, #DataCountArraySize ; if filled array
        MOVHI   r2, #DataCountArraySize ; then pretend we just filled it
        ADD     r3, r1, #CSH_DataCounts
        MOV     r4, #0                  ; period number
05
        TEQ     r4, r2                  ; if no more periods
        BEQ     %FT10                   ; then finished
        DLINE   "In period ", cc
        MOV     r0, r4
        BL      DecimalOutput
        DLINE   ", average data rate was ", cc
        LDR     r5, [r3], #4
        LDR     lr, =DataCountPeriod
        DivRem  r0, r5, lr, r6          ; convert from bytes/minute to bytes/second
        BL      DecimalOutput
        DLINE   " bytes/second"
        ADD     r4, r4, #1
        B       %BT05
 ]
10
        CLRV
        EXIT

        LTORG

; **************************************************************************
;
;       DecimalOutput - Decimal output routine
;
; in:   r0 = value to be output
; out:  -

DecimalOutput Entry "r0-r2",16
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        SWI     XOS_Write0
        EXIT

 [ CaptureToDynArea
; **************************************************************************
;
;       SaveOutput_Code - Code to handle SaveOutput command
;
; in:   r0 -> command tail
; out:  -

SaveOutput_Code Entry
	LDR	wp, [r12]
	MOV	r1, r0		; point r1 at filename
  [ CircularBuffer
	MOV	r0, #open_write
	SWI	XOS_Find
	EXIT	VS

	MOV	r1, r0		; r1 = file handle
	LDR	r3, DynAreaTotal
	LDR	lr, =dyn_area_size
	CMP	r3, lr		; if more than one buffer's full then output from offset->end, then 0->offset, else just 0->offset
	BLS	%FT10
	LDR	r3, DynAreaOffset
	LDR	r2, DynAreaAddress
	ADD	r2, r2, r3	; start of area to save
	SUBS	r3, lr, r3	; size of offset->end
	MOVNE	r0, #OSGBPB_WriteAtPTR	; if non-zero, write to file
	SWINE	XOS_GBPB
10
	LDR	r3, DynAreaOffset
	LDR	r2, DynAreaAddress
	MOV	r0, #OSGBPB_WriteAtPTR
	SWI	XOS_GBPB

	MOV	r0, #0
	SWI	XOS_Find
  |
	MOV	r0, #OSFile_Save ; reason code
	MOV	r2, #0		; load
	MOV	r3, #0		; exec
	LDR	r4, DynAreaAddress
	LDR	r5, DynAreaOffset
	ADD	r5, r5, r4
	SWI	XOS_File
 ]
	EXIT

 ] ; CaptureToDynArea
 [ CreateDynArea

; **************************************************************************
;
;	create_area - Create dynamic area to copy EASI space buffers into before GBPBing

create_area	Entry	"r0-r8"

                LDR     r0, DynAreaNumber
                CMP	r0, #-1
                EXIT    NE					; area already exists, will be VC

		MOV	r0, #0					; reason code
		MOV	r1, #-1					; allocate area number
		LDR	r2, =dyn_area_size
		MOV	r3, #-1					; allocate base address
		MOV	r4, #1:SHL:7				; not draggable
		MOV	r5, r2					; max same as current size
		MOV	r6, #0					; no handler routine
		MOV	r7, #0
		ADR	r8, dyn_area_name
		SWI	XOS_DynamicArea
                STRVS   r0, [sp]				; stash error pointer if required
		BVS	%10

		STR	r1, DynAreaNumber			; stash some stuff away
		STR	r3, DynAreaAddress
10
		EXIT

dyn_area_name	=	"MPEGCtFile DVB support", 0
		ALIGN

; **************************************************************************
;
;	remove_area - Remove the dynamic area

remove_area	Entry	"r0-r1"

		LDR	r1, DynAreaNumber
		CMP	r1, #-1
		EXITS	EQ					; exit preserving flags

		MOV	r0, #1					; reason code
		SWI	XOS_DynamicArea
		MOV	r0, #-1
		STR	r0, DynAreaNumber			; cancel indication of having an area
		EXITS						; exit preserving everything

 ]
; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END
