; > Module
; Source for MPEG Audio Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 03-Jun-94  TMD  0.01          Started work
; 24-Jun-94  TMD  0.03          Started amending to use whole packets (inc. hdrs), so we can get the PTS's
; 20-Jul-94  TMD  0.10          Release for Malcolm's trip
; 22-Jul-94  TMD  0.11          Added synchronisation to stream rate code
; 22-Jul-94  TMD  0.12          Added nolipsync option
; 29-Jul-94  TMD  0.13          Modified CloseStream behaviour to wait until empty unless paused, in which case junk data
; 05-Aug-94  TMD  0.14          Added option for better audio recovery on synchronisation errors
; 09-Aug-94  TMD  0.15          Set StreamClosing to 1 after all data sent on a close.
; 12-Aug-94  TMD  0.16          Don't do MPEGVideo_SetSCR if paused or in slo-mo
; 17-Aug-94  TMD  0.17          Slo-mo sets PLAY=1 (so doesn't jam up if you go pause->slo-mo)
;                               Also Pause sets MUTE=1 (just for completeness)
; 22-Aug-94  TMD  0.18          (Conditionally) enable IRQs inside TickerV stuffing code.
; 26-Aug-94  TMD  0.19          Remove erroneous setting of AudioIRQBodge to false in GetAll.
; 26-Aug-94  TMD  0.20          Only enable IRQs in TickerV if not doing AudioIRQBodge.
; 31-Aug-94  TMD  0.21          (Conditionally) call SetSCR directly, not via SWI.
; 02-Sep-94  TMD  0.22          (Conditionally) if playing only audio, do pre-fill before starting.
; 07-Sep-94  TMD  0.23          Avoid re-entry to TickerV code if stuffing directly in TickerV.
; 08-Sep-94  TMD  0.24          Pass flags to MPEGControl_Play.
; 19-Sep-94  TMD  0.25          Reprogram PCM_DIV when doing slow motion.
; 26-Sep-94  TMD  0.26          (Conditionally) check MPEG sample rate
; 29-Sep-94  TMD  0.27          Use thresholds of 8K, 24K; not 2K, 6K
; 30-Sep-94  TMD  0.28          Ensure pre-fill amount is at least mid point of thresholds
; 11-Oct-94  TMD  0.29          Put in (conditional) workaround for premature SCR 'Stars' problem
; 07-Nov-94  TMD  0.30          Put in code to record speed changes while pre-buffering
; 12-Dec-94  TMD  0.31          Fix overwriting of error pointer in FindPoduleNumber
; 14-Dec-94  TMD  0.32          Create new variant for Wild Vision Movie Magic card
; 15-Dec-94  TMD  0.33          Prevented possible weird settings of PCM_DIV when pre-buffering
; 15-Feb-95  TMD  0.34          (Conditionally) skip data up to synchronisation word at start
; 17-Feb-95  TMD  0.35          Change product-type matching code for recognition of podule:
;                                No longer match &0000 in any version
;                                Do allow &00F9 in all versions (as well as &00FF in non-'M' versions)
; 06-Mar-95  TMD  0.36          Added MPEGAudio_ResetStream
; 23-Mar-95  TMD  0.37          Attempt to (conditionally) work-around the pause bug in the TMXC part.
; 29-Mar-95  TMD  0.38          Attempt to find out what causes occasional stiff on frequent use of pause.
; 20-Apr-95  TMD  0.39          Only delay pauses in 'P' version if we're using a TMXC part.
; 21-Apr-95  TMD  0.40          Change from soft copy of play register approach to pending pause approach.
; 03-May-95  TMD  0.41          Add detection of STB2 product type - on this product we need to:-
;                                Update the Control Register on OpenStream to select AV110 IIS sound, and
;                                to reselect VIDC20 IIS sound on CloseStream.
; 05-May-95  TMD  0.42          Correct switching to VIDC20 sound on CloseStream.
; 24-May-95  TMD  0.43          Added MPEGAudio_MuteSound
; 12-Jul-95  MT   0.44          Added support (controlled by new HandleNoDRAM option) for running the
;				 AV110 without external DRAM (to save money), and using FIQs instead of
;				 IRQs - courtesy of a new version of the MPEG GAL/PAL chip - to service
;				 BALE at low latency.  This necessitates running the AV110 in stream
;				 rather than packet mode, and working out the timing of PTS delivery by
;				 software.  Also cured a minor bug where CloseStream could chop off the
;				 last bit of sound by switching back to VIDC20Sound before the AV110 (with
;				 DRAM fitted) has actually finished decoding a stream.
; 13-Jul-95  MT   0.45		Removed a diagnostic on MuteSound, accidentally left in; fixed
;				 ReleaseFIQVector to re-enable FIQ/IRQ properly; removed counting of
;				 PTSLate events (now impossible).
; 24-Jul-95  MT   0.46		When SendNewPacketIfNecessary can't find a frame start for a PTS - usually
;				 because it hasn't received all of the packet yet - it just forgets about
;				 it rather than waiting for more data, since when all system buffers all
;				 already in use, waiting would cause lock-up (no buffers available to
;				 supply more data in).  Diags report this as a "missed" PTS.  Also fixed a
;				 case where FIQs and IRQs were left disabled for longer than intended.
;				 Added some more diagnostics for *audioinfo: the figures add up now.
; 11-Aug-95  TMD  0.47		Added MPEGAudio_SoundVolume
; 23-Aug-95  TMD  0.48		Added support for starting paused
; 13-Sep-95  TMD  0.49		If not doing stream synchronisation, only use 4K preload size
; 19-Sep-95  TMD  0.50		Added PauseAfterResetStream option
; 20-Sep-95  TMD  0.51		Fix bug in ResetStream for FIQ-based stuffing (didn't reclaim FIQ vector)
; 21-Sep-95  TMD  0.52		Version for Generic CD Extension ROM release, with PauseAfterResetStream
;				 set to false (cos it hasn't been tested)
; 10-Oct-95  TMD  0.53		Add option to check system variable MPEG$PoduleNumber for override on podule number.
;				Also turn PauseAfterResetStream back on again.
; 25-Oct-95  TMD  0.54		Zero SKIP and REPEAT registers on initialisation, to prevent garbled play on first stream
;				 in no-DRAM configuration.
; 20-Nov-95  TMD  0.55		Check StreamFlags_StartPaused bit passed to ResetStream.
; 22-Jan-96  TMD  0.56		Fix failure to set up AV110 address in DoStreamSync, which caused STB2's to never skip
;				 or repeat audio frames to synchronise to the stream rate.
; 07-Mar-96  TMD  0.57		Added MPEGAudio_Stats


        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

                        ^       0, wp
PacketLength            #       4
IRQCounts               #       4       ; number of IRQs
LastIntStatus           #       4       ; last interrupt status
PTSInCount              #       4       ; count of PTS's coming in to us
PTSOutCount             #       4       ; count of PTS IRQs generated by AV110
 [ HandleNoDRAM
PTSMissCount		#	4	; count of PTSs not queued because partial packet
PTSDropCount		#	4	; count of PTSs not queued because Q was full
PTSDuffCount		#	4	; count of PTSs not matched to frame header
PTSOVRNCount		#	4	; count of PTSs dropped because triggerPTS was late
PTSIGNPCount		#	4	; count of PTSs not sent because in pause
PTSIGNSCount		#	4	; count of PTSs not sent because in slowmo/prefill
PTSQinCount		#	4	; count of PTSs queued
PTSQoutCount		#	4	; count of PTSs dequeued
PTSDiscCount		#	4	; count of PTSs discarded on close/reset
PTSSentCount		#	4	; count of PTSs actually sent as SCRs
ThresholdChecks		#	4	; number of threshold checks performed
 ]

 [ UseWholePackets
LastPTS                 #       8       ; last PTS value
 ]
 [ UseBALE
StreamState             #       4       ; state-machine state
 ]

Podule_Base             #       4       ; address of base of podule
AV110_Base              #       4       ; base address of AV110
Fast_Audio_Data         #       4       ; address to poke data to

PoduleHeaderBuffer      #       16      ; used to read podule headers

ControlStreamHandle     #       4
StreamFlags             #       4       ; flags passed to OpenStream
OriginalStreamFlags     #       4       ; copy of flags passed to OpenStream, to reset to on ResetStream

IRQVectorClaimed        #       4       ; NZ => device vector claimed
 [ HandleNoDRAM
FIQVectorClaimed	#	4	; NZ => FIQs claimed for data transfer
 ]

PacketListHeadPtr       #       4       ; pointer to head of list of packet descriptors
PacketListTailPtr       #       4       ; pointer to tail of list

 [ :LNOT: UseBALE
Podule_StatusRegister   #       4       ; address of status register
 ]

CallBackRequested       #       4       ; whether a callback is outstanding
OutstandingDataSize     #       4       ; length in bytes of data we can stuff it before
                                        ; we need to wait for an IRQ

InterruptMask           #       4       ; mask of enabled interrupts

AmountSent              #       4       ; amount of data sent (-1 => finished with pre-fill)
StreamClosing           #       4       ; 0 normally, 1 => stream is in the process of closing
ResyncDelay             #       4       ; number of cs ticks until we attempt resyncing again
Skips                   #       4       ; number of skipped frames
Repeats                 #       4       ; number of repeated frames
TotalReceived           #       4       ; number of bytes received
SpeedSetting            #       4       ; 0 => paused, 1 => normal, 2..8 => slow-motion, top-bit-set => pre-buffering
PCM_DIV_Copy            #       4       ; what would be in PCM_DIV if we were playing at normal speed
SampleRate              #       4       ; MPEG sample rate, 0=>44.1, 1=>48, 2=>32kHz
CardType                #       4       ; 1 => STB1 or RISC PC, 2 => STB2
SoundMuted              #       4       ; 0 => sound on, 1 => sound off (muted)
VolumeSetting		#	4	; 0 => muted, 1..256 = logarithmic volume value (256=0dB)
PreFillBufferSize	#	4	; size of prefill needed

 [ HandleNoDRAM
LocalBuffBase           #       4       ; ->buffer emulating non-fitted AV110 DRAM, or 0:DRAM
LocalBuffIn             #       4       ; offset in buffer of next byte to fill
LocalBuffFree           #       4       ; how many bytes currently free in buffer
LocalBuffOut            #       4       ; offset in buffer of next byte to empty (in FIQ code)
LocalBuffSize		*       32*1024	; 32KB for now (cf LWM/HWM sizes 8K..24K) MUST BE 2^K
FIQTransferP            #       4       ; ->count of bytes moved into AV110 under FIQ, or 0
SCRCount_Max		*	64	; hold at most this many pending SCR (PTS) values
SCRIndex_Mask		*	63	; mask for speedy wrap-round in table
SCRIn			#	4	; index of next free slot
SCROut			#	4	; index of next slot to deliver as SCR
SCRCount		#	4	; count of how many PTSs in table (i.e used count)
			#	4	; take up the spare byte slot for alignment
SCRTable		#	SCRCount_Max*2*4 ; the table itself (2 words/entry)
 ]

 [ CallSetSCRDirectly
SetSCRWorkspace         #       4       ; workspace value to call SetSCR routine with
SetSCRRoutine           #       4       ; address of SetSCR routine in MPEGVideo module
 ]

 [ VetSCRValues
VetSCRState             #       4       ; 0 => awaiting 1st SCR, 1 => last SCR was good, 2 => last SCR was bad
GoodSCROffset           #       4       ; SCR-<monotonic time>*900, for the last good SCR value
BadSCROffset            #       4       ; ditto, for the last bad SCR value
BadSCRCount             #       4       ; count of the number of bad SCR values
 ]

 [ DelayPauseCommands
NotTMXCFlag             #       4       ; 0 => delay pauses (since we're on TMXC), 1 => don't delay pauses
NotPendingPause         #       4       ; 0 => pending pause, 1 => no pending pause
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

 [ CollectDebugStats
DebugArraySize          *       8192

DebugArrayFree          #       4
DebugArrayPtr           #       4
DebugArray              #       DebugArraySize * 4         ; one word per centisecond
 ]

Module_WorkspaceSize * :INDEX: @

AudioFIFOStuffAmount    *       1024

 [ UseBALE
AudioFIFOThreshold      *       8*1024          ; must be 8K free when get RDY IRQ
AV110_Capacity          *       &6666 * 4       ; max number of bytes in AV110 FIFO
BALE_LIM                *       (AV110_Capacity - AudioFIFOThreshold) / 4

; Values in StreamState

                           ^ 0

StreamState_WaitingForRDY  # 1  ; waiting for CL450 RDY IRQ
                                ; (may or may not have data)

StreamState_WaitingForData # 1  ; waiting for data
 ]

;AudioBufferBase         *       6*1024
;AudioBufferHalfRange    *       2*1024
AudioBufferBase         *       16*1024
AudioBufferHalfRange    *       8*1024
AudioBufferLowWaterMark *       (AudioBufferBase-AudioBufferHalfRange)/4
AudioBufferHighWaterMark *      (AudioBufferBase+AudioBufferHalfRange)/4

PreFillMinimumSize	*	4*1024
 [ AudioBufferBase < PreFillMinimumSize
PreFillStreamingSize	*	PreFillMinimumSize
 |
PreFillStreamingSize	*	AudioBufferBase
 ]

 [ VetSCRValues
SCRAcceptableRange      *       &6000           ; about a 1/4 of a second, in 90kHz units
 ]

 [ HandleNoDRAM
AV110_FIQ_BIT   *       podule_FIQ_bit  ; bit in FIQ mask for AV110 INT -> fiq

AV110_FIFO_SIZE *       256             ; capacity of AV110's internal fifo
BALE_VALUE      *       208             ; "buffer almost empty" level in AV110 fifo
MAX_BALE_NODRAM *       244             ; Max value for BALE when no DRAM

FIQSpaceStart   *       &1C
FIQStackEnd     *       &80             ; allocate tiny FIQ stack: &24..&7F
 ]

; Card types

                ^       1
CardType_STB1   #       1
CardType_STB2   #       1

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

        GBLL    debug
debug   SETL    {FALSE}

        GBLL    FIQDebug
FIQDebug SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   $string, $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, $string, $cc, $routine
 ]
        MEND

; Debugging statistics macros

        MACRO
        OutputDebug $flag, $amount, $cond
 [ $flag
        B$cond  %FT10
        B       %FT20
10
        Push    "r0, lr"
        MOV     r0, $amount
        BL      OutputDebugRoutine
        Pull    "r0, lr"
20
 ]
        MEND

        MACRO
        OutputSentCount $amount, $cond
        OutputDebug Debug_SentCount, $amount, $cond
        MEND

        MACRO
        OutputFullness $amount, $cond
        OutputDebug Debug_Fullness, $amount, $cond
        MEND


; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGAudioSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "MPEGAudio", 0

Mod_HelpStr
        =       "MPEGAudio", TAB, "0.57 (07 Mar 1996)", 0
        ALIGN

Mod_SWITable
        =       "MPEGAudio", 0
        =       "OpenStream", 0
        =       "FullPackets", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
        =       "SkipFrame", 0
        =       "RepeatFrame", 0
        =       "ResetStream", 0
        =       "MuteSound", 0
	=	"SoundVolume", 0
	=	"Stats", 0
        =       0

Mod_HC_Table
        Command AudioInfo, 0, 0
        =       0

AudioInfo_Help
        =       "*AudioInfo outputs debugging info.", CR
AudioInfo_Syntax
        =       "Syntax: *AudioInfo", 0
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?

; DREG	r2, "MPEGAudio initialising, ws="
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        BL      FindPoduleNumber
        EXIT    VS

        MOV     r0, #0
        STR     r0, IRQVectorClaimed
        STR     r0, InterruptMask
        STR     r0, PacketListHeadPtr
        STR     r0, PacketListTailPtr
        STR     r0, PTSInCount
        STR     r0, PTSOutCount
 [ HandleNoDRAM
	STR	r0, FIQVectorClaimed
	STR	r0, PTSMissCount
        STR     r0, PTSDropCount
        STR     r0, PTSDuffCount
	STR	r0, PTSOVRNCount
	STR	r0, PTSIGNPCount
	STR	r0, PTSIGNSCount
	STR	r0, PTSQinCount
	STR	r0, PTSQoutCount
	STR	r0, PTSDiscCount
	STR	r0, SCRCount				; prevent spurious Disc counts in ClearFIQVars
	STR	r0, PTSSentCount
 ]
 [ CollectDebugStats
        STR     r0, DebugArrayFree
 ]
        STR     r0, CallBackRequested
        STR     r0, OutstandingDataSize
        STR     r0, ResyncDelay
 [ HandleNoDRAM
        STR     r0, LocalBuffBase       ; buffer alloc'ed only if & when we find it's needed
 ]

        MOV     r0, #3			; "unknown" value
        STR     r0, SampleRate

 [ CollectDebugStats
        MOV     r0, #-1
        ADRL    r1, DebugArray
        MOV     r2, #DebugArraySize     ; size in words
10
        STR     r0, [r1], #4
        SUBS    r2, r2, #1
        BNE     %BT10
 ]

        MOV     r0, #1
        STR     r0, StreamClosing       ; indicate nothing happening yet

        MOV     r0, #Podule_ReadInfo_EASILogical
        ADRL    r1, Podule_Base
        MOV     r2, #4
        SWI     XPodule_ReadInfo
 [ CheckPoduleVariable
	MOVVS	r0, r3, LSL #24				; if get error, then do it by hand, as it might be a
	ORRVS	r0, r0, #&88000000			; podule without an EPROM
	STRVS	r0, Podule_Base
 |
        EXIT    VS
 ]

        LDR     r0, Podule_Base
        ADD     r1, r0, #Offset_Fast_Audio_Data
        STR     r1, Fast_Audio_Data
 [ :LNOT: UseBALE
        ADD     r1, r0, #Offset_Podule_ControlStatus
        STR     r1, Podule_StatusRegister
 ]
        ADD     r1, r0, #Offset_AV110_Base
        STR     r1, AV110_Base


 [ HandleNoDRAM

; MT, 29-Jun-95: check for presence of external DRAM; if not there, we assume
; that a FIQ is available for (low-latency) refill of the AV110's small (256
; byte) internal buffer.  We must in this case do our own longer-term buffering
; in ARM's memory (using say 32KB in the first instance), to cope with
; system-level latency in the supply of audio data.  All the existing
; mechanisms for data transfer and flow control should still work, but we have
; to adapt their implementation to use our local buffer and associated flags
; rather than using AV110 registers.  Note: This is all conditional on not
; using BALE.  If UseBALE is set then the code will only sensibly work with
; external DRAM on the AV110 anyway.  The test for using DRAM or not is done at
; run-time not assembly-time, to preserve flexibility (e.g. it almost certainly
; won't work if the AV110 actually has DRAM but we assume it hasn't!) and to
; minimise the variability in software configuration.

        LDRB    r2, [r1, #AV110_DRAM_EXT]
        CMP     r2, #0
        BNE     %FT20                   ; leave LocalBuffBase 0 if ext DRAM

        ; else go claim our own buffer - give up if we can't get the RAM
        MOV     r0, #ModHandReason_Claim
        MOV     r3, #LocalBuffSize
        SWI     XOS_Module
        EXIT    VS
        STR     r2, LocalBuffBase
	BL	ClearFIQVars

  [ {FALSE} ; debugging
        ; Clear out the buffer to 0, for debugging purposes
        ADD     r1, r2, r1
15      STR     r0, [r1, #-4]!
        CMP     r1, r2
        BNE     %BT15
  ]
 ]

20

 [ CallSetSCRDirectly
        MOV     r0, #ReadParametersReason_SetSCR
        SWI     XMPEGVideo_ReadParameters
        EXIT    VS
        STR     r1, SetSCRRoutine               ; save workspace and routine pointers
        STR     r2, SetSCRWorkspace
 ]

        BL      InitAV110
        EXIT    VS

        BL      ClaimIRQVector
        EXIT    VS

        EXIT

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry "r1,r2"
        LDR     wp, [r12]

; DREG	r0, "MPEGAudio dying..."

 [ HandleNoDRAM
        LDR     r2, LocalBuffBase
        CMP     r2, #0
        BEQ     %FT10

	BL	ClearFIQVars		; force all FIQ activity to cease
	BL	ReleaseFIQVector	; for in case streaming was in progress (?)

10
 ]
        BL      ReleaseIRQVector

 [ HandleNoDRAM
	CMP	r2, #0
	BEQ	%FT20
        ; Using local buffering and AV110 fill via FIQs
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module		; release buffer space
        MOV	r0, #0
        STR	r0, LocalBuffBase	; and clean up for safety
20
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #MPEGAudioSWICheckValue - MPEGAudioSWI_Base
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
        B       OpenStream      ; open stream
        B       FullPackets     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
        B       SkipFrame       ; skip audio frame
        B       RepeatFrame     ; repeat audio frame
        B       ResetStream     ; discard data and reset
        B       MuteSound       ; mute/unmute sound
	B	SoundVolume	; set/read volume
	B	Stats		; return statistics

NoSuchSWI
        ADR     r0, NoSuchSWIError
        SETV
        MOV     pc, lr

NoSuchSWIError
        &       0
        =       "No such MPEGAudio SWI", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control stream handle (currently used to store address to
;             return empty packets to)
;       r2 -> Audio parameters structure
;
; out:  r0 = Audio stream handle
;

OpenStream Entry "r1,r2, r11"
        STR     r0, OriginalStreamFlags
        STR     r0, StreamFlags
        STR     r1, ControlStreamHandle

        LDR     r11, AV110_Base

	TST	r0, #StreamFlags_SyncToStream
	MOVNE	lr, #PreFillStreamingSize
	MOVEQ	lr, #PreFillMinimumSize
	STR	lr, PreFillBufferSize

	TST	r0, #StreamFlags_StartPaused
        MOVEQ   r0, #&80000001                          ; would be playing, if we weren't pre-buffering
	MOVNE	r0, #&80000000				; enter pause mode after pre-buffering
        STR     r0, SpeedSetting

        MOV     r0, #0
        STR     r0, AmountSent                          ; wait for prefill, then indicate ready
        STR     r0, StreamClosing
        STR     r0, ResyncDelay
        STR     r0, Skips
        STR     r0, Repeats
        STR     r0, TotalReceived
        STR     r0, SoundMuted
 [ HandleNoDRAM
	STR	r0, ThresholdChecks
 ]
 [ CollectDebugStats
        STR     r0, DebugArrayFree
 ]
 [ VetSCRValues
        STR     r0, VetSCRState                         ; indicate awaiting first SCR
        STR     r0, BadSCRCount                         ; no bad'uns yet
 ]
        MOV     r0, #3                                  ; 'unknown'
        STR     r0, SampleRate

	MOV	r0, #256		; full volume
	STR	r0, VolumeSetting

 [ HandleNoDRAM
	LDR	r0, LocalBuffBase	; if we're running DRAM-less
	CMP	r0, #0			; ....
	BLNE	ClaimFIQVector		; go set up to use FIQs for data traffic
 ]
        BL      SelectAV110Sound

        MOV     r0, r12
        CLRV
        EXIT

; **************************************************************************
;
;       Play - Start going
;
; in:   r0 = flags
;       r1 = Audio stream handle
;
; out:  -
;

Play	Entry "r0,r2, r11"
        LDR     r11, AV110_Base

        LDR     r0, SpeedSetting
        BIC     r0, r0, #&80000000                      ; knock off pre-buffering bit
        STR     r0, SpeedSetting
; DREG r0, "Play called, speed "
        MOV     r2, r0
        BL      SetSpeed

 [ CollectDebugStats
        ADRL    r0, DebugArray
        STR     r0, DebugArrayPtr
        LDR     r0, =DebugArraySize
        STR     r0, DebugArrayFree
 ]
        CLRV
        EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of MPEG playing
;
; in:   r0 = flags
;       r1 = Audio stream handle
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0,r2,r3, r11"
        LDR     r11, AV110_Base

        LDR     lr, SpeedSetting
        TST     lr, #&80000000                          ; if pre-buffering
        ORRNE   r2, r2, #&80000000                      ; then still pre-buffering, but select correct speed afterwards

        MOVS    lr, r2
        MOVEQ   lr, #1                                  ; if paused use normal speed (irrelevant)
        MOVMI   lr, #1                                  ; if pre-buffering use normal speed

        LDR     r0, PCM_DIV_Copy
        MUL     r0, lr, r0                              ; multiple normal speed divider value by speed
        CMP     r0, #32                                 ; if more than 32
        MOVHI   r0, #32                                 ; then use 32

 [ DelayPauseCommands
        LDR     lr, NotTMXCFlag
        ORRS    lr, lr, r2                              ; zero if pausing and need to delay pauses
        STR     lr, NotPendingPause                     ; either signal or cancel pending pause
        BEQ     %FT99                                   ; and if signalled, then exit now
 ]
	LDR	lr, VolumeSetting			; get programmed sound volume
	TEQ	lr, #0					; if zero
	MOVEQ	lr, #1					; then force mute
	LDRNE	lr, SoundMuted				; else check if user-muted

        CMP     r2, #1					; if playing then use value we've put in lr
        MOVNE   lr, #1                                  ; else pause or slo-mo, so mute
        STREQB  r0, [r11, #AV110_PCM_DIV]               ; if unmuting, set rate before
        STRB    lr, [r11, #AV110_MUTE]
        BLNE    WaitOneFrame                            ; wait for at least a frame time to let mute take effect
        STRNEB  r0, [r11, #AV110_PCM_DIV]               ; if muting, set rate after
        MOVLT   r3, #0                                  ; paused (or pre-buffering) so non-play
        MOVGE   r3, #1                                  ; normal or slo-mo, so play
        STRB    r3, [r11, #AV110_PLAY]
        STR     r2, SpeedSetting
 [ VetSCRValues
        MOVNE   lr, #0                                  ; if pause or slo-mo, reset vetting state
        STRNE   lr, VetSCRState                         ; until we receive 1st SCR after return to normal play
 ]
99
        CLRV
        EXIT

; Attempt to wait at least 1 frame time, by waiting for between 40 and 50 ms, since
; longest frame time is 36ms (1152/32000, i.e. layer II, 32 kHz).
; Must preserve all registers and flags

WaitOneFrame Entry "r0,r1"
        SWI     XOS_ReadMonotonicTime
        EXITS   VS
        ADD     r1, r0, #5
10
        SWI     XOS_ReadMonotonicTime
        EXITS   VS
        CMP     r0, r1
        BMI     %BT10
        EXITS

 [ DelayPauseCommands
; **************************************************************************
;
;       ExecutePendingPause - Execute any pending pause
;
; in:   r11 -> AV110
; out:  -
;

ExecutePendingPause Entry
        MOV     lr, pc
        ORR     lr, lr, #I_bit                          ; disable IRQs round this bit
        TEQP    lr, #0

        LDR     lr, NotPendingPause
        TEQ     lr, #0
        EXITS   NE
        MOV     lr, #1
        STR     lr, NotPendingPause
        STRB    lr, [r11, #AV110_MUTE]
        STRB    lr, [r11, #AV110_PCM_DIV]
        MOV     lr, #0
        STRB    lr, [r11, #AV110_PLAY]
        EXITS
 ]

; **************************************************************************
;
;       MuteSound - Mute/unmute sound
;
; in:   r0 = flags
;         bit 0 = 1   => sound off
;               = 0   => sound on
;         bits 1..31 reserved - should be zero
;       r1 = audio stream handle
;
; out:  -
;

MuteSound Entry "r0"
        LDR     r11, AV110_Base
        ANDS    r0, r0, #1
; DREG r0, "MuteSound called, r0 = "
        STR     r0, SoundMuted
        STRNEB  r0, [r11, #AV110_MUTE]                  ; muting, so do it now
        EXIT    NE

; unmuting, so need to see if we should be silent anyway

        MOV     lr, pc
        ORR     lr, lr, #I_bit                          ; disable IRQs, cos SpeedSetting can
        TEQP    lr, #0                                  ; happen in background due to FullBuffers -> Play

	LDR	lr, VolumeSetting			; if sound volume set to zero (mute)
	TEQ	lr, #0
	BEQ	%FT10					; then don't unmute here

        LDR     lr, SpeedSetting
        EORS    lr, lr, #1                              ; if playing, then lr=0 now
        STREQB  lr, [r11, #AV110_MUTE]                  ; and unmute
; BNE %FT09
; DREG lr, "MuteSound setting Mute reg to "
;09
10
        EXITS

; **************************************************************************
;
;       SoundVolume - Read/set sound volume
;
; in:   r0 = flags (must be zero)
;       r1 = audio stream handle
;	r2 = -1 => read current volume
;	r2 = 0..256 => set current volume
;
; out:  r2 = old setting of sound volume
;
; Volume settings are specified in units of 0.5adB, where an adB is
; almost but not quite entirely equal to a standard dB.  A change in
; volume by 6adB is *exactly* equal to a factor of 2, whereas in the
; standard scale a factor of 2 is represented as 20*log10(2), or
; 6.02059991...., i.e. 1adB = 1.00343331...dB.  This adjustment is
; deliberate, for more convenient representation in binary arithmetic.
; So a volume change of 12 units corresponds to an exact doubling or
; halving of the effective volume.
;
; Scale basis:
;
; The value 256 corresponds to a nominal 0dB volume setting ("normal
; full volume"), so 258 (if available) is 1adB louder (+1adB) and 254 is
; 1adB softer (-1adB).  Often, the hardware will not permit volume
; settings above 0dB.
;
; Special value:
;
; the volume setting 0 is special, in that it means not -128adB but
; "off" or "muted".
;
; Mapping to real hardware:
;
; Commonly, real hardware gain adjustments are only possible in coarser
; steps, say 1dB, 1.5dB or 2dB.  In this case, the software interface
; must map the requested volume setting onto the nearest available
; hardware setting.  Where the range of the hardware volume control
; available is less than -127.5dB..0dB, all settings between 1 and the
; minimum meaningful setting (setting equal or close to actual hardware
; minimum volume) map to the minimum volume, and never to "muted".  All
; setting requests with values above that which can be represented by
; the hardware are mapped to "maximum volume".
;
; [[[ So for the AV110, which has a range of -126..0dB in 2dB steps, the
; mapping of volume settings to control setting is:
;
;     Volume setting    Nom.Gain(adB)	AV110 setting  AV110 gain (dB)
;        >256		 >0		0		0
; 	256 		 0.0		0		0
; 	255		-0.5		0		0
; 	254		-1.0		0		0
; 	253		-1.5		1		-2
; 	252		-2.0		1		-2
; 	251		-2.5		1		-2
; 	...		...		...		...
; 	10		-123.0		61		-122
; 	9		-123.5		62		-124
; 	8		-124.0		62		-124
; 	7		-124.5		62		-124
; 	6		-125.0		62		-124
; 	5		-125.5		63		-126
; 	4		-126.0		63		-126
; 	3		-126.5		63		-126
; 	2		-127.0		63		-126
; 	1		-127.5		63		-126
; 	0		OFF		MUTE		MUTE
;
; ]]]
;
; Notes:
;
; This volume control interface is logarithmic in its basis.  Any
; software layers above it which use linear volume representations must
; therefore perform the mapping themselves before calling
; MPEGControl_Volume.

SoundVolume Entry "r0"
	LDR	r11, AV110_Base
	MOVS	r0, r2			; copy setting to r0, setting N if negative (ie just reading)
	LDR	r2, VolumeSetting
	EXIT	MI			; if just reading, we're done

        MOV     lr, pc
        ORR     lr, lr, #I_bit		; disable IRQs, cos SpeedSetting can
        TEQP    lr, #0			; happen in background due to FullBuffers -> Play

	CMP	r0, #256		; limit to maximum volume
	MOVHI	r0, #256
	STR	r0, VolumeSetting	; and store this

	LDR	lr, =257
	SUB	lr, lr, r0		; 257 - x
	MOV	lr, lr, LSR #2		; (257 - x) >> 2
	CMP	lr, #63			; check for maximum attenuation
	MOVHI	lr, #63			; and limit it

	STRB	lr, [r11, #AV110_ATTEN_L]
	STRB	lr, [r11, #AV110_ATTEN_R]

; now work out what MUTE register should contain

	MOV	lr, #1			; assume MUTE initially

	TEQ	r0, #0			; if volume=0 then definitely MUTE
	BEQ	%FT10

	LDR	r0, SoundMuted		; if sound muted then definitely MUTE
	TEQ	r0, #0

	LDREQ	r0, SpeedSetting
	TEQEQ	r0, #1
	MOVEQ	lr, #0
10
	STRB	lr, [r11, #AV110_MUTE]	; store to mute register
	EXITS				; exit restoring IRQ state

; **************************************************************************
;
;       SkipFrame - Skip an audio frame
;
; in:   r0 = flags
;
; out:  -

SkipFrame Entry "r11"
        LDR     r11, AV110_Base
        MOV     lr, #1
        STRB    lr, [r11, #AV110_SKIP]
        LDR     lr, Skips
        ADD     lr, lr, #1
        STR     lr, Skips
        CLRV
        EXIT

; **************************************************************************
;
;       RepeatFrame - Repeat an audio frame
;
; in:   r0 = flags
;
; out:  -

RepeatFrame Entry "r11"
        LDR     r11, AV110_Base
        MOV     lr, #1
        STRB    lr, [r11, #AV110_REPEAT]
        LDR     lr, Repeats
        ADD     lr, lr, #1
        STR     lr, Repeats
        CLRV
        EXIT

; **************************************************************************
;
;       FullPackets - Here's some more data
;
; in:   r0 = flags
;       r1 = Audio stream handle
;       r2 -> one or more linked bitstream packets

debug SETL {FALSE}

FullPackets Entry "r0-r2,r11"
 [ debug
        LDR     r0, [r2, #PacketDescriptor_Length]
        CMP     r0, #0
        BGE     %FT05

; negative length packet - do debug stuff

        DREG    r0, "Packet length="
        MOV     r0, #&03500000
        LDR     r1, =&40800080
        STR     r1, [r0]

        MOV     pc, #0
05
 ]

debug SETL {FALSE}

        MOV     r0, pc
        Push    "r0"
        ORR     lr, r0, #I_bit
        TEQP    lr, #0                                  ; disable IRQs round this bit

        LDR     r0, PacketListTailPtr
        TEQ     r0, #0                                  ; if nothing on list
        STREQ   r2, PacketListHeadPtr                   ; then point head at new packets
        STRNE   r2, [r0, #PacketDescriptor_Link]        ; else tail!link = packet
10
        LDR     r1, [r2, #PacketDescriptor_Length]
        LDR     r0, TotalReceived
        ADD     r0, r0, r1
        STR     r0, TotalReceived

        LDR     r0, [r2, #PacketDescriptor_Link]        ; go down list of packets to end
        TEQ     r0, #0
        MOVNE   r2, r0
        BNE     %BT10

        STR     r2, PacketListTailPtr                   ; store new tail pointer
 [ UseBALE
        LDR     r1, StreamState                         ; load up stream state, *before* restoring IRQ state
 ]
        Pull    "r0"
        TEQP    r0, #0                                  ; restore IRQ state

 [ UseBALE
        TEQ     r1, #StreamState_WaitingForRDY          ; if we were waiting for RDY
        BEQ	%FT90                                    ; then let IRQ send data

        BL      DoStuffWithData
90
 ]
        EXIT

; **************************************************************************
;
;       CloseStream - Close MPEG audio stream
;
; This call performs the following operations:
;  - If in pause mode, it delinks all full packets from the chain and frees them.
;  - If not in pause mode, then it waits for all data to have been sent
;    (it needs to drop into user mode for this to happen, so that callbacks go off (yuk!))
;
;  It is assumed that no more MPEGAudio_FullPackets calls will be
; made once this call has started (MPEGControl module should ensure this).
;
; in:   r0 = flags
;       r1 = Audio stream handle
;

CloseStream Entry "r0-r4, r11"
        LDR     r11, AV110_Base
 [ DelayPauseCommands
        BL      ExecutePendingPause
 ]
        LDRB    r0, [r11, #AV110_PLAY]
        TEQ     r0, #0
        BEQ     %FT50                                   ; [it was paused, so junk data]

; wait for data to empty

10
        TEQP    pc, #0
        NOP                                             ; allow callbacks
        SWI     OS_EnterOS

        LDR     r0, PacketListHeadPtr                   ; do we have any outstanding packets?
        CMP     r0, #0                                  ; V := 0
        BNE     %BT10                                   ; go round again if so

; BUG FIX 6-Jul-95, MT.  Also wait until the decoding buffer (either on the AV110's
; DRAM or in our own memory) has drained.  Without this, the end of sounds can be
; chopped off when the DACs are switched back to VIDC20 sound by the call below.
; Note that the AV110 has been known (in DRAM mode) to stop decoding and leave more
; than 1 frame's worth of data in its buffer once the feed to it stops, so the
; following code gives up waiting once the AV110 has reported empty, or the reported
; buffer level has remained constant for 50K consecutive enquiries.  50K calls on
; GetBufferFullness should take at least 50ms, and if the AV110 has read no data
; from its buffer in that time then it has probably decided to stop...


; DREG	r0, "Buffer queue empty, waiting for AV110.."
	BL	GetBufferFullness
	MOV	r3, r2
	MOV	r4, #0

20      BL      GetBufferFullness	; is the buffer not yet empty?
	CMP	r2, #0			;
	BEQ	%FT25			; all done if now 0
	CMP	r2, r3			; has the level gone down?
	MOVLT	r3, r2			; if so, record new lower level
	MOVLT	r4, #0			;        and reset counter
	ADDGE	r4, r4, #1		; else count up
	CMP	r4, #50*1024		; if we've seen the same value for 50K loops
	BGE	%FT25			; then quit
	B	%BT20			; else go round again

25
; DREG r2, "Finishing with bufferfullness "
        MOV     r0, #1
        STR     r0, StreamClosing
        B       %FT90

; we're paused, so mark stream as closing, and free all packets

50
        MOV     r0, #1
        STR     r0, StreamClosing
60
        LDR     r0, PacketListHeadPtr
        CMP     r0, #0                          ; V := 0
        BLNE    FreePacket
        BNE     %BT60

90
 [ HandleNoDRAM
	LDR	r0, LocalBuffBase
	CMP	r0, #0
	LDRNE	lr, SCRCount
	STRNE	lr, PTSDiscCount
	BLNE	ReleaseFIQVector
 ]
        BL      SelectVIDC20SoundIfNecessary
        EXIT

; **************************************************************************
;
;       FindPoduleNumber
;
; in:   -
;
; out:  r3 = podule number, if VC, otherwise corrupted
;       All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
 [ CheckPoduleVariable
	Push	"r3,r4"
	ADR	r0, PoduleVariableName
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	Pull	"r3,r4"
	BVS	%FT05

	MOV	r0, #0
	STRB	r0, [r1, r2]			; terminate string

	Push	"r1"
	SWI	XPodule_ReturnNumber
	Pull	"r1"
	BVS	%FT90

	SUB	r2, r0, #1			; maximum podule number
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	BVS	%FT05

	MOV	r3, r2				; copy value into r3
	MOV	r0, #CardType_STB1
	STR	r0, CardType
	EXIT

PoduleVariableName
	=	"MPEG$PoduleNumber", 0
	ALIGN

05
 ]
        SWI     XPodule_ReturnNumber
        BVS     %FT90
        SUB     r3, r0, #1              ; r6 = max podule number
        ADR     r2, PoduleHeaderBuffer
10
        SWI     XPodule_ReadHeader
        BVS     %FT20
        LDRB    r0, [r2, #3]
        LDRB    r1, [r2, #4]

; This code changed by TMD 17-Feb-95
; No longer allow &0000 in any version
; 'M' version allows &00F9 (as before)
; Other versions allow &00FF or &00F9

        ORR     r0, r0, r1, LSL #8
        MOV     r1, #0
 [ NewProductType
        CMP     r0, #ProdType_MPEGDecoder ; (V:=0)
 |
        CMP     r0, #ProdType_MPEGDecoder ; allow new
        CMPNE   r0, #&FF                ; or old types
 ]
        MOVEQ   r1, #CardType_STB1      ; RISC PC or STB1 type
        LDR     lr, =ProdType_STB2_MPEG1 ; also allow new STB2 MPEG 1 product type (not a valid immediate constant)
        TEQ     r0, lr
        MOVEQ   r1, #CardType_STB2      ; indicate as such
        TEQ     r1, #0                  ; if neither
        BEQ     %FT20                   ; then not this podule
        STR     r1, CardType            ; save card type
        CLRV
        EXIT

20
        SUBS    r3, r3, #1
        BPL     %BT10
        ADR     r0, NoPoduleError
90
        STR     r0, [sp]
        SETV
        EXIT

NoPoduleError
        &       0
        =       NoPoduleErrorMessage, 0
        ALIGN

; **************************************************************************
;
;       InitAV110 - Initialise AV110
;
;

InitAV110 Entry "r0-r4,r11"
        MOV     r0, #AudioFIFOStuffAmount
        STR     r0, OutstandingDataSize

 [ UseBALE
        MOV     r0, #StreamState_WaitingForData
        STR     r0, StreamState
 ]
        MOV     r0, #0
        STR     r0, IRQCounts

        LDR     r0, AV110_Base
        DReg    r0, "AV110 Base = "

 [ SendPTSPatch
        BL      IssuePTSPatch
 ]
        MOV     r1, #0
        MOV     r2, #1
        STRB    r1, [r0, #AV110_ATTEN_L]
        STRB    r1, [r0, #AV110_ATTEN_R]
        STRB    r1, [r0, #AV110_AUD_ID_EN]
	STRB	r1, [r0, #AV110_SKIP]
	STRB	r1, [r0, #AV110_REPEAT]

 [ UseBALE
        MOV     r3, #BALE_LIM :AND: &FF
        STRB    r3, [r0, #AV110_BALE_LIM_0]
        MOV     r3, #BALE_LIM / &100
        STRB    r3, [r0, #AV110_BALE_LIM_1]
        ; set BALF value in r3
        MOV     r3, #&4000                      ; 64KB BALF
 |
  [ HandleNoDRAM
	LDR	r4, LocalBuffBase
	CMP	r4, #0
        ; Note: BALE and BALF are specified in
        ; units of 32-bit words, hence the /4 below.
        MOVNE   r3, #BALE_VALUE/4       ; value for no-DRAM case
	MOVEQ	r3, #0
        STRB    r3, [r0, #AV110_BALE_LIM_0]
        MOV     r3, r3, LSR #8
        STRB    r3, [r0, #AV110_BALE_LIM_1]
        ;
        ; For BALF, set suitable value as if we were actually using the BALF interrupt;
        ; this is done just in case the AV110 actually uses the BALF value in determining
        ; the point at which it deasserts REQ (i.e. it considers its input buffer is full).
        ; Nothing in the data sheet says so, but for safety it seems wiser to do this anyway.
        ;
        CMP     r4, #0                          ; using external DRAM?
        MOVEQ   r3, #&4000                      ; set 64KB (16K words) for DRAM case
        MOVNE   r3, #MAX_BALE_NODRAM            ; set highest valid value for non-DRAM case
  |
        STRB    r1, [r0, #AV110_BALE_LIM_0]     ; sets BALE to 0 - we don't care
        STRB    r1, [r0, #AV110_BALE_LIM_1]
        MOV     r3, #&4000
  ]
 ]
        STRB    r3, [r0, #AV110_BALF_LIM_0]
        MOV     r3, r3, LSR #8
        STRB    r3, [r0, #AV110_BALF_LIM_1]

        STRB    r1, [r0, #AV110_EOS]
        STRB    r1, [r0, #AV110_FREE_FORM_0]
        STRB    r1, [r0, #AV110_FREE_FORM_1]
        STRB    r1, [r0, #AV110_INTR_EN_0]
        STRB    r1, [r0, #AV110_INTR_EN_1]
        STRB    r1, [r0, #AV110_IRC_LOAD]
        STRB    r1, [r0, #AV110_PCM_18]
        STRB    r1, [r0, #AV110_PCM_FS]
        STRB    r1, [r0, #AV110_PCM_ORD]
        STRB    r1, [r0, #AV110_SIN_EN]
 [ UseErrorRecovery
  [ HandleNoDRAM
        CMP     r4, #0
        STRNEB  r1, [r0, #AV110_LATENCY] ; latency = 0 (low) if no DRAM
        STREQB  r2, [r0, #AV110_LATENCY] ; latency = 1 (high) if DRAM
        ; set treatment of CRC errors and loss of sync
        MOVNE   r3, #1                          ; if no DRAM, use mode 1 (mute on error)
        MOVEQ   r3, #2                          ; else use mode 2, concealment
        STRB    r3, [r0, #AV110_SYNC_ECM]
        STRB    r3, [r0, #AV110_CRC_ECM]
        ; sync error recovery mode is determined by DRAM/no DRAM
        STRNEB  r1, [r0, #AV110_SYNC_LCK]       ; no DRAM: restart immediately on re-sync
        STREQB  r2, [r0, #AV110_SYNC_LCK]       ; else with DRAM, check for next frame sync too
  |
        MOV     r3, #1
        STRB    r3, [r0, #AV110_LATENCY]        ; latency = 1 (high)
        MOV     r3, #2
        STRB    r3, [r0, #AV110_SYNC_ECM]       ; repeat last frame on sync error
        STRB    r2, [r0, #AV110_SYNC_LCK]       ; also check for 1 extra frame for re-sync
        STRB    r3, [r0, #AV110_CRC_ECM]        ; repeat last frame on CRC error
  ]
 |
        STRB    r1, [r0, #AV110_LATENCY] ; low latency

;       STRB    r2, [r0, #AV110_SYNC_ECM] ; 1: on sync err, mute & resync
        STRB    r1, [r0, #AV110_SYNC_ECM] ; 0: ignore sync errors
        STRB    r1, [r0, #AV110_CRC_ECM]  ; 0: no CRC error detection/recovery
        STRB    r1, [r0, #AV110_SYNC_LCK] ; 0: restart on 1st frame with valid sync
 ]

        MOV     r3, #8
        STR     r3, PCM_DIV_Copy
        STRB    r3, [r0, #AV110_PCM_DIV]

        STRB    r2, [r0, #AV110_MUTE]           ; mute, initially
 [ DelayPauseCommands
        STR     r2, NotPendingPause
        LDRB    r3, [r0, #AV110_VERSION]
        TEQ     r3, #AV110VERSION_TMXC
        STREQ   r1, NotTMXCFlag                 ; if TMXC, then NotTMXCFlag = 0
        STRNE   r2, NotTMXCFlag                 ; else NotTMXCFlag = 1
 ]
        STRB    r1, [r0, #AV110_PLAY]           ; not playing, initially

 [ HandleNoDRAM
        CMP     r4, #0
        MOVNE   r3, #0                          ; if NoDRAM, always use audio stream
        MOVEQ   r3, #1                          ; else always use audio packets
 |
  [ UseWholePackets
        MOV     r3, #1                          ; 1 => audio packets
  |
        MOV     r3, #0                          ; 0 => audio stream
  ]
 ]
        STRB    r3, [r0, #AV110_STR_SEL]

        STRB    r2, [r0, #AV110_RESET]          ; send RESET command after initialisation
90
        CLRV
        EXIT

; **************************************************************************
;
;       SelectAV110Sound - Update MPEG card control register to select AV110 sound

SelectAV110Sound Entry "r0-r2"
        MOV     r0, #CardControlReason_UpdateControlRegister
        MOV     r1, #MPEGPoduleControl_I2SSelect_AV110
        MVN     r2, #MPEGPoduleControl_I2SSelect
        SWI     XMPEGVideo_CardControl
        CLRV
        EXIT

; **************************************************************************
;
;       SelectVIDC20SoundIfNecessary - Update MPEG card control register to select VIDC20 sound, but only if on STB2

SelectVIDC20SoundIfNecessary Entry "r0-r2"
        LDR     lr, CardType
        CMP     lr, #CardType_STB2              ; (V := 0)
        EXIT    NE
        MOV     r0, #CardControlReason_UpdateControlRegister
        MOV     r1, #MPEGPoduleControl_I2SSelect_VIDC20
        MVN     r2, #MPEGPoduleControl_I2SSelect
        SWI     XMPEGVideo_CardControl
        CLRV
        EXIT

 [ SendPTSPatch
; **************************************************************************
;
;       IssuePTSPatch - Send the PTS.FIX patch to the device
;
; in:   r0 -> AV110_Base

IssuePTSPatch Entry "r1-r4"
        MOV     r1, #1                          ; start off by issuing a software reset
        STRB    r1, [r0, #AV110_RESET]          ; (should really be a pin reset, but we don't have access to that)

        ADR     r2, PatchData_PTSFIX_Start
        ADR     r3, PatchData_PTSFIX_End
10
        LDRB    r4, [r2], #1                    ; write all the patch bytes to the same location
        STRB    r4, [r0, #AV110_PATCH]
        TEQ     r2, r3
        BNE     %BT10

        LDR     r2, =PatchData_PTSFIX_End - PatchData_PTSFIX_Start
20
        LDRB    r4, [r0, #AV110_PATCH]          ; then read them all back again
        SUBS    r2, r2, #1
        BNE     %BT20

        STRB    r1, [r0, #AV110_RESET]          ; then give it another software reset
        EXIT

        LTORG

        MACRO
        PatchData       $data
        LCLS    tmp
 [ (:LEN: "$data") = 0
        MEXIT
 |
  [ (:LEN: "$data") = 1
        ! 1, "Odd number of digits in PatchData"
  |
tmp     SETS    "$data" :LEFT: 2
        =       &$tmp
tmp     SETS    "$data" :RIGHT: ((:LEN: "$data")-2)
        PatchData       "$tmp"
  ]
 ]
        MEND


PatchData_PTSFIX_Start
        PatchData       00900715C1070A9005009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       009007009007009007009007
        PatchData       090000FF0F00
PatchData_PTSFIX_End
        ALIGN
        ASSERT  PatchData_PTSFIX_End - PatchData_PTSFIX_Start = 198
 ]

; **************************************************************************

ClaimIRQVector Entry "r0-r4"
        LDR     r0, IRQVectorClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    NE                              ; non-zero => already claimed
 [ HandleNoDRAM
        LDR     r4, LocalBuffBase
        CMP     r4, #0
        BNE     %FT20
 ]
        MOV     r0, #CardControlReason_ClaimAudioIRQ
        ADR     r1, AudioIRQHandler             ; handler address
        MOV     r2, wp                          ;  workspace pointer
        SWI     XMPEGVideo_CardControl
        EXIT    VS

 [ UseWholePackets
        MOV     r0, #AV110INTR_PTS              ; IRQ when PTS registered
        MOV     r1, #0
        BL      EnableDisableIRQs
 ]
20
 [ UseBALE
        ; (Note: HandleNoDRAM must be false here)
        MOV     r0, #AV110INTR_BALE             ; buffer empty IRQ
        MOV     r1, #0                          ; don't disable any
        BL      EnableDisableIRQs
 |
        MOV     r0, #TickerV
        ADR     r1, StuffDataFromIRQ
        MOV     r2, wp
        SWI     XOS_Claim
 ]
        MOV     r0, #1
        STR     r0, IRQVectorClaimed
        EXIT

ReleaseIRQVector Entry "r0-r2"
        LDR     r0, IRQVectorClaimed
        CMP     r0, #0                          ; V:=0
        EXIT    EQ                              ; non-zero => already claimed

        MOV     r0, #0
        STR     r0, IRQVectorClaimed

 [ :LNOT: UseBALE
        MOV     r0, #TickerV
        ADR     r1, StuffDataFromIRQ
        MOV     r2, wp
        SWI     XOS_Release

        ADR     r0, AudioTickerVCallBack
        MOV     r1, wp
        SWI     XOS_RemoveCallBack
 ]
	; It is believed harmless to perform the following call even when
	; it has already been performed by the ReleaseFIQ code in the case
	; of DRAM-less working.

        MOV	r0, #CardControlReason_ReleaseAudioIRQ
        SWI	XMPEGVideo_CardControl

        EXIT


        LTORG


 [ HandleNoDRAM

; **************************************************************************
;
; FIQCode
;
; Set up with:  r13 = FIQ stack
;               r12 = work space
;               r11 = address of podule control/status reg
;               r10 = address of AV110 data port
;               r9  = LocalBuffBase
; Within code:
;               r8  = LocalBuffOut (copy)
;               r2  = LocalBuffFree (copy)
;               r1  = IOMD_Base if needed
;               r0  = temp
FIQCode ROUT
        STMFD   sp!, {r0,r1,r2}                      ; preserve temps

        ; Clear the external latch for this FIQ - do first
        LDR     r0, Podule_Base
        STRB    r0, [r0, #Offset_EPROM]         ; data value irrelevant

        ; Read AV110's interrupt request register to clear its own interrupt
        ADD     r8, r10, #Offset_AV110_Base - Offset_Fast_Audio_Data
        LDRB    r0, [r8, #AV110_INTR_0]
        LDRB    r1, [r8, #AV110_INTR_1]
        ORR     r0, r0, r1, LSL #8              ; build complete interrupt source word
 [ FIQDebug
        MOV     r2, #0                          ; address FIQ code space (debug area)
        STR     r0, [r2, #&3C]                  ; log INTR state for debug
	LDR	r1, [r2, #&28]		; count FIQs seen (of any type)
	ADD	r1, r1, #1
	STR	r1, [r2, #&28]
 ]

        ; Check for FIFO having some space and fill it if so
        LDRB    r0, [r11, #0]
        TST     r0, #MPEGPoduleStatus_AudioFIFOFull
        BNE     %FT90                           ; still full?

10      LDR     r8, LocalBuffOut
        LDR     r2, LocalBuffFree
20      CMP     r2, #LocalBuffSize
        BEQ     %FT80                           ; go disable FIQ if none to move
        LDRB    r0, [r9, r8]                    ; pick up byte from buffer
        ADD     r8, r8, #1                      ; step on to next
        BIC     r8, r8, #LocalBuffSize          ; forcing wrap to start if at end
        STRB    r0, [r10]                       ; transfer to AV110
        ADD     r2, r2, #1                      ; one more free slot
        ; Check whether chip FIFO is now full
        LDRB    r0, [r11, #0]
        TST     r0, #MPEGPoduleStatus_AudioFIFOFull
        BEQ     %BT20                           ; if not, go round again

        ; Fifo now full; check again for having sent all the data
        CMP     r2, #LocalBuffSize
80      ; If EQ (buffer empty), disable FIQs
        MOVEQ   r0, #0
        MOVEQ   r1, #IOC
        STREQB  r0, [r1, #IOCFIQMSK]                    ; mask out all FIQs

        ; Update memory copies of state
        STR     r8, LocalBuffOut
        LDR     r0, LocalBuffFree
        SUB     r0, r2, r0                      ; work out how many moved
        STR     r2, LocalBuffFree               ; store updated free count

 [ FIQDebug
	MOV	r8, #0
	LDR	r1, [r8, #&2C]
	ADD	r1, r1, r0		; count up how many bytes sent in total
	STR	r1, [r8, #&2C]
 ]

        ; Decrement the transfer counter, used for PTS triggering

        LDR     r1, FIQTransferP	; pick up transfer count pointer
	CMP	r1, #0			; if 0, it's not active
 [ FIQDebug
	MOV	r2, #0
	LDREQ	r8, [r2, #&48]
	LDRNE	r8, [r2, #&4C]
	ADD	r8, r8, #1
	STREQ	r8, [r2, #&48]
	STRNE	r8, [r2, #&4C]
 ]
        BEQ     %FT90			; if so, leave it alone

	LDR	r8, [r1, #4]		; pick up transfer count (2nd word of scrtable ent)

        SUB     r2, r8, r0, LSL #1	; subtract off (bytes moved << 1)
        STR     r2, [r1, #4]		; and put back

	MOV	r8, r8, ASR #1		; reduce old value to byte count (lose PTS<32> bit)
	MOV	r2, r2, ASR #1		; ditto for new value
        CMP     r8, #0			; if old count value was > 0
        BLE     %FT90
        CMP     r2, #0			; and new value <= 0...
        BGT     %FT90

        ; The transfer countdown has just gone to/through 0: notify main module
        ; code that a pending PTS simulation is now due.  Do this using the
        ; ForceIRQ bit in IOMD, which we as FIQ owner also own.

        MOV     r1, #IOC
        LDRB    r0, [r1, #IOCIRQMSKA]
        ORR     r0, r0, #force_bit
        STRB    r0, [r1, #IOCIRQMSKA]

 [ FIQDebug
	MOV	r1, #0
	LDR	r0, [r1, #&38]		; count up PTS trigger events
	ADD	r0, r0, #1
	STR	r0, [r1, #&38]
 ]

        ; OK, all done for now

90      LDMFD   sp!, {r0,r1,r2}
        SUBS    pc, lr, #4                      ; return from FIQ



ClearFIQVars Entry "r0-r6"

	; Atomically flush and reset the local buffer and the PTS/SCR queue.
	ASSERT	LocalBuffIn + 4 = LocalBuffFree
	ASSERT	LocalBuffFree + 4 = LocalBuffOut
	ASSERT	LocalBuffOut + 4 = FIQTransferP
	ASSERT	FIQTransferP + 4 = SCRIn
	ASSERT	SCRIn + 4 = SCROut
	ASSERT	SCROut + 4 = SCRCount
        MOV     r0, #0			; value for LocalBuffIn
	MOV	r1, #LocalBuffSize	; value for LocalBuffFree
	MOV	r2, #0			; value for LocalBuffOut
	MOV	r3, #0			; value for FIQTransferP - disables counting
	MOV	r4, #0			; value for SCRIn
	MOV	r5, #0			; value for SCROut
	MOV	r6, #0			; value for SCRCount
	LDR	lr, SCRCount				; track how many discarded
	STR	lr, PTSDiscCount
	ADR	lr, LocalBuffIn
	STMIA	lr, {r0,r1,r2,r3,r4,r5,r6} ; zap them all in one go, unbroken by FIQ/IRQ

	EXIT

; **************************************************************************
;
;       ClaimFIQVector
;

ClaimFIQVector Entry "r0-r3"
	LDR	r1, FIQVectorClaimed
	CMP	r1, #0
	EXIT	NE			; if already claimed(?), go home

        MOV     r1, #Service_ClaimFIQ
        SWI     XOS_ServiceCall

	; AV110 DRAM is not fitted (else this routine would not be called), and
	; so the AV110 interrupt is about to be set up to generate FIQ instead.
	; Set a special -1 Audio IRQ handler address to mark that LAInt status
	; should be completely ignored by the video control module; in
	; particular, it must never attempt to read the AV110 interrupt request
	; register, as the default code does, since this is read sensitive and
	; could therefore play havoc with FIQ servicing.

        MOV     r0, #CardControlReason_ClaimAudioIRQ
        MVN     r1, #0                          ; -1 as handler address
        MVN     r2, #0                          ; -1 as workspace pointer
        SWI     XMPEGVideo_CardControl
        EXIT    VS

        ; For DRAM-less mode, we need to allow the BALE interrupt from the
        ; AV110; it will come in as a FIQ, to ensure the low latency of service
        ; which having only 256 bytes of buffering requires.

        MOV     r0, #AV110INTR_BALE
        MOV     r1, #0                          ; don't disable any
        BL      EnableDisableIRQs

	; Clear any AV110 interrupt which may have been hanging around (latched
	; in external hardware).
	LDR	r0, Podule_Base
	STRB	r0, [r0, #Offset_EPROM]

        ; Ensure FIQs are disabled for now - we own the whole of the IOC FIQ
	; mask so can just write it to 0 (which is nice and atomic unlike r/m/w).
        MOV     r0, #IOC
        MOV     r1, #0
        STRB    r1, [r0, #IOCFIQMSK]            ; shut off FIQs

	; Switch the new hardware over to generate poduleFIQ rather than
	; poduleIRQ for interrupts from the AV110.
        MOV     r1, #MPEGPoduleControl_FIQEnable ; enable FIQ from podule
        MVN     r2, #MPEGPoduleControl_FIQEnable ; leave other bits unchanged
        MOV     r0, #CardControlReason_UpdateControlRegister
        SWI     XMPEGVideo_CardControl

	; Now set up the FIQ vector and other locations in low memory

        MOV     r3, #0
        LDR     r0, FIQLDRPCInstr
        STR     r0, [r3, #&1C]                  ; &1C: LDR PC, .+4 instr
        ADR     r0, FIQCode
        STR     r0, [r3, #&20]                  ; &20: address of FIQCode to vector through
 [ FIQDebug
        LDR     r0, LocalBuffBase               ; &24: buffer address, for diags
        STR     r0, [r3, #&24]
        MOV     r0, #0
        STR     r0, [r3, #&28]                  ; &28: count of FIQs seen
        STR     r0, [r3, #&2C]                  ; &2C: count of bytes sent
        STR     r0, [r3, #&30]                  ; &30: count of f/g AV110 fills
        STR     r0, [r3, #&34]                  ; &34: count of bytes moved to AV110 in f/g
        STR     r0, [r3, #&38]                  ; &38: count of FIQs where PTS triggered
        STR     r0, [r3, #&3C]                  ; &3C: AV110 INTR on last FIQ
        STR     r0, [r3, #&40]                  ; &40: count of attempts to send data
        STR     r0, [r3, #&44]			; &44: worst PTS overrun in bytes
        STR     r0, [r3, #&48]			; &48: count of FIQs when FIQTransferP = 0
        STR     r0, [r3, #&4C]			; &4C: count of FIQs when FIQTransferP <> 0
        STR     r0, [r3, #&50]			; &50:
        STR     r0, [r3, #&54]			; &54: count of how many counts <= 0 queued
        STR     r12, [r3, #&58]			; &58: minimum count difference (init large)
        STR     r0, [r3, #&5C]			; &5C: maximum count difference
        STR     r0, [r3, #&60]			; &60:
 ]
	; Set up the FIQ mode registers

        MOV     r2, wp                          ; get copy of our workspace pointer
        ; Enter FIQ mode
        MOV     r0, pc
        BIC     r1, r0, #3
        ORR     r1, r1, #FIQ_mode+F_bit+I_bit ; stay out!
        TEQP    r1, #0
        NOP

        MOV     r13, #FIQStackEnd               ; Set up FIQ stack pointer
        MOV     r12, r2                         ; set r12_fiq = our r12 (wp), so ..
        LDR     r11, Podule_StatusRegister      ; ..can pick up other vars into FIQ regs
        LDR     r10, Fast_Audio_Data            ; ...
        LDR     r9, LocalBuffBase               ; ...

        TEQP    r0, #0                          ; go back to SVC mode
        NOP

	; Initialise variables for data traffic and PTS handling.
	BL	ClearFIQVars

        ; Now set up our handler for the ForceIRQ vector, so that the FIQ
	; code can when needed cause an IRQ in order to implement PTS
	; triggering.

        MOV     r0, #IOMD_FIQDowngrade_DevNo
        ADRL    r1, TriggerPTS
        MOV     r2, wp
        SWI     XOS_ClaimDeviceVector           ; assumed not to fail

	MOV	r0, #1
	STR	r0, FIQVectorClaimed	; all done for now

        EXIT

; Template for instruction to place on FIQ vector (uses following word
; as address of code to jump to).
FIQLDRPCInstr
        LDR     pc, %FT20
20


ReleaseFIQVector Entry "r0-r3"
	LDR	r0, FIQVectorClaimed
	CMP	r0, #0
	EXIT	EQ			; nothing to do if not claimed

	; Disable FIQ & IRQ for now
	MOV	r3, pc
	ORR	lr, r3, #I_bit+F_bit
	TEQP	lr, #0

	MOV	r0, #0
	STR	r0, FIQVectorClaimed	; not claimed now, for this module

        MOV     r0, #IOC
	; Disable FIQs at IOC/IOMD level
        MOV     r1, #0
        STRB    r1, [r0, #IOCFIQMSK]	; force off FIQs in FIQMask reg

	; Clear any pending force IRQ from FIQ code
	LDRB	r1, [r0, #IOCIRQMSKA]
	BIC	r1, r1, #force_bit
	STRB	r1, [r0, #IOCIRQMSKA]

	; Turn off INT sources in AV110
        MOV     r0, #0			; don't enable any
        LDR     r1, =AV110INTR_All	; disable them all
        BL      EnableDisableIRQs	; clear all sources of INT from AV110

	; Clear any pre-existing latched interrupt
	LDR	r1, Podule_Base		; clear any latched interrupt by
        STRB	r1, [r1, #Offset_EPROM]	; writing to EPROM space

	TEQP	r3, #0			; re-enable FIQs + IRQs

	; Switch hardware back to generating IRQs from AV110 INTs
        MOV     r1, #0			; disable FIQ from podule
        MVN     r2, #MPEGPoduleControl_FIQEnable ; leave other bits unchanged
        MOV     r0, #CardControlReason_UpdateControlRegister
        SWI     XMPEGVideo_CardControl

	; Release our special "IRQ routine" from the AudioIRQ vector
        MOV	r0, #CardControlReason_ReleaseAudioIRQ
        SWI	XMPEGVideo_CardControl

	; Tell OS we're finished with FIQs
        MOV     r1, #Service_ReleaseFIQ
        SWI     XOS_ServiceCall

        EXIT

 ]

	LTORG

; **************************************************************************
;
;       EnableDisableIRQs - Enable and/or disable individual interrupt bits in
;       the AV110; these are ORed together to generate a single INT signal.
;       When operating in DRAM-less mode, the INT is arranged to appear as a
;       FIQ (podule FIQ in fact).
;
; in:   r0 = mask of IRQs to enable
;       r1 = mask of IRQs to disable

EnableDisableIRQs Entry "r2,r11"

        LDR     r11, AV110_Base

        ; disable IRQs and FIQs
        MOV     r2, pc
        ORR     lr, r2, #I_bit+F_bit
        TEQP    lr, #0

        LDR     lr, InterruptMask
        BIC     lr, lr, r1
        ORR     lr, lr, r0
        STR     lr, InterruptMask
        STRB    lr, [r11, #AV110_INTR_EN_0]
        MOV     lr, lr, LSR #8
        STRB    lr, [r11, #AV110_INTR_EN_1]

        TEQP    r2, #0
        EXIT

; **************************************************************************
;
;       AudioIRQHandler - Handler for audio IRQs.  When operating in DRAM-less
;       mode, this is not used.
;
; in:   [sp, #0] = combined interrupt status
; out:  r0-r3 may be corrupted

AudioIRQHandler Entry "r0-r3,r11"
        LDR     lr, IRQCounts
        ADD     lr, lr, #1
        STR     lr, IRQCounts

        LDR     r11, AV110_Base
        LDR     r2, [sp, #6*4]          ; access stacked interrupt status
        STR     r2, LastIntStatus
 [ UseBALE
        TST     r2, #AV110INTR_BALE
        BLNE    StuffDataFromIRQ
 ]
 [ UseWholePackets
        TST     r2, #AV110INTR_PTS
        BLNE    ProcessPTSIRQ
 ]
 [ :LNOT: AudioIRQBodge
        LDR     r2, Podule_Base         ; clear latched interrupt by writing to EPROM space
        STRB    r2, [r2, #Offset_EPROM]
 ]
        PullEnv
        ADD     sp, sp, #4
        MOV     pc, lr

; **********************************************************************
;
; StuffDataFromIRQ - called from either AudioIRQHandler (if UseBALE is
; set) or from TickerV, to move data into the AV110 (or our local buffer)
; if possible.
;
StuffDataFromIRQ Entry "r0,r2"
 [ UseBALE
        LDR     r0, StreamState
        TEQ     r0, #StreamState_WaitingForRDY ; if not waiting for RDY
        EXIT    NE
 ]

        MOV     r0, #AudioFIFOStuffAmount
        STR     r0, OutstandingDataSize

        MOV     r0, pc
        ORR     lr, r0, #SVC_mode       ; go into SVC mode
        TEQP    lr, #0
        NOP


 [ {FALSE}      ; do it after filling instead

; now perform stream synchronisation if required

        Push    "r14"
        BL      DoStreamSync
        Pull    "r14"
 ]

        Push    "r0,r1,r14"
        LDR     r0, CallBackRequested
        TEQ     r0, #0
        OutputSentCount #-2, NE         ; indicate that we already had one queued
        BNE     %FT10
        LDR     r0, StreamFlags
        TST     r0, #StreamFlags_UseCallBacks
        BEQ     %FT20                   ; send directly
        ADR     r0, AudioTickerVCallBack
        MOV     r1, wp
        SWI     XOS_AddCallBack
        MOVVC   r0, #1
        STRVC   r0, CallBackRequested
10
        Pull    "r0,r1,r14"
        TEQP    r0, #0
        NOP
        EXIT                            ; then ignore

20
        Push    "r14"
        MOV     lr, #1
        STR     lr, CallBackRequested   ; set semaphore to avoid re-entry
 [ EnableIRQsInTickerV
        MOV     lr, pc
        BIC     lr, lr, #I_bit          ; enable IRQs
        TEQP    lr, #0
 ]
        BL      AudioTickerVCallBack
        Pull    "r14"
        B       %BT10

AudioTickerVCallBack Entry
        BL      DoStuffWithData
        MOV     lr, #0
        STR     lr, CallBackRequested
        EXIT

DoStuffWithData Entry "r0-r3, r11"
        LDR     r0, StreamClosing
        TEQ     r0, #0
        EXIT    NE
 [ CheckSampleRate
        BL      DoCheckSampleRate
 ]
05
        LDR     r0, PacketListHeadPtr
        TEQ     r0, #0                  ; do we have any data?
        BNE     %FT10                   ; [yes, so start sending it]

        OutputSentCount #-1             ; indicate none to send it

; no data, but AV110 ready, so set state to waiting for data

 [ UseBALE
  [ :LNOT: AudioIRQBodge
        MOV     r0, #0
        MOV     r1, #AV110INTR_BALE     ; disable this IRQ for now
        BL      EnableDisableIRQs
  ]

        MOV     r0, #StreamState_WaitingForData
        STR     r0, StreamState
 ]
        BL      DoStreamSync
        EXIT

; send data

10
 [ UseWholePackets
        BL      SendNewPacketIfNecessary
        BLEQ    SendData
 |
        BL      SendData                        ; not bothering with PTS stuff
 ]
        BLEQ    FreePacket                      ; in: r0 -> packet, out: r0 -> next packet

        BL      CheckForMore
        BEQ     %BT05

 [ UseBALE
        MOV     r0, #StreamState_WaitingForRDY
        STR     r0, StreamState
 ]
        EXIT

CheckForMore ROUT
        LDR     r1, StreamFlags
        TST     r1, #StreamFlags_UseCallBacks           ; if using callbacks then go back if
        MOVNES  pc, lr                                  ; we used all of packet (ie EQ on entry)
        LDR     r1, OutstandingDataSize                 ; else use OutstandingDataSize
        TEQ     r1, #0                                  ; if non-zero
        ORRNES  pc, lr, #Z_bit                          ; then indicate to try again
        BICEQS  pc, lr, #Z_bit                          ; else give up

 [ UseWholePackets
; **************************************************************************
;
;       SendNewPacketIfNecessary - Send packet header if at start of packet
;
; in:   r0 -> packet descriptor
; out:  r1-r3 corrupted
;       EQ => ok to send actual data, NE => don't try - we're not ready yet
;

SendNewPacketIfNecessary Entry "r4-r11"
        BL      CheckForSyncWord
        EXIT    NE

        LDR     r1, [r0, #PacketDescriptor_Flags]
        TST     r1, #PacketDescriptorFlags_MPEGStart ; is it start of an MPEG packet?
        EXIT    EQ                              ; [no, so no packet header required,
                                                ; exit EQ => try to send data]

 [ HandleNoDRAM
        LDR     r8, LocalBuffBase               ; Test whether AV110 has DRAM...
        CMP     r8, #0                          ; if no local buffer, then
        BEQ     %FT20                           ; go handle DRAM case, look at FIFO directly

        ; AV110 has no external DRAM, and hence is running in stream mode.
        ; Check if video module needs synchronisation via PTS handling.

        LDR     r4, StreamFlags
        TST     r4, #StreamFlags_VideoPresent
        BEQ     %FT10                   ; do nothing if no video in stream
        TST     r4, #StreamFlags_NoLipSync
        BNE     %FT10                   ; do nothing if no lip sync required

        ; The AV110 is in stream mode, without DRAM, but we may want to
        ; simulate a PTS interrupt at the correct time, without help from the
        ; AV110. Check whether this packet has a PTS attached.

        TST     r1, #PacketDescriptorFlags_PTSValid
        BEQ	%FT10			; if no PTS, we're all done

        LDR     lr, PTSInCount		; increment count of PTS'ed frames coming in
        ADD     lr, lr, #1
        STR     lr, PTSInCount

	; PTS is valid and we can handle it; find the next frame start in
	; the data and mark its position so that the PTS can be signalled
	; when that point is reached by the AV110.

        BL      FindSyncWord		; go hunt for a frame start: result in r2

	; Once we've looked once for a frame start, don't try again...
	LDR	lr, [r0, #PacketDescriptor_Flags]
        BIC	lr, lr, #PacketDescriptorFlags_MPEGStart ; clear packet start flag
        STR	lr, [r0, #PacketDescriptor_Flags]

	; If r2 < 0, couldn't find a frame start, presumably because not all of the packet
	; is available yet; keep count of such cases, and return without queuing a PTS.

        CMP     r2, #0			; if r2 < 0, not found
	LDRLT	lr, PTSMissCount	; increment "missed" count
	ADDLT	lr, lr, #1
	STRLT	lr, PTSMissCount
	BLT	%FT10			; return (send data anyway)

	LDR	lr, SCRCount		; count how many PTSs in queue already
	CMP	lr, #SCRCount_Max	; if maximum, drop this one
	LDREQ	lr, PTSDropCount	; increment count of dropped PTSs
	ADDEQ	lr, lr, #1
	STREQ	lr, PTSDropCount
	BEQ	%FT10			; forget it

	; Check that the frame start position makes sense
	CMP	r2, #1728		; compare with length of longest possible frame
	LDRGT	lr, PTSDuffCount	; increment count of duff PTSs if greater
	ADDGT	lr, lr, #1
	STRGT	lr, PTSDuffCount
        BGT     %FT10                   ; and ignore this PTS

	; Found a valid frame start. Try to work out when the PTS representing
	; this should be triggered, by the following means:
        ;
        ; (a) work out how many bytes of data are presently queued in the local
        ;     buffer;  anywhere from 0 to 24KB, representing up to 6 seconds
        ;     in the most extreme case, but more typically 0.5 - 1 second.
        ; (b) add to that the offset in this buffer to the sync byte (i.e.
        ;     what we just worked out), to get how many bytes there are between
        ;     the sync byte and the start of the AV110's FIFO; may be up to
        ;     (one frame-size less one byte), i.e. from 0 to 36ms worth.
        ; (c) add to that an estimate of the typical fullness of the AV110
        ;     FIFO, based upon the BALE value we use, to get a rough distance
        ;     to the end of the FIFO; somewhere between 3.5 and 48ms.
	;
	; We end up with a number N, such that when N bytes of compressed
	; data has been moved by the AV110 FIQ routine, the first byte of
	; compressed data from the frame whose PTS we are considering
	; should be being input by the AV110 for decoding; assuming very
	; short decoding latency (which is wrong but will do for the
	; moment), it should be the time point the PTS represents.  This is
	; all pretty approximate (in particular it assumes a steady data
	; transfer rate under FIQ, although in fact that is a bit lumpy,
	; and omits the decoding time and AV110 output buffer delay), but
	; should be close enough for the required accuracy level - the
	; synchronisation with video works only to the nearest field (or
	; frame, with older CL450 microcode), i.e. we have a slop of at
	; least 16.7ms (one field time in NTSC mode).

	; Leave item (a) to last, for atomicity reasons; start with item (b),
	; which is easy 'cos it's already in r2.

	; Add item (c); assume that on average the AV110's FIFO is half way
	; between full and the BALE trigger point, because FIQ latency from
	; BALE should be very low.
        ADD     r2, r2, #(BALE_VALUE + AV110_FIFO_SIZE)/2 ; (c)

	; Now have our sum of (b) and (c).  Need to add (a), the amount of
	; data in our local buffer.  This needs to be read and the transfer
	; count trigger set up atomically (both are modified under FIQ), so
	; we have left it till last.

	; First disable FIQ & IRQ...
        MOV     lr, pc
        ORR     r10, lr, #I_bit+F_bit
        TEQP    r10, #0

        LDR     r5, LocalBuffFree       ; work out what's in local buffer
        RSB     r5, r5, #LocalBuffSize  ; by simple arithmetic:  (a)
	ADD	r2, r2, r5		; add it in for our total

	; Go through outstanding PTS events, subtracting off the delay
	; count for each from our total delay, so as to produce a
	; differential count from the last entry in the table.  We've
	; already checked that there aren't already SCRCount_Max entries in
	; the table, above, so no need to actually count here, just start
	; at SCRTable[SCROut] and increment (wrapping) until we hit
	; SCRTable[SCRIn] which is the entry we will set up.

	ADR	r4, SCRTable
	LDR	r5, SCROut
	LDR	r6, SCRIn
02	ADD	r7, r4, r5, LSL #3
	CMP	r5, r6			; if out = in, no entries left, go add one
	BEQ	%FT04
	ADD	r5, r5, #1		; step on
	AND	r5, r5, #SCRIndex_Mask	; (wrapping)
	LDR	r1, [r7, #4]		; get count << 1 | PTS<32>
	SUB	r2, r2, r1, ASR #1	; subtract off (*signed*) count from total offset
	B	%BT02			; round again

04	; Now, r2 contains the byte count offset from the point at which
	; the last PTS in the table is due to be delivered.  It is
	; conceivable that in extreme circumstances (very high IRQ latency)
	; this value could actually be negative or 0, although that would
	; be bizarre.  Just in case, force it to be >0 to ensure the FIQ
	; code actually triggers properly on it.

	CMP	r2, #0
	MOVLE	r2, #1

	; Combine this with the new PTS itself to form the next
	; table entry.

	LDR	r1, [r0, #PacketDescriptor_PTS]	; get low 32 bits of PTS
	LDR	r3, [r0, #PacketDescriptor_PTS+4] ; and high bit (bit 32) of PTS
	AND	r3, r3, #1		; clean it
	ORR	r2, r3, r2, LSL #1	; combine PTS and count in high word
	STMIA	r7, {r1,r2}		; store entry in correct slot
	ADD	r6, r6, #1		; step on SCRIn
	AND	r6, r6, #SCRIndex_Mask	; wrapping round in table
	STR	r6, SCRIn
	LDR	r5, SCRCount		; increment count appropriately
	ADD	r5, r5, #1
	STR	r5, SCRCount
	LDR	r1, PTSQinCount
	ADD	r1, r1, #1
	STR	r1, PTSQinCount
	CMP	r5, #1			; is this now the first entry? (i.e. previously idle)
	STREQ	r7, FIQTransferP	; if so, set count pointer to point at it

	TEQP	lr, #0			; restore I+F state

10      TEQ     r0, r0                  ; always exit EQ
        EXIT


  [ {FALSE}	; The following was used to estimate further delay on PTS, but
		; is now ignored.

; gap_tab_{I,II}: tabulate to nearest whole byte the number of bytes of
; compressed data at the current bitrate (requires layer to decode) represented
; by 64 sample times at the current sample rate.

GAP_S	*	64				; how many samples assumed
        MACRO
        gaps	$bitrate
        DCB     $bitrate*GAP_S/44100/8, $bitrate*GAP_S/48000/8, $bitrate*GAP_S/32000/8
        MEND

gap_tab_I
        gaps    0
        gaps    32000
        gaps    64000
        gaps    96000
        gaps    128000
        gaps    160000
        gaps    192000
        gaps    224000
        gaps    256000
        gaps    288000
        gaps    320000
        gaps    352000
        gaps    384000
        gaps    416000
        gaps    448000

gap_tab_II
        gaps    0
        gaps    32000
        gaps    48000
        gaps    56000
        gaps    64000
        gaps    80000
        gaps    96000
        gaps    112000
        gaps    128000
        gaps    160000
        gaps    192000
        gaps    224000
        gaps    256000
        gaps    320000
        gaps    384000

        ALIGN
  ]

20
 ]
        LDR     r2, Podule_StatusRegister
        LDRB    r3, [r2, #0]
        TST     r3, #MPEGPoduleStatus_AudioFIFOFull
        MOVNE   r1, #0                                  ; fifo full, so don't try to send any more data
        STRNE   r1, OutstandingDataSize
        EXIT    NE                                      ; and exit NE indicating that

        LDR     r11, Fast_Audio_Data                    ; for WaitAndSendByte to write data to
        MOV     r3, #0
        BL      WaitAndSendByte                         ; send 1st byte of start code
        BL      WaitAndSendByte                         ; send 2nd byte of start code
        MOV     r3, #1
        BL      WaitAndSendByte                         ; send 3rd byte of start code
        MOV     r3, #&C0
        BL      WaitAndSendByte                         ; send 4th byte of start code
        LDR     r4, [r0, #PacketDescriptor_FullLength]
        TST     r1, #PacketDescriptorFlags_PTSValid

        BEQ     %FT30
        MOV     r3, pc
        ORR     lr, r3, #I_bit
        TEQP    lr, #0
        LDR     lr, PTSInCount                          ; increment count of PTS's coming in
        ADD     lr, lr, #1
        STR     lr, PTSInCount
        TEQP    r3, #0
30
        ADDEQ   r4, r4, #1                              ; add on one for 0F byte if no PTS
        ADDNE   r4, r4, #5                              ; add on five for PTS
        MOV     r3, r4, LSR #8
        BL      WaitAndSendByte                         ; send hi byte of length
        AND     r3, r4, #&FF
        BL      WaitAndSendByte                         ; send lo byte of length
        MOVEQ   r3, #&0F                                ; no PTS, so send terminating code
        BEQ     %FT50

        LDR     r4, [r0, #PacketDescriptor_PTS]         ; get bits 31..0 of PTS
        LDR     r5, [r0, #PacketDescriptor_PTS+4]       ; get bit 32 of PTS
        MOV     r3, r4, LSR #29                         ; r3 = bits 31..29 in bits 2..0
        ORR     r3, r3, r5, LSL #3                      ; r3 = bits 32..29 in bits 3..0
        ORR     r3, r3, #&21                            ; OR in 2 in top nibble indicating PTS, and force bit 0 to 1 (marker)
        BL      WaitAndSendByte
        MOV     r3, r4, LSR #22                         ; r3 = bits 29..22 in bits 7..0
        BL      WaitAndSendByte                         ; (only stores bottom 8 bits)
        MOV     r3, r4, LSR #14                         ; r3 = bits 21..14 in bits 7..0
        ORR     r3, r3, #1                              ; force bit 0 to 1 (marker)
        BL      WaitAndSendByte
        MOV     r3, r4, LSR #7                          ; r3 = bits 14..7 in bits 7..0
        BL      WaitAndSendByte
        MOV     r3, r4, LSL #1                          ; r3 = bits 6..0 in bits 7..1
        ORR     r3, r3, #1
50
        BL      WaitAndSendByte
        BIC     r1, r1, #PacketDescriptorFlags_MPEGStart ; clear MPEG start bit, so if run out of buffer part way thru,
        STR     r1, [r0, #PacketDescriptor_Flags]       ; we don't send hdr again
        TEQ     r0, r0                                  ; set EQ state, so we attempt to send data
        EXIT

WaitAndSendByte Entry
10
        LDR     lr, [r2, #0]                    ; check state of AV110 fifo
        TST     lr, #MPEGPoduleStatus_AudioFIFOFull
        BNE     %BT10                           ; if full, go round again
        STRB    r3, [r11, #0]                   ; not full, send the byte on
        EXITS



 [ HandleNoDRAM
; **************************************************************************
;
;	TriggerPTS - respond to transfer count reaching 0 in FIQ code,
;	downgraded to IRQ, by telling video module about latest PTS.
;	Called directly as an IRQ service routine.
;
TriggerPTS  Entry "r0-r11"

	; First off, turn off the IRQ bit which was set by the FIQ code to
	; cause this interrupt.  Need to disable FIQs here!
	MOV	lr, pc
	ORR	r11, lr, #F_bit + I_bit
	TEQP	r11, #0

	MOV	r3, #IOC
        LDRB    r0, [r3, #IOCIRQMSKA]
        BIC     r0, r0, #force_bit
        STRB    r0, [r3, #IOCIRQMSKA]

	TEQP	lr, #0			; FIQs back on for the moment

	; Increment count of PTS IRQs generated by AV110 via FIQ
        LDR     r1, PTSOutCount
        ADD     r1, r1, #1
        STR     r1, PTSOutCount

05	; Work out next PTS value, to set as SCR for the video stream.
	ADR	r5, SCRTable
	LDR	r4, SCROut
	ADD	r1, r5, r4, LSL #3	; (2 words per entry)
	ADD	r4, r4, #1		; step on
	AND	r4, r4, #SCRIndex_Mask  ; (modulo table size)
	STR	r4, SCROut		; write back
	LDR	r6, PTSQoutCount
	ADD	r6, r6, #1
	STR	r6, PTSQoutCount
	LDR	r6, SCRCount		; decrement count of entries in table
	SUB	r6, r6, #1
	STR	r6, SCRCount		; store back count

	; Next bit needs to be atomic, since the count word is still being
	; updated by FIQ code.  Disable FIQ & IRQ again.

        MOV     lr, pc
        ORR     r11, lr, #I_bit+F_bit
        TEQP    r11, #0

	CMP	r6, #0			; if any entries left...
	ADDGT	r3, r5, r4, LSL #3	; address next table entry
	MOVLE	r3, #0			; else set 0 to stop FIQ transfer counting
	STR	r3, FIQTransferP	; set new FIQTransferP (but it can't count, FIQs off)

	LDMIA	r1, {r1,r4}		; pick up the entry now expired (ready)...
	AND	r2, r4, #1		; leave only bottom bit of count word (PTS<32>)
	MOVEQ	r5, #1			; marks PTS as valid (see comments below)
	BEQ	%FT20			; if this is the last one, go trigger...

	; There's another PTS in the queue: we must compensate for any
	; overrun on the just expired transfer count, by adding in the
	; (<=0) final value of the counter into this new entry's count.

	BIC	r4, r4, #1		; clear out PTS<32> bit from prev count last value..

 [ FIQDebug
	MOV	r5, #0
	LDR	r6, [r5, #&44]
	CMP	r4, r6
	STRLT	r4, [r5, #&44]
19
 ]

	LDR	r5, [r3, #4]		; another entry is now active; pick up its count word
	ADD	r5, r5, r4		; add it in to correct the arithmetic
	CMP	r5, #0			; check for overrun, i.e. next count also expired
	LDRLE	r6, PTSOVRNCount
	ADDLE	r6, r6, #1
	STRLE	r6, PTSOVRNCount
	STR	r5, [r3, #4]		; and put it back to be counted down

20	; OK, the show can go on, let FIQs back in
	TEQP	lr, #0

	; Just in case PTSs were close together and for obscure reasons
	; there has been extremely high IRQ latency, it is possible that
	; the following entry should also be triggered at this time, in
	; which case r5 (a copy of the new entry's count field) will now be
	; <=0 (and the FIQ code will not cause a new PTS trigger IRQ since
	; it only sets the force IRQ bit on a transfer count crossing from
	; >0 to <=0) .  If so, what we do is forget the PTS we just picked
	; up and move on to the next instead, i.e go round to the beginning
	; and start again!
	CMP	r5, #0
	BLE	%BT05

	; Decide whether to actually send on the PTS we now have (in r1,r2)
	; - sometimes it's not appropriate...

        LDR     r3, SpeedSetting
        CMP     r3, #0                  ; if paused
	LDREQ	r0, PTSIGNPCount	;   do nothing
	ADDEQ	r0, r0, #1
	STREQ	r0, PTSIGNPCount
	EXIT	EQ
        CMP     r3, #5                  ; if speed >=5 or pre-buffering
	LDRHS	r0, PTSIGNSCount	;    do nothing, since audio speed is not
	ADDHS	r0, r0, #1		;    linked to video speed
	STRHS	r0, PTSIGNSCount
	EXIT	HS

	LDR	r0, PTSSentCount
	ADD	r0, r0, #1
	STR	r0, PTSSentCount
	; Go into SVC mode (IRQs still off)
        MOV     r11, pc
        ORR     lr, r11, #SVC_mode
        TEQP    lr, #0
        NOP
        Push    "lr"

        MOV     r0, #0
  [ CallSetSCRDirectly
        BL      CallSetSCR
  |
        SWI     XMPEGVideo_SetSCR
  ]
        Pull    "lr"
        TEQP    r11, #0
        NOP
        EXIT
 ]

; **********************************************************************
;
;	ProcessPTSIRQ - read PTS from AV110 and send it to video module
;
ProcessPTSIRQ Entry "r0-r2,r11"
        LDR     r11, AV110_Base

        LDR     r1, PTSOutCount		; increment count of PTS IRQs generated by AV110
        ADD     r1, r1, #1
        STR     r1, PTSOutCount

        LDRB    r1, [r11, #AV110_PTS_0]
        LDRB    lr, [r11, #AV110_PTS_1]
        ORR     r1, r1, lr, LSL #8
        LDRB    lr, [r11, #AV110_PTS_2]
        ORR     r1, r1, lr, LSL #16
        LDRB    lr, [r11, #AV110_PTS_3]
        ORR     r1, r1, lr, LSL #24
        STR     r1, LastPTS

        LDRB    r2, [r11, #AV110_PTS_4]
        STR     r2, LastPTS+4

 [ DelayPauseCommands
        BL      ExecutePendingPause             ; perform any pending pause
 ]

; check if video module needs synchronisation

        LDR     r0, StreamFlags
        TST     r0, #StreamFlags_VideoPresent
        EXIT    EQ                      ; do nothing if no video in stream
        TST     r0, #StreamFlags_NoLipSync
        EXIT    NE                      ; do nothing if no lip sync required
        LDR     r0, SpeedSetting
        CMP     r0, #0                  ; if paused
        CMPNE   r0, #5                  ; or if speed >=5 or pre-buffering
        EXIT    CS                      ; then do nothing, since audio speed is not linked to video speed

; now call the video module with the good news!

        MOV     r11, pc
        ORR     lr, r11, #SVC_mode      ; go into SVC mode
        TEQP    lr, #0
        MOV     r0, r0
        Push    "lr"

 [ VetSCRValues
        BL      PerformSCRVetting
        BNE     %FT90                   ; if SCR bad, don't send it
 ]

        MOV     r0, #0
  [ CallSetSCRDirectly
        BL      CallSetSCR
  |
        SWI     XMPEGVideo_SetSCR
  ]
90
        Pull    "lr"
        TEQP    r11, #0
        MOV     r0, r0
        EXIT
 ]

 [ CallSetSCRDirectly
CallSetSCR Entry "r11, r12"
        ASSERT  SetSCRRoutine = SetSCRWorkspace +4
        ADR     r11, SetSCRWorkspace
        MOV     lr, pc
        LDMIA   r11, {r12, pc}
        EXIT
 ]

 [ VetSCRValues
; **************************************************************************
;
;       PerformSCRVetting - Check SCR for sensibility, and reject if not
;
; in:   r1 = bottom 32 bits of SCR
;       r2 = bit 32 of SCR
;
; out:  NE => reject this SCR value

PerformSCRVetting Entry "r0,r3"
        LDR     r3, VetSCRState
        CMP     r3, #1
        BCS     %FT20

; we're awaiting the 1st SCR

        LDR     r0, SpeedSetting
        TEQ     r0, #1                  ; only exit this state if in normal play mode
        BNE     %FT10                   ; return EQ, but do nothing
        BL      ConvertSCRToOffset
        STR     r0, GoodSCROffset
05
        MOV     r0, #1
        STR     r0, VetSCRState
10
        TEQ     r0, r0                  ; set EQ
        EXIT

20
        BL      ConvertSCRToOffset      ; convert new SCR into an offset from 100Hz time
        LDR     lr, GoodSCROffset       ; get last good offset
30
        SUBS    lr, lr, r0              ; compute difference
        RSBMI   lr, lr, #0              ; compute absolute difference
        CMP     lr, #SCRAcceptableRange ; is it within range
        STRCC   r0, GoodSCROffset       ; yes, then store new good offset
        BCC     %BT05                   ; then mark last one as good, and exit EQ

; we're out of range of the last good one, but are we consistent with the last bad one?

        CMP     r3, #2                  ; was the last one bad?
        STRNE   r0, BadSCROffset        ; if not, then store this as the 1st bad one
        MOVNE   r0, #2                  ; indicate last one was bad
        STRNE   r0, VetSCRState
        LDRNE   r0, BadSCRCount         ; increment count of bad ones
        ADDNE   r0, r0, #1
        STRNE   r0, BadSCRCount
        EXIT    NE                      ; and exit NE, indicating last one bad

        LDR     lr, BadSCROffset        ; get last bad offset
        MOV     r3, #1                  ; pretend last one was good, so we don't drop thru again
        B       %BT30

ConvertSCRToOffset Entry
        SWI     XOS_ReadMonotonicTime   ; returns in r0
        MOV     lr, #900                ; SCR is in 90kHz ticks, monotonic time is in 100Hz units
        MUL     r0, lr, r0              ; make into 90kHz units (don't care about overflow)
        SUB     r0, r1, r0              ; SCR - MT*900
        EXIT
 ]

; **************************************************************************
;
;       SendData - Send a block of data
;
; in:   r0 -> packet descriptor
;
; out:  r1-r3 corrupted
;       EQ => finished sending whole packet

SendData Entry "r4-r10"
        LDR     r1, [r0, #PacketDescriptor_Length]
        CMP     r1, #0
        EXIT    EQ                      ; cope with zero length packets - exit EQ implying finished with it

 [ :LNOT: UseBALE
        LDR     r2, StreamFlags
        TST     r2, #StreamFlags_UseCallBacks
        BNE     %FT07
        LDR     r2, OutstandingDataSize
        CMP     r1, r2
        MOVHI   r1, r2         ; move min(amount we've got, amount we're sending per IRQ)
07
        LDR     r2, Podule_StatusRegister
        LDR     r4, [r0, #PacketDescriptor_Start]
        MOV     r5, r1
  [ HandleNoDRAM
        LDR     r3, LocalBuffBase
        CMP     r3, #0
        BNE     %FT50                                   ; go handle local buffer case
  ]
        LDR     r3, Fast_Audio_Data                     ; otherwise address AV110 data port
10
        LDRB    r6, [r2]                                ; is FIFO full
        TST     r6, #MPEGPoduleStatus_AudioFIFOFull     ; if so then finish
        BNE     %FT20

        LDRB    r6, [r4], #1
        STRB    r6, [r3]
        SUBS    r5, r5, #1
        BNE     %BT10

20      SUB     r1, r1, r5                      ; this is number of bytes actually done
        B       %FT90

  [ HandleNoDRAM

50
; DREG	r5, "SendData, len = "

	LDR     r9, LocalBuffIn
        LDR     r10, LocalBuffFree
60      CMP     r10, #0                         ; check space in buffer
        BEQ     %FT80                           ;  if none left, stop
        LDRB    r6, [r4], #1
        STRB    r6, [r3, r9]
        ADD     r9, r9, #1                      ; step pointer
        BIC     r9, r9, #LocalBuffSize          ; force wrap around in buffer
        SUB     r10, r10, #1                    ; one less free
        SUBS    r5, r5, #1                      ; one less to move
        BNE     %BT60                           ; loop round if more yet

80      STR     r9, LocalBuffIn                 ; update in index
        SUB     r1, r1, r5                      ; calc number of bytes actually done

        MOV     lr, pc                          ; disable FIQs and IRQs round this bit
        ORR     r10, lr, #I_bit+F_bit
        TEQP    r10, #0
        LDR     r10, LocalBuffFree              ; load latest free count
        CMP     r10, #LocalBuffSize             ; is buffer currently empty?
        BEQ     %FT81                           ; if so, treat specially
                                                ; else...
        SUB     r10, r10, r1                    ; decrement free count by amount moved
        STR     r10, LocalBuffFree
        TEQP    lr, #0                          ; restore FIQ/IRQ state
        B       %FT90


81	; Local buffer was previously empty - FIQs from the AV110 must be
	; disabled; go send the data directly until either we run out, or
	; the AV110 shows FIFO full.  Then enable AV110 FIQs and let FIQ
	; code handle the rest.

        TEQP    lr, #0                          ; restore FIQ/IRQ state
        LDR     r9, LocalBuffOut                ; get out index, normally used by FIQ code
        LDR     r10, Fast_Audio_Data            ; get audio data port address for AV110
        MOV     lr, #0                          ; count how many bytes moved manually
82      LDR     r6, [r2]                        ; read state of AV110 REQ pin
        TST     r6, #MPEGPoduleStatus_AudioFIFOFull ; is AV110 no longer requesting?
        BNE     %FT84                           ; not requesting now - exit loop
        CMP     lr, r1                          ; done all the bytes?
        BEQ     %FT84                           ; exit loop if so, but still no FIQ

        LDRB    r6, [r3, r9]                    ; get the next output byte
        ADD     r9, r9, #1                      ; step out pointer
        BIC     r9, r9, #LocalBuffSize          ; wrap around
        STRB    r6, [r10]                       ; store the byte to the AV110
        ADD     lr, lr, #1                      ; count up how many moved out to AV110
        B       %BT82

84      STR     r9, LocalBuffOut                ; update output pointer
 [ FIQDebug
        ; DEBUG
        MOV     r10, #0
        LDR     r3, [r10, #&30]
        ADD     r3, r3, #1                      ; how many direct fills
        STR     r3, [r10, #&30]
        LDR     r3, [r10, #&34]
        ADD     r3, r3, lr                      ; bytes moved on direct fill
        STR     r3, [r10, #&34]
        ; END-DEBUG
 ]
        SUBS    lr, r1, lr                      ; calc how many still in buffer
        RSB     lr, lr, #LocalBuffSize          ; and hence how many free in buffer
        STR     lr, LocalBuffFree
        ; if still some in buffer (NE cond from SUBS above), turn on FIQs from AV110
        MOVNE   r3, #IOC
        MOVNE   r6, #AV110_FIQ_BIT
        STRNEB  r6, [r3, #IOCFIQMSK]            ; enable FIQs if required
  ]

90      TEQ     r5, #0                          ; if we didn't finish due to chip not ready
        MOVNE   r2, r1                          ; then we want outstandingdatasize to be set to 0
        LDREQ   r2, OutstandingDataSize         ; else load existing size
 |
        LDR     r2, OutstandingDataSize
        CMP     r1, r2
        MOVHI   r1, r2          ; move min(amount we've got, amount free in buffer)
        LDR     r3, Fast_Audio_Data
        LDR     r4, [r0, #PacketDescriptor_Start]
        MOV     r5, r1
10
        LDRB    r6, [r4], #1
        STRB    r6, [r3]
        SUBS    r5, r5, #1
        BNE     %BT10

 ]
        SUB     r2, r2, r1                              ; decrement outstanding data size by this amount
        STR     r2, OutstandingDataSize

        LDR     r2, AmountSent
        CMP     r2, #0
        BLT     %FT98
        ADD     r2, r2, r1
        LDR     lr, PreFillBufferSize
        CMP     r2, lr
; DREG r2, "Amount sent now "
        STR     r2, AmountSent
        BLCS    IssuePlaySWI
98
        OutputSentCount r1                              ; output fact that r1 bytes were sent (excluding packet headers)
        STR     r4, [r0, #PacketDescriptor_Start]       ; advance start address in packet
        LDR     r2, [r0, #PacketDescriptor_Length]
        SUBS    r2, r2, r1                              ; EQ => finished whole packet
        STR     r2, [r0, #PacketDescriptor_Length]
        EXIT

IssuePlaySWI Entry "r0-r1"
; DREG    r2, "Audio ready, amount sent = "
        MOV     r2, #-1
        STR     r2, AmountSent
        MOV     r0, #StreamFlags_AudioPresent
        LDR     r1, ControlStreamHandle
        SWI     XMPEGControl_Play
        EXIT

; **************************************************************************
;
;       FreePacket - Free a packet
;
; in:   r0 -> packet descriptor
;
; out:  r0 -> next packet descriptor (or 0 if no more)
;       Also updates PacketListHeadPtr, PacketListTailPtr
;       PSR preserved
;

FreePacket ROUT
        Push    "r1, lr"
        MOV     r1, pc
        ORR     lr, r1, #I_bit
        TEQP    lr, #0                          ; disable IRQs round this

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, PacketListHeadPtr           ; update PacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, PacketListTailPtr           ; then zero PacketListTailPtr

        TEQP    r1, #0                          ; restore IRQ state

        Push    "lr"
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
        MOV     lr, pc
        LDR     pc, [r0, #PacketDescriptor_FreeRoutine]
        Pull    "r0,r1, pc",,^                     ; exit preserving flags

; **************************************************************************
;
;       DoStreamSync - Synchronise to stream (if required)
;
; in:   -
; out:  -

DoStreamSync Entry "r0-r2"
        LDR     r0, StreamClosing       ; if not active, exit
        TEQ     r0, #0
        EXIT    NE

        LDR     r2, AV110_Base
 [ HandleNoDRAM
        LDR     lr, LocalBuffBase               ; check whether AV110 has DRAM
        CMP     lr, #0                          ; if not, use local buffer count
        LDRNE   r0, LocalBuffFree               ;   find current free bytes in buffer
        RSBNE   r0, r0, #LocalBuffSize          ;   convert to used bytes in buffer
        MOVNE   r0, r0, LSR #2                  ;   convert to used words
        BNE     %FT10
                                                ; else ask AV110 for its reckoning
 ]
        ADD     r0, r2, #AV110_BUFF_0
        ASSERT  AV110_BUFF_1 = AV110_BUFF_0 +4
        LDMIA   r0, {r0, r1}
        AND     r0, r0, #&FF
        AND     r1, r1, #&FF
        ORR     r0, r0, r1, LSL #8
10
        OutputFullness r0

        LDRB    r1, [r2, #AV110_PLAY]           ; are we playing at the moment?
        TEQ     r1, #1
        EXIT    NE                              ; no, so don't try to sync
 [ DelayPauseCommands
        LDR     r1, NotPendingPause             ; also, don't try to sync if pause is pending
        TEQ     r1, #0
        EXIT    EQ
 ]
        LDR     r1, StreamFlags
        TST     r1, #StreamFlags_SyncToStream
        EXIT    EQ
        LDR     r1, ResyncDelay
        SUBS    r1, r1, #1
        STRCS   r1, ResyncDelay
        EXIT    CS

 [ HandleNoDRAM
	LDR	r1, ThresholdChecks
	ADD	r1, r1, #1
	STR	r1, ThresholdChecks
 ]
        LDR     r1, =AudioBufferLowWaterMark
        CMP     r0, r1
        MOVCC   r1, #5
        STRCC   r1, ResyncDelay
        BLCC    RepeatFrame

        LDR     r1, =AudioBufferHighWaterMark
        CMP     r0, r1
        MOVCS   r1, #5
        STRCS   r1, ResyncDelay
        BLCS    SkipFrame
        EXIT

 [ CheckSampleRate
; **************************************************************************
;
;       DoCheckSampleRate - Check sample rate bits in chip and adjust divisor
;
; in:   -
; out:  r0-r3, r11 may be corrupted

DoCheckSampleRate Entry
        LDR     r11, AV110_Base
        LDRB    r3, [r11, #AV110_PCM_FS]
        AND     r3, r3, #3
        CMP     r3, #2
        EXIT    HI                              ; if > 2 then unknown, so do nothing
        STR     r3, SampleRate
        MOVEQ   r0, #12                         ; if = 2 then 32kHz, so set divisor to 12
        MOVNE   r0, #8                          ; else 44.1 or 48kHz, so set divisor to 8
        STR     r0, PCM_DIV_Copy
        LDR     r1, SpeedSetting                ; get speed setting
        TEQ     r1, #0                          ; if paused
        MOVEQ   r1, #1                          ; then use normal speed (irrelevant)
        MOVMI   r1, #1                          ; or if pre-buffering then use normal speed
        MUL     r1, r0, r1
        CMP     r1, #32
        MOVHI   r1, #32
        STRB    r1, [r11, #AV110_PCM_DIV]

        TEQ     r3, #0                          ; if 44.1 kHz
        MOVEQ   r1, #MPEGPoduleControl_CLKSelect ; then set bit in control register
        MOVNE   r1, #0                          ; else clear bit
        MVN     r2, #MPEGPoduleControl_CLKSelect ; AND mask
        MOV     r0, #CardControlReason_UpdateControlRegister
        SWI     XMPEGVideo_CardControl
        CLRV                                    ; ignore errors
        EXIT
 ]


; **********************************************************************
;
;       FindSyncWord - find offset in data to (probable) start of MPEG
;       audio frame.
;
;  in: r0 -> packet descriptor
; out: r2 = number of bytes in data before &FF(.&Fx, where x=C,D,E,F),
;           or -1 if not found;
;      r3 = 0 if only the sync byte (and possibly header) have been validated,
;         = total size of frame, if next sync was also at least minimally validated.
;
; If found, as many validation checks as possible, up to and including
; validating the header of the next frame, have been done.  This depends
; on amount of data in buffer beyond where sync word was found.
;


FindSyncWord Entry "r0,r1,r4,r5,r6,r7,r8"

	MVN	r3, #0			; start at -1 for convenience
05      ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT99			; end of data -> failure without any match
        CMP     r1, #&FF		; look for &FF to start with
	BNE	%BT05
	B	%FT20

10      ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT97			; end of data -> failure ("slight match")
        CMP     r1, #&FF		; look for &FF to start with
	BNE	%BT10

20	MOV	r2, r3			; assume we are at the right point, for now, set r2
	ADD	r3, r3, #1		; check byte after &FF
	BL	FetchByte
	BMI	%FT95			; if no byte to be had, say it's OK, but r3=0
        AND     r5, r1, #&FC		; check for &FC..&FF
        CMP     r5, #&FC		; found OK?
        BNE     %BT10			; go back to looking for &FF if not

30
        ; Try to build up bottom 24 bits of header in r4 (top 8 bits fixed so ignore)
	MOV	r4, r1
	ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT95
	ORR	r4, r1, r4, LSL #8
	ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT95
	ORR	r4, r1, r4, LSL #8

        ; Check for internal consistency in this header
        BL      CheckHeader
        BEQ     %BT10			; returns EQ on failure, NE on success

        ; Work out size of total frame into r8, using fields extracted by CheckHeader
        ;  r4 = header as above
        ;  r5 = sample-rate index
        ;  r6 = layer (1 or 2)
        ;  r7 = bit-rate index

40      ADD     r7, r7, r7, LSL #1	; multiply bit-rate index by 3 since
					; 3 entries in each position, by sample-rate
        ADD     r7, r7, r5		; add sample-rate to get to right entry
        CMP     r6, #2			; switch out according to layer
        BEQ     %FT50

        ; Layer I computation
        ADR     r1, rate_tab_I
        LDRB    r1, [r1, r7]		; pick up byte-wide entry
        TST     r4, #1<<9		; check padding bit in header
        ADDNE   r1, r1, #1		; one more slot if it was set
        MOV     r8, r1, LSL #2		; convert from words to bytes
        B       %FT60

50      ; Layer II computation
        ADR     r1, rate_tab_II
        LDR     r1, [r1, r7, LSL #1]	; pick up half-word-wide entry as word
        MOV     r1, r1, LSL #16		; and clear out top 16 bits (junk)
        MOV     r8, r1, LSR #16		; produce answer in r8
        TST     r4, #1<<9		; check padding bit in header
        ADDNE   r8, r8, #1		; one more slot if it was set


60      ; We now have the size of the frame in r8; try to pick up next header also
	ADD	r3, r2, r8
	BL	FetchByte
	BMI	%FT95			; if -ve, can't get next putative sync start byte
					; so assume match, based on first header being OK

	CMP	r1, #&FF		; got byte, is it sync?
	MOVNE	r3, r2			; if not, try all over again
	BNE	%BT10

	ADD	r3, r3, #1		; OK, step on...
	BL	FetchByte		; and try 2nd byte of putative 2nd header
	BMI	%FT91			; if -ve, assume a match on it, given &FF

	AND	r5, r1, #&FC		; do usual check on 2nd byte
	CMP	r5, #&FC		; is it OK?
	MOVNE	r3, r2			; if not, try all over again
	BNE	%BT10

	; Again try to build up header
	MOV	r4, r1
	ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT91			; return OK if can't see 3rd byte
	ORR	r4, r1, r4, LSL #8
	ADD	r3, r3, #1
	BL	FetchByte
	BMI	%FT91			; return OK if can't see 4th byte
	ORR	r4, r1, r4, LSL #8

        BL      CheckHeader		; go check full header
	MOVEQ	r3, r2			; if header inconsistent (EQ),
        BEQ     %BT10			;   go round again
					; else we're successful

91	MOV	r3, r8			; set frame size in r3 on return
	EXIT				; maximum success!

95      MOV	r3, #0			;    only 1 header checked, so framesize = 0
        EXIT				;    return

97	; ran out of data without matching &FF.Fx, but having seen one &FF

99      ; ran out of data without finding (possible) sync word
        MVN     r2, #0			; marks failure
        EXIT				; go home



; Tables for working out frame size based on bit-rate, sampling frequency,
; layer and padding bit.  Table entries are measured in units of slots where
; a slot is 32 bits in layer I and 8 bits in layer 2.  Frame encodes 384 samples
; in layer I and 1152 samples in layer 2.  Longest frame is in layer II, at
; 32kHz sampling frequency, 384000 bits/sec, -> 1728 bytes.  Hence need to
; use half-words in table for layer II, whereas bytes will suffice for layer a1
; since longest frame then is 448000*384/32000/32 = 168 slots (672 bytes).
;
; Entries are ordered by sample rate as per sample-rate field in header:
;   0 -> 44.1kHz,  1 -> 48kHz,   2 -> 32kHz
;
; Hence each table is indexed by (bit rate index * 3) + sample rate index
;
; Note: arithmetic here in some cases produces fractional results which get
; truncated to integer: padding bit in header controls whether one extra slot
; is added in some frames to keep average bit rate correct.

        MACRO
        fsizes_I        $bitrate
        DCB     $bitrate*384/44100/32, $bitrate*384/48000/32, $bitrate*384/32000/32
        MEND

        MACRO
        fsizes_II       $bitrate
        DCW     $bitrate*1152/44100/8, $bitrate*1152/48000/8, $bitrate*1152/32000/8
        MEND

rate_tab_I
        fsizes_I        0
        fsizes_I        32000
        fsizes_I        64000
        fsizes_I        96000
        fsizes_I        128000
        fsizes_I        160000
        fsizes_I        192000
        fsizes_I        224000
        fsizes_I        256000
        fsizes_I        288000
        fsizes_I        320000
        fsizes_I        352000
        fsizes_I        384000
        fsizes_I        416000
        fsizes_I        448000

        ALIGN

rate_tab_II
        fsizes_II       0
        fsizes_II       32000
        fsizes_II       48000
        fsizes_II       56000
        fsizes_II       64000
        fsizes_II       80000
        fsizes_II       96000
        fsizes_II       112000
        fsizes_II       128000
        fsizes_II       160000
        fsizes_II       192000
        fsizes_II       224000
        fsizes_II       256000
        fsizes_II       320000
        fsizes_II       384000

        ALIGN



; **********************************************************************
;
;	FetchByte - subroutine of FindSyncWord
;
; in: r0 -> packet descriptor
;     r3 = offset in whole packet of byte needed
; out: r1 = byte needed and PL condition (N clear), or r1=-1 and MI (N set) if outside packet
FetchByte Entry "r0,r3"
10	LDR	r1, [r0, #PacketDescriptor_Length]
	CMP	r1, r3			; if length > offset
	LDRGT	lr, [r0, #PacketDescriptor_Start] ; then address data
	LDRGTB	r1, [lr, r3]		; and pick up the byte
	EXIT	GT			; and go home, with N clear
	LDR	r0, [r0, #PacketDescriptor_Link] ; skip to next segment
	CMP	r0, #0			; if not at end of list
	SUBNE	r3, r3, r1		; adjust offset by size of last segment
	BNE	%BT10

90	MVNS	r1, #0			; failed: go home with r1 = -1 and N set
	EXIT



; **********************************************************************
;
;       CheckHeader - validate MPEG audio header bits
;
; in:  r4 = header last 24 bits
; out: r4 = header last 24 bits
;      cc = EQ: failure, r5-r7 corrupted
;      cc = NE: OK:     r5 = sampling freq code (0=44.1,1=48,2=32)
;                       r6 = layer (1 or 2)
;                       r7 = bit-rate index from header
CheckHeader Entry "r2"

        ; Check for invalid combinations
        ; (1) Bit-rate index field (keep it for later also).
        MOV     r7, r4, LSR #12                 ; extract bit-rate index field into r7
        ANDS    r7, r7, #&F                     ; (4 bits worth only)
        CMPNE   r7, #&F                         ; if not free-format, check for forbidden value
        EXIT    EQ                              ;     and reject in either case

        ; (2) De-emphasis field - expecting 0 always but allow either of the 2
        ; other valid values.
        AND     r5, r4, #3                      ; bottom 2 bits of r4
        CMP     r5, #2                          ; value 2 is reserved
        EXIT    EQ                              ; reject it

        ; (3) Sampling frequency field - keep in r5 for later
        MOV     r5, r4, LSR #10
        AND     r5, r5, #3                      ; 2 bits worth only
        CMP     r5, #3                          ; value 3 is forbidden
        EXIT    EQ                              ; reject it

        ; Determine coding format: layer I or layer II, put 1 or 2 into r6

        TST     r4, #1<<17                      ; 0 for Layer II, 1 for Layer I
        MOVNE   r6, #1                          ; NE -> layer I
        MOVEQ   r6, #2                          ; EQ -> layer II

        ; For layer I, all checks are now done, exit with NE cond for success
        EXIT    NE

        ; In layer II only, check mode against bit-rate: some combinations are
        ; illegal.

        ADR     r2, mod_rate_tab
        LDRB    r2, [r2, r7]                    ; get table entry for bit-rate index
        MOV     lr, r4, LSR #6                  ; extract mode field from header
        AND     lr, lr, #3                      ; (2 bits worth)
        MOV     r2, r2, LSR lr                  ; check for mode bit in table
        TST     r2, #1                          ; being set (valid)

        ; condition NE means OK, and CheckHeader succeeds, else EQ for failure

        EXIT                                    ; all done

mod_rate_tab
        DCB     2_0000          ; f/f
        DCB     2_1000          ;  32
        DCB     2_1000          ;  48
        DCB     2_1000          ;  56
        DCB     2_1111          ;  64
        DCB     2_1000          ;  80
        DCB     2_1111          ;  96
        DCB     2_1111          ; 112
        DCB     2_1111          ; 128
        DCB     2_1111          ; 160
        DCB     2_1111          ; 192
        DCB     2_0111          ; 224
        DCB     2_0111          ; 256
        DCB     2_0111          ; 320
        DCB     2_0111          ; 384


; **************************************************************************
;
;       CheckForSyncWord - Skip data until sync word, if necessary
;
; in:   r0 -> packet descriptor
; out:  EQ => OK, carry on; NE => don't progress, not skipped yet

CheckForSyncWord Entry "r1-r5"
        LDR     lr, StreamFlags
        TST     lr, #StreamFlags_AudioSkipToSync ; if not skipping to sync word, or have already found it,
        EXIT    EQ                               ; then we can get on, so exit EQ

05
        LDR     r1, [r0, #PacketDescriptor_Start]
        LDR     r2, [r0, #PacketDescriptor_Length]
        MOV     r4, #0                          ; state: 0 => waiting for &FF, &0F => waiting for &Fx
        MOV     r5, r1
07
        MOV     r3, #0
10
        LDRB    lr, [r1,r3]
        ORR     lr, lr, r4
        TEQ     lr, #&FF                        ; is it next required byte (&FF or &Fx)?
        BNE     %FT20

        TEQ     r4, #0                          ; have we just got &FF?
        MOVEQ   r4, #&0F
        BEQ     %FT30                           ; [yes, so now look for &Fx]

; we've found the synchronisation word at offset r3-1 in this packet (but r3 may be zero!)

        TEQ     r3, #0                          ; if sync word split across two packets
        SUBEQ   r3, r2, #1                      ; then number of bytes skipped is length of 1st -1
        SUBNE   r3, r3, #1                      ; else skip r3-1 bytes
        SUB     r2, r2, r3                      ; reduce length
        STR     r2, [r0, #PacketDescriptor_Length] ; and store it back
        ADD     r5, r5, r3                      ; increase start address
        STR     r5, [r0, #PacketDescriptor_Start] ; and store back
        LDR     r5, [r0, #PacketDescriptor_Flags] ; if start of MPEG packet
        TST     r5, #PacketDescriptorFlags_MPEGStart
        LDRNE   r5, [r0, #PacketDescriptor_FullLength] ; then decrement full length as well
        SUBNE   r5, r5, r3
        STRNE   r5, [r0, #PacketDescriptor_FullLength]

        LDR     lr, StreamFlags
        BIC     lr, lr, #StreamFlags_AudioSkipToSync ; knock out sync waiting bit
        STR     lr, StreamFlags

        TEQ     r0, r0                  ; set EQ, to indicate that everything's tickety-boo
        EXIT

; it's not the required byte

20
        TEQ     r1, r5                          ; have we just crossed a packet boundary?
        BEQ     %FT25                           ; [no]
22
        BL      FreePacket                      ; the old packet doesn't have a sync word, so junk it
        CMP     r0, #1                          ; have we more packets (r0<>0)
        BCS     %BT05                           ; if so then scan that
        EXIT                                    ; else r0 = 0 so exit NE indicating wait

25
        MOV     r4, #0                          ; reset to looking for &FF
30
        ADD     r3, r3, #1
        CMP     r3, r2
        BCC     %BT10

        TEQ     r4, #0                          ; are we half way through the sync word?
        BEQ     %BT22                           ; if not then free the packet straight away

        LDR     r1, [r0, #PacketDescriptor_Link] ; else go onto next packet, keeping prev in r5
        CMP     r1, #1
        BCS     %BT07                           ; if there is one, then set r3 back to 0 and loop
        EXIT                                    ; if no next packet yet, then exit NE

; **************************************************************************
;
;       ResetStream - Discard all data and reset AV110
;
; in:   r0 = flags (ignored in code below)
;         bit 0 set => video data in new stream
;         bit 1 set => audio data in new stream
;	  bit 8 set => start in pause mode after reset (even after prefilling)
;       r1 = audio stream handle
;
; out:  r2 = estimate of number of bytes discarded

ResetStream Entry "r0-r2"
        LDR     r11, AV110_Base

        MOV     r2, #1			; pretend we're closing, so we don't send any more data to it in background
        STR     r2, StreamClosing

        BL      GetBufferFullness	; returns current fullness in r2

 [ HandleNoDRAM
        LDR     r0, LocalBuffBase
        CMP     r0, #0
	BEQ	%FT20
	; Turn off background data transfers now
	BL	ClearFIQVars
	BL	ReleaseFIQVector
20
 ]
        LDR     r0, PacketListHeadPtr
10
        TEQ     r0, #0			; any more packets?
        LDRNE   lr, [r0, #PacketDescriptor_Length] ; if so then add up length
        ADDNE   r2, r2, lr
        BLNE    FreePacket		; and free the packet
        BNE     %BT10			; then loop

        STR     r2, [sp, #2*4]		; update returned r2 value with byte count

        MOV     r0, #0
        STR     r0, AmountSent		; need to pre fill buffer
 [ VetSCRValues
        STR     r0, VetSCRState		; awaiting first SCR again
 ]

	LDR	r0, [sp, #0*4]		; get input flags
	TST	r0, #StreamFlags_StartPaused ; should we be paused after the reset?
        MOVEQ   r0, #&80000001		; would be playing, if we weren't pre-buffering
	MOVNE	r0, #&80000000		; enter pause mode after pre-buffering
        STR     r0, SpeedSetting

        LDR     r0, OriginalStreamFlags	; put back skiptosync bit if was there originally
        STR     r0, StreamFlags

        MOV     r0, #1
        STRB    r0, [r11, #AV110_RESET]	; issue reset command to AV110

 [ PauseAfterResetStream
30
	LDRB	r0, [r11, #AV110_RESET]
	TEQ	r0, #0
	BNE	%BT30			; wait until it's come out of reset

	MOV	r2, #1			; would be normal play if not pre-buffering
	BL	SetSpeed		; put it into pause mode
 ]

 [ HandleNoDRAM
	LDR	r0, LocalBuffBase
	CMP	r0, #0
	BLNE	ClaimFIQVector
 ]
	MOV	r0, #0
	STR	r0, StreamClosing	; now can send data again

        CLRV
        EXIT

; **************************************************************************
;
;       GetBufferFullness - Read amount of data in input buffer
;
; in:   r11 -> AV110_Base
;
; out:  r2 = amount of data in bytes
;

GetBufferFullness Entry
 [ HandleNoDRAM
        ; Check for presence/absence of DRAM on AV110 (i.e. absence or
        ; presence of a local buffer respectively).
        LDR     r2, LocalBuffBase
        CMP     r2, #0
        BEQ     %FT10
        ; If using local buffering (no DRAM on AV110), measure contents of
        ; that, and add in what's in the AV110's small internal buffer at this
        ; point, before it gets reset.  The AV110 may still be swallowing data
        ; so the result is not precise, but it's quite good enough for the
        ; purpose.
        LDR     r2, LocalBuffFree               ; grab current local buffer free count
        RSB     r2, r2, #LocalBuffSize          ; compute local buffer in-use count (bytes)
        LDRB    lr, [r11, #AV110_BUFF_0]        ; grab AV110 current in-use count (words):
                                                ; at most 256/4, so no need to read high bits
        ADD     r2, r2, lr, LSL #2              ; scale words->bytes and add for result
        EXIT
10
 ]
        ; Otherwise read size of buffer in AV110 external DRAM
        ADD     r2, r11, #AV110_BUFF_0
        ASSERT  AV110_BUFF_1 = AV110_BUFF_0 +4
        LDMIA   r2, {r2, r14}
        AND     r2, r2, #&FF
        AND     r14, r14, #&FF
        ORR     r2, r2, r14, LSL #8
        MOV     r2, r2, LSL #2                  ; convert from 32-bit words to bytes
        EXIT

; **************************************************************************
;
;	Stats - Entry point for MPEGAudio_Stats - return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = audio stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

	MACRO
	StatsTableEntry	$tag, $value
 [ :BASE: ($value) = 12
	&	$tag, :INDEX: ($value)
 |
	ASSERT	:BASE: $value = 15
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

Stats	Entry "r2, r5-r6"

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	EXIT	EQ				; then exit

	ADR	r6, StatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [wp, lr]
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

; The statistics that are done by routine:
; (must come before StatsTable so not forward reference)

Stats_SampleRate Entry
	LDR	lr, SampleRate
	ADR	r6, SampleRateHzTable
	LDR	r6, [r6, lr, LSL #2]
	EXIT

SampleRateHzTable
	&	44100, 48000, 32000, 0

; The table containing all the statistics

StatsTable
	StatsTableEntry &2000, Skips
	StatsTableEntry &2001, Repeats
	StatsTableEntry &2002, TotalReceived
	StatsTableEntry &2003, Stats_SampleRate
	StatsTableEntry &2004, BadSCRCount
	StatsTableEntry &2005, PTSInCount
	StatsTableEntry &2006, PTSOutCount
 [ HandleNoDRAM
	StatsTableEntry &2007, PTSMissCount
	StatsTableEntry &2008, PTSDropCount
	StatsTableEntry &2009, PTSDuffCount
	StatsTableEntry &200A, PTSQinCount
	StatsTableEntry &200B, PTSQoutCount
	StatsTableEntry &200C, PTSDiscCount
	StatsTableEntry &200D, PTSOVRNCount
	StatsTableEntry &200E, PTSIGNPCount
	StatsTableEntry &200F, PTSIGNSCount
	StatsTableEntry &2010, PTSSentCount
	StatsTableEntry &2011, ThresholdChecks
 ]
	&	-1

; **************************************************************************
;
;       AudioInfo_Code - AudioInfo *-command

AudioInfo_Code Entry "r0"
        LDR     wp, [r12]
 [ HandleNoDRAM
        LDR     r0, PTSInCount
        DREG    r0, "PTSs  in: "
        LDR     r0, PTSMissCount
        DREG    r0, "  missed: "
        LDR     r0, PTSDropCount
        DREG    r0, " dropped: "
        LDR     r0, PTSDuffCount
        DREG    r0, " badsync: "
	LDR	r0, PTSQinCount
	DREG	r0, "    Q in: "
	LDR	r0, PTSQoutCount
	DREG	r0, "   Q out: "
	LDR	r0, PTSDiscCount
	DREG	r0, " discard: "
        LDR     r0, PTSOutCount
        DREG    r0, "   fired: "
        LDR     r0, PTSOVRNCount
        DREG    r0, " overrun: "
        LDR     r0, PTSIGNPCount
        DREG    r0, "  paused: "
        LDR     r0, PTSIGNSCount
        DREG    r0, "  slowmo: "
        LDR     r0, PTSSentCount
        DREG    r0, "SCRs set: "
	LDR	r0, ThresholdChecks
	DREG	r0, "Threshold checks: "
 |
        LDR     r0, PTSInCount
        DREG    r0, "PTSs  in: "
        LDR     r0, PTSOutCount
        DREG    r0, "     out: "
 ]
        LDR     r0, Skips
        DREG    r0, "Skipped frames: "
        LDR     r0, Repeats
        DREG    r0, "Repeated frames: "
        LDR     r0, TotalReceived
        DREG    r0, "Total bytes received: "
 [ CheckSampleRate
        DLINE   "Sample rate: ", cc
        LDR     r0, SampleRate
        ADR     lr, SampleRateStringOffsets
        LDR     r0, [lr, r0, LSL #2]
        ADD     r0, r0, lr
        SWI     XOS_Write0
        SWIVC   XOS_NewLine
        STRVS   r0, [sp]
 ]
 [ VetSCRValues
        LDR     r0, BadSCRCount
        DREG    r0, "Bad SCR values: "
 ]
        EXIT

 [ CheckSampleRate
SampleRateStringOffsets
        &       SR441-SampleRateStringOffsets
        &       SR480-SampleRateStringOffsets
        &       SR320-SampleRateStringOffsets
        &       SRUK-SampleRateStringOffsets

SR441   =       "44.1kHz", 0
SR480   =       "48kHz", 0
SR320   =       "32kHz", 0
SRUK    =       "Unknown", 0
        ALIGN
 ]

 [ CollectDebugStats
; **************************************************************************
;
;       OutputDebugRoutine - Store value in debug array,
;
; in:   r0 = debug value
;

OutputDebugRoutine Entry "r1-r3"
        MOV     r1, pc
        ORR     lr, r1, #I_bit          ; disable IRQs round this
        TEQP    lr, #0

        LDR     lr, DebugArrayFree
        TEQ     lr, #0
        BEQ     %FT90                   ; [no slots free or haven't started playing yet]
        SUB     lr, lr, #1
        STR     lr, DebugArrayFree

        LDR     lr, DebugArrayPtr
        STR     r0, [lr], #4
        STR     lr, DebugArrayPtr
90
        TEQP    r1, #0
        EXIT
 ]


; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END

