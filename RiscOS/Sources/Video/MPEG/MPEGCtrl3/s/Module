; > Module
; Source for MPEGControl Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 07-Sep-00  BJGA 3.00          Started work merging MPEGSystem and MPEGTransport modules
;

TAB     *       9
LF      *       10
FF      *       12
CR      *       13


		GBLL	OnlyAcceptFirstPATandPMT
OnlyAcceptFirstPATandPMT SETL {FALSE}			; for use with a faint signal, since we don't check CRCs.

                GBLL    Capture
Capture         SETL    {TRUE}                          ; include *MPEGCapture and *MPEGSave

                GBLL    CountDiscontinuities
CountDiscontinuities SETL {TRUE} :LAND: DoPEH           ; count jumps in continuity_counter for PEH PIDs

                GBLL    EOSDetect
EOSDetect       SETL    {TRUE}                          ; detect end-of-stream / timeouts
Timeout_Time    *       500                             ; centiseconds at full speed

                GBLL    DebugNPT
DebugNPT        SETL    {FALSE}                         ; print NPT debug to vdu

                GBLL    DebugPID
DebugPID        SETL    {FALSE}                         ; print PID debug to vdu

                GBLL    DebugEOS
DebugEOS        SETL    {FALSE}                         ; print EOS debug to vdu

                GBLL    debug
debug           SETL    {FALSE}	                        ; this enables NdrDebug real-time debugging

                GBLL    hostvdu
                GBLL    debug_module
                GBLL    pdebug_module
                GBLL    dadebug_module
hostvdu         SETL    {FALSE}	                        ;
debug_module    SETL    {FALSE}	                        ; set preferred output route
pdebug_module   SETL    {FALSE}	                        ; if all false, then output sent to file
dadebug_module  SETL    {FALSE}	                        ;

                GBLL    debugentry
debugentry      SETL    {FALSE}	                        ; SWI entry points

; If playing elementary streams, we need to chop up large buffers longer than 64K into smaller
; chunks, because the maximum MPEG packet size is 64K

MaxMPEGPacketLength     *       &FF00                   ; allow some space for packet headers as well

TS_PacketLength         *       188                     ; length of transport stream packets (in bytes)
TS_SyncByte             *       &47                     ; transport stream sync byte
TS_TEI_Bit              *       &80 :SHL: 8             ; transport_error_indicator (in byte 1 of header)
TS_PUSI_Bit             *       &40 :SHL: 8             ; payload_unit_start_indicator (in byte 1)
TS_TP_Bit               *       &20 :SHL: 8             ; transport_priority (in byte 1)
TS_TSC_Bits             *       &C0                     ; transport_scrambling_control (in byte 3)
TS_AF_Present_Bit       *       &20                     ; indicates adaptation field present (in byte 3)
TS_Payload_Present_Bit  *       &10                     ; indicates payload present (in byte 3)
TS_CC_Bits              *       &0F                     ; continuity counter bits (in byte 3)

; Table ID values

TS_table_id_PAT         *       &00                     ; program association table section
TS_table_id_PMT         *       &02                     ; program map section

TS_Stream_Type_MPEG1Video *     &01
TS_Stream_Type_MPEG2Video *	&02
TS_Stream_Type_MPEG1Audio *     &03
TS_Stream_Type_MPEG2Audio *	&04

; PES packet header optional flags

PES_Optional_PTS_Present	*	&80		; PTS field present
PES_Optional_DTS_Present	*	&40		; DTS field present
PES_Optional_ESCR_flag		*	&20		; ESCR fields present
PES_Optional_ES_rate_flag	*	&10		; ES_rate field present
PES_Optional_DSM_trick_mode_flag *	&08		; DSM_trick_mode_flag present
PES_Optional_additional_copy_info_flag * &04		; additional copy info present
PES_Optional_PES_CRC_flag	*	&02		; PES_CRC present
PES_Optional_PES_extension_flag *	&01		; PES extensions present

; The DVB card has a PID filter which allows up to 32 programmable PIDs to be captured
; These are the PID slot indices used for the various streams

				^	0
PIDSlot_Video			#	1
PIDSlot_Audio			#	1
PIDSlot_PAT			#	1		; (PID 0, enabled by MPEG player !RunImage currently)
PIDSlot_PMT			#	1
PIDSlot_Extra			#	0		; base of PID slots used for additional handlers

NumberOfPIDSlots		*	32
		ASSERT	@ <= NumberOfPIDSlots-1		; make sure we have at least one PID slot for extras

 [ DoPEH
; Program Element Handler structure (global)

				^	0
PEH_Link			#	4		; link to next one
PEH_Flags			#	4		; flags relevant to handler
PEH_StreamType			#	4		; stream type
PEH_HandlerWS			#	4		; workspace pointer
PEH_HandlerCode			#	4		; entry point for handler
PEHSize				*	:INDEX: @

; Program Element PID structure (local to stream)

				^	0
PEHPID_Link			#	4		; link to next one
PEHPID_Flags			#	4		; flags relevant to handler for this stream
PEHPID_ProgramElementStreamHandle #	4		; stream handle to use when talking to PEH
PEHPID_PID			#	4		; the PID that this stream type is currently using
							; (this field may change during life of stream)
PEHPID_PIDSlot			#	4		; PID slot used in DVB card, allocated at time of OpenStream
PEHPID_PEH			#	4		; pointer to PEH node
 [ CountDiscontinuities
PEHPID_LastContinuityCounter    #       4               ; previous setting of continuity_counter for this PID
PEHPID_Discontinuities          #       4               ; number of times continuity_counter jumped
 ]
PEHPIDSize			*	:INDEX: @
 ] ; DoPEH

; Control stream handle structure

                        ^       0
CSH_ModuleWsPtr         #       4
CSH_StreamFlags         #       4
CSH_VideoStreamHandle   #       4
CSH_AudioStreamHandle   #       4
CSH_CoroutineStackCopy  #	4			; pointer to copy of coroutine stack claimed out of RMA
CSH_CoroutineStackBlockSize #	4			; size of block allocated
CSH_CoroutineStackSize	#	4			; number of words currently on stack
CSH_ExternalSP          #       4                       ; external stack pointer for coroutines
CSH_PMT_PID             #       4                       ; PID for packets containing Program Map Table (-1 if unknown)
CSH_Video_PID           #       4                       ; PID for video packets
CSH_Audio_PID           #       4                       ; PID for audio packets
CSH_NotReadyBits        #       4                       ; bits indicating which elemental modules are not yet ready to play
CSH_StartTime           #       4                       ; time stream was opened
CSH_PlayTime            #       4                       ; time stream started to play
CSH_LastTime            #       4                       ; last time data was received
CSH_DataReceived        #       4                       ; amount of data received
CSH_DataReceivedAtPlayTime #    4                       ; amount of data received during prefill
CSH_DataReturned	#	4			; amount of data returned
CSH_EndOfStreamReceived	#	4			; 0 normally, 1 when (system/program stream) end of stream code has been received
CSH_SyncLosses		#	4			; number of times system stream had discontinuity
CSH_TooShortPackets	#	4			; number of system/program stream packets whose header exceeded the packet length
CSH_DataDiscarded	#	4			; amount of transport stream data discarded (not video, audio, PAT, PMT or selected private)
CSH_CurrentProgram	#	4			; program number of current program, or -index (eg -1 = first program)
CSH_CurrentVideoStream	#	4			; index of video stream to select within program (1 => 1st)
CSH_TempVideoStream	#	4			; temporary decrementing copy of above
CSH_CurrentAudioStream	#	4			; index of video stream to select within program (1 => 1st)
CSH_TempAudioStream	#	4			; temporary decrementing copy of above

CSH_LastResetStreamFlags #	4			; bits indicating what streams are active after last resetstream
CSH_CloseStreamFlags    #       4                       ; flags passed to MPEGControl_CloseStream
CSH_NextResetStreamFlags #      4                       ; flag bits to use if/when there is an internal reset (good-data-follows or segment-transition)
CSH_NextSpeedIndicator  #       4                       ; for holding the speed indicator for the next stream, if an internal reset is pending
CSH_SpeedIndicator      #       4                       ; the current speed indicator (for general use)
 [ DoPEH
CSH_ListOfPEHPIDs	#	4			; pointer to 1st PEHPID node for this stream
 ]

CSH_TrickModeControl	#	4			; value required in trick_mode_control field, or -1 for normal
CSH_LastTrickModeControl #	4			; last value we actually had for trick_mode_control (or -1)

 [ DataRateStats
DataCountPeriod         *       300                     ; seconds in 1 period
DataCountArraySize      *       100                     ; allow for 100 periods at present
CSH_DataCounts          #       DataCountArraySize * 4  ; one word per minute
 ]

CSH_NPTCurrent		#	4			; 1 => NPT received since last ResetStream, 0 otherwise
CSH_NPTDescLength	#	1
CSH_NPTDescMaxLen	*	18			; we can store maximum of 18 bytes of descriptor (not including len)
CSH_NPTContentID	#	1			; bit 7 if postDiscontinuityIndicator (unused)
							; bits 6..0 are the content ID (incremented for each command)
CSH_NPTSTCRef		#	5			; 1st 7 bits reserved, last 33 are STC_Reference
CSH_NPTNPTRef		#	8			; 1st 31 bits reserved, last 33 are NPT_Reference
CSH_NPTScaleNum		#	2
CSH_NPTScaleDen		#	2
			AlignSpace

CSH_LastContentID	#	4			; last value in ContentID field, or -1 if none

CSH_PCR_PID             #       4                       ; PCR_PID (only used for calculating transport stream overall bitrate)
CSH_PCR_old_packets     #       4                       ; number of TS packets since most recently parsed PCR
CSH_PCR_old             #       6                       ; most recently parsed PCR
CSH_PCR_old_flags       #       2                       ; flags: bit 0 set => PCR is valid
CSH_PCR_older_packets   #       4                       ; number of TS packets between old PCR and older PCR
CSH_PCR_older           #       6                       ; PCR before the most recently parsed PCR
CSH_PCR_older_flags     #       2                       ; flags: bit 0 set => PCR is valid
 [ EOSDetect
CSH_BufferCount         #       4                       ; number of buffers in use
CSH_EOSFlags            #       4
EOSFlags_HadFirstBuffer *       1 :SHL: 0
EOSFlags_TimedOut       *       1 :SHL: 1
EOSFlags_EOSImminent    *       1 :SHL: 2
EOSFlags_WaitingForVideo *      1 :SHL: 3
EOSFlags_WaitingForAudio *      1 :SHL: 4
CSH_TickInterval        #       4                       ; in cs
CSH_LastTick_DataReceived #     4                       ; number of buffers in use at last ticker event
CSH_LastTick_BufferCount #      4                       ; data received at last ticker event
 ]

CSH_SystemBitrate       #       4               ; bitrate parsed from system/program stream pack header

CSH_DemuxType           #       4
DemuxType_Transport             *       1 :SHL: 0
DemuxType_Program               *       1 :SHL: 1
DemuxType_SystemXNORTransport   *       1 :SHL: 2       ; only for GlobalDemuxType
DemuxType_ElementaryXNORTransport *     1 :SHL: 3       ; only for GlobalDemuxType
DemuxType_System                *       1 :SHL: 2       ; only for CSH_DemuxType
DemuxType_Elementary            *       1 :SHL: 3       ; only for CSH_DemuxType

CSH_Autodetecting               #       4       ; 1 => bitstream buffers need to be queued, else 0
CSH_QueuedBSBufHead             #       4       ; -> first queued bitstream buffer
CSH_QueuedBSBufTail             #       4       ; -> last queued bitstream buffer

CSH_ControlStreamType           #       4
ControlStreamType_Undetermined  *       0
ControlStreamType_Unrecognised  *       1
ControlStreamType_ElementaryVideo *     2
ControlStreamType_ElementaryAudio *     3
ControlStreamType_MPEG1Packet   *       4
ControlStreamType_MPEG1System   *       5
ControlStreamType_MPEG2PES      *       6
ControlStreamType_MPEG2ProgramNoPSM *   7
ControlStreamType_MPEG2Program  *       8
ControlStreamType_MPEG2Transport *      9

CSH_AutoTSDetectBins    #       TS_PacketLength ; sync bytes might start at any of 188 offsets from start of stream
AutoTSDetect_Scans      *       21      ; 21 passes over the bins covers nearly 4Kbyte of data
AutoTSDetect_MinMatches *       11      ; even if there is one non-packet-multiple discontinuity, there should be at least this many sync codes in a run
AutoSCDetect_LookAhead  *       68*1024 ; enough for the maximum length of one PES packet plus a bit more

CSHSize                 *       @


                        ^       0, wp

FreePacketListHeadPtr   #       4       ; pointer to head of list of free packet descriptors
FreePacketListTailPtr   #       4       ; pointer to tail of list

SWIInstruction          #       8       ; SWI + Pull pc
DebugFlag               #       4       ; NZ => output debugging

 [ DoPEH
GlobalPEHList		#	4	; list of all PEH nodes, global to all streams
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

Saved_FPSR              #       4       ; for saving the fp context
Saved_FPRegs            #       12*4    ;

 [ Capture
CaptureEnable           #       4       ; 0 = inactive, 1 = active
CaptureDANo             #       4       ; dynamic area number
CaptureDAStart          #       4       ; base address of dynamic area
CaptureDASize           #       4       ; size of dynamic area
CaptureWritePtr         #       4       ; write pointer
CaptureAmount           #       4       ; amount captured since OpenStream
 ]

GlobalDemuxType         #       4       ; as used by MPEGControl_ControlOp - copied to CSH_DemuxType on OpenStream

ControlStreamHandle     #       CSHSize ; goes at the end cos likely to be long (with stack)
                                        ; NB this could be dynamically allocated on OpenStream eventually

Module_WorkspaceSize * :INDEX: @

; ** Debugging macros **

        GBLL    xdebug
xdebug   SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ xdebug
        DLINE   "$string", $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ xdebug
        DREG    $reg, "$string", $cc, $routine
 ]
        MEND

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

 [ DebugNPT
; PrintBlock: dumps out a region of memory in bytewise order
; $from    -> first address to print
; $to      -> address after the last one to print
; $scratch -> 4 bytes of temporary workspace
; corrupts r0-r2, $from
        MACRO
        PrintBlock $from, $to, $scratch
00      LDRB    r0, [$from]
        MOV     r1, $scratch
        MOV     r2, #4
        SWI     XOS_ConvertHex2
        SWI     XOS_Write0
        ADD     $from, $from, #1
        CMP     $from, $to
        BNE     %BT00
        MEND
 ]

; **************** Module code starts here **********************

        AREA    |Module$$Code|, CODE, READONLY

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGControlSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry
        &       0                               ; no messages file
        &       Mod_Flags   -Module_BaseAddr

Mod_Title
        =       "MPEGControl", 0

Mod_HelpStr
        =       "MPEGControl", TAB
	=	"$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
 ]
        =       " (autodetect version)"
        =       0
        ALIGN

Mod_Flags
      [ No32bitCode
        &       0
      |
        &       ModuleFlag_32bit
      ]

Mod_SWITable
        =       "MPEGControl", 0
        =       "OpenStream", 0
        =       "FullBuffers", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
	=	"ResetStream", 0
	=	"MuteSound", 0
	=	"SoundVolume", 0
	=	"SelectProgram", 0
	=	"Stats", 0
	=	"RegisterProgramElementHandler", 0
	=	"DeregisterProgramElementHandler", 0
	=	"SetAudioParameters", 0
	=       "ControlOp", 0
	=       "SetVideoParameters", 0
	=       "GetSprite", 0
        =       0


Mod_HC_Table
        Command CtrlInfo, 0, 0
        Command CtrlDebugOn, 0, 0
        Command CtrlDebugOff, 0, 0
 [ Capture
        Command MPEGCapture, 1, 1
        Command MPEGSave, 1, 1
 ]
        =       0

CtrlInfo_Help
        =       "*CtrlInfo outputs debugging info.", CR
CtrlInfo_Syntax
        =       "Syntax: *CtrlInfo", 0
CtrlDebugOn_Help
        =       "*CtrlDebugOn enables continuous debugging output.", CR
CtrlDebugOn_Syntax
        =       "Syntax: *CtrlDebugOn", 0
CtrlDebugOff_Help
        =       "*CtrlDebugOff disables continuous debugging output.", CR
CtrlDebugOff_Syntax
        =       "Syntax: *CtrlDebugOff", 0
 [ Capture
MPEGCapture_Help
        =       "*MPEGCapture starts or stops capturing the incoming MPEG stream.", CR
MPEGCapture_Syntax
        =       "Syntax: *MPEGCapture <buffer size in MB>", 0
MPEGSave_Help
        =       "*MPEGSave saves out the captured MPEG stream.", CR
MPEGSave_Syntax
        =       "Syntax: *MPEGSave <filename>", 0
 ]
        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2
        STR     r12, ControlStreamHandle+CSH_ModuleWsPtr

        Debug_Open "MPEGDebug"

        MOV     r0, #0
        STR     r0, FreePacketListHeadPtr
        STR     r0, FreePacketListTailPtr
        STR     r0, DebugFlag
 [ DoPEH
	STR	r0, GlobalPEHList	; no handlers on list to start with
	STR	r0, ControlStreamHandle+CSH_ListOfPEHPIDs ; control stream handle not valid, so no PEHPIDs
 ]
 [ Capture
        STR     r0, CaptureEnable
 ]
        LDR     r0, PullPCInstruction
        STR     r0, SWIInstruction +4

        MOV     r0, #-1
        STR     r0, GlobalDemuxType     ; default to fully automatic demux

	ADR	r0, IssueServiceMPEGControlStarting
	MOV	r1, wp
	SWI	XOS_AddCallBack

        CLRV
        EXIT

PullPCInstruction
        Pull    PC

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; Ensure that the callback requested on init doesn't go off after we're dead

	ADR	r0, IssueServiceMPEGControlStarting
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

; Issue service call so that people know that the direct access interface is now invalid

        BL      IssueServiceMPEGControlDying

; Free all the packets on our free list

	LDR	r1, FreePacketListHeadPtr
10
	MOVS	r2, r1					; are there any more nodes to free?
	BEQ	%FT90					; [no, so skip]
	LDR	r1, [r2, #PacketDescriptor_Link]	; get link to next
	MOV	r0, #ModHandReason_Free			; free this one
	SWI	XOS_Module
	B	%BT10					; and try again

90

; Free all the PEHs
        LDR     r1, GlobalPEHList
10
        MOVS    r2, r1
        BEQ     %FT90
        LDR     r1, [r2, #PEH_Link]
        MOV     r0, #ModHandReason_Free
        SWI     XOS_Module
        B       %BT10
90

      [ Capture
        LDR     r0, CaptureEnable
        TEQ     r0, #1             ; is also the "remove" reason code to OS_DynamicArea
        LDREQ   r1, CaptureDANo
        SWIEQ   XOS_DynamicArea
      ]

        Debug_Close

        CLRV
        EXIT

        InsertNDRDebugRoutines

; **************************************************************************
;
;	IssueServiceMPEGControlStarting - Issue start-up service

IssueServiceMPEGControlStarting Entry "r1"
        MOV     r0, #3             ; as it happens, the kernel always sets r0 to 3 on entry to callbacks, so this is backwards-comptible
	MOV	r1, #Service_MPEGControlStarting
	SWI	XOS_ServiceCall
	EXIT

; **************************************************************************
;
;	IssueServiceMPEGControlDying - Issue dying service

IssueServiceMPEGControlDying Entry "r1"
        MOV     r0, #2
	MOV	r1, #Service_MPEGControlStarting
	SWI	XOS_ServiceCall
	EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #(SWIBTableEnd - SWIBTable) :SHR: 2
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
SWIBTable
        B       OpenStream      ; open stream
        B       FullBuffers     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
	B	ResetStream	; discard data and reset devices
	B	MuteSound	; mute/unmute sound
	B	SoundVolume	; set/read sound volume
	B	SelectProgram	; select program to watch
	B	Stats		; return statistics
	B	RegisterProgramElementHandler ; register a new program element handler
	B	DeregisterProgramElementHandler ; and deregister it
	B	SetAudioParameters ; set audio parameters
	B       ControlOp       ; set stream autodetect preference
	B       SetVideoParameters ; set video parameters
	B       GetSprite       ; capture video as a sprite
SWIBTableEnd

 [ :LNOT: DoPEH
RegisterProgramElementHandler
DeregisterProgramElementHandler
 ]
NoSuchSWI
        ADR     r0, NoSuchSWIError
        SETV
        MOV     pc, lr

NoSuchSWIError
        &       0
        =       "No such MPEGControl SWI", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control parameters structure
;       r2 = video parameters structure
;       r3 = audio parameters structure
;
; out:  r0 = control stream handle (for now)
;

OpenStream Entry "r0-r2"
        Debug   entry, "MPEGControl_OpenStream: ", r0, r1, r2, r3
        ADR     r1, ControlStreamHandle

        STR     r0, [r1, #CSH_StreamFlags]

        AND     lr, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        STR     lr, [r1, #CSH_NotReadyBits]             ; which bits are not yet ready to play
	STR	lr, [r1, #CSH_LastResetStreamFlags]
	STR     lr, [r1, #CSH_NextResetStreamFlags]
	MOV     lr, #1                                  ; start off playing data at normal speed
	STR     lr, [r1, #CSH_SpeedIndicator]
	STR     lr, [r1, #CSH_NextSpeedIndicator]
	LDR     lr, GlobalDemuxType
	TST     lr, #DemuxType_Transport
	EOREQ   lr, lr, #DemuxType_SystemXNORTransport :OR: DemuxType_ElementaryXNORTransport ; sanitise it!
	STR     lr, [r1, #CSH_DemuxType]

 [ Capture
        LDR     lr, CaptureEnable
        TEQ     lr, #1
        LDREQ   lr, CaptureDAStart
        STREQ   lr, CaptureWritePtr
        MOVEQ   lr, #0
        STREQ   lr, CaptureAmount
 ]

        TST     r0, #StreamFlags_VideoPresent
        BEQ     %FT10

        SWI     XMPEGVideo_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
        EXIT    VS
        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_VideoStreamHandle]
        LDR     r0, [r1, #CSH_StreamFlags]
10
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT20

        MOV     r2, r3
        SWI     XMPEGAudio_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
        EXIT    VS

        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_AudioStreamHandle]
20
 [ DoPEH
	Push	"r3-r6"
; Zero the pointer to the list of PEHPIDs

	MOV	r6, #0
	STR	r6, [r1, #CSH_ListOfPEHPIDs]
	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_DVB			; are we doing DVB
	MOVNE	r5, #PIDSlot_Extra			; yes, use base of PID slots to use for PEH requests
	MOVEQ	r5, #-1					; no, then no slots to allocate

; For each PEH on global list:
	LDR	r6, GlobalPEHList
25
	TEQ	r6, #0
	BEQ	%FT50					; [no more PEHs to consider]

; Allocate a PEHPID

	MOV	r0, #ModHandReason_Claim
	MOV	r3, #PEHPIDSize
	SWI	XOS_Module
	Pull	"r3-r6", VS				; if failed to claim PEHPID, exit with error
	EXIT	VS

;   Issue OpenStream reason code to handler

30
	Push	"r1,r2"
	MOV	r0, #PEHReason_OpenStream
	MOV	r2, r1					; r2 = control stream handle
	LDR	r1, [r2, #CSH_StreamFlags]		; r1 = stream flags
	MOV	r3, #0					; no program element parameters struct yet
	BL	CallPEH
	Pull	"r1,r2"
	BVS	%FT45					; error, so don't include this
	TEQ	r0, #0
	BEQ	%FT45					; returned zero handle, so don't include this

	STR	r0, [r2, #PEHPID_ProgramElementStreamHandle] ; save PEH stream handle
	STR	r6, [r2, #PEHPID_PEH]
	MOV	lr, #0
	STR	lr, [r2, #PEHPID_Flags]			; no meaning to this yet
	LDR	lr, [r6, #PEH_Flags]
	TST	lr, #PEHFlags_StreamIdentifiedByPID
	MOVEQ	lr, #-1					; it's a stream_type, so no PID found for this yet
	LDRNE	lr, [r6, #PEH_StreamType]		; stream type is really a raw PID, so allow it straight away
	STR	lr, [r2, #PEHPID_PID]			; store PID
	STR	r5, [r2, #PEHPID_PIDSlot]		; use this PID slot
	CMP	r5, #NumberOfPIDSlots-1			; if we've just used the last slot (or already run out)
	MOVCS	r5, #-1					; then no more PID slots free
	ADDCC	r5, r5, #1				; else advance to next slot
      [ CountDiscontinuities
        MOV     lr, #-1
        STR     lr, [r2, #PEHPID_LastContinuityCounter] ; guaranteed not to match the first continuity_counter
        STR     lr, [r2, #PEHPID_Discontinuities]       ; always intialise to -1, so once we have started, value will be 0
      ]
	LDR	lr, [r1, #CSH_ListOfPEHPIDs]		; add PEHPID onto list for this stream
	STR	lr, [r2, #PEHPID_Link]
	STR	r2, [r1, #CSH_ListOfPEHPIDs]
	LDR	r6, [r6, #PEH_Link]
	B	%BT25

; handler didn't return a valid handle, so if we're the last PEH, we must free it
; else process next PEH using the same PEHPID

45
	LDR	r6, [r6, #PEH_Link]
	TEQ	r6, #0
	BNE	%BT30					; [not at end, so reuse this PEHPID for the next PEH]

	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module				; free PEHPID node

50
	Pull	"r3-r6"
 ] ; DoPEH
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_StartTime]
        STR     r0, [r1, #CSH_PlayTime]
        STR     r0, [r1, #CSH_LastTime]

        MOV     r0, #0
        STR     r0, [r1, #CSH_DataReceived]
        STR     r0, [r1, #CSH_DataReceivedAtPlayTime]
	STR	r0, [r1, #CSH_DataReturned]
	STR	r0, [r1, #CSH_EndOfStreamReceived]	; haven't had end of stream marker yet
	STR	r0, [r1, #CSH_SyncLosses]		; no loss of system stream sync yet
	STR	r0, [r1, #CSH_TooShortPackets]		; no short packets yet
	STR	r0, [r1, #CSH_DataDiscarded]
	STR	r0, [r1, #CSH_CoroutineStackCopy]	; no block allocated yet
	STR	r0, [r1, #CSH_CoroutineStackBlockSize]	; no space in it
	STRB	r0, [r1, #CSH_NPTDescLength]		; no bytes in stored descriptor
	STR	r0, [r1, #CSH_NPTCurrent]		; no current descriptor
 [ EOSDetect
        STR     r0, [r1, #CSH_BufferCount]              ; no buffers in use yet
        STR     r0, [r1, #CSH_EOSFlags]                 ; not near any sort of stream-end
 ]
        STR     r0, [r1, #CSH_SystemBitrate]            ; unknown bitrate
	ASSERT  ControlStreamType_Undetermined = 0
	STR     r0, [r1, #CSH_ControlStreamType]
        MOV     r0, #-1
	STR	r0, [r1, #CSH_CurrentProgram]		; just choose 1st program for now
        STR     r0, [r1, #CSH_PMT_PID]                  ; PID for Program Map Table is unknown until we get a PAT on PID 0
        STR     r0, [r1, #CSH_Video_PID]                ; PID for video is unknown until we get a PMT
        STR     r0, [r1, #CSH_Audio_PID]                ; PID for audio is unknown until we get a PMT
        STR     r0, [r1, #CSH_PCR_PID]                  ; PID for PCR is unknown until we get a PMT
	STR	r0, [r1, #CSH_LastTrickModeControl]	; indicate normal play
	STR	r0, [r1, #CSH_LastContentID]		; no content ID fields yet

	MOV	lr, #1
	STR	lr, [r1, #CSH_CurrentVideoStream]
	STR	lr, [r1, #CSH_CurrentAudioStream]
	STR     lr, [r1, #CSH_Autodetecting]

        ADD     lr, r1, #CSH_QueuedBSBufHead - BufferDescriptor_Link
        STR     lr, [r1, #CSH_QueuedBSBufTail]          ; when we "append" the first bsbuf list to the "tail", we're actually pointing the list head at it

 [ DataRateStats
        MOV     lr, #DataCountArraySize-1               ; initialise all data counts to zero
        ADD     r2, r1, #CSH_DataCounts
	MOV	r0, #0
80
        STR     r0, [r2, lr, LSL #2]
        SUBS    lr, lr, #1
        BPL     %BT80
 ]

        MOV     r0, r1
        BL      coinit                                  ; initialise coroutines

        CLRV
        STR     r0, [sp]
        EXIT

; **************************************************************************
;
;       Play - Start audio and video playing (if both ready)
;
; in:   r0 = flags
;            bit 0 set => video module ready to play
;            bit 1 set => audio module ready to play
;            bit 2 set => end-of-stream signalled from higher layer
;            bit 3 set => video unit is idle
;            bit 4 set => audio unit is idle
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

Play    Entry "r0-r3"
        Debug   entry, "MPEGControl_Play: ", r0, r1
        ADR     r1, ControlStreamHandle

      [ EOSDetect
        TST     r0, #PlayFlags_VideoReady :OR: PlayFlags_AudioReady
        BEQ     %FT30                           ; not a ready-to-play event
      ]

        LDR     r3, [r1, #CSH_NotReadyBits]
        BICS    r3, r3, r0                      ; clear not ready bits for this module
        STR     r3, [r1, #CSH_NotReadyBits]
        EXIT    NE                              ; someone still isn't ready

        LDR     r3, [r1, #CSH_LastResetStreamFlags]
        TST     r3, #ResetStreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        MOV     r0, #0                          ; flags
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #ResetStreamFlags_AudioPresent
        BEQ     %FT20

        Push    "r1,r2"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
20
        LDR     r0, [r1, #CSH_DataReceived]
        STR     r0, [r1, #CSH_DataReceivedAtPlayTime]
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_PlayTime]
        STR     r0, [r1, #CSH_LastTime]
        CLRV
        EXIT

 [ EOSDetect
30
        TST     r0, #PlayFlags_EOSImminent
        BEQ     %FT40

        ; Higher layer has signalled that we can expect an end-of-stream soon.
        ; Wait until video and/or audio have become idle.
      [ DebugEOS
        DLINE   "EOS imminent"
      ]
        BL      AnticipateEndOfStream
        EXIT

40      ; We have been called back by the video/audio unit to say that decode-display has ceased
        ; so we may have to generate either an end-of-stream or a timeout UpCall
        ; or possibly neither, in the case where we have received more data since we timed out
        SCPSR   I_bit, 0, r3,, lr                       ; disable IRQs around EOSFlags manipulation
        LDR     r3, [r1, #CSH_EOSFlags]
        TST     r0, #PlayFlags_VideoIdle
        BICNE   r3, r3, #EOSFlags_WaitingForVideo
        TST     r0, #PlayFlags_AudioIdle
        BICNE   r3, r3, #EOSFlags_WaitingForAudio
        STR     r3, [r1, #CSH_EOSFlags]
        RestPSR lr,, c                                  ; restore IRQ state
        TST     r3, #EOSFlags_WaitingForVideo :OR: EOSFlags_WaitingForAudio
        EXIT    NE                                      ; still waiting for the other unit

        TST     r3, #EOSFlags_EOSImminent
        BEQ     %FT45

        ; End Of Stream has occurred
        BL      RemoveTimeoutTicker                     ; don't generate timeouts after this point
        ADR     r0, CallBack_UpCall_EndOfStream
        MOV     r1, r12
        SWI     XOS_AddCallBack                         ; do it on a callback because we may have been triggered from an IRQ handler
        EXIT

45      TST     r3, #EOSFlags_TimedOut
        EXIT    EQ

        ; Stream has timed out and stopped decoding
        ADR     r0, CallBack_UpCall_TimeOut
        MOV     r1, r12
        SWI     XOS_AddCallBack                         ; do it on a callback because we may have been triggered from an IRQ handler
        EXIT

CallBack_UpCall_EndOfStream
        Entry   "r0-r3"
      [ DebugEOS
        DLINE   "End Of Stream UpCall"
      ]
        MOV     r0, #UpCall_MPEG
        MOV     r1, #0
        ADR     r2, ControlStreamHandle
        MOV     r3, #UpCallMPEG_EndOfStream
        SWI     XOS_UpCall
        EXIT

CallBack_UpCall_TimeOut
        Entry   "r0-r3"
      [ DebugEOS
        DLINE   "Timeout UpCall"
      ]
        MOV     r0, #UpCall_MPEG
        MOV     r1, #0
        ADR     r2, ControlStreamHandle
        MOV     r3, #UpCallMPEG_TimeOut
        SWI     XOS_UpCall
        EXIT



AnticipateEndOfStream
        Entry   "r3,r4"
        SCPSR   I_bit, 0, r3,, r4               ; disable IRQs while we alter EOSFlags
        LDR     r3, [r1, #CSH_EOSFlags]
        ORR     r3, r3, #EOSFlags_EOSImminent
        STR     r3, [r1, #CSH_EOSFlags]
        BL      RemoveTimeoutTicker
        RestPSR r4,, c
        Push    "r0-r2"
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
        MOVNE   r0, #2
        LDRNE   r1, [r1, #CSH_AudioStreamHandle]
        MOVNE   r2, #1
        SWINE   XMPEGAudio_SetAudioParameters   ; disable sync-to-stream while we empty the buffers
        Pull    "r0-r2"
        BL      CheckVidAudUnitsIdle
        EXIT

CheckVidAudUnitsIdle
        Entry   "r0-r3"
        SCPSR   I_bit, 0, r3,, lr               ; disable IRQs while we alter EOSFlags
        LDR     r2, [r1, #CSH_EOSFlags]
        LDR     r3, [r1, #CSH_LastResetStreamFlags]
        BIC     r2, r2, #EOSFlags_WaitingForVideo :OR: EOSFlags_WaitingForAudio
        TST     r3, #ResetStreamFlags_VideoPresent
        ORRNE   r2, r2, #EOSFlags_WaitingForVideo
        TST     r3, #ResetStreamFlags_AudioPresent
        ORRNE   r2, r2, #EOSFlags_WaitingForAudio
        STR     r2, [r1, #CSH_EOSFlags]
        RestPSR lr,, c

        TST     r3, #ResetStreamFlags_VideoPresent
        BEQ     %FT10

        ; Video is present in the stream; ask to be called back when video is idle
        Push    "r1"
        MOV     r0, #VideoPlayFlags_Stop
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_Play
        Pull    "r1"
10
        TST     r3, #ResetStreamFlags_AudioPresent
        BEQ     %FT20

        ; Audio is present in the stream; ask to be called back when audio is idle
        Push    "r1"
        MOV     r0, #VideoPlayFlags_Stop
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_Play
        Pull    "r1"
20
        EXIT
 ]

; **************************************************************************
;
;       SetSpeed - Set speed of play on MPEG stream
;
; in:   r0 = flags
;       r1 = external stream handle (assumed for now)
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0-r3"
        Debug   entry, "MPEGControl_SetSpeed: ", r0, r1, r2
        ADR     r1, ControlStreamHandle
        STR     r2, [r1, #CSH_NextSpeedIndicator]               ; store the speed indicator for future use
        LDR     lr, [r1, #CSH_ControlStreamType]
        TEQ     lr, #ControlStreamType_MPEG2Transport           ; if it's a stream type that can generate internal resets
        TEQNE   lr, #ControlStreamType_MPEG2Program
        LDREQ   lr, [r1, #CSH_NextResetStreamFlags]
        ANDEQ   lr, lr, #ResetStreamFlags_DeferReset
        TEQEQ   lr, #ResetStreamFlags_DeferReset                ; and there's one pending
        EXIT    EQ                                              ; then defer the SetSpeed until the internal reset happens
      [ DebugNPT
        SWI     XOS_WriteS
        =       "MPEGControl_SetSpeed: speed = ", 0
        ALIGN
        Push    "r0-r2"
        SUB     sp, sp, #4
        MOV     r0, r2
        MOV     r1, sp
        MOV     r2, #4
        SWI     XOS_ConvertHex2
        SWI     XOS_Write0
        ADD     sp, sp, #4
        Pull    "r0-r2"
        SWI     XOS_NewLine
      ]
        STR     r2, [r1, #CSH_SpeedIndicator]

        LDR     r3, [r1, #CSH_StreamFlags]
        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_SetSpeed
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

        Push    "r1"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_SetSpeed
        Pull    "r1"
        STRVS   r0, [sp]
        EXIT    VS
20
      [ EOSDetect
        BL      RemoveTimeoutTicker             ; has no effect if it wasn't already registered (eg we were paused)
        BL      AddTimeoutTicker                ; has no effect if we've just gone into pause
      ]
        CLRV
        EXIT

; **************************************************************************
;
;       MuteSound - Mute/unmute sound
;
; in:   r0 = flags
;		bit 0 = 0 => sound on
;		        1 => sound off
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

MuteSound Entry "r0-r3"
        Debug   entry, "MPEGControl_MuteSound: ", r0, r1
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_MuteSound			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SoundVolume - Set/read sound volume
;
; in:   r0 = flags (zero for now)
;       r1 = external stream handle (assumed for now)
;	r2 = -1 => read volume
;	   = 0..256 => set volume (logarithmic)
;
; out:  r2 = old volume
;

SoundVolume Entry "r0,r1"
        Debug   entry, "MPEGControl_SoundVolume: ", r0, r1, r2
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_SoundVolume			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SetAudioParameters - Set various audio parameters
;
; in:   r0 = reason code
;       r1 = external stream handle
;	Others depend on reason code
;
; out:  Depends on reason code
;

SetAudioParameters Entry "r0,r1"
        Debug   entry, "MPEGControl_SetAudioParameters: ", r0, r1, r2
	CLRV
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_SetAudioParameters		; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SetVideoParameters - Set various video parameters
;
; in:   r0 = reason code
;       r1 = external stream handle
;	Others depend on reason code
;
; out:  Depends on reason code
;

SetVideoParameters Entry "r0,r1"
        Debug   entry, "MPEGControl_SetVideoParameters: ", r0, r1, r2
	CLRV
	TEQ     r0, #0
	BNE     %FT01
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_VideoPresent
	LDRNE	r1, [r1, #CSH_VideoStreamHandle]
01      SWINE   XMPEGVideo_SetVideoParameters		; only execute it if video present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       GetSprite - Capture MPEG video as a sprite
;
; in:   r0 = flags
;       r1 = external stream handle, or 0 to use most recently opened stream
;       r2 -> sprite area control block, or 0 to use system sprite area
;       r3 -> sprite name
;
; out:  Depends on reason code
;

GetSprite Entry "r1"
        Debug   entry, "MPEGControl_GetSprite: ", r0, r1, r2, r3
        CLRV
        TEQ     r1, #0                                  ; pass a value of 0 straight through
        BEQ     %FT01
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_VideoPresent
        BEQ     %FT90
        LDR     r1, [r1, #CSH_VideoStreamHandle]
01      SWI     XMPEGVideo_GetSprite
        EXIT

        ; If no video stream for this control stream handle, return the same error as MPEGVideo_GetSprite would have done
90      ADR     r0, %FT99
        SETV
        EXIT
99
        &       &81850B
        =       "No displayed picture", 0
        ALIGN

; **************************************************************************
;
;       FullBuffers - Here's some more data
;

; Direct access interface:
; in:   r0 = flags
;       r1 -> one or more linked bitstream buffers
;       it is assumed that the bitstream buffer struct contains the control stream handle

FullBuffers_DirectAccessWrapper
        Push    "lr"
        MOV     r2, r1
        LDR     r1, [r2, #BufferDescriptor_CSH]
        LDR     r12, [r1, #CSH_ModuleWsPtr]             ; needed for things like accessing FreePacketList
        BL      int_full_buffers
        TEQ     pc, pc
        Pull    "pc", EQ                                ; 32-bit mode exit
        Pull    "pc",, ^                                ; 26-bit mode: flag preservation safe in both APCS-R and APCS-32

; SWI interface
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> one or more linked bitstream buffers

FullBuffers
;        TST     r0, #FullBuffersFlags_UsingNewBSBufFormat
;        BEQ     Unsupported_FullBuffers_Call
        ; drop through to...
int_full_buffers Entry "r0-r5"
        Debug   entry, "MPEGControl_FullBuffers: ", r0, r1, r2
 [ Capture
        LDR     lr, CaptureEnable
        TEQ     lr, #1
        BNE     %FT10

        Push    "r0-r5"
        LDR     r3, CaptureWritePtr
        LDR     r4, CaptureDAStart
        LDR     r5, CaptureDASize
        ADD     r4, r4, r5
        LDR     r5, CaptureAmount
03
        LDR     r0, [r2, #BufferDescriptor_Start]
        LDR     r1, [r2, #BufferDescriptor_Length]
        ADD     r5, r5, r1           ; add the length of this packet to total so far
05
        LDRB    lr, [r0], #1         ; copy one byte
        STRB    lr, [r3], #1
        TEQ     r3, r4
        LDREQ   r3, CaptureDAStart   ; if reached end of DA then loop round to start
        SUBS    r1, r1, #1
        BNE     %BT05

        LDR     r2, [r2, #BufferDescriptor_Link]
        TEQ     r2, #0
        BNE     %BT03

        STR     r3, CaptureWritePtr
        STR     r5, CaptureAmount
        Pull    "r0-r5"
10
 ]
        LDR     r0, [r1, #CSH_NotReadyBits]             ; if we haven't actually started playing yet, do nothing
        TEQ     r0, #0
        MOVNE   r5, #0                                  ; indicate no array element to increment
        BNE     %FT05
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_LastTime]

 [ DataRateStats
        LDR     lr, [r1, #CSH_StartTime]
        SUB     r0, r0, lr                              ; time since starting
        LDR     lr, =DataCountPeriod*100                ; number of centiseconds in a period
        DivRem  r5, r0, lr, r3                          ; r5 = number of periods since starting
        CMP     r5, #DataCountArraySize                 ; check in range of array
        ADDCC   lr, r1, #CSH_DataCounts                 ; if so, then compute address of count to increment
        ADDCC   r5, lr, r5, LSL #2
        MOVCS   r5, #0                                  ; else indicate nothing to increment
 ]
05

        LDR     lr, [r1, #CSH_Autodetecting]            ; if still in autodetect phase,
        TEQ     lr, #0
        LDRNE   lr, [r1, #CSH_QueuedBSBufTail]          ; then append the new buffers to the queue
        STRNE   r2, [lr, #BufferDescriptor_Link]

        LDR     r0, [sp]                                ; reload flags

10

; ** DEBUGGING **

xdebug   SETL    {FALSE}

 [ xdebug
        DLine   "FullBuffer:"
        LDR     r3, [r2, #BufferDescriptor_Link]
        DReg    r3, " Link = "
        LDR     r3, [r2, #BufferDescriptor_FreeRoutine]
        DReg    r3, " FreeRoutine = "
        LDR     r3, [r2, #BufferDescriptor_FreeWorkspace]
        DReg    r3, " FreeWorkspace = "
        LDR     r3, [r2, #BufferDescriptor_Start]
        DReg    r3, " Start = "
        LDR     r3, [r2, #BufferDescriptor_Length]
        DReg    r3, " Length = "
	DReg	sp, " Stack pointer = "
 ]

        LDR     lr, [r1, #CSH_Autodetecting]            ; while in autodetect phase
        TEQ     lr, #0
        STRNE   r2, [r1, #CSH_QueuedBSBufTail]          ; keep buffer tail pointer pointing at current buffer

 [ EOSDetect
        SCPSR   I_bit, 0, lr,, r3                       ; disable IRQs
        LDR     r4, [r1, #CSH_BufferCount]
        ADD     r4, r4, #1                              ; increment buffer count
        STR     r4, [r1, #CSH_BufferCount]
        LDR     r4, [r1, #CSH_EOSFlags]
        TST     r4, #EOSFlags_TimedOut                  ; if we were in a timed-out state
        BLNE    AddTimeoutTicker                        ; then we no longer should be
        RestPSR r3,, c                                  ; restore IRQ state
 ]

        LDR     r3, [r2, #BufferDescriptor_Packets]
        TST     r3, #BufferDescriptorFlags_NewFormat
        MOVNE   r3, #1 :OR: BufferDescriptorFlags_NewFormat
        MOVEQ   r3, #1
        STR     r3, [r2, #BufferDescriptor_Packets]     ; one user (us!)

        LDR     r3, [r2, #BufferDescriptor_Start]
        LDR     r4, [r2, #BufferDescriptor_Length]

        LDR     lr, [r1, #CSH_DataReceived]             ; increment count of total bytes received
        ADD     lr, lr, r4
        STR     lr, [r1, #CSH_DataReceived]

 [ DataRateStats
        TEQ     r5, #0                                  ; if we're inside array
        LDRNE   lr, [r5]                                ; then increment array element by amount of data
        ADDNE   lr, lr, r4
        STRNE   lr, [r5]
 ]
        ADD     r4, r3, r4

        LDR     lr, [r1, #CSH_StreamFlags]              ; if not in the process of closing the stream
        TST     lr, #StreamFlags_StreamClosing          ; then call the coroutines to parse the buffer
        BLEQ    CallCoroutines                          ; otherwise effectively junk any data in the buffer

        SCPSR   I_bit, 0, lr,, r3         ; disable IRQs, leave old psr in r3

        LDR     lr, [r2, #BufferDescriptor_Packets]
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        LDR     r4, [r2, #BufferDescriptor_Link]        ; load link *before* restoring IRQ state

        RestPSR r3,, c                  ; restore IRQ state

        LDR     r3, [r1, #CSH_Autodetecting]
        TEQ     r3, #0
        BNE     %FT20                   ; never free any buffer during autodetect

        BICS    r3, lr, #BufferDescriptorFlags_NewFormat ; is the count now zero (if so then no active packets in buffer)
        BNE     %FT20                   ; [no, so don't free buffer]

        Push    "r1"
        STR     lr, [r2, #BufferDescriptor_Link] ; only free one buffer
        MOV     r1, r2
        BL      FreeBuffer
        Pull    "r1"
20
        MOVS    r2, r4                  ; put link back into r2
        BNE     %BT10                   ; and if more buffers, loop
        ; since MOVS has set Z, we know V is clear
;       CLRV
        EXIT

xdebug   SETL    {FALSE}

;Unsupported_FullBuffers_Call
;        ADR     r0, %FT00
;        SETV
;        MOV     pc, lr
;00
;        &       0
;        =       "This version of MPEGControl does not support old-format bitstream buffer descriptors", 0
;        ALIGN

; **************************************************************************
;
;       CloseStream - Close the stream
;
; in:   r0 = flags
;       r1 = control stream handle
;

CloseStream Entry "r0"
        Debug   entry, "MPEGControl_CloseStream: ", r0, r1
        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_CloseStreamFlags]
        LDR     r0, [r1, #CSH_StreamFlags]
        ORR     r0, r0, #StreamFlags_StreamClosing	; first set the stream closing bit, so any incoming data gets junked
        STR     r0, [r1, #CSH_StreamFlags]

	LDR	lr, [r1, #CSH_NotReadyBits]		; see if we've issued the Play SWI yet
	TEQ	lr, #0
	BEQ	%FT10					; we have, so no need to issue it again

; we haven't yet told them to go, so do so now

	Push	"r0"
	MOV	r0, lr
	BL	Play
	Pull	"r0"

10
        TST     r0, #StreamFlags_VideoPresent
        BEQ     %FT20

        Push    "r0, r1"
        LDR     r0, [r1, #CSH_CloseStreamFlags]
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_CloseStream
        Pull    "r0, r1"
20
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT30

        Push    "r0, r1"
        LDR     r0, [r1, #CSH_CloseStreamFlags]
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_CloseStream
        Pull    "r0, r1"
30
 [ DoPEH
	Push	"r1-r3,r6"
	LDR	r3, [r1, #CSH_ListOfPEHPIDs]
35
	TEQ	r3, #0					; any more PEHPIDs to consider
	BEQ	%FT50					; [no, so exit]
	MOV	r0, #PEHReason_CloseStream
	LDR	r1, [r1, #CSH_CloseStreamFlags]		; flags
	LDR	r2, [r3, #PEHPID_ProgramElementStreamHandle]
	LDR	r6, [r3, #PEHPID_PEH]			; point r6 at PEH for CallPEH
	BL	CallPEH
	MOV	r2, r3					; save copy of PEHPID to free
	LDR	r3, [r3, #PEHPID_Link]			; advance to next before freeing
	LDR	r1, [sp, #0*4]				; reload CSH pointer
	STR	r3, [r1, #CSH_ListOfPEHPIDs]		; remove node from head of list
	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module
	B	%BT35

50
	Pull	"r1-r3,r6"
 ] ; DoPEH

 [ EOSDetect
        BL      RemoveTimeoutTicker
 ]

; Now free the coroutine stack block

	Push	"r0-r2"
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVNE	r0, #ModHandReason_Free
	SWINE	XOS_Module
	MOV	r2, #0
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	STR	r2, [r1, #CSH_CoroutineStackBlockSize]
	Pull	"r0-r2"
        CLRV
        EXIT

; **************************************************************************
;
;	SelectProgram - Select TS program number to watch
;
; in:	r0 = flags:
;		bit 0 set => r3 = index of video stream to select
;		bit 1 set => r4 = index of audio stream to select
;	r1 = control stream handle
;	r2 = program number to select, or -1 to choose 1st program
;
; out:	-

SelectProgram Entry "r3,r4"
        Debug   entry, "MPEGControl_SelectProgram: ", r0, r1, r2, r3, r4
	LDR	lr, [r1, #CSH_StreamFlags]
	TEQ	r2, #0
	ORREQ	lr, lr, #StreamFlags_NoProgramSelected ; if zero then don't allow any elementary/system/program stream data through
	BICNE	lr, lr, #StreamFlags_NoProgramSelected ; else allow anything through (we only accept stream codes &C0 and &E0 anyway)
	STR	lr, [r1, #CSH_StreamFlags]

	TST	r0, #1		; check if video stream specified
	MOVEQ	r3, #1		; if not use default
	TST	r0, #2		; check if audio stream specified
	MOVEQ	r4, #1		; if not use default
	LDR	lr, [r1, #CSH_CurrentProgram]
	STR	r2, [r1, #CSH_CurrentProgram]
	TEQ	lr, r2
	LDREQ	lr, [r1, #CSH_CurrentVideoStream]
	STR	r3, [r1, #CSH_CurrentVideoStream]
	TEQEQ	lr, r3
	LDREQ	lr, [r1, #CSH_CurrentAudioStream]
	STR	r4, [r1, #CSH_CurrentAudioStream]
	TEQEQ	lr, r4
	EXIT	EQ		; program and video stream and audio stream all the same, do nowt

	BL	InvalidatePIDs	; forget all about PMT, video, audio and PEH PIDs

	Push	"r0-r3"
	LDR	r0, [r1, #CSH_StreamFlags]
	TST	r0, #StreamFlags_DVB
	BEQ	%FT60
	Push	"r0-r2"
	SWI	XDVBControl_ResetStream
	MOV	r0, #PIDSlot_PAT
	MOV	r1, #&00000047
	LDR	r2, =&00FF1FFF		; re-enable PID 0
	SWI	XDVBControl_MatchMask
	Pull	"r0-r2"
60
	AND	r0, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        ORR     r0, r0, #ResetStreamFlags_InternalReset ; don't worry about waiting for a GDF
	BL	ResetStream
	Pull	"r0-r3"
	PullEnv
        TEQ     pc, pc
	MOVNES  pc, lr          ; if running in 26-bit mode, preserve all flags, as before
	CMP     r0, r0          ; else just ensure V is clear
	MOV     pc, lr

        LTORG

; **************************************************************************
;
;       InvalidatePIDs - Called by SelectProgram/ResetStream to invalidate PMT/Video/Audio/PEH PIDs
;
; in:   r1 -> control stream handle
;
; out:  -
;

InvalidatePIDs Entry "r0,r2"
	MOV	lr, #-1
	STR	lr, [r1, #CSH_PMT_PID]
	STR	lr, [r1, #CSH_Video_PID]
	STR	lr, [r1, #CSH_Audio_PID]
	STR     lr, [r1, #CSH_PCR_PID]

 [ DoPEH
	LDR	r2, [r1, #CSH_ListOfPEHPIDs]
10
	TEQ	r2, #0				; no more PEHPIDs?
	BEQ	%FT30				; then skip
	LDR	lr, [r2, #PEHPID_PEH]		; get PEH for PEHPID
	LDR	r0, [lr, #PEH_Flags]		; first check that this PEH uses stream_type
	TST	r0, #PEHFlags_StreamIdentifiedByPID ; (bit must be clear)
	MOVEQ	lr, #-1				; uses stream_type, so invalidate this PID
	STREQ	lr, [r2, #PEHPID_PID]
20
	LDR	r2, [r2, #PEHPID_Link]		; move to next PEHPID
	B	%BT10				; and loop
30
 ]
	EXIT

; **************************************************************************
;
;       FreePackets - Called by video/audio devices to free a packet
;
; in:   r0 -> packet descriptor (for now)
;
; out:  -
;

FreePackets Entry "r0-r5, wp"
        MOV     r1, r0
        LDR     wp, [r1, #PacketDescriptor_FreeWorkspace]
10
        LDR     r2, [r1, #PacketDescriptor_BufferDescriptor]    ; get parent buffer pointer

        SCPSR   I_bit, 0, lr,, r3                       ; disable IRQs round this bit

; decrement outstanding packet count for buffer (atomically)

        LDR     lr, [r2, #BufferDescriptor_Packets]     ; (needs to be atomic)
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

; add this packet descriptor to free list

        LDR     r4, FreePacketListTailPtr
        TEQ     r4, #0                                  ; if no packets currently free
        STREQ   r1, FreePacketListHeadPtr               ; then point head at new free packets
        STRNE   r1, [r4, #PacketDescriptor_Link]        ; else tail!link = packet
        STR     r1, FreePacketListTailPtr               ; store new tail ptr

        LDR     r4, [r1, #PacketDescriptor_Link]        ; go down to next packet on passed list
        MOV     r5, #0
        STR     r5, [r1, #PacketDescriptor_Link]        ; detach packet

        RestPSR r3,, c                                  ; restore IRQ state

        BICS    r3, lr, #BufferDescriptorFlags_NewFormat ; if all buffer data has been used, then free buffer
        STREQ   lr, [r2, #BufferDescriptor_Link]        ; only free one buffer
        MOVEQ   r1, r2
        BLEQ    FreeBuffer

        MOVS    r1, r4                                  ; are we at end of passed list?
        BNE     %BT10                                   ; no, so loop

        EXIT

; **************************************************************************
;
;	ResetStream - Discard data and reset devices
;
; in:	r0 = flags
;		bit 0 set => new stream has video data
;		bit 1 set => new stream has audio data
;		bit 2 set => discard data until we get data of trick mode specified by r2
;	        bit 3 set => OVS trick play mode
;               bit 4 set => don't actually reset, just cache the other flags until the next internal reset (r2 and r3 on exit are then invalid)
;                            (this bit is ignored in internal calls)
;               bit 5 CLEAR => if we are supporting OVS NPT descriptors, discard data until a ContentID change signals Good Data Follows
;                            (this bit must only be set in internal calls, in which cases bit 4 will be ignored)
;	r1 = control stream handle
;	r2 = trick mode of required data (if bit 2 of r0 set):
; 		0 => fast forward
; 		1 => slow motion
; 		2 => freeze frame
; 		3 => fast reverse
; 		4 => slow reverse
; 	       -1 => normal play
; 	Note that these values correspond to the values of the trick_mode_control field
; 	in the PES packet header, except for -1 which corresponds to DSM_trick_mode_flag = 0,
;	and hence no trick_mode_control field.
;
; out:	r2 = estimate of amount of discarded video data, in bytes
;	r3 = estimate of amount of discarded audio data, in bytes
;

ResetStream Entry "r0-r3"
        Debug   entry, "MPEGControl_ResetStream: ", r0, r1, r2
        STR     r0, [r1, #CSH_NextResetStreamFlags]
        TST     r0, #ResetStreamFlags_DeferReset
        EXIT    NE
        MOV     r3, #0                          ; only zero the following if it wasn't an internally-generated reset
	STRB	r3, [r1, #CSH_NPTDescLength]	; no bytes in stored descriptor
	STR	r3, [r1, #CSH_NPTCurrent]	; no current descriptor
	STR     r3, [r1, #CSH_SystemBitrate]    ; bitrate of following stream unknown
	ASSERT  ControlStreamType_Undetermined = 0
	STR     r3, [r1, #CSH_ControlStreamType]
	MOV     lr, #1
	STR     lr, [r1, #CSH_SpeedIndicator]
	STR     lr, [r1, #CSH_NextSpeedIndicator] ; if there should be a subsequent internal reset, then continue playing at normal speed
	STR     lr, [r1, #CSH_Autodetecting]    ; start autodetecting again
        ADD     lr, r1, #CSH_QueuedBSBufHead - BufferDescriptor_Link
        STR     lr, [r1, #CSH_QueuedBSBufTail]
      [ DebugNPT
        SWI     XOS_WriteS
        =       "*** NORMAL RESET ***", 0
        ALIGN
        SWI     XOS_NewLine
      ]
      [ EOSDetect
        BL      RemoveTimeoutTicker
        MOV     r3, #0
        STR     r3, [r1, #CSH_BufferCount]              ; no buffers in use yet
        STR     r3, [r1, #CSH_EOSFlags]                 ; not near any sort of stream-end
      ]
        BL      int_reset_stream
        STR     r2, [sp, #2*4]
        STR     r3, [sp, #3*4]

	BL	InvalidatePIDs			; throw away any stale PIDs

	MOV	r0, r1
	BL	coinit

        CLRV
        EXIT


int_reset_stream                                ; may also be called from within coroutines
        ALTENTRY                                ; must match ResetStream stack, so registers are returned correctly
      [ DebugNPT
        SWI     XOS_WriteS
        =       "Reset: flags = ", 0
        ALIGN
        Push    "r0-r2"
        SUB     sp, sp, #12
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        ADD     sp, sp, #12
        Pull    "r0-r2"
        SWI     XOS_NewLine
      ]
	MOV	r3, #0
	STR	r3, [sp, #2*4]			; zero the returned r2
	STR	r3, [sp, #3*4]			; zero the returned r3
	STR     r3, [r1, #CSH_PCR_old_flags-2]  ; mark most recent PCR as invalid by zeroing flags
        STR     r3, [r1, #CSH_EndOfStreamReceived] ; by virtue of having been reset, we're no longer at end-of-stream
      [ EOSDetect
        SCPSR   I_bit, 0, r3,, lr
        LDR     r3, [r1, #CSH_EOSFlags]
        BIC     r3, r3, #EOSFlags_EOSImminent   ; this is the only flag we should clear on internal resets
        STR     r3, [r1, #CSH_EOSFlags]
        RestPSR lr,, c
        Push    "r0-r2"
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
        MOVNE   r0, #2
        LDRNE   r1, [r1, #CSH_AudioStreamHandle]
        MOVNE   r2, #0
        SWINE   XMPEGAudio_SetAudioParameters   ; reverse the disabling of sync-to-stream that may have happened earlier
        Pull    "r0-r2"
      ]

        LDR     r3, [r1, #CSH_StreamFlags]
        TST     r0, #ResetStreamFlags_TrickPlayMode
        ORRNE   r3, r3, #StreamFlags_TrickPlayMode
        BICEQ   r3, r3, #StreamFlags_TrickPlayMode
        STR     r3, [r1, #CSH_StreamFlags]
	TST	r0, #ResetStreamFlags_SkipUntilCorrectMode	; if we need to skip to correct mode
	STRNE	r2, [r1, #CSH_TrickModeControl]			; then save new mode
	ORRNE	r3, r3, #StreamFlags_SkipUntilCorrectMode	; and set bit in stream flags so we discard
	BICEQ	r3, r3, #StreamFlags_SkipUntilCorrectMode	; else clear bit so we don't discard any more
	STR     r3, [r1, #CSH_StreamFlags]
	TST	r3, #StreamFlags_OVSNPTDescriptors		; if we're supporting OVS NPT descriptors
        ANDNE   lr, r0, #ResetStreamFlags_InternalReset         ; and unless we don't need to wait for a Good Data Follows...
        TEQNE   lr, #ResetStreamFlags_InternalReset
	ORRNE	r3, r3, #StreamFlags_OVSNPTSkipping		; then discard data until we see contentID change
	STRNE	r3, [r1, #CSH_StreamFlags]

	ASSERT	StreamFlags_VideoPresent = ResetStreamFlags_VideoPresent
	ASSERT	StreamFlags_AudioPresent = ResetStreamFlags_AudioPresent
	AND	lr, r0, r3			; and out impossible bits in new stream vid/aud flags
	AND	lr, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
	STR	lr, [r1, #CSH_NotReadyBits]     ; this *must* be set up now in case the video unit calls MPEGControl_Play very quickly!
	STR	lr, [r1, #CSH_LastResetStreamFlags]

        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_ResetStream
	STRVC	r2, [sp, #3*4]			; store in returned r2 slot
        Pull    "r1"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

	Push	"r1"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_ResetStream
	STRVC	r2, [sp, #4*4]			; store in returned r3 slot
	Pull	"r1"
        STRVS   r0, [sp]
        EXIT    VS
20

      [ DebugEOS
        DLINE   "ResetStream UpCall"
      ]
        Push    "r4"
        BIC     r4, r0, #ResetStreamFlags_InternalReset ; externally meaningful ResetStream flags
        MOV     r3, #UpCallMPEG_ResetStream
        MOV     r2, r1
        MOV     r1, #0
        MOV     r0, #UpCall_MPEG
        SWI     XOS_UpCall
        CMP     r0, r0  ; clear V
        Pull    "r4"

        EXIT

 [ DoPEH
; **************************************************************************
;
;	RegisterProgramElementHandler - Entry point for SWI
;
; in:	r0 = flags:
;	  bit 0 set => MPEGControl module should include adaptation fields in
;		       payload, when they occur (indicated by a bit in packet
;		       descriptor flags)
;	  bit 1 set => MPEGControl module should include PES packet headers
;	  bit 2 set => MPEGControl module should include the whole of the TS
;		       packet in the payload (in this case the program element
;		       handler is responsible for adaptation field parsing)
;	  bit 3 set => r1 is absolute PID, not stream_type
;	  Other bits reserved (should be zero)
;
;	r1 = stream identifier:
;	      if bit 3 of flags set then absolute PID;
;	      if bit 3 of flags clear then stream_type (as defined by the MPEG 2 Systems specification,
;	     table 2-36, page 64)
;
;	r2 = entry address for handler
;	r3 = workspace pointer for handler
;
; out:	All registers preserved

RegisterProgramElementHandler Entry "r4"
        Debug   entry, "MPEGControl_RegisterProgramElementHandler: ", r0, r1, r2, r3

; check if stream type in r1 matches any PEH on global list - if so, error

	LDR	r4, GlobalPEHList
10
	TEQ	r4, #0				; if at end of list
	BEQ	%FT20				; then OK

	LDR	lr, [r4, #PEH_StreamType]	; then load streamtype
	TEQ	lr, r1				; if a match
	LDREQ	lr, [r4, #PEH_Flags]		; then check flags also match
	TEQEQ	lr, r0	 			; to avoid problems if one is a stream_type and one is a PID
	LDRNE	r4, [r4, #PEH_Link]		; if no match then goto next
	BNE	%BT10				; and loop

	TEQ	r4, #0				; did we get to end of list?
	BNE	%FT90				; if not, then already a handler for that
						; stream type, so report an error
; allocate a PEH node - if fail, then error

20
	Push	"r0-r3"
	MOV	r0, #ModHandReason_Claim
	MOV	r3, #PEHSize
	SWI	XOS_Module
	MOVVC	r4, r2				; if no error transfer ptr to r4
	STRVS	r0, [sp]			; if error, save error ptr in stacked r0
	Pull	"r0-r3"
	EXIT	VS

; store all info in node

	STR	r0, [r4, #PEH_Flags]
	STR	r1, [r4, #PEH_StreamType]
	STR	r2, [r4, #PEH_HandlerCode]
	STR	r3, [r4, #PEH_HandlerWS]

; add PEH to global list (at head of list is easiest)
; NB no atomicity problems - PEH list can only be updated from foreground

	LDR	lr, GlobalPEHList
	STR	lr, [r4, #PEH_Link]
	STR	r4, GlobalPEHList

; exit, indicating success

	CLRV
	EXIT

; exit with error

90
	ADR	r0, DuplicateElementHandlerError
	SETV
	EXIT

DuplicateElementHandlerError
	&	0
	=	"Program element handler already registered for this stream type", 0
	ALIGN

; **************************************************************************
;
;	DeregisterProgramElementHandler - Entry point for SWI
;
; in:	r0 = flags (should be same as for RegisterProgramElementHandler)
;	r1 = stream type (ditto)
;	r2 = entry address for handler
;	r3 = workspace pointer for handler
;
; out:	All registers preserved

DeregisterProgramElementHandler Entry "r4-r6"
        Debug   entry, "MPEGControl_DeregisterProgramElementHandler: ", r0, r1, r2, r3

; check if (stream type,entry,ws) matches any PEH on global list - if not, error

	ADR	r6, GlobalPEHList
	LDR	r4, [r6]
10
	TEQ	r4, #0				; if at end of list
	BEQ	%FT90				; didn't find a match, so error

	LDR	lr, [r4, #PEH_StreamType]	; load streamtype
	TEQ	lr, r1				; and check for match
	LDREQ	lr, [r4, #PEH_Flags]		; load flags
	TEQEQ	lr, r0	 			; and check for match
	LDREQ	lr, [r4, #PEH_HandlerCode]	; if match then load handler code address
	TEQEQ	lr, r2				; and check for match
	LDREQ	lr, [r4, #PEH_HandlerWS]	; if match then load handler WS ptr
	TEQEQ	lr, r3				; and check for match
	MOVNE	r6, r4				; if no match then update prev ptr
	LDRNE	r4, [r4, #PEH_Link]		; if no match then goto next
	BNE	%BT10				; and loop

; check if any stream contains a PEHPID node which points at this PEH
; if so, error

; In the current implementation, there can be only one stream open at a time
; We assume that if no stream is open, then ControlStreamHandle+CSH_ListOfPEHPIDs holds zero.

	ADR	r5, ControlStreamHandle
	LDR	r5, [r5, #CSH_ListOfPEHPIDs]
20
	TEQ	r5, #0
	BEQ	%FT30				; no more PEHPIDs, so OK
	LDR	lr, [r5, #PEHPID_PEH]		; get corresponding PEH
	TEQ	lr, r4				; does it match the PEH we're trying to delete
	LDRNE	r5, [r5, #PEHPID_Link]		; no, then link to next one
	BNE	%BT20				; and loop

	ADR	r0, ProgramElementHandlerInUseError
	B	%FT92				; can't remove PEH, cos there's an open stream using it

; delink PEH node from global list
30
	LDR	lr, [r4, #PEH_Link]		; prev->link = this->link
	STR	lr, [r6, #PEH_Link]

; free PEH node

	Push	"r0-r2"
	MOV	r0, #ModHandReason_Free
	MOV	r2, r4
	SWI	XOS_Module			; ignore any error from free - we can't do much about it
	Pull	"r0-r2"

; exit, no error

	CLRV
	EXIT

; exit with error

90
	ADR	r0, ProgramElementHandlerNotFoundError
92
	SETV
	EXIT

ProgramElementHandlerNotFoundError
	&	0
	=	"Program element handler not found", 0
	ALIGN

ProgramElementHandlerInUseError
	&	0
	=	"Program element handler in use", 0
	ALIGN
 ] ; DoPEH

; **************************************************************************
;
;       FreeBuffer - Call owner of buffer to free it
;
; in:   r1 -> buffer descriptor
;
; out:  -
;

FreeBuffer Entry "r0-r3,r12"
	LDR	r2, [r1, #BufferDescriptor_Length]
	SCPSR   I_bit, 0, lr,, r3       ; IRQs off

        LDR     lr, [r1, #BufferDescriptor_Packets]
        TST     lr, #BufferDescriptorFlags_NewFormat
        LDRNE   lr, [r1, #BufferDescriptor_CSH]
        ADREQ   lr, ControlStreamHandle
	LDR	r0, [lr, #CSH_DataReturned]
	ADD	r0, r0, r2
	STR	r0, [lr, #CSH_DataReturned]
	RestPSR r3,, c                  ; restore IRQ state
	MOV     r3, lr                  ; r3 = control stream handle

        LDR     r2, [r1, #BufferDescriptor_FreeRoutine]
        TEQ     r2, #0          ; check for SWI interface
        BEQ     %FT10

; routine interface

	LDR	r12, [r1, #BufferDescriptor_FreeWorkspace]	; setup workspace ptr
        MOV     r0, #3
        MOV     lr, pc
        MOV     pc, r2
      [ EOSDetect
        B       %FT90
      |
        EXIT
      ]

; swi interface

10
        LDR     r2, [r1, #BufferDescriptor_FreeWorkspace]
        ORR     r2, r2, #&EF000000
        STR     r2, SWIInstruction +0
        MOV     r2, r1
        LDR     r0, [r3, #CSH_EndOfStreamReceived]	; will be 0 or 1
        MOV     r1, #0
        BL      %FT20
      [ EOSDetect
        B       %FT90
      |
        EXIT
      ]

20
        Push    "lr"
        ADR     pc, SWIInstruction

 [ EOSDetect
90
        SCPSR   I_bit, 0, lr,, r2                       ; disable IRQs
        LDR     r0, [r3, #CSH_BufferCount]
        SUB     r0, r0, #1
        STR     r0, [r3, #CSH_BufferCount]
        RestPSR r2,, c                                  ; restore IRQ state
        EXIT
 ]


 [ EOSDetect
; **************************************************************************
;
;       AddTimeoutTicker - if conditions are appropriate, initiates timeout ticker events
;
; in:   r1 = control stream handle
;

AddTimeoutTicker
        Entry   "r0-r2"
        LDR     r0, [r1, #CSH_SpeedIndicator]
        TEQ     r0, #0                          ; if paused
        EXIT    EQ                              ; then don't start ticker events
        SCPSR   I_bit, 0, r2,, lr               ; disable IRQs while we mess with EOSFlags
        LDR     r2, [r1, #CSH_EOSFlags]
        TST     r2, #EOSFlags_HadFirstBuffer    ; if still waiting for first data
        RestPSR lr, EQ, c
        EXIT    EQ
        TST     r2, #EOSFlags_EOSImminent       ; or expecting a genuine EOS
        RestPSR lr, NE, c
        EXIT    NE                              ; then also don't start ticker events

        BIC     r2, r2, #EOSFlags_TimedOut      ; in case we're recovering from a previous timeout, clear timed-out flag
        STR     r2, [r1, #CSH_EOSFlags]
        RestPSR lr,, c                          ; restore IRQ state

        LDR     r2, [r1, #CSH_DataReceived]
        LDR     lr, [r1, #CSH_BufferCount]
        STR     r2, [r1, #CSH_LastTick_DataReceived]
        STR     lr, [r1, #CSH_LastTick_BufferCount]

        LDR     r2, =Timeout_Time
        MUL     r0, r2, r0
        STR     r0, [r1, #CSH_TickInterval]
        MOV     r2, r1
        ADR     r1, TimeoutTicker
        SWI     XOS_CallAfter
        EXIT

; **************************************************************************
;
;       RemoveTimeoutTicker - prevents any further timeout ticker events
;
; in:   r1 = control stream handle
;

RemoveTimeoutTicker
        Entry   "r0,r1"
        ADR     r0, TimeoutTicker
        SWI     XOS_RemoveTickerEvent
        EXIT

; **************************************************************************
;
;       TimeoutTicker - ticker event handler
;
; in:   r12 = control stream handle
;       IRQs are disabled
;

TimeoutTicker
        Entry   "r0-r3"
        LDR     r0, [r12, #CSH_LastTick_BufferCount]
        LDR     r1, [r12, #CSH_BufferCount]
        TEQ     r0, #0                          ; if old BufferCount = 0
        LDREQ   r2, [r12, #CSH_LastTick_DataReceived]
        LDR     r3, [r12, #CSH_DataReceived]
        TEQEQ   r2, r3                          ; and data has arrived since last tick
        STR     r1, [r12, #CSH_LastTick_BufferCount]
        STR     r3, [r12, #CSH_LastTick_DataReceived]
        BEQ     %FT50                           ; then we've timed out
        ; else we need to set another CallAfter
        LDR     r0, [r12, #CSH_TickInterval]
        ADR     r1, TimeoutTicker
        MOV     r2, r12
        SWI     XOS_CallAfter
        EXIT

50
        MOV     r1, r12
        LDR     r0, [r1, #CSH_EOSFlags]
        ORR     r0, r0, #EOSFlags_TimedOut
        STR     r0, [r1, #CSH_EOSFlags]
        BL      CheckVidAudUnitsIdle
        EXIT
 ]

; **************************************************************************
;
;	ControlOp - choose demultiplexing options
;
; in:	r0 = reason code
;
; r0 = 0:  Set demux type(s) according to R1, return old demux type(s) in R1
; r0 = 1:  Return current demux type(s) in R1
; r0 = 2:  Not implemented (was register demux module)
; r0 = 3:  Not implemented (was deregister demux module)
;
; r1:  bit 0 set  =>  MPEG-2 transport stream
;      bit 1 set  =>  MPEG-2 program stream with program stream map
;      (bit 2 EOR bit 0) == 0  =>  MPEG-1 packet stream /
;                                  MPEG-1 system stream /
;                                  MPEG-2 PES stream /
;                                  MPEG-2 program stream without program stream map
;      (bit 3 EOR bit 0) == 0  =>  elementary stream

ControlOp
        Debug   entry, "MPEGControl_ControlOp: ", r0, r1
        CMP     R0, #3
        ADDLS   PC, PC, R0, LSL #2
        B       err_invalid_ControlOp
        B       ControlOp_0
        B       ControlOp_1
        MOV     PC, R14         ; ControlOp 2 not implemented
        MOV     PC, R14         ; ControlOp 3 not implemented

ControlOp_0
        LDR     R0, GlobalDemuxType
        STR     R1, GlobalDemuxType
        MOV     R1, R0
        MOV     R0, #0
        MOV     PC, R14

ControlOp_1
        LDR     R1, GlobalDemuxType
        MOV     PC, R14

err_invalid_ControlOp
        ADR     R0, BadReason
        SETV
        MOV     PC, R14

BadReason
        &       0
        =       "Illegal reason code", 0
        ALIGN

; **************************************************************************
;
;       Coroutine stuff
;
; Entry parameters for coroutines:
;  r0-r4 are passed in
;  r5-r11 hold their value across calls
;
;       r0 = flags on entry to FullBuffers
;       r1 = control stream handle
;       r2 -> buffers
;       r3 -> start of first buffer's data (current position during call)
;       r4 -> end of first buffer's data
;
;       r5 video/audio selector for packet, or pointer to PEHPID
;       r6
;       r7 holds return from getbyte, getnextstartcode
;       r8 remaining length of PES packet / transport stream packet
;       r9
;       r10
;       r11 packet descriptor in preparation
;
; r0-r2 are used when they are passed back to FullBuffers, and must be preserved

extendstackblock Entry "r0-r3" ; put here to avoid messing up the ALTENTRY macros!
	MOV	r3, r6				; number of excess bytes needed
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVEQ	r0, #ModHandReason_Claim	; if no block yet, then claim one
	MOVEQ	r3, #16*4			; of 16 words (should be enough)
	MOVNE	r0, #ModHandReason_ExtendBlock
	SWI	XOS_Module			; let's hope this never fails!
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	LDR	lr, [r1, #CSH_CoroutineStackBlockSize]
	ADD	lr, lr, r3			; increased block size
	STR	lr, [r1, #CSH_CoroutineStackBlockSize]
	EXIT

; CallCoroutines (called from FullBuffers as and when another bitstream buffer becomes available)

CallCoroutines Entry "r5-r11"
        STR     sp, [r1, #CSH_ExternalSP]
	LDR	r5, [r1, #CSH_CoroutineStackSize]
	TEQ	r5, #0
	LDRNE	r6, [r1, #CSH_CoroutineStackCopy]
	ADDNE	r6, r6, r5
10
	LDRNE	r7, [r6, #-4]!
	Push	r7, NE
	SUBNES	r5, r5, #4
	BNE	%BT10
        EXIT

; cowait (called from coroutine to fetch next bitstream buffer)

cowait  ALTENTRY
	LDR	r5, [r1, #CSH_ExternalSP]
	SUB	r5, r5, sp			; how many bytes on coroutine stack
	STR	r5, [r1, #CSH_CoroutineStackSize]
	LDR	r6, [r1, #CSH_CoroutineStackBlockSize]
	SUBS	r6, r5, r6			; number of excess bytes
	BLHI	extendstackblock
	LDR	r6, [r1, #CSH_CoroutineStackCopy]
10
	Pull	r7				; there's always at least one word (r5-r11 stacked)
	STR	r7, [r6], #4			; copy data into RMA block
	SUBS	r5, r5, #4
	BNE	%BT10
        EXIT

; coinit
;
; in:   r1 -> control stream handle
; out:  -
;

coinit ALTENTRY                                 ; must push same stuff as cowait pulls
        STR     sp, [r1, #CSH_ExternalSP]
        BL      cowait

; and when we come back (1st call to FullBuffers), drop thru to...

 [ EOSDetect
        ; We get here when the first data is received after an OpenStream or (non-internal) ResetStream
        SCPSR   I_bit, 0, r7,, lr
        LDR     r7, [r1, #CSH_EOSFlags]
        ORR     r7, r7, #EOSFlags_HadFirstBuffer
        STR     r7, [r1, #CSH_EOSFlags]
        RestPSR lr,, c
        BL      AddTimeoutTicker
 ]

        LDR     r11, [r1, #CSH_DemuxType]
        TEQ     r11, #DemuxType_Transport       ; are we *sure* that it's going to be a transport stream?
        BEQ     DemuxAsTransportStream

        TST     r11, #DemuxType_Transport       ; if it only *might* be a transport stream, we need to search the start of the stream for sync bytes
        BEQ     NotTransportStream

        ; Zero the TS detect bins
        ADD     r5, r1, #CSH_AutoTSDetectBins
        ADD     r6, r1, #CSH_AutoTSDetectBins + TS_PacketLength
        MOV     lr, #0
01      STR     lr, [r5], #4
        TEQ     r5, r6
        BNE     %BT01

        ; Look for sync bytes in the stream
        MOV     r6, #AutoTSDetect_Scans
02
        MOV     r8, #TS_PacketLength
03
        BL      getbyte
        TEQ     r7, #TS_SyncByte
        LDREQB  lr, [r5, -r8]
        ADDEQ   lr, lr, #1
        STREQB  lr, [r5, -r8]
        TEQEQ   lr, #AutoTSDetect_MinMatches
        BEQ     %FT04
        SUBS    r8, r8, #1
        BNE     %BT03
        SUBS    r6, r6, #1
        BNE     %BT02

        ; Autodetect has failed to detect a transport stream
        BL      rewind
        B       NotTransportStream

04      ; Autodetect has detected a transport stream
        BL      rewind
        B       DemuxAsTransportStream

NotTransportStream
        TST     r11, #DemuxType_Elementary :OR: DemuxType_System ;:OR: DemuxType_Program
        BEQ     DemuxAsUnrecognisedStream       ; if it's definitely not one we support, there's nothing we can do
        TST     r11, #DemuxType_System ;:OR: DemuxType_Program
        BEQ     DetermineElementaryStreamType   ; if we're sure this is an elementary stream, use simpler algorithm
        TST     r11, #DemuxType_Elementary ;:OR: DemuxType_Program
        BEQ     DemuxAsSystemStream             ; if we're sure this is a system (etc) stream, just start demuxing now

        MOV     r8, #AutoSCDetect_LookAhead
        MOV     r9, #0                          ; flag bits: bit 0 => had video start code, bit 1 => had system start code
        MOV     r10, #0                         ; state: 0 => unlocked, 1 => one zero, 2 => two zeroes
10      CMP     r8, #0
        BLE     %FT20                           ; finish when we've searched a given distance into the stream, if not before
        BL      getbytedec
        TEQ     r10, #1                         ; if we've either had one
        TEQNE   r10, #2                         ; or two zeroes
        TEQEQ   r7, #0                          ; and another one comes along
        MOVEQ   r10, #2                         ; then change to two-zero state
        BEQ     %BT10
        TEQ     r10, #0                         ; if we're unlocked
        TEQEQ   r7, #0                          ; and a zero comes along
        MOVEQ   r10, #1                         ; then change to one-zero state
        BEQ     %BT10
        TEQ     r10, #2                         ; unless we've had two zeroes
        TEQEQ   r7, #1                          ; and now a one
        MOVNE   r10, #0                         ; then change back to unlocked state
        BNE     %BT10

        BL      getbytedec

        AND     lr, r11, #DemuxType_Program
        TEQ     r7, #&BC                        ; is it a program stream map start code
        TEQEQ   lr, #DemuxType_Program          ; and are we looking for them?
        BEQ     %FT30                           ; if so then abandon the search now

        CMP     r7, #&B9                        ; if it's a system start code
        ORRGE   r9, r9, #2                      ; then remember that we've had one
        TSTGE   r11, #DemuxType_Program         ; and if we also don't care about any upcoming program stream map start codes
        BEQ     %FT40                           ; then we can abandon the search now

        CMP     r7, #&B8                        ; if it's a video start code
        ORRLE   r9, r9, #1                      ; then remember we've had one
                                                ; if we were only looking for elementary streams, we wouldn't be here, so keep going
        MOV     r10, #0                         ; back to unlocked state
        B       %BT10

20      ; We now searched the maximum allowed distance into the stream, and we haven't found the "highest priority" start code
        TST     r9, #2                          ; if we found a system start code
        TSTNE   r11, #DemuxType_System          ; and we're interested in system stream demuxing,
        BNE     %FT40                           ; then do so

        TST     r11, #DemuxType_Elementary      ; if we're not interested in elementary streams
        BEQ     %FT50                           ; then we're stuffed

        ; Autodetect has detected an elementary stream
        TST     r9, #1                          ; if we found a video start code
        MOVNE   r5, #StreamFlags_VideoPresent   ; then it's video
        MOVEQ   r5, #StreamFlags_AudioPresent   ; else guess it's audio
        LDR     lr, [r1, #CSH_NotReadyBits]
        AND     lr, lr, r5
        STR     lr, [r1, #CSH_NotReadyBits]
        BL      rewind
        B       DemuxAsElementaryStream

30      ; Autodetect has detected a program stream with program stream map
        ; Not implemented yet - ignore the PSM, but consider demuxing as a PES stream
        BL      rewind
        TST     r11, #DemuxType_System
        BNE     DemuxAsSystemStream
        B       DemuxAsUnrecognisedStream

40      ; Autodetect has detected MPEG-1 packet or MPEG-2 PES start codes (eg system stream, program stream)
        BL      rewind
        B       DemuxAsSystemStream

50      ; Autodetect has failed to determine the stream type
        BL      rewind
        B       DemuxAsUnrecognisedStream


; Common utility routines

rewind
        Entry   "r5"
        ; First pass along the bitstream buffer list until we reach the last buffer passed to this FullBuffers
01
        LDR     lr, [r2, #BufferDescriptor_Link]
        TEQ     lr, #0
        BEQ     %FT10
        BL      cowait
        B       %BT01
10      ; Now at final bitstream buffer - temporarily loop the list back to the start
        MOV     r5, r2
        LDR     lr, [r1, #CSH_QueuedBSBufHead]
        STR     lr, [r5, #BufferDescriptor_Link]
        BL      cowait
        ; Now back at the beginning - restore the original final link
        MOV     lr, #0
        STR     lr, [r5, #BufferDescriptor_Link]
        ; BufferCount is wrong since we have already counted the first buffer(s) - correct it
        MOV     lr, #1
        STR     lr, [r1, #CSH_BufferCount]
        EXIT

getbytedec
        SUB     r8, r8, #1              ; decrement count of bytes remaining
getbyte
        CMP     r3, r4
        LDRCCB  r7, [r3], #1
        MOVCC   pc, r14

        Push    "lr"
        BL      cowait
        Pull    "lr"
        B       getbyte


; **************************************************************************
;
;       DemuxAsUnrecognisedStream
;
; Main coroutine entry point for dealing with unrecognised streams
; (just throws the data away)

DemuxAsUnrecognisedStream
        MOV     lr, #0
        STR     lr, [r1, #CSH_Autodetecting]
        MOVNE   lr, #ControlStreamType_Unrecognised
        STR     lr, [r1, #CSH_ControlStreamType]
10      BL      cowait
        B       %BT10


; **************************************************************************
;
;       DemuxAsElementaryStream
;
; Main coroutine entry point for dealing with elementary streams
;
; On entry, r5 = StreamFlags_VideoPresent or StreamFlags_AudioPresent, as appropriate

DetermineElementaryStreamType
        ; If we've been told that it's definitely an elementary stream, chances are that the
        ; stream flags will tell us whether it's video or audio, so we can make a quick decision.
        LDR     r5, [r1, #CSH_StreamFlags]
        AND     r5, r5, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        TEQ     r5, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        BNE     DemuxAsElementaryStream
        ; Failing that, just use the old-fashioned method of checking the first byte.
        LDRB    r7, [r3, #0]                            ; if first byte = &FF, then audio-only file
        TEQ     r7, #&FF
        MOVNE   r5, #StreamFlags_VideoPresent
        MOVEQ   r5, #StreamFlags_AudioPresent
        STR     r5, [r1, #CSH_NotReadyBits]
        ; drop through to...

DemuxAsElementaryStream
        MOV     lr, #0
        STR     lr, [r1, #CSH_Autodetecting]
        TEQ     r5, #StreamFlags_VideoPresent
        MOVEQ   lr, #ControlStreamType_ElementaryVideo
        MOVNE   lr, #ControlStreamType_ElementaryAudio
        STR     lr, [r1, #CSH_ControlStreamType]

elementarystreamloop
        LDR     r0, [r1, #CSH_StreamFlags]
        TST     r0, r5
        BEQ     %FT10
        TST     r0, #StreamFlags_NoProgramSelected
        BNE     %FT10
05
        BL      GetPacketDescriptor
        MOV     r11, r0
        SUB     r7, r4, r3
        CMP     r7, #MaxMPEGPacketLength
        MOVHI   r7, #MaxMPEGPacketLength
        STR     r7, [r11, #PacketDescriptor_FullLength]
        MOV     lr, #PacketDescriptorFlags_MPEGStart
	TEQ	r5, #StreamFlags_AudioPresent		; if an audio-only stream
	ORREQ	lr, lr, #PacketDescriptorFlags_PTSValid	; then generate a fake PTS of zero
        STR     lr, [r11, #PacketDescriptor_Flags]
	MOVEQ	lr, #0
	STREQ	lr, [r11, #PacketDescriptor_PTS+0]
	STREQ	lr, [r11, #PacketDescriptor_PTS+4]
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer
        ADD     r7, r3, r7                              ; point at end of this packet
        BL      sendvidaudblock
        TEQ     r7, r4                                  ; have we got to end of buffer?
        MOVNE   r3, r7                                  ; if not, then move start
        BNE     %BT05                                   ; and create another packet
10
        BL      cowait
        B       elementarystreamloop


; **************************************************************************
;
;       DemuxAsSystemStream
;
; Main coroutine entry point for dealing with system streams, packet streams,
; program streams without program stream maps, and PES streams.
; Only supported stream_ids are &E0 (video) and &C0 (audio).
;

DemuxAsSystemStream
        MOV     lr, #0
        STR     lr, [r1, #CSH_Autodetecting]
        BL      getnextstartcode

systemstreamloop
        MOV     r5, #0                                  ; by default we're not interested in this packet
        TEQ     r7, #&E0                                ; if a video packet
        MOVEQ   r5, #StreamFlags_VideoPresent           ; then mark as such
        TEQ     r7, #&C0                                ; if audio packet
        MOVEQ   r5, #StreamFlags_AudioPresent           ; then mark as such
        LDR     r0, [r1, #CSH_StreamFlags]              ; load stream flags
        TST     r0, r5                                  ; if not a packet we're interested in
        BEQ     notvidaudpacket
        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_MPEGStart
        STR     r7, [r11, #PacketDescriptor_Flags]

        BL      getbyte                                 ; get bits 8-15 of length
        MOV     r8, r7
        BL      getbyte                                 ; get bits 0-7 of length
        ORR     r8, r7, r8, LSL #8                      ; r8 = length to go
skipstuffing
        BL      getbytedec
        TEQ     r7, #&FF
        BEQ     skipstuffing

        MOV     r9, r7, LSR #6
	TEQ	r9, #2					; if first byte starts '10' then MPEG2 PES packet
	BEQ	pespacket
        LDR     lr, [r1, #CSH_ControlStreamType]        ; else it's an MPEG1 packet, so update the control stream type if necessary
        TEQ     lr, #ControlStreamType_MPEG1Packet
        TEQNE   lr, #ControlStreamType_MPEG1System
        MOVNE   lr, #ControlStreamType_MPEG1Packet
        STRNE   lr, [r1, #CSH_ControlStreamType]
        TEQ     r9, #1
        BNE     notSTD
        AND     r9, r7, #&3F                            ; get bottom 6 bits of 1st byte
        BL      getbytedec                              ; get 2nd byte of STD-buffer-scale+size
        ORR     r9, r7, r9, LSL #8                      ; merge bytes
        TST     r9, #&2000                              ; test STD_buffer_scale bit
        BICNE   r9, r9, #&2000                          ; if set, then knock it out
        MOVNE   r9, r9, LSL #10                         ; and value is in units of 1024 bytes
        MOVEQ   r9, r9, LSL #7                          ; else value is in units of 128 bytes
        STR     r9, [r11, #PacketDescriptor_BSn]        ; store BSn field
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_BSnValid ; set BSn valid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        BL      getbytedec                              ; get byte after
notSTD
        MOVS    r9, r7, LSR #4                          ; get top 4 bits of next byte, and put bit 3 into carry
        TEQ     r9, #2                                  ; check for PTS only (doesn't affect carry)
        BNE     notPTS                                  ; carry now holds bit 32 of PTS
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid  ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]

vidaudpacketcommon
        STR     r8, [r11, #PacketDescriptor_FullLength] ; save full length of MPEG packet data (ignoring buffer breaks)
        TEQ     r3, r4                                  ; ensure we've got at least one byte to send
        BLEQ    cowait
vidaudpacketcontinue
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer

	LDR	lr, [r1, #CSH_StreamFlags]		; check stream flags to see if we should be skipping this
	TST	lr, #StreamFlags_SkipUntilCorrectMode
	BEQ	%FT30					; [no, we're OK]
	LDR	r7, [r1, #CSH_TrickModeControl]		; if we were skipping, the PES packet header we may have just had
	LDR	r10, [r1, #CSH_LastTrickModeControl]	; might be right type, so check if equal
	TEQ	r7, r10
	BICEQ	lr, lr, #StreamFlags_SkipUntilCorrectMode ; if so, then knock out bit, so we don't spend time checking any more
	STREQ	lr, [r1, #CSH_StreamFlags]		; and store back to stream flags
	BNE	free_packet_and_skip			; else free packet descriptor and skip packet
30
        TST     lr, #StreamFlags_NoProgramSelected      ; if magic program number 0 has been selected
        BNE     free_packet_and_skip                    ; then discard this packet

        CMP     r8, #0                                  ; negative length packet?
        BLT     badlength
        ADD     r7, r3, r8                              ; end of video packet (if it was all in this buffer)
        CMP     r7, r4                                  ; is it all within this buffer?
        BHI     notallinbuff

        BL      sendvidaudblock
        MOV     r3, r7                                  ; start from end of video block data
        BL      getnextstartcodecheckloss
        B       systemstreamloop

pespacket
        LDR     lr, [r1, #CSH_ControlStreamType]        ; update the control stream type if necessary
        TEQ     lr, #ControlStreamType_MPEG2PES
        TEQNE   lr, #ControlStreamType_MPEG2ProgramNoPSM
        TEQNE   lr, #ControlStreamType_MPEG2Program
        MOVNE   lr, #ControlStreamType_MPEG2PES
        STRNE   lr, [r1, #CSH_ControlStreamType]
	BL	getbytedec     				; get byte with PTS/DTS flags in
	MOV	r10, r7					; save for later
	BL	getbytedec     				; get length of optional fields
	MOV	r6, r7					; save for later

	TST	r10, #PES_Optional_PTS_Present		; PTS present
	BEQ	pes_nopts
	BL	getbytedec     				; get 1st byte of PTS
	BL	getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid  ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
	SUB	r6, r6, #5				; 5 bytes less of header

	TST	r10, #PES_Optional_DTS_Present
	BEQ	pes_nodts
	BL	getbytedec     				; get 1st byte of DTS
	BL	getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_DTSValid  ; set DTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
	SUB	r6, r6, #5				; 5 bytes less of header
pes_nodts
pes_nopts
	TST	r10, #PES_Optional_DSM_trick_mode_flag	; if the DSM trick mode field isn't present,
	MOVEQ	r10, #-1					; then indicate normal play, and skip the rest of the parsing
	BEQ	%FT20					; then don't go thru the hassle of skipping other fields before it

	MOV	r9, r6					; save number of bytes of header yet to skip
	TST	r10, #PES_Optional_ESCR_flag
	MOVEQ	r6, #0					; if no ESCR flag then no bytes to skip for it
	MOVNE	r6, #6					; else skip 6 bytes of ESCR
	TST	r10, #PES_Optional_ES_rate_flag		; if ES_rate flag present
	ADDNE	r6, r6, #3				; then skip another 3 bytes of that
	SUB	r9, r9, r6				; how many left to skip
	BL	skipbytes				; skip the bytes

	BL	getbytedec     				; get trick_mode_control in bits 7:5, plus some other bits
	MOV	r10, r7, LSR #5				; extract the important bits
	SUB	r6, r9, #1				; bytes left to skip in header, not counting the byte we just got
20
	STR	r10, [r1, #CSH_LastTrickModeControl]	; and save indication of last trick_mode_control value, or -1 if none

; Now skip rest of header
	BL	skipbytes
	B	vidaudpacketcommon


notallinbuff
        SUB     r8, r7, r4                              ; r8 = amount of excess
        MOV     r7, r4
        BL      sendvidaudblock                         ; send this amount
        BL      cowait

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_Flags]
        STR     r7, [r11, #PacketDescriptor_FullLength]
        B       vidaudpacketcontinue

badlength                                               ; will typically cause a loss of sync too
	LDR	lr, [r1, #CSH_TooShortPackets]		; increment count of too-short packets
	ADD	lr, lr, #1
	STR	lr, [r1, #CSH_TooShortPackets]
free_packet_and_skip
        Push    "r0"
        MOV     r0, r11                                 ; r0 -> packet
        BL      FreePackets                             ; free it (possibly also freeing buffer)
        Pull    "r0"
        BL      getnextstartcodecheckloss
        B       systemstreamloop

notPTS
        TEQ     r9, #3
        BNE     vidaudpacketcommon                      ; not PTS+DTS, so must be plain
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}

        BL      getbytedec                              ; get first byte of DTS, with %0001 at front
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}

        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid :OR: PacketDescriptorFlags_DTSValid
                                                        ; set PTSValid + DTSValid bits in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        B       vidaudpacketcommon

; This routine gets a 33-bit PTS, DTS or SCR from the stream
;
; in:   r7 = first byte (including bits 32..30)
; out:  r7 = low 32 bits
;       r9 = bit 32 in bit 0

getclockreference ROUT
        Push    "lr"
        AND     r7, r7, #&0E                            ; extract bits 3..1
        MOV     r9, r7, LSR #3                          ; r9 = bit 32 in bit 0
        Push    "r9"                                    ; save for later
        MOV     r9, r7, LSL #31-2                       ; r9 = bits 31,30
        BL      getbytedec                              ; get bits 29..22 in bits 7..0
        ORR     r9, r9, r7, LSL #22                     ; r9 = bits 31..22
        BL      getbytedec                              ; get bits 21..15 in bits 7..1
        MOV     r7, r7, LSR #1
        ORR     r9, r9, r7, LSL #15                     ; r1 = bits 31..15
        BL      getbytedec                              ; get bits 14..7 in bits 7..0
        ORR     r9, r9, r7, LSL #7                      ; r1 = bits 31..7
        BL      getbytedec                              ; get bits 6..0 in bits 7..1
        ORR     r7, r9, r7, LSR #1                      ; r9 = bits 31..0
        Pull    "r9, pc"

incrementpacketcount Entry "r0"
        SCPSR   I_bit, 0, lr,, r0                       ; disable IRQs

        LDR     lr, [r2, #BufferDescriptor_Packets]
        ADD     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        RestPSR r0,, c                                  ; restore IRQ state
        EXIT

notvidaudpacket
        CMP     r7, #&BC                ; is it a packet header
        BCS     packettoskip
        TEQ     r7, #&BA                ; is it a pack header
        BEQ     packheader
	TEQ	r7, #&B9				; is it end-of-stream marker
	MOVEQ	lr, #1
	STREQ	lr, [r1, #CSH_EndOfStreamReceived]	; indicate we've received end-of-stream marker
      [ EOSDetect
       [ DebugEOS
        BNE     %FT00
        DLINE   "Parsed end code"
00
       ]
        BLEQ    AnticipateEndOfStream                   ; this waits for decoding to stop, then issues an UpCall
      ]

        TEQ     r3, r4                  ; if there is no data remaining in current buffer
        BLEQ    cowait                  ; then wait for more data (if any ever arrives)
        ; If subsequent data is present, assume some unsignalled stream transition has
        ; taken place (eg looping) and do an internal reset before proceeding any further
        Push    "r0, r2, r3"
        LDR     r0, [r1, #CSH_NextResetStreamFlags]
        ORR     r0, r0, #ResetStreamFlags_InternalReset ; don't worry about waiting for GDF, we can't have one in a system stream
        BL      int_reset_stream
        Pull    "r0, r2, r3"
        BL      getnextstartcode
        B       systemstreamloop

packheader
        BL      getbyte
        AND     lr, r7, #&F0
        TEQ     lr, #&20
        BEQ     packheaderMPEG1
        AND     lr, r7, #&C0
        TEQ     lr, #&40
        BEQ     packheaderMPEG2
        ; else illegal
        BL      getnextstartcode
        B       systemstreamloop

packheaderMPEG1
        LDR     lr, [r1, #CSH_ControlStreamType]
        TEQ     lr, #ControlStreamType_MPEG1System
        MOVNE   lr, #ControlStreamType_MPEG1System
        STRNE   lr, [r1, #CSH_ControlStreamType]
        MOV     r6, #4
        BL      skipbytes
        BL      getbyte
        AND     r6, r7, #&7F            ; first 7 bits of mux_rate
        BL      getbyte
        ORR     r6, r7, r6, LSL #8      ; next 8 bits of mux_rate
        BL      getbyte
        MOV     r7, r7, LSR #1
        ORR     r6, r7, r6, LSL #7      ; next 7 bits of mux_rate
        MOV     r7, #400
        MUL     r6, r7, r6              ; mux_rate is in units of 400 bits/s
        STR     r6, [r1, #CSH_SystemBitrate]
        BL      getnextstartcode
        B       systemstreamloop

packheaderMPEG2
        LDR     lr, [r1, #CSH_ControlStreamType]
        TEQ     lr, #ControlStreamType_MPEG2ProgramNoPSM
        MOVNE   lr, #ControlStreamType_MPEG2ProgramNoPSM
        STRNE   lr, [r1, #CSH_ControlStreamType]
        MOV     r6, #5
        BL      skipbytes
        BL      getbyte
        MOV     r6, r7                  ; first 8 bits of program_mux_rate
        BL      getbyte
        ORR     r6, r7, r6, LSL #8      ; next 8 bits of program_mux_rate
        BL      getbyte
        MOV     r7, r7, LSR #2
        ORR     r6, r7, r6, LSL #6      ; next 6 bits of program_mux_rate
        MOV     r7, #400
        MUL     r6, r7, r6              ; program_mux_rate is in units of 400 bits/s
        STR     r6, [r1, #CSH_SystemBitrate]
        BL      getnextstartcode
        B       systemstreamloop

        LTORG

packettoskip
        BL      getbyte                 ; get bits 8-15 of length
        MOV     r6, r7
        BL      getbyte                 ; get bits 0-7 of length
        ORR     r6, r7, r6, LSL #8      ; r6 = length to go

	BL	skipbytes
        BL      getnextstartcodecheckloss
        B       systemstreamloop

getnextstartcodecheckloss Entry
	BL	getnextstartcode
	TEQ	r8, #0			; did we find the next start code straight after
	LDRNE	r8, [r1, #CSH_SyncLosses] ; if not, increment no. of sync losses
	ADDNE	r8, r8, #1
	STRNE	r8, [r1, #CSH_SyncLosses]
	EXIT

; skipbytes skips r6 bytes
; will not return until there is at least one byte in current buffer

skipbytes Entry
        SUB     r8, r8, r6              ; reduce outstanding number of bytes in packet (only useful during parsing of PES header)
10
        ADD     r3, r3, r6              ; end of packet (if it was all in this buffer)
        CMP     r3, r4                  ; is it all within this buffer?
	EXIT	CC

        SUB     r6, r3, r4              ; r6 = amount of excess
        BL      cowait
        B       %BT10

; getnextstartcode searches for the next start code (ie 2 or more 00 bytes followed by 01 xx)
; On exit:
;	r7 = xx code
;	r8 = 0 => found the start code as first thing
;	     1 => found other stuff first

getnextstartcode
        Push    "lr"
	MOVS	r8, #0			; indicate we found start code straight away (NB may be
					; more than two leading 00 bytes, but this is valid)
getnextstartcodeloop
	MOVNE	r8, #1			; don't execute this first time thru, but all branches
					; to here are with NE set, so indicate didn't find start code
					; straight away
        BL      getbyte                 ; look for 1st zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
        BL      getbyte                 ; look for 2nd zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
gottwozeros
        BL      getbyte                 ; look for "1" of start code
        CMP     r7, #1
        BCC     gottwozeros             ; if 3rd zero, then not start code, but we've got two zeros
        BNE     getnextstartcodeloop    ; not zero or one, so look for 1st zero again
        BL      getbyte                 ; get start code reason
        Pull    "pc"


; **************************************************************************
;
;       DemuxAsTransportStream
;
; Main coroutine entry point for dealing with transport streams.
;

DemuxAsTransportStream
        MOV     lr, #0
        STR     lr, [r1, #CSH_Autodetecting]
        MOV     lr, #ControlStreamType_MPEG2Transport
        STR     lr, [r1, #CSH_ControlStreamType]

ts_wait_for_sync
	LDR	r7, [r1, #CSH_StreamFlags]
	TST	r7, #StreamFlags_DVB
	MOVNE	r10, #4				; skip 4 bytes of tag word
	BLNE	ts_skipbytes

;        DREG    r3, "Memory pointer = "
ts_wait_for_sync_loop
        BL      getbyte
        TEQ     r7, #TS_SyncByte
        BNE     ts_wait_for_sync_loop

        LDR     lr, [r1, #CSH_PCR_old_packets]
        ADD     lr, lr, #1                      ; increment count of packets since last PCR
        STR     lr, [r1, #CSH_PCR_old_packets]
        MOV     r8, #TS_PacketLength-1          ; r8 = number of bytes remaining in transport packet
        BL      getbytedec                      ; get TEI, PUSI, TP and top 5 bits of PID
        MOV     r9, r7                          ; and save it
        BL      getbytedec                      ; get bottom 8 bits of PID
        AND     r5, r9, #&1F                    ; top 5 bits of PID
        ORR     r5, r7, r5, LSL #8              ; r5 = PID
        BL      getbytedec                      ; r7 = transport_scrambling_control (2 bits), adaptation_field_control (2 bits), continuity_counter (4 bits)
        ORR     r9, r7, r9, LSL #8              ; r9 now has byte 1 of packet in bits 8..15, and byte 3 of packet in bits 0..7

 [ DoPEH

; do PEH first, so get in before old-style (SWI based) video

	LDR	lr, [r1, #CSH_ListOfPEHPIDs]
10
	TEQ	lr, #0
	BEQ	%FT20
	LDR	r6, [lr, #PEHPID_PID]
	TEQ	r5, r6				; check if PID matches
	LDRNE	lr, [lr, #PEHPID_Link]
	BNE	%BT10

 [ CountDiscontinuities
        LDR     r5, [lr, #PEHPID_LastContinuityCounter] ; get last continuity_counter
        AND     r7, r7, #&F                             ; extract new continuity_counter bits
        STR     r7, [lr, #PEHPID_LastContinuityCounter] ; store for next time
        TST     r9, #TS_Payload_Present_Bit             ; if there's a payload in this TS packet, then continuity_counter should have advanced by 1
        SUBNE   r7, r7, #1                              ; so subtract 1 from the continuity_counter bits
        ANDNE   r7, r7, #&F                             ; and mask off any unwanted bits again (in case of wraparound)
        TEQ     r7, r5                                  ; does this give us the previous continuity_counter?
        LDRNE   r5, [lr, #PEHPID_Discontinuities]       ; if not, then increment the number of discontinuities found so far
        ADDNE   r5, r5, #1
        STRNE   r5, [lr, #PEHPID_Discontinuities]
 ]

; found a match, so point r5 at PEHPID and jump to common code

      [ {TRUE}
        Push    "lr"
        LDR     r5, [r1, #CSH_LastResetStreamFlags] ; bits which are set in both StreamFlags and ResetStreamFlags
        LDR     lr, [lr, #PEHPID_PEH]
        LDR     lr, [lr, #PEH_Flags]            ; get PEH flags
        AND     lr, lr, #PEHFlags_RequiredFlag_Mask
        MOV     lr, lr, LSR #PEHFlags_RequiredFlag_Shift
        CMP     lr, #0                          ; set carry
        TEQ     lr, r5, LSR lr                  ; set/clear carry according to relevant bit, or leave alone if lr=0
        Pull    "r5"
        BCS     ts_process_common
        BCC     ts_skip_to_next_packet          ; if a required StreamFlag bit is not set, skip this packet
      |
	MOV	r5, lr
	B	ts_process_common
      ]

20
 ] ; DoPEH

; check for video first, it's the most likely thing

        LDR     lr, [r1, #CSH_Video_PID]
        TEQ     r5, lr
        BEQ     ts_process_video_PID

        LDR     lr, [r1, #CSH_Audio_PID]
        TEQ     r5, lr
        BEQ     ts_process_audio_PID

        TEQ     r5, #0
        BEQ     ts_process_PID0
        LDR     lr, [r1, #CSH_PMT_PID]
        TEQ     r5, lr
        BEQ     ts_process_PMT_PID

        LDR     lr, [r1, #CSH_PCR_PID]
        TEQ     r5, lr
        BEQ     ts_process_PCR_PID

; this packet was not used, so increment the count of discarded data

	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_DVB			; check if DVB (extra 4 bytes if so)
	LDR	lr, [r1, #CSH_DataDiscarded]
	ADD	lr, lr, #TS_PacketLength		; add on 1 TS packet
	ADDNE	lr, lr, #4				; add on extra 4 bytes if DVB
	STR	lr, [r1, #CSH_DataDiscarded]

ts_skip_to_next_packet
        MOV     r10, r8
        BL      ts_skipbytes
        B       ts_wait_for_sync

ts_process_PID0 ROUT
      [ DebugPID
        DLINE   "Found PAT",cc
      ]
        TST     r9, #TS_Payload_Present_Bit     ; ensure there is payload in this packet
        TSTNE   r9, #TS_PUSI_Bit                ; and the PSI payload starts in this packet
        BEQ     ts_skip_to_next_packet          ; if not both of these, then no PAT in this packet, so skip it
        TST     r9, #TS_AF_Present_Bit          ; is an adaptation field present
        BLNE    ts_skip_adaptation_field        ; if so, then skip it
        BL      ts_find_PSI_start               ; use pointer field to find start of payload

        BL      getbytedec                      ; get table_id field
        TEQ     r7, #TS_table_id_PAT            ; if not what we're expecting
        BNE     ts_skip_to_next_packet          ; then skip to next packet
	BL	getbytedec
        AND     r9, r7, #&0F                    ; top 4 bits of section length, + 4 other bits
        BL      getbytedec
	ORR	r5, r7, r9, LSL #8		; r5 = section length

        MOV     r10, #5                         ; skip another 5 bytes of header
        BL      ts_skipbytes

	SUB	r5, r5, #5+4			; 5 fewer bytes to do, and also ignore CRC_32
	LDR	r6, [r1, #CSH_CurrentProgram]
10
	SUBS	r5, r5, #4			; have we got 4 bytes left?
	BLT	ts_skip_to_next_packet		; no, so no more programs
	BL	getbytedec   			; get hi byte of program_number
	MOV	r9, r7
	BL	getbytedec   			; get lo byte of program_number
	ORRS	r9, r7, r9, LSL #8
	BEQ	%FT20				; if zero then is PID for NIT, not for a real program

	TEQ	r6, #0
	BMI	%FT25				; if negative then a program index
	TEQ	r6, r9				; else check against requested program number
	BEQ	%FT30				; is our program
20
	BL	getbytedec   			; skip
	BL	getbytedec
	B	%BT10

25
	ADDS	r6, r6, #1			; increment program index
	BNE	%BT20				; if not zero, then loop back, else it is our program
30
        BL      getbytedec
        AND     r9, r7, #&1F                    ; top 5 bits of PMT_PID
        BL      getbytedec
        ORRS    r9, r7, r9, LSL #8
	LDR	lr, [r1, #CSH_PMT_PID]
 [ OnlyAcceptFirstPATandPMT
	CMP	lr, #-1				; if already know PMT_PID
	BNE	ts_skip_to_next_packet		; then skip to next packet
 ]
        STR     r9, [r1, #CSH_PMT_PID]
	CMP	lr, r9
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB
        BEQ     ts_skip_to_next_packet		; same as last time, or not doing DVB, so continue

	Push	"r0-r2"
	MOV	r0, #PIDSlot_PMT
	MOV	r1, r9
	BL	ts_pid_enable			; enable new PMT_PID (overwrites old)
	Pull	"r0-r2"
	B	ts_skip_to_next_packet


ts_process_PMT_PID ROUT
      [ DebugPID
        DLINE "Found PMT",cc
      ]
        TST     r9, #TS_Payload_Present_Bit     ; ensure there is payload in this packet
        TSTNE   r9, #TS_PUSI_Bit                ; and the PSI payload starts in this packet
        BEQ     ts_skip_to_next_packet          ; if not both of these, then no PAT in this packet, so skip it
        TST     r9, #TS_AF_Present_Bit          ; is an adaptation field present
        BLNE    ts_skip_adaptation_field        ; if so, then skip it
        BL      ts_find_PSI_start               ; use pointer field to find start of payload

        BL      getbytedec                      ; get table id
        TEQ     r7, #TS_table_id_PMT
        BNE     ts_skip_to_next_packet

        BL      getbytedec
        AND     r5, r7, #&0F                    ; top 4 bits of section length
        BL      getbytedec
        ORR     r5, r7, r5, LSL #8              ; r5 = section length

        BL      getbytedec   			; skip program number
        BL      getbytedec

        BL      getbytedec                      ; get 2 reserved, 5 version number, 1 current_next_indicator
        BL      getbytedec                      ; get section_number (must be zero)
        BL      getbytedec                      ; get last_section_number (ditto)
        BL      getbytedec                      ; get 3 reserved, 5 PCR_PID [12:8]
        AND     r10, r7, #&1F
        BL      getbytedec                      ; get 8 PCR_PID [7:0]
        ORR     r10, r7, r10, LSL #8
        STR     r10, [r1, #CSH_PCR_PID]
        BL      getbytedec
        AND     r9, r7, #&0F                    ; get 4 reserved, 4 program_info_length [11:8]
        BL      getbytedec                      ; get 8 program_info_length [7:0]

        SUB     r5, r5, #9+4                    ; reduce count by all the bytes since section length, + 4 for CRC on end

        ORR     r10, r7, r9, LSL #8             ; program_info_length
        SUBS    r5, r5, r10                     ; reduce count for length of descriptors
	BLT	ts_skip_to_next_packet		; bogus descriptors length
	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_OVSNPTDescriptors
	BNE	ts_check_for_OVSNPT
        BL      ts_skipbytes
ts_process_rest_of_PMT
	LDR	lr, [r1, #CSH_CurrentVideoStream] ; copy currents to temps
	STR	lr, [r1, #CSH_TempVideoStream]
	LDR	lr, [r1, #CSH_CurrentAudioStream]
	STR	lr, [r1, #CSH_TempAudioStream]
10
        SUBS    r5, r5, #5                      ; if no room for another stream type and PID
        BLT     ts_skip_to_next_packet
        BL      getbytedec                      ; get stream type
        MOV     r9, r7
        BL      getbytedec
        AND     r10, r7, #&1F
        BL      getbytedec
        ORR     r10, r7, r10, LSL #8            ; r10 = elementary PID

        TEQ     r9, #TS_Stream_Type_MPEG1Video
	TEQNE	r9, #TS_Stream_Type_MPEG2Video
	BNE	%FT40

	LDR	lr, [r1, #CSH_TempVideoStream]
	SUBS	lr, lr, #1
	STR	lr, [r1, #CSH_TempVideoStream]
	BNE	%FT60				; not our stream so ignore

	LDR	lr, [r1, #CSH_Video_PID]
 [ OnlyAcceptFirstPATandPMT
	CMP	lr, #-1				; if we already know this PID
	BNE	%FT60				; then ignore it
 ]
        STR     r10, [r1, #CSH_Video_PID]
	TEQ	lr, r10				; check if same as old
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB		; if same, or not doing DVB
	BEQ	%FT60				; then ignore

	Push	"r0-r2"
	MOV	r0, #&10000000			; large value, so will get limited to max packet size
	SWI	XDVBControl_PacketCounter
	MOV	r0, #PIDSlot_Video
	MOV	r1, r10
	BL	ts_pid_enable			; enable new video PID (overwrites old)
	Pull	"r0-r2"
	B	%FT60				; also check for PEH

40
        TEQ     r9, #TS_Stream_Type_MPEG1Audio
	TEQNE	r9, #TS_Stream_Type_MPEG2Audio
	BNE	%FT60

	LDR	lr, [r1, #CSH_TempAudioStream]
	SUBS	lr, lr, #1
	STR	lr, [r1, #CSH_TempAudioStream]
	BNE	%FT60				; not our stream so ignore

	LDR	lr, [r1, #CSH_Audio_PID]
 [ OnlyAcceptFirstPATandPMT
	CMP	lr, #-1				; if we already know this PID
	BNE	%FT60				; then ignore it
 ]
        STR     r10, [r1, #CSH_Audio_PID]
	TEQ	lr, r10				; check if same as old
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB		; if same, or not doing DVB
	BEQ	%FT60				; then ignore

	Push	"r0-r2"
	MOV	r0, #&10000000			; large value, so will get limited to max packet size
	SWI	XDVBControl_PacketCounter
	MOV	r0, #PIDSlot_Audio
	MOV	r1, r10
	BL	ts_pid_enable			; enable new audio PID (overwrites old)
	Pull	"r0-r2"

; and drop thru to...
; now check against the stream types of all PEHPIDs

60
 [ DoPEH
	Push	"r0,r2"
	LDR	r2, [r1, #CSH_ListOfPEHPIDs]
65
	TEQ	r2, #0				; no more PEHPIDs?
	BEQ	%FT78				; then skip
	LDR	lr, [r2, #PEHPID_PEH]		; get PEH for PEHPID
	LDR	r0, [lr, #PEH_Flags]		; first check that this PEH uses stream_type
	TST	r0, #PEHFlags_StreamIdentifiedByPID ; (bit must be clear)
	LDREQ	lr, [lr, #PEH_StreamType]	; get stream type for PEH
	TEQEQ	lr, r9				; check stream type against PEH's
	BNE	%FT75				; no match, go to next one
 [ OnlyAcceptFirstPATandPMT
	LDR	lr, [r2, #PEHPID_PID]
	CMP	lr, #-1				; if we already know this PID
	BNE	%FT75				; then ignore it
 ]
    [ {TRUE}
        TEQ     r9, #TS_Stream_Type_MPEG1Video
        TEQNE   r9, #TS_Stream_Type_MPEG2Video
        LDREQ   r10, [r1, #CSH_Video_PID]
        TEQ     r9, #TS_Stream_Type_MPEG1Audio
        TEQNE   r9, #TS_Stream_Type_MPEG2Audio
        LDREQ   r10, [r1, #CSH_Audio_PID]
    ]
	STR	r10, [r2, #PEHPID_PID]		; save PID value
	LDR	r0, [r2, #PEHPID_PIDSlot]	; get PID slot
	CMP	r0, #-1				; if not valid
	BEQ	%FT75				; then goto next PEHPID
	Push	"r1,r2"
	MOV	r1, r10
	BL	ts_pid_enable			; enable this PID
	Pull	"r1,r2"
75
	LDR	r2, [r2, #PEHPID_Link]		; move to next PEHPID
	B	%BT65				; and loop
78
	Pull	"r0,r2"
 ] ; DoPEH
80
        BL      getbytedec
        AND     r10, r7, #&0F
        BL      getbytedec
        ORR     r10, r7, r10, LSL #8            ; r10 = ES_info_length
        SUB     r5, r5, r10
        BL      ts_skipbytes
        B       %BT10

ts_process_PCR_PID ROUT  ; only used when there is a dedicated PCR PID, ie PCRs are not on video or audio PIDs
        TST     r9, #TS_AF_Present_Bit
        MOVNE   r6, r5
        BLNE    ts_process_adaptation_field
        B       ts_skip_to_next_packet

ts_process_audio_PID
      [ DebugPID
        DLINE "Found Audio PID",cc
      ]
;        DREG    r8, "Entered ts_process_audio_PID, remaining packet length = "
        MOV     r6, r5                                  ; hang on to the PID, may match PCR_PID
        MOV     r5, #StreamFlags_AudioPresent           ; indicate audio data
        B       ts_process_vidoraud

ts_process_video_PID
      [ DebugPID
        DLINE "Found Video PID",cc
      ]
;        DREG    r8, "Entered ts_process_video_PID, remaining packet length = "
        MOV     r6, r5                                  ; hang on to the PID, may match PCR_PID
        MOV     r5, #StreamFlags_VideoPresent           ; indicate video data
ts_process_vidoraud ROUT
        LDR     lr, [r1, #CSH_LastResetStreamFlags]
        TST     lr, r5                                  ; check we are interested in this stream
        TSTNE   r9, #TS_Payload_Present_Bit             ; and there is payload in this packet
        BEQ     ts_skip_to_next_packet
ts_process_common
        TST     r9, #TS_AF_Present_Bit                  ; is an adaptation field present
        BLNE    ts_process_adaptation_field             ; if so, then deal with it

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_FullLengthUnknown ; assume not start of MPEG packet for now
        STR     r7, [r11, #PacketDescriptor_Flags]
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_FullLength] ; and zero full length for now

        TST     r9, #TS_PUSI_Bit                        ; is there a PES packet at the start of the payload
        BLNE    ts_process_PES_packet_header

        TEQ     r3, r4                                  ; ensure we've got at least one byte to send
        BLEQ    cowait
ts_vidaudpacketcontinue
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      ts_incrementpacketcount                 ; increment packet count for buffer

	LDR	lr, [r1, #CSH_StreamFlags]		; check stream flags to see if we should be skipping this
	TST	lr, #StreamFlags_SkipUntilCorrectMode
	BEQ	%FT30					; [no, we're OK]
	LDR	r7, [r1, #CSH_TrickModeControl]		; if we were skipping, the PES packet header we may have just had
	LDR	r10, [r1, #CSH_LastTrickModeControl]	; might be right type, so check if equal
	TEQ	r7, r10
	BICEQ	lr, lr, #StreamFlags_SkipUntilCorrectMode ; if so, then knock out bit, so we don't spend time checking any more
	STREQ	lr, [r1, #CSH_StreamFlags]		; and store back to stream flags
	BNE	ts_free_packet_and_skip			; else free packet descriptor and skip packet
30

	LDR	lr, [r1, #CSH_StreamFlags]		; check if we're skipping
	TST	lr, #StreamFlags_OVSNPTSkipping
	BNE	ts_free_packet_and_skip			; if so, free packet descriptor and skip packet

        CMP     r8, #0                                  ; negative length packet?
        BLT     ts_free_packet_and_skip			; then free packet descriptor and skip packet
        ADD     r7, r3, r8                              ; end of transport packet (if it was all in this buffer)
        CMP     r7, r4                                  ; is it all within this buffer?
        BHI     ts_notallinbuff

        BL      sendvidaudblock
        MOV     r3, r7                                  ; start from end of video block data
        B       ts_wait_for_sync

ts_notallinbuff
        SUB     r8, r7, r4                              ; r8 = amount of excess
        MOV     r7, r4
        BL      sendvidaudblock                         ; send this amount
        BL      cowait

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_FullLengthUnknown
        STR     r7, [r11, #PacketDescriptor_Flags]
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_FullLength]
        B       ts_vidaudpacketcontinue

ts_free_packet_and_skip
        Push    "r0"
        MOV     r0, r11                                 ; r0 -> packet
        BL      FreePackets                             ; free it (possibly also freeing buffer)
        Pull    "r0"
        B       ts_skip_to_next_packet

; Transport Stream utility routines

; ts_skipbytes skips r10 bytes
; may return with no bytes in current buffer

ts_skipbytes ROUT
        SUB     r8, r8, r10                     ; reduce outstanding number of bytes in packet
10
        ADD     r3, r3, r10                     ; advance current pointer by r10 bytes
        CMP     r3, r4                          ; if still within buffer
        MOVLS   pc, r14                         ; then exit
        SUB     r10, r3, r4                     ; r10 = remaining bytes to skip (correction TMD 31-Jul-95 - was SUB r10,r4,r3)
        Push    "lr"
        BL      cowait
        Pull    "lr"
        B       %BT10

ts_find_PSI_start                               ; this does the same thing!
ts_skip_adaptation_field Entry "r7"
        BL      getbytedec                      ; get adaptation_field_length (or pointer_field)
        MOV     r10, r7                         ; then skip that number of bytes
        BL      ts_skipbytes
        EXIT

ts_process_adaptation_field Entry "r7"
; On entry, r6 = PID
        BL      getbytedec                      ; r7 = adaptation_field_length
        ADDS    r10, r7, #0                     ; r10 = bytes remaining in adaptation field; also clear C
        LDR     r7, [r1, #CSH_PCR_PID]
        TEQ     r6, r7                          ; preserves C
        CMPEQ   r10, #7                         ; if correct PID and there are at least 7 bytes, set C
        BCS     %FT10
        BL      ts_skipbytes                    ; else skip the whole adaptation field
        EXIT                                    ; and exit
10
        BL      getbytedec                      ; get byte with flags in
        SUB     r10, r10, #1
        TST     r7, #&10                        ; check PCR_flag
        BEQ     %FT80                           ; do nothing if not set

        Push    "r9-r11"
        ADD     lr, r1, #CSH_PCR_old_packets
        LDMIA   lr!, {r9-r11}                   ; copy details for old PCR
        ASSERT  CSH_PCR_older_packets = CSH_PCR_old_packets + 12
        STMIA   lr, {r9-r11}                    ; over those for older PCR
        MOV     r9, #0                          ; initialise packet count to 0
        BL      getbytedec
        MOV     r10, r7, LSL #24
        BL      getbytedec
        ORR     r10, r10, r7, LSL #16
        BL      getbytedec
        ORR     r10, r10, r7, LSL #8
        BL      getbytedec
        ORR     r10, r10, r7
        BL      getbytedec
        MOV     r11, r7, LSL #24
        BL      getbytedec
        ORR     r11, r11, r7, LSL #16
        ORR     r11, r11, #1                    ; set validity bit
        ADD     lr, r1, #CSH_PCR_old_packets
        STMIA   lr, {r9-r11}                    ; store as details for old PCR
        Pull    "r9-r11"
        SUB     r10, r10, #6

80      BL      ts_skipbytes                    ; skip remaining bytes in adaptation field, if any
        EXIT

ts_process_PES_packet_header Entry
 [ DoPEH
; first check if PEH wants to get the PES packet headers himself
; if so, then don't process them ourselves

	CMP	r5, #3				; if 1 or 2 then must be vid or aud
	BCC	%FT10

	LDR	lr, [r5, #PEHPID_PEH]		; get PEH for this PEHPID
	LDR	lr, [lr, #PEH_Flags]		; get flags for this PEH
	TST	lr, #PEHFlags_IncludePESHeaders
	EXIT	NE				; he wants to get PES headers, so exit

10
 ] ; DoPEH
        BL      ts_getnextstartcode
 [ :LNOT: DoPEH					; may get other packet header codes than these in private data
        TEQ     r7, #&C0
        TEQNE   r7, #&E0
        BNE     ts_bad_packet_header
 ]

        BL      getbytedec                              ; get bits 8-15 of length
        MOV     r6, r7
        BL      getbytedec                              ; get bits 0-7 of length
        ORR     r6, r7, r6, LSL #8                      ; r6 = length of PES packet to go

;        DREG    r6, "Packet length = "

        TEQ     r6, #0                                  ; if it's a wishy-washy indeterminate-length packet
        MOVEQ   r7, #PacketDescriptorFlags_MPEGStart :OR: PacketDescriptorFlags_FullLengthUnknown       ; then indicate that
        MOVEQ   r6, #&80000000                          ; indicate for later
        MOVNE   r7, #PacketDescriptorFlags_MPEGStart    ; else just an MPEG start
        SUBNE   r6, r6, r8                              ; express length of PES packet as offset from remaining length of transport packet
        STR     r7, [r11, #PacketDescriptor_Flags]

        BL      getbytedec
        MOV     r7, r7, LSR #6
        TEQ     r7, #2_10
        BNE     ts_bad_packet_header                    ; if not '10' at start, then not MPEG 2 PES

        Push    "r5"                                    ; save video/audio flag, so we can use r5 as temp here
        BL      getbytedec                              ; get optional fields flags
        MOV     r5, r7
        BL      getbytedec                              ; get length of optional fields
        MOV     r10, r7

        TST     r5, #PES_Optional_PTS_Present		; PTS present?
        BEQ     ts_nopts
        BL      getbytedec                              ; get 1st byte of PTS
        BL      ts_getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        SUB     r10, r10, #5

        TST     r5, #PES_Optional_DTS_Present		; DTS present also?
        BEQ     ts_nodts
        BL      getbytedec                              ; get 1st byte of DTS
        BL      ts_getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_DTSValid ; set DTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        SUB     r10, r10, #5
ts_nodts
ts_nopts
	TST	r5, #PES_Optional_DSM_trick_mode_flag	; if the DSM trick mode field isn't present,
	MOVEQ	r5, #-1					; then indicate normal play, and skip the rest of the parsing
	BEQ	%FT20					; then don't go thru the hassle of skipping other fields before it

	MOV	r9, r10					; save number of bytes of header yet to skip
	TST	r5, #PES_Optional_ESCR_flag
	MOVEQ	r10, #0					; if no ESCR flag then no bytes to skip for it
	MOVNE	r10, #6					; else skip 6 bytes of ESCR
	TST	r5, #PES_Optional_ES_rate_flag		; if ES_rate flag present
	ADDNE	r10, r10, #3				; then skip another 3 bytes of that
	SUB	r9, r9, r10				; how many left to skip
	BL	ts_skipbytes				; skip the bytes

	BL	getbytedec   				; get trick_mode_control in bits 7:5, plus some other bits
	MOV	r5, r7, LSR #5				; extract the important bits
	SUB	r10, r9, #1				; bytes left to skip in header, not counting the byte we just got
20
	STR	r5, [r1, #CSH_LastTrickModeControl]	; and save indication of last trick_mode_control value, or -1 if none

        BL      ts_skipbytes                            ; skip other optional fields
        Pull    "r5"                                    ; restore audio/video flag

        TEQ     r6, #&80000000                          ; if was indeterminate length
        MOVEQ   r6, #0                                  ; then stick zero in full length
        ADDNE   r6, r6, r8                              ; else convert packet length back from offset
        STR     r6, [r11, #PacketDescriptor_FullLength] ; save full length of MPEG packet data (ignoring buffer breaks)
        EXIT

ts_bad_packet_header
        DLine   "Bad PES packet header"
        PullEnv
        B       ts_skip_to_next_packet

; This routine gets a 33-bit PTS, DTS or SCR from the stream
;
; in:   r7 = first byte (including bits 32..30)
; out:  r7 = low 32 bits
;       r9 = bit 32 in bit 0

ts_getclockreference ROUT
        Push    "lr"
        AND     r7, r7, #&0E                            ; extract bits 3..1
        MOV     r9, r7, LSR #3                          ; r9 = bit 32 in bit 0
        Push    "r9"                                    ; save for later
        MOV     r9, r7, LSL #31-2                       ; r9 = bits 31,30
        BL      getbytedec                              ; get bits 29..22 in bits 7..0
        ORR     r9, r9, r7, LSL #22                     ; r9 = bits 31..22
        BL      getbytedec                              ; get bits 21..15 in bits 7..1
        MOV     r7, r7, LSR #1
        ORR     r9, r9, r7, LSL #15                     ; r1 = bits 31..15
        BL      getbytedec                              ; get bits 14..7 in bits 7..0
        ORR     r9, r9, r7, LSL #7                      ; r1 = bits 31..7
        BL      getbytedec                              ; get bits 6..0 in bits 7..1
        ORR     r7, r9, r7, LSR #1                      ; r9 = bits 31..0
        Pull    "r9, pc"

ts_incrementpacketcount Entry "r0"
        SCPSR   I_bit, 0, lr,, r0                       ; disable IRQs

        LDR     lr, [r2, #BufferDescriptor_Packets]
        ADD     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        RestPSR r0,, c                                  ; restore IRQ state
        EXIT

        LTORG

ts_getnextstartcode Entry
ts_getnextstartcodeloop
        BL      getbytedec                              ; look for 1st zero of start code
        TEQ     r7, #0
        BNE     ts_getnextstartcodeloop
        BL      getbytedec                              ; look for 2nd zero of start code
        TEQ     r7, #0
        BNE     ts_getnextstartcodeloop
ts_gottwozeros
        BL      getbytedec                              ; look for "1" of start code
        CMP     r7, #1
        BCC     ts_gottwozeros                          ; if 3rd zero, then not start code, but we've got two zeros
        BNE     ts_getnextstartcodeloop                 ; not zero or one, so look for 1st zero again
        BL      getbytedec                              ; get start code reason
        EXIT


NPTDescriptorTag	*	&17
StreamModeDescriptorTag *       &19
streamMode_EndOfStream  *       &07

ts_check_for_OVSNPT ROUT
	CMP	r10, #1
	BCC	ts_process_rest_of_PMT			; no descriptor bytes left, so do rest of PMT
	BEQ	ts_skip_to_next_packet			; only 1 byte left, but need tag and length!
	BL	getbytedec   				; get descriptor tag
	MOV	r9, r7
	BL	getbytedec   				; get descriptor length
	SUB	r10, r10, #2				; adjust for tag + length bytes
	CMP	r7, r10					; if descriptor length > descriptors length
	CMPLS	r7, r8					; or descriptor length > rest of packet length
	BHI	ts_skip_to_next_packet			; then bogus
	SUB	r10, r10, r7				; remaining bytes of descriptors
	TEQ	r9, #NPTDescriptorTag
	BEQ	%FT10					; found NPT descriptor
	TEQ     r9, #StreamModeDescriptorTag
	BEQ     %FT50
05
	Push	"r10"
	MOV	r10, r7
	BL	ts_skipbytes				; skip the whole (or rest) of this descriptor
	Pull	"r10"
	B	ts_check_for_OVSNPT			; and try again


10      ; Handle NPTReferenceDescriptor
      [ DebugNPT
        SWI     XOS_WriteS
        =       "NPTReferenceDescriptor received", 0
        ALIGN
        SWI     XOS_NewLine
      ]
	Push	"r5"
	MOV	r5, r7					; length of this descriptor
	CMP	r7, #CSH_NPTDescMaxLen			; maximum amount we can store
	MOVHI	r5, #CSH_NPTDescMaxLen			; amount we will store
	SUB	r7, r7, r5				; amount we won't store
	Push	"r7"
	ADD	r9, r1, #CSH_NPTDescLength		; point at length field
	STRB	r5, [r9], #1				; indicate amount stored
20
	SUBS	r5, r5, #1				; if no more bytes to store
	BCC	%FT30					; then exit
	BL	getbytedec   				; else get another
	STRB	r7, [r9], #1				; and store in block
	B	%BT20					; then loop

30
      [ DebugNPT
        Push    "r0-r5"
        ADR     r5, ControlStreamHandle
        SUB     sp, sp, #4
        SWI     XOS_WriteS
        =       "ContentID=", 0
        ALIGN
        LDRB    r0, [r5, #CSH_NPTContentID]
        MOV     r1, sp
        MOV     r2, #4
        SWI     XOS_ConvertHex2
        SWI     XOS_Write0
        SWI     XOS_WriteS
        =       ", STC=", 0
        ALIGN
        LDRB    r0, [r5, #CSH_NPTSTCRef]
        AND     r0, r0, #1
        ADD     r0, r0, #'0'
        SWI     XOS_WriteC
        ADD     r3, r5, #CSH_NPTSTCRef+1
        ADD     r4, r3, #4
        PrintBlock r3, r4, sp
        SWI     XOS_WriteS
        =       ", NPT=", 0
        ALIGN
        LDRB    r0, [r5, #CSH_NPTNPTRef+3]
        AND     r0, r0, #1
        ADD     r0, r0, #'0'
        SWI     XOS_WriteC
        ADD     r3, r5, #CSH_NPTNPTRef+4
        ADD     r4, r3, #4
        PrintBlock r3, r4, sp
        SWI     XOS_WriteS
        =       ", ScaleNum=", 0
        ALIGN
        ADD     r3, r5, #CSH_NPTScaleNum
        ADD     r4, r3, #2
        PrintBlock r3, r4, sp
        SWI     XOS_WriteS
        =       ", ScaleDen=", 0
        ALIGN
        ADD     r3, r5, #CSH_NPTScaleDen
        ADD     r4, r3, #2
        PrintBlock r3, r4, sp
        SWI     XOS_NewLine
        ADD     sp, sp, #4
        Pull    "r0-r5"
      ]
	MOV	r7, #1
	STR	r7, [r1, #CSH_NPTCurrent]		; indicate NPT descriptor is current
	LDRB	r7, [r1, #CSH_NPTContentID]		; get new contentID
	AND	r7, r7, #&7F				; only bottom 7 bits are the contentID
	LDR	lr, [r1, #CSH_StreamFlags]
        LDR     r5, [r1, #CSH_LastContentID]		; see what ContentID was last time
        TEQ     r5, r7                                  ; if it's changed then it's a GDF
        TSTNE   lr, #StreamFlags_ResetOnGoodDataFollows ;   and we may need to reset ourselves
      [ DebugNPT
        BEQ     %FT00
        SWI     XOS_WriteS
        =       "*** GOOD DATA FOLLOWS ***", 0
        ALIGN
        SWI     XOS_NewLine
00
      ]
        BNE     %FT39
        TEQ     r5, r7                                  ; if GDF
        TSTNE   lr, #StreamFlags_OVSNPTSkipping         ;   and we're skipping
        BICNE   lr, lr, #StreamFlags_OVSNPTSkipping     ;   then clear skipping bit from flags, and jump
        STRNE   lr, [r1, #CSH_StreamFlags]
        BNE     %FT40
        TEQ     r5, r7                                  ; unless it's the same, and we're not skipping and not in trick play mode
        TSTEQ   lr, #StreamFlags_OVSNPTSkipping :OR: StreamFlags_TrickPlayMode
        BNE     %FT40                                   ;   then jump
        ; It's a segment transition, drop through...
      [ DebugNPT
        SWI     XOS_WriteS
        =       "*** SEGMENT TRANSITION ***", 0
        ALIGN
        SWI     XOS_NewLine
      ]
39      ; Reset decoder
        Push    "r0, r2, r3"
        LDR     r0, [r1, #CSH_NextResetStreamFlags]
        BIC     r0, r0, #ResetStreamFlags_DeferReset    ; flag that the deferred reset has now happened
        STR     r0, [r1, #CSH_NextResetStreamFlags]
        ORR     r0, r0, #ResetStreamFlags_InternalReset ; don't worry about waiting for a(nother) GDF
        BL      int_reset_stream
        MOV     r0, #0                                  ; use SetSpeed flags of 0
        LDR     r2, [r1, #CSH_NextSpeedIndicator]       ; get stored speed indicator
        BL      SetSpeed                                ; and execute the deferred SetSpeed call
        Pull    "r0, r2, r3"
        ; drop through...
40
	STR	r7, [r1, #CSH_LastContentID]		; always store new contentID as last
	Pull	"r7"
	Pull	"r5"					; wrong order to do in one go
	B	%BT05					; skip any part of the descriptor we couldn't store


50      ; Handle StreamModeDescriptor (for streamMode End of Stream)
        Push    "r5"
        SUB     r5, r7, #1                              ; we're only going to read the first byte of the descriptor
        BL      getbytedec
        TEQ     r7, #streamMode_EndOfStream
        BNE     %FT55
      [ DebugNPT
        SWI     XOS_WriteS
        =       "End of Stream received", 0
        ALIGN
        SWI     XOS_NewLine
      ]
      [ EOSDetect
       [ DebugEOS
        DLINE   "Parsed EOS descriptor"
       ]
        BL      AnticipateEndOfStream                   ; this waits for decoding to stop before issuing the UpCall
        MOV     r10, r8
        BL      ts_skipbytes            ; skip the rest of this TS packet
        TEQ     r3, r4                  ; if there is no data remaining in current buffer
        BLEQ    cowait                  ; then wait for more data (if any ever arrives)
        ; Although we may subsequently get a Good Data Follows and do an internal reset then,
        ; it is an OVS-specific concept, so for greater generality, do a reset now (as well)
        Push    "r0, r2, r3"
        LDR     r0, [r1, #CSH_NextResetStreamFlags]
        BIC     r0, r0, #ResetStreamFlags_DeferReset    ; flag that the deferred reset has now happened
        STR     r0, [r1, #CSH_NextResetStreamFlags]
        ORR     r0, r0, #ResetStreamFlags_InternalReset ; don't worry about waiting for a(nother) GDF
        BL      int_reset_stream
        MOV     r0, #0                                  ; use SetSpeed flags of 0
        LDR     r2, [r1, #CSH_NextSpeedIndicator]       ; get stored speed indicator
        BL      SetSpeed                                ; and execute the deferred SetSpeed call
        Pull    "r0, r2, r3"
        B       ts_wait_for_sync        ; start work on a new TS packet
      |
        ; the old way of doing things
        Push    "r0-r3"
        MOV     r0, #UpCall_MPEG
        MOV     r1, #0
        ADR     r2, ControlStreamHandle
        MOV     r3, #UpCallMPEG_EndOfStream
        SWI     XOS_UpCall
        Pull    "r0-r3"
        ; drop through...
      ]
55      MOV     r7, r5                                  ; r7 = original r7 - 1
        Pull    "r5"
        B       %BT05                                   ; continue (automatically skips last byte of descriptor)


; **************************************************************************
;
;       sendvidaudblock - send block of video/audio data
;
; in:
;       r1 = control stream handle
;       (r2 -> buffer descriptor)
;       r3 -> start of block to send (not necessarily start of buffer))
;       (r4 -> end of buffer)
;	r5 = StreamFlags_VideoPresent, StreamFlags_AudioPresent, or a pointer to the appropriate PEHPID
;       r7 -> end of block to send (+1))
;       r11 -> packet descriptor (filled in apart from Length field)

sendvidaudblock Entry "r0-r2"
        SUB     r0, r7, r3
        STR     r0, [r11, #PacketDescriptor_Length]
        MOV     r0, #0                  ; flags for MPEGVideo/Audio_FullPackets
        MOV     r2, r11
        TEQ     r5, #StreamFlags_VideoPresent
        BNE     %FT30

; send video block

        LDR     lr, DebugFlag
        TEQ     lr, #0
        BEQ     %FT20
        DLINE   "Video packet", cc
        Push    "r0"
        LDR     lr, [r2, #PacketDescriptor_Length]
        DREG    lr, ", length = ", cc
        LDR     lr, [r2, #PacketDescriptor_FullLength]
        DREG    lr, ", full length = ", cc
        SWI     XOS_WriteI+" "
        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_MPEGStart
        SWINE   XOS_WriteI+"M"
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown
        SWINE   XOS_WriteI+"U"
        TST     r0, #PacketDescriptorFlags_PTSValid
        BEQ     %FT10
        LDR     lr, [r2, #PacketDescriptor_PTS]
        DREG    lr, " PTS = ", cc
10
        DLINE   ""
        Pull    "r0"
20
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_FullPackets
        CLRV
        EXIT

30
 [ DoPEH
	TEQ	r5, #StreamFlags_AudioPresent
	BNE	%FT60
 ] ; DoPEH

; send audio block

        LDR     lr, DebugFlag
        TEQ     lr, #0
        BEQ     %FT50
        DLINE   "Audio packet", cc
        Push    "r0"
        LDR     lr, [r2, #PacketDescriptor_Length]
        DREG    lr, ", length = ", cc
        LDR     lr, [r2, #PacketDescriptor_FullLength]
        DREG    lr, ", full length = ", cc
        SWI     XOS_WriteI+" "
        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_MPEGStart
        SWINE   XOS_WriteI+"M"
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown
        SWINE   XOS_WriteI+"U"
        TST     r0, #PacketDescriptorFlags_PTSValid
        BEQ     %FT40
        LDR     lr, [r2, #PacketDescriptor_PTS]
        DREG    lr, " PTS = ", cc
40
        DLINE   ""
        Pull    "r0"
50
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_FullPackets
        CLRV
        EXIT

 [ DoPEH
60
	Push	"r3,r6"
	LDR	r6, [r5, #PEHPID_PEH]
	MOV	r3, r2						; r3 -> packet
	LDR	r2, [r5, #PEHPID_ProgramElementStreamHandle]
	MOV	r1, #0						; flags
	MOV	r0, #PEHReason_DataTransfer
	BL	CallPEH
	Pull	"r3,r6"
	CLRV
	EXIT
 ] ; DoPEH

xdebug SETL {FALSE}

ts_pid_enable Entry "r1"
	AND	r2, r1, #&FF
	AND	r1, r1, #&1F00
	ORR	r1, r1, #&47
	ORR	r1, r1, r2, LSL #16
	LDR	r2, =&00FF1FFF
	SWI	XDVBControl_MatchMask
	EXIT

; **************************************************************************
;
;       GetPacketDescriptor - Get a packet descriptor from free list, or RMA if that fails
;
; in:   r12 -> module workspace
;
; out:  r0 -> packet descriptor
;

GetPacketDescriptor Entry "r1"
        SCPSR   I_bit, 0, lr,, r1               ; disable IRQs (this time, really do it!)

        LDR     r0, FreePacketListHeadPtr
        TEQ     r0, #0
        BEQ     %FT10                           ; [no free packet descriptors]

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, FreePacketListHeadPtr       ; update FreePacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, FreePacketListTailPtr       ; then zero FreePacketListTailPtr

        RestPSR r1,, c                          ; restore IRQs
05
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
; now fill in some of the fields
        ADRL    r1, FreePackets
        STR     r1, [r0, #PacketDescriptor_FreeRoutine]
        STR     wp, [r0, #PacketDescriptor_FreeWorkspace]
        CLRV
        EXIT

10
        RestPSR r1,, c                          ; restore IRQ state
        Push    "r2, r3"
        MOV     r3, #PacketDescriptorSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVC   r0, r2
        Pull    "r2, r3"
        BVC     %BT05
        EXIT

 [ DoPEH
; **************************************************************************
;
;	CallPEH - Call a Program Element Handler
;
; in:	r0 = reason code
;	r1-r? = parameters for call
;	r6 -> PEH
;
; out:	Depends on call
;

CallPEH	Entry "r12"
	ADD	r12, r6, #:INDEX: PEH_HandlerWS
	ASSERT  PEH_HandlerCode = PEH_HandlerWS +4
	CMP     r0, r0                          ; ensure V clear on entry (C generic-veneer will preserve or set V, never clear it)
	MOV	lr, pc
	LDMIA	r12, {r12, pc}
	EXIT
 ] ; DoPEH

; **************************************************************************
;
;	Stats - Entry point for MPEGControl_Stats - return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = control stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

; In contrast to the implementations in the elementary modules, the MPEGControl items
; are either the offset from the *stream handle* to the value (if positive), or the negation
; of the code offset into the module if a routine (if negative)
; Unfortunately, you can't use :BASE: with an absolute item (eg the CSH_ values), so
; we have to have an explicit flag on the macro.

	MACRO
	StatsTableEntry	$tag, $value, $codeP
 [ "$codeP"=""
	&	$tag, :INDEX: ($value)
 |
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

Stats	Entry "r0-r2, r5-r6"
        Debug   entry, "MPEGControl_Stats: ", r0, r1, r2, r3, r4

; First call video and audio to output their stuff

	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_VideoStreamHandle]
	SWI	XMPEGVideo_Stats
	LDMIA	sp, {r0,r1}			; reload flags + control handle
	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
	SWI	XMPEGAudio_Stats

; Note: r3 and r4 will have been updated after those

	LDMIA	sp, {r0,r1}			; reload flags + control handle again
	TEQ	r1, #0				; if no handle specified
	ADREQ	r1, ControlStreamHandle		; then use global one

; loop over all tags in input list, advancing input list pointer r2

StatsLoopReEntry
10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	BEQ	%FT90				; then exit

	ADR	r6, StatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [r1, lr]			; NB: relative to handle, not wp
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

; done all tags

90
	CMP	r4, #0				; if remaining space in buffer is >=0, then V:=0
	EXIT	PL				; and exit

	ADR	r0, BufferOverflowError		; else return an error
	STR	r0, [sp]
	SETV
	EXIT

BufferOverflowError
	&	0
	=	"Buffer overflow", 0
	ALIGN

; The statistics that are done by routine:
; (must come before StatsTable so not forward reference)

Stats_InTime Entry
	LDR	r6, [r1, #CSH_LastTime]		; lasttime - starttime
	LDR	lr, [r1, #CSH_StartTime]
	SUB	r6, r6, lr
	EXIT

Stats_SkippingUntilCorrectMode Entry
	LDR	r6, [r1, #CSH_StreamFlags]
	ANDS	r6, r6, #StreamFlags_SkipUntilCorrectMode
	MOVNE	r6, #1
	EXIT

Stats_NPTDescriptor ROUT
	LDRB	r6, [r1, #CSH_NPTDescLength]
	ADD	lr, r6, #15			; add on three words for tag + length + current flag + round up to a word
	BIC	lr, lr, #3
	SUBS	r4, r4, lr
	BMI	StatsLoopReEntry		; not enough space to store entry

	SUBS	lr, lr, #8			; length not including tag + length, but including flag + round-up
	STMIA	r3!, {r5, lr}			; store tag and length
	LDR	r5, [r1, #CSH_NPTCurrent]	; store current flag
	STR	r5, [r3], #4
	SUB	lr, lr, #4			; adjust for flag word
	ADD	r5, r1, #CSH_NPTContentID	; point at first byte of descriptor
10
	SUBS	lr, lr, #1			; if a byte left
	LDRCSB	r6, [r5], #1
	STRCSB	r6, [r3], #1
	BCS	%BT10
	B	StatsLoopReEntry		; now parse next tag

Stats_CSH Entry
        MOV     r6, r1
        EXIT

Stats_Bitrate Entry "r0-r5"
        LDR     lr, [r1, #CSH_ControlStreamType]
        TEQ     lr, #ControlStreamType_MPEG2Transport
        LDRNE   r6, [r1, #CSH_SystemBitrate]
        EXIT    NE                              ; we only have to calculate the bitrate ourselves for transport streams

        ADD     lr, r1, #CSH_PCR_old
        LDMIA   lr, {r1-r5}                     ; get PCR info
        AND     lr, r2, r5
        TST     lr, #1                          ; if either of the PCRs is invalid
        MOVEQ   r6, #0                          ; then exit with a flag value of 0
        EXIT    EQ

        MOV     r0, r2, LSL #7                  ; r0 is 27MHz part of old PCR in bits 23-31
        AND     r2, r2, #&80000000              ; r1,r2 is 90kHz part of old PCR
        MOV     r6, r5, LSL #7                  ; r6 is 27MHz part of older PCR in bits 23-31
        AND     r5, r5, #&80000000              ; r4,r5 is 90kHz part of older PCR
        SUBS    r2, r2, r5
        SBC     r1, r1, r4                      ; r1,r2 is difference between 90kHz parts, should be small and positive
        MOV     r4, r2, LSR #29
        ORR     r4, r4, r1, LSL #3              ; r4 = 4 * difference
        MOV     r5, r4, LSL #1                  ; r5 = 8 * difference
        ADD     r5, r5, r4, LSL #3              ; r5 = 40 * difference
        ADD     r5, r5, r4, LSL #6              ; r5 = 296 * difference
        ADD     r4, r4, r5                      ; r4 = 300 * difference (ie now in 27MHz ticks)
        ADD     r4, r4, r0, LSR #26
        SUB     r4, r4, r6, LSR #26             ; r4 is now total time difference, in 27MHz ticks

        ; Save FP context - requires 32-bit FPEmulator, so STB-3 or later only
        RFS     r1
        STR     r1, Saved_FPSR
        MOV     r1, #&00000000                  ; all exceptions suppressed
        WFS     r1
        ASSERT  :INDEX: Saved_FPRegs < 1024     ; aasm does not assemble SFM and LFM correctly
        DCD	&EDCC8200+:INDEX:Saved_FPRegs/4 ; SFM     f0, 3, [wp, #:INDEX:Saved_FPRegs]

        LDFD    f2, =4.0608E10                  ; = 188*8*27E6 = length of packet in bits, divided by length of tick in seconds
        FLTD    f0, r3                          ; number of TS packets between PCRs
        FLTD    f1, r4                          ; time between PCRs in 27MHz ticks
        MUFD    f0, f0, f2
        DVFD    f0, f0, f1
        FIX     r6, f0                          ; r6 = bitrate in bits per second

        ; Restore FP context
        DCD	&EDDC8200+:INDEX:Saved_FPRegs/4 ; LFM     f0, 3, [wp, #:INDEX:Saved_FPRegs]
        LDR     r1, Saved_FPSR
        WFS     r1

        EXIT

Stats_DirectFullBuffers ROUT
        ADRL    r6, FullBuffers_DirectAccessWrapper
        MOV     pc, lr

        LTORG

; The table containing all the statistics

StatsTable
	StatsTableEntry &0000, CSH_DataReceived
	StatsTableEntry &0001, Stats_InTime, Code
	StatsTableEntry &0003, CSH_PMT_PID
	StatsTableEntry &0004, CSH_Video_PID
	StatsTableEntry &0005, CSH_Audio_PID
	StatsTableEntry &0006, CSH_DataReturned
	StatsTableEntry &0007, Stats_SkippingUntilCorrectMode, Code
	StatsTableEntry &0008, CSH_DataDiscarded
	StatsTableEntry &0009, Stats_NPTDescriptor, Code
        StatsTableEntry &000A, Stats_CSH, Code
        StatsTableEntry &000B, Stats_Bitrate, Code
        StatsTableEntry &000C, Stats_DirectFullBuffers, Code
	&	-1

; **************************************************************************
;
;       CtrlInfo_Code - Code to handle CtrlInfo command
;
; in:   -
; out:  -

CtrlInfo_Code Entry "r7"
        LDR     wp, [r12]
        ADR     r1, ControlStreamHandle

        LDR     r7, [r1, #CSH_ControlStreamType]
        ADRL    r0, StreamTypeStrings
        ADD     r0, r0, r7, LSL #5
        SWI     XOS_Write0
        SWI     XOS_NewLine

        TEQ     r7, #ControlStreamType_MPEG2Transport
        BNE     %FT01

        LDR     r0, [r1, #CSH_PMT_PID]
        DREG    r0, "PMT PID = "

        LDR     r0, [r1, #CSH_Video_PID]
        DREG    r0, "Video PID = "

        LDR     r0, [r1, #CSH_Audio_PID]
        DREG    r0, "Audio PID = "
01

        DLINE   "In the ", cc
        LDR     r3, [r1, #CSH_LastTime]
        LDR     r0, [r1, #CSH_StartTime]
        SUB     r0, r3, r0
        BL      DecimalOutput
        DLINE   " cs since the stream was opened:"

        DLINE   " bytes received = ", cc

        LDR     r0, [r1, #CSH_DataReceived]
        BL      DecimalOutput
        DLINE   ""
        LDR     r2, [r1, #CSH_DataReceivedAtPlayTime]
        SUB     r2, r0, r2

        DLINE   " bytes returned = ", cc

        LDR     r0, [r1, #CSH_DataReturned]
        BL      DecimalOutput
        DLINE   ""

        CMP     r7, #ControlStreamType_MPEG2Program
        RSBLES  lr, r7, #ControlStreamType_MPEG1Packet
        BGT     %FT02

	DLINE	" number of start code sync losses = ", cc
	LDR	r0, [r1, #CSH_SyncLosses]
	BL	DecimalOutput
	DLINE	""

	DLINE	" number of short packets = ", cc
	LDR	r0, [r1, #CSH_TooShortPackets]
	BL	DecimalOutput
	DLINE	""
02

 [ EOSDetect
        DLINE   "Number of buffers currently held = ", cc
        LDR     r0, [r1, #CSH_BufferCount]
        BL      DecimalOutput
        DLINE   ""
      [ DebugEOS
        LDR     r0, [r1, #CSH_EOSFlags]
        DREG    r0, "EOSFlags = "
      ]
 ]

        LDR     r0, [r1, #CSH_PlayTime]
        SUBS    r0, r3, r0
        BEQ     %FT10

; we want to perform (bytes*100)/cs, but bytes*100 might overflow 32 bits
; so we do bytes/cs then multiply fractional part by 100 and add on

        DivRem  r3, r2, r0, r4
        MOV     r4, #100
        MUL     r2, r4, r2              ; multiply fractional part by 100
        DivRem  r5, r2, r0, r14         ; and divide by denominator
        Push    "r0"                    ; save amount of time for later
        MLA     r0, r3, r4, r5          ; add on original value*100
        DLINE   "Measured data rate = ", cc
        BL      DecimalOutput
        DLINE   " bytes/second  = ",cc
        MOV     r0, r0, LSL#3
        BL      DecimalOutput
        DLINE   " bits/second"
        Pull    "r0"
 [ DataRateStats
; r0 = number of centiseconds since starting

        LDR     lr, =DataCountPeriod*100
        DivRem  r2, r0, lr, r3          ; r2 = number of periods since starting
        CMP     r2, #DataCountArraySize ; if filled array
        MOVHI   r2, #DataCountArraySize ; then pretend we just filled it
        ADD     r3, r1, #CSH_DataCounts
        MOV     r4, #0                  ; period number
05
        TEQ     r4, r2                  ; if no more periods
        BEQ     %FT10                   ; then finished
        DLINE   "In period ", cc
        MOV     r0, r4
        BL      DecimalOutput
        DLINE   ", average data rate was ", cc
        LDR     r5, [r3], #4
        LDR     lr, =DataCountPeriod
        DivRem  r0, r5, lr, r6          ; convert from bytes/minute to bytes/second
        BL      DecimalOutput
        DLINE   " bytes/second"
        ADD     r4, r4, #1
        B       %BT05
 ]
10

        TEQ     r7, #ControlStreamType_MPEG2Transport
        BEQ     %FT11
        TEQ     r7, #ControlStreamType_MPEG1System
        TEQNE   r7, #ControlStreamType_MPEG2ProgramNoPSM
        TEQNE   r7, #ControlStreamType_MPEG2Program
        BNE     %FT12

        ; Print system/program bitrate
        LDR     r0, [r1, #CSH_SystemBitrate]
        DLINE   "Ideal bitrate (from pack header) = ", cc
        BL      DecimalOutput
        DLINE   " bits/second"
        B       %FT12
11
        ; Print transport stream bitrate
        LDR     r0, [r1, #CSH_PCR_PID]
        DREG    r0, "Ideal bitrate (from PCRs on PID ", cc
        DLINE   ") = ", cc
        BL      Stats_Bitrate
        MOV     r0, r6
        BL      DecimalOutput
        DLINE   " bits/second"
12

        LDR     r0, [r1, #CSH_LastResetStreamFlags]
        DREG    r0, "Last ResetStream flags = "

        TEQ     r7, #ControlStreamType_MPEG2Program
        TEQNE   r7, #ControlStreamType_MPEG2Transport
        EXIT    NE

        ; Everything else past this point relates to or requires PSI

	LDR	r0, [r1, #CSH_LastContentID]
	DREG	r0, "Last contentID = "

 [ DoPEH
	DLINE	"Program Element Handlers:", cc
	LDR	r0, GlobalPEHList
	TEQ	r0, #0
	BNE	%FT40

	DLINE	" None"
	B	%FT50
40
	DLINE	""
42
	BL	OutputPEHInfo
	LDR	r0, [r0, #PEH_Link]
	TEQ	r0, #0
	BNE	%BT42
50
	DLINE	"PEH PID nodes:", cc
	ADR	r0, ControlStreamHandle
	LDR	r1, [r0, #CSH_ListOfPEHPIDs]
	TEQ	r1, #0
	BNE	%FT60

	DLINE	" None"
	B	%FT70
60
	DLINE   ""
61
	LDR	r0, [r1, #PEHPID_PEH]
	BL	OutputPEHInfo
	LDR	r0, [r1, #PEHPID_Flags]
	DREG	r0, "  PEHPID flags = "
	LDR	r0, [r1, #PEHPID_ProgramElementStreamHandle]
	DREG	r0, "  Program element stream handle = "
	LDR	r0, [r1, #PEHPID_PID]
	DREG	r0, "  PID = "
      [ {FALSE}
	LDR	r0, [r1, #PEHPID_PIDSlot]
	DREG	r0, "  PID slot = "
      ]
	LDR     r0, [r1, #PEHPID_Discontinuities]
	DREG    r0, "  Discontinuities in PID = "
	LDR	r1, [r1, #PEHPID_Link]
	TEQ	r1, #0
	BNE	%BT61
70
 ] ; DoPEH
        CLRV
        EXIT

 [ DoPEH
OutputPEHInfo Entry "r1"
	LDR	r1, [r0, #PEH_StreamType]
	DREG	r1, " StreamType=", cc
	LDR	r1, [r0, #PEH_Flags]
	DREG	r1, " Flags=", cc
	LDR	r1, [r0, #PEH_HandlerCode]
	DREG	r1, " Code=", cc
	LDR	r1, [r0, #PEH_HandlerWS]
	DREG	r1, " WS="
	EXIT
 ] ; DoPEH

        LTORG

        ALIGN   32
StreamTypeStrings
        =       "UNDETERMINED STREAM TYPE", 0
        ALIGN   32
        =       "UNRECOGNISED STREAM TYPE", 0
        ALIGN   32
        =       "ELEMENTARY VIDEO STREAM", 0
        ALIGN   32
        =       "ELEMENTARY AUDIO STREAM", 0
        ALIGN   32
        =       "MPEG-1 PACKET STREAM", 0
        ALIGN   32
        =       "MPEG-1 SYSTEM STREAM", 0
        ALIGN   32
        =       "MPEG-2 PES STREAM", 0
        ALIGN   32
        =       "MPEG-2 PROGRAM STREAM", 0
        ALIGN   32
        =       "MPEG-2 PROGRAM STREAM WITH PSM", 0
        ALIGN   32
        =       "MPEG-2 TRANSPORT STREAM", 0
        ALIGN

; **************************************************************************

CtrlDebugOn_Code Entry
        MOV     r0, #1
        B       CtrlDebugCommon

CtrlDebugOff_Code ALTENTRY
        MOV     r0, #0
CtrlDebugCommon
        LDR     wp, [r12]
        STR     r0, DebugFlag
        EXIT

; **************************************************************************

 [ Capture
MPEGCapture_Code
        Entry   "R7, R8"
        LDR     wp, [r12]
        MOV     r1, r0
        MOV     r0, #10
        SWI     XOS_ReadUnsigned  ; how many megabytes requested?
        EXIT    VS
        MOV     r2, r2, LSL#20    ; convert to bytes

        LDR     r0, CaptureEnable
        MOV     lr, #0
        STR     lr, CaptureEnable ; disable capturing while DA is invalid
        TEQ     r0, #1
        LDREQ   r1, CaptureDANo   ; if a DA is already allocated, then remove it
        SWIEQ   XOS_DynamicArea
        EXIT    VS

        TEQ     r2, #0
        EXIT    EQ                ; if new size requested was 0, then exit with capturing disabled

        STR     r2, CaptureDASize
        MOV     r0, #0            ; create dynamic area
        MOV     r1, #-1
        MOV     r3, #-1
        MOV     r4, #&80          ; non-draggable
        MOV     r5, r2
        MOV     r6, #0
        MOV     r7, #0
        ADRL    r8, Mod_Title
        SWI     XOS_DynamicArea
        EXIT    VS

        STR     r1, CaptureDANo
        STR     r3, CaptureDAStart
        STR     r3, CaptureWritePtr
        MOV     lr, #0
        STR     lr, CaptureAmount
        MOV     lr, #1
        STR     lr, CaptureEnable
        EXIT

MPEGSave_Code
        Entry
        LDR     wp, [r12]
        LDR     lr, CaptureEnable
        TEQ     lr, #1
        BNE     %FT99

        MOV     r1, r0   ; filename is specified in command tail
        MOV     r0, #&80 ; open new file
        SWI     XOS_Find
        EXIT    VS
        MOV     r1, r0   ; move file handle into r1 for use in OS_GBPB

        LDR     r0, CaptureDASize
        LDR     r2, CaptureWritePtr
        LDR     r5, CaptureAmount
        CMP     r5, r0           ; if more than this, then we've filled the DA
        MOVGT   r5, r0
        LDR     r6, CaptureDAStart

        SUB     r2, r2, r5       ; start address, neglecting pointer wrap
        SUBS    r3, r6, r2       ; distance from r2 to CaptureDAStart: if >0, then we have to save top of DA first
        SUBGT   r5, r5, r3       ; deduct r3 from the amount we do in the second OS_GBPB
        ADDGT   r2, r2, r0
        MOV     r0, #2
        SWIGT   XOS_GBPB
        MOVVC   r2, r6           ; if we've wrapped, then second half starts at DA start, otherwise we started there anyway
        MOVVC   r3, r5
        SWIVC   XOS_GBPB

        BVS     %FT98
        MOV     r0, #0   ; close file
        SWI     XOS_Find
        EXIT
98
        Push    "r0"
        MOV     r0, #0   ; close file
        SWI     XOS_Find
        Pull    "r0"
        SETV
        EXIT
99
        ADR     r0, NotCapturedError
        SETV
        EXIT
NotCapturedError
        &       0
        =       "No captured MPEG stream", 0
        ALIGN
 ]

; **************************************************************************
;
;       DecimalOutput - Decimal output routine
;
; in:   r0 = value to be output
; out:  -

DecimalOutput Entry "r0-r2",16
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        SWI     XOS_Write0
        EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END
