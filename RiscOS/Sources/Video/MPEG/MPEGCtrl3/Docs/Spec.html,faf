<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML lang="en">
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>MPEGControl 3 Functional Specification</TITLE>
</HEAD>

<BODY bgcolor="#ffffff">

<H1 align="center">MPEGControl 3<BR>Functional Specification</H1>

<HR>

<P align="center"><STRONG>CONFIDENTIAL</STRONG>

<HR>

<TABLE border="0" width="50%" align="center">
<TR><TD>Document ref:    <TD>/FS
<TR><TD>Issue:           <TD>A
<TR><TD>Date:            <TD>18 Sep 2000
<TR><TD>Author(s):       <TD><A href="mailto:ben.avison@pace.co.uk">Ben Avison</A>
<TR><TD>Change:          <TD>
<TR><TD>Classification:  <TD>Pace Restricted
</TABLE>

<H2>Contents</H2>

<TABLE border="0" width="100%">
<TR><TD width="8%">1. <TD><A href="#overview">    Overview</A>
<TR><TD>2.         <TD><A href="#outstanding">    Outstanding issues</A>
<TR><TD>3.         <TD><A href="#technical">      Technical background</A>
<TR><TD>4.         <TD><A href="#user">           User interface</A>
<TR><TD>5.         <TD><A href="#programmer">     Programmer interface</A>
<TR><TD>6.         <TD><A href="#interchange">    Data interchange</A>
<TR><TD>7.         <TD><A href="#formats">        Data formats</A>
<TR><TD>8.         <TD><A href="#external">       External dependencies</A>
<TR><TD>9.         <TD><A href="#acceptance">     Acceptance test</A>
<TR><TD>10.        <TD><A href="#noncompliances"> Noncompliances</A>
<TR><TD>11.        <TD><A href="#test">           Development test strategy</A>
<TR><TD>12.        <TD><A href="#organisation">   Product organisation</A>
<TR><TD>13.        <TD><A href="#enhancements">   Future enhancements</A>
<TR><TD>14.        <TD><A href="#glossary">       Glossary</A>
<TR><TD>15.        <TD><A href="#references">     References</A>
<TR><TD>16.        <TD><A href="#history">        History</A>
</TABLE>

<HR>

<H2><A name="overview">1. Overview</A></H2>

<P>Copyright &copy; Pace Micro Technology plc 2000, all rights reserved.

<P>No part of this document may be reproduced, transmitted, transcribed, stored
in a retrieval system or translated into any language (natural or computer), in
any form or by any means without the prior written permission of Pace Micro
Technology plc.

<P>This document specifies the software module MPEGControl, which demultiplexes
MPEG-1 system streams and MPEG-2 PES, program and transport streams into video,
audio and other elementary streams (or can equally accept a raw elementary
stream) and passes the elementary stream data on to appropriate other modules
for decoding.

<HR>

<H2><A name="outstanding">2. Outstanding issues</A></H2>

<P>There are no outstanding issues.

<HR>

<H2><A name="technical">3. Technical background</A></H2>

<IMG src="Fig1.gif" alt="MPEG Decoder Block Diagram (not shown)" width="537" height="325">

<P>The above diagram shows the data flows associated with playing an MPEG
stream. Buffers full of data are read either from the network, or from a local
storage medium (eg a hard disc or CD-ROM drive) and are passed to the control
unit (the MPEGControl module). The control unit parses the data into packets
containing the elementary video, audio or other program element data, which get
passed to the respective units. When these units have finished processing a
packet, they call the 'free' routine associated with the packet, which resides
in the control unit. This decrements the count of outstanding packets
associated with the parent buffer, and if this is now zero, it in turn calls
the buffer's free routine which resides in the bitstream transport unit. This
buffer is now available to accept more data from the stream.

<P>The function of both the video and audio units is performed by the
MPEGDriver module in STB-400, or the MPEG2Video module in STB-3 and STB-22. In
the original STB-1 design, the video/audio data was delivered to the
video/audio units (implemented in two separate modules) exclusively by means of
MPEGVideo/MPEGAudio SWI calls. However, additional program element units can
now be registered with the system, which could decode other data associated
with the current program, for example subtitles. In order not to have to invent
new SWI calls for each new type of program element data, an interface has been
designed which performs data transfer by directly calling an entry point which
the program element unit registers with the control unit. This has the added
benefit of removing the SWI call overhead, so for greater efficiency,
MPEGDriver and MPEG2Video use this mechanism to receive video data, and also
audio data in the case of MPEGDriver. Note that the program element units must
have an associated stream_type or PID, which restricts their usefulness to
transport streams and program streams with program stream maps, so MPEG2Video
and MPEGDriver retain the older SWI interface for use with other stream types.

<P>The function of the bitstream transport unit is typically performed by the
UDPV module. However, some data delivery methods require the relevant modules
to interface directly with the MPEG system; examples include the NEC video
client and LVFGeneric, the VideoControl protocol module for "local" MPEG data
(including NFS data transfer). Historically, the controlling application had to
perform as the bitstream transport unit for local data.

<HR>

<H2><A name="user">4. User interface</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="programmer">5. Programmer interface</A></H2>

<H3>5.1. Software Interrupts (SWIs)</H3>

<P>The MPEGControl SWIs are the main external entry points to the MPEG decoding
system. Typically, they in turn call equivalent MPEGVideo and/or MPEGAudio
SWIs.

<P>The following documentation applies to MPEGControl 3.00 (18 Sep 2000).

<H4 align="right">MPEGControl_OpenStream
<BR>(SWI &amp;492C0)</H4>

<P>Opens stream to MPEG decoders

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>stream flags
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>Video data is present in the MPEG stream,
                                      so open stream to video unit
                      <TR><TD>1   <TD>Audio data is present in the MPEG stream,
                                      so open stream to audio unit
                      <TR><TD>2   <TD>Perform audio-to-stream synchronisation.
                                      When this bit is set, the audio unit
                                      regularly monitors the fullness of its
                                      buffer, and if it is above a given
                                      threshold, it instructs the audio decoder
                                      to play the stream fast. Similarly, if
                                      the buffer fullness is below another
                                      threshold, it instructs the audio decoder
                                      to play the stream slow. In this manner,
                                      the audio decoder (and hence also the
                                      video decoder) keeps in step with the
                                      incoming data rate and does not get
                                      buffer overruns or underruns if there is
                                      a mismatch between the rate at which a
                                      video server transmits data and the rate
                                      at which data is consumed by the decoders
                      <TR><TD>3   <TD>Do not perform video-to-audio
                                      synchronisation. Normally the audio
                                      decoder generates interrupts when it is
                                      about to present an audio frame which has
                                      an associated PTS. This PTS value is then
                                      passed as an SCR value to the video
                                      decoder. In this way the video is
                                      synchronised to the audio. When this bit
                                      is set, this synchronisation is disabled
                      <TR><TD>4   <TD>Reserved - set to zero <I>(on MPEG-1
                                      hardware, this suppressed the sending of
                                      video PTSs to the video decoder)</I>
                      <TR><TD>5   <TD>Use callbacks from centisecond IRQs to
                                      send data to the MPEG chip's private RAM,
                                      rather than directly in the IRQ routine
                      <TR><TD>6   <TD>Reserved - should be set to 1 <I>(was
                                      used on MPEG-1 hardware to cause the
                                      MPEGAudio module to initially discard
                                      data until the first audio
                                      synchronisation word - cannot be disabled
                                      on modern MPEG chips)</I>
                      <TR><TD>7   <TD>Reserved - set to zero <I>(hardware debug
                                      flag applicable to STB-22/STB-3 only)</I>
                      <TR><TD>8   <TD>Reserved - set to zero <I>(was
                                      StartPaused flag on MPEG-1 hardware, not
                                      required for subsequent hardware)</I>
                      <TR><TD>9   <TD>Reserved - set to zero <I>(enables
                                      support for prototype PID filter hardware
                                      which cannot be fitted to STB-400)</I>
                      <TR><TD>10  <TD>Enable OVS support: activates parsing of
                                      MPEG-2 DSM-CC NPT Reference and Stream
                                      Mode program descriptors in the
                                      TS_program_map_section. This is a
                                      prerequisite for internal end-of-stream
                                      detection in transport streams. It also
                                      assigns OVS-specific interpretations to
                                      repeated NPT Reference descriptors: if
                                      the contentId field changes, it is
                                      interpreted as a "Good Data Follows"
                                      (which has a special meaning for SWI
                                      MPEGControl_ResetStream); or if the
                                      contentId field is unchanged, it is
                                      interpreted as a "Segment Transition"
                                      (unless ResetStream flag bit 3 is set,
                                      because identical NPT Reference
                                      descriptors are sent repeatedly in trick
                                      play mode) and a stream reset is
                                      generated internally
                      <TR><TD>11  <TD>If flag bit 10 is set, this bit can be
                                      used to activate an alternative treatment
                                      of Good Data Follows:
                                      MPEGControl_ResetStream need not be
                                      called in advance, or if it is, it should
                                      normally be called with flag bit 4 set
                                      (defer reset), which merely caches the
                                      values of the other flag bits. Then, at
                                      the point when the repeated NPT Reference
                                      descriptor with the incremented contentId
                                      is parsed by the control unit, it
                                      generates a reset internally (similar to
                                      the behaviour on Segment Transitions)
                                      using the cached ResetStream flags from
                                      the deferred ResetStream SWI
                      <TR><TD colspan="2">Other bits are reserved and should be
                                      set to zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 = <TD>reserved for control parameters structure pointer (should be
                 set to zero)
<TR><TD>R2 = <TD>pointer to video parameters structure
<TR><TD>R3 = <TD>pointer to audio parameters structure
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = control stream handle

<H5>Use</H5>

<P>This call performs all the actions necessary to be ready to play an MPEG
stream. Depending on bits 0 and 1 of the stream flags, it calls
MPEGVideo_OpenStream and/or MPEGAudio_OpenStream; it also issues the OpenStream
reason code to each program element handler.

<P>If successful it returns a control stream handle in R0, for use with
subsequent MPEGControl SWIs.

<H4 align="right">MPEGControl_FullBuffers
<BR>(SWI &amp;492C1)</H4>

<P>Pass buffers full of MPEG data to the appropriate decoders

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>all the bitstream buffer descriptors
                                      pointed to by R2 have flag bit 31 (in
                                      the Packets field) set
                      <TR><TD colspan="2">Other bits are reserved and must be
                                      zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>control stream handle
<TR><TD>R2 =      <TD>pointer to one or more linked bitstream buffer
                      descriptors for buffers full of MPEG data
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is made by the bitstream transport unit when it has received new
data. The control unit parses the data in each buffer, and identifies the
contiguous sections of elementary stream payload within them. For each of these
sections it allocates a packet descriptor, and then calls either
MPEGVideo_FullPackets, MPEGAudio_FullPackets or the appropriate program element
handler.

<P>In any case, data for the video or audio unit is ignored if the appropriate
bit in the stream flags (bit 0 or 1 for video or audio respectively) is clear.

<P>For reasons relating to the handling of multiple concurrent control streams,
a new format of bitstream buffer descriptor has been introduced, such that the
control stream handle is held in the word at offset +24. It is <B>strongly
recommended</B> that all clients use this new format if at all possible,
because support for the old format may have to be removed in future. Flag bit
0 passed to this SWI in R0 is not currently acted upon, but at such a time as
support for old format bitstream buffer descriptors is withdrawn, it will be
used to fault old clients, so it must be set if you are using the new format
descriptors.

<P>There is a faster, direct-call interface that may be used instead of this
SWI, see MPEGControl_Stats. Note that the direct-call interface requires the
use of new format bitstream buffer descriptors.

<P>On entry to this SWI, the Packets field of each buffer descriptor must be
set to &amp;80000000 (or zero for old format bitstream buffer descriptors).

<P>Note that while the data pointed to by a buffer descriptor is being
processed by the MPEG modules, the memory occupied by both the bitstream buffer
and the bitstream buffer descriptor itself should be considered to be owned by
the MPEG modules, and must not be modified by the caller.

<P>When all the data in the buffer has been processed, the buffer is freed by
the control unit, using the following procedure:

<P>If the value in the FreeRoutine field of the bitstream buffer descriptor is
non-zero, then this is taken as the address of a routine, which is called as
follows:-

<H6>On entry</H6>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =       <TD>reserved (currently holds a value of 3)
<TR><TD>R1 =       <TD>pointer to bitstream buffer descriptor
<TR><TD>R12 =      <TD>contents of FreeWorkspace field of the bitstream buffer
                       descriptor
<TR><TD>R14&nbsp;= <TD>return address, including PSR bits if in a 26-bit
                       processor mode
<TR><TD colspan="2">Processor is in SVC mode
<TR><TD colspan="2">Interrupt status is undefined
<TR><TD colspan="2">Fast interrupts are enabled
</TBODY>
</TABLE>

<H6>On exit</H6>

<P>R0-R2, R12, R14 and the processor flags may be corrupted, all other
registers must be preserved.

<P>However, if the value in the FreeRoutine field is zero, then the
FreeWorkspace field is taken as a SWI number to call as follows:-

<H6>On entry</H6>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>the end-of-stream system start code
                                      &amp;000001B9 has been received since the
                                      start of the stream
                      <TR><TD colspan="2">Other bits are reserved and may take
                                      any value.
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>reserved (currently zero)
<TR><TD>R2&nbsp;= <TD>pointer to bitstream buffer descriptor
<TR><TD colspan="2">Processor is in SVC mode (as per all SWIs)
<TR><TD colspan="2">Interrupt status is undefined
<TR><TD colspan="2">Fast interrupts are enabled
</TBODY>
</TABLE>

<H6>On exit</H6>

R3-R9 must be preserved, but the processor flags may be corrupted.

<P>Note that the SWI number provided must have the 'X' bit (bit 17) set.

<P>In both cases, the bitstream transport unit is now free to reuse the buffer
data area and the buffer descriptor.

<H4 align="right">MPEGControl_CloseStream
<BR>(SWI &amp;492C2)</H4>

<P>Close MPEG stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>Blank the MPEG video plane when the
                                      stream has closed
                      <TR><TD colspan="2">Other bits are reserved and must be
                                      zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1&nbsp;= <TD>control stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is used to close the stream at any point after opening it, either
at the end of the movie, or if the stream has been aborted in the middle.

<P>If the stream is still in the prefilling stage, then it starts the video
and/or audio units playing, using MPEGVideo/Audio_Play.

<P>It then calls MPEGVideo_CloseStream and/or MPEGAudio_CloseStream
and issues the CloseStream reason code to any program element handler which is
active on that stream, and then frees any resources associated with the stream.

<P>Normally this call will not return until all data sent has been played,
unless the stream is paused.

<H4 align="right">MPEGControl_Play
<BR>(SWI &amp;492C3)</H4>

<P>Control playback

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>Video unit has completed prefilling and
                                      is ready to play
                      <TR><TD>1   <TD>Audio unit has completed prefilling and
                                      is ready to play
                      <TR><TD>2   <TD>Bitstream transport unit has reason to
                                      believe that the end of the stream is
                                      imminent (eg because it has reached the
                                      end of a file) so the next time all
                                      decode units become idle it will be an
                                      end-of-stream rather than a timeout
                      <TR><TD>3   <TD>Video unit has become idle
                      <TR><TD>4   <TD>Audio unit has become idle
                      <TR><TD colspan="2">Other bits are reserved and must be
                                      zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1&nbsp;= <TD>control stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>The MPEGControl_Play call is intended only for internal communications
received from the video, audio and bitstream transport units.

<P>When a stream is opened, initially both video and audio decoders are in
pause mode, waiting for sufficient data to arrive for them to start playing.
This is known as the prefilling stage. In order that both video and audio start
simultaneously, the video and audio units call MPEGControl_Play when they have
sufficient data to start decoding, with the appropriate bit set in the flags.

<P>Once all parties necessary to play the stream are ready, the control unit
issues MPEGVideo_Play and/or MPEGAudio_Play SWIs to start the modules playing.

<P>Periodically during playback, the control unit checks to see whether there
are any bitstream buffers in use, and if not, whether any data have been
received since the last time it checked. If no data have been received, it then
checks whether the video and/or audio units (as appropriate to the stream) are
idle, by calling MPEGVideo/Audio_Play with flag bit 1 set. The period of
checking is scaled according to any slow-motion mode that is selected; checking
is disabled in pause mode. The video and/or audio units indicate that they are
idle by calling MPEGControl_Play with flag bits 3 or 4 set. When all units are
confirmed as idle, the control unit issues UpCall_MPEG &amp;0002.

<P>Similarly, at the end of a stream, the control unit uses the same
MPEGVideo/Audio_Play SWIs to detect when all units have become idle and issues
an UpCall when they have, in this case UpCall_MPEG &amp;0000; the mechanism
differs from that used for timeout detection in that the video/audio units are
interrogated as soon as the the control unit is aware of a pending
end-of-stream, rather than waiting for a time to elapse in which no more
bitstream buffers are processed. The control unit determines that an
end-of-stream is pending via two mechanisms:

<UL>
<LI>by notification from the bitstream transport unit, via SWI MPEGControl_Play
    with flag bit 2 set; or
<LI>by parsing an iso_11172_end_code (known as MPEG_program_end_code for
    program streams) of &amp;000001B9 from a system/program stream, or
    a Stream Mode program descriptor in the TS_program_map_section with a
    Stream Mode value of 7 (End of Stream) from a transport stream. Note that
    the latter will only be parsed if flag bit 10 of the stream flags passed to
    MPEGControl_OpenStream was set.
</UL>

<H4 align="right">MPEGControl_SetSpeed
<BR>(SWI &amp;492C4)</H4>

<P>Set speed of playback

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>if moving to a faster speed, defer the
                                      effect until the audio buffer rises to or
                                      above the audio buffer high water mark;
                                      if moving to a slower speed, defer the
                                      effect until the audio buffer falls to or
                                      below the audio buffer low water mark
                                      <I>(STB-400 only)</I>
                      <TR><TD colspan="2">Other bits are reserved and must be
                                      zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>control stream handle
<TR><TD>R2&nbsp;= <TD>speed indicator:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Value            <TH>Effect
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0                <TD>paused
                      <TR><TD>1                <TD>normal speed
                      <TR><TD>2 - 16 (2&nbsp;-&nbsp;8&nbsp;on&nbsp;STB-3)
                                               <TD>slow motion, speed 1/R2
                      </TBODY>
                      </TABLE>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is used to set the speed of playback of the movie. It calls
MPEGVideo_SetSpeed and/or MPEGAudio_SetSpeed. Note that the flags are passed
through to the video and audio units, and since flag bit 0 is only implemented
in MPEGDriver not MPEG2Video, its functionality is not available on STB-3.
Slow motion is achieved by displaying each coded video frame for the number of
frames indicated in R2; audio is muted in slow motion. STB-400 supports a
wider range of slow-motion speeds than STB-3.

<P>Note that if a Good Data Follows is expected soon (ie
MPEGControl_ResetStream has been called with reset-stream flag bit 4 set) then
the calls to MPEGVideo_SetSpeed and/or MPEGAudio_SetSpeed are deferred until
after the Good Data Follows has been received and the video and audio units
have been reset. This only applies to transport streams at present.

<H4 align="right">MPEGControl_ResetStream
<BR>(SWI &amp;492C5)</H4>

<P>Discard pre-buffered data and prepare to accept new stream data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reset-stream flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>Video data is present in the new MPEG
                                      stream
                      <TR><TD>1   <TD>Audio data is present in the new MPEG
                                      stream
                      <TR><TD>2   <TD>Discard data until we get data of the
                                      trick mode specified by R2 (MPEG-2
                                      PES, program and transport streams only -
                                      for MPEG-1 packets, data will be
                                      discarded until the next ResetStream)
                      <TR><TD>3   <TD>New MPEG stream is a trick play stream,
                                      ie it consists of only I-frames presented
                                      in an order consistent with the direction
                                      of play, and usually at a lower frame
                                      rate than the intended display standard.
                      <TR><TD>4   <TD>Don't actually perform a reset yet;
                                      simply cache the settings of the other
                                      flags for use at the next
                                      internally-generated reset (usually at a
                                      Good Data Follows that we anticipate
                                      receiving in the near future)
                      <TR><TD colspan="2">Other bits are reserved and must be
                                      zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>control stream handle
<TR><TD>R2 =      <TD>trick mode of required data (if bit 2 of R0 set):
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Value <TH>Mode
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0     <TD>fast forward
                      <TR><TD>1     <TD>slow motion
                      <TR><TD>2     <TD>freeze frame
                      <TR><TD>3     <TD>fast reverse
                      <TR><TD>4     <TD>slow reverse
                      <TR><TD>-1    <TD>normal play
                      </TBODY>
                      </TABLE>
                      Note that these values correspond to the values of the
                      trick_mode_control field in the PES packet header, except
                      for -1 which corresponds to DSM_trick_mode_flag = 0, and
                      hence no trick_mode_control field.
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =      <TD>Estimate of the amount of discarded video data in bytes
                      (if video stream open, else zero)
<TR><TD>R3&nbsp;= <TD>Estimate of the amount of discarded audio data in bytes
                      (if audio stream open, else zero)
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is primarily intended for use when switching between a
normal-speed stream and a fast-forward/rewind stream, but can also be useful
in other situations, for example to ensure a clean join when looping a clip. It
makes calls to MPEGVideo_ResetStream and MPEGAudio_ResetStream where
appropriate, in order to flush the elementary decoders of any data which is
buffered up, whether in the decoding hardware's private RAM, or in buffers
passed to the video and audio units but not yet delivered to the hardware. By
doing this, we avoid any possibility of misinterpretation of the new stream as
part of an access unit of the old stream, and also avoid any frame prediction
and frame reordering problems that might otherwise occur at the transition.

<P>After discarding the data, the modules will effectively be in the same state
as after an OpenStream call, i.e. with the decoders in pause mode, waiting for
sufficient data to issue a MPEGControl_Play SWI.

<P>Reset-stream flag bit 3 is used to disable Segment Transition detection in
trick-play transport streams (when NPT Reference descriptors are sent on a
regular basis) - note that Segment Transition detection is conditional upon
stream flags bit 10 is set, and currently only works for transport streams.
Bit 3 is also passed to the MPEG2Video or MPEGDriver module as appropriate; in
the former, it is used to determine whether to apply underrun and/or
packet-length fixes (subject to bits 17 and 18 of the video parameters
structure flags). In the latter, the equivalent of the underrun fix is
conditional only upon ResetStream flag bit 3, and it also activates both an
alternative algorithm for calculating video prefill levels, and the display of
only one field of each frame if the frames are coded as interlaced. In both
modules, this flag is used to suppress the extraction of closed captioning data.

<P>Because a fast stream typically has no audio data, this SWI has flags
indicating the presence of video and audio data in the new stream, so that when
switching to fast-forward for example, the control unit knows it only needs to
wait for the video unit to be ready before issuing the MPEGVideo_Play SWI,
whereas when switching back to normal play, it must wait for both video and
audio units to be ready before starting them both together.

<P>When data is delivered in a server-push manner, there are typically
round-trip and buffering issues that mean that the precise time when data from
the new stream starts arriving can only be determined by parsing an indicator
from the bitstream itself. We currently recognise two mechanisms for signalling
the change of stream:

<UL>
<LI>Good Data Follows, signalled by a change of the contentId field of the
    NPT Reference program descriptor in the TS_program_map_section. This is
    only relevant to transport streams, and is only parsed if stream flags bit
    10 is set. When stream flags bit 10 is set and MPEGControl_ResetStream is
    called with reset-stream flags bit 4 clear, the control unit will simply
    discard all data until it parses a Good Data Follows. However, if stream
    flags bits 10 and 11 are both set, then the stream is automatically reset
    whenever a Good Data Follows is parsed; if we want the reset-stream flags
    to be different after the automatic reset (for example, if we're going into
    a trick play stream) then MPEGControl_ResetStream should still be called,
    but with reset-stream flag bit 4 set, which will merely cache the flags for
    use in subsequent automatic resets. The advantage of this latter approach
    is that the period of time in which decoding is inactive is minimised.
<LI>a change in the value or presence of the trick_mode_control field in the
    MPEG-2 PES packet header of either video or audio. Because this field
    cannot be present in MPEG-1 packets, this mechanism is restricted to MPEG-2
    PES, program and transport streams. To get the control unit to discard data
    until a particular trick_mode_control field is received (or until a PES
    packet header is received without one, in the case of switching back to a
    normal stream), call MPEGControl_ResetStream with reset-stream flag bit 2
    set and an appropriate value in R2. Note that no automatic reset option is
    available for this method of stream change signalling.
</UL>


<H4 align="right">MPEGControl_MuteSound
<BR>(SWI &amp;492C6)</H4>

<P>Mute/unmute sound

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <TBODY align="left" valign="top">
                      <TR><TD>bit 0 set   <TD>sound off
                      <TR><TD>bit 0 clear <TD>sound on
                      <TR><TD colspan="2">Other bits are reserved and should be
                              set to zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1&nbsp;= <TD>control stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is used to mute or unmute the sound while a movie is playing.
Note that the sound may still be off after an unmute call due to other reasons,
eg playing in fast-forward. If the stream is open for audio, then
MPEGAudio_MuteSound is called. If the stream is not open for audio,
MPEGControl_MuteSound has no effect.

<H4 align="right">MPEGControl_SoundVolume
<BR>(SWI &amp;492C7)</H4>

<P>Set sound volume

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =                  <TD colspan="2">flags (should be zero)
<TR><TD>R1 =                  <TD colspan="2">control stream handle
<TR><TD rowspan="2">R2&nbsp;= <TD>0 to 256 =&gt; <TD>set volume (logarithmic
                                                     scale)
<TR>                          <TD>-1 =&gt;       <TD>read volume
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R2 = old volume

<H5>Use</H5>

<P>This call is used to set the sound volume. It in turn calls
MPEGAudio_SoundVolume. Note that this call has no effect on STB-3.

<P>The volume control interface is logarithmic in its basis. The volume is
specified in units of 0.5 dB; a value of 256 corresponds to a nominal 0 dB
volume setting ("normal full volume"), so a value of 254 corresponds to 1 dB
softer than full volume and so on. In practice, hardware gain is only
adjustable in steps of 2 dB, so the software maps the requested volume setting
onto the nearest available hardware setting.

<P>The volume setting 0 is special, in that it means not -128 dB but "off" or
"muted".

<H4 align="right">MPEGControl_SelectProgram
<BR>(SWI &amp;492C8)</H4>

<P>Select/deselect program and video/audio channel

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit <TH>Meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>R3 = index of video stream to select
                      <TR><TD>1   <TD>R4 = index of audio stream to select
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>control stream handle
<TR><TD>R2 =      <TD>program selector:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH><TH>Value     <TH>Meaning
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD rowspan="2"><I>for transport streams</I>
                              <TD>R2&nbsp;&gt;=&nbsp;0 <TD>R2 is interpreted as
                                            the value of the program_number
                                            field in the program association
                                            table;
                      <TR>    <TD>R2 &lt; 0 <TD>-R2 is the index in the program
                                            association table of the program to
                                            select (eg -1 selects the first
                                            program, -2 selects the second
                                            program, and so on)
                      <TR><TD rowspan="2"><I>for other stream types</I>
                              <TD>R2 = 0    <TD>Disable stream processing
                      <TR>    <TD>otherwise <TD>Enable stream processing
                      </TBODY>
                      </TABLE>
<TR><TD>R3 =      <TD>index of video stream to select, if bit 0 of R0 is set (1
                      selects the first video stream in this program, 2 selects
                      the second video stream and so on) <I>- currently ignored
                      for streams other than transport streams</I>
<TR><TD>R4&nbsp;= <TD>index of audio stream to select, if bit 1 of R0 is set (1
                      selects the first audio stream, 2 the second, and so on)
                      <I>- currently ignored for streams other than transport
                      streams</I>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved.

<H5>Use</H5>

<P>This call is used to select a particular program to decode from a
multi-program transport stream. The program can either be specified by giving
a value to match against the program_number field which is present for each
program in the program_association_section in the PAT, or simply by giving the
index into the list of programs in the program_association_section in the PAT.

<P>There is no equivalent for other stream types, because transport streams are
the only streams that can contain multiple programs; however, we have defined a
program number of 0 for non-transport streams to mean "disable stream
processing".

<P>This call also optionally selects a particular video and/or audio stream
within the program (eg in the case where a particular program has multiple
audio streams with dialogue in different languages). This works for transport
streams. For system streams, there is no defined logical order to any extra
video or audio channels in the stream; only those with stream_ids of &amp;E0
(video) and/or &amp;C0 (audio) are supported, and the video/audio stream
indexes are ignored. Program streams are currently treated in the same manner
as system streams, but in future the Program Stream Map may be parsed, allowing
indexed video and audio streams to be selected.

<H4 align="right">MPEGControl_Stats
<BR>(SWI &amp;492C9)</H4>

<P>Return values relating to the operation of the decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags (should be zero)
<TR><TD>R1 =      <TD>control stream handle, or zero to read stream-independent
                      values
<TR><TD>R2 =      <TD>pointer to list of statistic tags, terminated by -1
<TR><TD>R3 =      <TD>pointer to word-aligned buffer to store results to
<TR><TD>R4&nbsp;= <TD>size of buffer (in bytes)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R3 =      <TD>pointer to byte after last byte put into buffer
<TR><TD>R4&nbsp;= <TD>value of R4 on entry minus the total size of the
                      requested entries, whether or not they were put into the
                      buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This SWI is used to extract statistics from the control, video and/or audio
units. The set of statistics to extract is determined by the list of statistic
tags passed in. Each unit has its own disjoint range of statistic tag numbers.

<P>Statistics may be obtained for a given stream (determined by the control
stream handle), or may be stream-independent (eg for statistics which appertain
to the last stream played, or are cumulative over all streams played so far),
in which case a handle of zero should be passed in.

<P>The format of the data stored into the buffer is as follows:-

<TABLE cellspacing="2">
<THEAD align="left" valign="top">
<TR><TH>Offset <TH>Value
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>First statistic tag
<TR><TD>4      <TD>N = Length of statistic data (in bytes)
<TR><TD>8      <TD>Statistic data
<TR><TD colspan="2">...
<TR><TD>N+8    <TD>Second statistic tag
<TR><TD colspan="2">...
</TBODY>
</TABLE>

<P>Unknown statistic tags are ignored - no data is entered into the buffer for
them.

<P>If the buffer is not big enough to accommodate the whole of a particular
item, then no further items will be put in the buffer, but r4 will continue to
be decremented by the size of each item, and an error 'Buffer overflow' will be
returned. Thus if the call returns with r4 negative, then -r4 is the amount
you need to extend the buffer by in order to fit all the data.

<P>Consequently, you can make the call with r3=0 and r4=0, and on exit -r4 will
be the amount of buffer space required for a subsequent call which actually
puts the data in the buffer. Note you will still get the 'Buffer overflow'
error returned from the first call.

<P>Initially the units are allocated the following tag ranges:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>Control: <TD>&amp;0000-&amp;0FFF
<TR><TD>Video:   <TD>&amp;1000-&amp;1FFF
<TR><TD>Audio:   <TD>&amp;2000-&amp;2FFF
</TBODY>
</TABLE>

<P>When the call is made, the control unit first scans the tag list for any
statistics for itself, then calls MPEGVideo_Stats and MPEGAudio_Stats, with the
control stream handle substituted by the video/audio stream handle, or zero if
zero was originally specified.

<P>Tag values currently recognised are:

<TABLE cellspacing="2">
<THEAD align="left" valign="top">
<TR><TH>Tag       <TH>Value (all of length 4 bytes except where indicated)
</THEAD>
<TBODY align="left" valign="top">
<TR><TD colspan="2">Control unit:
<TR><TD>&amp;0000 <TD>Number of bytes received by control unit
<TR><TD>&amp;0001 <TD>Time in cs from when the stream was opened to the time
                      the last byte was received
<TR><TD>&amp;0003 <TD>PMT PID for the current program (or -1 if not a transport
                      stream)
<TR><TD>&amp;0004 <TD>Video PID for the current program (or -1 if not a
                      transport stream)
<TR><TD>&amp;0005 <TD>Audio PID for the current program (or -1 if not a
                      transport stream)
<TR><TD>&amp;0006 <TD>Number of bytes returned to bitstream transport unit
<TR><TD>&amp;0007 <TD>1 if the control unit is still discarding data after an
                      MPEGControl_ResetStream call, looking for the correct
                      trick_mode_control field; otherwise 0
<TR><TD>&amp;0008 <TD>Number of bytes of transport stream data that were
                      discarded, due to them being padding packets, or other
                      data not being used to decode the current program.
<TR><TD>&amp;0009 <TD>NPT Reference descriptor information for the current
                      program <I>(typically 24 bytes)</I>:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bytes <TH>Meaning
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>4     <TD>Flags:
                                        <TABLE cellspacing="2">
                                        <THEAD align="left" valign="top">
                                        <TR><TH>Bit <TH>Meaning when set
                                        </THEAD>
                                        <TBODY align="left" valign="top">
                                        <TR><TD>0   <TD>NPT Reference descriptor
                                                        has been seen since the
                                                        last OpenStream or
                                                        ResetStream
                                        <TR><TD colspan="2">Other bits reserved
                                        </TBODY>
                                        </TABLE>
                                        
                      <TR><TD>N     <TD>The most recent NPT Reference
                                        descriptor, minus the descriptorTag and
                                        descriptorLength fields (see ISO/IEC
                                        13818-6). This field will not be
                                        present if no NPT Reference descriptors
                                        have been received since the stream was
                                        opened
                      <TR><TD>0-3   <TD>Padding to word boundary (contents
                                        undefined)
                      </TBODY>
                      </TABLE>
<TR><TD>&amp;000B <TD>Overall bitrate of the stream, or 0 if not known or not
                      yet determined. For system streams and program streams,
                      this is read from the pack header; for transport streams,
                      it is estimated, based upon the separation of PCRs.
                      Value is measured in bits per second
<TR><TD>&amp;000C <TD>Pointer to the direct-call interface to replace SWI
                      MPEGControl_FullBuffers. This is in the form of an
                      APCS-compliant function, taking the following arguments:
                      <BR>&nbsp;&nbsp;&nbsp;&nbsp;r0 = flags (as for SWI
                      MPEGControl_FullBuffers)
                      <BR>&nbsp;&nbsp;&nbsp;&nbsp;r1 -> one or more linked
                      bitstream buffers
                      <BR>and thus takes a prototype of
                      <BR>&nbsp;&nbsp;&nbsp;&nbsp;<CODE>void (*full_buffers)
                      (unsigned int flags, bs_buf *buffers)</CODE>
</TBODY>
<TBODY align="left" valign="top">
<TR><TD colspan="2">Video unit:
<TR><TD>&amp;1000 <TD>Number of video channel underruns encountered
<TR><TD>&amp;1001 <TD>Number of bytes of video data received from control unit
<TR><TD>&amp;100B <TD>Number of bytes of video packet data which has been
                      received but has yet to be passed to the MPEG chip's
                      private RAM
<TR><TD>&amp;100D <TD>Number of video reconstruction errors, since last
                      OpenStream or ResetStream <I>(STB-3 only)</I>
<TR><TD>&amp;100E <TD>Number of context errors, since last OpenStream or
                      ResetStream <I>(STB-3 only)</I>
<TR><TD>&amp;100F <TD>Number of variable length code or run length errors,
                      since last OpenStream or ResetStream <I>(STB-3 only)</I>
<TR><TD>&amp;1010 <TD>Time in cs from the last OpenStream or ResetStream to the
                      first subsequent video reconstruction error, or -1 if
                      none <I>(STB-3 only)</I>
<TR><TD>&amp;1011 <TD>Information about the active area of the video <I>(28
                      bytes, STB-400 only)</I>:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Offset <TH>Meaning
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>+0     <TD>width in coded samples (ie before
                                         scaling)
                      <TR><TD>+4     <TD>height in coded samples (ie before
                                         scaling)
                      <TR><TD>+8     <TD>overall aspect ratio (a fixed-point
                                         number: bits 16-31 are the integer
                                         part, bits 0-15 are the fractional
                                         part)
                      <TR><TD>+12    <TD>centre x-coordinate (a signed number,
                                         in OS units)
                      <TR><TD>+16    <TD>centre y-coordinate (a signed number,
                                         in OS units)
                      <TR><TD>+20    <TD>width (in OS units, after scaling)
                      <TR><TD>+24    <TD>height (in OS units, after scaling)
                      </TBODY>
                      </TABLE>
</TBODY>
<TBODY align="left" valign="top">
<TR><TD colspan="2">Audio unit:
<TR><TD colspan="2">No tags supported at present
</TBODY>
</TABLE>

<P>Other tag values are for future specification.

<H4 align="right">MPEGControl_RegisterProgramElementHandler
<BR>(SWI &amp;492CA)</H4>

<P>Register program element handler with MPEGControl module

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Bit(s) <TH>Interpretation / meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0      <TD>reserved - should be set to zero
                      <TR><TD>1      <TD>PES packet headers should be treated
                                     as payload
                      <TR><TD>2      <TD>reserved - should be set to zero
                      <TR><TD>3      <TD>R1 is an absolute PID value, not a
                                     stream_type value
                      <TR><TD>4-8    <TD>a five-bit value: when zero, the
                                     PEH reason code 1 handler should be called
                                     whenever the appropriate stream identifier
                                     is matched; otherwise (value-1) is the
                                     number of the bit which must be set in
                                     both the stream flags and the reset-stream
                                     flags before the hander will be called.
                                     Note that this currently only works for
                                     stream/reset-stream flags bits 0 and 1,
                                     but this may change in future.
                      <TR><TD colspan="2">Other bits reserved (should be set to
                                          zero)
                      </TBODY>
                      </TABLE>
<TR><TD>R1 =      <TD>stream identifier:
                      <BR>if bit 3 of R0 is set then this is an absolute PID
                      value;
                      <BR>if bit 3 of R0 is clear then this is a stream_type
                      value;
<TR><TD>R2 =      <TD>entry address for handler
<TR><TD>R3&nbsp;= <TD>workspace pointer for handler
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call registers a program element handler with the MPEGControl module.
If a handler module wishes to handle multiple stream types (eg both MPEG-1 and
MPEG-2 video) or multiple PID values it should issue this SWI multiple times.
The calling conditions for the handler are defined below.

<P>This SWI should be issued when the handler module initialises, and also
whenever Service_MPEGControlStarting (service call &amp;C7) is received.

<H4 align="right">MPEGControl_DeregisterProgramElementHandler
<BR>(SWI &amp;492CB)</H4>

<P>Deregister a program element handler

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>flags (as passed to
                      MPEGControl_RegisterProgramElementHandler)
<TR><TD>R1 =      <TD>stream identifier (ditto)
<TR><TD>R2 =      <TD>entry address for handler (ditto)
<TR><TD>R3&nbsp;= <TD>workspace pointer for handler (ditto)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call removes the specified program element handler from the
MPEGControl module's list of handlers. If a stream is open which is linked to
the handler then an error will be returned instead.

<P>This SWI should be issued when a handler module is being killed.

<H4 align="right">MPEGControl_SetAudioParameters
<BR>(SWI &amp;492CC)</H4>

<P>Reads and writes various audio parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>reason code
<TR><TD>R1&nbsp;= <TD>control stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

The following reason codes are currently defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write mute-on-bit-errors state
<TR><TD>1 <TD>Read/write dual channel mode specifier
</TBODY>
</TABLE>

<H4 align="right">MPEGControl_SetAudioParameters 0
<BR>(SWI &amp;492CC)</H4>

<P>Reads and writes mute-on-bit-errors state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">control stream handle
<TR><TD rowspan="2">R2 = <TD>0 or 1 =&gt; <TD>set mute-on-bit-errors state
<TR>                     <TD>-1 =&gt;     <TD>read mute-on-bit-errors state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = <TD>old mute-on-bit-errors state
<TR><TD colspan="2">other registers preserved
</TBODY>
</TABLE>

<P>The mute-on-errors state can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 =&gt; <TD>don't mute audio on bit errors
<TR><TD>1 =&gt; <TD>mute audio on bit errors
</TBODY>
</TABLE>

<H4 align="right">MPEGControl_SetAudioParameters 1
<BR>(SWI &amp;492CC)</H4>

<P>Reads and writes dual channel mode specifier

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (1)
<TR><TD>R1 =             <TD colspan="2">control stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 2 =&gt; <TD>set dual channel mode specifier
<TR>                     <TD>-1 =&gt;     <TD>read dual channel mode specifier
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = <TD>old dual channel mode specifier
<TR><TD>R3 = <TD>current channel type (according to hardware)
<TR><TD colspan="2">other registers preserved
</TBODY>
</TABLE>

<P>The dual channel mode specifier can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 =&gt; <TD>play both channels
<TR><TD>1 =&gt; <TD>play left channel only
<TR><TD>2 =&gt; <TD>play right channel only
</TBODY>
</TABLE>

<P>The current channel type can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 =&gt; <TD>stereo
<TR><TD>1 =&gt; <TD>joint stereo
<TR><TD>2 =&gt; <TD>dual mono
<TR><TD>3 =&gt; <TD>mono
<TR><TD>-1 =&gt; <TD>unknown
</TBODY>
</TABLE>


<H4 align="right">MPEGControl_ControlOp<BR>(SWI &492CD)</H4>

<P>Miscellaneous commands governing the behaviour of the MPEGControl module

<H5>On entry</H5>

<P>R0 = reason code
<BR>other registers depend upon the reason code

<P>The following reason codes are currently defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD width="20">0  <TD>Set stream demux / autodetect algorithm
<TR><TD>1             <TD>Read stream demux / autodetect algorithm
<TR><TD>2             <TD>Register stream demux module <I>(obsolete, not
                          implemented)</I>
<TR><TD>3             <TD>Deregister stream demux module <I>(obsolete, not
                          implemented)</I>
</TBODY>
</TABLE>

<H4 align="right">MPEGControl_ControlOp 0<BR>(SWI &492CD)</H4>

<P>Set stream demux / autodetect algorithm

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 = <TD>0 (reason code)
<TR><TD>R1 = <TD>new stream demux flags
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>previous stream demux flags
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This SWI sets the demultiplexing and autodetection options to be used for
all streams that are subsequently opened; at the time of a call to
MPEGControl_OpenStream, the stream demux flags are copied internally and used
for the lifetime of that stream.

<P>The stream demux flags determine which type of demultiplexing code can be
used to demultiplex the stream. Where more than one type of demultiplexing is
enabled, the control unit will attempt to autodetect which type of stream it is
demultiplexing. The flags have the following meanings; unfortunately they are a
little cryptic, in order to preserve backwards compatibility:

<TABLE cellspacing="2">
<THEAD align="left" valign="top">
<TR><TH>Bit    <TH>Types of stream for which to enable detection/demultiplexing
                   when bit is set
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>MPEG-2 transport streams
<TR><TD>1      <TD>MPEG-2 program streams with program stream maps
                   <I>(not currently supported)</I>
<TR><TD>2      <TD>MPEG-2 transport streams XNOR PES-based streams (ie MPEG-1
                   packet streams, MPEG-1 system streams, MPEG-2 PES streams
                   and MPEG-2 program streams without program stream maps)
<TR><TD>3      <TD>MPEG-2 transport streams XNOR elementary streams
<TR><TD>others <TD>Reserved for other stream types, set bits if you want
                   automatic parsing of future standards, or clear bits if
                   you want to be restricted to current stream types
</TBODY>
</TABLE>

<P>So for example, to force a stream to be demultiplexed as a system/program
stream (not even as an elementary stream), use a flag value of 8 (bit 0 = 0,
bit 1 = 0, bit 2 = 0 XNOR 1 = 0, bit 3 = 0 XNOR 0 = 1), or for full
autodetection freedom, use a flag value of &amp;FFFFFFFF.

<P>The stream demux flags default to &amp;FFFFFFFF.


<H4 align="right">MPEGControl_ControlOp 1<BR>(SWI &492CD)</H4>

<P>Read stream demux / autodetect algorithm

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 = <TD>1 (reason code)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>current stream demux flags (see MPEGControl_ControlOp 0)
</TBODY>
</TABLE>


<H4 align="right">MPEGControl_SetVideoParameters
<BR>(SWI &amp;492CE)</H4>

<P>Reads and writes various video parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD>R1 = <TD>control stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined <I>for STB-400 only</I>:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write video scaling type
<TR><TD>1 <TD>Read/write line 23 widescreen signalling state
<TR><TD>2 <TD>Read/write SCART pin 8 widescreen signalling state
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>

<H4 align="right">MPEGControl_SetVideoParameters 0
<BR>(SWI &amp;492CE)</H4>

<P>Read/write video scaling type <I>(STB-400 only)</I>

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">control stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 3 <TD>=&gt; set video scaling type
<TR>                     <TD>-1     <TD>=&gt; read video scaling type
<TR><TD>R3-R6&nbsp;=     <TD colspan="2">video scaling type parameters
                         <BR>(undefined if R2 = -1)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old video scaling type
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         <!-- weird Fresco formatting bug requires the above -->
<TR><TD>R3-R6&nbsp;= <TD colspan="2">old video scaling type parameters
</TBODY>
</TABLE>

<H5>Use</H5>

<P>The video scaling type parameters are identical to offsets +40 - +52 of the
video parameters structure.

<H4 align="right">MPEGControl_SetVideoParameters 1
<BR>(SWI &amp;492CE)</H4>

<P>Read/write line 23 widescreen signalling state <I>(STB-400 only)</I>

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (1)
<TR><TD rowspan="2">R2 = <TD>0 to 8 <TD>=&gt; set WSS state
<TR>                     <TD>-1     <TD>=&gt; read WSS state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old WSS state
<TR><TD>R3 =         <TD>overriding WSS state set appropriate to this clip, or
                         -1 if WSS state isn't being overridden
</TBODY>
</TABLE>

<H5>Use</H5>

<P>Line 23 widescreen signalling is applicable to PAL (and SECAM) TV signals,
and is most commonly used to switch 16:9 (widescreen) TVs between the various
picture scaling modes that are available. The signal is generated using the
STi3520L's on-screen display, so the relevant part of the graphics plane must
be transparent for it to function.

<P>When using ScalingType 0, the WSS state can optionally be overridden
automatically according to the type of clip being played. In this case, R3 will
return a value other than -1.

<P>The WSS states passed in R2 have the following meanings:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>State <TH>Line 23 signal present? <TH>Protected area (used as aspect ratio label) <TH>Format      <TH>Position <TH>Active lines <TH>Notes / typical appearance on a widescreen TV
</THEAD>
<TBODY align="left" valign="top">
<TR>                 <TD>0     <TD>no                      <TD>-                                           <TD>-           <TD>-        <TD>-            <TD>control of widescreen state is not asserted
<TR>                 <TD>1     <TD>yes                     <TD>4:3                                         <TD>full format <TD>-        <TD>576          <TD>the 4:3 picture is centred and pillarboxed
<TR>                 <TD>2     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>centre   <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>3     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>top      <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>4     <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>centre   <TD>430          <TD>the 16:9 picture is displayed using the whole of the TV screen
<TR>                 <TD>5     <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>top      <TD>430          <TD>the 16:9 picture is displayed using the whole of the TV screen
<TR>                 <TD>6     <TD>yes                     <TD>&gt; 16:9                                   <TD>letterbox   <TD>centre   <TD>&lt; 430     <TD>the picture is centred and letterboxed, and uses the full width of the TV screen
<TR>                 <TD>7     <TD>yes                     <TD>14:9                                        <TD>full format <TD>centre   <TD>576          <TD>this is 4:3 with 14:9 shoot-and-protect, and is treated the same as other 14:9 formats by a 16:9 TV
<TR>                 <TD>8     <TD>yes                     <TD>16:9                                        <TD>full-format <TD>-        <TD>576          <TD>this is 16:9 anamorphic mode, and is stretched horizontally to fill the TV screen
</TBODY>
</TABLE>

<H4 align="right">MPEGControl_SetVideoParameters 2
<BR>(SWI &amp;492CE)</H4>

<P>Read/write SCART pin 8 widescreen signalling state <I>(STB-400 only)</I>

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (2)
<TR><TD rowspan="3">R2 = <TD>0  <TD>=&gt; set non-anamorphic mode (ie use high
                                    voltage on SCART pin 8 when TV AV input is
                                    asserted)
<TR>                     <TD>1  <TD>=&gt; set anamorphic mode (ie use
                                    intermediate voltage on SCART pin 8 when TV
                                    AV input is asserted)
<TR>                     <TD>-1 <TD>=&gt; read mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old mode
<TR><TD>R3 =         <TD>overriding mode set appropriate to this clip, or -1 if
                         SCART pin 8 state isn't being overridden
</TBODY>
</TABLE>

<H5>Use</H5>

<P>The intermediate voltage on SCART pin 8 is used to signal to 16:9 TVs (and
some 4:3 TVs) that the images it is receiving have been anamorphically
squeezed, and that the TV should re-size the image in order to display them at
the correct aspect ratio. For 16:9 sets, this means stretching the image to
fill the whole width of the screen; for 4:3 sets, it means collapsing the image
vertically, and adding black bars top and bottom.

<P>When using ScalingType 0, the SCART pin 8 mode can optionally be overridden
automatically according to the type of clip being played. In this case, R3 will
return a value other than -1.

<H4 align="right">MPEGControl_GetSprite
<BR>(SWI &amp;492CF)</H4>

<P>Capture an MPEG video frame as a sprite <I>(STB-400 only)</I>

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>control stream handle, or 0 to capture from the most recently
                 opened stream
<TR><TD>R2 = <TD>pointer to control block of sprite area to create the sprite
                 in, or 0 to use the system sprite area
<TR><TD>R3 = <TD>pointer to the sprite name to use when creating the sprite
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>It is used in situations when the caller wishes to acquire the currently
displaying frame (or field, in the case of non-progressive video) as a sprite.
The sprite created is 32bpp RGB; the largest image supported by STB-400 is 1620
macroblocks, or 414720 pixels, so the caller should ensure that there is at
least enough room for a sprite image of 1658880 bytes as well as the sprite
control block. In particular, you should not calculate the size requirement
using stat &amp;1011, because although the final sprite will have been trimmed
down to match the active area, the SWI converts the entire coded frame to a
sprite in the course of its calculations, and needs enough room to hold it all
in the sprite area.

<P>Note that this SWI can take of the order of one second to complete on
STB-400; this means that sprite contents are undefined if the video stream is
not paused or stopped in some other way.

<H3>5.2. * Commands</H3>

<H4 align="right">*CtrlInfo</H4>

<P>List information

<H5>Syntax</H5>

<P><CODE>*CtrlInfo</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>Lists the following information about the most recently opened MPEG stream:
<UL>
  <LI>the stream type, one of: undetermined stream type; unrecognised stream
      type; elementary video stream; elementary audio stream; MPEG-1 packet
      stream; MPEG-1 system stream; MPEG-2 PES stream; MPEG-2 program stream;
      MPEG-2 program stream with program stream map; or MPEG-2 transport stream
  <LI>the PID of the current program's Program Map Table, or -1 if it hasn't
      been found yet - equivalent to statistics tag &amp;0003 <I>(transport
      streams only)</I>
  <LI>the PID of the current program's elementary video stream, or -1 if it
      hasn't been found yet - equivalent to statistics tag &amp;0004
      <I>(transport streams only)</I>
  <LI>the PID of the current program's elementary audio stream, or -1 if it
      hasn't been found yet - equivalent to statistics tag &amp;0005
      <I>(transport streams only)</I>
  <LI>the time offset (in cs) from the time when the stream was opened until
      the time when the latest bitstream buffer was delivered for decoding -
      equivalent to statistics tag &amp;0001
  <LI>the number of bitstream buffer bytes received since the stream was opened
      - equivalent to statistics tag &amp;0000
  <LI>the total bytecount of all the bitstream buffers that have been freed
      since the stream was opened - equivalent to statistics tag &amp;0006
  <LI>the total number of start-code sync losses since the stream was opened -
      ie the number of times a start code was expected but not found
      <I>(not transport streams or elementary streams)</I>
  <LI>the number of short packets encountered since the stream was opened -
      ie the number of times that the packet header length exceeded the packet
      length <I>(not transport streams or elementary streams)</I>
  <LI>the number of bitstream buffers currently in use
  <LI>the average (received) data rate since the stream started playing
  <LI>the data rate determined from the stream - equivalent to statistics tag
      &amp;000B <I>(not elementary streams)</I>
  <LI>the most-recently used reset-stream flags
  <LI>the contentId field of the most recently found NPT Reference descriptor,
      or -1 if it hasn't been found yet
      <I>(transport streams only)</I>
  <LI>a list of all registered program element handlers, giving stream
      identifier, flags, entry point and workspace pointer
      <I>(transport streams only)</I>
  <LI>a list of the active instantiations of program element handlers for the
      current MPEG stream <I>(transport streams only)</I>. Information listed
      is:
      <UL>
        <LI>the program element handler, identified by its stream identifier,
            flags, entry point and workspace pointer
        <LI>a flag word unique to the instantiation <I>(currently unused)</I>
        <LI>the program element stream handle
        <LI>the PID <I>(either the registered PID or the PID for the registered
            stream_type in the current program - or -1 if a PID of the
            registered stream_type hasn't been identified since the last
            OpenStream or ResetStream)</I>
        <LI>the estimated number of discontinuities in the PID - actually the
            number of times the continuity_counter in the transport stream
            headers for this PID didn't hold the expected value
      </UL>
</UL>

<H4 align="right">*CtrlDebugOn</H4>

<P>Turns on debugging output

<H5>Syntax</H5>

<P><CODE>*CtrlDebugOn</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>This command turns on debugging output. When debugging is active, just
before the control unit calls MPEGVideo_FullPackets or MPEGAudio_FullPackets,
it outputs a line containing the following information:

<UL>
  <LI>whether it is a video or audio packet
  <LI>the value of the "Length" field of the bitstream packet descriptor
  <LI>the value of the "FullLength" field of the bitstream packet descriptor,
      even if the Flags indicate that the value is invalid
  <LI>a letter "M" if Flags bit 0 is set <I>(ie packet is at the start of an
      MPEG packet)</I>
  <LI>a letter "U" if Flags bit 4 is set <I>(ie full length unknown)</I>
  <LI>the packet's PTS <I>(if validated by the Flags)</I>
</UL>

<P>Debugging is off by default.

<H4 align="right">*CtrlDebugOff</H4>

<P>Turns off debugging output

<H5>Syntax</H5>

<P><CODE>*CtrlDebugOff</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>This command turns off the debugging output previously enabled by
*CtrlDebugOn.

<H4 align="right">*MPEGCapture</H4>

<P>Initiates capture of the incoming stream to a dynamic area

<H5>Syntax</H5>

<P><CODE>*MPEGCapture <I>amount</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>amount</I></CODE>
<DD>the size of the dynamic area to store the stream in, or 0 to remove the
    dynamic area and disable capturing
</DL>

<H5>Use</H5>

<P>This call starts the capturing of the incoming stream to a circular buffer,
held in a dedicated dynamic area. The buffer is flushed on
MPEGControl_OpenStream, and also whenever it is resized.

<H4 align="right">*MPEGSave</H4>

<P>Saves captured stream data to a file

<H5>Syntax</H5>

<P><CODE>*MPEGSave <I>filename</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>filename</I></CODE>
<DD>file to save the captured data to
</DL>

<H5>Use</H5>

<P>This call allows the data captured by *MPEGCapture to be saved to a file.


<H3>5.3. UpCalls</H3>

<H4 align="right">UpCall_MPEG
<BR>(UpCall &amp;15)</H4>

<P>An event has occurred in the MPEG modules

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">&amp;15 (MPEG event)
<TR><TD>R1 =             <TD colspan="2">flags (reserved, currently 0)
<TR><TD>R2 =             <TD colspan="2">control stream handle (if applicable)
                                 or 0
<TR><TD rowspan="4">R3 = <TD colspan="2">sub-reason code:
<TR>                     <TD>&amp;0000 - &amp;0FFF<SUP>&nbsp;</SUP>
                             <TD>assigned to the control unit, see below
<TR>                     <TD>&amp;1000 - &amp;1FFF
                             <TD>assigned to the video unit
<TR>                     <TD>&amp;2000 - &amp;2FFF
                             <TD>assigned to the audio unit
<TR><TD colspan="3">Other registers depend upon the sub-reason code
</TBODY>
</TABLE>

<H4 align="right">UpCall_MPEG &amp;0000
<BR>(UpCall &amp;15)</H4>

<P>End of stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>control stream handle
<TR><TD>R3 =             <TD>&amp;0000
<TR><TD colspan="2">Interrupts are enabled
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the control unit when a pending end-of-stream has been
received (by whatever mechanism) and both the video and audio units have become
idle. For more details, see SWI MPEGControl_Play.

<H4 align="right">UpCall_MPEG &amp;0001
<BR>(UpCall &amp;15)</H4>

<P>Stream has reset

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>control stream handle
<TR><TD>R3 =             <TD>&amp;0001
<TR><TD>R4 =             <TD>reset-stream flags
<TR><TD colspan="2">Interrupts are enabled
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the control unit when a ResetStream occurs. This is
useful for clients that wish to monitor the play state in an event-driven
manner, especially with the concept of resets on Good Data Follows or Segment
Transitions (transport streams only).

<H4 align="right">UpCall_MPEG &amp;0002
<BR>(UpCall &amp;15)</H4>

<P>Stream has timed out

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>control stream handle
<TR><TD>R3 =             <TD>&amp;0002
<TR><TD colspan="2">Interrupts are enabled
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the control unit when it has processed no data for a
period of time and both the video and audio units have become idle. For more
details, see SWI MPEGControl_Play.


<H3>5.4. Program Element Handlers</H3>

<H4 align="right">Program Element Handler entry point</H4>

<P>Pass message from control unit to a program element handler

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =       <TD>reason code
<TR><TD>R12&nbsp;= <TD>handler's workspace pointer
<TR><TD colspan="2">V flag is clear
</TBODY>
</TABLE>

<P>The meaning of other registers is determined by the reason code.

<H5>On exit</H5>

<P>Depends on the reason code

<H4 align="right">Program Element Handler (Reason 0)</H4>

<P>Open stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>reason code (0)
<TR><TD>R1 =      <TD>stream flags (as passed to MPEGControl_OpenStream)
<TR><TD>R2&nbsp;= <TD>control stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = program element stream handle

<H5>Use</H5>

<P>This call is made as a result of a call to MPEGControl_OpenStream. The
call is made in turn to each registered handler, except for those stream types
which have been explicitly disabled by various flags passed to
MPEGControl_OpenStream (eg bits 0 and 1 of the stream flags control whether
the video and/or audio handlers will be called).

<P>The call returns a handle specific to this stream and this program element,
which is passed in to several of the other reason codes.

<P>If the handler returns a handle of zero, or returns an error (V set on exit,
r0 pointing to an error block), then this handler will be excluded from further
calls for this stream.

<H4 align="right">Program Element Handler (Reason 1)</H4>

<P>Data transfer

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>reason code (1)
<TR><TD>R1 =      <TD>flags (should be zero)
<TR><TD>R2 =      <TD>program element stream handle
<TR><TD>R3&nbsp;= <TD>pointer to one or more linked program element packet
                      descriptors
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 to R3 may be corrupted by the handler
<TR><TD>Other registers must be preserved (an error may possibly be returned)
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is used to pass data to the program element handler. The data may
be processed immediately, or a record of the entry may be queued by the handler
for later processing.

<H4 align="right">Program Element Handler (Reason 2)</H4>

<P>Close stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =      <TD>reason code (2)
<TR><TD>R1 =      <TD>flags (should be zero)
<TR><TD>R2&nbsp;= <TD>program element stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This reason code is issued when the stream is being closed.


<H3>5.5. Service Calls</H3>

<H4 align="right">Service_MPEGControlStarting (&amp;C7)</H4>

<P>Indicate control unit initialising

<H5>On entry</H5>

<P>R1 = service reason code (&amp;C7)

<H5>On exit</H5>

<P>All registers preserved (service should not be claimed)

<H5>Use</H5>

<P>This service call is issued by the MPEGControl module when it initialises.
When a program element handler module receives this service, it should
re-register itself with MPEGControl using
MPEGControl_RegisterProgramElementHandler.

<HR>

<H2><A name="interchange">6. Data interchange</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="formats">7. Data formats</A></H2>

<H3>7.1. Bitstream buffer</H3>

<P>A bitstream buffer is an area of memory used for storing MPEG bitstream data
in the system. Typically there will be a number of these in use at any time:
some of these will be empty, awaiting new data; others will contain data which
has not yet been delivered to the MPEG decoding units.

<P>A bitstream buffer descriptor is a structure which describes a bitstream
buffer, as follows:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>Link: pointer to 'next' bitstream buffer descriptor
<TR><TD>4      <TD>FreeRoutine: see MPEGControl_FullBuffers
<TR><TD>8      <TD>FreeWorkspace: see MPEGControl_FullBuffers
<TR><TD>12     <TD>Start: start address of bitstream buffer data
<TR><TD>16     <TD>Length: length of bitstream buffer in bytes
<TR><TD>20     <TD>Packets:
                   <TABLE border="0">
                   <THEAD align="left" valign="top">
                   <TR><TH>Bit(s) <TH>Meaning
                   </THEAD>
                   <TBODY align="left" valign="top">
                   <TR><TD>0-30   <TD>Private workspace for the control unit,
                                      must be set to zero on entry to
                                      MPEGControl_FullBuffers (is actually used
                                      for a count of the number of bitstream
                                      packets in this bistream buffer)
                   <TR><TD>31     <TD>When set, this indicates that the word at
                                      offset 24 is valid
                   </TBODY>
                   </TABLE>
<TR><TD>24     <TD>Control stream handle (only if Packets bit 31 is set)
</TBODY>
</TABLE>

<H3>7.2. Bitstream packet (aka program element packet)</H3>

<P>A bitstream packet is an area of memory within a bitstream buffer which
contains all or part of an MPEG packet, ie a contiguous block of payload for a
particular elementary stream.

<P>A bitstream packet descriptor (or program element packet descriptor) is a
structure which describes a bitstream packet, as follows:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>Link: pointer to 'next' bitstream packet descriptor
<TR><TD>4      <TD>FreeRoutine: address of routine to call to free packet
<TR><TD>8      <TD>FreeWorkspace: workspace pointer for free packet routine
<TR><TD>12     <TD>Start: start address of bitstream packet data
<TR><TD>16     <TD>Length: length of bitstream packet in bytes
<TR><TD>20     <TD>BufferDescriptor: pointer to bitstream buffer descriptor for
                   buffer containing this packet
<TR><TD>24     <TD>Flags: bitstream packet flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>bit&nbsp;0&nbsp;set&nbsp;=&gt;
                       <TD>bitstream packet is at the start of an MPEG-1 packet
                           or MPEG-2 PES packet
                   <TR><TD>bit 1 set =&gt;
                       <TD>BSn field is valid (only ever set for MPEG-1 packets)
                   <TR><TD>bit 2 set =&gt;
                       <TD>PTS field is valid
                   <TR><TD>bit 3 set =&gt;
                       <TD>DTS field is valid
                   <TR><TD>bit 4 set =&gt;
                       <TD>full length is unknown - for compatibility with
                           video streams where the length field in a PES packet
                           header may be zero (indicates indeterminate packet
                           length)
                   </TBODY>
                   </TABLE>
<TR><TD>28     <TD>BSn: the size of the input buffer in the system target
                   decoder (in bytes)
                   <BR>This is computed from the optional STD_buffer_scale and
                   STD_buffer_size fields in an MPEG-1 packet header
<TR><TD>32     <TD>PTS: presentation time stamp (optional field in MPEG packet
                   header) (5 bytes)
<TR><TD>40     <TD>DTS: decoding time stamp (optional field in MPEG packet
                   header) (5 bytes)
<TR><TD>48     <TD>FullLength: full length of the MPEG packet (only valid if
                   bit 0 of Flags is set and bit 4 is clear)
</TBODY>
</TABLE>
The length of the bitstream packet descriptor may grow in the future.

<H3>7.3. Video parameters structure</H3>

<P>A video parameters structure is a structure passed to
MPEGControl_OpenStream, and subsequently to the video unit, which identifies
parameters associated with the video element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>FormatType: video parameters structure format type (0 at
                   present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>don't clear screen contents before display; if this
                           bit is clear, the module assumes we're in a 16-bpp
                           mode
                   <TR><TD>Bit 1 set =&gt;
                       <TD>don't alter hardware palette; if this bit is clear,
                           the module assumes we're in a 16-bpp mode
                           <BR><I>(STB-3 only, STB-400 always behaves as though
                           this bit were set)</I>
                   <TR><TD>Bit 2 set =&gt;
                       <TD>configure for NTSC output (not PAL)
                           <BR><I>(STB-3 only, STB-400 determines this by
                           cacheing the DENC state at each mode change)</I>
                   <TR><TD colspan="2">Bits 3 to 15 reserved - set to zero
                   <TR><TD>Bit 16 set =&gt;
                       <TD>BlankedSequences and BlankedFields entries are
                           present
                           <BR><I>(STB-3 only, entries are ignored on
                           STB-400)</I>
                   <TR><TD>Bit 17 set =&gt;
                       <TD>apply underrun fix when in trick play mode
                           <BR><I>(STB-3 only, STB-400 always behaves as though
                           this bit were set)</I>
                   <TR><TD>Bit 18 set =&gt;
                       <TD>fix up PES packet lengths when in trick play mode
                           <BR><I>(STB-3 only, STB-400 doesn't require this
                           fix)</I>
                   <TR><TD>Bit&nbsp;19&nbsp;set&nbsp;=&gt;
                       <TD>ScalingType and the four subsequent entries are
                           present (if this is clear, default to Free scaling
                           type with all parameters set to NVRAM defaults)
                           <BR><I>(STB-400 only, entries are ignored on
                           STB-3)</I>
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>ScreenMode: mode specifier (ie number or pointer to mode
                   selector block) for screen mode to select (or -1 to indicate
                   no screen mode change)
<TR><TD>12     <TD>Reserved: must be zero
<TR><TD>16     <TD>Reserved: must be zero
<TR><TD>20     <TD>Reserved: must be zero
<TR><TD>24     <TD>Reserved: must be zero
<TR><TD>28     <TD>BlankedSequences: <I>(STB-3 only)</I> see below
<TR><TD>32     <TD>BlankedFields: <I>(STB-3 only)</I> when a stream is played,
                   initially the screen is blanked; it is only unblanked after
                   'BlankedSequences' number of video sequence headers have
                   been decoded, followed by 'BlankedFields' video field times.
                   These values are only present if bit 16 of the Flags word is
                   set, otherwise BlankedSequences defaults to 1, and
                   BlankedFields defaults to 16.
<TR><TD>36     <TD>ScalingType: <I>(STB-400 only)</I> determines how horizontal
                   and vertical video scaling should be performed:
                   <TABLE cellspacing="2">
                   <THEAD align="left" valign="top">
                   <TR><TH>Value <TH>Scaling type
                   </THEAD>
                   <TBODY align="left" valign="top">
                   <TR><TD>0     <TD>Free (width and height calculated from
                                     video headers, TV aspect and viewing mode)
                   <TR><TD>1     <TD>Fixed width
                   <TR><TD>2     <TD>Fixed height
                   <TR><TD>3     <TD>Fixed width and height
                   </TBODY>
                   </TABLE>
                   The interpretation of offsets 40-52 also depend upon this value.
<TR><TD>40-52  <TD>ScalingType parameters <I>(STB-400 only)</I>:
                   <TABLE cellspacing="2">
                   <TBODY align="left" valign="top">
                   <TR><TH colspan="2">ScalingType 0:
                   <TR><TD>40 <TD>Flags:
                              <BR>bit 0 set =&gt; value at +44 is valid;
                                  otherwise use NVRAM to determine setting
                              <BR>bit 1 set =&gt; bits 0 and 1 at +48 are
                                  valid; otherwise use NVRAM to determine
                                  settings
                              <BR>bit 2 set =&gt; value at +52 is valid;
                                  otherwise use NVRAM to determine setting
                              <BR>other bits are reserved, and must be zero
                              <BR>All of bits 0-2 will be set when reading the
                                  ScalingType parameters with SWI
                                  MPEGVideo_SetVideoParameters 0, and all the
                                  fields below will be correctly set up.
                   <TR><TD>44 <TD>TV aspect ratio: 0 =&gt; 4:3, 1 =&gt; 16:9
                   <TR><TD>48 <TD>Image scaling flags:
                              <BR>bit 0 set =&gt; use line 23 widescreen
                                  signalling
                              <BR>bit 1 set =&gt; use SCART pin 8 widescreen
                                  signalling
                              <BR>other bits are reserved, and must be zero
                   <TR><TD>52 <TD>Viewing mode (see below): 0 =&gt; Box,
                                  2 =&gt; Zoom, 3 =&gt; Stretch, others are
                                  undefined and reserved
                   <TR><TH colspan="2">ScalingType 1:
                   <TR><TD>40 <TD>0 =&gt; TV has conventional pixel aspect
                                  ratio for this TV standard,
                                  1 =&gt; TV is in anamorphic mode (wide pixels)
                   <TR><TD>44 <TD>Width (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 2:
                   <TR><TD>40 <TD>0 =&gt; TV has conventional pixel aspect
                                  ratio for this TV standard,
                                  1 =&gt; TV is in anamorphic mode (wide pixels)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 3:
                   <TR><TD>40 <TD>Width (OS units)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   </TBODY>
                   </TABLE>
</TBODY>
</TABLE>

<H3>7.4. Audio parameters structure</H3>

<P>An audio parameters structure is a structure passed to
MPEGControl_OpenStream, and subsequently to the audio unit, which identifies
parameters associated with the audio element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>Audio structure format type (0 at present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>mute audio on bit errors
                   <TR><TD>Bit&nbsp;1&nbsp;set =&gt;
                       <TD>dual channel mode specifier field is valid
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>Dual channel mode specifier (only valid if bit 1 of Flags
                   is set)
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>0 =&gt; <TD>play both channels
                   <TR><TD>1 =&gt; <TD>play left channel only
                   <TR><TD>2 =&gt; <TD>play right channel only
                   </TBODY>
                   </TABLE>
<TR><TD>12...  <TD>Reserved for future expansion
</TBODY>
</TABLE>

<HR>

<H2><A name="external">8. External dependencies</A></H2>

<UL>
  <LI>Target hardware must be available for testing.
</UL>

<HR>

<H2><A name="acceptance">9. Acceptance test</A></H2>

<UL>
  <LI>Must function on target hardware as specified.
</UL>

<HR>

<H2><A name="noncompliances">10. Noncompliances</A></H2>

<P>There are no noncompliances.

<HR>

<H2><A name="test">11. Development test strategy</A></H2>

<UL>
  <LI>All SWIs must function as specified.
  <LI>All * commands must function as specified.
  <LI>All program element handler reason codes must be called as specified.
  <LI>Service_MPEGControlStarting must be issued as specified.
</UL>

<HR>

<H2><A name="organisation">12. Product organisation</A></H2>

<P>The MPEGControl module is written in assembler, and may be built into ROM or
soft-loaded.

<HR>

<H2><A name="enhancements">13. Future enhancements</A></H2>

<P>None planned at present.

<HR>

<H2><A name="glossary">14. Glossary</A></H2>

<DL>
<DT>bpp
  <DD>bits per pixel.
<DT>BSn
  <DD>the Size of the input Buffer to hold data for elementary stream n in the
    "system target decoder" (a hypothetical reference model of a decoding
    process, as used in the MPEG standards).
<DT>cs
  <DD>centisecond (0.01 second).
<DT>DSM-CC
  <DD>Digital Storage Media Command and Control - a set of protocols to provide
    the control operations and functions to manage MPEG-2 bitstreams.
<DT>DTS
  <DD>Decoding Time Stamp - a time stamp associated with a particular video or
    audio frame, which indicates the value of the PCR or SCR at the moment the
    video or audio frame should be decoded.
<DT>DVB
  <DD>Digital Video Broadcasting. The acronym may also be used to refer to the
    Digital Video Broadcasting Project consortium of broadcasters,
    manufacturers, network operators and regulatory bodies.
<DT>IEC
  <DD>International Engineering Consortium.
<DT>IRQ
  <DD>Interrupt ReQuest.
<DT>ISO
  <DD>International Standards Organisation.
<DT>MPEG
  <DD>Moving Picture (Motion Pictures) Experts Group - the nickname of
    SubCommittee 29 of Working Group 11 of ISO/IEC Joint Technical Committee 1.
<DT>MPEG-1
  <DD>the nickname of ISO/IEC 11172 (see References).
<DT>MPEG-2
  <DD>the nickname of ISO/IEC 13818 (see References).
<DT>NPT
  <DD>Normal Play Time - a continuous timeline over the duration of an event
    (eg a single television programme). This contrasts with the System Time
    Clock (recovered from a PCR or SCR), which may contain discontinuities.
<DT>NPT Reference descriptor
  <DD>a descriptor intended to deliver the mapping between individual STC and
    NPT references, and the ratio of the rate of increase of the two (ie the
    trick play state) using a separate PID in the MPEG stream. OVS has
    overloaded it to signal Good Data Follows (GDF) and Segment Transition
    events.
<DT>NTSC
  <DD>National Television System Committee (of the Electronics Industries
    Association, the organisation which defined the standard format adopted by
    the FCC for broadcast television in the USA). Commonly used to refer to the
    standard-resolution, composite, colour video standard in use in the USA,
    Japan, Canada and Mexico.
<DT>OVS
  <DD>Oracle Video Server.
<DT>PAL
  <DD>Phase Alternation by Line - the standard-resolution, composite, colour
    video standard in use in the UK and most of western Europe (with the
    notable exception of France).
<DT>PAT
  <DD>Program Association Table - held in transport stream packets of PID 0,
    this holds a complete list of all programmes within the stream, and the PID
    of a PMT for each one.
<DT>PCR
  <DD>Program Clock Reference - a 90kHz time reference in a transport stream,
    used for synchronisation of MPEG playback.
<DT>PES
  <DD>Packetized Elementary Stream: a stream of variable-length packets from
    only one elementary stream (normally either video or audio). It requires
    transmission or storage in relatively error-free media.
<DT>PID
  <DD>Packet IDentifier - a field in each transport stream packet, identifying
    which elementary stream the packet's payload belongs to. Some PIDs instead
    indicate the Program Association Table, Program Map Tables, Conditional
    Access Table, Network Information Table, etc.
<DT>PMT
  <DD>Program Map Table - a table which fully defines a programme, including
    the PIDs of each relevant elementary stream.
<DT>Program stream
  <DD>similar to a system stream, but defined in the MPEG-2 standard.
<DT>PS
  <DD>see <I>program stream</I>.
<DT>PTS
  <DD>Presentation Time Stamp - a time stamp associated with a particular video
    or audio frame, which indicates the value of the PCR or SCR at the moment
    the video or audio frame should be presented.
<DT>RAM
  <DD>Random Access Memory.
<DT>ROM
  <DD>Read Only Memory.
<DT>SCR
  <DD>System Clock Reference - a 90kHz time reference in a system or program
    stream, used for synchronisation of MPEG playback.
<DT>STB
  <DD>Set Top Box.
<DT>SS
  <DD>see <I>system stream</I>.
<DT>SVC
  <DD>the "supervisor" mode of the ARM architecture - a privileged state,
    intended for general-purpose OS code.
<DT>SWI
  <DD>SoftWare Interrupt - basic OS function call.
<DT>System stream
  <DD>a variable-length-packet stream interleaving video, audio and other PES
    packets relating to a single programme, together with header packets. It
    requires transmission or storage in relatively error-free media. It is
    defined in the MPEG-1 standard.
<DT>Transport stream
  <DD>a fixed-length-packet stream, further encoding video, audio and other PES
    packets relating to one or more programmes. It is capable of transmission
    or storage in relatively error-prone media. It is defined in the MPEG-2
    standard.
<DT>TS
  <DD>see <I>transport stream</I>.
<DT>VIDC
  <DD>VIDeo Controller.
</DL>

<HR>

<H2><A name="references">15. References</A></H2>

<UL>
  <LI>ISO/IEC 11172: Information technology &mdash; Coding of moving pictures
      and associated audio for digital storage media at up to about 1,5 Mbit/s.
      Published in these parts:
      <UL>
        <LI>Part 1: Systems (1993)
        <LI>Part 2: Video (1993)
        <LI>Part 3: Audio (1993)
        <LI>Part 4: Conformance testing (1995)
        <LI>Part 5 (Technical Report): Software simulation (1998)
      </UL>
  <LI>ISO/IEC 13818: Information technology &mdash; Generic coding of moving
      pictures and associated audio information. Published in these parts:
      <UL>
        <LI>Part 1: Systems (1996)
        <LI>Part 2: Video (1996)
        <LI>Part 3: Audio (1998)
        <LI>Part 4: Conformance testing (1998)
        <LI>Part 5 (Technical Report): Software simulation (1997)
        <LI>Part 6: Extensions for DSM-CC (1998)
        <LI>Part 7: Advanced Audio Coding (1997)
        <LI>Part 9: Extension for real time interface for systems decoders
            (1996)
        <LI>Part 10: Conformance extensions for DSM-CC (1999)
      </UL>
</UL>

<HR>

<H2><A name="history">16. History</A></H2>

<TABLE width="100%" border="0">
<TBODY align="left" valign="top">
<TR><TD><STRONG>Issue</STRONG>  <TD><STRONG>Date</STRONG>  <TD><STRONG>Author</STRONG>  <TD><STRONG>Description of change</STRONG>
<TR><TD>A                       <TD>18&nbsp;Sep&nbsp;2000  <TD>BAvison                  <TD>Initial version, adapted from MPEGSystem/MPEGTransport issue 2A specs.

</TBODY>
</TABLE>


</BODY>
</HTML>
