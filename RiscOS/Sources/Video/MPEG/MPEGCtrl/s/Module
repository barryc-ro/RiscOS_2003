; > Module
; Source for MPEG Control Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 01-Jun-94  TMD  0.01          Started work (after a false start in 'C')
; 18-Jul-94  TMD  0.10          Release for Malcolm's trip
; 23-Aug-94  TMD  0.18          Added debug code for unknown MPEGControl SWI
;                               Now copes with multiple packets being freed at once
;                               Added checks for negative packet/full packet length
; 08-Sep-94  TMD  0.19          Put in flags in MPEGControl_Play, so both audio and video
;                               need to be ready before it plays
; 17-Oct-94  TMD  0.20          Put in incoming data rate measurement
; 20-Oct-94  TMD  0.21          If playing elemental video or audio stream, clear other bit in NotReadyBits
; 21-Oct-94  TMD  0.22          If playing elemental video or audio stream, chop up buffers into packets < 64K
; 01-Nov-94  TMD  0.23          Attempt to recover from negative length packets
; 14-Nov-94  TMD  0.24          Fix SWI despatch to use correct SWI limit
; 07-Feb-95  TMD  0.25		Made die entry free packet descriptors on free list
; 07-Feb-95  TMD  0.26		Fixed bug OMI-00006 (if opening audio fails, now closes already opened video stream)
; 06-Mar-95  TMD  0.27		Added MPEGControl_ResetStream
; 29-Mar-95  TMD  0.28		Debug version to check ICL server problem
; 06-Apr-95  TMD  0.29		(Conditionally) fake a zero PTS on audio-only stream packets
; 06-Apr-95  TMD  0.30		Don't zero DataReceived on Play SWI, as we've already received some by then!
; 24-May-95  TMD  0.31		Added MPEGControl_MuteSound
; 08-Jun-95  TMD  0.32		Check StreamFlags_PassThroughToVideo
; 21-Jul-95  TMD  0.33		Added detection of iso_11172_end_code (&000001B9)
; 11-Aug-95  TMD  0.34		Added MPEGControl_SoundVolume
;				Fix MPEGControl_MuteSound not passing in correct audio stream handle
; 05-Sep-95  TMD  0.35		Terminate video/audio prefill on MPEGControl_CloseStream before calling MPEGVideo/Audio_CloseStream
; 08-Feb-96  TMD  0.36		Fix FreeBuffer routine not setting up r12 when a routine address is specified rather than a SWI.
; 07-Mar-96  TMD  0.37		Added MPEGControl_Stats SWI
; 08-Jul-96  TMD  0.38		Added support for DataReturned statistic
; 16-Jul-96  TMD  0.39		(Conditionally) remove checks for video-only or audio-only streams, for testing by Siemens
; 01-Nov-96  TMD  0.40		Make InternalStack consistent with MPEGTrans - ie only allow 2K for coroutine stack, which
;				leaves 6K for stack-hungry C code.
; 27-Feb-97  TMD  0.41		Created variant that copies the coroutine stack away each time into an RMA block.
; 10-Mar-97  TMD  0.42		Don't do MODE12 on the error from (De)RegisterProgramElementHandler SWIs
; 16-May-97  TMD  0.43		(Conditionally) support MPEG-2 Program Streams
; 13-Oct-98  TMD  0.44		Added MPEGControl_SetAudioParameters SWI.
; 18-Nov-98  TMD  0.45		Added count of how many misaligned start codes we got
; 20-Nov-98  TMD  0.46		Make SelectProgram do a ResetStream, and stop sending data through if program
;				 zero is selected.
; 10-Dec-98  BJGA 0.47		Changed module name to MPEGSystem, changed SWI chunk and added "Sys" prefix to * commands.
; 20-May-99  BJGA 0.48          Made same NotReadyBits bugfix as in MPEGTransport 1.70
;

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

                GBLL    BuildAsMPEGControl
BuildAsMPEGControl SETL {FALSE}

                GBLL    UseSVCStack
UseSVCStack     SETL     {TRUE}

                GBLL    AutoABSDetect
AutoABSDetect   SETL    {TRUE}                          ; automatically detect audio-only files

                GBLL    ErrorRecovery
ErrorRecovery   SETL    {TRUE}                          ; attempt to recover from -ve length packets

		GBLL	ICLDebug
ICLDebug	SETL	{FALSE}

		GBLL	CoroutineStackCopied		; coroutine stack lives on normal SVC stack and is copied away each time
CoroutineStackCopied SETL {TRUE}			; into a static block

		GBLL	SupportMPEG2PS
SupportMPEG2PS	SETL	{TRUE}				; support decoding of MPEG-2 Program Streams

 [ :LNOT: CoroutineStackCopied
  [ UseSVCStack
InternalStack           *       &01C00800               ; 3/4 way down normal SVC stack
  |
InternalStackSize       *       4096                    ; could probably work with much less
  ]
 ]

; If playing elemental streams, we need to chop up large buffers longer than 64K into smaller
; chunks, because the maximum MPEG packet size is 64K

MaxMPEGPacketLength     *       &FF00                   ; allow some space for packet headers as well

; PES packet header optional flags

PES_Optional_PTS_Present	*	&80		; PTS field present
PES_Optional_DTS_Present	*	&40		; DTS field present

; Control stream handle structure

                        ^       0
CSH_StreamFlags         #       4
CSH_VideoStreamHandle   #       4
CSH_AudioStreamHandle   #       4
 [ CoroutineStackCopied
CSH_CoroutineStackCopy  #	4			; pointer to copy of coroutine stack claimed out of RMA
CSH_CoroutineStackBlockSize #	4			; size of block allocated
CSH_CoroutineStackSize	#	4			; number of words currently on stack
 |
CSH_InternalSP          #       4                       ; internal stack pointer for coroutines
 ]
CSH_ExternalSP          #       4                       ; external stack pointer for coroutines
CSH_NotReadyBits        #       4                       ; bits indicating which elemental modules are not yet ready to play
 [ SendFirstSCR
CSH_SendNextSCR         #       4                       ; flag indicating we should send next SCR to video module
 ]
CSH_StartTime           #       4                       ; time stream was opened
CSH_LastTime            #       4                       ; last time data was received
CSH_DataReceived        #       4                       ; amount of data received
CSH_DataReturned	#	4			; amount of data returned
CSH_EndOfStreamReceived	#	4			; 0 normally, 1 when end of stream code has been received
CSH_SyncLosses		#	4			; number of times system stream had discontinuity
CSH_TooShortPackets	#	4			; number of packets whose header exceeded the packet length

 [ DataRateStats
DataCountPeriod         *       300                     ; seconds in 1 period
DataCountArraySize      *       100                     ; allow for 100 periods at present
CSH_DataCounts          #       DataCountArraySize * 4  ; one word per minute
 ]

 [ :LNOT: UseSVCStack
CSH_InternalStack       #       InternalStackSize       ; stack for coroutines
CSH_InternalStackEnd    #       0
 ]
CSHSize                 *       @


                        ^       0, wp

FreePacketListHeadPtr   #       4       ; pointer to head of list of free packet descriptors
FreePacketListTailPtr   #       4       ; pointer to tail of list

SWIInstruction          #       8       ; SWI + Pull pc

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

ControlStreamHandle     #       CSHSize ; goes at the end cos likely to be long (with stack)
                                        ; NB this could be dynamically allocated on OpenStream eventually

Module_WorkspaceSize * :INDEX: @

; ** Debugging macros **

        GBLL    debug
debug   SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   $string, $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, $string, $cc, $routine
 ]
        MEND

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
 [ BuildAsMPEGControl
        &       MPEGControlSWI_Base ; SWI chunk
 |
        &       MPEGSystemSWI_Base ; SWI chunk
 ]
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
 [ BuildAsMPEGControl
        =       "MPEGControl", 0
 |
        =       "MPEGSystem", 0
 ]

Mod_HelpStr
 [ BuildAsMPEGControl
        =       "MPEGControl", TAB
 |
        =       "MPEGSystem", TAB
 ]
	=	"$Module_MajorVersion ($Module_Date)"
 [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
 ]
 [ OnlyAllowSystemStreams
	=	" (System streams only version)"
 ]
 [ ICLDebug
	=	" ICL Debug"
 ]
	=	0
        ALIGN

Mod_SWITable
 [ BuildAsMPEGControl
        =       "MPEGControl", 0
 |
        =       "MPEGSystem", 0
 ]
        =       "OpenStream", 0
        =       "FullBuffers", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
	=	"ResetStream", 0
	=	"MuteSound", 0
	=	"SoundVolume", 0
	=	"SelectProgram", 0
	=	"Stats", 0
	=	"RegisterProgramElementHandler", 0
	=	"DeregisterProgramElementHandler", 0
	=	"SetAudioParameters", 0
        =       0

 [ BuildAsMPEGControl

Mod_HC_Table
        Command CtrlInfo, 0, 0
        =       0

CtrlInfo_Help
        =       "*CtrlInfo outputs debugging info.", CR
CtrlInfo_Syntax
        =       "Syntax: *CtrlInfo", 0
        ALIGN

 |

Mod_HC_Table
        Command SysCtrlInfo, 0, 0
        =       0

SysCtrlInfo_Help
        =       "*SysCtrlInfo outputs debugging info.", CR
SysCtrlInfo_Syntax
        =       "Syntax: *SysCtrlInfo", 0
        ALIGN

 ]

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, FreePacketListHeadPtr
        STR     r0, FreePacketListTailPtr

        LDR     r0, PullPCInstruction
        STR     r0, SWIInstruction +4

      [ :LNOT: BuildAsMPEGControl
        MOV     r0, #2
        MOV     r1, #0
        ADR     r2, Module_BaseAddr
        MOV     r3, r12
        SWI     XMPEGControl_ControlOp  ; Let MPEGControl know we've initialised
      ]

        CLRV
        EXIT

PullPCInstruction
        Pull    PC

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; Free all the packets on our free list

	LDR	r1, FreePacketListHeadPtr
10
	MOVS	r2, r1					; are there any more nodes to free?
	BEQ	%FT90					; [no, so skip]
	LDR	r1, [r2, #PacketDescriptor_Link]	; get link to next
	MOV	r0, #ModHandReason_Free			; free this one
	SWI	XOS_Module
	B	%BT10					; and try again

90
      [ :LNOT: BuildAsMPEGControl
        MOV     r0, #3
        MOV     r1, #0
        SWI     XMPEGControl_ControlOp  ; Let MPEGControl know we've died
      ]

        CLRV
        EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #(SWIBTableEnd - SWIBTable) :SHR: 2
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
SWIBTable
        B       OpenStream      ; open stream
        B       FullBuffers     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
	B	ResetStream	; discard data and reset devices
	B	MuteSound	; mute/unmute sound
	B	SoundVolume	; set/read sound volume
	B	SelectProgram	; select program to watch
	B	Stats		; return statistics
	B	RegisterProgramElementHandler ; register a new program element handler
	B	DeregisterProgramElementHandler ; and deregister it
	B	SetAudioParameters ; set audio parameters
SWIBTableEnd

NoSuchSWI
        Push    "lr"
        SWI     XOS_WriteI+22
        SWI     XOS_WriteI+12
        DREG    r11, "Unknown MPEGControl SWI - offset from base = "
        DLINE   "Press any key"
        SWI     XOS_ReadC
	Pull	"lr"
RegisterProgramElementHandler	; not supported in MPEGCtrl - just return a 'soft' error
DeregisterProgramElementHandler ; not supported in MPEGCtrl - just return a 'soft' error
        ADR     r0, NoSuchSWIError
        SETV
	MOV	pc, lr

NoSuchSWIError
        &       0
        =       "No such MPEGControl SWI", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control parameters structure
;       r2 = video parameters structure
;       r3 = audio parameters structure
;
; out:  r0 = control stream handle (for now)
;

OpenStream Entry "r0-r2"
        ADR     r1, ControlStreamHandle

        STR     r0, [r1, #CSH_StreamFlags]

        AND     lr, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        STR     lr, [r1, #CSH_NotReadyBits]             ; which bits are not yet ready to play

 [ SendFirstSCR
        ASSERT  StreamFlags_VideoPresent = 1
        ANDS    lr, r0, #StreamFlags_VideoPresent
        STR     lr, [r1, #CSH_SendNextSCR]              ; only send 1st SCR if doing video
 |
        TST     r0, #StreamFlags_VideoPresent
 ]
        BEQ     %FT10

        SWI     XMPEGVideo_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
        EXIT    VS
        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_VideoStreamHandle]
        LDR     r0, [r1, #CSH_StreamFlags]
10
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT20

        MOV     r2, r3
        SWI     XMPEGAudio_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
	BVS	%FT90

        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_AudioStreamHandle]
20
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_StartTime]
        STR     r0, [r1, #CSH_LastTime]

        MOV     r0, #0
        STR     r0, [r1, #CSH_DataReceived]
	STR	r0, [r1, #CSH_DataReturned]
	STR	r0, [r1, #CSH_EndOfStreamReceived]	; haven't had end of stream marker yet
	STR	r0, [r1, #CSH_SyncLosses]		; no loss of system stream sync yet
	STR	r0, [r1, #CSH_TooShortPackets]		; no short packets yet
 [ CoroutineStackCopied
	STR	r0, [r1, #CSH_CoroutineStackCopy]	; no block allocated yet
	STR	r0, [r1, #CSH_CoroutineStackBlockSize]	; no space in it
 ]

 [ DataRateStats
        MOV     lr, #DataCountArraySize-1               ; initialise all data counts to zero
        ADD     r2, r1, #CSH_DataCounts
30
        STR     r0, [r2, lr, LSL #2]
        SUBS    lr, lr, #1
        BPL     %BT30
 ]

        MOV     r0, r1
        BL      coinit                          ; initialise coroutines

        CLRV
        STR     r0, [sp]
        EXIT

; we failed to open the audio stream, so close any already opened video stream and exit

90
	ADR	r1, ControlStreamHandle
	LDR	r0, [r1, #CSH_StreamFlags]
	TST	r0, #StreamFlags_VideoPresent	; did we open a video stream?
	LDRNE	r1, [r1, #CSH_VideoStreamHandle]
	MOVNE	r0, #0
	SWINE	XMPEGVideo_CloseStream		; if so then close it

	SETV
	EXIT

; **************************************************************************
;
;       Play - Start audio and video playing (if both ready)
;
; in:   r0 = flags
;            bit 0 set => video module ready to play
;            bit 1 set => audio module ready to play
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

Play    Entry "r0-r3"
        ADR     r1, ControlStreamHandle

        LDR     r3, [r1, #CSH_NotReadyBits]
        BICS    r3, r3, r0                      ; clear not ready bits for this module
        STR     r3, [r1, #CSH_NotReadyBits]
        EXIT    NE                              ; someone still isn't ready

        LDR     r3, [r1, #CSH_StreamFlags]
        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        MOV     r0, #0                          ; flags
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

        Push    "r1,r2"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
20
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_StartTime]
        STR     r0, [r1, #CSH_LastTime]
        CLRV
        EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of play on MPEG stream
;
; in:   r0 = flags
;       r1 = external stream handle (assumed for now)
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0-r3"
        ADR     r1, ControlStreamHandle

        LDR     r3, [r1, #CSH_StreamFlags]
        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        MOV     r0, #0                          ; flags
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_SetSpeed
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_SetSpeed
        STRVS   r0, [sp]
        EXIT    VS
20
        CLRV
        EXIT

; **************************************************************************
;
;       MuteSound - Mute/unmute sound
;
; in:   r0 = flags
;		bit 0 = 0 => sound on
;		        1 => sound off
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

MuteSound Entry "r0-r3"
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_MuteSound			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SoundVolume - Set/read sound volume
;
; in:   r0 = flags (zero for now)
;       r1 = external stream handle (assumed for now)
;	r2 = -1 => read volume
;	   = 0..256 => set volume (logarithmic)
;
; out:  r2 = old volume
;

SoundVolume Entry "r0,r1"
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_SoundVolume			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SetAudioParameters - Set various audio parameters
;
; in:   r0 = reason code
;       r1 = external stream handle
;	Others depend on reason code
;
; out:  Depends on reason code
;

SetAudioParameters Entry "r0,r1"
	CLRV
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_SetAudioParameters		; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       FullBuffers - Here's some more data
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> one or more linked bitstream buffers

FullBuffers Entry "r0-r5"
        ADR     r1, ControlStreamHandle                 ; for now, since Keith isn't doing the open!

        LDR     r0, [r1, #CSH_NotReadyBits]             ; if we haven't actually started playing yet, do nothing
        TEQ     r0, #0
        MOVNE   r5, #0                                  ; indicate no array element to increment
        BNE     %FT05
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_LastTime]

 [ DataRateStats
        LDR     lr, [r1, #CSH_StartTime]
        SUB     r0, r0, lr                              ; time since starting
        LDR     lr, =DataCountPeriod*100                ; number of centiseconds in a period
        DivRem  r5, r0, lr, r3                          ; r5 = number of periods since starting
        CMP     r5, #DataCountArraySize                 ; check in range of array
        ADDCC   lr, r1, #CSH_DataCounts                 ; if so, then compute address of count to increment
        ADDCC   r5, lr, r5, LSL #2
        MOVCS   r5, #0                                  ; else indicate nothing to increment
 ]

05
        LDR     r0, [sp]                                ; reload flags

10

; ** DEBUGGING **

debug   SETL    {FALSE}

        DLine   "FullBuffer:"
        LDR     r3, [r2, #BufferDescriptor_Link]
        DReg    r3, " Link = "
        LDR     r3, [r2, #BufferDescriptor_FreeRoutine]
        DReg    r3, " FreeRoutine = "
        LDR     r3, [r2, #BufferDescriptor_FreeWorkspace]
        DReg    r3, " FreeWorkspace = "
        LDR     r3, [r2, #BufferDescriptor_Start]
        DReg    r3, " Start = "
        LDR     r3, [r2, #BufferDescriptor_Length]
        DReg    r3, " Length = "

debug   SETL    {FALSE}

        MOV     r3, #1
        STR     r3, [r2, #BufferDescriptor_Packets]     ; one user (us!)

        LDR     r3, [r2, #BufferDescriptor_Start]
        LDR     r4, [r2, #BufferDescriptor_Length]

        LDR     lr, [r1, #CSH_DataReceived]             ; increment count of total bytes received
        ADD     lr, lr, r4
        STR     lr, [r1, #CSH_DataReceived]

 [ DataRateStats
        TEQ     r5, #0                                  ; if we're inside array
        LDRNE   lr, [r5]                                ; then increment array element by amount of data
        ADDNE   lr, lr, r4
        STRNE   lr, [r5]
 ]
        ADD     r4, r3, r4

        LDR     lr, [r1, #CSH_StreamFlags]              ; if not in the process of closing the stream
							; and haven't selected program zero (no program)
        TST     lr, #StreamFlags_StreamClosing :OR: StreamFlags_NoProgramSelected
						        ; then call the coroutines to parse the buffer
        BLEQ    CallCoroutines                          ; otherwise effectively junk any data in the buffer

        MOV     r3, pc
        ORR     lr, r3, #I_bit          ; disable IRQs
        TEQP    lr, #0

        LDR     lr, [r2, #BufferDescriptor_Packets]
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        LDR     r4, [r2, #BufferDescriptor_Link]        ; load link *before* restoring IRQ state

        TEQP    r3, #0                  ; restore IRQ state

        TEQ     lr, #0                  ; is the count now zero (if so then no active packets in buffer)
        BNE     %FT20                   ; [no, so don't free buffer]

        Push    "r1"
        STR     lr, [r2, #BufferDescriptor_Link] ; only free one buffer
        MOV     r1, r2
        BL      FreeBuffer
        Pull    "r1"
20
        MOVS    r2, r4                  ; put link back into r2
        BNE     %BT10                   ; and if more buffers, loop
        CLRV
        EXIT

; **************************************************************************
;
;       CloseStream - Close the stream
;
; in:   r0 = flags
;       r1 = control stream handle
;

CloseStream Entry "r0"
        ADR     r1, ControlStreamHandle
        LDR     r0, [r1, #CSH_StreamFlags]
        ORR     r0, r0, #StreamFlags_StreamClosing	; first set the stream closing bit, so any incoming data gets junked
        STR     r0, [r1, #CSH_StreamFlags]

	LDR	lr, [r1, #CSH_NotReadyBits]		; see if we've issued the Play SWI yet
	TEQ	lr, #0
	BEQ	%FT10					; we have, so no need to issue it again

; we haven't yet told them to go, so do so now

	Push	"r0"
	MOV	r0, lr
	BL	Play
	Pull	"r0"

10
        TST     r0, #StreamFlags_VideoPresent
        BEQ     %FT20

        Push    "r0, r1"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_CloseStream
        Pull    "r0, r1"
20
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT30

        Push    "r0, r1"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_CloseStream
        Pull    "r0, r1"
30
 [ CoroutineStackCopied

; Now free the coroutine stack block

	Push	"r0-r2"
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVNE	r0, #ModHandReason_Free
	SWINE	XOS_Module
	MOV	r2, #0
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	STR	r2, [r1, #CSH_CoroutineStackBlockSize]
	Pull	"r0-r2"
 ]
        CLRV
        EXIT

; **************************************************************************
;
;	SelectProgram - Select TS program number to watch
;			Ignored in this module
;
; in:	r0 = flags
;	r1 = control stream handle
;	r2 = program number to select, or -1 to choose 1st program
;
; out:	-

SelectProgram Entry "r0-r3"
	LDR	r0, [r1, #CSH_StreamFlags]
	TEQ	r2, #0
	ORREQ	r0, r0, #StreamFlags_NoProgramSelected ; if zero then don't allow any data through
	BICNE	r0, r0, #StreamFlags_NoProgramSelected ; else allow anything through
						       ; (we only accept stream codes &C0 and &E0 anyway)
	STR	r0, [r1, #CSH_StreamFlags]
	AND	r0, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
	BL	ResetStream
	EXIT

; **************************************************************************
;
;       FreePackets - Called by video/audio devices to free a packet
;
; in:   r0 -> packet descriptor (for now)
;
; out:  -
;

FreePackets Entry "r0-r5, wp"
        MOV     r1, r0
        LDR     wp, [r1, #PacketDescriptor_FreeWorkspace]
10
        LDR     r2, [r1, #PacketDescriptor_BufferDescriptor]    ; get parent buffer pointer

        MOV     r3, pc
        ORR     lr, r3, #I_bit                          ; disable IRQs round this bit
        TEQP    lr, #0

; decrement outstanding packet count for buffer (atomically)

        LDR     lr, [r2, #BufferDescriptor_Packets]     ; (needs to be atomic)
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

; add this packet descriptor to free list

        LDR     r4, FreePacketListTailPtr
        TEQ     r4, #0                                  ; if no packets currently free
        STREQ   r1, FreePacketListHeadPtr               ; then point head at new free packets
        STRNE   r1, [r4, #PacketDescriptor_Link]        ; else tail!link = packet
        STR     r1, FreePacketListTailPtr               ; store new tail ptr

        LDR     r4, [r1, #PacketDescriptor_Link]        ; go down to next packet on passed list
        MOV     r5, #0
        STR     r5, [r1, #PacketDescriptor_Link]        ; detach packet

        TEQP    r3, #0                                  ; restore IRQ state

        TEQ     lr, #0                                  ; if all buffer data has been used, then free buffer
        STREQ   lr, [r2, #BufferDescriptor_Link]        ; only free one buffer
        MOVEQ   r1, r2
        BLEQ    FreeBuffer

        MOVS    r1, r4                                  ; are we at end of passed list?
        BNE     %BT10                                   ; no, so loop

        EXIT

; **************************************************************************
;
;	ResetStream - Discard data and reset devices
;
; in:	r0 = flags
;		bit 0 set => new stream has video data
;		bit 1 set => new stream has audio data
;	r1 = control stream handle
;
; out:	r2 = estimate of amount of discarded video data, in bytes
;	r3 = estimate of amount of discarded audio data, in bytes
;

ResetStream Entry "r0-r3"
	MOV	r3, #0
	STR	r3, [sp, #2*4]			; zero the returned r2
	STR	r3, [sp, #3*4]			; zero the returned r3

        LDR     r3, [r1, #CSH_StreamFlags]
	AND	lr, r0, r3			; and out impossible bits in new stream vid/aud flags
	STR	lr, [r1, #CSH_NotReadyBits]     ; do before Video/Audio_ResetStreams, in case MPEGControl_Play is called soon after
        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_ResetStream
	STRVC	r2, [sp, #3*4]			; store in returned r2 slot
        Pull    "r1"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

	Push	"r1"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_ResetStream
	STRVC	r2, [sp, #4*4]			; store in returned r3 slot
	Pull	"r1"
        STRVS   r0, [sp]
        EXIT    VS
20
	MOV	r0, r1
	BL	coinit

        CLRV
        EXIT

; **************************************************************************
;
;       FreeBuffer - Call owner of buffer to free it
;
; in:   r1 -> buffer descriptor
;
; out:  -
;

FreeBuffer Entry "r0-r2,r12"
	LDR	r2, [r1, #BufferDescriptor_Length]
	MOV	r3, pc
	Push	r3
	ORR	lr, r3, #I_bit
	TEQP	lr, #0			; IRQs off

	ADR	lr, ControlStreamHandle
	LDR	r0, [lr, #CSH_DataReturned]
	ADD	r0, r0, r2
	STR	r0, [lr, #CSH_DataReturned]
	Pull	r3
	TEQP	r3, #0			; restore IRQ state

        LDR     r2, [r1, #BufferDescriptor_FreeRoutine]
        TEQ     r2, #0          ; check for SWI interface
        BEQ     %FT10

; routine interface

	LDR	r12, [r1, #BufferDescriptor_FreeWorkspace]	; setup workspace ptr
        MOV     r0, #3
        MOV     lr, pc
        MOV     pc, r2
        EXIT

; swi interface

10
        LDR     r2, [r1, #BufferDescriptor_FreeWorkspace]
        ORR     r2, r2, #&EF000000
        STR     r2, SWIInstruction +0
        MOV     r2, r1
	ADR	lr, ControlStreamHandle
	LDR	r0, [lr, #CSH_EndOfStreamReceived]	; will be 0 or 1
        MOV     r1, #0
        BL      %FT20
        EXIT

20
        Push    "lr"
        ADR     pc, SWIInstruction

; **************************************************************************
;
;       Coroutine stuff
;
; Entry parameters for coroutines:
;  r0-r4 are passed in
;  r5-r11 hold their value across calls
;
;       r0 = flags on entry to FullBuffers
;       r1 = control stream handle
;       r2 -> buffers
;       r3 -> start of first buffer's data (current position during call)
;       r4 -> end of first buffer's data
;
;       r5
;       r6
;       r7 holds return from getbyte, getnextstartcode
;       r8 remaining length of packet
;       r9
;       r10 video/audio selector for packet
;       r11 packet descriptor in preparation

 [ CoroutineStackCopied
ts_extendstackblock Entry "r0-r3"
	MOV	r3, r6				; number of excess bytes needed
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVEQ	r0, #ModHandReason_Claim	; if no block yet, then claim one
	MOVEQ	r3, #16*4			; of 16 words (should be enough)
	MOVNE	r0, #ModHandReason_ExtendBlock
	SWI	XOS_Module			; let's hope this never fails!
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	LDR	lr, [r1, #CSH_CoroutineStackBlockSize]
	ADD	lr, lr, r3			; increased block size
	STR	lr, [r1, #CSH_CoroutineStackBlockSize]
	EXIT
 ]

CallCoroutines Entry "r5-r11"
        STR     sp, [r1, #CSH_ExternalSP]
 [ CoroutineStackCopied
	LDR	r5, [r1, #CSH_CoroutineStackSize]
	TEQ	r5, #0
	LDRNE	r6, [r1, #CSH_CoroutineStackCopy]
	ADDNE	r6, r6, r5
10
	LDRNE	r7, [r6, #-4]!
	Push	r7, NE
	SUBNES	r5, r5, #4
	BNE	%BT10
 |
        LDR     sp, [r1, #CSH_InternalSP]
 ]
        EXIT

; cowait

cowait  ALTENTRY
 [ CoroutineStackCopied
	LDR	r5, [r1, #CSH_ExternalSP]
	SUB	r5, r5, sp			; how many bytes on coroutine stack
	STR	r5, [r1, #CSH_CoroutineStackSize]
	LDR	r6, [r1, #CSH_CoroutineStackBlockSize]
	SUBS	r6, r5, r6			; number of excess bytes
	BLHI	ts_extendstackblock
	LDR	r6, [r1, #CSH_CoroutineStackCopy]
10
	Pull	r7				; there's always at least one word (r5-r11 stacked)
	STR	r7, [r6], #4			; copy data into RMA block
	SUBS	r5, r5, #4
	BNE	%BT10
 |
        STR     sp, [r1, #CSH_InternalSP]       ; save internal stack pointer
        LDR     sp, [r1, #CSH_ExternalSP]
 ]
        EXIT

; coinit
;
; in:   r1 -> control stream handle
; out:  -
;

coinit  ALTENTRY                                ; must push same stuff as CoWait pulls
        STR     sp, [r1, #CSH_ExternalSP]
 [ :LNOT: CoroutineStackCopied
  [ UseSVCStack
        LDR     sp, =InternalStack
  |
        LDR     r3, =CSH_InternalStackEnd
        ADD     sp, r1, r3
  ]
 ]
        BL      cowait

; and when we come back, drop thru to...

	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_PassThroughToVideo
	BNE	PassThroughToVideo


 [ AutoABSDetect :LAND: :LNOT: OnlyAllowSystemStreams
        LDRB    r7, [r3, #0]                            ; if first byte = &FF, then audio-only file
        TEQ     r7, #&FF
        LDREQ   r10, [r1, #CSH_NotReadyBits]            ; it's audio-only, so don't make audio wait for video
        BICEQ   r10, r10, #StreamFlags_VideoPresent
        STREQ   r10, [r1, #CSH_NotReadyBits]
        MOVEQ   r10, #StreamFlags_AudioPresent          ; indicate all audio packets
        BEQ     allvidoraudloop
 ]

waitforstartcode
        BL      getnextstartcode
        CMP     r7, #&B9				; TMD 21-Jul-95 - changed to include end-of-stream code
 [ OnlyAllowSystemStreams
	BCC	waitforstartcode			; below &B9 are just video codes, so skip until we get system code
	B	notallvideo
 |
        BCS     notallvideo
 ]

        SUB     r3, r3, #4                              ; move pointer back to start of start code
                                                        ; (hopefully this won't cross block boundary!)
 [ ICLDebug
	Push	"r1,r3"
	LDR	r3, [r2, #BufferDescriptor_Start]
	SWI	XOS_WriteI+22
	SWI	XOS_WriteI+12
	MOV	r10, #0
00
	LDRB	r1, [r3, r10]
	BL	Tutu_Byte
	SWI	XOS_WriteI+32
	SWI	XOS_WriteI+32
	ADD	r10, r10, #1
	TEQ	r10, #64
	BNE	%BT00
	Pull	"r1,r3"
 ]

PassThroughToVideo
        LDR     r10, [r1, #CSH_NotReadyBits]            ; it's video-only, so don't make video wait for audio
        BIC     r10, r10, #StreamFlags_AudioPresent
        STR     r10, [r1, #CSH_NotReadyBits]

        MOV     r10, #StreamFlags_VideoPresent ; indicate all video packets
allvidoraudloop
        LDR     r0, [r1, #CSH_StreamFlags]
        TST     r0, r10
        BEQ     %FT10
05
        BL      GetPacketDescriptor
        MOV     r11, r0
        SUB     r7, r4, r3
        CMP     r7, #MaxMPEGPacketLength
        MOVHI   r7, #MaxMPEGPacketLength
        STR     r7, [r11, #PacketDescriptor_FullLength]
        MOV     lr, #PacketDescriptorFlags_MPEGStart
 [ GeneratePTSsForAudioOnly
	TEQ	r10, #StreamFlags_AudioPresent		; if an audio-only stream
	ORREQ	lr, lr, #PacketDescriptorFlags_PTSValid	; then generate a fake PTS of zero
        STR     lr, [r11, #PacketDescriptor_Flags]
	MOVEQ	lr, #0
	STREQ	lr, [r11, #PacketDescriptor_PTS+0]
	STREQ	lr, [r11, #PacketDescriptor_PTS+4]
 |
        STR     lr, [r11, #PacketDescriptor_Flags]
 ]
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer
        ADD     r7, r3, r7                              ; point at end of this packet
        BL      sendvidaudblock
        TEQ     r7, r4                                  ; have we got to end of buffer?
        MOVNE   r3, r7                                  ; if not, then move start
        BNE     %BT05                                   ; and create another packet
10
        BL      nextbuffer
        B       allvidoraudloop

notallvideo
        MOV     r10, #0                                 ; by default we're not interested in this packet
        TEQ     r7, #&E0                                ; if a video packet
        MOVEQ   r10, #StreamFlags_VideoPresent          ; then mark as such
        TEQ     r7, #&C0                                ; if audio packet
        MOVEQ   r10, #StreamFlags_AudioPresent          ; then mark as such
        LDR     r0, [r1, #CSH_StreamFlags]              ; load stream flags
        TST     r0, r10                                 ; if not a packet we're interested in
        BEQ     notvidaudpacket
        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_MPEGStart
        STR     r7, [r11, #PacketDescriptor_Flags]

        BL      getbyte                                 ; get bits 8-15 of length
        MOV     r8, r7
        BL      getbyte                                 ; get bits 0-7 of length
        ORR     r8, r7, r8, LSL #8                      ; r8 = length to go
skipstuffing
        BL      getbytedeccount
        TEQ     r7, #&FF
        BEQ     skipstuffing

        MOV     r9, r7, LSR #6
 [ SupportMPEG2PS
	TEQ	r9, #2					; if first byte starts '10' then MPEG2 PES packet
	BEQ	pespacket
 ]
        TEQ     r9, #1
        BNE     notSTD
        AND     r9, r7, #&3F                            ; get bottom 6 bits of 1st byte
        BL      getbytedeccount                         ; get 2nd byte of STD-buffer-scale+size
        ORR     r9, r7, r9, LSL #8                      ; merge bytes
        TST     r9, #&2000                              ; test STD_buffer_scale bit
        BICNE   r9, r9, #&2000                          ; if set, then knock it out
        MOVNE   r9, r9, LSL #10                         ; and value is in units of 1024 bytes
        MOVEQ   r9, r9, LSL #7                          ; else value is in units of 128 bytes
        STR     r9, [r11, #PacketDescriptor_BSn]        ; store BSn field
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_BSnValid ; set BSn valid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        BL      getbytedeccount                         ; get byte after
notSTD
        MOVS    r9, r7, LSR #4                          ; get top 4 bits of next byte, and put bit 3 into carry
        TEQ     r9, #2                                  ; check for PTS only (doesn't affect carry)
        BNE     notPTS                                  ; carry now holds bit 32 of PTS
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid  ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]

vidaudpacketcommon
        STR     r8, [r11, #PacketDescriptor_FullLength] ; save full length of MPEG packet data (ignoring buffer breaks)
 [ :LNOT: ErrorRecovery
        CMP     r8, #0                                  ; ** debugging **
        BLT     badfulllength
 ]
        TEQ     r3, r4                                  ; ensure we've got at least one byte to send
        BLEQ    nextbuffer
vidaudpacketcontinue
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      incrementpacketcount                    ; increment packet count for buffer

        CMP     r8, #0                                  ; negative length packet?
        BLT     badlength
        ADD     r7, r3, r8                              ; end of video packet (if it was all in this buffer)
        CMP     r7, r4                                  ; is it all within this buffer?
        BHI     notallinbuff

        BL      sendvidaudblock
        MOV     r3, r7                                  ; start from end of video block data
errorcontinue
        BL      getnextstartcodecheckloss
        B       notallvideo

 [ SupportMPEG2PS
pespacket
	BL	getbytedeccount				; get byte with PTS/DTS flags in
	MOV	r5, r7					; save for later
	BL	getbytedeccount				; get length of optional fields
	MOV	r6, r7					; save for later

	TST	r5, #PES_Optional_PTS_Present		; PTS present
	BEQ	pes_nopts
	BL	getbytedeccount				; get 1st byte of PTS
	BL	getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid  ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
	SUB	r6, r6, #5				; 5 bytes less of header

	TST	r5, #PES_Optional_DTS_Present
	BEQ	pes_nodts
	BL	getbytedeccount				; get 1st byte of DTS
	BL	getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_DTSValid  ; set DTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
	SUB	r6, r6, #5				; 5 bytes less of header
pes_nodts
pes_nopts
; Now skip rest of header
	SUB	r8, r8, r6				; deduct rest of header from packet payload length
	BL	skipbytes
	B	vidaudpacketcommon
 ]

 [ ErrorRecovery
badlength
        Push    "r0"
        MOV     r0, r11                                 ; r0 -> packet
        BL      FreePackets                             ; free it (possibly also freeing buffer)
	LDR	r0, [r1, #CSH_TooShortPackets]		; increment count of too-short packets
	ADD	r0, r0, #1
	STR	r0, [r1, #CSH_TooShortPackets]
        Pull    "r0"
        B       errorcontinue				; will typically cause a loss of sync too
 |
badlength
        SWI     XOS_WriteI + 22
        SWI     XOS_WriteI + 12
        DREG    r8, "Ctrl packet length = "
        SWI     XOS_ReadC
        MOV     pc, #0

badfulllength
        SWI     XOS_WriteI + 22
        SWI     XOS_WriteI + 12
        DREG    r8, "Ctrl packet full length = "
        SWI     XOS_ReadC
        MOV     pc, #0
 ]

notallinbuff
        SUB     r8, r7, r4                              ; r8 = amount of excess
        MOV     r7, r4
        BL      sendvidaudblock                         ; send this amount
        BL      nextbuffer

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_Flags]
        STR     r7, [r11, #PacketDescriptor_FullLength]
        B       vidaudpacketcontinue

notPTS
        TEQ     r9, #3
        BNE     vidaudpacketcommon                      ; not PTS+DTS, so must be plain
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}

        BL      getbytedeccount                         ; get first byte of DTS, with %0001 at front
        BL      getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}

        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid :OR: PacketDescriptorFlags_DTSValid
                                                        ; set PTSValid + DTSValid bits in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        B       vidaudpacketcommon

; This routine gets a 33-bit PTS, DTS or SCR from the stream
;
; in:   r7 = first byte (including bits 32..30)
; out:  r7 = low 32 bits
;       r9 = bit 32 in bit 0

getclockreference ROUT
        Push    "lr"
        AND     r7, r7, #&0E                            ; extract bits 3..1
        MOV     r9, r7, LSR #3                          ; r9 = bit 32 in bit 0
        Push    "r9"                                    ; save for later
        MOV     r9, r7, LSL #31-2                       ; r9 = bits 31,30
        BL      getbytedeccount                         ; get bits 29..22 in bits 7..0
        ORR     r9, r9, r7, LSL #22                     ; r9 = bits 31..22
        BL      getbytedeccount                         ; get bits 21..15 in bits 7..1
        MOV     r7, r7, LSR #1
        ORR     r9, r9, r7, LSL #15                     ; r1 = bits 31..15
        BL      getbytedeccount                         ; get bits 14..7 in bits 7..0
        ORR     r9, r9, r7, LSL #7                      ; r1 = bits 31..7
        BL      getbytedeccount                         ; get bits 6..0 in bits 7..1
        ORR     r7, r9, r7, LSR #1                      ; r9 = bits 31..0
        Pull    "r9, pc"

incrementpacketcount Entry "r0"
        MOV     r0, pc
        ORR     lr, r0, #I_bit                          ; disable IRQs
        TEQP    lr, #0

        LDR     lr, [r2, #BufferDescriptor_Packets]
        ADD     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        TEQP    r0, #0                                  ; restore IRQ state
        EXIT

notvidaudpacket
        CMP     r7, #&BC                ; is it a packet header
        BCS     packettoskip
 [ SendFirstSCR
	ASSERT	:LNOT: SupportMPEG2PS	; can't handle MPEG2PS pack headers yet
        TEQ     r7, #&BA                ; is it a pack header
        BNE     %FT20                   ; no, then nothing to do
        LDR     r7, [r1, #CSH_SendNextSCR]
        TEQ     r7, #0                  ; should we send it
        BEQ     %FT20                   ; [no, cos we've already sent one, or there's no video active]
        MOV     r7, #0
        STR     r7, [r1, #CSH_SendNextSCR] ; don't send any more

        BL      getbyte                 ; get bits 32..30 in bits 3..1
        BL      getclockreference
        Push    "r0-r2"

        DREG    r7, "Low SCR = "
        DREG    r9, "High SCR = "

        MOV     r0, #0
        MOV     r1, r7
        MOV     r2, r9
        SWI     XMPEGVideo_SetSCR

        MOV     r0, #&03500000
        LDR     r1, =&400000FF
        STR     r1, [r0]

        Pull    "r0-r2"
20
 ]
	TEQ	r7, #&B9				; is it end-of-stream marker
	MOVEQ	lr, #1
	STREQ	lr, [r1, #CSH_EndOfStreamReceived]	; indicate we've received end-of-stream marker

        BL      getnextstartcode
        B       notallvideo

        LTORG

packettoskip
        BL      getbyte                 ; get bits 8-15 of length
        MOV     r6, r7
        BL      getbyte                 ; get bits 0-7 of length
        ORR     r6, r7, r6, LSL #8      ; r6 = length to go

	BL	skipbytes
        BL      getnextstartcodecheckloss
        B       notallvideo

getnextstartcodecheckloss Entry
	BL	getnextstartcode
	TEQ	r8, #0			; did we find the next start code straight after
	LDRNE	r8, [r1, #CSH_SyncLosses] ; if not, increment no. of sync losses
	ADDNE	r8, r8, #1
	STRNE	r8, [r1, #CSH_SyncLosses]
	EXIT

skipbytes Entry
10
        ADD     r3, r3, r6              ; end of packet (if it was all in this buffer)
        CMP     r3, r4                  ; is it all within this buffer?
	EXIT	CC

        SUB     r6, r3, r4              ; r6 = amount of excess
        BL      nextbuffer
        B       %BT10

; getnextstartcode searches for the next start code (ie 2 or more 00 bytes followed by 01 xx)
; On exit:
;	r7 = xx code
;	r8 = 0 => found the start code as first thing
;	     1 => found other stuff first

getnextstartcode
        Push    "lr"
	MOVS	r8, #0			; indicate we found start code straight away (NB may be
					; more than two leading 00 bytes, but this is valid)
getnextstartcodeloop
	MOVNE	r8, #1			; don't execute this first time thru, but all branches
					; to here are with NE set, so indicate didn't find start code
					; straight away
        BL      getbyte                 ; look for 1st zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
        BL      getbyte                 ; look for 2nd zero of start code
        TEQ     r7, #0
        BNE     getnextstartcodeloop
gottwozeros
        BL      getbyte                 ; look for "1" of start code
        CMP     r7, #1
        BCC     gottwozeros             ; if 3rd zero, then not start code, but we've got two zeros
        BNE     getnextstartcodeloop    ; not zero or one, so look for 1st zero again
        BL      getbyte                 ; get start code reason
        Pull    "pc"

getbytedeccount
        SUB     r8, r8, #1              ; decrement count of bytes remaining
getbyte
        CMP     r3, r4
        LDRCCB  r7, [r3], #1
        MOVCC   pc, r14

        Push    "lr"
        BL      nextbuffer
        Pull    "lr"
        B       getbyte

 [ {TRUE}
nextbuffer *    cowait
 |
nextbuffer
        LDR     r2, [r2, #BufferDescriptor_Link]        ; go onto next buffer being added
        TEQ     r2, #0                                  ; if there is one, then
        LDRNE   r3, [r2, #BufferDescriptor_Start]       ; load start address
        LDRNE   r4, [r2, #BufferDescriptor_Length]      ; load length
        ADDNE   r4, r3, r4                              ; convert to end address
        MOVNE   pc, lr
        B       cowait                                  ; else wait for another buffer
 ]

; **************************************************************************
;
;       sendvidaudblock - send block of video/audio data
;
; in:
;       r1 = control stream handle
;       (r2 -> buffer descriptor)
;       r3 -> start of block to send (not necessarily start of buffer))
;       (r4 -> end of buffer)
;       r7 -> end of block to send (+1))
;       r10 = start code for video or audio packet so we know which
;       r11 -> packet descriptor (filled in apart from Length field)

sendvidaudblock Entry "r0-r2"
        SUB     r0, r7, r3
        STR     r0, [r11, #PacketDescriptor_Length]
        MOV     r0, #0                  ; flags for MPEGVideo/Audio_FullPackets
        MOV     r2, r11
        TEQ     r10, #StreamFlags_VideoPresent
        BNE     sendaudioblock

; drop thru to...

debug SETL {FALSE}

sendvideoblock
        DLine   "Video packet"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_FullPackets
        DLine   "Exiting video packet"
        CLRV
        EXIT

sendaudioblock
        DLine   "Audio packet"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_FullPackets
        DLine   "Exiting audio packet"
        CLRV
        EXIT

debug SETL {FALSE}

; **************************************************************************
;
;       GetPacketDescriptor - Get a packet descriptor from free list, or RMA if that fails
;
; in:   r12 -> module workspace
;
; out:  r0 -> packet descriptor
;

GetPacketDescriptor Entry "r1"
        MOV     r1, pc
        ORR     lr, r1, #I_bit                  ; disable IRQs

        LDR     r0, FreePacketListHeadPtr
        TEQ     r0, #0
        BEQ     %FT10                           ; [no free packet descriptors]

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, FreePacketListHeadPtr       ; update FreePacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, FreePacketListTailPtr       ; then zero FreePacketListTailPtr

        TEQP    r1, #0                          ; restore IRQs
05
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
; now fill in some of the fields
        ADRL    r1, FreePackets
        STR     r1, [r0, #PacketDescriptor_FreeRoutine]
        STR     wp, [r0, #PacketDescriptor_FreeWorkspace]
        CLRV
        EXIT

10
        TEQP    r1, #0                          ; restore IRQ state
        Push    "r2, r3"
        MOV     r3, #PacketDescriptorSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVC   r0, r2
        Pull    "r2, r3"
        BVC     %BT05
        EXIT

; **************************************************************************
;
;	Stats - Entry point for MPEGControl_Stats - return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = control stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

; In contrast to the implementations in the elementary modules, the MPEGControl items
; are either the offset from the *stream handle* to the value (if positive), or the negation
; of the code offset into the module if a routine (if negative)
; Unfortunately, you can't use :BASE: with an absolute item (eg the CSH_ values), so
; we have to have an explicit flag on the macro.

	MACRO
	StatsTableEntry	$tag, $value, $codeP
 [ "$codeP"=""
	&	$tag, :INDEX: ($value)
 |
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

Stats	Entry "r0-r2, r5-r6"

; First call video and audio to output their stuff

	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_VideoStreamHandle]
	SWI	XMPEGVideo_Stats
	LDMIA	sp, {r0,r1}			; reload flags + control handle
	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
	SWI	XMPEGAudio_Stats

; Note: r3 and r4 will have been updated after those

	LDMIA	sp, {r0,r1}			; reload flags + control handle again
	TEQ	r1, #0				; if no handle specified
	ADREQ	r1, ControlStreamHandle		; then use global one

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	BEQ	%FT90				; then exit

	ADR	r6, StatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [r1, lr]			; NB: relative to handle, not wp
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

; done all tags

90
	CMP	r4, #0				; if remaining space in buffer is >=0, then V:=0
	EXIT	PL				; and exit

	ADR	r0, BufferOverflowError		; else return an error
	STR	r0, [sp]
	SETV
	EXIT

BufferOverflowError
	&	0
	=	"Buffer overflow", 0
	ALIGN

; The statistics that are done by routine:
; (must come before StatsTable so not forward reference)

Stats_InTime Entry
	LDR	r6, [r1, #CSH_LastTime]		; lasttime - starttime
	LDR	lr, [r1, #CSH_StartTime]
	SUB	r6, r6, lr
	EXIT

Stats_SkippingAfterReset Entry
	LDR	r6, [r1, #CSH_StreamFlags]
	ANDS	r6, r6, #StreamFlags_SkippingAfterReset
	MOVNE	r6, #1
	EXIT

; The table containing all the statistics

StatsTable
	StatsTableEntry &0000, CSH_DataReceived
	StatsTableEntry &0001, Stats_InTime, Code
 [ {FALSE} ; only apply to TS
  [ SkipToSeqOnResetStream
	StatsTableEntry &0002, Stats_SkippingAfterReset, Code
  ]
	StatsTableEntry &0003, CSH_PMT_PID
	StatsTableEntry &0004, CSH_Video_PID
	StatsTableEntry &0005, CSH_Audio_PID
 ]
	StatsTableEntry &0006, CSH_DataReturned
	&	-1

; **************************************************************************
;
;       (Sys)CtrlInfo_Code - Code to handle (Sys)CtrlInfo command
;
; in:   -
; out:  -

 [ BuildAsMPEGControl
CtrlInfo_Code Entry
 |
SysCtrlInfo_Code Entry
 ]
        LDR     wp, [r12]
        ADR     r1, ControlStreamHandle

        DLINE   "Bytes received = ", cc

        LDR     r0, [r1, #CSH_DataReceived]
        BL      DecimalOutput
        DLINE   ""
        MOV     r2, r0

        DLINE   "In time ", cc
        LDR     r0, [r1, #CSH_LastTime]
        LDR     r3, [r1, #CSH_StartTime]
        SUB     r0, r0, r3
        BL      DecimalOutput
        DLINE   " cs"

        TEQ     r0, #0
        BEQ     %FT10

; we want to perform (bytes*100)/cs, but bytes*100 might overflow 32 bits
; so we do bytes/cs then multiply fractional part by 100 and add on

        DivRem  r3, r2, r0, r4
        MOV     r4, #100
        MUL     r2, r4, r2              ; multiply fractional part by 100
        DivRem  r5, r2, r0, r14         ; and divide by denominator
        Push    "r0"                    ; save amount of time for later
        MLA     r0, r3, r4, r5          ; add on original value*100
        DLINE   "Average data rate = ", cc
        BL      DecimalOutput
        DLINE   " bytes/second"
        Pull    "r0"
 [ DataRateStats
; r0 = number of centiseconds since starting

        LDR     lr, =DataCountPeriod*100
        DivRem  r2, r0, lr, r3          ; r2 = number of periods since starting
        CMP     r2, #DataCountArraySize ; if filled array
        MOVHI   r2, #DataCountArraySize ; then pretend we just filled it
        ADD     r3, r1, #CSH_DataCounts
        MOV     r4, #0                  ; period number
05
        TEQ     r4, r2                  ; if no more periods
        BEQ     %FT10                   ; then finished
        DLINE   "In period ", cc
        MOV     r0, r4
        BL      DecimalOutput
        DLINE   ", average data rate was ", cc
        LDR     r5, [r3], #4
        LDR     lr, =DataCountPeriod
        DivRem  r0, r5, lr, r6          ; convert from bytes/minute to bytes/second
        BL      DecimalOutput
        DLINE   " bytes/second"
        ADD     r4, r4, #1
        B       %BT05
 ]
10
        DLINE   "Bytes returned = ", cc

        LDR     r0, [r1, #CSH_DataReturned]
        BL      DecimalOutput
        DLINE   ""

	DLINE	"Number of sync losses = ", cc
	LDR	r0, [r1, #CSH_SyncLosses]
	BL	DecimalOutput
	DLINE	""

	DLINE	"Number of short packets = ", cc
	LDR	r0, [r1, #CSH_TooShortPackets]
	BL	DecimalOutput
	DLINE	""

        CLRV
        EXIT

        LTORG

; **************************************************************************
;
;       DecimalOutput - Decimal output routine
;
; in:   r0 = value to be output
; out:  -

DecimalOutput Entry "r0-r2",16
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        SWI     XOS_Write0
        EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END
