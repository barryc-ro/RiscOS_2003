/******	AudGeneric.h *******************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Generic version of audio handling

Copyright 2001 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
10/10/2001	BJGA	Created

***************************************************************************/

#ifdef GENERIC

#ifndef __audgeneric_h
#define __audgeneric_h

/* Includes */

#include <stdbool.h>
#include "kernel.h"

#include "Clk.h"
#include "Types.h"

/* Public types */

typedef struct
{
  /* COMMON */
  /* Would be implemented in each protocol module in a real PRISM system */
  
  /* establish(): stream initialisation (only called on OpenStream) */
  /*   in:     flags:        reserved, mbz */
  /*           handle:       top-level module's handle for this dialogue (= audio stream handle, for now) */
  /*   out:                  error pointer if stream could not be opened */
  /*           session_id:   protocol module's session identifier (its own handle for this dialogue) */
  _kernel_oserror * (*establish) (unsigned int flags, void *handle, void **session_id);
  
  /* annul(): stream finalisation (only called on CloseStream) */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer if stream could not be closed */
  _kernel_oserror * (*annul) (unsigned int flags, void *session_id);
  
  /* commence() : stream segment initialisation (called on OpenStream and ResetStream) */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer if stream could not be opened */
  _kernel_oserror * (*commence) (unsigned int flags, void *session_id);
  
  /* discontinue() : stream segment finalisation (called on ResetStream and CloseStream) */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer if stream could not be closed */
  _kernel_oserror * (*discontinue) (unsigned int flags, void *session_id);
  
  /* readsysteminfo() : return hardware/driver/codec information */
  /*   in:     tag:          0 => return pointer to hardware/codec name and version */
  /*                         1 => return hardware/codec version as unsigned int */
  /*                         2 => return pointer to driver/implementation name and version */
  /*                         3 => return driver/implementation version as unsigned int */
  /*                         etc  */
  /*   out:                  error pointer */
  _kernel_oserror * (*readsysteminfo) (unsigned int tag, unsigned int *result);
  
  
  /* DECODER PROTOCOL MODULES */
  
  /* dataavailable() : notification that data has arrived in a hitherto empty buffer */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer */
  _kernel_oserror * (*dataavailable) (unsigned int flags, void *session_id);
  
  /* consumedata() : accept contiguous data block (called multiple times in response to givemedata()) */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*           start/length: definition of data block */
  /*   out:                  error pointer if operation was aborted */
  /*           not_consumed: number of bytes that could not be accepted at this time (nonzero values will prevent further consumedata() calls until the next givemedata() call) */
  _kernel_oserror * (*consumedata) (unsigned int flags, void *session_id, const unsigned char *start, unsigned int length, unsigned int *not_consumed);
  
  /* readfullness() : return amount of data currently buffered */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer */
  /*           occupancy:    "private" (typically hardware) buffer occupancy (bytes) */
  _kernel_oserror * (*readfullness) (unsigned int flags, void *session_id, unsigned int *occupancy);
  
  
  /* SCHEDULER PROTOCOL MODULES */
  
  /* start() : enable decoding/display */
  /*   in:     flags:        bit 0 set => decode data in reverse, bit 0 clear => decode data forwards */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer */
  _kernel_oserror * (*start) (unsigned int flags, void *session_id);
  
  /* stop() : disable decoding/display */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer */
  _kernel_oserror * (*stop) (unsigned int flags, void *session_id);
  
    /* FUNCTIONS PROVIDED ONLY BY STREAM DECODERS */
    
      /* setclock() : set decoder's time - used only initially when audio is time master, used repeatedly when audio clock is slaved */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*           time:         current STC value */
      /*   out:                  error pointer */
      _kernel_oserror * (*setclock) (unsigned int flags, void *session_id, clk time);
      
      /* speed() : set decoding slow-down factor */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*           factor:       0=pause, 1=normal speed, >1=reciprocal of slow-motion speed */
      /*   out:                  error pointer */
      _kernel_oserror * (*speed) (unsigned int flags, void *session_id, unsigned int factor);
      
      /* fast() : skip next frame, or speed up presentation */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*   out:                  error pointer */
      _kernel_oserror * (*fast) (unsigned int flags, void *session_id);
      
      /* slow() : repeat next frame or slow down presentation */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*   out:                  error pointer */
      _kernel_oserror * (*slow) (unsigned int flags, void *session_id);
      
      /* normal() : return to normal presentation speed (if applicable) */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*   out:                  error pointer */
      _kernel_oserror * (*normal) (unsigned int flags, void *session_id);
    
    /* FUNCTIONS ONLY PROVIDED BY STEP DECODERS */
    
      /* proceed() : step to next frame, possibly skipping one or more */
      /* (also triggers a decode) */
      /*   in:     flags:        reserved, mbz */
      /*           session_id:   protocol module's session identifier */
      /*           frames:       number of frames to move forward by (usually 1, 2 would be */
      /*                         used for a synchronsiation frame skip, higher numbers might */
      /*                         be used for fast forward someday) */
      /*   out:                  error pointer */
      _kernel_oserror * (*proceed) (unsigned int flags, void *session_id, unsigned int frames);
  
  
  /* PRESENTATION PROTOCOL MODULES */
  
  /* volume() : set left/right volume/muting */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*           left/right:   0=mute, 1=-127.5 dB, 2=-127.0 dB ... 256=0 dB */
  /*                         if hardware cannot scale output, all nonzero values = unmuted */
  /*                         if hardware cannot scale left/right independently, scale both to average */
  /*   out:                  error pointer */
  _kernel_oserror * (*volume) (unsigned int flags, void *session_id, unsigned int left, unsigned int right);
  
  /* downmix() : control downmixing in dual/karaoke mode */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*           mode:         0 = channel 1 (or V1) on left, channel 2 (or V2) on right */
  /*                         1 = channel 1 (or V1) on both left and right */
  /*                         2 = channel 2 (or V2) on both left and right */
  /*                         3 = neither channel output */
  /*   out:                  error pointer */
  _kernel_oserror * (*downmix) (unsigned int flags, void *session_id, unsigned int mode);
  
  /* spdif() : control S/PDIF transmitter */
  /*   in:     flags:        bit 0 set => output PCM downmix rather than coded bitstream */
  /*           session_id:   protocol module's session identifier */
  /*   out:                  error pointer */
  _kernel_oserror * (*spdif) (unsigned int flags, void *session_id);
  
  /* readstreaminfo() : return stream information */
  /*   in:     flags:        reserved, mbz */
  /*           session_id:   protocol module's session identifier */
  /*           tag:          0 => return pointer to full encoding name (eg "MPEG-1 Layer II") */
  /*                         1 => return pointer to short encoding name (eg "MPEG-1") */
  /*                         2 => return sampling rate in Hz */
  /*                         3 => return bitrate in bits/s */
  /*                         4 => return number of main channels */
  /*                         5 => return number of surround channels */
  /*                         6 => return number of LFE channels */
  /*                         7 => return 1 if downmix options available (dual mono / karaoke) */
  /*                         8 => return 1 if copyrighted, else 0 */
  /*                         9 => return 1 if original, 0 if copy */
  /*                         etc (need a way to add things unique to particular coding scheme) */
  /*   out:                  error pointer */
  _kernel_oserror * (*readstreaminfo) (void *session_id, unsigned int tag, unsigned int *result);
}
protocol_fns_t;

typedef struct
{
  /* CALLS ANY TOP LEVEL MODULE (although flag bit definitions would differ) */
  
  /* registerme() : protocol module registration */
  /*   in:     flags:        bit 0 clear = MPEG audio, bit 0 set = AC-3 audio */
  /*                         bit 1 set => step decoder, else stream decoder */
  /*           me:           pointer to list of functions in this protocol module */
  /*   out:                  error pointer */
  _kernel_oserror * (*registerme) (unsigned int flags, protocol_fns_t *me);
  
  /* deregisterme(): protocol module deregistration */
  /*   in:     flags:        as for registerme() */
  /*           me:           as for registerme() */
  /*   out:                  error pointer */
  _kernel_oserror * (*deregisterme) (unsigned int flags, protocol_fns_t *me);
}
common_toplevel_fns_t;

typedef struct
{
  /* howmuchdata() : enquire how much data is available to be stuffed */
  /*   in:     flags:        reserved, mbz */
  /*           handle:       top-level module's dialogue handle */
  /*           max:          the maximum amount we're interested in hearing about, or 0 to return the total amount */
  /*   out:                  error pointer */
  /*           bytes:        number of bytes available for stuffing (excluding PES headers) */
  _kernel_oserror * (*howmuchdata) (unsigned int flags, void *handle, unsigned int max, unsigned int *bytes);
  
  /* givemedata() : request for stuffing */
  /*   in:     flags:        bit 0 set => wrap data in PES packets, bit 0 clear => no PES wrapping (implies no timestamps conveyed!) */
  /*           handle:       top-level module's dialogue handle */
  /*   out:                  error pointer */
  _kernel_oserror * (*givemedata) (unsigned int flags, void *handle);
}
buffer_fns_t;

typedef struct
{
  /* pts() : PTS being presented */
  /*   in:     flags:        reserved, mbz */
  /*           handle:       top-level module's dialogue handle */
  /*   out:                  error pointer */
  _kernel_oserror * (*pts) (unsigned int flags, void *handle, clk PTS);
  
  /* underrun() : decoding has underrun */
  /*   in:     flags:        reserved, mbz */
  /*           handle:       top-level module's dialogue handle */
  /*   out:                  error pointer */
  _kernel_oserror * (*underrun) (unsigned int flags, void *handle);
}
scheduler_fns_t;

typedef struct
{
  /* streaminfochanging(): stream information has been initialised or updated (new values have effect from next presentation unit) */
  /*   in:     flags:        reserved, mbz */
  /*           handle:       top-level module's dialogue handle */
  /*   out:                  error pointer */
  _kernel_oserror * (*streaminfochanging) (unsigned int flags, void *handle);
}
presentation_fns_t;

typedef struct
{
  /* streamrecognised(): stream type positively or negatively identified */
  /*   in:     flags:        bit 0 set => positive rather than negative identification */
  /*           handle:       top-level module's dialogue handle */
  /*   out:                  error pointer */
  _kernel_oserror * (*streamrecognised) (unsigned int flags, void *handle);
}
recogniser_fns_t;

/* Public prototypes */

extern _kernel_oserror *AudGeneric_Initialise (bool *use);
extern _kernel_oserror *AudGeneric_Finalise (void);

extern _kernel_oserror *AudGeneric_SWIOpenStream (stream_flags_t *flags, control_stream_handle_t csh, audio_parameters_structure_t *aps, stream_handle_t *return_ash);
extern _kernel_oserror *AudGeneric_SWIFullPackets (unsigned int type, unsigned int flags, stream_handle_t ash, bitstream_packet_t *packets);
extern _kernel_oserror *AudGeneric_SWICloseStream (unsigned int flags, stream_handle_t ash);
extern _kernel_oserror *AudGeneric_SWIPlay (unsigned int flags, stream_handle_t ash);
extern _kernel_oserror *AudGeneric_SWISetSpeed (unsigned int flags, stream_handle_t ash, unsigned int speed);
extern _kernel_oserror *AudGeneric_SWIResetStream (reset_stream_flags_t *flags, stream_handle_t ash, unsigned int *return_discarded_data_size);
extern _kernel_oserror *AudGeneric_SWIMuteSound (unsigned int flags, stream_handle_t ash);
extern _kernel_oserror *AudGeneric_SWISoundVolume (unsigned int flags, stream_handle_t ash, int volume, int *return_old_volume);
extern _kernel_oserror *AudGeneric_SWIStats (unsigned int flags, stream_handle_t ash, unsigned int *tags, void *buffer, int buffer_size, void **return_pointer, int *return_buffer_remaining);
extern _kernel_oserror *AudGeneric_SWISetAudioParameters0 (stream_handle_t ash, int new_state, int *return_old_state);
extern _kernel_oserror *AudGeneric_SWISetAudioParameters1 (stream_handle_t ash, dual_channel_specifier new_state, dual_channel_specifier *return_old_state, audio_channel_type *return_channel_type);
extern _kernel_oserror *AudGeneric_SWISetAudioParameters2 (stream_handle_t ash, int new_state, int *return_old_state);

#endif

#endif
