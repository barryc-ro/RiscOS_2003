; /****** ZoranPara.s ********************************************************
;
; Project:	STB-400
; Component:	MPEGDriver
; This file:	Code to manage the interface between the ARM and the Zoran
;		in the case of a PS/2 / parallel port dongle
;
; Copyright 2001 Pace Micro Technology plc. All rights reserved.
;
; This material is the confidential trade secret and proprietary information
; of Pace Micro Technology plc. It may not be reproduced, used, sold, or
; transferred to any third party without the prior written consent of
; Pace Micro Technology plc.
;
; History:
; Date		Who	Change
; ----------------------------------------------------------------------------
; 15/08/2001	BJGA	Created
;
; ***************************************************************************/


 [ :DEF: Generic

; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>
        GET     Hdr:Proc
        GET     Hdr:IO.IOMD
        GET     Hdr:DevNos
        GET     Hdr:Parallel
        GET     Hdr:HighFSI
        GET     Hdr:IIC
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:MsgTrans
        GET     Hdr:ModHand
        GET     hdr.Debug
        GET     VersionASM


; I²C address of Zoran chip

zr38601_i2c_addr *      &30

; FIFO size
fifo_size       *       256

; Address of IRQ semaphore
IRQsema         *       &108

; Offsets from parallel hardware base address
                ^       0
pp_data         #       4
pp_stat         #       4
pp_ctrl         #       4

; Bits in parallel status and control registers

pp_stat_notbusy         * 1:SHL:7
pp_stat_ack             * 1:SHL:6
pp_stat_pe              * 1:SHL:5
pp_stat_slct            * 1:SHL:4
pp_stat_error           * 1:SHL:3

pp_ctrl_dir             * 1:SHL:5
pp_ctrl_irqen           * 1:SHL:4
pp_ctrl_slctin          * 1:SHL:3
pp_ctrl_init            * 1:SHL:2
pp_ctrl_autofd          * 1:SHL:1
pp_ctrl_strobe          * 1:SHL:0

; Layout of zoran_interface_t C struct
                        ^       0
Interface_Command       #       4
Interface_UnmaskIRQ     #       4
Interface_MaskIRQ       #       4
Interface_ConsumeData   #       4
Interface_TopLevel      #       4
Interface_Buffer        #       4
Interface_Scheduler     #       4
Interface_Presentation  #       4
Interface_TopLevelHandle #      4
Interface_Clock         #       4
Interface_ClockHandle   #       4
Interface_Characteriser #       4
Interface_CharacteriserHandle # 4
Interface_Link          #       4
Interface_HowMuchData   #       4
Interface_GiveMeData    #       4
Interface_Flags         #       4
Interface_CharacterisationPTS # 8
Interface_OldPTC        #       4
Interface_OldPTCErr     #       4
Interface_STCRetestHoldoff #    4
Interface_BlockQueueHead #      4
Interface_BlockQueueTail #      4
Interface_PRISMID       #       4
Interface_FunctionDescriptorTable # 4
Interface_FunctionDescriptorTableSize # 4
Interface_Veneers       #       4
Interface_HWInfoPrototype #     4
Interface_HWInfo        #       4
Interface_RomVersion    #       4
Interface_DriverInfoPrototype # 4
Interface_DriverInfo    #       4
Interface_ShortInfo     #       4
InterfaceSize           *       :INDEX: @

InterfaceFlags_AC3NotMPA                        *       1 :SHL: 0
InterfaceFlags_Characterising                   *       1 :SHL: 1
InterfaceFlags_ReceivingCharacterisationData    *       1 :SHL: 2
InterfaceFlags_Started                          *       1 :SHL: 3
InterfaceFlags_CharacterisationPTSValid         *       1 :SHL: 4
InterfaceFlags_ClockSessionBegun                *       1 :SHL: 5
InterfaceFlags_SyncMaster                       *       1 :SHL: 6
InterfaceFlags_OldPTCValid                      *       1 :SHL: 7
InterfaceFlags_OldPTCErrValid                   *       1 :SHL: 8
InterfaceFlags_Resetting                        *       1 :SHL: 9
InterfaceFlags_IRQSincePoll                     *       1 :SHL: 10
InterfaceFlags_DongleFitted                     *       1 :SHL: 31 ; private flag

; Layout of common_toplevel_fns_t C struct
                        ^       0
TopLevel_RegisterMe     #       4
TopLevel_DeregisterMe   #       4

; Layout of buffer_fns_t C struct
                        ^       0
Buffer_HowMuchData      #       4
Buffer_GiveMeData       #       4


        IMPORT  Mess_GenerateError
        IMPORT  Zoran_Init
        IMPORT  Zoran_Final
        IMPORT  Zoran_ComponentInfo
        IMPORT  Zoran_ClockCorrection
        IMPORT  Zoran_SpeedChange
        IMPORT  Zoran_ActivateSyncControl
        IMPORT  Zoran_GetBufferLength
        IMPORT  Zoran_AdjustRate
        IMPORT  Zoran_EstablishMPA
        IMPORT  Zoran_EstablishAC3
        IMPORT  Zoran_Annul
        IMPORT  Zoran_Commence
        IMPORT  Zoran_Discontinue
        IMPORT  Zoran_DataAvailable
        IMPORT  Zoran_ConsumeData
        IMPORT  Zoran_ReadFullness
        IMPORT  Zoran_Start
        IMPORT  Zoran_Stop
        IMPORT  Zoran_Volume
        IMPORT  Zoran_Downmix
        IMPORT  Zoran_SPDIF
        IMPORT  Zoran_ReadStreamInfo
        IMPORT  Zoran_Peek
        IMPORT  Zoran_Poke
        IMPORT  Zoran_VCXO


        AREA    |Asm$$Code|, CODE, READONLY


; Exported functions
; ------------------


; These are the protocol_fns_t structs that we register with AudGeneric

ProtocolFunctions_MPEG
        DCD     ZoranPara_ComponentInfo
        DCD     ZoranPara_EstablishMPA
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo

ProtocolFunctions_AC3
        DCD     ZoranPara_ComponentInfo
        DCD     ZoranPara_EstablishAC3
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo


; extern _kernel_oserror *ZoranPara_Init (common_toplevel_fns_t *toplevel, buffer_fns_t *buffer, scheduler_fns_t *scheduler, const presentation_fns_t *presentation);

        EXPORT  ZoranPara_Init
ZoranPara_Init
        FunctionEntry "v1,v2"
        StaticBaseFromSL ip

        ; Cache callback function pointer tables in our interface struct
        ADRVar  lr, ip, Interface
        STR     a1, [lr, #Interface_TopLevel]
        MOV     v1, a1                  ; useful later in this function
        STR     a2, [lr, #Interface_Buffer]
        STR     a3, [lr, #Interface_Scheduler]
        STR     a4, [lr, #Interface_Presentation]

        MOV     a1, #0
        STRVar  a1, ip, InUseSemaphore, lr

        ; Internationalise the IIC NoAck message
        SUB     sp, sp, #4*4
        MOV     r0, sp
        ADRL    r1, IICMessagesFile
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        ADRL    r0, ErrorBlock_IIC_NoAcknowledge
        MOV     r1, sp
        ADRVar  r2, ip, IICNoAckError
        MOV     r3, #256
        SWI     XMessageTrans_ErrorLookup
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
        ADD     sp, sp, #4*4

        ; Cache parallel hardware address, so we don't have to do a SWI each time we need it
        SWI     XParallel_HardwareAddress
        Return  "v1,v2",, VS
        STRVar  a1, ip, ParallelHardwareAddress, lr

        ; Disable keyboard port
        MOV     a4, #IOMD_Base
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a1, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRB    a1, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        AND     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRVar  a2, ip, OldKeyboardIRQBits, a1

        LDRB    a2, [a4, #IOMD_KBDCR]
        AND     a2, a2, #IOMD_KBDCR_Enable    ; no way to read the state of the other control bits
        STRVar  a2, ip, OldKeyboardEnable, a1 ; so just assume they were clear
        MOV     a1, #0                  ; clear state machine
        STRB    a1, [a4, #IOMD_KBDCR]
        MOV     a1, #2                  ; wait for state tick
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        MOV     a1, #IOMD_KBDCR_Enable  ; reenable state machine
        STRB    a1, [a4, #IOMD_KBDCR]
        MOV     a1, #2                  ; wait for state tick
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        MOV     a1, #&FF                ; PS/2 reset command
        STRB    a1, [a4, #IOCSERTX]
        LDR     a1, =34000              ; Zzzzzzzzzzzzzzzzzzzzzzz.....
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        LDRB    a1, [a4, #IOMD_KBDCR]
        TST     a1, #IOMD_KBDCR_RxF     ; have we recived an ack from a genuine PS/2 device?
        MOVNE   a1, #0                  ; no, so exit without error, without registering
        BNE     %FT96
        MOV     a1, #0                  ; start in printer mode, I²C data high
        STRB    a1, [a4, #IOMD_KBDCR]

        ; Set up interfaces so we can talk to the Zoran chip
        BL      ActivateDongle
        TEQ     a1, #0
        BEQ     %FT30
        ADRVar  a2, ip, IICNoAckError
        TEQ     a1, a2                  ; if Zoran not detected,
        MOVEQ   a1, #0                  ;   then swallow error
        B       %FT95                   ; don't register our services either way
30      MOV     a1, #InterfaceFlags_DongleFitted
        ADRVar  a2, ip, Interface
        STR     a1, [a2, #Interface_Flags]

        ; Reset the Zoran chip
        MOV     a1, #0                  ; data lines must start all zero
        STRVar  a1, ip, SoftCopyData, lr
        LDRVar  v2, ip, SoftCopyCtrl
        BIC     a2, v2, #pp_ctrl_irqen :OR: pp_ctrl_init
        LDR     lr, ParallelHardwareAddress_Indirect
        LDR     ip, [ip, lr]            ; ip = ParallelHardwareAddress
        STRB    a1, [ip, #pp_data]
        STRB    a2, [ip, #pp_ctrl]
        MOV     a1, #26                 ; 160 ticks of 12.288 MHz clock = 13 µs
        BL      WaitSemimicroseconds
        STRB    v2, [ip, #pp_ctrl]
        MOV     a1, #3
        BL      WaitSemimicroseconds    ; 16 ticks of 12.288 MHz clock = 1.5 µs

        ; Set up the PLLs in the Zoran- assume 48kHz sampling
        LDR     a1, =(6:SHL:10) :OR: (&18:SHL:5) :OR: (0:SHL:0)
        ADR     a2, PLLTAB_Params
        BL      ZoranPara_Command

        SUB     sp, sp, #4
        LDR     a1, =(1:SHL:10) :OR: (&19:SHL:5) :OR: (1:SHL:0)
        ADR     a2, PLLCFG_Params1
        MOV     a3, sp
        BL      ZoranPara_Command

        MOV     v2, #1000
80      LDR     a1, =(1:SHL:10) :OR: (&19:SHL:5) :OR: (1:SHL:0)
        ADR     a2, PLLCFG_Params2
        MOV     a3, sp
        BL      ZoranPara_Command
        LDRB    a1, [sp]
        AND     a1, a1, #3
        TEQ     a1, #3
        SUBNES  v2, v2, #1
        BNE     %BT80
        ADD     sp, sp, #4
        TEQ     v2, #0
        BEQ     %FT90                   ; timed out

        B       %FT00
        LTORG
PLLTAB_Params
        DCB     0, 2, 0, 1, 9, 33
PLLCFG_Params1
        DCB     3
PLLCFG_Params2
        DCB     0
        ALIGN
00

        MOV     a1, #100
        BL      WaitSemimicroseconds

        ; Call generic Zoran code to continue initialisation
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Init              ; corrupts ip, may return error
        TEQ     a1, #0
        BNE     %FT95

        ; Finished talking to Zoran chip
        StaticBaseFromSL ip
        BL      DeactivateDongle        ; preserves a1

        ; Register our availability
        MOV     a1, #0                  ; register MPEG decoder
        ADR     a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #1                  ; register AC-3 decoder
        ADR     a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #0                  ; no error
        Return  "v1,v2"

90      ; Error: PLL did not lock
        ADR     a1, AudioLockMessageToken
        LDR     a2, =&81850C
        MOV     a3, #0
        BL      Mess_GenerateError
        ; drop through to general error exit...
95
        StaticBaseFromSL ip
        BL      DeactivateDongle
96      BL      RestoreKeyboardPort
        Return  "v1,v2"

AudioLockMessageToken
        =       "Err_NoAudioPLLLock", 0
        ALIGN

WaitSemimicroseconds
        ; In: a1 = number of 2 MHz ticks to wait
        ; Out: a1-a4 corrupted
        Entry
        SUB     a1, a1, #1              ; subtract 1 so that completion condition is it going -ve
        MOV     a2, #0                  ; a2 holds old timer count (zero-init forces wrap case)
        MOV     lr, #IOMD_Base
01      STRB    lr, [lr, #Timer0LR]
        LDRB    a3, [lr, #Timer0CL]
        LDRB    a4, [lr, #Timer0CH]
        ORR     a3, a3, a4, LSL #8      ; a3 = new timer count
        SUBS    a2, a3, a2              ; difference (>= 0 means we have wrapped or not ticked)
        ADDMIS  a1, a1, a2              ; subtract any tick count from total - have we finished?
        MOVPL   a2, a3                  ; old timer count := new timer count
        BPL     %BT01
        EXIT


; _kernel_oserror *ZoranPara_Final (void);

        EXPORT  ZoranPara_Final
ZoranPara_Final
        FunctionEntry "v1"
        ; Call generic Zoran code to start finalisation (note dongle is in pass-through mode)
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Final
        TEQ     a1, #0
        Return  "v1",, NE

        ; Passed last point when failure to finalise can happen - now deregister ourselves
        StaticBaseFromSL ip
        ADRVar  lr, ip, Interface
        LDR     v1, [lr, #Interface_TopLevel]

        MOV     a1, #0                  ; deregister MPEG decoder
        ADRL    a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        MOV     a1, #1                  ; deregister AC-3 decoder
        ADRL    a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        ; Restore keyboard port
        BL      RestoreKeyboardPort

        MOV     a1, #0                  ; no error
        Return  "v1"


; ActivateDongle - switch dongle to codec mode
;   in:  ip = static base
;   out: r0 -> error block, or 0 for no error
;        other registers preserved

ActivateDongle
        Entry   "a2-a4"
        ; Set up everything needed in case we have to bail out (so that caller can safely call DeactivateDongle)
        MOV     a3, #IOMD_Base
        LDRB    a2, [a3, #IOCIRQMSKA]
        AND     a2, a2, #IOMDr_printer_IRQ_bit
        STRVar  a2, ip, OldParallelIRQBit, a1
        LDRVar  a1, ip, ParallelHardwareAddress
        LDRB    a2, [a1, #pp_ctrl]
        STRVar  a2, ip, OldParallelCtrl, lr

        ; Check parallel port isn't in use
        MOV     a1, #OSFind_OpenOut :OR: open_mustopen :OR: open_nodir
        ADR     a2, ParallelColon
        SWI     XOS_Find
        EXIT    VS
        STRVar  a1, ip, ParallelFileHandle, lr

        ; Disable parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a1, a4, #I32_bit :OR: F32_bit
        ORR     lr, a4, #I32_bit
        MSR     CPSR_c, a1              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a1, a2, #IOMDr_printer_IRQ_bit
        STRB    a1, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; just IRQs off while we mess with other stuff
        AND     a2, a2, #IOMDr_printer_IRQ_bit
        STRVar  a2, ip, OldParallelIRQBit, a1

        LDRVar  a1, ip, ParallelHardwareAddress
        LDRVar  a2, ip, OldParallelCtrl
        BIC     a2, a2, #pp_ctrl_irqen :OR: pp_ctrl_slctin      ; I²C clock starts high, leave other lines the same until we're sure dongle is present
        STRVar  a2, ip, SoftCopyCtrl, lr        ; we need this so we can tentatively drive the slctin line without affecting any others
        STRB    a2, [a1, #pp_ctrl]

        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ClaimDeviceVector   ; let any pending IRQ (!?) drop through into our handler

        ; Enable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
        MOV     a1, #IOMD_KBDCR_Ndata   ; go to audio mode, I²C data high
        STRB    a1, [a3, #IOMD_KBDCR]

        MSR     CPSR_c, a4              ; restore IRQs

        ; Check for Zoran's acknowledge on I²C bus
        MOV     a1, #zr38601_i2c_addr
        MOV     a2, #0
        MOV     a3, #0
        BL      IIC_Op
        EXIT    VS

        ; Initialise parallel control lines (older code would do this by virtue of sending a command)
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRVar  a2, ip, SoftCopyCtrl, lr; byte toggle starts high, but strobe is inverting
        LDRVar  a1, ip, ParallelHardwareAddress
        STRB    a2, [a1, #pp_ctrl]

        MOV     a1, #0
        EXIT

ParallelColon
        =       "Parallel:", 0
        ALIGN


; DeactivateDongle - switch dongle to pass-through mode
;   in:  ip = static base
;   out: all registers preserved

DeactivateDongle
        Entry   "a1-a4"
        ; Disable parallel IRQs in the control register -
        ; avoids any messy issues with the control handover
        LDRVar  a4, ip, ParallelHardwareAddress
        LDRVar  a2, ip, OldParallelCtrl
        BIC     a2, a2, #pp_ctrl_irqen
        STRB    a2, [a4, #pp_ctrl]

        ; Disable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
        MOV     a1, #0                  ; go to printer mode, I²C data high
        STRB    a1, [a3, #IOMD_KBDCR]

        ; Hand back the parallel port
        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ReleaseDeviceVector

        MOV     a3, #IOMD_Base
        LDRVar  a1, ip, OldParallelIRQBit
        MRS     lr, CPSR
        ORR     a2, lr, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        ORR     a2, a2, a1
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; restore IRQ/FIQ state

        LDRVar  a1, ip, OldParallelCtrl
        STRB    a1, [a4, #pp_ctrl]

        ; Release filing system lock
        MOV     a1, #0
        LDRVar  a2, ip, ParallelFileHandle
        TEQ     a2, #0                  ; has it been initialised?
        SWINE   XOS_Find
        EXIT


; RestoreKeyboardPort - called both from initialisation failure and finalisation
;   out: a2-a4,ip corrupted

RestoreKeyboardPort
        Entry   "a1"
        StaticBaseFromSL ip
        MOV     a4, #IOMD_Base
        LDRVar  a1, ip, OldKeyboardEnable
        STRB    a1, [a4, #IOMD_KBDCR]

        LDRVar  a1, ip, OldKeyboardIRQBits
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        ORR     a2, a2, a1
        STRB    a2, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        EXIT


; _kernel_oserror * (*componentinfo) (uint32_t tag, uintptr_t *result);

ZoranPara_ComponentInfo
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_ComponentInfo


; _kernel_oserror *(*clockcorrection)(uint32_t flags, uint32_t decoder_handle);

ZoranPara_ClockCorrection
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_ClockCorrection


; _kernel_oserror *(*speedchange)(uint32_t flags, uint32_t decoder_handle);

ZoranPara_SpeedChange
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_SpeedChange


; _kernel_oserror *(*activatesynccontrol)(uint32_t flags, uint32_t decoder_handle);

ZoranPara_ActivateSyncControl
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_ActivateSyncControl


; _kernel_oserror *(*getbufferlength)(uint32_t flags, uint32_t decoder_handle, uint32_t *length);

ZoranPara_GetBufferLength
        StaticBaseFromSL ip
        ADRVar  a4, ip, Interface       ; set up necessary extra parameter
        B       Zoran_GetBufferLength


; _kernel_oserror *(*adjustrate)(uint32_t flags, uint32_t decoder_handle);

ZoranPara_AdjustRate
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_AdjustRate


        EXPORT  ZoranPara_Peek
ZoranPara_Peek
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_Peek

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"

StarCommandWithNoDongle
        ADR     a1, DongleNotFittedToken
        LDR     a2, =&818513
        MOV     a3, #0
        BL      Mess_GenerateError
        ADD     sp, sp, #4
        Return  "v1"

DongleNotFittedToken
        =       "Err_DongleNotFitted", 0
        ALIGN


; _kernel_oserror *ZoranPara_Poke (const char *arg_string);

        EXPORT  ZoranPara_Poke
ZoranPara_Poke
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_Poke

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"


; _kernel_oserror *ZoranPara_VCXO (const char *arg_string);

        EXPORT  ZoranPara_VCXO
ZoranPara_VCXO
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_VCXO

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"



; _kernel_oserror * (*establish) (unsigned int flags, void *handle, stream_handle_t clock_handle, void **session_id);

ZoranPara_EstablishMPA
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishMPA
        B       %FT10
ZoranPara_EstablishAC3
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishAC3
10
        StaticBaseFromSL ip
        LDRVar  lr, ip, InUseSemaphore
        TEQ     lr, #0                  ; already in use?
        ADRNE   a1, InUseError
        Return  "v1",, NE               ; exit if so

        ; Activate dongle
        Push    "a1"
        BL      ActivateDongle
        TEQ     a1, #0
        BEQ     %FT20
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"                     ; pass back any error
20

        ; Exchange handles
        ADRVar  lr, ip, Interface
        STR     a2, [lr, #Interface_TopLevelHandle]
        STR     lr, [a4]

        ; Call generic code
        Pull    "a1"
        MOV     a2, a3
        MOV     a3, lr
        MOV     lr, pc
        MOV     pc, v1                  ; call Zoran_EstablishMPA or Zoran_EstablishAC3
        StaticBaseFromSL ip
        TEQ     a1, #0
        BNE     %FT90                   ; error exit

        MOV     a4, #1
        STRVar  a4, ip, InUseSemaphore, lr ; set in-use semaphore
        Return  "v1"                    ; exit with a1=0

90      BL      DeactivateDongle
        Return  "v1"

InUseError
        &       &81850F                 ; errno_AUDIO_IN_USE
        =       "No suitable audio decoder available", 0
        ; No point in internationalising, because string is ignored by AudGeneric
        ALIGN


; _kernel_oserror * (*annul) (unsigned int flags, void *session_id);

ZoranPara_Annul
        FunctionEntry
        ; Call generic code
        BL      Zoran_Annul
        TEQ     a1, #0
        Return  ,, NE                   ; bail out now if error

        StaticBaseFromSL ip
        BL      DeactivateDongle

        MOV     a4, #0
        STRVar  a4, ip, InUseSemaphore, lr

        Return                          ; exit with a1=0


; _kernel_oserror * (*discontinue) (unsigned int flags, void *session_id);

ZoranPara_Discontinue
        FunctionEntry
        ; Call generic code
        BL      Zoran_Discontinue
        TEQ     a1, #0
        Return  ,, NE                   ; bail out if error

        ; Mask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

        MOV     a1, #0
        Return                          ; exit with a1=0


; _kernel_oserror * (*consumedata) (unsigned int flags, void *session_id, unsigned char *start, unsigned int length, unsigned int *not_consumed);

ZoranPara_ConsumeData
        LDR     ip, [a2, #Interface_Flags]
        TST     ip, #InterfaceFlags_ReceivingCharacterisationData :OR: InterfaceFlags_Resetting
        BEQ     %FT10
        TST     ip, #InterfaceFlags_Resetting
        BNE     %FT60

        ; Normal characterising case: send to recogniser via the generic Zoran code
        TST     ip, #InterfaceFlags_Characterising
        BNE     Zoran_ConsumeData       ; pass data on to characteriser

        ; A rare case where the characteriser reaches recognition at the very end of
        ; the previous block, and the buffer manager has sent another block
        LDR     a2, [sp, #4*0]          ; retrieve not_consumed pointer
        STR     a4, [a2]                ; have not consumed any of the new data
        MOV     a1, #0                  ; no error
        Return  , LinkNotStacked

10      ; Normal decoding case: send to hardware
        FunctionEntry
        StaticBaseFromSL ip
        LDRVar  a2, ip, StuffingBytesRemaining
        SUBS    a1, a4, a2
        MOVMI   a1, #0                  ; a1 = amount available that won't fit into data burst
        LDR     lr, [sp, #1*4]          ; retrieve not_consumed pointer
        STR     a1, [lr]
        SUBS    a1, a4, a1              ; a1 = bytes we're actually going to transfer
        SUBNE   a2, a2, a1
        STRVar  a2, ip, StuffingBytesRemaining, lr, NE
        MOVNE   a2, a3
        BLNE    IntConsumeData
        MOV     a1, #0                  ; no error
        Return

60      ; During a reset, flush all data away
        LDR     a2, [sp, #4*0]          ; retrieve not_consumed pointer
        MOV     a1, #0                  ; no error
        STR     a1, [a2]                ; all consumed
        Return  , LinkNotStacked


; extern void ZoranPara_UnmaskStuffingIRQ (void);

ZoranPara_UnmaskStuffingIRQ
        FunctionEntry
        StaticBaseFromSL ip

        ; State initialisation
        MOV     a1, #0                  ; don't send anything before the first interrupt
        STRVar  a1, ip, StuffingBytesRemaining, lr

        ; Unmask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        ORR     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

        ; Clear the IRQ in IOMD (well, it can't hurt)
        Push    "r0,r1"
        MOV     r0, #IOMD_Base
        MOV     r1, #IOMDr_printer_IRQ_bit
        STRB    r1, [r0, #IOCIRQCLRA]
        Pull    "r0,r1"

        Return


; extern void ZoranPara_MaskStuffingIRQ (void);

ZoranPara_MaskStuffingIRQ
        FunctionEntry

        ; Mask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

        Return


        ; IRQs are disabled on entry to ParallelIRQHandler
ParallelIRQHandler
        Entry   "r1"
        ; Drop into SVC mode and set up APCS module environment
        WritePSRc I_bit+SVC_mode, lr,, r1
        Push    "r0-r11, lr_svc"
        MOV     sl, sp, LSR #20
        MOV     sl, sl, LSL #20
        LDMIA   sl, {v1, v2}
        Push    "v1, v2"
        LDMIB   r12, {v1, v2}
        STMIA   sl, {v1, v2}
        ADD     sl, sl, #540
        MOV     fp, #0

 [ {FALSE}
        Push    "r3,lr"
        MOV     r3, #&03500000
        MOV     lr, #&10000008
        STR     lr,[r3]
        MOV     lr, #&0F000000
        STR     lr, [r3]
        LDR     lr, =&10000080
        STR     lr, [r3]
        MOV     lr, #&00FF0000
        STR     lr, [r3]
        Pull    "r3,lr"
 ]

        SUB     sp, sp, #4              ; allocate one word of scratch workspace on stack

        StaticBaseFromWP r9, r12

; MOV a1, #'i'
 [ Debugging=1 :LAND: DebugToScreen=1
 IMPORT DWrite_WriteC
 ]
; BL DWrite_WriteC

        ; Always acknowledge the interrupt
        MOV     r0, #IOMD_Base
        MOV     r1, #IOMDr_printer_IRQ_bit
        STRB    r1, [r0, #IOCIRQCLRA]

        LDRVar  v1, v6, ParallelHardwareAddress
        ADRVar  v2, v6, Interface
        LDR     v3, [v2, #Interface_TopLevelHandle]

        ; Check how much data is available
        MOV     a1, #0
        MOV     a2, v3
        MOV     a3, #fifo_size
        MOV     a4, sp
        MOV     lr, pc
        LDR     pc, [v2, #Interface_HowMuchData]
        LDR     v4, [sp]                ; v4 = amount available to be stuffed
        BIC     v4, v4, #1              ; ensure a whole number of 16-bit words
        STRVar  v4, v6, StuffingBytesRemaining, lr
; MOV a1,v4
; IMPORT DWrite_WriteHex8
; BL DWrite_WriteHex8

        ; Send two-byte header
        MOV     a1, #&42
        ORR     a1, a1, v4, LSL #7
        STR     a1, [sp]
        MOV     a2, sp
        MOV     a1, #2
        BL      IntConsumeData

        ; Fetch some data
        TEQ     v4, #0
        MOVNE   a1, #1                  ; wrap in PES packets
        MOVNE   a2, v3
        MOVNE   lr, pc
        LDRNE   pc, [v2, #Interface_GiveMeData] ; call the appropriate givemedata()

90      ; Send flushing data
        MOV     a1, #-1
        STR     a1, [sp]
        MOV     a2, sp
        MOV     a1, #4
        BL      IntConsumeData

        ; Mollify watchdog
        LDR     a1, [v2, #Interface_Flags]
        TST     a1, #InterfaceFlags_IRQSincePoll
        ORREQ   a1, a1, #InterfaceFlags_IRQSincePoll
        STREQ   a1, [v2, #Interface_Flags]

 [ {FALSE}
        Push    "r3,lr"
        MOV     r3, #&03500000
        MOV     lr, #&10000008
        STR     lr,[r3]
        MOV     lr, #0
        STR     lr,[r3]
        Pull    "r3,lr"
 ]

        ; Tidy up and exit
        ADD     sp, sp, #4
        Pull    "v1, v2"
        SUB     sl, sl, #540
        STMIA   sl, {v1, v2}
        Pull    "r0-r11, lr_svc"
        RestPSR r1              ; back to original processor mode
        EXIT


; Internal APCS routine to send data unconditionally

; In:  a1 = number of bytes to transfer
;      a2 -> block
; Out: a1 nonzero => aborted

IntConsumeData
        TEQ     a1, #0
        MOVEQ   pc, lr
        FunctionEntry "v1,v2"
        StaticBaseFromSL ip
        LDRVar  a3, ip, SoftCopyData
        LDRVar  a4, ip, SoftCopyCtrl
        LDRVar  v1, ip, ParallelHardwareAddress
        MOV     ip, #IOMD_Base
        TST     a1, #1
        MOVNE   lr, a3
        BNE     %FT15
10
        LDRB    lr, [a2], #1
        TEQ     lr, a3
        EOREQ   a4, a4, #pp_ctrl_strobe
        STREQB  a4, [v1, #pp_ctrl]
        STRNEB  lr, [v1, #pp_data]
15
        LDRB    a3, [a2], #1
        TEQ     a3, lr
        EOREQ   a4, a4, #pp_ctrl_strobe
        STREQB  a4, [v1, #pp_ctrl]
        STRNEB  a3, [v1, #pp_data]

        SUBS    a1, a1, #2
        BGT     %BT10
20
        StaticBaseFromSL ip
        STRVar  a3, ip, SoftCopyData, lr
        STRVar  a4, ip, SoftCopyCtrl, lr
        MOV     a1, #0
        Return  "v1,v2"


; extern void ZoranPara_Command (unsigned int flags, const char *parameters, char *response);

; flags: bits 5-9 = command-&80
;        bits 10-31 = number of parameters
;        bits 0-4 = number of results
; Executes for the most part in the same IRQ disable state as is set on entry

ZoranPara_Command
        FunctionEntry
        MOV     lr, a1
        AND     a4, lr, #&1F
        MOV     a1, #zr38601_i2c_addr :OR: 1 :OR: 1:SHL:31
        Push    "a1,a3,a4"      ; 4th transfer: read response
        MOV     a4, #2
        MOV     a1, #zr38601_i2c_addr :OR: 1 :OR: 1:SHL:30
        Push    "a1,a3,a4"      ; 3rd transfer: dummy read of two bytes (don't care about values, so use checksum mode)
        MOV     a4, lr, LSR #10
        MOV     a1, #zr38601_i2c_addr :OR: 1:SHL:31
        Push    "a1,a2,a4"      ; 2nd transfer: write parameters
        MOV     a4, #1
        SUB     a3, sp, #4*4
        MOV     a2, #zr38601_i2c_addr
        MOV     a1, #&1F
        AND     a1, a1, lr, LSR #5
        ADD     a1, a1, #&80
        Push    "a1-a4"         ; 1st transfer: write command number
        ADD     a1, sp, #4*1
        MOV     a2, #4
        BL      IIC_OpV
        ADD     sp, sp, #4*13
        Return



; Static variable indirection table
; ---------------------------------

        IMPORTVar Module_PrivateWord
        LocalVar Interface
        LocalVar InUseSemaphore
        LocalVar ParallelHardwareAddress
        LocalVar OldKeyboardIRQBits
        LocalVar OldKeyboardEnable
        LocalVar SoftCopyCtrl
        LocalVar SoftCopyData
        LocalVar ParallelFileHandle
        LocalVar OldParallelIRQBit
        LocalVar OldParallelCtrl
        LocalVar ParallelSemaphore
        LocalVar Aborted
        LocalVar StuffingBytesRemaining
        LocalVar IICNoAckError



; IIC code shamelessly copied from HAL (Kernel-5_35-4_79_2_47)


PollMax		*	150	; Number of times to poll for an Ack (increase if you clock faster - need to
                                ; allow 5ms for write cycle).

I2Cticks        *       3

IICStackAlignment       *       7       ; log2 of stack size, also stack alignment
                                        ; current requirement is 19 words = 2_01001100 bytes

                ^       0
IICLink_Next    #       4
IICLink_Error   #       4
IICLink_Array   #       4
IICLink_Size    #       4

; SVC stack format, in descending address order:
;    16 bytes   first link (also bottom of stacked registers)
;     n bytes   align to address with bottom x bits set
; 2^x-4 bytes   align to address with bottom x bits clear (the local stack)
;     4 bytes   linked list head
;     4 bytes   linked list tail
;     4 bytes   original sp
;      .
;      .
;      .
;    16 bytes   another link (also bottom of stacked registers)
;     4 bytes   original sp

; IRQ stack format, in descending address order, for reference:
;     4 bytes   lr_irq-4 (interrupted PC)
;     4 bytes   r0
;     4 bytes   spsr_irq (interrupted CPSR)
;    20 bytes   r1-r3, r11, r12
;     4 bytes   IRQsema link


iicsp   RN      11
iiclr   RN      12


        MACRO
$label  iicBL   $destination, $cond
$label  MOV$cond iiclr, pc
        B$cond  $destination
        MEND

        MACRO
$label  iicPull $reglist, $cond, $hat
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   "$hat" = ""
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  LDR$cond $reglist, [iicsp], #4
        |
$label  LDM$cond.FD iicsp!, {$reglist}$hat
        ]
        MEND

        MACRO
$label  iicPush $reglist, $cond
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  STR$cond $reglist, [iicsp, #-4]!
        |
$label  STM$cond.FD iicsp!, {$reglist}
        ]
        MEND


; *****************************************************************************

; in:   R0 = device address (bit 0 set => read, clear => write)
;       R1 -> data block
;       R2 = length of data block
;
IIC_Op
        Push    "R0-R2,LR"
        Push    "R0-R2"                 ; soft copy for IIC_OpV to work on
        MOV     R0, R13
        MOV     R1, #1
        BL      IIC_OpV
        ADD     R13, R13, #12           ; junk soft copy
        Pull    "R0-R2,PC",VC
        ADD     R13, R13, #4
        Pull    "R1-R2,PC"

; *****************************************************************************

; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  transfer descriptors may be updated (beware)
;
; transfer descriptor is 3 words: word 0 = device address (+direction)
;                                         (bit 29 signifies retry for response)
;                                         (bit 30 signifies checksum read only - ie fill in word 1 with
;                                          sum of bytes read)
;                                         (bit 31 signifies continued transfer - ie no start or address)
;                                 word 1 -> data block
;                                 word 2 = length of data block
IIC_OpV ROUT
        Push    "r0-r3,r6-r12,lr"
        MOV     lr, #0
        STR     lr, [sp, #-8]!
        StaticBaseFromSL r9
        MRS     r10, CPSR
        BIC     r7, r10, #I32_bit :OR: F32_bit
        ORR     r8, r7, #I32_bit
        MOV     r2, #IRQsema
        MOV     r12, sp                 ; original sp, also pointer to link
        ORR     lr, r8, #2_10000
        MSR     CPSR_c, lr              ; IRQs off, force 32-bit mode

01      LDR     r2, [r2]
        TEQ     r2, #0
        BEQ     %FT50                   ; I²C code not in IRQ stack
        LDR     r6, [r2, #4*8]          ; interrupted PC
IIC_OpV_PCReference
        RSB     lr, pc, r6
        LDR     r0, =(interrupt_protected_end-4) - (IIC_OpV_PCReference+8)
        CMP     lr, r0
        RSBLES  lr, lr, #interrupt_protected_start - (IIC_OpV_PCReference+8)
        BGT     %BT01

        ; I²C code is already threaded
        Push    "r12"                   ; put original sp on stack for our exit routine
        LDR     r0, [r2, #4*4]          ; retrieve interrupted iicsp
        BIC     r0, r0, #(1:SHL:IICStackAlignment)-1
        LDR     r1, [r0, #-8]           ; old list tail
        STR     r12, [r0, #-8]          ; new list tail
        STR     r12, [r1, #IICLink_Next] ; point old link to new link
        ADR     r0, IIC_OpV_CommonExit
        STR     r0, [r2, #4*8]          ; poke IRQ stack so previous operation returns as though completed
        LDR     r0, [r2, #4*6]          ; get interrupted CPSR
        MSR     SPSR_cxsf, r0           ; stick it in SPSR (okay, because IRQs are off)
        LDR     r0, [r2, #4*7]
        LDMIB   r2, {r1-r3,r11,r12}
        MOVS    pc, r6                  ; copy SPSR to CPSR and resume execution

50      ; I²C code not currently threaded - create new environment
        ADD     iicsp, sp, #4
        BIC     iicsp, iicsp, #(1:SHL:IICStackAlignment)-1
        SUB     iicsp, iicsp, #4
        BIC     sp, iicsp, #(1:SHL:IICStackAlignment)-1
        Push    "r12"                   ; list head pointer
        Push    "r12"                   ; list tail pointer
        Push    "r12"                   ; original sp
        LDR     r0, [r12, #IICLink_Array]
        LDR     r1, [r12, #IICLink_Size]
        B       IICStart                ; start working through list

IIC_OpV_CommonExit
        MSR     CPSR_c, r10             ; restore original IRQ disable state
        LDR     sp, [sp]
        ADD     sp, sp, #4              ; skip next pointer
        Pull    "r0"
        CMP     r0, #0
        Pull    "r0-r3,r6-r12,pc", EQ
        SETV
        ADD     sp, sp, #4
        Pull    "r1-r3,r6-r12,pc"


interrupt_protected_start

; Protected routines register usage:
;   r0-r3   general purpose
;    r7     MRS style PSR with c bits = SVC26/32, IRQs/FIQs enabled
;    r8     MRS style PSR with c bits = SVC26/32, IRQs disabled, FIQs enabled
;    r9     module static base
;    r11    stack pointer
;    r12    link register / general purpose
;    CPSR is also non-volatile

IICStart
        MSR     CPSR_c, r7              ; enable IRQs (inside protected code) - this may take some time
        ; drop through...

; *****************************************************************************
;
;       IICLoop - serial-execution outermost loop, stepping along pending IIC operations
;

IICLoop
     iicBL      IICDoOp
        MOVVC   r0, #0
        BIC     r1, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r2, [r1, #-4]           ; list head
        STR     r0, [r2, #IICLink_Error] ; set up return value
        MSR     CPSR_c, r8              ; disable IRQs while we work on the list
        LDR     r2, [r2]
        TEQ     r2, #0                  ; end of list?
        BEQ     IIC_OpV_CommonExit      ; finished!
        STR     r2, [r1, #-4]           ; update list head
        MSR     CPSR_c, r7              ; IRQs back on
        LDR     r0, [r2, #IICLink_Array]
        LDR     r1, [r2, #IICLink_Size] ; get next array
        B       IICLoop                 ; and loop

; *****************************************************************************
;
;       IICDoOp - main serial-execution entry point
;
; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  if V set, r0 -> error block
;       otherwise r0-r3,r12 may be corrupted
;

IICDoOp ROUT
        MOV     R2, #0
     iicPush    "R1,R2,iiclr"           ; two words on stack are RepeatedStart flag and transfers remaining

        MOV     R3, R0

05      LDR     R0, [iicsp]
        SUBS    R0, R0, #1
        BCC     %FT90
        STR     R0, [iicsp]

        LDMIA   R3!, {R0-R2}
        TST     R0, #1:SHL:31           ; skip start?
        BNE     %FT08

        LDR     iiclr, [iicsp, #4]
        TEQ     iiclr, #0
        MOV     iiclr, pc
        ADD     iiclr, iiclr, #8
        BEQ     Start
        BNE     RepeatedStart           ; these are effectively conditional BL's

        TST     R0, #1:SHL:29
        BNE     %FT06
     iicBL      TXAck                   ; transmit device address without retries
        B       %FT07

06
     iicBL      TXPollAck               ; transmit device address with retries
07      BVS     %FT80

08      MOV     iiclr, #1
        STR     iiclr, [iicsp, #4]
        TEQ     R2, #0
        BEQ     %BT05

        TST     R0, #1                  ; Z => write, NZ => read
        BNE     %FT20

; Write case
10      LDRB    R0, [R1], #1            ; read byte from data block
     iicBL      TXAck                   ; transmit, checking for ack
        BVS     %FT80
        SUBS    R2, R2, #1              ; decrement byte count
        BNE     %BT10                   ; loop until finished
        B       %BT05                   ; then next transfer

20      TST     R0, #1:SHL:30           ; checksum?
        BNE     %FT30

; Read case
21
     iicBL      RXByte                  ; read byte from bus
        STRB    R0, [R1], #1            ; store in data block
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT21
        B       %BT05                   ; next transfer

; Checksum case
30      MOV     R1, #0
31
     iicBL      RXByte                  ; read byte from bus
        ADD     R1, R1, R0
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT31
        STR     R1, [R3, #-8]           ; store checksum
        B       %BT05                   ; next transfer

90
     iicBL      Stop
        CLRV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

80
     iicBL      Stop
        ADRVar  R0, R9, IICNoAckError   ; don't internationalise here for MessageTrans re-entrancy reasons
        SETV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

        MakeInternatErrorBlock IIC_NoAcknowledge, NoAlign, "NoAck:No acknowledge from IIC device"
IICMessagesFile
        =       "Resources:$.Resources.IIC.Messages", 0
        ALIGN

; *****************************************************************************
;
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:  r0,r1 corrupted
;

SetC1C0 ROUT
     iicPush    "r2,r3,iiclr"
        TST     r0, #1          ; data high?
        MOVEQ   r0, #IOMD_KBDCR_Ndata :OR: IOMD_KBDCR_Nclock
        MOVNE   r0, #IOMD_KBDCR_Ndata
        MOV     r3, #IOMD_Base
        STRB    r0, [r3, #IOMD_KBDCR]

        LDRVar  r0, r9, ParallelHardwareAddress
        MSR     CPSR_c, r8
        TST     r1, #1          ; clock high?
        LDRVar  r1, r9, SoftCopyCtrl
        ORREQ   r1, r1, #pp_ctrl_slctin
        BICNE   r1, r1, #pp_ctrl_slctin
        STRB    r1, [r0, #pp_ctrl]
        STRVar  r1, r9, SoftCopyCtrl, r3
        MSR     CPSR_c, r7

        MOV     R0, #3
     iicBL      iicDoMicroDelay

     iicPull    "r2,r3,pc"

; *****************************************************************************
;
;	ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
;
; out:	R0, R1 updated
;

ReadC1C0 ROUT
        ; PS/2 clock line (IIC data line) has already been
        ; allowed to go open drain, so we need only read it
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_KBDCR]
        AND     r0, r0, #1
        ; The value of the IIC clock line isn't used, which
        ; is fortunate because we can't read it
        MOV     pc, iiclr

; *****************************************************************************
;
;       iicDoMicroDelay - Delay for >= R0/2 microseconds, IIC calling standard
;
; in:	R0 = time delay in 1/2 microsecond units
;	On ARM600, we may or may not be in a 32-bit mode
;
; out:	R0,R1 corrupted
;

iicDoMicroDelay ROUT
     iicPush    "R2,iiclr"
        MOV     R2, #IOMD_Base
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    iiclr, [R2, #Timer0CL]  ; iiclr := low output latch
        TEQ     iiclr, R1               ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, iiclr               ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

     iicPull    "R2,PC"

        LTORG

; *****************************************************************************
;
;	ClockData - Clock a bit of data down the IIC bus
;
; in:	R0 = data bit
;
; out:	All registers preserved, including PSR
;

ClockData ROUT
 [ No26bitCode
     iicPush    "R0-R3,iiclr"
        MRS     R2,CPSR
 |
     iicPush    "R0-R1,R3,iiclr"
 ]
        MOV     R3, R0

	MOV	R1, #0			; Clock lo
     iicBL      SetC1C0

; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling
        MSR     CPSR_c, r8

        MOV     R0, R3
	MOV	R1, #1			; Clock hi
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, R3
	MOV	R1, #0			; Clock lo
     iicBL      SetC1C0

 [ No26bitCode
        MSR     CPSR_cf,R2              ; Restore interrupts and flags
     iicPull    "R0-R3,PC"
 |
     iicPull    "R0-R1,R3,PC",,^
 ]

; *****************************************************************************
;
;	Start - Send the Start signal
;
; out:	All registers preserved, PSR corrupted
;

Start	ROUT
     iicPush    "R0-R1,iiclr"

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	RepeatedStart - Send a Repeated Start signal
;
; out:	All registers preserved, PSR corrupted
;

RepeatedStart	ROUT
     iicPush    "R0-R1,iiclr"

        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
     iicBL      SetC1C0

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	Acknowledge - Check acknowledge after transmitting a byte
;
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
;

Acknowledge ROUT
     iicPush    "R0-R2,iiclr"

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
     iicBL      SetC1C0

 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

     iicBL      ReadC1C0
        MOV     R2, R0                  ; should be LO for correct acknowledge

	MOV  	R0, #1
	MOV  	R1, #0			; clock LO, data HI
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]

        TST     R2, #1
        MRS     R2, CPSR
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
        MSR     CPSR_f, R2

     iicPull    "R0-R2,PC"

; *****************************************************************************
;
;	Stop - Send the Stop signal
;
; out:	All registers preserved, PSR corrupted
;

Stop	ROUT
     iicPush    "R0-R1,iiclr"

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, PSR corrupted
;

TXByte	ROUT
     iicPush    "R0-R2,iiclr"
	MOV	R1, #&80		; 2^7 the bit mask
	MOV	R2, R0			; byte goes into R2
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
     iicBL      ClockData               ; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
     iicPull    "R0-R2,PC"

TXAck	ROUT
     iicPush    iiclr
     iicBL      TXByte
     iicPull    iiclr
	B	Acknowledge


; *****************************************************************************
;
;	TXPollAck - Transmit a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved
;

TXPollAck	ROUT
     iicPush    "R1,iiclr"
	MOV	R1, #1
10
     iicBL      TXByte
     iicBL      Acknowledge
     iicPull    "R1,PC",VC
        ADD     R1, R1, #1
	TEQ	R1, #PollMax
        BEQ     %FT90
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
     iicBL      RepeatedStart
        B       %BT10
90
     iicPull    "R1,PC"

; *****************************************************************************
;
;	RXByte - Receive a byte
;
; out:	R0 = byte received
;	All other registers preserved, PSR corrupted
;

RXByte	ROUT
     iicPush    "R1-R3,iiclr"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #7

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
     iicBL      SetC1C0
10
 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
     iicBL      SetC1C0

     iicBL      ReadC1C0
        ADD     R3, R0, R3, LSL #1      ; byte:=byte*2+ SDA

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]
        SUBS    R2, R2, #1
	BCS	%BT10

	MOV	R0, R3			; return the result in R0
     iicPull    "R1-R3,PC"


interrupt_protected_end



; Some const strings
; ------------------

HWInfoPrototype                         ; printf format
        =       "Zoran ZR38601 (ROM %08X) parallel port dongle", 0
DriverInfoPrototype
        =       Module_ComponentName, " ", Module_HelpVersion, " microcode ", 34, "%s", 34, 0
ShortInfo
        =       "AC-3 Dongle Driver ", Module_HelpVersion, " © Pace ", Module_Date :RIGHT: 4, 0
        ALIGN


        AREA    |Asm$$Data|, DATA


; Local static variables
; ----------------------

Interface                               ; struct to pass to generic Zoran code
        DCD     ZoranPara_Command
        DCD     ZoranPara_UnmaskStuffingIRQ
        DCD     ZoranPara_MaskStuffingIRQ
        DCD     ZoranPara_ConsumeData
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0, 0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     &0300A002               ; PRISM ID
        DCD     FunctionDescriptorTable
        DCD     (FunctionDescriptorTableEnd - FunctionDescriptorTable) / 8
        DCD     0
        DCD     HWInfoPrototype
        DCD     0
        DCD     0
        DCD     DriverInfoPrototype
        DCD     0
        DCD     ShortInfo
        ASSERT  .-Interface = InterfaceSize
InUseSemaphore
        DCD     0                       ; nonzero => decoder in use
ParallelHardwareAddress
        DCD     0                       ; base address of parallel hardware
OldKeyboardIRQBits
        DCD     0                       ; original keyboard bits in IRQMSKB
OldKeyboardEnable
        DCD     0                       ; original keyboard enable bit in KBDCR
SoftCopyCtrl
        DCD     0                       ; soft copy of ctrl register (irqen/init set, slctin toggling), for speed
SoftCopyData
        DCD     0                       ; for speed
ParallelFileHandle
        DCD     0                       ; file handle we lock parallel: with
OldParallelIRQBit
        DCD     0                       ; original printer bit in IRQMSKA
OldParallelCtrl
        DCD     0                       ; original contents of parallel control register
ParallelSemaphore
        DCD     0                       ; address to poke into IRQ stack if threaded, else 0
Aborted
        DCD     0                       ; whether the current SendPacket was aborted
StuffingBytesRemaining
        DCD     0                       ; space in FIFO (for resumption of stuffing after underrun)
IICNoAckError
        %       256                     ; internationalised error block


; Table for passing to PRISM_CreateVeneers
; ----------------------------------------

FunctionDescriptorTable
        DCD     ZoranPara_ComponentInfo
        DCD     0
        DCD     ZoranPara_ClockCorrection
        DCD     0
        DCD     ZoranPara_SpeedChange
        DCD     0
        DCD     ZoranPara_ActivateSyncControl
        DCD     0
        DCD     ZoranPara_GetBufferLength
        DCD     0
        DCD     ZoranPara_AdjustRate
        DCD     0
 IMPORT Zoran_BodgePlay
 DCD Zoran_BodgePlay
 DCD 0
FunctionDescriptorTableEnd


 ]

        END
