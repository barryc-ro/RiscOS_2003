; /****** ZoranPara.s ********************************************************
;
; Project:	STB-400
; Component:	MPEGDriver
; This file:	Code to manage the interface between the ARM and the Zoran
;		in the case of a PS/2 / parallel port dongle
;
; Copyright 2001 Pace Micro Technology plc. All rights reserved.
;
; This material is the confidential trade secret and proprietary information
; of Pace Micro Technology plc. It may not be reproduced, used, sold, or
; transferred to any third party without the prior written consent of
; Pace Micro Technology plc.
;
; History:
; Date		Who	Change
; ----------------------------------------------------------------------------
; 15/08/2001	BJGA	Created
;
; ***************************************************************************/


; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>
        GET     Hdr:Proc
        GET     Hdr:IO.IOMD
        GET     Hdr:DevNos
        GET     Hdr:Parallel
        GET     Hdr:HighFSI
        GET     Hdr:IIC
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:MsgTrans
        GET     Hdr:ModHand
  GET  <Hdr$Dir>.Global.Debug
        GET     hdr.Debug
        GET     VersionASM


                GBLL    Microcode
Microcode       SETL    {TRUE}

                GBLA    PCB
PCB             SETA    4       ; 1 = slow data / no VCXO, 2 = no I²C, 3 = main board I²C, 4 = PS2 I²C

                GBLL    RnW
RnW             SETL    {TRUE}

                GBLL    SwitchPins
SwitchPins      SETL    {TRUE}


        MACRO
$l      ToggleLED
        Push    "r0,r1,lr"
        MOV     r0, #2
        ADR     r1, %FT00
        SWI     &72D80 ;XPortMan_AccessBit
        B       %FT01
00
        =       "LED_Red", 0
        ALIGN
01
        Pull     "r0,r1,lr"
        MEND


 [ PCB >= 3

; I²C address of Zoran chip

zr38601_i2c_addr *      &30

 ]

; FIFO size
 [ Microcode
fifo_size       *       256
 |
fifo_size       *       1
 ]

; Address of IRQ semaphore
IRQsema         *       &108

; Offsets from parallel hardware base address
                ^       0
pp_data         #       4
pp_stat         #       4
pp_ctrl         #       4

; Bits in parallel status and control registers

pp_stat_notbusy         * 1:SHL:7
pp_stat_ack             * 1:SHL:6
pp_stat_pe              * 1:SHL:5
pp_stat_slct            * 1:SHL:4
pp_stat_error           * 1:SHL:3

pp_ctrl_dir             * 1:SHL:5
pp_ctrl_irqen           * 1:SHL:4
pp_ctrl_slctin          * 1:SHL:3
pp_ctrl_init            * 1:SHL:2
pp_ctrl_autofd          * 1:SHL:1
pp_ctrl_strobe          * 1:SHL:0

; Layout of zoran_interface_t C struct
                        ^       0
Interface_Command       #       4
Interface_CompleteOp    #       4
Interface_UnmaskIRQ     #       4
Interface_ConsumeData   #       4
Interface_TopLevel      #       4
Interface_Buffer        #       4
Interface_Scheduler     #       4
Interface_Presentation  #       4
Interface_TopLevelHandle #      4
Interface_Characteriser #       4
Interface_CharacteriserHandle # 4
Interface_Link          #       4
Interface_HowMuchData   #       4
Interface_GiveMeData    #       4
Interface_Flags         #       4
Interface_BlockQueueHead #      4
Interface_BlockQueueTail #      4
Interface_HWInfoPrototype #     4
Interface_HWInfo        #       4
Interface_RomVersion    #       4
Interface_DriverInfoPrototype # 4
Interface_DriverInfo    #       4
InterfaceSize           *       :INDEX: @

InterfaceFlags_AC3NotMPA                        *       1 :SHL: 0
InterfaceFlags_Characterising                   *       1 :SHL: 1
InterfaceFlags_ReceivingCharacterisationData    *       1 :SHL: 2
InterfaceFlags_Started                          *       1 :SHL: 3
InterfaceFlags_DongleFitted                     *       1 :SHL: 31 ; private flag

; Layout of common_toplevel_fns_t C struct
                        ^       0
TopLevel_RegisterMe     #       4
TopLevel_DeregisterMe   #       4

; Layout of buffer_fns_t C struct
                        ^       0
Buffer_HowMuchData      #       4
Buffer_GiveMeData       #       4


        IMPORT  Mess_GenerateError
        IMPORT  Zoran_Init
        IMPORT  Zoran_Final
        IMPORT  Zoran_EstablishMPA
        IMPORT  Zoran_EstablishAC3
        IMPORT  Zoran_Annul
        IMPORT  Zoran_Commence
        IMPORT  Zoran_Discontinue
        IMPORT  Zoran_ReadSystemInfo
        IMPORT  Zoran_DataAvailable
        IMPORT  Zoran_ConsumeData
        IMPORT  Zoran_ReadFullness
        IMPORT  Zoran_Start
        IMPORT  Zoran_Stop
        IMPORT  Zoran_SetClock
        IMPORT  Zoran_Speed
        IMPORT  Zoran_Fast
        IMPORT  Zoran_Slow
        IMPORT  Zoran_Normal
        IMPORT  Zoran_Volume
        IMPORT  Zoran_Downmix
        IMPORT  Zoran_SPDIF
        IMPORT  Zoran_ReadStreamInfo
        IMPORT  Zoran_Peek
        IMPORT  Zoran_Poke
        IMPORT  Zoran_VCXO


        AREA    |Asm$$Code|, CODE, READONLY
 InsertDebugRoutines


; Exported functions
; ------------------


; These are the protocol_fns_t structs that we register with AudGeneric

ProtocolFunctions_MPEG
        DCD     ZoranPara_EstablishMPA
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     ZoranPara_ReadSystemInfo
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_SetClock
        DCD     Zoran_Speed
        DCD     Zoran_Fast
        DCD     Zoran_Slow
        DCD     Zoran_Normal
        DCD     0               ; Proceed
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo

ProtocolFunctions_AC3
        DCD     ZoranPara_EstablishAC3
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     ZoranPara_ReadSystemInfo
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_SetClock
        DCD     Zoran_Speed
        DCD     Zoran_Fast
        DCD     Zoran_Slow
        DCD     Zoran_Normal
        DCD     0               ; Proceed
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo


; extern _kernel_oserror *ZoranPara_Init (common_toplevel_fns_t *toplevel, buffer_fns_t *buffer, scheduler_fns_t *scheduler, const presentation_fns_t *presentation);

        EXPORT  ZoranPara_Init
ZoranPara_Init
        FunctionEntry "v1,v2"
        StaticBaseFromSL ip

        ; Cache callback function pointer tables in our interface struct
        ADRVar  lr, ip, Interface
        STR     a1, [lr, #Interface_TopLevel]
        MOV     v1, a1                  ; useful later in this function
        STR     a2, [lr, #Interface_Buffer]
        STR     a3, [lr, #Interface_Scheduler]
        STR     a4, [lr, #Interface_Presentation]

        MOV     a1, #0
        STRVar  a1, ip, InUseSemaphore, lr

      [ PCB = 4
        ; Internationalise the IIC NoAck message
        SUB     sp, sp, #4*4
        MOV     r0, sp
        ADRL    r1, IICMessagesFile
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        ADRL    r0, ErrorBlock_IIC_NoAcknowledge
        MOV     r1, sp
        ADRVar  r2, ip, IICNoAckError
        MOV     r3, #256
        SWI     XMessageTrans_ErrorLookup
        MOV     r0, sp
        SWI     XMessageTrans_CloseFile
        ADD     sp, sp, #4*4
      ]

        ; Cache parallel hardware address, so we don't have to do a SWI each time we need it
        SWI     XParallel_HardwareAddress
        Return  "v1,v2",, VS
        STRVar  a1, ip, ParallelHardwareAddress, lr

        ; Disable keyboard port
        MOV     a4, #IOMD_Base
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a1, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRB    a1, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        AND     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRVar  a2, ip, OldKeyboardIRQBits, a1

        LDRB    a2, [a4, #IOMD_KBDCR]
        AND     a2, a2, #IOMD_KBDCR_Enable    ; no way to read the state of the other control bits
        STRVar  a2, ip, OldKeyboardEnable, a1 ; so just assume they were clear
      [ PCB = 4
        MOV     a1, #0                  ; clear state machine
        STRB    a1, [a4, #IOMD_KBDCR]
        MOV     a1, #2                  ; wait for state tick
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        MOV     a1, #IOMD_KBDCR_Enable  ; reenable state machine
        STRB    a1, [a4, #IOMD_KBDCR]
        MOV     a1, #2                  ; wait for state tick
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        MOV     a1, #&FF                ; PS/2 reset command
        STRB    a1, [a4, #IOCSERTX]
        LDR     a1, =34000              ; Zzzzzzzzzzzzzzzzzzzzzzz.....
        BL      WaitSemimicroseconds
        MOV     a4, #IOMD_Base
        LDRB    a1, [a4, #IOMD_KBDCR]
        TST     a1, #IOMD_KBDCR_RxF     ; have we recived an ack from a genuine PS/2 device?
        MOVNE   a1, #0                  ; no, so exit without error, without registering
        BNE     %FT96
        MOV     a1, #0                  ; start in printer mode, I²C data high
      |
      [ PCB = 2 :LOR: PCB = 3
        MOV     a1, #0                  ; clock line must start high (not pulled low)
        STRVar  a1, ip, SoftCopyKBDCR, lr
      |
        MOV     a1, #IOMD_KBDCR_Nclock
      ]
      ]
        STRB    a1, [a4, #IOMD_KBDCR]

        ; Set up interfaces so we can talk to the Zoran chip
        BL      ActivateDongle
        TEQ     a1, #0
      [ PCB = 4
        BEQ     %FT30
        ADRVar  a2, ip, IICNoAckError
        TEQ     a1, a2                  ; if Zoran not detected,
        MOVEQ   a1, #0                  ;   then swallow error
        B       %FT95                   ; don't register our services either way
30      MOV     a1, #InterfaceFlags_DongleFitted
        ADRVar  a2, ip, Interface
        STR     a1, [a2, #Interface_Flags]
      |
        Return  "v1,v2",, NE
      ]

        ; Reset the Zoran chip
      [ PCB >= 2
        MOV     a1, #0                  ; data lines must start all zero
        STRVar  a1, ip, SoftCopyData, lr
      ]
      [ PCB = 4
        LDRVar  v2, ip, SoftCopyCtrl
        BIC     a2, v2, #pp_ctrl_irqen :OR: pp_ctrl_init
       ]
        LDR     lr, ParallelHardwareAddress_Indirect
        LDR     ip, [ip, lr]            ; ip = ParallelHardwareAddress
      [ PCB >= 2
        STRB    a1, [ip, #pp_data]
      ]
      [ PCB <= 3
        MOV     a2, #pp_ctrl_slctin
      ]
        STRB    a2, [ip, #pp_ctrl]
        MOV     a1, #26                 ; 160 ticks of 12.288 MHz clock = 13 µs
        BL      WaitSemimicroseconds
      [ PCB = 4
        STRB    v2, [ip, #pp_ctrl]
      |
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    a2, [ip, #pp_ctrl]
      ]
        MOV     a1, #3
        BL      WaitSemimicroseconds    ; 16 ticks of 12.288 MHz clock = 1.5 µs

 [ PCB >= 3

        ; Set up the PLLs in the Zoran- assume 48kHz sampling
        LDR     a1, =(6:SHL:10) :OR: (&18:SHL:5) :OR: (0:SHL:0)
        ADR     a2, PLLTAB_Params
        BL      ZoranPara_Command

        SUB     sp, sp, #4
        LDR     a1, =(1:SHL:10) :OR: (&19:SHL:5) :OR: (1:SHL:0)
        ADR     a2, PLLCFG_Params1
        MOV     a3, sp
        BL      ZoranPara_Command

        MOV     v2, #1000
80      LDR     a1, =(1:SHL:10) :OR: (&19:SHL:5) :OR: (1:SHL:0)
        ADR     a2, PLLCFG_Params2
        MOV     a3, sp
        BL      ZoranPara_Command
        LDRB    a1, [sp]
        AND     a1, a1, #3
        TEQ     a1, #3
        SUBNES  v2, v2, #1
        BNE     %BT80
        ADD     sp, sp, #4
        TEQ     v2, #0
        BEQ     %FT90                   ; timed out

        B       %FT00
        LTORG
PLLTAB_Params
        DCB     0, 2, 0, 1, 9, 33
PLLCFG_Params1
        DCB     3
PLLCFG_Params2
        DCB     0
        ALIGN
00

 |

        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    a2, [ip, #pp_ctrl]
      [ RnW
        MOV     a1, #16
        BL      WaitSemimicroseconds
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a2, [ip, #pp_ctrl]
        MOV     a1, #16
        BL      WaitSemimicroseconds
      ]

        ; Set up the PLLs in the Zoran - assume 48kHz sampling until we know otherwise
        ; Very slowly now, we don't want to confuse the poor thing
        MOV     a1, #&98                ; PLLTAB
        BL      WriteByteSlowly
        MOV     a1, #0                  ; AUDD[12:8]
        BL      WriteByteSlowly
        MOV     a1, #2                  ; AUDD[7:0]
        BL      WriteByteSlowly
        MOV     a1, #0                  ; AUDM[12:8]
        BL      WriteByteSlowly
      [ PCB >= 2
        MOV     a1, #1                  ; AUDM[7:0]
      |
        MOV     a1, #3                  ; AUDM[7:0]
      ]
        BL      WriteByteSlowly


; 33MHz
;        MOV a1, #26
;        BL      WriteByteSlowly
;        MOV a1, #35
;        BL      WriteByteSlowly
; 66MHz
;        MOV a1, #13
;        BL      WriteByteSlowly
;        MOV a1, #35
;        BL      WriteByteSlowly

; 90MHz
        MOV     a1, #9                  ; DSPD
        BL      WriteByteSlowly
      [ PCB >= 2
        MOV     a1, #33                 ; DSPM
      |
        MOV     a1, #66                 ; DSPM
      ]
        BL      WriteByteSlowly

; 100MHz
;        MOV a1, #16
;        BL      WriteByteSlowly
;        MOV a1, #65
;        BL      WriteByteSlowly

; 110MHz
;        MOV a1, #13
;        BL      WriteByteSlowly
;        MOV a1, #58
;        BL      WriteByteSlowly



        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
; BREG a1, "PLLTAB:", cc
        MOV     a1, #&99                ; PLLCFG
        BL      WriteByteSlowly
        MOV     a1, #&03                ; Parameter 1
        BL      WriteByteSlowly
        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
; BREG a1, " PLLCFG:", cc
; MOV a1, #0
; BL WriteByteSlowly
; BL ReadByteSlowly
; BREG a1, " ", cc
        ; Wait for the PLLs to lock
        ; Each time round the loop takes ~100µs, so 1000 times is a 0.1s timeout
        MOV     v2, #1000
80      MOV     a1, #&99                ; PLLCFG
        BL      WriteByteSlowly
        MOV     a1, #&00                ; Parameter 1
        BL      WriteByteSlowly
        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
; Push "a1"
; BREG a1, " ", cc
; MOV a1, #0
; BL WriteByteSlowly
; BL ReadByteSlowly
; BREG a1, " ", cc
; Pull "a1"
        AND     a1, a1, #3
        TEQ     a1, #3
        SUBNES  v2, v2, #1
        BNE     %BT80
        TEQ     v2, #0
        BEQ     %FT90                   ; timed out

        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]

 ]

        MOV     a1, #100
        BL      WaitSemimicroseconds

        ; Call generic Zoran code to continue initialisation
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Init              ; corrupts ip, may return error
        TEQ     a1, #0
        BNE     %FT95

        ; Finished talking to Zoran chip
        StaticBaseFromSL ip
        BL      DeactivateDongle        ; preserves a1

        ; Register our availability
        MOV     a1, #0                  ; register MPEG decoder
        ADR     a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #1                  ; register AC-3 decoder
        ADR     a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #0                  ; no error
        Return  "v1,v2"

90      ; Error: PLL did not lock
        ADR     a1, AudioLockMessageToken
        LDR     a2, =&81850C
        MOV     a3, #0
        BL      Mess_GenerateError
        ; drop through to general error exit...
95
        StaticBaseFromSL ip
        BL      DeactivateDongle
96      BL      RestoreKeyboardPort
        Return  "v1,v2"

AudioLockMessageToken
        =       "Err_NoAudioPLLLock", 0
        ALIGN

WaitSemimicroseconds
        ; In: a1 = number of 2 MHz ticks to wait
        ; Out: a1-a4 corrupted
        Entry
        SUB     a1, a1, #1              ; subtract 1 so that completion condition is it going -ve
        MOV     a2, #0                  ; a2 holds old timer count (zero-init forces wrap case)
        MOV     lr, #IOMD_Base
01      STRB    lr, [lr, #Timer0LR]
        LDRB    a3, [lr, #Timer0CL]
        LDRB    a4, [lr, #Timer0CH]
        ORR     a3, a3, a4, LSL #8      ; a3 = new timer count
        SUBS    a2, a3, a2              ; difference (>= 0 means we have wrapped or not ticked)
        ADDMIS  a1, a1, a2              ; subtract any tick count from total - have we finished?
        MOVPL   a2, a3                  ; old timer count := new timer count
        BPL     %BT01
        EXIT

 [ PCB <= 2
WriteByteSlowly
        ; In: a1 = byte to write
        ;     ip = parallel hardware address
        ; Out: a1-a4 corrupted
        Entry
        STRB    a1, [ip, #pp_data]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
        EXIT

ReadByteSlowly
        ; In: ip = parallel hardware address
        ; Out: a1 = byte result
        ;      a2-a4 corrupted
        Entry   "v1"
      [ RnW
        MOV     a1, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
      |
        MOV     a1, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_autofd
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
      ]
        LDRB    v1, [ip, #pp_data]
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]
      [ {TRUE};:LNOT: RnW
        MOV     a1, #128;64;32;16
        BL      WaitSemimicroseconds
      ]
        MOV     a1, v1
        EXIT
 ]


; _kernel_oserror *ZoranPara_Final (void);

        EXPORT  ZoranPara_Final
ZoranPara_Final
        FunctionEntry "v1"
        ; Call generic Zoran code to start finalisation (note dongle is in pass-through mode)
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Final
        TEQ     a1, #0
        Return  "v1",, NE

        ; Passed last point when failure to finalise can happen - now deregister ourselves
        StaticBaseFromSL ip
        ADRVar  lr, ip, Interface
        LDR     v1, [lr, #Interface_TopLevel]

        MOV     a1, #0                  ; deregister MPEG decoder
        ADRL    a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        MOV     a1, #1                  ; deregister AC-3 decoder
        ADRL    a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        ; Restore keyboard port
        BL      RestoreKeyboardPort

        MOV     a1, #0                  ; no error
        Return  "v1"


; ActivateDongle - switch dongle to codec mode
;   in:  ip = static base
;   out: r0 -> error block, or 0 for no error
;        other registers preserved

ActivateDongle
        Entry   "a2-a4"
      [ PCB = 4
        ; Set up everything needed in case we have to bail out (so that caller can safely call DeactivateDongle)
        MOV     a3, #IOMD_Base
        LDRB    a2, [a3, #IOCIRQMSKA]
        AND     a2, a2, #IOMDr_printer_IRQ_bit
        STRVar  a2, ip, OldParallelIRQBit, a1
        LDRVar  a1, ip, ParallelHardwareAddress
        LDRB    a2, [a1, #pp_ctrl]
        STRVar  a2, ip, OldParallelCtrl, lr
      ]

        ; Check parallel port isn't in use
        MOV     a1, #OSFind_OpenOut :OR: open_mustopen :OR: open_nodir
        ADR     a2, ParallelColon
        SWI     XOS_Find
        EXIT    VS
        STRVar  a1, ip, ParallelFileHandle, lr

        ; Disable parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a1, a4, #I32_bit :OR: F32_bit
        ORR     lr, a4, #I32_bit
        MSR     CPSR_c, a1              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a1, a2, #IOMDr_printer_IRQ_bit
        STRB    a1, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; just IRQs off while we mess with other stuff
        AND     a2, a2, #IOMDr_printer_IRQ_bit
        STRVar  a2, ip, OldParallelIRQBit, a1

        LDRVar  a1, ip, ParallelHardwareAddress
      [ PCB = 4
        LDRVar  a2, ip, OldParallelCtrl
        BIC     a2, a2, #pp_ctrl_irqen :OR: pp_ctrl_slctin      ; I²C clock starts high, leave other lines the same until we're sure dongle is present
        STRVar  a2, ip, SoftCopyCtrl, lr        ; we need this so we can tentatively drive the slctin line without affecting any others
      |
        LDRB    a2, [a1, #pp_ctrl]
        STRVar  a2, ip, OldParallelCtrl, lr
        BIC     a2, a2, #pp_ctrl_irqen
      ]
        STRB    a2, [a1, #pp_ctrl]

        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ClaimDeviceVector   ; let any pending IRQ (!?) drop through into our handler

        ; Enable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
      [ PCB = 4
        MOV     a1, #IOMD_KBDCR_Ndata   ; go to audio mode, I²C data high
      |
      [ PCB >= 2
        LDRVar  a1, ip, SoftCopyKBDCR
        ORR     a1, a1, #IOMD_KBDCR_Ndata
        STRVar  a1, ip, SoftCopyKBDCR, lr
      |
        MOV     a1, #IOMD_KBDCR_Ndata
      ]
      ]
        STRB    a1, [a3, #IOMD_KBDCR]

      [ PCB = 4
        MSR     CPSR_c, a4              ; restore IRQs

        ; Check for Zoran's acknowledge on I²C bus
        MOV     a1, #zr38601_i2c_addr
        MOV     a2, #0
        MOV     a3, #0
        BL      IIC_Op
        EXIT    VS
      ]

      [ PCB >= 3
        ; Initialise parallel control lines (older code would do this by virtue of sending a command)
      [ PCB = 4
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRVar  a2, ip, SoftCopyCtrl, lr; byte toggle starts high, but strobe is inverting
      |
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
      ]
        LDRVar  a1, ip, ParallelHardwareAddress
        STRB    a2, [a1, #pp_ctrl]
      ]

      [ PCB < 4
        MSR     CPSR_c, a4              ; restore IRQs
      ]
        MOV     a1, #0
        EXIT

ParallelColon
        =       "Parallel:", 0
        ALIGN


; DeactivateDongle - switch dongle to pass-through mode
;   in:  ip = static base
;   out: all registers preserved

DeactivateDongle
        Entry   "a1-a4"
        ; Disable parallel IRQs in the control register -
        ; avoids any messy issues with the control handover
        LDRVar  a4, ip, ParallelHardwareAddress
        LDRVar  a2, ip, OldParallelCtrl
        BIC     a2, a2, #pp_ctrl_irqen
        STRB    a2, [a4, #pp_ctrl]

        ; Disable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
      [ PCB = 4
        MOV     a1, #0                  ; go to printer mode, I²C data high
      |
      [ PCB >= 2
        LDRVar  a1, ip, SoftCopyKBDCR
        BIC     a1, a1, #IOMD_KBDCR_Ndata
        STRVar  a1, ip, SoftCopyKBDCR, lr
      |
        MOV     a1, #IOMD_KBDCR_Nclock
      ]
      ]
        STRB    a1, [a3, #IOMD_KBDCR]

        ; Hand back the parallel port
        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ReleaseDeviceVector

        MOV     a3, #IOMD_Base
        LDRVar  a1, ip, OldParallelIRQBit
        MRS     lr, CPSR
        ORR     a2, lr, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        ORR     a2, a2, a1
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; restore IRQ/FIQ state

        LDRVar  a1, ip, OldParallelCtrl
        STRB    a1, [a4, #pp_ctrl]

        ; Release filing system lock
        MOV     a1, #0
        LDRVar  a2, ip, ParallelFileHandle
      [ PCB = 4
        TEQ     a2, #0                  ; has it been initialised?
        SWINE   XOS_Find
      |
        SWI     XOS_Find
      ]
        EXIT


; RestoreKeyboardPort - called both from initialisation failure and finalisation
;   out: a2-a4,ip corrupted

RestoreKeyboardPort
        Entry   "a1"
        StaticBaseFromSL ip
        MOV     a4, #IOMD_Base
        LDRVar  a1, ip, OldKeyboardEnable
        STRB    a1, [a4, #IOMD_KBDCR]

        LDRVar  a1, ip, OldKeyboardIRQBits
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        ORR     a2, a2, a1
        STRB    a2, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        EXIT


; _kernel_oserror *ZoranPara_Peek (const char *arg_string);

        EXPORT  ZoranPara_Peek
ZoranPara_Peek
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
      [ PCB = 4
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
      ]
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
      [ PCB = 4
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
      |
        ADDNE   sp, sp, #4
        Return  "v1",, NE
      ]
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_Peek

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"

StarCommandWithNoDongle
        ADR     a1, DongleNotFittedToken
        LDR     a2, =&818513
        MOV     a3, #0
        BL      Mess_GenerateError
        ADD     sp, sp, #4
        Return  "v1"

DongleNotFittedToken
        =       "Err_DongleNotFitted", 0
        ALIGN


; _kernel_oserror *ZoranPara_Poke (const char *arg_string);

        EXPORT  ZoranPara_Poke
ZoranPara_Poke
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
      [ PCB = 4
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
      ]
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
      [ PCB = 4
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
      |
        ADDNE   sp, sp, #4
        Return  "v1",, NE
      ]
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_Poke

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"


; _kernel_oserror *ZoranPara_VCXO (const char *arg_string);

        EXPORT  ZoranPara_VCXO
ZoranPara_VCXO
        FunctionEntry "a1,v1"
        StaticBaseFromSL ip
      [ PCB = 4
        ADRVar  a1, ip, Interface
        LDR     a1, [a1, #Interface_Flags]
        TST     a1, #InterfaceFlags_DongleFitted
        BEQ     StarCommandWithNoDongle
      ]
        LDRVar  v1, ip, InUseSemaphore
        TEQ     v1, #0
        BNE     %FT01
        BL      ActivateDongle
        TEQ     a1, #0
      [ PCB = 4
        BEQ     %FT01
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"
      |
        ADDNE   sp, sp, #4
        Return  "v1",, NE
      ]
01
        StaticBaseFromSL ip
        LDR     a1, [sp]
        ADRVar  a2, ip, Interface       ; set up necessary extra parameter
        BL      Zoran_VCXO

        StaticBaseFromSL ip
        TEQ     v1, #0
        BLEQ    DeactivateDongle
        Return  "a1,v1"



; _kernel_oserror * (*establish) (unsigned int flags, void *handle, void **session_id);

ZoranPara_EstablishMPA
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishMPA
        B       %FT10
ZoranPara_EstablishAC3
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishAC3
10
        StaticBaseFromSL ip
        LDRVar  a4, ip, InUseSemaphore
        TEQ     a4, #0                  ; already in use?
        ADRNE   a1, InUseError
        Return  "v1",, NE               ; exit if so

        ; Activate dongle
        Push    "a1"
        BL      ActivateDongle
        TEQ     a1, #0
      [ PCB = 4
        BEQ     %FT20
        BL      DeactivateDongle
        ADD     sp, sp, #4
        Return  "v1"                     ; pass back any error
20
      |
        ADDNE   sp, sp, #1*4
        Return  "v1",, NE                ; pass back any error
      ]

        ; Exchange handles
        ADRVar  a4, ip, Interface
        STR     a2, [a4, #Interface_TopLevelHandle]
        STR     a4, [a3]

        ; Call generic code
        Pull    "a1"
        MOV     a2, a4
        MOV     lr, pc
        MOV     pc, v1                  ; call Zoran_EstablishMPA or Zoran_EstablishAC3
        StaticBaseFromSL ip
        TEQ     a1, #0
        BNE     %FT90                   ; error exit

        MOV     a4, #1
        STRVar  a4, ip, InUseSemaphore, lr ; set in-use semaphore
        Return  "v1"                    ; exit with a1=0

90      BL      DeactivateDongle
        Return  "v1"

InUseError
        &       &81850F                 ; errno_AUDIO_IN_USE
        =       "No suitable audio decoder available", 0
        ; No point in internationalising, because string is ignored by AudGeneric
        ALIGN


; _kernel_oserror * (*annul) (unsigned int flags, void *session_id);

ZoranPara_Annul
        FunctionEntry
        ; Call generic code
        BL      Zoran_Annul
        TEQ     a1, #0
        Return  ,, NE                   ; bail out now if error

        StaticBaseFromSL ip
        BL      DeactivateDongle

        MOV     a4, #0
        STRVar  a4, ip, InUseSemaphore, lr

        Return                          ; exit with a1=0


; _kernel_oserror * (*discontinue) (unsigned int flags, void *session_id);

ZoranPara_Discontinue
        FunctionEntry
        ; Call generic code
        BL      Zoran_Discontinue
        TEQ     a1, #0
        Return  ,, NE                   ; bail out if error

        ; Mask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

 [ :LNOT: Microcode
        ; Release TickerV
        StaticBaseFromSL ip
        MOV     a1, #TickerV
        ADR     a2, TickerHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_Release
 ]

        MOV     a1, #0
        Return                          ; exit with a1=0


; _kernel_oserror * (*readsysteminfo) (unsigned int tag, unsigned int *result);

ZoranPara_ReadSystemInfo
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_ReadSystemInfo


; _kernel_oserror * (*consumedata) (unsigned int flags, void *session_id, unsigned char *start, unsigned int length, unsigned int *not_consumed);

ZoranPara_ConsumeData
        LDR     ip, [a2, #Interface_Flags]
        TST     ip, #InterfaceFlags_ReceivingCharacterisationData
        BNE     %FT50

        ; Normal decoding case: send to hardware
 [ PCB >= 2
        FunctionEntry
        StaticBaseFromSL ip
        LDRVar  a2, ip, StuffingBytesRemaining
        SUBS    a1, a4, a2
        MOVMI   a1, #0                  ; a1 = amount available that won't fit into data burst
        LDR     lr, [sp, #1*4]          ; retrieve not_consumed pointer
        STR     a1, [lr]
        SUBS    a1, a4, a1              ; a1 = bytes we're actually going to transfer
        SUBNE   a2, a2, a1
        STRVar  a2, ip, StuffingBytesRemaining, lr, NE
        MOVNE   a2, a3
        BLNE    IntConsumeData
        MOV     a1, #0                  ; no error
        Return
 |
        FunctionEntry "v1,v2,v3,v4,v6,sl,fp"
        StaticBaseFromSL v6             ; R9 = static base
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base
        LDRVar  a1, v6, StuffingBytesRemaining
        SUBS    v4, a4, a1
        MOVMI   v4, #0                  ; v4 = amount available that won't fit into fifo
        SUBS    a1, a4, v4              ; R0 = bytes we're actually going to transfer
        BEQ     %FT49
        MOV     a2, a3                  ; R1 = address pointer
        MOV     a3, #0
        STRVar  a3, v6, Aborted, lr     ; clear aborted flag

        LDR     v1, ParallelSemaphore_Indirect
        MRS     v2, CPSR
        MOV     v3, a4                  ; keep original length in case we're aborted
        ORR     lr, v2, #I32_bit
        MSR     CPSR_c, lr              ; IRQs off
        ADR     lr, SendBlock_return_address
        STR     lr, [v6, v1]            ; set the semaphore
        B       SendBlock               ; do the transfer
SendBlock_return_address
        MOV     a1, #0
        STR     a1, [v6, v1]            ; clear the semaphore
        MSR     CPSR_c, v2
        LDRVar  a1, v6, Aborted
        LDR     lr, [sp, #8*4]          ; retrieve not_consumed pointer
        TEQ     a1, #0
        STRNE   v3, [lr]
        STREQ   v4, [lr]
        LDRVar  a1, v6, StuffingBytesRemaining, EQ
        SUBEQ   a1, a1, v3 ; take off the amount available
        ADDEQ   a1, a1, v4 ; put back the amount available that won't fit (not using SUBS above allows us to keep using condition flags)
        STRVar  a1, v6, StuffingBytesRemaining, lr, EQ
        MOV     a1, #0                  ; no error
        Return  "v1,v2,v3,v4,v6,sl,fp"

49      LDR     lr, [sp, #8*4]          ; retrieve not_consumed pointer
        STR     a4, [lr]                ; nothing consumed (either length or StuffingBytesRemaining was 0)
        MOV     a1, #0                  ; no error
        Return  "v1,v2,v3,v4,v6,sl,fp"
 ]

50      ; Normal characterising case: send to recogniser via the generic Zoran code
        TST     ip, #InterfaceFlags_Characterising
        BNE     Zoran_ConsumeData       ; pass data on to characteriser

        ; A rare case where the characteriser reaches recognition at the very end of
        ; the previous block, and the buffer manager has sent another block
        LDR     a2, [sp, #4*0]          ; retrieve not_consumed pointer
        STR     a4, [a2]                ; have not consumed any of the new data
        MOV     a1, #0                  ; no error
        Return  , LinkNotStacked


; extern void ZoranPara_UnmaskStuffingIRQ (void);

ZoranPara_UnmaskStuffingIRQ
        FunctionEntry
        StaticBaseFromSL ip

        ; State initialisation
 [ Microcode
        MOV     a1, #0                  ; don't send anything before the first interrupt
 |
        MOV     a1, #fifo_size          ; FIFO is initially empty and must be serviced from TickerV
 ]
        STRVar  a1, ip, StuffingBytesRemaining, lr

        ; Unmask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        ORR     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

 [ :LNOT: Microcode
        ; Claim TickerV
        MOV     a1, #TickerV
        ADR     a2, TickerHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_Claim
 ]

     Push "r0,r1"
     MOV     r0, #IOMD_Base
     MOV     r1, #IOMDr_printer_IRQ_bit
     STRB    r1, [r0, #IOCIRQCLRA]
     Pull "r0,r1"

       Return


 [ Microcode

        ; IRQs are disabled on entry to ParallelIRQHandler
ParallelIRQHandler
        Entry   "r1"
        ; Drop into SVC mode and set up APCS module environment
        WritePSRc I_bit+SVC_mode, lr,, r1
        Push    "r0-r11, lr_svc"
        MOV     sl, sp, LSR #20
        MOV     sl, sl, LSL #20
        LDMIA   sl, {v1, v2}
        Push    "v1, v2"
        LDMIB   r12, {v1, v2}
        STMIA   sl, {v1, v2}
        ADD     sl, sl, #540
        MOV     fp, #0

        SUB     sp, sp, #4              ; allocate one word of scratch workspace on stack

        StaticBaseFromWP r9, r12

; MOV a1, #'i'
 [ Debugging=1 :LAND: DebugToScreen=1
 IMPORT DWrite_WriteC
 ]
; BL DWrite_WriteC

        ; Always acknowledge the interrupt
        MOV     r0, #IOMD_Base
        MOV     r1, #IOMDr_printer_IRQ_bit
        STRB    r1, [r0, #IOCIRQCLRA]

; ToggleLED

        MOV     a1, #0
        BL      ZoranPara_CompleteInterruptedOp

        LDRVar  v1, v6, ParallelHardwareAddress
        ADRVar  v2, v6, Interface
        LDR     v3, [v2, #Interface_TopLevelHandle]

        ; Check how much data is available
        MOV     a1, #0
        MOV     a2, v3
        MOV     a3, sp
        MOV     lr, pc
        LDR     pc, [v2, #Interface_HowMuchData]
        LDR     v4, [sp]                ; v4 = amount available to be stuffed
; MOV v4, #0

        CMP     v4, #fifo_size
        MOVCS   v4, #fifo_size          ; cap by maximum the microcode will accept
        BIC     v4, v4, #1              ; ensure a whole number of 16-bit words
        STRVar  v4, v6, StuffingBytesRemaining, lr

        ; Send two-byte header
        MOV     a1, #&42
        ORR     a1, a1, v4, LSL #7
        STR     a1, [sp]
        MOV     a2, sp
        MOV     a1, #2
        BL      IntConsumeData

        ; Fetch some data
        TEQ     v4, #0
        MOVNE   a1, #1                  ; wrap in PES packets
        MOVNE   a2, v3
        MOVNE   lr, pc
        LDRNE   pc, [v2, #Interface_GiveMeData] ; call the appropriate givemedata()

90      ; Send flushing data
        MOV     a1, #-1
        STR     a1, [sp]
        MOV     a2, sp
        MOV     a1, #4
        BL      IntConsumeData

; ToggleLED

        ; Tidy up and exit
        ADD     sp, sp, #4
        Pull    "v1, v2"
        SUB     sl, sl, #540
        STMIA   sl, {v1, v2}
        Pull    "r0-r11, lr_svc"
        RestPSR r1              ; back to original processor mode
        EXIT

 |

        ; IRQs are disabled on entry to both TickerHandler and ParallelIRQHandler
TickerHandler
        Entry   "r0-r1, r9"
        StaticBaseFromWP r9, r12
        ; Set and check semaphore, exit if set
        ADRVar  r1, r9, StuffingSemaphore
        MOV     r0, #1
        SWP     r0, r0, [r1]
        TEQ     r0, #0
        EXIT    NE
        ; We can write the remaining part of the FIFO, if any
        LDRVar  r0, r9, StuffingBytesRemaining
        TEQ     r0, #0
        MOVEQ   r0, #fifo_size
        STRVar  r0, r9, StuffingBytesRemaining, lr, EQ
        B       CommonStuffingCode
TickerHandler_Abort
        MOV     r0, #0
        STRVar  r0, r9, StuffingSemaphore, lr
        EXIT

ParallelIRQHandler
        ALTENTRY
        StaticBaseFromWP r9, r12
        ; Always acknowledge the interrupt
        MOV     r0, #IOMD_Base
        MOV     r1, #IOMDr_printer_IRQ_bit
        STRB    r1, [r0, #IOCIRQCLRA]
        ; Set and check semaphore, exit if set
        ADRVar  r1, r9, StuffingSemaphore
        MOV     r0, #1
        SWP     r0, r0, [r1]
        TEQ     r0, #0
        EXIT    NE
        ; We can write a whole FIFO full
        MOV     r0, #fifo_size
        STRVar  r0, r9, StuffingBytesRemaining, lr
        ; drop through...
CommonStuffingCode
        ; Drop into SVC mode and set up APCS module environment
        WritePSRc I_bit+SVC_mode, lr,, r1
        Push    "r1-r8, r10-r11, lr_svc"
        MOV     sl, sp, LSR #20
        MOV     sl, sl, LSL #20
        LDMIA   sl, {v1, v2}
        Push    "v1, v2"
        LDMIB   r12, {v1, v2}
        STMIA   sl, {v1, v2}
        ADD     sl, sl, #540
        MOV     fp, #0

        MOV     v5, r0                  ; amount left in fifo

        MOV     a1, #0
        BL      ZoranPara_CompleteInterruptedOp

        LDRVar  v1, v6, ParallelHardwareAddress
        ADRVar  v2, v6, Interface
        LDR     v3, [v2, #Interface_TopLevelHandle]
        ; Check some data is available
        SUB     sp, sp, #4
        MOV     a1, #0
        MOV     a2, v3
        MOV     a3, sp
        MOV     lr, pc
        LDR     pc, [v2, #Interface_HowMuchData]
        Pull    "v4"                    ; v4 = amount available to be stuffed
        TEQ     v4, #0
        BEQ     %FT90
01
        CMP     v5, v4
        MOVHI   v5, v4                  ; v5 = amount that will be stuffed this time round loop
        ; Fetch some data
        MOV     a1, #1                  ; wrap in PES packets
        MOV     a2, v3
        MOV     lr, pc
        LDR     pc, [v2, #Interface_GiveMeData] ; call the appropriate givemedata()

        ; Read IRQ status line (actually active high, rather than combo chip's rising edge)
        LDRB    lr, [v1, #pp_stat]
        ADDS    lr, lr, #pp_stat_ack    ; toggle ack bit and clear C flag
        TST     lr, #pp_stat_ack        ; EQ => interrupting
        ; If line still asserted, then ack IRQ again in case it wiggled since last time
        MOVEQ   a2, #IOMD_Base
        MOVEQ   a3, #IOMDr_printer_IRQ_bit
        STREQB  a3, [a2, #IOCIRQCLRA]
        ; If line still asserted *and* givemedata() was successful *and* data still available to be stuffed, then loop
        TEQEQ   a1, #0                  ; no error?
        SUBEQS  v4, v4, v5              ; see how much data is left available to stuff
        MOVHI   v5, #fifo_size          ; HI = C set and Z clear (C set => SUBEQS was executed)
        STRVar  v5, v6, StuffingBytesRemaining, lr, HI
        BHI     %BT01

90      ; Clear semaphore
        MOV     a1, #0
        STRVar  a1, v6, StuffingSemaphore, lr
        ; Tidy up and exit
        Pull    "v1, v2"
        SUB     sl, sl, #540
        STMIA   sl, {v1, v2}
        Pull    "r1-r8, r10-r11, lr_svc"
        RestPSR r1              ; back to original processor mode
        EXIT

 ]


 [ Microcode

; Internal APCS routine to send data unconditionally

; In:  a1 = number of bytes to transfer
;      a2 -> block
; Out: a1 nonzero => aborted

IntConsumeData
 [ PCB >= 2
        TEQ     a1, #0
        MOVEQ   pc, lr
        FunctionEntry "v1,v2"
        StaticBaseFromSL ip
; ToggleLED
        LDRVar  a3, ip, SoftCopyData
      [ PCB = 4
        LDRVar  a4, ip, SoftCopyCtrl
      |
        LDRVar  a4, ip, SoftCopyKBDCR
      ]
        LDRVar  v1, ip, ParallelHardwareAddress
        MOV     ip, #IOMD_Base
        TST     a1, #1
        MOVNE   lr, a3
        BNE     %FT15
10
        LDRB    lr, [a2], #1
; MOV lr, #&42
        TEQ     lr, a3
;  TEQ r0,r0
      [ PCB = 4
      [ SwitchPins
        EOREQ   a4, a4, #pp_ctrl_strobe
      |
        EOREQ   a4, a4, #pp_ctrl_slctin
      ]
        STREQB  a4, [v1, #pp_ctrl]
        STRNEB  lr, [v1, #pp_data]
      |
        EOREQ   a4, a4, #IOMD_KBDCR_Nclock
        STREQB  a4, [ip, #IOMD_KBDCR]           ; if byte repeat, toggle PS/2 clock line
;        EOREQ   v2, a4, #IOMD_KBDCR_Nclock      ; invert bit to make conditionals work!
;        TSTEQ   v2, #IOMD_KBDCR_Nclock          ; if PS/2 line now open drain (not forced low) we need to insert a dummy B-cycle to allow it to rise
;        STRNE   lr, [v1, #pp_data]              ; if a different byte, then write it; if a dummy B-cycle then write unchanged value to the data register
      STR   lr, [v1, #pp_data]              ; if a different byte, then write it; if a dummy B-cycle then write unchanged value to the data register
      ]
15
        LDRB    a3, [a2], #1
; MOV a3, #&42
        TEQ     a3, lr
;  TEQ r0,r0
      [ PCB = 4
      [ SwitchPins
        EOREQ   a4, a4, #pp_ctrl_strobe
      |
        EOREQ   a4, a4, #pp_ctrl_slctin
      ]
        STREQB  a4, [v1, #pp_ctrl]
        STRNEB  a3, [v1, #pp_data]
      |
        EOREQ   a4, a4, #IOMD_KBDCR_Nclock
        STREQB  a4, [ip, #IOMD_KBDCR]           ; if byte repeat, toggle PS/2 clock line
;        EOREQ   v2, a4, #IOMD_KBDCR_Nclock      ; invert bit to make conditionals work!
;        TSTEQ   v2, #IOMD_KBDCR_Nclock          ; if PS/2 line now open drain (not forced low) we need to insert a dummy B-cycle to allow it to rise
;        STRNE   a3, [v1, #pp_data]              ; if a different byte, then write it; if a dummy B-cycle then write unchanged value to the data register
      STR   a3, [v1, #pp_data]              ; if a different byte, then write it; if a dummy B-cycle then write unchanged value to the data register
      ]

        SUBS    a1, a1, #2
        BGT     %BT10
20
        StaticBaseFromSL ip
        STRVar  a3, ip, SoftCopyData, lr
      [ PCB = 4
        STRVar  a4, ip, SoftCopyCtrl, lr
      |
        STRVar  a4, ip, SoftCopyKBDCR, lr
      ]
; ToggleLED
        MOV     a1, #0
        Return  "v1,v2"
 |
        FunctionEntry "v1,v2,v6,sl,fp"
        StaticBaseFromSL v6             ; R9 = static base
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base
        MOV     a3, #0
        STRVar  a3, v6, Aborted, lr     ; clear aborted flag

        LDR     v1, ParallelSemaphore_Indirect
        MRS     v2, CPSR
        ORR     lr, v2, #I32_bit
        MSR     CPSR_c, lr              ; IRQs off
        ADR     lr, SendBlock_IntConsumeData_return_address
        STR     lr, [v6, v1]

        B       SendBlock               ; do the transfer
SendBlock_IntConsumeData_return_address
        MOV     a1, #0
        STR     a1, [v6, v1]            ; clear the semaphore
        MSR     CPSR_c, v2
        LDRVar  a1, v6, Aborted
        Return  "v1,v2,v6,sl,fp"
 ]
 ]


; extern void ZoranPara_Command (unsigned int flags, const char *parameters, char *response);

; flags: bits 5-9 = command-&80
;        bits 10-31 = number of parameters
;        bits 0-4 = number of results
; Executes for the most part in the same IRQ disable state as is set on entry

ZoranPara_Command
 [ PCB >= 3
   [ {TRUE}
        FunctionEntry
        MOV     lr, a1
        AND     a4, lr, #&1F
        MOV     a1, #zr38601_i2c_addr :OR: 1 :OR: 1:SHL:31
        Push    "a1,a3,a4"      ; 4th transfer: read response
        MOV     a4, #2
        MOV     a1, #zr38601_i2c_addr :OR: 1 :OR: 1:SHL:30
        Push    "a1,a3,a4"      ; 3rd transfer: dummy read of two bytes (don't care about values, so use checksum mode)
        MOV     a4, lr, LSR #10
        MOV     a1, #zr38601_i2c_addr :OR: 1:SHL:31
        Push    "a1,a2,a4"      ; 2nd transfer: write parameters
        MOV     a4, #1
        SUB     a3, sp, #4*4
        MOV     a2, #zr38601_i2c_addr
        MOV     a1, #&1F
        AND     a1, a1, lr, LSR #5
        ADD     a1, a1, #&80
        Push    "a1-a4"         ; 1st transfer: write command number
        ADD     a1, sp, #4*1
        MOV     a2, #4
        BL      IIC_OpV
        ADD     sp, sp, #4*13
        Return
   |
        FunctionEntry "a2-a3"

        MOV     a4, a1
        MOV     lr, #&1F
        AND     a1, lr, a4, LSR #5
        ADD     a1, a1, #&80
        Push    "a1"
        MOV     r0, #zr38601_i2c_addr
        MOV     r1, sp
        MOV     r2, #1
      [ PCB = 4
        BL      IIC_Op
      |
        SWI     XIIC_Control
      ]
        ADD     sp, sp, #4

        MOV     r0, #zr38601_i2c_addr
        Pull    "r1"
        MOV     r2, a4, LSR #10
      [ PCB = 4
        BL      IIC_Op
      |
        SWI     XIIC_Control
      ]

        SUB     sp, sp, #4
        MOV     r0, #zr38601_i2c_addr :OR: 1
        MOV     r1, sp
        MOV     r2, #2
      [ PCB = 4
        BL      IIC_Op
      |
        SWI     XIIC_Control
      ]
        ADD     sp, sp, #4

        MOV     r0, #zr38601_i2c_addr :OR: 1
        Pull    "r1"
        AND     r2, a4, #&1F
      [ PCB = 4
        BL      IIC_Op
      |
        SWI     XIIC_Control
      ]

        Return
   ]
 |
        FunctionEntry "v1,v2,v6,sl,fp"
        StaticBaseFromSL v6             ; R9 = static base

 Push "a1-a4,v1,v2,ip"
 MOV a2, #&1F
 AND a1, a2, a1, LSR #5
 ADD a1, a1, #&80
 IMPORT DWrite_WriteHex2
 BL DWrite_WriteHex2
 LDMIA sp, {a1-a4}
 MOV v1, a2
 MOV v2, a1, LSR #10
 TEQ v2, #0
 BEQ %FT02
 ADD v2, v1, v2
01
 LDRB a1, [v1], #1
 BL DWrite_WriteHex2
 CMP v1, v2
 BLT %BT01
02
 LDMIA sp,{a1-a4,v1,v2,ip}

        MOV     ip, a1                  ; R12 = flags
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base

        LDR     v1, ParallelSemaphore_Indirect
        MRS     v2, CPSR
        ORR     lr, v2, #I32_bit
        MSR     CPSR_c, lr              ; IRQs off
        ADR     lr, Command_return_address
        STR     lr, [v6, v1]            ; set the semaphore

        B       Command
Command_return_address
        MOV     a1, #0
        STR     a1, [v6, v1]            ; clear the semaphore
        MSR     CPSR_c, v2

 LDMIA sp,{a1-a4,v1,v2,ip}
 LDR sl, [sp, #4*10]
 MOV v1, a3
 AND v2, a1, #&1F
 TEQ v2, #0
 BEQ %FT02
 ADD v2, v1, v2
01
 LDRB a1, [v1], #1
 BL DWrite_WriteHex2
 CMP v1, v2
 BLT %BT01
02
 MOV a1, #'.'
 IMPORT DWrite_WriteC
 BL DWrite_WriteC
 Pull "a1-a4,v1,v2,ip"

        Return  "v1,v2,v6,sl,fp"
 ]


; extern void ZoranPara_CompleteInterruptedOp (bool abort);

; Operation completed in original IRQ disable state, unless IRQs disabled at this function's entry

; ** For God's sake remember to change this if you change the register list in Kernel.s.NewIRQs!

ZoranPara_CompleteInterruptedOp
 [ PCB >= 3
        MOV     pc, lr
 |
        FunctionEntry "v1,v6"
        StaticBaseFromSL v6             ; R9 = static base
        MOV     ip, a1

        ; Check our semaphore
        LDR     v1, ParallelSemaphore_Indirect
        MRS     a4, CPSR
        ORR     a3, a4, #I32_bit :OR: 1:SHL:4 ; IRQs off and force 32-bit mode
        MSR     CPSR_c, a3
        LDR     a1, [v6, v1]
        TEQ     a1, #0                  ; semaphore set?
01      MSREQ   CPSR_c, a4              ; no, so quick exit
        Return  "v1,v6",, EQ

; Push "a1-a4,ip,lr"
; MOV a1, #'x'
; IMPORT DWrite_WriteC
; BL DWrite_WriteC
; Pull "a1-a4,ip,lr"
        ; Locate interrupted code on IRQ stack
        MOV     a3, #IRQsema
02      LDR     a3, [a3]
        TEQ     a3, #0
        BEQ     %BT01                   ; shouldn't happen, but if we can't find code, exit
        LDR     a2, [a3, #4*8]          ; interrupted PC
        RSB     lr, pc, a2
        CMP     lr, #interrupt_protected_end - 4 - CompleteInterruptedOp_pc_reference
CompleteInterruptedOp_pc_reference      ; must be 8 bytes after the RSB lr,pc,a2
        RSBLES  lr, lr, #interrupt_protected_start - CompleteInterruptedOp_pc_reference
        BGT     %BT02

        ; Mark the foreground operation as complete, then actually complete it
        Push    "a4,v2,sl,fp"
        ADR     lr, CompleteInterruptedOp_return_address
        STR     lr, [v6, v1]            ; set up our own semaphore, in case another interrupt happens
        STR     a1, [a3, #4*8]          ; poke IRQ stack so as to return to old semaphore
        LDR     a1, [a3, #4*6]          ; get interrupted CPSR
        TST     a4, #I32_bit            ; if IRQs were off on entry to CompleteInterruptedOp
        ORRNE   a1, a1, #I32_bit        ;   then don't open an interrupt hole
        MSR     SPSR_cxsf, a1           ; stick it in SPSR (okay, because IRQs are off)
        MOV     a1, #I32_bit :OR: SVC32_mode ; (SVC32 is available on all processors)
        STR     a1, [a3, #4*6]          ; ensure IRQs are off when we return to foreground
        MOV     v2, a2                  ; move interrupted PC to a safe register
        TEQ     ip, #0                  ; are we aborting?
        LDREQ   a1, [a3, #4*7]          ; retrieve interrupted R0 if not
        MOVNE   a1, #0                  ; else zero R0
        LDMIB   a3, {a2-a4, fp, ip}     ; retrieve interrupted R1-R3, R11, R12
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base
        MOVS    pc, v2                  ; copy SPSR to CPSR and jump back to interrupted code
CompleteInterruptedOp_return_address
        MOV     a1, #0
        Pull    "a4,v2,sl,fp"
        MSR     CPSR_c, a4              ; restore entry IRQ disable state and 26/32-bitness
        Return  "v1,v6"
 ]


 [ PCB <= 2
interrupt_protected_start

        MACRO
        Rpt     $instruction, $times
        LCLA    Times
      [ "$times" = ""
Times   SETA    1
      |
Times   SETA    $times
      ]
        WHILE   Times > 0
        $instruction
Times   SETA    Times - 1
        WEND
        MEND

; Command - execute a Zoran command
;
;   On entry:
;               R1 -> parameters
;               R2 -> response buffer
;               R5 = CPSR to execute routine with
;               R9 = static base
;               R10 = parallel base
;               R12 = flags
;               R14 = return address (not including any PSR bits)
;               SVC mode, IRQs disabled
;   During routine:
;               R1, R2, R3, R11, R12 are the only available general-purpose registers
;               R9, R10 must not be modified (may randomly be reset to static and parallel bases)
;               R14 always contains the return address, though it may change during the function
;               CPSR flag bits are not volatile
;               Other registers are volatile and must not be used (no stack is available)
;   On exit:
;               Must exit in SVC32 mode with IRQs disabled
;               Registers ignored

Command ROUT
        MSR     CPSR_c, R5

        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]

        ; Write opcode byte
        MOV     R3, #&1F
        AND     R3, R3, R12, LSR #5     ; extract opcode bits
        ADD     R3, R3, #&80
        STRB    R3, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
;      MOV R3, #2400 ; 1ms
;00    STRB R11, [R10, #pp_ctrl]
;      SUBS R3, R3, #1
;      BNE %BT00

        ; Write parameter bytes
01      SUBS    R12, R12, #1 :SHL: 10
        BCC     %FT02
        LDRB    R3, [R1], #1
        STRB    R3, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
;      MOV R3, #2400 ; 1ms
;00    STRB R11, [R10, #pp_ctrl]
;      SUBS R3, R3, #1
;      BNE %BT00
        B       %BT01
02      MOV     R12, R12, LSL #27

        ; Write READ command bytes and read response bytes
        MOV     R1, #0
03      SUBS    R12, R12, #1 :SHL: 27
        BCC     %FT04
        STRB    R1, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
;      MOV R3, #2400 ; 1ms
;00    STRB R11, [R10, #pp_ctrl]
;      SUBS R3, R3, #1
;      BNE %BT00

      [ RnW
        MOV     R11, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
      |
        MOV     R11, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_autofd
        STRB    R11, [R10, #pp_ctrl]
      ]
        LDRB    R3, [R10, #pp_data]
  LDRB    R3, [R10, #pp_data]
  LDRB    R3, [R10, #pp_data]
        STRB    R3, [R2], #1
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        B       %BT03


04
      [ PCB = 2
        LDRVar  R11, R9, SoftCopyData
        STRB    R11, [R10, #pp_data]
      ]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        MOV     R1, #240;;;;;;;;;;;;;;;;;;24                 ; we need 10µs delay between commands, so insert an extra 23 B-cycles
05      STRB    R11, [R10, #pp_ctrl]
        SUBS    R1, R1, #1
        BNE     %BT05

        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
        MOV     PC, R14
 ]


 [ PCB = 1
; SendBlock - send contiguous block of data to the Zoran data port
;
;   On entry:
;               R0 = maximum number of transfers to attempt
;               R1 = pointer to byte to start from
;               R5 = CPSR to execute routine with
;               R9 = static base
;               R10 = parallel base
;               R14 = return address (not including any PSR bits)
;               SVC mode, IRQs disabled
;   During routine:
;               R0 = remaining number of transfers to attempt (may be zeroed in the background if
;                 the operation is aborted)
;               R1, R2, R3, R11, R12 are the only available general-purpose registers
;               R9, R10 must not be modified (may randomly be reset to static and parallel bases)
;               R14 always contains the return address, though it may change during the function
;               CPSR flag bits are not volatile
;               Other registers are volatile and must not be used (no stack is available)
;   On exit:
;               Must exit in SVC32 mode with IRQs disabled
;               Registers ignored

SendBlock ROUT
        MSR     CPSR_c, R5

10      LDRB    R3, [R1], #1
        STRB    R3, [R10, #pp_data]
        MOV     R3, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R3, [R10, #pp_ctrl]
        MOV     R3, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    R3, [R10, #pp_ctrl]
        SUBS    R0, R0, #1
        BGT     %BT10

        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
        MOV     PC, R14
 ]

 [ PCB <= 2
interrupt_protected_end
 ]



 [ PCB = 4
; IIC code shamelessly copied from HAL (Kernel-5_35-4_79_2_47)


PollMax		*	150	; Number of times to poll for an Ack (increase if you clock faster - need to
                                ; allow 5ms for write cycle).

I2Cticks        *       3

IICStackAlignment       *       7       ; log2 of stack size, also stack alignment
                                        ; current requirement is 19 words = 2_01001100 bytes

                ^       0
IICLink_Next    #       4
IICLink_Error   #       4
IICLink_Array   #       4
IICLink_Size    #       4

; SVC stack format, in descending address order:
;    16 bytes   first link (also bottom of stacked registers)
;     n bytes   align to address with bottom x bits set
; 2^x-4 bytes   align to address with bottom x bits clear (the local stack)
;     4 bytes   linked list head
;     4 bytes   linked list tail
;     4 bytes   original sp
;      .
;      .
;      .
;    16 bytes   another link (also bottom of stacked registers)
;     4 bytes   original sp

; IRQ stack format, in descending address order, for reference:
;     4 bytes   lr_irq-4 (interrupted PC)
;     4 bytes   r0
;     4 bytes   spsr_irq (interrupted CPSR)
;    20 bytes   r1-r3, r11, r12
;     4 bytes   IRQsema link


iicsp   RN      11
iiclr   RN      12


        MACRO
$label  iicBL   $destination, $cond
$label  MOV$cond iiclr, pc
        B$cond  $destination
        MEND

        MACRO
$label  iicPull $reglist, $cond, $hat
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   "$hat" = ""
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  LDR$cond $reglist, [iicsp], #4
        |
$label  LDM$cond.FD iicsp!, {$reglist}$hat
        ]
        MEND

        MACRO
$label  iicPush $reglist, $cond
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  STR$cond $reglist, [iicsp, #-4]!
        |
$label  STM$cond.FD iicsp!, {$reglist}
        ]
        MEND


; *****************************************************************************

; in:   R0 = device address (bit 0 set => read, clear => write)
;       R1 -> data block
;       R2 = length of data block
;
IIC_Op
        Push    "R0-R2,LR"
        Push    "R0-R2"                 ; soft copy for IIC_OpV to work on
        MOV     R0, R13
        MOV     R1, #1
        BL      IIC_OpV
        ADD     R13, R13, #12           ; junk soft copy
        Pull    "R0-R2,PC",VC
        ADD     R13, R13, #4
        Pull    "R1-R2,PC"

; *****************************************************************************

; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  transfer descriptors may be updated (beware)
;
; transfer descriptor is 3 words: word 0 = device address (+direction)
;                                         (bit 29 signifies retry for response)
;                                         (bit 30 signifies checksum read only - ie fill in word 1 with
;                                          sum of bytes read)
;                                         (bit 31 signifies continued transfer - ie no start or address)
;                                 word 1 -> data block
;                                 word 2 = length of data block
IIC_OpV ROUT
        Push    "r0-r3,r6-r12,lr"
        MOV     lr, #0
        STR     lr, [sp, #-8]!
        StaticBaseFromSL r9
        MRS     r10, CPSR
        BIC     r7, r10, #I32_bit :OR: F32_bit
        ORR     r8, r7, #I32_bit
        MOV     r2, #IRQsema
        MOV     r12, sp                 ; original sp, also pointer to link
        ORR     lr, r8, #2_10000
        MSR     CPSR_c, lr              ; IRQs off, force 32-bit mode

01      LDR     r2, [r2]
        TEQ     r2, #0
        BEQ     %FT50                   ; I²C code not in IRQ stack
        LDR     r6, [r2, #4*8]          ; interrupted PC
IIC_OpV_PCReference
        RSB     lr, pc, r6
        LDR     r0, =(interrupt_protected_end-4) - (IIC_OpV_PCReference+8)
        CMP     lr, r0
        RSBLES  lr, lr, #interrupt_protected_start - (IIC_OpV_PCReference+8)
        BGT     %BT01

        ; I²C code is already threaded
        Push    "r12"                   ; put original sp on stack for our exit routine
        LDR     r0, [r2, #4*4]          ; retrieve interrupted iicsp
        BIC     r0, r0, #(1:SHL:IICStackAlignment)-1
        LDR     r1, [r0, #-8]           ; old list tail
        STR     r12, [r0, #-8]          ; new list tail
        STR     r12, [r1, #IICLink_Next] ; point old link to new link
        ADR     r0, IIC_OpV_CommonExit
        STR     r0, [r2, #4*8]          ; poke IRQ stack so previous operation returns as though completed
        LDR     r0, [r2, #4*6]          ; get interrupted CPSR
        MSR     SPSR_cxsf, r0           ; stick it in SPSR (okay, because IRQs are off)
        LDR     r0, [r2, #4*7]
        LDMIB   r2, {r1-r3,r11,r12}
        MOVS    pc, r6                  ; copy SPSR to CPSR and resume execution

50      ; I²C code not currently threaded - create new environment
        ADD     iicsp, sp, #4
        BIC     iicsp, iicsp, #(1:SHL:IICStackAlignment)-1
        SUB     iicsp, iicsp, #4
        BIC     sp, iicsp, #(1:SHL:IICStackAlignment)-1
        Push    "r12"                   ; list head pointer
        Push    "r12"                   ; list tail pointer
        Push    "r12"                   ; original sp
        LDR     r0, [r12, #IICLink_Array]
        LDR     r1, [r12, #IICLink_Size]
        B       IICStart                ; start working through list

IIC_OpV_CommonExit
        MSR     CPSR_c, r10             ; restore original IRQ disable state
        LDR     sp, [sp]
        ADD     sp, sp, #4              ; skip next pointer
        Pull    "r0"
        CMP     r0, #0
        Pull    "r0-r3,r6-r12,pc", EQ
        SETV
        ADD     sp, sp, #4
        Pull    "r1-r3,r6-r12,pc"


interrupt_protected_start

; Protected routines register usage:
;   r0-r3   general purpose
;    r7     MRS style PSR with c bits = SVC26/32, IRQs/FIQs enabled
;    r8     MRS style PSR with c bits = SVC26/32, IRQs disabled, FIQs enabled
;    r9     module static base
;    r11    stack pointer
;    r12    link register / general purpose
;    CPSR is also non-volatile

IICStart
        MSR     CPSR_c, r7              ; enable IRQs (inside protected code) - this may take some time
        ; drop through...

; *****************************************************************************
;
;       IICLoop - serial-execution outermost loop, stepping along pending IIC operations
;

IICLoop
     iicBL      IICDoOp
        MOVVC   r0, #0
        BIC     r1, iicsp, #(1:SHL:IICStackAlignment)-1
        LDR     r2, [r1, #-4]           ; list head
        STR     r0, [r2, #IICLink_Error] ; set up return value
        MSR     CPSR_c, r8              ; disable IRQs while we work on the list
        LDR     r2, [r2]
        TEQ     r2, #0                  ; end of list?
        BEQ     IIC_OpV_CommonExit      ; finished!
        STR     r2, [r1, #-4]           ; update list head
        MSR     CPSR_c, r7              ; IRQs back on
        LDR     r0, [r2, #IICLink_Array]
        LDR     r1, [r2, #IICLink_Size] ; get next array
        B       IICLoop                 ; and loop

; *****************************************************************************
;
;       IICDoOp - main serial-execution entry point
;
; in:   R0 -> array of transfer descriptors
;       R1 = number of transfers
;
; out:  if V set, r0 -> error block
;       otherwise r0-r3,r12 may be corrupted
;

IICDoOp ROUT
        MOV     R2, #0
     iicPush    "R1,R2,iiclr"           ; two words on stack are RepeatedStart flag and transfers remaining

        MOV     R3, R0

05      LDR     R0, [iicsp]
        SUBS    R0, R0, #1
        BCC     %FT90
        STR     R0, [iicsp]

        LDMIA   R3!, {R0-R2}
        TST     R0, #1:SHL:31           ; skip start?
        BNE     %FT08

        LDR     iiclr, [iicsp, #4]
        TEQ     iiclr, #0
        MOV     iiclr, pc
        ADD     iiclr, iiclr, #8
        BEQ     Start
        BNE     RepeatedStart           ; these are effectively conditional BL's

        TST     R0, #1:SHL:29
        BNE     %FT06
     iicBL      TXAck                   ; transmit device address without retries
        B       %FT07

06
     iicBL      TXPollAck               ; transmit device address with retries
07      BVS     %FT80

08      MOV     iiclr, #1
        STR     iiclr, [iicsp, #4]
        TEQ     R2, #0
        BEQ     %BT05

        TST     R0, #1                  ; Z => write, NZ => read
        BNE     %FT20

; Write case
10      LDRB    R0, [R1], #1            ; read byte from data block
     iicBL      TXAck                   ; transmit, checking for ack
        BVS     %FT80
        SUBS    R2, R2, #1              ; decrement byte count
        BNE     %BT10                   ; loop until finished
        B       %BT05                   ; then next transfer

20      TST     R0, #1:SHL:30           ; checksum?
        BNE     %FT30

; Read case
21
     iicBL      RXByte                  ; read byte from bus
        STRB    R0, [R1], #1            ; store in data block
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT21
        B       %BT05                   ; next transfer

; Checksum case
30      MOV     R1, #0
31
     iicBL      RXByte                  ; read byte from bus
        ADD     R1, R1, R0
        MOV     R0, #1                  ; start with the assumption that it's the last byte, and so shouldn't be acknowledged
        SUBS    R2, R2, #1              ; is it last byte in this descriptor?
        MOVNES  R0, R0, LSR #2          ; no, so definitely needs acknowledging (with 0 bit)
                                        ; now Z is set, and C set => just read last byte for this descriptor
        LDRCS   iiclr, [iicsp]
        TEQCS   iiclr, #0               ; if we've finished this descriptor, check for another transfer descriptor
                                        ; Z clear => last byte, and there is another descriptor
        LDRNE   iiclr, [R3]
        TSTNE   iiclr, #1:SHL:31        ; if appropriate, check if next descriptor is a continuation
        MOVNE   R0, #0                  ; if read is going to continue, we need to acknowledge
     iicBL      ClockData               ; but always send ack clock pulse
        BCC     %BT31
        STR     R1, [R3, #-8]           ; store checksum
        B       %BT05                   ; next transfer

90
     iicBL      Stop
        CLRV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

80
     iicBL      Stop
      [ PCB = 4
        ADRVar  R0, R9, IICNoAckError   ; don't internationalise here for MessageTrans re-entrancy reasons
      ]
        SETV
        ADD     iicsp, iicsp, #8        ; skip junk on stack
     iicPull    "pc"

        MakeInternatErrorBlock IIC_NoAcknowledge, NoAlign, "NoAck:No acknowledge from IIC device"
IICMessagesFile
        =       "Resources:$.Resources.IIC.Messages", 0
        ALIGN

; *****************************************************************************
;
;	SetC1C0 - Set clock and data lines to values in R1 and R0 respectively
;
; out:  r0,r1 corrupted
;

SetC1C0 ROUT
     iicPush    "r2,r3,iiclr"
        TST     r0, #1          ; data high?
        MOVEQ   r0, #IOMD_KBDCR_Ndata :OR: IOMD_KBDCR_Nclock
        MOVNE   r0, #IOMD_KBDCR_Ndata
        MOV     r3, #IOMD_Base
        STRB    r0, [r3, #IOMD_KBDCR]

        LDRVar  r0, r9, ParallelHardwareAddress
        MSR     CPSR_c, r8
        TST     r1, #1          ; clock high?
        LDRVar  r1, r9, SoftCopyCtrl
      [ SwitchPins
        ORREQ   r1, r1, #pp_ctrl_slctin
        BICNE   r1, r1, #pp_ctrl_slctin
      |
        ORREQ   r1, r1, #pp_ctrl_strobe
        BICNE   r1, r1, #pp_ctrl_strobe
      ]
        STRB    r1, [r0, #pp_ctrl]
        STRVar  r1, r9, SoftCopyCtrl, r3
        MSR     CPSR_c, r7

        MOV     R0, #3
     iicBL      iicDoMicroDelay

     iicPull    "r2,r3,pc"

; *****************************************************************************
;
;	ReadC1C0 - Read clock and data lines to  R1 and R0 respectively
;
; out:	R0, R1 updated
;

ReadC1C0 ROUT
        ; PS/2 clock line (IIC data line) has already been
        ; allowed to go open drain, so we need only read it
        MOV     r0, #IOMD_Base
        LDRB    r0, [r0, #IOMD_KBDCR]
        AND     r0, r0, #1
        ; The value of the IIC clock line isn't used, which
        ; is fortunate because we can't read it
        MOV     pc, iiclr

; *****************************************************************************
;
;       iicDoMicroDelay - Delay for >= R0/2 microseconds, IIC calling standard
;
; in:	R0 = time delay in 1/2 microsecond units
;	On ARM600, we may or may not be in a 32-bit mode
;
; out:	R0,R1 corrupted
;

iicDoMicroDelay ROUT
     iicPush    "R2,iiclr"
        MOV     R2, #IOMD_Base
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    R1, [R2, #Timer0CL]     ; R1 := low output latch
10
        STRB    R0, [R2, #Timer0LR]     ; copy counter into output latch
        LDRB    iiclr, [R2, #Timer0CL]  ; iiclr := low output latch
        TEQ     iiclr, R1               ; unchanged ?
        BEQ     %BT10                   ; then loop
        MOV     R1, iiclr               ; copy anyway
        SUBS    R0, R0, #1              ; decrement count
        BNE     %BT10                   ; loop if not finished

     iicPull    "R2,PC"

        LTORG

; *****************************************************************************
;
;	ClockData - Clock a bit of data down the IIC bus
;
; in:	R0 = data bit
;
; out:	All registers preserved, including PSR
;

ClockData ROUT
 [ No26bitCode
     iicPush    "R0-R3,iiclr"
        MRS     R2,CPSR
 |
     iicPush    "R0-R1,R3,iiclr"
 ]
        MOV     R3, R0

	MOV	R1, #0			; Clock lo
     iicBL      SetC1C0

; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling
        MSR     CPSR_c, r8

        MOV     R0, R3
	MOV	R1, #1			; Clock hi
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs

        MOV     R0, R3
	MOV	R1, #0			; Clock lo
     iicBL      SetC1C0

 [ No26bitCode
        MSR     CPSR_cf,R2              ; Restore interrupts and flags
     iicPull    "R0-R3,PC"
 |
     iicPull    "R0-R1,R3,PC",,^
 ]

; *****************************************************************************
;
;	Start - Send the Start signal
;
; out:	All registers preserved, PSR corrupted
;

Start	ROUT
     iicPush    "R0-R1,iiclr"

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	RepeatedStart - Send a Repeated Start signal
;
; out:	All registers preserved, PSR corrupted
;

RepeatedStart	ROUT
     iicPush    "R0-R1,iiclr"

        MOV     R0, #1
        MOV     R1, #0                  ; clock LO, data HI
     iicBL      SetC1C0

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.7 microsecs (1.3 for fast device)

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	Acknowledge - Check acknowledge after transmitting a byte
;
; out:	All registers preserved
;	V=0 => acknowledge received
;	V=1 => no acknowledge received
;

Acknowledge ROUT
     iicPush    "R0-R2,iiclr"

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
     iicBL      SetC1C0

 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

     iicBL      ReadC1C0
        MOV     R2, R0                  ; should be LO for correct acknowledge

	MOV  	R0, #1
	MOV  	R1, #0			; clock LO, data HI
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]

        TST     R2, #1
        MRS     R2, CPSR
	BICEQ	R2, R2, #V_bit		; clear V if correct acknowledge
	ORRNE	R2, R2, #V_bit		; set V if no acknowledge
        MSR     CPSR_f, R2

     iicPull    "R0-R2,PC"

; *****************************************************************************
;
;	Stop - Send the Stop signal
;
; out:	All registers preserved, PSR corrupted
;

Stop	ROUT
     iicPush    "R0-R1,iiclr"

	MOV	R0, #0			; clock LO, data LO
	MOV	R1, #0
     iicBL      SetC1C0

	MOV	R0, #0			; clock HI, data LO
	MOV	R1, #1
     iicBL      SetC1C0

; Delay here must be >= 4.0 microsecs (0.6 for fast device)

	MOV	R0, #1			; clock HI, data HI
	MOV	R1, #1
     iicBL      SetC1C0

     iicPull    "R0-R1,PC"

; *****************************************************************************
;
;	TXByte - Transmit a byte
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved, PSR corrupted
;

TXByte	ROUT
     iicPush    "R0-R2,iiclr"
	MOV	R1, #&80		; 2^7 the bit mask
	MOV	R2, R0			; byte goes into R2
10
	ANDS	R0, R2, R1		; zero if bit is zero
	MOVNE	R0, #1
     iicBL      ClockData               ; send the bit
	MOVS	R1, R1, LSR #1
	BNE	%BT10
     iicPull    "R0-R2,PC"

TXAck	ROUT
     iicPush    iiclr
     iicBL      TXByte
     iicPull    iiclr
	B	Acknowledge


; *****************************************************************************
;
;	TXPollAck - Transmit a byte and poll for acknowledge
;
;	This is intended for devices with a slow internal write cycle which
;	don't ack until the write cycle is finished ( eg ATMEL AT24C01A/x )
;
; in:	R0 = byte to be transmitted
;
; out:	All registers preserved
;

TXPollAck	ROUT
     iicPush    "R1,iiclr"
	MOV	R1, #1
10
     iicBL      TXByte
     iicBL      Acknowledge
     iicPull    "R1,PC",VC
        ADD     R1, R1, #1
	TEQ	R1, #PollMax
        BEQ     %FT90
 [	{FALSE}
	BREG	R1, "i2c tries:"
 ]
     iicBL      RepeatedStart
        B       %BT10
90
     iicPull    "R1,PC"

; *****************************************************************************
;
;	RXByte - Receive a byte
;
; out:	R0 = byte received
;	All other registers preserved, PSR corrupted
;

RXByte	ROUT
     iicPush    "R1-R3,iiclr"
        MOV     R3, #0                  ; byte:=0
        MOV     R2, #7

	MOV	R0, #1			; clock LO, data HI
	MOV	R1, #0
     iicBL      SetC1C0
10
 [ {TRUE}
; Disable interrupts to ensure clock hi with data hi is only transient
; This allows BMU to detect idle condition by polling

        MSR     CPSR_c, R8
 ]
	MOV	R0, #1			; pulse clock HI
	MOV	R1, #1
     iicBL      SetC1C0

     iicBL      ReadC1C0
        ADD     R3, R0, R3, LSL #1      ; byte:=byte*2+ SDA

	MOV	R0, #1			; return clock LO
	MOV	R1, #0
     iicBL      SetC1C0

 [ {TRUE}
        MSR     CPSR_c, R7
 ]
        SUBS    R2, R2, #1
	BCS	%BT10

	MOV	R0, R3			; return the result in R0
     iicPull    "R1-R3,PC"


interrupt_protected_end


 ] ; PCB = 4 (IIC code)


; Static variable indirection table
; ---------------------------------

        IMPORTVar Module_PrivateWord
        LocalVar Interface
        LocalVar InUseSemaphore
        LocalVar ParallelHardwareAddress
        LocalVar OldKeyboardIRQBits
        LocalVar OldKeyboardEnable
 [ PCB = 2 :LOR: PCB = 3
        LocalVar SoftCopyKBDCR
 ]
 [ PCB = 4
        LocalVar SoftCopyCtrl
 ]
 [ PCB >= 2
        LocalVar SoftCopyData
 ]
        LocalVar ParallelFileHandle
        LocalVar OldParallelIRQBit
        LocalVar OldParallelCtrl
        LocalVar ParallelSemaphore
        LocalVar Aborted
 [ :LNOT: Microcode
        LocalVar StuffingSemaphore
 ]
        LocalVar StuffingBytesRemaining
 [ PCB = 4
        LocalVar IICNoAckError
 ]


        AREA    |Asm$$Data|, DATA


; Local static variables
; ----------------------

Interface                               ; struct to pass to generic Zoran code
        DCD     ZoranPara_Command
        DCD     ZoranPara_CompleteInterruptedOp
        DCD     ZoranPara_UnmaskStuffingIRQ
        DCD     ZoranPara_ConsumeData
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     HWInfoPrototype
        DCD     0
        DCD     0
        DCD     DriverInfoPrototype
        DCD     0
        ASSERT  .-Interface = InterfaceSize
InUseSemaphore
        DCD     0                       ; nonzero => decoder in use
ParallelHardwareAddress
        DCD     0                       ; base address of parallel hardware
OldKeyboardIRQBits
        DCD     0                       ; original keyboard bits in IRQMSKB
OldKeyboardEnable
        DCD     0                       ; original keyboard enable bit in KBDCR
 [ PCB = 2 :LOR: PCB = 3
SoftCopyKBDCR
        DCD     0                       ; because the register is write-only
 ]
 [ PCB = 4
SoftCopyCtrl
        DCD     0                       ; soft copy of ctrl register (irqen/init set, slctin toggling), for speed
 ]
 [ PCB >= 2
SoftCopyData
        DCD     0                       ; for speed
 ]
ParallelFileHandle
        DCD     0                       ; file handle we lock parallel: with
OldParallelIRQBit
        DCD     0                       ; original printer bit in IRQMSKA
OldParallelCtrl
        DCD     0                       ; original contents of parallel control register
ParallelSemaphore
        DCD     0                       ; address to poke into IRQ stack if threaded, else 0
Aborted
        DCD     0                       ; whether the current SendPacket was aborted
 [ :LNOT: Microcode
StuffingSemaphore
        DCD     0                       ; whether a stuffing IRQ (parallel or ticker) is threaded
 ]
StuffingBytesRemaining
        DCD     0                       ; space in FIFO (for resumption of stuffing after underrun)
 [ PCB = 4
IICNoAckError
        %       256                     ; internationalised error block
 ]


HWInfoPrototype                         ; printf format
        =       "Zoran ZR38601 (ROM %08X) parallel port dongle", 0
DriverInfoPrototype
        =       Module_ComponentName, " ", Module_HelpVersion, " microcode ", 34, "%s", 34, 0
        ALIGN


        END
