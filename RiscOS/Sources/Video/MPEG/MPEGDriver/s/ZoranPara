; /****** ZoranPara.s ********************************************************
;
; Project:	STB-400
; Component:	MPEGDriver
; This file:	Code to manage the interface between the ARM and the Zoran
;		in the case of a PS/2 / parallel port dongle
;
; Copyright 2001 Pace Micro Technology plc. All rights reserved.
;
; This material is the confidential trade secret and proprietary information
; of Pace Micro Technology plc. It may not be reproduced, used, sold, or
; transferred to any third party without the prior written consent of
; Pace Micro Technology plc.
;
; History:
; Date		Who	Change
; ----------------------------------------------------------------------------
; 15/08/2001	BJGA	Created
;
; ***************************************************************************/


; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>
        GET     Hdr:Proc
        GET     Hdr:IO.IOMD
        GET     Hdr:DevNos
        GET     Hdr:Parallel
        GET     Hdr:HighFSI


; FIFO size
fifo_size       *       1

; Address of IRQ semaphore
IRQsema         *       &108

; Offsets from parallel hardware base address
                ^       0
pp_data         #       4
pp_stat         #       4
pp_ctrl         #       4

; Bits in parallel status and control registers

pp_stat_notbusy         * 1:SHL:7
pp_stat_ack             * 1:SHL:6
pp_stat_pe              * 1:SHL:5
pp_stat_slct            * 1:SHL:4
pp_stat_error           * 1:SHL:3

pp_ctrl_dir             * 1:SHL:5
pp_ctrl_irqen           * 1:SHL:4
pp_ctrl_slctin          * 1:SHL:3
pp_ctrl_init            * 1:SHL:2
pp_ctrl_autofd          * 1:SHL:1
pp_ctrl_strobe          * 1:SHL:0

; Layout of zoran_interface_t C struct
                        ^       0
Interface_Command       #       4
Interface_CompleteOp    #       4
Interface_UnmaskIRQ     #       4
Interface_ConsumeData   #       4
Interface_TopLevel      #       4
Interface_Buffer        #       4
Interface_Scheduler     #       4
Interface_Presentation  #       4
Interface_TopLevelHandle #      4
Interface_Characteriser #       4
Interface_CharacteriserHandle # 4
Interface_Link          #       4
Interface_HowMuchData   #       4
Interface_GiveMeData    #       4
Interface_Flags         #       4
Interface_BlockQueueHead #      4
Interface_BlockQueueTail #      4
InterfaceSize           *       :INDEX: @

InterfaceFlags_AC3NotMPA                        *       1 :SHL: 0
InterfaceFlags_Characterising                   *       1 :SHL: 1
InterfaceFlags_ReceivingCharacterisationData    *       1 :SHL: 2
InterfaceFlags_Started                          *       1 :SHL: 3

; Layout of common_toplevel_fns_t C struct
                        ^       0
TopLevel_RegisterMe     #       4
TopLevel_DeregisterMe   #       4

; Layout of buffer_fns_t C struct
                        ^       0
Buffer_HowMuchData      #       4
Buffer_GiveMeData       #       4


        IMPORT  Mess_GenerateError
        IMPORT  Zoran_Init
        IMPORT  Zoran_Final
        IMPORT  Zoran_EstablishMPA
        IMPORT  Zoran_EstablishAC3
        IMPORT  Zoran_Annul
        IMPORT  Zoran_Commence
        IMPORT  Zoran_Discontinue
        IMPORT  Zoran_ReadSystemInfo
        IMPORT  Zoran_DataAvailable
        IMPORT  Zoran_ConsumeData
        IMPORT  Zoran_ReadFullness
        IMPORT  Zoran_Start
        IMPORT  Zoran_Stop
        IMPORT  Zoran_SetClock
        IMPORT  Zoran_Speed
        IMPORT  Zoran_Fast
        IMPORT  Zoran_Slow
        IMPORT  Zoran_Normal
        IMPORT  Zoran_Volume
        IMPORT  Zoran_Downmix
        IMPORT  Zoran_SPDIF
        IMPORT  Zoran_ReadStreamInfo


        AREA    |Asm$$Code|, CODE, READONLY


; Exported functions
; ------------------


; These are the protocol_fns_t structs that we register with AudGeneric

ProtocolFunctions_MPEG
        DCD     ZoranPara_EstablishMPA
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     ZoranPara_ReadSystemInfo
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_SetClock
        DCD     Zoran_Speed
        DCD     Zoran_Fast
        DCD     Zoran_Slow
        DCD     Zoran_Normal
        DCD     0               ; Proceed
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo

ProtocolFunctions_AC3
        DCD     ZoranPara_EstablishAC3
        DCD     ZoranPara_Annul
        DCD     Zoran_Commence
        DCD     ZoranPara_Discontinue
        DCD     ZoranPara_ReadSystemInfo
        DCD     Zoran_DataAvailable
        DCD     ZoranPara_ConsumeData
        DCD     Zoran_ReadFullness
        DCD     Zoran_Start
        DCD     Zoran_Stop
        DCD     Zoran_SetClock
        DCD     Zoran_Speed
        DCD     Zoran_Fast
        DCD     Zoran_Slow
        DCD     Zoran_Normal
        DCD     0               ; Proceed
        DCD     Zoran_Volume
        DCD     Zoran_Downmix
        DCD     Zoran_SPDIF
        DCD     Zoran_ReadStreamInfo


; extern _kernel_oserror *ZoranPara_Init (common_toplevel_fns_t *toplevel, buffer_fns_t *buffer, scheduler_fns_t *scheduler, const presentation_fns_t *presentation);

        EXPORT  ZoranPara_Init
ZoranPara_Init
        FunctionEntry "v1,v2"
        StaticBaseFromSL ip

        ; No autodetection yet - just proceed as though we had detected the dongle

        ; Cache callback function pointer tables in our interface struct
        ADRVar  lr, ip, Interface
        STR     a1, [lr, #Interface_TopLevel]
        MOV     v1, a1                  ; useful later in this function
        STR     a2, [lr, #Interface_Buffer]
        STR     a3, [lr, #Interface_Scheduler]
        STR     a4, [lr, #Interface_Presentation]

        MOV     a1, #0
        STRVar  a1, ip, InUseSemaphore, lr

        ; Cache parallel hardware address, so we don't have to do a SWI each time we need it
        SWI     XParallel_HardwareAddress
        Return  "v1,v2",, VS
        STRVar  a1, ip, ParallelHardwareAddress, lr

        ; Disable keyboard port
        MOV     a4, #IOMD_Base
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a1, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRB    a1, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        AND     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        STRVar  a2, ip, OldKeyboardIRQBits, a1

        LDRB    a2, [a4, #IOMD_KBDCR]
        AND     a2, a2, #IOMD_KBDCR_Enable    ; no way to read the state of the other control bits
        STRVar  a2, ip, OldKeyboardEnable, a1 ; so just assume they were clear
        MOV     a1, #IOMD_KBDCR_Nclock
        STRB    a1, [a4, #IOMD_KBDCR]

        ; Set up interfaces so we can talk to the Zoran chip
        BL      ActivateDongle
        TEQ     a1, #0
        Return  "v1,v2",, NE

        ; Reset the Zoran chip
        LDR     lr, ParallelHardwareAddress_Indirect
        LDR     ip, [ip, lr]            ; ip = ParallelHardwareAddress
        MOV     a2, #pp_ctrl_slctin
        STRB    a2, [ip, #pp_ctrl]
        MOV     a1, #26                 ; 160 ticks of 12.288 MHz clock = 13 µs
        BL      WaitSemimicroseconds
        MOV     a2, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    a2, [ip, #pp_ctrl]
        MOV     a1, #3
        BL      WaitSemimicroseconds    ; 16 ticks of 12.288 MHz clock = 1.5 µs

        ; Set up the PLLs in the Zoran - assume 48kHz sampling until we know otherwise
        ; Very slowly now, we don't want to confuse the poor thing
        MOV     a1, #&98                ; PLLTAB
        BL      WriteByteSlowly
        MOV     a1, #0                  ; AUDD[12:8]
        BL      WriteByteSlowly
        MOV     a1, #2                  ; AUDD[7:0]
        BL      WriteByteSlowly
        MOV     a1, #0                  ; AUDM[12:8]
        BL      WriteByteSlowly
        MOV     a1, #3                  ; AUDM[7:0]
        BL      WriteByteSlowly
        MOV     a1, #2                  ; DSPD
        BL      WriteByteSlowly
        MOV     a1, #13                 ; DSPM
        BL      WriteByteSlowly
        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
        MOV     a1, #&99                ; PLLCFG
        BL      WriteByteSlowly
        MOV     a1, #&03                ; Parameter 1
        BL      WriteByteSlowly
        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
        ; Wait for the PLLs to lock
        ; Each time round the loop takes ~100µs, so 1000 times is a 0.1s timeout
        MOV     v2, #1000
80      MOV     a1, #&99                ; PLLCFG
        BL      WriteByteSlowly
        MOV     a1, #&00                ; Parameter 1
        BL      WriteByteSlowly
        MOV     a1, #0                  ; READ
        BL      WriteByteSlowly
        BL      ReadByteSlowly
        AND     a1, a1, #3
        TEQ     a1, #3
        SUBNES  v2, v2, #1
        BNE     %BT80
        TEQ     v2, #0
        BEQ     %FT90                   ; timed out

        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]

        MOV     a1, #100
        BL      WaitSemimicroseconds

        ; Call generic Zoran code to continue initialisation
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Init              ; corrupts ip, may return error
        TEQ     a1, #0
        BNE     %FT95

        ; Finished talking to Zoran chip
        StaticBaseFromSL ip
        BL      DeactivateDongle        ; preserves a1

        ; Register our availability
        MOV     a1, #0                  ; register MPEG decoder
        ADR     a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #1                  ; register AC-3 decoder
        ADR     a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_RegisterMe]

        MOV     a1, #0                  ; no error
        Return  "v1,v2"

90      ; Error: PLL did not lock
        ADR     a1, AudioLockMessageToken
        LDR     a2, =&81850C
        MOV     a3, #0
        BL      Mess_GenerateError
        ; drop through to general error exit...
95
        StaticBaseFromSL ip
        BL      DeactivateDongle
        BL      RestoreKeyboardPort
        Return  "v1,v2"

AudioLockMessageToken
        =       "Err_NoAudioPLLLock", 0
        ALIGN

WaitSemimicroseconds
        ; In: a1 = number of 2 MHz ticks to wait
        ; Out: a1-a4 corrupted
        Entry
        SUB     a1, a1, #1              ; subtract 1 so that completion condition is it going -ve
        MOV     a2, #0                  ; a2 holds old timer count (zero-init forces wrap case)
        MOV     lr, #IOMD_Base
01      STRB    lr, [lr, #Timer0LR]
        LDRB    a3, [lr, #Timer0CL]
        LDRB    a4, [lr, #Timer0CH]
        ORR     a3, a3, a4, LSL #8      ; a3 = new timer count
        SUBS    a2, a3, a2              ; difference (>= 0 means we have wrapped or not ticked)
        ADDMIS  a1, a1, a2              ; subtract any tick count from total - have we finished?
        MOVPL   a2, a3                  ; old timer count := new timer count
        BPL     %BT01
        EXIT

WriteByteSlowly
        ; In: a1 = byte to write
        ;     ip = parallel hardware address
        ; Out: a1-a4 corrupted
        Entry
        STRB    a1, [ip, #pp_data]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        EXIT

ReadByteSlowly
        ; In: ip = parallel hardware address
        ; Out: a1 = byte result
        ;      a2-a4 corrupted
        Entry   "v1"
        MOV     a1, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_autofd
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        LDRB    v1, [ip, #pp_data]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        MOV     a1, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    a1, [ip, #pp_ctrl]
        MOV     a1, #16
        BL      WaitSemimicroseconds
        MOV     a1, v1
        EXIT


; _kernel_oserror *ZoranPara_Final (void);

        EXPORT  ZoranPara_Final
ZoranPara_Final
        FunctionEntry "v1"
        ; Call generic Zoran code to start finalisation (note dongle is in pass-through mode)
        StaticBaseFromSL ip
        ADRVar  a1, ip, Interface
        BL      Zoran_Final
        TEQ     a1, #0
        Return  "v1",, NE

        ; Passed last point when failure to finalise can happen - now deregister ourselves
        StaticBaseFromSL ip
        ADRVar  lr, ip, Interface
        LDR     v1, [lr, #Interface_TopLevel]

        MOV     a1, #0                  ; deregister MPEG decoder
        ADR     a2, ProtocolFunctions_MPEG
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        MOV     a1, #1                  ; deregister AC-3 decoder
        ADR     a2, ProtocolFunctions_AC3
        MOV     lr, pc
        LDR     pc, [v1, #TopLevel_DeregisterMe]

        ; Restore keyboard port
        BL      RestoreKeyboardPort

        MOV     a1, #0                  ; no error
        Return  "v1"


; ActivateDongle - switch dongle to codec mode
;   in:  ip = static base
;   out: r0 -> error block, or 0 for no error
;        other registers preserved

ActivateDongle
        Entry   "a2-a4"
        ; Check parallel port isn't in use
        MOV     a1, #OSFind_OpenOut :OR: open_mustopen :OR: open_nodir
        ADR     a2, ParallelColon
        SWI     XOS_Find
        EXIT    VS
        STRVar  a1, ip, ParallelFileHandle, lr

        ; Disable parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a1, a4, #I32_bit :OR: F32_bit
        ORR     lr, a4, #I32_bit
        MSR     CPSR_c, a1              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a1, a2, #IOMDr_printer_IRQ_bit
        STRB    a1, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; just IRQs off while we mess with other stuff
        AND     a2, a2, #IOMDr_printer_IRQ_bit
        STRVar  a2, ip, OldParallelIRQBit, a1

        LDRVar  a1, ip, ParallelHardwareAddress
        LDRB    a2, [a1, #pp_ctrl]
        STRVar  a2, ip, OldParallelCtrl, lr
        BIC     a2, a2, #pp_ctrl_irqen
        STRB    a2, [a1, #pp_ctrl]

        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ClaimDeviceVector   ; let any pending IRQ drop through into our handler - should be ineffective

        ; Enable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
        MOV     a1, #IOMD_KBDCR_Ndata
        STRB    a1, [a3, #IOMD_KBDCR]

        MSR     CPSR_c, a4              ; restore IRQs
        MOV     a1, #0
        EXIT

ParallelColon
        =       "Parallel:", 0
        ALIGN


; DeactivateDongle - switch dongle to pass-through mode
;   in:  ip = static base
;   out: all registers preserved

DeactivateDongle
        Entry   "a1-a4"
        ; Disable parallel IRQs in the control register -
        ; avoids any messy issues with the control handover
        LDRVar  a4, ip, ParallelHardwareAddress
        LDRVar  a2, ip, OldParallelCtrl
        BIC     a2, a2, #pp_ctrl_irqen
        STRB    a2, [a4, #pp_ctrl]

        ; Disable printer and audio bypass lines in PS/2 interface
        MOV     a3, #IOMD_Base
        MOV     a1, #IOMD_KBDCR_Nclock
        STRB    a1, [a3, #IOMD_KBDCR]

        ; Hand back the parallel port
        MOV     a1, #IOMDr_PrinterIRQ_DevNo
        ADRL    a2, ParallelIRQHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_ReleaseDeviceVector

        MOV     a3, #IOMD_Base
        LDRVar  a1, ip, OldParallelIRQBit
        MRS     lr, CPSR
        ORR     a2, lr, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        ORR     a2, a2, a1
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, lr              ; restore IRQ/FIQ state

        LDRVar  a1, ip, OldParallelCtrl
        STRB    a1, [a4, #pp_ctrl]

        ; Release filing system lock
        MOV     a1, #0
        LDRVar  a2, ip, ParallelFileHandle
        SWI     XOS_Find
        EXIT


; RestoreKeyboardPort - called both from initialisation failure and finalisation
;   out: a2-a4,ip corrupted

RestoreKeyboardPort
        Entry   "a1"
        StaticBaseFromSL ip
        MOV     a4, #IOMD_Base
        LDRVar  a1, ip, OldKeyboardEnable
        STRB    a1, [a4, #IOMD_KBDCR]

        LDRVar  a1, ip, OldKeyboardIRQBits
        MRS     a3, CPSR
        ORR     a2, a3, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKB
        LDRB    a2, [a4, #IOCIRQMSKB]
        BIC     a2, a2, #serial_Rx_bit :OR: serial_Tx_bit
        ORR     a2, a2, a1
        STRB    a2, [a4, #IOCIRQMSKB]
        MSR     CPSR_c, a3              ; restore IRQ/FIQ state
        EXIT


; _kernel_oserror * (*establish) (unsigned int flags, void *handle, void **session_id);

ZoranPara_EstablishMPA
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishMPA
        B       %FT10
ZoranPara_EstablishAC3
        FunctionEntry "v1"
        LDR     v1, =Zoran_EstablishAC3
10
        StaticBaseFromSL ip
        LDRVar  a4, ip, InUseSemaphore
        TEQ     a4, #0                  ; already in use?
        ADRNE   a1, InUseError
        Return  "v1",, NE               ; exit if so

        ; Activate dongle
        Push    "a1"
        BL      ActivateDongle
        TEQ     a1, #0
        ADDNE   sp, sp, #1*4
        Return  "v1",, NE                ; pass back any error

        ; Exchange handles
        ADRVar  a4, ip, Interface
        STR     a2, [a4, #Interface_TopLevelHandle]
        STR     a4, [a3]

        ; Call generic code
        Pull    "a1"
        MOV     a2, a4
        MOV     lr, pc
        MOV     pc, v1                  ; call Zoran_EstablishMPA or Zoran_EstablishAC3
        StaticBaseFromSL ip
        TEQ     a1, #0
        BNE     %FT90                   ; error exit

        MOV     a4, #1
        STRVar  a4, ip, InUseSemaphore, lr ; set in-use semaphore
        Return  "v1"                    ; exit with a1=0

90      BL      DeactivateDongle
        Return  "v1"

InUseError
        &       &81850F                 ; errno_AUDIO_IN_USE
        =       "No suitable audio decoder available", 0
        ; No point in internationalising, because string is ignored by AudGeneric
        ALIGN


; _kernel_oserror * (*annul) (unsigned int flags, void *session_id);

ZoranPara_Annul
        FunctionEntry
        ; Call generic code
        BL      Zoran_Annul
        TEQ     a1, #0
        Return  ,, NE                   ; bail out now if error

        StaticBaseFromSL ip
        BL      DeactivateDongle

        MOV     a4, #0
        STRVar  a4, ip, InUseSemaphore, lr

        Return                          ; exit with a1=0


; _kernel_oserror * (*discontinue) (unsigned int flags, void *session_id);

ZoranPara_Discontinue
        FunctionEntry
        ; Call generic code
        BL      Zoran_Discontinue
        TEQ     a1, #0
        Return  ,, NE                   ; bail out if error

        ; Mask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        BIC     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

        ; Release TickerV
        StaticBaseFromSL ip
        MOV     a1, #TickerV
        ADR     a2, TickerHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_Release

        MOV     a1, #0
        Return                          ; exit with a1=0


; _kernel_oserror * (*readsysteminfo) (unsigned int tag, unsigned int *result);

ZoranPara_ReadSystemInfo
        StaticBaseFromSL ip
        ADRVar  a3, ip, Interface       ; set up necessary extra parameter
        B       Zoran_ReadSystemInfo


; _kernel_oserror * (*consumedata) (unsigned int flags, void *session_id, unsigned char *start, unsigned int length, unsigned int *not_consumed);

ZoranPara_ConsumeData
        LDR     ip, [a2, #Interface_Flags]
        TST     ip, #InterfaceFlags_ReceivingCharacterisationData
        BNE     %FT50

        ; Normal decoding case: send to hardware
        FunctionEntry "v1,v2,v3,v4,v6,sl,fp"
        StaticBaseFromSL v6             ; R9 = static base
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base
        LDRVar  a1, v6, StuffingBytesRemaining
        SUBS    v4, a4, a1
        MOVMI   v4, #0                  ; v4 = amount available that won't fit into fifo
        SUBS    a1, a4, v4              ; R0 = bytes we're actually going to transfer
        BEQ     %FT49
        MOV     a2, a3                  ; R1 = address pointer
        MOV     a3, #0
        STRVar  a3, v6, Aborted, lr     ; clear aborted flag

        LDR     v1, ParallelSemaphore_Indirect
        MRS     v2, CPSR
        MOV     v3, a4                  ; keep original length in case we're aborted
        ORR     lr, v2, #I32_bit
        MSR     CPSR_c, lr              ; IRQs off
        ADR     lr, SendBlock_return_address
        STR     lr, [v6, v1]            ; set the semaphore
        B       SendBlock               ; do the transfer
SendBlock_return_address
        MOV     a1, #0
        STR     a1, [v6, v1]            ; clear the semaphore
        MSR     CPSR_c, v2
        LDRVar  a1, v6, Aborted
        LDR     lr, [sp, #8*4]          ; retrieve not_consumed pointer
        TEQ     a1, #0
        STRNE   v3, [lr]
        STREQ   v4, [lr]
        LDRVar  a1, v6, StuffingBytesRemaining, EQ
        SUBEQ   a1, a1, v3 ; take off the amount available
        ADDEQ   a1, a1, v4 ; put back the amount available that won't fit (not using SUBS above allows us to keep using condition flags)
        STRVar  a1, v6, StuffingBytesRemaining, lr, EQ
        MOV     a1, #0                  ; no error
        Return  "v1,v2,v3,v4,v6,sl,fp"

49      LDR     lr, [sp, #8*4]          ; retrieve not_consumed pointer
        STR     a4, [lr]                ; nothing consumed (either length or StuffingBytesRemaining was 0)
        MOV     a1, #0                  ; no error
        Return  "v1,v2,v3,v4,v6,sl,fp"

50      ; Normal characterising case: send to recogniser via the generic Zoran code
        TST     ip, #InterfaceFlags_Characterising
        BNE     Zoran_ConsumeData       ; pass data on to characteriser

        ; A rare case where the characteriser reaches recognition at the very end of
        ; the previous block, and the buffer manager has sent another block
        LDR     a2, [sp, #4*0]          ; retrieve not_consumed pointer
        STR     a4, [a2]                ; have not consumed any of the new data
        MOV     a1, #0                  ; no error
        Return  , LinkNotStacked


; extern void ZoranPara_UnmaskStuffingIRQ (void);

ZoranPara_UnmaskStuffingIRQ
        FunctionEntry
        StaticBaseFromSL ip
        ; State initialisation
        MOV     a1, #fifo_size          ; FIFO is initially empty and must be serviced from TickerV
        STRVar  a1, ip, StuffingBytesRemaining, lr

        ; Unmask parallel IRQs
        MOV     a3, #IOMD_Base
        MRS     a4, CPSR
        ORR     a2, a4, #I32_bit :OR: F32_bit
        MSR     CPSR_c, a2              ; IRQs and FIQs off to manipulate IRQMSKA
        LDRB    a2, [a3, #IOCIRQMSKA]
        ORR     a2, a2, #IOMDr_printer_IRQ_bit
        STRB    a2, [a3, #IOCIRQMSKA]
        MSR     CPSR_c, a4              ; restore IRQs and FIQs

        ; Claim TickerV
        MOV     a1, #TickerV
        ADR     a2, TickerHandler
        LDRVar  a3, ip, Module_PrivateWord
        LDR     a3, [a3]
        SWI     XOS_Claim

        Return


        ; IRQs are disabled on entry to both TickerHandler and ParallelIRQHandler
TickerHandler
        Entry   "r0-r1, r9"
        StaticBaseFromWP r9, r12
        ; Set and check semaphore, exit if set
        ADRVar  r1, r9, StuffingSemaphore
        MOV     r0, #1
        SWP     r0, r0, [r1]
        TEQ     r0, #0
        EXIT    NE
;        ; Check IRQ status line (actually active high, rather than combo chip's rising edge)
;        LDRVar  r1, r9, ParallelHardwareAddress
;        LDRB    r0, [r1, #pp_stat]
;        TST     r0, #pp_stat_ack ; NE => interrupting
;        BEQ     TickerHandler_Abort
        ; We can write the remaining part of the FIFO, if any
        LDRVar  r0, r9, StuffingBytesRemaining
        TEQ     r0, #0
        MOVEQ   r0, #fifo_size
        STRVar  r0, r9, StuffingBytesRemaining, lr, EQ
        B       CommonStuffingCode
TickerHandler_Abort
        MOV     r0, #0
        STRVar  r0, r9, StuffingSemaphore, lr
        EXIT

ParallelIRQHandler
        ALTENTRY
        StaticBaseFromWP r9, r12
        ; Always acknowledge the interrupt
        MOV     r0, #IOMD_Base
        MOV     r1, #IOMDr_printer_IRQ_bit
        STRB    r1, [r0, #IOCIRQCLRA]
        ; Set and check semaphore, exit if set
        ADRVar  r1, r9, StuffingSemaphore
        MOV     r0, #1
        SWP     r0, r0, [r1]
        TEQ     r0, #0
        EXIT    NE
        ; We can write a whole FIFO full
        MOV     r0, #fifo_size
        STRVar  r0, r9, StuffingBytesRemaining, lr
        ; drop through...
CommonStuffingCode
        ; Drop into SVC mode and set up APCS module environment
        WritePSRc I_bit+SVC_mode, lr,, r1
        Push    "r1-r8, r10-r11, lr_svc"
        MOV     sl, sp, LSR #20
        MOV     sl, sl, LSL #20
        LDMIA   sl, {v1, v2}
        Push    "v1, v2"
        LDMIB   r12, {v1, v2}
        STMIA   sl, {v1, v2}
        ADD     sl, sl, #540
        MOV     fp, #0

        MOV     v5, r0                  ; amount left in fifo

        MOV     a1, #0
        BL      ZoranPara_CompleteInterruptedOp

        LDRVar  v1, v6, ParallelHardwareAddress
        ADRVar  v2, v6, Interface
        LDR     v3, [v2, #Interface_TopLevelHandle]
        ; Check some data is available
        SUB     sp, sp, #4
        MOV     a1, #0
        MOV     a2, v3
        MOV     a3, sp
        MOV     lr, pc
        LDR     pc, [v2, #Interface_HowMuchData]
        Pull    "v4"                    ; v4 = amount available to be stuffed
        TEQ     v4, #0
        BEQ     %FT90
01
        CMP     v5, v4
        MOVHI   v5, v4                  ; v5 = amount that will be stuffed this time round loop
        ; Fetch some data
        MOV     a1, #1                  ; wrap in PES packets
        MOV     a2, v3
        MOV     lr, pc
        LDR     pc, [v2, #Interface_GiveMeData] ; call the appropriate givemedata()

        ; Read IRQ status line (actually active high, rather than combo chip's rising edge)
        LDRB    lr, [v1, #pp_stat]
        ADDS    lr, lr, #pp_stat_ack    ; toggle ack bit and clear C flag
        TST     lr, #pp_stat_ack        ; EQ => interrupting
        ; If line still asserted, then ack IRQ again in case it wiggled since last time
        MOVEQ   a2, #IOMD_Base
        MOVEQ   a3, #IOMDr_printer_IRQ_bit
        STREQB  a3, [a2, #IOCIRQCLRA]
        ; If line still asserted *and* givemedata() was successful *and* data still available to be stuffed, then loop
        TEQEQ   a1, #0                  ; no error?
        SUBEQS  v4, v4, v5              ; see how much data is left available to stuff
        MOVHI   v5, #fifo_size          ; HI = C set and Z clear (C set => SUBEQS was executed)
        STRVar  v5, v6, StuffingBytesRemaining, lr, HI
        BHI     %BT01

90      ; Clear semaphore
        MOV     a1, #0
        STRVar  a1, v6, StuffingSemaphore, lr
        ; Tidy up and exit
        Pull    "v1, v2"
        SUB     sl, sl, #540
        STMIA   sl, {v1, v2}
        Pull    "r1-r8, r10-r11, lr_svc"
        RestPSR r1              ; back to original processor mode
        EXIT


; extern void ZoranPara_Command (unsigned int flags, const char *parameters, char *response);

; flags: bits 5-9 = command-&80
;        bits 10-31 = number of parameters
;        bits 0-4 = number of results
; Executes for the most part in the same IRQ disable state as is set on entry

ZoranPara_Command
        FunctionEntry "v1,v2,v6,sl,fp"
        StaticBaseFromSL v6             ; R9 = static base
        MOV     ip, a1                  ; R12 = flags
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base

        ; Set semaphore
        LDR     v1, ParallelSemaphore_Indirect
        MRS     v2, CPSR
        ORR     lr, v2, #I32_bit
        MSR     CPSR_c, lr
        ADR     lr, Command_return_address
        STR     lr, [v6, v1]

        B       Command
Command_return_address
        MOV     a1, #0
        STR     a1, [v6, v1]            ; clear the semaphore
        MSR     CPSR_c, v2
        Return  "v1,v2,v6,sl,fp"


; extern void ZoranPara_CompleteInterruptedOp (bool abort);

; Operation completed in original IRQ disable state, unless IRQs disabled at this function's entry

; ** For God's sake remember to change this if you change the register list in Kernel.s.NewIRQs!

ZoranPara_CompleteInterruptedOp
        FunctionEntry "v1,v6"
        StaticBaseFromSL v6             ; R9 = static base
        MOV     ip, a1

        ; Check our semaphore
        LDR     v1, ParallelSemaphore_Indirect
        MRS     a4, CPSR
        ORR     a3, a4, #I32_bit :OR: 1:SHL:4 ; IRQs off and force 32-bit mode
        MSR     CPSR_c, a3
        LDR     a1, [v6, v1]
        TEQ     a1, #0                  ; semaphore set?
01      MSREQ   CPSR_c, a4              ; no, so quick exit
        Return  "v1,v6",, EQ

; Push "a1-a4,ip,lr"
; MOV a1, #'x'
; IMPORT DWrite_WriteC
; BL DWrite_WriteC
; Pull "a1-a4,ip,lr"
        ; Locate interrupted code on IRQ stack
        MOV     a3, #IRQsema
02      LDR     a3, [a3]
        TEQ     a3, #0
        BEQ     %BT01                   ; shouldn't happen, but if we can't find code, exit
        LDR     a2, [a3, #4*8]          ; interrupted PC
        RSB     lr, pc, a2
        CMP     lr, #interrupt_protected_end - 4 - CompleteInterruptedOp_pc_reference
CompleteInterruptedOp_pc_reference      ; must be 8 bytes after the RSB lr,pc,a2
        RSBLES  lr, lr, #interrupt_protected_start - CompleteInterruptedOp_pc_reference
        BGT     %BT02

        ; Mark the foreground operation as complete, then actually complete it
        Push    "a4,v2,sl,fp"
        ADR     lr, CompleteInterruptedOp_return_address
        STR     lr, [v6, v1]            ; set up our own semaphore, in case another interrupt happens
        STR     a1, [a3, #4*8]          ; poke IRQ stack so as to return to old semaphore
        LDR     a1, [a3, #4*6]          ; get interrupted CPSR
        TST     a4, #I32_bit            ; if IRQs were off on entry to CompleteInterruptedOp
        ORRNE   a1, a1, #I32_bit        ;   then don't open an interrupt hole
        MSR     SPSR_cxsf, a1           ; stick it in SPSR (okay, because IRQs are off)
        MOV     a1, #I32_bit :OR: SVC32_mode ; (SVC32 is available on all processors)
        STR     a1, [a3, #4*6]          ; ensure IRQs are off when we return to foreground
        MOV     v2, a2                  ; move interrupted PC to a safe register
        TEQ     ip, #0                  ; are we aborting?
        LDREQ   a1, [a3, #4*7]          ; retrieve interrupted R0 if not
        MOVNE   a1, #0                  ; else zero R0
        LDMIB   a3, {a2-a4, fp, ip}     ; retrieve interrupted R1-R3, R11, R12
        LDRVar  sl, v6, ParallelHardwareAddress ; R10 = parallel base
        MOVS    pc, v2                  ; copy SPSR to CPSR and jump back to interrupted code
CompleteInterruptedOp_return_address
        MOV     a1, #0
        Pull    "a4,v2,sl,fp"
        MSR     CPSR_c, a4              ; restore entry IRQ disable state and 26/32-bitness
        Return  "v1,v6"


interrupt_protected_start

        MACRO
        Rpt     $instruction, $times
        LCLA    Times
      [ "$times" = ""
Times   SETA    1
      |
Times   SETA    $times
      ]
        WHILE   Times > 0
        $instruction
Times   SETA    Times - 1
        WEND
        MEND

; Command - execute a Zoran command
;
;   On entry:
;               R1 -> parameters
;               R2 -> response buffer
;               R5 = CPSR to execute routine with
;               R9 = static base
;               R10 = parallel base
;               R12 = flags
;               R14 = return address (not including any PSR bits)
;               SVC mode, IRQs disabled
;   During routine:
;               R1, R2, R3, R11, R12 are the only available general-purpose registers
;               R9, R10 must not be modified (may randomly be reset to static and parallel bases)
;               R14 always contains the return address, though it may change during the function
;               CPSR flag bits are not volatile
;               Other registers are volatile and must not be used (no stack is available)
;   On exit:
;               Must exit in SVC32 mode with IRQs disabled
;               Registers ignored

Command ROUT
        MSR     CPSR_c, R5

        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]

        ; Write opcode byte
        MOV     R3, #&1F
        AND     R3, R3, R12, LSR #5     ; extract opcode bits
        ADD     R3, R3, #&80
        STRB    R3, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]

        ; Write parameter bytes
01      SUBS    R12, R12, #1 :SHL: 10
        BCC     %FT02
        LDRB    R3, [R1], #1
        STRB    R3, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        B       %BT01
02      MOV     R12, R12, LSL #27

        ; Write READ command bytes and read response bytes
        MOV     R1, #0
03      SUBS    R12, R12, #1 :SHL: 27
        BCC     %FT04
        STRB    R1, [R10, #pp_data]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R11, [R10, #pp_ctrl]
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]
        STRB    R11, [R10, #pp_ctrl]

        MOV     R11, #pp_ctrl_dir :OR: pp_ctrl_irqen :OR: pp_ctrl_init :OR: pp_ctrl_autofd
        STRB    R11, [R10, #pp_ctrl]
        LDRB    R3, [R10, #pp_data]
        STRB    R3, [R2], #1
        MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_init
        STRB    R11, [R10, #pp_ctrl]
        B       %BT03


04      MOV     R11, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        MOV     R1, #24                 ; we need 10µs delay between commands, so insert an extra 23 B-cycles
05      STRB    R11, [R10, #pp_ctrl]
        SUBS    R1, R1, #1
        BNE     %BT05

        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
        MOV     PC, R14


; SendBlock - send contiguous block of data to the Zoran data port
;
;   On entry:
;               R0 = maximum number of transfers to attempt
;               R1 = pointer to byte to start from
;               R5 = CPSR to execute routine with (from which I32_bit needs to be cleared)
;               R9 = static base
;               R10 = parallel base
;               R14 = return address (not including any PSR bits)
;               SVC mode, IRQs disabled
;   During routine:
;               R0 = remaining number of transfers to attempt (may be zeroed in the background if
;                 the operation is aborted)
;               R1, R2, R3, R11, R12 are the only available general-purpose registers
;               R9, R10 must not be modified (may randomly be reset to static and parallel bases)
;               R14 always contains the return address, though it may change during the function
;               CPSR flag bits are not volatile
;               Other registers are volatile and must not be used (no stack is available)
;   On exit:
;               Must exit in SVC32 mode with IRQs disabled
;               Registers ignored

SendBlock ROUT
        BIC     R11, R5, #I32_bit       ; this R5 will be returned to original caller, so preserve
        MSR     CPSR_c, R11

10      LDRB    R3, [R1], #1
        STRB    R3, [R10, #pp_data]
        MOV     R3, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init :OR: pp_ctrl_strobe
        STRB    R3, [R10, #pp_ctrl]
        MOV     R3, #pp_ctrl_irqen :OR: pp_ctrl_slctin :OR: pp_ctrl_init
        STRB    R3, [R10, #pp_ctrl]
        SUBS    R0, R0, #1
        BGT     %BT10

        MSR     CPSR_c, #I32_bit :OR: SVC32_mode
        MOV     PC, R14

interrupt_protected_end


; Static variable indirection table
; ---------------------------------

        IMPORTVar Module_PrivateWord
        LocalVar Interface
        LocalVar InUseSemaphore
        LocalVar ParallelHardwareAddress
        LocalVar OldKeyboardIRQBits
        LocalVar OldKeyboardEnable
        LocalVar ParallelFileHandle
        LocalVar OldParallelIRQBit
        LocalVar OldParallelCtrl
        LocalVar ParallelSemaphore
        LocalVar Aborted
        LocalVar StuffingSemaphore
        LocalVar StuffingBytesRemaining


        AREA    |Asm$$Data|, DATA


; Local static variables
; ----------------------

Interface                               ; struct to pass to generic Zoran code
        DCD     ZoranPara_Command
        DCD     ZoranPara_CompleteInterruptedOp
        DCD     ZoranPara_UnmaskStuffingIRQ
        DCD     ZoranPara_ConsumeData
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        DCD     0
        ASSERT  .-Interface = InterfaceSize
InUseSemaphore
        DCD     0                       ; nonzero => decoder in use
ParallelHardwareAddress
        DCD     0                       ; base address of parallel hardware
OldKeyboardIRQBits
        DCD     0                       ; original keyboard bits in IRQMSKB
OldKeyboardEnable
        DCD     0                       ; original keyboard enable bit in KBDCR
ParallelFileHandle
        DCD     0                       ; file handle we lock parallel: with
OldParallelIRQBit
        DCD     0                       ; original printer bit in IRQMSKA
OldParallelCtrl
        DCD     0                       ; original contents of parallel control register
ParallelSemaphore
        DCD     0                       ; address to poke into IRQ stack if threaded, else 0
Aborted
        DCD     0                       ; whether the current SendPacket was aborted
StuffingSemaphore
        DCD     0                       ; whether a stuffing IRQ (parallel or ticker) is threaded
StuffingBytesRemaining
        DCD     0                       ; space in FIFO (for resumption of stuffing after underrun)


        END
