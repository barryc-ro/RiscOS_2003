; /****** MiscAsm.s **********************************************************
;
; Project:	STB-400
; Component:	MPEGDriver
; This file:	Miscellaneous assembler routines
;
; Copyright 1999 Pace Micro Technology plc. All rights reserved.
;
; This material is the confidential trade secret and proprietary information
; of Pace Micro Technology plc. It may not be reproduced, used, sold, or
; transferred to any third party without the prior written consent of
; Pace Micro Technology plc.
;
; History:
; Date		Who	Change
; ----------------------------------------------------------------------------
; 28/10/1999	BJGA	Created
; 23/11/1999	BJGA	Added UserModeWait routine
; 02/12/1999	BJGA	Updated to use Hdr:APCS.<APCS> and WritePSRc macro
; 07/12/1999	BJGA	Implemented MiscAsm_Stuff
;
; ***************************************************************************/


; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:APCS.<APCS>
        GET     Hdr:MPEGCtrl
      [ "$MPEGPoduleType" <> "MPEG2cCard"
        !       1, "MPEGDriver is only suitable for STi3520L hardware"
      ]
        GET     Hdr:$MPEGPoduleType


        AREA    |Asm$$Code|, CODE, READONLY


; Exported functions
; ------------------


; void MiscAsm_Stuff (void *write32, void *start, unsigned int length);

; In:   32-bit write address to use, start and length of source

        ASSERT  Offset_MPEG_Video_Data_Write_16 - Offset_MPEG_Video_Data_Write_32 = &100
        ASSERT  Offset_MPEG_Audio_Data_Write_16 - Offset_MPEG_Audio_Data_Write_32 = &100
        ASSERT  Offset_MPEG_Video_Data_Write_8  - Offset_MPEG_Video_Data_Write_32 = &200
        ASSERT  Offset_MPEG_Audio_Data_Write_8  - Offset_MPEG_Audio_Data_Write_32 = &200

        EXPORT  MiscAsm_Stuff
MiscAsm_Stuff
        FunctionEntry "v1-v5"
        RSB     a4, a2, #0
        AND     a4, a4, #3      ; a4 = number of bytes from start to next word boundary (range 0-3)
        CMP     a3, a4
        MOVLO   a4, a3          ; a4 = min (a3, a4)
        TEQ     a4, #0
        ; a2 -> data to stuff (not word aligned)
        ; a3 = amount remaining (not word aligned)
        ; a4 = number of bytes to do at this stage
        ; Z set => a4=0
      [ {FALSE}
        ; The kosher way to load the MS 1-3 bytes of a word into the LS 1-3 bytes of a register
        BICNE   lr, a2, #3
        LDRNE   ip, [lr]
        MOVNE   lr, a2, LSL #3  ; so bottom five bits of lr are 0, 8, 16 or 24
        MOVNE   ip, ip, ROR lr  ; ROR effectively ignores bits 5-31 of lr
      |
        ; An undocumented feature of the ARM lets us achieve exactly the same in one instruction
        LDRNE   ip, [a2]        ; note a2 can be non-word-aligned
      ]
        TST     a4, #1          ; write a byte if 1 or 3 bytes to do
        STRNEB  ip, [a1, #&200]
        MOVNE   ip, ip, ROR #8
        TST     a4, #2          ; write a halfword if 2 or 3 bytes to do
        STRNE   ip, [a1, #&100]
        ADD     a2, a2, a4
        SUB     a3, a3, a4
stuff_words
        ; a2 -> remaining data to stuff (word aligned - or if it isn't, then a3 will be 0)
        ; a3 = amount remaining (not word aligned)
        BICS    lr, a3, #31             ; lr = total size of all 8-word chunks left to do
        LDMNEIA a2!, {a4, v1-v5, ip, lr}
        STMNEIA a1, {a4, v1-v5, ip, lr}
        SUBNE   a3, a3, #32
        BNE     stuff_words
        BICS    lr, a3, #3              ; lr = total size of all words left to do
        ADDNE   pc, pc, lr, LSL #2
        TEQ     a3, #0
        B       stuff_trailing_bytes
        NOP
        NOP
        NOP
        LDR     a4, [a2], #4
        STR     a4, [a1]
        SUBS    a3, a3, #4*1
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1}
        STMIA   a1, {a4, v1}
        SUBS    a3, a3, #4*2
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1-v2}
        STMIA   a1, {a4, v1-v2}
        SUBS    a3, a3, #4*3
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1-v3}
        STMIA   a1, {a4, v1-v3}
        SUBS    a3, a3, #4*4
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1-v4}
        STMIA   a1, {a4, v1-v4}
        SUBS    a3, a3, #4*5
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1-v5}
        STMIA   a1, {a4, v1-v5}
        SUBS    a3, a3, #4*6
        B       stuff_trailing_bytes
        LDMIA   a2!, {a4, v1-v5, ip}
        STMIA   a1, {a4, v1-v5, ip}
        SUBS    a3, a3, #4*7
stuff_trailing_bytes
        ; a2 -> remaining data to stuff (word aligned)
        ; a3 = number of bytes remaining
        ; Z set => a3=0
        LDRNE   ip, [a2]
        TST     a3, #2          ; write a halfword if 2 or 3 bytes to do
        STRNE   ip, [a1, #&100]
        MOVNE   ip, ip, ROR #16
        TST     a3, #1          ; write a byte if 1 or 3 bytes to do
        STRNEB  ip, [a1, #&200]
        Return  "v1-v5"


; bitstream_packet_t *MiscAsm_FreePacket (bitstream_packet_t *packet);

; In:   Pointer to packet to free
; Out:  Contents of packet's |link| field

; On entry to the free routine:
; r0 -> packet descriptor (will accept a linked list, but we have only ever
;           zeroed the |link| field so a single packet is freed at once)
; all other registers undefined (even FreeWorkspace is read from the packet
;           descriptor by the free routine itself)

        EXPORT  MiscAsm_FreePacket
MiscAsm_FreePacket
        FunctionEntry
        LDR     a2, [a1, #PacketDescriptor_Link]
        Push    "a2"
        MOV     a2, #0
        STR     a2, [a1, #PacketDescriptor_Link]
        LDR     a2, [a1, #PacketDescriptor_FreeRoutine]
        TEQ     a2, #0
        MOVNE   lr, pc
        MOVNE   pc, a2
        Return  "a1"


; extern void MiscAsm_UserModeWait (void *pointer);

; In:   Pointer to flag word (exit when 0)

        EXPORT  MiscAsm_UserModeWait
MiscAsm_UserModeWait
        FunctionEntry
10
        WritePSRc USR_mode, a2 ; warning: also enables IRQs and FIQs
        NOP
        SWI     XOS_EnterOS ; trashes lr_usr - but that's probably not important

        LDR     lr, [a1]
        TEQ     lr, #0
        BNE     %BT10

        Return


        END
