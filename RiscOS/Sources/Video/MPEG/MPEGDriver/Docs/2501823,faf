<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML lang="en">
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>MPEGDriver Module Functional Specification</TITLE>
</HEAD>

<BODY bgcolor="#ffffff">

<H1 align="center">MPEGDriver Module Functional Specification</H1>

<HR>

<P align="center"><STRONG>CONFIDENTIAL</STRONG>

<HR>

<TABLE border="0" width="50%" align="center">
<TR><TD>Document ref:    <TD>2501,823/FS
<TR><TD>Issue:           <TD>2G
<TR><TD>Date:            <TD>10 Aug 2000
<TR><TD>Author(s):       <TD><A href="mailto:ben.avison@pace.co.uk">Ben Avison</A>
<TR><TD>Change:          <TD>
<TR><TD>Classification:  <TD>Pace Restricted
</TABLE>

<H2>Contents</H2>

<TABLE border="0" width="100%">
<TR><TD width="8%">1 <TD><A href="#overview">       Overview</A>
<TR><TD>2            <TD><A href="#outstanding">    Outstanding issues</A>
<TR><TD>3            <TD><A href="#technical">      Technical background</A>
<TR><TD>4            <TD><A href="#user">           User interface</A>
<TR><TD>5            <TD><A href="#programmer">     Programmer interface</A>
<TR><TD>6            <TD><A href="#interchange">    Data interchange</A>
<TR><TD>7            <TD><A href="#formats">        Data formats</A>
<TR><TD>8            <TD><A href="#internal">       Internal dependencies</A>
<TR><TD>9            <TD><A href="#acceptance">     Acceptance test</A>
<TR><TD>10           <TD><A href="#noncompliances"> Noncompliances</A>
<TR><TD>11           <TD><A href="#test">           Development test strategy</A>
<TR><TD>12           <TD><A href="#organisation">   Product organisation</A>
<TR><TD>13           <TD><A href="#enhancements">   Future enhancements</A>
<TR><TD>14           <TD><A href="#glossary">       Glossary</A>
<TR><TD>15           <TD><A href="#references">     References</A>
<TR><TD>16           <TD><A href="#history">        History</A>
</TABLE>

<HR>

<H2><A name="overview">1. Overview</A></H2>

<P>This document specifies the software module MPEGDriver, which is the hardware driver
for the SGS-Thomson STi3520L MPEG decoder chip<SUP>[1]</SUP>. The STi3520L provides the
MPEG-1<SUP>[2]</SUP> and MPEG-2<SUP>[3]</SUP> video and audio decoding capability of the
STB-400<SUP>[4] [5]</SUP>. MPEGDriver is responsible for taking the elementary or
packetised elementary video and audio streams provided by the rest of the MPEG stack,
feeding them into the hardware, and controlling the decode and display processes within
the chip. The software API is designed to be broadly compatible with those of the
MPEGVideo, MPEGAudio and MPEG2Video modules used in earlier STBs, so that it can be used
with the MPEGControl<SUP>[6]</SUP>, MPEGSystem<SUP>[7]</SUP> and
MPEGTransport<SUP>[8]</SUP> modules without requiring significant code changes to them;
MPEGDriver will also feature a few API enhancements, notably to allow access to the video
scaling abilities of the STi3520L. Both 525-line (eg NTSC) and 625-line (eg PAL-I) TV
standards are automatically supported, in conjunction with the DENCDriver
module<SUP>[9]</SUP>.

<HR>

<H2><A name="outstanding">2. Outstanding issues</A></H2>

<P>There are no outstanding issues.

<HR>

<H2><A name="technical">3. Technical background</A></H2>

<P>Here is a comparative table of features of the MPEG drivers of past, present and future
STBs:

<BR><BR>

<TABLE border="1">
<TBODY align="left">
<TR bgcolor="eeeeee"><TH>STB generation                  <TH>STB-1, STB-21                           <TH>STB-22, STB-24, STB-3                                         <TH>STB-400
<TR bgcolor="eeeeee"><TH>MPEG hardware                   <TH>C-Cube CL450, TI TMS320AV110            <TH>LSI L64002                                                    <TH>ST STi3520L
<TR bgcolor="eeeeee"><TH>Module name(s)                  <TH>MPEGVideo, MPEGAudio                    <TH>MPEG2Video                                                    <TH>MPEGDriver
<TR bgcolor="cccccc"><TH colspan="4">MPEGVideo SWIs
<TR><TH bgcolor="eeeeee">OpenStream                      <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">FullPackets                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CloseStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">Play                            <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SetSpeed                        <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CardControl                     <TD>Reason codes 0-5 implemented            <TD>Reason codes 2 &amp; 6 implemented                            <TD>Reason codes 2 &amp; 7 implemented
<TR><TH bgcolor="eeeeee">SetSCR                          <TD>Implemented                             <TD>Implemented (but not used)                                    <TD>Not implemented
<TR><TH bgcolor="eeeeee">ReadParameters                  <TD>Reason codes 0-5 implemented            <TD>Reason codes 1-5 implemented                                  <TD>Reason codes 4 &amp; 5 implemented
<TR><TH bgcolor="eeeeee">ResetStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">DisplayStill                    <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">Stats                           <TD>Stats &amp;1000 - &amp;100B implemented <TD>Stats &amp;1000, &amp;1001, &amp;100B - &amp;1010 implemented <TD>Stats &amp;1000, &amp;1001, &amp;100B, &amp;1011 implemented
<TR><TH bgcolor="eeeeee">RegisterHandler                 <TD>Not implemented                         <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">DeregisterHandler               <TD>Not implemented                         <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SetVideoParameters              <TD>Not implemented                         <TD>Not implemented                                               <TD>Implemented
<TR bgcolor="cccccc"><TH colspan="4">MPEGAudio SWIs
<TR><TH bgcolor="eeeeee">OpenStream                      <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">FullPackets                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CloseStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">Play                            <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SetSpeed                        <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SkipFrame                       <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">RepeatFrame                     <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">ResetStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">MuteSound                       <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SoundVolume                     <TD>Implemented                             <TD>Not implemented                                               <TD>Implemented
<TR><TH bgcolor="eeeeee">Stats                           <TD>Stats &amp;2000 - &amp;2011 implemented <TD>No stats implemented                                          <TD>No stats implemented
<TR><TH bgcolor="eeeeee">SetAudioParameters              <TD>Not implemented                         <TD>Implemented                                                   <TD>Implemented
<TR bgcolor="cccccc"><TH colspan="4">* Commands
<TR><TH bgcolor="eeeeee">SyncOffset                      <TD>Implemented                             <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">VideoInfo                       <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">AudioInfo                       <TD>Implemented                             <TD>Not implemented                                               <TD>Implemented
<TR><TH bgcolor="eeeeee">ReadL64002                      <TD>Not implemented                         <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">WriteL64002                     <TD>Not implemented                         <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">PacketInfo                      <TD>Not implemented                         <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">VideoSSave                      <TD>Not implemented                         <TD>Not implemented                                               <TD>Implemented
<TR><TH bgcolor="eeeeee">Read3520                        <TD>Not implemented                         <TD>Not implemented                                               <TD>Implemented
<TR><TH bgcolor="eeeeee">Write3520                       <TD>Not implemented                         <TD>Not implemented                                               <TD>Implemented
<TR bgcolor="cccccc"><TH colspan="4">System Variables
<TR><TH bgcolor="eeeeee">TVOn                            <TD>Used                                    <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG$PoduleNumber               <TD>Used                                    <TD>Ignored                                                       <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$PoduleNumber              <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$VideoOutputMode           <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferPreFill        <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferLowWaterMark   <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferHighWaterMark  <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$VideoBufferPreFill        <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$HorizontalShift           <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
</TBODY>
</TABLE>

<HR>

<H2><A name="user">4. User interface</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="programmer">5. Programmer interface</A></H2>

<P>Only those parts of the API that are implemented on the STB-400 are fully described.

<H3>5.1. Module Initialisation</H3>

<P>When MPEGDriver is initialised, it tests the MPEG chip and its private SDRAM. If it
detects a problem with either, it fails to complete initialisation, and returns one of the
following errors:

<TABLE cellspacing="2">
<THEAD align="left" valign="top">
<TR><TH>Error number <TH>Error message
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>&amp;818501  <TD>MPEG PLL did not lock
<TR><TD>&amp;818502  <TD>MPEG audio restart failed
<TR><TD>&amp;818503  <TD>MPEG SDRAM write timeout reached
<TR><TD>&amp;818504  <TD>MPEG SDRAM read timeout reached
<TR><TD>&amp;818505  <TD>MPEG SDRAM block move timeout reached
<TR><TD>&amp;818506  <TD>MPEG SDRAM data verification failed
</TBODY>
</TABLE>


<H3>5.2. Software Interrupts (SWIs)</H3>

<P>Most SWIs (all except MPEGVideo_CardControl, MPEGVideo_ReadParameters,
MPEGVideo_RegisterHandler and MPEGVideo_DeregisterHandler) are only intended to be called
by the MPEGSystem or MPEGTransport modules. Indeed, it would be difficult for anything
else to do so, since a valid video stream handle or audio stream handle are needed for
most SWIs, and these are only returned by MPEGDriver to MPEGSystem or MPEGTransport when
MPEGVideo_OpenStream or MPEGAudio_OpenStream are called. Since there is a level of trust
between the modules, error checking for these SWIs is minimal.

<P>For historical reasons, the video and audio SWIs are in two separate SWI chunks. The
MPEGVideo SWI chunk is the MPEGDriver module's "official" chunk, and the MPEGAudio SWIs
are serviced by using a second module header embedded within the module, and a minimal
module body that redirects audio SWIs into the main SWI handler entry point; in this way,
the benefits of the kernel's fast SWI dispatch code are not lost (as opposed to the
approach that MPEG2Video used, which was to claim the unknown SWI vector).

<P>Note that some relevant data structures are described in &sect;7.


<H4 align="right">MPEGVideo_OpenStream
<BR>(SWI &amp;49300)</H4>

<P>Open stream to the MPEG video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>control stream flags (as passed to MPEGSystem_OpenStream or
                 MPEGTransport_OpenStream)
<TR><TD>R1 = <TD>control stream handle
<TR><TD>R2 = <TD>pointer to video parameters structure (see &sect;7.1)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = video stream handle

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_OpenStream).

<P>This call performs all the actions necessary to be ready to accept an MPEG video
stream. If this call is successful it returns a video stream handle in R0 (otherwise R0 is
an error block pointer).


<H4 align="right">MPEGVideo_FullPackets
<BR>(SWI &amp;49301)</H4>

<P>Pass packet(s) of MPEG video data to the video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle
<TR><TD>R2 = <TD>pointer to one or more linked bitstream packet descriptors for packets
                 containing video data (see MPEGSystem/MPEGTransport specs)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_FullBuffers).

<P>This call passes packets of MPEG video data to the video decoder.


<H4 align="right">MPEGVideo_CloseStream
<BR>(SWI &amp;49302)</H4>

<P>Close MPEG video stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>bit <TH>meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>blank the MPEG video plane when the stream has closed
                      <TR><TD colspan="2">other bits are reserved, and must be zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 = <TD>video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_CloseStream).

<P>If in pause, slow-motion or trick-play mode, this call delinks all queuing bitstream
packets from the chain and frees them. Otherwise, it waits for all data to have been sent
to the decoders before returning (it needs to drop into user mode for this to happen, so
that callbacks go off).

<P>It is assumed that no more MPEGVideo_FullPackets calls will be made once this call has
started.


<H4 align="right">MPEGVideo_Play
<BR>(SWI &amp;49303)</H4>

<P>Control video data playback

<H5>On entry</H5>

<TABLE cellspacing="3">
<TBODY align="left" valign="top">
<TR><TD rowspan="4">R0 = <TD colspan="2">flags:
<TR>                     <TD>bit&nbsp;0&nbsp;clear&nbsp;=&gt; <TD>control unit has
                                     received confirmation that all necessary units have
                                     completed prefill, so video decode and presentation
                                     should now commence
<TR>                     <TD>bit 0 set =&gt;                  <TD>control unit anticipates
                                     either an end-of-stream or a stream timeout, and must
                                     be called back using SWI MPEGControl_Play, with flag
                                     bit 3 set, as soon as video presentation becomes idle
<TR>                     <TD colspan="2">other bits are reserved, and must be zero
<TR><TD>R1&nbsp;=        <TD colspan="2">video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules.
It is for internal use when negotiating start and stop of play.


<H4 align="right">MPEGVideo_SetSpeed
<BR>(SWI &amp;49304)</H4>

<P>Set speed of playback of video data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags:
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>bit <TH>meaning when set
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>0   <TD>if moving to a faster speed, defer the effect until
                                      the audio buffer rises to or above the audio buffer
                                      high water mark; if moving to a slower speed, defer
                                      the effect until the audio buffer falls to or below
                                      the audio buffer low water mark
                      <TR><TD colspan="2">other bits are reserved, and must be zero
                      </TBODY>
                      </TABLE>
<TR><TD>R1 = <TD>video stream handle
<TR><TD>R2 = <TD>speed indicator
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>Value  <TH>Effect
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0      <TD>pause
                 <TR><TD>1      <TD>normal speed
                 <TR><TD>2 - 16 <TD>slow motion, speed 1/R2
                 </TBODY>
                 </TABLE>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetSpeed).

<P>This call sets the playback speed of the video decoder, achieved by altering the number
of frames that each coded frame is displayed for. Flag bit 0 is typically set when data is
being supplied from a video server, and there is an unknown time delay before the server
starts delivering data at the new speed; in this way, we can avoid overrun or underrun
states. Conversely, in a situation where data is fetched as required (eg playing an MPEG
file via NFS) this would not be desirable behaviour, and the flag bit should be cleared.


<H4 align="right">MPEGVideo_CardControl
<BR>(SWI &amp;49305)</H4>

<P>Perform miscellaneous operations related to the MPEG hardware

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Claim MPEG-1 audio IRQ <I>(not implemented)</I>
<TR><TD>1 <TD>Release MPEG-1 audio IRQ <I>(not implemented)</I>
<TR><TD>2 <TD>Update MPEG-1 style control register
<TR><TD>3 <TD>Control power-down state <I>(not implemented)</I>
<TR><TD>4 <TD>Send MPEG-1 macro command <I>(not implemented)</I>
<TR><TD>5 <TD>Set output colour space <I>(not implemented)</I>
<TR><TD>6 <TD>Read STB22/3 status register <I>(not implemented)</I>
<TR><TD>7 <TD>Read STi3520 revision
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_CardControl 2
<BR>(SWI &amp;49305)</H4>

<P>Update state bits corresponding to those in the MPEG-1 hardware control register

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (2)
<TR><TD>R1 = <TD>EOR mask
<TR><TD>R2 = <TD>AND mask
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>old value
<TR><TD>R2 = <TD>new value
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is provided for backwards compatibility, to allow the SCART switching lines
to be controlled. The (virtual) control register is set to (old value AND R2) EOR R1.

<P>This call is the lowest level API for controlling the SCART switching lines that is
common to all STB versions.

<P>On STB-400 hardware, the SCART switching lines are controlled using an ARM7500FE
general-purpose I/O line (addressed using the PortMan module<SUP>[10]</SUP>) and outputs
from the TDA8540 video switch (addressed using the DENCDriver module<SUP>[9]</SUP>).
Different hardware is used to achieve the same effect on earlier STBs.

<P>When bit 5 of the control register is set, SCART pin 8 is driven high, which switches
the TV into its AV input mode (this is the CTRL0 signal). When bit 6 of the control
register is set, SCART pin 16 is driven high, which switches the TV to use the RGB input
lines on the SCART in preference to the CVBS line (this is the CTRL1 signal).

<P>Note that not all SCART-equipped TVs respond to one or both of these signals, and that
commonly only one SCART of multiple-socketed TVs is able to accept RGB input.

<P>Bits other than 5 or 6 are reserved and should not be altered (ie they should be set
in R2 and clear in R1).


<H4 align="right">MPEGVideo_CardControl 7
<BR>(SWI &amp;49305)</H4>

<P>Read STi3520 revision

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (7)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>flags:
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>bit <TH>meaning when set
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0   <TD>chip is STi3520L (rather than STi3520A)
                 <TR><TD colspan="2">other bits are reserved
                 </TBODY>
                 </TABLE>
<TR><TD>R2 = <TD>STi3520 chip revision number (eg &amp;BA =&gt; revision "BA")
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is provided so that unit test software can verify that the correct revision
of the Sti3520 has been fitted.


<H4 align="right">MPEGVideo_SetSCR
<BR>(SWI &amp;49306)</H4>

<P>Set the system clock in the video decoder

<P>This SWI is not implemented.


<H4 align="right">MPEGVideo_ReadParameters
<BR>(SWI &amp;49307)</H4>

<P>Read miscellaneous video stream parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read timecode and temporal reference <I>(not implemented)</I>
<TR><TD>1 <TD>Read direct access parameters for SetSCR <I>(not implemented)</I>
<TR><TD>2 <TD>Read various locations <I>(not implemented)</I>
<TR><TD>3 <TD>Read current STC value
<TR><TD>4 <TD>Read internal buffer fullness
<TR><TD>5 <TD>Check if display is ready
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_ReadParameters 3
<BR>(SWI &amp;49307)</H4>

<P>Read current STC value

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (3)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R1&nbsp;= <TD>bits 0 - 31 of STC
<TR><TD>R2 =      <TD>bit 32 of STC (in bit 0)
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call returns the current value of a 90kHz clock, the STC. In a typical
conventional decoder implementation, this would be slaved to the SCRs in a system or
program stream, or the PCRs in a transport stream. However, in the STB-400, there is too
much jitter in the rate of the incoming stream for this to be a useful strategy, so the
STC is determined by extrapolating from the most recently decoded audio PTS using one of
the ARM's internal 2MHz timers.

<P>If no audio stream is open, a value of zero is returned in both R1 and R2.


<H4 align="right">MPEGVideo_ReadParameters 4
<BR>(SWI &amp;49307)</H4>

<P>Read internal buffer fullness

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (4)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R1&nbsp;= <TD>number of bytes in internal video bit buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call reads the amount of data which is currently stored in the MPEG decoding
hardware's internal video bit buffer (ie excluding the amount queuing in the ARM's RAM,
waiting to be delivered). If no stream is open, a value of zero is returned.


<H4 align="right">MPEGVideo_ReadParameters 5
<BR>(SWI &amp;49307)</H4>

<P>Check if display is ready

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (5)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R1&nbsp;= <TD>1 if first picture has been displayed, else 0
</TBODY>
</TABLE>

<H5>Use</H5>

<P>When a stream is opened or reset, there is a time delay while buffers are filled and
predictor frames are decoded before the first video frame is displayed. This call allows
an application to determine if this has completed yet.


<H4 align="right">MPEGVideo_ResetStream
<BR>(SWI &amp;49308)</H4>

<P>Discard pre-buffered data and prepare to accept new stream data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reset stream flags (as passed to MPEGSystem_ResetStream or
                      MPEGTransport_ResetStream)
<TR><TD>R1 = <TD>video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>estimate of the amount of discarded video data in bytes
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_ResetStream).

<P>This call causes the video unit to discard all data not yet sent to the video decoding
hardware, and to instruct the hardware to discard any MPEG data stored in its internal
video bit buffer which has not yet been decoded.

<P>After discarding the data, the video unit enters largely the same state as after an
OpenStream call, ie in pause mode, waiting for sufficient data to issue a MPEGControl_Play
SWI. However, the display is not blanked, but is instead frozen at the last displayed
frame; this leads to a better presentation, especially when moving between different
trick-play streams.


<H4 align="right">MPEGVideo_DisplayStill
<BR>(SWI &amp;49309)</H4>

<P>Display still MPEG picture

<P>This SWI is not implemented.


<H4 align="right">MPEGVideo_Stats
<BR>(SWI &amp;4930A)</H4>

<P>Return values relating to the operation of the video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle, or zero to read stream-independent values
<TR><TD>R2 = <TD>pointer to list of statistic tags, terminated by -1
<TR><TD>R3 = <TD>pointer to word-aligned buffer to store results to
<TR><TD>R4 = <TD>size of buffer (in bytes)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R3&nbsp;= <TD>pointer to byte after last byte put into buffer
<TR><TD>R4 = <TD>value of R4 on entry minus the total size of the requested entries,
                 whether or not they were put into the buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_Stats).

<P>It has the equivalent functionality to MPEGSystem_Stats and MPEGTransport_Stats, but
just for the video unit stats.

<P>Tag values currently recognised are:

<TABLE cellspacing="2">
<THEAD align="left" valign="top">
<TR><TH>Tag       <TH>Value (all of length 4 bytes except where indicated)
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>&amp;1000 <TD>Number of MPEG video buffer underruns encountered
<TR><TD>&amp;1001 <TD>Number of bytes of video data received from control unit
<TR><TD>&amp;100B <TD>Number of bytes of video packet data which has been received but has
                      yet to be passed to the MPEG chip's private SDRAM
<TR><TD>&amp;1011 <TD>Information about the active area of the video (28 bytes):
                      <TABLE cellspacing="2">
                      <THEAD align="left" valign="top">
                      <TR><TH>Offset <TH>Meaning
                      </THEAD>
                      <TBODY align="left" valign="top">
                      <TR><TD>+0     <TD>width in coded samples (ie before scaling)
                      <TR><TD>+4     <TD>height in coded samples (ie before scaling)
                      <TR><TD>+8     <TD>overall aspect ratio (a fixed-point number: bits
                                         16-31 are the integer part, bits 0-15 are the
                                         fractional part)
                      <TR><TD>+12    <TD>centre x-coordinate (a signed number, in OS units)
                      <TR><TD>+16    <TD>centre y-coordinate (a signed number, in OS units)
                      <TR><TD>+20    <TD>width (in OS units, after scaling)
                      <TR><TD>+24    <TD>height (in OS units, after scaling)
                      </TBODY>
                      </TABLE>
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_RegisterHandler
<BR>(SWI &amp;4930B)</H4>

<P>Register a handler with the video unit

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>handler number
                      <TABLE cellspacing="2">
                      <TBODY align="left" valign="top">
                      <TR><TD>1      <TD>NTSC line 21 (odd field) data handler
                      <TR><TD>2      <TD>NTSC line 284 (even field) data handler
                      <TR><TD>others <TD>are not currently defined, and must not be
                                         registered
                      </TBODY>
                      </TABLE>
<TR><TD>R1 = <TD>address of handler function
<TR><TD>R2 = <TD>workspace pointer to pass to handler
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>The two SWIs MPEGVideo_RegisterHandler and MPEGVideo_DeregisterHandler allow one or
more separate modules to take over responsibility for handling part of the video stream.
The handler routine must meet the following conditions:

<H6>On entry</H6>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0-R7 = <TD>parameters (dependent on handler number)
<TR><TD>R8 =    <TD>handler number (equal to R0 when registered)
<TR><TD>R12 =   <TD>workspace pointer (equal to R2 when registered)
<TR><TD>R14 =   <TD>return address
<TR><TD colspan="2">Processor is in SVC mode
<TR><TD colspan="2">Interrupts are disabled
<TR><TD colspan="2">Fast interrupts are enabled

</TBODY>
</TABLE>

<H6>On exit</H6>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0-R7 <TD>are passed on to the next-most-recently-registered handler of the same
                  handler number (subject to R8)
<TR><TD>R8    <TD>should be preserved to pass the event on to the next handler;
                  <BR>should be set to 0 to claim the event and prevent it being passed on
<TR><TD colspan="2">R9, R10, R11 and R13 must be preserved
<TR><TD colspan="2">R12, R14 and the processor flags may be corrupted
</TBODY>
</TABLE>

<P>So far, only two handler numbers have been defined, one for odd field closed captioning
data, and one for even field closed captioning data. For example, a module which was only
interested in inserting EDS packets would only be interested in even field data, and so
would only register a routine for handler number 2. The handler parameters for both
handler numbers 1 and 2 are as follows:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =  <TD>flags word
<TR><TD>R1 =  <TD>pointer to caption data
<TR><TD>R2 =  <TD>number of bytes pointed to by R1
<TR><TD>R3-R7 <TD>are not defined, and must be preserved
</TBODY>
</TABLE>

<P>In other words, R0-R2 are set up for a call to Macrovision_LoadCaptions - and this is
indeed the action taken by the default handler, which for both odd and even field data is
in the MPEGCaptions module.

<P>Under this scheme, additional modules may be written to take any of the following
actions:

<UL>
<LI>monitoring the caption data stream but making no changes to it - for example,
    detecting and extracting a URL or email address that might have been included;
<LI>altering the caption data stream - for example, to insert EDS packets containing the
    current time;
<LI>replacing the line 21 functionality - for example, by interpreting the caption data
    and plotting text directly onto the VIDC graphics plane.
</UL>

<P>Type 1 and 2 handlers are called from an interrupt routine, with interrupts disabled.
This means that

<UL>
<LI>the handler code should execute as quickly as possible;
<LI>great caution should be taken when calling SWIs that are not re-entrant, as they may
    already be executing in the foreground - although Macrovision_LoadCaptions is not
    currently re-entrant, it will not be called from the foreground (at least, not during
    MPEG decode), so it is safe to call.
</UL>

<P>Another point to bear in mind when writing a caption handler is that the handler is
only called when at least one non-null caption byte has been detected in the MPEG stream.
This is a deliberate feature, as it allows for the frame skips which may occur as a normal
part of the video/audio synchronisation process to proceed without interrupting the flow
of caption data - subsequent data is effectively delayed by a frame until the next frame
that contains only null bytes on line 21. Handlers that wish to take action on frames
where no caption data is being transmitted (eg to insert EDS packets) must register a
routine on RISC OS's VSync event, and take action at that time if the caption handler has
not been called since the last VSync for the same field type, and providing that sufficent
frames have occurred that any extra data due to skipped frames will have been output.

<P>MPEGDriver currently understands two competing encodings of closed caption data within
an MPEG stream - those defined by DiviCom and C-Cube. The same handlers will be called
irrespective of which encoding method was used.


<H4 align="right">MPEGVideo_DeregisterHandler
<BR>(SWI &amp;4930C)</H4>

<P>Deregister a handler previously registered with MPEGVideo_RegisterHandler

<H5>On entry</H5>

<P>R0-R2 must match the values they had when registering the handler

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>For details, see the description of SWI MPEGVideo_RegisterHandler.


<H4 align="right">MPEGVideo_SetVideoParameters
<BR>(SWI &amp;4930D)</H4>

<P>Reads and writes various video parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD>R1 = <TD>video stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write video scaling type
<TR><TD>1 <TD>Read/write line 23 widescreen signalling state
<TR><TD>2 <TD>Read/write SCART pin 8 widescreen signalling state
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_SetVideoParameters 0
<BR>(SWI &amp;4930D)</H4>

<P>Read/write video scaling type

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">video stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 3 <TD>=&gt; set video scaling type
<TR>                     <TD>-1     <TD>=&gt; read video scaling type
<TR><TD>R3-R6&nbsp;=     <TD colspan="2">video scaling type parameters
                         <BR>(undefined if R2 = -1)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old video scaling type
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         <!-- weird Fresco formatting bug requires the above -->
<TR><TD>R3-R6&nbsp;= <TD colspan="2">old video scaling type parameters
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters, which has the same form but with
the control stream handle passed in R1).

<P>The video scaling type parameters are identical to offsets +40 - +52 of the video
parameters structure; they are described in more detail in &sect;7.1.


<H4 align="right">MPEGVideo_SetVideoParameters 1
<BR>(SWI &amp;4930D)</H4>

<P>Read/write line 23 widescreen signalling state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (1)
<TR><TD rowspan="2">R2 = <TD>0 to 8 <TD>=&gt; set WSS state
<TR>                     <TD>-1     <TD>=&gt; read WSS state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old WSS state
<TR><TD>R3 =         <TD>overriding WSS state set appropriate to this clip, or -1 if WSS
                         state isn't being overridden
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters).

<P>Line 23 widescreen signalling is applicable to PAL (and SECAM) TV signals, and is most
commonly used to switch 16:9 (widescreen) TVs between the various picture scaling modes
that are available. The signal is generated using the STi3520L's on-screen display, so
the relevant part of the graphics plane must be transparent for it to function.

<P>When using ScalingType 0, the WSS state can optionally be overridden automatically
according to the type of clip being played. In this case, R3 will return a value other
than -1.

<P>The WSS states passed in R2 have the following meanings:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>State <TH>Line 23 signal present? <TH>Protected area (used as aspect ratio label) <TH>Format      <TH>Position <TH>Active lines <TH>Notes / typical appearance on a widescreen TV
</THEAD>
<TBODY align="left" valign="top">
<TR>                 <TD>0     <TD>no                      <TD>-                                           <TD>-           <TD>-        <TD>-            <TD>control of widescreen state is not asserted
<TR>                 <TD>1     <TD>yes                     <TD>4:3                                         <TD>full format <TD>-        <TD>576          <TD>the 4:3 picture is centred and pillarboxed
<TR>                 <TD>2     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>centre   <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>3     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>top      <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>4     <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>centre   <TD>430          <TD>the 16:9 picture is displayed using the whole of the TV screen
<TR>                 <TD>5     <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>top      <TD>430          <TD>the 16:9 picture is displayed using the whole of the TV screen
<TR>                 <TD>6     <TD>yes                     <TD>&gt; 16:9                                   <TD>letterbox   <TD>centre   <TD>&lt; 430     <TD>the picture is centred and letterboxed, and uses the full width of the TV screen
<TR>                 <TD>7     <TD>yes                     <TD>14:9                                        <TD>full format <TD>centre   <TD>576          <TD>this is 4:3 with 14:9 shoot-and-protect, and is treated the same as other 14:9 formats by a 16:9 TV
<TR>                 <TD>8     <TD>yes                     <TD>16:9                                        <TD>full-format <TD>-        <TD>576          <TD>this is 16:9 anamorphic mode, and is stretched horizontally to fill the TV screen
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_SetVideoParameters 2
<BR>(SWI &amp;4930D)</H4>

<P>Read/write SCART pin 8 widescreen signalling state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (2)
<TR><TD rowspan="3">R2 = <TD>0  <TD>=&gt; set non-anamorphic mode (ie use high voltage
                                    on SCART pin 8 when TV AV input is asserted)
<TR>                     <TD>1  <TD>=&gt; set anamorphic mode (ie use intermediate voltage
                                    on SCART pin 8 when TV AV input is asserted)
<TR>                     <TD>-1 <TD>=&gt; read mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old mode
<TR><TD>R3 =         <TD>overriding mode set appropriate to this clip, or -1 if SCART
                         pin 8 state isn't being overridden
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters).

<P>The intermediate voltage on SCART pin 8 is used to signal to 16:9 TVs (and some 4:3
TVs) that the images it is receiving have been anamorphically squeezed, and that the TV
should re-size the image in order to display them at the correct aspect ratio. For 16:9
sets, this means stretching the image to fill the whole width of the screen; for 4:3 sets,
it means collapsing the image vertically, and adding black bars top and bottom.

<P>When using ScalingType 0, the SCART pin 8 mode can optionally be overridden
automatically according to the type of clip being played. In this case, R3 will return a
value other than -1.


<H4 align="right">MPEGVideo_GetSprite
<BR>(SWI &amp;4930E)</H4>

<P>Capture an MPEG video frame as a sprite

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle, or 0 to capture from the most recently opened stream
<TR><TD>R2 = <TD>pointer to control block of sprite area to create the sprite in, or 0 to
                 use the system sprite area
<TR><TD>R3 = <TD>pointer to the sprite name to use when creating the sprite
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_GetSprite).

<P>It is used in situations when the caller wishes to acquire the currently displaying
frame (or field, in the case of non-progressive video) as a sprite. The sprite created is
32bpp RGB; the largest image supported by STB-400 is 1620 macroblocks, or 414720 pixels,
so the caller should ensure that there is at least enough room for a sprite image of
1658880 bytes as well as the sprite control block. In particular, you should not
calculate the size requirement using stat &amp;1011, because although the final sprite
will have been trimmed down to match the active area, the SWI converts the entire coded
frame to a sprite in the course of its calculations, and needs enough room to hold it all
in the sprite area.

<P>Note that this SWI can take of the order of one second to complete on STB-400; this
means that sprite contents are undefined if the video stream is not paused or stopped in
some other way.


<H4 align="right">MPEGAudio_OpenStream
<BR>(SWI &amp;49340)</H4>

<P>Open stream to the MPEG audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>control stream flags (as passed to MPEGSystem_OpenStream or
                 MPEGTransport_OpenStream)
<TR><TD>R1 = <TD>control stream handle
<TR><TD>R2 = <TD>pointer to audio parameters structure (see &sect;7.2)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = audio stream handle

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_OpenStream).

<P>This call performs all the actions necessary to be ready to accept an MPEG audio
stream. If successful it returns an audio stream handle in R0 (otherwise R0 is an error
block pointer).


<H4 align="right">MPEGAudio_FullPackets
<BR>(SWI &amp;49341)</H4>

<P>Pass packet(s) of MPEG audio data to the audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
<TR><TD>R2 = <TD>pointer to one or more linked bitstream packet descriptors for packets
                 containing audio data (see MPEGSystem/MPEGTransport specs)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_FullBuffers).

<P>This call passes packets of MPEG audio data to the audio decoder.


<H4 align="right">MPEGAudio_CloseStream
<BR>(SWI &amp;49342)</H4>

<P>Close MPEG audio stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_CloseStream).

<P>If in pause or slow-motion mode, this call delinks all queuing bitstream packets from
the chain and frees them. Otherwise, it waits for all data to have been sent to the
decoders before returning (it needs to drop into user mode for this to happen, so that
callbacks go off).

<P>It is assumed that no more MPEGAudio_FullPackets calls will be made once this call has
started.


<H4 align="right">MPEGAudio_Play
<BR>(SWI &amp;49343)</H4>

<P>Control audio data playback

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD rowspan="4">R0 = <TD colspan="2">flags:
<TR>                     <TD>bit&nbsp;0&nbsp;clear&nbsp;=&gt; <TD>control unit has
                                     received confirmation that all necessary units have
                                     completed prefill, so audio decode and presentation
                                     should now commence
<TR>                     <TD>bit 0 set =&gt;                  <TD>control unit anticipates
                                     either an end-of-stream or a stream timeout, and must
                                     be called back using SWI MPEGControl_Play, with flag
                                     bit 4 set, as soon as audio presentation becomes idle
<TR>                     <TD colspan="2">other bits are reserved, and must be zero
<TR><TD>R1&nbsp;=        <TD colspan="2">audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules.
It is for internal use when negotiating start and stop of play.


<H4 align="right">MPEGAudio_SetSpeed
<BR>(SWI &amp;49344)</H4>

<P>Set speed of playback of audio data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
<TR><TD>R2 = <TD>speed indicator
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>Value  <TH>Effect
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0      <TD>pause
                 <TR><TD>1      <TD>normal speed
                 <TR><TD>2 - 16 <TD>slow motion, speed 1/R2
                 </TBODY>
                 </TABLE>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetSpeed).

<P>This call sets the playback speed of the audio decoder. If slow motion is selected,
the audio is muted, but decoding continues at a fractional speed so that synchronisation
is correct when returning to normal speed.


<H4 align="right">MPEGAudio_SkipFrame
<BR>(SWI &amp;49345)</H4>

<P>Skip an audio frame

<P>This SWI is not implemented.


<H4 align="right">MPEGAudio_RepeatFrame
<BR>(SWI &amp;49346)</H4>

<P>Repeat an audio frame

<P>This SWI is not implemented.


<H4 align="right">MPEGAudio_ResetStream
<BR>(SWI &amp;49347)</H4>

<P>Discard pre-buffered data and prepare to accept new stream data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reset stream flags (as passed to MPEGSystem_ResetStream or
                      MPEGTransport_ResetStream)
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>estimate of the amount of discarded audio data in bytes
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_ResetStream).

<P>This call causes the audio unit to discard all data not yet sent to the audio decoding
hardware, and to instruct the hardware to discard any MPEG data stored in its internal
audio bit buffer which has not yet been decoded.

<P>After discarding the data, the audio unit enters the same state as after an OpenStream
call, ie in pause mode, waiting for sufficient data to issue a MPEGControl_Play SWI.


<H4 align="right">MPEGAudio_MuteSound
<BR>(SWI &amp;49348)</H4>

<P>Mute/unmute sound

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags:
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>bit <TH>effect when set
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0   <TD>sound is muted
                 <TR><TD>other bits <TD>reserved, must be zero
                 </TBODY>
                 </TABLE>
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_MuteSound).

<P>This call mutes or unmutes the sound. Note that sound may still be off after an unmute
call due to other reasons, eg playing in fast-forward.


<H4 align="right">MPEGAudio_SoundVolume
<BR>(SWI &amp;49349)</H4>

<P>Adjust audio attenuation

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">flags (must be zero)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 256 <TD>=&gt; set volume (logarithmic scale)
<TR>                     <TD>-1       <TD>=&gt; read volume
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>old setting of sound volume
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SoundVolume).

<P>The volume control interface is logarithmic in its basis. The volume is specified in
units of 0.5 dB; a value of 256 corresponds to a nominal 0 dB volume setting ("normal
full volume"), so a value of 254 corresponds to 1 dB softer than full volume and so on.
In practice, hardware gain is only adjustable in steps of 2 dB, so the software maps the
requested volume setting onto the nearest available hardware setting.

<P>The volume setting 0 is special, in that it means not -128 dB but "off" or "muted".


<H4 align="right">MPEGAudio_Stats
<BR>(SWI &amp;4934A)</H4>

<P>Return values relating to the operation of the audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle, or zero to read stream-independent values
<TR><TD>R2 = <TD>pointer to list of statistic tags, terminated by -1
<TR><TD>R3 = <TD>pointer to word-aligned buffer to store results to
<TR><TD>R4 = <TD>size of buffer (in bytes)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R3&nbsp;= <TD>pointer to byte after last byte put into buffer
<TR><TD>R4 = <TD>value of R4 on entry minus the total size of the requested entries,
                 whether or not they were put into the buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_Stats).

<P>It has the equivalent functionality to MPEGSystem_Stats and MPEGTransport_Stats, but
just for the audio unit stats.

<P>No audio tag values are currently recognised.


<H4 align="right">MPEGAudio_SetAudioParameters
<BR>(SWI &amp;4934B)</H4>

<P>Reads and writes various audio parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD>R1 = <TD>audio stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write mute-on-bit-error state
<TR><TD>1 <TD>Read/write dual channel mode specifier
<TR><TD>2 <TD>Read/write suppress-sync-to-stream state
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGAudio_SetAudioParameters 0
<BR>(SWI &amp;4934B)</H4>

<P>Read/write mute-on-bit-error state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 or 1 <TD>=&gt; set mute-on-bit-error state
<TR>                     <TD>-1     <TD>=&gt; read mute-on-bit-error state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = old mute-on-bit-error state
<TR><TD>other registers preserved
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetAudioParameters).

<P>The mute-on-bit-errors state can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>=&gt; don't mute audio on bit errors
<TR><TD>1 <TD>=&gt; mute audio on bit errors (CRC failure)
</TBODY>
</TABLE>


<H4 align="right">MPEGAudio_SetAudioParameters 1
<BR>(SWI &amp;4934B)</H4>

<P>Read/write dual channel mode specifier

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (1)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 2 <TD>=&gt; set dual channel mode specifier
<TR>                     <TD>-1     <TD>=&gt; read dual channel mode specifier
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = old dual channel mode specifier
<TR><TD>R3 = current channel type
<TR><TD>other registers preserved
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetAudioParameters).

<P>The dual channel mode specifier can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>=&gt; output both channels normally
<TR><TD>1 <TD>=&gt; output left channel on both channels
<TR><TD>2 <TD>=&gt; output right channel on both channels
</TBODY>
</TABLE>

<P>The current channel type can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0  <TD>=&gt; stereo
<TR><TD>1  <TD>=&gt; joint stereo
<TR><TD>2  <TD>=&gt; dual mono
<TR><TD>3  <TD>=&gt; mono
<TR><TD>-1 <TD>=&gt; unknown
</TBODY>
</TABLE>


<H4 align="right">MPEGAudio_SetAudioParameters 2
<BR>(SWI &amp;4934B)</H4>

<P>Read/write suppress-sync-to-stream state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (2)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 or 1 <TD>=&gt; set suppress-sync-to-stream state
<TR>                     <TD>-1     <TD>=&gt; read suppress-sync-to-stream state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = old suppress-sync-to-stream state
<TR><TD>other registers preserved
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
during the processing of the end of a stream. Applications should never need to use the
equivalent call to MPEGControl_SetAudioParameters.

<P>The suppress-sync-to-stream state can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>=&gt; use the audio parameters structure to determine whether to
                    synchronise audio according to stream buffer levels
<TR><TD>1 <TD>=&gt; definitely do not synchronise the audio to the stream buffer
</TBODY>
</TABLE>


<H3>5.3. UpCalls</H3>

<H4 align="right">UpCall_MPEG
<BR>(UpCall &amp;15)</H4>

<P>An event has occurred in the MPEG modules

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">&amp;15 (MPEG event)
<TR><TD>R1 =             <TD colspan="2">flags (reserved, currently 0)
<TR><TD>R2 =             <TD colspan="2">control stream handle (if applicable) or 0
<TR><TD rowspan="4">R3 = <TD colspan="2">sub-reason code:
<TR>                     <TD>&amp;0000 - &amp;0FFF<SUP>&nbsp;</SUP>
                             <TD>assigned to the control unit, see MPEGSystem<SUP>[7]</SUP>
                                 and MPEGTransport<SUP>[8]</SUP> specifications
<TR>                     <TD>&amp;1000 - &amp;1FFF
                             <TD>assigned to the video unit, see below
<TR>                     <TD>&amp;2000 - &amp;2FFF
                             <TD>assigned to the audio unit (none currently issued)
<TR><TD colspan="3">Other registers depend upon the sub-reason code
</TBODY>
</TABLE>


<H4 align="right">UpCall_MPEG &amp;1000
<BR>(UpCall &amp;15)</H4>

<P>WSS state has changed

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>if the new WSS state was initiated automatically (ie due to a
                         stream with ScalingType 0 with automatic WSS enabled) this holds
                         the control stream handle; otherwise this is 0 (which is
                         guaranteed never to be a valid control stream handle)
<TR><TD>R3 =             <TD>&amp;1000
<TR><TD>R4 =             <TD>pixel aspect ratio of new WSS state, expressed as a 16.16
                         fixed-point number (eg square pixels would be &amp;10000)
<TR><TD>R5 =             <TD>percentage extra overscan at left due to new WSS state
<TR><TD>R6 =             <TD>percentage extra overscan at bottom due to new WSS state
<TR><TD>R7 =             <TD>percentage extra overscan at right due to new WSS state
<TR><TD>R8 =             <TD>percentage extra overscan at top due to new WSS state
<TR><TD colspan="2">Interrupt status is undefined
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the MPEGDriver when the WSS state in use is changed. This may
either be due to an external call to SWI MPEGVideo_SetVideoParameters 1, or due to the
opening or closing of a video stream with ScalingType 0 and automatic WSS enabled, or due
to a change in aspect ratio or active format descriptor at some point in the middle of
such a stream. If automatic WSS is in effect, any external call to
MPEGVideo_SetVideoParameters 1 will not affect the WSS signal generated, and so the UpCall
will not be issued.

<P>The call may have originated from an interrupt routine, so you must not enable
interrupts, and any processor-intensive work must be performed on a callback.


<H4 align="right">UpCall_MPEG &amp;1001
<BR>(UpCall &amp;15)</H4>

<P>SCART pin 8 widescreen state has changed

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>if the new SCART pin 8 widescreen state was initiated
                         automatically (ie due to a stream with ScalingType 0 with
                         automatic SCART pin 8 signalling enabled) this holds the control
                         stream handle; otherwise this is 0 (which is guaranteed never to
                         be a valid control stream handle)
<TR><TD>R3 =             <TD>&amp;1001
<TR><TD>R4 =             <TD>new SCART pin 8 widescreen state (see SWI
                         MPEGVideo_SetVideoParameters 2)
<TR><TD colspan="2">Interrupt status is undefined
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the MPEGDriver when the SCART pin 8 state in use is changed. This
may either be due to an external call to SWI MPEGVideo_SetVideoParameters 2, or due to the
opening or closing of a video stream with ScalingType 0 and automatic SCART pin 8
signalling enabled, or due to a change in aspect ratio or active format descriptor at some
point in the middle of such a stream. If automatic SCART pin 8 signalling is in effect,
any external call to MPEGVideo_SetVideoParameters 2 will not affect the SCART pin 8 signal
generated, and so the UpCall will not be issued.

<P>The call may have originated from an interrupt routine, so you must not enable
interrupts, and any processor-intensive work must be performed on a callback.


<H4 align="right">UpCall_MPEG &amp;1002
<BR>(UpCall &amp;15)</H4>

<P>Displayed active area will change at the next VSync

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>control stream handle
<TR><TD>R3 =             <TD>&amp;1002
<TR><TD colspan="2">Interrupts are disabled
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the MPEGDriver when a stream starts to be displayed, and whenever
one of the values in statistic &amp;1011 changes. Most notably, it is made when there is a
change in size, aspect ratio or active format descriptor in a stream that causes the
displayed size of the active area to change. It is expected that clients monitoring this
UpCall will use SWI MPEGControl_Stats to read statistic &amp;1011 for more information
about the new active area.

<P>When ScalingType is 0, a change in active format descriptor can cause the centre-point
of the active area to move without affecting its displayed size, so the UpCall is also
issued in this case. There can also be pan-and-scan offsets encoded in the stream that
cause the centre-point to change (but only if viewing mode Zoom is selected). By contrast,
When ScalingType is not 0, the centre-point is specified in the ScalingType parameters,
and so the centre-point only ever changes if someone has called SWI
MPEGVideo_SetVideoParameters 0.

<P>The call will have originated from an interrupt routine, so you must not enable
interrupts, and any processor-intensive work must be performed on a callback.


<H4 align="right">UpCall_MPEG &amp;1003
<BR>(UpCall &amp;15)</H4>

<P>Video slow-motion speed indicator has changed

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD>&amp;15 (MPEG event)
<TR><TD>R1 =             <TD>flags (reserved, currently 0)
<TR><TD>R2 =             <TD>control stream handle
<TR><TD>R3 =             <TD>&amp;1003
<TR><TD>R4 =             <TD>speed indicator (0 =&gt; pause, 1 =&gt; normal speed, 2 - 16
                             =&gt; slow motion, speed 1/R4)
<TR><TD colspan="2">Interrupts are enabled
<TR><TD colspan="2">Fast interrupts are enabled
<TR><TD colspan="2">Processor is in SVC mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers must be preserved, but processor flags may be corrupted

<H5>Use</H5>

<P>This call is made by the MPEGDriver when the slow-motion speed of the video decoder
changes: it may be during a call to SWI MPEGVideo_SetSpeed, or at some time after that,
depending upon whether the speed change is flagged to be deferred until the buffer
occupation level reaches a suitable criterion.


<H3>5.4. * Commands</H3>

<H4 align="right">*VideoInfo</H4>

<P>List counts of video events since the last OpenStream or ResetStream, and details read
from video headers leading up to the most recently presented video frame

<H5>Syntax</H5>

<P><CODE>*VideoInfo</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>This call lists video diagnostic information in the following categories:

<UL>
<LI>Bytecounts received and sent
<LI>PES packets and timestamps encoded and decoded
<LI>Frame skips and repeats (for synchronisation reasons)
<LI>Errors of various types
<LI>Video parameters that persist from the most recent set of sequence headers
<LI>Video parameters that persist from the most recent group-of-pictures header
<LI>Video parameters that were derived from the most recently presented video frame's
    headers
</UL>


<H4 align="right">*AudioInfo</H4>

<P>List counts of audio events since the last OpenStream or ResetStream, and details read
from audio headers from the most recently presented audio frame

<H5>Syntax</H5>

<P><CODE>*AudioInfo</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>This call lists audio diagnostic information in the following categories:

<UL>
<LI>Bytecounts received and sent
<LI>PES packets and timestamps encoded and decoded
<LI>Frames played fast or slow (for synchronisation reasons)
<LI>Errors of various types
<LI>Audio parameters that were parsed from the most recently presented audio frame header
</UL>


<H4 align="right">*PacketInfo</H4>

<P>Lists details of the currently queuing video and audio packets

<H5>Syntax</H5>

<P><CODE>*PacketInfo</CODE>

<H5>Parameters</H5>

<P>None

<H5>Use</H5>

<P>This call lists diagnostic information in the following categories:

<UL>
<LI>Number of packets waiting to be sent to the MPEG chip
<LI>The amount of data in those packets
<LI>The amount of data which has been sent to the MPEG chip but which has not yet been
    decoded
<LI>The current error in lipsync
</UL>


<H4 align="right">*VideoSSave</H4>

<P>Save the currently displaying MPEG video frame as a sprite

<H5>Syntax</H5>

<P><CODE>*VideoSSave <I>filename</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>filename</I></CODE>
<DD>file to save the captured sprite to
</DL>

<H5>Use</H5>

<P>This call provides a simple command line interface to SWI MPEGVideo_GetSprite. In
particular, it is restricted to capturing from the most recently-opened stream (which is
only significant in some theoretical implementation that is capable of decoding multiple
streams at once), but it does not require the setting up of a sprite area before use.


<H4 align="right">*Read3520</H4>

<P>Reads a byte from a register in the STi3520L, and prints the value read

<H5>Syntax</H5>

<P><CODE>*Read3520 <I>type register</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>type</I></CODE>
<DD>either "<CODE>V</CODE>" or "<CODE>A</CODE>", to read a video or audio register,
    respectively
<DT><CODE><I>register</I></CODE>
<DD>the register number
</DL>

<H5>Use</H5>

<P>This call allows you to perform raw reads of the STi3520L's registers. It is intended
for use only as a debugging aid. It will not be emulated in any future STB that uses a
different MPEG decoder, so it must not be used in any general-purpose applications.

<P>The register value is interpreted as a hexadecimal number by default (no
"<CODE>&amp;</CODE>" or "<CODE>0x</CODE>" prefix is required), but any other base may be
used by prefixing it with the base number (in decimal) and an underscore. For example,
"<CODE>10_80</CODE>" is interpreted as decimal 80, not decimal 128. The value printed is
in hexadecimal, with no prefix.


<H4 align="right">*Write3520</H4>

<P>Writes a byte into a register in the STi3520L

<H5>Syntax</H5>

<P><CODE>*Write3520 <I>type register value</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>type</I></CODE>
<DD>either "<CODE>V</CODE>" or "<CODE>A</CODE>", to write to a video or audio register,
    respectively
<DT><CODE><I>register</I></CODE>
<DD>the register number
<DT><CODE><I>value</I></CODE>
<DD>the byte to write
</DL>

<H5>Use</H5>

<P>This call allows you to perform raw writes to the STi3520L's registers. It is intended
for use only as a debugging aid. It will not be emulated in any future STB that uses a
different MPEG decoder, so it must not be used in any general-purpose applications.

<P>Both the register number and the byte value are interpreted as hexadecimal numbers by
default, but both may be expressed in any chosen base, in the same manner as the register
passed to *Read3520.


<H4 align="right">*Configure TVAspect</H4>

<P>

<H5>Syntax</H5>

<P><CODE>*Configure TVAspect <I>aspect</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>aspect</I></CODE>
<DD>either "<CODE>4:3</CODE>" or "<CODE>16:9</CODE>"
</DL>

<H5>Use</H5>

This call sets the default TV aspect ratio to be used at the next OpenStream, unless
a ScalingType other than 0 is in use, or unless otherwise specified in the ScalingType
parameters.


<H4 align="right">*Configure TVWSS</H4>

<P>

<H5>Syntax</H5>

<P><CODE>*Configure TVWSS <I>state</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>state</I></CODE>
<DD>a string which case-insensitively matches either "<CODE>on</CODE>" or
    "<CODE>off</CODE>"
</DL>

<H5>Use</H5>

This call sets whether line 23 and SCART pin 8 widescreen signalling is to be used from
the next OpenStream, unless a ScalingType other than 0 is in use, or unless otherwise
specified in the ScalingType parameters. The defaults for the two types of signalling
cannot be configured independently.


<H4 align="right">*Configure TVViewingMode</H4>

<P>

<H5>Syntax</H5>

<P><CODE>*Configure TVViewingMode <I>mode</I></CODE>

<H5>Parameters</H5>

<DL>
<DT><CODE><I>mode</I></CODE>
<DD>a string which case-insensitively matches "<CODE>box</CODE>", "<CODE>zoom</CODE>" or
    "<CODE>stretch</CODE>"
</DL>

<H5>Use</H5>

This call sets the default TV viewing mode to be used at the next OpenStream, unless
a ScalingType other than 0 is in use, or unless otherwise specified in the ScalingType
parameters.


<H3>5.5. System Variables</H3>

<H4 align="right">TVOn</H4>

<P>This is used during module initialisation to determine how the SCART CTRL lines (see
MPEGVideo_CardControl 2) should be initialised.

<TABLE border="1">
<THEAD align="left">
<TR bgcolor="eeeeee"><TH>TVOn variable setting <TH>SCART CTRL0 (pin 8)                         <TH>SCART CTRL1 (pin 16)
</THEAD>
<TBODY align="left">
<TR>                 <TD>Unset                 <TD>Low (TV tuner selected)                     <TD>Low (pin is ignored by TV)
<TR>                 <TD><CODE>RGB</CODE>      <TD>High or intermediate (TV AV input selected) <TD>High (TV uses R/G/B pins for signal and CVBS pin for sync)
<TR>                 <TD><CODE>CVBS</CODE>     <TD>High or intermediate (TV AV input selected) <TD>Low (TV uses CVBS pin for signal and sync)
<TR>                 <TD><CODE>YC</CODE>       <TD>High or intermediate (TV AV input selected) <TD>Low (pin is ignored by TV)
</TBODY>
</TABLE>


<H4 align="right">MPEG2$AudioBufferPreFill</H4>

<P>This is the buffer fullness (in bytes) that the audio buffer must reach before the
MPEGDriver module calls SWI MPEGControl_Play to signal that the audio unit has reached the
end-of-prefill condition. Note that more data may still be delivered to the buffer before
decoding is started if the video unit has not reached its own prefill-complete condition
(which is determined from vbv_delay in the picture header, combined with bit_rate from
the sequence header, and capped by vbv_buffer_size from the sequence header).


<H4 align="right">MPEG2$AudioBufferLowWaterMark</H4>

<P>This is the buffer fullness (in bytes) below which the MPEGDriver module will play an
audio frame slow, in the hopes of allowing the audio buffer to fill slightly. This
behaviour can be overridden by clearing bit 2 in the flags passed to
MPEGControl_OpenStream.


<H4 align="right">MPEG2$AudioBufferHighWaterMark</H4>

<P>This is the buffer fullness (in bytes) above which the MPEGDriver module will play an
audio frame fast, in the hopes of allowing the audio buffer to empty slightly. This
behaviour can be overridden by clearing bit 2 in the flags passed to
MPEGControl_OpenStream.


<HR>

<H2><A name="interchange">6. Data interchange</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="formats">7. Data formats</A></H2>

<H3>7.1 Video parameters structure</H3>

<P>A video parameters structure is a structure passed to MPEGControl_OpenStream, and
subsequently to MPEGVideo_OpenStream. It identifies parameters associated with the video
element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>FormatType: video parameters structure format type (0 at present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>don't clear screen contents before display (if this bit is
                           clear, the module assumes we're in a 16-bpp mode)
                   <TR><TD colspan="2">Bits 1 and 2 ignored (but used on STB-22 / STB-3)
                   <TR><TD colspan="2">Bits 3 to 15 reserved - set to zero
                   <TR><TD colspan="2">Bits 16 to 18 ignored (but used on STB-22 / STB-3)
                   <TR><TD>Bit&nbsp;19&nbsp;set&nbsp;=&gt;
                       <TD>ScalingType and the four subsequent entries are present
                           (if this is clear, default to Free scaling type with all
                           parameters set to NVRAM defaults)
                   <TR><TD colspan="2">Other bits are reserved and must be set to zero
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>ScreenMode: mode specifier (ie number or pointer to mode selector
                   block) for screen mode to select (or -1 to indicate no screen mode
                   change)
<TR><TD>12     <TD>Reserved: must be zero
<TR><TD>16     <TD>Reserved: must be zero
<TR><TD>20     <TD>Reserved: must be zero
<TR><TD>24     <TD>Reserved: must be zero
<TR><TD>28     <TD>Ignored (but used on STB-22 / STB-3)
<TR><TD>32     <TD>Ignored (but used on STB-22 / STB-3)
<TR><TD>36     <TD>ScalingType: determines how horizontal and vertical video scaling
                   should be performed:
                   <TABLE cellspacing="2">
                   <THEAD align="left" valign="top">
                   <TR><TH>Value <TH>Scaling type
                   </THEAD>
                   <TBODY align="left" valign="top">
                   <TR><TD>0     <TD>Free (width and height calculated from video headers,
                                     TV aspect and viewing mode)
                   <TR><TD>1     <TD>Fixed width
                   <TR><TD>2     <TD>Fixed height
                   <TR><TD>3     <TD>Fixed width and height
                   </TBODY>
                   </TABLE>
                   The interpretation of offsets 40-52 also depend upon this value.
<TR><TD>40-52  <TD>ScalingType parameters:
                   <TABLE cellspacing="2">
                   <TBODY align="left" valign="top">
                   <TR><TH colspan="2">ScalingType 0:
                   <TR><TD>40 <TD>Flags:
                              <BR>bit 0 set =&gt; value at +44 is valid; otherwise use
                                  NVRAM to determine setting
                              <BR>bit 1 set =&gt; bits 0 and 1 at +48 are valid; otherwise
                                  use NVRAM to determine settings
                              <BR>bit 2 set =&gt; value at +52 is valid; otherwise use
                                  NVRAM to determine setting
                              <BR>other bits are reserved, and must be zero
                              <BR>All of bits 0-2 will be set when reading the ScalingType
                                  parameters with SWI MPEGVideo_SetVideoParameters 0, and
                                  all the fields below will be correctly set up.
                   <TR><TD>44 <TD>TV aspect ratio: 0 =&gt; 4:3, 1 =&gt; 16:9
                   <TR><TD>48 <TD>Image scaling flags:
                              <BR>bit 0 set =&gt; use line 23 widescreen signalling
                              <BR>bit 1 set =&gt; use SCART pin 8 widescreen signalling
                              <BR>other bits are reserved, and must be zero
                   <TR><TD>52 <TD>Viewing mode (see below): 0 =&gt; Box, 2 =&gt; Zoom,
                                  3 =&gt; Stretch, others are undefined and reserved
                   <TR><TH colspan="2">ScalingType 1:
                   <TR><TD>40 <TD>0 =&gt; TV has conventional pixel aspect ratio for this
                                  TV standard,
                                  1 =&gt; TV is in anamorphic mode (wide pixels)
                   <TR><TD>44 <TD>Width (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 2:
                   <TR><TD>40 <TD>0 =&gt; TV has conventional pixel aspect ratio for this
                                  TV standard,
                                  1 =&gt; TV is in anamorphic mode (wide pixels)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 3:
                   <TR><TD>40 <TD>Width (OS units)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   </TBODY>
                   </TABLE>
</TBODY>
</TABLE>

<P>The process of interpreting a ScalingType begins by calculating the coded frame aspect
ratio (using the aspect_ratio_information, horizontal_size, vertical_size,
display_horizontal_size and display_vertical_size fields from the video sequence header
and, if present, the sequence display extension). If an Active Format Descriptor is
present, then an active area aspect ratio and optionally a protected area aspect ratio
within the coded frame can be distinguished; otherwise both default to the same as the
coded frame. See the glossary for a greater discussion of these terms.

<P>ScalingType 0, viewing mode Box: in this case, X and Y scaling are applied equally so
that the <I>protected area</I> fits wholly within the TV displayable area.

<P>ScalingType 0, viewing mode Zoom: in this case, X and Y scaling are applied equally so
that the active area fills the TV displayable area, with minimal overscan.

<P>ScalingType 0, viewing mode Stretch: in this case, X and Y scaling are independently
applied so that the active area exactly fits the TV displayable area.

<P>ScalingType 1: in this case, X and Y scaling factors are applied equally so that the
active area is the specified width.

<P>ScalingType 2: in this case, X and Y scaling factors are applied equally so that the
active area is the specified height.

<P>ScalingType 3: in this case, X and Y scaling are independently applied so that the
active area is the specified width and height.

<P>In practice, the STi3520L can only scale vertically by a strictly limited set of
factors, so the vertical scale will be calculated first. Where an exact match is not
possible, the module will select a scaling factor with excessive downsampling (unless the
ideal scaling factor is smaller than the minimum, in which case the smallest factor will
be selected). In the case of Box and Zoom viewing modes, and in ScalingTypes 1 and 2, the
horizontal scale factor will then be matched to the vertical scaling factor, even if it
differs from the ideal.

<P>When ScalingType 0 is selected, MPEGDriver can be instructed to automatically use
line 23 widescreen signalling (WSS) and/or SCART pin 8 widescreen signalling, to achieve
the best possible picture resolution on the selected TV. Note that line 23 WSS can
effectively increase the range of vertical scale factors available on a 16:9 TV, in
addition to its role in signalling when the video is anamorphically squeezed.

<P>When ScalingTypes 1 or 2 are used, the word at +40 should only be set to 1 if
either MPEGVideo_SetVideoParameters 1 or 2 have been (or are about to be) used to signal
to the TV that the picture is anamorphically squeezed. This is not done automatically in
this case.

<P>Note that OS coordinates outside the normal screen range can be used, for example to
support 2x upscaling.

<H4>Viewing mode examples</H4>

This is how a selection of picture types would be represented on a 4:3 TV set using each
of the viewing modes:

<TABLE border="1" cellpadding="6">
<TBODY align="center">
<TR bgcolor="eeeeee"><TH rowspan="3" bgcolor="ffffff">&nbsp; <TH>Active area    <TH>4:3                                              <TH>16:9                                                     <TH>16:9
<TR bgcolor="eeeeee">                                        <TH>Protected area <TH>4:3                                              <TH>4:3                                                      <TH>16:9
<TR bgcolor="eeeeee">                                        <TH>Coded frame    <TH>4:3                                              <TH>16:9                                                     <TH>16:9

<TR><TH bgcolor="eeeeee">Viewing mode                        <TH>&nbsp;         <TH>&nbsp;                                           <TH>&nbsp;                                                   <TH>&nbsp;
<TR><TH bgcolor="eeeeee">Box                                 <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="crop/169p43.jpg" width="192" height="144">     <TD><IMG src="bars/169.jpg" width="192" height="144">
<TR><TH bgcolor="eeeeee">Zoom                                <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="crop/169p43.jpg" width="192" height="144">     <TD><IMG src="crop/169.jpg" width="192" height="144">
<TR><TH bgcolor="eeeeee">Stretch                             <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="stretch/169p43.jpg" width="192" height="144">  <TD><IMG src="stretch/169.jpg" width="192" height="144">
</TBODY>
</TABLE>

This is how a selection of picture types would be represented on a 16:9 TV set using each
of the viewing modes:

<TABLE border="1" cellpadding="6">
<TBODY align="center">
<TR bgcolor="eeeeee"><TH rowspan="3" bgcolor="ffffff">&nbsp; <TH bgcolor="eeeeee">Active area    <TH>4:3                                                 <TH>4:3                                                      <TH>16:9
<TR bgcolor="eeeeee">                                        <TH bgcolor="eeeeee">Protected area <TH>4:3                                                 <TH>14:9                                                     <TH>16:9
<TR bgcolor="eeeeee">                                        <TH bgcolor="eeeeee">Coded frame    <TH>4:3                                                 <TH>4:3                                                      <TH>16:9

<TR><TH bgcolor="eeeeee">Viewing mode                        <TH>&nbsp;                          <TH>&nbsp;                                              <TH>&nbsp;                                                   <TH>&nbsp;
<TR><TH bgcolor="eeeeee">Box                                 <TH>&nbsp;                          <TD><IMG src="bars/43.jpg" width="256" height="144">    <TD><IMG src="halfcrop/43p149.jpg" width="256" height="144"> <TD><IMG src="full/169.jpg" width="256" height="144">
<TR><TH bgcolor="eeeeee">Zoom                                <TH>&nbsp;                          <TD><IMG src="crop/43.jpg" width="256" height="144">    <TD><IMG src="crop/43p149.jpg" width="256" height="144">     <TD><IMG src="full/169.jpg" width="256" height="144">
<TR><TH bgcolor="eeeeee">Stretch                             <TH>&nbsp;                          <TD><IMG src="stretch/43.jpg" width="256" height="144"> <TD><IMG src="stretch/43p149.jpg" width="256" height="144">  <TD><IMG src="full/169.jpg" width="256" height="144">
</TBODY>
</TABLE>


<H3>7.2 Audio parameters structure</H3>

<P>An audio parameters structure is a structure passed to MPEGControl_OpenStream, and
subsequently to MPEGAudio_OpenStream. It identifies parameters associated with the audio
element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>Audio structure format type (0 at present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>mute audio on bit errors
                   <TR><TD>Bit&nbsp;1&nbsp;set =&gt;
                       <TD>dual channel mode specifier field is valid
                   <TR><TD colspan="2">Other bits are reserved and must be set to zero
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>Dual channel mode specifier (only valid if bit 1 of Flags
                   is set)
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>0 =&gt; <TD>play both channels
                   <TR><TD>1 =&gt; <TD>play left channel only
                   <TR><TD>2 =&gt; <TD>play right channel only
                   </TBODY>
                   </TABLE>
<TR><TD>12...  <TD>Reserved for future expansion
</TBODY>
</TABLE>

<HR>

<H2><A name="internal">8. Internal dependencies</A></H2>

<UL>
<LI>Target hardware must be available for testing.
<LI>A variety of MPEG clips (eg some coded as 16:9, some with Active Format Descriptors,
some with field-pictures, some with dual-mono audio) must be obtained.
</UL>

<HR>

<H2><A name="acceptance">9. Acceptance test</A></H2>

<UL>
<LI>The module must function on target hardware as specified.
<LI>The executable code of the module must be less than 128K long.
<LI>The workspace used by the module must not exceed 8K plus 8K per open stream (excluding
queuing bitstream packets).
</UL>

<HR>

<H2><A name="noncompliances">10. Noncompliances</A></H2>

<P>There are no noncompliances.

<HR>

<H2><A name="test">11. Development test strategy</A></H2>

<UL>
<LI>All SWIs must function as specified
<LI>All * commands must function as specified
<LI>Program element handler entry points must function correctly (see MPEGTransport spec
    <SUP>[8]</SUP>)
</UL>

<P>These criteria will primarily be tested by using the BASIC player, with extensions
added as necessary. In most cases, the BASIC player will call either MPEGSystem or
MPEGTransport (both will be used in testing), which will then call MPEGDriver. The C code
parts of MPEGDriver will be examined using the McCabe analysis software, subject to
availability.

<HR>

<H2><A name="organisation">12. Product organisation</A></H2>

<P>The MPEGDriver module is written in a mixture of C and assembler. It will be built into
the STB-400 ROM, but can also be softloaded in order to deliver patches.

<HR>

<H2><A name="enhancements">13. Future enhancements</A></H2>

<P>None planned at present.

<HR>

<H2><A name="glossary">14. Glossary</A></H2>

<DL>
<DT>active area (aspect ratio)
    <DD>the shape of the part of a coded frame excluding any black bars (top and bottom
    or left and right) that are transmitted as part of the picture.
<DT>anamorphic
    <DD>typically used to describe the use of all luminance and chrominance samples and
    all scan lines to fully describe a 16:9 image, rather than a 4:3 image. Each pixel
    is therefore describing a region that is notably wider than it is tall, as opposed
    to the traditional arrangement where a pixel was approximately the same width as
    height. Thus, when an anamorphic signal is displayed unaltered on a 4:3 TV, it appears
    to have been squashed horizontally, producing a characteristic "tall, thin people"
    effect.
<DT>AV
    <DD>Audio/Video - often used to refer to the unmodulated video and audio inputs of a
    TV (for example, the SCART socket).
<DT>bpp
    <DD>bits per pixel.
<DT>coded frame (aspect ratio)
    <DD>the shape of the rectangle enclosing every coded pixel in an image. This is
    commonly determined by the image aspect ratio, but sometimes has to be calculated
    from the pixel aspect ratio in combination with the number of pixel rows and columns.
<DT>CRC
    <DD>Cyclic Redundancy Check - a common checksum algorithm that is used to detect
    errors in data. The MPEG audio specification allows CRCs to be embedded into audio
    streams.
<DT>CVBS
    <DD>Composite Video Baseband Video - a signal combining luminance and chrominance
    samples, but which has not been modulated to RF.
<DT>IEC
    <DD>International Engineering Consortium.
<DT>ISO
    <DD>International Standards Organisation.
<DT>letterbox
    <DD>the technique for displaying a picture entirely within a display of lesser ratio,
    by adding black bars top and bottom.
<DT>MPEG
    <DD>Moving Picture (Motion Pictures) Experts Group - the nickname of SubCommittee 29
    of Working Group 11 of ISO/IEC Joint Technical Committee 1.
<DT>MPEG-1
    <DD>the nickname of ISO/IEC 11172 (see References).
<DT>MPEG-2
    <DD>the nickname of ISO/IEC 13818 (see References).
<DT>NTSC
    <DD>National Television System Committee (of the Electronics Industries Association,
    the organisation which defined the standard format adopted by the FCC for broadcast
    television in the USA). Commonly used to refer to the standard-resolution, composite,
    colour video standard in use in the USA, Japan, Canada and Mexico.
<DT>PAL
    <DD>Phase Alternation by Line - the standard-resolution, composite, colour video
    standard in use in the UK and most of western Europe (with the notable exception of
    France).
<DT>PCR
    <DD>Program Clock Reference - a 90kHz time reference in a transport stream, used for
    synchronisation of MPEG playback. Where a transport stream contains multiple programs,
    each program will typically have its own PCR unrelated to the other programs.
<DT>PES
    <DD>Packetized Elementary Stream - a stream of variable-length packets from only one
    elementary stream (normally either video or audio). It requires transmission or
    storage in relatively error-free media.
<DT>pillarbox
    <DD>the technique for displaying a picture entirely within a display of greater ratio,
    by adding black bars left and right.
<DT>protected area (aspect ratio)
    <DD>the shape of the part of the active area that has been protected by
    shoot-and-protect filming. This typically allows a display which is closer in shape to
    the protected area than the active area to discard unnecessary parts of the picture.
<DT>PTS
    <DD>Presentation Time Stamp - the value of the STC at which an encoded item is
    intended to be presented (in an idealised decoder).
<DT>RGB
    <DD>Red/Green/Blue - a method of storing or transmitting colour information (eg using
    pins 15, 11 and 7 of a SCART lead).
<DT>SCART
    <DD>common name for the standard 21-pin connector approved by the Syndicat des
    Constructeurs Audio, Radio et T&eacute;l&eacute;vision, also known as Peritel or
    Euroconnector, which can (in its two main configurations) carry two-way mono or stereo
    audio and composite video and one-way S-video (luminance/chrominance) or RGB, as well
    as a couple of switching signals and data lines.
<DT>SCR
    <DD>System Clock Reference - a 90kHz timestamp in system or program streams, used for
    synchronisation of MPEG playback. Since a system or program stream can contain only
    one program, it has only a single clock reference, the SCR.
<DT>SECAM
    <DD>SEquentiel Coleur Avec M&eacute;moire - the standard-resolution, composite, colour
    video standard used in France, Eastern Europe, the Middle East, the former Soviet
    Union and many former French colonies. STB-400 cannot support SECAM.
<DT>shoot-and-protect
    <DD>the filming technique whereby, although a certain area is recorded to film or
    video, all the important action and detail is kept within a smaller region (an "area
    of interest", or as we are calling it here, the "protected area"). This allows
    displays that match the shape of the smaller region to discard the unnecessary
    material, but at the same time, does not require displays that match the shape of the
    original area to display black bars top and bottom or left and right.
<DT>STB
    <DD>Set Top Box.
<DT>STC
    <DD>System Time Clock - a 90kHz clock used in MPEG synchronisation.
<DT>SWI
    <DD>SoftWare Interrupt - basic OS function call.
<DT>VBV
    <DD>Video Buffering Verifier - a hypothetical decoder that is conceptually connected
    to the output of an MPEG video encoder. Its purpose is to provide a constraint on the
    variability of the data rate that an encoder or editing process may produce.
<DT>WSS
    <DD>WideScreen Signalling - a waveform which can be present on scan line 23 of B, D,
    G, H and I variant PAL (and SECAM) video formats, and indicates a number of features
    of the video signal (most notably the aspect ratio).
</DL>

<HR>

<H2><A name="references">15. References</A></H2>

<OL>
  <LI>SGS-Thomson STi3520L data sheet.
  <LI>ISO/IEC 11172: Information technology &mdash; Coding of moving pictures
      and associated audio for digital storage media at up to about 1,5 Mbit/s.
      Published in these parts:
      <UL>
        <LI>Part 1: Systems (1993)
        <LI>Part 2: Video (1993)
        <LI>Part 3: Audio (1993)
        <LI>Part 4: Conformance testing (1995)
        <LI>Part 5 (Technical Report): Software simulation (1998)
      </UL>
  <LI>ISO/IEC 13818: Information technology &mdash; Generic coding of moving
      pictures and associated audio information. Published in these parts:
      <UL>
        <LI>Part 1: Systems (1996)
        <LI>Part 2: Video (1996)
        <LI>Part 3: Audio (1998)
        <LI>Part 4: Conformance testing (1998)
        <LI>Part 5 (Technical Report): Software simulation (1997)
        <LI>Part 6: Extensions for DSM-CC (1998)
        <LI>Part 7: Advanced Audio Coding (1997)
        <LI>Part 9: Extension for real time interface for systems decoders (1996)
        <LI>Part 10: Conformance extensions for DSM-CC (1999)
      </UL>
  <LI>2501,812/FS: STB-400 Functional Specification.
  <LI>2501,828/FS: STB-400 OS ROM Functional Specification.
  <LI>2309,306/FS: MPEGControl 2.xx Module Software Functional Specification.
  <LI>2309,309/FS: MPEGSystem Module Functional Specification.
  <LI>2309,330/FS: MPEGTransport Module Functional Specification.
  <LI>2501,824/FS: DENCDriver Module Functional Specification.
  <LI>2309,331/FS: Port Manager Module Functional Specification.
</OL>

<HR>

<H2><A name="history">16. History</A></H2>

<TABLE width="100%" border="0" cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD><STRONG>Issue</STRONG>  <TD><STRONG>Date</STRONG>  <TD><STRONG>Author</STRONG>  <TD><STRONG>Description of change</STRONG>
<TR><TD>A                       <TD>09&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Initial version.
<TR><TD>B                       <TD>23&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Updated after review.
<TR><TD>1                       <TD>23&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Added AMR number.
<TR><TD>2                       <TD>22&nbsp;Oct&nbsp;1999  <TD>BAvison                  <TD>Resolved S-Video through SCART outstanding issue (we're not implementing it). Changed references to which hardware controls SCART switching lines, and added support for SCART pin 8 widescreen signalling. Added API for extracting STi3520 revision number.
<TR><TD>2A                      <TD>28&nbsp;Apr&nbsp;2000  <TD>BAvison                  <TD>Added errors returned on module initialisation. Changed screen-blanking behaviour on ResetStreams and CloseStreams. Added deferred-set-speed flag for use when playing from a server. Reintroduced SWI MPEGVideo_ReadParameters 3. Added lists of supported Stats tags. Changed line 23 WSS state numbers to ignore parity bit (gives us a much more sensible order). No longer requires video stream handle to read/write line 23 or SCART pin 8 WSS. Now possible to read the overriding line 23 and SCART pin 8 WSS states. SWI MPEGAudio_SetVolume is no longer a future enhancement. Added details of all UpCalls. Split *VideoInfo into *VideoInfo and *AudioInfo, and listed details of what they output. Added *Configure keywords. Reintroduced details of default SCART signalling when outputting S-Video through SCART. Added flags to ScalingType parameters for ScalingType 0, to allow selective use of NVRAM defaults. Removed viewing mode "Box", and renamed viewing mode "Auto" to be "Box" instead.
<TR><TD>2B                      <TD>12&nbsp;May&nbsp;2000  <TD>BAvison                  <TD>Minor changes to the UpCall reason codes. Documented *Read3520 and *Write3520. Various bits of tidying up that I missed in the last issue.
<TR><TD>2C                      <TD>18&nbsp;May&nbsp;2000  <TD>BAvison                  <TD>Added description of new UpCall_MPEG reason code, &amp;1003.
<TR><TD>2D                      <TD>26&nbsp;May&nbsp;2000  <TD>BAvison                  <TD>Added description of SWI MPEGVideo_GetSprite and *VideoSSave.
<TR><TD>2E                      <TD>20&nbsp;Jun&nbsp;2000  <TD>BAvison                  <TD>Added description of *PacketInfo.
<TR><TD>2F                      <TD>18&nbsp;Jul&nbsp;2000  <TD>BAvison                  <TD>Added description of new functionality of the Play SWIs in end-of-stream / stream timeout detection.
<TR><TD>2G                      <TD>10&nbsp;Aug&nbsp;2000  <TD>BAvison                  <TD>Added description of SWIs MPEGVideo_RegisterHandler, MPEGVideo_DeregisterHandler and MPEGAudio_SetAudioParameters 2.

</TBODY>
</TABLE>


</BODY>
</HTML>
