<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML lang="en">
<HEAD>
  <META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <TITLE>MPEGDriver Module Functional Specification</TITLE>
</HEAD>

<BODY bgcolor="#ffffff">

<H1 align="center">MPEGDriver Module Functional Specification</H1>

<HR>

<P align="center"><STRONG>CONFIDENTIAL</STRONG>

<HR>

<TABLE border="0" width="50%" align="center">
<TR><TD>Document ref:    <TD>2501,823/FS
<TR><TD>Issue:           <TD>2
<TR><TD>Date:            <TD>22 Oct 1999
<TR><TD>Author(s):       <TD><A href="mailto:ben.avison@pace.co.uk">Ben Avison</A>
<TR><TD>Change:          <TD>ECO 4256
<TR><TD>Classification:  <TD>Pace Restricted
</TABLE>

<H2>Contents</H2>

<TABLE border="0" width="100%">
<TR><TD width="8%">1 <TD><A href="#overview">       Overview</A>
<TR><TD>2            <TD><A href="#outstanding">    Outstanding issues</A>
<TR><TD>3            <TD><A href="#technical">      Technical background</A>
<TR><TD>4            <TD><A href="#user">           User interface</A>
<TR><TD>5            <TD><A href="#programmer">     Programmer interface</A>
<TR><TD>6            <TD><A href="#interchange">    Data interchange</A>
<TR><TD>7            <TD><A href="#formats">        Data formats</A>
<TR><TD>8            <TD><A href="#internal">       Internal dependencies</A>
<TR><TD>9            <TD><A href="#acceptance">     Acceptance test</A>
<TR><TD>10           <TD><A href="#noncompliances"> Noncompliances</A>
<TR><TD>11           <TD><A href="#test">           Development test strategy</A>
<TR><TD>12           <TD><A href="#organisation">   Product organisation</A>
<TR><TD>13           <TD><A href="#enhancements">   Future enhancements</A>
<TR><TD>14           <TD><A href="#glossary">       Glossary</A>
<TR><TD>15           <TD><A href="#references">     References</A>
<TR><TD>16           <TD><A href="#history">        History</A>
</TABLE>

<HR>

<H2><A name="overview">1. Overview</A></H2>

<P>This document specifies the software module MPEGDriver, which is the hardware driver
for the SGS-Thomson STi3520L MPEG decoder chip<SUP>[1]</SUP>. The STi3520L provides the
MPEG-1<SUP>[2]</SUP> and MPEG-2<SUP>[3]</SUP> video and audio decoding capability of the
STB-400<SUP>[4] [5]</SUP>. MPEGDriver is responsible for taking the elementary or
packetised elementary video and audio streams provided by the rest of the MPEG stack,
feeding them into the hardware, and controlling the decode and display processes within
the chip. The software API is designed to be broadly compatible with those of the
MPEGVideo, MPEGAudio and MPEG2Video modules used in earlier STBs, so that it can be used
with the MPEGControl<SUP>[6]</SUP>, MPEGSystem<SUP>[7]</SUP> and
MPEGTransport<SUP>[8]</SUP> modules without requiring significant code changes to them;
MPEGDriver will also feature a few API enhancements, notably to allow access to the video
scaling abilities of the STi3520L. Both 525-line (eg NTSC) and 625-line (eg PAL-I) TV
standards are automatically supported, in conjunction with the DENCDriver
module<SUP>[9]</SUP>.

<HR>

<H2><A name="outstanding">2. Outstanding issues</A></H2>

<P>The available parameters to MPEGVideo_Stats and MPEGAudio_Stats, and the items listed
by the *VideoInfo command, are unlikely to be determined until coding is largely complete.

<HR>

<H2><A name="technical">3. Technical background</A></H2>

<P>Here is a comparative table of features of the MPEG drivers of past, present and future
STBs:

<BR><BR>

<TABLE border="1">
<TBODY align="left">
<TR bgcolor="eeeeee"><TH>STB generation                  <TH>STB-1, STB-21                           <TH>STB-22, STB-24, STB-3                                         <TH>STB-400
<TR bgcolor="eeeeee"><TH>MPEG hardware                   <TH>C-Cube CL450, TI TMS320AV110            <TH>LSI L64002                                                    <TH>ST STi3520L
<TR bgcolor="eeeeee"><TH>Module name(s)                  <TH>MPEGVideo, MPEGAudio                    <TH>MPEG2Video                                                    <TH>MPEGDriver
<TR bgcolor="cccccc"><TH colspan="4">MPEGVideo SWIs
<TR><TH bgcolor="eeeeee">OpenStream                      <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">FullPackets                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CloseStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">Play                            <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SetSpeed                        <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CardControl                     <TD>Reason codes 0-5 implemented            <TD>Reason codes 2 &amp; 6 implemented                            <TD>Reason codes 2 &amp; 7 implemented
<TR><TH bgcolor="eeeeee">SetSCR                          <TD>Implemented                             <TD>Implemented (but not used)                                    <TD>Not implemented
<TR><TH bgcolor="eeeeee">ReadParameters                  <TD>Reason codes 0-5 implemented            <TD>Reason codes 1-5 implemented                                  <TD>Reason codes 4 &amp; 5 implemented
<TR><TH bgcolor="eeeeee">ResetStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">DisplayStill                    <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">Stats                           <TD>Stats &amp;1000 - &amp;100B implemented <TD>Stats &amp;1000, &amp;1001, &amp;100B - &amp;1010 implemented <TD>Implemented
<TR><TH bgcolor="eeeeee">RegisterHandler                 <TD>Not implemented                         <TD>Implemented                                                   <TD>Future enhancement
<TR><TH bgcolor="eeeeee">DeregisterHandler               <TD>Not implemented                         <TD>Implemented                                                   <TD>Future enhancement
<TR><TH bgcolor="eeeeee">SetVideoParameters              <TD>Not implemented                         <TD>Not implemented                                               <TD>Implemented
<TR bgcolor="cccccc"><TH colspan="4">MPEGAudio SWIs
<TR><TH bgcolor="eeeeee">OpenStream                      <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">FullPackets                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">CloseStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">Play                            <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SetSpeed                        <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SkipFrame                       <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">RepeatFrame                     <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">ResetStream                     <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">MuteSound                       <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">SoundVolume                     <TD>Implemented                             <TD>Not implemented                                               <TD>Future enhancement
<TR><TH bgcolor="eeeeee">Stats                           <TD>Stats &amp;2000 - &amp;2011 implemented <TD>Not implemented                                               <TD>Implemented
<TR><TH bgcolor="eeeeee">SetAudioParameters              <TD>Not implemented                         <TD>Implemented                                                   <TD>Implemented
<TR bgcolor="cccccc"><TH colspan="4">* Commands
<TR><TH bgcolor="eeeeee">SyncOffset                      <TD>Implemented                             <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">VideoInfo                       <TD>Implemented                             <TD>Implemented                                                   <TD>Implemented
<TR><TH bgcolor="eeeeee">AudioInfo                       <TD>Implemented                             <TD>Not implemented                                               <TD>Not implemented
<TR><TH bgcolor="eeeeee">ReadL64002                      <TD>Not implemented                         <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">WriteL64002                     <TD>Not implemented                         <TD>Implemented                                                   <TD>Not implemented
<TR><TH bgcolor="eeeeee">PacketInfo                      <TD>Not implemented                         <TD>Implemented                                                   <TD>Absorbed into VideoInfo
<TR bgcolor="cccccc"><TH colspan="4">System Variables
<TR><TH bgcolor="eeeeee">TVOn                            <TD>Used                                    <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG$PoduleNumber               <TD>Used                                    <TD>Ignored                                                       <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$PoduleNumber              <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$VideoOutputMode           <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferPreFill        <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferLowWaterMark   <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$AudioBufferHighWaterMark  <TD>Ignored                                 <TD>Used                                                          <TD>Used
<TR><TH bgcolor="eeeeee">MPEG2$VideoBufferPreFill        <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
<TR><TH bgcolor="eeeeee">MPEG2$HorizontalShift           <TD>Ignored                                 <TD>Used                                                          <TD>Ignored
</TBODY>
</TABLE>

<HR>

<H2><A name="user">4. User interface</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="programmer">5. Programmer interface</A></H2>

<P>Only those parts of the API that are implemented on the STB-400 are fully described.

<H3>5.1. Software Interrupts (SWIs)</H3>

<P>Most SWIs (all except MPEGVideo_CardControl, MPEGVideo_ReadParameters,
MPEGVideo_RegisterHandler and MPEGVideo_DeregisterHandler) are only intended to be called
by the MPEGSystem or MPEGTransport modules. Indeed, it would be difficult for anything
else to do so, since a valid video stream handle or audio stream handle are needed for
most SWIs, and these are only returned by MPEGDriver to MPEGSystem or MPEGTransport when
MPEGVideo_OpenStream or MPEGAudio_OpenStream are called. Since there is a level of trust
between the modules, error checking for these SWIs is minimal.

<P>For historical reasons, the video and audio SWIs are in two separate SWI chunks. The
MPEGVideo SWI chunk is the MPEGDriver module's "official" chunk, and the MPEGAudio SWIs
are serviced by using a second module header embedded within the module, and a minimal
module body that redirects audio SWIs into the main SWI handler entry point; in this way,
the benefits of the kernel's fast SWI dispatch code are not lost (as opposed to the
approach that MPEG2Video used, which was to claim the unknown SWI vector).

<P>Note that some relevant data structures are described in &sect;7.


<H4 align="right">MPEGVideo_OpenStream
<BR>(SWI &amp;49300)</H4>

<P>Open stream to the MPEG video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>control stream flags (as passed to MPEGSystem_OpenStream or
                 MPEGTransport_OpenStream)
<TR><TD>R1 = <TD>control stream handle
<TR><TD>R2 = <TD>pointer to video parameters structure (see &sect;7.1)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = video stream handle

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_OpenStream).

<P>This call performs all the actions necessary to be ready to accept an MPEG video
stream - for example, the screen is blanked (it remains so until shortly after decoding is
initiated with MPEGVideo_Play). If this call is successful it returns a video stream
handle in R0 (otherwise R0 is an error block pointer).


<H4 align="right">MPEGVideo_FullPackets
<BR>(SWI &amp;49301)</H4>

<P>Pass packet(s) of MPEG video data to the video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle
<TR><TD>R2 = <TD>pointer to one or more linked bitstream packet descriptors for packets
                 containing video data (see MPEGSystem/MPEGTransport specs)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_FullBuffers).

<P>This call passes packets of MPEG video data to the video decoder.


<H4 align="right">MPEGVideo_CloseStream
<BR>(SWI &amp;49302)</H4>

<P>Close MPEG video stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_CloseStream).

<P>If in pause mode, this call delinks all queuing bitstream packets from the chain and
frees them. If not in pause mode, it waits for all data to have been sent to the decoders
before returning (it needs to drop into user mode for this to happen, so that callbacks
go off).

<P>It is assumed that no more MPEGVideo_FullPackets calls will be made once this call has
started.


<H4 align="right">MPEGVideo_Play
<BR>(SWI &amp;49303)</H4>

<P>Start video data playback

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules.

<P>It is used to initiate video decoding. When both video and audio are present in the
MPEG stream, this call is not issued until both video and audio have reached their
prefilling completion conditions.


<H4 align="right">MPEGVideo_SetSpeed
<BR>(SWI &amp;49304)</H4>

<P>Set speed of playback of video data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle
<TR><TD>R2 = <TD>speed indicator
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>Value  <TH>Effect
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0      <TD>pause
                 <TR><TD>1      <TD>normal speed
                 <TR><TD>2 - 16 <TD>slow motion, speed 1/R2
                 </TBODY>
                 </TABLE>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetSpeed).

<P>This call sets the playback speed of the video decoder.


<H4 align="right">MPEGVideo_CardControl
<BR>(SWI &amp;49305)</H4>

<P>Perform miscellaneous operations related to the MPEG hardware

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Claim MPEG-1 audio IRQ <I>(not implemented)</I>
<TR><TD>1 <TD>Release MPEG-1 audio IRQ <I>(not implemented)</I>
<TR><TD>2 <TD>Update MPEG-1 style control register
<TR><TD>3 <TD>Control power-down state <I>(not implemented)</I>
<TR><TD>4 <TD>Send MPEG-1 macro command <I>(not implemented)</I>
<TR><TD>5 <TD>Set output colour space <I>(not implemented)</I>
<TR><TD>6 <TD>Read STB22/3 status register <I>(not implemented)</I>
<TR><TD>7 <TD>Read STi3520 revision
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_CardControl 2
<BR>(SWI &amp;49305)</H4>

<P>Update state bits corresponding to those in the MPEG-1 hardware control register

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (2)
<TR><TD>R1 = <TD>EOR mask
<TR><TD>R2 = <TD>AND mask
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>old value
<TR><TD>R2 = <TD>new value
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is provided for backwards compatibility, to allow the SCART switching lines
to be controlled. The (virtual) control register is set to (old value AND R2) EOR R1.

<P>This call is the lowest level API for controlling the SCART switching lines that is
common to all STB versions.

<P>On STB-400 hardware, the SCART switching lines are controlled using an ARM7500FE
general-purpose I/O line (addressed using the PortMan module<SUP>[10]</SUP>) and outputs
from the TDA8540 video switch (addressed using the DENCDriver module<SUP>[9]</SUP>).
Different hardware is used to achieve the same effect on earlier STBs.

<P>When bit 5 of the control register is set, SCART pin 8 is driven high, which switches
the TV into its AV input mode (this is the CTRL0 signal). When bit 6 of the control
register is set, SCART pin 16 is driven high, which switches the TV to use the RGB input
lines on the SCART in preference to the CVBS line (this is the CTRL1 signal).

<P>Note that not all SCART-equipped TVs respond to one or both of these signals, and that
commonly only one SCART of multiple-socketed TVs is able to accept RGB input.

<P>Bits other than 5 or 6 are reserved and should not be altered (ie they should be set
in R2 and clear in R1).


<H4 align="right">MPEGVideo_CardControl 7
<BR>(SWI &amp;49305)</H4>

<P>Read STi3520 revision

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (7)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD colspan="2">R0 preserved
<TR><TD>R1 = <TD>flags:
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>bit <TH>meaning when set
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0   <TD>chip is STi3520L (rather than STi3520A)
                 <TR><TD colspan="2">other bits are reserved
                 </TBODY>
                 </TABLE>
<TR><TD>R2 = <TD>STi3520 chip revision number (eg 0xBA =&gt; revision "BA")
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is provided so that unit test software can verify that the correct revision
of the Sti3520 has been fitted.


<H4 align="right">MPEGVideo_SetSCR
<BR>(SWI &amp;49306)</H4>

<P>Set the system clock in the video decoder

<P>This SWI is not implemented.


<H4 align="right">MPEGVideo_ReadParameters
<BR>(SWI &amp;49307)</H4>

<P>Read miscellaneous video stream parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read timecode and temporal reference <I>(not implemented)</I>
<TR><TD>1 <TD>Read direct access parameters for SetSCR <I>(not implemented)</I>
<TR><TD>2 <TD>Read various locations <I>(not implemented)</I>
<TR><TD>3 <TD>Read current SCR value <I>(not implemented)</I>
<TR><TD>4 <TD>Read internal buffer fullness
<TR><TD>5 <TD>Check if display is ready
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_ReadParameters 4
<BR>(SWI &amp;49307)</H4>

<P>Read internal buffer fullness

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (4)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R1&nbsp;= <TD>number of byes in internal video bit buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call reads the amount of data which is currently stored in the MPEG decoding
hardware's internal video bit buffer (ie excluding the amount queuing in the ARM's RAM,
waiting to be delivered). If no stream is open, a value of zero is returned.


<H4 align="right">MPEGVideo_ReadParameters 5
<BR>(SWI &amp;49307)</H4>

<P>Check if display is ready

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code (5)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R1&nbsp;= <TD>1 if first picture has been displayed, else 0
</TBODY>
</TABLE>

<H5>Use</H5>

<P>When a stream is opened or reset, the screen is blanked until a certain number of video
sequence headers have been decoded, followed by a number of field times, as determined by
the BlankedSequences and BlankedFields values in the video parameters structure. The
screen is then unblanked. This call allows an application to determine if this has
happened yet.


<H4 align="right">MPEGVideo_ResetStream
<BR>(SWI &amp;49308)</H4>

<P>Discard pre-buffered data and prepare to accept new stream data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reset stream flags (as passed to MPEGSystem_ResetStream or
                      MPEGTransport_ResetStream)
<TR><TD>R1 = <TD>video stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>estimate of the amount of discarded video data in bytes
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_ResetStream).

<P>This call causes the video unit to discard all data not yet sent to the video decoding
hardware, and to instruct the hardware to discard any MPEG data stored in its internal
video bit buffer which has not yet been decoded.

<P>After discarding the data, the video unit enters the same state as after an OpenStream
call, ie in pause mode, waiting for sufficient data to issue a MPEGControl_Play SWI.


<H4 align="right">MPEGVideo_DisplayStill
<BR>(SWI &amp;49309)</H4>

<P>Display still MPEG picture

<P>This SWI is not implemented.


<H4 align="right">MPEGVideo_Stats
<BR>(SWI &amp;4930A)</H4>

<P>Return values relating to the operation of the video decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>video stream handle, or zero to read stream-independent values
<TR><TD>R2 = <TD>pointer to list of statistic tags, terminated by -1
<TR><TD>R3 = <TD>pointer to word-aligned buffer to store results to
<TR><TD>R4 = <TD>size of buffer (in bytes)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R3&nbsp;= <TD>pointer to byte after last byte put into buffer
<TR><TD>R4 = <TD>value of R4 on entry minus the total size of the requested entries,
                 whether or not they were put into the buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_Stats).

<P>It has the equivalent functionality to MPEGSystem_Stats and MPEGTransport_Stats, but
just for the video unit stats.


<H4 align="right">MPEGVideo_RegisterHandler
<BR>(SWI &amp;4930B)</H4>

<P>Register a handler with the video unit

<P>This SWI is a future enhancement. It would be implemented to match the API described in
the advanced NTSC video features functional specification<SUP>[11]</SUP>.


<H4 align="right">MPEGVideo_DeregisterHandler
<BR>(SWI &amp;4930C)</H4>

<P>Deregister a handler previously registered with MPEGVideo_RegisterHandler

<P>This SWI is a future enhancement. It would be implemented to match the API described in
the advanced NTSC video features functional specification<SUP>[11]</SUP>.


<H4 align="right">MPEGVideo_SetVideoParameters
<BR>(SWI &amp;4930D)</H4>

<P>Reads and writes various video parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD>R1 = <TD>video stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write video scaling type
<TR><TD>1 <TD>Read/write line 23 widescreen signalling state
<TR><TD>2 <TD>Read/write SCART pin 8 widescreen signalling state
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGVideo_SetVideoParameters 0
<BR>(SWI &amp;4930D)</H4>

<P>Read/write video scaling type

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">video stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 3 <TD>=&gt; set video scaling type
<TR>                     <TD>-1     <TD>=&gt; read video scaling type
<TR><TD>R3-R6&nbsp;=     <TD colspan="2">video scaling type parameters
                         <BR>(undefined if R2 = -1)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old video scaling type
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         <!-- weird Fresco formatting bug requires the above -->
<TR><TD>R3-R6&nbsp;= <TD colspan="2">old video scaling type parameters
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters, which has the same form but with
the control stream handle passed in R1).

<P>The video scaling type parameters are identical to offsets +40 - +52 of the video
parameters structure; they are described in more detail in &sect;7.1.


<H4 align="right">MPEGVideo_SetVideoParameters 1
<BR>(SWI &amp;4930D)</H4>

<P>Read/write line 23 widescreen signalling state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (1)
<TR><TD>R1 =             <TD colspan="2">video stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 15 <TD>=&gt; set WSS state
<TR>                     <TD>-1      <TD>=&gt; read WSS state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old WSS state
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters, which has the same form but with
the control stream handle passed in R1).

<P>Line 23 widescreen signalling is applicable to PAL (and SECAM) TV signals, and is most
commonly used to switch 16:9 (widescreen) TVs between the various picture scaling modes
that are available. The signal is generated using the STi3520L's on-screen display, so
the relevant part of the graphics plane must be transparent for it to function.

<P>The WSS states passed in R2 have the following meanings:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>State <TH>Line 23 signal present? <TH>Protected area (used as aspect ratio label) <TH>Format      <TH>Position <TH>Active lines <TH>Notes
</THEAD>
<TBODY align="left" valign="top">
<TR>                 <TD>0     <TD>no                      <TD>-                                           <TD>-           <TD>-        <TD>-            <TD>control of widescreen state is not asserted
<TR>                 <TD>1     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>centre   <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>2     <TD>yes                     <TD>14:9                                        <TD>letterbox   <TD>top      <TD>504          <TD>the 14:9 picture is centred and pillarboxed, and uses the full height of the TV screen
<TR>                 <TD>3     <TD colspan="6">undefined - do not use
<TR>                 <TD>4     <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>top      <TD>430          <TD>the 16:9 picture is displayed using the whole TV screen
<TR>                 <TD>5     <TD colspan="6">undefined - do not use
<TR>                 <TD>6     <TD colspan="6">undefined - do not use
<TR>                 <TD>7     <TD>yes                     <TD>16:9                                        <TD>full-format <TD>-        <TD>576          <TD>this is 16:9 anamorphic mode, and is stretched horizontally to fill the TV screen
<TR>                 <TD>8     <TD>yes                     <TD>4:3                                         <TD>full format <TD>-        <TD>576          <TD>the 4:3 picture is centred and pillarboxed
<TR>                 <TD>9     <TD colspan="6">undefined - do not use
<TR>                 <TD>10    <TD colspan="6">undefined - do not use
<TR>                 <TD>11    <TD>yes                     <TD>16:9                                        <TD>letterbox   <TD>centre   <TD>430          <TD>the 16:9 picture is displayed using the whole TV screen
<TR>                 <TD>12    <TD colspan="6">undefined - do not use
<TR>                 <TD>13    <TD>yes                     <TD>&gt; 16:9                                   <TD>letterbox   <TD>centre   <TD>&lt; 430     <TD>the picture is centred and letterboxed, and uses the full width of the TV screen
<TR>                 <TD>14    <TD>yes                     <TD>14:9                                        <TD>full format <TD>centre   <TD>576          <TD>this is 4:3 with 14:9 shoot-and-protect, and is treated the same as other 14:9 formats by a 16:9 TV
<TR>                 <TD>15    <TD colspan="6">undefined - do not use
</TBODY>
</TABLE>

<P>Note that when using ScalingType 0, the WSS state is set automatically.


<H4 align="right">MPEGVideo_SetVideoParameters 2
<BR>(SWI &amp;4930D)</H4>

<P>Read/write SCART pin 8 widescreen signalling state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0 =             <TD colspan="2">reason code (2)
<TR><TD>R1 =             <TD colspan="2">video stream handle
<TR><TD rowspan="3">R2 = <TD>0  <TD>=&gt; set non-anamorphic mode (ie use high voltage
                                    on SCART pin 8 when TV AV input is asserted)
<TR>                     <TD>1  <TD>=&gt; set anamorphic mode (ie use intermediate voltage
                                    on SCART pin 8 when TV AV input is asserted)
<TR>                     <TD>-1 <TD>=&gt; read mode
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 =         <TD>old mode
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetVideoParameters, which has the same form but with
the control stream handle passed in R1).

<P>The intermediate voltage on SCART pin 8 is used to signal to 16:9 TVs (and some 4:3
TVs) that the images it is receiving have been anamorphically squeezed, and that the TV
should re-size the image in order to display them at the correct aspect ratio. For 16:9
sets, this means stretching the image to fill the whole width of the screen; for 4:3 sets,
it means collapsing the image vertically, and adding black bars top and bottom.


<H4 align="right">MPEGAudio_OpenStream
<BR>(SWI &amp;49340)</H4>

<P>Open stream to the MPEG audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>control stream flags (as passed to MPEGSystem_OpenStream or
                 MPEGTransport_OpenStream)
<TR><TD>R1 = <TD>control stream handle
<TR><TD>R2 = <TD>pointer to audio parameters structure (see &sect;7.2)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>R0 = audio stream handle

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_OpenStream).

<P>This call performs all the actions necessary to be ready to accept an MPEG audio
stream. If successful it returns an audio stream handle in R0 (otherwise R0 is an error
block pointer).


<H4 align="right">MPEGAudio_FullPackets
<BR>(SWI &amp;49341)</H4>

<P>Pass packet(s) of MPEG audio data to the audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
<TR><TD>R2 = <TD>pointer to one or more linked bitstream packet descriptors for packets
                 containing audio data (see MPEGSystem/MPEGTransport specs)
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_FullBuffers).

<P>This call passes packets of MPEG audio data to the audio decoder.


<H4 align="right">MPEGAudio_CloseStream
<BR>(SWI &amp;49342)</H4>

<P>Close MPEG audio stream

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_CloseStream).

<P>If in pause mode, this call delinks all queuing bitstream packets from the chain and
frees them. If not in pause mode, it waits for all data to have been sent to the decoders
before returning (it needs to drop into user mode for this to happen, so that callbacks
go off).

<P>It is assumed that no more MPEGAudio_FullPackets calls will be made once this call has
started.


<H4 align="right">MPEGAudio_Play
<BR>(SWI &amp;49343)</H4>

<P>Start audio data playback

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules.

<P>It is used to initiate audio decoding. When both video and audio are present in the
MPEG stream, this call is not issued until both video and audio have reached their
prefilling completion conditions.


<H4 align="right">MPEGAudio_SetSpeed
<BR>(SWI &amp;49344)</H4>

<P>Set speed of playback of audio data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle
<TR><TD>R2 = <TD>speed indicator
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>Value  <TH>Effect
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0      <TD>pause
                 <TR><TD>1      <TD>normal speed
                 <TR><TD>2 - 16 <TD>slow motion, speed 1/R2
                 </TBODY>
                 </TABLE>
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetSpeed).

<P>This call sets the playback speed of the audio decoder. If slow motion is selected,
the audio is muted, but decoding continues at a fractional speed so that synchronisation
is correct when returning to normal speed.


<H4 align="right">MPEGAudio_SkipFrame
<BR>(SWI &amp;49345)</H4>

<P>Skip an audio frame

<P>This SWI is not implemented.


<H4 align="right">MPEGAudio_RepeatFrame
<BR>(SWI &amp;49346)</H4>

<P>Repeat an audio frame

<P>This SWI is not implemented.


<H4 align="right">MPEGAudio_ResetStream
<BR>(SWI &amp;49347)</H4>

<P>Discard pre-buffered data and prepare to accept new stream data

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reset stream flags (as passed to MPEGSystem_ResetStream or
                      MPEGTransport_ResetStream)
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>estimate of the amount of discarded audio data in bytes
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_ResetStream).

<P>This call causes the audio unit to discard all data not yet sent to the audio decoding
hardware, and to instruct the hardware to discard any MPEG data stored in its internal
audio bit buffer which has not yet been decoded.

<P>After discarding the data, the audio unit enters the same state as after an OpenStream
call, ie in pause mode, waiting for sufficient data to issue a MPEGControl_Play SWI.


<H4 align="right">MPEGAudio_MuteSound
<BR>(SWI &amp;49348)</H4>

<P>Mute/unmute sound

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags:
                 <TABLE cellspacing="2">
                 <THEAD align="left" valign="top">
                 <TR><TH>bit <TH>effect when set
                 </THEAD>
                 <TBODY align="left" valign="top">
                 <TR><TD>0   <TD>sound is muted
                 <TR><TD>other bits <TD>reserved, must be zero
                 </TBODY>
                 </TABLE>
<TR><TD>R1 = <TD>audio stream handle
</TBODY>
</TABLE>

<H5>On exit</H5>

<P>All registers preserved

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_MuteSound).

<P>This call mutes or unmutes the sound. Note that sound may still be off after an unmute
call due to other reasons, eg playing in fast-forward.


<H4 align="right">MPEGAudio_SoundVolume
<BR>(SWI &amp;49349)</H4>

<P>Adjust audio attenuation

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">flags (must be zero)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 256 <TD>=&gt; set volume (logarithmic scale)
<TR>                     <TD>-1       <TD>=&gt; read volume
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2&nbsp;= <TD>old setting of sound volume
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This SWI is a future enhancement, and is intended solely for the use of the MPEGSystem
and MPEGTransport modules (applications should use MPEGControl_SoundVolume).

<P>The volume control interface is logarithmic in its basis. The volume is specified in
units of 0.5 dB; a value of 256 corresponds to a nominal 0 dB volume setting ("normal
full volume"), so a value of 254 corresponds to 1 dB softer than full volume and so on.
In practice, hardware gain is only adjustable in steps of 2 dB, so the software maps the
requested volume setting onto the nearest available hardware setting.

<P>The volume setting 0 is special, in that it means not -128 dB but "off" or "muted".


<H4 align="right">MPEGAudio_Stats
<BR>(SWI &amp;4934A)</H4>

<P>Return values relating to the operation of the audio decoder

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>flags (must be zero)
<TR><TD>R1 = <TD>audio stream handle, or zero to read stream-independent values
<TR><TD>R2 = <TD>pointer to list of statistic tags, terminated by -1
<TR><TD>R3 = <TD>pointer to word-aligned buffer to store results to
<TR><TD>R4 = <TD>size of buffer (in bytes)
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R3&nbsp;= <TD>pointer to byte after last byte put into buffer
<TR><TD>R4 = <TD>value of R4 on entry minus the total size of the requested entries,
                 whether or not they were put into the buffer
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_Stats).

<P>It has the equivalent functionality to MPEGSystem_Stats and MPEGTransport_Stats, but
just for the audio unit stats.


<H4 align="right">MPEGAudio_SetAudioParameters
<BR>(SWI &amp;4934B)</H4>

<P>Reads and writes various audio parameters

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;= <TD>reason code
<TR><TD>R1 = <TD>audio stream handle
<TR><TD colspan="2">other registers depend upon reason code
</TBODY>
</TABLE>

<P>The following reason codes are defined:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>Read/write mute-on-bit-error state
<TR><TD>1 <TD>Read/write dual channel mode specifier
<TR><TD colspan="2">other reason codes are reserved
</TBODY>
</TABLE>


<H4 align="right">MPEGAudio_SetAudioParameters 0
<BR>(SWI &amp;4934B)</H4>

<P>Read/write mute-on-bit-error state

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (0)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 or 1 <TD>=&gt; set mute-on-bit-error state
<TR>                     <TD>-1     <TD>=&gt; read mute-on-bit-error state
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = old mute-on-bit-error state
<TR><TD>other registers preserved
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetAudioParameters).

<P>The mute-on-bit-errors state can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>=&gt; don't mute audio on bit errors
<TR><TD>1 <TD>=&gt; mute audio on bit errors (CRC failure)
</TBODY>
</TABLE>


<H4 align="right">MPEGAudio_SetAudioParameters 1
<BR>(SWI &amp;4934B)</H4>

<P>Read/write dual channel mode specifier

<H5>On entry</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R0&nbsp;=        <TD colspan="2">reason code (1)
<TR><TD>R1 =             <TD colspan="2">audio stream handle
<TR><TD rowspan="2">R2 = <TD>0 to 2 <TD>=&gt; set dual channel mode specifier
<TR>                     <TD>-1     <TD>=&gt; read dual channel mode specifier
</TBODY>
</TABLE>

<H5>On exit</H5>

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>R2 = old dual channel mode specifier
<TR><TD>R3 = current channel type
<TR><TD>other registers preserved
</TBODY>
</TABLE>

<H5>Use</H5>

<P>This call is intended solely for the use of the MPEGSystem and MPEGTransport modules
(applications should use MPEGControl_SetAudioParameters).

<P>The dual channel mode specifier can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0 <TD>=&gt; output both channels normally
<TR><TD>1 <TD>=&gt; output left channel on both channels
<TR><TD>2 <TD>=&gt; output right channel on both channels
</TBODY>
</TABLE>

<P>The current channel type can take these values:

<TABLE cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD>0  <TD>=&gt; stereo
<TR><TD>1  <TD>=&gt; joint stereo
<TR><TD>2  <TD>=&gt; dual mono
<TR><TD>3  <TD>=&gt; mono
<TR><TD>-1 <TD>=&gt; unknown
</TBODY>
</TABLE>


<H3>5.2. * Commands</H3>

<H4 align="right">*VideoInfo</H4>

<P>List information about the current state of video and audio decoding, and counts of
events since the last ResetStream or OpenStream.

<P>While effort will be made to include similar information to previous modules, the exact
details of what can and cannot be listed depend upon the hardware and the way in which the
driver is implemented. Further, it is anticipated that some items will be added as needed
during debugging.


<H3>5.3. System Variables</H3>

<H4 align="right">TVOn</H4>

<P>This is used during module initialisation to determine how the SCART CTRL lines (see
MPEGVideo_CardControl 2) should be initialised.

<TABLE border="1">
<THEAD align="left">
<TR bgcolor="eeeeee"><TH>TVOn variable setting <TH>SCART CTRL0 (pin 8)                         <TH>SCART CTRL1 (pin 16)
</THEAD>
<TBODY align="left">
<TR>                 <TD>Unset                 <TD>Low (TV tuner selected)                     <TD>Low (pin is ignored by TV)
<TR>                 <TD><CODE>RGB</CODE>      <TD>High or intermediate (TV AV input selected) <TD>High (TV uses R/G/B pins for signal and CVBS pin for sync)
<TR>                 <TD><CODE>CVBS</CODE>     <TD>High or intermediate (TV AV input selected) <TD>Low (TV uses CVBS pin for signal and sync)
</TBODY>
</TABLE>


<H4 align="right">MPEG2$AudioBufferPreFill</H4>

<P>This is the buffer fullness (in bytes) that the audio buffer must reach before the
MPEGDriver module calls SWI MPEGControl_Play to signal that the audio unit has reached the
end-of-prefill condition. Note that more data may still be delivered to the buffer before
decoding is started if the video unit has not reached its own prefill-complete condition
(which is determined from vbv_delay in the picture header, combined with bit_rate from
the sequence header, and capped by vbv_buffer_size from the sequence header).


<H4 align="right">MPEG2$AudioBufferLowWaterMark</H4>

<P>This is the buffer fullness (in bytes) below which the MPEGDriver module will play an
audio frame slow, in the hopes of allowing the audio buffer to fill slightly. This
behaviour can be overridden by clearing bit 2 in the flags passed to
MPEGControl_OpenStream.


<H4 align="right">MPEG2$AudioBufferHighWaterMark</H4>

<P>This is the buffer fullness (in bytes) above which the MPEGDriver module will play an
audio frame fast, in the hopes of allowing the audio buffer to empty slightly. This
behaviour can be overridden by clearing bit 2 in the flags passed to
MPEGControl_OpenStream.


<HR>

<H2><A name="interchange">6. Data interchange</A></H2>

<P>This section is not applicable.

<HR>

<H2><A name="formats">7. Data formats</A></H2>

<H3>7.1 Video parameters structure</H3>

<P>A video parameters structure is a structure passed to MPEGControl_OpenStream, and
subsequently to MPEGVideo_OpenStream. It identifies parameters associated with the video
element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>FormatType: video parameters structure format type (0 at present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>don't clear screen contents before display (if this bit is
                           clear, the module assumes we're in a 16-bpp mode)
                   <TR><TD>Bit 1&nbsp;ignored
                       <TD>(palette now always initialised suitably by kernel in
                           16-bpp and 32-bpp modes)
                   <TR><TD>Bit 2&nbsp;ignored
                       <TD>(determination of 525/625-lines done by monitoring mode changes)
                   <TR><TD colspan="2">Bits 3 to 15 reserved - set to zero
                   <TR><TD>Bit 16 set =&gt;
                       <TD>BlankedSequences and BlankedFields entries are present
                   <TR><TD>Bit 17 set =&gt;
                       <TD>apply underrun fix when in trick play mode
                   <TR><TD>Bit 18 set =&gt;
                       <TD>fix up PES packet lengths when in trick play mode
                   <TR><TD>Bit&nbsp;19&nbsp;set&nbsp;=&gt;
                       <TD>ScalingType and the four subsequent entries are present
                           (if this is clear, default to Free scaling type, 4:3 TV,
                           Auto viewing mode)
                   <TR><TD colspan="2">Other bits are reserved and must be set to zero
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>ScreenMode: mode specifier (ie number or pointer to mode selector
                   block) for screen mode to select (or -1 to indicate no screen mode
                   change)
<TR><TD>12     <TD>Reserved: must be zero
<TR><TD>16     <TD>Reserved: must be zero
<TR><TD>20     <TD>Reserved: must be zero
<TR><TD>24     <TD>Reserved: must be zero
<TR><TD>28     <TD>BlankedSequences: see below
<TR><TD>32     <TD>BlankedFields: when a stream is played, initially the screen is
                   blanked; it is only unblanked after 'BlankedSequences' number of video
                   sequence headers have been decoded, followed by 'BlankedFields' video
                   field times. These values are only present if bit 16 of the Flags word
                   is set, otherwise BlankedSequences defaults to 1, and BlankedFields
                   defaults to 16.
<TR><TD>36     <TD>ScalingType: determines how horizontal and vertical video scaling
                   should be performed:
                   <TABLE cellspacing="2">
                   <THEAD align="left" valign="top">
                   <TR><TH>Value <TH>Scaling type
                   </THEAD>
                   <TBODY align="left" valign="top">
                   <TR><TD>0     <TD>Free (width and height calculated from video headers,
                                     TV aspect and viewing mode)
                   <TR><TD>1     <TD>Fixed width
                   <TR><TD>2     <TD>Fixed height
                   <TR><TD>3     <TD>Fixed width and height
                   </TBODY>
                   </TABLE>
                   The interpretation of offsets 40-52 also depend upon this value.
<TR><TD>40-52  <TD>ScalingType parameters:
                   <TABLE cellspacing="2">
                   <TBODY align="left" valign="top">
                   <TR><TH colspan="2">ScalingType 0:
                   <TR><TD>40 <TD>TV aspect ratio: 0 =&gt; 4:3, 1 =&gt; 16:9
                   <TR><TD>44 <TD>Flags:
                              <BR>bit 0 set =&gt; use line 23 widescreen signalling
                              <BR>bit 1 set =&gt; use SCART pin 8 widescreen signalling
                              <BR>other bits are reserved
                   <TR><TD>48 <TD>Viewing mode (see below): 0 =&gt; Box, 1 =&gt; Auto,
                                  2 =&gt; Zoom, 3 =&gt; Stretch
                   <TR><TD>52 <TD>Reserved: must be zero
                   <TR><TH colspan="2">ScalingType 1:
                   <TR><TD>40 <TD>0 =&gt; normal pixel aspect ratio,
                                  1 =&gt; anamorphically squeezed image (wide pixels)
                   <TR><TD>44 <TD>Width (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 2:
                   <TR><TD>40 <TD>0 =&gt; normal pixel aspect ratio,
                                  1 =&gt; anamorphically squeezed image (wide pixels)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   <TR><TH colspan="2">ScalingType 3:
                   <TR><TD>40 <TD>Width (OS units)
                   <TR><TD>44 <TD>Height (OS units)
                   <TR><TD>48 <TD>Centre X coordinate (OS units)
                   <TR><TD>52 <TD>Centre Y coordinate (OS units)
                   </TBODY>
                   </TABLE>
</TBODY>
</TABLE>

<P>The process of interpreting a ScalingType begins by calculating the coded frame aspect
ratio (using the aspect_ratio_information, horizontal_size, vertical_size,
display_horizontal_size and display_vertical_size fields from the video sequence header
and, if present, the sequence display extension). If an Active Format Descriptor is
present, then an active area aspect ratio and optionally a protected area aspect ratio
within the coded frame can be distinguished; otherwise both default to the same as the
coded frame. See the glossary for a greater discussion of these terms.

<P>ScalingType 0, viewing mode Box: in this case, X and Y scaling are applied equally so
that the active area fits wholly within the TV displayable area.

<P>ScalingType 0, viewing mode Auto: in this case, X and Y scaling are applied equally so
that the <I>protected area</I> fits wholly within the TV displayable area.

<P>ScalingType 0, viewing mode Zoom: in this case, X and Y scaling are applied equally so
that the active area fills the TV displayable area, with minimal overscan.

<P>ScalingType 0, viewing mode Stretch: in this case, X and Y scaling are independently
applied so that the active area exactly fits the TV displayable area.

<P>ScalingType 1: in this case, X and Y scaling factors are applied equally so that the
active area is the specified width.

<P>ScalingType 2: in this case, X and Y scaling factors are applied equally so that the
active area is the specified height.

<P>ScalingType 3: in this case, X and Y scaling are independently applied so that the
active area is the specified width and height.

<P>In practice, the STi3520L can only scale vertically by a strictly limited set of
factors, so the vertical scale will be calculated first. Where an exact match is not
possible, the module will select a scaling factor with excessive downsampling (unless the
ideal scaling factor is smaller than the minimum, in which case the smallest factor will
be selected). In the case of Box, Auto and Zoom viewing modes, and in ScalingTypes 1 and
2, the horizontal scale factor will then be matched to the vertical scaling factor, even
if it differs from the ideal.

<P>When ScalingType 0 is selected, MPEGDriver can be instructed to automatically use
line 23 widescreen signalling (WSS) and/or SCART pin 8 widescreen signalling, to achieve
the best possible picture resolution on the selected TV. Note that line 23 WSS can
effectively increase the range of vertical scale factors available on a 16:9 TV, in
addition to its role in signalling when the video is anamorphically squeezed.

<P>When ScalingTypes 1 or 2 are used, the word at +40 should only be set to 1 if
either MPEGVideo_SetVideoParameters 1 or 2 have been (or are about to be) used to signal
to the TV that the picture is anamorphically squeezed. This is not done automatically in
this case.

<P>Note that OS coordinates outside the normal screen range can be used, for example to
support 2x upscaling.

<H4>Viewing mode examples</H4>

This is how a selection of picture types would be represented on a 4:3 TV set using each
of the viewing modes:

<TABLE border="1" cellpadding="6">
<TBODY align="center">
<TR bgcolor="eeeeee"><TH rowspan="3" bgcolor="ffffff">&nbsp; <TH>Active area    <TH>4:3                                              <TH>16:9                                                     <TH>16:9
<TR bgcolor="eeeeee">                                        <TH>Protected area <TH>4:3                                              <TH>4:3                                                      <TH>16:9
<TR bgcolor="eeeeee">                                        <TH>Coded frame    <TH>4:3                                              <TH>16:9                                                     <TH>16:9

<TR><TH bgcolor="eeeeee">Viewing mode                        <TH>&nbsp;         <TH>&nbsp;                                           <TH>&nbsp;                                                   <TH>&nbsp;
<TR><TH bgcolor="eeeeee">Box                                 <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="bars/169p43.jpg" width="192" height="144">     <TD><IMG src="bars/169.jpg" width="192" height="144">
<TR><TH bgcolor="eeeeee">Auto                                <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="crop/169p43.jpg" width="192" height="144">     <TD><IMG src="bars/169.jpg" width="192" height="144">
<TR><TH bgcolor="eeeeee">Zoom                                <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="crop/169p43.jpg" width="192" height="144">     <TD><IMG src="crop/169.jpg" width="192" height="144">
<TR><TH bgcolor="eeeeee">Stretch                             <TH>&nbsp;         <TD><IMG src="full/43.jpg" width="192" height="144"> <TD><IMG src="stretch/169p43.jpg" width="192" height="144">  <TD><IMG src="stretch/169.jpg" width="192" height="144">
</TBODY>
</TABLE>

This is how a selection of picture types would be represented on a 16:9 TV set using each
of the viewing modes:

<TABLE border="1" cellpadding="6">
<TBODY align="center">
<TR bgcolor="eeeeee"><TH rowspan="3" bgcolor="ffffff">&nbsp; <TH bgcolor="eeeeee">Active area    <TH>4:3                                                 <TH>4:3                                                      <TH>16:9
<TR bgcolor="eeeeee">                                        <TH bgcolor="eeeeee">Protected area <TH>4:3                                                 <TH>14:9                                                     <TH>16:9
<TR bgcolor="eeeeee">                                        <TH bgcolor="eeeeee">Coded frame    <TH>4:3                                                 <TH>4:3                                                      <TH>16:9

<TR><TH bgcolor="eeeeee">Viewing mode                        <TH>&nbsp;                          <TH>&nbsp;                                              <TH>&nbsp;                                                   <TH>&nbsp;
<TR><TH bgcolor="eeeeee">Box                                 <TH>&nbsp;                          <TD><IMG src="bars/43.jpg" width="256" height="144">    <TD><IMG src="bars/43p149.jpg" width="256" height="144">     <TD><IMG src="full/169.jpg" width="256" height="144">
<TR><TH bgcolor="eeeeee">Auto                                <TH>&nbsp;                          <TD><IMG src="bars/43.jpg" width="256" height="144">    <TD><IMG src="halfcrop/43p149.jpg" width="256" height="144"> <TD><IMG src="full/169.jpg" width="256" height="144">
<TR><TH bgcolor="eeeeee">Zoom                                <TH>&nbsp;                          <TD><IMG src="crop/43.jpg" width="256" height="144">    <TD><IMG src="crop/43p149.jpg" width="256" height="144">     <TD><IMG src="full/169.jpg" width="256" height="144">
<TR><TH bgcolor="eeeeee">Stretch                             <TH>&nbsp;                          <TD><IMG src="stretch/43.jpg" width="256" height="144"> <TD><IMG src="stretch/43p149.jpg" width="256" height="144">  <TD><IMG src="full/169.jpg" width="256" height="144">
</TBODY>
</TABLE>


<H3>7.2 Audio parameters structure</H3>

<P>An audio parameters structure is a structure passed to MPEGControl_OpenStream, and
subsequently to MPEGAudio_OpenStream. It identifies parameters associated with the audio
element in the MPEG stream:

<TABLE border="1">
<THEAD align="left" valign="top">
<TR bgcolor="eeeeee"><TH>Offset <TH>Contents
</THEAD>
<TBODY align="left" valign="top">
<TR><TD>0      <TD>Audio structure format type (0 at present)
<TR><TD>4      <TD>Flags:
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>Bit 0 set =&gt;
                       <TD>mute audio on bit errors
                   <TR><TD>Bit&nbsp;1&nbsp;set =&gt;
                       <TD>dual channel mode specifier field is valid
                   <TR><TD colspan="2">Other bits are reserved and must be set to zero
                   </TBODY>
                   </TABLE>
<TR><TD>8      <TD>Dual channel mode specifier (only valid if bit 1 of Flags
                   is set)
                   <TABLE border="0">
                   <TBODY align="left" valign="top">
                   <TR><TD>0 =&gt; <TD>play both channels
                   <TR><TD>1 =&gt; <TD>play left channel only
                   <TR><TD>2 =&gt; <TD>play right channel only
                   </TBODY>
                   </TABLE>
<TR><TD>12...  <TD>Reserved for future expansion
</TBODY>
</TABLE>

<HR>

<H2><A name="internal">8. Internal dependencies</A></H2>

<UL>
<LI>Target hardware must be available for testing.
<LI>A variety of MPEG clips (eg some coded as 16:9, some with Active Format Descriptors,
some with field-pictures, some with dual-mono audio) must be obtained.
</UL>

<HR>

<H2><A name="acceptance">9. Acceptance test</A></H2>

<UL>
<LI>The module must function on target hardware as specified.
<LI>The executable code of the module must be less than 128K long.
<LI>The workspace used by the module must not exceed 8K plus 8K per open stream (excluding
queuing bitstream packets).
</UL>

<HR>

<H2><A name="noncompliances">10. Noncompliances</A></H2>

<P>There are no noncompliances.

<HR>

<H2><A name="test">11. Development test strategy</A></H2>

<UL>
<LI>All SWIs must function as specified
<LI>All * commands must function as specified
<LI>Program element handler entry points must function correctly (see MPEGTransport spec
    <SUP>[8]</SUP>)
</UL>

<P>These criteria will primarily be tested by using the BASIC player, with extensions
added as necessary. In most cases, the BASIC player will call either MPEGSystem or
MPEGTransport (both will be used in testing), which will then call MPEGDriver. The C code
parts of MPEGDriver will be examined using the McCabe analysis software, subject to
availability.

<HR>

<H2><A name="organisation">12. Product organisation</A></H2>

<P>The MPEGDriver module is written in a mixture of C and assembler. It will be built into
the STB-400 ROM, but can also be softloaded in order to deliver patches.

<HR>

<H2><A name="enhancements">13. Future enhancements</A></H2>

<P>Future enhancements are indicated in the table in &sect;3, and in more detail in
&sect;5.

<HR>

<H2><A name="glossary">14. Glossary</A></H2>

<DL>
<DT>active area (aspect ratio)
    <DD>the shape of the part of a coded frame excluding any black bars (top and bottom
    or left and right) that are transmitted as part of the picture.
<DT>anamorphic
    <DD>typically used to describe the use of all luminance and chrominance samples and
    all scan lines to fully describe a 16:9 image, rather than a 4:3 image. Each pixel
    is therefore describing a region that is notably wider than it is tall, as opposed
    to the traditional arrangement where a pixel was approximately the same width as
    height. Thus, when an anamorphic signal is displayed unaltered on a 4:3 TV, it appears
    to have been squashed horizontally, producing a characteristic "tall, thin people"
    effect.
<DT>AV
    <DD>Audio/Video - often used to refer to the unmodulated video and audio inputs of a
    TV (for example, the SCART socket).
<DT>bpp
    <DD>bits per pixel.
<DT>coded frame (aspect ratio)
    <DD>the shape of the rectangle enclosing every coded pixel in an image. This is
    commonly determined by the image aspect ratio, but sometimes has to be calculated
    from the pixel aspect ratio in combination with the number of pixel rows and columns.
<DT>CRC
    <DD>Cyclic Redundancy Check - a common checksum algorithm that is used to detect
    errors in data. The MPEG audio specification allows CRCs to be embedded into audio
    streams.
<DT>CVBS
    <DD>Composite Video Baseband Video - a signal combining luminance and chrominance
    samples, but which has not been modulated to RF.
<DT>IEC
    <DD>International Engineering Consortium.
<DT>ISO
    <DD>International Standards Organisation.
<DT>letterbox
    <DD>the technique for displaying a picture entirely within a display of lesser ratio,
    by adding black bars top and bottom.
<DT>MPEG
    <DD>Moving Picture (Motion Pictures) Experts Group - the nickname of SubCommittee 29
    of Working Group 11 of ISO/IEC Joint Technical Committee 1.
<DT>MPEG-1
    <DD>the nickname of ISO/IEC 11172 (see References).
<DT>MPEG-2
    <DD>the nickname of ISO/IEC 13818 (see References).
<DT>NTSC
    <DD>National Television System Committee (of the Electronics Industries Association,
    the organisation which defined the standard format adopted by the FCC for broadcast
    television in the USA). Commonly used to refer to the standard-resolution, composite,
    colour video standard in use in the USA, Japan, Canada and Mexico.
<DT>PAL
    <DD>Phase Alternation by Line - the standard-resolution, composite, colour video
    standard in use in the UK and most of western Europe (with the notable exception of
    France).
<DT>PES
    <DD>Packetized Elementary Stream - a stream of variable-length packets from only one
    elementary stream (normally either video or audio). It requires transmission or
    storage in relatively error-free media.
<DT>pillarbox
    <DD>the technique for displaying a picture entirely within a display of greater ratio,
    by adding black bars left and right.
<DT>protected area (aspect ratio)
    <DD>the shape of the part of the active area that has been protected by
    shoot-and-protect filming. This typically allows a display which is closer in shape to
    the protected area than the active area to discard unnecessary parts of the picture.
<DT>RGB
    <DD>Red/Green/Blue - a method of storing or transmitting colour information (eg using
    pins 15, 11 and 7 of a SCART lead).
<DT>SCART
    <DD>also known as peritel or euroconnector, this is a 21-pin connector which can
    (in its two main configurations) carry two-way mono or stereo audio and composite
    video and one-way S-video (luminance/chrominance) or RGB, as well as a couple of
    switching signals.
<DT>SECAM
    <DD>SEquentiel Coleur Avec M&eacute;moire - the standard-resolution, composite, colour
    video standard used in France, Eastern Europe, the Middle East, the former Soviet
    Union and many former French colonies. STB-400 cannot support SECAM.
<DT>shoot-and-protect
    <DD>the filming technique whereby, although a certain area is recorded to film or
    video, all the important action and detail is kept within a smaller region (an "area
    of interest", or as we are calling it here, the "protected area"). This allows
    displays that match the shape of the smaller region to discard the unnecessary
    material, but at the same time, does not require displays that match the shape of the
    original area to display black bars top and bottom or left and right.
<DT>STB
    <DD>Set Top Box.
<DT>SWI
    <DD>SoftWare Interrupt - basic OS function call.
<DT>VBV
    <DD>Video Buffer Verifier - the conceptual stage in MPEG video decoding that smooths
    out the substantial differences in delivery rates of I, P and B frames (due to their
    substantially different compressed sizes) to the constant rate of display of frames
    of whichever type. The vbv_delay of a particular picture is the time for which its
    picture header should remain in the VBV buffer; this serves as a useful minimum
    time-lag between a frame entering and leaving the video bit buffer, so in combination
    with the bit_rate from the sequence header, it can be used to calculate the video
    prefilling condition.
<DT>WSS
    <DD>WideScreen Signalling - a waveform which can be present on scan line 23 of B, D,
    G, H and I variant PAL (and SECAM) video formats, and indicates a number of features
    of the video signal (most notably the aspect ratio).
</DL>

<HR>

<H2><A name="references">15. References</A></H2>

<OL>
  <LI>SGS-Thomson STi3520L data sheet.
  <LI>ISO/IEC 11172: Information technology &mdash; Coding of moving pictures
      and associated audio for digital storage media at up to about 1,5 Mbit/s.
      Published in these parts:
      <UL>
        <LI>Part 1: Systems (1993)
        <LI>Part 2: Video (1993)
        <LI>Part 3: Audio (1993)
        <LI>Part 4: Conformance testing (1995)
        <LI>Part 5 (Technical Report): Software simulation (1998)
      </UL>
  <LI>ISO/IEC 13818: Information technology &mdash; Generic coding of moving
      pictures and associated audio information. Published in these parts:
      <UL>
        <LI>Part 1: Systems (1996)
        <LI>Part 2: Video (1996)
        <LI>Part 3: Audio (1998)
        <LI>Part 4: Conformance testing (1998)
        <LI>Part 5 (Technical Report): Software simulation (1997)
        <LI>Part 6: Extensions for DSM-CC (1998)
        <LI>Part 7: Advanced Audio Coding (1997)
        <LI>Part 9: Extension for real time interface for systems decoders (1996)
        <LI>Part 10: Conformance extensions for DSM-CC (1999)
      </UL>
  <LI>2501,812/FS: STB-400 Functional Specification.
  <LI>2501,828/FS: STB-400 OS ROM Functional Specification.
  <LI>2309,306/FS: MPEGControl 2.xx Module Software Functional Specification.
  <LI>2309,309/FS: MPEGSystem Module Functional Specification.
  <LI>2309,330/FS: MPEGTransport Module Functional Specification.
  <LI>2501,824/FS: DENCDriver Module Functional Specification.
  <LI>2309,331/FS: Port Manager Module Functional Specification.
  <LI>2202,793/FS: Advanced NTSC Video Features Functional Specification.
</OL>

<HR>

<H2><A name="history">16. History</A></H2>

<TABLE width="100%" border="0" cellspacing="2">
<TBODY align="left" valign="top">
<TR><TD><STRONG>Issue</STRONG>  <TD><STRONG>Date</STRONG>  <TD><STRONG>Author</STRONG>  <TD><STRONG>Description of change</STRONG>
<TR><TD>A                       <TD>09&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Initial version.
<TR><TD>B                       <TD>23&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Updated after review.
<TR><TD>1                       <TD>23&nbsp;Sep&nbsp;1999  <TD>BAvison                  <TD>Added AMR number.
<TR><TD>2                       <TD>22&nbsp;Oct&nbsp;1999  <TD>BAvison                  <TD>Resolved S-Video through SCART outstanding issue (we're not implementing it). Changed references to which hardware controls SCART switching lines, and added support for SCART pin 8 widescreen signalling. Added API for extracting STi3520 revision number.

</TBODY>
</TABLE>


</BODY>
</HTML>
