/******	Stuffing.c *********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Compressed data stuffing
		PES header reconstitution
		Sync-to-stream management

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
06/10/1999	BJGA	Created
22/10/1999	BJGA	Changed in line with Hdr:MPEG2cCard
05/11/1999	BJGA	Implemented freeing of packets after they're sent to the 3520
24/11/1999	BJGA	Bugfix to allow video play-out to function
13/12/1999	BJGA	Added support for MiscAsm_Stuff (ie 16- and 32-bit writes);
			initial attempt at audio stuffing
25/01/2000	BJGA	Calls SWI MPEGControl_Play when audio buffer reaches prefill threshold

***************************************************************************/

/************/
/* Includes */
/************/

#include "swis.h"

#include "Global/SWIs.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEG2cCard.h"

#include "Defs.h"
#include "MiscAsm.h"
#include "ModHdr.h"
#include "Module.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Registers.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

static bool video_callback_requested = false;
static bool audio_callback_requested = false;

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Stuffing_StuffVideo() **********************************************

Purpose:	TickerV entry for video stuffing

***************************************************************************/

void Stuffing_StuffVideo (void)
{
  if (!video_callback_requested)
  {
    if (Stream.s_flags.use_callbacks)
    {
      if (NULL == _swix (OS_AddCallBack, _INR(0,1), video_stuffing_callback, Module_PrivateWord))
      {
        video_callback_requested = true;
      }
    }
    else
    {
      video_callback_requested = true;
      Stuffing_VideoCallback ();
    }
  }
}

/******	Stuffing_VideoCallback() *******************************************

Purpose:	Callback entry for video stuffing

***************************************************************************/

void Stuffing_VideoCallback (void)
{
  bool irqs_were_disabled = _kernel_irqs_disabled ();
  int space_in_bit_buffer;
  unsigned int bytes_to_send_this_time;
#if MPEG_Base_Address == 0x88000000
  unsigned char *byte_pointer;
#endif
  
  /* Enable interrupts for the duration */
  if (irqs_were_disabled) _kernel_irqs_on ();
  
  if (Stream.video.state == stream_prefilling || Stream.video.state == stream_open || Stream.video.state == stream_closing)
  {
    /* Calculate the minimum possible space available in the video bit buffer */
    /* bearing in mind that VID_VBL is rounded down to the nearest 2 kilobit boundary */
    space_in_bit_buffer = (SDRAM_VIDEO_BIT_BUFFER_END - SDRAM_VIDEO_BIT_BUFFER_START) - ((VID_VBL & 0x3FFF) * 256 + 256);
    
    while (Stream.video.packet_list_head != NULL && space_in_bit_buffer > 0)
    {
      bytes_to_send_this_time = MIN(space_in_bit_buffer, Stream.video.packet_list_head->length);
      
#if MPEG_Base_Address == 0x88000000
      for (byte_pointer = Stream.video.packet_list_head->start; byte_pointer < Stream.video.packet_list_head->start + bytes_to_send_this_time; byte_pointer++)
      {
        * (unsigned char *) (MPEG_Base_Address + Offset_MPEG_Video_Data_Write_8) = *byte_pointer;
      }
#else
      MiscAsm_Stuff ((void *) (MPEG_Base_Address + Offset_MPEG_Video_Data_Write_32), Stream.video.packet_list_head->start, bytes_to_send_this_time);
#endif
      
      Stream.video.packet_list_head->start += bytes_to_send_this_time;
      Stream.video.packet_list_head->length -= bytes_to_send_this_time;
      Stream.video.since_open.amount_sent += bytes_to_send_this_time;
      Stream.video.since_reset.amount_sent += bytes_to_send_this_time;
      space_in_bit_buffer -= bytes_to_send_this_time;
      
      if (Stream.video.packet_list_head->length == 0) Stuffing_FreePacket (&Stream.video);
      
    }
  }
  
  /* Clear up and exit */
  video_callback_requested = false;
  if (irqs_were_disabled) _kernel_irqs_off ();
}

/******	Stuffing_StuffAudio() **********************************************

Purpose:	TickerV entry for audio stuffing

***************************************************************************/

void Stuffing_StuffAudio (void)
{
  if (!audio_callback_requested)
  {
    if (Stream.s_flags.use_callbacks)
    {
      if (NULL == _swix (OS_AddCallBack, _INR(0,1), audio_stuffing_callback, Module_PrivateWord))
      {
        audio_callback_requested = true;
      }
    }
    else
    {
      audio_callback_requested = true;
      Stuffing_AudioCallback ();
    }
  }
}

/******	Stuffing_AudioCallback() *******************************************

Purpose:	Callback entry for audio stuffing

***************************************************************************/

void Stuffing_AudioCallback (void)
{
  bool irqs_were_disabled = _kernel_irqs_disabled ();
  int total_audio_queueing;
  bitstream_packet_t *packet_pointer;
  int space_in_bit_buffer;
  unsigned int bytes_to_send_this_time;
#if MPEG_Base_Address == 0x88000000
  unsigned char *byte_pointer;
#endif
  
  /* Enable interrupts for the duration */
  if (irqs_were_disabled) _kernel_irqs_on ();
  
  if (Stream.audio.state == stream_prefilling || Stream.audio.state == stream_open || Stream.audio.state == stream_closing)
  {
    /* Calculate the minimum possible space available in the audio bit buffer */
    /* bearing in mind that VID_ABL is rounded down to the nearest 2 kilobit boundary */
    space_in_bit_buffer = (SDRAM_AUDIO_BIT_BUFFER_END - SDRAM_AUDIO_BIT_BUFFER_START) - ((VID_ABL & 0x3FFF) * 256 + 256);
    
    while (Stream.audio.packet_list_head != NULL && space_in_bit_buffer > 0)
    {
      bytes_to_send_this_time = MIN(space_in_bit_buffer, Stream.audio.packet_list_head->length);
      
#if MPEG_Base_Address == 0x88000000
      for (byte_pointer = Stream.audio.packet_list_head->start; byte_pointer < Stream.audio.packet_list_head->start + bytes_to_send_this_time; byte_pointer++)
      {
        * (unsigned char *) (MPEG_Base_Address + Offset_MPEG_Audio_Data_Write_8) = *byte_pointer;
      }
#else
      MiscAsm_Stuff ((void *) (MPEG_Base_Address + Offset_MPEG_Audio_Data_Write_32), Stream.audio.packet_list_head->start, bytes_to_send_this_time);
#endif
      
      Stream.audio.packet_list_head->start += bytes_to_send_this_time;
      Stream.audio.packet_list_head->length -= bytes_to_send_this_time;
      Stream.audio.since_open.amount_sent += bytes_to_send_this_time;
      Stream.audio.since_reset.amount_sent += bytes_to_send_this_time;
      space_in_bit_buffer -= bytes_to_send_this_time;
      
      if (Stream.audio.packet_list_head->length == 0) Stuffing_FreePacket (&Stream.audio);
      
    }
    
    /* Now test for the various audio buffer thresholds */
    total_audio_queueing = (VID_ABL & 0x3FFF) * 256;
    for (packet_pointer = Stream.audio.packet_list_head; packet_pointer != NULL; packet_pointer = packet_pointer->link)
    {
      total_audio_queueing += packet_pointer->length;
    }
//    dprintf (("Stuffing", "AudioCallback: total_audio_queueing = %d bytes\n", total_audio_queueing));
    
    /* If we've reached prefill buffer-fullness, tell control unit so */
    if (Stream.audio.state == stream_prefilling && Stream.audio.prefill_state == ps_initialising && total_audio_queueing > Stream.audio_buffer_prefill)
    {
      /* Update state machine */
      Stream.audio.prefill_state = ps_waiting_for_play_command;
      dprintf (("Stuffing", "AudioCallback: audio.prefill_state = waiting_for_play_command\n"));
      /* Note, we may be re-entered via SWI MPEGAudio_Play at this point */
      _swix (MPEGControl_Play, _INR(0,1), StreamFlags_AudioPresent, Stream.csh);
    }
    
    /* Do strsync here */
  }
  
  /* Clear up and exit */
  audio_callback_requested = false;
  if (irqs_were_disabled) _kernel_irqs_off ();
}

/******	Stuffing_FreePacket() **********************************************

Purpose:	Removes the first bistream packet from a packet list, and frees it
In:		Pointer to either Stream.video or Stream.audio
Notes:		Assumes the packet list is not empty

***************************************************************************/

void Stuffing_FreePacket (a_v_state_t *av)
{
  bitstream_packet_t *packet;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  
  /* Disable IRQs while we mess with the packet list */
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  packet = av->packet_list_head;
  /* Point list head at next packet along */
  av->packet_list_head = packet->link;
  /* If |packet| was the only one in the list, zero the list tail too */
  if (packet->link == NULL)
  {
    av->packet_list_tail = NULL;
  }
  
  /* Restore interrupts */
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  /* Free the packet */
  MiscAsm_FreePacket (packet);
}
