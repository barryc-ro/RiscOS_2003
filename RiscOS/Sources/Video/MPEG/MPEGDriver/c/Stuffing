/******	Stuffing.c *********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Compressed data stuffing
		PES header reconstitution
		Sync-to-stream management

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
06/10/1999	BJGA	Created
22/10/1999	BJGA	Changed in line with Hdr:MPEG2cCard
05/11/1999	BJGA	Implemented freeing of packets after they're sent to the 3520
24/11/1999	BJGA	Bugfix to allow video play-out to function

***************************************************************************/

/************/
/* Includes */
/************/

#include "swis.h"

#include "DebugLib/DebugLib.h"
#include "MPEG/MPEG2cCard.h"

#include "Defs.h"
#include "MiscAsm.h"
#include "ModHdr.h"
#include "Module.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Registers.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

static bool video_callback_requested = false;

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Stuffing_StuffVideo() **********************************************

Purpose:	TickerV entry for video stuffing

***************************************************************************/

void Stuffing_StuffVideo (void)
{
  if (!video_callback_requested)
  {
    if (Stream.s_flags.use_callbacks)
    {
      if (NULL == _swix (OS_AddCallBack, _INR(0,1), video_stuffing_callback, Module_PrivateWord))
      {
        video_callback_requested = true;
      }
    }
    else
    {
      video_callback_requested = true;
      Stuffing_VideoCallback ();
    }
  }
}

/******	Stuffing_VideoCallback() *******************************************

Purpose:	Callback entry for video stuffing

***************************************************************************/

void Stuffing_VideoCallback (void)
{
  bool irqs_were_disabled = _kernel_irqs_disabled ();
  int space_in_bit_buffer;
  unsigned int bytes_to_send_this_time;
  unsigned char *byte_pointer;
  
  /* Enable interrupts for the duration */
  if (irqs_were_disabled) _kernel_irqs_on ();
  
  if (Stream.video.state == stream_prefilling || Stream.video.state == stream_open || Stream.video.state == stream_closing)
  {
    /* Calculate the minimum possible space available in the video bit buffer */
    /* bearing in mind that VID_VBL is rounded down to the nearest 2 kilobit boundary */
    space_in_bit_buffer = (SDRAM_VIDEO_BIT_BUFFER_END - SDRAM_VIDEO_BIT_BUFFER_START) - ((VID_VBL & 0x3FFF) * 256 + 256);
    
    while (Stream.video.packet_list_head != NULL && space_in_bit_buffer > 0)
    {
      bytes_to_send_this_time = MIN(space_in_bit_buffer, Stream.video.packet_list_head->length);
      
      for (byte_pointer = Stream.video.packet_list_head->start; byte_pointer < Stream.video.packet_list_head->start + bytes_to_send_this_time; byte_pointer++)
      {
        * (unsigned char *) (MPEG_Base_Address + Offset_MPEG_Video_Data_Write_8) = *byte_pointer;
      }
      
      Stream.video.packet_list_head->start += bytes_to_send_this_time;
      Stream.video.packet_list_head->length -= bytes_to_send_this_time;
      Stream.video.since_open.amount_sent += bytes_to_send_this_time;
      Stream.video.since_reset.amount_sent += bytes_to_send_this_time;
      space_in_bit_buffer -= bytes_to_send_this_time;
      
      if (Stream.video.packet_list_head->length == 0) Stuffing_FreePacket (&Stream.video);
      
    }
    /* Would do strsync here if audio */
  }
  
  /* Clear up and exit */
  video_callback_requested = false;
  if (irqs_were_disabled) _kernel_irqs_off ();
}

/******	Stuffing_StuffAudio() **********************************************

Purpose:	TickerV entry for audio stuffing

***************************************************************************/

void Stuffing_StuffAudio (void)
{
}

/******	Stuffing_AudioCallback() *******************************************

Purpose:	Callback entry for audio stuffing

***************************************************************************/

void Stuffing_AudioCallback (void)
{
}

/******	Stuffing_FreePacket() **********************************************

Purpose:	Removes the first bistream packet from a packet list, and frees it
In:		Pointer to either Stream.video or Stream.audio
Notes:		Assumes the packet list is not empty

***************************************************************************/

void Stuffing_FreePacket (a_v_state_t *av)
{
  bitstream_packet_t *packet;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  
  /* Disable IRQs while we mess with the packet list */
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  packet = av->packet_list_head;
  /* Point list head at next packet along */
  av->packet_list_head = packet->link;
  /* If |packet| was the only one in the list, zero the list tail too */
  if (packet->link == NULL)
  {
    av->packet_list_tail = NULL;
  }
  
  /* Restore interrupts */
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  /* Free the packet */
  MiscAsm_FreePacket (packet);
}
