/******	Video.c ************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Video SWI handling

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
01/10/1999	BJGA	Created
20/10/1999	BJGA	Tweaks to enable playing the first picture
22/10/1999	BJGA	API updated in line with issue 2 specification
26/10/1999	BJGA	Now initialises picture lists on open and reset stream
05/11/1999	BJGA	Discards partial PES packets at start of stream;
			returns discarded data count from static_VideoStop()
12/11/1999	BJGA	Variable name changes in line with Types.h
17/11/1999	BJGA	Implemented SWI MPEGVideo_SetSpeed; initialises
			display list, fifth frame struct and first-anchor/B-
			frame buffer pointers
23/11/1999	BJGA	Initialises the new data counts and state flags; comes
			out of pause more slowly, so the user has a chance to
			request a single-step operation; return values from
			SWIStats() initialised, so VSP modules no longer crash;
			play-out on stream close implemented
25/11/1999	BJGA	Initialises frame buffer list (for new buffer allocation scheme)
30/11/1999	BJGA	Play-out no longer applies when slow-motion is selected
01/12/1999	BJGA	picture_structure initialisations changed to support new
			field/frame picture switching code
13/12/1999	BJGA	Added mode change and screen clearing in OpenStream;
			implemented SWI MPEGVideo_SetVideoParameters 1
28/01/2000	BJGA	Implemented ReadParameters 4 and 5 - allows OVS to work!

***************************************************************************/

/************/
/* Includes */
/************/

#include "kernel.h"
#include "swis.h"

#include "Global/SWIs.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGCtrl.h"

#include "Defs.h"
#include "IRQ.h"
#include "MiscAsm.h"
#include "Module.h"
#include "Registers.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"
#include "WSS.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static _kernel_oserror *static_VideoStart (void);
static unsigned int static_VideoStop (bool play_out);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Video_SWIOpenStream() **********************************************

Purpose:	Handles MPEGVideo_OpenStream
In:		Control stream flags; control stream handle; video parameters
		structure; address to write video stream handle into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIOpenStream (stream_flags_t *flags, control_stream_handle_t csh, video_parameters_structure_t *vps, stream_handle_t *return_vsh)
{
  _kernel_oserror *e = NULL;
  bool old_audio_present_flag;
  dprintf (("Video", "SWIOpenStream\n"));
  
  /* Cache StreamFlags (other than our copies of the video_present and audio_present flags), ControlStreamHandle and VideoParametersStructure */
  /* This way we can cope with the sequence MPEGVideo_OpenStream, MPEGAudio_OpenStream (returning an error), then MPEGVideo_CloseStream */
  old_audio_present_flag = Stream.s_flags.audio_present;
  Stream.s_flags = *flags;
  Stream.s_flags.video_present = true;
  Stream.s_flags.audio_present = old_audio_present_flag;
  Stream.csh = csh;
  Stream.video_parms = *vps;
  
  /* Initialise various variables */
  Stream.rs_flags.video_present = Stream.s_flags.video_present;
  Stream.rs_flags.audio_present = Stream.s_flags.audio_present;
  Stream.rs_flags.trick_play_mode = false;
  Stream.video.since_open.amount_received = 0;
  Stream.video.since_open.amount_sent = 0;
  Stream.video.since_open.slows = 0;
  Stream.video.since_open.fasts = 0;
  Stream.video.since_open.stalls = 0;
  Stream.video.since_open.underruns = 0;
  Stream.video.since_open.picture_decode_errors = 0;
  Stream.video.since_open.severe_errors = 0;
  Stream.video.since_open.pipeline_errors = 0;
  
  /* Initialise the new stream */
  e = static_VideoStart ();
  if (!e)
  {
    
    /* Change screen mode if required */
    if (Stream.video_parms.screen_mode != -1)
    {
      e = _swix (OS_ScreenMode, _INR(0,1), 0, Stream.video_parms.screen_mode);
    }
  }
  if (!e)
  {
    
    /* Clear screen if required */
    _swix (OS_SetColour, _INR(0,1), 16, 0x8000); /* set background graphics colour to transparent black overwrite */
    _swix (OS_WriteI + 16, 0);                   /* CLG */
    
    /* We no longer reprogram the palette */
    
    /* Return a pointer to Stream as the video stream handle */
    *return_vsh = (stream_handle_t) &Stream;
  }
  return e;
}

/******	Video_SWIFullPackets() *********************************************

Purpose:	Handles MPEGVideo_FullPackets
In:		Flags; video stream handle; list of bitstream packets
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIFullPackets (unsigned int flags, stream_handle_t vsh, bitstream_packet_t *packets)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  IGNORE(vsh);
  
  /* If we're just starting, discard bitstream packets until the beginning of the first PES packet */
  while (Stream.video.prefill_state == ps_searching_for_first_PES_header && packets != NULL)
  {
    if (packets->mpeg_start == true)
    {
      Stream.video.prefill_state = ps_initialising;
      dprintf (("Video", "SWIFullPackets: video.prefill_state = initialising\n"));
    }
    else
    {
      dprintf (("Video", "SWIFullPackets: discarding partial packet\n"));
      packets = MiscAsm_FreePacket (packets);
      /* Note that the rest of the function can cope fine if this sets |packets| to NULL */      
    }
  }
  
  /* Disable IRQs for the rest of this SWI */
  if (irqs_were_enabled) _kernel_irqs_off ();

  /* If packet list is empty, point list head at the first new packet, otherwise add it to the end */
  if (Stream.video.packet_list_tail == NULL)
  {
    Stream.video.packet_list_head = packets;
  }
  else
  {
    Stream.video.packet_list_tail->link = packets;
  }
  
  /* Step along the list of new packets */
  while (packets != NULL)
  {
    /* Add the length of each bitstream packet to the amnount we've received */
    Stream.video.since_open.amount_received += packets->length;
    Stream.video.since_reset.amount_received += packets->length;
    
    /* If it's the beginning of a PES packet, fiddle the full_length field (if necessary) */
    if (packets->mpeg_start)
    {
      if (Stream.rs_flags.trick_play_mode && Stream.video_parms.fix_lengths)
      {
        packets->full_length_unknown = true;
      }
      if (packets->full_length_unknown)
      {
        packets->full_length = 0;
      }
    }
    
    /* Update list tail pointer */
    Stream.video.packet_list_tail = packets;
    
    /* Move on to next packet */
    packets = packets->link;
  }
  
  /* Restore IRQ state */
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICloseStream() *********************************************

Purpose:	Handles MPEGVideo_CloseStream
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICloseStream (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWICloseStream\n"));
  
  /* Stop playing the old stream, only playing out the old data if we were playing at normal speed */
  static_VideoStop (Stream.video.speed_indicator == 1 && Stream.video.state == stream_open);
  return e;
}

/******	Video_SWIPlay() ****************************************************

Purpose:	Handles MPEGVideo_Play
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIPlay (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWIPlay\n"));
  
  e = IRQ_EnableVideoIRQs ();
  
  return e;
}

/******	Video_SWISetSpeed() ************************************************

Purpose:	Handles MPEGVideo_SetSpeed
In:		Flags; video stream handle;
		speed (0 => pause, 1 => normal, 2-16 => 1/2 - 1/16th speed)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetSpeed (unsigned int flags, stream_handle_t vsh, unsigned int speed)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWISetSpeed\n"));
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  if (Stream.video.speed_indicator == 0 && speed != 0)
  {
    /* Coming out of pause requires a little trickery */
    Stream.fields_till_next_AU = (Stream.fields_till_next_AU & 1) + (2 * speed); /* maintain odd/evenness */
  }
  Stream.video.speed_indicator = speed;
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICardControl2() ********************************************

Purpose:	Handles MPEGVideo_CardControl 2
In:		EOR and AND masks to apply to virtual MPEG-1 control register;
		addresses to write old and new values of virtual register into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl2 (unsigned int EOR_mask, unsigned int AND_mask, unsigned int *return_old_value, unsigned int *return_new_value)
{
  _kernel_oserror *e = NULL;
  IGNORE(EOR_mask);
  IGNORE(AND_mask);
  IGNORE(return_old_value);
  IGNORE(return_new_value);
  return e;
}

/******	Video_SWICardControl7() ********************************************

Purpose:	Handles MPEGVideo_CardControl 7
In:		Addresses to write flag word and revision number into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl7 (unsigned int *return_flags, unsigned int *return_revision)
{
  _kernel_oserror *e = NULL;
  IGNORE(return_flags);
  IGNORE(return_revision);
  return e;
}

/******	Video_SWIReadParameters4() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 4
In:		Address to write buffer fullness into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters4 (unsigned int *return_buffer_fullness)
{
  _kernel_oserror *e = NULL;
  if (Stream.video.state != stream_closed)
  {
    *return_buffer_fullness = (VID_VBL & 0x3FFF) * 256;
  }
  else
  {
    *return_buffer_fullness = 0;
  }
  return e;
}

/******	Video_SWIReadParameters5() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 5
In:		Address to write unblanked flag into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters5 (unsigned int *return_display_ready)
{
  _kernel_oserror *e = NULL;
  *return_display_ready = Stream.vid_flags.first_frame_displayed;
  return e;
}

/******	Video_SWIResetStream() *********************************************

Purpose:	Handles MPEGVideo_ResetStream
In:		ResetStream flags; video stream handle;
		address to write discarded data count into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIResetStream (reset_stream_flags_t *flags, stream_handle_t vsh, unsigned int *return_discarded_data_size)
{
  _kernel_oserror *e = NULL;
  IGNORE(vsh);
  dprintf (("Video", "SWIResetStream\n"));
  
  /* Cache ResetStreamFlags */
  Stream.rs_flags = *flags;
  
  /* Read audio and video buffer fullnesses */
  *return_discarded_data_size = (VID_VBL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
  /*  We need to read (and cache) the audio buffer fullness too, because
   *  we'll be resetting the 3520 in a while, which destroys the information.
   *  Note that this assumes MPEGVideo_ResetStream is called before
   *  MPEGAudio_ResetStream, which both MPEGSystem and MPEGTransport do.
   */
  Stream.discarded_audio_bit_buffer_data = (VID_ABL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
  
  /* Stop playing the old stream immediately */
  *return_discarded_data_size += static_VideoStop (false);
  
  /* Initialise the new stream */
  e = static_VideoStart ();
  return e;
}

/******	Video_SWIStats() ***************************************************

Purpose:	Handles MPEGVideo_Stats
In:		Flags; video stream handle; pointer to tags list; buffer to
		write ino (pointer/size); address to write updated buffer
		pointer into; address to write space remaining into (may be <0)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIStats (unsigned int flags, stream_handle_t vsh, unsigned int *tags, void *buffer, int buffer_size, void **return_pointer, int *return_buffer_remaining)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(vsh);
  IGNORE(tags);
  *return_pointer = buffer;
  *return_buffer_remaining = buffer_size;
  return e;
}

/******	Video_SWISetVideoParameters0() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 0
In:		Video stream handle; video scaling block to write to and/or read from
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters0 (stream_handle_t vsh, scaling_type_block_t *block_in_out)
{
  _kernel_oserror *e = NULL;
  IGNORE(vsh);
  IGNORE(block_in_out);
  return e;
}

/******	Video_SWISetVideoParameters1() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 1
In:		Video stream handle; new WSS state (or -1 just to read
		old state); address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters1 (stream_handle_t vsh, unsigned int new_state, unsigned int *return_old_state)
{
  _kernel_oserror *e = NULL;
  unsigned char new_group_settings [4] = { 0xFF, 0xFF, 0xFF, 0xFF };
  unsigned char old_state;
  IGNORE(vsh);
  
  new_group_settings [0] = new_state;
  e = WSS_Set (new_group_settings, false, &old_state);
  *return_old_state = old_state;
  return e;
}

/******	Video_SWISetVideoParameters2() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 2
In:		Video stream handle; new SCART pin 8 state (or -1 just to
		read old state); address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters2 (stream_handle_t vsh, unsigned int new_state, unsigned int *return_old_state)
{
  _kernel_oserror *e = NULL;
  IGNORE(vsh);
  IGNORE(new_state);
  IGNORE(return_old_state);
  return e;
}

/*********************/
/* Private functions */
/*********************/

/******	static_VideoStart() ************************************************

Purpose:	Common code between OpenStream and ResetStream
Out:		Pointer to error block

***************************************************************************/

static _kernel_oserror *static_VideoStart (void)
{
  _kernel_oserror *e = NULL;
  
  /* Perform a soft reset on the 3520 */
  STi3520L_SoftReset (true, false);
  
  /* Initialise various variables */
  Stream.video.state = stream_prefilling;
  Stream.video.prefill_state = ps_searching_for_first_PES_header;
  Stream.video.speed_indicator = 1;
  Stream.video.packet_list_head = NULL;
  Stream.video.packet_list_tail = NULL;
  Stream.video.since_reset.amount_received = 0;
  Stream.video.since_reset.amount_sent = 0;
  Stream.video.since_reset.slows = 0;
  Stream.video.since_reset.fasts = 0;
  Stream.video.since_reset.stalls = 0;
  Stream.video.since_reset.underruns = 0;
  Stream.video.since_reset.picture_decode_errors = 0;
  Stream.video.since_reset.severe_errors = 0;
  Stream.video.since_reset.pipeline_errors = 0;
  Stream.prev_picture_structure = ps_frame_picture;
  Stream.current_picture_structure = ps_frame_picture_extension; /* magic value should start off all types of clips correctly */
  Stream.vid_flags.default_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.default_non_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.parsing_headers = false;
  Stream.vid_flags.had_phoney_pipeline_idle_IRQ = false;
  Stream.vid_flags.prefill_anchor_frames_decoded = 0;
  Stream.vid_flags.first_frame_displayed = false;
  Stream.vid_flags.next_frames_headers_have_been_decoded = false;
  Stream.vid_flags.this_frames_data_have_been_decoded = true; /* don't expect PID IRQ before the first picture! */
  Stream.vid_flags.last_instruction_was_a_decode = false;
  Stream.vid_flags.final_instruction_has_been_written_during_this_AU = false;
  Stream.vid_flags.stalled_while_closing = false;
  Stream.fields_till_next_AU = -1; /* can't accidentally take value +1 before display is properly initialised */
  Stream.consecutive_pipeline_stalls = 0;
  Stream.decode_frames = NULL;
  Stream.display_frames = NULL;
  Stream.unused_frames = &(Stream.frame[0]);
  Stream.unused_frames->decode_link = &(Stream.frame[1]);
  Stream.unused_frames->decode_link->decode_link = &(Stream.frame[2]);
  Stream.unused_frames->decode_link->decode_link->decode_link = &(Stream.frame[3]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link = &(Stream.frame[4]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link->decode_link = NULL;
  Stream.unused_frame_buffers = &(Stream.frame_buffer[0]);
  Stream.unused_frame_buffers->unused_link = &(Stream.frame_buffer[1]);
  Stream.unused_frame_buffers->unused_link->unused_link = &(Stream.frame_buffer[2]);
  Stream.unused_frame_buffers->unused_link->unused_link->unused_link = &(Stream.frame_buffer[3]);
  Stream.unused_frame_buffers->unused_link->unused_link->unused_link->unused_link = NULL;
  Stream.frame_buffer[0].usage_count = Stream.frame_buffer[1].usage_count = Stream.frame_buffer[2].usage_count = Stream.frame_buffer[3].usage_count = 0;
  Stream.frame_buffer[0].addr = SDRAM_FRAME_BUFFER_1_START/256;
  Stream.frame_buffer[1].addr = SDRAM_FRAME_BUFFER_2_START/256;
  Stream.frame_buffer[2].addr = SDRAM_FRAME_BUFFER_3_START/256;
  Stream.frame_buffer[3].addr = SDRAM_FRAME_BUFFER_4_START/256;
  
  /* Claim interrupts */
  IRQ_EnableCommonIRQs ();
  IRQ_EnableVideoPrefillIRQs ();
  
  return e;
}

/******	static_VideoStop() *************************************************

Purpose:	Common code between ResetStream and CloseStream
In:		|true| if the currently queueing data should be allowed to play out
Out:		Number of data bytes that were not played

***************************************************************************/

static unsigned int static_VideoStop (bool play_out)
{
  unsigned int discarded_data = 0; /* default if we're playing out, or if there are no queuing packets */
  
  if (play_out)
  {
    /* Play out the old video data, but don't send any more to the 3520 */
    Stream.video.state = stream_closing;
    
    /* During play-out, we don't bother waiting for buffer-full */
    WRITE_VID_VBT(0); /* may trigger an interrupt immediately */
    
    /* Wait until all data is sent to the 3520 */
    MiscAsm_UserModeWait (&Stream.video.packet_list_head);
    
    /* Wait until the 3520 consumes all its data */
    while (((volatile program_element_structure_t *)&Stream)->vid_flags.stalled_while_closing == false);
    
    /* Now we are closed */
    Stream.video.state = stream_closed;
  }
  else
  {
    /* Go directly to closed, do not pass GO, do not collect £200 */
    Stream.video.state = stream_closed;
    while (Stream.video.packet_list_head != NULL)
    {
      discarded_data += Stream.video.packet_list_head->length;
      Stuffing_FreePacket (&Stream.video);
    }
  }
  
  /* Release interrupts */
  IRQ_DisableCommonIRQs ();
  IRQ_DisableVideoIRQs ();
  
  return discarded_data;
}
