/******	Video.c ************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Video SWI handling

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
01/10/1999	BJGA	Created
20/10/1999	BJGA	Tweaks to enable playing the first picture
22/10/1999	BJGA	API updated in line with issue 2 specification
26/10/1999	BJGA	Now initialises picture lists on open and reset stream
05/11/1999	BJGA	Discards partial PES packets at start of stream;
			returns discarded data count from static_VideoStop()
12/11/1999	BJGA	Variable name changes in line with Types.h
17/11/1999	BJGA	Implemented SWI MPEGVideo_SetSpeed; initialises
			display list, fifth frame struct and first-anchor/B-
			frame buffer pointers
23/11/1999	BJGA	Initialises the new data counts and state flags; comes
			out of pause more slowly, so the user has a chance to
			request a single-step operation; return values from
			SWIStats() initialised, so VSP modules no longer crash;
			play-out on stream close implemented
25/11/1999	BJGA	Initialises frame buffer list (for new buffer allocation scheme)
30/11/1999	BJGA	Play-out no longer applies when slow-motion is selected
01/12/1999	BJGA	picture_structure initialisations changed to support new
			field/frame picture switching code
13/12/1999	BJGA	Added mode change and screen clearing in OpenStream;
			implemented SWI MPEGVideo_SetVideoParameters 1
28/01/2000	BJGA	Implemented ReadParameters 4 and 5 - allows OVS to work!
09/02/2000	BJGA	Changed stream initialisation as per new frame buffer
			allocation algorithm
17/02/2000	BJGA	MPEG video is now blanked on CloseStream; first frame is
			decoded into framebuffer 2 if framebuffer 1 is being displayed
			(important now that blanking on ResetStream has been disabled);
			support added for deferred SetSpeed calls
22/02/2000	BJGA	Implemented CardControl 7; various flagging added to ensure that
			*VideoInfo only prints video header info for video-only streams;
			fixed bugs in deferred SetSpeed; fixed case where *second* prefill
			anchor frame could be decoded into the current display framebuffer
02/03/2000	BJGA	Implemented MPEGVideo_CardControl 2 and MPEGVideo_SetVideoParameters 2
10/04/2000	BJGA	Added counts of PES packets sent, PTSs encoded and decoded;
			added support for internally-generated resets;
			trick-play streams are no longer allowed to play out when they are closed;
			deferred set-speed now applied when going faster as well as when going slower;
			implemented MPEGVideo_ReadParameters 3;
			various initialisations for synchronisation added
02/05/2000	BJGA	Changed format of ScalingType 0 parameters (allows partial defaulting to NVRAM settings);
			now returns internal line 23 and SCART WSS states from MPEGVideo_SetVideoParameters 1 and 2;
			enumeration of line 23 WSS states made more sane (ignores parity bit);
			internal WSS states deactivated on CloseStream

***************************************************************************/

/************/
/* Includes */
/************/

#include "kernel.h"
#include "swis.h"

#include "Global/SWIs.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEGVideo.h"
#include "NVRAM.h"

#include "Defs.h"
#include "IRQ.h"
#include "MiscAsm.h"
#include "ModHdr.h"
#include "Module.h"
#include "Registers.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"
#include "WSS.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static _kernel_oserror *static_VideoStart (void);
static unsigned int static_VideoStop (bool play_out);
static void static_CompleteScalingTypeParameters (bool recache);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Video_SWIOpenStream() **********************************************

Purpose:	Handles MPEGVideo_OpenStream
In:		Control stream flags; control stream handle; video parameters
		structure; address to write video stream handle into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIOpenStream (stream_flags_t *flags, control_stream_handle_t csh, video_parameters_structure_t *vps, stream_handle_t *return_vsh)
{
  _kernel_oserror *e = NULL;
  bool old_audio_present_flag;
  dprintf (("Video", "SWIOpenStream\n"));
  
  /* Cache StreamFlags (other than our copies of the video_present and audio_present flags), ControlStreamHandle and VideoParametersStructure */
  /* This way we can cope with the sequence MPEGVideo_OpenStream, MPEGAudio_OpenStream (returning an error), then MPEGVideo_CloseStream */
  old_audio_present_flag = Stream.s_flags.audio_present;
  Stream.s_flags = *flags;
  Stream.s_flags.video_present = true;
  Stream.s_flags.audio_present = old_audio_present_flag;
  Stream.csh = csh;
  Stream.video_parms = *vps;
  if (!Stream.video_parms.scaling_type_present)
  {
    Stream.video_parms.scaling_type.type = st_free;
    Stream.video_parms.scaling_type.param.free.valid_ratio =
      Stream.video_parms.scaling_type.param.free.valid_WSS =
      Stream.video_parms.scaling_type.param.free.valid_preference =
      Stream.video_parms.scaling_type.param.free.reserved1 =
      Stream.video_parms.scaling_type.param.free.reserved2 = 0;
  }
  static_CompleteScalingTypeParameters (true);
  
  /* Initialise various variables */
  Stream.rs_flags.video_present = Stream.s_flags.video_present;
  Stream.rs_flags.audio_present = Stream.s_flags.audio_present;
  Stream.rs_flags.trick_play_mode = false;
  Stream.video.since_open.amount_received = 0;
  Stream.video.since_open.amount_sent = 0;
  Stream.video.since_open.PES_packets_sent = 0;
  Stream.video.since_open.PTSs_in = 0;
  Stream.video.since_open.PTSs_out = 0;
  Stream.video.since_open.slows = 0;
  Stream.video.since_open.fasts = 0;
  Stream.video.since_open.stalls = 0;
  Stream.video.since_open.picture_decode_errors = 0;
  Stream.video.since_open.severe_errors = 0;
  Stream.video.since_open.pipeline_errors = 0;
  Stream.video.since_open.internal_resets = 0;
  Stream.video.since_open.underruns = 0;
  
  /* Initialise the new stream */
  Stream.vid_flags.internal_reset = false;
  e = static_VideoStart ();
  if (!e)
  {
    
    /* Change screen mode if required */
    if (Stream.video_parms.screen_mode != -1)
    {
      e = _swix (OS_ScreenMode, _INR(0,1), 0, Stream.video_parms.screen_mode);
    }
  }
  if (!e)
  {
    
    if (Stream.video_parms.dont_CLS == 0)
    {
      /* Clear screen if required */
      _swix (OS_SetColour, _INR(0,1), 16, 0x8000); /* set background graphics colour to transparent black overwrite */
      _swix (OS_WriteI + 16, 0);                   /* CLG */
    }
    
    /* We no longer reprogram the palette */
    
    /* Return a pointer to Stream as the video stream handle */
    *return_vsh = (stream_handle_t) &Stream;
  }
  return e;
}

/******	Video_SWIFullPackets() *********************************************

Purpose:	Handles MPEGVideo_FullPackets
In:		Flags; video stream handle; list of bitstream packets
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIFullPackets (unsigned int flags, stream_handle_t vsh, bitstream_packet_t *packets)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  IGNORE(vsh);
  
  /* If we're just starting, discard bitstream packets until the beginning of the first PES packet */
  while (Stream.video.prefill_state == ps_searching_for_first_PES_header && packets != NULL)
  {
    if (packets->mpeg_start == true)
    {
      Stream.video.prefill_state = ps_initialising;
      dprintf (("Video", "SWIFullPackets: video.prefill_state = initialising\n"));
    }
    else
    {
      dprintf (("Video", "SWIFullPackets: discarding partial packet\n"));
      packets = MiscAsm_FreePacket (packets);
      /* Note that the rest of the function can cope fine if this sets |packets| to NULL */      
    }
  }
  
  /* Disable IRQs for the rest of this SWI */
  if (irqs_were_enabled) _kernel_irqs_off ();

  /* If packet list is empty, point list head at the first new packet, otherwise add it to the end */
  if (Stream.video.packet_list_tail == NULL)
  {
    Stream.video.packet_list_head = packets;
  }
  else
  {
    Stream.video.packet_list_tail->link = packets;
  }
  
  /* Step along the list of new packets */
  while (packets != NULL)
  {
    /* Add the length of each bitstream packet to the amnount we've received */
    Stream.video.since_open.amount_received += packets->length;
    Stream.video.since_reset.amount_received += packets->length;
    
    /* If it's the beginning of a PES packet, fiddle the full_length field (if necessary) */
    if (packets->mpeg_start)
    {
      if (Stream.rs_flags.trick_play_mode && Stream.video_parms.fix_lengths)
      {
        packets->full_length_unknown = true;
      }
      if (packets->full_length_unknown)
      {
        packets->full_length = 0;
      }
    }
    
    /* Update list tail pointer */
    Stream.video.packet_list_tail = packets;
    
    /* Move on to next packet */
    packets = packets->link;
  }
  
  /* Restore IRQ state */
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICloseStream() *********************************************

Purpose:	Handles MPEGVideo_CloseStream
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICloseStream (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  unsigned char group_settings [4] = { 0, 0xFF, 0xFF, 0xFF };
  scart_feature scart_setting = scart_dontcare;
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWICloseStream\n"));
  
  /* If an internal reset was pending, stop it */
  _swix (OS_RemoveCallBack, _INR(0,1), video_reset_callback, Module_PrivateWord);
  
  /* Stop playing the old stream, only playing out the old data if we were playing at normal speed */
  static_VideoStop (Stream.video.speed_indicator == 1 && Stream.video.state == stream_open && !Stream.rs_flags.trick_play_mode);
  
  /* We now only blank the video output on CloseStream, not on ResetStream */
  VID_DCF_0 &= ~VID_DCF_EVD>>0;
  
  /* Stop overriding the widescreen signalling */
  WSS_SetSCART (NULL, NULL, NULL, &scart_setting);
  WSS_Set (group_settings, true, NULL, NULL);
  
  Stream.s_flags.video_present = false;
  return e;
}

/******	Video_SWIPlay() ****************************************************

Purpose:	Handles MPEGVideo_Play
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIPlay (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWIPlay\n"));
  
  e = IRQ_EnableVideoIRQs ();
  
  return e;
}

/******	Video_SWISetSpeed() ************************************************

Purpose:	Handles MPEGVideo_SetSpeed
In:		Flags; video stream handle;
		speed (0 => pause, 1 => normal, 2-16 => 1/2 - 1/16th speed)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetSpeed (unsigned int flags, stream_handle_t vsh, unsigned int speed)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  IGNORE(vsh);
  dprintf (("Video", "SWISetSpeed\n"));
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  /* Coming out of pause requires a little trickery */
  if (Stream.video.speed_indicator == 0 && speed != 0)
  {
    Stream.fields_till_next_AU = (Stream.fields_till_next_AU & 1) + (2 * speed); /* maintain odd/evenness */
    Stream.reference_STC = Clk_ReadRawSTC (); /* make it as though STC hasn't incremented since we went into pause */
  }
  /* If defer flag is clear, or if we're already at that speed, or if there's no audio, then don't activate deferring mechanism */
  if ((flags & SetSpeedFlags_DeferSetSpeed) == 0 || speed == Stream.video.speed_indicator || !Stream.rs_flags.audio_present)
  {
    Stream.video.speed_indicator = speed;
  }
  else if ((speed < Stream.video.deferred_speed_indicator && speed != 0) || Stream.video.deferred_speed_indicator == 0)
  {
    /* Moving to a faster speed - wait for audio buffer to exceed prefill level */
    Stream.vid_flags.going_faster = true;
    Stream.vid_flags.going_slower = false;
  }
  else
  {
    /* Moving to a slower speed - wait for audio buffer to fall below prefill level */
    Stream.vid_flags.going_slower = true;
    Stream.vid_flags.going_faster = false;
  }
  /* The next time we stall, this is unconditionally the speed that should be asserted */
  Stream.video.deferred_speed_indicator = speed;
  
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICardControl2() ********************************************

Purpose:	Handles MPEGVideo_CardControl 2
In:		EOR and AND masks to apply to virtual MPEG-1 control register;
		addresses to write old and new values of virtual register into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl2 (unsigned int EOR_mask, unsigned int AND_mask, unsigned int *return_old_value, unsigned int *return_new_value)
{
  _kernel_oserror *e = NULL;
  scart_feature rgb = scart_preserve;
  scart_feature tvassert = scart_preserve;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  WSS_SetSCART (&rgb, &tvassert, NULL, NULL);
  *return_old_value = ((rgb == scart_enable) ? UpdateControlRegister_CTRL1 : 0) | ((tvassert == scart_enable) ? UpdateControlRegister_CTRL0 : 0);
  *return_new_value = (*return_old_value & AND_mask) ^ EOR_mask;
  rgb = ((*return_new_value & UpdateControlRegister_CTRL1) != 0) ? scart_enable : scart_disable;
  tvassert = ((*return_new_value & UpdateControlRegister_CTRL0) != 0) ? scart_enable : scart_disable;
  WSS_SetSCART (&rgb, &tvassert, NULL, NULL);
  
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICardControl7() ********************************************

Purpose:	Handles MPEGVideo_CardControl 7
In:		Addresses to write flag word and revision number into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl7 (unsigned int *return_flags, unsigned int *return_revision)
{
  _kernel_oserror *e = NULL;
  unsigned char first_read = VID_REV;
  unsigned char second_read = VID_REV;
  if (first_read == second_read)
  {
    *return_flags = 0;
  }
  else
  {
    *return_flags = 1;
  }
  *return_revision = first_read;
  return e;
}

/******	Video_SWIReadParameters3() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 3
In:		Address to write least significant 32 bits of PCR/SCR into,
		address to write most significant 1 bit of PCR/SCR into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters3 (unsigned int *return_PCR_lo, unsigned int *return_PCR_hi)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  clk my_PCR;
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  my_PCR = Clk_ReadRawSTC ();
  if (irqs_were_enabled) _kernel_irqs_on ();
  my_PCR = Clk_ConvertSTCtoPCR (my_PCR);
  
  if (Stream.audio.state == stream_open || Stream.audio.state == stream_closing)
  {
    *return_PCR_lo = my_PCR.lsw;
    *return_PCR_hi = my_PCR.msb;
  }
  else
  {
    *return_PCR_lo = 0;
    *return_PCR_hi = 0;
  }
  return e;
}

/******	Video_SWIReadParameters4() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 4
In:		Address to write buffer fullness into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters4 (unsigned int *return_buffer_fullness)
{
  _kernel_oserror *e = NULL;
  if (Stream.video.state != stream_closed)
  {
    *return_buffer_fullness = (VID_VBL & 0x3FFF) * 256;
  }
  else
  {
    *return_buffer_fullness = 0;
  }
  return e;
}

/******	Video_SWIReadParameters5() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 5
In:		Address to write unblanked flag into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters5 (unsigned int *return_display_ready)
{
  _kernel_oserror *e = NULL;
  *return_display_ready = Stream.vid_flags.first_frame_displayed;
  return e;
}

/******	Video_SWIResetStream() *********************************************

Purpose:	Handles MPEGVideo_ResetStream
In:		ResetStream flags; video stream handle;
		address to write discarded data count into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIResetStream (reset_stream_flags_t *flags, stream_handle_t vsh, unsigned int *return_discarded_data_size)
{
  _kernel_oserror *e = NULL;
  IGNORE(vsh);
  dprintf (("Video", "SWIResetStream\n"));
  
  /* Cache ResetStreamFlags */
  Stream.rs_flags = *flags;
  
  /* Read audio and video buffer fullnesses */
  *return_discarded_data_size = (VID_VBL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
  /*  We need to read (and cache) the audio buffer fullness too, because
   *  we'll be resetting the 3520 in a while, which destroys the information.
   *  Note that this assumes MPEGVideo_ResetStream is called before
   *  MPEGAudio_ResetStream, which both MPEGSystem and MPEGTransport do.
   */
  Stream.discarded_audio_bit_buffer_data = (VID_ABL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
  
  /* Stop playing the old stream immediately */
  *return_discarded_data_size += static_VideoStop (false);
  
  /* Initialise the new stream */
  Stream.vid_flags.internal_reset = false;
  e = static_VideoStart ();
  return e;
}

/******	Video_SWIStats() ***************************************************

Purpose:	Handles MPEGVideo_Stats
In:		Flags; video stream handle; pointer to tags list; buffer to
		write ino (pointer/size); address to write updated buffer
		pointer into; address to write space remaining into (may be <0)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIStats (unsigned int flags, stream_handle_t vsh, unsigned int *tags, void *buffer, int buffer_size, void **return_pointer, int *return_buffer_remaining)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(vsh);
  IGNORE(tags);
  *return_pointer = buffer;
  *return_buffer_remaining = buffer_size;
  return e;
}

/******	Video_SWISetVideoParameters0() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 0
In:		Video stream handle; video scaling block to write to and/or read from
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters0 (stream_handle_t vsh, scaling_type_block_t *block_in_out)
{
  _kernel_oserror *e = NULL;
  scaling_type_block_t temp_scaling_type_block;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(vsh);
  
  temp_scaling_type_block = *block_in_out;
  if (irqs_were_enabled) _kernel_irqs_off ();
  *block_in_out = Stream.video_parms.scaling_type;
  if (temp_scaling_type_block.type != (scaling_type) -1)
  {
    Stream.video_parms.scaling_type = temp_scaling_type_block;
    Stream.vid_flags.display_needs_setting_up = true;
    static_CompleteScalingTypeParameters (false);
  }
  if (irqs_were_enabled) _kernel_irqs_on ();
  return e;
}

/******	Video_SWISetVideoParameters1() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 1
In:		New WSS state (or -1 just to read old state);
		address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters1 (unsigned int new_state, unsigned int *return_old_ext_state, unsigned int *return_old_int_state)
{
  _kernel_oserror *e = NULL;
  unsigned char new_group_settings [4] = { 0xFF, 0xFF, 0xFF, 0xFF };
  unsigned char old_state_ext;
  unsigned char old_state_int;
  
  if (new_state == 0 || new_state == -1)
  {
    new_group_settings [0] = new_state;
  }
  else
  {
    unsigned int temp;
    new_state -= 1;
    temp = new_state ^ (new_state >> 1);
    temp = temp ^ (temp >> 2);
    if ((temp & 1) == 0) new_state ^= 8; /* set odd parity */
    new_group_settings [0] = new_state;
  }
  e = WSS_Set (new_group_settings, false, &old_state_ext, &old_state_int);
  if (old_state_ext == 0)
  {
    *return_old_ext_state = 0;
  }
  else
  {
    *return_old_ext_state = (old_state_ext & 7) + 1;
  }
  if (old_state_int == 0)
  {
    *return_old_int_state = 0;
  }
  else
  {
    *return_old_int_state = (old_state_int & 7) + 1;
  }
  return e;
}

/******	Video_SWISetVideoParameters2() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 2
In:		New SCART pin 8 state (or -1 just to read old state);
		address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters2 (unsigned int new_state, unsigned int *return_old_ext_state, unsigned int *return_old_int_state)
{
  _kernel_oserror *e = NULL;
  
  if (new_state == -1)
  {
    *return_old_ext_state = scart_preserve;
  }
  else
  {
    *return_old_ext_state = new_state;
  }
  *return_old_int_state = scart_preserve;
  WSS_SetSCART (NULL, NULL, (scart_feature *) return_old_ext_state, (scart_feature *) return_old_int_state);
  return e;
}

/******	Video_InternalReset() **********************************************

Purpose:	Performs a video reset in order to effect error recovery

***************************************************************************/

void Video_InternalReset (void)
{
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  dprintf (("Video", "Internal reset\n"));
  if (irqs_were_enabled) _kernel_irqs_off ();
  static_VideoStop (false);
  Stream.vid_flags.internal_reset = true;
  static_VideoStart ();
  if (irqs_were_enabled) _kernel_irqs_on ();
}

/*********************/
/* Private functions */
/*********************/

/******	static_VideoStart() ************************************************

Purpose:	Common code between OpenStream and ResetStream
Out:		Pointer to error block

***************************************************************************/

static _kernel_oserror *static_VideoStart (void)
{
  _kernel_oserror *e = NULL;
  
  /* Perform a soft reset on the 3520 */
  STi3520L_SoftReset (true, false);
  
  /* Initialise various variables */
  Stream.video.state = stream_prefilling;
  Stream.video.prefill_state = ps_searching_for_first_PES_header;
  if (!Stream.vid_flags.internal_reset)
  {
    Stream.video.speed_indicator = 1;
    Stream.video.deferred_speed_indicator = 1;
  }
  Stream.video.fast_slow_state = fss_normal_speed;
  Stream.video.packet_list_head = NULL;
  Stream.video.packet_list_tail = NULL;
  if (!Stream.vid_flags.internal_reset)
  {
    Stream.video.since_reset.amount_received = 0;
    Stream.video.since_reset.amount_sent = 0;
    Stream.video.since_reset.PES_packets_sent = 0;
    Stream.video.since_reset.PTSs_in = 0;
    Stream.video.since_reset.PTSs_out = 0;
    Stream.video.since_reset.slows = 0;
    Stream.video.since_reset.fasts = 0;
    Stream.video.since_reset.stalls = 0;
    Stream.video.since_reset.picture_decode_errors = 0;
    Stream.video.since_reset.severe_errors = 0;
    Stream.video.since_reset.pipeline_errors = 0;
    Stream.video.since_reset.internal_resets = 0;
    Stream.video.since_reset.underruns = 0;
  }
  Stream.video.first_PTS.msb = 0x80; /* flag that no PTS has been found yet */
  Stream.video.first_PTS.lsw = 0;
  Stream.prev_picture_structure = ps_frame_picture;
  Stream.current_picture_structure = ps_frame_picture_extension; /* magic value should start off all types of clips correctly */
  Stream.vid_flags.default_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.default_non_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.started_parsing_headers = false;
  Stream.vid_flags.had_phoney_pipeline_idle_IRQ = false;
  Stream.vid_flags.prefill_anchor_frames_decoded = 0;
  Stream.vid_flags.first_frame_displayed = false;
  Stream.vid_flags.next_frames_headers_have_been_decoded = false;
  Stream.vid_flags.this_frames_data_have_been_decoded = true; /* don't expect PID IRQ before the first picture! */
  Stream.vid_flags.last_instruction_was_a_decode = false;
  Stream.vid_flags.final_instruction_has_been_written_during_this_AU = false;
  Stream.vid_flags.stalled_while_closing = false;
  Stream.vid_flags.going_faster = false;
  Stream.vid_flags.going_slower = false;
  Stream.vid_flags.display_needs_setting_up = true;
  Stream.fields_till_next_AU = -1; /* can't accidentally take value +1 before display is properly initialised */
  Stream.consecutive_pipeline_stalls = 0;
  Stream.decode_frames = NULL;
  Stream.display_frames = NULL;
  Stream.unused_frames = &(Stream.frame[0]);
  Stream.unused_frames->decode_link = &(Stream.frame[1]);
  Stream.unused_frames->decode_link->decode_link = &(Stream.frame[2]);
  Stream.unused_frames->decode_link->decode_link->decode_link = &(Stream.frame[3]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link = &(Stream.frame[4]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link->decode_link = NULL;
  /* If we are displaying one of the anchor frames, then we must decode the prefill anchor frames into the *other* two anchor frame buffers */
  switch ((VID_DFP & 0x3FFF) + 2 * (VID_XFA & 0x3FFF))
  {
    case SDRAM_FRAME_BUFFER_1_START/256:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_2_START/256;
      break;
    case SDRAM_FRAME_BUFFER_2_START/256:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_3_START/256;
      break;
    default:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_1_START/256;
      break;
  }
  Stream.next_B_frame_buffer = SDRAM_FRAME_BUFFER_4_START/256;
  Stream.video_presentation_error = pe_acceptable; /* don't do lipsync until we've found two consecutive errors */
  WRITE_VID_VBT(0);
  if (!Stream.rs_flags.audio_present) Stream.aud_flags.first_header_received = false; /* don't offer audio headers in *VideoInfo */
  
  /* Claim interrupts */
  IRQ_EnableCommonIRQs ();
  IRQ_EnableVideoPrefillIRQs ();
  
  return e;
}

/******	static_VideoStop() *************************************************

Purpose:	Common code between ResetStream and CloseStream
In:		|true| if the currently queueing data should be allowed to play out
Out:		Number of data bytes that were not played

***************************************************************************/

static unsigned int static_VideoStop (bool play_out)
{
  unsigned int discarded_data = 0; /* default if we're playing out, or if there are no queuing packets */
  
  if (play_out)
  {
    /* Play out the old video data, but don't send any more to the 3520 */
    Stream.video.state = stream_closing;
    
    /* During play-out, we don't bother waiting for buffer-full */
    WRITE_VID_VBT(0); /* may trigger an interrupt immediately */
    
    /* Wait until all data is sent to the 3520 */
    MiscAsm_UserModeWait (&Stream.video.packet_list_head);
    
    /* Wait until the 3520 consumes all its data */
    while (((volatile program_element_structure_t *)&Stream)->vid_flags.stalled_while_closing == false);
    
    /* Now we are closed */
    Stream.video.state = stream_closed;
  }
  else
  {
    /* Go directly to closed, do not pass GO, do not collect £200 */
    Stream.video.state = stream_closed;
    while (Stream.video.packet_list_head != NULL)
    {
      discarded_data += Stream.video.packet_list_head->length;
      Stuffing_FreePacket (&Stream.video);
    }
  }
  
  /* Release interrupts */
  IRQ_DisableCommonIRQs ();
  IRQ_DisableVideoIRQs ();
  
  return discarded_data;
}

/******	static_CompleteScalingTypeParameters() *****************************

Purpose:	Fills in missing ScalinType parameters from NVRAM
In:		Whether to recache NVRAM settings

***************************************************************************/

static void static_CompleteScalingTypeParameters (bool recache)
{
  static TV_aspect shape;
  static bool use_switching;
  static viewing_mode mode;
  
  if (recache)
  {
    shape = tv_regular;
    use_switching = false;
    mode = vm_zoom;
    _swix (NVRAM_Read, _INR(0,2), "TVAspectRatio", &shape, 0);
    _swix (NVRAM_Read, _INR(0,2), "WideScreenSignalling", &use_switching, 0);
    _swix (NVRAM_Read, _INR(0,2), "TVViewingMode", &mode, 0);
  }
  
  if (Stream.video_parms.scaling_type.type == st_free)
  {
    if (!Stream.video_parms.scaling_type.param.free.valid_ratio)
    {
      Stream.video_parms.scaling_type.param.free.ratio = shape;
      Stream.video_parms.scaling_type.param.free.valid_ratio = true;
    }
    if (!Stream.video_parms.scaling_type.param.free.valid_WSS)
    {
      Stream.video_parms.scaling_type.param.free.use_WSS = use_switching;
      Stream.video_parms.scaling_type.param.free.use_SCART_pin_8 = use_switching;
      Stream.video_parms.scaling_type.param.free.valid_WSS = true;
    }
    if (!Stream.video_parms.scaling_type.param.free.valid_preference)
    {
      Stream.video_parms.scaling_type.param.free.preference = mode;
      Stream.video_parms.scaling_type.param.free.valid_preference = true;
    }
  }
}
