/******	Video.c ************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Video SWI handling

Copyright 1999-2000 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
01/10/1999	BJGA	Created
20/10/1999	BJGA	Tweaks to enable playing the first picture
22/10/1999	BJGA	API updated in line with issue 2 specification
26/10/1999	BJGA	Now initialises picture lists on open and reset stream
05/11/1999	BJGA	Discards partial PES packets at start of stream;
			returns discarded data count from static_VideoStop()
12/11/1999	BJGA	Variable name changes in line with Types.h
17/11/1999	BJGA	Implemented SWI MPEGVideo_SetSpeed; initialises
			display list, fifth frame struct and first-anchor/B-
			frame buffer pointers
23/11/1999	BJGA	Initialises the new data counts and state flags; comes
			out of pause more slowly, so the user has a chance to
			request a single-step operation; return values from
			SWIStats() initialised, so VSP modules no longer crash;
			play-out on stream close implemented
25/11/1999	BJGA	Initialises frame buffer list (for new buffer allocation scheme)
30/11/1999	BJGA	Play-out no longer applies when slow-motion is selected
01/12/1999	BJGA	picture_structure initialisations changed to support new
			field/frame picture switching code
13/12/1999	BJGA	Added mode change and screen clearing in OpenStream;
			implemented SWI MPEGVideo_SetVideoParameters 1
28/01/2000	BJGA	Implemented ReadParameters 4 and 5 - allows OVS to work!
09/02/2000	BJGA	Changed stream initialisation as per new frame buffer
			allocation algorithm
17/02/2000	BJGA	MPEG video is now blanked on CloseStream; first frame is
			decoded into framebuffer 2 if framebuffer 1 is being displayed
			(important now that blanking on ResetStream has been disabled);
			support added for deferred SetSpeed calls
22/02/2000	BJGA	Implemented CardControl 7; various flagging added to ensure that
			*VideoInfo only prints video header info for video-only streams;
			fixed bugs in deferred SetSpeed; fixed case where *second* prefill
			anchor frame could be decoded into the current display framebuffer
02/03/2000	BJGA	Implemented MPEGVideo_CardControl 2 and MPEGVideo_SetVideoParameters 2
10/04/2000	BJGA	Added counts of PES packets sent, PTSs encoded and decoded;
			added support for internally-generated resets;
			trick-play streams are no longer allowed to play out when they are closed;
			deferred set-speed now applied when going faster as well as when going slower;
			implemented MPEGVideo_ReadParameters 3;
			various initialisations for synchronisation added
02/05/2000	BJGA	Changed format of ScalingType 0 parameters (allows partial defaulting to NVRAM settings);
			now returns internal line 23 and SCART WSS states from MPEGVideo_SetVideoParameters 1 and 2;
			enumeration of line 23 WSS states made more sane (ignores parity bit);
			internal WSS states deactivated on CloseStream
11/05/2000	BJGA	Now checks video stream handles passed in; byte counters are now 64 bits wide;
			implemented MPEGVideo_Stats; extra initialisation added to static_VideoStart()
18/05/2000	BJGA	Issues UpCall_MPEG &1003 when the video speed indicator changes
26/05/2000	BJGA	Implemented MPEGVideo_GetSprite; fixed an immediate access to a multi-cycle register
13/06/2000	BJGA	Initialisations for *PacketInfo
20/06/2000	BJGA	Initialisations for video PTS list; FullPackets now discards data until the first sequence header
06/07/2000	BJGA	Implemented MPEGVideo_Play 1 (part of timeout/EOS detection)
08/07/2000	BJGA	Video state is now reported as idle durng prefill; fixed incorrect parameters to _swix(MPEGControl_Play)
14/07/2000	BJGA	Initialisations for repeat sequence header parsing and error counts
10/08/2000	BJGA	Implemented (De)registerHandler SWIs;
			sends clear-overlay CC control codes to TV on non-internal resets and CloseStreams

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include "kernel.h"
#include "swis.h"

#include "Global/RISCOS.h"
#include "Global/Sprite.h"
#include "Global/SWIs.h"
#include "Global/UpCall.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEGVideo.h"
#include "MPEG/UpCallMPEG.h"
#include "NVRAM.h"

#include "Defs.h"
#include "IRQ.h"
#include "Mess.h"
#include "MiscAsm.h"
#include "ModHdr.h"
#include "Module.h"
#include "Registers.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"
#include "WSS.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static _kernel_oserror *static_VideoStart (void);
static unsigned int static_VideoStop (bool play_out);
static void static_CompleteScalingTypeParameters (bool recache);
static _kernel_oserror *static_CheckHandle (stream_handle_t vsh);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#ifndef ErrorNumber_BuffOverflow
#define ErrorNumber_BuffOverflow 0x1E5
#endif

/********************/
/* Public functions */
/********************/

/******	Video_SWIOpenStream() **********************************************

Purpose:	Handles MPEGVideo_OpenStream
In:		Control stream flags; control stream handle; video parameters
		structure; address to write video stream handle into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIOpenStream (stream_flags_t *flags, control_stream_handle_t csh, video_parameters_structure_t *vps, stream_handle_t *return_vsh)
{
  _kernel_oserror *e = NULL;
  bool old_audio_present_flag;
  dprintf (("Video", "SWIOpenStream\n"));
  
  /* Cache StreamFlags (other than our copies of the video_present and audio_present flags), ControlStreamHandle and VideoParametersStructure */
  /* This way we can cope with the sequence MPEGVideo_OpenStream, MPEGAudio_OpenStream (returning an error), then MPEGVideo_CloseStream */
  old_audio_present_flag = Stream.s_flags.audio_present;
  Stream.s_flags = *flags;
  Stream.s_flags.video_present = true;
  Stream.s_flags.audio_present = old_audio_present_flag;
  Stream.csh = csh;
  Stream.video_parms = *vps;
  if (!Stream.video_parms.scaling_type_present)
  {
    Stream.video_parms.scaling_type.type = st_free;
    Stream.video_parms.scaling_type.param.free.valid_ratio =
      Stream.video_parms.scaling_type.param.free.valid_WSS =
      Stream.video_parms.scaling_type.param.free.valid_preference =
      Stream.video_parms.scaling_type.param.free.reserved1 =
      Stream.video_parms.scaling_type.param.free.reserved2 = 0;
  }
  static_CompleteScalingTypeParameters (true);
  
  /* Initialise various variables */
  Stream.rs_flags.video_present = Stream.s_flags.video_present;
  Stream.rs_flags.audio_present = Stream.s_flags.audio_present;
  Stream.rs_flags.trick_play_mode = false;
  Stream.video.since_open.amount_received.lsw = Stream.video.since_open.amount_received.msw = 0;
  Stream.video.since_open.amount_sent.lsw = Stream.video.since_open.amount_sent.msw = 0;
  Stream.video.since_open.PES_packets_sent = 0;
  Stream.video.since_open.PTSs_in = 0;
  Stream.video.since_open.PTSs_out = 0;
  Stream.video.since_open.slows = 0;
  Stream.video.since_open.fasts = 0;
  Stream.video.since_open.stalls = 0;
  Stream.video.since_open.picture_decode_errors = 0;
  Stream.video.since_open.severe_errors = 0;
  Stream.video.since_open.pipeline_errors = 0;
  Stream.video.since_open.seqhdr_errors = 0;
  Stream.video.since_open.internal_resets = 0;
  Stream.video.since_open.underruns = 0;
  
  /* Initialise the new stream */
  Stream.vid_flags.internal_reset = false;
  e = static_VideoStart ();
  if (!e)
  {
    
    /* Change screen mode if required */
    if (Stream.video_parms.screen_mode != -1)
    {
      e = _swix (OS_ScreenMode, _INR(0,1), 0, Stream.video_parms.screen_mode);
    }
  }
  if (!e)
  {
    
    if (Stream.video_parms.dont_CLS == 0)
    {
      /* Clear screen if required */
      _swix (OS_SetColour, _INR(0,1), 16, 0x8000); /* set background graphics colour to transparent black overwrite */
      _swix (OS_WriteI + 16, 0);                   /* CLG */
    }
    
    /* We no longer reprogram the palette */
    
    /* Return a pointer to Stream as the video stream handle */
    *return_vsh = (stream_handle_t) &Stream;
  }
  return e;
}

/******	Video_SWIFullPackets() *********************************************

Purpose:	Handles MPEGVideo_FullPackets
In:		Flags; video stream handle; list of bitstream packets
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIFullPackets (unsigned int flags, stream_handle_t vsh, bitstream_packet_t *packets)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  e = static_CheckHandle (vsh);
  
  if (!e)
  {
    /* If we're just starting, discard bitstream packets until the beginning of the first PES packet */
    while (Stream.video.prefill_state == ps_searching_for_first_PES_header && packets != NULL)
    {
      if (packets->mpeg_start == true)
      {
        Stream.video.prefill_state = ps_searching_for_first_sequence_header;
        dprintf (("Video", "SWIFullPackets: video.prefill_state = searching_for_first_sequence_header\n"));
        Stream.seqhdrsearch_stage = unlocked;
      }
      else
      {
        dprintf (("Video", "SWIFullPackets: discarding partial packet\n"));
        packets = MiscAsm_FreePacket (packets);
        /* Note that the rest of the function can cope fine if this sets |packets| to NULL */      
      }
    }
    
    /* I really despair of this MPEG chip. If there isn't a sequence header close to the beginning of    */
    /* the stream it receives, it's liable to lock up with the bitbuffer full and the header fifo empty. */
    /* Instead, we'll have to do the sequence header search ourselves, in software.                      */
    while (Stream.video.prefill_state == ps_searching_for_first_sequence_header && packets != NULL)
    {
      while (Stream.seqhdrsearch_stage != b3 && packets->length > 0)
      {
        unsigned char byte = *packets->start;
        packets->start ++;
        packets->length --;
        if (Stream.seqhdrsearch_stage == unlocked && byte == 0) Stream.seqhdrsearch_stage = first_zero;
        else if ((Stream.seqhdrsearch_stage == first_zero || Stream.seqhdrsearch_stage == second_zero) && byte == 0) Stream.seqhdrsearch_stage = second_zero;
        else if (Stream.seqhdrsearch_stage == second_zero && byte == 1) Stream.seqhdrsearch_stage = one;
        else if (Stream.seqhdrsearch_stage == one && byte == 0xb3) Stream.seqhdrsearch_stage = b3;
        else Stream.seqhdrsearch_stage = unlocked;
      }
      if (packets->length == 0)
      {
        packets = MiscAsm_FreePacket (packets);
      }
      if (Stream.seqhdrsearch_stage == b3)
      {
        /* We've found the sequence header */
        /* To compensate for the fact that we've skipped the real sequence header start code, */
        /* now insert a dedicated packet that contains only a sequence header start code      */
        static bitstream_packet_t sequence_header_packet; /* initialises to zero */
        static const unsigned char sequence_header_payload [4] = { 0, 0, 1, 0xb3 };
        sequence_header_packet.start = sequence_header_payload;
        sequence_header_packet.length = 4;
        sequence_header_packet.link = Stream.video.packet_list_head;
        Stream.video.packet_list_head = Stream.video.packet_list_tail = &sequence_header_packet;
        /* Update state machine */
        Stream.video.prefill_state = ps_initialising;
        dprintf (("Video", "SWIFullPackets: video.prefill_state = initialising\n"));
      }
    }
    
    /* Disable IRQs for the rest of this SWI */
    if (irqs_were_enabled) _kernel_irqs_off ();
  
    /* If packet list is empty, point list head at the first new packet, otherwise add it to the end */
    if (Stream.video.packet_list_tail == NULL)
    {
      Stream.video.packet_list_head = packets;
    }
    else
    {
      Stream.video.packet_list_tail->link = packets;
    }
    
    /* Step along the list of new packets */
    while (packets != NULL)
    {
      unsigned int old_value;
      /* Add the length of each bitstream packet to the amnount we've received */
      old_value = Stream.video.since_open.amount_received.lsw;
      Stream.video.since_open.amount_received.lsw += packets->length;
      if (Stream.video.since_open.amount_received.lsw < old_value) Stream.video.since_open.amount_received.msw ++;
      
      old_value = Stream.video.since_reset.amount_received.lsw;
      Stream.video.since_reset.amount_received.lsw += packets->length;
      if (Stream.video.since_reset.amount_received.lsw < old_value) Stream.video.since_reset.amount_received.msw ++;
      
      /* If it's the beginning of a PES packet, fiddle the full_length field (if necessary) */
      if (packets->mpeg_start)
      {
        if (Stream.rs_flags.trick_play_mode && Stream.video_parms.fix_lengths)
        {
          packets->full_length_unknown = true;
        }
        if (packets->full_length_unknown)
        {
          packets->full_length = 0;
        }
      }
      
      /* Update list tail pointer */
      Stream.video.packet_list_tail = packets;
      
      /* Move on to next packet */
      packets = packets->link;
    }
    
    /* Restore IRQ state */
    if (irqs_were_enabled) _kernel_irqs_on ();
  }
  return e;
}

/******	Video_SWICloseStream() *********************************************

Purpose:	Handles MPEGVideo_CloseStream
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICloseStream (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  unsigned char group_settings [4] = { 0, 0xFF, 0xFF, 0xFF };
  scart_feature scart_setting = scart_dontcare;
  e = static_CheckHandle (vsh);
  dprintf (("Video", "SWICloseStream\n"));
  
  if (!e)
  {
    /* If an internal reset was pending, stop it */
    _swix (OS_RemoveCallBack, _INR(0,1), video_reset_callback, Module_PrivateWord);
    
    /* Stop playing the old stream, only playing out the old data if we were playing at normal speed */
    Stream.vid_flags.internal_reset = false;
    static_VideoStop (Stream.video.speed_indicator == 1 && Stream.video.state == stream_open && !Stream.rs_flags.trick_play_mode);
    
    if (flags & CloseStreamFlags_BlankVideo)
    {
      /* We now only blank the video output on CloseStream, not on ResetStream */
      VID_DCF_0 &= ~VID_DCF_EVD>>0;
    }
    
    /* Stop overriding the widescreen signalling */
    WSS_SetSCART (NULL, NULL, NULL, &scart_setting);
    WSS_Set (group_settings, true, NULL, NULL);
    
    Stream.s_flags.video_present = false;
  }
  return e;
}

/******	Video_SWIPlay() ****************************************************

Purpose:	Handles MPEGVideo_Play
In:		Flags; video stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIPlay (unsigned int flags, stream_handle_t vsh)
{
  _kernel_oserror *e = NULL;
  e = static_CheckHandle (vsh);
  dprintf (("Video", "SWIPlay\n"));
  
  if (!e)
  {
    if ((flags & VideoPlayFlags_Stop) != 0)
    {
      if (Stream.vid_flags.display_idle)
      {
        e = _swix (MPEGControl_Play, _INR(0,1), PlayFlags_VideoIdle, Stream.csh);
      }
      else
      {
        Stream.vid_flags.eos_callback_requested = true;
      }
    }
    else
    {
      e = IRQ_EnableVideoIRQs ();
    }
  }
  return e;
}

/******	Video_SWISetSpeed() ************************************************

Purpose:	Handles MPEGVideo_SetSpeed
In:		Flags; video stream handle;
		speed (0 => pause, 1 => normal, 2-16 => 1/2 - 1/16th speed)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetSpeed (unsigned int flags, stream_handle_t vsh, unsigned int speed)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  bool issue_the_upcall = false;
  e = static_CheckHandle (vsh);
  dprintf (("Video", "SWISetSpeed\n"));
  
  if (!e)
  {
    if (irqs_were_enabled) _kernel_irqs_off ();
    
    /* Coming out of pause requires a little trickery */
    if (Stream.video.speed_indicator == 0 && speed != 0)
    {
      Stream.fields_till_next_AU = (Stream.fields_till_next_AU & 1) + (2 * speed); /* maintain odd/evenness */
      Stream.reference_STC = Clk_ReadRawSTC (); /* make it as though STC hasn't incremented since we went into pause */
    }
    if (speed == Stream.video.speed_indicator)
    {
      /* No change - do nothing */
    }
    else if ((flags & SetSpeedFlags_DeferSetSpeed) == 0 || !Stream.rs_flags.audio_present)
    {
      /* If defer flag is clear, or if there's no audio, then change speed immediately */
      Stream.vid_flags.going_faster = Stream.vid_flags.going_slower = false; /* in case a deferred SetSpeed is still pending */
      Stream.video.speed_indicator = speed;
      issue_the_upcall = true;
    }
    else if ((speed < Stream.video.deferred_speed_indicator && speed != 0) || Stream.video.deferred_speed_indicator == 0)
    {
      /* Moving to a faster speed - wait for audio buffer to exceed prefill level */
      Stream.vid_flags.going_faster = true;
      Stream.vid_flags.going_slower = false;
    }
    else
    {
      /* Moving to a slower speed - wait for audio buffer to fall below prefill level */
      Stream.vid_flags.going_slower = true;
      Stream.vid_flags.going_faster = false;
    }
    /* When the buffer reaches the required condition, this is the speed that should be asserted */
    Stream.video.deferred_speed_indicator = speed;
    
    if (irqs_were_enabled) _kernel_irqs_on ();
    
    if (issue_the_upcall)
    {
      /* OS_UpCall enables interrupts */
      _swix (OS_UpCall, _INR(0,4), UpCall_MPEG, 0, Stream.csh, UpCallMPEG_SpeedChange, Stream.video.speed_indicator);
    }
  }
  return e;
}

/******	Video_SWICardControl2() ********************************************

Purpose:	Handles MPEGVideo_CardControl 2
In:		EOR and AND masks to apply to virtual MPEG-1 control register;
		addresses to write old and new values of virtual register into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl2 (unsigned int EOR_mask, unsigned int AND_mask, unsigned int *return_old_value, unsigned int *return_new_value)
{
  _kernel_oserror *e = NULL;
  scart_feature rgb = scart_preserve;
  scart_feature tvassert = scart_preserve;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  WSS_SetSCART (&rgb, &tvassert, NULL, NULL);
  *return_old_value = ((rgb == scart_enable) ? UpdateControlRegister_CTRL1 : 0) | ((tvassert == scart_enable) ? UpdateControlRegister_CTRL0 : 0);
  *return_new_value = (*return_old_value & AND_mask) ^ EOR_mask;
  rgb = ((*return_new_value & UpdateControlRegister_CTRL1) != 0) ? scart_enable : scart_disable;
  tvassert = ((*return_new_value & UpdateControlRegister_CTRL0) != 0) ? scart_enable : scart_disable;
  WSS_SetSCART (&rgb, &tvassert, NULL, NULL);
  
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Video_SWICardControl7() ********************************************

Purpose:	Handles MPEGVideo_CardControl 7
In:		Addresses to write flag word and revision number into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWICardControl7 (unsigned int *return_flags, unsigned int *return_revision)
{
  _kernel_oserror *e = NULL;
  unsigned char first_read = VID_REV;
  unsigned char second_read = VID_REV;
  if (first_read == second_read)
  {
    *return_flags = 0;
  }
  else
  {
    *return_flags = 1;
  }
  *return_revision = first_read;
  return e;
}

/******	Video_SWIReadParameters3() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 3
In:		Address to write least significant 32 bits of PCR/SCR into,
		address to write most significant 1 bit of PCR/SCR into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters3 (unsigned int *return_PCR_lo, unsigned int *return_PCR_hi)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  clk my_PCR;
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  my_PCR = Clk_ReadRawSTC ();
  if (irqs_were_enabled) _kernel_irqs_on ();
  my_PCR = Clk_ConvertSTCtoPCR (my_PCR);
  
  if (Stream.audio.state == stream_open || Stream.audio.state == stream_closing)
  {
    *return_PCR_lo = my_PCR.lsw;
    *return_PCR_hi = my_PCR.msb;
  }
  else
  {
    *return_PCR_lo = 0;
    *return_PCR_hi = 0;
  }
  return e;
}

/******	Video_SWIReadParameters4() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 4
In:		Address to write buffer fullness into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters4 (unsigned int *return_buffer_fullness)
{
  _kernel_oserror *e = NULL;
  if (Stream.video.state != stream_closed)
  {
    *return_buffer_fullness = (VID_VBL & 0x3FFF) * 256;
  }
  else
  {
    *return_buffer_fullness = 0;
  }
  return e;
}

/******	Video_SWIReadParameters5() *****************************************

Purpose:	Handles MPEGVideo_ReadParameters 5
In:		Address to write unblanked flag into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIReadParameters5 (unsigned int *return_display_ready)
{
  _kernel_oserror *e = NULL;
  *return_display_ready = Stream.vid_flags.first_frame_displayed;
  return e;
}

/******	Video_SWIResetStream() *********************************************

Purpose:	Handles MPEGVideo_ResetStream
In:		ResetStream flags; video stream handle;
		address to write discarded data count into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIResetStream (reset_stream_flags_t *flags, stream_handle_t vsh, unsigned int *return_discarded_data_size)
{
  _kernel_oserror *e = NULL;
  e = static_CheckHandle (vsh);
  dprintf (("Video", "SWIResetStream\n"));
  
  if (!e)
  {
    /* Cache ResetStreamFlags */
    Stream.rs_flags = *flags;
    
    /* Read audio and video buffer fullnesses */
    *return_discarded_data_size = (VID_VBL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
    /*  We need to read (and cache) the audio buffer fullness too, because
     *  we'll be resetting the 3520 in a while, which destroys the information.
     *  Note that this assumes MPEGVideo_ResetStream is called before
     *  MPEGAudio_ResetStream, which both MPEGSystem and MPEGTransport do.
     */
    Stream.discarded_audio_bit_buffer_data = (VID_ABL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
    
    /* Stop playing the old stream immediately */
    *return_discarded_data_size += static_VideoStop (false);
    
    /* Initialise the new stream */
    Stream.vid_flags.internal_reset = false;
    e = static_VideoStart ();
  }
  return e;
}

/******	Video_SWIStats() ***************************************************

Purpose:	Handles MPEGVideo_Stats
In:		Flags; video stream handle; pointer to tags list; buffer to
		write ino (pointer/size); address to write updated buffer
		pointer into; address to write space remaining into (may be <0)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIStats (unsigned int flags, stream_handle_t vsh, unsigned int *tags, void *buffer, int buffer_size, void **return_pointer, int *return_buffer_remaining)
{
  _kernel_oserror *e = NULL;
  unsigned int tag;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  struct data_out
  {
    unsigned int tag;
    unsigned int length;
    unsigned int data [7];
  };
  IGNORE(flags);
  IGNORE(vsh);
  
  *return_pointer = buffer;
  *return_buffer_remaining = buffer_size;
  
  while ((tag = *tags++) != -1)
  {
    struct data_out *output = *(struct data_out **)return_pointer;
    switch (tag)
    {
      case 0x1000:
        *return_buffer_remaining -= 12;
        if (*return_buffer_remaining >= 0)
        {
          output->tag = tag;
          output->length = sizeof(int);
          output->data[0] = Stream.video.since_open.underruns;
        }
        *(char **)return_pointer += 12;
        break;
      case 0x1001:
        *return_buffer_remaining -= 12;
        if (*return_buffer_remaining >= 0)
        {
          output->tag = tag;
          output->length = sizeof(int);
          output->data[0] = Stream.video.since_open.amount_received.lsw;
        }
        *(char **)return_pointer += 12;
        break;
      case 0x100B:
        *return_buffer_remaining -= 12;
        if (*return_buffer_remaining >= 0)
        {
          bitstream_packet_t *packet_ptr;
          output->tag = tag;
          output->length = sizeof(int);
          output->data[0] = 0;
          if (irqs_were_enabled) _kernel_irqs_off ();
          for (packet_ptr = Stream.video.packet_list_head; packet_ptr != NULL; packet_ptr = packet_ptr->link)
          {
            output->data[0] += packet_ptr->length;
          }
          if (irqs_were_enabled) _kernel_irqs_on ();
        }
        *(char **)return_pointer += 12;
        break;
      case 0x1011:
        *return_buffer_remaining -= 36;
        if (*return_buffer_remaining >= 0)
        {
          /* Need to compensate for VIDC borders and graphics origin when returning OS units */
          int in_block [3] = { 136, 137, -1 };
          int out_block [2];
          _swix (OS_ReadVduVariables, _INR(0,1), in_block, out_block);
          output->tag = tag;
          output->length = 7 * sizeof(int);
          output->data[0] = Stream.active_horizontal_size;
          output->data[1] = Stream.active_vertical_size;
          output->data[2] = Stream.active_aspect_ratio;
          output->data[3] = Stream.displayed_active_centre_x - Module_OriginXOffset - out_block [0];
          output->data[4] = (Module_Display525_60 ? 960 : 1152) - Stream.displayed_active_centre_y * 4 - Module_OriginYOffset - out_block [1];
          output->data[5] = Stream.displayed_active_width;
          output->data[6] = Stream.displayed_active_height * 4;
        }
        *(char **)return_pointer += 36;
        break;
    }
  }
  
  if (*return_buffer_remaining < 0)
  {
    e = Mess_GenerateError ("Err_BufOvf", ErrorNumber_BuffOverflow, 0);
  }
  
  return e;
}

/******	Video_SWIRegisterHandler() *****************************************

Purpose:	Handles MPEGVideo_RegisterHandler
In:		Handler number; handler pointer; handler workspace pointer
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIRegisterHandler (unsigned int number, const void *handler, const void *wsptr)
{
  _kernel_oserror *e = NULL;
  handler_t *new_handler;
  e = _swix (OS_Module, _IN(0)|_IN(3)|_OUT(2), 6 /*ModHandReason_Claim*/, sizeof (handler_t), &new_handler);
  if (!e)
  {
    new_handler->next = Module_Handlers;
    new_handler->number = number;
    new_handler->handler = handler;
    new_handler->wsptr = wsptr;
    Module_Handlers = new_handler;
  }
  return e;
}

/******	Video_SWIDeregisterHandler() ***************************************

Purpose:	Handles MPEGVideo_DeregisterHandler
In:		Handler number; handler pointer; handler workspace pointer
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIDeregisterHandler (unsigned int number, const void *handler, const void *wsptr)
{
  _kernel_oserror *e = NULL;
  handler_t *prev = (handler_t *)&Module_Handlers; /* treat the list head as though it were the first word of another link */
  handler_t *ptr = Module_Handlers;
  while (ptr != NULL)
  {
    if (ptr->number == number && ptr->handler == handler && ptr->wsptr == wsptr)
    {
      prev->next = ptr->next;
      prev = ptr;
      ptr = ptr->next;
      _swix (OS_Module, _IN(0)|_IN(2), 7 /*ModHandReason_Free*/, prev);
    }
    else
    {
      prev = ptr;
      ptr = ptr->next;
    }
  }
  return e;
}

/******	Video_SWISetVideoParameters0() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 0
In:		Video stream handle; video scaling block to write to and/or read from
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters0 (stream_handle_t vsh, scaling_type_block_t *block_in_out)
{
  _kernel_oserror *e = NULL;
  scaling_type_block_t temp_scaling_type_block;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  e = static_CheckHandle (vsh);
  
  if (!e)
  {
    temp_scaling_type_block = *block_in_out;
    if (irqs_were_enabled) _kernel_irqs_off ();
    *block_in_out = Stream.video_parms.scaling_type;
    if (temp_scaling_type_block.type != (scaling_type) -1)
    {
      Stream.video_parms.scaling_type = temp_scaling_type_block;
      Stream.vid_flags.display_needs_setting_up = true;
      static_CompleteScalingTypeParameters (false);
    }
    if (irqs_were_enabled) _kernel_irqs_on ();
  }
  return e;
}

/******	Video_SWISetVideoParameters1() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 1
In:		New WSS state (or -1 just to read old state);
		address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters1 (unsigned int new_state, unsigned int *return_old_ext_state, unsigned int *return_old_int_state)
{
  _kernel_oserror *e = NULL;
  unsigned char new_group_settings [4] = { 0xFF, 0xFF, 0xFF, 0xFF };
  unsigned char old_state_ext;
  unsigned char old_state_int;
  
  if (new_state == 0 || new_state == -1)
  {
    new_group_settings [0] = new_state;
  }
  else
  {
    unsigned int temp;
    new_state -= 1;
    temp = new_state ^ (new_state >> 1);
    temp = temp ^ (temp >> 2);
    if ((temp & 1) == 0) new_state ^= 8; /* set odd parity */
    new_group_settings [0] = new_state;
  }
  e = WSS_Set (new_group_settings, false, &old_state_ext, &old_state_int);
  if (old_state_ext == 0)
  {
    *return_old_ext_state = 0;
  }
  else
  {
    *return_old_ext_state = (old_state_ext & 7) + 1;
  }
  if (old_state_int == 0)
  {
    *return_old_int_state = 0;
  }
  else
  {
    *return_old_int_state = (old_state_int & 7) + 1;
  }
  return e;
}

/******	Video_SWISetVideoParameters2() *************************************

Purpose:	Handles MPEGVideo_SetVideoParameters 2
In:		New SCART pin 8 state (or -1 just to read old state);
		address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWISetVideoParameters2 (unsigned int new_state, unsigned int *return_old_ext_state, unsigned int *return_old_int_state)
{
  _kernel_oserror *e = NULL;
  
  if (new_state == -1)
  {
    *return_old_ext_state = scart_preserve;
  }
  else
  {
    *return_old_ext_state = new_state;
  }
  *return_old_int_state = scart_preserve;
  WSS_SetSCART (NULL, NULL, (scart_feature *) return_old_ext_state, (scart_feature *) return_old_int_state);
  return e;
}

/******	Video_SWIGetSprite() ***********************************************

Purpose:	Handles MPEGVideo_GetSprite
In:		Flags; video stream handle; sprite area control block pointer
		for sprite area to create sprite in (or null to use system
		sprite area); name of sprite to create
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Video_SWIGetSprite (unsigned int flags, stream_handle_t vsh, void *sprite_area, const char *sprite_name)
{
  _kernel_oserror *e = NULL;
  unsigned int DA_number;
  void *DA_start;
  bool DA_created = false;
  char *sprite;
  unsigned int frame_buffer = 0;
  unsigned int macroblock_width = 0;
  unsigned int macroblock_height = 0;
  bool interlaced = true;
  unsigned int coded_area_width = 0;
  unsigned int coded_area_height = 0;
  unsigned int active_area_width = 0;
  unsigned int active_area_height = 0;
  bool active_top_flag = false;
  unsigned int my_VID_XFA;
  unsigned int my_VID_XFS;
  unsigned int left_wastage = 0;
  unsigned int bottom_wastage = 0;
  unsigned int right_wastage = 0;
  unsigned int top_wastage = 0;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  
  if (vsh != NULL) /* NULL is allowed, as a special handle meaning "most recently open stream" */
  {
    e = static_CheckHandle (vsh);
  }
  if (!e)
  {
    /* We can't get the information we need if no picture has been displayed since OpenStream or ResetStream */
    if (Stream.display_frames == NULL)
    {
      e = Mess_GenerateError ("Err_NoDisplayedPicture", errno_NO_DISPLAYED_PICTURE, 0);
    }
  }
  if (!e)
  {
    /* Read display variables */
    if (irqs_were_enabled) _kernel_irqs_off ();
    READ_VID_XFA(my_VID_XFA);
    READ_VID_XFS(my_VID_XFS);
    frame_buffer = ((VID_DFP & 0x3FFF) + 2 * (my_VID_XFA & 0x3FFF)) << 8;
    macroblock_width = VID_XFW;
    macroblock_height = (my_VID_XFS & 0x3FFF);
    interlaced = VID_DCF_0 & VID_DCF_USR>>0;
    coded_area_width = Stream.display_frames->seq.coded_horizontal_size;
    coded_area_height = Stream.display_frames->seq.coded_vertical_size;
    active_area_width = Stream.active_horizontal_size;
    active_area_height = Stream.active_vertical_size;
    active_top_flag = Stream.active_area_is_at_top;
    if (irqs_were_enabled) _kernel_irqs_on ();
    
    if (macroblock_width == 0) macroblock_width = 1;
    if (macroblock_height == 0) macroblock_height = 1;
    macroblock_height /= macroblock_width;
    if (interlaced)
    {
      coded_area_height >>= 1;
      active_area_height >>= 1;
    }
    /* Create a temporary dynamic area to hold a raw copy of the framebuffer */
    e = _swix (OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, 622080, -1, 1<<7, 622080, 0, 0, "Framebuffer copy", &DA_number, &DA_start);
  }
  if (!e)
  {
    DA_created = true;
    /* Copy the framebuffer to the dynamic area */
    e = STi3520L_ReadSDRAM (frame_buffer, DA_start, 622080);
  }
  if (!e)
  {
    /* Create the sprite */
    int mode_selector [10] = { 1, 720, 576, 5, -1, 4, 1, 5, 1, -1 };
    if (interlaced)
    {
      mode_selector [8] = 2; /* use rectangular pixels when capturing fields */
    }
    if (macroblock_width < macroblock_height)
    {
      mode_selector [6] = 2; /* quick-and-dirty check for half-res frames */
    }
    e = _swix (OS_SpriteOp, _INR(0,6), SpriteReason_CreateSprite | (sprite_area ? 256 : 0), sprite_area, sprite_name, 0, macroblock_width * 16, macroblock_height * (interlaced ? 8 : 16), mode_selector);
  }
  if (!e)
  {
    /* Get a pointer to the sprite */
    void *control_block = sprite_area;
    if (control_block == NULL)
    {
      /* SelectSprite will only return a sprite address if we supply a user control block pointer */
      e = _swix (OS_ReadDynamicArea, _IN(0)|_OUT(0), 3, &control_block);
    }
    if (!e)
    {
      e = _swix (OS_SpriteOp, _INR(0,2)|_OUT(2), SpriteReason_SelectSprite | 256, control_block, sprite_name, &sprite);
    }
  }
  if (!e)
  {
    sprite += *(unsigned int *)(sprite + spImage); /* add in offset to sprite image */
    /* Do the actual conversion in hand-coded assembler for speed */
    MiscAsm_ConvertImage (DA_start, sprite, macroblock_width, macroblock_height, (interlaced ? 2 : 0) | (frame_buffer < SDRAM_FRAME_BUFFER_4_START ? 1 : 0));
    /* Cope with partial macroblocks */
    if (coded_area_width < macroblock_width * 16)
    {
      right_wastage = macroblock_width * 16 - coded_area_width;
    }
    if (coded_area_height < macroblock_height * (interlaced ? 8 : 16))
    {
      bottom_wastage = macroblock_height * (interlaced ? 8 : 16) - coded_area_height;
    }
    /* Trim down from coded area to active area, since the rest of the API is in terms of the active area */
    if (active_area_width < coded_area_width)
    {
      left_wastage = coded_area_width - active_area_width;
      right_wastage += left_wastage - (left_wastage >> 1);
      left_wastage >>= 1;
    }
    if (active_area_height < coded_area_height)
    {
      if (active_top_flag)
      {
        bottom_wastage += coded_area_width - active_area_width;
      }
      else
      {
        top_wastage = coded_area_width - active_area_width;
        bottom_wastage += top_wastage - (top_wastage >> 1);
        top_wastage >>= 1;
      }
    }
    /* Apply the wastages */
    if (right_wastage > 0)
    {
      e = _swix (OS_SpriteOp, _INR(0,4), SpriteReason_InsertDeleteColumns | (sprite_area ? 256 : 0), sprite_area, sprite_name, macroblock_width * 16 - right_wastage, -right_wastage);
    }
  }
  if (!e)
  {
    if (left_wastage > 0)
    {
      e = _swix (OS_SpriteOp, _INR(0,4), SpriteReason_InsertDeleteColumns | (sprite_area ? 256 : 0), sprite_area, sprite_name, 0, -left_wastage);
    }
  }
  if (!e)
  {
    if (top_wastage > 0)
    {
      e = _swix (OS_SpriteOp, _INR(0,4), SpriteReason_InsertDeleteRows | (sprite_area ? 256 : 0), sprite_area, sprite_name, macroblock_height * (interlaced ? 8 :16) - top_wastage, -top_wastage);
    }
  }
  if (!e)
  {
    if (bottom_wastage > 0)
    {
      e = _swix (OS_SpriteOp, _INR(0,4), SpriteReason_InsertDeleteRows | (sprite_area ? 256 : 0), sprite_area, sprite_name, 0, -bottom_wastage);
    }
  }
  
  if (DA_created)
  {
    /* Remove the temporary dynamic area */
    _swix (OS_DynamicArea, _INR(0,1), 1, DA_number);
  }
  return e;
}

/******	Video_InternalReset() **********************************************

Purpose:	Performs a video reset in order to effect error recovery

***************************************************************************/

void Video_InternalReset (void)
{
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  dprintf (("Video", "Internal reset\n"));
  if (irqs_were_enabled) _kernel_irqs_off ();
  static_VideoStop (false);
  Stream.vid_flags.internal_reset = true;
  static_VideoStart ();
  if (irqs_were_enabled) _kernel_irqs_on ();
}

/*********************/
/* Private functions */
/*********************/

/******	static_VideoStart() ************************************************

Purpose:	Common code between OpenStream and ResetStream
Out:		Pointer to error block

***************************************************************************/

static _kernel_oserror *static_VideoStart (void)
{
  _kernel_oserror *e = NULL;
  unsigned int my_VID_XFA;
  
  /* Perform a soft reset on the 3520 */
  STi3520L_SoftReset (true, false);
  
  /* Initialise various variables */
  Stream.video.state = stream_prefilling;
  Stream.video.prefill_state = ps_searching_for_first_PES_header;
  if (!Stream.vid_flags.internal_reset)
  {
    Stream.video.speed_indicator = 1;
    Stream.video.deferred_speed_indicator = 1;
  }
  Stream.video.fast_slow_state = fss_normal_speed;
  Stream.video.packet_list_head = NULL;
  Stream.video.packet_list_tail = NULL;
  if (!Stream.vid_flags.internal_reset)
  {
    Stream.video.since_reset.amount_received.lsw = Stream.video.since_reset.amount_received.msw = 0;
    Stream.video.since_reset.amount_sent.lsw = Stream.video.since_reset.amount_sent.msw = 0;
    Stream.video.since_reset.PES_packets_sent = 0;
    Stream.video.since_reset.PTSs_in = 0;
    Stream.video.since_reset.PTSs_out = 0;
    Stream.video.since_reset.slows = 0;
    Stream.video.since_reset.fasts = 0;
    Stream.video.since_reset.stalls = 0;
    Stream.video.since_reset.picture_decode_errors = 0;
    Stream.video.since_reset.severe_errors = 0;
    Stream.video.since_reset.pipeline_errors = 0;
    Stream.video.since_reset.seqhdr_errors = 0;
    Stream.video.since_reset.internal_resets = 0;
    Stream.video.since_reset.underruns = 0;
  }
  Stream.video.first_PTS.msb = 0x80; /* flag that no PTS has been found yet */
  Stream.video.first_PTS.lsw = 0;
  Stream.prev_picture_structure = ps_frame_picture;
  Stream.current_picture_structure = ps_frame_picture_extension; /* magic value should start off all types of clips correctly */
  Stream.vid_flags.default_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.default_non_intra_quantizer_matrix_loaded = false;
  Stream.vid_flags.started_parsing_headers = false;
  Stream.vid_flags.sequence_headers_locked = false;
  Stream.vid_flags.sequence_headers_being_parsed = false;
  Stream.vid_flags.display_headers_present = false;
  Stream.vid_flags.had_phoney_pipeline_idle_IRQ = false;
  Stream.vid_flags.prefill_anchor_frames_decoded = 0;
  Stream.vid_flags.first_frame_displayed = false;
  Stream.vid_flags.next_frames_headers_have_been_decoded = false;
  Stream.vid_flags.this_frames_data_have_been_decoded = true; /* don't expect PID IRQ before the first picture! */
  Stream.vid_flags.last_instruction_was_a_decode = false;
  Stream.vid_flags.final_instruction_has_been_written_during_this_AU = false;
  Stream.vid_flags.stalled_while_closing = false;
  Stream.vid_flags.going_faster = false;
  Stream.vid_flags.going_slower = false;
  Stream.vid_flags.display_needs_setting_up = true;
  Stream.vid_flags.display_idle = true;
  Stream.vid_flags.eos_callback_requested = false;
  Stream.fields_till_next_AU = -1; /* can't accidentally take value +1 before display is properly initialised */
  Stream.consecutive_pipeline_stalls = 0;
  Stream.decode_frames = NULL;
  Stream.display_frames = NULL;
  Stream.unused_frames = &(Stream.frame[0]);
  Stream.unused_frames->decode_link = &(Stream.frame[1]);
  Stream.unused_frames->decode_link->decode_link = &(Stream.frame[2]);
  Stream.unused_frames->decode_link->decode_link->decode_link = &(Stream.frame[3]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link = &(Stream.frame[4]);
  Stream.unused_frames->decode_link->decode_link->decode_link->decode_link->decode_link = NULL;
  Stream.previous_anchor_frame = NULL;
  /* If we are displaying one of the anchor frames, then we must decode the prefill anchor frames into the *other* two anchor frame buffers */
  READ_VID_XFA(my_VID_XFA);
  switch ((VID_DFP & 0x3FFF) + 2 * (my_VID_XFA & 0x3FFF))
  {
    case SDRAM_FRAME_BUFFER_1_START/256:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_2_START/256;
      break;
    case SDRAM_FRAME_BUFFER_2_START/256:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_3_START/256;
      break;
    default:
      Stream.next_anchor_frame_buffer = SDRAM_FRAME_BUFFER_1_START/256;
      break;
  }
  Stream.next_B_frame_buffer = SDRAM_FRAME_BUFFER_4_START/256;
  Stream.video_PTS_write_ptr = 0;
  Stream.video_PTS_read_ptr = 0;
  Stream.video_presentation_error = pe_acceptable; /* don't do lipsync until we've found two consecutive errors */
  Stream.video_PTS_error.msb = 0;
  Stream.video_PTS_error.lsw = 0;
  Stream.protected_horizontal_size = Stream.protected_vertical_size = 0;
  Stream.protected_aspect_ratio = 0x10000;
  Stream.active_area_is_at_top = false;
  Stream.active_horizontal_size = Stream.active_vertical_size = 0;
  Stream.active_aspect_ratio = 0x10000;
  Stream.displayed_active_centre_x = Stream.displayed_active_centre_y = 0;
  Stream.displayed_active_width = Stream.displayed_active_height = 0;
  Stream.old_active_horizontal_size = Stream.old_active_vertical_size = 0;
  Stream.old_active_aspect_ratio = 0x10000;
  Stream.old_displayed_active_centre_x = Stream.old_displayed_active_centre_y = 0;
  Stream.old_displayed_active_width = Stream.old_displayed_active_height = 0;
  WRITE_VID_VBT(0);
  if (!Stream.rs_flags.audio_present) Stream.aud_flags.first_header_received = false; /* don't offer audio headers in *VideoInfo */
  
  /* Claim interrupts */
  IRQ_EnableCommonIRQs ();
  IRQ_EnableVideoPrefillIRQs ();
  
  return e;
}

/******	static_VideoStop() *************************************************

Purpose:	Common code between ResetStream and CloseStream
In:		|true| if the currently queueing data should be allowed to play out
Out:		Number of data bytes that were not played

***************************************************************************/

static unsigned int static_VideoStop (bool play_out)
{
  unsigned int discarded_data = 0; /* default if we're playing out, or if there are no queuing packets */
  
  if (play_out)
  {
    /* Play out the old video data, but don't send any more to the 3520 */
    Stream.video.state = stream_closing;
    
    /* During play-out, we don't bother waiting for buffer-full */
    WRITE_VID_VBT(0); /* may trigger an interrupt immediately */
    
    /* Wait until all data is sent to the 3520 */
    MiscAsm_UserModeWait (&Stream.video.packet_list_head);
    
    /* Wait until the 3520 consumes all its data */
    while (((volatile program_element_structure_t *)&Stream)->vid_flags.stalled_while_closing == false);
    
    /* Now we are closed */
    Stream.video.state = stream_closed;
  }
  else
  {
    /* Go directly to closed, do not pass GO, do not collect £200 */
    Stream.video.state = stream_closed;
    while (Stream.video.packet_list_head != NULL)
    {
      discarded_data += Stream.video.packet_list_head->length;
      Stuffing_FreePacket (&Stream.video);
    }
  }
  
  /* Release interrupts */
  IRQ_DisableCommonIRQs ();
  IRQ_DisableVideoIRQs ();
  
  /* Clear closed caption overlays */
  if (!Stream.vid_flags.internal_reset)
  {
    static const char erase_odd_captions [16] =  { 0x14, 0x2c, 0x14, 0x2c,    /* Erase Displayed Memory, captions channel 1 */
                                                   0x1c, 0x2c, 0x1c, 0x2c,    /* Erase Displayed Memory, captions channel 2 */
                                                   0x14, 0x2e, 0x14, 0x2e,    /* Erase Nondisplayed Memory, captions channel 1 */
                                                   0x1c, 0x2e, 0x1c, 0x2e  }; /* Erase Nondisplayed Memory, captions channel 2 */
    static const char erase_even_captions [16] = { 0x15, 0x2c, 0x15, 0x2c,    /* Erase Displayed Memory, captions channel 1 */
                                                   0x1d, 0x2c, 0x1d, 0x2c,    /* Erase Displayed Memory, captions channel 2 */
                                                   0x15, 0x2e, 0x15, 0x2e,    /* Erase Nondisplayed Memory, captions channel 1 */
                                                   0x1d, 0x2e, 0x1d, 0x2e  }; /* Erase Nondisplayed Memory, captions channel 2 */
    MiscAsm_CallHandler (1, 6 /* odd fields, calculate parity, flush buffer */, erase_odd_captions, 16);
    MiscAsm_CallHandler (2, 7 /* even fields, calculate parity, flush buffer */, erase_even_captions, 16);
  }
  
  return discarded_data;
}

/******	static_CompleteScalingTypeParameters() *****************************

Purpose:	Fills in missing ScalingType parameters from NVRAM
In:		Whether to recache NVRAM settings

***************************************************************************/

static void static_CompleteScalingTypeParameters (bool recache)
{
  static TV_aspect shape;
  static bool use_switching;
  static viewing_mode mode;
  
  if (recache)
  {
    shape = tv_regular;
    use_switching = false;
    mode = vm_zoom;
    _swix (NVRAM_Read, _INR(0,2), "TVAspectRatio", &shape, 0);
    _swix (NVRAM_Read, _INR(0,2), "WideScreenSignalling", &use_switching, 0);
    _swix (NVRAM_Read, _INR(0,2), "TVViewingMode", &mode, 0);
  }
  
  if (Stream.video_parms.scaling_type.type == st_free)
  {
    if (!Stream.video_parms.scaling_type.param.free.valid_ratio)
    {
      Stream.video_parms.scaling_type.param.free.ratio = shape;
      Stream.video_parms.scaling_type.param.free.valid_ratio = true;
    }
    if (!Stream.video_parms.scaling_type.param.free.valid_WSS)
    {
      Stream.video_parms.scaling_type.param.free.use_WSS = use_switching;
      Stream.video_parms.scaling_type.param.free.use_SCART_pin_8 = use_switching;
      Stream.video_parms.scaling_type.param.free.valid_WSS = true;
    }
    if (!Stream.video_parms.scaling_type.param.free.valid_preference)
    {
      Stream.video_parms.scaling_type.param.free.preference = mode;
      Stream.video_parms.scaling_type.param.free.valid_preference = true;
    }
  }
}

/******	static_CheckHandle() ***********************************************

Purpose:	Checks validity of an video stream handle
In:		Handle to check
Out:		Pointer to error block

***************************************************************************/

static _kernel_oserror *static_CheckHandle (stream_handle_t vsh)
{
  if (vsh == (stream_handle_t) &Stream)
  {
    return NULL;
  }
  else
  {
    char handle_string [12];
    sprintf (handle_string, "%p", vsh);
    return Mess_GenerateError ("Err_BadVideoHandle", errno_BAD_VIDEO_HANDLE, 1, handle_string);
  }
}
