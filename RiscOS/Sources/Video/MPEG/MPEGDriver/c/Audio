/******	Audio.c ************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Audio SWI handling

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
01/10/1999	BJGA	Created
23/11/1999	BJGA	Return values from SWIStats() initialised, so VSP modules no longer crash
09/12/1999	BJGA	Initial attempt at audio support:
			Audio_SWIOpenStream, Audio_SWIFullPackets, Audio_SWICloseStream, Audio_SWIPlay,
			Audio_SWISetSpeed, Audio_SWIResetStream, static_AudioStart and static_AudioStop
			based upon their c.Video equivalents; static_ReadBufferVariable is all-new

***************************************************************************/

/************/
/* Includes */
/************/

#include "kernel.h"
#include "swis.h"

#include "DebugLib/DebugLib.h"

#include "Audio.h"
#include "Defs.h"
#include "IRQ.h"
#include "MiscAsm.h"
#include "Module.h"
#include "Registers.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static unsigned int static_ReadBufferVariable (const char *name, unsigned int default_value);
static _kernel_oserror *static_AudioStart (void);
static unsigned int static_AudioStop (bool play_out);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#define DEFAULT_AUDIO_BUFFER_PREFILL         (16*1024)
#define DEFAULT_AUDIO_BUFFER_LOW_WATER_MARK  (8*1024)
#define DEFAULT_AUDIO_BUFFER_HIGH_WATER_MARK (24*1024)

/********************/
/* Public functions */
/********************/

/******	Audio_SWIOpenStream() **********************************************

Purpose:	Handles MPEGAudio_OpenStream
In:		Control stream flags; control stream handle; audio parameters
		structure; address to write audio stream handle into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIOpenStream (stream_flags_t *flags, control_stream_handle_t csh, audio_parameters_structure_t *aps, stream_handle_t *return_ash)
{
  _kernel_oserror *e = NULL;
  bool old_video_present_flag;
  dprintf (("Audio", "SWIOpenStream\n"));
  
  /* Cache StreamFlags (other than our copies of the video_present and audio_present flags), ControlStreamHandle and AudioParametersStructure */
  old_video_present_flag = Stream.s_flags.video_present;
  Stream.s_flags = *flags;
  Stream.s_flags.audio_present = true;
  Stream.s_flags.video_present = old_video_present_flag;
  Stream.csh = csh;
  Stream.audio_parms = *aps;
  
  /* Initialise various variables */
  Stream.rs_flags.video_present = Stream.s_flags.video_present;
  Stream.rs_flags.audio_present = Stream.s_flags.audio_present;
  Stream.rs_flags.trick_play_mode = false;
  Stream.audio.since_open.amount_received = 0;
  Stream.audio.since_open.amount_sent = 0;
  Stream.audio.since_open.slows = 0;
  Stream.audio.since_open.fasts = 0;
  Stream.audio.since_open.stalls = 0;
  Stream.audio.since_open.underruns = 0;
  Stream.audio.since_open.picture_decode_errors = 0;
  Stream.audio.since_open.severe_errors = 0;
  Stream.audio.since_open.pipeline_errors = 0;
  Stream.audio_buffer_prefill = static_ReadBufferVariable ("MPEG2$AudioBufferPreFill", DEFAULT_AUDIO_BUFFER_PREFILL);
  Stream.audio_buffer_low_water_mark = static_ReadBufferVariable ("MPEG2$AudioBufferLowWaterMark", DEFAULT_AUDIO_BUFFER_LOW_WATER_MARK);
  Stream.audio_buffer_high_water_mark = static_ReadBufferVariable ("MPEG2$AudioBufferHighWaterMark", DEFAULT_AUDIO_BUFFER_HIGH_WATER_MARK);
  dprintf (("Audio", "SWIOpenStream: prefill = %d, LWM = %d, HWM = %d bytes\n", Stream.audio_buffer_prefill, Stream.audio_buffer_low_water_mark, Stream.audio_buffer_high_water_mark));
  
  /* Initialise the new stream */
  e = static_AudioStart ();
  
  if (!e)
  {
    /* Return a pointer to Stream as the audio stream handle */
    *return_ash = (stream_handle_t) &Stream;
  }
  return e;
}

/******	Audio_SWIFullPackets() *********************************************

Purpose:	Handles MPEGAudio_FullPackets
In:		Flags; audio stream handle; list of bitstream packets
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIFullPackets (unsigned int flags, stream_handle_t ash, bitstream_packet_t *packets)
{
  _kernel_oserror *e = NULL;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  IGNORE(flags);
  IGNORE(ash);
  
  /* If we're just starting, discard bitstream packets until the beginning of the first PES packet */
  while (Stream.audio.prefill_state == ps_searching_for_first_PES_header && packets != NULL)
  {
    if (packets->mpeg_start == true)
    {
      Stream.audio.prefill_state = ps_initialising;
      dprintf (("Audio", "SWIFullPackets: audio.prefill_state = initialising\n"));
    }
    else
    {
      dprintf (("Audio", "SWIFullPackets: discarding partial packet\n"));
      packets = MiscAsm_FreePacket (packets);
      /* Note that the rest of the function can cope fine if this sets |packets| to NULL */      
    }
  }
  
  /* Disable IRQs for the rest of this SWI */
  if (irqs_were_enabled) _kernel_irqs_off ();

  /* If packet list is empty, point list head at the first new packet, otherwise add it to the end */
  if (Stream.audio.packet_list_tail == NULL)
  {
    Stream.audio.packet_list_head = packets;
  }
  else
  {
    Stream.audio.packet_list_tail->link = packets;
  }
  
  /* Step along the list of new packets */
  while (packets != NULL)
  {
    /* Add the length of each bitstream packet to the amnount we've received */
    Stream.audio.since_open.amount_received += packets->length;
    Stream.audio.since_reset.amount_received += packets->length;
    
    /* Update list tail pointer */
    Stream.audio.packet_list_tail = packets;
    
    /* Move on to next packet */
    packets = packets->link;
  }
  
  /* Restore IRQ state */
  if (irqs_were_enabled) _kernel_irqs_on ();
  
  return e;
}

/******	Audio_SWICloseStream() *********************************************

Purpose:	Handles MPEGAudio_CloseStream
In:		Flags; audio stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWICloseStream (unsigned int flags, stream_handle_t ash)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  dprintf (("Audio", "SWICloseStream\n"));
  
  /* Stop playing the old stream, only playing out the old data if we were playing at normal speed */
  static_AudioStop (Stream.audio.speed_indicator == 1 && Stream.audio.state == stream_open);
  return e;
}

/******	Audio_SWIPlay() ****************************************************

Purpose:	Handles MPEGAudio_Play
In:		Flags; audio stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIPlay (unsigned int flags, stream_handle_t ash)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  dprintf (("Audio", "SWIPlay\n"));
  
  e = IRQ_EnableAudioIRQs ();
  
  return e;
}

/******	Audio_SWISetSpeed() ************************************************

Purpose:	Handles MPEGAudio_SetSpeed
In:		Flags; audio stream handle;
		speed (0 => pause, 1 => normal, 2-16 => 1/2 - 1/16th speed)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWISetSpeed (unsigned int flags, stream_handle_t ash, unsigned int speed)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  dprintf (("Audio", "SWISetSpeed\n"));
  Stream.audio.speed_indicator = speed;
  return e;
}

/******	Audio_SWIResetStream() *********************************************

Purpose:	Handles MPEGAudio_ResetStream
In:		ResetStream flags; audio stream handle;
		address to write discarded data count into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIResetStream (reset_stream_flags_t *flags, stream_handle_t ash, unsigned int *return_discarded_data_size)
{
  _kernel_oserror *e = NULL;
  IGNORE(ash);
  dprintf (("Audio", "SWIResetStream\n"));
  
  /* Cache ResetStreamFlags */
  Stream.rs_flags = *flags;
  
  /* Read audio buffer fullnesses */
  if (Stream.discarded_audio_bit_buffer_data == -1)
  {
    *return_discarded_data_size = (VID_ABL & 0x3FFF) * 256; /* 3520 rounds buffer fullness to 256 byte boundaries */
  }
  else /* 3520 has already been reset, so we have to rely on the value cached earlier */
  {
    *return_discarded_data_size = Stream.discarded_audio_bit_buffer_data;
  }
  
  /* Stop playing the old stream immediately */
  *return_discarded_data_size += static_AudioStop (false);
  
  /* Initialise the new stream */
  e = static_AudioStart ();
  return e;
}

/******	Audio_SWIMuteSound() ***********************************************

Purpose:	Handles MPEGAudio_MuteSound
In:		Flags (bit 0 set => mute); audio stream handle
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIMuteSound (unsigned int flags, stream_handle_t ash)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  return e;
}

/******	Audio_SWISoundVolume() *********************************************

Purpose:	Handles MPEGAudio_SoundVolume
In:		Flags; audio stream handle; new volume (0 => mute,
		1-256 => .5 dB ramp up to 0 dB, -1 => just read old volume);
		address to write old volume into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWISoundVolume (unsigned int flags, stream_handle_t ash, int volume, int *return_old_volume)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  IGNORE(volume);
  IGNORE(return_old_volume);
  return e;
}

/******	Audio_SWIStats() ***************************************************

Purpose:	Handles MPEGAudio_Stats
In:		Flags; audio stream handle; pointer to tags list; buffer to
		write ino (pointer/size); address to write updated buffer
		pointer into; address to write space remaining into (may be <0)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWIStats (unsigned int flags, stream_handle_t ash, unsigned int *tags, void *buffer, int buffer_size, void **return_pointer, int *return_buffer_remaining)
{
  _kernel_oserror *e = NULL;
  IGNORE(flags);
  IGNORE(ash);
  IGNORE(tags);
  *return_pointer = buffer;
  *return_buffer_remaining = buffer_size;
  return e;
}

/******	Audio_SWISetAudioParameters0() *************************************

Purpose:	Handles MPEGAudio_SetAudioParameters 0
In:		Audio stream handle; new mute-on-error state (or -1 just
		to read old state); address to write old state into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWISetAudioParameters0 (stream_handle_t ash, int new_state, int *return_old_state)
{
  _kernel_oserror *e = NULL;
  IGNORE(ash);
  IGNORE(new_state);
  IGNORE(return_old_state);
  return e;
}

/******	Audio_SWISetAudioParameters1() *************************************

Purpose:	Handles MPEGAudio_SetAudioParameters 1
In:		Audio stream handle; new dual-channel state (or -1 just
		to read old state); address to write old dual-channel state
		into; address to write current channel type into
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *Audio_SWISetAudioParameters1 (stream_handle_t ash, dual_channel_specifier new_state, dual_channel_specifier *return_old_state, audio_channel_type *return_channel_type)
{
  _kernel_oserror *e = NULL;
  IGNORE(ash);
  IGNORE(new_state);
  IGNORE(return_old_state);
  IGNORE(return_channel_type);
  return e;
}

/*********************/
/* Private functions */
/*********************/

/******	static_ReadBufferVariable() ****************************************

Purpose:	Attempts to read one of the MPEG2$AudioBuffer system
		variables, and returns the defaulkt value if it can't
In:		System variable name, default value
Out:		Value to use

***************************************************************************/

static unsigned int static_ReadBufferVariable (const char *name, unsigned int default_value)
{
  _kernel_oserror *e;
  char variable_value_buffer [64];
  unsigned int variable_value_length;
  unsigned int result;
  
  e = _swix (OS_ReadVarVal, _INR(0,4)|_OUT(2), name, variable_value_buffer, sizeof variable_value_buffer, 0, 3, &variable_value_length);
  if (!e)
  {
    * (variable_value_buffer + variable_value_length) = '\0'; /* terminate string */
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUT(2), 0, variable_value_buffer, &result);
  }
  if (e)
  {
    result = default_value;
  }
  return result;
}

/******	static_AudioStart() ************************************************

Purpose:	Common code between OpenStream and ResetStream
Out:		Pointer to error block

***************************************************************************/

static _kernel_oserror *static_AudioStart (void)
{
  _kernel_oserror *e = NULL;
  
  /* Perform a soft reset on the 3520 */
  STi3520L_SoftReset (false, true);
  
  /* Initialise various variables */
  Stream.audio.state = stream_prefilling;
  Stream.audio.prefill_state = ps_searching_for_first_PES_header;
  Stream.audio.speed_indicator = 1;
  Stream.audio.packet_list_head = NULL;
  Stream.audio.packet_list_tail = NULL;
  Stream.audio.since_reset.amount_received = 0;
  Stream.audio.since_reset.amount_sent = 0;
  Stream.audio.since_reset.slows = 0;
  Stream.audio.since_reset.fasts = 0;
  Stream.audio.since_reset.stalls = 0;
  Stream.audio.since_reset.underruns = 0;
  Stream.audio.since_reset.picture_decode_errors = 0;
  Stream.audio.since_reset.severe_errors = 0;
  Stream.audio.since_reset.pipeline_errors = 0;
  Stream.discarded_audio_bit_buffer_data = -1; /* flag that VID_ABL should be read on the next Audio_ResetStream */
  
  /* Claim interrupts */
  IRQ_EnableCommonIRQs ();
  IRQ_EnableAudioPrefillIRQs ();
  
  return e;
}

/******	static_AudioStop() *************************************************

Purpose:	Common code between ResetStream and CloseStream
In:		|true| if the currently queueing data should be allowed to play out
Out:		Number of data bytes that were not played

***************************************************************************/

static unsigned int static_AudioStop (bool play_out)
{
  unsigned int discarded_data = 0; /* default if we're playing out, or if there are no queuing packets */
  
  if (play_out)
  {
    /* Play out the old audio data, but don't send any more to the 3520 */
    Stream.audio.state = stream_closing;
    
    /* Wait until all data is sent to the 3520 */
    MiscAsm_UserModeWait (&Stream.audio.packet_list_head);
    
    /* Wait until the 3520 consumes all its data */
    while ((VID_ABL & 0x3FFF) > 0);
    
    /* Now we are closed */
    Stream.audio.state = stream_closed;
  }
  else
  {
    /* Go directly to closed, do not pass GO, do not collect £200 */
    Stream.audio.state = stream_closed;
    while (Stream.audio.packet_list_head != NULL)
    {
      discarded_data += Stream.audio.packet_list_head->length;
      Stuffing_FreePacket (&Stream.audio);
    }
  }
  
  /* Release interrupts */
  IRQ_DisableCommonIRQs ();
  IRQ_DisableAudioIRQs ();
  
  return discarded_data;
}
