/******	Module.c ***********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Main relocatable module entry points

Copyright 1999-2000 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
10/09/1999	BJGA	Created
07/10/1999	BJGA	Initialises Stream and Module_PrivateWord
22/10/1999	BJGA	API updated in line with issue 2 specification
22/10/1999	BJGA	Now uses RAM_MODULE switch rather than ROM_MODULE to
			switch ResourceFS code - since debug and McCabe builds
			will be softloaded, this makes the makefile simpler
08/11/1999	BJGA	Added DebugLib support;
			added *Read3520 and *Write3520
13/12/1999	BJGA	Now initialises WSS pattern on module init;
			module now refuses to die if a stream is open
24/01/2000	BJGA	Only calls video/audio stuffing if the relevant stream is open
26/01/2000	BJGA	No longer fails initialisation if MPEGTransport uninitialised;
			split video and audio IRQ handlers
07/04/2000	BJGA	Exports AudioSpeedIndicatorOffset; added veneers for
			ReadParameters 3 and internal reset
02/05/2000	BJGA	Exports Display525_60 and OriginX/YOffset; added support for
			Service_ModeChange, *AudioInfo and *Configure commands;
			returns internal settings from MPEGVideo_SetVideoParameters 1 and 2
08/05/2000	BJGA	Returns any errors from HardReset on module initialisation;
			all errors returned now use allocated error numbers
26/05/2000	BJGA	Added support for MPEGVideo_GetSprite and *VideoSSave
08/06/2000	BJGA	Corrected handling of PEH OpenStream reason code, so PEH data transfer
			now works as it should have all along!
12/06/2000	BJGA	Added *PacketInfo
23/06/2000	BJGA	No longer initialises MPEGDriver+ in the middle of ROM init
06/07/2000	BJGA	Service_PostInit is now depatched correctly (!); sets video PEH flags
			as in Service.c; added audio PEH; VideoPrefillStiff handler added
			(does an internal reset if the MPEG chip locked up during prefill)
10/08/2000	BJGA	Frees all captoin handler blocks on module finalisation;
			dispatched (De)registerHandler SWIs and SetAudioParameters 2;
			bugfix: SetAudioParameters 0 is passed argument, not its address
29/09/2000	BJGA	Now passes flags word to Service_ServiceMPEGControlStarting()

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "Global/Services.h"
#include "Global/SWIs.h"
#include "Global/RISCOS.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGAudio.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEGVideo.h"

#include "Audio.h"
#include "CLI.h"
#include "Defs.h"
#include "IRQ.h"
#include "Mess.h"
#include "ModHdr.h"
#include "ModHdr2.h"
#include "Module.h"
#include "ResMess.h"
#include "Service.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"
#include "WSS.h"

#include "Debug.h"
#if Debugging==1
#include "DWrite.h"
#include "TrapVect.h"
#endif

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

#if Debugging==1 && DebugProtectMemory==1
extern program_element_structure_t Stream;
#else
program_element_structure_t Stream;
#endif
    /*
     *  Unfortunately, this is a structure not a class, so it forces all items to be global; however
     *  it's the only way to make everything stream-handle-relative. The naming convention is broken
     *  because it's going to be referenced all the time, and Module_Stream feels too long a name...
     */
handler_t *Module_Handlers = NULL; /* head pointer of list of currently-registered handler structs */
int Module_AudioSpeedIndicatorOffset; /* needed by Clk_ConvertSTCtoPCR */
bool Module_Display525_60; /* whether the display is set up NTSC-like or PAL-like */
int Module_OriginXOffset; /* horizontal distance from bottom-left active video to bottom-left ARM video in OS units */
int Module_OriginYOffset; /* vertical       "      "     "     "     "     "    "     "    "   "    "    "  "   "   */
void *Module_PrivateWord; /* so we don't have to worry about passing pw around as a parameter to dozens of functions */
int Module_MessageFD [4] = { 0, 0, 0, 0 };  /* message file descriptor */
bool Module_Dying = false; /* for the use of ModHdr2.s */

/*********************/
/* Private variables */
/*********************/

static bool CallBack_Pending = false; /* is there a CallBack for our init service calls pending? */

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Module_Init() ******************************************************

Purpose:	Module and STi3520L initialisation
In:		Standard args
Out:		Pointer to error block if initialisation failed

***************************************************************************/

extern _kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e = NULL;
#ifndef ROM_MODULE
  bool FileRegistered = false;
  bool SecondaryModuleInitialised = false;
#endif
  bool MessagesOpen = false;
  IGNORE(podule_base);
  IGNORE(cmd_tail);
  
  Module_PrivateWord = pw;
  CallBack_Pending = false;
  
  debug_initialise ("MPEGDriver", "null:", "");
  debug_atexit ();
  debug_set_taskname_prefix (false);
  debug_set_area_level_prefix (true);
  debug_set_area_pad_limit (0);
  debug_set_device (NULL_OUTPUT);
  debug_set_raw_device (NULL_OUTPUT);
  debug_set_trace_device (NULL_OUTPUT);
  
  if (!e)
  {
    
#ifndef ROM_MODULE
    e = _swix (ResourceFS_RegisterFiles, _IN(0), ResMess_ResourcesFiles ());
  }
  if (!e)
  {
    FileRegistered = true;
    
    e = _swix (OS_Module, _INR(0,1), 10 /* insert from memory */, ModHdr2);
  }
  if (!e)
  {
    SecondaryModuleInitialised = true;
#endif
    
    e = _swix (MessageTrans_OpenFile, _INR(0,2), &Module_MessageFD, "Resources:$.Resources.MPEGDriver.Messages", 0);
  }
  if (!e)
  {
    MessagesOpen = true;
    
    e = STi3520L_HardReset ();
  }
  if (!e)
  {
    
    e = WSS_Initialise ();
  }
  if (!e)
  {
    
    /* Initialise the program_element_structure_t */
    Stream.csh = NULL_CSH;                        /* signals no streams are open yet */
    Stream.s_flags.video_present = false;
    Stream.s_flags.audio_present = false;
    Stream.video.state = stream_closed;
    Stream.audio.state = stream_closed;
    Stream.discarded_audio_bit_buffer_data = -1;
    /* Cache mode variables as though a mode change had just happened */
    Service_ServiceModeChange ();
    
    /* Attempt to register program element handlers */
    /* Don't complain if it fails, it may be that we're in ROM and MPEGTransport hasn't initialised yet */
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 1 /* MPEG-1 video */, video_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 2 /* MPEG-2 video */, video_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 3 /* MPEG-1 audio */, audio_program_element_handler, pw);
    
    /* Set up Module_AudioSpeedIndicatorOffset (can't be done on static init) */
    Module_AudioSpeedIndicatorOffset = (char *) &Stream.audio.speed_indicator - (char *) &Stream;
    
    /* Create a CallBack to issue our "starting" service calls */
    e = _swix (OS_AddCallBack, _INR(0,1), module_init_callback, pw);
  }
  if (!e)
  {
    
    CallBack_Pending = true;
  }
  
  if (e && MessagesOpen) _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  if (e && SecondaryModuleInitialised) _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
  if (e && FileRegistered) _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
#if Debugging==1 && DebugProtectMemory==1
  TrapVect_InvalidatePages ();
#endif
  return e;
}

/******	Module_ModuleInitCallBack() ****************************************

Purpose:	Issue service calls to inform interested parties that we've started
In:		Standard args
Out:		Pointer to error block if failed

***************************************************************************/

_kernel_oserror *Module_ModuleInitCallBack(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(r);
  IGNORE(pw);
  
  /* Issue the "video unit has started" service call */
  e = _swix (OS_ServiceCall, _INR(0,1), (3<<1) | 1, Service_MPEGControlStarting);
  if (!e)
  {
    /* Issue the "audio unit has started" service call */
    e = _swix (OS_ServiceCall, _INR(0,1), (5<<1) | 1, Service_MPEGControlStarting);
  }
  
  return e;
}

/******	Module_Final() *****************************************************

Purpose:	Module finalisation
In:		Standard args
Out:		Pointer to error block if finalisation failed

***************************************************************************/

extern _kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);
#if Debugging==1 && DebugProtectMemory==1
  TrapVect_RevalidatePages ();
#endif
  
  if (Stream.video.state != stream_closed || Stream.audio.state != stream_closed)
  {
    e = Mess_GenerateError ("Err_CantDie", errno_CANT_DIE, 0);
  }
  else
  {
    handler_t *ptr = Module_Handlers;
    handler_t *next;
    
    if (CallBack_Pending)
    {
      /* If the CallBack is still pending, remove it */
      _swix (OS_RemoveCallBack, _INR(0,1), module_init_callback, pw);
      CallBack_Pending = false;
    }
    else
    {
      /* Issue the "video unit has died" service call */
      _swix (OS_ServiceCall, _INR(0,1), (2<<1) | 1, Service_MPEGControlStarting);
      /* Issue the "audio unit has died" service call */
      _swix (OS_ServiceCall, _INR(0,1), (4<<1) | 1, Service_MPEGControlStarting);
    }
    
    while (ptr != NULL)
    {
      next = ptr->next;
      _swix (OS_Module, _IN(0)|_IN(2), 7 /*ModHandReason_Free*/, ptr);
      ptr = next;
    }
    
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 3, audio_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 2, video_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 1, video_program_element_handler, pw);
    Module_Dying = true; /* flag to MPEGDriver+ that it's OK to die */
    _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
    _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
    _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  }
  return e;
}

/******	Module_Service() ***************************************************

Purpose:	Service call handler
In:		Standard args

***************************************************************************/

extern void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  bool claim = false;
  switch (service_number)
  {
    case Service_PreReset:
      claim = Service_ServicePreReset ();
      break;
    case Service_ModeChange:
      claim = Service_ServiceModeChange ();
      break;
    case Service_PostInit:
      claim = Service_ServicePostInit ();
      break;
    case Service_MPEGControlStarting:
      claim = Service_ServiceMPEGControlStarting (r->r[0], pw);
      break;
  }
  if (claim) r->r[1] = 0;
}

/******	Module_Commands() **************************************************

Purpose:	* command handler
In:		Standard args
Out:		Pointer to error block if command could not be executed

***************************************************************************/

extern _kernel_oserror *Module_Commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(argc);
  IGNORE(pw);
  switch ((int) arg_string)
  {
    case (int) arg_CONFIGURE_SYNTAX:
      switch (cmd_no)
      {
        case CMD_TVAspect:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVA", 0));
          break;
        case CMD_TVWSS:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVW", 0));
          break;
        case CMD_TVViewingMode:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVV", 0));
          break;
      }
      break;
    case (int) arg_STATUS:
      switch (cmd_no)
      {
        case CMD_TVAspect:
          CLI_TVAspect_Status ();
          break;
        case CMD_TVWSS:
          CLI_TVWSS_Status ();
          break;
        case CMD_TVViewingMode:
          CLI_TVViewingMode_Status ();
          break;
      }
      break;
    default:
      switch (cmd_no)
      {
        case CMD_VideoInfo:
          e = CLI_VideoInfo ();
          break;
        case CMD_AudioInfo:
          e = CLI_AudioInfo ();
          break;
        case CMD_PacketInfo:
          e = CLI_PacketInfo ();
          break;
        case CMD_VideoSSave:
          e = CLI_VideoSSave (arg_string);
          break;
        case CMD_Read3520:
          e = CLI_Read3520 (arg_string);
          break;
        case CMD_Write3520:
          e = CLI_Write3520 (arg_string);
          break;
        case CMD_TVAspect:
          e = CLI_TVAspect (arg_string);
          break;
        case CMD_TVWSS:
          e = CLI_TVWSS (arg_string);
          break;
        case CMD_TVViewingMode:
          e = CLI_TVViewingMode (arg_string);
          break;
      }
      break;
  }
  return e;
}

/******	Module_SWI() *******************************************************

Purpose:	SWI handler
In:		Standard args
Out:		Pointer to error block if SWI could not be executed

***************************************************************************/

extern _kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  _kernel_swi_regs rout;
  char reason_string [12];
  IGNORE(pw);
  switch (swi_offset)
  {
    case MPEGVideo_OpenStream - MPEGVideoSWI_Base:
      e = Video_SWIOpenStream (
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (video_parameters_structure_t *) (r->r[2]),
          (stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      break;
    case MPEGVideo_FullPackets - MPEGVideoSWI_Base:
      e = Video_SWIFullPackets (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGVideo_CloseStream - MPEGVideoSWI_Base:
      e = Video_SWICloseStream (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_Play - MPEGVideoSWI_Base:
      e = Video_SWIPlay (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_SetSpeed - MPEGVideoSWI_Base:
      e = Video_SWISetSpeed (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGVideo_CardControl - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 2:
          e = Video_SWICardControl2 (
              (unsigned int) (r->r[1]),
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case 7:
          e = Video_SWICardControl7 (
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_CardControl", reason_string);
          break;
      }
      break;
    case MPEGVideo_ReadParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Video_SWIReadParameters0 (
              (signed int *) &(rout.r[1]),
              (signed int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case 3:
          e = Video_SWIReadParameters3 (
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case 4:
          e = Video_SWIReadParameters4 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        case 5:
          e = Video_SWIReadParameters5 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_ReadParameters", reason_string);
          break;
      }
      break;
    case MPEGVideo_ResetStream - MPEGVideoSWI_Base:
      e = Video_SWIResetStream (
          (reset_stream_flags_t *) &(r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGVideo_Stats - MPEGVideoSWI_Base:
      e = Video_SWIStats (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGVideo_RegisterHandler - MPEGVideoSWI_Base:
      e = Video_SWIRegisterHandler (
          (unsigned int) (r->r[0]),
          (void *) (r->r[1]),
          (void *) (r->r[2])
          );
      break;
    case MPEGVideo_DeregisterHandler - MPEGVideoSWI_Base:
      e = Video_SWIDeregisterHandler (
          (unsigned int) (r->r[0]),
          (void *) (r->r[1]),
          (void *) (r->r[2])
          );
      break;
    case MPEGVideo_SetVideoParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Video_SWISetVideoParameters0 (
              (stream_handle_t) (r->r[1]),
              (scaling_type_block_t *) &(r->r[2])
              );
          break;
        case 1:
          e = Video_SWISetVideoParameters1 (
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2]),
              (unsigned int *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        case 2:
          e = Video_SWISetVideoParameters2 (
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2]),
              (unsigned int *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_SetVideoParameters", reason_string);
          break;
      }
      break;
    case MPEGVideo_GetSprite - MPEGVideoSWI_Base:
      e = Video_SWIGetSprite (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (void *) (r->r[2]),
          (const char *) (r->r[3])
          );
      break;
    case MPEGAudio_OpenStream - MPEGVideoSWI_Base:
      e = Audio_SWIOpenStream (
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (audio_parameters_structure_t *) (r->r[2]),
          (stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      break;
    case MPEGAudio_FullPackets - MPEGVideoSWI_Base:
      e = Audio_SWIFullPackets (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGAudio_CloseStream - MPEGVideoSWI_Base:
      e = Audio_SWICloseStream (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_Play - MPEGVideoSWI_Base:
      e = Audio_SWIPlay (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SetSpeed - MPEGVideoSWI_Base:
      e = Audio_SWISetSpeed (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGAudio_ResetStream - MPEGVideoSWI_Base:
      e = Audio_SWIResetStream (
          (reset_stream_flags_t *) &(r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_MuteSound - MPEGVideoSWI_Base:
      e = Audio_SWIMuteSound (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SoundVolume - MPEGVideoSWI_Base:
      e = Audio_SWISoundVolume (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (int) (r->r[2]),
          (int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_Stats - MPEGVideoSWI_Base:
      e = Audio_SWIStats (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGAudio_SetAudioParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Audio_SWISetAudioParameters0 (
              (stream_handle_t) (r->r[1]),
              (int) (r->r[2]),
              (int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        case 1:
          e = Audio_SWISetAudioParameters1 (
              (stream_handle_t) (r->r[1]),
              (dual_channel_specifier) (r->r[2]),
              (dual_channel_specifier *) &(rout.r[2]),
              (audio_channel_type *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        case 2:
          e = Audio_SWISetAudioParameters2 (
              (stream_handle_t) (r->r[1]),
              (int) (r->r[2]),
              (int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGAudio_SetAudioParameters", reason_string);
          break;
      }
      break;
    default:
      e = error_BAD_SWI;
      break;
  }
  return e;
}

/******	Module_AudioStuffingCallback() *************************************

Purpose:	Callback entry for the use of audio stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_AudioStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_AudioCallback ();
  return NULL;
}

/******	Module_VideoPEH() **************************************************

Purpose:	Video program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_VideoPEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGVideo_OpenStream is still called by MPEGTransport */
      /* However, we still need to return the stream handle here, because MPEGTransport will use it in        */
      /* preference to that returned from MPEGVideo_OpenStream (but only when calling PEH entry points)       */
      r->r[0] = (unsigned int) &Stream;
      break;
    case PEHReason_DataTransfer:
      e = Video_SWIFullPackets(
          (unsigned int) (r->r[1]),
          (stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGVideoCloseStream is still called by MPEGTransport) */
      break;
  }
  return e;
}

/******	Module_AudioPEH() **************************************************

Purpose:	Audio program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_AudioPEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGAudio_OpenStream is still called by MPEGTransport */
      /* However, we still need to return the stream handle here, because MPEGTransport will use it in        */
      /* preference to that returned from MPEGAudio_OpenStream (but only when calling PEH entry points)       */
      r->r[0] = (unsigned int) &Stream;
      break;
    case PEHReason_DataTransfer:
      e = Audio_SWIFullPackets(
          (unsigned int) (r->r[1]),
          (stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGAudioCloseStream is still called by MPEGTransport) */
      break;
  }
  return e;
}

/******	Module_STi3520LVideoIRQHandler() ***********************************

Purpose:	Top-level video IRQ handler entry point
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_STi3520LVideoIRQHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  IRQ_HandleVideoIRQ ();
  return NULL;
}

/******	Module_STi3520LAudioIRQHandler() ***********************************

Purpose:	Top-level audio IRQ handler entry point
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_STi3520LAudioIRQHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  IRQ_HandleAudioIRQ ();
  return NULL;
}

/******	Module_VideoPrefillStiff() *****************************************

Purpose:	CallAfter entry used when MPEG chip jams during prefill
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoPrefillStiff(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  _swix (OS_AddCallBack, _INR(0,1), video_reset_callback, Module_PrivateWord);
  Stream.video.since_open.internal_resets += 1;
  Stream.video.since_reset.internal_resets += 1;
#if Debugging==1 && DebugDecoderErrors==1
  DWrite_Write0("PrefillReset ");
#endif
  return NULL;
}

/******	Module_VideoResetCallback() ****************************************

Purpose:	Callback entry for the use of internal video resets
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoResetCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Video_InternalReset ();
  return NULL;
}

/******	Module_VideoStuffingCallback() *************************************

Purpose:	Callback entry for the use of video stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_VideoCallback ();
  return NULL;
}

/******	Module_TickerVHandler() ********************************************

Purpose:	TickerV entry point, used to timeslice stuffing code
In:		Registers in/out, module private word
Out:		0 to intercept, 1 to pass on

***************************************************************************/

int Module_TickerVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  if (Stream.audio.state != stream_closed)
  {
    Stuffing_StuffAudio ();  /* do audio first, the brain is more responsive to audio glitches */
  }
  if (Stream.video.state != stream_closed)
  {
    Stuffing_StuffVideo ();
  }
  return 1;
}
