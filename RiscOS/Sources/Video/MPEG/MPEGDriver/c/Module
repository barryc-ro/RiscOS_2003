/******	Module.c ***********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Main relocatable module entry points

Copyright 1999-2000 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
10/09/1999	BJGA	Created
07/10/1999	BJGA	Initialises Stream and Module_PrivateWord
22/10/1999	BJGA	API updated in line with issue 2 specification
22/10/1999	BJGA	Now uses RAM_MODULE switch rather than ROM_MODULE to
			switch ResourceFS code - since debug and McCabe builds
			will be softloaded, this makes the makefile simpler
08/11/1999	BJGA	Added DebugLib support;
			added *Read3520 and *Write3520
13/12/1999	BJGA	Now initialises WSS pattern on module init;
			module now refuses to die if a stream is open
24/01/2000	BJGA	Only calls video/audio stuffing if the relevant stream is open
26/01/2000	BJGA	No longer fails initialisation if MPEGTransport uninitialised;
			split video and audio IRQ handlers
07/04/2000	BJGA	Exports AudioSpeedIndicatorOffset; added veneers for
			ReadParameters 3 and internal reset
02/05/2000	BJGA	Exports Display525_60 and OriginX/YOffset; added support for
			Service_ModeChange, *AudioInfo and *Configure commands;
			returns internal settings from MPEGVideo_SetVideoParameters 1 and 2
08/05/2000	BJGA	Returns any errors from HardReset on module initialisation;
			all errors returned now use allocated error numbers
26/05/2000	BJGA	Added support for MPEGVideo_GetSprite and *VideoSSave
08/06/2000	BJGA	Corrected handling of PEH OpenStream reason code, so PEH data transfer
			now works as it should have all along!
12/06/2000	BJGA	Added *PacketInfo
23/06/2000	BJGA	No longer initialises MPEGDriver+ in the middle of ROM init
06/07/2000	BJGA	Service_PostInit is now depatched correctly (!); sets video PEH flags
			as in Service.c; added audio PEH; VideoPrefillStiff handler added
			(does an internal reset if the MPEG chip locked up during prefill)
10/08/2000	BJGA	Frees all captoin handler blocks on module finalisation;
			dispatched (De)registerHandler SWIs and SetAudioParameters 2;
			bugfix: SetAudioParameters 0 is passed argument, not its address
29/09/2000	BJGA	Now passes flags word to Service_ServiceMPEGControlStarting()

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "Global/Services.h"
#include "Global/SWIs.h"
#include "Global/RISCOS.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGAudio.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEGVideo.h"
#include "PRISM/PRISM.h"
#include "NVRAM.h"

#include "AudGeneric.h"
#include "Audio.h"
#include "CLI.h"
#include "Defs.h"
#include "IRQ.h"
#include "Mess.h"
#include "ModHdr.h"
#include "ModHdr2.h"
#include "Module.h"
#include "PCompos.h"
#include "ResMess.h"
#include "Service.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"
#include "WSS.h"
#include "ZoranPara.h"

#include "Debug.h"
#if Debugging==1
#include "DWrite.h"
#include "TrapVect.h"
#endif

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

#if Debugging==1 && DebugProtectMemory==1
extern program_element_structure_t Stream;
#else
program_element_structure_t Stream;
#endif
    /*
     *  Unfortunately, this is a structure not a class, so it forces all items to be global; however
     *  it's the only way to make everything stream-handle-relative. The naming convention is broken
     *  because it's going to be referenced all the time, and Module_Stream feels too long a name...
     */
#ifdef GENERIC
bool Module_UseGenericAudio;
#ifdef BODGEOVS
bool Module_DongleFitted;
#endif
#endif
handler_t *Module_Handlers = NULL; /* head pointer of list of currently-registered handler structs */
int Module_AudioSpeedIndicatorOffset; /* needed by Clk_ConvertSTCtoPCR */
bool Module_Display525_60; /* whether the display is set up NTSC-like or PAL-like */
int Module_OriginXOffset; /* horizontal distance from bottom-left active video to bottom-left ARM video in OS units */
int Module_OriginYOffset; /* vertical       "      "     "     "     "     "    "     "    "   "    "    "  "   "   */
void *Module_PrivateWord; /* so we don't have to worry about passing pw around as a parameter to dozens of functions */
int Module_MessageFD [4] = { 0, 0, 0, 0 };  /* message file descriptor */
bool Module_Dying = false; /* for the use of ModHdr2.s */

/*********************/
/* Private variables */
/*********************/

static bool CallBack_Pending = false; /* is there a CallBack for our init service calls pending? */
static control_stream_handle_t MostRecentControlStreamHandle;
static mpeg_stream_handle_t MostRecentVideoStreamHandle;
static mpeg_stream_handle_t MostRecentAudioStreamHandle;

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Module_Init() ******************************************************

Purpose:	Module and STi3520L initialisation
In:		Standard args
Out:		Pointer to error block if initialisation failed

***************************************************************************/

extern _kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e = NULL;
#ifndef ROM_MODULE
  bool FileRegistered = false;
  bool SecondaryModuleInitialised = false;
#endif
  bool MessagesOpen = false;
#ifdef GENERIC
  bool AudGenericInitialised = false;
  bool VideoInitialised = false;
#endif
  bool VolumeAdjustedForLineMode = false;
  int OriginalVolume = 127;
  IGNORE(podule_base);
  IGNORE(cmd_tail);
  
  Module_PrivateWord = pw;
  CallBack_Pending = false;
  
  debug_initialise ("MPEGDriver", "null:", "");
  debug_atexit ();
  debug_set_taskname_prefix (false);
  debug_set_area_level_prefix (true);
  debug_set_area_pad_limit (0);
  debug_set_device (DADEBUG_OUTPUT);
  debug_set_raw_device (NULL_OUTPUT);
  debug_set_trace_device (NULL_OUTPUT);
  
#if Debugging==1
  DWrite_Init (); /* just in case there's some debug before the first OpenStream */
#endif
  
  if (!e)
  {
    
#ifndef ROM_MODULE
    e = _swix (ResourceFS_RegisterFiles, _IN(0), ResMess_ResourcesFiles ());
  }
  if (!e)
  {
    FileRegistered = true;
    
    e = _swix (OS_Module, _INR(0,1), 10 /* insert from memory */, ModHdr2);
  }
  if (!e)
  {
    SecondaryModuleInitialised = true;
#endif
    
    e = _swix (MessageTrans_OpenFile, _INR(0,2), &Module_MessageFD, "Resources:$.Resources.MPEGDriver.Messages", 0);
  }
  if (!e)
  {
    MessagesOpen = true;
    
#ifdef GENERIC
#ifdef BODGEOVS
    e = AudGeneric_Initialise (&Module_DongleFitted);
    Module_UseGenericAudio = Module_DongleFitted;
#else
    e = AudGeneric_Initialise (&Module_UseGenericAudio);
#endif
  }
  if (!e)
  {
    AudGenericInitialised = true;
    
    e = Video_Initialise ();
  }
  if (!e)
  {
    VideoInitialised = true;
#else
    e = STi3520L_HardReset ();
  }
  if (!e)
  {
    
    e = WSS_Initialise ();
  }
  if (!e)
  {
#endif
    
    int audiomode = -1;
    _swix (NVRAM_Read, _INR(0,2), "DolbyAudioMode", &audiomode, 0);
    if (audiomode == 1)
    {
      _swix (Sound_Volume, _IN(0)|_OUT(0), 0, &OriginalVolume);
      _swix (Sound_Volume, _IN(0), (OriginalVolume > 29) ? OriginalVolume - 29 : 1);
      VolumeAdjustedForLineMode = true;
    }
    
    /* Initialise the program_element_structure_t */
    Stream.csh = NULL_CSH;                        /* signals no streams are open yet */
#ifndef GENERIC
    Stream.s_flags.video_present = false;
    Stream.s_flags.audio_present = false;
#endif
    Stream.video.state = stream_closed;
    Stream.audio.state = stream_closed;
    Stream.discarded_audio_bit_buffer_data = -1;
    /* Cache mode variables as though a mode change had just happened */
    Service_ServiceModeChange ();
    
#ifdef GENERIC
    if (Module_UseGenericAudio)
    {
      /* Register our PRISM components */
      PCompos_ModuleInitialising ();
    }
#endif
    
    /* Attempt to register program element handlers */
    /* Don't complain if it fails, it may be that we're in ROM and MPEGTransport hasn't initialised yet */
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 1 /* MPEG-1 video */, video_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 2 /* MPEG-2 video */, video_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 3 /* MPEG-1 audio */, audio_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 4 /* MPEG-2 audio (sic) */, audio_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 0x81 /* AC-3 audio */, ac3_program_element_handler, pw);
    _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3),
        (2 << PEHFlags_RequiredFlag_Shift) | PEHFlags_StreamIdentifiedByStreamId | PEHFlags_StreamIdentifiedByPID,
        0x80 /* AC-3 audio track 0 */, ac3_dvd_program_element_handler, pw);
    
    /* Set up Module_AudioSpeedIndicatorOffset (can't be done on static init) */
    Module_AudioSpeedIndicatorOffset = (char *) &Stream.audio.speed_indicator - (char *) &Stream;
    
    /* Create a CallBack to issue our "starting" service calls */
    e = _swix (OS_AddCallBack, _INR(0,1), module_init_callback, pw);
  }
  if (!e)
  {
    
    CallBack_Pending = true;
  }
  
  if (e && VolumeAdjustedForLineMode) _swix (Sound_Volume, _IN(0), OriginalVolume);
#ifdef GENERIC
  if (e && Module_UseGenericAudio) PCompos_MPEGDriverDying ();
  if (e && VideoInitialised) Video_Finalise ();
  if (e && AudGenericInitialised) AudGeneric_Finalise ();
#endif
  if (e && MessagesOpen) _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  if (e && SecondaryModuleInitialised) _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
  if (e && FileRegistered) _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
#if Debugging==1 && DebugProtectMemory==1
  TrapVect_InvalidatePages ();
#endif
  return e;
}

/******	Module_ModuleInitCallBack() ****************************************

Purpose:	Issue service calls to inform interested parties that we've started
In:		Standard args
Out:		Pointer to error block if failed

***************************************************************************/

_kernel_oserror *Module_ModuleInitCallBack(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  
  /* Issue the "video unit has started" service call */
  _swix (OS_ServiceCall, _INR(0,1), (3<<1) | 1, Service_MPEGControlStarting);
  
  /* Issue the "audio unit has started" service call */
  _swix (OS_ServiceCall, _INR(0,1), (5<<1) | 1, Service_MPEGControlStarting);
  
#ifdef GENERIC
  if (Module_UseGenericAudio)
  {
    /* Issue PRISM component starting service calls, and try to register with PRISM */
    PCompos_MPEGDriverInitialised ();
  }
#endif
  
  return NULL;
}

/******	Module_Final() *****************************************************

Purpose:	Module finalisation
In:		Standard args
Out:		Pointer to error block if finalisation failed

***************************************************************************/

extern _kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);
#if Debugging==1 && DebugProtectMemory==1
  TrapVect_RevalidatePages ();
#endif
  
  if (Stream.video.state != stream_closed || Stream.audio.state != stream_closed)
  {
    e = Mess_GenerateError ("Err_CantDie", errno_CANT_DIE, 0);
  }
  else
  {
    handler_t *ptr = Module_Handlers;
    handler_t *next;
    
    if (CallBack_Pending)
    {
      /* If the CallBack is still pending, remove it */
      _swix (OS_RemoveCallBack, _INR(0,1), module_init_callback, pw);
      CallBack_Pending = false;
    }
    else
    {
      /* Issue the "video unit has died" service call */
      _swix (OS_ServiceCall, _INR(0,1), (2<<1) | 1, Service_MPEGControlStarting);
      /* Issue the "audio unit has died" service call */
      _swix (OS_ServiceCall, _INR(0,1), (4<<1) | 1, Service_MPEGControlStarting);
    }
    
    while (ptr != NULL)
    {
      next = ptr->next;
      _swix (OS_Module, _IN(0)|_IN(2), 7 /*ModHandReason_Free*/, ptr);
      ptr = next;
    }
    
#ifdef GENERIC
#ifdef BODGEOVS
    if (Module_DongleFitted)
#else
    if (Module_UseGenericAudio)
#endif
    {
      Video_Finalise ();
      AudGeneric_Finalise ();
      PCompos_MPEGDriverDying ();
    }
#endif
    
    int audiomode = -1;
    _swix (NVRAM_Read, _INR(0,2), "DolbyAudioMode", &audiomode, 0);
    if (audiomode == 1)
    {
      int OriginalVolume = 127;
      _swix (Sound_Volume, _IN(0)|_OUT(0), 0, &OriginalVolume);
      _swix (Sound_Volume, _IN(0), (OriginalVolume < 127-29) ? OriginalVolume + 29 : 127);
    }
    
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        (2 << PEHFlags_RequiredFlag_Shift) | PEHFlags_StreamIdentifiedByStreamId | PEHFlags_StreamIdentifiedByPID,
        0x80, ac3_dvd_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 0x81, ac3_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 4, audio_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        2 << PEHFlags_RequiredFlag_Shift, 3, audio_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 2, video_program_element_handler, pw);
    _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3),
        1 << PEHFlags_RequiredFlag_Shift, 1, video_program_element_handler, pw);
    Module_Dying = true; /* flag to MPEGDriver+ that it's OK to die */
    _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
    _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
    _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  }
  return e;
}

/******	Module_Service() ***************************************************

Purpose:	Service call handler
In:		Standard args

***************************************************************************/

extern void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  bool claim = false;
  switch (service_number)
  {
    case Service_PreReset:
      claim = Service_ServicePreReset ();
      break;
    case Service_ModeChange:
      claim = Service_ServiceModeChange ();
      break;
    case Service_PostInit:
      claim = Service_ServicePostInit ();
      break;
    case Service_MPEGControlStarting:
      claim = Service_ServiceMPEGControlStarting (r->r[0], pw);
      break;
    case Service_PRISM_Core:
#ifdef GENERIC
#ifdef BODGEOVS
      if (Module_DongleFitted && r->r[0] == PRISMModuleStarted && r->r[3] == PRISM_PRISMID)
#else
      if (Module_UseGenericAudio && r->r[0] == PRISMModuleStarted && r->r[3] == PRISM_PRISMID)
#endif
      {
        PCompos_ModuleInitialising ();
      }
#endif
      break;
  }
  if (claim) r->r[1] = 0;
}

/******	Module_Commands() **************************************************

Purpose:	* command handler
In:		Standard args
Out:		Pointer to error block if command could not be executed

***************************************************************************/

extern _kernel_oserror *Module_Commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(argc);
  IGNORE(pw);
  switch ((int) arg_string)
  {
    case (int) arg_CONFIGURE_SYNTAX:
      switch (cmd_no)
      {
        case CMD_TVAspect:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVA", 0));
          break;
        case CMD_TVWSS:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVW", 0));
          break;
        case CMD_TVViewingMode:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDTVV", 0));
          break;
        case CMD_SPDIF:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDSPD", 0));
          break;
        case CMD_DolbyAudioMode:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CMPDDAM", 0));
          break;
      }
      break;
    case (int) arg_STATUS:
      switch (cmd_no)
      {
        case CMD_TVAspect:
          CLI_TVAspect_Status ();
          break;
        case CMD_TVWSS:
          CLI_TVWSS_Status ();
          break;
        case CMD_TVViewingMode:
          CLI_TVViewingMode_Status ();
          break;
        case CMD_SPDIF:
          CLI_SPDIF_Status ();
          break;
        case CMD_DolbyAudioMode:
          CLI_DolbyAudioMode_Status ();
          break;
      }
      break;
    default:
      switch (cmd_no)
      {
        case CMD_VideoInfo:
          e = CLI_VideoInfo ();
          break;
        case CMD_AudioInfo:
#ifdef GENERIC
          if (Module_UseGenericAudio)
            e = AudGeneric_CLIAudioInfo();
          else
#endif
            e = CLI_AudioInfo ();
          break;
        case CMD_PacketInfo:
          e = CLI_PacketInfo ();
          break;
        case CMD_VideoSSave:
          e = CLI_VideoSSave (arg_string);
          break;
        case CMD_Read3520:
          e = CLI_Read3520 (arg_string);
          break;
        case CMD_Write3520:
          e = CLI_Write3520 (arg_string);
          break;
#ifdef GENERIC
        case CMD_ZPeek:
          e = ZoranPara_Peek (arg_string);
          break;
        case CMD_ZPoke:
          e = ZoranPara_Poke (arg_string);
          break;
#endif
        case CMD_TVAspect:
          e = CLI_TVAspect (arg_string);
          break;
        case CMD_TVWSS:
          e = CLI_TVWSS (arg_string);
          break;
        case CMD_TVViewingMode:
          e = CLI_TVViewingMode (arg_string);
          break;
        case CMD_SPDIF:
          e = CLI_SPDIF (arg_string);
          break;
        case CMD_DolbyAudioMode:
          e = CLI_DolbyAudioMode (arg_string);
          break;
      }
      break;
  }
  return e;
}

/******	Module_SWI() *******************************************************

Purpose:	SWI handler
In:		Standard args
Out:		Pointer to error block if SWI could not be executed

***************************************************************************/

extern _kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  _kernel_swi_regs rout;
  char reason_string [12];
#ifdef GENERIC
  _kernel_oserror *(*fn)();
#endif
  IGNORE(pw);
  switch (swi_offset)
  {
    case MPEGVideo_OpenStream - MPEGVideoSWI_Base:
      e = Video_SWIOpenStream (
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (video_parameters_structure_t *) (r->r[2]),
          (mpeg_stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      MostRecentVideoStreamHandle = (mpeg_stream_handle_t) r->r[0];
      MostRecentControlStreamHandle = (control_stream_handle_t) r->r[1];
      break;
    case MPEGVideo_FullPackets - MPEGVideoSWI_Base:
      e = Video_SWIFullPackets (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGVideo_CloseStream - MPEGVideoSWI_Base:
      e = Video_SWICloseStream (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_Play - MPEGVideoSWI_Base:
      e = Video_SWIPlay (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_SetSpeed - MPEGVideoSWI_Base:
      e = Video_SWISetSpeed (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGVideo_CardControl - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 2:
          e = Video_SWICardControl2 (
              (unsigned int) (r->r[1]),
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case 7:
          e = Video_SWICardControl7 (
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_CardControl", reason_string);
          break;
      }
      break;
    case MPEGVideo_ReadParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case ReadParametersReason_TimeCode:
        case ReadParametersReason_TimeCode|ReadParametersReason_HandleProvided:
          e = Video_SWIReadParameters0 (
              (signed int *) &(rout.r[1]),
              (signed int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case ReadParametersReason_ReadSTC:
        case ReadParametersReason_ReadSTC|ReadParametersReason_HandleProvided:
          e = Video_SWIReadParameters3 (
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case ReadParametersReason_ReadBufferFullness:
        case ReadParametersReason_ReadBufferFullness|ReadParametersReason_HandleProvided:
          e = Video_SWIReadParameters4 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        case ReadParametersReason_CheckDisplayReady:
        case ReadParametersReason_CheckDisplayReady|ReadParametersReason_HandleProvided:
          e = Video_SWIReadParameters5 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_ReadParameters", reason_string);
          break;
      }
      break;
    case MPEGVideo_ResetStream - MPEGVideoSWI_Base:
      e = Video_SWIResetStream (
          (reset_stream_flags_t *) &(r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGVideo_Stats - MPEGVideoSWI_Base:
      e = Video_SWIStats (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGVideo_RegisterHandler - MPEGVideoSWI_Base:
      e = Video_SWIRegisterHandler (
          (unsigned int) (r->r[0]),
          (void *) (r->r[1]),
          (void *) (r->r[2])
          );
      break;
    case MPEGVideo_DeregisterHandler - MPEGVideoSWI_Base:
      e = Video_SWIDeregisterHandler (
          (unsigned int) (r->r[0]),
          (void *) (r->r[1]),
          (void *) (r->r[2])
          );
      break;
    case MPEGVideo_SetVideoParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Video_SWISetVideoParameters0 (
              (mpeg_stream_handle_t) (r->r[1]),
              (scaling_type_block_t *) &(r->r[2])
              );
          break;
        case 1:
          e = Video_SWISetVideoParameters1 (
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2]),
              (unsigned int *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        case 2:
          e = Video_SWISetVideoParameters2 (
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2]),
              (unsigned int *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGVideo_SetVideoParameters", reason_string);
          break;
      }
      break;
    case MPEGVideo_GetSprite - MPEGVideoSWI_Base:
      e = Video_SWIGetSprite (
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (void *) (r->r[2]),
          (const char *) (r->r[3])
          );
      break;
    case MPEGAudio_OpenStream - MPEGVideoSWI_Base:
#ifdef GENERIC
#ifdef BODGEOVS
      Module_UseGenericAudio = (Module_DongleFitted && (r->r[0] & (1<<10))==0);
#endif
      if (Module_UseGenericAudio) fn = AudGeneric_SWIOpenStream; else fn = Audio_SWIOpenStream;
      e = fn (
#else
      e = Audio_SWIOpenStream (
#endif
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (audio_parameters_structure_t *) (r->r[2]),
          (mpeg_stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      MostRecentAudioStreamHandle = (mpeg_stream_handle_t) r->r[0];
      MostRecentControlStreamHandle = (control_stream_handle_t) r->r[1];
      break;
    case MPEGAudio_FullPackets - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIFullPackets; else fn = Audio_SWIFullPackets;
      e = fn (
#else
      e = Audio_SWIFullPackets (
#endif
          0,
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGAudio_CloseStream - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWICloseStream; else fn = Audio_SWICloseStream;
      e = fn (
#else
      e = Audio_SWICloseStream (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_Play - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIPlay; else fn = Audio_SWIPlay;
      e = fn (
#else
      e = Audio_SWIPlay (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SetSpeed - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWISetSpeed; else fn = Audio_SWISetSpeed;
      e = fn (
#else
      e = Audio_SWISetSpeed (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGAudio_ResetStream - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIResetStream; else fn = Audio_SWIResetStream;
      e = fn (
#else
      e = Audio_SWIResetStream (
#endif
          (reset_stream_flags_t *) &(r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_MuteSound - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIMuteSound; else fn = Audio_SWIMuteSound;
      e = fn (
#else
      e = Audio_SWIMuteSound (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SoundVolume - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWISoundVolume; else fn = Audio_SWISoundVolume;
      e = fn (
#else
      e = Audio_SWISoundVolume (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (int) (r->r[2]),
          (int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_Stats - MPEGVideoSWI_Base:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIStats; else fn = Audio_SWIStats;
      e = fn (
#else
      e = Audio_SWIStats (
#endif
          (unsigned int) (r->r[0]),
          (mpeg_stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGAudio_SetAudioParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
#ifdef GENERIC
          if (Module_UseGenericAudio) fn = AudGeneric_SWISetAudioParameters0; else fn = Audio_SWISetAudioParameters0;
          e = fn (
#else
          e = Audio_SWISetAudioParameters0 (
#endif
              (mpeg_stream_handle_t) (r->r[1]),
              (int) (r->r[2]),
              (int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        case 1:
#ifdef GENERIC
          if (Module_UseGenericAudio) fn = AudGeneric_SWISetAudioParameters1; else fn = Audio_SWISetAudioParameters1;
          e = fn (
#else
          e = Audio_SWISetAudioParameters1 (
#endif
              (mpeg_stream_handle_t) (r->r[1]),
              (dual_channel_specifier) (r->r[2]),
              (dual_channel_specifier *) &(rout.r[2]),
              (audio_channel_type *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        case 2:
#ifdef GENERIC
          if (Module_UseGenericAudio) fn = AudGeneric_SWISetAudioParameters2; else fn = Audio_SWISetAudioParameters2;
          e = fn (
#else
          e = Audio_SWISetAudioParameters2 (
#endif
              (mpeg_stream_handle_t) (r->r[1]),
              (int) (r->r[2]),
              (int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGAudio_SetAudioParameters", reason_string);
          break;
      }
      break;
    case MPEGAudio_ReadParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case AudioReadParametersReason_ReadSTC:
#ifdef GENERIC
          if (Module_UseGenericAudio) fn = AudGeneric_SWIReadParameters3; else fn = Audio_SWIReadParameters3;
          e = fn (
#else
          e = Audio_SWIReadParameters3 (
#endif
              (mpeg_stream_handle_t) (r->r[1]),
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        default:
          sprintf (reason_string, "%d", r->r[0]);
          e = Mess_GenerateError ("Err_InvReason", errno_INV_REASON, 2, "MPEGAudio_ReadParameters", reason_string);
          break;
      }
      break;
    default:
      e = error_BAD_SWI;
      break;
  }
  return e;
}

/******	Module_AudioStuffingCallback() *************************************

Purpose:	Callback entry for the use of audio stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_AudioStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_AudioCallback ();
  return NULL;
}

/******	Module_VideoPEH() **************************************************

Purpose:	Video program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_VideoPEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGVideo_OpenStream is still called by MPEGTransport */
      /* However, we still need to return the stream handle here, because MPEGTransport will use it in        */
      /* preference to that returned from MPEGVideo_OpenStream (but only when calling PEH entry points)       */
      r->r[0] = (unsigned int) MostRecentVideoStreamHandle;
      break;
    case PEHReason_DataTransfer:
      e = Video_SWIFullPackets(
          (unsigned int) (r->r[1]),
          (mpeg_stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGVideoCloseStream is still called by MPEGTransport) */
      break;
  }
  return e;
}

/******	Module_AudioPEH() **************************************************

Purpose:	MPEG audio program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_AudioPEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
#ifdef GENERIC
  _kernel_oserror *(*fn)();
#endif
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGAudio_OpenStream is still called by MPEGControl */
      /* However, we still need to return the stream handle here, because MPEGControl will use it in        */
      /* preference to that returned from MPEGAudio_OpenStream (but only when calling PEH entry points)     */
      r->r[0] = (unsigned int) MostRecentAudioStreamHandle;
      break;
    case PEHReason_DataTransfer:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIFullPackets; else fn = Audio_SWIFullPackets;
      e = fn (
#else
      e = Audio_SWIFullPackets(
#endif
          0,
          (unsigned int) (r->r[1]),
          (mpeg_stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGAudio_CloseStream is still called by MPEGControl) */
      break;
  }
  return e;
}

/******	Module_AC3PEH() ****************************************************

Purpose:	AC-3 audio program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_AC3PEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
#ifdef GENERIC
  _kernel_oserror *(*fn)();
#endif
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGAudio_OpenStream is still called by MPEGControl */
      /* However, we still need to return the stream handle here, because MPEGControl will use it in        */
      /* preference to that returned from MPEGAudio_OpenStream (but only when calling PEH entry points)     */
      r->r[0] = (unsigned int) MostRecentAudioStreamHandle;
      break;
    case PEHReason_DataTransfer:
#ifdef GENERIC
      if (Module_UseGenericAudio) fn = AudGeneric_SWIFullPackets; else fn = Audio_SWIFullPackets;
      e = fn (
#else
      e = Audio_SWIFullPackets(
#endif
          1,
          (unsigned int) (r->r[1]),
          (mpeg_stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGAudio_CloseStream is still called by MPEGControl) */
      break;
  }
  return e;
}

/******	Module_AC3DVDPEH() *************************************************

Purpose:	AC-3 audio program element handler for DVD style packets
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_AC3DVDPEH(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
#ifdef GENERIC
  _kernel_oserror *(*fn)();
#endif
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_OpenStream:
      /* We don't have to take any action here, because MPEGAudio_OpenStream is still called by MPEGControl */
      /* However, we still need to return the stream handle here, because MPEGControl will use it in        */
      /* preference to that returned from MPEGAudio_OpenStream (but only when calling PEH entry points)     */
      r->r[0] = (unsigned int) MostRecentAudioStreamHandle;
      break;
    case PEHReason_DataTransfer:
      {
        bitstream_packet_t *packet = (bitstream_packet_t *) (r->r[3]);
        static int bytes_to_skip_this_PES_packet = 0;
        int bytes_to_skip_this_bitstream_packet;
        if (packet->mpeg_start)
        {
          bytes_to_skip_this_PES_packet = 3;
          /* In a DVD private_stream_1 AC-3 PES packet, there are still 3 more bytes after the */
          /* substream_id that are meaningless to the AC-3 decoder, and which we have to skip: */
          /*   Byte 1: number of sync codes in this packet                                     */
          /*   Byte 2: msb of offset to first sync code in this packet (starts at 1, not 0!)   */
          /*   Byte 3: lsb  "    "    "   "     "    "   "   "     "       "    " "   "  "     */
        }
        bytes_to_skip_this_bitstream_packet = MIN(bytes_to_skip_this_PES_packet, packet->length);
        bytes_to_skip_this_PES_packet -= bytes_to_skip_this_bitstream_packet;
        packet->start += bytes_to_skip_this_bitstream_packet;
        packet->length -= bytes_to_skip_this_bitstream_packet;
        if (packet->mpeg_start && !packet->full_length_unknown)
        {
          packet->full_length -= 3;
        }
        
#ifdef GENERIC
        if (Module_UseGenericAudio) fn = AudGeneric_SWIFullPackets; else fn = Audio_SWIFullPackets;
        e = fn (
#else
        e = Audio_SWIFullPackets(
#endif
            1,
            (unsigned int) (r->r[1]),
            (mpeg_stream_handle_t) (r->r[2]),
            packet
            );
        break;
      }
    default:
      /* do nothing (MPEGAudio_CloseStream is still called by MPEGControl) */
      break;
  }
  return e;
}

/******	Module_STi3520LVideoIRQHandler() ***********************************

Purpose:	Top-level video IRQ handler entry point
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_STi3520LVideoIRQHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  IRQ_HandleVideoIRQ ();
  return NULL;
}

/******	Module_STi3520LAudioIRQHandler() ***********************************

Purpose:	Top-level audio IRQ handler entry point
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_STi3520LAudioIRQHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  IRQ_HandleAudioIRQ ();
  return NULL;
}

/******	Module_VideoPrefillStiff() *****************************************

Purpose:	CallAfter entry used when MPEG chip jams during prefill
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoPrefillStiff(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  _swix (OS_AddCallBack, _INR(0,1), video_reset_callback, Module_PrivateWord);
  Stream.video.since_open.internal_resets += 1;
  Stream.video.since_reset.internal_resets += 1;
#if Debugging==1 && DebugDecoderErrors==1
  DWrite_Write0("PrefillReset ");
#endif
  return NULL;
}

/******	Module_VideoResetCallback() ****************************************

Purpose:	Callback entry for the use of internal video resets
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoResetCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Video_InternalReset ();
  return NULL;
}

/******	Module_VideoStuffingCallback() *************************************

Purpose:	Callback entry for the use of video stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_VideoCallback ();
  return NULL;
}

/******	Module_TickerVHandler() ********************************************

Purpose:	TickerV entry point, used to timeslice stuffing code
In:		Registers in/out, module private word
Out:		0 to intercept, 1 to pass on

***************************************************************************/

int Module_TickerVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
#ifdef GENERIC
  if (!Module_UseGenericAudio)
  {
#endif
    if (Stream.audio.state != stream_closed)
    {
      Stuffing_StuffAudio ();  /* do audio first, the brain is more responsive to audio glitches */
    }
#ifdef GENERIC
  }
#endif
  if (Stream.video.state != stream_closed)
  {
    Stuffing_StuffVideo ();
  }
  return 1;
}
