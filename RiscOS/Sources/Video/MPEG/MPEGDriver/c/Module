/******	Module.c ***********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Main relocatable module entry points

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
10/09/1999	BJGA	Created
07/10/1999	BJGA	Initialises Stream and Module_PrivateWord
22/10/1999	BJGA	API updated in line with issue 2 specification
22/10/1999	BJGA	Now uses RAM_MODULE switch rather than ROM_MODULE to
			switch ResourceFS code - since debug and McCabe builds
			will be softloaded, this makes the makefile simpler
08/11/1999	BJGA	Added DebugLib support;
			added *Read3520 and *Write3520

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "Global/Services.h"
#include "Global/SWIs.h"
#include "Global/RISCOS.h"
#include "DebugLib/DebugLib.h"
#include "MPEG/MPEGAudio.h"
#include "MPEG/MPEGCtrl.h"
#include "MPEG/MPEGVideo.h"

#include "Audio.h"
#include "CLI.h"
#include "Defs.h"
#include "IRQ.h"
#include "Mess.h"
#include "ModHdr.h"
#include "ModHdr2.h"
#include "Module.h"
#include "ResMess.h"
#include "Service.h"
#include "STi3520L.h"
#include "Stuffing.h"
#include "Types.h"
#include "Video.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

program_element_structure_t Stream;
    /*  
     *  Unfortunately, this is a structure not a class, so it forces all items to be global; however
     *  it's the only way to make everything stream-handle-relative. The naming convention is broken
     *  because it's going to be referenced all the time, and Module_Stream feels too long a name...
     */
void *Module_PrivateWord; /* so we don't have to worry about passing pw around as a parameter to dozens of functions */
int Module_MessageFD [4] = { 0, 0, 0, 0 };  /* message file descriptor */
bool Module_Dying = false; /* for the use of ModHdr2.s */

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Module_Init() ******************************************************

Purpose:	Module and STi3520L initialisation
In:		Standard args
Out:		Pointer to error block if initialisation failed

***************************************************************************/

extern _kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e = NULL;
#ifndef ROM_MODULE
  bool FileRegistered = false;
#endif
  bool MessagesOpen = false;
  bool PEH1Registered = false;
  bool PEH2Registered = false;
  bool SecondaryModuleInitialised = false;
  IGNORE(podule_base);
  IGNORE(cmd_tail);

  Module_PrivateWord = pw;

  debug_initialise ("MPEGDriver", "null:", "");
  debug_atexit ();
  debug_set_taskname_prefix (false);
  debug_set_area_level_prefix (true);
  debug_set_area_pad_limit (0);
  debug_set_device (NULL_OUTPUT);
  debug_set_raw_device (NULL_OUTPUT);
  debug_set_trace_device (NULL_OUTPUT);

  if (!e)
  {

#ifndef ROM_MODULE
    e = _swix (ResourceFS_RegisterFiles, _IN(0), ResMess_ResourcesFiles ());
  }
  if (!e)
  {
    FileRegistered = true;
#endif

    e = _swix (MessageTrans_OpenFile, _INR(0,2), &Module_MessageFD, "Resources:$.Resources.MPEGDriver.Messages", 0);
  }
  if (!e)
  {
    MessagesOpen = true;

    e = _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3), 0, 1 /* MPEG-1 video */, program_element_handler, pw);
  }
  if (!e)
  {
    PEH1Registered = true;

    e = _swix (MPEGControl_RegisterProgramElementHandler, _INR(0,3), 0, 2 /* MPEG-2 video */, program_element_handler, pw);
  }
  if (!e)
  {
    PEH2Registered = true;

    e = _swix (OS_Module, _INR(0,1), 10 /* insert from memory */, ModHdr2);
  }
  if (!e)
  {
    SecondaryModuleInitialised = true;
    
    STi3520L_HardReset ();
    
    /* Initialise the program_element_structure_t */
    Stream.csh = NULL_CSH;                        /* signals no streams are open yet */
    Stream.s_flags.video_present = false;
    Stream.s_flags.audio_present = false;
    Stream.discarded_audio_bit_buffer_data = -1;
  }

  if (e && SecondaryModuleInitialised) _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
  if (e && PEH2Registered) _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3), 0, 2, program_element_handler, pw);
  if (e && PEH1Registered) _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3), 0, 1, program_element_handler, pw);
  if (e && MessagesOpen) _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  if (e && FileRegistered) _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  return e;
}

/******	Module_Final() *****************************************************

Purpose:	Module finalisation
In:		Standard args
Out:		Pointer to error block if finalisation failed

***************************************************************************/

extern _kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);
  
  Module_Dying = true; /* flag to MPEGDriver+ that it's OK to die */
  _swix (OS_Module, _INR(0,1), 4 /* delete */, "MPEGDriver+");
  _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3), 0, 2, program_element_handler, pw);
  _swix (MPEGControl_DeregisterProgramElementHandler, _INR(0,3), 0, 1, program_element_handler, pw);
  _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  return e;
}

/******	Module_Service() ***************************************************

Purpose:	Service call handler
In:		Standard args

***************************************************************************/

extern void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  bool claim = false;
  switch (service_number)
  {
    case Service_PreReset:
      claim = Service_ServicePreReset ();
      break;
    case Service_MPEGControlStarting:
      claim = Service_ServiceMPEGControlStarting (pw);
      break;
  }
  if (claim) r->r[1] = 0;
}

/******	Module_Commands() **************************************************

Purpose:	* command handler
In:		Standard args
Out:		Pointer to error block if command could not be executed

***************************************************************************/

extern _kernel_oserror *Module_Commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(argc);
  IGNORE(pw);
  switch (cmd_no)
  {
    case CMD_VideoInfo:
      e = CLI_VideoInfo ();
      break;
    case CMD_Read3520:
      e = CLI_Read3520 (arg_string);
      break;
    case CMD_Write3520:
      e = CLI_Write3520 (arg_string);
      break;
  }
  return e;
}

/******	Module_SWI() *******************************************************

Purpose:	SWI handler
In:		Standard args
Out:		Pointer to error block if SWI could not be executed

***************************************************************************/

extern _kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  _kernel_swi_regs rout;
  IGNORE(pw);
  switch (swi_offset)
  {
    case MPEGVideo_OpenStream - MPEGVideoSWI_Base:
      e = Video_SWIOpenStream (
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (video_parameters_structure_t *) (r->r[2]),
          (stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      break;
    case MPEGVideo_FullPackets - MPEGVideoSWI_Base:
      e = Video_SWIFullPackets (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGVideo_CloseStream - MPEGVideoSWI_Base:
      e = Video_SWICloseStream (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_Play - MPEGVideoSWI_Base:
      e = Video_SWIPlay (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGVideo_SetSpeed - MPEGVideoSWI_Base:
      e = Video_SWISetSpeed (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGVideo_CardControl - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 2:
          e = Video_SWICardControl2 (
              (unsigned int) (r->r[1]),
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        case 7:
          e = Video_SWICardControl7 (
              (unsigned int *) &(rout.r[1]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          break;
        default:
          e = Mess_GenerateError ("Err_InvReason", 0, 1, "MPEGVideo_CardControl");
          break;
      }
      break;
    case MPEGVideo_ReadParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 4:
          e = Video_SWIReadParameters4 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        case 5:
          e = Video_SWIReadParameters5 (
              (unsigned int *) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        default:
          e = Mess_GenerateError ("Err_InvReason", 0, 1, "MPEGVideo_ReadParameters");
          break;
      }
      break;
    case MPEGVideo_ResetStream - MPEGVideoSWI_Base:
      e = Video_SWIResetStream (
          (reset_stream_flags_t *) &(r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGVideo_Stats - MPEGVideoSWI_Base:
      e = Video_SWIStats (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGVideo_SetVideoParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Video_SWISetVideoParameters0 (
              (stream_handle_t) (r->r[1]),
              (scaling_type_block_t *) &(r->r[2])
              );
          break;
        case 1:
          e = Video_SWISetVideoParameters1 (
              (stream_handle_t) (r->r[1]),
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        case 2:
          e = Video_SWISetVideoParameters2 (
              (stream_handle_t) (r->r[1]),
              (unsigned int) (r->r[2]),
              (unsigned int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        default:
          e = Mess_GenerateError ("Err_InvReason", 0, 1, "MPEGVideo_SetVideoParameters");
          break;
      }
      break;
    case MPEGAudio_OpenStream - MPEGVideoSWI_Base:
      e = Audio_SWIOpenStream (
          (stream_flags_t *) &(r->r[0]),
          (control_stream_handle_t) (r->r[1]),
          (audio_parameters_structure_t *) (r->r[2]),
          (stream_handle_t *) &(rout.r[0])
          );
      r->r[0] = rout.r[0];
      break;
    case MPEGAudio_FullPackets - MPEGVideoSWI_Base:
      e = Audio_SWIFullPackets (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (bitstream_packet_t *) (r->r[2])
          );
      break;
    case MPEGAudio_CloseStream - MPEGVideoSWI_Base:
      e = Audio_SWICloseStream (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_Play - MPEGVideoSWI_Base:
      e = Audio_SWIPlay (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SetSpeed - MPEGVideoSWI_Base:
      e = Audio_SWISetSpeed (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case MPEGAudio_ResetStream - MPEGVideoSWI_Base:
      e = Audio_SWIResetStream (
          (reset_stream_flags_t *) &(r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_MuteSound - MPEGVideoSWI_Base:
      e = Audio_SWIMuteSound (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1])
          );
      break;
    case MPEGAudio_SoundVolume - MPEGVideoSWI_Base:
      e = Audio_SWISoundVolume (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (int) (r->r[2]),
          (int *) &(rout.r[2])
          );
      r->r[2] = rout.r[2];
      break;
    case MPEGAudio_Stats - MPEGVideoSWI_Base:
      e = Audio_SWIStats (
          (unsigned int) (r->r[0]),
          (stream_handle_t) (r->r[1]),
          (unsigned int *) (r->r[2]),
          (void *) (r->r[3]),
          (int) (r->r[4]),
          (void **) &(rout.r[3]),
          (int *) &(rout.r[4])
          );
      r->r[3] = rout.r[3];
      r->r[4] = rout.r[4];
      break;
    case MPEGAudio_SetAudioParameters - MPEGVideoSWI_Base:
      switch (r->r[0])
      {
        case 0:
          e = Audio_SWISetAudioParameters0 (
              (stream_handle_t) (r->r[1]),
              (int) &(r->r[2]),
              (int *) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        case 1:
          e = Audio_SWISetAudioParameters1 (
              (stream_handle_t) (r->r[1]),
              (dual_channel_specifier) (r->r[2]),
              (dual_channel_specifier *) &(rout.r[2]),
              (audio_channel_type *) &(rout.r[3])
              );
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        default:
          e = Mess_GenerateError ("Err_InvReason", 0, 1, "MPEGAudio_SetAudioParameters");
          break;
      }
      break;
    default:
      e = error_BAD_SWI;
      break;
  }
  return e;
}

/******	Module_AudioStuffingCallback() *************************************

Purpose:	Callback entry for the use of audio stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_AudioStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_AudioCallback ();
  return NULL;
}

/******	Module_ProgramElementHandler() *************************************

Purpose:	Program element handler
In:		Registers in/out, module private word
Out:		Pointer to error block (if required)

***************************************************************************/

extern _kernel_oserror *Module_ProgramElementHandler(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(pw);
  switch (r->r[0])
  {
    case PEHReason_DataTransfer:
      e = Video_SWIFullPackets(
          (unsigned int) (r->r[1]),
          (stream_handle_t) (r->r[2]),
          (bitstream_packet_t *) (r->r[3])
          );
      break;
    default:
      /* do nothing (MPEGVideo_OpenStream and MPEGVideoCloseStream are still called by MPEGTransport) */
      break;
  }
  return e;
}

/******	Module_STi3520LIRQHandler() ****************************************

Purpose:	Top-level IRQ handler entry point
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_STi3520LIRQHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  IRQ_Handler ();
  return NULL;
}

/******	Module_VideoStuffingCallback() *************************************

Purpose:	Callback entry for the use of video stuffing code
In:		Registers in/out, module private word
Out:		Pointer to error block (null)

***************************************************************************/

_kernel_oserror *Module_VideoStuffingCallback(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_VideoCallback ();
  return NULL;
}

/******	Module_TickerVHandler() ********************************************

Purpose:	TickerV entry point, used to timeslice stuffing code
In:		Registers in/out, module private word
Out:		0 to intercept, 1 to pass on

***************************************************************************/

int Module_TickerVHandler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  Stuffing_StuffAudio ();  /* do audio first, the brain is more responsive to audio glitches */
  Stuffing_StuffVideo ();
  return 1;
}
