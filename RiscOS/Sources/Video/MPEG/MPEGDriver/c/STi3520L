/******	STi3520L.c *********************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	MPEG chip initialisation and management

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
28/09/1999	BJGA	Created
20/10/1999	BJGA	Fixed green screen on module initialisation;
			initialises video display in STi3520L_HardReset();
			implemented STi3520L_SoftReset() and STi3520L_PipelineReset()
23/11/1999	BJGA	Bit buffer end addresses are inclusive!
13/12/1999	BJGA	Added separate XDO/XDS values for PAL video;
			added audio bitbuffer initialisation;
			implemented STi3520L_WriteSDRAM()
25/01/2000	BJGA	Added lots of audio register initialisations to HardReset;
			rewrote SoftReset to allow separate audio and video resets;
			adjusted VID_XDO and VID_XDS as per new hardware timing scheme

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"

#include "DebugLib/DebugLib.h"
#include "Global/IO/GenericIO.h"

#include "Mess.h"
#include "Registers.h"
#include "STi3520L.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static void static_WaitMicroseconds (unsigned int wait);
static void static_InitialisePLL (void);
static void static_SelectPLLFreq (unsigned int conf_pll);
static void static_SelectSDRAM (void);
static bool static_TestMemory (unsigned char initial_value);
static bool static_TestBlockMove (void);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

/* Memory test function constants */

#define MEMORY_WRITE_FIFO_EMPTY_TIMEOUT 0xFFFF
#define MEMORY_READ_FIFO_FULL_TIMEOUT   0xFFFF
#define BLOCK_MOVE_IDLE_TIMEOUT         0xFFFF
#define MEMORY_TEST_SIZE                0x20
#define BLOCK_MOVE_SIZE                 0x7FFE

/* Bit pattern for block move test */

#define PATTERN_1       0xAA
#define PATTERN_2       0xAA
#define PATTERN_3       0xAA
#define PATTERN_4       0xAA
#define PATTERN_5       0xAA
#define PATTERN_6       0xAA
#define PATTERN_7       0xAA
#define PATTERN_8       0xAA
#define PATTERN_9       0x55
#define PATTERN_10      0x55
#define PATTERN_11      0x55
#define PATTERN_12      0x55
#define PATTERN_13      0x55
#define PATTERN_14      0x55
#define PATTERN_15      0x55
#define PATTERN_16      0x55

/********************/
/* Public functions */
/********************/

/******	STi3520L_HardReset() ***********************************************

Purpose:	Perform a hard reset and full reinitialisation of the 3520L

***************************************************************************/

void STi3520L_HardReset (void)
{
  unsigned char outerloop;
  unsigned char innerloop;
  
  /* Use the CFG_RST register to perform the hard reset */

  CFG_RST = 1;                  /* reset 3520 */
  static_WaitMicroseconds (1000);
  CFG_RST = 0;                  /* unreset 3520 */
  static_WaitMicroseconds (1000);
  WRITE_VID_DCF(VID_DCF_USR | VID_DCF_PXD);   /* get rid of green screen as quickly as possible */

  /* Go through the PLL initialisation procedure, as described in application note */
  
  for (outerloop = 0; outerloop < 10; outerloop++)
  {
    for (innerloop = 0; innerloop < 10; innerloop++)
    {
      /* Do memory tests with PLL overclocked to 297MHz to increase failure rate */
      static_InitialisePLL ();
      static_SelectPLLFreq (0xC5);
      CFG_CCF = 0x1F;
      static_SelectSDRAM ();
      if (false == static_TestMemory (innerloop))
        break;
      if (false == static_TestBlockMove ())
        break;
    }
    /* Set PLL to 243MHz (nominal) and test again */
    static_SelectPLLFreq (0xC3);
    if (false == static_TestMemory (innerloop))
      break;
    if (false == static_TestBlockMove ())
      break;
  }
  
  /* Set up the memory map */
  WRITE_VID_OTP(SDRAM_OSD_START/256);
  WRITE_VID_ABG(SDRAM_AUDIO_BIT_BUFFER_START/256);
  WRITE_VID_ABS(SDRAM_AUDIO_BIT_BUFFER_END/256 - 1);
  WRITE_VID_VBG(SDRAM_VIDEO_BIT_BUFFER_START/256);
  WRITE_VID_VBS(SDRAM_VIDEO_BIT_BUFFER_END/256 - 1);
  
  /* Other one-time initialisations */
  AUD_BBE = 1;      /* enable audio bit-buffer */
  AUD_CRC = 0;      /* disable CRC detection and error concealment */
  AUD_EXT = 0;      /* output both left and right channels */
  WRITE_AUD_FFL(0); /* free-format frame length is unknown */
  AUD_IDE = 0;      /* ignore AUD_SID */
  AUD_IFT = 0;      /* input FIFO threshold not used in this driver (set to 0) */
  AUD_ISS = 0;      /* input is elementary stream (for now) */
  AUD_LCA = 0;      /* left channel attenuation = 0 */
  AUD_LCK = 3;      /* sync words until lock = 3 (default) */
  AUD_MUT = 1;      /* muted */
  AUD_PLY = 0;      /* not playing */
  AUD_RCA = 0;      /* right channel attenuation = 0 */
  AUD_SCM = 1;      /* sync confirmation mode = 1 (sync when first start code and stream ID found) */
  AUD_SEM = 1;      /* sync error concealment mode = 1 (mute) */
  AUD_SID = 0;      /* stream ID = 0 (although not used, see AUD_IDE) */
  AUD_SKP = 0;      /* don't skip next frame! */
  AUD_SYE = 0x3F;   /* don't use any additional fields for sync lock */
  AUD_SYN = 1;      /* sync on any audio PES packet header */
  AUD_DIF = 1;      /*  \                                      */
  AUD_DIV = 1;      /*  |                                      */
  AUD_FOR = 1;      /*  |                                      */
  AUD_LRP = 1;      /*  |  set up PCM output to suit our DACs  */
  AUD_ORD = 0;      /*  |                                      */
  AUD_P18 = 1;      /*  |                                      */
  AUD_SCP = 0;      /*  /                                      */
  VID_CTL = VID_CTL_ERU | VID_CTL_ERS | VID_CTL_ERP;  /* automatic pipeline resets on any error type */
  
  /* Initialise the display */
  WRITE_VID_DFP(SDRAM_FRAME_BUFFER_1_START/256);
// NTSC
//  WRITE_VID_YDO(21);
//  WRITE_VID_YDS(21+240-128-1); /* -1 because we're using vertical filter mode 0 */
//  WRITE_VID_XDO(102);        /* -1 to get the chroma phases right on this system (?) */
//  WRITE_VID_XDS(102+720+6);
// PAL
  WRITE_VID_YDO(22);
  WRITE_VID_YDS(22+288-128-1); /* -1 because we're using vertical filter mode 0 */
  WRITE_VID_XDO(112);        /* -1 to get the chroma phases right on this system (?) */
  WRITE_VID_XDS(112+720+6);
  WRITE_VID_MWV(0xFF);  /* 0% background, 100% video */
  WRITE_VID_MWS(0xFF);  /* 0% background, 100% still picture (if we ever use it) */
  
  STi3520L_SoftReset (true, true); /* so the memory map changes take effect */
}

/******	STi3520L_SoftReset() ***********************************************

Purpose:	Perform a soft reset of the 3520L (and stops decoding)
In:		Whether to reset video and/or audio units

***************************************************************************/

void STi3520L_SoftReset (bool reset_video, bool reset_audio)
{
  unsigned char temp = VID_ABT_8 & 0x3F;
  if (reset_video ^ reset_audio != 0) temp |= VID_ABT_SSR >> 8; /* select separate resets if necessary */
  if (reset_video)
  {
    VID_DCF_0 &= ~(VID_DCF_EVD >> 0); /* hide video display */
    VID_ABT_8 = temp;
    VID_CTL |= VID_CTL_SRS; /* engage video or video+audio soft reset */
    static_WaitMicroseconds(1);
    VID_CTL &= ~VID_CTL_SRS; /* disengage reset */
    static_WaitMicroseconds(1);
  }
  if (reset_audio & !reset_video)
  {
    VID_ABT_8 = temp | VID_ABT_ASR >> 8; /* engage audio-only soft reset */
    static_WaitMicroseconds(1);
    VID_ABT_8 = temp; /* disengage reset */
    static_WaitMicroseconds(1);
  }
}

/******	STi3520L_PipelineReset() *******************************************

Purpose:	Perform a pipeline reset

***************************************************************************/

void STi3520L_PipelineReset (void)
{
  VID_CTL |= VID_CTL_PRS;
  static_WaitMicroseconds(1);
  VID_CTL &= ~VID_CTL_PRS;
}

/******	STi3520L_WriteSDRAM() **********************************************

Purpose:	Copies a block of memory to the private SDRAM
In:		From pointer (ARM DRAM), to pointer (3520 SDRAM, must be a
		multiple of 8 bytes), length (must be a multiple of 8 bytes)
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *STi3520L_WriteSDRAM (unsigned char *from, unsigned int to, unsigned int length)
{
  _kernel_oserror *e = NULL;
  unsigned int retry_count;
  WRITE_CFG_MWP(to / 8 * 4);
  /* Wait for the write FIFO to become empty */
  retry_count = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0 && retry_count < MEMORY_WRITE_FIFO_EMPTY_TIMEOUT) retry_count++;
  if (retry_count == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
  {
    e = Mess_GenerateError ("Err_Write", 1, 0);
  }
  while (length / 8 != 0 && !e)
  {
    /* Write one 64-bit word */
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    CFG_MWF = *(from++);
    length -= 8;
    /* Wait for the write FIFO to become empty */
    retry_count = 0;
    while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0 && retry_count < MEMORY_WRITE_FIFO_EMPTY_TIMEOUT) retry_count++;
    if (retry_count == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
    {
      e = Mess_GenerateError ("Err_Write", 1, 0);
    }
  }
  return e;
}

/*********************/
/* Private functions */
/*********************/

/******	static_WaitMicroseconds() ******************************************

Purpose:	Do nothing for a length of time more accurately measured
		than the centisecond timers would allow
In:		Minimum time to wait, in microseconds
Notes:		Processor is assumed to be in SVC mode

***************************************************************************/

static void static_WaitMicroseconds (unsigned int wait)
{
  unsigned int oldtime = 0;
  unsigned int newtime;
  signed int diff;
  /* Convert to 2MHz ticks (passing in µs makes code more readable - it's not like we can work to .5 µs accuracy anyway */
  signed int count = wait << 1;
    
  do
  {
    * (volatile unsigned char *) (IOC + Timer1LR) = 0;              /* latch Timer1 value */
    newtime = * (volatile unsigned char *) (IOC + Timer1CL) +
             (* (volatile unsigned char *) (IOC + Timer1CH) << 8);  /* read Timer1 value */
    diff = newtime - oldtime;
    if (diff < 0) count += diff;   /* if time has decreased (ie no wraparound) then apply it to |count| too */
    oldtime = newtime;
  }
  while (count > 0);

  return;
}

/******	static_InitialisePLL() *********************************************

Purpose:	Stops the PLL itself, but initialises its inputs and outputs

***************************************************************************/

static void static_InitialisePLL (void)
{
  /* Stop the PLL */
  WRITE_CKG_PLL(0x20);        /* discharge the capacitor */
  static_WaitMicroseconds (100);
  /* Set up inputs/outputs and PLL dividers */
  WRITE_CKG_CFG(0x23);        /* SDRAMCLK, PCMCLK pins set as outputs, AUDCLK, PIXCLK pins as inputs, video/audio decoder clocks generated internally */
  WRITE_CKG_VID(0x22001F7E);  /* PO=2,  PR=1,    Q=1,    DV2=0  => 60.750 MHz  (must be 3/2 SDRAMCLK for 32Mbit SDRAM configuration) */
  WRITE_CKG_AUD(0x28022F66);  /* P0=8,  PR=18,   Q=25,   DV2=0  => 25.000 MHz  */
  WRITE_CKG_PCM(0x397F6542);  /* PO=9,  PR=1022, Q=1341, DV2=1  => 11.290 MHz  (example - 44.1 kHz audio at 256 ticks per sample) */
  WRITE_CKG_MCK(0x00000F7E);  /* reset DIV3 */
  WRITE_CKG_MCK(0x32000F7E);  /* PO=2,  PR=0,    Q=1,    DV2=1  => 40.500 MHz  (most conservative SDRAMCLK frequency for 32Mbit SDRAM configuration) */
  WRITE_CKG_AUX(0x00000F7E);
  WRITE_CKG_PIX(0x00000F7E);
}

/******	static_SelectPLLFreq() *********************************************

Purpose:	Restarts the PLL, and polls the status bit in CKG_AUX until
		the PLL has locked
In:		Value to be written into CKG_PLL

***************************************************************************/

static void static_SelectPLLFreq (unsigned int conf_pll)
{
  int times;
  CKG_PLL = conf_pll;
  for (times=0; times < 0x1000; times++)
  {
    if ((CKG_AUX & 0x40000000) != 0) break;
  }
  if (times == 0x1000)
  {
    printf ("%s\n","Warning: MPEG PLL did not lock");
  }
}

/******	static_SelectSDRAM() ***********************************************

Purpose:	Configures memory refresh, performs SDRAM initialisation sequence

***************************************************************************/

static void static_SelectSDRAM (void)
{
  CFG_MCF = 39;  /* 8ms row refresh */
  CFG_DRC = 0;
  static_WaitMicroseconds (1000);
  CFG_DRC = 0x43;
  static_WaitMicroseconds (1000);
  CFG_DRC = 0x63;
  static_WaitMicroseconds (1000);  
}

/******	static_TestMemory() ************************************************

Purpose:	Tests SDRAM by writing a series of incrementing bytes, and
                verifying that the values are read back correctly
In:		The value of the first byte to write
Out:		|true| if test was successful

***************************************************************************/

static bool static_TestMemory (unsigned char initial_value)
{
  unsigned int i;
  unsigned int counter;
  unsigned char my_value = initial_value;
  
  /* Initialise memory write pointer */
  WRITE_CFG_MWP(0x000000);
  
  /* Fill the memory with a   initial_value++ */
  for (i = 0; i < MEMORY_TEST_SIZE; i++) 
  {
    /* Wait for the write FIFO to be empty */
    counter = 0;
    while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0)
    {
      counter++;
      if (counter == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
      {
        printf ("%s\n", "Warning: MPEG SDRAM write timeout reached");
        return false;
      }
    }
    
    /* Write a 64bits word */
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
    CFG_MWF = my_value++;
  }
  
  /* Initialise memory read pointer */
  WRITE_CFG_MRP(0x000000);
  
  /* Reinitialise counter */
  my_value = initial_value;
  
  /* Readback the memory */
  for (i = 0; i < MEMORY_TEST_SIZE; i++) 
  {
    /* Wait for the read FIFO to be full */
    counter = 0;
    while (((VID_STA_8<<8) & VIDEO_INT_RFF) == 0)
    {
      counter++;
      if (counter == MEMORY_READ_FIFO_FULL_TIMEOUT)
      {
        printf ("%s\n", "Warning: MPEG SDRAM read timeout reached");
        return false;
      }
    }
    
    /* Read a 64 bit word */
    if (CFG_MRF != my_value++) 
      return false;
    if (CFG_MRF != my_value++) 
      return false;
    if (CFG_MRF != my_value++) 
      return false;
    if (CFG_MRF != my_value++)
      return false;
    if (CFG_MRF != my_value++)
      return false;
    if (CFG_MRF != my_value++)
      return false;
    if (CFG_MRF != my_value++)
      return false;
    if (CFG_MRF != my_value++)
      return false;
  }
  return true;
}

/******	static_TestBlockMove() *********************************************

Purpose:	Tests SDRAM, using the block move functionality of the 3520L
		to repeatedly move a 128-bit pattern across memory in 64-bit
		steps. Due to the nature of the pattern, this involves
		toggling every bit in each 64-bit word
Out:		|true| if test was successful

***************************************************************************/

static bool static_TestBlockMove (void)
{
  int counter;
  
  /*
   *  First write two 64bit words into the base of memory ensuring FIFO is
   *  empty before commencing. (FIFO can contain 32 bits at a time so it is
   *  necessary to perform two independant write operations.
   */
  
  /* Wait for the write FIFO to be empty */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0)
  {
    counter++;
    if (counter == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
    {
      printf ("%s\n", "Warning: MPEG SDRAM write timeout reached");
      return false;
    }
  }
  
  /* Initialise memory write pointer */
  WRITE_CFG_MWP(0x000000);
  
  /* Write a 64bit word */
  CFG_MWF = PATTERN_1;
  CFG_MWF = PATTERN_2;
  CFG_MWF = PATTERN_3;
  CFG_MWF = PATTERN_4;
  CFG_MWF = PATTERN_5;
  CFG_MWF = PATTERN_6;
  CFG_MWF = PATTERN_7;
  CFG_MWF = PATTERN_8;
  
  /* Wait for the write FIFO to be empty */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0)
  {
    counter++;
    if (counter == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
    {
      printf ("%s\n", "Warning: MPEG SDRAM write timeout reached");
      return false;
    }
  }
  
  /* Write a 64bit word */   
  CFG_MWF = PATTERN_9;
  CFG_MWF = PATTERN_10;
  CFG_MWF = PATTERN_11;
  CFG_MWF = PATTERN_12;
  CFG_MWF = PATTERN_13;
  CFG_MWF = PATTERN_14;
  CFG_MWF = PATTERN_15;
  CFG_MWF = PATTERN_16;
  
  /* Wait for the write FIFO to be empty */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_WFE) == 0)
  {
    counter++;
    if (counter == MEMORY_WRITE_FIFO_EMPTY_TIMEOUT)
    {
      printf ("%s\n", "Warning: MPEG SDRAM write timeout reached");
      return false;
    }
  }
  
  /*
   *  Now perform the actual block move. Source address is 0x00 containing
   *  two 64bit words of data. Destination is 0x2 (64 bits into memory). Bit
   *  pattern will propagate through memory for BLOCK_MOVE_SIZE 64bit words
   */
  
  /* Set block move size */
  WRITE_CFG_BMS(BLOCK_MOVE_SIZE);
  
  /* Set the write address */
  WRITE_CFG_MWP(0x000008);
  
  /* Set the read address */
  WRITE_CFG_MRP(0x000000); /* launch block move process here */
  
  /* Wait for the block move to complete */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_BMI) == 0)
  {
    counter++;
    if (counter == BLOCK_MOVE_IDLE_TIMEOUT)
    {  
      printf ("%s\n", "Warning: MPEG SDRAM block move timeout reached");
      return false;
    }
  }
  
  /* Disable block move function */
  WRITE_CFG_BMS(0);
  
  /* Initialise memory read pointer */
  WRITE_CFG_MRP((BLOCK_MOVE_SIZE - 2) << 2)
  
  /* Wait for the read FIFO to be full */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_RFF) == 0)
  {
    counter++;
    if (counter == MEMORY_READ_FIFO_FULL_TIMEOUT)
    {
      printf ("%s\n", "Warning: MPEG SDRAM read timeout reached");
      return false;
    }
  }
  
  /* Read a 64 bit word */
  if (CFG_MRF != PATTERN_1) 
    return false;
  if (CFG_MRF != PATTERN_2) 
    return false;
  if (CFG_MRF != PATTERN_3) 
    return false;
  if (CFG_MRF != PATTERN_4)
    return false;
  if (CFG_MRF != PATTERN_5)
    return false;
  if (CFG_MRF != PATTERN_6)
    return false;
  if (CFG_MRF != PATTERN_7)
    return false;
  if (CFG_MRF != PATTERN_8)
    return false;
  
  /* Wait for the read FIFO to be full */
  counter = 0;
  while (((VID_STA_8<<8) & VIDEO_INT_RFF) == 0)
  {
    counter++;
    if (counter == MEMORY_READ_FIFO_FULL_TIMEOUT)
    {
      printf ("%s\n", "Warning: MPEG SDRAM read timeout reached");
      return false;
    }
  }
  
  /* Read a 64 bit word */
  if (CFG_MRF != PATTERN_9)
    return false;
  if (CFG_MRF != PATTERN_10)
    return false;
  if (CFG_MRF != PATTERN_11)
    return false;
  if (CFG_MRF != PATTERN_12)
    return false;
  if (CFG_MRF != PATTERN_13)
    return false;           
  if (CFG_MRF != PATTERN_14)
    return false;
  if (CFG_MRF != PATTERN_15)
    return false;
  if (CFG_MRF != PATTERN_16)
    return false;

  return true;
}
