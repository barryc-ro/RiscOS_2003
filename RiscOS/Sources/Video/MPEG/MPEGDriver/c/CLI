/******	CLI.c **************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Command line interface

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
17/09/1999	BJGA	Created
08/11/1999	BJGA	Added Read3520() and Write3520()
22/11/1999	BJGA	Implemented a basic version of VideoInfo
07/12/1999	BJGA	Added audio stats to *VideoInfo
28/01/2000	BJGA	*VideoInfo now outputs full audio header info
02/02/2000	BJGA	Fix for sillies in *VideoInfo
15/02/2000	BJGA	Now outputs video header information, and audio error counts
18/02/2000	BJGA	No longer prints garbage header details if there was no
			video/audio (as appropriate) in the most recently opened stream
27/03/2000	BJGA	Now outputs counts of PES packets and PTSs and the first PTS for
			each of video and audio, and also audio frame-sync losses
02/05/2000	BJGA	Split *AudioInfo from *VideoInfo; implemented *Configure commands

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "MPEG/MPEG2cCard.h"
#include "NVRAM.h"

#include "CLI.h"
#include "Defs.h"
#include "Mess.h"
#include "Module.h"
#include "Types.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static bool static_MatchStrings (const char *s1, const char *s2);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/********************/
/* Public functions */
/********************/

/******	CLI_VideoInfo() ****************************************************

Purpose:	Handles *VideoInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_VideoInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("                       Since open  Since reset\n");
  printf ("Bytes received:        %10u   %10u\n", Stream.video.since_open.amount_received, Stream.video.since_reset.amount_received);
  printf ("Bytes sent to 3520:    %10u   %10u\n", Stream.video.since_open.amount_sent, Stream.video.since_reset.amount_sent);
  printf ("PES packets sent:      %10u   %10u\n", Stream.video.since_open.PES_packets_sent, Stream.video.since_reset.PES_packets_sent);
  printf ("PTSs sent:             %10u   %10u\n", Stream.video.since_open.PTSs_in, Stream.video.since_reset.PTSs_in);
  printf ("PTSs decoded:          %10u   %10u\n", Stream.video.since_open.PTSs_out, Stream.video.since_reset.PTSs_out);
  printf ("Frame repeats:         %10u   %10u\n", Stream.video.since_open.slows, Stream.video.since_reset.slows);
  printf ("Frame skips:           %10u   %10u\n", Stream.video.since_open.fasts, Stream.video.since_reset.fasts);
  printf ("Stalls:                %10u   %10u\n", Stream.video.since_open.stalls, Stream.video.since_reset.stalls);
  printf ("Picture decode errors: %10u   %10u\n", Stream.video.since_open.picture_decode_errors, Stream.video.since_reset.picture_decode_errors);
  printf ("Severe errors:         %10u   %10u\n", Stream.video.since_open.severe_errors, Stream.video.since_reset.severe_errors);
  printf ("Pipeline errors:       %10u   %10u\n", Stream.video.since_open.pipeline_errors, Stream.video.since_reset.pipeline_errors);  
  printf ("Underruns:             %10u   %10u\n", Stream.video.since_open.underruns, Stream.video.since_reset.underruns);
  printf ("Software auto-resets:  %10u   %10u\n", Stream.video.since_open.internal_resets, Stream.video.since_reset.internal_resets);
  printf ("\n");
  
  printf ("First PTS received:             ");
  if (Stream.video.first_PTS.msb & 0xFE)
  {
    printf ("None\n");
  }
  else
  {
    printf ("%1X%08X\n", Stream.video.first_PTS.msb, Stream.video.first_PTS.lsw);
  }
  
  
  if (Stream.display_frames == NULL)
  {
    printf ("\nNo video header information available\n");
  }
  else
  {
    unsigned char frame_centre_offset;
    unsigned char number_of_frame_centre_offsets = Stream.display_frames->seq.progressive_sequence
      ? (Stream.display_frames->repeat_first_field ? (Stream.display_frames->top_field_first ? 3 : 2) : 1)
      : (Stream.display_frames->repeat_first_field ? 3 : 2); /* pairs of field pictures have been amalgamated by this point */
    
    printf ("\nSequence headers information:\n");
    printf ("    standard:                   %s\n", Stream.display_frames->seq.mpeg2 ? "MPEG-2" : "MPEG-1");
    printf ("    coded size:                 X:%4u Y:%4u aspect:%2u.%04u:1\n",
      Stream.display_frames->seq.coded_horizontal_size,
      Stream.display_frames->seq.coded_vertical_size,
      Stream.display_frames->seq.coded_aspect_ratio >> 16,
      ((Stream.display_frames->seq.coded_aspect_ratio & 0xFFFF) * 10000) >> 16);
    printf ("    display size:               X:%4u Y:%4u aspect:%2u.%04u:1\n",
      Stream.display_frames->seq.display_horizontal_size,
      Stream.display_frames->seq.display_vertical_size,
      Stream.display_frames->seq.display_aspect_ratio >> 16,
      ((Stream.display_frames->seq.display_aspect_ratio & 0xFFFF) * 10000) >> 16);
    printf ("    frame rate:                 %2u.%03u Hz\n", Stream.display_frames->seq.frame_rate / 1000, Stream.display_frames->seq.frame_rate % 1000);
    printf ("    bitrate:                    %u.%04u Mbit/s\n", Stream.display_frames->seq.bit_rate / 2500, Stream.display_frames->seq.bit_rate % 2500 * 4);
    printf ("    vbv_buffer_size:            %u Kbytes\n", Stream.display_frames->seq.vbv_buffer_size * 16);
    printf ("    profile/level:              ");
    {
      unsigned char escape_bit = (Stream.display_frames->seq.profile_and_level_indication & 0x80) >> 7;
      unsigned char profile = (Stream.display_frames->seq.profile_and_level_indication & 0x70) >> 4;
      unsigned char level = Stream.display_frames->seq.profile_and_level_indication & 0x0F;
      if (escape_bit == 1 ||
          profile == 0 ||
          profile > 5 ||
          (level & 1) == 1 ||
          level < 4 ||
          level > 10)
      {
        printf ("reserved\n");
      }
      else
      {
        switch (profile)
        {
          case 1: printf ("high profile (not supported) at "); break;
          case 2: printf ("spatially scalable profile (not supported) at "); break;
          case 3: printf ("SNR scalable profile (not supported) at "); break;
          case 4: printf ("main profile at "); break;
          case 5: printf ("simple profile at "); break;
        }
        switch (level)
        {
          case 4: printf ("high level (not supported)\n"); break;
          case 6: printf ("high 1440 level (not supported)\n"); break;
          case 8: printf ("main level\n"); break;
          case 10: printf ("low level\n"); break;
        }
      }
    }
    printf ("    progressive_sequence:       %u\n", Stream.display_frames->seq.progressive_sequence);
    printf ("    chroma_format:              ");
    switch (Stream.display_frames->seq.chroma_format)
    {
      case 0: printf ("reserved\n"); break;
      case 1: printf ("4:2:0\n"); break;
      case 2: printf ("4:2:2\n"); break;
      case 3: printf ("4:4:4\n"); break;
    }
    printf ("    low_delay:                  %u\n", Stream.display_frames->seq.low_delay);
    printf ("    video_format:               ");
    switch (Stream.display_frames->seq.video_format)
    {
      case 0: printf ("component\n"); break;
      case 1: printf ("PAL\n"); break;
      case 2: printf ("NTSC\n"); break;
      case 3: printf ("SECAM\n"); break;
      case 4: printf ("MAC\n"); break;
      case 5: printf ("unspecified\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    colour_primaries:           ");
    switch (Stream.display_frames->seq.colour_primaries)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("ITU-R BT.470-2 System M\n"); break;
      case 5: printf ("ITU-R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 240M\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    transfer_characteristics:   ");
    switch (Stream.display_frames->seq.transfer_characteristics)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("ITU-R BT.470-2 System M\n"); break;
      case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 250M\n"); break;
      case 8: printf ("linear\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    matrix_coefficients:        ");
    switch (Stream.display_frames->seq.matrix_coefficients)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("FCC\n"); break;
      case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 250M\n"); break;
      default: printf ("reserved\n"); break;
    }
    
    printf ("\nGOP header information:\n");
    printf ("    time_code:                  %02uh %02um %02us %02up\n",
      (Stream.display_frames->gop.time_code & 0xF10000) >> 19,
      (Stream.display_frames->gop.time_code & 0x07E000) >> 13,
      (Stream.display_frames->gop.time_code & 0x000FC0) >> 6,
      (Stream.display_frames->gop.time_code & 0x00003F) >> 0);
    printf ("    closed_gop:                 %u\n", Stream.display_frames->gop.closed_gop);
    printf ("    broken_link:                %u\n", Stream.display_frames->gop.broken_link);
    
    printf ("\nPicture headers information:\n");
    printf ("    temporal_reference:         %u\n", Stream.display_frames->temporal_reference);
    printf ("    picture_coding_type:        ");
    switch (Stream.display_frames->lastpic->picture_coding_type)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("I\n"); break;
      case 2: printf ("P\n"); break;
      case 3: printf ("B\n"); break;
      case 4: printf ("D (not supported)\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    vbv_delay:                  %u / 90kHz\n", Stream.display_frames->lastpic->vbv_delay);
    printf ("    f_code[s][t]:               %01X %01X %01X %01X\n",
      Stream.display_frames->lastpic->forward_horizontal_f_code,
      Stream.display_frames->lastpic->forward_vertical_f_code,
      Stream.display_frames->lastpic->backward_horizontal_f_code,
      Stream.display_frames->lastpic->backward_vertical_f_code);
    printf ("    intra_dc_precision:         %u bits\n", Stream.display_frames->lastpic->intra_dc_precision + 8);
    printf ("    picture_structure:          %s pictures\n",
      (Stream.display_frames->lastpic->picture_structure == 1 || Stream.display_frames->lastpic->picture_structure == 2) ? "field" : "frame");
    printf ("    top_field_first:            %u\n", Stream.display_frames->top_field_first);
    printf ("    frame_pred_frame_dct:       %u\n", Stream.display_frames->lastpic->picture_flags.bits.frame_pred_frame_dct);
    printf ("    concealment_motion_vectors: %u\n", Stream.display_frames->lastpic->picture_flags.bits.concealment_motion_vectors);
    printf ("    q_scale_type:               %u\n", Stream.display_frames->lastpic->picture_flags.bits.q_scale_type);
    printf ("    intra_vlc_format:           %u\n", Stream.display_frames->lastpic->picture_flags.bits.intra_vlc_format);
    printf ("    alternate_scan:             %u\n", Stream.display_frames->lastpic->picture_flags.bits.alternate_scan);
    printf ("    repeat_first_field:         %u\n", Stream.display_frames->repeat_first_field);
    printf ("    progressive_frame:          %u\n", Stream.display_frames->progressive_frame);
    for (frame_centre_offset = 0; frame_centre_offset < number_of_frame_centre_offsets; frame_centre_offset ++)
    {
      printf ("    %s(%+05d.%04d,%+05d.%04d)\n", frame_centre_offset ? "                            " : "frame centre offset(s):     ",
        Stream.display_frames->frame_centre_horizontal_offset [frame_centre_offset] / 16,
        abs (Stream.display_frames->frame_centre_horizontal_offset [frame_centre_offset] % 16) * 625,
        Stream.display_frames->frame_centre_vertical_offset [frame_centre_offset] / 16,
        abs (Stream.display_frames->frame_centre_vertical_offset [frame_centre_offset] % 16) * 625);
    }
    printf ("    active format:              %d\n", Stream.display_frames->lastpic->active_format);
    printf ("    active area:                X:%4u Y:%4u aspect:%2u.%04u:1 %s\n",
      Stream.active_horizontal_size,
      Stream.active_vertical_size,
      Stream.active_aspect_ratio >> 16,
      ((Stream.active_aspect_ratio & 0xFFFF) * 10000) >> 16,
      Stream.active_area_is_at_top ? "top" : "centre");
    printf ("    protected area:             X:%4u Y:%4u aspect:%2u.%04u:1 %s\n",
      Stream.protected_horizontal_size,
      Stream.protected_vertical_size,
      Stream.protected_aspect_ratio >> 16,
      ((Stream.protected_aspect_ratio & 0xFFFF) * 10000) >> 16,
      Stream.active_area_is_at_top ? "top" : "centre");
  }
  
  return e;
}

/******	CLI_AudioInfo() ****************************************************

Purpose:	Handles *AudioInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_AudioInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("                       Since open  Since reset\n");
  printf ("Bytes received:        %10u   %10u\n", Stream.audio.since_open.amount_received, Stream.audio.since_reset.amount_received);
  printf ("Bytes sent to 3520:    %10u   %10u\n", Stream.audio.since_open.amount_sent, Stream.audio.since_reset.amount_sent);
  printf ("PES packets sent:      %10u   %10u\n", Stream.audio.since_open.PES_packets_sent, Stream.audio.since_reset.PES_packets_sent);
  printf ("PTSs sent:             %10u   %10u\n", Stream.audio.since_open.PTSs_in, Stream.audio.since_reset.PTSs_in);
  printf ("PTSs decoded:          %10u   %10u\n", Stream.audio.since_open.PTSs_out, Stream.audio.since_reset.PTSs_out);
  printf ("Slows:                 %10u   %10u\n", Stream.audio.since_open.slows, Stream.audio.since_reset.slows);
  printf ("Fasts:                 %10u   %10u\n", Stream.audio.since_open.fasts, Stream.audio.since_reset.fasts);
  printf ("CRC errors:            %10u   %10u\n", Stream.audio.since_open.crc_errors, Stream.audio.since_reset.crc_errors);
  printf ("Frame sync losses:     %10u   %10u\n", Stream.audio.since_open.sync_losses, Stream.audio.since_reset.sync_losses);
  printf ("Underruns:             %10u   %10u\n", Stream.audio.since_open.underruns, Stream.audio.since_reset.underruns);
  printf ("\n");
  
  printf ("First PTS received:             ");
  if (Stream.audio.first_PTS.msb & 0xFE)
  {
    printf ("None\n");
  }
  else
  {
    printf ("%1X%08X\n", Stream.audio.first_PTS.msb, Stream.audio.first_PTS.lsw);
  }
  
  
  if (!Stream.aud_flags.first_header_received)
  {
    printf ("\nNo audio header information available\n");
  }
  else
  {
    printf ("\nHeader information:\n");
    printf ("    ID:                 %s\n", Stream.audio_header.fields.ID ? "MPEG-1" : "MPEG-2 (not supported)");
    printf ("    layer:              ");
    switch (Stream.audio_header.fields.layer)
    {
      case 0: printf ("reserved\n"); break;
      case 1: printf ("Layer III (not supported)\n"); break;
      case 2: printf ("Layer II\n"); break;
      case 3: printf ("Layer I\n"); break;
    }
    printf ("    protection_bit:     %sredundancy\n", Stream.audio_header.fields.protection_bit ? "no " : "");
    printf ("    bitrate:            ");
    switch (Stream.audio_header.fields.layer)
    {
      case 3: /* Layer I */
        switch (Stream.audio_header.fields.bitrate_index)
        {
          case 0: printf ("free format\n"); break;
          case 1: printf ("32 kbit/s\n"); break;
          case 2: printf ("64 kbit/s\n"); break;
          case 3: printf ("96 kbit/s\n"); break;
          case 4: printf ("128 kbit/s\n"); break;
          case 5: printf ("160 kbit/s\n"); break;
          case 6: printf ("192 kbit/s\n"); break;
          case 7: printf ("224 kbit/s\n"); break;
          case 8: printf ("256 kbit/s\n"); break;
          case 9: printf ("288 kbit/s\n"); break;
          case 10: printf ("320 kbit/s\n"); break;
          case 11: printf ("352 kbit/s\n"); break;
          case 12: printf ("384 kbit/s\n"); break;
          case 13: printf ("416 kbit/s\n"); break;
          case 14: printf ("448 kbit/s\n"); break;
          case 15: printf ("forbidden\n"); break;
        }
        break;
      case 2: /* Layer II */
        switch (Stream.audio_header.fields.bitrate_index)
        {
          case 0: printf ("free format\n"); break;
          case 1: printf ("32 kbit/s\n"); break;
          case 2: printf ("48 kbit/s\n"); break;
          case 3: printf ("56 kbit/s\n"); break;
          case 4: printf ("64 kbit/s\n"); break;
          case 5: printf ("80 kbit/s\n"); break;
          case 6: printf ("96 kbit/s\n"); break;
          case 7: printf ("112 kbit/s\n"); break;
          case 8: printf ("128 kbit/s\n"); break;
          case 9: printf ("160 kbit/s\n"); break;
          case 10: printf ("192 kbit/s\n"); break;
          case 11: printf ("224 kbit/s\n"); break;
          case 12: printf ("256 kbit/s\n"); break;
          case 13: printf ("320 kbit/s\n"); break;
          case 14: printf ("384 kbit/s\n"); break;
          case 15: printf ("forbidden\n"); break;
        }
        break;
      default: printf ("unknown\n"); break;
    }
    printf ("    sampling_frequency: ");
    switch (Stream.audio_header.fields.sampling_frequency)
    {
      case 0: printf ("44.1 kHz\n"); break;
      case 1: printf ("48 kHz\n"); break;
      case 2: printf ("32 kHz\n"); break;
      case 3: printf ("reserved\n"); break;
    }
    printf ("    padding_bit:        %sadditional slot\n", Stream.audio_header.fields.padding_bit ? "" : "no ");
    printf ("    private_bit:        %01X\n", Stream.audio_header.fields.private_bit);
    printf ("    mode:               ");
    switch (Stream.audio_header.fields.mode)
    {
      case 0: printf ("stereo\n"); break;
      case 1: printf ("joint stereo\n"); break;
      case 2: printf ("dual channel\n"); break;
      case 3: printf ("single channel\n"); break;
    }
    if (Stream.audio_header.fields.mode == 1) /* has meaning in joint stereo mode only */
    {
      printf ("    mode_extension:     ");
      switch (Stream.audio_header.fields.mode_extension)
      {
        case 0: printf ("subbands 4-31 in intensity stereo, bound=4\n"); break;
        case 1: printf ("subbands 8-31 in intensity stereo, bound=8\n"); break;
        case 2: printf ("subbands 12-31 in intensity stereo, bound=12\n"); break;
        case 3: printf ("subbands 16-31 in intensity stereo, bound=16\n"); break;
      }
    }
    printf ("    copyright:          %s\n", Stream.audio_header.fields.copyright ? "copyright protected" : "no copyright");
    printf ("    original/copy:      %s\n", Stream.audio_header.fields.original_copy ? "original" : "copy");
    printf ("    emphasis:           ");
    switch (Stream.audio_header.fields.emphasis)
    {
      case 0: printf ("none\n"); break;
      case 1: printf ("50/15 microseconds\n"); break;
      case 2: printf ("reserved\n"); break;
      case 3: printf ("CCITT J.17\n"); break;
    }
  }
  
  return e;
}

/******	CLI_TVAspect() *****************************************************

Purpose:	Configures a new TV aspect ratio
In:		TV aspect string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVAspect (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "4:3"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "16:9"))
  {
    value = 1;
  }
  else
  {
    e = Mess_GenerateError ("Err_BadAspect", 0, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "TVAspectRatio", &value, 0);
  }
  
  return e;
}

/******	CLI_TVAspect_Status() **********************************************

Purpose:	Displays currently configured TV aspect ratio

***************************************************************************/

void CLI_TVAspect_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "TVAspectRatio", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVAspect   4:3\n");
      break;
    case 1:
      printf ("TVAspect   16:9\n");
      break;
    default:
      printf ("TVAspect   unknown\n");
      break;
  }
}

/******	CLI_TVWSS() ********************************************************

Purpose:	Configures a new TV widescreen switching state
In:		On/off string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVWSS (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "off"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "on"))
  {
    value = 1;
  }
  else
  {
    e = Mess_GenerateError ("SMPDTVW", 0, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "WideScreenSignalling", &value, 0);
  }
  
  return e;
}

/******	CLI_TVWSS_Status() *************************************************

Purpose:	Displays currently configured TV widescreen switching state

***************************************************************************/

void CLI_TVWSS_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "WideScreenSignalling", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVWSS      off\n");
      break;
    case 1:
      printf ("TVWSS      on\n");
      break;
    default:
      printf ("TVWSS      unknown\n");
      break;
  }
}

/******	CLI_TVViewingMode() ************************************************

Purpose:	Configures a new TV viewing mode
In:		Mode string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVViewingMode (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "Box"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "Zoom"))
  {
    value = 2;
  }
  else if (static_MatchStrings (arg_string, "Stretch"))
  {
    value = 3;
  }
  else
  {
    e = Mess_GenerateError ("Err_BadViewingMode", 0, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "TVViewingMode", &value, 0);
  }
  
  return e;
}

/******	CLI_TVViewingMode_Status() *****************************************

Purpose:	Displays currently configured TV viewing mode

***************************************************************************/

void CLI_TVViewingMode_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "TVViewingMode", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVViewingMode Box\n");
      break;
    case 2:
      printf ("TVViewingMode Zoom\n");
      break;
    case 3:
      printf ("TVViewingMode Stretch\n");
      break;
    default:
      printf ("TVViewingMode unknown\n");
      break;
  }
}

/******	CLI_Read3520() *****************************************************

Purpose:	Handles *Read3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Read3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDR35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    value = * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        );
    printf ("%02X\n", value);
  }
  return e;
}

/******	CLI_Write3520() ****************************************************

Purpose:	Handles *Write3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Write3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDW35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    arg_string--;
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &value);
  }
  if (!e)
  {
    * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        ) = value;
  }
  return e;
}

/*********************/
/* Private functions */
/*********************/

/******	static_MatchStrings() **********************************************

Purpose:	Case insensitive control-terminated string compare
In:		Two string pointers
Out:		|true| if they match

***************************************************************************/

static bool static_MatchStrings (const char *s1, const char *s2)
{
  unsigned int i = 0;
  bool match = false;
  do
  {
    if ((s1[i] < ' ') ^ (s2[i] < ' '))
    {
      break;
    }
    else if ((s1[i] < ' ') && (s2[i] < ' '))
    {
      match = true;
    }
    else if (toupper(s1[i]) != toupper(s2[i]))
    {
      break;
    }
    i++;
  }
  while (!match);
  return match;
}
