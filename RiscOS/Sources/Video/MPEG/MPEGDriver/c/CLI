/******	CLI.c **************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Command line interface

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
17/09/1999	BJGA	Created
08/11/1999	BJGA	Added Read3520() and Write3520()
22/11/1999	BJGA	Implemented a basic version of VideoInfo
07/12/1999	BJGA	Added audio stats to *VideoInfo
28/01/2000	BJGA	*VideoInfo now outputs full audio header info
02/02/2000	BJGA	Fix for sillies in *VideoInfo

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "MPEG/MPEG2cCard.h"

#include "CLI.h"
#include "Defs.h"
#include "Mess.h"
#include "Module.h"
#include "Types.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static void static_OutputAVData (a_v_state_t *av);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/********************/
/* Public functions */
/********************/

/******	CLI_VideoInfo() ****************************************************

Purpose:	Handles *VideoInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_VideoInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("Video:\n");
  static_OutputAVData (&Stream.video);
  printf ("\nAudio:\n");
  static_OutputAVData (&Stream.audio);
  printf ("\nAudio header:\n");
  printf ("syncword:           %03X\n", Stream.audio_header.fields.syncword);
  printf ("ID:                 %s\n", Stream.audio_header.fields.ID ? "MPEG-1" : "MPEG-2 (not supported)");
  printf ("layer:              ");
  switch (Stream.audio_header.fields.layer)
  {
    case 0: printf ("reserved\n"); break;
    case 1: printf ("Layer III (not supported)\n"); break;
    case 2: printf ("Layer II\n"); break;
    case 3: printf ("Layer I\n"); break;
  }
  printf ("protection_bit:     %sredundancy\n", Stream.audio_header.fields.protection_bit ? "no " : "");
  printf ("bitrate_index:      ");
  switch (Stream.audio_header.fields.layer)
  {
    case 3: /* Layer I */
      switch (Stream.audio_header.fields.bitrate_index)
      {
        case 0: printf ("free format\n"); break;
        case 1: printf ("32 kbit/s\n"); break;
        case 2: printf ("64 kbit/s\n"); break;
        case 3: printf ("96 kbit/s\n"); break;
        case 4: printf ("128 kbit/s\n"); break;
        case 5: printf ("160 kbit/s\n"); break;
        case 6: printf ("192 kbit/s\n"); break;
        case 7: printf ("224 kbit/s\n"); break;
        case 8: printf ("256 kbit/s\n"); break;
        case 9: printf ("288 kbit/s\n"); break;
        case 10: printf ("320 kbit/s\n"); break;
        case 11: printf ("352 kbit/s\n"); break;
        case 12: printf ("384 kbit/s\n"); break;
        case 13: printf ("416 kbit/s\n"); break;
        case 14: printf ("448 kbit/s\n"); break;
        case 15: printf ("forbidden\n"); break;
      }
      break;
    case 2: /* Layer II */
      switch (Stream.audio_header.fields.bitrate_index)
      {
        case 0: printf ("free format\n"); break;
        case 1: printf ("32 kbit/s\n"); break;
        case 2: printf ("48 kbit/s\n"); break;
        case 3: printf ("56 kbit/s\n"); break;
        case 4: printf ("64 kbit/s\n"); break;
        case 5: printf ("80 kbit/s\n"); break;
        case 6: printf ("96 kbit/s\n"); break;
        case 7: printf ("112 kbit/s\n"); break;
        case 8: printf ("128 kbit/s\n"); break;
        case 9: printf ("160 kbit/s\n"); break;
        case 10: printf ("192 kbit/s\n"); break;
        case 11: printf ("224 kbit/s\n"); break;
        case 12: printf ("256 kbit/s\n"); break;
        case 13: printf ("320 kbit/s\n"); break;
        case 14: printf ("384 kbit/s\n"); break;
        case 15: printf ("forbidden\n"); break;
      }
      break;
    default: printf ("unknown\n"); break;
  }
  printf ("sampling_frequency: ");
  switch (Stream.audio_header.fields.sampling_frequency)
  {
    case 0: printf ("44.1 kHz\n"); break;
    case 1: printf ("48 kHz\n"); break;
    case 2: printf ("32 kHz\n"); break;
    case 3: printf ("reserved\n"); break;
  }
  printf ("padding_bit:        %sadditional slot\n", Stream.audio_header.fields.padding_bit ? "" : "no ");
  printf ("private_bit:        %01X\n", Stream.audio_header.fields.private_bit);
  printf ("mode:               ");
  switch (Stream.audio_header.fields.mode)
  {
    case 0: printf ("stereo\n"); break;
    case 1: printf ("joint stereo\n"); break;
    case 2: printf ("dual channel\n"); break;
    case 3: printf ("single channel\n"); break;
  }
  if (Stream.audio_header.fields.mode == 1) /* has meaning in joint stereo mode only */
  {
    printf ("mode_extension:     ");
    switch (Stream.audio_header.fields.mode_extension)
    {
      case 0: printf ("subbands 4-31 in intensity stereo, bound=4\n"); break;
      case 1: printf ("subbands 8-31 in intensity stereo, bound=8\n"); break;
      case 2: printf ("subbands 12-31 in intensity stereo, bound=12\n"); break;
      case 3: printf ("subbands 16-31 in intensity stereo, bound=16\n"); break;
    }
  }
  printf ("copyright:          %s\n", Stream.audio_header.fields.copyright ? "copyright protected" : "no copyright");
  printf ("original/copy:      %s\n", Stream.audio_header.fields.original_copy ? "original" : "copy");
  printf ("emphasis:           ");
  switch (Stream.audio_header.fields.emphasis)
  {
    case 0: printf ("none\n"); break;
    case 1: printf ("50/15 microseconds\n"); break;
    case 2: printf ("reserved\n"); break;
    case 3: printf ("CCITT J.17\n"); break;
  }
  return e;
}

/******	CLI_Read3520() *****************************************************

Purpose:	Handles *Read3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Read3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDR35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    value = * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        );
    printf ("%02X\n", value);
  }
  return e;
}

/******	CLI_Write3520() ****************************************************

Purpose:	Handles *Write3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Write3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDW35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    arg_string--;
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &value);
  }
  if (!e)
  {
    * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        ) = value;
  }
  return e;
}

/*********************/
/* Private functions */
/*********************/

/******	static_OutputAVData() **********************************************

Purpose:	Prints out *VideoInfo information pertaining to either
		Stream.video or Stream.audio
In:		Pointer to Stream.video or Stream.audio

***************************************************************************/

static void static_OutputAVData (a_v_state_t *av)
{
  printf ("                       Since open  Since reset\n");
  printf ("Bytes received:        %10d   %10d\n", av->since_open.amount_received, av->since_reset.amount_received);
  printf ("Bytes sent to 3520:    %10d   %10d\n", av->since_open.amount_sent, av->since_reset.amount_sent);
  printf ("Slows/repeats:         %10d   %10d\n", av->since_open.slows, av->since_reset.slows);
  printf ("Fasts/skips:           %10d   %10d\n", av->since_open.fasts, av->since_reset.fasts);
  printf ("Stalls:                %10d   %10d\n", av->since_open.stalls, av->since_reset.stalls);
  printf ("Underruns:             %10d   %10d\n", av->since_open.underruns, av->since_reset.underruns);
  printf ("Picture decode errors: %10d   %10d\n", av->since_open.picture_decode_errors, av->since_reset.picture_decode_errors);
  printf ("Severe errors:         %10d   %10d\n", av->since_open.severe_errors, av->since_reset.severe_errors);
  printf ("Pipeline errors:       %10d   %10d\n", av->since_open.pipeline_errors, av->since_reset.pipeline_errors);  
}
