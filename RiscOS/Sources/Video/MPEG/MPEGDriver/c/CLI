/******	CLI.c **************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Command line interface

Copyright 1999-2000 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
17/09/1999	BJGA	Created
08/11/1999	BJGA	Added Read3520() and Write3520()
22/11/1999	BJGA	Implemented a basic version of VideoInfo
07/12/1999	BJGA	Added audio stats to *VideoInfo
28/01/2000	BJGA	*VideoInfo now outputs full audio header info
02/02/2000	BJGA	Fix for sillies in *VideoInfo
15/02/2000	BJGA	Now outputs video header information, and audio error counts
18/02/2000	BJGA	No longer prints garbage header details if there was no
			video/audio (as appropriate) in the most recently opened stream
27/03/2000	BJGA	Now outputs counts of PES packets and PTSs and the first PTS for
			each of video and audio, and also audio frame-sync losses
02/05/2000	BJGA	Split *AudioInfo from *VideoInfo; implemented *Configure commands
11/05/2000	BJGA	Bytecounts now have to have dedicated printing code, because
			they're held as 64-bit integers; prefill/open/closing/close state and
			slow-motion speed are now output; allocated error numbers now used
26/05/2000	BJGA	Implemented *VideoSSave
13/06/2000	BJGA	Implemented *PacketInfo
20/06/2000	BJGA	New "sequence header search" video state catered for;
			lipsync error in *PacketInfo now given as a signed multiple of 1 frame time

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "Global/Sprite.h"
#include "MPEG/MPEG2cCard.h"
#include "NVRAM.h"

#include "CLI.h"
#include "Defs.h"
#include "DivRem64.h"
#include "Mess.h"
#include "Module.h"
#include "Registers.h"
#include "Types.h"
#include "Video.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

static bool static_MatchStrings (const char *s1, const char *s2);
static void static_Print64 (long_long value);

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/********************/
/* Public functions */
/********************/

/******	CLI_VideoInfo() ****************************************************

Purpose:	Handles *VideoInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_VideoInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("                           Since open    Since reset\n");
  printf ("Bytes received:       ");
  static_Print64 (Stream.video.since_open.amount_received);
  static_Print64 (Stream.video.since_reset.amount_received);
  printf ("\n");
  printf ("Bytes sent to 3520:   ");
  static_Print64 (Stream.video.since_open.amount_sent);
  static_Print64 (Stream.video.since_reset.amount_sent);
  printf ("\n");
  printf ("PES packets sent:          %10u     %10u\n", Stream.video.since_open.PES_packets_sent, Stream.video.since_reset.PES_packets_sent);
  printf ("PTSs sent:                 %10u     %10u\n", Stream.video.since_open.PTSs_in, Stream.video.since_reset.PTSs_in);
  printf ("PTSs decoded:              %10u     %10u\n", Stream.video.since_open.PTSs_out, Stream.video.since_reset.PTSs_out);
  printf ("Frame repeats:             %10u     %10u\n", Stream.video.since_open.slows, Stream.video.since_reset.slows);
  printf ("Frame skips:               %10u     %10u\n", Stream.video.since_open.fasts, Stream.video.since_reset.fasts);
  printf ("Stalls:                    %10u     %10u\n", Stream.video.since_open.stalls, Stream.video.since_reset.stalls);
  printf ("Picture decode errors:     %10u     %10u\n", Stream.video.since_open.picture_decode_errors, Stream.video.since_reset.picture_decode_errors);
  printf ("Severe errors:             %10u     %10u\n", Stream.video.since_open.severe_errors, Stream.video.since_reset.severe_errors);
  printf ("Pipeline errors:           %10u     %10u\n", Stream.video.since_open.pipeline_errors, Stream.video.since_reset.pipeline_errors);  
  printf ("Underruns:                 %10u     %10u\n", Stream.video.since_open.underruns, Stream.video.since_reset.underruns);
  printf ("Software auto-resets:      %10u     %10u\n", Stream.video.since_open.internal_resets, Stream.video.since_reset.internal_resets);
  printf ("\n");
  
  printf ("State:                          ");
  switch (Stream.video.state)
  {
    case stream_prefilling:
      printf ("Prefill (");
      switch (Stream.video.prefill_state)
      {
        case ps_searching_for_first_PES_header:
          printf ("searching for first PES header)\n");
          break;
        case ps_searching_for_first_sequence_header:
          printf ("searching for first sequence header)\n");
          break;
        case ps_initialising:
          printf ("reaching prefill threshold)\n");
          break;
        case ps_pre_decoding:
          printf ("decoding reference frames)\n");
          break;
        case ps_waiting_for_play_command:
          printf ("waiting for audio to complete prefill)\n");
          break;
        case ps_waiting_for_presentation_start:
          printf ("synchronising with VSyncs and audio)\n");
          break;
        default:
          printf ("unknown)\n");
          break;
      }
      break;
    case stream_open:
      printf ("Open\n");
      break;
    case stream_closing:
      printf ("Closing\n");
      break;
    case stream_closed:
      printf ("Closed\n");
      break;
    default:
      printf ("Unknown\n");
      break;
  }
  
  printf ("Slow-motion speed:              %d\n", Stream.video.speed_indicator);
  
  printf ("First PTS received:             ");
  if (Stream.video.first_PTS.msb & 0xFE)
  {
    printf ("None\n");
  }
  else
  {
    printf ("%1X%08X\n", Stream.video.first_PTS.msb, Stream.video.first_PTS.lsw);
  }
  
  
  if (Stream.display_frames == NULL)
  {
    printf ("\nNo video header information available\n");
  }
  else
  {
    unsigned char frame_centre_offset;
    unsigned char number_of_frame_centre_offsets = Stream.display_frames->seq.progressive_sequence
      ? (Stream.display_frames->repeat_first_field ? (Stream.display_frames->top_field_first ? 3 : 2) : 1)
      : (Stream.display_frames->repeat_first_field ? 3 : 2); /* pairs of field pictures have been amalgamated by this point */
    
    printf ("\nSequence headers information:\n");
    printf ("    standard:                   %s\n", Stream.display_frames->seq.mpeg2 ? "MPEG-2" : "MPEG-1");
    printf ("    coded size:                 X:%4u Y:%4u aspect:%2u.%04u:1\n",
      Stream.display_frames->seq.coded_horizontal_size,
      Stream.display_frames->seq.coded_vertical_size,
      Stream.display_frames->seq.coded_aspect_ratio >> 16,
      ((Stream.display_frames->seq.coded_aspect_ratio & 0xFFFF) * 10000) >> 16);
    printf ("    display size:               X:%4u Y:%4u aspect:%2u.%04u:1\n",
      Stream.display_frames->seq.display_horizontal_size,
      Stream.display_frames->seq.display_vertical_size,
      Stream.display_frames->seq.display_aspect_ratio >> 16,
      ((Stream.display_frames->seq.display_aspect_ratio & 0xFFFF) * 10000) >> 16);
    printf ("    frame rate:                 %2u.%03u Hz\n", Stream.display_frames->seq.frame_rate / 1000, Stream.display_frames->seq.frame_rate % 1000);
    printf ("    bitrate:                    %u.%04u Mbit/s\n", Stream.display_frames->seq.bit_rate / 2500, Stream.display_frames->seq.bit_rate % 2500 * 4);
    printf ("    vbv_buffer_size:            %u Kbytes\n", Stream.display_frames->seq.vbv_buffer_size * 16);
    printf ("    profile/level:              ");
    {
      unsigned char escape_bit = (Stream.display_frames->seq.profile_and_level_indication & 0x80) >> 7;
      unsigned char profile = (Stream.display_frames->seq.profile_and_level_indication & 0x70) >> 4;
      unsigned char level = Stream.display_frames->seq.profile_and_level_indication & 0x0F;
      if (escape_bit == 1 ||
          profile == 0 ||
          profile > 5 ||
          (level & 1) == 1 ||
          level < 4 ||
          level > 10)
      {
        printf ("reserved\n");
      }
      else
      {
        switch (profile)
        {
          case 1: printf ("high profile (not supported) at "); break;
          case 2: printf ("spatially scalable profile (not supported) at "); break;
          case 3: printf ("SNR scalable profile (not supported) at "); break;
          case 4: printf ("main profile at "); break;
          case 5: printf ("simple profile at "); break;
        }
        switch (level)
        {
          case 4: printf ("high level (not supported)\n"); break;
          case 6: printf ("high 1440 level (not supported)\n"); break;
          case 8: printf ("main level\n"); break;
          case 10: printf ("low level\n"); break;
        }
      }
    }
    printf ("    progressive_sequence:       %u\n", Stream.display_frames->seq.progressive_sequence);
    printf ("    chroma_format:              ");
    switch (Stream.display_frames->seq.chroma_format)
    {
      case 0: printf ("reserved\n"); break;
      case 1: printf ("4:2:0\n"); break;
      case 2: printf ("4:2:2\n"); break;
      case 3: printf ("4:4:4\n"); break;
    }
    printf ("    low_delay:                  %u\n", Stream.display_frames->seq.low_delay);
    printf ("    video_format:               ");
    switch (Stream.display_frames->seq.video_format)
    {
      case 0: printf ("component\n"); break;
      case 1: printf ("PAL\n"); break;
      case 2: printf ("NTSC\n"); break;
      case 3: printf ("SECAM\n"); break;
      case 4: printf ("MAC\n"); break;
      case 5: printf ("unspecified\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    colour_primaries:           ");
    switch (Stream.display_frames->seq.colour_primaries)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("ITU-R BT.470-2 System M\n"); break;
      case 5: printf ("ITU-R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 240M\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    transfer_characteristics:   ");
    switch (Stream.display_frames->seq.transfer_characteristics)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("ITU-R BT.470-2 System M\n"); break;
      case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 250M\n"); break;
      case 8: printf ("linear\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    matrix_coefficients:        ");
    switch (Stream.display_frames->seq.matrix_coefficients)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("ITU-R BT.709\n"); break;
      case 2: printf ("unspecified\n"); break;
      case 4: printf ("FCC\n"); break;
      case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
      case 6: printf ("SMPTE 170M\n"); break;
      case 7: printf ("SMPTE 250M\n"); break;
      default: printf ("reserved\n"); break;
    }
    
    printf ("\nGOP header information:\n");
    printf ("    time_code:                  %02uh %02um %02us %02up\n",
      (Stream.display_frames->gop.time_code & 0xF10000) >> 19,
      (Stream.display_frames->gop.time_code & 0x07E000) >> 13,
      (Stream.display_frames->gop.time_code & 0x000FC0) >> 6,
      (Stream.display_frames->gop.time_code & 0x00003F) >> 0);
    printf ("    closed_gop:                 %u\n", Stream.display_frames->gop.closed_gop);
    printf ("    broken_link:                %u\n", Stream.display_frames->gop.broken_link);
    
    printf ("\nPicture headers information:\n");
    printf ("    temporal_reference:         %u\n", Stream.display_frames->temporal_reference);
    printf ("    picture_coding_type:        ");
    switch (Stream.display_frames->lastpic->picture_coding_type)
    {
      case 0: printf ("forbidden\n"); break;
      case 1: printf ("I\n"); break;
      case 2: printf ("P\n"); break;
      case 3: printf ("B\n"); break;
      case 4: printf ("D (not supported)\n"); break;
      default: printf ("reserved\n"); break;
    }
    printf ("    vbv_delay:                  %u / 90kHz\n", Stream.display_frames->lastpic->vbv_delay);
    printf ("    f_code[s][t]:               %01X %01X %01X %01X\n",
      Stream.display_frames->lastpic->forward_horizontal_f_code,
      Stream.display_frames->lastpic->forward_vertical_f_code,
      Stream.display_frames->lastpic->backward_horizontal_f_code,
      Stream.display_frames->lastpic->backward_vertical_f_code);
    printf ("    intra_dc_precision:         %u bits\n", Stream.display_frames->lastpic->intra_dc_precision + 8);
    printf ("    picture_structure:          %s pictures\n",
      (Stream.display_frames->lastpic->picture_structure == 1 || Stream.display_frames->lastpic->picture_structure == 2) ? "field" : "frame");
    printf ("    top_field_first:            %u\n", Stream.display_frames->top_field_first);
    printf ("    frame_pred_frame_dct:       %u\n", Stream.display_frames->lastpic->picture_flags.bits.frame_pred_frame_dct);
    printf ("    concealment_motion_vectors: %u\n", Stream.display_frames->lastpic->picture_flags.bits.concealment_motion_vectors);
    printf ("    q_scale_type:               %u\n", Stream.display_frames->lastpic->picture_flags.bits.q_scale_type);
    printf ("    intra_vlc_format:           %u\n", Stream.display_frames->lastpic->picture_flags.bits.intra_vlc_format);
    printf ("    alternate_scan:             %u\n", Stream.display_frames->lastpic->picture_flags.bits.alternate_scan);
    printf ("    repeat_first_field:         %u\n", Stream.display_frames->repeat_first_field);
    printf ("    progressive_frame:          %u\n", Stream.display_frames->progressive_frame);
    for (frame_centre_offset = 0; frame_centre_offset < number_of_frame_centre_offsets; frame_centre_offset ++)
    {
      printf ("    %s(%+05d.%04d,%+05d.%04d)\n", frame_centre_offset ? "                            " : "frame centre offset(s):     ",
        Stream.display_frames->frame_centre_horizontal_offset [frame_centre_offset] / 16,
        abs (Stream.display_frames->frame_centre_horizontal_offset [frame_centre_offset] % 16) * 625,
        Stream.display_frames->frame_centre_vertical_offset [frame_centre_offset] / 16,
        abs (Stream.display_frames->frame_centre_vertical_offset [frame_centre_offset] % 16) * 625);
    }
    printf ("    active format:              %d\n", Stream.display_frames->lastpic->active_format);
    printf ("    active area:                X:%4u Y:%4u aspect:%2u.%04u:1 %s\n",
      Stream.active_horizontal_size,
      Stream.active_vertical_size,
      Stream.active_aspect_ratio >> 16,
      ((Stream.active_aspect_ratio & 0xFFFF) * 10000) >> 16,
      Stream.active_area_is_at_top ? "top" : "centre");
    printf ("    protected area:             X:%4u Y:%4u aspect:%2u.%04u:1 %s\n",
      Stream.protected_horizontal_size,
      Stream.protected_vertical_size,
      Stream.protected_aspect_ratio >> 16,
      ((Stream.protected_aspect_ratio & 0xFFFF) * 10000) >> 16,
      Stream.active_area_is_at_top ? "top" : "centre");
  }
  
  return e;
}

/******	CLI_AudioInfo() ****************************************************

Purpose:	Handles *AudioInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_AudioInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("                           Since open    Since reset\n");
  printf ("Bytes received:       ");
  static_Print64 (Stream.audio.since_open.amount_received);
  static_Print64 (Stream.audio.since_reset.amount_received);
  printf ("\n");
  printf ("Bytes sent to 3520:   ");
  static_Print64 (Stream.audio.since_open.amount_sent);
  static_Print64 (Stream.audio.since_reset.amount_sent);
  printf ("\n");
  printf ("PES packets sent:          %10u     %10u\n", Stream.audio.since_open.PES_packets_sent, Stream.audio.since_reset.PES_packets_sent);
  printf ("PTSs sent:                 %10u     %10u\n", Stream.audio.since_open.PTSs_in, Stream.audio.since_reset.PTSs_in);
  printf ("PTSs decoded:              %10u     %10u\n", Stream.audio.since_open.PTSs_out, Stream.audio.since_reset.PTSs_out);
  printf ("Slows:                     %10u     %10u\n", Stream.audio.since_open.slows, Stream.audio.since_reset.slows);
  printf ("Fasts:                     %10u     %10u\n", Stream.audio.since_open.fasts, Stream.audio.since_reset.fasts);
  printf ("CRC errors:                %10u     %10u\n", Stream.audio.since_open.crc_errors, Stream.audio.since_reset.crc_errors);
  printf ("Frame sync losses:         %10u     %10u\n", Stream.audio.since_open.sync_losses, Stream.audio.since_reset.sync_losses);
  printf ("Underruns:                 %10u     %10u\n", Stream.audio.since_open.underruns, Stream.audio.since_reset.underruns);
  printf ("\n");
  
  printf ("State:                          ");
  switch (Stream.video.state)
  {
    case stream_prefilling:
      printf ("Prefill (");
      switch (Stream.video.prefill_state)
      {
        case ps_searching_for_first_PES_header:
          printf ("searching for first PES header)\n");
          break;
        case ps_initialising:
          printf ("reaching prefill threshold)\n");
          break;
        case ps_waiting_for_play_command:
          printf ("waiting for video to complete prefill)\n");
          break;
        default:
          printf ("unknown)\n");
          break;
      }
      break;
    case stream_open:
      printf ("Open\n");
      break;
    case stream_closing:
      printf ("Closing\n");
      break;
    case stream_closed:
      printf ("Closed\n");
      break;
    default:
      printf ("Unknown\n");
      break;
  }
  
  printf ("First PTS received:             ");
  if (Stream.audio.first_PTS.msb & 0xFE)
  {
    printf ("None\n");
  }
  else
  {
    printf ("%1X%08X\n", Stream.audio.first_PTS.msb, Stream.audio.first_PTS.lsw);
  }
  
  
  if (!Stream.aud_flags.first_header_received)
  {
    printf ("\nNo audio header information available\n");
  }
  else
  {
    printf ("\nHeader information:\n");
    printf ("    ID:                 %s\n", Stream.audio_header.fields.ID ? "MPEG-1" : "MPEG-2 (not supported)");
    printf ("    layer:              ");
    switch (Stream.audio_header.fields.layer)
    {
      case 0: printf ("reserved\n"); break;
      case 1: printf ("Layer III (not supported)\n"); break;
      case 2: printf ("Layer II\n"); break;
      case 3: printf ("Layer I\n"); break;
    }
    printf ("    protection_bit:     %sredundancy\n", Stream.audio_header.fields.protection_bit ? "no " : "");
    printf ("    bitrate:            ");
    switch (Stream.audio_header.fields.layer)
    {
      case 3: /* Layer I */
        switch (Stream.audio_header.fields.bitrate_index)
        {
          case 0: printf ("free format\n"); break;
          case 1: printf ("32 kbit/s\n"); break;
          case 2: printf ("64 kbit/s\n"); break;
          case 3: printf ("96 kbit/s\n"); break;
          case 4: printf ("128 kbit/s\n"); break;
          case 5: printf ("160 kbit/s\n"); break;
          case 6: printf ("192 kbit/s\n"); break;
          case 7: printf ("224 kbit/s\n"); break;
          case 8: printf ("256 kbit/s\n"); break;
          case 9: printf ("288 kbit/s\n"); break;
          case 10: printf ("320 kbit/s\n"); break;
          case 11: printf ("352 kbit/s\n"); break;
          case 12: printf ("384 kbit/s\n"); break;
          case 13: printf ("416 kbit/s\n"); break;
          case 14: printf ("448 kbit/s\n"); break;
          case 15: printf ("forbidden\n"); break;
        }
        break;
      case 2: /* Layer II */
        switch (Stream.audio_header.fields.bitrate_index)
        {
          case 0: printf ("free format\n"); break;
          case 1: printf ("32 kbit/s\n"); break;
          case 2: printf ("48 kbit/s\n"); break;
          case 3: printf ("56 kbit/s\n"); break;
          case 4: printf ("64 kbit/s\n"); break;
          case 5: printf ("80 kbit/s\n"); break;
          case 6: printf ("96 kbit/s\n"); break;
          case 7: printf ("112 kbit/s\n"); break;
          case 8: printf ("128 kbit/s\n"); break;
          case 9: printf ("160 kbit/s\n"); break;
          case 10: printf ("192 kbit/s\n"); break;
          case 11: printf ("224 kbit/s\n"); break;
          case 12: printf ("256 kbit/s\n"); break;
          case 13: printf ("320 kbit/s\n"); break;
          case 14: printf ("384 kbit/s\n"); break;
          case 15: printf ("forbidden\n"); break;
        }
        break;
      default: printf ("unknown\n"); break;
    }
    printf ("    sampling_frequency: ");
    switch (Stream.audio_header.fields.sampling_frequency)
    {
      case 0: printf ("44.1 kHz\n"); break;
      case 1: printf ("48 kHz\n"); break;
      case 2: printf ("32 kHz\n"); break;
      case 3: printf ("reserved\n"); break;
    }
    printf ("    padding_bit:        %sadditional slot\n", Stream.audio_header.fields.padding_bit ? "" : "no ");
    printf ("    private_bit:        %01X\n", Stream.audio_header.fields.private_bit);
    printf ("    mode:               ");
    switch (Stream.audio_header.fields.mode)
    {
      case 0: printf ("stereo\n"); break;
      case 1: printf ("joint stereo\n"); break;
      case 2: printf ("dual channel\n"); break;
      case 3: printf ("single channel\n"); break;
    }
    if (Stream.audio_header.fields.mode == 1) /* has meaning in joint stereo mode only */
    {
      printf ("    mode_extension:     ");
      switch (Stream.audio_header.fields.mode_extension)
      {
        case 0: printf ("subbands 4-31 in intensity stereo, bound=4\n"); break;
        case 1: printf ("subbands 8-31 in intensity stereo, bound=8\n"); break;
        case 2: printf ("subbands 12-31 in intensity stereo, bound=12\n"); break;
        case 3: printf ("subbands 16-31 in intensity stereo, bound=16\n"); break;
      }
    }
    printf ("    copyright:          %s\n", Stream.audio_header.fields.copyright ? "copyright protected" : "no copyright");
    printf ("    original/copy:      %s\n", Stream.audio_header.fields.original_copy ? "original" : "copy");
    printf ("    emphasis:           ");
    switch (Stream.audio_header.fields.emphasis)
    {
      case 0: printf ("none\n"); break;
      case 1: printf ("50/15 microseconds\n"); break;
      case 2: printf ("reserved\n"); break;
      case 3: printf ("CCITT J.17\n"); break;
    }
  }
  
  return e;
}

/******	CLI_PacketInfo() ***************************************************

Purpose:	Handles *PacketInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_PacketInfo (void)
{
  _kernel_oserror *e = NULL;
  bitstream_packet_t *packet;
  unsigned int video_packets = 0;
  unsigned int video_packets_length = 0;
  unsigned int video_in_bitbuffer = (VID_VBL & 0x3FFF) * 256;
  unsigned int audio_packets = 0;
  unsigned int audio_packets_length = 0;
  unsigned int audio_in_bitbuffer = (VID_ABL & 0x3FFF) * 256;
  bool lipsync_error_negative;
  unsigned int lipsync_error_magnitude;
  bool irqs_were_enabled = !_kernel_irqs_disabled ();
  
  if (irqs_were_enabled) _kernel_irqs_off ();
  for (packet = Stream.video.packet_list_head; packet != NULL; packet = packet->link)
  {
    video_packets ++;
    video_packets_length += packet->length;
  }
  for (packet = Stream.audio.packet_list_head; packet != NULL; packet = packet->link)
  {
    audio_packets ++;
    audio_packets_length += packet->length;
  }
  if (irqs_were_enabled) _kernel_irqs_off ();
  
  printf ("Number of video packets:  %d packets\n", video_packets);
  printf ("Video packet data length: %d bytes\n", video_packets_length);
  printf ("Video data in bitbuffer:  %d bytes\n", video_in_bitbuffer);
  
  printf ("Number of audio packets:  %d packets\n", audio_packets);
  printf ("Audio packet data length: %d bytes\n", audio_packets_length);
  printf ("Audio data in bitbuffer:  %d bytes\n", audio_in_bitbuffer);
  
  lipsync_error_negative = ((Stream.video_PTS_error.msb & 1) != 0);
  lipsync_error_magnitude = (lipsync_error_negative ? -Stream.video_PTS_error.lsw : Stream.video_PTS_error.lsw);
  lipsync_error_magnitude /= (Module_Display525_60 ? 300 : 360);
  printf ("Lipsync error: %c%d.%d frames\n", lipsync_error_negative ? '-' : '+', lipsync_error_magnitude / 10, lipsync_error_magnitude % 10);
  
  return e;
}

/******	CLI_VideoSSave() ***************************************************

Purpose:	Handles *VideoSSave
In:		Filename to save sprite to
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_VideoSSave (const char *filename)
{
  _kernel_oserror *e = NULL;
  unsigned int DA_number;
  unsigned int *DA_start;
  bool DA_created = false;
  
  /* Create a dynamic area to hold the sprite temporarily */
  /* Max size required is 16 (sprite area control block) + 44 (sprite control block) + 720*576*4 = 0x19503C */
  e = _swix (OS_DynamicArea, _INR(0,8)|_OUT(1)|_OUT(3), 0, -1, 0x19503C, -1, 1<<7, 0x19503C, 0, 0, "VideoSSave sprite", &DA_number, &DA_start);
  if (!e)
  {
    DA_created = true;
    /* Initialise sprite area in the dynamic area */
    DA_start [0] = 0x19503C;
    DA_start [2] = 16;
    e = _swix (OS_SpriteOp, _INR(0,1), SpriteReason_ClearSprites | 256, DA_start);
  }
  if (!e)
  {
    /* Do the capture */
    e = Video_SWIGetSprite (0, NULL, DA_start, "CapturedMPEG");
  }
  if (!e)
  {
    /* Save the sprite */
    e = _swix (OS_SpriteOp, _INR(0,2), SpriteReason_SaveSpriteFile | 256, DA_start, filename);
  }
  
  if (DA_created)
  {
    /* Remove the temporary dynamic area */
    _swix (OS_DynamicArea, _INR(0,1), 1, DA_number);
  }
  return e;
}

/******	CLI_Read3520() *****************************************************

Purpose:	Handles *Read3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Read3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDR35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    value = * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        );
    printf ("%02X\n", value);
  }
  return e;
}

/******	CLI_Write3520() ****************************************************

Purpose:	Handles *Write3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Write3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDW35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    arg_string--;
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &value);
  }
  if (!e)
  {
    * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        ) = value;
  }
  return e;
}

/******	CLI_TVAspect() *****************************************************

Purpose:	Configures a new TV aspect ratio
In:		TV aspect string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVAspect (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "4:3"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "16:9"))
  {
    value = 1;
  }
  else
  {
    e = Mess_GenerateError ("Err_BadAspect", ErrorNumber_Syntax, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "TVAspectRatio", &value, 0);
  }
  
  return e;
}

/******	CLI_TVAspect_Status() **********************************************

Purpose:	Displays currently configured TV aspect ratio

***************************************************************************/

void CLI_TVAspect_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "TVAspectRatio", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVAspect   4:3\n");
      break;
    case 1:
      printf ("TVAspect   16:9\n");
      break;
    default:
      printf ("TVAspect   unknown\n");
      break;
  }
}

/******	CLI_TVWSS() ********************************************************

Purpose:	Configures a new TV widescreen switching state
In:		On/off string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVWSS (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "off"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "on"))
  {
    value = 1;
  }
  else
  {
    e = Mess_GenerateError ("SMPDTVW", ErrorNumber_Syntax, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "WideScreenSignalling", &value, 0);
  }
  
  return e;
}

/******	CLI_TVWSS_Status() *************************************************

Purpose:	Displays currently configured TV widescreen switching state

***************************************************************************/

void CLI_TVWSS_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "WideScreenSignalling", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVWSS      off\n");
      break;
    case 1:
      printf ("TVWSS      on\n");
      break;
    default:
      printf ("TVWSS      unknown\n");
      break;
  }
}

/******	CLI_TVViewingMode() ************************************************

Purpose:	Configures a new TV viewing mode
In:		Mode string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_TVViewingMode (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  int value;
  
  if (static_MatchStrings (arg_string, "Box"))
  {
    value = 0;
  }
  else if (static_MatchStrings (arg_string, "Zoom"))
  {
    value = 2;
  }
  else if (static_MatchStrings (arg_string, "Stretch"))
  {
    value = 3;
  }
  else
  {
    e = Mess_GenerateError ("Err_BadViewingMode", ErrorNumber_Syntax, 0);
  }
  
  if (!e)
  {
    _swix (NVRAM_Write, _INR(0,2), "TVViewingMode", &value, 0);
  }
  
  return e;
}

/******	CLI_TVViewingMode_Status() *****************************************

Purpose:	Displays currently configured TV viewing mode

***************************************************************************/

void CLI_TVViewingMode_Status (void)
{
  int value = -1;
  _swix (NVRAM_Read, _INR(0,2), "TVViewingMode", &value, 0);
  switch (value)
  {
    case 0:
      printf ("TVViewingMode Box\n");
      break;
    case 2:
      printf ("TVViewingMode Zoom\n");
      break;
    case 3:
      printf ("TVViewingMode Stretch\n");
      break;
    default:
      printf ("TVViewingMode unknown\n");
      break;
  }
}

/*********************/
/* Private functions */
/*********************/

/******	static_MatchStrings() **********************************************

Purpose:	Case insensitive control-terminated string compare
In:		Two string pointers
Out:		|true| if they match

***************************************************************************/

static bool static_MatchStrings (const char *s1, const char *s2)
{
  unsigned int i = 0;
  bool match = false;
  do
  {
    if ((s1[i] < ' ') ^ (s2[i] < ' '))
    {
      break;
    }
    else if ((s1[i] < ' ') && (s2[i] < ' '))
    {
      match = true;
    }
    else if (toupper(s1[i]) != toupper(s2[i]))
    {
      break;
    }
    i++;
  }
  while (!match);
  return match;
}

/******	static_Print64() ***************************************************

Purpose:	Outputs the least significant 15 decimal digits of a 64-bit number
In:		The value to print

***************************************************************************/

static void static_Print64 (long_long value)
{
  char string [21] = "                    "; /* max possible length of a 64-bit number, plus terminator */
  char *p = string + 19; /* current digit pointer */
  long_long remainder;
  const long_long ten = { 10, 0 };
  
  do
  {
    value = DivRem64 (value, ten, &remainder);
    *p-- = remainder.lsw + '0';
  }
  while (value.lsw != 0 || value.msw != 0);
  
  printf ("%s", string + 5); /* ignore first 5 digits (would require stream to be running for a number of years for us to hit them!) */
}
