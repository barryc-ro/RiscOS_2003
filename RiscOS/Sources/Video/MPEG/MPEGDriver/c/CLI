/******	CLI.c **************************************************************

Project:	STB-400
Component:	MPEGDriver
This file:	Command line interface

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
17/09/1999	BJGA	Created
08/11/1999	BJGA	Added Read3520() and Write3520()
22/11/1999	BJGA	Implemented a basic version of VideoInfo
07/12/1999	BJGA	Added audio stats to *VideoInfo
28/01/2000	BJGA	*VideoInfo now outputs full audio header info
02/02/2000	BJGA	Fix for sillies in *VideoInfo
15/02/2000	BJGA	Now outputs video header information, and audio error counts

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "MPEG/MPEG2cCard.h"

#include "CLI.h"
#include "Defs.h"
#include "Mess.h"
#include "Module.h"
#include "Types.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

#ifndef ErrorNumber_Syntax
#define ErrorNumber_Syntax 0xDC
#endif

/********************/
/* Public functions */
/********************/

/******	CLI_VideoInfo() ****************************************************

Purpose:	Handles *VideoInfo
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_VideoInfo (void)
{
  _kernel_oserror *e = NULL;
  printf ("Video:\n");
  printf ("----------------------------------------------\n");
  printf ("                       Since open  Since reset\n");
  printf ("Bytes received:        %10d   %10d\n", Stream.video.since_open.amount_received, Stream.video.since_reset.amount_received);
  printf ("Bytes sent to 3520:    %10d   %10d\n", Stream.video.since_open.amount_sent, Stream.video.since_reset.amount_sent);
  printf ("Frame repeats:         %10d   %10d\n", Stream.video.since_open.slows, Stream.video.since_reset.slows);
  printf ("Frame skips:           %10d   %10d\n", Stream.video.since_open.fasts, Stream.video.since_reset.fasts);
  printf ("Stalls:                %10d   %10d\n", Stream.video.since_open.stalls, Stream.video.since_reset.stalls);
  printf ("Picture decode errors: %10d   %10d\n", Stream.video.since_open.picture_decode_errors, Stream.video.since_reset.picture_decode_errors);
  printf ("Severe errors:         %10d   %10d\n", Stream.video.since_open.severe_errors, Stream.video.since_reset.severe_errors);
  printf ("Pipeline errors:       %10d   %10d\n", Stream.video.since_open.pipeline_errors, Stream.video.since_reset.pipeline_errors);  
  printf ("Underruns:             %10d   %10d\n", Stream.video.since_open.underruns, Stream.video.since_reset.underruns);
  
  
  printf ("\nSequence headers information:\n");
  printf ("    standard:                   %s\n", Stream.display_frames->seq.mpeg2 ? "MPEG-2" : "MPEG-1");
  printf ("    display size:               X:%4d Y:%4d\n", Stream.display_frames->seq.display_horizontal_size, Stream.display_frames->seq.display_vertical_size);
  printf ("    coded size:                 X:%4d Y:%4d\n", Stream.display_frames->seq.coded_horizontal_size, Stream.display_frames->seq.coded_vertical_size);
  printf ("    frame rate:                 %2d.%03d Hz\n", Stream.display_frames->seq.frame_rate / 1000, Stream.display_frames->seq.frame_rate % 1000);
  printf ("    bitrate:                    %d.%04d Mbit/s\n", Stream.display_frames->seq.bit_rate / 2500, Stream.display_frames->seq.bit_rate % 2500 * 4);
  printf ("    vbv_buffer_size:            %d Kbytes\n", Stream.display_frames->seq.vbv_buffer_size * 16);
  printf ("    profile/level:              ");
  {
    unsigned char escape_bit = (Stream.display_frames->seq.profile_and_level_indication & 0x80) >> 7;
    unsigned char profile = (Stream.display_frames->seq.profile_and_level_indication & 0x70) >> 4;
    unsigned char level = Stream.display_frames->seq.profile_and_level_indication & 0x0F;
    if (escape_bit == 1 ||
        profile == 0 ||
        profile > 5 ||
        (level & 1) == 1 ||
        level < 4 ||
        level > 10)
    {
      printf ("reserved\n");
    }
    else
    {
      switch (profile)
      {
        case 1: printf ("high profile (not supported) at "); break;
        case 2: printf ("spatially scalable profile (not supported) at "); break;
        case 3: printf ("SNR scalable profile (not supported) at "); break;
        case 4: printf ("main profile at "); break;
        case 5: printf ("simple profile at "); break;
      }
      switch (level)
      {
        case 4: printf ("high level (not supported)\n"); break;
        case 6: printf ("high 1440 level (not supported)\n"); break;
        case 8: printf ("main level\n"); break;
        case 10: printf ("low level\n"); break;
      }
    }
  }
  printf ("    progressive_sequence:       %d\n", Stream.display_frames->seq.progressive_sequence);
  printf ("    chroma_format:              ");
  switch (Stream.display_frames->seq.chroma_format)
  {
    case 0: printf ("reserved\n"); break;
    case 1: printf ("4:2:0\n"); break;
    case 2: printf ("4:2:2\n"); break;
    case 3: printf ("4:4:4\n"); break;
  }
  printf ("    low_delay:                  %d\n", Stream.display_frames->seq.low_delay);
  printf ("    video_format:               ");
  switch (Stream.display_frames->seq.video_format)
  {
    case 0: printf ("component\n"); break;
    case 1: printf ("PAL\n"); break;
    case 2: printf ("NTSC\n"); break;
    case 3: printf ("SECAM\n"); break;
    case 4: printf ("MAC\n"); break;
    case 5: printf ("unspecified\n"); break;
    default: printf ("reserved\n"); break;
  }
  printf ("    colour_primaries:           ");
  switch (Stream.display_frames->seq.colour_primaries)
  {
    case 0: printf ("forbidden\n"); break;
    case 1: printf ("ITU-R BT.709\n"); break;
    case 2: printf ("unspecified\n"); break;
    case 4: printf ("ITU-R BT.470-2 System M\n"); break;
    case 5: printf ("ITU-R BT.470-2 System B,G\n"); break;
    case 6: printf ("SMPTE 170M\n"); break;
    case 7: printf ("SMPTE 240M\n"); break;
    default: printf ("reserved\n"); break;
  }
  printf ("    transfer_characteristics:   ");
  switch (Stream.display_frames->seq.transfer_characteristics)
  {
    case 0: printf ("forbidden\n"); break;
    case 1: printf ("ITU-R BT.709\n"); break;
    case 2: printf ("unspecified\n"); break;
    case 4: printf ("ITU-R BT.470-2 System M\n"); break;
    case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
    case 6: printf ("SMPTE 170M\n"); break;
    case 7: printf ("SMPTE 250M\n"); break;
    case 8: printf ("linear\n"); break;
    default: printf ("reserved\n"); break;
  }
  printf ("    matrix_coefficients:        ");
  switch (Stream.display_frames->seq.matrix_coefficients)
  {
    case 0: printf ("forbidden\n"); break;
    case 1: printf ("ITU-R BT.709\n"); break;
    case 2: printf ("unspecified\n"); break;
    case 4: printf ("FCC\n"); break;
    case 5: printf ("ITU_R BT.470-2 System B,G\n"); break;
    case 6: printf ("SMPTE 170M\n"); break;
    case 7: printf ("SMPTE 250M\n"); break;
    default: printf ("reserved\n"); break;
  }
  
  printf ("\nGOP header information:\n");
  printf ("    time_code:                  %02dh %02dm %02ds %02dp\n",
    (Stream.display_frames->gop.time_code & 0xF10000) >> 19,
    (Stream.display_frames->gop.time_code & 0x07E000) >> 13,
    (Stream.display_frames->gop.time_code & 0x000FC0) >> 6,
    (Stream.display_frames->gop.time_code & 0x00003F) >> 0);
  printf ("    closed_gop:                 %d\n", Stream.display_frames->gop.closed_gop);
  printf ("    broken_link:                %d\n", Stream.display_frames->gop.broken_link);
  
  printf ("\nPicture headers information:\n");
  printf ("    temporal_reference:         %d\n", Stream.display_frames->temporal_reference);
  printf ("    picture_coding_type:        ");
  switch (Stream.display_frames->lastpic->picture_coding_type)
  {
    case 0: printf ("forbidden\n"); break;
    case 1: printf ("I\n"); break;
    case 2: printf ("P\n"); break;
    case 3: printf ("B\n"); break;
    case 4: printf ("D (not supported)\n"); break;
    default: printf ("reserved\n"); break;
  }
  printf ("    vbv_delay:                  %d / 90kHz\n", Stream.display_frames->lastpic->vbv_delay);
  printf ("    f_code[s][t]:               %01X %01X %01X %01X\n",
    Stream.display_frames->lastpic->forward_horizontal_f_code,
    Stream.display_frames->lastpic->forward_vertical_f_code,
    Stream.display_frames->lastpic->backward_horizontal_f_code,
    Stream.display_frames->lastpic->backward_vertical_f_code);
  printf ("    intra_dc_precision:         %d bits\n", Stream.display_frames->lastpic->intra_dc_precision + 8);
  printf ("    picture_structure:          %s pictures\n",
    (Stream.display_frames->lastpic->picture_structure == 1 || Stream.display_frames->lastpic->picture_structure == 2) ? "field" : "frame");
  printf ("    top_field_first:            %d\n", Stream.display_frames->top_field_first);
  printf ("    frame_pred_frame_dct:       %d\n", Stream.display_frames->lastpic->picture_flags.bits.frame_pred_frame_dct);
  printf ("    concealment_motion_vectors: %d\n", Stream.display_frames->lastpic->picture_flags.bits.concealment_motion_vectors);
  printf ("    q_scale_type:               %d\n", Stream.display_frames->lastpic->picture_flags.bits.q_scale_type);
  printf ("    intra_vlc_format:           %d\n", Stream.display_frames->lastpic->picture_flags.bits.intra_vlc_format);
  printf ("    alternate_scan:             %d\n", Stream.display_frames->lastpic->picture_flags.bits.alternate_scan);
  printf ("    repeat_first_field:         %d\n", Stream.display_frames->repeat_first_field);
  printf ("    progressive_frame:          %d\n", Stream.display_frames->progressive_frame);
  printf ("    active format:              ");
  if (Stream.display_frames->lastpic->active_format > 15)
  {
    printf ("not specified\n");
  }
  else
  {
    printf ("%d\n", Stream.display_frames->lastpic->active_format);
  }
  printf ("    active area size:           X:%4d Y:%4d\n", Stream.display_frames->seq.active_horizontal_size, Stream.display_frames->seq.active_vertical_size);
  printf ("    protected area size:        X:%4d Y:%4d\n", Stream.display_frames->seq.protected_horizontal_size, Stream.display_frames->seq.protected_vertical_size);
  
  
  printf ("\nAudio:\n");
  printf ("----------------------------------------------\n");
  printf ("                       Since open  Since reset\n");
  printf ("Bytes received:        %10d   %10d\n", Stream.audio.since_open.amount_received, Stream.audio.since_reset.amount_received);
  printf ("Bytes sent to 3520:    %10d   %10d\n", Stream.audio.since_open.amount_sent, Stream.audio.since_reset.amount_sent);
  printf ("Slows:                 %10d   %10d\n", Stream.audio.since_open.slows, Stream.audio.since_reset.slows);
  printf ("Fasts:                 %10d   %10d\n", Stream.audio.since_open.fasts, Stream.audio.since_reset.fasts);
  printf ("CRC errors:            %10d   %10d\n", Stream.audio.since_open.crc_errors, Stream.audio.since_reset.crc_errors);
  printf ("Underruns:             %10d   %10d\n", Stream.audio.since_open.underruns, Stream.audio.since_reset.underruns);
  
  
  printf ("\nHeader information:\n");
  printf ("    ID:                 %s\n", Stream.audio_header.fields.ID ? "MPEG-1" : "MPEG-2 (not supported)");
  printf ("    layer:              ");
  switch (Stream.audio_header.fields.layer)
  {
    case 0: printf ("reserved\n"); break;
    case 1: printf ("Layer III (not supported)\n"); break;
    case 2: printf ("Layer II\n"); break;
    case 3: printf ("Layer I\n"); break;
  }
  printf ("    protection_bit:     %sredundancy\n", Stream.audio_header.fields.protection_bit ? "no " : "");
  printf ("    bitrate:            ");
  switch (Stream.audio_header.fields.layer)
  {
    case 3: /* Layer I */
      switch (Stream.audio_header.fields.bitrate_index)
      {
        case 0: printf ("free format\n"); break;
        case 1: printf ("32 kbit/s\n"); break;
        case 2: printf ("64 kbit/s\n"); break;
        case 3: printf ("96 kbit/s\n"); break;
        case 4: printf ("128 kbit/s\n"); break;
        case 5: printf ("160 kbit/s\n"); break;
        case 6: printf ("192 kbit/s\n"); break;
        case 7: printf ("224 kbit/s\n"); break;
        case 8: printf ("256 kbit/s\n"); break;
        case 9: printf ("288 kbit/s\n"); break;
        case 10: printf ("320 kbit/s\n"); break;
        case 11: printf ("352 kbit/s\n"); break;
        case 12: printf ("384 kbit/s\n"); break;
        case 13: printf ("416 kbit/s\n"); break;
        case 14: printf ("448 kbit/s\n"); break;
        case 15: printf ("forbidden\n"); break;
      }
      break;
    case 2: /* Layer II */
      switch (Stream.audio_header.fields.bitrate_index)
      {
        case 0: printf ("free format\n"); break;
        case 1: printf ("32 kbit/s\n"); break;
        case 2: printf ("48 kbit/s\n"); break;
        case 3: printf ("56 kbit/s\n"); break;
        case 4: printf ("64 kbit/s\n"); break;
        case 5: printf ("80 kbit/s\n"); break;
        case 6: printf ("96 kbit/s\n"); break;
        case 7: printf ("112 kbit/s\n"); break;
        case 8: printf ("128 kbit/s\n"); break;
        case 9: printf ("160 kbit/s\n"); break;
        case 10: printf ("192 kbit/s\n"); break;
        case 11: printf ("224 kbit/s\n"); break;
        case 12: printf ("256 kbit/s\n"); break;
        case 13: printf ("320 kbit/s\n"); break;
        case 14: printf ("384 kbit/s\n"); break;
        case 15: printf ("forbidden\n"); break;
      }
      break;
    default: printf ("unknown\n"); break;
  }
  printf ("    sampling_frequency: ");
  switch (Stream.audio_header.fields.sampling_frequency)
  {
    case 0: printf ("44.1 kHz\n"); break;
    case 1: printf ("48 kHz\n"); break;
    case 2: printf ("32 kHz\n"); break;
    case 3: printf ("reserved\n"); break;
  }
  printf ("    padding_bit:        %sadditional slot\n", Stream.audio_header.fields.padding_bit ? "" : "no ");
  printf ("    private_bit:        %01X\n", Stream.audio_header.fields.private_bit);
  printf ("    mode:               ");
  switch (Stream.audio_header.fields.mode)
  {
    case 0: printf ("stereo\n"); break;
    case 1: printf ("joint stereo\n"); break;
    case 2: printf ("dual channel\n"); break;
    case 3: printf ("single channel\n"); break;
  }
  if (Stream.audio_header.fields.mode == 1) /* has meaning in joint stereo mode only */
  {
    printf ("    mode_extension:     ");
    switch (Stream.audio_header.fields.mode_extension)
    {
      case 0: printf ("subbands 4-31 in intensity stereo, bound=4\n"); break;
      case 1: printf ("subbands 8-31 in intensity stereo, bound=8\n"); break;
      case 2: printf ("subbands 12-31 in intensity stereo, bound=12\n"); break;
      case 3: printf ("subbands 16-31 in intensity stereo, bound=16\n"); break;
    }
  }
  printf ("    copyright:          %s\n", Stream.audio_header.fields.copyright ? "copyright protected" : "no copyright");
  printf ("    original/copy:      %s\n", Stream.audio_header.fields.original_copy ? "original" : "copy");
  printf ("    emphasis:           ");
  switch (Stream.audio_header.fields.emphasis)
  {
    case 0: printf ("none\n"); break;
    case 1: printf ("50/15 microseconds\n"); break;
    case 2: printf ("reserved\n"); break;
    case 3: printf ("CCITT J.17\n"); break;
  }
  return e;
}

/******	CLI_Read3520() *****************************************************

Purpose:	Handles *Read3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Read3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDR35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    value = * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        );
    printf ("%02X\n", value);
  }
  return e;
}

/******	CLI_Write3520() ****************************************************

Purpose:	Handles *Write3520
In:		Argument string
Out:		Pointer to error block

***************************************************************************/

_kernel_oserror *CLI_Write3520 (const char *arg_string)
{
  _kernel_oserror *e = NULL;
  bool video = false;
  unsigned char reg = 0;
  unsigned char value = 0;
  switch (*arg_string)
  {
    case 'V':
    case 'v':
      video = true;
      break;
    case 'A':
    case 'a':
      video = false;
      break;
    default:
      e = Mess_GenerateError ("SMPDW35", ErrorNumber_Syntax, 0);
      break;
  }
  if (!e)
  {
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &reg);
  }
  if (!e)
  {
    arg_string--;
    while (*++arg_string == ' ');
    e = _swix (OS_ReadUnsigned, _INR(0,1)|_OUTR(1,2), 16, arg_string, &arg_string, &value);
  }
  if (!e)
  {
    * (volatile unsigned char *) (
        MPEG_Base_Address +
        (video ? Offset_MPEG_Video_Registers : Offset_MPEG_Audio_Registers) +
        (reg << MPEG_Register_Address_Shift)
        ) = value;
  }
  return e;
}
