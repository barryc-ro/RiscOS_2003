; > Module
; Source for MPEG 2 Transport Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 10-Nov-94  TMD  1.24          Started work adapting from MPEGControl module
; 15-Nov-94  TMD  1.25          Major restructure after discovering zero-length-field PES packets (and the fact that
;                                PES packet headers are always aligned at the start of the transport packet payload).
; 15-Mar-95  TMD  1.26		Conditional out program number check
; 24-Apr-95  TMD  1.27		Better PAT processing to skip Network Information Table PID reference in PAT
;				Allow output of MPEG 2 Video/Audio data.
; 25-Apr-95  TMD  1.28		Added ResetStream
; 05-May-95  TMD  1.29		Free packet descriptors on Die entry, as in MPEGControl module.
; 24-May-95  TMD  1.30		Added MPEGControl_ResetStream, MPEGControl_MuteSound
; 31-Jul-95  TMD  1.31		Corrected problem in ts_skipbytes.
;				Moved coroutine stack lower to allow more space for normal SVC stack.
; 11-Aug-95  TMD  1.32		Added MPEGControl_SoundVolume
;				Fix MPEGControl_MuteSound not passing in correct audio stream handle
; 05-Sep-95  TMD  1.33		Terminate video/audio prefill on MPEGControl_CloseStream before calling MPEGVideo/Audio_CloseStream
; 25-Oct-95  TMD  1.34		(Conditionally) junk audio and video data after ResetStream until we get a video sequence header
; 25-Oct-95  TMD  1.35		Remove debugging output of "Bad PES packet header" except when debugging.
; 12-Dec-95  TMD  1.36		Remove register loads for debugging output close to start of FullBuffers.
; 08-Feb-95  TMD  1.37		Fix FreeBuffer routine not setting up r12 when a routine address is specified rather than a SWI.
; 15-Feb-95  TMD  1.38		Naive support for DVB format files (ie just skip tag word)
; 15-Feb-95  TMD  1.39		Added MPEGControl_SelectProgram SWI
; 16-Feb-95  TMD  1.40		Allow specification of program index as an alternative to program number
; 20-Feb-95  TMD  1.41		Added DVBControl SWIs where required to enable PIDs
; 28-Feb-95  TMD  1.42		Ignore errors from ResetStream in SelectProgram
; 07-Mar-96  TMD  1.43		Added MPEGControl_Stats SWI
; 11-Apr-96  TMD  1.44		Conditionally keep a copy of the 1st TS packet after OpenStream or ResetStream, for debugging
; 10-Jun-96  TMD  1.45		Started on adding code to skip until we get correct trick mode data.
; 21-Jun-96  TMD  1.46		Add amount returned statistic
; 21-Jun-96  TMD  1.47		Only issue MPEGVideo/Audio_Play if that stream present after last ResetStream
; 25-Jun-96  TMD  1.48		Started on new internal interfaces (program element handlers)
; 24-Jul-96  TMD  1.49		Initialise all data rate count entries to 0, not -1
; 12-Aug-96  TMD  1.50		Allow program element handlers to register for a particular PID, rather than a stream type.
; 16-Aug-96  TMD  1.51		Move check for PEH handlers above check for video_PID etc
;				Allow PMT entry to match PEHs as well as video
; 11-Nov-96  TMD  1.52		Created variant that copies the coroutine stack away each time into an RMA block.
;		  1.53		Source for this version has been lost - it was the same as 1.52 but kept track of continuity
;				 counter errors, and a copy of the packet after the discontinuity.
; 21-Mar-97  TMD  1.54		Added Stats_SkippingUntilCorrectMode
; 15-Apr-97  TMD  1.55		Added Stats_DataDiscarded in order to detect EOF on N-Cube server (sends null packets at end).
; 30-Oct-97  TMD  1.56		Added DataReturned to CtrlInfo
; 07-Nov-97  TMD  1.57		(Conditionally) nobble video packet lengths to zero
; 14-Nov-97  TMD  1.58		Allow bit 3 of ResetStream flags to pass through to video/audio
; 11-Feb-98  TMD  1.59		Issue Service_MPEGControlStarting on init
; 19-Feb-98  TMD  1.60		(Conditionally) parse OVS NPTReferenceDescriptor to spot transitions
; 20-Feb-98  TMD  1.61		Invalidate stream-type PEH PIDs on SelectProgram call
; 09-Mar-98  TMD  1.62		Invalidate PMT, video, audio and stream-type PEH PIDs on ResetStream
;

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

                GBLL    AutoABSDetect
AutoABSDetect   SETL    {FALSE}                         ; automatically detect audio-only files

                GBLL    ErrorRecovery
ErrorRecovery   SETL    {TRUE}                          ; attempt to recover from -ve length packets

		GBLL	AllowMPEG2Video
AllowMPEG2Video SETL	{TRUE}

		GBLL	AllowMPEG2Audio
AllowMPEG2Audio	SETL	{TRUE}

		GBLL	Save1stPacket
Save1stPacket	SETL	{FALSE}				; keep a copy of 1st TS packet after OpenStream or ResetStream

		GBLL	CoroutineStackCopied		; coroutine stack lives on normal SVC stack and is copied away each time
CoroutineStackCopied SETL {TRUE}			; into a static block

		GBLL	NobbleVideoPacketLengths	; set video packet lengths to zero, cos they're wrong anyway on OVS
NobbleVideoPacketLengths SETL {FALSE}			; easier to do it in MPEG2Video module instead

		GBLL	ParseOVSNPT
ParseOVSNPT	SETL	{TRUE}

 [ :LNOT: CoroutineStackCopied
TransportStack          *       &01C00800               ; 3/4 way down normal SVC stack
 ]

; If playing elemental streams, we need to chop up large buffers longer than 64K into smaller
; chunks, because the maximum MPEG packet size is 64K

MaxMPEGPacketLength     *       &FF00                   ; allow some space for packet headers as well

TS_PacketLength         *       188                     ; length of transport stream packets (in bytes)
TS_SyncByte             *       &47                     ; transport stream sync byte
TS_TEI_Bit              *       &80 :SHL: 8             ; transport_error_indicator (in byte 1 of header)
TS_PUSI_Bit             *       &40 :SHL: 8             ; payload_unit_start_indicator (in byte 1)
TS_TP_Bit               *       &20 :SHL: 8             ; transport_priority (in byte 1)
TS_TSC_Bits             *       &C0                     ; transport_scrambling_control (in byte 3)
TS_AF_Present_Bit       *       &20                     ; indicates adaptation field present (in byte 3)
TS_Payload_Present_Bit  *       &10                     ; indicates payload present (in byte 3)
TS_CC_Bits              *       &0F                     ; continuity counter bits (in byte 3)

; Table ID values

TS_table_id_PAT         *       &00                     ; program association table section
TS_table_id_PMT         *       &02                     ; program map section

TS_Stream_Type_MPEG1Video *     &01
TS_Stream_Type_MPEG2Video *	&02
TS_Stream_Type_MPEG1Audio *     &03
TS_Stream_Type_MPEG2Audio *	&04

; PES packet header optional flags

PES_Optional_PTS_Present	*	&80		; PTS field present
PES_Optional_DTS_Present	*	&40		; DTS field present
PES_Optional_ESCR_flag		*	&20		; ESCR fields present
PES_Optional_ES_rate_flag	*	&10		; ES_rate field present
PES_Optional_DSM_trick_mode_flag *	&08		; DSM_trick_mode_flag present
PES_Optional_additional_copy_info_flag * &04		; additional copy info present
PES_Optional_PES_CRC_flag	*	&02		; PES_CRC present
PES_Optional_PES_extension_flag *	&01		; PES extensions present

; The DVB card has a PID filter which allows up to 32 programmable PIDs to be captured
; These are the PID slot indices used for the various streams

				^	0
PIDSlot_Video			#	1
PIDSlot_Audio			#	1
PIDSlot_PAT			#	1		; (PID 0, enabled by MPEG player !RunImage currently)
PIDSlot_PMT			#	1
PIDSlot_Extra			#	0		; base of PID slots used for additional handlers

NumberOfPIDSlots		*	32
		ASSERT	@ <= NumberOfPIDSlots-1		; make sure we have at least one PID slot for extras

 [ DoPEH
; Program Element Handler structure (global)

				^	0
PEH_Link			#	4		; link to next one
PEH_Flags			#	4		; flags relevant to handler
PEH_StreamType			#	4		; stream type
PEH_HandlerWS			#	4		; workspace pointer
PEH_HandlerCode			#	4		; entry point for handler
PEHSize				*	:INDEX: @

; Program Element PID structure (local to stream)

				^	0
PEHPID_Link			#	4		; link to next one
PEHPID_Flags			#	4		; flags relevant to handler for this stream
PEHPID_ProgramElementStreamHandle #	4		; stream handle to use when talking to PEH
PEHPID_PID			#	4		; the PID that this stream type is currently using
							; (this field may change during life of stream)
PEHPID_PIDSlot			#	4		; PID slot used in DVB card, allocated at time of OpenStream
PEHPID_PEH			#	4		; pointer to PEH node
PEHPIDSize			*	:INDEX: @
 ] ; DoPEH

; Control stream handle structure

                        ^       0
CSH_StreamFlags         #       4
CSH_VideoStreamHandle   #       4
CSH_AudioStreamHandle   #       4
 [ CoroutineStackCopied
CSH_CoroutineStackCopy  #	4			; pointer to copy of coroutine stack claimed out of RMA
CSH_CoroutineStackBlockSize #	4			; size of block allocated
CSH_CoroutineStackSize	#	4			; number of words currently on stack
 |
CSH_TransportSP         #       4                       ; transport layer stack pointer for coroutines
 ]
CSH_ExternalSP          #       4                       ; external stack pointer for coroutines
CSH_PMT_PID             #       4                       ; PID for packets containing Program Map Table (-1 if unknown)
CSH_Video_PID           #       4                       ; PID for video packets
CSH_Audio_PID           #       4                       ; PID for audio packets
CSH_NotReadyBits        #       4                       ; bits indicating which elemental modules are not yet ready to play
 [ SendFirstSCR
CSH_SendNextSCR         #       4                       ; flag indicating we should send next SCR to video module
 ]
CSH_StartTime           #       4                       ; time stream was opened
CSH_LastTime            #       4                       ; last time data was received
CSH_DataReceived        #       4                       ; amount of data received
CSH_DataReturned	#	4			; amount of data returned
CSH_DataDiscarded	#	4			; amount of data discarded (not video, audio, PAT, PMT or selected private)
CSH_CurrentProgram	#	4			; program number of current program, or -index (eg -1 = first program)
CSH_CurrentVideoStream	#	4			; index of video stream to select within program (1 => 1st)
CSH_TempVideoStream	#	4			; temporary decrementing copy of above
CSH_CurrentAudioStream	#	4			; index of video stream to select within program (1 => 1st)
CSH_TempAudioStream	#	4			; temporary decrementing copy of above

CSH_LastResetStreamFlags #	4			; bits indicating what streams are active after last resetstream
 [ DoPEH
CSH_ListOfPEHPIDs	#	4			; pointer to 1st PEHPID node for this stream
 ]

 [ SkipToCorrectTrickMode
CSH_TrickModeControl	#	4			; value required in trick_mode_control field, or -1 for normal
CSH_LastTrickModeControl #	4			; last value we actually had for trick_mode_control (or -1)
 ]

 [ Save1stPacket
SavedSize		*	188
CSH_SavedLength		#	4			; 0 => still have to save 1st packet, else length of saved data
CSH_SavedData		#	SavedSize
 ]
 [ DataRateStats
; DataCountPeriod         *       300                     ; seconds in 1 period
DataCountPeriod         *       1                       ; seconds in 1 period
DataCountArraySize      *       100                     ; allow for 100 periods at present
CSH_DataCounts          #       DataCountArraySize * 4  ; one word per minute
 ]

 [ ParseOVSNPT
CSH_NPTDescLength	#	1
CSH_NPTDescMaxLen	*	18			; we can store maximum of 18 bytes of descriptor (not including len)
CSH_NPTContentID	#	1			; bit 7 if postDiscontinuityIndicator (unused)
							; bits 6..0 are the content ID (incremented for each command)
CSH_NPTSTCRef		#	5			; 1st 7 bits reserved, last 33 are STC_Reference
CSH_NPTNPTRef		#	8			; 1st 31 bits reserved, last 33 are NPT_Reference
CSH_NPTScaleNum		#	2
CSH_NPTScaleDen		#	2
			AlignSpace

CSH_LastContentID	#	4			; last value in ContentID field, or -1 if none
 ]

CSHSize                 *       @


                        ^       0, wp

FreePacketListHeadPtr   #       4       ; pointer to head of list of free packet descriptors
FreePacketListTailPtr   #       4       ; pointer to tail of list

SWIInstruction          #       8       ; SWI + Pull pc
DebugFlag               #       4       ; NZ => output debugging

 [ DoPEH
GlobalPEHList		#	4	; list of all PEH nodes, global to all streams
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

ControlStreamHandle     #       CSHSize ; goes at the end cos likely to be long (with stack)
                                        ; NB this could be dynamically allocated on OpenStream eventually

Module_WorkspaceSize * :INDEX: @

; ** Debugging macros **

        GBLL    debug
debug   SETL    {FALSE}

        MACRO
        DLine   $string, $cc, $inverse
 [ debug
        DLINE   "$string", $cc, $inverse
 ]
        MEND

        MACRO
        DReg    $reg, $string, $cc, $routine
 [ debug
        DREG    $reg, "$string", $cc, $routine
 ]
        MEND

        MACRO
        uilsbf16        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        MEND

        MACRO
        uilsbf32        $dst, $tmp
        LDRB    $dst, [r0], #1
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #8
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #16
        LDRB    $tmp, [r0], #1
        ORR     $dst, $dst, $tmp, LSL #24
        MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       MPEGControlSWI_Base ; SWI chunk
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "MPEGControl", 0

Mod_HelpStr
        =       "MPEGControl", TAB, "1.62 (09 Mar 1998) (MPEG 2 Transport layer version)", 0
        ALIGN

Mod_SWITable
        =       "MPEGControl", 0
        =       "OpenStream", 0
        =       "FullBuffers", 0
        =       "CloseStream", 0
        =       "Play", 0
        =       "SetSpeed", 0
	=	"ResetStream", 0
	=	"MuteSound", 0
	=	"SoundVolume", 0
	=	"SelectProgram", 0
	=	"Stats", 0
	=	"RegisterProgramElementHandler", 0
	=	"DeregisterProgramElementHandler", 0
        =       0

Mod_HC_Table
        Command CtrlInfo, 0, 0
        Command CtrlDebugOn, 0, 0
        Command CtrlDebugOff, 0, 0
        =       0

CtrlInfo_Help
        =       "*CtrlInfo outputs debugging info.", CR
CtrlInfo_Syntax
        =       "Syntax: *CtrlInfo", 0
CtrlDebugOn_Help
        =       "*CtrlDebugOn enables continuous debugging output.", CR
CtrlDebugOn_Syntax
        =       "Syntax: *CtrlDebugOn", 0
CtrlDebugOff_Help
        =       "*CtrlDebugOff disables continuous debugging output.", CR
CtrlDebugOff_Syntax
        =       "Syntax: *CtrlDebugOff", 0

        ALIGN

; **************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, FreePacketListHeadPtr
        STR     r0, FreePacketListTailPtr
        STR     r0, DebugFlag
 [ DoPEH
	STR	r0, GlobalPEHList	; no handlers on list to start with
	STR	r0, ControlStreamHandle+CSH_ListOfPEHPIDs ; control stream handle not valid, so no PEHPIDs
 ]
        LDR     r0, PullPCInstruction
        STR     r0, SWIInstruction +4

	ADR	r0, IssueServiceMPEGControlStarting
	MOV	r1, wp
	SWI	XOS_AddCallBack

        CLRV
        EXIT

PullPCInstruction
        Pull    PC

; **************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; Ensure that the callback requested on init doesn't go off after we're dead

	ADR	r0, IssueServiceMPEGControlStarting
	MOV	r1, wp
	SWI	XOS_RemoveCallBack

; Free all the packets on our free list

	LDR	r1, FreePacketListHeadPtr
10
	MOVS	r2, r1					; are there any more nodes to free?
	BEQ	%FT90					; [no, so skip]
	LDR	r1, [r2, #PacketDescriptor_Link]	; get link to next
	MOV	r0, #ModHandReason_Free			; free this one
	SWI	XOS_Module
	B	%BT10					; and try again

90
        CLRV
        EXIT

; **************************************************************************
;
;	IssueServiceMPEGControlStarting - Issue start-up service

IssueServiceMPEGControlStarting Entry "r1"
	MOV	r1, #Service_MPEGControlStarting
	SWI	XOS_ServiceCall
	EXIT

; **************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service * Module_BaseAddr   ; nothing to do yet!

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #MPEGControlSWICheckValue - MPEGControlSWI_Base
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
SWIBTable
        B       OpenStream      ; open stream
        B       FullBuffers     ; new data
        B       CloseStream     ; close stream
        B       Play            ; start playing
        B       SetSpeed        ; may encompass pause/slow/fast/rewind
	B	ResetStream	; discard data and reset devices
	B	MuteSound	; mute/unmute sound
	B	SoundVolume	; set/read sound volume
	B	SelectProgram	; select program to watch
	B	Stats		; return statistics
	B	RegisterProgramElementHandler ; register a new program element handler
	B	DeregisterProgramElementHandler ; and deregister it

	ASSERT  (MPEGControlSWICheckValue - MPEGControlSWI_Base)*4 = {PC} - SWIBTable

 [ :LNOT: DoPEH
RegisterProgramElementHandler
DeregisterProgramElementHandler
 ]
NoSuchSWI
        Push    "lr"
        SWI     XOS_WriteI+22
        SWI     XOS_WriteI+12
        DREG    r11, "Unknown MPEGControl SWI - offset from base = "
        DLINE   "Press any key"
        SWI     XOS_ReadC
        ADR     r0, NoSuchSWIError
        SETV
        Pull    "pc"

NoSuchSWIError
        &       0
        =       "No such MPEGControl SWI", 0
        ALIGN

; **************************************************************************
;
;       OpenStream - Open MPEG stream
;
; in:   r0 = flags
;       r1 = control parameters structure
;       r2 = video parameters structure
;       r3 = audio parameters structure
;
; out:  r0 = control stream handle (for now)
;

OpenStream Entry "r0-r2"
        ADR     r1, ControlStreamHandle

        STR     r0, [r1, #CSH_StreamFlags]

        AND     lr, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
        STR     lr, [r1, #CSH_NotReadyBits]             ; which bits are not yet ready to play
	STR	lr, [r1, #CSH_LastResetStreamFlags]

 [ SendFirstSCR
        ASSERT  StreamFlags_VideoPresent = 1
        ANDS    lr, r0, #StreamFlags_VideoPresent
        STR     lr, [r1, #CSH_SendNextSCR]              ; only send 1st SCR if doing video
 |
        TST     r0, #StreamFlags_VideoPresent
 ]
        BEQ     %FT10

        SWI     XMPEGVideo_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
        EXIT    VS
        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_VideoStreamHandle]
        LDR     r0, [r1, #CSH_StreamFlags]
10
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT20

        MOV     r2, r3
        SWI     XMPEGAudio_OpenStream                   ; in: r0 = stream flags
        STRVS   r0, [sp]
        EXIT    VS

        ADR     r1, ControlStreamHandle
        STR     r0, [r1, #CSH_AudioStreamHandle]
20
 [ DoPEH
	Push	"r3-r6"
; Zero the pointer to the list of PEHPIDs

	MOV	r6, #0
	STR	r6, [r1, #CSH_ListOfPEHPIDs]
	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_DVB			; are we doing DVB
	MOVNE	r5, #PIDSlot_Extra			; yes, use base of PID slots to use for PEH requests
	MOVEQ	r5, #-1					; no, then no slots to allocate

; For each PEH on global list:
	LDR	r6, GlobalPEHList
25
	TEQ	r6, #0
	BEQ	%FT50					; [no more PEHs to consider]

; Allocate a PEHPID

	MOV	r0, #ModHandReason_Claim
	MOV	r3, #PEHPIDSize
	SWI	XOS_Module
	Pull	"r3-r6", VS				; if failed to claim PEHPID, exit with error
	EXIT	VS

;   Issue OpenStream reason code to handler

30
	Push	"r1,r2"
	MOV	r0, #PEHReason_OpenStream
	MOV	r2, r1					; r2 = control stream handle
	LDR	r1, [r2, #CSH_StreamFlags]		; r1 = stream flags
	MOV	r3, #0					; no program element parameters struct yet
	BL	CallPEH
	Pull	"r1,r2"
	BVS	%FT45					; error, so don't include this
	TEQ	r0, #0
	BEQ	%FT45					; returned zero handle, so don't include this

	STR	r0, [r2, #PEHPID_ProgramElementStreamHandle] ; save PEH stream handle
	STR	r6, [r2, #PEHPID_PEH]
	MOV	lr, #0
	STR	lr, [r2, #PEHPID_Flags]			; no meaning to this yet
	LDR	lr, [r6, #PEH_Flags]
	TST	lr, #PEHFlags_StreamIdentifiedByPID
	MOVEQ	lr, #-1					; it's a stream_type, so no PID found for this yet
	LDRNE	lr, [r6, #PEH_StreamType]		; stream type is really a raw PID, so allow it straight away
	STR	lr, [r2, #PEHPID_PID]			; store PID
	STR	r5, [r2, #PEHPID_PIDSlot]		; use this PID slot
	CMP	r5, #NumberOfPIDSlots-1			; if we've just used the last slot (or already run out)
	MOVCS	r5, #-1					; then no more PID slots free
	ADDCC	r5, r5, #1				; else advance to next slot
	LDR	lr, [r1, #CSH_ListOfPEHPIDs]		; add PEHPID onto list for this stream
	STR	lr, [r2, #PEHPID_Link]
	STR	r2, [r1, #CSH_ListOfPEHPIDs]
	LDR	r6, [r6, #PEH_Link]
	B	%BT25

; handler didn't return a valid handle, so if we're the last PEH, we must free it
; else process next PEH using the same PEHPID

45
	LDR	r6, [r6, #PEH_Link]
	TEQ	r6, #0
	BNE	%BT30					; [not at end, so reuse this PEHPID for the next PEH]

	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module				; free PEHPID node

50
	Pull	"r3-r6"
 ] ; DoPEH
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_StartTime]
        STR     r0, [r1, #CSH_LastTime]

        MOV     r0, #0
        STR     r0, [r1, #CSH_DataReceived]
	STR	r0, [r1, #CSH_DataReturned]
	STR	r0, [r1, #CSH_DataDiscarded]
 [ Save1stPacket
	STR	r0, [r1, #CSH_SavedLength]		; not saved any data yet
 ]
 [ CoroutineStackCopied
	STR	r0, [r1, #CSH_CoroutineStackCopy]	; no block allocated yet
	STR	r0, [r1, #CSH_CoroutineStackBlockSize]	; no space in it
 ]
 [ ParseOVSNPT
	STRB	r0, [r1, #CSH_NPTDescLength]		; no bytes in stored descriptor
 ]
        MOV     r0, #-1
	STR	r0, [r1, #CSH_CurrentProgram]		; just choose 1st program for now
        STR     r0, [r1, #CSH_PMT_PID]                  ; PID for Program Map Table is unknown until we get a PAT on PID 0
        STR     r0, [r1, #CSH_Video_PID]                ; PID for video is unknown until we get a PMT
        STR     r0, [r1, #CSH_Audio_PID]                ; PID for audio is unknown until we get a PMT
 [ SkipToCorrectTrickMode
	STR	r0, [r1, #CSH_LastTrickModeControl]	; indicate normal play
 ]
 [ ParseOVSNPT
	STR	r0, [r1, #CSH_LastContentID]		; no content ID fields yet
 ]

	MOV	lr, #1
	STR	lr, [r1, #CSH_CurrentVideoStream]
	STR	lr, [r1, #CSH_CurrentAudioStream]

 [ DataRateStats
        MOV     lr, #DataCountArraySize-1               ; initialise all data counts to zero
        ADD     r2, r1, #CSH_DataCounts
	MOV	r0, #0
80
        STR     r0, [r2, lr, LSL #2]
        SUBS    lr, lr, #1
        BPL     %BT80
 ]

        MOV     r0, r1
        BL      ts_coinit                               ; initialise coroutines

        CLRV
        STR     r0, [sp]
        EXIT

; **************************************************************************
;
;       Play - Start audio and video playing (if both ready)
;
; in:   r0 = flags
;            bit 0 set => video module ready to play
;            bit 1 set => audio module ready to play
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

Play    Entry "r0-r3"
        ADR     r1, ControlStreamHandle

        LDR     r3, [r1, #CSH_NotReadyBits]
        BICS    r3, r3, r0                      ; clear not ready bits for this module
        STR     r3, [r1, #CSH_NotReadyBits]
        EXIT    NE                              ; someone still isn't ready

        LDR     r3, [r1, #CSH_LastResetStreamFlags]
        TST     r3, #ResetStreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        MOV     r0, #0                          ; flags
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #ResetStreamFlags_AudioPresent
        BEQ     %FT20

        Push    "r1,r2"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_Play
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
20
        MOV     r0, #0
;        STR     r0, [r1, #CSH_DataReceived] ; TMD 21-Jun-96 - don't zero on Play
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_StartTime]
        STR     r0, [r1, #CSH_LastTime]
        CLRV
        EXIT

; **************************************************************************
;
;       SetSpeed - Set speed of play on MPEG stream
;
; in:   r0 = flags
;       r1 = external stream handle (assumed for now)
;       r2 = speed indicator
;              0    = paused
;              1    = normal speed
;              2-8  = 1/2 to 1/8 slow motion
;
; out:  -
;

SetSpeed Entry "r0-r3"
        ADR     r1, ControlStreamHandle

        LDR     r3, [r1, #CSH_StreamFlags]
        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1,r2"
        MOV     r0, #0                          ; flags
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_SetSpeed
        Pull    "r1,r2"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_SetSpeed
        STRVS   r0, [sp]
        EXIT    VS
20
        CLRV
        EXIT

; **************************************************************************
;
;       MuteSound - Mute/unmute sound
;
; in:   r0 = flags
;		bit 0 = 0 => sound on
;		        1 => sound off
;       r1 = external stream handle (assumed for now)
;
; out:  -
;

MuteSound Entry "r0-r3"
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_MuteSound			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       SoundVolume - Set/read sound volume
;
; in:   r0 = flags (zero for now)
;       r1 = external stream handle (assumed for now)
;	r2 = -1 => read volume
;	   = 0..256 => set volume (logarithmic)
;
; out:  r2 = old volume
;

SoundVolume Entry "r0,r1"
	CLRV
        ADR     r1, ControlStreamHandle

        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, #StreamFlags_AudioPresent
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
        SWINE   XMPEGAudio_SoundVolume			; only execute it if audio present
        STRVS   r0, [sp]
        EXIT

; **************************************************************************
;
;       FullBuffers - Here's some more data
;
; in:   r0 = flags
;       r1 = control stream handle
;       r2 -> one or more linked bitstream buffers

FullBuffers Entry "r0-r5"
        ADR     r1, ControlStreamHandle                 ; for now, since Keith isn't doing the open!
 [ Save1stPacket
	LDR	r0, [r1, #CSH_SavedLength]
	TEQ	r0, #0
	BNE	%FT02					; [already saved]
	LDR	r0, [r2, #BufferDescriptor_Start]
	LDR	lr, [r2, #BufferDescriptor_Length]
	CMP	lr, #SavedSize
	MOVHI	lr, #SavedSize
	STR	lr, [r1, #CSH_SavedLength]
	ADD	r3, r1, #CSH_SavedData
01
	LDRB	r4, [r0], #1
	STRB	r4, [r3], #1
	SUBS	lr, lr, #1
	BNE	%BT01
02
 ]
        LDR     r0, [r1, #CSH_NotReadyBits]             ; if we haven't actually started playing yet, do nothing
        TEQ     r0, #0
        MOVNE   r5, #0                                  ; indicate no array element to increment
        BNE     %FT05
        SWI     XOS_ReadMonotonicTime
        STR     r0, [r1, #CSH_LastTime]

 [ DataRateStats
        LDR     lr, [r1, #CSH_StartTime]
        SUB     r0, r0, lr                              ; time since starting
        LDR     lr, =DataCountPeriod*100                ; number of centiseconds in a period
        DivRem  r5, r0, lr, r3                          ; r5 = number of periods since starting
        CMP     r5, #DataCountArraySize                 ; check in range of array
        ADDCC   lr, r1, #CSH_DataCounts                 ; if so, then compute address of count to increment
        ADDCC   r5, lr, r5, LSL #2
        MOVCS   r5, #0                                  ; else indicate nothing to increment
 ]

05
        LDR     r0, [sp]                                ; reload flags

10

; ** DEBUGGING **

debug   SETL    {FALSE}

 [ debug
        DLine   "FullBuffer:"
        LDR     r3, [r2, #BufferDescriptor_Link]
        DReg    r3, " Link = "
        LDR     r3, [r2, #BufferDescriptor_FreeRoutine]
        DReg    r3, " FreeRoutine = "
        LDR     r3, [r2, #BufferDescriptor_FreeWorkspace]
        DReg    r3, " FreeWorkspace = "
        LDR     r3, [r2, #BufferDescriptor_Start]
        DReg    r3, " Start = "
        LDR     r3, [r2, #BufferDescriptor_Length]
        DReg    r3, " Length = "
	DReg	sp, " Stack pointer = "
 ]

        MOV     r3, #1
        STR     r3, [r2, #BufferDescriptor_Packets]     ; one user (us!)

        LDR     r3, [r2, #BufferDescriptor_Start]
        LDR     r4, [r2, #BufferDescriptor_Length]

        LDR     lr, [r1, #CSH_DataReceived]             ; increment count of total bytes received
        ADD     lr, lr, r4
        STR     lr, [r1, #CSH_DataReceived]

 [ DataRateStats
        TEQ     r5, #0                                  ; if we're inside array
        LDRNE   lr, [r5]                                ; then increment array element by amount of data
        ADDNE   lr, lr, r4
        STRNE   lr, [r5]
 ]
        ADD     r4, r3, r4

        LDR     lr, [r1, #CSH_StreamFlags]              ; if not in the process of closing the stream
        TST     lr, #StreamFlags_StreamClosing          ; then call the coroutines to parse the buffer
	BNE	%FT15
	DLine	"Calling coroutines"
 [ :LNOT: CoroutineStackCopied
	LDR	lr, [r1, #CSH_TransportSP]
	DReg	lr, "Coroutine SP = "
 ]
        BL      CallCoroutines                          ; otherwise effectively junk any data in the buffer
	DLine	"Came back from coroutines"

15
        MOV     r3, pc
        ORR     lr, r3, #I_bit          ; disable IRQs
        TEQP    lr, #0

        LDR     lr, [r2, #BufferDescriptor_Packets]
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        LDR     r4, [r2, #BufferDescriptor_Link]        ; load link *before* restoring IRQ state

        TEQP    r3, #0                  ; restore IRQ state

        TEQ     lr, #0                  ; is the count now zero (if so then no active packets in buffer)
        BNE     %FT20                   ; [no, so don't free buffer]

	DLine	"About to call free routine directly from FullBuffers"
        Push    "r1"
        STR     lr, [r2, #BufferDescriptor_Link] ; only free one buffer
        MOV     r1, r2
        BL      FreeBuffer
        Pull    "r1"
	DLine	"Came back from freeing buffer"
20
        MOVS    r2, r4                  ; put link back into r2
        BNE     %BT10                   ; and if more buffers, loop
        CLRV
        EXIT

debug   SETL    {FALSE}

; **************************************************************************
;
;       CloseStream - Close the stream
;
; in:   r0 = flags
;       r1 = control stream handle
;

CloseStream Entry "r0"
        ADR     r1, ControlStreamHandle
        LDR     r0, [r1, #CSH_StreamFlags]
        ORR     r0, r0, #StreamFlags_StreamClosing	; first set the stream closing bit, so any incoming data gets junked
        STR     r0, [r1, #CSH_StreamFlags]

	LDR	lr, [r1, #CSH_NotReadyBits]		; see if we've issued the Play SWI yet
	TEQ	lr, #0
	BEQ	%FT10					; we have, so no need to issue it again

; we haven't yet told them to go, so do so now

	Push	"r0"
	MOV	r0, lr
	BL	Play
	Pull	"r0"

10
        TST     r0, #StreamFlags_VideoPresent
        BEQ     %FT20

        Push    "r0, r1"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_CloseStream
        Pull    "r0, r1"
20
        TST     r0, #StreamFlags_AudioPresent
        BEQ     %FT30

        Push    "r0, r1"
        MOV     r0, #0
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_CloseStream
        Pull    "r0, r1"
30
 [ DoPEH
	Push	"r1-r3,r6"
	LDR	r3, [r1, #CSH_ListOfPEHPIDs]
35
	TEQ	r3, #0					; any more PEHPIDs to consider
	BEQ	%FT50					; [no, so exit]
	MOV	r0, #PEHReason_CloseStream
	MOV	r1, #0					; flags
	LDR	r2, [r3, #PEHPID_ProgramElementStreamHandle]
	LDR	r6, [r3, #PEHPID_PEH]			; point r6 at PEH for CallPEH
	BL	CallPEH
	MOV	r2, r3					; save copy of PEHPID to free
	LDR	r3, [r3, #PEHPID_Link]			; advance to next before freeing
	LDR	r1, [sp, #0*4]				; reload CSH pointer
	STR	r3, [r1, #CSH_ListOfPEHPIDs]		; remove node from head of list
	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module
	B	%BT35

50
	Pull	"r1-r3,r6"
 ] ; DoPEH

 [ CoroutineStackCopied

; Now free the coroutine stack block

	Push	"r0-r2"
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVNE	r0, #ModHandReason_Free
	SWINE	XOS_Module
	MOV	r2, #0
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	STR	r2, [r1, #CSH_CoroutineStackBlockSize]
	Pull	"r0-r2"
 ]
        CLRV
        EXIT

; **************************************************************************
;
;	SelectProgram - Select TS program number to watch
;
; in:	r0 = flags:
;		bit 0 set => r3 = index of video stream to select
;		bit 1 set => r4 = index of audio stream to select
;	r1 = control stream handle
;	r2 = program number to select, or -1 to choose 1st program
;
; out:	-

SelectProgram Entry "r3,r4"
	TST	r0, #1		; check if video stream specified
	MOVEQ	r3, #1		; if not use default
	TST	r0, #2		; check if audio stream specified
	MOVEQ	r4, #1		; if not use default
	LDR	lr, [r1, #CSH_CurrentProgram]
	STR	r2, [r1, #CSH_CurrentProgram]
	TEQ	lr, r2
	LDREQ	lr, [r1, #CSH_CurrentVideoStream]
	STR	r3, [r1, #CSH_CurrentVideoStream]
	TEQEQ	lr, r3
	LDREQ	lr, [r1, #CSH_CurrentAudioStream]
	STR	r4, [r1, #CSH_CurrentAudioStream]
	TEQEQ	lr, r4
	EXIT	EQ		; program and video stream and audio stream all the same, do nowt

	BL	InvalidatePIDs	; forget all about PMT, video, audio and PEH PIDs

	Push	"r0-r3"
	LDR	r0, [r1, #CSH_StreamFlags]
	TST	r0, #StreamFlags_DVB
	BEQ	%FT60
	Push	"r0-r2"
	SWI	XDVBControl_ResetStream
	MOV	r0, #2
	MOV	r1, #&47
	LDR	r2, =&00FF1FFF		; re-enable PID 0
	SWI	XDVBControl_MatchMask
	Pull	"r0-r2"
60
	AND	r0, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
	BL	ResetStream
	Pull	"r0-r3"
	EXITS				; ignore errors

; **************************************************************************
;
;       InvalidatePIDs - Called by SelectProgram/ResetStream to invalidate PMT/Video/Audio/PEH PIDs
;
; in:   r1 -> control stream handle
;
; out:  -
;

InvalidatePIDs Entry "r0,r2"
	MOV	lr, #-1
	STR	lr, [r1, #CSH_PMT_PID]
	STR	lr, [r1, #CSH_Video_PID]
	STR	lr, [r1, #CSH_Audio_PID]

 [ DoPEH
	LDR	r2, [r1, #CSH_ListOfPEHPIDs]
10
	TEQ	r2, #0				; no more PEHPIDs?
	BEQ	%FT30				; then skip
	LDR	lr, [r2, #PEHPID_PEH]		; get PEH for PEHPID
	LDR	r0, [lr, #PEH_Flags]		; first check that this PEH uses stream_type
	TST	r0, #PEHFlags_StreamIdentifiedByPID ; (bit must be clear)
	MOVEQ	lr, #-1				; uses stream_type, so invalidate this PID
	STREQ	lr, [r2, #PEHPID_PID]
20
	LDR	r2, [r2, #PEHPID_Link]		; move to next PEHPID
	B	%BT10				; and loop
30
 ]
	EXIT

; **************************************************************************
;
;       FreePackets - Called by video/audio devices to free a packet
;
; in:   r0 -> packet descriptor (for now)
;
; out:  -
;

FreePackets Entry "r0-r5, wp"
        MOV     r1, r0
        LDR     wp, [r1, #PacketDescriptor_FreeWorkspace]
10
        LDR     r2, [r1, #PacketDescriptor_BufferDescriptor]    ; get parent buffer pointer

        MOV     r3, pc
        ORR     lr, r3, #I_bit                          ; disable IRQs round this bit
        TEQP    lr, #0

; decrement outstanding packet count for buffer (atomically)

        LDR     lr, [r2, #BufferDescriptor_Packets]     ; (needs to be atomic)
        SUB     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

; add this packet descriptor to free list

        LDR     r4, FreePacketListTailPtr
        TEQ     r4, #0                                  ; if no packets currently free
        STREQ   r1, FreePacketListHeadPtr               ; then point head at new free packets
        STRNE   r1, [r4, #PacketDescriptor_Link]        ; else tail!link = packet
        STR     r1, FreePacketListTailPtr               ; store new tail ptr

        LDR     r4, [r1, #PacketDescriptor_Link]        ; go down to next packet on passed list
        MOV     r5, #0
        STR     r5, [r1, #PacketDescriptor_Link]        ; detach packet

        TEQP    r3, #0                                  ; restore IRQ state

        TEQ     lr, #0                                  ; if all buffer data has been used, then free buffer
        STREQ   lr, [r2, #BufferDescriptor_Link]        ; only free one buffer
        MOVEQ   r1, r2
        BLEQ    FreeBuffer

        MOVS    r1, r4                                  ; are we at end of passed list?
        BNE     %BT10                                   ; no, so loop

        EXIT

; **************************************************************************
;
;	ResetStream - Discard data and reset devices
;
; in:	r0 = flags
;		bit 0 set => new stream has video data
;		bit 1 set => new stream has audio data
;		bit 2 set => discard data until we get data of trick mode specified by r2
;	r1 = control stream handle
;	r2 = trick mode of required data (if bit 2 of r0 set):
; 		0 => fast forward
; 		1 => slow motion
; 		2 => freeze frame
; 		3 => fast reverse
; 		4 => slow reverse
; 	       -1 => normal play
; 	Note that these values correspond to the values of the trick_mode_control field
; 	in the PES packet header, except for -1 which corresponds to DSM_trick_mode_flag = 0,
;	and hence no trick_mode_control field.
;
; out:	r2 = estimate of amount of discarded video data, in bytes
;	r3 = estimate of amount of discarded audio data, in bytes
;

ResetStream Entry "r0-r3"
	MOV	r3, #0
	STR	r3, [sp, #2*4]			; zero the returned r2
	STR	r3, [sp, #3*4]			; zero the returned r3

        LDR     r3, [r1, #CSH_StreamFlags]
 [ SkipToCorrectTrickMode
	TST	r0, #ResetStreamFlags_SkipUntilCorrectMode	; if we need to skip to correct mode
	STRNE	r2, [r1, #CSH_TrickModeControl]			; then save new mode
	ORRNE	r3, r3, #StreamFlags_SkipUntilCorrectMode	; and set bit in stream flags so we discard
	BICEQ	r3, r3, #StreamFlags_SkipUntilCorrectMode	; else clear bit so we don't discard any more
	STRNE	r3, [r1, #CSH_StreamFlags]
 ]
 [ ParseOVSNPT
	TST	r3, #StreamFlags_OVSNPTDescriptors		; if we're supporting OVS NPT descriptors
	ORRNE	r3, r3, #StreamFlags_OVSNPTSkipping		; then discard data until we see contentID change
	STRNE	r3, [r1, #CSH_StreamFlags]
 ]

        TST     r3, #StreamFlags_VideoPresent
        BEQ     %FT10

        Push    "r1"
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_ResetStream
	STRVC	r2, [sp, #3*4]			; store in returned r2 slot
        Pull    "r1"
        STRVS   r0, [sp]
        EXIT    VS
10
        TST     r3, #StreamFlags_AudioPresent
        BEQ     %FT20

	Push	"r1"
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_ResetStream
	STRVC	r2, [sp, #4*4]			; store in returned r3 slot
	Pull	"r1"
        STRVS   r0, [sp]
        EXIT    VS
20
	ASSERT	StreamFlags_VideoPresent = ResetStreamFlags_VideoPresent
	ASSERT	StreamFlags_AudioPresent = ResetStreamFlags_AudioPresent
	AND	r0, r0, r3			; and out impossible bits in new stream vid/aud flags
	AND	r0, r0, #StreamFlags_VideoPresent :OR: StreamFlags_AudioPresent
	STR	r0, [r1, #CSH_NotReadyBits]
	STR	r0, [r1, #CSH_LastResetStreamFlags]


 [ SkipToSeqOnResetStream
	TST	r0, #StreamFlags_VideoPresent	; if video in new stream
	ORRNE	r3, r3, #StreamFlags_SkippingAfterReset
	STRNE	r3, [r1, #CSH_StreamFlags]	; then set the skip bit
 ]

 [ Save1stPacket
	MOV	r0, #0
	STR	r0, [r1, #CSH_SavedLength]		; not saved any data yet
 ]

	BL	InvalidatePIDs			; throw away any stale PIDs

	MOV	r0, r1
	BL	ts_coinit

        CLRV
        EXIT

 [ DoPEH
; **************************************************************************
;
;	RegisterProgramElementHandler - Entry point for SWI
;
; in:	r0 = flags:
;	  bit 0 set => MPEGControl module should include adaptation fields in
;		       payload, when they occur (indicated by a bit in packet
;		       descriptor flags)
;	  bit 1 set => MPEGControl module should include PES packet headers
;	  bit 2 set => MPEGControl module should include the whole of the TS
;		       packet in the payload (in this case the program element
;		       handler is responsible for adaptation field parsing)
;	  bit 3 set => r1 is absolute PID, not stream_type
;	  Other bits reserved (should be zero)
;
;	r1 = stream identifier:
;	      if bit 3 of flags set then absolute PID;
;	      if bit 3 of flags clear then stream_type (as defined by the MPEG 2 Systems specification,
;	     table 2-36, page 64)
;
;	r2 = entry address for handler
;	r3 = workspace pointer for handler
;
; out:	All registers preserved

RegisterProgramElementHandler Entry "r4"

; check if stream type in r1 matches any PEH on global list - if so, error

	LDR	r4, GlobalPEHList
10
	TEQ	r4, #0				; if at end of list
	BEQ	%FT20				; then OK

	LDR	lr, [r4, #PEH_StreamType]	; then load streamtype
	TEQ	lr, r1				; if a match
	LDREQ	lr, [r4, #PEH_Flags]		; then check flags also match
	TEQEQ	lr, r0	 			; to avoid problems if one is a stream_type and one is a PID
	LDRNE	r4, [r4, #PEH_Link]		; if no match then goto next
	BNE	%BT10				; and loop

	TEQ	r4, #0				; did we get to end of list?
	BNE	%FT90				; if not, then already a handler for that
						; stream type, so report an error
; allocate a PEH node - if fail, then error

20
	Push	"r0-r3"
	MOV	r0, #ModHandReason_Claim
	MOV	r3, #PEHSize
	SWI	XOS_Module
	MOVVC	r4, r2				; if no error transfer ptr to r4
	STRVS	r0, [sp]			; if error, save error ptr in stacked r0
	Pull	"r0-r3"
	EXIT	VS

; store all info in node

	STR	r0, [r4, #PEH_Flags]
	STR	r1, [r4, #PEH_StreamType]
	STR	r2, [r4, #PEH_HandlerCode]
	STR	r3, [r4, #PEH_HandlerWS]

; add PEH to global list (at head of list is easiest)
; NB no atomicity problems - PEH list can only be updated from foreground

	LDR	lr, GlobalPEHList
	STR	lr, [r4, #PEH_Link]
	STR	r4, GlobalPEHList

; exit, indicating success

	CLRV
	EXIT

; exit with error

90
	ADR	r0, DuplicateElementHandlerError
	SETV
	EXIT

DuplicateElementHandlerError
	&	0
	=	"Program element handler already registered for this stream type", 0
	ALIGN

; **************************************************************************
;
;	DeregisterProgramElementHandler - Entry point for SWI
;
; in:	r0 = flags (should be same as for RegisterProgramElementHandler)
;	r1 = stream type (ditto)
;	r2 = entry address for handler
;	r3 = workspace pointer for handler
;
; out:	All registers preserved

DeregisterProgramElementHandler Entry "r4-r6"

; check if (stream type,entry,ws) matches any PEH on global list - if not, error

	ADR	r6, GlobalPEHList
	LDR	r4, [r6]
10
	TEQ	r4, #0				; if at end of list
	BEQ	%FT90				; didn't find a match, so error

	LDR	lr, [r4, #PEH_StreamType]	; load streamtype
	TEQ	lr, r1				; and check for match
	LDREQ	lr, [r4, #PEH_Flags]		; load flags
	TEQEQ	lr, r0	 			; and check for match
	LDREQ	lr, [r4, #PEH_HandlerCode]	; if match then load handler code address
	TEQEQ	lr, r2				; and check for match
	LDREQ	lr, [r4, #PEH_HandlerWS]	; if match then load handler WS ptr
	TEQEQ	lr, r3				; and check for match
	MOVNE	r6, r4				; if no match then update prev ptr
	LDRNE	r4, [r4, #PEH_Link]		; if no match then goto next
	BNE	%BT10				; and loop

; check if any stream contains a PEHPID node which points at this PEH
; if so, error

; In the current implementation, there can be only one stream open at a time
; We assume that if no stream is open, then ControlStreamHandle+CSH_ListOfPEHPIDs holds zero.

	ADR	r5, ControlStreamHandle
	LDR	r5, [r5, #CSH_ListOfPEHPIDs]
20
	TEQ	r5, #0
	BEQ	%FT30				; no more PEHPIDs, so OK
	LDR	lr, [r5, #PEHPID_PEH]		; get corresponding PEH
	TEQ	lr, r4				; does it match the PEH we're trying to delete
	LDRNE	r5, [r5, #PEHPID_Link]		; no, then link to next one
	BNE	%BT20				; and loop

	ADR	r0, ProgramElementHandlerInUseError
	B	%FT92				; can't remove PEH, cos there's an open stream using it

; delink PEH node from global list
30
	LDR	lr, [r4, #PEH_Link]		; prev->link = this->link
	STR	lr, [r6, #PEH_Link]

; free PEH node

	Push	"r0-r2"
	MOV	r0, #ModHandReason_Free
	MOV	r2, r4
	SWI	XOS_Module			; ignore any error from free - we can't do much about it
	Pull	"r0-r2"

; exit, no error

	CLRV
	EXIT

; exit with error

90
	ADR	r0, ProgramElementHandlerNotFoundError
92
	SETV
	EXIT

ProgramElementHandlerNotFoundError
	&	0
	=	"Program element handler not found", 0
	ALIGN

ProgramElementHandlerInUseError
	&	0
	=	"Program element handler in use", 0
	ALIGN
 ] ; DoPEH

; **************************************************************************
;
;       FreeBuffer - Call owner of buffer to free it
;
; in:   r1 -> buffer descriptor
;
; out:  -
;

FreeBuffer Entry "r0-r3,r12"
	LDR	r2, [r1, #BufferDescriptor_Length]
	MOV	r3, pc
	Push	r3
	ORR	lr, r3, #I_bit
	TEQP	lr, #0			; IRQs off

	ADR	lr, ControlStreamHandle
	LDR	r0, [lr, #CSH_DataReturned]
	ADD	r0, r0, r2
	STR	r0, [lr, #CSH_DataReturned]
	Pull	r3
	TEQP	r3, #0			; restore IRQ state

        LDR     r2, [r1, #BufferDescriptor_FreeRoutine]
        TEQ     r2, #0          ; check for SWI interface
        BEQ     %FT10

; routine interface

	LDR	r12, [r1, #BufferDescriptor_FreeWorkspace]	; setup workspace ptr
        MOV     r0, #3
        MOV     lr, pc
        MOV     pc, r2
        EXIT

; swi interface

10
        LDR     r2, [r1, #BufferDescriptor_FreeWorkspace]
        ORR     r2, r2, #&EF000000
        STR     r2, SWIInstruction +0
        MOV     r2, r1
        MOV     r0, #0
        MOV     r1, #0
        BL      %FT20
        EXIT

20
        Push    "lr"
        ADR     pc, SWIInstruction

; **************************************************************************
;
;       Coroutine stuff
;
; Entry parameters for coroutines:
;  r0-r4 are passed in
;  r5-r11 hold their value across calls
;
;       r0 = flags on entry to FullBuffers
;       r1 = control stream handle
;       r2 -> buffers
;       r3 -> start of first buffer's data (current position during call)
;       r4 -> end of first buffer's data
;
;       r5
;       r6
;       r7 holds return from getbyte, getnextstartcode
;       r8 remaining length of packet
;       r9
;       r10 video/audio selector for packet
;       r11 packet descriptor in preparation

 [ CoroutineStackCopied
ts_extendstackblock Entry "r0-r3"
	MOV	r3, r6				; number of excess bytes needed
	LDR	r2, [r1, #CSH_CoroutineStackCopy]
	TEQ	r2, #0
	MOVEQ	r0, #ModHandReason_Claim	; if no block yet, then claim one
	MOVEQ	r3, #16*4			; of 16 words (should be enough)
	MOVNE	r0, #ModHandReason_ExtendBlock
	SWI	XOS_Module			; let's hope this never fails!
	STR	r2, [r1, #CSH_CoroutineStackCopy]
	LDR	lr, [r1, #CSH_CoroutineStackBlockSize]
	ADD	lr, lr, r3			; increased block size
	STR	lr, [r1, #CSH_CoroutineStackBlockSize]
	EXIT
 ]

CallCoroutines Entry "r5-r11"
        STR     sp, [r1, #CSH_ExternalSP]
 [ CoroutineStackCopied
	LDR	r5, [r1, #CSH_CoroutineStackSize]
	TEQ	r5, #0
	LDRNE	r6, [r1, #CSH_CoroutineStackCopy]
	ADDNE	r6, r6, r5
10
	LDRNE	r7, [r6, #-4]!
	Push	r7, NE
	SUBNES	r5, r5, #4
	BNE	%BT10
 |
        LDR     sp, [r1, #CSH_TransportSP]
 ]
        EXIT

; ts_cowait (Transport Stream layer)

ts_cowait  ALTENTRY
 [ CoroutineStackCopied
	LDR	r5, [r1, #CSH_ExternalSP]
	SUB	r5, r5, sp			; how many bytes on coroutine stack
	STR	r5, [r1, #CSH_CoroutineStackSize]
	LDR	r6, [r1, #CSH_CoroutineStackBlockSize]
	SUBS	r6, r5, r6			; number of excess bytes
	BLHI	ts_extendstackblock
	LDR	r6, [r1, #CSH_CoroutineStackCopy]
10
	Pull	r7				; there's always at least one word (r5-r11 stacked)
	STR	r7, [r6], #4			; copy data into RMA block
	SUBS	r5, r5, #4
	BNE	%BT10
 |
        STR     sp, [r1, #CSH_TransportSP]       ; save transport layer stack pointer
        LDR     sp, [r1, #CSH_ExternalSP]
 ]
        EXIT

; ts_coinit
;
; in:   r1 -> control stream handle
; out:  -
;

ts_coinit ALTENTRY                              ; must push same stuff as CoWait pulls
        STR     sp, [r1, #CSH_ExternalSP]
 [ :LNOT: CoroutineStackCopied
        LDR     sp, =TransportStack
 ]
        BL      ts_cowait

; and when we come back, drop thru to...

ts_wait_for_sync
	LDR	r7, [r1, #CSH_StreamFlags]
	TST	r7, #StreamFlags_DVB
	MOVNE	r10, #4				; skip 4 bytes of tag word
	BLNE	ts_skipbytes

;        DREG    r3, "Memory pointer = "
ts_wait_for_sync_loop
        BL      ts_getbyte
        TEQ     r7, #TS_SyncByte
        BNE     ts_wait_for_sync_loop

        MOV     r8, #TS_PacketLength-1          ; r8 = number of bytes remaining in transport packet
        BL      ts_getbytedec                   ; get TEI, PUSI, TP and top 5 bits of PID
        MOV     r9, r7                          ; and save it
        BL      ts_getbytedec                   ; get bottom 8 bits of PID
        AND     r5, r9, #&1F                    ; top 5 bits of PID
        ORR     r5, r7, r5, LSL #8              ; r5 = PID
        BL      ts_getbytedec                   ; r7 = transport_scrambling_control (2 bits), adaptation_field_control (2 bits), continuity_counter (4 bits)
        ORR     r9, r7, r9, LSL #8              ; r9 now has byte 1 of packet in bits 8..15, and byte 3 of packet in bits 0..7

 [ DoPEH

; do PEH first, so get in before old-style (SWI based) video

	LDR	lr, [r1, #CSH_ListOfPEHPIDs]
10
	TEQ	lr, #0
	BEQ	%FT20
	LDR	r6, [lr, #PEHPID_PID]
	TEQ	r5, r6				; check if PID matches
	LDRNE	lr, [lr, #PEHPID_Link]
	BNE	%BT10

; found a match, so point r5 at PEHPID and jump to common code

	MOV	r5, lr
	B	ts_process_common

20
 ] ; DoPEH

; check for video first, it's the most likely thing

        LDR     lr, [r1, #CSH_Video_PID]
        TEQ     r5, lr
        BEQ     ts_process_video_PID

        LDR     lr, [r1, #CSH_Audio_PID]
        TEQ     r5, lr
        BEQ     ts_process_audio_PID

        TEQ     r5, #0
        BEQ     ts_process_PID0
        LDR     lr, [r1, #CSH_PMT_PID]
        TEQ     r5, lr
        BEQ     ts_process_PMT_PID

; this packet was not used, so increment the count of discarded data

	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_DVB			; check if DVB (extra 4 bytes if so)
	LDR	lr, [r1, #CSH_DataDiscarded]
	ADD	lr, lr, #TS_PacketLength		; add on 1 TS packet
	ADDNE	lr, lr, #4				; add on extra 4 bytes if DVB
	STR	lr, [r1, #CSH_DataDiscarded]

ts_skip_to_next_packet
        MOV     r10, r8
        BL      ts_skipbytes
        B       ts_wait_for_sync

ts_process_PID0 ROUT
        TST     r9, #TS_Payload_Present_Bit     ; ensure there is payload in this packet
        TSTNE   r9, #TS_PUSI_Bit                ; and the PSI payload starts in this packet
        BEQ     ts_skip_to_next_packet          ; if not both of these, then no PAT in this packet, so skip it
        TST     r9, #TS_AF_Present_Bit          ; is an adaptation field present
        BLNE    ts_skip_adaptation_field        ; if so, then skip it
        BL      ts_find_PSI_start               ; use pointer field to find start of payload

        BL      ts_getbytedec                   ; get table_id field
        TEQ     r7, #TS_table_id_PAT            ; if not what we're expecting
        BNE     ts_skip_to_next_packet          ; then skip to next packet
	BL	ts_getbytedec
        AND     r9, r7, #&0F                    ; top 4 bits of section length, + 4 other bits
        BL      ts_getbytedec
	ORR	r5, r7, r9, LSL #8		; r5 = section length

        MOV     r10, #5                         ; skip another 5 bytes of header
        BL      ts_skipbytes

	SUB	r5, r5, #5+4			; 5 fewer bytes to do, and also ignore CRC_32
	LDR	r6, [r1, #CSH_CurrentProgram]
10
	SUBS	r5, r5, #4			; have we got 4 bytes left?
	BCC	ts_skip_to_next_packet		; no, so no more programs
	BL	ts_getbytedec			; get hi byte of program_number
	MOV	r9, r7
	BL	ts_getbytedec			; get lo byte of program_number
	ORRS	r9, r7, r9, LSL #8
	BEQ	%FT20				; if zero then is PID for NIT, not for a real program

	TEQ	r6, #0
	BMI	%FT25				; if negative then a program index
	TEQ	r6, r9				; else check against requested program number
	BEQ	%FT30				; is our program
20
	BL	ts_getbytedec			; skip
	BL	ts_getbytedec
	B	%BT10

25
	ADDS	r6, r6, #1			; increment program index
	BNE	%BT20				; if not zero, then loop back, else it is our program
30
        BL      ts_getbytedec
        AND     r9, r7, #&1F                    ; top 5 bits of PMT_PID
        BL      ts_getbytedec
        ORRS    r9, r7, r9, LSL #8
	LDR	lr, [r1, #CSH_PMT_PID]
        STR     r9, [r1, #CSH_PMT_PID]
	CMP	lr, r9
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB
        BEQ     ts_skip_to_next_packet		; same as last time, or not doing DVB, so continue

	Push	"r0-r2"
	MOV	r0, #PIDSlot_PMT
	MOV	r1, r9
	BL	ts_pid_enable			; enable new PMT_PID (overwrites old)
	Pull	"r0-r2"
	B	ts_skip_to_next_packet


ts_process_PMT_PID ROUT
        TST     r9, #TS_Payload_Present_Bit     ; ensure there is payload in this packet
        TSTNE   r9, #TS_PUSI_Bit                ; and the PSI payload starts in this packet
        BEQ     ts_skip_to_next_packet          ; if not both of these, then no PAT in this packet, so skip it
        TST     r9, #TS_AF_Present_Bit          ; is an adaptation field present
        BLNE    ts_skip_adaptation_field        ; if so, then skip it
        BL      ts_find_PSI_start               ; use pointer field to find start of payload

        BL      ts_getbytedec                   ; get table id
        TEQ     r7, #TS_table_id_PMT
        BNE     ts_skip_to_next_packet

        BL      ts_getbytedec
        AND     r5, r7, #&0F                    ; top 4 bits of section length
        BL      ts_getbytedec
        ORR     r5, r7, r5, LSL #8              ; r5 = section length

        BL      ts_getbytedec			; skip program number
        BL      ts_getbytedec

        BL      ts_getbytedec                   ; get 2 reserved, 5 version number, 1 current_next_indicator
        BL      ts_getbytedec                   ; get section_number (must be zero)
        BL      ts_getbytedec                   ; get last_section_number (ditto)
        BL      ts_getbytedec                   ; get 3 reserved, 5 PCR_PID [12:8]
        BL      ts_getbytedec                   ; get 8 PCR_PID [7:0]
        BL      ts_getbytedec
        AND     r9, r7, #&0F                    ; get 4 reserved, 4 program_info_length [11:8]
        BL      ts_getbytedec                   ; get 8 program_info_length [7:0]

        SUB     r5, r5, #9+4                    ; reduce count by all the bytes since section length, + 4 for CRC on end

        ORR     r10, r7, r9, LSL #8             ; program_info_length
        SUBS    r5, r5, r10                     ; reduce count for length of descriptors
	BCC	ts_skip_to_next_packet		; bogus descriptors length
 [ ParseOVSNPT
	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_OVSNPTDescriptors
	BNE	ts_check_for_OVSNPT
 ]
        BL      ts_skipbytes
ts_process_rest_of_PMT
	LDR	lr, [r1, #CSH_CurrentVideoStream] ; copy currents to temps
	STR	lr, [r1, #CSH_TempVideoStream]
	LDR	lr, [r1, #CSH_CurrentAudioStream]
	STR	lr, [r1, #CSH_TempAudioStream]
10
        SUBS    r5, r5, #5                      ; if no room for another stream type and PID
        BCC     ts_skip_to_next_packet
        BL      ts_getbytedec                   ; get stream type
        MOV     r9, r7
        BL      ts_getbytedec
        AND     r10, r7, #&1F
        BL      ts_getbytedec
        ORR     r10, r7, r10, LSL #8            ; r10 = elementary PID

        TEQ     r9, #TS_Stream_Type_MPEG1Video
 [ AllowMPEG2Video
	TEQNE	r9, #TS_Stream_Type_MPEG2Video
 ]
	BNE	%FT40

	LDR	lr, [r1, #CSH_TempVideoStream]
	SUBS	lr, lr, #1
	STR	lr, [r1, #CSH_TempVideoStream]
	BNE	%FT60				; not our stream so ignore

	LDR	lr, [r1, #CSH_Video_PID]
        STR     r10, [r1, #CSH_Video_PID]
	TEQ	lr, r10				; check if same as old
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB		; if same, or not doing DVB
	BEQ	%FT60				; then ignore

	Push	"r0-r2"
	MOV	r0, #&10000000			; large value, so will get limited to max packet size
	SWI	XDVBControl_PacketCounter
	MOV	r0, #PIDSlot_Video
	MOV	r1, r10
	BL	ts_pid_enable			; enable new video PID (overwrites old)
	Pull	"r0-r2"
	B	%FT60				; also check for PEH

40
        TEQ     r9, #TS_Stream_Type_MPEG1Audio
 [ AllowMPEG2Audio
	TEQNE	r9, #TS_Stream_Type_MPEG2Audio
 ]
	BNE	%FT60

	LDR	lr, [r1, #CSH_TempAudioStream]
	SUBS	lr, lr, #1
	STR	lr, [r1, #CSH_TempAudioStream]
	BNE	%FT60				; not our stream so ignore

	LDR	lr, [r1, #CSH_Audio_PID]
        STR     r10, [r1, #CSH_Audio_PID]
	TEQ	lr, r10				; check if same as old
	LDRNE	r7, [r1, #CSH_StreamFlags]
	TSTNE	r7, #StreamFlags_DVB		; if same, or not doing DVB
	BEQ	%FT60				; then ignore

	Push	"r0-r2"
	MOV	r0, #&10000000			; large value, so will get limited to max packet size
	SWI	XDVBControl_PacketCounter
	MOV	r0, #PIDSlot_Audio
	MOV	r1, r10
	BL	ts_pid_enable			; enable new audio PID (overwrites old)
	Pull	"r0-r2"

; and drop thru to...
; now check against the stream types of all PEHPIDs

60
 [ DoPEH
	Push	"r0,r2"
	LDR	r2, [r1, #CSH_ListOfPEHPIDs]
65
	TEQ	r2, #0				; no more PEHPIDs?
	BEQ	%FT78				; then skip
	LDR	lr, [r2, #PEHPID_PEH]		; get PEH for PEHPID
	LDR	r0, [lr, #PEH_Flags]		; first check that this PEH uses stream_type
	TST	r0, #PEHFlags_StreamIdentifiedByPID ; (bit must be clear)
	LDREQ	lr, [lr, #PEH_StreamType]	; get stream type for PEH
	TEQEQ	lr, r9				; check stream type against PEH's
	BNE	%FT75				; no match, go to next one
	STR	r10, [r2, #PEHPID_PID]		; save PID value
	LDR	r0, [r2, #PEHPID_PIDSlot]	; get PID slot
	CMP	r0, #-1				; if not valid
	BEQ	%FT75				; then goto next PEHPID
	Push	"r1,r2"
	MOV	r1, r10
	BL	ts_pid_enable			; enable this PID
	Pull	"r1,r2"
75
	LDR	r2, [r2, #PEHPID_Link]		; move to next PEHPID
	B	%BT65				; and loop
78
	Pull	"r0,r2"
 ] ; DoPEH
80
        BL      ts_getbytedec
        AND     r10, r7, #&0F
        BL      ts_getbytedec
        ORR     r10, r7, r10, LSL #8            ; r10 = ES_info_length
        SUB     r5, r5, r10
        BL      ts_skipbytes
        B       %BT10

ts_process_audio_PID
;        DREG    r8, "Entered ts_process_audio_PID, remaining packet length = "
        MOV     r5, #StreamFlags_AudioPresent           ; indicate audio data
        B       ts_process_vidoraud

ts_process_video_PID
;        DREG    r8, "Entered ts_process_video_PID, remaining packet length = "
        MOV     r5, #StreamFlags_VideoPresent           ; indicate video data
ts_process_vidoraud ROUT
        LDR     lr, [r1, #CSH_StreamFlags]
        TST     lr, r5                                  ; check we are interested in this stream
        TSTNE   r9, #TS_Payload_Present_Bit             ; and there is payload in this packet
        BEQ     ts_skip_to_next_packet
ts_process_common
        TST     r9, #TS_AF_Present_Bit                  ; is an adaptation field present

 [ SkipToSeqOnResetStream
	ASSERT	:LNOT: DoPEH				; the TEQNE r5 would be wrong
	BEQ	%FT20
	TST	lr, #StreamFlags_SkippingAfterReset	; if skipping,
	TEQNE	r5, #StreamFlags_AudioPresent		; and not an audio packet (ie *is* a video packet)
        BLNE    ts_process_adaptation_field             ; then possibly check it for random_access_indicator
	BLEQ	ts_skip_adaptation_field		; else just skip it
20
	LDR	lr, [r1, #CSH_StreamFlags]		; if still skipping data
	TST	lr, #StreamFlags_SkippingAfterReset
	BNE	ts_skip_to_next_packet
 |
        BLNE    ts_skip_adaptation_field                ; if so, then skip it
 ]

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_FullLengthUnknown ; assume not start of MPEG packet for now
        STR     r7, [r11, #PacketDescriptor_Flags]
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_FullLength] ; and zero full length for now

        TST     r9, #TS_PUSI_Bit                        ; is there a PES packet at the start of the payload
        BLNE    ts_process_PES_packet_header

        TEQ     r3, r4                                  ; ensure we've got at least one byte to send
        BLEQ    ts_cowait
ts_vidaudpacketcontinue
        STR     r2, [r11, #PacketDescriptor_BufferDescriptor] ; store pointer to buffer holding first byte of actual data
        STR     r3, [r11, #PacketDescriptor_Start]      ; store pointer to data
        BL      ts_incrementpacketcount                 ; increment packet count for buffer

 [ SkipToCorrectTrickMode
	LDR	lr, [r1, #CSH_StreamFlags]		; check stream flags to see if we should be skipping this
	TST	lr, #StreamFlags_SkipUntilCorrectMode
	BEQ	%FT30					; [no, we're OK]
	LDR	r7, [r1, #CSH_TrickModeControl]		; if we were skipping, the PES packet header we may have just had
	LDR	r10, [r1, #CSH_LastTrickModeControl]	; might be right type, so check if equal
	TEQ	r7, r10
	BICEQ	lr, lr, #StreamFlags_SkipUntilCorrectMode ; if so, then knock out bit, so we don't spend time checking any more
	STREQ	lr, [r1, #CSH_StreamFlags]		; and store back to stream flags
	BNE	ts_free_packet_and_skip			; else free packet descriptor and skip packet
30
 ]

 [ ParseOVSNPT
	LDR	lr, [r1, #CSH_StreamFlags]		; check if we're skipping
	TST	lr, #StreamFlags_OVSNPTSkipping
	BNE	ts_free_packet_and_skip			; if so, free packet descriptor and skip packet
 ]

        CMP     r8, #0                                  ; negative length packet?
        BLT     ts_free_packet_and_skip			; then free packet descriptor and skip packet
        ADD     r7, r3, r8                              ; end of transport packet (if it was all in this buffer)
        CMP     r7, r4                                  ; is it all within this buffer?
        BHI     ts_notallinbuff

        BL      ts_sendvidaudblock
        MOV     r3, r7                                  ; start from end of video block data
        B       ts_wait_for_sync

ts_notallinbuff
        SUB     r8, r7, r4                              ; r8 = amount of excess
        MOV     r7, r4
        BL      ts_sendvidaudblock                      ; send this amount
        BL      ts_cowait

        BL      GetPacketDescriptor                     ; out: r0 -> new packet descriptor (link -> 0, free, freews set up)
        MOV     r11, r0
        MOV     r7, #PacketDescriptorFlags_FullLengthUnknown
        STR     r7, [r11, #PacketDescriptor_Flags]
        MOV     r7, #0
        STR     r7, [r11, #PacketDescriptor_FullLength]
        B       ts_vidaudpacketcontinue

ts_free_packet_and_skip
        Push    "r0"
        MOV     r0, r11                                 ; r0 -> packet
        BL      FreePackets                             ; free it (possibly also freeing buffer)
        Pull    "r0"
        B       ts_skip_to_next_packet

; Transport Stream utility routines

ts_getbytedec
        SUB     r8, r8, #1                      ; decrement count of number of bytes left in transport packet
ts_getbyte
        CMP     r3, r4
        LDRCCB  r7, [r3], #1
        MOVCC   pc, r14

        Push    "lr"
        BL      ts_cowait
        Pull    "lr"
        B       ts_getbyte

ts_skipbytes ROUT
        SUB     r8, r8, r10                     ; reduce outstanding number of bytes in packet
10
        ADD     r3, r3, r10                     ; advance current pointer by r10 bytes
        CMP     r3, r4                          ; if still within buffer
        MOVLS   pc, r14                         ; then exit
        SUB     r10, r3, r4                     ; r10 = remaining bytes to skip (correction TMD 31-Jul-95 - was SUB r10,r4,r3)
        Push    "lr"
        BL      ts_cowait
        Pull    "lr"
        B       %BT10

ts_find_PSI_start                               ; this does the same thing!
ts_skip_adaptation_field Entry "r7"
        BL      ts_getbytedec                   ; get adaptation_field_length (or pointer_field)
        MOV     r10, r7                         ; then skip that number of bytes
        BL      ts_skipbytes
        EXIT

 [ SkipToSeqOnResetStream
ts_process_adaptation_field Entry "r7"
	BL	ts_getbytedec			; get adaptation_field_length
	SUBS	r10, r7, #1			; if < 1 byte, then no real adaptation field there
	EXITS	CC				; so exit

	BL	ts_getbytedec			; get byte with flags in
	TST	r7, #&40			; check random_access_indicator bit
	LDRNE	lr, [r1, #CSH_StreamFlags]	; if set, then a video sequence is coming soon (in the next video PES packet)
	BICNE	lr, lr, #StreamFlags_SkippingAfterReset ; so stop skipping now
	STRNE	lr, [r1, #CSH_StreamFlags]
	BL	ts_skipbytes			; then skip the rest of the adaptation field
	EXITS					; must preserve flags on exit
 ]

ts_process_PES_packet_header Entry
 [ DoPEH
; first check if PEH wants to get the PES packet headers himself
; if so, then don't process them ourselves

	CMP	r5, #3				; if 1 or 2 then must be vid or aud
	BCC	%FT10

	LDR	lr, [r5, #PEHPID_PEH]		; get PEH for this PEHPID
	LDR	lr, [lr, #PEH_Flags]		; get flags for this PEH
	TST	lr, #PEHFlags_IncludePESHeaders
	EXIT	NE				; he wants to get PES headers, so exit

10
 ] ; DoPEH
        BL      ts_getnextstartcode
 [ :LNOT: DoPEH					; may get other packet header codes than these in private data
        TEQ     r7, #&C0
        TEQNE   r7, #&E0
        BNE     ts_bad_packet_header
 ]

        BL      ts_getbytedec                           ; get bits 8-15 of length
        MOV     r6, r7
        BL      ts_getbytedec                           ; get bits 0-7 of length
        ORR     r6, r7, r6, LSL #8                      ; r6 = length of PES packet to go

;        DREG    r6, "Packet length = "

 [ NobbleVideoPacketLengths ; get round OVS problem by nobbling packet length to zero
	TEQ	r5, #StreamFlags_VideoPresent		; if a video packet
	MOVEQ	r6, #0					; then pretend had zero (ie indeterminate) packet length
 ]
        TEQ     r6, #0                                  ; if it's a wishy-washy indeterminate-length packet
        MOVEQ   r7, #PacketDescriptorFlags_MPEGStart :OR: PacketDescriptorFlags_FullLengthUnknown       ; then indicate that
        MOVEQ   r6, #&80000000                          ; indicate for later
        MOVNE   r7, #PacketDescriptorFlags_MPEGStart    ; else just an MPEG start
        SUBNE   r6, r6, r8                              ; express length of PES packet as offset from remaining length of transport packet
        STR     r7, [r11, #PacketDescriptor_Flags]

        BL      ts_getbytedec
        MOV     r7, r7, LSR #6
        TEQ     r7, #2_10
        BNE     ts_bad_packet_header                    ; if not '10' at start, then not MPEG 2 PES

        Push    "r5"                                    ; save video/audio flag, so we can use r5 as temp here
        BL      ts_getbytedec                           ; get optional fields flags
        MOV     r5, r7
        BL      ts_getbytedec                           ; get length of optional fields
        MOV     r10, r7

        TST     r5, #PES_Optional_PTS_Present		; PTS present?
        BEQ     ts_nopts
        BL      ts_getbytedec                           ; get 1st byte of PTS
        BL      ts_getclockreference
        ADD     lr, r11, #PacketDescriptor_PTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_PTSValid ; set PTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        SUB     r10, r10, #5

        TST     r5, #PES_Optional_DTS_Present		; DTS present also?
        BEQ     ts_nodts
        BL      ts_getbytedec                           ; get 1st byte of DTS
        BL      ts_getclockreference
        ADD     lr, r11, #PacketDescriptor_DTS
        STMIA   lr, {r7, r9}
        LDR     r9, [r11, #PacketDescriptor_Flags]
        ORR     r9, r9, #PacketDescriptorFlags_DTSValid ; set DTSValid bit in flags
        STR     r9, [r11, #PacketDescriptor_Flags]
        SUB     r10, r10, #5
ts_nodts
ts_nopts
 [ SkipToCorrectTrickMode
	TST	r5, #PES_Optional_DSM_trick_mode_flag	; if the DSM trick mode field isn't present,
	MOVEQ	r5, #-1					; then indicate normal play, and skip the rest of the parsing
	BEQ	%FT20					; then don't go thru the hassle of skipping other fields before it

	MOV	r9, r10					; save number of bytes of header yet to skip
	TST	r5, #PES_Optional_ESCR_flag
	MOVEQ	r10, #0					; if no ESCR flag then no bytes to skip for it
	MOVNE	r10, #6					; else skip 6 bytes of ESCR
	TST	r5, #PES_Optional_ES_rate_flag		; if ES_rate flag present
	ADDNE	r10, r10, #3				; then skip another 3 bytes of that
	SUB	r9, r9, r10				; how many left to skip
	BL	ts_skipbytes				; skip the bytes

	BL	ts_getbytedec				; get trick_mode_control in bits 7:5, plus some other bits
	MOV	r5, r7, LSR #5				; extract the important bits
	SUB	r10, r9, #1				; bytes left to skip in header, not counting the byte we just got
20
	STR	r5, [r1, #CSH_LastTrickModeControl]	; and save indication of last trick_mode_control value, or -1 if none
 ]
        BL      ts_skipbytes                            ; skip other optional fields
        Pull    "r5"                                    ; restore audio/video flag

        TEQ     r6, #&80000000                          ; if was indeterminate length
        MOVEQ   r6, #0                                  ; then stick zero in full length
        ADDNE   r6, r6, r8                              ; else convert packet length back from offset
        STR     r6, [r11, #PacketDescriptor_FullLength] ; save full length of MPEG packet data (ignoring buffer breaks)
        EXIT

ts_bad_packet_header
        DLine   "Bad PES packet header"
        PullEnv
        B       ts_skip_to_next_packet

; This routine gets a 33-bit PTS, DTS or SCR from the stream
;
; in:   r7 = first byte (including bits 32..30)
; out:  r7 = low 32 bits
;       r9 = bit 32 in bit 0

ts_getclockreference ROUT
        Push    "lr"
        AND     r7, r7, #&0E                            ; extract bits 3..1
        MOV     r9, r7, LSR #3                          ; r9 = bit 32 in bit 0
        Push    "r9"                                    ; save for later
        MOV     r9, r7, LSL #31-2                       ; r9 = bits 31,30
        BL      ts_getbytedec                           ; get bits 29..22 in bits 7..0
        ORR     r9, r9, r7, LSL #22                     ; r9 = bits 31..22
        BL      ts_getbytedec                           ; get bits 21..15 in bits 7..1
        MOV     r7, r7, LSR #1
        ORR     r9, r9, r7, LSL #15                     ; r1 = bits 31..15
        BL      ts_getbytedec                           ; get bits 14..7 in bits 7..0
        ORR     r9, r9, r7, LSL #7                      ; r1 = bits 31..7
        BL      ts_getbytedec                           ; get bits 6..0 in bits 7..1
        ORR     r7, r9, r7, LSR #1                      ; r9 = bits 31..0
        Pull    "r9, pc"

ts_incrementpacketcount Entry "r0"
        MOV     r0, pc
        ORR     lr, r0, #I_bit                          ; disable IRQs
        TEQP    lr, #0

        LDR     lr, [r2, #BufferDescriptor_Packets]
        ADD     lr, lr, #1
        STR     lr, [r2, #BufferDescriptor_Packets]

        TEQP    r0, #0                                  ; restore IRQ state
        EXIT

        LTORG

ts_getnextstartcode Entry
ts_getnextstartcodeloop
        BL      ts_getbytedec                           ; look for 1st zero of start code
        TEQ     r7, #0
        BNE     ts_getnextstartcodeloop
        BL      ts_getbytedec                           ; look for 2nd zero of start code
        TEQ     r7, #0
        BNE     ts_getnextstartcodeloop
ts_gottwozeros
        BL      ts_getbytedec                           ; look for "1" of start code
        CMP     r7, #1
        BCC     ts_gottwozeros                          ; if 3rd zero, then not start code, but we've got two zeros
        BNE     ts_getnextstartcodeloop                 ; not zero or one, so look for 1st zero again
        BL      ts_getbytedec                           ; get start code reason
        EXIT

 [ ParseOVSNPT

NPTDescriptorTag	*	&17

ts_check_for_OVSNPT ROUT
	CMP	r10, #1
	BCC	ts_process_rest_of_PMT			; no descriptor bytes left, so do rest of PMT
	BEQ	ts_skip_to_next_packet			; only 1 byte left, but need tag and length!
	BL	ts_getbytedec				; get descriptor tag
	MOV	r9, r7
	BL	ts_getbytedec				; get descriptor length
	SUB	r10, r10, #2				; adjust for tag + length bytes
	CMP	r7, r10					; if descriptor length > descriptors length
	CMPLS	r7, r8					; or descriptor length > rest of packet length
	BHI	ts_skip_to_next_packet			; then bogus
	SUB	r10, r10, r7				; remaining bytes of descriptors
	TEQ	r9, #NPTDescriptorTag
	BEQ	%FT10					; found NPT descriptor
05
	Push	"r10"
	MOV	r10, r7
	BL	ts_skipbytes				; skip the whole (or rest) of this descriptor
	Pull	"r10"
	B	ts_check_for_OVSNPT			; and try again

10
	Push	"r5"
	MOV	r5, r7					; length of this descriptor
	CMP	r7, #CSH_NPTDescMaxLen			; maximum amount we can store
	MOVHI	r5, #CSH_NPTDescMaxLen			; amount we will store
	SUB	r7, r7, r5				; amount we won't store
	Push	"r7"
	ADD	r9, r1, #CSH_NPTDescLength		; point at length field
	STRB	r5, [r9], #1				; indicate amount stored
20
	SUBS	r5, r5, #1				; if no more bytes to store
	BCC	%FT30					; then exit
	BL	ts_getbytedec				; else get another
	STRB	r7, [r9], #1				; and store in block
	B	%BT20					; then loop

30
	LDRB	r7, [r1, #CSH_NPTContentID]		; get new contentID
	AND	r7, r7, #&7F				; only bottom 7 bits are the contentID
	LDR	lr, [r1, #CSH_StreamFlags]
	TST	lr, #StreamFlags_OVSNPTSkipping		; are we looking for a change right now
	BEQ	%FT40					; no then skip
	LDR	r5, [r1, #CSH_LastContentID]		; see what it was last time
	TEQ	r5, r7					; have we changed?
	BICNE	lr, lr, #StreamFlags_OVSNPTSkipping	; if so then clear skipping bit from flags
	STRNE	lr, [r1, #CSH_StreamFlags]		; and store back
40
	STR	r7, [r1, #CSH_LastContentID]		; always store new contentID as last
	Pull	"r7"
	Pull	"r5"					; wrong order to do in one go
	B	%BT05					; skip any part of the descriptor we couldn't store

 ]

; **************************************************************************
;
;       ts_sendvidaudblock - send block of video/audio data
;
; in:
;       r1 = control stream handle
;       (r2 -> buffer descriptor)
;       r3 -> start of block to send (not necessarily start of buffer))
;       (r4 -> end of buffer)
;	r5 = StreamFlags_VideoPresent, StreamFlags_AudioPresent, or a pointer to the appropriate PEHPID
;       r7 -> end of block to send (+1))
;       r10 = start code for video or audio packet so we know which
;       r11 -> packet descriptor (filled in apart from Length field)

ts_sendvidaudblock Entry "r0-r2"
        SUB     r0, r7, r3
        STR     r0, [r11, #PacketDescriptor_Length]
        MOV     r0, #0                  ; flags for MPEGVideo/Audio_FullPackets
        MOV     r2, r11
        TEQ     r5, #StreamFlags_VideoPresent
        BNE     %FT30

; send video block

        LDR     lr, DebugFlag
        TEQ     lr, #0
        BEQ     %FT20
        DLINE   "Video packet", cc
        Push    "r0"
        LDR     lr, [r2, #PacketDescriptor_Length]
        DREG    lr, ", length = ", cc
        LDR     lr, [r2, #PacketDescriptor_FullLength]
        DREG    lr, ", full length = ", cc
        SWI     XOS_WriteI+" "
        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_MPEGStart
        SWINE   XOS_WriteI+"M"
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown
        SWINE   XOS_WriteI+"U"
        TST     r0, #PacketDescriptorFlags_PTSValid
        BEQ     %FT10
        LDR     lr, [r2, #PacketDescriptor_PTS]
        DREG    lr, " PTS = ", cc
10
        DLINE   ""
        Pull    "r0"
20
        LDR     r1, [r1, #CSH_VideoStreamHandle]
        SWI     XMPEGVideo_FullPackets
        CLRV
        EXIT

30
 [ DoPEH
	TEQ	r5, #StreamFlags_AudioPresent
	BNE	%FT60
 ] ; DoPEH

; send audio block

        LDR     lr, DebugFlag
        TEQ     lr, #0
        BEQ     %FT50
        DLINE   "Audio packet", cc
        Push    "r0"
        LDR     lr, [r2, #PacketDescriptor_Length]
        DREG    lr, ", length = ", cc
        LDR     lr, [r2, #PacketDescriptor_FullLength]
        DREG    lr, ", full length = ", cc
        SWI     XOS_WriteI+" "
        LDR     r0, [r2, #PacketDescriptor_Flags]
        TST     r0, #PacketDescriptorFlags_MPEGStart
        SWINE   XOS_WriteI+"M"
        TST     r0, #PacketDescriptorFlags_FullLengthUnknown
        SWINE   XOS_WriteI+"U"
        TST     r0, #PacketDescriptorFlags_PTSValid
        BEQ     %FT40
        LDR     lr, [r2, #PacketDescriptor_PTS]
        DREG    lr, " PTS = ", cc
40
        DLINE   ""
        Pull    "r0"
50
        LDR     r1, [r1, #CSH_AudioStreamHandle]
        SWI     XMPEGAudio_FullPackets
        CLRV
        EXIT

 [ DoPEH
60
	Push	"r3,r6"
	LDR	r6, [r5, #PEHPID_PEH]
	MOV	r3, r2						; r3 -> packet
	LDR	r2, [r5, #PEHPID_ProgramElementStreamHandle]
	MOV	r1, #0						; flags
	MOV	r0, #PEHReason_DataTransfer
	BL	CallPEH
	Pull	"r3,r6"
	CLRV
	EXIT
 ] ; DoPEH

debug SETL {FALSE}

ts_pid_enable Entry "r1"
	AND	r2, r1, #&FF
	AND	r1, r1, #&1F00
	ORR	r1, r1, #&47
	ORR	r1, r1, r2, LSL #16
	LDR	r2, =&00FF1FFF
	SWI	XDVBControl_MatchMask
	EXIT

; **************************************************************************
;
;       GetPacketDescriptor - Get a packet descriptor from free list, or RMA if that fails
;
; in:   r12 -> module workspace
;
; out:  r0 -> packet descriptor
;

GetPacketDescriptor Entry "r1"
        MOV     r1, pc
        ORR     lr, r1, #I_bit                  ; disable IRQs

        LDR     r0, FreePacketListHeadPtr
        TEQ     r0, #0
        BEQ     %FT10                           ; [no free packet descriptors]

        LDR     lr, [r0, #PacketDescriptor_Link]
        STR     lr, FreePacketListHeadPtr       ; update FreePacketListHeadPtr
        TEQ     lr, #0                          ; and if no more,
        STREQ   lr, FreePacketListTailPtr       ; then zero FreePacketListTailPtr

        TEQP    r1, #0                          ; restore IRQs
05
        MOV     lr, #0
        STR     lr, [r0, #PacketDescriptor_Link] ; terminate this packet descriptor
                                                ; (we might want to be able to free multiple packets eventually)
; now fill in some of the fields
        ADRL    r1, FreePackets
        STR     r1, [r0, #PacketDescriptor_FreeRoutine]
        STR     wp, [r0, #PacketDescriptor_FreeWorkspace]
        CLRV
        EXIT

10
        TEQP    r1, #0                          ; restore IRQ state
        Push    "r2, r3"
        MOV     r3, #PacketDescriptorSize
        MOV     r0, #ModHandReason_Claim
        SWI     XOS_Module
        MOVVC   r0, r2
        Pull    "r2, r3"
        BVC     %BT05
        EXIT

 [ DoPEH
; **************************************************************************
;
;	CallPEH - Call a Program Element Handler
;
; in:	r0 = reason code
;	r1-r? = parameters for call
;	r6 -> PEH
;
; out:	Depends on call
;

CallPEH	Entry "r12"
	ADD	r12, r6, #:INDEX: PEH_HandlerWS
	ASSERT  PEH_HandlerCode = PEH_HandlerWS +4
	MOV	lr, pc
	LDMIA	r12, {r12, pc}
	EXIT
 ] ; DoPEH

; **************************************************************************
;
;	Stats - Entry point for MPEGControl_Stats - return statistics
;
; in:	r0 = flags (zero at present)
;	r1 = control stream handle, or zero for stream-independent vars
;	r2 -> list of statistic tags, terminated by -1
;	r3 -> word-aligned buffer to dump data
;	r4 = size of buffer (in bytes)
;
; out:
;	r3 -> after last byte put into buffer
;	r4 = entry r4 - total size of entries requested, whether or not they were put in buffer

		^	0
StatsTable_Tag	#	4
StatsTable_ID	#	4	; if +ve, then offset in workspace of word to return
				; if -ve, then -offset into module code of routine to handle it
StatsTableEntrySize	#	0

; In contrast to the implementations in the elementary modules, the MPEGControl items
; are either the offset from the *stream handle* to the value (if positive), or the negation
; of the code offset into the module if a routine (if negative)
; Unfortunately, you can't use :BASE: with an absolute item (eg the CSH_ values), so
; we have to have an explicit flag on the macro.

	MACRO
	StatsTableEntry	$tag, $value, $codeP
 [ "$codeP"=""
	&	$tag, :INDEX: ($value)
 |
	&	$tag, (Module_BaseAddr - ($value))
 ]
	MEND

Stats	Entry "r0-r2, r5-r6"

; First call video and audio to output their stuff

	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_VideoStreamHandle]
	SWI	XMPEGVideo_Stats
	LDMIA	sp, {r0,r1}			; reload flags + control handle
	TEQ	r1, #0
	LDRNE	r1, [r1, #CSH_AudioStreamHandle]
	SWI	XMPEGAudio_Stats

; Note: r3 and r4 will have been updated after those

	LDMIA	sp, {r0,r1}			; reload flags + control handle again
	TEQ	r1, #0				; if no handle specified
	ADREQ	r1, ControlStreamHandle		; then use global one

; loop over all tags in input list, advancing input list pointer r2

10
	LDR	r5, [r2], #4			; get next requested tag word
	CMP	r5, #-1				; if end of list
	BEQ	%FT90				; then exit

	ADR	r6, StatsTable
20
	LDR	lr, [r6, #StatsTable_Tag]	; get our tag
	CMP	lr, #-1				; hit end of our table, so ignore this input tag
	BEQ	%BT10
	TEQ	lr, r5				; is it his tag
	ADDNE	r6, r6, #StatsTableEntrySize
	BNE	%BT20				; no, so loop

	LDR	lr, [r6, #StatsTable_ID]
	TEQ	lr, #0
	LDRPL	r6, [r1, lr]			; NB: relative to handle, not wp
	BPL	%FT50

; negative number, so -code offset within module

	ADRL	r6, Module_BaseAddr		; point at start of module
	SUB	r6, r6, lr			; subtract a negative number
	MOV	lr, pc
	MOV	pc, r6				; returns value in r6
50
	SUBS	r4, r4, #12			; decrement buffer free space
	MOVPL	lr, r6				; value of statistic
	MOVPL	r6, #4				; length of statistic
	STMPLIA	r3!, {r5,r6,lr}			; store tag, length, value
	B	%BT10				; go back for more stats

; done all tags

90
	CMP	r4, #0				; if remaining space in buffer is >=0, then V:=0
	EXIT	PL				; and exit

	ADR	r0, BufferOverflowError		; else return an error
	STR	r0, [sp]
	SETV
	EXIT

BufferOverflowError
	&	0
	=	"Buffer overflow", 0
	ALIGN

; The statistics that are done by routine:
; (must come before StatsTable so not forward reference)

Stats_InTime Entry
	LDR	r6, [r1, #CSH_LastTime]		; lasttime - starttime
	LDR	lr, [r1, #CSH_StartTime]
	SUB	r6, r6, lr
	EXIT

Stats_SkippingAfterReset Entry
	LDR	r6, [r1, #CSH_StreamFlags]
	ANDS	r6, r6, #StreamFlags_SkippingAfterReset
	MOVNE	r6, #1
	EXIT

Stats_SkippingUntilCorrectMode Entry
	LDR	r6, [r1, #CSH_StreamFlags]
	ANDS	r6, r6, #StreamFlags_SkipUntilCorrectMode
	MOVNE	r6, #1
	EXIT

; The table containing all the statistics

StatsTable
	StatsTableEntry &0000, CSH_DataReceived
	StatsTableEntry &0001, Stats_InTime, Code
 [ SkipToSeqOnResetStream
	StatsTableEntry &0002, Stats_SkippingAfterReset, Code
 ]
	StatsTableEntry &0003, CSH_PMT_PID
	StatsTableEntry &0004, CSH_Video_PID
	StatsTableEntry &0005, CSH_Audio_PID
	StatsTableEntry &0006, CSH_DataReturned
	StatsTableEntry &0007, Stats_SkippingUntilCorrectMode, Code
	StatsTableEntry &0008, CSH_DataDiscarded
	&	-1

; **************************************************************************
;
;       CtrlInfo_Code - Code to handle CtrlInfo command
;
; in:   -
; out:  -

CtrlInfo_Code Entry
        LDR     wp, [r12]
        ADR     r1, ControlStreamHandle

        LDR     r0, [r1, #CSH_PMT_PID]
        DREG    r0, "PMT_PID = "

        LDR     r0, [r1, #CSH_Video_PID]
        DREG    r0, "Video_PID = "

        LDR     r0, [r1, #CSH_Audio_PID]
        DREG    r0, "Audio_PID = "

        DLINE   "Bytes received = ", cc

        LDR     r0, [r1, #CSH_DataReceived]
        BL      DecimalOutput
        DLINE   ""
        MOV     r2, r0

        DLINE   "Bytes returned = ", cc

        LDR     r0, [r1, #CSH_DataReturned]
        BL      DecimalOutput
        DLINE   ""

        DLINE   "In time ", cc
        LDR     r0, [r1, #CSH_LastTime]
        LDR     r3, [r1, #CSH_StartTime]
        SUB     r0, r0, r3
        BL      DecimalOutput
        DLINE   " cs"

        TEQ     r0, #0
        BEQ     %FT10

; we want to perform (bytes*100)/cs, but bytes*100 might overflow 32 bits
; so we do bytes/cs then multiply fractional part by 100 and add on

        DivRem  r3, r2, r0, r4
        MOV     r4, #100
        MUL     r2, r4, r2              ; multiply fractional part by 100
        DivRem  r5, r2, r0, r14         ; and divide by denominator
        Push    "r0"                    ; save amount of time for later
        MLA     r0, r3, r4, r5          ; add on original value*100
        DLINE   "Average data rate = ", cc
        BL      DecimalOutput
        DLINE   " bytes/second"
        Pull    "r0"
 [ DataRateStats
; r0 = number of centiseconds since starting

        LDR     lr, =DataCountPeriod*100
        DivRem  r2, r0, lr, r3          ; r2 = number of periods since starting
        CMP     r2, #DataCountArraySize ; if filled array
        MOVHI   r2, #DataCountArraySize ; then pretend we just filled it
        ADD     r3, r1, #CSH_DataCounts
        MOV     r4, #0                  ; period number
05
        TEQ     r4, r2                  ; if no more periods
        BEQ     %FT10                   ; then finished
        DLINE   "In period ", cc
        MOV     r0, r4
        BL      DecimalOutput
        DLINE   ", average data rate was ", cc
        LDR     r5, [r3], #4
        LDR     lr, =DataCountPeriod
        DivRem  r0, r5, lr, r6          ; convert from bytes/minute to bytes/second
        BL      DecimalOutput
        DLINE   " bytes/second"
        ADD     r4, r4, #1
        B       %BT05
 ]
10
 [ SkipToSeqOnResetStream
	LDR	r0, [r1, #CSH_StreamFlags]
	TST	r0, #StreamFlags_SkippingAfterReset
	BEQ	%FT20
	DLINE	"*** Still skipping after a reset ***"
20
 ]

 [ Save1stPacket
	LDR	r2, [r1, #CSH_SavedLength]
	ADD	r4, r1, #CSH_SavedData
	MOV	r3, #0
	TEQ	r2, #0
	BEQ	%FT35
	DLINE   "First TS packet is as follows:"
30
	LDRB	r0, [r4], #1
	BREG	r0, "", cc
	ADD	r3, r3, #1
	CMP	r3, #16
	MOVEQ	r3, #0
	SWIEQ	XOS_NewLine
	SUBS	r2, r2, #1
	BNE	%BT30
35
	TEQ	r3, #0
	SWINE	XOS_NewLine
 ]

 [ ParseOVSNPT
	LDR	r0, [r1, #CSH_LastContentID]
	DREG	r0, "Last contentID = "
 ]
 [ DoPEH
	DLINE	"Program Element Handlers:", cc
	LDR	r0, GlobalPEHList
	TEQ	r0, #0
	BNE	%FT40

	DLINE	" None"
	B	%FT50
40
	DLINE	""
42
	BL	OutputPEHInfo
	LDR	r0, [r0, #PEH_Link]
	TEQ	r0, #0
	BNE	%BT42
50
	DLINE	"PEH PID nodes:", cc
	ADR	r0, ControlStreamHandle
	LDR	r1, [r0, #CSH_ListOfPEHPIDs]
	TEQ	r1, #0
	BNE	%FT60

	DLINE	" None"
	B	%FT70
60
	DLINE	""
	LDR	r0, [r1, #PEHPID_Flags]
	DREG	r0, "PEHPID flags="
	LDR	r0, [r1, #PEHPID_ProgramElementStreamHandle]
	DREG	r0, "Program element stream handle="
	LDR	r0, [r1, #PEHPID_PID]
	DREG	r0, "PID="
	LDR	r0, [r1, #PEHPID_PIDSlot]
	DREG	r0, "PID slot="
	LDR	r0, [r1, #PEHPID_PEH]
	BL	OutputPEHInfo
	LDR	r1, [r1, #PEHPID_Link]
	TEQ	r1, #0
	BNE	%BT60
70
 ] ; DoPEH
        CLRV
        EXIT

 [ DoPEH
OutputPEHInfo Entry "r1"
	LDR	r1, [r0, #PEH_StreamType]
	DREG	r1, " StreamType=", cc
	LDR	r1, [r0, #PEH_Flags]
	DREG	r1, " Flags=", cc
	LDR	r1, [r0, #PEH_HandlerCode]
	DREG	r1, " Code=", cc
	LDR	r1, [r0, #PEH_HandlerWS]
	DREG	r1, " WS="
	EXIT
 ] ; DoPEH

        LTORG

; **************************************************************************

CtrlDebugOn_Code Entry
        MOV     r0, #1
        B       CtrlDebugCommon

CtrlDebugOff_Code ALTENTRY
        MOV     r0, #0
CtrlDebugCommon
        LDR     wp, [r12]
        STR     r0, DebugFlag
        EXIT

; **************************************************************************
;
;       DecimalOutput - Decimal output routine
;
; in:   r0 = value to be output
; out:  -

DecimalOutput Entry "r0-r2",16
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        SWI     XOS_Write0
        EXIT

; **************************************************************************
;
;       Message stuff


 [ international
CopyError ENTRY "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile ENTRY "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message ENTRY "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message ENTRY "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END
