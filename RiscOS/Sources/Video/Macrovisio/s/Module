; > Module

; Macrovision module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 27-Nov-95  TMD  0.01		Started.
; 06-Dec-95  TMD  0.01		First version released for DEC
; 06-Dec-95  TMD  0.02		Started on pulsation of AGC levels
; 17-Jan-96  TMD  0.03		Reset to normal video path on Service_PreReset
; 25-Jul-96  TMD  0.04		Split into two variants: STB2/1 and STB2/2
; 07-Aug-96  TMD  0.05		Optionally program CTRL1 signal on SCART
; 08-Aug-96  TMD  0.06		Add ForceMacroVideoPath option, for podules without daughter cards
; 08-Aug-96  TMD  0.07		Conditionally disabled RGB DACs when anti-taping
; 08-Aug-96  TMD  0.08		Remove debugging output on PaletteV
; 14-Aug-96  TMD  0.09		Modify initialisation to work on NTSC machines
; 14-Aug-96  TMD  0.10		Fixed FISE bit on NTSC machines
; 15-Aug-96  TMD  0.11		Fixed setting of PendingTVStandard on NTSC
; 12-Sep-96  TMD  0.12		Added variant C (STB2/2) as distinct from B (MPEG2 podule, new style) and A (MPEG1)
; 02-Oct-96  TMD  0.14		Fixed corruption of r0,r1 in Service_PreReset
; 07-Oct-96  TMD  0.15		No functional change - just delete old Hdr.Macrovisio from SrcFiler,
;				 so it doesn't get used as Hdr:Macrovision (something completely different!)
; 22-Oct-96  TMD  0.16		Alter SelectVideoPath so it only turns on CTRL1 if CTRL0 is on at the time, so on
;				 Service_PreReset we don't turn video back on again (eg when Standby is pressed).
; 31-Oct-96  TMD  0.17		Make programming of RCV2 pulse use system variables Macrovision$RCV2S, Macrovision$RCV2E
; 19-Oct-98  TMD  0.18		Disable colour burst inversion (Elmsdale don't want it).
; 13-Jan-99  NDT  0.19		Added double TDA8540 support (Variant D) and PAL/NTSC on IOMD_C_LINES
; 02-Feb-99  NDT  0.20          Modified to include the correct header file. RF bits now set on STB3.
;                                Fixed to build non STB3 variants...
; 02-Feb-99  BJGA 0.21          Sets modulator & boost bits in TDA-1 according to PAL/NTSC and CTRL0 bits from IOMD_CLINES.
;                                Handles Service_Standby (switches in and out of Standby video path).
;

	LEADR	Module_LoadAddr

TAB	*	9
LF	*	10
FF	*	12
CR	*	13

; Default foreground text/graphics colour in Macrovision modes

DefaultForegroundColour	*	3

 [ :LNOT: ProvideSWI
; Structure of a mode entry

			^	0
MVMode_LinkOffset	#	4		; Offset from node to next node (0 if end)
MVMode_ModeNumber	#	4		; Mode number
MVMode_VarNameOffset	#	4		; Offset from node to variable name
MVMode_Type		#	4		; 0 => normal video path, 1 => macro no anti-tape, 2 => anti-tape
MVMode_TVStandard	#	4		; 0 => PAL, 1 => NTSC

	MACRO
$label	MVModeNode	$modenumber, $varnameaddr, $type, $tvstandard, $next
$label
10
 [ "$next" = ""
	&	0
 |
	&	$next - %BT10
 ]
	&	$modenumber
	&	$varnameaddr - %BT10
	&	$type
	&	$tvstandard
	MEND
 ]

		^	0, wp

IICDataBlockPtr #	4		; debugging to store address of last compacted data block used
PaletteVClaimed	#	4		; 0 => PaletteV not claimed, 1 => PaletteV claimed
EventVClaimed	#	4		; 0 => EventV not claimed, 1 => EventV claimed
PaletteVCallbackRequested #	4	; non-zero => we have an outstanding callback to set the default colours
EventVCallbackRequested #	4	; non-zero => we have an outstanding callback to vary the AGC level

VSyncCount	#	4		; number of vsyncs till next modulation
AGCModulationPosition # 4		; position in table for next thing to do

MacroType	#	4		; 0 for normal video path, 1 for macrovision no anti-taping, 2 for anti-taping
TVStandard	#	4		; 0 for PAL, 1 for NTSC

 [ ProvideSWI
PendingMacroType #	4		; what to select on next mode change
PendingTVStandard #	4		; ditto for TV standard
 ]

LogicalPalette	#	8*4		; BBGGRR00 for each of colours 0 to 7
TempModulationBlock #	2		; sub-address, data for real-time s/w modulation
		#	1		; keep it aligned
SAA7183IICData  #	1		; 1 byte for sub-address
SAA7183IICMap	#	128		; copy of the 128 sub-address registers in the SAA7183


 [ international
MessageFile_Block #	16
MessageFile_Open  #	4
 ]

Module_WorkspaceSize * :INDEX: @

 [ :LNOT: ProvideSWI
MacrovisionPALMode0	*	64
MacrovisionPALMode1	*	65
MacrovisionNTSCMode0	*	66
MacrovisionNTSCMode1	*	67
 ]

IICDevice_SAA7183	*	&88
IICDevice_TDA8540	*	&98
IICDevice_TDA8540_2	*	&9c

VIDC		*	&03500000	; address to poke VIDC20

; Sub-addresses within SAA7183

SubAddress_PULM		*	&21	; register with PULM bit
SubAddress_OVL_LUT_Y0	*	&42	; base sub-address for palette entries
SubAddress_AGCL		*	&60	; AGC level
SubAddress_AGCFB	*	&7D	; register with AGCFB bit

; Bit masks within register

BitMask_AGCL		*	&FF
BitMask_PULM		*	1 :SHL: 3
BitMask_AGCFB		*	1 :SHL: 6

; Masks withing AGC table entries

AGCBitMask_AGCL		*	&FF :SHL: 0
AGCBitShift_PULM	*	8
AGCBitMask_PULM		*	1 :SHL: AGCBitShift_PULM
AGCBitShift_AGCFB	*	9
AGCBitMask_AGCFB	*	1 :SHL: AGCBitShift_AGCFB
AGCBitShift_Fields	*	16

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
 [ ProvideSWI
	&	MacrovisionSWI_Base ; SWI chunk
	&	Mod_SWIHandler-Module_BaseAddr
	&	Mod_SWITable-Module_BaseAddr
 |
        &       0 ; SWI chunk
        &       0 ; Mod_SWIHandler-Module_BaseAddr
        &       0 ; Mod_SWITable-Module_BaseAddr
 ]
        &       0                               ; no swi name decode entry

Mod_Title
        =       "Macrovision", 0

Mod_HelpStr
        =       "Macrovision", TAB, "$Module_MajorVersion ($Module_Date)"
        [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
        =       0
        ALIGN

Mod_HC_Table	*	Module_BaseAddr		; no star commands

 [ ProvideSWI
Mod_SWITable
	=	"Macrovision", 0
	=	"SetState", 0
	=	0
	ALIGN
 ]

; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [r12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, PaletteVClaimed
	STR	r0, EventVClaimed
	STR	r0, PaletteVCallbackRequested
	STR	r0, EventVCallbackRequested
	STRB	r0, SAA7183IICData	; zero sub-address

 [ ProvideSWI
	STR	r0, PendingMacroType
	STR	r0, PendingTVStandard
 |
	ADR	r0, RMEnsureInterlaceString
	SWI	XOS_CLI
	EXIT	VS
 ]

 [ ReadVarsForRCV2Timing
; Now check if the Macrovision$RCV2S/E variables have been set up, and if not, set them ourselves

	ADR	r0, MacroVarRCV2SName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT10			; [variable exists]

	ADR	r0, MacroVarRCV2SName
	LDR	r1, =RCV2S
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
10

	ADR	r0, MacroVarRCV2EName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT20			; [variable exists]

	ADR	r0, MacroVarRCV2EName
	LDR	r1, =RCV2E
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
20
 ]

 [ ExternalSyncGenerator
; doesn't matter what we put as TV format here, since Macrovision chip
; is not master sync generator

	MOV	r1, #0			; (PAL)
 |
   [ MPEG2PoduleStatus2_NTSCNotPAL <> 0
	MOV	r0, #CardControlReason_ReadStatusRegister
	SWI	XMPEGVideo_CardControl
	EXIT	VS
	ANDS	r1, r1, #(MPEG2PoduleStatus2_NTSCNotPAL :SHL: 8) ; 0 (PAL) if bit clear
   |
	ASSERT	IOMD_C_PALNTSCType <> 0
	MOV	r1, #IOMD_Base
	LDR	r1, [r1, #IOMD_CLINES]
	ANDS	r1, r1, #IOMD_C_PALNTSCType	; 0 (PAL) if bit clear
   ]
	MOVNE	r1, #1			; 1 (NTSC) if bit set
	STR	r1, PendingTVStandard
 ]
	MOV	r0, #0			; default to macrovision off
	BL	SelectVideoPath
	EXIT	VS

 [ :LNOT: ProvideSWI
	BL	SetVars
	EXIT	VS
 ]
        CLRV
        EXIT

 [ ReadVarsForRCV2Timing
MacroVarRCV2SName
	=	"Macrovision$$RCV2S", 0
MacroVarRCV2EName
	=	"Macrovision$$RCV2E", 0
	ALIGN
 ]

 [ :LNOT: ProvideSWI
SetVars Entry
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	ADD	r1, r5, #MVMode_ModeNumber ; point r1 at value
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal
	BVS	%FT90			; if error, unset all vars and exit VS

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0			; check for end, and clear V if EQ
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXIT

90
	BL	UnsetVars
	EXIT

UnsetVars Entry "r0"
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	MOV	r2, #-1			; length of value (ie delete)
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXITS				; exit preserving all flags and r0

; in: r2 = mode number; out: if Macrovision mode, r0 -> node, EQ, else r0 corrupted, NE

CheckMacroMode Entry
	ADR	r0, VarTable
10
	LDR	lr, [r0, #MVMode_ModeNumber]
	TEQ	lr, r2
	EXIT	EQ

	LDR	lr, [r0, #MVMode_LinkOffset]
	TEQ	lr, #0
	ADDNE	r0, r0, lr
	BNE	%BT10
	TEQ	lr, #1			; set NE (cos lr = 0)
	EXIT


RMEnsureInterlaceString
	=	"RMEnsure Interlace 0.37 Error 0 Macrovision module requires the Interlace module version 0.37 or later", 0
MacroVarPAL0Name
	=	"Macrovision$$PAL0", 0
MacroVarPAL1Name
	=	"Macrovision$$PAL1", 0
MacroVarNTSC0Name
	=	"Macrovision$$NTSC0", 0
MacroVarNTSC1Name
	=	"Macrovision$$NTSC1", 0
	ALIGN

VarTable
VarPAL0Entry	MVModeNode MacrovisionPALMode0, MacroVarPAL0Name, 1, 0, VarPAL1Entry
VarPAL1Entry	MVModeNode MacrovisionPALMode1, MacroVarPAL1Name, 2, 0, VarNTSC0Entry
VarNTSC0Entry	MVModeNode MacrovisionNTSCMode0, MacroVarNTSC0Name, 1, 1, VarNTSC1Entry
VarNTSC1Entry	MVModeNode MacrovisionNTSCMode1, MacroVarNTSC1Name, 2, 1
 ]

; *****************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; insert anything we need here!

	LDR	r0, PaletteVClaimed
	TEQ	r0, #0
	BNE	%FT90			; [on vectors, so must be in Macrovision mode, so not safe to die]

; safe to die

	BL	RemoveCallbacks		; remove any outstanding callbacks
 [ :LNOT: ProvideSWI
	BL	UnsetVars		; unset system variables so no-one thinks we're still here
 ]

        CLRV
        EXIT

; can't die, cos we're in a Macrovision mode currently

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"Macrovision module cannot die: Macrovision mode in use", 0
	ALIGN

; *****************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
        TEQ     r1, #Service_ModeChanging
	TEQNE	r1, #Service_PreReset
 [ Have_Double_TDA
        TEQNE   r1, #Service_Standby
 ]
        MOVNES  pc, lr

        LDR     wp, [r12]
 [ Have_Double_TDA
        TEQ     r1, #Service_Standby
        BEQ     svc_Standby
 ]
	TEQ	r1, #Service_PreReset
	BEQ	svc_PreReset

; and drop thru to...

; svc_ModeChanging
;
; in:	r2 = mode number

svc_ModeChanging Entry "r0,r1"
        BL      ReleasePaletteV
	BL	ReleaseEventV
	BL	RemoveCallbacks

 [ ProvideSWI
	LDR	r0, PendingMacroType
	LDR	r1, PendingTVStandard
	TEQ	r0, #0
	BLNE	ClaimPaletteV		; is macrovision video path, so claim PaletteV
	BL	SelectVideoPath		; select appropriate video path
 |
	BL	CheckMacroMode
	BNE	%FT50

; is Macrovision video path

	BL	ClaimPaletteV

	LDR	r1, [r0, #MVMode_TVStandard]
	LDR	r0, [r0, #MVMode_Type]
	BL	SelectVideoPath		; in: r0 = mode type, r1 = TV standard
	EXITS

; not a Macrovision mode, so release vectors if we've claimed them

50
	MOV	r0, #0			; get out of macrovision video path
	LDR	r1, TVStandard		; and assume same TV standard as last time
	BL	SelectVideoPath
 ]
        EXITS

; On Service_PreReset, switch back to normal video path, cos hardware won't

svc_PreReset Entry "r0,r1"
	MOV	r0, #0			; get out of macrovision video path
	LDR	r1, TVStandard		; and assume same TV standard as last time
	BL	SelectVideoPath
	EXITS

 [ Have_Double_TDA
; On Service_Standby, switch in or out of standby video path
;
; In: R0 = flags
;          Bit 0 set   => we've gone into standby mode
;          Bit 0 clear => we've come out of standby mode

svc_Standby
        Entry   "r0-r4"
        TST     r0, #1
        ADRNEL  r1, TDA8540StandbyIICData
        MOVNE   r2, #TDA8540StandbyIICDataEnd - TDA8540StandbyIICData
        ADRNEL  r3, TDA8540StandbyIICData_2
        MOVNE   r4, #TDA8540StandbyIICDataEnd_2 - TDA8540StandbyIICData_2
   [ ForceMacroVideoPath
        ADREQL  r1, TDA8540MacroIICData
        MOVEQ   r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
        ADREQL  r3, TDA8540MacroIICData_2
        MOVEQ   r4, #TDA8540MacroIICDataEnd_2 - TDA8540MacroIICData_2
   | ; otherwise always come out into non-macrovision path  (is this right?)
        ADREQL  r1, TDA8540NonMacroIICData
        MOVEQ   r2, #TDA8540NonMacroIICDataEnd - TDA8540NonMacroIICData
        ADREQL  r3, TDA8540NonMacroIICData_2
        MOVEQ   r4, #TDA8540NonMacroIICDataEnd_2 - TDA8540NonMacroIICData_2
   ]
        BL      Program_TDAs            ; nowhere to report errors to
        EXITS
 ]


ClaimPaletteV Entry "r0-r2"
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   NE

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Claim
	EXITS	VS

        MOV     r0, #1
        STR     r0, PaletteVClaimed
        EXITS

ReleasePaletteV Entry "r0-r2"
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   EQ

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Release

        MOV     r0, #0
        STR     r0, PaletteVClaimed
        EXITS

ClaimEventV Entry "r0-r2"
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   NE

	ADRL	r0, AGCModulationTableStart
	STR	r0, AGCModulationPosition

	MOV	r0, #1
	STR	r0, VSyncCount		; start going thru table next vsync

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Claim
	EXITS	VS

	MOV	r0, #14
	MOV	r1, #4
	SWI	XOS_Byte		; enable vsync event

        MOV     r0, #1
        STR     r0, EventVClaimed
        EXITS

ReleaseEventV Entry "r0-r2"
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   EQ

	MOV	r0, #13
	MOV	r1, #4
	SWI	XOS_Byte		; disable vsync event

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Release

        MOV     r0, #0
        STR     r0, EventVClaimed
        EXITS

MyEventV Entry "r0-r2"
	TEQ	r0, #Event_VSync
	EXIT	NE
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	EXIT	NE

; it's vsync time, and we're not waiting around for a callback that hasn't gone off yet

	LDR	r0, VSyncCount			; decrement vsync count
	SUBS	r0, r0, #1
	STR	r0, VSyncCount
	EXIT	NE				; if not zero, don't bother with a callback

	MOV	r2, pc
	ORR	r0, r2, #SVC_mode		; switch to SVC_mode, so we can save lr_svc
	TEQP	r0, #0
	NOP

	Push	"lr"
	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"lr"

	TEQP	r2, #0				; restore old mode
	NOP

	MOV	r0, #1
	STR	r0, EventVCallbackRequested
	EXIT

; Remove any outstanding PaletteV or EventV callbacks
; Assumes that noone is trying to generate any more of them!

RemoveCallbacks Entry "r0-r2"
	LDR	r0, PaletteVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT10

	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
10
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT20

	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
20
	EXIT

; ******************************************************************************************************
;
;       EventVCallback - Routine to adjust software modulated parameters on callback from vsync
;
; in:   SVC mode, interrupts enabled
; out:  -
;

EventVCallback	Entry "r0-r3"

	LDR	r2, AGCModulationPosition
	LDR	r3, [r2], #4
	ADRL	r1, AGCModulationTableEnd	; if got to end position
	TEQ	r2, r1
	ADREQL	r2, AGCModulationTableStart	; go back to start
	STR	r2, AGCModulationPosition

	MOV	lr, r3, LSR #AGCBitShift_Fields	; top 16 bits = next loop count
	STR	lr, VSyncCount

; now check we're inside VIDC display area (ie outside lines with AGC pulses)

	MOV	r0, #IOC
10
	LDRB	lr, [r0, #IOCControl]		; read "IOC Control Register"
	TST	lr, #vsync_state_bit
	BNE	%BT10				; wait for it to go low (ie outside flyback)

	MOV	r0, #SubAddress_PULM		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_PULM
	MOVNE	r1, #BitMask_PULM		; r1 = 0 or BitMask_PULM
	MOV	r2, #BitMask_PULM		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCFB		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_AGCFB
	MOVNE	r1, #BitMask_AGCFB		; r1 = 0 or BitMask_AGCFB
	MOV	r2, #BitMask_AGCFB		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCL		; r0 = sub-address
	AND	r1, r3, #AGCBitMask_AGCL
	MOV	r2, #BitMask_AGCL
	BL	ModulateBits

	MOV	lr, #0
	STR	lr, EventVCallbackRequested
	EXIT

; ******************************************************************************************************
;
;	ModulateBits - Modulate register bits in SAA7183
;
; in:	r0 = sub-address to change
;	r1 = new bits
;	r2 = mask of bits to change
;
; out:	-
;

ModulateBits Entry "r0-r3"
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; IRQs off

	ADR	lr, SAA7183IICMap
	LDRB	r3, [lr, r0]
	BIC	r3, r3, r2
	ORR	r3, r3, r1
	STRB	r3, [lr, r0]

	STRB	r0, TempModulationBlock +0
	STRB	r3, TempModulationBlock +1

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, TempModulationBlock
	MOV	r2, #2				; send sub-address + 1 data byte
	SWI	XIIC_Control
	EXITS					; exit restoring IRQ status

; ******************************************************************************************************
;
;       MyPaletteV - My PaletteV handler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6

MyPaletteV ENTRY "r0-r3"
 [ {FALSE}
	MOV	r0, #&81
	MOV	r1, #&FD
	MOV	r2, #&FF
	SWI	XOS_Byte
	TEQ	r1, #0
	LDMFD	r13, {r0-r3}
	BEQ	%FT10
	DREG	r4, "PaletteV reason "
10
 ]
        CMP     r4, #1
        EXITS   CC
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankUnblank
	BEQ	PV_BulkRead
        EXITS

PV_1stFlashState
PV_2ndFlashState
PV_BlankUnblank
ClaimExit
        MOV     r4, #0
PassOnExit
        PullEnv
        Pull    pc


; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bit 7
;       R3 = second flash setting  (BBGGRRS0), supremacy bit 7
;

PV_ReadPalette ROUT
	MOV     r2, #0			; default value if duff (black)
	TEQ	r1, #16
	BNE	ReturnBlack		; not normal colour, so return 0
	CMP	r0, #8
	BCS	ReturnBlack
	ADR	lr, LogicalPalette
	LDR	r2, [lr, r0, LSL #2]	; look up in our soft copy
ReturnBlack
	STR	r2, [sp, #2*4]		; store in saved r2
	STR	r2, [sp, #3*4]		; and saved r3
	B	ClaimExit		; claim call and exit

; *****************************************************************************
;
;	PV_BulkRead - PaletteV read section of palette
;
; in:	R0 = pointer to word aligned list of logical colours (words), or 0
;	R1 = type (bits 24..31) and number of colours (bits 0..23)
;	R2 = pointer to block for 1st flash state
;	R3 = pointer to block for 2nd flash state (or 0 for put both at R2)
;	R4 = 7 (reason code)
;
; out:	R4 = 0 (if complete) or preserved if not

PV_BulkRead ROUT
	MOV	lr, r1, LSR #24
	TEQ	lr, #16
	BNE	PassOnExit		; not reading normal colours, so skip
	BICS	r1, r1, #&FF000000
	BEQ	ClaimExit		; all done!
	MOV	r4, #0			; current palette index
10
	TEQ	r0, #0			; if list of colours
	LDRNE	r4, [r0], #4		; then load palette index to use, else use r4
	CMP	r4, #8
	MOVCS	lr, #0			; out of range, use black
	ADRCC	lr, LogicalPalette
	LDRCC	lr, [lr, r4, LSL #2]	; else return entry in table
	STR	lr, [r2], #4		; store 1st copy
	TEQ	r3, #0			; if no 2nd table
	STREQ	lr, [r2], #4		; then use 1st for 2nd flash state too
	STRNE	lr, [r3], #4		; else use 2nd table
	ADD	r4, r4, #1		; increment palette index assuming no list of colours
	SUBS	r1, r1, #1
	BNE	%BT10
	B	ClaimExit

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRR00
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

PV_SetPalette ROUT
        TEQ     r1, #16                 ; if 16 then set both colours
	BNE	ClaimExit		; not set normal colour, so exit

	AND	r0, r0, #&FF		; force colour number in range 0..255
	CMP	r0, #8			; only do anything with colours 0 to 7
        BLCC    UpdatePaletteSetting
	BLCC	TransmitSAA7183Data
        B       ClaimExit               ; indicate successful PaletteV op

UpdatePaletteSetting Entry
	ADR	lr, LogicalPalette
	STR	r2, [lr, r0, LSL #2]	; update our soft copy of palette
	BL	RGBToYUV		; in: r2 = BBGGRR00; out: r2 = 00VVUUYY
	MOV	lr, #3			; 3 bytes per palette entry
	MOV	r3, #SubAddress_OVL_LUT_Y0
	MLA	r3, r0, lr, r3		; index for Y component = OVL_LUT_Y0 + (index * 3)
	ADR	lr, SAA7183IICMap
	STRB	r2, [lr, r3]!		; store new Y component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #1]		; store new U component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #2]		; store new V component
	EXITS

; *****************************************************************************
;
;       Set default palette - "R0-R3,LR" already saved

PV_SetDefaultPalette ROUT
	ADR	r0, VIDCProgTable
	ADR	r1, VIDCProgTableEnd
	MOV	r2, #VIDC
10
	LDR	lr, [r0], #4
	STR	lr, [r2]
	TEQ	r0, r1
	BNE	%BT10

	MOV	lr, #0
	MOV	r0, #256-16
15
	STR	lr, [r2]		; program colours 16 to 255 to black
	SUBS	r0, r0, #1
	BNE	%BT15

	ADR	r1, DefaultPaletteTable
	MOV	r0, #0
20
	LDR	r2, [r1], #4
	BL	UpdatePaletteSetting
	ADD	r0, r0, #1
	TEQ	r0, #8
	BNE	%BT20

	SWI	XColourTrans_InvalidateCache	; let ColourTrans know we have a different palette

	BL	TransmitSAA7183Data	; send all data

	BL	SetDefaultColours


        B       ClaimExit               ; claim vector

        LTORG

DefaultPaletteTable
	&	&00000000		; colour 0 (black)
	&	&55555500		; colour 1 (1/3 grey)
	&	&AAAAAA00		; colour 2 (2/3 grey)
	&	&FFFFFF00		; colour 3 (white)
	&	&0000FF00		; colour 4 (red)
	&	&00FF0000		; colour 5 (green)
	&	&00BBFF00		; colour 6 (orange)
	&	&FF000000		; colour 7 (blue)

VIDCProgTable
	&	&10000000		; program palette index to 0
	&	&08000000		; colour 0 (RGB bits irrelevant if you have the h/w)
	&	&09111111		; colour 1
	&	&0A222222		; colour 2
	&	&0B333333		; colour 3
	&	&0C444444		; colour 4
	&	&0D555555		; colour 5
	&	&0E666666		; colour 6
	&	&0F777777		; colour 7
	&	&00888888		; colour 8 (transparent)
	&	&00999999		; colour 9 (ditto)
	&	&00AAAAAA		; colour 10
	&	&00BBBBBB		; colour 11
	&	&00CCCCCC		; colour 12
	&	&00DDDDDD		; colour 13
	&	&00EEEEEE		; colour 14
	&	&00FFFFFF		; colour 15
VIDCProgTableEnd

; *****************************************************************************
;
;	SetDefaultColours - Request a callback to set default text/graphics colours
;
; in:	-
; out:	-

SetDefaultColours Entry "r0-r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	lr, PaletteVCallbackRequested
	TEQ	lr, #0
	EXITS	NE

	MOV	lr, #1
	STR	lr, PaletteVCallbackRequested

	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_AddCallBack
	EXITS

ReallySetDefaultColours Entry "r0,r1"
	MOV	lr, #0
	STR	lr, PaletteVCallbackRequested

	LDR	r0, MacroType
	CMP	r0, #0			; if not in a macro mode any more, just quit
	EXIT	EQ

	MOV	r0, #0
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set graphics foregd to colour 7

	MOV	r0, #&40
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set text foregd to colour 7

	EXIT

; *****************************************************************************
;
;	RGBToYUV - Convert RGB to YUV
;
; in:	r2 = BBGGRR00
;
; out:	r2 = 00VVUUYY in the format required by Macrovision palette

RGBToYUV Entry "r0,r3-r6"
	AND	lr, r2, #&FF00
	ADRL	r0, YUVTable
	LDR	r3, [r0, lr, LSR #6]	; RY
	ADD	r0, r0, #&400
	LDR	r4, [r0, lr, LSR #6]	; RU
	ADD	r0, r0, #&400
	LDR	r5, [r0, lr, LSR #6]	; RV

	AND	lr, r2, #&FF0000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GY
	ADD	r3, r3, r6		; RY+GY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GU
	ADD	r4, r4, r6		; RU+GU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GV
	ADD	r5, r5, r6		; RV+GV

	AND	lr, r2, #&FF000000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BY
	ADD	r3, r3, r6		; RY+GY+BY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BU
	ADD	r4, r4, r6		; RU+GU+BU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BV
	ADD	r5, r5, r6		; RV+GV+BV

	ADD	r3, r3, #&80		; add on 1/2, before we round down
	MOV	r3, r3, ASR #8
	CMP	r3, #16			; limit Y to 16 to 235
	MOVLT	r3, #16
	CMP	r3, #235
	MOVGT	r3, #235
	EOR	r3, r3, #128		; toggle bit 7 as required

	ADD	r4, r4, #&80		; add on 1/2, before we round down
	MOV	r4, r4, ASR #8
	ADD	r4, r4, #128		; convert to Cr
	CMP	r4, #16			; limit Cr to 16 to 240
	MOVLT	r4, #16
	CMP	r4, #240
	MOVGT	r4, #240
	EOR	r4, r4, #128		; toggle bit 7 as required

	ADD	r5, r5, #&80		; add on 1/2, before we round down
	MOV	r5, r5, ASR #8
	ADD	r5, r5, #128		; convert to Cb
	CMP	r5, #16			; limit Cb to 16 to 240
	MOVLT	r5, #16
	CMP	r5, #240
	MOVGT	r5, #240
	EOR	r5, r5, #128		; toggle bit 7 as required

	ORR	r2, r3, r4, LSL #8
	ORR	r2, r2, r5, LSL #16
	EXIT

; *****************************************************************************
;
;	SelectVideoPath - Program TDA8540 and SAA7183 to select video path
;
; in:	r0 = MacroType - 0 => normal, 1 => macro OK to tape, 2 => macro anti-tape
;	r1 = TVStandard - 0 => PAL, 1 => NTSC
;
; out:	-
;

SelectVideoPath Entry "r0-r2"
	STR	r0, MacroType		; save away state, so we know where we are
	STR	r1, TVStandard

 [ ProgramCTRL1
	MOV	r0, #CardControlReason_UpdateControlRegister
	MOV	r1, #0
	MOV	r2, #-1
	SWI	XMPEGVideo_CardControl	; first read current state - and if control signals are both off, don't do anything
	TST	r1, #UpdateControlRegister_CTRL0 :OR: UpdateControlRegister_CTRL1
	BEQ	%FT10			; both off so don't disturb them

	LDMIA	sp, {r0, r1}		; reload r0 and r1
	TEQ	r0, #0			; is it normal mode
	MOVEQ	r1, #UpdateControlRegister_CTRL1 ; if so, then select RGB (CTRL1=1)
	MOVNE	r1, #0			; else select CVBS (CTRL1=0)
	MVN	r2, #UpdateControlRegister_CTRL1 ; only affect this pin
	MOV	r0, #CardControlReason_UpdateControlRegister
	SWI	XMPEGVideo_CardControl	; ignore any error from this SWI
10
	LDMIA	sp, {r0, r1}		; reload r0 and r1
 ]

 [ Have_Double_TDA
        Push    "r3,r4"
   [ ForceMacroVideoPath
	ADR	r1, TDA8540MacroIICData
	MOV	r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
	ADR	r3, TDA8540MacroIICData_2
	MOV	r4, #TDA8540MacroIICDataEnd_2 - TDA8540MacroIICData_2
   |
	TEQ	r0, #0
	ADREQ	r1, TDA8540NonMacroIICData
	MOVEQ	r2, #TDA8540NonMacroIICDataEnd - TDA8540NonMacroIICData
	ADREQ	r3, TDA8540NonMacroIICData_2
	MOVEQ	r4, #TDA8540NonMacroIICDataEnd_2 - TDA8540NonMacroIICData_2
	ADRNE	r1, TDA8540MacroIICData
	MOVNE	r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
	ADRNE	r3, TDA8540MacroIICData_2
	MOVNE	r4, #TDA8540MacroIICDataEnd_2 - TDA8540MacroIICData_2
   ]
        BL      Program_TDAs
        Pull    "r3,r4"
	BVS	%FT90
 |
   [ ForceMacroVideoPath
	ADR	r1, TDA8540MacroIICData
	MOV	r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
   |
	TEQ	r0, #0
	ADREQ	r1, TDA8540NormalIICData
	MOVEQ	r2, #TDA8540NormalIICDataEnd - TDA8540NormalIICData
	ADRNE	r1, TDA8540MacroIICData
	MOVNE	r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
   ]
	MOV	r0, #IICDevice_TDA8540
	SWI	XIIC_Control
	BVS	%FT90
 ]

 [ ExternalSyncGenerator
	LDMIA	sp, {r0,r1}		; reload parameters
	TEQ	r0, #0			; if not normal
	BNE	%FT20			; then program all regs

; is external sync gen, and is normal, so just program the outputs to off

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183OutputsOffData
	MOV	r2, #SAA7183OutputsOffDataEnd - SAA7183OutputsOffData
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT
20
 |
	LDMIA	sp, {r0,r1}		; reload parameters
 ]

; if we get here then is either macrovision mode, or normal but no external sync gen

	SUBS	r0, r0, #1		; go from 0,1,2 to -1,0,1
	MOVMI	r0, #0			; go from 0,1,2 to 0,0,1, since SAA7183 programming
					; is the same for normal and macro OK-to-tape
	TEQ	r1, #0
	ADDNE	r0, r0, #2		; add table offset for NTSC
	ADRL	lr, IICDataBlocks
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, r0, lr	; point at data block for this type of mode
	STR	r0, IICDataBlockPtr
	BL	SetupIICBlock

 [ ReadVarsForRCV2Timing
; Overwrite values in block from RCV2S and RCV2E variables

	Push	"r3, r4"
	SUB	sp, sp, #8		; make room for both values
	ADRL	r0, MacroVarRCV2SName
	MOV	r1, sp
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVS	r0, =RCV2S
	STRVS	r0, [sp]

	ADRL	r0, MacroVarRCV2EName
	ADD	r1, sp, #4
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVS	r0, =RCV2E
	STRVS	r0, [sp, #4]

	Pull	"r0, r1"		; get RCV2S, RCV2E values
	AND	r3, r0, #&FF		; bits 0..7 of RCV2S
	STRB	r3, SAA7183IICMap + &70
	AND	r3, r1, #&FF
	STRB	r3, SAA7183IICMap + &71
	AND	r3, r1, #&700
	MOV	r3, r3, LSR #4
	AND	r0, r0, #&700
	ORR	r3, r3, r0, LSR #8
	STRB	r3, SAA7183IICMap + &72
	Pull	"r3, r4"

 ]

	BL	TransmitSAA7183Data	; send all data to SAA7183

	LDR	r0, MacroType
	TEQ	r0, #2			; are we anti-taping
	BLEQ	ClaimEventV		; if so, then start modulation
90
	STRVS	r0, [sp]
	EXIT


90
	STRVS	r0, [sp]
	EXIT

 [ Have_Double_TDA
Program_TDAs
; On entry: r1 = address of TDA-1 IIC_Control block (with m,b bits clear)
;           r2 = length of TDA-1 IIC_Control block
;           r3 = address of TDA-2 IIC_Control block
;           r4 = length of TDA-2 IIC_Control block
; On exit: r0-r2 corrupted; error may be returned
        Entry
        ; Deal with TDA-1
        ASSERT  (TDA8540StandbyIICDataEnd_2 - TDA8540StandbyIICData_2) = 4
        ASSERT  (TDA8540NonMacroIICDataEnd_2 - TDA8540NonMacroIICData_2) = 4
        ASSERT  (TDA8540MacroIICDataEnd_2 - TDA8540MacroIICData_2) = 4
        ASSERT  IOMD_C_MPEG_CTRL_0 = (1<<3)
        ASSERT  IOMD_C_PALNTSCType = (1<<4)
        LDR     lr, [r1]                ; get copy of TDA-1 IIC_Control block, without (M)odulator and (B)oost power control bits
        MOV     r0, #IOMD_Base
        LDR     r0, [r0, #IOMD_CLINES]  ; read current state of IOMD_CLINES
        AND     r0, r0, #IOMD_C_MPEG_CTRL_0 :OR: IOMD_C_PALNTSCType
        ADR     r1, TDA8540IICData_PALon
        LDRB    r0, [r1, r0, LSR #3]    ; get appropriate "m" and "b" bits
        ORR     lr, lr, r0, LSL #16     ; add to second TDA-1 byte (third byte in IIC_Control block)
        Push    "lr"                    ; push customised block to stack
        MOV     r0, #IICDevice_TDA8540
        MOV     r1, sp                  ; r2 still set up from entry
        SWI     XIIC_Control
        ADD     sp, sp, #4              ; skip pushed block
        EXIT    VS

        ; Deal with TDA-2
	MOV	r0, #IICDevice_TDA8540_2
	MOV     r1, r3
	MOV     r2, r4
	SWI	XIIC_Control
        EXIT
 ]

SAA7183OutputsOffData
	=	&6B		; sub-address to control RCV outputs
	=	&00		; disable outputs
SAA7183OutputsOffDataEnd
	ALIGN

 [ Have_Double_TDA

; IIC data blocks to set TDA8540 devices for each of the three video paths Standby, Non-Macrovision and Macrovision

TDA8540StandbyIICData
	=	0		; sub-address to start at
	=	2_00000000
	=	2_11111100
	=	2_00000000	; Outputs OUT0 - OUT3 disabled
TDA8540StandbyIICDataEnd
	ALIGN
TDA8540StandbyIICData_2
	=	0		; sub-address to start at
	=	2_00000000
	=	2_11111100
	=	2_00000000
TDA8540StandbyIICDataEnd_2
	ALIGN

TDA8540NonMacroIICData
	=	0		; sub-address to start at
	=	2_11011101
	=	2_11111100
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540NonMacroIICDataEnd
	ALIGN
TDA8540NonMacroIICData_2
	=	0		; sub-address to start at
	=	2_10101010
	=	2_11111100
	=	2_00000111
TDA8540NonMacroIICDataEnd_2
	ALIGN

TDA8540MacroIICData             ; Used irrespective of anti-taping mode
	=	0		; sub-address to start at
	=	2_10001000
	=	2_00001100
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540MacroIICDataEnd
	ALIGN
TDA8540MacroIICData_2
	=	0		; sub-address to start at
	=	2_00000000
	=	2_10001000
	=	2_00000111
TDA8540MacroIICDataEnd_2

; Settings of Modulator and Boost power control bits for each combination of NTSC/PAL and SCART function-select pin
; These are bits 0 and 1 of the second byte addressed to TDA8540 #1.

TDA8540IICData_PALon   =  2_11  ; for when IOMD_CLINES = 2_xxx00xxx
TDA8540IICData_PALoff  =  2_01  ; for when IOMD_CLINES = 2_xxx01xxx
TDA8540IICData_NTSCon  =  2_10  ; for when IOMD_CLINES = 2_xxx10xxx
TDA8540IICData_NTSCoff =  2_01  ; for when IOMD_CLINES = 2_xxx11xxx

 |

TDA8540NormalIICData
	=	0		; sub-address to start at
	=	4_3100		; OUT3 (output_Y) = IN3 (normal_Y)
				; OUT2 (output_C) = IN1 (normal_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001100	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 0 (normal CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540NormalIICDataEnd
	ALIGN

TDA8540MacroIICData
	=	0		; sub-address to start at
	=	4_2000		; OUT3 (output_Y) = IN2 (macro_Y)
				; OUT2 (output_C) = IN0 (macro_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001101	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 1 (macro CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540MacroIICDataEnd
 ]
	ALIGN

CBENB		*	0	; Data from input ports, not just colour bars
DISKEY		*	0	; Overlay enabled
; FMT16	is now set in header file
Y2C		*	1	; Y data are straight binary (not 2's complement)
; UV2C is now set in header file

PAL_CHPS	*	&68	; Phase of encoded colour subcarrier for data from input ports
NTSC_CHPS	*	&82

Normal_DOWNB		*	0 ; RGB DACs on
; AntiTaping_DOWNB is now set in header file
DOWNA		*	0	; CVBS, Y, C DACs on
INPI		*	0	; Nominal PAL phase
RTCE		*	0	; No real time control of generated subcarrier frequency

PAL_YGS		*	0	; Luminance gain for White-Black = 100 IRE
NTSC_YGS	*	1	; Luminance gain for White-Black = 92.5 IRE

PAL_GAINU	*	&7D	; Variable gain for Cb
NTSC_GAINU	*	&76	; Variable gain for Cb

PAL_GAINV	*	&AF	; Variable gain for Cr
NTSC_GAINV	*	&A5	; Variable gain for Cr

PAL_BSTA	*	&4B	; Colour burst amplitude
NTSC_BSTA	*	&66	; Colour burst amplitude

PAL_BLCKL	*	&2D	; Black level
NTSC_BLCKL	*	&3C	; Black level

PAL_BLCKLA	*	&15	; Black level (anti-taping active)
NTSC_BLCKLA	*	&22	; Black level (anti-taping active)

PAL_BLNNL	*	&3F	; Blanking level
NTSC_BLNNL	*	&3A	; Blanking level

PAL_BLNNLA	*	&27	; Blanking level outside vsync (anti-taping active)
NTSC_BLNNLA	*	&20	; Blanking level outside vsync (anti-taping active)

PAL_BLNVB	*	&3F	; Blanking level during Vertical blanking interval
NTSC_BLNVB	*	&3A	; Blanking level during vsync

PAL_AGCL	*	&6F	; AGC Super White level (must be modulated by s/w)
NTSC_AGCL	*	&70	; AGC Super White level (must be modulated by s/w)

DECTYP		*	0	; Controls whether Real Time Control Input comes from SAA7151B or SAA7111
				; (in our case neither, so irrelevant)

SECAM		*	0	; Not SECAM
SCBW		*	1	; Standard bandwidth for Chrominance Encoding
PAL_FISE	*	0	; 864 total pixel clocks per line, not 858
NTSC_FISE	*	1	; 858 total pixel clocks per line, not 864

; PRCV2, SRCV1	now defined in header file
ORCV2		*	1	; HS output
CBLF		*	0	; HSync used in
PRCV1		*	0	; VS Active high
ORCV1		*	1	; VS output
TRCV2		*	1	; HSync from RCV2

SBLBN		*	1	; Vertical blanking forced according to CCIR-624 (50Hz) or RS170A (60Hz)
PHRES		*	2_00	; no reset of phase of colour subcarrier generator
FLC		*	2_00	; interlaced display

; RCV2S, RCV2E now defined in header file

PAL_N1		*	48	; First line with inverted burst in first group of field 1, ie lines 1 to 64
NTSC_N1		*	18
PAL_N2		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 1
NTSC_N2		*	20
PAL_N3		*	48	; First line with inverted burst in first group of field 2, ie lines 1 to 64
NTSC_N3		*	18
PAL_N4		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 2
NTSC_N4		*	29
PAL_N5		*	4	; Colour stripe group spacing (first line to first line) (16+N5 for NTSC, 12+N5 for PAL)
NTSC_N5		*	4
PAL_N6		*	3	; Number of colour stripes (groups) per field (6+N6)
NTSC_N6		*	4
PAL_N7		*	2	; Number of lines per colour stripe (group), 2+N7
NTSC_N7		*	2
PAL_BPp_follow	*	0	; Number of back porch pulses following V-sync pulse
NTSC_BPp_follow	*	0
PAL_BPp_prior	*	14	; Number of back porch pulses prior to V-sync pulse
NTSC_BPp_prior	*	6

PAL_FirstPseudoAGC	*	9	; First line with pseudo-sync pulse and AGC pulse
PAL_LastPseudoAGC	*	18	; Last line ....
PAL_AGCMask	*	(-1 << PAL_FirstPseudoAGC) :AND: :NOT: (-1 << (PAL_LastPseudoAGC+1))
PAL_AGCMask1	*	(PAL_AGCMask >> 14) :AND: &FF
PAL_AGCMask2	*	(PAL_AGCMask >> 7) :AND: &7F

NTSC_FirstPseudoAGC	*	12
NTSC_LastPseudoAGC	*	19
NTSC_AGCMask	*	(-1 << NTSC_FirstPseudoAGC) :AND: :NOT: (-1 << (NTSC_LastPseudoAGC+1))
NTSC_AGCMask1	*	(NTSC_AGCMask >> 14) :AND: &FF
NTSC_AGCMask2	*	(NTSC_AGCMask >> 7) :AND: &7F

DATM		*	0	; Data transmission mode enable (I don't know exactly what this does so don't enable it)

PAL_N8		*	4	; pseudo-sync pulse duration
NTSC_N8		*	3
PAL_N9		*	3	; location of 1st pseudo-sync pulse related to the leading edge of the H-sync pulse
NTSC_N9		*	2

PSSYNC_EN	*	1	; pseudo-sync pulses enabled

PAL_N10		*	3	; pseudo-sync pulse spacing
NTSC_N10	*	3
PULM		*	0	; pulsation mode enable (disabled for now, needs to be modulated by s/w)
p_count		*	5	; in state 'A', number of lines where AGC pulses are active (lines 9 to 13 inclusive)
tm_data		*	0	; transmission data, not used at present

MACRO		*	1	; Macrovision enabled
BINV		*	0	; Burst-inversion disabled (Elmsdale don't want it)
AGCFB		*	1	; AGC pulses following pseudo-sync pulses enabled
AGCEQ		*	1 	; Ancillary AGC pulses enabled

	GBLA	NextBase
	GBLA	NextSectionStart
	MACRO
	NewSections
NextBase SETA	0
NextSectionStart SETA	-1
	MEND

	MACRO
	Section	$base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, $length
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr + ($length)
	MEND

	MACRO
	SectionZero $base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, ($length) :OR: &80
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr
	MEND

	MACRO
	SectionEnd
	ASSERT	NextBase = &80
	=	0, 0		; zero length indicates end
	MEND

	MACRO
	Normal_00_39
	SectionZero	0, &3A	; zero fill from 0 to &39
	MEND

	MACRO
	Common_3A_41
	Section	&3A, 1
	=	(CBENB<<7) :OR: (DISKEY<<6) :OR: (FMT16<<2) :OR: (Y2C<<1) :OR: (UV2C<<0)
	SectionZero	&3B, (&42-&3B)	; zero fill from &3B to &41
	MEND

	MACRO
	Palette_42_59
	Section &42, (&5A-&42)
	=	&90, &00, &00	; Black
	=	&A9, &70, &EE	; Blue
	=	&D1, &DA, &70	; Red
	=	&EA, &4A, &5E	; Magenta
	=	&11, &B6, &A2	; Green
	=	&2A, &26, &90	; Cyan
	=	&52, &90, &12	; Yellow
	=	&6B, &00, &00	; White
	MEND

	MACRO
	PAL_5A_5C
	Section	&5A, 3
	=	PAL_CHPS
	=	(PAL_GAINU :AND: &FF)
	=	(PAL_GAINV :AND: &FF)
	MEND

	MACRO
	NTSC_5A_5C
	Section	&5A, 3
	=	NTSC_CHPS
	=	(NTSC_GAINU :AND: &FF)
	=	(NTSC_GAINV :AND: &FF)
	MEND

	MACRO
	NormalPAL_5D_61
	Section	&5D, 5
	=	((PAL_GAINU :AND: &100)>>1) :OR: PAL_BLCKL
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNL<<0)
	=	PAL_BLNVB
	=	&00		; Null register (&60)
	=	(Normal_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (PAL_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (1<<1) :OR: PAL_FISE
	MEND

	MACRO
	NormalNTSC_5D_61
	Section	&5D, 5
	=	((NTSC_GAINU :AND: &100)>>1) :OR: NTSC_BLCKL
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNL<<0)
	=	NTSC_BLNVB
	=	&00		; Null register (&60)
	=	(Normal_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (NTSC_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (0<<1) :OR: NTSC_FISE
	MEND

	MACRO
	PAL_62_66
	Section	&62, (&67-&62)
	=	(RTCE<<7) :OR: (PAL_BSTA<<0)
	=	&CB, &8A, &09, &2A	; subcarrier frequency
	MEND


	MACRO
	NTSC_62_66
	Section	&62, (&67-&62)
	=	(RTCE<<7) :OR: (NTSC_BSTA<<0)
	=	&1F, &7C, &F0, &21	; subcarrier frequency
	MEND

	MACRO
	Common_67_7C
	Section	&67, (&73-&67)
	=	&00, &00, &00, &00	; no captioning or extended data
	=	(SRCV1<<6) :OR: (TRCV2<<5) :OR: (ORCV1<<4) :OR: (PRCV1<<3) :OR: (CBLF<<2) :OR: (ORCV2<<1) :OR: PRCV2
	=	&54			; HTRIG
	=	&02			; VTRIG??
	=	(SBLBN<<7) :OR: (PHRES<<4) :OR: FLC
	=	&00			; no line 21 encoding or teletext or closed caption or extended data
	=	RCV2S :AND: &FF
	=	RCV2E :AND: &FF
	=	((RCV2E :AND: &700) :SHR: 4) :OR: ((RCV2S :AND: &700) :SHR: 8)
	SectionZero	&73, (&7D-&73)	; zero from &73 to &7C: no TTX stuff
	MEND

	MACRO
	Normal_7D_7F
	SectionZero	&7D, (&80-&7D)
	MEND

	MACRO
	AntiTapingPAL_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	PAL_N1			; N1
	=	&00			; register 02 not used
	=	PAL_N2, PAL_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	PAL_N4
	=	(PAL_N7<<6) :OR: (PAL_N6<<3) :OR: (PAL_N5<<0)
	=	(PAL_BPp_prior<<4) :OR: (PAL_BPp_follow<<0)
	=	&00			; register 13 not used
	=	PAL_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: PAL_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (PAL_N9<<3) :OR: (PAL_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (PAL_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingNTSC_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	NTSC_N1			; N1
	=	&00			; register 02 not used
	=	NTSC_N2, NTSC_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	NTSC_N4
	=	(NTSC_N7<<6) :OR: (NTSC_N6<<3) :OR: (NTSC_N5<<0)
	=	(NTSC_BPp_prior<<4) :OR: (NTSC_BPp_follow<<0)
	=	&00			; register 13 not used
	=	NTSC_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: NTSC_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (NTSC_N9<<3) :OR: (NTSC_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (NTSC_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingPAL_5D_61
	Section	&5D, (&62-&5D)
	=	((PAL_GAINU :AND: &100)>>1) :OR: (PAL_BLCKLA<<0)
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNLA<<0)
	=	PAL_BLNVB
	=	PAL_AGCL
	=	(AntiTaping_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (PAL_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (1<<1) :OR: PAL_FISE
	MEND

	MACRO
	AntiTapingNTSC_5D_61
	Section	&5D, (&62-&5D)
	=	((NTSC_GAINU :AND: &100)>>1) :OR: (NTSC_BLCKLA<<0)
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNLA<<0)
	=	NTSC_BLNVB
	=	NTSC_AGCL
	=	(AntiTaping_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (NTSC_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (0<<1) :OR: NTSC_FISE
	MEND

	MACRO
	AntiTaping_7D_7F
	Section	&7D, (&80-&7D)
	=	(AGCEQ<<7) :OR: (AGCFB<<6) :OR: (BINV<<5) :OR: (MACRO<<4)
	=	&00, &00	; locations &7E, &7F not used
	MEND

SAA7183MacroPAL0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	NormalPAL_5D_61
	PAL_62_66
	Common_67_7C
	Normal_7D_7F
	SectionEnd

SAA7183MacroNTSC0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	NormalNTSC_5D_61
	NTSC_62_66
	Common_67_7C
	Normal_7D_7F
	SectionEnd

SAA7183MacroPAL1IICData
	NewSections
	AntiTapingPAL_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	AntiTapingPAL_5D_61
	PAL_62_66
	Common_67_7C
	AntiTaping_7D_7F
	SectionEnd

SAA7183MacroNTSC1IICData
	NewSections
	AntiTapingNTSC_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	AntiTapingNTSC_5D_61
	NTSC_62_66
	Common_67_7C
	AntiTaping_7D_7F
	SectionEnd

	ALIGN

IICDataBlocks
	&	SAA7183MacroPAL0IICData - IICDataBlocks
	&	SAA7183MacroPAL1IICData - IICDataBlocks
	&	SAA7183MacroNTSC0IICData - IICDataBlocks
	&	SAA7183MacroNTSC1IICData - IICDataBlocks

; *****************************************************************************
;
;	SetupIICBlock - Transfer a compacted block of data into IIC block
;
; Format of compacted block is a series of bytes as follows:-
;
; <offset>, <length>, <byte_1>, <byte_2>, ..., <byte_length>
;	Store the following bytes at the given <offset>
; <offset>, <length> OR 128
;	Store zero for <length> bytes at given <offset>
; x, 0
;	Indicates end of block
;

; in:	r0 -> compacted block
;
; out:	-

SetupIICBlock Entry "r0-r3"
	ADR	r1, SAA7183IICMap
10
	LDRB	r2, [r0], #1		; get start offset
	LDRB	r3, [r0], #1		; get length and zeroing flag
	TEQ	r3, #0			; is it end of the table
	EXIT	EQ

	TST	r3, #&80		; are we zeroing
	BNE	%FT50

20
	LDRB	lr, [r0], #1
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT20
	B	%BT10

50
	BIC	r3, r3, #&80		; knock off zeroing flag
	MOV	lr, #0
60
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT60
	B	%BT10

; *****************************************************************************
;
;	TransmitSAA7183Data - Transmit IIC data to SAA7183
;
; in:	-
; out:	If error, r0 -> error, VS

TransmitSAA7183Data Entry "r0-r2"
	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183IICData
	MOV	r2, #128+1		; one byte for sub-address + 128 bytes of data
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

	MACRO
	AGCEntry	$agcfb, $pulm, $fields, $agcl
	ASSERT	($agcfb) = 0 :LOR: ($agcfb) = 1
	ASSERT	($pulm) = 0 :LOR: ($pulm) = 1
	ASSERT	($fields) >=1 :LAND: ($fields) <=65535
	LCLA	output
output	SETA	($agcl) :OR: (($pulm) << AGCBitShift_PULM) :OR: (($agcfb) << AGCBitShift_AGCFB) :OR: (($fields) << AGCBitShift_Fields)
;	! 0,	"AGCL = $agcl, AGCFB = $agcfb, PULM = $pulm, FIELDS = $fields, OUTPUT = $output"
	&	output
	MEND

	MACRO
	AGCRamp		$agcfb, $pulm, $fields, $fromagcl, $toagcl
	LCLA	RampCount
	LCLA	RampVel
 [ ($toagcl) >= ($fromagcl)
RampVel	SETA	1
 |
RampVel	SETA	-1
 ]
RampCount SETA ($fromagcl)
	WHILE	RampCount <> ($toagcl)+RampVel
	AGCEntry	$agcfb, $pulm, $fields, &$RampCount
RampCount SETA	RampCount + RampVel
	WEND
	MEND

	GBLA	LoopCount

;			AGCFB,  PULM,	Fields,	AGCL (, Target AGCL)
AGCModulationTableStart
	AGCEntry	1,	0, 	600, 	111
	AGCRamp		1, 	0, 	2,   	110,	41
	AGCEntry	0,	0,	12,	41

LoopCount SETA	5
	WHILE	LoopCount > 0
	AGCEntry	1,	1,	60, 	80
	AGCEntry	1,	0,	60,	49
LoopCount SETA LoopCount - 1
	WEND

	AGCRamp		1,	0,	2,	50,	110
AGCModulationTableEnd


YUVTable
	BIN	"Data.YUVTable"

 [ ProvideSWI
; *****************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
        CMP     r11, #MacrovisionSWICheckValue - MacrovisionSWI_Base
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
00
	B	SetState	; set state, to take effect from next mode change
	ASSERT  {PC}-%00 = (MacrovisionSWICheckValue-MacrovisionSWI_Base) :SHL: 2

NoSuchSWI
        ADRL    r0, NoSuchSWIError
        SETV
        MOV     pc, lr

NoSuchSWIError
        &       0
        =       "No such Macrovision SWI", 0
        ALIGN

; *****************************************************************************
;
;	SetState - SWI to set state entered after next mode change
;
; in:	r0 = flags (zero at present)
;	r1 = type (0 => normal, 1 => macro OK-to-tape, 2 => macro anti-tape)
;	r2 = TV standard (0 => PAL, 1 => NTSC)
;
; out:	All registers preserved

SetState Entry
	STR	r1, PendingMacroType
	STR	r2, PendingTVStandard
	EXIT
 ]

; *****************************************************************************
;
;       Message stuff


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

	InsertDebugRoutines

        END
