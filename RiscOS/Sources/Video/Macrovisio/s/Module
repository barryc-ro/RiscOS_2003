; > Module

; Macrovision module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 27-Nov-95  TMD  0.01		Started.
; 06-Nov-95  TMD  0.01		First version released for DEC
; 06-Nov-95  TMD  0.02		Started on pulsation of AGC levels
;

	LEADR	Module_LoadAddr

TAB	*	9
LF	*	10
FF	*	12
CR	*	13

; Default foreground text/graphics colour in Macrovision modes

DefaultForegroundColour	*	3

; Structure of a mode entry

			^	0
MVMode_LinkOffset	#	4		; Offset from node to next node (0 if end)
MVMode_ModeNumber	#	4		; Mode number
MVMode_VarNameOffset	#	4		; Offset from node to variable name
MVMode_Flags		#	4		; bit 0 set => anti-taping, bit 1 set => NTSC not PAL

	MACRO
$label	MVModeNode	$modenumber, $varnameaddr, $flags, $next
$label
10
 [ "$next" = ""
	&	0
 |
	&	$next - %BT10
 ]
	&	$modenumber
	&	$varnameaddr - %BT10
	&	$flags
	MEND

		^	0, wp

IICDataBlockPtr #	4		; debugging to store address of last compacted data block used
PaletteVClaimed	#	4		; 0 => PaletteV not claimed, 1 => PaletteV claimed
EventVClaimed	#	4		; 0 => EventV not claimed, 1 => EventV claimed
PaletteVCallbackRequested #	4	; non-zero => we have an outstanding callback to set the default colours
EventVCallbackRequested #	4	; non-zero => we have an outstanding callback to vary the AGC level

VSyncCount	#	4		; number of vsyncs till next modulation
AGCModulationPosition # 4		; position in table for next thing to do

MacroModeType	#	4		; -1 for non-macro, 0 to 3 for our modes
LogicalPalette	#	8*4		; BBGGRR00 for each of colours 0 to 7
TempModulationBlock #	2		; sub-address, data for real-time s/w modulation
		#	1		; keep it aligned
SAA7183IICData  #	1		; 1 byte for sub-address
SAA7183IICMap	#	128		; copy of the 128 sub-address registers in the SAA7183


 [ international
MessageFile_Block #	16
MessageFile_Open  #	4
 ]

Module_WorkspaceSize * :INDEX: @

MacrovisionPALMode0	*	64
MacrovisionPALMode1	*	65
MacrovisionNTSCMode0	*	66
MacrovisionNTSCMode1	*	67

IICDevice_SAA7183	*	&88
IICDevice_TDA8540	*	&98

VIDC		*	&03500000	; address to poke VIDC20

; Sub-addresses within SAA7183

SubAddress_PULM		*	&21	; register with PULM bit
SubAddress_OVL_LUT_Y0	*	&42	; base sub-address for palette entries
SubAddress_AGCL		*	&60	; AGC level
SubAddress_AGCFB	*	&7D	; register with AGCFB bit

; Bit masks within register

BitMask_AGCL		*	&FF
BitMask_PULM		*	1 :SHL: 3
BitMask_AGCFB		*	1 :SHL: 6

; Masks withing AGC table entries

AGCBitMask_AGCL		*	&FF :SHL: 0
AGCBitShift_PULM	*	8
AGCBitMask_PULM		*	1 :SHL: AGCBitShift_PULM
AGCBitShift_AGCFB	*	9
AGCBitMask_AGCFB	*	1 :SHL: AGCBitShift_AGCFB
AGCBitShift_Fields	*	16

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       0 ; SWI chunk
        &       0 ; Mod_SWIHandler-Module_BaseAddr
        &       0 ; Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "Macrovision", 0

Mod_HelpStr
        =       "Macrovision", TAB, "0.02 (06 Dec 1995)", 0
        ALIGN

Mod_HC_Table
;	Command HorizOffset,	2, 2
        =       0                       ; terminate table

; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [r12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, PaletteVClaimed
	STR	r0, EventVClaimed
	STR	r0, PaletteVCallbackRequested
	STR	r0, EventVCallbackRequested
	STRB	r0, SAA7183IICData	; zero sub-address

	ADR	r0, RMEnsureInterlaceString
	SWI	XOS_CLI
	EXIT	VS

	BL	SelectNormalVideoPath

	BL	SetVars
	EXIT	VS

        CLRV
        EXIT

SetVars Entry
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	ADD	r1, r5, #MVMode_ModeNumber ; point r1 at value
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal
	BVS	%FT90			; if error, unset all vars and exit VS

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0			; check for end, and clear V if EQ
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXIT

90
	BL	UnsetVars
	EXIT

UnsetVars Entry "r0"
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	MOV	r2, #-1			; length of value (ie delete)
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXITS				; exit preserving all flags and r0

; in: r2 = mode number; out: if Macrovision mode, r0 -> node, EQ, else r0 corrupted, NE

CheckMacroMode Entry
	ADR	r0, VarTable
10
	LDR	lr, [r0, #MVMode_ModeNumber]
	TEQ	lr, r2
	EXIT	EQ

	LDR	lr, [r0, #MVMode_LinkOffset]
	TEQ	lr, #0
	ADDNE	r0, r0, lr
	BNE	%BT10
	TEQ	lr, #1			; set NE (cos lr = 0)
	EXIT


RMEnsureInterlaceString
	=	"RMEnsure Interlace 0.37 Error 0 Macrovision module requires the Interlace module version 0.37 or later", 0
MacroVarPAL0Name
	=	"Macrovision$$PAL0", 0
MacroVarPAL1Name
	=	"Macrovision$$PAL1", 0
MacroVarNTSC0Name
	=	"Macrovision$$NTSC0", 0
MacroVarNTSC1Name
	=	"Macrovision$$NTSC1", 0
	ALIGN

VarTable
VarPAL0Entry	MVModeNode MacrovisionPALMode0, MacroVarPAL0Name, 0, VarPAL1Entry
VarPAL1Entry	MVModeNode MacrovisionPALMode1, MacroVarPAL1Name, 1, VarNTSC0Entry
VarNTSC0Entry	MVModeNode MacrovisionNTSCMode0, MacroVarNTSC0Name, 2, VarNTSC1Entry
VarNTSC1Entry	MVModeNode MacrovisionNTSCMode1, MacroVarNTSC1Name, 3

; *****************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; insert anything we need here!

	LDR	r0, PaletteVClaimed
	TEQ	r0, #0
	BNE	%FT90			; [on vectors, so must be in Macrovision mode, so not safe to die]

; safe to die

	BL	RemoveCallbacks		; remove any outstanding callbacks
	BL	UnsetVars		; unset system variables so no-one thinks we're still here

        CLRV
        EXIT

; can't die, cos we're in a Macrovision mode currently

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"Macrovision module cannot die: Macrovision mode in use", 0
	ALIGN

; *****************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
        TEQ     r1, #Service_ModeChanging
        MOVNES  pc, lr

        LDR     wp, [r12]

; and drop thru to...

; svc_ModeChanging
;
; in:	r2 = mode number

svc_ModeChanging Entry "r0"
        BL      ReleasePaletteV
	BL	ReleaseEventV
	BL	RemoveCallbacks

	BL	CheckMacroMode
	BNE	%FT50

	BL	ClaimPaletteV
	BL	SelectMacroVideoPath	; in: r0 -> mode node, which includes flag for anti-taping or not
	EXITS

; not a Macrovision mode, so release vectors if we've claimed them

50
	BL	SelectNormalVideoPath
	MOV	r0, #-1
	STR	r0, MacroModeType	; indicate not in a macro mode
        EXITS

ClaimPaletteV Entry "r0-r2"
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   NE

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Claim
	EXITS	VS

        MOV     r0, #1
        STR     r0, PaletteVClaimed
        EXITS

ReleasePaletteV Entry "r0-r2"
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   EQ

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Release

        MOV     r0, #0
        STR     r0, PaletteVClaimed
        EXITS

ClaimEventV Entry "r0-r2"
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   NE

	ADRL	r0, AGCModulationTableStart
	STR	r0, AGCModulationPosition

	MOV	r0, #1
	STR	r0, VSyncCount		; start going thru table next vsync

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Claim
	EXITS	VS

	MOV	r0, #14
	MOV	r1, #4
	SWI	XOS_Byte		; enable vsync event

        MOV     r0, #1
        STR     r0, EventVClaimed
        EXITS

ReleaseEventV Entry "r0-r2"
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   EQ

	MOV	r0, #13
	MOV	r1, #4
	SWI	XOS_Byte		; disable vsync event

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Release

        MOV     r0, #0
        STR     r0, EventVClaimed
        EXITS

MyEventV Entry "r0-r2"
	TEQ	r0, #Event_VSync
	EXIT	NE
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	EXIT	NE

; it's vsync time, and we're not waiting around for a callback that hasn't gone off yet

	LDR	r0, VSyncCount			; decrement vsync count
	SUBS	r0, r0, #1
	STR	r0, VSyncCount
	EXIT	NE				; if not zero, don't bother with a callback

	MOV	r2, pc
	ORR	r0, r2, #SVC_mode		; switch to SVC_mode, so we can save lr_svc
	TEQP	r0, #0
	NOP

	Push	"lr"
	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"lr"

	TEQP	r2, #0				; restore old mode
	NOP

	MOV	r0, #1
	STR	r0, EventVCallbackRequested
	EXIT

; Remove any outstanding PaletteV or EventV callbacks
; Assumes that noone is trying to generate any more of them!

RemoveCallbacks Entry "r0-r2"
	LDR	r0, PaletteVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT10

	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
10
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT20

	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
20
	EXIT

; ******************************************************************************************************
;
;       EventVCallback - Routine to adjust software modulated parameters on callback from vsync
;
; in:   SVC mode, interrupts enabled
; out:  -
;

EventVCallback	Entry "r0-r3"

	LDR	r2, AGCModulationPosition
	LDR	r3, [r2], #4
	ADRL	r1, AGCModulationTableEnd	; if got to end position
	TEQ	r2, r1
	ADREQL	r2, AGCModulationTableStart	; go back to start
	STR	r2, AGCModulationPosition

	MOV	lr, r3, LSR #AGCBitShift_Fields	; top 16 bits = next loop count
	STR	lr, VSyncCount

; now check we're inside VIDC display area (ie outside lines with AGC pulses)

	MOV	r0, #IOC
10
	LDRB	lr, [r0, #IOCControl]		; read "IOC Control Register"
	TST	lr, #vsync_state_bit
	BNE	%BT10				; wait for it to go low (ie outside flyback)

	MOV	r0, #SubAddress_PULM		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_PULM
	MOVNE	r1, #BitMask_PULM		; r1 = 0 or BitMask_PULM
	MOV	r2, #BitMask_PULM		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCFB		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_AGCFB
	MOVNE	r1, #BitMask_AGCFB		; r1 = 0 or BitMask_AGCFB
	MOV	r2, #BitMask_AGCFB		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCL		; r0 = sub-address
	AND	r1, r3, #AGCBitMask_AGCL
	MOV	r2, #BitMask_AGCL
	BL	ModulateBits

	MOV	lr, #0
	STR	lr, EventVCallbackRequested
	EXIT

; ******************************************************************************************************
;
;	ModulateBits - Modulate register bits in SAA7183
;
; in:	r0 = sub-address to change
;	r1 = new bits
;	r2 = mask of bits to change
;
; out:	-
;

ModulateBits Entry "r0-r3"
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; IRQs off

	ADR	lr, SAA7183IICMap
	LDRB	r3, [lr, r0]
	BIC	r3, r3, r2
	ORR	r3, r3, r1
	STRB	r3, [lr, r0]

	STRB	r0, TempModulationBlock +0
	STRB	r3, TempModulationBlock +1

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, TempModulationBlock
	MOV	r2, #2				; send sub-address + 1 data byte
	SWI	XIIC_Control
	EXITS					; exit restoring IRQ status

; ******************************************************************************************************
;
;       MyPaletteV - My PaletteV handler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6

MyPaletteV ENTRY "r0-r3"
	MOV	r0, #&81
	MOV	r1, #&FD
	MOV	r2, #&FF
	SWI	XOS_Byte
	TEQ	r1, #0
	LDMFD	r13, {r0-r3}
	BEQ	%FT10
	DREG	r4, "PaletteV reason "
10
        CMP     r4, #1
        EXITS   CC
        BEQ     PV_ReadPalette
        CMP     r4, #3
        BCC     PV_SetPalette
        BEQ     PV_1stFlashState
        CMP     r4, #5
        BCC     PV_2ndFlashState
        BEQ     PV_SetDefaultPalette
        CMP     r4, #7
        BCC     PV_BlankUnblank
	BEQ	PV_BulkRead
        EXITS

PV_1stFlashState
PV_2ndFlashState
PV_BlankUnblank
ClaimExit
        MOV     r4, #0
PassOnExit
        PullEnv
        Pull    pc


; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bit 7
;       R3 = second flash setting  (BBGGRRS0), supremacy bit 7
;

PV_ReadPalette ROUT
	MOV     r2, #0			; default value if duff (black)
	TEQ	r1, #16
	BNE	ReturnBlack		; not normal colour, so return 0
	CMP	r0, #8
	BCS	ReturnBlack
	ADR	lr, LogicalPalette
	LDR	r2, [lr, r0, LSL #2]	; look up in our soft copy
ReturnBlack
	STR	r2, [sp, #2*4]		; store in saved r2
	STR	r2, [sp, #3*4]		; and saved r3
	B	ClaimExit		; claim call and exit

; *****************************************************************************
;
;	PV_BulkRead - PaletteV read section of palette
;
; in:	R0 = pointer to word aligned list of logical colours (words), or 0
;	R1 = type (bits 24..31) and number of colours (bits 0..23)
;	R2 = pointer to block for 1st flash state
;	R3 = pointer to block for 2nd flash state (or 0 for put both at R2)
;	R4 = 7 (reason code)
;
; out:	R4 = 0 (if complete) or preserved if not

PV_BulkRead ROUT
	MOV	lr, r1, LSR #24
	TEQ	lr, #16
	BNE	PassOnExit		; not reading normal colours, so skip
	BICS	r1, r1, #&FF000000
	BEQ	ClaimExit		; all done!
	MOV	r4, #0			; current palette index
10
	TEQ	r0, #0			; if list of colours
	LDRNE	r4, [r0], #4		; then load palette index to use, else use r4
	CMP	r4, #8
	MOVCS	lr, #0			; out of range, use black
	ADRCC	lr, LogicalPalette
	LDRCC	lr, [lr, r4, LSL #2]	; else return entry in table
	STR	lr, [r2], #4		; store 1st copy
	TEQ	r3, #0			; if no 2nd table
	STREQ	lr, [r2], #4		; then use 1st for 2nd flash state too
	STRNE	lr, [r3], #4		; else use 2nd table
	ADD	r4, r4, #1		; increment palette index assuming no list of colours
	SUBS	r1, r1, #1
	BNE	%BT10
	B	ClaimExit

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRR00
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

PV_SetPalette ROUT
        TEQ     r1, #16                 ; if 16 then set both colours
	BNE	ClaimExit		; not set normal colour, so exit

	AND	r0, r0, #&FF		; force colour number in range 0..255
	CMP	r0, #8			; only do anything with colours 0 to 7
        BLCC    UpdatePaletteSetting
	BLCC	TransmitSAA7183Data
        B       ClaimExit               ; indicate successful PaletteV op

UpdatePaletteSetting Entry
	ADR	lr, LogicalPalette
	STR	r2, [lr, r0, LSL #2]	; update our soft copy of palette
	BL	RGBToYUV		; in: r2 = BBGGRR00; out: r2 = 00VVUUYY
	MOV	lr, #3			; 3 bytes per palette entry
	MOV	r3, #SubAddress_OVL_LUT_Y0
	MLA	r3, r0, lr, r3		; index for Y component = OVL_LUT_Y0 + (index * 3)
	ADR	lr, SAA7183IICMap
	STRB	r2, [lr, r3]!		; store new Y component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #1]		; store new U component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #2]		; store new V component
	EXITS

; *****************************************************************************
;
;       Set default palette - "R0-R3,LR" already saved

PV_SetDefaultPalette ROUT
	ADR	r0, VIDCProgTable
	ADR	r1, VIDCProgTableEnd
	MOV	r2, #VIDC
10
	LDR	lr, [r0], #4
	STR	lr, [r2]
	TEQ	r0, r1
	BNE	%BT10

	MOV	lr, #0
	MOV	r0, #256-16
15
	STR	lr, [r2]		; program colours 16 to 255 to black
	SUBS	r0, r0, #1
	BNE	%BT15

	ADR	r1, DefaultPaletteTable
	MOV	r0, #0
20
	LDR	r2, [r1], #4
	BL	UpdatePaletteSetting
	ADD	r0, r0, #1
	TEQ	r0, #8
	BNE	%BT20

	SWI	XColourTrans_InvalidateCache	; let ColourTrans know we have a different palette

	BL	TransmitSAA7183Data	; send all data

	BL	SetDefaultColours


        B       ClaimExit               ; claim vector

        LTORG

DefaultPaletteTable
	&	&00000000		; colour 0 (black)
	&	&55555500		; colour 1 (1/3 grey)
	&	&AAAAAA00		; colour 2 (2/3 grey)
	&	&FFFFFF00		; colour 3 (white)
	&	&0000FF00		; colour 4 (red)
	&	&00FF0000		; colour 5 (green)
	&	&00BBFF00		; colour 6 (orange)
	&	&FF000000		; colour 7 (blue)

VIDCProgTable
	&	&10000000		; program palette index to 0
	&	&08000000		; colour 0 (RGB bits irrelevant if you have the h/w)
	&	&09111111		; colour 1
	&	&0A222222		; colour 2
	&	&0B333333		; colour 3
	&	&0C444444		; colour 4
	&	&0D555555		; colour 5
	&	&0E666666		; colour 6
	&	&0F777777		; colour 7
	&	&00888888		; colour 8 (transparent)
	&	&00999999		; colour 9 (ditto)
	&	&00AAAAAA		; colour 10
	&	&00BBBBBB		; colour 11
	&	&00CCCCCC		; colour 12
	&	&00DDDDDD		; colour 13
	&	&00EEEEEE		; colour 14
	&	&00FFFFFF		; colour 15
VIDCProgTableEnd

; *****************************************************************************
;
;	SetDefaultColours - Request a callback to set default text/graphics colours
;
; in:	-
; out:	-

SetDefaultColours Entry "r0-r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	lr, PaletteVCallbackRequested
	TEQ	lr, #0
	EXITS	NE

	MOV	lr, #1
	STR	lr, PaletteVCallbackRequested

	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_AddCallBack
	EXITS

ReallySetDefaultColours Entry "r0,r1"
	MOV	lr, #0
	STR	lr, PaletteVCallbackRequested

	LDR	r0, MacroModeType
	CMP	r0, #-1			; if not in a macro mode any more, just quit
	EXIT	EQ

	MOV	r0, #0
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set graphics foregd to colour 7

	MOV	r0, #&40
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set text foregd to colour 7

	EXIT

; *****************************************************************************
;
;	RGBToYUV - Convert RGB to YUV
;
; in:	r2 = BBGGRR00
;
; out:	r2 = 00VVUUYY in the format required by Macrovision palette

RGBToYUV Entry "r0,r3-r6"
	AND	lr, r2, #&FF00
	ADRL	r0, YUVTable
	LDR	r3, [r0, lr, LSR #6]	; RY
	ADD	r0, r0, #&400
	LDR	r4, [r0, lr, LSR #6]	; RU
	ADD	r0, r0, #&400
	LDR	r5, [r0, lr, LSR #6]	; RV

	AND	lr, r2, #&FF0000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GY
	ADD	r3, r3, r6		; RY+GY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GU
	ADD	r4, r4, r6		; RU+GU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GV
	ADD	r5, r5, r6		; RV+GV

	AND	lr, r2, #&FF000000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BY
	ADD	r3, r3, r6		; RY+GY+BY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BU
	ADD	r4, r4, r6		; RU+GU+BU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BV
	ADD	r5, r5, r6		; RV+GV+BV

	ADD	r3, r3, #&80		; add on 1/2, before we round down
	MOV	r3, r3, ASR #8
	CMP	r3, #16			; limit Y to 16 to 235
	MOVLT	r3, #16
	CMP	r3, #235
	MOVGT	r3, #235
	EOR	r3, r3, #128		; toggle bit 7 as required

	ADD	r4, r4, #&80		; add on 1/2, before we round down
	MOV	r4, r4, ASR #8
	ADD	r4, r4, #128		; convert to Cr
	CMP	r4, #16			; limit Cr to 16 to 240
	MOVLT	r4, #16
	CMP	r4, #240
	MOVGT	r4, #240
	EOR	r4, r4, #128		; toggle bit 7 as required

	ADD	r5, r5, #&80		; add on 1/2, before we round down
	MOV	r5, r5, ASR #8
	ADD	r5, r5, #128		; convert to Cb
	CMP	r5, #16			; limit Cb to 16 to 240
	MOVLT	r5, #16
	CMP	r5, #240
	MOVGT	r5, #240
	EOR	r5, r5, #128		; toggle bit 7 as required

	ORR	r2, r3, r4, LSL #8
	ORR	r2, r2, r5, LSL #16
	EXIT

; *****************************************************************************
;
;	SelectNormalVideoPath - Program TDA8540 to select normal path
;
; in:	-
; out:	-
;

SelectNormalVideoPath Entry "r0-r2"
	MOV	r0, #IICDevice_TDA8540
	ADR	r1, TDA8540NormalIICData
	MOV	r2, #TDA8540NormalIICDataEnd - TDA8540NormalIICData
	SWI	XIIC_Control
	BVS	%FT90

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183OutputsOffData
	MOV	r2, #SAA7183OutputsOffDataEnd - SAA7183OutputsOffData
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

90
	STRVS	r0, [sp]
	EXIT

SAA7183OutputsOffData
	=	&6B		; sub-address to control RCV outputs
	=	&00		; disable outputs
SAA7183OutputsOffDataEnd
	ALIGN

TDA8540NormalIICData
	=	0		; sub-address to start at
	=	4_3100		; OUT3 (output_Y) = IN3 (normal_Y)
				; OUT2 (output_C) = IN1 (normal_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001100	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 0 (normal CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540NormalIICDataEnd
	ALIGN

; *****************************************************************************
;
;	SelectMacroVideoPath - Program TDA8540, SAA7183 for Macrovision video path
;
; in:	r0 -> mode node
; out:	-
;

SelectMacroVideoPath Entry "r0-r2"
	MOV	r0, #IICDevice_TDA8540
	ADR	r1, TDA8540MacroIICData
	MOV	r2, #TDA8540MacroIICDataEnd - TDA8540MacroIICData
	SWI	XIIC_Control
	BVS	%FT90

	LDR	r0, [sp]	; reload pointer to node
	LDR	r0, [r0, #MVMode_Flags]
	STR	r0, MacroModeType

	ADRL	lr, IICDataBlocks
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, r0, lr	; point at data block for this type of mode
	STR	r0, IICDataBlockPtr
	BL	SetupIICBlock

	BL	TransmitSAA7183Data	; send all data to SAA7183

	LDR	r0, MacroModeType
	TST	r0, #1			; are we anti-taping
	BLNE	ClaimEventV		; if so, then start modulation
90
	STRVS	r0, [sp]
	EXIT

TDA8540MacroIICData
	=	0		; sub-address to start at
	=	4_2000		; OUT3 (output_Y) = IN2 (macro_Y)
				; OUT2 (output_C) = IN0 (macro_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001101	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 1 (macro CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
TDA8540MacroIICDataEnd
	ALIGN

CBENB		*	0	; Data from input ports, not just colour bars
DISKEY		*	0	; Overlay enabled
FMT16		*	1	; Select format CbCr on DP port and Y on MP port
Y2C		*	1	; Y data are straight binary (not 2's complement)
UV2C		*	1	; Cb/Cr data are straight binary

PAL_CHPS	*	&68	; Phase of encoded colour subcarrier for data from input ports
NTSC_CHPS	*	&82

DOWNB		*	0	; RGB DACs on
DOWNA		*	0	; CVBS, Y, C DACs on
INPI		*	0	; Nominal PAL phase
RTCE		*	0	; No real time control of generated subcarrier frequency

PAL_YGS		*	0	; Luminance gain for White-Black = 100 IRE
NTSC_YGS	*	1	; Luminance gain for White-Black = 92.5 IRE

PAL_GAINU	*	&7D	; Variable gain for Cb
NTSC_GAINU	*	&76	; Variable gain for Cb

PAL_GAINV	*	&AF	; Variable gain for Cr
NTSC_GAINV	*	&A5	; Variable gain for Cr

PAL_BSTA	*	&4B	; Colour burst amplitude
NTSC_BSTA	*	&66	; Colour burst amplitude

PAL_BLCKL	*	&2D	; Black level
NTSC_BLCKL	*	&3C	; Black level

PAL_BLCKLA	*	&15	; Black level (anti-taping active)
NTSC_BLCKLA	*	&22	; Black level (anti-taping active)

PAL_BLNNL	*	&3F	; Blanking level
NTSC_BLNNL	*	&3A	; Blanking level

PAL_BLNNLA	*	&27	; Blanking level outside vsync (anti-taping active)
NTSC_BLNNLA	*	&20	; Blanking level outside vsync (anti-taping active)

PAL_BLNVB	*	&3F	; Blanking level during Vertical blanking interval
NTSC_BLNVB	*	&3A	; Blanking level during vsync

PAL_AGCL	*	&6F	; AGC Super White level (must be modulated by s/w)
NTSC_AGCL	*	&70	; AGC Super White level (must be modulated by s/w)

DECTYP		*	0	; Controls whether Real Time Control Input comes from SAA7151B or SAA7111
				; (in our case neither, so irrelevant)

SECAM		*	0	; Not SECAM
SCBW		*	1	; Standard bandwidth for Chrominance Encoding
FISE		*	0	; 864 total pixel clocks per line, not 858

PRCV2		*	1	; HS Active low
ORCV2		*	1	; HS output
CBLF		*	0	; HSync used in
PRCV1		*	0	; VS Active high
ORCV1		*	1	; VS output
TRCV2		*	1	; HSync from RCV2
SRCV1		*	2_00	; VSync input type VS

SBLBN		*	1	; Vertical blanking forced according to CCIR-624 (50Hz) or RS170A (60Hz)
PHRES		*	2_00	; no reset of phase of colour subcarrier generator
FLC		*	2_00	; interlaced display

RCV2S		*	&00	; start RCV2 on Hsync
RCV2E		*	&C8	; for central positioning of MPEG with -hoffset -44

PAL_N1		*	48	; First line with inverted burst in first group of field 1, ie lines 1 to 64
NTSC_N1		*	18
PAL_N2		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 1
NTSC_N2		*	20
PAL_N3		*	48	; First line with inverted burst in first group of field 2, ie lines 1 to 64
NTSC_N3		*	18
PAL_N4		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 2
NTSC_N4		*	29
PAL_N5		*	4	; Colour stripe group spacing (first line to first line) (16+N5 for NTSC, 12+N5 for PAL)
NTSC_N5		*	4
PAL_N6		*	3	; Number of colour stripes (groups) per field (6+N6)
NTSC_N6		*	4
PAL_N7		*	2	; Number of lines per colour stripe (group), 2+N7
NTSC_N7		*	2
PAL_BPp_follow	*	0	; Number of back porch pulses following V-sync pulse
NTSC_BPp_follow	*	0
PAL_BPp_prior	*	14	; Number of back porch pulses prior to V-sync pulse
NTSC_BPp_prior	*	6

PAL_FirstPseudoAGC	*	9	; First line with pseudo-sync pulse and AGC pulse
PAL_LastPseudoAGC	*	18	; Last line ....
PAL_AGCMask	*	(-1 << PAL_FirstPseudoAGC) :AND: :NOT: (-1 << (PAL_LastPseudoAGC+1))
PAL_AGCMask1	*	(PAL_AGCMask >> 14) :AND: &FF
PAL_AGCMask2	*	(PAL_AGCMask >> 7) :AND: &7F

NTSC_FirstPseudoAGC	*	12
NTSC_LastPseudoAGC	*	19
NTSC_AGCMask	*	(-1 << NTSC_FirstPseudoAGC) :AND: :NOT: (-1 << (NTSC_LastPseudoAGC+1))
NTSC_AGCMask1	*	(NTSC_AGCMask >> 14) :AND: &FF
NTSC_AGCMask2	*	(NTSC_AGCMask >> 7) :AND: &7F

DATM		*	0	; Data transmission mode enable (I don't know exactly what this does so don't enable it)

PAL_N8		*	4	; pseudo-sync pulse duration
NTSC_N8		*	3
PAL_N9		*	3	; location of 1st pseudo-sync pulse related to the leading edge of the H-sync pulse
NTSC_N9		*	2

PSSYNC_EN	*	1	; pseudo-sync pulses enabled

PAL_N10		*	3	; pseudo-sync pulse spacing
NTSC_N10	*	3
PULM		*	0	; pulsation mode enable (disabled for now, needs to be modulated by s/w)
p_count		*	5	; in state 'A', number of lines where AGC pulses are active (lines 9 to 13 inclusive)
tm_data		*	0	; transmission data, not used at present

MACRO		*	1	; Macrovision enabled
BINV		*	1	; Burst-inversion enabled
AGCFB		*	1	; AGC pulses following pseudo-sync pulses enabled
AGCEQ		*	1 	; Ancillary AGC pulses enabled

	GBLA	NextBase
	GBLA	NextSectionStart
	MACRO
	NewSections
NextBase SETA	0
NextSectionStart SETA	-1
	MEND

	MACRO
	Section	$base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, $length
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr + ($length)
	MEND

	MACRO
	SectionZero $base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, ($length) :OR: &80
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr
	MEND

	MACRO
	SectionEnd
	ASSERT	NextBase = &80
	=	0, 0		; zero length indicates end
	MEND

	MACRO
	Normal_00_39
	SectionZero	0, &3A	; zero fill from 0 to &39
	MEND

	MACRO
	Common_3A_41
	Section	&3A, 1
	=	(CBENB<<7) :OR: (DISKEY<<6) :OR: (FMT16<<2) :OR: (Y2C<<1) :OR: (UV2C<<0)
	SectionZero	&3B, (&42-&3B)	; zero fill from &3B to &41
	MEND

	MACRO
	Palette_42_59
	Section &42, (&5A-&42)
	=	&90, &00, &00	; Black
	=	&A9, &70, &EE	; Blue
	=	&D1, &DA, &70	; Red
	=	&EA, &4A, &5E	; Magenta
	=	&11, &B6, &A2	; Green
	=	&2A, &26, &90	; Cyan
	=	&52, &90, &12	; Yellow
	=	&6B, &00, &00	; White
	MEND

	MACRO
	PAL_5A_5C
	Section	&5A, 3
	=	PAL_CHPS
	=	(PAL_GAINU :AND: &FF)
	=	(PAL_GAINV :AND: &FF)
	MEND

	MACRO
	NTSC_5A_5C
	Section	&5A, 3
	=	NTSC_CHPS
	=	(NTSC_GAINU :AND: &FF)
	=	(NTSC_GAINV :AND: &FF)
	MEND

	MACRO
	NormalPAL_5D_60
	Section	&5D, 4
	=	((PAL_GAINU :AND: &100)>>1) :OR: PAL_BLCKL
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNL<<0)
	=	PAL_BLNVB
	=	&00		; Null register (&60)
	MEND

	MACRO
	NormalNTSC_5D_60
	Section	&5D, 4
	=	((NTSC_GAINU :AND: &100)>>1) :OR: NTSC_BLCKL
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNL<<0)
	=	NTSC_BLNVB
	=	&00		; Null register (&60)
	MEND

	MACRO
	PAL_61_66
	Section	&61, (&67-&61)
	=	(DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (PAL_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (1<<1) :OR: FISE
	=	(RTCE<<7) :OR: (PAL_BSTA<<0)
	=	&CB, &8A, &09, &2A	; subcarrier frequency
	MEND


	MACRO
	NTSC_61_66
	Section	&61, (&67-&61)
	=	(DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (NTSC_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (0<<1) :OR: FISE
	=	(RTCE<<7) :OR: (NTSC_BSTA<<0)
	=	&1F, &7C, &F0, &21	; subcarrier frequency
	MEND

	MACRO
	Common_67_7C
	Section	&67, (&73-&67)
	=	&00, &00, &00, &00	; no captioning or extended data
	=	(SRCV1<<6) :OR: (TRCV2<<5) :OR: (ORCV1<<4) :OR: (PRCV1<<3) :OR: (CBLF<<2) :OR: (ORCV2<<1) :OR: PRCV2
	=	&54			; HTRIG
	=	&02			; VTRIG??
	=	(SBLBN<<7) :OR: (PHRES<<4) :OR: FLC
	=	&00			; no line 21 encoding or teletext or closed caption or extended data
	=	RCV2S :AND: &FF
	=	RCV2E :AND: &FF
	=	((RCV2E :AND: &700) :SHR: 4) :OR: ((RCV2S :AND: &700) :SHR: 8)
	SectionZero	&73, (&7D-&73)	; zero from &73 to &7C: no TTX stuff
	MEND

	MACRO
	Normal_7D_7F
	SectionZero	&7D, (&80-&7D)
	MEND

	MACRO
	AntiTapingPAL_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	PAL_N1			; N1
	=	&00			; register 02 not used
	=	PAL_N2, PAL_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	PAL_N4
	=	(PAL_N7<<6) :OR: (PAL_N6<<3) :OR: (PAL_N5<<0)
	=	(PAL_BPp_prior<<4) :OR: (PAL_BPp_follow<<0)
	=	&00			; register 13 not used
	=	PAL_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: PAL_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (PAL_N9<<3) :OR: (PAL_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (PAL_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingNTSC_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	NTSC_N1			; N1
	=	&00			; register 02 not used
	=	NTSC_N2, NTSC_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	NTSC_N4
	=	(NTSC_N7<<6) :OR: (NTSC_N6<<3) :OR: (NTSC_N5<<0)
	=	(NTSC_BPp_prior<<4) :OR: (NTSC_BPp_follow<<0)
	=	&00			; register 13 not used
	=	NTSC_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: NTSC_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (NTSC_N9<<3) :OR: (NTSC_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (NTSC_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingPAL_5D_60
	Section	&5D, (&61-&5D)
	=	((PAL_GAINU :AND: &100)>>1) :OR: (PAL_BLCKLA<<0)
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNLA<<0)
	=	PAL_BLNVB
	=	PAL_AGCL
	MEND

	MACRO
	AntiTapingNTSC_5D_60
	Section	&5D, (&61-&5D)
	=	((NTSC_GAINU :AND: &100)>>1) :OR: (NTSC_BLCKLA<<0)
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNLA<<0)
	=	NTSC_BLNVB
	=	NTSC_AGCL
	MEND

	MACRO
	AntiTaping_7D_7F
	Section	&7D, (&80-&7D)
	=	(AGCEQ<<7) :OR: (AGCFB<<6) :OR: (BINV<<5) :OR: (MACRO<<4)
	=	&00, &00	; locations &7E, &7F not used
	MEND

SAA7183MacroPAL0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	NormalPAL_5D_60
	PAL_61_66
	Common_67_7C
	Normal_7D_7F
	SectionEnd

SAA7183MacroNTSC0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	NormalNTSC_5D_60
	NTSC_61_66
	Common_67_7C
	Normal_7D_7F
	SectionEnd

SAA7183MacroPAL1IICData
	NewSections
	AntiTapingPAL_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	AntiTapingPAL_5D_60
	PAL_61_66
	Common_67_7C
	AntiTaping_7D_7F
	SectionEnd

SAA7183MacroNTSC1IICData
	NewSections
	AntiTapingNTSC_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	AntiTapingNTSC_5D_60
	NTSC_61_66
	Common_67_7C
	AntiTaping_7D_7F
	SectionEnd

	ALIGN

IICDataBlocks
	&	SAA7183MacroPAL0IICData - IICDataBlocks
	&	SAA7183MacroPAL1IICData - IICDataBlocks
	&	SAA7183MacroNTSC0IICData - IICDataBlocks
	&	SAA7183MacroNTSC1IICData - IICDataBlocks

; *****************************************************************************
;
;	SetupIICBlock - Transfer a compacted block of data into IIC block
;
; Format of compacted block is a series of bytes as follows:-
;
; <offset>, <length>, <byte_1>, <byte_2>, ..., <byte_length>
;	Store the following bytes at the given <offset>
; <offset>, <length> OR 128
;	Store zero for <length> bytes at given <offset>
; x, 0
;	Indicates end of block
;

; in:	r0 -> compacted block
;
; out:	-

SetupIICBlock Entry "r0-r3"
	ADR	r1, SAA7183IICMap
10
	LDRB	r2, [r0], #1		; get start offset
	LDRB	r3, [r0], #1		; get length and zeroing flag
	TEQ	r3, #0			; is it end of the table
	EXIT	EQ

	TST	r3, #&80		; are we zeroing
	BNE	%FT50

20
	LDRB	lr, [r0], #1
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT20
	B	%BT10

50
	BIC	r3, r3, #&80		; knock off zeroing flag
	MOV	lr, #0
60
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT60
	B	%BT10

; *****************************************************************************
;
;	TransmitSAA7183Data - Transmit IIC data to SAA7183
;
; in:	-
; out:	If error, r0 -> error, VS

TransmitSAA7183Data Entry "r0-r2"
	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183IICData
	MOV	r2, #128+1		; one byte for sub-address + 128 bytes of data
	SWI	XIIC_Control
	STRVS	r0, [sp]
	EXIT

	MACRO
	AGCEntry	$agcfb, $pulm, $fields, $agcl
	ASSERT	($agcfb) = 0 :LOR: ($agcfb) = 1
	ASSERT	($pulm) = 0 :LOR: ($pulm) = 1
	ASSERT	($fields) >=1 :LAND: ($fields) <=65535
	LCLA	output
output	SETA	($agcl) :OR: (($pulm) << AGCBitShift_PULM) :OR: (($agcfb) << AGCBitShift_AGCFB) :OR: (($fields) << AGCBitShift_Fields)
;	! 0,	"AGCL = $agcl, AGCFB = $agcfb, PULM = $pulm, FIELDS = $fields, OUTPUT = $output"
	&	output
	MEND

	MACRO
	AGCRamp		$agcfb, $pulm, $fields, $fromagcl, $toagcl
	LCLA	RampCount
	LCLA	RampVel
 [ ($toagcl) >= ($fromagcl)
RampVel	SETA	1
 |
RampVel	SETA	-1
 ]
RampCount SETA ($fromagcl)
	WHILE	RampCount <> ($toagcl)+RampVel
	AGCEntry	$agcfb, $pulm, $fields, &$RampCount
RampCount SETA	RampCount + RampVel
	WEND
	MEND

	GBLA	LoopCount

;			AGCFB,  PULM,	Fields,	AGCL (, Target AGCL)
AGCModulationTableStart
	AGCEntry	1,	0, 	600, 	111
	AGCRamp		1, 	0, 	2,   	110,	41
	AGCEntry	0,	0,	12,	41

LoopCount SETA	5
	WHILE	LoopCount > 0
	AGCEntry	1,	1,	60, 	80
	AGCEntry	1,	0,	60,	49
LoopCount SETA LoopCount - 1
	WEND

	AGCRamp		1,	0,	2,	50,	110
AGCModulationTableEnd


YUVTable
	BIN	"Data.YUVTable"

; *****************************************************************************
;
;       Message stuff


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

	InsertDebugRoutines

        END
