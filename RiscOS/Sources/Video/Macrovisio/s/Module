; > Module

; Macrovision module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 27-Nov-95  TMD  0.01		Started.
; 06-Dec-95  TMD  0.01		First version released for DEC
; 06-Dec-95  TMD  0.02		Started on pulsation of AGC levels
; 17-Jan-96  TMD  0.03		Reset to normal video path on Service_PreReset
; 25-Jul-96  TMD  0.04		Split into two variants: STB2/1 and STB2/2
; 07-Aug-96  TMD  0.05		Optionally program CTRL1 signal on SCART
; 08-Aug-96  TMD  0.06		Add ForceMacroVideoPath option, for podules without daughter cards
; 08-Aug-96  TMD  0.07		Conditionally disabled RGB DACs when anti-taping
; 08-Aug-96  TMD  0.08		Remove debugging output on PaletteV
; 14-Aug-96  TMD  0.09		Modify initialisation to work on NTSC machines
; 14-Aug-96  TMD  0.10		Fixed FISE bit on NTSC machines
; 15-Aug-96  TMD  0.11		Fixed setting of PendingTVStandard on NTSC
; 12-Sep-96  TMD  0.12		Added variant C (STB2/2) as distinct from B (MPEG2 podule, new style) and A (MPEG1)
; 02-Oct-96  TMD  0.14		Fixed corruption of r0,r1 in Service_PreReset
; 07-Oct-96  TMD  0.15		No functional change - just delete old Hdr.Macrovisio from SrcFiler,
;				 so it doesn't get used as Hdr:Macrovision (something completely different!)
; 22-Oct-96  TMD  0.16		Alter SelectVideoPath so it only turns on CTRL1 if CTRL0 is on at the time, so on
;				 Service_PreReset we don't turn video back on again (eg when Standby is pressed).
; 31-Oct-96  TMD  0.17		Make programming of RCV2 pulse use system variables Macrovision$RCV2S, Macrovision$RCV2E
; 19-Oct-98  TMD  0.18		Disable colour burst inversion (Elmsdale don't want it).
; 13-Jan-99  NDT  0.19		Added double TDA8540 support (Variant D) and PAL/NTSC on IOMD_C_LINES
; 02-Feb-99  NDT  0.20          Modified to include the correct header file. RF bits now set on STB3.
;                                Fixed to build non STB3 variants...
; 02-Feb-99  BJGA 0.21          Sets modulator & boost bits in TDA-1 according to PAL/NTSC and CTRL0 bits from IOMD_CLINES.
;                                Handles Service_Standby (switches in and out of Standby video path).
; 03-Mar-99  NDT  0.22          Reworked standby code to use the parameter and the TVOn system variable instead of bits in
;                                IOMD_CLINES.
; 10-Mar-99  NDT  0.23          Added adjustment to RCV2E when in normal mode - RCV2N.
; 10-Mar-99  NDT  0.24          Palette set to black in macrovision mode.  Pointer colours now initialised.
; 22-Mar-99  NDT  0.25          We can now configure burst inversion (BINV) using a system variable.
; 07-Apr-99  BJGA 0.25-4.5.2.1  Added NTSC line 21 (closed captions) support.
; 14-Apr-99  TMD  0.25-4.5.2.2  Added code for fast switching in/out of Macrovision video path, for closed-caption support.
; 19-Apr-99  BJGA 0.25-4.5.2.3  Now builds cleanly when Machine=Peregrine (using Hdr:MPEG2Card instead of Hdr:MPEG2bCard).
; 20-Apr-99  BJGA 0.25-4.5.2.4  Now ensures that control codes are always sent in pairs on odd fields
; 10-May-99  BJGA 0.26          Merged development branch back onto trunk.
; 30-Jun-99  BJGA 0.27          Added facility to blank screen for a specified number (including zero) of fields during a
;                                switch in or out of caption mode. The various operations are now carried out on the VSync
;                                event, to hide glitches within the VBI if possible.
; 22-Jul-99  BJGA 0.28          Stopped Macrovision_CaptionControl returning ofla errors when Macrovision$RCV2* variables are unset.
; 13-Mar-00  BJGA 0.29          Implemented NewColourScheme code - completely new PaletteV code for both video paths.
;

	LEADR	Module_LoadAddr

        GET     Hdr:NdrDebug
        GBLL    dadebug_module
        GBLL    debug_irqsafe
debug           SETL    false           ; false turns off all NdrDebug debugging
dadebug_module  SETL    true
debug_irqsafe   SETL    true

TAB	*	9
LF	*	10
FF	*	12
CR	*	13

; Default foreground text/graphics colour in Macrovision modes

DefaultForegroundColour	*	3

 [ :LNOT: ProvideSWI
; Structure of a mode entry

			^	0
MVMode_LinkOffset	#	4		; Offset from node to next node (0 if end)
MVMode_ModeNumber	#	4		; Mode number
MVMode_VarNameOffset	#	4		; Offset from node to variable name
MVMode_Type		#	4		; 0 => normal video path, 1 => macro no anti-tape, 2 => anti-tape
MVMode_TVStandard	#	4		; 0 => PAL, 1 => NTSC

	MACRO
$label	MVModeNode	$modenumber, $varnameaddr, $type, $tvstandard, $next
$label
10
 [ "$next" = ""
	&	0
 |
	&	$next - %BT10
 ]
	&	$modenumber
	&	$varnameaddr - %BT10
	&	$type
	&	$tvstandard
	MEND
 ]

 [ Captions
; Structure of a caption / extended data FIFO
FIFOlength      *       55              ; FIFO length, in bytes  (4+4+1+55=64)
                                        ; The FIFO can hold 0 to (FIFOlength-1) bytes at a time, so FIFOlength
                                        ; must be odd to ensure complete byte pairs are always entered
                ^       0
FIFO_ReadPtr    #       4               ; index into FIFO to read from
FIFO_WritePtr   #       4               ; index into FIFO to write to
                #       1               ; unused
FIFO_Buffer     #       FIFOlength
FIFO_Size       #       0

                GBLL    BigFIFOs        ; set true if FIFO_Size > 1024 bytes
BigFIFOs        SETL    {FALSE}
 ]

		^	0, wp

IICDataBlockPtr #	4		; debugging to store address of last compacted data block used
 [ :LNOT: NewColourScheme ; we stay permanently on PaletteV now
PaletteVClaimed	#	4		; 0 => PaletteV not claimed, 1 => PaletteV claimed
 ]
 [ Captions
EventVState	#	4		; vsync event handler state (0 => EventV not claimed)
 |
EventVClaimed	#	4		; 0 => EventV not claimed, 1 => EventV claimed
 ]
 [ :LNOT: NewColourScheme ; with a standard default palette, the standard default colours are fine as they are
PaletteVCallbackRequested #	4	; non-zero => we have an outstanding callback to set the default colours
 ]
EventVCallbackRequested #	4	; non-zero => we have an outstanding callback to vary the AGC level

VSyncCount	#	4		; number of vsyncs till next modulation
AGCModulationPosition # 4		; position in table for next thing to do

MacroType	#	4		; 0 for normal video path, 1 for macrovision no anti-taping,
					; 2 for anti-taping, 3 for fast-switched CC mode (like 1 but no PaletteV intervention)
TVStandard	#	4		; 0 for PAL, 1 for NTSC

 [ ProvideSWI
PendingMacroType #	4		; what to select on next mode change
PendingTVStandard #	4		; ditto for TV standard
 ]

LogicalPalette	#	8*4		; BBGGRR00 for each of colours 0 to 7
TempModulationBlock #	2		; sub-address, data for real-time s/w modulation
		#	1		; keep it aligned
SAA7183IICData  #	1		; 1 byte for sub-address
SAA7183IICMap	#	128		; copy of the 128 sub-address registers in the SAA7183


 [ international
MessageFile_Block #	16
MessageFile_Open  #	4
 ]

 [ Captions
RCV2IICBlk	#	4
ControlCode1    #       1
ControlCode2    #       1
ControlCodeState #      1               ; 0 = normal
                                        ; 1 = received first byte of a control code
                                        ; 2 = received second byte of a control code
                                        ; 3 = received matching repeated first byte
SwitchState     #       1               ; 0 = not switching
                                        ; 1 = waiting for VSync to turn palette all transparent / all black
                                        ; 2 = waiting for VSync to switch paths
                                        ; 3 = waiting for VSync to set palette appropriate for new path
SwitchCountdown #       1               ; number of fields to wait until unblanking
        AlignSpace

NextMacroType   #       4               ; MacroType to assert at next VSync (unless I²C bus is in use)

IICBusyFlag     #       4

        MACRO
$label  MyIIC_Control $con
$label
        MOV$con lr, #1
        STR$con lr, IICBusyFlag
        SWI$con XIIC_Control
        MOV$con lr, #0
        STR$con lr, IICBusyFlag
        MEND

                #       FIFO_Size - ((:INDEX:@) :AND: (FIFO_Size-1))
CaptionFIFO     #       FIFO_Size
ExtDataFIFO     #       FIFO_Size
 ]

 [ NewColourScheme
; Copies of important VDU variables

ModeFlags       #       4
NColour         #       4

FlashState      #       4       ; flash state (1 or 2)

; Look-up tables for managing palette in Macrovision video path
; The 8 colours programmed into the DENC are derived from the gamma-corrected first-flash-state settings of logical colours 0-7

ApparentPalette1 #      4*20    ; palette entry words (flash state 1, bit 7 supremacy) for 16 logical colours, border, 3 pointer colours
ApparentPalette2 #      4*20    ; palette entry words (flash state 2, bit 7 supremacy) for 16 logical colours, border, 3 pointer colours
HardwarePalette1 #      1*20    ; settings of ED[0:3] (flash state 1) for 16 logical colours, border, 3 pointer colours
HardwarePalette2 #      1*20    ; settings of ED[0:3] (flash state 2) for 16 logical colours, border, 3 pointer colours
        AlignSpace 256
GammaTables     #       256*3

BulkWriteBlock  #       4*256*2 ; up to 256 colours, up to 2 flash states

PointerPalette  #       4*4     ; soft-copy of pointer palette in non-Macrovision path (offset 0 not used)
 ]

Module_WorkspaceSize * :INDEX: @

 [ :LNOT: ProvideSWI
MacrovisionPALMode0	*	64
MacrovisionPALMode1	*	65
MacrovisionNTSCMode0	*	66
MacrovisionNTSCMode1	*	67
 ]

IICDevice_SAA7183	*	&88
IICDevice_TDA8540	*	&98
IICDevice_TDA8540_2	*	&9c

TDA8540_Data_Size	*	4	; Including address byte

VIDC		*	&03500000	; address to poke VIDC20

; Sub-addresses within SAA7183

SubAddress_PULM		*	&21	; register with PULM bit
SubAddress_OVL_LUT_Y0	*	&42	; base sub-address for palette entries
SubAddress_AGCL		*	&60	; AGC level
SubAddress_AGCFB	*	&7D	; register with AGCFB bit

; Bit masks within register

BitMask_AGCL		*	&FF
BitMask_PULM		*	1 :SHL: 3
BitMask_AGCFB		*	1 :SHL: 6

; Masks withing AGC table entries

AGCBitMask_AGCL		*	&FF :SHL: 0
AGCBitShift_PULM	*	8
AGCBitMask_PULM		*	1 :SHL: AGCBitShift_PULM
AGCBitShift_AGCFB	*	9
AGCBitMask_AGCFB	*	1 :SHL: AGCBitShift_AGCFB
AGCBitShift_Fields	*	16

 [ Captions
; State flags for vsync event handler

EventVState_AntiTaping  *       1 :SHL: 0    ; anti-taping mode is engaged
EventVState_Captioning  *       1 :SHL: 1    ; line 21 encoding is enabled
EventVState_Switching   *       1 :SHL: 2    ; a "caption mode" switch start or end is pending
EventVState_Modulate    *       1 :SHL: 3    ; next callback should modulate AGC registers
EventVState_CaptionWaiting *    1 :SHL: 4    ; transmit caption data if possible
EventVState_ExtDataWaiting *    1 :SHL: 5    ; transmit extended data if possible
EventVState_OKToSwitch  *       1 :SHL: 6    ; "caption mode" switch is pending and I²C bus is free
 ]

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
 [ ProvideSWI
	&	MacrovisionSWI_Base ; SWI chunk
	&	Mod_SWIHandler-Module_BaseAddr
	&	Mod_SWITable-Module_BaseAddr
 |
        &       0 ; SWI chunk
        &       0 ; Mod_SWIHandler-Module_BaseAddr
        &       0 ; Mod_SWITable-Module_BaseAddr
 ]
        &       0                               ; no swi name decode entry

Mod_Title
        =       "Macrovision", 0

Mod_HelpStr
        =       "Macrovision", TAB, "$Module_MajorVersion ($Module_Date)"
        [ Module_MinorVersion <> ""
        =       " $Module_MinorVersion"
        ]
        =       0
        ALIGN

Mod_HC_Table	*	Module_BaseAddr		; no star commands

 [ ProvideSWI
Mod_SWITable
	=	"Macrovision", 0
	=	"SetState", 0
 [ Captions
	=       "LoadCaptions", 0
	=	"CaptionControl", 0
 ]
	=	0
	ALIGN
 ]

 [ debug
        InsertNDRDebugRoutines
 ]

; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry
        LDR     r2, [r12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

      [ debug
        Debug_Open      "MacroDebug"
      ]

        MOV     r0, #0
      [ NewColourScheme
        BL      ClaimPaletteV           ; stay on PaletteV all the time now
      |
        STR     r0, PaletteVClaimed
      ]
      [ Captions
	STR	r0, EventVState
      |
	STR	r0, EventVClaimed
      ]
      [ :LNOT: NewColourScheme
	STR	r0, PaletteVCallbackRequested
      ]
	STR	r0, EventVCallbackRequested
	STRB	r0, SAA7183IICData	; zero sub-address

 [ ProvideSWI
	STR	r0, PendingMacroType
	STR	r0, PendingTVStandard
 |
	ADR	r0, RMEnsureInterlaceString
	SWI	XOS_CLI
	EXIT	VS
 ]

 [ Captions
        STR     r0, IICBusyFlag
        STRB    r0, ControlCodeState

	MOV	r0, #&70	; IIC offset of RCV2 registers in 7183
	STRB	r0, RCV2IICBlk + 0

        MOV     r0, #FIFO_Buffer
      [ BigFIFOs
        ADRL    r14, CaptionFIFO + FIFO_ReadPtr
        STR     r0, [r14]
        ADRL    r14, CaptionFIFO + FIFO_WritePtr
        STR     r0, [r14]
        ADRL    r14, ExtDataFIFO + FIFO_ReadPtr
        STR     r0, [r14]
        ADRL    r14, ExtDataFIFO + FIFO_WritePtr
        STR     r0, [r14]
      |
        STR     r0, CaptionFIFO + FIFO_ReadPtr
        STR     r0, CaptionFIFO + FIFO_WritePtr
        STR     r0, ExtDataFIFO + FIFO_ReadPtr
        STR     r0, ExtDataFIFO + FIFO_WritePtr
      ]
 ]

 [ NewColourScheme
        ; Initialise gamma-correction tables to a 1:1 mapping
        ADR     r2, GammaTables
        MOV     r0, #0
05
        STRB    r0, [r2, #&200]                 ; store in blue table
        STRB    r0, [r2, #&100]                 ; store in green table
        STRB    r0, [r2], #1                    ; store in red table, and advance
        ADD     r0, r0, #1
        CMP     r0, #256
        BCC     %BT05

        ; Initialise FlashState (we have no way to read the current state, so we just have to guess!)
        MOV     r0, #1
        STR     r0, FlashState
 ]

 [ ReadVarsForRCV2Timing
; Now check if the Macrovision$RCV2S/E variables have been set up, and if not, set them ourselves

	ADR	r0, MacroVarRCV2SName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT10			; [variable exists]

	ADR	r0, MacroVarRCV2SName
	LDR	r1, =RCV2S
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
10

	ADR	r0, MacroVarRCV2EName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT20			; [variable exists]

	ADR	r0, MacroVarRCV2EName
	LDR	r1, =RCV2E
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
20
   [ :DEF: RCV2SN
	ADR	r0, MacroVarRCV2SNName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT30			; [variable exists]

	ADR	r0, MacroVarRCV2SNName
	LDR	r1, =RCV2SN
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
30
   ]
   [ :DEF: RCV2EN
	ADR	r0, MacroVarRCV2ENName
	MOV	r1, #0			; no buffer
	MOV	r2, #-1			; -ve length checking for existence of variable
	MOV	r3, #0			; context pointer
	MOV	r4, #0			; not expanded
	SWI	XOS_ReadVarVal
	TEQ	r2, #0
	BMI	%FT40			; [variable exists]

	ADR	r0, MacroVarRCV2ENName
	LDR	r1, =RCV2EN
	Push	"r1"
	MOV	r1, sp
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; 4-byte integer
	SWI	XOS_SetVarVal
	ADD	sp, sp, #4		; junk stack frame
40
   ]
 ]

 [ ExternalSyncGenerator
; doesn't matter what we put as TV format here, since Macrovision chip
; is not master sync generator

	MOV	r1, #0			; (PAL)
 |
   [ MPEG2PoduleStatus2_NTSCNotPAL <> 0
	MOV	r0, #CardControlReason_ReadStatusRegister
	SWI	XMPEGVideo_CardControl
	EXIT	VS
	ANDS	r1, r1, #(MPEG2PoduleStatus2_NTSCNotPAL :SHL: 8) ; 0 (PAL) if bit clear
   |
	ASSERT	IOMD_C_PALNTSCType <> 0
	MOV	r1, #IOMD_Base
	LDR	r1, [r1, #IOMD_CLINES]
	ANDS	r1, r1, #IOMD_C_PALNTSCType	; 0 (PAL) if bit clear
   ]
	MOVNE	r1, #1			; 1 (NTSC) if bit set
	STR	r1, PendingTVStandard
 ]
	MOV	r0, #0			; default to macrovision off
	BL	SelectVideoPath
	EXIT	VS

 [ :LNOT: ProvideSWI
	BL	SetVars
	EXIT	VS
 ]
        CLRV
        EXIT

 [ ReadVarsForRCV2Timing
MacroVarRCV2SName
	=	"Macrovision$$RCV2S", 0
	ALIGN
MacroVarRCV2EName
	=	"Macrovision$$RCV2E", 0
	ALIGN
   [ :DEF: RCV2SN
MacroVarRCV2SNName
	=	"Macrovision$$RCV2SN", 0
	ALIGN
   ]
   [ :DEF: RCV2EN
MacroVarRCV2ENName
	=	"Macrovision$$RCV2EN", 0
	ALIGN
   ]

; Setup IIC map values for RCV2S, RCV2E from Macrovision variables
; in:	-
; out:	r0 = RCV2S, r1 = RCV2E, possibly adjusted by RCV2SN/RCV2EN
;       r2-r4 corrupted

ProcessRCV2Vars Entry "r0,r1"
	ADR	r0, MacroVarRCV2SName
	MOV	r1, sp
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVS	r0, =RCV2S
	STRVS	r0, [sp]

	ADR	r0, MacroVarRCV2EName
	ADD	r1, sp, #4
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVS	r0, =RCV2E
	STRVS	r0, [sp, #4]

   [ :DEF: RCV2SN
	LDR	r2, NextMacroType	; Reload macrovision type
	CMP	r2, #0			; Check for normal mode.
	BNE	%FT10			; If it's not normal don't adjust

	SUB	sp, sp, #4		; Save space on the stack

	ADR	r0, MacroVarRCV2SNName
	MOV	r1, sp
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVC	r2, [sp]		; Get the variable value
	LDRVS	r2, =RCV2SN		; Get the default on error

	ADD	sp, sp, #4		; Junk the space on the stack
	LDR	r0, [sp, #0]		; add r2 value onto stacked r0 value
	ADD	r0, r0, r2
	STR	r0, [sp, #0]
10
   ]
   [ :DEF: RCV2EN
	LDR	r2, NextMacroType	; Reload macrovision type
	CMP	r2, #0			; Check for normal mode.
	BNE	%FT20			; If it's not normal don't adjust

	SUB	sp, sp, #4		; Save space on the stack

	ADR	r0, MacroVarRCV2ENName
	MOV	r1, sp
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDRVC	r2, [sp]		; Get the variable value
	LDRVS	r2, =RCV2EN		; Get the default on error

	ADD	sp, sp, #4		; Junk the space on the stack
	LDR	r1, [sp, #4]		; add r2 value onto stacked r1 value
	ADD	r1, r1, r2
	STR	r1, [sp, #4]
20
   ]
	LDMIA	sp, {r0, r1}		; get values, but leave on stack for exit
	AND	r3, r0, #&FF		; bits 0..7 of RCV2S
	STRB	r3, SAA7183IICMap + &70
	AND	r3, r1, #&FF
	STRB	r3, SAA7183IICMap + &71
	AND	r3, r1, #&700
	MOV	r3, r3, LSR #4
	AND	r0, r0, #&700
	ORR	r3, r3, r0, LSR #8
	STRB	r3, SAA7183IICMap + &72
	EXITS                           ; not bothered if V was set by any of the SWIs

 ]

 [ BINV_Var
MacroVarBINVName	= "Macrovision$$BINV", 0
	ALIGN
 ]

 [ :LNOT: ProvideSWI
SetVars Entry
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	ADD	r1, r5, #MVMode_ModeNumber ; point r1 at value
	MOV	r2, #4			; length of value
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal
	BVS	%FT90			; if error, unset all vars and exit VS

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0			; check for end, and clear V if EQ
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXIT

90
	BL	UnsetVars
	EXIT

UnsetVars Entry "r0"
	ADR	r5, VarTable
10
	LDR	r0, [r5, #MVMode_VarNameOffset]
	ADD	r0, r0, r5		; convert to absolute pointer
	MOV	r2, #-1			; length of value (ie delete)
	MOV	r3, #0			; context pointer
	MOV	r4, #1			; type: integer
	SWI	XOS_SetVarVal

	LDR	lr, [r5, #MVMode_LinkOffset]
	CMP	lr, #0
	ADDNE	r5, r5, lr
	BNE	%BT10
	EXITS				; exit preserving all flags and r0

; in: r2 = mode number; out: if Macrovision mode, r0 -> node, EQ, else r0 corrupted, NE

CheckMacroMode Entry
	ADR	r0, VarTable
10
	LDR	lr, [r0, #MVMode_ModeNumber]
	TEQ	lr, r2
	EXIT	EQ

	LDR	lr, [r0, #MVMode_LinkOffset]
	TEQ	lr, #0
	ADDNE	r0, r0, lr
	BNE	%BT10
	TEQ	lr, #1			; set NE (cos lr = 0)
	EXIT


RMEnsureInterlaceString
	=	"RMEnsure Interlace 0.37 Error 0 Macrovision module requires the Interlace module version 0.37 or later", 0
MacroVarPAL0Name
	=	"Macrovision$$PAL0", 0
MacroVarPAL1Name
	=	"Macrovision$$PAL1", 0
MacroVarNTSC0Name
	=	"Macrovision$$NTSC0", 0
MacroVarNTSC1Name
	=	"Macrovision$$NTSC1", 0
	ALIGN

VarTable
VarPAL0Entry	MVModeNode MacrovisionPALMode0, MacroVarPAL0Name, 1, 0, VarPAL1Entry
VarPAL1Entry	MVModeNode MacrovisionPALMode1, MacroVarPAL1Name, 2, 0, VarNTSC0Entry
VarNTSC0Entry	MVModeNode MacrovisionNTSCMode0, MacroVarNTSC0Name, 1, 1, VarNTSC1Entry
VarNTSC1Entry	MVModeNode MacrovisionNTSCMode1, MacroVarNTSC1Name, 2, 1
 ]

; *****************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; insert anything we need here!

      [ NewColourScheme
        BL      ReleaseEventV           ; doesn't matter if we're not actually on it at the moment
        BL      ReleasePaletteV
      |
	LDR	r0, PaletteVClaimed
	TEQ	r0, #0
	BNE	%FT90			; [on vectors, so must be in Macrovision mode, so not safe to die]
      ]

; safe to die

	BL	RemoveCallbacks		; remove any outstanding callbacks
 [ :LNOT: ProvideSWI
	BL	UnsetVars		; unset system variables so no-one thinks we're still here
 ]

 [ debug
        Debug_Close
 ]
        CLRV
        EXIT

; can't die, cos we're in a Macrovision mode currently

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"Macrovision module cannot die: Macrovision mode in use", 0
	ALIGN

; *****************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
        TEQ     r1, #Service_ModeChanging
	TEQNE	r1, #Service_PreReset
        TEQNE   r1, #Service_Standby
        MOVNES  pc, lr

        LDR     wp, [r12]
        TEQ     r1, #Service_Standby
        BEQ     svc_Standby
	TEQ	r1, #Service_PreReset
	BEQ	svc_PreReset

; and drop thru to...

; svc_ModeChanging
;
; in:	r2 = mode number

svc_ModeChanging Entry "r0,r1"
      [ :LNOT: NewColourScheme
        BL      ReleasePaletteV
      ]
      [ :LNOT: Captions
	BL	ReleaseEventV
      ]
	BL	RemoveCallbacks

 [ ProvideSWI
	LDR	r0, PendingMacroType
	LDR	r1, PendingTVStandard
      [ :LNOT: NewColourScheme
	TEQ	r0, #0
	BLNE	ClaimPaletteV		; is macrovision video path, so claim PaletteV
      ]
	BL	SelectVideoPath		; select appropriate video path
 |
	BL	CheckMacroMode
	BNE	%FT50

; is Macrovision video path

	BL	ClaimPaletteV

	LDR	r1, [r0, #MVMode_TVStandard]
	LDR	r0, [r0, #MVMode_Type]
	BL	SelectVideoPath		; in: r0 = mode type, r1 = TV standard
	EXITS

; not a Macrovision mode, so release vectors if we've claimed them

50
	MOV	r0, #0			; get out of macrovision video path
	LDR	r1, TVStandard		; and assume same TV standard as last time
	BL	SelectVideoPath
 ]
        EXITS

; On Service_PreReset, switch back to normal video path, cos hardware won't

svc_PreReset Entry "r0,r1"
	MOV	r0, #0			; get out of macrovision video path
	LDR	r1, TVStandard		; and assume same TV standard as last time
	BL	SelectVideoPath
	EXITS

; On Service_Standby, switch in or out of standby video path
;
; In: R0 = flags
;          Bit 0 set   => we've gone into standby mode
;          Bit 0 clear => we've come out of standby mode

svc_Standby
        Entry   "r0-r4"
        TST     r0, #1			; Check if we're coming out of standby
        MOVNE	r0, #2			; If not, switch to standby mode.
	MOVEQ	r0, #1			; If coming out of standby switch to macrovision mode.
   [ :LNOT: ForceMacroVideoPath
	LDREQ	r1, MacroType		; But if we're using the normal video path (0)...
	TEQEQ	r1, #0
	MOVEQ	r0, #0			; ...switch to the normal video path.
   ]
	LDR	r1, TVStandard		; Load the TV type
        BL      Program_TDAs            ; nowhere to report errors to
        EXITS


ClaimPaletteV Entry "r0-r2"
      [ :LNOT: NewColourScheme
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   NE
      ]

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Claim
      [ :LNOT: NewColourScheme
	EXITS	VS

        MOV     r0, #1
        STR     r0, PaletteVClaimed
      ]
        EXITS

ReleasePaletteV Entry "r0-r2"
      [ :LNOT: NewColourScheme
        LDR     r0, PaletteVClaimed
        TEQ     r0, #0
        EXITS   EQ
      ]

	MOV	r0, #PaletteV
	ADR	r1, MyPaletteV
	MOV	r2, wp
	SWI	XOS_Release

      [ :LNOT: NewColourScheme
        MOV     r0, #0
        STR     r0, PaletteVClaimed
      ]
        EXITS

      [ Captions
; ClaimReleaseEventV - claims or releases EventV as appropriate to the new MacroType and TVStandard
;
; On entry:
;   R0 = new MacroType
;   R1 = new TVStandard

ClaimReleaseEventV Entry "r0-r2"
        ; Build new EventVState word
        MOV     r2, #0
        TEQ     r0, #2                          ; if anti-taping and either video standard,
        ORREQ   r2, r2, #EventVState_AntiTaping ; then set anti-taping bit
        TEQ     r0, #1
        TEQNE   r0, #2                          ; if any of the macrovision video path modes
	TEQNE	r0, #3
        TEQEQ   r1, #1                          ; and NTSC
        ORREQ   r2, r2, #EventVState_Captioning ; then set captioning bit
        LDRB    r14, SwitchState
        TEQ     r14, #0                         ; if waiting for either blanking or unblanking
        ORRNE   r2, r2, #EventVState_Switching  ; then set path-switch bit

        LDR     r0, EventVState                 ; get the old value
        STR     r2, EventVState                 ; store the new value

        TST     r2, #EventVState_AntiTaping :OR: EventVState_Captioning :OR: EventVState_Switching
        BNE     %FT50

	; All states are now off - if any of them used to be on, release EventV
	TST     r0, #EventVState_AntiTaping :OR: EventVState_Captioning :OR: EventVState_Switching
	BLNE    ReleaseEventV
	EXITS

50      ; Initialise anti-taping if it's being enabled
        BIC     r1, r2, r0                      ; r1 = bits being turned on
        TST     r1, #EventVState_AntiTaping
	ADRNEL	r14, AGCModulationTableStart
	STRNE	r14, AGCModulationPosition
	MOVNE	r14, #1
	STRNE	r14, VSyncCount                 ; start going thru table next vsync

        ; One or more states is now on - if none of them used to be, claim EventV
        TST     r0, #EventVState_AntiTaping :OR: EventVState_Captioning :OR: EventVState_Switching
        BLEQ    ClaimEventV
        EXITS
      ]

ClaimEventV Entry "r0-r2"
      [ :LNOT: Captions
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   NE

	ADRL	r0, AGCModulationTableStart
	STR	r0, AGCModulationPosition

	MOV	r0, #1
	STR	r0, VSyncCount		; start going thru table next vsync
      ]

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Claim
	EXITS	VS

	MOV	r0, #14
	MOV	r1, #4
	SWI	XOS_Byte		; enable vsync event

      [ :LNOT: Captions
        MOV     r0, #1
        STR     r0, EventVClaimed
      ]
        EXITS

ReleaseEventV Entry "r0-r2"
      [ :LNOT: Captions
        LDR     r0, EventVClaimed
        TEQ     r0, #0
        EXITS   EQ
      ]

	MOV	r0, #13
	MOV	r1, #4
	SWI	XOS_Byte		; disable vsync event

	MOV	r0, #EventV
	ADR	r1, MyEventV
	MOV	r2, wp
	SWI	XOS_Release

      [ :LNOT: Captions
        MOV     r0, #0
        STR     r0, EventVClaimed
      ]
        EXITS

MyEventV Entry "r0-r4"
	TEQ	r0, #Event_VSync
	EXIT	NE
      [ Captions
        LDR     r2, EventVState
        BIC     r2, r2, #EventVState_Modulate :OR: EventVState_CaptionWaiting :OR: EventVState_ExtDataWaiting :OR: EventVState_OKToSwitch

        LDR     r0, EventVCallbackRequested
        TEQ     r0, #0                          ; don't do any anti-taping stuff if we're still waiting for the last callback
        ANDEQ   r14, r2, #EventVState_AntiTaping
        TEQEQ   r14, #EventVState_AntiTaping
        LDR     r0, VSyncCount
        SUBEQS  r0, r0, #1                      ; if anti-taping, decrement vsync count
        STR     r0, VSyncCount
        ORREQ   r2, r2, #EventVState_Modulate   ; only modulate if anti-taping and count has reached zero

        LDR     r14, IICBusyFlag
        TST     r2, #EventVState_Switching      ; if a path switch is pending
        TEQNE   r14, #1                         ; and foreground isn't doing IIC_Control,
        ORRNE   r2, r2, #EventVState_OKToSwitch ; then note we can do a path switch this time (rather than defer it)

        TST     r2, #EventVState_Captioning     ; if not captioning,
        TEQNE   r14, #1                         ; or foreground is already doing an IIC_Control,
        BEQ     %FT10                           ; don't bother checking FIFOs

      [ BigFIFOs
        ADRL    r14, CaptionFIFO + FIFO_ReadPtr
        LDR     r0, [r14]
        ADRL    r14, CaptionFIFO + FIFO_WritePtr
        LDR     r1, [r14]
      |
        LDR     r0, CaptionFIFO + FIFO_ReadPtr
        LDR     r1, CaptionFIFO + FIFO_WritePtr
      ]
        TEQ     r0, r1                          ; NE => there is data in the FIFO
        ADREQL  r14, SAA7183IICMap + &67
        LDREQB  r0, [r14], #1
        TEQEQ   r0, #&80
        LDREQB  r0, [r14]
        TEQEQ   r0, #&80                        ; now also NE if we need to send terminating nulls
        ORRNE   r2, r2, #EventVState_CaptionWaiting

      [ BigFIFOs
        ADRL    r14, ExtDataFIFO + FIFO_ReadPtr
        LDR     r0, [r14]
        ADRL    r14, ExtDataFIFO + FIFO_WritePtr
        LDR     r1, [r14]
      |
        LDR     r0, ExtDataFIFO + FIFO_ReadPtr
        LDR     r1, ExtDataFIFO + FIFO_WritePtr
      ]
        TEQ     r0, r1                          ; NE => there is data in the FIFO
        ADREQL  r14, SAA7183IICMap + &69
        LDREQB  r0, [r14], #1
        TEQEQ   r0, #&80
        LDREQB  r0, [r14]
        TEQEQ   r0, #&80                        ; now also NE if we need to send terminating nulls
        ORRNE   r2, r2, #EventVState_ExtDataWaiting

10      STR     r2, EventVState
        TST     r2, #EventVState_Modulate :OR: EventVState_CaptionWaiting :OR: EventVState_ExtDataWaiting :OR: EventVState_OKToSwitch
        EXIT    EQ                              ; don't bother with switching to SVC mode if nothing to do

        MOV     r3, r2
        MOV     r4, pc
        ORR     r0, r4, #SVC_mode               ; switch to SVC_mode, so we can save lr_svc
        TEQP    r0, #0
        NOP
        Push    "lr"

        ; Do blanking/switching/unblanking at highest priority, to avoid glitches
        LDRB    r14, SwitchState
        TEQ     r14, #1                         ; if waiting to blank (which may be followed by a switch on the same VSync)
        MVN     r0, r3
        TSTEQ   r0, #EventVState_OKToSwitch     ; and it's okay to switch
        BLEQ    DoCaptionSwitchBlank            ; then do so
        LDRB    r14, SwitchState
        TEQ     r14, #2                         ; if waiting to switch paths (including if we just blanked)
        MVN     r0, r3
        TSTEQ   r0, #EventVState_OKToSwitch     ; and it's okay to switch (this will be faked to false if we just turned transparent)
        BLEQ    DoCaptionSwitchSwitch           ; then do so
        LDRB    r14, SwitchState
        TEQ     r14, #3                         ; if waiting to unblank (including if we just did the switch)
        BLEQ    DoCaptionSwitchUnblank          ; then see if we've waited enough fields yet

        TST     r3, #EventVState_Modulate
        MOVNE   r0, #1
        STRNE   r0, EventVCallbackRequested
        ADRNE   r0, EventVCallback
        MOVNE   r1, wp
        SWINE   XOS_AddCallBack

        TST     r3, #EventVState_CaptionWaiting :OR: EventVState_ExtDataWaiting
        SUB     sp, sp, #4
        MOVNE   r0, #IICDevice_SAA7183 :OR: 1   ; read from device
        MOVNE   r1, sp
        MOVNE   r2, #4
        SWINE   XIIC_Control
        Pull    "r2"                            ; r2 now contains SAA7183 status byte in bits 0-7

      [ {FALSE}                                 ; debug code
        Push    "r0,r1"
        ADR     r0, printdebug
        AND     r1, r3, #&FF
        ORR     r1, r1, r2, LSL #8
        TST     r3, #EventVState_CaptionWaiting :OR: EventVState_ExtDataWaiting
        SWINE   XOS_AddCallBack
        Pull    "r0,r1"
      ]

        TST     r3, #EventVState_CaptionWaiting ; if caption data waiting
        TSTNE   r2, #1 :SHL: 4                  ; and previous caption bytes have been encoded by SAA7183
        BLNE    SendCaptionBytes

        TST     r3, #EventVState_ExtDataWaiting ; if extended data waiting
        TSTNE   r2, #1 :SHL: 3                  ; and previous extended data bytes have been encoded by SAA7183
        BLNE    SendExtDataBytes

        Pull    "lr"
        TEQP    r4, #0                          ; restore old mode
        NOP
        EXITS

      [ {FALSE}
printdebug
        Entry
        TST     r12, #EventVState_CaptionWaiting
        BEQ     %FT01
        DLINE   "CC Wt   ", cc
        B       %FT02
01
        DLINE   "        ", cc
02      TST     r12, #EventVState_ExtDataWaiting
        BEQ     %FT01
        DLINE   "EDS Wt  ", cc
        B       %FT02
01
        DLINE   "        ", cc
02      TST     r12, #1:SHL:12
        BEQ     %FT01
        DLINE   "CC CTS  ", cc
        B       %FT02
01
        DLINE   "        ", cc
02      TST     r12, #1:SHL:11
        BEQ     %FT01
        DLINE   "EDS CTS "
        B       %FT02
01
        DLINE   "        "
02
        EXITS
      ]
      |
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	EXIT	NE

; it's vsync time, and we're not waiting around for a callback that hasn't gone off yet

	LDR	r0, VSyncCount			; decrement vsync count
	SUBS	r0, r0, #1
	STR	r0, VSyncCount
	EXIT	NE				; if not zero, don't bother with a callback

	MOV	r2, pc
	ORR	r0, r2, #SVC_mode		; switch to SVC_mode, so we can save lr_svc
	TEQP	r0, #0
	NOP

	Push	"lr"
	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"lr"

	TEQP	r2, #0				; restore old mode
	NOP

	MOV	r0, #1
	STR	r0, EventVCallbackRequested
	EXIT
      ]

; Remove any outstanding PaletteV or EventV callbacks
; Assumes that noone is trying to generate any more of them!

RemoveCallbacks Entry "r0-r2"
      [ :LNOT: NewColourScheme
	LDR	r0, PaletteVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT10

        MOV     r0, #0
        STR     r0, PaletteVCallbackRequested
	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
10
      ]
	LDR	r0, EventVCallbackRequested
	TEQ	r0, #0
	BEQ	%FT20

        MOV     r0, #0
        STR     r0, EventVCallbackRequested
	ADR	r0, EventVCallback
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
20
	EXIT

; ******************************************************************************************************
;
;       EventVCallback - Routine to adjust software modulated parameters on callback from vsync
;
; in:   SVC mode, interrupts enabled
; out:  -
;

EventVCallback	Entry "r0-r3"

	LDR	r2, AGCModulationPosition
	LDR	r3, [r2], #4
	ADRL	r1, AGCModulationTableEnd	; if got to end position
	TEQ	r2, r1
	ADREQL	r2, AGCModulationTableStart	; go back to start
	STR	r2, AGCModulationPosition

	MOV	lr, r3, LSR #AGCBitShift_Fields	; top 16 bits = next loop count
	STR	lr, VSyncCount

; now check we're inside VIDC display area (ie outside lines with AGC pulses)

	MOV	r0, #IOC
10
	LDRB	lr, [r0, #IOCControl]		; read "IOC Control Register"
	TST	lr, #vsync_state_bit
	BNE	%BT10				; wait for it to go low (ie outside flyback)

	MOV	r0, #SubAddress_PULM		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_PULM
	MOVNE	r1, #BitMask_PULM		; r1 = 0 or BitMask_PULM
	MOV	r2, #BitMask_PULM		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCFB		; r0 = sub-address
	ANDS	r1, r3, #AGCBitMask_AGCFB
	MOVNE	r1, #BitMask_AGCFB		; r1 = 0 or BitMask_AGCFB
	MOV	r2, #BitMask_AGCFB		; r2 = bits to change
	BL	ModulateBits

	MOV	r0, #SubAddress_AGCL		; r0 = sub-address
	AND	r1, r3, #AGCBitMask_AGCL
	MOV	r2, #BitMask_AGCL
	BL	ModulateBits

	MOV	lr, #0
	STR	lr, EventVCallbackRequested
	EXIT

; ******************************************************************************************************
;
;	ModulateBits - Modulate register bits in SAA7183
;
; in:	r0 = sub-address to change
;	r1 = new bits
;	r2 = mask of bits to change
;
; out:	-
;

ModulateBits Entry "r0-r3"
	ORR	lr, lr, #I_bit
	TEQP	lr, #0				; IRQs off

	ADR	lr, SAA7183IICMap
	LDRB	r3, [lr, r0]
	BIC	r3, r3, r2
	ORR	r3, r3, r1
	STRB	r3, [lr, r0]

	STRB	r0, TempModulationBlock +0
	STRB	r3, TempModulationBlock +1

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, TempModulationBlock
	MOV	r2, #2				; send sub-address + 1 data byte
      [ Captions
        MyIIC_Control
      |
	SWI	XIIC_Control
      ]
	EXITS					; exit restoring IRQ status

; ******************************************************************************************************
;
;       MyPaletteV - My PaletteV handler
;
; in:   r4 = reason code
;
; out:  depends on r4
;

        ASSERT  paletteV_Complete = 0
        ASSERT  paletteV_Read = 1
        ASSERT  paletteV_Set = 2
        ASSERT  paletteV_1stFlashState = 3
        ASSERT  paletteV_2ndFlashState = 4
        ASSERT  paletteV_SetDefaultPalette = 5
        ASSERT  paletteV_BlankScreen = 6

MyPaletteV ENTRY "r0-r3"
 [ {FALSE}
	MOV	r0, #&81
	MOV	r1, #&FD
	MOV	r2, #&FF
	SWI	XOS_Byte
	TEQ	r1, #0
	LDMFD	r13, {r0-r3}
	BEQ	%FT10
	DREG	r4, "PaletteV reason "
10
 ]
      [ NewColourScheme
        STR     lr, [sp, #-8]!
        LDR     lr, MacroType
        TEQ     lr, #1
        TEQNE   lr, #2
        ADREQ   lr, Path1PVTable
        ADRNE   lr, Path2PVTable
        CMP     r4, #paletteV_GammaCorrection
        ADDLS   lr, lr, r4, LSL#2
        STR     lr, [sp, #4]
        Pull    "lr, pc"        ; restore entry lr, and branch into jump table

Path2PVTable
        B       PassOnExit
        B       PV_ReadPalette
        B       PV_SetPalette
        B       PassOnExit
        B       PassOnExit
        B       PV_SetDefaultPalette
        B       PassOnExit
        B       PV_BulkRead
        B       PV_BulkWrite
        B       PassOnExit

Path1PVTable
        B       ClaimExit_NotSupported
        B       PV_ReadPalette_Macro
        B       PV_SetPalette_Macro
        B       PV_1stFlashState_Macro
        B       PV_2ndFlashState_Macro
        B       PV_SetDefaultPalette_Macro
        B       PV_BlankUnblank_Macro
        B       PV_BulkRead_Macro
        B       PV_BulkWrite_Macro
        B       PV_GammaCorrect_Macro

      |
        CMP     r4, #paletteV_Read
        BCC     PassOnExit                      ; paletteV_Complete
        BEQ     PV_ReadPalette                  ; paletteV_Read
        CMP     r4, #paletteV_1stFlashState
        BCC     PV_SetPalette                   ; paletteV_Set
        BEQ     PV_1stFlashState                ; paletteV_1stFlashState
        CMP     r4, #paletteV_SetDefaultPalette
        BCC     PV_2ndFlashState                ; paletteV_2ndFlashState
        BEQ     PV_SetDefaultPalette            ; paletteV_SetDefaultPalette
        CMP     r4, #paletteV_BulkRead
        BCC     PV_BlankUnblank                 ; paletteV_BlankScreen
	BEQ	PV_BulkRead                     ; paletteV_BulkRead
	B	ClaimExit_NotSupported

PV_1stFlashState
PV_2ndFlashState
PV_BlankUnblank
      ]
ClaimExit_Supported
        MOV     r4, #paletteV_Complete
ClaimExit_NotSupported
        PullEnv
        Pull    pc
PassOnExit
        EXIT


 [ NewColourScheme

GetVduVariables
; Fills in ModeFlags and NColour
        Entry   "r0-r2"
        MOV     r0, #0                  ; vdu variable ModeFlags
        MOV     r1, #3                  ; vdu variable NColour
        MOV     r2, #-1                 ; terminator
        Push    "r0-r2"                 ; create 3-word input block
        MOV     r0, sp
        ADR     r1, ModeFlags
        SWI     XOS_ReadVduVariables
        ADD     sp, sp, #4*3
        EXIT


; ####################
; NON-MACROVISION PATH
; ####################

; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16/17/18 (read normal colour, both flash states returned in each case)
;            24 (read border colour)
;            25 (read cursor colour)
;       R4 = 1 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;       R2 (stacked) = first flash setting   (BBGGRRTT)
;       R3 (stacked) = second flash setting  (BBGGRRTT)
;

PV_ReadPalette ROUT
        Push    "r10-r12"

        ; Special case pointer colours: read them from our cache
        TEQ     r1, #25
        BNE     %FT20
        ADR     r2, PointerPalette
        LDR     r2, [r2, r0, LSL#2]
        MOV     r3, r2
        B       %FT70

20      ; The kernel PaletteV ReadPalette handler doesn't return most of the supremacy bits,
        ; but its BulkRead handler returns all four - so we convert all ReadPalette calls
        ; to BulkRead calls at this point. (The kernel bug is fixed in STB-400.)
        STR     r0, [sp, #-12]!
        MOV     r0, sp
        MOV     r1, #(16 :SHL: 24) :OR: 1
        ADD     r2, sp, #4
        ADD     r3, sp, #8
        MOV     r4, #paletteV_BulkRead

        ; Push a return address (PC + 12) onto the stack for actual claimant to return to
        STR     pc, [sp, #-4]!

        ; Having altered the stack, jump to the return address for passing on the call
        MOV     pc, lr

        NOP

        ; Get returned colours into r2 and r3, as though ReadPalette reason code had been used
        ADD     sp, sp, #4
        Pull    "r2,r3"

        ; Palette should now have been read; if it hasn't, then don't tamper with exit r2 or r3
        TEQ     r4, #paletteV_Complete
        BNE     %FT99

        ; Convert supremacy bits from hardware form to preferred form
        TST     r2, #&10
        BIC     r2, r2, #&FF            ; bits 0-7 clear for solid
        ORRNE   r2, r2, #&FF            ; bits 0-7 set for transparent
        TST     r3, #&10
        BIC     r3, r3, #&FF            ; bits 0-7 clear for solid
        ORRNE   r3, r3, #&FF            ; bits 0-7 set for transparent

70      ; Set up stacked r2,r3
        STR     r2, [sp, #4*3 + 8]
        STR     r3, [sp, #4*3 + 12]

        ; Restore r10-r12 to the values they had originally, and jump to the return
        ; address supplied for claiming the call
        Pull    "r10-r12"
        B       ClaimExit_Supported

99      ; Jumps here if there was any sort of error: claims vector, but doesn't mark
        ; operation as having been completed
        Pull    "r10-r12"
        CLRV
        MOV     r4, #paletteV_Read
        B       ClaimExit_NotSupported

; *****************************************************************************
;
;       PV_SetPalette - PaletteV set palette handler
;
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRTT
;     ( R3 not used, PRM 1-104 is wrong)
;       R4 = 2 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_SetPalette ROUT
        Push    "r10-r12"

        ; Need to keep a soft copy of the pointer palette - the kernel can't be relied upon
        ; because (a) single reads corrupt supremacy bits, and (b) bulk read can't be used for
        ; pointer colour 2 in 1bpp screen modes. Both bugs are fixed for STB-400.
        TEQ     r1, #25
        BNE     %FT10
        AND     r0, r0, #3              ; just in case
        ADR     r3, PointerPalette
        ADD     r3, r3, r0, LSL#2
        TST     r2, #&FF                ; if any of bits 0-7 in r2 are set,
        ORRNE   r2, r2, #&FF            ; set all of them (mirrors effect of writing then reading palette entry)
        STR     r2, [r3]

10      ; Convert supremacy bits as per hardware requirement
        TST     r2, #&FF
        BIC     r2, r2, #&FF            ; all ED lines low for solid
        ORRNE   r2, r2, #&10            ; ED[0] (only) high for transparent

        ; Push a return address (PC + 12) onto the stack for actual claimant to return to
        STR     pc, [sp, #-4]!

        ; Having altered the stack, jump to the return address for passing on the call
        MOV     pc, lr

        NOP

        ; Palette should now have been set; restore r10-r12 to the values they had
        ; originally, and jump to the return address supplied for claiming the call
        Pull    "r10-r12"
        B       ClaimExit_Supported

; *****************************************************************************
;
;	PV_BulkRead - PaletteV call to read section of palette
;
; in:	R0 = pointer to word aligned list of logical colours (words), or 0
;	R1 = type (bits 24..31) and number of colours (bits 0..23)
;	R2 = pointer to block for 1st flash state
;	R3 = pointer to block for 2nd flash state (or 0 for put both at R2)
;	R4 = 7 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_BulkRead ROUT
        Push    "r7,r8,r10-r12"
        MOV     r7, r1, LSR #24
        BIC     r8, r1, #&FF000000

        ; Special case pointer colours: read them from our cache
        TEQ     r7, #25
        BNE     %FT50
; r0 -> list of colours, or 0
; r1 = loop counter
; r2 -> first block
; r3 -> second block, or 0
; r4 -> soft copy of pointer palette
; r7 = colour number
; r8 = number of entries
; lr = palette entry
        MOV     r1, #0
        ADR     r4, PointerPalette
01      TEQ     r1, r8
        BEQ     %FT99
        TEQ     r0, #0                  ; get next colour number
        MOVEQ   r7, r1
        LDRNE   r7, [r0], #4
        AND     r7, r7, #3              ; just in case
        LDR     lr, [r4, r7, LSL#2]     ; get palette entry
        STR     lr, [r2], #4            ; store in first block
        TEQ     r3, #0                  ; store second copy (stupid API!)
        STRNE   lr, [r3], #4            ;   in second block
        STREQ   lr, [r2], #4            ;   or in same block if no second block specified
        ADD     r1, r1, #1
        B       %BT01

        ; Push a return address (PC + 12) onto the stack for actual claimant to return to
50      STR     pc, [sp, #-4]!

        ; Having altered the stack, jump to the return address for passing on the call
        MOV     pc, lr

        NOP

        ; Palette should now have been read; if it hasn't, then don't tamper with buffers
        TEQ     r4, #paletteV_Complete
        BNE     %FT99

        MOV     r10, #0
60
        TEQ     r7, #18                 ; do we need to fix the first flash colour?
        BEQ     %FT70
        LDR     r1, [r2]
        TST     r1, #&10
        BIC     r1, r1, #&FF            ; bits 0-7 clear for solid
        ORRNE   r1, r1, #&FF            ; bits 0-7 set for transparent
        STR     r1, [r2], #4
70
        TEQ     r7, #17                 ; do we need to fix the second flash colour?
        BEQ     %FT80
        TEQ     r7, #16
        TEQNE   r7, #24
        TEQNE   r7, #25
        TEQEQ   r3, #0
        LDRNE   r1, [r3]
        LDREQ   r1, [r2]
        TST     r1, #&10
        BIC     r1, r1, #&FF            ; bits 0-7 clear for solid
        ORRNE   r1, r1, #&FF            ; bits 0-7 set for transparent
        TEQ     r7, #16
        TEQNE   r7, #24
        TEQNE   r7, #25
        TEQEQ   r3, #0
        STRNE   r1, [r3], #4
        STREQ   r1, [r2], #4
80
        ADD     r10, r10, #1
        CMP     r10, r8
        BCC     %BT60

99      ; Restore r7,r8,r10-r12 to the values they had originally, and jump to the
        ; return address supplied for claiming the call
        Pull    "r7,r8,r10-r12"
        B       ClaimExit_Supported

; *****************************************************************************

;       PV_BulkWrite - PaletteV call to set palette in bulk
; in:   R0 => list of colours, or 0
;       R1 =  colour type (16,17,18,24,25) in b24-31 & number to do in b23-b00
;       R2 => list of palette entries (both flash states if 16, one if 17/18/24/25)
;       R4 = 8 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_BulkWrite ROUT
        Push    "r5-r6,r10-r12"

        ; Create another palette block, but with supremacy bits as per hardware requirement
        MOV     r3, r1, LSR #24
        BIC     r5, r1, #&FF000000
        CMP     r5, #256                ; refuse to do more than 256 palette entries
        MOVGT   r5, #256                ;   (that's all we've got space for)
        ORR     r1, r5, r3, LSL #24     ; recreate a suitable r1
        TEQ     r3, #16                 ; are there are two entries for each colour?
        MOVEQ   r5, r5, LSL #1          ; multiply by two if necessary
        Push    "lr"
        TEQ     r3, #25                 ; if it's a pointer colour bulk-write,
        BLEQ    copy_pointer_palette    ;   cache the details
        Pull    "lr"
        MOV     r3, r2                  ; we need the original block to copy from
        ADR     r2, BulkWriteBlock      ; point r2 at 2K of workspace
        MOV     r6, r2                  ; initialise roving pointer into our block

        ; Register usage:
        ; r2 -> our block
        ; r3 -> original block
        ; r5  = palette entry counter
        ; r6 -> our block
        ; r12 = scratch register
10      LDR     r12, [r3], #4
        TST     r12, #&FF
        BIC     r12, r12, #&FF          ; all ED lines low for solid
        ORRNE   r12, r12, #&10          ; ED[0] (only) high for transparent
        STR     r12, [r6], #4
        SUBS    r5, r5, #1
        BNE     %BT10

        ; Push a return address (PC + 12) onto the stack for actual claimant to return to
        STR     pc, [sp, #-4]!

        ; Having altered the stack, jump to the return address for passing on the call
        MOV     pc, lr

        NOP

        ; Palette should now have been set; restore r5-r6,r10-r12 to the values
        ; they had originally and jump to the return address supplied for claiming the call
        Pull    "r5-r6,r10-r12"
        B       ClaimExit_Supported

copy_pointer_palette
; in:   r0 -> list of colours, or 0
;       r2 -> list of palette entries
;       r5 = number of entries
; used: r1 = loop counter
;       r3 = colour number
;       r4 -> soft copy of pointer palette
;       lr = palette entry
; out:  all registers preserved
        Entry   "r0-r4"
        MOV     r1, #0
        ADR     r4, PointerPalette
01      TEQ     r1, r5
        EXIT    EQ
        TEQ     r0, #0          ; get next colour number
        MOVEQ   r3, r1
        LDRNE   r3, [r0], #4
        LDR     lr, [r2], #4    ; get next palette entry
        TST     lr, #&FF        ; if any of bits 0-7 are set,
        ORRNE   lr, lr, #&FF    ; set all of them
        AND     r3, r3, #3      ; just in case
        STR     lr, [r4, r3, LSL#2]
        ADD     r1, r1, #1
        B       %BT01

; *****************************************************************************
;
;       PV_SetDefaultPalette - PaletteV call to set default palette
;
; in:   R4 = 5 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_SetDefaultPalette ROUT
        Push    "r10-r12"

        ; Push a return address (PC + 12) onto the stack for actual claimant to return to
        STR     pc, [sp, #-4]!

        ; Having altered the stack, jump to the return address for passing on the call
        MOV     pc, lr

        NOP

        ; Palette should now have been set to default; if it hasn't, then don't dontinue with next stage
        TEQ     r4, #paletteV_Complete
        BNE     %FT99

        LDMIA   sp, {r10-r12}           ; restore vector environment
        BL      GetVduVariables         ; fill in ModeFlags

        LDR     r0, ModeFlags
        TST     r0, #2                  ; bit 1 is Teletext mode flag
        BEQ     %FT98                   ; for all modes other than 7, we've already finished

        ; We've redefined the default palette for MODE 7 from STB-400 onwards to be fully solid -
        ; the next bit of code is sufficient to achieve the same effect on earlier STBs

        MOV     r0, #0
        MOV     r1, #16 :SHL: 24        ; set both flash states together
        ORR     r1, r1, #16             ; set all 16 palette entries
        ADRL    r2, defaultpal_special
        MOV     r4, #paletteV_BulkWrite

        STR     pc, [sp, #-4]!          ; push claimant return address onto stack
        LDR     pc, [sp, #4*8]          ; goto pass-on (skip pc,r10-r12,r0-r3)
        NOP

        TEQ     r4, #paletteV_Complete  ; BulkWrite successful?
        BNE     %FT99

98      ; Restore r10-r12 to the values they had originally, and jump to the return
        ; address supplied for claiming the call
        Pull    "r10-r12"
        B       ClaimExit_Supported

99      ; Jumps here if there was any sort of error: claims vector, but doesn't mark
        ; operation as having been completed
        Pull    "r10-r12"
        CLRV
        MOV     r4, #paletteV_SetDefaultPalette
        B       ClaimExit_NotSupported



; ################
; MACROVISION PATH
; ################

; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16/17/18 (read normal colour, both flash states returned in each case)
;            24 (read border colour)
;            25 (read cursor colour)
;       R4 = 1 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;       R2 (stacked) = first flash setting   (BBGGRRTT)
;       R3 (stacked) = second flash setting  (BBGGRRTT)
;

PV_ReadPalette_Macro ROUT
        BL      GetVduVariables
        LDR     lr, NColour

        AND     r2, r0, lr              ; restrict logical colour to appropriate range
        AND     r2, r2, #15             ; and in any case, to the range 0-15

        TEQ     r1, #24                 ; or if requesting border colour
        MOVEQ   r2, #16                 ; use index 16

        TEQ     r1, #25                 ; or if requesting pointer colour
        ANDEQ   r2, r0, #3
        ADDEQ   r2, r2, #16             ; use index 17-19 as appropriate

        ADR     lr, ApparentPalette2    ; load settings from our copy of the palette
        LDR     r3, [lr, r2, LSL#2]
        ADR     lr, ApparentPalette1
        LDR     r2, [lr, r2, LSL#2]

        STMIA   sp, {r0-r3}             ; write over stack

        B       ClaimExit_Supported

; *****************************************************************************
;
;       PV_SetPalette - PaletteV set palette handler
;
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRRTT
;     ( R3 not used, PRM 1-104 is wrong)
;       R4 = 2 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_SetPalette_Macro ROUT
        ; Get the VDU variables we'll need later
        BL      GetVduVariables

        ; Now see which type of colour we're updating
        TEQ     r1, #16                 ; if 16 then set both colours
        MOVEQ   r1, #3
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #17                 ; elif 17 then set 1st colour
        MOVEQ   r1, #1
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #18                 ; elif 18 then set 2nd colour
        MOVEQ   r1, #2
        BEQ     Call_UpdateNormalColour

        TEQ     r1, #24                 ; elif 24 then border colour
        BEQ     Call_UpdateBorderColour

        TEQ     r1, #25                 ; elif 25 then pointer colour
        BEQ     Call_UpdatePointerColour

        B       ClaimExit_NotSupported

Call_UpdateNormalColour
        BL      UpdateNormalColour
        BL      CalculateHardwarePalette
        BL      ApplyHardwarePalette
        BL      SetDENCPalette
        B       ClaimExit_Supported

Call_UpdateBorderColour
        BL      UpdateBorderColour
        BL      CalculateHardwarePalette
        BL      ApplyHardwarePalette
        B       ClaimExit_Supported

Call_UpdatePointerColour
        BL      UpdatePointerColour
        BL      CalculateHardwarePalette
        BL      ApplyHardwarePalette
        B       ClaimExit_Supported

UpdateNormalColour
        Entry
        LDR     lr, NColour
        AND     r0, r0, lr              ; restrict logical colour to appropriate range
        AND     r0, r0, #15             ; and in any case, to the range 0-15
        BL      UpdateColour
        EXIT

UpdateBorderColour
        Entry
        MOV     r0, #16                 ; border is 16th position in our tables
        MOV     r1, #3                  ; always set both flash states the same
        BL      UpdateColour
; In modes 3 and 6, colour 2 matches the border, and colour 3 is its inverse
        LDR     lr, ModeFlags
        TST     lr, #8                  ; bit 3 is BBC gap mode flag
        EXIT    EQ
        MOV     r0, #2
        BL      UpdateColour
        MOV     r0, #3
        MVN     r2, r2                  ; invert bits 8-31 only
        EOR     r2, r2, #&FF            ;
        BL      UpdateColour
        EXIT

UpdatePointerColour
        Entry
        ANDS    r0, r0, #3
        EXIT    EQ                      ; pointer colour 0 can't be changed
        ADD     r0, r0, #16             ; pointer colours are indices 17-19 in our tables
        MOV     r1, #3                  ; always set both flash states the same
        BL      UpdateColour
        EXIT

UpdateColour
; r1 bit 0 => set first flash colour, r1 bit 1 => set second flash colour
        Entry
        ; Convert to preferred supremacy form
        TST     r2, #&FF
        BIC     r2, r2, #&FF
        ORRNE   r2, r2, #&FF
        ; Store in one or both flash-state tables
        TST     r1, #1
        ADRNE   lr, ApparentPalette1
        STRNE   r2, [lr, r0, LSL#2]
        TST     r1, #2
        ADRNE   lr, ApparentPalette2
        STRNE   r2, [lr, r0, LSL#2]
        EXIT

CalculateHardwarePalette
; Recalculates HardwarePalette1 and HardwarePalette2
        Entry   "r4-r11"                        ; r5-r11 are corrupted by best_colour
        ADR     r0, ApparentPalette1            ; r0,r1 are required by best_colour:
        ADD     r1, r0, #4*8                    ;   everything has to be matched to to one of the first 8 first-flash logical colours
        MOV     r3, #0                          ; colour index, ranges 0-39 (colours 0-19 in each list are adjacent in memory)
        ADR     r4, HardwarePalette1
01      LDR     r2, [r0, r3, LSL#2]             ; get ApparentPalette entry
        TST     r2, #&FF                        ; if transparent
        MOVNE   r2, #1:SHL:3                    ; then "set" ED[3] bit
        BLEQ    best_colour                     ; else find index into 8-colour palette (which will have bit 3 clear)
        EOR     r2, r2, #1:SHL:3                ; invert ED[3] setting in either case, to suit hardware requirement
        STRB    r2, [r4, r3]                    ; write HardwarePalette entry
        ADD     r3, r3, #1
        CMP     r3, #40
        BCC     %BT01
        EXIT

ApplyHardwarePalette
; Applies the appropriate ED palette for the current flash state
        Entry
        LDR     lr, FlashState
        TEQ     lr, #1
        ADREQ   r3, HardwarePalette1
        ADRNE   r3, HardwarePalette2
        MOV     r0, #0
        MOV     lr, #VIDC
        MOV     r1, #&10000000
        STR     r1, [lr]                        ; initialise VIDC palette index to 0
02      LDRB    r1, [r3, r0]                    ; read HardwarePalette entry
        CMP     r0, #16                         ; if border or pointer colour
        ORRCS   r1, r1, #&40                    ;   then use VIDC address 4-7 instead of 0
        ORRCS   r1, r1, r0, LSL#4
        MOV     r1, r1, LSL#24                  ; shift up to top byte (leave RGB as all zero)
        STR     r1, [lr]
        ADD     r0, r0, #1
        CMP     r0, #20
        BCC     %BT02
        EXIT

SetDENCPalette
; Sets the DENC overlay colours to the first flash states of the first 8 logical colours
        Entry   "r4"
        MOV     r0, #0                           ; index into palette
        ADR     r1, ApparentPalette1
01      LDR     r2, [r1, r0, LSL#2]              ; get BBGGRRTT
        ADR     lr, GammaTables
        AND     r4, r2, #&0000FF00               ; r4 = 0000RR00
        LDRB    r4, [lr, r4, LSR#8]
        MOV     r3, r4, LSL#8                    ; r3 = gamma (0000RR00)
        ADD     lr, lr, #256
        AND     r4, r2, #&00FF0000               ; r4 = 00GG0000
        LDRB    r4, [lr, r4, LSR#16]
        ORR     r3, r3, r4, LSL#16               ; r3 = gamma (00GGRR00)
        ADD     lr, lr, #256
        AND     r4, r2, #&FF000000               ; r4 = BB000000
        LDRB    r4, [lr, r4, LSR#24]
        ORR     r2, r3, r4, LSL#24               ; r2 = gamma (BBGGRR00)
        BL      RGBToYUV                         ; in: r2 = BBGGRR00; out: r2 = 00VVUUYY
        MOV     lr, #3                           ; 3 bytes per palette entry
        MOV     r3, #SubAddress_OVL_LUT_Y0
        MLA     r3, r0, lr, r3                   ; index for Y component = OVL_LUT_Y0 + (index * 3)
        ADR     lr, SAA7183IICMap
        STRB    r2, [lr, r3]!                    ; store new Y component
        MOV     r2, r2, LSR #8
        STRB    r2, [lr, #1]                     ; store new U component
        MOV     r2, r2, LSR #8
        STRB    r2, [lr, #2]                     ; store new V component
        ADD     r0, r0, #1
        CMP     r0, #8
        BCC     %BT01
        BL      TransmitSAA7183Data
        EXIT

; The following snippets of code are pinched from ColourTrans, where they are documented more fully.

; -------- Start of ColourTrans code --------

        MACRO
$label  CompErr $error, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2

$label  SUBS    $temp2, $blue, $col, LSR #24
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        MUL     $error, $temp1, $bload       ; loading will be small
        ; $error contains blue term
        AND     $temp1, $col, #&FF0000       ; green component, still shifted
        SUBS    $temp2, $green, $temp1, LSR #16
        RSBLT   $temp2, $temp2, #0           ; |green error|
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $gload, $error
        ; $error contains blue+green
        AND     $temp1, $col, #&FF00         ; red component, still shifted
        SUBS    $temp2, $red, $temp1, LSR #8
        RSBLT   $temp2, $temp2, #0           ; |red error|
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $rload, $error
        MEND

        MACRO
$label  FindCol  $test, $list, $listend, $srccol, $load, $error, $red, $green, $blue, $rload, $gload, $bload, $col, $temp1, $temp2

        ; First extract the packed colour and load
$label  MOV      $blue, #255
        AND      $green, $blue, $srccol, LSR #16
        AND      $gload, $blue, $load, LSR #16
        AND      $red, $blue, $srccol, LSR #8
        AND      $rload, $blue, $load, LSR #8
        MOV      $blue, $srccol, LSR #24
        MOV      $bload, $load, LSR #24
        ;
        ; Loop round from the top of the table down
00      LDR      $col, [$listend, #-4]!
        CompErr  $load, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2
        CMP      $load, $error
        MOV$test $error, $load
        SUB$test $srccol, $listend, $list             ; index * 4
        CMP      $listend, $list
        BHI      %BT00
        MOV      $srccol, $srccol, LSR #2
        MEND

; -------- End of ColourTrans code --------

best_colour
;    R0  colour table start          PRESERVED
;    R1  colour table end +4         PRESERVED
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    R5-R11                          TRASHED
;    LR  return address              IN
;        used as a temporary         TRASHED
        Entry   "r1,r3,r4,r12"
        LDR     r3, =DefaultErrorLoading
        MOV     r4, #&FFFFFFFF                  ; initial error
        FindCol LS,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r14
        EXIT

DefaultErrorLoading     * &01040200
        LTORG

; *****************************************************************************
;
;       PV_1stFlashState - PaletteV routine to set first flash state
;
; in:   R4 = 3 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_1stFlashState_Macro ROUT
        MOV     r0, #1
        STR     r0, FlashState
        BL      ApplyHardwarePalette
        B       ClaimExit_Supported

; *****************************************************************************
;
;       PV_2ndFlashState - PaletteV routine to set second flash state
;
; in:   R4 = 4 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_2ndFlashState_Macro ROUT
        MOV     r0, #2
        STR     r0, FlashState
        BL      ApplyHardwarePalette
        B       ClaimExit_Supported

; *****************************************************************************
;
;       PV_SetDefaultPalette - PaletteV call to set default palette
;
; in:   R4 = 5 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_SetDefaultPalette_Macro ROUT
        BL      GetVduVariables

        LDR     lr, NColour
        CMP     lr, #15
        TEQCC   lr, lr                  ; now NE => 256 or more colours
        LDREQ   r0, ModeFlags
        TSTEQ   r0, #2                  ; bit 1 is Teletext mode flag
        ADRNE   r0, defaultpal_special  ; in teletext or >= 256-colour modes, we have 8 repeated non-flashing colours
        MOVNE   lr, #15                 ; but only do 16 palette entries in >= 256-colour modes (there are only 16 entries in the VIDC ED LUT)
        ADREQ   r0, defaultpal_4bpp     ; otherwise point at the 4bpp table, in case it was a normal 16-colour mode
        CMP     lr, #3
        ADRCC   r0, defaultpal_1bpp     ; 2-colour modes
        ADREQ   r0, defaultpal_2bpp     ; 4-colour modes
        MOVLS   lr, #7                  ; for either of these two, actually set up 8 entries so the remaining DENC colours are also determined

        ; Copy entries into ApparentPalette
        ADR     r1, ApparentPalette1
        ADR     r2, ApparentPalette2
01      LDR     r3, [r0], #4
        STR     r3, [r1], #4
        LDR     r3, [r0], #4
        STR     r3, [r2], #4
        SUBS    lr, lr, #1
        BPL     %BT01

        ; Border and pointer colours all default to solid black in every mode
        MOV     r2, #0
        BL      UpdateBorderColour
        MOV     r0, #1
        BL      UpdatePointerColour
        MOV     r0, #2
        BL      UpdatePointerColour
        MOV     r0, #3
        BL      UpdatePointerColour

        BL      CalculateHardwarePalette
        BL      ApplyHardwarePalette
        BL      SetDENCPalette
        B       ClaimExit_Supported

defaultpal_1bpp
        &       &00000000, &00000000    ; black
        &       &FFFFFF00, &FFFFFF00    ; white
        &       &0000FF00, &0000FF00    ; red     \
        &       &00FF0000, &00FF0000    ; green   |
        &       &00FFFF00, &00FFFF00    ; yellow  | other colours to program into the DENC
        &       &FF000000, &FF000000    ; blue    | (may be useful for pointer or border)
        &       &FF00FF00, &FF00FF00    ; magenta |
        &       &FFFF0000, &FFFF0000    ; cyan    /

defaultpal_2bpp
        &       &00000000, &00000000    ; black
        &       &0000FF00, &0000FF00    ; red
        &       &00FFFF00, &00FFFF00    ; yellow
        &       &FFFFFF00, &FFFFFF00    ; white
        &       &00FF0000, &00FF0000    ; green   \
        &       &FF000000, &FF000000    ; blue    | other colours to program into the DENC
        &       &FF00FF00, &FF00FF00    ; magenta | (may be useful for pointer or border)
        &       &FFFF0000, &FFFF0000    ; cyan    /

defaultpal_special
        &       &00000000, &00000000    ; black
        &       &0000FF00, &0000FF00    ; red
        &       &00FF0000, &00FF0000    ; green
        &       &00FFFF00, &00FFFF00    ; yellow
        &       &FF000000, &FF000000    ; blue
        &       &FF00FF00, &FF00FF00    ; magenta
        &       &FFFF0000, &FFFF0000    ; cyan
        &       &FFFFFF00, &FFFFFF00    ; white
        ; continues for the next 8 entries...
defaultpal_4bpp
        &       &00000000, &00000000    ; black
        &       &0000FF00, &0000FF00    ; red
        &       &00FF0000, &00FF0000    ; green
        &       &00FFFF00, &00FFFF00    ; yellow
        &       &FF000000, &FF000000    ; blue
        &       &FF00FF00, &FF00FF00    ; magenta
        &       &FFFF0000, &FFFF0000    ; cyan
        &       &FFFFFF00, &FFFFFF00    ; white
        &       &00000000, &FFFFFF00    ; black-white
        &       &0000FF00, &FFFF0000    ; red-cyan
        &       &00FF0000, &FF00FF00    ; green-magenta
        &       &00FFFF00, &FF000000    ; yellow-blue
        &       &FF000000, &00FFFF00    ; blue-yellow
        &       &FF00FF00, &00FF0000    ; magenta-green
        &       &FFFF0000, &0000FF00    ; cyan-red
        &       &FFFFFF00, &00000000    ; white-black

; *****************************************************************************
;
;       PV_BlankUnblank - PaletteV call to blank/unblank screen
;
; in:   R0 = -1 => read blank state
;       R0 = 0 => unblank screen
;       R0 = 1 => blank screen
;       R4 = 6 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;       R0 (stacked) = old state (0=unblanked, 1=blanked)
;

PV_BlankUnblank_Macro ROUT
        B       ClaimExit_NotSupported

; *****************************************************************************
;
;	PV_BulkRead - PaletteV call to read section of palette
;
; in:	R0 = pointer to word aligned list of logical colours (words), or 0
;	R1 = type (bits 24..31) and number of colours (bits 0..23)
;	R2 = pointer to block for 1st flash state
;	R3 = pointer to block for 2nd flash state (or 0 for put both at R2)
;	R4 = 7 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_BulkRead_Macro ROUT
        BL      GetVduVariables

        Push    "r7-r11"
        ;register usage:
        ;[r0] colour list, or 0
        ;[r2] palette entry block 1
        ;[r3] palette entry block 2, or 0
        ;r7   colour type
        ;r8   max number
        ;r9   mask to apply to normal logical colours
        ;r10  loop counter
        ;r11  colour number
        MOV     r7, r1, LSR #24
        BIC     r8, r1, #&FF000000
        LDR     r9, NColour
        AND     r9, r9, #15             ; map the first 16 colours repeatedly for higher-colour modes
        MOV     r10, #0
10
        TEQ     r0, #0
        MOVEQ   r11, r10
        LDRNE   r11, [r0], #4

        TEQ     r7, #24
        MOVEQ   r11, #0                 ; only one border colour exists
        TEQNE   r7, #25
        ANDEQ   r11, r11, #3            ; pointer logical colours are in range 1-3
        ADDEQ   r11, r11, #16           ; border colour is at offset 16, pointer colours at 17-19
        ANDNE   r11, r11, r9            ; other colours are masked according to NColour

        TEQ     r7, #18                 ; in all cases other than this, we must fill in the first flash colour
        ADRNE   lr, ApparentPalette1
        LDRNE   r1, [lr, r11, LSL #2]
        STRNE   r1, [r2], #4

        TEQ     r7, #17                 ; in all cases other than this, we must fill in the second flash colour
        BEQ     %FT20
        ADR     lr, ApparentPalette2
        LDR     r1, [lr, r11, LSL #2]
        TEQ     r7, #16
        TEQEQ   r3, #0
        STRNE   r1, [r3], #4            ; when two palette blocks are specified, or colour type is NOT 16
        STREQ   r1, [r2], #4            ; when one palette block is specified AND colour type is 16
20
        ADD     r10, r10, #1
        CMP     r10, r8
        BCC     %BT10

        Pull    "r7-r11"
        B       ClaimExit_Supported

; *****************************************************************************

;       PV_BulkWrite - PaletteV call to set palette in bulk
; in:   R0 => list of colours, or 0
;       R1 =  colour type (16,17,18,24,25) in b24-31 & number to do in b23-b00
;       R2 => list of palette entries (both flash states if 16, one if 17/18/24/25)
;       R4 = 8 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_BulkWrite_Macro ROUT
        ; Get the VDU variables we'll need later
        BL      GetVduVariables

        Push    "r6-r11"
        ;register usage:
        ;[r6] colour list
        ;r7   colour type
        ;r8   max number
        ;[r9] palette entries
        ;r10  loop counter
        ;r11  colour number

        MOV     r7,r1,LSR #24
        BIC     r8,r1,#&FF000000
        MOV     r6,r0
        MOV     r9,r2

        MOV     r10,#0
10
        TEQ     r6,#0
        MOVEQ   r11,r10
        LDRNE   r11,[r6],#4

        TEQ     r7,#16
        TEQNE   r7,#17

        MOVEQ   r0,r11
        MOVEQ   r1,#1
        LDREQ   r2,[r9],#4
        BLEQ    UpdateNormalColour

        TEQ     r7,#16
        TEQNE   r7,#18

        MOVEQ   r0,r11
        MOVEQ   r1,#2
        LDREQ   r2,[r9],#4
        BLEQ    UpdateNormalColour

        TEQ     r7,#24

        MOVEQ   r0,r11
        LDREQ   r2,[r9],#4
        BLEQ    UpdateBorderColour

        TEQ     r7,#25

        MOVEQ   r0,r11
        LDREQ   r2,[r9],#4
        BLEQ    UpdatePointerColour

        ADD     r10,r10,#1
        CMP     r10,r8
        BCC     %BT10

        BL      CalculateHardwarePalette
        BL      ApplyHardwarePalette
        CMP     r7, #18
        BLLS    SetDENCPalette          ; don't bother if we're just updating the border or pointer
        Pull    "r6-r11"
        B       ClaimExit_Supported

; *****************************************************************************
;
;       PV_GammaCorrect - PaletteV call to update gamma correction tables
;
; in:   R0 -> red table
;       R1 -> green table
;       R2 -> blue table
;       R4 = 9 (PaletteV reason code)
;
; out:  R0-R3 may be corrupted
;

PV_GammaCorrect_Macro ROUT
        ADR     r3, GammaTables
        ADD     r4, r3, #256
01      LDR     lr, [r0], #4
        STR     lr, [r3], #4
        TEQ     r3, r4
        BNE     %BT01

        ADD     r4, r4, #256
02      LDR     lr, [r1], #4
        STR     lr, [r3], #4
        TEQ     r3, r4
        BNE     %BT02

        ADD     r4, r4, #256
03      LDR     lr, [r2], #4
        STR     lr, [r3], #4
        TEQ     r3, r4
        BNE     %BT03

        BL      SetDENCPalette
        B       ClaimExit_Supported



 | ; ----------------- now the pre-NewColourScheme code -----------------------



; *****************************************************************************
;
;       PV_ReadPalette - PaletteV read palette handler
;
; in:   R0 = logical colour
;       R1 = 16 (read normal colour)
;            24 (read border colour)
;            25 (read cursor colour)
;
; out:  R2 = first flash setting   (BBGGRRS0), supremacy bit 7
;       R3 = second flash setting  (BBGGRRS0), supremacy bit 7
;

PV_ReadPalette ROUT
	MOV     r2, #0			; default value if duff (black)
	TEQ	r1, #16
	BNE	ReturnBlack		; not normal colour, so return 0
	CMP	r0, #8
	BCS	ReturnBlack
	ADR	lr, LogicalPalette
	LDR	r2, [lr, r0, LSL #2]	; look up in our soft copy
ReturnBlack
	STR	r2, [sp, #2*4]		; store in saved r2
	STR	r2, [sp, #3*4]		; and saved r3
	B	ClaimExit_Supported	; claim call and exit

; *****************************************************************************
;
;	PV_BulkRead - PaletteV read section of palette
;
; in:	R0 = pointer to word aligned list of logical colours (words), or 0
;	R1 = type (bits 24..31) and number of colours (bits 0..23)
;	R2 = pointer to block for 1st flash state
;	R3 = pointer to block for 2nd flash state (or 0 for put both at R2)
;	R4 = 7 (reason code)
;
; out:	R4 = 0 (if complete) or preserved if not

PV_BulkRead ROUT
	MOV	lr, r1, LSR #24
	TEQ	lr, #16
	BNE	ClaimExit_NotSupported	; not reading normal colours, so skip
	BICS	r1, r1, #&FF000000
	BEQ	ClaimExit_Supported	; all done!
	MOV	r4, #0			; current palette index
10
	TEQ	r0, #0			; if list of colours
	LDRNE	r4, [r0], #4		; then load palette index to use, else use r4
	CMP	r4, #8
	MOVCS	lr, #0			; out of range, use black
	ADRCC	lr, LogicalPalette
	LDRCC	lr, [lr, r4, LSL #2]	; else return entry in table
	STR	lr, [r2], #4		; store 1st copy
	TEQ	r3, #0			; if no 2nd table
	STREQ	lr, [r2], #4		; then use 1st for 2nd flash state too
	STRNE	lr, [r3], #4		; else use 2nd table
	ADD	r4, r4, #1		; increment palette index assuming no list of colours
	SUBS	r1, r1, #1
	BNE	%BT10
	B	ClaimExit_Supported

; *****************************************************************************

; PaletteV call to set palette
; in:   R0 = logical colour
;       R1 = colour type (16,17,18,24,25)
;       R2 = BBGGRR00
;       R4 = PaletteV reason code
;
; out:  R4 = 0, claim vector if recognised
;       otherwise preserve R4 and pass on
;

PV_SetPalette ROUT
        TEQ     r1, #16                 ; if 16 then set both colours
	BNE	ClaimExit_Supported	; not set normal colour, so exit

	AND	r0, r0, #&FF		; force colour number in range 0..255
	CMP	r0, #8			; only do anything with colours 0 to 7
        BLCC    UpdatePaletteSetting
	BLCC	TransmitSAA7183Data
        B       ClaimExit_Supported     ; indicate successful PaletteV op

UpdatePaletteSetting Entry
	ADR	lr, LogicalPalette
	STR	r2, [lr, r0, LSL #2]	; update our soft copy of palette
	BL	RGBToYUV		; in: r2 = BBGGRR00; out: r2 = 00VVUUYY
	MOV	lr, #3			; 3 bytes per palette entry
	MOV	r3, #SubAddress_OVL_LUT_Y0
	MLA	r3, r0, lr, r3		; index for Y component = OVL_LUT_Y0 + (index * 3)
	ADR	lr, SAA7183IICMap
	STRB	r2, [lr, r3]!		; store new Y component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #1]		; store new U component
	MOV	r2, r2, LSR #8
	STRB	r2, [lr, #2]		; store new V component
	EXITS

; *****************************************************************************
;
;       Set default palette - "R0-R3,LR" already saved

PV_SetDefaultPalette ROUT
	ADR	r0, VIDCProgTable
	ADR	r1, VIDCProgTableEnd
	MOV	r2, #VIDC
10
	LDR	lr, [r0], #4
	STR	lr, [r2]
	TEQ	r0, r1
	BNE	%BT10

	MOV	lr, #0
	MOV	r0, #256-16
15
	STR	lr, [r2]		; program colours 16 to 255 to black
	SUBS	r0, r0, #1
	BNE	%BT15

	ADR	r1, DefaultPaletteTable
	MOV	r0, #0
20
	LDR	r2, [r1], #4
	BL	UpdatePaletteSetting
	ADD	r0, r0, #1
	TEQ	r0, #8
	BNE	%BT20

	SWI	XColourTrans_InvalidateCache	; let ColourTrans know we have a different palette

	BL	TransmitSAA7183Data	; send all data

	BL	SetDefaultColours

        B       ClaimExit_Supported     ; claim vector

        LTORG

DefaultPaletteTable
	&	&00000000		; colour 0 (black)
	&	&55555500		; colour 1 (1/3 grey)
	&	&AAAAAA00		; colour 2 (2/3 grey)
	&	&FFFFFF00		; colour 3 (white)
	&	&0000FF00		; colour 4 (red)
	&	&00FF0000		; colour 5 (green)
	&	&00BBFF00		; colour 6 (orange)
	&	&FF000000		; colour 7 (blue)

		GBLA	Palette_Mask
 [ MacroRGB_Off
Palette_Mask	SETA	&ff000000
 |
Palette_Mask	SETA	&ffffffff
 ]

VIDCProgTable
	&	&10000000			; program palette index to 0
	&	&08000000:AND:Palette_Mask	; colour 0 (RGB bits irrelevant if you have the h/w)
	&	&09111111:AND:Palette_Mask	; colour 1
	&	&0A222222:AND:Palette_Mask	; colour 2
	&	&0B333333:AND:Palette_Mask	; colour 3
	&	&0C444444:AND:Palette_Mask	; colour 4
	&	&0D555555:AND:Palette_Mask	; colour 5
	&	&0E666666:AND:Palette_Mask	; colour 6
	&	&0F777777:AND:Palette_Mask	; colour 7
	&	&00888888:AND:Palette_Mask	; colour 8 (transparent)
	&	&00999999:AND:Palette_Mask	; colour 9 (ditto)
	&	&00AAAAAA:AND:Palette_Mask	; colour 10
	&	&00BBBBBB:AND:Palette_Mask	; colour 11
	&	&00CCCCCC:AND:Palette_Mask	; colour 12
	&	&00DDDDDD:AND:Palette_Mask	; colour 13
	&	&00EEEEEE:AND:Palette_Mask	; colour 14
	&	&00FFFFFF:AND:Palette_Mask	; colour 15
	&	&48000000:AND:Palette_Mask	; Border
	&	&59111111:AND:Palette_Mask      ; Pointer colour 1
	&	&6A222222:AND:Palette_Mask      ; Pointer colour 2
	&	&7B333333:AND:Palette_Mask      ; Pointer colour 3
VIDCProgTableEnd

; *****************************************************************************
;
;	SetDefaultColours - Request a callback to set default text/graphics colours
;
; in:	-
; out:	-

SetDefaultColours Entry "r0-r2"
	MOV	lr, pc
	ORR	lr, lr, #I_bit
	TEQP	lr, #0

	LDR	lr, PaletteVCallbackRequested
	TEQ	lr, #0
	EXITS	NE

	MOV	lr, #1
	STR	lr, PaletteVCallbackRequested

	ADR	r0, ReallySetDefaultColours
	MOV	r1, wp
	SWI	XOS_AddCallBack
	EXITS

ReallySetDefaultColours Entry "r0,r1"
	MOV	lr, #0
	STR	lr, PaletteVCallbackRequested

	LDR	r0, MacroType
	CMP	r0, #0			; if not in a macro mode any more, just quit
	CMPNE	r0, #3			; this mode also doesn't affect palette
	EXIT	EQ

	MOV	r0, #0
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set graphics foregd to colour 7

	MOV	r0, #&40
	MOV	r1, #DefaultForegroundColour
	SWI	XOS_SetColour		; set text foregd to colour 7

	EXIT

 ] ; end NewColourScheme switch

; *****************************************************************************
;
;	RGBToYUV - Convert RGB to YUV
;
; in:	r2 = BBGGRR00
;
; out:	r2 = 00VVUUYY in the format required by Macrovision palette

RGBToYUV Entry "r0,r3-r6"
	AND	lr, r2, #&FF00
	ADRL	r0, YUVTable
	LDR	r3, [r0, lr, LSR #6]	; RY
	ADD	r0, r0, #&400
	LDR	r4, [r0, lr, LSR #6]	; RU
	ADD	r0, r0, #&400
	LDR	r5, [r0, lr, LSR #6]	; RV

	AND	lr, r2, #&FF0000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GY
	ADD	r3, r3, r6		; RY+GY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GU
	ADD	r4, r4, r6		; RU+GU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #14]	; GV
	ADD	r5, r5, r6		; RV+GV

	AND	lr, r2, #&FF000000
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BY
	ADD	r3, r3, r6		; RY+GY+BY
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BU
	ADD	r4, r4, r6		; RU+GU+BU
	ADD	r0, r0, #&400
	LDR	r6, [r0, lr, LSR #22]	; BV
	ADD	r5, r5, r6		; RV+GV+BV

	ADD	r3, r3, #&80		; add on 1/2, before we round down
	MOV	r3, r3, ASR #8
	CMP	r3, #16			; limit Y to 16 to 235
	MOVLT	r3, #16
	CMP	r3, #235
	MOVGT	r3, #235
	EOR	r3, r3, #128		; toggle bit 7 as required

	ADD	r4, r4, #&80		; add on 1/2, before we round down
	MOV	r4, r4, ASR #8
	ADD	r4, r4, #128		; convert to Cr
	CMP	r4, #16			; limit Cr to 16 to 240
	MOVLT	r4, #16
	CMP	r4, #240
	MOVGT	r4, #240
	EOR	r4, r4, #128		; toggle bit 7 as required

	ADD	r5, r5, #&80		; add on 1/2, before we round down
	MOV	r5, r5, ASR #8
	ADD	r5, r5, #128		; convert to Cb
	CMP	r5, #16			; limit Cb to 16 to 240
	MOVLT	r5, #16
	CMP	r5, #240
	MOVGT	r5, #240
	EOR	r5, r5, #128		; toggle bit 7 as required

	ORR	r2, r3, r4, LSL #8
	ORR	r2, r2, r5, LSL #16
	EXIT

; *****************************************************************************
;
;	SelectVideoPath - Program TDA8540 and SAA7183 to select video path
;
; in:	r0 = MacroType - 0 => normal, 1 => macro OK to tape, 2 => macro anti-tape
;	r1 = TVStandard - 0 => PAL, 1 => NTSC
;
; out:	-
;

SelectVideoPath Entry "r0-r4"
	STR	r0, MacroType		; save away state, so we know where we are
 [ Captions
        STR     r0, NextMacroType       ; ensure NextMacroType = MacroType (cancels any pending caption mode switch)
 ]
	STR	r1, TVStandard

 [ ProgramCTRL1
	MOV	r0, #CardControlReason_UpdateControlRegister
	MOV	r1, #0
	MOV	r2, #-1
	SWI	XMPEGVideo_CardControl	; first read current state - and if control signals are both off, don't do anything
	TST	r1, #UpdateControlRegister_CTRL0 :OR: UpdateControlRegister_CTRL1
	BEQ	%FT10			; both off so don't disturb them

	LDMIA	sp, {r0, r1}		; reload r0 and r1
	TEQ	r0, #0			; is it normal mode
	MOVEQ	r1, #UpdateControlRegister_CTRL1 ; if so, then select RGB (CTRL1=1)
	MOVNE	r1, #0			; else select CVBS (CTRL1=0)
	MVN	r2, #UpdateControlRegister_CTRL1 ; only affect this pin
	MOV	r0, #CardControlReason_UpdateControlRegister
	SWI	XMPEGVideo_CardControl	; ignore any error from this SWI
10
 ]

	ADR	r0, TVOnString		; Check if the TV is on
	MOV	r1, #0
	MOV	r2, #-1
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal
	LDMIA	sp, {r0, r1}
	; r2 = 0 if we're in standby.  r2 < 0 otherwise.

 [ ForceMacroVideoPath
   	MOV	r0, #1			; Use macrovision video path
 |
	TEQ	r0, #0			; Check if it's a macrovision path
	; If r0 = 0 then use normal path (r0 = 0)
	MOVNE	r0, #1			; If so use macrovision TDA data
 ]
	TEQ	r2, #0
	MOVEQ	r0, #2			; Use the standby TDA data
        BL      Program_TDAs
	BVS	%FT90

 [ ExternalSyncGenerator
	LDMIA	sp, {r0,r1}		; reload parameters
	TEQ	r0, #0			; if not normal
	BNE	%FT20			; then program all regs

; is external sync gen, and is normal, so just program the outputs to off

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183OutputsOffData
	MOV	r2, #SAA7183OutputsOffDataEnd - SAA7183OutputsOffData
      [ Captions
        MyIIC_Control
      |
	SWI	XIIC_Control
      ]
	STRVS	r0, [sp]
	EXIT
20
 |
	LDMIA	sp, {r0,r1}		; reload parameters
 ]

; if we get here then is either macrovision mode, or normal but no external sync gen

	SUBS	r0, r0, #1		; go from 0,1,2 to -1,0,1
	MOVMI	r0, #0			; go from 0,1,2 to 0,0,1, since SAA7183 programming
					; is the same for normal and macro OK-to-tape
	TEQ	r1, #0
	ADDNE	r0, r0, #2		; add table offset for NTSC
	ADRL	lr, IICDataBlocks
	LDR	r0, [lr, r0, LSL #2]
	ADD	r0, r0, lr		; point at data block for this type of mode
	STR	r0, IICDataBlockPtr
	BL	SetupIICBlock

 [ ReadVarsForRCV2Timing
; Overwrite values in block from RCV2S and RCV2E variables
	BL	ProcessRCV2Vars		; also returns values in r0, r1, but we're not interested
 ]

 [ MacroRGB_Off
	; Byte &61 bit 7 set in macrovision mode to disable RGB
	LDR	r0, [sp]		; reload parameters
	CMP	r0, #0			; check if it's macrovision mode
	LDRNEB	r0, SAA7183IICMap + &61
	ORRNE	r0, r0, #&80		; Disable DACS in macrovision mode.
	STRNEB	r0, SAA7183IICMap + &61
 ]

 [ BINV_Var
	LDR	r2, [sp]		; Reload macrovision type
	CMP	r2, #2			; Check for anti-taping mode.
	BNE	%FT40			; If it isn't, don't touch anything.

	SUB	sp, sp, #4		; Save space on the stack

	ADRL	r0, MacroVarBINVName	; Read the system variable
	MOV	r1, sp
	MOV	r2, #4
	MOV	r3, #0
	MOV	r4, #0
	SWI	XOS_ReadVarVal

	LDRVC	r1, [sp]		; Get the variable value if there was no error.
	ANDVC	r1, r1, #1		; Keep only bit 0.
	LDRVCB	r0, SAA7183IICMap + &7d	; Get the byte to modify.
	BICVC	r0, r0, #1<<5		; Mask out the BINV bit.
	ORRVC	r0, r0, r1, ASL #5	; Put the bit from the variable into the byte.
	STRVCB	r0, SAA7183IICMap + &7d	; Write the byte back.

	ADD	sp, sp, #4		; Junk the space on the stack
40
 ]

	BL	TransmitSAA7183Data	; send all data to SAA7183

      [ Captions
        LDMIA   sp, {$Proc_RegList}     ; restore registers to state on entry
        BL      ClaimReleaseEventV
      |
	LDR	r0, MacroType
	TEQ	r0, #2			; are we anti-taping
	BLEQ	ClaimEventV		; if so, then start modulation
      ]
90
	STRVS	r0, [sp]
	EXIT

TVOnString	=	"TVOn", 0

Program_TDAs
; On entry: r0 = video path - 0 => normal, 1 => macrovision, 2 => standby
;           r1 = TVStandard - 0 => PAL, 1 => NTSC
; On exit: r0-r3 corrupted; error may be returned
        Entry
        ; Deal with TDA-1
        ASSERT  TDA8540_Data_Size = 4
        ADR	r3, TDA8540_Data
        LDR     lr, [r3, r0, LSL #2]!   ; get copy of TDA-1 IIC_Control block, without (M)odulator and (B)oost power control bits

 [ Have_Double_TDA
	ADR	r2, TDA8540IICData_PALon
	TEQ	r0, #2			; Check if it's standby
	ADDEQ	r2, r2, #1		; If so, use the off byte
	TEQ	r1, #0			; Check if it's NTSC
	ADDNE	r2, r2, #2		; If so, use NTSC data.
        LDRB    r0, [r2]                ; get appropriate "m" and "b" bits
        ORR     lr, lr, r0, LSL #16     ; add to second TDA-1 byte (third byte in IIC_Control block)
 ]

        Push    "lr"                    ; push customised block to stack
        MOV     r0, #IICDevice_TDA8540
        MOV     r1, sp                  ; r2 still set up from entry
        MOV	r2, #TDA8540_Data_Size
      [ Captions
        MyIIC_Control
      |
        SWI     XIIC_Control
      ]
        ADD     sp, sp, #4              ; skip pushed block
        EXIT    VS

 [ Have_Double_TDA
        ; Deal with TDA-2
	MOV	r0, #IICDevice_TDA8540_2
	ADD     r1, r3, #TDA8540_Data_Size*3
	MOV     r2, #TDA8540_Data_Size
      [ Captions
        MyIIC_Control
      |
	SWI	XIIC_Control
     ]
 ]
        EXIT

SAA7183OutputsOffData
	=	&6B		; sub-address to control RCV outputs
	=	&00		; disable outputs
SAA7183OutputsOffDataEnd
	ALIGN

 [ Have_Double_TDA
; IIC data blocks to set TDA8540 devices for each of the three video paths Standby, Non-Macrovision and Macrovision
TDA8540_Data

TDA8540NormalIICData
	=	0		; sub-address to start at
	=	4_3131
	=	2_11111100
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
	ASSERT	. = TDA8540NormalIICData + TDA8540_Data_Size

TDA8540MacroIICData             ; Used irrespective of anti-taping mode
	=	0		; sub-address to start at
	=	4_2020
	=	2_00001100
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
	ASSERT	. = TDA8540MacroIICData + TDA8540_Data_Size

TDA8540StandbyIICData
	=	0		; sub-address to start at
	=	4_0000
	=	2_11111100
	=	2_00000000	; Outputs OUT0 - OUT3 disabled
	ASSERT	. = TDA8540StandbyIICData + TDA8540_Data_Size

TDA8540NormalIICData_2
	=	0		; sub-address to start at
	=	4_2222
	=	2_11111100
	=	2_00000111	; Outputs OUT0, OUT1, OUT2 enabled, OUT3 disabled.
	ASSERT	. = TDA8540NormalIICData_2 + TDA8540_Data_Size

TDA8540MacroIICData_2
	=	0		; sub-address to start at
	=	4_0000
	=	2_10001000
	=	2_00000111	; Outputs OUT0, OUT1, OUT2 enabled, OUT3 disabled.
	ASSERT	. = TDA8540MacroIICData_2 + TDA8540_Data_Size

TDA8540StandbyIICData_2
	=	0		; sub-address to start at
	=	4_0000
	=	2_11111100
	=	2_00000000
	ASSERT	. = TDA8540StandbyIICData_2 + TDA8540_Data_Size

	ASSERT	. = TDA8540_Data+2*3*TDA8540_Data_Size

; Settings of Modulator and Boost power control bits for each combination of NTSC/PAL and SCART function-select pin
; These are bits 0 and 1 of the second byte addressed to TDA8540 #1.

TDA8540IICData_PALon   =  2_11  ; for when IOMD_CLINES = 2_xxx00xxx
TDA8540IICData_PALoff  =  2_01  ; for when IOMD_CLINES = 2_xxx01xxx
TDA8540IICData_NTSCon  =  2_10  ; for when IOMD_CLINES = 2_xxx10xxx
TDA8540IICData_NTSCoff =  2_01  ; for when IOMD_CLINES = 2_xxx11xxx

 |
TDA8540_Data

TDA8540NormalIICData
	=	0		; sub-address to start at
	=	4_3100		; OUT3 (output_Y) = IN3 (normal_Y)
				; OUT2 (output_C) = IN1 (normal_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001100	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 0 (normal CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
	ASSERT	. = TDA8540NormalIICData + TDA8540_Data_Size

TDA8540MacroIICData
	=	0		; sub-address to start at
	=	4_2000		; OUT3 (output_Y) = IN2 (macro_Y)
				; OUT2 (output_C) = IN0 (macro_C)
				; OUT1 = OUT0 = don't care (IN0)
	=	2_00001101	; Gain 2 on all outputs
				; Clamps off, D1 = 0 (don't care), D0 = 1 (macro CVBS, RGB, HCLK, HS, VS)
	=	2_00001100	; Outputs OUT2, OUT3 enabled, OUT0, OUT1 disabled
	ASSERT	. = TDA8540MacroIICData + TDA8540_Data_Size

TDA8540StandbyIICData
	=	0		; sub-address to start at
	=	4_0000
	=	2_11111100
	=	2_00000000	; Outputs OUT0 - OUT3 disabled
	ASSERT	. = TDA8540StandbyIICData + TDA8540_Data_Size

 ]
	ALIGN

CBENB		*	0	; Data from input ports, not just colour bars
DISKEY		*	0	; Overlay enabled
; FMT16	is now set in header file
Y2C		*	1	; Y data are straight binary (not 2's complement)
; UV2C is now set in header file

PAL_CHPS	*	&68	; Phase of encoded colour subcarrier for data from input ports
NTSC_CHPS	*	&82

Normal_DOWNB		*	0 ; RGB DACs on
; AntiTaping_DOWNB is now set in header file
DOWNA		*	0	; CVBS, Y, C DACs on
INPI		*	0	; Nominal PAL phase
RTCE		*	0	; No real time control of generated subcarrier frequency

PAL_YGS		*	0	; Luminance gain for White-Black = 100 IRE
NTSC_YGS	*	1	; Luminance gain for White-Black = 92.5 IRE

PAL_GAINU	*	&7D	; Variable gain for Cb
NTSC_GAINU	*	&76	; Variable gain for Cb

PAL_GAINV	*	&AF	; Variable gain for Cr
NTSC_GAINV	*	&A5	; Variable gain for Cr

PAL_BSTA	*	&4B	; Colour burst amplitude
NTSC_BSTA	*	&66	; Colour burst amplitude

PAL_BLCKL	*	&2D	; Black level
NTSC_BLCKL	*	&3C	; Black level

PAL_BLCKLA	*	&15	; Black level (anti-taping active)
NTSC_BLCKLA	*	&22	; Black level (anti-taping active)

PAL_BLNNL	*	&3F	; Blanking level
NTSC_BLNNL	*	&3A	; Blanking level

PAL_BLNNLA	*	&27	; Blanking level outside vsync (anti-taping active)
NTSC_BLNNLA	*	&20	; Blanking level outside vsync (anti-taping active)

PAL_BLNVB	*	&3F	; Blanking level during Vertical blanking interval
NTSC_BLNVB	*	&3A	; Blanking level during vsync

PAL_AGCL	*	&6F	; AGC Super White level (must be modulated by s/w)
NTSC_AGCL	*	&70	; AGC Super White level (must be modulated by s/w)

DECTYP		*	0	; Controls whether Real Time Control Input comes from SAA7151B or SAA7111
				; (in our case neither, so irrelevant)

SECAM		*	0	; Not SECAM
SCBW		*	1	; Standard bandwidth for Chrominance Encoding
PAL_FISE	*	0	; 864 total pixel clocks per line, not 858
NTSC_FISE	*	1	; 858 total pixel clocks per line, not 864

; PRCV2, SRCV1	now defined in header file
ORCV2		*	1	; HS output
CBLF		*	0	; HSync used in
PRCV1		*	0	; VS Active high
ORCV1		*	1	; VS output
TRCV2		*	1	; HSync from RCV2

SBLBN		*	1	; Vertical blanking forced according to CCIR-624 (50Hz) or RS170A (60Hz)
PHRES		*	2_00	; no reset of phase of colour subcarrier generator
FLC		*	2_00	; interlaced display

; RCV2S, RCV2E now defined in header file

PAL_N1		*	48	; First line with inverted burst in first group of field 1, ie lines 1 to 64
NTSC_N1		*	18
PAL_N2		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 1
NTSC_N2		*	20
PAL_N3		*	48	; First line with inverted burst in first group of field 2, ie lines 1 to 64
NTSC_N3		*	18
PAL_N4		*	32	; Spacing from 1st line with inverted burst in first group to 1st line in second group, field 2
NTSC_N4		*	29
PAL_N5		*	4	; Colour stripe group spacing (first line to first line) (16+N5 for NTSC, 12+N5 for PAL)
NTSC_N5		*	4
PAL_N6		*	3	; Number of colour stripes (groups) per field (6+N6)
NTSC_N6		*	4
PAL_N7		*	2	; Number of lines per colour stripe (group), 2+N7
NTSC_N7		*	2
PAL_BPp_follow	*	0	; Number of back porch pulses following V-sync pulse
NTSC_BPp_follow	*	0
PAL_BPp_prior	*	14	; Number of back porch pulses prior to V-sync pulse
NTSC_BPp_prior	*	6

PAL_FirstPseudoAGC	*	9	; First line with pseudo-sync pulse and AGC pulse
PAL_LastPseudoAGC	*	18	; Last line ....
PAL_AGCMask	*	(-1 << PAL_FirstPseudoAGC) :AND: :NOT: (-1 << (PAL_LastPseudoAGC+1))
PAL_AGCMask1	*	(PAL_AGCMask >> 14) :AND: &FF
PAL_AGCMask2	*	(PAL_AGCMask >> 7) :AND: &7F

NTSC_FirstPseudoAGC	*	12
NTSC_LastPseudoAGC	*	19
NTSC_AGCMask	*	(-1 << NTSC_FirstPseudoAGC) :AND: :NOT: (-1 << (NTSC_LastPseudoAGC+1))
NTSC_AGCMask1	*	(NTSC_AGCMask >> 14) :AND: &FF
NTSC_AGCMask2	*	(NTSC_AGCMask >> 7) :AND: &7F

DATM		*	0	; Data transmission mode enable (I don't know exactly what this does so don't enable it)

PAL_N8		*	4	; pseudo-sync pulse duration
NTSC_N8		*	3
PAL_N9		*	3	; location of 1st pseudo-sync pulse related to the leading edge of the H-sync pulse
NTSC_N9		*	2

PSSYNC_EN	*	1	; pseudo-sync pulses enabled

PAL_N10		*	3	; pseudo-sync pulse spacing
NTSC_N10	*	3
PULM		*	0	; pulsation mode enable (disabled for now, needs to be modulated by s/w)
p_count		*	5	; in state 'A', number of lines where AGC pulses are active (lines 9 to 13 inclusive)
tm_data		*	0	; transmission data, not used at present

MACRO		*	1	; Macrovision enabled
 [ BINV_Var
BINV		*	1	; Burst-inversion configured in software.  Default to enabled.
 |
BINV		*	0	; Burst-inversion disabled (Elmsdale don't want it)
 ]
AGCFB		*	1	; AGC pulses following pseudo-sync pulses enabled
AGCEQ		*	1 	; Ancillary AGC pulses enabled

	GBLA	NextBase
	GBLA	NextSectionStart
	MACRO
	NewSections
NextBase SETA	0
NextSectionStart SETA	-1
	MEND

	MACRO
	Section	$base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, $length
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr + ($length)
	MEND

	MACRO
	SectionZero $base, $length
	ASSERT	(($base) :AND: &FFFFFF80) = 0
	ASSERT	(($length) :AND: &FFFFFF80) = 0
	ASSERT	($base)+($length) <= &80
	ASSERT	($base) = NextBase
 [ NextSectionStart <> -1
	ASSERT	{PC}-Module_BaseAddr = NextSectionStart
 ]
	=	$base, ($length) :OR: &80
NextBase SETA	NextBase + ($length)
NextSectionStart SETA {PC}-Module_BaseAddr
	MEND

	MACRO
	SectionEnd
	ASSERT	NextBase = &80
	=	0, 0		; zero length indicates end
	MEND

	MACRO
	Normal_00_39
	SectionZero	0, &3A	; zero fill from 0 to &39
	MEND

	MACRO
	Common_3A_41
	Section	&3A, 1
	=	(CBENB<<7) :OR: (DISKEY<<6) :OR: (FMT16<<2) :OR: (Y2C<<1) :OR: (UV2C<<0)
	SectionZero	&3B, (&42-&3B)	; zero fill from &3B to &41
	MEND

	MACRO
	Palette_42_59
	Section &42, (&5A-&42)
	=	&90, &00, &00	; Black
	=	&A9, &70, &EE	; Blue
	=	&D1, &DA, &70	; Red
	=	&EA, &4A, &5E	; Magenta
	=	&11, &B6, &A2	; Green
	=	&2A, &26, &90	; Cyan
	=	&52, &90, &12	; Yellow
	=	&6B, &00, &00	; White
	MEND

	MACRO
	PAL_5A_5C
	Section	&5A, 3
	=	PAL_CHPS
	=	(PAL_GAINU :AND: &FF)
	=	(PAL_GAINV :AND: &FF)
	MEND

	MACRO
	NTSC_5A_5C
	Section	&5A, 3
	=	NTSC_CHPS
	=	(NTSC_GAINU :AND: &FF)
	=	(NTSC_GAINV :AND: &FF)
	MEND

	MACRO
	NormalPAL_5D_61
	Section	&5D, 5
	=	((PAL_GAINU :AND: &100)>>1) :OR: PAL_BLCKL
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNL<<0)
	=	PAL_BLNVB
	=	&00		; Null register (&60)
	=	(Normal_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (PAL_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (1<<1) :OR: PAL_FISE
	MEND

	MACRO
	NormalNTSC_5D_61
	Section	&5D, 5
	=	((NTSC_GAINU :AND: &100)>>1) :OR: NTSC_BLCKL
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNL<<0)
	=	NTSC_BLNVB
	=	&00		; Null register (&60)
	=	(Normal_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (NTSC_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (0<<1) :OR: NTSC_FISE
	MEND

	MACRO
	PAL_62_66
	Section	&62, (&67-&62)
	=	(RTCE<<7) :OR: (PAL_BSTA<<0)
	=	&CB, &8A, &09, &2A	; subcarrier frequency
	MEND


	MACRO
	NTSC_62_66
	Section	&62, (&67-&62)
	=	(RTCE<<7) :OR: (NTSC_BSTA<<0)
	=	&1F, &7C, &F0, &21	; subcarrier frequency
	MEND

 [ Captions
        MACRO
        PAL_67_6F
	Section	&67, (&70-&67)
	=	&00, &00, &00, &00	; no captioning or extended data
	=	(SRCV1<<6) :OR: (TRCV2<<5) :OR: (ORCV1<<4) :OR: (PRCV1<<3) :OR: (CBLF<<2) :OR: (ORCV2<<1) :OR: PRCV2
	=	&54			; HTRIG
	=	&02			; VTRIG??
	=	(SBLBN<<7) :OR: (PHRES<<4) :OR: FLC
	=	&00			; no line 21 encoding or teletext or closed caption or extended data
        MEND

        MACRO
        NTSC_67_6F
	Section	&67, (&70-&67)
	=	&80, &80, &80, &80	; output odd-parity zeroes by default
	=	(SRCV1<<6) :OR: (TRCV2<<5) :OR: (ORCV1<<4) :OR: (PRCV1<<3) :OR: (CBLF<<2) :OR: (ORCV2<<1) :OR: PRCV2
	=	&54			; HTRIG
	=	&02			; VTRIG??
	=	(SBLBN<<7) :OR: (PHRES<<4) :OR: FLC
	=	&D1			; both types of line 21 encoding but no teletext
        MEND

        MACRO
        Common_70_7C
        Section &70, (&73-&70)
	=	RCV2S :AND: &FF
	=	RCV2E :AND: &FF
	=	((RCV2E :AND: &700) :SHR: 4) :OR: ((RCV2S :AND: &700) :SHR: 8)
	SectionZero	&73, (&7D-&73)	; zero from &73 to &7C: no TTX stuff
        MEND
 |
	MACRO
	Common_67_7C
	Section	&67, (&73-&67)
	=	&00, &00, &00, &00	; no captioning or extended data
	=	(SRCV1<<6) :OR: (TRCV2<<5) :OR: (ORCV1<<4) :OR: (PRCV1<<3) :OR: (CBLF<<2) :OR: (ORCV2<<1) :OR: PRCV2
	=	&54			; HTRIG
	=	&02			; VTRIG??
	=	(SBLBN<<7) :OR: (PHRES<<4) :OR: FLC
	=	&00			; no line 21 encoding or teletext or closed caption or extended data
	=	RCV2S :AND: &FF
	=	RCV2E :AND: &FF
	=	((RCV2E :AND: &700) :SHR: 4) :OR: ((RCV2S :AND: &700) :SHR: 8)
	SectionZero	&73, (&7D-&73)	; zero from &73 to &7C: no TTX stuff
	MEND
 ]

	MACRO
	Normal_7D_7F
	SectionZero	&7D, (&80-&7D)
	MEND

	MACRO
	AntiTapingPAL_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	PAL_N1			; N1
	=	&00			; register 02 not used
	=	PAL_N2, PAL_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	PAL_N4
	=	(PAL_N7<<6) :OR: (PAL_N6<<3) :OR: (PAL_N5<<0)
	=	(PAL_BPp_prior<<4) :OR: (PAL_BPp_follow<<0)
	=	&00			; register 13 not used
	=	PAL_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: PAL_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (PAL_N9<<3) :OR: (PAL_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (PAL_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingNTSC_00_39
	Section	&00, (&05-&00)
	=	&00			; register 00 not used
	=	NTSC_N1			; N1
	=	&00			; register 02 not used
	=	NTSC_N2, NTSC_N3		; N2, N3
	SectionZero	&05, (&10-&05)
	Section &10, (&16-&10)
	=	NTSC_N4
	=	(NTSC_N7<<6) :OR: (NTSC_N6<<3) :OR: (NTSC_N5<<0)
	=	(NTSC_BPp_prior<<4) :OR: (NTSC_BPp_follow<<0)
	=	&00			; register 13 not used
	=	NTSC_AGCMask1			; this register and the next need to be modulated by s/w
	=	(DATM<<7) :OR: NTSC_AGCMask2
	SectionZero	&16, (&20-&16)
	Section	&20, (&23-&20)
	=	(PSSYNC_EN<<7) :OR: (NTSC_N9<<3) :OR: (NTSC_N8<<0)
	=	(p_count<<4) :OR: (PULM<<3) :OR: (NTSC_N10<<0)
	=	tm_data
	SectionZero	&23, (&3A-&23)
	MEND

	MACRO
	AntiTapingPAL_5D_61
	Section	&5D, (&62-&5D)
	=	((PAL_GAINU :AND: &100)>>1) :OR: (PAL_BLCKLA<<0)
	=	((PAL_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (PAL_BLNNLA<<0)
	=	PAL_BLNVB
	=	PAL_AGCL
	=	(AntiTaping_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (PAL_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (1<<1) :OR: PAL_FISE
	MEND

	MACRO
	AntiTapingNTSC_5D_61
	Section	&5D, (&62-&5D)
	=	((NTSC_GAINU :AND: &100)>>1) :OR: (NTSC_BLCKLA<<0)
	=	((NTSC_GAINV :AND: &100)>>1) :OR: (DECTYP<<6) :OR: (NTSC_BLNNLA<<0)
	=	NTSC_BLNVB
	=	NTSC_AGCL
	=	(AntiTaping_DOWNB<<7) :OR: (DOWNA<<6) :OR: (INPI<<5) :OR: (NTSC_YGS<<4) :OR: (SECAM<<3) :OR: (SCBW<<2) :OR: (0<<1) :OR: NTSC_FISE
	MEND

	MACRO
	AntiTaping_7D_7F
	Section	&7D, (&80-&7D)
	=	(AGCEQ<<7) :OR: (AGCFB<<6) :OR: (BINV<<5) :OR: (MACRO<<4)
	=	&00, &00	; locations &7E, &7F not used
	MEND

SAA7183MacroPAL0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	NormalPAL_5D_61
	PAL_62_66
 [ Captions
	PAL_67_6F
	Common_70_7C
 |
	Common_67_7C
 ]
	Normal_7D_7F
	SectionEnd

SAA7183MacroNTSC0IICData
	NewSections
	Normal_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	NormalNTSC_5D_61
	NTSC_62_66
 [ Captions
	NTSC_67_6F
	Common_70_7C
 |
	Common_67_7C
 ]
	Normal_7D_7F
	SectionEnd

SAA7183MacroPAL1IICData
	NewSections
	AntiTapingPAL_00_39
	Common_3A_41
	Palette_42_59
	PAL_5A_5C
	AntiTapingPAL_5D_61
	PAL_62_66
 [ Captions
	PAL_67_6F
	Common_70_7C
 |
	Common_67_7C
 ]
	AntiTaping_7D_7F
	SectionEnd

SAA7183MacroNTSC1IICData
	NewSections
	AntiTapingNTSC_00_39
	Common_3A_41
	Palette_42_59
	NTSC_5A_5C
	AntiTapingNTSC_5D_61
	NTSC_62_66
 [ Captions
	NTSC_67_6F
	Common_70_7C
 |
	Common_67_7C
 ]
	AntiTaping_7D_7F
	SectionEnd

	ALIGN

IICDataBlocks
	&	SAA7183MacroPAL0IICData - IICDataBlocks
	&	SAA7183MacroPAL1IICData - IICDataBlocks
	&	SAA7183MacroNTSC0IICData - IICDataBlocks
	&	SAA7183MacroNTSC1IICData - IICDataBlocks

; *****************************************************************************
;
;	SetupIICBlock - Transfer a compacted block of data into IIC block
;
; Format of compacted block is a series of bytes as follows:-
;
; <offset>, <length>, <byte_1>, <byte_2>, ..., <byte_length>
;	Store the following bytes at the given <offset>
; <offset>, <length> OR 128
;	Store zero for <length> bytes at given <offset>
; x, 0
;	Indicates end of block
;

; in:	r0 -> compacted block
;
; out:	-

SetupIICBlock Entry "r0-r3"
	ADR	r1, SAA7183IICMap
10
	LDRB	r2, [r0], #1		; get start offset
	LDRB	r3, [r0], #1		; get length and zeroing flag
	TEQ	r3, #0			; is it end of the table
	EXIT	EQ

	TST	r3, #&80		; are we zeroing
	BNE	%FT50

20
	LDRB	lr, [r0], #1
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT20
	B	%BT10

50
	BIC	r3, r3, #&80		; knock off zeroing flag
	MOV	lr, #0
60
	STRB	lr, [r1, r2]
	ADD	r2, r2, #1
	SUBS	r3, r3, #1
	BNE	%BT60
	B	%BT10

; *****************************************************************************
;
;	TransmitSAA7183Data - Transmit IIC data to SAA7183
;
; in:	-
; out:	If error, r0 -> error, VS

TransmitSAA7183Data Entry "r0-r2"
	MOV	r0, #IICDevice_SAA7183
	ADR	r1, SAA7183IICData
	MOV	r2, #128+1		; one byte for sub-address + 128 bytes of data
      [ Captions
        MyIIC_Control
      |
	SWI	XIIC_Control
      ]
	STRVS	r0, [sp]
	EXIT

	MACRO
	AGCEntry	$agcfb, $pulm, $fields, $agcl
	ASSERT	($agcfb) = 0 :LOR: ($agcfb) = 1
	ASSERT	($pulm) = 0 :LOR: ($pulm) = 1
	ASSERT	($fields) >=1 :LAND: ($fields) <=65535
	LCLA	output
output	SETA	($agcl) :OR: (($pulm) << AGCBitShift_PULM) :OR: (($agcfb) << AGCBitShift_AGCFB) :OR: (($fields) << AGCBitShift_Fields)
;	! 0,	"AGCL = $agcl, AGCFB = $agcfb, PULM = $pulm, FIELDS = $fields, OUTPUT = $output"
	&	output
	MEND

	MACRO
	AGCRamp		$agcfb, $pulm, $fields, $fromagcl, $toagcl
	LCLA	RampCount
	LCLA	RampVel
 [ ($toagcl) >= ($fromagcl)
RampVel	SETA	1
 |
RampVel	SETA	-1
 ]
RampCount SETA ($fromagcl)
	WHILE	RampCount <> ($toagcl)+RampVel
	AGCEntry	$agcfb, $pulm, $fields, &$RampCount
RampCount SETA	RampCount + RampVel
	WEND
	MEND

	GBLA	LoopCount

;			AGCFB,  PULM,	Fields,	AGCL (, Target AGCL)
AGCModulationTableStart
	AGCEntry	1,	0, 	600, 	111
	AGCRamp		1, 	0, 	2,   	110,	41
	AGCEntry	0,	0,	12,	41

LoopCount SETA	5
	WHILE	LoopCount > 0
	AGCEntry	1,	1,	60, 	80
	AGCEntry	1,	0,	60,	49
LoopCount SETA LoopCount - 1
	WEND

	AGCRamp		1,	0,	2,	50,	110
AGCModulationTableEnd


YUVTable
	BIN	"Data.YUVTable"

 [ ProvideSWI
; *****************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     r12, [wp]
;        CMP     r11, #MacrovisionSWICheckValue - MacrovisionSWI_Base
	CMP	r11, #(%FT10-%FT00) :SHR: 2
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
00
	B	SetState	; set state, to take effect from next mode change
 [ Captions
        B       LoadCaptions    ; add caption data to queue
	B	CaptionControl	; enable/disable captions
 ]
10
;	ASSERT  {PC}-%00 = (MacrovisionSWICheckValue-MacrovisionSWI_Base) :SHL: 2

NoSuchSWI
        ADRL    r0, NoSuchSWIError
        SETV
        MOV     pc, lr

NoSuchSWIError
        &       0
        =       "No such Macrovision SWI", 0
        ALIGN

; *****************************************************************************
;
;	SetState - SWI to set state entered after next mode change
;
; in:	r0 = flags (zero at present)
;	r1 = type (0 => normal, 1 => macro OK-to-tape, 2 => macro anti-tape)
;	r2 = TV standard (0 => PAL, 1 => NTSC)
;
; out:	All registers preserved

SetState Entry
	STR	r1, PendingMacroType
	STR	r2, PendingTVStandard
	EXIT

 ]

 [ Captions
; *****************************************************************************
;
;	CaptionControl - SWI to enable/disable closed caption mode
;
; in:	r0 = flags
;	      bit 0 set => enable closed-caption mode
;	      bit 0 clear => disable closed-caption mode
;             bit 1 set => R1 contains number of fields to blank during switch
;	r1 = number of fields to blank during switch (0-255), if flag bit 1 is set, else defaults to 0
;
; out:  All registers preserved

CaptionControl Entry "r0-r4, r9"
        LDR     r14, TVStandard
        TEQ     r14, #1
        EXIT    NE              ; only proceed if we're on an NTSC TV!!
; Eventually check OK to change first

	TST	r0, #1 :SHL: 0	; enabling it
	MOVNE	r3, #3		; then set NextMacroType to 3
	MOVEQ	r3, #0		; else 0
	LDR	r1, NextMacroType ; old value
	EOR	r2, r1, #3	; EOR 3 should equal new value
	TEQ	r2, r3		; if different
	EXIT	NE		; then just ignore call

	TEQ	r3, #0		; if not switching to normal mode
	STRNE	r3, NextMacroType ; then update NextMacroType, and
	BNE	%FT20		; skip this

; Now remove any existing captions before we switch away from the SAA7183 video path

	MOV	r4, pc
	ORR	r1, r4, #I_bit
	TEQP	r1, #0		; disable IRQs to prevent anyone else calling LoadCaptions

        MOV     r0, #6                                          ; odd fields, calculate parity bits, flush buffer
        ADR     r1, EraseCaptions_OddField_Start
        MOV     r2, #EraseCaptions_OddField_End-EraseCaptions_OddField_Start
	BL	LoadCaptions					; clear captions channels 1 and 2

        MOV     r0, #7                                          ; even fields, calculate parity bits, flush buffer
        ADR     r1, EraseCaptions_EvenField_Start
        MOV     r2, #EraseCaptions_EvenField_End-EraseCaptions_EvenField_Start
        BL	LoadCaptions					; clear captions channels 3 and 4

	STR	r3, NextMacroType ; store new type, *before* we reenable IRQs, so if zero, it stops anyone
				; getting in with more CC data.
	TEQP	r4, #0		; restore IRQ state

; Now hang around until the SAA7183 has output &80, &80 on CC data (ie sent all our stuff) before we switch to
; the analog NTSC output without CC.

	MOV	r0, #19
	SWI	XOS_Byte	; wait for vsync to allow the LoadCaption commands to have taken effect

10
	ADRL	r14, SAA7183IICMap + &67	; &67..&6A are the bytes to check
	LDRB	r0, [r14], #1
	TEQ	r0, #&80
	LDREQB	r0, [r14], #1
	TEQEQ	r0, #&80
	LDREQB	r0, [r14], #1
	TEQEQ	r0, #&80
	LDREQB	r0, [r14], #1
	TEQEQ	r0, #&80
	BNE	%BT10
20

; Set up RCV2IICBlk for the switch code
; We need to do this here because OS_ReadVarVal enables interrupts (!) so we
; can't use it from event code but we also get a speed benefit from doing it now.

	BL	ProcessRCV2Vars		; updates SAA7183IICMap and returns values in r0,r1
	AND	r3, r0, #&FF		; bits 0..7 of RCV2S
	STRB	r3, RCV2IICBlk + 1
	AND	r3, r1, #&FF
	STRB	r3, RCV2IICBlk + 2
	AND	r3, r1, #&700
 	MOV	r3, r3, LSR #4
 	AND	r0, r0, #&700
	ORR	r3, r3, r0, LSR #8
	STRB	r3, RCV2IICBlk + 3

; Initialise switch state variables

        LDMIA   sp, {r0, r1}                    ; get back entry registers
        TST     r0, #1:SHL:1                    ; if flag bit 1 is clear,
        MOVEQ   r1, #0                          ; then blanked fields defaults to 0
        STR     r1, SwitchCountdown
        MOV     r0, #1
        STRB    r0, SwitchState                 ; set switch state to 1 (waiting for VSync to start blanking)

; Check to see if we need to claim EventV

	LDR	r0, MacroType
	LDR	r1, TVStandard
	BL	ClaimReleaseEventV

	EXIT

EraseCaptions_OddField_Start
        =       &14, &2C, &14, &2C              ; Erase Displayed Memory, captions channel 1
        =       &1C, &2C, &1C, &2C              ; Erase Displayed Memory, captions channel 2
;        =       &14, &2E, &14, &2E              ; Erase Nondisplayed Memory, captions channel 1
;        =       &1C, &2E, &1C, &2E              ; Erase Nondisplayed Memory, captions channel 2
EraseCaptions_OddField_End

EraseCaptions_EvenField_Start
        =       &15, &2C, &15, &2C              ; Erase Displayed Memory, captions channel 3
        =       &1D, &2C, &1D, &2C              ; Erase Displayed Memory, captions channel 4
;        =       &15, &2E, &15, &2E              ; Erase Nondisplayed Memory, captions channel 3
;        =       &1D, &2E, &1D, &2E              ; Erase Nondisplayed Memory, captions channel 4
EraseCaptions_EvenField_End

; DoCaptionSwitchBlank - called from EventV to blank the screen before a switch
;
; out:  r0-r2 may be corrupted
;

DoCaptionSwitchBlank
        Entry   "r3, r4, r9"

; Set palette either completely transparent or completely black, depending on whether we're blanking fields

        LDRB    r14, SwitchCountdown
        TEQ     r14, #0
	ADREQ	r0, TransparentEDPalette
	BICEQ   r3, r3, #EventVState_OKToSwitch ; if not blanking, then force a wait until at least the next field (yuk)
	STREQ   r3, [sp]
	ADRNE   r0, OpaqueEDPalette
	BL	PatchEDPalette

; Set gamma table to all-zero (so all opaque VIDC output is black)

        LDRB    r14, SwitchCountdown
        TEQ     r14, #0
        BEQ     %FT39                   ; don't bother with this if not actually blanking the screen
        MOV     r2, sp
        SUB     sp, sp, #256*3
        MOV     r1, sp
        MOV     r0, #0
30      STR     r0, [r1], #4
        TEQ     r1, r2
        BNE     %BT30
        MOV     r0, sp
        ADD     r1, sp, #256*1
        ADD     r2, sp, #256*2
        MOV     r4, #9
        MOV     r9, #PaletteV
        SWI     XOS_CallAVector
        ADD     sp, sp, #256*3
39

; Update state variable

        MOV     r14, #2
        STRB    r14, SwitchState

        EXIT

; DoCaptionSwitchSwitch - called from EventV to actually do path switching to/from caption mode during flyback
;
; in:   NextMacroType contains the MacroType to switch to
; out:  r0-r2 may be corrupted
;

DoCaptionSwitchSwitch
        Entry   "r3"

; Actually switch video paths

	LDR	r0, NextMacroType
	STR     r0, MacroType
	TEQ	r0, #3
	MOVEQ	r0, #1		; 0 -> 0, 3 -> 1, as far as switches are concerned
	LDR	r1, TVStandard
	BL	Program_TDAs

; Update RCV2 registers from system variables

	MOV	r0, #IICDevice_SAA7183
	ADR	r1, RCV2IICBlk
	MOV	r2, #4		; one byte for sub-address + 3 bytes of data
	SWI	XIIC_Control

; Update state variable

        MOV     r14, #3
        STRB    r14, SwitchState

	EXIT

; DoCaptionSwitchUnblank - called from EventV to unblank the screen after a switch
;
; out:  r0-r2 may be corrupted
;

DoCaptionSwitchUnblank
        Entry   "r3, r4, r9"
        LDRB    r14, SwitchCountdown
        SUBS    r14, r14, #1
        STRB    r14, SwitchCountdown
        EXIT    PL              ; don't actually do anything unless we've waited the correct number of fields

; Restore gamma table

        SUB     sp, sp, #256*3
        MOV     r1, sp
        MOV     r0, #0
40      STRB    r0, [r1, #256*2]
        STRB    r0, [r1, #256*1]
        STRB    r0, [r1], #1
        ADD     r0, r0, #1
        TEQ     r0, #256
        BNE     %BT40
        MOV     r0, sp
        ADD     r1, sp, #256*1
        ADD     r2, sp, #256*2
        MOV     r4, #9
        MOV     r9, #PaletteV
        SWI     XOS_CallAVector
        ADD     sp, sp, #256*3

; Now patch/unpatch palette (assumes 16bpp): ED3 controls transparency in path 1, instead of ED0

	LDR	r0, MacroType
	TEQ	r0, #0
	ADREQ	r0, NormalEDPalette
	ADRNE	r0, MacroEDPalette
	BL	PatchEDPalette		; (bits 4..7 are the ED values)

; Update state variable

        MOV     r14, #0
        STRB    r14, SwitchState

; See if we need to get off EventV

	LDR	r0, MacroType
	LDR	r1, TVStandard
	BL	ClaimReleaseEventV

        EXIT

NormalEDPalette
; Normal mode ED palette: bit 15 of pixel value turns on ED0
	=	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1

TransparentEDPalette
; Should be transparent in both normal and macro modes: ED0 set, ED3 clear
	=	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1

OpaqueEDPalette
; Palette where no MPEG is visible in either normal or macro mode: ED0 clear, ED3 set
        =       8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8

MacroEDPalette
; Macro mode ED palette: bit 15 of pixel value turns off ED3; when bit 15 low, then bits 12-14 determine colour
;	=	8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0
; Eventually we might want no solid colours at all?, ie
	=	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

; PatchEDPalette - set up 16bpp palette entries to make bit 15 of the pixel value map to a particular
;  value of the ED bits
;
; in: 	r0 -> array of ED bit entries
; out:	r0-r4, r9 corrupted
;

PatchEDPalette Entry "r5", 128		; allocate 128 bytes for 16 entries * 2 flash states * 4 bytes
	MOV	r5, r0			; save value in r5
	MOV	r0, #0			; no list of colours, just start with 0
	MOV	r1, #16			; 16 palette entries to read
	ORR	r1, r1, #16 << 24	; read both flash states
	MOV	r2, sp			; read into stack block
	MOV	r3, #0			; intermingle 2nd flash state with 1st
	MOV	r4, #7			; bulk read PaletteV call
	MOV	r9, #PaletteV
	SWI	XOS_CallAVector

	MOV	r2, sp			; point at entries

	MOV	r0, #16			; 16 entries
10
	LDRB	r1, [r5], #1
	MOV	r1, r1, LSL #4		; move up to bits 4..7
	STRB	r1, [r2], #4		; write value to 1st flash state
	STRB	r1, [r2], #4		; and to 2nd flash state
	SUBS	r0, r0, #1
	BNE	%BT10

	MOV	r0, #0			; no list of colours, just start with 0
	MOV	r1, #16			; 16 palette entries to write
	ORR	r1, r1, #16 << 24	; write both flash states
	MOV	r2, sp			; write into stack block
	MOV	r4, #8			; bulk write PaletteV call
	MOV	r9, #PaletteV
	SWI	XOS_CallAVector
	EXITS

; *****************************************************************************
;
;	LoadCaptions - SWI to add data to the queue waiting to be passed to the SAA7183
;
; in:	r0 = flags
;             bit 0 set => extended data, rather than closed captions
;             bit 1 set => calculate parity bits for the data
;             bit 2 set => flush the FIFO first
;	r1 -> data bytes
;	r2 = number of bytes pointed to by R1
;
; out:	All registers preserved

LoadCaptions
        Entry   "r0-r4"
	LDR	r3, NextMacroType
	TEQ	r3, #0
	EXITS	EQ			; exit doing nothing if normal mode
        TST     r0, #1 :SHL: 0          ; select FIFO
        ADREQ   r3, CaptionFIFO
        ADRNE   r3, ExtDataFIFO
        TST     r0, #1 :SHL: 2          ; flush FIFO?
        LDRNE   lr, [r3, #FIFO_WritePtr]
        STRNE   lr, [r3, #FIFO_ReadPtr]
01      SUBS    r2, r2, #1
        EXITS   MI
        LDRB    r4, [r1], #1
        TST     r0, #1 :SHL: 1
        BLNE    SetParity
        TST     r0, #1 :SHL: 0          ; ensure that control codes are always doubled, but only on odd fields
        BLEQ    WriteToFIFO_WithCheckForControlCode
        BLNE    WriteToFIFO
        B       %BT01

; SetParity - sets byte in r4 to odd parity
SetParity
 [ {TRUE} ; more efficient code TMD 14-Apr-99
	Entry
	EOR	r14, r4, r4, LSR #4	; combine bits 4 apart
	EOR	r14, r14, r14, LSR #2	; combine bits 2 apart
	EOR	r14, r14, r14, LSR #1	; combine bits 1 apart
	TST	r14, #1
	EOREQ	r4, r4, #&80		; if even parity then correct it
	EXITS
 |
        Entry   "r0-r2"
        MOV     r0, #7          ; loop counter
        MOV     r1, #0          ; set bits so far
        MOV     r2, r4
01      MOVS    r2, r2, ROR #1  ; shift bit 0 into bit 31
        ADDMI   r1, r1, #1
        SUBS    r0, r0, #1
        BNE     %BT01
        TST     r1, #1          ; odd or even number encountered so far?
        ORREQ   r4, r4, #&80
        BICNE   r4, r4, #&80
        EXITS
 ]

; WriteToFIFO_WithCheckForControlCode - may also insert extra data if needed to keep control codes in pairs
; in:   r3 -> FIFO
;       r4 = byte to write
; out:  registers preserved
WriteToFIFO_WithCheckForControlCode
        Entry
        LDRB    r14, ControlCodeState
        MOVS    r14, r14, LSR #1        ; C = r14 bit 0,  Z set if r14 was 0 or 1
        BHI     %FT03                   ; branch if C set and Z clear (ie r14 was 3)
        BNE     %FT02                   ; if r14 was 2
        BCS     %FT01                   ; if r14 was 1
                                        ; else r14 was 0
00      AND     r14, r4, #&70
        TEQ     r14, #&10               ; check if first byte of a control code (&10-&1F, ignoring parity)
        STREQB  r4, ControlCode1        ; if the start of a control code, wait for the second byte
        BLNE    WriteToFIFO             ; else just put it in the FIFO now
        MOVEQ   r14, #1
        MOVNE   r14, #0
        STRB    r14, ControlCodeState   ; update control code state appropriately
        EXITS

01      STRB    r4, ControlCode2
        LDRB    r4, ControlCode1
        BL      WriteToFIFO
        LDRB    r4, ControlCode2
        BL      WriteToFIFO             ; write both bytes now, in any case
        TST     r4, #&60                ; check if a valid second byte (&20-&7F, ignoring parity)
        LDRNEB  r4, ControlCode1
        BLNE    WriteToFIFO
        LDRNEB  r4, ControlCode2        ; if we recognised the control code format, send the repetition immediately
        BLNE    WriteToFIFO             ; else make no assumptions about repetition of codes (to allow for future changes to the CC standard)
        MOVNE   r14, #2
        MOVEQ   r14, #0
        STRB    r14, ControlCodeState   ; update control code state appropriately
        EXITS

02      LDRB    r14, ControlCode1
        TEQ     r4, r14                 ; an exact repetition?
        BNE     %BT00                   ; if not, act as though control code state was 0 instead
        MOV     r14, #3
        STRB    r14, ControlCodeState   ; else just update control code state (we've already put this byte in the FIFO)
        EXITS

03      LDRB    r14, ControlCode2
        TEQ     r4, r14                 ; an exact repetition?
        BNE     %BT01                   ; if not, act as though control code state was 1 instead
        MOV     r14, #0
        STRB    r14, ControlCodeState   ; else just update control code state (we've already put this byte in the FIFO)
        EXITS

; WriteToFIFO - writes a single byte to a FIFO
; in:   r3 -> FIFO
;       r4 = byte to write
; out:  registers preserved
;       no action is taken if overflow occurs
WriteToFIFO
        Entry   "r0-r2"
        ; Get FIFO read/write indices
        LDR     r0, [r3, #FIFO_ReadPtr]
        LDR     r1, [r3, #FIFO_WritePtr]
        ; Calculate next write index
        ADD     r2, r1, #1
        TEQ     r2, #FIFO_Buffer + FIFOlength
        MOVEQ   r2, #FIFO_Buffer
        ; If buffer has overrun, exit
        TEQ     r2, r0
        EXITS   EQ
        ; There is space in the buffer, so write byte
        STRB    r4, [r3, r1]
        STR     r2, [r3, #FIFO_WritePtr]
        EXITS

; ReadFromFIFO - reads a single byte from a FIFO
; in:   r3 -> FIFO
; out:  r4 = byte from FIFO
;       r3 preserved
;       &80 is returned in r1 if underflow occurs
ReadFromFIFO
        Entry   "r0,r1"
        ; Get FIFO read/write indices
        LDR     r0, [r3, #FIFO_ReadPtr]
        LDR     r1, [r3, #FIFO_WritePtr]
        ; If buffer has underrun, return &80 (odd-parity null)
        TEQ     r0, r1
        MOVEQ   r4, #&80
        EXITS   EQ
        ; Read byte
        LDRB    r4, [r3, r0]
        ; Update read pointer
        ADD     r0, r0, #1
        TEQ     r0, #FIFO_Buffer + FIFOlength
        MOVEQ   r0, #FIFO_Buffer
        STR     r0, [r3, #FIFO_ReadPtr]
        EXITS

; SendCaptionBytes - called from EventV to send a captions byte pair to SAA7183
; in:   no parameters
; out:  all registers preserved
SendCaptionBytes
        Entry   "r0-r5"
        ; Read 2 bytes from FIFO
        ADR     r3, CaptionFIFO
        BL      ReadFromFIFO
        MOV     r5, r4
        BL      ReadFromFIFO
        ; r5 = first byte, r4 = second byte
        ; Construct IIC_Control block on stack
        MOV     r0, #&67
        ORR     r0, r0, r5, LSL #8
        ORR     r0, r0, r4, LSL #16
        Push    "r0"
        MOV     r0, #IICDevice_SAA7183
        MOV     r1, sp
        MOV     r2, #3
        SWI     XIIC_Control
        ADD     sp, sp, #4
        EXITS   VS
        ; Update soft copy of SAA7183 registers
        ADRL    r14, SAA7183IICMap + &67
        STRB    r5, [r14], #1
        STRB    r4, [r14]
        EXITS

; SendExtDataBytes - called from EventV to send an extended data byte pair to SAA7183
; in:   no parameters
; out:  all registers preserved
SendExtDataBytes
        Entry   "r0-r5"
        ; Read 2 bytes from FIFO
        ADR     r3, ExtDataFIFO
        BL      ReadFromFIFO
        MOV     r5, r4
        BL      ReadFromFIFO
        ; r5 = first byte, r4 = second byte
        ; Construct IIC_Control block on stack
        MOV     r0, #&69
        ORR     r0, r0, r5, LSL #8
        ORR     r0, r0, r4, LSL #16
        Push    "r0"
        MOV     r0, #IICDevice_SAA7183
        MOV     r1, sp
        MOV     r2, #3
        SWI     XIIC_Control
        ADD     sp, sp, #4
        EXITS   VS
        ; Update soft copy of SAA7183 registers
        ADRL    r14, SAA7183IICMap + &69
        STRB    r5, [r14], #1
        STRB    r4, [r14]
        EXITS
 ]

; *****************************************************************************
;
;       Message stuff


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

	InsertDebugRoutines

        END
