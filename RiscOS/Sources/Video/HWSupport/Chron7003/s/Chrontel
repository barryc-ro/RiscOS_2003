

; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:PaletteV
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:IIC
        GET     Hdr:NVRAM
        GET     Hdr:Standby
        GET     Hdr:ModeFiles
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Territory
        GET     Hdr:Countries
        GET     Hdr:Machine.<Machine>
        GET     Hdr:Proc
        $GetMEMM
        $GetIO

        GET     VersionASM
;Bodge to pack the 9bit vertical value into an 8bit NVRAM location
                        GBLL    NVRAMBodge
NVRAMBodge              SETL    {TRUE}

;IIC address for Chrontel 7003

Chrontel_IIC_Write      * 234           ;&75:SHL:1
Chrontel_IIC_Read       * 235           ;&75:SHL:1 + 1

;Define some constants for the directions we can move in
                        ^ 0
Chrontel_Left           # 1
Chrontel_Right          # 1
Chrontel_Down           # 1
Chrontel_Up             # 1
Chrontel_Reset          # 1

Vert_Step_Size          * 4
Vert_Stop               * 50            ;how far they can move the display in the vertical in both directions
        ASSERT (313 - Vert_Stop) > (255 - 60)  ;check that the vertical stop won't allow the screen to be moved into the region we can't encode
Horiz_Step_Size         * 2
Horiz_Stop              * 50            ;how far they can move the display in the horizontal in both directions
Start_Active_Video      * 148
Horiz_Offset            * Start_Active_Video:SHR:2
Chrontel_Flicker        * 1             ;00=none  01=med  10=low  11=high

;Define the layout of the module workspace (NOT relative to r12)
                        ^ 0
FirPalAddr              # 4             ;soft copy of the palette, flash state 1
SecPalAddr              # 4             ;soft copy of the palette, flash state 2

DisplayNColour          # 4             ;1,3,15,63,255,etc
DisplayModeFlags        # 4
PalIndex                # 4             ;type of palette

TVLPF                   # 4             ;TV lines per frame - PAL 625, NTSC 525
IIC_Vert                # 4             ; and vertical positions - !!this is bits 0-8 but we need to copy bit 8 this into the overflow!!
IIC_Buffer              # 4*10           ;buffer to prepare IIC transmissions in and various other stuff like ReadVduVariables

IIC_SAV                 # 1             ;last known value of start active video,
IIC_Overflow            # 1             ; overflow - this is a soft copy of the register on the chip
IIC_Black               # 1             ; black level,
IIC_Horiz               # 1             ;last known horizontal - !!this is bits 0-7 of the value - we wil not be using the 8th bit!!

MonitorType             # 1             ;0,8 TV's +  3 Monitor - this byte is also used to decide whether to claim/release PaletteV
ScreenBlankFlag         # 1             ;screen blanked?
FlashState              # 1             ;which flash state is displayed; 0=2nd 1=1st
Dummy                   # 1
                        AlignSpace

 [ GammaCorrection
SoftPalette             # (256+1+3)*4*4+3*256   ; logical and physical copies of both flash states plus 3 lookup tables for r,g,b
 |
SoftPalette             # (256+1+3)*4*2         ; soft copy of palette (2 flash states)
 ]
WorkspaceSize           # 0

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_Commands-Module_BaseAddr
        &       0 ;SWIBase number
        &       0 ;Mod_SWIHandler-Module_BaseAddr
        &       0 ;Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry
        &       0                               ; no internationalised help
        &       Mod_Flags   -Module_BaseAddr

Mod_Title
        =       "Chrontel", 0

Mod_HelpStr
        =       "Chrontel", 9, "$Module_MajorVersion ($Module_Date) 7003 version",0

Chrontel_Var
        =       "Alias$URLOpenCLI_Chrontel_Move",0
Chrontel_Var_Val
        =       "Chrontel_Move %*0",0
Chrontel_Var_Val_End
        ALIGN

Mod_Flags
        &       ModuleFlag_32bit

Mod_Init
        Push    "lr"

        LDR     r2,[r12]                ;do we have some workspace?
        CMP     r2,#0
        BNE     Mod_Init_GotWorkspace   ;if so, don't claim more
        MOV     r0,#6
        LDR     r3,=WorkspaceSize
        SWI     XOS_Module
        Pull    "pc",VS                 ;return with error
        STR     r2,[r12]

Mod_Init_GotWorkspace
        MOV     r12,r2                  ;we'll need it at some point
        MOV     r2,#3
        STRB    r2,[r12,#MonitorType]   ;this has to reflect whether or not we've claimed paletteV

        ;set up the system variable containing our movement command that allows the browser to communicate with us
        ADR     r0,Chrontel_Var
        ADR     r1,Chrontel_Var_Val
        MOV     r2,#Chrontel_Var_Val_End-Chrontel_Var_Val
        MOV     r3,#0
        MOV     r4,#0
        SWI     XOS_SetVarVal

        ;set up stuff for the code ripped from the kernal
        ADD     r2,r12,#SoftPalette
        STR     r2,[r12,#FirPalAddr]
        ADD     r3,r2,#(256+1+3)*4
        STR     r3,[r12,#SecPalAddr]

; now initialise entries for pointer palette so they will actually program pointer palettte
; because VDU20 doesn't change pointer palette

        MOV     r3, #&50000000
        MOV     r4, #&60000000
        MOV     r5, #&70000000

        ADD     r2, r2, #260*4          ; store in 1st copy of logical
        STMDB   r2, {r3-r5}             ; (last 3 entries)

        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 2nd copy of logical

 [ GammaCorrection
        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 1st copy of physical

        ADD     r2, r2, #260*4
        STMDB   r2, {r3-r5}             ; store in 2nd copy of physical

; r2 now points off end of all 4 copies, ie start of rgb tables
; initialise red, green and blue transfer function tables to 1-1 mapping

        MOV     r0, #0
05
        STRB    r0, [r2, #&200]                 ; store in blue table
        STRB    r0, [r2, #&100]                 ; store in green table
        STRB    r0, [r2], #1                    ; store in red table, and advance
        ADD     r0, r0, #1
        CMP     r0, #256
        BCC     %BT05
  ]

        MOV     r0,#0
        STRB    r0,[r12,#FlashState]    ;which palette to display
        STRB    r0,[r12,#ScreenBlankFlag] ;not blanked

        BL      IOMD_Setup
        BL      Chrontel_Setup

        ;MVN     r3,#0                   ;force a read of the monitor type
        ;BL      Chrontel_Mode           ;set-up some stuff before the first call to paletteV

        Pull    "pc"


Mod_Die
        Push    "lr"
        LDR     r2,[r12]                ;do we have some memory to give back
        CMP     r2,#0
        MOVNE   r0,#7
        SWINE   XOS_Module
        MOV     r0,#PaletteV
        ADRL    r1,Chron_MOSPaletteV
        ;LDRB    r3,[r12,#MonitorType]
        ;CMP     r3,#3                  ;then do SWINE XOS_Release
        SWI     XOS_Release             ;r2 should still be the pointer to our workspace
        CLRV                            ;release paletteV regardless of whether we think we've claimed it just in case
        Pull    "pc"

Mod_Service
        &       Mod_Service_Table -Module_BaseAddr
        MOV     r0,r0                   ;special instruction to indicate fast service call dispatching
        TEQ     r1,#Service_ModeChange
        TEQNE   r1,#Service_PreModeChange
        TEQNE   r1,#Service_ModeChanging
        MOVNE   pc,lr
Mod_Service_Fast
        TEQ     r1,#Service_ModeChange
        BEQ     ModeChange
        TEQ     r1,#Service_PreModeChange
        BEQ     PreModeChange
        TEQ     r1,#Service_ModeChanging
        BEQ     ModeChanging
        MOV     pc,lr

Mod_Service_Table
        &       0                       ;flags
        &       Mod_Service_Fast -Module_BaseAddr
        &       Service_ModeChange      ;&46
        &       Service_PreModeChange   ;&4d
        &       Service_ModeChanging    ;&89
        &       0

Mod_Commands
        =       "Chrontel_Move",0
        ALIGN
        &       Command_Move -Module_BaseAddr
        &       &00020001
        &       Command_Move_Syntax -Module_BaseAddr
        &       Command_Move_Help -Module_BaseAddr

        =       "Chrontel_Status",0
        ALIGN
        &       Command_Status -Module_BaseAddr
        &       &00000000
        &       Command_Status_Syntax -Module_BaseAddr
        &       Command_Status_Help -Module_BaseAddr

        =       "Chrontel_Clocks",0
        ALIGN
        &       Command_Clocks -Module_BaseAddr
        &       &00000000
        &       Command_Clocks_Syntax -Module_BaseAddr
        &       Command_Clocks_Help -Module_BaseAddr

        &       0
        ALIGN

Command_Move_Help
        DCB     "*Chrontel_Move adjusts the position of the browser on the screen",13
Command_Move_Syntax
        DCB     "Syntax: *Chrontel_Move <Up|Down|Left|Right|Reset>",0
        ALIGN

Command_Clocks
        MOV     pc,lr
Command_Clocks_Help
        DCB     "*Chrontel_Clocks lists the available clock rates",13
Command_Clocks_Syntax
        DCB     "Syntax: *Chrontel_Clocks",0
        ALIGN
Command_Status
        MOV     pc,lr
Command_Status_Help
        DCB     "*Chrontel_Status displays the Chrontel's current parameters - need better message",13
Command_Status_Syntax
        DCB     "Syntax: *Chrontel_Status",0
        ALIGN

Command_Move
        ;need to respond to up,down,left,right and reset
        Push    "r0,lr"
        LDR     r12,[r12]

        ;find a colon, if one is present then only check for command after it, else use whole string
        ADR     r3,Command_Move_Table
        MOV     r5,r0                   ;remember the start of the command string in case it has no colon
Command_Move_Find_Colon
        LDRB    r6,[r0],#1
        CMP     r6,#58                  ;":"
        BEQ     Command_Move_Find

        CMP     r6,#32                  ;have we reached end of command
        BGT     Command_Move_Find_Colon
        MOV     r0,r5                   ;if we've not found the colon then use the original command string

Command_Move_Find
        MOV     r5,r0                    ;reset pointer to actual command
Command_Move_Find_Loop
        LDRB    r4,[r3],#1
        LDRB    r6,[r5],#1
        CMP     r4,#0
        BEQ     Command_Move_Check
        CMP     r6,#65
        RSBGES  r1,r6,#90
        ADDGE   r6,r6,#32               ;force lower case
        CMP     r4,r6
        BEQ     Command_Move_Find_Loop

Command_Move_Skip_Command
        CMP     r4,#0                   ;have we reached terminating zero?
        LDRNEB  r4,[r3],#1              ;load next char.
        BNE     Command_Move_Skip_Command
        LDRB    r4,[r3,#1]!             ;skip over code, load first character of next command and make r3 point next command
        CMP     r4,#0                   ;is it the end of the whole table
        BNE     Command_Move_Find

        ;if we reached the end of the table then fall through to here
Command_Move_Unknown
        Pull    "r0,lr"
        ADR     r0,Command_Move_Unknown_Message
        SETV
        MOV     pc,lr

Command_Move_Unknown_Message
        DCD     0
        DCB     "Bad direction - use up, down, left, right, or reset",0
        ALIGN

Command_Move_Table
        ;text, followed by terminating zero, followed by code
        ;bit 0 clear=horizontal set=vertical
        ;bit 1 clear=smaller(left,down) set=bigger(up,right)
        ;bit 2 clear=move set = reset
        ;codes are l=0 r=2,d=1,u=3,r=4
        DCB     "left"
        DCB     0
        DCB     Chrontel_Left

        DCB     "right"
        DCB     0
        DCB     Chrontel_Right

        DCB     "down"
        DCB     0
        DCB     Chrontel_Down

        DCB     "up"
        DCB     0
        DCB     Chrontel_Up

        DCB     "reset"
        DCB     0
        DCB     Chrontel_Reset

        DCB     0                       ;terminate table
        ALIGN

Command_Move_Check
        ;This section of code allows arguments which start the same e.g uplots and upabit
        CMP     r6,#32                  ;\space
        BLE     Command_Move_Do
        CMP     r6,#63                  ;"?"
        BNE     Command_Move_Skip_Command

Command_Move_Do
        ;we now have a valid command and r3 is pointing at it's code number
        LDRB    r2,[r3,#0]              ;load code number
        ADD     r1,r12,#IIC_Buffer      ;set up r1 to point to a buffer
        MOV     r0,#Chrontel_IIC_Write  ;required by SWI IIC_Control

        CMP     r2,#Chrontel_Reset
        BEQ     Chrontel_Move_Reset

        CMP     r2,#Chrontel_Left
        CMPNE   r2,#Chrontel_Right
        BEQ     Chrontel_Move_Horiz

        CMP     r2,#Chrontel_Down
        CMPNE   r2,#Chrontel_Up
        BEQ     Chrontel_Move_Vert
;new commands go here - look how I didn't assume a vertical movement

        Pull    "r0,pc"

Chrontel_Move_Horiz
        ;r0,r1 are ready for IIC_Control
        LDRB    r3,[r12,#IIC_Horiz]
        MOV     r5,r3                   ;make a copy to see if anything has changed
        CMP     r2,#Chrontel_Left
        ADDNE   r3,r3,#Horiz_Step_Size
        SUBEQ   r3,r3,#Horiz_Step_Size

        CMP     r3,#0                   ;minimum is 0 - should use the horiz_stop here
        MOVLT   r3,#0
        CMP     r3,#Horiz_Stop+Horiz_Offset     ;maximum is controlled by Horiz_Stop - chip allows 511 but this software only allows 255
        MOVGT   r3,#Horiz_Stop+Horiz_Offset
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STRB    r3,[r12,#IIC_Horiz]     ;store new value
        MOV     r2,#&0a                 ;horizontal register
        STRB    r2,[r1,#0]              ;put horizontal register into IIC block
        STRB    r3,[r1,#1]              ;put horizontal value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        SUB     r3,r3,#Horiz_Offset
        MOV     r3,r3,LSL#24
        MOV     r3,r3,LSR#24            ;make horizontal value unsigned

        ADR     r0,NVRAM_X
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write

        Pull    "r0,pc"                 ;return preserving r0

Chrontel_Move_Vert
        ;r0,r1 are ready for IIC_Control
        LDR     r3,[r12,#IIC_Vert]      ;this has to be an LDR because IIC_Vert is a 9 bit value
        MOV     r5,r3                   ;make a copy of the value before we alter it
        LDR     r6,[r12,#TVLPF]
        MOV     r6,r6,LSR#1             ;this is the limit that the chrontel 7003 defines [TVLPF-1]/2
        CMP     r2,#Chrontel_Down
        SUBEQ   r3,r3,#Vert_Step_Size
        ADDNE   r3,r3,#Vert_Step_Size

        CMP     r3,#0
        MOVLT   r3,r6
        CMP     r3,r6
        MOVGT   r3,#0

        SUB     r6,r6,#Vert_Stop        ;get a value that limits how low they can go
        CMP     r3,#Vert_Stop           ;is the vertical value greater than 50
        CMPGT   r6,r3                   ;and the upper limit greater than the vertical value
        BLE     Chrontel_Move_Vert_Program

        ;if we fall through to here the vertical value lies between the two limits
        ;so we need to fix it
        CMP     r2,#Chrontel_Down
        ADDEQ   r3,r3,#Vert_Step_Size
        SUBNE   r3,r3,#Vert_Step_Size

Chrontel_Move_Vert_Program
        ;this bit is broken - it will save the wrong values to NVRAM and generally get confused
        ;in particular r3 will have been corrupted by the time it gets to the NVRAM write stage
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STR     r3,[r12,#IIC_Vert]      ;store new value
        MOV     r2,#&0b                 ;vertical register
        STRB    r2,[r1,#0]              ;put vertical register into IIC block
        AND     r5,r3,#255              ;get low 8 bits
        STRB    r5,[r1,#1]              ;put low bits of vertical value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        MOV     r4,r3,LSR#8             ;move bit 8 into bit 0 (and preserve r3 for later)
        AND     r4,r4,#1                ;make sure we've only got bit 0
        LDRB    r6,[r12,#IIC_Overflow]  ;get the copy of the overflow register
        BIC     r5,r6,#2_11111110       ;clear everything except current vertical bit
        CMP     r4,r5                   ;are they set the same way?
        BEQ     Chrontel_Move_Vert_Skip1;don't program the overflow register

        MOV     r0,#Chrontel_IIC_Write
        BIC     r6,r6,#2_00000001       ;clear the relevant bit
        ORR     r6,r6,r4                ;and orr in the new value
        STRB    r6,[r12,#IIC_Overflow]  ;store it in our soft copy
        MOV     r2,#&08                 ;overflow register
        STRB    r2,[r1,#0]
        STRB    r6,[r1,#1]
        MOV     r2,#2
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

Chrontel_Move_Vert_Skip1
        ADR     r0,NVRAM_Y
 [ NVRAMBodge
        CMP     r3,#127                 ;is the value in the upper or lower range
        SUBGT   r3,r3,#60               ;upper range so subtract 60
 ]
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write

        Pull    "r0,pc"                 ;if there was no error then return preserving r0

Chrontel_Move_Reset
        ;r0,r1 are ready for IIC_Control
        MOV     r2,#8                   ;put overflow register number
        STR     r2,[r1,#0]              ;into IIC buffer
        LDRB    r2,[r12,#IIC_Overflow]  ;load the overflow byte
        AND     r2,r2,#2_11111100       ;zero the horiz and vert bits but leave everything else okay
        STRB    r2,[r1,#1]              ;put it in the block
        STRB    r2,[r12,#IIC_Overflow]  ;and the soft-copy
        MOV     r2,#2                   ;two bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)
        MOV     r0,#Chrontel_IIC_Write  ;IIC_Control helpfully corrupts r0 so we need to restore it

        MOV     r2,#&a+64               ;auto inc from horizontal register (&a)
        STRB    r2,[r1,#0]
        MOV     r2,#Horiz_Offset        ;default horizontal position
        STRB    r2,[r1,#1]
        STRB    r2,[r12,#IIC_Horiz]
        MOV     r2,#0                   ;default vertical position
        STRB    r2,[r1,#2]
        STR     r2,[r12,#IIC_Vert]
        MOV     r2,#3                   ;3 bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)

        MOV     r2,#0                   ;default horizontal position, also tells NVRAM_Write to use first word of r1
        STR     r2,[r1,#0]
        ADR     r0,NVRAM_X
        SWI     XNVRAM_Write

        MOV     r2,#0                   ;default vertical
        STR     r2,[r1,#0]
        MOV     r2,#0
        ADR     r0,NVRAM_Y
        SWI     XNVRAM_Write

        Pull    "r0,pc"

NVRAM_X
        =       "DisplayXPosition",0
NVRAM_Y
        =       "DisplayYPosition",0
        ALIGN

Chrontel_Setup
        ; Setup the chrontel hardware using the IIC bus
        ; this stuff is only done once i.e the stuff that is not mode or monitor dependant
        ; power up - reset - power up
        Push    "lr"
        ADD     r1,r12,#IIC_Buffer

        MOV     r2,#&0E                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00000011          ;power up and do reset
        STRB    r2,[r1,#1]
        MOV     r2,#2                   ;send 2 bytes
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#&0E                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00001011          ;power up and clear reset condition
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#64+0                ;display settings register (0) with auto inc (64)
        STRB    r2,[r1,#0]
        MOV     r2,#2_10000001          ;800x600 PAL 1-1 (29.5MHz) 640x480=%01100001
        STRB    r2,[r1,#1]
        MOV     r2,#Chrontel_Flicker    ;flicker reduction 00=none 01=med 10=low 11=high
        STRB    r2,[r1,#2]
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#4                   ;data format register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00001000          ;pixel data set to 8bit multiplex 5-5-5
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                  ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#6                   ;control register
        STRB    r2,[r1,#0]
        MOV     r2,#2_01000000          ;CFRB off, master mode on, x, data is latched on negative edge, xcm1, xcm0, pcm1, pcm0
                                        ;data latched on negative edge means that the red LUT corresponds to P0b (G2 G1 G0 B4 B3 B2 B1 B0)
                                        ;                                   and the green LUT corresponds to P0a (xx R4 R3 R2 R1 R0 G4 G3)
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        ADR     r0,NVRAM_X              ;NVRAM tag
        MOV     r2,#0                   ;read into first word of r1
        SWI     XNVRAM_Read
        CMP     r0,#0                   ;error?
        MOVLT   r4,#Horiz_Offset        ;default value if there is a problem reading NVRAM
        BLT     %FT40
        LDR     r4,[r1,#0]              ;if not load up the value
        MOV     r4,r4,ASL#24
        MOV     r4,r4,ASR#24            ;make into a signed value
        ADD     r4,r4,#Horiz_Offset     ;make 0 equate to a default middle position
40
        STRB    r4,[r12,#IIC_Horiz]     ;our soft copy


        ;the vertical position ranges between 0 and TVLPF/2 (313 max) which is too big to fit into 8bits
        ;however we don't use the middle of this range 50-200 (ish) so a cunning bodge allows us to fit the 9bit value into 8bits
        ;bit 7 clear indicates that the value is in the low range so we simply use the value
        ;bit 7 set indicates upper range so add 60 which gives a range of 188-315 (min required=262-stop value  max required=313)
        ADR     r0,NVRAM_Y
        MOV     r2,#0
        SWI     XNVRAM_Read
        CMP     r0,#0
        LDRGE   r5,[r1,#0]
        MOVLT   r5,#0                   ;default value
 [ NVRAMBodge
        TST     r5,#2_10000000          ;is bit 7 set?
        ADDNE   r5,r5,#60
 ]
        STR     r5,[r12,#IIC_Vert]      ;our soft copy

        MOV     r2,#64+&07              ;start active video register
        STRB    r2,[r1,#0]              ;address in block
        MOV     r2,#Start_Active_Video
        STRB    r2,[r1,#1]              ;SAV value in block     - limited to <=255
        MOV     r2,r5,LSR#8             ;make bit 8 into bit 0
        AND     r2,r2,#1                ;clear other bits
        STRB    r2,[r1,#2]              ;Overflow value in block
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#64+&0a              ;horizontal register
        STRB    r2,[r1,#0]              ;address in block
        STRB    r4,[r1,#1]              ;horizontal
        STRB    r5,[r1,#2]              ;vertical
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        ;MOV     r2,#64+&13              ;PLL registers starting (&13) with auto-inc (64)
        ;STRB    r2,[r1,#0]
        ;MOV     r2,#2_00000101
        ;STRB    r2,[r1,#1]
        ;MOV     r2,#57
        ;STRB    r2,[r1,#2]
        ;MOV     r2,#135
        ;STRB    r2,[r1,#3]
        ;MOV     r2,#4
        ;MOV     r0,#Chrontel_IIC_write                  ;put device address in r0
        ;SWI     XIIC_Control
        ;BVS     Chrontel_Failed

Chrontel_Failed
        CLRV                            ;in case one of the IIC_Control caused an error

        Pull    "pc"

PreModeChange
        ;a) check the colour depth <= 256 colours
        ;r2 is mode
        Push    "r0-r2,lr"
        LDR     r12,[r12]

        MOV     r0,r2                   ;we want to know about the suggested mode in r2
        MOV     r1,#9                   ;ask for LOG to base 2 of BPP
        SWI     XOS_ReadModeVariable
        MOVCS   r2,#0

        SWI     XModeFiles_MonitorType  ;otherwise read the actual type
        MOVVS   r0,#3                   ;if we couldn't get an answer from ModeFiles then assume not an NC so assume VGA
        CMP     r0,#0
        CMPEQ   r0,#8                   ;TV?
        Pull    "r0-r2,pc",NE           ;If not TV then carry on as normal

        CMP     r2,#4                   ;16bpp or greater
        Pull    "r0-r2,lr"
        MOVGE   r1,#0                   ;if so return with an error
        ADRGE   r0,HighColourModeError
        MOV     pc,lr

HighColourModeError
        DCD     &1ed
        DCB     "Screen mode not available: Pixel depths greater than 8bpp are not compatible with TV output",0
        ALIGN

        ;some code to set Variable1 rob$debug1 to the value of r3
        ;Push    "r0-r4"
        ;ADRL     r0,Variable1
        ;ADD     r1,r12,#IIC_Buffer
        ;STR     r3,[r1,#0]
        ;MOV     r2,#0
        ;MOV     r3,#0
        ;MOV     r4,#1
        ;SWI     XOS_SetVarVal
        ;Pull    "r0-r4"


ModeChanging
        ;decide, based on monitor type whether we still need to sit on PaletteV and also mark mode info
        ;as invalid so that the modified kernel routines re-read it
        ;r2 is new mode
        ;r3 is MonitorType
        ;0 : PAL TV
        ;3 : VGA MONITOR
        ;8 : NTSC TV
        LDR     r12,[r12]
        Push    "r0-r4,lr"

        ;various things required by the code ripped from the kernel
        MOV     r0,r2                   ;the new mode we're going to change to
        MOV     r1,#0                   ;ModeFlags
        SWI     XOS_ReadModeVariable
        STR     r2,[r12,#DisplayModeFlags]
        MOV     r4,r2
        MOV     r1,#3                   ;number of colours
        SWI     XOS_ReadModeVariable
        STR     r2,[r12,#DisplayNColour]

        ;now work out what the PalIndex is supposed to be, r2 is 1,3,15,63,255 etc
        MOV     r0,#3                   ;default to a 256 colour mode
        TST     r4,#2_0010000           ;hi-res mono
        MOVNE   r0,#5
        BNE     %FT20
        TST     r4,#2_0000010           ;teletext
        MOVNE   r0,#4
        BNE     %FT20

        CMP     r2,#1
        MOVEQ   r0,#0                   ;1bpp
        CMP     r2,#3
        MOVEQ   r0,#1                   ;2bpp
        CMP     r2,#15
        MOVEQ   r0,#2                   ;4bpp
        CMP     r2,#63
        CMPNE   r2,#255
        MOVEQ   r0,#3                   ;8bpp - both types

        MOV     r1,#&ff
        ORR     r1,r1,r1,LSL#8          ;get the value &ffff
        CMP     r2,r1
        MOVEQ   r0,#6                   ;16bpp
        CMN     r2,#1
        MOVEQ   r0,#7                   ;32bpp
20
        STR     r0,[r12,#PalIndex]

        ;okay now do the monitor type stuff
        CMP     r3,#0
        CMPNE   r3,#8
        CMPNE   r3,#3                   ;known type of display?
        BEQ     Chrontel_Mode_KnownType ;if so we can use it directly

        SWI     XModeFiles_MonitorType  ;otherwise read the actual type
        MOVVC   r3,r0                   ;put it in r3
        MOVVS   r3,#3                   ;if we couldn't get an answer from ModeFiles then assume not an NC so choose VGA
Chrontel_Mode_KnownType

        MOV     r0,#PaletteV
        ADRL    r1,Chron_MOSPaletteV
        MOV     r2,r12
        LDRB    lr,[r12,#MonitorType]   ;previous monitor type
        CMP     r3,#0
        CMPNE   r3,#8                   ;is it a television?
        BEQ     Chrontel_Mode_Claim     ;yes, so goto TV

        ;falls through to here if monitor
        CMP     lr,#3                   ;previously monitor?
        SWINE   XOS_Release             ;if not then release vector
        B       Chrontel_Mode_Skip3

Chrontel_Mode_Claim
        ;arrives here if television
        CMP     lr,#3                   ;previously monitor?
        SWIEQ   XOS_Claim               ;if so then claim vector
        ;B       Chrontel_Mode_Skip3

Chrontel_Mode_Skip3
        STRB    r3,[r12,#MonitorType]   ;make a record of what we've decided to go with

        ;MOV     r3,#1
        ;STRB    r3,[r12,#NewMode]


        Pull    "r0-r4,pc"



ModeChange
        LDR     r12,[r12]

Chrontel_Mode
        ;choose a black level based on NTSC[-J] or PAL[ M], TV type and territory
        ;choose PLL values to match clock
        ;if TV then look up clock speed and cross reference this to a chrontel mode
        ;nice if it could be called directly from Service_ModeChange
        ;r3 is monitor type
        ;we'll always be in the mode we are working out values for so we don't need to know the mode
        Push    "r0-r10,lr"

        LDRB    r3,[r12,#MonitorType]

        BL      Chrontel_Black_Level

        ;when moving the display  around on screen we need to know how many lines per frame
        ;default to 624 lines - this is what will happen with monitors (type 3) but since
        ; the chrontel doesn't move the display around on monitors so it don't matter
        MOV     r4,#624
        CMP     r3,#8
        MOVEQ   r4,#524                 ;NTSC lines
        CMP     r3,#0
        MOVEQ   r4,#624                 ;PAL lines
        STR     r4,[r12,#TVLPF]

        ;the kernal will invariably scrub over the changes we've made because it didn't know about them
        MOV     r0,#VIDC
        LDR     r1,VIDC_Parameters      ;make sure VIDC is doing the right stuff
        STR     r1,[r0]

        ;get pixel rate required by this mode
        ADD     r1,r12,#IIC_Buffer
        MOV     r0,r1                   ;use the same block for input and output
        MOV     r2,#173                 ;clock rate
        STR     r2,[r1,#0]
        MVN     r2,#0                   ;current mode r2=-1
        STR     r2,[r1,#4]
        SWI     XOS_ReadVduVariables
        LDR     r4,[r0,#0]              ;r4 = Fpix

        ;pick a mode based on this and PAL/NTSC choice - don't need to bother if it's a monitor
        ;to begin with pick one of two modes
        ;!!!!!!!!this bit needs 2 changes - i) select from the full range of modes - done
        ;                                  ii) choose the appropriate sub variant of NTSC or PAL (bits 3 and 4 page 31 of datasheet)

        CMP     r3,#3                   ;monitor
        BEQ     Select_Clock

        ADR     r7,TV_Modes
        ADR     r8,TV_Modes_End

        ;choose reasonablish defaults
        CMP     r3,#8
        MOVEQ   r6,#2_01101001          ;640*480 NTSC 1/1 24.671MHz
        CMP     r3,#0
        MOVEQ   r6,#2_10000001          ;800*600 PAL 1/1 29.5MHz

Select_Mode_Loop
        LDR     r5,[r7,#4]!
        MOV     r6,r5,LSR#16            ;r6 contains the byte to send to the chrontel
        BIC     r5,r5,#&00ff0000        ;r5 contains an Fpix value
        CMP     r5,r4                   ;have we found the correct mode
        BEQ     Select_Mode_Program
        CMP     r7,r8
        BLT     Select_Mode_Loop
        ;no matching frequency found...

Select_Mode_Program
        ;r3=monitorType
        ;r4=Fpix
        ;r6=contains a value to program into chrontel register 0
        ;still need to modify r6 to take into account NTSC-J and PAL-M

        ;ADD     r1,r12,#IIC_Buffer
        MOV     r0,#0                   ;display mode register
        STRB    r0,[r1,#0]
        STRB    r6,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

Select_Clock
        ;r3 = monitorType
        ;r4 = Fpix
        ;select the closest match
        ;loop over values of M and N
        MOV     r0,#0                   ;M
        MOV     r1,#0                   ;N
        MOV     r3,#14272               ;Get the Fref...
        ADD     r3,r3,#46               ; value that the chrontel is running off

        ADD     r2,r4,r4                ;get the first value of Fpix * (M+2) to check
        ADD     r5,r3,r3                ; and Fref * (N+2)

        MOV     r6,#0                   ;best value of M
        MOV     r7,#0                   ;best value of N
        MOV     r8,#&FF0000             ;best error - random constant that should be plenty big enough

Select_Clock_LoopM

        MOV     r10,#0                  ;flag

Select_Clock_LoopN
        SUBS    r9,r5,r2
        RSBMI   r9,r9,#0                ;make positive
        MOVPL   r10,#1                  ;if the sign of the error is positive we've looked at the smallest error either side of the 'ideal' value
        CMP     r9,r8                   ;new error-old error
        MOVLT   r6,r0
        MOVLT   r7,r1
        MOVLT   r8,r9                   ;remember best values

        ADD     r1,r1,#1                ;next value of N
        ADD     r5,r5,r3                ;add another Fref
        CMP     r1,#1024
        CMPLT   r10,#1                  ;this will go EQ thus breaking out of the loop if we've had a -ve and +ve error
        BLT     Select_Clock_LoopN

        MOV     r1,#0                   ;make N=0
        ADD     r5,r3,r3                ;reset Fref*(N+2)

        ADD     r0,r0,#1                ;next value of M
        ADD     r2,r2,r4                ;Fpix*(M+2)
        CMP     r0,#512
        BLT     Select_Clock_LoopM

        ;should now have best values of N and M and without any MULs
        ;N=r7 M=r6 Error=r8
        ;program chrontel with these values
        ADD     r1,r12,#IIC_Buffer
        AND     r4,r6,#255              ;low bits of M
        AND     r5,r7,#255              ;low bits of N
        MOV     r3,r7,LSR#7             ;bits 8,9 of N go in bit 1,2 of overflow reg.
        BIC     r3,r3,#1                ;clear what was bit 7 of N
        ORR     r3,r3,r6,LSR#8          ;or in bit 0 which is bit 8 of M
        MOV     r2,#&13+64              ;overflow register + auto-inc
        STRB    r2,[r1,#0]
        STRB    r3,[r1,#1]              ;value of overflow
        STRB    r4,[r1,#2]              ;value of M
        STRB    r5,[r1,#3]              ;value of N
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#4
        SWI     XIIC_Control

        CLRV
        Pull    "r0-r10,pc"

Chrontel_Black_Level
        ;enter with monitor type in r3
        ;corrupts r0-r2 (r1 points to IIC buffer though so it might be useful)
        ;0=PAL
        ;3=Monitor - don't change anything
        ;8=NTSC
        CMP     r3,#3
        MOVEQ   pc,lr

        Push    "lr"

        SWI     XTerritory_Number       ;returns territory number in r0
        MOVVS   r0,#TerritoryNum_Default

        MOV     r2,#127                 ;NTSC level is default

        CMP     r3,#0
        MOVEQ   r2,#105                 ;PAL level
        ;CMPEQ   r0,#TerritoryNum_Brazil ;this doesn't exist atm 25/07/2000 but there is _LatinAm   for Latin America
        ;MOVEQ   r2,#127                 ;PAL-M  -  used in Brazil apparently

        CMP     r3,#8
        MOVEQ   r2,#127                 ;NTSC level
        CMPEQ   r0,#TerritoryNum_Japan  ;are we in japan
        MOVEQ   r2,#100                 ;NTSC-J

        ADD     r1,r12,#IIC_Buffer
        MOV     r0,#&09
        STRB    r0,[r1,#0]              ;black level register
        STRB    r2,[r1,#1]              ;black level value
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

        Pull    "pc"

IOMD_Setup
        ; Assume that the processor is in a privilaged mode
        ; true for Mod_Init and Mod_service and PaletteV

        Push    "r0-r1"

        MOV     r0,#IOC
        LDR     r1,[r0,#IOMD_VIDMUX]
        ORR     r1,r1,#1                ;use ECLK to toggle between output of red and green LUTs on VIDC digital port
        STR     r1,[r0,#IOMD_VIDMUX]

        Pull    "r0-r1"
        MOV     pc,lr

VIDC_Parameters
        DCD     2_11000000000001010001000000000100

TV_Modes
        ;table of frequencies V byte to put in display register
        DCW     20139
        DCW     2_00001000              ;2
        DCW     21000
        DCW     2_01100000              ;13
        DCW     21000
        DCW     2_00000000              ;0 - use 13 instead
        DCW     21146
        DCW     2_01001000              ;10
        DCW     23790
        DCW     2_00101000              ;6
        DCW     24671
        DCW     2_01101001              ;16
        DCW     24671
        DCW     2_00001001              ;3 - use 16 instead
        DCW     25000
        DCW     2_01000000              ;8
        DCW     26250
        DCW     2_01100001              ;14
        DCW     26250
        DCW     2_00000001              ;1 - use 14 instead
        DCW     26433
        DCW     2_01001001              ;11
        DCW     28125
        DCW     2_00100000              ;4
        DCW     28195
        DCW     2_01101010              ;17
        DCW     29454
        DCW     2_00101001              ;7
        DCW     29500
        DCW     2_10000001              ;19
        DCW     30209
        DCW     2_01101011              ;18
        DCW     30210   ;should also be 30209 but it's been bodged
        DCW     2_01001010              ;12
        DCW     31500
        DCW     2_01100011              ;15
        DCW     31501   ;should also be 31500
        DCW     2_01000001              ;9
        DCW     34875
        DCW     2_00100001              ;5
        DCW     36000
        DCW     2_10000011              ;20
        DCW     39000
        DCW     2_10000100              ;21
        DCW     39272
        DCW     2_10001011              ;22
        DCW     43636
        DCW     2_10001100              ;23
        DCW     47832
        DCW     2_10001101              ;24
TV_Modes_End

Variable1
        DCB     "Rob$Debug1",0
        ALIGN
Variable2
        DCB     "Rob$Debug2",0
        ALIGN

Standby_Callback
        Push    "r0-r2,lr"

        ADD     r1,r12,#IIC_Buffer
        LDRB    r0,[r12,#ScreenBlankFlag]
        MOV     r2,#&0e
        STRB    r2,[r1,#0]              ;power register
        TST     r0,#1                   ;bit 0 =now in standby mode
        MOVEQ   r2,#2_00001011          ;normal - power on
        MOVNE   r2,#2_00001001          ;00001000 composite off - could also try 00001001 which is power down but if it resets everything i'll not bother
        STRB    r2,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control
        CLRV
        Pull    "r0-r2,pc"

        END

