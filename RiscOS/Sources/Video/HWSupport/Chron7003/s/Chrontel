

; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:PaletteV
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:IIC
        GET     Hdr:NVRAM
        GET     Hdr:Standby
        GET     Hdr:ModeFiles
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Territory
        GET     Hdr:Countries
        GET     Hdr:Machine.<Machine>
        $GetMEMM
        $GetIO

        GET     VersionASM

;Bodge to pack the 9bit vertical value into an 8bit NVRAM location
                        GBLL    NVRAMBodge
NVRAMBodge              SETL    {TRUE}

;IIC address for Chrontel 7003

Chrontel_IIC_Write      * 234           ;&75:SHL:1
Chrontel_IIC_Read       * 235           ;&75:SHL:1 + 1

;Define some constants for the directions we can move in
                        ^ 0
Chrontel_Left           # 1
Chrontel_Right          # 1
Chrontel_Down           # 1
Chrontel_Up             # 1
Chrontel_Reset          # 1

Vert_Step_Size          * 4
Vert_Stop               * 50            ;how far they can move the display in the vertical in both directions
        ASSERT (313 - Vert_Stop) > (255 - 60)  ;check that the vertical stop won't allow the screen to be moved into the region we can't encode
Horiz_Step_Size         * 2
Horiz_Stop              * 50            ;how far they can move the display in the horizontal in both directions
Start_Active_Video      * 0;148
Horiz_Offset            * 8 + Start_Active_Video:SHR:2
Chrontel_Flicker        * 1             ;00=none  01=med  10=low  11=high

;Define the layout of the module workspace (NOT relative to r12)
                        ^ 0
TVLPF                   # 4             ;TV lines per frame - PAL 625, NTSC 525
IIC_Vert                # 4             ; and vertical positions - !!this is bits 0-8 but we need to copy bit 8 this into the overflow!!
IIC_Buffer              # 4*4           ;buffer to prepare IIC transmissions in

IIC_SAV                 # 1             ;last known value of start active video,
IIC_Overflow            # 1             ; overflow - this is a soft copy of the register on the chip
IIC_Black               # 1             ; black level,
IIC_Horiz               # 1             ;last known horizontal - !!this is bits 0-7 of the value - we wil not be using the 8th bit!!

MonitorType             # 1             ;0,8 TV's 3 Monitor - this byte is also used to decide whether to claim/release PaletteV
; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_Commands-Module_BaseAddr
        &       0 ;SWIBase number
        &       0 ;Mod_SWIHandler-Module_BaseAddr
        &       0 ;Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry
        &       0                               ; no internationalised help
        &       Mod_Flags   -Module_BaseAddr

Mod_Title
        =       "Chrontel", 0

Mod_HelpStr
        =       "Chrontel", 9, "$Module_MajorVersion ($Module_Date) 7003 version",0

        ALIGN

Mod_Flags
        &       ModuleFlag_32bit

Mod_Init
        Push    "lr"

        LDR     r2,[r12]                ;do we have some workspace?
        CMP     r2,#0
        BNE     Mod_Init_GotWorkspace   ;if so, don't claim more
        MOV     r0,#6
        MOV     r3,#100
        SWI     XOS_Module
        Pull    "pc",VS                 ;return with error
        STR     r2,[r12]

Mod_Init_GotWorkspace
        MOV     r12,r2                  ;we'll need it at some point
        MOV     r2,#3
        STRB    r2,[r12,#MonitorType]   ;this has to reflect whether or not we've claimed paletteV
        BL      IOMD_Setup

        MOV     r3,#0                   ;default to PAL until things are more worked out

        BL      Chrontel_Setup


        ;MOV     r0,#1
        ;SWI     XModeFiles_MonitorType
        ;MOV     r3,r0                  ;put monitor type in r3 for chrontel_choose_mode
        ;BL      Chrontel_Choose_Mode

        Pull    "pc"

Mod_Die
        Push    "lr"
        LDR     r2,[r12]                ;do we have some memory to give back
        CMP     r2,#0
        MOVNE   r0,#7
        SWINE   XOS_Module
        MOV     r0,#PaletteV
        ADR     r1,Intercept_PaletteV
        ;LDRB    r3,[r12,#MonitorType]
        ;CMP     r3,#3                  ;then do SWINE XOS_Release
        SWI     XOS_Release             ;r2 should still be the pointer to our workspace
        CLRV                            ;release paletteV regardless of whether we think we've claimed it just in case
        Pull    "pc"

Mod_Service
        &       Mod_Service_Table -Module_BaseAddr
        MOV     r0,r0                   ;special instruction to indicate fast service call dispatching
        TEQ     r1,#Service_ModeChange
        TEQNE   r1,#Service_PreModeChange
        ;TEQNE   r1,#Service_Standby
        MOVNE   pc,lr
Mod_Service_Fast
        TEQ     r1,#Service_ModeChange
        BEQ     ModeChange
        TEQ     r1,#Service_PreModeChange
        BEQ     PreModeChange
        TEQ     r1,#Service_Standby
        ;BEQ     Standby
        MOV     pc,lr

Mod_Service_Table
        &       0                       ;flags
        &       Mod_Service_Fast -Module_BaseAddr
        &       Service_ModeChange      ;&46
        &       Service_PreModeChange   ;&4d
        &       Service_Standby         ;&ad
        &       0

Standby
        Push    "r0-r2,lr"
        LDR     r12,[r12]
        ADD     r1,r12,#IIC_Buffer
        MOV     r2,#&0e
        STRB    r2,[r1,#0]              ;power register
        TST     r0,#1                   ;bit 0 =now in standby mode
        MOVEQ   r2,#2_00001011          ;normal - power on
        MOVNE   r2,#2_00001000          ;composite off - could also try 00001001 which is power down but if it resets everything i'll not bother
        STRB    r2,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control
        CLRV
        Pull    "r0-r2,pc"

Intercept_PaletteV
;       TEQ     r4, #paletteV_Read
;        BEQ     PV_ReadPalette
        TEQ     r4, #paletteV_Set
        BEQ     PV_SetPalette
;        TEQ     r4, #paletteV_BulkRead
;        BEQ     PV_BulkRead

        TEQ     r4, #paletteV_1stFlashState
        BEQ     PV_Flash1
        TEQ     r4,#paletteV_2ndFlashState
        BEQ     PV_Flash2

        TEQ     r4, #paletteV_BulkWrite
        BEQ     PV_BulkWrite
        TEQ     r4, #paletteV_SetDefaultPalette
        BEQ     PV_SetDefaultPalette
        ; If none of those, then pass on call
        MOV     pc, lr

Mod_Commands
        =       "Chrontel_Move",0
        ALIGN
        &       Command_Move -Module_BaseAddr
        &       &00020001
        &       Command_Move_Syntax -Module_BaseAddr
        &       Command_Move_Help -Module_BaseAddr

        =       "Chrontel_Status",0
        ALIGN
        &       Command_Status -Module_BaseAddr
        &       &00000000
        &       Command_Status_Syntax -Module_BaseAddr
        &       Command_Status_Help -Module_BaseAddr

        =       "Chrontel_Clocks",0
        ALIGN
        &       Command_Clocks -Module_BaseAddr
        &       &00000000
        &       Command_Clocks_Syntax -Module_BaseAddr
        &       Command_Clocks_Help -Module_BaseAddr

        &       0
        ALIGN

Command_Move_Help
        DCB     "*Chrontel_Move adjusts the position of the browser on the screen",13
Command_Move_Syntax
        DCB     "Syntax: *Chrontel_Move <Up|Down|Left|Right|Reset>",0
        ALIGN

Command_Clocks
        MOV     pc,lr
Command_Clocks_Help
        DCB     "*Chrontel_Clocks lists the available clock rates",13
Command_Clocks_Syntax
        DCB     "Syntax: *Chrontel_Clocks",0
        ALIGN
Command_Status
        MOV     pc,lr
Command_Status_Help
        DCB     "*Chrontel_Status displays the Chrontel's current parameters - need better message",13
Command_Status_Syntax
        DCB     "Syntax: *Chrontel_Status",0
        ALIGN

Command_Move
        ;need to respond to up,down,left,right and reset
        Push    "r0,lr"
        LDR     r12,[r12]

        ;find a colon, if one is present then only check for command after it, else use whole string
        ADR     r3,Command_Move_Table
        MOV     r5,r0                   ;remember the start of the command string in case it has no colon
Command_Move_Find_Colon
        LDRB    r6,[r0],#1
        CMP     r6,#58                  ;":"
        BEQ     Command_Move_Find

        CMP     r6,#32                  ;have we reached end of command
        BGT     Command_Move_Find_Colon
        MOV     r0,r5                   ;if we've not found the colon then use the original command string

Command_Move_Find
        MOV     r5,r0                    ;reset pointer to actual command
Command_Move_Find_Loop
        LDRB    r4,[r3],#1
        LDRB    r6,[r5],#1
        CMP     r4,#0
        BEQ     Command_Move_Check
        CMP     r6,#65
        RSBGES  r1,r6,#90
        ADDGE   r6,r6,#32               ;force lower case
        CMP     r4,r6
        BEQ     Command_Move_Find_Loop

Command_Move_Skip_Command
        CMP     r4,#0                   ;have we reached terminating zero?
        LDRNEB  r4,[r3],#1              ;load next char.
        BNE     Command_Move_Skip_Command
        LDRB    r4,[r3,#1]!             ;skip over code, load first character of next command and make r3 point next command
        CMP     r4,#0                   ;is it the end of the whole table
        BNE     Command_Move_Find

        ;if we reached the end of the table then fall through to here
Command_Move_Unknown
        Pull    "r0,lr"
        ADR     r0,Command_Move_Unknown_Message
        SETV
        MOV     pc,lr

Command_Move_Unknown_Message
        DCD     0
        DCB     "Bad direction - use up, down, left, right, or reset",0
        ALIGN

Command_Move_Table
        ;text, followed by terminating zero, followed by code
        ;bit 0 clear=horizontal set=vertical
        ;bit 1 clear=smaller(left,down) set=bigger(up,right)
        ;bit 2 clear=move set = reset
        ;codes are l=0 r=2,d=1,u=3,r=4
        DCB     "left"
        DCB     0
        DCB     Chrontel_Left

        DCB     "right"
        DCB     0
        DCB     Chrontel_Right

        DCB     "down"
        DCB     0
        DCB     Chrontel_Down

        DCB     "up"
        DCB     0
        DCB     Chrontel_Up

        DCB     "reset"
        DCB     0
        DCB     Chrontel_Reset

        DCB     0                       ;terminate table
        ALIGN

Command_Move_Check
        ;This section of code allows arguments which start the same e.g uplots and upabit
        CMP     r6,#32                  ;\space
        BLE     Command_Move_Do
        CMP     r6,#63                  ;"?"
        BNE     Command_Move_Skip_Command

Command_Move_Do
        ;we now have a valid command and r3 is pointing at it's code number
        LDRB    r2,[r3,#0]              ;load code number
        ADD     r1,r12,#IIC_Buffer      ;set up r1 to point to a buffer
        MOV     r0,#Chrontel_IIC_Write  ;required by SWI IIC_Control

        CMP     r2,#Chrontel_Reset
        BEQ     Chrontel_Move_Reset

        CMP     r2,#Chrontel_Left
        CMPNE   r2,#Chrontel_Right
        BEQ     Chrontel_Move_Horiz

        CMP     r2,#Chrontel_Down
        CMPNE   r2,#Chrontel_Up
        BEQ     Chrontel_Move_Vert
;new commands go here - look how I didn't assume a vertical movement

        Pull    "r0,pc"

Chrontel_Move_Horiz
        ;r0,r1 are ready for IIC_Control
        LDRB    r3,[r12,#IIC_Horiz]
        MOV     r5,r3                   ;make a copy to see if anything has changed
        CMP     r2,#Chrontel_Left
        ADDNE   r3,r3,#Horiz_Step_Size
        SUBEQ   r3,r3,#Horiz_Step_Size

        CMP     r3,#Start_Active_Video                   ;minimum is 0 - should use the horiz_stop here
        MOVLT   r3,#Start_Active_Video
        CMP     r3,#Horiz_Stop+Horiz_Offset     ;maximum is controlled by Horiz_Stop - chip allows 511 but this software only allows 255
        MOVGT   r3,#Horiz_Stop+Horiz_Offset
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STRB    r3,[r12,#IIC_Horiz]     ;store new value
        MOV     r2,#&0a                 ;horizontal register
        STRB    r2,[r1,#0]              ;put horizontal register into IIC block
        STRB    r3,[r1,#1]              ;put horizontal value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        ADR     r0,NVRAM_X
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write

        Pull    "r0,pc"                 ;return preserving r0

Chrontel_Move_Vert
        ;r0,r1 are ready for IIC_Control
        LDR     r3,[r12,#IIC_Vert]      ;this has to be an LDR because IIC_Vert is a 9 bit value
        MOV     r5,r3                   ;make a copy of the value before we alter it
        LDR     r6,[r12,#TVLPF]
        MOV     r6,r6,LSR#1             ;this is the limit that the chrontel 7003 defines [TVLPF-1]/2
        CMP     r2,#Chrontel_Down
        SUBEQ   r3,r3,#Vert_Step_Size
        ADDNE   r3,r3,#Vert_Step_Size

        CMP     r3,#0
        MOVLT   r3,r6
        CMP     r3,r6
        MOVGT   r3,#0

        SUB     r6,r6,#Vert_Stop        ;get a value that limits how low they can go
        CMP     r3,#Vert_Stop           ;is the vertical value greater than 50
        CMPGT   r6,r3                   ;and the upper limit greater than the vertical value
        BLE     Chrontel_Move_Vert_Program

        ;if we fall through to here the vertical value lies between the two limits
        ;so we need to fix it
        CMP     r2,#Chrontel_Down
        ADDEQ   r3,r3,#Vert_Step_Size
        SUBNE   r3,r3,#Vert_Step_Size

Chrontel_Move_Vert_Program
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STR     r3,[r12,#IIC_Vert]      ;store new value
        MOV     r2,#&0b                 ;vertical register
        STRB    r2,[r1,#0]              ;put vertical register into IIC block
        AND     r5,r3,#255              ;get low 8 bits
        STRB    r5,[r1,#1]              ;put low bits of vertical value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        MOV     r3,r3,LSR#8             ;move bit 8 into bit 0
        AND     r3,r3,#1                ;make sure we've only got bit 0
        LDRB    r6,[r12,#IIC_Overflow]  ;get the copy of the overflow register
        BIC     r5,r6,#2_11111110       ;clear everything except current vertical bit
        CMP     r3,r5                   ;are they set the same way?
        Pull    "r0,pc",EQ              ;if so return

        MOV     r0,#Chrontel_IIC_Write
        BIC     r6,r6,#2_00000001       ;clear the relevant bit
        ORR     r6,r6,r3                ;and orr in the new value
        STRB    r6,[r12,#IIC_Overflow]  ;store it in our soft copy
        MOV     r2,#&08                 ;overflow register
        STRB    r2,[r1,#0]
        STRB    r6,[r1,#1]
        MOV     r2,#2
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        ADR     r0,NVRAM_Y
        CMP     r3,#127                 ;is the value in the upper or lower range
        SUBGT   r3,r3,#60               ;upper range so subtract 60
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write

        Pull    "r0,pc"                 ;if there was no error then return preserving r0

Chrontel_Move_Reset
        ;r0,r1 are ready for IIC_Control
        MOV     r2,#8                   ;put overflow register number
        STR     r2,[r1,#0]              ;into IIC buffer
        LDRB    r2,[r12,#IIC_Overflow]  ;load the overflow byte
        AND     r2,r2,#2_11111100       ;zero the horiz and vert bits but leave everything else okay
        STRB    r2,[r1,#1]              ;put it in the block
        STRB    r2,[r12,#IIC_Overflow]  ;and the soft-copy
        MOV     r2,#2                   ;two bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)
        MOV     r0,#Chrontel_IIC_Write  ;IIC_Control helpfully corrupts r0 so we need to restore it

        MOV     r2,#&a+64               ;auto inc from horizontal register (&a)
        STRB    r2,[r1,#0]
        MOV     r2,#Horiz_Offset        ;default horizontal position
        STRB    r2,[r1,#1]
        STRB    r2,[r12,#IIC_Horiz]
        MOV     r2,#0                   ;default vertical position
        STRB    r2,[r1,#2]
        STR     r2,[r12,#IIC_Vert]
        MOV     r2,#3                   ;3 bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)

        MOV     r2,#Horiz_Offset        ;default horizontal position
        STR     r2,[r1,#0]
        MOV     r2,#0
        ADR     r0,NVRAM_X
        SWI     XNVRAM_Write

        MOV     r2,#0                   ;default vertical
        STR     r2,[r1,#0]
        MOV     r2,#0
        ADR     r0,NVRAM_Y
        SWI     XNVRAM_Write

        Pull    "r0,pc"

NVRAM_X
        =       "DisplayXPosition",0
NVRAM_Y
        =       "DisplayYPosition",0
        ALIGN

Chrontel_Setup
        ; Setup the chrontel hardware using the IIC bus
        ; this stuff is only done once i.e the stuff that is not mode or monitor dependant
        ; power up - reset - power up
        Push    "lr"
        ADD     r1,r12,#IIC_Buffer

        MOV     r2,#&0E                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00000011          ;power up and do reset
        STRB    r2,[r1,#1]
        MOV     r2,#2                   ;send 2 bytes
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#&0E                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00001011          ;power up and clear reset condition
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#64+0                ;display settings register (0) with auto inc (64)
        STRB    r2,[r1,#0]
        MOV     r2,#2_10000001          ;800x600 PAL 1-1 (29.5MHz) 640x480=%01100001
        STRB    r2,[r1,#1]
        MOV     r2,#Chrontel_Flicker    ;flicker reduction 00=none 01=med 10=low 11=high
        STRB    r2,[r1,#2]
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#4                   ;data format register
        STRB    r2,[r1,#0]
        MOV     r2,#2_00001000          ;pixel data set to 8bit multiplex 5-5-5
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                  ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#6                   ;control register
        STRB    r2,[r1,#0]
        MOV     r2,#2_01000000          ;CFRB off, master mode on, x, data is latched on negative edge, xcm1, xcm0, pcm1, pcm0
                                        ;data latched on negative edge means that the red LUT corresponds to P0b (G2 G1 G0 B4 B3 B2 B1 B0)
                                        ;                                   and the green LUT corresponds to P0a (xx R4 R3 R2 R1 R0 G4 G3)
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write                 ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        ADR     r0,NVRAM_X              ;NVRAM tag
        MOV     r2,#0                   ;read into first word of r1
        SWI     XNVRAM_Read
        CMP     r0,#0                   ;error?
        LDRGE   r4,[r1,#0]              ;if not load up the value
        MOVLT   r4,#Horiz_Offset        ;default value if there is a problem reading NVRAM
        STRB    r4,[r12,#IIC_Horiz]     ;our soft copy


        ;the vertical position ranges between 0 and TVLPF/2 (313 max) which is too big to fit into 8bits
        ;however we don't use the middle of this range 50-200 (ish) so a cunning bodge allows us to fit the 9bit value into 8bits
        ;bit 7 clear indicates that the value is in the low range so we simply use the value
        ;bit 7 set indicates upper range so add 60 which gives a range of 188-315 (min required=262-stop value  max required=313)
        ADR     r0,NVRAM_Y
        MOV     r2,#0
        SWI     XNVRAM_Read
        CMP     r0,#0
        LDRGE   r5,[r1,#0]
        MOVLT   r5,#0                   ;default value
 [ NVRAMBodge
        TST     r5,#2_10000000          ;is bit 7 set?
        ADDNE   r5,r5,#60
 ]
        STR     r5,[r12,#IIC_Vert]      ;our soft copy

        MOV     r2,#64+&07              ;start active video register
        STRB    r2,[r1,#0]              ;address in block
        MOV     r2,#Start_Active_Video
        STRB    r2,[r1,#1]              ;SAV value in block     - limited to <=255
        MOV     r2,r5,LSR#8             ;make bit 8 into bit 0
        AND     r2,r2,#1                ;clear other bits
        STRB    r2,[r1,#2]              ;Overflow value in block
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#64+&0a              ;horizontal register
        STRB    r2,[r1,#0]              ;address in block
        STRB    r4,[r1,#1]              ;horizontal
        STRB    r5,[r1,#2]              ;vertical
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        ;MOV     r2,#64+&13              ;PLL registers starting (&13) with auto-inc (64)
        ;STRB    r2,[r1,#0]
        ;MOV     r2,#2_00000101
        ;STRB    r2,[r1,#1]
        ;MOV     r2,#57
        ;STRB    r2,[r1,#2]
        ;MOV     r2,#135
        ;STRB    r2,[r1,#3]
        ;MOV     r2,#4
        ;MOV     r0,#Chrontel_IIC_write                  ;put device address in r0
        ;SWI     XIIC_Control
        ;BVS     Chrontel_Failed

Chrontel_Failed
        CLRV                            ;in case one of the IIC_Control caused an error

        Pull    "pc"


PV_SetPalette
        ;r0  logical colour
        ;r1  type (not really important)
        ;r2  1st flash colour
        ;r3  2nd flash colour
        ;r4  reason code (2 in this case)
        ;incoming format is &BBGGRRxx (32bit word)
        ;chrontel format is G2 G1 G0 B4 B3 B2 B1 B0  and  XX R4 R3 R2 R1 R0 G4 G3 in the red and green registers
        Push "r2,r3,r5-r7,r10,r11,lr"

        MOV r4,#2_11111000              ;mask to extract top 5 bits of each colour

        ;first colour
        AND     r5,r4,r2,LSR#8          ;top 5 bits red
        AND     r6,r4,r2,LSR#16         ;top 5 bits green
        AND     r7,r4,r2,LSR#24         ;top 5 bits blue
        AND     r4,r2,#&ff000000        ;isolate blue (we include this so that it appears on the monitor - it won't be used by chrontel)
        ORR     r4,r4,r5,LSL#15         ;move red into bits 22-18 (15+3 clear low bits=18)
        ORR     r4,r4,r6,LSL#10         ;put green at 17-13
        ORR     r2,r4,r7,LSL#5          ;put blue at 12-8

        ;second colour
        AND     r5,r4,r3,LSR#8          ;top 5 bits red
        AND     r6,r4,r3,LSR#16         ;top 5 bits green
        AND     r7,r4,r3,LSR#24         ;top 5 bits blue
        AND     r4,r3,#&ff000000        ;isolate blue (we include this so that it appears on the monitor - it won't be used by chrontel)
        ORR     r4,r4,r5,LSL#15         ;move red into bits 22-18 (15+3 clear low bits=18)
        ORR     r4,r4,r6,LSL#10         ;put green at 17-13
        ORR     r3,r4,r7,LSL#5          ;put blue at 12-8

        MOV     r4,#2                   ;fix up r4 - the reason code

        Push    "pc"                    ;put pc+8 (StrongARM) or pc+12 (other ARMs) on to stack
        MOV     pc,lr                   ;pass on the call

        NOP                             ;StrongARM comes back here

        Pull    "r2,r3,r5-r7,r10,r11,lr,pc"     ;make sure we return the original value in r2 and r3

PV_SetDefaultPalette

        Push    "r0-r3,r5-r6,r10-r12,lr"

        ; Get the VDU variables that we need
        MOV     r0, #0                  ; ModeFlags variable
        MOV     r1, #3                  ; NColour variable
        MOV     r2, #-1                 ; terminator for input list
        SUB     sp, sp, #4*2            ; create output block on stack
        Push    "r0-r2"                 ; create input block on stack
        MOV     r0, sp
        ADD     r1, sp, #4*3
        SWI     XOS_ReadVduVariables
        MOV     sp, r1                  ; jump over input block on stack
        Pull    "r5,r6"                 ; r5 = ModeFlags, r6 = NColour
        BVS     %FT98

        CMP     r6, #255                ; by default,
        ADDCC   r1, r6, #1              ;   program NColour+1 palette entries
        MOVCS   r1, #256                ;   or 256, whichever is the minimum
        TEQ     r6, #1                  ; 1bpp?
        ADREQ   r2, defpal_1bpp
        TEQ     r6, #3                  ; 2bpp?
        ADREQ   r2, defpal_2bpp
        TEQ     r6, #63                 ; 8bpp, VIDC-1 compatible mode?
        BEQ     PV_SetDefaultPalette_64 ; if it's an old mode use our special routine
        TEQ     r6, #255                ; 8bpp, VIDC-20 mode
        ADREQ   r2, defpal_8bpp

        MOV     r3, r2                  ; for all of above, the flash states are the same
        TEQ     r6, #15                 ; 4bpp?
        ADREQ   r2, defpal_4bpp_1
        ADREQ   r3, defpal_4bpp_2
        TST     r5, #2                  ; teletext mode?
        ADRNE   r3, defpal_4bpp_1       ; don't flash colours
                                        ; note, no transparent default colours any more

        MOV     r0, #0                  ; program from palette entry 0 upwards
        ORR     r1, r1, #17:SHL:24      ; program flash state 1
        MOV     r4, #paletteV_BulkWrite
        STR     pc, [sp, #-4]!          ; push claimant return address onto stack
        LDR     pc, [sp, #4*10]         ; goto pass-on (skip pc,r0-r3,r5-r6,r10-r12)
        NOP
        TEQ     r4, #paletteV_Complete  ; BulkWrite not successful?
        BNE     %FT98

        ADD     r10, sp, #4*6
        LDMIA   r10, {r10-r12}          ; restore original r10-r12 from stack
        BIC     r1, r1, #&FF000000
        ORR     r1, r1, #18:SHL:24      ; program flash state 2
        MOV     r2, r3
        MOV     r4, #paletteV_BulkWrite
        STR     pc, [sp, #-4]!          ; push claimant return address onto stack
        LDR     pc, [sp, #4*10]         ; goto pass-on (skip pc,r0-r3,r5-r6,r10-r12)
        NOP
        TEQ     r4, #paletteV_Complete  ; BulkWrite not successful?
        BNE     %FT98

        ADD     r10, sp, #4*6
        LDMIA   r10, {r10-r12}          ; restore original r10-r12 from stack
        MOV     r0, #0
        MOV     r1, #24
        MOV     r2, #&00000000
        MOV     r4, #paletteV_Set       ; set border to solid black
        STR     pc, [sp, #-4]!          ; push claimant return address onto stack
        LDR     pc, [sp, #4*10]         ; goto pass-on (skip pc,r0-r3,r5-r6,r10-r12)
        NOP
        TEQ     r4, #paletteV_Complete  ; BulkWrite successful?
        BEQ     %FT99

98      ; Jumps here if there was any sort of error: claims vector, but doesn't mark
        ; operation as having been completed
        CLRV
        MOV     r4, #paletteV_SetDefaultPalette

99      ; Restore r0-r3,r5-r6,r10-r12,lr to the values they had originally, and jump to
        ; the return address supplied for claiming the call
        Pull    "r0-r3,r5-r6,r10-r12,lr,pc"

PV_SetDefaultPalette_64
        MOV     r0,#VIDC
        MOV     r1,#1<<28+0             ;program address register with value 0
        STR     r1,[r0]

        MOV     r3,#256
        ADR     r2,defpal_8bpp
PV_SetDefaultPalette_64_Loop
        LDR     r1,[r2],#4              ;load a word and post-inc
        MOV     r1,r1,LSR#8             ;put into format expected by VIDC
        STR     r1,[r0]                 ;send word to VIDC
        SUBS    r3,r3,#1
        BNE     PV_SetDefaultPalette_64_Loop
        MOV     r4,#paletteV_Complete   ;we completed the operation succesfully
        Pull    "r0-r3,r5-r6,r10-r12,lr,pc"     ;claim vector

PV_BulkWrite
        Push    "r0-r3,r5-r6,r10-r12,lr,pc"
        B       PV_SetDefaultPalette_64
        NOP
        Pull    "pc"

PV_Flash1
        ;drops through to below
        ;when we have our own copies of the required colours we need to program the other set so the routine will be slightly different
        ;e.g use a different base address when reading our table of colours
PV_Flash2
        ;if we are in 63+TINT mode then do this from out own copies of the required colours
        ;else let the kernal do it with it's copies of the palette
        Push    "r0-r2,lr"
        MVN     r0,#0
        MOV     r1,#3
        SWI     XOS_ReadModeVariable
        CMP     r2,#63
        Pull    "r0-r2,pc",NE           ;not a silly mode so do MOV pc,lr and pass on
        ;do prgramming from our own soft copies
        ;which we don't have atm.....
        ;and claim routine
        MOV     r4,#paletteV_Complete   ;we completed the operation succesfully
        Pull    "r0-r2,lr,pc"


        GBLA    Counter
        GBLA    PEntry

defpal_1bpp
        ;       &BBGGRRXX
        &       &0              ; black
        &       &FF7FFF00       ; white
defpal_2bpp
        &       &0              ; black
        &       &007C0000       ; red
        &       &007FE000       ; yellow
        &       &FF7FFF00       ; white
defpal_4bpp_1
        &       &00000000       ; black
        &       &007C0000       ; red
        &       &0003E000       ; green
        &       &007FE000       ; yellow
        &       &FF001F00       ; blue
        &       &FF7C1F00       ; magenta
        &       &FF03FF00       ; cyan
        &       &FF7FFF00       ; white
        &       &00000000       ; black-white flash
        &       &7C0000         ; red-cyan flash
        &       &3E000          ; green-magenta flash
        &       &7FE000         ; yellow-blue flash
        &       &FF001F00       ; blue-yellow flash
        &       &FF7C1F00       ; magenta-green flash
        &       &FF03FF00       ; cyan-red flash
        &       &FF7FFF00       ; white-black flash
defpal_4bpp_2
        &       &0              ; black
        &       &7C0000         ; red
        &       &3E000          ; green
        &       &007FE000       ; yellow
        &       &FF001F00       ; blue
        &       &FF7C1F00       ; magenta
        &       &FF03FF00       ; cyan
        &       &FF7FFF00       ; white
        &       &FF7FFF00       ; black-white flash
        &       &FF03FF00       ; red-cyan flash
        &       &FF7C1F00       ; green-magenta flash
        &       &FF001F00       ; yellow-blue flash
        &       &7FE000         ; blue-yellow flash
        &       &3E000          ; magenta-green flash
        &       &7C0000         ; cyan-red flash
        &       &0              ; white-black flash

defpal_8bpp

        GBLA Counter
        GBLA PEntry

Counter SETA    0
        WHILE   Counter < 256
PEntry  SETA    &00000000             ;nothing set to begin with
      [ Counter :AND: 1 = 1  ;bbbbbbbbxRRRRRGGGGGBBBBB--------
PEntry  SETA    PEntry :OR: 2_00010001000010000100001000000000  ; tint bit 0
      ]
      [ Counter :AND: 2 = 2
PEntry  SETA    PEntry :OR: 2_00100010000100001000010000000000  ; tint bit 1
      ]
      [ Counter :AND: 4 = 4
PEntry  SETA    PEntry :OR: 2_00000000001000000000000000000000  ; red bit 2 (corresponds to r3 which is output in green data)
      ]
      [ Counter :AND: 8 = 8
PEntry  SETA    PEntry :OR: 2_01000100000000000000100000000000  ; blue bit 2
      ]
      [ Counter :AND: 16 = 16
PEntry  SETA    PEntry :OR: 2_00000000010001000000000000000000  ; red bit 3  also turn on extra least sig. bit to produce full intensity
      ]
      [ Counter :AND: 32 = 32
PEntry  SETA    PEntry :OR: 2_00000000000000010000000000000000  ; green bit 2
      ]
      [ Counter :AND: 64 = 64
PEntry  SETA    PEntry :OR: 2_00000000000000100010000000000000  ; green bit 3  also turn on extra least sig. bit to produce full intensity
      ]
      [ Counter :AND: 128 = 128
PEntry  SETA    PEntry :OR: 2_10001000000000000001000100000000  ; blue bit 3  also turn on extra least sig. bit to produce full intensity
      ]
        &       PEntry
Counter SETA    Counter + 1
        WEND


PreModeChange
        ;a) check the colour depth <= 256 colours
        ;r2 is mode
        Push    "r0-r2,lr"
        LDR     r12,[r12]
        MOV     r0,r2                   ;we want to know about the suggested mode in r2
        MOV     r1,#9                   ;ask for LOG to base 2 of BPP
        SWI     XOS_ReadModeVariable
        Pull    "r0-r2,pc",CS           ;if something went wrong then return saying mode is okay - should we default to say mode not okay?
        CMP     r2,#4
        Pull    "r0-r2,lr"
        MOVGE   r1,#0
        MOVGE   r0,#0
        MOV     pc,lr

        ;some code to set Variable1 rob$debug1 to the value of r3
        ;Push    "r0-r4"
        ;ADRL     r0,Variable1
        ;ADD     r1,r12,#IIC_Buffer
        ;STR     r3,[r1,#0]
        ;MOV     r2,#0
        ;MOV     r3,#0
        ;MOV     r4,#1
        ;SWI     XOS_SetVarVal
        ;Pull    "r0-r4"

ModeChange
        ;called when Service_ModeChange issued
        ;need to make sure the VIDC and IOMD are doing the right thing
        ;need to select an appropriate clock speed - this is only dependant on the mode not monitor type
        ;only permissible modes will get here because we'll trap them in PreModeChange
        ;r3 is monitor type which we need to know about
        ;0 : PAL TV
        ;3 : VGA MONITOR
        ;8 : NTSC TV
        LDR     r12,[r12]

Chrontel_Mode
        ;choose a black level based on NTSC[-J] or PAL[ M], TV type and territory
        ;choose PLL values to match clock
        ;if TV then look up clock speed and cross reference this to a chrontel mode
        ;nice if it could be called directly from Service_ModeChange
        ;r3 is monitor type
        ;we'll always be in the mode we are working out values for so we don't need to know the mode
        Push    "r0-r10,lr"

        CMP     r3,#0
        CMPNE   r3,#8
        CMPNE   r3,#3                   ;known type of display?
        BEQ     Chrontel_Mode_KnownType ;if so we can use it directly

        SWI     XModeFiles_MonitorType  ;otherwise read the actual type
        MOVVC   r3,r0                   ;put it in r3
        MOVVS   r3,#0                   ;if we couldn't get an answer from ModeFiles then assume PAL TV
Chrontel_Mode_KnownType

        ;MOV     r3,#0                   ;lock to PAL TV until the ModeFiles module is rebuilt with (old style) ChrontelSupport switched off!
        MOV     r3,#3                   ;lock to Monitor

        MOV     r0,#PaletteV
        ADRL    r1,Intercept_PaletteV
        MOV     r2,r12
        LDRB    r4,[r12,#MonitorType]   ;previous monitor type
        CMP     r3,#0
        CMPNE   r3,#8                   ;is it a television?
        BEQ     Chrontel_Mode_Claim     ;yes, so goto TV

        ;falls through here if monitor
        CMP     r4,#3                   ;previously monitor?
        SWINE   XOS_Release             ;if not then release vector
        B       Chrontel_Mode_Skip3

Chrontel_Mode_Claim
        ;arrives here if television
        CMP     r4,#3                   ;previously monitor?
        SWIEQ   XOS_Claim               ;if so then claim vector
        ;B       Chrontel_Mode_Skip3

Chrontel_Mode_Skip3
        STRB    r3,[r12,#MonitorType]   ;make a record of what we've decided to go with


        BL      Chrontel_Black_Level


        ;when moving the display  around on screen we need to know how many lines per frame
        ;default to 624 lines - this is what will happen with monitors (type 3) but since
        ; the chrontel doesn't move the display around on monitors so it don't matter
        MOV     r4,#624
        CMP     r3,#8
        MOVEQ   r4,#524                 ;NTSC lines
        CMP     r3,#0
        MOVEQ   r4,#624                 ;PAL lines
        STR     r4,[r12,#TVLPF]

        ;the kernal will invariably scrub over the changes we've made because it didn't know about them
        MOV     r0,#VIDC
        LDR     r1,VIDC_Parameters      ;make sure VIDC is doing the right stuff
        STR     r1,[r0]

        ;find pixel rate required by this mode
        ADD     r0,r12,#IIC_Buffer
        MOV     r1,r0                   ;use the same block for input and output
        MOV     r2,#173                 ;clock rate
        STR     r2,[r0,#0]
        MVN     r2,#0                   ;current mode r2=-1
        STR     r2,[r0,#4]
        SWI     XOS_ReadVduVariables
        LDR     r2,[r0,#0]              ;Fpix

        ;pick a mode based on this and PAL/NTSC choice - don't need to bother if it's a monitor
        ;to begin with pick one of two modes
        ;!!!!!!!!this bit needs 2 changes - i) select from the full range of modes
        ;                                  ii) choose the appropriate sub variant of NTSC or PAL (bits 3 and 4 page 31 of datasheet)

        CMP     r3,#3                   ;monitor
        BEQ     Chrontel_Mode_Select_Clock
        CMP     r3,#8
        MOVEQ   r4,#2_01001001          ;640*480 NTSC 1/1 26.433MHz
        MOVNE   r4,#2_10000001          ;800*600 PAL 1/1 29.5MHz
        MOV     r5,r2                   ;preserve r2
        ADD     r1,r12,#IIC_Buffer
        MOV     r0,#0                   ;display mode register
        STRB    r0,[r1,#0]
        STRB    r4,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control
        MOV     r2,r5                   ;restore r2

Chrontel_Mode_Select_Clock
        ;select the closest match
        ;loop over values of M and N
        MOV     r0,#0                   ;M
        MOV     r1,#0                   ;N
        MOV     r3,#14272               ;Get the Fref...
        ADD     r3,r3,#46               ; value that the chrontel is running off

        ADD     r4,r2,r2                ;get the first value of Fpix * (M+2) to check
        ADD     r5,r3,r3                ; and Fref * (N+2)

        MOV     r6,#0                   ;best value of M
        MOV     r7,#0                   ;best value of N
        MOV     r8,#&FF0000             ;best error - random constant that should be plenty big enough

Select_Clock_LoopM

        MOV     r10,#0                  ;flag

Select_Clock_LoopN
        SUBS    r9,r5,r4
        RSBMI   r9,r9,#0                ;make positive
        MOVPL   r10,#1                  ;if the sign of the error is positive we've looked at the smallest error either side of the 'ideal' value
        CMP     r9,r8                   ;new error-old error
        MOVLT   r6,r0
        MOVLT   r7,r1
        MOVLT   r8,r9                   ;remember best values

        ADD     r1,r1,#1                ;next value of N
        ADD     r5,r5,r3                ;add another Fref
        CMP     r1,#1024
        CMPLT   r10,#1                  ;this will go EQ thus breaking out of the loop if we've had a -ve and +ve error
        BLT     Select_Clock_LoopN

        MOV     r1,#0                   ;make N=0
        ADD     r5,r3,r3                ;reset Fref*(N+2)

        ADD     r0,r0,#1                ;next value of M
        ADD     r4,r4,r2                ;Fpix*(M+2)
        CMP     r0,#512
        BLT     Select_Clock_LoopM

        ;should now have best values of N and M and without any MULs
        ;N=r7 M=r6 Error=r8
        ;program chrontel with these values
        ADD     r1,r12,#IIC_Buffer
        AND     r4,r6,#255              ;low bits of M
        AND     r5,r7,#255              ;low bits of N
        MOV     r3,r7,LSR#7             ;bits 8,9 of N go in bit 1,2 of overflow reg.
        BIC     r3,r3,#1                ;clear what was bit 7 of N
        ORR     r3,r3,r6,LSR#8          ;or in bit 0 which is bit 8 of M
        MOV     r2,#&13+64              ;overflow register + auto-inc
        STRB    r2,[r1,#0]
        STRB    r3,[r1,#1]              ;value of overflow
        STRB    r4,[r1,#2]              ;value of M
        STRB    r5,[r1,#3]              ;value of N
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#4
        SWI     XIIC_Control

        CLRV

        Pull    "r0-r10,pc"

Chrontel_Black_Level
        ;enter with monitor type in r3
        ;corrupts r0-r2 (r1 points to IIC buffer though so it might be useful)
        ;0=PAL
        ;3=Monitor - don't change anything
        ;8=NTSC
        CMP     r3,#3
        MOVEQ   pc,lr

        Push    "lr"

        SWI     XTerritory_Number       ;returns territory number in r0
        MOVVS   r0,#TerritoryNum_Default

        MOV     r2,#127                 ;NTSC level is default

        CMP     r3,#0
        MOVEQ   r2,#105                 ;PAL level
        ;CMPEQ   r0,#TerritoryNum_Brazil ;this doesn't exist atm 25/07/2000 but there is _LatinAm   for Latin America
        ;MOVEQ   r2,#127                 ;PAL-M  -  used in Brazil apparently

        CMP     r3,#8
        MOVEQ   r2,#127                 ;NTSC level
        CMPEQ   r0,#TerritoryNum_Japan  ;are we in japan
        MOVEQ   r2,#100                 ;NTSC-J

        ADD     r1,r12,#IIC_Buffer
        MOV     r0,#&09
        STRB    r0,[r1,#0]              ;black level register
        STRB    r2,[r1,#1]              ;black level value
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

        Pull    "pc"

IOMD_Setup
        ; Assume that the processor is in a privilaged mode
        ; true for Mod_Init and Mod_service and PaletteV

        Push    "r0-r1"

        MOV     r0,#IOC
        LDR     r1,[r0,#IOMD_VIDMUX]
        ORR     r1,r1,#1                ;use ECLK to toggle between output of red and green LUTs on VIDC digital port
        STR     r1,[r0,#IOMD_VIDMUX]

        Pull    "r0-r1"
        MOV     pc,lr

VIDC_Parameters
        DCD     2_11000000000001010001000000000100

TV_Modes
        DCD     20139
        DCD     21000
        DCD     21000
        DCD     21146
        DCD     23790
        DCD     24671
        DCD     24671
        DCD     25000
        DCD     26250
        DCD     26250
        DCD     26433
        DCD     28125
        DCD     28195
        DCD     29454
        DCD     29500
        DCD     30209
        DCD     30209
        DCD     31500
        DCD     31500
        DCD     34875
        DCD     36000
        DCD     39000
        DCD     39272
        DCD     43636
        DCD     47832

Variable1
        DCB     "Rob$Debug1",0
        ALIGN
Variable2
        DCB     "Rob$Debug2",0
        ALIGN


        END

