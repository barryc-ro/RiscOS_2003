m

; Included headers
; ----------------

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:PaletteV
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:IIC
        GET     Hdr:NVRAM
        ;GET     Hdr:Standby
        GET     Hdr:ModeFiles
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Territory
        GET     Hdr:Countries
        GET     Hdr:Machine.<Machine>
        GET     Hdr:Proc
        GET     Hdr:HALEntries
        $GetMEMM
        $GetIO

; Chrontel register numbers
DMR     *       &00
FFR     *       &01
VBW     *       &03
IDF     *       &04
CM      *       &06
SAV     *       &07
PO      *       &08
BLR     *       &09
HPR     *       &0A
VPR     *       &0B
SPR     *       &0D
PMR     *       &0E
CDR     *       &10
CE      *       &11
MNE     *       &13
PLLM    *       &14
PLLN    *       &15
BCO     *       &17
FSCI    *       &18
PLLC    *       &20
CIVC    *       &21
CIV     *       &22
VID     *       &25
TR      *       &26
AR      *       &2A
AutoInc *       &40

VID_7003 *      &02
VID_7005 *      &3A

        GET     VersionASM
;Bodge to pack the 9bit vertical value into an 8bit NVRAM location
                        GBLL    NVRAMBodge
NVRAMBodge              SETL    {TRUE}

;IIC address for Chrontel 7003

 [ :DEF: IICAddress
Chrontel_IIC_Write      * IICAddress
 |
Chrontel_IIC_Write      * &EA
 ]
Chrontel_IIC_Read       * Chrontel_IIC_Write + 1

 [ :LNOT: :DEF: RGB
                        GBLL    RGB
RGB                     SETL    {FALSE}
 ]

 [ :LNOT: :DEF: Slave
                        GBLL    Slave
Slave                   SETL    {FALSE}
 ]

 [ RGB
PMR_Reset               * 2_00010011
PMR_On                  * 2_00011011
PMR_PowerSave           * PMR_On         ; leave it on for now
 |
PMR_Reset               * 2_00000011
PMR_On                  * 2_00001011
PMR_PowerSave           * 2_00001000     ; Composite off only (?)
 ]

;Define some constants for the directions we can move in
                        ^ 0
Chrontel_Left           # 1
Chrontel_Right          # 1
Chrontel_Down           # 1
Chrontel_Up             # 1
Chrontel_Reset          # 1

Vert_Step_Size          * 4
Vert_Stop               * 50            ;how far they can move the display in the vertical in both directions
 [ NVRAMBodge
        ASSERT (313 - Vert_Stop) > (255 - 60)  ;check that the vertical stop won't allow the screen to be moved into the region we can't encode
 ]
Horiz_Step_Size         * 2
Horiz_Stop              * 50            ;how far they can move the display in the horizontal in both directions
Start_Active_Video      * 134           ;alterered value requested by MPT
Start_Active_Video_7005 * 40
Horiz_Offset            * 32            ;alterered value requested by MPT
Chrontel_Flicker_7003   * 1             ;00=none  01=med  10=low  11=high
Chrontel_Flicker_7005   * 2_101001      ;max chroma filter, max luma filter, slight text enhancement

;Define the layout of the module workspace (NOT relative to r12)
                        ^ 0
TVLPF                   # 4             ;TV lines per frame - PAL 625, NTSC 525
IIC_Vert                # 4             ; and vertical positions - !!this is bits 0-8 but we need to copy bit 8 this into the overflow!!
IIC_Buffer              # 4*10           ;buffer to prepare IIC transmissions in and various other stuff like ReadVduVariables

IIC_SAV                 # 1             ;last known value of start active video,
IIC_Overflow            # 1             ; overflow - this is a soft copy of the register on the chip
IIC_Black               # 1             ; black level,
IIC_Horiz               # 1             ;last known horizontal - !!this is bits 0-7 of the value - we wil not be using the 8th bit!!

MonitorType             # 1             ;0,8 TV's +  3 Monitor - this byte is also used to decide whether to claim/release PaletteV
ScreenBlankFlag         # 1             ;screen blanked?
Chrontel_VID            # 1
Dummy                   # 1
                        AlignSpace
WorkspaceSize           # 0

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_Commands-Module_BaseAddr
        &       0 ;SWIBase number
        &       0 ;Mod_SWIHandler-Module_BaseAddr
        &       0 ;Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry
        &       0                               ; no internationalised help
        &       Mod_Flags   -Module_BaseAddr

Mod_Title
        =       "Chrontel", 0

Mod_HelpStr
        =       "Chrontel", 9, "$Module_MajorVersion ($Module_Date) 7003 version",0

Chrontel_Var
        =       "Alias$URLOpenCLI_Chrontel_Move",0
Chrontel_Var_Val
        =       "Chrontel_Move %*0",0
Chrontel_Var_Val_End
        ALIGN

Mod_Flags
        &       ModuleFlag_32bit

Mod_Init
        Push    "lr"

        LDR     r2,[r12]                ;do we have some workspace?
        CMP     r2,#0
        BNE     Mod_Init_GotWorkspace   ;if so, don't claim more
        MOV     r0,#6
        LDR     r3,=WorkspaceSize
        SWI     XOS_Module
        Pull    "pc",VS                 ;return with error
        STR     r2,[r12]

Mod_Init_GotWorkspace
        MOV     r12,r2                  ;we'll need it at some point

        ;set up the system variable containing our movement command that allows the browser to communicate with us
        ADR     r0,Chrontel_Var
        ADR     r1,Chrontel_Var_Val
        MOV     r2,#Chrontel_Var_Val_End-Chrontel_Var_Val
        MOV     r3,#0
        MOV     r4,#0
        SWI     XOS_SetVarVal

        BL      PaletteV_Setup
        BL      Chrontel_Setup

        Pull    "pc"


Mod_Die
        Push    "lr"
        LDR     r2,[r12]                ;do we have some memory to give back
        CMP     r2,#0
        MOVNE   r0,#7
        SWINE   XOS_Module
        MOV     r0,#PaletteV
        ADRL    r1,Chron_MOSPaletteV
        ;LDRB    r3,[r12,#MonitorType]
        ;CMP     r3,#3                  ;then do SWINE XOS_Release
        SWI     XOS_Release             ;r2 should still be the pointer to our workspace
        CLRV                            ;release paletteV regardless of whether we think we've claimed it just in case
        Pull    "pc"

        &       Mod_Service_Table -Module_BaseAddr
Mod_Service
        MOV     r0,r0                   ;special instruction to indicate fast service call dispatching
        TEQ     r1,#Service_ModeChange
;        TEQNE   r1,#Service_PreModeChange
        TEQNE   r1,#Service_ModeChanging
        MOVNE   pc,lr
Mod_Service_Fast
        TEQ     r1,#Service_ModeChange
        BEQ     ModeChange
;        TEQ     r1,#Service_PreModeChange
;        BEQ     PreModeChange
        TEQ     r1,#Service_ModeChanging
        BEQ     ModeChanging
        MOV     pc,lr

Mod_Service_Table
        &       0                       ;flags
        &       Mod_Service_Fast -Module_BaseAddr
        &       Service_ModeChange      ;&46
;        &       Service_PreModeChange   ;&4d
        &       Service_ModeChanging    ;&89
        &       0

Mod_Commands
        =       "Chrontel_Move",0
        ALIGN
        &       Command_Move -Module_BaseAddr
        &       &00020001
        &       Command_Move_Syntax -Module_BaseAddr
        &       Command_Move_Help -Module_BaseAddr

        =       "Chrontel_Status",0
        ALIGN
        &       Command_Status -Module_BaseAddr
        &       &00000000
        &       Command_Status_Syntax -Module_BaseAddr
        &       Command_Status_Help -Module_BaseAddr

        =       "Chrontel_Clocks",0
        ALIGN
        &       Command_Clocks -Module_BaseAddr
        &       &00000000
        &       Command_Clocks_Syntax -Module_BaseAddr
        &       Command_Clocks_Help -Module_BaseAddr

        &       0
        ALIGN

Command_Move_Help
        DCB     "*Chrontel_Move adjusts the position of the browser on the screen",13
Command_Move_Syntax
        DCB     "Syntax: *Chrontel_Move <Up|Down|Left|Right|Reset>",0
        ALIGN

Command_Clocks
        MOV     pc,lr
Command_Clocks_Help
        DCB     "*Chrontel_Clocks lists the available clock rates",13
Command_Clocks_Syntax
        DCB     "Syntax: *Chrontel_Clocks",0
        ALIGN
Command_Status
        MOV     pc,lr
Command_Status_Help
        DCB     "*Chrontel_Status displays the Chrontel's current parameters - need better message",13
Command_Status_Syntax
        DCB     "Syntax: *Chrontel_Status",0
        ALIGN

Command_Move
        ;need to respond to up,down,left,right and reset
        Push    "r0,lr"
        LDR     r12,[r12]

        ;find a colon, if one is present then only check for command after it, else use whole string
        ADR     r3,Command_Move_Table
        MOV     r5,r0                   ;remember the start of the command string in case it has no colon
Command_Move_Find_Colon
        LDRB    r6,[r0],#1
        CMP     r6,#58                  ;":"
        BEQ     Command_Move_Find

        CMP     r6,#32                  ;have we reached end of command
        BGT     Command_Move_Find_Colon
        MOV     r0,r5                   ;if we've not found the colon then use the original command string

Command_Move_Find
        MOV     r5,r0                    ;reset pointer to actual command
Command_Move_Find_Loop
        LDRB    r4,[r3],#1
        LDRB    r6,[r5],#1
        CMP     r4,#0
        BEQ     Command_Move_Check
        CMP     r6,#65
        RSBGES  r1,r6,#90
        ADDGE   r6,r6,#32               ;force lower case
        CMP     r4,r6
        BEQ     Command_Move_Find_Loop

Command_Move_Skip_Command
        CMP     r4,#0                   ;have we reached terminating zero?
        LDRNEB  r4,[r3],#1              ;load next char.
        BNE     Command_Move_Skip_Command
        LDRB    r4,[r3,#1]!             ;skip over code, load first character of next command and make r3 point next command
        CMP     r4,#0                   ;is it the end of the whole table
        BNE     Command_Move_Find

        ;if we reached the end of the table then fall through to here
Command_Move_Unknown
        Pull    "r0,lr"
        ADR     r0,Command_Move_Unknown_Message
        SETV
        MOV     pc,lr

Command_Move_Unknown_Message
        DCD     0
        DCB     "Bad direction - use up, down, left, right, or reset",0
        ALIGN

Command_Move_Table
        ;text, followed by terminating zero, followed by code
        ;bit 0 clear=horizontal set=vertical
        ;bit 1 clear=smaller(left,down) set=bigger(up,right)
        ;bit 2 clear=move set = reset
        ;codes are l=0 r=2,d=1,u=3,r=4
        DCB     "left"
        DCB     0
        DCB     Chrontel_Left

        DCB     "right"
        DCB     0
        DCB     Chrontel_Right

        DCB     "down"
        DCB     0
        DCB     Chrontel_Down

        DCB     "up"
        DCB     0
        DCB     Chrontel_Up

        DCB     "reset"
        DCB     0
        DCB     Chrontel_Reset

        DCB     0                       ;terminate table
        ALIGN

Command_Move_Check
        ;This section of code allows arguments which start the same e.g uplots and upabit
        CMP     r6,#32                  ;\space
        BLE     Command_Move_Do
        CMP     r6,#63                  ;"?" - web browser issues the command Chrontel_Move Chrontel_Move:left?
        BNE     Command_Move_Skip_Command

Command_Move_Do
        ;we get here if the argument matched a command and was terminated by a ASCII code <=32 (space) or =63("?")
        ;we now have a valid command and r3 is pointing at it's code number
        LDRB    r2,[r3,#0]              ;load code number
        ADD     r1,r12,#IIC_Buffer      ;set up r1 to point to a buffer
        MOV     r0,#Chrontel_IIC_Write  ;required by SWI IIC_Control

        CMP     r2,#Chrontel_Reset
        BEQ     Chrontel_Move_Reset

        CMP     r2,#Chrontel_Left
        CMPNE   r2,#Chrontel_Right
        BEQ     Chrontel_Move_Horiz

        CMP     r2,#Chrontel_Down
        CMPNE   r2,#Chrontel_Up
        BEQ     Chrontel_Move_Vert
;new commands go here - look how I didn't assume a vertical movement

        Pull    "r0,pc"

Chrontel_Move_Horiz
        ;r0,r1 are ready for IIC_Control
        LDRB    r3,[r12,#IIC_Horiz]
        MOV     r5,r3                   ;make a copy to see if anything has changed
        CMP     r2,#Chrontel_Left
        ADDNE   r3,r3,#Horiz_Step_Size
        SUBEQ   r3,r3,#Horiz_Step_Size

        CMP     r3,#0                   ;minimum is 0 - should use the horiz_stop here
        MOVLT   r3,#0
        CMP     r3,#Horiz_Stop+Horiz_Offset     ;maximum is controlled by Horiz_Stop - chip allows 511 but this software only allows 255
        MOVGT   r3,#Horiz_Stop+Horiz_Offset
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STRB    r3,[r12,#IIC_Horiz]     ;store new value
        MOV     r2,#HPR                 ;horizontal register
        STRB    r2,[r1,#0]              ;put horizontal register into IIC block
        STRB    r3,[r1,#1]              ;put horizontal value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        SUB     r3,r3,#Horiz_Offset
        MOV     r3,r3,LSL#24
        MOV     r3,r3,LSR#24            ;make horizontal value unsigned

        ADR     r0,NVRAM_X
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write
        CLRV

        Pull    "r0,pc"                 ;return preserving r0

Chrontel_Move_Vert
        ;r0,r1 are ready for IIC_Control
        LDR     r3,[r12,#IIC_Vert]      ;this has to be an LDR because IIC_Vert is a 9 bit value
        MOV     r5,r3                   ;make a copy of the value before we alter it
        LDR     r6,[r12,#TVLPF]
        MOV     r6,r6,LSR#1             ;this is the limit that the chrontel 7003 defines [TVLPF-1]/2
        CMP     r2,#Chrontel_Down
        SUBEQ   r3,r3,#Vert_Step_Size
        ADDNE   r3,r3,#Vert_Step_Size

        CMP     r3,#0
        MOVLT   r3,r6
        CMP     r3,r6
        MOVGT   r3,#0

        SUB     r6,r6,#Vert_Stop        ;get a value that limits how low they can go
        CMP     r3,#Vert_Stop           ;is the vertical value greater than 50
        CMPGT   r6,r3                   ;and the upper limit greater than the vertical value
        BLE     Chrontel_Move_Vert_Program

        ;if we fall through to here the vertical value lies between the two limits
        ;so we need to fix it
        CMP     r2,#Chrontel_Down
        ADDEQ   r3,r3,#Vert_Step_Size
        SUBNE   r3,r3,#Vert_Step_Size

Chrontel_Move_Vert_Program
        CMP     r3,r5                   ;do the old and new values differ
        Pull    "r0,pc",EQ              ;if the same then return

        STR     r3,[r12,#IIC_Vert]      ;store new value
        MOV     r2,#VPR                 ;vertical register
        STRB    r2,[r1,#0]              ;put vertical register into IIC block
        AND     r5,r3,#255              ;get low 8 bits
        STRB    r5,[r1,#1]              ;put low bits of vertical value into IIC block
        MOV     r2,#2                   ;write two bytes
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

        MOV     r4,r3,LSR#8             ;move bit 8 into bit 0 (and preserve r3 for later)
        AND     r4,r4,#1                ;make sure we've only got bit 0
        LDRB    r6,[r12,#IIC_Overflow]  ;get the copy of the overflow register
        BIC     r5,r6,#2_11111110       ;clear everything except current vertical bit
        CMP     r4,r5                   ;are they set the same way?
        BEQ     Chrontel_Move_Vert_Skip1;don't program the overflow register

        MOV     r0,#Chrontel_IIC_Write
        BIC     r6,r6,#2_00000001       ;clear the relevant bit
        ORR     r6,r6,r4                ;and orr in the new value
        STRB    r6,[r12,#IIC_Overflow]  ;store it in our soft copy
        MOV     r2,#PO                  ;overflow register
        STRB    r2,[r1,#0]
        STRB    r6,[r1,#1]
        MOV     r2,#2
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;if there was an error then don't corrupt the error pointer (r0)

Chrontel_Move_Vert_Skip1
        ADR     r0,NVRAM_Y
 [ NVRAMBodge
        CMP     r3,#127                 ;is the value in the upper or lower range
        SUBGT   r3,r3,#60               ;upper range so subtract 60
 ]
        STR     r3,[r1,#0]
        MOV     r2,#0
        SWI     XNVRAM_Write
        CLRV

        Pull    "r0,pc"                 ;if there was no error then return preserving r0

Chrontel_Move_Reset
        ;r0,r1 are ready for IIC_Control
        MOV     r2,#PO                  ;put overflow register number
        STR     r2,[r1,#0]              ;into IIC buffer
        LDRB    r2,[r12,#IIC_Overflow]  ;load the overflow byte
        AND     r2,r2,#2_11111100       ;zero the horiz and vert bits but leave everything else okay
        STRB    r2,[r1,#1]              ;put it in the block
        STRB    r2,[r12,#IIC_Overflow]  ;and the soft-copy
        MOV     r2,#2                   ;two bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)
        MOV     r0,#Chrontel_IIC_Write  ;IIC_Control helpfully corrupts r0 so we need to restore it

        MOV     r2,#HPR+AutoInc         ;auto inc from horizontal register (&a)
        STRB    r2,[r1,#0]
        MOV     r2,#Horiz_Offset        ;default horizontal position
        STRB    r2,[r1,#1]
        STRB    r2,[r12,#IIC_Horiz]
        MOV     r2,#0                   ;default vertical position
        STRB    r2,[r1,#2]
        STR     r2,[r12,#IIC_Vert]
        MOV     r2,#3                   ;3 bytes to send
        SWI     XIIC_Control
        Pull    "r1,pc",VS              ;If there was an error then return it (we need to avoid corrupting r0 so load a dummy register instead - r1)

        MOV     r2,#0                   ;default horizontal position, also tells NVRAM_Write to use first word of r1
        STR     r2,[r1,#0]
        ADR     r0,NVRAM_X
        SWI     XNVRAM_Write

        MOV     r2,#0                   ;default vertical
        STR     r2,[r1,#0]
        MOV     r2,#0
        ADR     r0,NVRAM_Y
        SWI     XNVRAM_Write
        CLRV

        Pull    "r0,pc"

NVRAM_X
        =       "DisplayXPosition",0
NVRAM_Y
        =       "DisplayYPosition",0
        ALIGN

;*************************************************************
;Service call stuff, to gather info. when mode is changed
;*************************************************************

 [ {FALSE}
;Service_PreModeChange
PreModeChange
        ;a) check the colour depth <= 256 colours
        ;r2 is mode
        Push    "r0-r2,lr"
        LDR     r12,[r12]

        MOV     r0,r2                   ;we want to know about the suggested mode in r2
        MOV     r1,#9                   ;ask for LOG to base 2 of BPP
        SWI     XOS_ReadModeVariable
        MOVCS   r2,#0

        SWI     XModeFiles_MonitorType  ;otherwise read the actual type
        MOVVS   r0,#3                   ;if we couldn't get an answer from ModeFiles then assume not an NC so assume VGA
        CMP     r0,#0
        CMPEQ   r0,#8                   ;TV?
        Pull    "r0-r2,pc",NE           ;If not TV then carry on as normal

        CMP     r2,#4                   ;16bpp or greater
        Pull    "r0-r2,lr"
        MOVGE   r1,#0                   ;if so return with an error
        ADRGE   r0,HighColourModeError
        MOV     pc,lr

HighColourModeError
        DCD     &1ed
        DCB     "Screen mode not available: Pixel depths greater than 8bpp are not compatible with TV output",0
        ALIGN
 ]

        ;some code to set Variable1 rob$debug1 to the value of r3
        ;Push    "r0-r4"
        ;ADRL     r0,Variable1
        ;ADD     r1,r12,#IIC_Buffer
        ;STR     r3,[r1,#0]
        ;MOV     r2,#0
        ;MOV     r3,#0
        ;MOV     r4,#1
        ;SWI     XOS_SetVarVal
        ;Pull    "r0-r4"


;Service_ModeChanging code
ModeChanging
        ;decide, based on monitor type whether we still need to sit on PaletteV and also mark mode info
        ;as invalid so that the modified kernel routines re-read it
        ;r2 is new mode
        ;r3 is MonitorType
        ;0 : PAL TV
        ;3 : VGA MONITOR
        ;8 : NTSC TV
        LDR     r12,[r12]
        Push    "r0-r4,lr"

        CMP     r3,#0
        CMPNE   r3,#8
        CMPNE   r3,#3                   ;known type of display?
        BEQ     Chrontel_Mode_KnownType ;if so we can use it directly

        SWI     XModeFiles_MonitorType  ;otherwise read the actual type
        MOVVC   r3,r0                   ;put it in r3
        MOVVS   r3,#3                   ;if we couldn't get an answer from ModeFiles then assume not an NC so choose VGA
Chrontel_Mode_KnownType

        MOV     r0,#PaletteV
        ADRL    r1,Chron_MOSPaletteV
        MOV     r2,r12
        LDRB    lr,[r12,#MonitorType]   ;previous monitor type
        CMP     r3,#0
        CMPNE   r3,#8                   ;is it a television?
        BEQ     Chrontel_Mode_Claim     ;yes, so goto TV

        ;falls through to here if monitor
        CMP     lr,#3                   ;previously monitor?
        SWINE   XOS_Release             ;if not then release vector
        B       Chrontel_Mode_Skip3

Chrontel_Mode_Claim
        ;arrives here if television
        CMP     lr,#3                   ;previously monitor?
        SWIEQ   XOS_Claim               ;if so then claim vector
        ;B       Chrontel_Mode_Skip3

Chrontel_Mode_Skip3
        STRB    r3,[r12,#MonitorType]   ;make a record of what we've decided to go with
        Pull    "r0-r4,pc"


;Service_ModeChange code, can also be called from within module if we find that it needs to do some setting up
ModeChange
        LDR     r12,[r12]

Chrontel_Mode
        ;choose a black level based on NTSC[-J] or PAL[ M], TV type and territory
        ;choose PLL values to match clock
        ;if TV then look up clock speed and cross reference this to a chrontel mode
        ;r3 is monitor type
        ;we'll always be in the mode we are working out values for so we don't need to know the mode
        Push    "r0-r10,lr"

        LDRB    r3,[r12,#MonitorType]

        ;when moving the display  around on screen we need to know how many lines per frame
        ;default to 624 lines - this is what will happen with monitors (type 3) but since
        ; the chrontel doesn't move the display around on monitors so it don't matter
        MOV     r4,#624
        CMP     r3,#8
        MOVEQ   r4,#524                 ;NTSC lines
        CMP     r3,#0
        MOVEQ   r4,#624                 ;PAL lines
        STR     r4,[r12,#TVLPF]

        ;get pixel rate required by this mode
        ADD     r1,r12,#IIC_Buffer      ;set up address for output
        ADD     r0,r1,#8                ;set up address for input
        MOV     r2,#173                 ;clock rate
        STR     r2,[r0,#0]
        MVN     r2,#0                   ;current mode r2=-1
        STR     r2,[r0,#4]
        SWI     XOS_ReadVduVariables
        LDR     r4,[r1,#0]              ;r4 = Fpix

        ;pick a mode based on this and PAL/NTSC choice - don't need to bother if it's a monitor
        ;to begin with pick one of two modes

        CMP     r3,#3                   ;monitor
        BEQ     Select_Clock

        ADR     r7,TV_Modes             ;available chrontel modes
        ADR     r8,TV_Modes_End

Select_Mode_Loop
        LDR     r5,[r7],#4
        MOV     r6,r5,LSR#16            ;r6 contains the byte to send to the chrontel, plus bit 8 = PLLCAP
        BIC     r5,r5,#&00ff0000        ;r5 contains an Fpix value
        CMP     r5,r4                   ;have we found the correct mode
        BEQ     Select_Mode_Program
        CMP     r7,r8
        BLT     Select_Mode_Loop

        ;no matching frequency found...
        ;so choose reasonablish defaults?? - maybe we should just try to signal an error some how
        CMP     r3,#8
        MOVEQ   r6,#2_001101001          ;640*480 NTSC 1/1 24.671MHz
        CMP     r3,#0
        MOVEQ   r6,#2_010000001          ;800*600 PAL 1/1 29.5MHz


Select_Mode_Program
        ;r3=monitorType
        ;r4=Fpix
        ;r6=contains a value to program into chrontel register 0
        ;still need to modify r6 to take into account NTSC-J and PAL-M

        BL      Chrontel_Black_Level    ;sets up r1->IIC_Buffer, sets the black level and modifies r6 if in japan or brazil....

        MOV     r0,#DMR                 ;display mode register
        STRB    r0,[r1,#0]
        STRB    r6,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

        MOV     r0,#PLLC                ; PLL control
        STRB    r0,[r1,#0]
        TST     r6,#1:SHL:8
        MOV     r2,#2_001010            ; set PLLCAP bit for mode
        ORRNE   r2,r2,#2_010000
        STRB    r2,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

        ;now determine digital output format from HAL, and set up data format register
        ;
        Push    "r3"
        MOV     r8, #0
        MOV     r9, #EntryNo_HAL_Video_OutputFormat ;return HAL video format in r0
        SWI     XOS_Hardware
        ADD     r1, r12, #IIC_Buffer
        SUB     r0, r0, #1    ;HAL formats 1-10 correspond to Chrontel 7003 formats 0..9
        MOV     r2, #IDF      ;data format register
        STRB    r2, [r1, #0]
        STRB    r0, [r1, #1]
        MOV     r0, #Chrontel_IIC_Write
        MOV     r2, #2
        SWI     XIIC_Control
        Pull    "r3"

Select_Clock
        ;r3 = monitorType
        ;r4 = Fpix
        ;select the closest match
        ;loop over values of M and N
        MOV     r0,#0                   ;M
        MOV     r1,#0                   ;N
        LDR     r3,=&37EE3              ;Get the Fref*16 (14318.18 * 16)
                                        ; value that the chrontel is running off

        MOV     r2,r4,LSL #4+1          ;get the first value of Fpix * (M+2) to check
        ADD     r5,r3,r3                ; and Fref * (N+2)

        MOV     r6,#0                   ;best value of M
        MOV     r7,#0                   ;best value of N
        MOV     r8,#&FF00000            ;best error - random constant that should be plenty big enough

Select_Clock_LoopM

        MOV     r10,#0                  ;flag

Select_Clock_LoopN
        SUBS    r9,r5,r2
        RSBMI   r9,r9,#0                ;make positive
        MOVPL   r10,#1                  ;if the sign of the error is positive we've looked at the smallest error either side of the 'ideal' value
        CMP     r9,r8                   ;new error-old error
        MOVLT   r6,r0
        MOVLT   r7,r1
        MOVLT   r8,r9                   ;remember best values

        ADD     r1,r1,#1                ;next value of N
        ADD     r5,r5,r3                ;add another Fref
        CMP     r1,#1024
        CMPLT   r10,#1                  ;this will go EQ thus breaking out of the loop if we've had a -ve and +ve error
        BLT     Select_Clock_LoopN

        MOV     r1,#0                   ;make N=0
        ADD     r5,r3,r3                ;reset Fref*(N+2)

        ADD     r0,r0,#1                ;next value of M
        ADD     r2,r2,r4,LSL #4         ;Fpix*(M+2)
        CMP     r0,#512
        BLT     Select_Clock_LoopM

        ;should now have best values of N and M and without any MULs
        ;N=r7 M=r6 Error=r8
        ;program chrontel with these values
        ADD     r1,r12,#IIC_Buffer
        AND     r4,r6,#255              ;low bits of M
        AND     r5,r7,#255              ;low bits of N
        MOV     r3,r7,LSR#7             ;bits 8,9 of N go in bit 1,2 of overflow reg.
        BIC     r3,r3,#1                ;clear what was bit 7 of N
        ORR     r3,r3,r6,LSR#8          ;or in bit 0 which is bit 8 of M
        MOV     r2,#MNE+AutoInc         ;overflow register + auto-inc
        STRB    r2,[r1,#0]
        STRB    r3,[r1,#1]              ;value of overflow
        STRB    r4,[r1,#2]              ;value of M
        STRB    r5,[r1,#3]              ;value of N
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#4
        SWI     XIIC_Control

        CLRV
        Pull    "r0-r10,pc"

Chrontel_Black_Level
        ;enter with monitor type in r3 and chosen mode in r6
        ;corrupts r0-r2 (r1 points to IIC buffer though so it might be useful)
        ;modifies r6 where required
        ;0=PAL
        ;3=Monitor - don't change anything
        ;8=NTSC
        CMP     r3,#3
        MOVEQ   pc,lr

        Push    "lr"
 [ RGB
        MOV     r2, #0                  ;black level 0 for RGB mode
 |

        SWI     XTerritory_Number       ;returns territory number in r0
        MOVVS   r0,#TerritoryNum_Default

        MOV     r2,#127                 ;NTSC level is default

        CMP     r3,#0
        MOVEQ   r2,#105                 ;PAL level
        ;CMPEQ   r0,#TerritoryNum_Brazil ;this doesn't exist atm 25/07/2000 but there is _LatinAm   for Latin America
        ;MOVEQ   r2,#127                 ;PAL-M  -  used in Brazil apparently
        ;ORREQ   r6,r6,#2_00010000       ;special PAL-M mode

        CMP     r3,#8
        MOVEQ   r2,#127                 ;NTSC level
        CMPEQ   r0,#TerritoryNum_Japan  ;are we in japan
        MOVEQ   r2,#100                 ;NTSC-J
        ORREQ   r6,r6,#2_00010000       ;special NTSC-J mode

 ]
        ADD     r1,r12,#IIC_Buffer
        MOV     r0,#BLR
        STRB    r0,[r1,#0]              ;black level register
        STRB    r2,[r1,#1]              ;black level value
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control

        Pull    "pc"

;*************************************************************
;Setup type stuff, executed once only
;*************************************************************

PaletteV_Setup
        MOV     r2,#3
        STRB    r2,[r12,#MonitorType]           ;this has to reflect whether or not we've claimed paletteV
        MOV     r0,#0
        STRB    r0,[r12,#ScreenBlankFlag]       ;not blanked
        MOV     pc,r14                          ;return

Chrontel_Setup
        ; Setup the chrontel hardware using the IIC bus
        ; this stuff is only done once i.e the stuff that is not mode or monitor dependant
        ; power up - reset - power up
        Push    "lr"
        ADD     r1,r12,#IIC_Buffer

        MOV     r2,#PMR                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#PMR_Reset           ;power up and do reset
        STRB    r2,[r1,#1]
        MOV     r2,#2                   ;send 2 bytes
        MOV     r0,#Chrontel_IIC_Write  ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#VID
        STRB    r2,[r1,#0]
        MOV     r2,#1
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        MOV     r2,#1
        MOV     r0,#Chrontel_IIC_Read
        SWI     XIIC_Control
        LDRB    r2,[r1,#0]
        STRB    r2,[r12,#Chrontel_VID]

        MOV     r2,#PMR                 ;power register
        STRB    r2,[r1,#0]
        MOV     r2,#PMR_On              ;power up and clear reset condition
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write  ;put device address in r0
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r0,#Chrontel_IIC_Write  ;do it again to ensure register OK after reset
	MOV	r2,#2
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#DMR+AutoInc         ;display settings register (0) with auto inc (64)
        STRB    r2,[r1,#0]
        MOV     r2,#2_10000001          ;800x600 PAL 1-1 (29.5MHz) 640x480=%01100001
        STRB    r2,[r1,#1]
        LDRB    r2,[r12,#Chrontel_VID]
        TEQ     r2,#VID_7005
        MOVEQ   r2,#Chrontel_Flicker_7005
        MOVNE   r2,#Chrontel_Flicker_7003
        STRB    r2,[r1,#2]
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#CM                  ;control register
        STRB    r2,[r1,#0]
      [ Slave
        MOV     r2,#2_00000000
      |
        MOV     r2,#2_01000000          ;CFRB off, master mode on, x, data is latched on negative edge, xcm1, xcm0, pcm1, pcm0
      ]
                                        ;data latched on negative edge means that the red LUT corresponds to P0b (G2 G1 G0 B4 B3 B2 B1 B0)
                                        ;                                   and the green LUT corresponds to P0a (xx R4 R3 R2 R1 R0 G4 G3)
        STRB    r2,[r1,#1]
        MOV     r2,#2
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#CDR
        STRB    r2,[r1,#0]
        MOV     r2,#0
        STRB    r2,[r1,#1]
        MOV     r2,#2
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        ADRL    r0,NVRAM_X              ;NVRAM tag
        MOV     r2,#0                   ;read into first word of r1
        SWI     XNVRAM_Read
        CMP     r0,#0                   ;error?
        MOVLT   r4,#Horiz_Offset        ;default value if there is a problem reading NVRAM
        BLT     %FT40
        LDR     r4,[r1,#0]              ;if not load up the value
        MOV     r4,r4,ASL#24
        MOV     r4,r4,ASR#24            ;make into a signed value
        ADD     r4,r4,#Horiz_Offset     ;make 0 equate to a default middle position
40
        STRB    r4,[r12,#IIC_Horiz]     ;our soft copy


        ;the vertical position ranges between 0 and TVLPF/2 (313 max) which is too big to fit into 8bits
        ;however we don't use the middle of this range 50-200 (ish) so a cunning bodge allows us to fit the 9bit value into 8bits
        ;bit 7 clear indicates that the value is in the low range so we simply use the value
        ;bit 7 set indicates upper range so add 60 which gives a range of 188-315 (min required=262-stop value  max required=313)
        ADRL    r0,NVRAM_Y
        MOV     r2,#0
        SWI     XNVRAM_Read
        CMP     r0,#0
        LDRGE   r5,[r1,#0]
        MOVLT   r5,#0                   ;default value
 [ NVRAMBodge
        TST     r5,#2_10000000          ;is bit 7 set?
        ADDNE   r5,r5,#60
 ]
        STR     r5,[r12,#IIC_Vert]      ;our soft copy

        MOV     r2,#SAV+AutoInc         ;start active video register
        STRB    r2,[r1,#0]              ;address in block
        LDRB    r2,[r12,#Chrontel_VID]
        TEQ     r2,#VID_7003
        MOVEQ   r2,#Start_Active_Video
        MOVNE   r2,#Start_Active_Video_7005
        STRB    r2,[r1,#1]              ;SAV value in block     - limited to <=255
        MOV     r2,r5,LSR#8             ;make bit 8 into bit 0
        AND     r2,r2,#1                ;clear other bits
        STRB    r2,[r1,#2]              ;Overflow value in block
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        BVS     Chrontel_Failed

        MOV     r2,#HPR+AutoInc         ;horizontal register
        STRB    r2,[r1,#0]              ;address in block
        STRB    r4,[r1,#1]              ;horizontal
        STRB    r5,[r1,#2]              ;vertical
        MOV     r2,#3
        MOV     r0,#Chrontel_IIC_Write
        SWI     XIIC_Control
        ;BVS     Chrontel_Failed

Chrontel_Failed
        CLRV                            ;in case one of the XIIC_Control caused an error

        Pull    "pc"


TV_Modes
        ;table of frequencies V byte to put in display register
        DCW     20140
        DCW     2_100001000              ;2
        DCW     21000
        DCW     2_101100000              ;13
        DCW     21001
        DCW     2_100000000              ;0 - use 13 instead
        DCW     21147
        DCW     2_101001000              ;10
        DCW     23790
        DCW     2_100101000              ;6
        DCW     24671
        DCW     2_001101001              ;16
        DCW     24672
        DCW     2_000001001              ;3 - use 16 instead
        DCW     25000
        DCW     2_001000000              ;8
        DCW     26250
        DCW     2_101100001              ;14
        DCW     26251
        DCW     2_100000001              ;1 - use 14 instead
        DCW     26434
        DCW     2_101001001              ;11
        DCW     28125
        DCW     2_100100000              ;4
        DCW     28196
        DCW     2_001101010              ;17
        DCW     29455
        DCW     2_100101001              ;7
        DCW     29500
        DCW     2_010000001              ;19
        DCW     30210
        DCW     2_001101011              ;18
        DCW     30209   ;should be same as above but it's been bodged
        DCW     2_001001010              ;12
        DCW     31500
        DCW     2_101100011              ;15
        DCW     31501   ;should also be 31500
        DCW     2_101000001              ;9
        DCW     34875
        DCW     2_000100001              ;5
        DCW     36000
        DCW     2_110000011              ;20
        DCW     39000
        DCW     2_010000100              ;21
        DCW     39273
        DCW     2_110001011              ;22
        DCW     43636
        DCW     2_110001100              ;23
        DCW     47832
        DCW     2_010001101              ;24
TV_Modes_End

Variable1
        DCB     "Rob$Debug1",0
        ALIGN
Variable2
        DCB     "Rob$Debug2",0
        ALIGN

Standby_Callback
        Push    "r0-r2,lr"

        ADD     r1,r12,#IIC_Buffer
        LDRB    r0,[r12,#ScreenBlankFlag]       ;what state are we supposed to be in?
        MOV     r2,#PMR
        STRB    r2,[r1,#0]              ;chrontel power register
        TST     r0,#1                   ;bit 0 =now in standby mode
        MOVEQ   r2,#PMR_On              ;normal - power on
        MOVNE   r2,#PMR_PowerSave       ;00001000 composite off - could also try 00001001 which is power down but if it resets everything i'll not bother
        STRB    r2,[r1,#1]
        MOV     r0,#Chrontel_IIC_Write
        MOV     r2,#2
        SWI     XIIC_Control
        CLRV
        Pull    "r0-r2,pc"

        END

