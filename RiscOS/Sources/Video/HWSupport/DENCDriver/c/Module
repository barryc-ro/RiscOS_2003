/******	Module.c ***********************************************************

Project:	STB-400
Component:	DENCDriver
This file:	Main relocatable module entry points

Copyright 1999 Pace Micro Technology plc. All rights reserved.

This material is the confidential trade secret and proprietary information
of Pace Micro Technology plc. It may not be reproduced, used, sold, or
transferred to any third party without the prior written consent of
Pace Micro Technology plc.

History:
Date		Who	Change
----------------------------------------------------------------------------
01/10/1999	BJGA	Created
22/10/1999	BJGA	API updated in line with issue C specification
22/10/1999	BJGA	Now uses RAM_MODULE switch rather than ROM_MODULE to
			switch ResourceFS code - since debug and McCabe builds
			will be softloaded, this makes the makefile simpler
14/12/1999	BJGA	API updated in line with issue D specification
10/01/2000	BJGA	Various initialisation changes to get CAD 1 going
14/01/2000	BJGA	Installs PaletteV handler; sets up NTSC CLINES output bit
25/01/2000	BJGA	Added 2 x 27MHz delay to incoming HSync signal
26/01/2000	BJGA	Sets default palette on module initialisation
01/02/2000	BJGA	Removed 2 x 27MHz delay

***************************************************************************/

/************/
/* Includes */
/************/

#include <stdio.h>
#include <stdbool.h>
#include "kernel.h"
#include "swis.h"

#include "Global/PaletteV.h"
#include "Global/RISCOS.h"
#include "Global/Services.h"
#include "PortMan.h"

#include "CLI.h"
#include "Config.h"
#include "Defs.h"
#include "Mess.h"
#include "ModHdr.h"
#include "Module.h"
#include "PaletteV.h"
#include "ResMess.h"
#include "Service.h"
#include "SWI.h"

/*****************/
/* Private types */
/*****************/

/**********************/
/* Private prototypes */
/**********************/

/********************/
/* Public variables */
/********************/

extern int Module_MessageFD [4] = { 0, 0, 0, 0 };  /* message file descriptor */

/*********************/
/* Private variables */
/*********************/

/*********************/
/* Private constants */
/*********************/

/********************/
/* Public functions */
/********************/

/******	Module_Init() ******************************************************

Purpose:	Module and STi3520L initialisation
In:		Standard args
Out:		Pointer to error block if initialisation failed

***************************************************************************/

extern _kernel_oserror *Module_Init(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e = NULL;
#ifndef ROM_MODULE
  bool FileRegistered = false;
#endif
  bool MessagesOpen = false;
  bool PaletteVRegistered = false;
  IGNORE(podule_base);
  IGNORE(cmd_tail);

  if (!e)
  {

#ifndef ROM_MODULE
    e = _swix (ResourceFS_RegisterFiles, _IN(0), ResMess_ResourcesFiles ());
  }
  if (!e)
  {
    FileRegistered = true;
#endif

    e = _swix (MessageTrans_OpenFile, _INR(0,2), &Module_MessageFD, "Resources:$.Resources.DENCDriver.Messages", 0);
  }
  if (!e)
  {
    MessagesOpen = true;
    
    e = _swix (OS_Claim, _INR(0,2), PaletteV, PaletteV_Routine, pw);
  }
  if (!e)
  {
    PaletteVRegistered = true;
    
    {
#if 0
      /* Initialise DENC so we get sync pulses into the 3520L */
      unsigned char iic_block[2] = { 0, 0xB0 };  /* DENC is sync master (for bodge board) */
      /* Switch TDA1 to use 2x gain */
      iic_block[0] = 1;
      iic_block[1] = 0;
      _swix (IIC_Control, _INR(0,2), 0x98, &iic_block, 2);
#else
      /* Switch DENC to PAL mode */
      unsigned char iic_block[2] = { 0, 0x12 };
      _swix (IIC_Control, _INR(0,2), 0x40, &iic_block, 2);
      /* Turn off Macrovision (!!) */
      iic_block[0] = 45;
      iic_block[1] = 0x00;
      _swix (IIC_Control, _INR(0,2), 0x40, &iic_block, 2);
      /* Switch DENC to RGB */
      iic_block[0] = 5;
      iic_block[1] = 0xB0;
      _swix (IIC_Control, _INR(0,2), 0x40, &iic_block, 2);
      
      /* Switch TDA to use 2x gain */
      iic_block[0] = 1;
      iic_block[1] = 0;
      _swix (IIC_Control, _INR(0,2), 0x98, &iic_block, 2);
      /* Enable all 4 outputs */
      iic_block[0] = 2;
      iic_block[1] = 0x0F;
      _swix (IIC_Control, _INR(0,2), 0x98, &iic_block, 2);
      /* Map input 0 -> output 0, input 1 -> output 1 etc. */
      iic_block[0] = 0;
      iic_block[1] = 0xE4;
      _swix (IIC_Control, _INR(0,2), 0x98, &iic_block, 2);
      
      _swix (PortMan_AccessBit, _INR(0,1), PORTMAN_FLAG_CLEAR, "NTSC_Selected"); /* reassert on PortMan_Init Service call */
      
      * (volatile unsigned int *) 0x0302BF00 = 1;
      
      _swix (OS_CallAVector, _IN(4)|_IN(9), paletteV_SetDefaultPalette, PaletteV); /* set solid palette during machine boot */
      _swix (ColourTrans_InvalidateCache, 0); /* in case palette wasn't already default */
#endif
    }
  }

  if (e && PaletteVRegistered) _swix (OS_Release, _INR(0,2), PaletteV, PaletteV_Routine, pw);
  if (e && MessagesOpen) _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  if (e && FileRegistered) _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  return e;
}

/******	Module_Final() *****************************************************

Purpose:	Module finalisation
In:		Standard args
Out:		Pointer to error block if finalisation failed

***************************************************************************/

extern _kernel_oserror *Module_Final(int fatal, int podule, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(fatal);
  IGNORE(podule);
  
  _swix (OS_Release, _INR(0,2), PaletteV, PaletteV_Routine, pw);
  _swix (MessageTrans_CloseFile, _IN(0), &Module_MessageFD);
#ifndef ROM_MODULE
  _swix (ResourceFS_DeregisterFiles, _IN(0), ResMess_ResourcesFiles ());
#endif
  return e;
}

/******	Module_Service() ***************************************************

Purpose:	Service call handler
In:		Standard args

***************************************************************************/

extern void Module_Service(int service_number, _kernel_swi_regs *r, void *pw)
{
  bool claim = false;
  IGNORE(pw);
  switch (service_number)
  {
    case Service_ModeChanging:
      Service_ServiceModeChanging (
          (void *) (r->r[2])
          );
      break;
    case Service_Standby:
      Service_ServiceStandby (
          (unsigned int) (r->r[0])
          );
      break;
  }
  if (claim) r->r[1] = 0;
}

/******	Module_Commands() **************************************************

Purpose:	* command handler
In:		Standard args
Out:		Pointer to error block if command could not be executed

***************************************************************************/

extern _kernel_oserror *Module_Commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
  _kernel_oserror *e = NULL;
  IGNORE(argc);
  IGNORE(pw);
  switch ((int) arg_string)
  {
    case (int) arg_CONFIGURE_SYNTAX:
      switch (cmd_no)
      {
        case CMD_TVStandard:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CDEDTVS", 0));
          break;
        case CMD_TVChannel:
          printf ("%s\n", (char *) _swi (MessageTrans_Lookup, _INR(0,2)|_RETURN(2), Module_MessageFD, "CDEDTVC", 0));
          break;
      }
      break;
    case (int) arg_STATUS:
      switch (cmd_no)
      {
        case CMD_TVStandard:
          Config_PrintTVStandard ();
          break;
        case CMD_TVChannel:
          Config_PrintTVChannel ();
          break;
      }
      break;
    default:
      switch (cmd_no)
      {
        case CMD_LoadMacrovisionKey:
          e = CLI_LoadMacrovisionKey (arg_string);
          break;
        case CMD_TVStandard:
          e = Config_SetTVStandard (arg_string);
          break;
        case CMD_TVChannel:
          e = Config_SetTVChannel (arg_string);
          break;
      }
      break;
  }
  return e;
}

/******	Module_SWI() *******************************************************

Purpose:	SWI handler
In:		Standard args
Out:		Pointer to error block if SWI could not be executed

***************************************************************************/

extern _kernel_oserror *Module_SWI(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e = NULL;
  _kernel_swi_regs rout;
  IGNORE(pw);
  switch (swi_offset)
  {
    case Macrovision_SetState & 0x3F:
      e = SWI_SetState (
          (unsigned int) (r->r[0]),
          (unsigned int) (r->r[1]),
          (unsigned int *) &(rout.r[1])
          );
      r->r[1] = rout.r[1];
      break;
    case Macrovision_LoadCaptions & 0x3F:
      e = SWI_LoadCaptions (
          (unsigned int) (r->r[0]),
          (char *) (r->r[1]),
          (unsigned int) (r->r[2])
          );
      break;
    case Macrovision_CaptionControl & 0x3F:
      /* do nothing, but don't return an error either */
      break;
    case Macrovision_PlatformFeatures & 0x3F:
      switch (r->r[0])
      {
        case 0:
          e = SWI_PlatformFeatures0 (
              (void **) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        case 1:
          e = SWI_PlatformFeatures1 (
              (unsigned int) (r->r[1]),
              (void **) &(rout.r[2])
              );
          r->r[2] = rout.r[2];
          break;
        case 2:
          e = SWI_PlatformFeatures2 (
              (char **) &(rout.r[1]),
              (char **) &(rout.r[3])
              );
          r->r[1] = rout.r[1];
          r->r[2] = rout.r[2];
          r->r[3] = rout.r[3];
          break;
        case 3:
          e = SWI_PlatformFeatures3 (
              (void **) &(rout.r[1])
              );
          r->r[1] = rout.r[1];
          break;
        default:
          e = Mess_GenerateError ("Err_InvReason", 0, 1, "Macrovision_PlatformFeatures");
          break;
      }
      break;
    default:
      e = error_BAD_SWI;
      break;
  }
  return e;
}

/******	Module_EventV() ****************************************************

Purpose:	EventV handler
In:		Registers in/out, module private word
Out:		0 to intercept, 1 to pass on

***************************************************************************/

extern int Module_EventV(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  return 1;
}
