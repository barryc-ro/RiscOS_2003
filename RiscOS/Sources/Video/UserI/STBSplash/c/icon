/* STBSplash:c.icon */

#include <stdio.h>
#include <stdlib.h>
#include "stdbool.h"

#include "Global.Sprite.h"
#include "swis.h"

#include "dynamiclib.h"
#include "main.h"
#include "error.h"

#include "icon.h"

#define ICON_PADDING   (16) /* OS units */

/* This file uses OS units */

/*********************************** type definitions *********************************/

struct sprite_str
{
  struct sprite_str *next;
  int x, y;               /* Position of sprite top left, OS units */
  int width, height;      /* OS units                              */
  int *sprite;            /* Pointer to sprite                     */
};

typedef struct icon_str
{
  dynamiclib_str icons;   /* The sprites file                      */
  box  box;               /* Bounding box, OS units                */
  bool centreX, centreY;  /* Keep centred                          */
  int  x, y;              /* Position for top left of next sprite  */
  int  rowHeight;         /* Maximum height of sprites in last row */
  int  padding;           /* Space between icons, OS units         */
  sprite_str *firstIcon;  /* The list of icons                     */
  sprite_str *firstPlot;  /* The icon to start plotting from       */
  sprite_str *lastIcon;   /* The last one in the list              */
} icon_str;

/*************************** static variables *****************************************/

static icon_str icon;

/*********************************** static function declarations **********************/

/* start is the icon to start the fitting from */
/* If scrolled is returned as true then the window scrolled so redraw everything */
static _kernel_oserror *fit( sprite_str *start, bool *scrolled );

/*********************************** static functions **********************************/

#if debug == 1
 void dumpSprite( char *label )    
{
  int *sprite = (int *) (((int)icon.icons.area) + icon.icons.area[2]);
  int type = sprite[10];
  char *name = (char *)(sprite+1);
  printf( "%s Sprite %s has type %x\n", label, name, type );
  if( type != 0x1c ) printf( "******* WARNING ********\n" );
}

/* For testing that icons do go into the box specified */
void rectangle( box *box )
{
  _kernel_swi_regs r;

  r.r[0] = 4;
  r.r[1] = box->x0;
  r.r[2] = box->y0;
  _kernel_swi(OS_Plot, &r, &r);  
  r.r[0] = 5;
  r.r[1] = box->x0;
  r.r[2] = box->y1;           
  _kernel_swi(OS_Plot, &r, &r);
  r.r[0] = 5;
  r.r[1] = box->x1;
  r.r[2] = box->y1;           
  _kernel_swi(OS_Plot, &r, &r);
  r.r[0] = 5;
  r.r[1] = box->x1;
  r.r[2] = box->y0;
  _kernel_swi(OS_Plot, &r, &r);
  r.r[0] = 5;
  r.r[1] = box->x0;           
  r.r[2] = box->y0;
  _kernel_swi(OS_Plot, &r, &r);
}
#endif

/* Replot the icons onto the screen    */
/* Does not clear if first             */
/* If first == NULL, redraw everything */
_kernel_oserror *icon_redraw( sprite_str *first )
{
  _kernel_oserror *err = NULL;
  sprite_str *sprite = NULL;

  /* rectangle( icon.box.x0, icon.box.y0, icon.box.x1, icon.box.y1 ); */ 

  if( first == NULL ) first = icon.firstPlot;
  for( sprite = first; sprite && !err; sprite = sprite->next )
  {
    err = plot_sprite_translatedPtr( icon.icons.area, sprite->sprite, sprite->x, sprite->y - sprite->height, 1, 1 );
  }

  return err;
}

/* start is the icon to start the fitting from */
/* If scrolled is returned as true then the window scrolled so redraw everything */
static _kernel_oserror *fit( sprite_str *start, bool *scrolled )
{
  sprite_str *sprite = NULL;
  int x, y;                       /* current plot position */

  if( scrolled ) *scrolled = false;
  if( start == icon.firstIcon ) icon.firstPlot = start;
  if( start == icon.firstPlot ) /* Starting from the beginning of the box */
  {
    x = icon.box.x0;
    y = icon.box.y1;
    icon.rowHeight = 0;
  }
  else
  {
    x = icon.x;
    y = icon.y;
  }
  for( sprite = start; sprite; sprite = sprite->next )
  {
    /* If it won't fit horizontally, and it is not first on row, try the row below */
    if( x + sprite->width > icon.box.x1 && x > icon.box.x0 )
    {
      y -= icon.rowHeight + icon.padding;
      icon.rowHeight = sprite->height;
      sprite->x = x = icon.box.x0;
    }
    else /* It will fit on the end of the row */
    {
      sprite->x = x;
      if( sprite->height > icon.rowHeight ) icon.rowHeight = sprite->height;
    }
    sprite->y = y;
    x += icon.padding + sprite->width;

    /* Does that force a scroll? */
    if( y - icon.rowHeight < icon.box.y0 )
    {
      /* Scroll required */
      sprite_str *s;
      int move;
      int target = icon.box.y1 + (y - icon.box.y0) - icon.rowHeight; /* y value needed */
      for( s = icon.firstPlot; s != sprite; s = s->next )             /* scan the list to find it */
      {
        if( s->y <= target ) break;
      }
      /* Even if not found, we now have the best available solution so carry on */
      icon.firstPlot = s;
      move = icon.box.y1 - s->y;
      icon.firstPlot = s;
      /* Now we need to adjust all the y's */
      for( ; s != sprite; s = s->next )
      {
        s->y += move;
      }
      sprite->y += move;
      y += move;
      if( scrolled ) *scrolled = true;
    }
  }

  icon.x = x;
  icon.y = y;
  return NULL;
}

/*************************** extern functions ****************************************/

/* Call at module initialisation, after the mode variables have been read */
_kernel_oserror *icon_init(void)
{
  icon.icons.area = NULL;
  icon.icons.allocated = 0;
  icon.box.x0 = 0;
  icon.box.x1 = screen_info.width << screen_info.x_eig;
  icon.box.y0 = 0;
  icon.box.y1 = screen_info.height << screen_info.y_eig;
  icon.x = icon.box.x0;
  icon.y = icon.box.y1;
  icon.rowHeight = 0;
  icon.padding   = ICON_PADDING;
  icon.firstIcon = NULL;
  icon.firstPlot = NULL;
  icon.lastIcon  = NULL;
  return NULL;
}

/* Free all resources */
_kernel_oserror *icon_reset(void)
{
  _kernel_oserror *err = NULL;
  sprite_str *sprite, *nextSprite;

  for( sprite = icon.firstIcon; sprite; sprite = nextSprite )  
  {                                                            
    nextSprite = sprite->next;                                 
    free( sprite );                                            
  }                                                            
  icon.firstIcon = icon.firstPlot = icon.lastIcon = NULL;      
                                                               
  dynamiclib_free( &icon.icons );                              

  return err;
}

/* Load the sprite file specified in the command tail */
_kernel_oserror *icon_sprite( const char *cmdTail )
{
  /* no need to free first, it is done for us if neccessary */
  return set_up_dynamic_area( &icon.icons, NULL, cmdTail );
}

/* Add the named icon onto the screen */
_kernel_oserror *icon_add( const char *name )
{
  _kernel_swi_regs r;
  _kernel_oserror *err = NULL;
  sprite_str *sprite = NULL;
  int scale[4];
  bool scrolled;

  /* Check icons loaded */
  if( icon.icons.area == NULL ) err = error_make( ERROR_NOICONS );

  /* Memory for info about the sprite */
  if( !err )
  {
    sprite = malloc( sizeof( sprite_str ));
    if( sprite == NULL ) err = error_make( ERROR_MEMORY );
  }
    
  /* Find the sprite */
  if( !err )
  {
    r.r[0] = 0x100 + SpriteReason_SelectSprite;
    r.r[1] = (int) icon.icons.area;
    r.r[2] = (int) name;
    err = _kernel_swi(OS_SpriteOp, &r, &r);
    sprite->sprite = (int*) r.r[2];
  }
  
  /* Find out the scaling factors that the wimp would use */
  if( !err )
  {
    r.r[0] = 0x200;                  /* Use pointer to sprite */
    r.r[1] = (int) icon.icons.area;
    r.r[2] = (int) sprite->sprite;
    r.r[3] = r.r[4] = r.r[5] = 0;
    r.r[6] = (int) scale;
    r.r[7] = 0;
    err = _kernel_swi(Wimp_ReadPixTrans, &r, &r);
  }

  /* How big is it? */
  if( !err )
  {
    r.r[0] = 0x200 + SpriteReason_ReadSpriteSize;
    /* r1, r2 valid from previous call */
    err = _kernel_swi(OS_SpriteOp, &r, &r);
    sprite->width  = ( r.r[3] << screen_info.x_eig ) * scale[0] / scale[2];
    sprite->height = ( r.r[4] << screen_info.y_eig ) * scale[1] / scale[3];
  }

  /* It exists, and we've found out what we can about it, so add it to the list */
  if( !err )
  {
    sprite->next = NULL;
    if( icon.lastIcon ) icon.lastIcon->next = sprite;
    icon.lastIcon = sprite;
    if( icon.firstIcon == NULL ) icon.firstIcon = sprite;
    if( icon.firstPlot == NULL ) icon.firstPlot = sprite;
  }
  else
  /* It went pear shaped so tidy up */
  {
    free( sprite );
  }

  /* Call fit to work out positions */
  if( !err ) fit( sprite, &scrolled );

  /* Clear anything that needs clearing */
  if( !err && scrolled ) icon_clear( BLANK, &icon.box );

  /* And then call redraw */
  if( !err )
  {
    if( scrolled )
    { /* we need to redraw everything */
      /* we can't just redraw the rectangle because large sprites may overhang */
      err = plot_splash( NULL );
      if( !err ) err = icon_redraw( scrolled ? icon.firstPlot : icon.lastIcon );
    }
    else
    { /* only need to redraw the last icon */
      err = icon_redraw( icon.lastIcon );
    }
  }
  return err;
}

/* Box coordinates from the SWI */
_kernel_oserror *icon_swiBox( _kernel_swi_regs *r )
{
  _kernel_oserror *err = NULL;

  if( icon.firstIcon ) err = icon_clear( BLANK, &icon.box );

  icon.centreX = r->r[0] == -1;
  if( icon.centreX ) /* centre horizontally */
  {
    r->r[0] = ( screen_info.width - r->r[2] )/2;
    r->r[2] = ( screen_info.width + r->r[2] )/2;
  }

  icon.centreY = r->r[1] == -1;
  if( icon.centreY ) /* centre vertically */
  {
    r->r[1] = ( screen_info.height - r->r[3] )/2;
    r->r[3] = ( screen_info.height + r->r[3] )/2;
  }

  if(    r->r[0] < 0
      || r->r[0] > screen_info.width
      || r->r[1] < 0
      || r->r[1] > screen_info.height
      || r->r[2] < r->r[0]
      || r->r[2] > screen_info.width
      || r->r[3] < r->r[1]
      || r->r[3] > screen_info.height
    )
    err = error_make( ERROR_RECTANGLE );

  /* And convert to OS coordinates */
  if( !err )
  {
    icon.box.x0 = r->r[0] << screen_info.x_eig;
    icon.box.y0 = r->r[1] << screen_info.y_eig;
    icon.box.x1 = r->r[2] << screen_info.x_eig;
    icon.box.y1 = r->r[3] << screen_info.y_eig;
  }

  if( !err && icon.firstIcon != NULL )   /* Refitting and redraw required */
  {
    fit( icon.firstIcon, NULL );
    err = icon_clear( BLANK, &icon.box );
    if( !err ) err = plot_splash( NULL );
    if( !err ) err = icon_redraw( icon.firstPlot );
  }

  return err;
}

void icon_boxPosition( box *box, bool centreX, bool centreY )
{
  int screenWidth  = screen_info.width  << screen_info.x_eig;
  int screenHeight = screen_info.height << screen_info.y_eig;
  int boxWidth  = box->x1 - box->x0;
  int boxHeight = box->y1 - box->y0;
  /* Force bounding box to fit on the screen */
  if( boxWidth  > screenWidth  ) boxWidth  = screenWidth;
  if( boxHeight > screenHeight ) boxHeight = screenHeight;

  if( centreX )
  {
    /* centred  horizontally */
    box->x0 = ( screenWidth - boxWidth ) / 2;
    box->x1 = ( screenWidth + boxWidth ) / 2;
  }
  else  
  {
    /* force on screen */
    if( box->x0 < 0 )
    { box->x0 = 0;
      box->x1 = boxWidth;
    }

    if( box->x1 > screenWidth  )
    {
      box->x1 = screenWidth;
      box->x0 = box->x1 - boxWidth;
    }
  }

  if( centreY )
  {
    /* centred vertically */
    box->y0 = ( screenHeight - boxHeight ) / 2;
    box->y1 = ( screenHeight + boxHeight ) / 2;
  }
  else
  {
    /* force on screen */
    if( box->y0 < 0 )
    {
      box->y0 = 0;
      box->y1 = boxHeight;
    }
  
    if( box->y1 > screenHeight )
    {
      box->y1 = screenHeight;
      box->y0 = box->y1 - boxHeight;
    }
  }
printf( "Adjusted box (%d, %d), (%d, %d)\n", box->x0, box->y0, box->x1, box->y1 );
}

/* Call when a mode change occurs, after updating screen info and splash plotted */
_kernel_oserror *icon_mode( void )
{
  _kernel_oserror *err = NULL;

  /* Force the icon box to be on screen and centred as required */
  icon_boxPosition( &icon.box, icon.centreX, icon.centreY );

  /* now fit everything to it */
  err = fit( icon.firstIcon, NULL );

  /* redraw */
  if( !err ) err = icon_redraw( icon.firstPlot );
  
  return err;
}

/* Clears the area of screen using the named one pixel sprite */
/* If box == NULL, clear the icons area                       */
_kernel_oserror *icon_clear( char *spriteName, box *box )
{
  _kernel_oserror *err = NULL;
  _kernel_swi_regs r;
  
  if( !icon.icons.allocated )
  {
    error_setAsync( error_make( ERROR_NOICONS ));
    return NULL;
  }

  if( box == NULL ) box = &icon.box;

  if( box->x1 == 0 ) return NULL;

  if( !err )
  {
    r.r[0] = 0x100 + SpriteReason_SelectSprite;
    r.r[1] = (int) icon.icons.area;
    r.r[2] = (int) spriteName;
    err = _kernel_swi(OS_SpriteOp, &r, &r);
  }

  if( !err )
  {
    err = plot_sprite_translatedPtr
          ( graphics.area, (int *) r.r[2], box->x0, box->y0, box->x1 - box->x0, box->y1 - box->y0 );
  }
  
  return err;
}

/* End of icon.c */

