#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"
#include "swis.h"
#include "os.h"
#include "bbc.h"

#include "main.h"
#include "dynamiclib.h"
#include "ModHead.h"

/* Configuration parameters */
#ifdef UserIF_STB400
#define DEFAULT_CHOSEN_FONT		"Homerton.Bold\0"
#define DEFAULT_X_OFFSET		820
#define DEFAULT_Y_OFFSET		90
#define DEFAULT_TEXT_ALIGNMENT		3
#define DEFAULT_CHOSEN_FORE		0xFFFFFFu
#define DEFAULT_CHOSEN_BACK		0xBB3333u
#define DEFAULT_CHOSEN_TEXT_SIZE	18
#else
#define DEFAULT_CHOSEN_FONT		"Homerton.Medium\0"
#define DEFAULT_X_OFFSET		60
#define DEFAULT_Y_OFFSET		60
#define DEFAULT_TEXT_ALIGNMENT		1
#define DEFAULT_CHOSEN_FORE		0u
#define DEFAULT_CHOSEN_BACK		0xFFFFFFu
#define DEFAULT_CHOSEN_TEXT_SIZE	22
#endif

#define STARTUP_TIMEOUT                 1000 /* 10 seconds */
#define STARTUP_IMAGE                   "Resources:$.Resources.STBSplash.STB"
#define STARTUP_TEXT                    ""
#define STARTUP_DISABLE_VARIABLE        "STBSplash$Disable"
#define BOOT_ERROR_VARIABLE             "Boot$Error"
#define INET_ERROR_VARIABLE             "Inet$Error"

/* Some useful constants */
#define JPEG_Info 0x49980
#define JPEG_PlotScaled 0x49982
#define NH_AntiTwitter 0x838C0
#define SERVICE_REPORTERROR 0x57

#define UNUSED(x) x=x

static _kernel_oserror *plot_splash(const char *t);
static _kernel_oserror *set_up_font(char *fontname, int backcol, int forecol,
  int x_size, int y_size);
static _kernel_oserror *display_text(char *text, int x, int y, int orient,
  int *size_ok);
static _kernel_oserror *set_up_dynamic_area(const char *t);
static _kernel_oserror *create_sprite_splash(const char *filename, int filelen);
static _kernel_oserror *create_jpeg_splash(const char *filename, int filelen);
static _kernel_oserror *create_jpeg_splash_sub(const char *name, int filelen);
static _kernel_oserror *reset_everything(void);
static _kernel_oserror *fonts_to_os(int x, int y, int *result);
static void read_system_variables(void);
static int convert_to_int(char *in);
static _kernel_oserror *plot_sprite_translated(int x, int y);
static _kernel_oserror *read_mode_variable(int r0, int r1, int *res);
static _kernel_oserror *read_mode_variables(void);
//static _kernel_oserror *plot_blank_splash(int x, int y);
static int compare(const char *s1, const char *s2);
static _kernel_oserror *copy_error(_kernel_oserror *err);
static void set_async_error(_kernel_oserror *err);

static imageinfo_str  image_info;
static environment_str screen_info;
static misc_str misc_info;
static _kernel_oserror async_error_buf[1], *async_err=NULL;

dynamiclib_str  graphics, temp_jpeg;

/* These should be in a header file somewhere */
#define STBState_State	0x4b405
#define STBState_INIT	4

/* Callafter stuff *******************************************************/

/* Note: This can be modified by the callafter handler.  It is only safe to
 * change it when a callafter is not pending.
 */
static int callback_status=0;
#define CALLBACK_ACTIVE 1
#define CALLAFTER_ACTIVE 2

/* This flag is set when the splash screen gets disabled (ie: on Service_Error) */
#define SPLASH_ENABLED 1
#define SPLASH_DISABLED 0
static int splash_status = SPLASH_ENABLED;

/* When the callafter goes off, just set up a callback. */
_kernel_oserror *callafter_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs regs;

  callback_status &= ~CALLAFTER_ACTIVE;
  regs.r[0]=(int)callback_entry;
  regs.r[1]=(int)pw;
  /* If this returns an error, we can't really do much. */
  if(_kernel_swi(OS_AddCallBack, &regs, &regs) == NULL)
    callback_status |= CALLBACK_ACTIVE;
  return NULL;
}

_kernel_oserror *callback_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  UNUSED(pw);
  UNUSED(r);

  /* This is safe to call since there */
  callback_status &= ~CALLBACK_ACTIVE;

  /* The "can't connect" splash screen is not displayed if we have an error box open */
  if (splash_status == SPLASH_DISABLED)
  {
    return NULL;
  }

  /* Check if the variable exists */
  regs.r[0]=(int)STARTUP_DISABLE_VARIABLE;
  regs.r[1]=0;
  regs.r[2]=-1;
  regs.r[3]=0;
  regs.r[4]=0;
  _kernel_swi(OS_ReadVarVal, &regs, &regs);
  if(regs.r[2]!=0)
  {
    /* The splash screen is disabled. */
    return NULL;
  }

  /* Check if the Boot$Error variable is a non-empty string */
  regs.r[0]=(int)BOOT_ERROR_VARIABLE;
  regs.r[1]=0;
  regs.r[2]=-1;
  regs.r[3]=0;
  regs.r[4]=0;
  _kernel_swi(OS_ReadVarVal, &regs, &regs);
  if(regs.r[2]<-1 || regs.r[2]>0)
  {
    /* The splash screen is disabled when Boot$Error is non-empty. */
    return NULL;                          /* Exit (to Desktop) to report error in Boot$Error */
  }

  /* Check if the Inet$Error variable is a non-empty string */
  regs.r[0]=(int)INET_ERROR_VARIABLE;
  regs.r[1]=(int)malloc(512);             /* It's unlikely that the string will be 512 bytes in length */
  if (regs.r[1])                          /* when error blocks are currently 256 bytes maximum.        */
  {
    regs.r[2]=512;
    regs.r[3]=0;
    regs.r[4]=0;
    _kernel_swi(OS_ReadVarVal, &regs, &regs);
    if(regs.r[2]<-1 || regs.r[2]>0)
    {
      /* The splash screen is disabled when Inet$Error is non-empty. */
      regs.r[0]=(int)BOOT_ERROR_VARIABLE; /*  *Set Boot$Error <Inet$Error>  */
      regs.r[3]=0;
      regs.r[4]=4;
      _kernel_swi(OS_SetVarVal, &regs, &regs);
      return NULL;                        /* Exit (to Desktop) to report error in Boot$Error */
    }
    free((char *)regs.r[1]);
  }

  /* If we're not in STBState_INIT, don't display it. */
  if(_kernel_swi(STBState_State, &regs, &regs)==NULL &&
     regs.r[0]!=STBState_INIT)
    return NULL;

  /* Load the graphic */
  err = set_up_dynamic_area(STARTUP_IMAGE);

  if(err==NULL)
  {
    /* Plot it with default text. */
    err = plot_splash(STARTUP_TEXT);
  }

  if(err)
    set_async_error(err);

  return NULL;
}

/* Module initialisation routine */

_kernel_oserror *MyInit ( const char *cmd_tail, int podule_base, void *pw )
{
  _kernel_swi_regs regs;
  _kernel_oserror *err;

  UNUSED(cmd_tail);
  UNUSED(podule_base);

  graphics.allocated = 0;
  temp_jpeg.allocated = 0;

  regs.r[0]=STARTUP_TIMEOUT;
  regs.r[1]=(int)callafter_entry;
  regs.r[2]=(int)pw;

  err=_kernel_swi(OS_CallAfter, &regs, &regs);
  if (err == NULL) callback_status = CALLAFTER_ACTIVE;
  return(err);
}

/* Module finalisation routine */

_kernel_oserror *MyFinal(int fatal, int podule, void *pw)
{
  _kernel_oserror *err;
  _kernel_swi_regs regs;

  /* Free the dynamic areas if allocated */
  if (graphics.allocated)
    dynamiclib_free(&graphics);

  if (temp_jpeg.allocated)
    dynamiclib_free(&temp_jpeg);

  /* Stop the callafter */
  if(callback_status & CALLAFTER_ACTIVE)
  {
    regs.r[0]=(int)callafter_entry;
    regs.r[1]=(int)pw;
    err=_kernel_swi(OS_RemoveTickerEvent, &regs, &regs);
    /* Account for the case where the callafter goes off while we're
     * calling the SWI.  This will clear the callafter bit, and return
     * an error.  If the bit is now clear, the callafter has gone off
     * so we don't need to return the error.
     */
    if(err && (callback_status & CALLAFTER_ACTIVE))
      return err;
    /* It's now safe to touch this, as the callafter is cancelled */
    callback_status &= ~CALLAFTER_ACTIVE;
  }

  /* Stop the callback (now that the callafter has been stopped) */
  if(callback_status & CALLBACK_ACTIVE)
  {
    regs.r[0]=(int)callback_entry;
    regs.r[1]=(int)pw;
    err=_kernel_swi(OS_RemoveCallBack, &regs, &regs);
    if(err)
      return err;
    callback_status &= ~CALLBACK_ACTIVE;
  }
  return 0;
}

/* Module service call handler */
void MyService(int service, _kernel_swi_regs *r, void *pw)
{
  switch (service)
  {
    /* Disable the splash screen if an error box is open */
    case (SERVICE_REPORTERROR):
    {
      if (r->r[0] == 1)
        splash_status = SPLASH_DISABLED;
      else
        splash_status = SPLASH_ENABLED;
      break;
    }
  }
}

/* The command handler ***************************************************/
_kernel_oserror *cmd_handler(const char *arg_string, int argc, int cmd_no,
  void *pw)
{
  switch (cmd_no)
  {
    case CMD_STBSplash_Display:
      return plot_splash(arg_string);

    case CMD_STBSplash_Graphic:
      return set_up_dynamic_area(arg_string);

    case CMD_STBSplash_Reset:
      return reset_everything();

    case CMD_STBSplash_Error:
      {
        _kernel_oserror *err = async_err;
        async_err = NULL;
        return err;
      }
  }

  return 0;
}

/**************************
      Dynamic stuff
**************************/

static _kernel_oserror *set_up_dynamic_area(const char *filename)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;
  int filelen, filetype;
  const char *tmp;
  int filename_len;

  /* Free the dynamic area if it's already allocated. */
  if (graphics.allocated)
    dynamiclib_free(&graphics);

  /*** Read the information about the mode ***/
  err = read_mode_variables();
  if(err) return err;

  /* Read the catalogue information */
  r.r[0] = 17;
  r.r[1] = (int) filename;
  err=_kernel_swi(OS_File, &r, &r);

  /* If we got an error or it's not a file */
  if(err!=NULL || r.r[0] != 1)
    return err;

  /* Extract the type and length. */
  filelen = r.r[4];
  filetype = ( (r.r[2]>>20)&0xfff == 0xfff )
    ? (r.r[2] & 0x000fff00) >> 8 /* Typed file */
    : 0; /* Untyped file */

  graphics.type = 0;

  if (filetype == 0xff9) /* A sprite file */
    graphics.type = 1;
  else
  if (filetype == 0xc85) /* A JPEG file */
    graphics.type = 2;

  /* Find the end of the filename. */
  for(filename_len = 0; filename[filename_len]>=32; filename_len++)
    /* nothing */;

  if (graphics.type == 0 && filename_len > 4)
  {
    tmp = filename + filename_len - 4;

    if (compare(tmp, "/jpg"))
      graphics.type = 2;
  }

  switch(graphics.type)
  {
    case 1: /* A sprite file */
      err=create_sprite_splash(filename, filelen);
      break;

    case 2: /* A JPEG file */
      err=create_jpeg_splash(filename, filelen);
      break;

    default:
      /* Leave it unallocated */
      return NULL;
  }

  /* Free the graphics area if we got an error. */
  if(err)
  {
    err = copy_error(err);
    if (graphics.allocated)
      dynamiclib_free(&graphics);
  }
  return err;
}

static _kernel_oserror *
create_sprite_splash(const char *filename, int filelen)
{
  _kernel_oserror *err;
  _kernel_swi_regs r;
  char name[25];
  int x_eig, y_eig;
  /*** Set up the sprite area ***/

  image_info.size = filelen;

  strcpy(graphics.name, "Splash screen");
  graphics.size = filelen + 1024; /* Size of the area */

  err=dynamiclib_alloc(&graphics);
  if(err)
    return err;

  graphics.area[0] = graphics.size; /* Size of area */
  graphics.area[2] = 16;/* Offset to first sprite */
  /* Initialise sprite area (user sprite area) */
  r.r[0] = 256 + 9;
  r.r[1] = (int) graphics.area;
  err = _kernel_swi(OS_SpriteOp, &r, &r);
  if(err)
    return err;

  /*** Load the given sprite file into the area ***/
  r.r[0] = 256 + 10;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) filename;
  err = _kernel_swi(OS_SpriteOp, &r, &r);
  if(err)
    return err;

  /*** Read the information about the sprite ***/
  r.r[0] = 256 + 13;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) name;
  r.r[3] = sizeof(name);
  r.r[4] = 1; /* Sprite index */
  err=_kernel_swi(OS_SpriteOp, &r, &r);
  if(err)
    return err;

  strcpy(image_info.name, name);

  r.r[0] = 256 + 40;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) image_info.name;
  err=_kernel_swi(OS_SpriteOp, &r, &r);
  if(err)
    return err;

  image_info.mode = r.r[6];
  err=read_mode_variable(image_info.mode, 4, &x_eig);
  if(err)
    return err;
  err=read_mode_variable(image_info.mode, 5, &y_eig);
  if(err)
    return err;
  image_info.width = r.r[3] << x_eig;
  image_info.height = r.r[4] << y_eig;

  return err;
}

static _kernel_oserror *
create_jpeg_splash(const char *filename, int filelen)
{
  _kernel_oserror *err;
  strcpy(temp_jpeg.name, "Splash temp");
  temp_jpeg.size = filelen; /* Size of the area */

  /*** Allocate a temporary dynamic area for the JPEG data ***/

  err=dynamiclib_alloc(&temp_jpeg);

  if(err==NULL)
  {
    err=copy_error(create_jpeg_splash_sub(filename, filelen));
    dynamiclib_free(&temp_jpeg);
  }
  return err;
}

static _kernel_oserror *
create_jpeg_splash_sub(const char *filename, int jpegs)
{
  _kernel_oserror *err, *err2;
  _kernel_swi_regs r, saved;
  int width, height, mode, size_needed;
  int scale[4];
  int *palette;

  r.r[0] = 255;
  r.r[1] = (int) filename;
  r.r[2] = (int) temp_jpeg.area;
  r.r[3] = 0;
  err = _kernel_swi(OS_File, &r, &r);
  if(err)
    return err;

  /*** Get the info about the JPEG ***/

  r.r[0] = 1;
  r.r[1] = (int) temp_jpeg.area;
  r.r[2] = jpegs;                   /* Size of jpeg in buffer */
  err=_kernel_swi(JPEG_Info, &r, &r);
  if(err)
    return err;

  width = r.r[2];
  height = r.r[3];

  /*** Create sprite of the correct size ***/

  /* Each row is an integer number or words long. */
  size_needed = ( (width * screen_info.bpp + 31) / 32) * height * 4;

  strcpy(graphics.name, "Splash screen");
  graphics.size = size_needed + 1024; /* Size of the area */
  image_info.size = size_needed;

  err = dynamiclib_alloc(&graphics);
  if(err)
    return err;

  graphics.area[0] = graphics.size;
  graphics.area[2] = 16;
  r.r[0] = 256 + 9;
  r.r[1] = (int) graphics.area;
  err = _kernel_swi(OS_SpriteOp, &r, &r);
  if(err)
    return err;

  /* Read the screen mode */
  err = _swix(OS_ScreenMode, _IN(0) | _OUT(1), 1, &mode);
  if(err)
    return err;

  /* Sort out scaling */
  width = (width << 1) >> screen_info.x_eig;
  height = (height << 1) >> screen_info.y_eig;

  scale[0] = 2;
  scale[1] = 2;
  scale[2] = 1 << screen_info.x_eig;
  scale[3] = 1 << screen_info.y_eig;

  /*** Set the image_info structure data up ***/

  strcpy(image_info.name, "splash");
  image_info.width = width << screen_info.x_eig;
  image_info.height = height << screen_info.y_eig;
  image_info.mode = mode;

  /*** Create the new sprite ***/
  r.r[0] = 256 + 15;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) image_info.name;
  r.r[3] = screen_info.bpp <= 8 ? 1 : 0;
  r.r[4] = width;
  r.r[5] = height;
  r.r[6] = mode;
  err = _kernel_swi(OS_SpriteOp, &r, &r);
  if (err)
    return err;

  /*** Read current palette */
  if (screen_info.bpp <= 8)
  {
    r.r[0] = -1;
    r.r[1] = -1;
    r.r[2] = 0;
    r.r[4] = 0;
    err = _kernel_swi(ColourTrans_ReadPalette, &r, &r);
    if (err)
      return err;

    palette = malloc(r.r[3]);
    r.r[2] = (int) palette;
    err = _kernel_swi(ColourTrans_ReadPalette, &r, &r);
    if (err)
    {
      free(palette);
      return err;
    }

    /*** Write it to sprite ***/
    r.r[0] = (int) graphics.area;
    r.r[1] = (int) image_info.name;
    r.r[2] = (int) palette;
    r.r[3] = 0;
    r.r[4] = 0;
    err = _kernel_swi(ColourTrans_WritePalette, &r, &r);
    free(palette);
    if (err)
      return err;
  }

  /*** Switch output to the new sprite ***/

  r.r[0] = 256 + 60;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) image_info.name;
  r.r[3] = 0;
  err = _kernel_swi(OS_SpriteOp, &r, &saved);
  if (err)
    return err;

  /*** Blat the JPEG onto the new sprite ***/

  r.r[0] = (int) temp_jpeg.area;
  r.r[1] = 0;
  r.r[2] = 0;
  r.r[3] = (int) scale;
  r.r[4] = jpegs;
  r.r[5] = 0;
  err = _kernel_swi(JPEG_PlotScaled, &r, &r);

  /*** Switch output back to the screen ***/

  /* We need to do this even if an error happened */
  err2 = _kernel_swi(OS_SpriteOp, &saved, &r);

  if (err || err2)
    return err?err:err2;

  /* Pretend it's a sprite */
  graphics.type = 1;
  return 0;
}

static _kernel_oserror *reset_everything(void)
{
  if (graphics.allocated)
    return dynamiclib_free(&graphics);
  return 0;
}

/**************************
       Display stuff
**************************/

static _kernel_oserror *plot_splash(const char *text_in)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;
  char text[256];
  int text_x, text_y, x, y, size_okay, adjusted_x_size, adjusted_y_size;
  int scale[4];
  char *tt;

  /*** Strip the text of any quotes ***/

  if (text_in[0] == '"')
    text_in++;

  sprintf(text, "%.255s", text_in);

  tt = strrchr(text, '"');

  if (tt)
    *tt = 0;

  /*** Read the information about the mode again (it might have changed!) ***/

  err = read_mode_variables();
  if(err) return err;

  read_system_variables();

  /*** Plot the splash, either a sprite or a JPEG ***/

  if(graphics.allocated==0)
    graphics.type=0;

  if(graphics.type==0)
  {
    /* Some random numbers... */
    image_info.width = 436*2;
    image_info.height = 287*2;
  }

  x = ( (screen_info.width << screen_info.x_eig) - image_info.width) / 2;
  y = ( (screen_info.height << screen_info.y_eig) - image_info.height) / 2;

  switch(graphics.type)
  {
//  case 0: /* Blank */
//    err = plot_blank_splash(x, y);
//    if(err)
//      return err;
//    break;

  case 1: /* Sprite */

    err = plot_sprite_translated(x, y);
    if(err)
      return err;
    break;

  case 2: /* JPEG */
    scale[0] = 2;
    scale[1] = 2;
    scale[2] = 1 << screen_info.x_eig;
    scale[3] = 1 << screen_info.y_eig;

    r.r[0] = (int) graphics.area;
    r.r[1] = x;
    r.r[2] = y;
    r.r[3] = (int) scale;
    r.r[4] = image_info.size;
    r.r[5] = 0;
    err = _kernel_swi(JPEG_PlotScaled, &r, &r);

    if (err)
      return err;
    break;

  default: /* Just in case */
    return 0;
  }

  /* Need to do checks that the text will fit in, righthand alignment etc. */

  if (misc_info.text_x_offset > image_info.width)
    misc_info.text_x_offset = DEFAULT_X_OFFSET;
  text_x = ((screen_info.width << screen_info.x_eig) / 2)
         - (image_info.width / 2)
         + misc_info.text_x_offset;

  if (misc_info.text_y_offset > image_info.height)
    misc_info.text_y_offset = DEFAULT_Y_OFFSET;
  text_y = ((screen_info.height << screen_info.y_eig) / 2)
         - (image_info.height / 2)
         + misc_info.text_y_offset;

  adjusted_x_size = misc_info.chosen_x_size;
  adjusted_y_size = misc_info.chosen_y_size;

  do
  {
    err = set_up_font(misc_info.chosen_font, misc_info.chosen_back,
                      misc_info.chosen_fore, adjusted_x_size, adjusted_y_size);
    if(err) return err;

    /* The font is now allocated */

    err = display_text(text, text_x, text_y, misc_info.text_alignment,
                       &size_okay);
    err = copy_error(err);

    /* Make sure we lose the font in either case. */
    r.r[0] = misc_info.fonthandle;
    _kernel_swi(Font_LoseFont, &r, &r);

    if(err)
      return err;

    if (!size_okay) /* Probably too big to fit the box */
    {
      adjusted_x_size -= 2;
      adjusted_y_size -= 2;
    }
  } while (!size_okay && adjusted_x_size > 1);

  return 0;
}

/**************************
        Font stuff
**************************/

static _kernel_oserror *set_up_font(char *fontname, int backcol, int forecol,
  int x_size, int y_size)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;

  r.r[0] = 0;
  r.r[1] = (int) fontname;
  r.r[2] = x_size * 16;
  r.r[3] = y_size * 16;
  r.r[4] = r.r[5] = 0;
  err = _kernel_swi(Font_FindFont, &r, &r);
  misc_info.fonthandle = r.r[0];

  if (err == NULL)
  {
    r.r[0] = 0;
    r.r[1] = backcol;
    r.r[2] = forecol;
    r.r[3] = 14;
    err = _kernel_swi(ColourTrans_SetFontColours, &r, &r);
    if(err)
    {
      err = copy_error(err);

      /* Make sure we lose the font if we return an error. */
      r.r[0] = misc_info.fonthandle;
      _kernel_swi(Font_LoseFont, &r, &r);

      return err;
    }
  }
  else
  {
    r.r[0] = 0;
    r.r[1] = (int) "Homerton.Medium";
    r.r[2] = x_size * 16;
    r.r[3] = y_size * 16;
    r.r[4] = r.r[5] = 0;
    err = _kernel_swi(Font_FindFont, &r, &r);
    if(err) return err;
    misc_info.fonthandle = r.r[0];
  }
  return 0;
}

static _kernel_oserror *display_text(char *text, int x, int y, int orient,
  int *size_okay)
{
  _kernel_swi_regs r, p;
  _kernel_oserror *err;
  int width, height, success;
  char text_local[256];
  int output[16];
  int version;

  memset(text_local, 0, 255);

  sprintf(text_local, "%s\0", text);

  r.r[0] = 0;
  r.r[1] = (int) text_local;
  r.r[2] = 1000000;
  r.r[3] = 1000000;
  r.r[4] = -1;
  r.r[5] = 256;
  err = _kernel_swi(Font_StringWidth, &r, &r);
  if(err)
    return err;

  err = fonts_to_os(r.r[2], -1, &width);
  if(err)
    return err;
  height = misc_info.chosen_y_size << screen_info.y_eig;

  success = 1;  /* Default to it to fitting into the space */

  switch(orient)
  {
  case 1: /* Left alignment */
    if (width > (image_info.width - misc_info.text_x_offset - 30))
      success = 0;
    break;

  case 2:  /* Right alignment */
    if (width > (misc_info.text_x_offset - 30))
      success = 0;
    break;

  case 3:
    if (width > (image_info.width - 40))
      success = 0;
    break;
  }

  *size_okay = success;

  if(!success)
    return 0;

  r.r[0] = 0;
  r.r[1] = (int) text_local;
  r.r[2] = 16;

  err = _swix(Font_CacheAddr, _OUT(0), &version);
  if (!err && version >= 337)
   r.r[2] += 2048;  /* Blend to the background colour (bit 11) */

  switch(orient)
  {
  case 3: /* Centered */
    r.r[3] = ((screen_info.width << screen_info.x_eig) / 2) - (width / 2);
    break;

  case 2: /* Right */
    r.r[3] = x - width;
    break;

  case 1: /* Left */
    r.r[3] = x;
    break;
  }

  r.r[4] = y;
  r.r[5] = (int) output;
  p = r;
  err = _kernel_swi(Font_Paint, &r, &r);

  if (err)
    return err;

  r.r[0] = p.r[3] - 4;
  r.r[1] = p.r[4] - 4;
  r.r[2] = width + 8;
  r.r[3] = height + 8;

  if (strstr(text_local, "g") || strstr(text_local, "j") ||
      strstr(text_local, "p") ||
      strstr(text_local, "q") || strstr(text_local, "y"))
  {
    r.r[1] -= ((misc_info.chosen_y_size << screen_info.y_eig) / 2);
    r.r[3] += ((misc_info.chosen_y_size << screen_info.y_eig) / 2);
  }

  _kernel_swi(NH_AntiTwitter, &r, &r);

  return NULL;
}

static _kernel_oserror *fonts_to_os(int x, int y, int *result)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;

  r.r[1] = x;
  r.r[2] = y;
  err = _kernel_swi(Font_ConverttoOS, &r, &r);
  if(err) return err;

  if (x != -1)
  {
    *result=r.r[1];
  }
  else if (y != -1)
  {
    *result=r.r[2];
  }
  else
  {
    *result=0;
  }
  return(0);
}

static void stbsplash_read_var_val(const char *name, char *buffer, size_t len)
{
  if (_swix(OS_ReadVarVal, _INR(0,4)|_OUT(2), name, buffer, len, 0, 3, &len)) {
    len = 0;
  }
  buffer[len] = '\0';
}

static void read_system_variables(void)
{
  char  buffer[32];

  stbsplash_read_var_val("STBSplash$Font", misc_info.chosen_font,
                  sizeof(misc_info.chosen_font)-1);
  if (misc_info.chosen_font[0] == 0)
    strcpy(misc_info.chosen_font, DEFAULT_CHOSEN_FONT);

  stbsplash_read_var_val("STBSplash$Text_x", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.text_x_offset = atoi(buffer);
  else
    misc_info.text_x_offset = DEFAULT_X_OFFSET;
  if (misc_info.text_x_offset < 0)
    misc_info.text_x_offset = DEFAULT_X_OFFSET;

  stbsplash_read_var_val("STBSplash$Text_y", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.text_y_offset = atoi(buffer);
  else
    misc_info.text_y_offset = DEFAULT_Y_OFFSET;
  if (misc_info.text_y_offset < 0)
    misc_info.text_y_offset = DEFAULT_Y_OFFSET;

  stbsplash_read_var_val("STBSplash$Text_align", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.text_alignment = atoi(buffer);
  else
    misc_info.text_alignment = DEFAULT_TEXT_ALIGNMENT;
  if (misc_info.text_alignment < 1 || misc_info.text_alignment > 3)
    misc_info.text_alignment = DEFAULT_TEXT_ALIGNMENT;

  stbsplash_read_var_val("STBSplash$Text_fore", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.chosen_fore = convert_to_int(buffer) << 8;
  else
    misc_info.chosen_fore = DEFAULT_CHOSEN_FORE << 8;

  /* Set default background colour to be white */
  stbsplash_read_var_val("STBSplash$Text_back", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.chosen_back = convert_to_int(buffer) << 8;
  else
    misc_info.chosen_back = DEFAULT_CHOSEN_BACK << 8;

  stbsplash_read_var_val("STBSplash$Text_size", buffer, sizeof(buffer)-1);
  if (buffer[0] != 0)
    misc_info.chosen_x_size = atoi(buffer);
  else
    misc_info.chosen_x_size = DEFAULT_CHOSEN_TEXT_SIZE;
  if (misc_info.chosen_x_size < 1 || misc_info.chosen_x_size > 50)
    misc_info.chosen_x_size = DEFAULT_CHOSEN_TEXT_SIZE;

   /* Set the Y font size to be the same as the X */
   misc_info.chosen_y_size = misc_info.chosen_x_size;
}

/*---------------------------------------------------------------------------*
 * convert_to_int (from a hex number)                                        *
 *---------------------------------------------------------------------------*/

static int convert_to_int(char *in)
{
  int out;
  char *rest;

  out = (int) strtol(in, &rest, 16);

  return(out);
}

static _kernel_oserror *plot_sprite_translated(int x, int y)
{
  int *pal;
  int scale[4];
  _kernel_swi_regs r;
  _kernel_oserror *err;

  r.r[0] = 0x100;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) image_info.name;
  r.r[3] = r.r[4] = r.r[5] = 0;
  r.r[6] = (int) scale;
  r.r[7] = 0;
  err = _kernel_swi(Wimp_ReadPixTrans, &r, &r);
  if (err)
    return err;

  r.r[0] = (int) graphics.area;
  r.r[1] = (int) image_info.name;
  r.r[2] = r.r[3] = -1;
  r.r[4] = 0;
  r.r[5] = 16;
  err = _kernel_swi(ColourTrans_GenerateTable, &r, &r);
  if (err)
    return err;

  pal = malloc(r.r[4]);
  r.r[4] = (int) pal;
  err = _kernel_swi(ColourTrans_GenerateTable, &r, &r);
  if (err)
  {
      free(pal);
      return err;
  }

  r.r[0] = 256 + 52;
  r.r[1] = (int) graphics.area;
  r.r[2] = (int) image_info.name;
  r.r[3] = x;
  r.r[4] = y;
  r.r[5] = 32;
  r.r[6] = (int) scale;
  r.r[7] = (int) pal;
  err = _kernel_swi(OS_SpriteOp, &r, &r);
  free(pal);
  return err;
}

static _kernel_oserror *read_mode_variable(int r0, int r1, int *res)
{
  _kernel_swi_regs r;
  _kernel_oserror *err;

  r.r[0] = r0;
  r.r[1] = r1;
  err = _kernel_swi(OS_ReadModeVariable, &r, &r);
  if(err==NULL)
    *res = r.r[2];
  return err;
}

static _kernel_oserror *read_mode_variables(void)
{
  int log2_bpp;
  _kernel_oserror *err;

  err = read_mode_variable(-1, 4, &screen_info.x_eig);
  if(err) return err;

  err = read_mode_variable(-1, 5, &screen_info.y_eig);
  if(err) return err;

  err = read_mode_variable(-1, 11, &screen_info.width);
  if(err) return err;

  err = read_mode_variable(-1, 12, &screen_info.height);
  if(err) return err;

  err = read_mode_variable(-1, 9, &log2_bpp);
  if(err) return err;

  screen_info.bpp = 1 << log2_bpp;

  return err;
}

//static _kernel_oserror *plot_blank_splash(int x, int y)
//{
//  _kernel_swi_regs r;
//  _kernel_oserror *err;
//  char *taskname = "Splash Screen";
//  int handle;
//
//  err = _swix(ColourTrans_SetGCOL, _INR(0,4), DEFAULT_CHOSEN_BACK << 8, 0, 0, 0, 0);
//  if(err)
//    return err;
//
//  r.r[0] = 3;
//  err = _kernel_swi(Wimp_ReadSysInfo, &r, &r);
//  if (r.r[0] == 0)
//  {
//    err = bbc_rectanglefill(x, y, image_info.width - 1, image_info.height - 1);
//  }
//  else
//  {
//    r.r[0] = 310;
//    r.r[1] = 0x4B534154;
//    r.r[2] = (int) taskname;
//    err    = _kernel_swi(Wimp_Initialise, &r, &r);
//    if (err) return(err);
//    handle = r.r[1];
//
//    err = bbc_rectanglefill(x, y, image_info.width - 1, image_info.height - 1);
//    if (err) return(err);
//
//    r.r[0] = handle;
//    r.r[1] = 0x4B534154;
//    err    = _kernel_swi(Wimp_CloseDown, &r, &r);
//  }
//
//  return(err);
//}

/* Return 1 (true) if the strings are the same (ignoring case).
 * Return 0 otherwise.
 */
static int compare(const char *s1, const char *s2)
{
  for(; tolower(*s1)==tolower(*s2); s1++, s2++)
    if(*s2 == 0) /* Have we reached the end? */
      return 1;
  /* The strings are different */
  return 0;
}

/* Copy the error into an internal buffer (unless it's already there).
 * Give it NULL and it returns NULL.
 */
static _kernel_oserror *copy_error(_kernel_oserror *err)
{
  static _kernel_oserror error_buffer[1];

  if(err==NULL || err==error_buffer)
    return err;
  memcpy(error_buffer, err, sizeof(error_buffer));
  return error_buffer;
}

/* Set the asynchronous error
 */
static void set_async_error(_kernel_oserror *err)
{
  if(err)
  {
    memcpy(async_error_buf, err, sizeof(async_error_buf));
    async_err = async_error_buf;
  }
  else
  {
    async_err = NULL;
  }
}
