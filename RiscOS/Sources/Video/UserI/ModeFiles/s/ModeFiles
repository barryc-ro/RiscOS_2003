; > Sources.ModeFiles

; *********************************
; ***    C h a n g e   L i s t  ***
; *********************************

; Date       Description
; ----       -----------
; 01-Feb-96     0.01    Created

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
	GET	Hdr:Machine.<Machine>
	$GetIO
	GET	Hdr:CMOS
        GET     Hdr:Proc
        GET	Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:NewErrors
        GET     Hdr:MsgTrans
        GET     VersionASM

TAB     *       9

MonitorResolutionBits   *       &1F
MonitorDepthShift       *       5
MonitorDepthBits        *       &60
MonitorFrameRateBit     *       &80

; Sort out PAL/NTSC build type.
 [ :DEF: DontDetectHardware

                GBLS    TVStandard     ; used only for help string
TVStandard      SETS    "Slave"

 |

                GBLL    DontDetectHardware
DontDetectHardware SETL {FALSE}

		GBLL	PAL_Support
		GBLL	NTSC_Support
 [ :LNOT: :DEF: BuildForPAL
		GBLL	BuildForPAL
		GBLS	TVStandard

		ASSERT	IOMD_C_PALNTSCType <> 0 ; Must build PAL or NTSC on this machine.
 |
PAL_Support	SETL	BuildForPAL
NTSC_Support	SETL	:LNOT: BuildForPAL
   [ IOMD_C_PALNTSCType <> 0
		! 0, "Building hardware-detect version."
   ]
 ]

 [ IOMD_C_PALNTSCType <> 0
PAL_Support	SETL	{TRUE}
NTSC_Support	SETL	{TRUE}
TVStandard	SETS	"Auto"
 ]

		GBLL	Monitor_Support
 [ IOMD_C_MonitorType <> 0
Monitor_Support	SETL	{TRUE}
 |
Monitor_Support	SETL	{FALSE}
 ]

 [ PAL_Support
   [ :LNOT: :DEF: PAL_Columns
                GBLA    PAL_Columns
PAL_Columns     SETA    768
   ]
 ]

 ] ; :DEF: DontDetectHardware

; *****************************************************************************
;
;       Workspace layout
;
workspace       RN      r12
                ^       0,workspace

wsorigin                #       0

 [ DontDetectHardware
unused                  #       1    ; I don't want the workspace size to be zero
 |
display_mode            #       6*4
monitor_type            #       1
 ]

                        #       3:AND:(-:INDEX:@)

max_running_work        *       :INDEX:@


; **************** Module code starts here **********************

        ASSERT  (.-Module_BaseAddr) = 0

	&       0					; Start
	&       Mod_Init	- Module_BaseAddr
	&       0                                       ; Die
 [ DontDetectHardware
	&       0                                       ; Service
 |
	&       Mod_Service	- Module_BaseAddr	; Service
 ]
	&       Mod_Title	- Module_BaseAddr
	&       Mod_HelpStr	- Module_BaseAddr
	&       0					; HC_Table
	&       &4D480                                  ; SWI base
	&       Mod_SWIHandler  - Module_BaseAddr
	&       Mod_SWIDecode   - Module_BaseAddr
	&       0

Mod_Title
Mod_SWIDecode
        =       "ModeFiles", 0
        =       "MonitorType", 0
        =       "SafeArea", 0
        =       0

Mod_HelpStr
        =       "ModeFiles", TAB, "$Module_MajorVersion ($Module_Date) $TVStandard $Module_MinorVersion", 0
        ALIGN


; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init
        ENTRY   "r1-r4"

        LDR     r2, [r12]                       ; Have we already got a workspace ?
        CMP     r2, #0
        BNE     %FT01

        MOV     r0, #6
        LDR     r3, =max_running_work
        SWI     XOS_Module                      ; Claim workspace.
        EXIT    VS

        STR     r2, [r12]                       ; Store workspace pointer.
01
        MOV     r12, r2

 [ DontDetectHardware

        ADR     r0, ModeFilesPathVar
        ADR     r1, ModeFilesPathValue
        MOV     r2, #ModeFilesPathValueEnd - ModeFilesPathValue
        MOV     r3, #0
        MOV     r4, #4 ; VarType_LiteralString
        SWI     XOS_SetVarVal

        EXIT                                     ; Nothing else to do at this stage

ModeFilesPathVar
        =       "ModeFiles$Path", 0
ModeFilesPathValue
        =       "Resources:$.Resources.Monitors."
ModeFilesPathValueEnd
        =       0
        ALIGN

 | ; options out everything until Mod_SWIHandler!

	; Determine TV/Monitor type
 [ IOMD_C_PALNTSCType <> 0 :LOR: IOMD_C_MonitorType <> 0
	MOV	r0, #IOMD_Base			; Read the IOMD 8 bit port.
	LDR	r0, [r0, #IOMD_CLINES]
 ]

 [ IOMD_C_PALNTSCType = 0
   [ BuildForPAL
	MOV	r1, #0
   |
	MOV	r1, #8
   ]
 |
	TST	r0, #IOMD_C_PALNTSCType		; Check for PAL/NTSC
	MOVEQ	r1, #0				; 0 = PALTV
	MOVNE	r1, #8				; 8 = NTSCTV
 ]

 [ IOMD_C_MonitorType <> 0
	ASSERT	Monitor_Support
	TST	r0, #IOMD_C_MonitorType		; Check for monitor/TV
	MOVEQ	r1, #3				; 3 = VGA
 |
	ASSERT	:LNOT:Monitor_Support
	! 0, "Assuming TV only"
 ]

	STRB    r1, monitor_type

 [ :LNOT: ChrontelSupport
   [ PAL_Support
	CMP     R1, #0				; 0 = PALTV
	ADREQ   R0, PALTV
	ADREQ   R1, PALText
	MOVEQ   R2, #PALTextEnd-PALText
	BEQ     DoLoad
   ]
   [ NTSC_Support
	CMP     R1, #8				; 8 = NTSCTV
	ADREQ   R0, NTSCTV
	ADREQ   R1, NTSCText
	MOVEQ   R2, #NTSCTextEnd-NTSCText
	BEQ     DoLoad
   ]
   [ Monitor_Support
	CMP     R1, #3				; 3 = VGA
   ]
	EXIT    NE				; This should never happen
 ]

 [ Monitor_Support :LOR: ChrontelSupport
	MOV     R0, #ReadCMOS                   ; set VGA or VGAPlus mode file depending on CMOS
	MOV     R1, #MonitorModeCMOS
	SWI     XOS_Byte
	TST     R2, #MonitorFrameRateBit
	ADREQ   R0, VGA
	ADRNE   R0, VGAPlus
	ADR     R1, VGAText
	MOV     R2, #VGATextEnd-VGAText
 ]

DoLoad
	SWI	XOS_CLI                         ; do the LoadModeFile
	ADR     R0, TVTypeVar                   ; set TV$Type
	MOV     R3, #0
	MOV     R4, #4
	SWI     XOS_SetVarVal
	EXIT

 [ :LNOT: ChrontelSupport
   [ PAL_Support
PALTV           = "LoadModeFile Resources:Resources.Monitors.PALTV", 0
PALText         = "PAL"
PALTextEnd      = 0
   ]
   [ NTSC_Support
NTSCTV          = "LoadModeFile Resources:Resources.Monitors.NTSCTV", 0
NTSCText        = "NTSC"
NTSCTextEnd     = 0
   ]
 ]
VGA             = "LoadModeFile Resources:Resources.Monitors.VGA", 0
VGAPlus         = "LoadModeFile Resources:Resources.Monitors.VGAPlus", 0
VGAText         = "VGA"
VGATextEnd      = 0
TVTypeVar       = "TV$Type", 0
        ALIGN


; *****************************************************************************
;
;       Mod_Service - obvious really
;

Mod_ServiceTable
        &       0
        &       Mod_ServiceEntry - Module_BaseAddr
        &       Service_PostInit
        &       Service_MonitorLeadTranslation
        &       0

        DCD     Mod_ServiceTable - Module_BaseAddr
Mod_Service
        MOV     r0, r0
	TEQ	r1, #Service_MonitorLeadTranslation
	TEQNE	r1, #Service_PostInit
	MOVNES	pc, lr
Mod_ServiceEntry
	TEQ	r1, #Service_MonitorLeadTranslation
	BEQ	MonitorLeadTranslation

; Service_PostInit (PRM 1-264)
;   Exit:
;     All registers preserved

	; Eaugh!  On PostInit, set the screen mode.
	ENTRY	"r0-r2"
	MOV	r0, #1				; Read configured mode
	SWI	XOS_ReadSysInfo

	MOVVC	r1, r0
	MOVVC	r0, #0				; Set the mode
	SWIVC	XOS_ScreenMode
	EXITS

; Service_MonitorLeadTranslation (PRM 1-625)
;     r2 = monitor lead ID
;   Exit:
;     r1 = 0
;     r3 = Mode selector (PRM 5a-102)
;        0: Flags = 1
;        4: X resolution
;        8: Y resolution
;       12: depth
;       16: Frame rate
;       20: Terminator = -1
;     r4 = Monitor number
;     r5 = Sync type
MonitorLeadTranslation	ENTRY	"r0"

        LDR     r12, [r12]

 	MOV	r5, #0				; Normal sync.
	LDRB	r4, monitor_type		; Load monitor type

	ADR	r3, VGAMode
 [ PAL_Support
	CMP	r4, #0				; 0 = PALTV
	ADREQ	r3, PALMode
 ]

 [ NTSC_Support
	CMP	r4, #8				; 8 = NTSCTV
	ADREQ	r3, NTSCMode
 ]

 [ Monitor_Support :LOR: ChrontelSupport
	CMP	r4, #3
	BLEQ	CheckConfiguredMode
 ]

 [ ChrontelSupport
	MOV	r4, #3				; Fake VGA if Chrontel present.
 ]

	MOV	r1, #0
	EXITS

; Mode selectors for basic modes.
VGAMode		DCD	1, 640, 480, 4, -1, -1
 [ PAL_Support
   [ ChrontelSupport
PALMode		DCD	1, PAL_Columns, 576, 3, 50, -1
   |
PALMode		DCD	1, PAL_Columns, 576, 4, -1, -1
   ]
 ]
 [ NTSC_Support
   [ ChrontelSupport
NTSCMode	DCD	1, 640, 480, 3, 60, -1
   |
NTSCMode	DCD	1, 640, 480, 4, -1, -1
   ]
 ]


 [ Monitor_Support :LOR: ChrontelSupport
CheckConfiguredMode
; Out:  r3 = configured mode if valid (else preserved)
;
        ENTRY   "r0-r2,r4,r5"

        MOV     r0, #161                ; read configured display mode
        MOV     r1, #MonitorModeCMOS
        SWI     XOS_Byte

        AND     r4, r2, #MonitorDepthBits       ; extract depth 0 = 8bpp, 1 = 16bpp, 2 = 32bpp, 3 = reserved
        MOV     r4, r4, LSR #MonitorDepthShift
        TEQ     r4, #3
        EXIT    EQ

        ANDS    r2, r2, #MonitorResolutionBits  ; extract resolution index
   [ IOMD_C_PALNTSCType <> 0
 	ASSERT	PAL_Support :LAND: NTSC_Support
	; Z bit set if selected resolution 0
	MOVEQ	r0, #IOMD_Base			; If resolution zero,
	LDREQ	r0, [r0, #IOMD_CLINES]
	TSTEQ	r0, #IOMD_C_PALNTSCType		; Check PAL/NTSC type
	ADREQ	lr, PALRes			; If resolution zero and PAL, use alternate...
	BEQ	%FT10				; ...and skip the next bit.
   ]
	CMP     r2, #(EndResolutions-Resolutions)/12
	EXIT    CS

	ADR     lr, Resolutions         ; get x,y resolution
	ADD     lr, lr, r2, LSL #3
	ADD     lr, lr, r2, LSL #2
10	LDMIA   lr, {r1,r2,r5}          ; load x,y and frame rate

        MOV     r0, #1                  ; construct display mode and return it
        ADD     r4, r4, #3
        MOV     lr, #-1
        ADR     r3, display_mode
        STMIA   r3, {r0-r2,r4,r5,lr}	; 1, x_res, y_res, depth, rate, -1
        EXIT

Resolutions
   [ ChrontelSupport
     [ NTSC_Support
	DCD	640, 480, 60		; Resolution 0 (TV mode)
     |
	DCD	PAL_Columns, 576, 50
     ]
   |
     [ NTSC_Support
	DCD	640, 480, -1
     |
	DCD	PAL_Columns, 576, -1
     ]
   ]
	DCD	800, 600, -1		; Resolution 1
	DCD	1024, 768, -1		; Resolution 2
EndResolutions

   [ PAL_Support :LAND: NTSC_Support
     [ ChrontelSupport
PALRes	DCD	PAL_Columns, 576, 50
     |
PALRes	DCD	PAL_Columns, 576, -1
     ]
   ]
 ]

 ] ; DontDetectHardware (option bracket opened in Mod_Init)

; *****************************************************************************
;
;       Mod_SWIHandler - obvious really
;

Mod_SWIHandler
        LDR     r12, [r12]
        CMP     r11, #(JumpTableEnd-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        B       BadSWI

JumpTable
        B       MonitorType
        B       SafeArea
JumpTableEnd

BadSWI
        ENTRY "r1-r7"
        ADR     r0, ErrorBadSWI
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        ADR     r4, Mod_Title
        SWI     XMessageTrans_ErrorLookup
        EXIT

ErrorBadSWI
        DCD     ErrorNumber_ModuleBadSWI
        DCB     "BadSWI",0
        ALIGN

Divide
; Out:  r0 = r0 / r1
;
        ENTRY   "r1,r2"
        DivRem  r2, r0, r1, lr
        MOV     r0, r2
        EXIT

MonitorType
 [ DontDetectHardware
        ENTRY   "r1-r4"
        ADR     r0, TVTypeVar
        MOV     r2, #-1
        MOV     r3, #0
        MOV     r4, #0
        SWI     XOS_ReadVarVal
        MOVS    r0, r2
        BEQ     %FT01                   ; if variable not set, treat it as PAL
        RSB     r2, r2, #7
        BIC     r2, r2, #3              ; r2 = size needed for sp + string + terminator, rounded up to words
        STR     sp, [sp, -r2]!
        ADR     r0, TVTypeVar
        ADD     r1, sp, #4
        MOV     r3, #0
        SWI     XOS_ReadVarVal
        Pull    "sp, lr"                ; lr = first four chars of variable; restore stack
        LDR     r0, NTSCString          ; r0 = "NTSC" as a word
        TEQ     r0, lr
        MOVEQ   r0, #8
        MOVNE   r0, #0
01      ; r0 = 0 => PAL, r0 = 8 => NTSC
        CLRV
        EXIT

TVTypeVar       = "TV$Type", 0          ; earlier definition is optioned out
        ALIGN
NTSCString      = "NTSC"
 |
 [ ChrontelSupport
	MOV	r0, #3			; Always fake VGA
 |
        LDRB    r0, monitor_type
 ]
        MOVS    pc, lr
 ]

SafeArea
        ENTRY   "r4-r8"

        MOV     r2, #11                 ; x pixels
        MOV     r3, #12                 ; y pixels
        MOV     r4, #4                  ; x eig factor
        MOV     r5, #5                  ; y eig factor
        MOV     lr, #-1                 ; terminator
        Push    "r2-r5,lr"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r2-r5,lr"              ; get results
        EXIT    VS

        ADD     r2, r2, #1              ; get width and height
        ADD     r3, r3, #1

 [ DontDetectHardware
        BL      MonitorType
        MOV     r6, r0
 |
        LDRB    r6, monitor_type
 ]

        TEQ     r6, #0                  ; if not PAL
        TEQNE   r6, #8                  ; and not NTSC
        MOVNE   r0, #0                  ; then return full screen
        MOVNE   r1, #0
        BNE     %FT10

        TEQ     r6, #0                  ; load appropriate percentages
        ADREQ   lr, PALPercentages
        ADRNE   lr, NTSCPercentages
        LDMIA   lr, {r6-r8,lr}

        MOV     r1, #100                ; divisor is always 100

        MUL     r0, lr, r3              ; calculate max y
        BL      Divide
        MUL     lr, r7, r3
        SUB     r3, r3, r0

        MOV     r0, lr                  ; calculate min y
        BL      Divide
        MOV     r7, r0

        MUL     r0, r8, r2              ; calculate max x
        BL      Divide
        MUL     r8, r6, r2
        SUB     r2, r2, r0

        MOV     r0, r8                  ; calculate min x
        BL      Divide
        MOV     r1, r7                  ; restore min y

10
        MOV     r0, r0, LSL r4          ; convert to OS units
        MOV     r1, r1, LSL r5
        MOV     r2, r2, LSL r4
        MOV     r3, r3, LSL r5

        EXIT

; Percentages for left, bottom, right, top of screen giving borders round safe area.
;
PALPercentages
        DCD     $PALSafeArea

NTSCPercentages
        DCD     $NTSCSafeArea

        END
