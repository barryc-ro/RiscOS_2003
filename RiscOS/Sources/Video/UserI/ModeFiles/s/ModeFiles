; > Sources.ModeFiles

; *********************************
; ***    C h a n g e   L i s t  ***
; *********************************

; Date       Description
; ----       -----------
; 01-Feb-96     0.01    Created

Module_BaseAddr

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
	GET	Hdr:Machine.<Machine>
        GET     Hdr:Proc
        GET	Hdr:Services
        GET     Hdr:FSNumbers
        GET     Hdr:HighFSI
        GET     Hdr:NewErrors
        GET     Hdr:MsgTrans
        GET     Version

TAB     *       9

MonitorResolutionBits   *       &1F
MonitorDepthShift       *       5
MonitorDepthBits        *       &60
MonitorFrameRateBit     *       &80

; *****************************************************************************
;
;       Workspace layout
;
workspace       RN      r12
                ^       0,workspace

wsorigin                #       0

display_mode            #       6*4
monitor_type            #       1

                        #       3:AND:(-:INDEX:@)

max_running_work        *       :INDEX:@


; **************** Module code starts here **********************

        ASSERT  (.-Module_BaseAddr) = 0

	&       0					; Start
	&       Mod_Init	- Module_BaseAddr
	&       0                                       ; Die
	&       Mod_Service	- Module_BaseAddr	; Service
	&       Mod_Title	- Module_BaseAddr
	&       Mod_HelpStr	- Module_BaseAddr
	&       0					; HC_Table
	&       &4D480                                  ; SWI base
	&       Mod_SWIHandler  - Module_BaseAddr
	&       Mod_SWIDecode   - Module_BaseAddr
	&       0

Mod_Title
Mod_SWIDecode
        =       "ModeFiles", 0
        =       "MonitorType", 0
        =       "SafeArea", 0
        =       0

Mod_HelpStr
        =       "ModeFiles", TAB, TAB, "$VString ($Date)", 0
        ALIGN


; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init
        ENTRY   "r1-r4"

        LDR     r2, [r12]                       ; Have we already got a workspace ?
        CMP     r2, #0
        BNE     %FT01

        MOV     r0, #6
        LDR     r3, =max_running_work
        SWI     XOS_Module                      ; Claim workspace.
        EXIT    VS

        STR     r2, [r12]                       ; Store workspace pointer.
01
        MOV     r12, r2

	MOV	R0, #1
	SWI	XOS_ReadSysInfo                 ; R1 = Monitor Type
	EXIT	VS

        STRB    r1, monitor_type
        
	CMP     R1, #0
	ADREQ   R0, PALTV
	ADREQ   R1, PALText
	MOVEQ   R2, #PALTextEnd-PALText
	BEQ     DoLoad
	CMP     R1, #8
	ADREQ   R0, NTSCTV
	ADREQ   R1, NTSCText
	MOVEQ   R2, #NTSCTextEnd-NTSCText
	BEQ     DoLoad
	CMP     R1, #3
	EXIT    NE
	MOV     R0, #161                        ; set VGA or VGAPlus mode file depending on CMOS
	MOV     R1, #&6C
	SWI     XOS_Byte
	TST     R2, #MonitorFrameRateBit
	ADREQ   R0, VGA
	ADRNE   R0, VGAPlus
	ADR     R1, VGAText
	MOV     R2, #VGATextEnd-VGAText

DoLoad
	SWI	XOS_CLI                         ; do the LoadModeFile
	ADR     R0, TVTypeVar                   ; set TV$Type
	MOV     R3, #0
	MOV     R4, #4
	SWI     XOS_SetVarVal
	EXIT

PALTV           = "LoadModeFile Resources:Resources.Monitors.PALTV", 0
PALText         = "PAL"
PALTextEnd      = 0
NTSCTV          = "LoadModeFile Resources:Resources.Monitors.NTSCTV", 0
NTSCText        = "NTSC"
NTSCTextEnd     = 0
VGA             = "LoadModeFile Resources:Resources.Monitors.VGA", 0
VGAPlus         = "LoadModeFile Resources:Resources.Monitors.VGAPlus", 0
VGAText         = "VGA"
VGATextEnd      = 0
TVTypeVar       = "TV$Type", 0
        ALIGN


 [ {FALSE}
 
ReadTVType
; Out:  r1 = 0 (PAL), 3 (VGA - default) or 8 (NTSC)
;
        ENTRY   "r0,r2-r4"
        ADR     r0, TVTypeVar
        SUB     sp, sp, #8                      ; create local buffer
        MOV     r1, sp
        MOV     r2, #7
        MOV     r3, #0
        SWI     XOS_ReadVarVal
        MOV     r1, #3                          ; default to VGA
        Pull    "r3,lr"                         ; get result and balance stack
        EXIT    VS
        TEQ     r2, #0                          ; return default if not set
        EXIT    EQ
        TEQ     r4, #0                          ; return default if not set correctly
        EXIT    NE
        AND     r3, r3, #&FF                    ; only check first character
        LDRB    r0, PALText
        TEQ     r3, r0
        MOVEQ   r1, #0                          ; return 0 for PAL
        EXIT    EQ
        LDRB    r0, NTSCText
        TEQ     r3, r0
        MOVEQ   r1, #8                          ; return 8 for NTSC
        EXIT
        
 ]

; *****************************************************************************
;
;       Mod_Service - obvious really
;

Mod_Service
	TEQ	r1, #Service_MonitorLeadTranslation
	MOVNES	pc, lr

	ENTRY	"r0"

        LDR     r12, [r12]

        ADR     r0, MonitorLeadList
        ADR     r3, ModeList
10
        LDR     r14, [r0], #4
        EOR     r1, r2, r14, LSR #24            ; differences
        EOR     r14, r14, #&FF000000            ; make don't cares into zero
        TST     r14, #&C0000000
        BICEQ   r1, r1, #&C0                    ; knock out difference pairs if don't care
        TST     r14, #&30000000
        BICEQ   r1, r1, #&30
        TST     r14, #&0C000000
        BICEQ   r1, r1, #&0C
        TST     r14, #&03000000
        BICEQ   r1, r1, #&03
        TEQ     r1, #0                          ; if still have differences, then loop
        ADDNE   r3, r3, #24
        BNE     %BT10

        MOV     r0, #&FF
        AND     r4, r0, r14, LSR #8             ; monitortype in bits 8..15
        AND     r5, r0, r14, LSR #16            ; sync in bits 16..23
        ; r1 = 0 from above => claim service

        TEQ     r4, #3                          ; if monitor then
        BLEQ    CheckConfiguredMode             ; default mode may be overridden
        
        EXIT

        MACRO
        MonitorLeadItem $lead, $monitortype, $sync
        ASSERT $lead < 256
        ASSERT $monitortype < 256
        ASSERT $sync < 256
        DCD     (($lead):SHL:24):OR:(($sync):SHL:16):OR:(($monitortype):SHL:8)
        MEND

MonitorLeadList
	MonitorLeadItem 4_0331, 0, 0
	MonitorLeadItem 4_1331, 8, 0
	MonitorLeadItem 4_3333, 3, 0

ModeList
	DCD	1, 768, 576, 4, -1, -1
	DCD	1, 640, 480, 4, -1, -1
	DCD	1, 640, 480, 3, 60, -1
        

CheckConfiguredMode
; Out:  r3 = configured mode if valid (else preserved)
;
        ENTRY   "r0-r2,r4,r5"
        
        MOV     r0, #161                ; read configured display mode
        MOV     r1, #&6C
        SWI     XOS_Byte

        AND     r4, r2, #MonitorDepthBits       ; extract depth 0 = 8bpp, 1 = 16bpp, 2 = 32bpp, 3 = reserved
        MOV     r4, r4, LSR #MonitorDepthShift
        TEQ     r4, #3
        EXIT    EQ

        AND     r2, r2, #MonitorResolutionBits  ; extract resolution index
        CMP     r2, #(EndResolutions-Resolutions)/8
        EXIT    CS

        ADR     lr, Resolutions         ; get x,y resolution
        ADD     lr, lr, r2, LSL #3
        LDMIA   lr, {r1,r2}

        MOV     r0, #1                  ; construct display mode and return it
        ADD     r4, r4, #3
        MOV     r5, #-1
        MOV     lr, #-1
        ADR     r3, display_mode
        STMIA   r3, {r0-r2,r4,r5,lr}
        EXIT

Resolutions
        DCD     640, 480
        DCD     800, 600
        DCD     1024, 768
EndResolutions


; *****************************************************************************
;
;       Mod_SWIHandler - obvious really
;

Mod_SWIHandler
        LDR     r12, [r12]
        CMP     r11, #(JumpTableEnd-JumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        B       BadSWI

JumpTable
        B       MonitorType
        B       SafeArea
JumpTableEnd

BadSWI
        ENTRY "r1-r7"
        ADR     r0, ErrorBadSWI
        MOV     r1, #0
        MOV     r2, #0
        MOV     r3, #0
        ADR     r4, Mod_Title
        SWI     XMessageTrans_ErrorLookup
        EXIT

ErrorBadSWI
        DCD     ErrorNumber_ModuleBadSWI
        DCB     "BadSWI",0
        ALIGN

Divide
; Out:  r0 = r0 / r1
;
        ENTRY   "r1,r2"
        DivRem  r2, r0, r1, lr
        MOV     r0, r2
        EXIT

MonitorType
        LDRB    r0, monitor_type
        MOVS    pc, lr
        
SafeArea
        ENTRY   "r4-r8"

        MOV     r2, #11                 ; x pixels
        MOV     r3, #12                 ; y pixels
        MOV     r4, #4                  ; x eig factor
        MOV     r5, #5                  ; y eig factor
        MOV     lr, #-1                 ; terminator
        Push    "r2-r5,lr"
        MOV     r0, sp
        MOV     r1, sp
        SWI     XOS_ReadVduVariables
        Pull    "r2-r5,lr"              ; get results
        EXIT    VS

        ADD     r2, r2, #1              ; get width and height
        ADD     r3, r3, #1

        LDRB    r6, monitor_type
        TEQ     r6, #0                  ; if not PAL
        TEQNE   r6, #8                  ; and not NTSC
        MOVNE   r0, #0                  ; then return full screen
        MOVNE   r1, #0
        BNE     %FT10

        TEQ     r6, #0                  ; load appropriate percentages
        ADREQ   lr, PALPercentages
        ADRNE   lr, NTSCPercentages
        LDMIA   lr, {r6-r8,lr}
        
        MOV     r1, #100                ; divisor is always 100
        
        MUL     r0, lr, r3              ; calculate max y
        BL      Divide
        MUL     lr, r7, r3
        SUB     r3, r3, r0

        MOV     r0, lr                  ; calculate min y
        BL      Divide
        MOV     r7, r0

        MUL     r0, r8, r2              ; calculate max x
        BL      Divide
        MUL     r8, r6, r2
        SUB     r2, r2, r0

        MOV     r0, r8                  ; calculate min x
        BL      Divide
        MOV     r1, r7                  ; restore min y

10
        MOV     r0, r0, LSL r4          ; convert to OS units
        MOV     r1, r1, LSL r5
        MOV     r2, r2, LSL r4
        MOV     r3, r3, LSL r5
        
        EXIT

; Percentages for left, bottom, right, top of screen giving borders round safe area.
;
PALPercentages
        DCD     8, 8, 8, 8

NTSCPercentages
        DCD     3, 6, 3, 6
        

        END
