/*---------------------------------------------------------------------------*/
/* File:    c.acornlogo                                                      */
/* Purpose: Simple screen saver.                                             */
/* Author:  Richard Leggett                                                  */
/* History: 21-Nov-97: RML: Created.                                         */
/*          23-Mar-98: RML: Minor modifications.                             */
/*                                                                           */
/* Copyright © 1998 Acorn Computers Ltd., Cambridge, UK.                     */
/*---------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "wimp.h"
#include "wimplib.h"
#include "swis.h"
#include "wimplib.h"
#include "toolbox.h"
#include "event.h"
#include "window.h"

#define SpriteFile           "<BlankTask$Dir>.Frames"
#define FirstLoopingFrame    34
#define LastLoopingFrame     34
#define DelayBetweenFrames   2
#define DelayBetweenMoves    1
#define SpriteInitialiseArea 9
#define SpriteLoadFile       10
#define SpriteReadInfo       40
#define SpritePutScaled      52

static int       *spritearea = 0;
static char      *ctrans_table = 0;
static char       spritename[16];
static IdBlock    idb;
static MessagesFD messages_desc;
static int        screenw;
static int        screenh;
static int        animation_initialised = 0;
static int        current_frame;
static int        last_frame;
static int        last_move;
static int        spritew;
static int        spriteh;
static int        px;
static int        py;
static int        ax;
static int        ay;


/*---------------------------------------------------------------------------*
 * program_exit                                                              *
 *                                                                           *
 * Finished with this plug-in, so exit.                                      *
 *---------------------------------------------------------------------------*/

void program_exit(void)
{
    /* Turn on pointer */
    _swix(OS_Byte, _INR(0,1), 106, 1);

    /* Unset ScrSaver$Running */
    _swix(OS_SetVarVal, _INR(0,4), "ScrSaver$Running", 0, -1, 0, 0);
    
    /* Exit */
    if (spritearea) free(spritearea);
    if (ctrans_table) free(ctrans_table);
    exit(0);
}


/*---------------------------------------------------------------------------*
 * error_trap                                                                *
 *                                                                           *
 * Wrap around a function to report an error if one occurred eg.:            *
 *  error_trap(event_initialise(&idb), 0);                                   *
 *                                                                           *
 * In: err - a kernel_oserror block                                          *
 *     type - 0 means non-fatal, otherwise program will exit after reporting *
 *---------------------------------------------------------------------------*/

void error_trap(_kernel_oserror *err, int err_type)
{
    /* Report the appropriate error, has one occured */
    if (err != NULL)
    {
        wimp_report_error(err, 0, "Screen Blanker", 0, 0, 0);
  
        /* Now, if it was a fatal error (type != 0), exit at once */
        if (err_type != 0) exit(0);
    }    
}


/*---------------------------------------------------------------------------*
 * rnd                                                                       *
 *                                                                           *
 * Generate a random number between 1 and n.                                 *
 *---------------------------------------------------------------------------*/

int rnd(int n)
{
    return (int) ( ((float)rand()/(float)RAND_MAX) *n)+1;
}


/*---------------------------------------------------------------------------*
 * set_random_seed                                                           *
 *                                                                           *
 * Reset the random number seed to a value dependent on the monotonic timer. *
 *---------------------------------------------------------------------------*/

void set_random_seed(void)
{
    int time;
    
    _swix(OS_ReadMonotonicTime, _OUT(0), &time);
    srand(time);
}


/*---------------------------------------------------------------------------*
 * plot_sprite                                                               *
 *---------------------------------------------------------------------------*/

void plot_sprite(void)
{
    _swix(OS_SpriteOp, _INR(0,7),
                       256+SpritePutScaled, spritearea, spritename,
                       px, py, 32, 0, ctrans_table);
}


/*---------------------------------------------------------------------------*
 * initialise_animation                                                      *
 *---------------------------------------------------------------------------*/

int initialise_animation()
{
    _kernel_oserror *e;
    int              type = 0;
    int              size = 0;
    
    /* Find size of sprite file and get memory to store it */
    e = _swix(OS_File, _INR(0,1)|_OUT(0)|_OUT(4), 17, SpriteFile, &type, &size);
    if ((e) || (size==0) || (type==0)) return 0;
    spritearea = malloc(size+16);
    if (!spritearea) return 0;
    spritearea[0] = size + 16;
    spritearea[2] = 16;

    /* Initialise sprite area, read sprites into it and find their size */
    e=_swix(OS_SpriteOp, _INR(0,1), 256+SpriteInitialiseArea, spritearea);
    if (!e) e = _swix(OS_SpriteOp, _INR(0,2), 256+SpriteLoadFile, spritearea, SpriteFile);
    if (!e) e = _swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,4), 256+SpriteReadInfo, spritearea, "logo0", &spritew, &spriteh);
    if (e) return 0;
    spritew = spritew * 2;
    spriteh = spriteh * 2;
    
    /* Generate a colourtrans table */
    e = _swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), spritearea, "logo0", -1, -1, 0, 16, &size);
    if (e) return 0;				      
    ctrans_table = malloc(size);
    if (!ctrans_table) return 0;				       
    e = _swix(ColourTrans_GenerateTable, _INR(0,5), spritearea, "logo0", -1, -1, ctrans_table, 16);
    if (e) return 0;

    /* Set initial position and direction */
    memset(spritename, 0, 16);    
    sprintf(spritename, "logo0");
    set_random_seed();
    current_frame = -2;
    last_frame = _swi(OS_ReadMonotonicTime, _RETURN(0));
    last_move = last_frame;
    px = rnd(screenw-spritew);
    py = rnd(screenh-spriteh);
    ax = ay = rnd(2)*2;
    if (rnd(2)==1) ax = -ax;
    if (rnd(2)==1) ay = -ay;

    return 1;
}
    

/*---------------------------------------------------------------------------*
 * null_event                                                                *
 *                                                                           *
 * Null event handler - we do all our animation etc. here.                   *
 *---------------------------------------------------------------------------*/

int null_event(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    int time;
    int plot_it = 0;

    /* If we've failed to start up, then at least we get a blank screen */
    if (!animation_initialised) return 1;

    /* If we're just starting, then remove the high priority on pollword */
    if (current_frame==-2)
    {
        error_trap(event_set_mask(Wimp_Poll_PollWord), 0);    
        plot_it=1;
    }
 
    /* Change the frame? */
    time = _swi(OS_ReadMonotonicTime, _RETURN(0));
    if ((time-last_frame) >= DelayBetweenFrames)
    {
        last_frame = time;
        current_frame++;
        if (current_frame>LastLoopingFrame) current_frame = FirstLoopingFrame;
        plot_it = 1;
        sprintf(spritename, "logo%d", current_frame);
    }

    /* Move the animation? */
    if (current_frame >= FirstLoopingFrame)
    {
        if ((time-last_move) >= DelayBetweenMoves)
        {
            last_move = time;
            px += ax;
            py += ay;
            if (px>=(screenw-spritew)) ax =- ax;
            if (py>=(screenh-spriteh)) ay =- ay;
            if (px<=0) ax =- ax;
            if (py<=0) ay =- ay;
            plot_it = 1;
        }
    }

    if (plot_it) plot_sprite();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * gain_pointer                                                              *
 *                                                                           *
 * Pointer has entered my window - turn it off!                              *
 *---------------------------------------------------------------------------*/

int gain_pointer(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    _swix(OS_Byte, _INR(0,1), 106, 0);

    return 1;
}


/*---------------------------------------------------------------------------*
 * lose_pointer                                                              *
 *                                                                           *
 * Pointer has left my window - switch it back on again!                     *
 *---------------------------------------------------------------------------*/

int lose_pointer(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    _swix(OS_Byte, _INR(0,1), 106, 1);

    return 1;
}


/*---------------------------------------------------------------------------*
 * redraw                                                                    *
 *                                                                           *
 * Handle redraw events - do nothing!                                        *
 *---------------------------------------------------------------------------*/

int redraw(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    WimpRedrawWindowBlock block;
    int                   more;
    
    wimp_redraw_window(&block, &more);
    while (more)
    {
        wimp_get_rectangle(&block, &more);
    }
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * pollword                                                                  *
 *                                                                           *
 * Handle pollword non-zero events                                           *
 *---------------------------------------------------------------------------*/

int pollword(int event_code, WimpPollBlock *event, IdBlock *id_block, void *handle)
{
    program_exit();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * message_quit                                                              *
 *                                                                           *
 * Called when wimp quit message received.                                   *
 *---------------------------------------------------------------------------*/
 
int message_quit(WimpMessage *event, void *handler)
{
    program_exit();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * main_initialise                                                           *
 *---------------------------------------------------------------------------*/

static int main_initialise(void)
{
    WimpOpenWindowBlock win;
    BBox                extent;
    int                 main_window;
    int                 show[2];
    int                 xeig;
    int                 yeig;
    int                 xpixels;
    int                 ypixels;
    int                 task_handle;
    int                 wimp_handle;

    /* Initialise and register event handlers */
    error_trap(toolbox_initialise(0, 310, 0, 0, "<BlankTask$Dir>",
                                  &messages_desc, &idb, 0, &task_handle, 0), 1);
    error_trap(event_initialise(&idb), 0);
    error_trap(event_set_mask(Wimp_Poll_PollWord +
                              Wimp_Poll_PollWordHighPriority), 0);    

    error_trap(event_register_message_handler(Wimp_MQuit, message_quit, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_ENull, null_event, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_ERedrawWindow, redraw, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EPollWordNonZero, pollword, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EPointerEnteringWindow, gain_pointer, NULL), 0);
    error_trap(event_register_wimp_handler(-1, Wimp_EPointerLeavingWindow, lose_pointer, NULL), 0);

    /* Find screen size */
    error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 4, &xeig), 0);
    error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 5, &yeig), 0);
    error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 11, &xpixels), 0);
    error_trap(_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 12, &ypixels), 0);
    screenw = xpixels<<xeig;
    screenh = ypixels<<yeig;

    /* Set the extent of the 'covering' window. */
    extent.xmin = 0;
    extent.xmax = screenw;
    extent.ymin = 0;
    extent.ymax = screenh;
    show[0] = 0;
    show[1] = screenh;
    error_trap(toolbox_create_object(0, "Window", &main_window), 1);
    error_trap(window_set_extent(0, main_window, &extent), 0);
    error_trap(window_get_wimp_handle(0, main_window, &wimp_handle), 0);

    /* Open the covering window */
    win.window_handle = wimp_handle;
    win.visible_area.xmin = 0;
    win.visible_area.xmax = screenw;
    win.visible_area.ymin = 0;
    win.visible_area.ymax = screenh;
    win.xscroll = 0;
    win.yscroll = 0;
    win.behind = -1;
    error_trap(wimp_open_window(&win), 0);

    animation_initialised = initialise_animation();
    
    return 1;
}


/*---------------------------------------------------------------------------*
 * main                                                                      *
 *---------------------------------------------------------------------------*/

int main(int argc, char **argv)
{
    WimpPollBlock  wpb;
    int            event_code;
    int           *pollword = 0;

    if (argc>1) pollword = (int*) atoi(argv[1]);
    if (!pollword) program_exit();
    if (!main_initialise()) program_exit();
    
    while (TRUE)
    {
        error_trap(event_poll(&event_code, &wpb, pollword), 0);
    }
    
    return 0;
}
