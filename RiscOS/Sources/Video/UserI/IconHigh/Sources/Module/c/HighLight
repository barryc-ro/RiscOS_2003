#include <limits.h>
#include <stdlib.h>

#include "swis.h"

#include "Desk.Error2.h"
#include "Desk.WimpSWIs.h"
#include "Desk.Window.h"
#include "Desk.DeskMem.h"

#define	TaskModule_SendMessage	0x4d300

#include "^.Highlight.h"
#include "^.Globals.h"

#include "WindInfo2.h"
#include "DrawHL.h"





//#define	BEST_POINT( x, min, max)	Desk_MIN( Desk_MAX( x, min), max)

#define	CONTAINED( x, min, max)	( (x)>=(min) && (x)<(max))

static int	MinDistance( int amin, int amax, int bmin, int bmax)
	{
	int	s, s1, s2;
	
	Desk_Debug_Printf( Desk_error_PLACE "MinDistance( %i, %i, %i, %i)\n", amin, amax, bmin, bmax);
	
	if	( 
		   CONTAINED( amin, bmin, bmax+1)
		|| CONTAINED( amax, bmin, bmax+1)
		|| CONTAINED( bmin, amin, amax+1)
		|| CONTAINED( bmax, amin, amax+1)
		)
		{
		Desk_Debug_Printf( Desk_error_PLACE "MinDistance returning 0\n");
		return 0;
		}
	
	s1 = Desk_MIN( abs( amin-bmin), abs( amin-bmax));
	s2 = Desk_MIN( abs( amax-bmin), abs( amax-bmax));
	s = Desk_MIN( s1, s2);
	
	Desk_Debug_Printf( Desk_error_PLACE "MinDistance returning %i\n", s);
	
	return s;
	}


#define	MAJOR	3
#define	MINOR	1
#define	DISTANCE_SQUARED( major, minor)	( (major)*(major)/MAJOR/MAJOR + (minor)*(minor)/MINOR/MINOR)

#define	MakeGE( a, b)	if ((b)>(a))	(a)=(b)
#define	MakeLE( a, b)	if ((b)<(a))	(a)=(b)


void	MoveHighlight( Desk_wimp_point* newpos, iconhigh_direction direction, void* pw)
/*
cursor keypress should be in 'lastcursorkey'. We look for nearest icon
in the specified direction.
 */
	{
	Desk_window_info* volatile	info_volatile		= NULL;
	
	Desk_Debug_Printf( Desk_error_PLACE "MoveHighlight called for direction %i\n", (int) direction);
	
	Desk_Error2_Try	{
		Desk_window_info*		info;
		Desk_mouse_block		mouse;
		Desk_icon_block*		icons;
		int				besticon_number			= -1;
		int				besticon_distancesquared	= INT_MAX;
		int				besticon_rawdistance		= INT_MAX;
		Desk_wimp_point			besticon_centre = { 0, 0};
		int				i;
		Desk_wimp_point			mouse_workarea;
		Desk_wimp_rect			mouse_iconrect;
		
		Desk_Wimp_GetPointerInfo( &mouse);
		*newpos = mouse.pos;
		
		// Get all icons for current window...
		// First, how many icons:
		info = GetInfoAlloc( mouse.window);
		info_volatile = (Desk_window_info* volatile) info;
		
		mouse_workarea.x = mouse.pos.x + info->block.scroll.x - info->block.screenrect.min.x;
		mouse_workarea.y = mouse.pos.y + info->block.scroll.y - info->block.screenrect.max.y;
		
		Desk_Debug_Printf( Desk_error_PLACE "Window 0x%p has %i icons. Mouse is over icon %i\n", 
			(void*) mouse.window, 
			info->block.numicons,
			mouse.icon
			);
		
		
		// Find the rectangle for the current icon, if any. If not over an icon, use zero-size rect at position of pointer.
		// This rectangle is used when calulating the nearest icon to move to.
		if ( mouse.icon>=0)	{
			mouse_iconrect = ((Desk_icon_block*)(info+1))[ mouse.icon].workarearect;
			}
		else	{
			mouse_iconrect.min = mouse_workarea;
			mouse_iconrect.max = mouse_workarea;
			}
		
		// Step through each icon; if it is in specified direction, check whether it is closest so far.
		
		for ( i=0, icons=(Desk_icon_block*)(info+1); i<info->block.numicons; i++)	{
			Desk_icon_block*	icon = &icons[i];
			Desk_wimp_point		centre;
			Desk_wimp_point		dpos;
			unsigned int		distancesquared;
			//Desk_wimp_point		bestpoint;
			
			if ( 
				   direction!=iconhigh_direction_NONE 
				&& direction!=iconhigh_direction_NEAREST 
				&& i==mouse.icon
				)
				continue;	// Ignore current icon if we are moving.
			
			if ( icon->flags.data.buttontype == Desk_iconbtype_NEVER)	continue;
				// Ignore non-clickable icons
			
			if ( icon->flags.data.shaded)	continue;
				// Ignore shaded icons
			
			if ( !Desk_Coord_RectsOverlap( &info->block.workarearect, &icon->workarearect))	{
				Desk_Debug_Printf( Desk_error_PLACE "Icon %i is hidden outside accesible workarea of window\n", i);
				continue;
				}
				// Icon is hidden outside accesible workarea of window.
			
			if ( direction==iconhigh_direction_NONE)	{
				if ( Desk_Coord_PointInRect( &mouse_workarea, &icon->workarearect))	{
					Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and pointer within icon %i\n", i);
					besticon_number			= i;
					}
				}
			
			else	{
				dpos.x = MinDistance( mouse_iconrect.min.x, mouse_iconrect.max.x, icon->workarearect.min.x, icon->workarearect.max.x);
				dpos.y = MinDistance( mouse_iconrect.min.y, mouse_iconrect.max.y, icon->workarearect.min.y, icon->workarearect.max.y);
				
				/*
				bestpoint.x = BEST_POINT( mouse_workarea.x, icon->workarearect.min.x, icon->workarearect.max.x);
				bestpoint.y = BEST_POINT( mouse_workarea.y, icon->workarearect.min.y, icon->workarearect.max.y);
				*/
				centre.x = (icon->workarearect.max.x + icon->workarearect.min.x) / 2;
				centre.y = (icon->workarearect.max.y + icon->workarearect.min.y) / 2;
				
				/*
				dpos.x = abs( bestpoint.x - mouse_workarea.x);
				dpos.y = abs( bestpoint.y - mouse_workarea.y);
				*/
				
				if ( direction==iconhigh_direction_UP || direction==iconhigh_direction_DOWN)
					distancesquared = DISTANCE_SQUARED( dpos.y, dpos.x);
				else if ( direction==iconhigh_direction_LEFT || direction==iconhigh_direction_RIGHT)
					distancesquared = DISTANCE_SQUARED( dpos.x, dpos.y);
				else	distancesquared = dpos.x*dpos.x + dpos.y*dpos.y;
				
				
				Desk_Debug_Printf( Desk_error_PLACE "Icon %i, dpos=(%i,%i), dpos2=(%i,%i), ss=%i, bestss=%i, key=%s\n", 
					i, 
					dpos.x, 
					dpos.y, 
					centre.x - mouse_workarea.x, 
					centre.y - mouse_workarea.y,
					distancesquared, 
					besticon_distancesquared,
					  (direction==iconhigh_direction_UP)		? "UP"
					: (direction==iconhigh_direction_DOWN)		? "DOWN"
					: (direction==iconhigh_direction_LEFT)		? "LEFT"
					: (direction==iconhigh_direction_RIGHT)		? "RIGHT"
					: (direction==iconhigh_direction_NEAREST)	? "NEAREST"
					: "-"
					);
				
				if ( distancesquared <= besticon_distancesquared)	{
					if	(
						   ( centre.y > mouse_workarea.y && direction==iconhigh_direction_UP	)
						|| ( centre.y < mouse_workarea.y && direction==iconhigh_direction_DOWN	)
						|| ( centre.x > mouse_workarea.x && direction==iconhigh_direction_RIGHT	)
						|| ( centre.x < mouse_workarea.x && direction==iconhigh_direction_LEFT	)
						|| direction==iconhigh_direction_NEAREST
						)
						{
						int	rawdistance = 
							(centre.x-mouse_workarea.x)*(centre.x-mouse_workarea.x)
							+ 
							(centre.y-mouse_workarea.y)*(centre.y-mouse_workarea.y);
						
						/*
						It's likey that our distance measure will be identical to others, as any overlap
						in x or y direction is reduced to 0 distance in the direction.
						Eg:
						   **** ****
						   **** ****
						   **** ****
						   
						     ****
						     ****
						     ****
						
						- The top two icons will be the same distance from the bottom one.
						 */
						
						Desk_Debug_Printf( Desk_error_PLACE 
							"Icon %i, dpos=(%i,%i), rawdistance=%i, ss=%i, bestss=%i, bestrawdistance=%i key=%s\n", 
							i, 
							dpos.x, 
							dpos.y, 
							rawdistance,
							distancesquared, 
							besticon_distancesquared,
							besticon_rawdistance,
							  (direction==iconhigh_direction_UP)		? "UP"
							: (direction==iconhigh_direction_DOWN)		? "DOWN"
							: (direction==iconhigh_direction_LEFT)		? "LEFT"
							: (direction==iconhigh_direction_RIGHT)		? "RIGHT"
							: (direction==iconhigh_direction_NEAREST)	? "NEAREST"
							: "-"
							);
						
						
						if ( distancesquared<besticon_distancesquared || rawdistance<besticon_rawdistance)
							{
							Desk_Debug_Printf( Desk_error_PLACE "Icon %i is best so far...\n", i);
							besticon_number			= i;
							besticon_distancesquared	= distancesquared;
							besticon_centre			= centre;
							besticon_rawdistance		= rawdistance;
							}
						}
					}
				}
			}
		
		if ( besticon_number != -1)	{
			// We have a winner!
			Desk_icon_block*	icon		= &icons[ besticon_number];
			
			if ( direction==iconhigh_direction_NONE)	{
				Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and best icon=%i. Calling SetHighlight()\n", besticon_number);
				SetHighlight( mouse.window, besticon_number, icon, pw);
				}
			else	{
				Desk_wimp_rect		screenrect_wa	= info->block.screenrect;
				
				Desk_Debug_Printf( Desk_error_PLACE "Moving to icon %i\n", besticon_number);
				// If necessary, scroll window so that besticon is visible.
				newpos->x = besticon_centre.x - info->block.scroll.x + info->block.screenrect.min.x;
				newpos->y = besticon_centre.y - info->block.scroll.y + info->block.screenrect.max.y;
				Desk_Coord_RectToWorkArea( &screenrect_wa, (Desk_convert_block*) &info->block.screenrect);
				
				SetHighlight( mouse.window, besticon_number, icon, pw);
				
				if ( !Desk_Coord_RectContained( &icon->workarearect, &screenrect_wa))	{
					// Scroll window so that the new icon is visible.
					// We can't Wimp_OpenWindow the window ourselves (we don't own it), so
					// we send it a Wimp_OpenWindow event using Wimp_SendMessage, via
					// TaskModule.
					Desk_wimp_point	dscroll = { 0, 0};
					MakeGE( dscroll.x, icon->workarearect.max.x - screenrect_wa.max.x);
					MakeLE( dscroll.x, icon->workarearect.min.x - screenrect_wa.min.x);
					MakeLE( dscroll.y, icon->workarearect.min.y - screenrect_wa.min.y);
					MakeGE( dscroll.y, icon->workarearect.max.y - screenrect_wa.max.y);
					newpos->x -= dscroll.x;
					newpos->y -= dscroll.y;
					info->block.scroll.x += dscroll.x;
					info->block.scroll.y += dscroll.y;
					Desk_Debug_Printf( Desk_error_PLACE "Calling TaskModule_SendMessage, dscroll=(%i,%i)\n", dscroll.x, dscroll.y);
					Desk_Error2_CheckOS( 
						_swix( TaskModule_SendMessage, _INR(0,6), 
							1, 
							(Desk_window_openblock*) &info->window, 
								// First few fields in Desk_window_info are a Desk_window_openblock.
							info->window, 
							0, 
							0,
							0,
							Desk_event_OPEN
							)
						);
						
					}
				}
			}
		else	{	// No icon to move to.
			if (direction==iconhigh_direction_UP)		newpos->y = info->block.screenrect.max.y + 8;
			if (direction==iconhigh_direction_DOWN)		newpos->y = info->block.screenrect.min.y - 8;
			if (direction==iconhigh_direction_RIGHT)	newpos->x = info->block.screenrect.max.x + 8;
			if (direction==iconhigh_direction_LEFT)		newpos->x = info->block.screenrect.min.x - 8;
			if (direction==iconhigh_direction_NONE)		SetHighlight( NULL, 0, NULL, pw);	// Turn off the highlight.
			}
		
		info_volatile = NULL;
		GetInfoFree( info);
		}
	Desk_Error2_Catch	{
		GetInfoFree( info_volatile);
		}
	Desk_Error2_EndCatch
	
	Desk_UNUSED( pw);
	}


