#include <limits.h>
#include <stdlib.h>

#include "swis.h"

#include "Desk.Error2.h"
#include "Desk.WimpSWIs.h"
#include "Desk.Window.h"
#include "Desk.DeskMem.h"

#include "TaskModule.TaskModule.h"

#include "^.Highlight.h"
#include "^.Globals.h"

#include "WindInfo2.h"
#include "DrawHL.h"





#define	BEST_POINT( x, min, max)	Desk_MIN( Desk_MAX( x, min), max)

#define	MAJOR	3
#define	MINOR	1
#define	DISTANCE_SQUARED( major, minor)	( (major)*(major)/MAJOR/MAJOR + (minor)*(minor)/MINOR/MINOR)

#define	MakeGE( a, b)	if ((b)>(a))	(a)=(b)
#define	MakeLE( a, b)	if ((b)<(a))	(a)=(b)


void	MoveHighlight( Desk_wimp_point* newpos, iconhigh_direction direction, void* pw)
/*
cursor keypress should be in 'lastcursorkey'. We look for nearest icon
in the specified direction.
 */
	{
	Desk_window_info* volatile	info_volatile		= NULL;
	
	Desk_Debug_Printf( Desk_error_PLACE "MoveHighlight called for direction %i\n", (int) direction);
	
	Desk_Error2_Try	{
		Desk_window_info*		info;
		Desk_mouse_block		mouse;
		Desk_icon_block*		icons;
		int				besticon_number			= -1;
		int				besticon_distancesquared	= INT_MAX;
		Desk_wimp_point			besticon_centre = { 0, 0};
		int				i;
		Desk_wimp_point			mouse_workarea;
		
		Desk_Wimp_GetPointerInfo( &mouse);
		*newpos = mouse.pos;
		
		// Get all icons for current window...
		// First, how many icons:
		info = GetInfoAlloc( mouse.window);
		info_volatile = (Desk_window_info* volatile) info;
		
		mouse_workarea.x = mouse.pos.x + info->block.scroll.x - info->block.screenrect.min.x;
		mouse_workarea.y = mouse.pos.y + info->block.scroll.y - info->block.screenrect.max.y;
		
		Desk_Debug_Printf( Desk_error_PLACE "Window 0x%p has %i icons\n", (void*) mouse.window, info->block.numicons);
		
		// Step through each icon; if it is in specified direction, check whether it is closest so far.
		
		for ( i=0, icons=(Desk_icon_block*)(info+1); i<info->block.numicons; i++)	{
			Desk_icon_block*	icon = &icons[i];
			Desk_wimp_point		centre;
			Desk_wimp_point		dpos;
			unsigned int		distancesquared;
			Desk_wimp_point		bestpoint;
			
			if ( direction!=iconhigh_direction_NONE && i==mouse.icon)	continue;	// Ignore current icon if we are looking for closest
			if ( icon->flags.data.buttontype == Desk_iconbtype_NEVER)	continue;
				// Ignore non-clickable icons
			
			if ( !Desk_Coord_RectsOverlap( &info->block.workarearect, &icon->workarearect))	continue;
				// Icon is hidden outside accesible workarea of window.
			
			if ( direction==iconhigh_direction_NONE)	{
				if ( Desk_Coord_PointInRect( &mouse_workarea, &icon->workarearect))	{
					Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and pointer within icon %i\n", i);
					besticon_number			= i;
					}
				}
			
			else	{
				bestpoint.x = BEST_POINT( mouse_workarea.x, icon->workarearect.min.x, icon->workarearect.max.x);
				bestpoint.y = BEST_POINT( mouse_workarea.y, icon->workarearect.min.y, icon->workarearect.max.y);
				
				centre.x = (icon->workarearect.max.x + icon->workarearect.min.x) / 2;
				centre.y = (icon->workarearect.max.y + icon->workarearect.min.y) / 2;
				
				dpos.x = abs( bestpoint.x - mouse_workarea.x);
				dpos.y = abs( bestpoint.y - mouse_workarea.y);
				
				if ( direction==iconhigh_direction_UP || direction==iconhigh_direction_DOWN)
					distancesquared = DISTANCE_SQUARED( dpos.y, dpos.x);
				else	distancesquared = DISTANCE_SQUARED( dpos.x, dpos.y);
				
				//distancesquared = dpos.x * dpos.x + dpos.y * dpos.y;
				
				Desk_Debug3_Printf( Desk_error_PLACE "Icon %i, dpos=(%i,%i), dpos2=(%i,%i), ss=%i, bestss=%i, key=%s\n", 
					i, 
					dpos.x, 
					dpos.y, 
					centre.x - mouse_workarea.x, 
					centre.y - mouse_workarea.y,
					distancesquared, 
					besticon_distancesquared,
					  (direction==iconhigh_direction_UP)	? "UP"
					: (direction==iconhigh_direction_DOWN)	? "DOWN"
					: (direction==iconhigh_direction_LEFT)	? "LEFT"
					: (direction==iconhigh_direction_RIGHT)	? "RIGHT"
					: "-"
					);
				
				if	(
					( direction==iconhigh_direction_UP	&& centre.y > mouse_workarea.y && distancesquared < besticon_distancesquared)
					||
					( direction==iconhigh_direction_DOWN	&& centre.y < mouse_workarea.y && distancesquared < besticon_distancesquared)
					||
					( direction==iconhigh_direction_LEFT	&& centre.x < mouse_workarea.x && distancesquared < besticon_distancesquared)
					||
					( direction==iconhigh_direction_RIGHT	&& centre.x > mouse_workarea.x && distancesquared < besticon_distancesquared)
					)
					{
					besticon_number			= i;
					besticon_distancesquared	= distancesquared;
					besticon_centre			= centre;
					}
				}
			}
		
		if ( besticon_number != -1)	{
			// We have a winner!
			Desk_icon_block*	icon		= &icons[ besticon_number];
			
			if ( direction==iconhigh_direction_NONE)	{
				Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and best icon=%i. Calling SetHighlight()\n", besticon_number);
				SetHighlight( mouse.window, besticon_number, icon, pw);
				}
			else	{
				Desk_wimp_rect		screenrect_wa	= info->block.screenrect;
				
				Desk_Debug_Printf( Desk_error_PLACE "Moving to icon %i\n", besticon_number);
				// If necessary, scroll window so that besticon is visible.
				newpos->x = besticon_centre.x - info->block.scroll.x + info->block.screenrect.min.x;
				newpos->y = besticon_centre.y - info->block.scroll.y + info->block.screenrect.max.y;
				Desk_Coord_RectToWorkArea( &screenrect_wa, (Desk_convert_block*) &info->block.screenrect);
				
				SetHighlight( mouse.window, besticon_number, icon, pw);
				
				if ( !Desk_Coord_RectContained( &icon->workarearect, &screenrect_wa))	{
					// Scroll window so that the new icon is visible.
					// We can't Wimp_OpenWindow the window ourselves (we don't own it), so
					// we send it a Wimp_OpenWindow event using Wimp_SendMessage, via
					// TaskModule.
					Desk_wimp_point	dscroll = { 0, 0};
					MakeGE( dscroll.x, icon->workarearect.max.x - screenrect_wa.max.x);
					MakeLE( dscroll.x, icon->workarearect.min.x - screenrect_wa.min.x);
					MakeLE( dscroll.y, icon->workarearect.min.y - screenrect_wa.min.y);
					MakeGE( dscroll.y, icon->workarearect.max.y - screenrect_wa.max.y);
					newpos->x -= dscroll.x;
					newpos->y -= dscroll.y;
					info->block.scroll.x += dscroll.x;
					info->block.scroll.y += dscroll.y;
					Desk_Debug_Printf( Desk_error_PLACE "Calling TaskModule_SendMessage, dscroll=(%i,%i)\n", dscroll.x, dscroll.y);
					Desk_Error2_CheckOS( 
						_swix( TaskModule_SendMessage, _INR(0,6), 
							1, 
							(Desk_window_openblock*) &info->window, 
								// First few fields in Desk_window_info are a Desk_window_openblock.
							info->window, 
							0, 
							0,
							0,
							Desk_event_OPEN
							)
						);
						
					}
				}
			}
		else	{	// No icon to move to.
			if (direction==iconhigh_direction_UP)		newpos->y = info->block.screenrect.max.y + 8;
			if (direction==iconhigh_direction_DOWN)		newpos->y = info->block.screenrect.min.y - 8;
			if (direction==iconhigh_direction_RIGHT)	newpos->x = info->block.screenrect.max.x + 8;
			if (direction==iconhigh_direction_LEFT)		newpos->x = info->block.screenrect.min.x - 8;
			if (direction==iconhigh_direction_NONE)		SetHighlight( NULL, 0, NULL, pw);	// Turn off the highlight.
			}
		
		info_volatile = NULL;
		GetInfoFree( info);
		}
	Desk_Error2_Catch	{
		GetInfoFree( info_volatile);
		}
	Desk_Error2_EndCatch
	
	Desk_UNUSED( pw);
	}


