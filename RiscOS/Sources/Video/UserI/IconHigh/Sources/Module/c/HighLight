#include <limits.h>
#include <stdlib.h>

#include "swis.h"

#include "Desk.Error2.h"
#include "Desk.WimpSWIs.h"
#include "Desk.Window.h"
#include "Desk.DeskMem.h"
#include "Desk.Icon.h"

#include "tboxlibs.window.h"

#define	TaskModule_SendMessage		0x4d300
#define	TaskModule_AddCallBack		0x4d307
#define	TaskModule_RemoveCallBack	0x4d308


#include "^.Highlight.h"
#include "^.Globals.h"
#include "^.GetSetPtr.h"

#include "DrawHL.h"

#include "WindInfo2.h"
#include "DrawHL.h"
#include "CMHGHead.h"
#include "Emulation.h"

#define	Toolbox_MiscOp 0x44ec6



#define	MAJOR	3
#define	MINOR	1
#define	DISTANCE_SQUARED( major, minor)	( (major)*(major)*MINOR*MINOR + (minor)*(minor)*MAJOR*MAJOR)
#define	DISTANCE_SQUARED0( x, y)	( (x)*(x) + (y)*(y))

#define	MakeGE( a, b)	if ((b)>(a))	(a)=(b)
#define	MakeLE( a, b)	if ((b)<(a))	(a)=(b)





//#ifndef iconhigh_DAYTONA

	static int	Distance( const Desk_wimp_rect* pos, const Desk_wimp_rect* newpos, iconhigh_direction direction)
		{
		if ( direction==iconhigh_direction_NEAREST)	{
			return DISTANCE_SQUARED0(
				( ( pos->min.x+pos->max.x) - ( newpos->min.x+newpos->max.x)) / 2,
				( ( pos->min.y+pos->max.y) - ( newpos->min.y+newpos->max.y)) / 2
				);
			}

		else if ( direction==iconhigh_direction_NONE)	return INT_MAX;

		else	{
			Desk_wimp_rect	from;
			Desk_wimp_rect	to;

			// Transform so that we are always moving up.

			if ( direction==iconhigh_direction_UP)
				{
				from	= *pos;
				to	= *newpos;
				}
			if ( direction==iconhigh_direction_DOWN)
				{
				from.min.x	= pos->min.x;
				from.max.x	= pos->max.x;
				from.min.y	= -pos->max.y;
				from.max.y	= -pos->min.y;
				to.min.x	= newpos->min.x;
				to.max.x	= newpos->max.x;
				to.min.y	= -newpos->max.y;
				to.max.y	= -newpos->min.y;
				}
			if ( direction==iconhigh_direction_RIGHT)
				{
				from.min.x	= pos->min.y;
				from.max.x	= pos->max.y;
				from.min.y	= pos->min.x;
				from.max.y	= pos->max.x;
				to.min.x	= newpos->min.y;
				to.max.x	= newpos->max.y;
				to.min.y	= newpos->min.x;
				to.max.y	= newpos->max.x;
				}
			if ( direction==iconhigh_direction_LEFT)
				{
				from.min.x	= pos->min.y;
				from.max.x	= pos->max.y;
				from.min.y	= -pos->max.x;
				from.max.y	= -pos->min.x;
				to.min.x	= newpos->min.y;
				to.max.x	= newpos->max.y;
				to.min.y	= -newpos->max.x;
				to.max.y	= -newpos->min.x;
				}

			// Now calculate distance when moving up from 'from' to 'to'.
				{
				Desk_wimp_point	from_point;
				int		to_linex_min;
				int		to_linex_max;
				Desk_wimp_point	to_point;

				from_point.x	= (from.min.x + from.max.x) / 2;
				from_point.y	= from.max.y;
				to_linex_min	= to.min.x;
				to_linex_max	= to.max.x;

				to_point.y	= to.min.y;
				if ( to_point.y < from_point.y)	to_point.y = (to.min.y+to.max.y) / 2;
					// In case of overlap.

				if ( from_point.x > to_linex_max)	to_point.x = to_linex_max;
				else if ( from_point.x < to_linex_min)	to_point.x = to_linex_min;
				else	to_point.x = from_point.x;

				if ( to_point.y < from_point.y)	return INT_MAX;
				return DISTANCE_SQUARED( to_point.y-from_point.y, to_point.x-from_point.x);
				}
			}
		return INT_MAX;
		}

//#endif	// ifndef iconhigh_DAYTONA


/*
We ignore non-clickable icons, shaded icons and deleted icons.
 */




#ifdef iconhigh_DAYTONA

typedef struct
{
	int			numicons;
	Desk_icon_handle*	handles;
}
component_iconhandles;







#define  Window_GadgetGetIconList (0x082880+11)

static _kernel_oserror *gadget_get_icon_list_anytask ( unsigned int flags,
                                               Desk_window_handle window,
                                               ComponentId gadget,
                                               int *buffer,
                                               int buff_size,
                                               int *nbytes
                                             )
{
	return _swix( Window_GadgetGetIconList, _INR(0,4)|_OUT(4),
			flags, window, gadget, buffer, buff_size,
			nbytes
			);
}


static void	GetIconsForComponent( component_iconhandles* iconhandles, Desk_window_handle window, ComponentId component)
{
	int	numbytes;
	/*
	// TESTING - handled fine.
	iconhandles->handles	= NULL;
	iconhandles->numicons	= 0;
	return;
	*/
	Desk_Debug5_Printf( Desk_error_PLACE "Calling gadget_get_icon_list_anytask\n");
	Desk_Error2_CheckOS( gadget_get_icon_list_anytask( 0, window, component, NULL, 0, &numbytes));
	Desk_Debug5_Printf( Desk_error_PLACE "numbytes=%i\n", numbytes);
	if ( numbytes<=0)
	{
		iconhandles->numicons	= 0;
		iconhandles->handles	= NULL;
		return;
	}
	iconhandles->handles = (Desk_icon_handle*) Desk_DeskMem_Malloc( numbytes);
	Desk_Error2_CheckOS( gadget_get_icon_list_anytask( 0, window, component, (int*) iconhandles->handles, numbytes, &numbytes));
	iconhandles->numicons= numbytes/sizeof( Desk_icon_handle);
	Desk_Debug5_Printf( Desk_error_PLACE "GetIconsForComponent: component=0x%08x, numicons=%i\n", component, iconhandles->numicons);
	#ifdef Desk_DEBUG
	{
		int	i;
		for ( i=0; i<iconhandles->numicons; i++)
		{
			char	buffer[ 256] = "";
			Desk_Icon_GetText( window, iconhandles->handles[i], buffer);
			Desk_Debug5_Printf( Desk_error_PLACE "icon %i is '%s'\n", iconhandles->handles[i], buffer);
		}
	}
	#endif
}


typedef struct
{
	int		numcomponents;
	ComponentId*	ids;
}
object_components;


#define  Window_EnumerateGadgets (0x082880+10)


static int	ComponentCmp( const void* a, const void* b)
{
	return *(ComponentId*) a - *(ComponentId*) b;
}


#ifdef Desk_DEBUG
	static void	Desk_Debug_Flush( void)
	{
		int	i;
		for ( i=0; i<40; i++)	Desk_Debug_Printf( "                                ");
		Desk_Debug_Printf( "\n");
	}

#else
	#define	Desk_Debug_Flush()
#endif




static void	GetComponents( object_components* components, Desk_window_handle window)
{
	int	pos=-1;
	int	buffsize;

	Desk_Debug5_Printf( Desk_error_PLACE "GetComponents for window 0x%08x\n", window);
	//Desk_Debug5_Flush();

	Desk_Error2_CheckOS(
		_swix( Window_EnumerateGadgets, _INR(0,3)|_OUT(4),
			0, window, pos, 0,
			&buffsize
			)
		);
	Desk_Debug5_Printf( Desk_error_PLACE "Required buffsize is %i\n", buffsize);
	//Desk_Debug_Flush();

	components->ids = (ComponentId*) Desk_DeskMem_Malloc( buffsize);

	Desk_Error2_CheckOS(
		_swix( Window_EnumerateGadgets, _INR(0,4)|_OUT(4),
			0, window, pos, components->ids, buffsize,
			&buffsize
			)
		);

	components->numcomponents = buffsize / sizeof( ComponentId);

	Desk_Debug5_Printf( Desk_error_PLACE "Sorting components\n");
	//Desk_Debug_Flush();

	qsort( components->ids, components->numcomponents, sizeof( ComponentId), ComponentCmp);

	#ifdef Desk_DEBUG
		{
		int	i;
		for ( i=0; i<components->numcomponents; i++)	Desk_Debug5_Printf( Desk_error_PLACE "Component %i is 0x%08x\n", i, components->ids[i]);
		}
	#endif

	Desk_Debug5_Printf( Desk_error_PLACE "GetComponents returning\n");
	//Desk_Debug_Flush();
}



static Desk_icon_handle	GetNextIcon( ObjectId object, ComponentId component, Desk_window_info* info, Desk_icon_handle icon, int step)
{
	Desk_icon_block*	iconblocks = (Desk_icon_block*) (info+1);

	//return -1;	// TEST

	if ( step!=0)
	{	// Look at current gadget, to see if we merely have to move to a different icon in the gadget.
		component_iconhandles	iconhandles;
		int			i;
		GetIconsForComponent( &iconhandles, info->window, component);

		Desk_Debug5_Printf( Desk_error_PLACE "Looking at icons of current gadget (%i icons)\n", iconhandles.numicons);

		for ( i=0; i<iconhandles.numicons; i++)
		{
			if ( iconhandles.handles[i]==icon)
			{
				int	ii;
				for ( ii=i+step; ii>=0 && ii<iconhandles.numicons; ii+=step)
				{
					if ( !IconHigh_IgnoreIcon( &iconblocks[ iconhandles.handles[ii]]))
					{
						int	icon = iconhandles.handles[ii];
						Desk_DeskMem_Free( iconhandles.handles);
						Desk_Debug5_Printf( Desk_error_PLACE "Returning icon %i\n", icon);
						return icon;
					}
				}
			}
		Desk_DeskMem_Free( iconhandles.handles);
		}
	}

	// If we reach here, we need to move to the next component, and select the first/last icon.
	Desk_Debug5_Printf( Desk_error_PLACE "Looking for next component\n");

	{
		object_components	components;
		int			c;

		GetComponents( &components, info->window);

		if ( 0==step)
		{
			c=-1;
			step = 1;
		}
		else
		{
			for ( c=0; c<components.numcomponents; c++)
			{
				if ( component==components.ids[ c])	break;
			}
		}

		Desk_Debug5_Printf( Desk_error_PLACE "Starting at component %i\n", c+step);

		if ( c<components.numcomponents)
		{	// Search for next clickable icon.
			for ( c+=step; c>=0 && c<components.numcomponents; c+=step)
			{
				int	i;
				component_iconhandles	iconhandles;
				GetIconsForComponent( &iconhandles, info->window, components.ids[c]);

				Desk_Debug5_Printf( Desk_error_PLACE "Component %i (0x%08x) has %i icons\n", c, components.ids[c], iconhandles.numicons);
				i = (step>0) ? 0 : iconhandles.numicons-1;
				for ( ; i>=0 && i<iconhandles.numicons; i+=step)
				{
					if ( !IconHigh_IgnoreIcon( &iconblocks[ iconhandles.handles[i]]))
					{
						int	handle = iconhandles.handles[i];
						Desk_Debug_Printf( Desk_error_PLACE "Selecting icon number %i\n", handle);
						Desk_DeskMem_Free( iconhandles.handles);
						Desk_DeskMem_Free( components.ids);
						return handle;
					}
					else Desk_Debug_Printf( Desk_error_PLACE "Ignoring icon number %i\n", iconhandles.handles[i]);
				}
			Desk_DeskMem_Free( iconhandles.handles);
			Desk_Debug_Printf( Desk_error_PLACE "Component doesn't contain suitable icon\n");
			}
		}
		Desk_DeskMem_Free( components.ids);
	}
	Desk_Debug_Printf( Desk_error_PLACE "No icon to move to\n");
	return -1;

	Desk_UNUSED( object);
}


#endif



#ifdef iconhigh_DAYTONA

static Desk_task_handle	GetTaskHandle( Desk_window_handle window)
{
	Desk_message_header	message;
	Desk_task_handle	task;
	message.size	= sizeof( message);
	message.yourref	= 0;
	Desk_Error2_CheckOS( _swix( Wimp_SendMessage, _INR(0,2)|_OUT(2), Desk_event_ACK, &message, window, &task));
	return task;
}



static void	SetCaretToEnd( Desk_window_handle window, Desk_icon_handle icon)
/*
As Desk_Icon_SetCaret, except uses Wimp_TransferBlock for indirected
icon. Also makes caret invisible if icon handle is -1, rather than
removing the caret completely.
 */
{
	Desk_caret_block	caret;
	Desk_icon_block		istate;
	char*			buff;
	int			maxlen;

	caret.window	= window;
	caret.icon	= icon;
	caret.offset.y	= 0;
	caret.offset.x	= 0;

	if ( icon==-1)
	{
		caret.height = 1<<25;	// invisible.
	}

	else
	{
		caret.height	= -1;

		Desk_Wimp_GetIconState( window, icon, &istate);

		if ( !istate.flags.data.text || istate.flags.data.shaded)	return;          /* Not a text icon, or is shaded, so can't grab caret */

		if ( istate.flags.data.indirected)
		{
			Desk_task_handle	task = GetTaskHandle( window);
			maxlen = istate.data.indirecttext.bufflen;
			buff   = Desk_DeskMem_Malloc( maxlen);
			Desk_Wimp_TransferBlock( task, istate.data.indirecttext.buffer, task, buff, maxlen);
		}
		else
		{
			maxlen	= 12;
			buff	= istate.data.text;
		}

		for ( caret.index=0; caret.index<maxlen && buff[caret.index]>31; caret.index++)	;

		if ( istate.flags.data.indirected)	Desk_DeskMem_Free( buff);
	}

	Desk_Wimp_SetCaretPosition( &caret);
}

static struct
{
	Desk_bool		callbackset;
	Desk_window_handle	window;
	Desk_icon_handle	icon;
}
global_caret = { Desk_bool_FALSE};

static struct
{
	Desk_bool		callbackset;
	IconHigh_emulationtype	emulation;
	iconhigh_direction	direction;
	int			window;
	int			icon;
}
global_movehigh = { Desk_bool_FALSE};



_kernel_oserror*	SetCaret_handler( _kernel_swi_regs* r, void* pw)
{
	Desk_Error2_TryCatch(
		Desk_Debug_Printf( Desk_error_PLACE "SetCaret called, window=0x%x, icon=%i\n", (int) global_caret.window, (int) global_caret.icon);
		global_caret.callbackset	= Desk_bool_FALSE;
		_swix( Wimp_SetCaretPosition, _IN(0), -1);	// Turn caret off by default.
		SetCaretToEnd( global_caret.window, global_caret.icon);
		,
		)

	return NULL;
	Desk_UNUSED( r);
	Desk_UNUSED( pw);
}



static void	SetCaret2( Desk_window_handle window, Desk_icon_handle icon, void* pw)
{
	global_caret.window	= window;
	global_caret.icon	= icon;
	if ( !global_caret.callbackset)
	{
		Desk_Debug_Printf( Desk_error_PLACE "SetCaret2 called, window=0x%x, icon=%i\n", (int) window, (int) icon);
		_swix( 0x04d307 /*TaskModule_AddCallBack*/, _INR(0,2), 0, SetCaret, pw);
		global_caret.callbackset	= Desk_bool_TRUE;
	}
}


/*static*/ void	MoveHigh3( IconHigh_emulationtype emulation, iconhigh_direction direction,
                           int window, int icon, void* pw)
{
   	global_movehigh.emulation = emulation;
	global_movehigh.direction = direction;
	global_movehigh.window = window;
	global_movehigh.icon = icon;

	if ( !global_movehigh.callbackset)
	{
		Desk_Debug_Printf( Desk_error_PLACE "MoveHigh3 called, emulation=%i, direction=%i\n"
		                 , (int) emulation.type, (int) direction);
		_swix( 0x04d307 /*TaskModule_AddCallBack*/, _INR(0,2), 1, MoveHigh, pw);
		global_movehigh.callbackset	= Desk_bool_TRUE;
	}
}


_kernel_oserror*	MoveHigh_handler( _kernel_swi_regs* r, void* pw)
{
	Desk_Error2_TryCatch(
		Desk_Debug_Printf( Desk_error_PLACE "MoveHigh called, emulation=%i, direction=%i\n", (int) global_movehigh.emulation.type, (int) global_movehigh.direction);
		global_movehigh.callbackset	= Desk_bool_FALSE;
		if (global_movehigh.window != -1) {
			HighlightIconHandler ( global_movehigh.window, global_movehigh.icon, pw);
			MoveHigh3( global_movehigh.emulation, global_movehigh.direction, -1, -1, pw);
		} else {
			_EmulationPointerStart( global_movehigh.emulation, global_movehigh.direction, pw);
		}
		,
		)

	return NULL;
	Desk_UNUSED( r);
	Desk_UNUSED( pw);
}



/*static*/ void	MoveHigh2( IconHigh_emulationtype emulation, iconhigh_direction direction, void* pw)
{
	Desk_window_state	state;
	Desk_mouse_block	mouse;
	int x,y;
#define ONEPIXELINOSUNITS 4

   	global_movehigh.emulation = emulation;
	global_movehigh.direction = direction;
	global_movehigh.window = -1;
	Desk_Wimp_GetPointerInfo( &mouse);
	Desk_Wimp_GetWindowState( mouse.window, &state);

	switch (direction) {

	   case iconhigh_direction_UP:
	      x = (state.openblock.screenrect.min.x + state.openblock.screenrect.max.x ) / 2;
	      y = state.openblock.screenrect.max.y + ONEPIXELINOSUNITS;
	      break;

	   case iconhigh_direction_DOWN:
	      x = (state.openblock.screenrect.min.x + state.openblock.screenrect.max.x ) / 2;
	      y = state.openblock.screenrect.min.y - ONEPIXELINOSUNITS;
	      break;

	   default: /* Should really do other directions, but not needed for Daytona... */
	      x = (state.openblock.screenrect.min.x + state.openblock.screenrect.max.x ) / 2;
	      y = (state.openblock.screenrect.min.y + state.openblock.screenrect.max.y ) / 2;
	      break;

	}

	SetMousePos (x, y);

	if ( !global_movehigh.callbackset)
	{
		Desk_Debug_Printf( Desk_error_PLACE "MoveHigh2 called, winrect (%i,%i) (%i,%i), emulation=%i, direction=%i, setting mouse to (%i,%i)\n"
		                 , state.openblock.screenrect.min.x, state.openblock.screenrect.min.y
		                 , state.openblock.screenrect.max.x, state.openblock.screenrect.max.y
		                 , (int) emulation.type, (int) direction, x, y);
		_swix( 0x04d307 /*TaskModule_AddCallBack*/, _INR(0,2), 1, MoveHigh, pw);
		global_movehigh.callbackset	= Desk_bool_TRUE;
	}
}
#endif



/*

static	Desk_window_openblock	global_scroll_openblock;
static	Desk_bool		global_scroll_callbackset	= Desk_bool_FALSE;
static char*			global_scroll_filtername	= "IconHigh scroll";
static Desk_task_handle		global_scroll_task		= 0;

_kernel_oserror*	Scroll2_handler( _kernel_swi_regs* r, void* pw)
// Called when our openwindow event is delivered to a window
{
	Desk_event_type		type = (Desk_event_type)	r->r[0];
	Desk_event_data*	data = (Desk_event_data*)	r->r[1];
	Desk_task_handle	task = (Desk_task_handle)	r->r[2];

	Desk_Debug_Printf( Desk_error_PLACE "Scroll2_handler called\n");

	if ( type==Desk_event_OPEN && data->openblock.window == global_scroll_openblock.window)
	{
		global_scroll_callbackset	= Desk_bool_FALSE;
		#ifdef Desk_DEBUG
			Desk_Debug_Printf( Desk_error_PLACE "Scroll2_handler called\n");
			if ( data->openblock.scroll.x != global_scroll_openblock.scroll.x || data->openblock.scroll.y != global_scroll_openblock.scroll.y)
			{
				Desk_Debug_Printf( Desk_error_PLACE "Having to correct event_OPEN parameters:\n");
				Desk_Debug_Printf( Desk_error_PLACE "scroll offsets are (%i,%i), should be (%i,%i)\n",
					data->openblock.scroll.x,
					data->openblock.scroll.y,
					global_scroll_openblock.scroll.x,
					global_scroll_openblock.scroll.y
				);
			}
		#endif
		data->openblock = global_scroll_openblock;	// Ensure that the open is for our latest parameters.
		_swix( Filter_DeRegisterPostFilter, _INR(0,3), global_scroll_filtername, Scroll2, pw, task);
	}
	return NULL;
}

_kernel_oserror*	Scroll_handler( _kernel_swi_regs* r, void* pw)
// Called when taskmodule is next polled.
{
	Desk_Error2_Try
	{
		Desk_Debug_Printf( Desk_error_PLACE "Scroll_handler() called\n");
		global_scroll_callbackset = Desk_bool_FALSE;
		global_scroll_task = GetTaskHandle( global_scroll_openblock.window);
		Desk_Debug_Printf( Desk_error_PLACE "task handle = 0x%08x\n", global_scroll_task);
		_swix( Wimp_SendMessage, _INR(0,2), Desk_event_OPEN, &global_scroll_openblock, global_scroll_openblock.window);
		_swix( Filter_RegisterPostFilter, _INR(0,4), global_scroll_filtername, Scroll2, pw, global_scroll_task, ~(1<<Desk_event_OPEN));
	}
	Desk_Error2_Catch
	{
	}
	Desk_Error2_EndCatch
	return NULL;

	Desk_UNUSED( r);
	Desk_UNUSED( pw);
}
*/

/*
static void	ScrollWindow( Desk_window_openblock* openblock, void* pw)
// Ensures that a event_OPEN message is sent to the specified window, and that if
// we are called twice before the first message is delivered, the first message
// is modified to contain the second call's openblock.
{
	global_scroll_openblock = *openblock;
	if ( !global_scroll_callbackset)
	{
		global_scroll_callbackset = Desk_bool_TRUE;
		_swix( 0x04d307 TaskModule_AddCallBack , _INR(0,2), 0, Scroll, pw);
	}
}
*/


static Desk_bool	global_waitingforpoll = Desk_bool_FALSE;
//static Desk_wimp_point	global_mousepos = { -1, 0};

_kernel_oserror*	NextPoll_handler( _kernel_swi_regs* r, void* pw)
{
	global_waitingforpoll	= Desk_bool_FALSE;
	/*
	if ( global_mousepos.x != -1)
	{

		Desk_Error2_TryCatch(
			SetMousePos( global_mousepos.x, global_mousepos.y);
			global_mousepos.x = -1;
			,
			)
	}
	*/
	return NULL;
	Desk_UNUSED( r);
	Desk_UNUSED( pw);
}


static void	SetWaitingForPoll( void* pw)
{
	if ( global_waitingforpoll)
	{
		Desk_Debug_Printf( Desk_error_PLACE "SetWaitingForPoll called when already waiting...\n");
		return;
	}

	if ( NULL==_swix( TaskModule_AddCallBack, _INR(0,2), 1, NextPoll, pw))
		global_waitingforpoll	= Desk_bool_TRUE;
}

static void	ScrollWindow( Desk_window_openblock* openblock, Desk_wimp_point* mousepos, void* pw)
{
	_swix( TaskModule_SendMessage, _INR(0,6),
		1,
		openblock,
		openblock->window,
		0,
		0,
		0,
		Desk_event_OPEN
		);

	//global_mousepos = *mousepos;
	SetWaitingForPoll( pw);


	Desk_UNUSED( pw);
	Desk_UNUSED( mousepos);
}



void	CancelHighlightHandlers( void* pw)
{
	Desk_Debug3_Printf( Desk_error_PLACE "CancelHightlightHandlers called\n");
	#ifdef iconhigh_DAYTONA
		_swix( TaskModule_RemoveCallBack, _INR(0,2), 0, SetCaret, pw);
		global_caret.callbackset	= Desk_bool_FALSE;
		_swix( TaskModule_RemoveCallBack, _INR(0,2), 0, MoveHigh, pw);
		global_movehigh.callbackset	= Desk_bool_FALSE;
	#endif

	//_swix( 0x04d308 /*TaskModule_RemoveCallBack*/, _INR(0,2), 0, Scroll, pw);
	//_swix( Filter_DeRegisterPostFilter, _INR(0,3), global_scroll_filtername, Scroll2, pw, global_scroll_task);
	_swix( TaskModule_RemoveCallBack, _INR(0,2), 1, NextPoll, pw);
	//global_scroll_callbackset	= Desk_bool_FALSE;
	global_waitingforpoll		= Desk_bool_FALSE;
}

#ifdef MemCheck_MEMCHECK
	// The IconHigh_IgnoreIcon macro can causes a compiler resource shortage when compiling with
	// both -g and -zpc1
	static int	IgnoreIcon( Desk_icon_block* icon)
	{
		return IconHigh_IgnoreIcon( icon);
	}
	#undef 	IconHigh_IgnoreIcon
	#define	IconHigh_IgnoreIcon( icon)	IgnoreIcon( icon)
#endif

void	MoveHighlight( Desk_wimp_point* newpos, iconhigh_direction direction, void* pw)
{
   __MoveHighlight (newpos, -1, -1, direction, pw);
}

void	__MoveHighlight( Desk_wimp_point* newpos, int window, int besticon_number, iconhigh_direction direction, void* pw)
/*
cursor keypress should be in 'lastcursorkey'. We look for nearest icon
in the specified direction.

When direction=iconhigh_direction_NONE, we shouldn't move the mouse,
just highlight the icon under the current mouse (if any).

When direction=iconhigh_direction_NEAREST, we move to the nearest icon.

If besticon_number is -1 the best icon is calculated.
 */
	{
	Desk_window_info* volatile	info_volatile		= NULL;

	// TEST
	//return;

	Desk_Debug_Printf( Desk_error_PLACE "MoveHighlight called for direction %i\n", (int) direction);
	/*
	#ifdef iconhigh_DAYTONA
		if ( global_scroll_callbackset)
		{
			// In middle of sending a scroll request - don't move mouse.
			GetMousePos( newpos);
			Desk_Debug_Printf( Desk_error_PLACE "Ignoring move request - in middle of scroll\n");
			return;
		}
	#endif
	*/

	if ( global_waitingforpoll)	return;

	Desk_Error2_Try	{
		Desk_window_info*		info;
		Desk_mouse_block		mouse;
		Desk_icon_block*		icons;
//		int				besticon_number			= -1;
		int				besticon_distancesquared	= INT_MAX;
		Desk_wimp_rect			screenrect_wa;

		#ifdef iconhigh_DAYTONA
			//SetWaitingForPoll( pw);	// stops us being called until after the next wimp poll.
		#endif
//		#else
			int				i;
			Desk_wimp_point			mouse_workarea;
			Desk_wimp_rect			mouse_iconrect;
//		#endif

		Desk_Wimp_GetPointerInfo( &mouse);
		*newpos = mouse.pos;
		if (window != -1) {
			mouse.window = window;
			mouse.icon = besticon_number;
		}

		#ifdef iconhigh_DAYTONA
			if ( mouse.icon==-1 && direction != iconhigh_direction_UP && direction != iconhigh_direction_DOWN)
				direction = iconhigh_direction_NEAREST;
			// Hack to cope with when mouse is left not over an icon.
		#endif

		// Get all icons for current window... First, how many icons:
		info = GetInfoAlloc( mouse.window);
		info_volatile = (Desk_window_info* volatile) info;

		icons = (Desk_icon_block*) (info+1);
			// Don't really need icon info for daytona build, but the scroll offsets are used later
			// (should really use Wimp_GetWindowState in daytona build).

		screenrect_wa = info->block.screenrect;
		Desk_Coord_RectToWorkArea( &screenrect_wa, (Desk_convert_block*) &info->block.screenrect);

		if (besticon_number == -1)
		{
		#ifdef iconhigh_DAYTONA
		if (direction == iconhigh_direction_NEXT || direction == iconhigh_direction_PREV
		   || direction == iconhigh_direction_NEAREST)
		{
			ObjectId	object;
			ComponentId	component;

			Desk_Error2_CheckOS( window_wimp_to_toolbox( 0, mouse.window, mouse.icon, &object, &component));
			Desk_Debug_Printf( Desk_error_PLACE "object=%i, component=%i\n", (int) object, (int) component);

			if ( object!=0)
			{
				int	step = 0;
				if ( direction==iconhigh_direction_NEXT)	step = +1;
				else if ( direction==iconhigh_direction_PREV)	step = -1;
				besticon_number = GetNextIcon( object, component, info, mouse.icon, step);
			}

			else
			{	// Not a toolbox window, so move between icons instead, for testing purposes
				int	step = 0;
				Desk_Debug_Printf( Desk_error_PLACE "direction=%i\n", (int) direction);

				if ( direction==iconhigh_direction_NEAREST)
				{	// Move to the first icon
					step = +1;
					mouse.icon = -1;
				}
				else if ( direction==iconhigh_direction_NEXT)	step = +1;
				else if ( direction==iconhigh_direction_PREV)	step = -1;

				if ( step)
				{
					int	i = mouse.icon;
					for ( i=mouse.icon+step; i>=0 && i<info->block.numicons; i+=step)
					{
						Desk_Debug_Printf( Desk_error_PLACE "Looking at icon %i\n", i);
						if ( !IconHigh_IgnoreIcon( &icons[ i]))
						{
							besticon_number			= i;
							besticon_distancesquared	= 0;
							Desk_Debug_Printf( Desk_error_PLACE "Moving to icon %i\n", i);
							break;
						}
					}
				}
			}
		}
		else
		#endif
//		#else	// #ifdef iconhigh_DAYTONA
		{

			mouse_workarea.x = mouse.pos.x + info->block.scroll.x - info->block.screenrect.min.x;
			mouse_workarea.y = mouse.pos.y + info->block.scroll.y - info->block.screenrect.max.y;

			Desk_Debug_Printf( Desk_error_PLACE "Window 0x%p has %i icons. Mouse is at (%i, %i), over icon %i\n",
				(void*) mouse.window,
				info->block.numicons,
				mouse.pos.x,
				mouse.pos.y,
				mouse.icon
				);


			// Find the rectangle for the current icon, if any. If not over an icon, use zero-size rect at position of pointer.
			// This rectangle is used when calculating the nearest icon to move to.

			mouse_iconrect.min = mouse_workarea;
			mouse_iconrect.max = mouse_workarea;

			if ( mouse.icon>=0)	{
				Desk_icon_block*	mouseicon = &icons[ mouse.icon];
				if ( !IconHigh_IgnoreIcon( mouseicon))
					{
					mouse_iconrect = mouseicon->workarearect;
					}
				}

			for ( i=0; i<info->block.numicons; i++)	{
				Desk_icon_block*	icon = &icons[i];

				if ( 	   direction!=iconhigh_direction_NONE
					&& direction!=iconhigh_direction_NEAREST
					&& i==mouse.icon
					)
					continue;	// Ignore current icon if we are moving.

				if ( IconHigh_IgnoreIcon( icon))	continue;

				//if ( !Desk_Coord_RectsOverlap( &info->block.workarearect, &icon->workarearect))
				if ( !Desk_Coord_RectContained( &icon->workarearect, &info->block.workarearect))
					{
					Desk_Debug_Printf( Desk_error_PLACE "Icon %i is hidden outside accesible workarea of window\n", i);
					continue;
					}

				if	(
					IconHigh_globals.newemulation.data.no_autoscroll
					&&
					!Desk_Coord_RectContained( &icon->workarearect, &screenrect_wa)
					)
					{
					Desk_Debug_Printf( Desk_error_PLACE
						"Icon %i is not wholey inside visible window, and we aren't allowed to scroll\n", i
						);
					continue;
					}

				if ( direction==iconhigh_direction_NONE)	{
					if ( Desk_Coord_PointInRect( &mouse_workarea, &icon->workarearect))	{
						Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and pointer within icon %i\n", i);
						besticon_number			= i;
						}
					}

				else	{
					int	distancesquared = Distance( &mouse_iconrect, &icon->workarearect, direction);
					if ( distancesquared < besticon_distancesquared)	{
						besticon_number			= i;
						besticon_distancesquared	= distancesquared;
						}
					}
				}

			{	// Now compare to moving outside of window.
			int	distance = -1;
			if ( direction==iconhigh_direction_LEFT)	distance = mouse.pos.x - info->block.screenrect.min.x;
			if ( direction==iconhigh_direction_RIGHT)	distance = info->block.screenrect.max.x - mouse.pos.x;
			if ( direction==iconhigh_direction_DOWN)	distance = mouse.pos.y - info->block.screenrect.min.y;
			if ( direction==iconhigh_direction_UP)		distance = info->block.screenrect.max.y - mouse.pos.y;
			if ( distance!=-1 && distance*distance < besticon_distancesquared)
				besticon_number = -2;	// Cancel previous best icon - this will result in move out of window.
			}
	        }
//		#endif	// #ifdef iconhigh_DAYTONA #else
		}

		if ( besticon_number>=0)	{	// We have a winner!

			Desk_icon_block*	icon = &icons[ besticon_number];

			if ( direction==iconhigh_direction_NONE)	{
				Desk_Debug_Printf( Desk_error_PLACE "Direction=0, and best icon=%i. Calling SetHighlight()\n", besticon_number);
				SetHighlight( mouse.window, besticon_number, icon, pw);
				}
			else	{
				Desk_wimp_point		besticon_centre;

				besticon_centre.x = ( icon->workarearect.min.x + icon->workarearect.max.x) / 2;
				besticon_centre.y = ( icon->workarearect.min.y + icon->workarearect.max.y) / 2;

				Desk_Debug_Printf( Desk_error_PLACE "Moving to icon %i\n", besticon_number);
				// If necessary, scroll window so that besticon is visible.
				newpos->x = besticon_centre.x - info->block.scroll.x + info->block.screenrect.min.x;
				newpos->y = besticon_centre.y - info->block.scroll.y + info->block.screenrect.max.y;

				SetHighlight( mouse.window, besticon_number, icon, pw);

				#ifdef iconhigh_DAYTONA
					// Move input focus to the new icon.
					// Desk_Icon_SetCaret( mouse.window, besticon_number
					{
					/*
					Desk_caret_block caret;
					caret.window	= mouse.window;
					caret.icon	= besticon_number;
					caret.height	= -1;
					caret.offset.x	= 0;
					caret.offset.y	= 0;
					caret.index	= 0;
					*/
					if (	   icon->flags.data.buttontype==Desk_iconbtype_WRITECLICKDRAG
						|| icon->flags.data.buttontype==Desk_iconbtype_WRITABLE
						)
					{
					SetCaret2( mouse.window, besticon_number, pw);
					/*
					global_caret.window	= mouse.window;
					global_caret.icon	= besticon_number;
					*/
					}
					else
					{
					SetCaret2( mouse.window, -1, pw);
					/*
					global_caret.window	= mouse.window;
					global_caret.icon	= -1;
					*/
					}

					/*
						Desk_Icon_SetCaret( mouse.window, besticon_number);	// Places caret at end of text
					else	Desk_Icon_SetCaret( -1, -1);	// Lose caret.
					*/
					//_swix( 0x04d307 /*TaskModule_AddCallBack*/, _INR(0,2), 0, SetCaret, pw);
					}
				#endif

				if ( !Desk_Coord_RectContained( &icon->workarearect, &screenrect_wa) && !IconHigh_globals.newemulation.data.no_autoscroll)
					{
					// Scroll window so that the new icon is visible.
					// We can't Wimp_OpenWindow the window ourselves (we don't own it), so
					// we send it a Wimp_OpenWindow event using Wimp_SendMessage, via
					// TaskModule.
					Desk_wimp_point	dscroll = { 0, 0};
					Desk_wimp_point	highlightsize;
					GetHighlightWidth( &highlightsize);

					MakeGE( dscroll.x, icon->workarearect.max.x + highlightsize.x - screenrect_wa.max.x);
					MakeLE( dscroll.x, icon->workarearect.min.x - highlightsize.x - screenrect_wa.min.x);
					MakeLE( dscroll.y, icon->workarearect.min.y - highlightsize.y - screenrect_wa.min.y);
					MakeGE( dscroll.y, icon->workarearect.max.y + highlightsize.y - screenrect_wa.max.y);
					newpos->x -= dscroll.x;
					newpos->y -= dscroll.y;
					info->block.scroll.x += dscroll.x;
					info->block.scroll.y += dscroll.y;

					// We don't get taskmodule to send event_OPEN, because the order of arrival of
					// messages is undefined. If our last event_OPEN doesn't arrive last, the window
					// will end up scrolled to the wrong place. Hence ScrollWindow has a global var
					// that stores the last scroll position requested, and does the sendmessage itself
					// using TaskModule_AddCallBack.

					ScrollWindow( (Desk_window_openblock*) &info->window, newpos, pw);

					/*
					Desk_Debug_Printf( Desk_error_PLACE "Calling TaskModule_SendMessage, dscroll=(%i,%i)\n", dscroll.x, dscroll.y);
					Desk_Error2_CheckOS(
						_swix( TaskModule_SendMessage, _INR(0,6),
							1,
							(Desk_window_openblock*) &info->window,
								// First few fields in Desk_window_info are a Desk_window_openblock.
							info->window,
							0,
							0,
							0,
							Desk_event_OPEN
							)
						);
					*/
					}
				}
			}
		else if ( besticon_number==-1 && direction==iconhigh_direction_NEAREST)	// Nowhere to move.
		{
			#ifdef iconhigh_DAYTONA
//				Desk_Debug_Printf( Desk_error_PLACE "SetCaret2 ( mouse.window, -1, pw) called\n");
//				SetCaret2( mouse.window, -1, pw);
				int mouse_click_block[5];
				mouse_click_block[0] = info->block.screenrect.min.x;
				mouse_click_block[1] = info->block.screenrect.max.y;
				mouse_click_block[2] = 4; // Select pressed //
				mouse_click_block[3] = mouse.window;
				mouse_click_block[4] = -1; // Work area background //
				Desk_Debug_Printf( Desk_error_PLACE "Calling TaskModule_SendMessage, clickpos=(%i,%i)\n"
							, mouse_click_block[0], mouse_click_block[1]);
				Desk_Error2_CheckOS(
					_swix( TaskModule_SendMessage, _INR(0,3)|_IN(6),
						1,
						&mouse_click_block,
						info->window,
						0,
						Desk_event_CLICK
						)
					);
				EmulationPointerStop( pw);
			#endif
		}
		else if ( besticon_number==-1 && direction==iconhigh_direction_NONE)
		{
			SetHighlight( NULL, 0, NULL, pw);	// Turn off highlight.
		}
		else if ( besticon_number==-2)	{	// Move out of window.
			Desk_Debug_Printf( Desk_error_PLACE "No icon to move to...\n");
			if (direction==iconhigh_direction_UP)		newpos->y = info->block.screenrect.max.y + 8;
			if (direction==iconhigh_direction_DOWN)		newpos->y = info->block.screenrect.min.y - 8;
			if (direction==iconhigh_direction_RIGHT)	newpos->x = info->block.screenrect.max.x + 8;
			if (direction==iconhigh_direction_LEFT)		newpos->x = info->block.screenrect.min.x - 8;
			if (direction==iconhigh_direction_NONE)		SetHighlight( NULL, 0, NULL, pw);	// Turn off the highlight.
			}

		GetInfoFree( info);
		info_volatile = NULL;

		}
	Desk_Error2_Catch	{
		GetInfoFree( info_volatile);
		}
	Desk_Error2_EndCatch

	Desk_UNUSED( pw);
	}


