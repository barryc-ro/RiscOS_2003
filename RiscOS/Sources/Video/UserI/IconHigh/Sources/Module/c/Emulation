#include "swis.h"

#include "Desk.Error2.h"
#include "Desk.WimpSWIs.h"
#include "Desk.Coord.h"

#include "^.Desk.Filter2.h"
#include "^.Desk.Window2.h"

#include "MemCheck:MemCheck.h"

#include "^.Emulation.h"
#include "^.GetSetPtr.h"
#include "^.Highlight.h"
#include "^.Globals.h"

#include "WindInfo2.h"
#include "Header.h"
#include "PtrV.h"
#include "DrawHL.h"



static Desk_bool	KeyDown( int internalkeynumber)
	{
	int	r1;
	if ( _swix( OS_Byte, _INR(0,1)|_OUT(1), 121, internalkeynumber ^ 0x80, &r1))	return Desk_bool_FALSE;
	return (r1) ? Desk_bool_TRUE : Desk_bool_FALSE;
	}


/*
These store whether the mouse movement buttons are down. Used when
responding to MouseV in pointer mode.
 */
static	Desk_bool	keydown_left	= Desk_bool_FALSE;
static	Desk_bool	keydown_right	= Desk_bool_FALSE;
static	Desk_bool	keydown_up	= Desk_bool_FALSE;
static	Desk_bool	keydown_down	= Desk_bool_FALSE;

/*
Note that the frame rate will effect how fast the pointer-emulated mouse
moves. Could call OS_Monotonic time every time the mouse is read and
scale appropriately.
 */
#define	mousespeed_SCALE	256
static int		mouse_speed_max	= 8*mousespeed_SCALE;
static int		mouse_speed_min	= 1*mousespeed_SCALE;
static int		mouse_accel	= 16;
static int		mouse_speed	= mousespeed_SCALE;


static Desk_bool	callback_set_for_highlightcheck = Desk_bool_FALSE;

_kernel_oserror*	HighlighCheck_handler( _kernel_swi_regs* r, void* pw)
// Called when real mouse has moved in highlight mode. Need to check
// whether mouse is still over same icon.
	{
	if ( IconHigh_globals.currentemulation != IconHigh_newemulation_default_HIGHLIGHTING)	return NULL;
	
	Desk_Error2_Try	{
	/*
		Desk_mouse_block	mouse;
		Desk_Wimp_GetPointerInfo( &mouse);
		if ( mouse.icon < 0)	SetHighlight( NULL, 0, NULL, pw);
		else	{
			Desk_icon_block	iconblock;
			Desk_Wimp_GetIconState( mouse.window, mouse.icon, &iconblock);
			SetHighlight( mouse.window, mouse.icon, &iconblock, pw);
			}
		*/
		Desk_wimp_point	dummypos;
		MoveHighlight( &dummypos, iconhigh_direction_NONE, pw);
		callback_set_for_highlightcheck = Desk_bool_FALSE;
		}
	Desk_Error2_Catch	{
		}
	Desk_Error2_EndCatch
	
	return NULL;
	
	Desk_UNUSED( r);
	}



int	Pointer_PtrV_handler( _kernel_swi_regs* r, void* pw)
	{
	MemCheck_checking	oldchecking = MemCheck_SetChecking( 0, 0);
	
	if ( r->r[0]==0)	{
		Desk_wimp_point	dpos = { 0, 0};
		// Request status of device
		
		// Some cunning assembler (PtrV.s) ensures that we are called after the normal
		// mouse has filled in the mouse-movement values. Hence we simply add to the existing values.
		
		if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_HIGHLIGHTING)	{
			// mouse_dpos is not actually used - when highlighting is moved, the mouse is
			// moved directly, as moving here is subsequently scaled by Wimp.
			if ( r->r[2]!=0 || r->r[3]!=0)	{
				// Mouse has already moved, so we should check location of pointer and move/remove highlight
				if ( !callback_set_for_highlightcheck)	{
					_swix( OS_AddCallBack, _INR(0,1), HighlighCheck, pw);
					callback_set_for_highlightcheck = Desk_bool_TRUE;
					}
				}
			}
		
		if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_POINTER)	{
			if ( keydown_left)	dpos.x -= mouse_speed / mousespeed_SCALE;
			if ( keydown_right)	dpos.x += mouse_speed / mousespeed_SCALE;
			if ( keydown_down)	dpos.y -= mouse_speed / mousespeed_SCALE;
			if ( keydown_up)	dpos.y += mouse_speed / mousespeed_SCALE;
			
			if ( keydown_left || keydown_right || keydown_down || keydown_up)	{
				if ( mouse_speed < mouse_speed_max)	mouse_speed += mouse_accel;
				}
			else	{
				mouse_speed = mouse_speed_min;
				// Stops accelaration immediately if all buttons are released.
				}
			
			r->r[2] += dpos.x;
			r->r[3] += dpos.y;
			IconHigh_globals.lastmovement = dpos;
			}
		
		MemCheck_RestoreChecking( oldchecking);
		return 0;	// Intercept the call.
		}
	
	else	{
		MemCheck_RestoreChecking( oldchecking);
		return 1;
		}
	
	Desk_UNUSED( pw);
	
	#ifndef MemCheck_MEMCHECK
		Desk_UNUSED( oldchecking);
	#endif
	}

// These are low-level internal key numbers. See PRMs 1-156.
// These should never be changed.
#define	KEY_KEYV_MOUSE_SELECT	0x70
#define	KEY_KEYV_MOUSE_MENU	0x71
#define	KEY_KEYV_MOUSE_ADJUST	0x72

// The next 3 sets of constants define the keys used to emulate the mouse.
// They are currently the cursor keys, plus Delete, End and PageDown.

// These are low-level internal key numbers. See PRMs 1-156.
#define	KEY_KEYV_SELECT		0x34
#define	KEY_KEYV_MENU		0x35
#define	KEY_KEYV_ADJUST		0x36
#define	KEY_KEYV_RIGHT		0x64
#define	KEY_KEYV_LEFT		0x62
#define	KEY_KEYV_UP		0x59
#define	KEY_KEYV_DOWN		0x63

// Key numbers in wimp event_KEY events.
#define	KEY_WIMP_LEFT		0x18c
#define	KEY_WIMP_RIGHT		0x18d
#define	KEY_WIMP_DOWN		0x18e
#define	KEY_WIMP_UP		0x18f

// These are internal key numbers, as used by OS_Byte 121, Basic's INKEY(-x) etc. See PRMs 1-849
#define	KEY_INTERNAL_DOWN	41
#define	KEY_INTERNAL_UP		57
#define	KEY_INTERNAL_LEFT	25
#define	KEY_INTERNAL_RIGHT	121


int	Pointer_KeyV_handler( _kernel_swi_regs* r, void* pw)
	{
	MemCheck_RegisterMiscBlock( r, sizeof( _kernel_swi_regs));
	
	if ( r->r[0]==1 || r->r[0]==2)	{	// key release/press.
		
		// Convert keyboard's pseudo mouse buttons to to menu button change, and pass on call.
		// Now does intercept call... 18 Feb 1997
		if (0)	;
		else if ( r->r[1]==KEY_KEYV_SELECT)	{ r->r[1] = KEY_KEYV_MOUSE_SELECT;	}
		else if ( r->r[1]==KEY_KEYV_MENU)	{ r->r[1] = KEY_KEYV_MOUSE_MENU;	}
		else if ( r->r[1]==KEY_KEYV_ADJUST)	{ r->r[1] = KEY_KEYV_MOUSE_ADJUST;	}
		
		// Update status of cursor keys, and don't(09:43pm 07 Feb 1997) intercept call.
		// If we intercept call, this can cause problems later on if the elmulation stips
		// while a key is down - the OS will see 2 key-up events etc.
		// Seems to confuse things - system sometimes behaves as though a key is stuck down. etc.
		else if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_POINTER)	{
			if ( r->r[1]==KEY_KEYV_RIGHT)	{ keydown_right	= (r->r[0]==2) ? Desk_bool_TRUE : Desk_bool_FALSE; /*return 0;*/	}
			if ( r->r[1]==KEY_KEYV_LEFT)	{ keydown_left	= (r->r[0]==2) ? Desk_bool_TRUE : Desk_bool_FALSE; /*return 0;*/	}
			if ( r->r[1]==KEY_KEYV_UP)	{ keydown_up	= (r->r[0]==2) ? Desk_bool_TRUE : Desk_bool_FALSE; /*return 0;*/	}
			if ( r->r[1]==KEY_KEYV_DOWN)	{ keydown_down	= (r->r[0]==2) ? Desk_bool_TRUE : Desk_bool_FALSE; /*return 0;*/	}
			}
		
		else if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_HIGHLIGHTING)	{
			/*
			We don't handle key events here - doing them
			later (by trapping wimp key events with a filter) enables auto-repeat to
			be done for us.
			 */
			}
		
		}
	
	MemCheck_UnRegisterMiscBlock( r);
	
	return 1;	// Pass on the call.
	Desk_UNUSED( pw);
	}



static Desk_bool	WindowContainsClickableIcons( Desk_window_handle window)
	{
	Desk_window_info*	info = GetInfoAlloc( window);
	Desk_icon_block*	icons = (Desk_icon_block*) (info+1);
	int			i;
	Desk_bool		r = Desk_bool_FALSE;
	
	for ( i=0; i<info->block.numicons; i++)	{
		if ( icons[i].flags.data.buttontype != Desk_iconbtype_NEVER)	{
			if ( Desk_Coord_RectsOverlap( &info->block.workarearect, &icons[i].workarearect))	{
				r = Desk_bool_TRUE;
				break;
				}
			}
		}
	
	Desk_Window_GetInfoFree( info);
	return r;
        }


static void	EmulationStartAuto( Desk_window_handle window0, void* pw)
	{
	Desk_bool		ptr_in_windowborder	= Desk_bool_FALSE;
	IconHigh_emulationtype	newemulation		= IconHigh_newemulation_default_NONE;
	Desk_window_handle	window;
	
	Desk_Debug_Printf( Desk_error_PLACE "EmulationStartAuto called, window0=0x%p\n", (void*) window0);
	
	IconHigh_globals.lastemulation = IconHigh_globals.currentemulation;
	
	if ( !window0)	{
		Desk_window_state	state;
		Desk_mouse_block	mouse;
		Desk_Wimp_GetPointerInfo( &mouse);
		window = mouse.window;
		Desk_Debug_Printf( Desk_error_PLACE "EmulationStartAuto, mouse window=0x%p, calling GetWindowState\n", (void*) window);
		Desk_Wimp_GetWindowState( mouse.window, &state);
		Desk_Debug_Printf( Desk_error_PLACE "EmulationStartAuto, called GetWindowState\n");
		if ( !Desk_Coord_PointInRect( &mouse.pos, &state.openblock.screenrect))	ptr_in_windowborder = Desk_bool_TRUE;
		}
	else	window = window0;
	
	//IconHigh_globals.window = window;
	
	if ( 0)	;
	
	else if ( 
		IconHigh_globals.newemulation.data.newemulation == IconHigh_newemulation_default_POINTER
		||
			(
			IconHigh_globals.newemulation.data.newemulation == IconHigh_newemulation_default_PREVIOUS
			&&
			IconHigh_globals.lastemulation == IconHigh_newemulation_default_POINTER
			)
		)
		{
		if ( IconHigh_globals.newemulation.data.highlighting_with_icons && (!ptr_in_windowborder) && WindowContainsClickableIcons( window))
			newemulation = IconHigh_newemulation_default_HIGHLIGHTING;
		else	newemulation = IconHigh_newemulation_default_POINTER;
		}
	
	else if (
		IconHigh_globals.newemulation.data.newemulation == IconHigh_newemulation_default_HIGHLIGHTING
		||
			(
			IconHigh_globals.newemulation.data.newemulation == IconHigh_newemulation_default_PREVIOUS
			&&
			IconHigh_globals.lastemulation == IconHigh_newemulation_default_HIGHLIGHTING
			)
		)
		{
		if ( IconHigh_globals.newemulation.data.pointer_with_noicons && (ptr_in_windowborder || !WindowContainsClickableIcons( window)))
			newemulation = IconHigh_newemulation_default_POINTER;
		else	newemulation = IconHigh_newemulation_default_HIGHLIGHTING;
		}
	
	EmulationPointerStart( newemulation, pw);
	
	Desk_Debug_Printf( Desk_error_PLACE "EmulationStartAuto returning\n");
	}



static void	WimpKeyPressHandler( Desk_filter2_postblock *eventinfo, void* pw, void* reference)
	{
	// If cursor key, convert to one of '2468' and pass to MoveHighlight.
	//return;
	Desk_Error2_Try	{
		
		Desk_Debug_Printf( Desk_error_PLACE "WimpKeyPressHandler called for wimp key 0x%x\n", eventinfo->eventdata->key.code);
		
		if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_HIGHLIGHTING)	{
			Desk_wimp_point	pos;
			Desk_wimp_point	oldpos;
			
			GetMousePos( &pos);
			oldpos = pos;
			
			// We only move the highlight if the key is still down, otherwise autorepeat
			// can cause lots of key events to be delivered to use well after the key has
			// been released, causing all sorts of confusion.
			
			if ( 0)	;
			
			else if ( eventinfo->eventdata->key.code==KEY_WIMP_LEFT	 && KeyDown( KEY_INTERNAL_LEFT))
				MoveHighlight( &pos, iconhigh_direction_LEFT, pw);
			
			else if ( eventinfo->eventdata->key.code==KEY_WIMP_RIGHT && KeyDown( KEY_INTERNAL_RIGHT))
				MoveHighlight( &pos, iconhigh_direction_RIGHT, pw);
			
			else if ( eventinfo->eventdata->key.code==KEY_WIMP_DOWN  && KeyDown( KEY_INTERNAL_DOWN))
				MoveHighlight( &pos, iconhigh_direction_DOWN, pw);
			
			else if ( eventinfo->eventdata->key.code==KEY_WIMP_UP    && KeyDown( KEY_INTERNAL_UP))
				MoveHighlight( &pos, iconhigh_direction_UP, pw);
			
			SetMousePos( pos.x, pos.y);
			IconHigh_globals.lastmovement.x = pos.x - oldpos.x;
			IconHigh_globals.lastmovement.y = pos.y - oldpos.y;
			
			//_swix( 0x107, 0);
			}
		
		if	(
			   eventinfo->eventdata->key.code==KEY_WIMP_LEFT 
			|| eventinfo->eventdata->key.code==KEY_WIMP_RIGHT
			|| eventinfo->eventdata->key.code==KEY_WIMP_DOWN 
			|| eventinfo->eventdata->key.code==KEY_WIMP_UP
			)
			{
			eventinfo->eventtype = (Desk_event_type) -1;
			// Stops filtered task from receiving this key press.
			}
		}
	Desk_Error2_Catch	{
		}
	Desk_Error2_EndCatch
	
	
	Desk_Debug_Printf( Desk_error_PLACE "WimpKeyPressHandler returning\n");
	
	Desk_UNUSED( reference);
	}




/*
static void	PtrEnterLeaveHandler( Desk_filter2_postblock *eventinfo, void* pw, void* reference)
	{
	Desk_Debug_Printf( Desk_error_PLACE "PtrEnterLeaveHandler entered\n");
	
	Desk_Error2_Try	{
		Desk_Debug_Printf( Desk_error_PLACE "Event %i, pointer %s window 0x%08x (task 0x%08x\n", 
			eventinfo->eventtype, 
			(eventinfo->eventtype==Desk_event_PTRLEAVE) ? "leaving"
			: (eventinfo->eventtype==Desk_event_PTRENTER) ? "entering"
			: "???",
			eventinfo->eventdata->openblock.window,
			eventinfo->task
			);
		
		if ( Desk_event_PTRLEAVE==eventinfo->eventtype)	EmulationStartAuto( NULL, pw);	// Unknown window.
		
		if ( Desk_event_PTRENTER==eventinfo->eventtype)	EmulationStartAuto( eventinfo->eventdata->openblock.window, pw);
		}
	Desk_Error2_Catch	{
		}
	Desk_Error2_EndCatch
	
	Desk_Debug_Printf( Desk_error_PLACE "PtrEnterLeaveHandler returning\n");
	
	Desk_UNUSED( reference);
	}
*/

/*
static Desk_filter2_post2handle	ptrenterleavehandle	= NULL;
static Desk_filter2_post2handle	keyeventhandle		= NULL;
*/


_kernel_oserror*	KeyFilter_handler( _kernel_swi_regs* r, void* pw)
	{
	Desk_event_type		type;
	Desk_event_data*	data;
	MemCheck_RegisterMiscBlock( r, sizeof( *r));
	type = (Desk_event_type) r->r[0];
	data = (Desk_event_data*) r->r[1];
	MemCheck_RegisterMiscBlock( data, 256);
	
	WimpKeyPressHandler( (Desk_filter2_postblock*) r, pw, NULL);
	
	MemCheck_UnRegisterMiscBlock( data);
	MemCheck_UnRegisterMiscBlock( r);
	return NULL;
	}

static Desk_event_pollmask	global_premask = {0};

_kernel_oserror*	PtrPreFilter_handler( _kernel_swi_regs* r, void* pw)
	{
	MemCheck_RegisterMiscBlock( r, sizeof( *r));
	global_premask.value = r->r[0];
	r->r[0] &= (~( (1<<Desk_event_PTRLEAVE) | (1<<Desk_event_PTRENTER)));
		// Ensure ptr enter/leave eventa aren't masked out.
	MemCheck_UnRegisterMiscBlock( r);
	return NULL;
	Desk_UNUSED( pw);
	}

_kernel_oserror*	PtrPostFilter_handler( _kernel_swi_regs* r, void* pw)
	{
	Desk_event_type		type;
	Desk_event_data*	data;
	MemCheck_RegisterMiscBlock( r, sizeof( *r));
	type = (Desk_event_type) r->r[0];
	data = (Desk_event_data*) r->r[1];
	MemCheck_RegisterMiscBlock( data, 64);
	
	SetHighlight( 0, 0, NULL, pw);
	
	if ( Desk_event_PTRLEAVE==type)	EmulationStartAuto( NULL, pw);
	if ( Desk_event_PTRENTER==type)	EmulationStartAuto( data->openblock.window, pw);
	if ( (1<<type) && global_premask.value)	r->r[0] = -1;
		// Stop this event from reaching the app.
	global_premask.value = 0;
	MemCheck_UnRegisterMiscBlock( data);
	MemCheck_UnRegisterMiscBlock( r);
	return NULL;
	}



void	EmulationPointerStart( IconHigh_emulationtype emulation, void* pw)
	{
	if ( emulation==IconHigh_newemulation_default_NONE)	{
		EmulationPointerStop( pw);
		return;
        	}
        
        SetHighlight( 0, 0, NULL, pw);
        
        if ( emulation==IconHigh_globals.currentemulation)	return;
        
        EmulationPointerStop( pw);
        
	IconHigh_globals.currentemulation = emulation;
	
	Desk_Debug_Printf( Desk_error_PLACE "EmulationPointerStart called, pw=0x%p, type=%s\n", 
		pw,
		(emulation==IconHigh_newemulation_default_POINTER) ? "pointer"
		:(emulation==IconHigh_newemulation_default_HIGHLIGHTING) ? "highlighting"
		:(emulation==IconHigh_newemulation_default_PAUSED) ? "paused"
		: "-"
		);
	
	mouse_speed	= mouse_speed_min;
	
	keydown_left	= KeyDown( KEY_INTERNAL_LEFT);
	keydown_right	= KeyDown( KEY_INTERNAL_RIGHT);
	keydown_up	= KeyDown( KEY_INTERNAL_UP);
	keydown_down	= KeyDown( KEY_INTERNAL_DOWN);
	
	if ( emulation!=IconHigh_newemulation_default_PAUSED)	{
		_swix( OS_Claim, _INR(0,2), 0x26, Pointer_PtrV_Handler2, pw);
		_swix( OS_Claim, _INR(0,2), 0x13, Pointer_KeyV, pw);
		}
	
	/*
	keyeventhandle = Desk_Filter2_ClaimPost(
				~( 1<<Desk_event_KEY),
				0,
				WimpKeyPressHandler,
				NULL,
				"IconHigh wimp keypress",
				pw
				);
	
	
	ptrenterleavehandle = Desk_Filter2_ClaimPost2(
			~( (1<<Desk_event_PTRLEAVE) | (1<<Desk_event_PTRENTER)),
			0,
			PtrEnterLeaveHandler,
			(void*) 0x12345,
			"IconHigh ptr enter/leave",
			pw
			);
	*/
	_swix( Filter_RegisterPreFilter, _INR(0,3), 
		"IconHigh ptr enter/leave",
		PtrPreFilter,
		pw,
		0
		);
	
	_swix( Filter_RegisterPostFilter, _INR(0,4), 
		"IconHigh ptr enter/leave",
		PtrPostFilter,
		pw,
		0,
		~((1<<Desk_event_PTRLEAVE) | (1<<Desk_event_PTRENTER))
		);
	
	_swix( Filter_RegisterPostFilter, _INR(0,4), 
		"IconHigh ptr enter/leave",
		KeyFilter,
		pw,
		0,
		~(1<<Desk_event_KEY)
		);
	
	}



void	EmulationPointerStop( void* pw)
	{
	Desk_Debug3_Printf( Desk_error_PLACE "EmulationPointerStop called, pw=0x%p\n", pw);
	
	SetHighlight( 0, 0, NULL, pw);
	
	if ( IconHigh_globals.currentemulation == IconHigh_newemulation_default_NONE)	return;
	
	/*
	Desk_Error2_TryCatch(
		if (ptrenterleavehandle)	Desk_Filter2_ReleasePost2( ptrenterleavehandle);
		ptrenterleavehandle = NULL;
		,
		)
	Desk_Error2_TryCatch(
		if (keyeventhandle)	Desk_Filter2_ReleasePost( keyeventhandle);
		keyeventhandle = NULL;
		,
		)
	*/
	
	_swix( Filter_DeRegisterPreFilter, _INR(0,3), 
		"IconHigh ptr enter/leave",
		PtrPreFilter,
		pw,
		0
		);
	
	_swix( Filter_DeRegisterPostFilter, _INR(0,4), 
		"IconHigh ptr enter/leave",
		PtrPostFilter,
		pw,
		0,
		~((1<<Desk_event_PTRLEAVE) | (1<<Desk_event_PTRENTER))
		);
	
	_swix( Filter_DeRegisterPostFilter, _INR(0,4), 
		"IconHigh ptr enter/leave",
		KeyFilter,
		pw,
		0,
		~(1<<Desk_event_KEY)
		);
	
	_swix( OS_Release, _INR(0,2), 0x26, Pointer_PtrV_Handler2, pw);
	_swix( OS_Release, _INR(0,2), 0x13, Pointer_KeyV, pw);
	
	_swix( OS_RemoveCallBack, _INR(0,1), HighlighCheck, pw);
	callback_set_for_highlightcheck = Desk_bool_FALSE;
	
	SetHighlight( 0, 0, NULL, pw);
	
	IconHigh_globals.currentemulation = IconHigh_newemulation_default_NONE;
	
	Desk_Debug3_Printf( Desk_error_PLACE "EmulationPointerStop called2, pw=0x%p\n", pw);
	}



