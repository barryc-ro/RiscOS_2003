22 Jan 1997

Got SWI chunk allocated.



29 Jan 1997
Current status: Moves between icons in the current window in highlight
mode. Ballistic emulation works ok, with accelaration etc.

Works by sitting on PointerV and KeyV.

Problems so far: Detection of cursor keys is fine when looking for key
up/down events for ballistic emulation. However, highlighting needs to
be given keys after autorepeat has been added by the kernel. At the
moment I can't do this - tried to use OS_Byte 4 (PRMs (1-856) to make
cursor keys output normal key codes, but this didn't work. Hence
ballistic emulation currently responds to 2,4,8 and 6 being pressed
(either on numeric keypad or in main part of keyboard). The key events
aren't intercepted yet.


30 Jan 1997

Now /adds/ ballistic movement to that specified by the usual mouse, so
that IconHigh doesn't stop the normal mouse from being used.



03 Feb 1997

In highlight mode, distance now weighted according to direction.

Now scrolls window if needed to expose icon. This uses new feature of
TaskModule 0.05.


Added two Desk libraries locally, which allow veneers which pass a
reference to the client handler (as well as CMHG's pw), and a high-level
interface to the filter manager. Both seem to work.


04 Feb 1997

Added extra filter code for filters which munge the app's pollmask so
that the required events are always detected by the filter, even if the
task masks them out.

Seems to work ok. Note that testing the filtering out of the added code
with WimpMon doesn't work too well - WimpMon can see the extra events if
its filter is called before IconHigh's mask-restoring filter.

Added code to handle ptrenter/leave, and switch to appropriate emulation
mode. Works reasonably, but pointer stops moving and one has to press
cursor key again in ballistic mode. Tried hack to find initial state of
cursor keys, but doesn't work.


06 Feb 1997

Doesn't restart emulation when moving to new window if emulation is
unchanged.


07 Feb 1997

Seemed to have solved most of the problems. 

One was that sometimes a pointer enter event is received but
WImp_GetPointerInfo thinks pointer is still over old window. Thus
IconHigh chose the wrong window to test for presence of icons etc. The
intermitency of this was probably caused by the random order in which
IconHigh's filter detected event_LTRLEAVE/ENTER.

Another (which resulted in spurious movement of mouse and extra key
events being delivered to wimp apps) was caused by IconHigh blithely
moving the mouse inresponse to buffered autorepat events. It now only
moves the mouse in highlight mode if the appropriate key is still
pressed.

Now carries on moving after switching to ballisticmode from highlight
mode.

Need to stop cursor presses from reaching applications. Probably have to
use a filter.


11 Feb 1997

Bug causes no stack for trap handler etc. Seems that ptr enter/leave
code corrupts the memory of the task which is being filtered.

Seems to be ptr leave - eg moving onto titlebar. If no new emulation is
started (which is mosdt of the time because EmulationPointerStart
returns immediately if new emulation == old emulation) then everything
is ok.

Trying to ignore ptr leave com,pletely.
probkem is caused by ptr enter too. Even caused when
PtrEnterLeaveHandler calls EmulationPointerStart() straightaway, without
any checking of window info etc.

Problem goes away if Desk_Filter2_ClaimPost2 claim/relese is ommited...

Maybe it is the setting of r0to -1 after postfilter

Bug was caused by Desk_Filter2_ not coping with a filter being
unregistered by its client function. Hurray for MemCheck...


Still seems to be problem, only occurs after emulation has restarted,
and when key events are masked out...

**Check that MC checking isn't turnied ofand not restored...**
**try with direct CMHG veneers instead of Desk_ModHand etc.**



12 Feb 1997
Trying with direct CMHG veneers...Also removwed all mouse-buffer
functions in c.pointer - they were unused anyway. Seems to work ok.

13 Feb 1997
Made all key nbymers be #defines.


14 Feb 1997

Keeps lastmovement up to date.


17 Feb 1997

Problem with Filtermanager not understanding the inconsistent version
numbers used by Windowmanagr. It checks for version 3.80, and assumes
that all later versions have new filter code. Ubfortuntely, they don't.
Now have a hacked version which checks for version 3.96. This is on my
NC's NFS directory.


Works ok.


18 Feb 1997

Now intercepts KeyV in ballistic mode when key press is a cursor
direction key. Should prevent on-screen keyboard from detecting cursor
keypress KeyV and thus think that there is a real kbd present, and thus
closing down.

Now moves highlight when real mouse is moved.
Modified MoveHighlight() to cope with directioni_NULL - looks for valid
icon under pointer.

Problems are caused when window containing iconhighlightong is closed -
looks like redrawmanager doesn't detect this...?
Oops - problem was called by IconHigh calling Wimp[_ForceRedraw when
highlight was removed - caused problems when window doesn't exist any
more... Seems to be fixed now...






18 Mar 1997

Some info on keys...

Three types of key numbers are used:

KEY_KEYV_*	These are as used in the KeyV vector (PRMs 5a-238), and
		also in Key up/down events (PRMs 1-156).
KEY_INTERNAL_*	Used to test status of keys in OS_Byte 121, Basic's
		INKEY(-x) etc.
KEY_WIMP_*	Key numbers in Wimp keyboard events.

All three numbers are currently used because IconHigh does the following:


Detects KeyV vectors, and converts keypresses to mouse button presses.
This is done at this low level so that the kernel will automatically
detect mouse double-clicks and drags. Also allows IconHigh to store the
status of the direction keys when in pointer mode so that it knowns
which directorion to move the mouse in in response to PointerV (which is
generated every VSync), without explicitly testing the key up/down
status every VSync.

In highlight mode, IconHigh intercepts Wimp events for the direction
keys. This is done so that auto-repeat of the direction keys happens.

When emulation starts, the status of the direction keys is found
immediately (before the next PointerV), so that the mouse isn't
automatically stationary for an instant. This allows IconHigh to stop
and then start emulation whenever the pointer moves across a window
boundary without losing momentum. This makes deciding whether to change
emulation mode simpler.


Because the NC's IR keyboard and keypad only put key codes into the
keyboard buffer (PRMs 1-153), need to change the above mechanism so that
it doesn't rely on KeyV.



18 Mar 1997

Added detection of ScollLock key - toggles emulation on/off.

This is not quite as trivial as it may seem. If emulation is started off
with the pointer in the middle of a window, then IconHigh might not get
the first ptr-leave event, if the window's task has masked
ptrenter/leave and doesn't receive an event before the ptr leaves. This
is because IconHigh relies on munging each task's pollmask so that ptr
enter/leaves are always received. This can only be done immediately
after the task calls Wimp_Poll.

Will have to send a dummy event or something... The only candidate I can
see is Event_Scroll_Request (10), which cannot be masked out, and
accepts a scroll direction 0 meaning no change. Could send this to the
window, so that the prefilter can then munge the poll mask. 

19 Mar 1997

Better would be to send Open_Window, which also connot be masked out.
Have done this. Doesn't always work though - under some circumstances,
the call to Wimp_GetWindowState returns 'invalid wimp operation in this
context'. Seems to be ok for detectkon of toggle key though.

Implemented IconHigh_SetMomentum. 

Implemented IconHigh_SetHighlightColour - not tested. 

Fixed bug in !ROM_AOF !Run - adds -d flag to makatic3



20 Mar 1997
Looking at detecting highglight movement from keyboard buffer rather
than wimp poll interception. Keyboard buffer is number 0, write chr 'c'
with 'OS_Byte 128, 0, c'.
Cursor keys generate codes 140-143 (0x8c-0x8f) - see PRMs 1-892

Converted to intercept InsV to find keys, rather than Wimp event_Key
events. Also added SWI IconHigh_IgnoreNextCharacter.


21 Mar 1997

Refuses to move mouse to negative x or y coordinate - when this is
attempted, the mouse seems to end up 256 units in from the edge.


26 Mar 1997

Added support for irhandset. Module version now set to 0.01
IRhandset buffer codes are:
Ok:	0x0d
Menu:	0xc1
Stop:	0xc3

Seems to work ok, but pointer emulation without key up/down is not very
good - have to pretend the key is down for a time (dependent on the
autorepeat rate) so that autorepeat results in smooth movement and
accelaration.

NB This version still uses Delete,End,PageDown as mouse buttons on
standard keyboard.

Checked in as version 0.02


Added some timing code which uses my Timer1 library to measure the
interval between calls to the PtrV vector. There seem to be extra calls
for some reason. This version built by 'cc -dTIME_PTRV ...'.



08 Apr 1997

Changing the operation of the toggle key. This is only active when
emulation is on, and temporarily turns emulation off. Paused status is
orthogonal to the emulation type. Thus the emulation can change from
between pointer and highlight and still be paused. Pause is turned off
when emulation changes from none to either of pointer or highlight.

Detection of toggle has to be done by looking for key/down events - the
scroll key isn't put into the keyboard buffer, neither is the IRHandset
'Stop' key. This also avoids the toggling being sensitive to
auto-repeat.

All seems to work ok...


09 Apr 1997

Doing two things: Putting calls to clock() into PtrV handler to avoid
jumping of the pointer in pointer mode, and fixing flagging of a
key-press being from interception of KeyV rather than keyboard-buffer
InsV (will work with n-key rollover).

All works fine...


-- version 0.04 --


Note that the use of clock() in the PtrV handler isn't ideal. The time
between PtrV calls is typically 0, 1 or 2 cs, so the pointer still moves
unevenly.




15 Apr 1997

Adding code to work with IRKeyboard keys.

Adding code to ensure that the kernel's KeyV code doesn't get sent
contradictory mouse-key events (eg two key-down events in a row).


16 Apr 1997

Removed code that ensured that kernel's KeyV code doesn't get sent
contradictory mouse-key events. This was originaly done to fix a problem
where if emulation was started while <return> was depressed, the release
of <return> would be converted into a mouse button release, leaving the
os thinking that the return key was still down, and autorepeating it
into the keyboard buffer, which was then picked up by IconHigh and
converted into multiple SELECT clicks.

Other problems were also likely to be caused by pressing of buttons/keys
inparticular orders.

Anyway, solution now adopted is to send keyv release events for all
mouse button keys whenever emulation starts. Steve Cormie says that the
kernel's KeyV code can cope fine with such multiple key events.

There is a problem with drags from highlight emulation - ptr leave
events don't seem to be sent, so emulation doesn't change to pointer as
it should...



-- version 0.05 --
