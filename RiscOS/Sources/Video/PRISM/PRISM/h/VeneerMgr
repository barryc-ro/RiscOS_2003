#if !defined(PRISM_VENEERMGR_H) /* file used if not already included */
#define PRISM_VENEERMGR_H
/*****************************************************************************
* $Id$
* $Name$
*
* Author(s):  Ben Avison
* Project(s): 
*
* ----------------------------------------------------------------------------
* Copyright [2002] Pace Micro Technology PLC.  All rights reserved.
*
* The copyright in this material is owned by Pace Micro Technology PLC
* ("Pace").  This material is regarded as a highly confidential trade secret
* of Pace.  It may not be reproduced, used, sold or in any other way exploited
* or transferred to any third party without the prior written permission of
* Pace.
*
* ----------------------------------------------------------------------------
* Purpose: Direct-call veneer management
*
* ----------------------------------------------------------------------------
* History: See source control system log
*
*****************************************************************************/


/*****************************************************************************
* Include header files
*****************************************************************************/
#include <stdint.h>
#include "kernel.h"

#include "PRISM.h"


/*****************************************************************************
* MACROS
*****************************************************************************/

/* First a few "private" macros needed to define the later ones */

#define PRISM_WORDSIZEOF1(a1) ((sizeof(a1)+3)/4)
#define PRISM_WORDSIZEOF2(a1,a2) (PRISM_WORDSIZEOF1(a1)+PRISM_WORDSIZEOF1(a2))
#define PRISM_WORDSIZEOF3(a1,a2,a3) (PRISM_WORDSIZEOF2(a1,a2)+PRISM_WORDSIZEOF1(a3))
#define PRISM_WORDSIZEOF4(a1,a2,a3,a4) (PRISM_WORDSIZEOF3(a1,a2,a3)+PRISM_WORDSIZEOF1(a4))
#define PRISM_WORDSIZEOF5(a1,a2,a3,a4,a5) (PRISM_WORDSIZEOF4(a1,a2,a3,a4)+PRISM_WORDSIZEOF1(a5))
#define PRISM_WORDSIZEOF6(a1,a2,a3,a4,a5,a6) (PRISM_WORDSIZEOF5(a1,a2,a3,a4,a5)+PRISM_WORDSIZEOF1(a6))
#define PRISM_WORDSIZEOF7(a1,a2,a3,a4,a5,a6,a7) (PRISM_WORDSIZEOF6(a1,a2,a3,a4,a5,a6)+PRISM_WORDSIZEOF1(a7))
#define PRISM_WORDSIZEOF8(a1,a2,a3,a4,a5,a6,a7,a8) (PRISM_WORDSIZEOF7(a1,a2,a3,a4,a5,a6,a7)+PRISM_WORDSIZEOF1(a8))

//  The following macros should be used to declare any functions for which you will be creating a veneer.
//  
//  In this way, there is much less danger of getting the number of stacked words wrong in the table passed to PRISM_CreateVeneers.
//  
//  Unfortunately, even C99's variadic macros aren't sufficient to perform this sort of operation on a variable number of parameters,
//  so you will need to select the appropriate macro for the number of arguments in your function.
//  
//  Note that under APCS, unless you use the __value_in_regs storage class (and the result is four words or smaller), any function
//  that returns a result larger than one word (except the __int64 type, currently not supported by our compiler) will actually use an
//  additional argument word to hold an internal pointer through which the result is to be returned. These macros cannot detect such
//  cases automatically, so you must use the _RETURNING_STRUCT macro variants for them.
//  
//  For example, when you have used
//  
//    PRISM_DECLARE_FUNCTION_5(static void, fred, bool /*arnold*/, char * /*brian*/, int /*chris*/, double /*dave*/, char /*edward*/)
//  
//  then you will have declared the function
//  
//    static void fred(bool /*arnold*/, char * /*brian*/, int /*chris*/, double /*dave*/, char /*edward*/);
//  
//  and the enum  prism_STACK_WORDS_fred  will have been set to the value 2.
//  
//  Note that it is essential that the argument names are commented, if not omitted entirely, for these macros to work (because they use sizeof()).

#define PRISM_DECLARE_FUNCTION_0(type,name) \
  enum { prism_STACK_WORDS_##name = 0 }; \
  type name(void);
#define PRISM_DECLARE_FUNCTION_0_RETURNING_STRUCT(type,name) \
  enum { prism_STACK_WORDS_##name = 0 }; \
  type name(void);
#define PRISM_DECLARE_FUNCTION_1(type,name,a1) \
  enum { prism_STACK_WORDS_##name = PRISM_WORDSIZEOF1(a1) < 4 ? 0 : -4 + PRISM_WORDSIZEOF1(a1) }; \
  type name(a1);
#define PRISM_DECLARE_FUNCTION_1_RETURNING_STRUCT(type,name,a1) \
  enum { prism_STACK_WORDS_##name = PRISM_WORDSIZEOF1(a1) < 3 ? 0 : -3 + PRISM_WORDSIZEOF1(a1) }; \
  type name(a1);
#define PRISM_DECLARE_FUNCTION_2(type,name,a1,a2) \
  enum { prism_STACK_WORDS_##name = PRISM_WORDSIZEOF2(a1,a2) < 4 ? 0 : -4 + PRISM_WORDSIZEOF2(a1,a2) }; \
  type name(a1,a2);
#define PRISM_DECLARE_FUNCTION_2_RETURNING_STRUCT(type,name,a1,a2) \
  enum { prism_STACK_WORDS_##name = PRISM_WORDSIZEOF2(a1,a2) < 3 ? 0 : -3 + PRISM_WORDSIZEOF2(a1,a2) }; \
  type name(a1,a2);
#define PRISM_DECLARE_FUNCTION_3(type,name,a1,a2,a3) \
  enum { prism_STACK_WORDS_##name = PRISM_WORDSIZEOF3(a1,a2,a3) < 4 ? 0 : -4 + PRISM_WORDSIZEOF3(a1,a2,a3) }; \
  type name(a1,a2,a3);
#define PRISM_DECLARE_FUNCTION_3_RETURNING_STRUCT(type,name,a1,a2,a3) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF3(a1,a2,a3) }; \
  type name(a1,a2,a3);
#define PRISM_DECLARE_FUNCTION_4(type,name,a1,a2,a3,a4) \
  enum { prism_STACK_WORDS_##name = -4 + PRISM_WORDSIZEOF4(a1,a2,a3,a4) }; \
  type name(a1,a2,a3,a4);
#define PRISM_DECLARE_FUNCTION_4_RETURNING_STRUCT(type,name,a1,a2,a3,a4) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF4(a1,a2,a3,a4) }; \
  type name(a1,a2,a3,a4);
#define PRISM_DECLARE_FUNCTION_5(type,name,a1,a2,a3,a4,a5) \
  enum { prism_STACK_WORDS_##name = -4 + PRISM_WORDSIZEOF5(a1,a2,a3,a4,a5) }; \
  type name(a1,a2,a3,a4,a5);
#define PRISM_DECLARE_FUNCTION_5_RETURNING_STRUCT(type,name,a1,a2,a3,a4,a5) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF5(a1,a2,a3,a4,a5) }; \
  type name(a1,a2,a3,a4,a5);
#define PRISM_DECLARE_FUNCTION_6(type,name,a1,a2,a3,a4,a5,a6) \
  enum { prism_STACK_WORDS_##name = -4 + PRISM_WORDSIZEOF6(a1,a2,a3,a4,a5,a6) }; \
  type name(a1,a2,a3,a4,a5,a6);
#define PRISM_DECLARE_FUNCTION_6_RETURNING_STRUCT(type,name,a1,a2,a3,a4,a5,a6) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF6(a1,a2,a3,a4,a5,a6) }; \
  type name(a1,a2,a3,a4,a5,a6);
#define PRISM_DECLARE_FUNCTION_7(type,name,a1,a2,a3,a4,a5,a6,a7) \
  enum { prism_STACK_WORDS_##name = -4 + PRISM_WORDSIZEOF7(a1,a2,a3,a4,a5,a6,a7) }; \
  type name(a1,a2,a3,a4,a5,a6,a7);
#define PRISM_DECLARE_FUNCTION_7_RETURNING_STRUCT(type,name,a1,a2,a3,a4,a5,a6,a7) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF7(a1,a2,a3,a4,a5,a6,a7) }; \
  type name(a1,a2,a3,a4,a5,a6,a7);
#define PRISM_DECLARE_FUNCTION_8(type,name,a1,a2,a3,a4,a5,a6,a7,a8) \
  enum { prism_STACK_WORDS_##name = -4 + PRISM_WORDSIZEOF8(a1,a2,a3,a4,a5,a6,a7,a8) }; \
  type name(a1,a2,a3,a4,a5,a6,a7,a8);
#define PRISM_DECLARE_FUNCTION_8_RETURNING_STRUCT(type,name,a1,a2,a3,a4,a5,a6,a7,a8) \
  enum { prism_STACK_WORDS_##name = -3 + PRISM_WORDSIZEOF8(a1,a2,a3,a4,a5,a6,a7,a8) }; \
  type name(a1,a2,a3,a4,a5,a6,a7,a8);


/*****************************************************************************
* New type definitions
*****************************************************************************/


/*****************************************************************************
* Constants
*****************************************************************************/


/*****************************************************************************
* Global variables
*****************************************************************************/


/*****************************************************************************
* Function prototypes
*****************************************************************************/

/*****************************************************************************
* veneermgr_Init
*
* Must be called on module initialisation
* Not re-entrant
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NOTHING
*****************************************************************************/
extern void veneermgr_Init(void);

/*****************************************************************************
* veneermgr_Final
*
* Must be called on module finalisation
* Not re-entrant
*
* Assumptions
*  NONE
*
* Inputs
*  NONE
*
* Outputs
*  NONE
*
* Returns
*  NOTHING
*****************************************************************************/
extern void veneermgr_Final(void);

/*****************************************************************************
* veneermgr_Cleanup
*
* Tidy up after an abnormal exit of a PRISM component
* Not re-entrant
*
* Assumptions
*  NONE
*
* Inputs
*  id: PRISM ID of exiting component
*
* Outputs
*  NONE
*
* Returns
*  NOTHING
*****************************************************************************/
extern void veneermgr_Cleanup(prism_id_t id);

/*****************************************************************************
* veneermgr_Create
*
* Creates veneers
* Not re-entrant
*
* Assumptions
*  NONE
*
* Inputs
*  flags:      see SWI PRISM_CreateVeneers
*  table:      pointer to table of (function pointer, stack usage) entries
*  table_size: number of entries in table
*  workspace:  either module workspace, or module private word
*  id:         PRISM ID of component containing the functions the veneers point to
*
* Outputs
*  veneers:    pointer to the created veneer entry points (at quadword intervals)
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
extern _kernel_oserror *veneermgr_Create(uint32_t flags, const void *table, size_t table_size, const void *workspace, prism_id_t id, void **veneers);

/*****************************************************************************
* veneermgr_Free
*
* Frees veneers
* Not re-entrant
*
* Assumptions
*  NONE
*
* Inputs
*  veneers: veneer struct (as returned from veneermgr_Create)
*  id:      PRISM ID of component containing the functions the veneers point to
*
* Outputs
*  NONE
*
* Returns
*  NULL if successful; otherwise pointer to error block
*****************************************************************************/
extern _kernel_oserror *veneermgr_Free(void *veneers, prism_id_t id);


#endif  /* end of sentry #ifdef */
/*****************************************************************************
* END OF FILE
*****************************************************************************/
