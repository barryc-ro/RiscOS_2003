PRISM module API                                          20-Jul-2001
================                                          ===========


* PRISM component to PRISM module
  -------------------------------

PRISM_ComponentRegister

  R0 = Flags (0)
  R1 = Component's SWI base
  R2 = Component's PRISM ID
  R3 = Component's version number * 100
  R4 = Pointer to NUL-terminated information string (50 bytes or less
       including terminator)

  R0 = Exit flags (0)

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Declares the availability of a PRISM component to the PRISM module. This will
  allow the component to be listed by *PRISMComponents and *PRISMStatus. This
  SWI must be called before other component-to-module SWIs may be called.

  Components should call this SWI on initialisation. If it fails with "No such
  SWI" (error &1E6) that failure should be kept silent. The component should
  wait for Service_PRISM_Core with reason code 0 (PRISMModuleStarted) and PRISM
  ID &01001000 (PRISM_PRISMID) and when seen, attept to register again.

  In the event that Service_PRISM_Core is seen with reason code 1
  (PRISMModuleDying) and PRISM ID &01001000 (PRISM_PRISMID) is seen, the
  component should note that the PRISM module has died and it is no longer
  registered. It should wait for the module to start (as described above) and
  register again.

  If a client request is made of a component when it is not registered with
  PRISM, and in order to successfully fulfil the request the PRISM module
  would be needed, it should raise error &819822 ("PRISM service unavailable",
  prism_ERROR_SERVICE_UNAVAILABLE).

  To be PRISM compliant, the module should itself issue Service_PRISM_Core /
  PRISMModuleStarted after initialisation (so after registering with PRISM) and
  should also raise Service_PRISM_Core / PRISMModuleDying when exitting, after
  deregistering with PRISM - see SWI PRISM_ComponentDeregister.

  Any item with an allocated PRISM ID is obliged to register with the PRISM
  module when it starts - this applies to all classes of modules, including
  even the PRISM module (it registers with itself on startup).

  Possible errors:

    "PRISM could not claim enough memory"
    "Invalid parameters (PRISM_ComponentRegister) in PRISM"
    "Component already registered with PRISM"



PRISM_ComponentDeregister

  R0 = Flags (0)
  R1 = Component's SWI base
  R2 = Component's PRISM ID

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Any module registered with PRISM should call this SWI to deregister when it
  is either about to exit or cannot continue to provide services to the PRISM
  system. Normally, this is done in a module finalisation handler before
  issuing Service_PRISM_Core / PRISMModuleDying.

  Possible errors:

    "PRISM ID not recognised in PRISM"



PRISM_ComponentOptions

  R0 = Flags (0)
  R1 = PRISM ID

  R0 = Exit flags (0)

  This SWI is currently reserved and should not be used.



PRISM_ComponentNotify

  R0 = Flags (0)
  R1 = PRISM ID

  R0 = Exit flags (0)

  This SWI is currently reserved and should not be used.



PRISM_AllocateHandle

  R0 = Flags (0)
  R1 = PRISM ID
  R2 = Pointer to base of this module's array, or 0 if none exists presently
  R3 = Non-zero value to associate with the handle PRISM will allocate
  R4 = Highest handle number allowed, or 0 for default of 65535

  R0 = Exit flags (0)
  R1 = Local handle to use
  R2 = Updated to point to base of this module's array (which may have moved)
  R3 = Highest valid handle number

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Since client IDs and local IDs within the PRISM system are 16-bit quantities
  to allow streams of data to be described by a value capable of fitting in a
  single 32-bit processor register, it is not possible to use handles for
  sessions which are in fact pointers to local data structures. This does in
  fact hold some advantages but leads to a requirement to rapidly associate
  the handle with real session-related data. To this end, the most obvious
  solution would be an array of pointers to session data with the 16-bit value
  serving as an index into this array.

  Rather than have individual components within the PRISM system each include
  their own duplicated pieces of array management, the PRISM module provides a
  central service for associating a given value with a 16-bit handle that may
  be used as local or client handle as required. The PRISM_AllocateHandle SWI
  serves this purpose.

  Modules calling PRISM_AllocateHandle pass their PRISM ID in R1 on entry.
  This is used for safety checking as described later. In R2 on entry, the
  module passes a pointer to the base of the array. If this is the first time
  the module has ever asked PRISM for a handle, that value will be 0; if not,
  it will be the exit value of R2 from whichever of the SWIs
  PRISM_AllocateHandle or PRISM_ForgetHandle was most recently called. In R3
  on entry, the module passes the associated value that is to be stored in the
  array; usually this is a pointer to that module's session related data. This
  must NOT be zero.

  When a module has obtained the base of the array, it simply uses any given
  16-bit handle value as an index into this array. For example:

    unsigned int * array_values = r->r[2];
    void         * associated   = array_values[some_local_handle];

  It is recommended, however, that the exit value of R3 is used to ensure that
  a given handle is within range (between 1 and the value of R3 inclusive).
  Array entries with a value of zero stored in them are taken by PRISM to be
  unused and available for re-use later. Modules may take advantage of this
  to further validate handle values.

  Should a module know there is a limit on the number of handles it should
  allocate - for example, handles related to claimed pieces of hardware, and
  that hardware only supports 'n' claimants - it can specify on entry how many
  handles are allowed through R4. This is the highest valid handle number that
  may be allocated. So, if a module were to only allow one session, this would
  be 1.

  On exit, R1 contains the local handle value that has been allocated. R2
  should be used as the new array base pointer. R3 may be used to range
  check handle values when encountered at a future time.

  Note that handle values are from 1 to a maximum of 65535. The array does
  include an entry 0, which is NOT to be used by client modules. This avoids
  having to subtract one from a handle when using it as an array index. In
  practice, PRISM uses entry 0 to store the caller's PRISM ID, and validates
  the array base pointer against this entry on future calls.

  When a module no longer requires a handle value, it MUST tell the PRISM
  module about it by calling SWI PRISM_ForgetHandle.

  When a module deregisters from PRISM, any handles array allocated for it
  will be automatically deleted.

  Possible errors:

    PRISM could not claim enough memory
    Invalid handles array base pointer
    Cannot associate a value of zero in a handles array
    All available handles are in use
    Invalid parameters

  The last three are followed by an 8 digit upper case hex number in
  parentheses, which is the PRISM ID of the caller.



PRISM_ForgetHandle

  R0 = Flags (0)
  R1 = PRISM ID
  R2 = Pointer to base of this module's array
  R3 = Handle (1-65535)

  R0 = Exit flags (0)
  R1 = Preserved
  R2 = Updated to point to base of this module's array (which may have moved);
       0 if the array is empty and has been discarded.
  R3 = Highest valid handle number (which may have changed)

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  When a module has obtained a 16-bit handle value through calling SWI
  PRISM_AllocateHandle, it MUST call this SWI when it no longer has any use
  for the handle. PRISM will set the associated value to zero having validated
  the base pointer and handle value and allow this handle number to be re-used
  in future. If the value is at the top of the array, PRISM will alter the
  value of R3 on exit accordingly. Since PRISM may decide to shrink the block
  of memory in which the array is held, R2 on exit may be updated to a new
  base pointer. If PRISM decides all handles have been released, it may
  completely delete the array, in which case R2 will be zero on exit.

  When a module deregisters from PRISM, any handles array allocated for it
  will be automatically deleted.

  Possible errors:

    Invalid handles array base pointer
    Handle not in use
    Invalid parameters


-- 
Andrew Hodgkinson, Senior Software Engineer
Pace Micro Technology plc                    Tel: +44 1223 518 560
645 Newmarket Road                           Fax: +44 1223 518 526
Cambridge, CB5 8PB, United Kingdom           WWW: http://www.pace.co.uk/