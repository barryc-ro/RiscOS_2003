PRISM module API                                          20-Mar-2002
================                                          ===========


* Client to PRISM module
  ----------------------

  These SWIs are currently reserved and should not be used.



* PRISM component to PRISM module
  -------------------------------

PRISM_ComponentRegister

  R0 = Flags (0)
  R1 = Component's SWI base
  R2 = Component's PRISM ID
  R3 = Component's version number * 100
  R4 = Pointer to NUL-terminated information string (50 bytes or less
       including terminator)

  R0 = Exit flags (0)

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Declares the availability of a PRISM component to the PRISM module. This will
  allow the component to be listed by *PRISMComponents and *PRISMStatus. This
  SWI must be called before other component-to-module SWIs may be called.

  Components should call this SWI on initialisation. If it fails with "No such
  SWI" (error &1E6) that failure should be kept silent. The component should
  wait for Service_PRISM_Core with reason code 0 (PRISMModuleStarted) and PRISM
  ID &01001000 (PRISM_PRISMID) and when seen, attept to register again.

  In the event that Service_PRISM_Core is seen with reason code 1
  (PRISMModuleDying) and PRISM ID &01001000 (PRISM_PRISMID) is seen, the
  component should note that the PRISM module has died and it is no longer
  registered. It should wait for the module to start (as described above) and
  register again.

  If a client request is made of a component when it is not registered with
  PRISM, and in order to successfully fulfil the request the PRISM module
  would be needed, it should raise error &819822 ("PRISM service unavailable",
  prism_ERROR_SERVICE_UNAVAILABLE).

  To be PRISM compliant, the module should itself issue Service_PRISM_Core /
  PRISMModuleStarted after initialisation (so after registering with PRISM) and
  should also raise Service_PRISM_Core / PRISMModuleDying when exitting, after
  deregistering with PRISM - see SWI PRISM_ComponentDeregister.

  Any item with an allocated PRISM ID is obliged to register with the PRISM
  module when it starts - this applies to all classes of modules, including
  even the PRISM module (it registers with itself on startup).

  Possible errors:

    "PRISM could not claim enough memory"
    "Invalid parameters (PRISM_ComponentRegister) in PRISM"
    "Component already registered with PRISM"



PRISM_ComponentDeregister

  R0 = Flags (0)
  R1 = Component's SWI base
  R2 = Component's PRISM ID

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Any module registered with PRISM should call this SWI to deregister when it
  is either about to exit or cannot continue to provide services to the PRISM
  system. Normally, this is done in a module finalisation handler before
  issuing Service_PRISM_Core / PRISMModuleDying.

  Possible errors:

    "PRISM ID not recognised in PRISM"



PRISM_ComponentOptions

  R0 = Flags (0)
  R1 = PRISM ID

  R0 = Exit flags (0)

  This SWI is currently reserved and should not be used.



PRISM_ComponentNotify

  R0 = Flags (0)
  R1 = PRISM ID

  R0 = Exit flags (0)

  This SWI is currently reserved and should not be used.



* Generically useful routines
  ---------------------------
                                                        PRISM_CreateVeneers
                                                               (SWI &5513C)

On entry
  R0 = flags
       bits 0-3 = callee type:
                  0 = conventional assembler module
                  1 = APCS module
                 (2 = ATPCS module, when such things exist)
                  3-15 reserved
       other bits reserved (0)
  R1 -> table of 8-byte entries
          structure of entries is as follows:
          +0  pointer to a function for which to create a veneer
          +4  number of words of stack used to pass arguments
                if veneer is to be designed for an APCS-32 compliant caller
              or -1
                if veneer is to be designed for a call in from the OS
  R2 = number of entries in table
  R3 = module workspace pointer (callee type 0)
    or module private word pointer (callee type 1)
  R4 = PRISM ID (or 0 if not part of the PRISM system)

On exit
  R0 = exit flags (currently zero)
  R1 -> veneer struct
  Other registers are preserved
  Flags are corrupted

Interrupts
  Interrupt status is not altered

Processor mode
  Processor is in SVC mode

Re-entrancy
  SWI is not re-entrant

Use
  This SWI makes it easy to write PRISM components that allow direct calling
  between modules; specifically it deals with changing the statics scope in
  the absence of any address in stream handles from which we could otherwise
  locate statics. There is no such problem with SWI interfaces because the
  kernel always sets up R12 for the module, and in the case of C modules, cmhg
  does the rest of the work for us.
  
  Two types of callees are currently supported.
  
  Type 0 callee conditions:
  
    On entry:
      R0-R3 and stack contain arguments as per APCS
      R10 -> stack limit of current stack chunk
      R12 = module workspace pointer
      R13 -> full descending stack
      R14 = return address
    
    On exit:
      R0-R3 contain result or may be corrupted
      R12,R14 may be corrupted
      all other registers must be preserved
      flags may be corrupted
  
  Type 1 callee conditions:
  
    On entry
      R0-R3 and stack contain arguments as per APCS
      R10 -> stack limit of current stack chunk
      R11 = 0
      R13 -> full descending stack
      R14 = return address
      static relocation offsets are set up
    
    On exit
      R0-R3 contain result or may be corrupted
      R12,R14 may be corrupted
      all other registers must be preserved
      flags may be corrupted
  
  R10 is provided to type 0 callees primarily to make it easy for them to
  subsequently call other PRISM routines (note that you cannot assume that
  you are in SVC mode and therefore obtain the stack limit from the stack
  pointer).
  
  Two types of caller are currently supported (indicated by the second word
  in each entry pointed to by R1 on entry).
  
  APCS-32 caller conditions:
  
    On entry:
      R0-R3 and stack contain arguments as per APCS
      R10 -> stack limit of current stack chunk
      R13 -> full descending stack
      R14 = return address
    
    On exit
      R0-R3 contain result or may be corrupted
      R12,R14 are corrupted
      all other registers are preserved
      flags are corrupted
      static relocation offsets are preserved
  
  OS caller conditions:
    
    On entry:
      R12 = argument
      R13 -> full descending stack
      R14 = return address
      SVC or IRQ mode
    
    On exit
      V set and R0 -> error block
      or V clear and R0 preserved
      C flag preserved, NZ flags corrupted
      R12,R14 are corrupted
      all other registers are preserved
      static relocation offsets at base of SVC stack are preserved
  
  Note that the caller cannot be APCS-R. This is a deliberate simplification,
  because any entry point must be capable of being entered in a 32-bit mode,
  and mode-neutral flag preservation code is an undesirable overhead.
  
  The aim, when the caller is APCS compliant, is to provide a thinner veneer
  than a cmhg generic-veneer would provide - the callee is entered in the
  caller's processor mode (it must be able to handle being entered in SVC26,
  SVC32 or SYS32 modes), and both see conventional APCS/ATPCS arguments (four
  words in R0-R3, other arguments on the stack etc) so we are free to pass
  floating point values, structs etc between components with the minimum of
  fuss.
  
  In the case of OS-called routines, the callee is entered in SVC mode,
  irrespective of the caller's mode. We gain a benefit over cmhg
  generic-veneers in that the value passed in R12 is available for us to assign
  our own meaning to; it is no longer needed to convey statics scope, and could
  instead be used, for example, as a stream handle. The callee function
  prototype is as follows (although the parameter can be of any 32-bit type you
  choose):
  
    _kernel_oserror *callee(void *argument);
  
  The veneer struct returned in R1 from this SWI is quad-word aligned; it is
  allocated by PRISM, and its public interface should be considered as a set of
  function entry points at 16-byte intervals.

Related SWIs
  PRISM_FreeVeneers

Related vectors
  None



                                                          PRISM_FreeVeneers
                                                               (SWI &5513D)

On entry
  R0 = flags (reserved, currently should be zero)
  R1 -> veneer struct to free
  R2 = PRISM ID (must match ID when veneers were created)

On exit
  R0 = exit flags (currently zero)
  Other registers are preserved
  Flags are corrupted

Interrupts
  Interrupt status is not altered

Processor mode
  Processor is in SVC mode

Re-entrancy
  SWI is not re-entrant

Use
  This SWI frees the veneer struct when no longer required.

Related SWIs
  PRISM_CreateVeneers

Related vectors
  None



PRISM_AllocateHandle

  R0 = Flags (0)
  R1 = PRISM ID
  R2 = Pointer to base of this module's array, or 0 if none exists presently
  R3 = Non-zero value to associate with the handle PRISM will allocate
  R4 = Highest handle number allowed, or 0 for default of 65535

  R0 = Exit flags (0)
  R1 = Local handle to use
  R2 = Updated to point to base of this module's array (which may have moved)
  R3 = Highest valid handle number

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  Since client IDs and local IDs within the PRISM system are 16-bit quantities
  to allow streams of data to be described by a value capable of fitting in a
  single 32-bit processor register, it is not possible to use handles for
  sessions which are in fact pointers to local data structures. This does in
  fact hold some advantages but leads to a requirement to rapidly associate
  the handle with real session-related data. To this end, the most obvious
  solution would be an array of pointers to session data with the 16-bit value
  serving as an index into this array.

  Rather than have individual components within the PRISM system each include
  their own duplicated pieces of array management, the PRISM module provides a
  central service for associating a given value with a 16-bit handle that may
  be used as local or client handle as required. The PRISM_AllocateHandle SWI
  serves this purpose.

  Modules calling PRISM_AllocateHandle pass their PRISM ID in R1 on entry.
  This is used for safety checking as described later. In R2 on entry, the
  module passes a pointer to the base of the array. If this is the first time
  the module has ever asked PRISM for a handle, that value will be 0; if not,
  it will be the exit value of R2 from whichever of the SWIs
  PRISM_AllocateHandle or PRISM_ForgetHandle was most recently called. In R3
  on entry, the module passes the associated value that is to be stored in the
  array; usually this is a pointer to that module's session related data. This
  must NOT be zero.

  When a module has obtained the base of the array, it simply uses any given
  16-bit handle value as an index into this array. For example:

    unsigned int * array_values = r->r[2];
    void         * associated   = array_values[some_local_handle];

  It is recommended, however, that the exit value of R3 is used to ensure that
  a given handle is within range (between 1 and the value of R3 inclusive).
  Array entries with a value of zero stored in them are taken by PRISM to be
  unused and available for re-use later. Modules may take advantage of this
  to further validate handle values.

  Should a module know there is a limit on the number of handles it should
  allocate - for example, handles related to claimed pieces of hardware, and
  that hardware only supports 'n' claimants - it can specify on entry how many
  handles are allowed through R4. This is the highest valid handle number that
  may be allocated. So, if a module were to only allow one session, this would
  be 1.

  On exit, R1 contains the local handle value that has been allocated. R2
  should be used as the new array base pointer. R3 may be used to range
  check handle values when encountered at a future time.

  Note that handle values are from 1 to a maximum of 65535. The array does
  include an entry 0, which is NOT to be used by client modules. This avoids
  having to subtract one from a handle when using it as an array index. In
  practice, PRISM uses entry 0 to store the caller's PRISM ID, and validates
  the array base pointer against this entry on future calls.

  When a module no longer requires a handle value, it MUST tell the PRISM
  module about it by calling SWI PRISM_ForgetHandle.

  When a module deregisters from PRISM, any handles array allocated for it
  will be automatically deleted.

  Possible errors:

    PRISM could not claim enough memory
    Invalid handles array base pointer
    Cannot associate a value of zero in a handles array
    All available handles are in use
    Invalid parameters

  The last three are followed by an 8 digit upper case hex number in
  parentheses, which is the PRISM ID of the caller.



PRISM_ForgetHandle

  R0 = Flags (0)
  R1 = PRISM ID
  R2 = Pointer to base of this module's array
  R3 = Handle (1-65535)

  R0 = Exit flags (0)
  R1 = Preserved
  R2 = Updated to point to base of this module's array (which may have moved);
       0 if the array is empty and has been discarded.
  R3 = Highest valid handle number (which may have changed)

  All other registers preserved
  Interrupt state is undefined
  SWI is not re-entrant

  When a module has obtained a 16-bit handle value through calling SWI
  PRISM_AllocateHandle, it MUST call this SWI when it no longer has any use
  for the handle. PRISM will set the associated value to zero having validated
  the base pointer and handle value and allow this handle number to be re-used
  in future. If the value is at the top of the array, PRISM will alter the
  value of R3 on exit accordingly. Since PRISM may decide to shrink the block
  of memory in which the array is held, R2 on exit may be updated to a new
  base pointer. If PRISM decides all handles have been released, it may
  completely delete the array, in which case R2 will be zero on exit.

  When a module deregisters from PRISM, any handles array allocated for it
  will be automatically deleted.

  Possible errors:

    Invalid handles array base pointer
    Handle not in use
    Invalid parameters


-- 
Andrew Hodgkinson, Senior Software Engineer
Pace Micro Technology plc                    Tel: +44 1223 518 560
645 Newmarket Road                           Fax: +44 1223 518 526
Cambridge, CB5 8PB, United Kingdom           WWW: http://www.pace.co.uk/

Ben Avison, Senior Software Engineer
Pace Micro Technology plc                    Tel: +44 1223 518 562
645 Newmarket Road                           Fax: +44 1223 518 526
Cambridge, CB5 8PB, United Kingdom           WWW: http://www.pace.co.uk/
