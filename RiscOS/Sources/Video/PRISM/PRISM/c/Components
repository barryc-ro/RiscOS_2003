/**************************************************************/
/* File:    Components.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Manage component lists.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 21-Jun-2001 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include <kernel.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "PRISM.h"

#include "Lists.h"
#include "PRISMErr.h"
#include "Utils.h"

#include "Components.h"

/* Local variables */

static component * component_list = NULL;

/* Local functions */

static _kernel_oserror * components_print_subset  (unsigned int mask, unsigned int match, const char * t1, const char * t2);
static const char      * components_return_status (const component * compo);

/**************************************************************/
/* components_print_list()                                    */
/*                                                            */
/* Print a list of currently registered components, as for    */
/* "*PRISMComponents".                                        */
/**************************************************************/

_kernel_oserror * components_print_list(void)
{
  _kernel_oserror * e;
  const char      * buffer = NULL;
  size_t            len;

  if (component_list == NULL)
  {
    e = read_message("PCo00", &buffer, &len);

    if (e != NULL)
    {
      return e;
    }

    /* Print it - length-limit as we're using MessageTrans_Lookup */
    /* (albeit indirectly) in its "give us the buffer" mode, so   */
    /* the string is terminated by char 10 rather than NUL.       */

    printf("%.*s\n", len, buffer);
  }
  else
  {
    /* Get the header "PRISM ID  SWI base" etc. */

    e = read_message("PCo01", &buffer, &len);

    if (e != NULL)
    {
      return e;
    }
    else
    {
      const component * compo;

      printf("%.*s\n", len, buffer);

      /* Print 79 '=' signs (pre-assumes an 80 column or wider display) */

      for (len = 0; len < 9; ++len)
      {
        printf("========");
      }

      printf("=======\n");

      for (compo = component_list; compo; compo = compo->next)
      {
        printf("&%08X  &%5X     %01d.%02d   %s\n",
               compo->prism_id,
               compo->swi_base,
               compo->version / 100,
               compo->version % 100,
               compo->info);
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* components_return_status()                                 */
/*                                                            */
/* Return the status of a given component.                    */
/*                                                            */
/* Parameters: Pointer to the relevant component structure.   */
/*                                                            */
/* Returns:    Pointer to a MessageTrans token to look up for */
/*             the relevant status string.                    */
/**************************************************************/

const char * components_return_status(const component * compo)
{
  component * find  = component_list;
  bool        found = false;

  /* Are there zeros where none are expected? */

  if (
       (compo->prism_id & 0x00fff000) == 0 ||
       (compo->prism_id & 0xff000000) == 0
     )
     return "PStS4"; /* "Unknown" */

  /* Is this a protocol module? */

  if ((compo->prism_id & 0xfff) != 0)
  {
    unsigned int parent_id = compo->prism_id & 0xfffff000;

    while (find != NULL)
    {
      if (find->prism_id == parent_id)
      {
        found = true;
        break;
      }

      find = find->next;
    }

    if (found == false) return "PStS3"; /* "Asleep" */
  }

  /* Since there is no concept of active yet, return "Idle" */

  return compo->clients == 0 ? "PStS1" /* "Idle" */ : "PStS2" /* "Active" */; 
}

/**************************************************************/
/* components_print_subset()                                  */
/*                                                            */
/* Print a subset of the component list in a space format     */
/* appropriate for "*PRISMStatus".                            */
/*                                                            */
/* Parameters: Mask to apply to PRISM ID of each component;   */
/*                                                            */
/*             Value to match after masking in order to print */
/*             this item;                                     */
/*                                                            */
/*             Messages token for string to print before the  */
/*             list is shown;                                 */
/*                                                            */
/*             Messages token for string to print if nothing  */
/*             is found given the mask and match numbers.     */
/**************************************************************/

static _kernel_oserror * components_print_subset(unsigned int mask, unsigned int match, const char * t1, const char * t2)
{
  bool              found  = false;
  const component * compo;
  const char      * buffer = NULL;
  size_t            len;
  char              local[12];

  /* Show the heading */

  RetError(read_message(t1, &buffer, &len));
  printf("%.*s\n\n", len, buffer);

  /* List the required subset */

  found = false;

  for (compo = component_list; compo; compo = compo->next)
  {
    if ((compo->prism_id & mask) == match)
    {
      if (found == false)
      {
        /* Get the header "PRISM ID  SWI base" etc. */

        buffer = NULL;
        RetError(read_message("PSt01", &buffer, &len));
        printf("%.*s\n", len, buffer);

        /* Print 79 '=' signs (pre-assumes an 80 column or wider display) */

        for (len = 0; len < 9; ++len) printf("========");
        printf("=======\n");

        found = true;
      }

      buffer = NULL;
      RetError(read_message(components_return_status(compo), &buffer, &len));

      if (len > sizeof(local) - 1) len = sizeof(local) - 1;
      strncpy(local, buffer, len);
      local[len] = '\0';

      printf("&%08X  %-11s  %03d  %s\n",
             compo->prism_id,
             local,
             compo->clients,
             compo->info);
    }
  }

  /* None found? Complain */

  if (found == false)
  {
    buffer = NULL;
    RetError(read_message(t2, &buffer, &len));
    printf("%.*s\n", len, buffer);
  }

  return NULL;
}

/**************************************************************/
/* components_print_status()                                  */
/*                                                            */
/* Print a list of currently registered components and their  */
/* current status, as for "*PRISMStatus".                     */
/**************************************************************/

_kernel_oserror * components_print_status(void)
{
  const char * buffer = NULL;
  size_t       len;

  if (component_list == NULL)
  {
    RetError(read_message("PCo00", &buffer, &len));

    /* Print it - length-limit as we're using MessageTrans_Lookup */
    /* (albeit indirectly) in its "give us the buffer" mode, so   */
    /* the string is terminated by char 10 rather than NUL.       */

    printf("%.*s\n", len, buffer);
  }
  else
  {
    /* Show each section */

    RetError(components_print_subset(0xff000000, PRISM_Class_PFC, "PStPFC", "PStPF0")); printf("\n");
    RetError(components_print_subset(0xff000000, PRISM_Class_SI,  "PStSI",  "PStS0" )); printf("\n");
    RetError(components_print_subset(0xff000000, PRISM_Class_PTL, "PStPTL", "PStPT0"));
  }

  return NULL;
}

/**************************************************************/
/* components_find_by_id()                                    */
/*                                                            */
/* Find a registered component by its PRISM ID.               */
/*                                                            */
/* Parameters: ID to find.                                    */
/*                                                            */
/* Returns:    Pointer to the relevant component structure,   */
/*             or NULL if not found.                          */
/**************************************************************/

component * components_find_by_id(unsigned int id)
{
  component * c = component_list;

  dprintf(("Components",
           "components_find_by_id: Called for ID &%08X\n", id));

  while (c != NULL)
  {
    if (c->prism_id == id)
    {
      dprintf(("Components",
               "components_find_by_id: Successful, returning &%08X\n", (int) c));

      return c;
    }

    c = c->next;
  }

  dprintf(("Components",
           "Could not find the ID, returning NULL\n"));

  return NULL;
}

/**************************************************************/
/* components_component_register()                            */
/*                                                            */
/* Handle the PRISM_ComponentRegister SWI.                    */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

_kernel_oserror * components_component_register(_kernel_swi_regs * r)
{
  component * added;

  dprintf(("Components",
           "components_component_register: Called (&%08X, &%08X, %01d.%02d, '%s')\n",
           r->r[1],
           r->r[2],
           r->r[3] / 100,
           r->r[3] % 100,
           r->r[4] != 0 ? (char *) r->r[4] : "<NULL>"));

  if (r->r[4] == 0)
  {
    return make_error(prism_ERROR_INVALID_PARAMETERS,
                      1,
                      "PRISM_ComponentRegister");
  }

  if (components_find_by_id(r->r[2])) return make_error(prism_ERROR_COMPONENT_ALREADY_PRESENT, 0);

  if (r->r[2] == PRISM_PRISMID)
  {
    RetError(lists_add_to_head((void **) &component_list, sizeof(component)));

    added = component_list;
  }
  else
  {
    component * find = component_list;

    while (find != NULL)
    {
      if (find->prism_id < r->r[2]) find = find->next;
      else break;
    }

    RetError(lists_add_at_given((void **) &component_list, (void *) &added, (void *) find, sizeof(component)));
  }

  added->prism_id = r->r[2];
  added->version  = r->r[3];
  added->swi_base = r->r[1];
  added->flags    = 0;

  StrNCpy0(added->info, (char *) r->r[4]);

  /* On entry... */

  r->r[0] = 0;

  dprintf(("Components",
           "components_component_register: Successful\n"));

  return NULL;
}

/**************************************************************/
/* components_component_deregister()                          */
/*                                                            */
/* Handle the PRISM_ComponentDeregister SWI.                  */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

_kernel_oserror * components_component_deregister(_kernel_swi_regs * r)
{
  component * c;

  dprintf(("Components",
           "components_component_deregister: Called (&%08X, &%08X)\n",
           r->r[1],
           r->r[2]));

  c = components_find_by_id(r->r[2]);

  if (c == NULL) return make_error(prism_ERROR_PRISM_ID_NOT_KNOWN, 0);

  /* On entry... */

  r->r[0] = 0;

  dprintf(("Components",
           "components_component_deregister: Exitting through lists_remove()\n"));

  return lists_remove((void **) &component_list, (void *) c);
}

/**************************************************************/
/* components_shutdown()                                      */
/*                                                            */
/* Shut down the component registry.                          */
/**************************************************************/

void components_shutdown(void)
{
  dprintf(("Components",
           "components_shutdown: Called\n"));

  lists_remove_all((void **) &component_list);

  dprintf(("Components",
           "components_shutdown: Successful\n"));
}
