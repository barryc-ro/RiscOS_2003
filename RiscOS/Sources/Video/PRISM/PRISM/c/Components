/**************************************************************/
/* File:    Components.c                                      */
/*          (C) 2000 Pace Micro Technology PLC                */
/*          All rights reserved                               */
/*                                                            */
/* Purpose: Manage component lists.                           */
/*                                                            */
/* Author:  A.D.Hodgkinson.                                   */
/*                                                            */
/* History: 21-Jun-2001 (ADH): Created.                       */
/**************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#ifdef TRACE2
  #define TRACE
#endif
#ifdef TRACE
  #define DEBUGLIB
#endif
#include <debuglib/debuglib.h>

#include "PRISM.h"

#include "Lists.h"
#include "Utils.h"

#include "Components.h"

/* Local variables */

static component * component_list = NULL;

/* Local functions */

static component * components_find_by_id (unsigned int id);

/**************************************************************/
/* components_print_list()                                    */
/*                                                            */
/* Print a list of currently registered components, as for    */
/* "*PRISMComponents".                                        */
/**************************************************************/

_kernel_oserror * components_print_list(void)
{
  _kernel_oserror * e;
  const char      * buffer = NULL;
  size_t            len;

  if (component_list == NULL)
  {
    e = read_message("PCo00", &buffer, &len);

    if (e != NULL)
    {
      return e;
    }

    /* Print it - length-limit as we're using MessageTrans_Lookup */
    /* (albeit indirectly) in its "give us the buffer" mode, so   */
    /* the string is terminated by char 10 rather than NUL.       */

    printf("%.*s\n", len, buffer);
  }
  else
  {
    /* Get the header "PRISM ID  SWI base" etc. */

    e = read_message("PCo01", &buffer, &len);

    if (e != NULL)
    {
      return e;
    }
    else
    {
      const component * compo;

      printf("%.*s\n", len, buffer);

      /* Print 79 '=' signs (pre-assumes an 80 column or wider display) */

      for (len = 0; len < 9; ++len)
      {
        printf("========");
      }

      printf("=======\n");

      for (compo = component_list; compo; compo = compo->next)
      {
        printf("&%08X  &%5X     %01d.%02d   %s\n",
               compo->prism_id,
               compo->swi_base,
               compo->version / 100,
               compo->version % 100,
               compo->info);
      }
    }
  }

  return NULL;
}

/**************************************************************/
/* components_find_by_id()                                    */
/*                                                            */
/* Find a registered component by its PRISM ID.               */
/*                                                            */
/* Parameters: ID to find.                                    */
/*                                                            */
/* Returns:    Pointer to the relevant component structure,   */
/*             or NULL if not found.                          */
/**************************************************************/

static component * components_find_by_id(unsigned int id)
{
  component * c = component_list;

  dprintf(("Components",
           "components_find_by_id: Called for ID &%08X\n", id));



  while (c != NULL)
  {
    if (c->prism_id == id)
    {
      dprintf(("Components",
               "components_find_by_id: Successful, returning &%08X\n", (int) c));

      return c;
    }

    c = c->next;
  }

  dprintf(("Components",
           "Could not find the ID, returning NULL\n"));

  return NULL;
}

/**************************************************************/
/* components_component_register()                            */
/*                                                            */
/* Handle the PRISM_ComponentRegister SWI.                    */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

_kernel_oserror * components_component_register(_kernel_swi_regs * r)
{
  component * added;

  dprintf(("Components",
           "components_component_register: Called (&%08X, &%08X, %01d.%02d, '%s')\n",
           r->r[1],
           r->r[2],
           r->r[3] / 100,
           r->r[3] % 100,
           r->r[4] != 0 ? (char *) r->r[4] : "<NULL>"));

  if (r->r[4] == 0)
  {
    return make_error(prism_ERROR_INVALID_PARAMETERS,
                      1,
                      "PRISM_ComponentRegister");
  }

  if (components_find_by_id(r->r[2])) return make_error(prism_ERROR_COMPONENT_ALREADY_PRESENT, 0);

  if (r->r[2] == PRISM_PRISMID)
  {
    RetError(lists_add_to_head((void **) &component_list, sizeof(component)));

    added = component_list;
  }
  else
  {
    RetError(lists_add_to_tail((void **) &component_list, (void *) &added, sizeof(component)));
  }

  added->prism_id = r->r[2];
  added->version  = r->r[3];
  added->swi_base = r->r[1];
  added->flags    = 0;

  StrNCpy0(added->info, (char *) r->r[4]);

  dprintf(("Components",
           "components_component_register: Successful\n"));

  return NULL;
}

/**************************************************************/
/* components_component_deregister()                          */
/*                                                            */
/* Handle the PRISM_ComponentDeregister SWI.                  */
/*                                                            */
/* Parameters: Pointer to register block.                     */
/**************************************************************/

_kernel_oserror * components_component_deregister(_kernel_swi_regs * r)
{
  component * c = components_find_by_id(r->r[2]);

  dprintf(("Components",
           "components_component_deregister: Called (&%08X, &%08X)\n",
           r->r[1],
           r->r[2]));

  if      (c == NULL)              return make_error(prism_ERROR_PRISM_ID_NOT_KNOWN,     0);
  else if (c->swi_base != r->r[1]) return make_error(prism_ERROR_COMPONENT_SWI_ID_CLASH, 0);

  dprintf(("Components",
           "components_component_deregister: Exitting through lists_remove()\n"));

  return lists_remove((void **) &component_list, (void *) c);
}

/**************************************************************/
/* components_shutdown()                                      */
/*                                                            */
/* Shut down the component registry.                          */
/**************************************************************/

void components_shutdown(void)
{
  dprintf(("Components",
           "components_shutdown: Called\n"));

  lists_remove_all((void **) &component_list);

  dprintf(("Components",
           "components_shutdown: Successful\n"));
}
