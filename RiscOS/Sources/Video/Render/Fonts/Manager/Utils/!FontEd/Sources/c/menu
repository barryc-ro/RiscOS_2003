/*  Title: > c.menu
 */

#include "h.includes"
#include "h.wlink"
#include "h.misc"

#include "h.menu"
#include "h.drag"
#include "h.editchar"
#include "h.loadsave"
#include "h.main"
#include "h.redraw"
#include "h.scaffold"
#include "h.sprites"
#include "h.suspend"
#include "h.thicken"


/* ---- Global variables -----------------------------------------------------*/


int globalmag_up = 1;
int globalmag_down = 1;
char globalmag_variable = 1;


/* ---- Local functions ----------------------------------------------------- */

#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)

static os_error *redisplayfont(Font_Block *thisfont, BOOL childrentoo, os_error * (*subr)(Char_Block *charptr));
static os_error *rescalechar(Char_Block *charptr);
static os_error *alter_fontname(Font_Block *font, const char *fontname);
static os_error *alter_designsize(Font_Block *font, int designsize);
static os_error *alter_skeleton(Font_Block *font, int threshold);
static BOOL drawskels(Font_Block *font, int threshold);
os_error * alter_version(Font_Block *thisfont, int newversion, int nchars);

static os_error *remake1bpp(Char_Block *charptr);

static os_error *writeable_updated(wimp_w w, wimp_i i, char *buffer);

static os_error * decodescaffold(int * menus);
static os_error *unscaffold(Wind_Link *wlink);
static int unscaffoldpoint(Pt_Block *pt);

int movex, movey;
BOOL moveflag;
os_error *movepoints(Wind_Link *wlink);
int movepoint(Pt_Block *pt);

void redrawskels(void);

os_error * copy_a_path(Char_Block *charptr);
os_error * delete_a_path(Char_Block *charptr);
int findselected(Line_Block *line);


/* ---- Menus ------------------------------------------------------------- */


menustr(6) menu_Skeleton_Scaffold1 =
{
  menu("", 10),
  item("H-scaffold", NULL),
  item("U-tangent", NULL),
  item("D-tangent", NULL),
  item("V-scaffold", NULL),
  item("L-tangent", NULL),
  iteX("R-tangent", NULL)
};

menustr(6) menu_Skeleton_Scaffold2 =
{
  menu("", 10),
  item("H-scaffold", NULL),
  item("U-tangent", NULL),
  item("D-tangent", NULL),
  item("V-scaffold", NULL),
  item("L-tangent", NULL),
  iteX("R-tangent", NULL)
};

menustr(6) menu_Skeleton_Scaffold3 =
{
  menu("", 10),
  item("H-scaffold", NULL),
  item("U-tangent", NULL),
  item("D-tangent", NULL),
  item("V-scaffold", NULL),
  item("L-tangent", NULL),
  iteX("R-tangent", NULL)
};

menustr(5) menu_Skeleton_Scaffold =
{
  menu("Scaffold", 10),
  item("New local", &menu_Skeleton_Scaffold1),
  item("New global", &menu_Skeleton_Scaffold2),
  item("Replace", &menu_Skeleton_Scaffold3),
  item("Undelete", NULL),
  iteX("Disconnect", NULL)
};

menustr(9) menu_Skeleton_Display =
{
  menu("Display",10),
  item("Pointer",  NULL),
  item("Coords",   NULL),
  item("Width",    NULL),
  item("Char BBox",NULL),
  item("Orig BBox",NULL),
  item("Font BBox",NULL),
  item("Bitmap",   NULL),
  item("Handles",  NULL),
  iteX("End points", NULL)
};

char mb_skeleton_width[5];
static char mv_digits[] = "a0-9";
static char mv_digitsplusminus[] = "a0-9\\+\\-";

menustr2(1) menu_Skeleton_Width =
{
  menu("1/1000 em", 6),
  wimp_MLAST | wimp_MWRITABLE,
  NULL,
  ICONFLAGS(wimp_ITEXT | wimp_INDIRECT | wimp_IRJUST, 7, 0),
  mb_skeleton_width,
  mv_digits,
  sizeof(mb_skeleton_width)
};

menustr(7) menu_Skeleton =
{
  menu("Skel", 10),
  item("Delete", NULL),
  item("Straighten", NULL),
  item("Scaffold", &menu_Skeleton_Scaffold),
  item("Display", &menu_Skeleton_Display),
  item("Full char",  NULL),
  item("Width", &menu_Skeleton_Width),
  iteX("Zoom", NULL)
};

char mb_flatness[5];

menustr2(1) menu_Bitmap_Flatness =
{
  menu("Flatness", 5),
    wimp_MLAST | wimp_MWRITABLE,
    NULL,
    ICONFLAGS(wimp_ITEXT | wimp_INDIRECT | wimp_IRJUST, 7, 0),
    mb_flatness, mv_digits, sizeof(mb_flatness)
};

menustr(4) menu_Bitmap =
{
  menu("Grid",10),
  item("Rectangles", NULL),      /* CHAR_GRIDEDGES   */
  item("Diamonds",   NULL),      /* CHAR_GRIDCENTRES */
  item("Flatness",   &menu_Bitmap_Flatness),
  iteX("Origin",     NULL)
};

menustr(2) menu_IconBar =
{
  menu("FontEd", 4),
  item("Info",NULL),
  iteX("Quit",NULL)
};

menustr(2) menu_FontIndex_Save =
{
  menu("Save", 8),
  item("Outlines", NULL),
  iteX("Metrics", NULL)
};

char mb_fontname[40];
char mv_fontname[] = "A~$&%@\\^:#*""| ";    /* font name is restricted */

menustr2(1) menu_FontIndex_Alter_Fontname =
{
  menu("Font name", 39),
    wimp_MLAST | wimp_MWRITABLE,
    NULL,
    ICONFLAGS(wimp_ITEXT | wimp_INDIRECT,7,0),
    mb_fontname, mv_fontname, sizeof(mb_fontname)
};

char mb_designsize[5];

menustr2(1) menu_FontIndex_Alter_Designsize =
{
  menu("Size", 4),
    wimp_MLAST | wimp_MWRITABLE,
    NULL,
    ICONFLAGS(wimp_ITEXT | wimp_INDIRECT | wimp_IRJUST, 7, 0),
    mb_designsize, mv_digits, sizeof(mb_designsize)
};

char mb_skeletonsize[4];

menustr2(1) menu_FontIndex_Alter_Skeleton =
{
  menu("Pixel size", 7),
    wimp_MLAST | wimp_MWRITABLE,
    NULL,
    ICONFLAGS(wimp_ITEXT | wimp_INDIRECT | wimp_IRJUST, 7, 0),
    mb_skeletonsize, mv_digits, sizeof(mb_skeletonsize)
};


char mb_thickness[4];

menustr2(1) menu_FontIndex_Alter_Thickness =
{
  menu("Change by:", 7),
    wimp_MLAST | wimp_MWRITABLE,
    NULL,
    ICONFLAGS(wimp_ITEXT | wimp_INDIRECT | wimp_IRJUST, 7, 0),
    mb_thickness, mv_digitsplusminus, sizeof(mb_thickness)
};

menustr(16) menu_FontIndex_Alter_Version_NChars =
{
  menu("File size", 9),
  item("288 chars", NULL),
  item("320 chars", NULL),
  item("352 chars", NULL),
  item("384 chars", NULL),
  item("416 chars", NULL),
  item("448 chars", NULL),
  item("480 chars", NULL),
  item("512 chars", NULL),
  item("544 chars", NULL),
  item("576 chars", NULL),
  item("608 chars", NULL),
  item("640 chars", NULL),
  item("672 chars", NULL),
  item("704 chars", NULL),
  item("736 chars", NULL),
  iteX("768 chars", NULL)
};

menustr(2) menu_FontIndex_Alter_Version_Flags =
{
  menu("File flags", 10),
  item("Monochrome", NULL),
  iteX("Non-zero",NULL)
};

menustr(4) menu_FontIndex_Alter_Version =
{
  menu("File format", 9),
  item("Version 6", NULL),
  item("Version 7", NULL),
  item("Version 8", &menu_FontIndex_Alter_Version_NChars),
  iteX("Flags", &menu_FontIndex_Alter_Version_Flags)
};

menustr(8) menu_FontIndex_Alter_Inheritance =
{
  menu("Inherited:", 7),
  item("Chunk 0", NULL),
  item("Chunk 1", NULL),
  item("Chunk 2", NULL),
  item("Chunk 3", NULL),
  item("Chunk 4", NULL),
  item("Chunk 5", NULL),
  item("Chunk 6", NULL),
  iteX("Chunk 7", NULL)
};

menustr(6) menu_FontIndex_Alter =
{
  menu("Alter", 11),
  item("Font name", &menu_FontIndex_Alter_Fontname),
  item("Design size", &menu_FontIndex_Alter_Designsize),
  item("Skeleton", &menu_FontIndex_Alter_Skeleton),
  item("Thickness", &menu_FontIndex_Alter_Thickness),
  item("Inheritance", &menu_FontIndex_Alter_Inheritance),
  iteX("Format", &menu_FontIndex_Alter_Version)
};

menustr(2) menu_FontIndex_Display =
{
  menu("Display", 11),
  item("Char names", NULL),
  iteX("Chunk 0", NULL)
};

menustr(7) menu_FontIndex =
{
  menu("Font", 11),
  item("Redisplay", NULL),
  item("Show tree", NULL),
  item("Alter", &menu_FontIndex_Alter),
  item("Display", &menu_FontIndex_Display),
  item("Save", &menu_FontIndex_Save),
  wimp_MSEPARATE, NULL, ICONFLAGS(wimp_ITEXT,7,0), "Make bitmap",
  iteX("Debug",NULL)
};

menustr(1) menu_FontIndex2 =
{
  menu("Font", 4),
  iteX("Save", NULL)
};


wimp_menuptr Menu_Skeleton_Display = (wimp_menuptr) &menu_Skeleton_Display;
wimp_menuptr Menu_Skeleton_Scaffold1 = (wimp_menuptr) &menu_Skeleton_Scaffold1;
wimp_menuptr Menu_Skeleton_Scaffold2 = (wimp_menuptr) &menu_Skeleton_Scaffold2;
wimp_menuptr Menu_Skeleton_Scaffold3 = (wimp_menuptr) &menu_Skeleton_Scaffold3;
wimp_menuptr Menu_Skeleton_Scaffold = (wimp_menuptr) &menu_Skeleton_Scaffold;
wimp_menuptr Menu_Skeleton = (wimp_menuptr) &menu_Skeleton;
wimp_menuptr Menu_Bitmap = (wimp_menuptr) &menu_Bitmap;
wimp_menuptr Menu_IconBar = (wimp_menuptr) &menu_IconBar;
wimp_menuptr Menu_FontIndex_Save = (wimp_menuptr) &menu_FontIndex_Save;
wimp_menuptr Menu_FontIndex_Alter_Fontname = (wimp_menuptr) &menu_FontIndex_Alter_Fontname;
wimp_menuptr Menu_FontIndex_Alter_Designsize = (wimp_menuptr) &menu_FontIndex_Alter_Designsize;
wimp_menuptr Menu_FontIndex_Alter_Skeleton = (wimp_menuptr) &menu_FontIndex_Alter_Skeleton;
wimp_menuptr Menu_FontIndex_Alter_Thickness = (wimp_menuptr) &menu_FontIndex_Alter_Thickness;
wimp_menuptr Menu_FontIndex_Alter_Inheritance = (wimp_menuptr) &menu_FontIndex_Alter_Inheritance;
wimp_menuptr Menu_FontIndex_Alter_Version_NChars = (wimp_menuptr) &menu_FontIndex_Alter_Version_NChars;
wimp_menuptr Menu_FontIndex_Alter_Version_Flags = (wimp_menuptr) &menu_FontIndex_Alter_Version_Flags;
wimp_menuptr Menu_FontIndex_Alter_Version = (wimp_menuptr) &menu_FontIndex_Alter_Version;
wimp_menuptr Menu_FontIndex_Alter = (wimp_menuptr) &menu_FontIndex_Alter;
wimp_menuptr Menu_FontIndex_Display = (wimp_menuptr) &menu_FontIndex_Display;
wimp_menuptr Menu_FontIndex = (wimp_menuptr) &menu_FontIndex;
wimp_menuptr Menu_FontIndex2 = (wimp_menuptr) &menu_FontIndex2;


/* ---- Menu encoding / decoding ------------------------------------------ */


os_error * create_menu(Wind_Link * wlink,wimp_mousestr * mouse)
{
  menuhandle = wlink;
  switch(wlink->type)
  {
    case W_FONTINDEX:
       { Font_Block *font = wlink->info;
         FFile_FontHdr *f = font->filedata;
         int i;

         strcpy(wricon_filename, font->filename);
         strcpy(mb_fontname, ((char *)f->table) + f->table[0]);
         sprintf(mb_designsize, "%d", f->designsize);
         sprintf(mb_skeletonsize, "%d", font->skeleton_threshold);
         sprintf(mb_thickness, "");

         tickitem(Menu_FontIndex_Alter_Version, 0, (f->version == 6));
         tickitem(Menu_FontIndex_Alter_Version, 1, (f->version == 7));
         tickitem(Menu_FontIndex_Alter_Version, 2, (f->version == 8));
         shadeitem(Menu_FontIndex_Alter_Version,3, (f->version < 8));

         for (i=0; i<16; i++) {
           tickitem(Menu_FontIndex_Alter_Version_NChars, i, nchunks(f)==i+9);
         }

         tickitem(Menu_FontIndex_Alter_Version_Flags, 0,
                  f->version >=8 && f->chunk.new.scaffoldflags & SCF_MONOCHROME);

         tickitem(Menu_FontIndex_Alter_Version_Flags, 1,
                  f->version >=8 && f->chunk.new.scaffoldflags & SCF_NONZERO);

         tickitem(Menu_FontIndex_Display, 0, font->display.charnames);
         tickitem(Menu_FontIndex_Display, 1, (font->grid.skip==0));

         if (f->bpp == 0) {
           int i;
           for (i=0; i<8; i++) {
             tickitem(Menu_FontIndex_Alter_Inheritance, i, inbasefile(font,i<<5));
           }
           strcpy(wricon_filename2, font->filename2);
           er(wimp_create_menu(Menu_FontIndex, mouse->x-80, mouse->y+16));  /* outlines */
         } else {
           shadeitem(Menu_FontIndex2,0,f->fontid != FONT_READY);
           er(wimp_create_menu(Menu_FontIndex2, mouse->x-56, mouse->y+16)); /* bitmaps */
         }
       }
       break;

    case W_SKELETON:
         er(editskel(wlink,mouse));
         break;

    case W_BITMAP:
         {
           Char_Block * charptr = wlink->info;

           tickitem(Menu_Bitmap, 0, (charptr->flags & CHAR_GRIDEDGES));
           tickitem(Menu_Bitmap, 1, (charptr->flags & CHAR_GRIDCENTRES));
           tickitem(Menu_Bitmap, 2, (charptr->flags & CHAR_FLATTENED));

           shadeitem(Menu_Bitmap,2,charptr->template==NULL);
           shadeitem(Menu_Bitmap,3,charptr->template==NULL);

           sprintf(mb_flatness,"%d",charptr->flatness);
           sprintf(mb_origin,"%d,%d",charptr->orgX,charptr->orgY);

           er(wimp_create_menu(Menu_Bitmap, mouse->x-80, mouse->y+16));
         }
         break;

    default:
         menuhandle = NULL;
  }
  return(NULL);
}


os_error * event_menu(int * menus)
{
  wimp_mousestr mouse;
  Wind_Link *wlink;

  er(wimp_get_point_info(&mouse));   /* save for later */

  if (menuhandle == NULL) {
    if (*menus == 1) {
      int numnotsaved = 0;
      for(wlink=Wind_Head.next; wlink; wlink=wlink->next) {
        if (wlink->type == W_FONTINDEX) numnotsaved++;
      }
      if (numnotsaved > 0) {
        char buffer[64];
        sprintf(buffer, "%d %s not saved - are you sure you want to quit?",
                numnotsaved, numnotsaved==1 ? "font" : "fonts");
        if (dboxquery(buffer) == 1) numnotsaved = 0;
      }
      if (!numnotsaved) { wimp_closedown(); cleanexit(0); }
    }
  } else switch(menuhandle->type)
  {
    case W_FONTINDEX:
         thisfont = (Font_Block *) menuhandle->info;
         if (thisfont->filedata->bpp == 0) {
           switch (*menus++)                            /* outline font menu */
           {
             case 0:
                  er(redisplayfont(thisfont, FALSE, NULL));   /* rescan characters */
                  break;
             case 1:
                  if ((wlink=findwindinfo(W_TREE, thisfont)) != NULL) {
                    handle = wlink->wind_handle;
                  } else {
                    er(wimp_create_wind(&t_tree.w, &handle));
                    er(addwindlink(handle, W_TREE, thisfont));
                    thisfont->treebox.x1 = 0;
                    thisfont->treebox.y0 = 0;    /* bound to cause a size reset */
                  }
                  er(front(handle));
                  break;
             case 2:                         /* alter parameters */
                  switch(*menus++) {
                    case 0: if (*menus==0) { er(alter_fontname(menuhandle->info, mb_fontname));
                                           } break;
                    case 1: if (*menus==0) { int t;
                                             sscanf(mb_designsize, "%d", &t);
                                             er(alter_designsize(menuhandle->info, t));
                                           } break;
                    case 2: if (*menus==0) { int t;
                                             sscanf(mb_skeletonsize, "%d", &t);
                                             er(alter_skeleton(menuhandle->info, t));
                                           } break;
                    case 3: if (*menus==0) { int t;
                                             sscanf(mb_thickness, "%d", &t);
                                             er(alter_thickness(menuhandle->info, t));
                                           } break;
                    case 4: if (*menus>=0) { er(alter_inheritance(menuhandle->info, *menus));
                                           } break;
                    case 5: switch(*menus++) {
                              case 0: er(alter_version(thisfont,6,256)); break;
                              case 1: er(alter_version(thisfont,7,256)); break;
                              case 2: er(alter_version(thisfont,8,*menus<0 ? -1 : 32*(*menus+9))); break;
                              case 3:        /* file flags */
                                     switch(*menus++) { 
                                       case 0: 
                                         thisfont->filedata->chunk.new.scaffoldflags ^= SCF_MONOCHROME; break;
                                       case 1: 
                                         thisfont->filedata->chunk.new.scaffoldflags ^= SCF_NONZERO; 
                                         er(redisplayfont(thisfont, TRUE, NULL)); break;
                                    } 
                                     break;
                            }
                  }
                  break;
             case 3:                         /* display */
                  switch(*menus++) {
                    case 0: { Wind_Link *wlink = findwindinfo(W_FONTINDEX, thisfont);
                              showcharnames =         /* remember for default next time */
                              thisfont->display.charnames = !thisfont->display.charnames;
                              invalidate(wlink->wind_handle, -big,-big,big,big);
                            }
                            break;
                    case 1: { Wind_Link *wlink = findwindinfo(W_FONTINDEX, thisfont);
                              thisfont->grid.skip = thisfont->grid.skip ? 0 : 32;
                              er(setextent(wlink));
                              invalidate(wlink->wind_handle, -big,-big,big,big);
                            }
                            break;
                    case 2: { thisfont->display.endpoints = !thisfont->display.endpoints;
                              er(redisplayfont(thisfont, TRUE, NULL));
                            }
                            break;    
                  }
                  break;
             case 4:                        /* save file */
                  switch(*menus++)          /* NB: use filename in font block, not the edited version */
                  {
                    case 0: er(savefilechk(thisfont, thisfont->filename, 0)); break;
                    case 1: er(savefilechk2(thisfont, thisfont->filename2, 0)); break;
                    case -1: er(savefilechk(thisfont, thisfont->filename, 0));
                                if (strcmp(thisfont->filename2, "IntMetrics") != 0)  /* don't bother if none */
                                  er(savefilechk2(thisfont, thisfont->filename2, 0));
                  }
                  break;
             case 6:
                  debugfont(thisfont);
                  break;
           } /* switch */
         } else {
           switch(*menus++)                  /* bitmap font menu */
           {
             case 0: er(savefilechk(thisfont, wricon_filename, 0));
           }
         }
         break;

    case W_SKELETON:
         er(getwlinkstate(menuhandle));

         switch(*menus++)
         {
           case 0: {
                     int i = thischar->parent->scaffold.index;
                     switch(scafftype(thischar))
                     {
                       case SEL_SCAFFOLDX:
                         er(
                           changescaffold(thischar, i, thischar->charno, NULL_SCAFFOLD, 0, 0, NULL);
                         );
                         break;
                       case SEL_SCAFFOLDY:
                         er(
                           changescaffold(thischar, i, thischar->charno, NULL_SCAFFOLD, 0, 0, NULL);
                         );
                         break;
                       default:
                         er(deleteline(&thischar->sline));
                     }
                   }
                   break;
           case 1: er(straighten(&thischar->sline)); break;
           case 2: er(decodescaffold(menus)); break;
           case 3: switch(*menus++)
                   {
                     case 0: showpointer = ~showpointer; break;
                     case 1: showcoords = ~showcoords;   break;
                     case 2: showwidth = ~showwidth; redrawskels(); break;
                     case 3: showbbox = ~showbbox; redrawskels(); break;
                     case 4: showobox = ~showobox; redrawskels(); break;
                     case 5: showfbox = ~showfbox; redrawskels(); break;
                     case 6: showsprites = ~showsprites; redrawskels(); break;
                     case 7: showhandles = ~showhandles; redrawskels(); break;
                     case 8: showendpoints = ~showendpoints; redrawskels(); break;
                   }
                   break;
           case 4: er(open_char(W_FULL,menuhandle->info));
                   break;
           case 5: switch(*menus++)
                   { case 0: sscanf(mb_skeleton_width,"%d",&thischar->xwidth);
                               if (showwidth) invalidate(menuhandle->wind_handle, -big,-big,big,big);
                   }
         }
         break;

    case W_BITMAP:
         {
           Char_Block * charptr = (Char_Block *)menuhandle->info;

           switch(*menus++)
           {
             case 0: charptr->flags = charptr->flags ^ CHAR_GRIDEDGES;
                     break;

             case 1: charptr->flags = charptr->flags ^ CHAR_GRIDCENTRES;
                     break;

             case 2: if (*menus == -1)
                     {
                       charptr->flags = charptr->flags ^ CHAR_FLATTENED;
                     }
                     else
                     {
                       charptr->flags = charptr->flags | CHAR_FLATTENED;
                       sscanf(mb_flatness,"%d",&charptr->flatness);
                     }
                     er(remake1bpp(charptr));         /* recompute from outline */
                     break;

             default: menuhandle=NULL;
                      return(NULL);
           }
           charflags = orrin(charflags,charptr->flags,CHAR_GRID);
           invalidate(menuhandle->wind_handle,-big,-big,big,big);
         }
  }

  mytracef("menu exit: menuhandle = &%X\n",menuhandle);

  if (menuhandle != NULL && (mouse.bbits & wimp_BRIGHT)) {
       mouse.bbits = wimp_BMID;          /* for skeleton menu creation */
       return(create_menu(menuhandle,&mouse));
  } else {
       menuhandle = NULL;
       return(NULL);
  }
}


os_error * alter_version(Font_Block *thisfont, int version, int nchars)
{
  Wind_Link *wlink;
  int n1, n2;
  FFile_FontHdr *f = thisfont->filedata;

  f->version = version;
  er(grungefiledata(&thisfont->filedata));

  if (nchars>=0) {
    if (nchunks(f) != nchars/32) er(changenchunks(&thisfont->filedata, nchars/32));
    n1 = 32*nchunks(thisfont->filedata);
    n2 = !thisfont->basefiledata ? 0 : 32*nchunks(thisfont->basefiledata);
    if (n1<n2) n1=n2;

    if (n1 != thisfont->nchars) {
      wimp_box b1, b2;
      getfontbox(thisfont,&b1);
      er(changenchars(thisfont, n1));
      getfontbox(thisfont,&b2);
      wlink = findwindinfo(W_FONTINDEX, thisfont);
      er(setextent(wlink));
      invalidate(wlink->wind_handle,-big,-big,big,max(b1.y0,b2.y0)+dy);
    }
  }

  return(NULL);
}

/* Redisplay all characters in the font, by deleting all the sprites.
 * Also redraws any skeleton/bitmap/full windows that are open.
 */

os_error *redisplayfont(Font_Block *thisfont, BOOL childrentoo, os_error * (*subr)(Char_Block *charptr))
{
  Wind_Link *wlink;

  /* scan fonts first, to ensure that all sprites are deleted */

  wlink = Wind_Head.next;
  while (wlink) {
    switch(wlink->type) {
      case W_FONTINDEX:
        { Font_Block *font = wlink->info;
          if (font == thisfont || (childrentoo && font->parent == thisfont)) {
            Char_Block **charray = font->chars;
            Char_Block *charptr;
            int i;
            for (i=0; i<font->nchars; i++) {                 /* invalidate sprites and rescale widths */
              if ((charptr = charray[i]) != NULL) {
                charptr->sprname[0] = 0;
                if (subr) er(subr(charptr));
              }
            }
            if (font->spritedata) flex_free((flex_ptr)&font->spritedata);
            font->spritedata = NULL;    /* will be reallocated when required */
            font->currchar = 0;    /* rescan the font */
            if (font->filedata->bpp) font->filedata->fontid = FONT_SCALING;
            invalidate(wlink->wind_handle, -big,-big,big,big);
          }
        }
    } /* switch */
    wlink = wlink->next;
  } /* while */

  /* now that the sprites have been deleted, we can scan for the character windows */

  if (childrentoo) {              /* only need to do this if actual chars have changed */
    wlink = Wind_Head.next;
    while (wlink) {
      switch(wlink->type) {
        case W_SKELETON:
        case W_FULL:
        case W_BITMAP:
          { Char_Block *charptr = wlink->info;
            Char_Block *charptr2 = charptr->template;
            if (charptr->parent == thisfont ||
                (charptr2 && charptr2->parent == thisfont)) {
              if (wlink->type == W_BITMAP) {
                Font_Block *tempfont = thisfont;     /* corrupted by the following routine */
                er(loadchar(charptr));               /* recompute bitmap */
                thisfont = tempfont;
              }
              invalidate(wlink->wind_handle, -big,-big,big,big);
              er(setextent(wlink));
            } /* if */
          }
      } /* switch */
      wlink = wlink->next;
    } /* while */
  }

  return(NULL);
}


/* Alter name of font - calls changetitle() and redraws the font index window.
 */

os_error *alter_fontname(Font_Block *thisfont, const char *fontname)
{
  Wind_Link *wlink = Wind_Head.next;
  while(wlink) {
    switch(wlink->type) {
      case W_FONTINDEX:
        { Font_Block *font = wlink->info;
          if (font == thisfont || font->parent == thisfont) {
            FFile_FontHdr *f = font->filedata;
            er(changetitle(font, f->table[0], fontname, NULL));
            invalidate(wlink->wind_handle,
                           FontIndexOrgX, FontIndexOrgY,
                           xwindlimit, FontIndexOrgY+50);
          } /* if */
        }
    } /* switch */
    wlink = wlink->next;
  } /* while */
  return(NULL);
}


/* Alter design size of font
 * All sprites associated with the font must be discarded, and the font rescanned from scratch
 * This also goes for bitmap fonts whose parent's designsize is altered
 * Skeleton, full and bitmap windows must be redrawn, and bitmaps recalculated
 * Metrics are also rescaled to correspond with the new size
 */

static int global_multiplier;           /* parameters to rescalechar() */
static int global_divisor;

os_error *alter_designsize(Font_Block *thisfont, int designsize)
{
  int oldd = thisfont->filedata->designsize;

  if (designsize==0  || designsize == oldd) return(NULL);

  thisfont->filedata->designsize = designsize;

  global_multiplier = oldd;
  global_divisor = designsize;
  return(redisplayfont(thisfont, TRUE, rescalechar));        /* redisplay this font and its children */
}


/* Subroutine passed to redisplayfont to be called for each character in the font.
 */

os_error *rescalechar(Char_Block *charptr)
{
  charptr->xwidth = charptr->xwidth * global_multiplier / global_divisor;
  return(NULL);
}


/* Alter skeleton threshold of font
 * Full and bitmap windows must be redrawn, and bitmaps recalculated
 */

os_error *alter_skeleton(Font_Block *thisfont, int threshold)
{
  Wind_Link *wlink;
  int oldt = thisfont->skeleton_threshold;

  if (threshold == oldt) return(NULL);        /* boring! */

  thisfont->skeleton_threshold = threshold;

  /* scan for any dependent bitmap fonts where the new threshold makes a difference */

  wlink = Wind_Head.next;
  while (wlink) {
    switch(wlink->type) {
      case W_FONTINDEX:
        { Font_Block *font = wlink->info;
          if (font == thisfont || font->parent == thisfont)
          if (drawskels(font, threshold) != drawskels(font, oldt)) {
            Char_Block **charray = font->chars;
            Char_Block *charptr;
            int i;
            for (i=0; i<font->nchars; i++) {                 /* invalidate sprites */
              if ((charptr = charray[i]) != NULL) charptr->sprname[0] = 0;
            }
            if (font->spritedata) flex_free((flex_ptr)&font->spritedata);
            font->spritedata = NULL;    /* will be reallocated when required */
            font->currchar = 0;    /* rescan the font */
            if (font->filedata->bpp) font->filedata->fontid = FONT_SCALING;
            invalidate(wlink->wind_handle, -big,-big,big,big);
          } /* if */
        }
    } /* switch */
    wlink = wlink->next;
  } /* while */

  /* now that the sprites have been deleted, we can scan for the character windows */

  wlink = Wind_Head.next;
  while (wlink) {
    switch(wlink->type) {
      case W_FULL:
        { Char_Block *charptr = wlink->info;
          if (charptr->parent == thisfont)
            invalidate(wlink->wind_handle, -big,-big,big,big);     /* redraw always (wimp out!) */
        }
        break;

      case W_BITMAP:
        { Char_Block *charptr = wlink->info;
          Font_Block *font = charptr->parent;
          if (font == thisfont || font->parent == thisfont)
          if (drawskels(font, threshold) != drawskels(font, oldt)) {
            if (wlink->type == W_BITMAP) {
              Font_Block *tempfont = thisfont;     /* corrupted by the following routine */
              er(loadchar(charptr));               /* recompute bitmap */
              thisfont = tempfont;
            }
            invalidate(wlink->wind_handle, -big,-big,big,big);
          } /* if */
        }
    } /* switch */
    wlink = wlink->next;
  } /* while */

  return(NULL);
}

/* Returns TRUE if skeleton lines will be drawn in this font, FALSE if not */

BOOL drawskels(Font_Block *font, int threshold)
{
  if (threshold==0) return(TRUE);

  if (font->filedata->bpp) {
    if ((font->xpoints * font->xres < threshold * 72) ||
        (font->ypoints * font->yres < threshold * 72)) return(TRUE); else return(FALSE);
  } else {
    if (SUPERY-32 < threshold << 1) return(TRUE); else return(FALSE);
  }
}


/* Redraw all skeleton windows (after showwidth, showbbox or showfbox have changed)
 */

void redrawskels(void)
{
  Wind_Link *wlink = Wind_Head.next;
  while (wlink) {
    if (wlink->type == W_SKELETON)
      invalidate(wlink->wind_handle, -big,-big,big,big);
    wlink = wlink->next;
  }
}


/* Decode scaffold menus */

os_error * decodescaffold(int * menus)
{
  register Char_Block *chr = menuhandle->info;
  register int type, coord, width, offset, i;
  static char types[6] = { SEL_SCAFFOLDY, SEL_SCAFFOLDY, SEL_SCAFFOLDY,
                                  SEL_SCAFFOLDX, SEL_SCAFFOLDX, SEL_SCAFFOLDX };
  static char widths[6] = { 0, WID_RTANGENT, WID_LTANGENT,
                                    0, WID_LTANGENT, WID_RTANGENT };

  switch(*menus++)
  {
    case 0:        /* create new local line */
    case 1:        /* create new global line */
    case 2:        /* replace existing line (globally) */
           if ((i = *menus) < 0) return(NULL);
           type = types[i];
           width = widths[i];
           if (type == SEL_SCAFFOLDX) {
             offset = 0;
             coord = unscalex(mousex);
           } else {
             offset = 8;
             coord = unscaley(mousey);
           }
           switch(menus[-1]) {
             case 0: for (i=offset+1;i<offset+8;i++) {
                       if (chr->scaffold.xcoord[i] == NULL_SCAFFOLD) break;
                     } break;
             case 1: { Char_Block **charray = chr->parent->chars;
                       int nchars = chr->parent->nchars;
                       char * checkarray = heap_alloc(nchars * sizeof(char));
                       int j, flag;
                       if (!checkarray) returnerr("Heap full");
                       if ((flag=checkglobal(chr, offset, checkarray)) == 0) { i=16; break; }
                       for(i=0;i<8;i++) { if (flag & (1<<i)) break; }
                       i += offset;
                       for (j=0;j<nchars;j++) if (checkarray[j]) {
                         charray[j]->scaffold.xchar[i] = chr->charno;  /* for changescaffold */
                       }
                       heap_free(checkarray);
                     }
                     break;
             case 2: if (scafftype(chr) == type) i = chr->parent->scaffold.index; else i = 16;
           }
           if (i-offset<8) {
             er(changescaffold(chr, i, chr->charno, coord, width, 0, NULL));
           } else bbc_vdu(7);
           break;
    case 3:
           if (canundelete(chr)) {
             register Font_Block *font = chr->parent;
             register Char_Block *chr2 = font->chars[chr->scaffold.basechar];
             register int i = font->scaffold.index;
             er(changescaffold(chr, i,
                                     chr2->scaffold.xchar[i],
                                     chr2->scaffold.xcoord[i],
                                     chr2->scaffold.xwidth[i],
                                     chr2->scaffold.xlink[i], NULL));
           } else bbc_vdu(7);     /* status has changed (?) */
           break;
    case 4: er(unscaffold(menuhandle));      /* disconnect points from the selected line */
  }
  return(NULL);
}

/* returns TRUE if the basechar contains the selected line,
 * and it is not inherited in this char */

BOOL canundelete(Char_Block *chr)
{
  register Font_Block *font = chr->parent;
  register Char_Block *chr2 = font->chars[chr->scaffold.basechar];
  register int i = font->scaffold.index;
  if (chr2)
  if (chr2->scaffold.xchar[i] == font->scaffold.selchar)
  if (chr->scaffold.xchar[i] != font->scaffold.selchar)
    return(1);
  return(0);
}


/* returns a flag byte saying which lines are free for use as a global line */
/* offset = 0 / 8 for x/y scaffold */

int checkglobal(Char_Block *charptr, int offset, char *checkarray)
{
  int flag = 0xFE;    /* bit n set => can use index n */
  Char_Block *chr, *ch2, **charray = thischar->parent->chars;
  int basechar = charptr->charno;
  int i, j;
  int nchars = charptr->parent->nchars;

  if (checkarray) for (i=0;i<nchars;i++) checkarray[i]=0;

  for (i=0;i<nchars;i++)
  if ((chr=charray[i]) != NULL) {
    j=i;
    ch2 = chr;
    while(j) {
      if (j==basechar) break;
      j=ch2->scaffold.basechar;
      if ((ch2=charray[j])==NULL) j=0;      /* if linked to dead char! */
    }
    if (j) {                                             /* this char is linked to the base char */
      int * xcoord = chr->scaffold.xcoord + offset;   /* points at x/ycoord[] */
      for (j=1; j<8; j++) if (xcoord[j] != NULL_SCAFFOLD) flag &= ~(1<<j);
      if (checkarray) checkarray[i]=1;    /* i = char index */
    }
    if (flag==0) break;
  }
  return(flag);      /* bits 1..7 => is scaffold line null in all relevant chars? */
}


os_error *remake1bpp(Char_Block *charptr)
{
  er(makesprite1bpp(charptr,(nonzerowinding(charptr))));   /* recompute from outline */
  return(updatecopies(charptr,TRUE));                     /* update font index display & save char in file */
}



/* Call this after updating a writeable icon
 * It repositions the caret if necessary
 */

static os_error *writeable_updated(wimp_w w, wimp_i i, char *buffer)
{
  wimp_caretstr caret;

  er(wimp_get_caret_pos(&caret));

  if (caret.w == w && caret.i == i) {
    if (caret.index > strlen(buffer)) caret.index = strlen(buffer);
    caret.height = -1;
    er(wimp_set_caret_pos(&caret));
  }

  return(wimp_set_icon_state(w, i, 0, 0));
}


os_error * zoom(Wind_Link *wlink, int mup, int mdown, char variable)
{
  Char_Block *thischar = wlink->info;
  BOOL invalid = 0;

  if (mup != thischar->magnifierup) {
    thischar->magnifierup = mup;
    sprintf(wricon_magnifierup,"%d",mup);
    er(writeable_updated(magnifier_window,0,wricon_magnifierup));
    invalid = 1;
  }
  if (mdown != thischar->magnifierdown) {
    thischar->magnifierdown = mdown;
    sprintf(wricon_magnifierdown,"%d",thischar->magnifierdown);
    er(writeable_updated(magnifier_window,1,wricon_magnifierdown));
    invalid = 1;
  }
  if (variable != thischar->variable) {
    thischar->variable = variable;
    er(wimp_set_icon_state(magnifier_window,7,
                                                 variable?wimp_ISELECTED:0,
                                                 wimp_ISELECTED));
    invalid = 1;
  }
  if (invalid) {
    invalidate(wlink->wind_handle,-big,-big,big,big);
    er(setextent(wlink));
  }

  globalmag_up = mup;      /* defaults when a skeleton window is first opened */
  globalmag_down = mdown;
  globalmag_variable = variable;

  return(NULL);
}


/* Set correct extent for window
 * Algorithm depends on type of window, char bbox and magnification factors
 * Chars are drawn relative to font bbox - must be redrawn when bbox changes (savefile)
 * Extent is increased if the character is bigger than the current font bbox
 */

os_error *setextent(Wind_Link *wlink)
{
  wimp_redrawstr rblk;      /* for wimp_set_extent() */
  union {
    wimp_openstr open;      /* for wimp_open_wind() */
    struct {
      wimp_winfo wind;      /* for wimp_get_wind_info() */
      wimp_icon icon[1];    /* allow for 1 icon maximum */
    } winfo;
  } u;

  switch(wlink->type)
  {
    case W_FONTINDEX:
        { Font_Block *font = wlink->info;
          wimp_box iconbox;
          getfontbox(font,&iconbox);           /* get icon position */
          mytracef("fontindex iconbox= %d,%d,%d,%d\n", iconbox.x0, iconbox.y0, iconbox.x1, iconbox.y1);
          rblk.box.x0 = t_fontindex.w.ex.x0;
          rblk.box.y1 = t_fontindex.w.ex.y1;
          rblk.box.x1 = iconbox.x1 + (iconbox.x0-t_fontindex.w.ex.x0);           /* same margin all round */
          rblk.box.y0 = iconbox.y0 - (iconbox.x0-t_fontindex.w.ex.x0);
          mytracef("fontindex extent = %d,%d,%d,%d\n", rblk.box.x0, rblk.box.y0, rblk.box.x1, rblk.box.y1);
        }
        break;

    case W_TREE:
        { Font_Block *font = wlink->info;
          rblk.box.x0 = 0;
          rblk.box.y1 = 0;
          rblk.box.x1 = font->treebox.x1;
          rblk.box.y0 = font->treebox.y0;
        }
        break;

    case W_FULL:
    case W_SKELETON:
         { Char_Block *chr = wlink->info;
           FFile_FontHdr *f = chr->parent->filedata;

           /* NB: minx,miny,maxx,maxy must be global, so minmaxhandle() can use them */

           if (wlink->type == W_SKELETON) {
             int i;

             /* include control points and font bbox */

             miny = f->y0 + f->ys - f->designsize;             /* always include y1 - designsize */
             if (chr->windowbox.y0 < miny) miny = chr->windowbox.y0;
             minx = chr->windowbox.x0;
             maxx = chr->windowbox.x1;      /* skeleton window must include control points */
             maxy = chr->windowbox.y1;

             /* include scaffold lines */

             for (i=0; i<8; i++) {
               register int xx1 = chr->scaffold.xcoord[i];
               register int xx2 = chr->scaffold.xwidth[i];
               if (xx1 != NULL_SCAFFOLD) {
                 xx2 = xx1 + ((xx2 < WID_LTANGENT) ? xx2 : 0);
                 if (xx1 < minx) minx = xx1;
                 if (xx2 > maxx) maxx = xx2;
               }
             }
             for (i=0; i<8; i++) {                                        /* ensure scaffold lines can be reached */
               register int yy1 = chr->scaffold.ycoord[i];
               register int yy2 = chr->scaffold.ywidth[i];
               if (yy1 != NULL_SCAFFOLD) {
                 yy2 = yy1 + ((yy2 < WID_LTANGENT) ? yy2 : 0);
                 if (yy1 < miny) miny = yy1;
                 if (yy2 > maxy) maxy = yy2;
               }
             }

             /* include bitmap box, if either bitmap or handles visible */

             if (chr->backsprite[0] != 0) {
               scanhandles(&chr->backsprbox,minmaxhandle);
             }

           } else {
             minx = chr->xlowc;
             miny = chr->ylowc;                 /* full window doesn't need to include control points */
             maxx = chr->xupperc;
             maxy = chr->yupperc;
           }

           minx -= f->x0; if (minx > 0) minx = 0;                   /* make relative to font bbox */
           miny -= f->y0; if (miny > 0) miny = 0;
           maxx -= (f->x0+f->xs); if (maxx < 0) maxx = 0;
           maxy -= (f->y0+f->ys); if (maxy < 0) maxy = 0;

           if (chr->variable || wlink->type == W_FULL) {
             register int ymul = ywindlimit-80-(dy<<1) - (YBORDER<<1);
             register int ydiv = f->y0 + f->ys;
             register int y;
             if (ydiv < f->designsize) ydiv = f->designsize;      /* must include baseline */
             rblk.box.x0 = -XBORDER + minx * ymul / ydiv;
             rblk.box.y1 = YBORDER + maxy * ymul / ydiv;
             rblk.box.x1 = (f->xs + maxx) * ymul / ydiv + XBORDER;
             rblk.box.y0 = rblk.box.y1 - (ywindlimit-80-(dy<<1));
             y = (-f->ys + miny) * ymul / ydiv - YBORDER;
             if (y < rblk.box.y0) rblk.box.y0 = y;
           } else {
             register int mup = chr->magnifierup;
             register int mdown = chr->magnifierdown;
             rblk.box.x0 = -XBORDER + minx * mup / mdown;
             rblk.box.y1 = YBORDER + maxy * mup / mdown;
             rblk.box.x1 = (f->xs + maxx) * mup / mdown + XBORDER;
             rblk.box.y0 = (-f->ys + miny) * mup / mdown - YBORDER;
           }
         }
         break;
    default:
         return(NULL);                 /* don't even try it - window may have icons in it */
  }
  rblk.box.x0 &= ~(dx-1);
  rblk.box.y0 &= ~(dy-1);
  rblk.box.x1 &= ~(dx-1);
  rblk.box.y1 &= ~(dy-1);

  u.winfo.wind.w = wlink->wind_handle;
  er(wimp_get_wind_info(&u.winfo.wind));         /* NB: window must not have more than 1 icon */
  if (u.winfo.wind.info.nicons > 1) returnerr("Too many icons in window!");

  if (u.winfo.wind.info.ex.x0 != rblk.box.x0 ||           /* only reset extent if it is different */
      u.winfo.wind.info.ex.y0 != rblk.box.y0 ||
      u.winfo.wind.info.ex.x1 != rblk.box.x1 ||
      u.winfo.wind.info.ex.y1 != rblk.box.y1) {
    rblk.w = wlink->wind_handle;
    er(wimp_set_extent(&rblk));
    if (u.winfo.wind.info.flags & wimp_WOPEN) er(wimp_open_wind(&u.open));
  }

  return(NULL);
}


/* ---- Dialogue box stuff ------------------------------------------------ */


os_error * event_keypress(wimp_caretstr *caret, int chcode)
{
  Wind_Link *wlink;

  if (caret->w == save_window)
    if (chcode == 13) return(savefilechk(menuhandle->info,wricon_filename,0));

  if (caret->w == save_window2)
    if (chcode == 13) return(savefilechk2(menuhandle->info,wricon_filename2,0));

  if (caret->w == magnifier_window) {
    if (chcode == 13) {
      caret->i = 1-caret->i;
      caret->index = 0;
      er(wimp_set_caret_pos(caret));
      if (caret->i == 0) {
        int m1,m2;
        sscanf(wricon_magnifierup,"%d",&m1);
        sscanf(wricon_magnifierdown,"%d",&m2);
        if (m1 < 1) m1=1;
        if (m2 < 1) m2=1;
        er(zoom(menuhandle,m1,m2,0));
      }
      return(NULL);
    }
  }

  if (caret->w == fontsize_window)
  {
    static int keymatch[] = { 0x19C, 0x19D, 0x19E, 0x19F, 0x18E, 0x18F, 0x0D };
    static signed char keyarrow[] = { -1, 1, 2,-2, 2,-2, 1 };
    static signed char keyindex[] = {  1,-1, 0, 0, 0, 0,-1 };
    static signed char icon[] = { 2,4,8,10 };

    int keytype, ic;

#define nkeys (sizeof(keymatch)/sizeof(int))

    for (keytype=0;keytype<nkeys;keytype++)
      if (keymatch[keytype] == chcode) break;

    if (keytype < nkeys)
    {
      for (ic=0;ic<4;ic++) if (icon[ic]==caret->i) break;

      ic += keyarrow[keytype];

      if (ic < 0) return(NULL);
      if (ic > 3) { if (chcode == 13) {
                      int xpoints,ypoints,xres,yres;
                      BOOL x=0;
                      if (sscanf(fsiz_xpoints,"%d",&xpoints)==EOF) x=1;
                      if (sscanf(fsiz_ypoints,"%d",&ypoints)==EOF) x=1;
                      if (sscanf(fsiz_xres,"%d",&xres)==EOF) x=1;
                      if (sscanf(fsiz_yres,"%d",&yres)==EOF) x=1;
                      if (x) returnerr("One or more numbers missing!");

                      return(scalefont(menuhandle->info,
                                       xpoints,ypoints,xres,yres)); }
                    else { return(NULL); }
                  }

      caret->i = icon[ic];
      if (keyindex[keytype]==0) caret->height = -1;
      else { caret->x = keyindex[keytype] << 20;
             caret->index = -1; }
      return(wimp_set_caret_pos(caret));
    }
  }

  if ((wlink = findwindlink2(caret->w)) != NULL) {      /* unrecognised windows can occur (menus) */
    if (wlink->type == W_SKELETON) {
      movex=0;
      movey=0;
      er(getwlinkstate(wlink));              /* sets up thischar */
      switch(chcode)
      {
        case 0x1b: return(selectline(thischar, NULL));
        case 0x7f: return(delete_a_path(thischar));
        case 0x18B: return(copy_a_path(thischar));
        case 0x189: return(unscaffold(wlink));
        case 0x18c: movex = -1; break;
        case 0x18d: movex = 1; break;
        case 0x18e: movey = -1; break;
        case 0x18f: movey = 1; break;
        case 0x19c: movex = -4; break;
        case 0x19d: movex = 4; break;
        case 0x19e: movey = -4; break;
        case 0x19f: movey = 4; break;
        case 0x1ac: movex = -16; break;
        case 0x1ad: movex = 16; break;
        case 0x1ae: movey = -16; break;
        case 0x1af: movey = 16;
      }
      if (movex || movey)
      if (dragbox.type == DR_NONE) {
        if (scafftype(thischar) != SEL_NONE) return(movepoints(wlink));
        if (thischar->selcomp) {
          return(movecomposite(thischar, thischar->selcomp,
                                         thischar->selcomp->xorigin + movex,
                                         thischar->selcomp->yorigin + movey));
        }
      } /* if (dragbox.type == DR_NONE) */
    } /* if (wlink->type == W_SKELETON) */

    if (dragbox.type != DR_NONE) {      /* this goes for all !FontEd windows */
      char block[5];
      wimp_mousestr mouse;
      int x=0, y=0;

      switch(chcode)
      {
        case 0x18c: x = -dx; break;
        case 0x18d: x = dx; break;
        case 0x18e: y = -dy; break;
        case 0x18f: y = dy;
      }
      if (x || y) {
        er(wimp_get_point_info(&mouse));
        x = mouse.x + x;
        y = mouse.y + y;
        block[0] = 3;
        block[1] = x; block[2] = x>>8;
        block[3] = y; block[4] = y>>8;
        return(os_word(0x15,&block));
      }
    }
  }

  return(wimp_processkey(chcode));          /* MUST pass it on if not dealt with (hot keys) */
}


os_error *origin_mouse(wimp_mousestr * m)
{
  Char_Block * charptr = (Char_Block *)menuhandle->info;
  int x = charptr->orgX;
  int y = charptr->orgY;
  int add = 16;

  switch(m->bbits)
  {
    case wimp_BRIGHT: add = -add;
    case wimp_BLEFT:

         switch(m->i)
         {
           case 0: x = m->x - bx - OriginBox.x0;
                   x = (x << 8) / (OriginBox.x1 - OriginBox.x0);
                   y = m->y - by - OriginBox.y0;
                   y = (y << 8) / (OriginBox.y1 - OriginBox.y0);
                   break;

           case 1: y += add; break;
           case 2: x -= add; break;
           case 3: x += add; break;
           case 4: y -= add; break;
         }

         if (x<0) x=0; else if (x>255) x=255;
         if (y<0) y=0; else if (y>255) y=255;

         if (x != charptr->orgX || y != charptr->orgY)
         {
           charptr->orgX = x;
           charptr->orgY = y;
           sprintf(mb_origin,"%d,%d",charptr->orgX,charptr->orgY);
           er(writeable_updated(origin_window,5,mb_origin));
           er(remake1bpp(charptr));
           invalidate(menuhandle->wind_handle,-big,-big,big,big);
         }
         break;
  }
  return(NULL);
}


os_error *movepoints(Wind_Link *wlink)
{
  er(getwlinkstate(wlink));
  moveflag = 0;
  scancharpt(wlink->info, movepoint);
  if (moveflag) {
    invalidate(wlink->wind_handle, -big,-big,big,big);
    er(updatecopies(wlink->info,TRUE));
    return(updatebbox(wlink->info, wlink->wind_handle));
  }
  return(NULL);
}


int movepoint(Pt_Block *pt)
{
  switch(scafftype(thischar))
  {
    case SEL_SCAFFOLDX:
         if (pt->scaffoldx == thischar->parent->scaffold.index) {
           pt->x += movex;
           pt->y += movey;
           moveflag = 1;
         }
         break;

    case SEL_SCAFFOLDY:
         if (pt->scaffoldy == thischar->parent->scaffold.index-8) {
           pt->x += movex;
           pt->y += movey;
           moveflag = 1;
         }
  }
  return(0);
}


os_error *unscaffold(Wind_Link *wlink)
{
  er(getwlinkstate(wlink));
  gx0 = big; gy0 = big; gx1 = -big; gy1 = -big;  /* area to invalidate */
  scancharpt(wlink->info, unscaffoldpoint);
  invalidate(wlink->wind_handle, gx0, gy0, gx1, gy1);
  return(updatecopies(wlink->info,TRUE));
}


int unscaffoldpoint(Pt_Block *pt)
{
  int x,y, flag=0;

  if (pt->type == PT_HINGED || pt->type == PT_PARALLEL)
  switch(scafftype(thischar))
  {
    case SEL_SCAFFOLDX:
         if (pt->scaffoldx == thischar->parent->scaffold.index) {
           flag = 1; scafflink(pt, 0);      /* unlinks control points too */
         }
         break;

    case SEL_SCAFFOLDY:
         if (pt->scaffoldy == thischar->parent->scaffold.index-8) {
           flag = 1; scafflink(pt, 8);      /* unlinks control points too */
         }
  }
  if (flag) {
    x = rscalex(pt->x);
    y = rscaley(pt->y);
    if (x-tt < gx0) gx0 = x-tt;
    if (y-tt < gy0) gy0 = y-tt;
    if (x+tt > gx1) gx1 = x+tt;
    if (y+tt > gy1) gy1 = y+tt;
  }
  return(0);
}


/* Make one character into a composite part of another
 */

os_error *makecomposite(Char_Block *charptr, int charno, int xoffset, int yoffset)
{
  Comp_Block *comp;

  er(unsuspendpathdata(charptr));     /* ensure master copy is in char_block */

  er(getheap(Comp_Block, &comp));
  comp->charno = charno;
  comp->xorigin = comp->yorigin = 0;
  comp->next = charptr->composites;
  charptr->composites = comp;

  charptr->selcomp = comp;      /* select the most recent bit to be dragged in */

  return(movecomposite(charptr, comp, xoffset, yoffset));
}


/* This is called when moving an existing composite section
 * The character must already be unsuspended (how else could the comp_block * have been obtained?)
 */

os_error *movecomposite(Char_Block *charptr, Comp_Block *comp, int xoffset, int yoffset)
{
  Wind_Link *wlink = findwindinfo(W_SKELETON, charptr);
  wimp_w handle = NULL;

  comp->xorigin = xoffset;
  comp->yorigin = yoffset;

  if (wlink) invalidate(handle=wlink->wind_handle, -big,-big,big,big);
  er(updatebbox(charptr, handle));

  er(suspendpathdata(charptr));                      /* won't suspend char if visible anywhere */

  return(updatecopies(charptr, TRUE));
}


/* Remove most recent composite section of charno inside charptr.
 */

os_error *unmakecomposite(Char_Block *charptr, int charno)
{
  Comp_Block **backcomp, *comp;

  er(unsuspendpathdata(charptr));         /* master copy in char_block */

  backcomp = &charptr->composites;
  comp = *backcomp;
  while (comp) {
    if (comp->charno == charno) break;
    backcomp = &comp->next;
    comp = *backcomp;
  }

  if (charptr->selcomp==comp) charptr->selcomp = NULL;     /* deselect composite section */

  if (comp) {
    *backcomp = comp->next;
    heap_free(comp);
    { Wind_Link *wlink = findwindinfo(W_SKELETON, charptr);
      wimp_w handle = NULL;
      if (wlink) invalidate(handle=wlink->wind_handle, -big,-big,big,big);
      er(updatebbox(charptr, handle));
    }
    er(suspendpathdata(charptr));
    return(updatecopies(charptr, TRUE));
  } else {
    return(suspendpathdata(charptr));
  }
}


/* Copy the path which contains the selected line
 */


static Path_Block * static_subpath;

os_error * copy_a_path(Char_Block *charptr)
{
  Path_Block *newp;

  if (charptr->sline.p[0] == NULL) return(NULL);

  thischar = charptr;
  static_subpath = NULL;
  scanchar(charptr,findselected);    /* static_subpath updated */

  if (static_subpath) {
    er(copysubpath(static_subpath, &newp, 1, 1, 100, -100));
    newp->nextpath = static_subpath->nextpath;
    static_subpath->nextpath = newp;

    invalidate(handle,-big,-big,big,big);
    er(updatecopies(charptr,TRUE));
    er(updatebbox(charptr,handle));
  }

  return(NULL);
}


os_error * delete_a_path(Char_Block *charptr)
{
  if (charptr->sline.p[0] == NULL) return(NULL);

  thischar = charptr;
  static_subpath = NULL;
  scanchar(charptr,findselected);    /* static_subpath updated */

  if (static_subpath) {
    Path_Block **head;

    er(selectline(charptr, NULL));

    for (head=&charptr->nextpath; *head != static_subpath; head = &((*head)->nextpath));
    er(deletesubpath(head));

    invalidate(handle,-big,-big,big,big);

    er(updatecopies(thischar,TRUE));
    er(updatebbox(charptr,handle));
  }

  return(NULL);
}


int findselected(Line_Block *line)
{
  if (line->p[0] == thischar->sline.p[0] || line->p[1] == thischar->sline.p[0]) {
    static_subpath = thispath;
    return(1);
  } else {
    return(0);
  }
}

