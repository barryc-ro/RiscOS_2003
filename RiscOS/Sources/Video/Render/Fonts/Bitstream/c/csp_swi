/***************************************************************************
 * File:	c.csp_swi
 *
 * Purpose:	Provide SWI handler and registration routines
 *		as specified in ^.CMHG.CModuleHdr.
 *
 * History:	28/10/96	RBrowning	First code
 *		29/10/96	RBrowning	Moved to assembler
 *		10/12/96	RBrowning	Included bitstream callbacks
 **************************************************************************/

/*
Includes.
*/
#include "kernel.h"
#include <stdio.h>
#include <assert.h>
#include "csp_api.h"
#include "draw.h"
#include "speedo.h"
#include "fontprots.h"
/*
#defines.
*/
#define UNUSED( x )	( x = x )
#define WFR_Base	0x4F680
#define _SWI_GetNames	1
#define _SWI_GetTable	2
#define _SWI_Max	22
#define STR_TAB		"\t"
#define STR_NULL	"\0"
#define CSPCACHESIZE	16000		/* Bitmap cache memory size */
#define CSPMEMORYMODE	2		/* 1 = min, 2 = normal, 3 = max */
#define MODIF		9
#define ESC		27
#define SS2		142
#define CHECK_INIT	( if( !bit_init ) if( !InitialiseBitstream() ) return; )
#define ISMARU(A)	(A >= 202 && A <= 206)
#define ISNIGORI(A)	((A>=182 && A<=196) || (A>=202 && A<=206) || (A==179))
#define Logfile(S)	(if(replog) fprintf(replog_file, S))

/*#define WONG	    	1   	    	*//* Temporary hack to get BIG5 working for WONG */

/*
Typedefs.
*/
typedef void ( *_void_func_ptr )();
typedef int ( *_int_func_ptr )();
typedef struct
{
        unsigned int _value;
        _void_func_ptr svc_routine;
} _swi_call_table;
typedef struct
{
        unsigned int _fontindex;
        font_l * _cache_entry;
} _cache_char;


/*
Prototypes.
*/
void cspSvcInitBitmapCache( _kernel_swi_regs * );
void cspSvcSetCacheParams( _kernel_swi_regs * );
void cspSvcOpen( _kernel_swi_regs * );
void cspSvcOpenAlt1( _kernel_swi_regs * );
void cspSvcSetPfr( _kernel_swi_regs * );
void cspSvcOutputChar( _kernel_swi_regs * );
void cspSvcCharSize( _kernel_swi_regs * );
void cspSvcFontSize( _kernel_swi_regs *r );
void cspSvcAddFile( _kernel_swi_regs * );
void cspConvertCode( _kernel_swi_regs * );
void cspSetWideEncoding( _kernel_swi_regs * );
void cspDirectDraw( _kernel_swi_regs * );
void cspBitmapDraw( _kernel_swi_regs * );
void cspAddHandle( _kernel_swi_regs * );
void cspCheckHandle( _kernel_swi_regs * );
void cspCloseHandle( _kernel_swi_regs * );
void cspTestCacheChar( _kernel_swi_regs * );
void cspShowFontTree( _kernel_swi_regs * );
void cspIsWideFont( _kernel_swi_regs * );
void cspDetectEncoding( _kernel_swi_regs * );
void PrintRegisters( _kernel_swi_regs * );
ufix16 ConvertCode( int, ufix16 );
ufix16 xSJ2JIS( ufix16 );
ufix16 xJIS2SJ( ufix16 );
ufix16 KSC2UNI( ufix16 );
int SetBitstreamInit( void );
unsigned short InitialiseBitstream( char * );
static int MyReadResourceData( void *pBuffer, short nBytes, long offset );
static void *MyAllocCspBuffer( long minBuffSize, long normalBuffSize,
			       long maxBuffSize, long *pNBytes );
static void MyVstem( short x1, short x2 );
static void MyHstem( short y1, short y2 );
static void MyMoveTo( short x, short y );
static void MyLineTo( short x, short y );
static void MyCurveTo( short xc1, short yc1, short xc2, short yc2, short x, short y );
static void MyClosePath( void );
/*ufix16 JIS2SJ( ufix16 );*/
ufix16 EUC2SJ( ufix16 );
ufix16 EUC2JIS( ufix16 );
void SJ2JIS( int *, int * );
void JIS2SJ( int *, int * );
char GetFontChar( void );
int DetectCodeType( void );
void DoMetricsBlock( _kernel_swi_regs * );
void CloseFont( _kernel_swi_regs * );
ufix16 SJAS2UNI( ufix16 );
ufix16 Han2Zen( ufix16 );
ufix16 xSJ2UNI( ufix16 );
ufix16 UTF82UNI( _kernel_swi_regs * );

/*
Externs and statics.
*/
static long draw_data[2000];
static font_l* font_handles[256];
static int INT_font_handles[256];
int draw_index;
long current_x, current_y;
int object_start, object_size;
long fontsize;
static int x_step, y_step;
static long xPosPix;			/* Current X position in 16.16 pix */
static long yPosPix;			/* Current Y position in 16.16 pix */
static FILE *pdfFile;			/* Electronic document file */
static void *cspCache;			/* Bitmap cache memory buffer */
static void *cspBuffer;			/* CSP memory buffer */
static long xPosPix;			/* Current X position in 16.16 pix */
static long yPosPix;			/* Current Y position in 16.16 pix */
static void *bmapMem = NULL;		/* Pointer to memory for temporary bitmap. */
static _kernel_oserror csp_Error = { WFR_Base, "WFR Module Error" };
/* Call table for service routines. */
static _void_func_ptr swi_call_table[] = { cspSvcInitBitmapCache,
					   cspSvcSetCacheParams,
					   cspSvcOpen,
					   cspSvcOpenAlt1,
					   cspSvcSetPfr,
					   cspSvcOutputChar, /* This is not a bitstream routine */
					   DoMetricsBlock, /* This is not a bitstream routine */
					   CloseFont, /* This is not a bitstream routine */
					   cspSvcCharSize, /* This is not a Bitstream routine */
					   cspSvcAddFile, /* This is not a Bitstream routine */
					   cspConvertCode, /* This is not a Bitstream routine */
					   cspIsWideFont, /* This is not a Bitstream routine */
					   cspDirectDraw, /* This is not a Bitstream routine */
					   cspDirectDraw, /* This is not a Bitstream routine */
					   cspAddHandle, /* This is not a Bitstream routine */
					   cspCheckHandle, /* This is not a Bitstream routine */
					   cspCloseHandle, /* This is not a Bitstream routine */
					   cspTestCacheChar, /* This is not a Bitstream routine */
					   cspShowFontTree, /* This is not a Bitstream routine */
					   cspSetWideEncoding, /* This is not a Bitstream routine */
					   cspDetectEncoding, /* This is not a Bitstream routine */
					   PrintRegisters, /* This is not a Bitstream routine */
					   cspSvcFontSize
					 };
/* Direct call table for Bitstream routines. */
static _int_func_ptr _csp_proc_table[] = { CspInitBitmapCache,
					   CspSetCacheParams,
					   CspOpen,
					   CspOpenAlt1,
					   CspSetPfr };
/* Name table for Bitstream routines. */
static char *_csp_name_table = { "_CspInitBitmapCache" STR_TAB "<regs>" STR_NULL
				 "_CspSetCacheParams" STR_TAB "<regs>" STR_NULL
				 "_CspOpen" STR_TAB "<regs>" STR_NULL
				 "_CspOpenAlt1" STR_TAB "<regs>" STR_NULL
				 "_CspSetPfr" STR_TAB "<regs>" STR_NULL STR_NULL };
static char doublebyte[2];
static int dbcount;
/* Font path. */
static char font_path[100];

/* Data block for metrics. */
#define COUNT_LO	48	/* Offset to low byte character count. */
#define COUNT_HI	51	/* Offset to high byte character count. */
static unsigned char metrics_block[] = {
        /* Font name. */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        16, 0, 0, 0, 16, 0, 0, 0, /* Two lots of 16. */
        0, /* Low byte of number of chars that can be defined. */
        2, /* Version number of file format. */
	39, /* Flags [39 = no bbox, no x-off, no y-off, char map size given] */
	0, /* High byte of number of chars that can be defined. */
	0, 0 /* Character map size. */ };

/* Data block for outlines header. */
#define DESIGN_SIZE	6	/* Offset to design size of font. */
#define CHUNK_OFF_PTR	16	/* Offset to chunk offset area. */
#define CHUNK_COUNT	20	/* Offset to number of chunks. */
#define HEADER_SIZE	52	/* Total size of header block. */
static unsigned char header_block[] = {
        'F', 'O', 'N', 'T', /* Identification word. */
        0, /* Specify outlines. */
        8, /* Version number of file format. */
        0, 0, /* Design size of font. */
        0, 0, /* x0      } Maximum bounding box for font (16-bit signed). */
	0, 0, /* y0      } Bottom left (x0, y0) is inclusive. */
	0, 0, /* x1 - x0 } top-right (x1, y1) is exclusive. */
	0, 0, /* y1 - y0 } all coordinates are in pixels or design units. */
	0, 0, 0, 0, /* File offset to area of offsets for chunks. */
	0, 0, 0, 0, /* Number of defined chunks. */
	0, 0, 0, 0, /* Number of scaffold entries. */
	0, 0, 0, 0, /* Scaffold flags. */
	/* Reserved area; all zeros. */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/* To follow dynamically: file offsets (from header_block) of chunks,
   chunks themselves (which include outline data. */
static unsigned short kanjichar;

/* Enumeration for wide type detection. */
enum { ASCII = 0, SJIS, OLD, NEW, NEC, EUC, EUCORSJIS, xJIS, xSJIS, xEUC, xEUC2, xJIS2, UTF8 };

/* Font Manager paint string. */
char *string_ptr;
int string_pos;

/* List of pointers to filenames used in Font_ListFonts */
char *listfonts_ptr[ 100 ];			/* More than a hundred fonts and we're stuffed. */
int listfonts_count;

/* Initialiser flag for Bitstream. */
int bit_init;

/* Pointer to allocated memory for Unicode conversion. */
short int *uni_conv_tbl;

/* Current encoding semaphore. */
int current_encoding;

/* Current 16-bit character. */
unsigned short newkchar;
long bxstep, bystep;

/* File error output. */
FILE *file_err;

/* Flags for conversion. (0=error, 1=half-width, 2=ASCII, -1=normal) */
short cvt_flags;

/* Cache chars. */
static _cache_char cache_char[768];
/* Cache semaphore. */
static int cache_sema[768];
/* Font lists. */
static _wide_font_entry * flist_init;

FILE * replog_file;
int replog = 0;
font_l * font_child;
int glob_font;
_kernel_swi_regs *glob_regs;


static char * strcpycr ( char *dest, const char *src )
{
        for ( ; *src >= ' '; ) *dest++ = *src++;
        *dest = 0;
        return dest;
}



static char * strcatcr ( char *dest, const char *src )
{
        return strcpycr ( dest + strlen(dest), src );
}


/*
Procedures and functions.
*/
/* Initialise the CSP. */
int *cspInit( char *cmd_tail_str, int podule_base, void *private_word )
{
	UNUSED( private_word );
	UNUSED( cmd_tail_str );
	UNUSED( podule_base );

	/* Initialise the Bitstream library. */
	return ( SetBitstreamInit() );
}


/* Handle SWI calls. */
_kernel_oserror *cspSWIHandle( int swi_no,
			       _kernel_swi_regs *r,
			       void *private_word )
{
        UNUSED( r );
        UNUSED( private_word );

	assert( swi_no <= _SWI_Max );

	/* Execute the appropriate SWI routine. */
	( *swi_call_table[ swi_no ] )( r );

        return( NULL );
}


void cspSvcInitBitmapCache( _kernel_swi_regs *r )
{
        CspInitBitmapCache( (void *)r->r[1], (long)r->r[2] );
}


void cspSvcSetCacheParams( _kernel_swi_regs *r )
{
        CspSetCacheParams( (short int)r->r[1],
        		   (short int)r->r[2],
        		   (short int)r->r[3],
        		   (short int)r->r[4],
        		   (short int)r->r[5] );
}


void cspSvcOpen( _kernel_swi_regs *r )
{
	CspOpen( (short)r->r[1],
		 (_int_func_ptr)r->r[2],
		 (_void_func_ptr)r->r[3] );
}


void cspSvcOpenAlt1( _kernel_swi_regs *r )
{
        CspOpenAlt1( (short)r->r[1],
        	     (short)r->r[2],
        	     (cspPfrAccess_t *)r->r[3],
        	     (_void_func_ptr)r->r[4] );
}


/* SWI + 4 */
void cspSvcSetPfr( _kernel_swi_regs *r )
{
	int slen;

	/* fudge factor ten, captain, for some spaces at the start. */
	strcpy( font_path, (char *)(r->r[1] + 2) );
	slen = strlen( font_path ) - 3;
	font_path[ slen ] = '\0';
/*	printf("Opening %s\n", font_path);*/
	/* Set handle to indicate 16 bit file. */
	r->r[1] = 128;
/*	CspSetPfr( (short)r->r[1] );*/
}


/* SWI + 5 */
/* Display a character. */
/* In: R0 = 16-bit character (before encoding applied)
       R1,R2 = current x,y coordinates (OS units)
   Out: R0=0 => not a valid character
        else R0 = internal character code
             R2 = -1 => that was an 8-bit code (skip 1 byte in string)
             R2 <> 0 => that was a 16-bit code (skip 2 bytes in string)
*/
void cspSvcOutputChar( _kernel_swi_regs *r )
{
        unsigned long kanjichar;
        unsigned int mchar, lchar;
        int this_enc;
        long x, y;

	this_enc = font_handles[ glob_font ]->parent->encoding;

	if( replog ) fprintf(replog_file, "Into cspSvcOutputChar %x with encoding %i\n", r->r[0], this_enc );

	/* Cast register to unsigned 32-bit long. */
	kanjichar = (unsigned long) r->r[0];

	/* Position of character. */
	x_step = 0;/*(long)r->r[1] << 9;*/
	y_step = 0;/*(long)r->r[2] << 9;*/

	/* In case it's UTF* */
	glob_regs = r;

    	cvt_flags = -1;

	/* Convert the character as appropriate. */
	newkchar = ConvertCode( this_enc, kanjichar );
	if ( cvt_flags == 0 )
	{
	        /* Invalid character for encoding. */
	        r->r[0] = 0;
	        if( replog ) fprintf(replog_file, "Invalid char\n");
	        return;
	}
	if ( cvt_flags == 1 )	    	    	    /* Han/Zen (1 byte enc, 2 byte o/p) */
    	{
	        kanjichar = 1UL;
	}
	else if ( cvt_flags == 2 )
	{
	        /* Single-byte ASCII. */
	        kanjichar = 2UL;
	}
	else kanjichar = 0UL;

	/* Initialise the font string index. */
	string_pos = 0;
	string_ptr = (char *)r->r[4];
	xPosPix = 0;
	yPosPix = 0;
	draw_index = 0;

	/* Set global font size. */
	fontsize = (long)r->r[3];

	if( replog ) fprintf( replog_file, "Char. %x at size %li\n", newkchar, fontsize );

	/* Check whether the Bitstream stuff's been initialised */
	/* if( !bit_init ) if( !InitialiseBitstream() ) return; */
	/*** Need to alter the following so that, if the character _is_ invalid,
	     an error character is generated. All possible occurrences of any 16-bit
	     character should be accounted for; if a character is requested that is
	     valid as far as the encoding applies (ie the routine has reached thus
	     far) and calls to csp...Draw fail, then that is because the requested
	     character doesn't exist in the font table and is _not_ a fault of the
	     encoding. Therefore within the csp ... Draw calls, null characters from
	     the font table should be replaced by an error character in order not
	     to upset the character positioning and string spacing etc. */

	/* Need to set up pointer to draw data regardless. May be moved to
	initialisation routine later. */

	/**** Use font_child because that will have been set in the call to
	cspAddHandle. ****/
	r->r[0] = &draw_data;
	if( cvt_flags != -1 ) {
   		if( replog ) fprintf(replog_file, "Requesting 8-bit or Han char %x\n", newkchar );
   		r->r[1] = (unsigned long)newkchar;  	/* May or may not be modified depending on Han status. */
	        r->r[2] = (unsigned long)kanjichar;
	        return;
	}
	if( replog ) fprintf(replog_file, "Requesting 16-bit char %x\n", newkchar );
	r->r[2] = (unsigned long)newkchar;

/*	if( ( cache_char[r->r[2]]._fontindex == newkchar ) && cache_char[r->r[2]]._cache_entry == font_child )
	{
		cache_sema[r->r[2]] = 1;
	}
	else
	{
	        cache_char[ r->r[2] ]._fontindex = newkchar;
	        cache_char[ r->r[2] ]._cache_entry = font_child;
	        cache_sema[ r->r[2] ] = 0;
	}
*/
	current_encoding = this_enc;
}

/* SWI + 8 */
/* Retrieve metrics information about a character. */
void cspSvcCharSize( _kernel_swi_regs *r )
{
	cspCharInfo_t pCharInfo;

	/* Retrieve character specs. */
/*	CspGetCharSpecs( (unsigned short)newkchar, &pCharInfo );*/

	/* Return width and height info to caller. */
	r->r[2] = ( font_handles[ r->r[0] ]->font_size ) * 48;
	r->r[3] = 0UL;

/*	if(replog) fprintf(replog_file, "r0 %x\tr1 %x\tr2 %x\tr3 %x\tr4 %x\tr5 %x\n",
				r->r[0],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5] );*/

	if(replog) fprintf(replog_file, "Char %x is %i by %i\n", (unsigned short)newkchar,
				pCharInfo.hWidth, pCharInfo.vWidth);
}

/* Retrieve font bounding box specs. */
void cspSvcFontSize( _kernel_swi_regs *r )
{
        cspFontInfo_t pFontInfo;
        fontAttributes_t pFontAttributes;
        unsigned short pFontRefNumber;

        if( CspGetFontSpecs( &pFontRefNumber, &pFontInfo, &pFontAttributes ) )
        	assert( FALSE );

        r->r[0] = pFontInfo.fontBBox.xmin >> 6;
        r->r[1] = pFontInfo.fontBBox.ymin >> 6;
        r->r[2] = pFontInfo.fontBBox.xmax >> 6;
    	r->r[3] = pFontInfo.fontBBox.ymax >> 6;
}


/* SWI + 9 */
/* Add font name derived from Font_ListFonts. */
void cspSvcAddFile( _kernel_swi_regs *r )
{
        listfonts_ptr[ listfonts_count ] = malloc( (size_t)strlen((char*)(r->r[1])) + 1 ) ;
        strcpy( listfonts_ptr[ listfonts_count ], (char*)(r->r[1]) );
        *(listfonts_ptr[ listfonts_count ]+strlen((char*)(r->r[1]))) = 0;
        listfonts_count++;
}


int SetBitstreamInit( void )
{
        int	i;

	/* Initialise listfonts counts. */
	listfonts_count = 0;
	current_encoding = 1;

	if( replog )
	{
	        replog_file = fopen( ":4.$.replog2", "w" );
	        if( replog_file == NULL ) replog = 0;
	}

	if(replog)fprintf(replog_file,"Initialising font list\n");

	/* Start up the initial font list. */
	flist_init = FontListInit();

	if(replog)fprintf(replog_file,"Exiting font list\n");

	/* Initialise the font handles. */
	for( i = 0; i < 256; i++ ) {
	        font_handles[ i ] = NULL;
	}

	glob_font = 0;

	return 0;
}


unsigned short InitialiseBitstream( char * file )
{
        /* Variables. */
   	outputSpecs_t	outputSpecs;
   	int		errCode;
	cspFontInfo_t	fontInfo;
	fontAttributes_t fontAttributes;
	unsigned short	fontRefNumber;
	unsigned short	fontCode;
	char pathname[ 80 ];

	/* Check for no recognised PFR files.
	if( listfonts_count == 0 )
	{
	        return( FALSE );
	} */

	/* Open font file (temporary hack). */
/*	pdfFile = fopen( listfonts_ptr[listfonts_count-1], "rb" );*/
	strcpy( pathname, "Font:" );
	strcatcr( pathname, file );
	strcat( pathname, ".pfr0" );

	if( replog) fprintf(replog_file, "Attempting to open file %s\n", pathname);

	pdfFile = fopen( pathname, "rb" );

	if( pdfFile == NULL )
	{
		return( FALSE );
	}

	/* Open Character Shape Player */
	errCode = CspOpen( 0, MyReadResourceData, MyAllocCspBuffer );
	assert( errCode == 0 );
	if(replog) fprintf(replog_file, "CspOpen %i\n", errCode );

	/* Set up the output transformation and output type. */
	outputSpecs.outputType = OUTLINE_OUTPUT;
	outputSpecs.specs.outline.outputMatrix[ 0 ] = 1000L << 16;
	outputSpecs.specs.outline.outputMatrix[ 1 ] = 0L;
	outputSpecs.specs.outline.outputMatrix[ 2 ] = 0L;
	outputSpecs.specs.outline.outputMatrix[ 3 ] = 1000L << 16;
	outputSpecs.specs.outline.pOptions = NULL;
	outputSpecs.specs.outline.MoveTo	= MyMoveTo;
	outputSpecs.specs.outline.LineTo	= MyLineTo;
	outputSpecs.specs.outline.CurveTo	= MyCurveTo;
	outputSpecs.specs.outline.ClosePath	= MyClosePath;
	outputSpecs.specs.outline.Hstem		= MyHstem;
	outputSpecs.specs.outline.Vstem		= MyVstem;
	errCode = CspSetOutputSpecs( &outputSpecs );
	assert( errCode == 0 );
	if(replog) fprintf(replog_file, "CspSetOutputSpecs %i\n", errCode );

	/* Select a font. */
	errCode = CspSetFont( 0 );
	assert( errCode == 0 );
	if( replog ) fprintf(replog_file, "CspSetFont:1 %i\n", errCode );

	/* Retrieve details about the font. */
	errCode = CspGetFontSpecs( &fontRefNumber, &fontInfo, &fontAttributes );
	assert( errCode == 0 );

	/* Create the dynamic font. */
	errCode = CspCreateDynamicFont( fontInfo.pFontID, (short)1000, &fontAttributes, &fontCode );
	assert( errCode == 0 );

	/* Select the new font. */
	errCode = CspSetFont( fontCode );
	assert( errCode == 0 );

	/* Initialise double-byte count. */
	dbcount = 0;

	/* Initialise listfonts counts. */
	listfonts_count = 0;

	/* Set initialisation flag. */
	bit_init++;

	return( fontCode );
}


/* Callback function to read portable font resource data */
static int MyReadResourceData( void *pBuffer, short nBytes, long offset )
{
	if( fseek( pdfFile, offset, SEEK_SET ) )
	{
		return( 1 );
	}

	if( fread( pBuffer, 1, nBytes, pdfFile ) != nBytes )
	{
		return( 2 );
	}

	return( 0 );
}


/* Callback function to allocate memory for the character shape player */
static void *MyAllocCspBuffer( long minBuffSize, long normalBuffSize,
			       long maxBuffSize, long *pNBytes )
{
	long	nBytes;

	switch( CSPMEMORYMODE )
	{
		case 1: nBytes = minBuffSize;
			break;

		case 2: nBytes = normalBuffSize;
			break;

		case 3: nBytes = maxBuffSize;
			break;

		default:
			nBytes = CSPMEMORYMODE;
			break;
	}

	*pNBytes = nBytes;
	cspBuffer = (void *)malloc( nBytes );

	return( cspBuffer );
}


static void MyVstem( short x1, short x2 )
{	return;
}


static void MyHstem( short y1, short y2 )
{	return;
}


static void MyMoveTo( short x, short y )
{
        long x1, y1;
        x1 = (long)x * ( fontsize * MODIF ) >> 6;
        y1 = (long)y * ( fontsize * MODIF ) >> 6;
        x = (short) x1;
        y = (short) y1;
	DRAW_OBJECT_HDR2( DRAW_MOVE );
	DRAW_COORDINATE( x1, y1 );
	current_x = x1;
	current_y = y1;
}


static void MyLineTo( short x, short y )
{
        long x1, y1;

/*        printf("Drawing line to %i,%i\n", x, y); */

        x1 = (long)x * ( fontsize * MODIF ) >> 6;
        y1 = (long)y * ( fontsize * MODIF ) >> 6;
        x = (short) x1;
        y = (short) y1;
        DRAW_OBJECT_HDR2( DRAW_LINE );
        DRAW_COORDINATE( x1, y1 );
        current_x = x1;
        current_y = y1;
}


static void MyCurveTo( short xc1, short yc1, short xc2, short yc2, short x, short y )
{
	long x1, y1, xx1, yy1, xx2, yy2;

/*	printf("Drawing curve from %i,%i through %i,%i to %i,%i\n",
		xc1, yc1, xc2, yc2, x, y );*/

        x1 = (long) x * ( fontsize * MODIF ) >> 6;
        y1 = (long) y * ( fontsize * MODIF ) >> 6;
        x = (short) x1;
        y = (short) y1;
        xx1 = (long) xc1 * ( fontsize * MODIF ) >> 6;
        yy1 = (long) yc1 * ( fontsize * MODIF ) >> 6;
        xc1 = (short) xx1;
        yc1 = (short) yy1;
        xx2 = (long) xc2 * ( fontsize * MODIF ) >> 6;
        yy2 = (long) yc2 * ( fontsize * MODIF ) >> 6;
        xc2 = (short) xx2;
        yc2 = (short) yy2;
        DRAW_OBJECT_HDR2( DRAW_CURVE );
        DRAW_COORDINATE( xx1, yy1 );
        DRAW_COORDINATE( xx2, yy2 );
        DRAW_COORDINATE( x1, y1 );
        current_x = x1;
        current_y = y1;
}


static void MyClosePath( void )
{
        DRAW_OBJECT_HDR2( DRAW_ENDSUB );
}



/* JIS ward odd :                                       */
/* 0x21 - 0x5f -> 0x40 - 0x7e */
/* 0x60 - 0x7e -> 0x80 - 0x9e */
/* JIS ward even :                              */
/* 0x21 - 0x7e -> 0x9F - 0xfc */

/*ufix16 JIS2SJ(ufix16 code)*/
void JIS2SJ( int *p1, int *p2 )
/*
 * Convert JIS to shift-JIS
 */
{
	unsigned char c1 = *p1;
        unsigned char c2 = *p2;
        int rowOffset = (c1 < 95) ? 112 : 176;
        int cellOffset = (c1 % 2) ? 31 + (c2 > 95) : 126;

        *p1 = ( ( c1 + 1 ) >> 1 ) + rowOffset;
        *p2 = c2 + cellOffset;
}

ufix16 EUC2JIS(ufix16 code)
/*
 * Convert EUC (Extended Unix Code) to JIS
 */
{
        return (code-0x8080);
}


ufix16 EUC2SJ(ufix16 code)
/*
 * Convert EUC (Extended Unix Code) to shift-JIS
 */
{
        return( xJIS2SJ( EUC2JIS( code ) ) );
}


ufix16 JIS2EUC( ufix16 code )
/* Convert JIS to EUC */
{
        return( code + 0x8080 );
}


void SJ2JIS( int *p1, int *p2 )
/*
 * Convert Shift-JIS to JIS
 */
{
        int c1 = *p1;
        int  c2 = *p2;
        int adjust = c2 < 159;
        int rowOffset = ( c1 < 160 ) ? 112 : 176;
        int cellOffset = adjust ? ( 31 + ( c2 > 127 ) ) : 126;

        *p1 = ( ( c1 - rowOffset ) << 1 ) - adjust;
        *p2 -= cellOffset;
}

ufix16 SJ2EUC( ufix16 code )
/*
 * Convert Shift-JIS to EUC
 */
{
        int converted;

        int word1 = ( code & 0xff ) >> 8;
        int word2 = code & 0xff;

        SJ2JIS( &word1, &word2 );
        converted = ( word1 << 8 ) + word2;

        return ( converted + 0x8080 );
}

void cspDetectEncoding( _kernel_swi_regs* r )
{
        /* String pointer to detect. */
        string_ptr = r->r[0];

        r->r[1] = DetectCodeType();
}

char GetFontChar( void )
{
        return( string_ptr[ string_pos++ ] );
}

/* Detects the wide enconding type (see enumeration) */
int DetectCodeType( void )
{
        int	c = 0;
        int	whatcode = ASCII;

        while( ( whatcode == EUCORSJIS || whatcode == ASCII ) && c != EOF )
        {
                if( ( c = GetFontChar() ) != EOF )
                {
                        if( c == ESC )
                        {
                                c = GetFontChar();
                                if( c == '$' )
                                {
                                        c = GetFontChar();
                                        if( c == 'B' )
                                        	whatcode = NEW;
                                        else if( c == '@' )
                                        	whatcode = OLD;
                                }
                                else if( c == 'K' )
                                	whatcode = NEC;
                        }
                        else if( ( c >= 129 && c <= 141 ) || (c >= 143 && c <= 159 ) )
                      		whatcode = SJIS;
                        else if( c == SS2 )
                        {
                                c = GetFontChar();
                                if( ( c >= 64 && c <= 126 ) || ( c >= 128 && c <= 160 ) ||
                                      	( c >= 224 && c <= 252 ) )
                                       	whatcode = SJIS;
                                else if( c >= 161 && c <= 223 )
                                       	whatcode = EUCORSJIS;
                        }
                        else if( c >= 161 && c <= 223 )
                        {
                                c = GetFontChar();
                                if( c >= 240 && c <= 254 )
                                       	whatcode = EUC;
                                else if( c >= 161 && c <= 223 )
                                      	whatcode = EUCORSJIS;
				else if( c >= 224 && c <= 239 )
				{
				        whatcode = EUCORSJIS;
				        while( c >= 64 && c != EOF && whatcode == EUCORSJIS )
				        {
				                if( c >= 129 )
				                {
				                        if( c <= 141 || ( c >= 143 && c <= 159 ) )
				                        	whatcode = SJIS;
				                        else if( c >= 253 && c <= 254 )
				                        	whatcode = EUC;
				                }
				                c = GetFontChar();
				        }
				}
				else if( c <= 159 )
					whatcode = SJIS;
			}
			else if( c >= 240 && c <= 254 )
				whatcode = EUC;
			else if( c >= 224 && c <= 239 )
			{
			        c = GetFontChar();
			        if( ( c >= 64 && c <= 126 ) || ( c >= 128 && c <= 160 ) )
			        	whatcode = SJIS;
			        else if( c >= 253 && 254 )
			        	whatcode = EUC;
			        else if( c >= 161 && c <= 252 )
			        	whatcode = EUCORSJIS;
			}
		}
	}
	return( whatcode );
}


ufix16 UNI2JIS( ufix8 *ucode_ptr )
/*
 * Convert from Unicode to JIS
 */
{
        return( NULL );
}


ufix16 SJ2UNI( ufix16 code )
/*
 * Convert from SJIS to Unicode
 */
{
	unsigned short c;

        /* Check for valid S-JIS char. */
	c = ( code >> 8 ) & 0xff;
	if( c < 129 || c > 239 || ( c > 159 && c < 224 ) )
	{
	        if( c > 160 && c < 224 )
	        {
	                code = xSJ2UNI( Han2Zen( code ) );
	                if(replog) fprintf(replog_file,"HanZen code %x\n", code);
	                return( code );
		}
		if( c > 31 && c < 127 )
		{
		        cvt_flags = 2; /* Single-byte. */
		        return( SJAS2UNI( c ) );
		}
		cvt_flags = 0;
	        return( 0 );/*err*/
	}
	c = ( code & 0xff );
	if( c < 64 || c > 252 || ( c == 127 ) )
	{
	        cvt_flags = 0; /* Invalid char. */
	        return( 0 );/*err*/
	}

	cvt_flags = -1; /* Valid char. */
/*	if(replog) fprintf(replog_file, "Searching unicode conversion char %li %p\n", code, (void *)uni_conv_tbl);*/

        c = ( uni_conv_tbl[ ( code - 0x8140UL ) ] );

/*        if(replog) fprintf(replog_file, "Found unicode conversion char.\n");*/
        return c;
}


ufix16 JIS2UNI( ufix16 code )
/*
 * Convert from JIS to Unicode
 */
{
        int c1 = ( code & 0xff ) >> 8;
        int c2 = ( code & 0xff );
        ufix16 temp;

        JIS2SJ( &c1, &c2 );
        temp = ( c1 << 8 ) + c2;
        return( SJ2UNI( temp ) );
}


/* Generate a metrics block for the given font file. */
void DoMetricsBlock( _kernel_swi_regs *r )
{
	int	lp;
	char*	metrics_ptr;

	switch( (char)r->r[5] )
	{
	        case 1:	/* Read length information. */
	        	r->r[2] = 1000L; /* Dummy for the time being. */
	        	printf("BS: Length read\n");
	        	return;

	        case 2: /* Read metrics information. */
			metrics_ptr = r->r[2];

			/* Font name. */
			for( lp = 0; lp < 40; lp++ )
			{
			        metrics_ptr[lp] = '\n';
			}
			for( lp = strlen( font_path ); font_path[ lp ] != '.'; --lp );
			strcpy( metrics_ptr, font_path + lp + 1 );

			/* Sizes (x, y). */
			metrics_ptr[ 40 ] = 16;
			metrics_ptr[ 41 ] = 0;
			metrics_ptr[ 42 ] = 0;
			metrics_ptr[ 43 ] = 0;
			metrics_ptr[ 44 ] = 16;
			metrics_ptr[ 45 ] = 0;
			metrics_ptr[ 46 ] = 0;
			metrics_ptr[ 47 ] = 0;

			/* Number of chars (low). */
			metrics_ptr[ 48 ] = 0;

			/* Version. */
			metrics_ptr[ 49 ] = 2;

			/* Flags. */
			metrics_ptr[ 50 ] = 39;
			/* No bbox, no x-off, no y-off, char map precedes map */

			/* Number of chars (high). */
			metrics_ptr[ 51 ] = 5;

			/* Character map. */
			metrics_ptr[ 52 ] = 0; /* No character map. */

			printf("BS: Metrics read\n");
			return;

		default:/* Oops. */
			assert( 0 );
			return;
	}
}


/* Close a font. */
void CloseFont( _kernel_swi_regs *r )
{
        if (replog) fprintf(replog_file, "BS: Closing font\n");
}


/* Convert JIS to S-JIS passing 16-bit types as parms. */
ufix16 xJIS2SJ( ufix16 code )
{
        int c1, c2;

        c1 = ( code >> 8 ) & 0xff;
        c2 = code & 0xff;

        JIS2SJ( &c1, &c2 );
        return( (c1 << 8) + c2 );
}


/* Convert S-JIS to JIS passing 16-bit types as parms. */
ufix16 xSJ2JIS( ufix16 code )
{
        int c1, c2;

	c1 = ( code >> 8 ) & 0xff;
	c2 = code & 0xff;

	SJ2JIS( &c1, &c2 );
	return( (c1 << 8) + c2 );
}


/* Convert S-JIS to JIS without setting global variables. */
ufix16 xSJ2UNI( ufix16 code )
{
        unsigned short c;

        /* Check for valid S-JIS char. */
	c = ( code >> 8 ) & 0xff;
	if( c < 129 || c > 239 || ( c > 159 && c < 224 ) )
	{
	        return( 0 );/*err*/
	}
	c = ( code & 0xff );
	if( c < 64 || c > 252 || ( c == 127 ) )
	{
	        return( 0 );/*err*/
	}
        return( uni_conv_tbl[ ( code - 0x8140UL ) ] );
}


/* Conversion from KSC (Korean) to Unicode */
ufix16 KSC2UNI( ufix16 code )
{
        unsigned short c;

        /* Check for valid KSC char. */
        c = ( code >> 8 ) & 0xff;
        if( c < 0xA1 || c > 0xfe )
        {
                return( 0 ); /* err */
        }
        c = ( code & 0xff );
        if( c < 0xA1 || c > 0xfe )
        {
                return( 0 ); /* err */
        }
        cvt_flags = -1;
        return( uni_conv_tbl[ ( code - 0x8140UL ) ] );
}


/* SWI implementation to convert between 16-bit encodings. */
/* Re-implement by converting all characters to Unicode, then to dest. encoding. */
void cspConvertCode( _kernel_swi_regs *r )
{
        int enc = current_encoding;

/*        if(replog) fprintf(replog_file, "cspConvertCode %x encoding %i\n", r->r[0], enc );*/

        switch( enc ) {
                case 0:	break;
                case 1: r->r[1] = SJ2UNI( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (SJ2UNI) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 2: r->r[1] = JIS2UNI( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (JIS2UNI) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 3:	r->r[1] = SJ2UNI( EUC2SJ( (ufix16) r->r[0] ) );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (SJ2UNI) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 4: r->r[1] = KSC2UNI( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (KSC2UNI) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 5: r->r[1] = SJ2UNI( EUC2SJ( (ufix16) r->r[0] ) );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (SJ2UNI) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 6: r->r[1] = xSJ2JIS( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (sSJ2JIS) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 7: r->r[1] = xJIS2SJ( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (xJIS2SJ) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 8: r->r[1] = SJ2EUC( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (SJ2EUC) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 9: r->r[1] = JIS2EUC( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (JIS2EUC) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 10: r->r[1] = EUC2SJ( (ufix16) r->r[0] );
			r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (EUC2SJ) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 11: r->r[1] = EUC2JIS( (ufix16) r->r[0] );
                	r->r[0] = cvt_flags;
                	if(replog)fprintf(replog_file,"cspOut (EUC2JIS) r1 %x    r0 %x\n", r->r[1], r->r[0]);
                	break;
                case 12: r->r[1] = UTF82UNI( r );
                    	r->r[0] = cvt_flags;
	}
	newkchar = r->r[1] & 0xffff;
}



/* Internal usage: convert between encodings. */
ufix16 ConvertCode( int enc, ufix16 wchar )
{
        switch( enc ) {
                case 0:	cvt_flags = -1;
                	return( wchar );
                case 1: return( SJ2UNI( wchar ) );
                case 2: return( JIS2UNI( wchar ) );
                case 3: return( SJ2UNI( EUC2SJ( wchar ) ) );
                case 4: return( KSC2UNI( wchar ) );
		case 5: return( SJ2UNI( EUC2SJ( wchar ) ) );
		case 6: return( xSJ2JIS( wchar ) );
                case 7: return( xJIS2SJ( wchar ) );
                case 8: return( SJ2EUC( wchar ) );
                case 9: return( JIS2EUC( wchar ) );
                case 10: return( EUC2SJ( wchar ) );
                case 11: return( EUC2JIS( wchar ) );
                case 12: return( UTF82UNI( glob_regs ) );
	}
}


/* SWI implementation to set the global encoding used for strings. */
void cspSetWideEncoding( _kernel_swi_regs *r )
{
        int this_enc;
	char fname[100];

        this_enc = (int)r->r[1];

        if(replog)fprintf(replog_file, "Status of font handle: %i %i\n", r->r[0], font_handles[r->r[0]]);
	if( font_handles[ r->r[0] ] != NULL )
		if( this_enc >= 0 && this_enc <= 12 )
	        {
	                current_encoding = this_enc;
		        font_handles[ r->r[0] ]->parent->encoding = this_enc;
		        if(replog)fprintf(replog_file,"Setting encoding to %i\n", this_enc);
	        }
}


/* Draw the character direct to the output device. Anti-aliasing not done.
 * Parameters have been set up in the previous call to CspSvcOutputChar.
 * In: R0 = 0 => 4-bpp, else 1-bpp (multiply coords by 4 when anti-aliasing)
 * Out: R0 -> buffer, R1 = size
 */
void cspDirectDraw( _kernel_swi_regs *r )
{
	if ( r->r[0] )
	{   	// divide by 16 for 1-bpp (or direct draw)
    		if(replog)fprintf(replog_file,"DRAWDIRECT Font size=%li, Char=%x\n", fontsize, newkchar);
		fontsize >>= 2;
    	    	x_step = fontsize << 4;
    		y_step = (fontsize-160) << 4;
    		xPosPix = fontsize << 4;
    		yPosPix = (fontsize-160) << 4;
        }
	else
	{   	// divide by 16 and multiply by 4 for anti-aliased output
    		if(replog)fprintf(replog_file,"DRAWANTI Font size=%li, Char=%x\n", fontsize, newkchar);
    		x_step = fontsize << 4;
    		y_step = (fontsize-20) << 5;
    		xPosPix = fontsize << 4;
    		yPosPix = (fontsize-20) << 5;
    	}

    	draw_index = 0;

	CspDoChar( newkchar, &xPosPix, &yPosPix );
	if( ( draw_index - object_start ) > 0 )
	{
		r->r[1] = draw_index * sizeof( long );
		DRAW_OBJECT_HDR2( DRAW_ENDPATH );
		r->r[0] = &draw_data;
		return;
        }

	CspDoChar( 0x3307, &xPosPix, &yPosPix );
	r->r[1] = draw_index * sizeof( long );
	DRAW_OBJECT_HDR2( DRAW_ENDPATH );
	r->r[0] = &draw_data;
}


/* Conversion table from single-byte S-JIS ASCII to Unicode. */
ufix16 SJAS2UNI( ufix16 acode )
{
        /* Temp hack to ensure valid code range. */
        if( acode < 32 ) acode += 32;
        while( acode > 126 ) acode -= 32;

        return( acode + 0xFEE0 );
}


int Check16Bit( char* filename )
{
        _kernel_osfile_block	ahar;
        unsigned long		ftype;
        char lfname [100];

        strcpy( lfname, "Font:" );
        strcatcr ( lfname, filename );
        strcat ( lfname, ".PFR0" );

	if( replog ) fprintf( replog_file, "Check16: %s\n", lfname );

        if( _kernel_osfile( 17, lfname, &ahar ) != 1 ) return( 1==0 );
        ftype = ( ahar.load & 0xfff00UL ) >> 8;
        return( ftype == 0xf92 );
}

/* Add handle to signify 16-bits. */
/* Check for redundant font sizes and allocate bitmap caches as appropriate. */
/* Entry: R0 = font handle                */
/*        R1 -> font name                 */
/*        R2 = font size (1/16th point)   */

void cspAddHandle( _kernel_swi_regs *r )
{
        unsigned short b_return;
        char fontname[40];
        char pathname[100];
        FILE *temp_file;
        long int pos;
        int font_index;
        int font_size;
        int font_handle;
        _wide_font_entry * font_parent;

        font_handle = r->r[0];
	font_size = r->r[2];
        strcpycr( fontname, (const char*)r->r[1] );

	if( font_size == 0xffffffff )
		font_size = 1;
//	else
//		font_size >>= 4;

	if( !Check16Bit( fontname ) ) return;

       	/* Add new-font-parent bit for duplicate parent fonts. !!!! */

	/* Construct main list or sub-list if main exists. */
        if(replog) fprintf(replog_file,"Adding new handle: %i with size %i\n", font_handle, font_size);
        if( flist_init->wide_font_name == NULL )
        {
                font_parent = flist_init;
        }
        else
        {
                font_parent = FontListFind( flist_init, fontname );
                if( font_parent == NULL )
                	font_parent = FontListCreate( flist_init );
        }

	/* Check for pre-existing font creation. */
	if( font_parent->wide_font_name == NULL )
	{
	        if(replog)fprintf(replog_file, "Creating new font %s\n", fontname );
	        /* No pre-existing font, so create one. */
		bit_init = 0;
		b_return = InitialiseBitstream( fontname );
		if( b_return == 0 || bit_init == 0 ) return;

    	    	/* Allocate memory and place font name in leaf */
		font_parent->bits_handle = b_return;
		font_parent->wide_font_name = calloc( (size_t)strlen(fontname)+1,(size_t)1 );
		strcpy( font_parent->wide_font_name, fontname );

		/* Open encoding file and read into allocated memory */
		sprintf( pathname, "Font:%s.Enc0", fontname );
		if(replog)fprintf(replog_file, "Opening file %s\n", pathname);
		temp_file = fopen( pathname, "rb" );
		assert( temp_file != 0 );
		fseek( temp_file, 0, SEEK_END );
		pos = ftell( temp_file );

    	    	/* Allocate memory for encoding for this FONT PARENT */
		font_parent->uni_conv_tbl = calloc( (size_t)pos+2, (size_t)1 );
		assert( font_parent->uni_conv_tbl != 0 );
		fseek( temp_file, 0, SEEK_SET );
		font_index = fread( font_parent->uni_conv_tbl, 1, pos, temp_file );
		if(replog)fprintf( replog_file,"%li objects read from %s\n",
			font_index,
			pathname );
		fclose( temp_file );
		uni_conv_tbl = font_parent->uni_conv_tbl;

    	    	/* Create sub font leaf entry for this size */
		font_child = FontSubCreate( font_parent, (short)font_size );
		assert( font_child != NULL );
		font_child->font_handle = font_handle;
		font_handles[ font_handle ] = font_child;
		glob_font = font_handle;
	}
	else /* Font already exists, but check for sub-font. */
	{
		if(replog)fprintf(replog_file, "Font already exists ... ");
		/* Find appropriate sub-font. */
		if( ( font_child = FontSubFind( font_parent, (short)font_size ) ) != NULL )
		{
			/* Font already created. */
			if(replog)fprintf(replog_file,"Already created sub-font\n");
			/* Initialise encoding table pointer */
			uni_conv_tbl = font_parent->uni_conv_tbl;
			font_handles[ font_handle ] = font_child;
			glob_font = font_handle;
		}
		else
		{
		        /* Create sub-font and add it to list. */
		        if(replog)fprintf(replog_file, "Creating sub-font...\n");
			font_child = FontSubCreate( font_parent, (short)font_size );
			assert( font_child != NULL );
			font_child->font_handle = font_handle;
			uni_conv_tbl = font_parent->uni_conv_tbl;
			font_handles[ font_handle ] = font_child;
			glob_font = font_handle;
		}
	}
	font_handles[ glob_font ]->parent->encoding = UTF8;	/* Default to UTF8 encoding. */
	if(replog)fprintf(replog_file, "Exiting AddHandle\n");
}


/* Check handle for 16-bittedness. */
void cspCheckHandle( _kernel_swi_regs *r )
{
        int current_font = r->r[0];

	if( font_handles[ current_font ] == NULL )
	{
	        r->r[0] = 0;
	        return;
	}

       	if( replog ) fprintf( replog_file, "Check handle %i ", current_font );
	r->r[ 0 ] = (unsigned long)((font_handles[ current_font ]->font_handle) != NULL ) ? 1 : 0;
	if( replog ) fprintf( replog_file, " result %i\n", r->r[0]);
	if( r->r[0] == 1 )
	{
	        uni_conv_tbl = font_handles[ current_font ]->uni_conv_tbl;
	        glob_font = current_font;
	        CspSetFont( font_handles[ current_font ]->parent->bits_handle );
	}
}


/* Check handle for 16-bittedness - withough affecting the unicode conversion table. */
void cspIsWideFont( _kernel_swi_regs* r )
{
        int handle = r->r[0];

        if( font_handles[ handle ] == NULL )
        {
                r->r[0] = 0;
        }
}


void cspCloseHandle( _kernel_swi_regs *r )
{
        int handle = r->r[0];

        if( replog ) fprintf( replog_file, "In cspCloseHandle\n" );

        if( font_handles[ handle ] != NULL )
        {
		if( replog ) fprintf(replog_file, "Closing handle %i[%s] with size %i\n",
				handle,
				font_handles[ handle ]->parent->wide_font_name,
				font_handles[ handle ]->font_size );

		if( FontSubRemove( font_handles[ handle ] ) == NULL )
		{
	        	if( replog ) fprintf( replog_file, "Null main list; removing all font info.\n" );
		}
	        font_handles[ handle ] = NULL;
        }
}


ufix16 Han2Zen( ufix16 code )
{
        int maru = FALSE;
        int nigori = FALSE;
        static int p1, p2, tmp;
        static int mtable[][2] = {
	    {129,66},{129,117},{129,118},{129,65},{129,69},{131,146},{131,64},
	    {131,66},{131,68},{131,70},{131,72},{131,131},{131,133},{131,135},
	    {131,98},{129,91},{131,65},{131,67},{131,69},{131,71},{131,73},
	    {131,74},{131,76},{131,78},{131,80},{131,82},{131,84},{131,86},
	    {131,88},{131,90},{131,92},{131,94},{131,96},{131,99},{131,101},
	    {131,103},{131,105},{131,106},{131,107},{131,108},{131,109},
	    {131,110},{131,113},{131,116},{131,119},{131,122},{131,125},
	    {131,126},{131,128},{131,129},{131,130},{131,132},{131,134},
	    {131,136},{131,137},{131,138},{131,139},{131,140},{131,141},
	    {131,143},{131,147},{129,74},{129,75}
	};

	p1 = tmp = ( code >> 8 ) & 0xff;
	p2 = code & 0xff;

	cvt_flags = 1; /* Reset flags to indicate 2-byte o/p with 1-byte i/p. */

	if( p2 == 222 )
	{
	        if( ISNIGORI( p1 ) )
	        {
	                nigori = TRUE;
/*	                cvt_flags = 2;*/
	        }
	}
	else if( p2 == 223 )
	{
		if( ISMARU ( p1 ) )
		{

		        maru = TRUE;
/*		        cvt_flags = 2;*/
		}
	}

	p1 = mtable[ tmp - 161 ][ 0 ];
	p2 = mtable[ tmp - 161 ][ 1 ];

	if( nigori )
	{
		if ((p2 >= 74 && p2 <= 103) || (p2 >= 110 && p2 <= 122)) p2++;
		else if (p1 == 131 && p2 == 69) p2 = 148;
	}
	else if (maru && p2 >= 110 && p2 <= 122) p2 += 2;

	code = ( p1 << 8 ) + p2;

	return( code );
}


/* Convert UTF-8 to UCS-4. */
ufix16 UTF82UNI( _kernel_swi_regs *r )
{
        unsigned int  z, y, x, w, v, u;
        unsigned int result;

	cvt_flags = 0;

	z = *((char *)(r->r[4]));
	if( z <= 0x7f )
	{
	        if( z < 32 )
	        {
	                cvt_flags = 0;
	                return( z );
	        }

	        /* Single byte.*/
	        if( z == 0 )
	        	cvt_flags = 0;
	        else
	        	cvt_flags = 2;
	        return ( z );
	}

	y = *( (char *)((r->r[4]) + 1) );
	if( z <= 0xdf && z >= 0xc0 )
	{
	        cvt_flags = -1;
	        return ((( z - 0xc0 ) << 6) + ( y - 0x80 ));
	}

	x = *( (char *)((r->r[4]) + 2 ) );
	if( z <= 0xef && z >= 0xe0 )
	{
	        r->r[4] += 1;
	        cvt_flags = -1;
	        if( replog ) fprintf(replog_file, "z = %i, y = %i, x = %i", z, y, x);
		return ((( z - 0xe0 ) << 12) + (( y - 0x80 ) << 6) + ( x - 0x80 ));
	}

	w = *( (char *)((r->r[4]) + 3 ) );
	if( z <= 0xf7 && z >= 0xf0 )
	{
	        r->r[4] += 2;
	        cvt_flags = -1;
		return ((( z - 0xf0 ) << 18) + (( y - 0x80 ) << 12) + (( x - 0x80 ) << 6) + ( w - 0x80 ));
	}

	v = *( (char *)((r->r[4]) + 4 ) );
	if( z <= 0xfb && z >= 0xf8 )
	{
	        r->r[4] += 3;
	        cvt_flags = -1;
		return ((( z - 0xf8 ) << 24) + (( y - 0x80 ) << 18) + (( x - 0x80 ) << 12) +
					(( w - 0x80 ) << 6) + ( v - 0x80));
	}

	u = *( (char *)((r->r[4]) + 5 ) );
	if( z == 0xfc || z == 0xfd )
	{
	        r->r[4] += 4;
	        cvt_flags = -1;
		return ((( z - 0xfc ) << 30) + (( y - 0x80 ) << 24) + (( x - 0x80 ) << 18) +
					(( w - 0x80 ) << 12) + (( v - 0x80 ) << 6) + ( u - 0x80 ));
	}

	return 0;
}


void cspShowFontTree( _kernel_swi_regs* r )
{
        _wide_font_entry* font_iter1;
        font_l* font_iter2;

	printf("Widefonts cached: \n");
	font_iter1 = flist_init;
	while( font_iter1 != NULL )
	{
	        printf("   %s at ", font_iter1->wide_font_name);
	        font_iter2 = font_iter1->font_head;
	        while( font_iter2 != NULL )
	        {
	                printf("%i", font_iter2->font_size);
	                font_iter2 = font_iter2->next;
	                if( font_iter2 != NULL ) printf(", ");
	                else printf(" points.\n");
	        }
	        font_iter1 = font_iter1->next;
	}
}


/* Simplified cache just to see if the damned thing works. */
void cspTestCacheChar( _kernel_swi_regs *r )
{
        if(replog)fprintf(replog_file,"Testing cache for char %x ... ", r->r[0]);
	r->r[1] = cache_sema[newkchar];
	if(replog)fprintf(replog_file," %x\n", r->r[1]);
}


/* Debugging thing to print registers. */
void PrintRegisters( _kernel_swi_regs* r )
{
        if(replog) fprintf(replog_file,"r0[%8x]  r1[%8x]%s  r2[%8x]  r3[%8x]  r4[%8x] r5[%8x]\n",
        		   r->r[0],r->r[1],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5]);
}


/* void main( void )
{
        font_l * new_entry;

	flist1 = FontListInit();
	flist1->wide_font_name = malloc( sizeof( char ) * 20 );
	strcpy( flist1->wide_font_name, "TestFont1" );
	flist1->bits_handle = -1;

	if( FontSubCreate( flist1, 12 ) != NULL ) printf("Succ with font 12\n");
	if( FontSubCreate( flist1, 3 ) != NULL ) printf("Succ with font 3\n");

	if( FontSubFind( flist1, 12 ) != NULL ) printf("Found 12\n");
	if( FontSubDelete( flist1, 12 )!= NULL ) printf("Deleted 12\n");
	if( FontSubFind( flist1, 3 ) != NULL ) printf("Found 3\n");
	if( FontSubDelete( flist1, 3 )!= NULL ) printf("Deleted 3\n");
	if( FontSubFind( flist1, 4 ) == NULL ) printf("Couldn't find 4 (correct)\n");
	if( FontSubDelete( flist1, 4 ) == NULL ) printf("Couldn't delete 4 (correct)\n");
	if( FontListFind( flist1, "TestFont1" ) != NULL ) printf("Successfully found TestFont1\n");
	if( FontListFind( flist1, "siojadflk" ) == NULL ) printf("Successfully found invalid fontname\n");
}
*/
