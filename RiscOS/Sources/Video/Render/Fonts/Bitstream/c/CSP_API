/*****************************************************************************
*                                                                            *
*                        Copyright 1993 - 95                                 *
*          as an unpublished work by Bitstream Inc., Cambridge, MA           *
*                                                                            *
*         These programs are the sole property of Bitstream Inc. and         *
*           contain its proprietary and confidential information.            *
*                                                                            *
*****************************************************************************/



/*************************** C S P _ A P I . C *******************************
 *                                                                           *
 * Character shape player application program interface module.              *
 *                                                                           *
 ********************** R E V I S I O N   H I S T O R Y **********************
 *                                                                           *
 *  Changes since TrueDoc Release 2.0:                                       *
 *
 *     $Header$
 *
 *     $Log$
 * Revision 4.1  96/03/05  13:44:54  mark
 * Release
 *
 * Revision 3.1  95/12/29  10:28:28  mark
 * Release
 *
 * Revision 2.1  95/12/21  09:45:25  mark
 * Release
 *
 * Revision 1.5  95/10/13  14:15:57  john
 * SetBitmap() callback is now skipped if there is no bitmap image.
 * The current position, however is still updated.
 *
 * Revision 1.4  95/09/18  18:10:37  john
 * Added CspSetMissingChar() and CspUnsetMissingChar() as new API functions.
 * Modified CspDoString() and CspDoStringWidth() to substitute the missing
 * character code for character codes that are not found.
 *
 * Revision 1.3  95/08/15  16:39:26  john
 * Font bounding box adjustment done by CspGetFontSpecs for
 *     stroked and bold fontStyle is now inhibited if
 *     bold/stroke thickness is negative.
 *
 * Revision 1.2  95/08/13  14:35:01  john
 * CspSetPfr now resets current font to 0xffff.
 * CspSetFont now requires a font to be selected as well
 *     as no change in fontCode for a no font change exit.
 *
 * Revision 1.1  95/08/10  16:44:18  john
 * Initial revision
 *
 *                                                                           *
 ****************************************************************************/

#ifndef CSP_DEBUG
#define CSP_DEBUG   2
#endif

#if CSP_DEBUG
#include <stdio.h>
#endif

#include "csp_int.h"                    /* Public and internal header */

#if PROC_TRUEDOC || (! INCL_TPS)

#if INCL_CACHE
#include "cachemgr.h"
#endif

#if CSP_DEBUG
#include "csp_dbg.h"
#endif

#if REENTRANT
#else
cspGlobals_t *pCspGlobals;
#if INCL_CACHE
void *pCmGlobals;
#endif
#endif

#if !INCL_TPS || REENTRANT
#undef sp_globals
#define sp_globals ((cspGlobals_t *)pCspGlobals)->spGlobals
#endif

/* Character shape player state for calling sequence checking */
#define CSPOPENMASK        0x3fff
#define CSPOPEN            0x3a5b
#define CSPOUTPUTSPECSSET  0x4000
#define CSPFONTSELECTED    0x8000

/* CspDoChar skips updating current position when escapement
 * vector does not intersect output bounding box
 * Allowed values are:
 *  0: Always update current position
 *  1: Skip update if appropriate
 */
#ifndef DO_CHAR_OPTION_1
#define DO_CHAR_OPTION_1   1
#endif


FUNCTION
int CspInitBitmapCache(
	PCACONTEXT
    void *pBuffer,
    long nBytes)
/*
 *  Initializes the bitmap cache
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 */
{
#if INCL_CACHE
#if REENTRANT
void *pCmGlobals;
#endif

CmInitializeCache(&pCmGlobals, nBytes, (char *)pBuffer);

#if REENTRANT
*pCacheContext = pCmGlobals;
#else
if (pCspGlobals != NULL)
    ((cspGlobals_t *)pCspGlobals)->pCmGlobals = pCmGlobals;
#endif
#endif

return CSP_NO_ERR;
}


FUNCTION
int CspSetCacheParams(
     PCONTEXT
     short int enabled,
     short int capacity,
     short int pixelColor,
     short int alignment,
     short int inverted)
/*
 *  Initializes the bitmap cache
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 */
{
#if INCL_CACHE
if (((cspGlobals_t *)pCspGlobals)->pCmGlobals == NULL)
    return CSP_NO_ERR;

if (capacity == -1)
    capacity = CACHE_CAPACITY;
if (pixelColor == -1)
    pixelColor = BLACK_PIXEL;
if (alignment == -1)
    alignment = BMAP_ALIGNMENT;
if (inverted == -1)
    inverted = INVERT_BITMAP;

if ((ufix8)pixelColor !=
    ((cmGlobals_t *)(((cspGlobals_t *)pCspGlobals)->pCmGlobals))->blackPixel ||
    (ufix16)alignment !=
    ((cmGlobals_t *)(((cspGlobals_t *)pCspGlobals)->pCmGlobals))->bitmapAlignment ||
    (boolean)inverted !=
    ((cmGlobals_t *)(((cspGlobals_t *)pCspGlobals)->pCmGlobals))->invertBitmap)
    {
    CmReinitCache((cspGlobals_t *)pCspGlobals);
    }

CmInitParams(
    (cspGlobals_t *)pCspGlobals,
    enabled,
    capacity,
    pixelColor,
    alignment,
    inverted);
#endif

return CSP_NO_ERR;
}


FUNCTION
int CspOpen(
	PREENT
    short deviceResolution,
    int (*ReadResourceData)(
        void *pBuffer,
        short nBytes,
        long offset
        USERPARAM),
    void *(*AllocCspBuffer)(
        long minBuffSize,
        long normalBuffSize,
        long maxBuffSize,
        long *pNBytes
        USERPARAM)
    USERPARAM)
/*
 *  Standard function for opening the character shape player for one PFR
 *  accessed via a specified callback function.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_BUFFER_OVERFLOW_ERR  2  Insufficient memory allocated
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_PFR_FORMAT_ERR       4  Portable Font Resource format error
 */
{
cspPfrAccess_t pfrAccessTable[1];

pfrAccessTable[0].mode = PFR_ACCESS_INDIRECT;
pfrAccessTable[0].access.ReadResourceData = ReadResourceData;
return CspOpenAlt1(
#if REENTRANT
    pContext,
    pCmGlobals,
#endif
    deviceResolution,
    1,
    pfrAccessTable,
    AllocCspBuffer
#if REENTRANT
    , userParam
#endif
    );
}

FUNCTION
int CspOpenAlt1(
	PREENT
    short deviceResolution,
    short nPfrs,
    cspPfrAccess_t pfrAccessTable[],
    void *(*AllocCspBuffer)(
        long minBuffSize,
        long normalBuffSize,
        long maxBuffSize,
        long *pNBytes
        USERPARAM)
    USERPARAM)
/*
 *  Alternative function for initializing the character shape player.
 *  Either this function or CspOpen() should be called to open the player.
 *  This one handles any combination of multiple and/or pre-loaded PFRs.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_BUFFER_OVERFLOW_ERR  2  Insufficient memory allocated
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_PFR_FORMAT_ERR       4  Portable Font Resource format error
 */
{
#if REENTRANT
cspGlobals_t *pCspGlobals;
#endif
pfrHeaderData_t pfrHeaderData;
fix31   minBuffSize;
fix31   normalBuffSize;
fix31   maxBuffSize;
long    nBytes;
void   *pBuffer;
int     errCode;

/* Extract data from PFR headers */
errCode = CspGetPfrHeaderData(
    deviceResolution,
    nPfrs,
    pfrAccessTable,
    &pfrHeaderData
#if REENTRANT
    , userParam
#endif
    );
if (errCode != 0)
    {
    return errCode;
    }

/* Figure out how much memory we need for PFR execution */
CspDoMemoryBudget(
    nPfrs,
    pfrAccessTable,
    &pfrHeaderData,
    &minBuffSize,
    &normalBuffSize,
    &maxBuffSize);

/* Ask the client to allocate a memory buffer */
pBuffer = AllocCspBuffer(
    (long)minBuffSize,
    (long)normalBuffSize,
    (long)maxBuffSize,
    &nBytes
#if REENTRANT
    ,userParam
#endif
    );
if (nBytes < minBuffSize)       /* Less than min requested? */
    {
    return CSP_BUFFER_OVERFLOW_ERR;
    }

/* Initialize the CSP memory manager; allocate global structure */
if (!CspInitAlloc(
    &pCspGlobals,
    pBuffer,
    nBytes))
    {
    return CSP_BUFFER_OVERFLOW_ERR;
    }

/* Save user parameter as a global */
#if REENTRANT
    pCspGlobals->userArg = userParam;
#endif

/* Allocate memory and set up internal data structures */
errCode = CspSetupMemory(
    pCspGlobals,
    nPfrs,
    pfrAccessTable,
    &pfrHeaderData);
if (errCode != 0)
    {
    return errCode;
    }

/*  Clear out any previously cached characters */
#if INCL_CACHE
pCspGlobals->pCmGlobals = pCmGlobals;
CmReinitCache(pCspGlobals);
#endif

/* Mark CSP open */
pCspGlobals->cspState = CSPOPEN;

/* Initialize missing character mechanism */
pCspGlobals->missingCharCode = 0;
pCspGlobals->missingCharActive = FALSE;

/* Return pointer to CSP context (if re-entrant) */
#if REENTRANT
*pContext = (void *)pCspGlobals;
#endif

return CSP_NO_ERR;
}

FUNCTION
int CspSetMissingChar(
    PCONTEXT
    unsigned short missingCharCode)
/*
 *  Enables missing character substitution for string processing
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 */
{
/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

((cspGlobals_t *)pCspGlobals)->missingCharCode = missingCharCode;
((cspGlobals_t *)pCspGlobals)->missingCharActive = TRUE;

return CSP_NO_ERR;
}

FUNCTION
int CspUnsetMissingChar(PCONTEXT1)
/*
 *  Disables missing character substitution.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 */
{
/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

((cspGlobals_t *)pCspGlobals)->missingCharActive = FALSE;

return CSP_NO_ERR;
}

FUNCTION
int CspSetPfr(
    PCONTEXT
    short pfrCode)
/*
 *  Selects the specified portable font resource.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_PFR_CODE_ERR        11  PFR code out of range
 */
{
/* Check CSP is open */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

/* Check PFR code is valid */
if (pfrCode >= ((cspGlobals_t *)pCspGlobals)->nPfrs)
    {
    return CSP_PFR_CODE_ERR;
    }

/* Save user-selected PFR code */
((cspGlobals_t *)pCspGlobals)->userPfrCode = pfrCode;

/* Mark no font selected */
((cspGlobals_t *)pCspGlobals)->cspState &= ~CSPFONTSELECTED;
((cspGlobals_t *)pCspGlobals)->fontCode = 0xffff;

return CSP_NO_ERR;
}

FUNCTION
unsigned short CspGetFontCount(
    PCONTEXT1)
/*
 *  Returns a count of the number of fonts in the current portable
 *  font resource (zero if CSP is not open).
 *  If multiple PFRs are active, the value returned is normally
 *  the total number of fonts over the set of PFRs. If a specific
 *  PFR has been selected by calling CspSetPfr(), the number returned
 *  applies only to the currently selected PFR.
 *
 */
{
fix15   pfrCode;

if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)                    /* CSP not open? */
    {
    return 0;
    }

pfrCode = ((cspGlobals_t *)pCspGlobals)->userPfrCode;
if (pfrCode >= 0)               /* Local font numbering? */
    {
    return ((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].nLogicalFonts;
    }
else                            /* Global font numbering? */
    {
    return ((cspGlobals_t *)pCspGlobals)->nLogicalFonts;
    }
}


#if CSP_MAX_DYNAMIC_FONTS > 0
FUNCTION
int CspCreateDynamicFont(
    PCONTEXT
    char *pFontID,
    short attrOutlRes,
    fontAttributes_t *pFontAttributes,
    unsigned short *pFontCode)
/*
 *  Creates a new dynamic logical font based on the physical font with the
 *  specified font ID and the specified attributes. Attribute fields in
 *  outline resolution units are based on the specified attribute outline
 *  resolution.
 *  Sets *pFontCode to the global logical font code of the new font.
 *  The newly created font is _not_ automatically selected.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_FONT_STYLE_ERR       9  Illegal value for fontStyle
 *      CSP_LINE_JOIN_TYPE_ERR  10  Illegal value for lineJoinType
 *      CSP_FONT_ID_ERR         12  Font ID not found
 *      CSP_DYN_FONT_OFLO_ERR   13  Dynamic font table overflow
 */
{
/* Check CSP is open */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

return CspCreateNewFont(
    (cspGlobals_t *)pCspGlobals,
    pFontID,
    attrOutlRes,
    pFontAttributes,
    pFontCode);
}
#endif

#if CSP_MAX_DYNAMIC_FONTS > 0
FUNCTION
int CspDisposeDynamicFont(
    PCONTEXT
    unsigned short fontCode)
/*
 *  Reverses the result of calling CspCreateDynamicFont() for the
 *  specified global font code.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_FONT_CODE_ERR        5  Font code out of range
 */
{
/* Check CSP is open */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

/* Remove the dynamic font and exit */
return CspDisposeNewFont(
    (cspGlobals_t *)pCspGlobals,
    fontCode);
}
#endif

#if CSP_MAX_DYNAMIC_FONTS > 0
FUNCTION
unsigned short CspGetDynamicFontCount(
    PCONTEXT1)
/*
 *  Returns a count of the number of fonts created by CspCreateDynamicFont()
 *  that have not been destroyed by calling CspDestroyDynamicFont().
 */
{
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)                    /* CSP not open? */
    {
    return 0;
    }

return (unsigned short)(((cspGlobals_t *)pCspGlobals)->nNewFonts);
}
#endif



FUNCTION
int CspSetFont(
    PCONTEXT
    unsigned short fontCode)
/*
 *  Selects the specified font.
 *  If global font numbering is in effect and multiple PFRs are open,
 *  the appropriate PFR is determined from the font number.
 *  If local font numbering is in effect, the specified font number
 *  is converted into a global font code.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_FONT_CODE_ERR        5  Font code out of range
 */
{
fix15   pfrCode;
int     errCode;

/* Check CSP is open */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if CSP_MAX_DYNAMIC_FONTS > 0
/* Check if font code refers to dynamic font */
if (fontCode >= ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    /* Exit if the requested font is already selected */
    if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPFONTSELECTED) &&
        (fontCode == ((cspGlobals_t *)pCspGlobals)->fontCode))
        {
        return CSP_NO_ERR;
        }

    /* Load and select dynamic font */
    errCode = CspSetNewFont((cspGlobals_t *)pCspGlobals, fontCode);
    if (errCode != 0)
        return errCode;

    /* Mark font selected */
    ((cspGlobals_t *)pCspGlobals)->cspState |= CSPFONTSELECTED;

    /* Set up data paths and transformation constants */
    if (((cspGlobals_t *)pCspGlobals)->cspState & CSPOUTPUTSPECSSET)
        {
        errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
        if (errCode != 0)
            return errCode;
        }
    return CSP_NO_ERR;
    }

((cspGlobals_t *)pCspGlobals)->pNewFont = NULL;
#endif

/* Check font code; convert it to global numbering */
pfrCode = ((cspGlobals_t *)pCspGlobals)->userPfrCode;
if (pfrCode >= 0)           /* Local font numbering? */
    {
    if (fontCode >=
        ((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].nLogicalFonts)
        {
        return CSP_FONT_CODE_ERR;
        }
    fontCode +=
        ((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].baseFontCode;
    }
else                        /* Global font numbering? */
    {
    if (fontCode >= ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
        {
        return CSP_FONT_CODE_ERR;
        }
    for (
        pfrCode = 0;
        (fontCode >=
         (((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].baseFontCode +
          ((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].nLogicalFonts));
        pfrCode++)
        {
        }
    }

/* Exit if the requested font is already selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPFONTSELECTED) &&
    (fontCode == ((cspGlobals_t *)pCspGlobals)->fontCode))
    {
    return CSP_NO_ERR;
    }

/* Load and select specified logical font */
errCode = CspLoadLogicalFont(
    ((cspGlobals_t *)pCspGlobals),
    pfrCode,
    fontCode);
if (errCode != 0)
    return errCode;

/* Mark font selected */
((cspGlobals_t *)pCspGlobals)->cspState |= CSPFONTSELECTED;

/* Set up data paths and transformation constants */
if (((cspGlobals_t *)pCspGlobals)->cspState & CSPOUTPUTSPECSSET)
    {
    errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }

return CSP_NO_ERR;
}


FUNCTION
int CspGetFontSpecs(
    PCONTEXT
    unsigned short *pFontRefNumber,
    cspFontInfo_t *pFontInfo,
    fontAttributes_t *pFontAttributes)
/*
 *  Responds with information about the currently selected font.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 */
{
fix15   pfrCode;
int     errCode;

/* Verify CSP is open and a font is selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if CSP_MAX_DYNAMIC_FONTS > 0
if (((cspGlobals_t *)pCspGlobals)->fontCode >=
    ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    errCode = CspGetNewFontSpecs(
        (cspGlobals_t *)pCspGlobals,
        pFontRefNumber,
        pFontInfo,
        pFontAttributes);
    if (errCode != 0)
        return errCode;
    goto L1;
    }
#endif

*pFontRefNumber = ((cspGlobals_t *)pCspGlobals)->fontRefNumber;
pfrCode = ((cspGlobals_t *)pCspGlobals)->userPfrCode;
if (pfrCode < 0)            /* Global font numbering? */
    {
    pfrCode = ((cspGlobals_t *)pCspGlobals)->physFontPfrCode;
    *pFontRefNumber +=
        ((cspGlobals_t *)pCspGlobals)->pfrTable[pfrCode].baseFontCode;
    }

*pFontInfo =
    ((cspGlobals_t *)pCspGlobals)->fontInfo;

*pFontAttributes =
    ((cspGlobals_t *)pCspGlobals)->fontAttributes;

L1:

#if INCL_STROKE || INCL_BOLD
    /* Adjust font information fields for derivative fonts */
    {
    fix15   strokeThickness;
    fix31   miterLimit;
    short   bboxAdj;
    fix15   ii;

    switch (((cspGlobals_t *)pCspGlobals)->fontAttributes.fontStyle)
        {

#if INCL_STROKE
    case STROKED_STYLE:
        strokeThickness =
            pFontAttributes->styleSpecs.styleSpecsStroked.strokeThickness;
        pFontInfo->stdVW = strokeThickness;
        pFontInfo->stdHW = strokeThickness;
        miterLimit = pFontAttributes->styleSpecs.styleSpecsStroked.miterLimit;
        goto L2;
#endif

#if INCL_BOLD
    case BOLD_STYLE:
        strokeThickness =
            pFontAttributes->styleSpecs.styleSpecsBold.boldThickness;
        pFontInfo->stdVW += strokeThickness;
        pFontInfo->stdHW += strokeThickness;
        miterLimit = 0x40000;
        goto L2;
#endif

    L2:
        bboxAdj = (short)(
            (strokeThickness * (miterLimit + 0x10000) + 0x1ffff) >> 17);
        if (bboxAdj > 0)
            {
            pFontInfo->fontBBox.xmin -= bboxAdj;
            pFontInfo->fontBBox.ymin -= bboxAdj;
            pFontInfo->fontBBox.xmax += bboxAdj;
            pFontInfo->fontBBox.ymax += bboxAdj;
            }

        for (ii = 0; ii < pFontInfo->nBlueValues; ii++)
            {
            ((cspGlobals_t *)pCspGlobals)->pAdjBlueValues[ii] =
                pFontInfo->pBlueValues[ii];
            if (ii >= 2)
                ((cspGlobals_t *)pCspGlobals)->pAdjBlueValues[ii] += strokeThickness;
            }
        pFontInfo->pBlueValues =
            ((cspGlobals_t *)pCspGlobals)->pAdjBlueValues;
        }
    }
#endif

return CSP_NO_ERR;
}


FUNCTION
int CspListChars(
    PCONTEXT
    int (*ListCharFn)(
        PCONTEXT
        unsigned short charCode
        USERPARAM))
/*
 *  Calls the specified function once for each character in the
 *  currently selected font. The calls are in increasing order of
 *  character code.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_LIST_CHAR_FN_ERR     6  ListCharFn() returned error
 */
{
ufix8  *pChar;
ufix8  *pByte;
ufix16  charCode;
fix31   iChar;
int     errCode;

/* Verify CSP is open and a font is selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if CSP_MAX_DYNAMIC_FONTS > 0
if (((cspGlobals_t *)pCspGlobals)->fontCode >=
    ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    errCode = CspListNewFontChars(
        (cspGlobals_t *)pCspGlobals,
        ListCharFn);
    if (errCode != 0)
        return errCode;
    }
else                            /* PFR font? */
#endif
    {
    /* Loop over list of characters */
    pChar = ((cspGlobals_t *)pCspGlobals)->pFirstChar;
    for (
        iChar = 0;
        iChar < (fix31)((cspGlobals_t *)pCspGlobals)->fontInfo.nCharacters;
        iChar++)
        {
        pByte = pChar;
        pChar += ((cspGlobals_t *)pCspGlobals)->charRecSize;
        charCode = (((cspGlobals_t *)pCspGlobals)->charFormat & BIT_1)?
            (ufix16)NEXT_WORD(pByte):
            (ufix16)NEXT_BYTE(pByte);
        errCode = ListCharFn(
#if REENTRANT
            pCspGlobals,
#endif
            charCode
            USERARG);

        if (errCode != 0)
            return CSP_LIST_CHAR_FN_ERR;
        }
    }

return CSP_NO_ERR;
}


FUNCTION
int CspGetCharSpecs(
    PCONTEXT
    unsigned short charCode,
    cspCharInfo_t *pCharInfo)
/*
 *  Responds with information about the specified character in
 *  the currently selected font.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 */
{
fix15   outlineResolution;
outputSpecs_t outputSpecs;
fontAttributes_t fontAttributes;
int     errCode;

/* Verify CSP is open and a font is selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if CSP_MAX_DYNAMIC_FONTS > 0
if (((cspGlobals_t *)pCspGlobals)->fontCode >=
    ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    errCode = CspLoadTopPhysFont((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }
#endif

outlineResolution =
    ((cspGlobals_t *)pCspGlobals)->fontInfo.outlineResolution;

/* Save current output specs and font attributes */
outputSpecs = ((cspGlobals_t *)pCspGlobals)->outputSpecs;
fontAttributes = ((cspGlobals_t *)pCspGlobals)->fontAttributes;

/* Change font attributes for unit font matrix */
((cspGlobals_t *)pCspGlobals)->fontAttributes.fontMatrix[0] = 1L << 16;
((cspGlobals_t *)pCspGlobals)->fontAttributes.fontMatrix[1] = 0L << 16;
((cspGlobals_t *)pCspGlobals)->fontAttributes.fontMatrix[2] = 0L << 16;
((cspGlobals_t *)pCspGlobals)->fontAttributes.fontMatrix[3] = 1L << 16;

/* Change output type for bounding box collection */
((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType = 0;

/* Change output matrix to scale to outline resolution units */
((cspGlobals_t *)pCspGlobals)->outputSpecs.specs.charBBox.outputMatrix[0] =
((cspGlobals_t *)pCspGlobals)->outputSpecs.specs.charBBox.outputMatrix[3] =
    (fix31)outlineResolution << 16;
((cspGlobals_t *)pCspGlobals)->outputSpecs.specs.charBBox.outputMatrix[1] =
((cspGlobals_t *)pCspGlobals)->outputSpecs.specs.charBBox.outputMatrix[2] =
    0L;

/* Set up data paths and transformation constants */
errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
if (errCode != 0)
    return errCode;

/* Execute the specified character (image generation enabled) */
errCode = CspExecChar(
    ((cspGlobals_t *)pCspGlobals),
    charCode,
    FALSE);
if (errCode == 0)
    {
    /* Extract escapement vector */
    pCharInfo->hWidth = (short)(
        (sp_globals.set_width.x + 32768L) >> 16);
    pCharInfo->vWidth = (short)(
        (sp_globals.set_width.y + 32768L) >> 16);

    /* Extract character bounding box */
    pCharInfo->charBBox.xmin =
        (sp_globals.xmin +
         sp_globals.pixrnd) >>
        sp_globals.pixshift;
    pCharInfo->charBBox.ymin =
        (sp_globals.ymin +
         sp_globals.pixrnd) >>
        sp_globals.pixshift;
    pCharInfo->charBBox.xmax =
        (sp_globals.xmax +
         sp_globals.pixrnd) >>
        sp_globals.pixshift;
    pCharInfo->charBBox.ymax =
        (sp_globals.ymax +
         sp_globals.pixrnd) >>
        sp_globals.pixshift;
    }

/* Restore output specs and font attributes */
((cspGlobals_t *)pCspGlobals)->outputSpecs = outputSpecs;
((cspGlobals_t *)pCspGlobals)->fontAttributes = fontAttributes;

/* Restore data paths and transformation constants */
if (((cspGlobals_t *)pCspGlobals)->cspState & CSPOUTPUTSPECSSET)
    {
    errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }

return errCode;
}


FUNCTION
int CspSetOutputSpecs(
    PCONTEXT
    outputSpecs_t *pOutputSpecs)
/*
 *  Selects the specified output mode and saves a copy of the associated
 *  information in global variables.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_OUTPUT_TYPE_ERR      8  Undefined output type
 *      CSP_PIXEL_SIZE_ERR      14  Pixel size out of range
 */
{
int     errCode;

/* Verify CSP is open */
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)
    {
    return CSP_CALL_SEQUENCE_ERR ;
    }

/* Save requested output specifications */
((cspGlobals_t *)pCspGlobals)->outputSpecs = *pOutputSpecs;

switch (pOutputSpecs->outputType)
    {
case BITMAP_OUTPUT:
    break;

case OUTLINE_OUTPUT:
    break;

#if INCL_DIR
case DIRECT_OUTPUT:
    break;
#endif

#if INCL_ANTIALIASED_OUTPUT
case ANTIALIASED_OUTPUT:
    if ((pOutputSpecs->specs.pixmap.pixelSize < 1) ||
        (pOutputSpecs->specs.pixmap.pixelSize > 8))
        {
        return CSP_PIXEL_SIZE_ERR;
        }

    /* Switch to bitmap output if requested pixel size is 1 */
    if (pOutputSpecs->specs.pixmap.pixelSize == 1)
        {
        ((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType = BITMAP_OUTPUT;
        }
    break;
#endif

default:
    return CSP_OUTPUT_TYPE_ERR;
    }

/* Flag output specs set */
((cspGlobals_t *)pCspGlobals)->cspState |= CSPOUTPUTSPECSSET;

/* Set up data paths and transformation constants */
if (((cspGlobals_t *)pCspGlobals)->cspState & CSPFONTSELECTED)
    {
    errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }

return CSP_NO_ERR;
}

FUNCTION
int CspDoChar(
    PCONTEXT
    unsigned short charCode,
    long *pXpos,
    long *pYpos)
/*
 *  Executes the specified character from the currently selected font
 *  for the currently selected output specifications.
 *  In bitmap or antialiased output mode, a bitmap (or pixel map) of the
 *  specified character is generated and written at the specified position
 *  in device coordinates.
 *  After the bitmap is written, the position is incremented by the
 *  character escapement.
 *  In outline output mode, the transformed character hints and outline
 *  are delivered by calls to the outline output callback functions.
 *  In direct output mode, the transformed outline is delivered by calls
 *  to the direct output callback functions.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 *      CSP_CACHE_ERR           -1  Internal cache error
 */
{
boolean noImage;
point_t Pmin, Pmax;
int errCode;
#if INCL_CACHE
char_desc_t charDesc;
bmapSpecs_t bmapSpecs;
chardata_hdr *pCharData;
#endif

#if INCL_TPS && REENTRANT
intercepts_t intercepts;
sp_globals.intercepts = &intercepts;
#endif

#if CSP_DEBUG
printf("CspDoChar(%d)\n",charCode);
#endif

/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPOUTPUTSPECSSET + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPOUTPUTSPECSSET + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

switch (((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType)
    {
case BITMAP_OUTPUT:
case ANTIALIASED_OUTPUT:
    /* Test if character is completely outside output bounding box */
	if ((*pYpos < ((cspGlobals_t *)pCspGlobals)->outerClipYmin) ||
        (*pYpos > ((cspGlobals_t *)pCspGlobals)->outerClipYmax))
        {
#if DO_CHAR_OPTION_1
        /* Exit if we don't need to update current position */
        if (!((cspGlobals_t *)pCspGlobals)->verticalEscapement &&
        	(sp_globals.tcb.ctm[1] == 0))
        	{
        	return CSP_NO_ERR;
        	}
#endif
        noImage = TRUE;
        }
    else
    	{
    	noImage =
    		(*pXpos < ((cspGlobals_t *)pCspGlobals)->outerClipXmin) ||
    		(*pXpos > ((cspGlobals_t *)pCspGlobals)->outerClipXmax);
		}


#if INCL_CACHE
    if (((cspGlobals_t *)pCspGlobals)->cacheEnabled)
        {

#if CSP_DEBUG
printf("CspDoChar:check cache\n");
#endif
        charDesc.charCode = charCode;
        charDesc.fontCode = ((cspGlobals_t *)pCspGlobals)->fontCode;
        pCharData = CmFindChar(
          	((cspGlobals_t *)pCspGlobals)->pCmGlobals,
           	&charDesc);
#if CSP_DEBUG
printf("CspDoChar:cache pointer %lx\n",(long)pCharData);
#endif

        if (!noImage)           /* Character image required? */
            {
#if CSP_DEBUG
printf("CspDoChar:not clipped\n");
#endif


            if (pCharData != NULL) /* Char found in cache? */
                {
                CmUpdateLru(
                	((cspGlobals_t *)pCspGlobals)->pCmGlobals,
                    pCharData);
                }
            else                /* Char not found in cache? */
                {
                pCharData = CmMakeChar(
                	(cspGlobals_t *)pCspGlobals,
                	((cspGlobals_t *)pCspGlobals)->pCmGlobals,
                	&charDesc);
    	        if (pCharData == NULL)
                    {
                    return CSP_CHAR_CODE_ERR;
                    }
                }
#if CSP_DEBUG
printf("CspDoChar:pCharData xPos = %lx, ypos = %lx, xSize = %d, ySize = %d\n",
	pCharData->cacheSpecs.xPos,
	pCharData->cacheSpecs.yPos,
	pCharData->cacheSpecs.xSize,
	pCharData->cacheSpecs.ySize);
#endif


            bmapSpecs.xPos = (short)(
            	(*pXpos + pCharData->cacheSpecs.xPos + 32768L) >> 16);
            bmapSpecs.yPos = (short)(
            	(*pYpos + pCharData->cacheSpecs.yPos + 32768L) >> 16);
            bmapSpecs.xSize = pCharData->cacheSpecs.xSize;
            bmapSpecs.ySize = pCharData->cacheSpecs.ySize;
            if ((bmapSpecs.xSize > 0) &&
                (bmapSpecs.ySize > 0))
                {
                (*((cspGlobals_t *)pCspGlobals)->bmapCallbackFns.SetBitmap)(
                	bmapSpecs,
                    (char *)pCharData + sizeof(char_desc_t) + sizeof(chardata_hdr)
                    USERARG);
                }
            *pXpos += pCharData->cacheSpecs.xEscapement;
            *pYpos += pCharData->cacheSpecs.yEscapement;
            return CSP_NO_ERR;
            }

        /* Update current position if char found in cache */
        if (pCharData != NULL) /* Char found in cache? */
            {
            *pXpos += pCharData->cacheSpecs.xEscapement;
            *pYpos += pCharData->cacheSpecs.yEscapement;
            return CSP_NO_ERR;
            }
        }
#endif

    /* Save position in device coordinates for bitmap output */
    ((cspGlobals_t *)pCspGlobals)->xPosPix = *pXpos;
    ((cspGlobals_t *)pCspGlobals)->yPosPix = *pYpos;

	/* Test if character is partially outside output bounding box */
    if (!noImage && (
    	(*pXpos < ((cspGlobals_t *)pCspGlobals)->innerClipXmin) ||
        (*pXpos > ((cspGlobals_t *)pCspGlobals)->innerClipXmax) ||
        (*pYpos < ((cspGlobals_t *)pCspGlobals)->innerClipYmin) ||
        (*pYpos > ((cspGlobals_t *)pCspGlobals)->innerClipYmax)))
        {
        /* Save font bounding box */
        Pmin = ((cspGlobals_t *)pCspGlobals)->Pmin;
        Pmax = ((cspGlobals_t *)pCspGlobals)->Pmax;

       	/* Clip font bounding box to output bounding box */
       	CspClipFontBBox(((cspGlobals_t *)pCspGlobals),pXpos, pYpos);

        /* Execute character (image generation enabled) */
        errCode = CspExecChar(
            ((cspGlobals_t *)pCspGlobals),
            charCode,
            FALSE);

        /* Restore font bounding box */
        ((cspGlobals_t *)pCspGlobals)->Pmin = Pmin;
        ((cspGlobals_t *)pCspGlobals)->Pmax = Pmax;

        /* Update current point in device space */
        *pXpos += sp_globals.set_width.x;
        *pYpos += sp_globals.set_width.y;

        return errCode;
		}

    /* Execute character */
    errCode = CspExecChar(
        ((cspGlobals_t *)pCspGlobals),
        charCode,
        noImage);

    /* Update current point in device space */
    *pXpos += sp_globals.set_width.x;
    *pYpos += sp_globals.set_width.y;

    return errCode;

case OUTLINE_OUTPUT:
case DIRECT_OUTPUT:
    /* Execute character (image generation enabled) */
    errCode = CspExecChar(
        ((cspGlobals_t *)pCspGlobals),
        charCode,
        FALSE);

    /* Update current point in device space */
    *pXpos += sp_globals.set_width.x;
    *pYpos += sp_globals.set_width.y;

    return errCode;
    }
}

FUNCTION
int CspDoCharWidth(
    PCONTEXT
    unsigned short charCode,
    long *pXpos,
    long *pYpos)
/*
 *  Executes the specified character from the currently selected font
 *  for the currently selected output specifications.
 *  The current position in device coordinates is incremented by the
 *  character escapement.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 */
{
#if INCL_CACHE
char_desc_t charDesc;
chardata_hdr *pCharData;
#endif
int errCode;

/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPOUTPUTSPECSSET + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPOUTPUTSPECSSET + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if INCL_CACHE
if (((cspGlobals_t *)pCspGlobals)->cacheEnabled)
    {
    charDesc.charCode = charCode;
    charDesc.fontCode = ((cspGlobals_t *)pCspGlobals)->fontCode;
    pCharData = CmFindChar(
      	((cspGlobals_t *)pCspGlobals)->pCmGlobals,
       	&charDesc);

    /* Update current position if char found in cache */
    if (pCharData != NULL) /* Char found in cache? */
        {
        *pXpos += pCharData->cacheSpecs.xEscapement;
        *pYpos += pCharData->cacheSpecs.yEscapement;
        return CSP_NO_ERR;
        }
    }
#endif

/* Execute character (image generation disabled) */
errCode = CspExecChar(
    ((cspGlobals_t *)pCspGlobals),
    charCode,
    TRUE);
if (errCode != 0)
    return errCode;

/* Update current point in device space */
*pXpos += sp_globals.set_width.x;
*pYpos += sp_globals.set_width.y;

return CSP_NO_ERR;
}

FUNCTION
int CspDoString(
    PCONTEXT
    unsigned short modeFlags,
    short length,
    void *pString,
    long *pXpos,
    long *pYpos)
/*  Executes the each of the characters in the specified string using
 *  the currently selected font and the currently selected output
 *  specifications.
 *  *pXpos and *pYpos are updated with the escapement of each character
 *  in the string.
 *  The mode flags have the following meaning:
 *      Bit 0:  16-bit character codes
 *      Bit 1:  Round X-escapement after each character
 *      Bit 2:  Round Y-escapement after each character
 *  In bitmap output mode, a bitmap image of each character is generated
 *  and written at the current position in device coordinates.
 *  After the bitmap is written, the current position is incremented by the
 *  character escapement ready for the next character.
 *  In outline output mode, the transformed character hints and outline
 *  are delivered by calls to the outline output callback functions.
 *  In direct output mode, the transformed outline is delivered by calls
 *  to the direct output callback functions.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 *      CSP_CACHE_ERR           -1  Internal cache error
 */
{
unsigned short charCode;
fix15   ii;
long    round = 32768L;
long    fix = 65535L << 16;
int     errCode;

#if DO_CHAR_OPTION_1
switch (((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType)
    {
case BITMAP_OUTPUT:
case ANTIALIASED_OUTPUT:
    /* Test if character is completely outside output bounding box */
	if ((*pYpos < ((cspGlobals_t *)pCspGlobals)->outerClipYmin) ||
        (*pYpos > ((cspGlobals_t *)pCspGlobals)->outerClipYmax))
        {
        if (!((cspGlobals_t *)pCspGlobals)->verticalEscapement &&
        	(sp_globals.tcb.ctm[1] == 0))
        	{
        	return CSP_NO_ERR;
        	}
        }
    }
#endif

ii = 0;
while (TRUE)
    {
    charCode = (modeFlags & CSP_STRING_16)?
        ((ufix16 *)pString)[ii++]:
        (ufix16)(((ufix8 *)pString)[ii++]);
    if ((charCode == 0) && (length == 0))
        break;

L1: errCode = CspDoChar(
#if REENTRANT
        pCspGlobals,
#endif
        charCode,
        pXpos,
        pYpos);
    if (errCode != 0)
        {
        if ((errCode == CSP_CHAR_CODE_ERR) &&
            ((cspGlobals_t *)pCspGlobals)->missingCharActive &&
            (charCode != ((cspGlobals_t *)pCspGlobals)->missingCharCode))
            {
            charCode = ((cspGlobals_t *)pCspGlobals)->missingCharCode;
            goto L1;
            }
        return errCode;
        }

    if (modeFlags & CSP_ROUND_X_ESCAPEMENT)
        *pXpos = (*pXpos + round) & fix;
    if (modeFlags & CSP_ROUND_Y_ESCAPEMENT)
        *pYpos = (*pYpos + round) & fix;
    if ((length != 0) && (ii >= length))
        break;
    }

return CSP_NO_ERR;
}


FUNCTION
int CspDoStringWidth(
    PCONTEXT
    unsigned short modeFlags,
    short length,
    void *pString,
    long *pXpos,
    long *pYpos)
/*  Executes the each of the characters in the specified string using
 *  the currently selected font and the currently selected output
 *  specifications.
 *  *pXpos and *pYpos are updated with the escapement of each character
 *  in the string.
 *  The mode flags have the following meaning:
 *      Bit 0:  16-bit character codes
 *      Bit 1:  Round X-escapement after each character
 *      Bit 2:  Round Y-escapement after each character
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 *      CSP_CACHE_ERR           -1  Internal cache error
 */
{
unsigned short charCode;
fix15   ii;
long    round = 32768L;
long    fix = 65535L << 16;
int     errCode;

ii = 0;
while (TRUE)
    {
    charCode = (modeFlags & CSP_STRING_16)?
        ((ufix16 *)pString)[ii++]:
        (ufix16)(((ufix8 *)pString)[ii++]);
    if ((charCode == 0) && (length == 0))
        break;

L1: errCode = CspDoCharWidth(
#if REENTRANT
        pCspGlobals,
#endif
        charCode,
        pXpos,
        pYpos);
    if (errCode != 0)
        {
        if ((errCode == CSP_CHAR_CODE_ERR) &&
            ((cspGlobals_t *)pCspGlobals)->missingCharActive &&
            (charCode != ((cspGlobals_t *)pCspGlobals)->missingCharCode))
            {
            charCode = ((cspGlobals_t *)pCspGlobals)->missingCharCode;
            goto L1;
            }
        return errCode;
        }
    if (modeFlags & CSP_ROUND_X_ESCAPEMENT)
        *pXpos = (*pXpos + round) & fix;
    if (modeFlags & CSP_ROUND_Y_ESCAPEMENT)
        *pYpos = (*pYpos + round) & fix;
    if ((length != 0) && (ii >= length))
        break;
    }

return CSP_NO_ERR;
}



FUNCTION
int CspClose(PCONTEXT1)
/*
 *  Closes the character shape player
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 */

{
if ((((cspGlobals_t *)pCspGlobals)->cspState & CSPOPENMASK) !=
    CSPOPEN)                    /* CSP not open? */
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if REENTRANT
#else
pCspGlobals = NULL;             /* Mark globals unallocated */
#endif

return CSP_NO_ERR;
}


/***** Undocumented API functions *****/
FUNCTION
int CspTransformPoint(
    PCONTEXT
    long   x,
    long   y,
    long   *pXt,
    long   *pYt)
/*
 *  Transforms the point (x, y) from character coordinates (16.16 outline
 *  resolution units) into device coordinates (16.16 pixels) using the
 *  current transformation matrix.
 *  The transformed point, relative to the character origin, is written
 *  into (*pXt, *pYt).
 *
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API call sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 */
{
fix15   outlineResolution;
fix31   ctm[4];
fix15   ii;
fix31   xt, yt;
int     errCode;

/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPOUTPUTSPECSSET + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPOUTPUTSPECSSET + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

#if CSP_MAX_DYNAMIC_FONTS > 0
if (((cspGlobals_t *)pCspGlobals)->fontCode >=
    ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    errCode = CspLoadTopPhysFont((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }
#endif

/* Convert current transformation matrix to pixels per oru */
outlineResolution = ((cspGlobals_t *)pCspGlobals)->fontInfo.outlineResolution;
for (ii = 0; ii < 4; ii++)
    {
    ctm[ii] =
        (sp_globals.tcb.ctm[ii] + (outlineResolution >> 1)) /
        outlineResolution;
    }

xt =
    CspLongMult(x, ctm[0]) +
    CspLongMult(y, ctm[2]);

yt =
    CspLongMult(x, ctm[1]) +
    CspLongMult(y, ctm[3]);

*pXt = xt;
*pYt = yt;

return CSP_NO_ERR;
}

FUNCTION
int CspSetFontSpecs(
    PCONTEXT
    fontAttributes_t *pFontAttributes)
/*
 *  Overrides the font matrix and other rendering attributes of
 *  the currently selected font.
 *  The bitmap cache is cleared to ensure that there are no
 *  characters in the cache associated with the previous
 *  values of the font attributes.
 *
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_FONT_STYLE_ERR       9  Illegal value for fontStyle
 *      CSP_LINE_JOIN_TYPE_ERR  10  Illegal value for lineJoinType
 */
{
int     errCode;

/* Verify CSP is open and a font is selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

/* Verify values are legal */
switch(pFontAttributes->fontStyle)
    {
case FILLED_STYLE:
    break;

case BOLD_STYLE:
    break;

case STROKED_STYLE:
    switch (pFontAttributes->styleSpecs.styleSpecsStroked.lineJoinType)
        {
    case MITER_LINE_JOIN:
    case ROUND_LINE_JOIN:
    case BEVEL_LINE_JOIN:
        break;

    default:
        return CSP_LINE_JOIN_TYPE_ERR;
        }
    break;

default:
    return CSP_FONT_STYLE_ERR;
    }

/* Update data from font attributes structure */
((cspGlobals_t *)pCspGlobals)->fontAttributes = *pFontAttributes;

/* Set up data paths and transformation constants */
if (((cspGlobals_t *)pCspGlobals)->cspState & CSPOUTPUTSPECSSET)
    {
    errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
    if (errCode != 0)
        return errCode;
    }

/* Clear the bitmap cache */
#if INCL_CACHE
CmReinitCache((cspGlobals_t *)pCspGlobals);
#endif

return CSP_NO_ERR;
}

FUNCTION
int CspGetScaledCharBBox(
    PCONTEXT
    unsigned short charCode,
    CspScaledBbox_t *pBBox)
/*
 *  Measures the bounding box of the specified character in the
 *  currently selected font. Assigns to *pBBox the resulting bounding
 *  box expressed in 16.16 device coordinates.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_READ_RESOURCE_ERR    3  ReadResourceData() returned error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 */
{
short   outputType;
int     errCode;

/* Check CSP is open, output specs set and font selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPOUTPUTSPECSSET + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPOUTPUTSPECSSET + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

/* Save current output type */
outputType = ((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType;

/* Change output type to select bounding box accumulator */
((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType = 0;

/* Set up data paths and transformation constants */
errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);
if (errCode != 0)
    return errCode;

/* Execute character with image generation enabled */
errCode = CspExecChar(
    ((cspGlobals_t *)pCspGlobals),
    charCode,
    FALSE);
if (errCode != 0)
    {
    /* Restore output type */
    ((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType = outputType;

    /* Set up data paths and transformation constants */
    CspDoSetup((cspGlobals_t *)pCspGlobals);

    return errCode;
    }

/* Extract character bounding box */
pBBox->xmin =
    (fix31)sp_globals.xmin << sp_globals.poshift;
pBBox->ymin =
    (fix31)sp_globals.ymin << sp_globals.poshift;
pBBox->xmax =
    (fix31)sp_globals.xmax << sp_globals.poshift;
pBBox->ymax =
    (fix31)sp_globals.ymax << sp_globals.poshift;

/* Restore output type */
((cspGlobals_t *)pCspGlobals)->outputSpecs.outputType = outputType;

/* Set up data paths and transformation constants */
errCode = CspDoSetup((cspGlobals_t *)pCspGlobals);

return errCode;
}



/***** Undocumented functions used only by TrueDoc Printing Systems *****/

#if INCL_TPS

FUNCTION
int CspGetRawCharWidth(
    PCONTEXT
    unsigned short charCode,
    short *pXWidth,
    short *pYWidth)
/*
 *  Accesses the specified character in the currently selected font.
 *  The X and Y components of the width value (in metrics resolution units)
 *  are written to *pXWidth  and *pYWidth respectively.
 *  Returns:
 *      CSP_NO_ERR               0  Normal return
 *      CSP_CALL_SEQUENCE_ERR    1  API calling sequence error
 *      CSP_CHAR_CODE_ERR        7  Char not found in current font
 */
{
ufix8  *pByte;
fix15   width;

/* Verify CSP is open and a font is selected */
if ((((cspGlobals_t *)pCspGlobals)->cspState & (CSPOPENMASK + CSPFONTSELECTED)) !=
    (CSPOPEN + CSPFONTSELECTED))
    {
    return CSP_CALL_SEQUENCE_ERR;
    }

/* Find the character */
#if CSP_MAX_DYNAMIC_FONTS > 0
/* Check if font code refers to dynamic font */
if (((cspGlobals_t *)pCspGlobals)->fontCode >=
    ((cspGlobals_t *)pCspGlobals)->nLogicalFonts)
    {
    pByte = CspFindNewFontChar(
        (cspGlobals_t *)pCspGlobals, charCode);
    if (pByte == NULL)
        {
        return CSP_CHAR_CODE_ERR;
        }
    }
else                            /* PFR font? */
#endif
    {
    pByte = CspFindChar(pCspGlobals, charCode);
    if (pByte == NULL)          /* Character not found? */
        {
        return CSP_CHAR_CODE_ERR;
        }
    }

/* Get the width value */
if (((cspGlobals_t *)pCspGlobals)->charFormat & BIT_2) /* Variable width font? */
    {
    width = NEXT_WORD(pByte);
    }
else                            /* Fixed width font? */
    {
    width = ((cspGlobals_t *)pCspGlobals)->standardSetWidth;
    }

/* Put the width value in the appropriate axis */
if (((cspGlobals_t *)pCspGlobals)->verticalEscapement)
    {
    *pXWidth = 0;
    *pYWidth = width;
    }
else
    {
    *pXWidth = width;
    *pYWidth = 0;
    }

return CSP_NO_ERR;
}

#if REENTRANT
FUNCTION
sp_globals_t *GetspGlobalPtr(
    cspGlobals_t *pCspGlobals)
/***************************************************
	acquire a pointer to spGlobals member of a cspGlobals_t pointer
****************************************************/
{
	return(&sp_globals);	/* this macros to "(pCspGlobals->spGlobals)" */
}
#endif /* REENTRANT */

FUNCTION
unsigned short CspGetLogicalFontIndex(
    PCONTEXT1)
/***************************************************
	Return the current logical font index set in cspGlobals_t pointer
****************************************************/
{
	return((unsigned short) ((cspGlobals_t *)pCspGlobals)->fontCode);
}
#endif /* INCL_TPS */

#endif /* PROC_TRUEDOC */
