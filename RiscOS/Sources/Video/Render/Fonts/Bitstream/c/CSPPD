/*****************************************************************************
*                                                                            *
*                        Copyright 1993 - 95                                 *
*          as an unpublished work by Bitstream Inc., Cambridge, MA           *
*                                                                            *
*         These programs are the sole property of Bitstream Inc. and         *
*           contain its proprietary and confidential information.            *
*                                                                            *
*****************************************************************************/



/****************************** C S P P D . C ********************************
 *                                                                           *
 * TrueDoc Character Shape Player test program                               *
 * Reads and displays a portable document generated by TrueDoc recorder demo *
 * program (MS Windows or Mac)                                               *
 *                                                                           *
 ********************** R E V I S I O N   H I S T O R Y **********************
 *                                                                           *
 *  Changes since TrueDoc Release 2.0:                                       *
 *
 *     $Header$
 *
 *     $Log$
 * Revision 4.1  96/03/05  13:47:02  mark
 * Release
 *
 * Revision 3.1  95/12/29  10:30:46  mark
 * Release
 *
 * Revision 2.1  95/12/21  09:47:34  mark
 * Release
 *
 * Revision 1.1  95/08/10  16:46:30  john
 * Initial revision
 *
 *
 ****************************************************************************/


#include <stdlib.h>
#include <stdio.h>
/*#include <fcntl.h>*/
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "btstypes.h"
#include "csp_api.h"
#include "graphics.h"
#include "csp_pdr.h"

#ifndef DEBUG
#define DEBUG   1
#endif

#if DEBUG
#define SHOW(X) printf(#X " = %ld\n", (long)(X))
#else
#define SHOW(X)
#endif

#ifndef CSPCACHESIZE
#define CSPCACHESIZE 600000     /* Size of bitmap cacher buffer */
#endif

#define  PI     3.1415926536    /* pi */

char   *pTextBuff;		        /* Portable document text buffer */
long    textBuffSize;
int     deviceUnits;
int     pixelSize;              /* Bits per pixel */
void   *pCacheContext;
void   *pCspContext;

#if INCL_TPS && !REENTRANT
sp_globals_t sp_globals;
#endif

static  FILE   *pdfFile;        /* Portable document file */
static  long    pdFileOffset;   /* Offset to start of PFR */
static  ufix8  *cspBuff;        /* Origin of char shape player buffer */
static  fix31   ctm[6];         /* Current transformation matrix in 16.16 units */
static  long    cspMemoryMode;  /* 1 = minimum; 2 = normal; 3 = max; otherwise size */


/* local function declarations */

LOCAL_PROTO
int OpenCsp(void);

LOCAL_PROTO
ufix32 ReadLong(
    ufix8 *pBuff);

LOCAL_PROTO
int PdReadResourceData(
    void *pBuffer,
    short nBytes,
    long offset
    USERPARAM);

LOCAL_PROTO
void *PdAllocCspBuffer(
    long minBuffSize,
    long normalBuffSize,
    long maxBuffSize,
    long *pNBytes
    USERPARAM);




int main(
	int argc,
	char *argv[])
{
int i;
char   *pathname;
double aspectRatio = 1.0;
#if INCL_CACHE
short int cacheEnabled = TRUE;
short int invertBitmap = -1;
short int color = -1;
#endif
int angle;
rect_t clipRect;

/* Initialize defaults */
cspMemoryMode = 3;
deviceUnits = 72;
angle = 0;
pixelSize = 1;

pathname = argv[1];

if (argc < 2)
    {
    fprintf(stderr,"Usage: %s <portable document file> {options}\n", argv[0]);
    fprintf(stderr,"       options:\n");
    fprintf(stderr,"       -m memory_mode/buffer_size\n");
    fprintf(stderr,"       -a aspect_ratio\n");
    fprintf(stderr,"       -r device_resolution\n");
    fprintf(stderr,"       -o rotation_angle\n");
#if INCL_ANTIALIASED_OUTPUT
    fprintf(stderr,"       -z bits_per_pixel\n");
#endif
    return 1;
    }

/* Open portable document file */
pdfFile = fopen(pathname, "rb");
if (pdfFile == NULL)
    {
    printf("Cannot open portable document file\n");
    return 1;
    }

for (i = 2; i < argc;i++)
    {
    if (argv[i][0] == '-')
        {
        if (argv[i][1] == 'm')
            {
            i++;
            sscanf(argv[i],"%ld", &cspMemoryMode);
            }
        else if (argv[i][1] == 'a')
            {
            i++;
            sscanf(argv[i],"%lf", &aspectRatio);
            }
        else if (argv[i][1] == 'r')
            {
            i++;
            sscanf(argv[i],"%d", &deviceUnits);
            }
        else if (argv[i][1] == 'o')
            {
            i++;
            sscanf(argv[i],"%d", &angle);
            }
#if INCL_ANTIALIASED_OUTPUT
        else if (argv[i][1] == 'z')
            {
            i++;
            sscanf(argv[i],"%d", &pixelSize);
            }
#endif
        }
    }

ctm[0] = (fix31)(cos((double)angle*PI/180.)*((double)deviceUnits *65536.0));
ctm[1] = (fix31)(-sin((double)angle*PI/180.)*(double)(deviceUnits *65536.0));

ctm[2] = (fix31)(sin((double)angle*PI/180.)*((double)deviceUnits *65536.0 * aspectRatio));
#if INCL_TPS
ctm[3] = (fix31)(-cos((double)angle*PI/180.)*((double)deviceUnits * 65536.0 * aspectRatio));
#else
ctm[3] = (fix31)(cos((double)angle*PI/180.)*((double)deviceUnits * 65536.0 * aspectRatio));
#endif
ctm[4] = 0L << 16;
ctm[5] = 0L << 16;


/* Show characters graphically */
initiate_graphics();

/* Initialize the bitmap cache */
#if ! REENTRANT
CspInitBitmapCache(
    (void *)malloc((size_t)CSPCACHESIZE),
    CSPCACHESIZE);
#else
CspInitBitmapCache(
    &pCacheContext,
    (void *)malloc((size_t)CSPCACHESIZE),
    CSPCACHESIZE);
#endif

if (OpenCsp())
    {
    textBuffSize = pdFileOffset;
    pTextBuff = (char *)malloc((size_t)textBuffSize);
    if (pTextBuff != NULL)
        {
        fseek(pdfFile,0,0);
        if (fread(pTextBuff,1,(size_t)textBuffSize,pdfFile) == (size_t)textBuffSize)
            {
            int done = 0;
            while (!done)
                {
                int i;
                char      response[8];

#if INCL_CACHE
#if ! REENTRANT
                CspSetCacheParams(
                    cacheEnabled,
                    -1,
                    color,
                    -1,
                    invertBitmap);
#else
                CspSetCacheParams(
                    pCspContext,
                    cacheEnabled,
                    -1,
                    color,
                    -1,
                    invertBitmap);
#endif
#endif

                clear_graphics();
                GetClipRect(&clipRect);
                ShowPortableDoc(ctm, &clipRect);

                printf ("(u)p, (d)own, (l)eft, (r)ight, zoom (i)n, zoom (o)ut, (q)uit: ");
                gets (response);
                switch (response[0])
                    {
                    case 'i':
                        for (i = 0; i <= 4; i++)
                            ctm[i] = (ctm[i]/2) * 3;
                        break;
                    case 'o':
                        for (i = 0; i <= 4; i++)
                            ctm[i] = (ctm[i]/3) * 2;
                        break;
                    case 'u':
                        ctm[5] += 400L << 16;
                        break;
                    case 'd':
                        ctm[5] -= 400L << 16;
                        break;
                    case 'r':
                        ctm[4] -= 400L << 16;
                        break;
                    case 'l':
                        ctm[4] += 400L << 16;
                        break;
                    case 'q':
                        done = TRUE;
                        break;
#if INCL_CACHE
                    case 'E':
                        cacheEnabled = !cacheEnabled;
                        break;
                    case 'I':
                        invertBitmap = !invertBitmap;
                        break;
                    case 'C':
                        color = !color;
                        break;
#endif

                    default:
                        break;
                    }
                }
            }
        }

    terminate_graphics();
    }

printf("\nDone\n");
return 0;
}


/*********************************************************************
 *  OpenCsp - find character shape resource and load it
 *  Open the Character Shape Player
 *********************************************************************/
static int OpenCsp(void)
{
int nBytes;
char smallBuff[8];
long pfrSize;
long pos;

pos = fseek(pdfFile, -8L, SEEK_END);
if (pos == -1)
    {
    return FALSE;
    }

nBytes = fread(smallBuff, 1, (size_t)8, pdfFile);
if (nBytes != 8)
    {
    return FALSE;
    }

if (strncmp((char *)smallBuff + 3, "$PFR$", 5) != 0)
    {
    return FALSE;
    }

pfrSize = (int)ReadLong((ufix8 *)smallBuff);

fseek(pdfFile, -pfrSize, SEEK_END);     /* Seek to start of pfr */
pdFileOffset = ftell(pdfFile);
nBytes = fread(smallBuff, 1, (size_t)8, pdfFile);
if (nBytes != 8)
    {
    return FALSE;
    }

if (strncmp(smallBuff, "PFR0", 4) != 0)
    {
    return FALSE;
    }

if (strncmp((char *)smallBuff + 6, "\015\012", 2) != 0)
    {
    return FALSE;
    }

#if ! REENTRANT
CspOpen(
    deviceUnits,
    PdReadResourceData,
    PdAllocCspBuffer);
#else
CspOpen(
    &pCspContext,
    pCacheContext,
    deviceUnits,
    PdReadResourceData,
    PdAllocCspBuffer,
    0L);
#endif

return TRUE;

}

/*********************************************************************
 *  Read 3-byte integer
 *********************************************************************/
static ufix32 ReadLong(ufix8 *pBuff)
{
fix31 result;

result = (ufix32)(*(pBuff++));
result = (result << 8) + (ufix32)(*(pBuff++));
result = (result << 8) + (ufix32)(*(pBuff++));

return result;
}


/*********************************************************************
 *  Read block of data from portable font resource
 *********************************************************************/
static int PdReadResourceData(
    void *pBuffer,
    short nBytes,
    long offset
    USERPARAM)
/*
 *  Reads nBytes of data from the character shape resource to
 *  the specified buffer starting offset bytes from the
 *  beginning of the character shape resource.
 */
{
if (fseek(pdfFile, pdFileOffset + offset, 0) == -1)
    return 1;

if (fread(pBuffer,1,(size_t)nBytes,pdfFile) != (unsigned)nBytes)
    return 2;

return 0;
}

/*********************************************************************
 *  Allocate buffer for Character Shape Player
 *********************************************************************/
static void *PdAllocCspBuffer(
    long minBuffSize,
    long normalBuffSize,
    long maxBuffSize,
    long *pNBytes
    USERPARAM)
{
void *pMem;

switch (cspMemoryMode)
    {
case 3:
    *pNBytes = maxBuffSize;
    pMem = (void *)malloc((size_t)maxBuffSize);
    if (pMem != NULL)
        return pMem;

case 2:
    *pNBytes = normalBuffSize;
    pMem = (void *)malloc((size_t)normalBuffSize);
    if (pMem != NULL)
        return pMem;

case 1:
    *pNBytes = minBuffSize;
    return (void *)malloc((size_t)minBuffSize);

default:
    *pNBytes = cspMemoryMode;
    return (void *)malloc((size_t)cspMemoryMode);
    }
}

