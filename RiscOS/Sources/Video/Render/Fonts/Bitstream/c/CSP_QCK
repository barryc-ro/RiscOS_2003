/*****************************************************************************
*                                                                            *
*                        Copyright 1989 - 95                                 *
*          as an unpublished work by Bitstream Inc., Cambridge, MA           *
*                                                                            *
*         These programs are the sole property of Bitstream Inc. and         *
*           contain its proprietary and confidential information.            *
*                                                                            *
*****************************************************************************/



/************************** C S P _ Q C K . C ********************************
 *                                                                           *
 * This is a version of QuickWriter for use with TrueDoc.                    *
 * QuickWriter is a high-performance, high-quality output module for 4-in-1. *
 *                                                                           *
 ********************** R E V I S I O N   H I S T O R Y **********************
 *                                                                           *
 *  Changes since TrueDoc Release 2.0:                                       *
 *
 *     $Header$
 *                                                                                    
 *     $Log$
 * Revision 4.1  96/03/05  13:46:31  mark
 * Release
 * 
 * Revision 3.1  95/12/29  10:30:18  mark
 * Release
 * 
 * Revision 2.1  95/12/21  09:47:07  mark
 * Release
 * 
 * Revision 1.3  95/09/06  17:32:48  john
 * Test for clipped salients is now done for vectors that
 *     are entirely clipped as well as vectors that start
 *     in the clipped region and end in the active band.
 *     This avoids spurious salients in the top scanline
 *     of second and subsequent bands.
 * 
 * Revision 1.2  95/08/31  09:25:26  john
 * The dummy CspCurveToQuick function now splits curves int
 *     vectors and calls CspLineToQuick to process each vector.
 * 
 * Revision 1.1  95/08/10  16:45:37  john
 * Initial revision
 * 
 *                                                                           *
 ****************************************************************************/
        

#ifndef CSP_DEBUG
#define CSP_DEBUG      0
#endif

#if CSP_DEBUG
#include <stdio.h>
#endif

#include "csp_int.h"

#if CSP_DEBUG
#include "csp_dbg.h"
#endif

#if MSDOS
#define INLINE __inline
#else
#define INLINE
#endif

#define MAX_INTERCEPTS_QUICK MAX_INTERCEPTS

#if INCL_CSPQUICK

/* New type definition for intercept properties */
typedef ufix8 props_t;

/* Local function prototypes */

LOCAL_PROTO
void sp_init_intercepts_quick(
    cspGlobals_t *pCspGlobals);

LOCAL_PROTO
void sp_add_intercept_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y, 
    fix15 x, 
    props_t props_value);

LOCAL_PROTO
void sp_mark_salient_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y, 
    fix15 i1, 
    fix15 i2);

LOCAL_PROTO
void sp_proc_intercepts_quick(
    cspGlobals_t *pCspGlobals);

LOCAL_PROTO
void sp_flush_intercepts_quick(
    cspGlobals_t *pCspGlobals);

LOCAL_PROTO
void sp_close_horiz_gaps_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y);

LOCAL_PROTO
void sp_close_diag_gaps_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y);

LOCAL_PROTO
boolean sp_assemble_group_pair_quick(
    cspGlobals_t *pCspGlobals,
    fix15 i1, 
    fix15 i2, 
    fix15 *pi1_start, 
    fix15 *pi1_end, 
    fix15 *pi2_start, 
    fix15 *pi2_end);

LOCAL_PROTO
void sp_assemble_group_quick(
    cspGlobals_t *pCspGlobals,
    fix15 i, 
    props_t up_salient_mask, 
    props_t down_salient_mask, 
    fix15 min_open_intercepts,
    fix15 *pi_start,
    fix15 *pi_end,
    fix15 *pn_open_intercepts);

LOCAL_PROTO
void sp_proc_group_pair_quick(
    cspGlobals_t *pCspGlobals,
    fix15 i1_start, 
    fix15 i1_end, 
    fix15 i2_start, 
    fix15 i2_end);

LOCAL_PROTO
void sp_close_gap_quick(
    cspGlobals_t *pCspGlobals,
    fix15 i1_start, 
    fix15 i1_end, 
    fix15 i2_start, 
    fix15 i2_end);

LOCAL_PROTO
void sp_sort_intercepts_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y);

LOCAL_PROTO
void sp_output_complex_scanline_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y, 
    fix15 scanline);

LOCAL_PROTO
boolean sp_extend_zero_length_run_quick(
    cspGlobals_t *pCspGlobals,
    fix15 avail_pix_left, 
    fix15 extendibility_left,
    fix15 avail_pix_right, 
    fix15 extendibility_right,
    fix15 *px_start, 
    fix15 *px_end);

LOCAL_PROTO
void sp_check_scanline_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y);


#if CSP_DEBUG >= 1

LOCAL_PROTO
void print_intercepts(
    cspGlobals_t *pCspGlobals,
    fix15 y);

#endif

/* Intercept list property definitions */
#define SUB_CHAR_COUNT           0x03   /* MUST be at ls end of word */
#define COMPOUND_SCANLINE_FLAG   0x04
#define COMPLEX_SCANLINE_FLAG    0x08
#define COMPLEX_INTERVAL_BELOW   0x10
#define SOLID_SALIENT_FLAG       0x20
#define HOLLOW_SALIENT_FLAG      0x40

/* Individual intercept property definitions */
#define EXTENDIBILITY            0x03   /* MUST be at ls end of word */
#define BEGIN_SOLID_SALIENT      0x04
#define END_SOLID_SALIENT        0x08
#define BEGIN_HOLLOW_SALIENT     0x10
#define END_HOLLOW_SALIENT       0x20
#define UP_INTERCEPT             0x80

FUNCTION 
boolean CspInitOutQuick(
    cspGlobals_t *pCspGlobals,
    CspSpecs_t *specsarg)
/*
 *  Initializes the output module.
 *  Returns TRUE if output module can accept requested specifications.
 *  Returns FALSE otherwise.
 */
{
#if CSP_DEBUG >= 2
printf("CspInitOutQuick()\n");
printf("    Mode flags = %08x\n", specsarg->flags);
#endif

if (specsarg->flags & 
    (CLIP_LEFT |                /* Clipping not supported */
     CLIP_RIGHT |
     CLIP_TOP |
     CLIP_BOTTOM))
    {
    return FALSE;
    }

return TRUE;
}

FUNCTION 
boolean CspBeginCharQuick(
    cspGlobals_t *pCspGlobals,
    point_t Psw,                   
    point_t Pmin,                   
    point_t Pmax)                  
/*
 *  Called once at the start of the character generation process
 */
{
#if CSP_DEBUG >= 2
printf("CspBeginCharQuick(%3.1f, %3.1f, %3.1f, %3.1f, %3.1f, %3.1f\n", 
    (real)Psw.x / (real)sp_globals.onepix, 
    (real)Psw.y / (real)sp_globals.onepix,
    (real)Pmin.x / (real)sp_globals.onepix, 
    (real)Pmin.y / (real)sp_globals.onepix,
    (real)Pmax.x / (real)sp_globals.onepix, 
    (real)Pmax.y / (real)sp_globals.onepix);
#endif

/* Save escapement vector for later use in open_bitmap() */
sp_globals.set_width.x = (fix31)Psw.x << sp_globals.poshift;
sp_globals.set_width.y = (fix31)Psw.y << sp_globals.poshift;

/* Set initial band to cover all scanlines touched or intercepted by 
 * character allowing for some scaling jitter */
sp_globals.y_band.band_min = 
    (Pmin.y - sp_globals.onepix + 1) >> sp_globals.pixshift;
sp_globals.y_band.band_max = 
    (Pmax.y + sp_globals.onepix - 1) >> sp_globals.pixshift;

/* Initialize intercept storage */
sp_init_intercepts_quick(pCspGlobals);

/* Initialize bitmap bounding box */
if (sp_globals.normal)          /* Bitmap bounding box is known accurately? */
    {
    sp_globals.bmap_xmin = Pmin.x;
    sp_globals.bmap_xmax = Pmax.x;
    sp_globals.bmap_ymin = Pmin.y;
    sp_globals.bmap_ymax = Pmax.y;
    sp_globals.extents_running = FALSE;
    }
else                            /* Bitmap bounding box not known accurately? */
    {
    sp_globals.bmap_xmin = 32000;
    sp_globals.bmap_xmax = -32000;
    sp_globals.bmap_ymin = 32000;
    sp_globals.bmap_ymax = -32000;
    sp_globals.extents_running = TRUE;
    }

sp_globals.first_pass = TRUE;

return TRUE;
}

FUNCTION 
void CspBeginSubCharQuick(
    cspGlobals_t *pCspGlobals,
    point_t Psw,                   
    point_t Pmin,                   
    point_t Pmax)                   
/*
 *  Called at the start of each sub-character in a composite character
 */
{
#if CSP_DEBUG >= 2
printf("CspBeginSubCharQuick(%3.1f, %3.1f, %3.1f, %3.1f, %3.1f, %3.1f\n", 
    (real)Psw.x / (real)sp_globals.onepix, 
    (real)Psw.y / (real)sp_globals.onepix,
    (real)Pmin.x / (real)sp_globals.onepix, 
    (real)Pmin.y / (real)sp_globals.onepix,
    (real)Pmax.x / (real)sp_globals.onepix, 
    (real)Pmax.y / (real)sp_globals.onepix);
#endif

sp_globals.sp_first_sub_char_offset = sp_globals.next_offset;

/* Set safe band of scanlines touched or intersected by sub-character
 * We need to allow a 5 pixel boundary in case inner features break
 * through the character bounding box
 */   
sp_globals.sp_sub_band_min = 
    ((Pmin.y + sp_globals.pixrnd) >> sp_globals.pixshift) - 5;
sp_globals.sp_sub_band_max = 
    ((Pmax.y + sp_globals.pixrnd) >> sp_globals.pixshift) + 4; 

/* Ensure actual bitmap extents are collected for compound characters */
if (sp_globals.first_pass &&
    (!sp_globals.extents_running))
	{
    sp_globals.bmap_xmin = 32000;
    sp_globals.bmap_xmax = -32000;
    sp_globals.bmap_ymin = 32000;
    sp_globals.bmap_ymax = -32000;
    sp_globals.extents_running = TRUE;
	}
}

FUNCTION 
void CspBeginContourQuick(
    cspGlobals_t *pCspGlobals,
    point_t P1,                   
    boolean outside)
/*
 *  Called at the start of each contour
 */
{
#if CSP_DEBUG >= 2
printf("CspBeginContourQuick(%3.4f, %3.4f, %s)\n", 
    (real)P1.x / (real)sp_globals.onepix, 
    (real)P1.y / (real)sp_globals.onepix, 
    outside? "outside": "inside");
#endif

/* Determine if contour direction is reversed */
CspSetContourDirection(pCspGlobals, outside);

sp_globals.x0_spxl = P1.x;
sp_globals.y0_spxl = P1.y;
sp_globals.y_pxl = 
    (sp_globals.y0_spxl + sp_globals.pixrnd) >> sp_globals.pixshift;
sp_globals.sp_banding_active = TRUE;
sp_globals.sp_first_contour_offset = sp_globals.next_offset;

sp_globals.sp_old_yend = -32000;

sp_globals.sp_clipped_first_salient = FALSE;
sp_globals.sp_clipped_salient = FALSE;

/* Check space left in intercept structure */
sp_globals.sp_intercept_monitoring =
    (sp_globals.y_band.band_max - sp_globals.y_band.band_min) >= 
    (MAX_INTERCEPTS_QUICK - sp_globals.next_offset);
}

FUNCTION
void CspCurveToQuick(
    cspGlobals_t *pCspGlobals,
    point_t P1,
    point_t P2,
    point_t P3,
    fix15   depth)
/*
 *  Split curve into an appropriate number of vectors
 */
{
point_t P0;

P0.x = sp_globals.x0_spxl;
P0.y = sp_globals.y0_spxl;
CspSplitCurve(
    pCspGlobals,
    P0,
    P1,
    P2,
    P3,
    depth,
    CspLineToQuick);
}

FUNCTION 
void CspLineToQuick(
    cspGlobals_t *pCspGlobals,
    point_t P1)                  
/*
 *  Called for each vector in the transformed character
 *  Determines which scanlines that fall within the current band are
 *  intercepted and calls sp_add_intercept_quick to record each intercept in
 *  the intercept structure.
 */
{
fix15   xstart_spxl;    /* X coord of start point (sub-pixel units) */
fix15   ystart_spxl;    /* Y coord of start point (sub-pixel units) */
fix31   dx;             /* X increment (sub-pixel units) */
fix31   dy;             /* Y increment (sub-pixel units) */
fix15   ystart;         /* First scanline to be intercepted */
fix15   yend;           /* Last scanline to be intercepted */
fix15   space_left;     /* Space left in the intercept structure */
fix15   x;              /* X coord of each intercept (pixel units) */
fix15   y;              /* Y coord of each intercept (i'cept list index) */
fix31   xx;             /* X coord of each intercept (16.16 units) */
fix31   dxdy;           /* Delta X for each scanline (16.16 units) */
boolean salient_detected;
boolean banding_active_next;
fix15   tmpfix15;
#if MSDOS
fix31   tmpfix31;
#endif
props_t props_value;    /* Value of intercept properties field */

#if CSP_DEBUG >= 2
printf("CspLineToQuick(%3.4f, %3.4f)\n", 
   (real)P1.x/(real)sp_globals.onepix, 
   (real)P1.y/(real)sp_globals.onepix);
#endif

xstart_spxl = sp_globals.x0_spxl;
dx = (fix31)P1.x - sp_globals.x0_spxl;
sp_globals.x0_spxl = P1.x;

ystart_spxl = sp_globals.y0_spxl;
dy = (fix31)P1.y - sp_globals.y0_spxl;
sp_globals.y0_spxl = P1.y;

/* Accumulate actual character bounding box if not already known */
if (sp_globals.extents_running)
    {
    if (dx >= 0)
        {
        if (sp_globals.x0_spxl > sp_globals.bmap_xmax)         
            {
            sp_globals.bmap_xmax = sp_globals.x0_spxl;
            }
        }
    if (dx <= 0)
        {
        if (sp_globals.x0_spxl < sp_globals.bmap_xmin)
            {
            sp_globals.bmap_xmin = sp_globals.x0_spxl;
            }
        }

    if (dy >= 0)
        {
        if (sp_globals.y0_spxl > sp_globals.bmap_ymax)
            {
            sp_globals.bmap_ymax = sp_globals.y0_spxl;
            }
        }
    if (dy <= 0)
        {
        if (sp_globals.y0_spxl < sp_globals.bmap_ymin)
            {
            sp_globals.bmap_ymin = sp_globals.y0_spxl;
            }
        }
    }

/* Compute first and last scanlines intercepted by vector */
ystart = sp_globals.y_pxl;
sp_globals.y_pxl = yend = (P1.y + sp_globals.pixrnd) >> sp_globals.pixshift;   
if (yend < ystart)
    {
    ystart--;
    }
else if (yend > ystart)
    {
    yend--;
    }
else
    {
    return;
    }

/* Check if intercept overflow has already occured */
if (sp_globals.intercept_oflo)
    {
    return;
    }

/* Check for change in Y direction */
if (salient_detected = (ystart == sp_globals.sp_old_yend))
    {
    sp_globals.sp_intercept_monitoring =
        (sp_globals.y_band.band_max - sp_globals.y_band.band_min) >= 
        (MAX_INTERCEPTS_QUICK - sp_globals.next_offset);
    }
sp_globals.sp_old_yend = yend;

/* Check if last scanline intercepted is outside current band */
banding_active_next =
    (yend > sp_globals.y_band.band_max) ||
    (yend < sp_globals.y_band.band_min);

/* Clip vector to current band */
if (banding_active_next || sp_globals.sp_banding_active)
    {
    if (sp_globals.y_band.band_min > 
        sp_globals.y_band.band_max) /* Band is null? */
        {
        sp_globals.sp_banding_active = TRUE;
        return;
        }

    if (ystart > sp_globals.y_band.band_max)
        {
        if (salient_detected)
            {
            salient_detected = FALSE;
            if (sp_globals.next_offset == sp_globals.sp_first_contour_offset)
                {
                sp_globals.sp_clipped_first_salient = TRUE;
                }
            else
                {
                sp_globals.sp_clipped_salient = TRUE;
                }
            }
        if (yend > sp_globals.y_band.band_max)
            {
            sp_globals.sp_banding_active = TRUE;
            return;
            }
        ystart = sp_globals.y_band.band_max;
        }

    if (ystart < sp_globals.y_band.band_min)
        {
        if (salient_detected)
            {
            salient_detected = FALSE;
            if (sp_globals.next_offset == sp_globals.sp_first_contour_offset)
                {
                sp_globals.sp_clipped_first_salient = TRUE;
                }
            else
                {
                sp_globals.sp_clipped_salient = TRUE;
                }
            }
        if (yend < sp_globals.y_band.band_min)
            {
            sp_globals.sp_banding_active = TRUE;
            return;
            }
        ystart = sp_globals.y_band.band_min;
        }

    if (yend > sp_globals.y_band.band_max)
        {
        yend = sp_globals.y_band.band_max;
        }

    if (yend < sp_globals.y_band.band_min)
        {
        yend = sp_globals.y_band.band_min;
        }
    
    if (!banding_active_next)
        {
        sp_globals.sp_clipped_salient = FALSE;
        }
    }
sp_globals.sp_banding_active = banding_active_next;

/* Check if room for all intercepts from clipped vector */
if (sp_globals.sp_intercept_monitoring)
    {
    space_left = MAX_INTERCEPTS_QUICK - sp_globals.next_offset;
    tmpfix15 = yend - ystart;
    if ((tmpfix15 >= space_left) ||
        (-tmpfix15 >= space_left))
        {
        sp_globals.intercept_oflo = TRUE;
#if CSP_DEBUG >= 2
        printf("    Intercept overflow detected\n");
#endif
        return;
        }
    }

/* Make Y values relative to bottom of current band */
y = ystart = ystart - sp_globals.y_band.band_min;
yend -= sp_globals.y_band.band_min;

if (dx == 0)                    /* Vertical vector? */
    {
    x = (xstart_spxl + sp_globals.pixrnd) >> sp_globals.pixshift;
    if (dy > 0)                 /* Direction is up? */
        {
        props_value = pCspGlobals->reverseContour? 0: UP_INTERCEPT;
        do
            {
            sp_add_intercept_quick(pCspGlobals, y, x, props_value);
            }
        while (++y <= yend);
        }
    else                        /* Direction is down? */
    	{
        props_value = pCspGlobals->reverseContour? UP_INTERCEPT: 0;
        do
            {
            sp_add_intercept_quick(pCspGlobals, y, x, props_value);
            }
        while (--y >= yend);
        }
	}
else                            /* Neither horizontal nor vertical */
    {
    /* Compute slope as signed 16.16 value */
    dxdy = ((ufix32)(dx >= 0? dx: -dx) << 16) / (ufix32)(dy >= 0? dy: -dy);
    if ((dx >= 0) ^ (dy >= 0))
        {
        dxdy = -dxdy;
        }

#if MSDOS
    tmpfix31 = 
        (fix31)(xstart_spxl + sp_globals.pixrnd) << 
               (16 - sp_globals.pixshift);
    xx = (fix31)(((ystart + sp_globals.y_band.band_min) << 
                  sp_globals.pixshift) - ystart_spxl + sp_globals.pixrnd);
    xx = ((xx * dxdy) >> sp_globals.pixshift) + tmpfix31;
#else
    xx  = 
        ((fix31)(xstart_spxl + sp_globals.pixrnd) << 
                (16 - sp_globals.pixshift)) +
               (((((ystart + sp_globals.y_band.band_min) << 
                   sp_globals.pixshift) - 
                  ystart_spxl + sp_globals.pixrnd) *
                 dxdy) >> 
                sp_globals.pixshift);
#endif

    if (dy > 0)                 /* Upwards direction? */
        {
        props_value = pCspGlobals->reverseContour? 0: UP_INTERCEPT;
		while (TRUE)
			{
            sp_add_intercept_quick(
                pCspGlobals, 
                y, 
                (fix15)(xx >> 16), 
                props_value);
            if (++y > yend)
            	break;
            xx += dxdy;
            }
        }
    else                        /* Downwards direction? */
        {
        props_value = pCspGlobals->reverseContour? UP_INTERCEPT: 0;
		while (TRUE)
			{
            sp_add_intercept_quick(
                pCspGlobals, 
                y, 
                (fix15)(xx >> 16), 
                props_value);
            if (--y < yend)
            	break;
            xx -= dxdy;
            }
        }
    }

if (salient_detected)           /* Salient at start point? */
    {
    y = yend - ystart;          /* Number of intercepts - 1 */
    if (y < 0)
        {
        y = -y;
        }
    y = sp_globals.next_offset - y - 1; /* End salient intercept index */
    sp_mark_salient_quick(
        pCspGlobals, 
        ystart, 
        (fix15)(y - 1), 
        y);
    }
}

FUNCTION 
void CspEndContourQuick(
    cspGlobals_t *pCspGlobals)
/* 
 *  Called after the last vector in each contour
 *  Tests for the presence of a salient between the first and last
 *  intercepts of the contour.
 */
{
props_t upIntercept;

#if CSP_DEBUG >= 2
printf("CspEndContourQuick()\n");
#endif

if ((sp_globals.next_offset - sp_globals.sp_first_contour_offset >= 2) &&
    !sp_globals.sp_clipped_first_salient &&
    !sp_globals.sp_clipped_salient &&
    (sp_globals.sp_old_yend >= sp_globals.y_band.band_min) &&
    (sp_globals.sp_old_yend <= sp_globals.y_band.band_max))
    {
    upIntercept = pCspGlobals->reverseContour? 0: UP_INTERCEPT;

    if (((sp_intercepts.inttype[sp_globals.next_offset - 1] & UP_INTERCEPT) == upIntercept) &&
        ((sp_intercepts.inttype[sp_globals.sp_first_contour_offset] & UP_INTERCEPT) != upIntercept) &&
        (sp_globals.y_pxl - 1 == sp_globals.sp_old_yend))
        {
        sp_mark_salient_quick(
            pCspGlobals, 
            (fix15)(sp_globals.sp_old_yend - sp_globals.y_band.band_min), 
            (fix15)(sp_globals.next_offset - 1), 
            sp_globals.sp_first_contour_offset);
        }
    else if
       (((sp_intercepts.inttype[sp_globals.next_offset - 1] & UP_INTERCEPT) != upIntercept) &&
        ((sp_intercepts.inttype[sp_globals.sp_first_contour_offset] & UP_INTERCEPT) == upIntercept) &&
        (sp_globals.y_pxl == sp_globals.sp_old_yend))
        {
        sp_mark_salient_quick(
            pCspGlobals, 
            (fix15)(sp_globals.sp_old_yend - sp_globals.y_band.band_min), 
            (fix15)(sp_globals.next_offset - 1), 
            sp_globals.sp_first_contour_offset);
        }
    }
}

FUNCTION 
boolean CspEndSubCharQuick(
    cspGlobals_t *pCspGlobals)
/*
 *  Called after the last contour in each sub-character in a compound character.
 *  Marks scanlines with runs from 2 or more sub-characters compound.
 *  Marks scanline intervals adjacent to compound scanlines complex.
 */
{
fix15   first_y;
fix15   last_y;
fix15   y;

#if CSP_DEBUG >= 2
printf("CspEndSubCharQuick()\n");
#endif

if (sp_globals.next_offset != 
    sp_globals.sp_first_sub_char_offset) /* Non-blank sub-char? */
    {
    /* Determine range of Y values affected by sub-character */
    first_y = (sp_globals.y_band.band_max < sp_globals.sp_sub_band_max)?
        sp_globals.y_band.band_max:
        sp_globals.sp_sub_band_max;

    last_y = (sp_globals.y_band.band_min > sp_globals.sp_sub_band_min)?
        sp_globals.y_band.band_min:
        sp_globals.sp_sub_band_min;

    /* Adjust Y values to be relative to bottom of current Y band */
    first_y -= sp_globals.y_band.band_min;
    last_y -= sp_globals.y_band.band_min;

    for (y = first_y; y >= last_y; y--)
        {
        if (sp_intercepts.cdr[y] >= 
            sp_globals.sp_first_sub_char_offset) /* New intercepts added? */
            {
            switch(sp_intercepts.inttype[y] & SUB_CHAR_COUNT) /* How many sub_chars? */
                {
            case 0:             /* First sub-char at this y value? */
                sp_intercepts.inttype[y]++;  /* Increment sub_char count */
                break;

            case 1:             /* Second sub_char at this y value? */
                sp_intercepts.inttype[y]++;  /* Increment sub-char count */
                sp_intercepts.inttype[y] |= 
                    COMPLEX_INTERVAL_BELOW +
                    COMPOUND_SCANLINE_FLAG;
                if ((y + 1) < (fix15)sp_globals.no_y_lists)
                    {
                    sp_intercepts.inttype[y + 1] |= COMPLEX_INTERVAL_BELOW;
                    }
                break;

            default:            /* Third and subsequent sub-chars? */
                break;
                }
            }
        }    
    }

return TRUE;
}

FUNCTION 
boolean CspEndCharQuick(
    cspGlobals_t *pCspGlobals)
/* 
 *  Called when all character data has been output
 *  Return TRUE if output process is complete
 *  Return FALSE to repeat output of the transformed data beginning
 *  with the first contour
 *  Calls open_bitmap() to inititiate the bitmap output process.
 *  Calls sp_proc_intercepts_quick() to output each band of intercepts
 *  Calls sp_flush_intercepts_quick() to output the last scanline
 *  Calls close_bitmap() to terminate the bitmap output process
 */
{
fix31 xorg;
fix31 yorg;
fix15 tmpfix15;

#if CSP_DEBUG >= 2
printf("CspEndCharQuick()\n");
printf("Transformed character bounding box is %3.1f, %3.1f, %3.1f, %3.1f\n", 
    (real)sp_globals.bmap_xmin / (real)sp_globals.onepix, 
    (real)sp_globals.bmap_ymin / (real)sp_globals.onepix, 
    (real)sp_globals.bmap_xmax / (real)sp_globals.onepix, 
    (real)sp_globals.bmap_ymax / (real)sp_globals.onepix);
#endif

if (sp_globals.first_pass)
    {
    if (sp_globals.bmap_xmax >= sp_globals.bmap_xmin) /* Non-blank character? */
        {
        sp_globals.xmin = 
            (sp_globals.bmap_xmin + sp_globals.pixrnd - 1) >> 
            sp_globals.pixshift;
        sp_globals.ymin = 
            (sp_globals.bmap_ymin + sp_globals.pixrnd - 1) >> 
            sp_globals.pixshift;
        sp_globals.xmax = 
            (sp_globals.bmap_xmax + sp_globals.pixrnd) >> 
            sp_globals.pixshift;
        sp_globals.ymax = 
            (sp_globals.bmap_ymax + sp_globals.pixrnd) >> 
            sp_globals.pixshift;
        }
    else                        /* Blank character? */
        {
        sp_globals.xmin = sp_globals.xmax = 0;
        sp_globals.ymin = sp_globals.ymax = 0;
        }

    /* Origin is at bottom left of bitmap bounding box */
    xorg = (fix31)sp_globals.xmin << 16;
   	yorg = (fix31)sp_globals.ymin << 16;

    /* Restore fractional components of origin */
    if (sp_globals.tcb.xmode == 0)      /* X pix is function of X orus only? */
        {
    	xorg += (fix31)sp_globals.rnd_xmin << sp_globals.poshift;
        }
    else if (sp_globals.tcb.xmode == 1) /* X pix is function of -X orus only? */
        {
      	xorg -= (fix31)sp_globals.rnd_xmin << sp_globals.poshift;
        }

    if (sp_globals.tcb.ymode == 2)      /* Y pix is function of X orus only? */
        {
    	yorg += (fix31)sp_globals.rnd_xmin << sp_globals.poshift;
        }
    else if (sp_globals.tcb.ymode == 3) /* Y pix is function of -X orus only? */
        {
      	yorg -= (fix31)sp_globals.rnd_xmin << sp_globals.poshift;
        }
    
    (*pCspGlobals->rawBmapFns.OpenBitmap)(
        pCspGlobals,
        (long)sp_globals.set_width.x, 
        (long)sp_globals.set_width.y, 
        (long)xorg, 
        (long)yorg,
        (short)(sp_globals.xmax - sp_globals.xmin), 
        (short)(sp_globals.ymax - sp_globals.ymin));

    if (sp_globals.intercept_oflo)      /* Intercept overflow on first pass? */
        {
        sp_globals.y_band.band_max = sp_globals.ymax - 1;
        sp_globals.y_band.band_min = 
            (sp_globals.ymin + sp_globals.y_band.band_max) >> 1;
        sp_init_intercepts_quick(pCspGlobals);
        sp_globals.first_pass = FALSE;
        sp_globals.extents_running = FALSE;
        return FALSE;
        }
    else                        /* No intercept overflow on first pass? */
        {
        /* Output accumulated bitmap data */
        sp_proc_intercepts_quick(pCspGlobals);  

        /* Flush pipelined bitmap data */
        sp_flush_intercepts_quick(pCspGlobals);

        /* Close bitmap output */
        (*pCspGlobals->rawBmapFns.CloseBitmap)(pCspGlobals);

        return TRUE;            /* Flag successful completion */
        }
    }
else                            /* Second or subsequent pass? */
    {
    if (sp_globals.intercept_oflo)  /* Intercept overflow? */
        {
        sp_globals.y_band.band_min = 
            (sp_globals.y_band.band_min + 
             sp_globals.y_band.band_max) >> 1;  /* Halve band size */

        /* Init intercept storage for reduced  band */
        sp_init_intercepts_quick(pCspGlobals);
        return FALSE;
        }

    /* Output accumulated bitmap data */
    sp_proc_intercepts_quick(pCspGlobals);

    /* Clean up if all bands completed */
    if (sp_globals.y_band.band_min <= sp_globals.ymin)
        {
        /* Flush pipelined bitmap data */
        sp_flush_intercepts_quick(pCspGlobals); 

        /* Close bitmap output */
        (*pCspGlobals->rawBmapFns.CloseBitmap)(pCspGlobals);

        return TRUE;            /* Flag successful completion */
        }

    /* Move down to the next band */
    tmpfix15 = sp_globals.y_band.band_max - sp_globals.y_band.band_min;
    sp_globals.y_band.band_max = sp_globals.y_band.band_min;
    sp_globals.y_band.band_min = sp_globals.y_band.band_max - tmpfix15;

    /* Truncate band if it extends beyond bottom of character */
    if (sp_globals.y_band.band_min < sp_globals.ymin)
        {
        sp_globals.y_band.band_min = sp_globals.ymin;
        }

    /* Initialize intercepts structure for the new band */
    sp_init_intercepts_quick(pCspGlobals);

    return FALSE;               /* Flag output incomplete */
    }
}

FUNCTION 
static void sp_init_intercepts_quick(
    cspGlobals_t *pCspGlobals)
/*
 *  Called to initialize intercept storage data structure
 *  for the currently defined band
 */
{
fix15 y;

#if CSP_DEBUG >= 2
printf("Init intercepts (Y band from %d to %d)\n", 
    sp_globals.y_band.band_min, sp_globals.y_band.band_max);
#endif 

sp_globals.no_y_lists = 
    (fix31)sp_globals.y_band.band_max - sp_globals.y_band.band_min + 1;
sp_globals.intercept_oflo = 
    sp_globals.no_y_lists >= (fix31)MAX_INTERCEPTS_QUICK;
if (sp_globals.intercept_oflo)  /* List table won't fit? */
    {
    sp_globals.no_y_lists = (fix31)MAX_INTERCEPTS_QUICK;
	sp_globals.y_band.band_min = 
        sp_globals.y_band.band_max - MAX_INTERCEPTS_QUICK + 1;
    }

/* Clear intercepts structure */
for (y = 0; y < (fix15)sp_globals.no_y_lists; y++)
    {
    sp_intercepts.cdr[y] = 0;   /* Mark each intercept list empty */
    sp_intercepts.inttype[y] = 0; /* Clear all intercept list flags */
    }

sp_intercepts.inttype[sp_globals.no_y_lists - 1] |= COMPLEX_INTERVAL_BELOW;
sp_globals.sp_first_sub_char_offset = sp_globals.next_offset = 
    (fix15)sp_globals.no_y_lists;
sp_globals.sp_horiz_gap_found = FALSE;
}

FUNCTION INLINE
static void sp_add_intercept_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y,                /* Y coordinate relative to bottom of band */
    fix15 x,                /* X coordinate of intercept in subpixel units */
    props_t props_value)    /* Value of intercept properties field */
/*
 *  Called by line_quick() to add one intercept to the intercept list 
 *  structure.
 *  Assumes that the caller has checked that there is sufficient space.
 */
{
fix15 from;             /* Insertion pointers for the linked list sort */
fix15 to;

#if CSP_DEBUG >= 2
printf("    Add intercept(%2d, %d, %0.4x)\n", 
    y + sp_globals.y_band.band_min, x, props_value);
#endif

#if CSP_DEBUG >= 1
if (y < 0)                      /* Y value below bottom of current band? */
    {
    printf("*** Intecerpt Y value below bottom of band\n");
    return;
    }

if (y >= (fix15)sp_globals.no_y_lists) /* Y value above top of current band? */
    {
    printf("*** Intercept Y value above top of band\n");
    return;
    }

if (sp_globals.next_offset > MAX_INTERCEPTS_QUICK)
    {
    printf("*** Intercept list overflow\n");
    return;
    }
#endif

sp_intercepts.car[sp_globals.next_offset] = x;
sp_intercepts.inttype[sp_globals.next_offset] = props_value;

/* Find slot to insert new element (between from and to) */
from = y;                       /* Start at list head */
while (
    (to = sp_intercepts.cdr[from]) >= 
    sp_globals.sp_first_sub_char_offset) /* To end of list */
    {
    if (x <= sp_intercepts.car[to])        /* Time to insert new item? */
        {
        break;                  /* Drop out of loop and insert here */
        }
    from = to;                  /* Move down intercept list */
    }

/* Insert or append to end of list */
sp_intercepts.cdr[from] = sp_globals.next_offset;
sp_intercepts.cdr[sp_globals.next_offset++] = to;
}

FUNCTION
static void sp_mark_salient_quick(
    cspGlobals_t *pCspGlobals,
    fix15   y,      /* Index to y-intercept list */
    fix15   i1,     /* Index to intercept at start of salient */
    fix15   i2)     /* Index to intercept at end of salient */
/*
 *  Marks the intercepts at i1 and i2 as the beginning and end respectively
 *  of a salient.
 *  If the up intercept is to the right of the down intercept, the
 *  salient type is marked solid; otherwise it is marked hollow.
 *  Note that the designations solid and hollow are arbitrary and take
 *  on exchanged meanings when mirror imaging is in effect.
 *  Also sets the appropriate scanline y flags associated with the salient.
 */
{
fix15   y_interval;
fix15   i_up;
fix15   i_dn;

#if CSP_DEBUG >= 2
if (y < 0)
    {
    printf("*** sp_mark_salient_quick(): y < 0\n");
    }
if (y >= (fix15)sp_globals.no_y_lists)
    {
    printf("*** sp_mark_salient_quick(): y >= sp_globals.no_y_lists\n");
    }
#endif

/* Swap start and end if contour reversed */
if (pCspGlobals->reverseContour)
    {
    i_up = i1;
    i1 = i2;
    i2 = i_up;
    }

if (sp_intercepts.inttype[i1] & UP_INTERCEPT)
    {
    i_up = i1;
    i_dn = i2;
    y_interval = y + 1;
    }
else
    {
    i_up = i2;
    i_dn = i1;
    y_interval = y;
    }

if (sp_intercepts.car[i_up] > sp_intercepts.car[i_dn]) /* Solid salient? */
    {
    sp_intercepts.inttype[i1] |= BEGIN_SOLID_SALIENT;
    sp_intercepts.inttype[i2] |= END_SOLID_SALIENT;
    sp_intercepts.inttype[y] |= SOLID_SALIENT_FLAG;
    if (sp_intercepts.inttype[y] & HOLLOW_SALIENT_FLAG)
        {
        sp_globals.sp_horiz_gap_found = TRUE;
        }
    if (y_interval < (fix15)sp_globals.no_y_lists)
        {
        sp_intercepts.inttype[y_interval] |= COMPLEX_INTERVAL_BELOW;
        }
#if CSP_DEBUG >= 2
    printf("    Solid salient at Y = %d\n", y + sp_globals.y_band.band_min);
#endif
    }
else                            /* Hollow salient? */
    {
    sp_intercepts.inttype[i1] |= BEGIN_HOLLOW_SALIENT;
    sp_intercepts.inttype[i2] |= END_HOLLOW_SALIENT;
    sp_intercepts.inttype[y] |= HOLLOW_SALIENT_FLAG;
    if (sp_intercepts.inttype[y] & SOLID_SALIENT_FLAG)
        {
        sp_globals.sp_horiz_gap_found = TRUE;
        }
    if (y_interval < (fix15)sp_globals.no_y_lists)
        {
        sp_intercepts.inttype[y_interval] |= COMPLEX_INTERVAL_BELOW;
        }
#if CSP_DEBUG >= 2
    printf("    Hollow salient at Y = %d\n", y + sp_globals.y_band.band_min);
#endif
    }
}

FUNCTION 
static void sp_proc_intercepts_quick(
    cspGlobals_t *pCspGlobals)
/*
 *  Called by end_char_quick() to output accumulated intercept lists
 *  for the current band.
 */
{
fix15   first_y;
fix15   y;
fix15   scanline;
fix15   i1;
fix15   j1;
fix15   i2;
fix15   j2;
fix15   x_start1;
fix15   x_start2;
fix15   x_end1;
fix15   x_end2;

first_y = (fix15)sp_globals.no_y_lists - 1;

#if CSP_DEBUG >= 2
printf("\nsp_proc_intercepts_quick:\n");
#endif

/* Close gaps (if any) within scanlines */
if (sp_globals.sp_horiz_gap_found)
    {
    for (y = first_y; y > 0; y--)
        {
        if ((sp_intercepts.inttype[y] &
            (SOLID_SALIENT_FLAG + HOLLOW_SALIENT_FLAG)) ==
            (SOLID_SALIENT_FLAG + HOLLOW_SALIENT_FLAG))
            {
            sp_close_horiz_gaps_quick(pCspGlobals, y);
            }
        }
    }

scanline = sp_globals.ymax - sp_globals.y_band.band_min - first_y - 1;
for (y = first_y; y > 0; y--, scanline++)
    {
#if CSP_DEBUG >= 2
    /* Print intercept list for this scanline */
    print_intercepts(pCspGlobals, y);
#endif
    if (sp_intercepts.inttype[y] & 
        (COMPLEX_INTERVAL_BELOW |
         COMPLEX_SCANLINE_FLAG))
        {
        sp_close_diag_gaps_quick(pCspGlobals, y);
        if (sp_intercepts.inttype[y] & COMPOUND_SCANLINE_FLAG)
            {
            sp_sort_intercepts_quick(pCspGlobals, y);
            }

        sp_output_complex_scanline_quick(pCspGlobals, y, scanline);
        sp_check_scanline_quick(pCspGlobals, (fix15)(y - 1));
        }
    else						/* Simple scanline? */
        {
		if ((i1 = sp_intercepts.cdr[y]) == 0) /* Intercept list empty? */
    		{
    		continue;
    		}

		i2 = sp_intercepts.cdr[y - 1]; /* First intercept in next scanline */
		if (sp_intercepts.car[i2] < sp_globals.xmin) /* Outside bounding box? */
    		{
    		sp_intercepts.inttype[y - 1] |= COMPLEX_SCANLINE_FLAG;
#if CSP_DEBUG >= 1
    		printf("*** sp_proc_intercepts_quick: First intercept outside bbox on lower scanline\n");
#endif
		    }

		do
    		{
#if CSP_DEBUG >= 1
    		if (i1 == 0)
        		{
        		printf("*** sp_proc_intercepts_quick: Too few intercepts on upper scanline\n");
        		}
    		if ((sp_intercepts.cdr[i1] == 0) || (sp_intercepts.cdr[i2] == 0))
        		{
        		printf("*** sp_proc_intercepts_quick: Odd number of intercepts\n");
        		}
#endif
            x_start1 = sp_intercepts.car[i1];
            j1 = sp_intercepts.cdr[i1];
            x_end1 = sp_intercepts.car[j1];

            x_start2 = sp_intercepts.car[i2];
            j2 = sp_intercepts.cdr[i2];
            x_end2 = sp_intercepts.car[j2];
    		
    		/* Fill diagonal gaps if present */
    		if (x_start2 > x_end1)		/* Lower run starts after upper one ends? */
        		{
#if CSP_DEBUG >= 2
        		printf("simple_close_gap(%d, -, -, %d)\n", x_end1, x_start2);
#endif
        		x_end1 = sp_intercepts.car[i2] = (x_end1 + x_start2) >> 1;
        		}
    		else if (x_start1 > x_end2) /* Upper run starts after lower one ends? */
        		{
#if CSP_DEBUG >= 2
        		printf("simple_close_gap(-, %d, %d, -)\n", x_start1, x_end2);
#endif
        		sp_intercepts.car[j2] = x_start1 = (x_end2 + x_start1) >> 1;
        		}

    		/* Output run of bits */
    		(*pCspGlobals->rawBmapFns.SetBitmapBits)(
          pCspGlobals,
        		(short)scanline, 
        		(short)(x_start1 - sp_globals.xmin), 
        		(short)(x_end1 - sp_globals.xmin));

    		/* Check for zero_length run on next scanline */
    		if (x_start2 == x_end2) /* Zero-length run on next line? */
        		{
        		sp_intercepts.inttype[y - 1] |= COMPLEX_SCANLINE_FLAG;
        		if (x_start1 < x_start2)
            		{
            		sp_intercepts.inttype[i2]++; /* Mark start of run extendible */
            		}
        		if (x_end1 > x_end2)
            		{
            		sp_intercepts.inttype[j2]++; /* Mark end of run extendible */
            		}
        		}

    		/* Check for overlapping runs on next scanline */
    		if (((sp_intercepts.inttype[i2] ^ sp_intercepts.inttype[j2]) & UP_INTERCEPT) == 0) 
        		{
        		sp_intercepts.inttype[y - 1] |= COMPLEX_SCANLINE_FLAG;
        		}
        		
			i1 = sp_intercepts.cdr[j1];
    		} 
    	while ((i2 = sp_intercepts.cdr[j2]) != 0);

#if CSP_DEBUG >= 1
		if (i1 != 0)
    		{
    		printf("*** sp_proc_intercepts_quick: Too few intercepts on lower scanline\n");
    		}
#endif

		if (x_end2 > sp_globals.xmax)
    		{
   			sp_intercepts.inttype[y - 1] |= COMPLEX_SCANLINE_FLAG;
#if CSP_DEBUG >= 1
    		printf("*** sp_proc_intercepts_quick: Last intercept outside bbox on next scanline\n");
#endif
    		}
        }
    }
}

FUNCTION 
static void sp_flush_intercepts_quick(
    cspGlobals_t *pCspGlobals)
/*
 *  Called by end_char_quick() to output accumulated intercept lists
 *  in last scanline (if any).
 */
{
fix15   y;
fix15   scanline;

#if CSP_DEBUG >= 2
printf("\nsp_flush_intercepts_quick:\n");
#endif

if (sp_globals.no_y_lists > 0)  /* At least one scanline? */
    {
    y = 0;

#if CSP_DEBUG >= 2
    print_intercepts(pCspGlobals,y);
#endif

    if ((sp_intercepts.inttype[y] &
        (SOLID_SALIENT_FLAG + HOLLOW_SALIENT_FLAG)) ==
        (SOLID_SALIENT_FLAG + HOLLOW_SALIENT_FLAG))
        {
        sp_close_horiz_gaps_quick(pCspGlobals, y);
        }

    if (sp_intercepts.inttype[y] & COMPOUND_SCANLINE_FLAG)
        {
        sp_sort_intercepts_quick(pCspGlobals, y);
        }

	scanline = sp_globals.ymax - sp_globals.y_band.band_min - y - 1;
    sp_output_complex_scanline_quick(pCspGlobals, y, scanline);
    }
}

FUNCTION 
static void sp_close_horiz_gaps_quick(
    cspGlobals_t *pCspGlobals,
    fix15   y)
/*
 *  Called by sp_proc_intercepts_quick() and sp_flush_intercepts_quick() to close any gaps 
 *  within a specified scanline. Candidate scanlines are those that contain
 *  both hollow and solid salients.
 *  Each intercept in the scanline is tested to see if it the beginning
 *  or end of a salient. 
 *  A hollow salient count and a solid salient count start at zero.
 *  The appropriate count is incremented or decremented for each beginging and 
 *  each end of a salient. Incrementing is carried out for up intercepts; 
 *  decrementing for down intercepts. 
 *  Simultaneously, a winding number is incremented for each up intercept
 *  and decremented for each down intercept.
 *  A gap to be closed is identified by detecting an interval between a pair 
 *  of consecutive intercepts for which the current winding number is zero 
 *  and both accumulated salient counts are non-zero.
 *  A gap is closed by extending the preceding and following runs to the
 *  min-point of the gap.
 */
{
fix15   winding_number;
fix15   hollow_salient_count;
fix15   solid_salient_count;
fix15   i;

#if CSP_DEBUG >= 2
printf("sp_close_horiz_gaps_quick(%d)\n", y);
#endif

winding_number = 0;
hollow_salient_count = 0;
solid_salient_count = 0;
i = sp_intercepts.cdr[y];
while (i != 0)
    {
    if (sp_intercepts.inttype[i] & UP_INTERCEPT)
        {
        winding_number++;

        if (sp_intercepts.inttype[i] & BEGIN_SOLID_SALIENT)
            {
            solid_salient_count++;
            }

        if (sp_intercepts.inttype[i] & END_SOLID_SALIENT)
            {
            solid_salient_count++;
            }

        if (sp_intercepts.inttype[i] & BEGIN_HOLLOW_SALIENT)
            {
            hollow_salient_count++;
            }

        if (sp_intercepts.inttype[i] & END_HOLLOW_SALIENT)
            {
            hollow_salient_count++;
            }
        }
    else
        {
        winding_number--;

        if (sp_intercepts.inttype[i] & BEGIN_SOLID_SALIENT)
            {
            solid_salient_count--;
            }

        if (sp_intercepts.inttype[i] & END_SOLID_SALIENT)
            {
            solid_salient_count--;
            }

        if (sp_intercepts.inttype[i] & BEGIN_HOLLOW_SALIENT)
            {
            hollow_salient_count--;
            }

        if (sp_intercepts.inttype[i] & END_HOLLOW_SALIENT)
            {
            hollow_salient_count--;
            }
        }

    if ((winding_number == 0) &&
        (hollow_salient_count != 0) &&
        (solid_salient_count != 0))
        {

#if CSP_DEBUG >= 2
        printf("sp_close_horiz_gaps_quick(%d, %d)\n", 
            sp_intercepts.car[i], sp_intercepts.car[sp_intercepts.cdr[i]]);
#endif

        sp_intercepts.car[i] = 
            sp_intercepts.car[sp_intercepts.cdr[i]] = (sp_intercepts.car[i] + sp_intercepts.car[sp_intercepts.cdr[i]]) >> 1;
        }
    i = sp_intercepts.cdr[i];
    }

#if CSP_DEBUG >= 1
if (solid_salient_count || hollow_salient_count)
    {
    printf("*** sp_close_horiz_gaps_quick: non-zero salient count at end of list\n");
    }
#endif
}

FUNCTION 
static void sp_close_diag_gaps_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y)
/*
 *  Called by sp_proc_intercepts_quick() to close any diagnoal gaps between 
 *  the specified scanline and the scanline immediatly below it.
 *  Accomplished by pairing groups of runs from the upper and lower scanlines
 *  and then detecting and closing any gaps between them.
 */
{
fix15   i1;
fix15   i2;
fix15   i1_start;
fix15   i1_end;
fix15   i2_start;
fix15   i2_end;

#if CSP_DEBUG >= 1
if ((y < 1) || (y >= (fix15)sp_globals.no_y_lists))
    {
    printf("*** sp_close_diag_gaps_quick(%d): y out of range\n", y);
    }
#endif

i1 = sp_intercepts.cdr[y];      /* Index of head of upper intercept list */
i2 = sp_intercepts.cdr[y - 1];  /* Index to head of lower intercept list */
while ((i1 != 0) &&
    (sp_assemble_group_pair_quick(
        pCspGlobals, i1, i2, &i1_start, &i1_end, &i2_start, &i2_end)))
    {
    sp_proc_group_pair_quick(pCspGlobals, i1_start, i1_end, i2_start, i2_end);
    i1 = sp_intercepts.cdr[i1_end];
    i2 = sp_intercepts.cdr[i2_end];
    }
}

FUNCTION 
static boolean sp_assemble_group_pair_quick(
    cspGlobals_t *pCspGlobals,
    fix15   i1,         /* Index to start of upper intercept list */
    fix15   i2,         /* Index to start of lower intercept list */
    fix15  *pi1_start,	/* Index to start of upper group */
    fix15  *pi1_end,	/* Index to end of upper group */
    fix15  *pi2_start,	/* Index to start of lower group */
    fix15  *pi2_end)	/* Index to end of lower group */
/*
 *  Called by sp_proc_intercepts_quick() to assemble a corresponding pair of 
 *  groups of one or more runs on the upper and lower scanlines.
 */
{
fix15   n_open_intercepts;
fix15   min_open_intercepts;

sp_assemble_group_quick(pCspGlobals, 
    i1,
    (props_t)(END_SOLID_SALIENT | END_HOLLOW_SALIENT),
    (props_t)(BEGIN_SOLID_SALIENT | BEGIN_HOLLOW_SALIENT),
    (fix15)1,
    pi1_start,
    pi1_end,
    &n_open_intercepts);

if (n_open_intercepts == 0)
    {
    return FALSE;
    }

while (TRUE)
    {
    min_open_intercepts = n_open_intercepts;
    sp_assemble_group_quick(pCspGlobals, 
        i2,
        (props_t)(BEGIN_SOLID_SALIENT | BEGIN_HOLLOW_SALIENT),
        (props_t)(END_SOLID_SALIENT | END_HOLLOW_SALIENT),
        min_open_intercepts,
        pi2_start,
        pi2_end,
        &n_open_intercepts);

#if CSP_DEBUG >= 1
    if (n_open_intercepts < min_open_intercepts)
        {
        printf("*** sp_assemble_group_pair_quick: Can't assemble matching group (2)\n");
        }
#endif

    if (n_open_intercepts == min_open_intercepts)
        {
        return TRUE;
        }

    min_open_intercepts = n_open_intercepts;
    sp_assemble_group_quick(pCspGlobals, 
        i1,
        (props_t)(END_SOLID_SALIENT | END_HOLLOW_SALIENT),
        (props_t)(BEGIN_SOLID_SALIENT | BEGIN_HOLLOW_SALIENT),
        min_open_intercepts,
        pi1_start,
        pi1_end,
        &n_open_intercepts);

#if CSP_DEBUG >= 1
    if (n_open_intercepts < min_open_intercepts)
        {
        printf("*** sp_assemble_group_pair_quick: Can't assemble matching group (1)\n");
        }
#endif

    if (n_open_intercepts == min_open_intercepts)
        {
        return TRUE;
        }
    }
}

FUNCTION
static void sp_assemble_group_quick(
    cspGlobals_t *pCspGlobals,
    fix15   i, 
    props_t up_salient_mask, 
    props_t down_salient_mask, 
    fix15   min_open_intercepts,
    fix15   *pi_start,
    fix15   *pi_end,
    fix15   *pn_open_intercepts)
/*
 *  Identifies the next group in the given intercept list
 *  that has at least the specified number of open intercepts.
 *  An open intercept is one that is not associated with a
 *  relevent salient. The up_salient_mask selects relevant
 *  salients for up intercepts. The down-salient_mask selects
 *  relevant salients for down intercepts.
 *  A group consists of at least one run of pixels that ends
 *  with a zero winding number.
 */
{
fix15   winding_number;
fix15   salient_count;

*pn_open_intercepts = 0;        

if (i == 0)                     /* Empty intercept list? */
    {
    return;
    }

winding_number = 0;
salient_count = 0;
*pi_start = i;
while (i != 0)                  /* For each intercept... */
    {
    if (sp_intercepts.inttype[i] & UP_INTERCEPT) /* Up intercept? */
        {
        winding_number++;
        if (sp_intercepts.inttype[i] & up_salient_mask)
            {
            salient_count++;
            }
        else
            {
            *pn_open_intercepts += 1;
            }
        }
    else                        /* Down intercept? */
        {
        winding_number--;
        if (sp_intercepts.inttype[i] & down_salient_mask)
            {
            salient_count--;
            }
        else
            {
            *pn_open_intercepts += 1;
            }
        }

    if ((winding_number == 0) &&
        (salient_count == 0))   /* End of group? */
        {
        if (*pn_open_intercepts >= min_open_intercepts)
            {
            *pi_end = i;
            return;
            }

        if (*pn_open_intercepts == 0) /* Isolated terminal? */
            {
            *pi_start = sp_intercepts.cdr[i];
            }
        }

    i = sp_intercepts.cdr[i];
    }
}

FUNCTION
static void sp_proc_group_pair_quick(
    cspGlobals_t *pCspGlobals,
    fix15   i1_start,
    fix15   i1_end,
    fix15   i2_start,
    fix15   i2_end)
/*
 *  Processes a group of one or more runs from the upper scanline and the
 *  corresponding group of one or more runs from the lower scanline.
 *  Increments the extendibility of zero-length groups in either scanline
 *  whose corresponding group of one or more runs in the other scanline 
 *  extend beyond them.
 *  Fills any detected gaps by choosing the runs that require
 *  the minimum extensions to maintain continuity.
 */
{
fix15   x1_start;
fix15   x1_end;
fix15   x2_start;
fix15   x2_end;
fix15   i1_gap_start;
fix15   i2_gap_start;
fix15   i1;
fix15   i2;
fix15   winding_number1;
fix15   winding_number2;

#if CSP_DEBUG >= 2
printf("sp_proc_group_pair_quick(%d, %d, %d, %d)\n", 
    sp_intercepts.car[i1_start], 
    sp_intercepts.car[i1_end], 
    sp_intercepts.car[i2_start],
    sp_intercepts.car[i2_end]);
#endif

/* Increment extendability of zero-length runs */
x1_start = sp_intercepts.car[i1_start];
x1_end = sp_intercepts.car[i1_end];
x2_start = sp_intercepts.car[i2_start];
x2_end =sp_intercepts.car[i2_end];

if (x1_start == x1_end)
    {
    if (x2_start < x1_start)
        {
        sp_intercepts.inttype[i1_start]++;
        }
    if (x2_end > x1_end)
        {
        sp_intercepts.inttype[i1_end]++;
        }
    }

if (x2_start == x2_end)
    {
    if (x1_start < x2_start)
        {
        sp_intercepts.inttype[i2_start]++;
        }
    if (x1_end > x2_end)
        {
        sp_intercepts.inttype[i2_end]++;
        }
    }

/* Detect and fill gaps within the pair of corresponding groups */
i1_gap_start = i2_gap_start = 0;
i1 = i1_start;
i2 = i2_start;
winding_number1 = 0;
winding_number2 = 0;
while (TRUE)                    /* Loop for each detected gap */
    {
    do                          /* Loop to find next gap */
        {
        if (i1 == 0)            /* At end of group in upper scanline? */
            {
            if (i2 == 0)        /* At end of group in lower scanline? */
                {
                return;
                }
            goto L2;            /* Step across lower scanline */
            }

        if (i2 == 0)            /* At end of group in upper scanline? */
            goto L1;            /* Step across upper scanline */

        /* Test if next intercept in lower scanline */
        if (sp_intercepts.car[i1] > sp_intercepts.car[i2]) 
            goto L2;            /* Step across lower scanline */

    	/* Step one intercept across upper scanline */
    L1: if (sp_intercepts.inttype[i1] & UP_INTERCEPT)
            {
            winding_number1++;
            }
        else
            {
            winding_number1--;
            }

        if (winding_number1 == 0) /* Start of gap in upper scanline? */
            {
            i1_gap_start = i1;
            i1 = (i1 != i1_end)? sp_intercepts.cdr[i1]: 0;
            }
        else
            {
            i1 = sp_intercepts.cdr[i1];
            }
        continue;

    	/* Step one intercept across lower scanline */
    L2: if (sp_intercepts.inttype[i2] & UP_INTERCEPT)
            {
            winding_number2++;
            }
        else
            {
            winding_number2--;
            }

        if (winding_number2 == 0) /* Start of gap in lower scanline? */
            {
            i2_gap_start = i2;
            i2 = (i2 != i2_end)? sp_intercepts.cdr[i2]: 0;
            }
        else
            {
            i2 = sp_intercepts.cdr[i2];
            }
        continue;
        }
    while ((winding_number1 != 0) || (winding_number2 != 0));

    if ((i1 == 0) && (i2 == 0))
        {
        return;
        }
    sp_close_gap_quick(pCspGlobals, i1_gap_start, i1, i2_gap_start, i2);
    }
}

FUNCTION
static void sp_close_gap_quick(
    cspGlobals_t *pCspGlobals,
    fix15   i1_start,
    fix15   i1_end,
    fix15   i2_start,
    fix15   i2_end)
/*
 *  Given a pair of overlapping gaps on the upper and lower
 *  scanlines sp_close_gap_quick() adjusts the rightmost gap start
 *  point and the leftmost gap end point to coincide at
 *  the mid point between them
 */
{
fix15   i;
fix15   i_start;
fix15   i_end;
fix15   length;
fix15   min_length;
fix15   i_start_min;
fix15   i_end_min;
boolean initialized;

#if CSP_DEBUG >= 2
printf("sp_close_gap_quick(");

if (i1_start != 0) 
    printf("%d", sp_intercepts.car[i1_start]);
else 
    printf("-"); 

printf(", ");

if (i1_end != 0) 
    printf("%d", sp_intercepts.car[i1_end]);
else 
    printf("-"); 

printf(", ");

if (i2_start != 0) 
    printf("%d", sp_intercepts.car[i2_start]);
else 
    printf("-"); 

printf(", ");

if (i2_end != 0) 
    printf("%d", sp_intercepts.car[i2_end]);
else 
    printf("-"); 

printf(")\n");
#endif

/* Find shortest path for gap closing */
initialized = FALSE;
for (i = 0; i < 4; i++)
    {
    switch (i)
        {
    case 0:
        i_start = i1_start;
        i_end = i1_end;
        break;

    case 1:
        i_start = i2_start;
        i_end = i2_end;
        break;

    case 2:
        i_start = i1_start;
        i_end = i2_end;
        break;

    case 3:
        i_start = i2_start;
        i_end = i1_end;
        break;
        }

    if ((i_start == 0) ||
        (i_end == 0))
        {
        continue;
        }

    length = sp_intercepts.car[i_end] - sp_intercepts.car[i_start];
    if ((!initialized) ||
        (length < min_length))
        {
        min_length = length;
        i_start_min = i_start;
        i_end_min = i_end;
        initialized = TRUE;
        }
    }

/* Adjust selected start and end points to close gap */
if (initialized)
    {
    sp_intercepts.car[i_start_min] = sp_intercepts.car[i_end_min] =
        (sp_intercepts.car[i_start_min] + sp_intercepts.car[i_end_min]) >> 1;
    }
}

FUNCTION
static void sp_sort_intercepts_quick(
    cspGlobals_t *pCspGlobals,
    fix15   y)
/*
 *  Called by sp_proc_intercepts_quick() to sort the intercepts in the given
 *  scanline into ascending order.
 *  This is only required for those scanlines in compound characters
 *  that have received runs from two or more sub-characters. For
 *  simple characters (and scanlines in compound characters that only 
 *  receive runs from one sub-character) sorting is not needed as it
 *  has already been accomplished by sp_add_intercepts_quick() which inserts
 *  new intercepts in ascending order.
 */
{
fix15   i1;
fix15   j1;
fix15   i2;
fix15   j2;
fix15   i1_prev;

i1 = sp_intercepts.cdr[y];
if (i1 == 0)                    /* Intercept list is empty? */
    {
    return;
    }

/* Find end of main intercept list */
while (TRUE)
    {
    j1 = sp_intercepts.cdr[i1];
    if (j1 == 0)                /* End of intercept list? */
        {
        return;
        }
    if (sp_intercepts.car[i1] > 
        sp_intercepts.car[j1])  /* Intercept out of order? */
        {
        sp_intercepts.cdr[i1] = 0; /* Terminate main list */
        i2 = j1;                /* Start of list to be merged */
        break;
        }
    i1 = j1;                    /* Continue down intercept list */
    }

/* Merge list to be merged into main intercept list */
while (TRUE)
    {
    i1_prev = y;
    while ((i1 = sp_intercepts.cdr[i1_prev]) != 0) /* For each elem of main list... */
        {
        if (sp_intercepts.car[i2] <= 
            sp_intercepts.car[i1]) /* Time to merge sublist? */
            {
            sp_intercepts.cdr[i1_prev] = i2; /* Link main list into sublist */
        L1: j2 = sp_intercepts.cdr[i2];
            if (j2 == 0)        /* Last intercept in last sublist? */
                {
                sp_intercepts.cdr[i2] = i1; /* Link back into main list */
                return;
                }
            if (sp_intercepts.car[i2] > 
                sp_intercepts.car[j2]) /* Last intercept in sublist? */
                {
                sp_intercepts.cdr[i2] = i1; /* Link back into main list */
                i2 = j2;        /* Start of next sublist */
                i1_prev = y;    /* Restart main list */
                continue;
                }
            if (sp_intercepts.car[j2] <= 
                sp_intercepts.car[i1]) /* Incl next intercept in merge? */
                {
                i2 = j2;        /* Next element of sublist */
                goto L1;
                }
            sp_intercepts.cdr[i2] = i1;    /* Link back into main list */
            i2 = j2;            /* Remainder of sublist */
            }
        i1_prev = i1;
        }

    sp_intercepts.cdr[i1_prev] = i2;       /* Link to remaining sublist */
    while (TRUE)
        {
        if ((j2 = sp_intercepts.cdr[i2]) == 0) /* End of last sublist? */
            {
            return;
            }
        if (sp_intercepts.car[i2] > 
            sp_intercepts.car[j2])  /* End of sublist? */
            {
            sp_intercepts.cdr[i2] = 0;     /* Terminate merged sublist */
            i2 = j2;            /* Start of next sublist */
            break;
            }
        i2 = j2;
        }
    }
}

FUNCTION
static void sp_output_complex_scanline_quick(
    cspGlobals_t *pCspGlobals,
    fix15   y,      /* Intercept list */
    fix15	scanline)
/*
 *  This is a less restrictive, more comprhensive, slower version of the function
 *  function included within sp_proc_intercepts_quick.
 *  Runs of pixels may overlap but the individual intercepts are
 *  assumed to be in strict left-to-right order.
 */
{
fix15   i;
fix15   j;
fix15   old_x_end;
fix15   winding_number;
fix15   x_start;
fix15   x_end;
fix15   avail_pix_left;
fix15   avail_pix_right;

old_x_end = sp_globals.xmin - 2;
winding_number = 0;
i = sp_intercepts.cdr[y];
while (i != 0)                  /* Not end of intercept list? */
    {
    x_start = sp_intercepts.car[i]; /* Start of pixel run */
L1: if (sp_intercepts.inttype[i] & UP_INTERCEPT)
        {
        winding_number++;
        }
    else
        {
        winding_number--;
        }
    j = sp_intercepts.cdr[i];
    x_end = sp_intercepts.car[j];
    if (sp_intercepts.inttype[j] & UP_INTERCEPT)
        {
        winding_number++;
        }
    else
        {
        winding_number--;
        }

    if (winding_number != 0)    /* Overlapping runs? */
        {
        i = sp_intercepts.cdr[j];
        goto L1;
        }

    if (x_start < sp_globals.xmin)
        {
#if CSP_DEBUG >= 1
        printf("*** sp_output_complex_scanline_quick: Character BBox violation\n");
#endif
        x_start = sp_globals.xmin;
        if (x_end < x_start)
            {
            x_end = x_start;
            }
        }

    if (x_end > sp_globals.xmax)
        {
#if CSP_DEBUG >= 1
        printf("*** sp_output_complex_scanline_quick: Character BBox violation\n");
#endif
        x_end = sp_globals.xmax;
        if (x_end < x_start)
            {
            x_start = x_end;
            }
        }

    /* Check for zero-length run of pixels */
    if (x_start == x_end)
        {
        avail_pix_left = x_start - old_x_end;
        avail_pix_right = 
            ((sp_intercepts.cdr[j] != 0)? sp_intercepts.car[sp_intercepts.cdr[j]]: sp_globals.xmax + 2) - x_end;
        if (sp_extend_zero_length_run_quick(pCspGlobals, 
            avail_pix_left, 
            (fix15)(sp_intercepts.inttype[i] & EXTENDIBILITY),
            avail_pix_right, 
            (fix15)(sp_intercepts.inttype[j] & EXTENDIBILITY),
            &x_start, 
            &x_end))
            {
            (*pCspGlobals->rawBmapFns.SetBitmapBits)(
                pCspGlobals,
                (short)scanline, 
                (short)(x_start - sp_globals.xmin), 
                (short)(x_end - sp_globals.xmin));
            }
        }
    else
        {
        (*pCspGlobals->rawBmapFns.SetBitmapBits)(
            pCspGlobals,
            (short)scanline, 
            (short)(x_start - sp_globals.xmin), 
            (short)(x_end - sp_globals.xmin));
        }

    i = sp_intercepts.cdr[j];
    old_x_end = x_end;
    }
}

FUNCTION 
static boolean sp_extend_zero_length_run_quick(
    cspGlobals_t *pCspGlobals,
    fix15   avail_pix_left,
    fix15   extendibility_left,
    fix15   avail_pix_right,
    fix15   extendibility_right,
    fix15  *px_start,
    fix15  *px_end)
/*
 *  Called by sp_output_complex_scanline_quick() to extend a zero-length run
 *  of pixels by one pixel to the left or right. No extension is applies
 *  if the zero-length run is touching its neighbor.
 *  The choice of left or right extension is made on the basis of:
 *      avoiding touching or overlapping the adjacent run of pixels
 *      avoiding extending a run outside the character bounding box
 *  If both directions are available, the zero-length run is extended
 *  in the direction associated with the maximum extendibility.
 *  If both directions are available and have equal extendibility, the
 *  zero-length run is extended to the right.
 */
{
boolean left_possible;
boolean right_possible;

left_possible = 
    (avail_pix_left > 0) &&
    (avail_pix_right > -1) && 
    (*px_start > sp_globals.xmin);

right_possible = 
    (avail_pix_right > 0) &&
    (avail_pix_left > -1) &&
    (*px_end < sp_globals.xmax);

if (left_possible && right_possible)
    {
    if (extendibility_left > extendibility_right)
        {
#if CSP_DEBUG >= 2
        printf("Zero-length run at %d extended to left\n", *px_start);
#endif
        *px_start -= 1;
        }
    else
        {
#if CSP_DEBUG >= 2
        printf("Zero-length run at %d extended to right\n", *px_start);
#endif
        *px_end += 1;
        }
    return TRUE;
    }

if (left_possible)
    {
#if CSP_DEBUG >= 2
    printf("Zero-length run at %d extended to left\n", *px_start);
#endif
    *px_start -= 1;
    return TRUE;
    }

if (right_possible)
    {
#if CSP_DEBUG >= 2
    printf("Zero-length run at %d extended to right\n", *px_start);
#endif
    *px_end += 1;
    return TRUE;
    }

#if CSP_DEBUG >= 2
    printf("Zero-length run at %d not extended\n", *px_start);
#endif
return FALSE;
}

FUNCTION
static void sp_check_scanline_quick(
    cspGlobals_t *pCspGlobals,
    fix15 y)       /* Intercept list */
/*
 *  Checks the specified scanline
 *  Sets the COMPLEX_SCANLINE_FLAG if:
 *     - the first or last intercept is outside the character bounding box.
 *     - even-odd fill does not produce the same result as winding number fill.
 *     - zero-length runs need to be extended.
 */
{
fix15   i;
fix15   j;

if ((i = sp_intercepts.cdr[y]) == 0)
    {
    return;
    }

/* Check first intercept within bitmap bounding box */
if (sp_intercepts.car[i] < sp_globals.xmin)
    {
    sp_intercepts.inttype[y] |= COMPLEX_SCANLINE_FLAG;
    }

/* Check odd and even intercept have opposing directions */
do
    {
    j = sp_intercepts.cdr[i];
    if (((sp_intercepts.inttype[i] ^ sp_intercepts.inttype[j]) & UP_INTERCEPT) == 0)
        {
        sp_intercepts.inttype[y] |= COMPLEX_SCANLINE_FLAG;
        }
    if (sp_intercepts.car[i] == sp_intercepts.car[j])
        {
        sp_intercepts.inttype[y] |= COMPLEX_SCANLINE_FLAG;
        }
    i = sp_intercepts.cdr[j];
    }
while (i != 0);

/* Check last intercept within bitmap bounding box */
if (sp_intercepts.car[j] > sp_globals.xmax)
    {
    sp_intercepts.inttype[y] |= COMPLEX_SCANLINE_FLAG;
    }
}

#if CSP_DEBUG >= 2
FUNCTION
static void print_intercepts(
    cspGlobals_t *pCspGlobals,
    fix15   y)
/*
 *  Prints one row of intercepts for debugging purposes
 *  Each row is printed in the following format:
 *    2 ( 15) ----h |  3 -----v    4 --(--^ |  5 ---)-v    6 -----^ |
 *  The first number is the scanline number in its output form
 *  The second number in parens is the absolute scanline number.
 *  The funny symbols before the first vertical bar refer to the
 *  intercept list itself:
 *      # Compound scanline has runs from 2 or more sub-chars
 *      * Complex scanline
 *      ! Complex interval below this scanline
 *      s Scanline contains one or more solid salients
 *      h Scanline contains one or more hollow salients
 *  After the first vertical bar, each intercept is printed as the actual
 *  X intercept value followed by a series of symbols. The symbols for
 *  each intercept are:
 *      [ Start of solid salient
 *      ] Start of solid salient
 *      ( Start of hollow salient
 *      ) Start of hollow salient
 *      e Pixel run is extendible by adjusting this intercept
 *      ^ Up intercept
 *      v Down intercept
 *  A vertical bar separates each pair of intercepts.
 */
{
fix15   i, j;
fix15   scanline;
fix15   from;
fix15   to;

if ((i = sp_intercepts.cdr[y]) == 0)
    {
    return;
    }

scanline = sp_globals.ymax - sp_globals.y_band.band_min - y - 1;
printf("%3d (%3d) %c%c%c%c%c |", 
    scanline, 
    y + sp_globals.y_band.band_min,
    (sp_intercepts.inttype[y] & COMPOUND_SCANLINE_FLAG)? '#': '-',
    (sp_intercepts.inttype[y] & COMPLEX_SCANLINE_FLAG)? '*': '-',
    (sp_intercepts.inttype[y] & COMPLEX_INTERVAL_BELOW)? '!': '-',
    (sp_intercepts.inttype[y] & SOLID_SALIENT_FLAG)? 's': '-',
    (sp_intercepts.inttype[y] & HOLLOW_SALIENT_FLAG)? 'h': '-');

while (i != 0)                  /* Link to next intercept if present */
    {
    from = sp_intercepts.car[i];
    j = sp_intercepts.cdr[i];              /* Link to next intercept */
    if (j == 0)                 /* End of list? */
        {
        printf("\n*** print_intercepts: odd number of intercepts\n");
        break;
        }
    to = sp_intercepts.car[j];
    printf("%3d %c%c%c%c%c%c  %3d %c%c%c%c%c%c |", 
        from, 
        (sp_intercepts.inttype[i] & BEGIN_SOLID_SALIENT)? '[': '-',
        (sp_intercepts.inttype[i] & END_SOLID_SALIENT)? ']': '-',
        (sp_intercepts.inttype[i] & BEGIN_HOLLOW_SALIENT)? '(': '-',
        (sp_intercepts.inttype[i] & END_HOLLOW_SALIENT)? ')': '-',
        (sp_intercepts.inttype[i] & EXTENDIBILITY)? 'e': '-',
        (sp_intercepts.inttype[i] & UP_INTERCEPT)? '^': 'v',
        to,
        (sp_intercepts.inttype[j] & BEGIN_SOLID_SALIENT)? '[': '-',
        (sp_intercepts.inttype[j] & END_SOLID_SALIENT)? ']': '-',
        (sp_intercepts.inttype[j] & BEGIN_HOLLOW_SALIENT)? '(': '-',
        (sp_intercepts.inttype[j] & END_HOLLOW_SALIENT)? ')': '-',
        (sp_intercepts.inttype[j] & EXTENDIBILITY)? 'e': '-',
        (sp_intercepts.inttype[j] & UP_INTERCEPT)? '^': 'v');
    i = sp_intercepts.cdr[j];
    }
printf("\n");
}
#endif

#endif

