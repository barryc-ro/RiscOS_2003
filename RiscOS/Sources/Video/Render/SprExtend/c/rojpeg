/* c.rojpeg - JPEG for use within RISC OS */
#undef FILE_
#define FILE_ (40000)

#include "rojpeg.h"
#include "swis.h"

/* For macros taking variable argument packs */
#define _ ,

/* ----------------- surrogate C library stuff, if embedded use within RISC OS ----------------- */
/* This section is dependent on the way in which the code is embedded into
assembler. It makes use of facilities provided by c.PutScaled for trace output,
since the two in factshare the same namespace. */
#ifdef EMBED

extern void exit(int reason); /* Provided by assembler */

extern void *memcpy(void *dest, const void *src, size_t n)
{
  char *d = (char*) dest;
  char *s = (char*) src;

  while (n-- > 0) *d++ = *s++;
  return dest;
}

extern char *strcpy(char *dest, const char *src)
{
  char *d = (char*) dest;
  char *s = (char*) src;

  while (*s > 31) *d++ = *s++;
  return dest;
}

extern void *memset(void *s, int c, size_t n)
{
  char *d = (char*) s;

  while (n-- > 0) *d++ = c;
  return s;
}

#ifdef DEBUG
/* Debug only has an effect if embedded. */

#ifndef assert
  #define assert(x, y) do_assert(__LINE__, x, y, #x)
#endif
extern void do_assert(int line, BOOL arg, int error, char *describe); /* defined in c.PutScaled */

#ifndef tracef
#define tracef(args) sprintf(0, args)
extern void sprintf(char *d, char *format, ...); /* defined in c.PutScaled */
#endif

#else
/* Non-debugging things */

/* #define assert(x) if (!(x)) exit(FILE_+__LINE__) */
#define tracef(args) ((void) 0)

#endif

#else
/* Non-embedded things */

#ifdef DEBUG
  #define tracef(args) if (verbose) printf(args)
  static void newline(void) {tracef("\n");}
#else
  #define tracef(args) ((void) 0)
  static void newline(void) {tracef("\n");}
#endif

#endif

#ifdef ASMHUFF
extern void panic_exit(int i)
{
  tracef("Assembler panic exit %i.\n" _ i);
  exit(i);
}
#endif

/* ----------------- 'global' facilities declared within nested c files ----------------- */

#include "jrdjfif.c"
#include "jdhuff.c"
#ifdef STATS
  #include "jrevdct4.c"
#endif
#include "jcconv.c"

/* Reassert this file ID, for error exit identification */
#undef FILE_
#define FILE_ (10000)

/* ----------------- Assembler debug assistance ----------------------------- */

extern void assembler_panic(decompress_info_ptr cinfo, int *regblock, int code)
/* The assembler code calls us here when something goes wrong, in an attempt
to learn what happened. On exit it then returns, usually leading to no picture
being painted. */
{
  #ifdef DEBUG
    int i;

    tracef("Corrupted data in Huffman stream at byte %i\n" _ (char*)regblock[3] - cinfo->input_buffer);
    #if 1
      tracef("cinfo=0x%x regblock=0x%x code=%i.\n" _ (int)cinfo _ (int)regblock _ code);
      for (i = 0; i < 16; i++) tracef("R%i=0x%x\n" _ i _ regblock[i]);
      tracef("Nearby input bytes:\n");
      for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ ((char*)(regblock[3]))[i]);
      tracef("\n");
    #endif
  #endif
}


/* ----------------- JPEG entrypoints and control ----------------------------- */

#if 0
static int jpeg_workspace_size(void)
/* Return size of workspace needed */
{
  int s;

#if 0
  s = sizeof(struct decompress_info_struct)
    + 3 * sizeof(jpeg_component_info)          /* max of 3 components allowed */
    + NUM_QUANT_TBLS * sizeof(QUANT_TBL)
    + 2 * NUM_HUFF_TBLS * sizeof(HUFF_TBL);
#else
  s = sizeof(struct decompress_info_struct);
#endif
  tracef("Workspace block - %i bytes\n" _ s); /* 18776 at 27-oct-93 */
  return s;
}
#endif

static void init_workspace(decompress_info_ptr cinfo, int size)
/* Workspace has been allocated. Initialise it, any subsidiary structures etc. Do not
touch the band buffer, might not be allocated yet. */
{
  int i;
#if 0
  char *free = (char*) (cinfo + 1);                           /* after the decompress_info_struct itself */
  int size = jpeg_workspace_size();
  char *end = (char*) cinfo + size;
  int *bb = cinfo->band_buffer;
  int bbs = cinfo->band_buffer_size;
#endif
  int wss = cinfo->workspace_size;
  char *t32k = cinfo->table32k;

  MEMZERO((void*) cinfo, size);

  /* Replace workspace size */
#if 0
  cinfo->band_buffer = bb;
  cinfo->band_buffer_size = bbs;
#endif
  cinfo->workspace_size = wss;
  cinfo->table32k = t32k;

#if 0
  cinfo->comp_info = (jpeg_component_info *) free; /* pointer to array of components */
  free = (char*) ((jpeg_component_info *) free + 3);

  /* Set up pointers to subsidiary structures */
  for (i = 0; i < NUM_QUANT_TBLS; i++)                  /* allocate quantisation tables */
  {
    cinfo->quant_tbl_ptrs[i] = (QUANT_TBL_PTR) free;
    free = (char*) ((QUANT_TBL *) free + 1);
  }
  for (i = 0; i < NUM_HUFF_TBLS; i++)
  {
    cinfo->dc_huff_tbl_ptrs[i] = (HUFF_TBL *) free;
    free = (char*) ((HUFF_TBL *) free + 1);
    cinfo->ac_huff_tbl_ptrs[i] = (HUFF_TBL *) free;
    free = (char*) ((HUFF_TBL *) free + 1);
  }

  /* Check we got the size right */
  assert(free == end);
#else
  cinfo->comp_info = &(cinfo->s_cur_comp_info[0]);
  for (i = 0; i < NUM_QUANT_TBLS; i++)                  /* allocate quantisation tables */
    cinfo->quant_tbl_ptrs[i] = (QUANT_VAL*) &(cinfo->s_quant_tbl[i]);
  for (i = 0; i < NUM_HUFF_TBLS; i++)
  {
    cinfo->dc_huff_tbl_ptrs[i] = &(cinfo->s_dc_huff_tbl[i]);
    cinfo->ac_huff_tbl_ptrs[i] = &(cinfo->s_ac_huff_tbl[i]);
  }
#endif
}

#define BADFILE(reason) {tbad(reason,0,0); cinfo->error_code = reason; return reason;}
#define BADFILE1(reason,arg) {tbad(reason,arg,0); cinfo->error_code = reason; cinfo->error_argument1 = arg; return reason;}
#define BADFILE2(reason,arg1,arg2) \
  {tbad(reason,arg1,arg2); cinfo->error_code = reason; cinfo->error_argument1 = arg1; cinfo->error_argument2 = arg2; return reason;}
#if 0
  static void tbad(int r, int a1, int a2) {tracef("bad file (%i,%i,%i)\n" _ r _ a1 _ a2);}
#else
  #define tbad(r,a1,a2) ((void*) 0)
#endif

/* --------------------------------------------------------------------------------------------- */

static void save_huff_stream(decompress_info_ptr cinfo, huff_pointer *h)
/* Save the current state of the huffman stream, so that we could restart reading at this point. */
{
#if 1
  assert(cinfo->bits_left < 32, ERROR_BAD_JPEG);
  assert(cinfo->bits_left >= 0, ERROR_BAD_JPEG);
  assert(cinfo->input_buffer < cinfo->next_input_byte, ERROR_BAD_JPEG);
  assert(cinfo->next_input_byte < cinfo->buffer_end, ERROR_BAD_JPEG);
#endif

  h->bit_pointer = (cinfo->next_input_byte - cinfo->input_buffer)*32 + cinfo->bits_left;
  h->get_buffer = cinfo->get_buffer;
  h->last_dc_val0 = cinfo->last_dc_val[0];
  h->last_dc_val1 = cinfo->last_dc_val[1];
  h->last_dc_val2 = cinfo->last_dc_val[2];
  h->restarts_to_go = cinfo->restarts_to_go;
  h->next_restart_num = cinfo->next_restart_num;
  /* DUMPVAL(h->bit_pointer) DUMPVALN(h->get_buffer) */
}

static void restore_huff_stream(decompress_info_ptr cinfo, huff_pointer *h)
/* Reset a save state of the huffman stream, so that we can continue reading. */
{
  /* DUMPVAL(h->bit_pointer) DUMPVALN(h->get_buffer) */
  cinfo->get_buffer = h->get_buffer;
  cinfo->next_input_byte = cinfo->input_buffer + h->bit_pointer/32;
  cinfo->bits_left = h->bit_pointer & 31;
  cinfo->last_dc_val[0] = h->last_dc_val0;
  cinfo->last_dc_val[1] = h->last_dc_val1;
  cinfo->last_dc_val[2] = h->last_dc_val2;
  cinfo->restarts_to_go = h->restarts_to_go;
  cinfo->next_restart_num = h->next_restart_num;

#if 1
  #ifdef DEBUG
    if (!(cinfo->input_buffer < cinfo->next_input_byte && cinfo->next_input_byte < cinfo->buffer_end))
      tracef("oops restore_huff_stream: 0x%x 0x%x 0x%x\n" _ (int)cinfo->input_buffer _ (int)cinfo->next_input_byte _ (int)cinfo->buffer_end);
  #endif
  assert(cinfo->input_buffer < cinfo->next_input_byte, ERROR_FATAL);
  assert(cinfo->next_input_byte < cinfo->buffer_end, ERROR_FATAL);
#endif
}

/* --------------------------------------------------------------------------------------------- */

/* Coping with restarts - whoever put restarts in this standard? */

static void process_restart(decompress_info_ptr cinfo)
/* We should be precisely at a restart marker */
{
  char c = *cinfo->next_input_byte++;
  int ci;

  #if 0
  tracef("Processing restart marker %i at %i bytes\n" _ cinfo->next_restart_num _ cinfo->next_input_byte - cinfo->input_buffer);
  {
    int i;
    tracef("inbuf=0x%x nbits=%i inptr=0x%x file=0x%x\n" _ cinfo->get_buffer _ cinfo->bits_left _ (int)cinfo->next_input_byte _ (int)cinfo->input_buffer);
    for (i = -10; i < 10; i++) tracef("%i:0x%x " _ i _ cinfo->next_input_byte[i]);
    tracef("\n");
  }
  #endif
  assert(cinfo->bits_left <= 7, ERROR_BAD_JPEG);
  assert(c == 0xff, ERROR_BAD_JPEG);
  while (*cinfo->next_input_byte == 0xff) cinfo->next_input_byte++; /* additional 0xffs allowed at this point */
  c = *cinfo->next_input_byte++;
  assert((c & 0xF8) == 0xD0, ERROR_BAD_JPEG); /* RST0..RST7 markers */
  assert((c & 7) == cinfo->next_restart_num, ERROR_BAD_JPEG); /* should be precisely the correct marker */
  /* It appears to be a correctly formed restart marker */
  cinfo->bits_left = 0;       /* flush the remaining bits */
  cinfo->get_buffer = 0;
  cinfo->restarts_to_go = cinfo->restart_interval;
  cinfo->next_restart_num = (cinfo->next_restart_num + 1) & 7;
  for (ci = 0; ci < cinfo->comps_in_scan; ci++) cinfo->last_dc_val[ci] = 0;
}

static void
do_huff_skip_blocks(decompress_info_ptr cinfo, JBLOCK block,
                    HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                    int *last_dc_val, int nblocks, BOOL block_per_mcu)
/* Just like asm_huff_skip_blocks, but handles restart markers */
/* If block_per_mcu then count one restart interval per block, else just count one. */
{
  if (cinfo->restart_interval)
  {
    BOOL count = TRUE;

    while (nblocks > 0)
    {
      if (count)
      {
        if (cinfo->restarts_to_go == 0) process_restart(cinfo);
        cinfo->restarts_to_go--;
      }
      asm_huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
      nblocks--;
      count = block_per_mcu;
      block += DCTSIZE2;
    }
  }
  else
    asm_huff_skip_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
}


static void
do_huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                      HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                      int *last_dc_val, int nblocks, BOOL block_per_mcu)
/* Just like asm_huff_decode_blocks, but handles restart markers */
/* If block_per_mcu then count one restart interval per block, else just count one. */
{
  if (cinfo->restart_interval)
  {
    BOOL count = TRUE;

    while (nblocks > 0)
    {
      if (count)
      {
        if (cinfo->restarts_to_go == 0) process_restart(cinfo);
        cinfo->restarts_to_go--;
      }
      asm_huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, 1);
      nblocks--;
      count = block_per_mcu;
      block += DCTSIZE2;
    }
  }
  else
    asm_huff_decode_blocks(cinfo, block, dctbl, actbl, quanttbl, last_dc_val, nblocks);
}


/* --------------------------------------------------------------------------------------------- */

static int do_jpeg_scan_file(char *space, int space_size, char *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI */
{
  decompress_info_ptr cinfo = (decompress_info_ptr) space;
#if 0
  int *band_buffer = (int*) (space + jpeg_workspace_size());
  int band_buffer_size = (space_size - jpeg_workspace_size()) / sizeof(int);

  band_buffer_size &= ~0xf; /* only multiples of 16 integers interesting */
  cinfo->band_buffer = band_buffer;
  cinfo->band_buffer_size = band_buffer_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, 0);
#else
  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, 0);
#endif
}

static int do_jpeg_scan_file_16(char *space, int space_size, char *file_image, int image_length)
/* Simple entry sequence for use by ChangeFSI - 16bpp output. */
{
  decompress_info_ptr cinfo = (decompress_info_ptr) space;

  cinfo->workspace_size = space_size;
  cinfo->error_code = -1; /* force total reset */
  return jpeg_scan_file(cinfo, file_image, image_length, 0, 0x7fffffff, -1, -1, jopt_OUTBPP_16);
}

static int jpeg_scan_file(decompress_info_ptr cinfo, char *file_image, int image_length,
                          int xmin, int xmax, int width, int height, int options)
/* Effectively the length of the workspace available is passed in as cinfo->workspace_size,
a bit illogical. cinfo->error_code is also important. */
{
  int i;
#ifdef EMBED
  tracef("jpeg_scan_file cinfo=0x%x file_image=0x%x image_length=%i xmin=%i xmax=%i width=%i height=%i options=%i\n"
         _ (int)cinfo _ (int)file_image _ image_length _ xmin _ xmax _ width _ height _ options);
  DUMPVALN(cinfo->workspace_size)
#endif

  if (options & jopt_DC_ONLY)
  {
    options &= ~(jopt_OUTBPP_8 | jopt_OUTBPP_16 | jopt_OUTBPP_8YUV);
    tracef("Clearing 8YUV because of DC_ONLY flag\n");
  }
  if (xmin < 0) xmin = 0; /* xmax will be clipped to image_height, when we know it. */
  if (options & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV))
  {
    /* xmin = 0;*/ /* always have to do left part, because errors diffuse over from there */
    xmin -= 16; /* cos errors can diffuse forwards a little - clipped to 0 later */
    if (xmin < 0) xmin = 0;
    xmin &= ~15; /* round down to multiple of 16 - needed by dithering */
    xmax += 16; /* cos errors can diffuse backwards a little - clipped to image width later */
  }

#if 0
  /* Paranoid check that band buffer and workspace do not overlap. */
  assert(cinfo->band_buffer == 0
        || (int*)cinfo->band_buffer + cinfo->band_buffer_size <= (int*)cinfo
        || (char*)cinfo + sizeof(struct decompress_info_struct) <= (char*) cinfo->band_buffer);
#endif

#ifdef EMBED
  DUMPVALN(cinfo->error_code)
  DUMPVAL(cinfo->input_buffer) DUMPVALN(file_image)
  DUMPVAL(cinfo->buffer_end - cinfo->input_buffer) DUMPVALN(image_length)
  DUMPVAL(cinfo->check1) DUMPVALN(((int*)file_image)[image_length/(2*4)])
  DUMPVAL(cinfo->check2) DUMPVALN(((int*)file_image)[image_length/4 - image_length/(4*4)])
  DUMPVAL(cinfo->check3) DUMPVALN(((int*)file_image)[image_length/4 - image_length/(8*4)])
#endif

  /* Look to see if this is precisely the same JPEG file as last time */
  if (  cinfo->error_code == 0                                               /* check for very first time, or for error last time */
     && cinfo->input_buffer == file_image                                    /* check for image in same place */
     && cinfo->buffer_end - cinfo->input_buffer == image_length              /* check length unchanged */
     && (width == -1 || cinfo->image_width == width)                         /* width OK */
     && (height == -1 || cinfo->image_height == height)                      /* height OK */
     && cinfo->check1 == ((int*)file_image)[image_length/(2*4)]                  /* Random checks on data - the /4 gets us down to char offsets */
     && cinfo->check2 == ((int*)file_image)[image_length/4 - image_length/(4*4)] /* we check a word half-way through, and two later on */
     && cinfo->check3 == ((int*)file_image)[image_length/4 - image_length/(8*4)]
     && cinfo->options == options
     /* In the compressed data, any change will perturb the whole file - we trust! */
     )
  /* >>> We could allow the image to be shifted in store, might help considerably with some clients.
  The other tests are surely adequate. Would have to shift all the pointers in the huff_pointer array. */
  {
    tracef("This looks like the same JPEG file as last time.\n");
    if (xmax > cinfo->image_width) xmax = cinfo->image_width;
    if (xmin < cinfo->xmin || xmax > cinfo->xmax) cinfo->current_huff_pointer = -1; /* no band sufficiently loaded */
    cinfo->xmin = xmin; /* might need more, or less, than last time */
    cinfo->xmax = xmax;
    return 0;
  }

  /* If called for the first time, initialise the table32k pointer. */
  if (cinfo->error_code < 0) cinfo->table32k = 0;

  /* Clear out the info struct, preserving any possible workspace size. */
  init_workspace(cinfo, cinfo->workspace_size);

  /* Set up the band buffer pointer. */
  if (cinfo->workspace_size == 0) /* there's no workspace, they just want us to scan the header */
  {
    cinfo->band_buffer = 0;
    cinfo->band_buffer_size = 100000000; /* prevent complaints later on */
  }
  else
  {
    cinfo->band_buffer = (int*)((char*)cinfo + sizeof(struct decompress_info_struct));
    cinfo->band_buffer_size = (cinfo->workspace_size - sizeof(struct decompress_info_struct))/sizeof(int) & 0xfffffff0;
  }

  /* Set up the check words, to hope for repeated calls on this sprite */
  cinfo->check1 = ((int*)file_image)[image_length/(2*4)];
  cinfo->check2 = ((int*)file_image)[image_length/4 - image_length/(4*4)];
  cinfo->check3 = ((int*)file_image)[image_length/4 - image_length/(8*4)];

  /* Preserve pointers to the jpeg file image */
  cinfo->input_buffer = file_image;
  cinfo->next_input_byte = file_image;
  cinfo->buffer_end = file_image + image_length;

  /* Read the file header - sets various cinfo fields. */
  read_file_header(cinfo);

  /* Read the header for the first scan - sets various cinfo fields. */
  read_scan_header(cinfo);

  #ifdef DEBUG
    if (file_image[18] != 0) tracef("Packed RGB thumbnail size: %ix%i.\n" _ file_image[18] _ file_image[19]);
  #endif

  /* Initialise any huffman tables present. */
  for (i = 0; i < 4; i++)
  {
    fix_huff_tbl(cinfo, cinfo->dc_huff_tbl_ptrs[i]);
    fix_huff_tbl(cinfo, cinfo->ac_huff_tbl_ptrs[i]);
  }
  tracef("Huffman tables fixed.\n");
  tracef("Image starts at byte %i of JPEG data.\n" _ cinfo->next_input_byte - cinfo->input_buffer);

  /* Initialise the first huff decoding stream. */
  huff_decoder_init(cinfo);
  cinfo->current_huff_pointer = -1; /* No band currently unloaded. */
  cinfo->restarts_to_go = cinfo->restart_interval;
  cinfo->next_restart_num = 0;
  if (xmax > cinfo->image_width) xmax = cinfo->image_width;
  if (xmin > xmax) xmin = xmax; /* guard against silly input */
  cinfo->xmin = xmin;
  cinfo->xmax = xmax;
  cinfo->options = options;

  /* Check various limitations of our code. */
  if (cinfo->data_precision != 8) BADFILE1(E_PRE_NOT_8, cinfo->data_precision)
  /* if (cinfo->restart_interval != 0) BADFILE1(E_RESTART, cinfo->restart_interval) */
  if (cinfo->num_components != cinfo->comps_in_scan) BADFILE(E_MULTI_SCAN)
  if (cinfo->image_width != width && width != -1) BADFILE1(E_WIDTH, cinfo->image_width)
  if (cinfo->image_height != height && height != -1) BADFILE1(E_HEIGHT, cinfo->image_height)

  /* Allocate the array of pointers into the huffman codes, at the base of where the band
  buffer currently is. */
  {
    int mcu_height = 8 * cinfo->comp_info[0].v_samp_factor; /* 8 or 16 */
    /*int mcu_width = 8 * cinfo->comp_info[0].h_samp_factor;*/ /* 8 or 16 */
    int huff_array_size = sizeof(huff_pointer) * ((cinfo->image_height + mcu_height - 1)/mcu_height); /* in bytes */

    cinfo->huff_pointers = (huff_pointer*) cinfo->band_buffer;
    cinfo->band_buffer += huff_array_size/sizeof(int);
    cinfo->band_buffer_size -= huff_array_size/sizeof(int);
    if (cinfo->image_width > cinfo->band_buffer_size / mcu_height)
      BADFILE2(E_TOO_WIDE, cinfo->image_width, cinfo->band_buffer_size / mcu_height)
  }

  /* Now try the specific cases that we can do. */
  if (cinfo->num_components == 1)
  {
    /* if (cinfo->image_height > 8 * HPOINTERS) BADFILE2(E_TOO_HIGH, cinfo->image_height, 8 * HPOINTERS) */
    if (cinfo->jpeg_color_space != CS_GRAYSCALE) BADFILE1(E_COLOUR, cinfo->jpeg_color_space)
    /* if (cinfo->image_width > cinfo->band_buffer_size / 8) BADFILE2(E_TOO_HIGH, cinfo->image_width, cinfo->band_buffer_size / 8) */
    if (cinfo->comp_info[0].h_samp_factor != 1
       || cinfo->comp_info[0].v_samp_factor != 1
       ) BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[0].h_samp_factor, cinfo->comp_info[0].v_samp_factor)
    tracef("Greyscale file.\n");
    {
      int height = 0;
      jpeg_component_info * compptr = cinfo->cur_comp_info[0];
      HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[compptr->dc_tbl_no];
      HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[compptr->ac_tbl_no];
      QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];
      int hpointer_index = 0;

      while (height < cinfo->image_height)
      {
        /* save the state of the huff stream. */
        save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
        hpointer_index++;
        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], (cinfo->image_width + 7) >> 3, TRUE);
        height += 8;
        /* tracef("Scanned a band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
      }
    }
    options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for 16bpp output */
    tracef("Clearing 8YUV because of Greyscale flag\n");
  }
  else if (cinfo->num_components == 3)
  {

    /* A usual MCU (minimum coding unit) contains 4 Y blocks, 1 U block, 1 V block.
    We will accept MCUs of 1:1:1 or 2:1:1 as well, since there are examples of this.
    JFIF allows an arbitrary ratio - seems uncecessary. A band is always 1 MCU high. */
    int vsamp = cinfo->comp_info[0].v_samp_factor;
    int hsamp = cinfo->comp_info[0].h_samp_factor;

    if (cinfo->comp_info[0].h_samp_factor > 2 || cinfo->comp_info[0].v_samp_factor > 2)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[0].h_samp_factor, cinfo->comp_info[0].v_samp_factor)
    if (cinfo->comp_info[1].h_samp_factor != 1 || cinfo->comp_info[1].v_samp_factor != 1)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[1].h_samp_factor, cinfo->comp_info[1].v_samp_factor)
    if (cinfo->comp_info[2].h_samp_factor != 1 || cinfo->comp_info[2].v_samp_factor != 1)
      BADFILE2(E_BAD_SAMPLE, cinfo->comp_info[2].h_samp_factor, cinfo->comp_info[2].v_samp_factor)
/*    if (cinfo->image_height > 8 * vsamp * HPOINTERS) BADFILE2(E_TOO_HIGH, cinfo->image_height, 8 * vsamp * HPOINTERS) */
    if (cinfo->jpeg_color_space != CS_YCbCr) BADFILE1(E_COLOUR, cinfo->jpeg_color_space)
/*    if (cinfo->image_width > cinfo->band_buffer_size / (8*hsamp)) BADFILE2(E_TOO_WIDE, cinfo->image_width, cinfo->band_buffer_size /(8*hsamp)) */
    tracef("Interleaved YUV colour file.\n");
    /* if (cinfo->image_height & 15 != 0) tracef("Warning - height not multiple of 16.\n"); */
    /* if (cinfo->image_width & 15 != 0) tracef("Warning - width not multiple of 16.\n"); */
    /* >>> Check that the components are in the order we expect/assume! */

    if (hsamp != 2 || vsamp != 2) options &= ~(jopt_OUTBPP_16 | jopt_OUTBPP_8YUV); /* haven't got optimised colour conversion for unusual colour blocks */

    {
      int width;
      int height = 0;
      int hpointer_index = 0;

      HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
      HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
      QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
      HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
      HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
      QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
      HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
      HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
      QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];

      while (height < cinfo->image_height)
      {
        /* save the state of the huff stream. */
        save_huff_stream(cinfo, &cinfo->huff_pointers[hpointer_index]);
        hpointer_index++;

        width = 0;
        while (width < cinfo->image_width)
        {
          /* Skip over the six blocks representing this 16*16 square of pixels */
          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp * vsamp, FALSE);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);

          /* tracef("Done a block, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
          width += 8 * hsamp;
        }
        height += 8 * vsamp;
        /* tracef("Scanned a band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
      }
    }
    /* tracef("Finished scan, bytes left over = %i\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
  }
  else
    BADFILE1(E_COMPONENTS, cinfo->num_components)

/*  assert(cinfo->error_code == 0);*/

  if (options & jopt_INTERP_X) /* interpolation requested */
  {
    int size_per_line = cinfo->band_buffer_size / (8 * cinfo->comp_info[0].h_samp_factor);

    if (cinfo->image_width * 2 <= size_per_line) cinfo->error_argument1 |= jopt_INTERP_X; /* signal that we'll do it */
    else cinfo->options &= ~jopt_INTERP_X; /* not enough space - remember that we won't do it */
  }
  if (options & jopt_OUTBPP_8) cinfo->error_argument1 |= jopt_OUTBPP_8;
  if (options & jopt_OUTBPP_16) cinfo->error_argument1 |= jopt_OUTBPP_16;
  if (options & jopt_OUTBPP_8YUV) cinfo->error_argument1 |= jopt_OUTBPP_8YUV;
  if (options & jopt_OUTBPP_8GREY) cinfo->error_argument1 |= jopt_OUTBPP_8GREY;
  cinfo->options = options; /* in case processing above has discovered options we're not prepared to do */

#ifdef DEBUG
  tracef("After scan file, options are:\n");
  if (options & jopt_GREY) tracef("  jopt_GREY\n");
  if (options & jopt_DC_ONLY) tracef("  jopt_DC_ONLY\n");
  if (options & jopt_INTERP_X) tracef("  jopt_INTERP_X\n");
  if (options & jopt_OUTBPP_8) tracef("  jopt_OUTBPP_8\n");
  if (options & jopt_OUTBPP_16) tracef("  jopt_OUTBPP_16\n");
  if (options & jopt_OUTBPP_8YUV) tracef("  jopt_OUTBPP_8YUV\n");
  if (options & jopt_DIFFUSE) tracef("  jopt_DIFFUSE\n");
  if (options & jopt_OUTBPP_8GREY) tracef("  jopt_OUTBPP_8GREY\n");
#endif

  #ifdef EMBED
    tracef("Exit jpeg_scan_file OK\n\n");
  #endif
  return cinfo->error_code;
}

/* -------------------------------------------------------------------------------------------- */

static int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data)
/* This gets called for every line of a rendered image. Most of the time it is fast, every 8 or 16 lines
or so it must do some de-JPEGing of some more data. */
{
  int hpointer; /* huff pointer index */
  int l2_band_height = 2 + cinfo->comp_info[0].v_samp_factor; /* log2 of band height - 3 for mono, usually 4 for colour */
  int line_offset = cinfo->band_buffer_size >> l2_band_height; /* offset in words between lines of output */

  tracef("jpeg_find_line, palette data at %x\n" _ palette_data);
  /* coordinates fed into this are RISC OS-style, with 0 meaning the bottom row.
  Reverse this so that 0 means the top row. */
  ycoord = cinfo->image_height - ycoord - 1;
  assert(ycoord >= 0, ERROR_FATAL);
  assert(ycoord < cinfo->image_height, ERROR_FATAL);
  hpointer = ycoord >> l2_band_height;

#if 0
  #ifdef DEBUG
    tracef("jpeg_find_line %i, hpointer=%i current=%i.\n" _ ycoord _ hpointer _ cinfo->current_huff_pointer);
    tracef("cinfo=0x%x band_buffer=0x%x band_buffer_size=%i\n" _ (int)cinfo _ (int)cinfo->band_buffer _ cinfo->band_buffer_size);
    if (ycoord < 0 || ycoord >= cinfo->image_height)
    {
      tracef("ycoord out of bounds, [%i..%i..%i]\n" _ 0 _ ycoord _ cinfo->image_height);
      assert(0);
    }
  #endif
#endif

  if (hpointer != cinfo->current_huff_pointer) /* Fetch a line */
  {
    int nlines_fetched = 0;

    assert(cinfo->band_buffer != 0, ERROR_FATAL); /* someone had better have provided one! */

    /* Restore the huffman stream */
    cinfo->current_huff_pointer = -1; /* in case of error exit - set correctly at end */
    restore_huff_stream(cinfo, &cinfo->huff_pointers[hpointer]);

    if (cinfo->num_components == 1)
    {
      /* Get a row of blocks into the band buffer */
      int width = 0;
      int *outptr = cinfo->band_buffer;
      jpeg_component_info * compptr = cinfo->cur_comp_info[0];
      QUANT_TBL_PTR quanttbl = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];
      HUFF_TBL *dc = cinfo->dc_huff_tbl_ptrs[compptr->dc_tbl_no];
      HUFF_TBL *ac = cinfo->ac_huff_tbl_ptrs[compptr->ac_tbl_no];

      /* tracef("Greyscale line.\n"); */
      if (cinfo->xmin >= 8)
      {
        int count = (cinfo->xmin - 8) >> 3; /* how many blocks we can just skip */

        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], dc, ac, quanttbl, &cinfo->last_dc_val[0], count, TRUE);
        width += 8*count;
        if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*count;
          else outptr += 8*count;
      }

      if (cinfo->options & jopt_DC_ONLY) /* monochrome, only tile values */
      {
        /* We only want a flat value for each tile. Just create a single line but
        do not attempt to collapse this in the x direction, too complex to interface to. */
        while (width < cinfo->xmax) /* the data we want */
        {
          int pix;

          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
          pix = mono_convert_pixel(cinfo, cinfo->last_dc_val[0] * quanttbl[0]);
          outptr[0] = pix;
          outptr[1] = pix;
          outptr[2] = pix;
          outptr[3] = pix;
          outptr[4] = pix;
          outptr[5] = pix;
          outptr[6] = pix;
          outptr[7] = pix;
          width += 8;
          outptr += 8;
        }
        nlines_fetched = 1;
      }
      else /* mono normal case, all pixels required */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          /* Could convert and DCT the data 6 blocks at a time? Increases cache requirement... so, we won't */
          do_huff_decode_blocks(cinfo, cinfo->jblocks[1], dc, ac, quanttbl, &cinfo->last_dc_val[0], 1, TRUE);
          #ifdef TIMINGS
            if (!(cinfo->options & jopt_HUFF_ONLY))
          #endif
          {
            #ifdef STATS
              if (stats)
                j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
              else
            #endif
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], 1); /* output in jblocks[0] */
            #ifdef TIMINGS
              if (!(cinfo->options & jopt_DCT_ONLY))
            #endif
              if (cinfo->options & jopt_OUTBPP_8GREY)
                asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
              else
                asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
          }
          width += 8;
          if (cinfo->options & jopt_OUTBPP_8GREY)
            outptr += 2;
          else
            outptr += 8;
        }
        nlines_fetched = 8;
      }
    }
    else /* colour */
    {
      int width = 0;
      int *outptr = cinfo->band_buffer;
      HUFF_TBL *ydc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[0]->dc_tbl_no];
      HUFF_TBL *yac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[0]->ac_tbl_no];
      QUANT_TBL_PTR yquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[0]->quant_tbl_no];
      HUFF_TBL *udc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[1]->dc_tbl_no];
      HUFF_TBL *uac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[1]->ac_tbl_no];
      QUANT_TBL_PTR uquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[1]->quant_tbl_no];
      HUFF_TBL *vdc = cinfo->dc_huff_tbl_ptrs[cinfo->cur_comp_info[2]->dc_tbl_no];
      HUFF_TBL *vac = cinfo->ac_huff_tbl_ptrs[cinfo->cur_comp_info[2]->ac_tbl_no];
      QUANT_TBL_PTR vquanttbl = cinfo->quant_tbl_ptrs[cinfo->cur_comp_info[2]->quant_tbl_no];
      int vsamp = cinfo->comp_info[0].v_samp_factor;
      int hsamp = cinfo->comp_info[0].h_samp_factor;

      tracef("in colour half of jpeg_find_line\n");
      /* tracef("Fetching colour band\n"); */

      while (width + 8*hsamp <= cinfo->xmin) /* skip over blocks we don't want */
      {
        do_huff_skip_blocks(cinfo, cinfo->jblocks[0], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
        asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
        asm_huff_skip_blocks(cinfo, cinfo->jblocks[0], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
        width += 8*hsamp;
        if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
        else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
        else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
        else outptr += 8*hsamp;
      }

      if (cinfo->options & jopt_DC_ONLY) /* colour, only want pixel tile values */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          int y[4];
          int u;
          int v;
          int i;

          do_huff_skip_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1, FALSE);
          y[0] = cinfo->last_dc_val[0] * yquanttbl[0];
          for (i = 1; i < hsamp*vsamp; i++)
          {
            asm_huff_skip_blocks(cinfo, cinfo->jblocks[1 + i], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], 1);
            y[i] = cinfo->last_dc_val[0] * yquanttbl[0];
          }
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_skip_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
          u = cinfo->last_dc_val[1] * uquanttbl[0];
          v = cinfo->last_dc_val[2] * vquanttbl[0];
          /* tracef("Colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
          colour_convert_pixels(y, u, v); /* results back in y[0..3] */ /* wasteful for weird sample ratios, don't care */
          /* tracef("Converted colour values %i %i %i %i, %i %i\n" _ y[0] _ y[1] _ y[2] _ y[3] _ u _ v); */
          for (i = 0; i < 8; i++)
          {
            outptr[i] = y[0];
            if (hsamp == 2) outptr[8+i] = y[1];
            if (vsamp == 2)
            {
              outptr[line_offset+i] = y[hsamp == 2 ? 2 : 1];
              if (hsamp == 2) outptr[line_offset+8+i] = y[3];
            }
          }
          width += 8*hsamp;
          outptr += 8*hsamp;
        }
        nlines_fetched = vsamp;
      }
      else /* colour, normal case (want all pixels) */
      {
        while (width < cinfo->xmax) /* the data we want */
        {
          do_huff_decode_blocks(cinfo, cinfo->jblocks[1], ydc, yac, yquanttbl, &cinfo->last_dc_val[0], hsamp*vsamp, FALSE);
          asm_huff_decode_blocks(cinfo, cinfo->jblocks[5], udc, uac, uquanttbl, &cinfo->last_dc_val[1], 1);
          asm_huff_decode_blocks(cinfo, cinfo->jblocks[6], vdc, vac, vquanttbl, &cinfo->last_dc_val[2], 1);
          #ifdef TIMINGS
            if (!(cinfo->options & jopt_HUFF_ONLY))
          #endif
          {
            #ifdef TIMINGS
              if (!(cinfo->options & jopt_DCT_ONLY))
            #endif
            {
              if (cinfo->options & jopt_GREY) /* greyscale output is acceptable */
              {
                tracef("about to do some grey conversion\n");
                if (cinfo->options & jopt_OUTBPP_8GREY)
                {
                  asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block_8(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[1], outptr + 2, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block_8(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block_8(cinfo->jblocks[3], outptr + 8*line_offset + 2, line_offset);
                  }

                }
                else
                {
                  #ifdef STATS
                    if (stats)
                      j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                    else
                  #endif
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* output in jblocks[0..3] */
                  asm_mono_convert_block(cinfo->jblocks[0], outptr, line_offset);
                  if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[1], outptr + 8, line_offset);
                  if (vsamp == 2)
                  {
                    asm_mono_convert_block(cinfo->jblocks[hsamp == 1 ? 1 : 2], outptr + 8*line_offset, line_offset);
                    if (hsamp == 2) asm_mono_convert_block(cinfo->jblocks[3], outptr + 8*line_offset + 8, line_offset);
                  }
                }
              }
              else
              {
                tracef("about to do some colour conversion\n");

                if (hsamp*vsamp == 4)
                {
                  #ifdef STATS
                    if (stats)
                      j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */
                    else
                  #endif
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
                  if (cinfo->options & jopt_OUTBPP_16)
                    asm_colour_convert_block_16(cinfo->jblocks[0], (short int*) outptr, line_offset);
                  else if (cinfo->options & jopt_OUTBPP_8YUV)
                    asm_colour_convert_block_8(cinfo->jblocks[0], (char*) outptr, line_offset);
                  else
                    asm_colour_convert_block(cinfo->jblocks[0], outptr, line_offset);
                }
                else
                {
                  #ifdef STATS
                    if (stats)
                    {
                      j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                      j_rev_dct(cinfo, cinfo->jblocks[5], 2);
                    }
                    else
                  #endif
                    {
                      asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                      asm_j_rev_dct(cinfo, cinfo->jblocks[5], 2);
                    }
                  colour_convert_unusual_block(cinfo->jblocks[0], outptr, line_offset, hsamp, vsamp);
                }
              }
            }
            #ifdef TIMINGS
            else /* for timing experiments - still do the DCTs */
                 /* we don't gather stats and timings at the same time, so no need to check STATS */
            {
              if (hsamp*vsamp == 4)
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], 6); /* output in jblocks[0..5] */ /* usual, speed-critical case */
              else
              {
                asm_j_rev_dct(cinfo, cinfo->jblocks[1], hsamp*vsamp); /* weird aspect ratio - only do DCTs we need to do */
                asm_j_rev_dct(cinfo, cinfo->jblocks[5], 2);
              }
            }
            #endif
          }
          width += 8*hsamp;
          if (cinfo->options & jopt_OUTBPP_16) outptr += 4*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8YUV) outptr += 2*hsamp;
          else if (cinfo->options & jopt_OUTBPP_8GREY) outptr += 2*hsamp;
          else outptr += 8*hsamp;
        } /* while */
        nlines_fetched = 8*vsamp;
      } /* if */
    } /* if */

    if (cinfo->options & jopt_DIFFUSE)
    /*cinfo->options & jopt_OUTBPP_8*/ /* convert to 8bpp output, for instance by dithering */
    {
      if (/*cinfo->table32k == 0 && */!cinfo->table32k_unavailable)
      {
        /* Try to get the 16bpp->8bpp lookup table from ColourTrans. If we
        fail then never try again, probably running on old OS/ColourTrans where it isn't available. */
        cinfo->table32k = asm_get_table32k(palette_data);
        if (cinfo->table32k == 0) cinfo->table32k_unavailable = TRUE;
        tracef("Fetched 32k lookup table, at 0x%x\n" _ (int) cinfo->table32k);
      }

#if 0
      /* Uni-directional dithering */
      for (i = 0; i < nlines_fetched; i++, line+=line_offset)
      {
        /* cinfo->xmin has been set to 0, so that dithering from the left all works OK */
        asm_diffuse_line_to_8bpp(line, linelen, (char*)line, cinfo->table32k);
      }
#endif
      /* tracef("Doing dithering to 8bpp on %i lines\n" _ nlines_fetched); */
      /* Dither in lengths of 16, to allow xmin to be non-zero. xmin is a multiple of 16 */
      if (cinfo->options & jopt_OUTBPP_8)
      {
        int *line = cinfo->band_buffer + cinfo->xmin;
        int linelen = cinfo->xmax - cinfo->xmin;
        char *outptr = (char*) cinfo->band_buffer + cinfo->xmin;

        /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
        unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
        be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
        on the clipping. xmin is already a multiple of 16. */
        linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
        if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;

//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
        while (linelen > 0)
        {
          int blockwidth = linelen >= 32 ? 16 : linelen; /* avoid having very narrow blocks at r hand edge. */

          tracef("calling diffuse to 8bpp code. pallete = %x\n" _ palette_data);
          asm_diffuse_to_8bpp(line, blockwidth, outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
          outptr = outptr + blockwidth;
          line += blockwidth;
          linelen -= blockwidth;
        }
      }
      else
      {
        int *line = cinfo->band_buffer + cinfo->xmin;
        int linelen = cinfo->xmax - cinfo->xmin;
        int *outptr = cinfo->band_buffer + cinfo->xmin;

        /* The error diffusion cannot handle a very thin strip at the right, eg one pixel wide. So the last
        unit of diffusion may be up to 31 pixels. However, the units of diffusion until then must
        be unaffected by exactly what xmin/xmax are, or we will get minor pixel variation depending
        on the clipping. xmin is already a multiple of 16. */
        linelen = (linelen + 15) & ~15; /* round up to a multiple of 16 */
        if (linelen > cinfo->image_width - cinfo->xmin) linelen = cinfo->image_width - cinfo->xmin;

//        if (cinfo->options & jopt_INTERP_X) {line += cinfo->xmin; linelen += linelen;} /* double if you have interpolated */
        while (linelen > 0)
        {
          int blockwidth = linelen >= 32 ? 16 : linelen; /* avoid having very narrow blocks at r hand edge. */

          tracef("calling diffuse to palette entires code. pallete = %x\n" _ palette_data);
          asm_diffuse_to_24bpp(line, blockwidth, (int *)outptr, cinfo->table32k, nlines_fetched, line_offset, palette_data);
          outptr += blockwidth;
          line += blockwidth;
          linelen -= blockwidth;
          tracef("done diffusion, outptr = &%x, blockwidth = &%xlinelen = &%x\n" _ outptr _ blockwidth _ linelen);
        }
      }
    }

    cinfo->current_huff_pointer = hpointer; /* line completed correctly - remember for next time. */
    /* tracef("Done requested band, bytes left = %i.\n" _ cinfo->buffer_end - cinfo->next_input_byte); */
  }

  /* The band buffer now contains suitable pixels */
  {
    int* result = cinfo->band_buffer;

    if (cinfo->options & jopt_DC_ONLY)
    {
      if (l2_band_height == 4 && (ycoord & 0xf) >= 8) /* colour - choose between two rows of pixels */
        result += line_offset; /* second row in colour output */
    }
    else /* normal - choose between 8 or 16 rows of pixels */
      result += (ycoord & ((1<<l2_band_height)-1)) * line_offset;

    /* tracef("result=0x%x\n" _ (int)result); */
    return result;
  }
}

/* --------------------------------------------------------------------- */
/* Stuff that scans a JPEG file and tells you the image height and
width, so that you can call jpeg_scan_file with sensible amounts of
workspace. Used by the ChangeFSI code, and by j2s. */

static BOOL looks_like_jpeg(char *jdata)
{

  if (  ((int*)jdata)[0] != 0xe0ffd8ff
     || jdata[6]  != 'J'
     || jdata[7]  != 'F'
     || jdata[8]  != 'I'
     || jdata[9]  != 'F'
     || jdata[10] != 0
     )
    return FALSE;
/*According to the JFIF 1.02 description from C-Cube, this test is safe.
However, we've found files which start with a comment field before this occurs.
What is more, the subsequent stuff is almost bound to be safe - so, OK to water
this test down? Here is the watered down one:
Decided to stick to official JFIF definition which gives us a guarantee of
finding Pixel densities (GPS)*/

/*  if (jdata[0] != 0xff | jdata[1] != 0xd8 | jdata[2] != 0xff) return FALSE;*/
  return TRUE;
}

static int find_image_dims(char *jdata, int *image_width, int *image_height,
                           int *image_type,
#ifndef CFSI
                           int *image_density,
#endif
                           int *ws_size, int *err)
/* Code to find basic dimensions of a JPEG file. Not done via main scanning
code so that you can decide these things before you allocate the band buffer
etc. Returns 0 if all is OK, 1 if this is not kosher JPEG data. Returns
recommended minimum space needed by jpeg_scan_file in ws_size. */
{
  int             iwidth;
  int             iheight;
  int             itype = 0;
#ifndef CFSI
  char            buffer[1024];
  int             file_handle,
                  dataend;
#endif
  int             load_file = 0;
#ifndef CFSI
  int             pixel_density,
                  density_units;
  _kernel_oserror *e;
#endif

#define CMTOINCH      254
#define STANDARDDPI   90

  tracef("Find image dims called.\n");
  if (((int)ws_size & 3) == 1)
    load_file = 1;
#ifndef CFSI   /* remove when compiling CFSI-jpeg  */
  if (load_file) /* We need to load the file... */
  {
    tracef("We think it's a filename\n");
    tracef("file = '%s'\n" _ jdata);
    tracef("Got to 1\n");
    e = _swix(OS_Find, _IN(0) | _IN(1) | _OUT(0), 0x4f, jdata, &file_handle);
    if (e != 0)
    {
      tracef("e points to '%s'\n" _ e->errmess);
      tracef("err is %x\n" _ err);
      *err = (int)e;
     /* strcpy(err->errmess, e->errmess);*/
      tracef("err points to %x\n" _ e);
      tracef("err is %x\n" _ err);
      return((int)e);
    }
    tracef("Got to 2\n");
    jdata = buffer;
    tracef("Got to 3. buffer = %x\n" _ buffer);
    e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                  4, file_handle, jdata, 1024, &dataend);
    if (e != 0)
    {
      _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
      *err = (int)e;
      return((int)e);
    }
    tracef("Got to 4 jdata = %x, data_end = %x\n" _ jdata _ dataend);
  }
#endif
      tracef("jdata = %x\n" _ jdata);
  if (!looks_like_jpeg(jdata))
  {
#ifndef CFSI
    tracef("it ain't a jpeg\n");
    if (load_file)
    {
      tracef("trying to close file\n");
      e = _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
      if (e != 0)
      {
        *err = (int)e;
        return((int)e);
      }
    }
#endif
    return 1;
  }
  tracef("jdata = %x\n" _ jdata);
#ifndef CFSI
  density_units = jdata[13]; /* from JFIF definition */
  tracef("pixel density units are  %d\n" _ density_units);
/*  pixel_density = ((int*)jdata)[14] + jdata[15] + jdata[16] + jdata[17]*/;
  /*Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
  if (density_units == 1)
  {
    tracef("1.jdata[14-17], %x %x %x %x\n" _ jdata[14] _ jdata[15] _ jdata[16] _ jdata[17]);
   /* tracef("1.(int)jdata[14], %x\n" _ ((int*)jdata)[14]);*/
    pixel_density = (jdata[14] << 24) + (jdata[15] << 16) + (jdata[16] << 8) + jdata[17];
    tracef("1.pixel density in %x\n" _ pixel_density);
  }  /*Should make pixel_density = [XdenHigh XdenLow YdenHigh YdenLow] */
  else if (density_units == 2)
  {
    pixel_density = (int)(jdata[14]*CMTOINCH/100) << 24 + (int)(jdata[15]*CMTOINCH/100) << 16
                     + (int)(jdata[16]*CMTOINCH/100) << 8 + (int)(jdata[17]*CMTOINCH/100);
    tracef("2.pixel density in %d\n" _ pixel_density);
  }
  else /* density_units == 0 */
  {
    int xdens, ydens;

    xdens = 90;
    ydens = (jdata[14] << 8) + jdata[15]; /* take into account the case where the scale may be 0:0, pah! */
    if (ydens == 0) ydens = 1;
    ydens = ((jdata[16] << 8) + jdata[17]) / ydens;
    if
      (ydens == 0) ydens = 90;
    else
      ydens *=90;
/*    ydens = 90*((jdata[16] << 8) + jdata[17])/((jdata[14] << 8) + jdata[15]);*/
    pixel_density = (xdens << 16) | ydens;
    itype |= 0x100;    /* set bit in type word to indicate density os only a ratio */
    tracef("3.pixel density in %d\n" _ pixel_density);
  }
#endif
  /* We need the image width and height in order to construct the
  sprite header. Walk into the JPEG file until we find the SOF marker. */
  {
    #if 0
    char *jdata_max = jdata + size; /* limit check in case of corrupted/truncated file */
    #endif

    #define M_SOI 0xd8
    #define M_SOF0 0xc0
    #define M_SOF1 0xc1
    #define M_SOF9 0xc9
    jdata += 2; /* skip over 0xFF, SOI(0xd8) */
      tracef("jdata = %x\n" _ jdata);
    while (  1 /* jdata < jdata_max */
          && jdata[0] == 0xff
          && jdata[1] != M_SOF0
          && jdata[1] != M_SOF1
          && jdata[1] != M_SOF9
          ) /* until we get to SOF marker */
    {
      jdata += (jdata[2] << 8) + jdata[3] + 2; /* skip over variable length marker */
#ifndef CFSI
      if (load_file)
        if((int)jdata >= dataend)  /* load up more data */
        {
          int   offset = (int)jdata - dataend;

          tracef("Loading another chunk. jdata = %x, data_end = %x\n" _ jdata _ dataend);
          jdata = buffer;
          tracef("jdata reset to %x\n" _ jdata);
          e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                        4, file_handle, jdata, 1024, &dataend);
          if (e != 0)
          {
            _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
            *err = (int)e;
            return((int)e);
          }
          while (offset > 1024)
          {
            tracef("Loading another chunk.\n");
            e = _swix(OS_GBPB, _IN(0) | _IN(1) | _IN(2) | _IN(3) | _OUT(2),
                          4, file_handle, jdata, 1024, &dataend);
            if (e != 0)
            {
              _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
              *err = (int)e;
              return((int)e);
            }
            offset-=1024;
          }
          jdata += offset;
          tracef("Loaded. jdata = %x, data_end = %x, offset = %x\n" _ jdata _ dataend _ offset);
        }
#endif
    }
    if (jdata[1] == M_SOF0 || jdata[1] == M_SOF1 || jdata[1] == M_SOF9) /* found an SOF marker */
    {
      iheight = (jdata[5] << 8) + jdata[6];
      iwidth = (jdata[7] << 8) + jdata[8];
      itype |= jdata[9]; /* or 3 for YUV, the other state we can accept. */
    }
    else
    {
      tracef("Header looks like JPEG data, but can't find image height/width.\n");
      return 1;
      /* It's hard to be more specific than this. The header of the file looks like
      JPEG, but it has been truncated, or has the wrong sort of entropy encoding. */#
    }
  }

  /* tracef("Image width = %i, image height = %i, %s data.\n" _ iwidth _ iheight _ itype == 1 ? "greyscale" : "colour"); */
#ifdef CFSI
  if ((int)ws_size > 1)
  {
    *ws_size = sizeof(struct decompress_info_struct) + 1024
             + sizeof(huff_pointer) * (itype==1 ? ((iheight + 7)/8) : (iheight + 15/16))
             + (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
    /* This is pessimistic overall for files with strange Y:U::V sample ratios - don't care.
       (estimate for the huff_pointer array is optimistic, but the band buffer size is vastly pessimistic) */
    *ws_size = (*ws_size + 3) & ~3; /* round up to a multiple of 4 */
  }
  if (image_height) *image_height = iheight;
  if (image_width) *image_width = iwidth;
  if (image_type) *image_type = itype;
  return 0; /* all is well */
#else
  if ((int)ws_size > 3)
  {
    decompress_info_ptr   info;
    int             current_size,
                    new_size,
                    page_size;

    ws_size = (int *)((int)ws_size & ~3);
    info = (decompress_info_ptr)*ws_size;
    current_size = info->workspace_size;
    new_size = sizeof(struct decompress_info_struct) + 1024
             + sizeof(huff_pointer) * (itype==1 ? ((iheight + 7)/8) : (iheight + 15/16))
             + (itype == 1 ? 8 : 16) * (iwidth + 15) * sizeof(int);
    /* This is pessimistic overall for files with strange Y:U::V sample ratios - don't care.
       (estimate for the huff_pointer array is optimistic, but the band buffer size is vastly pessimistic) */
    new_size = (new_size + 3) & ~3; /* round up to a multiple of 4 */

    /* if info is not NULL then it points to the current decompress_info_struct which
       contains info about the current memory allocation*/
#ifdef DYNAMIC_AREA
    tracef("We are thinking about a walk into the Dynamic Area...\n");
    _swix(OS_ReadMemMapInfo, _OUT(0), &page_size);
    if (!info)
    {
      new_size = (new_size + page_size-1) & ~(page_size-1);
/*      new_size += page_size; *//*lets be a bit conservative!!*/
/*      new_size -= (new_size % page_size);
        new_size += page_size<<1;*/
    }
    else
    {
      tracef("We are walking into the Dynamix Area...\n");
      if (info->workspace_size >= new_size)
      {
        new_size = 0;   /* we already have enough memory */
      }
      else
      {
        new_size -= info->workspace_size;  /* size that will be added to Dynamic area for this jpeg */
        new_size = (new_size + page_size-1) & ~(page_size-1);
/*        new_size += page_size;*/ /*lets be a bit conservative!!*/
/*	new_size--;
        new_size -= (new_size % page_size);
        new_size += page_size<<1;*/
      }
    }
    *ws_size = new_size;
    tracef("We need another %x bytes\n" _ new_size);
#else
    if (!info)
      *ws_size = new_size + 10000;   /* first jpeg => alloc size we need plus safety margin */
    else
      if (info->workspace_size >= new_size)
        *ws_size = 0;   /* we already have enough memory */
      else
        *ws_size = new_size + 20000;  /* size that will be re-alloced for this jpeg */
#endif
  }
  if (image_height) *image_height = iheight;
  if (image_width) *image_width = iwidth;
  if (image_type) *image_type = itype;
  if (image_density) *image_density = pixel_density;
  if (image_density) tracef("4.pixel density in %d\n" _ *image_density);
  if (load_file) /* We need to close the file... */
  {
    tracef("closing file\n");
    e = _swix(OS_Find, _IN(0) | _IN(1), 0, file_handle);
    if (e != 0)
    {
      *err = (int)e;
      return((int)e);
    }
  }
  return 0; /* all is well */
#endif
}

#include "c.SpriteOp"

