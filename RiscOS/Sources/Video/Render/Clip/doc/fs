Copyright (c) Acorn Computers Ltd. 1995                  1307,102/FS Issue 0

                   SkyNet: Replay 3 Functional Specification
                   =========================================

                   ,---------------------------------------,
                   | Drawing No : 1307,102/FS              |
                   |      Issue : 0.11 *** DRAFT ***       |
                   |       Date : 08-Feb-96                |
                   |     Author : Simon Proven             |
                   |     Sheets :                          |
                   |  Last Issue: None                     |
                   '---------------------------------------'

Contents
########

1. History

2. Outstanding Issues
  2.1 Sound
  2.2 MovieFS Availability
  
3. Overview
  3.1 Multitasking
    3.1.1 Video Delivery
    3.1.2 Video Clipping
    3.1.3 Audio Handling
  3.2 Alien Video Codec Support
    3.2.1 MovieFS
    3.2.2 Fetcher Mechanism
  3.3 TimeCode Subsystem Support
    3.3.1 Replay TimeCode Generation
    3.3.2 Replay As A TimeCode Follower
 
4.0 Technical Background
  4.1 Operational Concepts
    4.1.1 System Architecture
      4.1.1.1 Single Tasking Operation
      4.1.1.2 Multi Tasking Operation
    4.1.2 Target Window
      4.1.2.1 Replay Maintained Window
      4.1.2.2 Someone Else's Window
  4.2 Clip Module
    4.2.1 Clipping Region Generation
      4.2.1.1 The Get Rectangle Filter
      4.2.1.2 The Rectangle Copy Filter
      4.2.1.3 Movement of Our Own Window
      4.2.1.4 Clipping Region Storage
    4.2.2 Special Cases
      4.2.2.1 Mode Changes
      4.2.2.2 Applications Starting
      4.2.2.3 Paused Movies
    4.2.3 Performance Issues
    4.2.4 Fault Tolerance
      4.2.4.1 Re-entrancy
      4.2.4.2 Memory Protection
      4.2.4.3 Parameter Checking
  4.3 Replay TimeCode Operation
    4.3.1 TimeCode Generation
    4.3.2 TimeCode Following

5.0 User Interface

6.0 API
  6.1 Clipping Module SWIs
    6.1.1 SWI Clip_Create
    6.1.2 SWI Clip_Destroy
    6.1.3 SWI Clip_Pause
    6.1.4 SWI Clip_Alter
  6.2 Command Line Parameters
    6.3.1 -multi <address>
    6.3.2 -window <task handle>,<window handle>
      
7.0 Data Formats
  7.1 Clipping Region Data Format

8.0 External Dependancies
  8.1 FilterManager
  8.2 TimeCode Subsystem
  8.3 MovieFS
  
9.0 Development Test Strategy
  9.1 Performance
  9.2 Test Harnesses
  9.3 Clipping Module Tests
  
10.0 Limitations And Constraints
  10.1 Full-Screen Applications Starting From Desktop
  
11.0 Acceptance Tests
  11.1 Performance
    11.1.1 Single Movie Playback
      11.1.1.1 Machine Useability
      11.1.1.2 Wimp Poll Latency Tolerance
    11.1.2 Multiple Movie Playback
  11.2 Desktop Usability
  11.3 IRQ Latency
  
12 Organisation
  12.1 ARMovie Directory Structure
  
13 Future Enhancements
  13.1 Multiple Sound Support
  13.2 Multimedia Chunks
  

1. History
##########

0.00 sbp 21-Jun-95 Started document
0.01 sbp 23-Jun-95 Added Outstanding Issues
0.02 sbp 25-Jun-95 Various minor changes and additions, mainly 
                   started on API
0.03 sbp 03-Jul-95 More misc additions, filling out etc
0.04 sbp 31-Jul-95 Extended development test section.
0.05 sbp 07-Aug-95 Added fetchers and multimedia chunks detail, acceptance tests.
0.06 sbp 14-Aug-95 Filling out of API section.
0.07 sbp 30-Aug-95 Removed multimedia chunks.
0.08 sbp 17-Nov-95 Updated API.
0.09 sbp 07-Feb-96 Removed outstanding issues on painting in low bpp modes,
                   performance, mode change behaviour, single tasking apps,
                   and FilterManager.  Major rewrite of sections on clipping
                   and testing, general tidying.
0.10 sbp 08-Feb-96 Removed obsolete command line parameters, tightened wording,
                   added information on test harnesses, brought contents up to
                   date.
0.11 sbp 10-Apr-96 Removed last outstanding issues, tightened things up, sorted
                   out how sound and TimeCode interaction will work.
0.12 sbp 18-Jul-96 Moved Clip module stuff to own document.

2. Outstanding Issues
#####################

None.

3 Overview
##########

Acorn Replay has established itself as the core of our multimedia
architecture, providing a coherent and extendable "Full Motion Video"
(FMV) playback system.  The enhancements proposed in this specification
further extend Replay's functionality to allow it to integrate better with
other multimedia resources, and introduce support for alien video (this
support is specified in detail separately).

Replay 3 will provide multitasking video playback; this will allow the
computer to continue to operate in a multitasking fashion while video is
played, and allow multiple simultaneous movies to be played within the
desktop, given sufficient processor power, by running multiple
simultaneous instances of the Replay 3 player.  Where a single movie is
played, multitasking of Replay movies will deliver performance close to,
but not exceeding - except for gains brought about through algorithmic
improvements - that of single tasking Replay.

Replay 3 will provide API hooks to allow alien video formats, such as AVI
(Video for Windows) files, to be played within the Replay architecture. 
This will enable Replay to play movies from the PC world in such a manner
that the format of the movie will be transparent to the application
attempting to play the movie.

It will be feasible to write a video codec and a file recogniser for the
majority of alien video formats.  Once such a codec has been implemented,
it will be possible for any Replay 3 aware application to play the video. 
Further, it will be possible to convert such movies to an ARMovie file,
thus avoiding the need for run-time translation.

3.1 Multitasking
================

In multitasking mode, Replay 3 will be able to play video alongside other
tasks within the desktop, rather than taking over the entire machine. 
This will allow the user to play multiple simultaneous movies, and will
allow the user to continue using other applications while video is being
played.

3.1.1 Video Delivery
--------------------

Replay 3 will be able to paint video into a window provided by any
desktop application which "understands" it.  This would allow, for
instance, a multimedia application such as Genisis to incorporate moving
video within a page, without the need for the playing of the movie to
interfere with the use of the application.  In such cases, the user
interface front-end to control the operation of the movie would be
provided by the client application.

It is anticipated that !ARPlayer will use this technique to provide a user
interface for playing back of movies; as a new ARPlayer is not a
deliverable of this project (we are only providing an upgrade to the
underlying architecture), a small application will be written using the
ToolBox, to test the ability to paint into other application's windows,
and to test the control of a movie by another application.

3.1.2 Video Clipping
--------------------

In order for Video to integrate properly into the desktop environment,
Replay 3 must clip its painting of video to avoid overwriting windows
which in some way cover areas of the video output.  As Replay, in order
to achieve high performance, does its painting in the background,
scheduled on the VSync interrupt, it cannot use the normal mechanism for
redrawing windows in the desktop (where an application calls
Wimp_UpdateWindow then Wimp_GetRectangle repeatedly until the entire area
to be updated has been redrawn).  This mechanism cannot be used from
within a background process as the Window Manager can only support one
redraw process at a time.

The Clip module has been designed to address this issue; it is specified
separately.

3.1.3 Audio Handling
--------------------

Multiple Replay movies will not initially be able to play audio
simultaneously.  Instead, the user will be able to select which movie's
audio is played.  In future with a new more sophisticated multi-channel
sound system it will be possible to have multiple Replay movies playing
sound simultaneously, provided that Replay is updated appropriately.

The multiple channel audio support is not specified here, but is instead
specified as a separate document, as is must be separately quoted for
ANC.

3.2 Alien Video Codec Support
=============================

Alien video codecs will be supported by extending the Replay architecture to
support playing of video which is not in the ARMovie format.  This will
require alien video file recognition, and translation.

3.2.1 MovieFS
-------------

MovieFS currently provides a means for users of RISC OS machines to play
alien video formats through ARMovie.  MovieFS does the work of
re-organising the movie into a form which can be played by ARMovie.  This
involves generating the ARMovie file header, and re-arranging the file
data into a form suitable for ARMovie - that is, a number of chunks, each
containing a given number of video frames and a given amount of audio
data.  MovieFS performs this translation task as an image filing system.

Once the movie has been translated, it can then be passed into ARMovie and
the standard ARMovie playback code is used.  MovieFS comes with a number
of ARMovie Decomp handlers to perform the actual decompression of the
movie data.

Being an image filing system, MovieFS introduces a number of overheads
into the system.  These overheads can be reduced by the use of alien video
fetchers.  These allow the movie to be played without going through the
image filing system.  MovieFS will support the fetchers, so that fetchers
will be used by MovieFS to gather data from a movie.

3.2.2 Fetcher Mechanism
-----------------------

The overheads of the Image Filing system approach taken by MovieFS
(effectively the filing system calls have to be done twice), can be
avoided for the playback by allowing a fetcher to be specified, which will
be asked to fetch a given chunk, as and when required, by accessing the
movie file directly, instead of operating as an image filing system.

This specification does not define how fetchers will operate.

3.3 Timecode Subsystem Support
==============================

The SkyNet TimeCode subsystem allows a number of time dependant devices or
systems to be synchronised.  By adding TimeCode support to Replay, we
allow Replay movies to be synchronised to other time dependant devices or
systems.  Support is provided for Replay providing the time stream, or for
another source of time (for instance, a MIDI clock), to cause the movie to
start playing a given time.  Full TimeCode following is not supported.

3.3.1 Replay TimeCode Generation
--------------------------------

A given Replay movie will be able to generate timecode output from a
movie.  The ARMovie clock will provide a clock for the TimeShare module,
which will be listed alongside the available clocks.  This clock module
will allow multiple movies to register with it, though only a single movie
can be the source of time at any moment. 

3.3.2 Replay As A TimeCode Follower
-----------------------------------

Replay will not be able to play a movie with full synchronisation with a
TimeCode stream, due to the technical difficulties imposed.  Instead,
Replay will only allow a movie to be started when the TimeCode reaches a
specified point.

3.5 Target Platforms
====================

3.5.1 Operating Systems
-----------------------

The software will operate on RISC OS 3.50 and 3.60.  It may be possible to
add support for RISC OS 3.10, if required; the major limitation on RISC OS
3.10 will be caused by the lack of dynamic areas, which the clipping
module currently uses.  The clipping support can never run on RISC OS 2.00
as it relies on the presence of Wimp filters, which were introduced in
RISC OS 3.00.

3.5.2 Hardware
--------------

On ARM610 and ARM710 machines, with VRAM, playing a single 25fps movie, or
two 12.5 fps movies, of the size supplied with RPC and A7000 machines,
should be playable by multitasking Replay.  Without VRAM, performance
will be considerably reduced due to bus contention caused by screen
refresh DMA.

Much of the time, Replay is running very close to the limit of the
performance available from the machine at present.  This means that a
small change in actual performance could have a dramatic impact on
performance delivered to the user.

If RISC OS 3.10 machines are supported, the performance will be limited by
the power of ARM2 or ARM3.

Memory requirments - Replay 3 will not be targetted at 2M byte machines,
however it may be possible to play small movies on such machines.  4M byte
machines should be able at least one movie, hopefully more.

3.6 Sound Support
=================

Replay 3 will provide support for playing multiple sound streams, through
the use of the multiple sound stream support being proposed for ANC.  The
proposal provides for the selection of a single output from a selection of
input sound streams.  This would allow us to have multiple movies playing
sound, given 16 bit audio hardware, but does not provide any solution on 8
bit hardware for multiple sound streams.  Replay 3 will provide no means
for playing multiple sound streams using 8 bit hardware.

Under the sound support scheme proposed, it would be possible for the user
to select which movie's sound output would be heard.  Other movies would
be muted at this point.

4.0 Technical Background
########################

4.1 Operational Concepts
========================

4.1.1 System Architecture
-------------------------

Replay's system arhitecture consists of a number of processes, many of
which are scheduled under interrupt.  In the foreground, the chunk fetcher
process gathers data from the movie file - typically held on a CD ROM
device or Hard Disc; though conceptually any RISC OS filing system can be
used, given adequate performance.  Interrupt driven processes decompress
the video, blit the decompressed video to the screen, and decompress and
play the sound.  These processes communicate by accessing shared memory.

4.1.1.1 Single Tasking Operation

In a single tasking environment, all of these processes reside in
application workspace.  The fetcher waits in a polling loop for the other
processes to be ready to accept data, and fetches data into one of the
chunk data buffers when it is required.  The other tasks run under
interrupt in the background.

4.1.1.2 Multi Tasking Operation

In the multitasking environment, the fetcher remains in application
workspace, and operates as a Wimp task.  As the other system components
must be runable at any time, as they are IRQ driven processes, they now
run in the RMA.  (As code fragments running in allocated RMA space, not as
a relocatable module).  Any workspace required under interrupt is either
placed in the RMA or in a dynamic area if possible, ie on RISC OS 3.50
onwards, as follows:

* The code for the decompressor, the painter, and the scheduling code,
  and any small associated static workspace, are placed in the RMA (can't
  run code in dynamic areas under RISC OS).

* Colour maps and video data buffers are placed in dynamic areas where
  possible.

Also, the clipping module places the clipping region in a dynamic area
where possible.

4.1.2 Target Window
-------------------

Movies will be painted into either a window created and maintained by
Replay, or will be painted into a window created and maintained by another
Wimp task.

The latter approach allows multimedia applications to mix Replay video
with other resources, such as text and still images, in a multitasking
application.

4.1.2.1 Replay Maintained Window

If -multi is specified to Player, then the default window to be used will
be the window generated by Player.  This window will be a non-moveable
window, with no title bar or other controls.

4.1.2.2 Someone Else's Window

In this case, the window will be maintained by another application, which
handles Wimp events on the window, and communicates with the ARMovie task
when required, via Wimp messages (defined in the API section, later), and
memory-resident flags.  The protocols to be obeyed by the Other Window
task will be defined in the API section, below.

Under Multitasking Replay, all mouse control of the application will be
handled through normal Wimp events, instead of low level mouse clicks as at
present - this will greatly simplify the writing of a user interface to
ARMovie.  When the application controlling the window is Player itself, it
will be the responsibility of Player to control the display of the movie.

4.2 Clip Module
===============

The clipping support will be provided by the Clip module.  This will
provide a number of interfaces, which will be primarily used by ARMovie to
support the clipping of a multitasking movie playback to the screen. 
However, it can also be used by other applications which wish to perform
similar asynchronous update of the screen.

4.2.1 Movement of our Own Window

We have to stop painting during movement of the window, as a paint halfway
through the wimp block copy would write over the window furniture, and
possibly damage the content of other windows.

ARMovie informs the Clip module of this by using the SWIs Clip_Moving (to
tell it that the movie is about to move) and Clip_Moved (when the window
has been moved).

4.2.2 Special Cases
-------------------

There are a number of special cases which we must be aware of in order to
prevent undesirable behaviour.

4.2.2.1 Mode Changes

Mode changes are only supported where a simple change of screen resolution
occurs; this allows 

4.2.2.2 Applications Starting

When a single tasking application starts, we must prevent the painting of
the movie from continuing, until the application terminates, or we
discover that it is really a multitasking application.

We detect the start of the application through Service_NewApplication;
when this occurs, we should stop painting and wait for the next null
event.  When we see a null event, we can start painting again.

As modules are the only type of program able to catch service calls, we
need to make the Clipping Module catch this particular call.  It will stop
painting by calling the callback function in the player code.

4.2.2.3 Paused Movies

Under previous versions of ARMovie, pausing of movies simply involed
stopping the painting of frames.  This works well, because the frame will
not be damaged by external events while it is paused.

This method is inadequate for desktop operation, as simply leaving the
painted frame on the screen is not sufficient to guarantee that the
display remains up-to-date in the deskztop; we have to cause areas of the
frame that are uncovered by window movement to be repainted.

Instead, the clipping module will tell ARMovie whenever more of the window
has been made visible, while the movie is paused.  This will cause ARMovie
to set a flag in its control block - causing the paint to occur on the
next Vsync.

4.2.2.4 Filter Manager Dying

When the Filter Manager dies, the filter events which are used to generate
the clipping region stop happening.  Thus, the clipping region must be
marked as invalid, to stop further painting from occuring.  This state
will continue until the filter manager is re-initialised.  The filter
manager dying can be spotted using Service_FilterManagerDying.  At this
point, the filters will have been deregistered.  When the filter manager
dies, the clipping regions will be left active, but will be cleared so
that nothing gets painted.

4.2.2.5 Filter Manager Initialising

If the filter manager has died, we spot it being initialised again using
Service_FilterManagerInstalled.  We then attempt to install our filters,
and if they install successfully, we then re-start the painting process.

In order to get the clipping going again, we ask the ARMovie task to
generate the redraw event.  It can't be done by the clipping module in the
service call handler because Invalid wimp operation in this context errors
occur on Wimp_GetWindowState.  Thus it is necessary to force a redraw of
the window.  It will either be done by asking the application that owns
the area of the window to redraw it, or by simply leaving an empty
clipping list, with the result that the clipping region will be inaccurate
(not drawing all visible regions) until a later point.

4.2.3 Performance Issues
------------------------

It is crucial that the clipping module does not cause excessive overheads
in the redraw of other application's windows.

When there are no active clipping regions, the clip module will deregister
all filters.  This will mean that the overhead of having the clipping
module running with no movies playing will be negligable.

The first action taken by the clipping module on receipt of any event,
will be to determine whether it is of interest or not (by comparing the
bounding box of the redraw or copy event with the clipping region visible
bounding box).  This way, any redraws which do not overlap a Replay movie
will be quickly ignored.

Also, on a line-by-line basis, we will have similar bounding conditions
for the visible region, so that redraws which overlap lines which are
already mostly clipped, will be ignored.

4.2.4 Fault Tolerance
---------------------

The Clip module will be designed to be as tolerant of fault conditions as
possible; it will attempt to avoid re-entrancy loops as described below,
and it will protect its workspace against corruption by applications
running in USR mode.

4.2.4.1 Re-entrancy

A particularly nasty failure mode for the filter is if a data abort occurs
during the operation of the filter code - this will cause an error to be 
generated, causing a filter event to occur, which may well cause a data
abort to occur again.  The result of such a situation would be an infinite
loop.

To avoid such a problem occuring, the clipping module will set a
re-entrancy flag.  If a filter is entered when this flag is set, then a
failure condition has occured; the filter will set a 'failed' flag, any
further entry to the filter routine will cause immediate return.  When
FilterManager SWIs are called, the 'failed' flag being set will cause an
error to be returned.

4.2.4.2 Memory protection

The memory of the clipping module will be protected from USR mode writes;
only code running in SVC mode will be able to write to the clipping
region.  This will prevent accidental corruption of a clipping region by
corrupted pointers in USR mode code, though there will be no defence
against corruption by SVC mode code.

4.2.4.3 Parameter Checking

Wherever possible, the clipping module will check parameters to prevent
illegal values causing fault in the clipping module or elsewhere.

4.3 Replay TimeCode Operation
=============================

4.3.1 TimeCode Generation
-------------------------

TimeCode generation will be enabled by the -TimeSource switch.  Under this
mode, ARMovie will cause a new time to be generated when every frame is
painted (just before the frame is painted to the screen).

A movie can only become the time source if there is no other movie
generating the time stream.  The TimeShareARMovie will refuse to die if
there is a movie which has control of the time stream (because it may have
the time entry point called).

4.3.1.1 Clock Operation

The ARMovie clock will operate as required for a clock module for the
TimeShare system.  It will respond to Service_TimeShare (service call &B2)
in order to support the clock management calls for the TimeShare module.

The clock should be visible to applications, and should be selectable as
the currently active clock.

4.3.2 TimeShareARMovie
----------------------

The TimeShareARMovie module provides the ARMovie clock; it will respond
to the TimeShare service call as required (see the TimeShare specification
for details of the calls that a Clock module will support).  The
TimeShareARMovie will provide facilities to allow a number of ARMovies to
register themselves with the Clock.  At any one time, only one movie may
be in control of the time sequence; although multiple movies can be
registered, since there can only be a single notion of 'current time' in
the timecode system, there can only be one movie generating the time.

The TimeShareARMovie_Register SWI allows a movie to place itself on the
list of registered movies; this list is built in the RMA as a linked list. 
Registering a movie with the TimeShareARMovie simply causes the movie to
be added to the linked list; it prevents the TimeShareARMovie module
exiting if there are still movies on the list.

The TimeShareARMovie_Deregister SWI allows a movie to remove itself from
the list.

The TimeShareARMovie_Attach SWI causes the movie to become the source of
time to the ARMovie clock; only a valid handle will allow this to occur.

The TimeShareARMovie_Detach SWI causes the movie to stop controlling the
time flow; the previous attached movie does not regain control of the time
stream; instead, the time stream enters the 'stopped' mode.

4.3.3 TimeCode Following
------------------------

ARMovie will be able to start playback at a given TimeCode point by using
the -starttime switch.  This takes the TimeCode in hours, minutes, seconds
and frames, using the format hh:mm:ss.ff

4.4 Alien Video Support
=======================

This is being specified as a separate task by Sophie Wilson and Warm
Silence software.

5.0 User Interface 
##################

There is no user interface within ARMovie.

6.0 API
#######

6.1 Clipping Module SWIs
========================

6.1.1 SWI Clip_Create (Clip_Base + 0x0)
---------------------------------------

This SWI creates a clipping region.

In:  R0=flags

	bit	meaning when set
	0	do not allow mode changes to occur

	bits 1-31 are reserved and should be set to 0

     R1=ptr to parameter block:
     
       +0  = window handle
       +4  = task handle
       +8  = bbox xmin (work area coords)
       +12 = bbox ymin (work area coords)
       +16 = bbox xmax (work area coords)
       +20 = bbox ymax (work area coords)
       +24 = pointer to callback routine
       +28 = log2 vertical scaling factor
       +32 = log2 number of spans per scan line

 On exit:

       R0  = handle for clipping region
       R1  = pointer to scan table

       All other registers preserved

This SWI call is used to create a new clipping region.  The callback
routine is used to handle a number of events which occur in the life of
the clipping region.

The scan table contains a list of all the scan line sections which are to
be painted.

6.1.2.3 Callback Routine

The main purpose of the callback routine, is to turn off painting at some
points in the lifetime of the clipping region.  Other reason codes may be
used by future versions of the clipping module; they will not be called
unless the appropriate flag is set in the parameters to Clip_Create.  To
ensure fault tolerance, the callback routine should do nothing on reason
codes which it does not understand.  The callback entry points are
documented below.

6.1.2.4 Vertical Scaling Factor

This is used to request that the clipping module provide extra information
in the clipping region, to allow clipping of movies which are scaled
vertically to be efficient.  This only works in powers of 2.

6.1.2 SWI Clip_Destroy (Clip_Base +0x1)
---------------------------------------

This SWI call is used to terminate a clipping region.

Entry:
      
       R0 = flags
       R1 = clipping region handle
       
Exit:

       All registers preserved - unless error.

6.1.3 SWI Clip_Moving (Clip_Base +0x2)
-------------------------------------

This SWI call is used to tell the Clipping module when a window is about
to move.

Entry:  R0 = flags (currently all values except 0 reserved)
	R1 = window handle of window containing movie

Exit:	All registers preserved.

This SWI call is used to tell the clipping module that something is going
to happen with the clipping region - eg Wimp_OpenWindow is about to be
called for a window containing a clipping region, or a number of clipping
regions (should also call before Wimp_CloseWindow if the clipping region
is still active).  This SWI is required because the clipping module cannot
easily determine which window is being moved from a rectangle copy event
(there is no window handle provided), and also to allow changes to be made
to the clipping region on the fly.

Therefore this SWI will be called by the application owning the window
before calling Wimp_OpenWindow.  Once the Window has moved, (preferably
immediately after calling Wimp_OpenWindow) the Clip_Moved SWI is called to
tell the clipping module that the change has been done, and allows the
clipping module to make the necessary alterations.

Between the calling of Clip_Moving and Clip_Moved, the state of the
clipping region will be inconsistent with the display on the screen, so
the clipping region is cleared to all covered at this point.  This means
that any paints which occur during the window movement will have NO
effect.  This is normally not a problem - there should be enough frames
painted when the window is being dragged normally.

However, there are still Open_Window_Requests generated when the movie
window is still, if it is not word aligned.  Hence if the window is not
going to be moved from its present position, the application should NOT
obey the request to open the window, and should leave the window where it
is on the screen.  This prevents painting becoming erratic and frames
being dropped unnecessarily.

6.1.4 SWI Clip_Moved
--------------------

This SWI is used to tell the clipping module that the window has now
moved, or to change the contents of the clipping region structures; it can
be called immediately after the Wimp_OpenWindow call has been made.

The clipping module will read the position of the window and then will
re-start the painting process (using Wimp_UpdateWindow to generate a new
clipping region).

Entry:

	R0	= flags
	R1	= window handle

Exit:
	All registers preserved.

Purpose:

To tell the clipping module that a window which had been moving, has
moved.

6.2 Command Line Parameters
===========================

This section lists the new command line parameters supported by ARMovie;
all the old ones are documented in ARMovie.Documents.ProfIf

6.3.1 -Multi <address>

Play the movie using multitasking. All memory is allocated in interrupt
shareable space (module area or Sprite Area on pre-RiscPC machines,
dynamic areas on the RiscPC), the playing code is put onto the module
area. The movie is played with a Wimp polling scheme, so it cannot
withstand long delays within the window managed system. The initial caller
is not returned to until the movie has stopped, but may get called on
other threads by the window manager. When the movie stops, ARMovie$Return
is valid.

The calling program must ensure that the screen mode is not changed while
the movie is being played. The tolerance of source device latency is
reduced to the value defined in the Access file, or to a default of 0.28
seconds.

The (decimal) address is filled in with the address of a word which
contains the following alterable status bits:

bit 0: pause
bit 1: mute the sound
bit 2: exit
bit 3: single frame advance
bit 6: exit/capture
bit 7: don't display the video

The other bits in the word must not be altered. The calling program must
ensure that the screen mode is not changed while the movie is being
played.

Bit 2 becoming set in the status word signals that the movie has finished
or the user has initiated an exit somehow. If an address of 0 is given,
then nothing happens. While the Player starts, the address given will be
0, while it runs there will be a value, then after it stops, the address
will be changed back to 0 (because the memory is returned to RISC OS).

Offset  4: movie bottom X
Offset  8: movie bottom Y
Offset 12: movie top X
Offset 16: movie top Y
Offset 20: movie played fps (after -speed is taken into account) * 100
Offset 24: screen address for painter to use

6.3.2 -window <task handle> <window handle>

Don't create a window of ARMovie's own to play the movie into, but instead
paint the movie data into the window owned by another task.  This allows
the movie to be played into effectively any window on the desktop.

Normally, this option would be used by a program such as ARPlayer to
provide a window into which the movie could be played.  It can be used to
paint into virtually any area of any window (for instance, a movie could
be played onto an icon).

Placement of the movie within the window is controlled with -at, except
that the position is now relative to the window's work area origin,
instead of relative to the bottom, left corner of the screen.

When the window is moved, the ARMovie task needs to be told that the
position of the movie has changed on the screen; the screen address to
paint to must be told to ARMovie by the application.  This is done by
updating the value at offset 24 from -multi above.

6.3.3 -starttime <timecode value>

Allows the start time of the movie to be specified.

6.4 TimeShareARMovie SWIs
=========================

These SWIs provide an interface to allow ARMovie tasks to control the
ARMovie clock.  In order to minimise the overhead in the paint routine of
setting the time, the TimeShareARMovie SWIs allow a movie to call the low
level clock time update routine via a veneer routine.

6.4.1 TimeShareARMovie_Register
-------------------------------

Purpose:

Registers a movie with the ARMovie Clock.  This must be performed before
the movie can drive the time stream.

Entry:
  R0 = frame rate

Exit:
  R0 = handle to refer to this registration of movie
  R1 = address to call when updating time
  
  V set on error.

This SWI must be called before TimeShareARMovie_Attach or Detach may be
called.  The movie will be added to a list of registered movies held by
this module.

6.4.1.1 Time uptdate routine

This routine is used to update time.  It may be entered in USR mode, SVC
mode or IRQ mode.  It should be entered as if from a BL.

Entry:
  R1 = handle
  R2 = new time
  
Exit:

  Nothing; can't return an error.


6.4.2 TimeShareARMovie_Deregister
---------------------------------

Purpose:

To tell the TimeShareARMovie module that this movie is no longer
interested in controlling the time stream.

Entry:
  R0 = handle from TimeShareARMovie_Register
  
Exit:

  Regs preserved.

  V set on error.

This SWI will inform the TimeShareARMovie module that the movie is no
longer interested in generating time.  If this movie is the currently
attached movie, then it will be made detached automatically, and the time
stream will be flagged as 'stopped'.

6.4.3 TimeShareARMovie_Attach
-----------------------------

Purpose:

To make a given movie the source of time.  The current time switches over
to the previous time for that clock.  After this has been done, any
further calls to the time update entry point will update the time
appropriately for this movie.

Entry:
  R0 = handle for this movie

6.4.4 TimeShareARMovie_Detach
-----------------------------

Detaches the given movie from the time stream.  Time for this movie will
stop, and the ARMovie clock will show this same time until another call to
TimeShareARMovie_Detach is called.

Entry:
  R0 = handle for this movie.

7.0 Data Formats
################

7.1 Clipping Region Format
==========================

The clipping region stores a list of scan line lengths, which together
provide a list of all the visible area within the movie.  The clipping
region is held in a dynamic area (if support is provided for pre-3.50
machines, the RMA will be used for this purpose).

The spans work down from the top, left of the screen.  If the region is
vertically unscaled, then each scan line of the region is considered by
itself.  However, if the movie is vertically expanded, the clipping region
contains extra information for every group of lines, which tells the
painter if the shape of the spans for the lines is identical, or if the
lines are not identical, within that group.  This allows the painter to
determine if it can use fast code for the group of spans, or use slow code
which has to treat each line differently.

The clipping region contains one line for every line of the image on the
screen; the first line corresponds to the top line of the image, and the
lines then continue down the image to the bottom; this is because ARMovie
painters start at the top, left corner of the image.  

Within scan lines, the spans are ordered in ascending order of horizontal
offset into the movie; this should not affect painters, and they should
not rely on it.  The ordering is mainly used by the clipping module to
optimise searches across the clipping region.

7.1.2 Line Data Structure
-------------------------

For any given clipping region, there is a maximum number of spans which
can be accomodated on that line.  The clipping module's behaviour when
there are more visible spans than can be held in the clipping region, is
to cause the rightmost span to be omitted from the line, resulting in a
non-destructive failure of the clipping module.

When painting the scan line, any order may be used - this is up to the
painter to decide.  In particular, ARMovie's painters paint the scan lines
in reverse order - right to left - as it simplifies the register usage of
the paint control code.

The line structure is laid out as follows:

offset	size	value
+0	4	number of spans and other flags
+4	4	first span element
+8	4	second span element
.	.	.
.	.       .
+4*n	4	final span element

The maximum number of elements within the span line is given by
(1<<Spans), from the Clip_Create SWI's stucture.  All the spans are
defined to be word aligned, and the minimum allowed value for Spans is 2
(ie 4 spans per line).

Each element contains the offset and length in pixels of the span, in
pixels:

bits	contains
0..15	offset (pixels)
16..31	length (pixels)

The ARMovie code makes the assumption that movies are always displayed at
less than 4096 pixels' width.  When painting vertically scaled
movies, ARMovie allocates bits 12..15, for its own purposes - it requires
bit flags which are used to determine which lines of a row are to be
output on each pass through the paint code.

8.0 External Dependencies
#########################

8.1 FilterManager
=================

The Replay Clipping system relies on the availablility of a filter manager
version which can provide access to the Wimp's copy and rectangle filters,
as well as the currently supporte Pre and Post filters on Wimp_Poll. 
Without such support, clipping support can still be implemented, but will
not integrate well with other applications which are use Filters based on
the rectangle and copy filters.

The specification 1307.07/FS defines the API for the new FilterManager.  A
prototype version of this which implements the SWIs documented in this
specification has been used with development of MulitTasking Replay and
satisfies our requirements.

8.2 TimeCode Subsystem
======================

Replay requires the TimeCode module present in order for the timecode
facilities discussed above to be useable within Replay.  The ability for
Replay to synchronise movies to external systems and devices relies on the
presence of the TimeCode MIDI Clock/Transmitter.

8.3 MovieFS
===========

The ability to handle alien video currently relies on MovieFS being
available to incorporate with this project.  Stewart Palmer is discussing
with Warm Silence how to produce a solution which is sufficiently powerful
for our requirements, and also protects future revenues for Warm Silence.

9.0 Development Test Strategy
#############################

9.1 Performance
===============

Replay 3 will be tested on a number of machine configurations to ensure
that it works across the complete range of machines.  In particular, a
number of different hard disc types will be tried when operating off a
local disc, and playing movies off a network will also be examined.  Also,
CD-ROM drives (an ATAPI drive would probably be sufficient) will be used
to examine performance on devices with increased latency.

The value of ARMovie$Frames will be used to determine how many frames from
the movie are dropped; ideally 0 frames should be dropped when a movie is
played.

9.2 Test Harnesses
==================

To test the painters fully, special test harnesses will be written which
generate clipping region shapes which exercise the full range of
possibilities in terms of shapes of spans.  These tests will check that
the entire movie is being painted over (the test scripts will write a
known value to any areas of screen not to be painted on, and will check
that they are not being corrupted).  Similarly, it will write the same
value to the areas of the screen that are to be painted to, allow time
enough for the movie to be painted, and check that the value is plotted
over.  A still image will be used for the painter input, so that the
expected values at every screen position will be known; this will allow
correctness of the painter output to be tested.  This test will not be
used for interpolated data, however, as interpolation is not used at the
left and right hand ends of spans.  Visual inspection will also be used to
check that data appears correct.

9.3 Clipping Module Testing
===========================

A test program which opens and moves windows around over the clipping
region will be written.  This test will rely on visual inspection of the
results.

10.0 Limitations And Constraints
################################

10.1 Full-Screen Applications Launched from Desktop
===================================================

Some applications (eg Sibelius 7) place an icon on the icon bar, and
when the user clicks on this icon, they take over the entire screen,
in the case of Sibelius 7, without changing screen mode.  It may be
the case that ARMovie will be unable to detect this occuring, so the
movie will paint over the screen.

11 Acceptance Tests
###################

11.1 Performance
================

Clearly, much of the work on multitasking Replay will introduce
performance penalties which have to be acknowledged.  In particular,
machines which lack VRAM suffer from seriously compromised ability to deal
with multitasking Replay.  This is particularly important in the education
sector where A7000 machines can be expected to be most common.  Most Risc
PC machines appear to have at least 1M byte of VRAM, so lack of VRAM is
probably not a problem in these cases.

Performance can be measured using the ARMovie$Frame system variable, set
by the player on completion of a movie.  This tells us how many frames
were dropped while the movie was played.  Our target should be 0 frames
dropped, although in some cases 0.5% frame drop might be acceptable.  This
measure is very quantative, however, and the best measure of 'acceptable'
performance is through human perception.  It might be worthwhile
increasing the complexity of the measurement of frame dropping - 3 frames
dropped at different times in a movie playback would probably not be
a serious problem, but 3 frames dropped in a row would look really bad.

It is important that when the system is fully loaded, it is still possible
for the user to interact with the system sufficiently to stop the movies
playing.

11.1.1 Single Movie Playback
----------------------------

Where the user is trying to use the machine at the same time, there are
two things that must be assessed - how useable the machine is, and how
well the movie responds to user activity.

11.1.1.1 Machine Useability

Clearly, there will be a reduction in performance of other tasks while the
movie is being played back.  The most important difference with Replay is
that it is a preemtive task (except for the fetcher, which operates
cooperatively).

11.1.1.2 Wimp Poll Latency Tolerance

As the fetcher operates from null events, it is clear that if wimp polling
stops for a length of time (for instance during a complex redraw in
another application) then the result will be that eventually, the
decompressor will suffer from data starvation, causing the movie to stop
being painted until data is once again available.  One potential problem
is that a long pause will cause the movie to then try to re-sync to the
timeline, causing much frantic decompressing of frames which will never be
painted, until the movie catches up.  With a large delay, this may take
some time.  This behaviour may sometimes be undesirable in a desktop
environment, because the decompressor will use up a large amount of CPU
time in order to catch up.

The tolerance of latency varies from movie to movie.  A test program which
occaisionally inserts a pause of known length into the wimp cycle will
allow us to easily quantify when latency is a problem.

11.1.2 Multiple Movie Playback
------------------------------

When playing multiple movies, the CPU resource is clearly shared between a
number of movies.  Clearly, if one movie interrupts during a paint
operation, there will be a visible tear.  It might be possible to get
around the tearing problem.  In general, however, movies will not see a
frame time quite so accurately as before thus there may be a slight
degradation in peformance.

As for what can be played on a given platform, it should be possible on
all VRAM machines to play two of the 12.5fps movies supplied with the RPC
simultaneously.  Lack of VRAM will reduce this capability - possibly to
the extent where multiple movies playing at once is not a viable option,
except where the movies are deliberately played slow.

11.2 Desktop Usability
======================

The way ARMovie behaves as a single tasking application is in many ways
not appropriate to the operation of a multitasking application, and its
behaviour must be modified so that it can interoperate reliably with other
software in the desktop enviornment.

In particular, the IRQ handling of Replay is antisocial and may cause
serious problems in desktop operation.  Prototype code has demonstrated
that keyboard events can go missing, for instance.  Previously, this would
not have been a noticeable problem.  However, under multitasking Replay,
keyboard events going missing would be classed as a serious problem if the
user was trying to use the machine for other purposes.

11.3 Memory Requirements
========================

Replay 3's memory requirements will be controlled by a number of factors
dependant on the movie playing, so it is not possible to define the memory
requirements precisely; the memory requirements will vary according to the
movie being played.

In general, a 4Mbyte machine should be able to play a single movie.  It is
not reasonable to expect Replay 3 to work well or at all on a 2M byte
machine, given the memory requirements of other parts of the system.

12 Organisation
###############

12.1 ARMovie Directory Structure
================================

The ARMovie directory structure is becoming more full of files, especially
with the advent of alien video codecs.  The 77 file limit, if we are not
careful, will soon become a problem here.  Thus, we should place more
items in subdirectories of the ARMovie directory.


13 Future Enhancements
######################

13.1 Full Audio Mixing
======================

It should be possible to extend the sound support in future to allow full
mixing of audio - with independant volume scaling - for multiple sound
streams.  The sound work will be designed to allow this enhancement to be
made relatively easily.

