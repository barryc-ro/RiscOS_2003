; > Module
; Source for NHTwitter Module

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 31-Oct-95  TMD  0.01          Started work
; 01-Nov-95  TMD  0.02		Version that adjusts for different linelengths
; 03-Nov-95  TMD  0.03		Fix screen corruption bugs
; 14-Nov-95  TMD  0.04		Re-read screen vars on Service_SwitchingOutputToSprite, as well as mode change
; 14-Nov-95  TMD  0.05		Add SWI call as well as star command
; 14-Nov-95  TMD  0.06		Fix incorrect restoration of r0 on errors in star command.
; 19-Jan-96  TMD  0.07		Better sanity checking on coordinates.
; 05-Aug-99  KJB  0.08		Added service call table.
; 16-Feb-00  KJB  0.09		Cunning stunt for modes with "1MB+half a line" LineLength - stick to the first
;				two copies to save thrashing the MMU's TLB. Gives a 15% speed up.

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

        	^       0, wp
TwitterOK	#	4	; 0 => can't anti-twitter in this mode
				; 1 => OK

OutVarTable	#	0
VScreenStart	#	4
VLineLen	#	4
VXEig		#	4
VYEig		#	4
VXWindLimit	#	4
VYWindLimit	#	4
VLog2BPC	#	4

VolatileCodeBlock #	0

Module_WorkspaceSize * (:INDEX: @) + (CodeBlockEnd - CodeBlockStart)

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die	    -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       NHSWI_Base
        &       Mod_SWIHandler-Module_BaseAddr
        &       Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "NHTwitter", 0

Mod_HelpStr
        =       "NHTwitter", TAB, "$Module_MajorVersion ($Module_Date)"
	= 0
        ALIGN

Mod_SWITable
	=	"NH", 0
	=	"AntiTwitter", 0
	=	0
	ALIGN

Mod_HC_Table
        Command NHAntiTwitter, 4, 4
        =       0

NHAntiTwitter_Help
	=	"*NHAntiTwitter performs an anti-twitter filter on part of the screen", 13
NHAntiTwitter_Syntax
        =       "Syntax: *NHAntiTwitter <x> <y> <w> <h>", 0
        ALIGN

	MACRO
	GetInt	$reg, $index, $t1, $t2
	LDR	$t1, [sp, $index]
	LDRB	$reg, [$t1, #1]!
	LDRB	$t2, [$t1, #1]!
	ORR	$reg, $reg, $t2, LSL #8
	LDRB	$t2, [$t1, #1]!
	ORR	$reg, $reg, $t2, LSL #16
	LDRB	$t2, [$t1, #1]!
	ORR	$reg, $reg, $t2, LSL #24
	MEND

Mod_Init Entry
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        LDR     r3, =Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

	ADR	r0, CodeBlockStart
	ADR	r1, VolatileCodeBlock
	LDR	r2, =CodeBlockEnd-CodeBlockStart
10
	LDR	r3, [r0], #4
	STR	r3, [r1], #4
	SUBS	r2, r2, #4
	BNE	%BT10

	BL	GetScreenVars
	EXIT

Mod_Die Entry
	LDR	wp, [r12]
	CLRV
	EXIT				; for now

	ASSERT	Service_ModeChange < Service_SwitchingOutputToSprite
Mod_ServiceTable
	DCD	0
	DCD	Mod_ServiceEntry - Module_BaseAddr
	DCD	Service_ModeChange
	DCD	Service_SwitchingOutputToSprite
	DCD	0

	DCD	Mod_ServiceTable - Module_BaseAddr
Mod_Service ROUT
	MOV	r0, r0
	TEQ	r1, #Service_ModeChange
	TEQNE	r1, #Service_SwitchingOutputToSprite
	MOVNES	pc, lr
Mod_ServiceEntry
	LDR	wp, [r12]

	TEQ	r1, #Service_SwitchingOutputToSprite
	BEQ	MyCallBack		; read vars directly, not on callback

; On Service_ModeChange, we have to re-read vars on a callback from the service, not directly
; on the service, so that the Interlace module has finished tinkering with the vars by then.


	Push	"r0,r1, lr"
	ADR	r0, MyCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"r0,r1, pc"

MyCallBack
	Push	"r0-r6, lr"
	BL	GetScreenVars
	Pull	"r0-r6, pc"

; **************************************************************************
;
;       Mod_SWIHandler - Main entry point for SWIs
;
; in:   r11 = SWI number
;

Mod_SWIHandler ROUT
        LDR     wp, [r12]
        CMP     r11, #1
        ADDCC   pc, pc, r11, LSL #2
        B       NoSuchSWI
        B       AntiTwitterSWI

NoSuchSWI
        ADRL    r0, NoSuchSWIError
        SETV
        MOV     pc, lr

NoSuchSWIError
        &       0
        =       "No such NHTwitter SWI", 0
        ALIGN

; **************************************************************************

GetScreenVars Entry
	ADR	r0, InVarTable
	ADR	r1, OutVarTable
	SWI	XOS_ReadVduVariables

	LDR	r0, VLog2BPC
	TEQ	r0, #4
	MOVNE	r0, #0
	BNE	%FT90			; not in 16bpp, so don't even try it

	LDR	r0, VLineLen
	BL	ConvertToImmediates	; out: r1, r2 = immediate fields

	TEQ	r0, #0			; if remainder after two immediates is non-zero
	MOVNE	r0, #0			; then we've failed
	BNE	%FT90

	ADR	r0, CodePatchTable
	ADR	r3, VolatileCodeBlock
10
	LDR	lr, [r0], #4
	CMP	lr, #-1
	BEQ	%FT80
	LDR	r4, [lr, r3]!
	MOV	r4, r4, LSR #12
	ORR	r4, r1, r4, LSL #12
	STR	r4, [lr]
	LDR	r4, [lr, #4]!
	MOV	r4, r4, LSR #12
	ORR	r4, r2, r4, LSL #12
	TEQ	r2, #&940		; is it &100000? if so, we're doing funny interlace
	BIC	r4, r4, #&01E00000	; clear opcode
	ORREQ	r4, r4, #&00200000	; make it EORcc Rx,Rx,#&100000 (saves MMU TLB thrash)
	ORRNE	r4, r4, #&00800000	; make it ADDcc Rx,Rx,#xx
	STR	r4, [lr]
	B	%BT10
80
	MOV	r0, #1			; indicate OK
90
	STR	r0, TwitterOK
	CLRV
	EXIT

CodePatchTable
	&	codepatch1a - CodeBlockStart
	&	codepatch1b - CodeBlockStart
	&	codepatch1c - CodeBlockStart
	&	codepatch2_0 - CodeBlockStart
	&	codepatch2_1 - CodeBlockStart
	&	codepatch2_2 - CodeBlockStart
	&	codepatch2_3 - CodeBlockStart
	&	codepatch2_4 - CodeBlockStart
	&	codepatch3_0 - CodeBlockStart
	&	codepatch3_1 - CodeBlockStart
	&	codepatch3_2 - CodeBlockStart
	&	codepatch3_3 - CodeBlockStart
	&	codepatch3_4 - CodeBlockStart
	&	-1

; in:	r0 = value to convert to two immediate values
; out:	r1, r2 are two 12-bit fields to substitute in bits 0..11
;	of instruction
;	r0 = remainder - should be zero

ConvertToImmediates Entry
	BL	GetImmediate		; out: r0 = remainder, r1 = bit field
	MOV	r2, r1
	BL	GetImmediate
	EXIT

GetImmediate Entry
	MOV	r1, #0			; number of rotates if zero
	MOVS	lr, r0			; if initial value zero
	EXIT	EQ			; there's nothing to do (imm field = 0)
	MOV	r1, #8
10
	TST	lr, #&C0000000		; if top two bits clear
	MOVEQ	lr, lr, LSL #2		; then shift up
	ADDEQ	r1, r1, #2		; and add two extra rotates
	BEQ	%BT10

	AND	r1, r1, #30		; ignore any wrap
	MOV	lr, lr, LSR #24		; move 8-bit field down to bottom
	BIC	r0, r0, lr, ROR r1	; knock out the field we just made
	ORR	r1, lr, r1, LSL #7	; merge 8-bit field with 4-bit rotate amount
	EXIT

NHAntiTwitter_Code Entry "r0-r3"
	LDR	wp, [r12]

; r0 -> command line

	MOV	r1, r0
	ADR	r0, Keys
	SUB	sp, sp, #128
	MOV	r2, sp
	MOV	r3, #128
	SWI	XOS_ReadArgs
	BVS	%FT90

	GetInt	r0, #0, r4,r5
	GetInt	r1, #4, r4,r5
	GetInt	r2, #8, r4,r5
	GetInt	r3, #12, r4,r5

	ADD	sp, sp, #128

	BL	AntiTwitterSWI
90
	STRVS	r0, [sp]
	EXIT

AntiTwitterSWI Entry "r0-r7"
	LDR	lr, TwitterOK
	TEQ	lr, #0
	BEQ	%FT99			; can't filter in this mode

	LDR	lr, VXWindLimit

	LDR	r1, VXEig
	MOVS	r4, r0, ASR r1		; r4 = XC >> XEIG
	MOVMI	r4, #0

	CMP	r4, lr
	BGT	%FT95			; left X off RHS of screen
;	BIC	r4, r4, #3		; r4 = X0

	ADD	r2, r2, r0		; r2 = WC + XC
	MOV	r5, r2, ASR r1
	SUBS	r5, r5, #1
	BMI	%FT95			; right X off LHS of screen

	CMP	r5, lr			; if right X off RHS of screen
	MOVGT	r5, lr			; move to RHS of screen
;	ORR	r5, r5, #3
	SUB	r5, r5, r4
	ADDS	r5, r5, #1		; r5 = W
	BLE	%FT95			; width <= 0

	LDR	r0, [sp, #1*4]		; r0 = YC
	LDR	r1, VYEig
	LDR	r2, [sp, #3*4]		; r2 = HC
	LDR	r3, VYWindLimit
	SUBS	r6, r3, r0, ASR r1
	BMI	%FT95			; if bot Y off top of screen
	CMP	r6, r3
	MOVGT	r6, r3			; r6 = Y0

	ADD	r0, r0, r2
	SUB	r7, r3, r0, ASR r1
	ADDS	r7, r7, #1		; top Y
	MOVMI	r7, #0			; r7 = Y1
	CMP	r7, r3			; if top Y off bot of screen
	BGT	%FT95
	SUBS	r6, r6, r7		; r6 = bottom-top (inclusive)
	BLT	%FT95			; top below bottom

	LDR	r0, VScreenStart
	ADD	r0, r0, r4, LSL #1
	LDR	r3, VLineLen
	MLA	r0, r3, r7, r0
	MOV	r1, r0
	ADD	r2, r6, #1		; r2 = H
	MOV	r3, r5

 [ {FALSE}
	DLINE	"About to call volatile code"
	DREG	r0, "Screen address = "
	DREG	r3, "Columns = "
	DREG	r2, "Rows = "
 |
	MOV	lr, pc
	ADR	pc, VolatileCodeBlock
 ]
	CLRV
	EXIT

95
	PullEnv
	ADR	r0, BadCoordsError
	SETV
	MOV	pc, lr

99
	PullEnv
	ADR	r0, TwitterFailError
	SETV
	MOV	pc, lr

BadCoordsError
	&	0
	=	"Invalid coordinates", 0
	ALIGN

TwitterFailError
	&	0
	=	"Can't perform anti-twitter in this mode", 0
	ALIGN

InVarTable
	&	VduExt_ScreenStart
	&	VduExt_LineLength
	&	VduExt_XEigFactor
	&	VduExt_YEigFactor
	&	VduExt_XWindLimit
	&	VduExt_YWindLimit
	&	VduExt_Log2BPC
	&	-1


Keys
	=	"/E,/E,/E,/E", 0
	ALIGN

lbpp		*	4
fl_mask1    	*	&7C1F03E0
fl_mask2	*	&03E07C1F

	MACRO
	FNdo2words $w00,$w10,$w01,$w11,$w02,$w12,$w0d,$w1d,$temp,$gm,$gm2,$entry
fl_entry$entry
	LDMIA	r0, {$w02,$w12}
	STMCSIA	r1, {$w0d,$w1d}
codepatch2_$entry
	ADDCS	r1, r1, #0			; addcs dstlen
	ADDCS	r1, r1, #0
	SUBS	r2, r2, #1
codepatch3_$entry
	ADDNE	r0, r0, #0			; addne srclen
	ADDNE	r0, r0, #0			; (advance src ptr except on last time but one - don't care on last time)

	AND	$w0d, $w00, $gm			; B_R_G_ word 0 line 0
	AND	$temp, $w02, $gm		; B_R_G_ word 0 line 2
	ADD	$w0d, $w0d, $temp		; B_R_G_ word 0 line 0+2
	AND	$temp, $w01, $gm		; B_R_G_ word 0 line 1
	ADD	$w0d, $temp, $w0d, LSR #1	; B_R_G_ word 0 line 0/2 + 1 + 2/2
	ORR	$w0d, $gm2, $w0d, LSR #1	; BFRFGF word 0 line 0/4 + 1/2 + 2/4

	BIC	$w00, $w00, $gm			; _G_B_R word 0 line 0
	BIC	$temp, $w02, $gm		; _G_B_R word 0 line 2
	ADD	$w00, $w00, $temp		; _G_B_R word 0 line 0+2
	BIC	$temp, $w01, $gm		; _G_B_R word 0 line 1
	ADD	$w00, $temp, $w00, LSR #1	; _G_B_R word 0 line 0/2 + 1 + 2/2
	ORR 	$w00, $gm, $w00, LSR #1		; FGFBFR word 0 line 0/4 + 1/2 + 2/4

	AND	$w0d, $w0d, $w00		; BGRBGR word 0 line 0/4 + 1/2 + 2/4

	AND	$w1d, $w10, $gm			; B_R_G_ word 1 line 0
	AND	$temp, $w12, $gm		; B_R_G_ word 1 line 2
	ADD	$w1d, $w1d, $temp		; B_R_G_ word 1 line 0+2
	AND	$temp, $w11, $gm		; B_R_G_ word 1 line 1
	ADD	$w1d, $temp, $w1d, LSR #1	; B_R_G_ word 1 line 0/2 + 1 + 2/2
	ORR	$w1d, $gm2, $w1d, LSR #1	; BFRFGF word 1 line 0/4 + 1/2 + 2/4

	BIC	$w10, $w10, $gm			; _G_B_R word 1 line 0
	BIC	$temp, $w12, $gm		; _G_B_R word 1 line 2
	ADD	$w10, $w10, $temp		; _G_B_R word 1 line 0+2
	BIC	$temp, $w11, $gm		; _G_B_R word 1 line 1
	ADD	$w10, $temp, $w10, LSR #1	; _G_B_R word 1 line 0/2 + 1 + 2/2
	ORR	$w10, $gm, $w10, LSR #1		; FGFBFR word 1 line 0/4 + 1/2 + 2/4

	AND	$w1d, $w1d, $w10		; BGRBGR word 1 line 0/4 + 1/2 + 2/4

	BCC	exitcolumn
	MEND

	MACRO
	FNdo1word $w00,$w01,$w02,$w0d,$temp,$gm,$gm2,$entry
fl_entry$entry
	LDR	$w02, [r0]
	STRCS	$w0d, [r1]
codepatch2_$entry
	ADDCS	r1, r1, #0			; addcs dstlen
	ADDCS	r1, r1, #0
	SUBS	r2, r2, #1
codepatch3_$entry
	ADDNE	r0, r0, #0			; addne srclen
	ADDNE	r0, r0, #0			; (advance src ptr except on last time but one - don't care on last time)

	AND	$w0d, $w00, $gm			; B_R_G_ word 0 line 0
	AND	$temp, $w02, $gm		; B_R_G_ word 0 line 2
	ADD	$w0d, $w0d, $temp		; B_R_G_ word 0 line 0+2
	AND	$temp, $w01, $gm		; B_R_G_ word 0 line 1
	ADD	$w0d, $temp, $w0d, LSR #1	; B_R_G_ word 0 line 0/2 + 1 + 2/2
	ORR	$w0d, $gm2, $w0d, LSR #1	; BFRFGF word 0 line 0/4 + 1/2 + 2/4

	BIC	$w00, $w00, $gm			; _G_B_R word 0 line 0
	BIC	$temp, $w02, $gm		; _G_B_R word 0 line 2
	ADD	$w00, $w00, $temp		; _G_B_R word 0 line 0+2
	BIC	$temp, $w01, $gm		; _G_B_R word 0 line 1
	ADD	$w00, $temp, $w00, LSR #1	; _G_B_R word 0 line 0/2 + 1 + 2/2
	ORR 	$w00, $gm, $w00, LSR #1		; FGFBFR word 0 line 0/4 + 1/2 + 2/4

	AND	$w0d, $w0d, $w00		; BGRBGR word 0 line 0/4 + 1/2 + 2/4
	MEND

	MACRO
	FNdohalfword $w00,$w01,$w02,$w0d,$temp,$gm,$gm2,$entry
fl_entry$entry
	LDR	$w02, [r0]			; NB may not be word-aligned
	STRCSB	$w0d, [r1]
	MOVCS	$w0d, $w0d, LSR #8
	STRCSB	$w0d, [r1, #1]
codepatch2_$entry
	ADDCS	r1, r1, #0			; addcs dstlen
	ADDCS	r1, r1, #0
	SUBS	r2, r2, #1
codepatch3_$entry
	ADDNE	r0, r0, #0			; addne srclen
	ADDNE	r0, r0, #0			; (advance src ptr except on last time but one - don't care on last time)

	AND	$w0d, $w00, $gm			; B_R_G_ word 0 line 0
	AND	$temp, $w02, $gm		; B_R_G_ word 0 line 2
	ADD	$w0d, $w0d, $temp		; B_R_G_ word 0 line 0+2
	AND	$temp, $w01, $gm		; B_R_G_ word 0 line 1
	ADD	$w0d, $temp, $w0d, LSR #1	; B_R_G_ word 0 line 0/2 + 1 + 2/2
	ORR	$w0d, $gm2, $w0d, LSR #1	; BFRFGF word 0 line 0/4 + 1/2 + 2/4

	BIC	$w00, $w00, $gm			; _G_B_R word 0 line 0
	BIC	$temp, $w02, $gm		; _G_B_R word 0 line 2
	ADD	$w00, $w00, $temp		; _G_B_R word 0 line 0+2
	BIC	$temp, $w01, $gm		; _G_B_R word 0 line 1
	ADD	$w00, $temp, $w00, LSR #1	; _G_B_R word 0 line 0/2 + 1 + 2/2
	ORR 	$w00, $gm, $w00, LSR #1		; FGFBFR word 0 line 0/4 + 1/2 + 2/4

	AND	$w0d, $w0d, $w00		; BGRBGR word 0 line 0/4 + 1/2 + 2/4
	MEND

CodeBlockStart

; in -  r0 -> src bitmap
;       r1 -> dst bitmap
;       r2 = number of src lines
;	r3 = number of src columns

AntiTwitter Entry "r8-r12"
	LDR	r12, flmask			; inverted mask
	MOV	r5, r3, LSL #(lbpp-3)
	SUBS	r2, r2, #1
	EXIT	LS			; < 2 lines, so nothing to do

	TST	r0, #2
	BLNE	DoHalfWordColumn

	MOV	r14, r12, ROR #16		; get normal mask
fl_startofcolumn
	SUBS	r5, r5, #8
	BCC	DoOddWord
	STMFD	r13!, {r0-r2,r5}
	LDMIA	r0, {r3,r4}
	MOV	r5, r3
	MOV	r6, r4
codepatch1a
	ADD	r0, r0, #0		; add srclen
	ADD	r0, r0, #0
	CMP	r0, #-1			; clear carry, so store doesn't happen 1st time thru
fl_columnloop
	FNdo2words r3,r4,r5,r6,r7,r8,r9,r10,r11,r14,r12,0
	FNdo2words r5,r6,r7,r8,r3,r4,r9,r10,r11,r14,r12,1
	FNdo2words r7,r8,r3,r4,r5,r6,r9,r10,r11,r14,r12,2
	B	fl_columnloop

exitcolumn
	STMIA	r1, {r9,r10}
	LDMFD	r13!, {r0-r2,r5}
	ADD	r0, r0, #8
	ADD	r1, r1, #8
	B	fl_startofcolumn

DoOddWord
	ADD	r5, r5, #8

	TST	r5, #4
	BLNE	DoOneWordColumn
	TST	r5, #2
	BLNE	DoHalfWordColumn

	EXIT

flmask	&	fl_mask2

DoHalfWordColumn
	STMFD	r13!, {r0-r2,r5}
	MOV	r4, r12, ROR #16
	LDR	r3, [r0]
	MOV	r5, r3
codepatch1b
	ADD	r0, r0, #0		; add srclen
	ADD	r0, r0, #0
	CMP	r0, #-1			; clear carry, so store doesn't happen 1st time thru
fl_halfcolumnloop
	FNdohalfword r3,r5,r7,r9,r11,r4,r12,3
	MOV	r3, r5			; shuffle manually
	MOV	r5, r7
	BCS	fl_halfcolumnloop
	STRB	r9, [r1]
	MOV	r9, r9, LSR #8
	STRB	r9, [r1, #1]
	LDMFD	r13!, {r0-r2,r5}
	ADD	r0, r0, #2
	ADD	r1, r1, #2
	SUB	r5, r5, #2
	MOV	pc, lr

DoOneWordColumn
	STMFD	r13!, {r0-r2,r5}
	MOV	r4, r12, ROR #16
	LDR	r3, [r0]
	MOV	r5, r3
codepatch1c
	ADD	r0, r0, #0		; add srclen
	ADD	r0, r0, #0
	CMP	r0, #-1			; clear carry, so store doesn't happen 1st time thru
fl_onecolumnloop
	FNdo1word r3,r5,r7,r9,r11,r4,r12,4
	MOV	r3, r5			; shuffle manually
	MOV	r5, r7
	BCS	fl_onecolumnloop
	STR	r9, [r1]
	LDMFD	r13!, {r0-r2,r5}
	ADD	r0, r0, #4
	ADD	r1, r1, #4
	SUB	r5, r5, #4
	MOV	pc, lr


CodeBlockEnd
;	BIN	"o.filter"

;	InsertDebugRoutines

        END
