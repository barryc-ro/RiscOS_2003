; > Common

; Interlace module
; Provides 768 x 576 and 768 x 480 and 720 x 576 interlaced by multi-section mapping
; Combined source for all hardware variants and 50/51/55 variants
; Now has all modes in one binary
; This is the variant that does it by monitor description files

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 17-Dec-92  TMD  0.01          Started, from line-doubling sources
; 13-Dec-93  TMD  0.02          Converted for 768 x 576 (multi-section)
; 16-Dec-93  TMD  0.03          Converted for 16bpp
; 17-Mar-94  TMD  0.04          Now (hopefully) never gets into wrong interlace phase
; 12-Apr-94  TMD  0.05          Now copes if interlace is configured on
; 22-Apr-94  TMD  0.06          Moved picture 8 pixels to right
; 03-May-94  TMD  0.07          Version for no VRAM that uses 948K
; 02-Jun-94  TMD  0.08          Version at 15MHz pixel rate
; 21-Jun-94  TMD  0.09          Added InterlaceSwap command
; 01-Jul-94  JER  0.10          Test rebuild. No functional changes.
; 01-Jul-94  MT   0.11          Now reads physical interlace state from MPEG card
; 14-Sep-94  TMD  0.12          Grand unification for all h/w variants and 50/55 variants
; 19-Oct-94  TMD  0.13          (Conditionally) use Timer1 to generate IRQ part way down screen
;                                so we're immune from awful ATM/ShareFS interrupt latency.
; 25-Oct-94  TMD  0.14          Added 720 x 576 at 13.5MHz version (mode 51)
; 25-Oct-94  TMD  0.15          Separated out 'w' (ie 'v' using Timer1) variant.
; 01-Feb-95  TMD  0.16          Made it update OS_Byte(&B0) value (decrementing vsync counter)
;                                so bottom bit = 0 for top field, 1 for bottom field.
; 17-Feb-95  TMD  0.17		Change product-type matching code for recognition of podule:
;				 No longer match &0000, but do match &00F9.
; 21-Feb-95  TMD  0.18		Check IOMD type to determine which address to use for VSYNC device
;				 workspace and code.
; 21-Feb-95  TMD  0.19		Now a single binary provides modes 50,51 and 55 (still different
;				 binaries for different hardware variants)
; 23-Feb-95  TMD  0.20		Extra TAB in help string, now name is shorter.
; 03-May-95  TMD  0.21		Update to recognise ProdType_STB2_MPEG1.
; 06-Jun-95  TMD  0.22		Update to recognise ProdType_STB2_MPEG0 (ie Roadster).
; 12-Jun-95  TMD  0.23		Version that uses page-mapped areas rather than section-mapped.
; 22-Jun-95  TMD  0.24		Fix hardware scroll problem.
; 22-Jun-95  TMD  0.25		Add *HorizOffset command.
; 23-Jun-95  TMD  0.26		(Conditionally) use 1MB of logical space per field (rather than
;				 512K), so can do 768 x 576 x 32bpp (on VRAM machine)
; 26-Jun-95  TMD  0.27		Prevent it releasing vectors on Service_Reset, except on soft resets
; 09-Aug-95  TMD  0.28		Modified mode 56 to be true-256 colour.
; 22-Aug-95  TMD  0.29		Added mode 57 (PAL version of mode 56).
; 15-Sep-95  TMD  0.30		Change check to determine address of VSyncDevice vector to test for
;				 versions of the OS greater than or equal to 3.60, rather than using
;				 presence of ARM7500.
; 21-Sep-95  TMD  0.31		New mode 55 with better centering.
; 10-Oct-95  TMD  0.32		Add option to check system variable MPEG$PoduleNumber for override
;				 on podule number.
; 31-Oct-95  TMD  0.33		Add 58 + 59 (16 bit versions of 56,57)
; 09-Nov-95  TMD  0.34		Fixed incorrect header with wrong definition of STB2_MPEG0.
; 24-Nov-95  TMD  0.35		Put Macrovision modes in ourself for now.
; 27-Nov-95  TMD  0.36		Added modes 60 and 61 (640 x 440 x 8 or 16 bpp) for desktop use on
;				 NTSC TV.
; 27-Nov-95  TMD  0.37		Put in NTSC Macrovision modes too.
; 29-Nov-95  TMD  0.38		Changed NTSC desktop modes 60 and 61 to 640 x 400.
; 06-Dec-95  TMD  0.39		Modified timings for Macrovision modes.
; 18-Jan-96  JRH  0.40		If PhaseDetectBitInCLines is set, looks for PhaseDetectBit in
;                                the IOMD 8bit I/O CLines.
; 22-Jan-96  SMC  0.41          Modified Makefile to install ROM component properly.
; 08-Feb-96  JRH  0.42		Fixed up vsync entry in kernel device table for OS versions > 3.61.
;				Sets bit 8 in ModeFlags (mode is interlaced) for all modes.
; 12-Apr-96  TMD  0.43		Started on work to support interlaced modes in monitor definition files.
; 02-May-96  TMD  0.44		Fix cursor flashing problem on switch output back to screen.
; 09-May-96  TMD  0.45		Try to do mode numbers as well, but comment out cos doesn't work yet.
; 14-May-96  TMD  0.46		Set DisplayModeFlags to the same as ModeFlags, so kernel can spot interlaced modes and do
;				 an interlaced pointer.
; 18-Jul-96  TMD  0.47		Add variant for MPEG 2 card on STB 1.
; 11-Sep-96  TMD  0.48		Also check for STB2_MPEG2 product type on MPEG 2 variant.
; 22-Jun-98  TMD  0.49		Check VectorsClaimed on Service_ValidateAddress.
; 05-Aug-99  KJB  0.53		Added service call table.
; 20-Sep-99  KJB  0.55          Revised Kernel interactions - kernel now initially sets
;                               interlaced mode flag, and we pick up on it. Saves Service_ModeExtension
;                               hackery. Also rejigs phase on Service_ScreenRestored, in case the
;                               syncs got shut down while screen blanked.
; 10-Dec-99  KJB  0.57          Removed Service_ScreenRestored code - unnecessary resyncs were happening.
;                               Instead, hooked on to PaletteV so it can monitor real blanked -> unblanked
;                               transitions. Also prevents any interaction with fancy screen blankers.
;                               Added Interlq variant for STB-400 (untested).
; 13-Dec-99  KJB  0.58          0.57 was doing odd things on Service_ScreenRestored, as it hadn't been
;                               totally removed from the service entry code.
; 11-May-00  KJB  0.60          Removed the need to do strange things with OS_ClaimDeviceVector and intimate
;                               knowledge of Kernel workspace.
;                               32-bit compatible.
;                               Service call fast rejection code was wrong.
; 28-Jun-00  BJGA 0.61          Added support for high-resolution teletext.
;                               Now intercepts the dynamic area handler entries for the screen dynamic area,
;                               to stop the kernel (a) copying screen memory around and (b) resetting
;                               DisplayStart, DriverBankAddr and DisplayBankAddr. This works for all kernels
;                               that support OS_ReadSysInfo 6, and also STB-3 (as a special case).
;

                GBLL    FixHWScroll
FixHWScroll     SETL    {TRUE}         ; does work now!

		GBLL	Use1MBPerField
Use1MBPerField	SETL	{TRUE}		; use 1MB per field, not 1MB per frame

		GBLL	TryToDoModeNumbers
TryToDoModeNumbers SETL {FALSE}		; doesn't work yet so comment out

                GBLL    UseVSyncEvent
UseVSyncEvent   SETL    {TRUE}          ; use VSync event instead of hacking Vsync device

; when initially turning on interlace, use a callback to wait until not in vsync

		GBLL	UseInitialCallBack
UseInitialCallBack SETL (PhaseDetectBit = 0) :LAND: {FALSE}

                GBLL    ScreenBanks
ScreenBanks     SETL    {TRUE}

        AREA    |Interlace$$Code|, CODE, READONLY, PIC

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

; Bits in VduStatus

Windowing *     1 :SHL: 3
Shadowing *     1 :SHL: 4

 [ UseTimer1
Timer1LatchValue *      10000   ; 5ms, so well outside vsync, for both 50Hz and 60Hz modes
 ]

; Offsets from base of OSByte variables

CFSTime		*	&B0

	MACRO
	DefineWS

        ^       0, wp

VectorsClaimed  #       4
DummyScreenStart #      4
Phase           #       4
 [ :LNOT: UseVSyncEvent
OldDeviceWS     #       4
OldDeviceCode   #       4
 ]
                #       3
OSWord16Block   #       5

OSByteVarBase	#	4
OtherStuffPtr	#	4
PageTablePhysAddr #	4		; physical address of page to use for L2PT for screen area
PageTablePPN	#	4		; physical page number of same page
PageTableLogAddr #	4		; logical address of same
ScreenPhysAddr	#	4		; physical address of screen
DynAreaNumber	#	4		; area number of our area
ShrinkOK	#	4		; NZ => shrink OK
FindModeStructure #	12		; 3 words of crap
FindModeOtherOffset #	4		; offset to OtherStuff
FindModeOtherStuff #	OtherIndex_RecordSize ; static OtherStuff created from mode parameters

 [ ScreenBanks
PhysicalDriverOffset    #       4       ; effective offset in physical space of driver base from start of screen memory
FrameDisplayOffset      #       4       ; offset of displayed frame from base of screen memory (discounting interlace)
FieldDisplayOffset      #       4       ; current component of display offset due to interlace
 ]

 [ PhaseDetectBit <> 0
LastPhase               #       1       ; for field-to-field checks
spare                   #       3       ; (preserve data alignment)
FieldCount              #       4       ; how many fields since last mode change/error check
PhaseErrors             #       4       ; how many errors over that time
Podule_Base             #       4       ; address of base of podule
Podule_ControlStatus    #       4       ; address of podule control/status register
PoduleHeaderBuffer      #       16      ; used to read podule headers
 ]

 [ UseInitialCallBack
CallBackRequested	#	4	; NZ => callback requested
 ]

 [ MakeCFSCountPhase
CFSTimeAddr	#	4
 ]

 [ FixGrowShrink
DANodePointer   #       4               ; where the dynamic area node is stored, or 0 if we don't know where
DAHandlerKernelWs #     4               ; the workspace pointer of the kernel routine
DAHandlerKernelRout #   4               ; the address of the DA handler in the kernel, so we can restore it on exit
DAHandlerIntercept #    4               ; 1 if we need to intercept for this mode, 0 otherwise
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

Module_WorkspaceSize * :INDEX: @
	MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       0 ; SWI chunk
        &       0 ; Mod_SWIHandler-Module_BaseAddr
        &       0 ; Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry
        &       0                               ; no messages file
        &       Mod_Flags   -Module_BaseAddr

Mod_Title
        =       "Interlace", 0

Mod_HelpStr
        =       "Interlace", TAB, "$Module_HelpVersion", 0
        ALIGN

Mod_HC_Table
        Command InterlaceSwap,  0, 0
 [ PhaseDetectBit <> 0
        Command InterlaceLog,   0, 0
 ]
        =       0                       ; terminate table

InterlaceSwap_Help
        =       "*InterlaceSwap swaps the interlace phase.", CR
InterlaceSwap_Syntax
        =       "Syntax: *InterlaceSwap", 0
        ALIGN
 [ PhaseDetectBit <> 0
InterlaceLog_Help
        =       "*InterlaceLog reports and resets phase error counts.", CR
InterlaceLog_Syntax
        =       "Syntax: *InterlaceLog", 0
        ALIGN
 ]

Mod_Flags
        &       ModuleFlag_32bit

 [ TryToDoModeNumbers
	OutputModeInfo
 |
	GBLA	maxyres
maxyres SETA	1280
 ]
	DefineWS

; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry "r7, r8"
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, VectorsClaimed
 [ UseInitialCallBack
	STR	r0, CallBackRequested
 ]

 [ PhaseDetectBit <> 0
        STR     r0, FieldCount
        STR     r0, PhaseErrors
        MOV     r0, #&FF
        STRB    r0, LastPhase           ; so it won't compare equal, no error
 ]

        MOV     r0, #2
        STRB    r0, OSWord16Block +0    ; switch display only

        LDR     r0, =DummyScreen
        STR     r0, DummyScreenStart

	MOV	r0, #&A6		; read base of OS_Byte variables
	MOV	r1, #0
	MOV	r2, #&FF
	SWI	XOS_Byte
	ORR	r1, r1, r2, LSL #8	; merge low and high bytes
	STR	r1, OSByteVarBase	; save address for future use

 [ PhaseDetectBit <> 0
; JER set up address of MPEG podule to read frame interlace bit.
   [ PhaseDetectOnPodule
        BL      FindPoduleNumber
	EXIT	VS

        MOV     r0, #Podule_ReadInfo_EASILogical
        ADR     r1, Podule_Base
        MOV     r2, #4
        SWI     XPodule_ReadInfo
     [ CheckPoduleVariable
	MOVVS	r0, r3, LSL #24		; if get error, then do it by hand, as it might be a
	ORRVS	r0, r0, #&88000000	; podule without an EPROM
	STRVS	r0, Podule_Base
     |
        EXIT    VS
     ]
        LDR     r0, Podule_Base
        ADD     r1, r0, #PhaseDetectOffset
   |
	LDR	r1, =PhaseDetectOffset ; bit not on podule, it's at an absolute address (probably IOMD CLINES)
   ]

        STR     r1, Podule_ControlStatus
 ]

; now set up page-mapped area

	LDR	r1, =&05000000
	BL	LogToPhys
	EXIT	VS
	STR	r2, ScreenPhysAddr

 [ UseOSMemory12
 ! 0, "Using OS_Memory 12 (requires Kernel 5.36 or later)"
 |

	LDR	r1, =L1PT
	BL	LogToPhys
	EXIT	VS
	MOV	r4, r2, LSR #12		; save physical memory page index for L1PT

	MOV	r0, #6			; read size of physical memory table
	SWI	XOS_Memory
	EXIT	VS

	MOV	r3, r1
	MOV	r0, #ModHandReason_Claim
	SWI	XOS_Module
	EXIT	VS

	MOV	r0, #7			; read table
	MOV	r1, r2
	SWI	XOS_Memory
	BVS	%FT90			; exit freeing block

; now find free page

10
	CMP	r4, r3, LSL #1		; have we gone off the end
	BCS	%FT85			; [couldn't find free page]
	LDRB	r5, [r2, r4, LSR #1]
	TST	r4, #1
	MOVNE	r5, r5, LSR #4
	ANDEQ	r5, r5, #15
	TEQ	r5, #1			; is it free DRAM?
	ADDNE	r4, r4, #1
	BNE	%BT10

	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module		; free the table memory
	EXIT	VS

	MOV	r4, r4, LSL #12		; physical address of page to take
	STR	r4, PageTablePhysAddr

	Push	"r0,r1,r4"		; create page block with phys addr at offset 8
	LDR	r0, =0 + (1 :SHL: 10) + (1 :SHL: 11) ; phys addr to ppn
	MOV	r1, sp
	MOV	r2, #1
	SWI	XOS_Memory
	STRVS	r0, [sp]
	Pull	"r0,r1,r4"
	EXIT	VS

	STR	r0, PageTablePPN
  ]

	MOV	r0, #0			; create dynamic area
	STR	r0, ShrinkOK		; can't shrink it at moment
	MOV	r1, #-1			; area number - RISC OS to allocate
	MOV	r2, #4096		; initial size - 1 page (never changes)
	MOV	r3, #-1			; base address - RISC OS to allocate
	MOV	r4, #1 :SHL: 8		; flags (need particular physical pages)
	MOV	r5, #4096		; maximum size (only 1 page needed)
	ADR	r6, DynAreaHandler
	MOV	r7, wp
	ADR	r8, DynAreaTitle
	SWI	XOS_DynamicArea
	EXIT	VS

	STR	r1, DynAreaNumber	; save number so we can remove area later
	STR	r3, PageTableLogAddr	; save log address for later poking
  [ UseOSMemory12
        MOV     r1, r3
        BL      LogToPhys
        EXIT    VS
        STR     r2, PageTablePhysAddr  ; store the physical address of the page
  ]

 [ FixGrowShrink
        MOV     r0, #0                  ; don't actually intercept the handler
        STR     r0, DAHandlerIntercept  ; until we change into an interlaced mode

        MOV     r0, #6                  ; read kernel values
        MOV     r1, #0                  ; just one value required
        MOV     r2, #7                  ; DAList required
        SWI     XOS_ReadSysInfo
        BVC     %FT30                   ; nice new kernel has returned DAList in r2

        MOV     r0, #ModHandReason_EnumerateROM_ModulesWithInfo
        MOV     r1, #0                  ; find 1st ROM module (UtilityModule)
        MOV     r2, #-1                 ; system ROM
        SWI     XOS_Module
        LDRVC   r0, =&47100             ; STB-3 OS kernel version is 4.71
        TEQVC   r6, r0                  ; preserves V
        MOVEQ   r2, #&170               ; the address of DAList in STB-3
        MOVNE   r2, #0                  ; don't currently know the address for anything else
        MOVVS   r2, #0                  ; if error from OS_Module, don't intercept DA handler
        TEQ     r2, #0
        BEQ     %FT40
30
        LDR     r2, [r2, #DANode_Link]
        TEQ     r2, #0                  ; have we got to the end yet? (shouldn't happen)
        BEQ     %FT40
        LDR     r3, [r2, #DANode_Number]
        TEQ     r3, #2                  ; screen DA?
        BNE     %BT30

        ADD     r3, r2, #DANode_Workspace
        ADR     r4, DAHandlerKernelWs
        ASSERT  DANode_Workspace = DANode_Handler - 4
        ASSERT  :INDEX: DAHandlerKernelWs = :INDEX: DAHandlerKernelRout - 4
        LDMIA   r3, {r0, r1}
        STMIA   r4, {r0, r1}
        ADR     r14, ScreenDynAreaHandler
        STMIA   r3, {r12, r14}          ; claim the handler for ourselves
40
        STR     r2, DANodePointer
 ]

        CLRV
        EXIT

; couldn't allocate page tables

85
	ADR	r0, Level2AllocateFailError

; free block and exit returning error

90
	Push	"r0"
	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module
	Pull	"r0"
	SETV
	EXIT

Level2AllocateFailError
	&	1
	=	"Couldn't allocate page table memory for interlaced mode", 0

DynAreaTitle
	=	"Interlace support", 0
	ALIGN

; Convert logical to physical address
; in:	r1 = log address
; out:	r2 = phys address

LogToPhys Entry "r0,r1"
	Push	"r0-r2"		; create page block on stack with log address at offset 4
	LDR	r0, =0 + (1 :SHL: 9) + (1 :SHL: 13) ; log address to phys address
	MOV	r1, sp
	MOV	r2, #1
	SWI	XOS_Memory
	STRVS	r0, [sp, #3*4]
	Pull	"r0-r2"
	EXIT

DynAreaHandler ROUT
        CMP     r0, #1
        BHI     %FT30		; check shrink
        MOVEQ   pc, r14		; post grow

; Pre-grow

        TEQ     r4, #0          ; only allow grow if zero size to start
        BNE     CantGrowError   ; must be NE
        STMFD   r13!, {r0-r3,lr}
  [ UseOSMemory12
        MOV     r0, #12         ; RecommendPage reason code
        MOV     r1, #4096       ; want 4096 bytes
        MOV     r2, #12         ; log2 of required alignment
        SWI     XOS_Memory      ; Answer comes back in R3
        LDMVSFD sp!, {r0-r3,pc}
        STR     r3, PageTablePPN
        LDMIB   r13, {r1-r2}    ; Restore R1 and R2
  |
        LDR     r3, PageTablePPN
  ]
10
        STR     r3, [r1], #12
        ADD     r3, r3, #1
        SUBS    r2, r2, #1
        BNE     %BT10
        ; V must be clear (SUBS above ensures that it is)
        LDMFD   r13!, {r0-r3,pc}

30
        STMFD   r13!, {r14}
        LDR     r14, ShrinkOK
        CMP     r14, #0         ; NB clears V
        LDMFD   r13!, {r14}
        MOVNE   pc, r14         ; NE => preshrink or postshrink OK
        ADREQ   r0, CantShrinkErrorBlock
CantGrowError
        ADRNE   r0, CantGrowErrorBlock
        SETV
        MOV     pc, r14

CantGrowErrorBlock
        &	1
	=	"Can't grow this area any more", 0
        ALIGN

CantShrinkErrorBlock
        &	1
	=	"Can't shrink this area", 0
        ALIGN

 [ FixGrowShrink
ScreenDynAreaHandler ROUT
        Push    "r14"
        LDR     r14, DAHandlerIntercept
        TEQ     r14, #0
        BEQ     ScreenDynArea_PassToKernel
        CMP     r0, #4
        ADDCC   pc, pc, r0, LSL #2
        Pull    "pc"            ; would generate an error if they tried it in a non-interlaced mode
        B       ScreenDynArea_PreGrow
        B       ScreenDynArea_PostGrow
        B       ScreenDynArea_PreShrink
        B       ScreenDynArea_PostShrink

;Pregrow entry parameters
; R0 = 0 (reason code)
; R1 -> page block (entries set to -1)
; R2 = number of entries in page block == number of pages area is growing by
; R3 = number of bytes area is growing by (r2 * pagesize)
; R4 = current size (bytes)
; R5 = page size
;
; exit with V clear, all preserved

ScreenDynArea_PreGrow
        Push    "r0-r2,r4"
        SWI     XOS_RemoveCursors

        ADRL    r0, PageShifts-1
        LDRB    r0, [r0, r5, LSR #12]           ; grab log2Pagesize for shifting
        MOV     r4, r4, LSR r0                  ; change present size into number of pages
                                                ; since page numbers are 0 to n-1 thus n
                                                ; is the first page number we want to insist on
10
        STR     r4, [r1], #12                   ; store physical page number and increment to next
        SUBS    r2, r2, #1                      ; one less to do
        ADDNE   r4, r4, #1                      ; next physical page number
        BNE     %BT10                           ; continue until all pages done

        VDWS    WsPtr
        LDR     r14, [WsPtr, #TotalScreenSize]
        ADD     r14, r14, R3
        STR     r14, [WsPtr, #TotalScreenSize]

 [ ScreenBanks
        LDR     r14, [WsPtr, #VduStatus]
        BIC     r14, r14, #Shadowing            ; for compatibility, unset Shadowing
        STR     r14, [WsPtr, #VduStatus]
 ]

        CLRV                                    ; ok, so I'm paranoid...
        Pull    "r0-r2,r4,pc"

PageShifts
        =       12, 13, 0, 14           ; 1 2 3 4
        =       0,  0,  0, 15           ; 5 6 7 8

;PreShrink Entry parameters
;R0 = 2 (reason code)
;R3 = number of bytes area is shrinking by
;R4 = current size of area (bytes)
;R5 = page size

ScreenDynArea_PreShrink
        Push    "r1-r2,r5,r12"
        VDWS    WsPtr

        ;need to check whether the proposed shrink still leaves enough for
        ;the current amount needed by the vdu drivers, if it doesn't we
        ;reduce R3 to be the most we can spare (in whole pages)

        SUB     R2, R5, #1                      ;make a page mask

        LDR     R5, [WsPtr, #ScreenSize]        ;get current minimum size

        SUB     R1, R4, R5                      ;R1 = maximum shrink (current - screensize)
        CMP     R3, R1                          ;if requested shrink > max...
        MOVHI   R3, R1                          ;...then limit it, and...
        BICS    R3, R3, R2                      ;...round down to multiple of page size

        LDR     R1, [WsPtr, #TotalScreenSize]
        SUB     R1, R1, R3
        STR     R1, [WsPtr, #TotalScreenSize]

        SWINE   XOS_RemoveCursors

 [ ScreenBanks
        LDR     r14, [WsPtr, #VduStatus]
        BIC     r14, r14, #Shadowing            ; for compatibility, unset Shadowing
        STR     r14, [WsPtr, #VduStatus]

        LDR     WsPtr, [sp, #3*4]               ; retrieve our own wsptr from stack
        SUB     r5, r1, r5                      ; max offset we can allow for either driver or display bank
        LDR     r1, PhysicalDriverOffset
        CMP     r1, r5
        MOVHI   r0, #112
        MOVHI   r1, #1
        SWIHI   XOS_Byte                        ; reset to driver bank 1 if necessary
        LDR     r1, FrameDisplayOffset
        CMP     r1, r5
        MOVHI   r0, #113
        MOVHI   r1, #1
        SWIHI   XOS_Byte                        ; reset to display bank 1 if necessary

        MOV     r0, #2                          ; restore value of r0 to what it was on entry
 ]
        CLRV
        Pull    "r1-r2,r5,r12,pc"

ScreenDynArea_PostGrow
ScreenDynArea_PostShrink
        SWI     XOS_RestoreCursors
        CLRV
        Pull    "pc"

ScreenDynArea_PassToKernel
        Push    "r6"
        ADR     r14, DAHandlerKernelWs
        ASSERT  :INDEX: DAHandlerKernelWs = :INDEX: DAHandlerKernelRout - 4
        LDR     r12, [r14]
        LDR     r6, [r14, #4]   ; wrong way round to do an LDM
        MOV     r14, pc
        MOV     pc, r6          ; jump into the kernel
        Pull    "r6,pc"
 ]

 [ PhaseDetectBit <> 0
  [ PhaseDetectOnPodule
; **************************************************************************
;
;       FindPoduleNumber
;
; in:   -
;
; out:  r3 = podule number, if VC, otherwise corrupted
;       All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
 [ CheckPoduleVariable
	Push	"r3,r4"
	ADR	r0, PoduleVariableName
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	Pull	"r3,r4"
	BVS	%FT05

	MOV	r0, #0
	STRB	r0, [r1, r2]			; terminate string

	Push	"r1"
	SWI	XPodule_ReturnNumber
	Pull	"r1"
	BVS	%FT90

	SUB	r2, r0, #1			; maximum podule number
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	BVS	%FT05

	MOV	r3, r2				; copy value into r3
	EXIT

PoduleVariableName
	=	MPEGCardVariableName, 0
	ALIGN

05
 ] ; CheckPoduleVariable
        SWI     XPodule_ReturnNumber
	BVS	%FT90
        SUB     r3, r0, #1              ; r6 = max podule number
        ADR     r2, PoduleHeaderBuffer
10
        SWI     XPodule_ReadHeader
        BVS     %FT20
        LDRB    r0, [r2, #3]
        LDRB    r1, [r2, #4]

; This code changed by TMD 17-Feb-95
; No longer allow &0000 in any version
; Allows &00FF or &00F9

        ORR     r0, r0, r1, LSL #8
 [ IsMPEG2
	LDR	lr, =ProdType_STB1_MPEG2	; check for STB1 MPEG2
	CMP	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2	; or STB2 MPEG2
	CMPNE	r0, lr
 |
	CMP	r0, #ProdType_MPEGDecoder 	; allow new
        CMPNE   r0, #&FF                	; or old types (V := 0)
	LDRNE	lr, =ProdType_STB2_MPEG1	; also allow STB2 MPEG 1 product type
	CMPNE	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG0	; also allow Roadster product type
	CMPNE	r0, lr
 ]
        EXIT    EQ
20
        SUBS    r3, r3, #1
        BPL     %BT10
        ADRL    r0, NoPoduleError
        SETV
90
	STR	r0, [sp]
        EXIT
  ] ; PhaseDetectOnPodule
 ] ; PhaseDetect <> 0

; *****************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; insert anything we need here!

	LDR	r0, VectorsClaimed
	TEQ	r0, #0
	BNE	%FT90			; [on vectors, so must be in interlace mode, so not safe to die]

; safe to die

        LDR     r0, =L1PT+(DummyScreen :SHR: 18)   ; start of relevant L1
 [ Use1MBPerField
	MOV	r3, #maxyres
 |
        MOV     r3, #maxyres/2          ; number of 1MB mappings required
 ]
	MOV	r1, #0			; no access to this area any more
10
        STMIA   r0!, {r1}
        SUBS    r3, r3, #1
        BNE     %BT10

	MOV	r0, #1			; remove dynamic area
	STR	r0, ShrinkOK
	LDR	r1, DynAreaNumber
	SWI	XOS_DynamicArea

 [ FixGrowShrink
        LDR     r2, DANodePointer
        TEQ     r2, #0                  ; have we claimed the screen DA handler?
        ADDNE   r3, r2, #DANode_Workspace
        ADRNE   r4, DAHandlerKernelWs
        ASSERT  DANode_Workspace = DANode_Handler - 4
        ASSERT  :INDEX: DAHandlerKernelWs = :INDEX: DAHandlerKernelRout - 4
        LDMNEIA r4, {r0, r1}
        STMNEIA r3, {r0, r1}            ; restore the original routine and workspace pointers if so
 ]

        CLRV
        EXIT

; can't die, cos we're in an interlace mode currently

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"Interlace module cannot die: interlaced mode in use", 0
	ALIGN

; *****************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

        ASSERT  Service_Reset < Service_ModeChange
        ASSERT  Service_ModeChange < Service_ModeExtension
        ASSERT  Service_ModeExtension < Service_ValidateAddress
        ASSERT  Service_ValidateAddress < Service_SwitchingOutputToSprite
        ASSERT  Service_SwitchingOutputToSprite < Service_ModeChanging

Mod_ServiceTable
        DCD     0
        DCD     Mod_ServiceEntry - Module_BaseAddr
        DCD     Service_Reset
        DCD     Service_ModeChange
 [ TryToDoModeNumbers
        DCD     Service_ModeExtension
 ]
        DCD     Service_ValidateAddress
 [ FixHWScroll
        DCD     Service_SwitchingOutputToSprite
 ]
        DCD     Service_ModeChanging
        DCD     0

        DCD     Mod_ServiceTable - Module_BaseAddr
Mod_Service ROUT
        MOV     r0, r0
        TEQ     r1, #Service_Reset
        TEQNE   r1, #Service_ModeChange
 [ TryToDoModeNumbers
        TEQNE   r1, #Service_ModeExtension
 ]
        TEQNE   r1, #Service_ValidateAddress
 [ FixHWScroll
        TEQNE   r1, #Service_SwitchingOutputToSprite
 ]
        TEQNE   r1, #Service_ModeChanging
        MOVNE   pc, lr

Mod_ServiceEntry
        LDR     wp, [r12]

        TEQ     r1, #Service_ModeChange
        BEQ     svc_ModeChange

        TEQ     r1, #Service_Reset
        BEQ     svc_Reset

        TEQ     r1, #Service_ModeChanging
        BEQ     svc_ModeChanging

        TEQ     r1, #Service_ValidateAddress
        BEQ     svc_ValidateAddress

 [ FixHWScroll
        TEQ     r1, #Service_SwitchingOutputToSprite
        BEQ     svc_SwitchingOutputToSprite
 ]


; In the new implementation, the interlaced modes are monitor description file modes,
; so the ScreenModes module claims the service.
;
; However, for backwards compatibility, we provide the numbered modes by translating the mode number
; into a mode descriptor and re-issuing the service.

  [ TryToDoModeNumbers
svc_ModeExtension Entry "r0"
	CMP	r2, #&100
	EXIT	CS				; if not a mode number, do nothing

	ADRL	r0, ModeListTable
10
	LDR	lr, [r0]
	CMP	lr, #-1
	EXIT	EQ				; didn't find mode in list, so exit
	TEQ	r2, lr
	ADDNE	r0, r0, #8
	BNE	%BT10				; [not this mode, so try next]

	LDR	r2, [r0, #4]			; load offset to mode descriptor
	ADD	r2, r2, r0			; convert to absolute address
	SWI	XOS_ServiceCall
	EXIT					; whether or not it's claimed, we exit, having made r2->mode descriptor
						; if claimed, r1 will have be set to 0, and r3->VIDClist, r4 probably 0 (wslist)
  ]

svc_ModeChange  Entry "r0-r3"
	BL	FindMode
	EXIT	EQ

	LDR	r2, [r0, #12]			; get offset to other info
	ADD	r2, r2, r0
	STR	r2, OtherStuffPtr

      [ :LNOT: ScreenBanks                      ; now done after ScreenSize is set up
	BL	SetupMemoryMap
      ]

	Push	"r2"
	MOV	r0, #2
	SWI	XOS_ReadDynamicArea
	Pull	"r2"
	LDR	r0, [r2, #OtherIndex_ScreenSize]
	VDWS	lr
      [ FixGrowShrink ; FixGrowShrink option is a prerequisite for this speed-up
	LDR	r3, [lr, #ScreenSize]		; if ScreenSize is already as big as we need, leave it
	CMP	r0, r3				; (this allows teletext mode to work)
	BLS	%FT20
      ]
	STR	r0, [lr, #ScreenSize]
      [ ScreenBanks
        LDR     r3, [lr, #VduStatus]
        TST     r3, #Shadowing
        MOVNE   r0, r0, LSL #1                  ; twice as much needed for shadow modes
      ]
	SUBS	r1, r0, r1			; needed size - current size

      [ FixGrowShrink
	MOVGT	r0, #2				; increase the screen size to cope, if necessary
	SWIGT	XOS_ChangeDynamicArea
      |
	MOV	r0, #2				; always set to exactly the right size (may be too big *or too little* now)
	SWI	XOS_ChangeDynamicArea		; so Wimp doesn't do it itself after we've screwed the variables up
      ]

      [ ScreenBanks
        ; ChangeDynamicArea trashes the Shadowing flag
        VDWS    lr
        STR     r3, [lr, #VduStatus]
      ]
20
      [ ScreenBanks
	BL	SetupMemoryMap
      ]

        MOV     r0, #&C0000000
        STR     r0, Phase

	; Claim the vectors early so that if anyone calls OS_SpriteOP 60 (Switch output to Sprite) we can override the
	; line length set by the kernel.  This was happening during SWI OS_WriteI+12 (below).
        BL      ClaimVectors

        VDWS    r0

	BL	ModifyVars

      [ ScreenBanks
        ; ModifyVars exits with VduStatus in r1
        ANDS    r14, r1, #Shadowing
        LDRNE   r14, [r0, #ScreenSize]          ; start in second bank in shadow modes
        STR     r14, PhysicalDriverOffset
        STR     r14, FrameDisplayOffset
      ]
        LDR     r1, DummyScreenStart
      [ ScreenBanks
        MOVNE   r14, r14, LSL #32-12
        ADDNE   r1, r1, r14, LSR #32-12         ; add in sub-page component of default bank
      ]
        STR     r1, [r0, #ScreenStart]
      [ :LNOT: ScreenBanks                      ; these variables not actually needed
        STR     r1, [r0, #DisplayStart]
        STR     r1, [r0, #DisplayBankAddr]
        STR     r1, [r0, #DriverBankAddr]
      ]
        STR     r1, [r0, #DisplayScreenStart]

        LDR     r1, [r2, #OtherIndex_YRes]
	MOV	r1, r1, LSR #1
	SUB	r1, r1, #1			; DisplayYWindLimit = yres/2-1
        STR     r1, [r0, #DisplayYWindLimit]

	LDR	r1, [r0, #YEigFactor]
        ADD	r1, r1, #1			; don't use constant 2 any more, so we can support weird YEig modes
        STR     r1, [r0, #DisplayYEigFactor]

        SWI     XOS_WriteI+12
        EXIT

ModifyVars Entry "r2"
	SWI	XOS_RemoveCursors		; remove flashing cursor while we mess about

	LDR	r1, [r2, #OtherIndex_LineLength]
	STR	r1, [r0, #LineLength]
      [ HiResTTX ; do it properly!
        LDR     lr, [r0, #RowMult]
        MUL     lr, r1, lr
      |
	MOV	lr, r1, LSL #3
      ]
	STR	lr, [r0, #RowLength]
      [ HiResTTX
        LDR     r2, [r0, #ModeFlags]
        TST     r2, #Flag_DoubleVertical
        SUBNE   r1, lr, r1, LSL #1              ; cursor is double height in these modes
        SUBEQ   r1, lr, r1
      |
	SUB	r1, lr, r1
      ]
	ADD	r2, r0, #CursorStartOffset
	ASSERT	CursorEndOffset = CursorStartOffset +4
	STMIA	r2, {r1, lr}
	BL	AddressCursors			; recompute CursorAddr, InputCursorAddr
	SWI	XOS_RestoreCursors

        LDR     r1, [r0, #ModeFlags]
        ORR     r1, r1, #Flag_HardScrollDisabled :OR: Flag_InterlacedMode
        STR     r1, [r0, #ModeFlags]
	STR	r1, [r0, #DisplayModeFlags]

        LDR     r1, [r0, #VduStatus]
        ORR     r1, r1, #Windowing
        STR     r1, [r0, #VduStatus]
	EXIT

        LTORG

AddressCursors Entry "r0-r4,r12"
	VDWS	r12
	LDR	lr, [r12, #CursorFlags]
	TST	lr, #CursorsSplit
	BLNE	AddressInputCursor
	LDR	r0, [r12, #CursorX]
	LDR	r1, [r12, #CursorY]
	BL	AddressR0R1
	STR	r2, [r12, #CursorAddr]
	EXIT

AddressInputCursor Entry
	LDR	r0, [r12, #InputCursorX]
	LDR	r1, [r12, #InputCursorY]
	BL	AddressR0R1
	STR	r2, [r12, #InputCursorAddr]
	EXIT

AddressR0R1 ROUT
	LDR	r4, [r12, #RowLength]
	LDR	r3, [r12, #Log2BPC]
      [ HiResTTX
        LDR     R2, [r12, #ModeFlags]
        TST     R2, #Flag_Teletext
        ADDNE   R3, R3, #1
      ]
	LDR	r2, [r12, #ScreenStart]		; start address of top of screen
	ADD	r2, r2, r0, LSL r3		; add in X component
	MLA	r2, r4, r1, r2			; add in Y * RowLength
	MOV	pc, lr

 [ FixHWScroll
svc_SwitchingOutputToSprite Entry "r0-r2"
	LDR	r0, VectorsClaimed
	TEQ	r0, #0
	EXIT	EQ			; not in interlaced mode, so exit

        VDWS    r0
        TEQ     r4, #0                  ; are we switching to screen?

; On switching back to the screen, the kernel restores the variable LineLength to the
; value returned from ReadModeVariable, ie the number of bytes on one line, not the enormous
; skip we require. This would not normally be a problem, since we get Service_SwitchingOutputToSprite
; when switching back to the screen, so we can patch it up again.

; However, the kernel restores the flashing cursor *before* issuing the service, and this does effectively
;   FOR i=CursorStartOffset TO CursorEndOffset-1 STEP LineLength: toggle CursorAddr?i: NEXT
; and CursorStartOffset and CursorEndOffset are an enormous distance apart, not all of which is mapped in,
; thus causing a data abort.

; To get around the problem we nobble CursorStartOffset and CursorEndOffset when output is switched away from
; the screen, so that on the return to the screen, the flashing code thinks the cursor is zero height and doesn't
; toggle anything.

; NB. we set CursorEndOffset to zero before CursorStartOffset, just in case there's a flash in between

	MOVNE	lr, #0				; if switching to sprite
	STRNE	lr, [r0, #CursorEndOffset]	; make cursorstartoffset >= cursorendoffset
	STRNE	lr, [r0, #CursorStartOffset]	; so no cursor flashing will occur
	LDR	r1, =SavedCursorEndOffset
	STRNE	lr, [r0, r1]			; make cursorstartoffset >= cursorendoffset
	LDR	r1, =SavedCursorStartOffset
	STRNE	lr, [r0, r1] 			; so no cursor flashing will occur

        EXIT    NE                      ; no, then exit

	LDR	r2, OtherStuffPtr
	BL	ModifyVars
        EXIT
 ]

svc_ModeChanging
        B       ReleaseVectors

svc_Reset Entry "r0-r2"
	MOV	r0, #&FD
	MOV	r1, #0
	MOV	r2, #&FF
	SWI	XOS_Byte
	TEQ	r1, #0
        BLEQ    ReleaseVectors
        EXIT

svc_ValidateAddress Entry "r0"
	LDR	lr, VectorsClaimed	; TMD 22-Jun-98: first check if we're in interlaced mode, so that
	TEQ	lr, #0			; indirection off OtherStuffPtr doesn't go bang!
	EXIT	EQ

        LDR     lr, DummyScreenStart
        CMP     r2, lr
        CMPCS   r3, lr
        EXIT    CC

	LDR	r0, OtherStuffPtr
	LDR	r0, [r0, #OtherIndex_YRes]
 [ Use1MBPerField
	ADD	lr, lr, r0, LSL #20 ; add on total amount of logical space for screen = yres * 1024K
 |
        ADD     lr, lr, r0, LSL #19 ; add on total amount of logical space for screen = yres * 512K
 ]
        CMP     r2, lr
        CMPLS   r3, lr
        MOVLS   r1, #0
        EXIT

        LTORG

; Check current is interlaced - we do this by looking at the mode flags. Note that this only works
; if we look at the "current" mode - other modes we can't actually tell...
; If so, we then need to create a fake structure for this mode - in practice only the 'OtherInfo'
; part gets used but we keep the same structure for simplicity.

; out:	r0 -> structure

FindMode Entry "r1-r5"
        MOV     r0, #-1
        MOV     r1, #VduExt_ModeFlags
        SWI     XOS_ReadModeVariable
        TST     r2, #Flag_InterlacedMode
        BEQ     %FT90

; we have an interlaced screen mode!

	MOV	r0, #-1
	MOV	r1, #VduExt_Log2BPP
	SWI	XOS_ReadModeVariable
	Push	"r2"			; save pixdepth
	MOV	r1, #VduExt_YWindLimit
	SWI	XOS_ReadModeVariable
	ADD	r2, r2, #1		; r2 = yres
	Push	"r2"
	MOV	r1, #VduExt_XWindLimit
	SWI	XOS_ReadModeVariable
	ADD	r2, r2, #1		; r2 = xres

	Pull	"r4,r5"			; r4 = yres; r5 = pixdepth
	STR	r4, FindModeOtherStuff+OtherIndex_YRes
	MOV	lr, r2, LSL r5		; lr = (xres << pixdepth)
	MOV	lr, lr, LSR #3+1	; actual linelength/2 in bytes
 [ Use1MBPerField
	ADD	r0, lr, #1024*1024	; r0 = RISC OS linelength
 |
	ADD	r0, lr, #512*1024
 ]
	STR	r0, FindModeOtherStuff+OtherIndex_LineLength
	MUL	r0, r4, lr		; r0 = size of one field
	LDR	r1, =&FFF		; r1 = page mask
	ADD	r0, r0, r1
	BIC	r2, r0, r1		; firstfieldsize
	STR	r2, FindModeOtherStuff+OtherIndex_PageOffset2ndField
	ADD	r3, r2, lr		; physical offset from bank 1 to 2
	STR	r3, FindModeOtherStuff+OtherIndex_Offset1To2
	ADD	r3, r0, lr
	BIC	r3, r3, r1		; secondfieldsize
	ADD	r3, r3, r2		; firstfieldsize + secondfieldsize
	STR	r3, FindModeOtherStuff+OtherIndex_ScreenSize

	MOV	r0, #FindModeOtherStuff - FindModeStructure
	STR	r0, FindModeOtherOffset
	ADR	r0, FindModeStructure

	TEQ	r0, #0			; set NE
	EXIT

90
	TEQ	r0, r0			; set EQ indicating not found
	EXIT


 [ ScreenBanks

; SetupMemoryMap_L2Only - setup L2 pages
; in:   r0 = base physical address
;       r2 -> OtherStuff

SetupMemoryMap_L2Only Entry
        BL      SetupL2Common
        MOV     r14, #0
        SetCop  r14, CR_TLBFlush         ; L1 and L2 modified, so flush TLB (no need to flush IDC, as area not cacheable)
        EXIT

SetupL2Common Entry "r0,r1,r3-r5"

 |

; SetupMemoryMap - setup L1 and L2 pages for current screensize
; in:	r2 -> OtherStuff

SetupMemoryMap Entry "r0,r1,r3-r5"

; first set up L2 entries

	LDR	r0, ScreenPhysAddr
 ]
	LDR	r1, =L2_SmallPage + (AP_Full * L2_APMult) + L2_B
	ADD	r0, r0, r1		; base L2 entry for 1st 512K (or 1024K)
	LDR	r1, [r2, #OtherIndex_PageOffset2ndField]
	ADD	r1, r1, r0		; r1 is entry for 2nd field
	LDR	r3, PageTableLogAddr	; r3 -> 1st half of L2 page (or 1st L2 page)
 [ Use1MBPerField
	MOV	r5, #1024		; number of bytes in each half
 |
	MOV	r5, #512		; number of bytes in each half
 ]
	ADD	r4, r3, r5		; point at 2nd half of L2 page (or 2nd L2 page)
10
	STR	r0, [r3], #4
	STR	r1, [r4], #4
	ADD	r0, r0, #&1000
	ADD	r1, r1, #&1000
	SUBS	r5, r5, #4
	BNE	%BT10

 [ ScreenBanks
        EXIT

; SetupMemoryMap - setup L1 and L2 pages for current screensize
; in:   r2 -> OtherStuff

SetupMemoryMap Entry "r0,r1,r3,r5"

; first set up L2 entries

        VDWS    r14
        LDR     r0, [r14, #VduStatus]
        ANDS    r0, r0, #Shadowing      ; if shadow screen mode, start at bank 2
        LDRNE   r0, [r14, #ScreenSize]
        MOV     r0, r0, LSR #12         ; page offset
        LDR     r14, ScreenPhysAddr
        ADD     r0, r14, r0, LSL #12
        BL      SetupL2Common
 ]

; finally set up L1 entries

        LDR     r1, PageTablePhysAddr   ; get physical address of L2
        LDR     r0, =L1_U + L1_Page
        ORR     r1, r1, r0

        LDR     r0, =L1PT+(DummyScreen :SHR: 18)   ; start of relevant L1
	LDR	r3, [r2, #OtherIndex_YRes]
	MOV	r3, r3, LSR #1		; number of 1MB (or 2MB) mappings required
 [ Use1MBPerField
	ADD	r5, r1, #&400		; 2nd L1 entry, pointing at 2nd L2 page
20
        STMIA   r0!, {r1,r5}
 |
20
        STMIA   r0!, {r1}
 ]
        SUBS    r3, r3, #1
        BNE     %BT20

	MOV	r0, #0
	SetCop	r0, CR_TLBFlush		; L1 and L2 modified, so flush TLB (no need to flush IDC, as area not cacheable)
	EXIT

ClaimVectors Entry "r0-r6"
        LDR     r0, VectorsClaimed
        TEQ     r0, #0
        EXIT    NE

 [ ScreenBanks
        MOV     r0, #ByteV
        ADRL    r1, MyByte
        MOV     r2, wp
        SWI     XOS_Claim

        MOV     r0, #WordV
        ADRL    r1, MyWord
        MOV     r2, wp
        SWI     XOS_Claim
 ]

 [ UseTimer1
        MOV     r0, #6          ; Timer 1 device
        ADR     r1, MyTimer1Device
        MOV     r2, wp
        SWI     XOS_ClaimDeviceVector
 ]

 [ :LNOT: UseVSyncEvent
   [ {TRUE}
; check version number of UtilityModule (1st module) is < 360, 360/361, or > 361
; (don't use presence of ARM7500, as 3.60 is available on RISC PC)
	MOV	r0, #ModHandReason_EnumerateROM_ModulesWithInfo
	MOV	r1, #0				; find 1st ROM module (hopefully UtilityModule)
	MOV	r2, #-1				; main ROM section
	SWI	XOS_Module
	MOVVS	r6, #0				; if error, assume old (shouldn't get error!)
	LDR	r0, =VSyncDeviceWS7500		; default address for 3.60 / 3.61
	CMP	r6, #&36000			; if version < 3.60
	LDRCC	r0, =VSyncDeviceWS		; then use old address
	LDRHI	r2, =&36100
	CMPHI	r6, r2				; if version > 3.61
	LDRHI	r0, =VSyncDeviceWSwIRQC		; then use new address
   |
	MOV	r0, #2
	SWI	XOS_ReadSysInfo
	TST	r2, #&FF :SHL: 8		; test IOMD variant (EQ => old IOMD)
	LDREQ	r0, =VSyncDeviceWS		; if old then use old address
        LDRNE   r0, =VSyncDeviceWS7500		; if new then use new address
   ]

        LDMIA   r0, {r1, r2}
        ADR     r0, OldDeviceWS
        STMIA   r0, {r1, r2}
 ]

 [ UseVSyncEvent
        MOV     r0, #EventV
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_Claim

        MOV     r0, #14
        MOV     r1, #Event_VSync
        SWI     XOS_Byte
 |
        MOV     r0, #3
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_ClaimDeviceVector
 ]

 [ PhaseDetectBit = 0
        MOV     r0, #PaletteV
        ADR     r1, MyPalette
        MOV     r2, wp
        SWI     XOS_Claim
 ]

 [ FixGrowShrink
        MOV     r0, #1
        STR     r0, DAHandlerIntercept          ; intercept DA handler for this mode
 ]

        MOV     r0, #1
        STR     r0, VectorsClaimed
        EXIT

        LTORG

ReleaseVectors Entry "r0-r2"
        LDR     r0, VectorsClaimed
        TEQ     r0, #0
        EXIT    EQ

 [ PhaseDetectBit = 0
        MOV     r0, #PaletteV
        ADR     r1, MyPalette
        MOV     r2, wp
        SWI     XOS_Release
 ]

 [ UseVSyncEvent
        MOV     r0, #13
        MOV     r1, #Event_VSync
        SWI     XOS_Byte

        MOV     r0, #EventV
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_Release
 |
        MOV     r0, #3
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_ReleaseDeviceVector
 ]

 [ UseTimer1
        MOV     r0, #6          ; Timer 1 device
        ADR     r1, MyTimer1Device
        MOV     r2, wp
        SWI     XOS_ReleaseDeviceVector
 ]

 [ UseInitialCallBack
	ADR	r0, InterlaceCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
	MOV	r0, #0
	STR	r0, CallBackRequested
 ]

 [ FixGrowShrink
        MOV     r0, #0
        STR     r0, DAHandlerIntercept          ; don't intercept DA handler for this mode
 ]

 [ ScreenBanks
        MOV     r0, #WordV
        ADRL    r1, MyWord
        MOV     r2, wp
        SWI     XOS_Release

        MOV     r0, #ByteV
        ADRL    r1, MyByte
        MOV     r2, wp
        SWI     XOS_Release
 ]

        MOV     r0, #0
        STR     r0, VectorsClaimed
        EXIT

 [ ScreenBanks
MyByte
        TEQ     r0, #112        ; write vdu driver screen bank
        TEQNE   r0, #113        ; write display hardware screen bank
        MOVNE   pc, r14         ; pass on other reason codes

        Push    "r0,r3-r5,r9"
        VDWS    r9
        MOVS    r3, r1          ; default for current mode?
        BNE     %FT10
        LDR     r14, [r9, #VduStatus]
        TST     r14, #Shadowing
        MOVEQ   r3, #1
        MOVNE   r3, #2
10
        SUB     r5, r0, #111    ; driver=1, display=2
        ADD     r0, r5, #249    ; 250 for driver, 251 for display
        MOV     r1, #0
        MOV     r2, #255
        SWI     XOS_Byte        ; read old bank number into R1
        LDR     r0, [r9, #ScreenSize]
        LDR     r2, [r9, #TotalScreenSize]
        MUL     r4, r3, r0      ; r4 = start offset of next bank
        CMP     r4, r2
        Pull    "r0,r3-r5,r9,pc", HI ; if after end, can't do it, so exit
        SUB     r4, r4, r0      ; r4 = start offset of this bank
        Push    "r1"
        ADD     r0, r5, #249
        MOV     r1, r3
        MOV     r2, #0
        SWI     XOS_Byte        ; update bank number in vdu workspace
        MOV     r0, r5, LSL #24 ; 1 or 2 in top byte
        MOV     r1, r4
        Push    "r0,r1"
        MOV     r0, #OsWord_WriteScreenBaseAddress
        ADD     r1, sp, #3
        SWI     XOS_Word        ; set base address
        ADD     sp, sp, #8
        Pull    "r1"
        Pull    "r0,r3-r5,r9,pc"

MyWord
        TEQ     r0, #OsWord_WriteScreenBaseAddress
        MOVNE   pc, r14         ; pass on other reason codes

        Push    "r0-r2,r9,r14"
        VDWS    r9
        LDRB    r2, [r1, #1]
        LDRB    r0, [r1, #2]
        ORR     r2, r2, r0, LSL #8
        LDRB    r0, [r1, #3]
        ORR     r2, r2, r0, LSL #16
        LDRB    r0, [r1, #4]
        ORR     r2, r2, r0, LSL #24
        LDRB    r0, [r1]        ; now r0=type, r2=offset
        LDR     r1, [r9, #ScreenSize]
        LDR     r14, [r9, #TotalScreenSize]
        SUB     r1, r14, r1     ; maximum allowable offset
        CMP     r2, r1
        Pull    "r0-r2,r9,r14,pc", HI ; claim without taking action if offset too big

        TST     r0, #1          ; writing driver base address?
        BEQ     %FT05
        Push    "r0,r2"
        SWI     XOS_RemoveCursors
        STR     r2, PhysicalDriverOffset
        LDR     r0, DummyScreenStart
        LDR     r14, =&FFF      ; page mask
        AND     r1, r2, r14     ; sub-page component of offset
        ADD     r0, r0, r1      ; added onto base of logical screen
        STR     r0, [r9, #DisplayScreenStart]
        STR     r0, [r9, #ScreenStart] ; should really be conditional on not outputting to sprite
        LDR     r1, ScreenPhysAddr
        BIC     r0, r2, r14     ; page component of offset
        ADD     r0, r1, r0      ; added onto base of physical screen
        LDR     r2, OtherStuffPtr
        BL      SetupMemoryMap_L2Only
        BL      AddressCursors
        SWI     XOS_RestoreCursors
        Pull    "r0,r2"
05
        TST     r0, #2          ; writing display base address?
        BEQ     %FT10
        STR     r2, FrameDisplayOffset
        LDR     r1, FieldDisplayOffset
        MOV     r0, #2:SHL:24   ; type flags for kernel in top byte of r0
        ADD     r2, r2, r1      ; base address taking interlace into account
        Push    "r0,r2"         ; construct new block on stack
        ADD     r1, sp, #3
        MOV     r0, #OsWord_WriteScreenBaseAddress
        Push    "pc"            ; push address for kernel to return to (PC+12) onto stack
        LDR     pc, [sp, #4*7]  ; jump to original r14: pass on to kernel
        NOP
        ADD     sp, sp, #8
10
        Pull    "r0-r2,r9,r14,pc"
 ]

MyVSyncDevice ROUT
 [ UseVSyncEvent
        TEQ     r0, #Event_VSync
        MOVNE   pc, lr
        Push    "r3,lr"
        MOV     r3, #IOC
 ]
 [ UseTimer1
        BL      StartTimer1
 |
        BL      DoInterlace
 ]
 [ UseVSyncEvent
        MOV     r0, #Event_VSync
        Pull    "r3,pc"
 |
        ADR     r0, OldDeviceWS
        LDMIA   r0, {r12, pc}
 ]

 [ UseTimer1
; On entry, r3 -> IOC

StartTimer1     Entry   "r0-r1"
        MOV     r0, #Timer1LatchValue :AND: 255
        STRB    r0, [r3, #Timer1LL]
        MOV     r0, #Timer1LatchValue :SHR: 8
        STRB    r0, [r3, #Timer1LH]
        STRB    r0, [r3, #Timer1GO]
        MOV     r0, #timer1_bit
        STRB    r0, [r3, #IOCIRQCLRA]           ; clear the latched IRQ
        STRB    r0, [r3, #IOCIRQCLRA]           ; and again in case it just underflowed
        SETPSR  I_bit+F_bit+SVC_mode,r1,,r0     ; disable IRQs round enabling of timer1 IRQ
        LDRB    r1, [r3, #IOCIRQMSKA]
        ORR     r1, r1, #timer1_bit
        STRB    r1, [r3, #IOCIRQMSKA]
        RestPSR r0,,c
        EXIT

MyTimer1Device  Entry "r0-r3"
        SETPSR  I_bit+F_bit+SVC_mode,r1,,r0     ; disable IRQs round disabling of timer1 IRQ
        LDRB    r1, [r3, #IOCIRQMSKA]
        BIC     r1, r1, #timer1_bit             ; disable IRQ in mask
        STRB    r1, [r3, #IOCIRQMSKA]
        RestPSR r0,,c
        MOV     r0, #timer1_bit
        STRB    r0, [r3, #IOCIRQCLRA]           ; and clear IRQ latch
        BL      DoInterlace
        EXIT
 ]

  [ PhaseDetectBit = 0
; If the screen gets blanked and Vsyncs stop we lose count. So we sit
; on PaletteV to detect when the screen unblanks.
MyPalette
        TEQ     r4, #paletteV_BlankScreen
        TEQEQ   r0, #0                          ; unblanking screen?
        MOVNE   pc, lr                          ; no - pass it on

        STMFD   sp!, {wp}                       ; save our wp
        STMFD   sp!, {pc}                       ; push PC+8 or 12
        MOV     pc, lr
        NOP

; Vector will return here
        LDMFD   sp!, {wp}                       ; get our workspace pointer back
        SavePSR lr                              ; don't break the exit flags (just in case)
        TEQ     r4, #paletteV_Complete          ; operation complete?
        TEQEQ   r0, #1                          ; and the previous state was blanked?
        BNE     %FT20

        RestPSR lr,,f                           ; get the PSR flags back
        MOV     lr, #&C0000000
        STR     lr, Phase                       ; and rejig interlace
        LDMFD   sp!, {pc}

20
        RestPSR lr,,f
        LDMFD   sp!, {pc}
  ]

DoInterlace Entry
 [ PhaseDetectBit = 0
        LDR     r0, Phase
        EORS    r0, r0, #1
        BLMI    EnableInterlace         ; first time thru, turn on interlace
        STR     r0, Phase
	LDRNE	r0, OtherStuffPtr
	LDRNE	r0, [r0, #OtherIndex_Offset1To2]
 |
        LDR     r0, Phase
        CMP     r0, #&C0000000
        BLEQ    EnableInterlace         ; first time thru, turn on interlace
        EOR     r0, r0, #1              ; toggle it
        STR     r0, Phase               ; put back
        LDR     r0, Podule_ControlStatus

        ; Go read hardware interlace phase - this bit shows the phase of
        ; the current field: 1 = odd, 0 = even.
        ; However, this IRQ code is called just before the
        ; *end* of the field, so the phase for the *next* field's data
        ; should be the opposite of what we read.  Well, we hope it
        ; is.  In theory, service latency for the flyback IRQ of over
        ; 1.5 milliseconds would mean we could read the phase after it
        ; has changed for the next field, i.e. it would be wrong.  For
        ; now, just count how often this happens, i.e. how often the
        ; phase read is the same as the phase read on the previous IRQ.

        LDRB    r3, [r0]
        LDRB    r1, LastPhase                           ; get previous phase for check
        ANDS    r3, r3, #PhaseDetectBit                 ; extract and test current phase
  [ PhaseDetectInvert
	EORS	r3, r3, #PhaseDetectBit			; invert if necessary
  ]
	LDREQ	r0, OtherStuffPtr
	LDREQ	r0, [r0, #OtherIndex_Offset1To2]	; if this phase even, make odd for next
        MOVNE   r0, #0                                  ; else even (no frame offset)
        STRB    r3, LastPhase                           ; save latest phase for next time
        CMP     r1, r3                                  ; compare this and last phase:
        LDREQ   r1, PhaseErrors                         ; if inconsistent, record the error
        ADDEQ   r1, r1, #1
        STREQ   r1, PhaseErrors
        LDR     r1, FieldCount
        ADD     r1, r1, #1
        STR     r1, FieldCount
 ]

 [ ScreenBanks
        STR     r0, FieldDisplayOffset
        LDR     r0, FrameDisplayOffset
 ]
        STR     r0, OSWord16Block +1

 [ MakeCFSCountPhase
        LDR     r3, OSByteVarBase
        MOVS    r1, r0
        MOVNE   r1, #1                                  ; r1 = 0 if next field is top, else r1 = 1
        LDRB    r0, [r3, #CFSTime]                      ; load OS's counter which decrements each field
        EOR     r1, r1, r0                              ; check relative parity
        TST     r1, #1
   [ UseVSyncEvent :LAND: :LNOT: UseTimer1
        SUBNE   r0, r0, #1                              ; if doing top field next then counter needs to be even now,
        STRNEB  r0, [r3, #CFSTime]                      ; as the Kernel's already updated CFS for this vsync
   |
        SUBEQ   r0, r0, #1                              ; if doing top field next then counter needs to be odd now
        STREQB  r0, [r3, #CFSTime]                      ; so it will be even after the vsync
   ]
 ]

        SETPSR  SVC_mode,r0,,r3

        Push    "lr"
        MOV     r0, #&16
        ADR     r1, OSWord16Block
        SWI     XOS_Word
        Pull    "lr"

        RestPSR r3,,c
        EXIT

EnableInterlace ROUT
 [ PhaseDetectBit = 0
        CMP     r0, #&C0000000
        BCC     %FT10
        LDR     r0, =ControlRegisterSoftCopy
        LDR     r1, [r0]
        BIC     r1, r1, #1 :SHL: 12
        STR     r1, [r0]
        MOV     r0, #&03500000
        STR     r1, [r0]
        MOV     r0, #&80000000          ; starting value of phase
        MOV     pc, r14
10
  [ UseInitialCallBack
	LDR	r0, CallBackRequested
	TEQ	r0, #0
	MOVNE	r0, #&80000000		; still waiting for callback
	MOVNE	pc, r14			; so keep phase at &80000000

        SETPSR  SVC_mode,r1,,r0
	Push	"r0,lr"
	ADR	r0, InterlaceCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"r0,lr"
        RestPSR r0,,c
	MOV	r0, #1
	STR	r0, CallBackRequested
  |
	MOV	r0, #IOC
20
	LDRB	r1, [r0, #IOCControl]
	TST	r1, #vsync_state_bit
	BNE	%BT20			; wait until out of vsync
  ]
 ]
ProgramControlRegister
        LDR     r0, =ControlRegisterSoftCopy
        LDR     r1, [r0]
 [ EnableInterlaceInVIDC
        ORR     r1, r1, #1 :SHL: 12
 |
        BIC     r1, r1, #1 :SHL: 12
 ]
        STR     r1, [r0]
        MOV     r0, #&03500000
        STR     r1, [r0]
 [ PhaseDetectBit = 0
	MOV	r0, #0
 |
        MOV     r0, #1                  ; starting value of phase
 ]
        MOV     pc, r14

 [ UseInitialCallBack
InterlaceCallBack Entry "r0-r2"
	MOV	r0, #IOC
        SETPSR  I_bit,r1,,r2
10
	LDRB	lr, [r0, #IOCControl]
	TST	lr, #vsync_state_bit
	BEQ	%BT10			; wait until vsync
20
        RestPSR r2,,c
        NOP                             ; give StrongARM time to trigger interrupts
        NOP
        NOP
        NOP
        NOP
        RestPSR r1,,c
	LDRB	lr, [r0, #IOCControl]
	TST	lr, #vsync_state_bit
	BNE	%BT20			; wait until not vsync
	BL	ProgramControlRegister
	STR	r0, Phase
	MOV	r0, #0
	STR	r0, CallBackRequested
        RestPSR r2,,c
        EXIT
 ]


 [ {FALSE}
InterlaceDebug_Code Entry
        LDR     wp, [r12]
        SUB     sp, sp, #12

        SWI     XOS_WriteS
        =       "YRes = ", 0
        ALIGN
        LDR     r0, FindModeOtherStuff+OtherIndex_YRes
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_NewLine

        SWI     XOS_WriteS
        =       "LineLength = ", 0
        ALIGN
        LDR     r0, FindModeOtherStuff+OtherIndex_LineLength
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_NewLine

        SWI     XOS_WriteS
        =       "PageOffset2ndField = ", 0
        ALIGN
        LDR     r0, FindModeOtherStuff+OtherIndex_PageOffset2ndField
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_NewLine

        SWI     XOS_WriteS
        =       "Offset1To2 = ", 0
        ALIGN
        LDR     r0, FindModeOtherStuff+OtherIndex_Offset1To2
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_NewLine

        SWI     XOS_WriteS
        =       "ScreenSize = ", 0
        ALIGN
        LDR     r0, FindModeOtherStuff+OtherIndex_ScreenSize
        MOV     r1, sp
        MOV     r2, #12
        SWI     XOS_ConvertHex8
        SWI     XOS_Write0
        SWI     XOS_NewLine

        ADD     sp, sp, #12
        EXIT
 ]
InterlaceSwap_Code Entry
        LDR     wp, [r12]
 [ PhaseDetectBit = 0
        SETPSR  I_bit,r1,,r0
        LDR     lr, Phase
        EOR     lr, lr, #1
        STR     lr, Phase
        RestPSR r0,,c
 ]
        EXIT

 [ PhaseDetectBit <> 0
InterlaceLog_Code Entry "r0-r3", 16
        LDR     wp, [r12]
        SWI     XOS_WriteS
        DCB     "Fields: ", 0
        ALIGN
        LDRVC   r0, FieldCount                          ; load current value
        LDRVC   r3, PhaseErrors                         ; of total & error counts
        MOVVC   r1, #0                                  ; zero them to reset counts
        STRVC   r1, FieldCount
        STRVC   r1, PhaseErrors
        MOVVC   r1, sp
        MOVVC   r2, #16
        SWIVC   XOS_ConvertCardinal4
        MOVVC   r0, sp
        SWIVC   XOS_Write0
        EXIT    VS
        SWI     XOS_WriteS
        DCB     ", errors: ", 0
        MOVVC   r0, r3
        MOVVC   r1, sp
        MOVVC   r2, #16
        SWIVC   XOS_ConvertCardinal4
        MOVVC   r0, sp
        SWIVC   XOS_Write0
        SWIVC   XOS_NewLine
        EXIT
 ]

; *****************************************************************************
;
;       Message stuff


 [ PhaseDetectBit <> 0
  [ PhaseDetectOnPodule
;JER BODGE should add proper error.
NoPoduleError
        &       0
        =       "Can't find MPEG expansion card", 0
        ALIGN
  ]
 ]


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

;        InsertDebugRoutines

        END
