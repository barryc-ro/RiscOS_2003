; > Common

; Interlace module
; Provides 768 x 576 and 768 x 480 and 720 x 576 interlaced by multi-section mapping
; Combined source for all hardware variants and 50/51/55 variants
; Now has all modes in one binary
; This is the variant that does it by monitor description files

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Who  Version       Description
; ----       ---  -------       -----------
; 17-Dec-92  TMD  0.01          Started, from line-doubling sources
; 13-Dec-93  TMD  0.02          Converted for 768 x 576 (multi-section)
; 16-Dec-93  TMD  0.03          Converted for 16bpp
; 17-Mar-94  TMD  0.04          Now (hopefully) never gets into wrong interlace phase
; 12-Apr-94  TMD  0.05          Now copes if interlace is configured on
; 22-Apr-94  TMD  0.06          Moved picture 8 pixels to right
; 03-May-94  TMD  0.07          Version for no VRAM that uses 948K
; 02-Jun-94  TMD  0.08          Version at 15MHz pixel rate
; 21-Jun-94  TMD  0.09          Added InterlaceSwap command
; 01-Jul-94  JER  0.10          Test rebuild. No functional changes.
; 01-Jul-94  MT   0.11          Now reads physical interlace state from MPEG card
; 14-Sep-94  TMD  0.12          Grand unification for all h/w variants and 50/55 variants
; 19-Oct-94  TMD  0.13          (Conditionally) use Timer1 to generate IRQ part way down screen
;                                so we're immune from awful ATM/ShareFS interrupt latency.
; 25-Oct-94  TMD  0.14          Added 720 x 576 at 13.5MHz version (mode 51)
; 25-Oct-94  TMD  0.15          Separated out 'w' (ie 'v' using Timer1) variant.
; 01-Feb-95  TMD  0.16          Made it update OS_Byte(&B0) value (decrementing vsync counter)
;                                so bottom bit = 0 for top field, 1 for bottom field.
; 17-Feb-95  TMD  0.17		Change product-type matching code for recognition of podule:
;				 No longer match &0000, but do match &00F9.
; 21-Feb-95  TMD  0.18		Check IOMD type to determine which address to use for VSYNC device
;				 workspace and code.
; 21-Feb-95  TMD  0.19		Now a single binary provides modes 50,51 and 55 (still different
;				 binaries for different hardware variants)
; 23-Feb-95  TMD  0.20		Extra TAB in help string, now name is shorter.
; 03-May-95  TMD  0.21		Update to recognise ProdType_STB2_MPEG1.
; 06-Jun-95  TMD  0.22		Update to recognise ProdType_STB2_MPEG0 (ie Roadster).
; 12-Jun-95  TMD  0.23		Version that uses page-mapped areas rather than section-mapped.
; 22-Jun-95  TMD  0.24		Fix hardware scroll problem.
; 22-Jun-95  TMD  0.25		Add *HorizOffset command.
; 23-Jun-95  TMD  0.26		(Conditionally) use 1MB of logical space per field (rather than
;				 512K), so can do 768 x 576 x 32bpp (on VRAM machine)
; 26-Jun-95  TMD  0.27		Prevent it releasing vectors on Service_Reset, except on soft resets
; 09-Aug-95  TMD  0.28		Modified mode 56 to be true-256 colour.
; 22-Aug-95  TMD  0.29		Added mode 57 (PAL version of mode 56).
; 15-Sep-95  TMD  0.30		Change check to determine address of VSyncDevice vector to test for
;				 versions of the OS greater than or equal to 3.60, rather than using
;				 presence of ARM7500.
; 21-Sep-95  TMD  0.31		New mode 55 with better centering.
; 10-Oct-95  TMD  0.32		Add option to check system variable MPEG$PoduleNumber for override
;				 on podule number.
; 31-Oct-95  TMD  0.33		Add 58 + 59 (16 bit versions of 56,57)
; 09-Nov-95  TMD  0.34		Fixed incorrect header with wrong definition of STB2_MPEG0.
; 24-Nov-95  TMD  0.35		Put Macrovision modes in ourself for now.
; 27-Nov-95  TMD  0.36		Added modes 60 and 61 (640 x 440 x 8 or 16 bpp) for desktop use on
;				 NTSC TV.
; 27-Nov-95  TMD  0.37		Put in NTSC Macrovision modes too.
; 29-Nov-95  TMD  0.38		Changed NTSC desktop modes 60 and 61 to 640 x 400.
; 06-Dec-95  TMD  0.39		Modified timings for Macrovision modes.
; 18-Jan-96  JRH  0.40		If PhaseDetectBitInCLines is set, looks for PhaseDetectBit in
;                                the IOMD 8bit I/O CLines.
; 22-Jan-96  SMC  0.41          Modified Makefile to install ROM component properly.
; 08-Feb-96  JRH  0.42		Fixed up vsync entry in kernel device table for OS versions > 3.61.
;				Sets bit 8 in ModeFlags (mode is interlaced) for all modes.
; 12-Apr-96  TMD  0.43		Started on work to support interlaced modes in monitor definition files.
; 02-May-96  TMD  0.44		Fix cursor flashing problem on switch output back to screen.
; 09-May-96  TMD  0.45		Try to do mode numbers as well, but comment out cos doesn't work yet.
; 14-May-96  TMD  0.46		Set DisplayModeFlags to the same as ModeFlags, so kernel can spot interlaced modes and do
;				 an interlaced pointer.
; 18-Jul-96  TMD  0.47		Add variant for MPEG 2 card on STB 1.
; 11-Sep-96  TMD  0.48		Also check for STB2_MPEG2 product type on MPEG 2 variant.
; 22-Jun-98  TMD  0.49		Check VectorsClaimed on Service_ValidateAddress.

                GBLL    FixHWScroll
FixHWScroll     SETL    {TRUE}         ; does work now!

		GBLL	Use1MBPerField
Use1MBPerField	SETL	{TRUE}		; use 1MB per field, not 1MB per frame

		GBLL	TryToDoModeNumbers
TryToDoModeNumbers SETL {FALSE}		; doesn't work yet so comment out

; when initially turning on interlace, use a callback to wait until not in vsync

		GBLL	UseInitialCallBack
UseInitialCallBack SETL (PhaseDetectBit = 0) :LAND: {FALSE}

        LEADR   Module_LoadAddr

TAB     *       9
LF      *       10
FF      *       12
CR      *       13

; Bits in VduStatus

Windowing *     1 :SHL: 3
Shadowing *     1 :SHL: 4

 [ UseTimer1
Timer1LatchValue *      10000   ; 5ms, so well outside vsync, for both 50Hz and 60Hz modes
 ]

; Offsets from base of OSByte variables

CFSTime		*	&B0

	MACRO
	DefineWS

        ^       0, wp

VectorsClaimed  #       4
DummyScreenStart #      4
Phase           #       4
OldDeviceWS     #       4
OldDeviceCode   #       4
                #       3
OSWord16Block   #       5

OSByteVarBase	#	4
OtherStuffPtr	#	4
PageTablePhysAddr #	4		; physical address of page to use for L2PT for screen area
PageTablePPN	#	4		; physical page number of same page
PageTableLogAddr #	4		; logical address of same
ScreenPhysAddr	#	4		; physical address of screen
DynAreaNumber	#	4		; area number of our area
ShrinkOK	#	4		; NZ => shrink OK
 [ UseModeDescriptors
FindModeStructure #	12		; 3 words of crap
FindModeOtherOffset #	4		; offset to OtherStuff
FindModeOtherStuff #	OtherIndex_RecordSize ; static OtherStuff created from mode parameters
 |
VIDCListCopy	#	VIDCListSize	; copy of VIDC list, adjusted by corresponding HorizOffset command
HorizOffsets	#	nummodes*4	; horizontal offsets for each of our modes
 ]

 [ PhaseDetectBit <> 0
LastPhase               #       1       ; for field-to-field checks
spare                   #       3       ; (preserve data alignment)
FieldCount              #       4       ; how many fields since last mode change/error check
PhaseErrors             #       4       ; how many errors over that time
Podule_Base             #       4       ; address of base of podule
Podule_ControlStatus    #       4       ; address of podule control/status register
PoduleHeaderBuffer      #       16      ; used to read podule headers
 ]

 [ UseInitialCallBack
CallBackRequested	#	4	; NZ => callback requested
 ]

 [ MakeCFSCountPhase
CFSTimeAddr	#	4
 ]

 [ international
MessageFile_Block #     16
MessageFile_Open  #     4
 ]

Module_WorkspaceSize * :INDEX: @
	MEND

; **************** Module code starts here **********************

Module_BaseAddr

        &       0                               ; no app start entry
        &       Mod_Init    -Module_BaseAddr
        &       Mod_Die     -Module_BaseAddr
        &       Mod_Service -Module_BaseAddr
        &       Mod_Title   -Module_BaseAddr
        &       Mod_HelpStr -Module_BaseAddr
        &       Mod_HC_Table-Module_BaseAddr
        &       0 ; SWI chunk
        &       0 ; Mod_SWIHandler-Module_BaseAddr
        &       0 ; Mod_SWITable-Module_BaseAddr
        &       0                               ; no swi name decode entry

Mod_Title
        =       "Interlace", 0

Mod_HelpStr
        =       ModuleHelp, TAB, TAB, Module_MajorVersion, " (", Module_Date, ")", 0
        ALIGN

Mod_HC_Table
        Command InterlaceSwap,  0, 0
 [ PhaseDetectBit <> 0
        Command InterlaceLog,   0, 0
 ]
 [ :LNOT: UseModeDescriptors
	Command HorizOffset,	2, 2
 ]
        =       0                       ; terminate table

InterlaceSwap_Help
        =       "*InterlaceSwap swaps the interlace phase.", CR
InterlaceSwap_Syntax
        =       "Syntax: *InterlaceSwap", 0
        ALIGN
 [ PhaseDetectBit <> 0
InterlaceLog_Help
        =       "*InterlaceLog reports and resets phase error counts.", CR
InterlaceLog_Syntax
        =       "Syntax: *InterlaceLog", 0
        ALIGN
 ]

 [ :LNOT: UseModeDescriptors
HorizOffset_Help
	=	"*HorizOffset sets a horizontal offset for an interlaced screen modes", CR
HorizOffset_Syntax
	=	"Syntax: *HorizOffset <mode> <offset>", 0
	ALIGN
 ]
 [ :LNOT: UseModeDescriptors :LOR: TryToDoModeNumbers
	OutputModeInfo
 |
	GBLA	maxyres
maxyres SETA	1280
 ]
	DefineWS

; *****************************************************************************
;
;       Mod_Init - Initialisation entry
;

Mod_Init Entry "r7, r8"
        LDR     r2, [R12]               ; have we got workspace yet ?
        TEQ     r2, #0
        BNE     %FT05

        MOV     r0, #ModHandReason_Claim
        MOV     r3, #Module_WorkspaceSize
        SWI     XOS_Module
        EXIT    VS

; r2 -> workspace

        STR     r2, [r12]               ; save address in my workspace pointer,
                                        ; so Tutu can free it for me when I die
05
        MOV     r12, r2

        MOV     r0, #0
        STR     r0, VectorsClaimed
 [ UseInitialCallBack
	STR	r0, CallBackRequested
 ]

 [ :LNOT: UseModeDescriptors
	ADR	r1, HorizOffsets
	MOV	r2, #?HorizOffsets
07
	STR	r0, [r1], #4		; zero out the horizontal offsets
	SUBS	r2, r2, #4
	BNE	%BT07
 ]

 [ PhaseDetectBit <> 0
        STR     r0, FieldCount
        STR     r0, PhaseErrors
        MOV     r0, #&FF
        STRB    r0, LastPhase           ; so it won't compare equal, no error
 ]

        MOV     r0, #2
        STRB    r0, OSWord16Block +0    ; switch display only

        LDR     r0, =DummyScreen
        STR     r0, DummyScreenStart

	MOV	r0, #&A6		; read base of OS_Byte variables
	MOV	r1, #0
	MOV	r2, #&FF
	SWI	XOS_Byte
	ORR	r1, r1, r2, LSL #8	; merge low and high bytes
	STR	r1, OSByteVarBase	; save address for future use

 [ PhaseDetectBit <> 0
; JER set up address of MPEG podule to read frame interlace bit.
   [ PhaseDetectOnPodule
        BL      FindPoduleNumber
	EXIT	VS

        MOV     r0, #Podule_ReadInfo_EASILogical
        ADR     r1, Podule_Base
        MOV     r2, #4
        SWI     XPodule_ReadInfo
     [ CheckPoduleVariable
	MOVVS	r0, r3, LSL #24		; if get error, then do it by hand, as it might be a
	ORRVS	r0, r0, #&88000000	; podule without an EPROM
	STRVS	r0, Podule_Base
     |
        EXIT    VS
     ]
        LDR     r0, Podule_Base
        ADD     r1, r0, #PhaseDetectOffset
   |
	LDR	r1, =PhaseDetectOffset ; bit not on podule, it's at an absolute address (probably IOMD CLINES)
   ]

        STR     r1, Podule_ControlStatus
 ]

; now set up page-mapped area

	LDR	r1, =&05000000
	BL	LogToPhys
	EXIT	VS
	STR	r2, ScreenPhysAddr

	LDR	r1, =L1PT
	BL	LogToPhys
	EXIT	VS
	MOV	r4, r2, LSR #12		; save physical memory page index for L1PT

	MOV	r0, #6			; read size of physical memory table
	SWI	XOS_Memory
	EXIT	VS

	MOV	r3, r1
	MOV	r0, #ModHandReason_Claim
	SWI	XOS_Module
	EXIT	VS

	MOV	r0, #7			; read table
	MOV	r1, r2
	SWI	XOS_Memory
	BVS	%FT90			; exit freeing block

; now find free page

10
	CMP	r4, r3, LSL #1		; have we gone off the end
	BCS	%FT85			; [couldn't find free page]
	LDRB	r5, [r2, r4, LSR #1]
	TST	r4, #1
	MOVNE	r5, r5, LSR #4
	ANDEQ	r5, r5, #15
	TEQ	r5, #1			; is it free DRAM?
	ADDNE	r4, r4, #1
	BNE	%BT10

	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module		; free the table memory
	EXIT	VS

	MOV	r4, r4, LSL #12		; physical address of page to take
	STR	r4, PageTablePhysAddr

	Push	"r0,r1,r4"		; create page block with phys addr at offset 8
	LDR	r0, =0 + (1 :SHL: 10) + (1 :SHL: 11) ; phys addr to ppn
	MOV	r1, sp
	MOV	r2, #1
	SWI	XOS_Memory
	STRVS	r0, [sp]
	Pull	"r0,r1,r4"
	EXIT	VS

	STR	r0, PageTablePPN

	MOV	r0, #0			; create dynamic area
	STR	r0, ShrinkOK		; can't shrink it at moment
	MOV	r1, #-1			; area number - RISC OS to allocate
	MOV	r2, #4096		; initial size - 1 page (never changes)
	MOV	r3, #-1			; base address - RISC OS to allocate
	MOV	r4, #1 :SHL: 8		; flags (need particular physical pages)
	MOV	r5, #4096		; maximum size (only 1 page needed)
	ADR	r6, DynAreaHandler
	MOV	r7, wp
	ADR	r8, DynAreaTitle
	SWI	XOS_DynamicArea
	EXIT	VS

	STR	r1, DynAreaNumber	; save number so we can remove area later
	STR	r3, PageTableLogAddr	; save log address for later poking

        CLRV
        EXIT

; couldn't allocate page tables

85
	ADR	r0, Level2AllocateFailError

; free block and exit returning error

90
	Push	"r0"
	MOV	r0, #ModHandReason_Free
	SWI	XOS_Module
	Pull	"r0"
	SETV
	EXIT

Level2AllocateFailError
	&	1
	=	"Couldn't allocate page table memory for interlaced mode", 0

DynAreaTitle
	=	"Interlace support", 0
	ALIGN

; Convert logical to physical address
; in:	r1 = log address
; out:	r2 = phys address

LogToPhys Entry "r0,r1"
	Push	"r0-r2"		; create page block on stack with log address at offset 4
	LDR	r0, =0 + (1 :SHL: 9) + (1 :SHL: 13) ; log address to phys address
	MOV	r1, sp
	MOV	r2, #1
	SWI	XOS_Memory
	STRVS	r0, [sp, #3*4]
	Pull	"r0-r2"
	EXIT

DynAreaHandler ROUT
        CMP     r0, #1
        BHI     %FT30		; check shrink
        BEQ     %FT20		; post grow

; Pre-grow

        TEQ     r4, #0          ; only allow grow if zero size to start
        BNE     CantGrowError
        STMFD   r13!, {r0-r2}
        LDR     r0, PageTablePPN
10
        STR     r0, [r1], #12
        ADD     r0, r0, #1
        SUBS    r2, r2, #1
        BNE     %BT10
        LDMFD   r13!, {r0-r2}
20
        BICS    pc, r14, #V_bit

30
        STMFD   r13!, {r14}
        LDR     r14, ShrinkOK
        CMP     r14, #0         ; NB clears V
        LDMFD   r13!, {r14}
        MOVNE   pc, r14         ; NE => preshrink or postshrink OK
        ADR     r0, CantShrinkErrorBlock
        B       ReportError

CantGrowError
        ADR     r0, CantGrowErrorBlock
ReportError
        CMP     pc, #&80000000  ; set V
        MOV     pc, r14

CantGrowErrorBlock
        &	1
	=	"Can't grow this area any more", 0
        ALIGN

CantShrinkErrorBlock
        &	1
	=	"Can't shrink this area", 0
        ALIGN

 [ PhaseDetectBit <> 0
  [ PhaseDetectOnPodule
; **************************************************************************
;
;       FindPoduleNumber
;
; in:   -
;
; out:  r3 = podule number, if VC, otherwise corrupted
;       All other registers preserved
;

FindPoduleNumber Entry "r0-r2"
 [ CheckPoduleVariable
	Push	"r3,r4"
	ADR	r0, PoduleVariableName
	ADR	r1, PoduleHeaderBuffer
	MOV	r2, #?PoduleHeaderBuffer	; length of buffer
	MOV	r3, #0				; first (and only) call
	MOV	r4, #3				; expand to a string
	SWI	XOS_ReadVarVal
	Pull	"r3,r4"
	BVS	%FT05

	MOV	r0, #0
	STRB	r0, [r1, r2]			; terminate string

	Push	"r1"
	SWI	XPodule_ReturnNumber
	Pull	"r1"
	BVS	%FT90

	SUB	r2, r0, #1			; maximum podule number
	MOV	r0, #1<<29			; use limit
	SWI	XOS_ReadUnsigned
	BVS	%FT05

	MOV	r3, r2				; copy value into r3
	EXIT

PoduleVariableName
	=	MPEGCardVariableName, 0
	ALIGN

05
 ] ; CheckPoduleVariable
        SWI     XPodule_ReturnNumber
	BVS	%FT90
        SUB     r3, r0, #1              ; r6 = max podule number
        ADR     r2, PoduleHeaderBuffer
10
        SWI     XPodule_ReadHeader
        BVS     %FT20
        LDRB    r0, [r2, #3]
        LDRB    r1, [r2, #4]

; This code changed by TMD 17-Feb-95
; No longer allow &0000 in any version
; Allows &00FF or &00F9

        ORR     r0, r0, r1, LSL #8
 [ IsMPEG2
	LDR	lr, =ProdType_STB1_MPEG2	; check for STB1 MPEG2
	CMP	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG2	; or STB2 MPEG2
	CMPNE	r0, lr
 |
	CMP	r0, #ProdType_MPEGDecoder 	; allow new
        CMPNE   r0, #&FF                	; or old types (V := 0)
	LDRNE	lr, =ProdType_STB2_MPEG1	; also allow STB2 MPEG 1 product type
	CMPNE	r0, lr
	LDRNE	lr, =ProdType_STB2_MPEG0	; also allow Roadster product type
	CMPNE	r0, lr
 ]
        EXIT    EQ
20
        SUBS    r3, r3, #1
        BPL     %BT10
        ADRL    r0, NoPoduleError
        SETV
90
	STR	r0, [sp]
        EXIT
  ] ; PhaseDetectOnPodule
 ] ; PhaseDetect <> 0

; *****************************************************************************
;
;       Mod_Die - Die entry
;

Mod_Die Entry
        LDR     wp, [r12]

; insert anything we need here!

	LDR	r0, VectorsClaimed
	TEQ	r0, #0
	BNE	%FT90			; [on vectors, so must be in interlace mode, so not safe to die]

; safe to die

        LDR     r0, =L1PT+(DummyScreen :SHR: 18)   ; start of relevant L1
 [ Use1MBPerField
	MOV	r3, #maxyres
 |
        MOV     r3, #maxyres/2          ; number of 1MB mappings required
 ]
	MOV	r1, #0			; no access to this area any more
10
        STMIA   r0!, {r1}
        SUBS    r3, r3, #1
        BNE     %BT10

	MOV	r0, #1			; remove dynamic area
	STR	r0, ShrinkOK
	LDR	r1, DynAreaNumber
	SWI	XOS_DynamicArea

        CLRV
        EXIT

; can't die, cos we're in an interlace mode currently

90
	ADR	r0, CantDieError
	SETV
	EXIT

CantDieError
	&	1
	=	"Interlace module cannot die: interlaced mode in use", 0
	ALIGN

; *****************************************************************************
;
;       Mod_Service - Main entry point for services
;
; in:   R1 = service reason code
;
; out:  R1 = 0 if we claimed it
;

Mod_Service ROUT
        TEQ     r1, #Service_ModeExtension
        TEQNE   r1, #Service_ModeChange
        TEQNE   r1, #Service_Reset
        TEQNE   r1, #Service_ModeChanging
        TEQNE   r1, #Service_ValidateAddress
 [ FixHWScroll
        TEQNE   r1, #Service_SwitchingOutputToSprite
 ]
        MOVNES  pc, lr

        LDR     wp, [r12]

        TEQ     r1, #Service_ModeChange
        BEQ     svc_ModeChange

        TEQ     r1, #Service_Reset
        BEQ     svc_Reset

        TEQ     r1, #Service_ModeChanging
        BEQ     svc_ModeChanging

        TEQ     r1, #Service_ValidateAddress
        BEQ     svc_ValidateAddress

 [ FixHWScroll
        TEQ     r1, #Service_SwitchingOutputToSprite
        BEQ     svc_SwitchingOutputToSprite
 ]

; In the new implementation, the interlaced modes are monitor description file modes,
; so the ScreenModes module claims the service.
;
; However, for backwards compatibility, we provide the numbered modes by translating the mode number
; into a mode descriptor and re-issuing the service.

 [ UseModeDescriptors
  [ TryToDoModeNumbers
svc_ModeExtension Entry "r0"
	CMP	r2, #&100
	EXIT	CS				; if not a mode number, do nothing

	ADRL	r0, ModeListTable
10
	LDR	lr, [r0]
	CMP	lr, #-1
	EXIT	EQ				; didn't find mode in list, so exit
	TEQ	r2, lr
	ADDNE	r0, r0, #8
	BNE	%BT10				; [not this mode, so try next]

	LDR	r2, [r0, #4]			; load offset to mode descriptor
	ADD	r2, r2, r0			; convert to absolute address
	SWI	XOS_ServiceCall
	EXIT					; whether or not it's claimed, we exit, having made r2->mode descriptor
						; if claimed, r1 will have be set to 0, and r3->VIDClist, r4 probably 0 (wslist)
  |
svc_ModeExtension MOV pc, lr			; don't do anything, cos it doesn't work yet
  ]
 |
svc_ModeExtension Entry "r0,r5"
	BL	FindMode
	EXIT	EQ				; if not one of ours, exit

	LDMIB	r0, {r3, r4, r5}		; skip mode number, get offsets from r0 to VIDCList and WSList + other stuff
	ADD	r3, r3, r0
	ADD	r4, r4, r0
	ADD	r5, r5, r0
	LDR	r5, [r5, #OtherIndex_ModeIndex]
	MOV	r5, r5, LSL #2
	ADD	r5, r5, #:INDEX: HorizOffsets
	LDR	r5, [wp, r5]			; get appropriate horiz offset

	ADR	r0, VIDCListCopy
	MOV	lr, #VIDCListSize-4
10
	LDR	r1, [r3, lr]			; copy VIDC list into workspace block
	STR	r1, [r0, lr]
	SUBS	lr, lr, #4
	BCS	%BT10

	Push	"r2,r4,r6,r7"
	ADD	r1, r0, #VIDCListIndex_HSW
	LDMIA	r1, {r1,r2,r3,r4,r6,r7}		; load hsw,hbp,hb1,hdis,hb2,hfp

	CMP	r5, #0
	BLT	%FT50				; [move to left]

; it's a move to the right

	CMP	r5, r6				; is offset <= right border
	SUBLS	r6, r6, r5			; if so then reduce right border
	ADDLS	r3, r3, r5			; and increase left border
	BLS	%FT90				; and we're done

	SUB	r5, r5, r6			; else do as much as we can from border
	ADD	r3, r3, r6			; which we put onto left border
	MOV	r6, #0				; no right border left

	CMP	r5, r7				; is remaining offset <= front porch
	SUBLS	r7, r7, r5			; if so then reduce front porch
	ADDLS	r2, r2, r5			; and increase back porch
	BLS	%FT90				; and we're done

	SUB	r5, r5, r7			; else do as much as we can from front porch
	ADD	r2, r2, r7			; which we put onto back porch
	MOV	r7, #0				; no back porch left

	CMP	r5, r1				; is remaining offset <= sync width
	MOVHI	r5, r1				; if more then tough
	SUB	r1, r1, r5			; if so then reduce sync width (dodgy!)
	ADD	r2, r2, r5			; and put it in back porch
	B	%FT90				; and we're done

; it's a move to the left

50
	RSB	r5, r5, #0			; make offset +ve
	CMP	r5, r3				; is offset <= left border
	SUBLS	r3, r3, r5			; if so then reduce left border
	ADDLS	r6, r6, r5			; and increase right border
	BLS	%FT90				; and we're done

	SUB	r5, r5, r3			; else do as much as we can from border
	ADD	r6, r6, r3			; which we put onto right border
	MOV	r3, #0				; no left border left

	CMP	r5, r2				; is remaining offset <= back porch
	MOVHI	r5, r2				; if not then most we can do is back porch
	SUB	r2, r2, r5			; if so then reduce back porch
	ADD	r7, r7, r5			; and increase front porch
90
	ADD	r5, r0, #VIDCListIndex_HSW
	STMIA	r5, {r1,r2,r3,r4,r6,r7}		; store updated values
	Pull	"r2,r4,r6,r7"
	MOV	r3, r0				; point r3 at copy
        MOV     r1, #0
	EXIT
 ] ; UseModeDescriptors

svc_ModeChange  Entry "r0-r2"
	BL	FindMode
	EXIT	EQ

	LDR	r2, [r0, #12]			; get offset to other info
	ADD	r2, r2, r0
	STR	r2, OtherStuffPtr

	BL	SetupMemoryMap

	Push	"r2"
	MOV	r0, #2
	SWI	XOS_ReadDynamicArea
	Pull	"r2"
	LDR	r0, [r2, #OtherIndex_ScreenSize]
	VDWS	lr
	STR	r0, [lr, #ScreenSize]
	SUBS	r1, r0, r1			; needed size - current size

	MOV	r0, #2				; always set to exactly the right size (may be too big *or too little* now)
	SWI	XOS_ChangeDynamicArea		; so Wimp doesn't do it itself after we've screwed the variables up

        MOV     r0, #&C0000000
        STR     r0, Phase

	; Claim the vectors early so that if anyone calls OS_SpriteOP 60 (Switch output to Sprite) we can override the
	; line length set by the kernel.  This was happening during SWI OS_WriteI+12 (below).
        BL      ClaimVectors

        VDWS    r0

 [ :LNOT: UseModeDescriptors
	LDR	r1, [r2, #OtherIndex_PalIndex]	; no need to mess around with palette now
        STR     r1, [r0, #PalIndex]
        SWI     XOS_WriteI + 20
 ]
	BL	ModifyVars

        LDR     r1, DummyScreenStart
        STR     r1, [r0, #ScreenStart]
        STR     r1, [r0, #DisplayStart]
        STR     r1, [r0, #DisplayBankAddr]
        STR     r1, [r0, #DriverBankAddr]
        STR     r1, [r0, #DisplayScreenStart]

        LDR     r1, [r2, #OtherIndex_YRes]
	MOV	r1, r1, LSR #1
	SUB	r1, r1, #1			; DisplayYWindLimit = yres/2-1
        STR     r1, [r0, #DisplayYWindLimit]

	LDR	r1, [r0, #YEigFactor]
        ADD	r1, r1, #1			; don't use constant 2 any more, so we can support weird YEig modes
        STR     r1, [r0, #DisplayYEigFactor]

        SWI     XOS_WriteI+12
        EXITS

ModifyVars Entry "r2"
 [ UseModeDescriptors
	SWI	XOS_RemoveCursors		; remove flashing cursor while we mess about

	LDR	r1, [r2, #OtherIndex_LineLength]
	STR	r1, [r0, #LineLength]
	MOV	lr, r1, LSL #3
	STR	lr, [r0, #RowLength]
	SUB	r1, lr, r1
	ADD	r2, r0, #CursorStartOffset
	ASSERT	CursorEndOffset = CursorStartOffset +4
	STMIA	r2, {r1, lr}
	BL	AddressCursors			; recompute CursorAddr, InputCursorAddr
	SWI	XOS_RestoreCursors
 ]

        LDR     r1, [r0, #ModeFlags]
        ORR     r1, r1, #Flag_HardScrollDisabled :OR: Flag_InterlacedMode
        STR     r1, [r0, #ModeFlags]
 [ UseModeDescriptors
	STR	r1, [r0, #DisplayModeFlags]
 ]

        LDR     r1, [r0, #VduStatus]
        ORR     r1, r1, #Windowing
        STR     r1, [r0, #VduStatus]
	EXITS

        LTORG

 [ UseModeDescriptors
AddressCursors Entry "r0-r4,r12"
	VDWS	r12
	LDR	lr, [r12, #CursorFlags]
	TST	lr, #CursorsSplit
	BLNE	AddressInputCursor
	LDR	r0, [r12, #CursorX]
	LDR	r1, [r12, #CursorY]
	BL	AddressR0R1
	STR	r2, [r12, #CursorAddr]
	EXIT

AddressInputCursor Entry
	LDR	r0, [r12, #InputCursorX]
	LDR	r1, [r12, #InputCursorY]
	BL	AddressR0R1
	STR	r2, [r12, #InputCursorAddr]
	EXIT

AddressR0R1 ROUT
	LDR	r4, [r12, #RowLength]
	LDR	r3, [r12, #Log2BPC]
	LDR	r2, [r12, #ScreenStart]		; start address of top of screen
	ADD	r2, r2, r0, LSL r3		; add in X component
	MLA	r2, r4, r1, r2			; add in Y * RowLength
	MOV	pc, lr
 ]

 [ FixHWScroll
svc_SwitchingOutputToSprite Entry "r0-r2"
	LDR	r0, VectorsClaimed
	TEQ	r0, #0
	EXIT	EQ			; not in interlaced mode, so exit

        VDWS    r0
        TEQ     r4, #0                  ; are we switching to screen?
  [ UseModeDescriptors
; On switching back to the screen, the kernel restores the variable LineLength to the
; value returned from ReadModeVariable, ie the number of bytes on one line, not the enormous
; skip we require. This would not normally be a problem, since we get Service_SwitchingOutputToSprite
; when switching back to the screen, so we can patch it up again.

; However, the kernel restores the flashing cursor *before* issuing the service, and this does effectively
;   FOR i=CursorStartOffset TO CursorEndOffset-1 STEP LineLength: toggle CursorAddr?i: NEXT
; and CursorStartOffset and CursorEndOffset are an enormous distance apart, not all of which is mapped in,
; thus causing a data abort.

; To get around the problem we nobble CursorStartOffset and CursorEndOffset when output is switched away from
; the screen, so that on the return to the screen, the flashing code thinks the cursor is zero height and doesn't
; toggle anything.

; NB. we set CursorEndOffset to zero before CursorStartOffset, just in case there's a flash in between

	MOVNE	lr, #0				; if switching to sprite
	STRNE	lr, [r0, #CursorEndOffset]	; make cursorstartoffset >= cursorendoffset
	STRNE	lr, [r0, #CursorStartOffset]	; so no cursor flashing will occur
	LDR	r1, =SavedCursorEndOffset
	STRNE	lr, [r0, r1]			; make cursorstartoffset >= cursorendoffset
	LDR	r1, =SavedCursorStartOffset
	STRNE	lr, [r0, r1] 			; so no cursor flashing will occur
  ]
        EXIT    NE                      ; no, then exit

	LDR	r2, OtherStuffPtr
	BL	ModifyVars
        EXIT
 ]

svc_ModeChanging Entry
        BL      ReleaseVectors
        EXITS

svc_Reset Entry "r0-r2"
	MOV	r0, #&FD
	MOV	r1, #0
	MOV	r2, #&FF
	SWI	XOS_Byte
	TEQ	r1, #0
        BLEQ    ReleaseVectors
        EXITS

svc_ValidateAddress Entry "r0"
	LDR	lr, VectorsClaimed	; TMD 22-Jun-98: first check if we're in interlaced mode, so that
	TEQ	lr, #0			; indirection off OtherStuffPtr doesn't go bang!
	EXITS	EQ

        LDR     lr, DummyScreenStart
        CMP     r2, lr
        CMPCS   r3, lr
        EXITS   CC

	LDR	r0, OtherStuffPtr
	LDR	r0, [r0, #OtherIndex_YRes]
 [ Use1MBPerField
	ADD	lr, lr, r0, LSL #20 ; add on total amount of logical space for screen = yres * 1024K
 |
        ADD     lr, lr, r0, LSL #19 ; add on total amount of logical space for screen = yres * 512K
 ]
        CMP     r2, lr
        CMPLS   r3, lr
        MOVLS   r1, #0
        EXITS

        LTORG

 [ UseModeDescriptors
; Check whether mode in r2 is interlaced - we do this by issuing Service_ModeExtension and if this
; returns a VIDC list with the new video parameter on the end, then it is.
; If so, we then need to create a fake structure for this mode - in practice only the 'OtherInfo'
; part gets used but we keep the same structure for simplicity.

; Unfortunately Service_ModeExtension needs the video bandwidth and video DRAM size to be passed in,
; Service_ModeChange (where we're called from) doesn't give us this information
; for the time being make it up and assume there isn't both a non-interlaced *and* interlaced form of a mode
; in the same file.

; in:	r2 = mode
;	r3 = monitor type
; out:	r0 -> structure

FindMode Entry "r1-r5"
	MOV	r1, #Service_ModeExtension
	LDR	r4, =160000000		; 160E6 bytes/sec
	MOV	r5, #2048*1024		; 2MB video ram
	SWI	XOS_ServiceCall
	TEQ	r1, #0
	BNE	%FT90 			; [unclaimed, so don't think it's interlaced]

	LDR	lr, [r3, #VIDCListIndex_Type]
	TEQ	lr, #3			; if not type 3, forget it
	BNE	%FT90

	ADD	lr, r3, #VIDCListIndex_VideoControlParameters
10
	LDR	r0, [lr], #8
	CMP	r0, #-1
	BEQ	%FT90			; didn't find our entry

	TEQ	r0, #VideoControlParametersIndex_Interlaced
	BNE	%BT10			; if not ours then we've already skipped value, so loop
	LDR	r0, [lr, #-4]		; read value
	TEQ	r0, #1			; if not 1
	BNE	%FT90			; then not interlaced

; we have an interlaced screen mode!

	MOV	r0, r2			; r0 = mode
	MOV	r1, #VduExt_Log2BPP
	SWI	XOS_ReadModeVariable
	Push	"r2"			; save pixdepth
	MOV	r1, #VduExt_YWindLimit
	SWI	XOS_ReadModeVariable
	ADD	r2, r2, #1		; r2 = yres
	Push	"r2"
	MOV	r1, #VduExt_XWindLimit
	SWI	XOS_ReadModeVariable
	ADD	r2, r2, #1		; r2 = xres

	Pull	"r4,r5"			; r4 = yres; r5 = pixdepth
	STR	r4, FindModeOtherStuff+OtherIndex_YRes
	MOV	lr, r2, LSL r5		; lr = (xres << pixdepth)
	MOV	lr, lr, LSR #3+1	; actual linelength/2 in bytes
 [ Use1MBPerField
	ADD	r0, lr, #1024*1024	; r0 = RISC OS linelength
 |
	ADD	r0, lr, #512*1024
 ]
	STR	r0, FindModeOtherStuff+OtherIndex_LineLength
	MUL	r0, r4, lr		; r0 = size of one field
	LDR	r1, =&FFF		; r1 = page mask
	ADD	r0, r0, r1
	BIC	r2, r0, r1		; firstfieldsize
	STR	r2, FindModeOtherStuff+OtherIndex_PageOffset2ndField
	ADD	r3, r2, lr		; physical offset from bank 1 to 2
	STR	r3, FindModeOtherStuff+OtherIndex_Offset1To2
	ADD	r3, r0, lr
	BIC	r3, r3, r1		; secondfieldsize
	ADD	r3, r3, r2		; firstfieldsize + secondfieldsize
	STR	r3, FindModeOtherStuff+OtherIndex_ScreenSize

	MOV	r0, #FindModeOtherStuff - FindModeStructure
	STR	r0, FindModeOtherOffset
	ADR	r0, FindModeStructure

	TEQ	r0, #0			; set NE
	EXIT

90
	TEQ	r0, r0			; set EQ indicating not found
	EXIT

 |
; Check whether mode number in r2 matches one of our modes
; If it does, then exits NE, and r0 -> structure for that mode, else exits EQ, r0 corrupted

FindMode Entry
	ADRL	r0, ModeListTable
10
	LDR	lr, [r0], #16			; get mode number
	CMP	lr, #-1
	EXIT	EQ
	TEQ	r2, lr
	BNE	%BT10
	SUBS	r0, r0, #16			; point r0 back at entry, and set NE
	EXIT
 ]

; SetupMemoryMap - setup L1 and L2 pages for current screensize
; in:	r2 -> OtherStuff

SetupMemoryMap Entry "r0,r1,r3-r5"

; first set up L2 entries

	LDR	r0, ScreenPhysAddr
	LDR	r1, =L2_SmallPage + (AP_Full * L2_APMult) + L2_B
	ADD	r0, r0, r1		; base L2 entry for 1st 512K (or 1024K)
	LDR	r1, [r2, #OtherIndex_PageOffset2ndField]
	ADD	r1, r1, r0		; r1 is entry for 2nd field
	LDR	r3, PageTableLogAddr	; r3 -> 1st half of L2 page (or 1st L2 page)
 [ Use1MBPerField
	MOV	r5, #1024		; number of bytes in each half
 |
	MOV	r5, #512		; number of bytes in each half
 ]
	ADD	r4, r3, r5		; point at 2nd half of L2 page (or 2nd L2 page)
10
	STR	r0, [r3], #4
	STR	r1, [r4], #4
	ADD	r0, r0, #&1000
	ADD	r1, r1, #&1000
	SUBS	r5, r5, #4
	BNE	%BT10

; finally set up L1 entries

        LDR     r1, PageTablePhysAddr   ; get physical address of L2
        LDR     r0, =L1_U + L1_Page
        ORR     r1, r1, r0

        LDR     r0, =L1PT+(DummyScreen :SHR: 18)   ; start of relevant L1
	LDR	r3, [r2, #OtherIndex_YRes]
	MOV	r3, r3, LSR #1		; number of 1MB (or 2MB) mappings required
 [ Use1MBPerField
	ADD	r5, r1, #&400		; 2nd L1 entry, pointing at 2nd L2 page
20
        STMIA   r0!, {r1,r5}
 |
20
        STMIA   r0!, {r1}
 ]
        SUBS    r3, r3, #1
        BNE     %BT20

	MOV	r0, #0
	SetCop	r0, CR_TLBFlush		; L1 and L2 modified, so flush TLB (no need to flush IDC, as area not cacheable)
	EXIT

ClaimVectors Entry "r0-r6"
        LDR     r0, VectorsClaimed
        TEQ     r0, #0
        EXITS   NE

 [ UseTimer1
        MOV     r0, #6          ; Timer 1 device
        ADR     r1, MyTimer1Device
        MOV     r2, wp
        SWI     XOS_ClaimDeviceVector
 ]

 [ {TRUE}
; check version number of UtilityModule (1st module) is < 360, 360/361, or > 361
; (don't use presence of ARM7500, as 3.60 is available on RISC PC)
	MOV	r0, #ModHandReason_EnumerateROM_ModulesWithInfo
	MOV	r1, #0				; find 1st ROM module (hopefully UtilityModule)
	MOV	r2, #-1				; main ROM section
	SWI	XOS_Module
	MOVVS	r6, #0				; if error, assume old (shouldn't get error!)
	LDR	r0, =VSyncDeviceWS7500		; default address for 3.60 / 3.61
	CMP	r6, #&36000			; if version < 3.60
	LDRCC	r0, =VSyncDeviceWS		; then use old address
	LDRHI	r2, =&36100
	CMPHI	r6, r2				; if version > 3.61
	LDRHI	r0, =VSyncDeviceWSwIRQC		; then use new address
 |
	MOV	r0, #2
	SWI	XOS_ReadSysInfo
	TST	r2, #&FF :SHL: 8		; test IOMD variant (EQ => old IOMD)
	LDREQ	r0, =VSyncDeviceWS		; if old then use old address
        LDRNE   r0, =VSyncDeviceWS7500		; if new then use new address
 ]

        LDMIA   r0, {r1, r2}
        ADR     r0, OldDeviceWS
        STMIA   r0, {r1, r2}

        MOV     r0, #3
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_ClaimDeviceVector

 [ {FALSE}
        MOV     r0, #ByteV
        ADRL    r1, MyByte
        MOV     r2, wp
        SWI     XOS_Claim

        MOV     r0, #WordV
        ADRL    r1, MyWord
        VDWS    r2
        SWI     XOS_Claim
 ]

        MOV     r0, #1
        STR     r0, VectorsClaimed
        EXITS

        LTORG

ReleaseVectors Entry "r0-r2"
        LDR     r0, VectorsClaimed
        TEQ     r0, #0
        EXITS   EQ

 [ {FALSE}
        MOV     r0, #WordV
        ADRL    r1, MyWord
        VDWS    r2
        SWI     XOS_Release

        MOV     r0, #ByteV
        ADRL    r1, MyByte
        VDWS    r2
        SWI     XOS_Release
 ]

        MOV     r0, #3
        ADR     r1, MyVSyncDevice
        MOV     r2, wp
        SWI     XOS_ReleaseDeviceVector

 [ UseTimer1
        MOV     r0, #6          ; Timer 1 device
        ADR     r1, MyTimer1Device
        MOV     r2, wp
        SWI     XOS_ReleaseDeviceVector
 ]

 [ UseInitialCallBack
	ADR	r0, InterlaceCallBack
	MOV	r1, wp
	SWI	XOS_RemoveCallBack
	MOV	r0, #0
	STR	r0, CallBackRequested
 ]
        MOV     r0, #0
        STR     r0, VectorsClaimed
        EXITS

MyVSyncDevice ROUT
        SUB     sp, sp, #8
        Push    "r0-r3, lr"
 [ UseTimer1
        BL      StartTimer1
 |
        BL      DoInterlace
 ]
        ADR     r0, OldDeviceWS
        LDMIA   r0, {r0, r1}
        STR     r0, [sp, #5*4]
        STR     r1, [sp, #6*4]
        Pull    "r0-r3, lr"
        Pull    "r12, pc"
        EXIT

 [ UseTimer1
; On entry, r3 -> IOC

StartTimer1     Entry   "r0-r1"
        MOV     r0, #Timer1LatchValue :AND: 255
        STRB    r0, [r3, #Timer1LL]
        MOV     r0, #Timer1LatchValue :SHR: 8
        STRB    r0, [r3, #Timer1LH]
        STRB    r0, [r3, #Timer1GO]
        MOV     r0, #timer1_bit
        STRB    r0, [r3, #IOCIRQCLRA]           ; clear the latched IRQ
        STRB    r0, [r3, #IOCIRQCLRA]           ; and again in case it just underflowed
        MOV     r0, pc
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; disable IRQs round enabling of timer1 IRQ
        NOP
        LDRB    r1, [r3, #IOCIRQMSKA]
        ORR     r1, r1, #timer1_bit
        STRB    r1, [r3, #IOCIRQMSKA]
  [ {FALSE}
        Push    "r0,r1,lr"
        MOV     r0, #12
        ADR     r1, RedBlock
        SWI     XOS_Word
        Pull    "r0,r1,lr"
  ]
        TEQP    r0, #0
        NOP
        EXIT

  [ {FALSE}
RedBlock
        =       0, 1, 0,0,0
BlueBlock
        =       0, 4, 0,0,0
        ALIGN
  ]

MyTimer1Device  Entry "r0-r3"
        MOV     r0, pc
        TEQP    pc, #SVC_mode + I_bit + F_bit   ; disable IRQs round disabling of timer1 IRQ
        NOP
        LDRB    r1, [r3, #IOCIRQMSKA]
        BIC     r1, r1, #timer1_bit             ; disable IRQ in mask
        STRB    r1, [r3, #IOCIRQMSKA]
  [ {FALSE}
        Push    "r0,r1,lr"
        MOV     r0, #12
        ADR     r1, BlueBlock
        SWI     XOS_Word
        Pull    "r0,r1,lr"
  ]
        TEQP    r0, #0
        NOP
        MOV     r0, #timer1_bit
        STRB    r0, [r3, #IOCIRQCLRA]           ; and clear IRQ latch
        BL      DoInterlace
        EXIT
 ]

DoInterlace Entry
 [ PhaseDetectBit = 0
        LDR     r0, Phase
        EORS    r0, r0, #1
        BLMI    EnableInterlace         ; first time thru, turn on interlace
        STR     r0, Phase
	LDRNE	r0, OtherStuffPtr
	LDRNE	r0, [r0, #OtherIndex_Offset1To2]
 |
        LDR     r0, Phase
        CMP     r0, #&C0000000
        BLEQ    EnableInterlace         ; first time thru, turn on interlace
        EOR     r0, r0, #1              ; toggle it
        STR     r0, Phase               ; put back
        LDR     r0, Podule_ControlStatus

        ; Go read hardware interlace phase - this bit shows the phase of
        ; the current field: 1 = odd, 0 = even.
        ; However, this IRQ code is called just before the
        ; *end* of the field, so the phase for the *next* field's data
        ; should be the opposite of what we read.  Well, we hope it
        ; is.  In theory, service latency for the flyback IRQ of over
        ; 1.5 milliseconds would mean we could read the phase after it
        ; has changed for the next field, i.e. it would be wrong.  For
        ; now, just count how often this happens, i.e. how often the
        ; phase read is the same as the phase read on the previous IRQ.

        LDRB    r3, [r0]
        LDRB    r1, LastPhase                           ; get previous phase for check
        ANDS    r3, r3, #PhaseDetectBit                 ; extract and test current phase
  [ PhaseDetectInvert
	EORS	r3, r3, #PhaseDetectBit			; invert if necessary
  ]
	LDREQ	r0, OtherStuffPtr
	LDREQ	r0, [r0, #OtherIndex_Offset1To2]	; if this phase even, make odd for next
        MOVNE   r0, #0                                  ; else even (no frame offset)
        STRB    r3, LastPhase                           ; save latest phase for next time
        CMP     r1, r3                                  ; compare this and last phase:
        LDREQ   r1, PhaseErrors                         ; if inconsistent, record the error
        ADDEQ   r1, r1, #1
        STREQ   r1, PhaseErrors
        LDR     r1, FieldCount
        ADD     r1, r1, #1
        STR     r1, FieldCount
 ]

        STR     r0, OSWord16Block +1

 [ MakeCFSCountPhase
        Push    "lr"
        MOVS    r1, r0
        MOVNE   r1, #1                                  ; r1 = 0 if next field is top, else r1 = 1
        LDR     r3, OSByteVarBase
        LDRB    lr, [r3, #CFSTime]                      ; load OS's counter which decrements each field
        EOR     r1, r1, lr                              ; check relative parity
        TST     r1, #1                                  ; if doing top field next then counter needs to be odd now
        SUBEQ   lr, lr, #1                              ; so it will be even after the vsync
        STREQB  lr, [r3, #CFSTime]
        Pull    "lr"
 ]

        MOV     r3, pc
        ORR     r0, r3, #3
        TEQP    r0, #0
        NOP

        Push    "lr"
        MOV     r0, #&16
        ADR     r1, OSWord16Block
        SWI     XOS_Word
        Pull    "lr"

        TEQP    r3, #0
        NOP
        EXIT

EnableInterlace ROUT
 [ PhaseDetectBit = 0
        CMP     r0, #&C0000000
        BCC     %FT10
        LDR     r0, =ControlRegisterSoftCopy
        LDR     r1, [r0]
        BIC     r1, r1, #1 :SHL: 12
        STR     r1, [r0]
        MOV     r0, #&03500000
        STR     r1, [r0]
        MOV     r0, #&80000000          ; starting value of phase
        MOV     pc, r14
10
  [ UseInitialCallBack
	LDR	r0, CallBackRequested
	TEQ	r0, #0
	MOVNE	r0, #&80000000		; still waiting for callback
	MOVNE	pc, r14			; so keep phase at &80000000

	MOV	r0, pc
	ORR	r1, r0, #SVC_mode
	TEQP	r1, #0
	NOP
	Push	"r0,lr"
	ADR	r0, InterlaceCallBack
	MOV	r1, wp
	SWI	XOS_AddCallBack
	Pull	"r0,lr"
	TEQP	r0, #0
	NOP
	MOV	r0, #1
	STR	r0, CallBackRequested
  |
	MOV	r0, #IOC
20
	LDRB	r1, [r0, #IOCControl]
	TST	r1, #vsync_state_bit
	BNE	%BT20			; wait until out of vsync
  ]
 ]
ProgramControlRegister
        LDR     r0, =ControlRegisterSoftCopy
        LDR     r1, [r0]
 [ EnableInterlaceInVIDC
        ORR     r1, r1, #1 :SHL: 12
 |
        BIC     r1, r1, #1 :SHL: 12
 ]
        STR     r1, [r0]
        MOV     r0, #&03500000
        STR     r1, [r0]
 [ PhaseDetectBit = 0
	MOV	r0, #0
 |
        MOV     r0, #1                  ; starting value of phase
 ]
        MOV     pc, r14

 [ UseInitialCallBack
InterlaceCallBack Entry "r0-r2"
	MOV	r0, #IOC
	MOV	r1, PC
	ORR	r2, r1, #I_bit
10
	LDRB	lr, [r0, #IOCControl]
	TST	lr, #vsync_state_bit
	BEQ	%BT10			; wait until vsync
20
	TEQP	r1, #0
	TEQP	r2, #0
	LDRB	lr, [r0, #IOCControl]
	TST	lr, #vsync_state_bit
	BNE	%BT20			; wait until not vsync
	BL	ProgramControlRegister
	STR	r0, Phase
	MOV	r0, #0
	STR	r0, CallBackRequested
	EXITS
 ]

 [ :LNOT: UseModeDescriptors		; don't support this in new world
HorizOffset_Code Entry
	LDR	wp, [r12]

	MOV	r1, r0
	MOV	r0, #10 :OR: (1:SHL:31) ; insist on space or ctrl char terminator, base 10
        SWI     XOS_ReadUnsigned
        EXIT    VS

	BL	FindMode
	BEQ	%FT90			; mode not found

	Push	"r0"
10
	LDRB	r0, [r1]
	TEQ	r0, #" "		; skip spaces
	ADDEQ	r1, r1, #1
	BEQ	%BT10

	TEQ	r0, #"-"
	ADDEQ	r1, r1, #1
	MOVEQ	r6, #1
	MOVNE	r6, #0

	MOV	r0, #10 :OR: (1:SHL:31)
	SWI	XOS_ReadUnsigned
	STRVS	r0, [sp]
	Pull	"r0"
	EXIT	VS

	TEQ	r6, #0
	RSBNE	r2, r2, #0

	LDMIB	r0, {r3-r5}		; get offsets to VIDC list, WS list, other list
	ADD	r3, r3, r0

	ADD	r5, r5, r0
	LDR	r5, [r5, #OtherIndex_ModeIndex]
	MOV	r5, r5, LSL #2
	ADD	r5, r5, #:INDEX: HorizOffsets	; r5 = offset in wp to store
	STR	r2, [wp, r5]
	CLRV
	EXIT

90
	ADR	r0, UnknownModeError
	SETV
	EXIT

UnknownModeError
	&	1
	=	"Unknown interlaced screen mode", 0
	ALIGN
 ]

InterlaceSwap_Code Entry
        LDR     wp, [r12]
 [ PhaseDetectBit = 0
        TEQP    pc, #SVC_mode + I_bit
        LDR     lr, Phase
        EOR     lr, lr, #1
        STR     lr, Phase
 ]
        EXITS

 [ PhaseDetectBit <> 0
InterlaceLog_Code Entry "r0-r3"
        LDR     wp, [r12]
        SWI     XOS_WriteS
        DCB     "Fields: ", 0
        ALIGN
        LDR     r0, FieldCount                          ; load current value
        LDR     r3, PhaseErrors                         ; of total & error counts
        MOV     r1, #0                                  ; zero them to reset counts
        STR     r1, FieldCount
        STR     r1, PhaseErrors
        SUB     sp, sp, #16                             ; <<< claim space from stack
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        MOV     r0, sp
        SWI     XOS_Write0
        SWI     XOS_WriteS
        DCB     ", errors: ", 0
        MOV     r0, r3
        MOV     r1, sp
        MOV     r2, #16
        SWI     XOS_ConvertCardinal4
        MOV     r0, sp
        SWI     XOS_Write0
        ADD     sp, sp, #16                             ; >>> release stack space
        SWI     XOS_NewLine
        EXITS
 ]

; *****************************************************************************
;
;       Message stuff


 [ PhaseDetectBit <> 0
  [ PhaseDetectOnPodule
;JER BODGE should add proper error.
NoPoduleError
        &       0
        =       "Can't find MPEG expansion card", 0
        ALIGN
  ]
 ]


 [ international
CopyError Entry "r1-r7"
        BL      open_messagefile
        EXIT    VS
        ADR     r1, MessageFile_Block
        MOV     r2, #0
        LDR     r4, [sp]        ; R1 (parameter) -> R4
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        EXIT

message_filename
        DCB     "Resources:$.Resources.ARM600.Messages", 0
        ALIGN

open_messagefile Entry "r0-r2"
        LDR     r0, MessageFile_Open
        CMP     r0, #0
        EXIT    NE
        ADR     r0, MessageFile_Block
        ADR     r1, message_filename
        MOV     r2, #0
        SWI     XMessageTrans_OpenFile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r0, #1
        STR     r0, MessageFile_Open
        EXIT

write_r0_message Entry "r0-r7"
        BL      open_messagefile
        STRVS   r0, [sp]
        EXIT    VS
        MOV     r1, r0
        ADR     r0, MessageFile_Block
        MOV     r2, #0
        MOV     r4, #0
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_Lookup
        STRVS   r0, [sp]
        EXIT    VS
10      LDRB    r0, [r2], #1
        CMP     r0, #" "
        SWICS   XOS_WriteC
        STRVS   r0, [sp]
        EXIT    VS
        BCS     %B10
        SWI     XOS_NewLine
        EXIT
 |
write_r0_message Entry "r0"
        SWI     XOS_Write0
        STRVS   r0, [sp]
        EXIT
 ]

        InsertDebugRoutines

        END
