; > Commons

;..............................................................................
; 
; build_colours
;    
; Fill the specified buffer with suitable data for performing palette lookups,
; the routine builds a table containing the correct data and returns R0,R1
; containing the bounds of the buffer.
;
; R6 is supplied on entry as a temporary buffer to be filled and on exit
; it will have been advanced past any data written into this buffer.
;
; R7,R8 contain pointers to routines on exit to be called to find the best
; and worst colour for the specified physical palette entry.  Whilst the
; routine is building the specified table it uses R7 as an index into a 
; routine table which is then resolved on exit from the code.
;
; The cases go as follows:
;
;       default =rc_Simple 
;       if 8BPP, brain-damaged and default palette then =rc_Fast256
;              
; The routine does check for the current palette being cached, if it
; is then it will return that if R0,R1 are -1 on entry.
; 
; in    R0 mode to build table for / =-1 for current
;       R1 -> palette block to build mode for / =0 for default / =-1 for current
;       R2 = flags word
;       R7 -> extended flags word
;               bit 0 set => generate extended tables, else limit to eight bit per pixel tables
;
; out   V =1 => R0 -> error block
;       else,   R0,R1 contain limits of the buffer
;               R6 updated to point past last record
;               R7 ->routine to call to find best colour 
;               R8 ->routine to call to find worst colour

rc_SimpleMatch  * 0
rc_Clever8BPP   * 1
rc_Enhanced16   * 2
rc_Enhanced32   * 3

        ASSERT  :INDEX:PaletteCacheEnd =:INDEX: PaletteCacheStart +4
        ASSERT  :INDEX:PaletteBestV    =:INDEX: PaletteCacheStart +8
        ASSERT  :INDEX:PaletteWorstV   =:INDEX: PaletteCacheStart +12
   
build_colours ROUT
                         
        Debuga  buildcolours,"Build colours mode",R0
        Debuga  buildcolours,", palette",R1
        Debug   buildcolours,", flags",R7

        CMP     R0,#-1                  ;Do they want the current palette?
        CMPEQ   R1,#-1
        BNE     build_colours2          ;If not then skip caching checks

        Debug   buildcolours2,"Attempting to get current palette"
                  
        Push    "R3,R6,LR"
                 
        LDR     R3,[WP,#PaletteCacheStart]
        TEQ     R3,#0                   ;Has the palette already been cached?
        BNE     build_colourscached   

        Debug   buildcolours2,"Not already cached"
                          
        addl    R6,WP,CurrentPalette    ;->Buffer to fill
        BL      build_colours2
        addl    R6,WP,PaletteCacheStart
        STMIA   R6,{R0,R1,R7,R8}        ;Store the start and end of cache blocks

        Debuga  buildcolours2,"Our store is from",R0
        Debug   buildcolours2," to",R1
        Debug   buildcolours2,"Best routine",R7
        Debug   buildcolours2,"Worst routine",R8
        
        Pull    "R3,R6,PC",,^           ;Return because done

build_colourscached
        Debug   buildcolours2,"Current palette already cached"

        addl    R0,WP,PaletteCacheStart
        LDMIA   R0,{R0,R1,R7,R8}        ;Get bounds of cache block
        Pull    "R3,R6,PC",,^

;..............................................................................
; 
; build_colours2
;
; This routine performs the actual table building and then returns the correct
; pointers etc.
;
; in    as above
;
; out   V =1 => R0 -> error block
;       else,   as above


build_colours2
        
        Push    "R2-R5,R10-R11,LR"

        Debuga  buildcolours2,"Mode",R0
        Debuga  buildcolours2," palette",R1
        Debuga  buildcolours2," scratch",R6
        Debug   buildcolours2," flags",R7

        Debuga  ag,"Mode",R0
        Debuga  ag," palette",R1
        Debuga  ag," scratch",R6
        Debug   ag," flags",R7
                 
        LDR     R10,[WP,#PaletteAt]     ;->Palette table 

        CMP     R0,#-1                  ;Are we building for the current mode?
        BEQ     build_coloursvalid      ;Yup so ignore as Palette table is valid

        CMP     R1,#-1                  ;If we are not building for current mode, but current palette then
        MOVEQ   LR,#0                   ;brain damage the palette pointer
        STREQ   LR,[WP,#PaletteAt]                                           
        ;following is intended to fix rendering 256 colour non-palette sprite into
        ;other modes, where, without this, it returns a 1:1 table of the current
        ;palette
        MOVEQ   R1,#0                   ;and force it to use the default for the mode (amg 1.54)

build_coloursvalid
        MOV     R11,R1                  ;Temporary copy of palette pointer

;amg calling modeflags at this point is only sensible for a real mode, not a sprite
;mode word        
           
        CMP     R0,#-1
        BEQ     bc2_oldmode

        CMP     R0,#256
        BCC     bc2_oldmode

        TST     R0,#1                   ;is bit0 set ?
        BEQ     bc2_oldmode             ;it isn't - so it is a modeselector

        ;so it is a sprite mode word             
        Debug   buildcolours,"It's a sprite mode word"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ;Get Log2BPP into flags (R3)
        MOV     R3,R2
                            
        ;removed 1.54 - causes problems with tilesprite in desktop.
        MOV R4,#0
;        TEQ     R3,#3
;        MOVEQ   R4,#Flag_FullPalette    ;treat any 8bpp sprite as full palette here          
;        MOVNE   R4,#0   

        B       bc2_gotmodevars

bc2_oldmode
        Debug   buildcolours,"It's a mode number/selector"
        MOV     R1,#VduExt_Log2BPP
        SWI     XOS_ReadModeVariable    ;Get Log2BPP into flags (R3)
        MOVCC   R3,R2                   
        MOVCC   R1,#VduExt_ModeFlags
        SWICC   XOS_ReadModeVariable    ;Get the mode flags as required (R4)
        MOVCC   R4,R2
         
        STRCS   R10,[WP,#PaletteAt]     ;Restore palette table is at pointer
        Pull    "R2-R5,R10-R11,LR",CS
        BadMODE CS
        BCS     LookupError             ;Balance stack and return bad mode error if not valid

bc2_gotmodevars
        CMP     R3,#3                   ;Is this a sensible mode for building a table in?
        BGT     buildcoloursbigjob      ;No, generating one in this mode is silly!
        
        MOV     R1,#1
        MOV     LR,R1,ASL R3            ;Convert from Log2BPP to BPP
        MOV     R1,#4
        MOV     R1,R1,ASL LR            ;Get the size of the table to be generated in words

        LDR     R5,[WP,#Calibration_ptr]
        MOV     R7,#rc_SimpleMatch      ;Index for routine to call (defaults to safe jobbie)
                                        
        MOVS    R0,R11
        
        ADREQL  LR,defpals
        LDREQ   R0,[LR,R3,ASL #2]
        ADDEQ   R0,R0,LR                ;->Palette table or default if R1 was zero on entry

        Debug   buildcolours2,"Resolved palette pointer",R0
        Debug   buildcolours2,"Final palette size",R1
        Debug   buildcolours2,"Log2BPP",R3
        Debug   buildcolours2,"Flags",R4
        Debug   buildcolours2,"Calibration table at",R5
        Debug   buildcolours2,"Scratch space",R6
                                               
        ;nb this actually the palette pointer

        CMP     R0,#-1                  ;Build palette for current mode?
        BEQ     buildcurrent            
                
        Debug   buildcolours2,"Build from table"

        CMP     R3,#2                   ;Is it an 8BPP mode?
        CMPLE   R5,#0                   ;Calibration table specified?
        ADDLE   R1,R1,R0                
        BLE     buildcoloursexit        ;Not 8BPP and no calibration so exit now... R0 ->table & R1 ->end

        TEQ     R3,#3                   ;Is it 8PP mode?
        TSTEQ   R4,#Flag_FullPalette    ;Does it have a full palette?
        BNE     buildslowtable
 
; flow down into "buildfasttable"

;..............................................................................
; 
; buildfasttable
;
; Build a fast table of colours, we know that the mode is 8bpp and brain
; damaged and so we can simply read the base 16 entires and interpolate
; from these up to the final values. 
;
; in    R0 -> table
;       R1 size of table block +1
;       R5 -> calibration table
;       R6 -> scratch space
; 
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved
                                    
buildfasttable
        Push    "R4,R8-R9"

        Debug   buildcolours2,"Building from a table"

        ADRL    R2,hardmode_hardbits    ;-> bit extensions for 8BPP modes
        LDR     R8,=&70307000           ;Bit mask to munge bits around with
        MOV     R9,#255                 ;Maximum colour index within the table

buildfastloop
        AND     LR,R9,#15               ;Get index into base entries
        LDR     R4,[R0,LR,ASL #2]       ;Get the RGB of the base palette entry
        AND     R4,R4,R8
        MOV     LR,R9,LSR #4
        LDR     LR,[R2,LR,ASL #2]       ;Get tint munging values
        ORR     R4,LR,R4
        ORR     R4,R4,R4,LSR #4         ;Combine into a suitable set of colours (including *17/16)
      [ {FALSE}
        TEQ     R5,#0
        BLNE    convert_screen_colour2  ;Attempt to calibrate if table pointer <>0
      ]
        STR     R4,[R6,R9,ASL #2]       ;Store into the table 

        SUBS    R9,R9,#1
        BPL     buildfastloop           ;Loop until the entire table has been built

buildfastexit
        Pull    "R4,R8-R9"              ;Restore registers
        MOV     R0,R6
        ADD     R1,R1,R0                ;Setup bounds of table in registers
        MOV     R6,R1                   ;Setup end of scratch buffer pointer
        B       buildcoloursexit

;..............................................................................
; 
; buildslowtable
;
; Fill the specified table with suitable data read from the block at R0
; and then stored at R6 performing calibration if required.
; 
; in    R0 ->default palette block
;       R1 size of palette block +1
;       R3 log2BPP
;       R5 ->calibration table /=0 for none
;       R6 pointer to scratch buffer
; 
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved
 
buildslowtable
        Debuga  buildcolours2,"Building for normal modes from",R0
        Debug   buildcolours2," at",R6

        ADD     LR,R6,R1                ;End of table
        Push    "R6,LR"                 ;Push exit R0,R1 to table
        MOV     R2,R4                   ;Take a temporary copy of R4                 

buildslowloop
        SUBS    R1,R1,#4
        BMI     buildslowexit           ;Exit when finished building the current table

        LDR     R4,[R0],#4              ;Get a palette entry from original table
      [ {FALSE}
        TEQ     R5,#0                   ;Is there a calibration table?
        BLNE    convert_screen_colour2
      ]
        STR     R4,[R6],#4              ;Store the colour after possible calibration
        B       buildslowloop           ;Loop until all written back 
                     
buildslowexit
        Pull    "R0,R1" 
        MOV     R4,R2                   ;Setup table start, end and restore mode flags
        B       buildcoloursexit        ;And then exit from routines

;..............................................................................
; 
; buildcurrent
;
; Build table of current palette entries, to do this we need to fill the table
; at R6 with suitable palette data. 
;
; No optimisation has been specified for the 8BPP case of brain damaged
; but we should attempt to find it if we can.
; 
; in    R0 =-1
;       R1 size of palette buffer to fill
;       R3 log2bpp
;       R4 flags
;       R5 ->calibration table
;       R6 pointer to scratch buffer
; 
; out   V =1 => R0 -> error block
;       else,   R0 -> start of table    (exits via calling 'buildcoloursexit')
;               R1 -> end of table
;               R6 updated
;               R7 preserved
           
buildcurrent
        ADD     LR,R6,R1                ;Pointer to end of data read
        Push    "R6,LR"                 ;Store the pointers

        MOV     R0,R1,LSR #2            ;R0 index of maxmium colour
        MOV     R1,#16                  ;Setup to return &BBGGRRxx

        Debug   buildcolours2,"Number of colours",R0
 
        MOV     R1,#17                  ;only actually want first flash state
        BL      fast_read_whole_palette ;R6 = where to, R0 = max colour+1
                                        ;R1 = colour type (16 here) 
                                        ;returns R0=0 for correct behaviour below

        MOV     R1,#16                  ;but the original routine uses 16!

buildcurrentloop
        SUBS    R0,R0,#1
        BMI     buildcurrentexit        ;Exit when finished building palette

        Push    "R3,R4"
        BL      my_read_palette         ;Will calibrate result if required
        Pull    "R3,R4"

        STRVC   R2,[R6,R0,ASL #2]       ;Store palette entry obtained
        BVC     buildcurrentloop
        
buildcurrentexit                    
        Pull    "R0,R1"                 ;Balance stack pulling the exit parameters
        MOV     R6,R1
        B       buildcoloursexit

;..............................................................................
;
; Routine for coping with 16 and 32 bit per-pixel modes.  In these cases
; we do not attempt to generate a table (would be too big!) we infact
; just setup the pointers to the routines and then let the rest fall into
; place.

buildcoloursbigjob

        Debug   buildcolours,"16/32bpp mode, R3=",R3                       
        TEQ     R3,#4                   ;If its 16 bits per pixel
        MOVEQ   R7,#rc_Enhanced16       ;Then setup for the correct routine
        MOVNE   R7,#rc_Enhanced32       ;Otherwise define to be at 32 bits per pixel

;..............................................................................
;
; General purpose exit routine.  Attempts to decide which routine should be used
; to match the colours.
; 

buildcoloursexit
        Debug   buildcolours2,"Finished building table"
               
        STR     R3,[WP,#BuildColoursL2BPP]

        TEQ     R3,#3                   ;Is it an 8BPP mode?
        TSTEQ   R4,#Flag_FullPalette    ;Is it brian damaged... borring
        BNE     buildcoloursdone
        
      [ docalibration
        LDR     R2,[WP,#Calibration_ptr]
        TEQ     R2,#0                   ;Is there a calibration table in use?
        BNE     buildcoloursdone        ;If so we cannot perform the faster look up
      ]
        Debug   buildcolours2,"Check for fast colour matching"

        ADR     R2,modetwofivesix       ;Base of table for 256 colours
        MOV     R3,#16
        LDR     R4,=&70307000           ;Mask to extract colours

scanoldstyle
        SUBS    R3,R3,#1                ;Decrease the counter
        MOVMI   R7,#rc_Clever8BPP       ;Switch to fast 256 table matching
        BMI     buildcoloursdone

        LDR     LR,[R2,R3,LSL #2]       ;Get colour from my table
        LDR     R5,[R0,R3,LSL #2]
        AND     R5,R5,R4                ;Get colour from palette
        TEQ     R5,LR   
        BEQ     scanoldstyle            ;Loop back until all checked
                                   
        Debug   buildcolours2,"Matching failed"

buildcoloursdone
        Debuga  buildcolours2,"Table from",R0
        Debuga  buildcolours2," to",R1
        Debuga  buildcolours2," scratch",R6
        Debug   buildcolours2," routine index",R7                        
                
        ADR     LR,routinetable
        ADD     R7,LR,R7,ASL #3         ;-> routine table to call
        LDMIA   R7,{R7,R8}
        ADD     R7,R7,LR                ;-> best colour routine
        ADD     R8,R8,LR                ;-> worst colour routine          
        
        Debug   buildcolours,"Best match routine",R7
        Debug   buildcolours,"Worst match routine",R8

        STR     R10,[WP,#PaletteAt]     ;Restore the palette table pointer

        Pull    "R2-R5,R10-R11,PC",,^

;..............................................................................
; 
; Routines to be called to find suitable colours.  These routines are given
; as absolute addresses in R7,R8 on return from build_colours.
;
; The routine whilst operating attempts to increase R7 as a suitable index
; within the table so that on exit from the build_colours code it can
; setup a set of suitable pointers
; 
        ASSERT  rc_SimpleMatch =0
        ASSERT  rc_Clever8BPP  =1
        ASSERT  rc_Enhanced16  =2
        ASSERT  rc_Enhanced32  =3

routinetable
        & best_colour_safe     -routinetable
        & worst_colour_safe    -routinetable

        & best_colour256_safe  -routinetable
        & worst_colour256_safe -routinetable
        
        & best_colour16bpp     -routinetable
        & worst_colour16bpp    -routinetable

        & best_colour32bpp     -routinetable
        & worst_colour32bpp    -routinetable

        LTORG

;..............................................................................
; 
; Tables required to contain default palette data for the various screen
; modes.
;
; NB: 256 colour modes are a very special case and contain only the base 16
;     entries and interpolation is performed from here to the real
;     values.
;

defpals
        DCD     modetwo         - defpals
        DCD     modefour        - defpals
        DCD     modesixteen     - defpals
        DCD     modetwofivesix  - defpals

modetwo
        DCD     &0              ;  black
        DCD     &FFFFFF00       ;  white

modefour
        DCD     &0              ;  black
        DCD     &FF00           ;  red
        DCD     &FFFF00         ;  yellow
        DCD     &FFFFFF00       ;  white

modesixteen                     ;  actual colours
        DCD     &0              ;  black
        DCD     &FF00           ;  red
        DCD     &FF0000         ;  green
        DCD     &FFFF00         ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white
        DCD     &0              ;  black - flashing
        DCD     &FF00           ;  red
        DCD     &FF0000         ;  green
        DCD     &FFFF00         ;  yellow
        DCD     &FF000000       ;  blue
        DCD     &FF00FF00       ;  magenta
        DCD     &FFFF0000       ;  cyan
        DCD     &FFFFFF00       ;  white

modetwofivesix
        DCD     &0              ;  0000
        DCD     &10101000       ;  0001
        DCD     &20202000       ;  0010
        DCD     &30303000       ;  0011
        DCD     &00004000       ;  0100
        DCD     &10105000       ;  0101
        DCD     &20206000       ;  0110
        DCD     &30307000       ;  0111
        DCD     &40000000       ;  1000
        DCD     &50101000       ;  1001
        DCD     &60202000       ;  1010
        DCD     &70303000       ;  1011
        DCD     &40004000       ;  1100
        DCD     &50105000       ;  1101
        DCD     &60206000       ;  1110
        DCD     &70307000       ;  1111

hardmode_hardbits       ;  translation of top nibble of byte to RGB bits
        DCD     &0              ;  0000
        DCD     &00008000       ;  0001
        DCD     &00400000       ;  0010
        DCD     &00408000       ;  0011
        DCD     &00800000       ;  0100
        DCD     &00808000       ;  0101
        DCD     &00C00000       ;  0110
        DCD     &00C08000       ;  0111
        DCD     &80000000       ;  1000
        DCD     &80008000       ;  1001
        DCD     &80400000       ;  1010
        DCD     &80408000       ;  1011
        DCD     &80800000       ;  1100
        DCD     &80808000       ;  1101
        DCD     &80C00000       ;  1110
        DCD     &80C08000       ;  1111
                          
;------------------------------------------------------------------------------
;
; Common routines to find the closest and furthest colour from
; a given RGB value, given a table of colour entries.
;
; The algorithms here are expressed as macros - I find this makes
; register allocation easy while preserving some self documentation
; in the register names.
;
; Colours are encoded in the standard RISC OS way:-
;
;           BBGGRRxx
;
; where ``xx'' is undefined.  This encoding is also used for the
; loading in error calculations, used when determining the closest
; or most distance colour from a given colour.  The error is calculated
; from the errors in each component (be, ge, re) as follows:-
;
;         bl*be^2 + gl*ge^2 + rl*re^2
;
; The loadings are parameterised and stored globally as a single word
; value in the above format, ie:-
;
;           blglrlxx
;
; It will be seen that the maximum loading is thus 255.  This limits
; the maximum error generated by the above calculation to 3*255^3;
; &2F708FD.
;
;----------------------------------------------------------------------
; MACRO ColErr
;
; Calculates an error value in $error corresponding to the difference
; between the two colours $col1 and $col2.  Requires two temporary
; registers.  All registers must be different.  This routine requires
; 20 instructions, six of which are multiples.  The routine also requires
; a packed loading value ($load) and a register constant with value
; 255 (this is preserved).
;
; Multiply instruction timing: the multiply instruction implementation
; is under the control of the third operand, which is repeatedly shifted
; by two bits at a time.  When the operand becomes zero the multiply
; is complete (the actual register contents are not, of course, modified).
; So, for fastest multiply, put a small POSITIVE argument in the third
; operand.
;
; The consequence of this is that, in the following macro, the upper
; limit of the MUL instructions which square the error is 1S+5I, the
; time for the loading multiplications can be calculated exactly given
; the loadings, hence:-
;
;  loading         1,1,1   1,2,3   1,3,10
;  max total time 20S+18I 20S+20I 20S+21I
;
        MACRO
$label  ColErr  $error, $col1, $col2, $load, $temp1, $temp2, $t255

$label  MOV     $temp1, $col1, LSR #24
        SUBS    $temp2, $temp1, $col2, LSR #24
        RSBLT   $temp2, $temp2, #0             ; speed multiplication
        MUL     $temp1, $temp2, $temp2
        MOV     $temp2, $load, LSR #24
        MUL     $error, $temp1, $temp2         ; loading will be small
        ; $error contains blue term
        ; Use $t255, which must contain 255, to extract the green
        ; components
        AND     $temp1, $t255, $col1, LSR #16
        AND     $temp2, $t255, $col2, LSR #16
        SUBS    $temp2, $temp1, $temp2         ; green error
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #16  ; green load
        MLA     $error, $temp1, $temp2, $error
        ; Repeat for the red term
        AND     $temp1, $t255, $col1, LSR #8
        AND     $temp2, $t255, $col2, LSR #8
        SUBS    $temp2, $temp1, $temp2         ; red error
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #8   ; red load
        MLA     $error, $temp1, $temp2, $error
        MEND
;
;----------------------------------------------------------------------
;
; MACRO CompErr
;
; This macro also calculates an error value, however the second colour
; is specified as three separate r, g, b values.  The registers containing
; these values can be the same, if desired.  The registers should not be
; the same as any of the other registers.  Similarly the loading values
; are held in separate registers, which can be the same as each other
; if desired.  The calculation needs 14 instructions, including six
; multiplies.
;
; Timing calculations show the following:-
;
;  loading         1,1,1   1,2,3   1,3,10
;  max total time 14S+18I 14S+20I 14S+21I
;
; So this macro is 6S cycles quicker than the ColErr macro (note that
; the multiply instructions cost the same in each case).
;
        MACRO
$label  CompErr $error, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2

$label  SUBS    $temp2, $blue, $col, LSR #24
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        MUL     $error, $temp1, $bload       ; loading will be small
        ; $error contains blue term
        AND     $temp1, $col, #&FF0000       ; green component, still shifted
        SUBS    $temp2, $green, $temp1, LSR #16
        RSBLT   $temp2, $temp2, #0           ; |green error|
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $gload, $error
        ; $error contains blue+green
        AND     $temp1, $col, #&FF00         ; red component, still shifted
        SUBS    $temp2, $red, $temp1, LSR #8
        RSBLT   $temp2, $temp2, #0           ; |red error|
        MUL     $temp1, $temp2, $temp2
        MLA     $error, $temp1, $rload, $error
        MEND
;
;----------------------------------------------------------------------
;
; MACRO FindCol
;
; This macro finds a colour closest to or furthest from the given colour.
; Which is found is determined by the initial value of $error and the
; test ($test) which is supplied to use when deciding whether the found
; colour is better or worse than the current best.
;
; The $test value is used in instructions conditional on the result of:-
;
;      CMP      $newerror, $error
;
; And the search goes from the top of the colour table down, hence:-
;
;   $test    Initial $error          Interpretation
;   -----    --------------          --------------
;   LS       #&FFFFFFFF      Find closest colour, favour lower indices
;   LO       #&FFFFFFFF      Find closest colour, favour higher indicies
;   HS       #&0             Find furthest colour, favour lower indices
;   HI       #&0             Find furthest colour, favour higher indices
;
; Timings for the search obviously depend on the size of the colour
; table.  The whole table is always searched.  The following timings
; are derived from those for CompErr.  Overhead is 8S cycles, loop
; cost is 5S+1N+1I plus the CompErr macro cost, plus the branch instruction
; cost (2S+1N, minus 1S+1N at loop end).  This gives:-
;
; Overhead:  7S-1N
; Loop:      CompErr+7S+2N+1I
;
;  loading                 1,1,1            1,2,3            1,3,10
;  loop cost          21S+  2N+  19I   21S+  2N+  21I   21S+  2N+  22I
;  2 colour table     49S+  3N+  38I   49S+  3N+  42I   49S+  3N+  44I
;  4 colour table     91S+  7N+  76I   91S+  7N+  84I   91S+  7N+  88I
;  16 colour table   343S+ 31N+ 304I  343S+ 31N+ 336I  343S+ 31N+ 352I
;  256 colour table 5383S+511N+4864I 5383S+511N+5376I 5383S+511N+5632I
;
; This corresponds to times, in microseconds, of:-
;
;         CPU                ARM2(8MHz)           ARM3(26MHz+12MHz)
;        16 colour table       95                     ~31
;       256 colour table      1500                    ~500
;
; (Note that this assumes the code is running out of RAM; 256 entry
; lookup running out of ROM takes 2.2 milliseconds).
;
; Arguments are as follows:-
;
; $test      Comparison to perform: LS, LO, HS or HI
; $list      Pointer to start of colour table         PRESERVED
; $listend   Pointer to end+4 of colour table         IN
;            Same as $list                            OUT
; $srccol    BBGGRRxx colour to check                 IN
;            Index of colour in table                 OUT
; $load      Error loading in format BBGGRRxx         IN
;            Temporary registered                     TRASHED
; $error     Error value for colour $list[$srccol]    OUT
; $red       TEMPORARY
; $green     TEMPORARY
; $blue      TEMPORARY
; $rload     TEMPORARY
; $gload     TEMPORARY
; $bload     TEMPORARY
; $col       TEMPORARY
; $temp1     TEMPORARY
; $temp2     TEMPORARY
;
        MACRO
$label  FindCol  $test, $list, $listend, $srccol, $load, $error, $red, $green, $blue, $rload, $gload, $bload, $col, $temp1, $temp2

        ; First extract the packed colour and load
$label  MOV      $blue, #255
        AND      $green, $blue, $srccol, LSR #16
        AND      $gload, $blue, $load, LSR #16
        AND      $red, $blue, $srccol, LSR #8
        AND      $rload, $blue, $load, LSR #8
        MOV      $blue, $srccol, LSR #24
        MOV      $bload, $load, LSR #24
        ;
        ; Loop round from the top of the table down
00      LDR      $col, [$listend, #-4]!
        CompErr  $load, $col, $red, $green, $blue, $rload, $gload, $bload, $temp1, $temp2
        CMP      $load, $error
        MOV$test $error, $load
        SUB$test $srccol, $listend, $list             ; index * 4
        CMP      $listend, $list
        BHI      %BT00
        MOV      $srccol, $srccol, LSR #2
        MEND
;
;----------------------------------------------------------------------
;
; MACRO Find256
;
; This macro finds the best matching colour for the *standard* ARM 256
; entry palette - the one with the R/G/B/T (tint) bits.  The algorithm
; returns a palette value encoded in the standard way (BGGRBRTT) in
; $srccol and the error in $error.  The algorithm is expressed in two
; parts; the first to find the closest ARM 24 bit colour, then the
; second to convert this to the ARM standard format.  This allows the
; basic macro to be used either for GCOL (BBGGRRTT) form or colour
; number (BGGRBRTT) form.  The timings below assume colour number form.
;
; Arguments are as follows:-
;
;Find256
;-------
; $test      Comparison to perform: LS, LO, HS or HI
; $srccol    BBGGRRxx colour to check                 PRESERVED
;            Index of colour in table                 OUT
; $load      Error loading in format BBGGRRxx         PRESERVED
; $error     Error value for colour $srccol           OUT
; $tint      TEMPORARY
; $col       TEMPORARY
;            24 bit colour value                      OUT
; $temp1     TEMPORARY
; $temp2     TEMPORARY
; $newerr    TEMPORARY
; $newcol    TEMPORARY
; $t255      MUST contain the value #255 on entry     PRESERVED
;
;Convert24Number, Convert24GCOL
;---------------  -------------
; $col       24 bit colour value                      PRESERVED
; $number    256 palette entry colour number          OUT
; $temp1     TEMPORARY
;
; All arguments must be different registers.  The body of the loop is 48
; instructions, including the normal six multiplies.  The code goes
; round it four times, there is a further 12 instruction overhead plus
; three taken branch instructions.  The maximum error on any component
; value is 51 (&33), because each tint value is tried the average error
; over the four loops will, however, be less - the worst possible case
; errors still mean quicker multiplies for two of the error calculations.
; This allows more accurate prediction of the loop timings, depending on
; the loadings the timings are approximately:-
;
;  loading                 1,1,1       1,2,3      1,3,10
;  max single loop time  48S+15I     48S+17I     48S+18I
;  max total loop time  192S+51I    192S+59I    192S+63I
;  max total time       200S+51I+3N 200S+59I+3N 200S+63I+3N
;
; This gives a search time:-
;                  ARM2: 34 microseconds
;                  ARM3: 11 microseconds
;
; The ARM palette entries are assumed to expand a 4 bit component to an 8
; bit component using c<<4|c - this has been determined experimentally to
; give good results.
;
; The $error value and the $test condition must be as in FindCol.  Because
; the algorithm searches through the tints starting at the highest the
; behaviour is as follows:-
;
;   $test    Initial $error          Interpretation
;   -----    --------------          --------------
;   LS       #&FFFFFFFF      Find closest colour, favour lower tints
;   LO       #&FFFFFFFF      Find closest colour, favour higher tints
;   HS       #&0             Find furthest colour, favour lower tints
;   HI       #&0             Find furthest colour, favour higher tints
;
; Following comments are supposed to be in the body of the macro...
;
        ;See COMMENTS? below...
        ; At this point the top bits of $temp1 hold the best blue bit values
        ; given the current $tint tint bits, however the desired value may
        ; be >11tt or <00tt, in either case the top bit (bit 31) of $temp1
        ; will be set, hence the N flag will be set in the PSR.  We must
        ; distinguish overflow (>11tt) from a simple negative result (<00tt)
        ; and truncate both to the appropriate end of the scale.  We have
        ; calculated (blue-tint+&22)<<23.  The overflow (V) flag will ONLY
        ; be set for >11tt; the other possible results (in the range &FF<<23
        ; to -&17<<23 are representable without overflow), so:-
        ;

        MACRO
$label  Find256  $test, $srccol, $load, $error, $tint, $comp, $col, $temp1, $temp2, $newerr, $newcol, $t255

        ; $t255 MUST contain the value 255...
$label  MOV     $tint, #&30:SHL:23              ; tint bits unexpanded

00      RSB     $temp1, $tint, #&20:SHL:23      ; overflow not possible here
        MOV     $comp, $srccol, LSR #24         ; extract blue component
        SUB     $temp2, $comp, $comp, LSR #4    ; ~multiplication by 16/17
        ADDS    $temp1, $temp1, $temp2, LSL #23
        ;
        ; *** COMMENTS?  See above (AAsm objects to macro length...)
        ;
        MOVVSS  $temp1, #&7F000000              ; clears the N flag!
        MOVMI   $temp1, #0
        ;
        ; Now extract the blue bits and reconstruct the real (expanded)
        ; blue value.
        ;
        AND     $temp1, $temp1, #&60000000      ; two blue bits
        ADD     $temp1, $temp1, $tint           ; plus tint
        ADD     $newcol, $temp1, $temp1, LSR #4 ; expand component bits -
                                                ; 8 bit blue value
        ;
        ; Calculate the error as in previous macros.
        ;
        SUBS    $temp2, $comp, $newcol, LSR #23
        RSBLT   $temp2, $temp2, #0              ; speeds up multiplication
        MUL     $temp1, $temp2, $temp2
        MOV     $temp2, $load, LSR #24          ; blue error loading
        MUL     $newerr, $temp1, $temp2         ; loading will be small
        ;
        ; Repeat this for the green component, accumulating the error
        ;
        RSB     $temp1, $tint, #&20:SHL:23
        AND     $comp, $t255, $srccol, LSR #16
        SUB     $temp2, $comp, $comp, LSR #4
        ADDS    $temp1, $temp1, $temp2, LSL #23
        MOVVSS  $temp1, #&7F000000
        MOVMI   $temp1, #0
        ;
        AND     $temp1, $temp1, #&60000000       ; two green bits
        ADD     $temp1, $tint, $temp1            ; 4 bit green value
        ADD     $temp1, $temp1, $temp1, LSR #4   ; expand component bits
        ORR     $newcol, $newcol, $temp1, LSR #8 ; Accumulate bits in $newcol
        ;
        SUBS    $temp2, $comp, $temp1, LSR #23
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #16
        MLA     $newerr, $temp1, $temp2, $newerr
        ;
        ; And the red component:-
        ;
        RSB     $temp1, $tint, #&20:SHL:23
        AND     $comp, $t255, $srccol, LSR #8
        SUB     $temp2, $comp, $comp, LSR #4
        ADDS    $temp1, $temp1, $temp2, LSL #23
        MOVVSS  $temp1, #&7F000000
        MOVMI   $temp1, #0
        ;
        AND     $temp1, $temp1, #&60000000       ; two red bits
        ADD     $temp1, $tint, $temp1            ; 4 bit red value
        ADD     $temp1, $temp1, $temp1, LSR #4   ; expand component bits
        ORR     $newcol, $newcol, $temp1, LSR #16; Accumulate bits in $newcol
        ;
        SUBS    $temp2, $comp, $temp1, LSR #23
        RSBLT   $temp2, $temp2, #0
        MUL     $temp1, $temp2, $temp2
        AND     $temp2, $t255, $load, LSR #8
        MLA     $newerr, $temp1, $temp2, $newerr
        ;
        ; $newerr contains the error for the ARM value in $newcol (actually
        ; this value is shifted right by 1 bit because of the LSL 23 above).
        ; Check the error and see if this is a better pixel.
        ;
        CMP      $newerr, $error
        MOV$test $error, $newerr               ; $test determines result
        MOV$test $col, $newcol, LSL #1         ; $col holds best match
        ;
        ; Try the next tint
        ;
        SUBS    $tint, $tint, #&10:SHL:23
        BGE     %BT00
        ;
        ; $error is the error, and is directly comparable with the $error
        ; value from the other macros.  $col is a 24 bit RGB value in the
        ; format:-
        ;
        ;       BBTTBBTT GGTTGGTT RRTTRRTT 00000000
        ;
        MEND
;
; Convert24Number - convert the above format to the ARM colour number
; format:-
;
;            76543210
;            BGGRBRTT
;
        MACRO
$label  Convert24Number $col, $number, $temp1

$label  AND     $temp1, $col, #&80000000        ; B   (needs >> 24)
        MOV     $number, $temp1, LSR #24
        AND     $temp1, $col, #&C00000          ; GG  (needs >> 17)
        ORR     $number, $number, $temp1, LSR #17
        AND     $temp1, $col, #&8000            ; R   (needs >> 11)
        ORR     $number, $number, $temp1, LSR #11
        AND     $temp1, $col, #&40000000        ; B   (needs >> 27)
        ORR     $number, $number, $temp1, LSR #27
        AND     $temp1, $col, #&7000            ; RTT (needs >> 12)
        ORR     $number, $number, $temp1, LSR #12
        MEND
;
; Convert24GCOL - convert the above format to the ARM colour number
; format:-
;
;            76543210
;            BBGGRRTT
;
        MACRO
$label  Convert24GCOL $col, $number, $temp1

$label  AND     $temp1, $col, #&C0000000        ; BB   (needs >> 24)
        MOV     $number, $temp1, LSR #24
        AND     $temp1, $col, #&C00000          ; GG   (needs >> 18)
        ORR     $number, $number, $temp1, LSR #18
        AND     $temp1, $col, #&F000            ; RRTT (needs >> 12)
        ORR     $number, $number, $temp1, LSR #12
        MEND
;
;----------------------------------------------------------------------
;
; INTERFACE best_colourXXX
;
; Finds the index (returned in R2) of the closest colour to the
; colour given in R2.  If two colours are equally good the one
; with the lowest index in the table is returned.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   colour table start             PRESERVED
;    R1   colour table end +4            IN
;         == R0 (colour table start)     OUT
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) IN
;         used as a temporary            TRASHED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is trashed.  Notice that the routine
; preserves the workspace pointer in r12 - the previous best_colour
; interface did not do this (on the other hand, it did preserve
; other registers - WATCH OUT!)
;
best_colour_fast
        Push    "wp, lr"
        MOV     r4, #&FFFFFFFF                  ; initial error
        FindCol LS,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Pull    "wp, pc"
;
; This alternative interface preserves registers; ONLY the following
; registers are used or altered:-
;
;    R0  colour table start          PRESERVED
;    R1  colour table end +4         PRESERVED
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
best_colour_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
         LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      best_colour_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"
; 
; Finds the index (returned in R2) of the closest ARM VIDC 256 entry
; palette colour to the colour given in R2.  If two colours are equally
; good the one with the highest tint is returned.  The value returned is
; a RISC OS colour number NOT a GCOL value.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   not used                       PRESERVED
;    R1   set to 255                     TRASHED
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) PRESERVED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is preserved.
;
best_colour256_fast
        MOV     r4, #&FFFFFFFF                  ; initial error
        MOV     r1, #255                        ; macro needs this...
        Find256 LO,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r1
        Convert24Number r7, r2, r5
        MOV     pc, lr
;
; This version of the same interface preserves all the registers except:
;
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
best_colour256_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      best_colour256_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"
;
;----------------------------------------------------------------------
;
; INTERFACE worst_colour_XXX
;
; Finds the index (returned in R2) of the furthest colour from the
; colour given in R2.  If two colours are equally good the one
; with the highest index in the table is returned.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   colour table start             PRESERVED
;    R1   colour table end +4            IN
;         == R0 (colour table start)     OUT
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) IN
;         used as a temporary            TRASHED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is trashed.  As with the best_colour
; routines the work space pointer is preserved, but other things are
; damaged.
;
worst_colour_fast
        Push    "wp, lr"
        MOV     r4, #&0                  ; initial error
        FindCol HI,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r14
        Pull    "wp, pc"
;
; There is no register preserving interface - this routine is only
; used in one place so this would be a waste of ROM space!  The
; following code is therefore commented out...
;
; This alternative interface preserves registers; ONLY the following
; registers are used or altered:-
;
;    R0  colour table start          PRESERVED
;    R1  colour table end +4         PRESERVED
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
worst_colour_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
         LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      worst_colour_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"
;
; 
; Finds the index (returned in R2) of the furthest ARM VIDC 256 entry
; palette colour from the colour given in R2.  If two colours are equally
; good the one with the lowest tint is returned.  The value returned is
; a RISC OS colour number NOT a GCOL value.
;
; This interface trashes ALL the registers EXCEPT:-
;
;    R0   not used                       PRESERVED
;    R1   set to 255                     TRASHED
;    R2   colour to check (BBGGRRxx)     IN
;         index of colour within table   OUT
;    R3   error loading value (BBGGRRxx) PRESERVED
;    R4   error for given colour         OUT
;    R12  Workspace pointer              PRESERVED
;
; LR is the return address, and is preserved.
;
worst_colour256_fast
        MOV     r4, #&0                         ; initial error
        MOV     r1, #255                        ; macro needs this...
        Find256 HS,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r1
        Convert24Number r7, r2, r5
        MOV     pc, lr
;
; This version of the same interface preserves all the registers except:
;
;    R2  colour to check (BBGGRRxx)  IN
;        index of colour in table    OUT
;    LR  return address              IN
;        used as a temporary         TRASHED
;
worst_colour256_safe
        Push    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,lr"
      [ newcalibration
        LDR     r3, [wp, #Calibration_ptr]
        TEQ     r3, #0
        BLNE    convert_screen_colour
      ]
        LDR     r3, [wp, #ColourErrorLoading]   ; BBGGRRxx loading value
        BL      worst_colour256_fast
        Pull    "r1,r3,r4,r5,r6,r7,r8,r9,r10,r11,pc"

        END
