; > &.Hourglass.Hourglass

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:Hourglass
        GET     Hdr:MsgTrans
;        GET     Hdr:EcoMacros
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:Proc

        GET     Time+Date
        
        GET     Hdr:NdrDebug
                GBLL    hostvdu
hostvdu         SETL    {FALSE}
                GBLL    debug_flush
debug_flush     SETL    {TRUE}
                GBLL    debug
debug           SETL    {FALSE}
                GBLL    debugswientry
debugswientry   SETL    {FALSE}
                GBLL    debugdepth
debugdepth      SETL    {FALSE}
                GBLL    debugcurrent
debugcurrent    SETL    {FALSE}
                GBLL    ursula
ursula          SETL    {TRUE}

bignum          * &3FFFFFFF                             ; A large number to put into PercentageDepth

; The constants defining the hourglass shape and position

HgX             * 4
HgY             * 2
HgSize          * 16
ActiveX         * HgX + (HgSize :SHR: 1)
ActiveY         * HgY + (HgSize :SHR: 1)

; The constants defining the Hourglass time behaviour

UpdateDelay     * 15
StartupDelay    * 33

; These define the things round the hourglass
; nb. keep on byte boundries !

PixelsPerByte   * 4
BytesPerLine    * 6
HeightInPixels  * 32
DataSize        * (BytesPerLine * HeightInPixels + 3):AND: :NOT: 3

PercX           * 0
PercY           * 23
CharWidth       * 8
CharHeight      * 9
 
WaitForVSync    * 19

SetPointer      * 106
NoPointer       * 0
PointerOSWord   * 21
WritePalette    * 12

; Define number of frames and palette data
HourglassFrames * 8

DefaultColour1  * &fff6d5
DefaultColour2  * &0
DefaultColour3  * &ffa100

MySWIChunkBase  * Module_SWISystemBase + HourglassSWI * Module_SWIChunkSize
 ASSERT MySWIChunkBase = Hourglass_On

; Workspace

        ^ 0, wp
HourglassData           #       DataSize                ; My Hourglass data is in here
HourglassDataEnd        #       0

ReturnColours           #       0                       ; Colours to return to when switched fully off
ReturnColour1           #       4
 [ ursula
ReturnColour2           #       4
 ]
ReturnColour3           #       4
NextHColours            #       0                       ; Colours to reassert at next frame update
NextHColour1            #       4
 [ ursula
NextHColour2            #       4
 ]
NextHColour3            #       4
LastHColours            #       0                       ; Colours set at last frame update
LastHColour1            #       4
 [ ursula
LastHColour2            #       4
 ]
LastHColour3            #       4
CurrentColours          #       0                       ; Colours actually in use
CurrentColour1          #       4
 [ ursula
CurrentColour2          #       4
 ]
CurrentColour3          #       4
HourglassTimer          #       4
HourglassDepth          #       4
PercentageDepth         #       4
OldPercentage           #       1
NewPercentage           #       1
OldLEDs                 #       1
NewLEDs                 #       1

ReturnPointer           #       1                       ; Pointer number to return to when switched fully off
HourglassState          #       1                       ; State of sand (0..5)

        AlignSpace      4, 2                            ; so that the data ptr in the
                                                        ; OS_Word block is word-aligned

OSWord15Block           #       0                       ; Block for defining pointer shape
Block_ReasonCode        #       1
Block_PointerNumber     #       1
Block_Width             #       1
Block_Height            #       1
Block_ActiveX           #       1
Block_ActiveY           #       1
Block_DataPtr           #       4
        ASSERT  (3 :AND: :INDEX: Block_DataPtr)=0

PointerDirty            #       1                       ; 0 => shape set up etc
                                                        ; 1 => shape not set up etc
UpdateSemaphore         #       1                       ; 0 => not in update code
                                                        ; non0 => in update code

        AlignSpace

RAMSpaceRequired       * :INDEX: @

ModuleStart
        DCD     0                                       ; StartCode
        DCD     InitialisationCode-ModuleStart
        DCD     FinalisationCode-ModuleStart
        DCD     ServiceCall-ModuleStart
        DCD     TitleString-ModuleStart
        DCD     HelpString-ModuleStart
        DCD     0                                       ; HelpAndCommandKeywordTable
        DCD     MySWIChunkBase
        DCD     SWIHandlerCode-ModuleStart
        DCD     SWIDecodingTable-ModuleStart
        DCD     0                                       ; SWIDecodingCode


        [       OldOs
UnknownSWIErrorMsg
        DCD     ErrorNumber_ModuleBadSWI     
        DCB     "SWI value out of range for module "
        ]
SWIDecodingTable
TitleString
        DCB     "Hourglass", 0  ; Share
        DCB     "On", 0
        DCB     "Off", 0
        DCB     "Smash", 0
        DCB     "Start", 0
        DCB     "Percentage", 0
        DCB     "LEDs", 0
        DCB     "Colours", 0
        DCB     0

                GBLS    OsString
        [       OldOs
OsString        SETS    " (2.00)"
        |
OsString        SETS    ""
        ]

HelpString
        DCB     "Hourglass", 9, "2.", CurrentVersion
        [       ReleaseVersion
        !       0, "Assembling Hourglass 2.$CurrentVersion$OsString"
        |
        DCB     "/", CurrentIteration
        !       0, "Assembling Hourglass 2.$CurrentVersion/$CurrentIteration$OsString"
        ]
        DCB     " (", CurrentDate, ")"
        [       :LNOT: ReleaseVersion
        DCB     " assembled  at ", CurrentTime, "."
        ]
        DCB     "$OsString", 0
        ALIGN

      [ debug
        InsertNDRDebugRoutines
      ]

InitialisationCode ROUT
      [ debug
        Debug_Open "<Hourglass$Debug>1"
        Debug   swientry, "Module initialisation"
      ]
        Push    "r0-r2, lr"                             ; Push the same registers as Service
        LDR     r2, [ r12 ]                             ; Is our workspace here already?
        TEQ     r2, #0                                  ; If not this will be zero
        BNE     SoftInitialisation                      ; Don't claim if we already have workspace
        MOV     r0, #ModHandReason_Claim                ; Claim some workspace
        MOV     r3, #RAMSpaceRequired                   ; We need this much free space
        SWI     XOS_Module                              ; Claim RMA
        BVS     ErrorExitInit
        STR     r2, [ r12 ]                             ; Update the private word
SoftInitialisation
        MOV     wp, r2                                  ; Now point to my workspace
InitialiseWorkspace
        MOV     r14, #bignum
        STR     r14, PercentageDepth
        MOV     r14, #0
        STR     r14, HourglassDepth
        STRB    r14, UpdateSemaphore
        ADR     r0, OSWord15BlockData                   ; Set up OSWord block in my workspace
        LDMIA   r0, { r1, r2 }
        ADR     r0, OSWord15Block-2
        STMIA   r0, { r1, r2 }
        ADR     r0, HourglassData
        STR     r0, Block_DataPtr
        BL      InitialisePointerInfo
ErrorExitInit
        STRVS   r0, [ sp, #0 ]
ExitInit
        Pull    "r0-r2, pc"

OSWord15BlockData
        DCB     0                                       ; two dummy bytes so that the
        DCB     0                                       ; data pointer is on a word boundary
        DCB     0                                       ; Reason code: program pointer shape
        DCB     3                                       ; Initial pointer number
                                                        ; (this toggles between 3 and 4)
        DCB     BytesPerLine
        DCB     HeightInPixels
        DCB     ActiveX
        DCB     ActiveY
        ALIGN

DefaultColours
        DCD     DefaultColour1
       [ ursula
        DCD     DefaultColour2
       ]
        DCD     DefaultColour3

FinalisationCode ROUT
        Debug   swientry, "Module finalisation"
        LDR     wp, [ r12 ]
        Push    "lr"
        BL      HourglassSmash
      [ debug
        Debug_Close
      ]
        Pull    "pc"


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want

        ASSERT  Service_Error < Service_Reset

ServiceTable
        DCD     0
        DCD     ServiceUrsula - ModuleStart
        DCD     Service_Error
        DCD     Service_Reset
        DCD     0
        DCD     ServiceTable - ModuleStart


; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module service entry point

ServiceCall     ROUT
        MOV     r0, r0                                  ; Indicates there is a service call table

ServiceUrsula
        CMP     r1, #Service_Reset                      ; is it reset ? EQ,CSet if so
        TEQNE   r1, #Service_Error*4,2                  ; or error ? EQ, CClear if so
        MOVNE   pc, lr

        LDR     wp, [ r12 ]                             ; get my private word
        BCS     DoServiceReset
        B       HourglassSmash                          ; All errors turn off the hourglass

DoServiceReset
        Push    "r0-r2, lr"
        MOV     r0, #253                                ; Now check reset was NOT hard
        MOV     r1, #0                                  ; Read last reset type,
        MOV     r2, #255
        SWI     XOS_Byte                                ; only do reset when it was soft
        BVS     ErrorExitInit
        TEQ     r1, #0                                  ; Was it a soft-reset
        BNE     ExitInit                                ; No, it was hard, so exit
        B       InitialiseWorkspace

SWIHandlerCode  ROUT
        LDR     wp, [ r12 ]
        CMP     r11, #(EndOfJumpTable - SWIJumpTable)/4
        ADDCC   pc, pc, r11, LSL #2
        B       UnknownSWIError
SWIJumpTable
        B       HourglassOn
        B       HourglassOff
        B       HourglassSmash
        B       HourglassStart
        B       HourglassPercentage
        B       HourglassLEDs
        B       HourglassColours
EndOfJumpTable

 ASSERT HourglassSWICheckValue-Hourglass_On=(EndOfJumpTable - SWIJumpTable)/4

UnknownSWIError
        [       OldOs
        ADR     r0, UnknownSWIErrorMsg
        ORRS    pc, lr, #V_bit
        |       ; OldOs
        Push    "r1-r7, lr"
        ADR     r0, ErrorBlock_ModuleBadSWI
        MOV     r1, #0                                  ; No message block
        MOV     r2, #0                                  ; No buffer
        ADR     r4, TitleString
        MOV     r5, #0
        MOV     r6, #0
        MOV     r7, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r7, pc"

        MakeErrorBlock     ModuleBadSWI
        ]       ; OldOs

; *****************************************************************************
;
;       HourglassOn - Turn on after default startup delay
;
; in:   -
;
; out:  -
;

HourglassOn ENTRY "r0"
        Debug   swientry, "Hourglass_On"
        MOV     r0, #StartupDelay
        BL      HourglassStart
        EXITS   VC
        STR     r0, [ sp ]
        EXIT

; *****************************************************************************
;
;       HourglassStart - Turn on after specified delay
;       If already on, just increment depth count
;
; in:   R0 = delay in centiseconds (0 => never update hourglass)
;
; out:  -
;

HourglassStart ENTRY "r0-r2,r11"
        Debug   swientry, "Hourglass_Start, R0 =", r0
        
        LDR     r11, HourglassDepth
        Debug   depth, "Hourglass_Start: old HourglassDepth =", r11
        ADD     r11, r11, #1                            ; update my depth count
        STR     r11, HourglassDepth
        
        LDR     r1, HourglassTimer
        CMP     r11, #1                                 ; update the hourglass timer if this is the first level
        CMPHI   r0, r1                                  ; or if a deeper level is requesting an even earlier display
        STRLS   r0, HourglassTimer
        
        CMP     r11, #1                                 ; that's all we need to do unless this is the first level
        EXITS   HI

        BL      InitialisePointerInfo
        
        MOV     r0, #TickerV                            ; get on TickerV
        ADR     r1, MyTickRoutine                       ; to do things
        MOV     r2, wp
        SWI     XOS_Claim
        EXITS   VC
        STR     r0, [ sp ]
        EXIT

; *****************************************************************************
;
;       HourglassOff - If at outer level, turn off hourglass, else dec depth
;
; in:   -
;
; out:  -
;

HourglassOff ENTRY "r0-r3, r10"
        Debug   swientry, "Hourglass_Off"

        LDR     r10, HourglassDepth
        Debug   depth, "Hourglass_Off: old HourglassDepth =", r10
        LDR     r14, PercentageDepth                    ; turn off percentage if we're at the controlling depth now
        TEQ     r10, r14
        MOVEQ   r14, #-1
        STREQB  r14, NewPercentage
        MOVEQ   r14, #bignum                            ; also reset PercentageDepth so we can turn it on again next time
        STREQ   r14, PercentageDepth
        SUBS    r10, r10, #1                            ; update my depth count
        STRCS   r10, HourglassDepth                     ; store back if wasn't already zero
        EXITS   NE                                      ; if not bottom, leave alone

        MOV     r0, #TickerV                            ; get off TickerV
        ADR     r1, MyTickRoutine
        MOV     r2, wp
        SWI     XOS_Release

        LDRB    r0, PointerDirty                        ; have we set up shape yet ?
        TEQ     r0, #0
        
        BLEQ    RestorePointer                          ; yes - undo it
        EXITS                                           ; ignore errors

; *****************************************************************************
;
;       HourglassSmash - Unconditionally turn off hourglass
;
; in:   -
;
; out:  -
;

HourglassSmash ENTRY "r0"
        Debug   swientry, "Hourglass_Smash"
        
        LDR     r0, HourglassDepth
        Debug   depth, "Hourglass_Smash: old HourglassDepth =", r0
        TEQ     r0, #0                                  ; if at top, ignore

        MOVNE   r0, #1                                  ; depth count becomes one
        STRNE   r0, HourglassDepth
        MOVNE   r0, #bignum
        STRNE   r0, PercentageDepth
        Debug swientry, "r10 on entry =", r10
        BLNE    HourglassOff                            ; to force turn-off
        Debug swientry, "r10 on exit =", r10
        EXITS   VC
        STR     r0, [sp]
        EXIT

; *****************************************************************************
;
;       HourglassPercentage - Set percentage figures
;
; in:   R0 = percentage to display, outside 0-99 to turn figures off
;
; out:  -
;

HourglassPercentage ENTRY "r1"
        Debug   swientry, "Hourglass_Percentage, percentage =", r0

        LDR     r14, HourglassDepth
        LDR     r1, PercentageDepth
        CMP     r14, r1                                 ; Are we at or below the controlling depth?
        STRLT   r14, PercentageDepth                    ; if so, we can set the percentage
        STRLEB  r0, NewPercentage

        LDRB    r14, NewPercentage                      ; if percentages were turned off,
        CMP     r14, #100                               ; re-enable percentage changes at lower levels
        MOVHS   r14, #bignum
        STRHS   r14, PercentageDepth

        EXITS

; *****************************************************************************
;
;       HourglassLEDs - Set LED states (currently 2 of them)
;
; in:   R0 = EOR mask
;       R1 = AND mask
;
; out:  R0 = old LED state
;

HourglassLEDs ENTRY "r10, r11"
        Debug   swientry, "Hourglass_LEDs, R0,R1 =", r0, r1
        
        LDRB    r10, NewLEDs                            ; read previous values
        AND     r11, r1, r10
        EOR     r0, r0, r11
        STRB    r0, NewLEDs                             ; store new value
        MOV     r0, r10                                 ; return old value
        EXITS

; *****************************************************************************
;
;       HourglassColours - Set the colours used for the hourglass
;
; in:   R0 = New colour to use as colour 1 (-1 for no change)
;       R1 = New colour to use as colour 3 (-1 for no change)
;
; out:  R0 = Old colour that was being used as colour 1
;       R1 = Old colour that was being used as colour 3
;

HourglassColours ENTRY "r0, r1"
        Debug   swientry, "Hourglass_Colours, new colours 1,3 =", r0, r1
        
        LDR     r14, NextHColour1                       ; Save the old value of Colour1
        STR     r14, [ sp, #0 ]                         ; Put old value in exit stack frame
        LDR     r14, NextHColour3                       ; Save the old value of Colour3
        STR     r14, [ sp, #4 ]                         ; Put old value in exit stack frame
        CMP     r0, #-1                                 ; Are we changing this colour(1)?
        STRNE   r0, NextHColour1                        ; Put down the new value
        CMP     r1, #-1                                 ; Are we changing this colour(3)?
        STRNE   r1, NextHColour3                        ; Put down the new value
        EXITS                                           ; Return with V clear

; *****************************************************************************
;
;       MyTickRoutine - TickerV routine
;

MyTickRoutine ROUT
        Push    "lr"
        LDRB    r14, UpdateSemaphore
        TEQ     r14, #0                                 ; Are we already doing this?
        Pull    "pc", NE                                ; Yes, so stay out
        INC     r14
        STRB    r14, UpdateSemaphore
        LDR     r14, HourglassTimer
        SUBS    r14, r14, #1                            ; decrement timer
        MOVEQ   r14, #UpdateDelay                       ; if now zero, reset timer
        STRCS   r14, HourglassTimer                     ; if wasn't zero before, store back
        BNE     ExitTickRoutine                         ; exit if not zero now
        Push    "r0-r6"
        MOV     r6, pc
        TEQP    pc, #3                                  ; must be SVC mode here, Enables Ints
        NOP
        Push    "r14"                                   ; save SVC r14
        LDRB    r0, PointerDirty                        ; if pointer shape needs setting up
        TEQ     r0, #0
        DebugIf NE, swientry, "Hourglass being shown"
        BLNE    SetupPointer                            ; then do it
        BL      FillHourglass                           ; some sand falls
        BL      SetupPercentage
        BL      SetupLEDs
        BL      ProgramPointer                          ; and show the world
        Pull    "r14"                                   ; restore SVC r14
        TEQP    r6, #0                                  ; restore the mode
        NOP
        Pull    "r0-r6"
ExitTickRoutine
        MOV     r14, #0
        STRB    r14, UpdateSemaphore
        Pull    "pc"

; *****************************************************************************
;
;       SetupPointer - Program initial shape of hourglass etc
;       Called only when the pointer is dirty - ie first time through ticker routine
;
; in:   -
;
; out:  R0-R5 may be corrupted
;

SetupPointer ROUT
        Push    "lr"

        MOV     r0, #-1
        STRB    r0, OldPercentage
        STRB    r0, NewPercentage

        ADR     r0, HourglassData
      [ debug :LOR: ursula
        ADRL    r1, HourglassShape
        ADRL    r2, HourglassShapeEnd
      |
        ADR     r1, HourglassShape
        ADR     r2, HourglassShapeEnd
      ]
10
        LDR     r3, [r1], #4
        STR     r3, [r0], #4
        TEQ     r1, r2
        BNE     %BT10

        ADR     r2, HourglassDataEnd
        MOV     r3, #0
20
        STR     r3, [r0], #4
        TEQ     r0, r2
        BNE     %BT20

        STRB    r3, HourglassState                      ; zero hourglass state
        STRB    r3, PointerDirty                        ; pointer now clean

        Pull    "pc"

; *****************************************************************************
;
;       FillHourglass - Go to next state of hourglass
;
; in:   -
;
; out:  R0-R3 corrupted
;

FillHourglass ROUT
        LDRB    r0, HourglassState
        ADD     r0, r0, #1                              ; go to next state

      [ ursula
        TEQ     r0, #HourglassFrames
      |
        TEQ     r0, #6                                  ; keep in range 0..5
      ]
        MOVEQ   r0, #0
        STRB    r0, HourglassState

      [ debug :LOR: ursula
        ADRL    r1, DiffOffsetTable
      |
        ADR     r1, DiffOffsetTable
      ]
        LDR     r0, [r1, r0, LSL #2]                    ; load offset to diff table
        ADD     r0, r0, r1                              ; convert to address
        ADR     r3, HourglassData
        LDR     r1, [r0], #4
10
        MOV     r2, r1, LSR #16
        STRB    r2, [r3, r2, LSR #8]
        EOR     r2, r1, r2, LSL #16
        STRB    r2, [r3, r2, LSR #8]

        LDR     r1, [r0], #4
        TEQ     r1, #0
        BNE     %BT10
        MOV     pc, lr

; *****************************************************************************
;
;       SetupLEDs - Set up LED data in hourglass shape
;
; in:   -
;
; out:  R0-R3 corrupted
;

        ASSERT HgSize = 16
        ASSERT HgY > 0
        ASSERT (HgX :MOD: PixelsPerByte) = 0

SetupLEDs ROUT
        LDRB    r0, OldLEDs
        LDRB    r1, NewLEDs
        TEQ     r0, r1
        MOVEQ   pc, r14

        STRB    r1, OldLEDs
        ADR     r2, HourglassData+(HgX/PixelsPerByte)+((HgY-1)*BytesPerLine)
        TST     r1, #1
        MOVNE   r3, #&FF
        MOVEQ   r3, #&55
        STRB    r3, [r2, #0]
        STRB    r3, [r2, #1]
        STRB    r3, [r2, #2]
        STRB    r3, [r2, #3]

        ADD     r2, r2, #(HgSize+1)*BytesPerLine
        TST     r1, #2
        MOVNE   r3, #&FF
        MOVEQ   r3, #&55
        STRB    r3, [r2, #0]
        STRB    r3, [r2, #1]
        STRB    r3, [r2, #2]
        STRB    r3, [r2, #3]

        MOV     pc, lr

; *****************************************************************************
;
;       SetupPercentage - Set up percentage digits in hourglass shape
;
; in:   -
;
; out:  R0-R3 corrupted
;

SetupPercentage ROUT
        LDRB    r1, OldPercentage
        LDRB    r2, NewPercentage
        TEQ     r1, r2
        MOVEQ   pc, r14

        Push    "r14"
        STRB    r2, OldPercentage
        CMP     r2, #100
        BHS     %f1                                     ; turn it off
        MOV     r1, #10
        DivRem  r0, r2, r1, r14

      [ debug :LOR: ursula
        ADRL    r3, ChDefNumbers
      |
        ADR     r3, ChDefNumbers
      ]
      
 ASSERT  CharHeight = 9
        ADD     r1, r0, r0, LSL #3  ; * 9
        ADD     r1, r3, r1, LSL #1
        ADR     r0, HourglassData+(PercX/PixelsPerByte)+(PercY * BytesPerLine)
        BL      SetupChar
        ADD     r1, r2, r2, LSL #3  ; * 9
        ADD     r1, r3, r1, LSL #1
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        ADRL    r1, ChDefPercent
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        Pull    "pc"
1
        ADR     r0, HourglassData+(PercX/PixelsPerByte)+(PercY * BytesPerLine)
      [ debug :LOR: ursula
        ADRL    r1, ChDefSpace
      |
        ADR     r1, ChDefSpace
      ]
        BL      SetupChar
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        ADD     r0, r0, #8 / PixelsPerByte
        BL      SetupChar
        Pull    "pc"

; *****************************************************************************
;
;       SetupChar - Copy character definition into hourglass shape
;
; in:   R0 = address of top left of character in hourglass
;       R1 = address of first byte of character definition
;

SetupChar ROUT
        Push    "r0-r2, lr"
        MOV     r2, #9
SetupCharLoop
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #1
        LDRB    r14, [r1], #1
        STRB    r14, [r0], #BytesPerLine-1
        SUBS    r2, r2, #1
        BNE     SetupCharLoop
        Pull    "r0-r2, pc"


 [ ursula
; *****************************************************************************
;
;       ProgramPointer - Call OS_Word to define pointer shape
;

ProgramPointer ROUT
        Push    "r0-r9, lr"

        LDRB    r0, Block_PointerNumber
        EOR     r0, r0, #(3 :EOR: 4)
        STRB    r0, Block_PointerNumber

        MOV     r0, #PointerOSWord
        ADRL     r1, OSWord15Block
        SWI     XOS_Word                                ; reprogram our pointer

        BL      ReadPointerColours                      ; get CurrentColours
        
        ADR     r0, NextHColours
        LDMIA   r0, { r4, r5, r6 }
        ADR     r0, CurrentColours
        LDMIA   r0, { r7, r8, r9 }
        
        TEQ     r7, r4                                  ; set the colour(s)/number for the next frame
        TEQEQ   r8, r5                                  ; avoid reprogramming colours unless strictly necessary
        TEQEQ   r9, r6
        MOVNE   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWINE   XOS_Byte
        MOV     r0, #1
        TEQ     r7, r4
        MOVNE   r1, r4
        BLNE    SetColour ; logical Colour 1
        MOV     r0, #2
        TEQ     r8, r5
        MOVNE   r1, r5
        BLNE    SetColour ; logical Colour 2       
        MOV     r0, #3
        TEQ     r9, r6
        MOVNE   r1, r6
        BLNE    SetColour ; logical Colour 3
        MOV     r0, #SetPointer
        LDRB    r1, Block_PointerNumber
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r1, r1, #&FF
        
        CMP     r1, #3                                  ; if we weren't the last to set a colour/number,
        STRLOB  r1, ReturnPointer                       ; remember the current one for when we switch off
        ADR     r0, LastHColours
        LDMIA   r0, { r1, r2, r3 }
        TEQ     r7, r1
        STRNE   r7, ReturnColour1
        TEQ     r8, r2
        STRNE   r8, ReturnColour2
        TEQ     r9, r3
        STRNE   r9, ReturnColour3
        
        STMIA   r0, { r4, r5, r6 }                          ; LastHColours = NextHColours

        Pull    "r0-r9, pc"

        LTORG
 ]


; *****************************************************************************
;
;       SetColour - Program a pointer colour
;
; in:   R0 = pointer colour to program (1..3)
;       R1 = value to program &00BBGGRR
;
; out:  -
;

SetColour ROUT
        Push    "r0-r1, lr"
        ORR     r0, r0, r1, LSL #16
        ORR     r0, r0, #&1900
        MOV     r14, r1, LSR #16
        Push    "r0, r14"                               ; Put data in to a stack frame
        MOV     r1, sp                                  ; Address of recently stored data
        MOV     r0, #WritePalette
        SWI     XOS_Word
        ADD     sp, sp, #8                              ; Trash stack frame
        Pull    "r0-r1, pc"


 [ ursula
; *****************************************************************************
;
;       InitialisePointerInfo - sets up colour, number etc information
;
; in:   -
;
; out:  Registers preserved.

InitialisePointerInfo ENTRY "r0-r3"
        BL      ReadPointerColours                      ; get CurrentColours
        
        ADR     r0, CurrentColours                      ; Return = Current
        LDMIA   r0, { r1, r2, r3 }
        ADR     r0, ReturnColours
        STMIA   r0, { r1, r2, r3 }
        MOV     r0, #1
        STRB    r0, ReturnPointer ; mustn't read current pointer
                                  ; number here, it causes flicker
        
        ADRL    r0, DefaultColours                      ; NextH = Default
        LDMIA   r0, { r1, r2, r3 }
        ADR     r0, NextHColours
        STMIA   r0, { r1, r2, r3 }
        
        MOV     r0, #-1                                 ; LastH = -1 (ie guaranteed != current)
        STR     r0, LastHColour1
        STR     r0, LastHColour2
        STR     r0, LastHColour3
        
        MOV     r0, #1
        STRB    r0, PointerDirty                        ; indicate shape needs setting up

        MOV     r0, #0
        STRB    r0, OldLEDs
        STRB    r0, NewLEDs

        EXIT
 ]


 [ ursula
; *****************************************************************************
;
;       RestorePointer - changes pointer number and colours back to the "off" values.
;
; in:   -
;
; out:  Registers preserved.

RestorePointer ENTRY "r0-r5,r9-r11"
        BL      ReadPointerColours                      ; get CurrentColours

        MOV     r0, #SetPointer                         ; restore old pointer iff it was most recently changed by us
        LDRB    r1, ReturnPointer
        SWI     XOS_Byte ; on exit, R1 is old shape/linkage
        AND     r3, r1, #&FF
        CMP     r3, #3
        SWILO   XOS_Byte ; Oops, shouldn't have done that
                         ; because someone else had changed
                         ; the pointer - switch it back.
                         ; Having pointer-switch flicker
                         ; here is far better than having it
                         ; during a pre-emptive read routine.

        LDR     r9, LastHColour1                       ; restore old colour(s) iff they were most recently changed by us
        LDR     r10, LastHColour2
        LDR     r11, LastHColour3
        LDR     r3, CurrentColour1
        LDR     r4, CurrentColour2
        LDR     r5, CurrentColour3
        TEQ     r3, r9
        TEQNE   r4, r10
        TEQNE   r5, r11
        MOVEQ   r0, #WaitForVSync                       ; at least one needs changing, so wait until VSync
        SWIEQ   XOS_Byte                                ; if called R1, R2 trashed

        MOV     r0, #1
        TEQ     r3, r9
        LDREQ   r1, ReturnColour1
        BLEQ    SetColour ; logical Colour 1

        MOV     r0, #2
        TEQ     r4, r10
        LDREQ   r1, ReturnColour2
        BLEQ    SetColour ; logical Colour 2
        
        MOV     r0, #3
        TEQ     r5, r11
        LDREQ   r1, ReturnColour3
        BLEQ    SetColour ; logical Colour 3

        EXIT
 ]

 
; *****************************************************************************
;
;       ReadPointerColours - read the current pointer number and colours 1 & 3
;       The colours are stored in CurrentColour1 and CurrentColour3.
;
; in:   -
;
; out:  Registers preserved.

ReadPointerColours ENTRY "r0-r3"
        MOV     r0, #1
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour1
        Debug   current, "Current colour 1 =", r2

 [ ursula
        MOV     r0, #2
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour2
        Debug   current, "Current colour 2 =", r2
 ]

        MOV     r0, #3
        MOV     r1, #25
        SWI     XOS_ReadPalette
        MOVVC   r2, r2, LSR #8
        STRVC   r2, CurrentColour3
        Debug   current, "Current colour 3 =", r2
        
        EXIT


; ***************************************************************************
; Hourglass data

        ALIGN
HourglassShape
        DCB     &00, &a8, &aa, &aa, &aa, &00
        DCB     &00, &f8, &ff, &ff, &bf, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &d8, &ff, &ff, &9f, &00
        DCB     &00, &d8, &ff, &ff, &9f, &00
        DCB     &00, &60, &ff, &ff, &27, &00
        DCB     &00, &60, &ff, &ff, &27, &00
        DCB     &00, &80, &fd, &ff, &09, &00
        DCB     &00, &00, &f6, &7f, &02, &00
        DCB     &00, &00, &d8, &9f, &00, &00
        DCB     &00, &00, &58, &95, &00, &00
        DCB     &00, &00, &56, &57, &02, &00
        DCB     &00, &80, &55, &55, &09, &00
        DCB     &00, &60, &55, &57, &25, &00
        DCB     &00, &60, &55, &55, &25, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &58, &55, &55, &95, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &58, &55, &57, &95, &00
        DCB     &00, &f8, &ff, &ff, &bf, &00
        DCB     &00, &a8, &aa, &aa, &aa, &00
        ALIGN
HourglassShapeEnd


DiffOffsetTable
       &       ShapeDiffs0-DiffOffsetTable
       &       ShapeDiffs1-DiffOffsetTable
       &       ShapeDiffs2-DiffOffsetTable
       &       ShapeDiffs3-DiffOffsetTable
       &       ShapeDiffs4-DiffOffsetTable
       &       ShapeDiffs5-DiffOffsetTable
       &       ShapeDiffs6-DiffOffsetTable
       &       ShapeDiffs7-DiffOffsetTable


ShapeDiffs1
        DCB     &d5,&74, &5f,&75
        DCB     &00,&00, &00,&00

ShapeDiffs2
        DCB     &58,&19, &55,&1a, &55,&1b, &95,&1c, &57,&69, &d5,&6e
        DCB     &5f,&6f, &f5,&74, &7f,&75, &7f,&75
        DCB     &00,&00, &00,&00

ShapeDiffs3
        DCB     &58,&1f, &55,&20, &55,&21, &95,&22, &d5,&68, &5f,&69
        DCB     &f5,&6e, &7f,&6f, &fd,&74, &ff,&75
        DCB     &00,&00, &00,&00

ShapeDiffs4
        DCB     &55,&26, &55,&27, &25,&28, &57,&5d, &d5,&62, &5f,&63
        DCB     &f5,&68, &7f,&69, &fd,&6e, &ff,&6f, &ff,&74, &97,&76
        DCB     &00,&00, &00,&00

ShapeDiffs5
        DCB     &55,&2c, &55,&2d, &25,&2e, &d5,&5c, &5f,&5d, &f5,&62
        DCB     &7f,&63, &fd,&68, &ff,&69, &ff,&6e, &97,&70, &d8,&73
        DCB     &9f,&76, &9f,&76
        DCB     &00,&00, &00,&00

ShapeDiffs6
        DCB     &55,&32, &55,&33, &55,&4b, &57,&51, &d5,&56, &5f,&57
        DCB     &f5,&5c, &7f,&5d, &fd,&62, &ff,&63, &ff,&68, &97,&6a
        DCB     &d8,&6d, &9f,&70
        DCB     &00,&00, &00,&00

ShapeDiffs7
        DCB     &56,&38, &55,&39, &58,&3e, &95,&3f, &d5,&50, &5f,&51
        DCB     &f5,&56, &7f,&57, &fd,&5c, &ff,&5d, &ff,&62, &97,&64
        DCB     &d8,&67, &9f,&6a
        DCB     &00,&00, &00,&00

ShapeDiffs0
        DCB     &d8,&19, &ff,&1a, &ff,&1b, &9f,&1c, &d8,&1f, &ff,&20
        DCB     &ff,&21, &9f,&22, &ff,&26, &ff,&27, &27,&28, &ff,&2c
        DCB     &ff,&2d, &27,&2e, &fd,&32, &ff,&33, &f6,&38, &7f,&39
        DCB     &d8,&3e, &9f,&3f, &57,&4b, &55,&50, &55,&51, &55,&56
        DCB     &57,&57, &55,&5c, &55,&5d, &55,&62, &57,&63, &95,&64
        DCB     &58,&67, &55,&68, &55,&69, &95,&6a, &58,&6d, &55,&6e
        DCB     &57,&6f, &95,&70, &58,&73, &55,&74, &57,&75, &95,&76
        DCB     &00,&00, &00,&00


; ***************************************************************************
; Character definitions

        ALIGN
ChDefSpace
        DCD     0, 0, 0, 0, 0

ChDefNumbers
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&7f,&fd,&5f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&7f,&fd,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&ff,&d7,&7f,&f5,&5f,&ff,&d7,&ff,&57,&d5,&ff,&ff
    = &ff,&ff,&5f,&f5,&57,&d7,&ff,&d7,&ff,&f5,&ff,&d7,&57,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&7f,&f5,&5f,&f5,&d7,&f5,&d7,&f5,&57,&d5,&ff,&f5,&ff,&f5,&ff,&ff
    = &ff,&ff,&57,&d5,&d7,&ff,&57,&f5,&ff,&d7,&ff,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&5f,&d5,&d7,&ff,&d7,&ff,&57,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&57,&d5,&ff,&f5,&7f,&fd,&7f,&fd,&5f,&ff,&5f,&ff,&5f,&ff,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&f5,&ff,&ff
    = &ff,&ff,&5f,&f5,&d7,&d7,&d7,&d7,&5f,&d5,&ff,&d7,&ff,&d7,&5f,&f5,&ff,&ff

ChDefPercent
    = &ff,&ff,&df,&df,&77,&f7,&77,&f7,&df,&dd,&7f,&77,&7f,&77,&df,&df,&ff,&ff


        END
