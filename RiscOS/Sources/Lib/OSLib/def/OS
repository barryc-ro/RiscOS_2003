TITLE OS;

CONST
   OS_ErrorLimit    = .Int: 252,
   OS_FileNameLimit = .Int: 256,
   OS_CLILimit      = .Int: 256;

TYPE
   OS_T              = .Int,   //monotonic time
   OS_F              = .Byte,  //file handle
   OS_Mode,                    //mode number
   OS_GCOL           = .Byte,  //graphical colour
   OS_Tint           = .Byte,  //graphical tint
   OS_Action         = .Byte,  //graphical action
   OS_Colour         = .Bits, //(r, g, b) triplet
   OS_ColourNumber   = .Int,   //number for screen memory
   OS_ColourPair     = .Struct (OS_Colour: on, OS_Colour: off),
   OS_Palette        = .Struct (OS_Colour: entries ...),
   OS_SpritePalette  = .Struct (OS_ColourPair: entries ...),
   OS_ECF            = .Struct ([8] .Bits: ecf),
   OS_CorrectionTable = .Struct ([256] .Byte: gamma),
   OS_BCDDateAndTime = .Struct (.Byte: year, .Byte: month, .Byte: date,
                             .Byte: weekday, .Byte: hour, .Byte: minute,
                             .Byte: second),
   OS_StationNumber  = .Struct (.Int: station, .Int: net),
   OS_Box            = .Struct (.Int: x0, .Int: y0, .Int: x1, .Int: y1),
   OS_Factors        = .Struct (.Int: xmul, .Int: ymul, .Int: xdiv,
                             .Int: ydiv),
   OS_ChangeBox      = .Struct (.Int: state, OS_Box: box),
   OS_Error          = .Struct (.Bits: errnum, [OS_ErrorLimit] .Char: errmess),
   OS_DateAndTime    = [5] .Byte, //cannot be in a struct: alignment fouls up
   OS_Coord          = .Struct (.Int: x, .Int: y),
   OS_Trfm           = .Struct ([3] [2] .Int: entries),
   OS_HomTrfm        = .Struct ([2] [2] .Int: entries),
   OS_Pgm            = .Struct ([4] OS_Coord: coords),

   OS_ErrorHandlerBuffer = .Struct (.Int: pc, .Bits: errnum, 
                             [248] .Char: errmess);

CONST
   //For the parts of an OS_Colour
   OS_RShift      = .Int: 8,
   OS_GShift      = .Int: 16,
   OS_BShift      = .Int: 24,
   OS_R           = .Bits: &FF00,
   OS_G           = .Bits: &FF0000,
   OS_B           = .Bits: &FF000000,
   OS_ColourRange = .Int: 255;

CONST
   OS_Mode1bpp90x45 = OS_Mode: 0,
   OS_Mode2bpp90x45 = OS_Mode: 8,
   OS_Mode4bpp90x45 = OS_Mode: 12,
   OS_Mode8bpp90x45 = OS_Mode: 15,
// OS_Mode1bpp45x45 doesn't exist
   OS_Mode2bpp45x45 = OS_Mode: 1,
   OS_Mode4bpp45x45 = OS_Mode: 9,
   OS_Mode8bpp45x45 = OS_Mode: 13,
   OS_Mode1bpp90x90 = OS_Mode: 25,
   OS_Mode2bpp90x90 = OS_Mode: 26,
   OS_Mode4bpp90x90 = OS_Mode: 27,
   OS_Mode8bpp90x90 = OS_Mode: 28;

CONST
   OS_Inch = .Int: 180; //1in in O S units

CONST
   //for OS_WriteC/VDU
   OS_VDUNull              = .Char:   0,
   OS_VDUCharToPrinter     = .Char:   1,
   OS_VDUPrinterOn         = .Char:   2,
   OS_VDUPrinterOff        = .Char:   3,
   OS_VDUGraphTextOff      = .Char:   4,
   OS_VDUGraphTextOn       = .Char:   5,
   OS_VDUScreenOn          = .Char:   6,
   OS_VDUBell              = .Char:   7,
   OS_VDUBackspace         = .Char:   8,
   OS_VDUTab               = .Char:   9,
   OS_VDULinefeed          = .Char:  10,
   OS_VDUVerticalTab       = .Char:  11,
   OS_VDUClS               = .Char:  12,
   OS_VDUReturn            = .Char:  13,
   OS_VDUPageModeOn        = .Char:  14,
   OS_VDUPageModeOff       = .Char:  15,
   OS_VDUClG               = .Char:  16,
   OS_VDUSetTextColour     = .Char:  17,
   OS_VDUSetGCOL           = .Char:  18,
   OS_VDUSetPalette        = .Char:  19,
   OS_VDUResetColours      = .Char:  20,
   OS_VDUScreenOff         = .Char:  21,
   OS_VDUMode              = .Char:  22,
   OS_VDUMisc              = .Char:  23,
   OS_VDUSetGraphicsWindow = .Char:  24,
   OS_VDUPlot              = .Char:  25,
   OS_VDUResetWindows      = .Char:  26,
   OS_VDUEscape            = .Char:  27,
   OS_VDUSetTextWindow     = .Char:  28,
   OS_VDUSetGraphicsOrigin = .Char:  29,
   OS_VDUHomeTextCursor    = .Char:  30,
   OS_VDUSetTextCursor     = .Char:  31,
   OS_VDUDelete            = .Char: 127;

CONST
   //For VDU 23
   OS_MiscInterlace         = .Char:  0,
   OS_MiscCursor            = .Char:  1,
   OS_MiscSetECF1           = .Char:  2,
   OS_MiscSetECF2           = .Char:  3,
   OS_MiscSetECF3           = .Char:  4,
   OS_MiscSetECF4           = .Char:  5,
   OS_MiscSetDotStyle       = .Char:  6,
   OS_MiscScroll            = .Char:  7,
   OS_MiscClearRegion       = .Char:  8,
   OS_MiscSetOn             = .Char:  9,
   OS_MiscSetOff            = .Char: 10,
   OS_MiscSetBBCECF         = .Char: 11,
   OS_MiscSetUnpackedECF1   = .Char: 12,
   OS_MiscSetUnpackedECF2   = .Char: 13,
   OS_MiscSetUnpackedECF3   = .Char: 14,
   OS_MiscSetUnpackedECF4   = .Char: 15,
   OS_MiscSetCursorMovement = .Char: 16,
   OS_MiscMisc              = .Char: 17;

CONST
   //For VDU 23, 17
   OS_MiscSetTextFGTint        = .Char: 0,
   OS_MiscSetTextBGTint        = .Char: 1,
   OS_MiscSetGraphicsFGTint    = .Char: 2,
   OS_MiscSetGraphicsBGTint    = .Char: 3,
   OS_MiscSetECFInterpretation = .Char: 4,
   OS_MiscInvertText           = .Char: 5,
   OS_MiscSetECFOrigin         = .Char: 6,
   OS_MiscSetCharSize          = .Char: 7;

CONST
   OS_ActionOverwrite        = OS_Action: 0,
   OS_ActionDisjoin          = OS_Action: 1,
   OS_ActionConjoin          = OS_Action: 2,
   OS_ActionExclusiveDisjoin = OS_Action: 3,
   OS_ActionInvert           = OS_Action: 4,
   OS_ActionIdentity         = OS_Action: 5,
   OS_ActionConjoinNegation  = OS_Action: 6,
   OS_ActionDisjoinNegation  = OS_Action: 7,
   OS_ActionUseMask          = OS_Action: 8,
   OS_ActionUseECF1          = OS_Action: 0x10,
   OS_ActionUseECF2          = OS_Action: 0x20,
   OS_ActionUseECF3          = OS_Action: 0x30,
   OS_ActionUseECF4          = OS_Action: 0x40,
   OS_ActionUseGiantECF      = OS_Action: 0x50,
   OS_ActionUseSpritePalette = OS_Action: %100000; //RO3.5

CONST
   //for VDU driver
   OS_GCOLSetFG = OS_GCOL: 0b0,
   OS_GCOLSetBG = OS_GCOL: 0b10000000;

CONST
   //For OS_Plot
   OS_PlotSolid             = .Int: 0x00,
   OS_PlotSolidExEnd        = .Int: 0x08,
   OS_PlotDotted            = .Int: 0x10,
   OS_PlotDottedExEnd       = .Int: 0x18,
   OS_PlotSolidExStart      = .Int: 0x20,
   OS_PlotSolidExBoth       = .Int: 0x28,
   OS_PlotDottedExStart     = .Int: 0x30,
   OS_PlotDottedExBoth      = .Int: 0x38,
   OS_PlotPoint             = .Int: 0x40,
   OS_PlotHorizontalToNonBG = .Int: 0x48,
   OS_PlotTriangle          = .Int: 0x50,
   OS_PlotRightToBG         = .Int: 0x58,
   OS_PlotRectangle         = .Int: 0x60,
   OS_PlotHorizontalToFG    = .Int: 0x68,
   OS_PlotParallelogram     = .Int: 0x70,
   OS_PlotRightToNonFG      = .Int: 0x78,
   OS_PlotFloodToNonBG      = .Int: 0x80,
   OS_PlotFloodToFG         = .Int: 0x88,
   OS_PlotCircleOutline     = .Int: 0x90,
   OS_PlotCircle            = .Int: 0x98,
   OS_PlotArc               = .Int: 0xA0,
   OS_PlotSegment           = .Int: 0xA8,
   OS_PlotSector            = .Int: 0xB0,
   OS_PlotBlock             = .Int: 0xB8,
   OS_PlotEllipseOutline    = .Int: 0xC0,
   OS_PlotEllipse           = .Int: 0xC8,

   OS_MoveBy        = .Int: 0,
   OS_PlotBy        = .Int: 1,
   OS_PlotInverseBy = .Int: 2,
   OS_PlotBGBy      = .Int: 3,
   OS_MoveTo        = .Int: 4,
   OS_PlotTo        = .Int: 5,
   OS_PlotInverseTo = .Int: 6,
   OS_PlotBGTo      = .Int: 7,

   //For OS_{Read,Set}VarVal
   OS_VartypeString        = .Int: 0,
   OS_VartypeNumber        = .Int: 1,
   OS_VartypeMacro         = .Int: 2,
   OS_VartypeExpanded      = .Int: 3,
   OS_VartypeLiteralString = .Int: 4,
   OS_VartypeCode          = .Int: 16;

CONST
   OS_ModevarModeFlags    = .Int: 0,
   OS_ModevarRScreen      = .Int: 1,
   OS_ModevarBScreen      = .Int: 2,
   OS_ModevarNColour      = .Int: 3,
   OS_ModevarXEigFactor   = .Int: 4,
   OS_ModevarYEigFactor   = .Int: 5,
   OS_ModevarLineLength   = .Int: 6,
   OS_ModevarScreenSize   = .Int: 7,
   OS_ModevarYShiftFactor = .Int: 8,
   OS_ModevarLog2BPP      = .Int: 9,
   OS_ModevarLog2BPC      = .Int: 10,
   OS_ModevarXWindLimit   = .Int: 11,
   OS_ModevarYWindLimit   = .Int: 12;

CONST
   OS_ModeFlagNonGraphics    = .Bits: %1,
   OS_ModeFlagTeletext       = .Bits: %10,
   OS_ModeFlagGap            = .Bits: %100,
   OS_ModeFlagBBCGap         = .Bits: %1000,
   OS_ModeFlagHiResMono      = .Bits: %10000,
   OS_ModeFlagDoubleHeight   = .Bits: %100000,
   OS_ModeFlagHardwareScroll = .Bits: %1000000,
   OS_ModeFlagFullPalette    = .Bits: %10000000;

CONST
   OS_VduvarGWLCol          = .Int: 128,
   OS_VduvarGWBRow          = .Int: 129,
   OS_VduvarGWRCol          = .Int: 130,
   OS_VduvarGWTRow          = .Int: 131,
   OS_VduvarTWLCol          = .Int: 132,
   OS_VduvarTWBRow          = .Int: 133,
   OS_VduvarTWRCol          = .Int: 134,
   OS_VduvarTWTRow          = .Int: 135,
   OS_VduvarOrgX            = .Int: 136,
   OS_VduvarOrgY            = .Int: 137,
   OS_VduvarGCsX            = .Int: 138,
   OS_VduvarGCsY            = .Int: 139,
   OS_VduvarOlderCsX        = .Int: 140,
   OS_VduvarOlderCsY        = .Int: 141,
   OS_VduvarOldCsX          = .Int: 142,
   OS_VduvarOldCsY          = .Int: 143,
   OS_VduvarGCsIX           = .Int: 144,
   OS_VduvarGCsIY           = .Int: 145,
   OS_VduvarNewPtX          = .Int: 146,
   OS_VduvarNewPtY          = .Int: 147,
   OS_VduvarScreenStart     = .Int: 148,
   OS_VduvarDisplayStart    = .Int: 149,
   OS_VduvarTotalScreenSize = .Int: 150,
   OS_VduvarGPLFMD          = .Int: 151,
   OS_VduvarGPLBMD          = .Int: 152,
   OS_VduvarGFCOL           = .Int: 153,
   OS_VduvarGBCOL           = .Int: 154,
   OS_VduvarTForeCol        = .Int: 155,
   OS_VduvarTBackCol        = .Int: 156,
   OS_VduvarGFTint          = .Int: 157,
   OS_VduvarGBTint          = .Int: 158,
   OS_VduvarTFTint          = .Int: 159,
   OS_VduvarTBTint          = .Int: 160,
   OS_VduvarMaxMode         = .Int: 161,
   OS_VduvarGCharSizeX      = .Int: 162,
   OS_VduvarGCharSizeY      = .Int: 163,
   OS_VduvarGCharSpaceX     = .Int: 164,
   OS_VduvarGCharSpaceY     = .Int: 165,
   OS_VduvarHLineAddr       = .Int: 166,
   OS_VduvarTCharSizeX      = .Int: 167,
   OS_VduvarTCharSizeY      = .Int: 168,
   OS_VduvarTCharSpaceX     = .Int: 169,
   OS_VduvarTCharSpaceY     = .Int: 170,
   OS_VduvarGCOLOraEorAddr  = .Int: 171,
   OS_VduvarVIDCClockSpeed  = .Int: 172,
   OS_VduvarWindowWidth     = .Int: 256,
   OS_VduvarWindowHeight    = .Int: 257;

CONST
   OS_Foreground = .Bits: 0,
   OS_Background = .Bits: %10000000;

CONST
   OS_ColourTransparent   = OS_Colour: &FFFFFFFF,

   //primaries and secondaries
   OS_ColourRed           = OS_Colour: &0000FF00,
   OS_ColourGreen         = OS_Colour: &00FF0000,
   OS_ColourBlue          = OS_Colour: &FF000000,
   OS_ColourCyan          = OS_Colour: &FFFF0000,
   OS_ColourMagenta       = OS_Colour: &FF00FF00,
   OS_ColourYellow        = OS_Colour: &00FFFF00,

   //greyscale
   OS_ColourWhite         = OS_Colour: &FFFFFF00,
   OS_ColourVeryLightGrey = OS_Colour: &DDDDDD00,
   OS_ColourLightGrey     = OS_Colour: &BBBBBB00,
   OS_ColourMidLightGrey  = OS_Colour: &99999900,
   OS_ColourMidDarkGrey   = OS_Colour: &77777700,
   OS_ColourDarkGrey      = OS_Colour: &55555500,
   OS_ColourVeryDarkGrey  = OS_Colour: &33333300,
   OS_ColourBlack         = OS_Colour: &00000000,

   //WIMP colours
   OS_ColourDarkBlue      = OS_Colour: &99440000,
   OS_ColourLightYellow   = OS_Colour: &00EEEE00,
   OS_ColourLightGreen    = OS_Colour: &00CC0000,
   OS_ColourLightRed      = OS_Colour: &0000DD00,
   OS_ColourCream         = OS_Colour: &BBEEEE00,
   OS_ColourDarkGreen     = OS_Colour: &00885500,
   OS_ColourOrange        = OS_Colour: &00BBFF00,
   OS_ColourLightBlue     = OS_Colour: &FFBB0000;

CONST //device numbers
   OS_DevicePrinterBusy           = .Int: 0,
   OS_DeviceSerialRinging         = .Int: 1,
   OS_DevicePrinterAcknowledge    = .Int: 2,
   OS_DeviceVSync                 = .Int: 3,
   OS_DevicePowerOn               = .Int: 4,
   OS_DeviceIOCTimer0             = .Int: 5,
   OS_DeviceIOCTimer1             = .Int: 6,
   OS_DeviceFIQDowngrade          = .Int: 7,
   OS_DeviceExpansionFIQDowngrade = .Int: 8,
   OS_DeviceSoundBuffer           = .Int: 9,
   OS_DeviceSerialController      = .Int: 10,
   OS_DeviceHardDiscController    = .Int: 11,
   OS_DeviceFloppyDiscChanged     = .Int: 12,
   OS_DeviceExpansionCard         = .Int: 13,
   OS_DeviceKeyboardTxEmpty       = .Int: 14,
   OS_DeviceKeyboardRxFull        = .Int: 15;

CONST //82C71[01] device numbers
   OS_DevicePrinter         = .Int: 0,
   OS_DeviceBatteryWarning  = .Int: 1,
   OS_DeviceFloppyDiscIndex = .Int: 2,
   OS_DeviceIDEDisc         = .Int: 11;

CONST
   //Structure of an error number:
   OS_ErrorNumberShift    = .Int: 0,      //shift
   OS_ErrorNumber         = .Bits: &FF,   //mask
   OS_ErrorSourceShift    = .Int: 8,      //shift
   OS_ErrorSource         = .Bits: &FFFF00, //mask
   OS_ErrorCategoryShift  = .Int: 24,     //shift
   OS_ErrorCategory       = .Bits: &7000000,  //mask

   OS_CategoryUnclassified = .Int: 0,
   OS_CategoryInformation  = .Int: 1,
   OS_CategoryWarning      = .Int: 2,
   OS_CategorySystem       = .Int: 3;

CONST
   //Error messages in Resources.Global.Messages. THESE SHOULD BE MATCHED UP
   //PROPERLY with the error numbers they actually correspond to!!!
   OS_GlobalEscape     = .Int: 1,
   OS_GlobalFatal      = .Int: 2,
   OS_GlobalIsAFil     = .Int: 3,
   OS_GlobalIsntFil    = .Int: 4,
   OS_GlobalIsADir     = .Int: 5,
   OS_GlobalIsntDir    = .Int: 6,
   OS_GlobalNoFile     = .Int: 7,
   OS_GlobalNoDir      = .Int: 8,
   OS_GlobalNoAny      = .Int: 9,
   OS_GlobalTypsBad    = .Int: 10,
   OS_GlobalBadRen     = .Int: 11,
   OS_GlobalBadAcc     = .Int: 12,
   OS_GlobalOpnFils    = .Int: 13,
   OS_GlobalBadName    = .Int: 14,
   OS_GlobalLongNam    = .Int: 15,
   OS_GlobalChannel    = .Int: 16,
   OS_GlobalBadSWI     = .Int: 17,
   OS_GlobalModInUs    = .Int: 18,
   OS_GlobalStrOFlo    = .Int: 19,
   OS_GlobalNumOFlo    = .Int: 20,
   OS_GlobalBufOFlo    = .Int: 21,
   OS_GlobalBadStn     = .Int: 22,
   OS_GlobalBadNet     = .Int: 23,
   OS_GlobalFullNet    = .Int: 24,
   OS_GlobalNoEco      = .Int: 25,
   OS_GlobalBadRead    = .Int: 26,
   OS_GlobalBadWrt     = .Int: 27,
   OS_GlobalDataLst    = .Int: 28,
   OS_GlobalBadFSOp    = .Int: 29,
   OS_GlobalFSNoRd     = .Int: 30,
   OS_GlobalFSNoWrt    = .Int: 31,
   OS_GlobalFSInUse    = .Int: 32,
   OS_GlobalBadAddress = .Int: 33,
   OS_GlobalNoStore    = .Int: 34,
   OS_GlobalRAMLoadC   = .Int: 35,
   OS_GlobalDDS0       = .Int: 36,
   OS_GlobalDDS1       = .Int: 37,
   OS_GlobalDDS2       = .Int: 38,
   OS_GlobalDDS3       = .Int: 39,
   OS_GlobalCSDS       = .Int: 40,
   OS_GlobalLDS        = .Int: 41,
   OS_GlobalURDS       = .Int: 42,
   OS_GlobalDr         = .Int: 43,
   OS_GlobalApp        = .Int: 44,
   OS_GlobalExDt       = .Int: 45,
   OS_GlobalExLdEx     = .Int: 46,
   OS_GlobalUseDesk    = .Int: 47,
   OS_GlobalAppQuit    = .Int: 48,
   OS_GlobalNoMem      = .Int: 49,
   OS_GlobalBadHard    = .Int: 50,
   OS_GlobalBadParm    = .Int: 51,
   OS_GlobalNoWimp     = .Int: 52;

CONST
   //General OS errors
   Error_Escape = .Bits: 17,
   Error_BadMode = .Bits: 25,
   Error_IsADir = .Bits: 168,
   Error_TypesDontMatch = .Bits: 175,
   Error_BadRename = .Bits: 176,
   Error_BadCopy = .Bits: 177,
   Error_OutsideFile = .Bits: 183,
   Error_AccessViolation = .Bits: 189,
   Error_TooManyOpenFiles = .Bits: 192,
   Error_NotOpenForUpdate = .Bits: 193,
   Error_FileOpen = .Bits: 194,
   Error_ObjectLocked = .Bits: 195,
   Error_AlreadyExists = .Bits: 196,
   Error_BadFileName = .Bits: 204,
   Error_FileNotFound = .Bits: 214,
   Error_Syntax = .Bits: 220,
   Error_BadNoParms = .Bits: 220,
   Error_TooManyParms = .Bits: 220,
   Error_Channel = .Bits: 222,
   Error_EndOfFile = .Bits: 223,
   Error_BadFilingSystemName = .Bits: 248,
   Error_UnknownFilingSystem = .Bits: 248,
   Error_BadKey = .Bits: 251,
   Error_BadAddress = .Bits: 252,
   Error_BadString = .Bits: 253,
   Error_BadAliasString = .Bits: 253,
   Error_BadParmString = .Bits: 253,
   Error_WildCards = .Bits: 253, //Unfortunate clash
   Error_BadCommand = .Bits: 254,

   //Variables errors
   Error_BadMacVal = .Bits: &120,
   Error_BadVarNam = .Bits: &121,
   Error_BadVarType = .Bits: &122,
   Error_VarNoRoom = .Bits: &123,
   Error_VarCantFind = .Bits: &124,
   Error_VarTooLong = .Bits: &125,

   //General OS errors
   Error_RedirectFail = .Bits: &140,
   Error_StackFull = .Bits: &141,

   //Expression errors
   Error_BadHex = .Bits: &160,
   Error_BadExpr = .Bits: &161,
   Error_BadBra = .Bits: &162,
   Error_StkOFlo = .Bits: &163,
   Error_MissOpn = .Bits: &164,
   Error_MissOpr = .Bits: &165,
   Error_BadBits = .Bits: &166,
   Error_StrOFlo = .Bits: &167,
   Error_BadItm = .Bits: &168,
   Error_DivZero = .Bits: &169,
   Error_BadBase = .Bits: &16A,
   Error_BadNumb = .Bits: &16B,
   Error_NumbTooBig = .Bits: &16C,

   //Vector claim/release errors,
   Error_BadClaimNum = .Bits: &1A1,
   Error_BadRelease = .Bits: &1A2,
   Error_BadDevNo = .Bits: &1A3,
   Error_BadDevVecRel = .Bits: &1A4,

   //Environment alteration SWI errors
   Error_BadEnvNumber = .Bits: &1B0,
   Error_CantCancelQuit = .Bits: &1B1,

   //Change dynamic area errors
   Error_ChDynamCAO = .Bits: &1C0,
   Error_ChDynamNotAllMoved = .Bits: &1C1,
   Error_AplWSpaceInUse = .Bits: &1C2,
   Error_RAMFsUnchangeable = .Bits: &1C3,

   //OS_CLI and other errors
   Error_OSCLILongLine = .Bits: &1E0, //line too long for OS_CLI
   Error_OSCLITooHard = .Bits: &1E1, //oscli ran out of buffers
   Error_RCExc = .Bits: &1E2,
   Error_RCNegative = .Bits: &1E2,
   Error_SysHeapFull = .Bits: &1E3,
   Error_BuffOverflow = .Bits: &1E4,
   Error_BadTime = .Bits: &1E5,
   Error_NoSuchSWI = .Bits: &1E6,
   Error_Unimplemented = .Bits: &1E7,
   Error_OutOfRange = .Bits: &1E8,
   Error_NoOSCLISpecials = .Bits: &1E9,
   Error_BadParameters = .Bits: &1EA,
   Error_ArgRepeated = .Bits: &1EB,
   Error_BadReadSysInfo = .Bits: &1EC,

   //Convert date and time errors
   Error_CDATStackOverflow = .Bits: &2C0,
   Error_CDATBufferOverflow = .Bits: &2C1,
   Error_CDATBadField = .Bits: &2C2,

   Error_CantStartApplication = .Bits: &600, //Unable to start application
   Error_BadCommandOption     = .Bits: &601, //Bad command option
   Error_UnknownSerialOp      = .Bits: &602, //Unknown serial operation
   Error_BadHard              = .Bits: &603; //Unsupported hardware configuration

SWI
   //A few simple ones to start with ...
   OS_WriteC = (NUMBER 0 "Writes a character to all of the active output
         streams", ENTRY (R0 = .Char: c)),
   WrchV = (NUMBER 0x34, ENTRY (R0 = .Char: c, R9 # &03 "OS_WriteC vector")),
   OS_WriteS = (NUMBER 1 "Writes the following string to all of the
         active output streams (cannot be called via APCS)", ABSENT),
   OS_Write0 = (NUMBER 2 "Writes a string to all of the active output
         streams", ENTRY (R0 -> .String: s), EXIT (R0?)),
   OS_NewLine = (NUMBER 3 "Writes a line feed followed by a carriage
         return to all of the active output streams"),
   OS_ReadC = (NUMBER 4 "Reads a character from the input stream",
         EXIT (R0 = .Char: c, FLAGS!)),
   RdchV = (NUMBER 0x34, ENTRY (R9 # &04 "OS_ReadC vector"),
        EXIT (R0 = .Char: c, FLAGS!)),
   OS_CLI = (NUMBER 5 "Processes a supervisor command",
         ENTRY (R0 -> .String: command)),
   CLIV = (NUMBER 0x34, ENTRY (R0 -> .String: command, R9 # &05
         "OS_CLI vector"));

SWI OS_ReadLine =
   (  NUMBER 0xE "Reads a line from the input stream",
      ENTRY
      (  R0 = .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineGivenEcho =
   (  NUMBER 0xE "Reads a line from the input stream, using the given echo 
            character",
      ENTRY
      (  R0 # &40000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineSuppressInvalid =
   (  NUMBER 0xE "Reads a line from the input stream, not echoing invalid 
            characters",
      ENTRY
      (  R0 # &80000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_ReadLineGivenEchoSuppressInvalid =
   (  NUMBER 0xE "Reads a line from the input stream, using the given echo 
            character and not echoing invalid characters",
      ENTRY
      (  R0 # &C0000000,
         R0 | .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI
   ReadLineV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Ref .String: buffer,
         R1 = .Int: size,
         R2 = .Char: min_char,
         R3 = .Char: max_char,
         R4 = .Char: echo,
         R9 # &0E "OS_ReadLine vector"
      ),
      EXIT
      (  R0?,
         R1 = .Int: used,
         R2?,
         R3?,
         FLAGS!
   )  );

SWI OS_Control =
   (  NUMBER 0xF "Reads/writes handler addresses (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> .Asm: error_handler,
         R1 = .Ref OS_Error: error_buffer,
         R2 -> .Asm: escape_handler,
         R3 -> .Asm: event_handler
      ),
      EXIT
      (  R0 -> .Asm: old_error_handler,
         R1 = .Ref OS_Error: old_error_buffer,
         R2 -> .Asm: old_escape_handler,
         R3 -> .Asm: old_event_handler
   )  );

SWI OS_GetEnv =
   (  NUMBER 0x10 "Reads environment parameters",
      EXIT
      (  R0! -> .String: command,
         R1 = .Ref .Data: ram_limit,
         R2 -> OS_DateAndTime: start
   )  );

SWI OS_Exit =
   (  NUMBER 0x11 "Passes control to the most recent exit handler",
      ENTRY
      (  R0 -> OS_Error: error,
         R1 # 'ABEX',
         R2 = .Int: rc
   )  );

SWI OS_SetEnv =
   (  NUMBER 0x12 "Sets environment parameters (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> .Asm: exit_handler,
         R1 = .Ref .Data: ram_limit,
         R4 -> .Asm: undefined_instruction_handler,
         R5 -> .Asm: prefetch_abort_handler,
         R6 -> .Asm: data_abort_handler,
         R7 -> .Asm: address_exception_handler
      ),
      EXIT
      (  R0 -> .Asm: old_exit_handler,
         R1 = .Ref .Data: old_ram_limit,
         R4 -> .Asm: old_undefined_instruction_handler,
         R5 -> .Asm: old_prefetch_abort_handler,
         R6 -> .Asm: old_data_abort_handler,
         R7 -> .Asm: old_address_exception_handler
   )  );

SWI OS_IntOn = (NUMBER 0x13 "Enables interrupts (cannot be called via APCS)", 
      ABSENT);

SWI OS_IntOff = (NUMBER 0x14 "Disables interrupts (cannot be called via APCS)", 
      ABSENT);

SWI
   IrqV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &02 "Called when an unknown IRQ is detected"
   )  );

TYPE OS_RegisterBlock = .Struct ([16] .Int: registers);

SWI OS_CallBack =
   (  NUMBER 0x15 "Sets up the callback handler (prefer OS_ChangeEnvironment)",
      ENTRY
      (  R0 -> OS_RegisterBlock: register_block,
         R1 -> .Asm: call_back_handler
      ),
      EXIT
      (  R0 -> OS_RegisterBlock: old_register_block,
         R1 -> .Asm: old_call_back_handler
   )  );

SWI OS_EnterOS = (NUMBER 0x16 "Sets the processor to SVC mode (cannot be
      called via APCS)", ABSENT);

SWI OS_BreakPt = (NUMBER 0x17 "Causes a break point trap to occur and
      the break point handler to be entered");

SWI OS_BreakCtrl =
   (  NUMBER 0x18 "Sets up the break point handler (prefer 
            OS_ChangeEnvironment)",
      ENTRY
      (  R0 = .Ref OS_RegisterBlock: register_block,
         R1 -> .Asm: break_pt_handler
      ),
      EXIT
      (  R0 = .Ref OS_RegisterBlock: old_register_block,
         R1 -> .Asm: old_break_pt_handler
   )  );

SWI OS_UnusedSWI =
   (  NUMBER 0x19 "Sets up the handler for unused SWI's (prefer 
            OS_ChangeEnvironment)",
      ENTRY (R0 -> .Asm: unused_swi_handler),
      EXIT  (R0! -> .Asm: old_unused_swi_handler)
   );

SWI
   UKSWIV = (NUMBER 0x34, ENTRY (R9 # &18 "Called when an unknown SWI
         instruction is issued (cannot be called via APCS)"), ABSENT);

SWI OS_UpdateMEMC =
   (  NUMBER 0x1A "Reads or alters the contents of the MEMC control
            register",
      ENTRY
      (  R0 = .Bits: value,
         R1 = .Bits: mask
      ),
      EXIT
      (  R0! = .Bits: old_value,
         R1?
   )  );

SWI OS_SetCallBack = (NUMBER 0x1B "Causes a call to the callback handler");

SWI OS_Mouse =
   (  NUMBER 0x1C "Reads a mouse state from the buffer",
      EXIT
      (  R0 = .Int: x,
         R1 = .Int: y,
         R2 = .Bits: buttons,
         R3 = OS_T: t
   )  );

SWI
   MouseV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1A "OS_Mouse vector"
      ),
      EXIT
      (  R0 = .Int: x,
         R1 = .Int: y,
         R2 = .Bits: buttons,
         R3 = OS_T: t
   )  );

SWI OS_Claim =
   (  NUMBER 0x1F "Adds a routine to the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

SWI OS_Release =
   (  NUMBER 0x20 "Removes a routine from the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

CONST
   OS_ReadControlTerminated = .Bits: %10000000000000000000000000000000,
   OS_ReadByte              = .Bits: %1000000000000000000000000000000,
   OS_ReadLimited           = .Bits: %100000000000000000000000000000;

SWI OS_ReadUnsigned =
   (  NUMBER 0x21 "Converts a string to an unsigned number",
      ENTRY
      (  R0 = .Bits: flags,
         R1 -> .String: number,
         R2 = .Int: limit
      ),
      EXIT
      (  R1 -> .Char: end,
         R2! = .Int: value
   )  );

SWI OS_GenerateEvent = (NUMBER 0x22 "Generates an event", ABSENT);

SWI EventV = (NUMBER 0x34, ENTRY (R9 # &10 "OS_GenerateEvent vector"),
      ABSENT);
      //reason codes as OS_GenerateEvent

SWI OS_ReadVarVal =
   (  NUMBER 0x23 "Reads a variable value",
      ENTRY
      (  R0 -> .String: var,
         R1 = .Ref .String: value,
         R2 = .Int: size,
         R3 = .Int: context,
         R4 = .Int: var_type
      ),
      EXIT
      (  R0?,
         R2 = .Int: used,
         R3! = .Int: context_out,
         R4 = .Int: var_type_out
   )  );

CONST OS_DestroyVar = .Int: -1; //use in R2 of OS_SetVarVal

SWI OS_SetVarVal =
   (  NUMBER 0x24 "Writes a variable value",
      ENTRY
      (  R0 -> .String: var,
         R1 -> .Data: value,
         R2 = .Int: size,
         R3 = .Int: context,
         R4 = .Int: var_type
      ),
      EXIT
      (  R3! = .Int: context_out,
         R4 = .Int: var_type_out
   )  );

CONST
   OS_GSTerminateOnSpace  = .Bits: 0b100000000000000000000000000000,
   OS_GSRetainStick       = .Bits: 0b1000000000000000000000000000000,
   OS_GSRetainDoubleQuote = .Bits: 0b10000000000000000000000000000000;

SWI OS_GSInit =
   (  NUMBER 0x25 "Initialises context for use by OS_GSRead",
      ENTRY
      (  R0 -> .String: s,
         R2 = .Bits: flags
      ),
      EXIT
      (  R0 = .Int: context1,
         R1?,
         R2 = .Int: context2
   )  );

SWI OS_GSRead =
   (  NUMBER 0x26 "Returns a character from a string which has been
            initialised by OS_GSInit",
      ENTRY
      (  R0 = .Int: context1,
         R2 = .Int: context2
      ),
      EXIT
      (  R0 = .Int: context1_out,
         R1 = .Char: c,
         R2 = .Int: context2_out,
         FLAGS!
   )  );

SWI OS_GSTrans =
   (  NUMBER 0x27 "Equivalent to a call to OS_GSInit and repeated calls
            to OS_GSRead",
      ENTRY
      (  R0 -> .String: s,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1?,
         R2 = .Int: used,
         FLAGS!
      )
   );

SWI OS_BinaryToDecimal =
   (  NUMBER 0x28 "Converts a signed number to a string",
      ENTRY
      (  R0 = .Int: i,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R2 = .Int: used
   )  );

SWI OS_ChangeDynamicArea =
   (  NUMBER 0x2A "Alters the space sllocation of a dynamic area",
      ENTRY
      (  R0 = .Int: area_type,
         R1 = .Int: change
      ),
      EXIT
      (  R1! = .Int: change_out
   )  );

SWI OS_GenerateError =
   (  NUMBER 0x2B "Generates an error and invokes the error handler",
      ENTRY (R0 -> OS_Error: error)
   );

SWI
   ErrorV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &01 "OS_GenerateError vector"
   )  );

SWI OS_ReadEscapeState = (NUMBER 0x2C "Checks whether an escape condition
      has occurred", EXIT (FLAGS!));

SWI OS_EvaluateExpression =
   (  NUMBER 0x2D "Evaluates a string expression and returns an integer or
            string result",
      ENTRY
      (  R0 -> .String: expr,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R1 = .Bool: expr_is_str,
         R2 = .Int: int_value_or_str_used
   )  );

SWI OS_ReadPalette =
   (  NUMBER 0x2F "Reads the palette setting of a colour",
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type
      ),
      EXIT
      (  R2 = OS_Colour: on,
         R3 = OS_Colour: off
   )  );

SWI PaletteV = (NUMBER 0x34, ENTRY (R9 # &23 "Called whenever the
      palette is to be read or written"), ABSENT),

   PaletteV_ReadEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R4 # 1 "Reads the palette",
         R9 # &23
      ),
      EXIT
      (  R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4! = .Bool: incomplete
   )  ),

   PaletteV_SetEntry =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = OS_ColourNumber: entry,
         R1 = .Int: colour_type,
         R2 = OS_Colour: on,
         R3 = OS_Colour: off,
         R4 # 2 "Sets the palette",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOn =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 3 "Sets the flash state to on",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetOff =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 4 "Sets the flash state to off",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_Default =
   (  NUMBER 0x34,
      ENTRY
      (  R4 # 5 "Sets the palette to the default",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_ReadEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 = .Ref OS_Palette: on,
         R3 = .Ref OS_Palette: off,
         R4 # 7 "Reads palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_WriteEntries =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_ColourNumber: entry_list,
         R1 = .Bits: colour_type_and_entry_count,
         R2 -> OS_Palette: palette,
         R4 # 8 "Writes palette entries",
         R9 # &23
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  ),

   PaletteV_SetGammaCorrections =
   (  NUMBER 0x34,
      ENTRY
      (  R0 -> OS_CorrectionTable: red_table,
         R1 -> OS_CorrectionTable: green_table,
         R2 -> OS_CorrectionTable: blue_table,
         R4 # 9 "Sets the gamma correction tables"
      ),
      EXIT
      (  R4! = .Bool: incomplete
   )  );

SWI OS_ServiceCall = (NUMBER 0x30 "Issues a service call", ABSENT);

TYPE OS_VDUVarList = .Struct (.Int: var ...);

SWI OS_ReadVduVariables =
   (  NUMBER 0x31 "Reads a series of VDU variables",
      ENTRY
      (  R0 -> OS_VDUVarList: var_list,
         R1 = .Ref .Int: value_list
   )  );

SWI OS_ReadPoint =
   (  NUMBER 0x32 "Reads the colour of a point",
      ENTRY
      (  R0 = .Int: x,
         R1 = .Int: y
      ),
      EXIT
      (  R2 = OS_GCOL: gcol,
         R3 = OS_Tint: tint,
         R4! = .Bool: off_screen
   )  );

SWI OS_UpCall = (NUMBER 0x33 "Calls up from RISC OS to an application to
      warn of particular situations", ABSENT);

SWI UpCallV = (NUMBER 0x34,  ENTRY (R9 # &1D "OS_UpCall vector"),
      ABSENT); //reason codes as OS_UpCall

SWI OS_CallAVector = (NUMBER 0x34 "Calls a vector directly", ABSENT);

SWI OS_ReadModeVariable =
   (  NUMBER 0x35 "Reads information about a screen mode",
      ENTRY
      (  R0 = OS_Mode: mode,
         R1 = .Int: var
      ),
      EXIT
      (  R2 = .Int: var_val,
         FLAGS!
   )  );

SWI OS_RemoveCursors = (NUMBER 0x36 "Removes the cursors from the screen");

SWI OS_RestoreCursors = (NUMBER 0x37 "Restores the cursors to the screen");

SWI OS_SWINumberToString =
   (  NUMBER 0x38 "Converts a SWI number to a string containing its name",
      ENTRY
      (  R0 = .Int: swi,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R2 = .Int: used
   )  );

SWI OS_SWINumberFromString =
   (  NUMBER 0x39 "Converts a string to a SWI number if valid",
      ENTRY (R1 -> .String: swi_name),
      EXIT  (R0! = .Int: swi)
   );

SWI OS_ValidateAddress =
   (  NUMBER 0x3A "Checks that a range of address are in logical RAM",
      ENTRY
      (  R0 = .Ref .Data: min,
         R1 = .Ref .Data: max
      ),
      EXIT (FLAGS!)
   );

SWI OS_CallAfter =
   (  NUMBER 0x3B "Calls a specified address after a delay",
      ENTRY
      (  R0 = .Int: delay,
         R1 -> .Asm: code,
         R2 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_CallEvery =
   (  NUMBER 0x3C "Calls a specified address every time a delay elapses",
      ENTRY
      (  R0 = .Int: delay,
         R1 -> .Asm: code,
         R2 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_RemoveTickerEvent =
   (  NUMBER 0x3D "Removes a given call address and handle value from the
            ticker event list",
      ENTRY
      (  R0 -> .Asm: code,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI
   TickerV =
   (  NUMBER 0x34,
      ENTRY
      (  R9 # &1C "Called every centisecond"
   )  );

TYPE OS_KeyHandler = .Struct (.Byte: k ...);

SWI OS_InstallKeyHandler =
   (  NUMBER 0x3E "Installs a key handler or reads the address of the
            current one",
      ENTRY (R0 -> OS_KeyHandler: key_handler),
      EXIT  (R0! -> OS_KeyHandler: old_key_handler)
   );

CONST
   KeyV_TypeArchimedes = .Int: 1,
   KeyV_TypePCAT       = .Int: 2;

SWI KeyV = (NUMBER 0x34, ENTRY (R9 # &13 "Used to communicate between the kernel
      and a keyboard device driver"), ABSENT),

   KeyV_Present = (NUMBER 0x34, ENTRY (R0 # 0 "The given keyboard is present",
         R1 = .Int: keyboard_type, R9 # &13)),

   KeyV_TransitionUp = (NUMBER 0x34,  ENTRY (R0 # 1 "Key released",
         R1 = .Int: key, R9 # &13)),

   KeyV_TransitionDown = (NUMBER 0x34,  ENTRY (R0 # 2 "Key pressed",
         R1 = .Int: key, R9 # &13)),

   KeyV_LEDState = (NUMBER 0x34,  ENTRY (R0 # 3 "Notifies driver of LED state",
         R1 = .Bits: flags, R9 # &13)),

   KeyV_EnableDrivers = (NUMBER 0x34,  ENTRY (R0 # 4 "Enables keyboard device
         drivers", R9 # &13));

CONST
   OS_CurrentMode            = OS_Mode: -1,
   OS_NonexistentMode        = .Int: -1,
   OS_NotEnoughMemoryForMode = .Int: -2,
   OS_NoAlternativeMode      = OS_Mode: -2;

SWI OS_CheckModeValid =
   (  NUMBER 0x3F "Checks if it is possible to change into a specified mode",
      ENTRY
      (  R0 = OS_Mode: mode
      ),
      EXIT
      (  R0 = .Int: mode_status,
         R1 = OS_Mode: alternative_mode,
         FLAGS!
   )  );

CONST
   OS_HandlerMemoryLimit          = .Int:  0,
   OS_HandlerUndefinedInstruction = .Int:  1,
   OS_HandlerPrefetchAbort        = .Int:  2,
   OS_HandlerDataAbort            = .Int:  3,
   OS_HandlerAddressException     = .Int:  4,
   OS_HandlerOtherExceptions      = .Int:  5,
   OS_HandlerError                = .Int:  6,
   OS_HandlerCallBack             = .Int:  7,
   OS_HandlerBreakPt              = .Int:  8,
   OS_HandlerEscape               = .Int:  9,
   OS_HandlerEvent                = .Int: 10,
   OS_HandlerExit                 = .Int: 11,
   OS_HandlerUnusedSWI            = .Int: 12,
   OS_HandlerExceptionRegisters   = .Int: 13,
   OS_HandlerApplicationSpace     = .Int: 14,
   OS_HandlerCAO                  = .Int: 15,
   OS_HandlerUpCall               = .Int: 16;

SWI OS_ChangeEnvironment =
   (  NUMBER 0x40 "Installs a handler",
      ENTRY
      (  R0 = .Int: handler_type,
         R1 -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer
      ),
      EXIT
      (  R1! -> .Asm: old_handler,
         R2 = .Ref .Data: old_handle, //should be int, like other handles
         R3 = .Ref .Data: old_buffer
   )  );

SWI
   ChangeEnvironmentV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Int: handler_type,
         R1 -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer,
         R9 # &1E "OS_ChangeEnvironment vector"
      ),
      EXIT
      (  R1 -> .Asm: old_handler,
         R2 = .Ref .Data: old_handle, //should be int, like other handles
         R3 = .Ref .Data: old_buffer
   )  );

SWI
   OS_ClaimScreenMemory = (NUMBER 0x41 "Uses spare screen memory", ABSENT),
   OSClaimScreenMemory_Alloc =
   (  NUMBER 0x41,
      ENTRY
      (  R0 # 1 "Claims spare screen memory",
         R1 = .Int: size
      ),
      EXIT
      (  R1 = .Int: size_out,
         R2 = .Ref Void: blk,
         FLAGS!
   )  ),
   OSClaimScreenMemory_Free =
   (  NUMBER 0x41,
      ENTRY (R0 # 0 "Releases spare screen memory")
   );

SWI OS_ReadMonotonicTime =
   (  NUMBER 0x42 "Returns the number of centiseconds since the last hard
            reset",
      EXIT (R0! = OS_T: t)
   );

SWI OS_SubstituteArgs =
   (  NUMBER 0x43 "Substitutes command line arguments",
      ENTRY
      (  R0 -> .String: args,
         R1 = .Ref .String: buffer,
         R2 = .Int: size,
         R3 -> .String: source,
         R4 = .Int: source_size
      ),
      EXIT
      (  R2 = .Int: used
   )  );

SWI OS_PrettyPrint =
   (  NUMBER 0x44 "Writes a string with some formatting to all of the
            active output streams",
      ENTRY
      (  R0 -> .String: string,
         R1 -> .Data: dictionary,
         R2 -> .String: special
   )  );

SWI OS_Plot =
   (  NUMBER 0x45 "Direct VDU call to general plot command",
      ENTRY
      (  R0 = .Int: plot_code,
         R1 = .Int: x,
         R2 = .Int: y
   )  );

SWI
   UKPLOTV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Int: plot_code,
         R9 # &19 "Called when an unknown OS_Plot command is issued"
   )  );

SWI OS_WriteN =
   (  NUMBER 0x46 "Writes a counted string to all of the active output
         streams",
      ENTRY
      (  R0 -> .String: s,
         R1 = .Int: size
   )  );

SWI OS_AddToVector =
   (  NUMBER 0x47 "Adds a routine to the list of those that claim a
            vector",
      ENTRY
      (  R0 = .Int: vector,
         R1 -> .Asm: routine,
         R2 = .Ref .Data: handle //should be int, like other handles
      )
   );

SWI OS_WriteEnv =
   (  NUMBER 0x48 "Sets the program environment command string and start
            time",
      ENTRY
      (  R0 -> .String: command,
         R1 -> OS_DateAndTime: start
   )  );

//   To use OS_ReadArgs, declare a structure for the output to match the
//argument string. If the argument string is
//
//      "a1/k1,...,aN/kN"
//
//declare an object of type
//
//      .Struct (T1: a1, ..., TN: aN, [BIG] .Byte: buffer)
//
//where Ti is derived from ki as follows:
//
//      /s    .Bool
//      /e    .Ref OS_GI
//      /g    .Ref OS_GS
//      other .Ref .String
//
//The value of BIG should be chosen so that all the arguments fit in the
//buffer. A pointer to the whole structure is passed in R2, and its size
//in R3.

TYPE OS_GI = .Struct (.Byte: type, [4] .Byte: i);

TYPE OS_GS = .Struct (.Short: size, .Char: s ...);

SWI OS_ReadArgs =
   (  NUMBER 0x49 "Given a keyword definition, scans a command string",
      ENTRY
      (  R0 -> .String: keywords,
         R1 -> .String: input,
         R2 = .Ref .String: buffer,
         R3 = .Int: size
      ),
      EXIT (R3 = .Int: spare)
   );

SWI OS_ReadRAMFsLimits =
   (  NUMBER 0x4A "Gets the current limits of the RM filing system",
      EXIT
      (  R0 -> .Data: start,
         R1 -> .Char: end
   )  );

SWI OS_ClaimDeviceVector =
   (  NUMBER 0x4B "Claims a device vector",
      ENTRY
      (  R0 = .Int: device,
         R1 -> .Asm: driver,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Int: status,
         R4 = .Bits: mask
      )
   );

SWI OS_ReleaseDeviceVector =
   (  NUMBER 0x4C "Releases a device vector",
      ENTRY
      (  R0 = .Int: device,
         R1 -> .Asm: driver,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Int: status,
         R4 = .Bits: mask
      )
   );

SWI OS_DelinkApplication =
   (  NUMBER 0x4D "Removes any vectors that an application is using",
      ENTRY
      (  R0 = .Ref .Data: vector_details,
         R1 = .Int: size
      ),
      EXIT
      (  R1 = .Int: used
   )  );

SWI OS_RelinkApplication =
   (  NUMBER 0x4E "Restores from a buffer any vectors that an application
            is using",
      ENTRY (R0 -> .Data: vector_details)
   );

//Types of sort (pass in R2)
CONST
   OS_SortCardinal        = .Ref .Asm: 0,
   OS_SortInteger         = .Ref .Asm: 1,
   OS_SortCardinalPointer = .Ref .Asm: 2,
   OS_SortIntegerPointer  = .Ref .Asm: 3,
   OS_SortCIString        = .Ref .Asm: 4,
   OS_SortString          = .Ref .Asm: 5;

//Flags for OS_HeapSort (set in R1!)
CONST
   OS_SortGivenWorkspace = .Bits: 0b100000000000000000000000000000,
   OS_SortBuildArray     = .Bits: 0b1000000000000000000000000000000,
   OS_SortObjects        = .Bits: 0b10000000000000000000000000000000;

SWI OS_HeapSort =
   (  NUMBER 0x4F "Heap-sorts a list of objects",
      ENTRY
      (  R0 = .Int: count,
         R1 = .Ref .Int: array,
         R2 -> .Asm: compare_fn,
         R3 = .Ref .Data: handle, //should be int, like other handles
         R4 = .Ref .Data: objects,
         R5 = .Int: object_size,
         R6 = .Ref Void: workspace
   )  );

SWI OS_ExitAndDie =
   (  NUMBER 0x50 "Kills a module and passes control to the most recent
            exit handler",
      ENTRY
      (  R0 -> OS_Error: error,
         R1 # 'ABEX',
         R2 = .Int: rc,
         R3 -> .String: module_name
   )  );

SWI OS_ReadMemMapInfo =
   (  NUMBER 0x51 "Reads the page size and count",
      EXIT
      (  R0 = .Int: page_size,
         R1 = .Int: page_count
   )  );

CONST
   OS_AreaAccessReadWrite = .Bits: 0,
   OS_AreaAccessReadOnly  = .Bits: 1,
   OS_AreaAccessNone      = .Bits: 3,
   OS_AreaAccessShift     = .Int: 0,
   OS_AreaNotBufferable   = .Bits: %10000,
   OS_AreaNotCacheable    = .Bits: %100000,
   OS_AreaDoublyMapped    = .Bits: %1000000,
   OS_AreaNoUserDrag      = .Bits: %10000000,
   OS_AreaNeedsGivenPages = .Bits: %100000000;

TYPE
   OS_MemMapRequest =
      .Struct
      (  .Int: page_no,
         .Ref .Data: map,
         .Bits: access
      ),
   OS_MemMapRequestList =
      .Struct
      (  OS_MemMapRequest: requests ...
      );

TYPE
   OS_PageBlock =
      .Struct
      (  .Int: page_no,
         .Ref .Data: log_addr,
         .Ref .Data: phys_addr
      );

SWI OS_ReadMemMapEntries =
   (  NUMBER 0x52 "Reads by page number the logical to physical memory
            mapping used by MEMC",
      ENTRY (R0 = .Ref OS_MemMapRequestList: request_list)
   );

SWI OS_SetMemMapEntries =
   (  NUMBER 0x53 "Writes the logical to physical memory mapping used by
            MEMC",
      ENTRY (R0 -> OS_MemMapRequestList: request_list)
   );

SWI OS_AddCallBack =
   (  NUMBER 0x54 "Adds a transient callback to the list",
      ENTRY
      (  R0 -> .Asm: call_back,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_ReadDefaultHandler =
   (  NUMBER 0x55 "Gets the address of the default handler",
      ENTRY
      (  R0 = .Int: handler_type
      ),
      EXIT
      (  R1 -> .Asm: handler,
         R2 = .Ref .Data: handle, //should be int, like other handles
         R3 = .Ref .Data: buffer
   )  );

SWI OS_SetECFOrigin =
   (  NUMBER 0x56 "Sets the origin of the ECF patterns",
      ENTRY
      (  R0 = .Int: x,
         R1 = .Int: y
   )  );

SWI OS_Confirm =
   (  NUMBER 0x59 "Gets a yes or no answer",
      EXIT
      (  R0 = .Char: key,
         FLAGS!
   )  );

TYPE OS_ChangedBoxState = .Int;
CONST OS_DisableChangedBox = OS_ChangedBoxState: 0,
   OS_EnableChangedBox = OS_ChangedBoxState: 1,
   OS_ResetChangedBox = OS_ChangedBoxState: 2,
   OS_ReadChangedBox = OS_ChangedBoxState: -1;

SWI OS_ChangedBox =
   (  NUMBER 0x5A "Determines which area of the screen has changed",
      ENTRY
      (  R0 = OS_ChangedBoxState: state
      ),
      EXIT
      (  R0! = .Bool: enabled,
         R1 -> OS_ChangeBox: change_box
   )  );

SWI OS_CRC =
   (  NUMBER 0x5B "Calculates the cyclic redundancy check for a block of
            data",
      ENTRY
      (  R0 = .Int: crc_in,
         R1 -> .Data: block,
         R2 -> .Char: end,
         R3 = .Int: stride
      ),
      EXIT
      (  R0! = .Int: crc
   )  );

CONST
   OS_DynamicAreaApplicationSpace = .Int: -1, //RO3.5
   OS_DynamicAreaSystemHeap       = .Int: 0,
   OS_DynamicAreaRMA              = .Int: 1,
   OS_DynamicAreaScreenMemory     = .Int: 2,
   OS_DynamicAreaSystemSprites    = .Int: 3,
   OS_DynamicAreaFontCache        = .Int: 4,
   OS_DynamicAreaRAMDisc          = .Int: 5,
   OS_DynamicAreaFreePool         = .Int: 6; //RO3.5

SWI OS_ReadDynamicArea =
   (  NUMBER 0x5C "Reads the space allocation of a dynamic area",
      ENTRY
      (  R0 = .Int: area
      ),
      EXIT
      (  R0! = .Ref .Data: area_start,
         R1 = .Int: size,
         R2 = .Int: size_limit
   )  );

SWI OS_PrintChar =
   (  NUMBER 0x5D "Sends a character to the printer stream",
      ENTRY
      (  R0 = .Char: c
   )  );

SWI OS_ChangeRedirection =
   (  NUMBER 0x5E "Reads or writes OS_CLI input/output redirection
            handles",
      ENTRY
      (  R0 = OS_F: input,
         R1 = OS_F: output
      ),
      EXIT
      (  R0 = OS_F: old_input,
         R1 = OS_F: old_output
   )  );

SWI OS_RemoveCallBack =
   (  NUMBER 0x5F "Removes a transient callback from the list",
      ENTRY
      (  R0 -> .Asm: call_back,
         R1 = .Ref .Data: handle //should be int, like other handles
   )  );

SWI OS_FindMemMapEntries =
   (  NUMBER 0x60 "Reads by logical address the logical to physical memory
            mapping used by MEMC",
      ENTRY (R0 = .Ref OS_MemMapRequestList: request_list)
   );

CONST
   OS_ColourSetBG        = .Bits: 0b10000,
   OS_ColourGivenPattern = .Bits: 0b100000,
   OS_ColourSetText      = .Bits: 0b1000000, //RO3.5
   OS_ColourRead         = .Bits: 0b10000000; //RO3.5

SWI OS_SetColour =
   (  NUMBER 0x61 "Sets the current colour or colour pattern",
      ENTRY
      (  R0 = .Bits: flags,
         R1 = OS_ColourNumber: colour_number
   )  ),
   OS_ReadColour = //RO3.5
   (  NUMBER 0x61 "Reads the current colour or colour pattern",
      ENTRY
      (  R0 # %10000000,
         R0 | .Bits: flags,
         R1 = .Ref OS_ECF: pattern
      ),
      EXIT
      (  R0 = .Bits: flags_out,
         R1! = OS_ColourNumber: colour_number
   )  );

SWI
   OS_Pointer = //RO3.5
      (NUMBER 0x64 "Gets or sets the currently selected pointer device type",
      ABSENT),
   OSPointer_Get = (NUMBER 0x64, ENTRY (R0 # 0 "Gets the currently selected
         pointer device type"), EXIT (R0! = .Int: pointer_type)),
   OSPointer_Set = (NUMBER 0x64, ENTRY (R0 # 1 "Sets the currently selected
         pointer device type", R1 = .Int: pointer_type), EXIT (R0?));

CONST
   PointerV_TypeQuadrature   = .Int: 0,
   PointerV_TypeMicrosoft    = .Int: 1,
   PointerV_TypeMouseSystems = .Int: 2;

TYPE
   PointerV_Record = .Struct (.Ref PointerV_Record: next, .Bits: flags,
         .Int: pointer_type, [30] .Char: name);

SWI PointerV = (NUMBER 0x34, ENTRY (R9 # &26 "Used to communicate between the
      kernel and a pointer device driver"), ABSENT),

   PointerV_Status =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 0 "Requests status of pointer device",
         R1 = .Int: pointer_type,
         R9 # &26
      ),
      EXIT
      (  R2 = .Int: xmove,
         R3 = .Int: ymove
   )  ),

   PointerV_Enumerate =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 1 "Enumerates pointer device types",
         R1 -> PointerV_Record: record,
         R9 # &26
      ),
      EXIT
      (  R1! -> PointerV_Record: record_out
   )  ),

   PointerV_Selected =
   (  NUMBER 0x34,
      ENTRY
      (  R0 # 2 "Pointer device type selected",
         R1 = .Int: pointer_type,
         R9 # &26
   )  );

SWI
   OS_ScreenMode = //RO3.5
         (NUMBER 0x65 "Performs miscellaneous operations for screen mode
         handling", ABSENT),
   OSScreenMode_Select = (NUMBER 0x65, ENTRY (R0 # 0 "Selects a screen mode",
         R1 = OS_Mode: mode)),
   OSScreenMode_Current = (NUMBER 0x65, ENTRY (R0 # 1 "Returns the mode
         specifier for the current mode"), EXIT (R1! = OS_Mode: mode)),
   OSScreenMode_Enumerate = (NUMBER 0x65, ENTRY (R0 # 2 "Enumerates the
         available screen modes", R2 = .Int: context,
         R6 = .Ref OS_ModeBlock: block, R7 = .Int: block_size),
         EXIT (R1! = .Bool: complete, R2 = .Int: context_out,
         R6 -> .Data: end, R7 = .Int: free));

SWI OS_DynamicArea = //RO3.5
      (NUMBER 0x66 "Performs operations on dynamic areas", ABSENT);

CONST
   OSDynamicArea_AllocateArea = .Int: -1,
   OSDynamicArea_AllocateBase = .Ref .Data: -1;

SWI OSDynamicArea_Create =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 0 "Creates a new dynamic area",
         R1 = .Int: area,
         R2 = .Int: size,
         R3 -> .Data: base_address,
         R4 = .Bits: flags,
         R5 = .Int: size_limit,
         R6 -> .Asm: handler,
         R7 = .Ref Void: workspace,
         R8 -> .String: description
      ),
      EXIT
      (  R1! = .Int: area_out,
         R3 -> .Data: base_address_out,
         R5 = .Int: size_limit_out
      )
   ),
   OSDynamicArea_Delete =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 1 "Removes a previously created dynamic area",
         R1 = .Int: area
   )  ),
   OSDynamicArea_Read =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 2 "Returns information on a dynamic area",
         R1 = .Int: area
      ),
      EXIT
      (  R2 = .Int: size,
         R3 -> .Data: base_address,
         R4 = .Bits: flags,
         R5 = .Int: size_limit,
         R6 -> .Asm: handler,
         R7 = .Ref Void: workspace,
         R8 -> .String: description
   )  ),
   OSDynamicArea_Enumerate =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 3 "Enumerates dynamic areas",
         R1 = .Int: context
      ),
      EXIT
      (  R1! = .Int: context_out
   )  ),
   OSDynamicArea_Renumber =
   (  NUMBER 0x66,
      ENTRY
      (  R0 # 4 "Renumbers dynamic areas",
         R1 = .Int: old_area,
         R2 = .Int: new_area
   )  );

SWI OS_Memory = //RO3.5
   (  NUMBER 0x68 "Performs miscellaneous operations for memory management",
      ABSENT
   );

CONST
   OSMemory_GivenPageNo    = .Bits: %100000000,
   OSMemory_GivenLogAddr   = .Bits: %1000000000,
   OSMemory_GivenPhysAddr  = .Bits: %10000000000,
   OSMemory_ReturnPageNo   = .Bits: %100000000000,
   OSMemory_ReturnLogAddr  = .Bits: %1000000000000,
   OSMemory_ReturnPhysAddr = .Bits: %10000000000000,
   OSMemory_Cache          = .Bits: %1100000000000000,
   OSMemory_CacheShift     = .Int: 14,
   OSMemory_CacheDisable   = .Bits: 2,
   OSMemory_CacheEnable    = .Bits: 3;

CONST
   OSMemory_Type      = .Bits: %111100000000,
   OSMemory_TypeShift = .Int: 8,
   OSMemory_TypeDRAM  = .Bits: 1,
   OSMemory_TypeVRAM  = .Bits: 2,
   OSMemory_TypeROM   = .Bits: 3,
   OSMemory_TypeIO    = .Bits: 4;

CONST
   OSMemory_ControllerNo             = .Bits: &F,
   OSMemory_ControllerNoShift        = .Int: 0,
   OSMemory_ControllerType           = .Bits: &FFFFFFF0,
   OSMemory_ControllerTypeShift      = .Int: 8,
   OSMemory_ControllerTypeEASI       = .Bits: 0,
   OSMemory_ControllerTypeEASISpace  = .Bits: 1,
   OSMemory_ControllerTypeVIDC1      = .Bits: 2,
   OSMemory_ControllerTypeVIDC20     = .Bits: 3;

SWI
   OSMemory_PageOp =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 0 "General page block operations",
         R0 | .Bits: flags,
         R1 -> OS_PageBlock: page_block,
         R2 = .Int: page_count
   )  ),
   OSMemory_ReadArrangementTableSize =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 6 "Reads the size of the physical memory arrangement table"
      ),
      EXIT
      (  R1! = .Int: table_size,
         R2 = .Int: page_size
   )  ),
   OSMemory_ReadArrangementTable =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 7 "Read the physical memory arrangement table",
         R1 = .Ref .Data: arrangement_table
   )  ),
   OSMemory_ReadSize =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 8 "Reads the amount of a specified type of memory available on the
               computer",
         R0 | .Bits: type
      ),
      EXIT
      (   R1! = .Int: page_count,
          R2 = .Int: page_size
   )  ),
   OSMemory_ReadController =
   (  NUMBER 0x68,
      ENTRY
      (  R0 # 9 "Reads controller presence and base address",
         R1 = .Bits: controller
      ),
      EXIT
      (  R1 -> .Asm: controller_addr
   )  );

SWI
   OS_ClaimProcessorVector = //RO3.5
         (NUMBER 0x69 "Provides a means for a module to attach itself to one of
         the processor's vectors", ABSENT),
   OSClaimProcessorVector_Alloc =
         (NUMBER 0x69, ENTRY (R0 # %100000000 "Claims a processor vector",
         R0 | .Bits: vector, R1 -> .Asm: routine),
         EXIT (R1! -> .Asm: old_routine)),
   OSClaimProcessorVector_Free =
         (NUMBER 0x69, ENTRY (R0 # 0 "Releases a processor vector",
         R0 | .Bits: vector, R2 -> .Asm: old_routine),
         EXIT (R1?));

SWI OS_Reset = (NUMBER 0x6A "Performs a hard reset"); //RO3.5

SWI OS_MMUControl = //RO3.5
      (NUMBER 0x6B "Modifies the ARM MMU (prefer Cache_Control)",
      ENTRY (R0 # 0, R1 = .Bits: eor_mask, R2 = .Bits: and_mask),
      EXIT (R1! = .Bits: old_value, R2?));

SWI OS_ConvertStandardDateAndTime =
   (  NUMBER 0xC0 "Converts a 5-byte time into a string (prefer
            Territory_ConvertStandardDateAndTime)",
      ENTRY
      (  R0 -> OS_DateAndTime: date_and_time,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertDateAndTime =
   (  NUMBER 0xC1 "Converts a 5-byte time into a string using a supplied
            format string (prefer Territory_ConvertDateAndTime)",
      ENTRY
      (  R0 -> OS_DateAndTime: date_and_time,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_Hex1Limit = .Int: 1,
   OS_Hex2Limit = .Int: 2,
   OS_Hex4Limit = .Int: 4,
   OS_Hex6Limit = .Int: 6,
   OS_Hex8Limit = .Int: 8;

SWI OS_ConvertHex1 =
   (  NUMBER 0xD0 "Converts a number into a 1-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex2 =
   (  NUMBER 0xD1 "Converts a number into a 2-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex4 =
   (  NUMBER 0xD2 "Converts a number into a 4-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex6 =
   (  NUMBER 0xD3 "Converts a number into a 6-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertHex8 =
   (  NUMBER 0xD4 "Converts a number into an 8-digit hexadecimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_Cardinal1Limit = .Int: 3,
   OS_Cardinal2Limit = .Int: 5,
   OS_Cardinal3Limit = .Int: 8,
   OS_Cardinal4Limit = .Int: 10;

SWI OS_ConvertCardinal1 =
   (  NUMBER 0xD5 "Converts a 1-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal2 =
   (  NUMBER 0xD6 "Converts a 2-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal3 =
   (  NUMBER 0xD7 "Converts a 3-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertCardinal4 =
   (  NUMBER 0xD8 "Converts a 4-byte number into an unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_Integer1Limit = .Int: 4,
   OS_Integer2Limit = .Int: 6,
   OS_Integer3Limit = .Int: 8,
   OS_Integer4Limit = .Int: 11;

SWI OS_ConvertInteger1 =
   (  NUMBER 0xD9 "Converts a 1-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger2 =
   (  NUMBER 0xDA "Converts a 2-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger3 =
   (  NUMBER 0xDB "Converts a 3-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertInteger4 =
   (  NUMBER 0xDC "Converts a 4-byte number into a signed decimal string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_Binary1Limit = .Int: 8,
   OS_Binary2Limit = .Int: 16,
   OS_Binary3Limit = .Int: 24,
   OS_Binary4Limit = .Int: 32;

SWI OS_ConvertBinary1 =
   (  NUMBER 0xDD "Converts a 1-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary2 =
   (  NUMBER 0xDE "Converts a 2-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary3 =
   (  NUMBER 0xDF "Converts a 3-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertBinary4 =
   (  NUMBER 0xE0 "Converts a 4-byte number into an unsigned binary
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_SpacedCardinal1Limit = .Int: 3,
   OS_SpacedCardinal2Limit = .Int: 6,
   OS_SpacedCardinal3Limit = .Int: 10,
   OS_SpacedCardinal4Limit = .Int: 13;

SWI OS_ConvertSpacedCardinal1 =
   (  NUMBER 0xE1 "Converts a 1-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal2 =
   (  NUMBER 0xE2 "Converts a 2-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal3 =
   (  NUMBER 0xE3 "Converts a 3-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedCardinal4 =
   (  NUMBER 0xE4 "Converts a 4-byte number into a spaced unsigned decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST
   OS_SpacedInteger1Limit = .Int: 4,
   OS_SpacedInteger2Limit = .Int: 7,
   OS_SpacedInteger3Limit = .Int: 10,
   OS_SpacedInteger4Limit = .Int: 14;

SWI OS_ConvertSpacedInteger1 =
   (  NUMBER 0xE5 "Converts a 1-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger2 =
   (  NUMBER 0xE6 "Converts a 2-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger3 =
   (  NUMBER 0xE7 "Converts a 3-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_ConvertSpacedInteger4 =
   (  NUMBER 0xE8 "Converts a 4-byte number into a spaced signed decimal
            string",
      ENTRY
      (  R0 = .Int: value,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST OS_FixedNetStationLimit = .Int: 7;

SWI OS_ConvertFixedNetStation =
   (  NUMBER 0xE9 "Converts from an Econet station/network number pair to
            a string of fixed length",
      ENTRY
      (  R0 -> OS_StationNumber: station_number,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST OS_NetStationLimit = .Int: 7;

SWI OS_ConvertNetStation =
   (  NUMBER 0xEA "Converts from an Econet station/network number pair to
            a string",
      ENTRY
      (  R0 -> OS_StationNumber: station_number,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST OS_FixedFileSizeLimit = .Int: 11;

SWI OS_ConvertFixedFileSize =
   (  NUMBER 0xEB "Converts an integer into a filesize string of fixed
            length",
      ENTRY
      (  R0 = .Int: file_size,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

CONST OS_FileSizeLimit = .Int: 11;

SWI OS_ConvertFileSize =
   (  NUMBER 0xEC "Converts an integer into a filesize string",
      ENTRY
      (  R0 = .Int: file_size,
         R1 = .Ref .String: buffer,
         R2 = .Int: size
      ),
      EXIT
      (  R0?,
         R1 -> .Char: end,
         R2?
   )  );

SWI OS_WriteI = (NUMBER &100 "Writes an immediate byte (cannot be called via
      APCS)", ABSENT);

SWI
   OS_Null = (NUMBER 0x100 "VDU command for nul (no operation)"),
   OS_CharToPrinter = (NUMBER 0x101 "VDU command to send the nextcharacter
         to the printer only - must be followed by 'char'"),
   OS_PrinterOn = (NUMBER 0x102 "VDU command to enable the printer stream"),
   OS_PrinterOff = (NUMBER 0x103 "VDU command to disable the printer
         stream"),
   OS_SplitCursors = (NUMBER 0x104 "VDU command to split the text and
         graphics cursors"),
   OS_JoinCursors = (NUMBER 0x105 "VDU command to join the text and graphics
         cursors"),
   OS_VDUOn = (NUMBER 0x106 "VDU command to enable screen output"),
   OS_Bell = (NUMBER 0x107 "VDU command to ring the bell"),
   OS_Backspace = (NUMBER 0x108 "VDU command to perform a backspace"),
  OS_Tab = (NUMBER 0x109 "VDU command to perform a horizontal tab"),
   OS_LineFeed = (NUMBER 0x10A "VDU command to perform a linefeed"),
   OS_VerticalTab = (NUMBER 0x10B "VDU command to perform a vertical tab"),
   OS_ClS = (NUMBER 0x10C "VDU command to clear the text window"),
   OS_Return = (NUMBER 0x10D "VDU command to perform a return"),
   OS_PageModeOn = (NUMBER 0x10E "VDU command to turn paged mode on"),
   OS_PageModeOff = (NUMBER 0x10F "VDU command to turn paged mode off"),
   OS_ClG = (NUMBER 0x110 "VDU command to clear the graphics window"),
   OS_SetTextColour = (NUMBER 0x111 "VDU command to set the text colour -
         must be followed by 'colour'"),
   OS_SetGCOL = (NUMBER 0x112 "VDU command to set the graphics colour and
         action - must be followed by 'action,' 'colour'"),
   OS_SetPalette = (NUMBER 0x113 "VDU command to set the palette - must be
         followed by 'colour,' 'mode,' 'red,' 'green,' 'blue'"),
   OS_ResetColours = (NUMBER 0x114 "VDU command to restore default colours"),
   OS_VDUOff = (NUMBER 0x115 "VDU command to disable screen output"),
   OS_SetMode = (NUMBER 0x116 "VDU command to change display mode - must be
         followed by 'mode'"),
   OS_Misc = (NUMBER 0x117 "Miscellaneous VDU commands - must be followed by
         'command' and 8 more arguments)"),
   OS_SetGraphicsWindow = (NUMBER 0x118 "VDU command to define the graphics
         window - must be followed by 'x0,' 'y0,' 'x1,' 'y1' (2 bytes
         each)"),
   OS_PlotVDU = (NUMBER 0x119 "General VDU plot commands - must be followed
         by 'plot_type' and 'x,' 'y' (2 bytes each) (prefer OS_Plot)"),
   OS_ResetWindows = (NUMBER 0x11A "VDU command to restore default windows"),
   OS_Escape = (NUMBER 0x11B "VDU command for escape (no operation)"),
   OS_SetTextWindow = (NUMBER 0x11C "VDU command to define the text window -
         must be followed by 'x0,' 'y0,' 'x1,' 'y1'"),
   OS_SetGraphicsOrigin = (NUMBER 0x11D "VDU command to set the graphics
         origin - must be followed by 'x,' 'y' (2 bytes each)"),
   OS_HomeTextCursor = (NUMBER 0x11E "VDU command to home the text cursor"),
   OS_SetTextCursor = (NUMBER 0x11F "VDU command to position the text cursor
         - must be followed by 'x,' 'y'"),
   OS_Space = (NUMBER 0x120 "VDU command to perform a space"),
   OS_Delete = (NUMBER 0x17F "VDU command to perform a delete");

SWI
   UserV =
   (  NUMBER 0x34,
      ENTRY (R9 # 0 "User vector"),
      ABSENT
   );

SWI
   IrqV =
   (  NUMBER 0x34,
      ENTRY (R9 # &2 "Called when an unknown IRQ is detected"),
      ABSENT
   );

SWI
   UKVDU23V =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Int: n,
         R1 -> .Byte: queue,
         R9 # &17 "Called when an unrecognised VDU 23 command is issued"
   )  );

SWI
   VDUXV =
   (  NUMBER 0x34,
      ENTRY
      (  R0 = .Byte: b,
         R9 # &1B "Called when VDU output has been redirected"
   )  );

TYPE
   OS_ModeBlock = .Struct (.Int: size, .Bits: flags, .Int: xres, .Int: yres,
         .Int: log2_bpp, .Int: frame_rate, .Char: name ...),
   OS_ModeSelector = .Struct (.Bits: flags, .Int: xres, .Int: yres,
         .Int: log2_bpp, .Int: frame_rate,
         .Struct (.Int: var, .Int: val): modevars ...);

SWI
   Service_ReleaseFIQ                 = (NUMBER 0x30, ENTRY (R1 # 0x0B
         "FIQ released")),
   Service_ClaimFIQ                   = (NUMBER 0x30, ENTRY (R1 # 0x0C
         "FIQ claimed")),
   Service_Reset                      = (NUMBER 0x30, ENTRY (R1 # 0x27
         "Post-reset. Also, request to task modules and
         filing system-specific desktop filers to set task_handle variable
         to 0")),
   Service_KeyHandler                 = (NUMBER 0x30, ENTRY (R1 # 0x44
         "Keyboard handler changed", R2 = .Int: keyboard_id)),
   Service_ModeChange                 = (NUMBER 0x30, ENTRY (R1 # 0x46
         "Mode changed")),
   Service_ClaimFIQInBackground       = (NUMBER 0x30, ENTRY (R1 # 0x47
         "FIQ claimed in background")),
   Service_MemoryMoved                = (NUMBER 0x30, ENTRY (R1 # 0x4E
         "Memory moved")),
   Service_PreModeChange              = (NUMBER 0x30, ENTRY (R1 # 0x4D
         "Mode change", R2 = OS_Mode: mode)),
   Service_ModeExtension              = (NUMBER 0x30, ENTRY (R1 # 0x50
         "Allow soft modes",
         R2 = OS_Mode: mode, R3 = .Int: monitor_type,
         R4 = .Int: bandwidth, //RO3.5
         R5 = .Int: vram_size), //RO3.5
         EXIT (R1! = .Bool: unclaimed, R3 -> .Int: vidc_list,
         R4 -> .Int: workspace_list)),
   Service_ModeTranslation            = (NUMBER 0x30, ENTRY (R1 # 0x51
         "Translate modes for unknown monitor types", R2 = OS_Mode: mode,
         R3 = .Int: monitor_type)),
   Service_ValidateAddress            = (NUMBER 0x30, ENTRY (R1 # 0x6D
         "OS_ValidateAddress has been called with an unknown area")),
   Service_MonitorLeadTranslation = (NUMBER 0x30, ENTRY (R1 # 0x76
         "Translate monitor lead ID", R2 = .Int: lead_id)),
   Service_ModeChanging               = (NUMBER 0x30, ENTRY (R1 # 0x89
         "Mode change", R2 = OS_Mode: mode, R3 = .Int: monitor_type)),
   Service_EnumerateScreenModes       = (NUMBER 0x30, ENTRY (R1 # 0x8D
         "Enumerates the available screen modes", R2 = .Int: context,
         R3 = .Int: monitor_type, R4 = .Int: bandwidth, R5 = .Int: vram_size,
         R6 = .Ref OS_ModeBlock: block, R7 = .Int: block_size),
         Exit (R1! = .Bool: unclaimed, R2 = .Int: context_out, R6 -> .Data: end,
         R7 = .Int: free)),
   Service_PagesUnsafe = //RO3.5
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x8E "Pages specified are about to be swapped for different pages",
         R2 -> OS_PageBlock: page_block,
         R3 = .Int: request_count
      )
   ),
   Service_PagesSafe = //RO3.5
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x8F "Pages specified have been swapped for different pages",
         R2 = .Int: request_count,
         R3 -> OS_PageBlock: old_page_block,
         R4 -> OS_PageBlock: new_page_block
      )
   ),
   Service_DynamicAreaCreate = //RO3.5
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x90 "Dynamic area has just been successfully created",
         R2 = .Int: area
      )
   ),
   Service_DynamicAreaRemove = //RO3.5
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x91 "Dynamic area is about to be removed",
         R2 = .Int: area
      )
   ),
   Service_DynamicAreaRenumber = //RO3.5
   (  NUMBER 0x30,
      ENTRY
      (  R1 # 0x92 "Dynamic area is being renumbered",
         R2 = .Int: area
      )
   );

CONST //for Event_MouseTransition
   OS_TransitionMouseRight  = .Bits: 0b1,
   OS_TransitionMouseMiddle = .Bits: 0b10,
   OS_TransitionMouseLeft   = .Bits: 0b100;

CONST //for Event_KeyTransition
   OS_TransitionKeyEscape       = .Byte: &00,
   OS_TransitionKeyF1           = .Byte: &01,
   OS_TransitionKeyF2           = .Byte: &02,
   OS_TransitionKeyF3           = .Byte: &03,
   OS_TransitionKeyF4           = .Byte: &04,
   OS_TransitionKeyF5           = .Byte: &05,
   OS_TransitionKeyF6           = .Byte: &06,
   OS_TransitionKeyF7           = .Byte: &07,
   OS_TransitionKeyF8           = .Byte: &08,
   OS_TransitionKeyF9           = .Byte: &09,
   OS_TransitionKeyF10          = .Byte: &0A,
   OS_TransitionKeyF11          = .Byte: &0B,
   OS_TransitionKeyF12          = .Byte: &0C,
   OS_TransitionKeyPrint        = .Byte: &0D,
   OS_TransitionKeyScrollLock   = .Byte: &0E,
   OS_TransitionKeyBreak        = .Byte: &0F,
   OS_TransitionKeyGrave        = .Byte: &10,
   OS_TransitionKey1            = .Byte: &11,
   OS_TransitionKey2            = .Byte: &12,
   OS_TransitionKey3            = .Byte: &13,
   OS_TransitionKey4            = .Byte: &14,
   OS_TransitionKey5            = .Byte: &15,
   OS_TransitionKey6            = .Byte: &16,
   OS_TransitionKey7            = .Byte: &17,
   OS_TransitionKey8            = .Byte: &18,
   OS_TransitionKey9            = .Byte: &19,
   OS_TransitionKey0            = .Byte: &1A,
   OS_TransitionKeyHyphen       = .Byte: &1B,
   OS_TransitionKeyEquals       = .Byte: &1C,
   OS_TransitionKeyPound        = .Byte: &1D,
   OS_TransitionKeyBackspace    = .Byte: &1E,
   OS_TransitionKeyInsert       = .Byte: &1F,
   OS_TransitionKeyHome         = .Byte: &20,
   OS_TransitionKeyPageUp       = .Byte: &21,
   OS_TransitionKeyNumLock      = .Byte: &22,
   OS_TransitionKeyKeypadSlash  = .Byte: &23,
   OS_TransitionKeyKeypadStar   = .Byte: &24,
   OS_TransitionKeyKeypadHash   = .Byte: &25,
   OS_TransitionKeyTab          = .Byte: &26,
   OS_TransitionKeyQ            = .Byte: &27,
   OS_TransitionKeyW            = .Byte: &28,
   OS_TransitionKeyE            = .Byte: &29,
   OS_TransitionKeyR            = .Byte: &2A,
   OS_TransitionKeyT            = .Byte: &2B,
   OS_TransitionKeyY            = .Byte: &2C,
   OS_TransitionKeyU            = .Byte: &2D,
   OS_TransitionKeyI            = .Byte: &2E,
   OS_TransitionKeyO            = .Byte: &2F,
   OS_TransitionKeyP            = .Byte: &30,
   OS_TransitionKeySquareBra    = .Byte: &31,
   OS_TransitionKeySquareKet    = .Byte: &32,
   OS_TransitionKeyBackslash    = .Byte: &33,
   OS_TransitionKeyDelete       = .Byte: &34,
   OS_TransitionKeyCopy         = .Byte: &35,
   OS_TransitionKeyPageDown     = .Byte: &36,
   OS_TransitionKeyKeypad7      = .Byte: &37,
   OS_TransitionKeyKeypad8      = .Byte: &38,
   OS_TransitionKeyKeypad9      = .Byte: &39,
   OS_TransitionKeyKeypadMinus  = .Byte: &3A,
   OS_TransitionKeyLeftControl  = .Byte: &3B,
   OS_TransitionKeyA            = .Byte: &3C,
   OS_TransitionKeyS            = .Byte: &3D,
   OS_TransitionKeyD            = .Byte: &3E,
   OS_TransitionKeyF            = .Byte: &3F,
   OS_TransitionKeyG            = .Byte: &40,
   OS_TransitionKeyH            = .Byte: &41,
   OS_TransitionKeyJ            = .Byte: &42,
   OS_TransitionKeyK            = .Byte: &43,
   OS_TransitionKeyL            = .Byte: &44,
   OS_TransitionKeySemicolon    = .Byte: &45,
   OS_TransitionKeyAcute        = .Byte: &46,
   OS_TransitionKeyReturn       = .Byte: &47,
   OS_TransitionKeyKeypad4      = .Byte: &48,
   OS_TransitionKeyKeypad5      = .Byte: &49,
   OS_TransitionKeyKeypad6      = .Byte: &4A,
   OS_TransitionKeyKeypadPlus   = .Byte: &4B,
   OS_TransitionKeyLeftShift    = .Byte: &4C,
   //there is no key &4D
   OS_TransitionKeyZ            = .Byte: &4E,
   OS_TransitionKeyX            = .Byte: &4F,
   OS_TransitionKeyC            = .Byte: &50,
   OS_TransitionKeyV            = .Byte: &51,
   OS_TransitionKeyB            = .Byte: &52,
   OS_TransitionKeyN            = .Byte: &53,
   OS_TransitionKeyM            = .Byte: &54,
   OS_TransitionKeyComma        = .Byte: &55,
   OS_TransitionKeyPoint        = .Byte: &56,
   OS_TransitionKeySlash        = .Byte: &57,
   OS_TransitionKeyRightShift   = .Byte: &58,
   OS_TransitionKeyUp           = .Byte: &59,
   OS_TransitionKeyKeypad1      = .Byte: &5A,
   OS_TransitionKeyKeypad2      = .Byte: &5B,
   OS_TransitionKeyKeypad3      = .Byte: &5C,
   OS_TransitionKeyCapsLock     = .Byte: &5D,
   OS_TransitionKeyLeftAlt      = .Byte: &5E,
   OS_TransitionKeySpace        = .Byte: &5F,
   OS_TransitionKeyRightAlt     = .Byte: &60,
   OS_TransitionKeyRightControl = .Byte: &61,
   OS_TransitionKeyLeft         = .Byte: &62,
   OS_TransitionKeyDown         = .Byte: &63,
   OS_TransitionKeyRight        = .Byte: &64,
   OS_TransitionKeyKeypad0      = .Byte: &65,
   OS_TransitionKeyKeypadPoint  = .Byte: &66,
   OS_TransitionKeyEnter        = .Byte: &67;

CONST
   OS_TransitionUp   = .Int: 0,
   OS_TransitionDown = .Int: 1;

SWI
   Event_CharInput =
   (  NUMBER &22,
      ENTRY
      (  R0 # 2 "Character input",
         R1 = .Int: buffer,
         R2 = .Byte: b
      )
   ),

   Event_VSync =
   (  NUMBER &22,
      ENTRY
      (  R0 # 4 "Vertical sync"
      )
   ),

   Event_IntervalTimer =
   (  NUMBER &22,
      ENTRY
      (  R0 # 5 "Interval timer"
      )
   ),

   Event_Escape =
   (  NUMBER &22,
      ENTRY
      (  R0 # 6 "Escape"
      )
   ),

   Event_User =
   (  NUMBER &22,
      ENTRY
      (  R0 # 9 "User event"
      ),
      ABSENT
   ),

   Event_MouseTransition =
   (  NUMBER &22,
      ENTRY
      (  R0 # 10 "Mouse button up/down",
         R1 = .Int: x,
         R2 = .Int: y,
         R3 = .Bits: state,
         R4 = OS_T: t
      )
   ),

   Event_KeyTransition =
   (  NUMBER &22,
      ENTRY
      (  R0 # 11 "Key up/down",
         R1 = .Bool: down,
         R2 = .Int: key,
         R3 = .Int: keyboard_id
      )
   );

SWI UpCall_MoveMemoryRequest =
   (  NUMBER 0x33,
      ENTRY
      (  R0 # 257 "Informs your program that RISC OS would like to move
               memory",
         R1 = .Int: size_change
      ),
      EXIT
      (  R0! = .Bool: not_moved
   )  )
