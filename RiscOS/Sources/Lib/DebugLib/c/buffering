/************************************************************************/
/* File:    buffering.c                                                 */
/* Purpose: Buffered output control for DebugLib.                       */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  Mon 11th January 1999                                 */
/*                Created.                                              */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "include.h"
#include "buffering.h"
#include "globals.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

#define DebugBuffer_DA_Name	"DebugLib Buffer"

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

static _kernel_oserror		global_er;

BufferStatus		buff_status;



static void buffer_terminate(void);
/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* debug_output_buffer_on                                               */
/*                                                                      */
/* Function enables buffering of output in DebugLib.  This is stored in */
/* a dynamic area until such times as the user calls                    */
/* debug_output_buffer_off().                                           */
/*                                                                      */
/* Parameters: flags    - flags word - set to 0.                        */
/*             nbytes   - size of Dynamic Area to create.               */
/*                                                                      */
/* Returns:    _kernel_oserror for error, else NULL.                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *debug_output_buffer_on(int flags, int nbytes)
{
  _kernel_oserror	*er = NULL;
  _kernel_oserror	*er_ptr = NULL;
  _kernel_swi_regs	 regs;

  DEBUGLIB_UNUSED(flags);

  atexit(buffer_terminate);

  regs.r[0] = 0;
  regs.r[1] = -1;
  regs.r[2] = nbytes;
  regs.r[3] = -1;
  regs.r[4] = 1<<7;
  regs.r[5] = nbytes;
  regs.r[6] = 0;
  regs.r[7] = 0;
  regs.r[8] = (int) DebugBuffer_DA_Name;

  er = _kernel_swi(OS_DynamicArea, &regs, &regs);

  if (er != NULL)
  {
    global_er.errnum = er->errnum;
    strcpy(global_er.errmess, er->errmess);
    er_ptr = &global_er;
    return(er_ptr);
  }
  else
  {
    buff_status.da = regs.r[1];
    buff_status.enabled = TRUE;
    buff_status.size = nbytes;
    buff_status.base = (char *) regs.r[3];
    strcpy(buff_status.base, "\0");
    return(NULL);
  }
}


/************************************************************************/
/* debug_output_buffer_off                                              */
/*                                                                      */
/* Function turns off buffering of output.                              */
/*                                                                      */
/* Parameters: flags   - not used.                                      */
/*             device  - DebugLib stream to use to output the buffer,   */
/*                       and all data from this point on.               */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_output_buffer_off(int flags, debug_device device)
{
  /* Flags word not in use yet */
  DEBUGLIB_UNUSED(flags);

  /* Set enabled to FALSE so that debug_output_device & debug_output will do
   * something
   */
  buff_status.enabled = FALSE;

  /* If the system variable is unset then set ourselves up */
  if (sysvar_provided_device == UNSET_OUTPUT)
    debug_output_device(device);
  else
    debug_output_device(sysvar_provided_device);

  debug_output(buff_status.base);

  /* Now that everything has been output, terminate the buffer */
  buffer_terminate();
}



/************************************************************************/
/* buffer_terminate                                                     */
/*                                                                      */
/* Function will close the dynamic area down.                           */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void buffer_terminate(void)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er;

  if (buff_status.da != FALSE)
  {
    regs.r[0] = 1;
    regs.r[1] = buff_status.da;

    er = _kernel_swi(OS_DynamicArea, &regs, &regs);

    if (er != NULL)
      printf("Message: %s\n", er->errmess);
  }
  buff_status.da = FALSE;
  buff_status.enabled = FALSE;
  buff_status.base = NULL;
  buff_status.head = NULL;
}


/************************************************************************/
/* buffer_startup                                                       */
/*                                                                      */
/* Function prepares the buffering code.                                */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void buffer_startup(void)
{
  buff_status.da = FALSE;
  buff_status.enabled = FALSE;
  buff_status.size = FALSE;
  buff_status.base = NULL;
  buff_status.head = NULL;
}


/************************************************************************/
/* buffer_stream                                                        */
/*                                                                      */
/* Function buffers the text passed in into the setup dynamic area.     */
/*                                                                      */
/* Parameters: stream.                                                  */
/*                                                                      */
/* Returns:    TRUE or FALSE                                            */
/*                                                                      */
/************************************************************************/
int buffer_stream(const char *stream)
{
  if ((strlen(stream) + strlen(buff_status.base)) < buff_status.size)
  {
    strcat(buff_status.base, stream);
    return(TRUE);
  }
  else
  {
    return(FALSE);
  }
}
