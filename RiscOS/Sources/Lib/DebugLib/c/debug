/************************************************************************/
/* File:    debug.c                                                     */
/* Purpose: The file contains various debugging routines.  I have       */
/*          provided several methods of debug output; TML Podules,      */
/*          !Tracker, printf statements, serial parallel and sockets    */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Tue 18th February 1997  ver 0.01 - Created.                 */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include "include.h"
#include "debug.h"
#include "misc.h"
#include "globals.h"
#include "debugit.h"
#include "file.h"
#include "pdebug.h"
#include "printf.h"
#include "serial.h"
#include "socket.h"
#include "tml.h"
#include "tracker.h"
#include "buffering.h"

#include "VersionNum"


/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

debug_options debug_current_options;

int serial_handle = 0;

FILE *debug_file_pointer = NULL;          /* File pointer */

debug_session *remotedb_info;           /* RemoteDB handler */

SessionsAvailable sessions_available;

int tracker_window_handle = -1;

BOOL pdebug_error = FALSE;

debug_device sysvar_provided_device = UNSET_OUTPUT;    /* The variable to hold output device specified by
                                                          system variable */

/* -------------------------------------- LOCAL VARIABLES --------------------------------------- */

static const char debug_version_string[] = Module_FullVersion;

static debug_device sysvar_provided_tracedevice = UNSET_OUTPUT;  /* The variable to hold the trace output device
                                                          specified by system variable */

static char *level_specifier = NULL;            /* Contents of area-level specifying sys var */

static char debug_buffer[Debug_Buffer_Size];     /* Buffer for debug data */

static int global_indent = 0;

static const char *always_ignore = " PDebug_* Trace_* remote_debug_open debug_printf";

typedef struct debug_output_method
{
  /* Functions */
  BOOL (*initialise)(void);
  void (*output)(const char *);
  void (*quit)(void);
}debug_output_method;

static debug_output_method methods[11] =
{
  {NULL,               NULL,                 NULL},                 /* NULL_OUTPUT */
  {debug_tracker_init, debug_tracker_output, debug_tracker_quit},   /* TRACKER_OUTPUT */
  {NULL,               debug_printf_output,  NULL},                 /* PRINTF_OUTPUT */
  {NULL,               NULL,                 NULL},                 /* NOTUSED_OUTPUT */
  {debug_pdebug_init,  debug_pdebug_output,  debug_pdebug_quit},    /* PDEBUG_OUTPUT */
  {debug_socket_init,  debug_socket_output,  debug_socket_quit},    /* SOCKET_OUTPUT */
  {debug_debugit_init, debug_debugit_output, debug_debugit_quit},   /* DEBUGIT_OUTPUT */
  {debug_tml_init,     debug_tml_output,     debug_tml_quit},       /* TML_OUTPUT */
  {debug_file_init,    debug_file_output,    debug_file_quit},      /* FILE_OUTPUT */
  {debug_serial_init,  debug_serial_output,  debug_serial_quit},    /* SERIAL_OUTPUT */
  {NULL,               NULL,                 NULL}                  /* UNSET_OUTPUT */
};

/* ------------------------------------ FUNCTION PROTOTYPES ------------------------------------- */

void debug_trace_enter (const char *);
void debug_trace_exit (const char *);

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/************************************************************************/
/* debug_check_level                                                    */
/*                                                                      */
/* Checks the area-level pair passed in a dprintf with the system       */
/* variable specifying what areas and levels are wanted, and returns    */
/* 1 if the line should be output, and 0 if it shouldn't                */
/*                                                                      */
/* Parameters: area_level_in - The area-level pair                      */
/*             variable - The contents of the system variable           */
/*                                                                      */
/* Returns:    1 or 0.                                                  */
/*                                                                      */
/************************************************************************/
static int debug_check_level (const char *area_level_in, const char *variable)
{
  char *match;
  int matched = 0;
  int area_level_len, area_len, var_len, offset;
  char *area, *area_level = NULL;
  int level = 0, var_level = 0;

  /* If variable unset, it's a match */
  if (variable == NULL)
    return 1;

  /* If the variable is set and empty, no match */
  if (strlen (variable) == 0)
    return 0;

  /* If the area_level is NULL, it's a match */
  if (area_level_in == NULL)
    return 1;

  area_level_len = strlen (area_level_in);

  /* If the area_level is empty, it's a match */
  if (area_level_len == 0)
    return 1;

  area_level = malloc (strlen (area_level_in) + 1);
  strcpy (area_level, area_level_in);
  area = area_level;

  if ((area_level_len - 2) > 0)
  {
    /* It's possible to have "A_5" */
    if (isdigit (area_level[area_level_len - 1]) != 0)     /* area_level = "Area_4" */
    {
      /* area_level has an explicit level embedded */
      area_level[area_level_len - 2] = '\0';
      level = atoi (&area_level[area_level_len - 1]);
    }
  }

  if ((area_level_len - 1) > 0)
  {
    /* It's possible to have "A_" */
    if (area_level[area_level_len - 1] == '_')   /* area_level = "Area_" */
    {
      /* area_level has an '_', but no explicit level */
      area_level[area_level_len - 1] = '\0';
      level = 0;
    }
  }
  else
  {
    /* area_level has no explicit level embedded */
    level = 0;
  }

  var_len = strlen (variable);
  area_len = strlen (area);

  if ((match = strstr (variable, area)) != NULL)
  {
    internal_dprintf (("", "match = \"%s\"\n", match));
    if (match != variable)
    {
      if (*(match-1) != ' ' && *(match-1) != ',')
      {
        /* No match */
        return 0;
      }
    }

    offset = (int) match - (int) variable;

    internal_dprintf (("", "offset = %d,  var_len = %d,  area_len = %d\n", offset, var_len, area_len));

    if (area_len + offset > var_len)
    {
      /* No match, we've fallen off the end of the system variable */
      internal_dprintf (("", "Fallen off end\n"));
      return 0;
    }
    else if (area_len + offset == var_len)  /* match = "Area" */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (match[area_len] == ',')  /* match = "Area," */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (area_len + offset + 1 < var_len)
    {
       if ((match[area_len] == '_') && (!isdigit (match[area_len+1]))) /* match = "Area_" */
      {
        /* No level in variable, we want everything */
        var_level = 9;
        matched = 1;
      }
      else if (match[area_len] == '_' && isdigit (match[area_len+1]))  /* match = "Area_4" */
      {
        /* level supplied in variable */
        var_level = atoi (&match[area_len+1]);
        matched = 1;
      }
      else
        matched = 0;
    }
    else
      matched = 0;
  }
  else
    matched = 0;

  if (area_level)
    free (area_level);

  if (matched == 1)
  {
    if (var_level >= level)
      return 1;
    else
      return 0;
  }
  else
    return 0;
}

/************************************************************************/
/* debug_setup_filename                                                 */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the filename for   */
/* the file output method using either sysvar or param passed into      */
/* debug_initialise                                                     */
/*                                                                      */
/* Parameters: fname  - filename passed in debug_initialise             */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_filename (const char *fname)
{
  char *tmp_sysvar_name;

  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Filename_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Filename_%s", debug_current_options.taskname);

  if (debug_current_options.filename)
    free (debug_current_options.filename);
  debug_current_options.filename = misc_getenv_malloc (tmp_sysvar_name);
  if (debug_current_options.filename == NULL)
  {
    if (fname || strlen (fname))
    {
      debug_current_options.filename = debug_strdup (fname);
    }
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_unbuffered                                               */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the whether files  */
/* should be unbuffered for the file outpit method.                     */
/* debug_initialise                                                     */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_unbuffered (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$UnbufferedFiles_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$UnbufferedFiles_%s", debug_current_options.taskname);

  tmp_string = misc_getenv_malloc (tmp_sysvar_name);
  if (tmp_string != NULL)
  {
    free (tmp_string);
    debug_current_options.unbuffered_files = TRUE;
  }
  else
    debug_current_options.unbuffered_files = FALSE;

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_level                                                    */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the level          */
/* specifier, which is read from a system variable                      */
/*                                                                      */
/*                                                                      */
/* Parameters: sysvar - system variable specifier from debug_initialise */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_level (const char *sysvar)
{
  char *tmp_sysvar_name;

  /* Check for level sysvar specifier */
  if (sysvar && strlen (sysvar))
  {
    tmp_sysvar_name = debug_strdup (sysvar);
  }
  else
  {
    /* .. Setup a string with the name of the default system variable that will
       specify the debug area/level(s) */
    tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Level_") + 1);
    sprintf (tmp_sysvar_name, "DebugLib$Level_%s", debug_current_options.taskname);
  }

  if (level_specifier != NULL)
    free (level_specifier);
  level_specifier = misc_getenv_malloc (tmp_sysvar_name);

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_device                                                   */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the device used    */
/* for normal debug output. Read from a system variable                 */
/*                                                                      */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_device (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  /* Setup a string with the name of the system variable that will
     specify the output device */
  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$Device_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$Device_%s", debug_current_options.taskname);

  /* Read the system variable */
  tmp_string = misc_getenv_malloc (tmp_sysvar_name);

  if (tmp_string)
  {
    sysvar_provided_device = (debug_device) atoi (tmp_string);
    free (tmp_string);
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_setup_tracedevice                                              */
/*                                                                      */
/* Auxiliary function for debug_initialise.  Sets up the device used    */
/* for trace output. Read from a system variable.                       */
/*                                                                      */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    nothing.                                                 */
/*                                                                      */
/************************************************************************/
static void debug_setup_tracedevice (void)
{
  char *tmp_sysvar_name;
  char *tmp_string;

  /* Setup a string with the name of the system variable that will
     specify the trace output device */
  tmp_sysvar_name = malloc (strlen (debug_current_options.taskname) + strlen ("DebugLib$TraceDevice_") + 1);
  sprintf (tmp_sysvar_name, "DebugLib$TraceDevice_%s", debug_current_options.taskname);

  tmp_string = misc_getenv_malloc (tmp_sysvar_name);

  /* If we got something out of the system variable ... */
  if (tmp_string)
  {
    /* ... convert it to a output device type */
    sysvar_provided_tracedevice = (debug_device) atoi (tmp_string);
    free (tmp_string);
  }

  /* Free up the temp string */
  if (tmp_sysvar_name)
    free (tmp_sysvar_name);
}


/************************************************************************/
/* debug_initialise_options                                             */
/*                                                                      */
/* Function initialises the library's options to default values         */
/*                                                                      */
/* Parameters: none                                                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void debug_initialise_options (void)
{
  debug_current_options.taskname = NULL;
  debug_current_options.filename = NULL;
  debug_current_options.device = NULL_OUTPUT;
  debug_current_options.trace_device = NULL_OUTPUT;
  debug_current_options.taskname_prefix = TRUE;
  debug_current_options.stamp_debug = FALSE;
  debug_current_options.screen_cornering = TRUE;
  debug_current_options.unbuffered_files = FALSE;
  debug_current_options.serial_lf = TRUE;
  debug_current_options.serial_port_speed = SerialPort_DefaultSpeed;
  debug_current_options.serial_port_number = SerialPort_DefaultPort;
  debug_current_options.dump_width = DumpWidth_DefaultWidth;
}


/************************************************************************/
/* debug_initialise                                                     */
/*                                                                      */
/* Function initialises the library                                     */
/*                                                                      */
/* Parameters: name - name of app that is calling the library.          */
/*             fame - file for debug output to FILE                     */
/*             sysvar - System Variable to override default area/level  */
/*                      specifiying system variable. Uses default if    */
/*                      NULL or "" is passed.                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_initialise (const char *name, const char *fname, const char *sysvar)
{
  /* No open debug devices */
  sessions_available.debugit = FALSE;
  sessions_available.tml = FALSE;
  sessions_available.remotedb = FALSE;
  sessions_available.tracker = FALSE;
  sessions_available.pdebug = FALSE;
  sessions_available.serial = FALSE;

  /* Set default debuglib options */
  debug_initialise_options ();

  /* Setup taskname */
  if (debug_current_options.taskname)
    free (debug_current_options.taskname);
  if (name && strlen (name))
    debug_current_options.taskname = debug_strdup (name);
  else
    debug_current_options.taskname = debug_strdup ("DefaultName");

  /* Setup filename */
  debug_setup_filename (fname);

  /* Setup whether we should be doing unbuffered file writes */
  debug_setup_unbuffered ();

  /* Setup the level specifier */
  debug_setup_level (sysvar);

  /* Setup the device */
  debug_setup_device ();

  /* Setup the trace device */
  debug_setup_tracedevice ();

  /* Setup the buffering code */
  buffer_startup();
}


void debug_set_trace_device (debug_device device)
{
  debug_current_options.trace_device = device;
}

void debug_set_taskname_prefix (BOOL on)
{
  debug_current_options.taskname_prefix = on;
}

void debug_set_stamp_debug (BOOL on)
{
  debug_current_options.stamp_debug = on;
}

void debug_set_screen_cornering (BOOL on)
{
  debug_current_options.screen_cornering = on;
}

void debug_set_unbuffered_files (BOOL on)
{
  debug_current_options.unbuffered_files = on;
}

void debug_set_serial_lf (BOOL on)
{
  debug_current_options.serial_lf = on;
}

void debug_set_serial_port_speed (int speed)
{
  debug_current_options.serial_port_speed = speed;
}

void debug_set_serial_port_number (int num)
{
  debug_current_options.serial_port_number = num;
}

void debug_set_dump_width (size_t width)
{
  debug_current_options.dump_width = width;
}


/************************************************************************/
/* debug_set_options                                                    */
/*                                                                      */
/* Function sets up debuglib options.                                   */
/*                                                                      */
/* Parameters: options - Bit 0 Set,    Enable taskname prefixing (def). */
/*                             Unset,  Disable taskname prefixing.      */
/*                     - Bit 1 Set,    Add \r to serial output (def).   */
/*                             Unset,  No \r.                           */
/*                     - Bit 2 Set,    Enable printf "screen cornering" */
/*                                     i.e. each successive "printf"    */
/*                                     output is sent to the top-left   */
/*                                     corner of the screen (default)   */
/*                             Unset,  Disable "screen cornering"       */
/*             sport   - Serial port to use (1|2) - def = 1.            */
/*             sspeed  - Serial port speed (300 - 115200) - def = 9600. */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_options (unsigned int options, int sport, int sspeed)
{
  /* Task prefixing */
  if (options & DebugLib_Options_TasknamePrefix_On)
    debug_current_options.taskname_prefix = TRUE;
  else
    debug_current_options.taskname_prefix = FALSE;

  /* Serial port \r */
  if (options & DebugLib_Options_SerialPortLF_On)
    debug_current_options.serial_lf = TRUE;
  else
    debug_current_options.serial_lf = FALSE;

  /* Serial port number */
  if ((sport > 0) && (sport < 3))
    debug_current_options.serial_port_number = sport;

  /* Serial port speed */
  if ((sspeed >= 300) && (sspeed <= 115200))
    debug_current_options.serial_port_speed = sspeed;

  /* Printf "screen cornering (TM)" */
  if (options & DebugLib_Options_ScreenCornering_On)
    debug_current_options.screen_cornering = TRUE;
  else
    debug_current_options.screen_cornering = FALSE;

  if (options & DebugLib_Options_StampDebug_On)
    debug_current_options.stamp_debug = TRUE;
  else
    debug_current_options.stamp_debug = FALSE;
}


/************************************************************************/
/* debug_terminate                                                      */
/*                                                                      */
/* Function terminates the current debug session.                       */
/*                                                                      */
/* Parameters: none                                                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_terminate (void)
{
  debug_close_device ();

  debug_debugit_quit ();
  debug_file_quit ();
  debug_pdebug_quit ();
  debug_socket_quit ();
  debug_tml_quit ();
  debug_tracker_quit ();
  debug_serial_quit ();
}


/************************************************************************/
/* debug_close_device                                                   */
/*                                                                      */
/* Function closes the currently active device.                         */
/*                                                                      */
/* Parameters: device - integer constant for devices.                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_close_device (void)
{
  time_t timer;

  time (&timer);
  _dprintf ("", "\n***** Debug Session Terminated ***********************************\n");
  _dprintf ("", "Task: %s\n", debug_current_options.taskname);
  _dprintf ("", "Time: %s", ctime(&timer));
  _dprintf ("", "******************************************************************\n");

  if (methods[debug_current_options.device].quit)
    methods[debug_current_options.device].quit();
  debug_current_options.device = NULL_OUTPUT;
}


/************************************************************************/
/* debug_set_device                                                     */
/*                                                                      */
/* Function selects the debug output device                             */
/*                                                                      */
/* Parameters: device - device specifer.                                */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_device (debug_device device)
{
  time_t timer;
  BOOL rc = FALSE;

  /* Fault invalid devices */
  if (device < NULL_OUTPUT || device > UNSET_OUTPUT)
    return;

  if (buff_status.enabled == FALSE)
  {
    /* Buffering is off, so proceed */

    /* If we've been provided with an output device by a sysvar, we want to
       override the the requested output device with the one in the sysvar */
    if (sysvar_provided_device != UNSET_OUTPUT)
      device = sysvar_provided_device;

    /* Set to NULL by default, until proved otherwise.  Removes the need for an ELSE statements
     * when checking for modules
     */

    /* Close down previous debug output */
    debug_close_device ();

    if (methods[device].initialise)
      rc = methods[device].initialise();
    else
      rc = TRUE;

    /* If we've initialised correctly, set the debug
       device */
    if (rc == TRUE)
      debug_current_options.device = device;

    time (&timer);
    _dprintf ("", "\n***** Debug Session Started **************************************\n");
    _dprintf ("", "System: DebugLib %s\n", debug_version());
    _dprintf ("", "        remotedb %s\n", remotedb_version());
    _dprintf ("", "        PDebug %s\n", PDebug_Version());
    _dprintf ("", "Task:   %s\n", debug_current_options.taskname);
    _dprintf ("", "Time:   %s", ctime(&timer));
    {
      char *levels;
      if (level_specifier == NULL)
        levels = "";
      else
        levels = level_specifier;
      _dprintf ("", "Levels: %s\n", levels);
    }
    _dprintf ("", "******************************************************************\n");
  }
}


/************************************************************************/
/* debug_output                                                         */
/*                                                                      */
/* Function sends the debugging data to a valid location.               */
/*                                                                      */
/* Parameters: buffer - data to be streamed.                            */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_output (const char *buffer)
{
  if (buff_status.enabled != FALSE)
  {
    buffer_stream (buffer);
  }
  else
  {
    if (debug_current_options.device < NULL_OUTPUT || debug_current_options.device > UNSET_OUTPUT)
      return;

    if (methods[debug_current_options.device].output)
      methods[debug_current_options.device].output (buffer);
  }
}


/************************************************************************/
/* _dvprintf                                                            */
/*                                                                      */
/* Function is equilivant to vprintf for debugging.                     */
/*                                                                      */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dvprintf(const char *area_level, const char *format, const va_list arg)
{
  if (debug_check_level(area_level, level_specifier) == 1)
  {
    vsprintf(debug_buffer, format, arg);

    if (debug_current_options.stamp_debug == TRUE)
    {
      char buf[20];
      time_t timer;
      struct tm *t;

      time (&timer);

      t = localtime (&timer);

      strftime (buf, sizeof (buf), "%H:%M:%S - ", t);
      debug_output (buf);
    }
    debug_output(debug_buffer);
  }
}


/************************************************************************/
/* _dprintf                                                             */
/*                                                                      */
/* Function sends the data to the current output device                 */
/*                                                                      */
/* Parameters: format - printf configuration.                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dprintf (const char *area_level, const char *format, ...)
{
  va_list p;

  va_start (p, format);
  _dvprintf(area_level, format, p);
  va_end (p);
}


/************************************************************************/
/* debug_beep                                                           */
/*                                                                      */
/* Function makes a beep when called                                    */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_beep (void)
{
  _swix (OS_WriteI + 7, 0);
}


/************************************************************************/
/* stream_debug_output                                                  */
/*                                                                      */
/* Function sends the debugging data to the specified stream.           */
/*                                                                      */
/* Parameters: buffer - data to be streamed.                            */
/*             stream - place to send it.                               */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void stream_debug_output (debug_device device, const char *buffer)
{
  BOOL rc;

  if (device < NULL_OUTPUT || device > UNSET_OUTPUT)
    return;

  if (methods[device].initialise)
    rc = methods[device].initialise();
  else
    rc = TRUE;

  if (rc == TRUE)
  {
    if (device != FILE_OUTPUT)
    {
      if (methods[device].output)
        methods[device].output (buffer);
    }
  }
}


/************************************************************************/
/* _dfprintf                                                            */
/*                                                                      */
/* Function sends the data to the specified stream.                     */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dfprintf (const char *area_level, debug_device stream, const char *format, ...)
{
  va_list p;

  if (debug_check_level (area_level, level_specifier) == 1)
  {
    va_start (p, format);
    vsprintf (debug_buffer, format, p);
    va_end (p);

    if (stream == debug_current_options.device)
      debug_output (debug_buffer);
    else
      stream_debug_output (stream, debug_buffer);
  }
}

/************************************************************************/
/* ddumpbuf                                                             */
/*                                                                      */
/* Function to dump a buffer to the current output device               */
/*                                                                      */
/* Parameters: buffer - data to dump                                    */
/*             size   - amount of data to dump                          */
/*             offset - offset to add to addresses                      */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ddumpbuf(const char *area_level, const void *buffer, size_t size, size_t offset)
{
  if (debug_check_level (area_level, level_specifier) == 1)
  {
    const size_t width = debug_current_options.dump_width;
    const size_t end = ((size + width - 1) / width) * width;
    const char *membuf = buffer;

    size_t i = 0, j;
    char *db;

    db = debug_buffer;
    *db = 0;

    while (i < end) {
      if ((i % width) == 0) {
        if (i) {
          db += sprintf(db, ": ");
          for (j = i - width; j != i; ++j) {
            db += sprintf(db, "%c", (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
          }
          sprintf(db, "\n");
          debug_output (debug_buffer);
          db = debug_buffer;
        }
        db += sprintf(db, "%04x: ", i + offset);
      }

      if (i>=size) {
        db += sprintf(db, "   ");
      }
      else {
        db += sprintf(db, "%02x ", membuf[i]);
      }
      ++i;
    }

    if (i) {
      for (db += sprintf(db, ": "), j = i - width; j != i; ++j) {
        db += sprintf(db, "%c", j>=size ? ' ' : (membuf[j]>=32 && membuf[j] != 0x7f) ? membuf[j] : '.');
      }
      sprintf(db, "\n");
      debug_output (debug_buffer);
    }

  }
}


/************************************************************************/
/* debug_initialise_trace                                               */
/*                                                                      */
/* Function initialises the trace library.                              */
/*                                                                      */
/* Parameters: stream - Debug output stream to use.                     */
/*             fns    - Functions to ignore                             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/

void debug_initialise_trace (debug_device stream, const char *fns)
{
  char *ignore_fns;
  int len, len2;

  if (sysvar_provided_tracedevice == UNSET_OUTPUT)
    debug_current_options.trace_device = stream;
  else
    debug_current_options.trace_device = sysvar_provided_tracedevice;

  global_indent++;

  if (fns == NULL)
    len2 = 0;
  else
    len2 = strlen (fns);

  len = len2 + strlen (always_ignore) + 1;

  if ((ignore_fns = malloc (len)) == NULL)
  {
    return;
  }

  /* Buffer allocated, so add the PDebug, Trace and remotedb functions onto the end of the list */

  if (len2 > 0)
    strcpy (ignore_fns, fns);
  else
    ignore_fns[0] = '\0';

  strcat (ignore_fns, always_ignore);

  Trace_IgnoreFunctions (ignore_fns);
  Trace_SetHandlers (
                     (Trace_fnstarthandler)debug_trace_enter,
                     (Trace_fnstophandler)debug_trace_exit
                    );
  Trace_InterceptAllFunctions ();

  free (ignore_fns);
}


/************************************************************************/
/* debug_trace_enter                                                    */
/*                                                                      */
/* Function is called when a function is entered provided trace is      */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_trace_enter (const char *fname)
{
  int i = 0;
  char buffer[1024];
  char buffer2[256];

  sprintf (buffer, "Trace: %3d:", global_indent);

  /* _dfprintf ("", debug_current_options.trace_device, "Trace: %3d:", global_indent); */
  for (i = 0; i < global_indent; i++)
  {
    strcat (buffer, " |");
    /*stream_debug_output (debug_current_options.trace_device, " |");*/
  }
  sprintf (buffer2, " %s\n", fname);
  strcat (buffer, buffer2);

  _dfprintf ("Trace", debug_current_options.trace_device, buffer);

  global_indent++;
}


/************************************************************************/
/* debug_trace_exit                                                     */
/*                                                                      */
/* Function is called when a function is exited provided trace is       */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_trace_exit (const char* fname)
{
  int i = 0;
  char buffer[1024];
  char buffer2[256];

  sprintf (buffer, "Trace: %3d:", global_indent-1);

  /*_dfprintf ("", debug_current_options.trace_device, "Trace: %3d:", global_indent-1);*/
  for (i=0; i < global_indent-1; i++)
  {
    strcat (buffer, " |");
    /*stream_debug_output (debug_current_options.trace_device, " |");*/
  }

  sprintf (buffer2, "~%s\n", fname);
  strcat (buffer, buffer2);

  _dfprintf ("Trace", debug_current_options.trace_device, buffer);

  global_indent--;
  /*_dfprintf ("", debug_current_options.trace_device, "~%s\n", fname); */
}


/************************************************************************/
/* debug_version                                                        */
/*                                                                      */
/* Function returns the library's version number.                       */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    Pointer to const string containg version number.         */
/*                                                                      */
/************************************************************************/
const char *debug_version (void)
{
  return debug_version_string;
}
