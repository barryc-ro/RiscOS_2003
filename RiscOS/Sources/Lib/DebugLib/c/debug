/************************************************************************/
/* File:    debug.c                                                     */
/* Purpose: The file contains various debugging routines.  I have       */
/*          provided several methods of debug output; TML Podules,      */
/*          !Tracker, printf statements, serial parallel and sockets    */
/* Author:  Neil Bingham (mailto:NBingham@acorn.co.uk)                  */
/* History: Tue 18th February 1997  ver 0.01 - Created.                 */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include "include.h"
#include "debug.h"
#include "inits.h"
#include "output.h"
#include "quits.h"
#include "globals.h"

#include "VersionNum"


/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */
/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

int use_taskname_prefix = TRUE;

int serial_port_speed = SerialPort_DefaultSpeed;
int serial_port_number = SerialPort_DefaultPort;
int serial_handle = 0;
int serial_lf = TRUE;

int printf_screen_cornering = 1;

int DEBUG_OUTPUT_TYPE = NULL_OUTPUT;		/* Output device - see DebugLib.h */

static int sysvar_provided_type = NULL_OUTPUT;         /* The variable to hold output device specified by
                                                          system variable */

FILE		*debug_file_pointer=NULL;	/* File pointer */

int		trace_stream = NULL;

debug_session	*remotedb_info;			/* RemoteDB handler */

char	TASK_NAME[20];			/* Task name for use with Sockets Library */

char	FILE_FILENAME[300];		/* Filename for FILE debug output */

static char *sys_var_contents = NULL;        /* Contents of area-level specifying sys var */

SessionsAvailable sessions_available;

int tracker_window_handle = -1;

BOOL pdebug_error = FALSE;

/* -------------------------------------- LOCAL VARIABLES --------------------------------------- */

static char    debug_buffer[Debug_Buffer_Size];	/* Buffer for debug data */

static int	stamp_debug = FALSE;		/* Add timestamp to lines if set to TRUE */

/* ------------------------------------ FUNCTION PROTOTYPES ------------------------------------- */
static int global_indent = 0;

void debug_trace_enter(const char *);
void debug_trace_exit(const char *);

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/************************************************************************/
/* debug_check_level                                                    */
/*                                                                      */
/* Checks the area-level pair passed in a dprintf with the system       */
/* variable specifying what areas and levels are wanted, and returns    */
/* 1 if the line should be output, and 0 if it shouldn't                */
/*                                                                      */
/* Parameters: area_level_in - The area-level pair                      */
/*             variable - The contents of the system variable           */
/*                                                                      */
/* Returns:    1 or 0.                                                  */
/*                                                                      */
/************************************************************************/
static int debug_check_level (const char *area_level_in, const char *variable)
{
  char *match;
  int matched = 0;
  int area_level_len, area_len, var_len, offset;
  char *area, *area_level = NULL;
  int level = 0, var_level = 0;

  /* If variable unset, it's a match */
  if (variable == NULL)
    return 1;

  /* If the variable is set and empty, no match */
  if (strlen (variable) == 0)
    return 0;

  area_level_len = strlen (area_level_in);

  /* If the area_level is empty, or NULL, it's a match */
  if (area_level_in == NULL || area_level_len == 0)
    return 1;

  area_level = malloc (strlen (area_level) + 1);
  strcpy (area_level, area_level_in);
  area = area_level;

  if ((area_level_len - 2) > 0)
  {
    /* It's possible to have "A_5" */
    if (isdigit (area_level[area_level_len - 1]) != 0)     /* area_level = "Area_4" */
    {
      /* area_level has an explicit level embedded */
      area_level[area_level_len - 2] = '\0';
      level = atoi (&area_level[area_level_len - 1]);
    }
  }

  if ((area_level_len - 1) > 0)
  {
    /* It's possible to have "A_" */
    if (area_level[area_level_len - 1] == '_')   /* area_level = "Area_" */
    {
      /* area_level has an '_', but no explicit level */
      area_level[area_level_len - 1] = '\0';
      level = 0;
    }
  }
  else
  {
    /* area_level has no explicit level embedded */
    level = 0;
  }

  var_len = strlen (variable);
  area_len = strlen (area);

  if ((match = strstr (variable, area)) != NULL)
  {
    if (match != variable)
    {
      if (*(match-1) != ' ' && (*match-1) != ',')
      {
        /* No match */
        return 0;
      }
    }

    offset = (int) match - (int) variable;

    if (area_len + offset > var_len)
    {
      /* No match, we've fallen off the end of the system variable */
      return 0;
    }
    else if (area_len + offset == var_len)  /* match = "Area" */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (match[area_len] == ',')  /* match = "Area," */
    {
      /* No level in variable, we want everything */
      var_level = 9;
      matched = 1;
    }
    else if (area_len + offset + 1 < var_len)
    {
       if ((match[area_len] == '_') && (!isdigit (match[area_len+1]))) /* match = "Area_" */
      {
        /* No level in variable, we want everything */
        var_level = 9;
        matched = 1;
      }
      else if (match[area_len] == '_' && isdigit (match[area_len+1]))  /* match = "Area_4" */
      {
        /* level supplied in variable */
        var_level = atoi (&match[area_len+1]);
        matched = 1;
      }
      else
        matched = 0;
    }
    else
      matched = 0;
  }
  else
    matched = 0;

  if (area_level)
    free (area_level);

  if (matched == 1)
  {
    if (var_level >= level)
      return 1;
    else
      return 0;
  }
  else
    return 0;
}


/************************************************************************/
/* debug_initialise                                                     */
/*                                                                      */
/* Function initialises the library                                     */
/*                                                                      */
/* Parameters: name - name of app that is calling the library.          */
/*             filename - file for debug output to FILE                 */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_initialise (char *name, char *fname, char* sysvar)
{
  char *sys_variable;
  int tmp_type;
  _kernel_oserror *er;
  char tmp_string[20];

  IGNORE (sysvar);

  /* No open debug devices */
  sessions_available.debugit = FALSE;
  sessions_available.tml = FALSE;
  sessions_available.remotedb = FALSE;
  sessions_available.tracker = FALSE;
  sessions_available.pdebug = FALSE;
  sessions_available.serial = FALSE;

  /* Setup TASK_NAME for use with Sockets debugging. */
  strncpy (TASK_NAME, name, sizeof (TASK_NAME));
  TASK_NAME[sizeof (TASK_NAME) - 1] = '\0';

  /* Setup filename */
  strncpy (FILE_FILENAME, fname, sizeof (FILE_FILENAME));
  FILE_FILENAME[sizeof (FILE_FILENAME) - 1] = '\0';

  if (sys_var_contents != NULL)
    free (sys_var_contents);
  sys_var_contents = malloc (300);

  /* Setup area-level specifying system variable */
  if (sysvar == NULL || strlen (sysvar) == 0)
  {
    sys_variable = malloc (strlen (TASK_NAME) + 15 /* strlen ("DebugLib$Level_") */ + 1);
    sprintf (sys_variable, "DebugLib$Level_%s", TASK_NAME);

    er = _kernel_getenv (sys_variable, sys_var_contents, 300);

    if (sys_variable)
      free (sys_variable);
  }
  else
    er = _kernel_getenv (sysvar, sys_var_contents, 300);

  if (er != NULL)
  {
    /* Probably means the sysvar is unset */
    if (sys_var_contents)
      free (sys_var_contents);
    sys_var_contents = NULL;
  }
  else
  {
    /* Make sure it's NUL terminated */
    sys_var_contents[300 - 1] = '\0';
  }

  /* Setup output device specifying system variable */
  sys_variable = malloc (strlen (TASK_NAME) + 16 /* strlen ("DebugLib$Device_") */ + 1);
  sprintf (sys_variable, "DebugLib$Device_%s", TASK_NAME);

  er = _kernel_getenv (sys_variable, tmp_string, sizeof (tmp_string));

  if (sys_variable)
    free (sys_variable);

  if (er != NULL)
  {
    /* Probably means the sysvar is unset */
    sysvar_provided_type = NULL_OUTPUT;
  }
  else
  {
    /* Make sure it's the device specifier is NUL terminated */
    tmp_string[sizeof(tmp_string) - 1] = '\0';

    /* And convert it to a output device type */
    tmp_type = atoi (tmp_string);

    /* Set the output device to the one specified */
    debug_output_device (tmp_type);

    /* And set a variable which is checked later */
    sysvar_provided_type = tmp_type;
  }
}


/************************************************************************/
/* debug_set_options                                                    */
/*                                                                      */
/* Function sets up debuglib options.                                   */
/*                                                                      */
/* Parameters: options - Bit 0 Set,    Enable taskname prefixing (def). */
/*                             Unset,  Disable taskname prefixing.      */
/*                     - Bit 1 Set,    Add \r to serial output (def).   */
/*                             Unset,  No \r.                           */
/*             sport   - Serial port to use (1|2) - def = 1.            */
/*             sspeed  - Serial port speed (300 - 115200) - def = 9600. */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_set_options (const unsigned int options, const int sport, const int sspeed)
{
  /* Task prefixing */
  if (options & DebugLib_Options_TasknamePrefix_On)
    use_taskname_prefix = TRUE;
  else
    use_taskname_prefix = FALSE;

  /* Serial port \r */
  if (options & DebugLib_Options_SerialPortLF_On)
  {
    serial_lf = TRUE;
  }
  else
    serial_lf = FALSE;

  /* Serial port number */
  if ( (sport > 0) && (sport < 3) )
  {
    serial_port_number = sport;
  }

  /* Serial port speed */
  if ( (sspeed >= 300) && (sspeed <= 115200) )
  {
    serial_port_speed = sspeed;
  }

  /* Printf "screen cornering (TM)" */
  if (options & DebugLib_Options_ScreenCornering_On)
    printf_screen_cornering = 1;
  else
    printf_screen_cornering = 0;
}


/************************************************************************/
/* debug_terminate                                                      */
/*                                                                      */
/* Function terminates the current debug session.                       */
/*                                                                      */
/* Parameters: none                                                     */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_terminate (void)
{
  debug_close_device ();

  quit_debugit ();
  quit_file ();
  quit_pdebug ();
  quit_socket ();
  quit_tml ();
  quit_tracker ();
  quit_serial();
}


/************************************************************************/
/* debug_close_device                                                   */
/*                                                                      */
/* Function closes the currently active device.                         */
/*                                                                      */
/* Parameters: device - integer constant for devices.                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_close_device (void)
{
  time_t timer;

  time (&timer);
  _dprintf("", "\n***** Debug Session Terminated ***********************************\n");
  _dprintf("", "Task: %s\n", TASK_NAME);
  _dprintf("", "Time: %s", ctime(&timer));
  _dprintf("", "******************************************************************\n");

  switch(DEBUG_OUTPUT_TYPE)
  {
    case FILE_OUTPUT:
      quit_file ();
      break;

    case PDEBUG_OUTPUT:
      quit_pdebug ();
      break;

    case SOCKET_OUTPUT:
      quit_socket ();
      break;

    case TRACKER_OUTPUT:
      quit_tracker ();
      break;
  }
  DEBUG_OUTPUT_TYPE = NULL_OUTPUT;
}


/************************************************************************/
/* debug_output_device                                                  */
/*                                                                      */
/* Function selects the Debug Output Device                             */
/*                                                                      */
/* Parameters: device - integer constant for devices.                   */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_output_device (int device)
{
  time_t timer;

  /* If we've been provided with an output device by a sysvar, we want to
     disallow the output device being changed */
  if (sysvar_provided_type != NULL_OUTPUT)
    return;

  if ((device <= no_devices) && (device >= 0))
  {
    /* Set to NULL by default, until proved otherwise.  Removes the need for an ELSE statements
     * when checking for modules
     */

    /* Close down previous debug output */
    debug_close_device ();

    switch (device)
    {
      /* !List Debug output device */
      case DEBUGIT_OUTPUT:
        if (init_debugit () == TRUE)
        {
          /* Module initialised properly */
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* FILE Output */
      case FILE_OUTPUT:
        if (init_file () == TRUE)
        {
          /* File opened OK */
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* PDebug Output */
      case PDEBUG_OUTPUT:
        /* Check that module is present */
        if (init_pdebug () == TRUE)
        {
          /* Module initialised properly */
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      case SERIAL_OUTPUT:
        if (init_serial() == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* Sockets */
      case SOCKET_OUTPUT:
        if (init_socket () == TRUE)
        {
          /* Initialised OK */
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* TML Output */
      case TML_OUTPUT:
        /* Check that module is present */
        if (init_tml () == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* Tracker Output */
      case TRACKER_OUTPUT:
        /* Check that module is present */
        if (init_tracker () == TRUE)
        {
          DEBUG_OUTPUT_TYPE = device;
        }
        break;

      /* Printf Output */
      case PRINTF_OUTPUT:
        /* No initialisation to do */
        DEBUG_OUTPUT_TYPE = device;
        break;
    }
    time (&timer);
    _dprintf("", "\n***** Debug Session Started **************************************\n");
    _dprintf("", "System: DebugLib %s  (Neil Bingham & John Beranek)\n",
                      Module_MajorVersion);
    _dprintf("", "Task:   %s\n", TASK_NAME);
    _dprintf("", "Time:   %s", ctime(&timer));
    {
      char *levels;
      if (sys_var_contents == NULL)
        levels = "";
      else
        levels = sys_var_contents;
      _dprintf("", "Levels: %s\n", levels);
    }
    _dprintf("", "******************************************************************\n");
  }
}


/************************************************************************/
/* debug_output                                                         */
/*                                                                      */
/* Function sends the debugging data to a valid location.               */
/*                                                                      */
/* Parameters: buffer - data to be streamed.                            */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_output (const char *stream)
{
  switch (DEBUG_OUTPUT_TYPE)
  {
    case NULL_OUTPUT:
      // do nothing
      break;

    /* !Listdebug Output */
    case DEBUGIT_OUTPUT:
      output_debugit (stream);
      break;

    /* FILE Output */
    case FILE_OUTPUT:
      output_file (stream);
      break;

    /* PDebug Output */
    case PDEBUG_OUTPUT:
      output_pdebug (stream);
      break;

    /* Printf Output */
    case PRINTF_OUTPUT:
      output_printf (stream);
      break;

    /* RemoteDB Output */
    case SOCKET_OUTPUT:
      output_socket (stream);
      break;

    /* Serial Output */
    case SERIAL_OUTPUT:
      output_serial (stream);
      break;

    /* !Tracker Output */
    case TRACKER_OUTPUT:
      output_tracker (stream);
      break;

    /* TML Podule Output */
    case TML_OUTPUT:
      output_tml (stream);
      break;
  }
}


/************************************************************************/
/* _dprintf                                                             */
/*                                                                      */
/* Function sends the data to the current output device                 */
/*                                                                      */
/* Parameters: format - printf configuration.                           */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dprintf (const char *area_level, const char *format, ...)
{
  va_list p;

  if (debug_check_level (area_level, sys_var_contents) == 1)
  {
    va_start (p, format);
    vsprintf (debug_buffer, format, p);
    va_end (p);

    if (stamp_debug == TRUE)
    {
      time_t timer;
      time (&timer);

      debug_output (ctime (&timer));
    }
    debug_output (debug_buffer);
  }
}


/************************************************************************/
/* debug_beep                                                           */
/*                                                                      */
/* Function makes a beep when called                                    */
/*                                                                      */
/* Parameters: none.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_beep (void)
{
  _swix (0x107, _IN(0));
}


/************************************************************************/
/* stream_debug_output                                                  */
/*                                                                      */
/* Function sends the debugging data to the specified stream.           */
/*                                                                      */
/* Parameters: buffer - data to be streamed.                            */
/*             stream - place to send it.                               */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void stream_debug_output (int stream, const char *buffer)
{
  switch (stream)
  {
    case NULL_OUTPUT:
      // do nothing
      break;

    /* !Listdebug Output */
    case DEBUGIT_OUTPUT:
      if (init_debugit () == TRUE)
        output_debugit (buffer);

      break;

    /* PDebug Output */
    case PDEBUG_OUTPUT:
      if (init_pdebug () == TRUE)
        output_pdebug (buffer);

      break;

    /* RemoteDB Output */
    case SOCKET_OUTPUT:
      if (init_socket () == TRUE)
        output_socket (buffer);

      break;

    /* !Tracker Output */
    case TRACKER_OUTPUT:
      if (init_tracker () == TRUE)
        output_tracker (buffer);

      break;

    /* TML Podule Output */
    case TML_OUTPUT:
      if (init_tml () == TRUE)
        output_tml (buffer);

      break;

    /* Serial Output */
    case SERIAL_OUTPUT:
      if (init_serial () == TRUE)
        output_serial (buffer);

      break;

    case FILE_OUTPUT:
      /* Do Nothing.  I guess it should open a file,
         write to it, then close it */
      break;
  }
}


/************************************************************************/
/* _dfprintf                                                            */
/*                                                                      */
/* Function sends the data to the specified stream.                     */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void _dfprintf (const char *area_level, const int stream, const char *format, ...)
{
  va_list p;

  if (debug_check_level (area_level, sys_var_contents) == 1)
  {
    va_start (p, format);
    vsprintf (debug_buffer, format, p);
    va_end (p);

    stream_debug_output (stream, debug_buffer);
  }
}


/************************************************************************/
/* debug_initialise_trace                                               */
/*                                                                      */
/* Function initialises the trace library.                              */
/*                                                                      */
/* Parameters: stream - Debug output stream to use.                     */
/*             fns    - Functions to ignore                             */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_initialise_trace (int stream, char *fns)
{
  char *ignore_fns;
  int len;

  trace_stream = stream;
  global_indent++;

  len = strlen (fns) + 61  /* strlen (" PDebug_* debug_printf Trace_* debug_printf remote_debug_open") */ + 1;

  if ((ignore_fns = malloc (len)) == NULL)
  {
    return;
  }

  /* Buffer allocated, so add the PDebug, Trace and remotedb functions onto the end of the list */
  strcpy (ignore_fns, fns);
  strcat (ignore_fns, " PDebug_* debug_printf Trace_* debug_printf remote_debug_open");

  Trace_IgnoreFunctions (ignore_fns);
  Trace_SetHandlers (
                     (Trace_fnstarthandler)debug_trace_enter,
                     (Trace_fnstophandler)debug_trace_exit
                    );
  Trace_InterceptAllFunctions ();
}


/************************************************************************/
/* debug_trace_enter                                                    */
/*                                                                      */
/* Function is called when a function is entered provided trace is      */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_trace_enter (const char* fname)
{
  int i = 0;

  _dfprintf ("", trace_stream, "Trace: %3d:", global_indent);
  for (i=0; i< global_indent; i++)
  {
    stream_debug_output (trace_stream, " |");
  }
  _dfprintf ("", trace_stream, " %s\n", fname);
  global_indent++;
}


/************************************************************************/
/* debug_trace_exit                                                     */
/*                                                                      */
/* Function is called when a function is exited provided trace is       */
/* running.                                                             */
/*                                                                      */
/* Parameters: format - fprintf configuration.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void debug_trace_exit (const char* fname)
{
  int i = 0;

  _dfprintf ("", trace_stream, "Trace: %3d:", global_indent-1);
  for (i=0; i < global_indent-1; i++)
  {
    stream_debug_output (trace_stream, " |");
  }
  global_indent--;
  _dfprintf ("", trace_stream, "~%s\n", fname);
}
