/**************************************************************************/
/* File:    msghandle.c                                                   */
/* Purpose: This file contains various functions to use with MessageTrans.*/
/*          application by default.                                       */
/* Author:  Neil Bingham <mailto:neil@binghams.demon.co.uk>               */
/* History: 0.01  - Tue 18th February 1997                                */
/*                  Created.                                              */
/*          0.02  - Mon 20th October 1997                                 */
/*                  Incorporated into NBLib                               */
/**************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "main.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */

/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* nb_messagetrans_close_file                                           */
/*                                                                      */
/* Function closes an opened MessageTrans file.                         */
/*                                                                      */
/* Parameters: flags                                                    */
/*             file_id  - Pointer to MessageTrans file.                 */
/*                                                                      */
/* Returns:    _kernel_oserror.                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_messagetrans_close_file(unsigned int flags, MessagesFD file_id)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er = NULL;

  NB_UNUSED(flags);

  regs.r[0] = (int) &file_id;

  er = _kernel_swi(MessageTrans_CloseFile, &regs, &regs);
  if (er != NULL)
  {
    return_code.errnum = er->errnum;
    strcpy(return_code.errmess, er->errmess);
    return(&return_code);
  }
  else
  {
    return(NULL);
  }
}


/************************************************************************/
/* nb_messagetrans_file_info                                            */
/*                                                                      */
/* Function reads the size of the MessageTrans file so that a suitable  */
/* buffer can be declared prior to calling nb_messagetrans_open_file()  */
/*                                                                      */
/* Parameters: flags                                                    */
/*             filename - filename to check.                            */
/*             size     - pointer to size of MessageTrans file.         */
/*                                                                      */
/* Returns:    _kernel_oserror.                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_messagetrans_file_info(unsigned int flags, char *filename, int *filesize)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er = NULL;

  NB_UNUSED(flags);

  regs.r[1] = (int) filename;

  er = _kernel_swi(MessageTrans_FileInfo, &regs, &regs);
  if(er != NULL)
  {
    return_code.errnum = er->errnum;
    strcpy(return_code.errmess, er->errmess);
    return(&return_code);
  }
  else
  {
    *filesize = regs.r[2];
    return(NULL);
  }
}


/************************************************************************/
/* nb_messagetrans_lookup                                               */
/*                                                                      */
/* Function looks up the tag specified in the specified Messages File & */
/* returns the token to the calling function.                           */
/*                                                                      */
/* Parameters: file_id  - file handle as setup by nb_messagetrans_open..*/
/*             tag      - tag in Messages to lookup.                    */
/*                                                                      */
/* Returns:    Token which matches the tag in Messages.                 */
/*                                                                      */
/************************************************************************/
char *nb_messagetrans_lookup(MessagesFD file_id, char *tag)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er = NULL;

  regs.r[0] = (int) &file_id;
  regs.r[1] = (int) tag;
  regs.r[2] = 0;

  if ((strcmp(tag, NULL) == 0) || (strcmp(tag, "") == 0))
  {
    return("");
  }
  else
  {
    er = _kernel_swi(MessageTrans_Lookup,&regs,&regs);

    if (er != NULL)
    {
      return("\0");
    }
    else
    {
      return (char *) regs.r[2];
    }
  }
}


/************************************************************************/
/* nb_messagetrans_token_length                                         */
/*                                                                      */
/* Function takes the supplied tag and returns the length of the        */
/* associated token.  0 is returned for invalid tokens.                 */
/*                                                                      */
/* Parameters:  file_id   - Messages file descriptor block.             */
/*              tag       - Tag to match to token.                      */
/*                                                                      */
/* Returns:     length of token (or zero).                              */
/*                                                                      */
/************************************************************************/
int nb_messagetrans_token_length(MessagesFD file_id, char *tag)
{
  _kernel_swi_regs	 regs;
  _kernel_oserror	*er = NULL;

  regs.r[0] = (int) &file_id;
  regs.r[1] = (int) tag;
  regs.r[2] = 0;

  er = _kernel_swi(MessageTrans_Lookup,&regs,&regs);

  if (er != NULL)
  {
    return(0);
  }
  else
  {
    return(regs.r[3]);
  }
}


/************************************************************************/
/* nb_messagetrans_lookup_params                                        */
/*                                                                      */
/* Function looks up the tag specified in the Messages file, substitutes*/
/* in the text of the parameters and returns the entire string.         */
/*                                                                      */
/* Parameters: file_id  - file handle as setup by nb_messagetrans_open..*/
/*             tag      - tag in Messages to lookup.                    */
/*             param_1  - Parameter 1.                                  */
/*             param_2  - Parameter 2.                                  */
/*             param_3  - Parameter 3.                                  */
/*             param_4  - Parameter 4.                                  */
/*                                                                      */
/* Returns:    Token which matches the tag in Messages.                 */
/*                                                                      */
/************************************************************************/
char *nb_messagetrans_lookup_params(MessagesFD file_id, char *tag,
                                   char *param_1, char *param_2, char *param_3, char *param_4)
{
  _kernel_swi_regs	regs;
  char			*ptr = NULL;
  int			parsed_length = 0;

  /* Make sure something was passed */
  if ((strcmp(tag, NULL) == 0) || (strcmp(tag, "") == 0))
  {
    return("");
  }
  else
  {
    /* Get size of parsed string so we can malloc enough memory */
    regs.r[0] = (int) &file_id;
    regs.r[1] = (int) tag;
    regs.r[2] = (int) 0;

    /* Do lookup with no buffer so size of required buffer is returned */
    if (_kernel_swi(MessageTrans_Lookup,&regs,&regs))
    {
      return 0;
    }
    else
    {
      /* Allocate memory */
      parsed_length =( strlen( (char *)regs.r[2]) + strlen(param_1) + strlen(param_2) +
                       strlen(param_3) + strlen(param_4) + 5 // for good luck ;-)
                     );
      if ((ptr = malloc (parsed_length)) == NULL)
      {
        return("");
      }
      else
      {
        /* Setup registers for 'real' call */
        regs.r[0] = (int) &file_id;
        regs.r[1] = (int) tag;
        regs.r[2] = (int) ptr;
        regs.r[3] = parsed_length;

        /* See if param_1 has anything in it */
        if (strcmp(param_1, "") != 0)
        {
          /* it does, so put it in R4 */
          regs.r[4] = (int) param_1;
        }
        /* See if param_2 has anything in it */
        if (strcmp(param_2, "") != 0)
        {
          /* it does, so put it in R5 */
          regs.r[5] = (int) param_2;
        }
        /* See if param_3 has anything in it */
        if (strcmp(param_3, "") != 0)
        {
          /* it does, so put it in R6 */
          regs.r[6] = (int) param_3;
        }
        /* See if param_4 has anything in it */
        if (strcmp(param_4, "") != 0)
        {
          /* it does, so put it in R7 */
          regs.r[7] = (int) param_4;
        }

        /* Call SWI again with a proper buffer */
        if (_kernel_swi(MessageTrans_Lookup,&regs,&regs))
        {
          return 0;
        }

        else
        {
          return (char *) ptr;
        }
      }
    }
  }
}


/************************************************************************/
/* nb_messagetrans_wimp_error                                           */
/*                                                                      */
/* Function puts the token matching the passed tag into a standard wimp */
/* message error box.                                                   */
/*                                                                      */
/* Assumes:    Tag _taskname returns the program's name.                */
/*                                                                      */
/* Parameters: file_id  - MessageTrans file pointer.                    */
/*             tag      - pointer to token to use.                      */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void nb_messagetrans_wimp_error(MessagesFD file_id, char *tag)
{
  _kernel_oserror	er;
  _kernel_oserror	*is_error = NULL;
  _kernel_swi_regs	regs;

  er.errnum = 0;
  strncpy(er.errmess, nb_messagetrans_lookup(file_id, tag), 250);

  /* Setup registers */
  regs.r[0] = (int) &er;
  regs.r[1] = 1;
  regs.r[2] = (int) nb_messagetrans_lookup(file_id, "_TaskName");

  is_error = _kernel_swi(Wimp_ReportError, &regs, &regs);
}


/************************************************************************/
/* nb_messagetrans_params_wimp_error                                    */
/*                                                                      */
/* Function looks up the tag specified in the specified Messages file,  */
/* and then displays the tag in a standard OS message box.              */
/*                                                                      */
/* Parameters: file_id  - MessageTrans file pointer.                    */
/*             tag      - Tag in Messages to lookup.                    */
/*             param_1  - Parameter 1.                                  */
/*             param_2  - Parameter 2.                                  */
/*             param_3  - Parameter 3.                                  */
/*             param_4  - Parameter 4.                                  */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void nb_messagetrans_params_wimp_error(MessagesFD file_id, char *tag, char *param_1, char *param_2,
                                       char *param_3,char *param_4)
{
  _kernel_oserror	er;
  _kernel_oserror	*is_error = NULL;
  _kernel_swi_regs	regs;

  er.errnum = 0;
  strncpy(er.errmess, nb_messagetrans_lookup_params(file_id, tag, param_1, param_2, param_3,
                                                    param_4), 250);

  /* Setup registers */
  regs.r[0] = (int) &er;
  regs.r[1] = 1;
  regs.r[2] = (int) nb_messagetrans_lookup(file_id, "_TaskName");

  is_error = _kernel_swi(Wimp_ReportError, &regs, &regs);

}


/************************************************************************/
/* nb_messagetrans_wimp_decide_error                                    */
/*                                                                      */
/* Function looks up the tag specified in the Messages file and then    */
/* displays the tag in a standard OS message box.                       */
/*                                                                      */
/* Parameters: file_id  - MessageTrans file pointer.                    */
/*             tag      - Tag in Messages to lookup.                    */
/*                                                                      */
/* Returns:    TRUE (OK clicked), or FALSE (Cancel clicked).            */
/*                                                                      */
/************************************************************************/
int nb_messagetrans_wimp_decide_error(MessagesFD file_id, char *token)
{
  _kernel_oserror	 er;
  _kernel_oserror	*is_error = NULL;
  _kernel_swi_regs	 regs;

  er.errnum = 0;
  strncpy(er.errmess, nb_messagetrans_lookup(file_id, token), 254);

  /* Setup registers */
  regs.r[1] = 3;
  regs.r[0] = (int) &er;
  regs.r[2] = (int) nb_messagetrans_lookup(file_id, "_TaskName");

  is_error = _kernel_swi(Wimp_ReportError, &regs, &regs);

  /* Check r1 to see what button was pressed by the user */
  if (regs.r[1] == 1)
  {
    /* OK Pressed */
    return(TRUE);
  }
  else
  {
    /* Cancel Pressed (if setup) */
    return(FALSE);
  }
}


/************************************************************************/
/* nb_messagetrans_enumerate_no                                         */
/*                                                                      */
/* Function returns the number on the end of a token returned by        */
/* MessageTrans_EnumerateToken in r2. If an invalid token is passed, the*/
/* token is returned                                                    */
/*                                                                      */
/* Parameters: flags                                                    */
/*             token  - Token to return enumerate value from            */
/*                                                                      */
/* Returns:    enumerate number.                                        */
/*                                                                      */
/************************************************************************/
char *nb_messagetrans_enumerate_no(unsigned int flags, char *token)
{
  char		enumerate_value[20];
  int		len = 0;
  int		pos = 0;

  NB_UNUSED(flags);

  enumerate_value[0] = '\0';

  len = strlen(token);
  pos = len;

  do
  {
    pos--;
  }
  while ((token[pos] != '_') && (pos >= 0));

  nb_right_string(0, token, enumerate_value, (len-pos-1));
  return(enumerate_value);
}

