/************************************************************************/
/* File:    NB_String.c                                                 */
/* Purpose: String Handling Code in NBLib.                              */
/*                                                                      */
/* Author:  Neil Bingham <mailto:nbingham@acorn.com>                    */
/* History: 0.01  - Fri 01st August 1997                                */
/*                  Created.                                            */
/*          0.02  - Fri 06th November 1998                              */
/*                  Moved code from NB_Misc into separate file.         */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "math.h"
#include "time.h"
#include "ctype.h"

#include "main.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */


/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */

/************************************************************************/
/* nb_case_insensitive_strcmp                                           */
/*                                                                      */
/* Function does a strcmp but in a case sensitive manner.               */
/*                                                                      */
/* Parameters:  string 1                                                */
/*              string 2                                                */
/*                                                                      */
/* Returns:     TRUE or FALSE.                                          */
/*                                                                      */
/************************************************************************/
int nb_case_insensitive_strcmp(const char *first, const char *second)
{
  for (;;)
  {
    unsigned int a = *first++;
    unsigned int b = *second++;

    if (a == 0) return -b;
    if (a != b)
    {
      unsigned int c = (unsigned int) tolower(a);
      unsigned int d = (unsigned int) tolower(b);
      signed int result = c - d;
      if (result != 0) return result;
    }
  }
}


/************************************************************************/
/* nb_case_insensitive_strncmp                                          */
/*                                                                      */
/* Function does a strncmp but in a case sensitive manner.              */
/*                                                                      */
/* Parameters:  string 1 -                                              */
/*              string 2 -                                              */
/*              n        - number of bytes to compare.                  */
/*                                                                      */
/* Returns:     TRUE or FALSE.                                          */
/*                                                                      */
/************************************************************************/
int nb_case_insensitive_strncmp(const char *first, const char *second, size_t limit)
{
  for (;limit;--limit)
  {
    unsigned int a = *first++;
    unsigned int b = *second++;

    if (a == 0) return -b;
    if (a != b)
    {
      unsigned int c = (unsigned int) tolower(a);
      unsigned int d = (unsigned int) tolower(b);
      signed int result = c - d;
      if (result != 0) return result;
    }
  }
  return 0;
}


/************************************************************************/
/* nb_mid_string                                                        */
/*                                                                      */
/* Function is equilivant to Basic's MID$.  It takes a starting position*/
/* from ZERO and returns the number of chars specified including the    */
/* character at the starting position.                                  */
/*                                                                      */
/* Parameters:                                                          */
/*                                                                      */
/* Returns:                                                             */
/*                                                                      */
/************************************************************************/
void nb_mid_string(unsigned int flags, char *source, char *result, int start_pos, int nchars)
{
  int			 len = 0;
  int			 count = 0;

  NB_UNUSED(flags);

  len = strlen(source);

  strcpy(result, "\0");

  if ((start_pos < len) && ((start_pos + (nchars-1)) < len))
  {
    for (count = start_pos; count <= (start_pos + nchars-1); count++)
    {
      sprintf(result, "%s%c", result, source[count]);
    }
  }
}


/************************************************************************/
/* nb_right_string                                                      */
/*                                                                      */
/* Function does the same as the basic call RIGHT$ in that it returns   */
/* the n right-most characters in the string.                           */
/*                                                                      */
/* Parameters:    flags  - flags word.                                  */
/*                source - source string.                               */
/*                result - destination string for extracted text.       */
/*                nchars - number of chars to extract.                  */
/*                                                                      */
/* Returns:       void.  Result is returned via a pointer.              */
/*                                                                      */
/************************************************************************/
void nb_right_string(unsigned int flags, char *source, char *result, int nchars)
{
  int			 len = 0;
  int			 count = 0;

  NB_UNUSED(flags);

  len = strlen(source);

  strcpy(result, "\0");

  if ((len >0) && (nchars <= len))
  {
    for (count = (len - nchars); count < len; count++)
    {
      sprintf(result, "%s%c", result, source[count]);
    }
  }
}


/************************************************************************/
/* nb_strcpy_malloc                                                     */
/*                                                                      */
/* Function takes the data supplied in 'data', mallocs space at the     */
/* address of 'location' and copies the data to that address.           */
/*                                                                      */
/* Parameters: location - pointer to where to store string.             */
/*             data     - data to copy.                                 */
/*                                                                      */
/* Returns:    _kernel_oserror (error), NULL (success).                 */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_strcpy_malloc(char **location, char *data)
{
  char *ptr;

  if (!data)
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_strcpy_malloc failed because no source data was supplied");
    return(&return_code);
  }
  else if (*data != NULL)
  {
    if ((ptr= malloc(strlen(data) + 2)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_strcpy_malloc failed due to lack of memory");
      return(&return_code);
    }
    else
    {
      strcpy(ptr, data);
      *location = ptr;
      return(NULL);
    }
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_strcpy_malloc failed because a null pointer was passed");
    return(&return_code);
  }
}
