/************************************************************************/
/* File:    NB_Files.c                                                  */
/* Purpose: File contains code to do with filer operations.             */
/*                                                                      */
/* Author:  Neil Bingham <mailto:neil@binghams.demon.co.uk>             */
/* History: 0.01  Tue 14th October 1997                                 */
/*                Created.                                              */
/*          0.02  Fri 07th August 1998                                  */
/*                Removed directory code into separate file.            */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "main.h"

/* ---------------------------------- PRE-PROCESSOR DIRECTIVES ---------------------------------- */

/* -------------------------------------- GLOBAL VARIABLES -------------------------------------- */


/* ----------------------------------------- FUNCTIONS ------------------------------------------ */


/* ============================================================================================== */
/* |======================================== CREATE CODE =======================================| */
/* ============================================================================================== */



/************************************************************************/
/* nb_file_copy                                                         */
/*                                                                      */
/* Function copies the file specified in source to the file specified   */
/* in destination.                                                      */
/*                                                                      */
/* Parameters: flags       - 0: Set   - Move files.                     */
/*                              Unset - Copy files.                     */
/*             source      - source file.                               */
/*             destination - destination file.                          */
/*                                                                      */
/* Returns:    _kernel_oserror.                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_copy(unsigned int flags, char *source, char *destination)
{
  _kernel_swi_regs	regs;
  _kernel_oserror	return_code;

  if (nb_file_exists(1, source, NULL, NULL) == NULL)
  {
    regs.r[0] = 26;
    regs.r[1] = (int) source;
    regs.r[2] = (int) destination;

    if (nb_bit_set(flags, 0) == TRUE)
    {
      regs.r[3] = 4738;
    }
    else
    {
      regs.r[3] = 4610;
    }
    return(_kernel_swi(OS_FSControl, &regs, &regs));
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_copy failed because the source file didn't exist");
    return(&return_code);
  }
}


/************************************************************************/
/* nb_file_delete                                                       */
/*                                                                      */
/* Function deletes the specified file.                                 */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to delete. */
/*              location  - directory location or full file path.       */
/*              file_name - file to del, or NULL.                       */
/*                                                                      */
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_delete(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 6;
      regs.r[1] = (int) location;

      er = _kernel_swi(OS_File, &regs, &regs);
      if (er != NULL)
        return(er);
      else
        return(NULL);
    }
    else
    {
      /* file specified does not exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_delete_file failed because file specified does not exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains just directory file exists in - check to see if it is valid */
    if (nb_directory_exists(1, location, NULL) == NULL)
    {
      /* We must add file_name to the end of location
       * allocate memory for operation
       */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 5)) == NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess, "nb_delete_file failed due to lack of memory");
        return(&return_code);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);

        regs.r[0] = 6;
        regs.r[1] = (int) buffer;

        er = _kernel_swi(OS_File, &regs, &regs);
        if (er != NULL)
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_delete_file failed because the file specified doesn't exist.");

          free(buffer);
          return(&return_code);
        }
        else
        {
          return(NULL);
        }
      }
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_delete_file failed because the directory specified doesn't exist.");
      return(&return_code);
    }
  }
}


/************************************************************************/
/* nb_file_exists                                                       */
/*                                                                      */
/* Function checks to see if the specified file exists.                 */
/*                                                                      */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to check.  */
/*                          Bit 1 Set   - Check filetype                */
/*              location  - directory location or full file path.       */
/*              file_name - dir to check, or NULL.                      */
/*                                                                      */
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_exists(unsigned int flags, char *location, char*file_name, int file_type)
{
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer = NULL;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* location includes file to check.
     * Use OS_File 21 to determine path and filetype
     */
    regs.r[0] = 21;
    regs.r[1] = (int) location;
  }
  else
  {
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_exists failed due to lack of memory");
      return(&return_code);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, file_name);
    }
    regs.r[0] = 21;
    regs.r[1] = (int) buffer;
  }

  /* Filepath sorted out, so check for its validity. */
  er = _kernel_swi(OS_File, &regs, &regs);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    if((regs.r[0] != 0) && (regs.r[0] != 2))
    {
      /* The file_path does not point to a directory, so continue. */
      if (nb_bit_set(flags,1) == TRUE)
      {
        /* Check Filetype */
        if (regs.r[6] == file_type)
        {
          /* Filetype valid, so return */
          if (nb_bit_set(flags, 0) == FALSE)
          {
            free(buffer);
          }
          return(NULL);
        }
        else
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_file_exists failed because File Does Not Have The Specified FileType");
          if (nb_bit_set(flags, 0) == FALSE)
          {
            free(buffer);
          }
          return(&return_code);
        }
      }
      else
      {
        /* File Exists, and filetype was not to be checked */
        if (nb_bit_set(flags, 0) == FALSE)
        {
          free(buffer);
        }
        return(NULL);
      }
    }
    else
    {
      /* File doesn't exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "File Specified Does Not Exist.");
      if (nb_bit_set(flags, 0) == FALSE)
      {
        free(buffer);
      }
      return(&return_code);
    }
  }
}


/************************************************************************/
/* nb_file_find_filetype                                                */
/*                                                                      */
/* Function returns the filename of the first file in the directory     */
/* with type absolute.                                                  */
/*                                                                      */
/*                                                                      */
/* Parameters:  flags                                                   */
/*              location  - directory location.                         */
/*              file_type - as hex integer.                             */
/*              file_name - pointer to string                           */
/*              nbytes    - size of string                              */
/*                                                                      */
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_find_filetype(unsigned int flags, char *location, int file_type,
                                        char *file_name, int nbytes)
{
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  OSGBPB_Full_Info	 buffer;      /* Buffer for file details. */
  int			 found_file=FALSE;

  NB_UNUSED(flags);

  /* Setup SWI registers */
  regs.r[0] = 12;		/* OS_GBPB 12 */
  regs.r[1] = (int) location;	/* Directory to search */
  regs.r[2] = (int)&buffer;	/* Buffer for directory information */
  regs.r[3] = 1;		/* Read one item at a time */
  regs.r[4] = 0;		/* Offset of first item to read (0 for start) */
  regs.r[5] = sizeof(buffer);
  regs.r[6] = (int)"*";         /* Return Everything */

  if (nb_directory_exists(1, location, NULL) == NULL)
  {
    /* Directory Exists */
    do
    {
      if ((er = _kernel_swi(OS_GBPB, &regs, &regs)) != NULL)
      {
        /* Error returned by SWI */
        break;
      }

      if (regs.r[3] > 0)
      {
        /* A file has been returned */
        if (buffer.file_type == file_type)
        {
          /* We have found the first file in the directory to match the criteria */
          strncpy(file_name, buffer.name, (nbytes-1));
          found_file = TRUE;
        }
      }
    }
    while (regs.r[4] != -1);
    /* In case we didn't find anything, return an error block */
    if (found_file == FALSE)
    {
    return_code.errnum = 1;
    strcpy(return_code.errmess,
           "nb_file_find_filetype failed because a file of that type didn't exist");
    return(&return_code);
    }
    else
    {
      return(NULL);
    }
  }
  else
  {
    return_code.errnum = 1;
    strcpy(return_code.errmess,"nb_file_find_filetype failed because host directory doesn't exist");
    return(&return_code);
  }
}


/************************************************************************/
/* nb_file_get_datestamp                                                */
/*                                                                      */
/* Function returns the datestamp information for the specified file as */
/* would be seen from the Filer File->Info dialogue.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to check.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to check, or NULL.                     */
/*              date      - string to put date into.                    */
/*              size      - size of date.                               */
/*                                                                      */
/* Returns:     _kernel_oserror if file does not exist.                 */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_get_datestamp(unsigned int flags,char *location,char *filename,char *date,
                                       int size)
{
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  unsigned char		 block[5];
  char			*buffer;
  int			 buffer_len;
  char			 datetime[45];

  if (nb_bit_set(flags, 0) == TRUE)
  {
    buffer_len = strlen(location) + 5;
  }
  else
  {
    buffer_len = strlen(location) + strlen(filename) + 5;
  }
  /* Allocate buffer */
  if ((buffer = malloc(buffer_len)) == NULL)
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_datestamp failed due to lack of memory");
    return(&return_code);
  }
  else
  {
    if (nb_bit_set(flags, 0) == TRUE)
    {
      strcpy(buffer, location);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, filename);
    }

    if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 5;
      regs.r[1] = (int) buffer;

      _kernel_swi(OS_File, &regs, &regs);

      /* Put 5 byte time into block */
      block[4] = (regs.r[2] & 0xFF);
      block[3] = (regs.r[3] & 0xFF000000)	>> 24;
      block[2] = (regs.r[3] & 0xFF0000)		>> 16;
      block[1] = (regs.r[3] & 0xFF00)		>> 8;
      block[0] = (regs.r[3] & 0xFF);

      regs.r[0] = (int)  block;
      regs.r[1] = (int) &datetime;
      regs.r[2] = sizeof(datetime);

      _kernel_swi(OS_ConvertStandardDateAndTime, &regs, &regs);

      strncpy(date, datetime, size);
      return(NULL);
    }
    else
    {
      /* file specified does not exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_file_get_datestamp failed because file specified does not exist");
      return(&return_code);
    }
  }
}

/************************************************************************/
/* nb_file_get_leafname                                                 */
/*                                                                      */
/* Function returns <filename> from <path>.<filename>.                  */
/*                                                                      */
/* Parameters:  flags    - if Bit 0 is set don't check for file existing*/
/*              fullpath - full filename path                           */
/*              filename - pointer to char                              */
/*              size     - size of filename buffer.                     */
/*                                                                      */
/* Returns:     _kernel_oserror                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_get_leafname(unsigned int flags, char *fullpath, char *filename, int size)
{
  _kernel_oserror	return_code;
  int  counter, start_pos, len=0;

  len = strlen(fullpath) - 1;
  start_pos = len;

  if (nb_bit_set(flags, 0) == FALSE)
  {
    if (nb_file_exists(1, fullpath, NULL, NULL) != NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_leafname failed because the file doesn't exist");
      return(&return_code);
    }
  }
  do
  {
    start_pos--;
  }
  while(fullpath[start_pos] != '.');
  start_pos++;

  /* Check that the buffer is big enough */
  if ( (len - start_pos) < size)
  {
    for (counter = 0; counter <= (len - start_pos); counter++)
    {
      filename[counter] = fullpath[start_pos + counter];
    }
    filename[counter] = '\0';
    return(NULL);
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_leafname failed because the buffer was too short.");
    return(&return_code);
  }
}



/************************************************************************/
/* nb_file_get_lines                                                    */
/*                                                                      */
/* Function returns the number of lines of text in a file.              */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to count.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to count, or NULL                      */
/*                                                                      */
/* Returns:    lines in file.                                           */
/*                                                                      */
/************************************************************************/
int nb_file_get_lines(unsigned int flags, char *location, char *filename)
{
  int			 lines_code=0;
  char			 letter;
  char			*buffer = NULL;
  FILE			*file_handle;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      file_handle = fopen(location, "r");
    }
    else
    {
      return(NULL);
    }
  }
  else
  {
    /* Bit 1 unset: location is just directory
     * allocate memory for operation
     */
    if ((buffer = malloc(strlen(location) + strlen(filename) + 30)) == NULL)
    {
      return(NULL);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, filename);
      file_handle = fopen(buffer, "r");
    }
  }

  if (file_handle != NULL)
  {
    while ((letter = getc(file_handle)) != 255) //EOF
    {
      if ( (letter == 10) || (letter == 13) ) //'\n')
      {
        lines_code++;
      }
    }
    fclose(file_handle);
    if (nb_bit_set(flags, 0) == FALSE)
    {
      free(buffer);
    }
    return lines_code;
  }
  else
  {
    if (nb_bit_set(flags, 0) == FALSE)
    {
      free(buffer);
    }
    return(0);
  }
}


/************************************************************************/
/* nb_file_get_size                                                     */
/*                                                                      */
/* Function returns the size of the specified file in bytes             */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to count.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to count, or NULL.                     */
/*                                                                      */
/* Returns:    size (-1 if file doesn't exist).                         */
/*                                                                      */
/************************************************************************/
int nb_file_get_size(unsigned int flags, char *location, char *filename)
{
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  OSGBPB_Full_Info	 buffer;      /* Buffer for file details. */

  if (nb_bit_set(flags, 0) == FALSE)
  {
    /* Bit 1 unset: location contains just directory */
    regs.r[0] = 12;			/* OS_GBPB 12 */
    regs.r[1] = (int) location;		/* Directory to search */
    regs.r[2] = (int)&buffer;		/* Buffer for directory information */
    regs.r[3] = 1;			/* Read one item at a time */
    regs.r[4] = 0;			/* Offset of first item to read (0 for start) */
    regs.r[5] = sizeof(buffer);
    regs.r[6] = (int) "*";

    do
    {
      if ((er = _kernel_swi(OS_GBPB, &regs, &regs)) != NULL)
      {
        /* Error returned by SWI */
        break;
      }
    }
    while ((strcmp(filename, buffer.name) != 0) && (regs.r[4] != -1));

    return(buffer.size);
  }
  return(-1);
}


/************************************************************************/
/* nb_file_get_parent_dir                                               */
/*                                                                      */
/* Function returns <path> from <path>.<filename>.                      */
/*                                                                      */
/* Parameters:  flags      - flags field.                               */
/*              fullpath   - full path of filename.                     */
/*              parent_dir - pointer to buffer.                         */
/*              nbytes     - size of buffer.                            */
/*                                                                      */
/* Returns:     _kernel_oserror                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_get_parent_dir(unsigned int flags, char *fullpath, char *parent_dir,
                                        int nbytes)
{
  _kernel_oserror	return_code;
  int  counter, stop_pos=0, len=0;

  NB_UNUSED(flags);

  if (nb_file_exists(1, fullpath, NULL, NULL) == NULL)
  {
    len = strlen(fullpath) - 1;

    /* We need to start at the end of the string and work backwards to find the beginning of the
     * filename - this will be denoted by a "." character
     */
    stop_pos = len;

    do
    {
      stop_pos--;
    }
    while(fullpath[stop_pos] != '.');

    /* We now scan through from the beginning of the string to the stop_pos (which will be the "."
     * character, and extract the data
     */
    if (stop_pos < nbytes)
    {
      for (counter = 0; counter <= (stop_pos - 1); counter++)
      {
        parent_dir[counter] = fullpath[counter];
      }
      parent_dir[counter] = '\0';
      return(NULL);
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_parent_dir failed because the buffer is too short.");
      return(&return_code);
    }
  }
  else
  {
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_parent_dir failed because the file doesn't exist");
    return(&return_code);
  }
}


/************************************************************************/
/* nb_file_get_filetype                                                 */
/*                                                                      */
/* Function gets the filetype of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to get type*/
/*              location  - directory location or full file path.       */
/*              file_name - file to check, or NULL.                     */
/*              file_type - pointer to int.                             */
/*                                                                      */
/* Returns:    _kernel_oserror if file doesn't exist                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_get_filetype(unsigned int flags, char *location, char *file_name,
                                        int *file_type)
{
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* location includes file to check. */
    if ((buffer = malloc(strlen(location) +  20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      strcpy(buffer, location);
    }
  }
  else
  {
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_get_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, file_name);
    }
  }

  /* Filepath sorted out, so get the filetype */
  if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
  {
    regs.r[0] = 20;
    regs.r[1] = (int ) buffer;

    _kernel_swi(OS_File, &regs, &regs);

    *file_type = regs.r[6];

    free(buffer);
    return(NULL);
  }
  else
  {
    free(buffer);
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_get_filetype failed because file doesn't exist.");
    return(&return_code);
  }
}


/************************************************************************/
/* nb_file_set_filetype                                                 */
/*                                                                      */
/* Function sets the filetype of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to settype */
/*              location  - directory location or full file path.       */
/*              file_name - dir to check, or NULL.                      */
/*              file_type - Hex filetype.                               */
/*                                                                      */
/* Returns:    NULL if it exists, otherwise a _kernel_oserror.          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_set_filetype(unsigned int flags, char *location, char *file_name,
                                        int file_type)
{
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* location includes file to check. */
    if ((buffer = malloc(strlen(location) +  20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_set_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      strcpy(buffer, location);
    }
  }
  else
  {
    /* location contains parent directory only */
    if ((buffer = malloc(strlen(location) + strlen(file_name) + 20)) == NULL)
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_set_filetype failed due lack of memory");
      return(&return_code);
    }
    else
    {
      sprintf(buffer, "%s.%s", location, file_name);
    }
  }

  /* Filepath sorted out, so get the filetype */
  if (nb_file_exists(1, buffer, NULL, NULL) == NULL)
  {
    regs.r[0] = 18;
    regs.r[1] = (int ) buffer;
    regs.r[2] = file_type;

    er = _kernel_swi(OS_File, &regs, &regs);
    free(buffer);

    if (er == NULL)
      return(NULL);
    else
      return(er);
  }
  else
  {
    free(buffer);
    return_code.errnum = 0;
    strcpy(return_code.errmess, "nb_file_set_filetype failed because file doesn't exist.");
    return(&return_code);
  }
}


/************************************************************************/
/* nb_file_stamp                                                        */
/*                                                                      */
/* Function stamps the specified file.                                  */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to stamp.  */
/*              location  - directory location or full file path.       */
/*              file_name - file to run, or NULL.                       */
/*                                                                      */
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_stamp(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror	 return_code;
  _kernel_oserror	*er;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* Bit 1 set: location contains full filepath */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      /* File Exists */
      regs.r[0] = 9;
      regs.r[1] = (int) location;

      er = _kernel_swi(OS_File, &regs, &regs);
      return(er);
    }
    else
    {
      /* file specified does not exist */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_stamp_file failed because file specified does not exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains just directory file exists in - check to see if it is valid */
    if (nb_directory_exists(1, location, NULL) == NULL)
    {
      /* We must add file_name to the end of location
       * allocate memory for operation
       */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 5)) == NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess, "nb_stamp_file failed due to lack of memory");
        return(&return_code);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);

        regs.r[0] = 9;
        regs.r[1] = (int) buffer;

        er = _kernel_swi(OS_File, &regs, &regs);
        if (er != NULL)
        {
          return_code.errnum = 0;
          strcpy(return_code.errmess,
                 "nb_stamp_file failed because the file specified doesn't exist.");

          free(buffer);
          return(&return_code);
        }
        else
        {
          return(NULL);
        }
      }
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess,
             "nb_stamp_file failed because the directory specified doesn't exist.");
      return(&return_code);

    }
  }
}


/************************************************************************/
/* nb_file_lock                                                         */
/*                                                                      */
/* Function sets the Lock bit of the specified file.                    */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to lock.   */
/*              location  - directory location or full file path.       */
/*              file_name - file to lock, or NULL.                      */
/*                                                                      */
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_lock(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* location includes file to lock */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      regs.r[0] = 17;
      regs.r[1] = (int) location;
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_lock failed because file doesn't exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains parent directory */
    /* file_name contains details of the file to lock.  Check file actually exists. */
    if (nb_file_exists(0, location, file_name, NULL) == NULL)
    {
      /* allocate memory for operation */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess, "nb_file_lock failed due to lack of memory");
        return(&return_code);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);

        regs.r[0] = 17;
        regs.r[1] = (int) buffer;
      }
    }
    else
    {
      /* Parent directory didn't exist - report error */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_lock failed because the file doesn't exist");
      return(&return_code);
    }
  }

  /* OK now that paths have been setup, get the existing file flags */
  _kernel_swi(OS_File, &regs, &regs);

  /* Update the returned flags to lock the file */
  regs.r[5] |= (1 << 3);
  regs.r[0] = 4;

  er = _kernel_swi(OS_File, &regs, &regs);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    /* No problem encountered */
    return(NULL);
  }
}


/************************************************************************/
/* nb_file_unlock                                                       */
/*                                                                      */
/* Function sets the Lock bit of the specified file to unlocked.        */
/*                                                                      */
/* Parameters:  flags     - Bit 0 Set   - location contains full path.  */
/*                          Bit 0 Unset - location contains parent dir  */
/*                                       & file_name is file to unlock. */
/*              location  - directory location or full file path.       */
/*              file_name - file to unlock, or NULL.                    */
/*                                                                      */
/* Returns:     _kernel_oserror block.                                  */
/*                                                                      */
/************************************************************************/
_kernel_oserror *nb_file_unlock(unsigned int flags, char *location, char *file_name)
{
  _kernel_oserror	*er;
  _kernel_oserror	 return_code;
  _kernel_swi_regs	 regs;
  char			*buffer;

  if (nb_bit_set(flags, 0) == TRUE)
  {
    /* location includes file to unlock */
    if (nb_file_exists(1, location, NULL, NULL) == NULL)
    {
      regs.r[0] = 17;
      regs.r[1] = (int) location;
    }
    else
    {
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_unlock failed because file doesn't exist");
      return(&return_code);
    }
  }
  else
  {
    /* Location contains parent directory */
    /* file_name contains details of the file to unlock.  Check file actually exists. */
    if (nb_file_exists(0, location, file_name, NULL) == NULL)
    {
      /* allocate memory for operation */
      if ((buffer = malloc(strlen(location) + strlen(file_name) + 6)) == NULL)
      {
        return_code.errnum = 0;
        strcpy(return_code.errmess, "nb_file_unlock failed due to lack of memory");
        return(&return_code);
      }
      else
      {
        sprintf(buffer, "%s.%s", location, file_name);

        regs.r[0] = 17;
        regs.r[1] = (int) buffer;
      }
    }
    else
    {
      /* Parent directory didn't exist - report error */
      return_code.errnum = 0;
      strcpy(return_code.errmess, "nb_file_unlock failed because the file doesn't exist");
      return(&return_code);
    }
  }

  /* OK now that paths have been setup, get the existing file flags */
  _kernel_swi(OS_File, &regs, &regs);

  /* Update the returned flags to lock the file */
  regs.r[5] &= ~(1 << 3);
  regs.r[0] = 4;

  er = _kernel_swi(OS_File, &regs, &regs);

  if (er != NULL)
  {
    return(er);
  }
  else
  {
    /* No problem encountered */
    return(NULL);
  }
}


