#ifndef __html_externs__
#define __html_externs__

#include "tags.h"
#include "struct.h"
#include "tablestruc.h"

#ifndef BOOL
#define BOOL  int

// Sometimes people define Bool & TRUE & FALSE...

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif
#endif

#ifndef NOT_USED
#define NOT_USED(x) { x=x; }
#endif

typedef unsigned char byte;


/***********************************************************************/
/* Structures used internally                                          */
/***********************************************************************/
/* General purpose structure to hold anchor tag information            */
/* All element names are those used in the HTML 2.0 specification.     */
/***********************************************************************/
typedef struct ANCHOR {
    /******/
/*  char		*rel;
    char		*rev;
    char		*urn;
    char		*title;
    char		*methods;  */
    char		*name;
    char		*href;       /* URL of page */
    char		*src;        /* Location of image */
    char                *target;
    char		*alt;	     /* Text for image */
    char 		*action;     /* Place to send form - same as HREF? */
    char 		*enctype;    /* Ignored */
    char 		*value;      /* Of input field */
    unsigned int	maxlength;   /* of input field */
    unsigned int	size;	     /* Of on-screen box */
    unsigned int	rows;	     /* Text area size */
    unsigned int	cols;	     /* text area size */
    unsigned int        spacing;     /* frame, frameset spacing */
    unsigned int        type;	     /* INPUT formats (0-7), frameset types etc. */
    byte	        method;	     /* Method to use - see HTTP module */
    byte		ismap;	     /* ISMAP on images */
    byte		alignment;   /* For images (0-7) */
    byte                valign;      /* For tables (0-7) */
    byte                checked;     /* For checkboxes */
    byte		multiple;    /* For Radio buttons */
    byte		selected;    /* For menus etc */
    byte		border;	     /* Hopefully borderwidth <= 255 */
    byte                colspan;     /* Tables support */
    byte                rowspan;     /* Tables support */
    #ifdef TonyTables
    int                 width;
    #endif
    unsigned int        noshade:1;   /* NOSHADE on <HR>s */
    unsigned int        noresize:1;  /* NORESIZE on <FRAME>s */
    unsigned int        scrolling:2; /* SCROLLING on <FRAME>s */
    } AnchorInfo, *AnchorInfoRef;

/***********************************************************************/
/* This is the internal stream structure used by the HTML stream parser*/
/***********************************************************************/
typedef struct COLOUR_INFO ColourInfo, *ColourInfoRef;

#ifdef TonyTables
typedef struct TABLE_STUFF {
    HStream *Stream;
    unsigned int memcontext;
} TableContext;
#endif

/*
 * States for the stream parser. Somewhat limited at present :)
 */
typedef enum stream_state
{
    Other,            /* Catch all that covers all the original code */
    Declaration,      /* Inside a <! */
    Comment           /* Inside a -- inside a <! */
}
stream_state;

typedef struct styleinfo
{
  byte bold;    /* used as a counter */
  byte italic;  /* used as a counter */
  byte tt;      /* used as a counter */
  byte u;
  byte sub;
  byte sup;
  byte strike;
  byte a;
  byte img;
  byte p;       /* bool */
  byte pre;
  byte dl;
  byte dt;
  byte dd;
  byte ol;
  byte ul;
  byte dir;
  byte br;
  byte blockquote;
  byte address;
  byte centre;
  byte select;
  byte textarea;
  byte li;
  unsigned int h;
  /* Keep track of colour blocks */
  ColourInfo *colour;
} styleinfo;

typedef struct STREAM_TOKENS {
  /* The HTML token counters (not all used -> see code! ) */

  /* head */
  byte _stream_title;   /* used as a counter */
  byte _stream_isindex; /* bool */

  /* body */

  /* Stuff that needs to be stacked away on a <TABLE> */
  styleinfo _stream_style;
  #define _stream_bold   _stream_style.bold
  #define _stream_italic _stream_style.italic
  #define _stream_u      _stream_style.u
  #define _stream_sub    _stream_style.sub
  #define _stream_sup    _stream_style.sup
  #define _stream_strike _stream_style.strike
  #define _stream_tt     _stream_style.tt
  #define _stream_a      _stream_style.a
  #define _stream_img    _stream_style.img
  #define _stream_p      _stream_style.p
  #define _stream_pre    _stream_style.pre
  #define _stream_dl     _stream_style.dl
  #define _stream_dt     _stream_style.dt
  #define _stream_dd     _stream_style.dd
  #define _stream_ol     _stream_style.ol
  #define _stream_ul     _stream_style.ul
  #define _stream_dir    _stream_style.dir
  #define _stream_br     _stream_style.br
  #define _stream_blockquote _stream_style.blockquote
  #define _stream_address _stream_style.address
  #define _stream_center _stream_style.centre
  #define _stream_select _stream_style.select
  #define _stream_textarea _stream_style.textarea
  #define _stream_li     _stream_style.li
  #define _stream_h      _stream_style.h
  #define _stream_colour _stream_style.colour
  /* End stuff that need to be stacked */
  byte _stream_form;

  /* doc tags */
  unsigned int _stream_body:1;
  unsigned int _stream_head:1;
#ifdef NEWSPACING
  unsigned int stripleadingspace:1;
  unsigned int trailingspacestripped:1;
  unsigned int lastwaspcdata:1;
  unsigned int lastwaspcdataspace:1;
  unsigned int isendtag:1;
#endif
#ifdef FRAMESUPPORT
  unsigned int _stream_noframes:1;
  unsigned int usingframes:1;
  byte _stream_frameset;
#endif
  byte type; /* 1 = HTML, 2=TEXT currently */
  byte  _stream_table;
  /* Send a list token with next token? */
  byte send_list;
  /* Cope with another Netscrape-ism */
#ifndef NEWSPACING
  byte stripleadingcr;
#endif
  /* Hold off processing until we get a */
  /* Keep track of end tokens so we can just send back those we need */
  unsigned int needtosend;
  /* How far into the stream are we? */
  unsigned int done;
  unsigned int sizesofar; /* What we have been given in total */
  /* Size of chunk/document */
  unsigned int chunklength;
  unsigned int doclength;
  /* The URL of the document*/
  char *url;
  /* The base target of the document */
  char *target;
  /* Keep track of anchors */
  AnchorInfo *_stream_anchor;
  AnchorInfo *_stream_forms;
  AnchorInfo *_stream_table_anc;
  /* The head of the stream structure */
  HStream *Stream;
  #ifdef TonyTables
  TableContext   *Tables;                  /* Previous parsing contexts for tables */
  table_stream   *_stream_current_table;   /* this is also an HStream * */
  table_row      *_stream_current_row;
  table_headdata *_stream_current_headdata;
  #endif
  /* The memory context we are in */
  unsigned int memcontext;
  unsigned int following_start_tag:1;
  unsigned int _stream_basefont:3;
  stream_state state;
} StreamTokens, *StreamTokensRef;

struct COLOUR_INFO {
  struct COLOUR_INFO *next;
  unsigned int colour:24;
  unsigned int colour_valid:1;
  signed int size:7;
};
/*************************************************************************/
/* These #defines are used in link parsing. They have been moved out of  */
/* the publicly defined interface. 	    	      	   	     	 */
/*************************************************************************/
/*
 * These are the attributes used by links etc. They are in a second
 * status word effectivly.
 */
#ifdef FRAMESUPPORT

enum _anchor_tags {
  REL,		REV,		URN,		_TITLE,
  METHODS,	HREF,		NAME,		SRC,
  BACKGROUND = SRC,
  ALT,		ALIGN,		ISMAP,		ACTION,
  METHOD, 	ENCTYPE,	TYPE,		MAXLENGTH,
  SIZE,		VALUE,		CHECKED,	MULTIPLE,
  SELECTED,	COLS,		ROWS,		BORDER,
  VALIGN,	COLSPAN,	ROWSPAN,	BGCOL,
  FGCOL,	ALINK,		VLINK,		COLOR,
  FONTSIZE,	BASEFONTSIZE,	HRWIDTH,	NOSHADE,
  FRAMEBORDER,  BORDERCOLOR,    MARGINWIDTH,    MARGINHEIGHT,
  SCROLLING,    NORESIZE,       TARGET,         CELLSPACING,
  CELLPADDING,  NOWRAP,         CELLWIDTH,      CELLHEIGHT,
  TABLEWIDTH
};

#else

#define REL			((unsigned int)1<<0)
#define REV			((unsigned int)1<<1)
#define URN			((unsigned int)1<<2)
#define _TITLE			((unsigned int)1<<3)
#define METHODS			((unsigned int)1<<4)
#define HREF			((unsigned int)1<<5)
#define NAME			((unsigned int)1<<6)
#define SRC			((unsigned int)1<<7)
#define ALT			((unsigned int)1<<8)
#define ALIGN			((unsigned int)1<<9)
#define ISMAP			((unsigned int)1<<10)
#define BACKGROUND              SRC

/*
 * Form bits
 */
#define ACTION                  ((unsigned int)1<<11)
#define METHOD			((unsigned int)1<<12)
#define ENCTYPE			((unsigned int)1<<13)
#define TYPE			((unsigned int)1<<14)
#define MAXLENGTH		((unsigned int)1<<15)
#define SIZE			((unsigned int)1<<16)
#define VALUE			((unsigned int)1<<17)
#define CHECKED			((unsigned int)1<<18)
#define MULTIPLE		((unsigned int)1<<19)
#define SELECTED		((unsigned int)1<<20)
#define COLS			((unsigned int)1<<21)
#define ROWS			((unsigned int)1<<22)
#define BORDER			((unsigned int)1<<23)

/* Tables stuff */
#define VALIGN                  ((unsigned int)1<<24)
#define COLSPAN                 ((unsigned int)1<<25)
#define ROWSPAN                 ((unsigned int)1<<26)

/* Colours stuff */
#define BGCOL                   ((unsigned int)1<<27)
#define FGCOL                   ((unsigned int)1<<28)
#define ALINK                   ((unsigned int)1<<29)
#define VLINK                   ((unsigned int)1<<30)

/* Values for <FONT> tags, purely internal */
#define COLOR                   17
#define FONTSIZE                18
#define BASEFONTSIZE            19

/* And HR... */
#define HRWIDTH                 20
#define NOSHADE                 21


#endif

/* The values for align can just be normal unsigned ints not bits set... */
#define TOP			(1)
#define RIGHT			(2)
#define	BOTTOM			(3)
#define LEFT			(4)
#define MIDDLE			(5)

/* The values for INPUT TYPE=... */
#define TEXT  	  		(0)  /* Default case */
#define PASSWORD		(1)  /* Gets hidden */
#define CHECKBOX		(2)  /* Square thing */
#define RADIO			(3)  /* Round thing */
#define IMAGE			(4)  /* Uh-oh! */
#define HIDDEN			(5)  /* Not shown in UI */
#define SUBMIT			(6)  /* Press to send */
#define RESET			(7)  /* You buggered it up? */

/***********************************************************************/
/* From ^.c.parse                                                      */
/***********************************************************************/
/* This file is a hang over from the tree parser; it just contains the */
/* generic code to strip stuff out of anchors and store their value in */
/* and AnchorInfo struct.      	      	      	  	      	       */
/***********************************************************************/
extern AnchorInfo *__html_get_anchor_info(StreamTokens *st, char **anchor_info, Tag tag);

/***********************************************************************/
/* From ^.c.rules                                                      */
/***********************************************************************/
/* ^.c.rules contains a number of small routines for extracting tags   */
/* and manipulating them where required. "Knows the HTML2 DTD".	       */
/***********************************************************************/
extern int __html_check_tag (const Tag *rules, int max_rules, const char *tag);
extern Tag __html_find_start_tag_block(char *tag);
extern Tag __html_find_end_tag_block(char *tag);
extern Tag __html_find_tag(char **html, int end);

/***********************************************************************/
/* From ^.c.display                                                    */
/***********************************************************************/
/* ^.c.display contains the routines needed prior to displaying a page */
/* ATM this is just the code to strip the spaces, but the code to      */
/* convert the ISO-LATIN-1 entities will also be in here       	       */
/***********************************************************************/
#ifdef NEWSPACING
extern int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
extern void __html_strip_trailing_spaces(char *input);
#else
extern char *__html_strip_spaces(char *input, int stripleadingcr);
#endif
extern char *__html_strip_lfs(char *input);
extern char *strdup(char *s1);
extern char *strndup(char *s1, int size);
extern char *__html_unescape_string(char *input);
extern int __html_unnumeric_escape(char ch);
extern void __html_strip_control_codes(char *input);
extern int  strincmp(const char *string, const char *index, int size);
extern char *strnstr(const char *string, const char *index, int size);
char *strinstr(const char *string, const char *index, int size);

/* Need to think about TABs at some stage */
#define CTRL_CODE(c) (c<' ' && c!='\n' && c!='\r')

/***********************************************************************/
/* From ^.c.font                                                       */
/***********************************************************************/
/* ^.c.font contains the routines needed to process the <FONT> tag     */
/***********************************************************************/
extern void add_colour_info(StreamTokens *st, unsigned int col, int *allocate_required);
extern void add_size_info(StreamTokens *st, const char *ptr, int *allocate_required);
extern void fill_in_colour_info(const StreamTokens *st, HStream *hs);
extern void font_tag_closed(StreamTokens *st);

#ifdef USING_OLD_FREE
/***********************************************************************/
/* From ^.c.free - no longer needed I belive                           */
/***********************************************************************/
/* ^.c.free was the initial code to free up memory that was allocated. */
/* These routines were used to free up the stream and tree structures  */
/* before __html_free() existed. There are I believe no longer needed. */
/***********************************************************************/
extern void __html_tree_entry_free(Html *document);
extern void __html_tree_free(Html *document, int depth);
extern void __html_stream_free(HStream *stream);
extern void __html_stream_entry_free(HStream *stream);
#endif

/***********************************************************************/
/* From ^.c.malloc                                                     */
/***********************************************************************/
/* ^.c.malloc is the general purpose front end to malloc which keeps   */
/* account of the context which a set of structures exists in. When    */
/* a call to __html_free() is made, all memory in the same context as  */
/* the pointer passed can be freeded if the second argument is TRUE.   */
/* NOTE: these functions put a wrapper around the memory allocated so  */
/* they cant be used in conjunction with normal free() and malloc().   */
/* The code uses calloc() internally to ensure memory is initialised.  */
/***********************************************************************/
extern char *__html_malloc(size_t bytes, size_t size);
extern void __html_free(void *ptr, int free_all);
extern unsigned int __html_memory_init(void);
extern void __html_memory_list(void);
extern void __html_set_memory_context(unsigned int);
extern void __html_set_memory_context_from_block(void *block);

#if 0
/***********************************************************************/
/* From ^.c.stream                                                     */
/***********************************************************************/
/* ^.c.stream contains a small streamer used to turn a HTML document   */
/* into a stream compatible with Minerva's Philease GUI.    	       */
/***********************************************************************/
extern unsigned int __html_interest_tags;
extern unsigned int __html_indent_tags;
extern HStream *__html_make_stream(Html *doc);
#endif

/***********************************************************************/
/* From ^.c.new_stream                                                 */
/***********************************************************************/
/* ^.c.new_stream contains a small streamer used to turn a HTML        */
/* document into a stream compatible with Minerva's Philease GUI.      */
/***********************************************************************/
extern byte __html_done_for_now;
extern HStream *__html_stream_parse(StreamTokens *st,char **html, char *url, int size, HStream *prevhs);
extern StreamTokens *__html_stream_init(void);
extern void __html_style_init(styleinfo *s);
extern HStream *__html_return_text_token(char *doc, size_t size);

/***********************************************************************/
/* From ^.c.HTTPSupport                                                */
/***********************************************************************/
/* HTTPSupport contains a number of functions to support the parsing   */
/* of HTTP headers, work out file content type, and strip the HTTP     */
/* headers ready to pass to an external application or the main parser */
/***********************************************************************/
extern int __http_strip_headers(char *stream, size_t stream_len);
extern unsigned int __html_identify(char *stream, size_t stream_len, char done, char **url, int *file_type, int *canparse);
extern char *__http_escape_string(char *string);

/***********************************************************************/
/* This is just needed ok' :)                                          */
/***********************************************************************/
#include "ctype.h"

/***********************************************************************/
/* Useful macro's                                                      */
/***********************************************************************/
/* This turns a string into upper case. NOTE: it is destructive. That  */
/* has caught me out before. The best use is to strdup the string and  */
/* then upper_case() it. You will need to do this in two steps.	       */
/***********************************************************************/
#define UPPER_CASE(x) { char *y; y=x; while (*y != '\0') { \
		        *y=toupper(*y); y++; } }
/***********************************************************************/
/* Small macro to do lots of tests in one line of code. This will tell */
/* You if the return value from withing any of the TAG finding fn's is */
/* the NULL_TAG as defined in h.tags	       	       	       	       */
/***********************************************************************/
#define NULL_TAG(x) ( (x.start_tag==NULL) && \
		      (x.tag==0) && (x.rule == 0 ) && (x.anchors == 0))

#endif /* __html_externs__ */
