/*
 * This file contains the definitions of the API for using the HTML2
 * parser libraries.
 */
#ifndef __html2_parser_api_
#define __html2_parser_api_

/*
 * This file includes a number of other files. See these for comments
 * on their content. You will need them _all_ in your include path
 * when compiling with the HTMLlib object file.
 */
#include "html2_ext.h"	/* All the HTML 2 tags  */
#include "tags.h"	/* All the tag #defines */
#include "struct.h"	/* The structures used  */

/* Function calls provided. */

extern void *HtmlParse(char *url, int length, int type, int usingframes);
/* HtmlParse() is used to initialise the HTML parser for a document
 * to be parsed (the document need not actually be present). The
 * arguments passed in are:
 *
 *   (char *) url     - The full URL of the page to be parsed so
 *   	      	      	relative links may be established within the
 *		        document.
 *   (int) length     - The total length of the document (if known).
 *   	   	        This is used oven the chunk size argument for
 *			hourglass % calculation if it is non-zero.
 *   (int) type	      - The type as defined in the return value from
 *   	   	        HtmlIdentify. Typically this is 1 for HTML
 *			and 2 for plain text (this ensure plain text
 *   	   	        is PRE-formatted)
 *   (int) usingframes- If the front end is displaying frames, this
 *                      should equal 1. This will suppress NOFRAMES
 *                      data. Otherwise set to 0.
 */
extern HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flags);
/* HtmlGetStream() attempts to parse the next chunk of document in
 * the context of a previous document, or context created by HtmlParse().
 * The arguments passed in are:
 *
 *   (void *) streamtok - The context to parse in (provided from
 *   	      		  HTMLParse()).
 *   (char **) document - A pointer to a pointer to the start of the
 *   	       		  complete document (NOT the chunk to be
 *			  added).  As yet non-contiguous chunks are
 *			  not supported
 *   (int) size         - size of the chunk added.
 *   (int *) flags      - output destintation for reported flags
 *
 * flags are:
 */
#define HTML_GOT_MORE 1u


extern void HtmlStreamFree(void *stream);
/* Given a pointer to a HTML stream, this call will free up all memory
 * associated with the stream.
 */
extern int HttpStripHeaders(char *stream, size_t stream_len);
/* Given a pointer to the start of a data stream, and the amount of
 * data in the stream, HTTPStripHeaders returns the offset into the
 * stream at which the data segment starts assuming HTTP style headers
 */
extern unsigned int HtmlIdentify(char *stream, size_t stream_len, char done,
       		    		      char **url, int *file_type,
       		    		      int *canparse);
/* Given a pointer to the head of the data stream, the amount of data
 * currently in the stream, and a boolean flag to say if all the data
 * has been retrieved (done = 1 for complete stream, 0 for not), this call
 * attempts to understand the HTTP headers at the start of the stream,
 * indicating if a redirect is needed (return val = 302 and url becomes
 * a pointer to a buffer containing where to go to), authentication is
 * required (return val = 401), or the filetype of the document
 * derived from either the HTTP headers or the body data. If the
 * result is unknown, 0 is returned. If the filetype is known and no
 * redirect is needed, 200 is returned. (Yes these do look like the HTTP
 * response codes dont they :)
 *
 * The value passed back in can parse is as defined below:
 */
#define TYPE_UNKNOWN     0
#define TYPE_HTMLFILE    1
#define TYPE_TEXTFILE    2
#define TYPE_IMAGEFILE   3

/*
 */
extern char *HTTPEscapeString(char *string);
/* When returning data to a server, it is necessary to encode it in the
 * right way. This function call encodes the input string in this way,
 * returning the string to send (and not modifying the input string).
 */

extern void *HtmlMalloc(size_t size, void *parent);
/* Allocate memory associated with a stream - pass as parent a pointer to
 * a HStream or TableStream belonging to that stream. Then when HtmlStreamFree
 * is called, this block will be freed with it. The allocated memory is
 * zero-initialised.
 */

extern void HtmlFree(void *block);
/* Free a block allocated with HtmlMalloc
 */

extern char *HtmlRelativiseURL(const char *base, const char *link, void *parent);
/* Given a base URL (eg http://www.acorn.co.uk/) and a possibly relative URL
 * as found in an href attribute (eg home.html), return the absolute URL
 * (eg http://www.acorn.co.uk/home.html). The returned string is in a buffer
 * allocated with HtmlMalloc, which will be discarded when HtmlStreamFree is
 * called. See HtmlMalloc for details of "parent". Don't forget to check for
 * NULL returns - memory is, alas, finite.
 */

extern void HtmlInit(void);
/* Initialise the HTML library.  *MUST* be called before any other routines
 * in the library.
 */

extern unsigned int HtmlReturnContext(void *block);
/* Return the memory context of an object allocated with HtmlMalloc. This
 * allows, for example, easy identification of objects that are part of a
 * wider collection of blocks that are to be freed with HtmlFree. If zero
 * is returned, the block was either not allocated with HtmlMalloc in the
 * first place or has since been freed (either way, the guard word on the
 * block is not what was expected).
 */

/*
 * Now functions to check attributes applying to an element.
 *
 * Attributes specific to an element first. Conventions are:
 *
 * Function name is Html<ELEMENT><attribute>(HStream *h);
 * The function must be passed an HStream whose tag field is <ELEMENT>.
 * String returns are static, must not be modified, and can be relied upon until
 * HtmlStreamFree is called.
 * If a string attribute is not present, NULL is returned.
 * If a colour is not present, NULL_COLOUR is returned.
 */

extern  const char *HtmlBODYonload(HStream *h);
extern  const char *HtmlBODYonunload(HStream *h);
extern  const char *HtmlBODYbackground(HStream *h);
extern unsigned int HtmlBODYtext(HStream *h);
extern unsigned int HtmlBODYbgcolour(HStream *h);
extern unsigned int HtmlBODYlink(HStream *h);
extern unsigned int HtmlBODYvlink(HStream *h);
extern unsigned int HtmlBODYalink(HStream *h);

extern  const char *HtmlMETAname(HStream *h);
extern  const char *HtmlMETAhttp_equiv(HStream *h);
extern  const char *HtmlMETAcontent(HStream *h);
extern  const char *HtmlMETAscheme(HStream *h);

extern  const char *HtmlFORMaction(HStream *h);
extern  formmethod  HtmlFORMmethod(HStream *h);
extern  const char *HtmlFORMenctype(HStream *h);
extern  const char *HtmlFORMaccept_charset(HStream *h);
extern  const char *HtmlFORMonreset(HStream *h);
extern  const char *HtmlFORMonsubmit(HStream *h);
extern  const char *HtmlFORMtarget(HStream *h);

#endif /* __html2_parser_api_ */
