/***************************************************/
/* File   : HTMLTables.c                           */
/* Purpose: Parsing of Tables and other            */
/*          table related functions                */
/* Author : Tony Cheal                             */
/* History: 12-Feb-97: Created                     */
/***************************************************/
/*have to repeat this here because our header file depends on it!*/
#include "HTMLTables.h"
#include "tablestruc.h"

#ifdef TonyTables
table_stream   * __html_current_table=0; /* this is also an HStream */
table_row      * __html_current_row=0;
table_headdata * __html_current_headdata=0;
/*table_flag     * __html_table_stream_flag=0; */

static void skipptr(char **html)
{
char *ptr;
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
/*
 * why the f*** wasn't this a function, and done earlier???
 * under what circumstance do you want to get the pointer stuck?
 */

 if (html != NULL) {
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) {/*printf("!%c",*ptr);*/ptr++;}
  if (*ptr=='>') ptr++;
  *html=ptr;
  /*printf("\n");*/
 }
}

/* spurious externs... */

HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,char **html, int start, char *url);
void __html_stream_free_anchor(AnchorInfo **anchor);

HStream * __html_table_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 HStream * return_val;
 AnchorInfo *anc;

 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);

 anc = __html_get_anchor_info(st, html, next_tag);
 return_val=__html_stream_return_tag(st,next_tag,html,0,url);

 if (return_val != NULL) {
     table_stream * treturn_val=(table_stream *) return_val;

     return_val->tag=TABLE;
     treturn_val->finished=0;
     treturn_val->List=NULL;
     treturn_val->Next=NULL; /*just in case?*/
     treturn_val->Prev=NULL;
     treturn_val->bgcol=(unsigned int) -1;
     treturn_val->Align=_html_none;

     if (anc)
     {
         treturn_val->border      = anc->border;
         treturn_val->bgcol       = anc->maxlength;
         if (anc->size & 0x80000000)
         {
           treturn_val->cellpadding = anc->size & 0x7fffffff;
           treturn_val->flags    |= TABLEFLAG_CELLPADDING;
         }
         if (anc->spacing & 0x80000000)
         {
           treturn_val->cellspacing = anc->spacing & 0x7fffffff;
           treturn_val->flags      |= TABLEFLAG_CELLSPACING;
         }
         treturn_val->cols        = anc->cols;
         if (anc->cols)
             treturn_val->flags    |= TABLEFLAG_COLS;
         if (anc->alignment != _html_none)
             treturn_val->Align       = anc->alignment;
         if (anc->width & 0x01000000)
         {
             treturn_val->flags  |= TABLEFLAG_WIDTH;
             treturn_val->width   = anc->width & 0x00ffffff;
             treturn_val->flags  |= (anc->width >> 28) << TABLEFLAG_UNITS_SHIFT;
         }
     }
     /* Stack away style information */
     treturn_val->stackedstyle = (styleinfo *) __html_malloc(sizeof(styleinfo), 1);
     if (treturn_val->stackedstyle)
        *treturn_val->stackedstyle = st->_stream_style;

     treturn_val->awaiting_tr = 1;
 }
 if (anc)
    __html_stream_free_anchor(&anc);

/*should set the style stuff?*/
 return return_val;
}

HStream * __html_table_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag); NOT_USED(url);

/*printf("table_table_end_tag 0x%x",(int) __html_current_table);*/
 if (__html_current_table != NULL)
 {
     __html_current_table->finished=-1;
     if (__html_current_table->stackedstyle)
     {
         st->_stream_style = *__html_current_table->stackedstyle;
         __html_free(__html_current_table->stackedstyle, 0);
         __html_current_table->stackedstyle = 0;
     }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 NOT_USED(size);
 NOT_USED(url);

 if (__html_current_table != NULL) {
  table_row * trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
  if (trow != NULL)
  {
    AnchorInfo *anc;

    __html_current_table->awaiting_tr = 0;

    if (__html_current_row != NULL)
    {
      trow->Prev=__html_current_row;
      __html_current_row->Next=trow;
    }
    else
      __html_current_table->List=trow;

    trow->parent = __html_current_table;

    trow->bgcol=__html_current_table->bgcol;
    trow->align=__html_current_table->Align;

    anc = __html_get_anchor_info(st, html, next_tag);
    if (anc)
    {
       if (anc->alignment != _html_none)
           trow->align = anc->alignment;
       trow->valign = anc->valign;
       if (anc->maxlength != (unsigned int) -1)
          trow->bgcol = anc->maxlength;
       __html_stream_free_anchor(&anc);
    }
  }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag);
 NOT_USED(url);
 NOT_USED(st);

 if (__html_current_table)
     __html_current_table->awaiting_tr = 1;
 skipptr(html);
 return NULL;
/*junk up to the next <TR> will be added to the last <TR><TD>*/
}

static HStream * table_thing_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size,int tag)
{
 AnchorInfo * anc;

 NOT_USED(url);
 NOT_USED(size);

 if (__html_current_table != NULL) {
  table_headdata * theaddata=(table_headdata *)__html_malloc(sizeof(table_headdata)+1,1);
  /* Deal with tables missing a <TR> */
  if (__html_current_table->awaiting_tr) {
   table_row *trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
   if (trow != NULL)
   {
     __html_current_table->awaiting_tr = 0;
     if (__html_current_row != NULL)
     {
       trow->Prev=__html_current_row;
       __html_current_row->Next=trow;
     }
     else
       __html_current_table->List=trow;

     trow->parent=__html_current_table;

     trow->bgcol=__html_current_table->bgcol;
     trow->align=__html_current_table->Align;

     __html_current_row = trow;
     __html_current_headdata = NULL;
   }
  }
  if (__html_current_row != NULL && theaddata != NULL)
  {
    if (__html_current_headdata != NULL)
    {
      __html_current_headdata->Next=theaddata;
      theaddata->Prev=__html_current_headdata;
    }
    else
      __html_current_row->List=theaddata;
    theaddata->Tag=tag;
    theaddata->bgcol=__html_current_row->bgcol;
    theaddata->Align=__html_current_row->align;
    anc=__html_get_anchor_info(st,html,next_tag);
    if (anc != NULL) {
      theaddata->ColSpan=anc->colspan;
      theaddata->RowSpan=anc->rowspan;
      theaddata->background=strdup(anc->src);
      if (anc->maxlength != (unsigned int) -1)
          theaddata->bgcol=anc->maxlength;
      if (anc->cols & 0x80000000)
      {
          theaddata->width = anc->cols & 0x3fffffff;
          theaddata->flags |= TDFLAG_WIDTH;
          if (anc->cols & 0x40000000)
              theaddata->flags |= UNITS_PERCENT << TDFLAG_WUNITS_SHIFT;
      }
      if (anc->rows & 0x80000000)
      {
          theaddata->height = anc->rows & 0x3fffffff;
          theaddata->flags |= TDFLAG_HEIGHT;
          if (anc->rows & 0x40000000)
              theaddata->flags |= UNITS_PERCENT << TDFLAG_HUNITS_SHIFT;
      }
      theaddata->VAlign=anc->valign;
      if (anc->alignment != _html_none)
          theaddata->Align=anc->alignment;
      /*printf("ColSpan is: 0x%x\n",theaddata->ColSpan);
      printf("RowSpan is: 0x%x\n",theaddata->RowSpan);*/
      __html_stream_free_anchor(&anc);
    }
    if (__html_current_table->stackedstyle != NULL)
    {
        __html_style_init(&st->_stream_style);
        if (tag == TagTableHead)
        {
           st->_stream_style.bold = 1;
           if (theaddata->Align==_html_none)
               st->_stream_center = 1;
        }
        /* Override here */
        if (theaddata->Align==_html_centre)
           st->_stream_center = 1;
    }
  }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_data_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableData);
}

HStream * __html_table_data_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(st); NOT_USED(next_tag); NOT_USED(url);

 skipptr(html);
 return NULL;
/*junk up to next <TD> will be added to the last <TD>*/
}

HStream * __html_table_head_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_thing_start_tag(st,next_tag,html,url,size,TagTableHead);
}

HStream * __html_table_head_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 return __html_table_data_end_tag(st,next_tag,html,url);
}

table_prev_info table_skip_current(HStream * current)
{
 __html_current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 __html_current_row=NULL;
 __html_current_headdata=NULL;
/*printf("calling table_skip_current\n");*/
 return table_skip_current_r(current);
}


table_prev_info table_skip_current_r(HStream * current)
{
  table_prev_info realcurrent;
/* printf("table is 0x%x\n",(int)__html_current_table);
   printf("row is 0x%x\n",(int)__html_current_row);
   printf("headdata is 0x%x\n",(int)__html_current_headdata);*/
 if (current == NULL)
 {
   realcurrent.prev = NULL;
   realcurrent.prevnextptr = NULL;
   return realcurrent;
 }
 realcurrent.prev = current;
 realcurrent.prevnextptr = &current->next;
 if (!(current->tag == TABLE && ISBODY(current))) return realcurrent;
 {
  table_stream * tcurrent;
  tcurrent = (table_stream *) current;
  if (tcurrent->finished) return realcurrent;
/*incomplete table, so go down to rows etc.*/
  __html_current_table=tcurrent;
  __html_current_row=tcurrent->List;
  if (__html_current_row != NULL) {
   while(__html_current_row->Next != NULL) __html_current_row=__html_current_row->Next;
  }
  __html_current_headdata=NULL;
  if (__html_current_row != NULL) __html_current_headdata=__html_current_row->List;
  if (__html_current_headdata != NULL) {
   while(__html_current_headdata->Next != NULL) __html_current_headdata=__html_current_headdata->Next;
  }
  if (__html_current_headdata != NULL)
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=(HStream * *)(&(__html_current_headdata->List));
  }
  else
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=NULL;
  }
  if (realcurrent.prevnextptr == NULL || *realcurrent.prevnextptr == NULL) return realcurrent;
  while((*realcurrent.prevnextptr)->next != NULL)
  {
    realcurrent.prev=*realcurrent.prevnextptr;
    realcurrent.prevnextptr=&((*realcurrent.prevnextptr)->next);
  }
/*printf("recursing\n");*/
  return table_skip_current_r(*realcurrent.prevnextptr);
/* __html_current_table will be NULL or relevant nested table
   __html_current_row will be NULL if no rows yet
   __html_current_headdata will be NULL if no columns yet*/
 }
}
#endif
