/***************************************************/
/* File   : HTMLTables.c                           */
/* Purpose: Parsing of Tables and other            */
/*          table related functions                */
/* Author : Tony Cheal                             */
/* History: 12-Feb-97: Created                     */
/***************************************************/
/*have to repeat this here because our header file depends on it!*/
#include "HTMLTables.h"
#include "tablestruc.h"

#ifdef TonyTables
table_stream   * __html_current_table=0; /* this is also an HStream */
table_row      * __html_current_row=0;
table_cell * __html_current_cell=0;
/*table_flag     * __html_table_stream_flag=0; */

static void skipptr(char **html)
{
char *ptr;
/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
/*
 * why the f*** wasn't this a function, and done earlier???
 * under what circumstance do you want to get the pointer stuck?
 */

 if (html != NULL) {
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) {/*printf("!%c",*ptr);*/ptr++;}
  if (*ptr=='>') ptr++;
  *html=ptr;
  /*printf("\n");*/
 }
}

/* spurious externs... */

HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,char **html, int start, char *url);
void __html_stream_free_anchor(AnchorInfo **anchor);

HStream * __html_table_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 HStream * return_val;

 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);

 return_val=__html_stream_return_tag(st,next_tag,html,0,url);

 if (return_val != NULL) {
     table_stream * treturn_val=(table_stream *) return_val;

     return_val->tag=TABLE;
     treturn_val->finished=0;
     treturn_val->List=NULL;
     treturn_val->Next=NULL; /*just in case?*/
     treturn_val->Prev=NULL;

     treturn_val->border=ATTR_VAL(BORDER);

     if (ATTR_SET(BGCOL))
         treturn_val->bgcol=ATTR_VAL(BGCOL);
     else
         treturn_val->bgcol=(unsigned int) -1;

     if (ATTR_SET(CELLPADDING))
     {
         treturn_val->cellpadding=ATTR_VAL(CELLPADDING);
         treturn_val->has_cellpadding = 1;
     }

     if (ATTR_SET(COLS))
     {
         treturn_val->cols = ATTR_VAL(COLS);
         treturn_val->has_cols = 1;
     }

     switch (ATTR_VAL(ALIGN))
     {
         case 1: treturn_val->Align = _html_left; break;
         case 2: treturn_val->Align = _html_centre; break;
         case 3: treturn_val->Align = _html_right; break;
         default:treturn_val->Align = _html_none; break;
     }

     if (ATTR_SET(WIDTH))
     {
         treturn_val->width     = ATTR_VAL(WIDTH);
         treturn_val->has_width = 1;
         treturn_val->width_units = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
     }

     /* Stack away style information */
     treturn_val->stackedstyle = (styleinfo *) __html_malloc(sizeof(styleinfo), 1);
     if (treturn_val->stackedstyle)
        *treturn_val->stackedstyle = st->_stream_style;

     treturn_val->awaiting_tr = 1;
 }

/*should set the style stuff?*/
 return return_val;
}

HStream * __html_table_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag); NOT_USED(url);

/*printf("table_table_end_tag 0x%x",(int) __html_current_table);*/
 if (__html_current_table != NULL)
 {
     __html_current_table->finished=-1;
     if (__html_current_table->stackedstyle)
     {
         st->_stream_style = *__html_current_table->stackedstyle;
         __html_free(__html_current_table->stackedstyle, 0);
         __html_current_table->stackedstyle = 0;
     }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 NOT_USED(size);
 NOT_USED(url);
 NOT_USED(next_tag);

 if (__html_current_table != NULL) {
  table_row * trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
  if (trow != NULL)
  {
    __html_current_table->awaiting_tr = 0;

    if (__html_current_row != NULL)
    {
      trow->Prev=__html_current_row;
      __html_current_row->Next=trow;
    }
    else
      __html_current_table->List=trow;

    trow->parent = __html_current_table;

    switch (ATTR_VAL(ALIGN))
    {
        case 1: trow->align = _html_left; break;
        case 2: trow->align = _html_centre; break;
        case 3: trow->align = _html_right; break;
        /*case 4: trow->align = _html_justify; break;*/
        default:trow->align=__html_current_table->Align; break;
    }

    switch (ATTR_VAL(VALIGN))
    {
        case 1: trow->valign = _html_top; break;
        case 2: trow->valign = _html_middle; break;
        case 3: trow->valign = _html_bottom; break;
        default:trow->valign = _html_none; break;
    }

    if (ATTR_SET(BGCOL))
        trow->bgcol = ATTR_VAL(BGCOL);
    else
        trow->bgcol=__html_current_table->bgcol;

   }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_row_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(next_tag);
 NOT_USED(url);
 NOT_USED(st);

 if (__html_current_table)
     __html_current_table->awaiting_tr = 1;
 skipptr(html);
 return NULL;
/*junk up to the next <TR> will be added to the last <TR><TD>*/
}

static HStream * table_cell_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size,int tag)
{
 NOT_USED(url);
 NOT_USED(size);
 NOT_USED(next_tag);

 if (__html_current_table != NULL) {
  table_cell * tcell=(table_cell *)__html_malloc(sizeof(table_cell)+1,1);
  /* Deal with tables missing a <TR> */
  if (__html_current_table->awaiting_tr) {
   table_row *trow=(table_row *)__html_malloc(sizeof(table_row)+1,1);
   if (trow != NULL)
   {
     __html_current_table->awaiting_tr = 0;
     if (__html_current_row != NULL)
     {
       trow->Prev=__html_current_row;
       __html_current_row->Next=trow;
     }
     else
       __html_current_table->List=trow;

     trow->parent=__html_current_table;

     trow->bgcol=__html_current_table->bgcol;
     trow->align=__html_current_table->Align;

     __html_current_row = trow;
     __html_current_cell = NULL;
   }
  }
  if (__html_current_row != NULL && tcell != NULL)
  {
    if (__html_current_cell != NULL)
    {
      __html_current_cell->Next=tcell;
      tcell->Prev=__html_current_cell;
    }
    else
      __html_current_row->List=tcell;
    tcell->Tag=tag;

    tcell->ColSpan=ATTR_VAL(COLSPAN);
    tcell->RowSpan=ATTR_VAL(ROWSPAN);
    tcell->background=ATTR_STR(BACKGROUND);
    if (ATTR_SET(BGCOL))
        tcell->bgcol=ATTR_VAL(BGCOL);
    else
        tcell->bgcol=__html_current_row->bgcol;
    if (ATTR_SET(WIDTH))
    {
        tcell->width = ATTR_VAL(WIDTH);
        tcell->width = st->curattrs[WIDTH].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_width = 1;
    }
    if (ATTR_SET(HEIGHT))
    {
        tcell->height = ATTR_VAL(HEIGHT);
        tcell->height = st->curattrs[HEIGHT].miscflag ? UNITS_PERCENT : UNITS_PIXELS;
        tcell->has_height = 1;
    }
    if (ATTR_SET(NOWRAP))
        tcell->nowrap = 1;

    switch (ATTR_VAL(VALIGN))
    {
        case 1: tcell->VAlign = _html_top; break;
        case 2: tcell->VAlign = _html_middle; break;
        case 3: tcell->VAlign = _html_bottom; break;
        default:tcell->VAlign = __html_current_row->valign; break;
    }

    switch (ATTR_VAL(ALIGN))
    {
        case 1: tcell->Align = _html_left; break;
        case 2: tcell->Align = _html_centre; break;
        case 3: tcell->Align = _html_right; break;
        default:tcell->Align = __html_current_row->align; break;
    }

    if (__html_current_table->stackedstyle != NULL)
    {
        __html_style_init(&st->_stream_style);
        if (tag == TagTableHead)
        {
           st->_stream_style.bold = 1;
           if (tcell->Align==_html_none)
               st->_stream_center = 1;
        }
        /* Override here */
        if (tcell->Align==_html_centre)
           st->_stream_center = 1;
    }
  }
 }
 skipptr(html);
 return NULL;
}

HStream * __html_table_data_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableData);
}

HStream * __html_table_data_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 NOT_USED(st); NOT_USED(next_tag); NOT_USED(url);

 skipptr(html);
 return NULL;
/*junk up to next <TD> will be added to the last <TD>*/
}

HStream * __html_table_head_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
 return table_cell_start_tag(st,next_tag,html,url,size,TagTableHead);
}

HStream * __html_table_head_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url)
{
 return __html_table_data_end_tag(st,next_tag,html,url);
}

table_prev_info table_skip_current(HStream * current)
{
 __html_current_table=NULL; /*to stop inadvertant <TR><TD> causing trouble*/
 __html_current_row=NULL;
 __html_current_cell=NULL;
/*printf("calling table_skip_current\n");*/
 return table_skip_current_r(current);
}


table_prev_info table_skip_current_r(HStream * current)
{
  table_prev_info realcurrent;
/* printf("table is 0x%x\n",(int)__html_current_table);
   printf("row is 0x%x\n",(int)__html_current_row);
   printf("cell is 0x%x\n",(int)__html_current_cell);*/
 if (current == NULL)
 {
   realcurrent.prev = NULL;
   realcurrent.prevnextptr = NULL;
   return realcurrent;
 }
 realcurrent.prev = current;
 realcurrent.prevnextptr = &current->next;
 if (!(current->tag == TABLE && ISBODY(current))) return realcurrent;
 {
  table_stream * tcurrent;
  tcurrent = (table_stream *) current;
  if (tcurrent->finished) return realcurrent;
/*incomplete table, so go down to rows etc.*/
  __html_current_table=tcurrent;
  __html_current_row=tcurrent->List;
  if (__html_current_row != NULL) {
   while(__html_current_row->Next != NULL) __html_current_row=__html_current_row->Next;
  }
  __html_current_cell=NULL;
  if (__html_current_row != NULL) __html_current_cell=__html_current_row->List;
  if (__html_current_cell != NULL) {
   while(__html_current_cell->Next != NULL) __html_current_cell=__html_current_cell->Next;
  }
  if (__html_current_cell != NULL)
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=(HStream * *)(&(__html_current_cell->List));
  }
  else
  {
    realcurrent.prev=NULL;
    realcurrent.prevnextptr=NULL;
  }
  if (realcurrent.prevnextptr == NULL || *realcurrent.prevnextptr == NULL) return realcurrent;
  while((*realcurrent.prevnextptr)->next != NULL)
  {
    realcurrent.prev=*realcurrent.prevnextptr;
    realcurrent.prevnextptr=&((*realcurrent.prevnextptr)->next);
  }
/*printf("recursing\n");*/
  return table_skip_current_r(*realcurrent.prevnextptr);
/* __html_current_table will be NULL or relevant nested table
   __html_current_row will be NULL if no rows yet
   __html_current_cell will be NULL if no columns yet*/
 }
}
#endif
