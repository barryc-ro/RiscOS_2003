#include "html2_ext.h"
#include "tags.h"
#include "struct.h"
#include "string.h"
#include "internal.h"
#include "stdio.h"

#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace);
#else
char * __html_strip_spaces(char *input, int stripleadingcr);
#endif
char * __html_strip_lfs(char *input);
char * __html_tidy_url(char *url);
int __html_unnumeric_escape(char ch);
static char __html_iso_lat_1_to_char(char * *sequencep);
static char __html_number_to_char(char **sequencep);


/********************************************************************/
/* char *__html_strip_spaces(char *input, int stripleadingcr)       */
/********************************************************************/
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
/********************************************************************/
#ifdef NEWSPACING
int __html_strip_spaces(char *input, int stripleadingspace, int striptrailingspace)
#else
char *__html_strip_spaces(char *input, int stripleadingcr)
#endif
{
char *s,*ptr;
#ifdef NEWSPACING
int strippedtrailingspaces=0;
int lastisspace=0;
#endif

/*
 * Avoid muck situation we know about
 */
#ifdef NEWSPACING
  if ((input==NULL) || (*input=='\0')) return stripleadingspace;
#else
  if ((input==NULL) || (*input=='\0')) return input;
#endif

  ptr=s=input;
#ifdef DEBUG
  Printf("Stripping spaces:\n");
  Printf("Input : '%s'\n",input);
#endif

#ifdef NEWSPACING
  /*
   * Strip all leading whitespace if necessary (ie if after start tag)
   */
  if (stripleadingspace)
  {
    while (isspace(*input))
       input++;
  }
#else
/*
 * First off, if the input sequence starts with chars that are
 * under 32 (a space), e.g. new lines, jump over these straigt off
 * to make the output look a bit better!
 */
if (stripleadingcr)
{
  while ((*input > 0) && (*input < 32)) input++;
  if (*input==0) {
    *ptr='\0';
    return ptr;
  }
}
#endif


/* Turn all initial spaces into a single space */
  while (isspace(*input) && isspace(*(input+1))) input++;

/*
 * Now loop down the string stripping out any non-ascii chars
 * and turn them into spaces.
 */
  while (*input != '\0') {
    if (*input <= 32) {
      while ((*input <= 32) && (*input != '\0')) {
/* Step over all chars less than or a space */
	input++;
/* Replace them with a single space */
/*
        *s=' ';
        s++;
*/
      }
      *s=' ';
      s++;
    }

/* At this point we know that *input is not a space so we can snarf it */
    *s=*input;
    if (*s != '\0') {
      s++;
      input++;
    }
  }

  *s='\0';

#ifdef NEWSPACING
  if (striptrailingspace)
  {
    if (s > ptr && isspace(*(s-1)))
    {
      strippedtrailingspaces=1;
      *--s='\0';
    }
  }
  else
  {
    if (s > ptr && isspace(*(s-1)))
    {
      lastisspace=1;
    }
    else if (s == ptr)
      lastisspace=stripleadingspace;
  }
#endif

#ifdef DEBUG
  Printf("Output: '%s'\n", ptr);
#endif

/* And return */
#ifdef NEWSPACING
  return lastisspace;
#else
  return ptr;
#endif
}

void __html_strip_trailing_spaces(char *input)
{
    char *p=input+strlen(input)-1;

    while (p >= input && isspace(*p))
        *p--='\0';
}

/********************************************************************/
/* char *__html_strip_lfs(char *input)                              */
/********************************************************************/
/* This function removes all instances LF in the input stream to    */
/* enable the front end to only have to deal with CRs  	      	    */
/********************************************************************/
#define CR '\r'
#define LF '\n'
char *__html_strip_lfs(char *input)
{
char *s1=input, *s2=input, c;

  if(!input || !*input) return input;

  while ((c=*s1) != '\0') {
/* Are we pointing at a CR */
    switch (c)
    {
      case CR:
        if (*(s1+1)==LF)         /* Turn CRLF into LF */
        {
            *s2=LF;
            s1++;
        }
        else
        {
            *s2=LF;              /* Turn CR into LF */
        }
        break;
      /* Deal with tabs - this should pad to 8 chars */
      case '\t':
        *s2=' ';
        break;
      default:
        *s2=*s1;
        break;
    }
    s1++;
    s2++;
  }
/* Ensure we terminate s2 */
  *s2='\0';

/* Return the string */
  return input;
}

/********************************************************************/
/* char *strdup(char *s1)                                           */
/********************************************************************/
/* strdup stand for "STRing DUPlicate". Go figure :) This returns a */
/* copy of s1 on success or a NULL pointer on failure               */
/********************************************************************/

char * strdup(const char * s1)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(strlen(s1) + 1, 1);

  if (s2 == NULL) return NULL;

  return strcpy(s2, s1);
}

/********************************************************************/
/* char *strndup(char *s1, int size)                                */
/********************************************************************/
/* Same as strdup except that the amount of bytes to copy is known  */
/********************************************************************/

char * strndup(const char * s1, int size)
{
  char * s2;

  if (s1 == NULL) return NULL;

  s2 = (char *) __html_malloc(size + 1, sizeof(char)); /* +1 to be safe? */

  if (s2 == NULL) return NULL;

  return (char *) memcpy(s2, s1, size);
}

/********************************************************************/
/* static void __html_unescape(char *sequence)                      */
/********************************************************************/
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
/********************************************************************/

static void __html_unescape(char *sequence)
{
  char *ptr=sequence;
  char c, result;
  char *end;

  while (isalnum(*sequence) || *sequence=='#' || *sequence=='&') {
    sequence++;
  }

  c=*sequence; *sequence='\0';

  if (*(ptr+1) == '#') { /* Decimal numeric escape */
    end = ptr + 2;
    result=__html_number_to_char(&end);
    /* Turn TABs into spaces (it'll do for now) */
    if (result == 9) result = 32;
    if (result < 32 || result == 127)
        result = 0;
  }
  else {
    end = ptr+1;
    result=__html_iso_lat_1_to_char(&end);
  }

  if (result == 0)
  {
    *sequence=c;
    return;             /* We don't recognise it as a valid thingy, so exit */
  }
  else
    *ptr = result;

  *sequence=c;

  sequence = end;
  if (*sequence==';')
    sequence++;

  ptr++;

  while (*sequence != '\0') {
    *ptr=*sequence;
    ptr++;
    sequence++;
  }
  *ptr='\0';
}

/********************************************************************/
/* static int __html_unhex(char ch)                                 */
/********************************************************************/
/* Given a single char return its integer value as if it were a hex */
/* digit.                                                           */
/********************************************************************/

int __html_unnumeric_escape(char ch)
{
    if ((ch >= '0') && (ch <= '9')) return ((int)ch-'0'); /* 0 to 9 */
    if ((ch >= 'A') && (ch <= 'F')) return ((int)ch-'A'+10); /* 10 to 15 */
    return 0;
}

static int iso10646cmp(const void *a, const void *b)
{
    unsigned int key = (unsigned int) a;
    wchar_t *wc = (wchar_t *) b;

    return key - *wc;
}

/********************************************************************/
/* char __html_iso10646_to_latin1(unsigned long ch)                 */
/********************************************************************/
/* Given an ISO 10646 code (or a Microsoft code if in the range     */
/* 128-159), spit out the Acorn Extended Latin-1 equivalent         */
/* escape code, convert this to a single Risc OS char               */
/********************************************************************/
static char __html_iso10646_to_latin1(unsigned long ch)
{
  typedef struct
  {
    wchar_t num;
    char acornlatin1;
  }
  CharEnt;

  /*
   * This table contains transformations from ISO10646 to Acorn
   * Extended Latin-1, and from Microsoft code page 1252.
   *
   * We don't have proper charset support yet, so we assume:
   *   1) The library output will be displayed using an
   *      Acorn Extended Latin-1 font.
   *   2) Hence codes 32-126 and 160-255 are the same as
   *      ISO10646 and CP1252.
   *   3) The input document is encoded using CP1252.
   *   4) Numbered entities that are (erroneously) in the range
   *      128-159 are supposed to be CP1252.
   *   5) De facto standards suck.
   */
  static const CharEnt char_table[] =
  {
        130, ',',  /* Single low-9 quotation mark (U+201A) */
        131, 'f',  /* Latin small letter f with hook (U+0192) */
        132, '–',  /* Double low-9 quotation mark (U+201E) */
        133, 'Œ',  /* Horizontal ellipsis (U+2026) */
        134, 'œ',  /* Dagger (U+2020) */
        135, '',  /* Double dagger (U+2021) */
        136, '^',  /* Modifier letter circumflex accent (U+02C6) */
        137, 'Ž',  /* Per mille sign (U+2030) */
        138, 'S',  /* Latin capital letter S with caron (U+0160) */
        139, '’',  /* Single left-pointing angle quotation mark (U+2039) */
        140, 'š',  /* Latin capital ligature OE (U+0152) */
        145, '',  /* Left single quotation mark (U+2018) */
        146, '‘',  /* Right single quotation mark (U+2019) */
        147, '”',  /* Left double quotation mark (U+201C) */
        148, '•',  /* Right double quotation mark (U+201D) */
        149, '',  /* Bullet (U+2022) */
        150, '—',  /* En dash (U+2013) */
        151, '˜',  /* Em dash (U+2014) */
        152, '~',  /* Small tilde (U+02DC) */
        153, '',  /* Trade mark sign (U+2122) */
        154, 's',  /* Latin small letter s with caron (U+0161) */
        155, '“',  /* Single right pointing angle quotation mark (U+203A) */
        156, '›',  /* Latin small ligature oe (U+0153) */
        159, 'Y',  /* Latin capital letter Y with diaresis (U+0178) */
     0x0152, 'š',  /* Latin capital ligature OE */
     0x0153, '›',  /* Latin small ligature oe */
     0x0160, 'S',  /* Latin capital letter S with caron */
     0x0161, 's',  /* Latin small letter s with caron */
     0x0174, '',  /* Latin capital letter W with circumflex */
     0x0175, '‚',  /* Latin small letter w with circumflex */
     0x0176, '…',  /* Latin capital letter Y with circumflex */
     0x0177, '†',  /* Latin small letter y with circumflex */
     0x0178, 'Y',  /* Latin capital letter Y with diaresis */
     0x0192, 'f',  /* Latin small letter f with hook */
     0x02C6, '^',  /* Modifier letter circumflex accent */
     0x02DC, '~',  /* Small tilde */
     0x2013, '—',  /* En dash */
     0x2014, '˜',  /* Em dash */
     0x2018, '',  /* Left single quotation mark */
     0x2019, '‘',  /* Right single quotation mark */
     0x201A, ',',  /* Single low-9 quotation mark */
     0x201C, '”',  /* Left double quotation mark */
     0x201D, '•',  /* Right double quotation mark */
     0x201E, '–',  /* Double low-9 quotation mark */
     0x2020, 'œ',  /* Dagger */
     0x2021, '',  /* Double dagger */
     0x2022, '',  /* Bullet */
     0x2026, 'Œ',  /* Horizontal ellipsis */
     0x2030, 'Ž',  /* Per mille sign */
     0x2039, '’',  /* Single left-pointing angle quotation mark */
     0x203A, '“',  /* Single right pointing angle quotation mark */
     0x2122, '',  /* Trade mark sign */
     0x2212, '™',  /* Minus sign */
     0xFB01, 'ž',  /* Latin small ligature fi */
     0xFB02, 'Ÿ',  /* Latin small ligature fl */
  };

  CharEnt *cent = bsearch((const void *) ch,
                          char_table,
                          (sizeof char_table) / (sizeof char_table[0]),
                          sizeof char_table[0],
                          iso10646cmp);

  return cent                                 ? cent->acornlatin1 :
         (ch < 127 || (ch >= 160 && ch < 256) ? (char) ch :
         '?');
}

/********************************************************************/
/* char __html_hex_to_char(char *sequence)                          */
/********************************************************************/
/* Given a char sequence that is known to be an ISO-LATIN-1 hex     */
/* escape code, convert this to a single Risc OS char               */
/********************************************************************/

static char __html_number_to_char(char **sequencep)
{
  unsigned long ch=0;

 /* We know that sequence is 0 terminated */
  if (**sequencep == 'x' || **sequencep == 'X')
      ch = strtoul(*sequencep + 1, NULL, 16);
  else
      ch = strtoul(*sequencep, NULL, 10);
  *sequencep += strlen(*sequencep);

  return __html_iso10646_to_latin1(ch);
}

/* This relies on no known entity being a truncation of another one! */
static int entcmp(const void *a, const void *b)
{
    return strncmp((const char *) a, (const char *) b, strlen((const char *) b));
}

/********************************************************************/
/* char __html_iso_lat_1_to_char(const char * sequence)             */
/********************************************************************/
/* Given a ';' or ' ' space terminated sequence of chars (including */
/* the '&', this routine will return the correct (hopefully)        */
/* ISO-LATIN-1 char for that sequence. The string passed in         */
/* sequence is returned in the modified form.                       */
/********************************************************************/

static char __html_iso_lat_1_to_char(char ** sequencep)
{
  typedef struct
  {
    char name[7], code;
  }
  CharEnt;

  char *sequence = *sequencep;

  /* This table comes from ISO 8879, except where commented */

  static const CharEnt char_table[] =
  {
    "AElig",  198,
    "Aacute", 193,
    "Acirc",  194,
    "Agrave", 192,
    "Aring",  197,
    "Atilde", 195,
    "Auml",   196,
    "Ccedil", 199,
    "Dagger", 157, /* Cougar */
    "ETH",    208,
    "Eacute", 201,
    "Ecirc",  202,
    "Egrave", 200,
    "Euml",   203,
    "Iacute", 205,
    "Icirc",  206,
    "Igrave", 204,
    "Iuml",   207,
    "Ntilde", 209,
    "OElig",  154, /* Cougar */
    "Oacute", 211,
    "Ocirc",  212,
    "Ograve", 210,
    "Oslash", 216,
    "Otilde", 213,
    "Ouml",   214,
    "THORN",  222,
    "Uacute", 218,
    "Ucirc",  219,
    "Ugrave", 217,
    "Uuml",   220,
    "Wcirc",  129, /* Invented */
    "Yacute", 221,
    "Ycirc",  133, /* Invented */
    "aacute", 225,
    "acirc",  226,
    "acute",  180,
    "aelig",  230,
    "agrave", 224,
    "amp",    38,  /* HTML */
    "aring",  229,
    "atilde", 227,
    "auml",   228,
    "bdquo",  150, /* Cougar */
    "bull",   143, /* Cougar */
    "brvbar", 166, /* HTML 3.2 */
    "ccedil", 231,
    "cedil",  184, /* HTML 3.2 */
    "cent",   162, /* HTML 3.2 */
    "copy",   169, /* HTML */
    "curren", 164, /* HTML 3.2 */
    "dagger", 156, /* Cougar */
    "deg",    176, /* HTML 3.2 */
    "divide", 247, /* Cougar */
    "eacute", 233,
    "ecirc",  234,
    "egrave", 232,
    "eth",    240,
    "euml",   235,
    "frac12", 189, /* HTML 3.2 */
    "frac14", 188, /* HTML 3.2 */
    "frac34", 190, /* HTML 3.2 */
    "gt",     62,  /* HTML */
    "iacute", 237,
    "icirc",  238,
    "iexcl",  161, /* HTML 3.2 */
    "igrave", 236,
    "iquest", 191, /* HTML 3.2 */
    "iuml",   239,
    "laquo",  171, /* HTML 3.2 */
    "ldquo",  148, /* Cougar */
    "lsaquo", 146, /* Cougar */
    "lsquo",  144, /* Cougar */
    "lt",     60,  /* HTML */
    "macr",   175, /* HTML 3.2 */
    "mdash",  152, /* Cougar */
    "micro",  181, /* HTML 3.2 */
    "middot", 183, /* HTML 3.2 */
    "minus",  153, /* Cougar */
    "nbsp",   160, /* HTML */
    "ndash",  151, /* Cougar */
    "not",    172, /* HTML 3.2 */
    "ntilde", 241,
    "oacute", 243,
    "ocirc",  244,
    "oelig",  155, /* Cougar */
    "ograve", 242,
    "ordf",   170, /* HTML 3.2 */
    "ordm",   186, /* HTML 3.2 */
    "oslash", 248,
    "otilde", 245,
    "ouml",   246,
    "para",   182, /* HTML 3.2 */
    "permil", 142, /* Cougar */
    "plusmn", 177, /* HTML 3.2 */
    "pound",  163, /* HTML 3.2 */
    "quot",   34,  /* HTML */
    "raquo",  187, /* HTML 3.2 */
    "rdquo",  149, /* Cougar */
    "reg",    174, /* HTML */
    "rsaquo", 147, /* Cougar */
    "rsquo",  145, /* Cougar */
    "sect",   167, /* HTML 3.2 */
    "shy",    173, /* HTML 3.2 */
    "sup2",   178, /* HTML 3.2 */
    "sup3",   179, /* HTML 3.2 */
    "supl",   185, /* HTML 3.2 */
    "szlig",  223,
    "thorn",  254,
    "times",  215, /* Cougar */
    "uacute", 250,
    "ucirc",  251,
    "ugrave", 249,
    "uml",    168, /* HTML 3.2 */
    "uuml",   252,
    "wcirc",  130, /* Invented */
    "yacute", 253,
    "ycirc",  134, /* Invented */
    "yen",    165, /* HTML 3.2 */
    "yuml",   255,
  };

  const CharEnt * found;
  char            temp[7];
  int             i;

  for (
        i = 0;

        sequence[i] != '\0' &&
        sequence[i] != ' '  &&
        sequence[i] != ';'  &&
        i < 7;

        i++
      )
      temp[i] = sequence[i];

  temp[i] = '\0';

  found = bsearch(temp,
                  char_table,
                  (sizeof char_table) / (sizeof char_table[0]),
                  sizeof char_table[0],
                  entcmp);

  if (found)
  {
      *sequencep = sequence + strlen(found->name);
      return found->code;
  }
  else       return 0;
}

/********************************************************************/
/* char *__html_unescape_string(char *input)                        */
/********************************************************************/
/* This function removes all instances of multiple whitespace and   */
/* replaces them with a single space. Thus CR, LF CTRL-... are      */
/* replaced by a space                                              */
/********************************************************************/

char *__html_unescape_string(char * input)
{
  char * ret = input;

  while (*input != '\0')
  {
    if (*input == '&')
        __html_unescape(input);
    else if (*input >= 128 && *input < 160)
        *input = __html_iso10646_to_latin1(*input);
    input++;
  }
  return ret;
}

/********************************************************************/
/* char *__html_tidy_url(char *url)                                 */
/********************************************************************/
/* Given a URL, this routine will attempt to tidy up all occurances */
/* of ".." and remove the relevant parts of the directory tree      */
/********************************************************************/

#define UPDIR "/../"

char * __html_tidy_url(char * url)
{
  char * s1;
  char * s2;
  char * s3;

  if (!url || !*url) return NULL;

  /* Check for stupid case of link ending in "/.." */

  if (
       strlen(url) >= 3                          &&
       strcmp(url + strlen(url) - 3, "/..") == 0
     )
     strcat(url, "/");

  /* While we still have "/.."s in the input stream */

  while ((s1=strstr(url,UPDIR)) != NULL)
  {
    /* Locate the start of the previous directory */

    *s1 = 0;
    s2  = strrchr(url, '/');
    s3  = strrchr(url, ':');

    s2  = s2 > s3 ? s2 : s3;
    *s1 = '/';

    if (s2 == NULL) return url;

    /* If s2[-1] = '/' we're at '//', as in 'http://'. So don't */
    /* want to strip out the site name, but do need to remove   */
    /* the '/../' from the end.                                 */
    /*                                                          */
    /* This is for the case where there are too many '/../'s in */
    /* a relative URL (which happens quite often, it seems!).   */

    if (s2[-1] == '/') s2 = s1;

    /* Skip over the UPDIR bit */

    s1 += sizeof(UPDIR) - 1;

    /* Blat the remainder of the string onto what we have */

    s2++;
    memmove(s2, s1, strlen(s1) + 1);

    /* Repeat as required! */
  }

  return url;
}

/********************************************************************/
/* char *__html_strip_control_codes(char *s)                        */
/********************************************************************/
/* Strip out all control codes (c>0 & c< 32 && c!=10 && c!=13)      */
/********************************************************************/
void __html_strip_control_codes(char *s)
{
    while (*s)
    {
        if (CTRL_CODE(*s) && *s!='\t')
            *s='?';

        s++;
    }
}

/*************************************************************/
/* char *strincmp(char *sting, char *index, int size)        */
/*************************************************************/
/* Given two strings, look case insensitivly to establish if */
/* the first "size" chars in "string" are "index"	     */
/*************************************************************/
int strincmp(const char *string, const char *index, int size)
{
int d=0;

  while (size-- > 0) {
    d = toupper(*string++) - toupper(*index++);
    if (d != 0) return d;
    if (*string == 0) return 0;     /* no need to check c2 */
    }
  return 0;
}

/*************************************************************/
/* char *strnstr(char *sting, char *index, int size          */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strnstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (count+i > size) return 0;
      if (ch == 0) return (char *)string;
      if (string[i] != ch) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

/*************************************************************/
/* char *strinstr(char *sting, char *index, int size         */
/*************************************************************/
/* Given a pointer to a string, and the size of the string,  */
/* look to see if we can find the index char requested.      */
/*************************************************************/
char *strinstr(const char *string, const char *index, int size)
{
int i;
int count=0;

  while(1) {
    for (i=0;; i++) {
      char ch = index[i];
      if (ch == 0) return (char *)string;
      if (count+i >= size) return 0;
      if (toupper(string[i]) != toupper(ch)) break;
    }
    count++;
    if (count > size) return 0;
    if (*string++ == 0) return 0;
  }
}

