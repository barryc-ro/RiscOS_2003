#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include <ctype.h>
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

/******************************************************************************/
/* This comment is 80 chars wide. It was used to format this file.            */
/******************************************************************************/

/********************************************************************/
/* Predefinition of static functions contained in this file, along  */
/* along with the main parse function predifinition.   	     	    */
/********************************************************************/
static unsigned int __html_stream_style(StreamTokens *st);
static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start);
static unsigned int __html_stream_indent(StreamTokens *st);
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag *next_tag,
                              char **html,char *url, int size);
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag *next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_image(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_hr(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_anchor(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_frame(StreamTokens *st, char **html,
                              Tag *next_tag, int size);
static    HStream * __html_stream_frameset(StreamTokens *st, char **html,
                              Tag *next_tag, int size);
static    HStream * __html_stream_base(StreamTokens *st);
static        void  __html_stream_end_anchor(StreamTokens *st);
#if 0
static    HStream * __html_stream_end_header(char **html);
#endif
static    HStream * __html_form_handler(StreamTokens *st, Tag *next_tag,
                              char **html, int size);
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,
                              char **html, int start);
static 	     char * __html_stream_grab_pcdata(char **input, int size,
                              int contig);
/*static*/   char * __html_make_anchor(char *base, char *link);
/*static*/         void __html_stream_free_anchor(AnchorInfo **anchor);
static    HStream * __html_form_parse_select(StreamTokens *, char **html,
                              int size, HStream *ret);
static    HStream * __html_stream_declaration(StreamTokens *st, char **html,
                                              int size);
static    HStream * __html_stream_comment(StreamTokens *st, char **html,
                                          int size);
static    HStream * HStreamalloc(void);
static    HStream * __html_stream_script(StreamTokens *st, char **html,
                                             int size, const char *term, int tag);
static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number);

/********************************************************************/
/* A global variable declared in this file. A byte is an unsigned   */
/* char.    	     	      	      	      	      	 	    */
/********************************************************************/
byte __html_done_for_now=0;

/********************************************************************/
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

/********************************************************************/
/* A small macro. Set a parser internal flag for some exit states.  */
/* This permits on the fly HTML parsing to work correctly. 	    */
/********************************************************************/
#define RETURN(x) {__html_done_for_now=1; return x;}

/********************************************************************/
/* HStream *__html_stream_parse(StreamTokens *st, char **html, .... */
/********************************************************************/
/* The main parse routine. This does one of three things:           */
/*     + Grabs the next bit of text on the input stream		    */
/*     + interprets the top HTML tag on the input stream	    */
/*     + nothing because there is insufficient input (on the fly    */
/*          parsing needs this).  	       	     	     	    */
/*	    	    	  					    */
/* In the first two cases the input pointer is updated to where we  */
/* got to, in the last case, __html_done_for_now is set and the     */
/* input pointer is not moved. 			    	    	    */
/********************************************************************/
HStream *__html_stream_parse(StreamTokens *st, char **html, char *url,
                              int size, HStream *prevhs)
{
  HStream *return_val=NULL;
  Tag     *next_tag;
  char    *ptr;
  char 	  *tag_start;
  char 	  *start;
  int     lastwaspcdata=st->lastwaspcdata;

/* Reset the bail out pointer */
  __html_done_for_now=0;

/* Look to make sure we have a valid input pointer. Order is important here */
  if (!html || !*html || !**html) RETURN(NULL);

  switch (st->state)
  {
    case Declaration:
      return __html_stream_declaration(st, html, size);
    case Comment:
      return __html_stream_comment(st, html, size);
      /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
    case Script:
      return __html_stream_script(st, html, size, "</SCRIPT", SCRIPT);
    case Style:
      return __html_stream_script(st, html, size, "</STYLE", STYLE);
    /* Fall through if other */
  }

/* In some cases a '>' is left at the beginning of the input stream. Ignore it */
  if (**html == '>') {
/* If we ignore it, update the input pointer and the size */
    *html = *html+1;
    size--;
/* If we now have nothing left, return */
    if ((size==0) || (!**html)) RETURN((HStream *)NULL);
/* Always keep ptr in sync with HTML */
  }

  ptr=*html;
  tag_start=*html+1;
  start=*html;

/*
 * The first case. We dont have a '<' as the top of the input stream
 * and we are not inside a comment, so grab up to the next tag or the
 * end of the input stream, whichever is the sooner, and return it as
 * a text segment (PCDATA).
 */
  if (*ptr != '<') {

/* This avoids a few funnies. Cant remember why but it is needed */
    if (**html == '>') {
      *html=(*html)+sizeof(char);
      size --;
    }

/* Create the structure to return. If non-NULL fill it in */
    return_val=HStreamalloc();
    if (return_val != NULL) {
/* Grab the text, and set the style word in the structure */
      return_val->text=__html_stream_grab_pcdata(html, size, 0);
      return_val->style=__html_stream_style(st) | PCDATA ;
/*
 * If the text is PREformatted or in a textarea in a form we dont want
 * to strip out the LFs, but we do need to unescape it
 */
      if (((return_val->style & PRE) == PRE ) ||
      	   ((return_val->style & TEXTAREA) == TEXTAREA)) {
        __html_strip_lfs(return_val->text); /* Strip CRs, preserve LFs */
        __html_unescape_string(return_val->text);
      } else {
/*
 * Otherwise it is true PCDATA so we need to munge spaces, CRs, LFs, and
 * unescape escape sequences in the data
 */
#ifdef NEWSPACING
        st->stripleadingspace = __html_strip_spaces(return_val->text, st->stripleadingspace, 0);
        st->lastwaspcdata = 1;
#else
        __html_strip_spaces(return_val->text, st->stripleadingcr);
#endif
        __html_unescape_string(return_val->text);
      }

/*
 * Now evaluate the type word. We need this to decide what to do if there
 * is a NULL input string left at this point.
 */
      return_val->type=__html_stream_type(st, TYPE_BODY, START);

      /*if (return_val->style & DL)
         Printf("HTMLLib: Got a DL\n");*/
/* Look to see if we have a zero length return string */
      if (*(return_val->text) == '\0') {
/*
 * If the tag is not a special once-only tag,
 * dump the tag to save memory in the
 * final stream returned.
 */
      if (!(return_val->style & (P|BR|DL|OL|UL))) {
/*
 * We only need to free the text and the structure since we havent filled
 * in any other bits, so this is faster than calling the free routine. And
 * return a NULL pointer because we dont need to do anything. 'html' has
 * already been moved at this point, so this is safe.
 */
          __html_free(return_val->text,0);
          __html_free(return_val,0);
          /*if (return_val->style & DL)
            Printf("HTMLLib: Junked a DL :-(\n");*/
          return NULL;
        }
        else {
/* Otherwise just free up the text and set the text pointer to a NULL */
          __html_free(return_val->text,0);
          return_val->text=NULL;
          /*if (return_val->style & DL)
            Printf("HTMLLib: Cleared a DL\n");*/
        }
      }

/* Calculate the list indent count */
      return_val->indent=__html_stream_indent(st);

/* If this tag has anchor information associated with it, extract it */
      if (st->_stream_anchor != NULL) {
        return_val->anchor=st->_stream_anchor->href;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        return_val->name=st->_stream_anchor->name;
        st->need_to_send_name=0;
        return_val->target = st->_stream_anchor->target;
      }

/* Fill in colour information */
      fill_in_colour_info(st, return_val);

/* Set the rest of the values up as a TEXT token */
      return_val->tag=PCDATA;
      st->needtosend=0;
      #ifdef NEWSPACING
      /*st->stripleadingspace=0;*/
      #else
      st->stripleadingcr=0;
      #endif
    }

  #ifdef TRACE
  {
      FILE *fp=fopen("ADFS::4.$.Trace.ParseTrc", "a");
      if (fp)
      {
          fputs(return_val->text, fp);
          fclose(fp);
      }
  }
  #endif
/*
 * Return the structure. Note that if there was insufficient memory to
 * allocate a tag, this will return a NULL pointer, so this is safe.
 */
    //if (return_val->style & DL) Printf("HTMLLib: returned a DL\n");

    return return_val;
  }

  if (size < 2)
      RETURN(NULL);

  /* Stop doing any titleness */
  st->_stream_title=0;

  if (*(ptr+1) == '!')
  {
      st->state = Declaration;
      *html = ptr+2;
      return NULL;
  }

  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

/*
 * We now think we have a tag. We extract the tag information by skipping
 * the initial '<', finding the end of the tag, and inspecting the bit
 * between the start and end pointers (*html and ptr).
 */
  ptr++; /* Skip the '<' */
  while ((ptr-start < size) && (*ptr != '\0') && (*ptr != '>') &&
                             (*ptr != '<')) {
    ptr++;
  }

/* This code breaks if there happens to be a '>' in the first byte
 * after the meaningful data
 */
#if 0
/*
 * If we hit 'size' but the first element in the stream is a '<'
 * I think we have an incomplete tag, otherwise if we have moved
 * more than 'size' bytes we have run off the end of a meaningful
 * input stream.
 */
  if (ptr-start >= size) {
    if ( ((**html == '<') && (*ptr != '>')) || (ptr-start > size) ) {
      RETURN(NULL);
    }
  }
#else
  if (ptr-start >= size)
  {
      RETURN(NULL);
  }
#endif

/*
 * We are now in a safe position to believe we have a tag and that we
 * have all of the tag. Thus we can look to see what we have.
 */

  if (tag_start[0]=='/')
  {
    if (lastwaspcdata && prevhs && prevhs->text && prevhs->tag != TABLE)
    {
      __html_strip_trailing_spaces(prevhs->text);
      if (prevhs->text[0]=='\0')
      {
        __html_free(prevhs->text, 0);
        prevhs->text=0;
        prevhs->type &=~ TYPE_MASK;
        /*prevhs->type=(prevhs->type &~ (TYPE_BODY|TYPE_FRAMESET|TYPE_NOFRAMES)) | TYPE_HEAD;*/
      }
    }
  }
  else
    st->stripleadingspace=1;

  if (tag_start[0] != '/')
  {
      next_tag=__html_find_tag(&tag_start,0);

    /* The start tag case */
      if (next_tag) {
    /*
     * If the tag we have is a tag that we need to notify the termination
     * of, then send back a NULL tag that terminates all the tags we need
     * to before returning this tag. We can do this by not moving the html
     * data pointer before returning.
     */
        if ((st->needtosend & next_tag->tag) == next_tag->tag && next_tag->tag
    #ifdef TonyTables
            && !__html_current_table
    #endif
           )
        {
            /* Put in a null tag (ish) */
            return_val=__html_stream_return_tag(st, &Null_Tag, NULL, END);
            return_val->type|=TYPE_BODY;
        }
        else
        {
            char *p=*html;
    /*
     * Otherwise do what we need to with this pointer before returning
     * any token that it generates.
     */
          if (lastwaspcdata && next_tag->block_tag && prevhs && prevhs->text)
          {
            __html_strip_trailing_spaces(prevhs->text);
            if (prevhs->text[0]=='\0')
            {
              __html_free(prevhs->text, 0);
              prevhs->text=0;
            }
          }

          return_val = __html_stream_start_tag(st, next_tag, &p, url, size);
          /* More hackery - some tags swallow PCDATA - if the routine returns
             NULL, that indicates a tag that needs more PCDATA */
          if (p>ptr)
            *html=p;
          else if (p!=NULL)
            *html=ptr;
        }
        return return_val;
      }
  }
  else
  {
      st->isendtag=1;
    /* Otherwise it was an end tag? */
      next_tag=__html_find_tag(&tag_start,1);

      if (next_tag) {
    /* Register that we have an end tag */
        st->stripleadingspace=next_tag->block_tag;
        return_val = __html_stream_end_tag(st, next_tag, html, url, size);
        *html=ptr;

       return return_val;
      }
      else
        st->stripleadingspace=1;
  }

/* Update the pointer and return. This skips unwanted tags etc. */

  *html=ptr;

  return return_val;
}

/********************************************************************/
/* __html_stream_declaration                                        */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a <!  > pair   */
/********************************************************************/
static HStream *__html_stream_declaration(StreamTokens *st, char **html,
                                          int size)
{
    /*
     * Currently we don't do anything with declarations. Just need
     * to skip comments
     */
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '>')
        {
            *html = ptr + 1;
            st->state = Other;
            return NULL;
        }
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                int i;

                /* Check for a run of -s */
                for (i=2; i<size; i++)
                {
                    if (ptr[i] != '-')
                    {
                        *html = ptr+i;
                        st->state = Comment;
                        return NULL;
                    }
                }
                /* Have not reached the end of this run yet */
                *html = ptr;
                RETURN(NULL);
            }
        }
        ptr++;
        size--;
    }

    *html=ptr;
    RETURN(NULL);
}

/********************************************************************/
/* __html_stream_comment                                            */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a -- -- pair   */
/********************************************************************/
static HStream *__html_stream_comment(StreamTokens *st, char **html,
                                      int size)
{
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                int i;

                /* Check for a run of -s */
                for (i=2; i<size; i++)
                {
                    if (ptr[i] != '-')
                    {
                        *html = ptr+i;
                        st->state = Declaration;
                        return NULL;
                    }
                }
                /* Have not reached the end of this run yet */
                *html = ptr;
                RETURN(NULL);
            }
        }
        ptr++;
        size--;
    }

    *html = ptr;
    RETURN(NULL);
}

/********************************************************************/
/* static unsigned int __html_stream_style(void)                    */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_style(StreamTokens *st)
{
  unsigned int return_val=0;

  if (st->_stream_title) {
    return_val |= TITLE;
  }
  else {
    if (st->_stream_bold)	    return_val |= BOLD;
    if (st->_stream_italic)         return_val |= ITALIC;
    if (st->_stream_tt)	    	    return_val |= TT;
    if (st->_stream_a)	    	    return_val |= A;
    if (st->_stream_img)	    return_val |= IMG;
    if (st->_stream_p)	          { return_val |= P; st->_stream_p=0; }
                                    return_val |= st->_stream_h;
    if (st->_stream_pre)	    return_val |= PRE;

    if (st->send_list > 0) {
      if (st->send_list & DL) {
        if (st->_stream_dl)	    return_val |= DL;
      }
      if (st->send_list & OL) {
        if (st->_stream_ol)	    return_val |= OL;
      }
      if (st->send_list & UL) {
        if (st->_stream_ul)	    return_val |= UL;
      }
      st->send_list = 0;
    }
    /*if (st->_stream_li)	            return_val |= LI;*/
    if (st->_stream_dt)	    	    return_val |= DT;
    if (st->_stream_dd)	    	    return_val |= DD;
    if (st->_stream_br)           { return_val |= BR ; st->_stream_br=0; }
    if (st->_stream_blockquote)     return_val |= BLOCKQUOTE;
    if (st->_stream_address)        return_val |= ADDRESS;
    if (st->_stream_center)	    return_val |= CENTER;
    if (st->_stream_anchor != NULL) return_val |= A;
    if (st->_stream_form)     	    return_val |= FORM;
    if (st->_stream_select)	    return_val |= SELECT;
    if (st->_stream_textarea)	    return_val |= TEXTAREA;
    #ifdef TonyTables
    if (st->_stream_table)          return_val |= TABLE;
    #endif
  }

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_type(void)                     */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
{
  unsigned int temp=tag_type;

  if (st->_stream_title) {
    temp = TYPE_HEAD;

  } else if (st->_stream_frameset) {
    temp = TYPE_FRAMESET;
  }

  if (st->_stream_noframes) {
    temp |= TYPE_NOFRAMES;
  }

  temp |= (((unsigned int) start) << TYPE_START_SHIFT);

  if (st->_stream_colour != NULL) {
    if (st->_stream_colour->colour_valid)
      temp |= TYPE_COLOURED;
  }

  return temp;
}

/********************************************************************/
/* static unsigned int __html_stream_indent(void)                   */
/********************************************************************/
/* Given all the status variable attempt to work out the indent     */
/* level at this point in time	 	    	     	 	    */
/********************************************************************/
static unsigned int __html_stream_indent(StreamTokens *st)
{
  return ((unsigned int) st->_stream_dl -
                         st->_stream_dt +
  	 	         st->_stream_ol +
  	 	         st->_stream_ul);
}

#if 0
static char *strnchrs(char *start, const char *c, const char *end)
{
    const char *p;

    while (start < end)
    {
        for (p = c; *p; p++)
            if (*start == *p)
                return start;
        start++;
    }
    return 0;
}
#endif

/********************************************************************/
/* static char * __html_stream_grab_pcdata(char **input, int size)  */
/********************************************************************/
/* This routine returns a local copy of any PCDATA encountered at   */
/* this point, including feeding it through the relevant stripping  */
/* code etc. This routine only reads up to the next '<' sign  	    */
/********************************************************************/
static char *__html_stream_grab_pcdata(char **input, int size, int contig)
{
  char *end=*input;
  char *ret;

carryon:
/*
 * Find the start of the next tag, end of the input stream, or the
 * end of the chunk by size, which ever is the sooner.
 */
  while ((end - *input < size) && (*end != '\0') && (*end != '<') && (*end != '&'))
  {
      end++;
  }

/* If we have gone over the end of the size limit, shuffle back a bit */
  if ((end-*input) >= size) {
    end=(*input)+size;
    if (contig)
        RETURN(NULL);  /* Can't be sure we have all PCDATA yet - we'll come back later */
  } else if (*end == '&')
  {
      /* Check we don't have half an escape code */
      char *stop;

      for (stop = end + 1; (stop - *input < size) && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
        continue;

      if (stop - *input < size)
      {
        if (*stop == ';')
        {
            end = stop + 1;
            goto carryon;
        }
        else if (*stop)
        {
            end = stop;
            goto carryon;
        }
      }
  }

/*
 * grab a copy of what we have and return it, moving the input
 * pointer accordingly.
 */
  ret=strndup(*input,(end-*input));
  __html_strip_control_codes(ret);

  *input=end;
  return ret;

}

/********************************************************************/
/* static HStream __html_stream_start_tag(Tag next_tag, char **html)*/
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
#ifndef NEWSPACING
    st->stripleadingcr=1;
#endif

    __html_process_attributes(st, next_tag, *html, url);

    switch(next_tag->tag_no)
    {
      #ifdef TABLE_SUPPORT
      case TAG_TR:
      case TAG_TD:
      case TAG_TH:
      case TAG_TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
      #endif
      case TAG_INPUT:
      case TAG_SELECT:
      case TAG_OPTION:
      case TAG_TEXTAREA:   if (st->_stream_form==0) break;
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, size);
      case TAG_BASEFONT:   if (ATTR_VAL(FONTSIZE) >= 1 && ATTR_VAL(FONTSIZE) <= 7)
                               st->_stream_basefont = ATTR_VAL(FONTSIZE);
                           break;
      case TAG_FONT: {     int first=1;

                           if (ATTR_SET(COLOUR))
                               add_colour_info(st, ATTR_VAL(COLOUR), &first);

                           if (ATTR_SET(FONTSIZE))
                               add_size_info(st, ATTR_STR(FONTSIZE), &first);

                           break;
                     }
      case TAG_CENTER:     st->_stream_center++; break;
      case TAG_ADDRESS:    st->_stream_address++; break;
      case TAG_BLOCKQUOTE: st->_stream_blockquote++; break;
      case TAG_PRE:	   st->_stream_pre++; break;
      case TAG_H1:
      case TAG_H2:
      case TAG_H3:
      case TAG_H4:
      case TAG_H5:
      case TAG_H6:     st->_stream_h=next_tag->tag; break;
      case TAG_MENU:
      case TAG_DIR:
      case TAG_UL:     st->_stream_ul++;  /* Needed for indent level */
      	   	       st->send_list|=UL;
                       break;
      case TAG_OL:     st->_stream_ol++;  /* Needed for indent level */
      	   	       st->send_list|=OL;
      	   	       break;
      case TAG_DL:     st->_stream_dl++;  /* Needed for indent level */
      	   	       st->_stream_dt=0;
      	   	       st->_stream_dd=0;
      	   	       st->send_list|=DL;
      	   	       //Printf("HTMLLib: Should send a DL now\n");
      	   	       break;

      case TAG_LI:     st->_stream_li++; /* Needed for indent level? */
                       return __html_stream_return_tag(st,next_tag,html,START);
      case TAG_DT:     if (st->_stream_dt)
                       {
                           /* Force a non DT tag so we get a newline */
                           HStream *r;

                           *html = NULL;
                           st->_stream_dt=0;
                           r=__html_stream_return_tag(st, &Null_Tag, NULL, END);
                           r->type |= TYPE_BODY;
                           return r;
                       }
                       st->_stream_dt=1; /* Needed for indent level? */
                       st->_stream_dd=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START);
      case TAG_DD:     st->_stream_dd=1; /* Needed for indent level? */
                       st->_stream_dt=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START);

      case TAG_HR:     return __html_stream_hr(st, html, next_tag);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START);
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      case TAG_P:      st->_stream_p=1; break;
      case TAG_IMG:    return __html_stream_image(st,html, next_tag);
      case TAG_A:      __html_stream_anchor(st, html, next_tag); break;
      case TAG_SAMP:
      case TAG_CODE:
      case TAG_KBD:
      case TAG_VAR:
      case TAG_TT:     st->_stream_tt++; break;
      case TAG_EM:
      case TAG_CITE:
      case TAG_ITALIC: st->_stream_italic++; break;
      case TAG_STRONG:
      case TAG_BOLD:   st->_stream_bold++; break;
      #ifdef TonyTables
      case TAG_TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
      case TAG_TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
      case TAG_TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
      case TAG_TABLE:  st->_stream_table++;
                       return __html_table_start_tag(st, next_tag, html, url, size);
      #endif
      case TAG_META: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_meta), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->meta.http_equiv = ATTR_STR(HTTP_EQUIV);
                  ret->info->meta.name       = ATTR_STR(NAME);
                  ret->info->meta.content    = ATTR_STR(CONTENT);
                  ret->info->meta.scheme     = ATTR_STR(SCHEME);
              }
              return ret;
      }
      case TAG_TITLE:  st->_stream_title++; break;
      case TAG_BASE:   __html_stream_base(st); break;
      case TAG_ISINDEX: st->_stream_isindex=1; break;
      case TAG_SCRIPT:  st->state = Script; return NULL;
      case TAG_STYLE:   st->state = Style; return NULL;
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag, size);
      case TAG_BODY: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_body), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->body.onload = ATTR_STR(ONLOAD);
                  ret->info->body.onunload = ATTR_STR(ONUNLOAD);
                  ret->info->body.background = ATTR_STR(BACKGROUND);
                  ret->info->body.text = ATTR_SET(FGCOL) ? ATTR_VAL(FGCOL) : NULL_COLOUR;
                  ret->info->body.bgcolour = ATTR_SET(BGCOL) ? ATTR_VAL(BGCOL) : NULL_COLOUR;
                  ret->info->body.link = ATTR_SET(LINKCOL) ? ATTR_VAL(LINKCOL) : NULL_COLOUR;
                  ret->info->body.vlink = ATTR_SET(VLINK) ? ATTR_VAL(VLINK) : NULL_COLOUR;
                  ret->info->body.alink = ATTR_SET(ALINK) ? ATTR_VAL(ALINK) : NULL_COLOUR;
              }
              return ret;
          }
      case TAG_FRAMESET:return __html_stream_frameset(st, html, next_tag, size);
      case TAG_NOFRAMES:
              st->_stream_noframes = 1;
              break;
    }
/* In theory we dont need to do any more so we can return here */
    return NULL;
}

#define DEC(a) if ((a) > 0) { (a)--; }

/********************************************************************/
/* static Hstream *__html_stream_end_tag(Tag next_tag, char **html) */
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
/* Make a note of this token for later use */
  st->needtosend |= next_tag->tag;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :) */

  switch(next_tag->tag_no) {
    #ifdef TABLE_SUPPORT
    case TAG_TR:
    case TAG_TD:
    case TAG_TH:
    case TAG_TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
    #endif

    case TAG_FORM:
      st->_stream_form=0;
      break;

    case TAG_SELECT:
      st->_stream_select=0;
      break;

    case TAG_TEXTAREA:
      st->_stream_textarea=0;
      break;

    case TAG_FONT:
      font_tag_closed(st);
      #ifndef NEWSPACING
      st->stripleadingcr = 0;
      #endif
      break;

    case TAG_CENTER:
      DEC(st->_stream_center);
      break;

    case TAG_ADDRESS:
      DEC(st->_stream_address);
      break;

    case TAG_BLOCKQUOTE:
      DEC(st->_stream_blockquote);
      break;

    case TAG_MENU:
    case TAG_DIR:
    case TAG_UL:
      DEC(st->_stream_ul);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_OL:
      DEC(st->_stream_ol);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_DL:
      DEC(st->_stream_dl);
      /* Cope with nested <DL>s: if we're still in a DL, for valid HTML
         we must be in a DD! */
      st->_stream_dt=0;
      st->_stream_dd=st->_stream_dl ? 1 : 0;
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url)*/;

    case TAG_DD:
      st->_stream_dd = 0;
      break;

    case TAG_LI:
      DEC(st->_stream_li);
      break;

    case TAG_DT:
      st->_stream_dt = 0;
      break;

    case TAG_PRE:
      DEC(st->_stream_pre);
      break;

    case TAG_H1:
    case TAG_H2:
    case TAG_H3:
    case TAG_H4:
    case TAG_H5:
    case TAG_H6:
      st->_stream_h = 0;
      break;

    case TAG_A:
    {
      /* Cope with tossers that do <A NAME="fred"></A> */
      if (st->need_to_send_name)
      {
          HStream *return_val;
          st->need_to_send_name=0;

          /* To stop it stripping spaces before the <A NAME="x"> */
          st->isendtag=0;

          return_val=HStreamalloc();
          if (return_val)
          {
              return_val->style=__html_stream_style(st)|PCDATA;
              return_val->type=__html_stream_type(st, TYPE_BODY, END);
              return_val->indent=__html_stream_indent(st);
              if (st->_stream_anchor != NULL) {
                #ifdef LINEONE_HACK
                return_val->onclick=st->_stream_anchor->onclick;
                #endif
                return_val->anchor=st->_stream_anchor->href;
                return_val->name=st->_stream_anchor->name;
                return_val->target = st->_stream_anchor->target;
              }
              fill_in_colour_info(st, return_val);
              return_val->tag=next_tag->tag;
          }
          __html_stream_end_anchor(st);
          return return_val;
      }
      __html_stream_end_anchor(st);
      break;
    }
    case TAG_SAMP:
    case TAG_CODE:
    case TAG_KBD:
    case TAG_VAR:
    case TAG_TT:
      DEC(st->_stream_tt);
      break;

    case TAG_EM:
    case TAG_CITE:
    case TAG_ITALIC:
      DEC(st->_stream_italic);
      break;

    case TAG_STRONG:
    case TAG_BOLD:
      DEC(st->_stream_bold);
      break;
  #ifdef TonyTables
    case TAG_TR:    return __html_table_row_end_tag(st, next_tag, html, url);
    case TAG_TD:    return __html_table_data_end_tag(st, next_tag, html, url);
    case TAG_TH:    return __html_table_head_end_tag(st, next_tag, html, url);
    case TAG_TABLE: return __html_table_end_tag(st, next_tag, html, url);
  #endif
  #if 0
    /* Not required because ANY tag will terminate a TITLE */
    case TAG_TITLE:
      DEC(st->_stream_title);
      break;
  #endif
    case TAG_FRAMESET:
      DEC(st->_stream_frameset);
      NOT_USED(size);
      break;
    case TAG_NOFRAMES:
      st->_stream_noframes = 0;
      break;
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_imagechar **html)                  */
/********************************************************************/
/* Knowing that we are in a image tag, grab the anchor information  */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->style=__html_stream_style(st) | IMG;
    return_val->type=__html_stream_type(st, next_tag->type, START);
    if (ATTR_SET(ISMAP))
        return_val->type|=TYPE_ISMAP;

    switch (ATTR_VAL(ALIGN))
    {
        case 1: return_val->type|=_html_top<<TYPE_ALIGN_SHIFT; break;
        case 2: return_val->type|=_html_middle<<TYPE_ALIGN_SHIFT; break;
        case 3: return_val->type|=_html_bottom<<TYPE_ALIGN_SHIFT; break;
        case 4: return_val->type|=_html_left<<TYPE_ALIGN_SHIFT; break;
        case 5: return_val->type|=_html_right<<TYPE_ALIGN_SHIFT; break;
        case 6: return_val->type|=_html_centre<<TYPE_ALIGN_SHIFT; break;
        default:return_val->type|=_html_none<<TYPE_ALIGN_SHIFT; break;
    }

    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        return_val->target=st->_stream_anchor->target;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
    }

    st->need_to_send_name=0;

    return_val->text=ATTR_STR(ALT);

    return_val->src=ATTR_STR(SRC);

    return_val->rows=ATTR_VAL(HEIGHT);
    return_val->cols=ATTR_VAL(WIDTH);
    return_val->maxlen=ATTR_SET(BORDER) ? ATTR_VAL(BORDER) : 2;

    /* If one of HEIGHT or WIDTH are missing, remove the other one as
       well to prevent confusion */
    if (return_val->rows==0 || return_val->cols==0)
        return_val->cols=return_val->rows=0;

    st->needtosend=0;

  }

  return_val->tag=IMG;
  return_val->indent=__html_stream_indent(st);
  fill_in_colour_info(st, return_val);

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_hr()                               */
/********************************************************************/
/* Knowing that we are in a HR tag, grab the anchor information     */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  char        *ptr;
  int         noshade=0;
  int         alignment=_html_centre;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    if (ATTR_SET(NOSHADE))
        noshade=1;
    switch (ATTR_VAL(ALIGN))
    {
        case 1: alignment = _html_left; break;
        case 2: alignment = _html_right; break;
        case 3: alignment = _html_centre; break;
        default:alignment = _html_none; break;
    }
    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    return_val->size=ATTR_VAL(SIZE);

    st->needtosend=0;
    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        st->need_to_send_name=0;
    }
    return_val->style=__html_stream_style(st) | HR;
    return_val->type=__html_stream_type(st, next_tag->type, START) | noshade;
    return_val->type &= ~TYPE_ALIGN_MASK;
    return_val->type |= alignment << TYPE_ALIGN_SHIFT;
    return_val->indent=__html_stream_indent(st);
    return_val->tag=HR;
    /* Get rid of the anchor info block */

    fill_in_colour_info(st, return_val);
  }


/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_anchor(char **html)                */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag *next_tag)
{
  AnchorInfo *anc;
  int gotsomething=0;

  NOT_USED(html); NOT_USED(next_tag);

  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);

  anc = (AnchorInfo *) __html_malloc(sizeof(AnchorInfo), 1);
  if (!anc) return NULL;

  if (ATTR_SET(NAME))
      anc->name = ATTR_STR(NAME), gotsomething=1, st->need_to_send_name = 1;

  if (ATTR_SET(HREF))
      anc->href = ATTR_STR(HREF), gotsomething=1;

  if (ATTR_SET(TARGET))
      anc->target = ATTR_STR(TARGET), gotsomething=1;

  #ifdef LINEONE_HACK
  if (ATTR_SET(ONCLICK))
      anc->onclick = ATTR_STR(ONCLICK), gotsomething=1;
  #endif

  if (gotsomething)
  {
      if (!anc->target)
          anc->target = strdup(st->target);

      st->_stream_anchor = anc;
  }

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_frame (char **html)                */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag, int size)
{
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | FRAME;
    return_val->tag    = FRAME;
    return_val->type = __html_stream_type(st, next_tag->type, START);
    return_val->size   = st->_stream_frameset;
    return_val->type |= ATTR_VAL(SCROLLING) << TYPE_SCROLLING_SHIFT;
    if (ATTR_SET(NORESIZE))
        return_val->type |= TYPE_NORESIZE;
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
    return_val->rows   = ATTR_VAL(MARGINHEIGHT);
    return_val->cols   = ATTR_VAL(MARGINWIDTH);
    return_val->name   = ATTR_STR(NAME);
    return_val->src    = ATTR_STR(SRC);
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, size, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_frameset (char **html)             */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frameset(StreamTokens *st, char **html, Tag *tag, int size)
{
  HStream     *return_val;
  char        *ptr;

  st->_stream_frameset++;
  st->_stream_noframes = 0;
  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | tag->tag;
    return_val->tag    = tag->tag;
    return_val->type   = __html_stream_type(st, tag->type, START);
    return_val->size   = st->_stream_frameset;
    if (ATTR_SET(ROWS))
    {
        parse_rowcols(ATTR_STRPEEK(ROWS), NULL, &return_val->rows);
        return_val->name = __html_malloc(sizeof(unsigned int), return_val->rows);
        if (return_val->name)
            parse_rowcols(ATTR_STRPEEK(ROWS), (unsigned int *) (return_val->name), NULL);
    }
    if (ATTR_SET(COLS))
    {
        parse_rowcols(ATTR_STRPEEK(COLS), NULL, &return_val->cols);
        return_val->value = __html_malloc(sizeof(unsigned int), return_val->cols);
        if (return_val->value)
            parse_rowcols(ATTR_STRPEEK(COLS), (unsigned int *) (return_val->value), NULL);
    }
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
        
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, size, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_base(char **html)                  */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_base(StreamTokens *st)
{
  if (ATTR_SET(HREF))
  {
      if (st->url) __html_free(st->url, 0);
      st->url = ATTR_STR(HREF);
  }

  if (ATTR_SET(TARGET))
  {
      if (st->target) __html_free(st->target, 0);
      st->target = ATTR_STR(TARGET);
  }

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_end_anchor(void)                   */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static void __html_stream_end_anchor(StreamTokens *st)
{
  /* Need to rewrite this ! */
  __html_stream_free_anchor(&(st->_stream_anchor));
}

#if 0
/********************************************************************/
/* static HStream *__html_stream_end_header(char **html)            */
/********************************************************************/
/* Given the end of the header block, return a token indicating     */
/* things like if ISINDEX is set for example.  	     		    */
/********************************************************************/
static HStream *__html_stream_end_header(char **html)
{
  NOT_USED(html);

  return NULL;
}
#endif

/********************************************************************/
/* static void __html_style_init(styleinfo *s)                      */
/********************************************************************/
/* This small routine resets all the styles to their initial        */
/* value      	      	     	     	       	  		    */
/********************************************************************/
void __html_style_init(styleinfo *s)
{
  memset(s, 0, sizeof *s);
}

/********************************************************************/
/* static void __html_stream_init(void)                             */
/********************************************************************/
/* This small routine resets all the variables to their initial     */
/* value      	      	     	     	       	  		    */
/********************************************************************/
StreamTokens *__html_stream_init(void)
{
  StreamTokens *st;

  st=(StreamTokens *)calloc(1, sizeof(StreamTokens)); /* zeroes everything */
  if (st==NULL) return NULL;

  __html_style_init(&st->_stream_style);

  st->_stream_basefont   =3;
  st->stripleadingspace  =1;

  return st;
}

/********************************************************************/
/* static HStream *__html_stream_return_tag (Tag tag, char **html)  */
/********************************************************************/
/* Given any old tag block that isnt a PCDATA, create and return a  */
/* stream element for that tag.	       	       	      	  	    */
/********************************************************************/
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag *tag, char **html, int start)
{
  HStream *ret;
  char *ptr;

  ret=HStreamalloc();
  if (ret != NULL) {

      ret->style=__html_stream_style(st) | tag->tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag->type, start);

      ret->indent=__html_stream_indent(st);

      fill_in_colour_info(st, ret);

      if (st->_stream_anchor!=NULL) {
        #ifdef LINEONE_HACK
        ret->onclick=st->_stream_anchor->onclick;
        #endif
        ret->anchor=st->_stream_anchor->href;
        ret->name=st->_stream_anchor->name;
        st->need_to_send_name=0;
        ret->target=st->_stream_anchor->target;
      }

      ret->tag=tag->tag;

      st->needtosend=0;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  if (html != NULL) {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

  return ret;
}

/********************************************************************/
/* static void __html_stream_free_anchor(AnchorInfo **anchor)       */
/********************************************************************/
/* Given an anchor info block free up all the memory associated     */
/* with it, and set it back to NULL   	      	     		    */
/********************************************************************/
/*static*/ void __html_stream_free_anchor(AnchorInfo **anchor)
{
AnchorInfo *anc=*anchor;

  if (!anchor || !anc) return;

  /* Don't free href or target - HStreams point directly to them.
   * They will get freed normally when the stream is discarded.
   */
  __html_free(anc,0);

  *anchor=NULL;
}

/********************************************************************/
/* static HStream * __html_form_handler(StreamTokens *st, Tag ne... */
/********************************************************************/
/* General purpose forms handling but. Since all form elements are  */
/* basically derived from the same generic idea, it makes sense to  */
/* keep them in one bit. NOTE: LINKS WITHIN FORMS ARE DUFF AT THE   */
/* moment due to an earlier oversight. Fix soon	      	      	    */
/********************************************************************/
static HStream * __html_form_handler(StreamTokens *st, Tag *next_tag, char **html, int size)
{
HStream *ret;
char *ptr; /* Hackery - used to get text after tag */
char *p;

/* Since a form shouldnt be within an anchor, we can clear the anchor state */
  /*if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));*/


/* Fill in a return slip :) */
  ret=HStreamalloc();
  if (!ret) return ret;

   ret->flags = 0;
   fill_in_colour_info(st, ret);

  if (next_tag->tag == OPTION || next_tag->tag == TEXTAREA || next_tag->tag == SELECT)
  {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

/* This is the nasty bit :) Decide what to do based on the tag */
  switch(next_tag->tag_no) {
    case TAG_FORM: /* Fill in method bit etc */
    	       ret->tag=FORM;
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_form), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
    	       st->_stream_form=1;
	       ret->style=__html_stream_style(st);
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
    	       ret->info->form.action         = ATTR_STR(ACTION);
    	       ret->info->form.method         = (formmethod) ATTR_VAL(METHOD);
               ret->info->form.accept_charset = ATTR_STR(ACCEPT_CHARSET);
               ret->info->form.enctype        = ATTR_STR(ENCTYPE);
               ret->info->form.onsubmit       = ATTR_STR(ONSUBMIT);
               ret->info->form.onreset        = ATTR_STR(ONRESET);
               ret->info->form.target         = ATTR_STR(TARGET);
               st->needtosend |= FORM;
	       break;

    case TAG_INPUT: /* Do lots of bits */
    {
               elementinfo_input *info;

    	       ret->tag=INPUT;
    	       info=(elementinfo_input *)__html_malloc(sizeof(elementinfo_input), 1);
    	       ret->info=(elementinfo *)info;
    	       if (!info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | INPUT;
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
	       /* INPUTy bits */
               info->type      = (inputtype) ATTR_VAL(TYPE);
	       info->name      = ATTR_STR(NAME);
	       info->value     = ATTR_STR(VALUE);
               info->checked   = ATTR_SET(CHECKED);
               info->disabled  = ATTR_SET(DISABLED);
               info->readonly  = ATTR_SET(READONLY);
	       info->size      = ATTR_VAL(SIZE);
	       info->maxlength = ATTR_VAL(MAXLENGTH);
	       info->src       = ATTR_STR(SRC);
	       info->alt       = ATTR_STR(ALT);
	       info->usemap    = ATTR_STR(USEMAP);
	       info->align     = (imgalign) ATTR_VAL(ALIGN);
               info->tabindex  = ATTR_VAL(TABINDEX);
               info->onfocus   = ATTR_STR(ONFOCUS);
               info->onblur    = ATTR_STR(ONBLUR);
               info->onselect  = ATTR_STR(ONSELECT);
               info->onchange  = ATTR_STR(ONCHANGE);
               info->accept    = ATTR_STR(ACCEPT);
	       if (info->type == inputtype_TEXT || info->type == inputtype_PASSWORD) {
  	         if (info->maxlength > 0) {
  	           ret->text=strndup(info->value, info->maxlength); /* Ensure big buffer */
  	         }
  	         else {
  	           ret->text=strndup(info->value, 1024);
  	         }
  	       } else if (info->type == inputtype_IMAGE)
  	           ret->text=strdup(info->alt);
	       break;
    }

    case TAG_SELECT: /* Check multiple bits */
                /* Right, here we go. We need to grab data until the next
                   </SELECT> */
                if ((p = strinstr(*html, "</SELECT>", size)) == NULL)
                {
                    *html=0;       /* Signal back-up */
                    RETURN(NULL);
                }
                return __html_form_parse_select(st, html, p-*html, ret);

    case TAG_OPTION: /* OPTION tag */
    	       ret->tag=OPTION;
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_option), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | OPTION;
	       ret->type=__html_stream_type(st, next_tag->tag, START);
	       /* OPTIONy bits */
	       ret->value=ATTR_STR(VALUE);
	       ret->info->option.selected = ATTR_SET(SELECTED);
	       ret->info->option.disabled = ATTR_SET(DISABLED);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
               #ifdef NEWSPACING
               __html_strip_spaces(ret->text, st->stripleadingspace, 1);
               #else
               __html_strip_spaces(ret->text, st->stripleadingcr);
               #endif
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;

    default: /* TEXTAREA */
    	       st->_stream_textarea=1;
    	       ret->tag=TEXTAREA;
	       ret->style=__html_stream_style(st) | TEXTAREA;
	       ret->type=__html_stream_type(st, next_tag->type, START);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
	       /* TextArea Bits */
	       ret->cols=ATTR_VAL(COLS);
	       ret->rows=ATTR_VAL(ROWS);
	       ret->name=ATTR_STR(NAME);
	       /*st->form_disabled = ATTR_SET(DISABLED);*/
                __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;
  }

  if (ret)
      fill_in_colour_info(st, ret);

  return ret;
}

HStream *__html_return_text_token(char *doc, size_t size)
{
HStream *return_val=NULL;

  return_val=HStreamalloc();

  if (return_val != NULL) {

    return_val->text=strndup(doc, size);
    return_val->style=PRE | PCDATA ;
    return_val->flags = 0;


    __html_strip_lfs(return_val->text);
    __html_strip_control_codes(return_val->text);
    return_val->type=TYPE_BODY;
    return_val->tag=PCDATA;
    return_val->fontsize = 3;
  }
  return return_val;
}

#include "api.h"

/*
 * This routine is called from __html_form_handler
 * We have an HStream ready to be filled in, html points to the start
 * of the block, and size is the size of the block.
 */
static HStream *__html_form_parse_select(StreamTokens *st, char **html, int size, HStream *ret)
{
    char *ptr=*html, *p;
    HStream *h, *hp;
    StreamTokens *s;
    int count,items;
    elementinfo_select *info;

    /* Re-enter the parser - get a stream for our block, and pull out the
       OPTION tags(!) */

    s=HtmlParse(st->url, size, TYPE_HTMLFILE, 0);
    /* Hack hack hack hack! */
    s->_stream_form=1;
    s->_stream_select=1;
    h=HtmlGetStream(s, &ptr, size, NULL);
    __html_set_memory_context(st->memcontext);

    /* The format of the "value" is:
               1st word: number of options
               2nd word: flags (0)
       then per option:
               Flags byte: bit 0 = selected
                           bit 1 = disabled
               Displayed text, terminated by zero byte
               Symbolic name, terminated by a zero byte (just a zero byte if not
                                                         present)
       then to terminate
               &FF
     */
    count=8;
    items=0;
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            count+=1+strlen(hp->text)+1+(hp->value?strlen(hp->value):0)+1;
            items+=1;
        }
        hp=hp->next;
    }
    count+=1;

    info=(elementinfo_select *)__html_malloc(sizeof(elementinfo_select), 1);
    ret->info=(elementinfo *)info;
    if (!info) { HtmlStreamFree(h); free(s); __html_free(ret, 0); return NULL; }

    info->options=(int *)__html_malloc(count, 1);
    info->options[0] = items;
    info->options[1] = 0;
    p = (char *) &info->options[2];
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            int len;

            /* Flags byte */
            *p++=hp->info->option.selected;

            sprintf(p, "%s%n", hp->text, &len); p+=len;
            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';
            p++;
            if (hp->value)
            {
                sprintf(p, "%s%n", hp->value, &len); p+=len+1;
            }
            else
                *p++='\0';
        }
        hp=hp->next;
    }
    *p=0xFF;
    assert((p+1)-(char *)info->options == count);

    HtmlStreamFree(h);
    free(s);

    ret->tag=SELECT;

    ret->style=__html_stream_style(st) | SELECT;
    ret->type=__html_stream_type(st, TYPE_BODY, START);
    ret->indent=__html_stream_indent(st);

    info->name     = ATTR_STR(NAME);
    info->disabled = ATTR_SET(DISABLED);
    info->multiple = ATTR_SET(MULTIPLE);
    info->size     = ATTR_VAL(SIZE);
    info->tabindex = ATTR_VAL(TABINDEX);
    info->onfocus  = ATTR_STR(ONFOCUS);
    info->onblur   = ATTR_STR(ONBLUR);
    info->onselect = ATTR_STR(ONSELECT);
    info->onchange = ATTR_STR(ONCHANGE);

    fill_in_colour_info(st, ret);
    st->needtosend |= SELECT;

    ptr=*html+size;

    while (*ptr!='>')
        ptr++;

    *html=ptr+1;

    return ret;
}

HStream *HStreamalloc(void)
{
    HStream *ret = (HStream *)__html_malloc(sizeof(HStream), 1);

    if (ret)
        ret->parent = __html_current_cell;

    return ret;
}

static int my_strncasecmp(const char *a, const char *b, unsigned int n)
{
    while( *a && *b && n-- )
	if( tolower(*a++) != tolower(*b++) )
	    return 1;

    return 0;
}


static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, int tag)
{
    char *ptr = *html;
    int termlen = strlen(term);
    char term0 = term[0];

    while (size)
    {
        if (*ptr == term0)
        {
            if (size < termlen)
                RETURN(NULL);

            if (my_strncasecmp(ptr, term, termlen)==0)
            {
                HStream *ret;

                st->state = Other;
                /* Produce a return token with the data in the text field */
                ret = HStreamalloc();
                if (ret)
                {
                    ret->tag = tag;
                    ret->style = __html_stream_style(st);
                    ret->type = __html_stream_type(st, TYPE_HEAD, START);
                    ret->text = strndup(*html, ptr - *html - 1);
                    __html_unescape_string(ret->text);
                }
                *html = ptr;
                st->stripleadingspace = 1;
                return ret;
            }
        }
        ptr++;
        size--;
    }

    RETURN(NULL);
}

/* parse_rowcols (local)
 *
 *   ptr -> FRAMESET ROWS=""/COLS="" data to parse
 *   values = NULL:
 *      put number of data into number
 *   value != NULL:
 *      put data into values array
 *
 * counts number of data items, or puts data items in an array
 */

static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number) {

  unsigned int value;

  if (!values) *number = 0;

  do {
    while (isspace(*ptr)) ptr++;
    value = 0;
    if (isdigit(*ptr)) {
      value = (unsigned int) strtol (ptr, &ptr, /*base=*/10);
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == '*') {
      if (!value) value = 1;
      value |= ROWCOL_STAR;
      ptr++;
    } else if (*ptr == '%') {
      value |= ROWCOL_PERCENT;
      ptr++;
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == ',') {
      ptr++;
    }
    while (isspace(*ptr)) ptr++;

    if (values) {
      *values++ = value;
    } else {
      *number += 1;
    }

  } while (isdigit (*ptr) || *ptr == '*');
}
