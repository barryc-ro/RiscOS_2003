/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source$
 *
 * $Log$
 * Revision 1.2.2.6  1997/07/02 09:05:55  gthorbur
 * updated to help enable head/body switching
 *
 * Revision 1.2.2.5  1997/07/02 08:39:39  kbracey
 * Added previous pointers to table rows and cells.
 * Implemented skipping of <STYLE> and <SCRIPT>.
 *
 * Revision 1.2  1997/04/29 15:50:47  kbracey
 * Merged in ARTtmp_merge
 *
 * Revision 1.1.2.3  1997/04/28 14:20:19  kbracey
 * Added in Tony Cheal's table code. Various other bug fixes.
 *
 * Revision 1.1.2.2  1997/04/09 16:44:37  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:46  kbracey
 * Initial revision
 *
 * Revision 1.1  95/10/31  13:12:14  pwain
 * Initial revision
 *
 */

#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#ifdef TonyTables
#include "HTMLTables.h"
#endif

/******************************************************************************/
/* This comment is 80 chars wide. It was used to format this file.            */
/******************************************************************************/

/********************************************************************/
/* Predefinition of static functions contained in this file, along  */
/* along with the main parse function predifinition.   	     	    */
/********************************************************************/
static unsigned int __html_stream_style(StreamTokens *st);
static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start);
static unsigned int __html_stream_indent(StreamTokens *st);
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag next_tag,
                              char **html,char *url, int size);
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_image(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_hr(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_anchor(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static    HStream * __html_stream_frame(StreamTokens *st, char **html,
                              Tag next_tag, char *url, int size);
static    HStream * __html_stream_base(StreamTokens *st, char **html,
                              Tag next_tag, char *url);
static        void  __html_stream_end_anchor(StreamTokens *st);
#if 0
static    HStream * __html_stream_end_header(char **html);
#endif
static    HStream * __html_form_handler(StreamTokens *st, Tag next_tag,
                              char **html, char *url, int size);
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag tag,
                              char **html, int start, char *url);
static 	     char * __html_stream_grab_pcdata(char **input, int size,
                              int contig);
/*static*/   char * __html_make_anchor(char *base, char *link);
/*static*/         void __html_stream_free_anchor(AnchorInfo **anchor);
static         void strdoublecpy(char *buffer, char *s1, char *s2);
static    HStream * __html_form_parse_select(StreamTokens *, char **html,
                              int size, HStream *ret);
static    HStream * __html_stream_declaration(StreamTokens *st, char **html,
                                              int size);
static    HStream * __html_stream_comment(StreamTokens *st, char **html,
                                          int size);
static    HStream * HStreamalloc(void);
static    HStream * __html_stream_skip_cdata(StreamTokens *st, char **html,
                                             int size);

/********************************************************************/
/* A global variable declared in this file. A byte is an unsigned   */
/* char.    	     	      	      	      	      	 	    */
/********************************************************************/
byte __html_done_for_now=0;

/********************************************************************/
/* A few preprocessor definitions to make life easier.              */
/********************************************************************/
#define START 1
#define END   0

/********************************************************************/
/* A small macro. Set a parser internal flag for some exit states.  */
/* This permits on the fly HTML parsing to work correctly. 	    */
/********************************************************************/
#define RETURN(x) {__html_done_for_now=1; return x;}

/********************************************************************/
/* HStream *__html_stream_parse(StreamTokens *st, char **html, .... */
/********************************************************************/
/* The main parse routine. This does one of three things:           */
/*     + Grabs the next bit of text on the input stream		    */
/*     + interprets the top HTML tag on the input stream	    */
/*     + nothing because there is insufficient input (on the fly    */
/*          parsing needs this).  	       	     	     	    */
/*	    	    	  					    */
/* In the first two cases the input pointer is updated to where we  */
/* got to, in the last case, __html_done_for_now is set and the     */
/* input pointer is not moved. 			    	    	    */
/********************************************************************/
HStream *__html_stream_parse(StreamTokens *st, char **html, char *url,
                              int size, HStream *prevhs)
{
  HStream *return_val=NULL;
  Tag     next_tag;
  char    *ptr;
  char 	  *tag_start;
  char 	  *start;
  int     lastwaspcdata=st->lastwaspcdata;

/* Reset the bail out pointer */
  __html_done_for_now=0;

/* Look to make sure we have a valid input pointer. Order is important here */
  if (!html || !*html || !**html) RETURN(NULL);

  switch (st->state)
  {
    case Declaration:
      return __html_stream_declaration(st, html, size);
    case Comment:
      return __html_stream_comment(st, html, size);
      /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
    case Script:
    case Style:
      return __html_stream_skip_cdata(st, html, size);
    /* Fall through if other */
  }

/* In some cases a '>' is left at the beginning of the input stream. Ignore it */
  if (**html == '>') {
/* If we ignore it, update the input pointer and the size */
    *html = *html+1;
    size--;
/* If we now have nothing left, return */
    if ((size==0) || (!**html)) RETURN((HStream *)NULL);
/* Always keep ptr in sync with HTML */
  }

  ptr=*html;
  tag_start=*html+1;
  start=*html;

/*
 * The first case. We dont have a '<' as the top of the input stream
 * and we are not inside a comment, so grab up to the next tag or the
 * end of the input stream, whichever is the sooner, and return it as
 * a text segment (PCDATA).
 */
  if (*ptr != '<') {

/* This avoids a few funnies. Cant remember why but it is needed */
    if (**html == '>') {
      *html=(*html)+sizeof(char);
      size --;
    }

/* Create the structure to return. If non-NULL fill it in */
    return_val=HStreamalloc();
    if (return_val != NULL) {
/* Grab the text, and set the style word in the structure */
      return_val->flags = 0;
      return_val->text=__html_stream_grab_pcdata(html, size, 0);
      return_val->style=__html_stream_style(st) | PCDATA ;
/*
 * If the text is PREformatted or in a textarea in a form we dont want
 * to strip out the LFs, but we do need to unescape it
 */
      if (((return_val->style & PRE) == PRE ) ||
      	   ((return_val->style & TEXTAREA) == TEXTAREA)) {
        __html_strip_lfs(return_val->text); /* Strip CRs, preserve LFs */
        __html_unescape_string(return_val->text);
      } else {
/*
 * Otherwise it is true PCDATA so we need to munge spaces, CRs, LFs, and
 * unescape escape sequences in the data
 */
#ifdef NEWSPACING
        st->stripleadingspace = __html_strip_spaces(return_val->text, st->stripleadingspace, 0);
        st->lastwaspcdata = 1;
#else
        __html_strip_spaces(return_val->text, st->stripleadingcr);
#endif
        __html_unescape_string(return_val->text);
      }

/*
 * Now evaluate the type word. We need this to decide what to do if there
 * is a NULL input string left at this point.
 */
      return_val->type=__html_stream_type(st, TYPE_BODY, START);

      /*if (return_val->style & DL)
         Printf("HTMLLib: Got a DL\n");*/
/* Look to see if we have a zero length return string */
      if (*(return_val->text) == '\0') {
/*
 * If the tag is not a special once-only tag,
 * dump the tag to save memory in the
 * final stream returned.
 */
      if (!(return_val->style & (P|BR|DL|OL|UL|DIR))) {
/*
 * We only need to free the text and the structure since we havent filled
 * in any other bits, so this is faster than calling the free routine. And
 * return a NULL pointer because we dont need to do anything. 'html' has
 * already been moved at this point, so this is safe.
 */
          __html_free(return_val->text,0);
          __html_free(return_val,0);
          /*if (return_val->style & DL)
            Printf("HTMLLib: Junked a DL :-(\n");*/
          return NULL;
        }
        else {
/* Otherwise just free up the text and set the text pointer to a NULL */
          __html_free(return_val->text,0);
          return_val->text=NULL;
          /*if (return_val->style & DL)
            Printf("HTMLLib: Cleared a DL\n");*/
        }
      }

/* Calculate the list indent count */
      return_val->indent=__html_stream_indent(st);

/* If this tag has anchor information associated with it, extract it */
      if (st->_stream_anchor != NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->name=st->_stream_anchor->name;
        return_val->target = st->_stream_anchor->target;
      }
/* Otherwise set it to a NULL */
      else {
        return_val->anchor=NULL;
        return_val->name=NULL;
      }

/* Fill in colour information */
      fill_in_colour_info(st, return_val);

/* Set the rest of the values up as a TEXT token */
      return_val->tag=PCDATA;
      return_val->src=NULL;
      return_val->next=NULL;
      return_val->prev=NULL;
      st->needtosend=0;
      #ifdef NEWSPACING
      /*st->stripleadingspace=0;*/
      #else
      st->stripleadingcr=0;
      #endif
    }

  #ifdef TRACE
  {
      FILE *fp=fopen("ADFS::4.$.Trace.ParseTrc", "a");
      if (fp)
      {
          fputs(return_val->text, fp);
          fclose(fp);
      }
  }
  #endif
/*
 * Return the structure. Note that if there was insufficient memory to
 * allocate a tag, this will return a NULL pointer, so this is safe.
 */
    //if (return_val->style & DL) Printf("HTMLLib: returned a DL\n");

    return return_val;
  }

  if (size < 2)
      RETURN(NULL);

  /* Stop doing any titleness */
  st->_stream_title=0;

  if (*(ptr+1) == '!')
  {
      st->state = Declaration;
      *html = ptr+2;
      return NULL;
  }

  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

/*
 * We now think we have a tag. We extract the tag information by skipping
 * the initial '<', finding the end of the tag, and inspecting the bit
 * between the start and end pointers (*html and ptr).
 */
  ptr++; /* Skip the '<' */
  while ((ptr-start < size) && (*ptr != '\0') && (*ptr != '>') &&
                             (*ptr != '<')) {
    ptr++;
  }

/* This code breaks if there happens to be a '>' in the first byte
 * after the meaningful data
 */
#if 0
/*
 * If we hit 'size' but the first element in the stream is a '<'
 * I think we have an incomplete tag, otherwise if we have moved
 * more than 'size' bytes we have run off the end of a meaningful
 * input stream.
 */
  if (ptr-start >= size) {
    if ( ((**html == '<') && (*ptr != '>')) || (ptr-start > size) ) {
      RETURN(NULL);
    }
  }
#else
  if (ptr-start >= size)
  {
      RETURN(NULL);
  }
#endif

/*
 * We are now in a safe position to believe we have a tag and that we
 * have all of the tag. Thus we can look to see what we have.
 */

  if (tag_start[0]=='/')
  {
    if (lastwaspcdata && prevhs && prevhs->text)
    {
      __html_strip_trailing_spaces(prevhs->text);
      if (prevhs->text[0]=='\0')
      {
        __html_free(prevhs->text, 0);
        prevhs->text=0;
        prevhs->type &=~ TYPE_MASK;
        /*prevhs->type=(prevhs->type &~ (TYPE_BODY|TYPE_FRAMESET|TYPE_NOFRAMES)) | TYPE_HEAD;*/
      }
    }
  }
  else
    st->stripleadingspace=1;

  next_tag=__html_find_tag(&tag_start,0);

/* The start tag case */
  if (!NULL_TAG(next_tag)) {
/*
 * If the tag we have is a tag that we need to notify the termination
 * of, then send back a NULL tag that terminates all the tags we need
 * to before returning this tag. We can do this by not moving the html
 * data pointer before returning.
 */
    if ((st->needtosend & next_tag.tag) == next_tag.tag && next_tag.tag
#ifdef TonyTables
        && !__html_current_table
#endif
       )
    {
        /* Put in a null tag (ish) */
        return_val=__html_stream_return_tag(st, Null_Tag, NULL, END, st->url);
        return_val->type|=TYPE_BODY;
    }
    else
    {
        char *p=*html;
/*
 * Otherwise do what we need to with this pointer before returning
 * any token that it generates.
 */
      if (lastwaspcdata && next_tag.implicit_lf_before && prevhs && prevhs->text)
      {
        __html_strip_trailing_spaces(prevhs->text);
        if (prevhs->text[0]=='\0')
        {
          __html_free(prevhs->text, 0);
          prevhs->text=0;
        }
      }

      return_val =  __html_stream_start_tag(st,next_tag, &p, url, size);
      /* More hackery - some tags swallow PCDATA - if the routine returns
         NULL, that indicates a tag that needs more PCDATA */
      if (p>ptr)
        *html=p;
      else if (p!=NULL)
        *html=ptr;
    }
    return return_val;
  }


/* Otherwise it was an end tag? */
  next_tag=__html_find_tag(&tag_start,1);

  if (!NULL_TAG(next_tag)) {
/* Register that we have an end tag */
    return_val = __html_stream_end_tag(st, next_tag, html, url, size);
    *html=ptr;

   return return_val;
  }

/* Update the pointer and return. This skips unwanted tags etc. */

  *html=ptr;

  return return_val;
}

/********************************************************************/
/* __html_stream_declaration                                        */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a <!  > pair   */
/********************************************************************/
static HStream *__html_stream_declaration(StreamTokens *st, char **html,
                                          int size)
{
    /*
     * Currently we don't do anything with declarations. Just need
     * to skip comments
     */
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '>')
        {
            *html = ptr + 1;
            st->state = Other;
            return NULL;
        }
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                *html = ptr+2;
                st->state = Comment;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    *html=ptr;
    RETURN(NULL);
}

/********************************************************************/
/* __html_stream_comment                                            */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a -- -- pair   */
/********************************************************************/
static HStream *__html_stream_comment(StreamTokens *st, char **html,
                                      int size)
{
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '-')
        {
            if (size < 2)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '-')
            {
                *html = ptr+2;
                st->state = Declaration;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    *html = ptr;
    RETURN(NULL);
}

/********************************************************************/
/* static unsigned int __html_stream_style(void)                    */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_style(StreamTokens *st)
{
  unsigned int return_val=0;

  if (st->_stream_title) {
    return_val |= TITLE;
  }
  else {
    if (st->_stream_bold)	    return_val |= BOLD;
    if (st->_stream_italic)         return_val |= ITALIC;
    if (st->_stream_tt)	    	    return_val |= TT;
    if (st->_stream_a)	    	    return_val |= A;
    if (st->_stream_img)	    return_val |= IMG;
    if (st->_stream_p)	          { return_val |= P; st->_stream_p=0; }
                                    return_val |= st->_stream_h;
    if (st->_stream_pre)	    return_val |= PRE;

    if (st->send_list > 0) {
      if (st->send_list & DL) {
        if (st->_stream_dl)	    return_val |= DL;
      }
      if (st->send_list & OL) {
        if (st->_stream_ol)	    return_val |= OL;
      }
      if (st->send_list & UL) {
        if (st->_stream_ul)	    return_val |= UL;
      }
      if (st->send_list & DIR) {
        if (st->_stream_dir)	    return_val |= DIR;
      }
      st->send_list = 0;
    }
    /*if (st->_stream_li)	            return_val |= LI;*/
    if (st->_stream_dt)	    	    return_val |= DT;
    if (st->_stream_dd)	    	    return_val |= DD;
    if (st->_stream_br)           { return_val |= BR ; st->_stream_br=0; }
    if (st->_stream_blockquote)     return_val |= BLOCKQUOTE;
    if (st->_stream_address)        return_val |= ADDRESS;
    if (st->_stream_center)	    return_val |= CENTER;
    if (st->_stream_anchor != NULL) return_val |= A;
    if (st->_stream_form)     	    return_val |= FORM;
    if (st->_stream_select)	    return_val |= SELECT;
    if (st->_stream_textarea)	    return_val |= TEXTAREA;
    #ifdef TonyTables
    if (st->_stream_table)          return_val |= TABLE;
    #endif
  }

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_type(void)                     */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

static unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
{
  unsigned int temp=tag_type;

  if (st->_stream_title) {
    temp = TYPE_HEAD;

  } else if (st->_stream_frameset) {
    temp = TYPE_FRAMESET;
  }

  if (st->_stream_noframes) {
    temp |= TYPE_NOFRAMES;
  }

  temp |= (((unsigned int) start) << TYPE_START_SHIFT);

/* Draw together the anchor and form bits just in case :) */
  if (st->_stream_anchor != NULL) {
    temp |= ((unsigned int)(st->_stream_anchor->alignment) <<TYPE_ALIGN_SHIFT);
    temp |= ((unsigned int)(st->_stream_anchor->ismap)     <<TYPE_ISMAP_SHIFT);
  }
  if (st->_stream_forms != NULL) {
    temp |= ((unsigned int)(st->_stream_forms->type)       <<TYPE_INPUT_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->method)     <<TYPE_METHOD_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->checked)    <<TYPE_CHECKED_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->multiple)   <<TYPE_MULTIPLE_SHIFT);
    temp |= ((unsigned int)(st->_stream_forms->selected)   <<TYPE_SELECTED_SHIFT);
  }
  if (st->_stream_colour != NULL) {
    if (st->_stream_colour->colour_valid)
      temp |= TYPE_COLOURED;
  }

  return temp;
}

/********************************************************************/
/* static unsigned int __html_stream_indent(void)                   */
/********************************************************************/
/* Given all the status variable attempt to work out the indent     */
/* level at this point in time	 	    	     	 	    */
/********************************************************************/
static unsigned int __html_stream_indent(StreamTokens *st)
{
  return ((unsigned int) st->_stream_dl -
                         st->_stream_dt +
  	 	         st->_stream_ol +
  	 	         st->_stream_ul +
  	 	         st->_stream_dir);
}

#if 0
static char *strnchrs(char *start, const char *c, const char *end)
{
    const char *p;

    while (start < end)
    {
        for (p = c; *p; p++)
            if (*start == *p)
                return start;
        start++;
    }
    return 0;
}
#endif

/********************************************************************/
/* static char * __html_stream_grab_pcdata(char **input, int size)  */
/********************************************************************/
/* This routine returns a local copy of any PCDATA encountered at   */
/* this point, including feeding it through the relevant stripping  */
/* code etc. This routine only reads up to the next '<' sign  	    */
/********************************************************************/
static char *__html_stream_grab_pcdata(char **input, int size, int contig)
{
  char *end=*input;
  char *ret;

carryon:
/*
 * Find the start of the next tag, end of the input stream, or the
 * end of the chunk by size, which ever is the sooner.
 */
  while ((end - *input < size) && (*end != '\0') && (*end != '<') && (*end != '&'))
  {
      end++;
  }

/* If we have gone over the end of the size limit, shuffle back a bit */
  if ((end-*input) >= size) {
    end=(*input)+size;
    if (contig)
        RETURN(NULL);  /* Can't be sure we have all PCDATA yet - we'll come back later */
  } else if (*end == '&')
  {
      /* Check we don't have half an escape code */
      char *stop;

      for (stop = end + 1; (stop - *input < size) && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
        continue;

      if (stop - *input < size)
      {
        if (*stop == ';')
        {
            end = stop + 1;
            goto carryon;
        }
        else if (*stop)
        {
            end = stop;
            goto carryon;
        }
      }
  }

/*
 * grab a copy of what we have and return it, moving the input
 * pointer accordingly.
 */
  ret=strndup(*input,(end-*input));
  __html_strip_control_codes(ret);

  *input=end;
  return ret;

}

/********************************************************************/
/* static HStream __html_stream_start_tag(Tag next_tag, char **html)*/
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_start_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
#ifndef NEWSPACING
    st->stripleadingcr=1;
#endif
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :)
 */
#ifndef TABLE_SUPPORT
    if (next_tag.tag >= BR)
    {
/*
 * We have a body only element so if we were in the head stage
 * we should toggle to the body stage
 */
    }
#endif

    switch(next_tag.tag_no)
    {
      #ifdef TABLE_SUPPORT
      case TAG_TR:
      case TAG_TD:
      case TAG_TH:
      case TAG_TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
      #endif
      case TAG_INPUT:
      case TAG_SELECT:
      case TAG_OPTION:
      case TAG_TEXTAREA:   if (st->_stream_form==0) break;
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, url, size);
      case TAG_BASEFONT:
      case TAG_FONT:       {
                           AnchorInfo *anc;
                           /*
                            * __html_get_anchor_info will examine the size/colour information in
                            * the tag, and will update st. We don't actually want the AnchorInfo
                            * structure generated...
                            */
                           anc = __html_get_anchor_info(st, html, next_tag);
                           __html_stream_free_anchor(&anc);
                           break;
                           }
      case TAG_CENTER:     st->_stream_center++; break;
      case TAG_ADDRESS:    st->_stream_address++; break;
      case TAG_BLOCKQUOTE: st->_stream_blockquote++; break;
      case TAG_PRE:	   st->_stream_pre++; break;
      case TAG_H1:
      case TAG_H2:
      case TAG_H3:
      case TAG_H4:
      case TAG_H5:
      case TAG_H6:
      case TAG_H7:     st->_stream_h=next_tag.tag; break;
      case TAG_DIR:    st->_stream_dir++; /* Needed for indent level */
      	   	       st->send_list|=DIR;
      	   	       break;
      case TAG_MENU:
      case TAG_UL:     st->_stream_ul++;  /* Needed for indent level */
      	   	       st->send_list|=UL;
                       break;
      case TAG_OL:     st->_stream_ol++;  /* Needed for indent level */
      	   	       st->send_list|=OL;
      	   	       break;
      case TAG_DL:	       st->_stream_dl++;  /* Needed for indent level */
      	   	       st->_stream_dt=0;
      	   	       st->_stream_dd=0;
      	   	       st->send_list|=DL;
      	   	       //Printf("HTMLLib: Should send a DL now\n");
      	   	       break;

      case TAG_LI:	       st->_stream_li++; /* Needed for indent level? */
                       return __html_stream_return_tag(st,next_tag,html,START,url);
      case TAG_DT:	       st->_stream_dt=1; /* Needed for indent level? */
                       st->_stream_dd=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);
      case TAG_DD:	       st->_stream_dd=1; /* Needed for indent level? */
                       st->_stream_dt=0;
      	   	       return __html_stream_return_tag(st,next_tag,html,START,url);

      case TAG_HR:     return __html_stream_hr(st, html, next_tag, url);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START,url);
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      case TAG_P:      st->_stream_p=1; break;
      case TAG_IMG:    return __html_stream_image(st,html, next_tag, url);
      case TAG_A:      __html_stream_anchor(st, html, next_tag, url); break;
      case TAG_SAMP:
      case TAG_CODE:
      case TAG_KBD:
      case TAG_VAR:
      case TAG_TT:     st->_stream_tt++; break;
      case TAG_EM:
      case TAG_CITE:
      case TAG_ITALIC: st->_stream_italic++; break;
      case TAG_STRONG:
      case TAG_BOLD:   st->_stream_bold++; break;
      #ifdef TonyTables
      case TAG_TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
      case TAG_TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
      case TAG_TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
      case TAG_TABLE:  st->_stream_table++;
                       return __html_table_start_tag(st, next_tag, html, url, size);
      #endif
      case TAG_NEXTID:
      case TAG_META:
      case TAG_LINK:   //st->_stream_head=1;
         	 break; /* We are ignoring these for now */
      case TAG_TITLE:  st->_stream_title++; break;
      case TAG_BASE:   __html_stream_base(st, html, next_tag, url); break;
      case TAG_ISINDEX: st->_stream_isindex=1; break;
      case TAG_SCRIPT:  st->state = Script; return NULL;
      case TAG_STYLE:   st->state = Style; return NULL;
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag, url, size);
      case TAG_BODY:
              __html_stream_anchor(st, html, next_tag, url);
              return __html_stream_return_tag(st,next_tag,html,START,url);
      case TAG_FRAMESET:
            {
              HStream *ret_val;
              st->_stream_frameset++;
              st->_stream_noframes = 0;
              __html_stream_anchor(st, html, next_tag, url);
              if (st->_stream_anchor)
              {
                st->_stream_anchor->size = st->_stream_frameset;
//                st->_stream_frame = 0;
              }
              ret_val =  __html_stream_return_tag(st,next_tag,html,START,url);

              __html_stream_grab_pcdata(html, size, 1);

              return ret_val;
              break;
            }
      case TAG_NOFRAMES:
              st->_stream_noframes = 1;
              break;
    }
/* In theory we dont need to do any more so we can return here */
    return NULL;
}

#define DEC(a) if ((a) > 0) { (a)--; }

/********************************************************************/
/* static Hstream *__html_stream_end_tag(Tag next_tag, char **html) */
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_end_tag(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
#ifdef NEWSPACING
    st->isendtag=1;
    st->stripleadingspace=next_tag.implicit_lf_after;
#else
    st->stripleadingcr=1;
#endif
/* Make a note of this token for later use */
  st->needtosend |= next_tag.tag;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :) */

  switch(next_tag.tag_no) {
    #ifdef TABLE_SUPPORT
    case TAG_TR:
    case TAG_TD:
    case TAG_TH:
    case TAG_TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
    #endif

    case TAG_FORM:
      st->_stream_form=0;
      break;

    case TAG_SELECT:
      st->_stream_select=0;
      break;

    case TAG_TEXTAREA:
      st->_stream_textarea=0;
      break;

    case TAG_FONT:
      font_tag_closed(st);
      #ifndef NEWSPACING
      st->stripleadingcr = 0;
      #endif
      break;

    case TAG_CENTER:
      DEC(st->_stream_center);
      break;

    case TAG_ADDRESS:
      DEC(st->_stream_address);
      break;

    case TAG_BLOCKQUOTE:
      DEC(st->_stream_blockquote);
      break;

    case TAG_DIR:
      DEC(st->_stream_dir);
      return __html_stream_return_tag(st,next_tag,html,END,url);

    case TAG_MENU:
    case TAG_UL:
      DEC(st->_stream_ul);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_OL:
      DEC(st->_stream_ol);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_DL:
      DEC(st->_stream_dl);
      /* Cope with nested <DL>s: if we're still in a DL, for valid HTML
         we must be in a DD! */
      st->_stream_dt=0;
      st->_stream_dd=st->_stream_dl ? 1 : 0;
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url)*/;

    case TAG_DD:
      st->_stream_dd = 0;
      break;

    case TAG_LI:
      DEC(st->_stream_li);
      break;

    case TAG_DT:
      st->_stream_dt = 0;
      break;

    case TAG_PRE:
      DEC(st->_stream_pre);
      break;

    case TAG_H1:
    case TAG_H2:
    case TAG_H3:
    case TAG_H4:
    case TAG_H5:
    case TAG_H6:
    case TAG_H7:
      st->_stream_h = 0;
      break;

    case TAG_HR: break; /* Should never see! */
    case TAG_BR: break; /* Should never see! */
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
    case TAG_IMG:    break; /* No such tag! */
    case TAG_A:      __html_stream_end_anchor(st); break;
    case TAG_SAMP:
    case TAG_CODE:
    case TAG_KBD:
    case TAG_VAR:
    case TAG_TT:
      DEC(st->_stream_tt);
      break;

    case TAG_EM:
    case TAG_CITE:
    case TAG_ITALIC:
      DEC(st->_stream_italic);
      break;

    case TAG_STRONG:
    case TAG_BOLD:
      DEC(st->_stream_bold);
      break;
  #ifdef TonyTables
    case TAG_TR:    return __html_table_row_end_tag(st, next_tag, html, url);
    case TAG_TD:    return __html_table_data_end_tag(st, next_tag, html, url);
    case TAG_TH:    return __html_table_head_end_tag(st, next_tag, html, url);
    case TAG_TABLE: return __html_table_end_tag(st, next_tag, html, url);
  #endif
    case TAG_NEXTID:
    case TAG_META:
    case TAG_LINK:
    case TAG_ISINDEX: break; /* No such tags */
#if 0
    /* Not required because ANY tag will terminate a TITLE */
    case TAG_TITLE:
      DEC(st->_stream_title);
      break;
#endif
    case TAG_FRAMESET:
      DEC(st->_stream_frameset);
      NOT_USED(size);
      break;
    case TAG_NOFRAMES:
      st->_stream_noframes = 0;
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_imagechar **html)                  */
/********************************************************************/
/* Knowing that we are in a image tag, grab the anchor information  */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      return_val->style=__html_stream_style(st) | IMG;
      return_val->type=__html_stream_type(st, next_tag.type, START);
      if (anc->ismap) {
        return_val->type|=TYPE_ISMAP;
      }
      return_val->type|=anc->alignment<<TYPE_ALIGN_SHIFT;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->target = (st->_stream_anchor->target);
       }
      else {
        return_val->anchor=NULL;
      }
      return_val->text=strdup(anc->alt);
      return_val->src=__html_make_anchor(url,anc->src);
      return_val->name=st->_stream_anchor->name;
//      return_val->target = strdup(st->_stream_anchor->target);
     return_val->rows=anc->rows;
      return_val->cols=anc->cols;
      return_val->maxlen=anc->border;
      return_val->next=NULL;
      return_val->prev=NULL;

      /* If one of HEIGHT or WIDTH are missing, remove the other one as
         well to prevent confusion */
      if (return_val->rows==0 || return_val->cols==0)
        return_val->cols=return_val->rows=0;
    }
    st->needtosend=0;

    /* Get rid of the anchor info block */
    __html_stream_free_anchor(&anc);

  }

  return_val->tag=IMG;
  return_val->indent=__html_stream_indent(st);
  fill_in_colour_info(st, return_val);

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_hr()                               */
/********************************************************************/
/* Knowing that we are in a HR tag, grab the anchor information     */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;
  int         noshade=0;
  int         alignment=_html_centre;

  return_val=HStreamalloc();
  if (return_val != NULL) {
    return_val->flags = 0;
    anc=__html_get_anchor_info(st, html, next_tag);
    if (anc != NULL) {
      if (anc->noshade)
        noshade = TYPE_NOSHADE;
      if (anc->alignment != _html_none)
          alignment = anc->alignment;
      if (st->_stream_anchor!=NULL) {
        return_val->anchor=__html_make_anchor(url,st->_stream_anchor->href);
        return_val->name=st->_stream_anchor->name;
      }
      return_val->cols=anc->cols;
      return_val->size=anc->size;
      __html_stream_free_anchor(&anc);

    }
    st->needtosend=0;
    return_val->name=st->_stream_anchor->name;
    return_val->style=__html_stream_style(st) | HR;
    return_val->type=__html_stream_type(st, next_tag.type, START) | noshade;
    return_val->type &= ~TYPE_ALIGN_MASK;
    return_val->type |= alignment << TYPE_ALIGN_SHIFT;
    return_val->indent=__html_stream_indent(st);
    return_val->tag=HR;
    /* Get rid of the anchor info block */

    fill_in_colour_info(st, return_val);
  }


/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_anchor(char **html)                */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag next_tag, char *url)
{
  NOT_USED(url);
  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor && !st->_stream_anchor->target)
    st->_stream_anchor->target = strdup(st->target);
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_frame (char **html)                */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag next_tag, char *url, int size)
{
  AnchorInfo  *anc;
  HStream     *return_val;
  char        *ptr;

  return_val=HStreamalloc();
  anc = __html_get_anchor_info(st, html, next_tag);
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | FRAME;
    return_val->tag    = FRAME;
    return_val->type = __html_stream_type(st, next_tag.type, START);
    return_val->size   = st->_stream_frameset;
    if (anc != NULL) {
      if (anc->scrolling) {
        return_val->type |= anc->scrolling << TYPE_SCROLLING_SHIFT;
      }
      if (anc->noresize) {
        return_val->type |= TYPE_NORESIZE;
      }
      return_val->indent = anc->spacing;
      return_val->maxlen = anc->maxlength;
      return_val->rows   = anc->rows;
      return_val->cols   = anc->cols;
      return_val->name   = anc->name;
      return_val->src=__html_make_anchor(url,anc->src);

//      __html_stream_free_anchor(&anc);
    }
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, size, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_base(char **html)                  */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_base(StreamTokens *st, char **html, Tag next_tag, char *url)
{
char *newurl, *newtarget;
  NOT_USED(url);

  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);
  st->_stream_anchor=__html_get_anchor_info(st, html, next_tag);
  if (st->_stream_anchor != NULL) {
    if (st->_stream_anchor->href != NULL) {
      newurl=strdup(st->_stream_anchor->href);
      if (newurl) {
        __html_free(st->url,0);
        st->url=newurl;
      }
    }
    if (st->_stream_anchor->target != NULL) {
      newtarget=strdup(st->_stream_anchor->target);
      if (newtarget) {
        __html_free(st->target,0);
        st->target=newtarget;
      }
    }
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_end_anchor(void)                   */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static void __html_stream_end_anchor(StreamTokens *st)
{
  /* Need to rewrite this ! */
  __html_stream_free_anchor(&(st->_stream_anchor));
}

#if 0
/********************************************************************/
/* static HStream *__html_stream_end_header(char **html)            */
/********************************************************************/
/* Given the end of the header block, return a token indicating     */
/* things like if ISINDEX is set for example.  	     		    */
/********************************************************************/
static HStream *__html_stream_end_header(char **html)
{
  NOT_USED(html);

  return NULL;
}
#endif

/********************************************************************/
/* static void __html_style_init(styleinfo *s)                      */
/********************************************************************/
/* This small routine resets all the styles to their initial        */
/* value      	      	     	     	       	  		    */
/********************************************************************/
void __html_style_init(styleinfo *s)
{
  memset(s, 0, sizeof *s);
}

/********************************************************************/
/* static void __html_stream_init(void)                             */
/********************************************************************/
/* This small routine resets all the variables to their initial     */
/* value      	      	     	     	       	  		    */
/********************************************************************/
StreamTokens *__html_stream_init(void)
{
  StreamTokens *st;

  st=(StreamTokens *)calloc(1, sizeof(StreamTokens)); /* zeroes everything */
  if (st==NULL) return NULL;

  __html_style_init(&st->_stream_style);

  st->_stream_basefont   =3;
  st->stripleadingspace  =1;

  return st;
}

/********************************************************************/
/* static HStream *__html_stream_return_tag (Tag tag, char **html)  */
/********************************************************************/
/* Given any old tag block that isnt a PCDATA, create and return a  */
/* stream element for that tag.	       	       	      	  	    */
/********************************************************************/
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag tag, char **html, int start, char *url)
{
  HStream *ret;
  char *ptr;
  #ifdef TRACE
  FILE *fp;
  #endif

  ret=HStreamalloc();
  if (ret != NULL) {

      ret->flags = 0;
      ret->style=__html_stream_style(st) | tag.tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag.type, start);
      #ifdef TABLE_SUPPORT
      if (tag.tag==TABLE) {
        ret->style|=HR;
        #ifdef TRACE
        fp=fopen("adfs::4.$.op","a");
        if (fp) {
          fprintf(fp,"TABLE found...\n");
          fclose(fp);
        }
        #endif
      }
      #endif

      ret->indent=__html_stream_indent(st);

      fill_in_colour_info(st, ret);

      if (st->_stream_anchor!=NULL) {
        ret->anchor=__html_make_anchor(url, st->_stream_anchor->href);
        ret->name=st->_stream_anchor->name;
        ret->target=st->_stream_anchor->target;
      }
      else {
        ret->anchor=NULL;
        ret->name=NULL;
        ret->target=NULL;
      }

      ret->text=NULL;
      if (tag.tag_no==TAG_BODY)
        ret->tag=0;
      else
        ret->tag=tag.tag;

      #ifdef TABLE_SUPPORT
      if (tag.tag == TABLE) {
        ret->style|=HR;
      }
      #endif


//      Printf ("%s has tag field %08x\n", tag.start_tag, tag.tag);

      if (tag.tag_no == TAG_BODY) {
        if (st->_stream_anchor != NULL) {
          ret->src=__html_make_anchor(url,st->_stream_anchor->src);
          /* These four store colour info for the page (special case) */
          ret->size=st->_stream_anchor->size;
          ret->rows=st->_stream_anchor->rows;
          ret->cols=st->_stream_anchor->cols;
          ret->maxlen=st->_stream_anchor->maxlength;
          __html_stream_free_anchor(&(st->_stream_anchor));
          ret->style |= IMG;
        }
        else {
          ret->src=NULL;
          /* Not valid RiscOS colours. Should be trapped by the UI */
          ret->size=(unsigned int)-1;
          ret->rows=(unsigned int)-1;
          ret->cols=(unsigned int)-1;
          ret->maxlen=(unsigned int)-1;
        }
      } else if (tag.tag == TYPE_FRAMESET) {
//          ret->src=st->_stream_anchor->src;

          if (st->_stream_anchor != NULL) {

              ret->value=st->_stream_anchor->value;
              st->_stream_anchor->value = 0;

              ret->size=st->_stream_anchor->size;
              ret->rows=st->_stream_anchor->rows;
              ret->cols=st->_stream_anchor->cols;
              ret->indent=st->_stream_anchor->spacing;
              ret->maxlen=st->_stream_anchor->maxlength;
          } else {
              ret->value = 0;
              ret->size = st->_stream_frameset;
              ret->rows = 0;
              ret->cols = 0;
              ret->indent = 1;
              ret->maxlen = 0x00000000;
          }

      } else ret->src=NULL;
      ret->prev=NULL;
      st->needtosend=0;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  if (html != NULL) {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

  return ret;
}

/********************************************************************/
/* static char *__html_make_anchor(char *base, char *link)          */
/********************************************************************/
/* Given a base URL and another URL (e.g. a link or an image), this */
/* routine constructs the resultant URL from the pair               */
/********************************************************************/

char * __html_make_anchor(char * base, char * link)
{
  char        * ret = NULL;
  char        * copy;
  char        * buffer;
  char        * uri;
  extern char * __html_tidy_url(char * url);

  if (link == NULL) return NULL;

  if (base == NULL) // || (strstr(base,"ADFS:") != NULL)
  {
    ret = strdup(link);
    return ret;
  }

  if (link[0] == '#')
  {
    /* It's a within document link */

    ret = __html_malloc(strlen(link) + strlen(base) + 1, 1);
    if (ret) strdoublecpy(ret, base, link);

    return ret;
  }

  /* Should have a Fetcher_Relativise call                               */
  /*                                                                     */
  /* Simple test for a fully qualified URL. Look for '://' in the string */
  /* Also catch "mailto:" and "x500:" URLs at this point. We expect the  */
  /* method to be at the start of the string. (This is to allow for      */
  /* funny proxies :)                                                    */
  /*                                                                     */
  /* The test on ret - link <= 9 ensures URLs that are indeed relative,  */
  /* but contain URLs themselves (e.g. as part of some CGI info in the   */
  /* link) aren't treated as absolute (see below for more of this kind   */
  /* of consideration). We want the :// to be within about the first 9   */
  /* characters, more or less...                                         */

  ret = strstr(link, "://");

  if (
       (ret && ret - link <= 9)     ||
       !strincmp(link,"MAILTO:",7)  ||
       !strincmp(link,"NEWS:",  5)  ||
       !strincmp(link,"X500:",  5)
     )
  {

    ret = strdup(link);
    return ret;
  }

  /* Now look for broken URLs of the form 'method:/path/to/file' or           */
  /* 'method:relative/path'. These are a tad more difficult to deal with      */
  /* so a separate routine is needed to do this :) This relies on mailto and  */
  /* x500 being caught above.                                                 */
  /*                                                                          */
  /* Also the test for being more than 7 chars in is needed for places like   */
  /* www.pathfinder.com who have URLs of the form:                            */
  /*                                                                          */
  /* /adgw/nph-adgw.cgi?url=http:%2f%2fchess.ibm.park.org&advertiser=...      */
  /* IBM%20OS2&description=IBM%20Chess%20Button&source=%2fpathfinder%2f...    */
  /* welcome.html                                                             */
  /*                                                                          */
  /* which contain the sequence "http:" (Technically the ':' should be        */
  /* encoded too I believe!). Anyway since mailto is the longest method, 7    */
  /* should be okay, I hope!. Alternatively if this is found to be unreliable */
  /* change the buffer=strchr() bit and the *link=='/' bits around.           */

  buffer = strchr(link, ':');

  if (buffer && (buffer - link < 7))
  {
    buffer++;

    uri = strdup(buffer); /* Buffer should now contain URI. Just need new base */
    if (!uri) return NULL;

    /* Now get the method bit - ughh! */

    buffer = strdup(link);

    if (!buffer) return buffer;

    ret  = strchr(buffer,':'); /* Can't fail because of above */
    *ret = '\0';

    /* Now need to construct new base bit. */
    copy=__html_malloc(strlen(base)+strlen(buffer)+1,1);
    if (!copy) return copy;
    /* We have up to the : so skip that in base */
    base=strchr(base,':');
    if (base==NULL) return base;
    sprintf(copy,"%s%s",buffer,base);
    base=copy;
    link=uri;
  }

/* The 1st case. The link starts with a '/' so it is an absolute URL
 * around the same host/method base.
 */
  if (*link=='/') {
    link++;
    ret=__html_malloc(strlen(base)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return NULL;

    strcpy(ret,base);
    copy=ret;
    copy=strstr(copy,"://");
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; copy++; copy++;
    copy=strchr(copy,'/');
    if (copy==NULL) {
      __html_free(ret, 0);
      return NULL;
    }
    copy++; *copy='\0';
    strcat(ret,link);
    return ret;
  }

/* The 2nd case. The link starts with a './' so it is an relative URL
 * around this page
 */
  if ((*link=='.') && (*(link+1)=='/')) {
    link++; link++;

default_return:

/*
 * Basically we need to look back through base to find the last '/'
 * and append link at that point. So we need a string the length
 * of base and link, and then blat the two strings into it.
 *
 * So grab a copy of base, and strip it back to the required point
 */
    ret=copy=strdup(base);

    if (ret==NULL) return ret;

    ret=strrchr(copy,'/');

    if (ret==NULL) {
      __html_free(copy, 0);
      return NULL;
    }
    ret++;
    *ret='\0';

/* Create a big enough string */
    ret=__html_malloc(strlen(copy)+strlen(link)+1,sizeof(char));
    if (ret==NULL) return ret;
/* Add the two strings into the return buffer */
    strdoublecpy(ret, copy, link);
    return __html_tidy_url(ret);
  }

/* 3rd case. The link has a ':' in it. Assume its a link such as a
 * mailto request. (i.e. host independant URL)
 */

 if (strchr(link, ':') != NULL) {
   ret=strdup(link);
   return ret;
 }

/* Otherwise this is sort of the same as case 2 sans the './' */
 goto default_return;
}

/********************************************************************/
/* static void __html_stream_free_anchor(AnchorInfo **anchor)       */
/********************************************************************/
/* Given an anchor info block free up all the memory associated     */
/* with it, and set it back to NULL   	      	     		    */
/********************************************************************/
/*static*/ void __html_stream_free_anchor(AnchorInfo **anchor)
{
AnchorInfo *anc=*anchor;

  if (!anchor || !anc) return;

  if (anc->href != NULL)    __html_free(anc->href,0);
  if (anc->src != NULL)     __html_free(anc->src,0);
  if (anc->alt != NULL)     __html_free(anc->alt,0);
  if (anc->action != NULL)  __html_free(anc->action,0);
  if (anc->enctype != NULL) __html_free(anc->enctype,0);
  if (anc->value != NULL)   __html_free(anc->value,0);
//  if (anc->target != NULL)  __html_free(anc->target,0);
  __html_free(anc,0);

  *anchor=NULL;
}

/********************************************************************/
/* static void strdoublecpy(char *buffer, char *s1, char *s2)       */
/********************************************************************/
/* Copy s1 and s2 into buffer, with no space between them           */
/********************************************************************/

static void strdoublecpy(char *buffer, char *s1, char *s2)
{
  if (buffer==NULL) return;
  sprintf(buffer,"%s%s",s1,s2);
}

/********************************************************************/
/* static HStream * __html_form_handler(StreamTokens *st, Tag ne... */
/********************************************************************/
/* General purpose forms handling but. Since all form elements are  */
/* basically derived from the same generic idea, it makes sense to  */
/* keep them in one bit. NOTE: LINKS WITHIN FORMS ARE DUFF AT THE   */
/* moment due to an earlier oversight. Fix soon	      	      	    */
/********************************************************************/
static HStream * __html_form_handler(StreamTokens *st, Tag next_tag, char **html, char *url, int size)
{
AnchorInfo *anc;
HStream *ret;
char *ptr; /* Hackery - used to get text after tag */
char *p;

/* Since a form shouldnt be within an anchor, we can clear the anchor state */
  if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));

/* Now get the form information out of the anchor */
  anc=__html_get_anchor_info(st, html, next_tag);

/* Always check for those NULLs. */
  if (anc == NULL && next_tag.tag != OPTION)
      return (HStream *)anc; /* 2 instructions saved :) */

  st->_stream_forms = anc;

/* Fill in a return slip :) */
  ret=HStreamalloc();
  if (!ret) return ret;

   ret->flags = 0;
   fill_in_colour_info(st, ret);

  if (next_tag.tag == OPTION || next_tag.tag == TEXTAREA || next_tag.tag == SELECT)
  {
    ptr=*html;
    while((*ptr != '\0') && (*ptr != '>')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

/* This is the nasty bit :) Decide what to do based on the tag */
  switch(next_tag.tag_no) {
    case TAG_FORM: /* Fill in method bit etc */
    	       st->_stream_form=1;
    	       ret->tag=FORM;
    	       if (!anc->method)
    	            anc->method=1; /* Default to GET form (there are morons out there) */
	       ret->style=__html_stream_style(st);
	       ret->type=__html_stream_type(st, next_tag.type, START);
	       ret->anchor=__html_make_anchor(url, st->_stream_forms->action);
	       if (st->_stream_anchor) {
                 ret->target = st->_stream_anchor->target;
               }
               ret->enctype=strdup(st->_stream_forms->enctype);
               ret->indent=__html_stream_indent(st);
               st->needtosend |= FORM;
	       break;

    case TAG_INPUT: /* Do lots of bits */
    	       ret->tag=INPUT;
	       ret->style=__html_stream_style(st) | INPUT;
	       ret->type=__html_stream_type(st, next_tag.type, START);
	       /* INPUTy bits */
	       ret->maxlen=st->_stream_forms->maxlength;
	       ret->size=st->_stream_forms->size;
	       ret->value=strdup(st->_stream_forms->value);
	       if (st->_stream_forms->type <= 1) {
  	         if (ret->maxlen > 0) {
  	           ret->text=strndup(ret->value,ret->maxlen); /* Ensure big buffer */
  	         }
  	         else {
  	           ret->text=strndup(ret->value, 1024);
  	         }
  	       }
	       ret->name=strdup(st->_stream_forms->name);
	       ret->src=strdup(st->_stream_forms->src);
               ret->indent=__html_stream_indent(st);
	       break;

    case TAG_SELECT: /* Check multiple bits */
#ifdef OLDCODE
    	       st->_stream_select=1;
    	       ret->tag=SELECT;
	       ret->style=__html_stream_style(st) | SELECT;
	       ret->type=__html_stream_type(st, START);
	       /* SELECTy bits */
	       ret->name=strdup(st->_stream_forms->name);
               ret->indent=__html_stream_indent(st);
	       st->needtosend |= SELECT;
	       break;
#else
                /* Right, here we go. We need to grab data until the next
                   </SELECT> */
                if ((p = strinstr(*html, "</SELECT>", size)) == NULL)
                {
                    *html=0;       /* Signal back-up */
                    RETURN(NULL);
                }
                return __html_form_parse_select(st, html, p-*html, ret);
#endif

    case TAG_OPTION: /* OPTION tag */
    	       ret->tag=OPTION;
	       ret->style=__html_stream_style(st) | OPTION;
	       ret->type=__html_stream_type(st, next_tag.tag, START);
	       /* OPTIONy bits */
	       if (st->_stream_forms)
	           ret->value=strdup(st->_stream_forms->value);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
               #ifdef NEWSPACING
               __html_strip_spaces(ret->text, st->stripleadingspace, 1);
               #else
               __html_strip_spaces(ret->text, st->stripleadingcr);
               #endif
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;

    default: /* TEXTAREA */
    	       st->_stream_textarea=1;
    	       ret->tag=TEXTAREA;
	       ret->style=__html_stream_style(st) | TEXTAREA;
	       ret->type=__html_stream_type(st, next_tag.type, START);
	       ret->text=__html_stream_grab_pcdata(html, size, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
	       /* TextArea Bits */
	       ret->cols=st->_stream_forms->cols;
	       ret->rows=st->_stream_forms->rows;
	       ret->name=strdup(st->_stream_forms->name);
                __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;
  }

  return ret;
}

HStream *__html_return_text_token(char *doc, size_t size)
{
HStream *return_val=NULL;

  return_val=HStreamalloc();

  if (return_val != NULL) {

    return_val->text=strndup(doc, size);
    return_val->style=PRE | PCDATA ;
    return_val->flags = 0;


    __html_strip_lfs(return_val->text);
    __html_strip_control_codes(return_val->text);
    return_val->type=TYPE_BODY;
    return_val->tag=PCDATA;
    return_val->fontsize = 3;
  }
  return return_val;
}

#include "api.h"

/*
 * This routine is called from __html_form_handler
 * We have an HStream ready to be filled in, html points to the start
 * of the block, and size is the size of the block.
 */
static HStream *__html_form_parse_select(StreamTokens *st, char **html, int size, HStream *ret)
{
    char *ptr=*html, *p;
    HStream *h, *hp;
    StreamTokens *s;
    int count,items;

    /* Re-enter the parser - get a stream for our block, and pull out the
       OPTION tags(!) */

    s=HtmlParse(st->url, size, TYPE_HTMLFILE, 0);
    /* Hack hack hack hack! */
    s->_stream_form=1;
    s->_stream_select=1;
    h=HtmlGetStream(s, &ptr, size, NULL);
    __html_set_memory_context(st->memcontext);

    /* The format of the "value" is:
               1st word: number of options
               2nd word: flags (0)
       then per option:
               Flags byte (0 atm)
               Displayed text, terminated by zero byte
               Symbolic name, terminated by a zero byte (just a zero byte if not
                                                         present)
       then to terminate
               &FF
     */
    count=8;
    items=0;
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            count+=1+strlen(hp->text)+1+(hp->value?strlen(hp->value):0)+1;
            items+=1;
        }
        hp=hp->next;
    }
    count+=1;
    /* Hack! */
    ret->value=p=__html_malloc(count, 1);
    *((int *)p)=items; p+=4;
    *((int *)p)=0; p+=4;
    hp=h;
    while (hp)
    {
        if (hp->tag == OPTION)
        {
            int len;

            /* Flags byte */
            *p++=(hp->type & TYPE_SELECTED) ? 1 : 0;

            sprintf(p, "%s%n", hp->text, &len); p+=len;
            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';
            p++;
            if (hp->value)
            {
                sprintf(p, "%s%n", hp->value, &len); p+=len+1;
            }
            else
                *p++='\0';
        }
        hp=hp->next;
    }
    *p=0xFF;
    assert((p+1)-ret->value == count);

    HtmlStreamFree(h);
    free(s);

    ret->tag=SELECT;
    ret->style=__html_stream_style(st) | SELECT;
    ret->type=__html_stream_type(st, TYPE_BODY, START);
    ret->name=strdup(st->_stream_forms->name);
    ret->size=st->_stream_forms->size;
    ret->indent=__html_stream_indent(st);
    fill_in_colour_info(st, ret);
    st->needtosend |= SELECT;

    ptr=*html+size;

    while (*ptr!='>')
        ptr++;

    *html=ptr+1;

    return ret;
}

HStream *HStreamalloc(void)
{
    HStream *ret = (HStream *)__html_malloc(sizeof(HStream), 1);

    if (ret)
        ret->parent = __html_current_headdata;

    return ret;
}

static HStream * __html_stream_skip_cdata(StreamTokens *st, char **html, int size)
{
    char *ptr = *html;
    while (size)
    {
        if (*ptr == '<')
        {
            if (size < 3)
            {
                *html = ptr;
                RETURN(NULL);
            }
            if (*(ptr+1) == '/' && (*(ptr+2) >= 'A' && *(ptr+2) <= 'Z' ||
                                    *(ptr+2) >= 'a' && *(ptr+2) <= 'z'))
            {
                /*
                 * It's an end tag - assume its the end of the SCRIPT/STYLE section and
                 * let the parser process the </Whatever>. HTML 3.2 spec says that we
                 * should ignore anything other than "</" followed immediately by
                 * [a-zA-Z], so we've satisfied that condition at least
                 */
                st->state = Other;
                *html = ptr;
                return NULL;
            }
        }
        ptr++;
        size--;
    }

    *html = ptr;
    RETURN(NULL);
}
