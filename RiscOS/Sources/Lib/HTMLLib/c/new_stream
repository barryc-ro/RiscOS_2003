#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include <ctype.h>
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

/******************************************************************************/
/* This comment is 80 chars wide. It was used to format this file.            */
/******************************************************************************/

/********************************************************************/
/* Predefinition of static functions contained in this file, along  */
/* along with the main parse function predifinition.   	     	    */
/********************************************************************/
static    HStream * __html_stream_start_tag(StreamTokens *st, Tag *next_tag,
                              char **html,char *url, int size);
static    HStream * __html_stream_end_tag(StreamTokens *st, Tag *next_tag,
                              char **html, char *url, int size);
static    HStream * __html_stream_end_form(StreamTokens *st, char **html);
static    HStream * __html_stream_image(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_q(StreamTokens *st, char **html,
                              int start);
static    HStream * __html_map_handler(StreamTokens *st);
static    HStream * __html_stream_area(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_hr(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_anchor(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_frame(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_frameset(StreamTokens *st, char **html,
                              Tag *next_tag);
static    HStream * __html_stream_base(StreamTokens *st);
static        void  __html_stream_end_anchor(StreamTokens *st);
#if 0
static    HStream * __html_stream_end_header(char **html);
#endif
static    HStream * __html_form_handler(StreamTokens *st, Tag *next_tag,
                              char **html, int size);
/*static*/HStream * __html_stream_return_tag(StreamTokens *st, Tag *tag,
                              char **html, int start);
static 	     char * __html_stream_grab_pcdata(char **input,
                              int contig, int after_tag);
/*static*/   char * __html_make_anchor(char *base, char *link);
/*static*/         void __html_stream_free_anchor(AnchorInfo **anchor);
static    HStream * __html_form_parse_select(StreamTokens *, char **html,
                              int size, HStream *ret);
static    HStream * __html_stream_declaration(StreamTokens *st, char **html,
                                              int size);
//static    HStream * __html_stream_comment(StreamTokens *st, char **html,
//                                          int size);
static    HStream * __html_stream_script(StreamTokens *st, char **html,
                                             int size, const char *term, tag_no tagno);
static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number);
static char *__html_skip_record_end(const char *s, int strip_leading);

/********************************************************************/
/* A global variable declared in this file. A byte is an unsigned   */
/* char.    	     	      	      	      	      	 	    */
/********************************************************************/
byte __html_done_for_now=0;

/********************************************************************/
/* A small macro. Set a parser internal flag for some exit states.  */
/* This permits on the fly HTML parsing to work correctly. 	    */
/********************************************************************/
#define RETURN(x) {__html_done_for_now=1; return x;}

/********************************************************************/
/* HStream *__html_stream_parse(StreamTokens *st, char **html, .... */
/********************************************************************/
/* The main parse routine. This does one of three things:           */
/*     + Grabs the next bit of text on the input stream		    */
/*     + interprets the top HTML tag on the input stream	    */
/*     + nothing because there is insufficient input (on the fly    */
/*          parsing needs this).  	       	     	     	    */
/*	    	    	  					    */
/* In the first two cases the input pointer is updated to where we  */
/* got to, in the last case, __html_done_for_now is set and the     */
/* input pointer is not moved. 			    	    	    */
/********************************************************************/
HStream *__html_stream_parse(StreamTokens *st, char **html, char *url,
                              int size, HStream *prevhs)
{
  HStream *return_val=NULL;
  Tag     *next_tag;
  char    *ptr;
  char 	  *tag_start;
  char 	  *start;
  int     lastwaspcdata=st->lastwaspcdata;

/* Reset the bail out pointer */
  __html_done_for_now=0;

  if (st->special_return)
  {
      return_val = st->special_return;
      st->special_return = NULL;
      return return_val;
  }

/* Look to make sure we have a valid input pointer. Order is important here */
  if (!html || !*html || !**html) RETURN(NULL);

  switch (st->state)
  {
    case Declaration:
      return __html_stream_declaration(st, html, size);
//    case Comment:
//      return __html_stream_comment(st, html, size);
      /* Don't handle SCRIPT or STYLE at the moment, but lets parse over it */
    case Script:
      return __html_stream_script(st, html, size, "</SCRIPT>", TAG_SCRIPT);
    case Style:
      return __html_stream_script(st, html, size, "</STYLE>", TAG_STYLE);
    /* Fall through if other */
  }

/* In some cases a '>' is left at the beginning of the input stream. Ignore it */
  if (**html == '>') {
/* If we ignore it, update the input pointer and the size */
    *html = *html+1;
    size--;
/* If we now have nothing left, return */
    if ((size==0) || (!**html)) RETURN((HStream *)NULL);
/* Always keep ptr in sync with HTML */
  }

  ptr=*html;
  tag_start=*html+1;
  start=*html;

/*
 * The first case. We dont have a '<' as the top of the input stream
 * and we are not inside a comment, so grab up to the next tag or the
 * end of the input stream, whichever is the sooner, and return it as
 * a text segment (PCDATA).
 */
  if (*ptr != '<') {

/* This avoids a few funnies. Cant remember why but it is needed */
    if (**html == '>') {
      *html += 1;
      size --;
    }

/* Create the structure to return. If non-NULL fill it in */
    return_val=HStreamalloc(st, (tag_no)0);
    if (return_val != NULL) {
/* Grab the text, and set the style word in the structure */
      return_val->text=__html_stream_grab_pcdata(html, 0, 0);
      if (st->_stream_title)
          return_val->tagno = TAG_TITLE;
      else
          return_val->style=__html_stream_style(st) | PCDATA ;
/*
 * If the text is PREformatted or in a textarea in a form we dont want
 * to strip out the LFs, but we do need to unescape it
 */
      if ((return_val->style & PRE) == PRE ||
      	   return_val->tagno == TAG_TEXTAREA) {
        __html_strip_lfs(return_val->text); /* Strip CRs, preserve LFs */
        __html_unescape_string(return_val->text);
      } else {
/*
 * Otherwise it is true PCDATA so we need to munge spaces, CRs, LFs, and
 * unescape escape sequences in the data
 */
#ifdef NEWSPACING
        st->stripleadingspace = __html_strip_spaces(return_val->text, st->stripleadingspace, 0);
        st->lastwaspcdata = 1;
#else
        __html_strip_spaces(return_val->text, st->stripleadingcr);
#endif
        __html_unescape_string(return_val->text);
      }

/*
 * Now evaluate the type word. We need this to decide what to do if there
 * is a NULL input string left at this point.
 */
      return_val->type=__html_stream_type(st, TYPE_BODY, START);

      /*if (return_val->style & DL)
         Printf("HTMLLib: Got a DL\n");*/
/* Look to see if we have a zero length return string */
      if (*(return_val->text) == '\0') {
/*
 * If the tag is not a special once-only tag,
 * dump the tag to save memory in the
 * final stream returned.
 */
      if (!(return_val->style & (P|BR|DL|UL))) {
/*
 * We only need to free the text and the structure since we havent filled
 * in any other bits, so this is faster than calling the free routine. And
 * return a NULL pointer because we dont need to do anything. 'html' has
 * already been moved at this point, so this is safe.
 */
          __html_free(return_val->text,0);
          __html_free(return_val,0);
          /*if (return_val->style & DL)
            Printf("HTMLLib: Junked a DL :-(\n");*/
          return NULL;
        }
        else {
/* Otherwise just free up the text and set the text pointer to a NULL */
          __html_free(return_val->text,0);
          return_val->text=NULL;
          /*if (return_val->style & DL)
            Printf("HTMLLib: Cleared a DL\n");*/
        }
      }

/* Calculate the list indent count */
      return_val->indent=__html_stream_indent(st);

/* If this tag has anchor information associated with it, extract it */
      if (st->_stream_anchor != NULL) {
        return_val->anchor=st->_stream_anchor->href;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        return_val->name=st->_stream_anchor->name;
        return_val->coords=st->_stream_anchor->coords;
        st->need_to_send_name=0;
        return_val->target = st->_stream_anchor->target;
      }

/* Fill in colour information */
      fill_in_colour_info(st, return_val);

/* Set the rest of the values up as a TEXT token */
      return_val->tag=PCDATA;
      memset(st->needtosend, 0, sizeof st->needtosend);
      #ifdef NEWSPACING
      /*st->stripleadingspace=0;*/
      #else
      st->stripleadingcr=0;
      #endif
    }

  #ifdef TRACE
  {
      FILE *fp=fopen("ADFS::4.$.Trace.ParseTrc", "a");
      if (fp)
      {
          fputs(return_val->text, fp);
          fclose(fp);
      }
  }
  #endif
/*
 * Return the structure. Note that if there was insufficient memory to
 * allocate a tag, this will return a NULL pointer, so this is safe.
 */
    //if (return_val->style & DL) Printf("HTMLLib: returned a DL\n");

    return return_val;
  }

  if (size < 2)
      RETURN(NULL);

  /* Stop doing any titleness */
  st->_stream_title=0;

  if (*(ptr+1) == '!')
  {
      st->state = Declaration;
      *html = ptr+2;
      return NULL;
  }

  #ifdef NEWSPACING
  st->lastwaspcdata=0;
  #endif

/*
 * We now think we have a tag. We extract the tag information by skipping
 * the initial '<', finding the end of the tag, and inspecting the bit
 * between the start and end pointers (*html and ptr).
 */
  ptr++; /* Skip the '<' */
  while ((ptr-start < size) && (*ptr != '\0') && (*ptr != '>') &&
                             (*ptr != '<')) {
    ptr++;
  }

  if (*ptr == '>')
    ptr++;

/* This code breaks if there happens to be a '>' in the first byte
 * after the meaningful data
 */
#if 0
/*
 * If we hit 'size' but the first element in the stream is a '<'
 * I think we have an incomplete tag, otherwise if we have moved
 * more than 'size' bytes we have run off the end of a meaningful
 * input stream.
 */
  if (ptr-start >= size) {
    if ( ((**html == '<') && (*ptr != '>')) || (ptr-start > size) ) {
      RETURN(NULL);
    }
  }
#else
  if (ptr-start >= size)
  {
      RETURN(NULL);
  }
#endif

/*
 * We are now in a safe position to believe we have a tag and that we
 * have all of the tag. Thus we can look to see what we have.
 */

  if (tag_start[0]=='/')
  {
    if (lastwaspcdata && prevhs && prevhs->text && prevhs->tag == PCDATA)
    {
      __html_strip_trailing_spaces(prevhs->text);
      if (prevhs->text[0]=='\0')
      {
        __html_free(prevhs->text, 0);
        prevhs->text=0;
        prevhs->type &=~ TYPE_MASK;
        /*prevhs->type=(prevhs->type &~ (TYPE_BODY|TYPE_FRAMESET|TYPE_NOFRAMES)) | TYPE_HEAD;*/
      }
    }
  }
  else
    st->stripleadingspace=1;

  if (tag_start[0] != '/')
  {
      next_tag=__html_find_tag(&tag_start,0);

    /* The start tag case */
      if (next_tag) {
    /*
     * If the tag we have is a tag that we need to notify the termination
     * of, then send back a NULL tag that terminates all the tags we need
     * to before returning this tag. We can do this by not moving the html
     * data pointer before returning.
     */
        if (st->needtosend[next_tag->tag_no] && next_tag->tag_no
    #ifdef TonyTables
            && !st->current_table
    #endif
           )
        {
            /* Put in a null tag (ish) */
            return_val=__html_stream_return_tag(st, &Null_Tag, NULL, END);
            return_val->type|=TYPE_BODY;
            return_val->tagno = TAG_DUMMY;
            /*return_val->style |= DUMMY;*/
        }
        else
        {
            char *p=*html;
    /*
     * Otherwise do what we need to with this pointer before returning
     * any token that it generates.
     */
          if (lastwaspcdata && next_tag->block_tag && prevhs && prevhs->text)
          {
            __html_strip_trailing_spaces(prevhs->text);
            if (prevhs->text[0]=='\0')
            {
              __html_free(prevhs->text, 0);
              prevhs->text=0;
            }
          }

          return_val = __html_stream_start_tag(st, next_tag, &p, url, size);
          /* More hackery - some tags swallow PCDATA - if the routine returns
             NULL, that indicates a tag that needs more PCDATA */
          if (p>ptr)
            *html=p;
          else if (p!=NULL)
            *html=ptr;

          /* Take off any RE (line feed) following a start tag */
          if (!st->_stream_pre || next_tag->tag_no == TAG_PRE || next_tag->tag_no == TAG_XMP || next_tag->tag_no == TAG_TEXTAREA)
              *html = __html_skip_record_end(*html, next_tag->tag_no != TAG_PRE && next_tag->tag_no != TAG_XMP && next_tag->tag_no != TAG_TEXTAREA);
        }
        return return_val;
      }
  }
  else
  {
      st->isendtag=1;
    /* Otherwise it was an end tag? */
      next_tag=__html_find_tag(&tag_start,1);

      if (next_tag) {
    /* Register that we have an end tag */
        st->stripleadingspace=next_tag->block_tag;
        return_val = __html_stream_end_tag(st, next_tag, html, url, size);
        *html=ptr;
        if (next_tag->block_tag && !st->_stream_pre)
            *html = __html_skip_record_end(*html, 1);

       return return_val;
      }
      else
        st->stripleadingspace=1;
  }

/* Update the pointer and return. This skips unwanted tags etc. */

  *html=ptr;

  return return_val;
}

/********************************************************************/
/* __html_stream_declaration                                        */
/********************************************************************/
/* Called instead of __html_stream_parse when inside a <!  > pair   */
/********************************************************************/
static HStream *__html_stream_declaration(StreamTokens *st, char **html,
                                          int size)
{
    /*
     * Currently we don't do anything with declarations. Just need
     * to skip comments
     */

    char *ptr = *html;

    while (size)
    {
//        if (*ptr == '>')
//        {
//            *html = ptr + 1;
//            st->state = Other;
//            return NULL;
//        }

        if      (*ptr == '<') st->anglecount++;
        else if (*ptr == '>') st->anglecount--;

        /* Count < and > pairs, but allow the comment close '-->' */
        /* to forcibly end the comment section.                   */

        if (
             st->anglecount < 0 ||
             (
               size >= 3         &&
               *ptr == '-'       &&
               *(ptr + 1) == '-' &&
               *(ptr + 2) == '>'
             )
           )
        {
            int inc = (*ptr == '-') ? 3 : 1;

            st->anglecount = 0;
            st->state      = Other;

            if (!st->_stream_pre)
                *html = __html_skip_record_end(ptr + inc, 1);
            else
                *html = ptr + inc;
            return NULL;
        }

//        if (*ptr == '-')
//        {
//            if (size < 2)
//            {
//                *html = ptr;
//                RETURN(NULL);
//            }
//            if (*(ptr+1) == '-')
//            {
//                int i;
//
//                /* Check for a run of -s */
//                for (i=2; i<size; i++)
//                {
//                    if (ptr[i] != '-')
//                    {
//                        *html = ptr+i;
//                        st->state = Comment;
//                        return NULL;
//                    }
//                }
//                /* Have not reached the end of this run yet */
//                *html = ptr;
//                RETURN(NULL);
//            }
//        }

        ptr++;
        size--;
    }

    *html=ptr;
    RETURN(NULL);
}

// /********************************************************************/
// /* __html_stream_comment                                            */
// /********************************************************************/
// /* Called instead of __html_stream_parse when inside a -- -- pair   */
// /********************************************************************/
// static HStream *__html_stream_comment(StreamTokens *st, char **html,
//                                       int size)
// {
//     char *ptr = *html;
//     while (size)
//     {
//         if (*ptr == '-')
//         {
//             if (size < 2)
//             {
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//             if (*(ptr+1) == '-')
//             {
//                 int i;
//
//                 /* Check for a run of -s */
//                 for (i=2; i<size; i++)
//                 {
//                     if (ptr[i] != '-')
//                     {
//                         *html = ptr+i;
//                         st->state = Declaration;
//                         return NULL;
//                     }
//                 }
//                 /* Have not reached the end of this run yet */
//                 *html = ptr;
//                 RETURN(NULL);
//             }
//         }
//         ptr++;
//         size--;
//     }
//
//     *html = ptr;
//     RETURN(NULL);
// }

/********************************************************************/
/* static unsigned int __html_stream_style(void)                    */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

unsigned int __html_stream_style(StreamTokens *st)
{
  unsigned int return_val=0;

  /*
  if (st->_stream_title) {
    return_val |= TITLE;
  }
  else {
  */
    if (st->_stream_bold)           return_val |= BOLD;
    if (st->_stream_italic)         return_val |= ITALIC;
    if (st->_stream_tt)             return_val |= TT;
    if (st->_stream_a)              return_val |= A;
    if (st->_stream_img)            return_val |= IMG;
    if (st->_stream_nobr)           return_val |= NOBR;
    if (st->_stream_p)           { return_val |= P; st->_stream_p=0; }
                                    return_val |= st->_stream_h;
    if (st->_stream_pre)	    return_val |= PRE;

    if (st->send_list > 0) {
      if (st->send_list & DL) {
        if (st->_stream_dl)	    return_val |= DL;
      }
      if (st->send_list & UL) {
        if (st->_stream_ul)	    return_val |= UL;
      }
      st->send_list = 0;
    }
    /*if (st->_stream_li)	            return_val |= LI;*/
    if (st->_stream_dt)	    	    return_val |= DT;
    if (st->_stream_dd)	    	    return_val |= DD;
    if (st->_stream_br)           { return_val |= BR ; st->_stream_br=0; }
    if (st->_stream_blockquote)     return_val |= BLOCKQUOTE;
    if (st->_stream_address)        return_val |= ADDRESS;
    if (st->_stream_h && st->_stream_halign)
    {
        switch (st->_stream_halign)
        {
            case 2: return_val |= CENTER; break;
            case 3: return_val |= RIGHT; break;
        }
    }
    else
    {
        if (st->_stream_centre)	    return_val |= CENTER;
        if (st->_stream_right)	    return_val |= RIGHT;
    }
    if (st->_stream_sub)	    return_val |= SUB;
    if (st->_stream_sup)	    return_val |= SUP;
    if (st->_stream_u)              return_val |= UNDERLINE;
    if (st->_stream_strike)         return_val |= STRIKE;
    if (st->_stream_anchor != NULL) return_val |= A;
  /*}*/

  return return_val;
}

/********************************************************************/
/* static unsigned int __html_stream_type(void)                     */
/********************************************************************/
/* This routine takes the variables declared above and reworkes     */
/* them into the flags word as defined in ^.h.tags ready for being  */
/* passed back to the renderer on a block of text. This needs to be */
/* expanded to include FORM elements                                */
/********************************************************************/

unsigned int __html_stream_type(StreamTokens *st, unsigned int tag_type, int start)
{
  unsigned int temp=tag_type;

  if (st->_stream_title) {
    temp = TYPE_HEAD;

  } else if (st->_stream_frameset) {
    temp = TYPE_FRAMESET;
  }

  if (st->_stream_noframes) {
    temp |= TYPE_NOFRAMES;
  }

  temp |= (((unsigned int) start) << TYPE_START_SHIFT);

  if (st->_stream_colour != NULL) {
    if (st->_stream_colour->colour_valid)
      temp |= TYPE_COLOURED;
  }

  return temp;
}

/********************************************************************/
/* static unsigned int __html_stream_indent(void)                   */
/********************************************************************/
/* Given all the status variable attempt to work out the indent     */
/* level at this point in time	 	    	     	 	    */
/********************************************************************/
unsigned int __html_stream_indent(StreamTokens *st)
{
  return ((unsigned int) st->_stream_dl -
                         st->_stream_dt +
  	 	         st->_stream_ol +
  	 	         st->_stream_ul);
}

#if 0
static char *strnchrs(char *start, const char *c, const char *end)
{
    const char *p;

    while (start < end)
    {
        for (p = c; *p; p++)
            if (*start == *p)
                return start;
        start++;
    }
    return 0;
}
#endif

/********************************************************************/
/* static char * __html_stream_grab_pcdata(char **input, int size)  */
/********************************************************************/
/* This routine returns a local copy of any PCDATA encountered at   */
/* this point, including feeding it through the relevant stripping  */
/* code etc. This routine only reads up to the next '<' sign  	    */
/********************************************************************/
static char *__html_stream_grab_pcdata(char **input, int contig, int after_tag)
{
  char *end;
  char *ret;

  if (after_tag)
      end = __html_skip_record_end(*input, 1);
  else
      end = *input;

carryon:
/*
 * Find the start of the next tag, end of the input stream, or the
 * end of the chunk by size, which ever is the sooner.
 */
  while ((*end != '\0') && (*end != '<') && (*end != '&'))
  {
      end++;
  }

/* If we have gone over the end of the size limit, shuffle back a bit */
  if (*end == '\0') {
    if (contig)
        RETURN(NULL);  /* Can't be sure we have all PCDATA yet - we'll come back later */
  } else if (*end == '&')
  {
      /* Check we don't have half an escape code */
      char *stop;

      for (stop = end + 1; *stop != '\0' && (isalnum(*stop) || *stop=='#' || *stop=='&'); stop++)
        continue;

      if (*stop == ';')
      {
          end = stop + 1;
          goto carryon;
      }
      else if (*stop)
      {
          end = stop;
          goto carryon;
      }
  }

/*
 * grab a copy of what we have and return it, moving the input
 * pointer accordingly.
 */
  ret=strndup(*input,(end-*input));
  __html_strip_control_codes(ret);

  *input=end;
  return ret;

}

/********************************************************************/
/* static HStream __html_stream_start_tag(Tag next_tag, char **html)*/
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_start_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
#ifndef NEWSPACING
    st->stripleadingcr=1;
#endif

    __html_process_attributes(st, next_tag, *html, url);

    switch(next_tag->tag_no)
    {
      #ifdef TABLE_SUPPORT
      case TAG_TR:
      case TAG_TD:
      case TAG_TH:
      case TAG_TABLE:      return __html_stream_return_tag(st,next_tag,html,END,url);
      #endif
      case TAG_INPUT:
      case TAG_SELECT:
      case TAG_OPTION:
      case TAG_TEXTAREA:
      case TAG_FORM:       return __html_form_handler(st, next_tag, html, size);
      case TAG_MAP:        return __html_map_handler(st);
      case TAG_AREA:       return __html_stream_area(st, html, next_tag);
      case TAG_APPLET:
      case TAG_OBJECT:     return __html_stream_object(st, html, next_tag);
      case TAG_PARAM:      return __html_stream_param(st, html, next_tag);
      case TAG_EMBED:      return __html_stream_embed(st, html, next_tag);
      case TAG_BASEFONT:   if (ATTR_VAL(FONTSIZE) >= 1 && ATTR_VAL(FONTSIZE) <= 7)
                               st->_stream_basefont = ATTR_VAL(FONTSIZE);
                           break;
      case TAG_FONT:  {     int first=1;

                            if (ATTR_SET(COLOUR))
                                add_colour_info(st, ATTR_VAL(COLOUR), &first);

                            if (ATTR_SET(FONTSIZE))
                                add_size_info(st, ATTR_STR(FONTSIZE), &first);

                            break;
                      }
      case TAG_BIG:   {     int first=1;

                            add_size_info(st, "+1", &first);
                            break;
                      }

      case TAG_ACRONYM:
      case TAG_SMALL: {     int first=1;

                            add_size_info(st, "-1", &first);
                            break;
                      }
      case TAG_CENTER:     st->_stream_centre++; break;
      case TAG_ADDRESS:    st->_stream_address++; break;
      case TAG_BLOCKQUOTE: st->_stream_blockquote++; break;
      case TAG_XMP:
      case TAG_PRE:        st->_stream_pre++; break;
      case TAG_H1:
      case TAG_H2:
      case TAG_H3:
      case TAG_H4:
      case TAG_H5:
      case TAG_H6:     st->_stream_h=next_tag->tag;
                       st->_stream_halign=ATTR_VAL(ALIGN);
                       break;
      case TAG_MENU:
      case TAG_DIR:
      case TAG_UL:     st->_stream_ul++;  /* Needed for indent level */
      	   	       st->send_list|=UL;
      	   	       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
      	   	       {
      	   	           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = 'u';
      	   	       }
                       break;
      case TAG_OL:     st->_stream_ol++;  /* Needed for indent level */
                       if (st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           int start = ATTR_VAL(STARTattr);
                           int style = ATTR_VAL(TYPE);
                           if (ATTR_SET(STARTattr))
                               start--;
                           if (!style)
                               style = '1';
                           st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = start;
                           st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = style;
                       }
      	   	       break;
      case TAG_DL:     st->_stream_dl++;  /* Needed for indent level */
      	   	       st->_stream_dt=0;
      	   	       st->_stream_dd=0;
      	   	       st->send_list|=DL;
      	   	       //Printf("HTMLLib: Should send a DL now\n");
      	   	       break;

      case TAG_LI: {
                       HStream *ret;

                       st->_stream_li++; /* Needed for indent level? */
                       if (st->_stream_ol + st->_stream_ul > 0 && st->_stream_ol + st->_stream_ul <= MAX_OL)
                       {
                           if (ATTR_SET(VALUE))
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(VALUE);
                           else
                               st->_stream_olcount[st->_stream_ol + st->_stream_ul - 1] ++;

                           if (ATTR_SET(TYPE))
                               st->_stream_olstyle[st->_stream_ol + st->_stream_ul - 1] = ATTR_VAL(TYPE);
                       }

                       ret = __html_stream_return_tag(st,next_tag,html,START);
                       if (ret)
                           __html_construct_ol_text(st, ret);
                       return ret;
                   }
      case TAG_DT:     if (st->_stream_dt || !st->_stream_dl)
                       {
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
                       }
                       st->_stream_dt=1; /* Needed for indent level? */
                       st->_stream_dd=0;
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/
      case TAG_DD:     if (st->_stream_dd || !st->_stream_dl)
                       {
                           char *br = "BR>";
                           /* Send back a BR tag - easiest way to get a linebreak */
                           return __html_stream_return_tag(st, __html_find_tag(&br, 0), html, START);
                       }
                       st->_stream_dd=1; /* Needed for indent level? */
                       st->_stream_dt=0;
                       break;
      	   	       /*return __html_stream_return_tag(st,next_tag,html,START);*/

      case TAG_HR:     return __html_stream_hr(st, html, next_tag);
      case TAG_BR:     return __html_stream_return_tag(st,next_tag,html,START);
/*
 * We didnt find the tag in that lot, so look in the last 10. This is
 * sort of complicated by the fact that some of these are in the
 * head and some are in the body list, and there are <HEAD> and <BODY>
 * too.
 */
      case TAG_P:   {  int align = ATTR_VAL(ALIGN);
                       st->_stream_p=1;
                       if (align != 0 && !st->_stream_palign)
                       {
                           st->_stream_palign = 1;
                           st->_stream_oldcentre = st->_stream_centre;
                           st->_stream_oldright = st->_stream_right;
                       }
                       if (align == 1)
                           st->_stream_centre = st->_stream_right = 0;
                       else if (align == 2)
                           st->_stream_centre = 1, st->_stream_right = 0;
                       else if (align == 3)
                           st->_stream_centre = 0, st->_stream_right = 1;
                       else if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
                       break;
                     }
      case TAG_DIV:    if (st->_stream_palign)
                       {
                           st->_stream_palign = 0;
                           st->_stream_centre = st->_stream_oldcentre;
                           st->_stream_right = st->_stream_oldright;
                       }
                       st->_stream_h = 0;
                       switch (ATTR_VAL(ALIGN))
                       {
                           default:
                           case 1: st->_stream_centre = st->_stream_right = 0; break;
                           case 2: st->_stream_centre = 1; st->_stream_right = 0; break;
                           case 3: st->_stream_centre = 0; st->_stream_right = 1; break;
                       }
                       break;
      case TAG_IMG:    return __html_stream_image(st,html, next_tag);
      case TAG_A:      __html_stream_anchor(st, html, next_tag); break;
      case TAG_SAMP:
      case TAG_CODE:
      case TAG_KBD:
      case TAG_VAR:
      case TAG_TT:     st->_stream_tt++; break;
      case TAG_EM:
      case TAG_CITE:
      case TAG_DFN:
      case TAG_ITALIC: st->_stream_italic++; break;
      case TAG_STRONG:
      case TAG_BOLD:   st->_stream_bold++; break;
      case TAG_NOBR:   st->_stream_nobr++; break;
      case TAG_SUB:    st->_stream_sub++; break;
      case TAG_SUP:    st->_stream_sup++; break;
      case TAG_INS:
      case TAG_U:      st->_stream_u++; break;
      case TAG_Q:      return __html_stream_q(st, html, START);

      case TAG_S:
      case TAG_DEL:
      case TAG_STRIKE: st->_stream_strike++; break;
      #ifdef TonyTables
      case TAG_TR:     return __html_table_row_start_tag(st, next_tag, html, url, size);
      case TAG_TD:     return __html_table_data_start_tag(st, next_tag, html, url, size);
      case TAG_TH:     return __html_table_head_start_tag(st, next_tag, html, url, size);
      case TAG_TABLE:  return __html_table_start_tag(st, next_tag, html, url, size);
      #endif
      case TAG_META: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_meta), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->meta.http_equiv = ATTR_STR(HTTP_EQUIV);
                  ret->info->meta.name       = ATTR_STR(NAME);
                  ret->info->meta.content    = ATTR_STR(CONTENT);
                  ret->info->meta.scheme     = ATTR_STR(SCHEME);
              }
              return ret;
      }
      case TAG_TITLE:  st->_stream_title++; break;
      case TAG_BASE:   __html_stream_base(st); break;
      case TAG_ISINDEX: st->_stream_isindex=1; break;
      case TAG_SCRIPT:  st->state = Script; return NULL;
      case TAG_STYLE:   st->state = Style; return NULL;
      case TAG_FRAME:   return __html_stream_frame(st, html, next_tag);
      case TAG_BODY: {
              HStream *ret=__html_stream_return_tag(st,next_tag,html,START);
              if (ret)
              {
                  ret->info = (elementinfo *)__html_malloc(sizeof (elementinfo_body), 1);
                  if (!ret->info) { __html_free(ret, 0); return NULL; }
                  ret->info->body.onload = ATTR_STR(ONLOAD);
                  ret->info->body.onunload = ATTR_STR(ONUNLOAD);
                  ret->info->body.background = ATTR_STR(BACKGROUND);
                  ret->info->body.text = ATTR_SET(FGCOL) ? ATTR_VAL(FGCOL) : NULL_COLOUR;
                  ret->info->body.bgcolour = ATTR_SET(BGCOL) ? ATTR_VAL(BGCOL) : NULL_COLOUR;
                  ret->info->body.link = ATTR_SET(LINKCOL) ? ATTR_VAL(LINKCOL) : NULL_COLOUR;
                  ret->info->body.vlink = ATTR_SET(VLINK) ? ATTR_VAL(VLINK) : NULL_COLOUR;
                  ret->info->body.alink = ATTR_SET(ALINK) ? ATTR_VAL(ALINK) : NULL_COLOUR;
              }
              return ret;
          }
      case TAG_FRAMESET:return __html_stream_frameset(st, html, next_tag);
      case TAG_NOFRAMES:
              st->_stream_noframes = 1;
              break;
    }
/* In theory we dont need to do any more so we can return here */
    return NULL;
}

#define DEC(a) if ((a) > 0) { (a)--; }

/********************************************************************/
/* static Hstream *__html_stream_end_tag(Tag next_tag, char **html) */
/********************************************************************/
/* This takes a tag that is known to be a start tag and processes   */
/* it setting the correct bits in the various status words	    */
/* This is really only computational work but is in its own fn for  */
/* ease of code reading		     	      	    	       	    */
/********************************************************************/
static HStream *__html_stream_end_tag(StreamTokens *st, Tag *next_tag, char **html, char *url, int size)
{
/* Make a note of this token for later use */
  st->needtosend[next_tag->tag_no] = 1;
/*
 * we have a start tag. Big case statement alert - work from the bottom
 * of the list upwards for safty :) */

  switch(next_tag->tag_no) {
    #ifdef TABLE_SUPPORT
    case TAG_TR:
    case TAG_TD:
    case TAG_TH:
    case TAG_TABLE: return __html_stream_return_tag(st,next_tag,html,END,url);
    #endif

    case TAG_FORM:
      return __html_stream_end_form(st, html);

    case TAG_MAP:
      st->_stream_map=0;
      break;

    case TAG_SELECT:
      st->_stream_select=0;
      break;

    case TAG_BIG:
    case TAG_SMALL:
    case TAG_ACRONYM:
    case TAG_FONT:
      font_tag_closed(st);
      #ifndef NEWSPACING
      st->stripleadingcr = 0;
      #endif
      break;

    case TAG_P:
      if (st->_stream_palign)
      {
          st->_stream_palign = 0;
          st->_stream_centre = st->_stream_oldcentre;
          st->_stream_right = st->_stream_oldright;
      }
      break;

    case TAG_CENTER:
      st->_stream_br = 1;
      DEC(st->_stream_centre);
      break;

    case TAG_DIV:
      st->_stream_br = 1;
      st->_stream_palign = 0;
      st->_stream_centre = 0;
      st->_stream_right = 0;
      break;

    case TAG_ADDRESS:
      DEC(st->_stream_address);
      break;

    case TAG_BLOCKQUOTE:
      DEC(st->_stream_blockquote);
      break;

    case TAG_MENU:
    case TAG_DIR:
    case TAG_UL:
      DEC(st->_stream_ul);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_OL:
      DEC(st->_stream_ol);
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url) */;

    case TAG_DL:
      DEC(st->_stream_dl);
      /* Cope with nested <DL>s: if we're still in a DL, for valid HTML
         we must be in a DD! */
      st->_stream_dt=0;
      st->_stream_dd=st->_stream_dl ? 1 : 0;
      return NULL /*__html_stream_return_tag(st,next_tag,html,END,url)*/;

    case TAG_DD:
      st->_stream_dd = 0;
      st->_stream_br = 1; /* Yuck. */
      break;

    case TAG_LI:
      DEC(st->_stream_li);
      break;

    case TAG_DT:
      st->_stream_dt = 0;
      break;

    case TAG_XMP:
    case TAG_PRE:
      DEC(st->_stream_pre);
      break;

    case TAG_H1:
    case TAG_H2:
    case TAG_H3:
    case TAG_H4:
    case TAG_H5:
    case TAG_H6:
      st->_stream_h = 0;
      break;

    case TAG_A:
    {
      /* Cope with tossers that do <A NAME="fred"></A> */
      if (st->need_to_send_name)
      {
          HStream *return_val;
          st->need_to_send_name=0;

          /* To stop it stripping spaces before the <A NAME="x"> */
          st->isendtag=0;

          return_val=HStreamalloc(st, TAG_A);
          if (return_val)
          {
              return_val->style=__html_stream_style(st)|PCDATA;
              return_val->type=__html_stream_type(st, TYPE_BODY, END);
              return_val->indent=__html_stream_indent(st);
              if (st->_stream_anchor != NULL) {
                #ifdef LINEONE_HACK
                return_val->onclick=st->_stream_anchor->onclick;
                #endif
                return_val->anchor=st->_stream_anchor->href;
                return_val->name=st->_stream_anchor->name;
                return_val->target = st->_stream_anchor->target;
              }
              fill_in_colour_info(st, return_val);
              return_val->tag=next_tag->tag;
          }
          __html_stream_end_anchor(st);
          return return_val;
      }
      __html_stream_end_anchor(st);
      break;
    }
    case TAG_SAMP:
    case TAG_CODE:
    case TAG_KBD:
    case TAG_VAR:
    case TAG_TT:
      DEC(st->_stream_tt);
      break;

    case TAG_EM:
    case TAG_CITE:
    case TAG_DFN:
    case TAG_ITALIC:
      DEC(st->_stream_italic);
      break;

    case TAG_STRONG:
    case TAG_BOLD:
      DEC(st->_stream_bold);
      break;

    case TAG_NOBR:
      DEC(st->_stream_nobr);
      break;

    case TAG_SUB:
      DEC(st->_stream_sub);
      break;

    case TAG_SUP:
      DEC(st->_stream_sup);
      break;

    case TAG_INS:
    case TAG_U:
      DEC(st->_stream_u);
      break;

    case TAG_Q:
      return __html_stream_q(st, html, END);

    case TAG_S:
    case TAG_DEL:
    case TAG_STRIKE:
      DEC(st->_stream_strike);
      break;

  #ifdef TonyTables
    case TAG_TR:    return __html_table_row_end_tag(st, next_tag, html, url);
    case TAG_TD:    return __html_table_data_end_tag(st, next_tag, html, url);
    case TAG_TH:    return __html_table_head_end_tag(st, next_tag, html, url);
    case TAG_TABLE: return __html_table_end_tag(st, next_tag, html, url);
  #endif
  #if 0
    /* Not required because ANY tag will terminate a TITLE */
    case TAG_TITLE:
      DEC(st->_stream_title);
      break;
  #endif
    case TAG_APPLET:
    case TAG_OBJECT:
      __html_stream_end_object(st);
      break;
    case TAG_FRAMESET:
      if (st->_stream_frameset == 1 && st->had_frame) st->dead = 1;
      DEC(st->_stream_frameset);
      NOT_USED(size);
      break;
    case TAG_NOFRAMES:
      st->_stream_noframes = 0;
      break;
  }
  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_imagechar **html)                  */
/********************************************************************/
/* Knowing that we are in a image tag, grab the anchor information  */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_image(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  char        *ptr;

  /* Throw out certain nasty image thingies which probably don't */
  /* contribute much to the page alignment...                    */

  if (ATTR_VAL(ALIGN) == 4 || ATTR_VAL(ALIGN) == 5)
  {
    if (
         (
           ATTR_SET(WIDTH) &&
           ATTR_VAL(WIDTH) <= 2
         )
         ||
         (
           ATTR_SET(WIDTH)      &&
           ATTR_SET(HEIGHT)     &&
           ATTR_VAL(WIDTH) <= 6 &&
           ATTR_VAL(HEIGHT) > ATTR_VAL(WIDTH) * 15
         )
       )
       return NULL;
  }

  return_val=HStreamalloc(st, TAG_IMG);
  if (return_val != NULL) {
    return_val->style=__html_stream_style(st) | IMG;
    return_val->type=__html_stream_type(st, next_tag->type, START);
    if (ATTR_SET(ISMAP))
        return_val->type|=TYPE_ISMAP;

    if (ATTR_SET(USEMAP))
    {
        elementinfo_object *info;
        info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
        if (info)
        {
            return_val->info = (elementinfo *) info;
            info->usemap = ATTR_STR(USEMAP);
            info->maps = st->maps;
            return_val->type |= TYPE_ISCLIENTMAP;
        }
    }


    switch (ATTR_VAL(ALIGN))
    {
        case 1: return_val->type|=_html_top<<TYPE_ALIGN_SHIFT; break;
        case 2: return_val->type|=_html_middle<<TYPE_ALIGN_SHIFT; break;
        case 3: return_val->type|=_html_bottom<<TYPE_ALIGN_SHIFT; break;
        case 4: return_val->type|=_html_left<<TYPE_ALIGN_SHIFT; break;
        case 5: return_val->type|=_html_right<<TYPE_ALIGN_SHIFT; break;
        case 6: return_val->type|=_html_centre<<TYPE_ALIGN_SHIFT; break;
        default:return_val->type|=_html_none<<TYPE_ALIGN_SHIFT; break;
    }

    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        return_val->target=st->_stream_anchor->target;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
    }

    st->need_to_send_name=0;

    return_val->text=ATTR_STR(ALT);

    return_val->src=ATTR_STR(SRC);

    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    if (ATTR_SET(HEIGHT))
    {
        return_val->rows = ATTR_VAL(HEIGHT) | (1<<24);
        if (st->curattrs[HEIGHT].miscflag)
            return_val->rows |= UNITS_PERCENT << 28;
        else
            return_val->rows |= UNITS_PIXELS << 28;
    }

    return_val->maxlen=ATTR_SET(BORDER) ? ATTR_VAL(BORDER) :
                                          return_val->anchor ? 2 : 0;

//    /* If one of HEIGHT or WIDTH are missing, remove the other one as
//       well to prevent confusion */
//    if (return_val->rows==0 || return_val->cols==0)
//        return_val->cols=return_val->rows=0;

    memset(st->needtosend, 0, sizeof st->needtosend);

  }

  return_val->tag=IMG;
  return_val->indent=__html_stream_indent(st);
  fill_in_colour_info(st, return_val);

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_hr()                               */
/********************************************************************/
/* Knowing that we are in a HR tag, grab the anchor information     */
/* associated with it and return this info. 	       		    */
/********************************************************************/
static HStream *__html_stream_hr(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  char        *ptr;
  int         noshade=0;
  int         alignment=_html_centre;

  return_val=HStreamalloc(st, TAG_HR);
  if (return_val != NULL) {
    if (ATTR_SET(NOSHADE))
        noshade=TYPE_NOSHADE;
    switch (ATTR_VAL(ALIGN))
    {
        case 1: alignment = _html_left; break;
        case 2: alignment = _html_right; break;
        case 3: alignment = _html_centre; break;
        default:alignment = _html_none; break;
    }
    if (ATTR_SET(WIDTH))
    {
        return_val->cols = ATTR_VAL(WIDTH) | (1<<24);
        if (st->curattrs[WIDTH].miscflag)
            return_val->cols |= UNITS_PERCENT << 28;
        else
            return_val->cols |= UNITS_PIXELS << 28;
    }
    return_val->size=ATTR_VAL(SIZE);

    memset(st->needtosend, 0, sizeof st->needtosend);
    if (st->_stream_anchor!=NULL) {
        return_val->anchor=st->_stream_anchor->href;
        return_val->name=st->_stream_anchor->name;
        #ifdef LINEONE_HACK
        return_val->onclick=st->_stream_anchor->onclick;
        #endif
        st->need_to_send_name=0;
    }
    return_val->style=__html_stream_style(st) | HR;
    return_val->type=__html_stream_type(st, next_tag->type, START) | noshade;
    return_val->type &= ~TYPE_ALIGN_MASK;
    return_val->type |= alignment << TYPE_ALIGN_SHIFT;
    return_val->indent=__html_stream_indent(st);
    return_val->tag=HR;
    /* Get rid of the anchor info block */

    fill_in_colour_info(st, return_val);
  }


/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_anchor(char **html)                */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_anchor(StreamTokens *st, char **html, Tag *next_tag)
{
  AnchorInfo *anc;
  int gotsomething=0;

  NOT_USED(html); NOT_USED(next_tag);

  if (st->_stream_anchor != NULL) __html_stream_end_anchor(st);

  anc = (AnchorInfo *) __html_malloc(sizeof(AnchorInfo), 1);
  if (!anc) return NULL;

  if (ATTR_SET(NAME))
      anc->name = ATTR_STR(NAME), gotsomething=1, st->need_to_send_name = 1;

  if (ATTR_SET(HREF))
      anc->href = ATTR_STR(HREF), gotsomething=1;

  if (ATTR_SET(TARGET))
      anc->target = ATTR_STR(TARGET), gotsomething=1;

  #ifdef LINEONE_HACK
  if (ATTR_SET(ONCLICK))
      anc->onclick = ATTR_STR(ONCLICK), gotsomething=1;
  #endif

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      anc->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      anc->coords = (int *) __html_malloc(sizeof(int), 2);

  if (anc->coords)
      anc->coords[0] = ATTR_VAL(SHAPE);

  if (gotsomething)
  {
      if (!anc->target)
          anc->target = strdup(st->target);

      st->_stream_anchor = anc;
  }

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_frame (char **html)                */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frame (StreamTokens *st, char **html, Tag *next_tag)
{
  HStream     *return_val;
  char        *ptr;

  if (!st->usingframes)
      return NULL;

  return_val=HStreamalloc(st, TAG_FRAME);

  if (return_val != NULL)
  {
    st->had_frame = 1;

    return_val->style  = __html_stream_style(st) | FRAME;
    return_val->tag    = FRAME;
    return_val->type = __html_stream_type(st, next_tag->type, START);
    return_val->size   = st->_stream_frameset;
    return_val->type |= ATTR_VAL(SCROLLING) << TYPE_SCROLLING_SHIFT;
    if (ATTR_SET(NORESIZE))
        return_val->type |= TYPE_NORESIZE;
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
    if (ATTR_SET(BORDERCOLOUR))
        return_val->maxlen = ATTR_VAL(BORDERCOLOUR) | 1;
    return_val->rows   = ATTR_VAL(MARGINHEIGHT);
    return_val->cols   = ATTR_VAL(MARGINWIDTH);
    return_val->name   = ATTR_STR(NAME);
    return_val->src    = ATTR_STR(SRC);
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, 1, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_frameset (char **html)             */
/********************************************************************/
/* Given a frame start tag, extract the relevant information        */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_frameset(StreamTokens *st, char **html, Tag *tag)
{
  HStream     *return_val;
  char        *ptr;

  if (!st->usingframes)
      return NULL;

  if (!ATTR_SET(ROWS) && !ATTR_SET(COLS)) return NULL;

  st->_stream_frameset++;
  st->_stream_noframes = 0;
  return_val=HStreamalloc(st, TAG_FRAMESET);
  if (return_val != NULL) {
    return_val->style  = __html_stream_style(st) | tag->tag;
    return_val->tag    = tag->tag;
    return_val->type   = __html_stream_type(st, tag->type, START);
    return_val->size   = st->_stream_frameset;
    if (ATTR_SET(ROWS))
    {
        parse_rowcols(ATTR_STRPEEK(ROWS), NULL, &return_val->rows);
        return_val->name = __html_malloc(sizeof(unsigned int), return_val->rows);
        if (return_val->name)
            parse_rowcols(ATTR_STRPEEK(ROWS), (unsigned int *) (return_val->name), NULL);
    }
    if (ATTR_SET(COLS))
    {
        parse_rowcols(ATTR_STRPEEK(COLS), NULL, &return_val->cols);
        return_val->value = __html_malloc(sizeof(unsigned int), return_val->cols);
        if (return_val->value)
            parse_rowcols(ATTR_STRPEEK(COLS), (unsigned int *) (return_val->value), NULL);
    }
    if (ATTR_SET(FRAMEBORDER))
    {
        char *p = ATTR_STRPEEK(FRAMEBORDER);
        UPPER_CASE(p);

        if (strstr(p, "YES")) return_val->indent = 8;
        else if (strstr(p, "NO")) return_val->indent = 0;
        else
        {
            return_val->indent = atoi(p);
            if (return_val->indent == 1)
                return_val->indent = 8;
        }
    }
    else
        return_val->indent = 8;
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  ptr=*html + 1;
  while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
  if (*ptr=='>') ptr++;
  *html=ptr;

  __html_stream_grab_pcdata(html, 1, 1);
  return return_val;
}

/********************************************************************/
/* static HStream *__html_stream_base(char **html)                  */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static HStream *__html_stream_base(StreamTokens *st)
{
  if (ATTR_SET(HREF))
  {
      if (st->url) __html_free(st->url, 0);
      st->url = ATTR_STR(HREF);
  }

  if (ATTR_SET(TARGET))
  {
      if (st->target) __html_free(st->target, 0);
      st->target = ATTR_STR(TARGET);
  }

  return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_end_anchor(void)                   */
/********************************************************************/
/* Given an anchor start tag, extract the relevant information      */
/* associated with this tag.  	      	  	   		    */
/********************************************************************/
static void __html_stream_end_anchor(StreamTokens *st)
{
  /* Need to rewrite this ! */
  __html_stream_free_anchor(&(st->_stream_anchor));
}

#if 0
/********************************************************************/
/* static HStream *__html_stream_end_header(char **html)            */
/********************************************************************/
/* Given the end of the header block, return a token indicating     */
/* things like if ISINDEX is set for example.  	     		    */
/********************************************************************/
static HStream *__html_stream_end_header(char **html)
{
  NOT_USED(html);

  return NULL;
}
#endif

/********************************************************************/
/* static void __html_style_init(styleinfo *s)                      */
/********************************************************************/
/* This small routine resets all the styles to their initial        */
/* value      	      	     	     	       	  		    */
/********************************************************************/
void __html_style_init(styleinfo *s)
{
  memset(s, 0, sizeof *s);
}

/********************************************************************/
/* static void __html_stream_init(void)                             */
/********************************************************************/
/* This small routine resets all the variables to their initial     */
/* value      	      	     	     	       	  		    */
/********************************************************************/
StreamTokens *__html_stream_init(void)
{
  StreamTokens *st;

  st=(StreamTokens *)calloc(1, sizeof(StreamTokens)); /* zeroes everything */
  if (st==NULL) return NULL;

  __html_style_init(&st->_stream_style);

  st->_stream_basefont   =3;
  st->stripleadingspace  =1;

  return st;
}

/********************************************************************/
/* static HStream *__html_stream_return_tag (Tag tag, char **html)  */
/********************************************************************/
/* Given any old tag block that isnt a PCDATA, create and return a  */
/* stream element for that tag.	       	       	      	  	    */
/********************************************************************/
/*static*/ HStream *__html_stream_return_tag(StreamTokens *st, Tag *tag, char **html, int start)
{
  HStream *ret;
  char *ptr;

  ret=HStreamalloc(st, tag->tag_no);
  if (ret != NULL) {

      ret->style=__html_stream_style(st) | tag->tag; // This appears to put dodgy stuff in the style word
      ret->type=__html_stream_type(st, tag->type, start);

      ret->indent=__html_stream_indent(st);

      fill_in_colour_info(st, ret);

      if (st->_stream_anchor!=NULL) {
        #ifdef LINEONE_HACK
        ret->onclick=st->_stream_anchor->onclick;
        #endif
        ret->anchor=st->_stream_anchor->href;
        ret->name=st->_stream_anchor->name;
        st->need_to_send_name=0;
        ret->target=st->_stream_anchor->target;
      }

      ret->tag=tag->tag;

      memset(st->needtosend, 0, sizeof st->needtosend);
  }

/*
 * This routine is called with the understanding that it will update
 * the HTML pointer. Move it to past the next > or the end of the input
 * whichever is sooner. In theory it should be the former.
 */
  if (html != NULL) {
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

  return ret;
}

/********************************************************************/
/* static void __html_stream_free_anchor(AnchorInfo **anchor)       */
/********************************************************************/
/* Given an anchor info block free up all the memory associated     */
/* with it, and set it back to NULL   	      	     		    */
/********************************************************************/
/*static*/ void __html_stream_free_anchor(AnchorInfo **anchor)
{
AnchorInfo *anc=*anchor;

  if (!anchor || !anc) return;

  /* Don't free href or target - HStreams point directly to them.
   * They will get freed normally when the stream is discarded.
   */
  __html_free(anc,0);

  *anchor=NULL;
}

/********************************************************************/
/* static HStream * __html_form_handler(StreamTokens *st, Tag ne... */
/********************************************************************/
/* General purpose forms handling but. Since all form elements are  */
/* basically derived from the same generic idea, it makes sense to  */
/* keep them in one bit. NOTE: LINKS WITHIN FORMS ARE DUFF AT THE   */
/* moment due to an earlier oversight. Fix soon	      	      	    */
/********************************************************************/
static HStream * __html_form_handler(StreamTokens *st, Tag *next_tag, char **html, int size)
{
HStream *ret;
char *ptr; /* Hackery - used to get text after tag */
char *p;

/* Since a form shouldnt be within an anchor, we can clear the anchor state */
  /*if (st->_stream_forms) __html_stream_free_anchor(&(st->_stream_forms));*/


/* Fill in a return slip :) */
  ret=HStreamalloc(st, next_tag->tag_no);
  if (!ret) return ret;

   ret->flags = 0;
   fill_in_colour_info(st, ret);

  if (next_tag->tag_no == TAG_OPTION ||
      next_tag->tag_no == TAG_TEXTAREA ||
      next_tag->tag_no == TAG_SELECT)
  {
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;
  }

/* This is the nasty bit :) Decide what to do based on the tag */
  switch(next_tag->tag_no) {
    case TAG_FORM: /* Fill in method bit etc */
    	       ret->tag=FORM;
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_form), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
               if (ATTR_SET(ACTION))
    	           ret->info->form.action     = ATTR_STR(ACTION);
    	       else
    	           ret->info->form.action     = strdup(st->url);
    	       ret->info->form.method         = (formmethod) ATTR_VAL(METHOD);
               ret->info->form.accept_charset = ATTR_STR(ACCEPT_CHARSET);
               ret->info->form.enctype        = ATTR_STR(ENCTYPE);
               ret->info->form.onsubmit       = ATTR_STR(ONSUBMIT);
               ret->info->form.onreset        = ATTR_STR(ONRESET);
               if (ATTR_SET(TARGET))
                   ret->info->form.target     = ATTR_STR(TARGET);
               else
                   ret->info->form.target     = strdup(st->target);
               st->needtosend[TAG_FORM] = 1;
	       break;

    case TAG_INPUT: /* Do lots of bits */
    {
               elementinfo_input *info;

    	       info=(elementinfo_input *)__html_malloc(sizeof(elementinfo_input), 1);
    	       ret->info=(elementinfo *)info;
    	       if (!info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
               ret->indent=__html_stream_indent(st);
	       /* INPUTy bits */
               info->type      = (inputtype) ATTR_VAL(TYPE);
	       info->name      = ATTR_STR(NAME);
	       info->value     = ATTR_STR(VALUE);
               info->checked   = ATTR_SET(CHECKED);
               info->disabled  = ATTR_SET(DISABLED);
               info->readonly  = ATTR_SET(READONLY);
	       info->size      = ATTR_VAL(SIZE);
	       info->maxlength = ATTR_VAL(MAXLENGTH);
	       info->src       = ATTR_STR(SRC);
	       info->alt       = ATTR_STR(ALT);
	       info->usemap    = ATTR_STR(USEMAP);
	       info->align     = (imgalign) ATTR_VAL(ALIGN);
               info->tabindex  = ATTR_VAL(TABINDEX);
               info->onfocus   = ATTR_STR(ONFOCUS);
               info->onblur    = ATTR_STR(ONBLUR);
               info->onselect  = ATTR_STR(ONSELECT);
               info->onchange  = ATTR_STR(ONCHANGE);
               info->accept    = ATTR_STR(ACCEPT);
	       if (info->type == inputtype_TEXT || info->type == inputtype_PASSWORD) {
  	         if (info->maxlength > 0) {
  	           ret->text=strndup(info->value, info->maxlength); /* Ensure big buffer */
  	         }
  	         else {
  	           ret->text=strndup(info->value, 1024);
  	         }
  	       } else if (info->type == inputtype_IMAGE)
  	           ret->text=strdup(info->alt);
	       break;
    }

    case TAG_SELECT: /* Check multiple bits */
                /* Right, here we go. We need to grab data until the next
                   </SELECT> */
                if ((p = strinstr(*html, "</SELECT>", size)) == NULL)
                {
                    *html=0;       /* Signal back-up */
                    RETURN(NULL);
                }
                return __html_form_parse_select(st, html, p-*html+1, ret);

    case TAG_OPTION: /* OPTION tag */
    	       ret->info=(elementinfo *)__html_malloc(sizeof(elementinfo_option), 1);
    	       if (!ret->info) { __html_free(ret, 0); return NULL; }
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->tag, START);
	       /* OPTIONy bits */
	       ret->value=ATTR_STR(VALUE);
	       ret->info->option.selected = ATTR_SET(SELECTED);
	       ret->info->option.disabled = ATTR_SET(DISABLED);
	       ret->text=__html_stream_grab_pcdata(html, 1, !st->_stream_pre);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
               #ifdef NEWSPACING
               __html_strip_spaces(ret->text, st->stripleadingspace, 1);
               #else
               __html_strip_spaces(ret->text, st->stripleadingcr);
               #endif
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;

    default: /* TEXTAREA */
	       ret->style=__html_stream_style(st) | FORM;
	       ret->type=__html_stream_type(st, next_tag->type, START);
	       ret->text=__html_stream_grab_pcdata(html, 1, 1);
	       if (ret->text==NULL)
	       {
	           __html_free(ret,0);
	           *html=NULL;
	           RETURN(NULL);
	       }
	       /* TextArea Bits */
	       ret->cols=ATTR_VAL(COLS);
	       ret->rows=ATTR_VAL(ROWS);
	       ret->name=ATTR_STR(NAME);
	       /*st->form_disabled = ATTR_SET(DISABLED);*/
                __html_strip_lfs(ret->text); /* Strip CRs, preserve LFs */
               __html_unescape_string(ret->text);
               ret->indent=__html_stream_indent(st);
	       break;
  }

  if (ret)
      fill_in_colour_info(st, ret);

  return ret;
}

HStream *__html_return_text_token(StreamTokens *st, char *doc, size_t size)
{
HStream *return_val=NULL;

  return_val=HStreamalloc(st, (tag_no)0);

  if (return_val != NULL) {

    return_val->text=strndup(doc, size);
    return_val->style=PRE | PCDATA ;
    return_val->flags = 0;


    __html_strip_lfs(return_val->text);
    __html_strip_control_codes(return_val->text);
    return_val->type=TYPE_BODY;
    return_val->tag=PCDATA;
    return_val->fontsize = 3;
  }
  return return_val;
}

#include "api.h"

/*
 * This routine is called from __html_form_handler
 * We have an HStream ready to be filled in, html points to the start
 * of the block, and size is the size of the block.
 */
static HStream *__html_form_parse_select(StreamTokens *st, char **html, int size, HStream *ret)
{
    char *ptr=*html, *p;
    HStream *h, *hp;
    StreamTokens *s;
    int count,items;
    elementinfo_select *info;

    /* Re-enter the parser - get a stream for our block, and pull out the
       OPTION tags(!) */

    #ifdef UNIFONT
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 106 /* UTF-8 */, priority_user);
    #else
    s=HtmlParse(st->url, size, TYPE_HTMLFILE, st->usingframes, st->usingobjects, 5001 /* Acorn Latin-1 */, priority_user);
    #endif
    /* Hack hack hack! */
    s->_stream_select=1;
    h=HtmlGetStream(s, &ptr, size, NULL);
    __html_set_memory_context(st->memcontext);

    /* The format of the "value" is:
               1st word: number of options
               2nd word: flags (0)
       then per option:
               Flags byte: bit 0 = selected
                           bit 1 = disabled
               Displayed text, terminated by zero byte
               Symbolic name, terminated by a zero byte (just a zero byte if not
                                                         present)
       then to terminate
               &FF
     */
    count=8;
    items=0;
    hp=h;
    while (hp)
    {
        if (hp->tagno == TAG_OPTION)
        {
            count += 1 +
                     strlen(hp->text) +
                     1 +
                     (hp->value ? strlen(hp->value) : strlen(hp->text)) +
                     1;

            items += 1;
        }
        hp=hp->next;
    }
    count+=1;

    info=(elementinfo_select *)__html_malloc(sizeof(elementinfo_select), 1);
    ret->info=(elementinfo *)info;
    if (!info) { HtmlStreamFree(h); free(s); __html_free(ret, 0); return NULL; }

    info->options=(int *)__html_malloc(count, 1);
    info->options[0] = items;
    info->options[1] = 0;
    p = (char *) &info->options[2];
    hp=h;
    while (hp)
    {
        if (hp->tagno == TAG_OPTION)
        {
            int len;

            /* Flags byte */
            *p++=hp->info->option.selected;

            sprintf(p, "%s%n", hp->text, &len); p+=len;
            /* Strip trailing spaces */
            while (*(p-1)==' ')
                *--p='\0';
            p++;
            sprintf(p, "%s%n", hp->value ? hp->value : hp->text, &len); p+=len+1;
        }
        hp=hp->next;
    }
    *p=0xFF;
    assert((p+1)-(char *)info->options == count);

    HtmlStreamFree(h);
    HtmlEndParse(s);

    ret->style=__html_stream_style(st) | FORM;
    ret->type=__html_stream_type(st, TYPE_BODY, START);
    ret->indent=__html_stream_indent(st);

    info->name     = ATTR_STR(NAME);
    info->disabled = ATTR_SET(DISABLED);
    info->multiple = ATTR_SET(MULTIPLE);
    info->size     = ATTR_VAL(SIZE);
    info->tabindex = ATTR_VAL(TABINDEX);
    info->onfocus  = ATTR_STR(ONFOCUS);
    info->onblur   = ATTR_STR(ONBLUR);
    info->onselect = ATTR_STR(ONSELECT);
    info->onchange = ATTR_STR(ONCHANGE);

    fill_in_colour_info(st, ret);
    st->needtosend[TAG_SELECT] = 1;

    ptr=*html+size;

    while (*ptr!='>')
        ptr++;

    *html=ptr+1;

    return ret;
}

static HStream *__html_stream_end_form(StreamTokens *st, char **html)
{
    HStream *ret;
    char *ptr;
    ret = HStreamalloc(st, TAG_FORM_END);
    if (ret)
    {
        ret->style=__html_stream_style(st) | FORM;
        ret->type=__html_stream_type(st, TYPE_BODY, END);
        ret->indent=__html_stream_indent(st);
        ret->tag=FORM;
        fill_in_colour_info(st, ret);
    }

  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;

}

HStream *HStreamalloc(StreamTokens *st, tag_no tagno)
{
    HStream *ret;

    if (tagno == TAG_TABLE) ret = (HStream *)__html_malloc(sizeof(table_stream), 1);
    else                    ret = (HStream *)__html_malloc(sizeof(HStream),      1);

    if (ret)
    {
        ret->parent = st->current_cell;
        ret->tagno = tagno;
    }

    return ret;
}

static int my_strncasecmp(const char *a, const char *b, unsigned int n)
{
    while( *a && *b && n-- )
	if( tolower(*a++) != tolower(*b++) )
	    return 1;

    return 0;
}


static HStream *__html_stream_script(StreamTokens *st, char **html, int size, const char *term, tag_no tagno)
{
    char *ptr = *html;
    int termlen = strlen(term);
    char term0 = term[0];

    while (size)
    {
        if (*ptr == term0)
        {
            if (size < termlen)
                RETURN(NULL);

            if (my_strncasecmp(ptr, term, termlen)==0)
            {
                HStream *ret;

                st->state = Other;
                /* Produce a return token with the data in the text field */
                ret = HStreamalloc(st, tagno);
                if (ret)
                {
                    /*ret->style = __html_stream_style(st);*/
                    ret->type = __html_stream_type(st, TYPE_HEAD, START);
                    ret->text = strndup(*html, ptr - *html - 1);
                    __html_unescape_string(ret->text);
                }
                if (!st->_stream_pre)
                    *html = __html_skip_record_end(ptr, 1);
                else
                    *html = ptr;
                st->stripleadingspace = 1;
                return ret;
            }
        }
        ptr++;
        size--;
    }

    RETURN(NULL);
}

/* parse_rowcols (local)
 *
 *   ptr -> FRAMESET ROWS=""/COLS="" data to parse
 *   values = NULL:
 *      put number of data into number
 *   value != NULL:
 *      put data into values array
 *
 * counts number of data items, or puts data items in an array
 */

static void parse_rowcols (char *ptr, unsigned int *values, unsigned int *number) {

  unsigned int value;

  if (!values) *number = 0;

  do {
    while (isspace(*ptr)) ptr++;
    value = 0;
    if (isdigit(*ptr)) {
      value = (unsigned int) strtol (ptr, &ptr, /*base=*/10);
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == '*') {
      if (!value) value = 1;
      value |= ROWCOL_STAR;
      ptr++;
    } else if (*ptr == '%') {
      value |= ROWCOL_PERCENT;
      ptr++;
    }
    while (isspace(*ptr)) ptr++;
    if (*ptr == ',') {
      ptr++;
    }
    while (isspace(*ptr)) ptr++;

    if (values) {
      *values++ = value;
    } else {
      *number += 1;
    }

  } while (isdigit (*ptr) || *ptr == '*');
}

/********************************************************************/
/* static HStream *__html_map_handler(char **html)                  */
/********************************************************************/
/* Given an map tag, prepare a new MapStream.              	    */
/********************************************************************/
static HStream *__html_map_handler(StreamTokens *st)
{
    MapStream *map;

    /* Need a name */
    if (!ATTR_STRPEEK(NAME)) return NULL;

    map = (MapStream *) __html_malloc(sizeof(MapStream), 1);
    if (!map) return NULL;

    map->name = ATTR_STR(NAME);
    map->next = st->maps->next;
    st->maps->next = map;
    st->_stream_map = 1;

    return NULL;
}

/********************************************************************/
/* static HStream *__html_stream_area(char **html)                  */
/********************************************************************/
/* Given an area tag, extract the relevant information              */
/* associated with this tag and present it as an <A> element,       */
/* attached to the current map.                         	    */
/********************************************************************/
static HStream *__html_stream_area(StreamTokens *st, char **html, Tag *next_tag)
{
  HStream *ret, **prev;

  NOT_USED(next_tag);

  if (!st->_stream_map) return NULL;

  /* Fill in an HStream */
  ret = __html_stream_return_tag(st, next_tag, html, 1);
  if (!ret)
      return NULL;

  ret->style |= A;

  /* Get the coordinates */
  if (ATTR_SET(COORDS))
      ret->coords = ATTR_COORDS(COORDS);
  else if (ATTR_VAL(SHAPE) == areashape_DEFAULT)
      /* If no coordinates, and shape = DEFAULT, that's okay - put in a dummy coords block. */
      ret->coords = (int *) __html_malloc(sizeof(int), 2);

  if (!ret->coords)
  {
      __html_free(ret, 0);
      return NULL;
  }

  ret->coords[0] = ATTR_VAL(SHAPE);

  ret->anchor = ATTR_STR(HREF);

  if (ATTR_SET(TARGET))
      ret->target = ATTR_STR(TARGET);
  else
      ret->target = strdup(st->target);

  if (ATTR_SET(ALT))
      ret->text = ATTR_STR(ALT);
  else
      ret->text = strdup(ret->anchor);

  for (prev = &st->maps->next->stream; *prev; prev = &(*prev)->next)
      continue;

  *prev = ret;

  return NULL;
}

/********************************************************************/
/* static HStream *__html_skip_record_end(char *s)                  */
/********************************************************************/
/* Skip over record ends (RE) (line feed). Need to cope with there  */
/* being spaces at the end of lines or start of the last line.      */
/********************************************************************/
static char *__html_skip_record_end(const char *s, int skip_leading)
{
    const char *p = s;
    bool found_re = false;

    while ((*p == ' ' || *p == 10 || *p == 13) && !(found_re && !skip_leading && *p == ' '))
    {
        if (*p != ' ')
            found_re = true;

        p++;
    }

    return (char *) (found_re ? p : s);
}

static HStream *__html_stream_q(StreamTokens *st, char **html, int start)
{
    HStream *ret;
    char *ptr;
    static const char quote[2][2][4] =
    {
        #ifdef UNIFONT
        "", "", "", ""
        #else
        "",   "",   "",   ""
        #endif
    };

    ret = HStreamalloc(st, (tag_no)0);
    if (ret)
    {
        ret->text = strdup(quote[st->_stream_q & 1][start]);
        ret->style=__html_stream_style(st) | PCDATA;
        ret->type=__html_stream_type(st, TYPE_BODY, START);
        ret->indent=__html_stream_indent(st);
        ret->tag=PCDATA;
        st->lastwaspcdata = 1;
        fill_in_colour_info(st, ret);
        memset(st->needtosend, 0, sizeof st->needtosend);
        if (st->_stream_anchor != NULL)
        {
            ret->anchor=st->_stream_anchor->href;
            #ifdef LINEONE_HACK
            ret->onclick=st->_stream_anchor->onclick;
            #endif
            ret->name=st->_stream_anchor->name;
            st->need_to_send_name=0;
            ret->target = st->_stream_anchor->target;
        }
    }

    st->_stream_q += start ? +1 : -1;

  /*
   * This routine is called with the understanding that it will update
   * the HTML pointer. Move it to past the next > or the end of the input
   * whichever is sooner. In theory it should be the former.
   */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;

}

