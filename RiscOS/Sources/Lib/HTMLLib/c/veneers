/*
 * These functions are basically remappings to the actual functions used.
 */

#include "api.h"
#include "internal.h"
#include "flex.h"
#include "stdio.h"
#include <string.h>
#include "kernel.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

/***********************************************************************/
/* (void) __html_set_hourglass_percent(int done, int size)             */
/***********************************************************************/
/* A small macro to set the hour glass status                          */
/***********************************************************************/
#define Hourglass_Percent 0x406c4
#define __html_set_hourglass_percent(done,size) {\
  r.r[0]=(int)((done*100)/size); \
  _kernel_swi(Hourglass_Percent, &r, &r);}

/***********************************************************************/
/* void *HtmlParse(char *url, int length)                              */
/***********************************************************************/
/* This is the call to set up a new context within which a document is */
/* parsed. The length is the total size of the document and is an      */
/* optional parameter (it is used in place of size in HtmlGetStream to */
/* set the hourglass percentage if it is non-zero), and URL is a       */
/* pointer to the document being parsed. 	    	       	       */
/***********************************************************************/
void *HtmlParse(char *url, int length, int type, int usingframes)
{
   StreamTokens *st;
/* Create the stream context structure */
    st=__html_stream_init();
    if (st == NULL)
        return (void *)st;
/* Fill in the bits known, such as length, memory context and url */
    st->doclength=length; /* If known */
/* Create a memory context for this URL */
    st->memcontext=__html_memory_init();
    st->url=strdup(url);
    st->type=type;
#ifdef FRAMESUPPORT
    st->usingframes=usingframes;
#endif
/* Return the pointer to the struct as a void * */
    return (void *)st;
}

#ifdef FRAMESUPPORT
static void StripNoframes(HStream *p)
{
  HStream *next;

  if (!p)
    return;

  /*
   * Skip one - this is OK because p will either be the very first token (which
   * is infinitely unlikely to be NOFRAMES, or it will be the last tag
   * of a previous parse chunk, hence already checked
   */
  p = p->next;

  for ( ; p; p=next)
  {
    next = p->next;
    if (p->type & TYPE_NOFRAMES) {
      p->prev->next = next;
      if (next)
        next->prev = p->prev;
      /*
       * This doesn't free associated data in the token, but it will get
       * freed eventually when HtmlFreeStream is called. Should be sorted.
       */
      __html_free(p, 0);

    }
  }
}
#endif

/***********************************************************************/
/* HStream *HtmlGetStream(void *streamtok, char **document, int size)  */
/***********************************************************************/
/* Attempt to parse an additional "size" bytes of the "document" using */
/* the context pointed too in "streamtok". This allows documents to be */
/* parsed as they come in off the wire.	   	       		       */
/***********************************************************************/

HStream *HtmlGetStream(void *streamtok, char **document, int size, unsigned int *flags)
{
  HStream *return_val, *current;
  StreamTokens *st = (StreamTokens *)streamtok;
  char *doc,  *start, *docstart, *end;
  int chunksize=st->doclength;
  int oldflexstate;

#ifdef OLDCODE
  int todo=size;
#endif
  _kernel_swi_regs r;
#ifdef TRACE
{
    FILE *fp=fopen("ADFS::4.$.Trace.ParseIn", "a");
    if (fp)
    {
        int t;
        fprintf(fp, "HtmlGetStream(%p, %d)\n", streamtok, size);
        t=size;
        if (st->done < st->sizesofar)
            t+=st->sizesofar - st->done;
        fwrite(doc+st->done, t, 1, fp);
        fclose(fp);
    }
}
#endif

  if (!size) return (HStream *)size;

  /* Yuckery! Give us 16K of free space by shifting flex stuff, then lock the
     flex stuff */
  oldflexstate = flex_set_budge(1);
  free(malloc(16384));
  flex_set_budge(0);

  doc=start=docstart=*document;

/* Set up our environment first */
  __html_set_memory_context(st->memcontext);

  current=st->Stream;

  if (st->done != 0) {
/* We have already done some parsing so update doc and size appropriatly */
    int  newsize = size;
    doc += st->done;
    start=doc;
    if (st->done < st->sizesofar) {
      newsize += st->sizesofar - st->done;
    }
    st->sizesofar += size;
    size = newsize;
  }
  else {
    st->sizesofar += size;
  }
  end=*document+st->sizesofar;

  if (chunksize==0) chunksize=size;

/* Now parse the document */
  if (st->type == TYPE_HTMLFILE) {
/* HTML Parser */

    if (current == NULL) {
      current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current;
    }

    while (doc < end && *doc != '\0') {
      char *olddoc = doc;
      size=chunksize-(doc-start);
      /* Fail safe for badly terminated strings */
      if ((size<1) || __html_done_for_now) break;
      if (return_val == NULL) {
        current=return_val=__html_stream_parse(st, &doc, st->url, size, NULL);
        if (current == NULL && doc == olddoc)
            __html_done_for_now = 1;
      }
      else {
        #ifdef TonyTables
        /*
         * if there are incomplete tables, then you link somewhere different
         * also table-stuff needs a bit of context in order to operate properly
         */
        HStream **realcurrent;
        realcurrent=table_skip_current(current);

        st->isendtag=0;
        if (realcurrent != NULL)
            *realcurrent=__html_stream_parse(st, &doc, st->url, size, current);
        else
             __html_stream_parse(st, &doc, st->url, size, current);
        /* effect is to skip anything before valid <tr><td> e.g. junk<tr>junk<td> */
        #else
        st->isendtag=0;
        current->next=__html_stream_parse(st, &doc, st->url, size, current);
        #endif
        if (current->next != NULL) {
#ifdef NEWSPACING
            if ((st->isendtag) && current && current->text && current &&
                !(current->style & (PRE|TEXTAREA)))
            {
                int s=strlen(current->text);
                if (s > 0)
                {
                    if (current->text[s-1]==' ')
                        current->text[s-1]='\0';
                }
            }
#endif
            current->next->prev = current;
            current=current->next;
        }
        else if (doc == olddoc)
            __html_done_for_now = 1;
      }
      if (chunksize >= 1)
        __html_set_hourglass_percent((int)(doc-start),
            chunksize);
      /*if (doc == olddoc && current == NULL)
        break;*/
    }
    __html_done_for_now=0;

    #ifdef FRAMESUPPORT
    if (st->usingframes)
      StripNoframes(return_val);
    #endif


  }
  else { /* plain text */
    if (current == NULL) {
      current=return_val=__html_return_text_token(doc,size);
    }
    else {
      while (current->next != NULL) current=current->next;
      return_val=current->next=__html_return_text_token(doc,size);
    }
    doc+=size;
  }

/* Preserve the start of the stream for us */
  if (st->Stream==NULL)
      st->Stream=return_val;
  else if (return_val != NULL && return_val->next != NULL)
      return_val=return_val->next;

/* and make a note of how much we have done */
  st->done=(doc-docstart);
  if (st->done > st->sizesofar) st->done=st->sizesofar;

  flex_set_budge(oldflexstate);

/*
 * Return the pointer to the complete stream or the element which
 * we added if the stream already existed.
 */
  return return_val;
}

/***********************************************************************/
/* void HtmlStreamFree(void *stream)                                   */
/***********************************************************************/
/* Small entry point to free up all the memory associated with a       */
/* stream (even if the stream was created with multiple parses.	       */
/***********************************************************************/
void HtmlStreamFree(void *stream) {
    if (stream==NULL) return;
    __html_free(stream, 1);
#ifdef MEMORY_DEBUG
    __html_memory_list();
#endif
}

int HttpStripHeaders(char *stream, size_t stream_len)
{
  return __http_strip_headers(stream, stream_len);
}

unsigned int HtmlIdentify(char *stream, size_t stream_len, char done,
       		    		      char **url, int *file_type,
       		    		      int *canparse)
{
  return __html_identify(stream, stream_len, done, url, file_type, canparse);
}

char *HTTPEscapeString(char *string)
{
  return __http_escape_string(string);
}

/***********************************************************************/
/* void *HtmlMalloc(size_t size, void *parent)                         */
/***********************************************************************/
/* User frontend to __html_malloc                        	       */
/***********************************************************************/
void *HtmlMalloc(size_t size, void *parent)
{
    __html_set_memory_context_from_block(parent);
    return __html_malloc(size, 1);
}

/***********************************************************************/
/* void *HtmlFree(void *block)                                         */
/***********************************************************************/
/* User frontend to __html_free                             	       */
/***********************************************************************/
void HtmlFree(void *block)
{
    __html_free(block, 0);
}
