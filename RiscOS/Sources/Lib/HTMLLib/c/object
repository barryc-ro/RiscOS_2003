#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include <ctype.h>
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

HStream *__html_stream_object(StreamTokens *st, char **html, Tag *next_tag)
{
    HStream     *ret;
    elementinfo_object *info;
    char       *ptr;

    ret=HStreamalloc(st, TAG_OBJECT);

    if (ret)
    {
        info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
        if (!info) { __html_free(ret, 0); return NULL; }

        ret->info = (elementinfo *) info;
        ret->style=__html_stream_style(st);
        ret->type=__html_stream_type(st, next_tag->type, START);
        ret->indent = __html_stream_indent(st);

        ret->rows   = ATTR_VAL(HEIGHT);
        ret->cols   = ATTR_VAL(WIDTH);
        ret->maxlen = ATTR_SET(BORDER) ? ATTR_VAL(BORDER) : 2;

        switch (ATTR_VAL(ALIGN))
        {
            case 1: ret->type|=_html_top<<TYPE_ALIGN_SHIFT; break;
            case 2: ret->type|=_html_middle<<TYPE_ALIGN_SHIFT; break;
            case 3: ret->type|=_html_bottom<<TYPE_ALIGN_SHIFT; break;
            case 4: ret->type|=_html_left<<TYPE_ALIGN_SHIFT; break;
            case 5: ret->type|=_html_right<<TYPE_ALIGN_SHIFT; break;
            case 6: ret->type|=_html_centre<<TYPE_ALIGN_SHIFT; break;
            default:ret->type|=_html_none<<TYPE_ALIGN_SHIFT; break;
        }

        if (st->_stream_anchor!=NULL) {
            ret->anchor=st->_stream_anchor->href;
            ret->name=st->_stream_anchor->name;
            ret->target=st->_stream_anchor->target;
            #ifdef LINEONE_HACK
            ret->onclick=st->_stream_anchor->onclick;
            #endif
        }

        if (ATTR_SET(NAME))
            ret->name=ATTR_STR(NAME);

        info->declare  = ATTR_SET(DECLARE);
        info->classid  = ATTR_STR(CLASSID);
        info->codebase = ATTR_STR(CODEBASE);
        info->data     = ATTR_STR(DATA);
        info->type     = ATTR_STR(TYPE);
        info->codetype = ATTR_STR(CODETYPE);
        info->archive  = ATTR_STR(ARCHIVE);
        info->standby  = ATTR_STR(STANDBY);
        info->hspace   = ATTR_VAL(HSPACE);
        info->vspace   = ATTR_VAL(VSPACE);
        info->usemap   = ATTR_STR(USEMAP);
        info->shapes   = ATTR_SET(SHAPES);
        info->tabindex = ATTR_VAL(TABINDEX);

        info->parent   = st->object;

        st->object = ret;
    }

    /*
     * This routine is called with the understanding that it will update
     * the HTML pointer. Move it to past the next > or the end of the input
     * whichever is sooner. In theory it should be the former.
     */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;
}

void __html_stream_end_object(StreamTokens *st)
{
    if (st->object)
        st->object = st->object->info->object.parent;
}

table_prev_info __html_find_current_object(StreamTokens *st, HStream *current)
{
    table_prev_info realcurrent;

    if (!st->object)
    {
        realcurrent.prev = current;
        realcurrent.prevnextptr = &current->next;
    }
    else
    {
        if (st->object->info->object.hstream)
        {
            HStream *h = st->object->info->object.hstream;

            while (h->next) h = h->next;

            realcurrent.prev = h;
            realcurrent.prevnextptr = &h->next;
        }
        else
        {
            realcurrent.prev = st->object->info->object.parent;
            realcurrent.prevnextptr = &st->object->info->object.hstream;
        }
    }
    return realcurrent;
}
