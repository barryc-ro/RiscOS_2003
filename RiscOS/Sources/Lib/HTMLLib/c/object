#include <assert.h>
#include <stdio.h>     /* For NULL etc */
#include <ctype.h>
#include "html2_ext.h" /* For the HTML bits */
#include "tags.h"      /* for PCDATA */
#include "struct.h"    /* For the structures */
#include "string.h"    /* For string handling */
#include "internal.h"  /* predefinitions of functions */
#include "elementinf.h"
#ifdef TonyTables
#include "HTMLTables.h"
#endif

HStream *__html_stream_object(StreamTokens *st, char **html, Tag *next_tag)
{
    HStream     *ret;
    elementinfo_object *info;
    char       *ptr;

    ret=HStreamalloc(TAG_OBJECT);

    if (ret)
    {
        info = (elementinfo_object *)__html_malloc(sizeof(elementinfo_object), 1);
        if (!info) { __html_free(ret, 0); return NULL; }

        ret->info = (elementinfo *) info;
        ret->style=__html_stream_style(st);
        ret->type=__html_stream_type(st, next_tag->type, START);
        ret->indent = __html_stream_indent(st);

        ret->rows = ATTR_VAL(HEIGHT);
        ret->cols = ATTR_VAL(WIDTH);

        info->declare  = ATTR_SET(DECLARE);
        info->shapes   = ATTR_SET(SHAPES);
        info->classid  = ATTR_STR(CLASSID);
        info->codebase = ATTR_STR(CODEBASE);
        info->data     = ATTR_STR(DATA);
        info->type     = ATTR_STR(TYPE);
        info->codetype = ATTR_STR(CODETYPE);
        info->archive  = ATTR_STR(ARCHIVE);
        info->tabindex = ATTR_VAL(TABINDEX);

        info->parent   = st->object;

        st->object = ret;
    }

    /*
     * This routine is called with the understanding that it will update
     * the HTML pointer. Move it to past the next > or the end of the input
     * whichever is sooner. In theory it should be the former.
     */
    ptr=*html + 1;
    while((*ptr != '\0') && (*ptr != '>') && (*ptr != '<')) ptr++;
    if (*ptr=='>') ptr++;
    *html=ptr;

    return ret;
}

void __html_stream_end_object(StreamTokens *st)
{
    if (st->object)
        st->object = st->object->info->object.parent;
}

table_prev_info __html_find_current_object(StreamTokens *st, HStream *current)
{
    table_prev_info realcurrent;

    if (!st->object)
    {
        realcurrent.prev = current;
        realcurrent.prevnextptr = &current->next;
    }
    else
    {
        if (st->object->info->object.hstream)
        {
            HStream *h = st->object->info->object.hstream;

            while (h->next) h = h->next;

            realcurrent.prev = h;
            realcurrent.prevnextptr = &h->next;
        }
        else
        {
            realcurrent.prev = st->object->info->object.parent;
            realcurrent.prevnextptr = &st->object->info->object.hstream;
        }
    }
    return realcurrent;
}
