/* -*-C-*-
 *
 * $Version: networking $
 *
 * $Source$
 *
 * $Log$
 * Revision 1.2  1997/04/29 15:50:48  kbracey
 * Merged in ARTtmp_merge
 *
 * Revision 1.1.2.2  1997/04/09 16:44:38  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:48  kbracey
 * Initial revision
 *
 * Revision 1.6  95/10/31  13:11:40  pwain
 * *** empty log message ***
 *
 * Revision 1.5  95/10/30  10:44:39  pwain
 * Moved strdup to display source file
 *
 * Revision 1.4  95/10/30  10:39:44  pwain
 * Caught a NULL pointer in strdup().
 *
 * Revision 1.3  95/10/20  15:27:52  pwain
 * Rewrote case 2 in parse again. This seems to work now!
 * Also required a slight change to the rules handling to allow
 * a read only pointer to be passed in. This should have been done
 * anyway of course!
 *
 * Revision 1.2  95/10/18  10:40:14  pwain
 * Found a case where free() was used rather than
 * __html_free() after a strdup()
 *
 * Revision 1.1  95/10/12  12:46:51  pwain
 * Initial revision
 *
 *
 * --- Original Log Information ---
 *
 * $Version: networking $
 *
 * $Source$
 *
 * $Log$
 * Revision 1.2  1997/04/29 15:50:48  kbracey
 * Merged in ARTtmp_merge
 *
 * Revision 1.1.2.2  1997/04/09 16:44:38  kbracey
 * Spacing rules drastically improved. Major error in memory context handling
 * fixed. Bug in __html_strip_lf fixed.
 *
 * Revision 1.1.2.1  1997/04/08 10:26:48  kbracey
 * Initial revision
 *
 * Revision 1.6  95/10/31  13:11:40  pwain
 * *** empty log message ***
 *
 * Revision 1.5  95/10/30  10:44:39  pwain
 * Moved strdup to display source file
 *
 * Revision 1.4  95/10/30  10:39:44  pwain
 * Caught a NULL pointer in strdup().
 *
 * Revision 1.3  95/10/20  15:27:52  pwain
 * Rewrote case 2 in parse again. This seems to work now!
 * Also required a slight change to the rules handling to allow
 * a read only pointer to be passed in. This should have been done
 * anyway of course!
 *
 * Revision 1.2  95/10/18  10:40:14  pwain
 * Found a case where free() was used rather than
 * __html_free() after a strdup()
 *
 * Revision 1.1  95/10/12  12:46:51  pwain
 * Initial revision
 *
 * Revision 1.1  95/09/08  10:06:09  pwain
 * Initial revision
 *
 *
 */

/*
 * This is some useful code to lookup rules in the various tables, and
 * validate that tags are in the correct place etc.
 */

#include "html2_ext.h"
#include "internal.h"
#include "html2.h"
#include "struct.h"
#include "string.h"
#include "ctype.h"

#ifdef USE_SPRINTF
#include "stdio.h"
#endif

static int __html_tag_name_len (char *s1);

static int compare_tag(const void *keyp, const void *membp)
{
    const char *key = (const char *) keyp;
    const Tag *memb = (const Tag *) membp;

    return strcmp(key, memb->start_tag);
}

/*
 * Given a rule block, (and the number of entries in the rule block),
 * look to see if the tag exists in that rule block.
 *
 */

int __html_check_tag (const Tag *tags, int max_tags, const char *tag)
{
Tag  *t_tag;
//Tag  *tags;
int loop;
const char *y;
char *x;
static char this_tag[32];

    /* Make sure we are working in upper case */
    x=this_tag;
    y=tag;
    loop = 31;

    while (*y && loop--)
      *x++ = toupper(*y++);

    *x = '\0';

    if (!loop)
        return 0;

//    tags=rules;

    t_tag = (Tag *) bsearch(this_tag, tags, max_tags, sizeof(Tag), compare_tag);

    /*
     * Handle not finding the tag elegantly... Need to understand about
     * comments which are sort of NULL tags but not quite!
     *
     * This works because comments have been defined as a 0 tag as
     * has the doctype tag. (NASTY HACK!)
     */
    if ( !t_tag || t_tag->tag == 0 ) return 0;

    return 1;
}


/*
 * Routine to find the rule for a tag in any tag block. This routine
 * assumes it is looking for a start tag (e.g. <P>, <LI> etc), and not an
 * end tag (e.g. </P>, </LI> etc). See the next routine for how to find
 * an end tag, and the one after that for how to find *any* tag
 */

Tag __html_find_start_tag_block(char *tag)
{
char *y;
Tag *found_tag;

    if ((tag==NULL) || (*tag=='\0')) return Null_Tag;

    y=tag;

    while (*y) {
      *y=toupper(*y);
      y++;
    }

    /* Look at the Head and Body tags */
    found_tag = bsearch(tag, Head_Body_Tags, MAX_HEAD_BODY_TAGS, sizeof(Tag), compare_tag);
    if (found_tag) return *found_tag;

    /* Next look at the Frameset tags */
    found_tag = bsearch(tag, Frameset_Tags, MAX_FRAMESET_TAGS, sizeof(Tag), compare_tag);
    if (found_tag) return *found_tag;

    /* Finally the "document" tags */
    found_tag = bsearch(tag, Document_Tags, MAX_DOC_TAGS, sizeof(Tag), compare_tag);
    if (found_tag) return *found_tag;

    /* Not found! */
    return Null_Tag;
}

/*
 * This routine looks in all the rule blocks for an end tag (e.g. </P>).
 * (It could probably have been merged with the above routine, but this
 * is cleaner in my mind. -- PW)
 */
Tag __html_find_end_tag_block(char *tag)
{
char *y;
Tag *found_tag;

    if (tag == NULL || *tag != '/') return Null_Tag;

    y=tag;

    while (*y) {
      *y=toupper(*y);
      y++;
    }

    /* Since most tags are in the body - start there */
    found_tag = bsearch(tag + 1, Head_Body_Tags, MAX_HEAD_BODY_TAGS, sizeof(Tag), compare_tag);
    if (found_tag && found_tag->can_be_end) return *found_tag;

    /* Next look at the Frameset tags */
    found_tag = bsearch(tag + 1, Frameset_Tags, MAX_FRAMESET_TAGS, sizeof(Tag), compare_tag);
    if (found_tag && found_tag->can_be_end) return *found_tag;

    /* Finally the "document" tags */
    found_tag = bsearch(tag + 1, Document_Tags, MAX_DOC_TAGS, sizeof(Tag), compare_tag);
    if (found_tag && found_tag->can_be_end) return *found_tag;

    /* Not found! */
    return Null_Tag;
}

/*
 * This routine finds tags ANYWHERE in the tables. I.E. a start tag or
 * an end tag. It should be used as a more general interface to
 * the above routines. If end==0 then only the start tags are searched.
 * If end==1 then only the end tags are checked. If end==2 then all tags
 * are checked.
 *
 * Note html is a pointer to the string holding the tag, which doesnt need
 * to be null terminated after the tag name. It does however need to either
 * contain a space or a terminator before the end of the memory allocated
 * to that string passed into it.
 */

Tag __html_find_tag(char **html, int end)
{
Tag tag;
int found=0;
char *h;

    if (*html==NULL) return Null_Tag;

    h=strndup(*html,__html_tag_name_len(*html));

    /* try and find the tag in the starting tags */
    if ((end >= 1) && (end < 3)) {
        tag=__html_find_end_tag_block(h);
	if (!NULL_TAG(tag)) found=1;
	}

    /* Otherwise try and find tag in the end tags */
    if (((end == 0) || (end > 1)) && (found==0)) {
        tag=__html_find_start_tag_block(h);
	}

    __html_free(h,0);

    /* return the info for the found tag */
    return tag;
}

static int __html_tag_name_len (char *s1)
{
  char *p=s1;

  while ((!isspace(*p)) && (*p != '>') && (*p != '\0')) {
        p++; /* skip to the end of the tag name */
	}

  return (int)(p-s1);
}
