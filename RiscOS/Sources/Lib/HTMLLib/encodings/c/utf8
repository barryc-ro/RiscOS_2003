#include "utf8.h"

/*
 * UCS4_to_UTF8 converts a UCS-4 code to UTF-8, storing the result
 * in the array pointed to by out. This array must be large enough
 * to store the resulting UTF-8 element (6 bytes will always be
 * sufficient). The return value is a pointer to the byte after
 * the last one written.
 */
char *UCS4_to_UTF8(char *out, UCS4 code)
{
    if (code < 0x80)
    {
        *out++ = code;
        return out;
    }

    if (code < 0x800)
        *out++ = 0xC0 | (code >> 6);
    else
    {
        if (code < 0x10000)
            *out++ = 0xE0 | (code >> 12);
        else
        {
            if (code < 0x200000)
                *out++ = 0xF0 | (code >> 18);
            else
            {
                if (code < 0x4000000)
                    *out++ = 0xF8 | (code >> 24);
                else
                {
                    *out++ = 0xFC | (code >> 30);
                    *out++ = 0x80 | ((code >> 24) & 0x3F);
                }
                *out++ = 0x80 | ((code >> 18) & 0x3F);
            }
            *out++ = 0x80 | ((code >> 12) & 0x3F);
        }
        *out++ = 0x80 | ((code >> 6) & 0x3F);
    }
    *out++ = 0x80 | (code & 0x3F);

    return out;
}

/*
 * UTF8_to_UCS4 takes a pointer to a UTF-8 sequence and outputs
 * the corresponding UCS4 code, returning the number of bytes consumed.
 */
int UTF8_to_UCS4(const char *c, UCS4 *r)
{
    UCS4 c0 = c[0];
    UCS4 ucs, cn;

    /* Easy case - is code 0xxxxxxx? If so, just return it. */
    if (c0 < 0x80)
    {
        *r = c0;
        return 1;
    }

    /* If we have 10xxxxxx, we're broken */
    if (c0 < 0xC0)
        goto badutf;

    /* Check second byte is 10xxxxxx */
    cn = c[1] ^ 0x80;

    if (cn & 0xC0)
        goto badutf;

    /* Add it in */
    ucs = (c0 << 6) | cn;

    /* Check for two byte codes - 110xxxxx 10xxxxxx */
    if (c0 < 0xE0)
    {
        /* ucs holds 00110xxx xxxxxxxx */
        ucs &=~ 0x3000;

        /* Check it's not a small value that shouldn't be encoded this long */
        if (ucs < 0x80)
            goto badutf;

        *r = ucs;
        return 2;
    }

    /* Check third byte is 10xxxxxx */
    cn = c[2] ^ 0x80;

    if (cn & 0xC0)
        goto badutf;

    /* Add it in */
    ucs = (ucs << 6) | cn;

    /* Check for 3 byte codes - 1110xxxx 10xxxxxx 10xxxxxx */
    if (c0 < 0xF0)
    {
        /* ucs holds 1110 xxxxxxxx xxxxxxxx */
        ucs &=~ 0xE0000;

        /* Check it's not a small value that shouldn't be encoded this long */
        if (ucs < 0x800)
            goto badutf;

        *r = ucs;
        return 3;
    }

    /* Check fourth byte is 10xxxxxx */
    cn = c[3] ^ 0x80;

    if (cn & 0xC0)
        goto badutf;

    /* Add it in */
    ucs = (ucs << 6) | cn;

    /* Check for 4 byte codes - 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (c0 < 0xF8)
    {
        /* ucs holds 11 110xxxxx xxxxxxxx xxxxxxxx */
        ucs &=~ 0x3C00000;

        /* Check it's not a small value that shouldn't be encoded this long */
        if (ucs < 0x10000)
            goto badutf;

        *r = ucs;
        return 4;
    }

    /* Check fifth byte is 10xxxxxx */
    cn = c[4] ^ 0x80;

    if (cn & 0xC0)
        goto badutf;

    /* Add it in */
    ucs = (ucs << 6) | cn;

    /* Check for 5 byte codes - 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (c0 < 0xFC)
    {
        /* ucs holds 111110xx xxxxxxxx xxxxxxxx xxxxxxxx */
        ucs &=~ 0xF8000000;

        /* Check it's not a small value that shouldn't be encoded this long */
        if (ucs < 0x200000)
            goto badutf;

        *r = ucs;
        return 5;
    }

    /* Check sixth byte is 10xxxxxx */
    cn = c[5] ^ 0x80;

    if (cn & 0xC0)
        goto badutf;

    /* Add it in */
    ucs = (ucs << 6) | cn;

    /* Check for 6 byte codes - 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (c0 < 0xFE)
    {
        /* ucs holds 0xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx */

        /* Check it's not a small value that shouldn't be encoded this long */
        if (ucs < 0x4000000)
            goto badutf;

        *r = ucs;
        return 6;
    }

    /* If we get this far, c0 = 1111111x which is bogus, so fall through to... */

  badutf:
    *r = 0xFFFD;
    return 1;
}

/*
 * UTF8_codelen gives the length of a UCS-4 code when converted to UTF-8
 * using UCS4_to_UTF8.
 */
int UTF8_codelen(UCS4 code)
{
    if (code < 0x80) return 1;
    if (code < 0x800) return 2;
    if (code < 0x10000) return 3;
    if (code < 0x200000) return 4;
    if (code < 0x4000000) return 5;
    return 6;
}

/*
 * UTF8_seqlen gives the length of a UTF-8 sequence, given its first
 * byte.
 */
int UTF8_seqlen(char c)
{
    if (c < 0xC0) return 1;
    if (c < 0xE0) return 2;
    if (c < 0xF0) return 3;
    if (c < 0xF8) return 4;
    if (c < 0xFC) return 5;
    if (c < 0xFE) return 6;
    return 1;
}
