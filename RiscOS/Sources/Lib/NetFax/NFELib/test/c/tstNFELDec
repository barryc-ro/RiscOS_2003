#include <stdio.h>
#include "NetFax/NFELib/NFELib.h"
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef MEMCHECK
  #include "MemCheck:MemCheck.h"
#endif

int main()
{
  NFE_CONTEXT      context;
  clock_t          t_slice;
  NFE_rcode        rc = NFE_COMPLETED;
  _kernel_oserror *e = 0;
  char            *file = "sun1msg";
  char            *out_file = "thu1tiff";
  uint32           length = 32203;
  NFE_header       header;
  clock_t          slice = 20;
  int32            i = 0;
  struct tm       *tm = 0;
  char             buf[255];

#ifdef MEMCHECK
  MemCheck_Init();
  MemCheck_RedirectToFilename("MEMOUTD");
  MemCheck_SetStoreMallocFunctions(1);
  MemCheck_InterceptSCLStringFunctions();
#endif
  
  memset(&header, 0, sizeof(NFE_header));
  
  rc = new_context(&context);
  if (rc == NFE_COMPLETED)
  {
    printf("created new context\n");
    
    rc = NFE_RUNNING;
    t_slice = clock() + slice;
    while ((!e) && (rc == NFE_RUNNING))
    {
      t_slice = clock() + slice;
      e = NFE_decode_RFC822_hdr(&context, t_slice, TRUE, file, length, &header, &rc);
    }
    destroy_context(&context);
    if (e)
      printf("KERNEL OSERROR!\n");
    else if (rc < NFE_COMPLETED)
      printf("rc: %d\n", rc);
    else
    {
      printf("rc: %d\n", rc);
      printf("SUCCESS!\n");

      if (header.to.address)
      {
        printf("TO   address : %s\n", header.to.address);
        free(header.to.address);
        header.to.address = 0;
      }
      else
        printf("NO TO ADDRESS\n");
      if (header.to.real_name)
      {
        printf("TO   realname: %s\n", header.to.real_name);
        free(header.to.real_name);
        header.to.real_name = 0;
      }
      else
        printf("NO TO REALNAME\n");
      if (header.from.address)
      {
        printf("FROM address : %s\n", header.from.address);
        free(header.from.address);
        header.from.address = 0;
      }
      else
        printf("NO FROM ADDRESS\n");
      if (header.from.real_name)
      {
        printf("FROM realname: %s\n", header.from.real_name);
        free(header.from.real_name);
        header.from.real_name = 0;
      }
      else
        printf("NO FROM REALNAME\n");

      if (header.return_receipt_to.address)
      {
        printf("RETURN RECEIPT TO address : %s\n", header.return_receipt_to.address);
        free(header.return_receipt_to.address);
        header.return_receipt_to.address = 0;
      }
      else
        printf("NO RETURN RECEIPT TO ADDRESS\n");
      if (header.return_receipt_to.real_name)
      {
        printf("RETURN RECEIPT TO realname: %s\n", header.return_receipt_to.real_name);
        free(header.return_receipt_to.real_name);
        header.return_receipt_to.real_name = 0;
      }
      else
        printf("NO RETURN RECEIPT TO REALNAME\n");
      
      tm = gmtime(&header.date);
      if (tm)
      {
        strftime(buf, 254, "%a, %d %b %Y %H:%M:%S %Z", tm);
        printf("DATE         : %s\n", buf);
      }
      
      if (header.date_hdr)
      {
        printf("DATE STRING  : %s\n", header.date_hdr);
        free(header.date_hdr);
      }
      else
        printf("NO DATE STRING\n");
      if (header.subject)
      {
        printf("SUBJECT      : %s\n", header.subject);
        free(header.subject);
      }
      else
        printf("NO SUBJECT\n");
      printf("FIRST PAGE   : %d\n", header.id.first_page_num);
      printf("LAST PAGE    : %d\n", header.id.last_page_num);
      printf("DOCUMENT NUM : %d\n", header.id.doc_num);
      printf("NUM OF PAGES : %d\n", header.id.msg_num_pages);
      printf("EXACT NUMBER : %d\n", header.id.exact_num_pages);
      if (header.id.iap_username)
      {
        printf("USERNAME     : %s\n", header.id.iap_username);
        free(header.id.iap_username);
        header.id.iap_username = 0;
      }
      else
        printf("NO USERNAME\n");
      if (header.details.device)
      {
        printf("DEVICE       : %s\n", header.details.device);
        free(header.details.device);
        header.details.device = 0;
      }
      else
        printf("NO DEVICE\n");
      printf("DEVICE_CLASS : %d\n", header.details.device_class);
      printf("SERIAL       : ");
      for (i=0;i<SERIAL_LEN;i++)
        printf("%02x", header.details.serial_num[i]);
      printf("\n");
      printf("SOFTWARE REV : %d.%02d\n", header.details.software_rev_major, header.details.software_rev_minor);
      if (header.details.domain)
      {
        printf("DOMAIN       : %s\n", header.details.domain);
        free(header.details.domain);
        header.details.domain = 0;
      }
      else
        printf("NO DOMAIN\n");
      if (header.config.fax_num)
      {
        printf("FAX NUMBER   : %s\n", header.config.fax_num);
        free(header.config.fax_num);
        header.config.fax_num = 0;
      }
      else
        printf("NO FAX NUMBER\n");
      if (header.config.phone_num)
      {
        printf("PHONE NUMBER : %s\n", header.config.phone_num);
        free(header.config.phone_num);
        header.config.phone_num = 0;
      }
      else
        printf("NO PHONE NUMBER\n");
      if (header.config.organisation)
      {
        printf("ORGANISATION : %s\n", header.config.organisation);
        free(header.config.organisation);
        header.config.organisation = 0;
      }
      else
        printf("NO ORGANISATION\n");
      
      if (header.netfax_msg_class & NFE_NFMC_ENCRYPTED)	printf("ENCRYPTED\n");
      if (header.netfax_msg_class & NFE_NFMC_RTEXT)	printf("RTEXT\n");
      if (header.netfax_msg_class & NFE_NFMC_FAX)	printf("FAX\n");
      if (header.netfax_msg_class & NFE_NFMC_AUDIO)	printf("AUDIO\n");
      if (header.netfax_msg_class & NFE_NFMC_VIDEO)	printf("VIDEO\n");
      if (header.netfax_msg_class & NFE_NFMC_CONFIG)	printf("CONFIG\n");
      if (header.netfax_msg_class & NFE_NFMC_ADDRBK)	printf("ADDRBK\n");
      if (header.netfax_msg_class & NFE_NFMC_KEY)	printf("KEY\n");
      if (header.netfax_msg_class & NFE_NFMC_REPORT)	printf("REPORT\n");
      if (header.netfax_msg_class & NFE_NFMC_LOG)	printf("LOG\n");
      if (header.netfax_msg_class & NFE_NFMC_DELIVERYREPORT)	printf("DELIVERYREPORT\n");

      switch (header.msg_class)
      {
        case NFE_MC_INVALID:
          printf("MESSAGE IS INVALID\n");
          break;
        case NFE_MC_NETFAX_DATA:
          printf("MESSAGE HAS NETFAX DATA\n");
          break;
        case NFE_MC_SMTP_DELIVERY_ERROR:
          printf("MESSAGE IS A SMTP DELIVERY ERROR\n");
          break;
        case NFE_MC_UNKNOWN:
          printf("MESSAGE UNKNOWN\n");
          break;
        default:
          printf("MESSAGE CLASS TYPE INVALID!\n");
          break;
      }
      
      rc = new_context(&context);
      if (rc == NFE_COMPLETED)
      {
        NFE_LIST list;
        printf("created new context\n");
        
        rc = NFE_RUNNING;
        while ((!e) && (rc == NFE_RUNNING))
        {
          t_slice = clock() + slice;
          e = NFE_decode_msg_contents(&context, t_slice, file, length, &list, &rc);
        }
        destroy_context(&context);
        if (e)
          printf("KERNEL OSERROR!\n");
        else if (rc < NFE_COMPLETED)
          printf("rc: %d\n", rc);
        else
        {
          int32 num = 0;
          printf("rc: %d\n", rc);
          printf("SUCCESS decode_msg_contents!\n");
          
          rc = NFE_LIST_getnum(list, &num);
          if (rc == NFE_COMPLETED)
          {
            int i = 0;
            while ((i<num) && (rc >= 0))
            {
              NFE_MIME m = NFE_LIST_get(i, list);
              if (m)
              {
                NFE_NF_msg_class nfmsgclass;
                NFE_msg_class    msgclass;
                
                printf("GOT A MIME FROM NFE_LIST\n\n");
                rc = NFE_decode_mime_hdr(m, &nfmsgclass, &msgclass);
                if (rc == NFE_COMPLETED)
                {
                  switch(msgclass)
                  {
                    case NFE_MC_INVALID:
                      printf("MIME IS INVALID RFC822 MESSAGE\n");
                      break;
                    case NFE_MC_NETFAX_DATA:
                    {
                      printf("MIME HAS NETFAX DATA!\n");
                      printf("NetFax Message Class: %d\n\n", nfmsgclass);
                      
                      rc = new_context(&context);
                      if (rc == NFE_COMPLETED)
                      {
                        char out_file2[255];
                        FILE *file2 = 0;
                        
                        sprintf(out_file2, "%s%d", out_file, i);
                        printf("created new context\n");
                        file2 = fopen(out_file2, "wb");
                        if (file2)
                        {
                          rc = NFE_RUNNING;
                          while ((!e) && (rc == NFE_RUNNING))
                          {
                            t_slice = clock() + slice;
                            e = NFE_decode_mime(&context, t_slice, m, out_file2, file2, &rc);
                          }
                        }
                        else
                          printf("FAILED TO OPEN FILE: '%s'\n", out_file2);
                        destroy_context(&context);
                        if (e)
                          printf("KERNEL OSERROR!\n");
                        else if (rc != NFE_COMPLETED)
                          printf("rc: %d\n", rc);
                        else
                        {
                          printf("SUCCESS decode_mime!\n");
                        }
                      }
                      else
                        printf("failed to create context\n");
                      break;
                    }
                    case NFE_MC_SMTP_DELIVERY_ERROR:
                      printf("MIME HAS SMTP ERROR MESSAGE\n");
                      break;
                    case NFE_MC_UNKNOWN:
                      printf("MIME IS UNKNOWN\n");
                      break;
                    default:
                      printf("NFE_msg_class is broken!\n");
                      break;
                  }
                }
                else
                  printf("NFE_decode_mime_hdr FAILED: %d\n", rc);
              }
              i++;
            }
          }
          else
            printf("NFE_LIST_getnum failed: %d\n", rc);
        }
        if (list)
          list = NFE_LIST_destroy(list);
      }
    }
  }

#ifdef MEMCHECK
  MemCheck_OutputBlocksInfo();
#endif
}
