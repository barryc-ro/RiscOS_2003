/*	Project Daytona (757)
	Acorn Computers Ltd
	Copyright © 1997, 1998. All Rights Reserved.

	FILE:		NFElib.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.23 for RISC OS

	OVERVIEW
	========
	Source file for implementation of NFElib (NetFax Email Library)
	functions.  Called by the NFElib.c veneer.

	HISTORY
	=======
	18/09/97	0.01	RDW	initial version
	30/09/97	0.02	RDW	NFE_create_FAX_entity fixed, context
					was not dereferenced before assignment
	01/10/97	0.03	RDW	added if check to NFE_LIST_destroy
					before delete call
	01/10/97	0.04	RDW	In create_fax_entity_init c.retcode not
					checked correctly in if statement after
					AddParam/ReplaceParam call
					In NFE_create_FAX_entity FSM,
					NFE_decode_mime FSM and
					NFE_create_RFC822_msg FSM now set
					*rc = NFE_RUNNING before switching to
					ERROR state to make sure we're called
					back
					NFE_create_MIME_entity initialisation
					of *rc changed to NFE_RUNNING and
					susequent if check changed to check for
					this.  Fixes bug which may appear on
					certain file sizes/timeslices/machines
					where it'll end up returning NFE_COMPLETED
					when it hasn't!
	02/10/97	0.05	RDW	changed non-blocking FSMs functions
					so they init *rc to NFE_RUNNING before
					entering FSM loop.  FSM loop also changed
					to a do loop so that we at least do the
					FSM once before return.  Also, put a
					!expired() check just before loop start.
					This should prevent a possible live lock
					where by the time we reached the while
					check at the start of the loop the
					t_slice was up and we never, ever enter
					the FSM or do the call to another
					non-blocking function.
	07/10/97	0.06	RDW	Fix in NFE_LIST_get in case RFC882MSG
					case.  if GetMIMEentity call returns
					0, then we should *always* break out of
					the switch.  This wasn't being done before.
	27/10/97	0.07	RDW	Subject header support added
	24/11/97	0.08	RDW	NFE_create_RTEXT_entity function added and
					called from NFE_create_MIME_entity.
					CREATE_RTEXT_STATES type added.
					create_rtext_context type added.
					create_rtext_entity_init function added.
					NFE_decode_mime_hdr extended to handle
					RTEXT and text/plain without NetFax headers
	29/11/97	0.09	RDW	NFE_create_MIME_entity case on type
					changed so RTEXT, CONFIG, REPORT, LOG
					and FAXERROR all use NFE_create_TEXT_entity.
					(NFE_create_RTEXT_entity renamed to
					NFE_create_TEXT_entity).
					CONFIG, REPORT, LOG AND FAXERROR now
					supported.
					create_rfc822msg_init Fixed memory leak
					of the to_hdr and from_hdr which are
					copied by rfc822msg, so need to be
					destroyed.
					NFE_decode_msg_contents, creating rfc822msg
					object, ownership changed to TRUE in constructor
					parameters
	03/12/97	0.10	RDW	create_rfc822msg_init changed so Fax-Pages
					header only in message if fax data present
					Also, fix so that Message-Class header isn't
					present twice in a message headers list
	04/12/97	0.11	RDW	NFE_decode_mime parameters modified.
					now takes a FILE* which is for the
					given file out_file already opened
					with write access and binary mode
					and at the current position to start
					output at.
	08/12/97	0.12	RDW	NFE_decode_RFC822_hdr fixed so that
					it copies out the information for a
					non-Netfax RFC822 message
	09/01/98	0.13	RDW	decode_mime_init changed so that all
					MIME objects are accepted.
	09/01/98	0.14	RDW	Implemented NFE_MC_SMTP_DELIVERY_ERROR
					in NFE_decode_RFC822_hdr.
	19/01/98	0.15	RDW	NFE_decode_RFC822_hdr, if GetHdrs fails,
					but previous rc = NFE_COMPLETED, we
					return a INTERNALERR as this should
					never happen.
	20/01/98	0.16	RDW	create_rfc822msg_init fixed so that
					it returns NFE_NULLADDR and not
					NFE_FAILED for the cases when data
					items within the NFE_header structure
					are NULL.
					NFE_decode_RFC822_hdr and
					NFE_decode_msg_contents modified to
					cope with Non-fatal errors from
					ParseData
	22/01/98	0.17	RDW	NFE_decode_RFC822_hdr
					modified to fill in the new date_hdr
					in NFE_header structure.
	03/02/98	0.18	RDW	NFE_decode_mime fclose() calls
					removed that should have gone in
					version 0.11 changes!
					proper _kernel_oserrors returned now
					(oserror global added)
	04/02/98	0.19	RDW	NFE_decode_RFC822_hdr altered so that
					the Message-ID data is only extracted
					for NetFax messages which have FAX data
					in them
					Tidied up/added comments
					NFE_create_MIME_entity switch statement
					tidied up, grouping UNSUPPORTED cases
					together.
					NFE_decode_RFC822_hdr, to and from
					header check for NFE_NODATAPRESENT
					being returned for getting realname
	18/02/98	0.20	RDW	#includes changed to give pathname
	19/02/98	0.21	RDW	NFE_NFMC_FAXERROR renamed to
					NFE_NFMC_DELIVERYREPORT
					create_rfc822msg_init() creates
					X-NetFax-Return-Receipt-To header
					if data given and NFE_NFMC_DELIVERYREPORT
					not set for the message.
					NFE_decode_RFC822_hdr() decodes and
					extracts the Return-Receipt-To header
					as long as the message class doesn't
					have NFE_NFMC_DELIVERYREPORT set
	23/02/98	0.21	RDW	Tidy up comments and tidy up code, split in to sub
					functions to make more maintainable.
					private check_rc() function added
					NFE_create_MIME_entity() now calls check_rc
					NFE_create_TEXT_entity() duplicate init. of *rc removed
					                         initial state label correct to RTEXT from FAX!
					                         ERROR state, redundant zeroing of context members removed
					                         as the context get's deleted.
					                         context var. set to 0, not c var as c is the local handle
					                         not the one that is returned to the caller.  Same done
					                         for FINISHED state as well.
					                         APPLY_ENCODING_BUFSIZE added to replace value in ApplyEncoding call
					NFE_create_FAX_entity() duplicate init. of *rc removed
					                        ERROR state, redundant zeroing of context members removed
					                        as the context get's deleted.
					                        context var. set to 0, not c var as c is the local handle
					                        not the one that is returned to the caller.  Same done
					                        for FINISHED state as well.
					                        APPLY_ENCODING_BUFSIZE added to replace value in ApplyEncoding call
					                        create_text_entity_init erronous setting of c.state at end of function
					                        removed.
					NFE_create_RFC822_msg() now calls check_rc
					NFE_create_RFC822_msg() duplicate init. of *rc removed
					                        ERROR state, redundant zeroing of context members removed
					                        as the context get's deleted.
					                        context var. set to 0, not c var as c is the local handle
					                        not the one that is returned to the caller.  Same done
					                        for FINISHED state as well.
					                        destruction of c->mimeentity in FINISHED state removed as this
					                        object at this point belongs to the rfc822msg object and it
					                        destroys it.
					private create_to_hdr() function added for create_rfc822msg_init
					create_fax_entity_init() changed to cope with SERIAL reversed byte ordering
					create_messageid_hdr() changed to cope with SERIAL reversed byte ordering
					NFE_create_TEXT_entity(), NFE_create_FAX_entity(), NFE_create_RFC822_msg(),
					NFE_decode_mime() FSM's all fixed so they are not entered if returncode has been
					set to an error.  Bug showed itself as base64encoding failing and returning
					NFE_INTERNALERR.  This was due to in base64encode, expired() call failed, returncode
					was set to NFE_NOTENOUGHTTIME before the context instance had been created for the FSM
					However, the FSM was entered (uninitialised) so we end up in the default: (INTERNALERR)
					state.  Fixed now.
	25/02/98	0.22	RDW	Changed to take account of the movement of functions
					into the new support files (utils, create_ent and extract_hdr) to hopefully make
					NFELib more readable and maintainable.
	27/02/98	0.23	RDW	NFE_decode_mime changed for RFC822msgs, so it does a RemoveEncoding on the
					rfc822msg message body object to convert from 7bit encoding to OS text
					file format.
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "Email/EmailLib/MIMEimage.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/parameter.h"
#include "Email/EmailLib/contentT.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/from.h"
#include "Email/EmailLib/header.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/XNFfaxpage.h"
#include "Email/EmailLib/messageid.h"
#include "Email/EmailLib/XNFdevice.h"
#include "Email/EmailLib/XNFdevicec.h"
#include "Email/EmailLib/XNFserial.h"
#include "Email/EmailLib/XNFsoftrev.h"
#include "Email/EmailLib/XNFfaxnum.h"
#include "Email/EmailLib/XNFphoneno.h"
#include "Email/EmailLib/Xorganiz.h"
#include "Email/EmailLib/XNFmsgclas.h"
#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/822parser.h"
#include "Email/EmailLib/XNFrtnrcpt.h"

extern "C"
{
  #include "NFELib.h"
  #include "Email/EmailLib/ELib.h"
  #include "Email/EmailLib/Elib_priv.h"
}
#include "utils.h"
#include "create_ent.h"
#include "extracthdr.h"


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef void* NFE_MIME;

typedef enum
{
  DECODE_MIME_INIT,
  DECODE_MIME_DECODE_RFC822_INIT,
  DECODE_MIME_DECODE_RFC822,
  DECODE_MIME_DECODE_IMAGE_INIT,
  DECODE_MIME_DECODE_IMAGE,
  DECODE_MIME_FINISHED,
  DECODE_MIME_ERROR
} DECODE_MIME_STATES;								/* States of decode mime entity FSM, used in NFE_decode_mime() */

typedef struct
{
  NFE_CONTEXT_TYPE    type;							/* The type of the context data, all context structures in ELib have this */
  NFE_rcode           retcode;							/* The return code to pass back, in context so we can pass it the ERROR state and then to the caller */
  const char         *out_file;							/* The filename of the file to write the MIME body data into */
  DECODE_MIME_STATES  state;							/* The current state that the FSM is in */
  NFE_CONTEXT         decode_context;						/* The context handle for the RemoveEncoding or WriteOut method of the entity */
  FILE               *file;							/* The FILE ptr of the output file to write the entity body data into */
  entity             *ent;							/* The entity to decode, a rfc822msg or a MIMEentity of some type */
  MIMEentity         *me;							/* The MIMEentity within the RFC822msg, if there is one */
  body               *b;							/* The body of the entity to decode */
} decode_mime_context;								/* FSM data context, used in NFE_decode_mime() */


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
const static uint32 REMOVE_ENCODING_BUFSIZE = 4096;				// Size of buffer to use in Removing an Encoding from an entity


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static void decode_mime_init(decode_mime_context &c);				// Init. function used by NFE_decode_mime


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       NFE_create_MIME_entity
   DESCRIPTION:    Function to create a MIME entity of the possible forms
                   defined in the Daytona Email Functional Specification.  The
                   type of entity output is determined by the type parameter.
                   The function performs the process in small chunks deteremined
                   by the t_slice parameter.  The process will continue until it
                   either completes (rc = NFE_COMPLETED) or the t_slice period
                   is up (rc = NFE_RUNNING) or an error occurs (rc = -ve value,
                   OR rc = +ve value >= 2 - NON-FATAL error).
                   If an OS errors occurs then the function return code is NON
                   NULL and points to a RISC OS error block.
   DEPENDENCIES:   data type            NFE_CONTEXT      NFElib.h
                   data type            clock_t          <time.h>
                   data type            NFE_NF_msg_class NFElib.h
                   constant             SERIAL_LEN       NFElib.h
                   data type            uint32           Elib.h
                   data type            NFE_rcode        Elib.h
                   data type            NFE_MIME         NFElib.h
                   data type            _kernel_oserror  "kernel.h"
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_CONTEXT          context         create_MIME_entity current process context information
                   clock_t              t_slice         clock tick time to return by
                   const char *const    in_file         data file to use as input
                   NFE_NF_msg_class     type            type of NetFax MIME entity to create
                   const char *const    out_file        file to output MIME entity to
                   char[SERIAL_LEN]     serial_num      Device serial number
                   uint32               doc_num         Fax document number
                   uint32               page_num        Fax Page number
                   NFE_rcode *const     rc              NetFax Email Library return code.  Must point to a NFE_rcode
   OUTPUT PARAMS:  NFE_CONTEXT          context         create_MIME_entity current process context information
                   NFE_rcode *const     rc              NetFax Email Library return code
                   NFE_MIME            *obj             Created MIME entity
   RETURN VALUE:   _kernel_oserror*                     OS error
   VARIABLES:      _kernel_oserror*     e               return code
                   MIMEentity          *entity          The mime entity to return
 */
/* ************************************************************************** */
extern "C" _kernel_oserror *NFE_create_MIME_entity(NFE_CONTEXT           *context,
                                                   const clock_t          t_slice,
                                                   const char *const      in_file,
                                                   const NFE_NF_msg_class type,
                                                   const char *const      out_file,
                                                   const char             serial_num[],
                                                   const uint32           doc_num,
                                                   const uint32           page_num,
                                                   NFE_MIME*              obj,
                                                   NFE_rcode *const       rc)
{
  _kernel_oserror *e = 0;
  MIMEentity *entity = 0;							// The MIMEentity to return to the caller, data hidden using NFE_MIME type (obj output parameter)

  e = check_rc(rc);								// Make sure we can return the return code to the caller
    
  if (!e)									// No sys. error, so proceed
  {
    *rc = NFE_RUNNING;								// Initialise the return code
    
    if ((!in_file) || (!out_file) || (obj == 0))				// Check given parameters are valid
      *rc = NFE_NULLADDR;
    
    if (*rc == NFE_RUNNING)							// No error, so select creation FSM to use depending on the data type
    {  										// These create_X FSMs can probably be merged together, must look at doing this
      switch (type)
      {
        case NFE_NFMC_CONFIG:
        case NFE_NFMC_REPORT:
        case NFE_NFMC_LOG:
        case NFE_NFMC_DELIVERYREPORT:
        case NFE_NFMC_RTEXT:							// All of these are text/plain entitys
        {
          e = NFE_create_TEXT_entity(context,
                                     t_slice,
                                     in_file,
                                     out_file,
                                     type,
                                     entity,
                                     rc);
          *obj = (NFE_MIME*)entity;
          break;
        }
        case NFE_NFMC_FAX:							// Fax is the only image/tiff, oddly enough .......
        {
          e = NFE_create_FAX_entity(context,
                                    t_slice,
                                    in_file,
                                    out_file,
                                    serial_num,
                                    doc_num,
                                    page_num,
                                    entity,
                                    rc);
          *obj = (NFE_MIME*)entity;
          break;
        }
        case NFE_NFMC_ENCRYPTED:
        case NFE_NFMC_AUDIO:
        case NFE_NFMC_VIDEO:
        case NFE_NFMC_ADDRBK:
        case NFE_NFMC_KEY:
        default:								// Any other type is not supported, neither are combinations of types
        {
          *rc = NFE_NOTSUPPORTED;						// return error to caller
          break;
        }
      } // endswitch on type
    } // endif check on return code not being set to an error
  } // endif check on sys. error not being set
  
  return e;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_create_RFC822_msg
   DESCRIPTION:    Function to create a RFC822 message given the header
                   information for the message and the list of MIME entities
                   the message is to have.  In the NFE_header structure passed
                   in as input, if the return_receipt_to.address is not null,
                   this is taken to be a valid email address and the
                   X-NetFax-Return-Receipt-To header will be added to the
                   message provided the msg_class doesn't have the 10th bit,
                   NFE_NFMC_DELIVERYREPORT, set.  Also, if the
                   return_receipt_to.real_name is not null, it will be used
                   as the RealName with that email address.
                   If the function completes successfully,
                   NFE_COMPLETED returned, then the NFE_LIST mime_list is
                   destroyed by this function.  If an error occurs, the list
                   is not destroyed.
                   The function performs the process in small chunks deteremined
                   by the t_slice parameter.  The process will continue until it
                   either completes (rc = NFE_COMPLETED) or the t_slice period
                   is up (rc = NFE_RUNNING) or an error occurs (rc = -ve value,
                   OR rc = +ve value >= 2 - NON-FATAL error).
                   If an OS errors occurs then the function return code is NON
                   NULL and points to a RISC OS error block.
   DEPENDENCIES:   data type            NFE_CONTEXT     NFElib.h
                   data type            clock_t         <time.h>
                   data type            NFE_header      NFElib.h
                   data type            NFE_LIST        NFElib.h
                   data type            NFE_rcode       NFElib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_CONTEXT          context         create_RFC822_msg current process context information
                   clock_t              t_slice         clock tick time to return by
                   NFE_header*          header          RFC822 Message header information.  Must point to a NFE_header object.
                   NFE_LIST             mime_list       List holding details of each MIME entity to put in the message
                   const char *const    out_file        file to output MIME entity to
                   NFE_rcode *const     rc              NetFax Email Library return code.  Must point to a NFE_rcode
   OUTPUT PARAMS:  NFE_rcode *const     rc              NetFax Email Library return code
   RETURN VALUE:   _kernel_oserror*                     OS error
                   create_rfc822msg_context *c          context structure for this FSM
 */
/* ************************************************************************** */
extern "C" _kernel_oserror *NFE_create_RFC822_msg(NFE_CONTEXT       *context,
                                                  const clock_t      t_slice,
                                                  NFE_header        *header,
                                                  NFE_LIST           mime_list,
                                                  const char *const  out_file,
                                                  NFE_rcode *const   rc)
{
  _kernel_oserror          *e = 0;							// OS error to return
  create_rfc822msg_context *c = 0;							// Pointer to context structure for instance of this FSM
  
  e = check_rc(rc);									// Make sure we can return the return code to the caller

  if (!e)
  {
    *rc = NFE_RUNNING;									// Initialise the return code
    if (expired(t_slice))								// Check we've got enough time to initialise
      *rc = NFE_NOTENOUGHTIME;
    else
    {
      c = *((create_rfc822msg_context**)context);					// set the context handle to the one passed in by the caller
      if (c == 0)									// If 0, then this is to be a new instance of this FSM, so
      {
        c = (create_rfc822msg_context*)new create_rfc822msg_context;			// Create new context structure
        *context = (NFE_CONTEXT)c;							// Set context handle so we return this instance
        if (!c)										// Check creation of context succeeded
          *rc = NFE_MALLOCFAILED;
        else
        {
          memset(c, 0, sizeof(create_rfc822msg_context));				// Clear the context
          c->type = NFE_CT_CREATE_RFC822MSG;						// Set the type of this context to catch caller passing it to the wrong FSM
          c->state = CREATE_RFC822MSG_INIT;						// Set initial state of FSM
        }
      }
      else if (c->type != NFE_CT_CREATE_RFC822MSG)					// else, given handle was not 0, so check this context is for this FSM
        *rc = NFE_INVALIDCONTEXT;							// if not return error code
    }
    
    if (expired(t_slice))								// Check we've been given a big enough time slice for at least one iteration of the FSM
      *rc = NFE_NOTENOUGHTIME;

    if (*rc >= 0)									// check no error is set before entering FSM
    {
      do										// Beginning of FSM loop
      {
        switch (c->state)
        {
          case CREATE_RFC822MSG_INIT:							// State to create and initialise the rfc822msg object
          {
            dprintf(("", "CREATE_RFC822MSG_INIT\n"));
            if ((header == 0) || (out_file == 0) || (mime_list == 0))			// Check parameters are valid
            {
              c->retcode = NFE_NULLADDR;
              c->state = CREATE_RFC822MSG_ERROR;
              *rc = NFE_RUNNING;
            }
            else
            {
              c->retcode    = NFE_RUNNING;
              c->header     = header;
              c->mimeentity = (MIMEentity*)mime_list;
              c->out_file   = out_file;
              create_rfc822msg_init(*c);						// Create the rfc822msg object
              if (c->retcode == NFE_COMPLETED)
                c->retcode = NFE_RUNNING;
            }
            break;
          }
          case CREATE_RFC822MSG_WRITEOUT_INIT:						// State to prepare for writing out the rfc822msg object to a file
          {
            dprintf(("", "CREATE_RFC822MSG_WRITEOUT_INIT\n"));
            c->file = fopen(c->out_file, "wb");						// Open the file to output the message to
            
            if (c->file)
            {
              c->retcode = new_context(&(c->msg_writeout_context));			// Create a context handle for the writeout method
              if (c->retcode == NFE_COMPLETED)
              {
                c->retcode = NFE_RUNNING;
                c->state = CREATE_RFC822MSG_WRITEOUT;					// If successful, switch to the WRITEOUT state
              }
            }
            else									// Else, switch to the ERROR state
            {
              c->retcode = NFE_INVALIDFILENAME;
              c->state = CREATE_RFC822MSG_ERROR;
              *rc = NFE_RUNNING;
            }
            break;
          }
          case CREATE_RFC822MSG_WRITEOUT:						// State to drive the WriteOut method of the rfc822msg object
          {
            dprintf(("", "CREATE_RFC822MSG_WRITEOUT\n"));
            do
            {
              c->retcode = c->msg->WriteOut(c->msg_writeout_context, t_slice, c->file);
            } while ((c->retcode == NFE_RUNNING) && (!expired(t_slice)));		// Call WriteOut FSM method until completed, an error occurs or the timeslice expires
  
            if (c->retcode == NFE_COMPLETED)						// If writeout completed successfully, then
            {
              fclose(c->file);								// Close the file and destroy the context handle
              c->retcode = destroy_context(&(c->msg_writeout_context));
              if (c->retcode == NFE_COMPLETED)
                c->state = CREATE_RFC822MSG_FINISHED;					// Switch to the FINISHED state
              else
              {
                c->state = CREATE_RFC822MSG_ERROR;
                *rc = NFE_RUNNING;
              }
            }
            else if (c->retcode == NFE_RUNNING)						// Else, if writeout is not finished yet(still running)
            {
              *rc = NFE_RUNNING;							// Make sure NFE_RUNNING return code is returned
              c->state = CREATE_RFC822MSG_WRITEOUT;					// and stay in this state (we will drop out of our FSM loop as the time slice has expired)
            }
            else									// Else, an error has occured, so switch to ERROR state
            {
              fclose(c->file);								// Close the file
              c->state = CREATE_RFC822MSG_ERROR;
              *rc = NFE_RUNNING;
            }
            break;
          }
          case CREATE_RFC822MSG_ERROR:							// State to clean up this FSM instance and return the error that occured
          {
            dprintf(("", "CREATE_RFC882MSG_ERROR\n"));
            // clean up everything!
            if (c->msg)									// If the rfc822msg exists, destroy it
              delete c->msg;
            *rc = c->retcode;								// Pass out the error code that occured
            delete c;									// Destroy this context(instance) of the FSM
            *context = 0;								// Set context handle that's return to 0
            break;
          }
          case CREATE_RFC822MSG_FINISHED:						// clean up FSM context, terminate FSM and return
          {
            dprintf(("", "CREATE_RFC822MSG_FINISHED\n"));
            delete c->msg;								// destroy the rfc822msg object as we've successfully written it out to file
            *rc = NFE_COMPLETED;							// Set successful termination return code
            delete c;									// Destroy this context(instance) of the FSM
            *context = 0;								// Set context handle that's returned to 0
            break;
          }
          default:									// Catch all state to trap disasters
          {
            dprintf(("", "DEFAULT in CREATE_RFC822MSG FSM!!!\n"));
            *rc = NFE_INTERNALERR;							// We should never get here, unless context gets corrupted
            break;
          }
        } // endswitch
      } while ((*rc == NFE_RUNNING) && (!expired(t_slice)) && (e == 0));		// FSM keeps running until an error, it terminates or time slice expires
    }											// endif *rc check
  } // endif _kernel_oserror e check
  
  return e;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_LIST_create
   DESCRIPTION:    Function to create a new NFE_LIST object.  Returns non-NULL 
                   if successful, else returns NULL (failure)
   DEPENDENCIES:   data type    NFE_LIST        NFELib.h
                   data type    MIMEmultip      MIMEmultip.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_LIST                     the new list object
 */
/* ************************************************************************** */
extern "C" NFE_LIST NFE_LIST_create(void)
{
  return new MIMEmultip(FALSE, 0, 0, 0, NFE_CT_MULTIPART_MIXED, TRUE);
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_LIST_destroy
   DESCRIPTION:    Function to destroy a NFE_LIST object.  Returns NULL 
                   if successful, else returns the NFE_LIST
   DEPENDENCIES:   data type    NFE_LIST        NFELib.h
                   data type    entity          entity.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_LIST     list            the list to destroy
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_LIST                     the destroyed list
 */
/* ************************************************************************** */
extern "C" NFE_LIST NFE_LIST_destroy(NFE_LIST list)
{
  entity *e = (entity*)list;
  
  if (e)
    delete e;
  e = 0;
  list = (NFE_LIST)e;
  
  return list;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_LIST_add
   DESCRIPTION:    Function to add a NFE_MIME object to a NFE_LIST list.
   DEPENDENCIES:   data type    NFE_LIST        NFELib.h
                   data type    MIMEentity      MIMEentity.h
                   data type    MIMEmultip      MIMEmultip.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_MIME     object          MIME object to add to the list
                   NFE_LIST     list            the list to add to
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_rcode                    NFE_COMPLETED = success,
                                                -ve = failure
   VARIABLES:      NFE_rcode    rc              The return code
                   MIMEmultip  *mp              Typecast of the list
                   MIMEentity  *o               Typecast of the object
 */
/* ************************************************************************** */
extern "C" NFE_rcode NFE_LIST_add(NFE_MIME object,
                                  NFE_LIST list)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if ((object) && (list))
  {
    MIMEmultip *mp = (MIMEmultip*)list;
    MIMEentity *o  = (MIMEentity*)object;
    
    rc = mp->AddEntity(*o);
  }
  else
    rc = NFE_NULLADDR;
    
  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_LIST_getnum
   DESCRIPTION:    Function to get number of items in a NFE_LIST.
                   An NFE_LIST can either have a rfc822msg or MIMEentity
                   "hidden" behind it.  The MIMEentity may be a MIMEmultip.
                   So, need to find out the object type, then find out how
                   many "items" it has.  A plain rfc822msg (non-mime) has
                   1 (1message body).  A rfc822msg with a MIMEentity has
                   1 (1message body).  A rfc822msg with a MIMEmultip as
                   the MIMEentity has the number of entities in it.
   DEPENDENCIES:   data type            entity          entity.h
                   data type            NFE_rcode       ELib.h
                   data type            MIMEmultip      MIMEmultip.h
                   data type            MIMEentity      entity.h
                   data type            rfc822msg       rfc822msg.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_LIST             list            The list
   OUTPUT PARAMS:  int32               *num             The number of items in the list
   RETURN VALUE:   NFE_rcode                            NFE_COMPLETED = success,
                                                        -ve = failure
   VARIABLES:      NFE_rcode            rc              The return code
                   entity              *ent             Typecast of the list
 */
/* ************************************************************************** */
extern "C" NFE_rcode NFE_LIST_getnum(NFE_LIST  list,
                                     int32    *num)
{
  NFE_rcode rc = NFE_COMPLETED;
  entity     *ent = (entity*)list;
  
  if ((num == 0) || (list == 0))						// Check parameters are valid
    rc = NFE_NULLADDR;
  else
  {
    MIMEentity      *e    = (MIMEentity*)ent;					// The list is (at least) a MIMEentity object
    NFE_ENTITY_TYPE  type = ent->GetType();					// So, get it's real type
    *num                  = 0;							// Initialise number to 0
    
    switch (type)								// case type of entity, do
    {
      case NFE_ENTITY_RFC822MSG:						// entity(the list) is an RFC822msg
      {
        rfc822msg *msg = (rfc822msg*)ent;
        e              = msg->GetMIMEentity();					// Does it hold a MIMEentity?
        if (!e)									// If not then set number to 1 item in list (the plain rfc822 message body)
        {
          *num = 1;								// this is a plain rfc822 message, no mime so 1 item, the message body
          break;								// break out of the switch statement
        }									// NOTE, no break we want to fall through to NFE_ENTITY_MIME below if there was a MIMEentity
      }
      case NFE_ENTITY_MIME:							// entity (the list or entity from the RFC822msg) is a MIMEentity of some type
      {
        NFE_CT ct;
        rc = e->GetMajorType(ct);						// Get the type of this MIMEentity
        if (rc == NFE_COMPLETED)
        {
          MIMEmultip *mp = (MIMEmultip*)e;
          if (ct == NFE_CT_MULTIPART)						// If it's a multipart, report back the number of entities in it
            *num = mp->GetNumEntities();
          else									// Otherwise, return 1
            *num = 1;
        }
        else
          rc = NFE_FAILED;
        break;
      }
      case NFE_ENTITY_UNKNOWN:							// if we get here, something has gone horribly wrong!
      default:
      {
        rc = NFE_INTERNALERR;
        break;
      }
    } // endswitch
  }
  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_LIST_get
   DESCRIPTION:    Function to get the requested "item" at the given position
                   in a NFE_LIST.  As a NFE_LIST can be a rfc822msg object,
                   a MIMEentity or some sort or a MIMEmultip, we have to check
                   which one of these the NFE_LIST is, what is in it and then
                   return the item requested.  If the NFE_LIST is a PLAIN
                   rfc822msg(eg. no MIME entity in it) or a MIMEentity other
                   than a MIMEmultip, then only position 0 can be asked for
                   as these only hold one item of data.  However, if the
                   item is a MIMEmultip or the rfc822msg holds a MIMEmultip,
                   then other position numbers are valid.
   DEPENDENCIES:   data type            entity          entity.h
                   data type            NFE_rcode       ELib.h
                   data type            MIMEmultip      MIMEmultip.h
                   data type            MIMEentity      entity.h
                   data type            rfc822msg       rfc822msg.h
                   data type            NFE_LIST        NFELib.h
                   data type            NFE_MIME        NFELib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_LIST             list            The list
                   int32                pos             The item to get from the list
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_rcode                            NFE_COMPLETED = success,
                                                        -ve = failure
   VARIABLES:      NFE_rcode            rc              The return code
                   entity              *entity          Typecast of the list
 */
/* ************************************************************************** */
extern "C" NFE_MIME NFE_LIST_get(int32 pos, NFE_LIST list)
{
  NFE_rcode  rc  = NFE_COMPLETED;
  entity    *ent = (entity*)list;
  
  if (list == 0)								// Check parameter is valid
    rc = NFE_NULLADDR;
  else
  {
    MIMEentity      *e    = (MIMEentity*)ent;					// The list is (at least) a MIMEentity object
    NFE_ENTITY_TYPE  type = ent->GetType();					// So, get it's real type
    
    switch (type)								// case type of entity, do
    {
      case NFE_ENTITY_RFC822MSG:						// entity(the list) is an RFC822msg
      {
        rfc822msg *msg = (rfc822msg*)ent;
        e = msg->GetMIMEentity();						// Does it hold a MIMEentity?
        if (!e)									// If not then 
        {
          if (pos > 0)								// plain rfc822 message only has one item so if they've asked for an iemt other than 0 return NULL
            ent = 0;
          break;								// break out of the switch statement
        }									// NOTE, no break we want to fall through to NFE_ENTITY_MIME below if there was a MIMEentity
      }
      case NFE_ENTITY_MIME:							// entity (the list or entity from the RFC822msg) is a MIMEentity of some type
      {
        NFE_CT ct;
        rc = e->GetMajorType(ct);						// Get the type of this MIMEentity
        if (rc == NFE_COMPLETED)
        {
          MIMEmultip *mp = (MIMEmultip*)e;
          if (ct == NFE_CT_MULTIPART)						// If it's a multipart, Get the entity at the position requested
            ent = mp->GetEntity(pos);
          else if (pos == 0)							// Else, caller can only request the 0th element of the list as the list is a single entity
            ent = e;								// return it
          else									// Else, caller requested oter than the 0th element and this is a single entity, so
            ent = 0;								// return NULL (Error)
        }
        else
          ent = 0;
        break;
      }
      case NFE_ENTITY_UNKNOWN:							// if we get here, something has gone horribly wrong!
      default:
      {
        ent = 0;
        break;
      }
    } // endswitch
  }
  
  return (NFE_MIME)ent;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_decode_RFC822_hdr
   DESCRIPTION:    Function to decode the information from an RFC822 message
                   header.  The input is a filename of a file which holds either
                   a complete RFC822 message, or just the headers of such a
                   message.  The function will decode the header and fill in
                   the given NFE_header structure with the details.
                   The function performs the process in small chunks deteremined
                   by the t_slice parameter.  The process will continue until it
                   either completes (rc = NFE_COMPLETED) or the t_slice period
                   is up (rc = NFE_RUNNING) or an error occurs (rc = -ve value,
                   OR rc = +ve value >= 2 - NON-FATAL error).
                   If an OS errors occurs then the function return code is NON
                   NULL and points to a RISC OS error block.
                   If in the returned NFE_header the return_receipt_to.address
                   is not NULL, the sender of this message requests a receipt
                   (delivery report) to be sent back to this email address.
                   If the address is not null, then the return_receipt_to.real_name
                   may also be set to the sender's "real name"
   DEPENDENCIES:   data type            NFE_CONTEXT     NFElib.h
                   data type            clock_t         <time.h>
                   data type            NFE_header      NFElib.h
                   data type            NFE_rcode       NFElib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_CONTEXT          context         decode_RFC822_hdr current process context information
                   clock_t              t_slice         clock tick time to return by
                   const char *const    in_file         File that holds the RFC822 headers/RFC822 message
                   uint32               length          length of the headers in the in_file in characters.  Length is
                                                        the length to the end of the last header
                   NFE_header*          header          RFC822 Message header information.  Must point to a NFE_header object
                   NFE_rcode *const     rc              NetFax Email Library return code.  Must point to a NFE_rcode
   OUTPUT PARAMS:  NFE_header*          header          Header details filled in
                   NFE_rcode *const     rc              NetFax Email Library return code
   RETURN VALUE:   _kernel_oserror*                     OS error
   VARIABLES:      _kernel_oserror*     e               OS error to return
*/
/* ************************************************************************** */
extern "C" _kernel_oserror *NFE_decode_RFC822_hdr(NFE_CONTEXT       *context,
                                                  const clock_t      t_slice,
                                                  BOOL               file,
                                                  const char *const  in_file,
                                                  uint32             length,
                                                  NFE_header        *hdr,
                                                  NFE_rcode *const   rc)
{
  _kernel_oserror       *e = 0;

  e = check_rc(rc);								// Make sure we can return the return code to the caller
  if (!e)
  {
    if (expired(t_slice))							// Check we've got enough time
      *rc = NFE_NOTENOUGHTIME;
    else if ((hdr == 0) || (context == 0) || (in_file == 0))			// Check parameters are valid
      *rc = NFE_NULLADDR;
    else if (length == 0)
      *rc = NFE_FAILED;
    else
    {
      entity     ent(file, (char*)in_file, 0, length, NFE_ENTITY_UNKNOWN, FALSE);	// Create the Entity and give it the file to parse
      NFE_rcode  retcode = NFE_COMPLETED;
      
      retcode = ent.ParseData(*context, t_slice);				// Instruct the entity to parse the data it's been given
      if (retcode >= NFE_COMPLETED)						// If parsing was successful (or at least non-fatal), then
        retcode = NFE_COMPLETED;						// Set to successful completition
      if (retcode == NFE_COMPLETED)
        retcode = extract_NFE_header(ent, hdr);					// Extract the NFE_header details from the entity
      *rc = retcode;								// Pass back to caller the return code
    }
  }
  
  return e;
}
  

/* ************************************************************************** */
/*
   FUNCTION:       NFE_decode_msg_contents
   DESCRIPTION:    Function to decode the body contents of an RFC822 message.
                   The input is a filename of a file which holds a complete
                   RFC822 message.  The function will decode the contents of
                   the message by processing it's headers, and where present,
                   the MIME data.  As output it returns an NFE_LIST
                   which holds a list of data structures, one for each Netfax
                   understood MIME entity in the message (a NFE_MIME).
                   DO NOT call NFE_LIST_create first.  This function will
                   create the list for you.
                   The function performs the process in small chunks deteremined
                   by the t_slice parameter.  The process will continue until it
                   either completes (rc = NFE_COMPLETED) or the t_slice period
                   is up (rc = NFE_RUNNING) or an error occurs (rc = -ve value,
                   OR rc = +ve value >= 2 - NON-FATAL error).
                   If an OS errors occurs then the function return code is NON
                   NULL and points to a RISC OS error block.
   DEPENDENCIES:   data type            NFE_CONTEXT     NFELib.h
                   data type            clock_t         <time.h>
                   data type            uint32          Elib.h
                   data type            NFE_LIST        NFELib.h
                   data type            NFE_header      NFELib.h
                   data type            NFE_rcode       NFELib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_CONTEXT          context         decode_msg_contents current process context information
                   clock_t              t_slice         clock tick time to return by
                   const char *const    in_file         File that holds the RFC822 message
                   uint32               length          length of the message in characters(bytes)
                   NFE_rcode *const     rc              NetFax Email Library return code.  Must point to a NFE_rcode
   OUTPUT PARAMS:  NFE_rcode *const     rc              NetFax Email Library return code
                   NFE_LIST             mime_list       List of objects, one object for each netfax MIME object
   RETURN VALUE:   _kernel_oserror*                     OS error
 */
/* ************************************************************************** */
extern "C" _kernel_oserror *NFE_decode_msg_contents(NFE_CONTEXT      *context,
                                                    const clock_t     t_slice,
                                                    const char *const in_file,
                                                    uint32            length,
                                                    NFE_LIST         *mime_list,
                                                    NFE_rcode *const  rc)
{
  _kernel_oserror *e = 0;
  
  e = check_rc(rc);								// Make sure we can return the return code to the caller
  if (!e)
  {
    if (expired(t_slice))							// Check we've got enough time
      *rc = NFE_NOTENOUGHTIME;
    else if ((mime_list == 0) || (context == 0) || (in_file == 0))		// Check parameters are valid
      *rc = NFE_NULLADDR;
    else if (length == 0)
      *rc = NFE_FAILED;
    else
    {
      rfc822msg *msg = new rfc822msg(TRUE, (char*)in_file, 0, length, TRUE);	// Create an rfc822msg and give it the data to parse
      
      if (msg)
        *rc = msg->ParseData(*context, t_slice);				// Parse the data if creation worked
      else
        *rc = NFE_MALLOCFAILED;							// else, return error
      if (*rc < NFE_COMPLETED)
      {
        if (msg)
          delete msg;
        mime_list = 0;
      }
      else
        *mime_list = (NFE_LIST)msg;
    }
  }
  
  return e;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_decode_mime_hdr
   DESCRIPTION:    Function to decode the information from a NFE_MIME object
   DEPENDENCIES:   data type            NFE_MIME         NFELib.h
                   data type            NFE_NF_msg_class NFELib.h
                   data type            NFE_msg_class    NFELib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_MIME             mime
   OUTPUT PARAMS:  NFE_NF_msg_class    *netfax_msg_class        netfax data type in mime object
                   NFE_msg_class       *msg_class               type of message
   RETURN VALUE:   NFE_rcode            rc                      NetFax Email Library return code
 */
/* ************************************************************************** */
extern "C" NFE_rcode NFE_decode_mime_hdr(NFE_MIME          mime,
                                         NFE_NF_msg_class *netfax_msg_class,
                                         NFE_msg_class    *msg_class)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if ((netfax_msg_class == 0) || (msg_class == 0) || (mime == 0))		// Check parameters are valid
    rc = NFE_NULLADDR;
  else
  {
    entity          *ent  = (entity*)mime;
    MIMEentity      *e    = (MIMEentity*)ent;
    NFE_ENTITY_TYPE  type = ent->GetType();
    *netfax_msg_class     = NFE_NFMC_NONE;					// Default to unknown NetFax type
    *msg_class            = NFE_MC_UNKNOWN;					// Default to an unknown message
    
    switch (type)								// case type of entity, do
    {
      case NFE_ENTITY_RFC822MSG:						// entity(the list) is an RFC822msg
      {
        rfc822msg *msg = (rfc822msg*)ent;
        *msg_class = NFE_MC_UNKNOWN;						// Default to an unknown message
        ent = msg->GetMIMEentity();						// Does it hold a MIMEentity?
        if (!ent)								// If not then 
        {
          *netfax_msg_class = NFE_NFMC_NONE;					// No NetFax data in message
          break;								// break out of the switch statement
        }									// NOTE, no break we want to fall through to NFE_ENTITY_MIME below if there was a MIMEentity
      }
      case NFE_ENTITY_MIME:							// entity (the list or entity from the RFC822msg) is a MIMEentity of some type
      {
        NFE_CT ct;
        rc = e->GetMajorType(ct);						// Get the type of this MIMEentity
        if (rc == NFE_COMPLETED)
        {
          MIMEmultip *mp = (MIMEmultip*)e;
          if (ct == NFE_CT_MULTIPART)						// If it's a multipart, then return error as it's invalid to pass in a MIMEmultip object.
            rc = NFE_FAILED;							// Must be a atomic MIMEentity (eg. MIMEimage) or a plain rfc822msg
          else
          {
            headers *h = ent->GetHdrs();					// Get the headers of the entity
            if (h)
            {
              XNFmsgclass *msgclass_hdr = (XNFmsgclass*)h->FindHdr(NFE_HDR_X_NF_MESSAGE_CLASS);
              if (msgclass_hdr)							// If "X-NetFax-Message-Class" header exists, this is a NETFAX message
              {
                *netfax_msg_class = (NFE_NF_msg_class)msgclass_hdr->Get();
                *msg_class = NFE_MC_NETFAX_DATA;
              }
              else								// else, this is a NON-NetFax MIMEentity
              {
                if (ct == NFE_CT_TEXT)						// check if it is a text/plain.  If yes, then treat as if it was an RTEXT
                {
                  *netfax_msg_class = NFE_NFMC_RTEXT;
                  *msg_class = NFE_MC_NETFAX_DATA;
                }
              }
            }
          }
        }
        else
          rc = NFE_FAILED;							// need better error code.  MIMEentity MUST have a content-type header
        break;
      }
      case NFE_ENTITY_UNKNOWN:							// if we get here, something has gone horribly wrong!
      default:
      {
        rc = NFE_INTERNALERR;
        break;
      }
    } // endswitch
  }
  
  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       NFE_decode_mime
   DESCRIPTION:    Function to decode the body contents of a MIME entity in
                   a message.  The inputs are a filename of a file which
                   holds a complete RFC822 message, the NFE_MIME object
                   which describes the MIME entity in the message to decode,
                   the filename to put the decoded data in and the file
                   handle for that file already opened in binary mode,
                   at the position in the file to start writing at and
                   opened with write permission.
                   The NFE_MIME object is obtained from the output list from
                   the NFE_decode_msg_contents function which must be called
                   first.  The function will decode MIME entity by using the
                   message's headers and MIME information.
                   As output it writes the decoded data into the out_file
                   using the given file descriptor fd.  This must be the
                   for the given out_file and opened with write permission
                   and in binary mode.
                   The function performs the process in small chunks deteremined
                   by the t_slice parameter.  The process will continue until it
                   either completes (rc = NFE_COMPLETED) or the t_slice period
                   is up (rc = NFE_RUNNING) or an error occurs (rc = -ve value,
                   OR rc = +ve value >= 2 - NON-FATAL error).
                   If an OS errors occurs then the function return code is NON
                   NULL and points to a RISC OS error block.
   DEPENDENCIES:   data type            NFE_CONTEXT             NFElib.h
                   data type            clock_t                 <time.h>
                   data type            NFE_header              NFElib.h
                   data type            NFE_rcode               NFElib.h
                   function             NFE_decode_msg_contents NFElib.h
   DEPENDED ON BY: !Daytona Control application
   INPUT PARAMS:   NFE_CONTEXT          context         decode_mime current process context information
                   clock_t              t_slice         clock tick time to return by
                   NFE_MIME             mime            MIME object which describes which entity to decode
                   const char *const    out_file        File to write decoded data into
                   FILE                *fd              File descriptor of the file
                   NFE_rcode *const     rc              NetFax Email Library return code.  Must point to a NFE_rcode
   OUTPUT PARAMS:  NFE_rcode *const     rc              NetFax Email Library return code
   RETURN VALUE:   _kernel_oserror*                     OS error
   VARIABLES:      _kernel_oserror     *e               OS error to return
 */
/* ************************************************************************** */
extern "C" _kernel_oserror *NFE_decode_mime(NFE_CONTEXT       *context,
                                            const clock_t      t_slice,
                                            NFE_MIME           mime,
                                            const char *const  out_file,
                                            FILE              *fd,
                                            NFE_rcode *const   rc)
{
  _kernel_oserror     *e = 0;							// OS error to return
  decode_mime_context *c = 0;							// Pointer to context structure for instance of this FSM
  
  e = check_rc(rc);								// Make sure we can return the return code to the caller
  if (!e)									// No sys. error, so proceed
  {
    if (expired(t_slice))							// Check we've got enough time to initialise
      *rc = NFE_NOTENOUGHTIME;
    else
    {
      *rc = NFE_RUNNING;							// Initialise return code      
      c = *((decode_mime_context**)context);					// set the context handle to the one passed in by the caller
      if (c == 0)								// If 0, then this is to be a new instance of this FSM, so
      {
        c = (decode_mime_context*)new decode_mime_context;			// Create new context structure
        *context = (NFE_CONTEXT)c;						// Set context handle so we return this instance
        if (!c)									// Check creation of context succeeded
          *rc = NFE_MALLOCFAILED;
        else
        {
          memset(c, 0, sizeof(decode_mime_context));				// Clear the context
          c->type = NFE_CT_DECODE_MIME;						// Set the type of this context to catch caller passing it to the wrong FSM
          c->state = DECODE_MIME_INIT;						// Set initial state of FSM and setup other defaults
        }
      }
      else if (c->type != NFE_CT_DECODE_MIME)					// else, given handle was not 0, so check this context is for this FSM
        *rc = NFE_INVALIDCONTEXT;						// if not return error code
    }
    
    if (expired(t_slice))							// Check we've been given a big enough time slice for at least one iteration of the FSM
      *rc = NFE_NOTENOUGHTIME;
      
    if (*rc >= 0)								// check no error is set before entering FSM
    {
      do									// Beginning of FSM loop
      {
        switch (c->state)
        {
          case DECODE_MIME_INIT:						// State to initialise for decoding the entity 
          {
            dprintf(("", "DECODE_MIME_INIT\n"));
            if ((mime == 0) || (out_file == 0) || (fd == 0))			// Check parameters
            {
              c->retcode = NFE_NULLADDR;
              c->state = DECODE_MIME_ERROR;
              *rc = NFE_RUNNING;
            }
            else
            {
              c->retcode = NFE_RUNNING;
              c->ent      = (entity*)mime;
              c->out_file = out_file;
              c->file = fd;
              decode_mime_init(*c);						// Initialise the FSM
              if (c->retcode == NFE_COMPLETED)
                c->retcode = NFE_RUNNING;
            }
            break;
          }
          case DECODE_MIME_DECODE_RFC822_INIT:					// State to prepare & initialise for decoding the entity if it is a RFC822msg
          {
            dprintf(("", "DECODE_MIME_DECODE_RFC822_INIT\n"));
            
            if (c->file)							// Check We've got a FILE* pointer
            {
              c->retcode = new_context(&(c->decode_context));			// Create new context handle for the decode
              if (c->retcode == NFE_COMPLETED)					// If successful, switch to the rfc822 decode state
              {
                c->state = DECODE_MIME_DECODE_RFC822;
                *rc = NFE_RUNNING;
                c->retcode = NFE_RUNNING;
              }
              else								// Else, switch to error state
              {
                c->state = DECODE_MIME_ERROR;
                *rc = NFE_RUNNING;
                destroy_context(&(c->decode_context));
              }
            }
            else								// else, no FILE* given, return error.
            {
              c->retcode = NFE_INVALIDFILENAME;
              c->state = DECODE_MIME_ERROR;
              *rc = NFE_RUNNING;
            }        
            break;
          }
          case DECODE_MIME_DECODE_RFC822:					// State to do the decoding of this RFC822 message
          {
            dprintf(("", "DECODE_MIME_DECODE_RFC822\n"));
            do
            {
//              c->retcode = c->b->WriteOut(c->decode_context, t_slice, c->file);
              c->retcode = c->b->RemoveEncoding(c->decode_context,
                                                t_slice,
                                                (char*)c->out_file,
                                                fd,
                                                REMOVE_ENCODING_BUFSIZE);
            } while ((c->retcode == NFE_RUNNING) && (!expired(t_slice)));	// Call WriteOut FSM method until completed, an error occurs or the timeslice expires
            
            if (c->retcode == NFE_COMPLETED)					// If completed successfully, then
            {
              c->retcode = destroy_context(&(c->decode_context));		// Destroy this context handle
              if (c->retcode == NFE_COMPLETED)
                c->state = DECODE_MIME_FINISHED;				// Switch to the FINISHED state
              else
              {
                c->state = DECODE_MIME_ERROR;
                *rc = NFE_RUNNING;
              }
            }
            else if (c->retcode == NFE_RUNNING)					// Else, if encoding is not finished yet(still running)
            {
              *rc = NFE_RUNNING;						// Make sure NFE_RUNNING return code is returned
              c->state = DECODE_MIME_DECODE_RFC822;				// and stay in this state (we will drop out of our FSM loop as the time slice has expired)
            }
            else								// Else, an error has occured, so switch to ERROR state
            {
              c->state = DECODE_MIME_ERROR;
              *rc = NFE_RUNNING;
            }
            break;
          }
          case DECODE_MIME_DECODE_IMAGE_INIT:					// State to prepare & initialise for decoding the entity if it is a MIMEentity
          {
            dprintf(("", "DECODE_MIME_DECODE_IMAGE_INIT\n"));
            c->retcode = new_context(&(c->decode_context));			// Create new context handle for the decode
            if (c->retcode == NFE_COMPLETED)					// If successful, switch to the mimeentity decode or writeout state
            {
              c->state = DECODE_MIME_DECODE_IMAGE;
              *rc = NFE_RUNNING;
              c->retcode = NFE_RUNNING;
            }
            else								// If error code set, then switch to ERROR state
            {
              c->state = DECODE_MIME_ERROR;
              *rc = NFE_RUNNING;
              destroy_context(&(c->decode_context));
            }
            break;
          }
          case DECODE_MIME_DECODE_IMAGE:					// State to do the decoding of this MIMEentity message
          {
            dprintf(("", "DECODE_MIME_DECODE_IMAGE\n"));
            do
            {
              c->retcode = c->me->RemoveEncoding(c->decode_context,
                                                 t_slice,
                                                 (char*)c->out_file,
                                                 fd,
                                                 REMOVE_ENCODING_BUFSIZE);
            } while ((c->retcode == NFE_RUNNING) && (!expired(t_slice)));	// Call RemoveEncoding FSM method until completed, an error occurs or the timeslice expires
  
            if (c->retcode == NFE_COMPLETED)					// If completed successfully, then
            {
              c->retcode = destroy_context(&(c->decode_context));		// Destroy this context handle
              if (c->retcode == NFE_COMPLETED)
                c->state = DECODE_MIME_FINISHED;				// Switch to the FINISHED state
              else
              {
                c->state = DECODE_MIME_ERROR;
                *rc = NFE_RUNNING;
              }
            }
            else if (c->retcode == NFE_RUNNING)					// Else, if encoding is not finished yet(still running)
            {
              *rc = NFE_RUNNING;							// Make sure NFE_RUNNING return code is returned
              c->state = DECODE_MIME_DECODE_IMAGE;				// and stay in this state (we will drop out of our FSM loop as the time slice has expired)
            }
            else								// Else, an error has occured, so switch to ERROR state
            {
              c->state = DECODE_MIME_ERROR;
              *rc = NFE_RUNNING;
            }
            break;
          }
          case DECODE_MIME_ERROR:						// State to clean up this FSM instance and return the error that occured
          {
            dprintf(("", "DECODE_MIME_ERROR\n"));
            *rc = c->retcode;							// Pass out the error code that occured
            delete c;								// Destroy this context(instance) of the FSM
            *context = 0;							// Set context handle that's return to 0
            break;
          }
          case DECODE_MIME_FINISHED:						// clean up FSM context, terminate FSM and return
          {
            dprintf(("", "DECODE_MIME_FINISHED\n"));
            *rc = NFE_COMPLETED;						// Set successful termination return code
            delete c;								// Destroy this context(instance) of the FSM
            *context = 0;							// Set context handle that's returned to 0
            break;
          }
          default:								// Catch all state to trap disasters
          {
            dprintf(("", "DECODE_MIME FSM BROKEN!!!\n"));
            *rc = NFE_INTERNALERR;
            break;
          }
        } // endswitch
      } while ((*rc == NFE_RUNNING) && (!expired(t_slice)) && (e == 0));
    }										// endif *rc check
  } // endif rc == 0
  
  return e;
}    


/* ************************************************************************** */
/*
   FUNCTION:       decode_mime_init
   DESCRIPTION:    Function to do the DECODE_MIME_INIT state of the
                   NFE_decode_mime FSM
   DEPENDENCIES:   data type           decode_mime_context      NFELib.c++
   DEPENDED ON BY: function            NFE_decode_mime          NFELib.c++
   INPUT PARAMS:   NFE_CONTEXT         &context         current process context information
   OUTPUT PARAMS:  NFE_CONTEXT         &context         current process context information
   RETURN VALUE:   NONE
   VARIABLES:      
 */
/* ************************************************************************** */
static void decode_mime_init(decode_mime_context &c)
{
  NFE_ENTITY_TYPE type = c.ent->GetType();
        
  switch (type)									// case type of entity, do
  {
    case NFE_ENTITY_RFC822MSG:							// entity is an RFC822msg
    {
      rfc822msg *msg = (rfc822msg*)c.ent;
      c.me = msg->GetMIMEentity();						// Does it hold a MIMEentity?
      if (!c.me)								// If not, get the body of this plain rfc822msg
      {
        c.b = msg->GetBody();
        if (c.b)
          c.state = DECODE_MIME_DECODE_RFC822_INIT;				// Switch to the RFC822 decode init state
        else
        {
          c.retcode = NFE_FAILED;
          c.state = DECODE_MIME_ERROR;
        }
        break;									// break out of switch
      }										// NOTE, no break we want to fall through to NFE_ENTITY_MIME below if there was a MIMEentity
    }
    case NFE_ENTITY_MIME:							// entity (or entity from the RFC822msg) is a MIMEentity of some type
    {
      NFE_CT ct;
      if (c.me == 0)
        c.me = (MIMEentity*)c.ent;
      c.retcode = c.me->GetMajorType(ct);					// Get the type of this MIMEentity
      if (c.retcode == NFE_COMPLETED)
      {
        if (ct == NFE_CT_MULTIPART)						// If it's a multipart, then 
        {
          c.me = ((MIMEmultip*)c.me)->GetEntity(0);				// get 1st entity in multipart(there should be only one! as if it is a REAL multipart, the NFE_LIST access methods should
          if (c.me == 0)							// have been used to extract each entity in turn and given them to this function one at a time
          {
            c.retcode = NFE_FAILED;
            c.state = DECODE_MIME_ERROR;
          }
          else
            c.retcode = NFE_FAILED;
        }
        if (c.retcode == NFE_COMPLETED)
        {
          c.state = DECODE_MIME_DECODE_IMAGE_INIT;				// Switch to DECODE MIME entity init state
        }
      }
      break;
    }
    default:									// if we get here, something has gone horribly wrong!
    {
      c.retcode = NFE_INTERNALERR;
      break;
    }
  } // endswitch on type
  
  if (c.retcode == NFE_COMPLETED)
    c.retcode = NFE_RUNNING;
}

