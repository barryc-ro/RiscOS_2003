/*	Project Daytona (757)
	Acorn Computers Ltd
	Copyright © 1997, 1998. All Rights Reserved.

	FILE:		extracthdr.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.03 for RISC OS

	OVERVIEW
	========
	Source file for implementation of extract_NFE_header
	functions.  Used by NFE_decode_RFC822_hdr in NFELib.c++

	HISTORY
	=======
	25/02/97	0.01	RDW	initial version
	02/03/98	0.02	RDW	Fixed extract_NFE_header and extract_NFE_header_address
					so that we don't try to extract the
					returnreciptto_hdr unless it exists!
	08/06/98	0.03	RDW	corrected error where message class header
					presence was not checked for before doing
					Get() operation
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "extracthdr.h"
#include "Email/EmailLib/MIMEimage.h"
#include "Email/EmailLib/MIMEtext.h"
#include "Email/EmailLib/parameter.h"
#include "Email/EmailLib/contentT.h"
#include "Email/EmailLib/to.h"
#include "Email/EmailLib/from.h"
#include "Email/EmailLib/header.h"
#include "Email/EmailLib/date.h"
#include "Email/EmailLib/subject.h"
#include "Email/EmailLib/XNFfaxpage.h"
#include "Email/EmailLib/messageid.h"
#include "Email/EmailLib/XNFdevice.h"
#include "Email/EmailLib/XNFdevicec.h"
#include "Email/EmailLib/XNFserial.h"
#include "Email/EmailLib/XNFsoftrev.h"
#include "Email/EmailLib/XNFfaxnum.h"
#include "Email/EmailLib/XNFphoneno.h"
#include "Email/EmailLib/Xorganiz.h"
#include "Email/EmailLib/XNFmsgclas.h"
#include "Email/EmailLib/rfc822msg.h"
#include "Email/EmailLib/MIMEmultip.h"
#include "Email/EmailLib/822parser.h"
#include "Email/EmailLib/XNFrtnrcpt.h"

extern "C"
{
  #include "NFELib.h"
  #include "Email/EmailLib/ELib.h"
  #include "Email/EmailLib/Elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static NFE_rcode extract_NFE_header_NFE_address(from         *the_hdr,
                                                NFE_address&  addr);		// Function to extract the email address details into a NFE_address
static NFE_rcode extract_NFE_header_date(date *date_hdr, NFE_header *hdr);	// Function to extract the date into a NFE_header
static NFE_rcode extract_NFE_header_faxpages(XNFfaxpages *faxpages_hdr,
                                             NFE_header  *hdr);			// Function to extract the fax pages header details into a NFE_header
static NFE_rcode extract_NFE_header_messageid(messageid  *messageid_hdr,
                                              XNFmsgclass*msgclass_hdr,
                                              NFE_header *hdr);			// Function to extract the message id details into a NFE_header
static NFE_rcode extract_NFE_header_plain(header *the_hdr, char* &string);	// Function to extract the plain header string contents into a char*
static NFE_rcode extract_NFE_header_serial(XNFserial  *serial_hdr,
                                           NFE_header *hdr);			// Function to extract the serial number header details into a NFE_header
static NFE_rcode extract_NFE_header_softrev(XNFsoftrev *softrev_hdr,
                                            NFE_header *hdr);			// Function to extract the software revision header details into a NFE_header
static NFE_rcode extract_NFE_header_faxnum(XNFfaxnum *the_hdr,
                                           char*     &tele_num);		// Function to extract the telephone header type details into a char*


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

extern NFE_rcode extract_NFE_header(entity &ent, NFE_header *hdr)
{
  NFE_rcode  retcode = NFE_COMPLETED;
  headers   *h       = 0;
  
  h = ent.GetHdrs();								// Get the headers of the entity
  if (h)
  {
    headers hdrs(*h);								// Don't remember why we make a copy of the headers, there seems to be no point
    										// However, too risky at this stage to change this, not enough time to test change
    to                 *to_hdr              = (to*)hdrs.FindHdr(NFE_HDR_TO);	// Get the "To" header, then all the other header's we're interested in
    from               *from_hdr            = (from*)hdrs.FindHdr(NFE_HDR_FROM);
    date               *date_hdr            = (date*)hdrs.FindHdr(NFE_HDR_DATE);
    subject            *subject_hdr         = (subject*)hdrs.FindHdr(NFE_HDR_SUBJECT);
    XNFfaxpages        *faxpages_hdr        = (XNFfaxpages*)hdrs.FindHdr(NFE_HDR_X_NF_FAX_PAGES);
    messageid          *messageid_hdr       = (messageid*)hdrs.FindHdr(NFE_HDR_MESSAGE_ID);
    XNFdevice          *device_hdr          = (XNFdevice*)hdrs.FindHdr(NFE_HDR_X_NF_DEVICE);
    XNFdeviceclass     *deviceclass_hdr     = (XNFdeviceclass*)hdrs.FindHdr(NFE_HDR_X_NF_DEVICE_CLASS);
    XNFserial          *serial_hdr          = (XNFserial*)hdrs.FindHdr(NFE_HDR_X_NF_SERIAL);
    XNFsoftrev         *softrev_hdr         = (XNFsoftrev*)hdrs.FindHdr(NFE_HDR_X_NF_SOFTWARE_REV);
    XNFfaxnum          *faxnum_hdr          = (XNFfaxnum*)hdrs.FindHdr(NFE_HDR_X_NF_FAX_NUMBER);
    XNFphonenum        *phonenum_hdr        = (XNFphonenum*)hdrs.FindHdr(NFE_HDR_X_NF_PHONE_NUMBER);
    Xorganization      *organization_hdr    = (Xorganization*)hdrs.FindHdr(NFE_HDR_X_ORGANIZATION);
    XNFmsgclass        *msgclass_hdr        = (XNFmsgclass*)hdrs.FindHdr(NFE_HDR_X_NF_MESSAGE_CLASS);
    header             *returnpath_hdr      = hdrs.FindHdr("Return-Path");
    XNFreturnreceiptto *returnreceiptto_hdr = (XNFreturnreceiptto*)hdrs.FindHdr(NFE_HDR_X_NF_RETURN_RECEIPT_TO);
    
    if ((!to_hdr) || (!from_hdr) || (!date_hdr))				// If there is no source, destination or date header, this is invalid RFC822
      hdr->msg_class = NFE_MC_INVALID;						// ATM, we need a To & From.  Need to change this to any valid source & destination headers
    else
    {
      if (msgclass_hdr)
        hdr->msg_class = NFE_MC_NETFAX_DATA;
      else if (returnpath_hdr)
        hdr->msg_class = NFE_MC_UNKNOWN;
      else
        hdr->msg_class = NFE_MC_SMTP_DELIVERY_ERROR;
      retcode = extract_NFE_header_NFE_address(to_hdr, hdr->to);		// Extract the "To" details into the "to" NFE_address in NFE_header
      if (returnreceiptto_hdr)
      {
        retcode = extract_NFE_header_NFE_address(returnreceiptto_hdr,
                                                 hdr->return_receipt_to);	// Extract the "X-NetFax-Return-Receipt-To" details into the NFE_header, only if we found one
      }
      retcode = extract_NFE_header_NFE_address(from_hdr, hdr->from);		// Extract the "From" details into the "from" NFE_address in NFE_header
      retcode = extract_NFE_header_date(date_hdr, hdr);				// Extract the "Date" details into the NFE_header
      retcode = extract_NFE_header_faxpages(faxpages_hdr, hdr);			// Extract the "X-NetFax-Fax-Pages" details into the NFE_header
      retcode = extract_NFE_header_messageid(messageid_hdr, msgclass_hdr, hdr);	// Extract the "Message-ID" details into the NFE_header
      retcode = extract_NFE_header_plain(subject_hdr, hdr->subject);		// Extract the "Subject" details into the NFE_header
      retcode = extract_NFE_header_plain(device_hdr, hdr->details.device);	// Extract the "X-NetFax-Device" details into the NFE_header
      if (deviceclass_hdr)
        hdr->details.device_class = deviceclass_hdr->Get();			// Extract the "X-NetFax-Device-Class" value into the NFE_header
      retcode = extract_NFE_header_serial(serial_hdr, hdr);			// Extract the "X-NetFax-Serial" details into the NFE_header
      retcode = extract_NFE_header_softrev(softrev_hdr, hdr);			// Extract the "X-NetFax-Software-Rev" details into the NFE_header
      retcode = extract_NFE_header_faxnum(faxnum_hdr, hdr->config.fax_num);	// Extract the "X-NetFax-Fax-Number" details into the NFE_header
      retcode = extract_NFE_header_faxnum(phonenum_hdr, hdr->config.phone_num);	// Extract the "X-NetFax-Phone-Number" details into the NFE_header (XNFphonenum is child of XNFfaxnum)
      retcode = extract_NFE_header_plain(organization_hdr,
                                         hdr->config.organisation);		// Extract the "X-Organization" details into the NFE_header
      if (retcode == NFE_COMPLETED)
      {
        if (msgclass_hdr)
          hdr->netfax_msg_class = (NFE_NF_msg_class)msgclass_hdr->Get();	// Extract the "X-NetFax-Message-Class" details into the NFE_header
        else
          hdr->netfax_msg_class = NFE_NFMC_NONE;
      }
    }
  }
  else										// if we didn't get the headers
    retcode = NFE_INTERNALERR;							// return INTERNALERR, this should never happen!

  return retcode;
}


static NFE_rcode extract_NFE_header_NFE_address(from *the_hdr, NFE_address& addr)// From header as it is the base class address header
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (the_hdr)									// Check we've got a header
    retcode = the_hdr->GetBodyLen(len);						// Get the length of the To header contents
  else
    retcode = NFE_NULLADDR;							// else, set error code
  if (retcode == NFE_COMPLETED)							// If okay, create space for the address and Get it into the NFE_address
  {
    len += 1;
    if (addr.address = malloc(len+1))
      retcode = the_hdr->GetAddress(addr.address, len);
  }
  if (retcode == NFE_COMPLETED)							// If okay Get the "real name" of the address
    retcode = the_hdr->GetBodyLen(len);
  if (retcode == NFE_COMPLETED)
  {
    len+=1;
    if (addr.real_name = malloc(len+1))
    {
      retcode = the_hdr->GetRealName(addr.real_name, len);
      if (retcode == NFE_NODATAPRESENT)						// If the real name doesn't exist free the buffer created for it
      {
        free(addr.real_name);
        addr.real_name = 0;
        retcode = NFE_COMPLETED;						// Clear the error code as it's valid not to have a RealName
      }
    }
  }
  
  return retcode;
}

  
static NFE_rcode extract_NFE_header_date(date *date_hdr, NFE_header *hdr)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  hdr->date = date_hdr->GetDate();
  retcode   = date_hdr->GetBodyLen(len);
  if (retcode == NFE_COMPLETED)
  {
    len += 1;
    if (hdr->date_hdr = malloc(len+1))
      retcode = date_hdr->GetUnfoldedNoCommentsBody(hdr->date_hdr, len);
  }
    
  return retcode;
}


static NFE_rcode extract_NFE_header_faxpages(XNFfaxpages *faxpages_hdr, NFE_header *hdr)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (faxpages_hdr)
  {
    hdr->id.msg_num_pages   = faxpages_hdr->GetNumber();
    hdr->id.exact_num_pages = faxpages_hdr->Exact();
  }

  return retcode;
}


static NFE_rcode extract_NFE_header_messageid(messageid *messageid_hdr, XNFmsgclass *msgclass_hdr, NFE_header *hdr)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if ((messageid_hdr) &&
      (hdr->msg_class == NFE_MC_NETFAX_DATA) &&
      ((NFE_NF_msg_class)msgclass_hdr->Get() & NFE_NFMC_FAX))			// if Message-ID header exists and the email is NETFAX DATA compliant and the NETFAX DATA has FAX DATA, then extract the data from the Message-ID header
  {
    retcode = messageid_hdr->GetBodyLen(len);
    len +=1;
    char *buf = malloc(len+1);
    if (buf)
    {
      retcode = messageid_hdr->GetLocalpart(buf, len);
      if (retcode == NFE_COMPLETED)
      {
        char *ptr = buf;
        uint32 size = len;
        BOOL error = FALSE;
        
        error = consume_number(ptr, size, 1, 10, hdr->id.first_page_num);
        if (!error)
        {
          if (*ptr == '-')
          {
            error = consume_char(ptr, size, '-');
            if (!error)	error = consume_number(ptr, size, 1, 10, hdr->id.last_page_num);
          }
          else
            hdr->id.last_page_num = hdr->id.first_page_num;
        }
        if (!error)	error = consume_char(ptr, size, '.');
        if (!error)	error = consume_number(ptr, size, 1, 10, hdr->id.doc_num);
        if (!error)	error = consume_char(ptr, size, '.');
        if (error)	retcode = NFE_FAILED;
      }
      delete[]buf;
    }
  }
  else
  {
    /* else, fake up the message details */
    hdr->id.first_page_num = 1;
    hdr->id.last_page_num = 1;
    hdr->id.doc_num = 1;
  }

  return retcode;
}


static NFE_rcode extract_NFE_header_plain(header *the_hdr, char* &string)	// char* &string, string is a reference to a char*
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (the_hdr)
  {
    if (retcode == NFE_COMPLETED)
      retcode = the_hdr->GetBodyLen(len);
    if (retcode == NFE_COMPLETED)
    {
      len += 1;
      if (string = malloc(len+1))
        retcode = the_hdr->GetUnfoldedNoCommentsBody(string, len);
    }
  }

  return retcode;
}


static NFE_rcode extract_NFE_header_serial(XNFserial *serial_hdr, NFE_header *hdr)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (serial_hdr)
  {
    if (retcode == NFE_COMPLETED)
    {
      if (retcode == NFE_COMPLETED)
      {
        len = SERIAL_LEN;
        retcode = serial_hdr->Get(hdr->details.serial_num, len);
      }
    }
  }

  return retcode;
}


static NFE_rcode extract_NFE_header_softrev(XNFsoftrev *softrev_hdr, NFE_header *hdr)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (softrev_hdr)
  {
    if (retcode == NFE_COMPLETED)
    {
      retcode = softrev_hdr->GetMajor(hdr->details.software_rev_major);
      if (retcode == NFE_COMPLETED)
        retcode = softrev_hdr->GetMinor(hdr->details.software_rev_minor);
    }
  }

  return retcode;
}


static NFE_rcode extract_NFE_header_faxnum(XNFfaxnum *the_hdr, char* &tele_num)
{
  NFE_rcode retcode = NFE_COMPLETED;
  uint32    len     = 0;
  
  if (the_hdr)
  {
    if (retcode == NFE_COMPLETED)
    {
      retcode = the_hdr->GetBodyLen(len);
      if (retcode == NFE_COMPLETED)
      {
        len +=1;
        if (tele_num = malloc(len+1))
          retcode = the_hdr->GetUnfoldedNoCommentsBody(tele_num, len);
      }
    }
  }

  return retcode;
}
