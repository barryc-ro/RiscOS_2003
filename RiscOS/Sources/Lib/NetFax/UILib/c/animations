/************************************************************************/
/* File:    Animations.c                                                */
/* Purpose: Code to handle animations and the clock in Daytona.         */
/*                                                                      */
/* Author:  John Beranek <mailto:jberanek@acorn.com>                    */
/*          taken over from Neil Bingham                                */
/*          Some enhancements for more flexible animations by mrison.   */
/*                                                                      */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS ------------------ */
#include "include.h"
#include "windows.h"
#include "animations.h"
#include "globals.h"

/* ---------------------- LOCAL FUNCTIONS ---------------------------------- */
static void next_animation_frame (void);
static void show_next_frame (AnimationRec *, ComponentId);
static void show_frame (AnimationRec *, ComponentId);

/* ---------------------- LOCAL VARIABLES ---------------------------------- */
static AnimationRec	centre;
static AnimationRec	left;
static AnimationRec	right;

/* ---------------------- GLOBAL VARIABLES --------------------------------- */
clock_t         confirm_start = 0, decide_start = 0;

/* ---------------------- FUNCTIONS ---------------------------------------- */

#define Strncpy(d, s, n) (*(d) = '\0', strncat ((d), (s), (n) - 1))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

/************************************************************************/
/* ui_read_time                                                         */
/*                                                                      */
/* Function reads the monotonic time of the system for timing null poll */
/* events.  This is then used to kick off the ui_pollword_handler       */
/* function for controlling the animations and clock.                   */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
void ui_read_time (unsigned int *p_time)
{
  _swix (OS_ReadMonotonicTime, _OUT(0), p_time);
}


/************************************************************************/
/* ui_pollword_handler                                                  */
/*                                                                      */
/* Function kicks off the animations etc. on null wimp polls.           */
/*                                                                      */
/* Parameters: WimpEventHandler parameters                              */
/*                                                                      */
/* Returns:    TRUE or FALSE.                                           */
/*                                                                      */
/************************************************************************/
int ui_pollword_handler (int event_code, WimpPollBlock *event, IdBlock *id_block,
                         void *handle)
{
  static char time_counter = 0;

  IGNORE (event_code); IGNORE (event); IGNORE (id_block); IGNORE (handle);

  ui_read_time (&current);

  /* Animations */
  if ((future /* + Poll_Delay_Animations [what's this in aid of?] */) <= current)
  {
    /* Only do something if there are any windows open */
    if (ui_currently_open_win != NULL)
    {
      /* Animation Polling */
      if (ui_currently_open_win == Home_WindowHandle)
      {
        next_animation_frame ();
      }
      future = current + Poll_Delay_Animations;

      time_counter++;

      /* If there's a "confirm" in operartion */
      if (confirm_start != 0)
      {
        /* Check if it's timed out */
        if (clock () > (confirm_start + (Timeout_Confirm * CLOCKS_PER_SEC)))
        {
          dprintf (("", ">>UI<< Confirm window timed-out\n"));
          /* If it has, call the correct function and reset the confirm time */
          (*confirm_fun_point)(ConfirmAction_Finished);
          confirm_start = 0;
        }
      }

      /* If there's a "decide" in operation */
      if (decide_start != 0)
      {
        /* Check if it's timed out */
        if (clock () > (decide_start + (Timeout_Decide * CLOCKS_PER_SEC)))
        {
          dprintf (("", ">>UI<< Decide window timed-out\n"));
          /* If it has, call the correct function with the timeout default,
             and reset the decide time */
          (*decide_fun_point)(DecideAction_Finished, decide_timeout_default);
          decide_start = 0;
        }
      }

      if (time_counter > 9)
      {
        /* Because we don't need to update the clock every 1/3 seconds, add
           the clock code in here where it will poll every 6 seconds or so. */
        /* Well it will now update every second -- MGR */
        ui_update_clock_display ();
        time_counter = 0;
      }
    }
  }
  return 1;
}


/************************************************************************/
/* ui_initialise_animations                                             */
/*                                                                      */
/* Function initialises the animations code.                            */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    _kernel_oserror.                                         */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_initialise_animations (void)
{
#if DAYTONA

  /* Left */
  *left.leaf_name = '\0';
  *left.sequence = '\0';
  left.dstogo = -1;
  left.current_frame = -1;
  left.loop_once = FALSE;
  /* Centre */
  *centre.leaf_name = '\0';
  *centre.sequence = '\0';
  centre.dstogo = -1;
  centre.current_frame = -1;
  centre.loop_once = FALSE;
  /* Right */
  *right.leaf_name = '\0';
  *right.sequence = '\0';
  right.dstogo = -1;
  right.current_frame = -1;
  right.loop_once = FALSE;
#endif
  return NULL;
}


/************************************************************************/
/* ui_register_animation                                                */
/*                                                                      */
/* Function registers an animation set for one of the three on-screen   */
/* buttons.                                                             */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Left side button.                    */
/*                          1   Y  Centre button.                       */
/*                          2   Y  Right side button.                   */
/*                          3   Y  Stop animation after one sequence.   */
/* Parameters: flags    - Bit 0 (Left), Bit 1 (Centre), Bit 2 (Right)   */
/*             leaf_name- Name for sprite set.                          */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_register_animation (int flags, char *leaf_name)
{
#if DAYTONA
  char *sequence;
  char *space;
  int len;

  sequence = lookup_message_token (&message_block, leaf_name);
  if (sequence == NULL)
     return (_kernel_oserror *) "    No such animation"; /* Yeah, yeah, I know... */

  /* Check for replacement sprite set */
  space = strchr (sequence, ' ');
  if (space) {
     len = space - sequence + 1; /* len is total length of leaf_name, including terminator */
     leaf_name = sequence;
     sequence = space + 1;
  } else {
     len = strlen (leaf_name) + 1;
  }

  if (flags & AnimationRegister_Left
     && (strncmp (left.leaf_name, leaf_name, len) != 0
        || strcmp (left.sequence, sequence) != 0))
  {
    Strncpy (left.leaf_name, leaf_name, MIN (len, sizeof left.leaf_name));
    Strncpy (left.sequence, sequence, sizeof (left.sequence));
    left.current_frame = 0;
    left.loop_once = FALSE;
    left.dstogo = 0;
    ui_home_set_sprite (AnimationRegister_Left, "blank_a"); /* In case moving from bigger to smaller */
    show_next_frame (&left, home_left_sprite);
  }
  else if (flags & AnimationRegister_Centre
          && (strncmp (centre.leaf_name, leaf_name, len) != 0
             || strcmp (centre.sequence, sequence) != 0))
  {
    Strncpy (centre.leaf_name, leaf_name, MIN (len, sizeof centre.leaf_name));
    Strncpy (centre.sequence, sequence, sizeof (centre.sequence));
    centre.current_frame = 0;
    centre.loop_once = FALSE;
    centre.dstogo = 0;
    ui_home_set_sprite (AnimationRegister_Centre, "blank_c"); /* In case moving from bigger to smaller */
    show_next_frame (&centre, home_centre_sprite);
  }
  else if (flags & AnimationRegister_Right
          && (strncmp (right.leaf_name, leaf_name, len) != 0
             || strcmp (right.sequence, sequence) != 0))
  {
    Strncpy (right.leaf_name, leaf_name, MIN (len, sizeof right.leaf_name));
    Strncpy (right.sequence, sequence, sizeof (right.sequence));
    right.current_frame = 0;
    if (flags & AnimationRegister_Once)
      right.loop_once = TRUE;
    else
      right.loop_once = FALSE;
    right.dstogo = 0;
    ui_home_set_sprite (AnimationRegister_Right, "blank_a"); /* In case moving from bigger to smaller */
    show_next_frame (&right, home_right_sprite);
  }
#endif
  return NULL;
}


/************************************************************************/
/* ui_deregister_animation                                              */
/*                                                                      */
/* Function deregisters an animation set for one of the three on-screen */
/* buttons.                                                             */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Left side button.                    */
/*                          1   Y  Centre button.                       */
/*                          2   Y  Right side button.                   */
/*                          3   Y  Do not replace animation with blank  */
/*                                 sprite - stops flicker.              */
/*                                                                      */
/* Returns:    _kernel_oserror block.                                   */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_deregister_animation (int flags)
{
#if DAYTONA

  _kernel_oserror *er = NULL;

  if (flags & AnimationDeregister_Left)
  {
    if (left.dstogo != -1)
    {
      left.current_frame = -1;
      left.dstogo = -1;
      *left.leaf_name = '\0';

      /* If bit 3 is not set then blank the button */
      if (!(flags & AnimationDeregister_NoReplace))
      {
        /* Blank Button */
        er = button_set_value (0, Home_WindowHandle, home_left_sprite, "blank_a");
        if (er)
          return er;
      }
    }
  }
  else if (flags & AnimationDeregister_Centre)
  {
    if (centre.dstogo != -1)
    {
      centre.current_frame = -1;
      centre.dstogo = -1;
      *centre.leaf_name = '\0';

      /* If bit 3 is set then do not blank the button */
      if (!(flags & AnimationDeregister_NoReplace))
      {
        /* Blank Button */
        er = button_set_value (0, Home_WindowHandle, home_centre_sprite, "blank_c");
        if (er)
          return er;
      }
    }
  }
  else if (flags & AnimationDeregister_Right)
  {
    if (right.dstogo != -1)
    {
      right.current_frame = -1;
      right.dstogo = -1;
      *right.leaf_name = '\0';

      /* If bit 3 is set then do not blank the button */
      if (!(flags & AnimationDeregister_NoReplace))
      {
        /* Blank Button */
        er = button_set_value (0, Home_WindowHandle, home_right_sprite, "blank_a");
        if (er)
          return er;
      }
    }
  }
  return er;
#else
  return NULL;
#endif
}


/************************************************************************/
/* next_animation_frame                                                 */
/*                                                                      */
/* Function will cycle through the sprite set.  It determines which     */
/* buttons to animate depending on which buttons have sprites registered*/
/* to them.                                                             */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void next_animation_frame (void)
{
  /* See if left button is set */
  if (left.dstogo != -1)
  {
    /* Left sprite */
    show_next_frame (&left, home_left_sprite);
  }
  if (centre.dstogo != -1)
  {
    /* Centre sprite */
    show_next_frame (&centre, home_centre_sprite);
  }
  if (right.dstogo != -1)
  {
    /* Right sprite */
    show_next_frame (&right, home_right_sprite);
  }
}


/************************************************************************/
/* show_next_frame                                                      */
/*                                                                      */
/* Function will show the next frame in the button specified in         */
/* Animation Rec.                                                       */
/*                                                                      */
/* Parameters: record   - Information on the current sequence.          */
/*             button   - the button to show the next frame in.         */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static void show_next_frame (AnimationRec *record, ComponentId button)
{
#if DAYTONA
/*
  dprintf (("","Leaf_name:     %s\n", record->leaf_name));
  dprintf (("","last_frame:    %d\n", record->last_frame));
  dprintf (("","Current_frame: %d\n", record->current_frame));
*/

/*
  _swix (256+7, 0);
  _swix (256+4, 0);
  _swix (256+30, 0);
  _swix (256+65, 0);
*/

  if (record->dstogo == 0) { /* Initialisation; see ui_register_animation */

     record->current_frame = 0;

  } else {

     if (--record->dstogo)
        return;

     if (++record->current_frame * 2 + 1 >= strlen (record->sequence)) {

        if (record->loop_once == TRUE) {

           ui_deregister_animation (AnimationDeregister_Right);
           return;

        } else {

           record->current_frame = 0;

        }

     }

  }

  record->dstogo = record->sequence[record->current_frame * 2 + 1] - '0';

  if (record->dstogo > 9) /* Allow A-Z (36imal) */
     record->dstogo -= 'A' - '9' - 1;

  if (record->dstogo <= 0) /* This should never happen! */
     record->dstogo = 666;

  ++record->dstogo; /* This is so that if the next tick comes just next
                     * we get at least one tick's worth of frame */

  show_frame (record, button);

  return;

#endif
}

static void show_frame (AnimationRec *record, ComponentId button)
{
#if DAYTONA
  char frame_name[16];

  /* Build spritename */
  /* This is not very buffer-overflow-safe, but... */
  sprintf (frame_name, "%s_%s%s%d", record->leaf_name
          , button == home_left_sprite ? "l" : ""
          , button == home_right_sprite ? "r" : ""
          , record->sequence[record->current_frame * 2] - '0');

/*
  _swix (256+7, 0);
  _swix (256+4, 0);
  _swix (256+30, 0);
  _swix (256+65, 0);
  printf (frame_name);
*/
  button_set_value (0, Home_WindowHandle, button, frame_name);
#endif
}
