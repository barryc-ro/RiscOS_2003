/************************************************************************/
/* File:    Window.c                                                    */
/* Purpose: Window Handling Functions for Daytona.                      */
/*                                                                      */
/* Author:  John Beranek  <mailto:jberanek@acorn.com>                   */
/*          taken over from Neil Bingham                                */
/*                                                                      */
/************************************************************************/


/* -------------------------------------- LIBRARY IMPORTS --------------------------------------- */
#include "include.h"
#include "font.h"
#include "windows.h"
#include "globals.h"

/* Window Sizes and offsets */
#define menu_softkey_size	288	/* Softkey window width in Menu mode (WIDE) */
#define confirm_softkey_size	144	/* Softkey window width in Confirm mode (NARROW) */
#define menu_title_size		524	/* Title window width in Menu mode (WIDE) */
#define confirm_title_size	636	/* Title window width in Confirm mode (NARROW) */
#define full_title_size		836	/* Title window width when there is no Soft Key window */

#define softkey_window_offset	114	/* Offset to use to move the Title window so that the
					 * buttons are shown when in NARROW mode */

/* Window Opening Positions
 *
 * Main Window
 */
#define main_open_x		   0
#define main_open_y		-316
#define main_size_x		 956
#define main_size_y		 316
/* Feedback Window */
#define feed_open_x		   2
#define feed_open_y		  -2
#define feed_size_x		 128
#define feed_size_y		 -44
/* SoftKey Window (Narrow) */
#define soft_open_n_x		 762
#define soft_open_n_y		  -2
#define soft_size_n_x		 192
#define soft_size_n_y		-312
/* SoftKey Window (Wide) */
#define soft_open_w_x		 700
#define soft_open_w_y		  -2
#define soft_size_w_x		 254
#define soft_size_w_y		-312
/* Title Window (Narrow) */
#define title_open_n_x		 134
#define title_open_n_y		  -2
#define title_size_n_x		 562
#define title_size_n_y		 -44
/* Title Window (Wide) */
#define title_open_w_x		 134
#define title_open_w_y		  -2
#define title_size_w_x		 624
#define title_size_w_y		 -44
/* Title Window (Full) */
#define title_open_f_x		 134
#define title_open_f_y		  -2
#define title_size_f_x		 820
#define title_size_f_y		 -44
/* Editable Window (Full) */
#define edit_open_f_x		   2
#define edit_open_f_y		 -50
#define edit_size_f_x		 952
#define edit_size_f_y		-264
/* Editable Window (Big) */
#define edit_open_b_x		   2
#define edit_open_b_y		 -50
#define edit_size_b_x		 756
#define edit_size_b_y		-264
/* Editable Window (Small) */
#define edit_open_s_x		   2
#define edit_open_s_y		 -50
#define edit_size_s_x		 694
#define edit_size_s_y		-264

/* Gadget Buttons */
#define title_label		0x00
#define softkey_1_label		0x01
#define softkey_2_label		0x02
#define softkey_3_label		0x03
#define softkey_4_label		0x04


/* -------------------- LOCAL FUNCTIONS ---------------------------------- */
static _kernel_oserror *nest_window (unsigned int, ObjectId, int, int, int, int);
static _kernel_oserror *resize_windows (unsigned int);
static _kernel_oserror *open_main_window (void);
static _kernel_oserror *ui_fade_gadget (ObjectId, ComponentId, int);
static void ui_confirmwindow_keypressed (void);
static void ui_decidewindow_keypressed (int);

/* -------------------- GLOBAL VARIABLES --------------------------------- */
ObjectId	ui_currently_open_win = NULL;

/* Window Handles */
ObjectId	Main_WindowHandle;
ObjectId	Feed_WindowHandle;
ObjectId	Title_WindowHandle;
ObjectId	Soft_WindowHandle;
ObjectId	Decide_WindowHandle;
ObjectId	Confirm_WindowHandle;
ObjectId	Home_WindowHandle;

MessagesFD	message_block;

unsigned int	future, current;

int decide_timeout_default = 1;
void (*decide_fun_point)(int, int);
void (*confirm_fun_point)(int);

/* -------------------- FUNCTIONS ---------------------------------------- */

/************************************************************************/
/* ui_attach_handlers                                                   */
/*                                                                      */
/* This function handles the auto creation events for UILib windows,    */
/* and sets up ObjectId handles, and fonts for these windows.  It also  */
/* registers a few wimp handlers for UILib windows.  This should be     */
/* called as the otherwise clause at the end of the UILib application's */
/* auto created handler.                                                */
/*                                                                      */
/* Parameters: event     - The auto-created event block                 */
/*             id_block  - The auto-created event ID block              */
/*                                                                      */
/* Returns:    1 if the event was claimed.                              */
/*             0 if the event was not claimed.                          */
/*                                                                      */
/************************************************************************/
int ui_attach_handlers (ToolboxObjectAutoCreatedEvent *event, IdBlock *id_block)
{
#if DAYTONA
  static int windows_initialised = 0;

  /* MAIN_WIN */
  if (strcmp (event->template_name, "main_win")==0)
  {
    /* Define handle for main_win */
    Main_WindowHandle = id_block->self_id;

    windows_initialised++;
  }

  /* FEED_WIN */
  else if (strcmp (event->template_name, "feed_win")==0)
  {
    /* Define handle for feed_win */
    Feed_WindowHandle = id_block->self_id;

    /* Setup Clock font settings */
    ui_font_clock ();

    windows_initialised++;
  }

  /* SOFT_WIN */
  else if (strcmp (event->template_name, "soft_win")==0)
  {
    /* Define handle for soft_win */
    Soft_WindowHandle = id_block->self_id;

    /* Setup SoftKeys font settings */
    ui_font_softkeys ();

    windows_initialised++;
  }

  /* TITLE_WIN */
  else if (strcmp (event->template_name, "title_win")==0)
  {
    /* Define handle for title_win */
    Title_WindowHandle = id_block->self_id;

    /* Setup Title font settings */
    ui_font_title ();

    windows_initialised++;
  }

  /* DECIDE_WIN */
  else if (strcmp (event->template_name, "decide_win")==0)
  {
    dprintf (("", ">>UI<< Auto-created decide_win\n"));
    /* Define handle for decide_win */
    Decide_WindowHandle = id_block->self_id;

    ui_font_status (Decide_WindowHandle, decide_textarea);

    event_register_wimp_handler (Decide_WindowHandle, Wimp_EKeyPressed,
                                 ui_decidewindow_keypress_handler, 0);
    windows_initialised++;
  }

  /* CONFIRM_WIN */
  else if (strcmp (event->template_name, "confirm_win")==0)
  {
    dprintf (("", ">>UI<< Auto-created confirm_win\n"));
    /* Define handle for confirm_win */
    Confirm_WindowHandle = id_block->self_id;

    ui_font_status (Confirm_WindowHandle, confirm_textarea);

    event_register_wimp_handler (Confirm_WindowHandle, Wimp_EKeyPressed,
                                 ui_confirmwindow_keypress_handler, 0);

    windows_initialised++;
  }

  if (windows_initialised == 6)
    return 1;
  else
    return 0;
#endif
  return 1;
}

/************************************************************************/
/* ui_key_handler                                                       */
/*                                                                      */
/* This function is a backup (paranoia) handler for key presses that    */
/* occur in UILib managed windows.  It should be called from the        */
/* client's default key handler when ui_currently_open_win is set to    */
/* either the Confirm or Decide window.                                 */
/*                                                                      */
/* Parameters: key_code  - The key code obtained from the key event     */
/*                                                                      */
/* Returns:    1                                                        */
/*                                                                      */
/************************************************************************/
int ui_key_handler (int key_code)
{
  if (ui_currently_open_win == Decide_WindowHandle)
    ui_decidewindow_keypressed (key_code);
  else if (ui_currently_open_win == Confirm_WindowHandle)
    ui_confirmwindow_keypressed ();

  return 1;
}


static void ui_confirmwindow_keypressed (void)
{
  dprintf (("", ">>UI<< Keypress in confirm_win\n"));

  /* If a key's been pressed, call the return function */
  (*confirm_fun_point)(ConfirmAction_Finished);
  confirm_start = 0;
}

static void ui_decidewindow_keypressed (int key_code)
{
  int ret;

  dprintf (("", ">>UI<< Keypress in decide_win, code = %d", key_code));

  /* Only do something when either softkey 1 or 2 is pressed */
  if (key_code == KeyCode_SK1 ||
      key_code == KeyCode_SK2)
  {
    if (key_code == KeyCode_SK1)
    {
      dprintf (("", " = sk1\n"));
      ret = 1;
    }
    else
    {
      dprintf (("", " = sk2\n"));
      ret = 2;
    }

    /* Call the return function, with the number of the key pressed */
    (*decide_fun_point)(DecideAction_Finished, ret);
    decide_start = 0;
  }
  else
    dprintf (("", "\n"));
}

/* Handles key presses that occur in the confirm window */
int ui_confirmwindow_keypress_handler (int event_code, WimpPollBlock *event,
                                       IdBlock *id_block, void *handle)
{
  IGNORE (event_code); IGNORE (event); IGNORE (id_block); IGNORE (handle);

  ui_confirmwindow_keypressed ();
  return 1;
}

/* Handles key presses that occur in the decide window */
int ui_decidewindow_keypress_handler (int event_code, WimpPollBlock *event,
                                      IdBlock *id_block, void *handle)
{
  IGNORE (event_code); IGNORE (id_block); IGNORE (handle);

  ui_decidewindow_keypressed (event->key_pressed.key_code);
  return 1;
}


/************************************************************************/
/* ui_close_display                                                     */
/*                                                                      */
/* Function closes the Title, Feed, Soft, & Main Windows.  It also      */
/* closes the current Editable Area window.                             */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_close_display (void)
{
#if DAYTONA
  _kernel_oserror *er = NULL;

  /* If the display's already closed, just return */
  if (ui_currently_open_win == NULL)
    return NULL;

  /* Close Editable Area window */
  er = toolbox_hide_object (0, ui_currently_open_win);
  if (er)
    return er;

  ui_currently_open_win = NULL;

  /* Close screen framework */
  er = toolbox_hide_object (0, Feed_WindowHandle);
  if (er)
    return er;

  er = toolbox_hide_object (0, Soft_WindowHandle);
  if (er)
    return er;

  er = toolbox_hide_object (0, Title_WindowHandle);
  if (er)
    return er;

  er = toolbox_hide_object (0, Main_WindowHandle);

  return er;
#else
  return NULL;
#endif
}

/************************************************************************/
/* ui_open_window                                                       */
/*                                                                      */
/* Function opens the window which can contain anything to do with the  */
/* project.  This should only be done after the ui_initialise_display() */
/* function has been called.  It also closes the last open window.      */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Softkey window required.             */
/*                          1   Y  Narrow Softkey window required.      */
/*                          1   N  Wide Softkey window required.        */
/*                          2   Y  Start with SK1 faded.                */
/*                          3   Y  Start with SK2 faded.                */
/*                          4   Y  Start with SK3 faded.                */
/*                          5   Y  Start with SK4 faded.                */
/*                          6   Y  Force vertical scrollbar ON.         */
/*                          7   Y  Force vertical scrollbar OFF.        */
/*             open_win  - Window to open.                              */
/*             title     - Window Title.                                */
/*             sk_1      - Soft Key 1 (top).                            */
/*             sk_2      - Soft Key 2.                                  */
/*             sk_3      - Soft Key 3.                                  */
/*             sk_4      - Soft Key 4 (bottom).                         */
/*             gadget_to_highlight - Either a gadget ID to highlight,   */
/*                                   or -1 to highlight the first       */
/*                                   clickable gadget.                  */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_open_window (unsigned int flags, ObjectId open_win, char *title,
                                 char *sk_1, char *sk_2, char *sk_3, char *sk_4,
                                 ComponentId gadget_to_highlight)
{
#if DAYTONA
  _kernel_oserror *er = NULL;
  int wimp_handle;
  int buff[10];
  int icon_number;

  IconHigh_Stop ();

  if (ui_currently_open_win == NULL)
  {
    /* Open Main (Background) Window */
    er = open_main_window ();
    if (er)
      return er;

    /* nest_window: flags, win_name,      xpos, (-)ypos, xsize, (-)ysize */
    er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Feed_WindowHandle, feed_open_x, feed_open_y,
                      feed_size_x, feed_size_y);
    if (er)
      return er;
  }
  else
  {
    /* Hide currently open window */
    er = toolbox_hide_object (0, ui_currently_open_win);
    if (er)
      return er;
  }

  /* Reset the softkeys to all unfaded */
  er = ui_fade_softkeys (Fade_SK1 | Fade_SK2| Fade_SK3 | Fade_SK4, FALSE);
  if (er)
    return er;

  /* Then take the bits in the flags words in order to fade the requested soft keys */
  er = ui_fade_softkeys ((flags & (Open_SK1_Faded | Open_SK2_Faded | Open_SK3_Faded | Open_SK4_Faded))
                          >> 2, TRUE);
  if (er)
    return er;

  /* Prod clock to display (in case of a timelag due to polling every 3 seconds) */
  er = ui_update_clock_display ();
  if (er)
    return er;

  if (flags & Open_SK_Required)
  {
    /* Soft Key Window Required */
    if (flags & Open_SK_Narrow)
    {
      /* NARROW SoftKey window required. */
      er = nest_window (flags, open_win, edit_open_b_x, edit_open_b_y, edit_size_b_x, edit_size_b_y);
      if (er)
        return er;
    }
    else
    {
      /* WIDE Softkey window */
      er = nest_window (flags, open_win, edit_open_s_x, edit_open_s_y, edit_size_s_x, edit_size_s_y);
      if (er)
        return er;
    }
    /* Setup Window Legends */
    er = ui_window_softkeys (sk_1, sk_2, sk_3, sk_4);
    if (er)
      return er;
  }
  else
  {
    /* No softkey window, so we open Editable Full Size */
    er = nest_window (flags, open_win, edit_open_f_x, edit_open_f_y, edit_size_f_x, edit_size_f_y);
    if (er)
      return er;
  }

  if (title != NULL)
  {
    er = ui_window_title (title);
    if (er)
      return er;
  }

  ui_currently_open_win = open_win;

  er = resize_windows (flags);
  if (er)
    return er;

#if 1
  /* Set the caret into the edittable window */
  er = window_get_wimp_handle (0, open_win, &wimp_handle);
  if (er)
    dprintf (("", ">>UI<< ui_open_window. Error calling window_get_wimp_handle = \"%s\"\n",
             er->errmess));

  er = wimp_set_caret_position (wimp_handle, -1, 0, 0, (1 << 25), 0);
  if (er)
    dprintf (("", ">>UI<< ui_open_window. Error calling wimp_set_caret_position = \"%s\"\n",
             er->errmess));
#endif

  /* If we've been asked to highlight a gadget, get the wimp icon number */
  if (gadget_to_highlight != -1)
  {
    gadget_get_icon_list (0, open_win, gadget_to_highlight, buff, sizeof (buff),
                          NULL);
    icon_number = buff[0];
  }
  else
    icon_number = -1;

  _swix (IconHigh_Start, _INR(0, 2), 8, wimp_handle, icon_number);

  return er;
#else
  return NULL;
#endif
}

/************************************************************************/
/* ui_window_softkeys                                                   */
/*                                                                      */
/* Function changes the SoftKey legends on the Daytona                  */
/* screen display.  This is for use whenever differnet windows are      */
/* opened after the initial one. The function is expecting MessageTrans */
/* tags as parameters.                                                  */
/*                                                                      */
/* Parameters: sk_1      - Soft Key 1 (top)                             */
/*             sk_2      - Soft Key 2                                   */
/*             sk_3      - Soft Key 3                                   */
/*             sk_4      - Soft Key 4 (bottom)                          */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_window_softkeys (char *sk_1, char *sk_2, char *sk_3, char *sk_4)
{
#if DAYTONA
  _kernel_oserror	*er = NULL;

  /* Setup Softkey legends

   * Soft Key 1 */
  er = button_set_value (0, Soft_WindowHandle, softkey_1_label,
                         lookup_message_token (&message_block, sk_1));
  if (er)
    return er;

  /* Soft Key 2 */
  er = button_set_value (0, Soft_WindowHandle, softkey_2_label,
                         lookup_message_token (&message_block, sk_2));
  if (er)
    return er;

  /* Soft Key 3 */
  er = button_set_value (0, Soft_WindowHandle, softkey_3_label,
                         lookup_message_token (&message_block, sk_3));
  if (er)
    return er;

  /* Soft Key 4 */
  er = button_set_value (0, Soft_WindowHandle, softkey_4_label,
                         lookup_message_token (&message_block, sk_4));

  return er;
#else
  return NULL;
#endif
}


/************************************************************************/
/* ui_fade_softkeys                                                     */
/*                                                                      */
/* Function changes the SoftKey legends on the Daytona                  */
/* screen display.  This is for use whenever differnet windows are      */
/* opened after the initial one. The function is expecting MessageTrans */
/* tags as parameters.                                                  */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Softkey 1.                           */
/*                          1   Y  Softkey 2.                           */
/*                          2   Y  Softkey 3.                           */
/*                          3   Y  Softkey 4.                           */
/* Parameters: flags     - Flags.                                       */
/*             faded     - TRUE or FALSE.                               */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_fade_softkeys (int flags, int faded)
{
#if DAYTONA
  _kernel_oserror *er = NULL;

  if (flags & Fade_SK1)
  {
    er = ui_fade_gadget (Soft_WindowHandle, softkey_1_label, faded);
    if (er)
      return er;
  }

  if (flags & Fade_SK2)
  {
    er = ui_fade_gadget (Soft_WindowHandle, softkey_2_label, faded);
    if (er)
      return er;
  }

  if (flags & Fade_SK3)
  {
    er = ui_fade_gadget (Soft_WindowHandle, softkey_3_label, faded);
    if (er)
      return er;
  }

  if (flags & Fade_SK4)
  {
    er = ui_fade_gadget (Soft_WindowHandle, softkey_4_label, faded);
    if (er)
      return er;
  }

  return er;
#else
  return NULL;
#endif
}

static _kernel_oserror *ui_fade_gadget (ObjectId obj_id, ComponentId comp_id, int faded)
{
#if DAYTONA
  unsigned int gadget_flags;
  _kernel_oserror *er = NULL;

  er = gadget_get_flags (0, obj_id, comp_id, &gadget_flags);
  if (er)
    return er;

  if (faded == TRUE)
    gadget_flags |= Gadget_Faded;
  else
    gadget_flags &= !(Gadget_Faded);

  er = gadget_set_flags (0, obj_id, comp_id, gadget_flags);
  return er;
#else
  return NULL;
#endif
}

/************************************************************************/
/* ui_window_title                                                      */
/*                                                                      */
/* Function changes the Title on the Daytona Screen Display.  The       */
/* function is expecting MessageTrans tags as parameters.               */
/*                                                                      */
/* Parameters: title     - Window Title                                 */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_window_title (char *title)
{
#if DAYTONA

  _kernel_oserror	*er = NULL;

  /* Setup title ledgend */
  er = button_set_value (0, Title_WindowHandle, title_label,
                         lookup_message_token (&message_block, title));

  return er;
#else
  return NULL;
#endif
}


/*************************************************************************/
/* ui_decide_window                                                      */
/*                                                                       */
/* Function will display a window with narrow softkeys, basically for    */
/* allowing the user to answer questions.  The sprite is fixed to        */
/* question.bmp, and up to 5 lines of text is possible (Messages tags).  */
/*                                                                       */
/* Parameters: title           - Window title                            */
/*             sk_1            - Soft Key 1 (top)                        */
/*             sk_2            - Soft Key 2                              */
/*             tag             - Text pointer.                           */
/*             param_1         - Parameter substitution string 1.        */
/*             param_2         - Parameter substitution string 2.        */
/*             sprite          - Spritename of sprite to use in window.  */
/*             fun_point       - Pointer to function to call when decide */
/*                               window is finished.                     */
/*             timeout_default - Default action to take on timeout       */
/*                                                                       */
/* Returns:    _kernel_oserror                                           */
/*                                                                       */
/*************************************************************************/
_kernel_oserror *ui_decide_window (char *title, char *sk_1, char *sk_2,
                                   char *tag, char *param_1, char *param_2, char *sprite,
                                   void (*fun_point)(int, int), int timeout_default)
{
#if DAYTONA
  _kernel_oserror	*er = NULL;
  char			*text = NULL;
  int nbytes, ret;

  /* Store the function ppinter to call when finished */
  decide_fun_point = fun_point;
  /* Store when the window was opened, for timeout */
  decide_start = clock ();
  /* Store the timeout default action */
  decide_timeout_default = timeout_default;

  dprintf (("", ">>UI<< ui_decide_window called. fun_point = %p, timeout = %d\n", decide_fun_point,
            decide_timeout_default));


  /* Set the sprite */
  er = button_set_value (0, Decide_WindowHandle, decide_sprite, sprite);
  if (er)
    return er;

  /* Setup text */
  ret = lookup_message_token_params (&message_block, tag, param_1, param_2, "", "", NULL,
                                      0, &nbytes);
  text = malloc (nbytes);

  ret = lookup_message_token_params (&message_block, tag, param_1, param_2, "", "", text,
                                      nbytes, &nbytes);

  /* Set the text */
  er = textarea_set_text (0, Decide_WindowHandle, decide_textarea, text);
  if (er)
  {
    if (text)
      free (text);
    return er;
  }

  /* Open window */
  er = ui_open_window (3, Decide_WindowHandle, title, sk_1, sk_2, NULL, NULL, -1);

  /* Free up pointer memory */
  if (text)
    free(text);

  return er;
#else
  return NULL;
#endif
}


/************************************************************************/
/* ui_confirm_window                                                    */
/*                                                                      */
/* Function will display a window with no softkeys, which is for popping*/
/* up a notification to the user.  It will disappear after a specified  */
/* number of seconds.                                                   */
/*                                                                      */
/* Parameters: title     - Window title                                 */
/*             tag       - Tag pointer to text to place in textarea.    */
/*             param_1   - Parameter substitution string 1.             */
/*             param_2   - Parameter substitution string 2.             */
/*             sprite    - Spritename of sprite to use in window.       */
/*             fun_point - Pointer to function to call when confirm     */
/*                         window is finished.                          */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_confirm_window (char *title, char *tag, char *param_1, char* param_2,
                                    char *sprite, void (*fun_point)(int))
{
#if DAYTONA
  int nbytes, ret;
  _kernel_oserror	*er = NULL;
  char			*text = NULL;

  /* Store the function ppinter to call when finished */
  confirm_fun_point = fun_point;
  /* Store when the window was opened, for timeout */
  confirm_start = clock();

  dprintf (("", ">>UI<< ui_confirm_window called. fun_point = %p\n", confirm_fun_point));

  /* Set the sprite */
  er = button_set_value (0, Confirm_WindowHandle, confirm_sprite, sprite);
  if (er)
    return er;

  /* Setup text */
  ret = lookup_message_token_params (&message_block, tag, param_1, param_2, "", "", NULL,
                                     0, &nbytes);

  text = malloc (nbytes);

  ret = lookup_message_token_params (&message_block, tag, param_1, param_2, "", "", text,
                                     nbytes, &nbytes);

  /* Set the text */
  er = textarea_set_text (0, Confirm_WindowHandle, confirm_textarea, text);
  if (er)
  {
    if (text)
      free (text);
    return er;
  }

  /* Open window */
  er = ui_open_window (0, Confirm_WindowHandle, title, "", "", "", "", -1);

  /* Free up pointer memory */
  if (text)
    free (text);

  return er;
#else
  return NULL;
#endif
}


#define Alignment_NewFlagsGiven            (1u<<0)

/************************************************************************/
/* nest_window                                                          */
/*                                                                      */
/* Function will nest the passed window within Main_WindowHandle.       */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Softkey window required.             */
/*                          1   Y  Narrow Softkey window required.      */
/*                          1   N  Wide Softkey window required.        */
/*             win       - Window ObjectId.                             */
/*             x         - x start coordinate.                          */
/*             y         - y start coordinate (NEGATIVE).               */
/*             x_size    - horizontal viewable size of window.          */
/*             y_size    - vertical viewable size of window (NEGATIVE). */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static _kernel_oserror *nest_window (unsigned int flags, ObjectId win, int x, int y, int x_size,
                                     int y_size)
{
#if DAYTONA
  _kernel_oserror *er = NULL;
  WindowShowObjectBlock show;
  WimpGetWindowStateBlock parent_state, child_state;

  /* Get wimp handle of main_win */
  er = window_get_wimp_handle (0, Main_WindowHandle, &parent_state.window_handle);
  if (er)
    return er;

  /* Get wimp handle of the child window */
  er = window_get_wimp_handle (0, Main_WindowHandle, &child_state.window_handle);
  if (er)
    return er;

  /* Get the window state of main_win */
  er = wimp_get_window_state (&parent_state);
  if (er)
    return er;

  /* Get the window state of the child window */
  er = wimp_get_window_state (&child_state);
  if (er)
    return er;

  /* Setup display sizes */
  show.visible_area.xmin = x + parent_state.visible_area.xmin - parent_state.xscroll;
  show.visible_area.xmax = x + x_size + parent_state.visible_area.xmin - parent_state.xscroll;

  show.visible_area.ymin = y + y_size + parent_state.visible_area.ymax - parent_state.yscroll;
  show.visible_area.ymax = y + parent_state.visible_area.ymax - parent_state.yscroll;

  show.yscroll = child_state.yscroll;
  show.behind  = child_state.behind;

  /*
  show.yscroll = 0;
  show.behind = -1;
  */

  show.window_flags = child_state.flags;

  if (flags & Open_VScroll_On)
  {
    dprintf (("", "vscroll on, win = %x soft = %x\n", win, Soft_WindowHandle));
    show.window_flags |= WimpWindow_VScroll;
  }
  else if (flags & Open_VScroll_Off)
  {
    dprintf (("", "vscroll off, win = %x soft = %x\n", win, Soft_WindowHandle));
    show.window_flags &= ~WimpWindow_VScroll;
  }

  if ((flags & Open_VScroll_On) | (flags & Open_VScroll_Off))
    show.alignment_flags = Alignment_NewFlagsGiven; /* what's this!!!? */

  show.parent_window_handle = parent_state.window_handle;

  /* Don't know what this bit does exactly */
  if ((win == Soft_WindowHandle) && (flags & Open_SK_Narrow))
  {
    /* NARROW Softkey window required */
    show.xscroll = softkey_window_offset;
  }
  else
  {
    /* Any other window */
    show.xscroll = 0;
  }

  er = toolbox_show_object (Toolbox_ShowObject_AsSubWindow, win,
                            Toolbox_ShowObject_FullSpec, &show, Main_WindowHandle, -1);
  return er;
#endif
  return NULL;
}


/************************************************************************/
/* resize_title                                                         */
/*                                                                      */
/* Function is called when the program has to change from a wide or     */
/* narrow softkey window.  It resizes the title button.                 */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Softkey window.                      */
/*                          1   Y  Narrow Softkey window.               */
/*                          1   N  Wide Softkey window.                 */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static _kernel_oserror *resize_title(unsigned int flags)
{
#if DAYTONA
  _kernel_oserror	*er = NULL;
  BBox			size;

  /* Get current co-ordinates & size of softkey button */
  er = gadget_get_bbox (0, Title_WindowHandle, title_label, &size);
  if (er)
    return er;

  if (flags & Open_SK_Required)
  {
    /* There is a soft key window, so resize */
    if (flags & Open_SK_Narrow)
    {
      /* It's narrow */
      size.xmax = size.xmin + confirm_title_size;

      /* Set new values. */
      er = gadget_move_gadget (0, Title_WindowHandle, title_label, &size);
      if (er)
        return er;
    }
    else
    {
      /* It's wide */
      size.xmax = size.xmin + menu_title_size;

      /* Set new values. */
      er = gadget_move_gadget (0, Title_WindowHandle, title_label, &size);
      if (er)
        return er;
    }
  }
  else
  {
    /* No softkeys , so make it full screen */
    size.xmax = size.xmin + full_title_size;

    /* Set new values. */
    er = gadget_move_gadget (0, Title_WindowHandle, title_label, &size);
  }
  return er;
#endif
  return NULL;
}


/************************************************************************/
/* resize_windows                                                       */
/*                                                                      */
/* Function is called to resize the Title and Softkey windows as part   */
/* of the ui_open_window() function.                                    */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Softkey window required.             */
/*                          1   Y  Narrow Softkey window required.      */
/*                          1   N  Wide Softkey window required.        */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static _kernel_oserror *resize_windows (unsigned int flags)
{
#if DAYTONA
  _kernel_oserror *er = NULL;

  /* Check to see if bit is set */
  if (flags & Open_SK_Required)
  {
    /* Soft Key Window required */
    if (flags & Open_SK_Narrow)
    {
      /* NARROW SOFTKEY SCREEN */
      er = resize_title (flags);
      if (er)
        return er;

      er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Title_WindowHandle,
                        title_open_w_x, title_open_w_y, title_size_w_x, title_size_w_y);
      if (er)
        return er;
      er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Soft_WindowHandle,
                        soft_open_n_x, soft_open_n_y, soft_size_n_x, soft_size_n_y);
      if (er)
        return er;
    }
    else
    {
      /* LARGE SOFTKEY SCREEN */
      er = resize_title (flags);
      if (er)
        return er;

      /* nest_window: flags, win_name, xpos, (-)ypos, xsize, (-)ysize */
      er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Title_WindowHandle,
                        title_open_n_x, title_open_n_y, title_size_n_x, title_size_n_y);
      if (er)
        return er;
      er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Soft_WindowHandle,
                        soft_open_w_x, soft_open_w_y, soft_size_w_x, soft_size_w_y);
      if (er)
        return er;
    }
  }
  else
  {
    er = resize_title (flags);
    if (er)
      return er;
    er = nest_window (flags & ~Open_VScroll_On & ~Open_VScroll_Off, Title_WindowHandle,
                      title_open_f_x, title_open_f_y, title_size_f_x, title_size_f_y);
    if (er)
      return er;

    er = toolbox_hide_object (0, Soft_WindowHandle);
    if (er)
      return er;
  }
  return er;
#endif
  return NULL;
}


/************************************************************************/
/* ui_update_clock_display                                              */
/*                                                                      */
/* Function is called to update the clock display in the Feedback win.  */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_update_clock_display (void)
{

#if DAYTONA

  _kernel_oserror	*er = NULL;
  struct tm 		*time_struct;
  time_t		 current_time;
  char			 time_display[7];

  /* Get Current Time */
  time (&current_time);
  time_struct = localtime (&current_time);

  /* Build Textual string */
  sprintf (time_display, "%d:%02d", time_struct->tm_hour, time_struct->tm_min);

  /* Output string */
  er = button_set_value (0, Feed_WindowHandle, feed_clock_display, time_display);

  return er;
#else
  return NULL;
#endif
}


/************************************************************************/
/* ui_home_set_status                                                   */
/*                                                                      */
/* Function will set line 1 or 2 of the status fields in the home window*/
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Set upper line.                      */
/*                          1   Y  Set lower line.                      */
/*             tag       - Tag pointer to text to put in status line.   */
/*                         2 parameters, %0 and %1 are allowed          */
/*             param_1   - Parameter substitution string 1.             */
/*             param_2   - Parameter substitution string 2.             */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_home_set_status (int flags, char *tag, char *param_1, char *param_2)
{
#if DAYTONA

  _kernel_oserror *er = NULL;
  ComponentId which_line;
  char *txt = NULL;
  int ret, nbytes;

  if (flags & HomeStatus_Upper)
    which_line = home_status_1;

  else
    which_line = home_status_2;

  /* Set button text */
  ret = lookup_message_token_params (&message_block, tag, param_1, param_2,
                                     "", "", NULL, 0, &nbytes);

  if (ret == 0)
  {
    er = button_set_value (0, Home_WindowHandle, which_line, "");
  }
  else
  {
    txt = malloc (nbytes);

    ret = lookup_message_token_params (&message_block, tag, param_1, param_2,
                                       "", "", txt, nbytes, &nbytes);

    er = button_set_value (0, Home_WindowHandle, which_line, txt);

    if (txt)
      free (txt);
  }

  return er;
#else
  char *txt;
  int ret, nbytes;

  ret = lookup_message_token_params (&message_block, tag, param_1, param_2,
                                     "", "", NULL, 0, &nbytes);

  if (ret == 1)
  {
    txt = malloc (nbytes);

    ret = lookup_message_token_params (&message_block, tag, param_1, param_2,
                                       "", "", txt, nbytes, &nbytes);

    printf("%s\n", txt);

    if (txt)
      free (txt);
  }

  return NULL;
#endif
}


/************************************************************************/
/* ui_home_set_sprite                                                   */
/*                                                                      */
/* Function sets a sprite into a specified Button.                      */
/*                                                                      */
/* Parameters: flags     - Bit Set Meaning                              */
/*                          0   Y  Left side button.                    */
/*                          1   Y  Centre button.                       */
/*                          2   Y  Right side button.                   */
/* Parameters: flag     - Which animation box to setup.                 */
/*             sprite   - Spritename to put in box                      */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_home_set_sprite (int flags, char *sprite)
{
#if DAYTONA

  _kernel_oserror	*er = NULL;
  ComponentId		which_button;

  if (flags & HomeSprite_Left)
    which_button = home_left_sprite;

  else if (flags & HomeSprite_Centre)
    which_button = home_centre_sprite;

  else
    which_button = home_right_sprite;

  /* Set sprite */
  er = button_set_value (0, Home_WindowHandle, which_button, sprite);

  return er;
#else
  return NULL;
#endif
}


/************************************************************************/
/* ui_optionfield_update                                                */
/*                                                                      */
/* Function will change the value in the option field depending on which*/
/* arrow key was pressed.                                               */
/*                                                                      */
/* Parameters: updown - Should be UP | DOWN.                            */
/*             tag    - Tag prefix for optionfield, e.g. "OptField_"    */
/*             win    - Window which optionfield resides in             */
/*             comp   - Component which holds optionfield text          */
/*             flags  - Bit Set Meaning                                 */
/*                       0   Y  Wrap optionfield at start and beginning */
/*                       0   N  No wrapping                             */
/*                       1   Y  Field is numerical                      */
/*                       1   N  Field is a set of tags.                 */
/*                       2   Y  Numerical format of field is "%02d"     */
/*                                                                      */
/* Returns:    _kernel_oserror                                          */
/*                                                                      */
/************************************************************************/
_kernel_oserror *ui_optionfield_update (int updown, char *tag, ObjectId win, ComponentId comp,
                                        unsigned int flags)
{
#if DAYTONA

  _kernel_oserror	*er = NULL;
  int			 last_item, new_item, lookup, first_item;
  char			 command[40];
  char wrap;

  wrap = (flags & Optionfield_Wrap);

  if (flags & Optionfield_Numerical)
  {
    sprintf (command, "%sFirst", tag);
    first_item = atoi (lookup_message_token (&message_block, command));
  }
  else
    first_item = 0;

  sprintf (command, "%sLast", tag);
  last_item = atoi (lookup_message_token (&message_block, command));

  /*
   * If lookup fails we want default values for the item to
   * display, correctly set for UP & DOWN situations
   */
  if (updown == UP)
  {
    new_item = last_item;
  }
  else
  {
    new_item = first_item;
  }

  lookup = ui_optionfield_lookup (tag, win, comp, flags);
  if (lookup != -1)
  {
    switch (updown)
    {
      case DOWN:
        if (lookup != first_item)
          new_item = lookup - 1;
        else if ((lookup == first_item) && wrap)
          new_item = last_item;
        break;

      case UP:
        if (lookup != last_item)
          new_item = lookup + 1;
        else if ((lookup == last_item) && wrap)
          new_item = first_item;
        break;
    }
  }

  if (flags & Optionfield_Numerical)
  {
    if (flags & Optionfield_Numerical_FormatExpand)
      sprintf (command, "%02d", new_item);
    else
      sprintf (command, "%d", new_item);
    er = button_set_value(0, win, comp, command);
  }
  else
  {
    /* Set the button value */
    sprintf (command, "%s%d", tag, new_item);
    er = button_set_value (0, win, comp, lookup_message_token (&message_block, command));
  }

  return er;
#else
  return NULL;
#endif
}

/************************************************************************/
/* ui_optionfield_lookup                                                */
/*                                                                      */
/* Function will change the value in the option field depending on which*/
/* arrow key was pressed.                                               */
/*                                                                      */
/* Parameters: tag    - Tag prefix for optionfield, e.g. "OptField_"    */
/*             win    - Window which optionfield resides in             */
/*             comp   - Component which holds optionfield text          */
/*             flags  - Bit Set Meaning                                 */
/*                       1   Y  Field is numerical                      */
/*                       1   N  Field is a set of tags.                 */
/*                                                                      */
/* Returns:    Token number of option in optionfield                    */
/*                                                                      */
/************************************************************************/
int ui_optionfield_lookup (char *tag, ObjectId win, ComponentId comp, unsigned int flags)
{
#if DAYTONA
  int last_item, counter;
  char command[40];
  char buffer[30];

  /* Get value of button in window */
  button_get_value (0, win, comp, buffer, sizeof(buffer), NULL);

  if (flags & Optionfield_Numerical)
    return atoi (buffer);

  /* Build command to contain tag plus Last */
  sprintf (command, "%sLast", tag);

  last_item = atoi (lookup_message_token (&message_block, command));

  for (counter = 0; counter <= last_item; counter++)
  {
    /* Is string in button equal to Tag + counter? */
    sprintf (command, "%s%d", tag, counter);

    if (strcmp (buffer, lookup_message_token (&message_block, command)) == 0)
    {
      return counter;
    }
  }
#endif
  return -1;
}

/************************************************************************/
/* open_main                                                            */
/*                                                                      */
/* Function opens the main (background) window for the Daytona UI.      */
/*                                                                      */
/* Parameters: void.                                                    */
/*                                                                      */
/* Returns:    void.                                                    */
/*                                                                      */
/************************************************************************/
static _kernel_oserror *open_main_window (void)
{
#if DAYTONA
  _kernel_oserror	*er = NULL;
  WindowShowObjectBlock	 show;

  /* Setup display sizes */
  show.visible_area.xmin = 0; /*main_open_x + ;*/
  show.visible_area.xmax = main_open_x + main_size_x;

  show.visible_area.ymin = 0;
  show.visible_area.ymax = main_size_y; /* - main_open_y;*/

  show.xscroll = 0;
  show.yscroll = 0;
  show.behind = -1;
  show.window_flags = 0;
  show.alignment_flags = 0;
  show.parent_window_handle = 0;

  er = toolbox_show_object (0, Main_WindowHandle,
                            Toolbox_ShowObject_FullSpec, &show, 0, 0);
  return er;
#else
  return NULL;
#endif
}
