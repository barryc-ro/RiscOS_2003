Generic Message and Error Handling Routines [msgs.h]
----------------------------------------------------

Timothy Roddis 7/11/95

Historical Interest
-------------------

These routines are largely derived from those written by me (Timothy Roddis)
for the Aquarius (Acorn C/C++ with toolbox) project.

Opening and Closing the file
----------------------------

There are actually two ways of opening a file supported by this object
module.


   _kernel_oserror *msgs_open_file (char *pathname)

opens the file for the programmer and keeps a record of the message file
handle for future use.


   void msgs_set_file_descriptor (MsgsFD *messages_fd)

remembers the given message file descriptor for future use.


   _kernel_oserror *msgs_close_file ()

closes the file (regardless of how it was opened).

Looking up a message
--------------------

   char *msgs_lookup(char *token)

looks up the given token in the message file. If the token is present, its
translation is copied to an internal static buffer whose address is returned
as result. If the token is not found (or some other error occurs), the
address of the token itself is passed back as result.

Example:

    char *token = "TaskName";
    char *taskname = msgs_lookup (token);

    if (taskname == token)
        taskname = "Unknown task";

Error Generation
----------------

   void msgs_set_error_base (int error_base)

sets the error base number for future use. The default is nought.


   _kernel_oserror *msgs_make_error (int error_num, ...)

returns a pointer to a single, static error block. Only one error can be
generated by msgs_make_error and held at any one time because of this
constraint. The error_num parameter is used to get the correct message and to
determine the error number used in the error block as follows:-

In the messages file there should be a line

Enn:<error message>

where nn is a hexadecimal number representing the error_num parameter
modulus 256; note that hexadecimal digits greater than 9 should be
represented by lower case letters (eg Ea3).

The error number will be the error base added to the error_num argument.

The <error message> is interpreted as a 'printf-like' format string, and any
further arguments will be substituted.

Example:

   E34:There are %d %s open

   num_files_open = 10;
   e = msgs_make_error (0x34, num_files_open, "files");

will generate error number <error_base> + &34 with text:

            "There are 10 files open"

Program errors
--------------

The constant PROG_ERR is defined to contain the bits needed to turn a normal
error number into a "program error" as, eg:

    e = msgs_make_error (ERR_BADDRIVE | PROG_ERR, drive_num);

Error display
-------------

   void msgs_display_error (_kernel_oserror *err)

displays the text of the supplied error in a Wimp error box. The title of
the box will be "Error from <taskname>" where <taskname> is the translated
value of the token "TaskName".
