/*
 * disass.c - single instruction disassembler
 * Copyright (C) Advanced RISC Machines Ltd., 1991.
 */

/*
 * RCS $Revision$
 * Checkin $Date$
 * Revising $Author$
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "disass.h"

#ifndef __STDC__
typedef char *VoidStar;
#endif

typedef int bool;
#define YES 1
#define NO 0

/* ---------------- Output Functions --------------------- */

#define outc(h,o) (*o++ = h)
#define outf(o,f,s) (sprintf(o,f,s), (o + strlen(o)))
#define outi(n,o)   outf(o,"#%ld",n)
#define outx(n,o)   (sprintf(o,"%s%lx",hexprefix,n), (o+strlen(o)))

/* ---------------- Bit twiddlers ------------------------ */

/* The casts to unsigned32 in bit() and bits() are redundant, but required by
   some buggy compilers.
 */
#define bp(n) (((unsigned32)1L<<(n)))
#define bit(n) (((unsigned32)(instr & bp(n)))>>(n))
#define bits(m,n) (((unsigned32)(instr & (bp(n)-bp(m)+bp(n))))>>(m))
#define ror(n,b) (((n)>>(b))|((n)<<(32-(b)))) /* n right rotated b bits */

/* ---------------- Local variables ---------------------- */

static char **regnames, **fregnames;
static dis_cb *cb_proc;
static void *cb_arg;
static char *hexprefix = "0x";

static char *outs(const char *s, char *o) {
 /* All strings are very short: no point to any cleverness which a library
    strcpy might give us.
  */
    char ch;
    for (; (ch = *s++) != 0;)
      outc(ch, o);
    return o;
}

static char *cond(unsigned32 instr, char *o) {
    const char *ccnames = "EQ\0\0NE\0\0CS\0\0CC\0\0MI\0\0PL\0\0VS\0\0VC\0\0\
HI\0\0LS\0\0GE\0\0LT\0\0GT\0\0LE\0\0\0\0\0\0NV";
    return outs(ccnames+4*(int)bits(28,31), o);
}

static char *reg(unsigned32 rno, int ch, char *o) {
    if (regnames == 0)
       if (rno == 15)
          o = outs("pc", o);
       else
          o = outf(o, "r%ld", rno);
    else
       o = outs(regnames[rno], o);
    if (ch != 0)
       outc(ch, o);
    return o;
}

static char *freg(unsigned32 rno, int ch, char *o) {
    if (fregnames == 0)
       o = outf(o, "f%ld", rno);
    else
       o = outs(fregnames[rno], o);
    if (ch != 0)
       outc(ch, o);
    return o;
}

static char *shiftedreg(unsigned32 instr, char *o) {
    char *shiftname = "LSL\0LSR\0ASR\0ROR" + 4*(int)bits(5,6);
    o = reg(bits(0,3), 0, o); /* offset is a (shifted) reg */
    if (bit(4)) { /* register shift */
       o = outf(o, ",%s ", shiftname);
       o = reg(bits(8,11), 0, o);
    }
    else if (bits(5,11)!=0) { /* immediate shift */
       if (bits(5,11)==3)
          o = outs(",RRX", o);
       else {
          o = outf(o, ",%s ", shiftname);
          if (bits(5,11)==1 || bits(5,11)==2)
             o = outi(32L, o);
          else
             o = outi(bits(7,11), o);
       }
    }
    return o;
}

static char *outh(unsigned32 n, unsigned32 pos, char *o) {
    outc('#', o);
    if (!pos) outc('-', o);
    if (n < 10)
        o = outf(o, "%ld", n);
    else
        o = outx(n, o);
    return o;
}

static char *spacetocol9(char *start, char *o) {
    int k = 9 - (o - start);
    for (; k > 0; k--) outc(' ', o);
    return o;
}

static char *opcode(unsigned32 instr, const char *op, char ch, char *o) {
    char *start = o;
    o = outs(op, o);
    o = cond(instr, o);
    if (ch != 0) outc(ch, o);
    return spacetocol9(start, o);
}

static char *outaddress(unsigned32 instr, unsigned32 address, int32 offset, int w, char *o) {
    char *oldo = o;
    if (bits(16,19)==15 && bit(24) && !bit(25)) { /* pc based, pre, imm */
       if (!bit(23)) offset = -offset;
       address = address+offset+8;
       o = cb_proc((bit(20) ? D_LOADPCREL : D_STOREPCREL),
                   offset, address, w, cb_arg, o);
       if (oldo == o) o = outx(address, o);
    } else {
       if (bit(24) && !bit(25)) /* pre, imm */
          o = cb_proc((bit(20) ? D_LOAD : D_STORE),
                      (bit(23) ? offset : -offset),
                      bits(16,19), w, cb_arg, o);
       if (oldo == o) {
          outc('[', o);
          o = reg(bits(16,19), (bit(24) ? 0 : ']'), o);
          outc(',', o);
          if (!bit(25)) { /* offset is an immediate */
              o = outh(offset, bit(23), o);
          } else {
             if (!bit(23)) outc('-', o);
             o = shiftedreg(instr, o);
          }
          if (bit(24)) {
             outc(']', o);
             if (bit(21)) outc('!', o);
          }
       }
    }
    return o;
}

static char *outregset(unsigned32 instr, char *o) {
    bool started = NO,
         string = NO;
    unsigned32 i,
               first = 0,
               last = 0;
    outc('{', o);
    for (i=0; i<16; i++) {
       if (bit(i)) {
          if (!started) {
             o = reg(i, 0, o);
             started=YES;
             first=last=i;
          }
          else if (i==last+1) {
             string=YES;
             last=i;
          }
          else {
             if (i>last+1 && string) {
                outc((first == last-1) ? ',' : '-', o);
                o = reg(last, 0, o);
                string=NO;
             }
             outc(',', o); o = reg(i, 0, o);
             first=last=i;
          }
       }
    }
    if (string) {
       outc((first == last-1) ? ',' : '-', o);
       o = reg(last, 0, o);
    }
    outc('}', o);
    return o;
}

static char *generic_cpdo(unsigned32 instr, char *o) {
    o = opcode(instr, "CDP", 0, o);
    o = outf(o, "P%ld,", bits(8,11));
    o = outx(bits(20,23), o); outc(',', o);
    o = outf(o, "C%ld,", bits(12,15));   /* CRd */
    o = outf(o, "C%ld,", bits(16,19));   /* CRn */
    o = outf(o, "C%ld,", bits(0,3));     /* CRm */
    o = outh(bits(5,7),1, o);
    return o;
}

static char *generic_cprt(unsigned32 instr, char *o) {
    o = opcode(instr, (bit(20) ? "MRC" : "MCR"), 0, o);
    o = outf(o, "P%ld,", bits(8,11));
    o = outx(bits(21,23), o); outc(',', o);
    o = reg(bits(12,15), ',', o);
    o = outf(o, "C%ld,",bits(16,19));   /* CRn */
    o = outf(o, "C%ld,",bits(0,3));      /* CRm */
    o = outh(bits(5,7),1, o);
    return o;
}

static char *generic_cpdt(unsigned32 instr, unsigned32 address, char *o) {
    o = opcode(instr, (bit(20) ? "LDC" : "STC"), (bit(22) ? 'L' : 0), o);
    o = outf(o, "P%ld,",bits(8,11));
    o = outf(o, "C%ld,",bits(12,15));
    return outaddress(instr, address, 4*bits(0,7), 0, o);
}

static char fp_dt_widthname(unsigned32 instr) {
    return "SDEP"[bit(15) + 2*bit(22)];
}

static char fp_widthname(unsigned32 instr) {
    return "SDEP"[bit(7) + 2*bit(19)];
}

static char *fp_rounding(unsigned32 instr) {
    return "\0\0P\0M\0Z" + 2*bits(5,6);
}

static char *fp_mfield(unsigned32 instr, char *o) {
   unsigned32 r = bits(0,2);
   if (bit(3)) {
      if (r < 6)
         o = outi(r, o);
      else
         o = outs((r == 6 ? "#0.5" : "#10"), o);
   }
   else
      o = freg(r, 0, o);
   return o;
}

static char *fp_cpdo(unsigned32 instr, bool *oddity, char *o) {
    char *opset;
    char *start = o;
    if (bit(15))  /* unary */
        opset = "\
MVF\0MNF\0ABS\0RND\0SQT\0LOG\0LGN\0EXP\0\
SIN\0COS\0TAN\0ASN\0ACS\0ATN\0URD\0NRM";
     else
        opset = "\
ADF\0MUF\0SUF\0RSF\0DVF\0RDF\0POW\0RPW\0\
RMF\0FML\0FDV\0FRD\0POL\0XX1\0XX2\0XX3";

    o = outs(opset + 4*bits(20,23), o);
    o = cond(instr, o);
    outc(fp_widthname(instr), o);
    o = outs(fp_rounding(instr), o);
    o = spacetocol9(start, o);
    o = freg(bits(12,14), ',', o);  /* Fd */
    if (!bit(15))
        o = freg(bits(16,18), ',', o);  /* Fn */
    else if (bits(16,18) != 0)
    /* odd monadic (Fn != 0) ... */
        *oddity = YES;
    return fp_mfield(instr, o);
}

static char *fp_cprt(unsigned32 instr, char *o) {
    int op = (int)bits(20,23);
    if (bits(12,15)==15)  /* ARM register = pc */ {
       if ((op & 9) != 9)
          op = 4;
       else
          op = (op>>1)-4;
       o = opcode(instr, "CMF\0\0CNF\0\0CMFE\0CNFE\0???" + 5*op, 0, o);
       o = freg(bits(16,18), ',', o);
       return fp_mfield(instr, o);

    } else {
       char *start = o;
       if (op > 7) op = 7;
       o = outs("FLT\0FIX\0WFS\0RFS\0WFC\0RFC\0???\0???" + 4*op, o);
       o = cond(instr, o);
       outc(fp_widthname(instr), o);
       o = outs(fp_rounding(instr), o);
       o = spacetocol9(start, o);
       if (bits(20,23) == 0) /* FLT */ {
         o = freg(bits(16,18), ',', o);
       }
       o = reg(bits(12,15), 0, o);
       if (bits(20,23) == 1) /* FIX */ {
         outc(',', o);
         o = fp_mfield(instr, o);
       }
    }
    return o;
}

static char *fp_cpdt(unsigned32 instr, unsigned32 address, char *o) {
    if (!bit(24) && !bit(21)) {
       /* oddity: post and not writeback */
       return generic_cpdt(instr, address, o);
    } else {
       o = opcode(instr, (bit(20) ? "LDF" : "STF"), fp_dt_widthname(instr), o);
       o = freg(bits(12,14), ',', o);
       return outaddress(instr, address, 4*bits(0,7), 0, o);
    }
}

static char *fm_cpdt(unsigned32 instr, unsigned32 address, char *o) {
    if (!bit(24) && !bit(21))
    {
       /* oddity: post and not writeback */
       return generic_cpdt(instr, address, o);
    }
    o = opcode(instr, (bit(20) ? "LFM" : "SFM"), 0, o);
    o = freg(bits(12,14), ',', o);
    {  int count = (int)(bit(15) + 2*bit(22));
       o = outf(o, "%d,", count==0 ? 4: count);
    }
    o = outaddress(instr, address, 4*bits(0,7), 0, o);
    return o;
}

void disass_setregnames(char **rn, char **fn) {
    regnames = rn; fregnames = fn;
}

void disass_sethexprefix(char *p) {
    hexprefix = p;
}

void disass(unsigned32 instr, unsigned32 address, char *o, void *cba, dis_cb *cbp) {
    disass_32or26(instr, address, o, cba, cbp, 0);
}

void disass_32or26(unsigned32 instr, unsigned32 address, char *o, void *cba, dis_cb *cbp, int mode_32bit) {
    bool oddity = NO;
    cb_proc = cbp; cb_arg = cba;
    switch (bits(24,27)) {

    case 0:
       if (bit(23)==1 && bits(4,7)==9) { /* Long Multiply */
          o=opcode(instr, bit(21) ? (bit(22) ? "SMLAL" : "UMLAL")
                                  : (bit(22) ? "SMULL" : "UMULL"),
                   bit(20) ? 'S' : 0, o);
          o = reg(bits(12,15), ',', o);
          o = reg(bits(16,19), ',', o);
          o = reg(bits(0,3), ',', o);
          o = reg(bits(8,11), 0, o);
          break;
       }
       /* Drop through */
    case 1: case 2: case 3:
       if (bits(22,25)==0 && bits(4,7)==9) { /* multiply */
          o = opcode(instr, (bit(21) ? "MLA" : "MUL"), (bit(20) ? 'S' : 0), o);
          o = reg(bits(16,19), ',', o);
          o = reg(bits(0,3), ',', o);
          o = reg(bits(8,11), 0, o);
          if (bit(21)) { outc(',', o); o = reg(bits(12,15), 0, o);}
       }
       else if (bits(23,25)==2 && bits(20,21)==0 && bits(4,11)==9) {
          /* Swap */
          o = opcode(instr, "SWP", (bit(22) ? 'B' : 0), o);
          o = reg(bits(12,15), ',', o);
          o = reg(bits(0,3), ',', o);
          outc('[', o); o = reg(bits(16,19), ']', o);
       }
       else if (instr == 0xe1a00000L)
          o = opcode(instr, "NOP", 0, o);
       else { /* data processing */
          int op = (int)bits(21,24);
          const char *opnames = "AND\0EOR\0SUB\0RSB\0ADD\0ADC\0SBC\0RSC\0\
TST\0TEQ\0CMP\0CMN\0ORR\0MOV\0BIC\0MVN";
          if (op >= 8 && op < 12 && !bit(20)) {
             if ((op & 1) == 0) {
                o = opcode(instr, "MRS", 0, o);
                o = reg(bits(12,15), ',', o);
                if (op == 8)
                   o = outs("cpsr", o);
                else
                   o = outs("spsr", o);
                oddity = (bits(0, 11) != 0 || bits(16, 19) != 15);
                break;
             } else {
                char *rname = op == 9 ? "cpsr" : "spsr";
                int rn = (int)bits(16, 19);
                char *part = rn == 1 ? "ctl" :
                             rn == 8 ? "flg" :
                             rn == 9 ? "all" :
                                       "?";
                o = opcode(instr, "MSR", 0, o);
                o = outs(rname, o);
                o = outf(o, "_%s,", part);
                oddity = bits(12,15) != 15;
             }
          } else {
             int ch = (!bit(20)) ? 0 :
                (op>=8 && op<12) ? (bits(12,15)==15 ? 'P' : 0) :
                                   'S';
             o = opcode(instr, opnames+4*op, ch, o);
             if (!(op >= 8 && op < 12)) {    /* not TST TEQ CMP CMN */
                /* print the dest reg */
                o = reg(bits(12,15), ',', o);
             }
             if (op!=13 && op!=15) {         /* not MOV MVN */
                o = reg(bits(16,19), ',', o);
             }
          }
          if (bit(25)) {            /* rhs is immediate */
             int shift = 2*(int)bits(8,11);
             int32 operand = ror(bits(0,7), shift);
             char *oldo = o;
             if ((op == 4 || op == 2) && /* ADD or SUB  */
                 bits(16,19) == 15)          /* rn = pc */
                o = cb_proc((op == 4 ? D_ADDPCREL : D_SUBPCREL),
                            operand, address+8, 0, cb_arg, o);

             if (o == oldo) o = outh(operand,1, o);
          }
          else {                   /* rhs is a register */
             o = shiftedreg(instr, o);
          }
       }
       break;

    case 0xa: case 0xb:
       o = opcode(instr, (bit(24) ? "BL" : "B"), 0, o);
       {  int32 offset = (((int32)bits(0,23))<<8)>>6; /* sign extend and * 4 */
          char *oldo = o;
          address += offset + 8;
          if (!mode_32bit) address &= 0x3ffffffL;
          o = cb_proc(D_BORBL, offset, address, 0, cb_arg, o);
          if (o == oldo) o = outx(address, o);
       }
       break;

    case 6: case 7:
       /* Cope with the case where register shift register is specified
        * as this is an undefined instruction rather than an LDR or STR
        */
       if (bit(4)) {
         o=outs("Undefined Instruction",o);
         break;
       }
       /* Drop through to alwasy LDR / STR case */
    case 4: case 5:
       {  char *start = o;
          o = outs(bit(20) ? "LDR" : "STR", o);
          o = cond(instr, o);
          if (bit(22)) outc('B', o);
          if (!bit(24) && bit(21))  /* post, writeback */
             outc('T', o);
          o = spacetocol9(start, o);
          o = reg(bits(12,15), ',', o);
          o = outaddress(instr, address, bits(0,11), (bit(22) ? 1 : 4), o);
          break;
       }

    case 8: case 9:
       {  char *start = o;
          o = outs(bit(20) ? "LDM" : "STM", o);
          o = cond(instr, o);
          o = outs("DA\0\0IA\0\0DB\0\0IB" + 4*(int)bits(23,24), o);
          o = spacetocol9(start, o);
          o = reg(bits(16,19), 0, o);
          if (bit(21)) outc('!', o);
          outc(',', o);
          o = outregset(instr, o);
          if (bit(22)) outc('^', o);
          break;
       }

    case 0xf:
       o = opcode(instr, "SWI", 0, o);
       {  char *oldo = o;
          int32 swino = bits(0,23);
          o = cb_proc(D_SWI, swino, 0, 0, cb_arg, o);
          if (o == oldo) o = outx(swino, o);
       }
       break;

    case 0xe:
       if (bit(4)==0) { /* CP data processing */
           switch(bits(8,11)) {
           case 1:
              o = fp_cpdo(instr, &oddity, o);
              break;
           default:
              o = generic_cpdo(instr, o);
              break;
           }
       } else { /* CP reg to/from ARM reg */
          switch (bits(8,11)) {
          case 1:
             o = fp_cprt(instr, o);
             break;
          default:
             o = generic_cprt(instr, o);
             break;
          }
       }
       break;

    case 0xc: case 0xd:
       switch (bits(8,11)) {
       case 1:
          o = fp_cpdt(instr, address, o);
          break;
       case 2:
          o = fm_cpdt(instr, address, o);
          break;
       default:
          o = generic_cpdt(instr, address, o);
          break;
       }
       break;

    default:
       o = outs("EQUD    ", o);
       o = outx(instr, o);
    }
    if (oddity) o = outs(" ; (?)", o);
    outc('\0', o);
}

