#include "fname.h"

#define  NULL       0

#define  COLON     ':'
#define  AMPERSAND '&'
#define  DOLLAR    '$'
#define  DOT       '.'
#define  SLASH     '/'
#define  BACKSLASH '\\'
#define  HAT       '^'
#define  AT        '@'

#define  ROOTED     FNAME_ROOTED
#define  HASSLASH   16
#define  NOSLASH    32
#define  PSEUDOUNIX 64

/* #define HOST_HAS_ALL_NAMES       1 */

#ifndef HOST_HAS_ACORN_NAMES
#  ifdef HOST_HAS_ALL_NAMES
#    define HOST_HAS_ACORN_NAMES 1
#  endif
#  ifdef __riscos
#    define HOST_HAS_ACORN_NAMES 1
#  endif
#endif
#ifndef HOST_HAS_DOS_NAMES
#  ifdef HOST_HAS_ALL_NAMES
#    define HOST_HAS_DOS_NAMES   1
#  endif
#  ifdef __ZTC__
#    define HOST_HAS_DOS_NAMES   1
#  endif
#endif
#ifndef HOST_HAS_MAC_NAMES
#  ifdef HOST_HAS_ALL_NAMES
#    define HOST_HAS_MAC_NAMES   1
#  endif
#  ifdef macintosh
#    define HOST_HAS_MAC_NAMES   1
#  endif
#endif

static void parse_as_unix_or_dos_name(const char *s, UnparsedName *un, int sl)
{   const char *p;

    {   /* Zero/NULLify *un... */
        int l = sizeof(UnparsedName);
        char *p = (char *)un;
        while (l-- > 0) *p++ = 0;
    }

    for (p = s;  *p != 0 && *p != sl;  ++p)
        if (*p == COLON && p != s && un->vol == NULL)
        {   un->vol = s;
            ++p;
            un->vlen = p - s;
            /* strictly, PSEUDOUNIX only if sl == '/'... */
            un->flags |= (*p == sl) ? HASSLASH+PSEUDOUNIX : NOSLASH;
            un->flags |= ROOTED;
            s = p;
            if (*p == 0) break;
        }

    if (*s == sl)
    {   un->flags |= ROOTED+HASSLASH;
        ++s;
    }

    for (un->path = s;  *p != 0;  ++p)
        if (*p == sl) {s = p+1;  un->flags |= HASSLASH;}

    un->root = s;
    if (s[0] == DOT && (s[1] == 0 || s[1] == DOT && s[2] == 0))
        /* Really means 'is a Unix file name'... */
    {   un->flags |= HASSLASH;
        s = p;
        un->plen = s - un->path;
    }
    else if (un->path == s)
        un->path = NULL;
    else
        un->plen = s - un->path - 1;

    un->rlen = p - s;
    while (p != s)
    {   --p;
        if (*p == DOT)
        {   un->extn = p + 1;
            un->elen = un->rlen - (p - s) - 1;
            un->rlen = p - s;
            break;
        }
    }
    un->pathsep = sl;
}

#ifdef HOST_HAS_ACORN_NAMES

static int is_suffix(const char *extn, int elen, const char *suffixes)
{   int l, sch;
    sch = *suffixes++;
    while (sch)
    {   while (sch == ' ') sch = *suffixes++;
        l = 0;
        while (l < elen && extn[l] == sch) {++l;  sch = *suffixes++;}
        /* Assert: l >= elen || *extn[l] != *suffixes */
        if (l >= elen && (sch == ' ' || sch == 0)) return 1;
        while (sch != ' ' && sch != 0) sch = *suffixes++;
    }
    return 0;
}

static void reparse_as_risc_os_name(const char *s, UnparsedName *un,
    const char *suffixes)
{   const char *p = s, *e;

    if (un->flags & NOSLASH)
    {   /* starts volume:... but not volume:/... */
        p += un->vlen;
    }

    if (*p != COLON && *p != AMPERSAND && *p != DOLLAR)
    {   if (*p != HAT && *p != AT && un->flags & HASSLASH)
            /* interpretation as a Unix file name was just fine... */
            return;
        else
            un->flags = 0;
    }
    else
    {   if (*p == COLON)
        {   if (un->vol == NULL) un->vol = s;
            do ++p; while (*p != DOT && *p != 0);
            if (*p == DOT) ++p;
        }
        if (un->vol != NULL) un->vlen = p - un->vol - 1;
        if (*p == AMPERSAND || *p == DOLLAR) p += 2;  /* skip &. or $. */
        un->flags = ROOTED;
    }

    s = e = p;
    for (un->path = p;  *p != 0;  ++p)
        if (*p == DOT) {s = e;  e = p+1;}

    if (s != e && is_suffix(s, e-s-1, suffixes))
    {   un->extn = s;
        un->elen = e - s - 1;
        un->root = e;
        un->rlen = p - e;
    }
    else if (s != e && is_suffix(e, p-e, suffixes))
    {   un->extn = e;
        un->elen = p - e;
        un->root = s;
        un->rlen = e - s - 1;
    }
    else
    {   un->extn = NULL;
        un->elen = 0;
        s = e;
        un->root = e;
        un->rlen = p - e;
    }

    if (un->path == s)
    {   un->path = NULL;
        un->plen = 0;
    }
    else
        un->plen = s - un->path - 1;
    un->pathsep = DOT;
} 

#endif /* HOST_HAS_ACORN_NAMES */

#ifdef HOST_HAS_MAC_NAMES

static void reparse_as_mac_name(const char *s, UnparsedName *un)
{   const char *p;

    if (un->flags & HASSLASH)
        /* interpretation as a Unix file name was just fine... */
        return;

    un->flags = 0;
    un->vol = un->path = NULL;
    un->plen = un->vlen = 0;

    for (p = s;  *p != 0;  ++p)
        if (*p == COLON)
        {   if (un->path == NULL)
            {   if (p != s && un->vol == NULL)
                {   un->vol = s;
                    un->vlen = p - s;
                    un->flags |= ROOTED;
                }
                else
                    un->path = s+1;
            }
            s = p;
        }

    if (un->path == (s+1))
        un->path = NULL;
    else if (un->path != NULL)
        un->plen = s - un->path;
    if (*s == COLON) ++s;
    un->root = s;
    un->rlen = p - s;
    if (un->extn != NULL) un->rlen -= (un->elen + 1);
    un->pathsep = COLON;
} 

#endif /* HOST_HAS_MAC_NAMES */


int fname_parse(const char s[], int astype, const char *suffixes,
    UnparsedName *un)
{
    parse_as_unix_or_dos_name(s, un, SLASH);

    if (un->flags & PSEUDOUNIX
        ||
        un->vol == NULL && (un->flags & HASSLASH)
#ifdef HOST_HAS_ACORN_NAMES
        && !(s[0] == COLON || s[0] == DOLLAR ||
             s[0] == AMPERSAND || s[0] == HAT || s[0] == AT)
#endif
        ||
        astype == FNAME_UNIX)
        return un->type = FNAME_UNIX | (un->flags & ROOTED);

#ifdef HOST_HAS_ACORN_NAMES
#  ifdef HOST_HAS_ALL_NAMES
    if (astype == FNAME_ACORN)
#  else
    astype = FNAME_ACORN;
#  endif
        reparse_as_risc_os_name(s, un, suffixes);
#endif

#ifdef HOST_HAS_MAC_NAMES
#  ifdef HOST_HAS_ALL_NAMES
    if (astype == FNAME_MACINTOSH)
#  else
    astype = FNAME_MACINTOSH;
#  endif
        reparse_as_mac_name(s, un);
#endif

#ifdef HOST_HAS_DOS_NAMES
#  ifdef HOST_HAS_ALL_NAMES
    if (astype == FNAME_MSDOS)
#  else
    astype = FNAME_MSDOS;
#  endif
        parse_as_unix_or_dos_name(s, un, BACKSLASH);
#endif

    return un->type = astype | (un->flags & ROOTED);
}

#define  here_(type)  "\0@..\0"[type]

static char *copyto(char *s, const char *fm, int l, char *limit)
{   while (s != limit && l > 0) {*s++ = *fm++;  --l;}
    return s;
}

int fname_unparse(UnparsedName *un, int outtype, char *buffer, int maxlen)
{   int intype = un->type & FNAME_TYPEMASK;
    char *limit = buffer + maxlen;
    char *buffer0 = buffer;
    int as_path = (outtype & FNAME_AS_PATH);

    outtype &= ~FNAME_AS_PATH;
    if (outtype == 0 || (unsigned)outtype > FNAME_MACINTOSH)
        outtype = intype;

    if (un->vol != NULL)
    {   buffer = copyto(buffer, un->vol, un->vlen, limit);
        if (un->flags & PSEUDOUNIX)
        {   if (buffer != limit && outtype != FNAME_MACINTOSH)
                *buffer++ = "\0:\\/:"[outtype];
        }
        else if (buffer != limit && !(un->flags & NOSLASH))
            *buffer++ = dir_sep_(outtype);
        un->type |= ROOTED;
    }
    else if (un->type & ROOTED)
    {
#ifdef HOST_HAS_ACORN_NAMES
        if (outtype == FNAME_ACORN && buffer != limit)
            *buffer++ = DOLLAR;
#endif
        if (outtype != FNAME_MACINTOSH && buffer != limit)
            *buffer++ = dir_sep_(outtype); 
    }
    else
    {
#ifdef HOST_HAS_MAC_NAMES
        if (outtype == FNAME_MACINTOSH && buffer != limit)
            *buffer++ = COLON; 
#endif
    }

    if (un->path != NULL)
    {   const char *s = un->path, *p, *e = s + un->plen;
        int isep = dir_sep_(intype), osep = dir_sep_(outtype), l;

        for (p = s;  p <= e;  ++p)
        {   if (p < e && *p != isep) continue;
            l = p - s;
            if (
#ifdef HOST_HAS_MAC_NAMES
                l == 0 && intype == FNAME_MACINTOSH ||
#endif
#ifdef HOST_HAS_ACORN_NAMES
                l == 1 && intype == FNAME_ACORN && *s == '^' ||
#endif
                l == 2 && (intype == FNAME_MSDOS || intype == FNAME_UNIX) &&
                    s[0] == '.' && s[1] == '.')
            {
                if (buffer != limit &&
                    outtype != FNAME_MACINTOSH && outtype != FNAME_DFLT)
                {
                    *buffer++ = (outtype == FNAME_ACORN) ? '^' : '.';
                    if (outtype != FNAME_ACORN && buffer != limit)
                        *buffer++ = '.';
                }
            }
            else if (l == 1 && *s == here_(intype))
                goto skip_here;
            else
                buffer = copyto(buffer, s, l, limit);
            if (buffer != limit &&
                (p < e || un->rlen > 0 || outtype == FNAME_MACINTOSH))
                *buffer++ = osep;
skip_here:  s = p + 1;
        }
    }
    un->un_pathlen = (buffer - buffer0);
#ifdef HOST_HAS_MAC_NAMES
    if (outtype == FNAME_MACINTOSH &&
        buffer != buffer0 &&
        buffer[-1] == COLON) --(un->un_pathlen);
#endif

#ifdef HOST_HAS_ACORN_NAMES
    if (outtype == FNAME_ACORN && un->extn != NULL &&
        !(un->flags & PSEUDOUNIX))
    {   buffer = copyto(buffer, un->extn, un->elen, limit);
        if (buffer != limit) *buffer++ = DOT;
    }
#endif
    buffer = copyto(buffer, un->root, un->rlen, limit);
    if ((outtype != FNAME_ACORN || (un->flags & PSEUDOUNIX)) &&
        un->extn != NULL)
    {   if (buffer != limit) *buffer++ =
            (outtype == FNAME_ACORN) ? SLASH : DOT;
        buffer = copyto(buffer, un->extn, un->elen, limit);
    }
    else if (as_path)
    {   if (outtype != FNAME_MACINTOSH)
        {   if (buffer != limit && buffer != buffer0)
                *buffer++ = dir_sep_(outtype);
        }
        else if (buffer > buffer0 && buffer[-1] == COLON)
            --buffer;
        un->un_pathlen = (buffer - buffer0);
    }

    if (buffer == limit)
        return -1;
    else
    {   *buffer = 0;
        return  (buffer - buffer0);
    }
}
