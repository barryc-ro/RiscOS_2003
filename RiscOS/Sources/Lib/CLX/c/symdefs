/*
  Title:        symdefs - operations on symdefs files
  Status:       C Library Extension
  Copyright:    (C) 2000, Pace Micro Technology plc.
  $Id$

*/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifndef SEEK_SET
#  define  SEEK_SET  0
#endif

#include "symdefs.h"
#include "wholefls.h"

struct SymDefSymbol {
  struct SymDefSymbol *next;
  char *name;
  int32 val;
  SymDefSymbolType type;
  int updated;
  size_t start, end;
};


struct SymDefsFile {
  char *buffer;
  int32 buffer_length;
  int32 header_size;
  char *filename;
  unsigned32 sym_count;
  SymDefSymbol *syms;
  SymDefSymbol **last;
  int32 include_all_syms;
};


#define FILESIG "#SYMDEFS#"

/* These are the code letters which map directly to the enum above */
#define SYMDEF_TYPES "ADT"


/* Function to duplicate a string (allocate memory and copy bytewise)
 *
 * Originally: sbrodie
 *
 * Parameters: const char *s1 - source string
 * Result: char * - duplicate string (or NULL on failure or s1 NULL)
 *
 *
 * Problems: None known
 *
 */

static char *Strdup(const char *s1)
{
        if (s1 == NULL) {
                return NULL;
        }
        else {
                const size_t length = strlen(s1) + 1;
                char *const s2 = malloc(length);

                if (s2 == NULL) return NULL;
                return memcpy(s2, s1, length);
        }
}

static SymDefSymbol *sds_new(SymDefsFile *sf, char *name, int32 val, SymDefSymbolType t)
{
  const size_t name_len = strlen(name) + 1;
  SymDefSymbol *sds = malloc(sizeof(SymDefSymbol) + name_len);
  if (sds) {
    *(sf->last) = sds;
    sf->last = &sds->next;
    ++sf->sym_count;
    sds->next = NULL;
    sds->name = (char *) (sds + 1);
    sds->val = val;
    sds->type = t;
    sds->start = sds->end = 0;
    sds->updated = 0;
    memcpy(sds + 1, name, name_len);
  }

  return sds;
}

static void sds_delete(SymDefsFile *sf, SymDefSymbol *sds)
{
  SymDefSymbol **p;

  for (p = &sf->syms; *p; p = &((*p)->next)) {
    SymDefSymbol *t = *p;
    if (t == sds) {
      *p = t->next;
      if (*p == NULL) {
        sf->last = p;
      }
      break;
    }
  }

  free(sds);
}


extern int sf_parse(SymDefsFile *sf, SymDefCallback callback)
/*
 * Parse a symdef file.  Each symbol that is located in the file is passed to
 * the supplied callback function which *must* always return NULL.  (The CLX library
 * needs and uses the return value internally to preserve comments in restriction
 * specification files)
 */
{
  char *p = sf->buffer + sf->header_size;
  char *sym, temp;
  int32 val;
  SymDefSymbolType type;
  SymDefSymbol *sds;
  char typebuf[4];
  size_t start, end;

  if (sf->header_size == 0) {
    /* No file - probably an output file.  There's no symbols anyway */
    return 0;
  }

  /* Single-character string buffer for strcspn */
  typebuf[1] = 0;

  while (*p) {
    while (*p && isspace(*p)) ++p;
    if (!*p) return 0;
    if (*p == ';' || *p == '#') {
      /* This line is a comment */
      while (*p && *p != '\n') ++p;
      continue;
    }
    /* We have found a line of data now.  Should be [address] [type] [sym] */
    start = (p - sf->buffer);
    val = (int32) strtoul(p, &p, 0);
    while (*p && isspace(*p)) ++p;
    if (!*p) return -1;
    *typebuf = *p++;
    type = (SymDefSymbolType) strcspn(SYMDEF_TYPES, typebuf);
    while (*p && isspace(*p)) ++p;
    if (!*p) return -1;
    sym = p;
    while (*p && !isspace(*p)) ++p;
    end = (p - sf->buffer);
    temp = *p;
    *p = '\0';
    if ((sds = (*callback)(sf, sym, val, type)) != NULL) {
      sds->start = start;
      sds->end = end;
    }
    *p = temp;
  }

  return 0;
}

extern SymDefsFile *sf_open(char *filename, SymDefsFile *sf, SymDefsOpenMode mode)
{
/*
 * On entry, 'filename' is the name of the file which is assumed to be a
 * symdefs file; 'sf' in an intialised SymDefsFile returned by sf_new.
 *
 * On exit, 'sf' has been initialised safely and 'sf' is returned.
 * On an I/O error and the file not being a symdefs file and mode is
 *   SFOPEN_OUTPUT, 'sf' has been initialised safely and 'sf' is returned.
 *
 * On I/O error, or the file not being a symdefs file, NULL is returned.
 *
 * (structure still must be destroyed by sf_delete even if NULL returned)
 */
  sf->buffer_length = wf_filesize(filename);
  sf->filename = Strdup(filename);

  if (sf->buffer_length == -1 && mode == SFOPEN_OUTPUT) {
    /* The file does not exist (or cannot be read :-/)
     * For output symdefs file, this is OK.  For input files, we
     * simply return NULL to flag that it wasn't a symdefs file.
     */
    return sf;
  }

  if (sf->buffer_length < sizeof(FILESIG)) {
    /* Not a valid symdefs file - don't know what to do with the file */
    return NULL;
  }

  if ((sf->buffer = malloc((size_t) sf->buffer_length+1)) == NULL) {
    return NULL;
  }

  if (wf_load(filename, sf->buffer, sf->buffer_length) == -1) {
    /* Unable to load the file.  Fail the operation */
    return NULL;
  }

  sf->buffer[sf->buffer_length] = '\0'; /* Safety marker at end of file */

  if (memcmp(FILESIG, sf->buffer, sizeof(FILESIG)-1) != 0) {
    /* not a symdefs file! */
    return NULL;
  }

  sf->include_all_syms = 0;
  sf->header_size = strcspn(sf->buffer, "\r\n"); /* length of top line */

  sf_parse(sf, sds_new);
  return sf;
}


extern char *sf_readheader(SymDefsFile *sf, int32 *size)
{
/*
 * Read the signature line from 'sf', returning the length of the signature
 * in size and returning a pointer to the signature as the function result
 * Otherwise return NULL (on i/o error, not a chunk file, etc.).
 */
  *size = sf->header_size;
  return sf->buffer;
}

extern int sf_rewrite(SymDefsFile *sf, char *filename, char *toolsig)
{
/*
 * Regenerate the file referred to by 'sf' with the actual values of the
 * symbols in the structure.  toolsig is the tool's ID string to put in the
 * symdefs file.  The new filename is in 'filename' - NULL means use the
 * name originally passed to sf_open.  Do not pass NULL as 'toolsig'.
 * There is no need to put the date in 'toolsig' - it is added for you.
 *
 * If successfully written, return 0 otherwise return -1.
 */
  int result;
  char *buffer, *date, *p;
  const char *srcfile = sf->buffer;
  time_t t;
  size_t newsize;
  SymDefSymbol *sds;
  size_t last_end;

  time(&t);
  date = Strdup(ctime(&t));
  date[strcspn(date, "\r\n")] = '\0';

  /* BE CAREFUL - if you change the data in the file, don't forget to change
   *              it in BOTH places - the size calculation AND the data generator
   *              otherwise you will cause aborts/core dumps et al at best.
   */
  newsize = sizeof(FILESIG) + strlen(toolsig) + sizeof("[") + strlen(date) +
    sizeof("]") - 1;

  last_end = (size_t) sf->header_size;
  for (sds = sf->syms; sds; sds = sds->next) {
    size_t this_start = sds->start;
    if (this_start && last_end && this_start != last_end) {
      newsize += (this_start - last_end);
      last_end = sds->end;
    }
    else {
      ++newsize; /* newline */
    }
    if (sds->updated) {
      newsize += strlen("0x00000000 X ") + strlen(sds->name);
    }
  }

  if (last_end) {
    newsize += (size_t) (sf->buffer_length - last_end);
  }

  if (!sds) ++newsize; /* No symbols, at least put a newline on the end */

  p = buffer = malloc(newsize);
  if (p) {
    p += sprintf(p, FILESIG " %s [%s]", toolsig, date);
  }
  free(date);
  if (!p) return -1;


  last_end = (size_t) sf->header_size;
  for (sds = sf->syms; sds; sds = sds->next) {
    int32 this_start = sds->start;
    if (this_start && last_end && this_start != last_end) {
      memcpy(p, srcfile + last_end, (size_t) (this_start - last_end));
      p += this_start - last_end;
      last_end = sds->end;
    }
    else {
      *p++ = '\n';
    }
    if (sds->updated) {
      p += sprintf(p, "0x%08lx %c %s", sds->val, SYMDEF_TYPES[sds->type], sds->name);
    }
  }

  if (last_end) {
    memcpy(p, srcfile + last_end, (size_t) (sf->buffer_length - last_end));
    p += (sf->buffer_length - last_end);
  }

  if (!sds) *p++ = '\n'; /* No symbols, at least put a newline on the end */

  if (!filename) remove(sf->filename);
  result = wf_save(filename?filename : sf->filename, buffer, p - buffer);
  free(buffer);
  buffer = 0;
  return result;
}

extern SymDefsFile *sf_new(void)
{
/*
 * Returns a newly allocated SymDefsFile structure, or NULL if failed.
 *
 */
  SymDefsFile *sf = calloc(1, sizeof(SymDefsFile));

  if (sf) {
    sf->syms = NULL;
    sf->last = &sf->syms;
    sf->buffer = NULL;
    sf->filename = NULL;
    sf->buffer_length = -1;
    sf->include_all_syms = 1;
  }

  return sf;
}

extern void sf_delete(SymDefsFile *sf)
{
/*
 * Frees up all the memory associated with a symdefs file structure.
 *
 */
  while (sf->syms) sds_delete(sf, sf->syms);
  free(sf->filename);
  free(sf->buffer);
  free(sf);
}

extern SymDefSymbol *sf_update_symbol(SymDefsFile *sf, char *name, int32 val, SymDefSymbolType t)
{
/*
 * Updates a symbol's value in the symdefs file list structure.  If all global symbols are
 * being exported, the symbol will be added to the structure.  If a restricted list is being
 * used, only existing symbols will be updated.
 *
 * Returns NULL if the symbol was not added.
 */
  SymDefSymbol *sds;

  for (sds = sf->syms; sds; sds = sds->next) {
    if (strcmp(name, sds->name) == 0) {
      sds->val = val;
      sds->type = t;
      sds->updated = 1;
      break;
    }
  }

  if (sds == NULL && sf->include_all_syms) {
    sds = sds_new(sf, name, val, t);
    sds->updated = 1;
  }

  return sds;
}
