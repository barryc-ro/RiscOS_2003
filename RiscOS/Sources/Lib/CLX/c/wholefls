/*
  Title:        Operations on whole files
  Status:       C Library Extension
  Copyright:    (C) 1991, Advanced RISC Machines Ltd., Cambridge, England.
  $Revision$  LDS 15-Jan-91
*/

/*
 * This module is designed to provide efficient, portable operations on whole
 * files. The wf_filesize() function allows the caller to have control over
 * storage allocation, which is vital for application efficiency.
 *
 * Current implementations; RISC OS; BSD Unix (RISCiX, SunOS)
 */

#include "wholefls.h"

#ifdef __riscos

#ifdef SUPPORT_ECONET
#  include "netfix.h"
#else
#  define netfix_check_path(name, fixed)   name; *fixed = 0
#  define netfix_done()
#endif

#define  WRITEATTR     0x01
#define  READATTR      0x05
#define  SAVEFILE      0x0a
#define  LOADFILE      0xff
#define  FILEFOUND     1
#define  DATA          0xffd
#define  OPENUP        0xc0
#define  WRITEEXTENT   3
#define  CLOSE         0

typedef struct {
    int32 load, exec;
    int32 start, end;
} osfile_block;

extern int __riscos_osfile(int op, char *name, osfile_block *b);
extern int __riscos_osfind_open(int op, char *name);
extern int __riscos_osfind_close(int op, long handle);
extern int __riscos_osargs(int op, int32 handle, int32 arg);

int32 wf_filesize(name)
char *name;
/*
 * Return the size of the named file (as a pre-cursor to loading it).
 * Implemented using osfile(5,...) (Acorn).
 * Return -1 if error.
 */
{ osfile_block b;
  char *new_path;
  int fixed;
  int res;

  new_path = netfix_check_path(name, &fixed);
  res = __riscos_osfile(READATTR, new_path, &b);
  if (fixed) netfix_done();
  if (res != FILEFOUND) return -1;
  return b.start;
}

int wf_load(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Load the named file of size 'size' at address 'p'.
 * 'size' must match the size of the file exactly.
 * Return -1 if error; otherwise 0.
 * Implemented using osfile(&0xff,...) (RISC OS)
 */
{ osfile_block b;
  char *new_path;
  int fixed;
  int res;

  new_path = netfix_check_path(name, &fixed);

  b.load = (int32) p;
  b.exec = 0;
  res = __riscos_osfile(LOADFILE, new_path, &b);
  if (fixed) netfix_done();
  if (res != FILEFOUND) return -1;
  if (b.start != size) return -1;  /* wrong size */
  return 0;
}

int wf_save(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Save a block of memory as a file.
 * Return -1 if error; otherwise 0.
 * Implemented using osfile(&0x0a,...) (RISC OS).
 */
{ osfile_block b;
  char *new_path;
  int fixed;
  int res;

  new_path = netfix_check_path(name, &fixed);

  b.load  = DATA;
  b.exec  = 0;
  b.start = (int32) p;
  b.end   = b.start + size;
  res = __riscos_osfile(SAVEFILE, new_path, &b);
  if (fixed) netfix_done();
  return (res == SAVEFILE ? 0 : -1);
}

int wf_truncate(name, len)
char *name;
int32 len;
/*
 * Truncate the named file to at most 'len' bytes.
 * (Equivalent to Unix's ftruncate).
 * Return 0 if succeeded; otherwise -1.
 */
{ int32 fd, size;
  char *new_path;
  int fixed;

  size = wf_filesize(name);
  if (size < 0) return -1;
  if (len < size) {
    new_path = netfix_check_path(name, &fixed);
    fd = __riscos_osfind_open(OPENUP, new_path);
    if (fixed) netfix_done();
    if (__riscos_osargs(WRITEEXTENT, fd, len) != len) return -1;
    return __riscos_osfind_close(CLOSE, fd);
  }
  return 0;
}

int wf_copystatus(from_file, to_file)
char *from_file, *to_file;
/*
 * Propagate the time-stamp, file-type, and access permissions
 * from 'from_file' to 'to_file'.
 * Return 0 if succeeded; otherwise -1.
 */
{
  osfile_block b;
  char *new_path;
  int fixed;
  int res;

  new_path = netfix_check_path(from_file, &fixed);
  res = __riscos_osfile(READATTR, new_path, &b);
  if (fixed) netfix_done();
  if (res != FILEFOUND) return -1;

  new_path = netfix_check_path(to_file, &fixed);
  res = __riscos_osfile(WRITEATTR, new_path, &b);
  if (fixed) netfix_done();
  if (res < 0) return -1;
  return 0;
}

#else /* !__riscos */
#ifdef __ZTC__ /* Zortech C++ under MS-DOS */

#include <stdio.h>
#include <io.h>
#include <dos.h>

int32 wf_filesize(name)
char *name;
/*
 * Return the size of the named file (as a pre-cursor to loading it).
 * Implemented using stat() (Unix) or osfile(5,...) (Acorn).
 * Return -1 if error.
 */
{ int32 size;
  size = filesize(name);
  return size;
}

int wf_load(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Load the named file of size 'size' at address 'p'.
 * 'size' must match the size of the file exactly.
 * Return -1 if error; otherwise 0.
 * (Implemented using open(), read(), close() (Unix))
 */
{ int fd, rc, tempsize;
  VoidStar tempp;
  int32 remaining;
  fd = open(name, O_RDONLY, 0);
  if (fd <= 0) return -1;
  rc = 0;
  remaining = size;
  tempp = p;
  while (remaining > 32768)
  { if (read(fd, tempp, 32768) != 32768)
    { rc = -1;
      break;
    }
    remaining -= 32768;
    tempp = (char *)tempp + 32768;
  }
  if (rc == 0)
  { tempsize = remaining;
    if (read(fd, tempp, tempsize) != tempsize) rc = -1;
  }
  close(fd);
  return rc;
}

int wf_save(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Save a block of memory as a file.
 * Return -1 if error; otherwise 0.
 * Implemented using open(), write(), close() (Unix)
 */
{ int fd, rc, tempsize;
  VoidStar tempp;
  int32 remaining;
  fd = open(name, O_WRONLY+O_CREAT+O_TRUNC, 0664);
  if (fd <= 0) return -1;
  rc = 0;
  remaining = size;
  tempp = p;
  while (remaining > 32768)
  { if (write(fd, tempp, 32768) != 32768)
    { rc = -1;
      break;
    }
    remaining -= 32768;
    tempp = (char *)tempp + 32768;
  }
  if (rc == 0)
  { tempsize = remaining;
    if (write(fd, tempp, tempsize) != tempsize) rc = -1;
  }
  close(fd);
  return rc;
}

int wf_truncate(name, len)
char *name;
int32 len;
/*
 * Truncate the named file to at most 'len' bytes.
 * (Equivalent to Unix's truncate).
 * Return 0 if succeeded; otherwise -1.
 */
{
  fprintf(stderr, "\nwf_truncate not implemented\n\n");
  return -1;
}

int wf_copystatus(from_file, to_file)
char *from_file, *to_file;
/*
 * Propagate the time-stamp, file-type, and access permissions
 * from 'from_file' to 'to_file'.
 * Return 0 if succeeded; otherwise -1.
 */
{
  fprintf(stderr, "\nwf_copystatus not implemented\n\n");
  return -1;
}


#else /* !__ZTC__ */
#ifdef macintosh

#include <fcntl.h>
#include <stdio.h>

#include <Types.h>
#include <Files.h>
#include <Strings.h>

int32 wf_filesize(name)
char *name;
/*
 * Return the size of the named file (as a pre-cursor to loading it).
 * Implemented using stat() (Unix) or osfile(5,...) (Acorn).
 * Return -1 if error.
 */
{ ParamBlockRec pb;
  OSErr err;

  pb.fileParam.ioNamePtr = c2pstr(name);
  pb.fileParam.ioVRefNum = 0;
  pb.fileParam.ioFVersNum = 0;
  pb.fileParam.ioFDirIndex = 0;
  err = PBGetFInfoSync(&pb);
  p2cstr(name);

  return (err == noErr) ? pb.fileParam.ioFlLgLen : -1;
}

int wf_load(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Load the named file of size 'size' at address 'p'.
 * 'size' must match the size of the file exactly.
 * Return -1 if error; otherwise 0.
 * (Implemented using open(), read(), close() (Unix))
 */
{ int fd, rc;
  fd = open(name, O_RDONLY);
  if (fd <= 0) return -1;
  rc = 0;
  if (read(fd, p, size) != size) rc = -1;
  close(fd);
  return rc;
}

int wf_save(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Save a block of memory as a file.
 * Return -1 if error; otherwise 0.
 * Implemented using open(), write(), close() (Unix)
 */
{ int fd, rc;
  fd = open(name, O_WRONLY+O_CREAT+O_TRUNC);
  if (fd <= 0) return -1;
  rc = 0;
  if (write(fd, p, size) != size) rc = -1;
  close(fd);
  return rc;
}

int wf_truncate(name, len)
char *name;
int32 len;
/*
 * Truncate the named file to at most 'len' bytes.
 * (Equivalent to Unix's truncate).
 * Return 0 if succeeded; otherwise -1.
 */
{ int32 l;
  fprintf(stderr, "\nwf_truncate not implemented\n\n");
  return -1;
/*
  l = wf_filesize(name);
  if (l < len) return -1;
  return truncate(name, len);
*/
}

int wf_copystatus(from_file, to_file)
char *from_file, *to_file;
/*
 * Propagate the time-stamp, file-type, and access permissions
 * from 'from_file' to 'to_file'.
 * Return 0 if succeeded; otherwise -1.
 */
{
  fprintf(stderr, "\nwf_copystatus not implemented\n\n");
  return -1;
}

#else /* assume BSD Unix... */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>

int32 wf_filesize(name)
char *name;
/*
 * Return the size of the named file (as a pre-cursor to loading it).
 * Implemented using stat() (Unix) or osfile(5,...) (Acorn).
 * Return -1 if error.
 */
{ struct stat buf;
  if (stat(name, &buf) != 0) return -1;
  return buf.st_size;
}

int wf_load(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Load the named file of size 'size' at address 'p'.
 * 'size' must match the size of the file exactly.
 * Return -1 if error; otherwise 0.
 * (Implemented using open(), read(), close() (Unix))
 */
{ int fd, rc;
  fd = open(name, O_RDONLY, 0);
  if (fd <= 0) return -1;
  rc = 0;
  if (read(fd, p, size) != size) rc = -1;
  close(fd);
  return rc;
}

int wf_save(name, p, size)
char *name;
VoidStar p;
int32 size;
/*
 * Save a block of memory as a file.
 * Return -1 if error; otherwise 0.
 * Implemented using open(), write(), close() (Unix)
 */
{ int fd, rc;
  fd = open(name, O_WRONLY+O_CREAT+O_TRUNC, 0664);
  if (fd <= 0) return -1;
  rc = 0;
  if (write(fd, p, size) != size) rc = -1;
  close(fd);
  return rc;
}

int wf_truncate(name, len)
char *name;
int32 len;
/*
 * Truncate the named file to at most 'len' bytes.
 * (Equivalent to Unix's truncate).
 * Return 0 if succeeded; otherwise -1.
 */
{ int32 l;
  l = wf_filesize(name);
  if (l < len) return -1;
  return truncate(name, len);
}

int wf_copystatus(from_file, to_file)
char *from_file, *to_file;
/*
 * Propagate the time-stamp, file-type, and access permissions
 * from 'from_file' to 'to_file'.
 * Return 0 if succeeded; otherwise -1.
 */
{
  fprintf(stderr, "\nwf_copystatus not implemented\n\n");
  return -1;
}

#endif
#endif
#endif
