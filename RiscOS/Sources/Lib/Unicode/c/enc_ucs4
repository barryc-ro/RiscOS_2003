/************************************************************************/
/*                  Copyright 1997-1999 Element 14 Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Element 14 Ltd.  It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Element 14 Ltd.  All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdlib.h>

#include "encpriv.h"

#include "enc_ucs4.h"

typedef struct UCS4_Encoding
{
    EncodingPriv e;
    union
    {
        char byte[4];
        UCS4 word;
    } code;
    char sync;
    enum { big_endian, little_endian } byte_sex;
} UCS4_Encoding;

/*
 * Routines for encoding UCS-4
 * Number: 1001
 * Names: ISO-10646-UCS-4
 *        csUCS4
 */
static int ucs4_reset(Encoding *e, int for_encoding)
{
    UCS4_Encoding *ue = (UCS4_Encoding *) e;

    ue->code.word = 0;
    ue->sync = 3;
    ue->byte_sex = big_endian;

    return 1;
}

static unsigned int ucs4_read(Encoding *e,
                              encoding_read_callback_fn ucs_out,
                              const char *s,
                              unsigned int n,
                              void *handle)
{
    UCS4_Encoding *ue = (UCS4_Encoding *) e;
    unsigned int count;

    for (count = n; count; count--)
    {
        char c = *s++;
        UCS4 u;

        if (ue->byte_sex == big_endian)
            ue->code.byte[ue->sync] = c;
        else
            ue->code.byte[3 - ue->sync] = c;

        if (ue->sync)
        {
            ue->sync--;
            continue;
        }

        ue->sync = 3;
        u = ue->code.word;

        if (u == 0xFFFE0000)
        {
            if (ue->byte_sex == big_endian)
                ue->byte_sex = little_endian;
            else
                ue->byte_sex = big_endian;
            u = 0xFEFF;
        }

        if (ucs_out)
            if (ucs_out(handle, u))
                break;
    }

    return n - count;
}

/* Always write out little endian? */

static int ucs4_write(EncodingPriv *e, UCS4 u, char **pucs4, int *bufsize)
{
    char *ucs4;

    if (u == NULL_UCS4)
	return 0;
    
    if ((*bufsize -= 4) < 0 || !pucs4)
	return 0;

    ucs4 = *pucs4;

    /* convert all illegal sequences (except NULL_UCS4) to the
       illegal/replacement character */
    if (u & 0x80000000)
	u = 0xFFFD;
    
    *ucs4++ = (u >> 24) & 0xff;
    *ucs4++ = (u >> 16) & 0xff;
    *ucs4++ = (u >> 8) & 0xff;
    *ucs4++ = u & 0xff;

    (*pucs4) += 4;
    
    return 4;
    e = e;
}

EncodingPriv enc_ucs4 =
{
    ucs4_read,
    ucs4_reset,
    sizeof(UCS4_Encoding) - sizeof(EncodingPriv),
    0, /* ucs4_delete */
    0,
    ucs4_write
};
