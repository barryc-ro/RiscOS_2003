#ifndef encoding_H
#define encoding_H

#include "iso10646.h"
#include <stdlib.h>

typedef struct EncodingPriv Encoding;

typedef int (*encoding_read_callback_fn)(void *handle, UCS4 c);

/*
 * read processes the next part of a stream. s points to the data, which
 * is n bytes long. For each UCS character found, ucs_out() will be called
 * with the character code and the value passed in handle.
 * It will cope correctly with multi-byte codes split across two calls.
 * ucs_out() may return non-zero to indicate that decoding should stop.
 * The function returns the number of bytes read - this will equal n unless
 * ucs_out() signals early termination.
 */
extern unsigned encoding_read(Encoding *e,
			      encoding_read_callback_fn ucs_out,
			      const char *s,
			      unsigned int n,
			      void *handle);

/*
 * write a UCS4 'character' to the buffer in the encoding setup.
 * The buffer size remaining is updated whether the sequence is written or not.
 * The function returns true or false for whether the buffer was written to.
 * The buf ptr is only updated if the sequence was successfully written.
 */
extern int encoding_write(Encoding *e, UCS4 c, char **buf, int *bufsize);

/*
 * To obtain a new decoder session, use the following calls.
 *
 * new_encoding takes an encoding number. These numbers are Internet MIB numbers.
 * for_encoding is one of four values describing whether to the encoding will be used
 * with 'read' or 'write' methods and how writing should handle encoding errors.
 */

#define encoding_READ		0 /* to UTF 8 */
#define encoding_WRITE		1 /* from UTF8, single alternate for unencodable characters */
#define encoding_WRITE_STRICT	2 /* from UTF8 and return -1 if unencodable character */
#define encoding_WRITE_LOOSE	3 /* from UTF8, alternate list for unencodable characters */

extern Encoding *encoding_new(int n, int for_encoding);

/*
 * When a decoding session has finished, call delete_encoding to free up the Encoding
 * structure and other associated workspace.
 */
extern void encoding_delete(Encoding *e);

/*
 * reset_decoder() resets the decoder to its default state. Some encodings
 * have state (eg ISO 2022's character set and UCS-2's byte ordering) - this
 * will reset to allow a stream to be rescanned or a new stream to be
 * decoded.
 */

extern int encoding_reset(Encoding *e);

/*
 * Given a MIME charset name (terminated by a character not valid in a MIME
 * charset name, so a direct pointer into the Content-Type header field will do),
 * this returns the encoding number (the Internet MIB coded value if assigned).
 * This number can be passed to new_encoding(). If the name is unknown or
 * unsupported, 0 is returned.
 */
int encoding_number_from_name(const char *name);

/*
 * Setup the memory allocators for the encoding library to use
 * Defaults to malloc and free
 */

typedef void *(*encoding_alloc_fn)(size_t size);
typedef void (*encoding_free_fn)(void *ptr);

extern void encoding_set_alloc_fns(encoding_alloc_fn alloc, encoding_free_fn free);

extern int encoding_max_char_size(int enc_num);

/*
 * Return the default language string (see languages.h) for this encoding. 
 * Generic encodings such as UTF8 return ""
 */

extern const char *encoding_default_language(int enc_num);

/* Return the default mime type for this encoding number. Returns true
 * if the encoding number was one recognised by the library */

extern int encoding_default_mime_type(int enc_num, char *buf, int buf_size);

/*
 * Scan the list of loaded tables and free any that have zero usage counr.
 */

extern void encoding_table_remove_unused(void);

#endif
