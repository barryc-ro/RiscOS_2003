/* File:    callx.c
 * Purpose: Callback, callafter and callevery library
 * Author:  Ben Laughton
 * History:
 *
 * 1997-07-17: BAL
 * Created.
 *
 * 1997-08-26: RDW
 * Fixed bug where data structure accessed after being freed.
 * Functions changed are:
 *   callx_remove_callback, callx_remove_all_callbacks,
 *   callx_remove_callafter, callx_remove_all_callafters,
 *   callx_remove_callevery, callx_remove_all_calleverys
 */




/* =============================================================================
 * Include header files
 */

/* CLib */
#include "kernel.h"
#include <stdlib.h>
#include "swis.h"

/* DaytonaHW */
#include "callx.h"
#include "error.h"
#include "interrupts.h"




/* =============================================================================
 * Define contants
 */

#define F_CalledOnce (0x00000001)
#define F_Processing (0x00000002)

enum
{
    E_CallX_CantAdd
};




/* =============================================================================
 * Define types
 */

typedef struct list_t list_t;

typedef struct callx_t
{
    struct callx_t *prev;
    struct callx_t *next;

    unsigned int flags;
    void *pw;
    list_t *list;

    int time;    /* not used for callbacks */
    callx_handler_fn handler;
    void *data;

} callx_t;

struct list_t
{
    callx_t *first;
    callx_t *last;
};




/* =============================================================================
 * Declare global variables
 */

static void *workspace_ptr;
static list_t callback_list;
static list_t callafter_list;
static list_t callevery_list;

static _kernel_oserror callx_error[] =
{
    {0, "Unable to add call"}
};



/* =============================================================================
 * Declare function prototypes
 */

extern void  callx_veneer (void);

static callx_t *  add_call (list_t *            list,
                            const unsigned int  flags,
                            const int           time,
                            callx_handler_fn    handler,
                            void *              data);

extern void  remove_call (list_t *   list,
                          callx_t *  call);




/* =============================================================================
 * Define functions
 */

/* -----------------------------------------------------------------------------
+
   callx_init

   Initialise the callx library.

   Inputs
   pw: module's private word pointer
-
 */

extern void  callx_init (void *const  pw)
{
    workspace_ptr = pw;
}




/* -----------------------------------------------------------------------------
+
   callx_add_callback

   Add a transient callback.

   Inputs
   handler: pointer to callback handler function
   data:    data pointer for handler function

   Returns:
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_add_callback (callx_handler_fn  handler,
                                              void *            data)
{
    _kernel_oserror *  e = NULL;
    callx_t *          new_call;

    new_call = add_call (&callback_list, F_CalledOnce, 0, handler, data);
    if (new_call != NULL)
    {
        e = _swix (OS_AddCallBack, _INR (0, 1), callx_veneer, new_call);
        if (e)
        {
            remove_call (&callback_list, new_call);
        }
    }
    else
    {
        return &callx_error[E_CallX_CantAdd];
    }

    return e;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_callback

   Remove a pending callback.

   Inputs
   handler: pointer to callback handler function
   data:    data pointer for handler function

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *callx_remove_callback (callx_handler_fn handler,
                                               void *data)
{
    unsigned int  irqs;
    callx_t *     call;
    callx_t *     next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callback_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */
        if (call->handler == handler && call->data == data)
        {
            _kernel_oserror *  e;

            e = _swix (OS_RemoveCallBack, _INR (0, 1), callx_veneer, call);
            remove_call (&callback_list, call);
            irqs_restore (irqs);
            return e;
        }

/*        call = call->next; */ /* removed by RDW 26/10/97 */
        call = next;    /* added by RDW 26/10/97 */
    }
    irqs_restore (irqs);

    return NULL;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_all_callbacks

   Remove all pending callbacks.

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *callx_remove_all_callbacks (void)
{
    unsigned int       irqs;
    _kernel_oserror *  e = NULL;
    callx_t *          call;
    callx_t *          next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callback_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */

        e = _swix (OS_RemoveCallBack, _INR (0, 1), callx_veneer, call);
        /* previous errors will be squashed */

        remove_call (&callback_list, call);
 /*       call = call->next; */ /* removed by RDW 26/10/97 */
        call = next;    /* added by RDW 26/10/97 */
    }
    irqs_restore (irqs);

    return e;
}




/* -----------------------------------------------------------------------------
+
   callx_add_callafter

   Add a callafter.

   Inputs
   handler: pointer to callafter handler function
   data:    data pointer for handler function

   Returns:
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_add_callafter (const unsigned int  time,
                                               callx_handler_fn    handler,
                                               void *              data)
{
    _kernel_oserror *e = NULL;
    callx_t *new_call;

    new_call = add_call (&callafter_list,  F_CalledOnce, time, handler, data);
    if (new_call != NULL)
    {
        e = _swix (OS_CallAfter, _INR (0, 2), time, callx_veneer, new_call);
        if (e)
        {
            remove_call (&callafter_list, new_call);
        }
    }
    else
    {
        return &callx_error[E_CallX_CantAdd];
    }

    return e;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_callafter

   Remove a pending callafter.  Interrupts must be temporarily switch off so
   that the callafter being removed cannot trigger while we are looking for
   it in the list.

   Inputs
   handler: pointer to callafter handler function
   data:    data pointer for handler function

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_remove_callafter (callx_handler_fn  handler,
                                                  void *            data)
{
    unsigned int  irqs;
    callx_t *     call;
    callx_t *     next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callafter_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */
        if (call->handler == handler && call->data == data)
        {
            _kernel_oserror *  e;

            e = _swix (OS_RemoveTickerEvent, _INR (0, 1), callx_veneer, call);
            remove_call (&callafter_list, call);
            irqs_restore (irqs);
            return e;
        }

 /*       call = call->next;*/ /* removed by RDW 26/10/97 */
         call = next;    /* added by RDW 26/10/97 */
    }

    irqs_restore (irqs);
    return NULL;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_all_callafters

   Remove all pending callafters.  Interrupts must be switched off so that none
   of the callafters can be triggered while we are removing them.

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_remove_all_callafters (void)
{
    unsigned int       irqs;
    _kernel_oserror *  e = NULL;
    callx_t *          call;
    callx_t *          next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callafter_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */
        e = _swix (OS_RemoveTickerEvent, _INR (0, 1), callx_veneer, call);
        /* any previous error will be squashed */

        remove_call (&callafter_list, call);
/*        call = call->next;*/ /* removed by RDW 26/10/97 */
        call = next;    /* added by RDW 26/10/97 */
    }
    irqs_restore (irqs);

    return e;
}




/* -----------------------------------------------------------------------------
+
   callx_add_callevery

   Add a callevery.

   Inputs
   handler: pointer to callafter handler function
   data:    data pointer for handler function

   Returns:
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_add_callevery (const unsigned int  time,
                                               callx_handler_fn    handler,
                                               void *              data)
{
    _kernel_oserror *  e = NULL;
    callx_t *          new_call;

    new_call = add_call (&callevery_list, 0, time, handler, data);
    if (new_call != NULL)
    {
        e = _swix (OS_CallEvery, _INR (0, 2), time, callx_veneer, new_call);
        if (e)
        {
            remove_call (&callevery_list, new_call);
        }
    }
    else
    {
        return &callx_error[E_CallX_CantAdd];
    }

    return e;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_callevery

   Remove a pending callevery.

   Inputs
   handler: pointer to callevery handler function
   data:    data pointer for handler function

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_remove_callevery (callx_handler_fn  handler,
                                                  void *            data)
{
    unsigned int  irqs;
    callx_t *     call;
    callx_t *     next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callevery_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */
        if (call->handler == handler && call->data == data)
        {
            _kernel_oserror *  e;

            e = _swix (OS_RemoveTickerEvent, _INR (0, 1), callx_veneer, call);
            remove_call (&callevery_list, call);
            irqs_restore (irqs);
            return e;
        }

/*        call = call->next;*/ /* removed by RDW 26/10/97 */
        call = next;    /* added by RDW 26/10/97 */
    }

    irqs_restore (irqs);
    return NULL;
}




/* -----------------------------------------------------------------------------
+
   callx_remove_all_calleverys

   Remove all pending calleverys.

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

extern _kernel_oserror *  callx_remove_all_calleverys (void)
{
    unsigned int       irqs;
    _kernel_oserror *  e = NULL;
    callx_t *          call;
    callx_t *          next;    /* added by RDW 26/10/97 */

    irqs = irqs_off ();
    call = callevery_list.first;
    while (call)
    {
        next = call->next;    /* added by RDW 26/10/97 */
        e = _swix (OS_RemoveTickerEvent, _INR (0, 1), callx_veneer, call);
        /* previous errors will be squashed */

        remove_call (&callevery_list, call);
/*        call = call->next;*/ /* removed by RDW 26/10/97 */
        call = next;    /* added by RDW 26/10/97 */
    }
    irqs_restore (irqs);

    return e;
}




/* -----------------------------------------------------------------------------
+
   add_call

   Add a call to one of the call lists

   Inputs
   list:    list to add item to
   flags:   internal callx flags for this call
   time:    callafter / callevery time (not used for callbacks)
   handler: pointer to handler function
   data:    data pointer for handler function

   Returns
   success: NULL
   failure: pointer to standard error block
-
 */

static callx_t *  add_call (list_t *            list,
                            const unsigned int  flags,
                            const int           time,
                            callx_handler_fn    handler,
                            void *              data)
{
    callx_t *new_call;

    /* Allocate memory for new list element */
    new_call = malloc (sizeof (callx_t));
    if (new_call != NULL)
    {
        /* Fill in new call data */
        new_call->flags = flags;
        new_call->pw = workspace_ptr;
        new_call->list = list;

        new_call->time = time;
        new_call->handler = handler;
        new_call->data = data;

        /* Add new item to end of list */
        new_call->prev = list->last;
        new_call->next = NULL;

        if (list->first == NULL)
        {
            list->first = new_call;
        }

        if (list->last != NULL)
        {
            list->last->next = new_call;
        }

        list->last = new_call;
    }

    return new_call;
}




/* -----------------------------------------------------------------------------
+
   list_remove_item

   Remove an item from a list list.

   Inputs
   list: pointer to list to remove item from
   item: pointer to list item to remove
-
 */

extern void  remove_call (list_t *   list,
                          callx_t *  call)
{
    callx_t *prev, *next;

    /* Have to be careful here: if a call is removed by an interrupt routine
     * then that particular call may be currently invoked.  In this case we
     * don't want to remove the call here - it will be done automatically by
     * the veneer when the call finishes.
     */
    if ((call->flags & F_Processing) == 0)
    {
        prev = call->prev;
        next = call->next;

        /* Update previous item's next pointer */
        if (prev == NULL)    /* item to be removed is at start of list */
        {
            list->first = next;
        }
        else
        {
            prev->next = next;
        }

        /* Update next item's prev pointer */
        if (next == NULL)    /* item to be removed is at end of list */
        {
            list->last = prev;
        }
        else
        {
            next->prev = prev;
        }

        free (call);
    }
}
