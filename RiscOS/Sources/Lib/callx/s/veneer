; File:    veneer.s
; Purpose: Callx library veneer
; Author:  Ben Laughton
; History: 1997-08-15: BAL: Created

	GET	Hdr:ListOpts
	GET	Hdr:Macros
	GET	Hdr:System
	GET	Hdr:HostFS
	GET	Hdr:NdrDebug
	GET	Hdr:DDVMacros

	AREA	|C$$Code|, CODE, READONLY

	GBLL	debug
	GBLL	hostvdu

debug	SETL	false
hostvdu	SETL	true

veneer	SETD	true
time	SETD	false

F_CalledOnce	*	&00000001
F_Processing	*	&00000002

	IMPORT	|_Lib$Reloc$Off$DP|
	IMPORT	|remove_call|

	EXPORT	callx_veneer

callx_veneer
	STMFD	sp!, {r0-r9, sl, fp, lr}
	MOV	r9, r12			; pointer to callx structure

	; Set flag in data structure to indicate this call is being processed
	PHPSEI	r0			; disable IRQs
	LDR	r1, [r9, #8]
	ORR	r1, r1, #F_Processing
	STR	r1, [r9, #8]
	PLP	r0			; restore IRQs

	MOV	r4, pc
	ORR	r5, r4, #SVC_mode
	TEQP	r5, #0
	MOV	r0, r0

 [ debug
	SWI	XOS_ReadMonotonicTime
	Debug	time, "v",r12,r0
 ]

	MOV	r0, sp			; input register set
	LDR	r1, [r9, #12]		; module's private word pointer
	MOV	r12, r1
	LDR	r2, [r9, #28]		; routine's private pointer

	MOV     r5, lr			; preserve R14_svc
	MOV	sl, sp, LSR#20
	MOV	sl, sl, LSL#20		; SP_LWM
	LDMIA   sl, {r6, r7}            ; save old reloc modifiers over fn call
	LDR     r12, [r12]              ; -> static data
	LDMIB   r12, {fp, r12}          ; new relocation modifiers
	STMIA   sl,  {fp, r12}          ; set by module init

	Debug	veneer, "about to enter handler"
	; Set SL to the correct offset below SP
	; (eqvuivalent of ADD sl, sl, <number>)
	DCD	|_Lib$Reloc$Off$DP| + &e28aa000

	MOV	fp, #0			; halt C backtrace here

        MOV	lr, pc
	ADD	lr, lr, #return-.-4

	LDR	pc, [r9, #24]		; branch to call handler

return
	Debug	veneer, "returned from handler"
	; CallAfters and CallBacks are only called once, then removed by the
	; OS, so we should remove the list element for the call.
	; NB. This part is *not* re-entrant - if 'remove_call' were to be
	; re-entered to remove the same call then it would end up trying to
	; free the same data twice.

	PHPSEI	r8			; disable IRQs
	LDR	r0, [r9, #8]

	; Clear processing flag so remove_call can do its stuff (or so that
	; clients can remove a call if it does not fall into he 'called once'
	; category.
	BIC	r0, r0, #F_Processing
	STR	r0, [r9, #8]

	TST	r0, #F_CalledOnce
	LDRNE	r0, [r9, #16]		; pointer to list to remove call from
	MOVNE	r1, r9			; pointer to list item

	DebugIf	NE, veneer, "removing call",r0,r1
	BLNE	|remove_call|
	DebugIf	NE, veneer, "removed call"
	PLP     r8			; restore IRQs

	; Restore SL
	DCD	|_Lib$Reloc$Off$DP| + &e24aa000
	STMIA	sl, {r6, r7}		; restore old reloc modifiers
	MOV	lr, r5			; restore old R14_svc
	TEQP	r4, #0			; restore entry mode
	MOV	r0, r0
	LDMFD	sp!, {r0-r9, sl, fp, pc}^ ; return with unmodified flags

 [ debug
	InsertNDRDebugRoutines
 ]

	LTORG

	END
