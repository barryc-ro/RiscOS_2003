        SUBT    Creation of swis.h ==> Hdr:makehswis

; ***********************************
; ***    C h a n g e   L i s t    ***
; ***********************************

; Date       Name       Description
; ----       ----       -----------
; 07-Feb-94  TMD        Created file 
; 20-Jul-94  AMcC       Made compatible with Hdr file changes:
;                       - GETs Hdr:PublicWS rather than defining SoundWorkSpace.
;                       - Hdr:File has been split into Hdr:FSNumbers and Hdr:HighFSI
;                         GETs Hdr:FSNumbers (needed by NewErrors) (was GET Hdr:File).
;                       - FilerAction hdr file is now called FilerAct (was Filer).
;                       - Filter hdr file is now called Filter (was Filters).
;                       - Squash hdr file is now called Squash (was Compress).
;                       - Removed GET  Hdr:DBox
;                       - Removed GET  Hdr:ROMCache
; 22-Sep-94  AMcC       #ifdef __cplusplus lines included in derived file (from IJohnson)
; 22-Sep-94  AMcC       Generates SWI name defs for all SWIs listed in PRM (3.50 version)
; 12-Oct-94  AMcC       Added SWIs for DDT (HLLDebugger) and HostFS (Tube)
; 03-Jan-95  AMcC       Added CDROM and SCSI SWIs (as requested by SPalmer)
; 09-Jan-95  AMcC       Added #defines for INR(..) and OUTR(..)
;                       Added usage comment (for Aquarius Toolbox)
;                       Updated version and date for header of output file
;

; AAsm source file to make h.swis file from Hdr:SWIs and other headers

        GET     Hdr:ListOpts

        GBLS    SWIClass

; Now the special version of the AddSWI macro that outputs the #defines

        MACRO
        AddSWI  $SWIName,$value
        LCLA    val2
  [     "$value" = ""
$SWIClass._$SWIName # 1
  |
$SWIClass._$SWIName * $value
  ]
val2    SETA    $SWIClass._$SWIName
X$SWIClass._$SWIName * $SWIClass._$SWIName + Auto_Error_SWI_bit
        =       "#undef $SWIClass._$SWIName", 10
        =       "#define $SWIClass._$SWIName 0x$val2", 10
        MEND

        MACRO
$label  AddError $name,$text,$value
$label
   [    "$value" = ""
ErrorNumber_$name # 1
   |
ErrorNumber_$name * $value
   ]
        GBLS ErrorString_$name
ErrorString_$name SETS "$text"
        MEND

        MACRO
$label  AddError2 $name,$text,$value
$label
   [    "$value" = ""
ErrorNumber_$name # 1
   |
ErrorNumber_$name * $value
   ]
        GBLS ErrorString_$name
ErrorString_$name SETS "$text"
        MEND

        MACRO
$label  AddFSError      $class, $baseerr, $fsname, $fsnumber
$label
        LCLA    value
value   SETA    &10000 + $fsnumber*&100 + ErrorNumber_$baseerr._Pre
        LCLS    string
string  SETS    ErrorString_$baseerr._Pre :CC: "$fsname" :CC: ErrorString_$baseerr._Post
        LCLS    string2
string2 SETS    "&":CC:(:STR:value)
        AddError        $class$baseerr, "$string", $string2
        MEND

; Needed to GET Hdr:Sound without Hdr:VickySpace -> Hdr:Macros

;SoundWorkSpace * &01F04000
        GET     Hdr:PublicWS

; First output the file header

        =       "#pragma force_top_level", 10
        =       "#pragma include_only_once", 10
        =       10
        =       "/*Name:    swis.h", 10
        =       "  Purpose: Generalised SWI interface", 10
        =       "  Author:  (c) Acorn Computers Ltd, 1989", 10
        =       "  Version: 2.04 (09-Jan-1995)", 10
        =       "  This file is automatically generated from Hdr:makehswis", 10
        =       "*/", 10
        =       10
        =       "#ifndef __swis_h", 10
        =       "#define __swis_h", 10
        =       10
        =       "#ifndef __kernel_h", 10
        =       "  #include ""kernel.h""", 10
        =       "#endif", 10
        =       10
        =       "#ifdef __cplusplus", 10
        =       "extern ""C""", 10
        =       "{", 10
        =       "#endif", 10
        =       10
        =       "extern int _swi (int swi_no, unsigned int, ...);", 10
        =       10
        =       "extern _kernel_oserror *_swix (int swi_no, unsigned int, ...);", 10
        =       10
        =       "#ifdef __cplusplus", 10
        =       "}", 10
        =       "#endif", 10
        =       10
        =       "#define _FLAGS     0x10 /*use with _RETURN() or _OUT()*/", 10
        =       "#define _IN(i)     (1U << (i))", 10
        =       "#define _INR(i,j)  (~0 << (i) ^ ~0 << (j) + 1)", 10
        =       "#define _OUT(i)    ((i) != _FLAGS? 1U << 31 - (i): 1U << 21)", 10
        =       "#define _OUTR(i,j) (~0U >> (i) ^ ~0U >> (j) + 1)", 10
        =       "#define _BLOCK(i)  (1U << 11 | (unsigned) (i) << 12)", 10
        =       "#define _RETURN(i) ((i) != _FLAGS? (unsigned) (i) << 16: 0xFU << 16)", 10
        =       "#define _C         (1U << 29)", 10
        =       "#define _Z         (1U << 30)", 10
        =       "#define _N         (1U << 31)", 10
        =       10
        =       "#define XOS_Bit    (1U << 17) /*deprecated: use _swi() or _swix()*/", 10
        =       10
        =       "/*", 10
        =       " * These functions provide a generic method of calling RISC OS SWIs from C or", 10
        =       " * C++.", 10
        =       " * ", 10
        =       " * Two functions are provided:", 10
        =       " *     _swi for calling SWIs without setting the X bit", 10
        =       " *     _swix which sets the X bit before calling the SWI.", 10
        =       " * ", 10
        =       " * swi_no is the number of the SWI to be called. This should never have the", 10
        =       " * X bit set.", 10
        =       " * ", 10
        =       " * mask is a word containing an input and output register mask, a return", 10
        =       " * register, and a block parameter register.", 10
        =       " * ", 10
        =       " * The arrangement of mask is as follows:", 10
        =       " * ", 10
        =       " * Bits 0 -  9:  Set if R(N) is passed to the SWI.", 10
        =       " * Bits 22 - 31: Set if R(31-N) is output from the SWI (ie bit 31", 10
        =       " *               corresponds to R0, bit 22 corresponds to R9).", 10
        =       " * Bit 21:       Set if the PC (including the flags) is to be output.", 10
        =       " * Bits 16 - 19: Register no. to be returned from a _swi call. This is only", 10
        =       " *               applicable to _swi as _swix always returns either 0 or an error", 10
        =       " *               pointer.", 10
        =       " * Bit 11:       Set if a local block parameter is to be passed to the SWI", 10
        =       " * Bits 12 - 15: Register number for local block parameter if bit 11 set.", 10
        =       " * ", 10
        =       " * If a register is specified as a return register (bits 16-19) it must not", 10
        =       " * also be specified as an output register in the output register mask", 10
        =       " * (bits 22-31).", 10
        =       " * ", 10
        =       " * If a register is specified as a local block parameter register it must not", 10
        =       " * also be specified as an input register in the input register mask", 10
        =       " * (bits 0-9).", 10
        =       " * ", 10
        =       " * If the PC is specified as a return register (ie bits 16-19 = 15) or as an", 10
        =       " * output registers (bit 21 = 1) the value returned will contain the flags in", 10
        =       " * bits 28 to 31 (28 = V, 29 = C, 30 = Z, 31 = N).", 10
        =       " * ", 10
        =       " * The remainder of the variadic arguments are as follows (in order):", 10
        =       " * ", 10
        =       " * The word value of each input register in order from 0 to 9 as specified by", 10
        =       " * bits 0 to 9 of the mask.", 10
        =       " * ", 10
        =       " * The address of a word to be written for each output register in order from", 10
        =       " * 0 to 9 as specified by bits 31 downto 22 of the mask.", 10
        =       " * ", 10
        =       " * The address of a word to be written with the PC value on exit from the SWI", 10
        =       " * if bit 21 of the register mask is set.", 10
        =       " * ", 10
        =       " * If bit 11 is set the remainder of the arguments are placed in order in a", 10
        =       " * parameter block and the address of the parameter block is passed to the SWI", 10
        =       " * in the register specified by bits 12-15.", 10
        =       " * ", 10
        =       " * The macros are as follows:", 10
        =       " * ", 10
        =       " * _IN(n)       - Specifies that R(n) is used on input", 10
        =       " * _OUT(n)      - Specifies that R(n) is output", 10
        =       " * _BLOCK(n)    - Specifies that R(n) is a block parameter", 10
        =       " * _RETURN(n)   - Specifies that R(n) is returned from _swi.", 10
        =       " * ", 10
        =       " * The values of the macros should be ORed together to produce the value for", 10
        =       " * the mask.", 10
        =       " * ", 10
        =       " * The following constants are defined", 10
        =       " * ", 10
        =       " * _FLAGS       - the register containing the flags (currently 15)", 10
        =       " * _C           - mask for the C bit in _FLAGS", 10
        =       " * _Z           - mask for the Z bit in _FLAGS", 10
        =       " * _N           - mask for the N bit in _FLAGS", 10
        =       " * ", 10
        =       " * Example calls:", 10
        =       " * ", 10
        =       " *     _swi(OS_NewLine, 0);   // Must specify 0 register mask", 10
        =       " * ", 10
        =       " *     _swi(OS_Write0, _IN(0), ",34,"Hello, World",34,");", 10
        =       " * ", 10
        =       " *     task_handle = _swi(Wimp_Initialise, _IN(0)|_IN(1)|_IN(2)|_RETURN(1),", 10
        =       " *                        300, *(int *)",34,"TASK",34,", ",34,"Test",34,");", 10
        =       " * ", 10
        =       " *     e = _swix(Wimp_LoadTemplate, _IN(1)|_IN(2)|_IN(3)|_IN(4)|_IN(5)|_IN(6)|", 10
        =       " *                                  _OUT(2)|_OUT(6),", 10
        =       " *               template_buffer, workspace, workspace_end, -1, ",34,"MyWind",34,", next,", 10
        =       " *               &workspace_end, &next);", 10
        =       " * ", 10
        =       " *     e = _swix(Wimp_SetExtent, _IN(0)|_BLOCK(1), w, minx, miny, maxx, maxy);", 10
        =       " */", 10
        =       10

; Now output all the SWI symbols we can access

        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:SWIs
        GET     Hdr:CPU.Generic26
        GET     Hdr:IO.GenericIO
        GET     Hdr:ModHand

        GET     Hdr:ADFS
        GET     Hdr:ATAPI
        GET     Hdr:BasicTrans
        GET     Hdr:Buffer
        GET     Hdr:ARM3Cache
        GET     Hdr:CDROM
        GET     Hdr:CDFS
        GET     Hdr:ColourPick
        GET     Hdr:ColourTran
        GET     Hdr:DDT
        GET     Hdr:Debugger
        GET     Hdr:DeviceFS
        GET     Hdr:DMA
        GET     Hdr:DOSFS
        GET     Hdr:DragASprit
        GET     Hdr:DragAnObj
        GET     Hdr:Draw
        GET     Hdr:Econet
        GET     Hdr:FileCore
        GET     Hdr:FilerAct
        GET     Hdr:Filter
        GET     Hdr:Font
        GET     Hdr:FPEmulator
        GET     Hdr:Free
        GET     Hdr:FSLock
        GET     Hdr:Hourglass
        GET     Hdr:HostFS
        GET     Hdr:IIC
        GET     Hdr:Joystick
        GET     Hdr:MakePSFont
        GET     Hdr:MsgTrans
;       GET     Hdr:NetFS         SWIs defined in Hdr:Econet
;       GET     Hdr:NetPrint      SWIs defined in Hdr:Econet
        GET     Hdr:RISCOS
        GET     Hdr:Parallel
        GET     Hdr:PDriver
        GET     Hdr:PDumper
        GET     Hdr:Podule
        GET     Hdr:Portable
        GET     Hdr:RAMFS
        GET     Hdr:ResourceFS
        GET     Hdr:ScrBlank
        GET     Hdr:ScrModes
        GET     Hdr:SCSI
        GET     Hdr:SCSIFS
        GET     Hdr:SharedCLib
        GET     Hdr:Shell
        GET     Hdr:Sound
        GET     Hdr:Squash
        GET     Hdr:Super
        GET     Hdr:Switcher
        GET     Hdr:TaskWindow
        GET     Hdr:Territory
        GET     Hdr:Wimp

; And finally the trailing bits

        =       10
        =       "#endif", 10

        END
