/*--------------------------------------------------------------------------------------------*/
/* File:    c.rml_misc                                                                        */
/* Purpose: Miscellaneous library routines                                                    */
/* Author:  Richard Leggett                                                                   */
/* History: 21-Apr-97: RML: Created using elements of my image library code which were out    */
/*                          of place in their current files.                                  */
/*--------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"
#include "rml_misc.h"
#include "defines.h"

#define DebugOutput    0
#define ReportToFile   0
#define ReportToScreen 0

static FILE *debug_fp;
static FILE *report_fp;

/*--------------------------------------------------------------------------------------------*/
/* Memory munging routines                                                                    */
/*--------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------*
 * rml_misc_memset32bit                                                                       *
 *                                                                                            *
 * A version of the clib memset, for 32bit numbers. It will copy n lots of the 32bit integer  *
 * 'c' into memory, starting at location pointed to by 'data' (assumed to be word aligned).   *
 *                                                                                            *
 * In: data - pointer to memory.                                                              *
 *     c    - 32bit integer to put in memory.                                                 *
 *     n    - number of times to copy 'c'.                                                    *
 *--------------------------------------------------------------------------------------------*/

void rml_misc_memset32bit(char* data, unsigned int c, int n)
{
   int* store = (int*)data;
   int  i;

   for (i=0; i<n; i++) store[i]=c;
}


/*--------------------------------------------------------------------------------------------*
 * rml_misc_memset16bit                                                                       *
 *                                                                                            *
 * A version of the clib memset, for 16bit numbers. It will copy n lots of the 16bit integer  *
 * 'c' into memory, starting at location pointed to by 'data' (assumed to be half word        *
 * aligned).                                                                                  *
 *                                                                                            *
 * In: data - pointer to memory.                                                              *
 *     c    - 16bit integer to put in memory.                                                 *
 *     n    - number of times to copy 'c'.                                                    *
 *--------------------------------------------------------------------------------------------*/

void rml_misc_memset16bit(char* data, unsigned int c, int n)
{
   int* store = (int*)data;
   int  word  = (c<<16) + c;
   int  m     = n;
   int  i, to;

   if ((int)data % 4) {
     data[0] = c & 0xFF;
     data[1] = (c & 0xFF00) >>8;
     m--;
     store++;
   }

   to = m/2;

   for (i=0; i<to; i++) store[i]=word;

   if (m % 2) {
     data[n*2-2]   = c & 0xFF;
     data[n*2-1] = (c & 0xFF00) >>8;
   }
}


/*--------------------------------------------------------------------------------------------*
 * rml_misc_memset1bit                                                                        *
 *                                                                                            *
 * A version of the clib memset, for 1bit numbers. It will copy n lots of the 1bit integer    *
 * 'c' into memory, starting at location pointed to by 'data' and starting with the bit       *
 * specified by 'startbit' (0 being least significant).                                       *
 *                                                                                            *
 * In: data     - pointer to memory.                                                          *
 *     c        - 1bit value to put in memory.                                                *
 *     n        - number of times to copy 'c'.                                                *
 *     startbit - bit number of location 'data' to start at.                                  *
 *--------------------------------------------------------------------------------------------*/

void rml_misc_memset1bit(char *data, int c, int n, int startbit)
{
   int* store;
   int  i, j, to, bit, b, from;
   int  word=0;
   char byte=0;

   if (c==1)  word=0xFFFFFFFF;

   b    = (int)data % 4;

   if ((b) || (startbit))
   {
     b = 4-b;

     for (i=0; i<b; i++)
     {
       byte = data[i];
       if (i==0) {
         from=startbit;
         startbit=-1;
       }
       else from=0;
       for (j=from; j<8; j++)
       {
         bit = 1<<j;
         if (c)               byte = byte | bit;
         else if (byte & bit) byte = byte ^ bit;
         n--; if (n==0) break;
       }
       data[i] = byte;
       if (n==0) break;
     }

     data+=b;
   }

   if (n<=0) return;

   if (n>31) {
     store = (int*)data;
     to = n/32;
     for (i=0; i<to; i++) store[i]=word;
     n-=32;
     data=data + (to*4);
   }

   if (n<=0) return;

   b = n/8; if (n % 8) b++;

   for (i=0; i<b; i++)
   {
     byte = data[i];

     for (j=0; j<8; j++)
     {
       bit = 1<<j;
       if (c)               byte = byte | bit;
       else if (byte & bit) byte = byte ^ bit;
       n--;
       if (n==0) break;
     }
     data[i] = byte;
     if (n==0) break;
   }

}


/*--------------------------------------------------------------------------------------------*
 * rml_misc_set_bit                                                                           *
 *                                                                                            *
 * Sets a bit of a number                                                                     *
 *                                                                                            *
 * In: num - original value of the number.                                                    *
 *     bit - number of bit to set (0 lsb, 31 msb).                                            *
 *                                                                                            *
 * Returns: new value of num.                                                                 *
 *--------------------------------------------------------------------------------------------*/

int rml_misc_set_bit(int num, int bit)
{
  int bitmask = 1<<bit;

  return num | bitmask;
}


/*--------------------------------------------------------------------------------------------*
 * rml_misc_unset_bit                                                                         *
 *                                                                                            *
 * Unsets a bit of a number                                                                   *
 *                                                                                            *
 * In: num - original value of the number.                                                    *
 *     bit - number of bit to unset (0 lsb, 31 msb).                                          *
 *                                                                                            *
 * Returns: new value of num.                                                                 *
 *--------------------------------------------------------------------------------------------*/

int rml_misc_unset_bit(int num, int bit)
{
  int bitmask = 1<<bit;

  if ((num & bitmask)==bitmask) return num^bitmask;
  return num;
}


/*--------------------------------------------------------------------------------------------*/
/* Graphics routines                                                                          */
/*--------------------------------------------------------------------------------------------*/

/* Read the current graphics window co-ords */
gbox read_graphics_window(void)
{
  int in[5];
  gbox out;

  in[0]=128;
  in[1]=129;
  in[2]=130;
  in[3]=131;
  in[4]=-1;

  _swi(OS_ReadVduVariables,_IN(0)|_IN(1),(int)in,&out);
  return out;
}


/*--------------------------------------------------------------------------------------------*/
/* Debugging routines                                                                         */
/*--------------------------------------------------------------------------------------------*/


/* Open the debugging file */
void debug_start(void)
{
   if (debug_fp!=NULL) return;
   debug_fp=fopen("<Debug$Dir>.Debug", "w");
   if (!debug_fp) exit(0);
}


/* Close the debugging file */
void debug_end(void)
{
#if DebugOutput
   fclose(debug_fp);
#endif
}


/* Print a string to the debug file */
void debug_print(char* s)
{
#if DebugOutput
   char string[255];

   if (debug_fp==NULL) debug_start();

   sprintf(string, "%s\n",s);
   fprintf(debug_fp, string);
#endif
}


/* Print an error string to the debug file */
void debug_error(char* s)
{
#if DebugOutput
   if (debug_fp==NULL) debug_start();

   fprintf(debug_fp, s);
#endif
}


/* Print a string and a value to the debug file */
void debug_value(char *s, int v)
{
#if DebugOutput
  char string[255];

  if (debug_fp==NULL) debug_start();

  sprintf(string, "%s %d\n",s,v);
  fprintf(debug_fp,string);
#endif
}


/* Print a number to the debug file */
void debug_numeric(int n)
{
#if DebugOutput
  char string[255];

  if (debug_fp==NULL) debug_start();

  sprintf(string, "Number %d\n",n);
  fprintf(debug_fp,string);
#endif
}


/* Breakpoint for debugger */
void debugger_breakpoint(void)
{
}


/* Exit program and report error */
void exit_error(char *string)
{
  _swi(OS_WriteC,_IN(0),4);
  _swi(OS_WriteC,_IN(0),26);
  printf("\nAn error has occurred :\n");
  printf("%s\n",string);
  //_swi(OS_ReadC,0);
  exit(0);
}


/*--------------------------------------------------------------------------------------------*/
/* Reporting routines                                                                         */
/*--------------------------------------------------------------------------------------------*/

void report_string(char *s)
{
   char string[255];

   memset(string, 0, 1);

#if ReportToFile
   if (!report_fp) report_start();
   sprintf(string,"%s\n",s);
   fprintf(report_fp,string);
#endif

#if ReportToScreen
   printf("%s\n",s);
#endif
}

void report_value(char *s, int v)
{
   char string[255];

   memset(string, 0, 1);

#if ReportToFile
   if (!report_fp) report_start();
   sprintf(string, "%s %d\n", s, v);
   fprintf(report_fp, string);
#endif

#if ReportToScreen
   printf("%s %d\n",s,v);
#endif
}

void report_start(void)
{
   if (report_fp) return;
   report_fp = fopen("<Debug$Dir>.GIFReport", "w");
   if (!report_fp) {
     printf("Can't open report file.\n");
     exit(0);
   }
}
