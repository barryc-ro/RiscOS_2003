/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <stdlib.h>
#include <string.h>
#include <math.h>
#ifdef TRACE
#include <stdio.h>
#endif

#include "swis.h"

#include "imagetrans.h"

#include "internal.h"
#include "defines.h"
#include "datastruct.h"
#include "gif.h"
#include "cfsi.h"
#include "jpeg.h"
#include "xbm.h"
#include "png.h"
#include "sprite.h"
#include "PNG/png.h"

static const char *mimetypes[]={"gif", "jpeg", "x-xbitmap", "x-riscos-sprite", "png", 0};

static int NewGuess(Image *);
static _kernel_oserror *LoadGuess(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *DeleteGuess(Image *this);
static _kernel_oserror *EndLoadGuess(Image *this, BBox *changed);

void ImageLib_Init (void)
{
    png_init ();
}

Image *NewImage(const char *mimetype, unsigned int flags)
{
    Image *image;
    int s;
    int i;

    image=(Image *)malloc(sizeof(Image));
    memset(image, 0, sizeof(Image));

    if (!image)
        return NULL;

    image->width=-1;
    image->height=-1;
    image->flags=flags;
    image->private_data=NULL;

    image->transparent = 0;
    image->mutable_mask = 0;
    image->animated = 0;

    if (mimetype==NULL)
        i=-1;
    else
        for (i=0; mimetypes[i]; i++)
            if (strcmp(mimetype, mimetypes[i])==0)
                break;

    switch (i)
    {
        case -1:
            s=NewGuess(image);
            break;

        case 0:
            s=NewGIF(image);
            break;

        case 1:
            s=NewJPEG(image);
            break;

        case 2:
            s=NewXBM(image);
            break;

        case 3:
            s=NewSprite(image);
            break;

        case 4:
            s=NewPNG(image);
            break;

        default:
            s=NewCFSI(image);
            break;
    }

    if (s)
    {
        free(image);
        return NULL;
    }

    return image;
}

static int NewGuess(Image *this)
{
    this->Load=LoadGuess;
    this->Delete=DeleteGuess;
    this->EndLoad=EndLoadGuess;
    this->width=this->width_os=this->height_os=-1;
    this->height=0; /* Use this to store bytes so far */

    return 0;
}

static _kernel_oserror *LoadGuess(Image *this, const char *data, int len, BBox *changed)
{
    int toread=len;
    char temp[sizeof this->factors];
    int s;
    _kernel_oserror *e;
    int tempw, temph;

    #ifdef TRACE
    FILE *trace;
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%pG", this);
        trace=fopen(name, "a");
        if (trace)
        {
            fwrite(data, len, 1, trace);
            fclose(trace);
        }
    }
    #endif

    if (changed)
        memset(changed, 0, sizeof(BBox));

    if (len<0)
        return NULL;

    if (toread+this->height > sizeof this->factors)
        toread=sizeof this->factors - this->height;

    memcpy((char *)this->factors+this->height, data, toread);

    this->height += toread;
    len -= toread;
    data += toread;

    if (this->height < sizeof this->factors)
        return 0;

    tempw=this->width_os;
    temph=this->height_os;

    memcpy(temp, this->factors, sizeof temp);

    #ifdef TRACE
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%pD", this);
        trace=fopen(name, "w");
        if (trace)
            fprintf(trace, "I think it's a ");
    }
    #endif
    if (this->factors[0] == 0x38464947)  /* GIF8 */
    {
        s=NewGIF(this);
        #ifdef TRACE
        if (trace) fprintf(trace, "GIF. NewGif returned %d\n", s);
        #endif
    }
    else if ((this->factors[1] & 0xFFFF0000) == 0x464A0000 &&
             (this->factors[2] & 0x0000FFFF) == 0x00004649)     /* JFIF */
    {
        s=NewJPEG(this);
        #ifdef TRACE
        if (trace) fprintf(trace, "JPEG. NewJPEG returned %d\n", s);
        #endif
    }
    else if (this->factors[0] == 0x66656423 &&
             this->factors[1] == 0x20656E69)     /* #define */
        s=NewXBM(this);
    else if (this->factors[0] <= 200 &&       /* Less than 200 sprites */
             this->factors[1] <= 64*1024 &&    /* Less than 64K of user data */
             this->factors[2] <= 4*1024*1024)  /* Less than 4M in size */
        s=NewSprite(this);
    else if (png_check_sig((png_bytep) this->factors, sizeof this->factors))
        s=NewPNG(this);
    else
    {
        s=NewCFSI(this);
        #ifdef TRACE
        if (trace) fprintf(trace, "Dunno. NewCFSI returned %d\n", s);
        #endif
    }

    #ifdef TRACE
    if (trace) fclose(trace);
    #endif

    if (s)
        return imgtrnsError("Unable to determine image format");

    this->width_os=tempw;
    this->height_os=temph;

    e=this->Load(this, temp, sizeof temp, changed);
    if (!e && len)
        e=this->Load(this, data, len, changed);

    return e;
}

static _kernel_oserror *DeleteGuess(Image *this)
{
    free(this);
    return NULL;
}

static _kernel_oserror *EndLoadGuess(Image *this, BBox *changed)
{
    changed=NULL;
    
    return imgtrnsError("Insufficient data to determine image format");
}


_kernel_oserror *imgtrnsError(const char *st)
{
  static _kernel_oserror e;
  e.errnum=0;
  strcpy(e.errmess, st);

  return &e;
}

static flex_ptr export_ptr;
static int export_len;
static int export_pos;

_kernel_oserror *StartExport(flex_ptr source, int len, int offset)
{
    export_ptr=source;
    export_len=len;
    export_pos=offset;

    return NULL;
}

_kernel_oserror *Export(Image *this, char *buffer, int *len)
{
    if (*len>export_len)
    {
        memcpy(buffer, (char *)*export_ptr+export_pos, export_len);
        *len=export_len;
        export_len=0;
        export_pos+=export_len;
    }
    else
    {
        memcpy(buffer, (char *)*export_ptr+export_pos, *len);
        export_len-=*len;
        export_pos+=*len;
    }
    return NULL;
}

_kernel_oserror *EndExport(Image *this)
{
    return NULL;
}

static _kernel_oserror *ReadPixel(void *spr_ptr, int *spid, int x, int y,
                                  int *colour, int *tint)
{
    _kernel_oserror *e = NULL;
    int pal_size;
    int mask;

    /* Read pixel mask */
    e=_swix(OS_SpriteOp, _INR(0,4)|_OUT(5), 43+512, spr_ptr, spid, x, y, &mask);
    if (e)
        goto finish;

    if (mask==0)
    {
        *colour=-1;
        goto finish;
    }

    /* Read palette size*/
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(3), 37+512, spr_ptr, spid, -1, &pal_size);
    if (e)
        goto finish;

    if (pal_size == 256) /* Only if a 256 palette sprite */
    {
        *colour =
        ((char *) (((int *) ((char *) spid + spid[8]) +
        (spid[4] + 1)*(spid[5] - y)))) [spid[6]/8 + x];
        *tint = 0;
    }
    else
    {
        /*All other cases o k.*/
        e = _swix(OS_SpriteOp, _INR(0,4)|_OUTR(5,6), 41+512, spr_ptr, spid, x, y,
                                                    colour, tint);
        if (e)
            goto finish;
    }

finish:
    return e;
}


_kernel_oserror *BGCol(void *spr_ptr, int bpp, int *bgcol)
{
    int x,y;
    int *sphead;
    _kernel_oserror *e;
    char temp[16];
    int width, height, mode, palsize;
    int colour, tint;
    int *palette;
    unsigned int col_word;
    unsigned r=0, g=0, b=0;
    double r2=0, g2=0, b2=0;
    int rval, gval, bval;
    int n=0;
    int bg=*bgcol;
    double sr, sg, sb;
    double sd;

    /* Find first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, spr_ptr, temp, sizeof temp, 1);
    if (e)
        return e;

    /* Get pointer to it */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+24, spr_ptr, temp, &sphead);
    if (e)
        return e;

    /* Get width and height */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 512+40, spr_ptr, sphead,
                                                       &width, &height, &mode);
    if (e)
        return e;

    /* Get bpp */
    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 9, &bpp);
    if (e) return e;

    /* Check palette */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(3,4), 512+37, spr_ptr, sphead, -1,
                                                       &palsize, &palette);
    if (e) return e;

    if (bpp >= 4 || palsize < (1<<(1<<bpp)))
    {
        *bgcol=-2;
        return NULL;
    }

    for (x=0; x<width; x+=9)
        for (y=0; y<height; y+=9)
        {
            ReadPixel(spr_ptr, sphead, x, y, &colour, &tint);
            if (colour==-1)
                col_word=bg;
            else
                col_word=palette[colour*2];
            rval=(col_word & 0xFF00) >> 8;
            gval=(col_word & 0xFF0000) >> 16;
            bval=col_word >> 24;

            r+=rval; g+=gval; b+=bval;
            r2+=rval*rval; g2+=gval*gval; b2+=bval*bval;
            n++;
        }


    sr=sqrt(((double)r2-(double)r*(double)r/(double)n)/(double)n);
    sg=sqrt(((double)g2-(double)g*(double)g/(double)n)/(double)n);
    sb=sqrt(((double)b2-(double)b*(double)b/(double)n)/(double)n);

    sd=(2*sr+4*sg+sb)/7;

    if (sd<=32.0)
    {
        r/=n; g/=n; b/=n;

        col_word=b<<24 | g<<16 | r<<8;
    }
    else
        col_word=-1;

    *bgcol=col_word;

    return NULL;
}

int SpriteAreaSize(void *mode, int w, int h)
{
    int bpp;
    int rowwidthinbits;
    int rowwidthinwords;

    bpp = _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);

    rowwidthinbits = w<<bpp;
    rowwidthinwords = (rowwidthinbits+31)/32;
    return 16+44+rowwidthinwords*4*h;
}

_kernel_oserror *BGColSimple(Image *this, int *bgcol)
{
    return BGCol(this->private_data2, 3, bgcol);
}
