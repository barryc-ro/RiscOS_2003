/*---------------------------------------------------------------------------------------------------------*/
/* File:    c.gif_stream                                                                                   */
/* Purpose: GIF plotting routines                                                                          */
/* Author:  Richard Leggett (adapted from Kevin Bracey's original GIF image library code)                  */
/* History: 03-Feb-97: RML: Created by chopping the relevant sections from KB's GIF image library code.    */
/*                          The idea is to turn this code into a module which will make use of the         */
/*                          direct to screen plotting code being developed alongside. As a result, a       */
/*                          fair ammount of KB's code has been cut, output has been directed to the        */
/*                          renderer code, rather than to a sprite, and the 'Image' structure (from        */
/*                          imagetrans) has been abandoned.                                                */
/*          04-Feb-97: RML: Added interface routines which are more like what the module routines will be. */
/*          11-Feb-97: RML: Added some (temporary) code to try and access multiple images in animated GIFs */
/*                          This involves some completely new code to read in GIF headers, extensions etc. */
/*                          (ie. not KB's routines), but old code still used for non animated GIFs.        */
/*          12-Feb-97: RML: Animated GIF code correctly identifies images.                                 */
/*          14-Feb-97: RML: More animated GIF stuff.                                                       */
/*          20-Feb-97: RML: More animated GIF stuff.                                                       */
/*          06-Mar-97: RML: Tidied up error handling, made functions return _kernel_oserrors               */
/*          13-Mar-97: RML: Fixed some flexy problems (lost anchors etc.)                                  */
/*          18-Mar-97: RML: Fixed bug where flex can get confused if picture is deleted before it has      */
/*                          finished being fetched.                                                        */
/*          25-Mar-97: RML: Fixed a bug with mutable_mask (interlaced + transparent images)                */
/*          11-Apr-97: RML: Implemented gradual loading of animated GIFs, via the load->state variable     */
/*                          which defines which stage of the decoding a particular animation is at.        */
/*          15-Apr-97: RML: Improved error trapping.                                                       */
/*          22-Apr-97: RML: Properly merged together animated and still GIF code so they are transparent   */
/*                          to the gifstream's client (ie. the c.gif component)                            */
/*          24-Apr-97: RML: Corrected bug which corrupted sprite palette on mode changes.                  */
/*          09-May-97: RML: Tidied up, removed a few redundant routines.                                   */
/*          23-May-97: RML: If IMAGE_FAST flag set, then only get first frame of an animation.             */
/*          27-Aug-97: KJB: mutable_mask was being set erroneously (checking for load->transparent != 0    */
/*                          rather than != -1).                                                            */
/*          09-Sep-97: RML: Made use of flex_set_budge to avoid stack problems on pre-RPC                  */
/*                          machines.                                                                      */
/*          18-Sep-97: RML: Added flex_deferred_compaction in gifstream_plot.                              */
/*          22-Sep-97: RML: Fixed problem with npixels not being updated sometimes in lzw decoder, so      */
/*                          imagelib thinks image is corrupted.                                            */
/*          22-Sep-97: KJB: Copes with there being no clear code at the start of the LZW stream.           */
/*          23-Sep-97: KJB: Would fail big-time if the LZW minimum code size wasn't the same as the global */
/*                          colour map size.                                                               */
/*                          Would restrict colour values to the size of the global colour map, so if an    */
/*                          image in an animated GIF had 128 colours while the global map had 64 colours,  */
/*                          it would fail (although this was masked by the above bug - as such an image    */
/*                          would necessarily have a minimum code size > the global colour map size).      */
/*                          Reduced memory usage by 32K per stream by turning the Prefix array into        */
/*                          shorts, and Suffix and OutCode into chars.                                     */
/*                          Fixed spelling of "colour" in various places.                                  */
/*                          Added support for the number of repeats field in the Netscape looping          */
/*                          extension.                                                                     */
/*          07-Oct-97: KJB: Ensured unnecessary debug code not put in unless TRACE defined.                */
/*                          Adjust screen size of a GIF if the first image doesn't fit.                    */
/*          07-Oct-97: RML: The background colour provided to render_animate_new_frame is now a palette    */
/*                          entry and not a palette index.                                                 */
/*          21-Oct-97: KJB: Optimised various stuff in Render.                                             */
/*                          Ignore screen size for GIF87 files.                                            */
/*---------------------------------------------------------------------------------------------------------*/
/* To do :                                                                                                 */
/*     Can the other lzw routines be speeded up and have memory usage reduced? They're far more general    */
/*     purpose than these, and hence slower. Kind of ironic given that they're used for the direct         */
/*     plotting.                                                                                           */
/*---------------------------------------------------------------------------------------------------------*/


#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "kernel.h"
#include "swis.h"
#include "wimp.h"
#include "imagetrans.h"
#include "internal.h"
#include "defines.h"
#include "datastruct.h"
#include "gif_stream.h"
#include "sprite.h"
#include "flex.h"
#include "lzw_comp.h"
#include "lzw_decomp.h"
#include "render.h"
#include "rml_misc.h"

/*---------------------------------------------------------------------------------------------------------*/

#define SKIPBYTE (dataptr++)
#define NEXTBYTE (*dataptr++)
#define EXTENSION     0x21
#define IMAGESEP      0x2c
#define TRAILER       0x3b

#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define MaxPics 256

#define gifError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

#define NETSCAPE_ID 1

#define State_ReadGifSignature      1
#define State_ReadScreenDescriptor  2
#define State_ReadGlobalColourMap   3
#define State_InventGlobalColourMap 4
#define State_ReadExtensionBlock    5
#define State_ReadImageDescriptor   6
#define State_ReadLocalColourMap    7
#define State_PreImageData          8
#define State_NoMoreFrames          9
#define State_ReportWriteLine       10
#define State_ReadApplicationExt    11
#define State_ReadGraphicControlExt 12
#define State_ReadDataBlock         13
#define State_ReadImageData         14
#define State_EndImageData          15

#define Type_InternalLZW     1
#define Type_AnimatedSprites 2

/*---------------------------------------------------------------------------------------------------------*/

static const int EGApalette[16][3] = {
  {0,0,0},       {0,0,128},     {0,128,0},     {0,128,128},
  {128,0,0},     {128,0,128},   {128,128,0},   {200,200,200},
  {100,100,100}, {100,100,255}, {100,255,100}, {100,255,255},
  {255,100,100}, {255,100,255}, {255,255,100}, {255,255,255} };


typedef struct gif_loaddata
{
    int         BitOffset,		    /* Bit Offset of next code                    */
                XC, YC,		            /* Output X and Y coords of current pixel     */
                Pass,			    /* Used by output routine if interlaced pic   */
                BitsPerPixel,		    /* Bits per pixel, read from GIF header       */
                ColourMapSize,		    /* number of colours                          */
                Background,		    /* background colour                          */
                CodeSize,		    /* Code size, read from GIF header            */
                InitCodeSize,		    /* Starting code size, used during Clear      */
                Code,			    /* Value returned by ReadCode                 */
                MaxCode,		    /* limiting value for current code size       */
                ClearCode,		    /* GIF clear code                             */
                EOFCode,		    /* GIF end-of-information code                */
                CurCode, OldCode, InCode,   /* Decompressor variables                     */
                JustHadClearCode,           /* Last code was a clear code                 */
                FirstFree,		    /* First free code, generated per GIF spec    */
                FreeCode,		    /* Decompressor,next free slot in hash table  */
                FinChar,		    /* Decompressor variable                      */
                BitMask,		    /* current AND mask for data size             */
                ReadMask,		    /* Code AND mask for current code size        */
                Misc;                       /* miscellaneous bits (interlace, local cmap) */
    int         gif89;                      /* &5c                                        */
    boolean     Interlace, HasColourmap;
    int         state;
    byte       *origptr;
    int         aspect;
    const byte *dataptr, *dataend;
    int         bytes_so_far_in_section;
    byte        temp[320];                  /* 80  */
    byte        palette[256*3];             /* 180 */
    int         npixels, maxpixels;         /* 484 */
    byte       *ptr;                        /* 48C */
    int         transparent;
    int         readimagestate;
    int         loadinto;
    int         blocksize;                  /* 4A0 */
    short      *Prefix;                     /* Hash table used by decompressor */
    char       *Suffix;
    char       *OutCode;                    /* Output array used by the decompressor */

    /* Fields added to structure by RML */
    render_flags  flags;                      // Bitfield containing various flags (see. h.render)
    char         *spr_buff;                   // Pointer to single row sprite
    int           pn;                         // Pointer to current column in sprite
    int           last_row;                   // Last full row decompressed
    int           last_bounded;               // value of last_row when last bounding box returned
    int           width;                      // width (from Image)
    int           height;                     // height (from Image)
    int           render_handle;              // handle for render code
    int           substage;                   // used by the extension block decoding routines
    int           substage_size;              // used by the extension block decoding routines
    int           app_ext_id;                 // Last application extension ID read.
    int           last_full_frame;            // The last frame which has been fully processed.
    int           screen_width;               // Screen width (in GIF terms, not OS terms)
    int           screen_height;              // Screen height
    unsigned int  loops;                      // As specified in the "NETSCAPE2.0" extension
    int           current_frame;              // Current frame being decoded
    int           top;                        // Position in screen, offset from top
    int           left;                       // Position in screen, offset from left
    int           delay;                      // Delay before displaying next screen
    int           disposal;                   // Disposal method for this image (see GIF spec)
    int           image_bpp;                  // Bits per pixel of the current image

    FillerFunction *fill_fn;                  // Pointer to function to call to fill the image background
    void           *handle1;                  // Data to be passed to filler function
    int            *handle2;                  // Data to be passed to filler function

    char        local_pal[256*3];             // Local palette data
} GIFloaddata;

static GIFloaddata* store[MaxPics];           // Store of pointers to image data for each image
static int          gif_initialised;          // Set if gifstream_initialised has been called

#ifdef TRACE
static char         report_temp[255];         // Temporary - for debugging purposes.
#endif

/*------------------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_still_image(GIFloaddata *load);
static int              gifstream_ReadCode(GIFloaddata *load, int CodeSize, int ReadMask);
static void             gifstream_abandon_image(int handle);
static _kernel_oserror* gifstream_error(char *s);
static int              gifstream_valid_handle(int handle);
static void             gifstream_initialise(void);
static void             gifstream_add_palette(GIFloaddata *load);
static _kernel_oserror* gifstream_read_image_data(GIFloaddata *load, BBox *changed);
static _kernel_oserror* gifstream_read_gif_signature(GIFloaddata *load);
static _kernel_oserror* gifstream_read_screen_descriptor(GIFloaddata *load);
static _kernel_oserror* gifstream_read_global_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_invent_global_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_read_image_descriptor(GIFloaddata *load);
static _kernel_oserror* gifstream_read_local_colour_map(GIFloaddata *load);
static _kernel_oserror* gifstream_read_extension_block(GIFloaddata *load);
static _kernel_oserror* gifstream_read_application_extension(GIFloaddata *load);
static _kernel_oserror* gifstream_read_graphic_control_extension(GIFloaddata *load);
static _kernel_oserror* gifstream_read_data_block(GIFloaddata *load);
static _kernel_oserror* gifstream_pre_image_data(GIFloaddata *load, int frame);
static _kernel_oserror* gifstream_end_image_data(GIFloaddata *load);
static _kernel_oserror* gifstream_make_animation(GIFloaddata *load);
static _kernel_oserror* gifstream_animated_load(int handle, char *buffer, int size, BBox *changed);
static _kernel_oserror* gifstream_animated_plot(int handle, int x, int y, scale_factor scale);

#define copyline(to)  if (y+to < ymax) \
                      {memcpy(sptr+linesize*(y+to), sptr+linesize*y, linesize);\
                      if (mptr)\
                          memcpy(mptr+linesize*(y+to), mptr+linesize*y, linesize);}

/*------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * gifstream_begin                                                                            *
 *                                                                                            *
 * Called at the beginning of the load/fetching process for a GIF.                            *
 *                                                                                            *
 * In: flags            - as specified by imagetrans (currently, only bit 0 for IMAGE_FAST)   *
 *     return_gifhandle - pointer to integer to store this image's handle (identifier to be   *
 *                        used for aÌll future gifstream calls).                               *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *          return_gifhandle updated.                                                         *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_begin(int *return_gifhandle, int flags)
{
   int          i, n=-1;

   debug_print("    gifstream_begin");

   gifstream_initialise();

   /* Find a slot for the data */
   for (i=0; i<MaxPics; i++) {
     if (store[i]==0) n=i;
     if (n>=0) break;
   }

   if (n<0) return gifstream_error("Can't get an array slot for data.");

   /* Claim memory to store structure */
   store[n]=malloc(sizeof(GIFloaddata));
   if (!store[n]) return gifstream_error("Can't get memory for GIF structure.");

   /* Clear the whole structure */
   memset(store[n], 0, sizeof *store[n]);

   /* Get memory for various tables */
   if (!flex_alloc((flex_ptr) &store[n]->Prefix, 4097 *sizeof(short)))
   {
       free(store[n]);
       return gifstream_error("Can't get memory for prefix table.");
   }

   if (!flex_alloc((flex_ptr) &store[n]->Suffix, 4097 *sizeof(char)))
   {
       flex_free((flex_ptr) &store[n]->Prefix);
       free(store[n]);
       return gifstream_error("Can't get memory for suffix table.");
   }

   if (!flex_alloc((flex_ptr) &store[n]->OutCode, 4097 *sizeof(char)))
   {
       flex_free((flex_ptr) &store[n]->Prefix);
       flex_free((flex_ptr) &store[n]->Suffix);
       free(store[n]);
       return gifstream_error("Can't get memory for outcode table.");
   }

   /* Clear tables */
   memset(store[n]->Prefix, 0, sizeof(short)*4096);
   memset(store[n]->Suffix, 0, sizeof(char)*4096);
   memset(store[n]->OutCode, 0, sizeof(char)*4096);

   store[n]->transparent             = -1;
   store[n]->width                   = -1;
   store[n]->height                  = -1;
   store[n]->render_handle           = -1;
   store[n]->state                   = State_ReadGifSignature;
   store[n]->bytes_so_far_in_section = 0;
   store[n]->current_frame           = 0;
   store[n]->last_full_frame         = -1;
   store[n]->flags.render_type       = Type_InternalLZW;

   /* Set flags */
   store[n]->flags.image_fast          = 0;
   store[n]->flags.background          = 0;
   store[n]->flags.looping             = 0;
   store[n]->flags.client_stream_ended = 0;
   store[n]->flags.regen_tables        = 0;
   store[n]->flags.mutable_mask        = 0;
   store[n]->flags.load_ended          = 0;
   store[n]->flags.render_type         = Type_InternalLZW;
   store[n]->flags.lpb                 = 0;
   store[n]->flags.unused              = 0;

   if (flags && IMAGE_FAST) store[n]->flags.image_fast = 1;

   *return_gifhandle = n;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_initialise                                                                       *
 *                                                                                            *
 * Called to initialise the array of data structures.                                         *
 *--------------------------------------------------------------------------------------------*/

static void gifstream_initialise(void)
{
   int n;

   /* If already initialised, return */
   if (gif_initialised) return;

   /* Reset the store of GIFloddata structures */
   for (n=0; n<MaxPics; n++) store[n]=0;

   /* Set a flag to say we've initialised */
   gif_initialised=1;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_end                                                                              *
 *                                                                                            *
 * Called when all data has been fetched/loaded.                                              *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_end(int handle)
{
    _kernel_oserror *e = NULL;
    GIFloaddata     *load = store[handle];

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    if (load->flags.render_type == Type_AnimatedSprites)
    {
        if (!load->flags.client_stream_ended) gifstream_end_image_data(load);
        e=render_animate_end(load->render_handle);
        if (e) return e;
    }

    /* Free the tables used by the GIF decompressor */
    if (store[handle]->Prefix) flex_free((flex_ptr) &store[handle]->Prefix);
    if (store[handle]->Suffix) flex_free((flex_ptr) &store[handle]->Suffix);
    if (store[handle]->OutCode) flex_free((flex_ptr) &store[handle]->OutCode);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_delete                                                                           *
 *                                                                                            *
 * Called when an image is no longer required, removes all data associated with it.           *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_delete(int handle)
{
   _kernel_oserror *e;
   GIFloaddata     *load = store[handle];

   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;

   /* If gif end hasn't been called, do the stuff that it would do */
   if (store[handle]->Prefix)  flex_free((flex_ptr) &store[handle]->Prefix);
   if (store[handle]->Suffix)  flex_free((flex_ptr) &store[handle]->Suffix);
   if (store[handle]->OutCode) flex_free((flex_ptr) &store[handle]->OutCode);

   /* Tell c.render to delete it's data */
   if (load->flags.render_type==Type_InternalLZW) e=render_delete(load->render_handle);
   else e=render_animate_delete(load->render_handle);

   /* Free array entry */
   if (store[handle]) free(store[handle]);
   store[handle]=0;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_load                                                                             *
 *                                                                                            *
 * Called each time a block of data has been fetched/loaded, to decode a bit more of the      *
 * image.                                                                                     *
 *                                                                                            *
 * In: handle        - identifier for the image.                                              *
 *     buffer        - location of fetched data                                               *
 *     size          - bytes of data loaded/fetched                                           *
 *     changed       - pointer to bounding box to put details of which part of the image has  *
 *                     changed, once decoding of the data has happened.                       *
 *     return_width  - pointer to integer to store width of the image if read from file yet,  *
 *                     else -1.                                                               *
 *     return_height - pointer to integer to store height of the image if read from file yet, *
 *                     else -1.                                                               *
 *     return_mask   - value of mutable_mask, if calculated yet, else -1.                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *          return_width, return_height, return_mask updated.                                 *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_load(int handle, char *buffer, int size, BBox *changed,
                                int *return_width, int *return_height, int* return_mask, int* return_anim)
{
   _kernel_oserror *e;
   int              w,h;

   changed->xmin = changed->xmax = changed->ymin = changed->ymax = 0;

   /* If not a valid handle, return */
   if (!gifstream_valid_handle(handle)) return NULL;

   e=gifstream_animated_load(handle, buffer, size, changed);
   if (e) {
     gifstream_abandon_image(handle);
     return e;
   }

   w=-1; h=-1;
   if (store[handle]->width>0) {
     w=store[handle]->screen_width;
     h=store[handle]->screen_height;
   }

   if (store[handle]->flags.render_type==Type_AnimatedSprites)
       store[handle]->flags.mutable_mask = 0;

   *return_width  = w;
   *return_height = h;
   *return_mask   = store[handle]->flags.mutable_mask;
   *return_anim   = store[handle]->flags.render_type - 1;

   return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_plot                                                                             *
 *                                                                                            *
 * Called to plot the image to the screen.                                                    *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *     x      - x co-ordinate to plot at.                                                     *
 *     y      - y co-ordinate to plot at.                                                     *
 *     scale  - scaling structure holding x and y divisors/multipliers                        *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_plot(int handle, int x, int y, scale_factor scale)
{
    GIFloaddata     *load = store[handle];
    _kernel_oserror *e=NULL;
    int              old_budge_state, old_deferred_state;

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    /* Set budge state and deferred compaction state */
    old_budge_state=flex_set_budge(0);
    old_deferred_state = flex_set_deferred_compaction(0);

    /* Plot the image */
    if (load->flags.render_type==Type_InternalLZW) e=render_whole_scaled(load->render_handle,x,y,scale);
    else e=gifstream_animated_plot(handle, x, y, scale);
    if (e) gifstream_abandon_image(handle);

    /* Reset budge and deferred compaction state to their old values */
    flex_set_deferred_compaction(old_deferred_state);
    flex_set_budge(old_budge_state);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_add_palette                                                                      *
 *                                                                                            *
 * Copies the image's palette into the image's sprite's palette.                              *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *--------------------------------------------------------------------------------------------*/

void gifstream_add_palette(GIFloaddata *load)
{
   sprite_area   *spr        = (sprite_area*) render_return_sprite_address(load->render_handle);
   sprite_header *spr_header = (sprite_header*) ((char*)spr + sizeof(sprite_area));
   int            i;

   report_value("Adding palette, colourmap ", load->HasColourmap);

   for (i=0; i<256; i++) {
     if (load->HasColourmap)
        spr_header->palette[i*2] = spr_header->palette[i*2+1] = (load->local_pal[i*3]<<8)+
                                                                (load->local_pal[i*3+1]<<16)+
                                                                (load->local_pal[i*3+2]<<24);
     else
        spr_header->palette[i*2] = spr_header->palette[i*2+1] = (load->palette[i*3]<<8)+
                                                                (load->palette[i*3+1]<<16)+
                                                                (load->palette[i*3+2]<<24);
   }
}



_kernel_oserror* gifstream_mode_change(int handle)
{
   GIFloaddata     *load = store[handle];
   _kernel_oserror *e=NULL;

   if (load->flags.render_type==Type_InternalLZW) e=render_mode_change(load->render_handle);
   else e=render_animate_mode_change(load->render_handle);
   if (e) gifstream_abandon_image(handle);

   return e;
}


/*---------------------------------------------------------------------------------------------------------------*/
/*                                                Animated GIF stuff                                             */
/*---------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * gifstream_need_redraw                                                                      *
 *                                                                                            *
 * Checks if a specified animation needs redrawing (due to frame having changed).             *
 *                                                                                            *
 * In: handle - identifier for this animation.                                                *
 *                                                                                            *
 * Returns: 1 if redraw needed, else 0.                                                       *
 *--------------------------------------------------------------------------------------------*/

int gifstream_need_redraw(int handle, BBox *changed)
{
    GIFloaddata *load = store[handle];

    if (load->flags.render_type==Type_InternalLZW) return 1;

    return render_animate_need_redraw(store[handle]->render_handle, changed);
}


/*--------------------------------------------------------------------------------------------*
 * gif_animated_load                                                                          *
 *                                                                                            *
 * Called when some data has been loaded/fetched, to decode it.                               *
 *                                                                                            *
 * In: handle  - identifier for this animation.                                               *
 *     buffer  - pointer to data.                                                             *
 *     size    - size of data.                                                                *
 *     changed - pointer to bounding box to put details of the changed area                   *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_animated_load(int handle, char *buffer, int size, BBox *changed)
{
    _kernel_oserror *e=NULL;
    GIFloaddata     *load = store[handle];
    int              more_frames=1;
    int              oldstate;

    report_string("gifstream_animated_load");

    load->dataptr = (byte*)buffer;
    load->origptr = (byte*)buffer;
    load->dataend = (byte*)buffer + size;

    while ((load->dataptr < load->dataend) && (!e) && (more_frames))
    {
        switch (load->state)
        {
            case State_ReadGifSignature:
                e=gifstream_read_gif_signature(load);
                break;
            case State_ReadScreenDescriptor:
                e=gifstream_read_screen_descriptor(load);
                break;
            case State_ReadGlobalColourMap:
                e=gifstream_read_global_colour_map(load);
                break;
            case State_InventGlobalColourMap:
                e=gifstream_invent_global_colour_map(load);
                break;
            case State_ReportWriteLine:
                report_string("--------------------------------------------------------------------------------");
                report_value("frame", load->current_frame); report_string("");
                load->state=State_ReadExtensionBlock;
                break;
            case State_ReadExtensionBlock:
                e=gifstream_read_extension_block(load);
                break;
            case State_ReadApplicationExt:
               e=gifstream_read_application_extension(load);
               break;
            case State_ReadGraphicControlExt:
               e=gifstream_read_graphic_control_extension(load);
               break;
            case State_ReadDataBlock:
               e=gifstream_read_data_block(load);
               break;
            case State_ReadImageDescriptor:
               e=gifstream_read_image_descriptor(load);
               break;
            case State_ReadLocalColourMap:
               e=gifstream_read_local_colour_map(load);
               break;
            case State_PreImageData:
               e=gifstream_pre_image_data(load, load->current_frame);
               break;
            case State_ReadImageData:
               oldstate=flex_set_budge(0);
               e=gifstream_read_image_data(load, changed);
               flex_set_budge(oldstate);
               break;
            case State_EndImageData:
               e=gifstream_end_image_data(load);
               break;
            case State_NoMoreFrames:
               more_frames=0;
               break;
            default:
               report_value("\n\nError - State ",load->state);
               _swi(OS_WriteI + 4, 0);
               _swi(OS_WriteI + 26, 0);
               printf("Error in gif_stream - strange state %d\n",load->state);
               exit(0);
               break;
        }
    }

#if ReportErrorsToScreen
    if (e)
    {
        _swi(OS_WriteI + 4, 0);
        _swi(OS_WriteI + 26, 0);
        printf("gifstream_animated_load error %s\n",e->errmess);
    }
#endif

    if (e) gifstream_abandon_image(handle);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_gif_signature                                                               *
 *                                                                                            *
 * Reads the GIF signature from the datastream.                                               *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_gif_signature(GIFloaddata *load)
{
    int len = min(6-load->bytes_so_far_in_section, load->dataend-load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 6)
    {
        if      (strncmp(load->temp,"GIF89a",6)==0) load->gif89 = 1;
        else if (strncmp(load->temp,"GIF87a",6)==0) load->gif89 = 0;
        else return gifstream_error("Not a GIF file.");

        load->state = State_ReadScreenDescriptor;
        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_screen_descriptor                                                           *
 *                                                                                            *
 * Reads the GIF screen descriptor from the datastream.                                       *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_screen_descriptor(GIFloaddata *load)
{
    const byte      *dataptr=load->dataptr;
    int              crpixel;
    int              len = min(7 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 7)
    {
        dataptr=load->temp;

        /*
         * Only use these for GIF89 images - there are lots of GIF87 images with bogus
         * screen sizes. The later code to check that the screen is as large as the
         * first image will sort it out.
         */
        if (load->gif89)
        {
            load->screen_width  = dataptr[0] + (dataptr[1] * 256);
            load->screen_height = dataptr[2] + (dataptr[3] * 256);
        }
        crpixel             = dataptr[4];
        load->Background    = dataptr[5];
        load->aspect        = dataptr[6];

        load->BitsPerPixel  = (crpixel & 7) + 1;
        load->ColourMapSize = 1 << load->BitsPerPixel;
        load->delay         = -1;

        report_string("\nScreen descriptor");
        report_value ("  screen_x  ", load->screen_width);
        report_value ("  screen_y  ", load->screen_height);
        report_value ("  background", load->Background);

        if (crpixel && 128) load->state = State_ReadGlobalColourMap;
        else load->state = State_InventGlobalColourMap;

        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_global_colour_map                                                           *
 *                                                                                            *
 * Reads the GIF global colour map from the datastream.                                       *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_global_colour_map(GIFloaddata *load)
{
    int         size_of_map = load->ColourMapSize * 3;
    int         len         = min(size_of_map - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->palette + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == size_of_map)
    {
        report_string("Reading Global Colour Table");
        load->state = State_ReportWriteLine;
        load->bytes_so_far_in_section=0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_invent_global_colour_map                                                         *
 *                                                                                            *
 * For images without a defined global colourmap, creates a standard EGA palette.             *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_invent_global_colour_map(GIFloaddata *load)
{
    int i, to;

    to = 1 << load->BitsPerPixel;

    report_string("Global palette is standard EGA palette");
    for (i=0; i<to; i++)
    {
        load->palette[i*3]   = EGApalette[i&15][0];
        load->palette[i*3+1] = EGApalette[i&15][1];
        load->palette[i*3+2] = EGApalette[i&15][2];
    }

    load->Background = -1;
    load->state = State_ReportWriteLine;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_image_descriptor                                                            *
 *                                                                                            *
 * Reads an image descriptor from the datastream.                                             *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_image_descriptor(GIFloaddata *load)
{
    _kernel_oserror *e;
    const byte      *dataptr = load->dataptr;
    int              len = min(10 - load->bytes_so_far_in_section, load->dataend - load->dataptr);
    int              comma;

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 10)
    {
        dataptr=load->temp;

        if (dataptr[0]==59)
        {
            load->state = State_NoMoreFrames;
            return NULL;
        }

        /* If this is the second frame, then the render needs to be told that we're now doing an animation */
        if (load->current_frame==1)
        {
            e=gifstream_make_animation(load);
            if (e) return e;
        }

        if (dataptr[0]!=44)
        {
            report_string("*** WARNING - Corrupt GIF file ***");
            load->state = State_NoMoreFrames;
            return NULL;
        }

        comma        = dataptr[0];
        load->left   = dataptr[1] + (dataptr[2] * 256);
        load->top    = dataptr[3] + (dataptr[4] * 256);
        load->width  = dataptr[5] + (dataptr[6] * 256);
        load->height = dataptr[7] + (dataptr[8] * 256);
        load->Misc   = dataptr[9];

        if (load->current_frame == 0)
        {
            if (load->flags.image_fast)
            {
                load->screen_width = load->width;
                load->screen_height = load->height;
            }
            else
            {
                if (load->left + load->width > load->screen_width)
                    load->screen_width = load->left + load->width;

                if (load->top + load->height > load->screen_height)
                    load->screen_height = load->top + load->height;
            }
        }

        load->image_bpp    = (load->Misc & 7) +1;
        load->HasColourmap = load->Misc & 128;
        load->Interlace    = load->Misc & 64;

        if (load->Interlace && (load->transparent!=-1)) load->flags.mutable_mask=true;

        report_string("Read image descriptor");
        report_value("  comma          ",comma);
        report_value("  left           ",load->left);
        report_value("  top            ",load->top);
        report_value("  width          ",load->width);
        report_value("  height         ",load->height);
        report_value("  load->Misc     ",load->Misc);
        report_value("  colourmap      ",load->HasColourmap);
        report_value("  image bpp      ",load->image_bpp);

        if (load->HasColourmap) load->state = State_ReadLocalColourMap;
        else load->state = State_PreImageData;

        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_local_colour_map                                                            *
 *                                                                                            *
 * Reads a local colour map from the datastream.                                              *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_local_colour_map(GIFloaddata *load)
{
    int size        = 1<<load->image_bpp;
    int size_of_map = size * 3;
    int len         = min(size_of_map - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->local_pal + load->bytes_so_far_in_section, load->dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == size_of_map)
    {
        report_string("Reading local colour map");
        load->state = State_PreImageData;
        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_extension_block                                                             *
 *                                                                                            *
 * Reads an extension block from the datastream.                                              *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_extension_block(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         introducer, code;
    int         len = min(2 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 2)
    {
        dataptr=load->temp;

        introducer = *dataptr++;
        code       = *dataptr++;

        if (introducer!=33)
        {
            load->state = State_ReadImageDescriptor;
            return NULL;
        }

        report_value("Reading extension",code);

        if      (code==0xFF) load->state = State_ReadApplicationExt;    /* Application extension     */
        else if (code==0xF9) load->state = State_ReadGraphicControlExt; /* Graphic control extension */
        else if (code==0xFE) load->state = State_ReadDataBlock;         /* Comment extension         */
        else if (code==0x01) load->state = State_ReadDataBlock;         /* Plain text extension      */
        else                 load->state = State_ReadDataBlock;         /* Unrecognised extension    */

        load->substage = 0;
        load->bytes_so_far_in_section = 0;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_application_extension                                                       *
 *                                                                                            *
 * Reads an application extension block from the datastream.                                  *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_application_extension(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         size, len;
    char        authent[3];
    char        id[8];

    /* Reading an application extension is two stages:           */
    /*  - First, a header block with the application identifier. */
    /*  - Then, any number of data blocks.                       */

    /* The header block size isn't necessarily 12!!! (Thanks Adobe) */
    if (load->substage == 0)
    {
        load->substage_size = *load->dataptr++;
        load->bytes_so_far_in_section = 0;
        load->substage = 1;
    }

    /* So, if we're at the first stage, then we need a 12 byte header block */
    else if (load->substage == 1)
    {
        len = min(load->substage_size - load->bytes_so_far_in_section, load->dataend - load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        /* If we've managed to get all 12 bytes, then process the information */
        if (load->bytes_so_far_in_section == load->substage_size)
        {
            report_string("  Reading application extension");
            dataptr = load->temp;
            load->app_ext_id = 0;
            if (load->substage_size >= 11)
            {
                strncpy(id,      dataptr, 8); dataptr+=8;
                strncpy(authent, dataptr, 3); dataptr+=3;
                if (strncmp(id,"NETSCAPE",8)==0)
                    load->app_ext_id=NETSCAPE_ID;
            }
            #ifdef TRACE
            sprintf(report_temp,"  id %s",id); report_string(report_temp);
            #endif
            load->substage = 2;
            load->bytes_so_far_in_section = 0;
        }
    }

    /* For the later stages, we read in the data blocks checking for any extensions we */
    /* recognise - currently only the Netscape one which makes an animation repeat.    */
    /* This block reading stage is further divided into two stages - the first reads   */
    /* the size of the block, the second actually reads the block data. It seems quite */
    /* an involved process, but this is necessary because of the gradual fetching that */
    /* processes involved.                                                             */

    /* So, to read the block size */
    else if (load->substage == 2)
    {
        load->substage      = 3;
        load->substage_size = load->dataptr[0];
        load->dataptr++;

        report_value("  blocksize",load->substage_size);

        if (load->substage_size==0)
        {
            load->bytes_so_far_in_section=0;
            load->state = State_ReadExtensionBlock;
            report_string("  end block");
            return NULL;
        }
    }

    /* Now, to read the block data */
    else
    {
        size = load->substage_size;

        len = min(size - load->bytes_so_far_in_section, load->dataend-load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        if (load->bytes_so_far_in_section == size)
        {
            dataptr = load->temp;
            load->bytes_so_far_in_section = 0;
            load->substage = 2;

            if ((load->app_ext_id==NETSCAPE_ID) && (size==3) && (*dataptr==1))
            {
                load->flags.looping = 1;
                load->loops         = dataptr[1] | dataptr[2] << 8;

                report_string("NETSCAPE looping extension");
            }
        }
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_graphic_control_extension                                                   *
 *                                                                                            *
 * Reads a graphic control extension block from the datastream.                               *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_graphic_control_extension(GIFloaddata *load)
{
    _kernel_oserror *e;
    const byte      *dataptr = load->dataptr;
    int              blocksize, stuff, terminate, use_transparency;
    int              len = min(6 - load->bytes_so_far_in_section, load->dataend - load->dataptr);

    memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
    load->dataptr+=len;
    load->bytes_so_far_in_section+=len;

    if (load->bytes_so_far_in_section == 6)
    {
        dataptr = load->temp;

        /* If this is the second frame, then the render needs to be told that we're now doing an animation */
        if (load->current_frame==1)
        {
            e=gifstream_make_animation(load);
            if (e) return e;
        }

        report_string("Reading graphic control extension");

        load->bytes_so_far_in_section = 0;
        load->state = State_ReadExtensionBlock;

        if (load->delay>-1)
        {
            report_string("Another graphic control extension - ignoring.");
            dataptr+=6;
            return NULL;
        }

        blocksize         = dataptr[0];
        stuff             = dataptr[1];
        load->delay       = dataptr[2] + (dataptr[3] * 256);
        load->transparent = dataptr[4];
        terminate         = dataptr[5];
        load->disposal    = (stuff & 0x1C) >>2;
        use_transparency  = (stuff & 1);

        report_value("  blocksize",blocksize);
        report_value("  stuff    ",stuff);
        report_value("  delay    ",load->delay);
        report_value("  transp   ",load->transparent);
        report_value("  terminate",terminate);
        report_value("  disposal ",load->disposal);
        report_value("  use trans",use_transparency);

        if (!use_transparency) load->transparent=-1;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_data_block                                                                  *
 *                                                                                            *
 * Reads a data block and ignores the data (eg. for a comment extension)                      *
 *                                                                                            *
 * In: load - pointer to GIFloaddata structure which contains information about the GIF file  *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_read_data_block(GIFloaddata *load)
{
    const byte* dataptr = load->dataptr;
    int         size;
    int         len;

    /* The process of reading a data block is divided into two substages - the first reads the */
    /* size of the block, the next reads the block. This is necessary because of the gradual   */
    /* fetching processes involved.                                                            */

    /* So, firstly, to read the block size */
    if (load->substage == 0)
    {
        load->substage      = 1;
        load->substage_size = load->dataptr[0];

        report_value("  substage size ",load->substage_size);

        load->dataptr++;

        if (load->substage_size==0)
        {
            load->bytes_so_far_in_section=0;
            load->state = State_ReadExtensionBlock;
            return NULL;
        }
    }

    /* Now to read the block data (and ignore it!) */
    else
    {
        size = load->substage_size;

        len = min(size - load->bytes_so_far_in_section, load->dataend - load->dataptr);
        memcpy(load->temp + load->bytes_so_far_in_section, dataptr, len);
        load->dataptr+=len;
        load->bytes_so_far_in_section+=len;

        if (load->bytes_so_far_in_section == size)
        {
            load->bytes_so_far_in_section = 0;
            load->substage = 0;
        }
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_pre_image_data                                                                   *
 *                                                                                            *
 * Reads an image from the datastream and sends it to the render code                         *
 *                                                                                            *
 * In: load  - pointer to GIFloaddata structure which contains information about the GIF file *
 *     frame - the number of the frame we're reading.                                         *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_pre_image_data(GIFloaddata *load, int frame)
{
    _kernel_oserror *e;
    frame_str        fr;
    int             *put_palette;
    int              n, oldstate, background_entry;

    frame=frame;

    /* Reset the tables in preperation */
    memset(load->Prefix, 0, sizeof(short)*4096);
    memset(load->Suffix, 0, sizeof(char)*4096);
    memset(load->OutCode, 0, sizeof(char)*4096);
    load->BitOffset=0;

    load->CodeSize = *load->dataptr++;

    /* Setup some variables for the decompression */
    if (load->Interlace && load->transparent != -1) load->flags.mutable_mask=true;

    load->ClearCode = (1 << load->CodeSize);
    load->EOFCode   = load->ClearCode+1;
    load->FreeCode  = load->FirstFree = load->ClearCode + 2;
    load->CodeSize++;

    if (load->HasColourmap)
        load->BitMask = (1 << load->image_bpp) - 1;
    else
        load->BitMask = load->ColourMapSize - 1;

    load->InitCodeSize              = load->CodeSize;
    load->MaxCode                   = (1 << load->CodeSize);
    load->ReadMask                  = load->MaxCode - 1;
    load->JustHadClearCode          = 1;
    load->npixels                   = 0;
    load->maxpixels                 = load->width * load->height;
    load->readimagestate            = 0;
    load->loadinto                  = 0;
    load->bytes_so_far_in_section   = 0;
    load->XC                        = 0;
    load->YC                        = 0;
    load->flags.client_stream_ended = 0;

    fr.delay        = load->delay;
    fr.width        = load->width;
    fr.height       = load->height;
    fr.left         = load->left;
    fr.top          = load->top;
    fr.transparency = load->transparent;
    fr.disposal     = load->disposal;
    fr.interlace    = load->Interlace;

    if (load->flags.render_type==Type_InternalLZW)
    {
        int handle;

        e=render_start('G', load->width, load->height, load->Interlace,
                          load->transparent, load->flags, &handle, &load->spr_buff);
        if (e) return e;
        load->render_handle = handle;
    }
    else
    {
        oldstate=flex_set_budge(0);
        background_entry = (load->palette[load->Background*3]   << 8)+
                           (load->palette[load->Background*3+1] << 16)+
                           (load->palette[load->Background*3+2] << 24);
        e=render_animate_new_frame(load->render_handle, fr, background_entry, &load->spr_buff);
        flex_set_budge(oldstate);
        if (e) return e;
    }

    load->pn = 0;

    /* Supply render with the local palette */
    oldstate=flex_set_budge(0);
    if (load->flags.render_type==Type_AnimatedSprites)
    {
        put_palette = (int*)render_animate_add_local_palette(load->render_handle, 8);

        for (n=0; n<256; n++)
        {
            if (load->HasColourmap)
                put_palette[n*2] = put_palette[n*2+1] = (load->local_pal[n*3]  <<8)+
                                                        (load->local_pal[n*3+1]<<16)+
                                                        (load->local_pal[n*3+2]<<24);
            else
                put_palette[n*2] = put_palette[n*2+1] = (load->palette[n*3]  <<8)+
                                                        (load->palette[n*3+1]<<16)+
                                                        (load->palette[n*3+2]<<24);
        }
    }
    flex_set_budge(oldstate);

    report_string("About to decode...");

    load->state = State_ReadImageData;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_end_image_data                                                                   *
 *                                                                                            *
 * Ends reading of the image data and tells render that the frame is finished.                *
 *                                                                                            *
 * In: load  - pointer to GIFloaddata structure which contains information about the GIF file *
 *     frame - the number of the frame we're reading.                                         *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_end_image_data(GIFloaddata *load)
{
    _kernel_oserror *e;
    int              oldstate;

    if (load->flags.render_type==Type_InternalLZW)
    {
        oldstate=flex_set_budge(0);
        e=render_end(load->render_handle);
        flex_set_budge(oldstate);
        if (e) return e;
    }
    else
    {
        oldstate=flex_set_budge(0);
        e=render_animate_done_frame(load->render_handle);
        flex_set_budge(oldstate);
        load->delay=-1;
        if (e) return e;
    }

    load->last_full_frame++;
    load->dataptr++;
    load->state = State_ReportWriteLine;
    load->current_frame++;
    load->bytes_so_far_in_section = 0;
    load->flags.client_stream_ended=1;

    if (load->npixels!=load->maxpixels)
    {
        //printf("Corrupt frame!");
        if (load->flags.render_type==Type_AnimatedSprites) render_mark_corrupt_frame(load->render_handle);
        //_swi(OS_ReadC,0);
    }

    if (load->flags.image_fast) load->state = State_NoMoreFrames;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_image_data                                                                  *
 *                                                                                            *
 * Decodes some more image data and passes it to the still (inanimate) part of render.        *
 *                                                                                            *
 * In: load    - pointer to GIFloaddata structure which contains information about the file   *
 *     changed - pointer to bounding box to store area of the 'screen' which is changed.      *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror *gifstream_read_image_data(GIFloaddata *load, BBox *changed)
{
    _kernel_oserror *e;
    char     *spr_buff;
    const int ClearCode = load->ClearCode, EOFCode=load->EOFCode;
    const int BitMask = load->BitMask;
    int       i;
    int       len, now_to;
    int       CodeSize = load->CodeSize, MaxCode=load->MaxCode;
    int       ReadMask = load->ReadMask, FreeCode=load->FreeCode;
    int       CurCode = load->CurCode, OldCode=load->OldCode;
    int       FinChar = load->FinChar;
    int       npixels = load->npixels, InCode=load->InCode, Code=load->Code;
    int       OutCount=0;

    if (load->flags.render_type==Type_InternalLZW)
    {
        e = gifstream_read_still_image(load);
        now_to = load->last_row;
        render_changed(load->render_handle, load->last_bounded, now_to, load->Interlace, changed);
        load->last_bounded = now_to;
        return e;
    }

    spr_buff = load->spr_buff = render_animate_return_spr_address(load->render_handle);

restart:
    if (load->bytes_so_far_in_section == 0)
    {
        /* Need to start a new block */
        load->bytes_so_far_in_section = *load->dataptr++;

        if (load->bytes_so_far_in_section == 0)
        {
            load->dataptr--;
            load->npixels = npixels;  /* So this can be inspected by gifstream_end_image_data() */
            load->state = State_EndImageData;
            return NULL;
        }
        if (load->dataptr==load->dataend)
            goto exit;
    }

    len=min(load->dataend-load->dataptr, load->bytes_so_far_in_section);

    memcpy(load->temp+load->loadinto, load->dataptr, len);

    load->blocksize=len+load->loadinto;

    load->dataptr+=len;
    load->bytes_so_far_in_section-=len;

    /* Right, we've got some more of the block in temp */

    //picptr=(byte *)this->private_data2+this->private_data2[12] + 16
    //                  + load->YC * load->spritewidth + load->XC;

    switch (load->readimagestate)
    {
        case 2:
            goto stage2;
        case 3:
            goto stage3;
    }

  /* Decompress the file, continuing until you see the GIF EOF code.
   * One obvious enhancement is to add checking for corrupt files here.
   */

stage3:
    Code = gifstream_ReadCode(load, CodeSize, ReadMask);

    if (Code==-1)
    {
        load->readimagestate=3;
        if (load->dataptr < load->dataend)
            goto restart;
        else
            goto exit;
    }


    while (Code != EOFCode)
    {
        /* Clear code sets everything back to its initial value, then reads the
         * immediately subsequent code as uncompressed data.
         */

        if (Code == ClearCode)
        {
            CodeSize = load->InitCodeSize;
            MaxCode = (1 << CodeSize);
            ReadMask = MaxCode - 1;
            FreeCode = load->FirstFree;
            load->JustHadClearCode = 1;
        }
        else
        {
            /* If not a clear code, must be data: save same as CurCode and InCode */

            /* if we're at maxcode and didn't get a clear, stop loading */
            if (FreeCode>=4096)
                return gifError("freecode blew up");

            CurCode = InCode = Code;

            if (!load->JustHadClearCode)
            {

                /* If greater or equal to FreeCode, not in the hash table yet;
                 * repeat the last character decoded
                 */

                if (CurCode >= FreeCode)
                {
    	            CurCode = OldCode;
    	            if (OutCount > 4096)
    	                return gifError("outcount1 blew up");
    	            load->OutCode[OutCount++] = FinChar;
                }

                /* Unless this code is raw data, pursue the chain pointed to by CurCode
                 * through the hash table to its end; each code in the chain puts its
                 * associated output code on the output queue.
                 */

                while (CurCode > EOFCode)
                {
    	            if (OutCount > 4096) break;   /* corrupt file */
    	            load->OutCode[OutCount++] = load->Suffix[CurCode];
    	            CurCode = load->Prefix[CurCode];
                }

                if (OutCount > 4096) { return gifError("outcount blew up"); }

            }

            /* The last code in the chain is treated as raw data. */

            FinChar = CurCode & BitMask;
            load->OutCode[OutCount++] = FinChar;

            /* Now we put the data out to the Output routine.
             * It's been stacked LIFO, so deal with it that way...
             */

            /* safety thing:  prevent exceeding range of 'pic8' */
            if (npixels + OutCount > load->maxpixels)
                OutCount = load->maxpixels-npixels;

            npixels += OutCount;

            for (i=OutCount-1; i>=0; i--)
            {
                // *picptr = load->OutCode[i];

                spr_buff[load->pn++] = load->OutCode[i];

                //putpixel(load, load->OutCode[i]);
                //if (load->OutCode[i]==transparent) spr_mask[(load->pn)-1]=0;
                //else spr_mask[(load->pn)-1]=255;

                if (++load->XC == load->width) {
                  load->spr_buff = render_animate_row(load->render_handle);
                  spr_buff = load->spr_buff;
                  load->pn = 0;
                  load->XC=0;
                  load->YC++;
                }

                //if (transparent >= 0 && spr_buff[load->pn] != transparent)
                //  spr_mask[load->pn-1]=255;
                //else spr_buff[load->pn-1]=5; //spr_mask[load->pn-1]=0;
                //    *(picptr+load->maskoffset)=255;
                //picptr++;
                //if (++load->XC == this->width)
                //{
                //    load->XC=0;
                //    load->YC++;
                //    picptr+=load->spritewidth-this->width;
                //}
            }

            OutCount = 0;

            /* Build the hash table on-the-fly. No table is stored in the file. */

            if (load->JustHadClearCode)
                load->JustHadClearCode = 0;
            else
            {
                load->Prefix[FreeCode] = OldCode;
                load->Suffix[FreeCode] = FinChar;

                /* Point to the next slot in the table.  If we exceed the current
                 * MaxCode value, increment the code size unless it's already 12.  If it
                 * is, do nothing: the next code decompressed better be CLEAR
                 */

                if (++FreeCode >= MaxCode)
                {
    	            if (CodeSize < 12)
    	            {
    	                CodeSize++;
    	                MaxCode *= 2;
    	                ReadMask = (1 << CodeSize) - 1;
    	            }
                }
            }
            OldCode = InCode;
        }
stage2:
        Code = gifstream_ReadCode(load, CodeSize, ReadMask);

        if (Code == -1)
        {
            load->readimagestate=2;
            if (load->dataptr < load->dataend)
                goto restart;
            else
                goto exit;
        }
        if (npixels >= load->maxpixels) break;
    }
    load->state = State_EndImageData;

exit:

    load->CodeSize=CodeSize; load->MaxCode=MaxCode;
    load->ReadMask=ReadMask; load->FreeCode=FreeCode;
    load->npixels=npixels;
    load->OldCode=OldCode;
    load->FinChar=FinChar;

    load->CurCode=CurCode;
    load->InCode=InCode; load->Code=Code;

    report_value("  XC       ",load->XC);
    report_value("  YC       ",load->YC);
    report_value("  npixels  ",load->npixels);
    report_value("  maxpixels",load->maxpixels);

    render_animate_changed(load->render_handle, changed);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_read_still_image                                                                 *
 *                                                                                            *
 * Continues the decoding of the image data (not the header) - called by gifstream_load.      *
 *                                                                                            *
 * In: load    - structure containing details about the current image.                        *
 *                                                                                            *
 * Returns: Error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror *gifstream_read_still_image(GIFloaddata *load)
{
    _kernel_oserror *e;
    char     *spr_buff;
    int       i;
    int       len;
    int       CodeSize = load->CodeSize, MaxCode=load->MaxCode;
    int       ReadMask = load->ReadMask, FreeCode=load->FreeCode;
    int       CurCode  = load->CurCode, OldCode=load->OldCode;
    int       FinChar  = load->FinChar;
    int       npixels  = load->npixels, InCode=load->InCode, Code=load->Code;
    int       OutCount = 0;
    const int ClearCode = load->ClearCode, EOFCode=load->EOFCode;
    const int BitMask=load->BitMask;

    load->spr_buff=render_return_address_for_rgb_data(load->render_handle);
    spr_buff=load->spr_buff;

    if (npixels==0) gifstream_add_palette(load);

restart:
    if (load->bytes_so_far_in_section == 0)
    {
        /* Need to start a new block */
        load->bytes_so_far_in_section = *load->dataptr++;

        if (load->bytes_so_far_in_section == 0)
        {
            load->dataptr--;
            load->npixels = npixels;  /* So this can be inspected by gifstream_end_image_data() */
            load->state = State_EndImageData;
            return NULL;
        }
        if (load->dataptr==load->dataend)
            goto exit;
    }

    len=min(load->dataend-load->dataptr, load->bytes_so_far_in_section);

    memcpy(load->temp+load->loadinto, load->dataptr, len);

    load->blocksize=len+load->loadinto;

    load->dataptr+=len;
    load->bytes_so_far_in_section-=len;

    /* Right, we've got some more of the block in temp */

    //picptr=(byte *)this->private_data2+this->private_data2[12] + 16
    //                  + load->YC * load->spritewidth + load->XC;

    switch (load->readimagestate)
    {
        case 2:
            goto stage2;
        case 3:
            goto stage3;
    }

  /* Decompress the file, continuing until you see the GIF EOF code.
   * One obvious enhancement is to add checking for corrupt files here.
   */

stage3:
    Code = gifstream_ReadCode(load, CodeSize, ReadMask);

    if (Code==-1)
    {
        load->readimagestate=3;
        if (load->dataptr < load->dataend)
            goto restart;
        else
            goto exit;
    }


    while (Code != EOFCode)
    {
        /* Clear code sets everything back to its initial value, then reads the
         * immediately subsequent code as uncompressed data.
         */

        if (Code == ClearCode)
        {
            CodeSize = load->InitCodeSize;
            MaxCode = (1 << CodeSize);
            ReadMask = MaxCode - 1;
            FreeCode = load->FirstFree;
            load->JustHadClearCode = 1;
        }
        else
        {
            /* If not a clear code, must be data: save same as CurCode and InCode */

            /* if we're at maxcode and didn't get a clear, stop loading */
            if (FreeCode>=4096)
                return gifError("freecode blew up");

            CurCode = InCode = Code;

            if (!load->JustHadClearCode)
            {

                /* If greater or equal to FreeCode, not in the hash table yet;
                 * repeat the last character decoded
                 */

                if (CurCode >= FreeCode)
                {
    	            CurCode = OldCode;
    	            if (OutCount > 4096)
    	                return gifError("outcount1 blew up");
    	            load->OutCode[OutCount++] = FinChar;
                }

                /* Unless this code is raw data, pursue the chain pointed to by CurCode
                 * through the hash table to its end; each code in the chain puts its
                 * associated output code on the output queue.
                 */

                while (CurCode > EOFCode)
                {
    	            if (OutCount > 4096) break;   /* corrupt file */
    	            load->OutCode[OutCount++] = load->Suffix[CurCode];
    	            CurCode = load->Prefix[CurCode];
                }

                if (OutCount > 4096) return gifError("outcount blew up");
            }

            /* The last code in the chain is treated as raw data. */

            FinChar = CurCode & BitMask;
            load->OutCode[OutCount++] = FinChar;

            /* Now we put the data out to the Output routine.
             * It's been stacked LIFO, so deal with it that way...
             */

            /* safety thing:  prevent exceeding range of 'pic8' */
            if (npixels + OutCount > load->maxpixels)
                OutCount = load->maxpixels-npixels;

            npixels += OutCount;

            //if (!Interlace)
            //{
                for (i=OutCount-1; i>=0; i--)
                {
                    // *picptr = load->OutCode[i];

                    spr_buff[load->pn++] = load->OutCode[i];

                    if (load->pn==load->width) {
                      int inc;
                      e=render_row(load->render_handle, &spr_buff, &inc);
                      if (e) return e;
                      load->last_row+=inc;
                      load->pn=0;
                      //if (load->last_row > load->height) printf("extra one %d    \n",load->last_row);
                    }

                    //if (transparent >= 0 && *picptr != transparent)
                    //    *(picptr+load->maskoffset)=255;
                    //picptr++;
                    //if (++load->XC == this->width)
                    //{
                    //    load->XC=0;
                    //    load->YC++;
                    //    picptr+=load->spritewidth-this->width;
                    //}
                }
            //}
            //else
            //    for (i=OutCount-1; i>=0; i--)
            //        DoInterlace(this, load->OutCode[i], transparent);

            OutCount = 0;

            if (load->JustHadClearCode)
                load->JustHadClearCode = 0;
            else
            {
                /* Build the hash table on-the-fly. No table is stored in the file. */

                load->Prefix[FreeCode] = OldCode;
                load->Suffix[FreeCode] = FinChar;

                /* Point to the next slot in the table.  If we exceed the current
                 * MaxCode value, increment the code size unless it's already 12.  If it
                 * is, do nothing: the next code decompressed better be CLEAR
                 */

                if (++FreeCode >= MaxCode)
                {
    	            if (CodeSize < 12)
    	            {
    	                CodeSize++;
    	                MaxCode *= 2;
    	                ReadMask = (1 << CodeSize) - 1;
    	            }
                }
            }
            OldCode = InCode;
        }
stage2:
        Code = gifstream_ReadCode(load, CodeSize, ReadMask);
        if (Code == -1)
        {
            load->readimagestate=2;
            if (load->dataptr < load->dataend)
                goto restart;
            else
                goto exit;
        }
        if (npixels >= load->maxpixels) break;
    }
    load->state = State_EndImageData;

exit:

    load->CodeSize=CodeSize; load->MaxCode=MaxCode;
    load->ReadMask=ReadMask; load->FreeCode=FreeCode;
    load->npixels=npixels;
    load->OldCode=OldCode;
    load->FinChar=FinChar;

    load->CurCode=CurCode;
    load->InCode=InCode; load->Code=Code;

    return NULL;
}


/* Fetch the next code from the raster data stream.  The codes can be
 * any length from 3 to 12 bits, packed into 8-bit bytes, so we have to
 * maintain our location in the Raster array as a BIT Offset.  We compute
 * the byte Offset into the raster array by dividing this by 8, pick up
 * three bytes, compute the bit Offset into our 24-bit chunk, shift to
 * bring the desired code to the bottom, then mask it off and return it.
 */

static int gifstream_ReadCode(GIFloaddata *load, int CodeSize, int ReadMask)
{
  int RawCode, ByteOffset;

  ByteOffset = load->BitOffset / 8;

  if (load->BitOffset + CodeSize > 8*load->blocksize)
  {
      /* About to bite off more than we can chew. */
      if (load->blocksize - ByteOffset >= 1)
          load->temp[0]=load->temp[ByteOffset];
      if (load->blocksize - ByteOffset >= 2)
          load->temp[1]=load->temp[ByteOffset+1];
      load->BitOffset-=ByteOffset*8;
      load->loadinto=load->blocksize-ByteOffset;
      return -1;
  }
  RawCode = load->temp[ByteOffset] + (load->temp[ByteOffset + 1] << 8);
  if (CodeSize > 8)
    RawCode += ( load->temp[ByteOffset + 2] << 16);
  RawCode >>= (load->BitOffset % 8);
  load->BitOffset += CodeSize;

  return RawCode & ReadMask;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_abandon_image                                                                    *
 *                                                                                            *
 * Remove all data, structures, memory allocations etc. associated with an image.             *
 *                                                                                            *
 * In: handle - identifier for this image (different to the handle used by c.render)          *
 *--------------------------------------------------------------------------------------------*/

static void gifstream_abandon_image(int handle)
{
    gifstream_delete(handle);
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_error                                                                            *
 *                                                                                            *
 * Takes a string in and returns a kernel_oserror.                                            *
 *                                                                                            *
 * In: s - string containing an error message.                                                *
 *                                                                                            *
 * Returns: kernel_oserror block containing the string as the error message                   *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_error(char *s)
{
    static _kernel_oserror e;

    e.errnum=MiscErrorNum;
    sprintf(e.errmess,"Error from GIF stream: %s\n",s);

    return &e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_valid_handle                                                                     *
 *                                                                                            *
 * Checks to see if a given handle is currently valid.                                        *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: 1 (handle is valid) or 0 (handle not valid)                                       *
 *--------------------------------------------------------------------------------------------*/

static int gifstream_valid_handle(int handle)
{
    if (handle<0)
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    if (handle>MaxPics)
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    if (!store[handle])
    {
        debug_print("*** INVALID GIF HANDLE ***");
        return 0;
    }

    return 1;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_animated_plot                                                                    *
 *                                                                                            *
 * Plot the current (next) frame of animation on the screen.                                  *
 *                                                                                            *
 * In: handle - identifier for this animation                                                 *
 *     x, y   - co-ordinates to plot at                                                       *
 *     scale  - % scale to plot at                                                            *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_animated_plot(int handle, int x, int y, scale_factor scale)
{
    _kernel_oserror *e;
    GIFloaddata     *load = store[handle];

    e=render_animate_plot(load->render_handle, x, y, scale);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_register_filler                                                                  *
 *                                                                                            *
 * Called by client to register a background filler routine for animations. This is called    *
 * before each frame is plotted and will fill in the background.                              *
 *                                                                                            *
 * In: handle - identifier for this animation                                                 *
 *              fill_fn - function to call to fill background                                 *
 *              handle1, handle2 - handles to pass to filler function.                        *
 *                                                                                            *
 * Returns: a handle which will be passed to the filler routine when it is called.            *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* gifstream_register_filler(int handle, FillerFunction *fill_fn, void* handle1, int* handle2)
{
    GIFloaddata *load = store[handle];

    load->fill_fn = fill_fn;
    load->handle1 = handle1;
    load->handle2 = handle2;

    if (store[handle]->flags.render_type==Type_AnimatedSprites)
        render_register_filler(load->render_handle, load->fill_fn, load->handle1, load->handle2);

    return 0;
}


/*--------------------------------------------------------------------------------------------*
 * gifstream_make_animation                                                                   *
 *                                                                                            *
 * Called when decoder realises that there's more than one frame (ie. it's an animation).     *
 * Informs render of this.                                                                    *
 *                                                                                            *
 * In: load - structure for this image/animation                                              *
 *                                                                                            *
 * Returns: error, if one occurred, else NULL                                                 *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* gifstream_make_animation(GIFloaddata *load)
{
    _kernel_oserror *e;
    frame_str        fr;
    int              an_handle, oldstate;

    if (load->flags.render_type!=Type_InternalLZW) return NULL;

    fr.frame_off    = 0;
    fr.delay        = load->delay;
    fr.width        = load->width;
    fr.height       = load->height;
    fr.left         = load->left;
    fr.top          = load->top;
    fr.transparency = load->transparent;
    fr.disposal     = load->disposal;
    fr.haspalette   = 0;
    fr.interlace    = load->Interlace;
    fr.trtab        = 0;

    oldstate=flex_set_budge(0);
    e = render_make_animation(load->render_handle, fr, load->Background,
                              load->screen_width, load->screen_height, load->loops,
                              &an_handle);
    flex_set_budge(oldstate);
    if (e) return e;

    load->flags.render_type = Type_AnimatedSprites;
    load->render_handle     = an_handle;

    e = render_register_filler(load->render_handle, load->fill_fn, load->handle1, load->handle2);
    if (e) return e;

    load->delay=-1;

    return NULL;
}


_kernel_oserror* gifstream_export_sprite(int handle, char* filename)
{
    _kernel_oserror *e = NULL;

    /* If not a valid handle, return */
    if (!gifstream_valid_handle(handle)) return NULL;

    if (store[handle]->flags.render_type==Type_InternalLZW)
        e=render_export_sprite(store[handle]->render_handle, filename);
    else e=render_export_animated_sprites(store[handle]->render_handle, filename);

    return e;
}
