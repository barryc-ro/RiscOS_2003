/*-------------------------------------------------------------------------------------------*/
/* File:    c.sprite                                                                         */
/* Purpose: Sprite plotting component of the image library.                                  */
/* Author:  Kevin Bracey                                                                     */
/* History: 06-May-97: RML: Modified Render routine to take an x and y size to scale to,     */
/*                          instead of a percentage.                                         */
/*          12-Sep-97: RML: Added a DumpSprite routine.                                      */
/*-------------------------------------------------------------------------------------------*/

/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"
#include "flex.h"

#include "imagetrans.h"
#include "internal.h"
#include "sprite.h"
#include "defines.h"
#include "datastruct.h"
#include "gif.h"

#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

static int osver;
static int log2bpp;

/*
 * File Format:
 *   (format identifier:  "#define" as first couple chars in file)
 *
 * looks for first line beginning with '#define'
 *   reads "#define identifier width"  (identifier is ignored)
 * looks for next line beginning with '#define'
 *   reads "#define identifier height" (identifier is ignored)
 * looks for next occurence of characters '0x'
 *   read next two chars as two hex digits
 *   move forward to next occurence of '0x'
 *   repeat
 */

_kernel_oserror *LoadSprite(Image *this, const char *data, int len, BBox *changed);
_kernel_oserror *EndLoadSprite(Image *this, BBox *changed);
_kernel_oserror *StartExportSprite(Image *this, int *size);
_kernel_oserror *RenderSprite(Image *this, int x, int y, int scale, int x_size, int y_size);
_kernel_oserror *ModeChangeSprite(Image *this);
_kernel_oserror *DeleteSprite(Image *this);
_kernel_oserror *LoadFromCacheSprite(Image *this, const char *filename);
_kernel_oserror *DumpToCacheSprite(Image *this, const char *filename, int *justuseorig);

#define spriteError imgtrnsError

int NewSprite(Image *im)
{
    Spriteloaddata *load;

    if (osver==0)
        _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    load=(Spriteloaddata *)(im->private_data=malloc(sizeof(Spriteloaddata)));

    if (!load)
        return -1;

    im->Load=LoadSprite;
    im->DumpSprite=SpriteDumpSprite;
    im->EndLoad=EndLoadSprite;
    im->Delete=DeleteSprite;
    im->Render=RenderSprite;
    im->ModeChange=ModeChangeSprite;
    im->LoadFromCache=LoadFromCacheSprite;
    im->DumpToCache=DumpToCacheSprite;
    im->StartExport=StartExportSprite;
    im->Export=Export;
    im->EndExport=EndExport;
    im->BGCol=BGColSimple;
    im->NeedRedraw=0;
    im->RegisterFiller=0;

    im->width=im->height=im->width_os=im->height_os=-1;
    im->animated=0;

    im->table=NULL;

    memset(load, 0, sizeof *load);

    if (flex_alloc((flex_ptr) &im->private_data2, 2048) == 0)
        return -1;

    memset(im->factors, 0, sizeof *im->factors);

    load->memory=2048;

    return 0;
}

/*****************************/
_kernel_oserror *LoadSprite(Image *this, const char *data, int len, BBox *changed)
{
    Spriteloaddata *load=(Spriteloaddata *) this->private_data;

    if (len==0)
        return NULL;

    if (load->bytesloaded+len > load->memory)
    {
        if (flex_extend((flex_ptr) &this->private_data2, load->bytesloaded+len+2048)==0)
            return spriteError("Out of memory");
        load->memory=load->bytesloaded+len+2048;
    }

    memcpy((char *)this->private_data2+load->bytesloaded+4, data, len);

    load->bytesloaded+=len;

    if (changed)
        memset(changed, 0, sizeof(BBox));

    return NULL;
}

/*******************************************/
_kernel_oserror *EndLoadSprite(Image *this, BBox *changed)
{
    int    w, h;
    Spriteloaddata *load=(Spriteloaddata *) this->private_data;
    int mask, mode;
    _kernel_oserror *e;

    memset(changed, 0, sizeof(BBox));

    this->private_data2[0]=load->bytesloaded+4;

    /* Get name of first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, this->private_data2, load->name,
                                            sizeof load->name, 1);
    if (e) return e;

    /* Read sprite information */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,6), 256+40, this->private_data2, load->name,
                                               &w, &h, &mask, &mode);
    if (e) return e;

    /* Check whether we have a palette */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(3), 256+37, this->private_data2, load->name, -1,
                                                    &load->pal);
    if (e) return e;

    this->width=w;
    this->height=h;

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 4, &load->xeig);
    if (e) return e;
    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 5, &load->yeig);
    if (e) return e;
    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 9, &load->bpp);
    if (e) return e;

    /* We can't utilise non-256 entry 8bpp palettes */
    if (load->bpp==3 && load->pal != 256)
        load->pal=0;

    if (this->width_os==-1)
        this->width_os=w<<load->xeig;

    if (this->height_os==-1)
        this->height_os=h<<load->yeig;

    this->transparent=mask;


  return 0;
}

_kernel_oserror *ModeChangeSprite(Image *this)
{
    Spriteloaddata *load=(Spriteloaddata *) this->private_data;
    _kernel_oserror *e=0;
    int bufsize;

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);

    /* don't need a table if going into 16 or 32bpp, and we have a palette */

    if (!(load->pal && log2bpp >= 4))
    {
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2,
                                                              load->name,
                                                              -1, -1, 0, 2,
                                                              &bufsize);

        if (!e)
        {
            free(this->table);
            this->table=malloc(bufsize);
            if (!this->table)
                e=spriteError("Insufficient memory");
        }

        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2,
                                                      load->name, -1, -1,
                                                      this->table, 2);
    }

    if (!e)
    e=_swix(Wimp_ReadPixTrans, _INR(0,2)|_INR(6,7), 256, this->private_data2, load->name,
                                                    this->factors, 0);

    if (!e)
    {
        this->factors[0]*=this->width_os;
        this->factors[1]*=this->height_os;
        this->factors[2]*=this->width<<load->xeig;
        this->factors[3]*=this->height<<load->yeig;
    }
    return e;
}

_kernel_oserror *RenderSprite(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    Spriteloaddata *load=(Spriteloaddata *) this->private_data;
    _kernel_oserror *e=NULL;
    int fac[4];

    if (this->width <= 0)
    {
        e=_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), 0, 0, 0);
        if (!e)
            e=_swix(OS_Plot, 4, x, y);
        if (!e)
            e=_swix(OS_Plot, 0x60 | 1, this->width_os*scale/100-1,
                                       this->height_os*scale/100-1);
        return e;
    }

    if (!this->factors[0])
        e=ModeChangeSprite(this);

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
      int xos, yos;
      
      xos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,4);
      yos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,5);

      fac[0]=x_size;
      fac[1]=y_size;
      fac[2]=this->width*xos;
      fac[3]=this->height*yos;
    }
    else if (scale!=100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (!e)
    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    this->private_data2,
                                    load->name,
                                    x, y,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                    PutSpriteScaled_UseMask
                                                  : PutSpriteScaled_UseMask,
                                    fac,
                                    (log2bpp <=3 || !load->pal) ? this->table : 0);

    return e;
}

_kernel_oserror *StartExportSprite(Image *this, int *size)
{
    *size=this->private_data2[0]-4;

    return StartExport((flex_ptr) &this->private_data2, this->private_data2[0]-4, 4);
}

_kernel_oserror *DeleteSprite(Image *this)
{
    free(this->private_data);
    free(this->table);

    if (this->private_data2)
        flex_free((flex_ptr) &this->private_data2);

    free(this);

    return NULL;
}

_kernel_oserror *DumpToCacheSprite(Image *this, const char *filename, int *justuseorig)
{
    *justuseorig=0;
    return SaveSpriteGIF(this, filename, -1);
}

_kernel_oserror *LoadFromCacheSprite(Image *this, const char *filename)
{
    _kernel_oserror *e;
    int length, transparent;

    e=_swix(OS_File, _INR(0,1)|_OUT(4), 20, filename, &length);

    if (!e)
    {
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4))
            return spriteError("Insufficient memory");
    }

    if (!e)
    {
        this->private_data2[0]=length+4;
        this->private_data2[2]=16;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    }

    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2), 256+10, this->private_data2, filename);

    transparent = this->transparent;
    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 256+40, this->private_data2, filename,
                                                   &this->width, &this->height,
                                                   &transparent);
    this->transparent = transparent;

    if (!e)
    {
        this->mutable_mask=0;
        if (this->width_os==-1)
            this->width_os=2*this->width;
        if (this->height_os==-1)
            this->height_os=2*this->height;
    }

    return e;
}

_kernel_oserror *SpriteDumpSprite(Image *this, const char *filename, int maxbpp)
{
    return _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
}
