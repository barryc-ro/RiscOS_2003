/*------------------------------------------------------------------------------------------------------*/
/* File:    c.gif                                                                                       */
/* Purpose: GIF image library component                                                                 */
/*          Makes use of direct to screen plotting, rather than interval sprite                         */
/* Author:  Richard Leggett                                                                             */
/* History: 04-Feb-97: RML: Created                                                                     */
/*          17-Mar-97: RML: Minor modifications.							*/
/*          24-Mar-97: RML: Improved error handling							*/
/*          06-May-97: RML: Modified Render routine to take an x and y size to scale to, instead of a   */
/*                          percentage.                                                                 */
/*------------------------------------------------------------------------------------------------------*/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "swis.h"
#include "defines.h"
#include "imagetrans.h"
#include "datastruct.h"
#include "gif.h"
#include "gif_stream.h"
#include "render.h"
#include "rml_misc.h"

static _kernel_oserror *LoadGIF(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *EndLoad(Image *this, BBox *changed);
static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size);
static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig);
static _kernel_oserror *LoadFromCache(Image *this, const char *filename);
static _kernel_oserror *ModeChange(Image *this);
static _kernel_oserror *StartExportGIF(Image *this, int *size);
static _kernel_oserror *Export(Image *this, char *buffer, int *len);
static _kernel_oserror *EndExport(Image *this);
static _kernel_oserror *BGColGIF(Image *this, int *bgcol);
static _kernel_oserror *Delete(Image *this);
static _kernel_oserror *GIFNeedRedraw(Image *this, int* need, BBox *changed);
static _kernel_oserror *GIFRegisterFiller(Image *this, FillerFunction *fill_fn,
                                          void* handle1, int* handle2);

static int xos, yos;

static void gifstream_report_error(_kernel_oserror *e)
{
    if (e)
    {
        debug_error(e->errmess);
#if ReportErrorsToScreen
        _swi(OS_WriteC,_IN(0),7);
        _swi(OS_WriteC,_IN(0),4);
        _swi(OS_WriteC,_IN(0),26);
        printf("%d, %s                \n", e->errnum, e->errmess);
        //_swi(OS_ReadC,0);
        //exit(0);
#endif
    }
}


int NewGIF(Image *im)
{
    _kernel_oserror *e;
    int              gifhandle;

    debug_print("\nGIF, NewGIF");

    /* Read scaling, pixels -> OS units */
    xos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,4);
    yos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,5);

    /* Setup a few variables */
    im->Load           = LoadGIF;
    im->DumpSprite     = SaveSpriteGIF;
    im->EndLoad        = EndLoad;
    im->Delete         = Delete;
    im->Render         = Render;
    /*im->ModeChange     = ModeChange;*/
    im->LoadFromCache  = LoadFromCache;
    im->DumpToCache    = DumpToCache;
    im->StartExport    = StartExportGIF;
    im->Export         = Export;
    im->EndExport      = EndExport;
    im->BGCol          = BGColGIF;
    im->NeedRedraw     = GIFNeedRedraw;
    im->RegisterFiller = GIFRegisterFiller;

    /* Reset width, height etc. so we know where we are */
    im->width = im->height = im->width_os = im->height_os = -1;
    im->mutable_mask = 0;
    im->animated = 0;

    /* Call 'gifstream' begin routine */
    e=gifstream_begin(&gifhandle, im->flags);
    debug_value("  gifhandle ",gifhandle);

    /* If an error occurred, report it, then set flags to indicate this is an invalid structure */
    if (e)
    {
        gifstream_report_error(e);
        im->flags=-1;
        return 0;
    }

    /* Put the handle for the image in the flags field */
    im->flags=gifhandle;

    return 0;
}


_kernel_oserror *LoadGIF(Image *this, const char *data, int len, BBox *changed)
{
    _kernel_oserror *e;
    int              gif_handle=this->flags;
    int              return_width, return_height, return_mask, return_anim;

    debug_value("\nGIF, LoadGIF ",gif_handle);

    /* If flags are -1, then structure is invalid - do nothing */
    if (this->flags==-1) return NULL;

    /* Tell 'gifstream' that we've loaded a bit of data */
    e=gifstream_load(gif_handle, (char*)data, len, changed, &return_width,
                     &return_height, &return_mask, &return_anim);
    this->animated = return_anim;

    if (e)
    {
        gifstream_report_error(e);
        this->flags=-1;
        return e;
    }

    /* Set the mutable maks according to the returned value */
    this->mutable_mask = return_mask;

    /* If returned width and height are not -1, then they have been read from the GIF file */
    if ((this->width==-1) && (return_width>-1))
    {
        this->width =return_width;
        this->height=return_height;
        if (this->width_os==-1)  this->width_os = this->width *2;
        if (this->height_os==-1) this->height_os = this->height *2;
    }

    debug_value("GIF, End LoadGIF ",gif_handle);

    return NULL;
}


_kernel_oserror *EndLoad(Image *this, BBox *changed)
{
    _kernel_oserror *e;
    int              gif_handle=this->flags;

    debug_value("\nGIF, EndLoad ",gif_handle);

    /* Check if the structure is invalid */
    if (this->flags==-1) return NULL;

    /* Call the end load routine */
    e=gifstream_end(gif_handle);

    if (e)
    {
        gifstream_report_error(e);
        this->flags=-1;
        return e;
    }

    changed->xmin = 0;
    changed->xmax = this->width_os;
    changed->ymin = 0;
    changed->ymax = 8;

    debug_value("GIF, End EndLoad ",gif_handle);
    return NULL;
}


_kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    _kernel_oserror *e;
    int              gif_handle=this->flags;
    scale_factor     s;

    debug_value("\nGIF, Render ",gif_handle);

    /* Check if structure is invalid */
    if (this->flags==-1) return NULL;

    if (this->modechanged)
    {
        e = ModeChange(this);
        if (e) return e;
        this->modechanged = 0;
    }

    /* By default, scale is specfied by 'scale' variable */
    s.x_mul = scale * 2;
    s.x_div = 100 * xos;
    s.y_mul = scale * 2;
    s.y_div = 100 * yos;

    /* If specified, scale so that image is x_size wide and y_size high */
    if ((x_size>0) && (y_size>0))
    {
        s.x_mul = x_size;
        s.y_mul = y_size;
        s.x_div = this->width*xos;
        s.y_div = this->height*yos;
    }

    /* if defined by host application, scale is specified by width_os and height_os */
    else if ((this->width_os>0) && (this->width_os != this->width*xos))
    {
        s.x_mul = this->width_os;
        s.y_mul = this->height_os;
        s.x_div = this->width * xos;
        s.y_div = this->height * yos;
    }

    /* Plot the image */
    e=gifstream_plot(gif_handle, x, y, s);
    if (e)
    {
        gifstream_report_error(e);
        this->flags=-1;
        return e;
    }

    debug_value("GIF, End Render ",gif_handle);
    return NULL;
}


_kernel_oserror *SaveSpriteGIF(Image *this, const char *filename, int maxbpp)
{
    int gif_handle=this->flags;

    maxbpp=maxbpp;
    gifstream_export_sprite(gif_handle, (char*)filename);

    return 0;
}


_kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig)
{
    int gif_handle=this->flags;

    gif_handle=gif_handle;
    filename=filename;
    justuseorig=justuseorig;

    return 0;
}


_kernel_oserror *LoadFromCache(Image *this, const char *filename)
{
    int gif_handle=this->flags;

    gif_handle=gif_handle;
    filename=filename;

    return 0;
}


_kernel_oserror *ModeChange(Image *this)
{
    _kernel_oserror *e=0;
    int              gif_handle=this->flags;

    debug_value("\nGIF, ModeChange ",gif_handle);

    /* Read scaling pixels -> OS Units */
    xos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,4);
    yos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,5);

    /* Check this image is valid */
    if (this->flags==-1) return NULL;

    /* Call the appropriate routine */
    e=gifstream_mode_change(gif_handle);
    if (e)
    {
        gifstream_report_error(e);
        this->flags=-1;
        return e;
    }

    debug_value("GIF, End ModeChange ",gif_handle);

    return e;
}


_kernel_oserror *StartExportGIF(Image *this, int *size)
{
    int gif_handle=this->flags;

    gif_handle=gif_handle;
    size=size;

    return 0;
}


_kernel_oserror *Export(Image *this, char *buffer, int *len)
{
    int gif_handle=this->flags;

    gif_handle=gif_handle;
    buffer=buffer;
    len=len;

    return 0;
}


_kernel_oserror *EndExport(Image *this)
{
    int gif_handle=this->flags;

    gif_handle=gif_handle;

    return 0;
}


_kernel_oserror *BGColGIF(Image *this, int *bgcol)
{
    int gif_handle=this->flags;

    return gifstream_background_colour(gif_handle, bgcol);
}


_kernel_oserror *Delete(Image *this)
{
    _kernel_oserror *e;
    int              gif_handle=this->flags;

    debug_value("\nGIF, Delete ",gif_handle);

    /* Check it's a valid image */
    if (this->flags==-1) return NULL;

    /* Delete the image */
    e=gifstream_delete(gif_handle);
    if (e)
    {
        gifstream_report_error(e);
        this->flags=-1;
        return e;
    }

    /* Free the memory for this data structure */
    free(this);
    this = 0;

    debug_value("GIF, End Delete ",gif_handle);

    return 0;
}


_kernel_oserror *GIFNeedRedraw(Image *this, int *redraw, BBox *changed)
{
    *redraw = gifstream_need_redraw(this->flags, changed);
    return NULL;
}


_kernel_oserror* GIFRegisterFiller(Image *this, FillerFunction *fill_fn, void* handle1, int* handle2)
{
    gifstream_register_filler(this->flags, fill_fn, handle1, handle2);

    return NULL;
}

