/*-------------------------------------------------------------------------------------------*/
/* File:    c.png                                                                            */
/* Purpose: PNG plotting component of the image library.                                     */
/* Author:  Kevin Bracey                                                                     */
/* History: 06-May-97: RML: Modified Render routine to take an x and y size to scale to,     */
/*                          instead of a percentage.                                         */
/*-------------------------------------------------------------------------------------------*/

/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <string.h>
#include <stdlib.h>
#ifdef TRACE
#include <stdio.h>
#endif

#include "swis.h"

#include "imagetrans.h"
#include "defines.h"
#include "datastruct.h"
#include "internal.h"
#include "png.h"
#include "sprite.h"

#define PNG_INTERNAL  /* Give ourselves slightly more intimate access */
#include "PNG/png.h"

#include "riscospal.h"

typedef unsigned char bool;
#define false 0
#define true 1

#define SCREEN_GAMMA 2.2

#define DITHERING
/*#define GAMMA_DITHER*/

/*#define GIVE_WARNINGS*/

#define MODE(t,x,y) (((t) << 27) | ((x) << 14) | ((y) << 1) | 1)

#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define pngError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

static int osver;
static int log2bpp;
static png_bytep screen_to_1, screen_from_1, hack_to_screen, hack_to_1;
static int ct32k_buffer[3];

static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *EndLoad(Image *this, BBox *changed);
static _kernel_oserror *Delete(Image *this);
static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size);
static _kernel_oserror *ModeChange(Image *this);
static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig);
static _kernel_oserror *LoadFromCache(Image *this, const char *filename);
static _kernel_oserror *StartExportPNG(Image *this, int *size);
static _kernel_oserror *BGColPNG(Image *this, int *bgcol);
static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2);

typedef struct png_loaddata
{
    int spritewidth;
    int maskwidth;
    unsigned int finished:1;
    unsigned int eightbpphack:1; /* Processing 8bpp + alpha data */
    #ifdef TRACE
    FILE *trace;
    #endif
    png_struct *png_ptr;
    png_info *info_ptr;
    int sprite_offset;
    int mask_offset;
    const char *errmess;
    BBox changed;
    png_byte *temp;
    int color_type;
    png_bytep file_to_1;
    png_bytep file_to_screen;
    FillerFunction *filler;
    void *filler_handle1;
    int *filler_handle2;

} PNGloaddata;

static void info_callback(png_struct *, png_info *);
static void row_callback(png_struct *, png_byte *, png_uint_32, int);
static void end_callback(png_struct *, png_info *);

static void my_error_fn(png_struct *png_ptr, png_const_charp errmess)
{
    *(const char **)png_get_error_ptr(png_ptr) = errmess;
}

#ifdef GIVE_WARNINGS
static void my_warn_fn(png_struct *png_ptr, png_const_charp errmess)
{
    _kernel_oserror er;
    er.errnum = 1;
    strcpy(er.errmess, errmess);
    wimp_report_error(&er, 0, "LibPNG");
}
#endif

int NewPNG(Image *im)
{
    PNGloaddata *load;
    png_info *info_ptr;
    png_struct *png_ptr;
    int oldbudge;

    oldbudge = flex_set_budge(1);

    load=(PNGloaddata *)(im->private_data=malloc(sizeof(PNGloaddata)));

    if (!load)
        goto abort1;

    memset(load, 0, sizeof *load);

    /* Sort out error functions */
#ifdef GIVE_WARNINGS
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, my_warn_fn);
#else
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, NULL);
#endif
    if (!png_ptr)
        goto abort2;

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
        goto abort3;

    png_set_progressive_read_fn(png_ptr, im, info_callback, row_callback, end_callback);

#ifdef GIVE_WARNINGS
    png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_DISCARD);
#else
    png_set_crc_action(png_ptr, PNG_CRC_ERROR_QUIT, PNG_CRC_WARN_DISCARD);
#endif

    if (osver==0)
        _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    im->Load=LoadPNG;
    im->DumpSprite=SaveSpritePNG;
    im->EndLoad=EndLoad;
    im->Delete=Delete;
    im->Render=Render;
    /*im->ModeChange=ModeChange;*/
    im->LoadFromCache=LoadFromCache;
    im->DumpToCache=DumpToCache;
    im->StartExport=StartExportPNG;
    im->Export=Export;
    im->EndExport=EndExport;
    im->BGCol=BGColPNG;
    im->NeedRedraw=0;
    im->RegisterFiller=RegisterFiller;

    im->table=NULL;
    im->private_data2=NULL;
    im->width=im->height=im->width_os=im->height_os=-1;
    im->animated=0;

    memset(im->factors, 0, sizeof im->factors);

    im->transparent=0;
    im->mutable_mask=0;
    im->private_data=load;

    load->png_ptr = png_ptr;
    load->info_ptr = info_ptr;

    #ifdef TRACE
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%p", im);
        load->trace=fopen(name, "w");
    }
    #endif

    flex_set_budge(oldbudge);

    return 0;

  abort3:
    png_destroy_read_struct(&png_ptr, (png_infopp) NULL, (png_infopp) NULL);
  abort2:
    free(load);
  abort1:
    flex_set_budge(oldbudge);
    return -1;
}

/*****************************/
static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    volatile int oldbudge = -1;

    if (changed)
        memset(changed, 0, sizeof(BBox));

    load->changed.xmin = 0;
    load->changed.ymin = 0x10000000;
    load->changed.xmax = 0;
    load->changed.ymax = 0;

    if (setjmp(load->png_ptr->jmpbuf))
    {
        flex_set_budge(oldbudge);

        return pngError(load->errmess);
    }

    oldbudge = flex_set_budge(0);

    /*
     * Set these up for our hacky premultiply routine...
     */
    hack_to_1 = load->file_to_1;
    hack_to_screen = load->file_to_screen;

    png_process_data(load->png_ptr, load->info_ptr, (png_byte *) data, len);

    flex_set_budge(oldbudge);

    if (changed)
    	*changed = load->changed;

    return NULL;
}

void info_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int mem;
    unsigned int mode;
    int pal_entries;
    _kernel_oserror *e;
    int r1, r2, r3;
    int background;
    png_color *palette;
    int num_palette;
    bool have_mask;
    int riscos_rowbytes;
    png_bytep trans = NULL;
    int num_trans = 0, useropal = 0;
    png_color_16p trans_values = NULL;

    /* First decide if we're going to do alpha processing */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        this->full_alpha = 1;
    }
    else if (info->valid & PNG_INFO_tRNS)
    {
        png_get_tRNS(png_ptr, info, &trans, &num_trans, &trans_values);
        if (info->color_type == PNG_COLOR_TYPE_PALETTE)
        {
            int i;
            for (i = 0; i < num_trans; i++)
            {
                if (trans[i] != 0 && trans[i] != 255)
                {
                    this->full_alpha = 1;
                    break;
                }
            }
        }
    }

    if (this->flags & IMAGE_FAST)
        this->full_alpha = 0;

    if (this->full_alpha)
    {
        if (!log2bpp) ModeChange(NULL);

        if (log2bpp < 3)
            this->full_alpha = 0;
    }

    if (this->full_alpha)
    {
        /* Make some extra gamma tables... */
        double g;
        int i;

        /*
         * file gamma -> linear
         */
        if (info->gamma)
            g = 1.0 / info->gamma;
        else
            g = 1.0 / 0.45;

        load->file_to_1 = malloc(256);
        if (!load->file_to_1)
            png_error(png_ptr, "Insufficient memory");

        for (i = 0; i < 256; i++)
        {
           load->file_to_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
        }

        /*
         * file gamma -> screen gamma
         */
        if (info->gamma)
            g = 1.0 / (info->gamma * SCREEN_GAMMA);
        else
            g = 1.0 / (0.45 * SCREEN_GAMMA);

        load->file_to_screen = malloc(256);
        if (!load->file_to_screen)
            png_error(png_ptr, "Insufficient memory");

        for (i = 0; i < 256; i++)
        {
            load->file_to_screen[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
        }

        /*
         * screen gamma -> linear
         */
        if (!screen_from_1)
        {
            screen_from_1 = malloc(256);
            if (!screen_from_1)
                png_error(png_ptr, "Insufficient memory");

            g = 1.0 / SCREEN_GAMMA;

            for (i = 0; i < 256; i++)
            {
               screen_from_1[i] = (png_byte)(pow((double)i / 255.0,
                  g) * 255.0 + .5);
            }
        }

        /*
         * linear -> screen gamma
         */
        if (!screen_to_1)
        {
            screen_to_1 = (png_bytep) malloc(256);
            if (!screen_to_1)
                png_error(png_ptr, "Insufficient memory");

            g = SCREEN_GAMMA;

            for (i = 0; i < 256; i++)
            {
                screen_to_1[i] = (png_byte)(pow((double)i / 255.0,
                   g) * 255.0 + .5);
            }
        }

        hack_to_1 = load->file_to_1;
        hack_to_screen = load->file_to_screen;
    }

    /* Only 8 bits per channel under RISC OS */
    if (info->bit_depth == 16)
        png_set_strip_16(png_ptr);

    if (info->bit_depth < 8)
    {
        if (this->full_alpha)
        {
            /* Need 8bpp data for blending code */
            png_set_expand(png_ptr);
        }
        else
            png_set_packswap(png_ptr);
    }

    if (info->color_type == PNG_COLOR_TYPE_RGB ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver >= 0xA5 || this->full_alpha)
        {
            /* Add a filler if alpha missing */
            if (info->color_type == PNG_COLOR_TYPE_RGB)
                png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);

            mode = MODE(6,90,90);
        }
        else
        {
            /* If on an old OS, get it to spit out 8bpp data :-( */
            _swix(Hourglass_On, 0);
            if (png_get_valid(png_ptr, info, PNG_INFO_PLTE))
            {
                png_uint_16p histogram = NULL;
                png_get_hIST(png_ptr, info, &histogram);
                png_set_dither(png_ptr, info->palette, info->num_palette, 256, histogram, 1);
            }
            else
            {
                png_set_dither(png_ptr, riscospal, 256, 256, NULL, 1);
                useropal=1;
            }
            _swix(Hourglass_Off, 0);
            mode = 28;
        }
    }
    else
    {
        switch (info->bit_depth)
        {
            case 1:  mode = 25; break;
            case 2:  mode = 26; break;
            case 4:  mode = 27; break;
            case 8:
            case 16: mode = 28; break;
        }
    }

    /* Can't handle 16bpp data with transparency - turn it into 8bpp with alpha */
    if (info->valid & PNG_INFO_tRNS)
    {
        if (info->bit_depth == 16 || info->color_type == PNG_COLOR_TYPE_RGB)
            png_set_expand(png_ptr);
    }

    if (!this->full_alpha)
    {
        if (info->valid & PNG_INFO_gAMA)
            png_set_gamma(png_ptr, SCREEN_GAMMA, info->gamma);
        else
            png_set_gamma(png_ptr, SCREEN_GAMMA, 0.45);
    }
    else
    {
        if (info->color_type != PNG_COLOR_TYPE_PALETTE)
            png_set_premultiply_alpha(png_ptr);
    }


    /* Enable filling in of interlace */
    png_set_interlace_handling(png_ptr);

    png_read_update_info(png_ptr, info);

    /*
     * Okay, we will now be getting data in one of these formats:
     *            1 bpp paletted/greyscale }
     *            2 bpp paletted/greyscale } only if no alpha in palette
     *            4 bpp paletted/greyscale }
     *            8 bpp paletted/greyscale
     *            8 bpp greyscale + alpha (=> 2 bytes per pixel)
     *           24 bpp colour (with or without alpha, 32 bit packed)
     */

    this->width = info->width;
    this->height = info->height;

    if (this->width_os==-1)
        this->width_os = info->width * 2;
    if (this->height_os==-1)
        this->height_os = info->height * 2;

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        riscos_rowbytes = info->width;
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        riscos_rowbytes = info->width * 4;
    else
        riscos_rowbytes = info->rowbytes;

    mem = 16  /* Sprite area header size */
         +44; /* Sprite header size */

    if ((info->color_type &~ PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY)
        num_palette = pal_entries = 1 << min(info->bit_depth, 8);
    else if (info->color_type == PNG_COLOR_TYPE_PALETTE)
    {
        if (useropal)
            num_palette = 256;
        else
            num_palette = info->num_palette;
        if (num_palette > 16)     pal_entries = 256;
        else if (num_palette > 4) pal_entries = 16;
        else if (num_palette > 2) pal_entries = 4;
        else                      pal_entries = 2;
    }
    else
        num_palette = pal_entries = 0;

    mem += 8 * pal_entries;

    load->spritewidth = (riscos_rowbytes+3)&~3;

    mem += load->spritewidth * info->height;

    if (!this->full_alpha &&
            ((info->color_type & PNG_COLOR_MASK_ALPHA) || (info->valid & PNG_INFO_tRNS))
        || info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
       if (mode > 28)
          load->maskwidth = ((info->width + 31) &~ 31) / 8;
       else
          load->maskwidth = load->spritewidth;

       mem += load->maskwidth * info->height;

       have_mask = true;

       if (!this->full_alpha)
           this->transparent = 1;
    }
    else
       have_mask = false;

    if (!flex_alloc((flex_ptr)&this->private_data2, mem))
    {
        load->errmess = "Insufficient memory";
        longjmp(png_ptr->jmpbuf, 1);
    }

    /* Create the sprite now */
    this->private_data2[0] = mem;
    this->private_data2[2] = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    if (e)
        goto error;

    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                            this->width, this->height, mode);
    if (e)
        goto error;

    /* Sort out the mask */
    if (have_mask)
    {
        e=_swix(OS_SpriteOp, _INR(0,2), 256+29, this->private_data2, "png");
        if (e)
            goto error;


    	/* Clear the mask */
    	_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+61, this->private_data2, "png", 0,
    	    	    	    	    	     	&r1, &r2, &r3);
    	_swix(OS_SetColour, _INR(0,1), 0x10, 0);
    	_swix(OS_WriteI + 16, 0);
    	_swix(OS_SpriteOp, _INR(0,3), 256+61, r1, r2, r3);
    }

    /* Create and fill in the palette */
    if (pal_entries)
    {
        int i, c;

        e=_swix(OS_SpriteOp, _INR(0,3), 256+37, this->private_data2, "png",
                                        pal_entries == 256 ? (1U<<31) + 1 : 1);
        if (e)
            goto error;

        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            palette = png_malloc(png_ptr, num_palette * sizeof(png_color));
            png_build_grayscale_palette(min(info->bit_depth, 8), palette);
            png_correct_palette(png_ptr, palette, num_palette);
            png_ptr->transformations &= ~PNG_GAMMA;
        }
        else if (useropal)
            palette = riscospal;
        else
            palette = info->palette;


        /* If full_alpha, must be palette data with hard tRNS chunk */
        if (this->full_alpha)
        {
            /* We manipulate the palette (har har har).
             * 255 alpha -> colour gamma corrected ready for screen
             * other alpha -> linearise and premultiply
             */
            for (i = 0; i < pal_entries; i++)
            {
                int r, g, b, a;

                if (i < num_trans) a = trans[i]; else a = 255;
                r = palette[i].red;
                g = palette[i].green;
                b = palette[i].blue;

                if (a == 255)
                {
                    #ifdef GAMMA_DITHER
                    r = load->file_to_1[r];
                    g = load->file_to_1[g];
                    b = load->file_to_1[b];
                    #else
                    r = load->file_to_screen[r];
                    g = load->file_to_screen[g];
                    b = load->file_to_screen[b];
                    #endif
                }
                else
                {
                    int a256 = a + (a >> 7);
                    r = (load->file_to_1[r] * a256) >> 8;
                    g = (load->file_to_1[g] * a256) >> 8;
                    b = (load->file_to_1[b] * a256) >> 8;
                }
                c = (b << 24) | (g << 16) | (r << 8) | a;
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = c;
            }
        }
        else
        {
            for (i = 0; i < pal_entries; i++)
            {
                c = (palette[i].blue << 24) |
                    (palette[i].green << 16) |
                    (palette[i].red << 8);
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = c;
            }
        }

        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            png_free(png_ptr, palette);
        }
    }

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 2))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }


    load->sprite_offset = 16 + this->private_data2[12];
    if (have_mask)
    {
        load->mask_offset=16 + this->private_data2[13];
        if (info->interlace_type == 1)
            this->mutable_mask = true;
    }

    load->color_type = info->color_type;

    /* Clear the background */
    background = ((info->background.blue>>(info->bit_depth-8))<<24) |
                 ((info->background.green>>(info->bit_depth-8))<<16) |
                 ((info->background.red>>(info->bit_depth-8))<<8);

    _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
    	    	    	    	    	     &r1, &r2, &r3);
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), background, 128, 0);
    _swix(OS_WriteI + 16, 0);
    _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);

    return;

  error:
    load->errmess = e->errmess;
    longjmp(png_ptr->jmpbuf, 1);
}

static void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type);
static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width);

void row_callback(png_struct *png_ptr, png_byte *new_row, png_uint_32 row_num, int pass)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    png_info *info = load->info_ptr;
    png_byte *row, *mask_row, *our_row;
    int y;

    int oldbudge = flex_set_budge(0);

         row = (png_byte *) this->private_data2 +
                            load->sprite_offset +
                            load->spritewidth * row_num;

    mask_row = (png_byte *) this->private_data2 +
                            load->mask_offset +
                            load->maskwidth * row_num;

    /* Expand our separate mask + color data into the interleaved format the library
       expects... */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        int i;
        png_byte *dp, *sp, *mp;

        sp = row;
        mp = mask_row;
        dp = load->temp;
        for (i = info->width; i; i--)
        {
            *dp++ = *sp++;
            *dp++ = *mp++;
        }

        our_row = row;
        row = load->temp;
    }

    png_progressive_combine_row(png_ptr, row, new_row);

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        /* And remerge... */
        int i;
        png_byte *dp, *sp, *mp;

        row = our_row;

        sp = load->temp;
        mp = mask_row;
        dp = row;
        if (this->full_alpha)
        {
            for (i = info->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++;
            }
        }
        else
        {
            for (i = info->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++ ? 255 : 0;
            }
        }
    }
    else if (info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (!this->full_alpha)
            convert_32bit_alpha_to_mask(row, mask_row, info->width);
    }
    else if (info->valid & PNG_INFO_tRNS)
    {
        if (!this->full_alpha)
            convert_trns_to_mask(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);
    }

    flex_set_budge(oldbudge);

    load->changed.xmax = this->width_os;

    y = (this->height - row_num - 1) * 2;

    if (y + 2 > load->changed.ymax)
    	load->changed.ymax = y + 2;

    if (y < load->changed.ymin)
    	load->changed.ymin = y;
}

void end_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->finished = 1;
}

/*
 * process_transparency - deal with transparency specified by the tRNS chunk
 */
static void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
{
    int i;
    png_uint_32 mask1, mask2;
    png_byte *dp, *sp;
    int s_start, s_inc, shift;
    png_byte alpha;

    switch (depth)
    {
      case 1:
        shift = s_start = 7;
        s_inc = -1;
        mask1 = 0x7f7f;
        mask2 = 1;
        break;

      case 2:
        shift = s_start = 6;
        s_inc = -2;
        mask1 = 0x3f3f;
        mask2 = 3;
        break;

      case 4:
        shift = s_start = 4;
        s_inc = -4;
        mask1 = 0xf0f;
        mask2 = 0xf;
        break;

      default:
        shift = s_start = 0;
        s_inc = 0;
        mask1 = 0;
        mask2 = 0xff;
        break;
    }

    sp =      row + (width - 1) * depth/8;
    dp = mask_row + (width - 1) * depth/8;

    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix < num_trans && trans[pix] == 0)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else if (color_type == PNG_COLOR_TYPE_GRAY)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix == trans_values->gray)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else /* color_type == PNG_COLOR_TYPE_RGB && bit_depth == 8 */
    {
        unsigned int trans_col = (trans_values->blue << 16) |
                                 (trans_values->green << 8) |
                                 trans_values->red;

        dp = mask_row + ((width - 1) >> 3);
        shift = 7;

        for (i = width; i; i--)
        {
            int pix;

            pix = *(int *) sp;
            if (pix & 0x00ffffff == trans_col)
                alpha = 0;
            else
                alpha = 1;

            *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = 7;
                dp--;
            }
            else
                shift--;

            sp -= 4;
        }
    }
}

/*
 * Given a row in AABBGGRR format, fill in the 1-bpp mask information
 */
static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width)
{
    png_bytep sp;
    png_bytep dp;
    int shift, alpha, i;
    unsigned int pix;

    sp = row + (width - 1) * 4 + 3;
    dp = mask_row + ((width - 1) >> 3);

    shift = (width + 7) & 7;

    for (i = width; i; i--)
    {
        alpha = *sp ? 1 : 0;

        *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
        *dp |= (png_byte)(alpha << shift);

        if (shift == 0)
        {
            shift = 7;
            dp--;
        }
        else
            shift--;

        sp -= 4;
    }
}

void png_premultiply_and_gamma_correct(png_row_infop row_info, png_bytep row)
{
    int a, r, g, b, x;
    png_bytep file_to_1 = hack_to_1;
    png_bytep file_to_screen = hack_to_screen;

    if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        for (x = row_info->width ; x; x--)
        {
            r = *row++;
            g = *row++;
            b = *row++;
            a = *row++;

            if (a == 255)
            {
                row[-4] = file_to_screen[r];
                row[-3] = file_to_screen[g];
                row[-2] = file_to_screen[b];
            }
            else if (a == 0)
            {
                row[-4] = 0;
                row[-3] = 0;
                row[-2] = 0;
            }
            else
            {
                int a256 = a + (a >> 7);
                r = (file_to_1[r] * a256) >> 8;
                g = (file_to_1[g] * a256) >> 8;
                b = (file_to_1[b] * a256) >> 8;
                row[-4] = r;
                row[-3] = g;
                row[-2] = b;
            }
        }
    }
    else
    {
        for (x = row_info->width ; x; x--)
        {
            g = *row++;
            a = *row++;

            if (a == 255)
                row[-2] = file_to_screen[g];
            else if (a == 0)
                row[-2] = 0;
            else
            {
                int a256 = a + (a >> 7);
                g = (file_to_1[g] * a256) >> 8;
                row[-2] = g;
            }
        }
    }
}

/*****************************/


_kernel_oserror *SaveSpritePNG(Image *this, const char *filename, int maxbpp)
{
    return _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
}

static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig)
{
    *justuseorig=0;
    return SaveSpritePNG(this, filename, -1);
}

static _kernel_oserror *LoadFromCache(Image *this, const char *filename)
{
    _kernel_oserror *e;
    int length, transparent;

    e=_swix(OS_File, _INR(0,1)|_OUT(4), 20, filename, &length);

    if (!e)
    {
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4))
            return pngError("Insufficient memory");
    }

    if (!e)
    {
        this->private_data2[0]=length+4;
        this->private_data2[2]=16;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    }

    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2), 256+10, this->private_data2, filename);

    transparent = this->transparent;
    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 256+40, this->private_data2, filename,
                                                   &this->width, &this->height,
                                                   &transparent);
    this->transparent = transparent;

    if (!e)
    {
        this->mutable_mask=this->transparent;
        if (this->width_os==-1)
            this->width_os=2*this->width;
        if (this->height_os==-1)
            this->height_os=2*this->height;
    }

    return e;
}

static _kernel_oserror *EndLoad(Image *this, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    #ifdef TRACE
    if (load->trace)
        fclose(load->trace);
    #endif

    memset(changed, 0, sizeof(BBox));

    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

    if (load->temp)
        flex_free((flex_ptr) &load->temp);

    /*free(this->private_data);
    this->private_data=NULL;*/

    if (this->width_os==-1)
        this->width_os=2*this->width; /*180*this->width/xres;*/
    if (this->height_os==-1)
        this->height_os=2*this->height; /*180*this->height/yres;*/

    return NULL;
}

static _kernel_oserror *Delete(Image *this)
{
    PNGloaddata *load;

    if (!this)
        return NULL;

    load=(PNGloaddata *) this->private_data;
    if (load)
    {
        if (load->png_ptr)
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

        free(load->file_to_1);
        free(load->file_to_screen);
        free(load);
    }

    if (this->private_data2)
        flex_free((flex_ptr) &this->private_data2);

    free(this);

    return NULL;
}

static _kernel_oserror *ModeChange(Image *this)
{
    _kernel_oserror *e=0;
    int bufsize;

    ct32k_buffer[0] = 0;

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);
    if (e) return e;

    /*don't need a table if going into 16 or 32bpp*/

    if (!this)
        return NULL;

    if (log2bpp <= 3)
    {
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2, "png", -1, -1,
                                                    0, 0, &bufsize);

        if (!e)
        {
            free(this->table);
            this->table=malloc(bufsize);
            if (!this->table)
                e=pngError("Insufficient memory");
        }

        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2, "png", -1, -1,
                                                    this->table, 0);
    }

    if (!e)
    e=_swix(Wimp_ReadPixTrans, _INR(0,2)|_INR(6,7), 256, this->private_data2, "png",
                                                    this->factors, 0);

    if (!e)
    {
        this->factors[0]*=this->width_os;
        this->factors[1]*=this->height_os;
        this->factors[2]*=this->width*2;
        this->factors[3]*=this->height*2;
    }
    return e;
}

static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing);

static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    _kernel_oserror *e=NULL;
    int fac[4];

    if (!this || !this->private_data2)
        return pngError("Broken PNG");

    if (this->width <= 0)
    {
        e=_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), 0, 0, 0);
        if (!e)
            e=_swix(OS_Plot, 4, x, y);
        if (!e)
            e=_swix(OS_Plot, 0x60 | 1, this->width_os*scale/100-1,
                                       this->height_os*scale/100-1);
        return e;
    }

    if (this->modechanged || !this->factors[0])
    {
        e=ModeChange(this);
        if (e) return e;
        this->modechanged = 0;
    }

    if (this->full_alpha)
    {
        int job = 0;
        _swix(PDriver_CurrentJob, _OUT(0), &job);
        if (job || log2bpp >= 3)
            return RenderWithAlpha(this, x, y, scale, x_size, y_size, job ? (osver >= 0xA5 ? 5 : 3) : log2bpp, job);
    }

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (!e)
    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    this->private_data2,
                                    "png",
                                    x, y,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                    PutSpriteScaled_UseMask
                                                  : PutSpriteScaled_UseMask,
                                    fac,
                                    log2bpp <=3 ? this->table : 0);

    return e;
}

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp);

/*
 * Assumes : log2bpp = 3,4,5
 */
static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing)
{
    int bgmem;
    int bgwidth;
    int mode;
    sprite_area *bgarea;
    int oldsw0, oldsw1, oldsw2, oldsw3;
    int savesize;
    void *table = 0, *savearea = 0;
    int fac[4];
    _kernel_oserror *e;
    int oldbudge, oldcompact;
    int *palette = 0;
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    #define imagename "image"
    /*char imagename[12];*/
    static int imageno;
    int width = this->width, height = this->height;
    int clipoffset = 0, xo = 0, yo = 0;

    if (!printing)
    {
        static const int vdu_list[] = { 128,129,130,131,4,5,136,137,-1 };
        struct
        {
            BBox clip;
            int xeig, yeig;
            int ox, oy;
        } var;

        e = _swix(OS_ReadVduVariables, _INR(0,1), vdu_list, &var);
        if (e) return e;

        if (x_size > 0 && y_size > 0)
        {
            if (width * 2 != x_size ||
                height * 2 != y_size)
                goto dont_clip;
        }
        else if (scale != 100)
            goto dont_clip;

        var.clip.xmin = (var.clip.xmin << var.xeig) + var.ox;
        var.clip.ymin = (var.clip.ymin << var.yeig) + var.oy;
        var.clip.xmax = ((var.clip.xmax+1) << var.xeig) + var.ox;
        var.clip.ymax = ((var.clip.ymax+1) << var.yeig) + var.oy;

        if (var.clip.xmax < x || var.clip.xmin >= x + x_size ||
            var.clip.ymax < y || var.clip.ymin >= y + y_size)
            return NULL;

        if (var.clip.xmin < x) var.clip.xmin = x;
        if (var.clip.xmax > x + x_size) var.clip.xmax = x + x_size;
        if (var.clip.ymin < y) var.clip.ymin = y;
        if (var.clip.ymax > y + y_size) var.clip.ymax = y + y_size;

        var.clip.xmin -= x; var.clip.ymin -= y;
        var.clip.xmax -= x; var.clip.ymax -= y;

        var.clip.xmin >>= 1;
        var.clip.ymin >>= 1;
        var.clip.xmax = (var.clip.xmax + 1) >> 1;
        var.clip.ymax = (var.clip.ymax + 1) >> 1;

        width = var.clip.xmax - var.clip.xmin;
        height = var.clip.ymax - var.clip.ymin;
        if (width <= 0 || height <= 0)
            return NULL;

        if (height < 4)
        {
            if (var.clip.ymin >= 4)
                var.clip.ymin -= 4 - height;
            else
                var.clip.ymax += 4 - height;
            height = 4;
        }
        if (width < 4)
        {
            if (var.clip.xmin >= 4)
                var.clip.xmin -= 4 - width;
            else
                var.clip.xmax += 4 - width;
            width = 4;
        }
        xo = -2 * var.clip.xmin;
        yo = -2 * var.clip.ymin;
        clipoffset = var.clip.xmin;
        if (load->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            clipoffset *= 4;
        clipoffset += (this->height - var.clip.ymax) * load->spritewidth;

        /*_swix(OS_WriteI + 4, 0);
        _swix(OS_WriteI + 30, 0);
        printf("width = %d, height = %d, xo = %d, yo = %d, clipoffset = %x                ", width, height, xo, yo, clipoffset);
        _swix(OS_WriteI + 5, 0);*/
    }

  dont_clip:

    bgmem = 16 + 44;
    bgwidth = width * (1 << (log2bpp - 3));
    bgwidth = (bgwidth + 3) &~ 3;
    bgmem += bgwidth * height;
    if (log2bpp == 3) bgmem += 2*4*256;

    if (!flex_alloc((flex_ptr)&bgarea, bgmem))
    /*bgarea = malloc(bgmem);
    if (!bgarea)*/
        return pngError("Can't get memory for background image.");

    oldbudge = flex_set_budge(0);
    oldcompact = flex_set_deferred_compaction(0);

    switch (log2bpp)
    {
        case 3: mode = 28;              break;
        case 4: mode = MODE(5, 90, 90); break;
        case 5: mode = MODE(6, 90, 90); break;
    }

    /*sprintf(imagename, "%x", imageno++);*/

    bgarea->size   = bgmem;
    bgarea->sproff = sizeof(sprite_area);
    e = _swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, bgarea);
    if (e) goto error1;
    e = _swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, bgarea, imagename,
                                      0, width, height,
                                      mode);
    if (e) goto error1;

    if (log2bpp == 3)
    {
        e = _swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, bgarea, imagename, (1U<<31)+1);
        if (e) goto error1;
        e = _swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 256+SprAddPalette, bgarea, imagename, -1, &palette);
        if (e) goto error1;
        e = _swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, palette, 256*4*2, 2);
        if (e) goto error1;
    }

    e =_swix(OS_SpriteOp, _INR(0,2)|_OUT(3), 256+SprSaveAreaSize, bgarea, imagename, &savesize);
    if (e) goto error1;

    savearea = calloc(savesize, 1);

    e = _swix(OS_SpriteOp, _INR(0,3)|_OUTR(0,3), 256+SprSwitchVdu, bgarea, imagename, savearea,
                                                 &oldsw0, &oldsw1, &oldsw2, &oldsw3);
    if (e) goto error2;

    if (xo != 0 || yo != 0)
    {
        char cmd[5];
        cmd[0] = 29;
        cmd[1] = xo & 0xFF;
        cmd[2] = xo >> 8;
        cmd[3] = yo & 0xFF;
        cmd[4] = yo >> 8;
        e = _swix(OS_WriteN, _INR(0,1), cmd, 5);
    }

    #ifdef RANDOM_BG
    e = _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), rand() << 8, 0x180, 0);
    if (e) goto error2;

    e = _swix(OS_WriteI + 16, 0); /* CLG */
    if (e) goto error2;
    #else

    if (!e) e = load->filler(load->filler_handle1, load->filler_handle2);
    #endif

    _swix(OS_SpriteOp, _INR(0,3), oldsw0, oldsw1, oldsw2, oldsw3);

    if (e) goto error2;

    blend_image(width, height,
                (char *) this->private_data2 + load->sprite_offset + clipoffset,
                (char *) this->private_data2 + load->mask_offset + clipoffset,
                this->private_data2 + 4 + 11,
                load->color_type,
                load->spritewidth,
                (char *) (bgarea + 1) + ((sprite_header *)(bgarea + 1))->image,
                bgwidth,
                (int *) ((char *) bgarea + 16 + 44),
                log2bpp);

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (log2bpp == 3 || printing)
    {
        int bufsize;

        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), bgarea, imagename, -1, -1,
                                           0, 0, &bufsize);
        if (e) goto error2;

        table = malloc(bufsize);
        if (!table)
        {
            e=pngError("Insufficient memory");
            goto error2;
        }

        e=_swix(ColourTrans_GenerateTable, _INR(0,5), bgarea, imagename, -1, -1,
                                           table, 0);
        if (e) goto error2;
    }

    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    bgarea,
                                    imagename,
                                    x - xo, y - yo,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette
                                                  : 0,
                                    fac,
                                    table);

    free(table);
 error2:
    free(savearea);
 error1:
    flex_set_budge(oldbudge);
    flex_set_deferred_compaction(oldcompact);

    flex_free((flex_ptr) &bgarea);

    return e;
}

static _kernel_oserror *StartExportPNG(Image *this, int *size)
{
    *size=this->private_data2[0]-4;

    return StartExport((flex_ptr) &this->private_data2, this->private_data2[0]-4, 4);
}

static _kernel_oserror *BGColPNG(Image *this, int *bgcol)
{
    _kernel_oserror *e;
    int size, *sphead;
    void *mode;
    Spriteloaddata *l;
    char temp[16];
    int bufsiz;
    void *colbuf;
    int fac[4];
    int r1, r2, r3;
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int nw, nh, log2bpp;

    e=BGCol(this->private_data2, bgcol);
    if (e)
        return e;

    if (!(this->flags & IMAGE_FAST))
        return NULL;

    l = (Spriteloaddata *)malloc(sizeof *l);
    if (!l)
        return NULL;

    this->flags &= ~IMAGE_FAST;
    /*
     * Right, this is obviously a background image, so lets munge it into
     * a sprite of the current mode and palette!
     */
    _swix(OS_Byte, _IN(0)|_OUT(2), 135, &mode);
    log2bpp=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);

    /* Find first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, this->private_data2, temp, sizeof temp, 1);
    if (e)
        return NULL;

    /* Get pointer to it */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+24, this->private_data2, temp, &sphead);
    if (e)
        return NULL;

    /* Get scale factors */
    _swix(Wimp_ReadPixTrans, _INR(0,2) |_INR(6,7), 0x200, this->private_data2, sphead, fac, 0);
    nw=this->width * fac[0] / fac[2];
    nh=this->height * fac[1] / fac[3];

    size = SpriteAreaSize(mode, nw, nh);
    if (log2bpp <= 3)
        /* Add the palette... */
        size += 8 << (1 << log2bpp);

    if (flex_midextend((flex_ptr) &this->private_data2, 0, size) == 0)
        return NULL;

    sphead=(int *)((char *)sphead + size);
    this->private_data2[0]=size;
    this->private_data2[2]=16;
    /* Initialise sprite area */
    _swix(OS_SpriteOp, _INR(0,1), 0x109, this->private_data2);
    /* Create sprite */
    e=_swix(OS_SpriteOp, _INR(0,6), 0x10f, this->private_data2, "sprite",
                                    0, nw, nh, mode);
    /* Add the palette */
    if (!e && log2bpp <= 3)
    {
        void *palette;
        e=_swix(OS_SpriteOp, _INR(0,3), 0x125, this->private_data2, "sprite", (1U<<31)+1);
        if (!e)
            e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 0x125, this->private_data2, "sprite", -1, &palette);
        if (!e)
            e=_swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, palette, 8<<(1<<log2bpp), 2);
    }
    if (e)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }
#define ORIG ((int *)((char *)this->private_data2+size))

    _swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                     ORIG, sphead, -1, -1, 0, 1, &bufsiz);

    colbuf = malloc(bufsiz);
    if (!colbuf)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }

    _swix(ColourTrans_GenerateTable, _INR(0,5), ORIG, sphead, -1, -1, colbuf, 1);

    /* Switch output to it */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, this->private_data2, "sprite", 0,
                                               &r1, &r2, &r3);
    if (e)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }

    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), *bgcol, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    /* Plot sprite */
    _swix(OS_SpriteOp, _INR(0,7), 512+52, ORIG, sphead, 0, 0, 8+16, fac, colbuf);

    /* Unswitch output */
    _swix(OS_SpriteOp, _INR(0,3), 0x13c, r1, r2, r3);

    free(colbuf);

    flex_midextend((flex_ptr) &this->private_data2, size+ORIG[0], -ORIG[0]);

    if (load)
    {
        free(this->private_data);
    }
    free(this->table);

    this->DumpSprite=SpriteDumpSprite;
    this->Render=RenderSprite;
    this->ModeChange=ModeChangeSprite;
    this->DumpToCache=DumpToCacheSprite;
    this->StartExport=StartExportSprite;
    this->Export=Export;
    this->EndExport=EndExport;
    this->Delete=DeleteSprite;
    this->private_data=l;
    this->transparent=0;
    this->mutable_mask=0;
    this->width=nw;
    this->height=nh;

    l->memory=size;
    l->xeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 4);
    l->yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 5);
    l->bpp =_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);
    l->pal =0;
    this->table = 0;
    this->factors[0]=this->factors[1]=this->factors[2]=this->factors[3]=1;
    strcpy(l->name, "sprite");
    return NULL;
}

static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2)
{
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->filler = fill_fn;
    load->filler_handle1 = handle1;
    load->filler_handle2 = handle2;

    return 0;
}

#define blend(dest, alpha_dest, src)               \
          {                                        \
              if (dest) dest *= (alpha_dest);      \
              dest = (dest >> 8) + src;            \
          }

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp)
{
    int bgdepth = 1 << (bglog2bpp - 3);
    int red, green, blue;
    int bgred, bggreen, bgblue;
    unsigned int fg, bg;
    int alpha, bg_alpha;
    int x, y;
    char *s, *m, *b;
    char *cttable;
    #ifdef DITHERING
    int dir=1;
    unsigned int result;
    int truered, truegreen, trueblue, result_red, result_green, result_blue;
    int error_red, error_green, error_blue;
    #endif

    if (bgdepth == 1 & !ct32k_buffer[0])
    {
        _kernel_oserror *e;

        /* Get the magic "table" from ColourTrans ( { '32K.', table_ptr, '32K. } ) */
        e = _swix(ColourTrans_GenerateTable, _INR(0,5), MODE(5, 90, 90), -1, -1, -1, ct32k_buffer, 0);
        if (e) return;
    }
    cttable = (char *)ct32k_buffer[1];

    for (y = height; y; y--)
    {
        s = sprdata;   sprdata   += rowwidth;
        m = maskdata;  maskdata  += rowwidth;
        b = bgsprdata; bgsprdata += bgrowwidth;

        #ifdef DITHERING
        if (dir == -1)
        {
            if (type == PNG_COLOR_TYPE_RGB_ALPHA)
                s += (width-1) * 4;
            else
                s += width-1;
            m += width-1;
            b += (width-1) * bgdepth;
        }

        error_red = error_green = error_blue = 0;
        #endif

        for (x = width; x; x--)
        {
            switch (type)
            {
              case PNG_COLOR_TYPE_PALETTE:
                #ifdef DITHERING
                fg = palette[*s * 2];
                s += dir;
                #else
                fg = palette[*s++ * 2];
                #endif
                alpha = fg & 0xFF;
                if (alpha == 0)
                {
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (dir == 1)
                        b += bgdepth;
                    else
                        b -= bgdepth;
                    #else
                    b += bgdepth;
                    #endif
                    continue;
                }
                blue = fg >> 24;
                green = (fg >> 16) & 0xFF;
                red = (fg >> 8) & 0xFF;
                break;

              case PNG_COLOR_TYPE_GRAY_ALPHA:
                #ifdef DITHERING
                alpha = *m;
                m += dir;
                #else
                alpha = *m++;
                #endif
                if (alpha == 0)
                {
                    #ifdef DITHERING
                    s += dir;
                    #else
                    s++;
                    #endif
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (dir == 1)
                        b += bgdepth;
                    else
                        b -= bgdepth;
                    #else
                    b += bgdepth;
                    #endif
                    continue;
                }
                #ifdef DITHERING
                red = green = blue = *s;
                s += dir;
                #else
                red = green = blue = *s++;
                #endif
                break;

              case PNG_COLOR_TYPE_RGB_ALPHA:
                fg = *((int *) s);
                #ifdef DITHERING
                s += 4 * dir;
                #else
                s += 4;
                #endif
                alpha = fg >> 24;
                if (alpha == 0)
                {
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (dir == 1)
                        b += bgdepth;
                    else
                        b -= bgdepth;
                    #else
                    b += bgdepth;
                    #endif
                    continue;
                }
                blue = (fg >> 16) & 0xFF;
                green = (fg >> 8) & 0xFF;
                red = fg & 0xFF;
                break;
            }

            if (alpha != 255)
            {
                switch (bgdepth)
                {
                  case 1:
                    bg = bgpalette[*b * 2];
                    bgblue = bg >> 24;
                    bggreen = (bg >> 16) & 0xFF;
                    bgred = (bg >> 8) & 0xFF;
                    break;

                  case 2:
                  {
                    bg = *((unsigned short *) b);
                    bgred   = (bg << 3) & 0xF8; bgred   |= bgred   >> 5;
                    bggreen = (bg >> 2) & 0xF8; bggreen |= bggreen >> 5;
                    bgblue  = (bg >> 7) & 0xF8; bgblue  |= bgblue  >> 5;
                    break;
                  }

                  case 4:
                    bg = *((unsigned int *) b);
                    bgblue = (bg >> 16) & 0xFF;
                    bggreen = (bg >> 8) & 0xFF;
                    bgred = bg & 0xFF;
                    break;
                }

                alpha = alpha + (alpha >> 7);   /* Rescale to 0..256 */
                bg_alpha = 256 - alpha;

                /*
                 * The background we captured is gamma adjusted for the
                 * screen - get back to linear before we do the maths
                 */
                bgblue  = screen_to_1[bgblue];
                bggreen = screen_to_1[bggreen];
                bgred   = screen_to_1[bgred];

                /*
                 * (Partially opaque colours in the image are already
                 * linear)
                 */

                blend(bgblue,  bg_alpha, blue);
                blend(bggreen, bg_alpha, green);
                blend(bgred,   bg_alpha, red);

                #if defined(DITHERING) && defined(GAMMA_DITHER)
                bgblue += error_blue;
                bggreen += error_green;
                bgred += error_red;
                if (bgblue < 0) bgblue = 0; else if (bgblue > 255) bgblue = 255;
                if (bggreen < 0) bggreen = 0; else if (bggreen > 255) bggreen = 255;
                if (bgred < 0) bgred = 0; else if (bgred > 255) bgred = 255;
                truered = bgred;
                truegreen = bggreen;
                trueblue = bgblue;
                #endif

                bgblue  = screen_from_1[bgblue];
                bggreen = screen_from_1[bggreen];
                bgred   = screen_from_1[bgred];
            }
            else
            {
                /*
                 * Fully opaque case - we "cheat" by stored fully screen
                 * gamma corrected data in this case only!
                 */
                #ifdef GAMMA_DITHER
                blue += error_blue;
                green += error_green;
                red += error_red;
                if (blue < 0) blue = 0; else if (blue > 255) blue = 255;
                if (green < 0) green = 0; else if (green > 255) green = 255;
                if (red < 0) red = 0; else if (red > 255) red = 255;
                truered = red;
                truegreen = green;
                trueblue = blue;
                bgblue  = screen_from_1[blue];
                bggreen = screen_from_1[green];
                bgred   = screen_from_1[red];
                #else
                bgblue = blue;
                bggreen = green;
                bgred = red;
                #endif
            }

            #if defined(DITHERING) && !defined(GAMMA_DITHER)
            bgblue += error_blue;
            bggreen += error_green;
            bgred += error_red;
            if (bgblue < 0) bgblue = 0; else if (bgblue > 255) bgblue = 255;
            if (bggreen < 0) bggreen = 0; else if (bggreen > 255) bggreen = 255;
            if (bgred < 0) bgred = 0; else if (bgred > 255) bgred = 255;
            truered = bgred;
            truegreen = bggreen;
            trueblue = bgblue;
            #endif

            if (bgdepth != 4)
                bg = ((bgblue & 0xF8) << 7) | ((bggreen & 0xF8) << 2) | (bgred >> 3);
            else
                bg = (bgblue << 16) | (bggreen << 8) | bgred;

            switch (bgdepth)
            {
              case 1:
              {
                int c = cttable[bg];
                #ifdef DITHERING
                *b = c;
                if (dir == 1)
                    b++;
                else
                    b--;
                result = bgpalette[c * 2];
                result_blue = result >> 24;
                result_green = (result >> 16) & 0xFF;
                result_red = (result >> 8) & 0xFF;
                #else
                *b++ = c;
                #endif
                break;
              }
              case 2:
                *(unsigned short *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 2;
                else
                    b -= 2;
                result_red = (bgred & 0xF8) | (bgred >> 5);
                result_green = (bggreen & 0xF8) | (bggreen >> 5);
                result_blue = (bgblue & 0xF8) | (bgblue >> 5);
                #else
                b += 2;
                #endif
                break;
              case 4:
                *(unsigned int *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 4;
                else
                    b -= 4;
                #else
                b += 4;
                #endif
                continue;
            }

            #ifdef DITHERING
            #ifdef GAMMA_DITHER
            error_red = truered - screen_to_1[result_red];
            error_green = truegreen - screen_to_1[result_green];
            error_blue = trueblue - screen_to_1[result_blue];
            #else
            error_red = truered - result_red;
            error_green = truegreen - result_green;
            error_blue = trueblue - result_blue;
            #endif
            #endif

        } /* end x loop */

        dir = -dir;

    } /* end y loop */

}
