/*-------------------------------------------------------------------------------------------*/
/* File:    c.png                                                                            */
/* Purpose: PNG plotting component of the image library.                                     */
/* Author:  Kevin Bracey                                                                     */
/* History: 06-May-97: RML: Modified Render routine to take an x and y size to scale to,     */
/*                          instead of a percentage.                                         */
/*-------------------------------------------------------------------------------------------*/

/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <string.h>
#include <stdlib.h>
#ifdef TRACE
#include <stdio.h>
#endif

#include "swis.h"

#include "imagetrans.h"
#include "internal.h"
#include "png.h"
#include "sprite.h"

#define PNG_INTERNAL  /* Give ourselves slightly more intimate access */
#include "PNG/png.h"

#include "riscospal.h"

typedef unsigned char bool;
#define false 0
#define true 1

/*#define GIVE_WARNINGS*/

#define MODE(t,x,y) (((t) << 27) | ((x) << 14) | ((y) << 1) | 1)

#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define pngError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

static int osver;
static int log2bpp;

static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *EndLoad(Image *this, BBox *changed);
static _kernel_oserror *Delete(Image *this);
static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size);
static _kernel_oserror *ModeChange(Image *this);
static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig);
static _kernel_oserror *LoadFromCache(Image *this, const char *filename);
static _kernel_oserror *StartExportPNG(Image *this, int *size);
static _kernel_oserror *BGColPNG(Image *this, int *bgcol);

typedef struct png_loaddata
{
    int spritewidth;
    int maskwidth;
    unsigned int finished:1;
    unsigned int eightbpphack:1; /* Processing 8bpp + alpha data */
    #ifdef TRACE
    FILE *trace;
    #endif
    png_struct *png_ptr;
    png_info *info_ptr;
    int sprite_offset;
    int mask_offset;
    const char *errmess;
    BBox changed;
    png_byte *temp;
} PNGloaddata;

static void info_callback(png_struct *, png_info *);
static void row_callback(png_struct *, png_byte *, png_uint_32, int);
static void end_callback(png_struct *, png_info *);

static void my_error_fn(png_struct *png_ptr, png_const_charp errmess)
{
    *(const char **)png_get_error_ptr(png_ptr) = errmess;
}

#ifdef GIVE_WARNINGS
static void my_warn_fn(png_struct *png_ptr, png_const_charp errmess)
{
    _kernel_oserror er;
    er.errnum = 1;
    strcpy(er.errmess, errmess);
    wimp_report_error(&er, 0, "LibPNG");
}
#endif

int NewPNG(Image *im)
{
    PNGloaddata *load;
    png_info *info_ptr;
    png_struct *png_ptr;
    int oldbudge;

    oldbudge = flex_set_budge(1);

    load=(PNGloaddata *)(im->private_data=malloc(sizeof(PNGloaddata)));

    if (!load)
        goto abort1;

    memset(load, 0, sizeof *load);

    /* Sort out error functions */
#ifdef GIVE_WARNINGS
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, my_warn_fn);
#else
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, NULL);
#endif
    if (!png_ptr)
        goto abort2;

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
        goto abort3;

    png_set_progressive_read_fn(png_ptr, im, info_callback, row_callback, end_callback);

#ifdef GIVE_WARNINGS
    png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_DISCARD);
#else
    png_set_crc_action(png_ptr, PNG_CRC_ERROR_QUIT, PNG_CRC_WARN_DISCARD);
#endif

    if (osver==0)
        _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    im->Load=LoadPNG;
    im->DumpSprite=SaveSpritePNG;
    im->EndLoad=EndLoad;
    im->Delete=Delete;
    im->Render=Render;
    im->ModeChange=ModeChange;
    im->LoadFromCache=LoadFromCache;
    im->DumpToCache=DumpToCache;
    im->StartExport=StartExportPNG;
    im->Export=Export;
    im->EndExport=EndExport;
    im->BGCol=BGColPNG;
    im->NeedRedraw=0;
    im->RegisterFiller=0;

    im->table=NULL;
    im->private_data2=NULL;
    im->width=im->height=im->width_os=im->height_os=-1;
    im->animated=0;

    memset(im->factors, 0, sizeof im->factors);

    im->transparent=0;
    im->mutable_mask=0;
    im->private_data=load;

    load->png_ptr = png_ptr;
    load->info_ptr = info_ptr;

    #ifdef TRACE
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%p", im);
        load->trace=fopen(name, "w");
    }
    #endif

    flex_set_budge(oldbudge);

    return 0;

  abort3:
    png_destroy_read_struct(&png_ptr, (png_infopp) NULL, (png_infopp) NULL);
  abort2:
    free(load);
  abort1:
    flex_set_budge(oldbudge);
    return -1;
}

/*****************************/
static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    volatile int oldbudge = -1;

    if (changed)
        memset(changed, 0, sizeof(BBox));

    load->changed.xmin = 0;
    load->changed.ymin = 0x10000000;
    load->changed.xmax = 0;
    load->changed.ymax = 0;

    if (setjmp(load->png_ptr->jmpbuf))
    {
        flex_set_budge(oldbudge);

        return pngError(load->errmess);
    }

    oldbudge = flex_set_budge(0);

    png_process_data(load->png_ptr, load->info_ptr, (png_byte *) data, len);

    flex_set_budge(oldbudge);

    if (changed)
    	*changed = load->changed;

    return NULL;
}

void info_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int mem;
    unsigned int mode;
    int pal_entries;
    _kernel_oserror *e;
    int r1, r2, r3;
    int background;
    png_color *palette;
    int num_palette;
    bool have_mask;
    int riscos_rowbytes;


    /* Only 8 bits per channel under RISC OS */
    if (info->bit_depth == 16)
    {
        png_set_strip_16(png_ptr);
    }

    if (info->bit_depth < 8)
        png_set_packswap(png_ptr);

    if (info->color_type == PNG_COLOR_TYPE_RGB ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver >= 0xA5)
        {
            /* Add a filler if alpha missing */
            if (info->color_type == PNG_COLOR_TYPE_RGB)
            {
                png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
            }

            mode = MODE(6,90,90);
        }
        else
        {
            /* If on an old OS, get it to spit out 8bpp data :-( */
            png_set_dither(png_ptr, riscospal, 256, 256, NULL, 0);
            mode = 28;
        }
    }
    else
    {
        switch (info->bit_depth)
        {
            case 1:  mode = 25; break;
            case 2:  mode = 26; break;
            case 4:  mode = 27; break;
            case 8:
            case 16: mode = 28; break;
        }
    }

    /* Can't handle 16bpp data with transparency - turn it into 8bpp with alpha */
    if (info->valid & PNG_INFO_tRNS)
    {
        if (info->bit_depth == 16 || info->color_type == PNG_COLOR_TYPE_RGB ||
                                     info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            png_set_expand(png_ptr);
    }

    if (info->valid & PNG_INFO_gAMA)
        png_set_gamma(png_ptr, 2.5, info->gamma);
    else
    	png_set_gamma(png_ptr, 2.5, 0.45);

    /* Enable filling in of interlace */
    png_set_interlace_handling(png_ptr);

    png_read_update_info(png_ptr, info);

    /*
     * Okay, we will now be getting data in one of these formats:
     *            1 bpp paletted/greyscale
     *            2 bpp paletted/greyscale
     *            4 bpp paletted/greyscale
     *            8 bpp paletted/greyscale
     *            8 bpp greyscale + alpha (=> 2 bytes per pixel)
     *           24 bpp colour (with or without alpha, 32 bit packed)
     */

    this->width = info->width;
    this->height = info->height;
    
    if (this->width_os==-1)
        this->width_os = info->width * 2;
    if (this->height_os==-1)
        this->height_os = info->height * 2;

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        riscos_rowbytes = info->width;
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        riscos_rowbytes = info->width * 4;
    else
        riscos_rowbytes = info->rowbytes;

    mem = 16  /* Sprite area header size */
         +44; /* Sprite header size */

    if ((info->color_type &~ PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY)
        num_palette = pal_entries = 1 << min(info->bit_depth, 8);
    else if (info->color_type == PNG_COLOR_TYPE_PALETTE)
    {
        num_palette = info->num_palette;
        if (num_palette > 16)     pal_entries = 256;
        else if (num_palette > 4) pal_entries = 16;
        else if (num_palette > 2) pal_entries = 4;
        else                      pal_entries = 2;
    }
    else
        num_palette = pal_entries = 0;

    mem += 8 * pal_entries;

    load->spritewidth = (riscos_rowbytes+3)&~3;

    mem += load->spritewidth * info->height;

    if ((info->color_type & PNG_COLOR_MASK_ALPHA) || (info->valid & PNG_INFO_tRNS))
    {
       if (mode > 28)
          load->maskwidth = (load->spritewidth / 32 + 3) &~ 3;
       else
          load->maskwidth = load->spritewidth;

       mem += load->maskwidth * info->height;

       have_mask = true;
    }
    else
       have_mask = false;

    if (!flex_alloc((flex_ptr)&this->private_data2, mem))
    {
        load->errmess = "Insufficient memory";
        longjmp(png_ptr->jmpbuf, 1);
    }

    /* Create the sprite now */
    this->private_data2[0] = mem;
    this->private_data2[2] = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    if (e)
        goto error;

    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                            this->width, this->height, mode);
    if (e)
        goto error;

    /* Sort out the mask */
    if (have_mask)
    {
        e=_swix(OS_SpriteOp, _INR(0,2), 256+29, this->private_data2, "png");
        if (e)
            goto error;


    	/* Clear the mask */
    	_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+61, this->private_data2, "png", 0,
    	    	    	    	    	     	&r1, &r2, &r3);
    	_swix(OS_SetColour, _INR(0,1), 0x10, 0);
    	_swix(OS_WriteI + 16, 0);
    	_swix(OS_SpriteOp, _INR(0,3), 256+61, r1, r2, r3);
    }

    /* Create and fill in the palette */
    if (pal_entries)
    {
        int i, c;

        e=_swix(OS_SpriteOp, _INR(0,3), 256+37, this->private_data2, "png",
                                        pal_entries == 256 ? (1U<<31) + 1 : 1);
        if (e)
            goto error;

        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            palette = png_malloc(png_ptr, num_palette * sizeof(png_color));
            png_build_grayscale_palette(min(info->bit_depth, 8), palette);
        }
        else
            palette = info->palette;

        for (i = 0; i < pal_entries; i++)
        {
            c = (palette[i].blue << 24) |
                (palette[i].green << 16) |
                (palette[i].red << 8);
            this->private_data2[15 + i * 2] =
            this->private_data2[15 + i * 2 + 1] = c;
        }

        if (info->color_type == PNG_COLOR_TYPE_GRAY ||
            info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            png_free(png_ptr, palette);
        }
    }

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 2))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }


    load->sprite_offset = 16 + this->private_data2[12];
    if (have_mask)
    {
        load->mask_offset=16 + this->private_data2[13];
        if (info->interlace_type == 1)
            this->mutable_mask = true;
    }

    /* Clear the background */
    background = ((info->background.blue>>(info->bit_depth-8))<<24) |
                 ((info->background.green>>(info->bit_depth-8))<<16) |
                 ((info->background.red>>(info->bit_depth-8))<<8);

    _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
    	    	    	    	    	     &r1, &r2, &r3);
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), background, 128, 0);
    _swix(OS_WriteI + 16, 0);
    _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);

    return;

  error:
    load->errmess = e->errmess;
    longjmp(png_ptr->jmpbuf, 1);
}

static void process_transparency(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type);
static void process_alpha(const png_bytep row, png_bytep mask_row, png_uint_32 width);

void row_callback(png_struct *png_ptr, png_byte *new_row, png_uint_32 row_num, int pass)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    png_info *info = load->info_ptr;
    png_byte *row, *mask_row, *our_row;
    int y;

    int oldbudge = flex_set_budge(0);

         row = (png_byte *) this->private_data2 +
                            load->sprite_offset +
                            load->spritewidth * row_num;

    mask_row = (png_byte *) this->private_data2 +
                            load->mask_offset +
                            load->maskwidth * row_num;

    /* Expand our separate mask + color data into the interleaved format the library
       expects... */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        int i;
        png_byte *dp, *sp, *mp;

        sp = row + (info->width - 1);
        mp = mask_row + (info->width - 1);
        dp = load->temp + (info->width - 1) * 2;
        for (i = info->width; i; i--)
        {
            *dp = *sp;
            *(dp + 1) = *mp;
            dp-=2;
            sp--; mp--;
        }

        our_row = row;
        row = load->temp;
    }

    png_progressive_combine_row(png_ptr, row, new_row);

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        /* And remerge... */
        int i;
        png_byte *dp, *sp, *mp;

        row = our_row;

        sp = load->temp + (info->width - 1) * 2;
        mp = mask_row + (info->width - 1);
        dp = row + (info->width - 1);
        for (i = info->width; i; i--)
        {
            *dp = *sp;
            *mp = *(sp + 1) ? 255 : 0;
            sp-=2;
            dp--; mp--;
        }
    }
    else if (info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
        process_alpha(row, mask_row, info->width);
    else if (info->valid & PNG_INFO_tRNS)
        process_transparency(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);

    flex_set_budge(oldbudge);

    load->changed.xmax = this->width_os;

    y = (this->height - row_num - 1) * 2;

    if (y + 2 > load->changed.ymax)
    	load->changed.ymax = y + 2;

    if (y < load->changed.ymin)
    	load->changed.ymin = y;
}

void end_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->finished = 1;
}

/*
 * process_transparency - deal with transparency specified by the tRNS chunk
 */
static void process_transparency(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
{
    int i;
    png_uint_32 mask1, mask2;
    png_byte *dp, *sp;
    int s_start, s_inc, shift;
    png_byte alpha;

    switch (depth)
    {
      case 1:
        shift = s_start = 7;
        s_inc = -1;
        mask1 = 0x7f7f;
        mask2 = 1;
        break;

      case 2:
        shift = s_start = 6;
        s_inc = -2;
        mask1 = 0x3f3f;
        mask2 = 3;
        break;

      case 4:
        shift = s_start = 4;
        s_inc = -4;
        mask1 = 0xf0f;
        mask2 = 0xf;
        break;

      default:
        shift = s_start = 0;
        s_inc = 0;
        mask1 = 0;
        mask2 = 0xff;
        break;
    }

    sp =      row + (width - 1) * depth/8;
    dp = mask_row + (width - 1) * depth/8;

    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix < num_trans && trans[pix] == 0)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else if (color_type == PNG_COLOR_TYPE_GRAY)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix == trans_values->gray)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else /* color_type == PNG_COLOR_TYPE_RGB && bit_depth == 8 */
    {
        unsigned int trans_col = (trans_values->blue << 16) |
                                 (trans_values->green << 8) |
                                 trans_values->red;

        dp = mask_row + ((width - 1) >> 3);
        shift = 7;

        for (i = width; i; i--)
        {
            int pix;

            pix = *(int *) sp;
            if (pix & 0x00ffffff == trans_col)
                alpha = 0;
            else
                alpha = 1;

            *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = 7;
                dp--;
            }
            else
                shift--;

            sp -= 4;
        }
    }
}

static void process_alpha(const png_bytep row, png_bytep mask_row, png_uint_32 width)
{
    png_bytep sp;
    png_bytep dp;
    int shift, alpha, i;
    unsigned int pix;

    sp = row + (width - 1) * 4 + 3;
    dp = mask_row + ((width - 1) >> 3);

    shift = (width + 7) & 7;

    for (i = width; i; i--)
    {
        alpha = *sp ? 1 : 0;

        *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
        *dp |= (png_byte)(alpha << shift);

        if (shift == 0)
        {
            shift = 7;
            dp--;
        }
        else
            shift--;

        sp -= 4;
    }
}

/*****************************/


_kernel_oserror *SaveSpritePNG(Image *this, const char *filename, int maxbpp)
{
    return _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
}

static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig)
{
    *justuseorig=0;
    return SaveSpritePNG(this, filename, -1);
}

static _kernel_oserror *LoadFromCache(Image *this, const char *filename)
{
    _kernel_oserror *e;
    int length, transparent;

    e=_swix(OS_File, _INR(0,1)|_OUT(4), 20, filename, &length);

    if (!e)
    {
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4))
            return pngError("Insufficient memory");
    }

    if (!e)
    {
        this->private_data2[0]=length+4;
        this->private_data2[2]=16;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    }

    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2), 256+10, this->private_data2, filename);

    transparent = this->transparent;
    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 256+40, this->private_data2, filename,
                                                   &this->width, &this->height,
                                                   &transparent);
    this->transparent = transparent;

    if (!e)
    {
        this->mutable_mask=this->transparent;
        if (this->width_os==-1)
            this->width_os=2*this->width;
        if (this->height_os==-1)
            this->height_os=2*this->height;
    }

    return e;
}

static _kernel_oserror *EndLoad(Image *this, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    #ifdef TRACE
    if (load->trace)
        fclose(load->trace);
    #endif

    memset(changed, 0, sizeof(BBox));

    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

    if (load->temp)
        flex_free((flex_ptr) &load->temp);

    free(this->private_data);
    this->private_data=NULL;

    if (this->width_os==-1)
        this->width_os=2*this->width; /*180*this->width/xres;*/
    if (this->height_os==-1)
        this->height_os=2*this->height; /*180*this->height/yres;*/

    return NULL;
}

static _kernel_oserror *Delete(Image *this)
{
    PNGloaddata *load;

    if (!this)
        return NULL;

    load=(PNGloaddata *) this->private_data;
    if (load)
    {
        if (load->png_ptr);
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

        free(load);
    }

    if (this->private_data2)
        flex_free((flex_ptr) &this->private_data2);

    free(this);

    return NULL;
}

static _kernel_oserror *ModeChange(Image *this)
{
    _kernel_oserror *e=0;
    int bufsize;

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);

    /*don't need a table if going into 16 or 32bpp*/

    if (log2bpp <= 3)
    {
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2, "png", -1, -1,
                                                    0, 0, &bufsize);

        if (!e)
        {
            free(this->table);
            this->table=malloc(bufsize);
            if (!this->table)
                e=pngError("Insufficient memory");
        }

        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2, "png", -1, -1,
                                                    this->table, 0);
    }

    if (!e)
    e=_swix(Wimp_ReadPixTrans, _INR(0,2)|_INR(6,7), 256, this->private_data2, "png",
                                                    this->factors, 0);

    if (!e)
    {
        this->factors[0]*=this->width_os;
        this->factors[1]*=this->height_os;
        this->factors[2]*=this->width*2;
        this->factors[3]*=this->height*2;
    }
    return e;
}

static _kernel_oserror *Render(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    _kernel_oserror *e=NULL;
    int fac[4];

    if (!this || !this->private_data2)
        return pngError("Broken PNG");

    if (this->width <= 0)
    {
        e=_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), 0, 0, 0);
        if (!e)
            e=_swix(OS_Plot, 4, x, y);
        if (!e)
            e=_swix(OS_Plot, 0x60 | 1, this->width_os*scale/100-1,
                                       this->height_os*scale/100-1);
        return e;
    }

    if (!this->factors[0])
        e=ModeChange(this);

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
      int xos, yos;
      
      xos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,4);
      yos = 1 << _swi(OS_ReadModeVariable,_IN(0)|_IN(1)|_RETURN(2),-1,5);

      fac[0]=x_size;
      fac[1]=y_size;
      fac[2]=this->width*xos;
      fac[3]=this->height*yos;
    }
    else if (scale!=100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (!e)
    e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                    this->private_data2,
                                    "png",
                                    x, y,
                                    osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                    PutSpriteScaled_UseMask
                                                  : PutSpriteScaled_UseMask,
                                    fac,
                                    log2bpp <=3 ? this->table : 0);

    return e;
}

static _kernel_oserror *StartExportPNG(Image *this, int *size)
{
    *size=this->private_data2[0]-4;

    return StartExport((flex_ptr) &this->private_data2, this->private_data2[0]-4, 4);
}

static _kernel_oserror *BGColPNG(Image *this, int *bgcol)
{
    _kernel_oserror *e;
    int size, *sphead;
    void *mode;
    Spriteloaddata *l;
    char temp[16];
    int bufsiz;
    void *colbuf;
    int fac[4];
    int r1, r2, r3;
    PNGloaddata *load;
    int nw, nh;

    e=BGCol(this->private_data2, 3, bgcol);
    if (e)
        return e;

    if (!(this->flags & IMAGE_FAST))
        return NULL;

    l = (Spriteloaddata *)malloc(sizeof *l);
    if (!l)
        return NULL;

    this->flags &= ~IMAGE_FAST;
    /*
     * Right, this is obviously a background image, so lets munge it into
     * a sprite of the current mode and palette!
     */
    _swix(OS_Byte, _IN(0)|_OUT(2), 135, &mode);

    /* Find first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, this->private_data2, temp, sizeof temp, 1);
    if (e)
        return NULL;

    /* Get pointer to it */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+24, this->private_data2, temp, &sphead);
    if (e)
        return NULL;

    /* Get scale factors */
    _swix(Wimp_ReadPixTrans, _INR(0,2) |_INR(6,7), 0x200, this->private_data2, sphead, fac, 0);
    nw=this->width * fac[0] / fac[2];
    nh=this->height * fac[1] / fac[3];

    size = SpriteAreaSize(mode, nw, nh);

    if (flex_midextend((flex_ptr) &this->private_data2, 0, size) == 0)
        return NULL;

    sphead=(int *)((char *)sphead + size);
    this->private_data2[0]=size;
    this->private_data2[2]=16;
    /* Initialise sprite area */
    _swix(OS_SpriteOp, _INR(0,1), 0x109, this->private_data2);
    /* Create sprite */
    e=_swix(OS_SpriteOp, _INR(0,6), 0x10f, this->private_data2, "sprite",
                                    0, nw, nh, mode);
    if (e)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }
#define ORIG ((int *)((char *)this->private_data2+size))

    _swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                     ORIG, sphead, -1, -1, 0, 1, &bufsiz);

    colbuf = malloc(bufsiz);
    if (!colbuf)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }

    _swix(ColourTrans_GenerateTable, _INR(0,5), ORIG, sphead, -1, -1, colbuf, 1);

    /* Switch output to it */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, this->private_data2, "sprite", 0,
                                               &r1, &r2, &r3);
    if (e)
    {
        flex_midextend((flex_ptr) &this->private_data2, size, -size);
        return NULL;
    }

    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), *bgcol, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    /* Plot sprite */
    _swix(OS_SpriteOp, _INR(0,7), 512+52, ORIG, sphead, 0, 0, 8+16, fac, colbuf);

    /* Unswitch output */
    _swix(OS_SpriteOp, _INR(0,3), 0x13c, r1, r2, r3);

    free(colbuf);

    flex_midextend((flex_ptr) &this->private_data2, size+ORIG[0], -ORIG[0]);

    load=(PNGloaddata *) this->private_data;
    if (load)
    {
        free(this->private_data);
    }
    free(this->table);

    this->DumpSprite=SpriteDumpSprite;
    this->Render=RenderSprite;
    this->ModeChange=ModeChangeSprite;
    this->DumpToCache=DumpToCacheSprite;
    this->StartExport=StartExportSprite;
    this->Export=Export;
    this->EndExport=EndExport;
    this->Delete=DeleteSprite;
    this->private_data=l;
    this->transparent=0;
    this->mutable_mask=0;
    this->width=nw;
    this->height=nh;

    l->memory=size;
    l->xeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 4);
    l->yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 5);
    l->bpp =_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);
    l->pal =0;
    this->table = 0;
    this->factors[0]=this->factors[1]=this->factors[2]=this->factors[3]=1;
    strcpy(l->name, "sprite");
    return NULL;
}
