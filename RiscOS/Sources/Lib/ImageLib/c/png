/*-------------------------------------------------------------------------------------------*/
/* File:    c.png                                                                            */
/* Purpose: PNG plotting component of the image library.                                     */
/* Author:  Kevin Bracey                                                                     */
/* History: 06-May-97: RML: Modified Render routine to take an x and y size to scale to,     */
/*                          instead of a percentage.                                         */
/*          21-Oct-97: KJB: Stopped attempting alpha processing on pre-RISC OS 3.5 machines. */
/*-------------------------------------------------------------------------------------------*/

/*
 * Copyright (c) 1996 Acorn RISC Technologies. All rights reserved.
 */

#include <string.h>
#include <stdlib.h>
#ifdef TRACE
#include <stdio.h>
#endif

#include "swis.h"

#include "imagetrans.h"
#include "defines.h"
#include "datastruct.h"
#include "internal.h"
#include "sprite.h"

#define PNG_INTERNAL  /* Give ourselves slightly more intimate access */
#include "PNG/png.h"

#include "png.h"

#include "riscospal.h"

typedef unsigned char bool;
#define false 0
#define true 1

#define SCREEN_GAMMA 2.2

#define DITHERING

/*#define GIVE_WARNINGS*/

#define MODE(t,x,y) (((t) << 27) | ((x) << 14) | ((y) << 1) | 1)

#define PutSprite 34
#define PutSpriteScaled 52
#define PutSpriteScaled_UseMask 0x08
#define PutSpriteScaled_UsePalette 0x10
#define PutSpriteScaled_WideTable 0x20
#define PutSpriteScaled_Dithered 0x40
#define GenerateTable_WideTable 0x10

#define pngError imgtrnsError

#define max(a, b) (a>b ? a : b)
#define min(a, b) (a<b ? a : b)

static int osver;
static int log2bpp;
static png_bytep screen_to_1, screen_from_1, hack_to_screen, hack_to_1;
static int ct32k_buffer[3];
static char *ro310_2nd_table;

static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed);
static _kernel_oserror *EndLoad(Image *this, BBox *changed);
static _kernel_oserror *Delete(Image *this);
static _kernel_oserror *RenderPNG(Image *this, int x, int y, int scale, int x_size, int y_size);
static _kernel_oserror *ModeChange(Image *this);
static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig);
static _kernel_oserror *LoadFromCache(Image *this, const char *filename);
static _kernel_oserror *StartExportPNG(Image *this, int *size);
static _kernel_oserror *BGColPNG(Image *this, int *bgcol, int dontoverride);
static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2);
static _kernel_oserror *SaveSpriteAlphaPNG(Image *this, const char *filename, int maxbpp);

typedef struct png_loaddata
{
    int spritewidth;
    int maskwidth;
    unsigned int finished:1;
    unsigned int eightbpphack:1; /* Processing 8bpp + alpha data */
    unsigned int have_bkgd:1;
    unsigned int have_bkgd_index:1;
    unsigned int isreally32bit:1;
    unsigned int convto16bit:1;
    unsigned int removemask:1;
    unsigned int bkgd;           /* Background colour (BBGGRRNN in file gamma, NN=palette number) */
    #ifdef TRACE
    FILE *trace;
    #endif
    png_struct *png_ptr;
    png_info *info_ptr;
    int sprite_offset;
    int mask_offset;
    int available_rows;
    const char *errmess;
    BBox changed;
    png_byte *temp;
    int color_type;
    png_bytep file_to_1;
    png_bytep file_to_screen;
    FillerFunction *filler;
    void *filler_handle1;
    int *filler_handle2;

} PNGloaddata;

static void info_callback(png_struct *, png_info *);
static void row_callback(png_struct *, png_byte *, png_uint_32, int);
static void end_callback(png_struct *, png_info *);

static void my_error_fn(png_struct *png_ptr, png_const_charp errmess)
{
    *(const char **)png_get_error_ptr(png_ptr) = errmess;
}

#ifdef GIVE_WARNINGS
static void my_warn_fn(png_struct *png_ptr, png_const_charp errmess)
{
    _kernel_oserror er;
    er.errnum = 1;
    strcpy(er.errmess, errmess);
    wimp_report_error(&er, 0, "LibPNG");
}
#endif

/*
 * Used on RISC OS 3.1, whose ColourTrans can't give us this table.
 */
static void load_inversetable(void)
{
    char fname[256];
    extern void colour_table_leaf_to_path(char *path, const char *leaf);
    _kernel_oserror *e;
    char *itable;

    colour_table_leaf_to_path(fname, "8desktop");

    itable = malloc(32768);
    if (!itable)
        return;

    e = _swix(OS_File, _INR(0,3), 16, fname, itable, 0);
    if (e)
    {
        free(itable);
        return;
    }

    ct32k_buffer[0] = 0x2E4B3233;
    ct32k_buffer[1] = (int) itable;
    ct32k_buffer[2] = 0x2E4B3233;
}

int NewPNG(Image *im)
{
    PNGloaddata *load;
    png_info *info_ptr;
    png_struct *png_ptr;
    int oldbudge;

    oldbudge = flex_set_budge(1);

    load=(PNGloaddata *)(im->private_data=malloc(sizeof(PNGloaddata)));

    if (!load)
        goto abort1;

    memset(load, 0, sizeof *load);

    /* Sort out error functions */
#ifdef GIVE_WARNINGS
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, my_warn_fn);
#else
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, &load->errmess, my_error_fn, NULL);
#endif
    if (!png_ptr)
        goto abort2;

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr)
        goto abort3;

    png_set_progressive_read_fn(png_ptr, im, info_callback, row_callback, end_callback);

#ifdef GIVE_WARNINGS
    png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_DISCARD);
#else
    png_set_crc_action(png_ptr, PNG_CRC_ERROR_QUIT, PNG_CRC_WARN_DISCARD);
#endif

    if (osver==0)
        _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    im->Load=LoadPNG;
    im->DumpSprite=SaveSpritePNG;
    im->EndLoad=EndLoad;
    im->Delete=Delete;
    im->Render=RenderPNG;
    /*im->ModeChange=ModeChange;*/
    im->LoadFromCache=LoadFromCache;
    im->DumpToCache=DumpToCache;
    im->StartExport=StartExportPNG;
    im->Export=Export;
    im->EndExport=EndExport;
    im->BGCol=BGColPNG;
    im->NeedRedraw=0;
    im->RegisterFiller=RegisterFiller;

    im->table=NULL;
    im->private_data2=NULL;
    im->width=im->height=im->width_os=im->height_os=-1;
    im->animated=0;

    memset(im->factors, 0, sizeof im->factors);

    im->transparent=0;
    im->mutable_mask=0;
    im->private_data=load;

    load->png_ptr = png_ptr;
    load->info_ptr = info_ptr;

    #ifdef TRACE
    {
        char name[256];
        sprintf(name, "ADFS::4.$.Trace.Lib.%p", im);
        load->trace=fopen(name, "w");
    }
    #endif

    flex_set_budge(oldbudge);

    return 0;

  abort3:
    png_destroy_read_struct(&png_ptr, (png_infopp) NULL, (png_infopp) NULL);
  abort2:
    free(load);
  abort1:
    flex_set_budge(oldbudge);
    return -1;
}

static int hourglass_on;

/*****************************/
static _kernel_oserror *LoadPNG(Image *this, const char *data, int len, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    volatile int oldbudge = -1;

    if (changed)
        memset(changed, 0, sizeof(BBox));

    load->changed.xmin = 0;
    load->changed.ymin = 0x10000000;
    load->changed.xmax = 0;
    load->changed.ymax = 0;

    if (setjmp(load->png_ptr->jmpbuf))
    {
        flex_set_budge(oldbudge);
        if (hourglass_on)
        {
            _swix(Hourglass_Off, 0);
            hourglass_on = 0;
        }

        return pngError(load->errmess);
    }

    oldbudge = flex_set_budge(-1);

    /*
     * Set these up for our hacky premultiply routine...
     */
    hack_to_1 = load->file_to_1;
    hack_to_screen = load->file_to_screen;

    png_process_data(load->png_ptr, load->info_ptr, (png_byte *) data, len);

    flex_set_budge(oldbudge);

    if (changed)
    	*changed = load->changed;

    return NULL;
}

void info_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int mem;
    unsigned int mode;
    int pal_entries;
    _kernel_oserror *e;
    int r1, r2, r3;
    png_color *palette;
    int num_palette;
    bool have_mask;
    int riscos_rowbytes;
    png_bytep trans = NULL;
    int num_trans = 0;
    png_color_16p trans_values = NULL;

    /* First decide if we're going to do alpha processing */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        this->full_alpha = 1;
    }
    else if (info->valid & PNG_INFO_tRNS)
    {
        png_get_tRNS(png_ptr, info, &trans, &num_trans, &trans_values);
        if (info->color_type == PNG_COLOR_TYPE_PALETTE)
        {
            int i;
            for (i = 0; i < num_trans; i++)
            {
                if (trans[i] != 0 && trans[i] != 255)
                {
                    this->full_alpha = 1;
                    break;
                }
            }
        }
    }

    if (this->full_alpha || info->valid & PNG_INFO_bKGD)
    {
        /* Make some extra gamma tables... */
        double g;
        int i;

        /*
         * file gamma -> linear
         */
        if (info->valid & PNG_INFO_gAMA)
            g = 1.0 / info->gamma;
        else
            g = SCREEN_GAMMA;

        load->file_to_1 = malloc(256);
        if (!load->file_to_1)
            png_error(png_ptr, "Insufficient memory");

        for (i = 1; i <= 254; i++)
        {
           load->file_to_1[i] = (png_byte)(pow((double)i / 255.0,
              g) * 255.0 + .5);
        }
        load->file_to_1[0] = 0;
        load->file_to_1[255] = 255;

        /*
         * file gamma -> screen gamma
         */
        if (info->valid & PNG_INFO_gAMA)
            g = 1.0 / (info->gamma * SCREEN_GAMMA);
        else
            g = 1.0;

        load->file_to_screen = malloc(256);
        if (!load->file_to_screen)
            png_error(png_ptr, "Insufficient memory");

        for (i = 1; i <= 254; i++)
        {
            load->file_to_screen[i] = (png_byte)(pow((double)i / 255.0,
               g) * 255.0 + .5);
        }
        load->file_to_screen[0] = 0;
        load->file_to_screen[255] = 255;

        /*
         * screen gamma -> linear
         */
        if (!screen_from_1)
        {
            screen_from_1 = malloc(256);
            if (!screen_from_1)
                png_error(png_ptr, "Insufficient memory");

            g = 1.0 / SCREEN_GAMMA;

            for (i = 1; i <= 254; i++)
            {
               screen_from_1[i] = (png_byte)(pow((double)i / 255.0,
                  g) * 255.0 + .5);
            }
            screen_from_1[0] = 0;
            screen_from_1[255] = 255;
        }

        /*
         * linear -> screen gamma
         */
        if (!screen_to_1)
        {
            screen_to_1 = (png_bytep) malloc(256);
            if (!screen_to_1)
                png_error(png_ptr, "Insufficient memory");

            g = SCREEN_GAMMA;

            for (i = 1; i <= 254; i++)
            {
                screen_to_1[i] = (png_byte)(pow((double)i / 255.0,
                   g) * 255.0 + .5);
            }
            screen_to_1[0] = 0;
            screen_to_1[255] = 255;
        }

        hack_to_1 = load->file_to_1;
        hack_to_screen = load->file_to_screen;
    }

    /* Only 8 bits per channel under RISC OS */
    if (info->bit_depth == 16)
        png_set_strip_16(png_ptr);

    if (info->bit_depth < 8)
    {
        if (this->full_alpha)
        {
            /* Need 8bpp data for blending code */
            png_set_packing(png_ptr);
        }
        else
            png_set_packswap(png_ptr);
    }

    if ((info->color_type == PNG_COLOR_TYPE_RGB ||
         info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && osver >= 0xA5)
    {
        if (!this->full_alpha && (info->valid & PNG_INFO_sBIT))
        {
            if (info->sig_bit.red <= 5 && info->sig_bit.green <= 5 && info->sig_bit.blue <= 5)
                load->convto16bit=1;
        }
    }

    if (info->color_type == PNG_COLOR_TYPE_RGB)
        png_set_filler(png_ptr, load->convto16bit ? 255 : 0, PNG_FILLER_AFTER);

    /* Can't handle RGB data with transparency - need to know data
     * values pre-gamma for palette/greyscale trick to work - get the library
     * to turn it into RGBA. Also, 16-bit greyscale will have to be turned into
     * grey+alpha...
     */
    if (info->valid & PNG_INFO_tRNS)
    {
        if (info->color_type == PNG_COLOR_TYPE_RGB ||
            info->color_type == PNG_COLOR_TYPE_GRAY && info->bit_depth == 16)
            png_set_expand(png_ptr);
    }

    if (!this->full_alpha)
    {
        if (info->color_type & PNG_COLOR_MASK_COLOR) /* We do greyscale ourselves */
        {
            if (info->valid & PNG_INFO_gAMA)
                png_set_gamma(png_ptr, SCREEN_GAMMA, info->gamma);
            else
                png_set_gamma(png_ptr, SCREEN_GAMMA, 1.0 / SCREEN_GAMMA);
        }
    }
    else
    {
        if (info->color_type != PNG_COLOR_TYPE_PALETTE)
            png_set_premultiply_alpha(png_ptr);
    }

    /* Extract the background colour in a useful form */
    if (info->valid & PNG_INFO_bKGD)
    {
        unsigned int bg_r = info->background.red;
        unsigned int bg_g = info->background.green;
        unsigned int bg_b = info->background.blue;
        unsigned int bg_m = info->background.gray;
        unsigned int bg_i = 0x100;

        switch (png_ptr->color_type)
        {
          case PNG_COLOR_TYPE_GRAY:
          case PNG_COLOR_TYPE_GRAY_ALPHA:
            bg_i = bg_m;
            switch (info->bit_depth)
            {
              case 1:
                bg_m *= 0xFF;
                break;
              case 2:
                bg_m *= 0x55;
                break;
              case 4:
                bg_m *= 0x11;
                break;
              case 16:
                bg_m >>= 8;
                break;
            }
            bg_r = bg_g = bg_b = bg_m;
            break;

          case PNG_COLOR_TYPE_PALETTE:
            bg_i = info->background.index;
            bg_r = info->palette[bg_i].red;
            bg_g = info->palette[bg_i].green;
            bg_b = info->palette[bg_i].blue;
            break;

          case PNG_COLOR_TYPE_RGB:
          case PNG_COLOR_TYPE_RGB_ALPHA:
            if (info->bit_depth == 16)
            {
              bg_r >>= 8;
              bg_g >>= 8;
              bg_b >>= 8;
            }
            break;
        }

        load->bkgd = (bg_b << 24) | (bg_g << 16) | (bg_r << 8) | (bg_i & 0xFF);
        load->have_bkgd = 1;
        if (bg_i != 0x100) load->have_bkgd_index = 1;
    }

    /* Enable filling in of interlace */
    png_set_interlace_handling(png_ptr);

    png_read_update_info(png_ptr, info);

    /*
     * Okay, we will now be getting data in one of these formats:
     *            1 bpp paletted/greyscale }
     *            2 bpp paletted/greyscale } only if no alpha in palette
     *            4 bpp paletted/greyscale }
     *            8 bpp paletted/greyscale
     *            8 bpp greyscale + alpha (=> 2 bytes per pixel)
     *           24 bpp colour (with or without alpha, 32 bit packed)
     */

    if (info->color_type == PNG_COLOR_TYPE_RGB ||
        info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver >= 0xA5)
        {
            if (load->convto16bit)
                mode = MODE(5,90,90);
            else
                mode = MODE(6,90,90);
        }
        else
        {
            if (!ct32k_buffer[1])
            {
                load_inversetable();
                if (!ct32k_buffer[1])
                    png_error(png_ptr, "Insufficient memory");
            }

            if (this->full_alpha)
                mode = MODE(6,90,90);
            else
                mode = 28;
        }
    }
    else
    {
        switch (info->bit_depth)
        {
            case 1: mode = 25; break;
            case 2: mode = 26; break;
            case 4: mode = 27; break;
            case 8: mode = 28; break;
        }
    }

    this->width = info->width;
    this->height = info->height;

    #if 0
    /* Don't support the pHYS chunk - it sucks */
    if ((info->valid & PNG_INFO_pHYs) && info->phys_unit_type < PNG_RESOLUTION_LAST)
    {
        switch (info->phys_unit_type)
        {
          case PNG_RESOLUTION_UNKNOWN:
            if (this->width_os==-1)
            {
                if (info->x_pixels_per_unit > info->y_pixels_per_unit)
                    this->width_os = info->width * 2;
                else
                    this->width_os = info->width * 2 * info->y_pixels_per_unit / info->x_pixels_per_unit;
            }
            if (this->height_os==-1)
            {
                if (info->x_pixels_per_unit > info->y_pixels_per_unit)
                    this->height_os = info->height * 2 * info->x_pixels_per_unit / info->y_pixels_per_unit;
                else
                    this->height_os = info->height * 2;
            }
            break;

          case PNG_RESOLUTION_METER:
            if (this->width_os==-1)
                this->width_os = info->width * 180.0F / (info->x_pixels_per_unit * 0.0254F);
            if (this->height_os==-1)
                this->height_os = info->height * 180.0F / (info->y_pixels_per_unit * 0.0254F);
            break;
        }
    }
    else
    #endif
    {
        if (this->width_os==-1)
            this->width_os = info->width * 2;
        if (this->height_os==-1)
            this->height_os = info->height * 2;
    }

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        riscos_rowbytes = info->width;
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (osver < 0xA5 && !this->full_alpha)
            riscos_rowbytes = info->width;
        else if (load->convto16bit)
            riscos_rowbytes = info->width * 2;
        else
            riscos_rowbytes = info->width * 4;
    }
    else
        riscos_rowbytes = info->rowbytes;

    mem = 16  /* Sprite area header size */
         +44; /* Sprite header size */

    if ((info->color_type&~PNG_COLOR_MASK_ALPHA) == PNG_COLOR_TYPE_GRAY && !this->full_alpha)
        num_palette = pal_entries = 1 << info->bit_depth;
    else if (info->color_type == PNG_COLOR_TYPE_PALETTE)
    {
        num_palette = info->num_palette;
        pal_entries = 1 << info->bit_depth;
    }
    else if (osver < 0xA5 && info->color_type == PNG_COLOR_TYPE_RGB)
    {
        num_palette = 0;
        pal_entries = 256;
    }
    else
        num_palette = pal_entries = 0;

    mem += 8 * pal_entries;

    load->spritewidth = (riscos_rowbytes+3)&~3;

    mem += load->spritewidth * info->height;

    if (!this->full_alpha || info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
       if (mode > 28)
          load->maskwidth = ((info->width + 31) &~ 31) / 8;
       else
          load->maskwidth = load->spritewidth;

       mem += load->maskwidth * info->height;

       have_mask = true;

       if (!this->full_alpha)
       {
           this->transparent = 1;
           if (!(info->color_type & PNG_COLOR_MASK_ALPHA) && !(info->valid & PNG_INFO_tRNS))
           {
               if (this->flags & IMAGE_FAST)
               {
                   /* don't bother */
                   mem -= load->maskwidth * info->height;
                   load->maskwidth = 0;
                   have_mask = false;
                   this->transparent = 0;
               }
               else
                   load->removemask = 1;
           }
       }
    }
    else
       have_mask = false;

  trywithoutmask:
    if (!flex_alloc((flex_ptr)&this->private_data2, mem + SprExtendBonus))
    {
        if (load->removemask)
        {
            mem -= load->maskwidth * info->height;
            have_mask = false;
            load->removemask = 0;
            this->transparent = 0;
            goto trywithoutmask;
        }

        load->errmess = "Insufficient memory";
        longjmp(png_ptr->jmpbuf, 1);
    }

    /* Create the sprite now */
    this->private_data2[0] = mem;
    this->private_data2[2] = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    if (e)
        goto error;

    if (osver < 0xA5 && mode == MODE(6,90,90))
    {
        e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                                this->width * 4, this->height, 28);
        load->isreally32bit = 1;
    }
    else
    {
        e=_swix(OS_SpriteOp, _INR(0,6), 256+15, this->private_data2, "png", 0,
                                                this->width, this->height, mode);
    }
    if (e)
        goto error;

    /* Sort out the mask */
    if (have_mask)
    {
        e=_swix(OS_SpriteOp, _INR(0,2), 256+29, this->private_data2, "png");
        if (e)
            goto error;


    	/* Clear the mask */
    	_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+61, this->private_data2, "png", 0,
    	    	    	    	    	     	&r1, &r2, &r3);
    	_swix(OS_SetColour, _INR(0,1), 0x10, 0);
    	_swix(OS_WriteI + 16, 0);
    	_swix(OS_SpriteOp, _INR(0,3), 256+61, r1, r2, r3);
    }

    /* Create and fill in the palette */
    if (pal_entries)
    {
        int i, c;

        e=_swix(OS_SpriteOp, _INR(0,3), 256+37, this->private_data2, "png",
                                        pal_entries == 256 ? (1U<<31) + 1 : 1);
        if (e)
            goto error;

        palette = info->palette;

        if (num_palette == 0)
            goto leave_default_palette;

        /* If full_alpha, must be palette data with hard tRNS chunk */
        if (this->full_alpha && info->color_type == PNG_COLOR_TYPE_PALETTE)
        {
            /* We manipulate the palette (har har har).
             * 255 alpha -> colour gamma corrected ready for screen
             * other alpha -> linearise and premultiply
             */
            for (i = 0; i < num_palette; i++)
            {
                int r, g, b, a;

                if (i < num_trans) a = trans[i]; else a = 255;
                r = palette[i].red;
                g = palette[i].green;
                b = palette[i].blue;

                if (a == 255)
                {
                    r = load->file_to_screen[r];
                    g = load->file_to_screen[g];
                    b = load->file_to_screen[b];
                }
                else
                {
                    int a256 = a + (a >> 7);
                    r = (load->file_to_1[r] * a256) >> 8;
                    g = (load->file_to_1[g] * a256) >> 8;
                    b = (load->file_to_1[b] * a256) >> 8;
                }
                c = (b << 24) | (g << 16) | (r << 8) | a;
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = c;
            }

            /* Any spare palette entries are set to opaque black */
            for ( ; i < pal_entries; i++)
                this->private_data2[15 + i * 2] =
                this->private_data2[15 + i * 2 + 1] = 0x000000FF;

        }
        else
        {
            if (info->color_type == PNG_COLOR_TYPE_GRAY ||
                info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
            {
                if (!this->full_alpha)
                {
                    /* Need a gamma corrected palette */
                    int g, end, step, do_gamma;
                    double gamma;

                    if (info->valid & PNG_INFO_gAMA)
                    {
                        gamma = 1.0 / (info->gamma * SCREEN_GAMMA);
                        do_gamma = fabs(gamma - 1.0) >= PNG_GAMMA_THRESHOLD;
                    }
                    else
                        do_gamma = 0;

                    this->private_data2[15] = this->private_data2[16] = 0;

                    end = (1 << info->bit_depth) - 1;
                    step = 255 / end;

                    for (i = 1, g = step; i < end; i++, g += step)
                    {
                        if (do_gamma)
                            c = (png_byte)(pow((double)g / 255.0, gamma) * 255.0 + .5);
                        else
                            c = g;
                        c = (c << 24) | (c << 16) | (c << 8);

                        this->private_data2[15 + i * 2] =
                        this->private_data2[15 + i * 2 + 1] = c;
                    }

                    this->private_data2[15 + i * 2] = this->private_data2[15 + i * 2 + 1] = 0xFFFFFF00;
                }
            }
            else
            {
                /* Normal palette - phew */
                for (i = 0; i < num_palette; i++)
                {
                    c = (palette[i].blue << 24) |
                        (palette[i].green << 16) |
                        (palette[i].red << 8);
                    this->private_data2[15 + i * 2] =
                    this->private_data2[15 + i * 2 + 1] = c;
                }

                /* Any spare palette entries are zeroed */
                for ( ; i < pal_entries; i++)
                    this->private_data2[15 + i * 2] =
                    this->private_data2[15 + i * 2 + 1] = 0;
            }
        }
    }

  leave_default_palette:

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 2))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }
    }
    else if ((osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
                  || load->convto16bit)
    {
        if (!flex_alloc((flex_ptr) &load->temp, info->width * 4))
        {
            load->errmess = "Insufficient memory";
            longjmp(png_ptr->jmpbuf, 1);
        }
    }

    load->sprite_offset = 16 + this->private_data2[12];
    if (have_mask)
    {
        load->mask_offset=16 + this->private_data2[13];
        if (info->interlace_type == 1 && !load->removemask)
            this->mutable_mask = true;
    }

    load->color_type = info->color_type;


    if (load->have_bkgd)
    {
        if (!(osver < 0xA5 && mode==MODE(6,90,90)))
        {
            /* Clear the background */
            _swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 256+60, this->private_data2, "png", 0,
            	    	    	    	    	     &r1, &r2, &r3);
            if (load->have_bkgd_index)
                _swix(OS_SetColour, _INR(0,1), 0x10, load->bkgd & 0xFF);
            else
            {
                unsigned int bg, bg_r, bg_g, bg_b;
                bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
                bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
                bg_b = load->file_to_screen[load->bkgd >> 24];
                bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
                _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
            }
            _swix(OS_WriteI + 16, 0);
            _swix(OS_SpriteOp, _INR(0,3), 256+60, r1, r2, r3);
        }
    }

    return;

  error:
    load->errmess = e->errmess;
    longjmp(png_ptr->jmpbuf, 1);
}

static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width);
static void convert_row_24bit_to_8bit(const png_byte *row, png_byte *data, png_byte *mask, const char *itable, unsigned int width);
static void convert_row_8bit_to_24bit(png_byte *row, const png_byte *data, const png_byte *mask, const unsigned int *palette, unsigned int width);
static void convert_row_24bit_to_15bit(const png_byte *row, png_byte *data, unsigned int width);
static void convert_row_15bit_to_24bit(png_byte *row, const png_byte *data, unsigned int width);

void row_callback(png_struct *png_ptr, png_byte *new_row, png_uint_32 row_num, int pass)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    png_info *info = load->info_ptr;
    png_byte *row, *mask_row, *our_row;
    int y;

    int oldbudge = flex_set_budge(0);

    /* Increase apparent height of sprite if necessary */
    if (row_num >= load->available_rows)
    {
        load->available_rows = row_num + 1;

        /* If now got one complete pass, take off the temporary mask */
        if (load->available_rows == this->height && load->removemask)
        {
            if (!_swix(OS_SpriteOp, _INR(0,2), 256+30, this->private_data2, "png"))
            {
                flex_extend((flex_ptr) &this->private_data2, load->mask_offset);
                this->private_data2[0] = load->mask_offset;
                load->mask_offset = 0;
                load->removemask = 0;
                this->transparent = 0;
            }
        }
    }

         row = (png_byte *) this->private_data2 +
                            load->sprite_offset +
                            load->spritewidth * row_num;

    if (load->mask_offset)
    {
        mask_row = (png_byte *) this->private_data2 +
                                 load->mask_offset +
                                 load->maskwidth * row_num;
        if (load->removemask)
        {
            memset(mask_row, 255, load->maskwidth);
            mask_row = NULL;
        }
    }
    else
        mask_row = NULL;

    /* Expand our separate mask + color data into the interleaved format the library
       expects... */
    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        int i;
        png_byte *dp, *sp, *mp;

        sp = row;
        mp = mask_row;
        dp = load->temp;
        for (i = info->width; i; i--)
        {
            *dp++ = *sp++;
            *dp++ = *mp++;
        }

        our_row = row;
        row = load->temp;
    }
    else if (load->convto16bit)
    {
        convert_row_15bit_to_24bit(load->temp, row, info->width);
        our_row = row;
        row = load->temp;
    }
    else if (osver < 0xA5 && (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA) && !this->full_alpha)
    {
        convert_row_8bit_to_24bit(load->temp, row, mask_row, (unsigned int *) this->private_data2 + 15, info->width);
        our_row = row;
        row = load->temp;
    }

    png_progressive_combine_row(png_ptr, row, new_row);

    if (info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
    {
        /* And remerge... */
        int i;
        png_byte *dp, *sp, *mp;

        row = our_row;

        sp = load->temp;
        mp = mask_row;
        dp = row;
        if (this->full_alpha)
        {
            for (i = info->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++;
            }
        }
        else
        {
            for (i = info->width; i; i--)
            {
                *dp++ = *sp++;
                *mp++ = *sp++ ? 255 : 0;
            }
        }
    }
    else if (load->convto16bit)
    {
        row = our_row;
        if (mask_row)
            convert_32bit_alpha_to_mask(load->temp, mask_row, info->width);
        convert_row_24bit_to_15bit(load->temp, row, info->width);
    }
    else if (info->color_type == PNG_COLOR_TYPE_RGB || info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        if (!this->full_alpha)
        {
            if (osver >= 0xA5 && info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
                convert_32bit_alpha_to_mask(row, mask_row, info->width);
            else if (osver < 0xA5)
            {
                row = our_row;
                convert_row_24bit_to_8bit(load->temp, row, mask_row, (char *)ct32k_buffer[1], info->width);
            }
        }
    }
    else if (info->valid & PNG_INFO_tRNS)
    {
        if (!this->full_alpha)
            convert_trns_to_mask(row, mask_row, info->width, info->bit_depth, info->trans, info->num_trans, &info->trans_values, info->color_type);
    }

    flex_set_budge(oldbudge);

    load->changed.xmax = this->width_os;

    y = (this->height - row_num - 1) * 2;

    if (y + 2 > load->changed.ymax)
    	load->changed.ymax = y + 2;

    if (y < load->changed.ymin)
    	load->changed.ymin = y;
}

void end_callback(png_struct *png_ptr, png_info *info)
{
    Image *this = (Image *) png_get_progressive_ptr(png_ptr);
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->finished = 1;
}

/*
 * process_transparency - deal with transparency specified by the tRNS chunk
 */
void convert_trns_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width, int depth, png_bytep trans, int num_trans, const png_color_16 *trans_values, int color_type)
{
    int i;
    png_uint_32 mask1, mask2;
    png_byte *dp, *sp;
    int s_start, s_inc, shift;
    png_byte alpha;

    switch (depth)
    {
      case 1:
        shift = s_start = 7;
        s_inc = -1;
        mask1 = 0x7f7f;
        mask2 = 1;
        break;

      case 2:
        shift = s_start = 6;
        s_inc = -2;
        mask1 = 0x3f3f;
        mask2 = 3;
        break;

      case 4:
        shift = s_start = 4;
        s_inc = -4;
        mask1 = 0xf0f;
        mask2 = 0xf;
        break;

      default:
        shift = s_start = 0;
        s_inc = 0;
        mask1 = 0;
        mask2 = 0xff;
        break;
    }

    sp =      row + (width - 1) * depth/8;
    dp = mask_row + (width - 1) * depth/8;

    if (color_type == PNG_COLOR_TYPE_PALETTE)
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix < num_trans && trans[pix] == 0)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
    else /* color_type == PNG_COLOR_TYPE_GRAY */
    {
        for (i = width; i; i--)
        {
            int pix;

            pix = (*sp >> shift) & mask2;
            if (pix == trans_values->gray)
                alpha = 0;
            else
                alpha = mask2;

            *dp &= (png_byte)((mask1 >> (s_start - shift)) & 0xff);
            *dp |= (png_byte)(alpha << shift);

            if (shift == 0)
            {
                shift = s_start;
                dp--;
                sp--;
            }
            else
                shift += s_inc;
        }
    }
}

/*
 * Given a row in AABBGGRR format, fill in the 1-bpp mask information
 */
static void convert_32bit_alpha_to_mask(const png_bytep row, png_bytep mask_row, png_uint_32 width)
{
    png_bytep sp;
    png_bytep dp;
    png_uint_32 i, shift, alpha;

    sp = row + (width - 1) * 4 + 3;
    dp = mask_row + ((width - 1) >> 3);

    shift = (width + 7) & 7;

    for (i = width; i; i--)
    {
        alpha = *sp ? 1 : 0;

        *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
        *dp |= (png_byte)(alpha << shift);

        if (shift == 0)
        {
            shift = 7;
            dp--;
        }
        else
            shift--;

        sp -= 4;
    }
}

/*
 * Turn 32-bit RGBA data into 8-bit paletted data with mask.
 */
static void convert_row_24bit_to_8bit(const png_byte *row, png_byte *data, png_byte *mask, const char *itable, unsigned int width)
{
    unsigned int x;
    unsigned int r, g, b, a, col;

    for (x = width; x; x--)
    {
        r = *row++; g = *row++; b = *row++; a = *row++;
        col = itable[((b >> 3) << 10) | ((g >> 3) << 5) | (r >> 3)];
        *data++ = col;
        if (mask)
            *mask++ = a ? 255 : 0;
    }
}

/*
 * Turn 8-bit paletted data into 32-bit RGBA.
 */
static void convert_row_8bit_to_24bit(png_byte *row, const png_byte *data, const png_byte *mask, const unsigned int *palette, unsigned int width)
{
    unsigned int x;
    unsigned int col;

    for (x = width; x; x--)
    {
        col = palette[*data++ * 2] >> 8;
        if (mask)
            col |= *mask++ << 24;

        *(unsigned int *)row = col;
        row += 4;
    }
}

/*
 * Turn 32-bit RGBA into 16-bit RGBM
 */
void convert_row_24bit_to_15bit(const png_byte *row, png_byte *data, unsigned int width)
{
    unsigned int x;
    unsigned int r, g, b, a, col;

    for (x = width; x; x--)
    {
        r = *row++; g = *row++; b = *row++; a = *row++;
        col = ((b >> 3) << 10) | ((g >> 3) << 5) | (r >> 3);
        if (a==0) col |= 0x8000;
        *(unsigned short *) data = col;
        data += 2;
    }
}

/*
 * Convert 16-bit RGBM into 32-bit RGBA.
 */
void convert_row_15bit_to_24bit(png_byte *row, const png_byte *data, unsigned int width)
{
    unsigned int x;
    unsigned int col;

    /*
     * Only need to do this approximately as we're just going to munge the
     * data back into 15 bits anyway.
     */
    for (x = width; x; x--)
    {
        col = *(unsigned int *) data;
        data += 2;
        *row++ = col << 3;
        *row++ = col >> 2;
        *row++ = col >> 7;
        *row++ = col & 0x8000 ? 0 : 255;
    }
}

void png_premultiply_and_gamma_correct(png_row_infop row_info, png_bytep row)
{
    int a, r, g, b;
    png_uint_32 x;

    png_bytep file_to_1 = hack_to_1;
    png_bytep file_to_screen = hack_to_screen;

    if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
    {
        for (x = row_info->width ; x; x--)
        {
            r = *row++;
            g = *row++;
            b = *row++;
            a = *row++;

            if (a == 255)
            {
                row[-4] = file_to_screen[r];
                row[-3] = file_to_screen[g];
                row[-2] = file_to_screen[b];
            }
            else if (a == 0)
            {
                row[-4] = 0;
                row[-3] = 0;
                row[-2] = 0;
            }
            else
            {
                int a256 = a + (a >> 7);
                r = (file_to_1[r] * a256) >> 8;
                g = (file_to_1[g] * a256) >> 8;
                b = (file_to_1[b] * a256) >> 8;
                row[-4] = r;
                row[-3] = g;
                row[-2] = b;
            }
        }
    }
    else
    {
        for (x = row_info->width ; x; x--)
        {
            g = *row++;
            a = *row++;

            if (a == 255)
                row[-2] = file_to_screen[g];
            else if (a == 0)
                row[-2] = 0;
            else
            {
                int a256 = a + (a >> 7);
                g = (file_to_1[g] * a256) >> 8;
                row[-2] = g;
            }
        }
    }
}

/*****************************/


_kernel_oserror *SaveSpritePNG(Image *this, const char *filename, int maxbpp)
{
    _kernel_oserror *e;
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    if (this->full_alpha)
        return SaveSpriteAlphaPNG(this, filename, maxbpp);

    if (load->isreally32bit)
        this->private_data2[14] = MODE(6,90,90);

    e = _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);

    if (load->isreally32bit)
        this->private_data2[14] = 28;

    return e;
}

static _kernel_oserror *SaveSpriteAlphaPNG(Image *this, const char *filename, int maxbpp)
{
    _kernel_oserror *e;
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int *temppal, i, j;
    unsigned int bg_r, bg_g, bg_b, r, g, b, a, sprwidth, gap;
    FILE *file;
    png_byte *p, *m;
    char *cttable = (char *)ct32k_buffer[1];

    struct
    {
        int number;   // Number of sprites
        int sproff;   // Offset to first sprite
        int freeoff;  // Offset to first free byte
        int  next;          // Offset to next sprite
        char name[12];      // Sprite name
        int  width;         // Width in words-1      (0..639)
        int  height;        // Height in scanlines-1 (0..255/511)
        int  lbit;          // First bit used (left end of row)
        int  rbit;          // Last bit used (right end of row)
        int  image;         // Offset to sprite image
        int  mask;          // Offset to transparency mask
        int  mode;          // Mode sprite was defined in
    } fileheader;


    if (load->have_bkgd)
    {
        bg_r = (load->bkgd & 0xFF00) >> 8;
        bg_g = (load->bkgd & 0xFF0000) >> 16;
        bg_b = load->bkgd >> 24;
    }
    else
        bg_r = bg_g = bg_b = 0xFF;

    switch (load->color_type)
    {
      case PNG_COLOR_TYPE_PALETTE:
        /*
         * We have an 8bpp sprite with true colour palette - just convert the palette
         * entries and save.
         */
        temppal = malloc(256*2*4);
        if (!temppal) return pngError("Insufficient memory");
        memcpy(temppal, this->private_data2+15, 256*2*4);
        for (i = 0; i < 256; i++)
        {
            unsigned int r, g, b, a, c;
            c = this->private_data2[15 + i * 2];
            b = c >> 24;
            g = (c & 0xFF0000) >> 16;
            r = (c & 0xFF00) >> 8;
            a = c & 0xFF;

            if (a == 255)
                continue;

            if (a == 0)
            {
                r = load->file_to_screen[bg_r];
                g = load->file_to_screen[bg_g];
                b = load->file_to_screen[bg_b];
            }
            else
            {
                a = 256 - (a + (a >> 7)); /* Rescale to 256..0 */
                r += (load->file_to_1[bg_r] * a) >> 8;
                g += (load->file_to_1[bg_g] * a) >> 8;
                b += (load->file_to_1[bg_b] * a) >> 8;
                r = screen_from_1[r];
                g = screen_from_1[g];
                b = screen_from_1[b];
            }

            c = (b << 24) | (g << 16) | (r << 8);
            this->private_data2[15 + i * 2] =
            this->private_data2[15 + i * 2 + 1] = c;
        }
        e = _swix(OS_SpriteOp, _INR(0,2), 256+12, this->private_data2, filename);
        memcpy(this->private_data2+15, temppal, 256*2*4);
        free(temppal);
        return e;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
        file = fopen(filename, "wb");
        if (!file) return pngError("Unable to open output file");
        memset(&fileheader, 0, sizeof fileheader);
        fileheader.number = 1;
        fileheader.sproff = 16;
        fileheader.freeoff = load->mask_offset + 256*2*4;
        fileheader.next = load->mask_offset + 256*2*4 - 16;
        strcpy(fileheader.name, "png");
        fileheader.width = this->private_data2[8];
        fileheader.height = this->private_data2[9];
        fileheader.lbit = 0;
        fileheader.rbit = this->private_data2[11];
        fileheader.image = 0x82C;
        fileheader.mask = 0x82C;
        fileheader.mode = 28;
        if (fwrite(&fileheader, sizeof fileheader, 1, file) < 1)
            goto file_error;
        for (i = 0; i < 256; i++)
        {
            int pal[2];
            pal[0] = pal[1] = (i<<24)|(i<<16)|(i<<8);
            if (fwrite(pal, sizeof pal[0], 2, file) < 2)
                goto file_error;
        }

        p = (png_byte *) this->private_data2 + load->sprite_offset;
        m = (png_byte *) this->private_data2 + load->mask_offset;
        for (i = load->spritewidth * this->height; i; i--)
        {
            g = *p++; a = *m++;

            if (a != 255)
            {
                a = 256 - (a + (a >> 7));
                g += (load->file_to_1[bg_g] * a) >> 8;
                g = screen_from_1[g];
            }
            if (putc(g, file) == EOF)
                goto file_error;
        }
        fclose(file);
        return _swix(OS_File, _INR(0,2), 18, filename, 0xFF9);
      case PNG_COLOR_TYPE_RGB_ALPHA:
        file = fopen(filename, "wb");
        if (!file) return pngError("Unable to open output file");
        if (osver < 0xA5)
           sprwidth = ((this->width + 3) >> 2) - 1;
        else
           sprwidth = this->private_data2[8];
        memset(&fileheader, 0, sizeof fileheader);
        fileheader.number = 1;
        fileheader.sproff = 16;
        fileheader.freeoff = 16 +44 + (sprwidth+1) * 4 * this->height;
        fileheader.next = 44 + (sprwidth+1) * 4 * this->height;
        strcpy(fileheader.name, "png");
        fileheader.width = sprwidth;
        fileheader.height = this->private_data2[9];
        fileheader.lbit = 0;
        gap = osver < 0xA5 ? (fileheader.width+1)*4-this->width : 0;
        fileheader.rbit = osver < 0xA5 ? (this->width * 8 - 1) & 31
                                       : 31;
        fileheader.image = 0x2C;
        fileheader.mask = 0x2C;
        fileheader.mode = osver < 0xA5 ? 28 : MODE(6,90,90);
        if (fwrite(&fileheader, sizeof fileheader, 1, file) < 1)
            goto file_error;

        p = (png_byte *) this->private_data2 + load->sprite_offset;
        for (i = this->height; i; i--)
        {
            for (j = this->width; j; j--)
            {
                r = *p++; g = *p++; b = *p++; a = *p++;

                if (a != 255)
                {
                    a = 256 - (a + (a >> 7));
                    r += (load->file_to_1[bg_r] * a) >> 8;
                    g += (load->file_to_1[bg_g] * a) >> 8;
                    b += (load->file_to_1[bg_b] * a) >> 8;
                    r = screen_from_1[r];
                    g = screen_from_1[g];
                    b = screen_from_1[b];
                }
                if (osver < 0xA5)
                {
                    unsigned int c = ((b >> 3) << 10) |
                                     ((g >> 3) << 5) |
                                     (r >> 3);

                    if (putc(cttable[c], file) == EOF)
                        goto file_error;
                }
                else
                {
                    if (putc(r, file) == EOF || putc(g, file) == EOF ||
                        putc(b, file) == EOF || putc(0, file) == EOF)
                        goto file_error;
                }
            }
            if (gap)
            {
                char zero[4] = { 0 };
                if (fwrite(&zero, 1, gap, file) < gap)
                    goto file_error;
            }
        }
        fclose(file);
        return _swix(OS_File, _INR(0,2), 18, filename, 0xFF9);
    }

  file_error:
    fclose(file);
    remove(filename);
    return pngError("Error writing file");
}

static _kernel_oserror *DumpToCache(Image *this, const char *filename, int *justuseorig)
{
    *justuseorig=0;
    return SaveSpritePNG(this, filename, -1);
}

static _kernel_oserror *LoadFromCache(Image *this, const char *filename)
{
    _kernel_oserror *e;
    int length, transparent;

    e=_swix(OS_File, _INR(0,1)|_OUT(4), 20, filename, &length);

    if (!e)
    {
        if (!flex_alloc((flex_ptr)&this->private_data2, length+4+SprExtendBonus))
            return pngError("Insufficient memory");
    }

    if (!e)
    {
        this->private_data2[0]=length+4;
        this->private_data2[2]=16;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+9, this->private_data2);
    }

    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2), 256+10, this->private_data2, filename);

    transparent = this->transparent;
    if (!e)
        e=_swix(OS_SpriteOp, _INR(0,2)|_OUTR(3,5), 256+40, this->private_data2, filename,
                                                   &this->width, &this->height,
                                                   &transparent);
    this->transparent = transparent;

    if (!e)
    {
        this->mutable_mask=0;
        if (this->width_os==-1)
            this->width_os=2*this->width;
        if (this->height_os==-1)
            this->height_os=2*this->height;
    }

    return e;
}

static _kernel_oserror *EndLoad(Image *this, BBox *changed)
{
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    #ifdef TRACE
    if (load->trace)
        fclose(load->trace);
    #endif

    memset(changed, 0, sizeof(BBox));

    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

    if (load->temp)
        flex_free((flex_ptr) &load->temp);

    /*free(this->private_data);
    this->private_data=NULL;*/

    if (this->width_os==-1)
        this->width_os=2*this->width; /*180*this->width/xres;*/
    if (this->height_os==-1)
        this->height_os=2*this->height; /*180*this->height/yres;*/

    return NULL;
}

static _kernel_oserror *Delete(Image *this)
{
    PNGloaddata *load;

    if (!this)
        return NULL;

    load=(PNGloaddata *) this->private_data;
    if (load)
    {
        if (load->png_ptr)
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);

        free(load->file_to_1);
        free(load->file_to_screen);
        free(load);
    }

    if (this->private_data2)
        flex_free((flex_ptr) &this->private_data2);

    free(this);

    return NULL;
}

static _kernel_oserror *ModeChange(Image *this)
{
    _kernel_oserror *e=0;
    int bufsize;

    e=_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2), -1, 9, &log2bpp);
    if (e) return e;

    if (osver >= 0xA5)
        ct32k_buffer[0] = 0;
    else if (log2bpp < 3)
    {
        if (!ro310_2nd_table)
            ro310_2nd_table = malloc(256);
        if (!ro310_2nd_table)
            return pngError("Insufficient memory");

        e = _swix(ColourTrans_GenerateTable, _INR(0,5), 28, 0, -1, -1, ro310_2nd_table, 0);
        if (e) return e;
    }

    /*don't need a table if going into 16 or 32bpp*/

    if (!this)
        return NULL;

    if (log2bpp <= 3)
    {
        if (!e)
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), this->private_data2, "png", -1, -1,
                                                    0, 0, &bufsize);

        if (!e)
        {
            free(this->table);
            if (bufsize)
            {
                this->table=malloc(bufsize);
                if (!this->table)
                    e=pngError("Insufficient memory");

                if (!e)
                    e=_swix(ColourTrans_GenerateTable, _INR(0,5), this->private_data2, "png", -1, -1,
                                                                  this->table, 0);
            }
        }

    }

    if (!e)
    e=_swix(Wimp_ReadPixTrans, _INR(0,2)|_INR(6,7), 256, this->private_data2, "png",
                                                    this->factors, 0);

    if (!e)
    {
        this->factors[0]*=this->width_os;
        this->factors[1]*=this->height_os;
        this->factors[2]*=this->width*2;
        this->factors[3]*=this->height*2;
    }
    return e;
}

static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing);

static _kernel_oserror *RenderPNG(Image *this, int x, int y, int scale, int x_size, int y_size)
{
    _kernel_oserror *e=NULL;
    PNGloaddata *load = (PNGloaddata *)this->private_data;
    int fac[4];
    int job = 0;

    if (!this || !this->private_data2)
        return pngError("Broken PNG");

    if (this->width <= 0)
    {
        e=_swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), 0, 0, 0);
        if (!e)
            e=_swix(OS_Plot, 4, x, y);
        if (!e)
            e=_swix(OS_Plot, 0x60 | 1, this->width_os*scale/100-1,
                                       this->height_os*scale/100-1);
        return e;
    }

    if (this->modechanged || !this->factors[0])
    {
        e=ModeChange(this);
        if (e) return e;
        this->modechanged = 0;
    }

    _swix(PDriver_CurrentJob, _OUT(0), &job);

    if (this->full_alpha)
        return RenderWithAlpha(this, x, y, scale, x_size, y_size, job ? (osver >= 0xA5 ? 5 : 3) : log2bpp, job);

    if (load->isreally32bit)
        return pngError("Unable to render this image in this screen mode");

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    if (e) return e;

    if (log2bpp <= 3 && this->table == NULL && fac[0] == fac[2] && fac[1] == fac[3])
        e=_swix(OS_SpriteOp, _INR(0,5), 256+PutSprite,
                                        this->private_data2,
                                        "png",
                                        x, y,
                                        PutSpriteScaled_UseMask);
    else
        e=_swix(OS_SpriteOp, _INR(0,7), 256+PutSpriteScaled,
                                        this->private_data2,
                                        "png",
                                        x, y,
                                        osver >= 0xa5 ? PutSpriteScaled_UsePalette |
                                                        PutSpriteScaled_UseMask
                                                      : PutSpriteScaled_UseMask,
                                        fac,
                                        log2bpp <=3 ? this->table : 0);

    return e;
}

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp);

static _kernel_oserror *RenderWithAlpha(Image *this, int x, int y, int scale, int x_size, int y_size, int log2bpp, int printing)
{
    int bgwidth;
    int mode;
    void *table = 0;
    int fac[4];
    _kernel_oserror *e;
    int oldbudge;
    int *bgpal;
    char *bgptr;
    PNGloaddata *load=(PNGloaddata *) this->private_data;
    int width = this->width, height = this->height, rowstoblend = load->available_rows;
    int clipoffset = 0, xo = 0, yo = 0;

    if (!printing)
    {
        static const int vdu_list[] = { 128,129,130,131,4,5,136,137,-1 };
        struct
        {
            BBox clip;
            int xeig, yeig;
            int ox, oy;
        } var;

        e = _swix(OS_ReadVduVariables, _INR(0,1), vdu_list, &var);
        if (e) return e;

        if (x_size > 0 && y_size > 0)
        {
            if (width * 2 != x_size ||
                height * 2 != y_size)
                goto dont_clip;
        }
        else if (scale != 100)
            goto dont_clip;
        else
        {
            x_size = width * 2;
            y_size = height * 2;
        }

        /* var.clip = graphics window in external coordinates */
        var.clip.xmin = (var.clip.xmin << var.xeig) + var.ox;
        var.clip.ymin = (var.clip.ymin << var.yeig) + var.oy;
        var.clip.xmax = ((var.clip.xmax+1) << var.xeig) + var.ox;
        var.clip.ymax = ((var.clip.ymax+1) << var.yeig) + var.oy;

        /* If graphics window is totally outside available image, return */
        if (var.clip.xmax < x || var.clip.xmin >= x + x_size ||
            var.clip.ymax < y + y_size - load->available_rows * 2 || var.clip.ymin >= y + y_size)
            return NULL;

        if (var.clip.xmin < x) var.clip.xmin = x;
        if (var.clip.xmax > x + x_size) var.clip.xmax = x + x_size;
        if (var.clip.ymin < y + y_size - load->available_rows * 2) var.clip.ymin = y + y_size - load->available_rows * 2;
        if (var.clip.ymax > y + y_size) var.clip.ymax = y + y_size;

        var.clip.xmin -= x; var.clip.ymin -= y;
        var.clip.xmax -= x; var.clip.ymax -= y;

        var.clip.xmin >>= 1;
        var.clip.ymin >>= 1;
        var.clip.xmax = (var.clip.xmax + 1) >> 1;
        var.clip.ymax = (var.clip.ymax + 1) >> 1;

        width = var.clip.xmax - var.clip.xmin;
        height = var.clip.ymax - var.clip.ymin;
        if (width <= 0 || height <= 0)
            return NULL;

        if (height < 4)
        {
            if (var.clip.ymin >= 4)
                var.clip.ymin -= 4 - height;
            else
                var.clip.ymax += 4 - height;
            height = 4;
        }
        if (width < 4)
        {
            if (var.clip.xmin >= 4)
                var.clip.xmin -= 4 - width;
            else
                var.clip.xmax += 4 - width;
            width = 4;
        }
        xo = -2 * var.clip.xmin;
        yo = -2 * var.clip.ymin;
        clipoffset = var.clip.xmin;
        if (load->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            clipoffset *= 4;
        clipoffset += (this->height - var.clip.ymax) * load->spritewidth;

        rowstoblend = height;
        if (this->height - var.clip.ymin > load->available_rows)
            rowstoblend = load->available_rows - (this->height - var.clip.ymax);
    }

  dont_clip:

    switch (log2bpp)
    {
        case 0: mode = 25;              break;
        case 1: mode = 26;              break;
        case 2: mode = 27;              break;
        case 3: mode = 28;              break;
        case 4: mode = MODE(5, 90, 90); break;
        case 5: mode = MODE(6, 90, 90); break;
    }

    e = MakeBufferSprite((void *) mode, width, height, &bgpal);
    if (e) return e;

    e = SwitchToBufferSprite();
    if (e) goto error2;

    {
        static const int list[] = { 6, 148, -1 };
        int out[2];

        e = _swix(OS_ReadVduVariables, _INR(0,1), list, out);
        if (e) goto error2;
        bgwidth = out[0];
        bgptr = (char *) out[1];
    }

    if (xo != 0 || yo != 0)
    {
        char cmd[5];
        cmd[0] = 29;
        cmd[1] = xo & 0xFF;
        cmd[2] = xo >> 8;
        cmd[3] = yo & 0xFF;
        cmd[4] = yo >> 8;
        e = _swix(OS_WriteN, _INR(0,1), cmd, 5);
    }

    if (!e)
    {
        if (load->filler)
            e = load->filler(load->filler_handle1, load->filler_handle2);
        else
        {
            unsigned int bg_r, bg_g, bg_b, bg;
            if (load->have_bkgd)
            {
                bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
                bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
                bg_b = load->file_to_screen[load->bkgd >> 24];
                bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
            }
            else
                bg = 0xFFFFFF00;
            _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
            _swix(OS_WriteI + 16, 0);
        }
    }

    e = SwitchFromBufferSprite();
    if (e) goto error2;

    if (!ct32k_buffer[0] && osver < 0xA5)
    {
        load_inversetable();
        if (!ct32k_buffer[0])
            goto error2;
    }

    oldbudge = flex_set_budge(0);

    blend_image(width, rowstoblend,
                (char *) this->private_data2 + load->sprite_offset + clipoffset,
                (char *) this->private_data2 + load->mask_offset + clipoffset,
                this->private_data2 + 4 + 11,
                load->color_type,
                load->spritewidth,
                bgptr,
                bgwidth,
                bgpal,
                log2bpp);

    flex_set_budge(oldbudge);

    memcpy(fac, this->factors, sizeof fac);

    if ((x_size>0) && (y_size>0))
    {
        int xos, yos;

        xos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 4);
        yos = 1 << _swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), -1, 5);

        fac[0]=x_size;
        fac[1]=y_size;
        fac[2]=this->width*xos;
        fac[3]=this->height*yos;
    }
    else if (scale != 100)
    {
        fac[0]*=scale;
        fac[1]*=scale;
        fac[2]*=100;
        fac[3]*=100;
    }

    /* Selection table should be unnecessary for the screen... One exception
     * is an A4 in mode 28 in LCD, as the screen palette won't be that in
     * the 8desktop file, but this isn't worth worrying about. They should
     * be using mode 27 anyway.
     */
    if (printing)
    {
        int bufsize;

        e=BufferSprite_TableSize(&bufsize);
        if (e) goto error2;

        if (bufsize)
        {
            table = malloc(bufsize);
            if (!table)
            {
                e=pngError("Insufficient memory");
                goto error2;
            }

            e=BufferSprite_GenerateTable(table);
            if (e) goto error2;
        }
    }

    e=BufferSprite_PlotScaled(x - xo, y - yo, osver >= 0xa5 ? PutSpriteScaled_UsePalette : 0, fac, table);

    free(table);
 error2:
    FreeBufferSprite();

    return e;
}

static _kernel_oserror *StartExportPNG(Image *this, int *size)
{
    *size=this->private_data2[0]-4;

    return StartExport((flex_ptr) &this->private_data2, this->private_data2[0]-4, 4);
}

static _kernel_oserror *bgfiller(void *h, int *bg)
{
    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), *bg, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    return NULL;
}

static _kernel_oserror *BGColPNG(Image *this, int *bgcol, int dontoverride)
{
    _kernel_oserror *e;
    int size, *sphead;
    void *mode;
    Spriteloaddata *l;
    char temp[16];
    int fac[4];
    int r1, r2, r3;
    PNGloaddata *load = (PNGloaddata *) this->private_data;
    int nw, nh, log2bpp;
    unsigned int bg = *bgcol;
    int *newarea;
    int copy_row;

    if (!(this->flags & IMAGE_FAST))
       return BGCol(this->private_data2, bgcol);

    ModeChange(this);
    this->modechanged = 0;

    l = (Spriteloaddata *)malloc(sizeof *l);
    if (!l)
        return NULL;

    this->flags &= ~IMAGE_FAST;
    /*
     * Right, this is obviously a background image, so lets munge it into
     * a sprite of the current mode and palette!
     */
    _swix(OS_Byte, _IN(0)|_OUT(2), 135, &mode);
    log2bpp=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);

    /* Find first sprite */
    e=_swix(OS_SpriteOp, _INR(0,4), 256+13, this->private_data2, temp, sizeof temp, 1);
    if (e)
        return NULL;

    /* Get pointer to it */
    e=_swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+24, this->private_data2, temp, &sphead);
    if (e)
        return NULL;

    /* Get scale factors */
    _swix(Wimp_ReadPixTrans, _INR(0,2) |_INR(6,7), 0x200, this->private_data2, sphead, fac, 0);
    nw=this->width * fac[0] / fac[2];
    nh=this->height * fac[1] / fac[3];

    if (nw == 0) nw=1;
    if (nh == 0) nh=1;

    /* SpriteExtend bodge */
    if (nh==1) {
      nh=8;
      this->height*=8;
      this->height_os*=8;
      copy_row=1;
    }

    size = SpriteAreaSize(mode, nw, nh);
    if (log2bpp <= 3)
        /* Add the palette... */
        size += 8 << (1 << log2bpp);

    newarea = malloc(size);
    if (!newarea)
        return NULL;

    newarea[0] = size;
    newarea[2] = 16;
    /* Initialise sprite area */
    _swix(OS_SpriteOp, _INR(0,1), 256+9, newarea);

    /* Create sprite */
    e=_swix(OS_SpriteOp, _INR(0,6), 256+15, newarea, "sprite",
                                    0, nw, nh, mode);

    /* Add the palette */
    if (!e && log2bpp <= 3)
    {
        void *palette;
        e=_swix(OS_SpriteOp, _INR(0,3), 0x125, newarea, "sprite", (1U<<31)+1);
        if (!e)
            e=_swix(OS_SpriteOp, _INR(0,3)|_OUT(4), 0x125, newarea, "sprite", -1, &palette);
        if (!e)
            e=_swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, palette, 8<<(1<<log2bpp), 2);
    }
    if (e)
    {
        free(newarea);
        return NULL;
    }

    /* Switch output to it */
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(1,3), 0x13C, newarea, "sprite", 0,
                                               &r1, &r2, &r3);
    if (e)
    {
        free(newarea);
        return NULL;
    }

    /* What background colour? */
    if (!dontoverride && load->have_bkgd)
    {
        unsigned int bg_r, bg_g, bg_b;
        bg_r = load->file_to_screen[(load->bkgd >> 8) & 0xFF];
        bg_g = load->file_to_screen[(load->bkgd >> 16) & 0xFF];
        bg_b = load->file_to_screen[load->bkgd >> 24];
        bg = (bg_b << 24) | (bg_g << 16) | (bg_r << 8);
    }

    /* Set background colour */
    _swix(ColourTrans_SetGCOL, _IN(0)|_INR(3,4), bg, 128, 0);
    /* CLG */
    _swix(OS_WriteI+16, 0);

    this->RegisterFiller(this, bgfiller, this, (int *) &bg);

    /* Plot the image */
    RenderPNG(this, 0, 0, 100, -1, -1);

    /* Unswitch output */
    _swix(OS_SpriteOp, _INR(0,3), 0x13c, r1, r2, r3);

    /* If it was a one row PNG, copy the one row to the other seven. */
    if (copy_row)
    {
      int          *sprite_area;
      int          *sprite_header;
      char         *sprite_data;
      int           n, sw, bpp, widthinbytes;

      bpp = 1<< log2bpp;

      widthinbytes = (this->width * bpp) / 8;
      if (this->width % bpp) widthinbytes++;

      sw = (widthinbytes+3)&~3;

      sprite_area   = (int*) newarea;
      sprite_header = (int*) ((char*)sprite_area + sprite_area[2]);
      sprite_data   = (char*) ((char*)sprite_header + sprite_header[8]);

      for (n=0; n<7; n++) memcpy(sprite_data + (n*sw), sprite_data + (7*sw), sw);
    }

    BGCol(newarea, bgcol);

    if (flex_extend((flex_ptr) &this->private_data2, size) == 0)
    {
        free(newarea);
        return NULL;
    }
    memcpy(this->private_data2, newarea, size);
    free(newarea);

    if (load)
    {
        if (load->png_ptr)
    	    png_destroy_read_struct(&load->png_ptr, &load->info_ptr, NULL);
        free(load->file_to_1);
        free(load->file_to_screen);
        free(load);
    }
    free(this->table);

    this->DumpSprite=SpriteDumpSprite;
    this->Render=RenderSprite;
    this->DumpToCache=DumpToCacheSprite;
    this->StartExport=StartExportSprite;
    this->Export=Export;
    this->EndExport=EndExport;
    this->Delete=DeleteSprite;
    this->private_data=l;
    this->transparent=0;
    this->mutable_mask=0;
    this->width=nw;
    this->height=nh;
    this->NeedRedraw=0;
    this->RegisterFiller=0;

    l->memory=size;
    l->xeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 4);
    l->yeig=_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 5);
    l->bpp =_swi(OS_ReadModeVariable, _INR(0,1)|_RETURN(2), mode, 9);
    {
        int *pal;
        _swi(OS_SpriteOp, _INR(0,3)|_OUTR(3,4), 256+37, this->private_data2, "sprite", -1, &l->palsize, &pal);
        if (pal)
            l->paloffset = pal - this->private_data2;
        else
            l->paloffset = 0;
    }
    this->table = 0;
    this->factors[0]=this->factors[1]=this->factors[2]=this->factors[3]=1;
    strcpy(l->name, "sprite");
    return NULL;
}

static _kernel_oserror *RegisterFiller(Image *this, FillerFunction *fill_fn, void *handle1, int *handle2)
{
    PNGloaddata *load = (PNGloaddata *) this->private_data;

    load->filler = fill_fn;
    load->filler_handle1 = handle1;
    load->filler_handle2 = handle2;

    return 0;
}

#define blend(dest, alpha_dest, src)               \
          {                                        \
              if (dest) dest *= (alpha_dest);      \
              dest = (dest >> 8) + src;            \
          }

static void blend_image(int width, int height, char *sprdata, char *maskdata, int *palette, int type, int rowwidth, char *bgsprdata, int bgrowwidth, int *bgpalette, int bglog2bpp)
{
    unsigned int bgdepth = 1 << bglog2bpp;
    int red, green, blue;
    int bgred, bggreen, bgblue;
    unsigned int fg, bg, c;
    int alpha, bg_alpha;
    int x, y, bbit;
    char *s, *m, *b;
    char *cttable;
    #ifdef DITHERING
    int dir=1;
    unsigned int result;
    int truered, truegreen, trueblue, result_red, result_green, result_blue;
    int error_red, error_green, error_blue;
    #endif

    if (bgdepth <= 8 && osver >= 0xA5)
    {
        _kernel_oserror *e;

        /* Get the magic "table" from ColourTrans ( { '32K.', table_ptr, '32K.' } ) */
        e = _swix(ColourTrans_GenerateTable, _INR(0,5), MODE(5, 90, 90), -1, -1, -1, ct32k_buffer, 0);
        if (e) return;
    }
    cttable = (char *)ct32k_buffer[1];

    for (y = height; y; y--)
    {
        s = sprdata;   sprdata   += rowwidth;
        m = maskdata;  maskdata  += rowwidth;
        b = bgsprdata; bgsprdata += bgrowwidth;
        bbit = 0;

        #ifdef DITHERING
        if (dir == -1)
        {
            if (type == PNG_COLOR_TYPE_RGB_ALPHA)
                s += (width-1) * 4;
            else
                s += width-1;
            m += width-1;
            b += ((width-1) * bgdepth) >> 3;
            bbit = ((width-1) * bgdepth) & 7;
        }

        error_red = error_green = error_blue = 0;
        #endif

        for (x = width; x; x--)
        {
            switch (type)
            {
              case PNG_COLOR_TYPE_PALETTE:
                #ifdef DITHERING
                fg = palette[*s * 2];
                s += dir;
                #else
                fg = palette[*s++ * 2];
                #endif
                alpha = fg & 0xFF;
                if (alpha == 0)
                    goto leave_background;
                blue = fg >> 24;
                green = (fg >> 16) & 0xFF;
                red = (fg >> 8) & 0xFF;
                break;

              case PNG_COLOR_TYPE_GRAY_ALPHA:
                #ifdef DITHERING
                alpha = *m;
                m += dir;
                #else
                alpha = *m++;
                #endif
                if (alpha == 0)
                {
                    #ifdef DITHERING
                    s += dir;
                    #else
                    s++;
                    #endif
                    goto leave_background;
                }
                #ifdef DITHERING
                red = green = blue = *s;
                s += dir;
                #else
                red = green = blue = *s++;
                #endif
                break;

              case PNG_COLOR_TYPE_RGB_ALPHA:
                fg = *((int *) s);
                #ifdef DITHERING
                s += 4 * dir;
                #else
                s += 4;
                #endif
                alpha = fg >> 24;
                if (alpha == 0)
                {
                  leave_background:
                    #ifdef DITHERING
                    error_red = error_green = error_blue = 0;
                    if (bgdepth >= 8)
                    {
                        if (dir == 1)
                            b += bgdepth >> 3;
                        else
                            b -= bgdepth >> 3;
                    }
                    else
                    {
                        if (dir == 1)
                        {
                            if ((bbit += bgdepth) == 8)
                            {
                                bbit = 0;
                                b++;
                            }
                        }
                        else
                        {
                            if ((bbit -= bgdepth) < 0)
                            {
                                bbit = 8-bgdepth;
                                b--;
                            }
                        }
                    }
                    #else
                    if (bgdepth >= 8)
                        b += bgdepth;
                    else
                    {
                        if ((bbit += bgdepth) == 8)
                        {
                            bbit = 0;
                            b++;
                        }
                    }
                    #endif
                    continue;
                }
                blue = (fg >> 16) & 0xFF;
                green = (fg >> 8) & 0xFF;
                red = fg & 0xFF;
                break;
            }

            if (alpha != 255)
            {
                switch (bgdepth)
                {
                  case 1:
                    bg = (*b >> bbit) & 1;
                    goto read_palette;

                  case 2:
                    bg = (*b >> bbit) & 3;
                    goto read_palette;

                  case 4:
                    bg = (*b >> bbit) & 0xF;
                    goto read_palette;

                  case 8:
                    bg = *b;
                  read_palette:
                    bg = bgpalette[bg * 2];
                    bgblue = bg >> 24;
                    bggreen = (bg >> 16) & 0xFF;
                    bgred = (bg >> 8) & 0xFF;
                    break;

                  case 16:
                  {
                    bg = *((unsigned short *) b);
                    bgred   = (bg << 3) & 0xF8; bgred   |= bgred   >> 5;
                    bggreen = (bg >> 2) & 0xF8; bggreen |= bggreen >> 5;
                    bgblue  = (bg >> 7) & 0xF8; bgblue  |= bgblue  >> 5;
                    break;
                  }

                  case 32:
                    bg = *((unsigned int *) b);
                    bgblue = (bg >> 16) & 0xFF;
                    bggreen = (bg >> 8) & 0xFF;
                    bgred = bg & 0xFF;
                    break;
                }

                alpha = alpha + (alpha >> 7);   /* Rescale to 0..256 */
                bg_alpha = 256 - alpha;

                /*
                 * The background we captured is gamma adjusted for the
                 * screen - get back to linear before we do the maths
                 */
                bgblue  = screen_to_1[bgblue];
                bggreen = screen_to_1[bggreen];
                bgred   = screen_to_1[bgred];

                /*
                 * (Partially opaque colours in the image are already
                 * linear)
                 */

                blend(bgblue,  bg_alpha, blue);
                blend(bggreen, bg_alpha, green);
                blend(bgred,   bg_alpha, red);

                bgblue  = screen_from_1[bgblue];
                bggreen = screen_from_1[bggreen];
                bgred   = screen_from_1[bgred];
            }
            else
            {
                /*
                 * Fully opaque case - we "cheat" by stored fully screen
                 * gamma corrected data in this case only!
                 */
                bgblue = blue;
                bggreen = green;
                bgred = red;
            }

            #ifdef DITHERING
            bgblue += error_blue;
            bggreen += error_green;
            bgred += error_red;
            if (bgblue < 0) bgblue = 0; else if (bgblue > 255) bgblue = 255;
            if (bggreen < 0) bggreen = 0; else if (bggreen > 255) bggreen = 255;
            if (bgred < 0) bgred = 0; else if (bgred > 255) bgred = 255;
            truered = bgred;
            truegreen = bggreen;
            trueblue = bgblue;
            #endif

            if (bgdepth != 32)
                bg = ((bgblue & 0xF8) << 7) | ((bggreen & 0xF8) << 2) | (bgred >> 3);
            else
                bg = (bgblue << 16) | (bggreen << 8) | bgred;

            switch (bgdepth)
            {
              case 1:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (1 << bbit)) | (c << bbit);
                goto advance_bit;

              case 2:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (3 << bbit)) | (c << bbit);
                goto advance_bit;

              case 4:
                c = cttable[bg];
                if (osver < 0xA5)
                    c = ro310_2nd_table[c];
                *b = (*b &~ (0xF << bbit)) | (c << bbit);
              advance_bit:
                #ifdef DITHERING
                if (dir == 1)
                {
                    if ((bbit += bgdepth) == 8)
                    {
                        bbit = 0;
                        b++;
                    }
                }
                else
                {
                    if ((bbit -= bgdepth) < 0)
                    {
                        bbit = 8 - bgdepth;
                        b--;
                    }
                }
                goto get_result;
                #else
                if ((bbit += bgdepth) == 8)
                {
                    bbit = 0;
                    b++;
                }
                #endif
                break;

              case 8:
                c = cttable[bg];
                #ifdef DITHERING
                *b = c;
                if (dir == 1)
                    b++;
                else
                    b--;
              get_result:
                result = bgpalette[c * 2];
                result_blue = result >> 24;
                result_green = (result >> 16) & 0xFF;
                result_red = (result >> 8) & 0xFF;
                #else
                *b++ = c;
                #endif
                break;

              case 16:
                *(unsigned short *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 2;
                else
                    b -= 2;
                result_red = (bgred & 0xF8) | (bgred >> 5);
                result_green = (bggreen & 0xF8) | (bggreen >> 5);
                result_blue = (bgblue & 0xF8) | (bgblue >> 5);
                #else
                b += 2;
                #endif
                break;
              case 32:
                *(unsigned int *) b = bg;
                #ifdef DITHERING
                if (dir == 1)
                    b += 4;
                else
                    b -= 4;
                #else
                b += 4;
                #endif
                continue;
            }

            #ifdef DITHERING
            error_red = truered - result_red;
            error_green = truegreen - result_green;
            error_blue = trueblue - result_blue;
            #endif

        } /* end x loop */

        dir = -dir;

    } /* end y loop */

}
