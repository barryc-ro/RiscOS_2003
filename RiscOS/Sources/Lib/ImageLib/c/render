/*---------------------------------------------------------------------------------------------*/
/* File:    c.render                                                                           */
/* Purpose: 'Bitstream' rendering                                                              */
/*          Takes a bitstream in and compresses and renders it on screen                       */
/* Author:  Richard Leggett                                                                    */
/* History: 17-Jan-97: RML: Created using elements of a test program                           */
/*          20-Jan-97: RML: Added functions to plot whole and part of internal format image    */
/*          21-Jan-97: RML: Added support for interlaced pictures                              */
/*          22-Jan-97: RML: Added support for scaling                                          */
/*          27-Jan-97: RML: Make plot routines read graphics window and decide from that what  */
/*	    	       	    blocks to plot.                                                    */
/*          30-Jan-97: RML: Altered plotting routines so that they will plot as much as has so */
/*                          far been recompressed.					       */
/*          05-Feb-97: RML: Improved memory allocation (greater efficiency)                    */
/*          06-Feb-97: RML: Added correct palettes. Tidied up memory allocation for sprite.    */
/*          10-Feb-97: RML: Made changes necessary to cope with multiple images open.          */
/*          11-Feb-97: RML: Started support for animated GIFs                                  */
/*          13-Feb-97: RML: Animated GIFs now work                                             */
/*          17-Feb-97: RML: Improved the storage space taken by animations, by not storing as  */
/*                          sprites, but as raw RGB data (ie. no mask, palette etc.)           */
/*          24-Feb-97: RML: Changed animated routines so they store the 'last screen'.         */
/*          26-Feb-97: RML: Changed way that animations are plotted, as there were problems    */
/*                          with palettes.   		    	     	      	   	       */
/*          27-Feb-97: RML: Corrected a bug, so that now, last_screen is based on the screen   */
/*                          size specified in the GIF descriptor, not the size of frame 0      */
/*          03-Mar-97: RML: Animated GIFs on hold for a while, back to still GIFs. Fixed bug   */
/*                          which sometimes caused interlaced gif display to crash.            */
/*          04-Mar-97: RML: Another interlaced bug (causing rows to be displayed in wrong      */
/*                          order) fixed. Added transparency to inanimate pictures.            */
/*          05-Mar-97: RML: Moved memory allocation to flex.                                   */
/*          06-Mar-97: RML: Tidied up error trapping, made functions return kernel_oserrors.   */
/*          13-Mar-97: RML: Fixed some flexy problems (lost anchors etc.)                      */
/*          17-Mar-97: RML: Minor tidying up                                                   */
/*          18-Mar-97: RML: Sorted out bug where flex gets confused if picture is deleted      */
/*                          before it is finished being fetched.                               */
/*          20-Mar-97: RML: Fixed a few redraw bugs.					       */
/*          24-Mar-97: RML: Tidied up error trapping/reporting.                                */
/*          25-Mar-97: RML: Cleared up some memory leaks occuring in low memory situations.    */
/*          02-Apr-97: RML: Back to animated GIFs - due to palette considerations, decided to  */
/*                          revert back to storing each frame as a sprite. Added local palette */
/*                          support.                                                           */
/*          03-Apr-97: RML: Added interlace animated GIF support.                              */
/*          04-Apr-97: RML: Corrected bug which crashes on small interlaced pictures. Fixed    */
/*                          problems with plotting in rectangular pixel modes.                 */
/*          09-Apr-97: RML: Made last_screen and background sprites be in the current screen   */
/*                          mode, rather than always mode 28 (should display better).          */
/*          10-Apr-97: RML: Speed improvements, by implementing 16 and 32bit versions of       */
/*                          memset.                                                            */
/*          15-Apr-97: RML: Improved error trapping.                                           */
/*          21-Apr-97: RML: Moved animated frame data structures over to a linked list, thus   */
/*                          getting rid of flex problems which have been bugging me for ages   */
/*                          (oops...)                                                          */
/*          24-Apr-97: RML: Added mode change support.                                         */
/*          25-Apr-97: RML: Add support for scaling animations.                                */
/*          28-Apr-97: RML: Miscellaneous bug fixing.                                          */
/*          01-May-97: RML: Added support for registering of functions to fill animation       */
/*                          backgrounds.                                                       */
/*          06-May-97: RML: Implemented proper support of Netscape looping extension.          */
/*          08-May-97: RML: Got around SpriteExtend bug when screen height is 1 pixel.         */
/*          12-May-97: RML: Fixed bug with still images using wrong (short/long) colour table. */
/*          19-May-97  RML: Made all a particular animation's colour translation tables be in  */
/*                          one flex block, for speed. As a result of this, moved away from    */
/*                          linked list structure for frame data.                              */
/*          21-May-97: RML: Optimised interlaced image plotting to give greater speed while    */
/*                          fetching.                                                          */
/*          25-Jun-97: RML: Corrected redraw problem with 1 pixel high animations scaled up.   */
/*                          Comes about because of 1 pixel height SpriteExtend problems.       */
/*          10-Jul-97: RML: Made need_redraw return a bounding box specifying the area needing */
/*                          update. Fixed problem with greyscale images in 256 grey modes.     */
/*          11-Aug-97: RML: Fixed bug in allocation of lzw_buffer (wasn't allocating enough in */
/*                          some circumstances)                                                */
/*          18-Aug-97: RML: Fixed bug introduced by above change (oops!).                      */
/*          04-Sep-97: RML: Made use of flex_set_budge to avoid stack problems on pre-RPC      */
/*                          machines.                                                          */
/*          04-Sep-97: RML: Corrected bug which resulted in dodgy palette for animations in    */
/*                          16 colour screen modes.                                            */
/*          12-Sep-97: RML: Added sprite export functions (render_export_sprite and            */
/*                          render_export_animated_sprites)                                    */
/*          23-Sep-97: KJB: Added support for looping an animation a specified number of times.*/
/*          07-Oct-97: RML: Fixed problem which can cause flex_error if screen size is smaller */
/*                          than image_size (illegal GIF header). The background colour        */
/*                          specified to render_make_animation is now a palette entry and not  */
/*                          an index.                                                          */
/*          09-Oct-97: RML: Background wasn't being filled in correctly on animations.         */
/*          21-Oct-97: KJB: Lots and lots and lots of redraw errors fixed.                     */
/*                          Various optimisations.                                             */
/*---------------------------------------------------------------------------------------------*/
/* To do (inanimate) :                                                                         */
/* Progressive rendering of incomplete images generally shafted in non-2x2 modes.              */
/*                                                                                             */
/* To do (animated) :                                                                          */
/* When disposing of frame 0 with disposal type 3, code wrongly assumes local colour palette   */
/* and 8bpp.                                                                                   */
/*---------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "swis.h"
#include "flex.h"
#include "defines.h"
#include "wimp.h"
#include "imagetrans.h"
#include "internal.h"
#include "png.h"
#include "datastruct.h"
#include "render.h"
#include "lzw_comp.h"
#include "lzw_decomp.h"
#include "rml_misc.h"

/*----------------------------------------------------------------------------------------------------------------------*/

#define LZWDataSize       1000*1024    // A large (!) value so that the LZW compressor doesn't give up.
#define LinesInBlock      8            // How many lines does the LZW compressor output before flushing
#define MaxImages         256          // Maximum number of images open at any one time.
#define MaxAnims          1024         // Maximum number of animations open at any one time.
#define NoBackgroundBit   1            // The flag for no background to be plotted.
#define InternalType      'I'          // To go in type field of structures to identify image as being in internal LZW format.

#define SaveFrames        0            // Debugging
#define SaveFrameHdl      0            // Debugging
#define ExitAfterOne      0            // Debugging

#define WideTableOSV      0xa6         // Minimum OS version (3.6) which supports wide colourtrans tables

/* Rounds x up to the nearest word aligned value */
#define AlignSize(x) (x+3)&~3

/* Finds the frame structure for animation handle h, frame f */
#define FindFrame(h,f) (frame_str*) (anims[h]->frame_data + (f * sizeof(frame_str)))

/*----------------------------------------------------------------------------------------------------------------------*/

static int              interlace_gap[5];                  // The 'gap' between interlace lines ie. 8,8,4,2,(1)
static int              xos, yos, bpp, bytepp, mode;       // pixels->OS Units multipliers, plus bpp for current mode
static int              render_initialised=0;              // Flag to indicate if render_initialise has been called
static int              osver=0;                           // OS version number
static internal_header *images[MaxImages];                 // Set of pointers to the data structures for images
static animated_str    *anims[MaxAnims];                   // Set of pointers to the data structures for animation
static int             *save_area=0;                       // Save area for OS_SpriteOp 60
static int              saveprev0, saveprev1,
                        saveprev2, saveprev3;              // Previous save area values
static int              anim_initialised=0;                // Flag to indicate if animated routines intialised

/*----------------------------------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_error(char *s);
static _kernel_oserror* render_error_and_abandon(int handle, char *s);
static _kernel_oserror* animate_error_and_abandon(int handle, char *s);
static _kernel_oserror* render_start_fast(int handle);
static _kernel_oserror* render_row_fast(int handle);
static _kernel_oserror* render_convert_interlace(int handle);
static int              render_which_row_is_this(int handle, unsigned int n);
static _kernel_oserror* render_between(int handle, int first_line, int last_line);
static _kernel_oserror* render_between_interlace(int handle, int first_line, int last_line);
static _kernel_oserror* render_between_scaled(int handle, int first_line, int last_line);
static _kernel_oserror* render_between_scaled_interlace(int handle, int first_line, int last_line);
static _kernel_oserror* render_whole_scaled_fast(int handle, int printing);
static _kernel_oserror* render_generate_colourtrans_table(int handle);
static _kernel_oserror* render_save_area(void);
static _kernel_oserror* render_vdu_back_to_screen(void);
static int              render_valid_handle(unsigned int handle);
static void             render_initialise(void);
static int              render_which_interlace_offset(int handle, unsigned int n, int *pass);
static void             render_which_row_and_pass_is_this(int handle, int n, unsigned int* row, int* pass);
static unsigned int     render_previous_interlace_line(int handle, int row);
static _kernel_oserror* render_whole(int handle);
static int              render_animate_which_row_is_this(int handle, int n);
static void             render_animate_initialise(void);
static _kernel_oserror* render_animate_create_last_screen(int handle);
static _kernel_oserror* render_animate_clear_last_screen(int handle);
static _kernel_oserror* render_animate_plot_image(int handle, int plot_x, int plot_y, scale_factor scale, int frame);
static _kernel_oserror* render_animate_frame_to_last_screen(int handle, int frame);
static _kernel_oserror* render_animate_do_disposal(int handle);
static _kernel_oserror* render_animate_make_tables(int handle);
static _kernel_oserror* render_animate_generate_table(int handle, int frame);
static int              render_animate_valid_handle(int handle);
static void             render_calculate_interlace_offsets(int handle);
static void             render_read_mode_variables(void);
static int              render_next_frame(int handle);
//static _kernel_oserror* render_sprite_put_screen_palette(char* spr_palette);


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                             Fetching routines                                                   */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_start                                                                               *
 *                                                                                            *
 * Called by a client (eg. c.gif) to begin the compression process.                           *
 *                                                                                            *
 * If image_fast in the flags field has been set, then the image is to be stored as a sprite  *
 * rather than as compressed data, so render_start_fast will be called.                       *
 *                                                                                            *
 * In: type  - type of image (eg. 'G' for GIF etc.) - for future use (ignored presently)      *
 *     w     - width of image in pixels                                                       *
 *     h     - height of image in pixels                                                      *
 *     i     - interlace flag                                                                 *
 *     tp    - transparent colour                                                             *
 *     flags - as for image library                                                           *
 *                                                                                            *
 * Returns: return_handle  - an identifier for this image for all future calls to render      *
 *          return_address - location of start of memory chunk to put bitstream               *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_start(char type, int w, int h, int i, int tp, render_flags flags,
                              int* return_handle, char** return_address)
{
   _kernel_oserror *e;
    internal_header *im;
    sprite_area     *spr;
    int              n, handle, size, datasize;
    char             lpb;

    debug_print("  render_start");

    render_initialise();
    render_read_mode_variables();

    /* Find a slot for the data */
    handle=-1;
    for (n=0; n<MaxImages; n++)
    {
        if (images[n]==0) handle=n;
        if (handle>=0) break;
    }
    if (handle<0) return render_error("Too many images open.");

    debug_value("    render handle ",handle); debug_value("    width ",w); debug_value("    height",h);

    /* How many lines per block? */
    if (i) lpb=1;
    else lpb=LinesInBlock;

    /* How many blocks? */
    n = (h/lpb)+2;

    /* Grab the memory for the data structure */
    images[handle]=malloc(sizeof(internal_header) + (n*sizeof(int)));
    if (!images[handle]) return render_error("No free memory to hold information about this image.");
    im = images[handle];

    /* Store details of this image */
    im->rgb_data      = 0;                  // Store for single row of uncompressed data
    im->lzw_data      = 0;                  // Store for compressed data
    im->spr_data      = 0;                  // Store for sprite data
    im->trtab         = 0;                  // Store for colour translation table
    im->width         = w;                  // width
    im->height        = h;                  // height
    im->type          = type;               // type
    im->scanline      = 0;                  // current scanline of block being recompressed
    im->subscanline   = 0;                  // current scanline in block
    im->interlace     = i;                  // interlace flag
    im->blk_off[0]    = 0;                  // first block offset is zero
    im->no_blks       = 1;                  // number of blocks is 1 to start with
    im->scale.x_mul   = 2;                  // Image scale, x multiplier
    im->scale.x_div   = 1;                  //              x divisor
    im->scale.y_mul   = 2;                  //              y multiplier
    im->scale.y_div   = 1;                  //              y divisor
    im->lzw_ptr       = 0;                  // Pointer to current position in lzw data
    im->transparency  = tp;                 // Transparent colour (-1 for not transparent)
    im->flags         = flags;              // Flags
    im->lzw_handle    = -1;                 // handle for lzw compressor/decompressor
    im->last_sprite_row = -1;

    /* Get memory to store lpb row of uncompressed data (for recompression) */
    size=((w*lpb/4)*4) + 16;
    if (!flex_alloc((flex_ptr)&im->rgb_data, size))
        return render_error_and_abandon(handle, "Can't allocate memory for rgb_data.");

    if (i) render_calculate_interlace_offsets(handle);

    /* If this is a FAST plot, then call a different routine as memory allocation etc. will be different */
    if (flags.image_fast)
    {
        e=render_start_fast(handle);
        *return_handle  = handle;
        *return_address = im->rgb_data;
        if (e) return render_error_and_abandon(handle, e->errmess);
        return NULL;
    }

    /* Get memory to store single row sprite (for plotting) */
    size = sizeof(sprite_area) + sizeof(sprite_header) + AlignSize(w);
    if (im->transparency!=-1) size+=AlignSize(w);
    if (!flex_alloc((flex_ptr)&im->spr_data, size))
       return render_error_and_abandon(handle, "Can't allocate memory for single row sprite.");

    /* Get memory to store new compressed data for whole image */
    datasize=16;
    if (!flex_alloc((flex_ptr)&im->lzw_data, datasize))
        return render_error_and_abandon(handle, "Can't allocate memory for compressed data");

    im->lzw_data_size = datasize;

    spr=im->spr_data;

    /* Initialise sprite area, then create sprite */
    spr->size   = size;
    spr->sproff = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, (int)spr);
    e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, (int)spr, "row", 0, w, 1, 28);
    if (e) return render_error_and_abandon(handle, e->errmess);

    /* Add 256 entry palette */
    e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, (int)spr, "row", (1U<<31)+1);
    if (e) return render_error_and_abandon(handle, e->errmess);

    /* If transparent, add mask */
    if (im->transparency!=-1) e=_swix(OS_SpriteOp, _INR(0,2), 256+SprAddMask, (int)spr, "row");
    if (e) return render_error_and_abandon(handle, e->errmess);

    im->flags.lpb   = lpb;
    *return_handle  = handle;
    *return_address = im->rgb_data;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_initialise                                                                          *
 *                                                                                            *
 * Called by render_start each time, but returns straight away if already been called.        *
 * Reads OS version, pixels scaling, resets array of image structures                         *
 *--------------------------------------------------------------------------------------------*/

static void render_initialise(void)
{
    int n;

    debug_print("  render initialise");

    /* If already initialised, return */
    if (render_initialised) return;

    /* Read in the current OS version */
    if (osver==0) _swix(OS_Byte, _INR(0,2)|_OUT(1), 129, 0, 255, &osver);

    /* Initialise table of pointers to image data structures */
    for (n=0; n<MaxImages; n++) images[n]=0;

    /* Following are spacings between lines on each interlace pass */
    interlace_gap[1]=8;
    interlace_gap[2]=8;
    interlace_gap[3]=4;
    interlace_gap[4]=2;

    render_initialised=1;
}


/*--------------------------------------------------------------------------------------------*
 * render_read_mode_variables                                                                 *
 *                                                                                            *
 * Reads in various details about the current screen mode                                     *
 *--------------------------------------------------------------------------------------------*/

static void render_read_mode_variables(void)
{
    /* Set up scale factors for pixels -> OS units */
    xos = 1 << _swi(OS_ReadModeVariable,_INR(0,1)|_RETURN(2),-1,4);
    yos = 1 << _swi(OS_ReadModeVariable,_INR(0,1)|_RETURN(2),-1,5);
    bpp = 1 << _swi(OS_ReadModeVariable,_INR(0,1)|_RETURN(2),-1,9);

    if      (bpp==32) mode = (6<<27) + (90<<14) + (90<<1) + 1;
    else if (bpp==16) mode = (5<<27) + (90<<14) + (90<<1) + 1;
    else              mode = 28;

    if      (bpp==32) bytepp=4;
    else if (bpp==16) bytepp=2;
    else              bytepp=1;
}


/*--------------------------------------------------------------------------------------------*
 * render_start_fast                                                                          *
 *                                                                                            *
 * Called by render_start if the IMAGE_FAST flag is set, as memory requirements are different *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *                                                                                            *
 * Returns: Error if one occurred, else NULL.                                                 *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_start_fast(int handle)
{
    _kernel_oserror *e;
    internal_header *im=images[handle];
    sprite_area     *spr;
    int              sw, size, w, h;

    debug_value("  render start fast ",handle);

    w=im->width;
    h=im->height;

    /* Problem with sprite extend plotting 1 pixel high sprites */
    if (h<2) h=8;

    /* Get memory to store sprite, bearing in mind word alignment of sprite rows */
    sw = AlignSize(w);
    size=sizeof(sprite_area) + sizeof(sprite_header) + (sw*h);
    if (im->transparency != -1)
        size += sw*h;
    if (!flex_alloc((flex_ptr)&im->spr_data, size))
        return render_error("Can't allocate memory for sprite.");

    spr=im->spr_data;

    /* Initialise sprite area, then create sprite */
    spr->size   = size;
    spr->sproff = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, spr);
    e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, spr, "row", 0, w, h, 28);
    if (e) return e;

    /* Add 256 entry palette */
    e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, spr, "row", (1U<<31)+1);
    if (e) return e;

    /* Create mask */
    if (im->transparency != -1)
    {
        e=_swix(OS_SpriteOp, _INR(0,2), 256+SprAddMask, spr, "row");
        if (e) return e;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_row                                                                                 *
 *                                                                                            *
 * Called by the client each time a row of the image has been put in the bitstream buffer.    *
 *                                                                                            *
 * In: handle - identifier for this image                                                     *
 *                                                                                            *
 * Returns: return_address - (possibly new) location to put bitstream                         *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_row(int handle, char **return_address, int *inc)
{
    _kernel_oserror *e;
    internal_header *im=images[handle];
    int              nb, size, spare, extend;
    int              oldscanline = im->scanline;

    debug_value("  render row ",handle);

    /* Check we've been given a valid handle */
    if (!render_valid_handle(handle)) return NULL;

    /* If it's a fast image, call the appropriate routine */
    if (im->flags.image_fast)
    {
        e=render_row_fast(handle);
        *return_address = im->rgb_data;
        *inc = 1;
        if (e) return render_error_and_abandon(handle, e->errmess);
        return NULL;
    }

    im->subscanline++;
    if (im->subscanline == im->flags.lpb || im->scanline+im->subscanline >= im->height)
    {
        /* ... so how many bytes do we need to have spare to be sure of fitting a block of data? */
        spare  = (im->width < 256) ? 4096*im->subscanline : (im->width * LinesInBlock * 2 * im->subscanline);
        /* and if this isn't free, how much should we extend the area by? */
        extend = 2 * spare;

        if  ( (im->lzw_ptr > (im->lzw_data_size-spare) ) || (im->lzw_data_size<spare) )
        {
            debug_print("    extending flex area");
            size = im->lzw_data_size + extend;
            if (!flex_extend((flex_ptr)&im->lzw_data, size))
                return render_error_and_abandon(handle, "No memory to extend lzw data area.");
            im->lzw_data_size=size;
        }

        /* If this is the first row, then start the compressor */
        if (im->scanline==0)
        {
            im->lzw_handle = LZW_compress_new();
            if (im->lzw_handle==-1)
                return render_error_and_abandon(handle, "Compressor is working on too many images already.");
            e=LZW_compress_start( (uint8*)im->lzw_data + im->lzw_ptr, LZWDataSize, im->lzw_handle);
            if (e) return render_error_and_abandon(handle, e->errmess);
        }

        /* Compress these rows */
        LZW_compress_next( (uint8*)im->lzw_data + im->lzw_ptr, (uint8*)im->rgb_data, im->width * im->subscanline, im->lzw_handle);

        if (im->subscanline == im->flags.lpb)
        {
            /* Flush compression table, so beginning a new block */
            LZW_compress_flush(&nb, im->lzw_handle, (uint8*)im->lzw_data + im->lzw_ptr);
            /* Move the data pointer on */
            im->lzw_ptr += nb;

            /* Update the table of block offsets */
            im->blk_off[im->no_blks++] = im->lzw_ptr;
            /* Restart compression (as long as this isn't the last row) */
            if (im->scanline+im->subscanline < im->height)
            {
                e=LZW_compress_start( (uint8*)im->lzw_data + im->lzw_ptr, LZWDataSize, im->lzw_handle);
                if (e) return render_error_and_abandon(handle, e->errmess);
            }
        }

        /* Increment scanline */
        im->scanline+=im->subscanline;
        im->subscanline = 0;

        /* Check if this is the bottom of the image */
        if (im->scanline>=im->height)
            render_end(handle);
    }

    *return_address = im->rgb_data + im->width * im->subscanline;
    *inc = im->scanline - oldscanline;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_row_fast                                                                            *
 *                                                                                            *
 * Called by render_row if the IMAGE_FAST flag is set, meaning image is store as a sprite     *
 * rather than the compressed LZW data.                                                       *
 *                                                                                            *
 * In: handle - identifier for the image                                                      *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_row_fast(int handle)
{
    internal_header *im=images[handle];
    sprite_header   *spr_head;
    char            *spr_data;
    int              sw, line;

    debug_value("  render row fast ",handle);

    /* Sprites are word aligned, so calculate effective width */
    sw = AlignSize(im->width);

    /* If interlaced picture, then calculate which row in the sprite to put this row of data */
    line=im->scanline;
    if (im->interlace) line=render_which_row_is_this(handle, im->scanline);

    /* Copy the data from the bitstream buffer to the sprite */
    spr_head = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    spr_data = (char*)spr_head + spr_head->image + (line * sw);
    memcpy(spr_data, im->rgb_data, im->width);

    if (im->transparency != -1)
    {
        png_color_16 trns;

        trns.gray = im->transparency;

        /*
         * Use the routine in the PNG stuff :) This will save us grief if we
         * finally sort out non 8-bpp data.
         */
        convert_trns_to_mask((png_bytep) spr_data,
                             (png_bytep) spr_head + spr_head->mask + (line * sw),
                             im->width,
                             8,
                             NULL,
                             0,
                             &trns,
                             PNG_COLOR_TYPE_GRAY /* Okay, it's not grey, but GIF transparency */
                                                 /* works in the same way as PNGs grey        */
                                                 /* transparency, not palette transparency    */
                            );
    }

    /* Increment scanline */
    im->scanline++;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_return_address_for_rgb_data                                                         *
 *                                                                                            *
 * Called by a client to obtain location to put bitstream                                     *
 *                                                                                            *
 * In: handle - identifier for this image                                                     *
 *                                                                                            *
 * Returns: char* - address to put data.                                                      *
 *--------------------------------------------------------------------------------------------*/

char* render_return_address_for_rgb_data(int handle)
{
    internal_header *im=images[handle];

    return (char*)im->rgb_data + im->subscanline * im->width;
}


/*--------------------------------------------------------------------------------------------*
 * render_end                                                                                 *
 *                                                                                            *
 * Called by a client after the last row of the image to stop the compression process.        *
 *                                                                                            *
 * In: handle - identifier for the image                                                      *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_end(int handle)
{
    _kernel_oserror *e;
    internal_header *im=images[handle];
    int nb;

    debug_value("  render end ",handle);
    report_string("render end");

    /* Check it's a valid handle */
    if (!render_valid_handle(handle)) return NULL;

    if (im->type==InternalType) return NULL;

    if (im->flags.image_fast)
    {
        if (im->height<2)
        {
            sprite_header* spr_hdr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
            char*          spr_data = (char*)spr_hdr + spr_hdr->image;
            int            sw, n;

            debug_print("    copying background sprite");

            sw = AlignSize(im->width);

            for (n=1; n<8; n++) memcpy(spr_data + (n*sw), spr_data, sw);
        }
    }
    else
    {
        /* Flush compression table, so beginning a new block */
        LZW_compress_flush(&nb, im->lzw_handle, (uint8*)im->lzw_data + im->lzw_ptr);
        /* Move the data pointer on */
        im->lzw_ptr += nb;
        /* Update the table of block offsets */
        im->blk_off[im->no_blks++] = im->lzw_ptr;

        LZW_compress_end(im->lzw_handle);
        im->lzw_handle = -1;

        if (im->interlace)
        {
            e=render_convert_interlace(handle);
            if (e) return render_error_and_abandon(handle, e->errmess);
        }

        im->internal_size = im->lzw_ptr;
        im->interlace = 0;

        /* Reduce the lzw data size data area down to the lzw data size */
        if (!flex_extend((flex_ptr) &im->lzw_data, im->lzw_ptr))
            return render_error_and_abandon(handle, "Failed in render_end");
    }

    im->type = InternalType;

    debug_print("  render_end finished");

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_delete                                                                              *
 *                                                                                            *
 * Called by a client when an image is finished with. Frees up memory and removes data        *
 * structures.                                                                                *
 *                                                                                            *
 * In: handle - identifier for image                                                          *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_delete(int handle)
{
    internal_header *im=images[handle];

    debug_value("  render_delete ",handle);

    /* Check it's a valid handle */
    if (!render_valid_handle(handle)) return NULL;

    if (im->type!=InternalType)
    {
        if ((!(im->flags.image_fast)) && (im->lzw_handle!=-1)) LZW_compress_end(im->lzw_handle);
        im->type = InternalType;
    }

    /* Free data */
    if (images[handle]->lzw_data) flex_free((flex_ptr) &images[handle]->lzw_data);
    if (images[handle]->rgb_data) flex_free((flex_ptr) &images[handle]->rgb_data);
    if (images[handle]->spr_data) flex_free((flex_ptr) &images[handle]->spr_data);
    if (images[handle]->trtab)    flex_free((flex_ptr) &images[handle]->trtab);

    free(images[handle]);
    images[handle]=0;

    debug_print("  render_delete finished");

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_return_sprite_address                                                               *
 *                                                                                            *
 * Returns the address in memory of the sprite for image with identifier 'handle'. For fast   *
 * images, this sprite will be the same width and height as the source image, but for others, *
 * just a single row.                                                                         *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *                                                                                            *
 * Returns: char* - address of sprite data.                                                   *
 *--------------------------------------------------------------------------------------------*/

char* render_return_sprite_address(int handle)
{
    return (char*) images[handle]->spr_data;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                     Plotting routines for scaled images                                         */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_whole_scaled                                                                        *
 *                                                                                            *
 * Plot an image to the screen at specified co-ordinates and scale.                           *
 *                                                                                            *
 * render_whole_scaled is the routine called by a client to plot an image. It in turn calls   *
 * one of a variety of routines which are tailored to more specific cases :                   *
 *  1. First, a check is made to see if the image is flagged as being fast. If so, it is      *
 *     stored as a sprite, so render_whole_fast is called to plot it.                         *
 *  2. Next, a check is made to see if the scale factor is 100%. If it is, then               *
 *     render_whole is called.                                                                *
 *  3. Next, the graphics window is read to see if it is necessary to plot the whole image.   *
 *     If it isn't, then render_between_scaled or render_between_scaled_interlace is called.  *
 *  4. Only if the WHOLE image is to be plotted, NOT at 100% does execution continue in       *
 *     render_whole_scaled.                                                                   *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *     xc     - x co-ordinate to plot at                                                      *
 *     yc     - y co-ordinate to plot at                                                      *
 *     scale  - scaling structure containing x and y divisors and multipliers                 *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_whole_scaled(int handle, int xc, int yc, scale_factor scale)
{
    _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *row_msk;
    char             *row_img;
    #ifdef TRACE
    int               bytes;
    #endif
    int               x, l, tp, first, last, top, py; //, l1, l2;
    int               width = im->width;
    int               height = im->height;
    int               dcb[8];
    signed int        y;
    gbox              gw;
    int               plotflags;
    int               printing = 0;

    debug_value("  render whole scaled ",handle);

    //_swi(ColourTrans_SetGCOL,_IN(0)|_IN(3)|_IN(4), 0xFF000000, 128, 0);
    //_swi(OS_WriteC,_IN(0),16);
    //_swi(OS_ReadC,0);
    //_swi(ColourTrans_SetGCOL,_IN(0)|_IN(3)|_IN(4), 0x00FF0000, 128, 0);
    //_swi(OS_WriteC,_IN(0),16);

    /* Check it's a valid handle */
    if (!render_valid_handle(handle)) return NULL;

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    render_read_mode_variables();

    /* If not already generated, make a colourtrans table */
    if (!images[handle]->trtab || printing) render_generate_colourtrans_table(handle);

    /* Store current x, y and scale */
    im->x     = xc;
    im->y     = yc;
    im->scale = scale;

    /* If we've not brought in much of the image, then don't bother */
    /*if ( (im->scanline<4) && (!(im->flags.image_fast)) ) return NULL;*/
    if (!im->scanline) return NULL;

    /* If it's a fast image, then call fast routines */
    if (im->flags.image_fast)
    {
        e=render_whole_scaled_fast(handle, printing);
        if (e) return render_error_and_abandon(handle, e->errmess);
        return NULL;
    }

    /* If scale is 1:1, then call another routine which is faster */
    if ((im->scale.x_mul==im->scale.x_div) && (im->scale.y_mul==im->scale.y_div) && !printing)
    {
        if ((xos==2) && (yos==2))
        {
            e=render_whole(handle);
            if (e) return render_error_and_abandon(handle, e->errmess);
            return NULL;
        }
    }

    /* Calculate memory location of the single row sprite, it's image data and it's mask data */
    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;

    if (!printing)
    {
        /* Read the graphics clipping window */
        gw=read_graphics_window();

        y    = im->y / yos;
        top = y + ((height * im->scale.y_mul) / im->scale.y_div);

        /* Calculate the first and last row of the image that we need to plot */
        if (gw.y1 > y) last = im->height - ( (im->scale.y_div * (gw.y1 - y)) / im->scale.y_mul);
        else last = height - 1;
        if (gw.y2 < top) first = im->height - ( (im->scale.y_div * (gw.y2 - y)) / im->scale.y_mul);
        else first = 0;

    #if 0
        /* Calculate the first and last row of the image that we need to plot */
        if (gw.y1 > y) last = ( ((top-gw.y1)*im->scale.y_div) / im->scale.y_mul ) + 1;
        else last = height-1;
        if (gw.y2 < top) first = ( ((top-gw.y2)*im->scale.y_div) / im->scale.y_mul ) - 1;
        else first=0;
    #endif

        /* Add a row either side for luck */
        if (first>0) first--;
        if (last<(height-1)) last++;

        /* Check for strange values of first and last lines - paranoia? */
        if (last<0) return NULL;
        if (first>height) first=0;

        if (first<0) first=0;

        /* If not interlaced, then check that the last line doesn't exceed the scanline */
        if (!im->interlace)
        {
            /*if (im->type==InternalType)
            {*/
                if (last  >= im->scanline)  last=im->scanline-1;
                if (first >= im->scanline) first=im->scanline-1;
            /*}
            else
            {
                if (last  > (im->scanline-4))  last=im->scanline-4;
                if (first > (im->scanline-4)) first=im->scanline-4;
            }*/
        }

        /* If we're not plotting the whole image, then call routine to plot between */
        /* the specified rows, and return */
        if (  (first>0)  ||  (last < (height-1))  ||  (im->interlace)  )
        {
            if (im->interlace) e=render_between_scaled_interlace(handle, first, last);
            else e=render_between_scaled(handle, first, last);
            if (e) return render_error_and_abandon(handle, e->errmess);
            return NULL;
        }
    }

    debug_print("  still in render whole scaled");
    debug_value("    first  ",first);
    debug_value("    last   ",last);
    debug_value("    height ",height);

    /* We're drawing the whole image, so set the lzw data pointer to the start */
    e=LZW_decompress_start((uint8*) im->lzw_data);
    if (e) return render_error_and_abandon(handle, e->errmess);

    /* Work out x co-ordinates of destination coordinate block - these don't change */
    dcb[0] = dcb[6] = im->x * 256;                                                        /* x0 */
    dcb[2] = dcb[4] = dcb[0] + ((im->scale.x_mul*xos*256*width) / im->scale.x_div);   /* x1 */

    plotflags = 16;
    if (osver >= WideTableOSV) plotflags |= 32;
    if (tp != -1) plotflags |= 8;

    /* Loop through from the top of the image to the bottom */
    for (l=0; l<height; l++)
    {
        py = (height-l-1);

        /* Decompress next row */
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) im->lzw_data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) im->lzw_data);
        #endif
        if (e) return render_error_and_abandon(handle, e->errmess);

        /* Setup mask */
        if (tp!=-1)
        {
            for (x=0; x<width; x++)
            {
                if (row_img[x]==tp) row_msk[x]=0;
                else row_msk[x]=255;
            }
        }

        /* If a whole row hasn't been returned, then something's gone wrong */
        #ifdef TRACE
        if (bytes!=width) return render_error_and_abandon(handle, "Couldn't decompress whole row.");
        #endif

        /* Update y0 and y1 */
        dcb[1] = dcb[3] = (256*im->y) + ( ( 256*yos*im->scale.y_mul *   py    ) / im->scale.y_div );  /* y0 */
        dcb[5] = dcb[7] = dcb[1]      + ( ( 256*yos*im->scale.y_mul + im->scale.y_div - 1) / im->scale.y_div );  /* y1 */

        /* Plot sprite */
        e=_swix(OS_SpriteOp, _INR(0,7),
                             512+SprPutTrans,
                             im->spr_data,
                             row_spr,
                             1,
                             0,
                             plotflags,
                             dcb,
                             im->trtab);
        if (e) return e;
    }

    LZW_decompress_end();

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_between_scaled                                                                      *
 *                                                                                            *
 * Called by render_whole_scaled if not all the image is visible and so we only need to plot  *
 * the portion of the image between a first line and a last line.                             *
 *                                                                                            *
 * In: handle     - identifier for the image.                                                 *
 *     first_line - first row of image to plot.                                               *
 *     last_line  - last row of image to plot.                                                *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_between_scaled(int handle, int first_line, int last_line)
{
    _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *row_msk;
    char             *row_img;
    char             *data;
    #ifdef TRACE
    int               bytes;
    #endif
    int               first_block, last_block, l, x, tp, lzw_redraw_ptr, plotflags;
    int               width = im->width;
    int               height = im->height;
    int               dcb[8];

    debug_value("  render between scaled ",handle);

    /* Calculate the location of the single row sprite, it's image data and it's mask data */
    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;
    plotflags = 0;
    if (osver >= WideTableOSV) plotflags |= 32;
    if (tp != -1) plotflags |= 8;

    /* Check that we've actually read the last line - if not, set it to the last one we have */
    if ( last_line >= im->scanline ) last_line=im->scanline-1;

    /* Work out the first block (the block the first line is in) and the last block  */
    /* (the block the last line is in) - we will have to decompress fully all blocks */
    /* between and including these two. */
    first_block = first_line / im->flags.lpb;
    last_block  = last_line  / im->flags.lpb;

    /* Set the LZW data pointer to the first block */
    lzw_redraw_ptr = im->blk_off[first_block];
    data = (char*) ( (int)im->lzw_data + lzw_redraw_ptr);
    e=LZW_decompress_start((uint8*) data);
    if (e) return e;

    /* Work out x co-ordinates of destination coordinate block - these don't change */
    dcb[0] = dcb[6] = im->x * 256;                                                      /* x0 */
    dcb[2] = dcb[4] = dcb[0] + ((im->scale.x_mul*xos*256*width) / im->scale.x_div); /* x1 */

    /* Loop through all the scanlines contained between first_block and last_block */
    for (l=(first_block * im->flags.lpb); l<=last_line; l++)
    {
        /* Decompress next row */
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data);
        #endif
        if (e) return e;

        #ifdef TRACE
        /* If not a whole row of data, something's gone wrong */
        if (bytes!=width) return render_error("Decompression failed - not a whole row.\n");
        #endif

        /* Setup mask */
        if (tp!=-1)
        {
            for (x=width-1; x>=0; x--)
            {
                if (row_img[x]==tp) row_msk[x]=0;
                else row_msk[x]=255;
            }
        }

        /* If line is within the two limits specified (we've checked for l<=last_line above), then plot it */
        if (l>=first_line)
        {
            /* Update y0 and y1 */
            dcb[1] = dcb[3] = (256*im->y) + ( ( (256*yos*im->scale.y_mul) * (height-l-1) ) / im->scale.y_div );  /* y0 */
            dcb[5] = dcb[7] = dcb[1]      + (   (256*yos*im->scale.y_mul + im->scale.y_div - 1 ) / im->scale.y_div );  /* y1 */

            /* Plot sprite */
            e=_swix(OS_SpriteOp, _INR(0,7),
          		         512+SprPutTrans,
        			 im->spr_data,
        			 row_spr,
        			 1,
        			 0,
        			 osver>=WideTableOSV ? 40:8,
        			 dcb,
        			 im->trtab);
            if (e) return e;
        }
    }

    /* End decompression */
    LZW_decompress_end();

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_between_scaled_interlace                                                            *
 *                                                                                            *
 * As for render_between, but for interlaced images. Called by render_whole_scaled if not all *
 * the image is visible and so we only need to plot the portion of the image between a first  *
 * line and a last line.                                                                      *
 *                                                                                            *
 * In: handle     - identifier for the image.                                                 *
 *     first_line - first row of image to plot.                                               *
 *     last_line  - last row of image to plot.                                                *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_between_scaled_interlace(int handle, int first_line, int last_line)
{
    _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *row_msk;
    char             *row_img;
    char             *data;
    #ifdef TRACE
    int               bytes;
    #endif
    int               m, x, tp, pass, lzw_redraw_ptr;
    unsigned int      l;
    int               b, c;
    int               width = im->width;
    int               height = im->height;
    int               dcb[8];
    int               plotflags;

    debug_value("  render between scaled interlace ",handle);

    b = im->interlace_b;
    c = im->interlace_c;

    /* If it's the first pass and we're trying to plot further down than we've fetched, don't bother */
    render_which_row_and_pass_is_this(handle, im->scanline, &l, &pass);
    if ((pass==1) && (first_line>=l)) return NULL;
    if ((pass==1) && (last_line>=l)) last_line=l-1;

    /* Calculate the location of the single row sprite, it's image data and it's mask data */
    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;

    /* Work out x co-ordinates of destination coordinate block - these don't change    */
    dcb[0] = dcb[6] = im->x * 256;                                                        /* x0 */
    dcb[2] = dcb[4] = dcb[0] + ((im->scale.x_mul*xos*256*width) / im->scale.x_div);   /* x1 */
    plotflags = 0;
    if (osver >= WideTableOSV) plotflags |= 32;
    if (tp != -1) plotflags |= 8;

    /* Wind back first_line to a line we actually have */
    m = render_which_interlace_offset(handle, first_line, &pass);
    if (m >= im->scanline)
        first_line = render_previous_interlace_line(handle, first_line);

    for (l=first_line; l<=last_line; l++)
    {
        /* Update y0 and y1 */
        dcb[1] = dcb[3] = (256*im->y) + ( ( (256*yos*im->scale.y_mul) * (height-l-1) ) / im->scale.y_div );  /* y0 */
        dcb[5] = dcb[7] = dcb[1]      + (   (256*yos*im->scale.y_mul + im->scale.y_div - 1 ) / im->scale.y_div );  /* y1 */

        /* Find out where line l is in the data */
        m = render_which_interlace_offset(handle, l, &pass);

        /* If we have fetched this row, then... */
        if (m < im->scanline)
        {
            /* Set LZW data pointer to this line */
            lzw_redraw_ptr = im->blk_off[m];
            data = (char*) ( (int)im->lzw_data + lzw_redraw_ptr);
            e=LZW_decompress_start((uint8*) data);
            if (e) return e;

            /* Decompress row */
            #ifdef TRACE
            e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data, &bytes);
            #else
            e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data);
            #endif
            if (e) return e;

            #ifdef TRACE
            /* If not a whole row of data, something's gone wrong */
            if (bytes!=width) return render_error("Decompression failed - not a whole row.\n");
            #endif

            /* Do mask */
            if (tp!=-1)
            {
                for (x=0; x<width; x++)
                {
                    if (row_img[x]==tp) row_msk[x]=0;
                    else row_msk[x]=255;
                }
            }

            /* End decompression */
            LZW_decompress_end();
        }

        /* Plot sprite */
        e=_swix(OS_SpriteOp, _INR(0,7),
                             256+SprPutTrans,
       			     (int)im->spr_data,
       			     "row",
       			     1,
       			     0,
       			     plotflags,
       			     dcb,
       			     im->trtab);
        if (e) return e;
    }

    return NULL;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                              Plotting routines for non-scaled (1:1) images                                      */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_whole                                                                               *
 *                                                                                            *
 * Plot the whole of the image onto the screen, unscaled. If graphic window defined, call     *
 * routine to plot only part of the image that is visible.                                    *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_whole(int handle)
{
    _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *row_msk;
    char             *row_img;
    #ifdef TRACE
    int               bytes;
    #endif
    int               x, first, last, tp, py;
    int               width = im->width;
    int               height = im->height;
    signed int        y;
    gbox              gw;
    int               plotflags;

    debug_value("  render whole ",handle);

    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;

    plotflags = 0;
    if (osver >= WideTableOSV) plotflags |= 32;
    if (tp != -1) plotflags |= 8;

    /* Read the graphics clipping window */
    gw=read_graphics_window();
    y = im->y / yos;

    /* Calculate the first and last row of the image that we need to plot */
    if (gw.y1 > y) last = height - (gw.y1 - y);
    else last = height-1;
    if (gw.y2 < (y + height)) first = height - (gw.y2 - y);
    else first = 0;

    /* Add a row either side for luck */
    if (first>0) first--;
    if (last<(height-1)) last++;

    /* Check for strange values of first and last lines - paranoia? */
    if (last<0) return NULL;
    if (first>=height) first=height-1;

    if (first<0) first=0;

    /* If not interlaced, then check that the last line doesn't exceed the scanline */
    if (!im->interlace)
    {
        /*if (im->type==InternalType)
        {*/
            if (last  >= im->scanline)  last=im->scanline-1;
            if (first >= im->scanline) first=im->scanline-1;
        /*}
        else
        {
            if (last  > (im->scanline-4))  last=im->scanline-4;
            if (first > (im->scanline-4)) first=im->scanline-4;
        }*/
    }

    /* Check that above conditions haven't made last>first */
    if (first>last) first=last;

    /* If we're not plotting the whole image, then call routine to plot between */
    /* the specified rows, and return */
    if (  (first>0)  ||  (last < (height-1))  ||  (im->interlace)  )
    {
        if (im->interlace) e=render_between_interlace(handle, first, last);
        else e=render_between(handle, first, last);
        if (e) return e;
        return NULL;
    }

    debug_print("  Still in render whole");

    /* Check we've scanned upto the last line */
    if (last > im->scanline-1) last=im->scanline-1;

    /* Else we're plotting the whole image, so move the redraw pointer to the start of the data */
    e=LZW_decompress_start((uint8*) im->lzw_data);
    if (e) return e;

    for (y=0; y<height; y++)
    {
        py = (height-y-1) * yos;

        /* Decompress next row */
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) im->lzw_data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) im->lzw_data);
        #endif
        if (e) return e;

        #ifdef TRACE
        /* If not a whole row of data, something's gone wrong */
        if (bytes!=width) return render_error("Decompression failed - not a whole row.\n");
        #endif

        /* Setup mask */
        if (tp!=-1)
        {
            for (x=0; x<width; x++)
            {
                if (row_img[x]==tp) row_msk[x]=0;
                else row_msk[x]=255;
            }
        }

        /* Plot sprite */
        e=_swix(OS_SpriteOp, _INR(0,7),
                             512+SprPutScaled,
      			     im->spr_data,
      			     row_spr,
      			     im->x,
      			     im->y + py,
      			     plotflags,
      			     0,
      		             im->trtab);
        if (e) return e;
    }

    LZW_decompress_end();

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_between                                                                             *
 *                                                                                            *
 * Called by render_whole if not all the image is visible and so we only need to plot the     *
 * portion of the image between a first line and a last line.                                 *
 *                                                                                            *
 * In: handle     - identifier for the image.                                                 *
 *     first_line - first row of image to plot.                                               *
 *     last_line  - last row of image to plot.                                                *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_between(int handle, int first_line, int last_line)
{
    _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *data;
    char             *row_msk;
    char             *row_img;
    #ifdef TRACE
    int               bytes;
    #endif
    int               first_block, last_block, x, y, l, tp, lzw_redraw_ptr;
    int               width = im->width;
    int               height = im->height;

    debug_value("  render between ",handle);

    /* Calculate location of single row sprite, it's image data and it's mask data */
    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;

    /* Work out the first block (the block the first line is in) and the last block  */
    /* (the block the last line is in) - we will have to decompress fully all blocks */
    /* between and including these two. */
    first_block = first_line / im->flags.lpb;
    last_block  = last_line  / im->flags.lpb;

    /* Set the LZW data pointer to the first block */
    lzw_redraw_ptr = im->blk_off[first_block];
    data = (char*) ( (int)im->lzw_data + lzw_redraw_ptr);
    e=LZW_decompress_start((uint8*) data);
    if (e) return e;

    debug_value("    b first line ",first_line);
    debug_value("    b last line  ",last_line);

    /* Loop through all the scanlines contained between first_block and last_block */
    for (l=(first_block * im->flags.lpb); l<=last_line; l++)
    {
        y = yos * (height - l - 1);

        /* Decompress next row */
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data);
        #endif
        if (e) return e;

        #ifdef TRACE
        /* If not a whole row of data, something's gone wrong */
        if (bytes!=width) return render_error("Decompression failed - not a whole row.");
        #endif

        /* Setup mask */
        if (tp!=-1)
        {
            for (x=width-1; x>=0; x--)
                row_msk[x] = row_img[x] == tp ? 0 : 255;
        }

        /* If line is within the two limits specified, then plot it */
        if ((l>=first_line) && (l<=last_line))
        {
            e=_swix(OS_SpriteOp, _INR(0,7),
                                 256+SprPutScaled,
        			 (int)im->spr_data,
        			 "row",
        			 im->x,
        			 im->y + y,
        			 osver>=WideTableOSV ? 40:8,
        			 0,
        			 im->trtab);
            if (e) return e;
        }
    }

    /* End decompression */
    LZW_decompress_end();

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_between_interlace                                                                   *
 *                                                                                            *
 * As for render_between, but for interlaced images. Called by render_whole if not all the    *
 * image is visible and so we only need to plot the portion of the image between a first line *
 * and a last line.                                                                           *
 *                                                                                            *
 * In: handle     - identifier for the image.                                                 *
 *     first_line - first row of image to plot.                                               *
 *     last_line  - last row of image to plot.                                                *
 *                                                                                            *
 * Returns: Any error, else NULL.                                                             *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_between_interlace(int handle, int first_line, int last_line)
{
   _kernel_oserror  *e;
    internal_header  *im=images[handle];
    sprite_header    *row_spr;
    char             *row_msk;
    char             *row_img;
    char             *data;
    int               y, m, x, tp, pass, scanpass, lzw_redraw_ptr, plotflags;
    unsigned int      l;
    #ifdef TRACE
    int               bytes;
    #endif
    int               scanline = im->scanline;
    int               b, c;
    int               imx = im->x;
    int               imy = im->y;
    int               width = im->width;
    int               height = im->height;

    debug_value("  render between interlace ",handle);

    b = im->interlace_b;
    c = im->interlace_c;

    /* If it's the first pass and we're trying to plot further down than we've fetched, don't bother */
    render_which_row_and_pass_is_this(handle, scanline, &l, &scanpass);
    if ((scanpass==1) && (first_line>=l)) return NULL;
    if ((scanpass==1) && (last_line>=l)) last_line=l-1;

    /* Calculate location of the single row sprite, it's image data and it's mask data */
    row_spr = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    row_img = (char*)row_spr + row_spr->image;
    row_msk = (char*)row_spr + row_spr->mask;
    tp=im->transparency;

    plotflags = 0;
    if (osver >= WideTableOSV) plotflags |= 32;
    if (tp != -1) plotflags |= 8;

    /* Wind back first_line to a line we actually have */
    m = render_which_interlace_offset(handle, first_line, &pass);
    if (m >= scanline)
        first_line = render_previous_interlace_line(handle, first_line);

    y = yos * (height - first_line);
    for (l=first_line; l<=last_line; l++)
    {
        /* Calculate y co-ordinate */
        y -= yos;

        /* Find out where line l is in the data */
        m = render_which_interlace_offset(handle, l, &pass);

        /* If we have fetched this row, then... */
        if (m < im->scanline)
        {
            /* Set LZW data pointer to this line */
            lzw_redraw_ptr = im->blk_off[m];
            data = (char*) ( (int)im->lzw_data + lzw_redraw_ptr);
            e=LZW_decompress_start((uint8*) data);
            if (e) return e;

            /* Decompress row */
            #ifdef TRACE
            e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data, &bytes);
            #else
            e=LZW_decompress_next((uint8*)row_img, width, (uint8*) data);
            #endif
            if (e) return e;

            #ifdef TRACE
            /* If not a whole row of data, something's gone wrong */
            if (bytes!=width)
                return render_error("Decompression failed - not a whole row.\n");
            #endif

            /* Do mask */
            if (tp!=-1)
            {
                for (x=0; x<width; x++)
                {
                    if (row_img[x]==tp) row_msk[x]=0;
                    else row_msk[x]=255;
                }
            }

            /* End decompression */
            LZW_decompress_end();
            im->last_sprite_row = m;
        }

        /* Plot sprite */
        e=_swix(OS_SpriteOp, _INR(0,7),
                             512+SprPutScaled,
                             (int)im->spr_data,
                             row_spr,
                             imx,
                             imy + y,
                             plotflags,
         		     0,
                             im->trtab);

        if (e) return e;
    }

    return NULL;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                        Plotting routines for fast images                                        */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_whole_scaled_fast                                                                   *
 *                                                                                            *
 * Called by render_whole_scaled if image to be plotted has the IMAGE_FAST flag set (ie. is   *
 * stored as a whole sprite, not compressed).                                                 *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *                                                                                            *
 * Returns: Error, if one occurred, or NULL.                                                  *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_whole_scaled_fast(int handle, int printing)
{
    internal_header *im=images[handle];

    debug_value("  render_whole_scaled_fast ",handle);

    if (im->scale.x_mul == im->scale.x_div && im->scale.y_mul == im->scale.y_div
          && im->trtab == NULL && !printing)
        return _swix(OS_SpriteOp, _INR(0,5),
                                  256+SprPutSprite,
         			  im->spr_data,
         			  "row",
         			  im->x,
         			  im->y,
         			  8);
    else
        return _swix(OS_SpriteOp, _INR(0,7),
                                  256+SprPutScaled,
           	                  im->spr_data,
                 		  "row",
                 		  im->x,
                 		  im->y,
                 		  osver>=WideTableOSV ? 40:8,
                 		  &im->scale,
                 		  im->trtab);
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                             Routines for handling interlace pictures                                            */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_convert_interlace                                                                   *
 *                                                                                            *
 * Called after all the data for an interlaced picture has been recompressed. It rearranges   *
 * the rows of data in the correct order for display.                                         *
 *                                                                                            *
 * In: handle - identifier for the image                                                      *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_convert_interlace(int handle)
{
    internal_header *im=images[handle];
    char            *lzw;
    int              offset, new_ptr, old_ptr, size;
    unsigned int     n;
    /*int              a = im->interlace_a;*/
    int              b = im->interlace_b;
    int              c = im->interlace_c;
    int              d = im->interlace_d;
    int              height=im->height;
    int             *new_blk_off;

    debug_value("  render convert interlace ",handle);

    if (im->scanline != height) return NULL;

    if (!flex_alloc((flex_ptr)&new_blk_off, sizeof(int)*height))
        return render_error("Can't allocate memory to convert interlaced picture.");
    //new_blk_off = malloc(sizeof(int)*height);
    //if (!new_blk_off) return render_error("Can't allocate memory to convert interlaced picture.");

    /* Get memory to store new compressed data */
    if (!flex_alloc((flex_ptr)&lzw, im->lzw_data_size + 4096))
    {
        flex_free((flex_ptr)&new_blk_off);
        return render_error("Can't allocate memory for compressed data");
    }

    //lzw = malloc(im->lzw_data_size + 4096);
    //if (!lzw) return render_error("Can't allocate memory for compressed data");

    new_ptr=0;
    for (n=0; n<height; n++)
    {
        /* Work out where in the order the nth row came in eg. the 8th row of the
           image is actually sent as the 2nd row. */
             if ((n & 7) == 0) offset = /*a +*/ (n >> 3);
        else if ((n & 3) == 0) offset = b + ((n-4) >> 3);
        else if ((n & 1) == 0) offset = c + ((n-2) >> 2);
        else                   offset = d + ((n-1) >> 1);

        if (offset>height) offset=height;

        /* Copy the data for the row */
        old_ptr = im->blk_off[offset];
        new_blk_off[n]=new_ptr;
        size = im->blk_off[offset+1] - im->blk_off[offset];
        //printf("size %d\n",size);
        memcpy(lzw+new_ptr, im->lzw_data+old_ptr, size);
        new_ptr+=size;
        old_ptr+=size;
    }

    /* Copy the new data back over the old data */
    memcpy(im->lzw_data, lzw, im->lzw_data_size);

    /* Free the temporary store */
    flex_free((flex_ptr)&lzw);
    //free(lzw);

    /* Copy the new blk offsets over the old ones */
    for (n=0; n<height; n++) im->blk_off[n]=new_blk_off[n];

    //free(new_blk_off);
    flex_free((flex_ptr)&new_blk_off);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_which_interlace_offset                                                              *
 *                                                                                            *
 * For interlaced images, given the (actual) row of an image, returns the row (and pass) it   *
 * was sent as.                                                                               *
 *                                                                                            *
 * In: handle - identifier for this image                                                     *
 *     n      - row number                                                                    *
 *     pass   - pointer to location to store the pass the row came in (1 being first)         *
 *                                                                                            *
 * Returns: the order the row came in (0 being first)                                         *
 *--------------------------------------------------------------------------------------------*/

static int render_which_interlace_offset(int handle, unsigned int n, int *pass)
{
    internal_header *im=images[handle];
    int              offset;

    /* Work out where in the order the nth row came in eg. the 8th row of the image is actually sent as the 2nd row. */

    if ((int) n < 0) return 10000;

    /* Row was in first pass */
    if ( (n & 7) == 0 )
    {
        offset = /*im->interlace_a +*/ n >> 3;
        *pass = 8;
    }

    /* Row was in second pass */
    else if ( (n & 3) == 0 )
    {
        offset = im->interlace_b + ((n - 4) >> 3);
        *pass = 4;
    }

    /* Row was in third pass */
    else if ( (n & 1) == 0 )
    {
        offset = im->interlace_c + ((n - 2) >> 2);
        *pass = 2;
    }

    /* Row was in final pass */
    else
    {
        offset = im->interlace_d + ((n - 1) >> 1);
        *pass = 1;
    }

    if ( offset > (im->scanline-1) ) return 20000;
    else return offset;
}


/*--------------------------------------------------------------------------------------------*
 * render_which_row_is_this                                                                   *
 *                                                                                            *
 * For interlaced images, given the order this row arrived (eg. 6th to arrive), return the    *
 * actual row in the image.                                                                   *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *     n      - nth row to arrive.                                                            *
 *                                                                                            *
 * Returns: int - actual row in image.                                                        *
 *--------------------------------------------------------------------------------------------*/

static int render_which_row_is_this(int handle, unsigned int n)
{
    internal_header *im=images[handle];
    /*int              a = im->interlace_a;*/
    int              b = im->interlace_b;
    int              c = im->interlace_c;
    int              d = im->interlace_d;
    int              offset;

         if (n<b) offset = ( (n/*-a*/) << 3 ) + 0;
    else if (n<c) offset = ( (n-b) << 3 ) + 4;
    else if (n<d) offset = ( (n-c) << 2 ) + 2;
    else          offset = ( (n-d) << 1 ) + 1;

    if (offset >= im->height) offset = im->height - 1;

    return offset;
}


/*--------------------------------------------------------------------------------------------*
 * render_which_row_and_pass_is_this                                                          *
 *                                                                                            *
 * For interlaced images, given the order this row arrived (eg. 6th to arrive), return the    *
 * actual row in the image, plus the pass it arrived in.                                      *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *     n      - nth row to arrive.                                                            *
 *                                                                                            *
 * Returns: int  - actual row in image.                                                       *
 *          pass - pass row arrived in.                                                       *
 *--------------------------------------------------------------------------------------------*/

static void render_which_row_and_pass_is_this(int handle, int n, unsigned int* row, int* pass)
{
    internal_header *im=images[handle];
    /*int              a = im->interlace_a;*/
    int              b = im->interlace_b;
    int              c = im->interlace_c;
    int              d = im->interlace_d;

    if (n < 0) n=0;
    if (n >= im->height) n = im->height - 1;

    if (n<b)
    {
        *row  = ( (n/*-a*/) << 3 ) + 0;
        *pass = 1;
    }
    else if (n<c)
    {
        *row  = ( (n-b) << 3 ) + 4;
        *pass = 2;
    }
    else if (n<d)
    {
        *row  = ( (n-c) << 2 ) + 2;
        *pass = 3;
    }
    else
    {
        *row  = ( (n-d) << 1 ) + 1;
        *pass = 4;
    }

}


/*--------------------------------------------------------------------------------------------*
 * render_previous_interlace_line                                                             *
 *                                                                                            *
 * For interlaced images, given a physical line in the image, return the closest previous     *
 * physical line that we've actually received. Assumes that row hasn't actually been fetched, *
 * and that row isn't below the scanline on the first pass                                    *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *     row    - physical row to arrive.                                                       *
 *                                                                                            *
 * Returns: int  - actual row in image.                                                       *
 *          pass - pass row arrived in.                                                       *
 *--------------------------------------------------------------------------------------------*/

static unsigned int render_previous_interlace_line(int handle, int row)
{
    internal_header *im=images[handle];
    unsigned int     n, scanline = im->scanline;
    int              pass;

    render_which_row_and_pass_is_this(handle, scanline, &n, &pass);

    if (row <= 0) return 0;
    if (row >= im->height) row = im->height - 1;

    switch (pass)
    {
      case 1:
        return row &~ 7;
        break;

      case 2:
        if (row < (scanline - im->interlace_b) * 8 + 4)
            return row &~ 3;
        else
            return row &~ 7;
        break;

      case 3:
        if (row < (scanline - im->interlace_c) * 4 + 2)
            return row &~ 1;
        else
            return row &~ 3;
        break;

      default:
        return row &~ 1;
        break;
    }
}


/*--------------------------------------------------------------------------------------------*
 * render_calculate_interlace_offsets                                                         *
 *                                                                                            *
 * Calculates some values which are used in determining plotting positions of rows of an      *
 * interlaced image.                                                                          *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *--------------------------------------------------------------------------------------------*/

static void render_calculate_interlace_offsets(int handle)
{
    int height = images[handle]->height;
    int na, nb, nc, nd, a, b, c, d;

    /* The interlaced GIF is stored as...
         a) every eigth row  +0 (ie. beginning at scanline 0)
         b) every eigth row  +4 (ie. beginning at scanline 4)
         c) every fourth row +2 (ie. beginning at scanline 2)
         d) every second row +1 (ie. beginning at scanline 1)
      a,b,c,d are the offsets (in terms of number of lines) to the appropriate data
      as symboled above, so 'd' contains the number of rows that have to be trawled
      through before we get to the data for every second row. */
    na = (height - 0)/8;
    nb = (height - 4)/8;
    nc = (height - 2)/4;
    nd = (height - 1)/2;

    if ( ((na*8)+0) >= height) na--;
    if ( ((nb*8)+4) >= height) nb--;
    if ( ((nc*4)+2) >= height) nc--;
    if ( ((nd*2)+1) >= height) nd--;

    na++; nb++; nc++; nd++;

    a=0; b=a+na; c=b+nb; d=c+nc;

    /*images[handle]->interlace_a = a;*/
    images[handle]->interlace_b = b;
    images[handle]->interlace_c = c;
    images[handle]->interlace_d = d;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                               Miscellaneous routines                                            */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_generate_colourtrans_table                                                          *
 *                                                                                            *
 * Generates the ColourTrans translation table for the image specified.                       *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, or NULL otherwise.                                        *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_generate_colourtrans_table(int handle)
{
    internal_header *im = images[handle];
    _kernel_oserror *e = NULL;
    int              buffsize, islinear=1;

    if (im->trtab) flex_free((flex_ptr)&im->trtab);

    e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                       im->spr_data,
    				       im->spr_data+1,
    				       -1,
    				       -1,
    				       0,
    				       osver>=WideTableOSV ? 16+1:1,
    				       &buffsize);
    if (e) return e;

    if (buffsize == 0)
        return NULL;

    if (!flex_alloc((flex_ptr)&im->trtab, buffsize)) return render_error("No room for translation table.");

    im=images[handle];
    e=_swix(ColourTrans_GenerateTable, _INR(0,5),
    	                               im->spr_data,
    	      			       im->spr_data+1,
    				       -1,
    				       -1,
    				       im->trtab,
    				       osver>=WideTableOSV ? 16+1:1);
    if (e) return e;

    /*
     * It's always a table from a 256-colour image, thus the size of the entries
     * is determined by the buffer size...
     */
    if (buffsize == 256)
    {
        char *tab = im->trtab;
        int i, job=0;

        _swix(PDriver_CurrentJob, _OUT(0), &job);
        if (!job)
        {
            for (i=0; i<256; i++)
                if (tab[i] != i)
                {
                    islinear = 0;
                    break;
                }

            if (islinear)
                flex_free((flex_ptr)&im->trtab);
        }
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_mode_change                                                                         *
 *                                                                                            *
 * Called by a client upon a mode change. Regenerates the colour translation tables.          *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, or NULL otherwise.                                        *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_mode_change(int handle)
{
    render_read_mode_variables();

    if (images[handle]->trtab) flex_free((flex_ptr)&images[handle]->trtab);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_changed                                                                             *
 *                                                                                            *
 * Given the first and last line of an image, calculate the bounding box spanning those lines *
 * In: handle    - identifier for the image.                                                  *
 *     first     - the first line to be spanned.                                              *
 *     last      - the last line enclosed by the box.                                         *
 *     interlace - 1 for interlaced, 0 for not interlaced. Passed because render may have     *
 *                 changed it's copy of the value.                                            *
 *                                                                                            *
 * Returns: changed - the bounding box.                                                       *
 *--------------------------------------------------------------------------------------------*/

void render_changed(int handle, int first, int last, int interlace, BBox *changed)
{
    internal_header  *im=images[handle];
    int               first_pass, last_pass;
    unsigned int      first_row, last_row;

    render_read_mode_variables();

    if (first == last)
    {
        changed->xmin = changed->xmax = changed->ymin = changed->ymax = 0;
        return;
    }

    changed->xmin = 0;
    changed->xmax = im->width * xos;

    if (interlace==0)
    {
        first -= 1;
        changed->ymin = (im->height - last) * yos;
        changed->ymax = (im->height - first) * yos;
        return;
    }

    render_which_row_and_pass_is_this(handle, first, &first_row, &first_pass);
    render_which_row_and_pass_is_this(handle, last,  &last_row,  &last_pass);

    if (last_pass==first_pass || last_pass==first_pass+1 && last_row < first_row)
    {
        changed->ymin = (im->height - last_row) * yos;
        changed->ymax = (im->height - first_row) * yos;
    }
    else
    {
        changed->ymin = 0;
        changed->ymax = im->height * yos;
    }
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                                 Animation routines                                              */
/*-----------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------*
 * render_animate_start                                                                       *
 *                                                                                            *
 * Called at the start of the loading/fetching process for an animated image to begin the     *
 * decoding process.                                                                          *
 *                                                                                            *
 * In: screenw       - Screen width, as specified in GIF file                                 *
 *     screenh       - Screen height                                                          *
 *     return_handle - pointer to location to put handle allocated to this animation.         *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_start(int screenw, int screenh, unsigned int loops, int* return_handle)
{
    _kernel_oserror *e;
    animated_str    *an;
    sprite_area     *spr_area;
    int              n, handle;
    render_flags     flags;

    if (!anim_initialised) render_animate_initialise();

    /* Find a free structure */
    handle=-1;

    for (n=0; n<MaxAnims; n++)
    {
        if (anims[n]==0) handle=n;
        if (handle>=0) break;
    }

    if (handle<0) return render_error("Too many animations are open already.");

    memset(&flags, 0, 4);
    /* Problem with spriteextend directing vdu to 1 pixel high sprites, so if screen height is 1, make it 2! */
    if (screenh==1)
    {
        flags.onepixelhigh=1;
        screenh=2;
    }

    flags.render_type=2;

    /* Allocate memory for this structure */
    anims[handle] = malloc(sizeof(animated_str));
    if (!anims[handle]) return render_error("Insufficient memory to store animation data.");
    an=anims[handle];

    /* Allocate an arbitary sized chunk for the rgb data */
    if (!flex_alloc((flex_ptr)&an->rgb_data, sizeof(sprite_area)))
    {
        free(anims[handle]);
        return render_error("Can't get space for animation image data.");
    }

    /* Allocate an arbitary sized chunk for the restore data */
    if (!flex_alloc((flex_ptr)&an->restore, 4))
    {
        flex_free((flex_ptr)&an->rgb_data);
        free(anims[handle]);
        return render_error("Can't get space for restore data.");
    }

    /* Allocate space for (initially) two frames */
    if (!flex_alloc((flex_ptr)&an->frame_data, sizeof(frame_str)*2))
    {
        flex_free((flex_ptr)&an->restore);
        flex_free((flex_ptr)&an->rgb_data);
        free(anims[handle]);
        return render_error("Can't get space for frame data");
    }


    /* Allocate an initial 4k chunk for the colour translation tables */
    if (!flex_alloc((flex_ptr)&an->fr_trtabs, 4096))
    {
        flex_free((flex_ptr)&an->frame_data);
        flex_free((flex_ptr)&an->restore);
        flex_free((flex_ptr)&an->rgb_data);
        free(anims[handle]);
        return render_error("Can't get space for translation tables");
    }
    an->trtab_size = 4096;
    an->trtab_next = 0;

    an->restore_frame=-1;

    /* Initialise the sprite area */
    spr_area = (sprite_area*) anims[handle]->rgb_data;
    spr_area->size   = sizeof(sprite_area);
    spr_area->sproff = sizeof(sprite_area);
    e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, (int)spr_area);

    if (e)
    {
        flex_free((flex_ptr)&an->rgb_data);
        flex_free((flex_ptr)&an->restore);
        free(anims[handle]);
        return e;
    }

    /* Initialise a few variables */
    an->no_frames     = 0;
    an->trtab         = 0;
    an->rgb_size      = sizeof(sprite_area);
    an->last_frame    = 0;
    an->time          = 0;
    an->screen_width  = screenw;
    an->screen_height = screenh;
    an->fill_fn       = 0;
    an->flags         = flags;
    an->loops         = loops;

    *return_handle=handle;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_initialise                                                                  *
 *                                                                                            *
 * Clear the array of data stuctures, plus create a sprite needed later.                      *
 *--------------------------------------------------------------------------------------------*/

static void render_animate_initialise(void)
{
    int n;

    if (anim_initialised) return;

    render_initialise();

    for (n=0; n<MaxAnims; n++) anims[n]=0;

    anim_initialised=1;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_end                                                                         *
 *                                                                                            *
 * Called at the end of the loading/fetching process to confirm that all data got.            *
 *                                                                                            *
 * In: handle - identifier for this animation.                                                *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_end(int handle)
{
    animated_str *an = anims[handle];

    an->flags.load_ended = 1;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_new_frame                                                                   *
 *                                                                                            *
 * Called by client for each new frame, before the bitstream for the frame is created.        *
 *                                                                                            *
 * In: handle         - identifier for the animation.                                         *
 *     frame_data     - structure containing width, height, position, transparency, delay and *
 *                      disposal details for this frame.                                      *
 *     back           - background colour.                                                    *
 *     return_address - pointer to a pointer which will store the location the client (eg.    *
 *                      GIF) should put the bitstream.                                        *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_new_frame(int handle, frame_str frame_data, int back, char** return_address)
{
    _kernel_oserror *e;
    animated_str    *an = anims[handle];
    sprite_area     *spr_area;
    sprite_header   *spr_hdr;
    frame_str       *fr;
    char            *new_location;
    char             sname[32];
    int              image_size, new_size, sw;
    int              frame = an->no_frames;
    int              w = frame_data.width;
    int              h = frame_data.height;

    debug_value("render animate new frame ",handle);

    render_read_mode_variables();

    /* Allocate memory to store the frame data */
    if (frame>1)
    {
        if (!flex_extend((flex_ptr)&an->frame_data, sizeof(frame_str) * (frame+1)))
            return animate_error_and_abandon(handle, "Can't get any more memory for frame data.");
    }

    /* Increase the allocated memory for the image data */
    /* Sprites are word aligned, so calculate word aligned width */
    sw         = AlignSize(w);
    image_size = sizeof(sprite_header) - 4 + (2 * sw *h);
    new_size   = an->rgb_size + image_size;

    if (!flex_extend((flex_ptr)&an->rgb_data, new_size))
        return animate_error_and_abandon(handle, "Can't get any more memory to store frame image data.");

    /* Update sprite area size */
    spr_area = (sprite_area*) an->rgb_data;
    spr_area->size = new_size;
    spr_area->sproff = sizeof(sprite_area);

    /* Create the sprite for this frame */
    memset(sname, 0, 32);
    sprintf(sname,"frame%d",frame);

    e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, (int)spr_area, sname, 0, w, h, 28);
    if (e) return animate_error_and_abandon(handle, e->errmess);
    e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, (int)spr_area, sname, (1U<<31)+1);
    if (e) return animate_error_and_abandon(handle, e->errmess);
    e=_swix(OS_SpriteOp, _INR(0,2), 256+SprAddMask, (int)spr_area, sname);
    if (e) return animate_error_and_abandon(handle, e->errmess);

    /* Store a few details about this frame */
    an->background = back;

    fr = FindFrame(handle, frame);
    fr->frame_off    = an->rgb_size;
    fr->delay        = frame_data.delay;
    fr->width        = frame_data.width;
    fr->height       = frame_data.height;
    fr->top          = frame_data.top;
    fr->left         = frame_data.left;
    fr->transparency = frame_data.transparency;
    fr->disposal     = frame_data.disposal;
    fr->haspalette   = 0;
    fr->interlace    = frame_data.interlace;
    fr->trtab        = 0;

    if (fr->delay<0) fr->delay = 10;
    if (fr->delay==0) fr->delay = 1;

    /* If first frame, then create last screen sprite */
    if (frame==0)
    {
        e=render_animate_create_last_screen(handle);
        if (e) return animate_error_and_abandon(handle, e->errmess);
    }

    /* Store the new data size */
    an->rgb_size = new_size;
    an->no_frames++;
    an->scanline = 0;

    /* Calculate the address to put the new data */
    spr_area = (sprite_area*) an->rgb_data;
    spr_hdr  = (sprite_header*) ((char*)spr_area + fr->frame_off);

    new_location = (char*)spr_hdr + spr_hdr->image;

    *return_address=new_location;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_create_last_screen                                                          *
 *                                                                                            *
 * Creates the last_screen sprite used for plotting the animation.                            *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_create_last_screen(int handle)
{
    _kernel_oserror *e;
    animated_str    *an=anims[handle];
    sprite_header   *ls_sprheader;
    int              spr_area_size, mask_size, image_size;
    int              w=an->screen_width;
    int              h=an->screen_height;
    int              printing = 0;

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    /* The mode the sprite is defined may vary - for <=8bpp screen modes, use an 8bpp sprite */
    /* for 16bpp, use a 16bpp sprite and for 24bpp, use a 24bpp sprite */

    /* What is ls_img_width (actual size in bytes of a row of image data) and ls_msk_width (mask data) */
    an->ls_img_width = AlignSize(w * bytepp);

    /* Now, what is ls_msk_width (size in bytes of a row of mask data) - for 8bpp, it's a 8bpp mask, otherwise 1bpp */
    if (bpp<=8) an->ls_msk_width = an->ls_img_width;
    else
    {
        mask_size = w/8;
        if (w % 8) mask_size++;
        an->ls_msk_width = AlignSize(mask_size);
    }

    image_size = (an->ls_img_width * h) + (an->ls_msk_width * h);

    /* Calculate size of needed sprite area */
    spr_area_size = sizeof(sprite_area) + sizeof(sprite_header) + image_size;
    if (!flex_alloc((flex_ptr)&an->last_screen, spr_area_size))
        return render_error("Can't get memory for last screen image data.");

    ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));

    /* Create sprite */
    an->last_screen->size   = spr_area_size;
    an->last_screen->sproff = sizeof(sprite_area);

    e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea,  (int)an->last_screen);
    if (e) return e;
    e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, (int)an->last_screen, "sprite", 0, w, h, mode);
    if (e) return e;

    /* Rhubarb */
    //e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, (int)an->last_screen, "sprite", (1U<<31)+1);
    //if (e) return animate_error_and_abandon(handle, e->errmess);
    //render_sprite_put_screen_palette((char*)ls_sprheader->palette);

    e=_swix(OS_SpriteOp, _INR(0,2), 256+SprAddMask, (int)an->last_screen, "sprite");
    if (e) return e;

    /* If less than 8bpp, we need a colour translation table for this image. */
    if (bpp<8 || printing)
    {
        int buffsize;

        debug_print("Making <8bpp table");

        if (an->trtab) flex_free((flex_ptr)&an->trtab);

        /* Find out how much memory is needed for translation table */
        e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4), an->last_screen, an->last_screen+1, -1, -1, 0,
                   osver >= WideTableOSV ? 16+1:1, &buffsize);
        if (e) return e;

        /* Allocate the memory */
        if (!flex_alloc((flex_ptr)&an->trtab, buffsize))
            return render_error("No memory for colourtrans table.");

        /* Generate the table */
        e=_swix(ColourTrans_GenerateTable, _INR(0,5), an->last_screen, an->last_screen+1, -1, -1, an->trtab, osver >= WideTableOSV ? 16+1:1);
        if (e) return e;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_row                                                                         *
 *                                                                                            *
 * Called by the client (eg. gif) for each row of a frame to return the address in memory to  *
 * store the colour data (bitstream).                                                         *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: char* - pointer to memory to put row of data (bitstream)                          *
 *--------------------------------------------------------------------------------------------*/

char* render_animate_row(int handle)
{
    animated_str    *an=anims[handle];
    sprite_header   *spr_hdr;
    frame_str       *fr;
    char            *data;
    int              frame=an->no_frames-1;
    int              row_size, row;

    debug_value("  render animate row ",handle);

    fr = FindFrame(handle, frame);

    row = render_animate_which_row_is_this(handle, an->scanline + 1);

    /* Where is the sprite header for this frame? */
    spr_hdr = (sprite_header*) ((char*)an->rgb_data + fr->frame_off);

    /* What's the actual size of a row (taking into account word alignment) ? */
    row_size = AlignSize(fr->width);

    /* So, calculate the address for the data to be put */
    data = (char*)spr_hdr + (spr_hdr->image + (row_size*row));
    an->scanline++;

    return data;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_return_spr_address                                                          *
 *                                                                                            *
 * Return the address of the start of the row that the client is currently bitstreaming.      *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: char* - pointer to memory to put row of data (bitstream)                          *
 *--------------------------------------------------------------------------------------------*/

char* render_animate_return_spr_address(int handle)
{
    animated_str    *an=anims[handle];
    sprite_header   *spr_hdr;
    frame_str       *fr;
    char            *data;
    int              frame=an->no_frames-1;
    int              row_size, row;

    debug_value("  render animate row ",handle);

    fr = FindFrame(handle, frame);

    row = render_animate_which_row_is_this(handle, an->scanline);

    /* Where is the sprite header for this frame? */
    spr_hdr = (sprite_header*) ((char*)an->rgb_data + fr->frame_off);

    /* What's the actual size of a row (taking into account word alignment) ? */
    row_size = AlignSize(fr->width);

    /* So, calculate the address for the data to be put */
    data = (char*)spr_hdr + (spr_hdr->image + (row_size*row));

    return data;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_done_frame                                                                  *
 *                                                                                            *
 * Called by client at the end of each frame's bitstream (rgb data).                          *
 * It creates the mask for the frame.                                                         *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: error, if one occurred, else NULL                                                 *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_done_frame(int handle)
{
    animated_str    *an=anims[handle];
    sprite_area     *spr_area;
    sprite_header   *spr_hdr;
    frame_str       *fr;
    char            *image;
    char            *mask;
    int              frame = an->no_frames-1;
    int              w, h, sw, tp, x, y;

    fr = FindFrame(handle, frame);

    /* Where is the data I need? */
    spr_area = (sprite_area*)an->rgb_data;
    spr_hdr  = (sprite_header*) ((char*)spr_area + fr->frame_off);
    image    = (char*)spr_hdr + spr_hdr->image;
    mask     = (char*)spr_hdr + spr_hdr->mask;

    tp = fr->transparency;
    w  = fr->width;
    h  = fr->height;
    sw = AlignSize(w);

    /* Do we need to worry about the background showing through? */
    if (frame==0) an->flags.background = fr->transparency==-1 ? 0:1;

    /* Loop through image data and compare each pixel with transparent colour(s) */
    for (y=0; y<h; y++)
    {
        for (x=0; x<w; x++)
        {
            if (image[x]==tp) mask[x]=0;
            else mask[x]=255;
        }

        image+=sw;
        mask+=sw;
    }

    /* Generate a colour translation table for this frame */
    render_animate_generate_table(handle, frame);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_add_local_palette                                                           *
 *                                                                                            *
 * Called by client if this frame has a local palette, it sets aside memory to store the      *
 * palette entries and returns a pointer to the client.                                       *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     frame  - frame number which has the palette.                                           *
 *     depth  - colour depth of palette (ie. bpp)                                             *
 *                                                                                            *
 * Returns: char* - pointer to memory to put the palette data                                 *
 *--------------------------------------------------------------------------------------------*/

char* render_animate_add_local_palette(int handle, int depth)
{
    animated_str  *an = anims[handle];
    sprite_header *spr_hdr;
    frame_str     *fr;
    char          *data;
    int            frame=an->no_frames-1;

    depth=depth;

    fr = FindFrame(handle, frame);

    spr_hdr = (sprite_header*) ((char*)an->rgb_data + fr->frame_off);
    data = (char*)spr_hdr + (sizeof(sprite_header) - 4 - 2048);

    return data;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_plot                                                                        *
 *                                                                                            *
 * Plots the current (or next, as appropriate) frame of animation to screen.                  *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     x      - x co-ordinate to plot at                                                      *
 *     y      - y co-ordinate to plot at                                                      *
 *     scale  - scale %                                                                       *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_plot(int handle, int x, int y, scale_factor scale)
{
    _kernel_oserror *e;
    animated_str    *an = anims[handle];
    frame_str       *fr;
    int              old_frame, frame, time;

    if (!render_animate_valid_handle(handle)) return NULL;

    render_read_mode_variables();

    frame=an->last_frame;
    fr = FindFrame(handle, frame);

    /* Read the centisecond timer */
    _swi(OS_ReadMonotonicTime, _OUT(0), &time);

    /* If we've just started (ie. first time the animation is plotted), then clear the last_screen */
    if ((frame==0) && (an->time==0))
    {
        e=render_animate_clear_last_screen(handle);
        if (e) return animate_error_and_abandon(handle, e->errmess);
        an->time = time;
    }

    /* Otherwise, check if sufficient time has elapsed to increment the frame number */
    else if (time>=(an->time + fr->delay))
    {
        old_frame=frame;
        frame=render_next_frame(handle);
        fr=FindFrame(handle, frame);
        if ( (frame==0) && (old_frame!=0) )
        {
            e=render_animate_clear_last_screen(handle);
            if (e) return animate_error_and_abandon(handle, e->errmess);
            frame=0;
            if (an->loops && --an->loops==0)
                an->flags.looping = 0;
        }
        an->time = time;
    }

    /* Plot the image/frame */
    e=render_animate_plot_image(handle, x, y, scale, frame);
    if (e) return animate_error_and_abandon(handle, e->errmess);

    an->last_frame = frame;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_next_frame                                                                          *
 *                                                                                            *
 * returns the number of the next frame of the animation to plot.                             *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: frame number to be plotted.                                                       *
 *--------------------------------------------------------------------------------------------*/

static int render_next_frame(int handle)
{
    animated_str *an = anims[handle];
    frame_str    *fr;
    int           got_one = 0;
    int           last_frame = an->last_frame;
    int           frame = an->last_frame;
    int           loop = 0;

    while (!got_one)
    {
        frame++;

        if ( (!an->flags.load_ended) && (frame == an->no_frames-1) )
        {
            frame=last_frame;
            got_one=1;
            break;
        }

        else if (frame==an->no_frames)
        {
            if (an->flags.looping)
            {
                frame=0;
                loop++;
            }
            else
                frame=last_frame;
            got_one=1;
            break;
        }

        fr = FindFrame(handle, frame);
        if (fr->delay > 0) got_one=1;
    }

    return frame;
}

/*--------------------------------------------------------------------------------------------*
 * render_animate_need_redraw                                                                 *
 *                                                                                            *
 * Checks if a given animation needs a redraw because a new frame needs plotting.             *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     changed - pointer to bounding box where redraw area will be put.                       *
 *                                                                                            *
 * Returns: 1 if needs redraw, 0 otherwise.                                                   *
 *--------------------------------------------------------------------------------------------*/

int render_animate_need_redraw(int handle, BBox *changed)
{
    animated_str *an = anims[handle];
    frame_str    *fr;
    BBox          lf_bbox, nf_bbox;
    int           time, frame;

    render_read_mode_variables();

    _swi(OS_ReadMonotonicTime, _OUT(0), &time);

    fr = FindFrame(handle, an->last_frame);

    if (time < (fr->delay + anims[handle]->time)) return 0;

    /* What is the bounding box of the area occupied by the current frame? */
    lf_bbox.xmin = fr->left;
    lf_bbox.xmax = lf_bbox.xmin + fr->width;
    lf_bbox.ymax = an->screen_height - fr->top;
    lf_bbox.ymin = lf_bbox.ymax - fr->height;

    frame=render_next_frame(handle);
    fr = FindFrame(handle, frame);

    /* What is the bounding box of the area occupied by the next frame? */
    nf_bbox.xmin = fr->left;
    nf_bbox.xmax = nf_bbox.xmin + fr->width;
    nf_bbox.ymax = an->screen_height - fr->top;
    nf_bbox.ymin = nf_bbox.ymax - fr->height;

    /* Combine the two bounding boxes */
    if (nf_bbox.xmin < lf_bbox.xmin) lf_bbox.xmin = nf_bbox.xmin;
    if (nf_bbox.xmax > lf_bbox.xmax) lf_bbox.xmax = nf_bbox.xmax;
    if (nf_bbox.ymin < lf_bbox.ymin) lf_bbox.ymin = nf_bbox.ymin;
    if (nf_bbox.ymax > lf_bbox.ymax) lf_bbox.ymax = nf_bbox.ymax;

    /* Scale up into OS units */
    changed->xmin = (lf_bbox.xmin - 1) * xos;
    changed->xmax = (lf_bbox.xmax + 1) * xos;
    changed->ymin = (lf_bbox.ymin - 1) * yos;
    changed->ymax = (lf_bbox.ymax + 1) * yos;

    return 1;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_clear_last_screen                                                           *
 *                                                                                            *
 * Resets the 'last_screen' sprite to the first frame of the animation. Done each time the    *
 * animation restarts.                                                                        *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_clear_last_screen(int handle)
{
    _kernel_oserror *e;
    animated_str    *an = anims[handle];
    frame_str       *fr;
    sprite_header   *ls_sprheader, *f0_sprheader;
    char            *ls_img, *ls_msk, *f0_img, *f0_msk;
    int              i, j, k, x, y, x_to, bitmask, startmask, byte, tp, setmask, top;
    int              f0_msk_width, f0_width, f0_height;
    int              ls_msk_width = an->ls_msk_width;
    int              ls_img_width = an->ls_img_width;
    int              ls_width = an->screen_width;
    int              ls_height = an->screen_height;
    int              bgcol;
    int              printing = 0;

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    /* Do colourtrans tables need regenerating (eg. because of mode change) ? */
    if (an->flags.regen_tables) render_animate_make_tables(handle);

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->rgb_data, "<Debug$Dir>.frames");
    #endif

    /* Now we have to define some values...
     * fr                         : Pointer to the structure holding data about frame 0
     * ls_width, ls_height        : width and height of last_screen, in pixels
     * f0_width, f0_height        : widrh and height of frame 0, in pixels.
     * f0_sprheader               : pointer to the sprite header for the frame 0 sprite
     * ls_sprheader               : pointer to the sprite header for the last_screen sprite
     * ls_msk, ls_img             : pointer to the last_screen image data and mask data
     * f0_msk, f0_img             : pointer to the frame 0 image data and mask data
     * f0_img_width, f0_msk_width : width of frame 0 image and mask, in bytes (allowing for word alignment wastage)
     * ls_img_width, ls_msk_width : width of last_screen image and mask, in bytes
     * tp                         : the transparent colour for the current frame */

    fr = FindFrame(handle, 0);
    an = anims[handle];
    tp = fr->transparency;

    ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));
    ls_img       = (char*)ls_sprheader + ls_sprheader->image;
    ls_msk       = (char*)ls_sprheader + ls_sprheader->mask;
    f0_sprheader = (sprite_header*) ((char*)an->rgb_data + fr->frame_off);
    f0_img       = (char*)f0_sprheader + f0_sprheader->image;
    f0_msk       = (char*)f0_sprheader + f0_sprheader->mask;
    f0_width     = fr->width;
    f0_height    = fr->height;
    f0_msk_width = AlignSize(f0_width);


    /* PART 1: Go through last_screen sprite's mask and set it all to be transparent (if background shows through) */
    /*         Plus, clear background.                                                                             */
    if (an->flags.background)   setmask = 0;
    else                        setmask = 255;
    if (an->flags.onepixelhigh) setmask = 0;

    /* What is the colour number of the background? */
    if (bpp>=8) _swix(ColourTrans_ReturnColourNumberForMode, _INR(0,2)|_OUT(0), an->background, -1, -1, &bgcol);
    else        _swix(ColourTrans_ReturnColourNumberForMode, _INR(0,2)|_OUT(0), an->background, 15, 0, &bgcol);

    /* Set mask */
    for (y=0; y<ls_height; y++) memset(ls_msk + (y*ls_msk_width), setmask, ls_msk_width);

    /* Set background */
    if      (bpp<=8)  for (y=0; y<ls_height; y++) memset(ls_img + (y*ls_img_width), bgcol, ls_img_width);
    else if (bpp==32) for (y=0; y<ls_height; y++) rml_misc_memset32bit(ls_img + (y*ls_img_width), bgcol, ls_width);
    else if (bpp==16) for (y=0; y<ls_height; y++) rml_misc_memset16bit(ls_img + (y*ls_img_width), bgcol, ls_width);

    if (fr->disposal==3) an->restore_frame = 0;
    else                 an->restore_frame = -1;

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.ls0");
    #endif

    /* PART 2: Plot frame sprite onto last_screen */
    e=render_save_area();
    if (e) return e;

    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(0,3), 256+SprSwitchVdu,
                                               (int)an->last_screen, "sprite", (int)save_area,
                                               &saveprev0, &saveprev1, &saveprev2, &saveprev3);
    if (e) return e;

    top = fr->top;
    if (an->flags.onepixelhigh) top++;

    e=_swix(OS_SpriteOp, _INR(0,7), 256+SprPutScaled,
                                    (int)an->rgb_data,
                                    "frame0",
                                    fr->left * 2,
                                    (ls_height - top - f0_height) * 2,
                                    osver>=WideTableOSV ? 40:8,
                                    0,
                                    an->fr_trtabs + fr->trtab);
    e=render_vdu_back_to_screen();
    if (e) return e;


    /* PART3: Transfer mask from frame to last_screen */
    x_to = ls_width - fr->left;                                        // Work out how much row to transfer.
    if (f0_width<x_to) x_to=f0_width;

    if (an->flags.onepixelhigh) ls_msk+=an->ls_msk_width;

    /* If last_screen is 8bpp sprite, 8bpp mask also */
    if (bpp<=8)
    {
        ls_msk = ls_msk + (fr->top * ls_msk_width) + fr->left;         // Work out position within mask data to start

        i=0; j=0;
        for (y=0; y<f0_height; y++)
        {
            memcpy(ls_msk + j, f0_msk + i, x_to);
            i = i + f0_msk_width;
            j = j + ls_msk_width;
        }
    }

    /* If last_screen is >8bpp, then 1bpp mask */
    else
    {
        ls_msk = ls_msk + (fr->top * ls_msk_width) + (fr->left/8);     // Work out position within mask data to start
        startmask = 1 << (fr->left % 8);                               // The value of the first bit we'll transfer

        i=0; j=0;
        for (y=0; y<f0_height; y++)
        {
            k=0;
            byte=ls_msk[j+k];
            bitmask=startmask;

            for (x=0; x<x_to; x++)
            {
                if (f0_msk[i+x]==255) byte=byte | bitmask;
                else if (byte & bitmask) byte=byte^bitmask;
                bitmask*=2;
                if (bitmask==256)
                {
                    bitmask=1;
                    ls_msk[j+k]=byte;
                    k++;
                    byte=ls_msk[j+k];
                }
            }

            ls_msk[j+k]=byte;
            i = i + f0_msk_width;
            j = j + ls_msk_width;
        }
    }

    an->last_frame=0;

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.ls1");
    #endif

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_plot_image                                                                  *
 *                                                                                            *
 * Called by render_animate_plot to plot a specified frame to the screen.                     *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     plot_x - x co-ordinate to plot at.                                                     *
 *     plot_y - y co-ordinate to plot at.                                                     *
 *     scale  - % scale.                                                                      *
 *     frame  - frame number to plot.                                                         *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_plot_image(int handle, int plot_x, int plot_y, scale_factor scale, int frame)
{
    _kernel_oserror *e;
    animated_str    *an = anims[handle];
  #if 0
    sprite_area     *bg_sprarea = 0;
    sprite_header   *bg_sprheader = 0;
    int              spr_area_size, image_size;
  #endif
    int              w = an->screen_width;
    int              h = an->screen_height;
    int              bgmode, printing = 0;

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    if (!an->flags.load_ended)
    {
        if (frame >= (an->no_frames-1)) return NULL;
    }

    if (an->flags.regen_tables || printing) render_animate_make_tables(handle);

    /* If current frame is different to the last one plotted, then carry out disposal as per GIF file */
    if (frame!=an->last_frame)
    {
        e=render_animate_do_disposal(handle);
        if (e) return e;
    }

    /* Create the background sprite (if there is a background) */
    if (an->flags.background && !printing)
    {
        #if 0
        image_size = (an->ls_img_width * h) + (an->ls_msk_width * h);

        /* Calculate size of needed sprite area */
        spr_area_size = sizeof(sprite_area) + sizeof(sprite_header) + image_size;

        if (!flex_alloc((flex_ptr)&bg_sprarea, spr_area_size))
            return render_error("Can't get memory for background image.");
        //bg_sprarea = malloc(spr_area_size);
        //if (!bg_sprarea) return render_error("Can't get memory for background image.");

        bg_sprheader = (sprite_header*) ((char*)bg_sprarea + sizeof(sprite_area));

        /* Call OS_SpriteOp to create the sprite */
        bg_sprarea->size   = spr_area_size;
        bg_sprarea->sproff = sizeof(sprite_area);

        e=_swix(OS_Byte, _IN(0)|_OUT(2), 135, &bgmode);
        if (e) return e;
        if (bpp>=8) bgmode=mode;
        e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, (int)bg_sprarea);
        if (e) return e;
        e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, (int)bg_sprarea, "sprite", 0, w, h, bgmode);
        if (e) return e;
        #else
        e=_swix(OS_Byte, _IN(0)|_OUT(2), 135, &bgmode);
        if (e) return e;
        if (bpp>=8) bgmode=mode;
        if (printing)
        {
            if (osver >= 0xA5)
                bgmode = (6<<27) + (90<<14) + (90<<1) + 1;
            else
                bgmode = 28;
        }
        e = MakeBufferSprite((void *) bgmode, w, h, NULL);
        if (e) return e;
        #endif

        /* Rhubarb */
        //e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, (int)bg_sprarea, "sprite", (1U<<31)+1);
        //if (e) return animate_error_and_abandon(handle, e->errmess);
        //render_sprite_put_screen_palette((char*)bg_sprheader->palette);

        /* Fill in the background */
        if (an->fill_fn)
        {
            e = SwitchToBufferSprite();
            if (e) return e;
            an->fill_fn(an->handle1, an->handle2);
            SwitchFromBufferSprite();
            render_read_mode_variables();
        }

        #if SaveFrames
        if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)bg_sprarea, "<Debug$Dir>.bg1");
        #endif
    }


    /* Plot current frame onto last_screen sprite */
    if (frame!=an->last_frame && !printing)
    {
        e=render_animate_frame_to_last_screen(handle,frame);
        if (e) return e;
    }

    /* If there is a background showing through, then plot last_screen onto the background before */
    /* plotting to the screen, else just plot last_screen direct. */
    if (an->flags.background && !printing)
    {
        e = SwitchToBufferSprite();
        if (e) return e;

        /* Not sure if we can make the bpp<8 the case for ALL bpp */
        if (bpp<=8 || printing)
        {
            _swi(ColourTrans_GenerateTable, _INR(0,5), an->last_screen, an->last_screen+1, -1, -1, an->trtab, 1);
            e=_swix(OS_SpriteOp, _INR(0,7), 512+SprPutScaled, an->last_screen, an->last_screen+1, 0, 0, 8, 0, an->trtab);
        }
        else
        {
            e=_swix(OS_SpriteOp, _INR(0,7), 512+SprPutScaled, an->last_screen, an->last_screen+1, 0, 0, 8, 0, 0);
        }
        e=SwitchFromBufferSprite();
        if (e) return e;

        /* Not sure if we can make the bpp<8 the case for ALL bpp */
        if (bpp<=8 || printing)
        {
            BufferSprite_GenerateTable(an->trtab);
            e = BufferSprite_PlotScaled(plot_x, plot_y, osver>=WideTableOSV ? 32:0, (int *) &scale, an->trtab);
        }
        else
        {
            e= BufferSprite_PlotScaled(plot_x, plot_y, osver>=WideTableOSV ? 32:0, (int *) &scale, 0);
        }
        if (e) return e;

        #if SaveFrames
        if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)bg_sprarea, "<Debug$Dir>.bg2");
        #endif

        /* Free the memory allocated to the background sprite */
        FreeBufferSprite();
        //free(bg_sprarea);
    }
    else if (printing)
    {
        frame_str *fr = FindFrame(handle, 0);

        /* Just plot the first frame */
        e = _swix(OS_SpriteOp, _INR(0,7), 256+SprPutScaled,
                                    an->rgb_data,
                                    "frame0",
                                    plot_x + fr->left * 2 * scale.x_mul / scale.x_div,
                                    plot_y + (an->screen_height - fr->top - fr->height) * 2 * scale.y_mul / scale.y_div,
                                    osver>=WideTableOSV ? 32+16+8:16+8,
                                    &scale,
                                    an->fr_trtabs + fr->trtab);
    }
    else
    {
        e=_swix(OS_SpriteOp, _INR(0,7),
                             512+SprPutScaled,
                             an->last_screen,
                             an->last_screen+1,
                             plot_x,
                             plot_y,
                             (osver>=WideTableOSV ? 32:0) +
                             printing ? 8 : 0,
                             &scale,
                             an->trtab);
        if (e) return e;
    }

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_frame_to_last_screen                                                        *
 *                                                                                            *
 * Plots the specified frame of animation ont the last_screen sprite and transfers masking    *
 * information as appropriate.                                                                *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     frame  - the frame to plot onto the last_screen sprite                                 *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_frame_to_last_screen(int handle, int frame)
{
    _kernel_oserror  *e;
    animated_str     *an = anims[handle];
    sprite_header    *ls_sprheader;
    sprite_header    *cf_sprheader;
    frame_str        *fr;
    char             *ls_img;
    char             *ls_msk;
    char             *cf_img;
    char             *cf_msk;
    char             *rs_msk;
    char             *rs_img;
    char              sname[32];
    int               tp, x, y, i, j, k, x_to;
    int               cf_width, cf_height, rs_img_width, rs_msk_width, cf_img_width;
    int               msk_size, img_size, startmask, bitmask, byte, copy_width, top;
    int               ls_width = an->screen_width;
    int               ls_height = an->screen_height;
    int               ls_msk_width = an->ls_msk_width;
    int               ls_img_width = an->ls_img_width;

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.ls14");
    #endif

    /* Now we have to define some values...
     * fr                         : Pointer to the structure holding data about the current frame
     * cf_width, cf_height        : width and height of current_frame, in pixels
     * ls_width, ls_height        : width and height of last_screen, in pixels
     * cf_sprheader               : pointer to the sprite header for the current_frame sprite
     * ls_sprheader               : pointer to the sprite header for the last_screen sprite
     * ls_msk, ls_img             : pointer to the last_screen image data and mask data
     * cf_msk, cf_img             : pointer to the current_frame image data and mask data
     * cf_img_width, cf_msk_width : width of current_frame image and mask, in bytes (allowing for word alignment wastage)
     * ls_img_width, ls_msk_width : width of last_screen image and mask, in bytes
     * rs_img_width, rs_msk_width : width of restore buffer image and mask, in bytes
     * tp                         : the transparent colour for the current frame */

    fr = FindFrame(handle, frame);

    cf_width     = fr->width;
    cf_height    = fr->height;
    tp           = fr->transparency;
    cf_sprheader = (sprite_header*) ((char*)an->rgb_data + fr->frame_off);
    cf_img       = (char*)cf_sprheader + cf_sprheader->image;
    cf_msk       = (char*)cf_sprheader + cf_sprheader->mask;
    cf_img_width = AlignSize(cf_width);

    /* Adjust cf_height for overflow */
    if ((cf_height + fr->top) > ls_height) cf_height = ls_height - fr->top;

    ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));
    ls_img  = (char*)ls_sprheader + ls_sprheader->image;
    ls_msk  = (char*)ls_sprheader + ls_sprheader->mask;

    /* Now offset image and mask according to the top and left positioning specified for this frame */
    ls_img += (fr->top * ls_img_width) + (fr->left * bytepp);
    if (bpp<=8) ls_msk = ls_msk + (fr->top * ls_msk_width) + fr->left;
    else        ls_msk = ls_msk + (fr->top * ls_msk_width) + (fr->left/8);

    /* If the disposal method for this frame is to restore the previous state, copy the data to 'restore' */
    if ((an->restore_frame==-1) && (fr->disposal==3))
    {
        /* Check current frame doesn't overhang right side of last_screen */
        if ((fr->left + cf_width) > ls_width) copy_width = ls_width - fr->left;
        else copy_width = cf_width;

        rs_img_width = copy_width * bytepp;

        if (bpp>8)
        {
            rs_msk_width = (rs_img_width/8);
            if (rs_img_width % 8) rs_msk_width++;
        }
        else
        {
            rs_msk_width = rs_img_width;
        }

        rs_img_width = AlignSize(rs_img_width);
        rs_msk_width = AlignSize(rs_msk_width);

        img_size = rs_img_width * fr->height;
        msk_size = rs_msk_width * fr->height;

        /* Allocate memory for the restore buffer */
        if (!flex_extend((flex_ptr)&an->restore, img_size + msk_size))
            return render_error("Can't get memory for restore area.");

        fr = FindFrame(handle, frame);

        /* Recalculate location of mask and image data (it may have moved) */
        ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));
        ls_img  = (char*)ls_sprheader + ls_sprheader->image;
        ls_msk  = (char*)ls_sprheader + ls_sprheader->mask;
        ls_img += (fr->top * ls_img_width) + (fr->left * bytepp);
        if (bpp<=8) ls_msk = ls_msk + (fr->top * ls_msk_width) + fr->left;
        else        ls_msk = ls_msk + (fr->top * ls_msk_width) + (fr->left/8);

        rs_img = (char*)an->restore;
        rs_msk = (char*)an->restore + img_size;
        an->restore_frame=frame;

        /* Copy the data */
        i=0; j=0;
        for (y=0; y<cf_height; y++)
        {
            memcpy(rs_img+i, ls_img + (y*ls_img_width), rs_img_width);
            memcpy(rs_msk+j, ls_msk + (y*ls_msk_width), rs_msk_width);
            i+=rs_img_width;
            j+=rs_msk_width;
        }
    }

    /*--- Plot the frame over the last_screen image --------------------------------------------------------------------*/

    e=render_save_area();
    if (e) return e;

    sprintf(sname,"frame%d",frame);
    e=_swix(OS_SpriteOp, _INR(0,3)|_OUTR(0,3), 256+SprSwitchVdu, (int)an->last_screen, "sprite", (int)save_area,
                                               &saveprev0, &saveprev1, &saveprev2, &saveprev3);
    if (e) return e;

    top = fr->top;
    if (an->flags.onepixelhigh) top++;

    e=_swix(OS_SpriteOp, _INR(0,7), 256+SprPutScaled,
                                    (int)an->rgb_data,
                                    sname,
                                    fr->left * 2,
                                    (an->screen_height - top - fr->height) * 2,
                                    osver>=WideTableOSV ? 40:8,
                                    0,
                                    an->fr_trtabs + fr->trtab);

    e=render_vdu_back_to_screen();
    if (e) return e;

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.ls15");
    #endif

    /*--- Transfer the mask from the frame to last_screen --------------------------------------------------------------*/

    /* How much of a row do we transfer? */
    x_to = an->screen_width - fr->left;
    if (cf_width < x_to) x_to=cf_width;

    /* Recalculate location of mask and image data (it may have moved) */
    ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));
    ls_img  = (char*)ls_sprheader + ls_sprheader->image;
    ls_msk  = (char*)ls_sprheader + ls_sprheader->mask;
    ls_img += (fr->top * ls_img_width) + (fr->left * bytepp);

    if (bpp<=8) ls_msk = ls_msk + (fr->top * ls_msk_width) + fr->left;              // Offset mask data according to top and left positioning
    else        ls_msk = ls_msk + (fr->top * ls_msk_width) + (fr->left/8);

    if (an->flags.onepixelhigh)
    {
        ls_img+=an->ls_img_width;
        ls_msk+=an->ls_msk_width;
    }

    /* If 8bpp last_screen, then 8bpp mask */
    if (bpp<=8)
    {
        i=0; j=0;

        for (y=0; y<cf_height; y++)
        {
            for (x=0; x<x_to; x++) if (cf_msk[i+x]==255) ls_msk[j+x] = 255;
            i+=cf_img_width;
            j+=ls_img_width;
        }
    }

    /* If last_screen is >8bpp, then 1bpp mask */
    else
    {
        startmask = 1 << (fr->left % 8);
        i=0; j=0;

        for (y=0; y<cf_height; y++)
        {
            k=0;
            byte=ls_msk[j+k];
            bitmask=startmask;

            for (x=0; x<x_to; x++)
            {
                if (cf_msk[i+x]==255) byte=byte | bitmask;
                bitmask*=2;

                if (bitmask==256)
                {
                    bitmask=1;
                    ls_msk[j+k]=byte;
                    k++;
                    byte=ls_msk[j+k];
                }
            }

            ls_msk[j+k]=byte;
            i += cf_img_width;
            j += ls_msk_width;
        }
    }

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.ls2");
    #endif

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_do_disposal                                                                 *
 *                                                                                            *
 * Called after a frame is finished with to carry out it's disposal, as specified in the GIF  *
 * specification :                                                                            *
 *   If disposal type is 0 or 1, frame is to be kept in place. So, in this code, that means   *
 *                           do nothing - we've already copied the frame data to last_store.  *
 *   If disposal type is 2, then blank to background colour                                   *
 *   If disposal type is 3, then restore last_screen                                          *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_do_disposal(int handle)
{
    animated_str     *an = anims[handle];
    frame_str        *fr;
    sprite_header    *ls_sprheader;
    char             *ls_img;
    char             *ls_msk;
    char             *rs_msk;
    char             *rs_img;
    int               a, y, i, j, f, tp, disposal, img_size, msk_size, copy_width;
    int               cf_width, cf_height, rs_img_width, rs_msk_width;
    int               restore_frame=an->restore_frame;
    int               ls_width  = an->screen_width;
    int               ls_height = an->screen_height;
    int               ls_img_width = an->ls_img_width;
    int               ls_msk_width = an->ls_msk_width;
    uint32            c, m;

    f = an->last_frame;

    fr = FindFrame(handle, f);

    disposal = fr->disposal;

    /* If disposal type is 0 or 1, then do nothing - we've already copied the frame data to last_store */
    if (disposal<=1) return NULL;

    /* What is width, height & transparency code for the current frame? */
    cf_width     = fr->width;
    cf_height    = fr->height;
    tp           = fr->transparency;

    /* Ensure there's no overflow */
    if ((fr->left + cf_width) > ls_width) cf_width = ls_width - fr->left;
    if ((fr->top + cf_height) > ls_height) cf_height = ls_height - fr->top;

    /* Work out where on the last screen image (and mask) to start plotting this */
    ls_sprheader = (sprite_header*) ((char*)an->last_screen + sizeof(sprite_area));
    ls_img       = (char*)ls_sprheader + ls_sprheader->image;
    ls_msk       = (char*)ls_sprheader + ls_sprheader->mask;
    ls_img      += (fr->top * ls_img_width) + (fr->left * bytepp);

    if (bpp<=8) ls_msk = ls_msk + (fr->top * ls_msk_width) + fr->left;
    else        ls_msk = ls_msk + (fr->top * ls_msk_width) + (fr->left/8);

    i=0; j=0;

    /* Disposal type 2 - set to background colour */
    if (disposal==2)
    {
        if (bpp>=8) _swix(ColourTrans_ReturnColourNumberForMode, _INR(0,2)|_OUT(0), an->background, -1, -1, &c);
        else        _swix(ColourTrans_ReturnColourNumberForMode, _INR(0,2)|_OUT(0), an->background, 15, 0, &c);

        m = an->flags.background;

        if (bpp<=8)
        {
            for (y=0; y<cf_height; y++)
            {
                if (m)
                    memset(ls_msk + i, 0, cf_width);
                else
                    memset(ls_img + i, c, cf_width);
                i+=ls_img_width;
            }
        }
        else if (bpp==16)
        {
            a = fr->left % 8;

            for (y=0; y<cf_height; y++)
            {
                if (m)
                    rml_misc_memset1bit(ls_msk + j, 0, cf_width, a);
                else
                    rml_misc_memset16bit(ls_img + i, c, cf_width);
                i+=ls_img_width;
                j+=ls_msk_width;
            }
        }
        else if (bpp==32)
        {
            a = fr->left % 8;

            for (y=0; y<cf_height; y++)
            {
                if (m)
                    rml_misc_memset1bit(ls_msk + j, 0, cf_width, a);
                else
                    rml_misc_memset32bit(ls_img + i, c, cf_width);
                i+=ls_img_width;
                j+=ls_msk_width;
            }
        }
    }

    /* Disposal type 3 - Restore previous screen */
    else if ((disposal==3) && (restore_frame!=-1))
    {
        /* Check in case the current_frame image overhangs the right side of last_screen - if so, shorten it */
        if ((fr->left + cf_width) > ls_width) copy_width = ls_width - fr->left;
        else copy_width = cf_width;

        /* How many bytes of data need to be stored for each row */
        rs_img_width = copy_width * bytepp;

        if (bpp>8)
        {
            rs_msk_width = (rs_img_width/8);
            if (rs_img_width % 8) rs_msk_width++;
        }
        else rs_msk_width = rs_img_width;

        /* Consider word alignment */
        rs_img_width = AlignSize(rs_img_width);
        rs_msk_width = AlignSize(rs_msk_width);

        /* How much room do we need for the restore image and mask? */
        img_size = rs_img_width * fr->height;
        msk_size = rs_msk_width * fr->height;

        rs_img = (char*)an->restore;
        rs_msk = (char*)an->restore + img_size;

        /* Copy the data... */
        i=0; j=0;
        /* If the frame we're restoring is zero, then put the background in */
        if (f==0)
        {
            int setmask;
            int bgcol;

            _swix(ColourTrans_ReturnColourNumberForMode, _INR(0,2)|_OUT(0), an->background, 15, 0, &bgcol);

            if (an->flags.background) setmask=0;
            else setmask=255;

            for (y=0; y<cf_height; y++)
            {
                memset(ls_img + (y*ls_img_width), bgcol, rs_img_width);
                memset(ls_msk + (y*ls_msk_width), setmask, rs_msk_width);
                i+=rs_img_width;
                j+=rs_msk_width;
            }
         }

         /* Otherwise, copy from the restore buffer */
         else
         {
             for (y=0; y<cf_height; y++)
             {
                 memcpy(ls_img + (y*ls_img_width), rs_img+i, rs_img_width);
                 memcpy(ls_msk + (y*ls_msk_width), rs_msk+j, rs_msk_width);
                 i+=rs_img_width;
                 j+=rs_msk_width;
             }
         }

         flex_extend((flex_ptr)&an->restore, 4);
         an->restore_frame=-1;
    }

    #if SaveFrames
    if (handle==SaveFrameHdl) _swi(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)an->last_screen, "<Debug$Dir>.di1");
    #endif

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_make_tables                                                                 *
 *                                                                                            *
 * Makes colour translation tables for all the frames in an animation.                        *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_make_tables(int handle)
{
    _kernel_oserror *e;
    animated_str    *an=anims[handle];
    frame_str       *fr=NULL;
    char            *location;
    int              newmode=mode;
    int              n, buffsize;
    int              trtab_size, trtab_next;
    int              printing = 0;
    char             sname[32];
    sprite_header   *sptr;

    trtab_size = 4096;
    trtab_next = 0;

    if (!flex_extend((flex_ptr)&an->fr_trtabs, trtab_size))
        return render_error("No memory for colourtrans table.");

    _swix(PDriver_CurrentJob, _OUT(0), &printing);

    /* Go through frames and generate the colourtrans tables */
    for (n=0; n<an->no_frames; n++)
    {
        fr = FindFrame(handle, n);

        /* Find out how much memory is needed for translation table */
        sprintf(sname,"frame%d",n);

        e = _swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+SprSelect, an->rgb_data, sname, &sptr);
        if (e) return e;

        if (bpp<8 && !printing)
            e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                               an->rgb_data,
                                               sptr,
                                               newmode,
                                               0,
                                               0,
                                               osver>=WideTableOSV ? 16+1:1,
                                               &buffsize);


        else e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                                an->rgb_data,
                                                sptr,
                                                -1,
                                                -1,
                                                0,
                                                osver>=WideTableOSV ? 16+1:1,
                                                &buffsize);

        if (e) return e;

        /* Is there enough space already in the colourtrans table area? */
        if ((trtab_next + buffsize) > trtab_size)
        {
            /* Allocate an extra 4k */
            if (!flex_extend((flex_ptr)&an->fr_trtabs, trtab_size + 4096))
                return render_error("No memory for colourtrans table.");
            trtab_size += 4096;
            fr = FindFrame(handle, n);
        }

        location = an->fr_trtabs + trtab_next;

        /* Generate the table */
        if (bpp<8 && !printing)
            e=_swix(ColourTrans_GenerateTable, _INR(0,5),
                                               an->rgb_data,
                                               sptr,
                                               28,
                                               0,
                                               location,
                                               osver>=WideTableOSV ? 16+1:1);

        else e=_swix(ColourTrans_GenerateTable, _INR(0,5),
                                                an->rgb_data,
                                                sptr,
                                                -1,
                                                -1,
                                                location,
                                                osver>=WideTableOSV ? 16+1:1);

        if (e) return e;

        fr->trtab = trtab_next;
        trtab_next += buffsize;
    }

    anims[handle]->flags.regen_tables = 0;
    anims[handle]->trtab_next = trtab_next;
    anims[handle]->trtab_size = trtab_size;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_generate_table                                                              *
 *                                                                                            *
 * Makes colour translation table for a frame of an animation.                                *
 *                                                                                            *
 * In: handle - identifier for the animation.                                                 *
 *     frame  - frame number to generate the table for.                                       *
 *                                                                                            *
 * Returns: error if one occurred, else NULL.                                                 *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_animate_generate_table(int handle, int frame)
{
    _kernel_oserror *e;
    animated_str    *an=anims[handle];
    frame_str       *fr;
    char            *location;
    char             sname[32];
    int              newmode=mode;
    int              buffsize;
    sprite_header   *sptr;

    fr = FindFrame(handle, frame);

    /* Find out how much memory is needed for translation table */
    sprintf(sname,"frame%d",frame);

    e = _swix(OS_SpriteOp, _INR(0,2)|_OUT(2), 256+SprSelect, an->rgb_data, sname, &sptr);
    if (e) return e;

    if (bpp<=8) e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                                  an->rgb_data,
                                                  sptr,
                                                  newmode,
                                                  0,
                                                  0,
                                                  osver>=WideTableOSV ? 16+1:1,
                                                  &buffsize);

    else e=_swix(ColourTrans_GenerateTable, _INR(0,5)|_OUT(4),
                                            an->rgb_data,
                                            sptr,
                                            -1,
                                            -1,
                                            0,
                                            osver>=WideTableOSV ? 16+1:1,
                                            &buffsize);

    if (e) return e;

    /* Is there enough space already in the colourtrans table area? */
    if ((an->trtab_next + buffsize) > an->trtab_size)
    {
        /* Allocate an extra 4k */
        if (!flex_extend((flex_ptr)&an->fr_trtabs, an->trtab_size + 4096))
            return render_error("No memory for colourtrans table.");
        an->trtab_size += 4096;
        fr = FindFrame(handle, frame);

    }

    location = an->fr_trtabs + an->trtab_next;

    /* Generate the table */
    if (bpp<=8) e=_swix(ColourTrans_GenerateTable, _INR(0,5),
                                                  an->rgb_data,
                                                  sptr,
                                                  newmode,
                                                  0,
                                                  location,
                                                  osver>=WideTableOSV ? 16+1:1);

    else e=_swix(ColourTrans_GenerateTable, _INR(0,5),
                                            an->rgb_data,
                                            sname,
                                            -1,
                                            -1,
                                            location,
                                            osver>=WideTableOSV ? 16+1:1);
    if (e) return e;

    fr->trtab = an->trtab_next;
    an->trtab_next += buffsize;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_which_row_is_this                                                           *
 *                                                                                            *
 * For interlaced images, given the order this row arrived (eg. 6th to arrive), return the    *
 * actual row in the image.                                                                   *
 *                                                                                            *
 * In: handle - identifier for this image.                                                    *
 *     n      - nth row to arrive.                                                            *
 *                                                                                            *
 * Returns: int - actual row in image.                                                        *
 *--------------------------------------------------------------------------------------------*/

static int render_animate_which_row_is_this(int handle, int n)
{
    animated_str    *an=anims[handle];
    frame_str       *fr;
    int              frame=an->no_frames-1;
    unsigned int     /*a, */b, c, d, na, nb, nc, nd, offset, h;

    fr = FindFrame(handle, frame);

    if (fr->trtab) return NULL;

    if (!fr->interlace) return n;

    h=fr->height;

    /* The interlaced GIF is stored as...
         a) every eigth row  +0 (ie. beginning at scanline 0)
         b) every eigth row  +4 (ie. beginning at scanline 4)
         c) every fourth row +2 (ie. beginning at scanline 2)
         d) every second row +1 (ie. beginning at scanline 1)
      a,b,c,d are the offsets (in terms of number of lines) to the appropriate data
      as symboled above, so 'd' contains the number of rows that have to be trawled
      through before we get to the data for every second row. */
    na = (h - 0)/8;
    nb = (h - 4)/8;
    nc = (h - 2)/4;
    nd = (h - 1)/2;

    if ( ((na*8)+0) >= h) na--;
    if ( ((nb*8)+4) >= h) nb--;
    if ( ((nc*4)+2) >= h) nc--;
    if ( ((nd*2)+1) >= h) nd--;

    na++; nb++; nc++; nd++;
    /*a=0;*/ b=/*a+*/na; c=b+nb; d=c+nc;

         if (n<b) offset = ( (n/*-a*/) * 8 ) + 0;
    else if (n<c) offset = ( (n-b) * 8 ) + 4;
    else if (n<d) offset = ( (n-c) * 4 ) + 2;
    else          offset = ( (n-d) * 2 ) + 1;

    if (offset>=h) offset=h-1;

    return offset;
}


/*--------------------------------------------------------------------------------------------*
 * render_make_animation                                                                      *
 *                                                                                            *
 * The client has detected more than one image within it's source file, so calls this routine *
 * to turn the image it's already pulled in and processed, into the first frame of an         *
 * animation.                                                                                 *
 *                                                                                            *
 * In: render_handle - identifier for the image already processed.                            *
 *     frame_data    - frame data for the image.                                              *
 *     back          - screen background colour.                                              *
 *     screen_x      - screen width.                                                          *
 *     screen_y      - screen height.                                                         *
 *     return_handle - pointer to location to put handle for newly created animation.         *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_make_animation(int render_handle, frame_str frame_data, int back,
                                       int screen_x, int screen_y, unsigned int loops,
                                       int* return_handle)
{
    _kernel_oserror *e;
    animated_str    *an;
    internal_header *im=images[render_handle];
    sprite_area     *src_area;
    sprite_header   *src_header;
    sprite_area     *dest_area;
    sprite_header   *dest_header;
    char            *dest_img;
    char            *dest_msk;
    char            *data;
    int              an_handle, img_width, y, i;
    #ifdef TRACE
    int              bytes;
    #endif

    e=render_animate_start(screen_x, screen_y, loops, &an_handle);
    if (e) return animate_error_and_abandon(render_handle, e->errmess);

    e=render_animate_new_frame(an_handle, frame_data, back, &data);
    if (e) return animate_error_and_abandon(render_handle, e->errmess);

    e=LZW_decompress_start((uint8*) im->lzw_data);
    if (e) return animate_error_and_abandon(render_handle, e->errmess);

    /* Copy a few variables from the still structure to the animated structure */
    *return_handle = an_handle;
    an = anims[an_handle];

    if (an->flags.onepixelhigh) im->flags.onepixelhigh=1;
    an->flags = im->flags;

    /* Now decompress the compressed picture into the first frame of the animation */
    dest_area   = (sprite_area*)an->rgb_data;
    dest_header = (sprite_header*) ((char*)dest_area + sizeof(sprite_area));
    dest_img    = (char*)dest_header + dest_header->image;
    dest_msk    = (char*)dest_header + dest_header->mask;

    src_area    = (sprite_area*)im->spr_data;
    src_header  = (sprite_header*) ((char*)src_area + sizeof(sprite_area));

    img_width = AlignSize(im->width);

    i=0;
    for (y=0; y<im->height; y++)
    {
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)dest_img + i, im->width, (uint8*) im->lzw_data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)dest_img + i, im->width, (uint8*) im->lzw_data);
        #endif
        if (e) return animate_error_and_abandon(render_handle, e->errmess);
        i += img_width;
    }

    LZW_decompress_end();

    /* Copy the palette */
    for (i=0; i<512; i++) dest_header->palette[i] = src_header->palette[i];

    render_animate_done_frame(an_handle);

    render_delete(render_handle);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_changed                                                                     *
 *                                                                                            *
 * Return a bounding box for the area which has changed since last load (assumed to be whole  *
 * image for the moment).                                                                     *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *     changed - pointer to bounding box to put the changed image.                            *
 *--------------------------------------------------------------------------------------------*/

void render_animate_changed(int handle, BBox *changed)
{
    animated_str *an=anims[handle];

    render_read_mode_variables();

    changed->xmin = 0 * xos;
    changed->xmax = an->screen_width * xos;

    changed->ymin = 0 * yos;
    changed->ymax = an->screen_height * yos;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_delete                                                                      *
 *                                                                                            *
 * Called by a client when an animation is finished with. Frees up memory and removes data    *
 * structures.                                                                                *
 *                                                                                            *
 * In: handle - identifier for animation.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_delete(int handle)
{
    animated_str *an=anims[handle];

    debug_value("  render_animate_delete ",handle);

    /* Check it's a valid handle */
    if (!render_animate_valid_handle(handle)) return NULL;

    if (an->trtab)       flex_free((flex_ptr)&an->trtab);
    if (an->last_screen) flex_free((flex_ptr)&an->last_screen);
    if (an->fr_trtabs)   flex_free((flex_ptr)&an->fr_trtabs);
    if (an->frame_data)  flex_free((flex_ptr)&an->frame_data);
    if (an->restore)     flex_free((flex_ptr)&an->restore);
    if (an->rgb_data)    flex_free((flex_ptr)&an->rgb_data);

    if (anims[handle]) free(anims[handle]);
    anims[handle]=0;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_mode_change                                                                 *
 *                                                                                            *
 * Called by client, for each animation, upon a mode change. Regenerates sprites in the new   *
 * mode.                                                                                      *
 *                                                                                            *
 * In: handle - identifier for animation.                                                     *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_animate_mode_change(int handle)
{
    _kernel_oserror *e;
    int              oldstate, oldcompact;

    debug_print("animate_mode_change");

    render_read_mode_variables();

    /* Delete the last_screen sprite */
    if (anims[handle]->last_screen)
    {
        memset(anims[handle]->last_screen, 0, sizeof(sprite_area)+sizeof(sprite_header));
        flex_free((flex_ptr)&anims[handle]->last_screen);
    }

    /* Free colour translation table */
    if (anims[handle]->trtab) flex_free((flex_ptr)&anims[handle]->trtab);

    anims[handle]->last_frame = 0;
    anims[handle]->time       = 0;

    /* Set a flag to say colour translation tables need regenerating, then create the last_screen sprite */
    anims[handle]->flags.regen_tables = 1;

    oldstate=flex_set_budge(0);
    oldcompact=flex_set_deferred_compaction(0);
    e=render_animate_create_last_screen(handle);
    flex_set_budge(oldstate);
    flex_set_deferred_compaction(oldcompact);

    if (e) return animate_error_and_abandon(handle, e->errmess);

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_register_filler                                                                     *
 *                                                                                            *
 * Called by the client to provide a function which will be called each time the background   *
 * of an animation is being plotted (to fill the background in)                               *
 *                                                                                            *
 * In: handle           - identifier for animation.                                           *
 *     fill_fn          - the function to be called.                                          *
 *     handle1, handle2 - two pieces of data passed to the filler function.                   *
 *                                                                                            *
 * Returns: Error, if one occurred, else NULL.                                                *
 *--------------------------------------------------------------------------------------------*/

_kernel_oserror* render_register_filler(int handle, FillerFunction *fill_fn, void* handle1, int* handle2)
{
    if (!render_animate_valid_handle(handle)) return NULL;

    anims[handle]->fill_fn = fill_fn;
    anims[handle]->handle1 = handle1;
    anims[handle]->handle2 = handle2;

    return NULL;
}


_kernel_oserror* render_mark_corrupt_frame(int handle)
{
    animated_str *an = anims[handle];
    frame_str    *fr;
    int           frame = an->no_frames-1;

    report_value("Corrupt frame ",frame);

    fr = FindFrame(handle, frame);
    fr->delay = 0;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_save_area                                                                           *
 *                                                                                            *
 * Creates a save area for storing vdu state when redirecting output to a sprite.             *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_save_area(void)
{
    /* Get save area for switching output to sprite */
    if (!save_area) flex_alloc((flex_ptr)&save_area, 800);
    //if (!save_area) save_area=malloc(800);
    if (!save_area) return render_error("Can't allocate memory for save_area\n");
    *(int *)save_area = 0;

    return NULL;
}


/*--------------------------------------------------------------------------------------------*
 * render_vdu_back_to_screen                                                                  *
 *                                                                                            *
 * Restores vdu output back to the screen (after it had been directed to a sprite).           *
 *                                                                                            *
 * Returns: error, if one occurred, else null.                                                *
 *--------------------------------------------------------------------------------------------*/

static _kernel_oserror* render_vdu_back_to_screen(void)
{
    _kernel_oserror *e=NULL;
    int temp = saveprev0;

    saveprev0 = 0;

    if (temp)
        e=_swix(OS_SpriteOp, _INR(0,3), temp, saveprev1, saveprev2, saveprev3);

    return e;
}


/*--------------------------------------------------------------------------------------------*
 * render_valid_handle                                                                        *
 *                                                                                            *
 * Check if a handle is currently valid                                                       *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: 1 if valid, 0 if not valid.                                                       *
 *--------------------------------------------------------------------------------------------*/

static int render_valid_handle(unsigned int handle)
{
    if (handle>MaxImages)
    {
        debug_print("*** INVALID RENDER HANDLE ***");
        return 0;
    }

    if (!images[handle])
    {
        debug_print("*** INVALID RENDER HANDLE ***");
        return 0;
    }

    return 1;
}


/*--------------------------------------------------------------------------------------------*
 * render_animate_valid_handle                                                                *
 *                                                                                            *
 * Check if a handle is currently valid                                                       *
 *                                                                                            *
 * In: handle - identifier for the image.                                                     *
 *                                                                                            *
 * Returns: 1 if valid, 0 if not valid.                                                       *
 *--------------------------------------------------------------------------------------------*/

static int render_animate_valid_handle(int handle)
{
    if (handle<0)
    {
        debug_print("*** INVALID RENDER HANDLE ***");
        return 0;
    }

    if (handle>MaxAnims)
    {
        debug_print("*** INVALID RENDER HANDLE ***");
        return 0;
    }

    if (!anims[handle])
    {
        debug_print("*** INVALID RENDER HANDLE ***");
        return 0;
    }

    return 1;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                                 IMAGE EXPORT ROUTINES                                           */
/*-----------------------------------------------------------------------------------------------------------------*/

#define FreeMemoryAndReturn {flex_free((flex_ptr)&spr);flex_set_budge(oldstate);return e;}

_kernel_oserror* render_export_sprite(int handle, char*filename)
{
    _kernel_oserror *e = NULL;
    internal_header *im = images[handle];
    sprite_area     *spr;
    sprite_header   *spr_head;
    sprite_header   *src_head;
    char            *src_pal;
    char            *spr_pal;
    char            *spr_img;
    char            *spr_msk;
    int              w = im->width;
    int              h = im->height;
    int              tp = im->transparency;
    int              oldstate, sw, size, x, y;
    #ifdef TRACE
    int              bytes;
    #endif

    /* Check it's a valid handle */
    if (!render_valid_handle(handle)) return NULL;

    oldstate=flex_set_budge(0);

    /* If image_fast set, we can save the image already */
    if (im->flags.image_fast)
    {
        _swix(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)im->spr_data, filename);
        return NULL;
    }

    /* Get memory to store a sprite of this image */
    sw = AlignSize(w);
    size = sizeof(sprite_area) + sizeof(sprite_header) + (sw*h) + (sw*h);
    if (!flex_alloc((flex_ptr)&spr, size))
        return render_error("Can't allocate memory to save sprite.");

    /* Initialise sprite area, then create sprite */
    spr->size   = size;
    spr->sproff = 16;
    e=_swix(OS_SpriteOp, _INR(0,1), 256+SprInitArea, spr);
    e=_swix(OS_SpriteOp, _INR(0,6), 256+SprCreateSprite, spr, "image", 0, w, h, 28);
    if (e) FreeMemoryAndReturn

    /* Add 256 entry palette */
    e=_swix(OS_SpriteOp, _INR(0,3), 256+SprAddPalette, spr, "image", (1U<<31)+1);
    if (e) FreeMemoryAndReturn

    /* If transparent, add mask */
    if (tp!=-1) e=_swix(OS_SpriteOp, _INR(0,2), 256+SprAddMask, spr, "image");
    if (e) FreeMemoryAndReturn

    spr_head = (sprite_header*) ((char*)spr + sizeof(sprite_area));
    spr_img = ((char*)spr_head) + spr_head->image;
    spr_msk = ((char*)spr_head) + spr_head->mask;
    spr_pal = ((char*)spr_head) + sizeof(sprite_header) - 4 - 2048;

    src_head = (sprite_header*) ((char*)im->spr_data + sizeof(sprite_area));
    src_pal  = ((char*)src_head) + sizeof(sprite_header) - 4 - 2048;

    /* Copy the palette data */
    memcpy(spr_pal, src_pal, 2048);

    e=LZW_decompress_start((uint8*) im->lzw_data);
    if (e) FreeMemoryAndReturn

    for (y=0; y<h; y++)
    {
        /* Decompress next row */
        #ifdef TRACE
        e=LZW_decompress_next((uint8*)spr_img, w, (uint8*)im->lzw_data, &bytes);
        #else
        e=LZW_decompress_next((uint8*)spr_img, w, (uint8*)im->lzw_data);
        #endif
        if (e) FreeMemoryAndReturn

        #ifdef TRACE
        /* If not a whole row of data, something's gone wrong */
        if (bytes!=w)
        {
            flex_free((flex_ptr)&spr);
            flex_set_budge(oldstate);
            return render_error("Decompression failed - not a whole row.\n");
        }
        #endif

        /* Set up mask */
        if (tp!=-1)
        {
            for (x=0; x<w; x++)
            {
                if (spr_img[x]==tp) spr_msk[x]=0;
                else spr_msk[x]=255;
            }
        }
        spr_img+=sw;
        spr_msk+=sw;
    }

    LZW_decompress_end();

    _swix(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)spr, filename);

    flex_free((flex_ptr)&spr);

    flex_set_budge(oldstate);

    return NULL;
}


_kernel_oserror* render_export_animated_sprites(int handle, char* filename)
{
    _kernel_oserror *e = NULL;

    /* Check it's a valid handle */
    if (!render_animate_valid_handle(handle)) return NULL;

    /* Save the sprites */
    e=_swix(OS_SpriteOp, _INR(0,2), 256+SprSaveSprites, (int)anims[handle]->rgb_data, filename);

    return e;
}


/*-----------------------------------------------------------------------------------------------------------------*/
/*                                                 TEMPORARY ROUTINES                                              */
/*-----------------------------------------------------------------------------------------------------------------*/


_kernel_oserror* render_error(char *s)
{
    static _kernel_oserror e;

    e.errnum=MiscErrorNum;
    sprintf(e.errmess,"Error from render: %s\n",s);

#if ReportErrorsToScreen
    _swi(OS_WriteC,_IN(0),4);
    _swi(OS_WriteC,_IN(0),26);
    printf("%s\n",e.errmess);
    //exit(0);
#endif

    return &e;
}


_kernel_oserror* render_error_and_abandon(int handle, char *s)
{
    static _kernel_oserror e;

    debug_print("  In render_error_and_abandon");

    e.errnum=MiscErrorNum;
    sprintf(e.errmess,"Error from render: %s\n",s);

#if ReportErrorsToScreen
    _swi(OS_WriteC,_IN(0),4);
    _swi(OS_WriteC,_IN(0),26);
    printf("%s\n",e.errmess);
#endif

    if (!images[handle]) return &e;
    if (images[handle]->lzw_handle!=-1) LZW_compress_end(images[handle]->lzw_handle);
    render_delete(handle);

    debug_print("  render_error_and_abandon ended.");

    return &e;
}


_kernel_oserror* animate_error_and_abandon(int handle, char *s)
{
    static _kernel_oserror e;

    debug_print("  In render_error_and_abandon");

    e.errnum=MiscErrorNum;
    sprintf(e.errmess,"Error from render: %s\n",s);

#if ReportErrorsToScreen
    _swi(OS_WriteC,_IN(0),4);
    _swi(OS_WriteC,_IN(0),26);
    printf("%s\n",e.errmess);
#endif

    if (!anims[handle]) return &e;

    render_animate_delete(handle);

    debug_print("  render_error_and_abandon ended.");

    return &e;
}


/*
static _kernel_oserror* render_sprite_put_screen_palette(char* palette)
{
    _kernel_oserror *e;
    int             *spr_palette;
    int              scr_palette[256];
    int              size, n;

    e=_swix(ColourTrans_ReadPalette, _INR(0,4)|_OUT(3), -1, -1, 0, 0, 0, &size);
    if (e) return e;
    if (size > (256*sizeof(int)) ) return render_error("Error in reading screen palette");

    e=_swix(ColourTrans_ReadPalette, _INR(0,4), -1, -1, &scr_palette, 256*sizeof(int), 0);
    spr_palette = (int*)palette;

    for (n=0; n<256; n++)
    {
        spr_palette[n*2] = spr_palette[n*2+1] = scr_palette[n];
    }

    return NULL;
}
*/

