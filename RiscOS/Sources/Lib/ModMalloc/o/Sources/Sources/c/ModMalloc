#include <stdlib.h>
#include <string.h>

#include "swis.h"

#include "Desk.Debug.h"
#include "Desk.Error.h"
#include "Desk.LinkList.h"

#ifdef MemCheck_MEMCHECK
	#include "MemCheck:MemCheck.h"
#endif

#include "ModMalloc.ModMalloc.h"


typedef struct	{
	Desk_linklist_header	header;
	int			size;	/* Size including header	*/
	}
	ModMalloc_header;

static Desk_linklist_header	ModMalloc_blocks = { NULL, NULL};



#ifdef MemCheck_MEMCHECK
	#pragma -c0
	/* We don't want MemCheck checking accesses from within here...	*/
#endif


#ifdef Desk_DEBUG
	static void	ModMalloc_Debug_ShowBlocks( void)
		{
		ModMalloc_header*	header;
		Desk_Debug2_Printf( Desk_error_PLACE "ModMalloc blocks are:\n");
		for	(
			header = (ModMalloc_header*) Desk_LinkList_FirstItem( &ModMalloc_blocks);
			header;
			header = (ModMalloc_header*) Desk_LinkList_NextItem( &header->header)
			)
			{
			Desk_Debug2_Printf( Desk_error_PLACE "0x%p-0x%p (%i)\n", header+1, (char*) header + header->size, header->size-sizeof( *header));
			}
		Desk_Debug2_Printf( Desk_error_PLACE "\n");
		}
#else
	#define	ModMalloc_Debug_ShowBlocks()
#endif



static _kernel_oserror*	ModMalloc__Free( void* ptr)
	{
	ModMalloc_header*	header;
	_kernel_oserror*	e;
	
	Desk_Debug_Printf( Desk_error_PLACE "ModMalloc__Free( 0x%p)\n", ptr);
	ModMalloc_Debug_ShowBlocks();
	
	if ( !ptr)	return NULL;
	
	header	= ( (ModMalloc_header*) ptr) - 1;
	
	Desk_LinkList_Unlink( &ModMalloc_blocks, &header->header);
	
	
	/*last	= header->prev;*/
	e	= _swix( OS_Module, _IN(0)|_IN(2), 7, header);
	
	if (e)	{
		Desk_Debug_Printf( "ModMalloc_Free 0x%p failed\n", ptr);
		return e;
		}
	/*
	if ( ModMalloc_lastblock == header
	ModMalloc_lastblock = last;
	*/
	#ifdef MemCheck_MEMCHECK
		MemCheck_UnRegisterMiscBlock( ptr);
	#endif
	
	return NULL;
	}

void	ModMalloc_Free( void* ptr)
	{
	ModMalloc__Free( ptr);
	}


void	ModMalloc_FreeDownTo( void* first)
	{
	ModMalloc_header*	firstheader = (first) ? ((ModMalloc_header*) first) - 1 : NULL;
	ModMalloc_header*	header;
	Desk_Debug_Printf( "ModMalloc_FreeAll called\n");
	for	(
		header = (ModMalloc_header*) Desk_LinkList_LastItem( &ModMalloc_blocks);
		header;
		header = (ModMalloc_header*) Desk_LinkList_PreviousItem( &header->header)
		)
		{
		Desk_Debug_Printf( "ModMalloc_FreeAll: freeing 0x%p\n", header+1);
		if ( ModMalloc__Free( header+1))	{
			Desk_Debug_Printf( "ModMalloc__Free returned error - teminating ModMalloc_FreeDownTo\n");
			break;
			}
		
		if ( header==firstheader)	break;
		/*
		if ( header==header->prev)	{
			Desk_Debug_Printf( "Circular list - terminating ModMalloc_FreeDownTo\n");
			break;
			}
		*/
		}
	Desk_Debug_Printf( "ModMalloc_FreeAll finished\n");
	}


void	ModMalloc_FreeAll( void)
	{
	ModMalloc_FreeDownTo( NULL);
	}


void*	ModMalloc_Malloc( size_t size)
	{
	ModMalloc_header*	header;
	_kernel_oserror*	e;
	/*
	static int		inited = 0;
	
	if (!inited)	{
		inited = 1;
		atexit( ModMalloc_FreeAll);
		}
	*/
	ModMalloc_Debug_ShowBlocks();
	size += sizeof( ModMalloc_header);
	e = _swix( OS_Module, _IN(0)|_IN(3)|_OUT(2), 6, size, &header);
	if (e)	{
		Desk_Debug_Printf( "ModMalloc_Malloc can't allocate memory\n");
		return NULL;
		}
	
	
	/*header->prev	= ModMalloc_lastblock;*/
	header->size	= size;
	/*ModMalloc_lastblock = header;*/
	Desk_LinkList_AddToTail( &ModMalloc_blocks, &header->header);
	
	#ifdef MemCheck_MEMCHECK
		MemCheck_RegisterMiscBlock( header+1, size - sizeof( ModMalloc_header));
	#endif
	return (void*) (header+1);
	}




#define	ModMalloc_MIN( x, y)	( (x<y) ? x : y)

void*	ModMalloc_Realloc( void* ptr, size_t newsize)
	{
	ModMalloc_header*	header = ( (ModMalloc_header*) ptr) - 1;
	ModMalloc_header*	newheader;
	Desk_linklist_header*	oldprev = Desk_LinkList_PreviousItem( &header->header);
	Desk_os_error*		e;
	
	Desk_LinkList_Unlink( &ModMalloc_blocks, &header->header);
	
	newsize += sizeof( ModMalloc_header);
	
	e = _swix( OS_Module, _IN(0)|_INR(2,3)|_OUT(2), 13, header, newsize-header->size, &newheader);
	
	if ( e)	{
		Desk_LinkList_InsertAfter( &ModMalloc_blocks, oldprev, &header->header);
		return NULL;
		}
	
	newheader->size = newsize;
	Desk_LinkList_InsertAfter( &ModMalloc_blocks, oldprev, &newheader->header);
	
	return newheader+1;
	/*
	ModMalloc_header*	header = ( (ModMalloc_header*) ptr) - 1;
	void*			newptr = ModMalloc_Malloc( newsize);
	ModMalloc_Debug_ShowBlocks();
	if (!newptr)	{
		Desk_Debug_Printf( "ModMalloc_Realloc failed\n");
		return NULL;
		}
	
	if ( ptr)	{
		memcpy( newptr, ptr, ModMalloc_MIN( header->size-sizeof( ModMalloc_header), newsize));
		ModMalloc_Free( ptr);
		}
	
	Don't need to call MeMCheck functions
	here - done by ModMalloc_Malloc/Free
	
	return newptr;
	*/
	}




void*	ModMalloc_Calloc( size_t n, size_t size)
	{
	void*	ptr = ModMalloc_Malloc( n*size);
	ModMalloc_Debug_ShowBlocks();
	if (!ptr)	{
		Desk_Debug_Printf( "ModMalloc_Calloc failed\n");
		return ptr;
		}
	memset( ptr, 0, n*size);
	/*
	Don't need to call MeMCheck functions 
	here - done by ModMalloc_Malloc/Free
	 */
	return ptr;
	}
