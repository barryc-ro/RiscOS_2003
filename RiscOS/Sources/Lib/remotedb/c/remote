/************************************************************************/
/*                  Copyright 1996 Acorn Computers Ltd                  */
/*                                                                      */
/*  This material is the confidential trade secret and proprietary      */
/*  information of Acorn Computers. It may not be reproduced, used      */
/*  sold, or transferred to any third party without the prior written   */
/*  consent of Acorn Computers. All rights reserved.                    */
/*                                                                      */
/************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>

#include "sys/types.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "netdb.h"
#include "netinet/in.h"
#include "socklib.h"
#define REMOTE_DEBUG
#include "remote.h"

#define REMOTE_DEBUG_MAX_LINE 256

/*
 * compare two strings caselessly
 */
static int
caseless_strcmp(char *a, char *b)
{
  int d;

  while (*a || *b)
  {
    d = tolower( *(a++) ) - tolower( *(b++) );
    if (d) return d;
  }
  return 0;
}

/*
 * check the input port for any data, if there is, check it for a newline
 * and if terminated correctly, extract the line.
 */
static int
debug_poll(debug_session *sess)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  fd_set read_set;
  struct timeval tv;
  char	 *argv[20];
  int    argc = 0;
  char   *cp;

  if (!sess)
    return (0);

  FD_ZERO(&read_set);
  FD_SET(sess->sock,&read_set);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  if (select(FD_SETSIZE,&read_set,NULL,NULL,&tv)<=0)
    return (0);

  if (FD_ISSET(sess->sock,&read_set))
  {
    if (recv(sess->sock, debug_line, sizeof(debug_line),MSG_PEEK)>0)
      if ((cp=strchr(debug_line,'\n'))!=NULL)
        if (recv(sess->sock, debug_line, (cp-debug_line+1),0)>0)
        {
          debug_line[cp-debug_line]='\0'; /* remove the new line char */
          /*
           * break down string
           */
          cp = debug_line;
          while (*cp != '\0')
          {
            while (*cp == ' ')
              cp++;
            if (*cp == '\0')
              break;
            argv[argc++] = cp;
            if (argc>=20)
              break;
            while (*cp != '\0' && *cp != ' ')
              cp++;
            if (*cp == 0)
              break;
            *cp++ = '\0';
          }
          *cp++ = '\0';
          /*
           * what do we want to do
           */
          if (caseless_strcmp(argv[0],"PRIORITY")==0)
          {
            if (argc>1)
            {
              debug_printf(sess,"(6) debug priority changed to %d\n",
              			     sess->priority);
              sess->priority = atoi(argv[1]);
            }
          }
          else
            debug_printf(sess,"(6) unknown command %s\n",argv[0]);
        }

  }
  return (0);
}

/*
 * send stuff to the debug session
 */
void
debug_printf(debug_session *sess, char *format, ...)
{
  char debug_line[REMOTE_DEBUG_MAX_LINE];
  va_list list;
  unsigned char priority=7;

  if (!sess)
    return;

  debug_poll(sess);

  va_start (list, format);
  vsprintf(debug_line,format, list);
  va_end(list);

  if (debug_line[strlen(debug_line)-1]!='\n')
    strcat(debug_line,"\n");

  if (debug_line[0]=='(')             /* get opening bracket */
    if (strchr(debug_line,')')!=NULL) /* find closing bracket */
      priority=atoi(debug_line+1);

  if (priority<=sess->priority)
  {
    send(sess->sock, sess->info, strlen(sess->info), 0);
    send(sess->sock, debug_line, strlen(debug_line), 0);
  }
}


/*
 * Reads environment variable Inet$DebugHost in the form valhalla:1448 to
 * obtain IP address and port number. Opens a socket to this host and returns
 * a structure to be used for subsequent debug calls. Debug session should be
 * closed using the remote_debug_session_close() function
 */
void
remote_debug_open(char *info, debug_session **db_sess)
{
  int rc;
  int debug_socket=-1;
  struct sockaddr_in sockaddr;
  struct hostent *hostent;
  debug_session *sess=NULL;
  char host[40];
  char *port;

  memset(&sockaddr, 0, sizeof(sockaddr));

  /*
   * where do we want to connect to
   */
  if (getenv("Inet$DebugHost")==NULL)
    goto exit_gracefully;
  strncpy(host,getenv("Inet$DebugHost"),sizeof(host));

  /*
   * find port
   */
  if ((port=strchr(host,':'))==NULL)
    goto exit_gracefully;

  *(port++) = 0; /* terminate host name and leave pointer to port */
  sockaddr.sin_port = htons(atoi(port));
  if (sockaddr.sin_port==0)
    goto exit_gracefully;

  /*
   * allocate a socket
   */
  do
  {
    debug_socket = socket(AF_INET, SOCK_STREAM, 0);
  } while (debug_socket == 0);

  hostent = gethostbyname(host);
  if (hostent == NULL)
    goto exit_gracefully;

  sockaddr.sin_family = AF_INET;
  sockaddr.sin_addr.s_addr = *(u_long*)hostent->h_addr;

  rc = connect(debug_socket, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
  if (rc<0)
    goto exit_gracefully;

  /*
   * allocate a debug session
   */
  if ((sess=malloc(sizeof(debug_session)))==NULL)
    goto exit_gracefully;

  sess->sock = debug_socket;

  if ((sess->info=malloc(strlen(info)+2))==NULL)
    goto exit_gracefully;

  strcpy(sess->info, info);
  strcat(sess->info, ": ");

  sess->priority = 7;

  /*
   * send initial opening message
   */
  debug_printf(sess,"(6) Open Version %s",REMOTE_DEBUG_VERSION);

  *db_sess = sess;

  return;

exit_gracefully:
  if (debug_socket >= 0)
    socketclose(debug_socket);

  if (sess)
  {
    if (sess->info)
      free(sess->info);
    free(sess);
  }
  *db_sess = NULL;
}

/*
 * close previously opened debug session
 */
void
remote_debug_close(debug_session *sess)
{
  if (sess)
  {
    debug_printf(sess,"(6) Close");
    if (sess->sock >= 0)
      socketclose(sess->sock);

    if (sess->info)
      free(sess->info);
    free(sess);
  }
  return;
}



