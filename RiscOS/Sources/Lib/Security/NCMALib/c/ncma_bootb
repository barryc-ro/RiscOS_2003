/************************************************************************/
/* File:    ncma_bootb.c                                                */
/* Purpose: deal with all aspects of bootblocks, enterprise blocks etc. */
/*                whether in RAM, NVRAM, or on the smartcard            */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pacemicro.com             */
/************************************************************************/

/* ANSI includes */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Library includes */
#include "kernel.h"
#include "swis.h"
#include "NVRAM.h"

/* Local includes */
#include "smtags.h"
#include "ncma_bootb.h"
#define PROTOTYPES_INTERNAL
#include "ncma_tags.h"
#include "ncma_scard.h"
#include "ncma_utils.h"
#include "smcard.h"
#include "dynalloc.h"
#include "debuglib/debuglib.h"

#ifdef SC_SWAPPING
#include "machine.h"
#endif /* SC_SWAPPING */
#include "DBUG.h"


/* Declare local variables */
/*
struct nvram
{
  char          initialised;
  int           len;
  unsigned char data[1];
};

static struct nvram *bootblock;
*/



/*********************************************************************************/
/* fetch_sc_bootblock                                                            */
/*                                                                               */
/* This routine fetches a bootblock into a memory area.                          */
/*                                                                               */
/* Parameters: int called_for_ISPCapture. This variable states whether this      */
/*              routine was called as part of ISPCapture. If this was the case,  */
/*              then it does not attempt to copy the bootblock of perform        */
/*              comparisons between bootblocks (needed for SC_SWAPPING           */
/*              behaviour)                                                       */
/*                                                                               */
/* Returns:    int : -1 if the bootblock was unobtainable; -2 if the bootblock   */
/*                   and bootblock copy did not match (SC_SWAPPING behaviour).   */
/*                   0 if there was no error.                                    */
/*                                                                               */
/*********************************************************************************/
int fetch_sc_bootblock(int called_for_ISPCapture, sc_bootblock_data_struct* bb_data)
{
    _kernel_swi_regs r;
    DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock() called with parameter %d\n", called_for_ISPCapture);

    /* Notes to self: NCBootblock spec (2107-791/FS) does not specify what the parameters passed in to NCBootbblock are.
        Am assuming from looking at the code that r.r[0]=1 means that we even want insecure bootblocksm and that with
        that flag set it will return the data whether secure or insecure. For builds where we require secure bootblocks,
        this flag *must* be set to 0.
    */
    #ifdef AUTHENTICATE_SIGNATURES
    r.r[0] = 0; /* tell bootblock that we must have secure (i.e. authenticated) data */
    #else
    r.r[0] = 1; /* tell bootblock that we want even insecure data */
    #endif /* AUTHENTICATE_SIGNATURES */
    if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "fetch_sc_bootblock: SWI failed\n");
      return(-1);
    }

#ifdef SC_SWAPPING
    if (called_for_ISPCapture == FETCH_BOOTBLOCK_FOR_ISPCAPTURE)
    {
      /* If a bootblock copy already exists and this is called for
          ISPcapture, it is assumed that the new values will replace the
          existing ones.Therefore if a copy exists here scrub it and allow it
          to be replaced when the user next connects.
         An example of when this happens is when the user connects but the
          URL on the sc is bad. The badurl screen allows the user to go back
          to ISPCapture to re-enter values, and thus when the user
          re-connects afterwards the card is said to be invalid. The logic
          below prevents this anamolous behaviour by fushing the bootblock
          copy, allowing it to be recreated with the new image next time the
          user reconnects.
      */
      if (sc_swapping.bootblock_copy != NULL) /* A bootblock copy has been allocated */
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: Flushing the existing bootblock copy.\n");
        rmfree(sc_swapping.bootblock_copy);
        sc_swapping.bootblock_copy = NULL;
      }
    }
#endif /* SC_SWAPPING */

    if(r.r[0]<0)
    {
      switch(r.r[0])
      {

        case -1: /* no enterprise data available */
               DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: no enterprise info available\n");
               bb_data->sc_block_ptr = NULL;
    	       bb_data->sc_block_bytes = 0;
    	       bb_data->sc_index_ptr = (unsigned char *)r.r[2];
    	       bb_data->sc_index_bytes = r.r[3];
    	       bb_data->sc_alt_ptr = (unsigned char *)r.r[4];
    	       bb_data->sc_alt_bytes = r.r[5];
    	       break;

        case -2: /* authentication failed */
               DBUG_PRINTF(DBUG_LVL_ERROR, "fetch_sc_bootblock: authentication failed\n");
               return(-1);

        default:
               DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: bizarre error %d\n", r.r[0]);
               return(-1);
      }
    }
    else
    {
      /* success */
      DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: succeeded\n");

      if(r.r[6] & 1)
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: NCBootblock doesn't trust this data\n");
        bb_data->trusted_scard_data = false;
      }
      else
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: NCBootblock trusts this data\n");
        bb_data->trusted_scard_data = true;
      }

      bb_data->sc_block_ptr = (unsigned char *)r.r[0];
      bb_data->sc_block_bytes = r.r[1];
      bb_data->sc_index_ptr = (unsigned char *)r.r[2];
      bb_data->sc_index_bytes = r.r[3];
      bb_data->sc_alt_ptr = (unsigned char *)r.r[4];
      bb_data->sc_alt_bytes = r.r[5];
      bb_data->sc_eb_ptr = find_tag_in_block(bb_data->sc_block_ptr, bb_data->sc_block_bytes, NCIBeginSignatureTag, &bb_data->sc_eb_bytes, NULL);
      bb_data->sc_hash_ptr = find_tag_in_block(bb_data->sc_block_ptr, bb_data->sc_block_bytes, NCISignatureTag, &bb_data->sc_hash_bytes, NULL);

  /* SC_SWAPPING behaviour requires that when a redial is requested that the
      card inserted is the card the session was strted with. This is achieved
      by the code below, which compares a copy of the bootblock of the
      original card with the one which is currently inserted. */
#ifdef SC_SWAPPING
    if (called_for_ISPCapture == FETCH_BOOTBLOCK_FOR_ISPCAPTURE)
    {
      /* Was called as part of ISPCapture. Since this is used before the
         'official' start of a session, it does not want to store the data
         here, as ISPCapture alters it. Instead it should be stored when
         connecting. */
      DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: Not copying bootblock as it was called for ISPCapture.\n");
    }

    if (called_for_ISPCapture == FETCH_BOOTBLOCK_FOR_CLIENT) /* The user is connecting */
    {
      if (sc_swapping.bootblock_copy==NULL)  /* Bootblock copy has not yet been allocated */
      {
        sc_swapping.bootblock_num_bytes = sc_block_bytes;
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: Allocating memory for bootb copy.\n");
        sc_swapping.bootblock_copy = rmalloc(sc_block_bytes, "Bootblock copy.");
        if (!sc_swapping.bootblock_copy)
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: Error : Could not Allocate memory for bootb copy.\n");
        }
        else
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: About to copy memory over.\n");
          memcpy(sc_swapping.bootblock_copy, sc_block_ptr, sc_block_bytes);
        }
      }
      else /* Bootblock copy has already been allocated- perform comparisons */
      {
        int comp_result;
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: A sc has already been allocated.\n");
        /* Compare with the latest memory area. */
        /* 1stly check sizes are the same */
        if (sc_block_bytes != sc_swapping.bootblock_num_bytes)
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: Sizes are different : Going to State_NCMAWrongISPCard (sc_block_bytes = %d bootblock_num_bytes = %d) .\n", sc_block_bytes, sc_swapping.bootblock_num_bytes);
          return (-2);
        }

        /* Now actually compare the blocks using memcmp - sizes must be the same. */
        comp_result = memcmp(sc_swapping.bootblock_copy, sc_block_ptr, sc_block_bytes);
        if (comp_result != 0)
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: This is not the same card we started the session with - memory areas are different. Result is %d\n", comp_result);
          return (-2);
        }

        /* If it gets this far, then it must be the same card. */
        DBUG_PRINTF(DBUG_LVL_DIAG, "fetch_sc_bootblock: This is the same card we started the session with.\n");
      }
    }
#endif /* SC_SWAPPING */

  }
  return(0);
}





/*********************************************************************************/
/* select_scard_iap                                                              */
/*                                                                               */
/* This routine selects the IAP off the smartcard.                               */
/*                                                                               */
/* Parameters: void                                                              */
/*                                                                               */
/* Returns:    int : -1 if no IAP block, 1 if block found, 0 otherwise.          */
/*                                                                               */
/*********************************************************************************/
int select_scard_iap(sc_bootblock_data_struct* bb_data)
{
    unsigned char *group_ptr;
    unsigned int group_bytes;

    unsigned char *matrix_ptr;
    unsigned int matrix_bytes;

    unsigned char *id_ptr;
    unsigned int id_bytes;

    unsigned int tmp;

    DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap()\n");

    if((matrix_ptr = find_tag_in_block(bb_data->sc_eb_ptr, bb_data->sc_eb_bytes, NCIIAPConnectMatrixTag, &matrix_bytes, NULL))==NULL)
    {
        DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: no IAPConnectMatrix in s/card block\n");
        return(-1);
    }

    for(group_ptr = NULL;;)
    {
        if((group_ptr = find_tag_in_block(matrix_ptr, matrix_bytes, NCIGroupTag, &group_bytes, group_ptr))==NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: exhausted s/card IAP groups\n");
            return(-1);
        }
        if((id_ptr = find_tag_in_block(group_ptr, group_bytes, NCIIAPIDTag, &id_bytes, NULL))==NULL) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: no IAP ID in this block\n");
            continue;
        }

        tmp = read_big_word((char *)id_ptr);
        bb_data->iap_id = tmp;
        DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: using IAP ID %d\n", bb_data->iap_id);
        bb_data->sc_iap_ptr = group_ptr;
        bb_data->sc_iap_bytes = group_bytes;
        return(1);
    }
    return(0);
}




/*********************************************************************************/
/* virgin_smartcard                                                              */
/*                                                                               */
/* This routine returns whether a smartcard is virgin (i.e. no data has been     */
/*  written to it) or sullied (data has been written to it in bootblock form).   */
/*                                                                               */
/* Parameters: void                                                              */
/*                                                                               */
/* Returns:    int : 1 if a virgin card, -1 for an error and 0 for a sullied     */
/*                   card.                                                       */
/*                                                                               */
/*********************************************************************************/
int virgin_smartcard(void)
{
    int i;
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard()\n");

    r.r[0] = 1; /* gimme data whether it's authentic or not */
    r.r[2] = 0; /* initialise to zero in case it's a substitute BB module
                   that doesn't fill these in (eg NCBBnvram or NCBBtwin) */
    if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL)
    {
        DBUG_PRINTF(DBUG_LVL_ERROR, "virgin_smartcard: Bootblock enquiry SWI failed!\n");
        return(-1);
    }

    if(r.r[0] != -2)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard(): r0 != -2\n");
      if (r.r[2])
      {
        i = *(unsigned int *)(r.r[2]);

        //DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: purity rating: 0x%x\n", i);
        if((i == 0x00000000) || (i == 0xffffffff))
        {
            DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: VIRGIN CARD\n");
            return(1);
        }
      }
    }
    else
    {
        DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SWI returned error %d\n", r.r[0]);
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SULLIED CARD\n");
    return(0);
}



/* This routine initialises a bootblock data struct to the defaults given in
smtags.h */

void initialise_sc_bootblock_data_struct(sc_bootblock_data_struct* struct_to_initialise)
{
  int l;

  struct_to_initialise->ram_block_ptr = NULL;
  struct_to_initialise->ram_eb_ptr = NULL;
  struct_to_initialise->ram_cert_ptr = NULL;
  struct_to_initialise->ram_sig_ptr = NULL;
  struct_to_initialise->ram_iap_ptr = NULL;

  struct_to_initialise->sc_block_ptr = NULL;
  struct_to_initialise->sc_eb_ptr = NULL;
  struct_to_initialise->sc_index_ptr = NULL;
  struct_to_initialise->sc_alt_ptr = NULL;
  struct_to_initialise->sc_iap_ptr = NULL;
  struct_to_initialise->sc_hash_ptr = NULL;

  struct_to_initialise->nvram_ptr = NULL;

  struct_to_initialise->ram_block_bytes = 0;
  struct_to_initialise->ram_eb_bytes = 0;
  struct_to_initialise->ram_cert_bytes = 0;
  struct_to_initialise->ram_sig_bytes = 0;
  struct_to_initialise->ram_iap_bytes = 0;

  struct_to_initialise->sc_block_bytes = 0;
  struct_to_initialise->sc_eb_bytes = 0;
  struct_to_initialise->sc_index_bytes = 0;
  struct_to_initialise->sc_alt_bytes = 0;
  struct_to_initialise->sc_iap_bytes = 0;
  struct_to_initialise->sc_hash_bytes = 0;

  struct_to_initialise->nvram_bytes = 0;

  struct_to_initialise->enterprise_id = 0;
  struct_to_initialise->iap_id = 0;
  struct_to_initialise->trusted_scard_data = false;

  /* Now initialise the tag_cache... */
  struct_to_initialise->tag_cache = (void*)rmalloc(sizeof(TAG_CACHE), "Tag cache");
  if (!struct_to_initialise->tag_cache)
  {
    dprintf(("", "initialise_sc_bootblock_data_struct(): Error allocating %d bytes of memory.\n", sizeof(TAG_CACHE)));
  }

  /* Now fill in the memory... */
  struct_to_initialise->tag_cache->base = NULL;
  struct_to_initialise->tag_cache->free = NULL;
  struct_to_initialise->tag_cache->tags = 0;
  struct_to_initialise->tag_cache->bytes = 0;
  struct_to_initialise->tag_cache->bytes = TAG_CACHE_SIZE;
  struct_to_initialise->tag_cache->valid = 0;

  /* Copy over all the tag values as specified in the smtags.h file */
  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    /* Allocate memory for string... */
    if (tag_cache.tag[l].tag) /* Tag has a value */
    {
      char description[255];
      sprintf(description, "Tag space for tag %d", l);
      struct_to_initialise->tag_cache->tag[l].tag = (char*)rmalloc(strlen(tag_cache.tag[l].tag)+1, description);
      if (!struct_to_initialise->tag_cache->tag[l].tag)
      {
        /* Memory allocation error */
        dprintf(("", "initialise_sc_bootblock_data_struct(): Error allocating %d bytes of memory.\n", strlen(tag_cache.tag[l].tag)+1));
      }
      strcpy((char*)struct_to_initialise->tag_cache->tag[l].tag, tag_cache.tag[l].tag);
      struct_to_initialise->tag_cache->tag[l].nci_tag = tag_cache.tag[l].nci_tag;
      struct_to_initialise->tag_cache->tag[l].mapping = tag_cache.tag[l].mapping;
      struct_to_initialise->tag_cache->tag[l].val = NULL;
      struct_to_initialise->tag_cache->tag[l].bytes = 0;

      dprintf(("", "initialise_sc_bootblock_data_struct(): Tag %d set to %s.\n",l, struct_to_initialise->tag_cache->tag[l].tag));
    }
    else
    {
      /* The last values should be set to NULL so that build_ram_cache stops at the last known tag. */
      struct_to_initialise->tag_cache->tag[l].tag = NULL;
    }
  }

}




/* This routine frees all memory allocated in a struct_to_free */
void free_sc_bootblock_data_struct(sc_bootblock_data_struct* struct_to_free)
{
  int l;

  /* Free the contents of the tag cache */
  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    /* Free memory... */
    if (struct_to_free->tag_cache->tag[l].tag)
    {
      rmfree((void*)struct_to_free->tag_cache->tag[l].tag);
      struct_to_free->tag_cache->tag[l].tag = NULL;
    }
    if (struct_to_free->tag_cache->tag[l].val)
    {
      rmfree((void*)struct_to_free->tag_cache->tag[l].val);
      struct_to_free->tag_cache->tag[l].val = NULL;
    }
  }

  /* Free the tag cache base itself (set in reset_cache()) */
  if (struct_to_free->tag_cache->base)
  {
    rmfree ((void*)struct_to_free->tag_cache->base);
    struct_to_free->tag_cache->base = NULL;
  }

  /* Free the tag cache itself */
  if (struct_to_free->tag_cache)
  {
    rmfree ((void*)struct_to_free->tag_cache);
    struct_to_free->tag_cache = NULL;
  }
}



/* This routine reads a bootblock via the NCBootblock_Enquiry SWI into the sc_bootblock_data_struct structure passed in and builds a cache of all the tags contained with it. It returns non-zero if an error has occured. */

int read_bootblock_from_ncbootblock(sc_bootblock_data_struct* bootblock)
{
  _kernel_swi_regs r;
  int error = 0;

  dprintf(("", "read_bootblock_from_NCBootblock()\n"));

  if (!bootblock)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error, bootblock passed in is NULL.\n"));
  }

  r.r[0] = 1; /* tell bootblock that we want even insecure data */
  if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): SWI failed\n"));
    return(-1);
  }

  if(r.r[0] < 0)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error %d getting main bootblock\n", r.r[0]));
  }
  else
  {

    if(r.r[6] & 1)
    {
      dprintf(("", "read_bootblock_from_NCBootblock(): NCBootblock doesn't trust this data\n"));
      bootblock->trusted_scard_data = false;
    }
    else
    {
      dprintf(("", "read_bootblock_from_NCBootblock(): NCBootblock trusts this data\n"));
      bootblock->trusted_scard_data = true;
    }

    bootblock->sc_block_ptr = (unsigned char *)r.r[0];
    bootblock->sc_block_bytes = r.r[1];
    bootblock->sc_index_ptr = (unsigned char *)r.r[2];
    bootblock->sc_index_bytes = r.r[3];
    bootblock->sc_alt_ptr = (unsigned char *)r.r[4];
    bootblock->sc_alt_bytes = r.r[5];
    bootblock->sc_eb_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCIBeginSignatureTag, &bootblock->sc_eb_bytes, NULL);
    bootblock->sc_hash_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCISignatureTag, &bootblock->sc_hash_bytes, NULL);
  }

  fetch_bootblock(bootblock);
  error = build_ram_cache(bootblock);
  if (error <= 0)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error building ram cache %d.\n", error));
  }

  return (error);
}






/* This routine reads a bootblock from an NVRAM tag into the sc_bootblock_data_struct structure passed in and builds a cache of all the tags contained with it. The NVRAM tag to read from is passed in in the nvram_tag parameter. It returns non-zero if an error has occured. */

int read_bootblock_from_nvram(sc_bootblock_data_struct* bootblock, const char* const nvram_tag)
{
  int error = 0;
  int bootblock_size = 0;

  /* Get the area of memory in which the default bootblock is stored. */
  _swix(NVRAM_Read, _INR(0,1)|_OUT(0), "BootBlockDefault", 0, &bootblock_size);
  dprintf(("", "read_bootblock_from_nvram(): bootblock_size is %d\n", bootblock_size));
  if (bootblock_size > 0)
  {
    bootblock->data = (void*)rmalloc(bootblock_size, "default bootblock store");
    if (bootblock->data)
    {
      _swix(NVRAM_Read, _INR(0,2), nvram_tag, bootblock->data, bootblock_size);
    }
    dprintf(("", "read_bootblock_from_nvram(): DefaultBootblock NVRAM tag has length %d.\n", bootblock_size));

    bootblock->len = bootblock_size;

    bootblock->sc_block_ptr = (unsigned char *)bootblock->data;
    bootblock->sc_block_bytes = bootblock->len;

    /* Now get the bootblock data */
    fetch_bootblock(bootblock);

    /* Build a RAM cache of all the tags. */
    error = build_ram_cache(bootblock);

    if (error <= 0)
    {
      dprintf(("", "read_bootblock_from_nvram(): Error building ram cache %d.\n", error));
    }

    /* Free the memory storing the NVRAM default bootblock */
    if (bootblock->data)
    {
      rmfree ((void*)bootblock->data);
      bootblock->data = NULL;
    }
  }

  return (error);
}




int fetch_bootblock(sc_bootblock_data_struct* bootblock)
{
  dprintf(("", "fetch_bootblock()\n"));

  dprintf(("", "fetch_bootblock(): bootblock is at %p, size %d\n", bootblock->sc_block_ptr, bootblock->sc_block_bytes));

  bootblock->sc_eb_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCIBeginSignatureTag, &bootblock->sc_eb_bytes, NULL);
  bootblock->sc_hash_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCISignatureTag, &bootblock->sc_hash_bytes, NULL);

  dprintf(("", "fetch_bootblock(): default_sc_eb_ptr = %p, default_sc_hash_ptr = %p\n", bootblock->sc_eb_ptr, bootblock->sc_hash_ptr));

  return(0);
}


