/************************************************************************/
/* File:    ncma_bootb.c                                                */
/* Purpose: deal with all aspects of bootblocks, enterprise blocks etc. */
/*                whether in RAM, NVRAM, or on the smartcard            */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pacemicro.com             */
/************************************************************************/

/* ANSI includes */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* Library includes */
#include "kernel.h"
#include "swis.h"
#include "NVRAM.h"

/* Local includes */
#include "smtags.h"
#include "ncma_bootb.h"
#define PROTOTYPES_INTERNAL
#include "ncma_tags.h"
#include "ncma_scard.h"
#include "ncma_utils.h"
#include "smcard.h"
#include "dynalloc.h"
#include "debuglib/debuglib.h"
#include "DBUG.h"






/*********************************************************************************/
/* select_scard_iap                                                              */
/*                                                                               */
/* This routine selects the IAP off the smartcard.                               */
/*                                                                               */
/* Parameters: void                                                              */
/*                                                                               */
/* Returns:    int : -1 if no IAP block, 1 if block found, 0 otherwise.          */
/*                                                                               */
/*********************************************************************************/
int select_scard_iap(sc_bootblock_data_struct* bb_data)
{
    unsigned char *group_ptr;
    unsigned int group_bytes;

    unsigned char *matrix_ptr;
    unsigned int matrix_bytes;

    unsigned char *id_ptr;
    unsigned int id_bytes;

    unsigned int tmp;

    DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap()\n");

    if((matrix_ptr = find_tag_in_block(bb_data->sc_eb_ptr, bb_data->sc_eb_bytes, NCIIAPConnectMatrixTag, &matrix_bytes, NULL))==NULL)
    {
        DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: no IAPConnectMatrix in s/card block\n");
        return(-1);
    }

    for(group_ptr = NULL;;)
    {
        if((group_ptr = find_tag_in_block(matrix_ptr, matrix_bytes, NCIGroupTag, &group_bytes, group_ptr))==NULL) {
            DBUG_PRINTF(DBUG_LVL_ERROR, "select_scard_iap: exhausted s/card IAP groups\n");
            return(-1);
        }
        if((id_ptr = find_tag_in_block(group_ptr, group_bytes, NCIIAPIDTag, &id_bytes, NULL))==NULL) {
            DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: no IAP ID in this block\n");
            continue;
        }

        tmp = read_big_word((char *)id_ptr);
        bb_data->iap_id = tmp;
        DBUG_PRINTF(DBUG_LVL_DIAG, "select_scard_iap: using IAP ID %d\n", bb_data->iap_id);
        bb_data->sc_iap_ptr = group_ptr;
        bb_data->sc_iap_bytes = group_bytes;
        return(1);
    }
    return(0);
}




/*********************************************************************************/
/* virgin_smartcard                                                              */
/*                                                                               */
/* This routine returns whether a smartcard is virgin (i.e. no data has been     */
/*  written to it) or sullied (data has been written to it in bootblock form).   */
/*                                                                               */
/* Parameters: void                                                              */
/*                                                                               */
/* Returns:    int : 1 if a virgin card, -1 for an error and 0 for a sullied     */
/*                   card.                                                       */
/*                                                                               */
/*********************************************************************************/
int virgin_smartcard(void)
{
    int i;
    _kernel_swi_regs r;

    DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard()\n");

    r.r[0] = 1; /* gimme data whether it's authentic or not */
    r.r[2] = 0; /* initialise to zero in case it's a substitute BB module
                   that doesn't fill these in (eg NCBBnvram or NCBBtwin) */
    if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL)
    {
        DBUG_PRINTF(DBUG_LVL_ERROR, "virgin_smartcard: Bootblock enquiry SWI failed!\n");
        return(-1);
    }

    if(r.r[0] != -2)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard(): r0 != -2\n");
      if (r.r[2])
      {
        i = *(unsigned int *)(r.r[2]);

        //DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: purity rating: 0x%x\n", i);
        if((i == 0x00000000) || (i == 0xffffffff))
        {
            DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: VIRGIN CARD\n");
            return(1);
        }
      }
    }
    else
    {
        DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SWI returned error %d\n", r.r[0]);
        return(-1);
    }

    DBUG_PRINTF(DBUG_LVL_DIAG, "virgin_smartcard: SULLIED CARD\n");
    return(0);
}



/* This routine initialises a bootblock data struct to the defaults given in
smtags.h */

void initialise_sc_bootblock_data_struct(sc_bootblock_data_struct* struct_to_initialise)
{
  int l;

  struct_to_initialise->ram_block_ptr = NULL;
  struct_to_initialise->ram_eb_ptr = NULL;
  struct_to_initialise->ram_cert_ptr = NULL;
  struct_to_initialise->ram_sig_ptr = NULL;
  struct_to_initialise->ram_iap_ptr = NULL;

  struct_to_initialise->sc_block_ptr = NULL;
  struct_to_initialise->sc_eb_ptr = NULL;
  struct_to_initialise->sc_index_ptr = NULL;
  struct_to_initialise->sc_alt_ptr = NULL;
  struct_to_initialise->sc_iap_ptr = NULL;
  struct_to_initialise->sc_hash_ptr = NULL;

  struct_to_initialise->nvram_ptr = NULL;

  struct_to_initialise->ram_block_bytes = 0;
  struct_to_initialise->ram_eb_bytes = 0;
  struct_to_initialise->ram_cert_bytes = 0;
  struct_to_initialise->ram_sig_bytes = 0;
  struct_to_initialise->ram_iap_bytes = 0;

  struct_to_initialise->sc_block_bytes = 0;
  struct_to_initialise->sc_eb_bytes = 0;
  struct_to_initialise->sc_index_bytes = 0;
  struct_to_initialise->sc_alt_bytes = 0;
  struct_to_initialise->sc_iap_bytes = 0;
  struct_to_initialise->sc_hash_bytes = 0;

  struct_to_initialise->nvram_bytes = 0;

  struct_to_initialise->enterprise_id = 0;
  struct_to_initialise->iap_id = 0;
  struct_to_initialise->trusted_scard_data = false;

  /* Now initialise the tag_cache... */
  struct_to_initialise->tag_cache = (void*)rmalloc(sizeof(TAG_CACHE), "Tag cache");
  if (!struct_to_initialise->tag_cache)
  {
    dprintf(("", "initialise_sc_bootblock_data_struct(): Error allocating %d bytes of memory.\n", sizeof(TAG_CACHE)));
  }

  /* Now fill in the memory... */
  struct_to_initialise->tag_cache->base = NULL;
  struct_to_initialise->tag_cache->free = NULL;
  struct_to_initialise->tag_cache->tags = 0;
  struct_to_initialise->tag_cache->bytes = 0;
  struct_to_initialise->tag_cache->bytes = TAG_CACHE_SIZE;
  struct_to_initialise->tag_cache->valid = 0;

  /* Copy over all the tag values as specified in the smtags.h file */
  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    /* Allocate memory for string... */
    if (tag_cache.tag[l].tag) /* Tag has a value */
    {
      char description[255];
      sprintf(description, "Tag space for tag %d", l);
      struct_to_initialise->tag_cache->tag[l].tag = (char*)rmalloc(strlen(tag_cache.tag[l].tag)+1, description);
      if (!struct_to_initialise->tag_cache->tag[l].tag)
      {
        /* Memory allocation error */
        dprintf(("", "initialise_sc_bootblock_data_struct(): Error allocating %d bytes of memory.\n", strlen(tag_cache.tag[l].tag)+1));
      }
      strcpy((char*)struct_to_initialise->tag_cache->tag[l].tag, tag_cache.tag[l].tag);
      struct_to_initialise->tag_cache->tag[l].nci_tag = tag_cache.tag[l].nci_tag;
      struct_to_initialise->tag_cache->tag[l].mapping = tag_cache.tag[l].mapping;
      struct_to_initialise->tag_cache->tag[l].val = NULL;
      struct_to_initialise->tag_cache->tag[l].bytes = 0;

      dprintf(("", "initialise_sc_bootblock_data_struct(): Tag %d set to %s.\n",l, struct_to_initialise->tag_cache->tag[l].tag));
    }
    else
    {
      /* The last values should be set to NULL so that build_ram_cache stops at the last known tag. */
      struct_to_initialise->tag_cache->tag[l].tag = NULL;
    }
  }
}




/* This routine frees all memory allocated in a struct_to_free */
void free_sc_bootblock_data_struct(sc_bootblock_data_struct* struct_to_free)
{
  int l;

  /* Free the contents of the tag cache */
  for(l=0; l<MAX_TAG_CACHE; l++)
  {
    /* Free memory... */
    if (struct_to_free->tag_cache->tag[l].tag)
    {
      rmfree((void*)struct_to_free->tag_cache->tag[l].tag);
      struct_to_free->tag_cache->tag[l].tag = NULL;
    }
    if (struct_to_free->tag_cache->tag[l].val)
    {
      rmfree((void*)struct_to_free->tag_cache->tag[l].val);
      struct_to_free->tag_cache->tag[l].val = NULL;
    }
  }

  /* Free the tag cache base itself (set in reset_cache()) */
  if (struct_to_free->tag_cache->base)
  {
    rmfree ((void*)struct_to_free->tag_cache->base);
    struct_to_free->tag_cache->base = NULL;
  }

  /* Free the tag cache itself */
  if (struct_to_free->tag_cache)
  {
    rmfree ((void*)struct_to_free->tag_cache);
    struct_to_free->tag_cache = NULL;
  }
}



/* This routine reads a bootblock via the NCBootblock_Enquiry SWI into the sc_bootblock_data_struct structure passed in and builds a cache of all the tags contained with it. It returns non-zero if an error has occured. */

int read_bootblock_from_ncbootblock(sc_bootblock_data_struct* bootblock)
{
  _kernel_swi_regs r;
  int error = 0;

  dprintf(("", "read_bootblock_from_NCBootblock()\n"));

  if (!bootblock)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error, bootblock passed in is NULL.\n"));
  }

  r.r[0] = 1; /* tell bootblock that we want even insecure data */
  if(_kernel_swi(NCBootblock_Enquiry, &r, &r)!=NULL)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): SWI failed\n"));
    return(-1);
  }

  if(r.r[0] < 0)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error %d getting main bootblock\n", r.r[0]));
  }
  else
  {

    if(r.r[6] & 1)
    {
      dprintf(("", "read_bootblock_from_NCBootblock(): NCBootblock doesn't trust this data\n"));
      bootblock->trusted_scard_data = false;
    }
    else
    {
      dprintf(("", "read_bootblock_from_NCBootblock(): NCBootblock trusts this data\n"));
      bootblock->trusted_scard_data = true;
    }

    bootblock->sc_block_ptr = (unsigned char *)r.r[0];
    bootblock->sc_block_bytes = r.r[1];
    bootblock->sc_index_ptr = (unsigned char *)r.r[2];
    bootblock->sc_index_bytes = r.r[3];
    bootblock->sc_alt_ptr = (unsigned char *)r.r[4];
    bootblock->sc_alt_bytes = r.r[5];
    bootblock->sc_eb_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCIBeginSignatureTag, &bootblock->sc_eb_bytes, NULL);
    bootblock->sc_hash_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCISignatureTag, &bootblock->sc_hash_bytes, NULL);
  }

  fetch_bootblock(bootblock);
  error = build_ram_cache(bootblock);
  if (error <= 0)
  {
    dprintf(("", "read_bootblock_from_NCBootblock(): Error building ram cache %d.\n", error));
  }

  return (error);
}






/* This routine reads a bootblock from an NVRAM tag into the sc_bootblock_data_struct structure passed in and builds a cache of all the tags contained with it. The NVRAM tag to read from is passed in in the nvram_tag parameter. It returns non-zero if an error has occured. */

int read_bootblock_from_nvram(sc_bootblock_data_struct* bootblock, const char* const nvram_tag)
{
  int error = 0;
  int bootblock_size = 0;
  _kernel_oserror* err = NULL;

  /* Get the area of memory in which the default bootblock is stored. */
  _swix(NVRAM_Read, _INR(0,1)|_OUT(0), "BootBlockDefault", 0, &bootblock_size);
  dprintf(("", "read_bootblock_from_nvram(): bootblock_size is %d as read from NVRAM tag %s", bootblock_size, nvram_tag));
  if (bootblock_size > 0)
  {
    bootblock->sc_block_ptr = (void*)rmalloc(bootblock_size, "bootblock store");
    if (bootblock->sc_block_ptr)
    {
      err = _swix(NVRAM_Read, _INR(0,2), "BootBlockDefault", bootblock->sc_block_ptr, bootblock_size);
      if (err)
      {
        dprintf(("", "read_bootblock_from_nvram(): Error reading default bootblock.\n"));
      }
    }
    dprintf(("", "read_bootblock_from_nvram(): DefaultBootblock NVRAM tag has length %d.\n", bootblock_size));

    bootblock->sc_block_bytes = bootblock_size;

    dprintf(("", "read_bootblock_from_nvram(): Bootblock is at %p length %d.\n", bootblock->sc_block_ptr, bootblock->sc_block_bytes));

    /* Now get the bootblock data */
    fetch_bootblock(bootblock);

    /* Build a RAM cache of all the tags. */
    error = build_ram_cache(bootblock);

    if (error <= 0)
    {
      dprintf(("", "read_bootblock_from_nvram(): Error building ram cache %d.\n", error));
    }
  }

  return (error);
}




int fetch_bootblock(sc_bootblock_data_struct* bootblock)
{
  dprintf(("", "fetch_bootblock()\n"));

  dprintf(("", "fetch_bootblock(): bootblock is at %p, size %d\n", bootblock->sc_block_ptr, bootblock->sc_block_bytes));

  bootblock->sc_eb_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCIBeginSignatureTag, &bootblock->sc_eb_bytes, NULL);
  bootblock->sc_hash_ptr = find_tag_in_block(bootblock->sc_block_ptr, bootblock->sc_block_bytes, NCISignatureTag, &bootblock->sc_hash_bytes, NULL);

  dprintf(("", "fetch_bootblock(): bootblock->sc_eb_ptr = %p, bootblock->sc_hash_ptr = %p\n", bootblock->sc_eb_ptr, bootblock->sc_hash_ptr));

  return(0);
}


