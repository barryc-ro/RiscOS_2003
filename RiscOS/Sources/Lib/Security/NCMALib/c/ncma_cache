/************************************************************************/
/* File:    ncma_cache.c                                                */
/* Purpose: Handle caching of RISC OS tags converted from NCI tag       */
/*           format in either RAM or on the smartcard                   */
/*                                                                      */
/* Author:  David Cotton <mailto:david.cotton@pacemicro.com>            */
/*                                                                      */
/************************************************************************/

/* ANSI includes */
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>

/* Library includes */
#include "kernel.h"
#include "swis.h"
#include "smcard.h"
#include "NVRAM.h"

/* Local includes */
#include "dynalloc.h"
#include "ncma_utils.h"
#include "smtags.h"
#define PROTOTYPES_INTERNAL
#include "ncma_tags.h"
#include "ncma_bootb.h"
#include "kprintf.h"
#include "DBUG.h"


/*********************************************************************************/
/* unlock_cache                                                                  */
/*                                                                               */
/* This routine marks the tag cache as being unlocked.                           */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    Nothing                                                           */
/*                                                                               */
/*********************************************************************************/
void unlock_cache(sc_bootblock_data_struct* bb_data)
{
  DBUG_PRINTF(DBUG_LVL_DIAG, "unlock_cache: unlocking tag cache\n");
  bb_data->tag_cache->valid = 0;
  return;
}





/*********************************************************************************/
/* cache_info                                                                    */
/*                                                                               */
/* This routine displays information on the tags held in the cache.              */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    int : Always 0, for some reason.                                  */
/*                                                                               */
/*********************************************************************************/
int cache_info(sc_bootblock_data_struct* bb_data)
{
    int l,m;

    kprintf("Tag cache stats:\n\n");

    kprintf("\nTag cache base: 0x%x  Bytes used: %d/%d  Tags in cache: %d\n", bb_data->tag_cache->base, bb_data->tag_cache->bytes, bb_data->tag_cache->max, bb_data->tag_cache->tags);

    kprintf("Tag cache %s ready\n\n", bb_data->tag_cache->valid?"":"not");

    for(l=0; l<MAX_TAG_CACHE; l++) {
        if(bb_data->tag_cache->tag[l].tag == NULL) break; /* no more tags */
        kprintf("%s (%d) %s",
           bb_data->tag_cache->tag[l].tag,
           bb_data->tag_cache->tag[l].bytes,
           bb_data->tag_cache->tag[l].bytes==0?"MISS":"HIT");

     if(bb_data->tag_cache->tag[l].bytes != 0)
     {
        switch(bb_data->tag_cache->tag[l].mapping)
        {
            case TAG_MAPPING_URL:
            case TAG_MAPPING_STRING:
            case TAG_MAPPING_HOST:
            case TAG_MAPPING_PROXY:
                 kprintf(" %s\n", (char *)(bb_data->tag_cache->tag[l].val));
                 break;

            case TAG_MAPPING_INT:
            case TAG_MAPPING_IP:
                 kprintf(" 0x%x\n", read_big_word((char *)(bb_data->tag_cache->tag[l].val)));
                 break;

            case TAG_MAPPING_SOAK:
            case TAG_MAPPING_PLIP:
                 m = read_little_word((char *)(bb_data->tag_cache->tag[l].val));
                 kprintf(" %s\n", m?"ENABLED":"DISABLED");
                 break;

            default:
                 kprintf(" ???\n");
                 break;
        }
     }
     else
     {
       kprintf("\n");
     }
   }

   return(0);
}




#define E_INSUFFICIENT_BUFFER_SPACE -2
#define E_INVALID_CACHE -1
/*********************************************************************************/
/* cache_enquiry                                                                 */
/*                                                                               */
/* This routine returns details of the tag passed in. If buff is NULL, then it   */
/*  only returns the length of the tag, otherwise it copies the tag into the     */
/*  buffer.                                                                      */
/*                                                                               */
/* Parameters: char *tag    The tag to be searched for.                          */
/*             char *buff   The buffer for the tag contents to be placed in.     */
/*             int bytes    The size of the buffer.                              */
/*                                                                               */
/* Returns:    int : -1 if the tag was not found, othweise length of the tag.    */
/*                                                                               */
/*********************************************************************************/
int cache_enquiry(sc_bootblock_data_struct* bb_data, char *tag, char *buff, int bytes, int use_hidden_phone_number)
{
    int l;

    if(!tag_cache.valid)
    {
      DBUG_PRINTF(DBUG_LVL_DIAG, "Returning -1 as cache is not valid.\n");
      return(E_INVALID_CACHE);
    }

    /* Ensure that if use_hidden_phone_number is set, it obtains the phone mumber
        from the NVRAM location, and not from the bootblock. This allows us to
        support two phone numbers, one from the bootblock for normal use and
        another, 'hidden' one, which can be used during production test to dial
        up to a test box. */
    if (use_hidden_phone_number && (strcmp(tag,"PSTN_NUM") == 0))
    {
      /* Obtain the phone number string from the NVRAM tag. */
      char* phone_number = get_nvram_tag_string("NCMAHiddenPhoneNumber");
      if (!phone_number) /* There was an error obtaining the alternate number */
      {
        DBUG_PRINTF(DBUG_LVL_ERROR, "NVRAM tag 'NCMAHiddenPhoneNumber' empty or does not exist.\n");
        return (E_INVALID_CACHE);
      }
      else
      {
        unsigned int phone_number_length = strlen(phone_number);
        DBUG_PRINTF(DBUG_LVL_DIAG, "NVRAM tag 'NCMAHiddenPhoneNumber' has value of %s (length %d)\n", phone_number, phone_number_length);
        if (buff != NULL)
        {
          strcpy (buff, phone_number);
          use_hidden_phone_number = false;
        }
        else
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "cache_enquiry: Since buffer passed in is NULL, not copying tag over and just returning the tag size (%d) (tag is %s).\n", phone_number_length, phone_number);
        }
        rmfree ((unsigned char*)phone_number);
        phone_number = NULL;
        return (phone_number_length);
      }
    }

    for(l=0; l<MAX_TAG_CACHE; l++)
    {
      if(caseless_strcmp(tag, (char *)bb_data->tag_cache->tag[l].tag)==0)
      {
        if(bb_data->tag_cache->tag[l].bytes != 0)
        {
          if (buff != NULL) /* If buff is NULL must not copy into it! */
          {
            memcpy(buff, bb_data->tag_cache->tag[l].val, bb_data->tag_cache->tag[l].bytes>bytes?bytes:bb_data->tag_cache->tag[l].bytes);
            DBUG_PRINTF(DBUG_LVL_DIAG, "cache_enquiry: serviced enquiry %s with %d bytes (tag is %s)\n", tag, bb_data->tag_cache->tag[l].bytes, bb_data->tag_cache->tag[l].val);
          }
          else
          {
            DBUG_PRINTF(DBUG_LVL_DIAG, "cache_enquiry: Since buffer passed in is NULL, not copying tag over and just returning the tag size (%d) (tag is %s).\n", bb_data->tag_cache->tag[l].bytes, bb_data->tag_cache->tag[l].val);
          }
        }
        else
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "cache_enquiry: tag %s valid but contains no data\n", tag);
        }
        return(bb_data->tag_cache->tag[l].bytes);
      }
    }
    DBUG_PRINTF(DBUG_LVL_ERROR, "cache_enquiry: no such tag \"%s\"\n", tag);
    return(-1);
}




/*********************************************************************************/
/* cache_ptr                                                                     */
/*                                                                               */
/* This routine return ptr to tag value, & return size in ref. variable          */
/*                                                                               */
/* Parameters: char *tag. The tag we wish to acquire a string from.              */
/*             int  *bytes. The number of bytes held in the tag.                 */
/*                                                                               */
/* Returns:    Null if the required tag was not found, otherwise the string      */
/*              value held in the tag.                                           */
/*                                                                               */
/*********************************************************************************/
char *cache_ptr(sc_bootblock_data_struct* bb_data, char *tag, int *bytes)
{
    int l;

    if(!bb_data->tag_cache->valid)
      return(NULL);

    for(l=0; l<MAX_TAG_CACHE; l++)
    {
        if(caseless_strcmp(tag, (char *)bb_data->tag_cache->tag[l].tag)==0)
        {
          if(bytes != NULL)
          {
            *bytes = bb_data->tag_cache->tag[l].bytes;
          }
          return(bb_data->tag_cache->tag[l].val);
        }
    }
    DBUG_PRINTF(DBUG_LVL_ERROR, "cache_ptr: no such tag \"%s\"\n", tag);
    return(NULL);
}



/*********************************************************************************/
/* build_ram_cache                                                               */
/*                                                                               */
/* This routine builds a cache of all tags that it can find in a bootblock.      */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    -1 if there was an error (eg. no bootblock), otherwise the        */
/*              number of tags in the cache.                                     */
/*                                                                               */
/*********************************************************************************/
int build_ram_cache(sc_bootblock_data_struct* bb_data)
{
    int l;
    char *ptr;
    int bytes;
    int tag_bytes;
    int actual_tags;
    unsigned int test_mode;

    unsigned char *tptr;
    unsigned int tbytes;

    /* reset cache */
    if(reset_cache(bb_data)<0)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "build_ram_cache(): cache reset failed\n");
      return(-1);
    }

    bytes = bb_data->tag_cache->max;
    ptr = bb_data->tag_cache->base;
    actual_tags = 0;

    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): entered\n");

    if(select_scard_iap(bb_data)<0)
    {
      DBUG_PRINTF(DBUG_LVL_ERROR, "build_ram_cache(): no IAP block on smartcard\n");
      bb_data->sc_iap_ptr = NULL;
      bb_data->sc_iap_bytes = 0;
      return(-1);
    }

    for(l=0; ((l<MAX_TAG_CACHE) && (bytes>0));l++)
    {
      if(bb_data->tag_cache->tag[l].tag == NULL)
      {
        DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): end of tag list at tag %d\n", l);
        break;
      }

      DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): searching for \"%s\" (0x%x)", bb_data->tag_cache->tag[l].tag, bb_data->tag_cache->tag[l].nci_tag);

      tptr = NULL;

      /* Attempt to find the tag in the smartcard IAP block. */
      if((tptr == NULL))
      { /* not in RAM, try SC IAP block */
        if((tptr=find_tag_in_block(bb_data->sc_iap_ptr, bb_data->sc_iap_bytes, bb_data->tag_cache->tag[l].nci_tag, &tbytes, NULL))==NULL)
        { /* not in SC IAP */
        }
        else
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "HIT (SC-IAP)\n");
        }
      } /* endif SC IAP */

      /* Attempt to find the tag in the smartcard. */
      if((tptr == NULL))
      { /* not in SC IAP block, try SC as a whole */
        if((tptr=find_tag_in_block(bb_data->sc_eb_ptr, bb_data->sc_eb_bytes, bb_data->tag_cache->tag[l].nci_tag, &tbytes, NULL))==NULL)
        { /* not in SC IAP */
        }
        else
        {
          DBUG_PRINTF(DBUG_LVL_DIAG, "HIT (SC)\n");
        }

      } /* endif SC */


      if(tptr == NULL)
      { /* run out of options */
        DBUG_PRINTF(DBUG_LVL_DIAG, "MISS\n");
        continue;
      }

      /* found it somewhere */
      tag_bytes = (tbytes<bytes)?tbytes:bytes;
      DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): mapping is %d, tag bytes: %d\n", bb_data->tag_cache->tag[l].mapping, tag_bytes);
//      add_tag_to_tag_cache(bb_data, tptr, tag_bytes, l, &actual_tags, &bytes, &ptr, tbytes);
      switch(bb_data->tag_cache->tag[l].mapping)
      {
          case TAG_MAPPING_URL:
          case TAG_MAPPING_STRING:
               strncpy(ptr, (char *)tptr, tag_bytes);
               *(ptr + tag_bytes) = 0;
               bb_data->tag_cache->tag[l].val = ptr;
               bb_data->tag_cache->tag[l].bytes = tag_bytes+1;
               ptr += tag_bytes+1;
               bytes -= tag_bytes+1;
               actual_tags++;
               break;

          case TAG_MAPPING_INT:
               if(bytes>=tbytes)
               {
                   memcpy(ptr, tptr, tbytes);
                   bb_data->tag_cache->tag[l].val = ptr;
                   bb_data->tag_cache->tag[l].bytes = tbytes;
                   ptr += tbytes;
                   bytes -= tbytes;
                   actual_tags++;
               }
               break;

          case TAG_MAPPING_HOST:
               strncpy(ptr, (char *)tptr, tag_bytes);
               *(ptr + tag_bytes) = 0;
               bb_data->tag_cache->tag[l].val = ptr;
               bb_data->tag_cache->tag[l].bytes = tag_bytes+1;
               ptr += tag_bytes+1;
               bytes -= tag_bytes+1;
               actual_tags++;
               break;

          case TAG_MAPPING_IP:
               if(bytes>=tbytes)
               {
                   memcpy(ptr, tptr, tbytes);
                   bb_data->tag_cache->tag[l].val = ptr;
                   bb_data->tag_cache->tag[l].bytes = tbytes;
                   ptr += tbytes;
                   bytes -= tbytes;
                   actual_tags++;
               }
               break;

          case TAG_MAPPING_PROXY:
               strncpy(ptr, (char *)tptr, tag_bytes);
               *(ptr + tag_bytes) = 0;
               bb_data->tag_cache->tag[l].val = ptr;
               bb_data->tag_cache->tag[l].bytes = tag_bytes+1;
               ptr += tag_bytes+1;
               bytes -= tag_bytes+1;
               actual_tags++;
               break;

          case TAG_MAPPING_SOAK:
               test_mode = read_big_word((char *)tptr);
               if(test_mode & TEST_TAG_SOAK)
               {
                 if(bytes>=4)
                 {
                   write_little_word(ptr, 1);
                   bb_data->tag_cache->tag[l].val = ptr;
                   bb_data->tag_cache->tag[l].bytes = tbytes;
                   ptr += tbytes;
                   bytes -= tbytes;
                   actual_tags++;
                   DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache: SOAK TEST ENABLED\n");
                 }
               }
               break;

          case TAG_MAPPING_PLIP:
               test_mode = read_big_word((char *)tptr);
               if(test_mode & TEST_TAG_PLIP) {
                   if(bytes>=4) {
                       write_little_word(ptr, 1);
                       bb_data->tag_cache->tag[l].val = ptr;
                       bb_data->tag_cache->tag[l].bytes = tbytes;
                       ptr += tbytes;
                       bytes -= tbytes;
                       actual_tags++;
                       DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache: PLIP DOWNLOAD ENABLED\n");
                   }
               }
                   break;

        } /* endswitch tag mappings */

    } /* end forall tags */

    bb_data->tag_cache->tags = actual_tags;
    bb_data->tag_cache->bytes = TAG_CACHE_SIZE - bytes;
    bb_data->tag_cache->free = ptr;
    bb_data->tag_cache->valid = 1;

    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): bytes                          : %d\n", bb_data->tag_cache->bytes);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): Tag cache number of tags       : %d\n", bb_data->tag_cache->tags);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): Tag cache number of bytes      : %d\n", bb_data->tag_cache->bytes);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): Tag cache base                 : %p\n", bb_data->tag_cache->base);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): Tag cache next free area       : %p\n", bb_data->tag_cache->free);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): Tag cache size                 : %d\n", TAG_CACHE_SIZE);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): sc_block_bytes                 : %d\n", bb_data->sc_block_bytes);
    DBUG_PRINTF(DBUG_LVL_DIAG, "build_ram_cache(): sc_block_ptr                   : %p\n", bb_data->sc_block_ptr);

    return(bb_data->tag_cache->tags);
}




/*********************************************************************************/
/* add_at_to_cache                                                               */
/*                                                                               */
/* This routine adds the tag passed in to the tag cache.                         */
/*                                                                               */
/* Parameters:                                                                   */
/*                                                                               */
/* Returns:   true if the tag was successfully aded to the cache, false          */
/*             otherwise                                                         */
/*   This routine is currently incpmplete and should not be used.                */
/*********************************************************************************/

bool add_tag_to_tag_cache(sc_bootblock_data_struct* bb_data, const unsigned char* const tptr, const int tag_bytes, const int tag_number, int* actual_tags, int* bytes, char** ptr, const unsigned int tbytes)
{
  unsigned int test_mode;

  DBUG_PRINTF(DBUG_LVL_DIAG, "add_tag_to_tag_cache(): \"%s\" (0x%x)\n", bb_data->tag_cache->tag[tag_number].tag, bb_data->tag_cache->tag[tag_number].nci_tag);
  assert(1!=1); /* This routine is currently incomplete */
  switch(bb_data->tag_cache->tag[tag_number].mapping)
  {
    case TAG_MAPPING_URL:
    case TAG_MAPPING_STRING:
         strncpy(*ptr, (char *)tptr, tag_bytes);
         *(ptr + tag_bytes) = 0;
         bb_data->tag_cache->tag[tag_number].val = *ptr;
         bb_data->tag_cache->tag[tag_number].bytes = tag_bytes+1;
         *ptr += tag_bytes+1;
         *bytes -= tag_bytes+1;
         *actual_tags +=1;
         break;

    case TAG_MAPPING_INT:
         if(*bytes>=tbytes)
         {
           memcpy(ptr, tptr, tbytes);
           bb_data->tag_cache->tag[tag_number].val = *ptr;
           bb_data->tag_cache->tag[tag_number].bytes = tbytes;
           *ptr += tbytes;
           *bytes -= tbytes;
           *actual_tags+=1;
         }
         break;

    case TAG_MAPPING_HOST:
         strncpy(*ptr, (char *)tptr, tag_bytes);
         *(*ptr + tag_bytes) = 0;
         bb_data->tag_cache->tag[tag_number].val = *ptr;
         bb_data->tag_cache->tag[tag_number].bytes = tag_bytes+1;
         *ptr += tag_bytes+1;
         *bytes -= tag_bytes+1;
         *actual_tags+=1;
         break;

    case TAG_MAPPING_IP:
         if(*bytes>=tbytes)
         {
           memcpy(*ptr, tptr, tbytes);
           bb_data->tag_cache->tag[tag_number].val = *ptr;
           bb_data->tag_cache->tag[tag_number].bytes = tbytes;
           *ptr += tbytes;
           *bytes -= tbytes;
           *actual_tags+=1;
         }
         break;

    case TAG_MAPPING_PROXY:
         strncpy(*ptr, (char *)tptr, tag_bytes);
         *(*ptr + tag_bytes) = 0;
         bb_data->tag_cache->tag[tag_number].val = *ptr;
         bb_data->tag_cache->tag[tag_number].bytes = tag_bytes+1;
         *ptr += tag_bytes+1;
         *bytes -= tag_bytes+1;
         *actual_tags+=1;
         break;

    case TAG_MAPPING_SOAK:
         test_mode = read_big_word((char *)tptr);
         if(test_mode & TEST_TAG_SOAK)
         {
           if(*bytes>=4)
           {
             write_little_word(*ptr, 1);
             bb_data->tag_cache->tag[tag_number].val = *ptr;
             bb_data->tag_cache->tag[tag_number].bytes = tbytes;
             *ptr += tbytes;
             *bytes -= tbytes;
             *actual_tags+=1;
             DBUG_PRINTF(DBUG_LVL_DIAG, "add_tag_to_cache(): SOAK TEST ENABLED\n");
           }
         }
         break;

    case TAG_MAPPING_PLIP:
    {
      test_mode = read_big_word((char *)tptr);
      if(test_mode & TEST_TAG_PLIP)
      {
        if(*bytes>=4)
        {
          write_little_word(*ptr, 1);
          bb_data->tag_cache->tag[tag_number].val = *ptr;
          bb_data->tag_cache->tag[tag_number].bytes = tbytes;
          *ptr += tbytes;
          *bytes -= tbytes;
          *actual_tags+=1;
          DBUG_PRINTF(DBUG_LVL_DIAG, "add_tag_to_cache(): PLIP DOWNLOAD ENABLED\n");
        }
      }
      break;
    }

  } /* endswitch tag mappings */

  return (true);
}




/*********************************************************************************/
/* reset_cache                                                                   */
/*                                                                               */
/* This routine resets the cache.                                                */
/*                                                                               */
/* Parameters: None                                                              */
/*                                                                               */
/* Returns:    int. Always 0.                                                    */
/*                                                                               */
/*********************************************************************************/
int reset_cache(sc_bootblock_data_struct* bootblock)
{
    int l;

    DBUG_PRINTF(DBUG_LVL_DIAG, "reset_cache()\n");

    if(bootblock->tag_cache->base == NULL)
    {
      if((bootblock->tag_cache->base = (char *)rmalloc(TAG_CACHE_SIZE, "NCMA tag cache"))==NULL) return(-1);
    }

    bootblock->tag_cache->free = tag_cache.base;
    bootblock->tag_cache->max = TAG_CACHE_SIZE;
    bootblock->tag_cache->bytes = 0;
    bootblock->tag_cache->tags = 0;
    bootblock->tag_cache->valid = 0;

    /* bin any old contents... */
    for(l=0; l<MAX_TAG_CACHE; l++)
    {
      bootblock->tag_cache->tag[l].val = NULL;
      bootblock->tag_cache->tag[l].bytes = 0;
    }

    memset(bootblock->tag_cache->base, 0, TAG_CACHE_SIZE);

    return(0);
}
