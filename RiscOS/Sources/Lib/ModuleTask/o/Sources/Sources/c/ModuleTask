#include "swis.h"

#include "Desk.Debug.h"
#include "Desk.Error.h"
#include "Desk.Str.h"

#include "ModuleTask.ModuleTask.h"

#include "Defs.h"

#include "MemCheck.MemCheck.h"


#define	TASKHANDLE	(*ModuleTask_Client.taskhandle_ptr)

char*	ModuleTask__stack	= NULL;


_kernel_oserror*	ModuleTask__ModuleInitialise( const char *cmd_tail, int podule_base, void *pw)
	{
	_kernel_oserror*	e;
	
	MemCheck_InitNoDebug();
	
	MemCheck_RegisterMiscBlock_StringCR( cmd_tail);
	/*
		{
		MemCheck_checking	oldchecking = MemCheck_SetChecking( 0, 1);
		MemCheck_RegisterMiscBlock( cmd_tail, 1+Desk_strlencr( cmd_tail));
		MemCheck_RestoreChecking( oldchecking);
		}
	*/
	Desk_Debug_Assert( ModuleTask_Client.module_initialise);
	
	e = ModuleTask_Client.module_initialise( cmd_tail, podule_base, pw);
	if (e)	return e;
	
	MemCheck_UnRegisterMiscBlock( cmd_tail);
	Desk_Debug_Assert( ModuleTask_Client.taskhandle_ptr);
	
	TASKHANDLE = 0;
	
	return NULL;
	}


_kernel_oserror*	ModuleTask__ModuleCmdHandler( const char *arg_string, int argc, int cmd_no, void* pw)
	{
	_kernel_oserror*	e = NULL;
	
	Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleCmdHandler called, cmd_no=%i\n", cmd_no);
	
	MemCheck_RegisterMiscBlock_StringCR( arg_string);
	/*
		{
		MemCheck_checking	oldchecking = MemCheck_SetChecking( 0, 1);
		MemCheck_RegisterMiscBlock( arg_string, 1+Desk_strlencr( arg_string));
		MemCheck_RestoreChecking( oldchecking);
		}
	*/
	
	if ( cmd_no == ModuleTask_Client.command_desktop_num)	{
		
		int	startup = 0;
		
		if ( TASKHANDLE == -1)	startup = 1;
		else if ( TASKHANDLE == 0)	{
			#ifdef ModuleTask_DESKTOP
				/* Check whether wimp is active, and enter module as above if so...	*/
				int	numtasks = 0;
				_swix( Wimp_ReadSysInfo, _IN(0)|_OUT(0), 0, &numtasks);	/* Returns >0 even at F12 command line...	*/
				if ( numtasks>0)	startup = 1;
			#else
			#endif
			}
		
		if ( startup)	{
			
			Desk_Debug_Printf( Desk_error_PLACE "Just about to enter module\n");
			
			e = _swix( OS_Module, _IN(0)|_IN(1)|_IN(2), 2, ModuleTask_Client.module_name, arg_string);
			
			if ( e)	Desk_Debug_Printf( 
					Desk_error_PLACE "ModuleTask__ModuleCmdHandler entering module returned 0x%i '%s'\n", 
					e->errnum, e->errmess
					);
			else	Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleCmdHandler entering module retunred NULL\n");
			}
		}
	
	else if ( ModuleTask_Client.module_commandhandler)
		return ModuleTask_Client.module_commandhandler( arg_string, argc, cmd_no, pw);
	
	MemCheck_UnRegisterMiscBlock( arg_string);
	
	return NULL;
	
	Desk_UNUSED( arg_string);
	Desk_UNUSED( argc);
	Desk_UNUSED( pw);
	}


#define Service_Memory          0x11
#define Service_StartWimp       0x49
#define Service_StartedWimp     0x4A
#define	Service_Help		0x09



void	ModuleTask__ModuleService( int service_no, _kernel_swi_regs *r, void *pw)
	{
	MemCheck_RegisterMiscBlock( r, sizeof( *r));
	
	if ( service_no == Service_StartWimp)	{
		if ( TASKHANDLE == 0)	{
			TASKHANDLE = -1;
			r->r[0] = (int) ModuleTask_Client.command_desktop;
			r->r[1] = 0;	/* Claim service	*/
			}
		}
	
	else if ( service_no == Service_StartedWimp)	{
		if ( TASKHANDLE == -1)	TASKHANDLE = 0;
		}
	
	
	/* We aren't interested in applicationspace. Used to claim Service_Memory - resulting
	in 'next' amount of app memory being used... 11 Apr 1997
	
	We still allow the client to claim this service call though.
	*/
	/*
	else if ( service_no == Service_Memory)	{
		//if ( TASKHANDLE == -1)	r->r[1]=0;
		}
	*/
	
	
	else	{
		#ifdef Desk_DEBUG
			if ( service_no == Service_Help)	{
				Desk_Debug_Printf( Desk_error_PLACE "Received service %i, client service fn = 0x%p\n", 
					service_no, ModuleTask_Client.module_service
					);
				}
		#endif
		if ( ModuleTask_Client.module_service)	{
			ModuleTask_Client.module_service( service_no, r, pw);
			}
		}
	
	MemCheck_UnRegisterMiscBlock( r);
	
	Desk_UNUSED( pw );
	}


_kernel_oserror*	ModuleTask__ModuleFinalise( int fatal, int podule, void* pw)
	{
	_kernel_oserror*	e = NULL;
	
	/*
	static Desk_os_error	cantquit = { 0, "Task is still active"};
	
	if ( TASKHANDLE > 0)	{
		Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleFinalise: can't quit - taskhandle is > 0 (%i)\n", TASKHANDLE);
		return &cantquit;
		}
	*/
	if ( ModuleTask_Client.module_finalise)	e = ModuleTask_Client.module_finalise( fatal, podule, pw);
	if (e)	{
		Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleFinalise: can't quit - task finalise fn returned error\n");
		return e;
		}
	
	if ( TASKHANDLE > 0)	{
		e = _swix( Wimp_CloseDown, _INR(0,1), TASKHANDLE, /**(int*)"TASK"*/0x4b534154);
		TASKHANDLE = 0;	/* Always set taskhandle to 0, so we can always quit after a second attempt, even if the task has gone wrong	*/
		if (e)	{
			Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleFinalise: Wimp_CloseDown returned error %i, '%s'\n", e->errnum, e->errmess);
			return e;
			}
		}
	
	if ( fatal)	{
		Desk_Debug_Printf( Desk_error_PLACE "\n");
		if ( ModuleTask__stack != NULL)	{
			Desk_Debug_Printf( Desk_error_PLACE "Freeing stack at 0x%p\n", ModuleTask__stack);
			_swix( OS_Module, _IN(0)|_IN(2), 7, ModuleTask__stack);
			ModuleTask__stack = NULL;
			}
		/*
		Desk_Debug_Printf( Desk_error_PLACE "Calling OS_Exit()\n");
		_swix( OS_Exit, _IN(0)|_IN(1), NULL, 0);
		Desk_Debug_Printf( Desk_error_PLACE "Called OS_Exit()\n");
		*/
		}
	
	Desk_Debug_Printf( Desk_error_PLACE "returning\n");
	return NULL;
	}




extern int	disable_stack_extension;

_kernel_oserror*	ModuleTask__ModuleEnter( const char *args)
	{
	Desk_Debug_Printf( Desk_error_PLACE "ModuleTask__ModuleEnter called, taskhandle=0x%08x\n", TASKHANDLE);
	Desk_Debug_Assert( ModuleTask_Client.module_enter);
	disable_stack_extension = 1;
	if ( TASKHANDLE == -1)	{
		if ( ModuleTask_Client.module_enter)	return ModuleTask_Client.module_enter( args);
		}
	
	return NULL;
	}
