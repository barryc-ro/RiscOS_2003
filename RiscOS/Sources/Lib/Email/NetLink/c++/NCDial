/* File:    NCDial.++
   Purpose: Control a modem metwork link through NCDial.
   Author:  Ben Laughton

   Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.

   History:

   1998-09-23: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include "kernel.h"
#include "swis.h"

// Toolbox / Wimp
#include "tboxlibs/event.h"

// Mailbox
#include "Email/Mailbox/WimpRegistry.h"

// NetLink
#include "NCDial.h"

#include "DebugLib/DebugLib.h"




// =============================================================================
// Define contants

#define TaskModule_RegisterService      0x4d302
#define TaskModule_DeRegisterService    0x4d303

#define TaskModule_Flags_PreserveOrder  0x1

#define Message_Service                 0x4d300

#define Service_DiallerStatus           0xb4

#define NCDialUI_Start                  0x4e880

#define NCDial_Hangup                   0x4ec01

enum
{
    NCDial_Status_Disconnected        = 0,
    NCDial_Status_IPUp                = 4,
    NCDial_Status_NoDialtone          = 0x81,
    NCDial_Status_Busy,
    NCDial_Status_NoCarrier,
    NCDial_Status_ServerNotResponding,
    NCDial_Status_Timeout,
    NCDial_Status_Error,
    NCDial_Status_Starting            = 0x90,
    NCDial_Status_Dialling,
    NCDial_Status_Connecting,
    NCDial_Status_Connected
};



/* =============================================================================
 * Define types
 */

struct wimp_message_header_t
{
    int  size;
    int  sender;
    int  my_ref;
    int  your_ref;
    int  action_code;
};

struct wimp_message_service_t
{
    wimp_message_header_t  header;
    _kernel_swi_regs       r;
};

// Register with WimpRegistry
class NCDialNetLink_wimp_register
{
    public:
         NCDialNetLink_wimp_register ();
};




// =============================================================================
// Declare global objects

// Static object that on construction registers with WimpRegistry so that
// before main() is entered, WimpRegistry is set up.

static NCDialNetLink_wimp_register  wimp_reg;




// =============================================================================
// Member function definitions

/* -----------------------------------------------------------------------------
   NCDialNetLink_wimp_register::NCDialNetLink_wimp_register

   Constructor.  Tells the WimpRegistry that we wish to receive Message_Service
   Wimp messages.
 */

NCDialNetLink_wimp_register::NCDialNetLink_wimp_register ()
{
    WimpRegistry::Instance()->RegisterMessage (Message_Service);
}




/* -----------------------------------------------------------------------------
   NCDialNetLink::NCDialNetLink

   Constructor.
 */

NCDialNetLink::NCDialNetLink ()
    : _handlers_registered (false)
{
    dprintf (("", "NetLink: NCDialNetLink constructor\n"));
}




/* -----------------------------------------------------------------------------
   NCDialNetLink::~NCDialNetLink

   Constructor.
 */

NCDialNetLink::~NCDialNetLink ()
{
    dprintf (("", "NetLink: NCDialNetLink destructor\n"));
}




/* -----------------------------------------------------------------------------
   NCDialNetLink::Connect

   Connect to NCDial network link.  Just calls any registered callbacks
   immediately because the link doesn't need to be established.

   Returns ELib_rcode
   ELIB_COMPLETED
 */

ELib_rcode  NCDialNetLink::Connect ()
{
    ELib_rcode       rc = ELIB_COMPLETED;
    NetLink::Status  current_status = GetStatus ();


    dprintf (("", "NetLink: NCDialNetLink::Connect current=%d\n",
              current_status));

    // Only try to connect if the link is currently disconnected, disconnecting
    // or had previously failed with an error.
    if (current_status != NetLink::Connected &&
        current_status != NetLink::Connecting)
    {
        _kernel_oserror *  e = NULL;

        if (!_handlers_registered)
        {
            dprintf (("", "NetLink: registering handlers\n"));
            e = register_handlers (&NCDialNetLink::connect_status_handler);
        }

        if (e == NULL)
        {
            // Call NCFrescoReDial to start the dial
            e = _swix (OS_CLI,
                       _IN (0),
                       "NCFrescoReDial");

            if (e == NULL)
            {
                ChangeStatus (NetLink::Connecting);
            }
            else
            {
                dprintf (("", "NetLink: NCDialUI_Start error: %s\n", e->errmess));
            }
        }

        if (e)
        {
            // Ensure we don't leave any dangling registrations if an error
            // occurs.
            deregister_handlers ();

            rc = ELIB_EFAILED;
        }
    }

    return rc;
}




/* -----------------------------------------------------------------------------
   NCDialNetLink::Disconnect

   Disconnect from NCDial network link.  Just calls any registered callbacks
   immediately because the link doesn't really get taken down.

   Returns ELib_rcode
   ELIB_COMPLETED
 */

ELib_rcode  NCDialNetLink::Disconnect ()
{
    ELib_rcode       rc = ELIB_COMPLETED;
    NetLink::Status  current_status = GetStatus ();


    // Only try to disconnect if the link is not already disconnected (possibly
    // due to a previous error).
    if (current_status != NetLink::Disconnected &&
        current_status != NetLink::Error)
    {
        _kernel_oserror *  e = NULL;

        if (!_handlers_registered)
        {
            e = register_handlers (&NCDialNetLink::disconnect_status_handler);
        }

        if (e == NULL)
        {
            // Call NCDial to disconnect
            e = _swix (NCDial_Hangup,
                       0);

            if (e == NULL)
            {
                ChangeStatus (NetLink::Disconnecting);
            }
        }

        if (e)
        {
            deregister_handlers ();

            rc = ELIB_EFAILED;
        }
    }

    return rc;
}




int  NCDialNetLink::service_message_handler (
                        WimpMessage *  message,
                        void *         handle)
{
    wimp_message_service_t *  service_message =
        (wimp_message_service_t *) message;
    int                       rc = 0;

    /* Service call number held in r1 in register block */
    if (service_message->r.r[1] == Service_DiallerStatus)
    {
        NCDialNetLink *  this_netlink = (NCDialNetLink *) handle;

        dprintf (("", "NetLink: received Service_DiallerStatus %d\n",
                  service_message->r.r[2]));

        (this_netlink->*(this_netlink->_status_handler)) (
            service_message->r.r[2]);
        rc = 1;
    }

    return rc;
}




void  NCDialNetLink::connect_status_handler (const int  ncdial_status)
{
    NetLink::Status  current_status = GetStatus ();
    NetLink::Status  new_status;

    dprintf (("", "NetLink: current status is %d\n", current_status));

    switch (ncdial_status)
    {
        case NCDial_Status_IPUp:
            new_status = NetLink::Connected;
            break;

        case NCDial_Status_NoDialtone:
        case NCDial_Status_Busy:
        case NCDial_Status_NoCarrier:
        case NCDial_Status_ServerNotResponding:
        case NCDial_Status_Timeout:
        case NCDial_Status_Error:
            new_status = NetLink::Error;
            break;

        default:
            new_status = current_status;
            break;
    }

    dprintf (("", "NetLink: new status is %d\n", new_status));
    if (new_status != current_status)
    {
        ChangeStatus (new_status);

        // Know this new state is terminal, so deregister handlers
        deregister_handlers ();
    }
}




void  NCDialNetLink::disconnect_status_handler (const int  ncdial_status)
{
    NetLink::Status  current_status = GetStatus ();
    NetLink::Status  new_status;

    switch (ncdial_status)
    {
        case NCDial_Status_Disconnected:
            new_status = NetLink::Disconnected;
            break;

        case NCDial_Status_NoDialtone:
        case NCDial_Status_Busy:
        case NCDial_Status_NoCarrier:
        case NCDial_Status_ServerNotResponding:
        case NCDial_Status_Timeout:
        case NCDial_Status_Error:
            new_status = NetLink::Error;
            break;

        default:
            new_status = current_status;
            break;
    }

    if (new_status != current_status)
    {
        ChangeStatus (new_status);

        // Know this new state is terminal, so deregister handlers
        deregister_handlers ();
    }
}



_kernel_oserror *  NCDialNetLink::register_handlers (
                                      status_handler_fn  status_handler)
{
    _kernel_oserror *  e;
    int                task_handle = WimpRegistry::Instance()->GetTaskID ();

    e = _swix (TaskModule_RegisterService,
               _INR (0, 2),

               TaskModule_Flags_PreserveOrder,
               Service_DiallerStatus,
               task_handle);
    if (e == NULL)
    {
        e = event_register_message_handler (
                Message_Service,
                NCDialNetLink::service_message_handler,
                this);
        if (e == NULL)
        {
            _handlers_registered = true;
            _status_handler      = status_handler;
        }
        else
        {
            (void) _swix (TaskModule_DeRegisterService,
                          _INR (0, 2),
                          0,
                          Service_DiallerStatus,
                          task_handle);
        }
    }

    return e;
}


void  NCDialNetLink::deregister_handlers ()
{
    (void) event_deregister_message_handler (
               Message_Service,
               NCDialNetLink::service_message_handler,
               this);

    (void) _swix (TaskModule_DeRegisterService,
                  _INR (0, 2),
                  0,
                  Service_DiallerStatus,
                  WimpRegistry::Instance()->GetTaskID ());

    _handlers_registered = false;
}
