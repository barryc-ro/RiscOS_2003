/* File:    POP3Mailbox.c++
   Purpose:
   Author:  Ben Laughton

   Copyright 1998 Acorn Computers Ltd

   This material is the confidential trade secret and proprietary information
   of Acorn Computers. It may not be reproduced, used sold, or transferred to
   any third party without the prior written consent of Acorn Computers.
   All rights reserved.

   History:

   1998-08-10: BAL
   Created.
 */




// =============================================================================
// Include header files

// CLib
#include <string.h>

// General email
#include "Email/Common/bool.h"
#include "Email/Common/list.h"
#include "Email/Common/types.h"

// Mailbox
#include "Mailbox.h"
#include "utils.h"

#include "MBoxOpCB/getnummsgs.h"

#include "POP3/POP3GetNumMsgs.h"
#include "POP3/POP3Mailbox.h"
#include "POP3/POP3Message.h"
#include "POP3/POP3Process.h"



// =============================================================================
// Define member functions

/* -----------------------------------------------------------------------------
 */

POP3Mailbox::POP3Mailbox (POP3Imp &  imp)
    : Mailbox (),
      _session (imp)
{
    // Do nothing
}




ELib_rcode  POP3Mailbox::GetNumberMessages (MBoxOpCB_getnummsgs *const  cb)
{
    if (cb)
    {
        cb->rc = ELIB_COMPLETED;
        cb->number_messages = _number_messages;
        cb->Callback ();
    }

    return  ELIB_COMPLETED;
}




/* -----------------------------------------------------------------------------
   POP3Mailbox::Process

 */

ELib_rcode  POP3Mailbox::Process (MBoxOpCB_process *const  cb)
{
    ELib_rcode  rc;


    POP3MBox_process *  process =
        new POP3MBox_process (
                this,
                (MBoxCBHandlerMethod) &POP3Mailbox::process_cb_handler,
                cb,
                &_session,
                rc);

    if (process)
    {
        if (rc == ELIB_COMPLETED)
        {
            process->Execute ();
        }
    }
    else
    {
        rc = ELIB_EMALLOCFAILED;
    }

    return rc;
}




ELib_rcode  POP3Mailbox::Expunge (MBoxOpCB_expunge *const  cb)
{
    M_unused (cb);
    return ELIB_ENOTSUPPORTED;
}




ELib_rcode  POP3Mailbox::UpdateIDs (MBoxOpCB_updateids *const  cb)
{
    M_unused (cb);
    return ELIB_ENOTSUPPORTED;
}




/* -----------------------------------------------------------------------------
   POP3Mailbox::process_cb_handler
 */

void  POP3Mailbox::process_cb_handler (MBoxCB *const  cb,
                                       void *         client_data)
{
    M_unused (client_data);

    POP3MBox_process *const  process = (POP3MBox_process *) cb;
    ELib_rcode  rc = process->rc;

    _number_messages = process->number_messages;

    // Create list of messages which match those we already know about
    bool *         matchlist = new bool[_number_messages];
    POP3Message *  message;
    int            i;

    for (i = 0; i < _number_messages; ++i)
    {
        matchlist[i] = false;
    }

    // For each message we already know about, check if it still exists on
    // the server.  If not then delete it from our internal representation of
    // the mailbox.  If it does still exist then flag this fact and flag the
    // message as old.

    for (messages.Start (); !messages.Nul (); messages.Next ())
    {
        message = (POP3Message *) messages.Current ();

        for (i = 0; i < _number_messages; ++i)
        {
            if (matchlist[i] == false &&
                strcmp (message->GetUID (),
                        process->uid_list[i].unique_id) == 0)
            {
                matchlist[i] = true;
            }
        }

        if (matchlist[i])
        {
            // Mark message as old

            ELib_rcode  rc;

//            MBoxOpCB_setflags  * setflags =
//                new (*this,
//                     (CallbackHandler) POP3Mailbox::set_flags_cb_handler,
//                     rc);

            rc = message->SetFlags (0,    // Don't care about the result
                                    Message::New,
                                    Message::New);
        }
        else
        {
            // Message is no longer on server so remove from our internal
            // representation of the mailbox.

            delete message;
            messages.Delete ();
        }
    }

    // Each message in the list of UIDs that was not matches is a new message
    for (i = 0; i < _number_messages; ++i)
    {
        if (matchlist[i] == false)
        {
            POP3Message *  new_message =
                               new POP3Message (_session,
                                                *this,
                                                Message::New,
                                                rc,
                                                process->message_list[i].msg_size,
                                                process->message_list[i].msg_id,
                                                process->uid_list[i].unique_id);
            messages.End ();
            messages.Insert (new_message);
        }
    }

    delete[] matchlist;

    MBoxOpCB *  mbox_cb = process->mailbox_op;
    if (mbox_cb)
    {
        mbox_cb->rc = rc;
        mbox_cb->Callback ();
    }
}




/* -----------------------------------------------------------------------------
   POP3Mailbox::set_flags_cb_handler
 */

//void  POP3Mailbox::set_flags_cb_handler (MBoxOpCB_setflags &  cb)
//{
//    // Do nothing for now.  Having to use callbacks for the flags stuff is
//    // awkward.
//}
