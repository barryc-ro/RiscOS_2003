#include "Email/Common/list.h"

#include "Email/Mailbox/Mailbox.h"
#include "Email/Mailbox/Message.h"
#include "Email/Mailbox/WimpRegistry.h"

#include "Email/Mailbox/MBoxOpCB/MBoxOpCB.h"
#include "Email/Mailbox/MBoxOpCB/process.h"
#include "Email/Mailbox/MBoxOpCB/sendmsg.h"

#include "Email/Mailbox/POP3/POP3Account.h"

#include "Email/Mailbox/SendQ/SendQAccount.h"
#include "Email/Mailbox/SendQ/SendQMailbox.h"
#include "Email/Mailbox/SendQ/SendQMessage.h"

#include "main.h"

#include "Engine.h"


Engine::Engine ()
    : fp (0), usage (0)
{
}


void Engine::Init(void)
{
    ELib_rcode rc = ELIB_COMPLETED;

    fp = fopen ("<MBoxTest$Dir>.session", "w");
    if (fp)
    {
        setbuf (fp, 0);
        account = new POP3Account ("pop3test",
                                   "pop3test",
                                   "rwarren",
                                   rc);

        if ((account) && (rc == ELIB_COMPLETED))
        {
            sendq = new SendQAccount ("rwarren",
                                      rc);
            if (sendq == 0)
            {
                rc = ELIB_EMALLOCFAILED;
            }
            else
            {
                SendQMailbox *  mbox = (SendQMailbox *) sendq->GetInbox ();

                rc = mbox->AddMessage ("<MBoxTest$Dir>.^.^.msg",
                                       "rwarren@acorn.com",
                                       "rwarren@acorn.com");
            }
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    if (rc < 0)
    {
        error (rc);
    }
}



void Engine::inc_usage ()
{
    ++usage;
}

void Engine::dec_usage ()
{
    if (--usage == 0)
    {
        g_quit = true;
    }
}

bool Engine::Receive ()
{
    bool success;
    ELib_rcode  rc;

    if (fp)
    {
        if (account)
        {
            // start test
            MBoxOpCB_connect *  connect =
                new MBoxOpCB_connect (
                    this,
                    (MBoxCBHandlerMethod) &Engine::connect_cb_handler);

            if (connect)
            {
                rc = account->Connect (connect);
            }
            else
            {
                rc = ELIB_EMALLOCFAILED;
            }
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }
    else
    {
        rc = ELIB_EWRITEFAIL;
    }

    if (rc < 0)
    {
        error (rc);
        success = false;
    }
    else
    {
        inc_usage ();
        success = true;
    }


    return success;
}




Engine::~Engine ()
{
    if (account)
      delete account;
    if (sendq)
       delete sendq;
    if (fp)
    {
        fclose (fp);
    }
}




void  Engine::connect_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_connect *const  connect = (MBoxOpCB_connect *) cb;
    ELib_rcode  rc = connect->rc;

    if (rc == ELIB_COMPLETED)
    {
        fprintf (fp, "Connected\n");

        Mailbox *  mbox = account->GetInbox ();

        MBoxOpCB_process *  process =
            new MBoxOpCB_process (
                    this,
                    (MBoxCBHandlerMethod) Engine::process_cb_handler);

        if (process)
        {
            rc = mbox->Process (process);
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    delete connect;

    if (rc < 0)
    {
        error (rc);
    }
}




void  Engine::process_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_process *const  process = (MBoxOpCB_process *) cb;
    ELib_rcode  rc = process->rc;

    if (rc == ELIB_COMPLETED)
    {
        fprintf (fp, "Processed mailbox\n");
        if (process->mailbox_changed)
        {
            fprintf (fp, "Mailbox state changed\n");
        }
        else
        {
            fprintf (fp, "Mailbox state has not changed after processing\n");
        }

        MBoxOpCB_getnummsgs *  getnummsgs =
            new MBoxOpCB_getnummsgs (
                    this,
                    (MBoxCBHandlerMethod) Engine::enumerate_messages);

        if (getnummsgs)
        {
            Mailbox *  mbox = account->GetInbox ();
            rc = mbox->GetNumberMessages (getnummsgs);
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    delete process;

    if (rc < 0)
    {
        error (rc);
    }
}



class EnumerateMsgs : public MBoxCBHandlerObject, public MBoxCB
{
    public:
        EnumerateMsgs (MBoxCBHandlerObject *  cb_handler,
                       MBoxCBHandlerMethod  cb_fn,
                       Mailbox &          mailbox,
                       FILE *const        fp,
                       ELib_rcode &       rcode);

    private:
        ELib_rcode  get_message ();
        void getlength_cb_handler (MBoxCB *const  cb);
        void gethdrs_cb_handler (MBoxCB *const  cb);

   public:
       ELib_rcode  rc;

   private:
       Mailbox &    _mailbox;
       ELib_list &  _messages;
       uint32       _count;
       FILE *const  _fp;
};

EnumerateMsgs::EnumerateMsgs (MBoxCBHandlerObject *  cb_handler,
                              MBoxCBHandlerMethod  cb_fn,
                              Mailbox &          mailbox,
                              FILE *const        fp,
                              ELib_rcode &       rcode)
    : MBoxCB (cb_handler,
              cb_fn,
              0),
      _mailbox (mailbox),
      _count (0),
      _messages (_mailbox.GetMessages ()),
      _fp (fp)
{
    _messages.Start ();
    rcode = get_message ();
}

ELib_rcode  EnumerateMsgs::get_message ()
{
    if (_messages.Nul ())
    {
        rc = ELIB_COMPLETED;
        //Callback ();
    }
    else
    {
        MBoxOpCB_getlength *  getlength =
            new MBoxOpCB_getlength (
                    this,
                    (MBoxCBHandlerMethod) &EnumerateMsgs::getlength_cb_handler);

        if (getlength)
        {
            Message *const  message = (Message *) _messages.Current ();
            message->GetLength (getlength);
            rc = ELIB_RUNNING;
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    return rc;
}


void EnumerateMsgs::getlength_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_getlength *const getlength = (MBoxOpCB_getlength *) cb;
    rc = getlength->rc;

    if (rc == ELIB_COMPLETED)
    {
        Message *const  message = (Message *) _messages.Current ();

        fprintf (_fp, "%d bytes\t", getlength->length);

        Message::Flags flags;

        message->GetFlags(flags);

        if (flags & Message::Read)     fprintf (_fp, "Read\t");
        if (flags & Message::New)      fprintf (_fp, "New\t");
        if (flags & Message::Answered) fprintf (_fp, "Answered");
        if (flags & Message::Delete)   fprintf (_fp, "Delete");

        fprintf (_fp, "\n");

        char  filename[256];

        sprintf (filename, "<MBoxTest$Dir>.headers.%d", _count++);
        MBoxOpCB_gethdrs_file *  gethdrs =
            new MBoxOpCB_gethdrs_file (
                    this,
                    (MBoxCBHandlerMethod) &EnumerateMsgs::gethdrs_cb_handler,
                    filename,
                    rc);

        if (gethdrs)
        {
            if (rc == ELIB_COMPLETED)
            {
                rc = message->GetHeaders (gethdrs);
            }

            if (rc < 0)
            {
                delete gethdrs;
            }
        }
    }
    delete getlength;

    if (rc < 0)
    {
        Callback ();
    }
}


void EnumerateMsgs::gethdrs_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_gethdrs_file *const gethdrs = (MBoxOpCB_gethdrs_file *) cb;
    rc = gethdrs->rc;
    delete gethdrs;

    if (rc == ELIB_COMPLETED)
    {
        _messages.Next ();
        if (get_message () != ELIB_RUNNING)
        {
            Callback ();
        }
    }
}


void  Engine::enumerate_messages (MBoxCB *const  cb)
{
    MBoxOpCB_getnummsgs *const getnummsgs = (MBoxOpCB_getnummsgs *) cb;
    ELib_rcode  rc;

    fprintf (fp, "%d messages\n", getnummsgs->number_messages);
    delete getnummsgs;

    EnumerateMsgs *  enumerate =
        new EnumerateMsgs (this,
                           (MBoxCBHandlerMethod) &Engine::enumerate_cb_handler,
                           *account->GetInbox (),
                           fp,
                           rc);

    if (enumerate)
    {
        if (rc < 0)
        {
            delete enumerate;
        }
    }
    else
    {
        rc = ELIB_EMALLOCFAILED;
    }

    if (rc < 0)
    {
        error (rc);
    }
}

void Engine::enumerate_cb_handler (MBoxCB *const  cb)
{
    EnumerateMsgs *const  enumerate = (EnumerateMsgs *) cb;
    delete enumerate;

    ELib_rcode  rc;

    MBoxOpCB_disconnect *  disconnect =
            new MBoxOpCB_disconnect (
                    this,
                    (MBoxCBHandlerMethod) &Engine::disconnect_cb_handler);

    if (disconnect)
    {
        rc = account->Disconnect (disconnect);
    }
    else
    {
        rc = ELIB_EMALLOCFAILED;
    }

    if (rc < 0)
    {
        error (rc);
    }
}

void Engine::disconnect_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_disconnect *const disconnect = (MBoxOpCB_disconnect *) cb;
    if (disconnect->rc < 0)
    {
        error (disconnect->rc);
    }
    else
    {
        fprintf (fp, "Disconnected\n");
    }
    delete disconnect;

    dec_usage ();
}




void Engine::error (const ELib_rcode  rc)
{
    if (fp)
    {
        fprintf (fp, "Error %d\n", rc);
    }
}



bool Engine::Send ()
{
    bool  success;
    ELib_rcode  rc;

    if (sendq)
    {
        MBoxOpCB_connect *  connect =
            new MBoxOpCB_connect (
                this,
                (MBoxCBHandlerMethod) &Engine::send_connect_cb_handler);

        if (connect)
        {
            rc = sendq->Connect (connect);
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }
    else
    {
        rc = ELIB_EMALLOCFAILED;
    }


    if (rc < 0)
    {
        error (rc);
        success = false;
    }
    else
    {
        inc_usage ();
        success = true;
    }


    return success;
}




class SendMsgs : public MBoxCBHandlerObject, public MBoxCB
{
    public:
        SendMsgs (MBoxCBHandlerObject *  cb_handler,
                  MBoxCBHandlerMethod    cb_fn,
                  ELib_list &            messages,
                  FILE *const            fp,
                  ELib_rcode &           rcode);

    private:
        ELib_rcode  send_message ();
        void        sendmsg_cb_handler (MBoxCB *const  cb);

   public:
       ELib_rcode  rc;

   private:
       ELib_list &  _messages;
       FILE *const  _fp;
};




SendMsgs::SendMsgs (MBoxCBHandlerObject *  cb_handler,
                    MBoxCBHandlerMethod    cb_fn,
                    ELib_list &            messages,
                    FILE *const            fp,
                    ELib_rcode &           rcode)
    : MBoxCB (cb_handler,
              cb_fn,
              0),
      _messages (messages),
      _fp (fp)
{
     _messages.Start ();
     rcode = send_message ();
}




ELib_rcode  SendMsgs::send_message ()
{
    if (_messages.Nul ())
    {
        rc = ELIB_COMPLETED;
        //Callback ();
    }
    else
    {
        MBoxOpCB_sendmsg_file *  sendmsg =
            new MBoxOpCB_sendmsg_file (
                    this,
                    (MBoxCBHandlerMethod) &SendMsgs::sendmsg_cb_handler,
                    rc);

        if (sendmsg)
        {
            if (rc == ELIB_COMPLETED)
            {
                SendQMessage *const  message =
                    (SendQMessage *) _messages.Current ();
                message->SendMessage (sendmsg);
                rc = ELIB_RUNNING;
            }
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    return rc;
}




void SendMsgs::sendmsg_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_sendmsg_file *const sendmsg = (MBoxOpCB_sendmsg_file *) cb;
    rc = sendmsg->rc;

    if (rc == ELIB_COMPLETED)
    {
        fprintf (_fp, "Sent message\n");

    }
    delete sendmsg;

    if (rc == ELIB_COMPLETED)
    {
        _messages.Next ();
        rc = send_message ();
    }

    if (rc != ELIB_RUNNING)
    {
        Callback ();
    }
}



void  Engine::send_connect_cb_handler (MBoxCB *const  cb)
{
    MBoxOpCB_connect *const  connect = (MBoxOpCB_connect *) cb;
    ELib_rcode  rc = connect->rc;

    if (rc == ELIB_COMPLETED)
    {
        fprintf (fp, "Connected to SendQ\n");

        SendQMailbox *  mbox = (SendQMailbox *) sendq->GetInbox ();

        SendMsgs *  send =
            new SendMsgs (this,
                          (MBoxCBHandlerMethod) &Engine::send_cb_handler,
                          mbox->GetMessages (),
                          fp,
                          rc);

        if (send)
        {
            if (rc < 0)
            {
                delete send;
            }
        }
        else
        {
            rc = ELIB_EMALLOCFAILED;
        }
    }

    delete connect;

    if (rc < 0)
    {
        error (rc);
    }
}



void  Engine::send_cb_handler (MBoxCB *const  cb)
{
    SendMsgs *const  send = (SendMsgs *) cb;


    if (send->rc < 0)
    {
        error (send->rc);
    }
    else
    {
        fprintf (fp, "Finished sending\n");
    }

    delete send;

    dec_usage ();
}

