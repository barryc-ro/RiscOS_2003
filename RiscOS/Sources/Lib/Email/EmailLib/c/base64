/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		base64.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.12 for RISC OS

	OVERVIEW
	========
	Source file for implementation of base64 encode and decode.
	Encode and decode FSMs are so similar I should really try and merge them.
	Only the process functions really differ.

	HISTORY
	=======
	21/07/97	0.01	RDW	initial version
	24/07/97	0.02	RDW	time sliced/context saving version
	11/09/97	0.03	RDW	added bytes_written parameter to encode and decode functions
	22/09/97	0.04	RDW	made globals local to file static
	23/09/97	0.05	RDW	fixed bug introduced in 0.03 'cos context struct was
					destroyed before the bytes_written parameter was assigned
					from it
	25/09/97	0.06	RDW	base64decode function changed in state B64D_READ.
					Now scans read in data in input buffer for end of
					valid base64 data.  This is needed for decoding MIME
					multiparts.
	01/10/97	0.07	RDW	0.06 version not quite right!  It finds the end,
					but doesn't retain that fact so we just jump back in
					and read more data!  End found added into context
					struct and checked in WRITEOUT state
	02/10/97	0.08	RDW	changed while loop round FSMs to a do loop so that
					we at least to the FSM once before return.  Also,
					put a !expired() check just before loop start.  This
					should prevent a possible live lock where by the
					time we reached the while check at the start of the loop
					the t_slice was up and we never, ever enter the FSM!
	29/10/97	0.09	RDW	Fixed bug in b64d_process.  Bug was when a BASE64 encoded
					file had two pad characters, '==', then 1 extra byte
					was written out to the decoded file.
	28/11/97	0.10	RDW	B64E_CLEAN_UP, putc changed to fputc
	18/12/97	0.11	RDW	base64encode and base64decode FSMs modified so that
					fwrite and fputc returns are checked for failure.
					If fail, then switch to ERROR state to return errorcode.
	18/02/98	0.12	RDW	#include DebugLib path added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "kernel.h"
#include "DebugLib/DebugLib.h"


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "base64.h"
#include "ELib_priv.h"


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  B64E_INIT,
  B64E_READ,
  B64E_PROCESS,
  B64E_WRITE,
  B64E_CLEAN_UP,
  B64E_ERROR
} b64e_states;									// BASE 64 encoding states

typedef enum
{
  B64D_INIT,
  B64D_READ,
  B64D_PROCESS,
  B64D_WRITE,
  B64D_CLEAN_UP,
  B64D_ERROR
} b64d_states;									// BASE 64 decoding states

typedef struct
{
  NFE_CONTEXT_TYPE type;							// context structure type value
  b64e_states      STATE;							// STATE base64encode FSM is in
  uint32           in_buf_size;							// input buffer size
  uint32           out_buf_size;						// output buffer size
  int32            column;							// output base64 text column position counter
  int32            missing;							// missing counter for end of data reached and it doesn't fill 3 byte buffer
  char            *ch;								// current position in input buffer
  char            *in_buf;							// input buffer, read from input file into buffer
  char            *out_buf;							// output buffer, write out to output file
  char            *o_ch;							// current position in output buffer
  uint32           count;							// counter counting number of bytes processed in input buffer
  uint32           num;								// number of bytes read into input buffer from file
  FILE            *in;								// input file pointer
  FILE            *out;								// output file pointer
  uint32           bwritten;							// no. of bytes written
  NFE_rcode       rc;
} base64encode_context;

typedef struct
{
  NFE_CONTEXT_TYPE type;							// context structure type value
  b64d_states      STATE;							// STATE base64encode FSM is in
  uint32           in_buf_size;							// input buffer size
  uint32           out_buf_size;						// output buffer size
  char            *ch;								// current position in input buffer
  char            *in_buf;							// input buffer, read from input file into buffer
  char            *out_buf;							// output buffer, write out to output file
  char            *o_ch;							// current position in output buffer
  uint32           count;							// counter counting number of bytes processed in input buffer
  uint32           num;								// number of bytes read into input buffer from file
  FILE            *in;								// input file pointer
  FILE            *out;								// output file pointer
  int32            cntr;							// 
  int32            sixbits;							// 
  uint32           chunk;
  uint32           bwritten;							// no. of bytes written
  BOOL		   end;								// is this the last buffer's worth to do?
  NFE_rcode       rc;
} base64decode_context;


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
const static char base64_table[]="ABCDEFGHIJKLMNOP"
                                 "QRSTUVWXYZabcdef"
                                 "ghijklmnopqrstuv"
                                 "wxyz0123456789+/";				// BASE64 conversion table
const static int32 BASE64_MAXWIDTH = 76;						// MAX number of BASE64 characters per line
const static char  BASE64_PAD = '=';							// BASE64 PAD character
const static int32 BASE64_ENCODE_MIN_BUFSIZE = 3;					// Minimum input buffer size for base64 encode
const static int32 BASE64_DECODE_MIN_BUFSIZE = 4;					// Minimum input buffer size for base64 decode
const static int32 BASE64_DECODE_WHITESPACE  = 255;
const static int32 BASE64_DECODE_TERMINATOR  = 254;


/* ************************************************************************** */
/*                                                                            */
/* Private Global variables to this file                                      */
/*                                                                            */
/* ************************************************************************** */
static char base64_decode[256];							// BASE64 decode table


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */
static NFE_rcode b64e_process(base64encode_context *c, clock_t t_slice);	// do the BASE64 encoding
static NFE_rcode b64e_init(base64encode_context* c, uint32 size);		// initialise and setup BASE64 encoding FSM context for first state
static void init_encode_context(base64encode_context *c);			// initialise/zero BASE64 encoding FSM context
static NFE_rcode b64d_process(base64decode_context *c, clock_t t_slice);	// do the BASE64 decoding
static NFE_rcode b64d_init(base64decode_context* c, uint32 size);		// initialise and setup BASE64 decoding FSM context for first state
static void init_decode_context(base64decode_context *c);			// initialise/zero BASE64 decoding FSM context


/* ************************************************************************** */
/*                                                                            */
/* Functions                                                                  */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   FUNCTION:       base64encode
   DESCRIPTION:    Function to base64 encode data from input file into the
   		   output file given a buffer size to use.  Buffer size states
   		   the size of input buffer to use.  Output buffer size is
   		   calculated from this, ensuring it is large enough to hold
   		   the converted data + the extra CRLF bytes at the end of each
   		   line.
   		   Non-blocking in use, it will do one buffer's worth and then
   		   return with code NFE_RUNNING.  In this case it must be
   		   called again with the same parameters until an error code is
   		   returned or NFE_COMPLETED.  Once NFE_COMPLETED is returned
   		   the process is complete.  It will also return by the time
   		   given by t_slice, even if it is in the middle of a buffer.
   DEPENDENCIES:   int32		 BASE64_MAXWIDTH
   		   char			 BASE64_PAD
   		   int32		 BASE64_ENCODE_MINBUF_SIZE
   DEPENDED ON BY: 
   INPUT PARAMS:   NFE_CONTEXT		*context	FSMs current context
   		   const clock_t	 t_slice	time at which function must return
   		   FILE			*in		input file pointer
   		   FILE			*out		output file pointer
   		   uint32		 in_buf_size	size of input buffer to
   		   					use in bytes (best if a multiple of 3)
   OUTPUT PARAMS:  NFE_CONTEXT		*context	FSMs current context
  		   uint32		*bytes_written	if not null on entry, it will be set to the no. of
  		   					bytes written
   RETURN VALUE:   NFE_elib_rcodes	 NFE_COMPLETED
   					 NFE_MALLOCFAILED
   					 NFE_RUNNING
   CONSTANTS:      NONE
   VARIABLES:      See start of code
 */
/* ************************************************************************** */
extern NFE_rcode base64encode(NFE_CONTEXT   *context,
                               const clock_t  t_slice,
                               FILE          *in,
                               FILE          *out,
                               uint32         in_buf_size,
                               uint32        *bytes_written)
{
  NFE_rcode            rc           = NFE_RUNNING;				// default to running operation
  base64encode_context *c            = 0;					// var to typecast context var to for easy access
  
  if (expired(t_slice))								// check we've been given a reasonable amount of time
    rc = NFE_NOTENOUGHTIME;							// if not, return an error
  else if ((context == 0) || (in == 0) || (out == 0))				// check none of the input pointers are NULL
    rc = NFE_NULLADDR;
  else
  {
    c = *((base64encode_context**)context);					// typecast c to context parameter
    if (c == 0)									// this is the start of a new encode as the context is NULL
    {
      c = (base64encode_context*)malloc(sizeof(base64encode_context));		// create context
      *context = (NFE_CONTEXT)c;
      if (!c)									// if malloc failed, then
        rc = NFE_MALLOCFAILED;							// set return code error
      else
        init_encode_context(c);
    }
    else if (c->type != NFE_CT_BASE64ENCODE)					// check context is for this function and not another one
      rc = NFE_INVALIDCONTEXT;							// set INVALIDCONTEXT error if it's not for us
  }
  
  if (expired(t_slice))								// check we've been given a reasonable amount of time
    rc = NFE_NOTENOUGHTIME;							// if not, return an error

  do										// FSM loop until rc != NFE_RUNNING OR expired t_slice
  {
    switch (c->STATE)
    {
      case B64E_INIT:
      {
        dprintf(("", "B64E_INIT\n"));
        c->in = in;								// copy input file ptr into context
        c->out = out;								// copy output file ptr into context
        c->rc = b64e_init(c, in_buf_size);					// initialise and setup context vars.
        if (c->rc < 0)
          c->STATE = B64E_ERROR;						// switch to ERROR state
        else
          c->STATE = B64E_READ;							// switch to READ state
        break;
      }
      case B64E_READ:
      {
        dprintf(("", "B64E_READ\n"));
        c->num = fread(c->in_buf, 1, c->in_buf_size, c->in);			// read in data from input file into input buffer
        c->o_ch = c->out_buf;							// reset o_ch to start of output buffer
        c->ch   = c->in_buf;							// reset ch to start of input buffer
        c->count = 0;
        if (c->num)
          c->STATE = B64E_PROCESS;
        else
          c->STATE = B64E_CLEAN_UP;
        break;
      }
      case B64E_PROCESS:
      {
        dprintf(("", "B64E_PROCESS\n"));
        c->rc = b64e_process(c, t_slice);					// process buffer contents
        if (c->rc == NFE_RUNNING)
          c->STATE = B64E_PROCESS;
        else if (c->rc == NFE_COMPLETED)
          c->STATE = B64E_WRITE;
        else
          c->STATE = B64E_ERROR;
        break;
      }
      case B64E_WRITE:
      {
        size_t bytes_written = 0;

        dprintf(("", "B64E_WRITE\n"));
        bytes_written = fwrite(c->out_buf, 1, (c->o_ch-c->out_buf), c->out);	// write output buffer to file
        c->bwritten += bytes_written;
        if ((uint32)bytes_written < (uint32)(c->o_ch-c->out_buf))
        {
          c->STATE = B64E_ERROR;
          c->rc = NFE_WRITEFAIL;
        }
        else if (ferror(c->in))
          c->STATE = B64E_CLEAN_UP;
        else
          c->STATE = B64E_READ;
        break;
      }
      case B64E_CLEAN_UP:
      {
        dprintf(("", "B64E_CLEAN_UP\n"));
        if (fputc('\r', c->out) == EOF)						// output a CR
        {
          c->rc = NFE_WRITEFAIL;
          c->STATE = B64E_ERROR;
        }
        else
        {
          if (fputc('\n', c->out) == EOF)					// output a LF
          {
            c->rc = NFE_WRITEFAIL;
            c->STATE = B64E_ERROR;
          }
          else
          {            
            free(c->out_buf);							// deallocate output buffer
            free(c->in_buf);							// deallocate input buffer
            if (bytes_written)
              *bytes_written = c->bwritten + 2;					// + 2 from the last CRLF
            free(c);
            c = 0;
            rc = NFE_COMPLETED;
          } // endif fput LF check
        } // endif fputc CR check
        break;
      }
      case B64E_ERROR:
      {
        dprintf(("", "B64E_ERROR\n"));
        rc = c->rc;
        free(c->out_buf);							// deallocate output buffer
        free(c->in_buf);							// deallocate input buffer
        if (bytes_written)
          *bytes_written = c->bwritten;
        free(c);
        c = 0;
        break;
      }
      default:
      {
        rc = NFE_INTERNALERR;
        dprintf(("", "shouldn't get here!\n"));
        break;
      }
    } // endswitch
  } while ((rc == NFE_RUNNING) && (!expired(t_slice)));

  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       base64decode
   DESCRIPTION:    Function to base64 decode data from input file into the
   		   output file given a buffer size to use.  Buffer size states
   		   the size of input buffer to use.  Output buffer size is
   		   calculated from this, ensuring it is large enough to hold
   		   the converted data.
   		   Non-blocking in use, it will do one buffer's worth and then
   		   return with code NFE_RUNNING.  In this case it must be
   		   called again with the same parameters until an error code is
   		   returned or NFE_COMPLETED.  Once NFE_COMPLETED is returned
   		   the process is complete.  It will also return by the time
   		   given by t_slice, even if it is in the middle of a buffer.
   DEPENDENCIES:   char			 BASE64_PAD
   		   int32		 BASE64_DECODE_MINBUF_SIZE
   DEPENDED ON BY: 
   INPUT PARAMS:   NFE_CONTEXT		*context	FSMs current context
   		   const clock_t	 t_slice	time at which function must return
   		   FILE			*in		input file pointer
   		   FILE			*out		output file pointer
   		   uint32		 in_buf_size	size of input buffer to
   		   					use in bytes (best if a multiple of 4)
   		   BOOL			 start		start of new encode or not
   OUTPUT PARAMS:  NFE_CONTEXT		*context	FSMs current context
  		   uint32		*bytes_written	if not null on entry, it will be set to the no. of
     		   					bytes written
   RETURN VALUE:   NFE_elib_rcodes	 NFE_COMPLETED
   					 NFE_MALLOCFAILED
   					 NFE_RUNNING
   CONSTANTS:      NONE
   VARIABLES:      See start of code
 */
/* ************************************************************************** */
extern NFE_rcode base64decode(NFE_CONTEXT   *context,
                               const clock_t  t_slice,
                               FILE          *in,
                               FILE          *out,
                               uint32         in_buf_size,
                               uint32        *bytes_written)
{
  NFE_rcode            rc           = NFE_RUNNING;				// default to running operation
  base64decode_context *c            = 0;					// var to typecast context var to for easy access
  
  if (expired(t_slice))								// check we've been given a reasonable amount of time
    rc = NFE_NOTENOUGHTIME;							// if not, return an error
  else if ((context == 0) || (in == 0) || (out == 0))				// check none of the input pointers are NULL
    rc = NFE_NULLADDR;
  else
  {
    c = *((base64decode_context**)context);					// typecast c to context parameter
    if (c == 0)									// this is the start of a new encode as the context is NULL
    {
      c = (base64decode_context*)malloc(sizeof(base64decode_context));		// create context
      *context = (NFE_CONTEXT)c;
      if (!c)									// if malloc failed, then
        rc = NFE_MALLOCFAILED;							// set return code error
      else
        init_decode_context(c);
    }
    else if (c->type != NFE_CT_BASE64DECODE)					// check context is for this function and not another one
      rc = NFE_INVALIDCONTEXT;							// set INVALIDCONTEXT error if it's not for us
  }
  
  if (expired(t_slice))								// check we've been given a reasonable amount of time
    rc = NFE_NOTENOUGHTIME;							// if not, return an error

  do										// FSM loop until rc != NFE_RUNNING OR expired t_slice
  {
    switch (c->STATE)
    {
      case B64D_INIT:
      {
        dprintf(("", "B64D_INIT\n"));
        c->in = in;								// copy input file ptr into context
        c->out = out;								// copy output file ptr into context
        c->rc = b64d_init(c, in_buf_size);					// initialise and setup context vars.
        if (c->rc < 0)
          c->STATE = B64D_ERROR;						// switch to ERROR state
        else
          c->STATE = B64D_READ;							// switch to READ state
        break;
      }
      case B64D_READ:
      {
        dprintf(("", "B64D_READ\n"));
        c->num = fread(c->in_buf, 1, c->in_buf_size, c->in);			// read in data from input file into input buffer
        if (c->num > 0)								// check we read something in, then
        {
          // scan for end of b64 data
          // if a '=', that is the end
          // if a char not in base64_table and not a CR or an LF, that is the end
          char *ptr = c->in_buf;						// goto start of buffer
          BOOL found = FALSE;							// set found end of base64 data to FALSE
          while ((!found) && (ptr < (c->in_buf+c->num)))			// while not found end of data and not at end of buffer, do
          {
            if (*ptr == '=')							// '=' is valid pad char at end of BASE64 data
            {
              while ((*ptr == '=') && (ptr < (c->in_buf+c->num)))		// skip all the '=' chars
                ptr++;	
              found = TRUE;							// set found to TRUE
            }
            else if ((*ptr != '\r') &&						// else check if char is not a valid BASE64 char or CR or LF, then
                     (*ptr != '\n') &&
                     (*ptr != '+')  &&
                     ((*ptr < 47) || ((*ptr > 57) && (*ptr < 65)) || ((*ptr > 90) && (*ptr <97)) || (*ptr > 122))
                    )
            {
              found = TRUE;							// found = TRUE
            }
            else
              ptr++;
          }
          if (found)								// if we found the end of the base64 data, then
          {
            c->num = ptr - c->in_buf;						// reset the number of bytes read in to be upto the end of the data
            c->end = TRUE;
          }
        }
        c->bwritten += c->num;
        c->o_ch = c->out_buf;							// reset o_ch to start of output buffer
        c->ch   = c->in_buf;							// reset ch to start of input buffer
        c->count = 0;
        if (c->num)
          c->STATE = B64D_PROCESS;
        else
          c->STATE = B64D_CLEAN_UP;
        break;
      }
      case B64D_PROCESS:
      {
        dprintf(("", "B64D_PROCESS\n"));
        c->rc = b64d_process(c, t_slice);					// process buffer contents
        if (c->rc == NFE_RUNNING)
          c->STATE = B64D_PROCESS;
        else if (c->rc == NFE_COMPLETED)
          c->STATE = B64D_WRITE;
        else
          c->STATE = B64D_ERROR;
        break;
      }
      case B64D_WRITE:
      {
        size_t bytes_written = 0;

        dprintf(("", "B64D_WRITE\n"));
        bytes_written = fwrite(c->out_buf, 1, (c->o_ch-c->out_buf), c->out);			// write output buffer to file
        c->bwritten += bytes_written;
        if (bytes_written < (c->o_ch-c->out_buf))
        {
          c->STATE = B64D_ERROR;
          c->rc = NFE_WRITEFAIL;
        }
        else  if ((ferror(c->in)) || (c->end))
          c->STATE = B64D_CLEAN_UP;
        else
          c->STATE = B64D_READ;
        break;
      }
      case B64D_CLEAN_UP:
      {
        dprintf(("", "B64D_CLEAN_UP\n"));
        free(c->out_buf);							// deallocate output buffer
        free(c->in_buf);							// deallocate input buffer
        if (bytes_written)
          *bytes_written = c->bwritten;
        free(c);
        c = 0;
        rc = NFE_COMPLETED;
        break;
      }
      case B64D_ERROR:
      {
        dprintf(("", "B64D_ERROR\n"));
        rc = c->rc;
        free(c->out_buf);							// deallocate output buffer
        free(c->in_buf);							// deallocate input buffer
        if (bytes_written)
          *bytes_written = c->bwritten;
        free(c);
        c = 0;
        break;
      }
      default:
      {
        rc = NFE_INTERNALERR;
        dprintf(("", "shouldn't get here!\n"));
        break;
      }
    } // endswitch
  } while ((rc == 0) && (!expired(t_slice)));

  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       init_encode_context
   DESCRIPTION:    Function to initialise/zero the BASE64 encode context structure
   		   to 0 values ready for use.
   DEPENDENCIES:   type			base64encode_context	base64.c
   DEPENDED ON BY: function		base64encode	base64.c
   INPUT PARAMS:   base64encode_context	*c		context to zero
   OUTPUT PARAMS:  base64encode_context	*c		context zeroed
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
static void init_encode_context(base64encode_context *c)
{
  if (c)
  {
    c->type         = NFE_CT_BASE64ENCODE;
    c->STATE        = B64E_INIT;
    c->in_buf_size  = 0;
    c->out_buf_size = 0;
    c->column       = 0;
    c->missing      = 0;
    c->ch           = 0;
    c->in_buf       = 0;
    c->out_buf      = 0;
    c->o_ch         = 0;
    c->count        = 0;
    c->num          = 0;
    c->in           = 0;
    c->out          = 0;
    c->bwritten     = 0;
    c->rc           = NFE_RUNNING;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       init_decode_context
   DESCRIPTION:    Function to initialise/zero the BASE64 decode context structure
   		   to 0 values ready for use.
   DEPENDENCIES:   type			base64decode_context	base64.c
   DEPENDED ON BY: function		base64decode	base64.c
   INPUT PARAMS:   base64decode_context	*c		context to zero
   OUTPUT PARAMS:  base64decode_context	*c		context zeroed
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
static void init_decode_context(base64decode_context *c)
{
  if (c)
  {
    c->type         = NFE_CT_BASE64DECODE;
    c->STATE        = B64D_INIT;
    c->in_buf_size  = 0;
    c->out_buf_size = 0;
    c->ch           = 0;
    c->in_buf       = 0;
    c->out_buf      = 0;
    c->o_ch         = 0;
    c->count        = 0;
    c->num          = 0;
    c->in           = 0;
    c->out          = 0;
    c->cntr         = 0;
    c->sixbits      = 0;
    c->chunk        = 0;							// 
    c->bwritten     = 0;
    c->end          = FALSE;
    c->rc           = NFE_RUNNING;
  }
}


/* ************************************************************************** */
/*
   FUNCTION:       b64e_init
   DESCRIPTION:    Function to do memory alloc. and setup encode context ready
   		   to start FSM in the initial state
   DEPENDENCIES:   type			base64encode_context	base64.c
   		   type			uint32			ELib.h
   DEPENDED ON BY: function		base64encode	base64.c
   INPUT PARAMS:   base64encode_context	*c		context to setup
   OUTPUT PARAMS:  base64encode_context	*c		context setup
   RETURN VALUE:   NFE_rcode				return code
   CONSTANTS:      NONE
   VARIABLES:      NFE_rcode		 rc		the return code
 */
/* ************************************************************************** */
static NFE_rcode b64e_init(base64encode_context* c, uint32 size)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (c)
  {
    c->in_buf_size = (size / 3) * 3;						// round in_buf_size so that it is divisable by 3
            
    if (c->in_buf_size < BASE64_ENCODE_MIN_BUFSIZE)
      c->in_buf_size = BASE64_ENCODE_MIN_BUFSIZE;				// make sure we are told to use a buffer of a least 3 bytes in size
            
    c->out_buf_size = ((c->in_buf_size/3)*4) + (c->in_buf_size/(BASE64_MAXWIDTH))*2 + 1024;// calculate size of output buffer based on size on input buffer
    c->in_buf       = (char*)malloc(c->in_buf_size);				// allocate space for input buffer
          
    if (c->in_buf)								// if allocate successful for input buffer, then
    {
      c->out_buf      = (char*)malloc(c->out_buf_size);				// allocate space for output buffer
      if (!c->out_buf)								// if allocate for output buffer failed, then
      {
        free(c->in_buf);							// free input buffer
        c->in_buf = 0;
        rc = NFE_MALLOCFAILED;							// set returncode to MALLOC FAILED
      }
    }
    else									// else, alloc for input buffer failed, so
      rc = NFE_MALLOCFAILED;							// set returncode to MALLOCFAILED	
  }
  else										// context param is NULL
    rc = NFE_NULLADDR;								// so set NULL ADDR error

  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       b64d_init
   DESCRIPTION:    Function to do memory alloc. and setup decode context ready
   		   to start FSM in the initial state
   DEPENDENCIES:   type			base64decode_context	base64.c
   		   type			uint32			ELib.h
   DEPENDED ON BY: function		base64encode	base64.c
   INPUT PARAMS:   base64decode_context	*c		context to setup
   OUTPUT PARAMS:  base64decode_context	*c		context setup
   RETURN VALUE:   NFE_rcode				return code
   CONSTANTS:      NONE
   VARIABLES:      NFE_rcode		 rc		the return code
 */
/* ************************************************************************** */
static NFE_rcode b64d_init(base64decode_context* c, uint32 size)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (c)
  {
    c->in_buf_size = (size / 4) * 4;						// round in_buf_size so that it is divisable by 4
            
    if (c->in_buf_size < BASE64_DECODE_MIN_BUFSIZE)
      c->in_buf_size = BASE64_DECODE_MIN_BUFSIZE;				// make sure we are told to use a buffer of a least 4 bytes in size
            
    c->out_buf_size = ((c->in_buf_size/4)*3);					// calculate size of output buffer based on size on input buffer
    c->in_buf       = (char*)malloc(c->in_buf_size);				// allocate space for input buffer
          
    if (c->in_buf)								// if allocate successful for input buffer, then
    {
      c->out_buf      = (char*)malloc(c->out_buf_size);				// allocate space for output buffer
      if (!c->out_buf)								// if allocate for output buffer failed, then
      {
        free(c->in_buf);							// free input buffer
        c->in_buf = 0;
        rc = NFE_MALLOCFAILED;							// set returncode to MALLOC FAILED
      }
    }
    else									// else, alloc for input buffer failed, so
      rc = NFE_MALLOCFAILED;							// set returncode to MALLOCFAILED	
  }
  else										// context param is NULL
    rc = NFE_NULLADDR;								// so set NULL ADDR error

  if (rc == NFE_COMPLETED)							// if no error has occured, then
  {
    int32 indx;									// index counter for creating base64_decode table

    for (indx=0; indx<256; indx++)						// clear the decode table
      base64_decode[indx] = BASE64_DECODE_WHITESPACE;
    for (indx=0; indx<64; indx++)						// populate the decode table with the characters
      base64_decode[base64_table[indx]] = indx;
    base64_decode[' ']  = BASE64_DECODE_WHITESPACE;				// add space to the table
    base64_decode['\n'] = BASE64_DECODE_WHITESPACE;
    base64_decode['\r'] = BASE64_DECODE_WHITESPACE;
    base64_decode['\t'] = BASE64_DECODE_WHITESPACE;
    base64_decode['=']  = BASE64_DECODE_TERMINATOR;
  }
  
  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       b64e_process
   DESCRIPTION:    Function to base64 encode data from input file into the
   		   output file.  This is the function that does the BASE64
   		   encode work for the BASE64 encode FSM.
   		   Non-blocking in use, it will do one buffer's worth and then
   		   return with code NFE_RUNNING.  In this case it must be
   		   called again with the same parameters until an error code is
   		   returned or NFE_COMPLETED.  Once NFE_COMPLETED is returned
   		   the process is complete.  It will also return by the time
   		   given by t_slice, even if it is in the middle of a buffer.
   DEPENDENCIES:   int32		 BASE64_MAXWIDTH
   		   char			 BASE64_PAD
   		   int32		 BASE64_ENCODE_MINBUF_SIZE
   DEPENDED ON BY: function		 base64encode	base64.c
   INPUT PARAMS:   base64decode_context *c		process context
   		   clock_t		 t_slice	time to return by
   OUTPUT PARAMS:  base64decode_context *c		process context
   RETURN VALUE:   NFE_elib_rcodes	 NFE_COMPLETED
   					 NFE_MALLOCFAILED
   					 NFE_RUNNING
   CONSTANTS:      NONE
   VARIABLES:      See start of code
 */
/* ************************************************************************** */
static NFE_rcode b64e_process(base64encode_context *c, 
                               clock_t               t_slice)
{
  NFE_rcode rc    = NFE_RUNNING;
  int32      i     = 0;								// for loop counter to read in 3 bytes of data
  uint32     chunk = 0;								// chunk holds the 3 bytes of data
  
  if (c)									// check we have got a context
  {
    BOOL timedout = FALSE;
    while ((c->count < c->num) && (c->ch < c->in_buf+c->in_buf_size) && (!timedout))	// while still more data to process from input buffer and not out of time, do
    {
      c->rc = NFE_RUNNING;							// set return code to RUNNING
      chunk = 0;								// clear chunk
      
      for (i=0; i<3; i++)							// read in 3 bytes of data
      {
        chunk = (chunk << 8);							// make room for a new byte by shifting contents of chunk 8bits to left
        if (c->count < c->num)							// if not the send of the input file then
          chunk = chunk | *c->ch;						// OR chunk contents with new byte in ch
        else
          c->missing++;								// increment the missing byte count for this block of 3bytes
        c->ch++;								// get next byte of data
        c->count++;
      } // endfor
      
      *c->o_ch = base64_table[(chunk >> 18) & 0x3f];				// Output 1st character of the 4 base64 characters  
      c->o_ch++;
      *c->o_ch = base64_table[(chunk >> 12) & 0x3f];				// Output 2nd character of the 4 base64 characters
      c->o_ch++;
      
      if (c->missing < 2)							// If there is 1 or 0 missing bytes out of the block of 3 then
      {
        *c->o_ch = base64_table[(chunk >> 6) & 0x3f];				// Output 3rd character of the 4 base64 characters
        c->o_ch++;
        if (c->missing < 1)							// If there is NO missing bytes then
        {
          *c->o_ch = base64_table[chunk & 0x3f];				// Output 4th character of the 4 base64 characters
          c->o_ch++;
        }
        else
        {
          *c->o_ch = BASE64_PAD;						// 4th character is missing, so pad with =
          c->o_ch++;
        }
      }
      else									// Else, must be more 2 missing bytes so
      {
        *c->o_ch = BASE64_PAD;							// 3rd character is missing, so output pad
        c->o_ch++;
        *c->o_ch = BASE64_PAD;							// 4th character is missing, so output pad
        c->o_ch++;
      }
      
      c->column += 4;								// increment column count by 4 characters
      if (c->column >= BASE64_MAXWIDTH)						// if we've reached the width limit then
      {
        *c->o_ch = '\r';							// output a CR
        c->o_ch++;
        *c->o_ch = '\n';							// output a NL
        c->o_ch++;
        c->column = 0;								// reset column to zero
      } // endif column check
      timedout = expired(t_slice);
    } // endwhile
    if ((c->count < c->num) && (c->ch < c->in_buf+c->in_buf_size))
      rc = NFE_RUNNING;
    else
      rc = NFE_COMPLETED;
  }
  else										// else, context was NULL
    rc = NFE_NULLADDR;								// return NULLADDR error
    
  return rc;
}


/* ************************************************************************** */
/*
   FUNCTION:       b64d_process
   DESCRIPTION:    Function to base64 decode data from input file into the
   		   output file.   This is the function that does the BASE64
   		   encode work for the BASE64 decode FSM.
   		   Non-blocking in use, it will do one buffer's worth and then
   		   return with code NFE_RUNNING.  In this case it must be
   		   called again with the same parameters until an error code is
   		   returned or NFE_COMPLETED.  Once NFE_COMPLETED is returned
   		   the process is complete.  It will also return by the time
   		   given by t_slice, even if it is in the middle of a buffer.
   DEPENDENCIES:   char			 BASE64_PAD
   		   int32		 BASE64_DECODE_MINBUF_SIZE
   DEPENDED ON BY: function		 base64decode	base64.c
   INPUT PARAMS:   base64decode_context *c		process context
   		   clock_t		 t_slice	time to return by
   OUTPUT PARAMS:  base64decode_context *c		process context
   RETURN VALUE:   NFE_elib_rcodes	 NFE_COMPLETED
   					 NFE_MALLOCFAILED
   					 NFE_RUNNING
   CONSTANTS:      NONE
   VARIABLES:      See start of code
 */
/* ************************************************************************** */
static NFE_rcode b64d_process(base64decode_context *c,
                               clock_t               t_slice)
{
  NFE_rcode rc = NFE_RUNNING;
  
  if (c)									// check we have got a context
  {
    BOOL timedout = FALSE;
    while ((c->count < c->num) && (c->ch < c->in_buf+c->in_buf_size) && (!timedout))	// while still more data to process from input buffer, do
    {
      rc = NFE_RUNNING;								// set return code to RUNNING
      c->sixbits = base64_decode[*(c->ch)];					// get sixbits of data for this byte
      if (c->sixbits != BASE64_DECODE_WHITESPACE)				// if this data is not a whitespace character, then
      {
        if (*(c->ch) == BASE64_PAD)						// if this input character is a BASE64 pad char '=', then
        {
          c->sixbits = 0;							// clear sixbits of data
          
          switch (c->cntr)							// case number of number of bytes read, do
          {
            case 3:								// output the two bytes of data
            {
              *c->o_ch = (c->chunk >> 10) & 0xFF;
              c->o_ch++;
              *c->o_ch = (c->chunk >> 2) & 0xFF;
              c->o_ch++;
              break;
            }
            case 2:								// output the one byte of data
            {
              *c->o_ch = (c->chunk >> 4) & 0xFF;
              c->o_ch++;
              c->count++;			// move passed next '='		// increment the counter the counts the number of input bytes processed
              break;
            }
            default:
            {
              rc = NFE_INTERNALERR;						// This should never happen, but cover ourselves
              break;
            }
          } // endswitch
          c->count++;								// increment the counter the counts the number of input bytes processed
          timedout = expired(t_slice);
          break; // break out of while loop
        }
        else									// else this is not a PAD character, so
        {
          c->chunk = (c->chunk << 6) | c->sixbits;				// copy those sixbits into the chunk
          c->cntr++;								// increment the counter of sixbits MOVED
        
          if (c->cntr >= 4)							// if we've read in 4 lots of sixbits, then
          {
            *c->o_ch = (c->chunk >> 16) & 0xff;					// write them out as 3 bytes
            c->o_ch++;
            *c->o_ch = (c->chunk >> 8) & 0xff;
            c->o_ch++;
            *c->o_ch = c->chunk & 0xff;
            c->o_ch++;
            c->cntr = 0;							// reset sixbit counter
          } // endif
        } // endif BASE64_PAD check
      } // endif WHITESPACE check
      c->ch++;									// move ch to the next character in the input buffer
      c->count++;								// increment the counter the counts the number of input bytes processed
      timedout = expired(t_slice);
    } // endwhile
    if ((c->count < c->num) && (c->ch < c->in_buf+c->in_buf_size))
      rc = NFE_RUNNING;
    else
      rc = NFE_COMPLETED;
  }
  else										// else, context was NULL
    rc = NFE_NULLADDR;								// return NULLADDR error
    
  return rc;
}


