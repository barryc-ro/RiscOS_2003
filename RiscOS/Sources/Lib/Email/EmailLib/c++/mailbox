/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		mailbox.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.02 for RISC OS

	OVERVIEW
	========
	Source file for implementation of mailbox object.  mailbox is the
	mailbox token in rfc822.  Currently, this mailbox implementation is
	not fully rfc822 compliant, in that the optional route part of the
	route-addr rule is not supported.

	HISTORY
	=======
	28/09/98	0.01	RDW	initial version
	01/10/98	0.02	RDW	WriteOut methods implemented
					UpdateBody method added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include mailbox files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include mailbox files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "mailbox.h"
#include "header.h"
#include "822parser.h"
extern "C"
{
  #include "ELib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a mailbox object (memory based)
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
mailbox::mailbox(bool f, char *membase, uint32 offset, uint32 length, bool owner)
        :elibbase(f, membase, offset, length, owner),
         realname_start(0),
         realname_end(0),
         address_start(0),
         address_end(0),
         allocated_realname(false),
         allocated_address(false),
         parsed(false)
{
  if ((owner) && (length==0))
  {
    parsed = true;
  }
}


// copy constructor
mailbox::mailbox(const mailbox &object)
        :elibbase(object),
         realname_start(0),
         realname_end(0),
         address_start(0),
         address_end(0),
         allocated_realname(false),
         allocated_address(false),
         parsed(false)
{
  copymailboxobject(object);
}


void mailbox::copymailboxobject(const mailbox &object)
{
  if ((object.realname_start) && (object.realname_end))
  {
    realname_start = new char[(object.realname_end - object.realname_start) + 1];
    memcpy(realname_start, object.realname_start, (object.realname_end - object.realname_start));
    realname_end = realname_start + (object.realname_end - object.realname_start);
    allocated_realname = true;
  }
  if (object.address_start)
  {
    address_start = new char[(object.address_end - object.address_start) + 1];
    memcpy(address_start, object.address_start, (object.address_end - object.address_start));
    address_end = address_start + (object.address_end - object.address_start);
    allocated_address = true;
  }
  parsed = object.parsed;
}


// Implementation of destructor for mailbox
mailbox::~mailbox()
{
  if ((allocated_realname) && (realname_start))
    delete[] realname_start;
  if ((allocated_address) && (address_start))
    delete[] address_start;
}


ELib_rcode mailbox::parse(ELIB_CONTEXT &context, clock_t t_slice)
{
  ELib_rcode rc    = ELIB_COMPLETED;
  bool      error = false;

  uint32 size = len;
  char *ptr = mem_base+start;							// HORRIBLE HACK which relies on from class always holding data in memory

  error = consume_all_LWSP(ptr, size);
  char *start = ptr;
  while ( (*ptr != '<') && (*ptr != '@') && (size))				// search for < or @.
  {
    ptr++;
    size--;
  }
  if (size)									// if not off end of the data
  {
    if (*ptr == '<')								// if <, then we've found the start of the address
    {
      address_start = ptr+1;							// set address start as 1st char after <
      while ( (*ptr != '>') && (size))						// search until > found (end of address)
      {
        ptr++;
        size--;
      }
      len = (ptr+1) - (mem_base+elibbase::start);				// set len in case where address is enclosed by <>
      address_end = ptr;							// set address end
      realname_start = start;							// set realname at start
      realname_end = address_start - 2;						// set realname end at
      ptr = realname_end;
      while ( ((*ptr == 32) || (*ptr == '\t')) && (ptr != realname_start))	// go backwards until not a LWSP found
        ptr--;
      if (ptr != realname_start)						// if we've not gone back to the start, then
        realname_end = ptr + 1;							// adjust realname end
      else
        realname_end = 0;
    }
    else if (*ptr == '@')							// if found @, then we're in the middle of the address
    {
//      address_start = start;							// set address start as the start
      char *ptr2 = ptr;
      while ( (*ptr2 != 32) && (*ptr2 != '\t') && (*ptr2 != ',') && (ptr2 != start))	// search through string until we drop off the start of the address
      {
        ptr2--;
      }
      address_start = ptr2;							// set address start
      if (address_start != start)						// if we're not at the start of the string, there must be a realname
      {										// in front, in which case to be in this block (ie. *ptr == '@') the
        rc = ELIB_BADADDR;							// <> brackets are missing
        address_start += 1;
      }
      while ( (*ptr != 32) && (*ptr != '\t') && (*ptr != ',') && (size))	// search through string until we drop off the end of the address
      {
        ptr++;
        size--;
      }
      address_end = ptr;							// set address end
      len = ptr - (mem_base+elibbase::start);					// set len in case where address isn't enclosed by <>
    }
    parsed = true;
  }
  else
    error = true;

  return rc;
}


void mailbox::Display(void)
{
  if ((realname_end) && (realname_start))
  {
    char* realname = new char[(realname_end - realname_start)+1];
    memcpy(realname, realname_start, (realname_end - realname_start));
    realname[(realname_end - realname_start)] = '\0';
    if (realname)
    {
      printf("REAL NAME: %sEND\n", realname);
      delete[] realname;
    }
    else
      printf("MALLOC FAILED\n");
  }

  if (address_start)
  {
    char* address = new char[(address_end - address_start)+1];
    memcpy(address, address_start, (address_end - address_start));
    address[(address_end - address_start)] = '\0';
    if (address)
    {
      printf("ADDRESS:   %sEND\n", address);
      delete[] address;
    }
    else
      printf("MALLOC FAILED\n");
  }
  printf("\n");
}


ELib_rcode mailbox::SetRealName(char *n)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (n)
  {
    if ((allocated_realname) && (realname_start) && (realname_end))
      delete[] realname_start;
    realname_start = new char[strlen(n)+1];
    if (realname_start)
    {
      strcpy(realname_start, n);
      realname_end = realname_start + strlen(realname_start);
      allocated_realname = true;
    }
    else
      rc = ELIB_EMALLOCFAILED;
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}


ELib_rcode mailbox::SetAddress(char *n)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (n)
  {
    if ((allocated_address) && (address_start))
      delete[] address_start;
    address_start = new char[strlen(n)+1];
    if (address_start)
    {
      strcpy(address_start, n);
      address_end = address_start + strlen(address_start);
      allocated_address = true;
    }
    else
      rc = ELIB_EMALLOCFAILED;
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}


ELib_rcode mailbox::GetData(char* start, char* end, char *data, uint32 &size) const
{
  ELib_rcode rc = ELIB_COMPLETED;

  if ((end) && (start))								// Check the requested data exists
  {
    if (data == 0)								// If we've not been given a block of memory
    {
      if (size == 0)								// are we to allocate some, if size == 0, then no
      {
        size = (end - start) + 1;						// so return the size required
        rc = ELIB_ENULLADDR;
      }
      else									// else, allocate the required amount of space
      {
        size = (end - start) + 1;
        data = new char[size];
        if (data == 0)
          rc = ELIB_EMALLOCFAILED;
      }
    }

    if (data)									// if memory allocated, then
    {
      if (size >= (end - start)+1)						// is it big enough?  if so then
      {
        memcpy(data, start, (end - start));					// copy the data
        data[(end - start)] = '\0';
      }
      else									// else return nospace error
        rc = ELIB_ENOSPACE;
    }
  }
  else										// else, requested data wasn't present
    rc = ELIB_ENODATAPRESENT;

  return rc;
}


ELib_rcode mailbox::GetRealName(char*& n, uint32 &size) const
{
  return GetData(realname_start, realname_end, n, size);
}


ELib_rcode mailbox::GetAddress(char*& n, uint32 &size) const
{
  return GetData(address_start, address_end, n, size);
}


// function to write out the object to file
ELib_rcode mailbox::UpdateBody(void)
{
  ELib_rcode rc = ELIB_COMPLETED;

  uint32 realname_len = realname_end - realname_start;
  uint32 address_len  = address_end  - address_start;
  bool realname_present = false;
  uint32 size = 0;

  if ((realname_end) && (realname_start))
    realname_present = true;

  if ((address_end == 0) || (address_start == 0))
    rc = ELIB_ENODATAPRESENT;

  if (rc == ELIB_COMPLETED)
  {
    char* temp_string = new char[realname_len + address_len + 4];
    if (temp_string)
    {
      if (realname_present)
      {
        memcpy(temp_string, realname_start, realname_len);
        memcpy(temp_string+realname_len, " <", 2);
        size = realname_len + 2;
      }
      memcpy(temp_string+size, address_start, address_len);
      size += address_len;
      if (realname_present)
      {
        memcpy(temp_string+realname_len+2+address_len, ">", 1);
        size += 1;
      }
      temp_string[size] = '\0';
      if ((mem_base) && (ownership))
        delete[] mem_base;
      mem_base = temp_string;
      ownership = true;
      start = 0;
      len = size;
      parsed = true;
    }
    else
      rc = ELIB_EMALLOCFAILED;
  }

  return rc;
}


// function to write out the object to file
ELib_rcode mailbox::WriteOut(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (f)
  {
    rc = UpdateBody();
    if (rc >= ELIB_COMPLETED)
      rc = super::WriteOut(context, t_slice, f);
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}


// function to write out the object to memory
ELib_rcode mailbox::WriteOut(ELIB_CONTEXT &context, clock_t t_slice, char *mem, uint32 &l)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (mem)
  {
    rc = UpdateBody();
    if (rc >= ELIB_COMPLETED)
      rc = super::WriteOut(context, t_slice, mem, l);
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}


