/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1998. All Rights Reserved.

	FILE:		MIMEmessage.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.01D for RISC OS

	OVERVIEW
	========
	Source file for implementation of MIMEmessage object

	HISTORY
	=======
	16/07/98	0.01D	RDW	initial version
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "MIMEmsg.h"
#include "bodyrfc822.h"
extern "C"
{
  #include "ELib.h"
  #include "Elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a MIMEmessage object
   DESCRIPTION:    Construct a memory version of a MIMEmessage object.  Construct
   		   the MIMEentity object we inherit (also MEMORY version) and
   		   setup our data members (message_type)
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   bool			f		file(true), MEMORY(false)
   		   char*		membase		start of memory block
   		   uint32		offset		no. of chars. from membase to start of MIMEmessage
   		   uint32		length		length of MIMEmessage in chars
   		   NFE_CT_MESSAGE_TYPE	t		image type (eg. TIFF)
   		   bool			owner		object owns memory block?
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage::MIMEmessage(bool               f,
                         char              *membase,
                         uint32             offset,
                         uint32             length,
                         NFE_CT_MESSAGE_TYPE  t,
                         bool               owner)
            :MIMEentity(f, membase, offset, length, owner),
             message_type(t),
             parsed(false)
{
  if ((owner) && (length == 0))		// then this is a MIMEmessage to be created from scratch
  {
    switch(t)
    {
      case NFE_CT_MESSAGE_RFC822:
        SetContentType("message/rfc822", NFE_CT_MESSAGE ,NFE_CT_MESSAGE_RFC822);
        break;
      default:
        // ARGH!! NOTHING WE CAN DO, this is the constructor
        break;
    } // endswitch
    parsed = true;
  }
}


/* ************************************************************************** */
/*
   METHOD:         Copy Constructor for a MIMEmessage object
   DESCRIPTION:    Construct a MIMEmessage object from another MIMEmessage object.
   		   Construct the MIMEentity object we inherit and
   		   setup our data members from the given object to copy from
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   const MIMEmessage&	object		object to copy from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage::MIMEmessage(const MIMEmessage &object) : MIMEentity(object)
{
  copyMIMEmessageobject(object);
}


/* ************************************************************************** */
/*
   METHOD:         Copy Constructor for a MIMEmessage object
   DESCRIPTION:    Construct a MIMEmessage object from a MIMEentity object.
   		   Construct the MIMEentity object we inherit and
   		   setup our data members to their init. states
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   const MIMEentity&	object		object to copy from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage::MIMEmessage(const MIMEentity &object) : MIMEentity(object)
{
  message_type = NFE_CT_MESSAGE_UNKNOWN;
  parsed = false;
}



/* ************************************************************************** */
/*
   METHOD:         Assignment operator
   DESCRIPTION:    set this MIMEmessage object to be the same as the given MIMEentity
   		   object.  First all the MIMEentity assignment, do any destruction
   		   needed (NONE in this object) and then initialise the MIMEmessage
   		   data members as the given MIMEentity won't have any to copy!
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   const MIMEmessage&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   MIMEmessage&				reference to this object
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage& MIMEmessage::operator=(const MIMEentity &object)
{
  MIMEentity::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    message_type = NFE_CT_MESSAGE_UNKNOWN;
    parsed = false;
  }
  return *this;
}


/* ************************************************************************** */
/*
   METHOD:         Assignment operator
   DESCRIPTION:    set this MIMEmessage object to be the same as the given MIMEmessage
   		   object.  First all the MIMEentity assignment, do any destruction
   		   needed (NONE in this object), then copy the MIMEmessage data members
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   const MIMEmessage&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   MIMEmessage&				reference to this object
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage& MIMEmessage::operator=(const MIMEmessage &object)
{
  MIMEentity::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyMIMEmessageobject(object);
  }
  return *this;
}


/* ************************************************************************** */
/*
   METHOD:         copyMIMEmessageobject
   DESCRIPTION:    Copy the data members from the given MIMEmessage object into
   		   this MIMEmessage object.
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   const MIMEmessage&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
void MIMEmessage::copyMIMEmessageobject(const MIMEmessage &object)
{
  // nothing to do, should get rid of this and the copy constructors and leave
  // the default copy constructors, etc.
  message_type = object.message_type;
  parsed = object.parsed;
}


/* ************************************************************************** */
/*
   METHOD:         Destructor
   DESCRIPTION:    Nothing to do as MIMEentity has no dyanmic data members.
   		   Could just remove the destructor and leave it to the
   		   default one.
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEmessage::~MIMEmessage()
{
  // nothing to do
}


/* ************************************************************************** */
/*
   METHOD:         parse
   DESCRIPTION:    Private method which is called by ParseData method from
   		   elibbase base class.  function should parse the data that
   		   the MIMEmessage object has in order to setup the MIMEmessage
   		   data members.  In this case to get the image type
   DEPENDENCIES:   class		MIMEentity
   DEPENDED ON BY:
   INPUT PARAMS:   NFE_CONTEXT&		context
   		   clock_t		t_slice
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_rcode		rc		result of function
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
NFE_rcode MIMEmessage::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;						// Assume success
  bool      error = false;							// No error has occured yet

  if (!MIMEentity::Parsed())							// Check that at the generic MIMEentity level of this object, it has been parsed,
    rc = MIMEentity::parse(context, t_slice);					// parse it if it's not been done

  // check for ContentType present and is message/* where * is something we understand
  if (rc == NFE_COMPLETED)							// if all is well so far, then
  {
    NFE_CT ct;									// ContentType of this object
    rc = GetMajorType(ct);							// Get the ContentType
    if ((rc == NFE_COMPLETED) && (ct == NFE_CT_MESSAGE))			// If we are a MIME message, then
    {
      uint32 len = GetContentTypeLen();						// Get the length of the ContentType field contents
      if (len)									// if we have a length, then
      {
        char *string = new char[len+5];						// create a string of length + 5 (CRLF + NULL = 3, +2 to be safe!)
        len+=4;									// set len as 1 less so we can set the last char as NULL
        if (string)								// if malloc worked then
        {
          rc = GetContentSubType(string, len);					// Get the Subtype from the ContentType field.  This will be much less than length anyway
          dprintf(("","MIMEmessage::parse:GetContentSubType: string: '%s' len: %d rc: %d\n", string, len, rc));
          if (rc == NFE_COMPLETED)						// if we got that okay, then
          {
            if (incase_comp("message", string) == 0)				// if it's "message" then
            {
              message_type = NFE_CT_MESSAGE_RFC822;				// set to MESSAGE_RFC822
              bodyrfc822msg *new_body = 0;					// create a bodyrfc822msg body object
              if (the_body)
                new_body = new bodyrfc822msg(*the_body);
              else
                new_body = new bodyrfc822msg(file, mem_base, body_start, body_len, false);
              if (new_body)
              {
                if (the_body)							// swap it for the basic body object
                  delete the_body;
                the_body = new_body;
                rc = the_body->ParseData(context, t_slice);				// parse this new body
              }
              else
                rc = NFE_MALLOCFAILED;
            }
            else								// else
              message_type = NFE_CT_MESSAGE_UNKNOWN;				// set to MESSAGE_UNKNOWN
          }
          delete[] string;
        }
        else									// else
          rc = NFE_MALLOCFAILED;						// set rc as MALLOCFAILED
      }
      else									// else
        rc = NFE_FAILED;							// we couldn't get the length of the ContentType field
    }
    else									// else
      rc = NFE_INVALIDDATA;							// Parsing failed, this is not an MIME message entity
  }
  if (rc == NFE_COMPLETED)
    parsed = true;

  return rc;
}


/* ************************************************************************** */
/*
   METHOD:         Display
   DESCRIPTION:    Method for development only printf's info. on the object
   DEPENDENCIES:   NONE
   DEPENDED ON BY:
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
#ifdef DISPLAY
void MIMEmessage::Display(void)
{
  printf("MIMEmessage DISPLAY:\n");
  switch (message_type)
  {
    case NFE_CT_MESSAGE_RFC822:
      printf("message_type is : RFC822\n");
      break;
    case NFE_CT_MESSAGE_UNKNOWN:
      printf("message_type is : UNKNOWN\n");
      break;
    default:
      printf("message_type is : INTERNAL ERROR!\n");
      break;
  }
  if (the_headers)
    the_headers->Display();
  if (the_body)
    the_body->Display();
  printf("END OF MIMEmessage\n");
  printf("\n");
}
#endif
