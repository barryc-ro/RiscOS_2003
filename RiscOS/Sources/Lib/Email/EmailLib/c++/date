/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		date.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.05 for RISC OS

	OVERVIEW
	========
	Source file for implementation of date object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	12/09/97	0.02	RDW	Merged file and memory constructors into one
	26/09/97	0.03	RDW	set parsed to TRUE in constructor
					when creating from scratch and set
					parsed to TRUE in parse function on
					success
					copydateobject correct to copy the date
					struct tm and time_t
	04/12/97	0.04	RDW	NFE_OS_get_timezone call added to
					CreateDate method so timezone of host
					machine is added to date
	18/02/98	0.02	RDW	#include DebugLib path added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdlib.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "date.h"
#include "header.h"
#include "822parser.h"
extern "C"
{
  #include "ELib.h"
  #include "Elib_OS.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */
struct m
{
  uint32 m;
  char   mname[4];
};
const static struct m months[] =
{
  {  1, "Jan" },
  {  2, "Feb" },
  {  3, "Mar" },
  {  4, "Apr" },
  {  5, "May" },
  {  6, "Jun" },
  {  7, "Jul" },
  {  8, "Aug" },
  {  9, "Sep" },
  { 10, "Oct" },
  { 11, "Nov" },
  { 12, "Dec" }
};

struct z
{
  int32 z;
  char  zname[4];
};
const static struct z zones[] = 
{
  { 0, "UT" },
  { 0, "GMT" },
  { -5, "EST" },
  { -4, "EDT" },
  { -6, "CST" },
  { -5, "CDT" },
  { -7, "MST" },
  { -6, "MDT" },
  { -8, "PST" },
  { -7, "PDT" }
};


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a date object (memory based)
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
date::date(BOOL f, char *membase, uint32 offset, uint32 length, BOOL owner) : header(f, membase, offset, length, NFE_HDR_DATE, owner),
                                                                      datetime_valid(FALSE),
                                                                      parsed(FALSE)
{
  if ((owner) && (length==0))
  {
    SetName("Date");
    CreateDate();		// set date to current time
    parsed = TRUE;
  }
  else
    memset(&datetime, 0, sizeof(datetime));
}


// copy constructor
date::date(const date &object) : header(object),
                                 datetime_valid(FALSE),
                                 parsed(FALSE)
{
  memset(&datetime, 0, sizeof(datetime));
  copydateobject(object);
}


// copy constructor from header object
date::date(const header &object) : header(object),
                                   datetime_valid(FALSE),
                                   parsed(FALSE)
{
  type = NFE_HDR_DATE;
  memset(&datetime, 0, sizeof(datetime));
}


date &date::operator=(const date &object)
{
  header::operator=(object);
  if (this != &object)
  {
    // do destructor things
    copydateobject(object);
  }
  return *this;
}


date &date::operator=(const header &object)
{
  header::operator=(object);
  if (this != &object)
  {
    // do destructor things
    datetime_valid = FALSE;
    parsed = FALSE;
  }
  return *this;
}


void date::copydateobject(const date &object)
{
  dt = object.dt;
  datetime = object.datetime;
  datetime_valid = object.datetime_valid;
  parsed = object.parsed;
}


/*// constructor, file version
date::date(char *filename, uint32 offset, BOOL owner) : header(filename, offset, NFE_HDR_DATE, owner),
                                                        datetime_valid(FALSE),
                                                        parsed(FALSE)
{
  memset(&datetime, 0, sizeof(datetime));  
}
*/

// Implementation of destructor for date
date::~date()
{
  // nothing to do
}


NFE_rcode date::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  BOOL      error = FALSE;

  if (!header::Parsed())
    rc = header::parse(context, t_slice);
  if (rc != NFE_COMPLETED)
    error = TRUE;
    
  if (!error)
  {
    uint32 size = 0;
    rc = GetBodyLen(size);
    size+=2;
    char *temp = new char[size];
    if (temp)
    {
      rc = GetUnfoldedNoCommentsBody(temp, size);
      dprintf(("", "GetUnfoldedNoCommentsBody(): %s   size:%d\n", temp, size));
      if (rc == NFE_COMPLETED)
      {
        char *ptr = temp;
        
        error = consume_all_LWSP(ptr, size); 
        if ((!error) &&(ptr[3] == ','))					// if it's a ',' skip it and until all the char is not a LWSP char
        {
          ptr+=4;
          error = consume_all_LWSP(ptr, size); 
        }
        
        error = consume_number(ptr, size, 1, 2, datetime.tm_mday);		// get 1 or 2 digits -> day
        
        if (!error)	error = consume_all_LWSP(ptr, size);			// skip all LWSP
        char month[4];
        if (!error)	error = consume_string(ptr, size, 3, 3, month);
        if (!error)								// consume month
        {
          if (islower(month[0]))	month[0] -= 32;
          if (isupper(month[1]))	month[1] += 32;
          if (isupper(month[2]))	month[2] += 32;

          datetime.tm_mon = 0;
          for (uint32 i=0; i<12; i++)
          {
            if (strncmp(months[i].mname, month, 3) == 0)
              datetime.tm_mon = months[i].m;
          }
          if (datetime.tm_mon)
            datetime.tm_mon--;
          else
            error = TRUE;
        }									// end of consume month
        if (!error)	error = consume_all_LWSP(ptr, size);
        if (!error)	error = consume_number(ptr, size, 2, 4, datetime.tm_year);
        if (!error)	datetime.tm_year-=1900;
        if (!error)	error = consume_all_LWSP(ptr, size);
        if (!error)	error = consume_number(ptr, size, 2, 2, datetime.tm_hour);
        if (!error)	error = consume_char(ptr, size, ':');
        if (!error)	error = consume_number(ptr, size, 2, 2, datetime.tm_min);
        if (!error)
        {
          if (*ptr == ':')
          {
            ptr++;
            error = consume_number(ptr, size, 2, 2, datetime.tm_sec);
          }
        }
        if (!error)	error = consume_all_LWSP(ptr, size);
        if (!error)								// consume zone
        {
          if (isalpha(*ptr))							// if char is an alpha then
          {
            if (isalpha((*ptr)+1))						// if next char IS an alpha then
            {
              char zone[4];
              error = consume_string(ptr, size, 2, 3, zone);			// consume zone name
              for (uint32 i=0; i<10; i++)
              {
                if (strncmp(zones[i].zname, zone, 3) == 0)
                {
                  // re-calc time to UT(GMT) based on zones[i][0]
                  if (zones[i].z != 0)
                  {
                    datetime.tm_hour += zones[i].z;
                    if (datetime.tm_hour > 23)
                    {
                      datetime.tm_hour = abs(datetime.tm_hour) - 24;
                      datetime.tm_mday += 1;
                      if (datetime.tm_mday > 31)
                      {
                        datetime.tm_mday = abs(datetime.tm_mday) - 31;		// mktime should sort our the 28, 30 or 31 days in the month
                        datetime.tm_mon += 1;
                        if (datetime.tm_mon > 11)
                        {
                          datetime.tm_mon = abs(datetime.tm_mon) - 12;
                          datetime.tm_year += 1;
                        }
                      }
                    } 
                  }
                }  // end for recalc. to UT(GMT) time
              }
            }
            else
              ptr++;								// this is military, ignore and assume UT(GMT)
          }
          else									// numeric zone consume
          {
            int32 zone_hh = 0;
            int32 zone_mm = 0;
            int32 positive = TRUE;
            
            if (*ptr == '+')
              positive = TRUE;
            else if (*ptr == '-')
              positive = FALSE;
            else
              error = TRUE;
            if (!error)
            {
              ptr++;								// consume the - or +
              error = consume_number(ptr, size, 2, 2, zone_hh);			// consume the hours offset
              if (!error)	consume_number(ptr, size, 2, 2, zone_mm);	// consume the minutes offset
            }
            if (!error)
            {
              // re-calc time to UT(GMT)based on zone_hh and mm
              // mm first
              if (zone_mm != 0)
              {
                if (positive)
                {
                  datetime.tm_min -= zone_mm;
                  if (datetime.tm_min < 0)
                  {
                    datetime.tm_min = 60 - abs(datetime.tm_min);
                    datetime.tm_hour -= 1;
                    if (datetime.tm_hour < 0)
                    {
                      datetime.tm_hour = 24 - abs(datetime.tm_hour);
                      datetime.tm_mday -= 1;
                      if (datetime.tm_mday <= 0)
                      {
                        datetime.tm_mday = 31 - abs(datetime.tm_mday);		// mktime should sort our the 28, 30 or 31 days in the month
                        datetime.tm_mon -= 1;
                        if (datetime.tm_mon < 0)
                        {
                          datetime.tm_mon = 12 - abs(datetime.tm_mon);
                          datetime.tm_year -= 1;
                        }
                      }
                    }
                  }
                } // end of negitive minute change
                else
                {
                  datetime.tm_min += zone_mm;
                  if (datetime.tm_min > 59)
                  {
                    datetime.tm_min = abs(datetime.tm_min) - 59;
                    datetime.tm_hour += 1;
                    if (datetime.tm_hour > 23)
                    {
                      datetime.tm_hour = abs(datetime.tm_hour) - 24;
                      datetime.tm_mday += 1;
                      if (datetime.tm_mday > 31)
                      {
                        datetime.tm_mday = abs(datetime.tm_mday) - 31;		// mktime should sort our the 28, 30 or 31 days in the month
                        datetime.tm_mon += 1;
                        if (datetime.tm_mon > 11)
                        {
                          datetime.tm_mon = abs(datetime.tm_mon) - 12;
                          datetime.tm_year += 1;
                        }
                      }
                    }
                  }
                } // end of positive minute change                
              } // end of changes due to minutes
              if (zone_hh != 0)
              {
                if (positive)
                {
                  datetime.tm_hour -= zone_hh;
                  if (datetime.tm_hour < 0)
                  {
                    datetime.tm_hour = 24 - abs(datetime.tm_hour);
                    datetime.tm_mday -= 1;
                    if (datetime.tm_mday <= 0)
                    {
                      datetime.tm_mday = 31 - abs(datetime.tm_mday);		// mktime should sort our the 28, 30 or 31 days in the month
                      datetime.tm_mon -= 1;
                      if (datetime.tm_mon < 0)
                      {
                        datetime.tm_mon = 12 - abs(datetime.tm_mon);
                        datetime.tm_year -= 1;
                      }
                    }
                  }
                } // end of negitive hour change
                else
                {
                  datetime.tm_hour += zone_hh;
                  if (datetime.tm_hour > 23)
                  {
                    datetime.tm_hour = abs(datetime.tm_hour) - 24;
                    datetime.tm_mday += 1;
                    if (datetime.tm_mday > 31)
                    {
                      datetime.tm_mday = abs(datetime.tm_mday) - 31;		// mktime should sort our the 28, 30 or 31 days in the month
                      datetime.tm_mon += 1;
                      if (datetime.tm_mon > 11)
                      {
                        datetime.tm_mon = abs(datetime.tm_mon) - 12;
                        datetime.tm_year += 1;
                      }
                    }
                  }
                } // end of positive hour change                
              } // end of changes due to hours
            }
          }									// end of consume numeric time zone
        }									// end of consume time zone
      }
      // calc. struct tm for this object
      dt = mktime(&datetime);
      datetime_valid = TRUE;
      delete[] temp;
      temp = 0;
      parsed = TRUE;
    }
    else
      rc = NFE_MALLOCFAILED;
  }
    
  return rc;
}


void date::Display(void)
{
  header::Display();
  printf("seconds: %d\n", datetime.tm_sec);
  printf("minutes: %d\n", datetime.tm_min);
  printf("hours  : %d\n", datetime.tm_hour);
  printf("Day    : %d\n", datetime.tm_mday);
  printf("Month  : %d\n", datetime.tm_mon);
  printf("Year   : %d\n", datetime.tm_year);
  printf("DST    : %d\n", datetime.tm_isdst);
  printf("\n");
}


NFE_rcode date::GetDate(struct tm &copy_dt) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (parsed)
  {
    if (datetime_valid)
      copy_dt = datetime;
    else
      rc = NFE_INVALIDDATA;
  }
  else
    rc = NFE_DATAMUSTBEPARSED;
  
  return rc;
}


NFE_rcode date::CreateDate(void)
{
  NFE_rcode rc = NFE_COMPLETED;
  BOOL      positive;
  uint32    hours;
  uint32    minutes;
  
  rc = NFE_OS_get_timezone(&positive, &hours, &minutes);
  
  if (rc == NFE_COMPLETED)
  {
    dt = time(0);
    datetime = *localtime(&dt);
    char s[60];
    int success = strftime(s, 49, "%a, %d %b %Y %H:%M:%S", &datetime);
  
    if (success)
    {
      if (positive)
        sprintf(s+success, " +%02d%02d", hours, minutes);
      else
        sprintf(s+success, " -%02d%02d", hours, minutes);
      rc = SetBody(s);
      if (rc == NFE_COMPLETED)
      {
        parsed = TRUE;
        datetime_valid = TRUE;
      }
    }
    else
      rc = NFE_FAILED;
  }
  
  return rc;
}


    
