/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		entity.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.12D for RISC OS

	OVERVIEW
	========
	Source file for implementation of entity object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	10/09/97	0.02	RDW	WriteOut methods added
	11/09/97	0.03	RDW	ReplaceBody method added
	12/09/97	0.04	RDW	Merged file and memory constructors into one
	17/09/97	0.05	RDW	WriteOut methods changed so that the blank
					line is only written if there are headers to
					write out
	07/10/97	0.06	RDW	Descructor does not check ownership anymore
					before destroying body or headers.  They are
					always destroyed now.
					stop() call missing from parse method. Added.
	29/11/97	0.07	RDW	Methods	operator+= and copyentityobject
					altered to GetType of body object before
					creating copy so that correct body object
					(body or bodymulti) is created as the copy.
	08/12/97	0.08	RDW	parse method, default encoding for body
					corrected to 7BIT and not unknown.
	09/01/98	0.09	RDW	constructor no longer creates headers object.
					parse method now does this once it knows the
					length of the headers.
	19/01/98	0.10	RDW	parse modified to return NFE_NOTVALIDENTITY
	18/02/98	0.11	RDW	#include DebugLib path added
	23/04/98	0.12D	RDW	#ifdef DISPLAY round Display method added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "entity.h"
#include "elibbase.h"
#include "headers.h"
#include "header.h"
#include "contentTE.h"
#include "body.h"
#include "bodymulti.h"
extern "C"
{
  #include "ELib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a entity object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
entity::entity(BOOL f, char *membase, uint32 offset, uint32 length, NFE_ENTITY_TYPE t, BOOL owner) : elibbase(f, membase, offset, length, owner),
//                                           the_headers(membase, offset, length, FALSE),
                                           the_headers(0),
                                           the_body(0),
                                           headers_start(0),
                                           headers_len(0),
                                           body_start(0),
                                           body_len(0),
                                           entity_type(t)
{
  if ((owner) && (length == 0))					// then this is a MIMEimage to be created from scratch
  {
    the_headers = new headers(FALSE, 0, 0, 0, owner);		// MEMORY ONLY! 0 for membase for headers as mem_base is the body
    NFE_TE e = NFE_TE_UNKNOWN;
    switch (t)
    {
      case NFE_ENTITY_MIME:
        e = NFE_TE_8BIT;
        break;
      case NFE_ENTITY_RFC822MSG:
        e = NFE_TE_7BIT;
        break;
      default:
        e = NFE_TE_UNKNOWN;
        break;
    }
    the_body    = new body(f, membase, 0, 0, e, owner);
  }
//  else
//    the_headers = new headers(f, membase, offset, length, owner);
}


// copy constructor
entity::entity(const entity &object) : elibbase(object),
                                           the_headers(0),
                                           the_body(0),
                                           headers_start(0),
                                           headers_len(0),
                                           body_start(0),
                                           body_len(0),
                                           entity_type(NFE_ENTITY_UNKNOWN)
{
  copyentityobject(object);
}


/*// constructor, file version
entity::entity(uint32 offset, uint32 length, char *filename, NFE_ENTITY_TYPE t, BOOL owner) : elibbase(filename, offset, length, TRUE, owner),
//                                           the_headers(filename, offset, FALSE),
                                           the_headers(0),
                                           the_body(0),
                                           headers_start(0),
                                           headers_len(0),
                                           body_start(0),
                                           body_len(0),
                                           entity_type(t)
{
  if ((owner) && (length == 0))					// then this is a MIMEimage to be created from scratch
  {
    the_headers = new headers(0, 0, 0, owner);			// memory for headers as the file is the body!
    the_body    = new body(0, 0, mem_base, NFE_TE_NONE, owner);
  }
  else
    the_headers = new headers(filename, offset, owner);
}
*/

// assignment operator
entity& entity::operator=(const entity &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    if ((the_body) && (ownership))
    {
      delete the_body;
      the_body = 0;
    }
    if ((the_headers) && (ownership))
    {
      delete the_headers;
      the_headers = 0;
    }
    copyentityobject(object);
  }
  return *this;
}


// += operator
entity& entity::operator+=(const entity &object)
{
  elibbase::operator=(object);	// HMMM......?
  if (this != &object)
  {
    // do destructor type things
    if (object.the_body)			// if other object has a body then destroy ours
    {
      if ((the_body) && (ownership))
      {
        delete the_body;
        the_body = 0;
      }
      switch (object.the_body->GetType())
      {
        case NFE_BODY:
          the_body = new body(*(object.the_body));
          break;
        case NFE_BODY_MULTI:
          the_body = new bodymulti(*((bodymulti*)object.the_body));
          break;
        default:
        {
          the_body = 0;
          // ARRGHH! Need to throw exception as we are stuffed if we end up here!
        }
      } // endswitch
    }
    if (object.the_headers)			// if other object has headers, then add them to ours
    {
      if (!the_headers)
        the_headers = new headers(*(object.the_headers));	// if we had no headers, copy other objects in full
      else
        (*the_headers)+=(*object.the_headers);
     // all below is a problem.....
//     headers_start = object.headers_start;
//     headers_len = object.headers_len;
//     body_start = object.body_start;
//     body_len = object.body_len;
     // keep out entity type
    }
   }
  return *this;
}


void entity::copyentityobject(const entity &object)
{
  headers_start = object.headers_start;
  headers_len = object.headers_len;
  body_start = object.body_start;
  body_len = object.body_len;
  entity_type = object.entity_type;
//  the_headers = object.the_headers;
  if (object.the_headers)
    the_headers = new headers(*(object.the_headers));
  if (object.the_body)
  {
    switch (object.the_body->GetType())
    {
      case NFE_BODY:
        the_body = new body(*(object.the_body));
        break;
      case NFE_BODY_MULTI:
        the_body = new bodymulti(*(object.the_body));
        break;
      default:
      {
        the_body = 0;
        // ARRGHH! Need to throw exception as we are stuffed if we end up here!
      }
    } // endswitch
  }
  else
    the_body = 0;
}


// Implementation of destructor for entity
entity::~entity()
{
  if (the_body)
    delete the_body;
  if (the_headers)
    delete the_headers;
}


NFE_rcode entity::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  BOOL      error = FALSE;
  uint32    body_offset = 2;

  BOOL startok = goto_start();
  if (!startok)
    error = TRUE;
  if ((error) && (file))
    rc = NFE_INVALIDFILENAME;
  else
  {
    if (compare_current_pos("\r\n") != 0)
    {
        body_offset = 4;
      next_char();
      while ((!error) && (compare_current_pos("\r\n\r\n") != 0))
      {
        if (end_of_data())
        {
          error = TRUE;
          rc = NFE_NOTVALIDENTITY;
        }
        else
          next_char();
      }
    }
  }

  if (!error)
  {
    headers_start = 0;
    headers_len = curpos;
    body_start = curpos + body_offset;
    body_len = len - body_start;

    if (!the_headers)
      the_headers = the_headers = new headers(file, mem_base, start, headers_len, ownership);
      
    if (the_headers)
      rc = the_headers->ParseData(context, 0);
    else
      rc = NFE_MALLOCFAILED;
    if (rc != NFE_COMPLETED)
    {
      dprintf(("", "entity:headers->ParseData\n"));
      error = TRUE;
    }
    else
    {
      // parse body
      NFE_TE enc = NFE_TE_7BIT;

      header *h = the_headers->FindHdr(NFE_HDR_CONTENT_TRANSFER_ENCODING);

      if (h)
        rc = ((contentTE*)h)->GetTE(enc);

      if (rc == NFE_COMPLETED)
      {
/*        if (file)
          the_body = new body(body_start+start, body_len, mem_base, enc, FALSE);
        else
          the_body = new body(mem_base, body_start+start, body_len, enc, FALSE);*/
        the_body = new body(file, mem_base, body_start+start, body_len, enc, FALSE);
        if (!the_body)
          rc = NFE_MALLOCFAILED;
        else
        {
          the_body->ParseData(context, 0);
        }
      }
    }
  }
  if (startok)
    stop();
  if ((error) && (rc == NFE_COMPLETED))
    rc = NFE_INTERNALERR;
    
  return rc;
}


#ifdef DISPLAY
void entity::Display(void)
{
  printf("ENTITY DISPLAY:\n");
  if (the_headers)
    the_headers->Display();
  if (the_body)
    the_body->Display();
  printf("END OF ENTITY\n");
  printf("\n");
}
#endif

void entity::SetOwnership(BOOL o)
{
  if (the_headers)
    the_headers->SetOwnership(o);
  if (the_body)
    the_body->SetOwnership(o);
}


// function to write out the object to file
NFE_rcode entity::WriteOut(NFE_CONTEXT &context, clock_t t_slice, FILE *f)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (f)
  {
    if (the_headers)
    {
      rc = the_headers->WriteOut(context, t_slice, f);
      if (rc == NFE_COMPLETED)
        fwrite("\r\n", 2, 1, f);					// Only write out blank line if there are headers
    }
    if (rc == NFE_COMPLETED)
      rc = the_body->WriteOut(context, t_slice, f);
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


// function to write out the object to memory
NFE_rcode entity::WriteOut(NFE_CONTEXT &context, clock_t t_slice, char *mem, uint32 &l)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (mem)
  {
    if (l >= len + 1)
    {
      if (the_headers)
      {
        rc = the_headers->WriteOut(context, t_slice, mem, l);
        if (rc == NFE_COMPLETED)
          strcat(mem, "\r\n");						// Only write out blank line if there are headers
      }
      if (rc == NFE_COMPLETED)
        rc = the_body->WriteOut(context, t_slice, mem, l);
    }
    else
    {
      l = len + 1;
      rc = NFE_NOSPACE;
    }
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


// replace the entity's body object with this one
NFE_rcode entity::ReplaceBody(body *b)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (b)
  {
    if (the_body)
      delete the_body;
    the_body = b;
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


// Destroy all the headers in this entity
NFE_rcode entity::DestroyHdrs(void)
{
  if (the_headers)
  {
    delete the_headers;
    the_headers = 0;
  }
  return NFE_COMPLETED;
}


