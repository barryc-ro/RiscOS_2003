/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		headers.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.15D for RISC OS

	OVERVIEW
	========
	Source file for implementation of headers object
	

	HISTORY
	=======
	03/09/97	0.01	RDW	initial version
	10/09/97	0.02	RDW	WriteOut methods done
					ReplaceHdr, InsertHdr and AddHdr methods added
	12/09/97	0.03	RDW	Merged file and memory constructors into one
	18/09/97	0.04	RDW	Added support for all the XNetFax headers
	22/09/97	0.05	RDW	FindHdr method changed so it no longer tests for data_present() as
					for headers created from scratch the headers object will have no
					data as it will all be held within the individualy created
					header objects.
					list.Next() move in FindHdr so that is is always called.  if h
					was NULL, then Next wasn't called and the Nul test would fail
					leaving it in an infinite loop
	25/09/97	0.06	RDW	Not all code in parse method that had moved to entity class
					had been commented out.  This ment for memory version of
					headers, the length of a header was stuck at 4!
	26/09/97	0.07	RDW	removed ownership check in destructor
					and operator= so we always destroy the
					header objects we hold
					Modified copyheadersobject so that
					it creates copies of the header objects in
					the other object it's copying from
	27/10/97	0.08	RDW	added support for subject class header
	09/01/98	0.09	RDW	parse method (curpos<len) check added
					to while loop as end_of_data is broken.
					This needs fixing later when there is
					more time to assess the impact of it.
	09/01/98	0.10	RDW	FindHdr method which takes the header field
					name string as input added
					WriteOut Methods now stop and return when
					a header WriteOut call fails
	18/02/98	0.11	RDW	#include DebugLib path added
	20/02/98	0.12	RDW	added support for XNFrtnrcpt
	27/02/98	0.13	RDW	FindHdr(char *fieldname) method memory leak fixed,
					tmpname wasn't deallocated & fixed error
					on fieldname parameter check, logic was
					inverted!
	23/04/98	0.14D	RDW	#ifdef DISPLAY round Display method added
					copyheadersobject method changed to use
					clone() virtual copy constructor.
					copy constructor parameter corrected to be const
					copyheadersobject method changed so it now
					makes a tmp copy of the other headers object's
					list and TRAVERSE that.  As TRAVERSE doesn't
					modify the dynamically allocated data structures
					in the QAList, this is safe.  However, we aught to
					add a proper operator= and copy constructor to
					QAlist
	11/06/98	0.15D	RDW	Modified to use hdr_registry, parse method modified
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <string.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "hdr_reg.h"
#include "headers.h"
#include "header.h"
#include "elibbase.h"
#include "date.h"
#include "resentdate.h"
#include "from.h"
#include "to.h"
#include "replyto.h"
#include "messageid.h"
#include "mimevers.h"
#include "contentTE.h"
#include "contentT.h"
#include "XNFfaxpage.h"
#include "XNFserial.h"
#include "XNFsoftrev.h"
#include "XNFmsgclas.h"
#include "Xorganiz.h"
#include "XNFfaxnum.h"
#include "XNFphoneno.h"
#include "XNFdevice.h"
#include "XNFdevicec.h"
#include "subject.h"
#include "XNFrtnrcpt.h"

extern "C"
{
  #include "ELib.h"
  #include "Elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Default constructor
   DESCRIPTION:    NOTHING TO DO
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers::headers(void) : elibbase()
{
  
}


/* ************************************************************************** */
/*
   METHOD:         Constructor for a headers object
   DESCRIPTION:    Construct a memory version of a headers object.  Construct
   		   the elibbase object we inherit (also MEMORY version).
   DEPENDENCIES:   class		elibbase
   DEPENDED ON BY: 
   INPUT PARAMS:   BOOL                 f		filebased(TRUE), memory(FALSE)
                   char*		membase		start of memory block
   		   uint32		offset		no. of chars. from membase to start of headers
   		   uint32		length		length of headers in chars
   		   BOOL			owner		object owns memory block?
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers::headers(BOOL    f,
                 char   *membase,
                 uint32  offset,
                 uint32  length,
                 BOOL    owner) : elibbase(f, membase, offset, length, owner)
{
  
}

/* REMOVED */
/* ************************************************************************** */
/*
   METHOD:         Constructor for a headers object (FILE)
   DESCRIPTION:    Construct a file version of a headers object.  Construct
   		   the elibbase object we inherit (also FILE version).
   DEPENDENCIES:   class		elibbase
   DEPENDED ON BY: 
   INPUT PARAMS:   uint32		offset		no. of chars. from membase to start of headers
   		   uint32		length		length of headers in chars
   		   char*		filename	filename of file headers is in
   		   BOOL			owner		object owns file?
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
/*headers::headers(char   *filename,
                 uint32  offset,
                 BOOL    owner) : elibbase(filename, offset, 0, TRUE, owner)
{
  
}
*/


/* ************************************************************************** */
/*
   METHOD:         Copy Constructor for a headers object
   DESCRIPTION:    Construct a headers object from another headers object.
   		   Construct the elibbase object we inherit and
   		   setup our data members from the given object to copy from
   DEPENDENCIES:   class		elibbase
   		   method		copyheadersobject
   DEPENDED ON BY: 
   INPUT PARAMS:   const headers&	object		object to copy from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers::headers(const headers &object) : elibbase(object)
{
  copyheadersobject(object);
}


/* ************************************************************************** */
/*
   METHOD:         Assignment operator
   DESCRIPTION:    set this headers object to be the same as the given headers
   		   object.  First all the elibbase assignment, do any destruction
   		   needed (delete the header objects in the list if we own them)
   		   and then copy the headers object data members
   DEPENDENCIES:   method		copyheadersobject
   DEPENDED ON BY: 
   INPUT PARAMS:   const headers&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   headers&				reference to this object
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers &headers::operator=(headers &object)
{
  elibbase::operator=(object);							// do the parent class assignment
  if (this != &object)								// make sure we are not assigning to ourselves
  {
    // do destructor stuff
    TRAVERSE(list)
    {
      header *h = (header*)list.Current();
      if (h)
        delete h;								// delete the header objects we have
    }
    copyheadersobject(object);							// copy the other headers object into this one
  }
  return *this;									// return this object
}


/* ************************************************************************** */
/*
   METHOD:         Assignment operator, but keep all this objects headers too!
   DESCRIPTION:    set this headers object to be the same as the given headers
   		   object.  First all the elibbase assignment, do any destruction
   		   needed (delete the header objects in the list if we own them)
   		   and then copy the headers object data members
   DEPENDENCIES:   method		copyheadersobject
   DEPENDED ON BY: 
   INPUT PARAMS:   const headers&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   headers&				reference to this object
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers &headers::operator+=(headers &object)
{
  elibbase::operator=(object);							// do the parent class assignment
  if (this != &object)								// make sure we are not assigning to ourselves
  {
    copyheadersobject(object);							// copy the other headers object into this one
  }
  return *this;									// return this object
}


/* ************************************************************************** */
/*
   METHOD:         copyheadersobject
   DESCRIPTION:    Copy the data members from the given headers object into
   		   this headers object.
   DEPENDENCIES:   
   DEPENDED ON BY: copy constructor
   		   operator=
   INPUT PARAMS:   const headers&	object		object to assign from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
void headers::copyheadersobject(const headers &object)
{
  QAIndexedList tmp_list(object.list);						// Make a copy of the list to traverse
  
  TRAVERSE(tmp_list)								// traverse the object's list of headers
  {
    header *h = (header*)(tmp_list.Current());					// get ptr to the current header in the list
    if (h)									// if we've got one, then
    {
      header *h2 = (header*)h->clone();						// Create a copy of the header object
      if (h2)
        list.Insert(h2);
    }
  }
  parsed = object.parsed;							// WHY HAVE I PUT THIS HERE?  the elibbase copying should do this
}


/* ************************************************************************** */
/*
   METHOD:         Destructor
   DESCRIPTION:    If we have ownership of the header objects we hold in our
   		   list, traverse the list and destroy them
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
headers::~headers()
{
  // traverse list and destroy the header objects in it
  TRAVERSE(list)
  {
    header *h = (header*)list.Current();
    if (h)
      delete h;
  }
}


/* ************************************************************************** */
/*
   METHOD:         Display
   DESCRIPTION:    Method for development only printf's info. on the object
   DEPENDENCIES:   NONE
   DEPENDED ON BY: 
   INPUT PARAMS:   NONE
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
#ifdef DISPLAY
void headers::Display(void)
{
  TRAVERSE(list)								// Traverse this list
  {
    ((header*)list.Current())->Display();					// Call Display method for each object
  }
}
#endif

/* ************************************************************************** */
/*
   METHOD:         parse
   DESCRIPTION:    Private method which is called by ParseData method from
   		   elibbase base class.  function should parse the data that
   		   the headers object has in order to setup the headers list
   		   data member.
   		   Method starts at the beginning of the data and parses each
   		   RFC email header found by creating a header object, calling
   		   it's ParseData method.  Next, findout what type it is from
   		   it's Field name.  If we have a specific header class defined
   		   for that, we create an object of that type (eg. date) assign
   		   the general header object to this specific one and destroy
   		   the general one.  Once all the headers are done, we return
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   NFE_CONTEXT&		context
   		   clock_t		t_slice
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NFE_rcode		rc		result of function
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
NFE_rcode headers::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc = NFE_COMPLETED;							// Assume success
  BOOL error = FALSE;								// No error yet
  
  BOOL startok = goto_start();							// goto to the start of the data to parse
  if (!startok)									// if we didn't manage that then set an error
    error = TRUE;
  if ((error) && (file))							// if error set and this object is file based, then
    rc = NFE_INVALIDFILENAME;							// set return code as INVALIDFILENAME
  
  // PARSE DATA
  if (!error)									// if no error, then find the length of the headers in total
  {
    uint32 beginning = 0;							// set beginning of next header as 0 to start with
    
    while ( (!error) && (!end_of_data()) && (curpos<len))			// while no error and still data to parse, do
    {
      NFE_CONTEXT c;								// context to call header object parsing with
      NFE_rcode rc = NFE_COMPLETED;						// assume success for header parsing
      header *h = 0;								// current header object
      uint32 tmplen = len - curpos;						// potential length of current header object
      										// ie. length of the headers - current position
      dprintf(("", "BEFORE new header, curchar: %c\ncurpos: %d\n", curchar, curpos));
      h = new header(file, mem_base, curpos+start, tmplen);			// create a new header object
      
      if (h)									// if header created okay, then
        rc = h->ParseData(c, 0);						// parse that header
      else									// else
        rc = NFE_MALLOCFAILED;							// set rc MALLOCFAILED
      if (rc != NFE_COMPLETED)							// if parse NOT OK, then
      {
        dprintf(("", "headers:header->ParseData failed\n"));
        error = TRUE;								// set error
        if (h)									// if header object exists, then
          delete h;								// delete it
        h = 0;									// clear h
      }
      else									// else header parse was OK, so
      {
        header *h2 = hdr_registry::Instance().create_specific_header(*h);	// Get the header registry to create the correct specific header object

        if (!h2)
          rc = NFE_MALLOCFAILED;
        else
        {
          rc = h2->ParseData(c, 0);						// parse that header's specific properties
          if (rc != NFE_COMPLETED)						// if parse not ok, then
          {
            dprintf(("", "headers:header->ParseData failed\n"));
            if (h2)
              delete h2;							// destroy that specific header
            h2 = 0;								// reset h2
          }
          else									// else parse was ok, so
          {
            delete h;								// destroy old generic header object
            h = h2;								// set h to point at the specific header object
          }
        }

        if (!error)
        {
          h->GetLen(tmplen);							// Get the actual length of the current header
          dprintf(("", "h->GetLen(tmplen): %d\n", tmplen));
          beginning += tmplen;							// goto end of this header
          goto_pos(beginning);							// and therefore, start of the next one
          dprintf(("", "headers:curchar: %c\ncurpos: %d\n", curchar, curpos));
        
          // add new header to list
          if (!list.Insert(h))
          {
            dprintf(("", "headers:list.Insert failed\n"));
            error = TRUE;							// Insert failed!
          }
        }
      } // endif check on generic header parse success/failure
    } // endwhile
  }
  stop();									// terminate the access to the object's data
  if ((error) && (rc != NFE_COMPLETED))
    rc = NFE_FAILED;
  return rc;
}


/* ************************************************************************** */
/*
   METHOD:         FindHdr
   DESCRIPTION:    Method for finding a header of the given type t and returning
   		   a pointer to that header object and it's position in the
   		   headers list.  This method will only return the first header
   		   of the type requested found.  Later in development, I may
   		   find I need to get other headers which occur more than once.
   		   eg. Received header.
   DEPENDENCIES:   NONE
   DEPENDED ON BY: 
   INPUT PARAMS:   NFE_HDR_TYPE		t		type of header to look for
   OUTPUT PARAMS:  int32&		index		position of header in list
   RETURN VALUE:   header*				NULL if not found
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header* headers::FindHdr(NFE_HDR_TYPE t, int32 &index)
{
  header *h = 0;
  
  if (parsed)									// check this headers object has data which is parsed
  {
    BOOL found = FALSE;
    list.Start();								// Goto start of list
    while ((!list.Nul()) && (!found))						// while not found header and not off end of list, do
    {
      h = (header*)list.Current();						// Get current header in list
      if (h)
      {
        if (h->GetType() == t)							// Get header type and if == t, then
        {
          found = TRUE;								// set found
          index = list.Rank();							// and set index
        }
      }
      list.Next();
    }
    if (!found)
      h = 0;
  }
    
  return h;
}


/* ************************************************************************** */
/*
   METHOD:         FindHdr
   DESCRIPTION:    Method for finding a header of the given field name
   DEPENDENCIES:   NONE
   DEPENDED ON BY: 
   INPUT PARAMS:   char*		fieldname	
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   header*				NULL if not found
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header* headers::FindHdr(char *fieldname)
{
  header *h = 0;
  
  if ((parsed) && (fieldname))							// check this headers object has data which is parsed
  {
    BOOL found = FALSE;
    list.Start();								// Goto start of list
    while ((!list.Nul()) && (!found))						// while not found header and not off end of list, do
    {
      h = (header*)list.Current();						// Get current header in list
      if (h)
      {
        char *tmpname = 0;
        NFE_rcode rc = NFE_COMPLETED;
        uint32 tmplen = 0;
        
        rc = h->GetNameLen(tmplen);
        if (rc == NFE_COMPLETED)
        {
          tmplen+=2;
          
          tmpname = new char[tmplen+1];
          if (tmpname)
          {
            rc = h->GetName(tmpname, tmplen);
            if (rc == NFE_COMPLETED)
            {
              if (incase_comp(fieldname, tmpname) == 0)
                found = TRUE;
            }
            delete[] tmpname;
          }
          else
            rc = NFE_MALLOCFAILED;
        }
      }
      list.Next();
    }
    if (!found)
      h = 0;
  }
    
  return h;
}


/* ************************************************************************** */
/*
   METHOD:         FindHdr
   DESCRIPTION:    Method to find a header of a given type, but called doesn't
   		   what the index position it is.
   DEPENDENCIES:   NONE
   DEPENDED ON BY: 
   INPUT PARAMS:   NFE_HDR_TYPE		t		type of header to look for
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   header*				NULL if not found
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header* headers::FindHdr(NFE_HDR_TYPE t)
{
  int32 unused = 0;
  return FindHdr(t, unused);
}


/* ************************************************************************** */
/*
   METHOD:         GetHdr
   DESCRIPTION:    Method to get the header object at the position pos in the
   		   list.
   DEPENDENCIES:   NONE
   DEPENDED ON BY: 
   INPUT PARAMS:   uint32		pos		index position to get from
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   header*				NULL if not found
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header* headers::GetHdr(uint32 pos)
{
  header *h = 0;
  list.GoTo(pos);
  h = (header*)list.Current();
  return h;
}


// function to write out the object to file
NFE_rcode headers::WriteOut(NFE_CONTEXT &context, clock_t t_slice, FILE *f)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (f)
  {
    list.Start();
    while ((!list.Nul()) && (rc >= NFE_RUNNING))
    {
      header *h = (header*)list.Current();
      if (h)
        rc = h->WriteOut(context, t_slice, f);
      list.Next();
    }
  }
  else
    rc = NFE_NULLADDR;
  
  return rc;
}


// function to write out the object to memory
NFE_rcode headers::WriteOut(NFE_CONTEXT &context, clock_t t_slice, char *mem, uint32 &l)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (mem)
  {
    if (l >= len + 1)
    {
      list.Start();
      while ((!list.Nul()) && (rc >= NFE_RUNNING))
      {
        header *h = (header*)list.Current();
        if (h)
          rc = h->WriteOut(context, t_slice, mem, l);
        list.Next();
      }
    }
    else
    {
      l = len + 1;
      rc = NFE_NOSPACE;
    }
  }
  else
    rc = NFE_NULLADDR;
    
  return rc;
}

// Replace the header at position index with this header
NFE_rcode headers::ReplaceHdr(const header& h, int32 index)
{
  NFE_rcode rc    = NFE_COMPLETED;
  header *current = 0;

  InsertHdr(h, index);						// Insert the header at the requested position
  list.Next();							// Goto the next position, ie. the header we are to replace
  current = (header*)list.Current();				// Get that header
  if (current)							// if we've got it, then
  {
    list.Delete();						// remove it from the list
    delete current;						// destroy that header object
  }

  return rc;
}

// Insert header at position index in the list
NFE_rcode headers::InsertHdr(const header& h, int32 index)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  index--;
  if (index <= 0)
    list.Start();						// make sure the list is at the start
  else								// else
    list.GoTo(index);						// goto the item before the one we are to replace
  list.Insert(&h);						// Insert the replacement header after the current position
  list.Next();							// Goto the next position, ie. the header we've just added

  return rc;
}

// Add header onto the end of the list of headers
NFE_rcode headers::AddHdr(const header& h)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  list.End();
  list.Insert(&h);
  
  return rc;
}

