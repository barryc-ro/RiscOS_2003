/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		contentTE.c
	AUTHOR:		Richard D. Warren
	VERSION:	0.07D for RISC OS

	OVERVIEW
	========
	Source file for implementation of contentTE object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	12/09/97	0.02	RDW	Merged file and memory constructors into one
	26/09/97	0.03	RDW	parsed set to true in constructor when
					object constructed from scratch
	18/02/98	0.04	RDW	#include DebugLib path added
	23/04/98	0.05D	RDW	#ifdef DISPLAY round Display method added
	08/06/98	0.06D	RDW	Modified to use hdr_registry
					common header constructor added
	14/06/98	0.07D	RDW	parsed = true removed from common
					constructor as its not been parsed
					Removed unrequired initialisation of
					data members from contentTE copy
					constructor
					Fixed operator= from header object to
					reset the type data member correctly.
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "contentTE.h"
#include "header.h"
#include "822parser.h"
extern "C"
{
  #include "ELib.h"
  #include "elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New types - Private to this file                                           */
/*                                                                            */
/* ************************************************************************** */
class contentTE_registry : public header_registry
{
  public:
    contentTE_registry();
    header* create_header(bool filebased, char *membase, uint32 offset,
                          uint32 length, bool owner);
    header* create_header(header& h);
};


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */
const char         NFE_HDR_CONTENT_TE_STRING[] = "Content-Transfer-Encoding";	// The header class' header fieldname
contentTE_registry cr;								// The registry object for this header class


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */
contentTE_registry::contentTE_registry() : header_registry()
{
  reg_name  = NFE_HDR_CONTENT_TE_STRING;
}


header* contentTE_registry::create_header(header& h)
{
  return new contentTE(h);
}


header* contentTE_registry::create_header(bool filebased, char *membase,
                                          uint32 offset, uint32 length, bool owner)
{
  return new contentTE(filebased, membase, offset, length, owner);
}


/* ************************************************************************** */
/*
   METHOD:         Constructor for a contentTE object (memory based)
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
contentTE::contentTE(bool f, char *membase, uint32 offset, uint32 length,
                     bool owner)
          :header(f, membase, offset, length, owner),
           encoding(NFE_TE_UNKNOWN),
           parsed(false)
{
  type = cr.GetType();
  if ((owner) && (length==0))
  {
    SetName(NFE_HDR_CONTENT_TE_STRING);
  }
}


contentTE::contentTE(bool f, char *membase, uint32 offset, uint32 length,
                     NFE_TE enc, bool owner)
          :header(f, membase, offset, length, owner),
           encoding(enc),
           parsed(false)
{
  type = cr.GetType();
  if ((owner) && (length==0))
  {
    SetName(NFE_HDR_CONTENT_TE_STRING);
    parsed = true;
  }
}


// copy constructor
contentTE::contentTE(const contentTE &object)
          :header(object)
{
  copycontentTEobject(object);
}


// copy constructor from header object
contentTE::contentTE(const header &object)
          :header(object),
           encoding(NFE_TE_NONE),
           parsed(false)
{
  type = cr.GetType();								// header copy constructor will have reset this, so set it back
}


contentTE &contentTE::operator=(const contentTE &object)
{
  header::operator=(object);
  if (this != &object)
  {
    // do destructor things
    copycontentTEobject(object);
  }
  return *this;
}


contentTE &contentTE::operator=(const header &object)
{
  header::operator=(object);
  if (this != &object)
  {
    // do destructor things
    parsed = false;
    encoding = NFE_TE_UNKNOWN;
    type = cr.GetType();							// header operator= will have reset this, so set this back
  }
  return *this;
}


void contentTE::copycontentTEobject(const contentTE &object)
{
  encoding = object.encoding;
  parsed   = object.parsed;
}


// Implementation of destructor for contentTE
contentTE::~contentTE()
{
  // nothing to do
}


NFE_rcode contentTE::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  bool      error = false;

  if (!header::Parsed())
    rc = header::parse(context, t_slice);
  if (rc != NFE_COMPLETED)
    error = true;

  if (!error)
  {
    uint32 size = 0;
    rc = GetBodyLen(size);
    size+=2;
    char *temp = new char[size];
    if (temp)
    {
      rc = GetUnfoldedNoCommentsBody(temp, size);
      dprintf(("", "GetUnfoldedNoCommentsBody(): %s   size:%d\n", temp, size));
      if (rc == NFE_COMPLETED)
      {
        char *ptr = temp;

        error = consume_all_LWSP(ptr, size);
        if (!error)
        {
          uint32 tsize = size;
          char *tptr = ptr;
          while ((tsize) && (*tptr != '\r'))
          {
            tsize--;
            tptr++;
          }
          if (tsize)
            *tptr=0;
          else
            error = true;
        }
        if (incase_comp("7bit", ptr) == 0)
          encoding = NFE_TE_7BIT;
        else if (incase_comp("8bit", ptr) == 0)
          encoding = NFE_TE_8BIT;
        else if (incase_comp("binary", ptr) == 0)
          encoding = NFE_TE_BINARY;
        else if (incase_comp("quoted-printable", ptr) == 0)
          encoding = NFE_TE_QUOTED_PRINTABLE;
        else if (incase_comp("base64", ptr) == 0)
          encoding = NFE_TE_BASE64;
        else
          encoding = NFE_TE_UNKNOWN;
        delete[] temp;
        temp = 0;
        parsed = true;
      }
    }
    else
      rc = NFE_MALLOCFAILED;
  }

  return rc;
}


#ifdef DISPLAY
void contentTE::Display(void)
{
  header::Display();
  switch (encoding)
  {
    case NFE_TE_7BIT:
      printf("encoding is 7BIT/NONE\n");
      break;
    case NFE_TE_8BIT:
      printf("encoding is 8BIT\n");
      break;
    case NFE_TE_BINARY:
      printf("encoding is BINARY\n");
      break;
    case NFE_TE_QUOTED_PRINTABLE:
      printf("encoding is QUOTED_PRINTABLE\n");
      break;
    case NFE_TE_BASE64:
      printf("encoding is BASE64\n");
      break;
    case NFE_TE_UNKNOWN:
      printf("encoding is UNKNOWN\n");
      break;
    default:
      printf("encoding INTERNALERR\n");
  }
  printf("\n");
}
#endif

NFE_rcode contentTE::GetTE(NFE_TE &enc)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (data_present())
  {
    if (parsed)
    {
      enc = encoding;
    }
    else
      rc = NFE_DATAMUSTBEPARSED;
  }
  else
    rc = NFE_NODATAPRESENT;

  return rc;
}
