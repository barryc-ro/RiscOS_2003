/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		header.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.13D for RISC OS

	OVERVIEW
	========
	Source file for implementation of header object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	09/09/97	0.02	RDW	SetName added and members fieldname and fieldbody added
					default constructor added
	10/09/97	0.03	RDW	SetBody added and WriteOut methods added
	12/09/97	0.04	RDW	Merged file and memory constructors into one
	19/09/97	0.05	RDW	Added support for all the XNetFax headers
	27/09/97	0.06	RDW	Fixed bug in parse method.  Only call next_char method
					if end flag not set to true now.
	01/12/97	0.07	RDW	fixed memory leak in GetNameType
	15/01/98	0.08	RDW	Fixed WriteOut methods so they check return of fwrite
					and see if there is space before doing a strcat
	18/02/98	0.09	RDW	#include DebugLib path added
	20/02/98	0.10	RDW	added support for XNFrtnrcpt
	23/04/98	0.11D	RDW	#ifdef DISPLAY round Display method added
	07/06/98	0.12D	RDW	Modified to use hdr_registry.
					GetNameType() Method removed - redundant.
					SetName() and SetBody() parameter made
					const char*
					GetName(void)
	14/06/98	0.13D	RDW	Removed unrequired initialisation of data members
					from copy constructor
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "header.h"
#include "hdr_reg.h"
#include "elibbase.h"
extern "C"
{
  #include "ELib.h"
  #include "elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New types - Private to this file                                           */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */
const char NFE_HDR_UNKNOWN_STRING[] = "";					// The header class' header fieldname.  Special default case "" as this is the base class
header_registry hr;								// The registry object for this header class


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */
header_registry::header_registry()
{
  reg_name  = NFE_HDR_UNKNOWN_STRING;
  reg_value = hdr_registry::Instance().reg(this);
}


header* header_registry::create_header(header& h)
{
  return new header(h);
}


header* header_registry::create_header(bool filebased, char *membase,
                                       uint32 offset, uint32 length, bool owner)
{
  return new header(filebased, membase, offset, length, owner);
}


NFE_HDR_TYPE header_registry::GetType(void) const
{
  return reg_value;
}


const char* header_registry::GetTypeName(void) const
{
  return reg_name;
}


#ifdef DISPLAY
void header_registry::display_reg_value(void)
{
  printf("NFE_HDR_TYPE value: %d\n", reg_value);
  printf("Field name        : %s\n", reg_name);
}
#endif


/* ************************************************************************** */
/*
   METHOD:         Constructor for a header object (memory based)
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header::header(bool filebased, char *membase, uint32 offset, uint32 length,
               bool owner)
       :elibbase(filebased, membase, offset, length, owner),
        fieldname_start(0),
        fieldname_len(0),
        fieldbody_start(0),
        fieldbody_len(0),
        type(0),
        fieldname(0),
        fieldbody(0)
{
  type = hr.GetType();
}


header::header(void) : elibbase(),
                       fieldname_start(0),
                       fieldname_len(0),
                       fieldbody_start(0),
                       fieldbody_len(0),
                       type(0),
                       fieldname(0),
                       fieldbody(0)
{
  type = hr.GetType();
}


// copy constructor
header::header(const header &object) : elibbase(object)
{
  copyheaderobject(object);
}


// assignment operator
header& header::operator=(const header &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyheaderobject(object);
  }
  return *this;
}


void header::copyheaderobject(const header &object)
{
  fieldname_start = object.fieldname_start;
  fieldname_len   = object.fieldname_len;
  fieldbody_start = object.fieldbody_start;
  fieldbody_len   = object.fieldbody_len;
  type            = object.type;

  if (object.fieldname)
  {
    fieldname = new char[strlen(object.fieldname)+1];
    if (fieldname) strcpy(fieldname, object.fieldname);
  }
  else
    fieldname = 0;

  if (object.fieldbody)
  {
    fieldbody = new char[strlen(object.fieldbody)+1];
    if (fieldbody) strcpy(fieldbody, object.fieldbody);
  }
  else
    fieldbody = 0;
}


// Implementation of destructor for header
header::~header()
{
  // nothing to do
  if (fieldname)	delete[] fieldname;
  if (fieldbody)	delete[] fieldbody;
}


NFE_rcode header::GetName(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;

  rc = param_check_Get(n, length);
  if (rc >= 0)
  {
    if (length < fieldname_len+1)
      rc = NFE_NOSPACE;
    else
    {
      n = get_data(fieldname_start, fieldname_len, n);
      if (!n)
        rc = NFE_FAILED;
    }
  }
  length = fieldname_len+1;

  return rc;
}


char* header::GetName(void) const
{
  NFE_rcode  rc      = NFE_COMPLETED;
  char      *tmpname = 0;
  uint32     tmplen  = 0;

  rc = GetNameLen(tmplen);
  if (rc == NFE_COMPLETED)
  {
    tmplen+=2;
    tmpname = new char[tmplen+1];
    if (tmpname)
    {
      rc = GetName(tmpname, tmplen);
      if (rc != NFE_COMPLETED)
      {
        delete[] tmpname;
        tmpname = 0;
      }
    }
  }

  return tmpname;
}

NFE_rcode header::GetRealBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;

  rc = param_check_Get(n, length);

  if (rc >= 0)
  {
    if (length < fieldbody_len+1)
      rc = NFE_NOSPACE;
    else
    {
      n = get_data(fieldbody_start, fieldbody_len, n);
      if (!n)
        rc = NFE_FAILED;
    }
  }
  length = fieldbody_len+1;

  return rc;
}


NFE_rcode header::GetUnfoldedBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  bool   error = false;

  rc = GetRealBody(n, length);
  dprintf(("", "header::GetUnfoldedBody:GetRealBody: %d %s\n", length, n));
  if (rc == NFE_COMPLETED)
  {
    uint32  i     = 0;
    char   *pos   = n;

    while ((pos<(n+length)) && (i<length) && (!error))
    {
      if ( ((*(pos) == '\r') && (*(pos+1) == '\n')) &&
           ((*(pos+2) == 32) || (*(pos+2) == '\t')))
      {
        dprintf(("", "in remove LWS\n"));
        n[i] = 32;								// convert <CRLF><LWS> to <SPACE>
        i++;
        pos+=2;
        while (( (*(pos) == 32) ||
                 (*(pos) == '\t')
               ) &&
               (!error))						// skip over extra <LWS>
        {
          dprintf(("", "in remove LWS LOOP\n"));
          if ((pos>n+length) || (i>length))
          {
            dprintf(("", "header::GetUnfoldedBody ERROR\n"));
            error = true;
            rc = NFE_FAILED;
          }
          pos++;
        }
      }
      if (!error)
      {
        dprintf(("", "header::GetUnfoldedBody:pos: %c %d\n", *pos, *pos));
        n[i] = *pos;
        i++;
        pos++;
      }
    }
    if (!error)
      n[i] = 0;
  }
  else
    error = true;
  if (error)
    length = fieldbody_len + 1;
  else
    length = strlen(n) + 1;

  return rc;
}


NFE_rcode header::GetUnfoldedNoCommentsBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  bool   error = false;

  rc = GetUnfoldedBody(n, length);
  dprintf(("", "header::GetUnfoldedNoCommentsBody:GetUnfoldedBody: %d %s\n", length, n));
  if (rc == NFE_COMPLETED)
  {
    uint32  i     = 0;
    char   *pos   = n;
    bool inquotes = false;

    while ((pos<(n+length)) && (i<length) && (!error))
    {
      if (*pos == '"')
      {
        if (!inquotes)
          inquotes = true;
        else
          inquotes = false;
      }
      if ((*pos == '(') && (!inquotes))
      {
        dprintf(("", "in remove COMMENT\n"));
        while ((*pos != ')') && (!error))						// skip over extra <LWS>
        {
          dprintf(("", "in remove COMMENT LOOP\n"));
          if ((pos>(n+length)) || (i>length))
          {
            dprintf(("", "header::GetUnfoldedNoCommentsBody ERROR\n"));
            error = true;
            rc = NFE_FAILED;
          }
          pos++;
        }
        pos++;
        dprintf(("", "n[i]: %d  *pos: %d\n", n[i], *pos));
        if (((n[i-1] == 32) || (n[i-1] == '\t')) && ((*pos == 32) || (*pos == '\t')))
          pos++;
      }
      if (!error)
      {
        dprintf(("", "header::GetUnfoldedNoCommentsBody:pos: %c %d\n", *pos, *pos));
        n[i] = *pos;
        i++;
        pos++;
      }
    }
    if (!error)
      n[i] = 0;
  }
  else
    error = true;
  if (error)
    length = fieldbody_len + 1;
  else
    length = strlen(n) + 1;

  return rc;
}


NFE_rcode header::param_check_Get(char *n, uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;

  if (!n)
    rc = NFE_NULLADDR;

  if (rc >= 0)
    if (len == 0)
      rc = NFE_NOSPACE;

  if (!data_present())
    rc = NFE_NODATAPRESENT;

  if (rc >= 0)
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
  }

  return rc;
}


NFE_rcode header::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  bool      error = false;

  bool startok = goto_start();
  if (!startok)
    error = true;
  if ((error) && (file))
    rc = NFE_INVALIDFILENAME;
  else
  {
    fieldname_start = curpos;							// fieldname must start at the start of the header field
    // traverse until ':' found or CRLF(error) of we go off the end of the data
    while ( (curchar != ':') && (!error))
    {
      dprintf(("", "header: curchar: %c\n", curchar));
      if ((iscntrl(curchar)) || (curchar == 32) || (end_of_data()) )
        error = true;
      next_char();
    }
  }

  if (!error)
  {
    fieldname_len = curpos;
    next_char();								// consume the ':'
    while ( (isspace(curchar)) && (!end_of_data()) )				// traverse until !whitespace found
      next_char();
    fieldbody_start = curpos;							// set fieldbody_start
  }

  // traverse until CRLF and next char not a LWSP char
  dprintf(("", "parse body\n"));
  bool end = false;
  while ((!end) && (!error))
  {
    dprintf(("", "headerbody: current char: %c\n", curchar));
    int32 r = compare_current_pos("\r\n\x20");
    int32 s = compare_current_pos("\r\n\t");

    if ((r == 0) || (s == 0))							// if we are currently pointing at <CRLF><SPACE> or <CRLF><TAB>, then
      end = false;
    else if ((r < 0) || (s < 0))
      error = true;
    else
    {
      int32 r = compare_current_pos("\r\n");
      if (r == 0)
        end = true;
      else if (r < 0)
        error = true;
    }
    if (!end)
      next_char();
    if (end_of_data())
      error = true;
  }
  if (end)
    error = false;
  dprintf(("","body error %d\n", error));
  if (!error)
  {
    fieldbody_len = curpos - fieldbody_start;					// set fieldbody_len
    len = curpos  + 2;							// set length to actual length of header field
  }
  dprintf(("", "fieldbody_len: %d\n", fieldbody_len));
  stop();									// we've stopped processing data, tidy up by closing file if this is a file version

  if ((error) && (rc == NFE_COMPLETED))
    rc = NFE_FAILED;
  else
    parsed = true;

  return rc;
}


NFE_rcode header::GetNameLen(uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;

  if (data_present())
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
    else
      len = fieldname_len;
  }
  else
    rc = NFE_NODATAPRESENT;

  return rc;
}


NFE_rcode header::GetBodyLen(uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;

  if (data_present())
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
    else
      len = fieldbody_len;
  }
  else
    rc = NFE_NODATAPRESENT;

  return rc;
}


#ifdef DISPLAY
void header::Display(void)
{
  uint32 i;

  bool startok = goto_pos(fieldname_start);
  if (startok)
  {
    printf("HEADER: ");
    for (i = 0; i<fieldname_len; i++)
    {
      printf("%c", curchar);
      next_char();
    }
    printf("\nBODY: ");
  }
  startok = goto_pos(fieldbody_start);
  {
    for (i = 0; i<fieldbody_len; i++)
    {
      printf("%c", curchar);
      next_char();
    }
    printf("\n");
    stop();
  }
}
#endif


NFE_rcode header::SetName(const char *c)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (c)
  {
    if (file)
    {
      rc = NFE_FAILED;			// I'M NOT GOING TO SUPPORT A FILE VERSION OF HEADERS FOR CREATION OR UPDATE JUST NOW!  USE MEMORY, HDRS ARE SMALL!
/*      if (mem_base)			// check we have a filename
      {

        fd = fopen(filename, "wb");	// openfile for writing and wipe it clean
        if (fd)				// if opened OK then
        {

        }
        else				// else
          rc = NFE_WRITEFAIL;		// return error can't open file
      }
      else
        rc = NFE_INVALIDFILENAME;*/
    }
    else
    {
      char *new_memory = 0;							// temp pointer to new memory block

      mem_size = strlen(c)+2+fieldbody_len+4;					// calculate storage fieldname length +':'+' '+fieldbody_len+CRLF+NULLCHAR
      new_memory = new char[mem_size];						// allocate space
      if (new_memory)								// if storage allocated OK, then
      {
        sprintf(new_memory, "%s: ", c);						// copy in new field name
        if (fieldbody_len)							// if fieldbody present in old memory, then
          strncat(new_memory, mem_base+start+fieldbody_start, fieldbody_len);	// copy in old fieldbody into new memory
        strcat(new_memory, "\r\n");						// write in terminating in CRLF+NULLCHAR
        start = 0;								// start offset is 0 as we own this memory
        len = mem_size-1;							// set length to size of the memory area (-1 for the NULLCHAR)
        fieldname_start = 0;							// start of fieldname is at the start of the memory
        fieldname_len   = strlen(c);						// set length of fieldname
        if (fieldbody_len)							// if fieldbody present, then
          fieldbody_start = fieldname_len+2;					// set fieldbody start to the new correct offset
        fieldbody_len   = fieldbody_len;					// set fieldbody len as before
        parsed = true;								// parsed = true as all the offsets above are now correct

        if ((mem_base) && (ownership))						// if there was previous storage and we owned it, then
          delete[] mem_base;							// delete it
        mem_base = new_memory;							// use the new memory
        ownership = true;							// set ownership as we own this new memory
      }
      else
        rc = NFE_MALLOCFAILED;
    } // endif memory version
  }
  else
    rc = NFE_NULLADDR;								// c parameter is NULL, so return error

  return rc;
}


NFE_rcode header::SetBody(const char *c)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (c)
  {
    if (file)
    {
      rc = NFE_FAILED;			// I'M NOT GOING TO SUPPORT A FILE VERSION OF HEADERS FOR CREATION OR UPDATE JUST NOW!  USE MEMORY, HDRS ARE SMALL!
/*      if (mem_base)			// check we have a filename
      {

        fd = fopen(filename, "wb");	// openfile for writing and wipe it clean
        if (fd)				// if opened OK then
        {

        }
        else				// else
          rc = NFE_WRITEFAIL;		// return error can't open file
      }
      else
        rc = NFE_INVALIDFILENAME;*/
    }
    else
    {
      char *new_memory = 0;							// temp pointer to new memory block

      mem_size = fieldname_len+2+strlen(c)+4;					// calculate storage fieldname_len+':'+' '+fieldbody length+CRLF+NULLCHAR
      new_memory = new char[mem_size];						// allocate space
      if (new_memory)								// if storage allocated OK, then
      {
        if (fieldname_len)							// if fieldname present in old memory, then
        {
          strncpy(new_memory, mem_base+start+fieldname_start, fieldname_len);	// copy in old fieldname into new memory
          new_memory[fieldname_len] = 0;
        }
        strcat(new_memory, c);							// copy in new field body
        strcat(new_memory, "\r\n");						// write in terminating in CRLF+NULLCHAR
        start = 0;								// start offset is 0 as we own this memory
        len = mem_size-1;							// set length to size of the memory area (-1 for the NULLCHAR)
        fieldname_start = fieldname_start;					// start of fieldname is as before
        fieldname_len   = fieldname_len;					// set length of fieldname as before
        fieldbody_start = fieldname_start+fieldname_len;			// set fieldbody start
        fieldbody_len   = strlen(c);						// set fieldbody len to length of new fieldbody
        parsed = true;								// parsed = true as all the offsets above are now correct

        if ((mem_base) && (ownership))						// if there was previous storage and we owned it, then
          delete[] mem_base;							// delete it
        mem_base = new_memory;							// use the new memory
        ownership = true;							// set ownership as we own this new memory
      }
      else
        rc = NFE_MALLOCFAILED;
    } // endif memory version
  }
  else
    rc = NFE_NULLADDR;								// c parameter is NULL, so return error

  return rc;
}


// function to write out the object to file
NFE_rcode header::WriteOut(NFE_CONTEXT &context, clock_t t_slice, FILE *f)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (f)
  {
    rc = write_to_file(context, t_slice, f, fieldname_start, fieldname_len);
    if (rc == NFE_COMPLETED)
    {
      if (fwrite(": ", 2, 1, f) != 1)
        rc = NFE_WRITEFAIL;
    }
    if (rc == NFE_COMPLETED)
      rc = write_to_file(context, t_slice, f, fieldbody_start, fieldbody_len);
    if (rc == NFE_COMPLETED)
    {
      if (fwrite("\r\n", 2, 1, f) != 1)
        rc = NFE_WRITEFAIL;
    }
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


// function to write out the object to memory
NFE_rcode header::WriteOut(NFE_CONTEXT &context, clock_t t_slice, char *mem, uint32 &l)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (mem)
  {
    if (l >= fieldname_len + 2 + fieldbody_len + 3)
    {
      rc = write_to_mem(context, t_slice, mem, l, fieldname_start, fieldname_len);
      if (rc == NFE_COMPLETED)
      {
        if (l >= 3)
        {
          strcat(mem, ": ");
          l -= 2;
        }
        else
          rc = NFE_WRITEFAIL;
      }
      if (rc == NFE_COMPLETED)
        write_to_mem(context, t_slice, mem, l, fieldbody_start, fieldbody_len);
      if (rc == NFE_COMPLETED)
      {
        if (l >= 3)
        {
          strcat(mem, "\r\n");
          l -= 2;
        }
        else
          rc= NFE_WRITEFAIL;
      }
    }
    else
    {
      l = fieldname_len + 2 + fieldbody_len + 3;
      rc = NFE_NOSPACE;
    }
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}

