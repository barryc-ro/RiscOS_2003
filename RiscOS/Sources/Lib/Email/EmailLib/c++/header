/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		header.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.09 for RISC OS

	OVERVIEW
	========
	Source file for implementation of header object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	09/09/97	0.02	RDW	SetName added and members fieldname and fieldbody added
					default constructor added
	10/09/97	0.03	RDW	SetBody added and WriteOut methods added
	12/09/97	0.04	RDW	Merged file and memory constructors into one
	19/09/97	0.05	RDW	Added support for all the XNetFax headers
	27/09/97	0.06	RDW	Fixed bug in parse method.  Only call next_char method
					if end flag not set to TRUE now.
	01/12/97	0.07	RDW	fixed memory leak in GetNameType
	15/01/98	0.08	RDW	Fixed WriteOut methods so they check return of fwrite
					and see if there is space before doing a strcat
	18/02/98	0.09	RDW	#include DebugLib path added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "header.h"
#include "elibbase.h"
extern "C"
{
  #include "ELib.h"
  #include "elib_priv.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a header object (memory based)
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
header::header(BOOL f, char *membase, uint32 offset, uint32 length, NFE_HDR_TYPE t, BOOL owner) : elibbase(f, membase, offset, length, owner),
                                           fieldname_start(0),
                                           fieldname_len(0),
                                           fieldbody_start(0),
                                           fieldbody_len(0),
                                           type(t),
                                           fieldname(0),
                                           fieldbody(0)
{
  
}


header::header(void) : elibbase(),
                       fieldname_start(0),
                       fieldname_len(0),
                       fieldbody_start(0),
                       fieldbody_len(0),
                       type(NFE_HDR_UNKNOWN),
                       fieldname(0),
                       fieldbody(0)
{
  
}


// copy constructor
header::header(const header &object) : elibbase(object),
                                           fieldname_start(0),
                                           fieldname_len(0),
                                           fieldbody_start(0),
                                           fieldbody_len(0),
                                           type(NFE_HDR_UNKNOWN),
                                           fieldname(0),
                                           fieldbody(0)
{
  copyheaderobject(object);
}


/*// constructor, file version
header::header(char *filename, uint32 offset, NFE_HDR_TYPE t, BOOL owner) : elibbase(filename, offset, 0, TRUE, owner),
                                           fieldname_start(0),
                                           fieldname_len(0),
                                           fieldbody_start(0),
                                           fieldbody_len(0),
                                           type(t),
                                           fieldname(0),
                                           fieldbody(0)
{
  
}
*/

// assignment operator
header& header::operator=(const header &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyheaderobject(object);
  }
  return *this;
}


void header::copyheaderobject(const header &object)
{
  fieldname_start = object.fieldname_start;
  fieldname_len = object.fieldname_len;
  fieldbody_start = object.fieldbody_start;
  fieldbody_len = object.fieldbody_len;
  type = object.type;
  if (object.fieldname)
  {
    fieldname = new char[strlen(object.fieldname)+1];
    if (fieldname) strcpy(fieldname, object.fieldname);
  }
  if (object.fieldbody)
  {
    fieldbody = new char[strlen(object.fieldbody)+1];
    if (fieldbody) strcpy(fieldbody, object.fieldbody);
  }
}


// Implementation of destructor for header
header::~header()
{
  // nothing to do
  if (fieldname)	delete[] fieldname;
  if (fieldbody)	delete[] fieldbody;
}


NFE_rcode header::GetName(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  rc = param_check_Get(n, length);
  if (rc >= 0)
  {
    if (length < fieldname_len+1)
      rc = NFE_NOSPACE;
    else
    {
      n = get_data(fieldname_start, fieldname_len, n);
      if (!n)
        rc = NFE_FAILED;
    }
  }
  length = fieldname_len+1;

  return rc;
}


NFE_HDR_TYPE header::GetNameType(void)
{
  NFE_HDR_TYPE hdrtype = NFE_HDR_UNKNOWN;
  
  if ((data_present()) && (parsed))
  {
    uint32 l = fieldname_len+1;
    char *name = new char[l];
    if (name)
    {
      if (GetName(name, l) == NFE_COMPLETED)
      {
        dprintf(("", "GetNameType:name: %s\n", name));
        // case insensitive compare between name and defined header names
        if (incase_comp("Date", name) == 0)
          hdrtype = NFE_HDR_DATE;
        else if (incase_comp("Resent-Date", name) == 0)
          hdrtype = NFE_HDR_RESENT_DATE;
        else if (incase_comp("Subject", name) == 0)
          hdrtype = NFE_HDR_SUBJECT;
        else if (incase_comp("From", name) == 0)
          hdrtype = NFE_HDR_FROM;
        else if (incase_comp("To", name) == 0)
          hdrtype = NFE_HDR_TO;
        else if (incase_comp("Reply-To", name) == 0)
          hdrtype = NFE_HDR_REPLY_TO;
        else if (incase_comp("Message-ID", name) == 0)
          hdrtype = NFE_HDR_MESSAGE_ID;
        else if (incase_comp("MIME-Version", name) == 0)
          hdrtype = NFE_HDR_MIME_VERSION;
        else if (incase_comp("Content-Transfer-Encoding", name) == 0)
          hdrtype = NFE_HDR_CONTENT_TRANSFER_ENCODING;
        else if (incase_comp("Content-Type", name) == 0)
          hdrtype = NFE_HDR_CONTENT_TYPE;
        else if (incase_comp("X-NetFax-Fax-Pages", name) == 0)
          hdrtype = NFE_HDR_X_NF_FAX_PAGES;
        else if (incase_comp("X-NetFax-Serial", name) == 0)
          hdrtype = NFE_HDR_X_NF_SERIAL;
        else if (incase_comp("X-NetFax-Software-Rev", name) == 0)
          hdrtype = NFE_HDR_X_NF_SOFTWARE_REV;
        else if (incase_comp("X-NetFax-Message-Class", name) == 0)
          hdrtype = NFE_HDR_X_NF_MESSAGE_CLASS;
        else if (incase_comp("X-Organization", name) == 0)
          hdrtype = NFE_HDR_X_ORGANIZATION;
        else if (incase_comp("X-NetFax-Fax-Number", name) == 0)
          hdrtype = NFE_HDR_X_NF_FAX_NUMBER;
        else if (incase_comp("X-NetFax-Phone-Number", name) == 0)
          hdrtype = NFE_HDR_X_NF_PHONE_NUMBER;
        else if (incase_comp("X-NetFax-Device", name) == 0)
          hdrtype = NFE_HDR_X_NF_DEVICE;
        else if (incase_comp("X-NetFax-Device-Class", name) == 0)
          hdrtype = NFE_HDR_X_NF_DEVICE_CLASS;
        else
          hdrtype = NFE_HDR_UNKNOWN;
      } // endif GetName()
      delete[] name;
    } // endif name
  }
  return hdrtype;
}


NFE_rcode header::GetRealBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  rc = param_check_Get(n, length);
  
  if (rc >= 0)
  {
    if (length < fieldbody_len+1)
      rc = NFE_NOSPACE;
    else
    {
      n = get_data(fieldbody_start, fieldbody_len, n);
      if (!n)
        rc = NFE_FAILED;
    }
  }
  length = fieldbody_len+1;
  
  return rc;
}


NFE_rcode header::GetUnfoldedBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  BOOL   error = FALSE;
  
  rc = GetRealBody(n, length);
  dprintf(("", "header::GetUnfoldedBody:GetRealBody: %d %s\n", length, n));
  if (rc == NFE_COMPLETED)
  {
    uint32  i     = 0;
    char   *pos   = n;
    
    while ((pos<(n+length)) && (i<length) && (!error))
    {
      if ( ((*(pos) == '\r') && (*(pos+1) == '\n')) &&
           ((*(pos+2) == 32) || (*(pos+2) == '\t')))
      {
        dprintf(("", "in remove LWS\n"));
        n[i] = 32;								// convert <CRLF><LWS> to <SPACE>
        i++;
        pos+=2;
        while (( (*(pos) == 32) ||
                 (*(pos) == '\t')
               ) &&
               (!error))						// skip over extra <LWS>
        {
          dprintf(("", "in remove LWS LOOP\n"));
          if ((pos>n+length) || (i>length))
          {
            dprintf(("", "header::GetUnfoldedBody ERROR\n"));
            error = TRUE;
            rc = NFE_FAILED;
          }
          pos++;
        }
      }
      if (!error)
      {
        dprintf(("", "header::GetUnfoldedBody:pos: %c %d\n", *pos, *pos));
        n[i] = *pos;
        i++;
        pos++;
      }
    }
    if (!error)
      n[i] = 0;
  }
  else
    error = TRUE;
  if (error)
    length = fieldbody_len + 1;
  else
    length = strlen(n) + 1;
  
  return rc;
}


NFE_rcode header::GetUnfoldedNoCommentsBody(char *n, uint32 &length) const
{
  NFE_rcode rc = NFE_COMPLETED;
  BOOL   error = FALSE;
  
  rc = GetUnfoldedBody(n, length);
  dprintf(("", "header::GetUnfoldedNoCommentsBody:GetUnfoldedBody: %d %s\n", length, n));  
  if (rc == NFE_COMPLETED)
  {
    uint32  i     = 0;
    char   *pos   = n;
    BOOL inquotes = FALSE;
    
    while ((pos<(n+length)) && (i<length) && (!error))
    {
      if (*pos == '"')
      {
        if (!inquotes)
          inquotes = TRUE;
        else
          inquotes = FALSE;
      }
      if ((*pos == '(') && (!inquotes))
      {
        dprintf(("", "in remove COMMENT\n"));
        while ((*pos != ')') && (!error))						// skip over extra <LWS>
        {
          dprintf(("", "in remove COMMENT LOOP\n"));
          if ((pos>(n+length)) || (i>length))
          {
            dprintf(("", "header::GetUnfoldedNoCommentsBody ERROR\n"));
            error = TRUE;
            rc = NFE_FAILED;
          }
          pos++;
        }
        pos++;
        dprintf(("", "n[i]: %d  *pos: %d\n", n[i], *pos));
        if (((n[i-1] == 32) || (n[i-1] == '\t')) && ((*pos == 32) || (*pos == '\t')))
          pos++;
      }
      if (!error)
      {
        dprintf(("", "header::GetUnfoldedNoCommentsBody:pos: %c %d\n", *pos, *pos));
        n[i] = *pos;
        i++;
        pos++;
      }
    }
    if (!error)
      n[i] = 0;
  }
  else
    error = TRUE;
  if (error)
    length = fieldbody_len + 1;
  else
    length = strlen(n) + 1;
  
  return rc;
}


NFE_rcode header::param_check_Get(char *n, uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (!n)
    rc = NFE_NULLADDR;
  
  if (rc >= 0)
    if (len == 0)
      rc = NFE_NOSPACE;
  
  if (!data_present())
    rc = NFE_NODATAPRESENT;
  
  if (rc >= 0)
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
  }
  
  return rc;
}


NFE_rcode header::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  BOOL      error = FALSE;

  BOOL startok = goto_start();
  if (!startok)
    error = TRUE;
  if ((error) && (file))
    rc = NFE_INVALIDFILENAME;
  else
  {
    fieldname_start = curpos;							// fieldname must start at the start of the header field
    // traverse until ':' found or CRLF(error) of we go off the end of the data
    while ( (curchar != ':') && (!error))
    {
      dprintf(("", "header: curchar: %c\n", curchar));
      if ((iscntrl(curchar)) || (curchar == 32) || (end_of_data()) )
        error = TRUE;
      next_char();
    }
  }
  
  if (!error)
  {
    fieldname_len = curpos;
    next_char();								// consume the ':'
    while ( (isspace(curchar)) && (!end_of_data()) )				// traverse until !whitespace found
      next_char();  
    fieldbody_start = curpos;							// set fieldbody_start
  }
  
  // traverse until CRLF and next char not a LWSP char
  dprintf(("", "parse body\n"));
  BOOL end = FALSE;
  while ((!end) && (!error))
  {
    dprintf(("", "headerbody: current char: %c\n", curchar));
    int32 r = compare_current_pos("\r\n\x20");
    int32 s = compare_current_pos("\r\n\t");
    
    if ((r == 0) || (s == 0))							// if we are currently pointing at <CRLF><SPACE> or <CRLF><TAB>, then
      end = FALSE;
    else if ((r < 0) || (s < 0))
      error = TRUE;
    else
    {
      int32 r = compare_current_pos("\r\n");
      if (r == 0)
        end = TRUE;
      else if (r < 0)
        error = TRUE;
    }
    if (!end)
      next_char();
    if (end_of_data())
      error = TRUE;
  }
  if (end)
    error = FALSE;
  dprintf(("","body error %d\n", error));
  if (!error)
  {
    fieldbody_len = curpos - fieldbody_start;					// set fieldbody_len
    len = curpos  + 2;							// set length to actual length of header field
  }
  dprintf(("", "fieldbody_len: %d\n", fieldbody_len));
  stop();									// we've stopped processing data, tidy up by closing file if this is a file version
  
  if ((error) && (rc == NFE_COMPLETED))
    rc = NFE_FAILED;
  else
    parsed = TRUE;
    
  return rc;
}


NFE_rcode header::GetNameLen(uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (data_present())
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
    else
      len = fieldname_len;
  }
  else
    rc = NFE_NODATAPRESENT;
  
  return rc;
}


NFE_rcode header::GetBodyLen(uint32 &len) const
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (data_present())
  {
    if (!parsed)
      rc = NFE_DATAMUSTBEPARSED;
    else
      len = fieldbody_len;
  }
  else
    rc = NFE_NODATAPRESENT;
  
  return rc;
}


void header::Display(void)
{
  uint32 i;
  
  BOOL startok = goto_pos(fieldname_start);
  if (startok)
  {
    printf("HEADER: ");
    for (i = 0; i<fieldname_len; i++)
    {
      printf("%c", curchar);
      next_char();
    }
    printf("\nBODY: ");
  }
  startok = goto_pos(fieldbody_start);
  {
    for (i = 0; i<fieldbody_len; i++)
    {
      printf("%c", curchar);
      next_char();
    }
    printf("\n");
    stop();
  }
}


NFE_rcode header::SetName(char *c)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (c)
  {
    if (file)
    {
      rc = NFE_FAILED;			// I'M NOT GOING TO SUPPORT A FILE VERSION OF HEADERS FOR CREATION OR UPDATE JUST NOW!  USE MEMORY, HDRS ARE SMALL!
/*      if (mem_base)			// check we have a filename
      {
        
        fd = fopen(filename, "wb");	// openfile for writing and wipe it clean
        if (fd)				// if opened OK then
        {
          
        }
        else				// else
          rc = NFE_WRITEFAIL;		// return error can't open file
      }
      else
        rc = NFE_INVALIDFILENAME;*/
    }
    else
    {
      char *new_memory = 0;							// temp pointer to new memory block

      mem_size = strlen(c)+2+fieldbody_len+4;					// calculate storage fieldname length +':'+' '+fieldbody_len+CRLF+NULLCHAR
      new_memory = new char[mem_size];						// allocate space
      if (new_memory)								// if storage allocated OK, then
      {
        sprintf(new_memory, "%s: ", c);						// copy in new field name
        if (fieldbody_len)							// if fieldbody present in old memory, then
          strncat(new_memory, mem_base+start+fieldbody_start, fieldbody_len);	// copy in old fieldbody into new memory
        strcat(new_memory, "\r\n");						// write in terminating in CRLF+NULLCHAR
        start = 0;								// start offset is 0 as we own this memory
        len = mem_size-1;							// set length to size of the memory area (-1 for the NULLCHAR)
        fieldname_start = 0;							// start of fieldname is at the start of the memory
        fieldname_len   = strlen(c);						// set length of fieldname
        if (fieldbody_len)							// if fieldbody present, then
          fieldbody_start = fieldname_len+2;					// set fieldbody start to the new correct offset
        fieldbody_len   = fieldbody_len;					// set fieldbody len as before
        parsed = TRUE;								// parsed = TRUE as all the offsets above are now correct

        if ((mem_base) && (ownership))						// if there was previous storage and we owned it, then
          delete[] mem_base;							// delete it
        mem_base = new_memory;							// use the new memory
        ownership = TRUE;							// set ownership as we own this new memory
      }
      else
        rc = NFE_MALLOCFAILED;
    } // endif memory version
  }
  else
    rc = NFE_NULLADDR;								// c parameter is NULL, so return error
    
  return rc;
}


NFE_rcode header::SetBody(char *c)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (c)
  {
    if (file)
    {
      rc = NFE_FAILED;			// I'M NOT GOING TO SUPPORT A FILE VERSION OF HEADERS FOR CREATION OR UPDATE JUST NOW!  USE MEMORY, HDRS ARE SMALL!
/*      if (mem_base)			// check we have a filename
      {
        
        fd = fopen(filename, "wb");	// openfile for writing and wipe it clean
        if (fd)				// if opened OK then
        {
          
        }
        else				// else
          rc = NFE_WRITEFAIL;		// return error can't open file
      }
      else
        rc = NFE_INVALIDFILENAME;*/
    }
    else
    {
      char *new_memory = 0;							// temp pointer to new memory block

      mem_size = fieldname_len+2+strlen(c)+4;					// calculate storage fieldname_len+':'+' '+fieldbody length+CRLF+NULLCHAR
      new_memory = new char[mem_size];						// allocate space
      if (new_memory)								// if storage allocated OK, then
      {
        if (fieldname_len)							// if fieldname present in old memory, then
        {
          strncpy(new_memory, mem_base+start+fieldname_start, fieldname_len);	// copy in old fieldname into new memory
          new_memory[fieldname_len] = 0;
        }
        strcat(new_memory, c);							// copy in new field body
        strcat(new_memory, "\r\n");						// write in terminating in CRLF+NULLCHAR
        start = 0;								// start offset is 0 as we own this memory
        len = mem_size-1;							// set length to size of the memory area (-1 for the NULLCHAR)
        fieldname_start = fieldname_start;					// start of fieldname is as before
        fieldname_len   = fieldname_len;					// set length of fieldname as before
        fieldbody_start = fieldname_start+fieldname_len;			// set fieldbody start
        fieldbody_len   = strlen(c);						// set fieldbody len to length of new fieldbody
        parsed = TRUE;								// parsed = TRUE as all the offsets above are now correct

        if ((mem_base) && (ownership))						// if there was previous storage and we owned it, then
          delete[] mem_base;							// delete it
        mem_base = new_memory;							// use the new memory
        ownership = TRUE;							// set ownership as we own this new memory
      }
      else
        rc = NFE_MALLOCFAILED;
    } // endif memory version
  }
  else
    rc = NFE_NULLADDR;								// c parameter is NULL, so return error
    
  return rc;
}


// function to write out the object to file
NFE_rcode header::WriteOut(NFE_CONTEXT &context, clock_t t_slice, FILE *f)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (f)
  {
    rc = write_to_file(context, t_slice, f, fieldname_start, fieldname_len);
    if (rc == NFE_COMPLETED)
    {
      if (fwrite(": ", 2, 1, f) != 1)
        rc = NFE_WRITEFAIL;
    }
    if (rc == NFE_COMPLETED)
      rc = write_to_file(context, t_slice, f, fieldbody_start, fieldbody_len);
    if (rc == NFE_COMPLETED)
    {
      if (fwrite("\r\n", 2, 1, f) != 1)
        rc = NFE_WRITEFAIL;
    }
  }
  else
    rc = NFE_NULLADDR;
  
  return rc;
}


// function to write out the object to memory
NFE_rcode header::WriteOut(NFE_CONTEXT &context, clock_t t_slice, char *mem, uint32 &l)
{
  NFE_rcode rc = NFE_COMPLETED;
  
  if (mem)
  {
    if (l >= fieldname_len + 2 + fieldbody_len + 3)
    {
      rc = write_to_mem(context, t_slice, mem, l, fieldname_start, fieldname_len);
      if (rc == NFE_COMPLETED)
      {
        if (l >= 3)
        {
          strcat(mem, ": ");
          l -= 2;
        }
        else
          rc = NFE_WRITEFAIL;
      }
      if (rc == NFE_COMPLETED)
        write_to_mem(context, t_slice, mem, l, fieldbody_start, fieldbody_len);
      if (rc == NFE_COMPLETED)
      {
        if (l >= 3)
        {
          strcat(mem, "\r\n");
          l -= 2;
        }
        else
          rc= NFE_WRITEFAIL;
      }
    }
    else
    {
      l = fieldname_len + 2 + fieldbody_len + 3;
      rc = NFE_NOSPACE;
    }
  }
  else
    rc = NFE_NULLADDR;
    
  return rc;
}

