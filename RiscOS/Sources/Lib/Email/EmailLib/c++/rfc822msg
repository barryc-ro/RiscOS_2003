/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		rfc822msg.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.07 for RISC OS

	OVERVIEW
	========
	Source file for implementation of entity object

	HISTORY
	=======
	12/09/97	0.01	RDW	initial version
					Merged file and memory constructors into one
	19/09/97	0.02	RDW	Added to parse function so that it detects if
					the message is MIME conformant and then goes
					ahead and creates a MIMEentity and parses it
	21/09/97	0.03	RDW	added operator+= so that it adds a MIME-Version
					header
	22/09/97	0.04	RDW	Correct mistake in parse method where
					creating specific MIME object wrong variable
					(mime_obj) was used instead of (mime_obj2)
	09/01/98	0.05	RDW	parse method was missing support for MIMEtext
	21/01/98	0.06	RDW	parse method modified to copy with non-fatal
					errors returned by ParseData methods of
					MIMEentities
	18/02/98	0.07	RDW	#include DebugLib path added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "rfc822msg.h"
#include "entity.h"
#include "to.h"
#include "from.h"
#include "date.h"
#include "mimevers.h"
#include "MIMEentity.h"
#include "MIMEimage.h"
#include "MIMEtext.h"
#include "MIMEmultip.h"
extern "C"
{
  #include "ELib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a entity object 
   DESCRIPTION:    
   DEPENDENCIES:   
   DEPENDED ON BY: 
   INPUT PARAMS:   
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
rfc822msg::rfc822msg(BOOL f, char *membase, uint32 offset, uint32 length, BOOL owner) : entity(f, membase, offset, length, NFE_ENTITY_RFC822MSG, owner),
       to_index(-1),
       from_index(-1),
       date_index(-1),
       mime_obj(0)
{
  if ((owner) && (length == 0))
  {
    NFE_rcode rc = NFE_COMPLETED;
    
    date *d = new date(FALSE, 0, 0, 0, TRUE);
    if (d)
    {
      if (the_headers)
      {
        rc = the_headers->AddHdr(*d);
        if (rc != NFE_COMPLETED)
          delete d;
      }
      else
        delete d;
    }
    mimevers *mv = new mimevers(FALSE, 0, 0, 0, TRUE);
    if (mv)
    {
      if (the_headers)
      {
        rc = the_headers->AddHdr(*mv);
        if (rc != NFE_COMPLETED)
          delete mv;
      }
    }
  }
}


// copy constructor
rfc822msg::rfc822msg(const rfc822msg &object) : entity(object)
{
  copyrfc822msgobject(object);
}


/*// constructor, file version
rfc822msg::rfc822msg(uint32 offset, uint32 length, char *filename, BOOL owner) : entity(offset, length, filename, NFE_ENTITY_MIME, owner),
       content_type_index(-1),
       content_transfer_encoding_index(-1)
{
  
}
*/

// assignment operator
rfc822msg& rfc822msg::operator=(const rfc822msg &object)
{
  entity::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyrfc822msgobject(object);
  }
  return *this;
}


// assignment operator
rfc822msg& rfc822msg::operator+=(const MIMEentity &object)
{
  entity::operator+=(object);
  
  mimevers *mv_hdr = 0;
  int32     mv_index = -1;
  
  mv_hdr = (mimevers*)GetAHdr(NFE_HDR_MIME_VERSION, mv_index);
  if (!mv_hdr)
  {
    NFE_rcode rc = NFE_COMPLETED;
    mv_hdr = new mimevers(FALSE, 0, 0, 0, TRUE);
    if ((mv_hdr) && (the_headers))
      rc = the_headers->AddHdr(*mv_hdr);
    if (rc != NFE_COMPLETED)
      delete mv_hdr;
  }
    
  return *this;
}


void rfc822msg::copyrfc822msgobject(const rfc822msg &object)
{
  // nothing to do, should get rid of this and leave the default copy constructors, etc.
  to_index = object.to_index;
  from_index = object.from_index;
  date_index = object.date_index;
  mime_obj = object.mime_obj;
}


// Implementation of destructor for rfc822msg
rfc822msg::~rfc822msg()
{
  if ((ownership) && (mime_obj))
    delete mime_obj;
}


NFE_rcode rfc822msg::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  BOOL      error = FALSE;

  if (!entity::Parsed())
    rc = entity::parse(context, t_slice);
  
  if (rc == NFE_COMPLETED)
  {
    // find MIME-Version header
    mimevers *mv_hdr = 0;
    int32     mv_index = -1;
    
    mv_hdr = (mimevers*)GetAHdr(NFE_HDR_MIME_VERSION, mv_index);
    // if present then
    if (mv_hdr)
    {
      uint32 major = 0;
      uint32 minor = 0;
      // if version 1.0 then
      rc = mv_hdr->GetMajor(major);
      if (rc == NFE_COMPLETED)
      {
        if (major == 1)
        {
          rc = mv_hdr->GetMinor(minor);
          if (rc == NFE_COMPLETED)
          {
            if (minor != 0)
              error = TRUE;
          }
        }
        else
          error = TRUE;
      
        if (!error)
        {
          parsed = TRUE;
          // find content-type header
          contentT *ct_hdr = 0;
          int32     ct_index = 0;
          ct_hdr = (contentT*)GetAHdr(NFE_HDR_CONTENT_TYPE, ct_index);
          // if found then
          if (ct_hdr)
          {
            mime_obj = new MIMEentity(*this);
            if (mime_obj)
            {
              mime_obj->SetOwnership(FALSE);		// MIMEentity doesn't own the data, this rfc822msg does!
              rc = mime_obj->ParseData(context, t_slice);
              NFE_CT ctype = NFE_CT_UNKNOWN;
            
              rc = ct_hdr->GetMajorType(ctype);
              if (rc == NFE_COMPLETED)
              {
                MIMEentity *mime_obj2 = 0;
                switch (ctype)
                {
                  case NFE_CT_TEXT:
                    mime_obj2 = new MIMEtext(*mime_obj);
                    break;
                  case NFE_CT_IMAGE:
                    mime_obj2 = new MIMEimage(*mime_obj);
                    break;
                  case NFE_CT_MULTIPART:
                    mime_obj2 = new MIMEmultip(*mime_obj);
                    break;
                  case NFE_CT_UNKNOWN:
                  default:
                    mime_obj2 = 0;
                    break;
                }
                if (mime_obj2)
                {
                  rc = mime_obj2->ParseData(context, t_slice);
                  if (rc < NFE_COMPLETED)
                  {
                    delete mime_obj2;
                    mime_obj2 = 0;
                  }
                  else
                  {
                    delete mime_obj;
                    mime_obj = mime_obj2;
                  }
                }
              }
            }
            else			// else
              rc = NFE_MALLOCFAILED;	// rc = NFE_MALLOCFAILED
          }
          else
            mime_obj = 0;
        }
        else
          mime_obj = 0;
      }
      else
        mime_obj = 0;
    }
    else
      mime_obj = 0;  
  }

  return rc;
}


void rfc822msg::Display(void)
{
  printf("rfc822msg DISPLAY:\n");
  if (the_headers)
    the_headers->Display();
  if (the_body)
    the_body->Display();  
  printf("END OF rfc822msg\n");
  printf("\n");
}


NFE_rcode rfc822msg::SetTo(to &obj)
{
  to *to_copy = new to(obj);
  
  if (to_copy)
    return SetAHdr(*to_copy, NFE_HDR_TO, to_index);
  else
    return NFE_MALLOCFAILED;
}


NFE_rcode rfc822msg::SetFrom(from &obj)
{
  from *from_copy = new from(obj);
  
  if (from_copy)
    return SetAHdr(*from_copy, NFE_HDR_FROM, from_index);
  else
    return NFE_MALLOCFAILED;
}


NFE_rcode rfc822msg::SetAHdr(header &obj, NFE_HDR_TYPE t, int32 &index)				// move method to entity class????
{
  NFE_rcode rc = NFE_COMPLETED;
  header *h = 0;
  
  if ((the_headers) && (index >= 0))
    h = the_headers->GetHdr(index);
  if (h)
  {
    if (h->GetType() != t)
      h = the_headers->FindHdr(t, index);
  }
  if (h)
    rc = the_headers->ReplaceHdr(obj, index);
  else
  {
    if (the_headers)
      rc = the_headers->AddHdr(obj);
    else
      rc = NFE_FAILED;
  }
  
  return rc;
}


header* rfc822msg::GetAHdr(NFE_HDR_TYPE t, int32 &index)				// move method to entity class????
{
  header *h = 0;
  
  if ((the_headers) && (index >= 0))
    h = the_headers->GetHdr(index);
  else
    h = the_headers->FindHdr(t, index);
  if (h)
  {
    if (h->GetType() != t)
      h = the_headers->FindHdr(t, index);
  }
  
  return h;
}


to* rfc822msg::GetTo(void)
{
  return (to*)GetAHdr(NFE_HDR_TO, to_index);
}


from* rfc822msg::GetFrom(void)
{
  return (from*)GetAHdr(NFE_HDR_FROM, from_index);
}

