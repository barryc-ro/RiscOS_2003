/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		rfc822msg.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.11 for RISC OS

	OVERVIEW
	========
	Source file for implementation of entity object

	HISTORY
	=======
	12/09/97	0.01	RDW	initial version
					Merged file and memory constructors into one
	19/09/97	0.02	RDW	Added to parse function so that it detects if
					the message is MIME conformant and then goes
					ahead and creates a MIMEentity and parses it
	21/09/97	0.03	RDW	added operator+= so that it adds a MIME-Version
					header
	22/09/97	0.04	RDW	Correct mistake in parse method where
					creating specific MIME object wrong variable
					(mime_obj) was used instead of (mime_obj2)
	09/01/98	0.05	RDW	parse method was missing support for MIMEtext
	21/01/98	0.06	RDW	parse method modified to copy with non-fatal
					errors returned by ParseData methods of
					MIMEentities
	18/02/98	0.07	RDW	#include DebugLib path added
	06/10/98	0.08	RDW	GetCharSet() method added
	08/10/98	0.09	RDW	MergeMIMEentity() method added as a replacement
					for operator+= for creating a MIME rfc822msg.
					GetRecipients() method added
					AppendRecipients() method added for GetRecipients()
					ConvertMailboxList() method added for GetRecipients()
	12/10/98	0.10	RDW	CreateReply() method added
					MakeReplyBody() method added
					MakeReplyToHdr() method added
					MakeReplySubjectHdr() method added
					CopyMailboxesToHdr() method added
					WriteOut() memory version, char* mem changed to
					char*& mem so that on exit mem is pointing to
					the next location to write a char to
					Changed destructor to use new bool flag
					"owns_mime_obj" to indicate if it is responsible for
					destroying the mime_obj object
					Fixed memory leak of "new_body" in MakeReplySubjectHdr()
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
  #include "ELib_priv.h"
  #include "ELib_OS.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "rfc822msg.h"
#include "entity.h"
#include "to.h"
#include "replyto.h"
#include "cc.h"
#include "from.h"
#include "date.h"
#include "subject.h"
#include "mimevers.h"
#include "MIMEentity.h"
#include "MIMEimage.h"
#include "MIMEtext.h"
#include "MIMEmultip.h"
extern "C"
{
  #include "ELib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
const char REPLY_SUBJECT_PREFIX[] = "Re: ";


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a entity object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
rfc822msg::rfc822msg(bool f, char *membase, uint32 offset, uint32 length, bool owner) : entity(f, membase, offset, length, ELIB_ENTITY_RFC822MSG, owner),
       to_index(-1),
       from_index(-1),
       date_index(-1),
       mime_obj(0),
       owns_mime_obj(true)
{
  if ((owner) && (length == 0))
  {
    ELib_rcode rc = ELIB_COMPLETED;

    date *d = new date(false, 0, 0, 0, true);
    if (d)
    {
      if (the_headers)
      {
        rc = the_headers->AddHdr(*d);
        if (rc != ELIB_COMPLETED)
          delete d;
      }
      else
        delete d;
    }
    mimevers *mv = new mimevers(false, 0, 0, 0, true);
    if (mv)
    {
      if (the_headers)
      {
        rc = the_headers->AddHdr(*mv);
        if (rc != ELIB_COMPLETED)
          delete mv;
      }
    }
  }
}


// copy constructor
rfc822msg::rfc822msg(const rfc822msg &object) : entity(object)
{
  copyrfc822msgobject(object);
}


/*// constructor, file version
rfc822msg::rfc822msg(uint32 offset, uint32 length, char *filename, bool owner) : entity(offset, length, filename, ELIB_ENTITY_MIME, owner),
       content_type_index(-1),
       content_transfer_encoding_index(-1)
{

}
*/

// assignment operator
rfc822msg& rfc822msg::operator=(const rfc822msg &object)
{
  entity::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyrfc822msgobject(object);
  }
  return *this;
}


// assignment operator
rfc822msg& rfc822msg::operator+=(const MIMEentity &object)
{
  entity::operator+=(object);

  mimevers *mv_hdr = 0;
  int32     mv_index = -1;

  mv_hdr = (mimevers*)GetAHdr(ELIB_HDR_MIME_VERSION, mv_index);
  if (!mv_hdr)
  {
    ELib_rcode rc = ELIB_COMPLETED;
    mv_hdr = new mimevers(false, 0, 0, 0, true);
    if ((mv_hdr) && (the_headers))
      rc = the_headers->AddHdr(*mv_hdr);
    if (rc != ELIB_COMPLETED)
      delete mv_hdr;
  }

  return *this;
}


void rfc822msg::copyrfc822msgobject(const rfc822msg &object)
{
  // nothing to do, should get rid of this and leave the default copy constructors, etc.
  to_index = object.to_index;
  from_index = object.from_index;
  date_index = object.date_index;
  mime_obj = object.mime_obj;
  owns_mime_obj = false;
}


// Implementation of destructor for rfc822msg
rfc822msg::~rfc822msg()
{
  if ((owns_mime_obj) && (mime_obj))
    delete mime_obj;
}


ELib_rcode rfc822msg::parse(ELIB_CONTEXT &context, clock_t t_slice)
{
  ELib_rcode rc    = ELIB_COMPLETED;
  bool      error = false;

  if (!entity::Parsed())
    rc = entity::parse(context, t_slice);

  if (rc == ELIB_COMPLETED)
  {
    // find MIME-Version header
    mimevers *mv_hdr = 0;
    int32     mv_index = -1;

    mv_hdr = (mimevers*)GetAHdr(ELIB_HDR_MIME_VERSION, mv_index);
    // if present then
    if (mv_hdr)
    {
      uint32 major = 0;
      uint32 minor = 0;
      // if version 1.0 then
      rc = mv_hdr->GetMajor(major);
      if (rc == ELIB_COMPLETED)
      {
        if (major == 1)
        {
          rc = mv_hdr->GetMinor(minor);
          if (rc == ELIB_COMPLETED)
          {
            if (minor != 0)
              error = true;
          }
        }
        else
          error = true;

        if (!error)
        {
          parsed = true;
          // find content-type header
          contentT *ct_hdr = 0;
          int32     ct_index = 0;
          ct_hdr = (contentT*)GetAHdr(ELIB_HDR_CONTENT_TYPE, ct_index);
          // if found then
          if (ct_hdr)
          {
            mime_obj = new MIMEentity(*this);
            if (mime_obj)
            {
              mime_obj->SetOwnership(false);		// MIMEentity doesn't own the data, this rfc822msg does!
              rc = mime_obj->ParseData(context, t_slice);
              ELIB_CT ctype = ELIB_CT_UNKNOWN;

              rc = ct_hdr->GetMajorType(ctype);
              if (rc == ELIB_COMPLETED)
              {
                MIMEentity *mime_obj2 = 0;
                switch (ctype)
                {
                  case ELIB_CT_TEXT:
                    mime_obj2 = new MIMEtext(*mime_obj);
                    break;
                  case ELIB_CT_IMAGE:
                    mime_obj2 = new MIMEimage(*mime_obj);
                    break;
                  case ELIB_CT_MULTIPART:
                    mime_obj2 = new MIMEmultip(*mime_obj);
                    break;
                  case ELIB_CT_UNKNOWN:
                  default:
                    mime_obj2 = 0;
                    break;
                }
                if (mime_obj2)
                {
                  rc = mime_obj2->ParseData(context, t_slice);
                  if (rc < ELIB_COMPLETED)
                  {
                    delete mime_obj2;
                    mime_obj2 = 0;
                  }
                  else
                  {
                    delete mime_obj;
                    mime_obj = mime_obj2;
                  }
                }
              }
            }
            else			// else
              rc = ELIB_EMALLOCFAILED;	// rc = ELIB_EMALLOCFAILED
          }
          else
            mime_obj = 0;
        }
        else
          mime_obj = 0;
      }
      else
        mime_obj = 0;
    }
    else
      mime_obj = 0;
  }

  return rc;
}


void rfc822msg::Display(void)
{
  printf("rfc822msg DISPLAY:\n");
  if (the_headers)
    the_headers->Display();
  if (the_body)
    the_body->Display();
  printf("END OF rfc822msg\n");
  printf("\n");
}


ELib_rcode rfc822msg::SetTo(to &obj)
{
  to *to_copy = new to(obj);

  if (to_copy)
    return SetAHdr(*to_copy, ELIB_HDR_TO, to_index);
  else
    return ELIB_EMALLOCFAILED;
}


ELib_rcode rfc822msg::SetFrom(from &obj)
{
  from *from_copy = new from(obj);

  if (from_copy)
    return SetAHdr(*from_copy, ELIB_HDR_FROM, from_index);
  else
    return ELIB_EMALLOCFAILED;
}


ELib_rcode rfc822msg::SetAHdr(header &obj, ELIB_HDR_TYPE t, int32 &index)				// move method to entity class????
{
  ELib_rcode rc = ELIB_COMPLETED;
  header *h = 0;

  if ((the_headers) && (index >= 0))
    h = the_headers->GetHdr(index);
  if (h)
  {
    if (h->GetType() != t)
      h = the_headers->FindHdr(t, index);
  }
  if (h)
    rc = the_headers->ReplaceHdr(obj, index);
  else
  {
    if (the_headers)
      rc = the_headers->AddHdr(obj);
    else
      rc = ELIB_EFAILED;
  }

  return rc;
}


header* rfc822msg::GetAHdr(ELIB_HDR_TYPE t, int32 &index)				// move method to entity class????
{
  header *h = 0;

  if ((the_headers) && (index >= 0))
    h = the_headers->GetHdr(index);
  else
    h = the_headers->FindHdr(t, index);
  if (h)
  {
    if (h->GetType() != t)
      h = the_headers->FindHdr(t, index);
  }

  return h;
}


to* rfc822msg::GetTo(void)
{
  return (to*)GetAHdr(ELIB_HDR_TO, to_index);
}


from* rfc822msg::GetFrom(void)
{
  return (from*)GetAHdr(ELIB_HDR_FROM, from_index);
}


ELib_rcode rfc822msg::GetCharSet(char*& data, uint32 &size)
{
  static char charset[] = "us-ascii";
  ELib_rcode rc = ELIB_DEFAULTED;

  if (mime_obj)
  {
    rc = mime_obj->GetCharSet(data, size);
  }
  else
  {
    if (data == 0)								// If we've not been given a block of memory
    {
      if (size == 0)								// are we to allocate some, if size == 0, then no
      {
        size = strlen(charset) + 1;
        rc = ELIB_ENULLADDR;
      }
      else									// else, allocate the required amount of space
      {
        size = strlen(charset) + 1;
        data = new char[size];
        if (data == 0)
          rc = ELIB_EMALLOCFAILED;
      }
    }

    if (data)									// if memory allocated, then
    {
      if (size >= strlen(charset) + 1)						// is it big enough?  if so then
      {
        strcpy(data, charset);
      }
      else
        rc = ELIB_ENOSPACE;
    }
  }

  return rc;
}


ELib_rcode rfc822msg::MergeMIMEentity(MIMEentity* ent)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (ent)
  {
    if ((mime_obj) && (owns_mime_obj))
    {
      delete mime_obj;
    }
    mime_obj = ent;
    owns_mime_obj = true;

    headers* mime_obj_hdrs = mime_obj->GetHdrs();
    body*    mime_obj_body = mime_obj->GetBody();

    mime_obj_hdrs->Prepend(*the_headers);
//    *mime_obj_hdrs += *the_headers;		// Copy our headers in to MIME object's headers

    destroy_headers();				// Destroy our body and headers objects and setup for us to use the MIMEentities ones'
    destroy_body();

    own_headers = false;
    own_body = false;

    the_headers = mime_obj_hdrs;
    the_body = mime_obj_body;

    // Ensure a MIME-Version header is present
    mimevers *mv_hdr = 0;
    int32     mv_index = -1;

    mv_hdr = (mimevers*)GetAHdr(ELIB_HDR_MIME_VERSION, mv_index);
    if (!mv_hdr)
    {
      ELib_rcode rc = ELIB_COMPLETED;
      mv_hdr = new mimevers(false, 0, 0, 0, true);
      if ((mv_hdr) && (the_headers))
        rc = the_headers->AddHdr(*mv_hdr);
      if (rc != ELIB_COMPLETED)
        delete mv_hdr;
    }
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}




ELib_rcode rfc822msg::WriteOut(ELIB_CONTEXT& context, clock_t t_slice, FILE* file)
{
  if (mime_obj)
    return mime_obj->WriteOut(context, t_slice, file);
  else
    return super::WriteOut(context, t_slice, file);
}

// function to write out the object to memory
ELib_rcode rfc822msg::WriteOut(ELIB_CONTEXT& context, clock_t t_slice, char*& mem, uint32& l)
{
  if (mime_obj)
    return mime_obj->WriteOut(context, t_slice, mem, l);
  else
    return super::WriteOut(context, t_slice, mem, l);
}


// function to write out the object to file
ELib_rcode rfc822msg::WriteOut(ELIB_CONTEXT &context, clock_t t_slice, FILE *f, ELIB_TE format)
{
  if (mime_obj)
    return mime_obj->WriteOut(context, t_slice, f, format);
  else
    return super::WriteOut(context, t_slice, f, format);
}


// for all destination header types (to, cc)	// need to extend to support case when resent- hdrs are present and what about bcc?
//   append all email addresses to list
//   convert list into string
// endfor
ELib_rcode rfc822msg::GetRecipients(char*& recipients)
{
  static ELIB_HDR_TYPE hdrs_to_do[] = {ELIB_HDR_TO, ELIB_HDR_CC};	// HDR types *MUST* be of class type from or sub-classes
  									// Made static as CFront won't do it as an automatic local var.
  ELib_rcode    rc           = ELIB_COMPLETED;
  ELib_list     recipient_list;

  for (uint32 hdr_count=0;
       ((hdr_count<(sizeof(hdrs_to_do)/sizeof(ELIB_HDR_TYPE))) && rc > ELIB_RUNNING);
       hdr_count++)
  {
    rc = AppendRecipients(hdrs_to_do[hdr_count], recipient_list);
  }

  if (rc > ELIB_RUNNING)
    rc = ConvertMailboxList(recipients, recipient_list);

  return rc;
}


// find hdr
// if hdr then
//   for each address in hdr do
//     get address
//     append address to list
//   endfor
// endif
ELib_rcode rfc822msg::AppendRecipients(ELIB_HDR_TYPE hdr_type, ELib_list& list)
{
  ELib_rcode rc = ELIB_COMPLETED;
  from*       h = 0;

  // FindHdr
  if (the_headers)
  {
    h = (from*)the_headers->FindHdr(hdr_type);
    if (h)
    {
      uint32 num_of_mboxes = h->GetNumMailboxes();

      if (num_of_mboxes > 0)
      {
        for (uint32 i = 0;i<num_of_mboxes;i++)
        {
          mailbox* m = h->GetMailbox(i);
          if (m)
          {
            list.Insert(m);
          }
        }
      }
    }
  }
  // if found, then

  return rc;
}


// Private method to convert list of mailboxes into a string of comma separated character strings of the email addresses
ELib_rcode rfc822msg::ConvertMailboxList(char*& comma_list, ELib_list& mbox_list)
{
  // Turn ELib_list mailbox list into a common separated string of characters of the email addresses
  ELib_rcode rc = ELIB_COMPLETED;
  mailbox* mbox = 0;
  uint32   string_size = 0;

  comma_list = 0;

  // Calculate size of string required to hold all addresses + comma separators + null char
  TRAVERSE(mbox_list)
  {
    mbox = (mailbox*)mbox_list.Current();
    if (mbox)
    {
      char* tmp = 0;
      uint32 mbox_size = 0;

      mbox->GetAddress(tmp, mbox_size);
      string_size += mbox_size;			// don't need + 1 for comma or NULL (if this is last one) as GetAddress mbox_size includes null char
    }
  }

  // allocate memory and copy addresses into string
  if (string_size)
  {
    comma_list = new char[string_size];
    if (comma_list)
    {
      uint32 mbox_size = string_size;
      char* pos = comma_list;
      TRAVERSE(mbox_list)
      {
        mbox = (mailbox*)mbox_list.Current();
        if (mbox)
        {
          rc = mbox->GetAddress(pos, mbox_size);
          if (rc > ELIB_RUNNING)
          {
            uint32 string_len = strlen(pos);
            pos += string_len;			// move char* to null char
            *pos = ',';
            pos++;
            string_size -= string_len + 1;	// remove the space taken by the address string and the comma(was null char)
            mbox_size = string_size;
          }
        }
      }
      pos--;					// overwrite last ',' with null char
      *pos = '\0';
    }
    else
      rc = ELIB_EMALLOCFAILED;
  }
  else
    rc = ELIB_EFAILED;

  if ((rc < ELIB_RUNNING) && (comma_list))
  {
    delete[] comma_list;
    comma_list = 0;
  }

  return rc;
}


ELib_rcode rfc822msg::CreateReply(rfc822msg*& reply_message, const char* const body_filename, bool reply_to_all)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (Parsed() == false)
  {
    rc = ELIB_EDATAMUSTBEPARSED;
  }
  else
  {
    reply_message = new rfc822msg(false, 0, 0, 0, true);
    if (reply_message == 0)
      rc = ELIB_EMALLOCFAILED;
    else
    {
      to* new_to_hdr = 0;

      rc = MakeReplyToHdr(new_to_hdr, reply_to_all);
      if (rc > ELIB_RUNNING)
      {
        rc = reply_message->SetTo(*new_to_hdr);
        delete new_to_hdr;
      }

      if (rc > ELIB_RUNNING)
      {
        rc = MakeReplySubjectHdr(*reply_message);
      }

      if (rc > ELIB_RUNNING)
      {
        rc = MakeReplyBody(*reply_message, body_filename);
      }
    }
    if (rc < ELIB_RUNNING)
      delete reply_message;
  }

  return rc;
}


ELib_rcode rfc822msg::MakeReplyBody(rfc822msg& reply_message, const char* const body_filename)
{
  ELib_rcode rc = ELIB_COMPLETED;
  body *new_body = 0;

  MIMEtext* text = new MIMEtext(false, 0, 0, 0, ELIB_CT_TEXT_PLAIN, true);

  if (text == 0)
    rc = ELIB_EMALLOCFAILED;
  else
  {
    body* old_body = Get1stTextBody();
    if (old_body)
    {
      // quote body into new body
      new_body = new body(*old_body);
      if (new_body)
      {
        ELIB_CONTEXT context;
        char* tmp_file = "<Wimp$ScrapDir>.EMailLib00";

        new_context(&context);
        rc = new_body->RemoveEncoding(context, 0, tmp_file, 3072);
        destroy_context(&context);

        if (rc == ELIB_EALREADYDECODED)
        {
          rc = ELIB_COMPLETED;
        }
        if (rc > ELIB_RUNNING)
        {
          new_context(&context);
          rc = new_body->ApplyEncoding(context, 0, ELIB_TE_TEXT_QUOTING, (char*)body_filename, 3072);
          destroy_context(&context);
        }
        ELIB_OS_delete_file(tmp_file);
      }
      else
        rc = ELIB_EMALLOCFAILED;
    }
  }

  if (rc > ELIB_RUNNING)
  {
    if (new_body)
    {
      text->ReplaceBody(new_body);
    }
  }

  if (rc > ELIB_RUNNING)
    rc = reply_message.MergeMIMEentity(text);

  return rc;
}


body* rfc822msg::Get1stTextBody(void)
{
  body* b = 0;
  MIMEentity* current_entity = GetMIMEentity();

  // check for MIMEobject
  if (current_entity == 0)
    b = the_body;
  else
  {
    ELib_rcode rc = ELIB_COMPLETED;
    ELIB_CT ct;

    rc = current_entity->GetMajorType(ct);
    if (rc > ELIB_RUNNING)
    {
      if (ct == ELIB_CT_MULTIPART)
      {
        current_entity = ((MIMEmultip*)current_entity)->BFS(ELIB_CT_TEXT);
        ct = ELIB_CT_TEXT;
      }
      if (current_entity)
      {
        b = current_entity->GetBody();
      }
    }
  }

  return b;
}


ELib_rcode rfc822msg::MakeReplySubjectHdr(rfc822msg& reply_message)
{
  ELib_rcode rc              = ELIB_COMPLETED;
  subject*   new_subject_hdr = 0;
  subject*   old_subject_hdr = (subject*)the_headers->FindHdr(ELIB_HDR_SUBJECT);

  if (old_subject_hdr)
    new_subject_hdr = new subject(*old_subject_hdr);
  else
    new_subject_hdr = new subject(false, 0, 0, 0, true);

  if (new_subject_hdr == 0)
    rc = ELIB_EMALLOCFAILED;
  else
  {
    uint32 size = 0;
    char* new_body = 0;

    rc = new_subject_hdr->GetBodyLen(size);
    if (rc > ELIB_RUNNING)
    {
      size++;
      size += strlen(REPLY_SUBJECT_PREFIX);
      new_body = new char[size+1];
      if (new_body == 0)
        rc = ELIB_EMALLOCFAILED;
      else
      {
        strcpy(new_body, REPLY_SUBJECT_PREFIX);
        char* pos = new_body;
        pos += strlen(REPLY_SUBJECT_PREFIX);
        size -= strlen(REPLY_SUBJECT_PREFIX);

        rc = new_subject_hdr->GetUnfoldedNoCommentsBody(pos, size);
        if (rc > ELIB_RUNNING)
        {
          if (incase_n_comp(pos, (char*)REPLY_SUBJECT_PREFIX, strlen(REPLY_SUBJECT_PREFIX)) == 0)	// if subject already has "Re:"
          {
            rc = new_subject_hdr->SetBody(pos);							// set body to orginal message subject contents
          }
          else
          {
            rc = new_subject_hdr->SetBody(new_body);						// else, set to original with "Re:" prepended
          }
          if (rc > ELIB_RUNNING)
          {
            headers* new_headers = reply_message.GetHdrs();
            if (new_headers)
            {
              rc = new_headers->AddHdr(*new_subject_hdr);
            }
          }
        }
        delete new_body;
      }
    }
    if (rc < ELIB_RUNNING)
      delete new_subject_hdr;
  }

  return rc;
}


ELib_rcode rfc822msg::MakeReplyToHdr(to*& new_to_hdr, bool reply_to_all)
{
  ELib_rcode rc = ELIB_COMPLETED;
  new_to_hdr = 0;

  replyto* replyto_hdr = (replyto*)the_headers->FindHdr(ELIB_HDR_REPLY_TO);	// Look for presence of a Reply-To header
  if (replyto_hdr)									// If found, make to header from that
  {
    new_to_hdr = new to(*replyto_hdr);
    if (new_to_hdr == 0)
      rc = ELIB_EMALLOCFAILED;
  }

  if (rc > ELIB_RUNNING)
  {
    if (new_to_hdr == 0)							// If no to header, then there was no reply-to, so
    {
      from* from_hdr = (from*)the_headers->FindHdr(ELIB_HDR_FROM);		// look for from header
      if (from_hdr)
        new_to_hdr = new to(*from_hdr);						// and create to header from that
      else
        new_to_hdr = new to(false, 0, 0, 0, true);				// if not found from header, then make empty to header
										// need this as message/rfc822 objects are not required to
      										// to have destination or source headers as per RFC822
      if (new_to_hdr == 0)
        rc = ELIB_EMALLOCFAILED;
    }
  }

  if ((rc > ELIB_RUNNING) && (reply_to_all == true))
  {
    cc* cc_hdr = (cc*)the_headers->FindHdr(ELIB_HDR_CC);
    to* to_hdr = (to*)the_headers->FindHdr(ELIB_HDR_TO);

    if (cc_hdr)
      rc = CopyMailboxesToHdr(*new_to_hdr, *cc_hdr);
    if ((rc > ELIB_RUNNING) && (to_hdr))
      rc = CopyMailboxesToHdr(*new_to_hdr, *to_hdr);
  }

  return rc;
}

// Make copies of mailbox objects in source_hdr and append them to the dest_hdr
ELib_rcode rfc822msg::CopyMailboxesToHdr(from& dest_hdr, from& source_hdr)
{
  ELib_rcode rc = ELIB_COMPLETED;

  uint32 num_of_mboxes = source_hdr.GetNumMailboxes();

  if (num_of_mboxes > 0)
  {
    for (uint32 i = 0;
         ((i<num_of_mboxes) && (rc > ELIB_RUNNING));
         i++)
    {
      mailbox* m = source_hdr.GetMailbox(i);
      if (m)
      {
        mailbox* m2 = new mailbox(*m);
        if (m2)
        {
          rc = dest_hdr.AddMBox(*m2);
          if (rc < ELIB_RUNNING)
            delete m2;
        }
        else
          rc = ELIB_EMALLOCFAILED;
      }
    }
  }

  return rc;
}

