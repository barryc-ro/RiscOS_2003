/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		body.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.11 for RISC OS

	OVERVIEW
	========
	Source file for implementation of body object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	11/09/97	0.02	RDW	modified RemoveEncoding to file method
					so that the body object now uses that
					file as	it's data and disguards the
					original
					ApplyEncoding to file method done
	12/09/97	0.03	RDW	Merged file and memory constructors
					into one.
	26/11/97	0.04	RDW	Apply_encoding, encode to 7bit
					added for file version with Encode7BIT
					method.  Remove_encoding, decode to
					RISCOS text file added for file version
					with Decode7BIT method.
	29/11/97	0.05	RDW	type private method initialised in
					constructors and added to copybodyobject
					method.
	04/12/97	0.06	RDW	RemoveEncoding method added with FILE* parameter
					to use instead of opening the filename directly
					Decode7BIT modified to have a FILE* parameter too.
	20/01/98	0.07	RDW	if goto_start returns false, rcode is now set
					to ELIB_EINVALIDFILENAME and not ELIB_EFAILED
	18/02/98	0.08	RDW	#include DebugLib path added
	27/02/98	0.09	RDW	RemoveEncoding() ELIB_TE_8BIT changed to
					return ELIB_ENOTSUPPORTED
	30/09/98	0.10	RDW	RemoveEncoding() ELIB_TE_8BIT support added
					Decode8BIT() method added
	01/10/98	0.11	RDW	Display() method changed to support 7BIT/NONE
					encoding as separate types now
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "body.h"
#include "elibbase.h"
extern "C"
{
  #include "ELib.h"
  #include "base64.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  LF = 10,
  CR = 13
} CHARS;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a body object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
body::body(void) : elibbase(),
                   encoding(ELIB_TE_UNKNOWN), out(0),
                   type(ELIB_BODY)
{

}


body::body(bool f, char *membase, uint32 offset, uint32 length, ELIB_TE enc, bool owner) : elibbase(f, membase, offset, length, owner),
                                                                                  encoding(enc), out(0), type(ELIB_BODY)
{

}


// copy constructor
body::body(const body &object) : elibbase(object),
                                  encoding(ELIB_TE_UNKNOWN)
{
  copybodyobject(object);
}


/*// constructor, file version
body::body(uint32 offset, uint32 length, char *filename, ELIB_TE enc, bool owner) : elibbase(filename, offset, length, true, owner),
                                                                                   encoding(enc), out(0)
{

}
*/

// assignment operator
body& body::operator=(const body &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copybodyobject(object);
  }
  return *this;
}


void body::copybodyobject(const body &object)
{
  encoding = object.encoding;
  out = object.out;
  type = object.type;
}


// Implementation of destructor for body
body::~body()
{
  // nothing to do
}


ELib_rcode body::parse(ELIB_CONTEXT &context, clock_t t_slice)
{
  // Nothing to do, you don't parse a body you apply and remove encoings from it, so lots of different parsing to be done
  return ELIB_COMPLETED;
}


void body::Display(void)
{
  printf("BODY DISPLAY:\n");
  printf("ENCODING    : ");
  switch (encoding)
  {
    case ELIB_TE_NONE:
      printf("NONE\n");
      break;
    case ELIB_TE_7BIT:
      printf("7BIT\n");
      break;
    case ELIB_TE_8BIT:
      printf("8BIT\n");
      break;
    case ELIB_TE_BINARY:
      printf("BINARY\n");
      break;
    case ELIB_TE_QUOTED_PRINTABLE:
      printf("QUOTED_PRINTABLE\n");
      break;
    case ELIB_TE_BASE64:
      printf("BASE64\n");
      break;
    case ELIB_TE_UNKNOWN:
      printf("UNKNOWN\n");
      break;
    default:
      printf("INTERNALERR\n");
  }
  elibbase::Display();
  printf("END OF BODY\n");
  printf("\n");
}


ELib_rcode body::GetEncoding(ELIB_TE &enc)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
    enc = encoding;
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


ELib_rcode body::RemoveEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               char *filename,
                               FILE *filedes,
                               uint32 buffer)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
  {
/*    if (encoding != ELIB_TE_NONE)
    {*/
      if (encoding == ELIB_TE_UNKNOWN)
        rc = ELIB_ECANTDOUNKNOWN;
      else
      {
        // do decode
        switch (encoding)
        {
          case ELIB_TE_8BIT:
          case ELIB_TE_7BIT:
          {
            if (encoding == ELIB_TE_8BIT)
              rc = Decode8BIT(context, t_slice, true, filename, filedes, buffer);
            else
              rc = Decode7BIT(context, t_slice, true, filename, filedes, buffer);
            if (rc == ELIB_COMPLETED)
            {
              // need to replace current body data with this new encoded body data
              encoding = ELIB_TE_NONE;
              if ((ownership) && (!file))
                delete[] mem_base;
              if (file)
                delete[] mem_base;
              file = true;
              parsed = true;
              start = 0;
              len = bwritten;
              mem_base = new char[strlen(filename)+1];
              strcpy(mem_base, filename);
              mem_size = 0;
            }
            if (out)
            {
              fclose(out);
              out = 0;
            }
            break;
          }
          case ELIB_TE_BINARY:
            rc = ELIB_EALREADYDECODED;
            break;
          case ELIB_TE_QUOTED_PRINTABLE:
            rc = ELIB_ENOTSUPPORTED;
            break;
          case ELIB_TE_BASE64:
          {
            if (out == 0)			// if this is the start (we've not opend the files yet), then
            {
              new_context(&context);

              if (file)
              {
                if (filedes)
                  out = filedes;
                else
                  out = fopen(filename, "wb+");
                if (out)
                {
                  // move to start in file
                  bool ok = goto_start();
                  if (ok)
                  {
                    fseek(fd, -1, SEEK_CUR);// move back on char in file as goto_start reads in first char
                    bwritten = 0;
                    rc = base64decode(&context, t_slice, fd, out, buffer, &bwritten);
                    if (rc == ELIB_COMPLETED)
                    {
                      // need to replace current body data with this new encoded body data are correctly set all the data members
                      encoding = ELIB_TE_7BIT;
                      if ((ownership) && (!file))
                        delete[] mem_base;
                      if (file)
                        delete[] mem_base;
                      file = true;
                      parsed = true;
                      start = 0;
                      len = bwritten;
                      mem_base = new char[strlen(filename)+1];
                      strcpy(mem_base, filename);
                      mem_size = 0;
                    }
                    if (rc != ELIB_RUNNING)
                    {
                      destroy_context(&context);
                      if (!filedes)
                        fclose(out);
                      out = 0;
                      stop();
                    }
                  }
                  else
                  {
                    rc = ELIB_EINVALIDFILENAME;
                    if (!filedes)
                      fclose(out);
                    out = 0;
                  }
                }
                else
                {
                  rc = ELIB_EWRITEFAIL;
                }
              }
              else
                rc = ELIB_EINTERNALERR;	// 'cos I've not done mem version yet!
            }
            else
            {
              rc = base64decode(&context, t_slice, fd, out, buffer, &bwritten);
              if (rc == ELIB_COMPLETED)
              {
                // need to replace current body data with this new encoded body data are correctly set all the data members
                encoding = ELIB_TE_7BIT;
                if ((ownership) && (!file))
                  delete[] mem_base;
                if (file)
                  delete[] mem_base;
                file = true;
                parsed = true;
                start = 0;
                len = bwritten;
                mem_base = new char[strlen(filename)+1];
                strcpy(mem_base, filename);
                mem_size = 0;
              }
              if (rc != ELIB_RUNNING)
              {
                destroy_context(&context);
                if (!filedes)
                  fclose(out);
                out = 0;
                stop();
              }
            }
            break;
          }
          default:
          {
            rc = ELIB_EINTERNALERR;
            break;
          }
        }  // end switch
      } // endif on encoding type check
//    } // endif on encoding not NONE check
  } // endif on data present check
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


ELib_rcode body::RemoveEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               char *memory)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
  {
    if (encoding != ELIB_TE_NONE)
    {
      if (encoding == ELIB_TE_UNKNOWN)
        rc = ELIB_ECANTDOUNKNOWN;
      else
      {
        // do decode
      }
    }
  }
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


ELib_rcode body::ApplyEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               ELIB_TE enc,
                               char *filename,
                               uint32 buffer)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
  {
    if (enc == encoding)
      rc = ELIB_EALREADYENCODED;
    else if (enc == ELIB_TE_UNKNOWN)
      rc = ELIB_ECANTDOUNKNOWN;
    else
    {
      // do encode
      switch (enc)
      {
        case ELIB_TE_7BIT:
        {
          rc = Encode7BIT(context, t_slice, true, filename, buffer);
          if (rc == ELIB_COMPLETED)
          {
            // need to replace current body data with this new encoded body data
            encoding = ELIB_TE_7BIT;
            if ((ownership) && (!file))
              delete[] mem_base;
            if (file)
              delete[] mem_base;
            file = true;
            parsed = true;
            start = 0;
            len = bwritten;
            mem_base = new char[strlen(filename)+1];
            strcpy(mem_base, filename);
            mem_size = 0;
          }
          if (out)
          {
            fclose(out);
            out = 0;
          }
          break;
        }
//        case ELIB_TE_NONE:
        case ELIB_TE_8BIT:			// cant apply 8BIT or binary, that's a base format.
        case ELIB_TE_BINARY:
          rc = ELIB_ENOTSUPPORTED;
          break;
        case ELIB_TE_QUOTED_PRINTABLE:
          rc = ELIB_ENOTSUPPORTED;
          break;
        case ELIB_TE_BASE64:
        {
          if (out == 0)			// if this is the start (we've not opend the files yet), then
          {
            new_context(&context);

            if (file)
            {
              out = fopen(filename, "wb+");
              if (out)
              {
                // move to start in file
                bool ok = goto_start();
                if (ok)
                {
                  fseek(fd, -1, SEEK_CUR);// move back on char in file as goto_start reads in first char
                  bwritten = 0;
                  rc = base64encode(&context, t_slice, fd, out, buffer, &bwritten);
                  if (rc == ELIB_COMPLETED)
                  {
                    // need to replace current body data with this new encoded body data are correctly set all the data members
                    encoding = ELIB_TE_BASE64;
                    if ((ownership) && (!file))
                      delete[] mem_base;
                    if (file)
                      delete[] mem_base;
                    file = true;
                    parsed = true;
                    start = 0;
                    len = bwritten;
                    mem_base = new char[strlen(filename)+1];
                    strcpy(mem_base, filename);
                    mem_size = 0;
                  }
                  if (rc != ELIB_RUNNING)
                  {
                    destroy_context(&context);
                    fclose(out);
                    out = 0;
                    stop();
                  }
                }
                else
                {
                  rc = ELIB_EINVALIDFILENAME;
                  fclose(out);
                  out = 0;
                }
              }
              else
              {
                rc = ELIB_EWRITEFAIL;
              }
            }
            else
              rc = ELIB_EINTERNALERR;	// 'cos I've not done mem version yet!
          }
          else
          {
            rc = base64encode(&context, t_slice, fd, out, buffer, &bwritten);
            if (rc == ELIB_COMPLETED)
            {
              // need to replace current body data with this new encoded body data are correctly set all the data members
              encoding = ELIB_TE_BASE64;
              if ((ownership) && (!file))
                delete[] mem_base;
              if (file)
                delete[] mem_base;
              file = true;
              parsed = true;
              start = 0;
              len = bwritten;
              mem_base = new char[strlen(filename)+1];
              strcpy(mem_base, filename);
              mem_size = 0;
            }
            if (rc != ELIB_RUNNING)
            {
              destroy_context(&context);
              fclose(out);
              out = 0;
              stop();
            }
          }
          break;
        }
        default:
        {
          rc = ELIB_EINTERNALERR;
          break;
        }
      }  // end switch
    }
  }
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


ELib_rcode body::ApplyEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               ELIB_TE enc,
                               char *memory)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
  {
    if (enc == encoding)
      rc = ELIB_EALREADYENCODED;
    else if (encoding != ELIB_TE_7BIT)
      rc = ELIB_EMUSTBE7BIT;
    else if (encoding == ELIB_TE_UNKNOWN)
      rc = ELIB_ECANTDOUNKNOWN;
    else
    {
      // do encode
    }
  }
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


ELib_rcode body::Encode7BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;		// As I've not implemented memory output yet!
  else
  {
    new_context(&c);
    out = fopen(output, "wb+");
    if (!out)
      rc = ELIB_EWRITEFAIL;
    else
    {
      bool ok = goto_start();		// Goto start of this body object
      if (!ok)
      {
        rc = ELIB_EINVALIDFILENAME;
        fclose(out);
        out = 0;
      }
      else
      {
        bwritten = 0;
        char prev = 0;
        int error = 0;

        while ( (error != EOF) && (!end_of_data()) )
        {
          if (curchar == LF)				// if current char is a LF
          {
            if ((prev != CR) && (error != EOF))		// if previous char is not a CR then
            {
              error = fputc(CR, out);			// write out a CR
              if (error != EOF) bwritten++;
            }
          }
          error = fputc(curchar, out);
          if (error != EOF) bwritten++;
          prev = curchar;
          next_char();
        } // endwhile
        stop();
      }
    } // endif fopen check
    destroy_context(&c);
  } // endif file_output check

  return rc;
}


ELib_rcode body::Decode7BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           FILE          *filedes,
                           uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;		// As I've not implemented memory output yet!
  else
  {
    new_context(&c);
    if (filedes)
      out = filedes;
    else
      out = fopen(output, "wb+");
    if (!out)
      rc = ELIB_EWRITEFAIL;
    else
    {
      bool ok = goto_start();		// Goto start of this body object
      if (!ok)
      {
        rc = ELIB_EINVALIDFILENAME;
        if (!filedes)
          fclose(out);
        out = 0;
      }
      else
      {
        bwritten = 0;
        int error = 0;

        while ( (error != EOF) && (!end_of_data()) && (curpos<len))
        {
          if (curchar == CR)				// if current char is a CR
          {
            next_char();				// get the next char
            if (curchar == LF)				// if the next char is a LF then
            {
              error = fputc(LF, out);			// Turn CRLF into LF by just outputing LF
              if (error != EOF) bwritten++;
            }
            else					// else, next char wasn't LF, so not a CRLF sequence, so
            {
              error = fputc(CR, out);			// write out the CR and
              if (error !=EOF) bwritten++;
              error = fputc(curchar, out);		// write out this character
              if (error !=EOF) bwritten++;
            }
          }
          else						// else current char wasn't a CR, so
          {
            error = fputc(curchar, out);		// write it out
            if (error != EOF) bwritten++;
          }
          next_char();
        } // endwhile
        stop();
      }
    } // endif fopen check
    destroy_context(&c);
  } // endif file_output check

  return rc;
}


ELib_rcode body::Decode8BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           FILE          *filedes,
                           uint32         bufsize)
{
  return Decode7BIT(c, t_slice, file_output, output, filedes, bufsize);		// As for decoding 8BIT we just need to turn CRLF into OS linebreaks
}


