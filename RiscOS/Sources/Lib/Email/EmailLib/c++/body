/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		body.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.13 for RISC OS

	OVERVIEW
	========
	Source file for implementation of body object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	11/09/97	0.02	RDW	modified RemoveEncoding to file method
					so that the body object now uses that
					file as	it's data and disguards the
					original
					ApplyEncoding to file method done
	12/09/97	0.03	RDW	Merged file and memory constructors
					into one.
	26/11/97	0.04	RDW	Apply_encoding, encode to 7bit
					added for file version with Encode7BIT
					method.  Remove_encoding, decode to
					RISCOS text file added for file version
					with Decode7BIT method.
	29/11/97	0.05	RDW	type private method initialised in
					constructors and added to copybodyobject
					method.
	04/12/97	0.06	RDW	RemoveEncoding method added with FILE* parameter
					to use instead of opening the filename directly
					Decode7BIT modified to have a FILE* parameter too.
	20/01/98	0.07	RDW	if goto_start returns false, rcode is now set
					to ELIB_EINVALIDFILENAME and not ELIB_EFAILED
	18/02/98	0.08	RDW	#include DebugLib path added
	27/02/98	0.09	RDW	RemoveEncoding() ELIB_TE_8BIT changed to
					return ELIB_ENOTSUPPORTED
	30/09/98	0.10	RDW	RemoveEncoding() ELIB_TE_8BIT support added
					Decode8BIT() method added
	01/10/98	0.11	RDW	Display() method changed to support 7BIT/NONE
					encoding as separate types now
	04/10/98	0.12	RDW	Intergrating quotedprintable support
					out data member renamed to out_fd
					DecodeQT(), EncodeQT(), SetUpQT() and CleanUpAT()
					methods added
					Memory versions of RemoveEncoding() methods
					implemented for QT support only.  Destination
					memory parameter removed as body object itself
					will allocate the memory to use
	06/10/98	0.13	RDW	GetCharSet() method added
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "body.h"
#include "elibbase.h"
#include "quotedprintable.h"
extern "C"
{
  #include "ELib.h"
  #include "base64.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  LF = 10,
  CR = 13
} CHARS;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a body object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
body::body(void)
     :elibbase(),
      encoding(ELIB_TE_UNKNOWN),
      out_fd(0),
      type(ELIB_BODY),
      qp_obj(0)
{

}


body::body(bool f, char *membase, uint32 offset, uint32 length, ELIB_TE enc, bool owner)
     :elibbase(f, membase, offset, length, owner),
      encoding(enc),
      out_fd(0),
      type(ELIB_BODY),
      qp_obj(0)
{

}


// copy constructor
body::body(const body &object)
     :elibbase(object),
      out_fd(0),
      encoding(ELIB_TE_UNKNOWN),
      qp_obj(0)
{
  copybodyobject(object);
}


// assignment operator
body& body::operator=(const body &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    if (out_fd)
    {
      fclose(out_fd);
      out_fd = 0;
    }
    if (qp_obj)
    {
      delete qp_obj;
      qp_obj = 0;
    }
    copybodyobject(object);
  }
  return *this;
}


void body::copybodyobject(const body &object)
{
  encoding = object.encoding;
  out_fd = object.out_fd;
  type = object.type;
}


// Implementation of destructor for body
body::~body()
{
  if (out_fd)
  {
    fclose(out_fd);
    out_fd = 0;
  }
}


ELib_rcode body::parse(ELIB_CONTEXT &context, clock_t t_slice)
{
  // Nothing to do, you don't parse a body you apply and remove encoings from it, so lots of different parsing to be done
  return ELIB_COMPLETED;
}


void body::Display(void)
{
  printf("BODY DISPLAY:\n");
  printf("ENCODING    : ");
  switch (encoding)
  {
    case ELIB_TE_NONE:
      printf("NONE\n");
      break;
    case ELIB_TE_7BIT:
      printf("7BIT\n");
      break;
    case ELIB_TE_8BIT:
      printf("8BIT\n");
      break;
    case ELIB_TE_BINARY:
      printf("BINARY\n");
      break;
    case ELIB_TE_QUOTED_PRINTABLE:
      printf("QUOTED_PRINTABLE\n");
      break;
    case ELIB_TE_BASE64:
      printf("BASE64\n");
      break;
    case ELIB_TE_UNKNOWN:
      printf("UNKNOWN\n");
      break;
    default:
      printf("INTERNALERR\n");
  }
  elibbase::Display();
  printf("END OF BODY\n");
  printf("\n");
}


ELib_rcode body::GetEncoding(ELIB_TE &enc)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
    enc = encoding;
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


// Remove to file
ELib_rcode body::RemoveEncoding(ELIB_CONTEXT  &context,
                                const clock_t  t_slice,
                                char          *filename,
                                FILE          *filedes,
                                uint32         buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }

  if ((rc == ELIB_RUNNING) && (out_fd == 0))
  {
    bwritten = 0;
    if (filedes)
    {
      out_fd = filedes;
    }
    else
    {
      out_fd = fopen(filename, "wb+");
      if (out_fd == 0)
        rc = ELIB_EWRITEFAIL;
    }
  }

  if (rc == ELIB_RUNNING)
  {
    switch (encoding)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_NONE:
      case ELIB_TE_BINARY:
      {
        rc = ELIB_EALREADYDECODED;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_7BIT:
      {
        if (rc >= ELIB_RUNNING)
        {
          if (encoding == ELIB_TE_8BIT)
            rc = Decode8BIT(context, t_slice, true, filename, buffer);
          else
            rc = Decode7BIT(context, t_slice, true, filename, buffer);
        }
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        if (rc >= ELIB_RUNNING)
        {
          rc = DecodeQT(true, t_slice, ELIB_TE_NONE, 4096, filename);
        }
        break;
      }
      case ELIB_TE_BASE64:
      {
        rc = DecodeBASE64(context, t_slice, 4096);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    }  // end switch

    if (rc == ELIB_COMPLETED)
    {
      // need to replace current body data with this new encoded body data
      encoding = ELIB_TE_NONE;
      if ((ownership) && (!file))
        delete[] mem_base;
      if (file)
        delete[] mem_base;
      file = true;
      parsed = true;
      start = 0;
      len = bwritten;
      mem_base = new char[strlen(filename)+1];
      strcpy(mem_base, filename);
      mem_size = 0;
    }
  } // endif on rc == ELIB_RUNNING

  if (rc != ELIB_RUNNING)
  {
    if (filedes == 0)			// If caller DID NOT give us a file to use then
    {
      if (out_fd)
        fclose(out_fd);			// close the file as we opened it
      out_fd = 0;
    }
  }

  return rc;
}


// Remove to memory
ELib_rcode body::RemoveEncoding(ELIB_CONTEXT &context,
                                const clock_t t_slice)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }

  if (rc == ELIB_RUNNING)
  {
    char *new_memory = 0;

    switch (encoding)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_NONE:
      case ELIB_TE_BINARY:
      {
        rc = ELIB_EALREADYDECODED;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_7BIT:
      case ELIB_TE_BASE64:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = DecodeQT(false, t_slice, ELIB_TE_NONE, 4096, new_memory);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    } // end switch

    if (rc == ELIB_COMPLETED)		// If decoding has completed, then
    {
      // need to replace current body data with this new encoded body data
      encoding = ELIB_TE_NONE;
      if ((ownership) && (!file))
        delete[] mem_base;
      if (file)
        delete[] mem_base;
      file = false;
      parsed = true;
      start = 0;
      len = bwritten;
      mem_base = new_memory;
      mem_size = bwritten;
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}


// Encode to file
ELib_rcode body::ApplyEncoding(ELIB_CONTEXT& context,
                               const clock_t t_slice,
                               ELIB_TE       enc,
                               char*         filename,
                               uint32        buffer,
                               FILE*         filedes)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }
  else if (enc == encoding)
  {
    rc = ELIB_EALREADYENCODED;
  }

  if ((rc == ELIB_RUNNING) && (out_fd == 0))
  {
    if (filedes)
    {
      out_fd = filedes;
    }
    else
    {
      out_fd = fopen(filename, "wb+");
      if (out_fd == 0)
        rc = ELIB_EWRITEFAIL;
    }
  }

  if (rc == ELIB_RUNNING)
  {
    switch (enc)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_8BIT:			// 8bit not implemented yet
      case ELIB_TE_BINARY:			// cant apply binary or NONE (OS format), they are base formats.
      case ELIB_TE_NONE:
      {
        rc = ELIB_ENOTSUPPORTED;
        break;
      }
      case ELIB_TE_7BIT:
      {
        rc = Encode7BIT(context, t_slice, true, filename, buffer);
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = EncodeQT(true, t_slice, buffer, filename);
        break;
      }
      case ELIB_TE_BASE64:
      {
        rc = EncodeBASE64(context, t_slice, buffer);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    }  // end switch

    if (rc == ELIB_COMPLETED)			// If encoding has completed, then
    {
      // need to replace current body data with this new encoded body data
      encoding = enc;
      if ((ownership) && (!file))
        delete[] mem_base;
      if (file)
        delete[] mem_base;
      file = true;
      parsed = true;
      start = 0;
      len = bwritten;
      mem_base = new char[strlen(filename)+1];
      strcpy(mem_base, filename);
      mem_size = 0;
    }
  } // endif on rc == ELIB_RUNNING

  if (rc != ELIB_RUNNING)
  {
    if (filedes == 0)			// If we didn't get given the file opened, then
    {
      if (out_fd)
      {
        fclose(out_fd);			// we need to close it
        out_fd = 0;
      }
    }
  }

  return rc;
}


// Encode to memory
ELib_rcode body::ApplyEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               ELIB_TE       enc)
{
  ELib_rcode rc = ELIB_RUNNING;
  char *new_memory = 0;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }
  else if (enc == encoding)
  {
    rc = ELIB_EALREADYENCODED;
  }

  if (rc == ELIB_RUNNING)
  {
    switch (enc)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_BINARY:
      case ELIB_TE_7BIT:
      case ELIB_TE_NONE:
      case ELIB_TE_BASE64:
      {
        rc = ELIB_ENOTSUPPORTED;
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = EncodeQT(false, t_slice, 4096, new_memory);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    } // end switch
  }

  if (rc == ELIB_COMPLETED)
  {
    // need to replace current body data with this new encoded body data
    encoding = enc;
    if ((ownership) && (!file))
      delete[] mem_base;
    if (file)
      delete[] mem_base;
    file = false;
    parsed = true;
    start = 0;
    len = bwritten;
    mem_base = new_memory;
    mem_size = bwritten;
  }

  return rc;
}


// ********************************************************************************
// 7BIT Methods
//

// method to take the body in it's native system form(ie. RISC OS) Text file
// and CRLF terminate it.  Later I'll make this none blocking and throw error if
// characters are not legal 7bit ASCII
ELib_rcode body::Encode7BIT(ELIB_CONTEXT   &c,
                            const clock_t  t_slice,
                            bool           file_output,
                            char          *output,
                            uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;		// As I've not implemented memory output yet!
  else
  {
    bool ok = goto_start();		// Goto start of this body object
    if (!ok)
    {
      rc = ELIB_EINVALIDFILENAME;
    }
    else
    {
      bwritten = 0;
      char prev = 0;
      int error = 0;

      while ( (error != EOF) && (!end_of_data()) )
      {
        if (curchar == LF)				// if current char is a LF
        {
          if ((prev != CR) && (error != EOF))		// if previous char is not a CR then
          {
            error = fputc(CR, out_fd);			// write out a CR
            if (error != EOF) bwritten++;
          }
        }
        error = fputc(curchar, out_fd);
        if (error != EOF) bwritten++;
        prev = curchar;
        next_char();
      } // endwhile
      stop();
    }
  } // endif file_output check

  return rc;
}


ELib_rcode body::Decode7BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;				// As I've not implemented memory output yet!
  else
  {
    bool ok = goto_start();				// Goto start of this body object
    if (!ok)
    {
      rc = ELIB_EINVALIDFILENAME;
    }
    else
    {
      bwritten = 0;
      int error = 0;

      while ( (error != EOF) && (!end_of_data()) && (curpos<len))
      {
        if (curchar == CR)				// if current char is a CR
        {
          next_char();					// get the next char
          if (curchar == LF)				// if the next char is a LF then
          {
            error = fputc(LF, out_fd);			// Turn CRLF into LF by just outputing LF
            if (error != EOF) bwritten++;
          }
          else						// else, next char wasn't LF, so not a CRLF sequence, so
          {
            error = fputc(CR, out_fd);			// write out the CR and
            if (error !=EOF) bwritten++;
            error = fputc(curchar, out_fd);		// write out this character
            if (error !=EOF) bwritten++;
          }
        }
        else						// else current char wasn't a CR, so
        {
          error = fputc(curchar, out_fd);		// write it out
          if (error != EOF) bwritten++;
        }
        next_char();
      } // endwhile
      stop();
    } // endif goto_start() check
  } // endif file_output check

  return rc;
}
//
// End of 7BIT Methods
// ********************************************************************************


// ********************************************************************************
// 8BIT Methods
//
ELib_rcode body::Decode8BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           uint32         bufsize)
{
  return Decode7BIT(c, t_slice, file_output, output, bufsize);			// As for decoding 8BIT we just need to turn CRLF into OS linebreaks
}
//
// End of 8BIT Methods
// ********************************************************************************


// ********************************************************************************
// QUOTED PRINTABLE Methods
//
ELib_rcode body::DecodeQT(bool              output_to_file,
                          const clock_t     t_slice,
                          ELIB_TE           output_encoding,
                          uint32            bufsize,
                          char*&            output)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (qp_obj == 0)			// This is the start
  {
    rc = SetUpQT(output_to_file, output);
  }

  if ((qp_obj) && (rc >= ELIB_RUNNING))	// this is the next time slice or straight after a successful creation of qp_obj
  {
    rc = qp_obj->decode(t_slice, bwritten, output_encoding);
  }

  if (rc != ELIB_RUNNING)
  {
    CleanUpQT();
  }

  return rc;
}


void body::CleanUpQT(void)
{
  if (qp_obj)
  {
    delete qp_obj;
    qp_obj = 0;
  }
  stop();
}


ELib_rcode body::EncodeQT(bool              output_to_file,
                          const clock_t     t_slice,
                          uint32            bufsize,
                          char*&            output)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (qp_obj == 0)			// This is the start
  {
    rc = SetUpQT(output_to_file, output);
  }

  if ((qp_obj) && (rc >= ELIB_RUNNING))	// this is the next time slice or straight after a successful creation of qp_obj
  {
    rc = qp_obj->encode(t_slice, bwritten);
  }

  if (rc != ELIB_RUNNING)
  {
    CleanUpQT();
  }

  return rc;
}


ELib_rcode body::SetUpQT(bool output_to_file, char*& output)
{
  ELib_rcode rc = ELIB_RUNNING;

  bool ok = goto_start();
  if (ok)
  {
    if (file)
    {
      fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
    }
    bwritten = 0;

    if (rc >= ELIB_RUNNING)
    {
      if (file)
      {
        if (output_to_file == true)
        {
          qp_obj = new quotedprintable(fd, len, out_fd, rc);
        }
        else
        {
          qp_obj = new quotedprintable(fd, len, &output, rc);
        }
      }
      else
      {
        if (output_to_file == true)
        {
          qp_obj = new quotedprintable(mem_base, len, out_fd, rc);
        }
        else
        {
          qp_obj = new quotedprintable(mem_base, len, &output, rc);
        }
      }

      if (qp_obj == 0)
      {
        rc = ELIB_EMALLOCFAILED;
      }
    }
  }
  else
  {
    rc = ELIB_EFAILED;
  }

  return rc;
}
//
// End of QUOTED PRINTABLE Methods
// ********************************************************************************


// ********************************************************************************
// BASE64 Methods
//
ELib_rcode body::DecodeBASE64(ELIB_CONTEXT &context,
                              const clock_t t_slice,
                              uint32        buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (file == false)
    rc = ELIB_EINTERNALERR;	// memory as sourse not implemented

  if (rc == ELIB_RUNNING)
  {
    if (context == 0)		// if this is the start (we've not opend the files yet), then
    {
      new_context(&context);

      bool ok = goto_start();	// move to start in file
      if (ok)
      {
        fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
      }
      else
        rc = ELIB_EINVALIDFILENAME;
    }

    rc = base64decode(&context, t_slice, fd, out_fd, buffer, &bwritten);
    if (rc != ELIB_RUNNING)
    {
      destroy_context(&context);
      stop();
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}


ELib_rcode body::EncodeBASE64(ELIB_CONTEXT &context,
                              const clock_t t_slice,
                              uint32        buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (file == false)
    rc = ELIB_EINTERNALERR;	// memory as sourse not implemented

  if (rc == ELIB_RUNNING)
  {
    if (context == 0)		// if this is the start (we've not opend the files yet), then
    {
      new_context(&context);

      bool ok = goto_start();	// move to start in file
      if (ok)
      {
        fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
      }
      else
        rc = ELIB_EINVALIDFILENAME;
    }

    rc = base64encode(&context, t_slice, fd, out_fd, buffer, &bwritten);
    if (rc != ELIB_RUNNING)
    {
      destroy_context(&context);
      stop();
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}
//
// End of BASE64 Methods
// ********************************************************************************


ELib_rcode body::GetCharSet(char*& data, uint32 &size)
{
  static char charset[] = "iso-8859-1";
  ELib_rcode rc = ELIB_DEFAULTED;

  if (data == 0)								// If we've not been given a block of memory
  {
    if (size == 0)								// are we to allocate some, if size == 0, then no
    {
      size = strlen(charset) + 1;
      rc = ELIB_ENULLADDR;
    }
    else									// else, allocate the required amount of space
    {
      size = strlen(charset) + 1;
      data = new char[size];
      if (data == 0)
        rc = ELIB_EMALLOCFAILED;
    }
  }

  if (data)									// if memory allocated, then
  {
    if (size >= strlen(charset) + 1)						// is it big enough?  if so then
    {
      strcpy(data, charset);
    }
    else
      rc = ELIB_ENOSPACE;
  }

  return rc;
}
