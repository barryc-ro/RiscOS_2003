/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		body.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.14 for RISC OS

	OVERVIEW
	========
	Source file for implementation of body object

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	11/09/97	0.02	RDW	modified RemoveEncoding to file method
					so that the body object now uses that
					file as	it's data and disguards the
					original
					ApplyEncoding to file method done
	12/09/97	0.03	RDW	Merged file and memory constructors
					into one.
	26/11/97	0.04	RDW	Apply_encoding, encode to 7bit
					added for file version with Encode7BIT
					method.  Remove_encoding, decode to
					RISCOS text file added for file version
					with Decode7BIT method.
	29/11/97	0.05	RDW	type private method initialised in
					constructors and added to copybodyobject
					method.
	04/12/97	0.06	RDW	RemoveEncoding method added with FILE* parameter
					to use instead of opening the filename directly
					Decode7BIT modified to have a FILE* parameter too.
	20/01/98	0.07	RDW	if goto_start returns false, rcode is now set
					to ELIB_EINVALIDFILENAME and not ELIB_EFAILED
	18/02/98	0.08	RDW	#include DebugLib path added
	27/02/98	0.09	RDW	RemoveEncoding() ELIB_TE_8BIT changed to
					return ELIB_ENOTSUPPORTED
	30/09/98	0.10	RDW	RemoveEncoding() ELIB_TE_8BIT support added
					Decode8BIT() method added
	01/10/98	0.11	RDW	Display() method changed to support 7BIT/NONE
					encoding as separate types now
	04/10/98	0.12	RDW	Intergrating quotedprintable support
					out data member renamed to out_fd
					DecodeQT(), EncodeQT(), SetUpQT() and CleanUpAT()
					methods added
					Memory versions of RemoveEncoding() methods
					implemented for QT support only.  Destination
					memory parameter removed as body object itself
					will allocate the memory to use
	06/10/98	0.13	RDW	GetCharSet() method added
	07/10/98	0.14	RDW	WriteOut() method file version added (do memory
					later) so an output data format can be specified
					ie. output data suitable for 7BIT transport, 8BIT
					transport, etc.
					Fixed RemoveEncoding/ApplyEncoding to a file so that
					it doesn't assume that it's outputing data at the start
					of the file.
					Moved Apply/RemoveEncoding into private
					PerformApply/RemoveEncoding methods except for
					the operation of swapping in the new data file
					This is so Perform... methods can be used by the
					WriteOut data type methods as for these we don't
					want to replace the source data
					implementation of GetWriteOutEncoding() method added
					SetCharSet() method added and constructors now default
					charset.  New constructor added to accept charset
*/


/* ************************************************************************** */
/*                                                                            */
/* Include header files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include header files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "body.h"
#include "elibbase.h"
#include "quotedprintable.h"
extern "C"
{
  #include "ELib.h"
  #include "base64.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Constants                                                                  */
/*                                                                            */
/* ************************************************************************** */
const uint32 B64_SIZE_THRESHOLD = 4096;
const uint32 B64_PERCENTAGE_THRESHOLD = 25;
const uint32 MAX_7BIT_LINE_LENGTH = 75;


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */
typedef enum
{
  LF = 10,
  CR = 13
} CHARS;


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */
static char* charsets[] =
{
  "us-ascii",
  "iso-8859-1",
  "UNKNOWN"
};


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a body object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
body::body(void)
     :elibbase(),
      encoding(ELIB_TE_UNKNOWN),
      out_fd(0),
      type(ELIB_BODY),
      qp_obj(0),
      new_start(0),
      charset(ELIB_CS_ISO_8859_1),
      data_outside_7bit(0),
      charset_string(0)
{

}


body::body(bool f, char *membase, uint32 offset, uint32 length, ELIB_TE enc, bool owner)
     :elibbase(f, membase, offset, length, owner),
      encoding(enc),
      out_fd(0),
      type(ELIB_BODY),
      qp_obj(0),
      new_start(0),
      charset(ELIB_CS_ISO_8859_1),
      data_outside_7bit(0),
      charset_string(0)
{

}


body::body(bool f, char *membase, uint32 offset, uint32 length, ELIB_TE enc, ELIB_CS cset, bool owner)
     :elibbase(f, membase, offset, length, owner),
      encoding(enc),
      out_fd(0),
      type(ELIB_BODY),
      qp_obj(0),
      new_start(0),
      charset(cset),
      data_outside_7bit(0),
      charset_string(charsets[cset])
{

}


// copy constructor
body::body(const body &object)
     :elibbase(object),
      out_fd(0),
      encoding(ELIB_TE_UNKNOWN),
      qp_obj(0),
      new_start(0),
      charset(ELIB_CS_ISO_8859_1),
      data_outside_7bit(0),
      charset_string(0)
{
  copybodyobject(object);
}


// assignment operator
body& body::operator=(const body &object)
{
  elibbase::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    if (out_fd)
    {
      fclose(out_fd);
      out_fd = 0;
    }
    if (qp_obj)
    {
      delete qp_obj;
      qp_obj = 0;
    }
    if ((charset == ELIB_CS_UNKNOWN) && (charset_string))
    {
      delete[] charset_string;
      charset_string = 0;
    }
    copybodyobject(object);
  }
  return *this;
}


void body::copybodyobject(const body &object)
{
  encoding = object.encoding;
  out_fd = object.out_fd;
  type = object.type;
  charset = object.charset;
  if (charset == ELIB_CS_UNKNOWN)
  {
    charset_string = new char[strlen(object.charset_string)+1];
    if (charset_string)
      strcpy(charset_string, object.charset_string);
  }
  else
    charset_string = object.charset_string;
  data_outside_7bit = object.data_outside_7bit;
}


// Implementation of destructor for body
body::~body()
{
  if (out_fd)
  {
    fclose(out_fd);
    out_fd = 0;
  }
  if (qp_obj)
  {
    delete qp_obj;
    qp_obj = 0;
  }
  if ((charset == ELIB_CS_UNKNOWN) && (charset_string))
  {
    delete[] charset_string;
    charset_string = 0;
  }
}


ELib_rcode body::parse(ELIB_CONTEXT &context, clock_t t_slice)
{
  ELib_rcode rc = ELIB_COMPLETED;
  bool is_usascii = true;
  data_outside_7bit = 0;

  if (goto_start())
  {
    uint32 num_of_chars_in_line = 0;
    bool long_lines = false;

    while ((!end_of_data()) && (data_outside_7bit < base64_threshold()))
    {
      if ((uint32)curchar > 127)
      {
        is_usascii = false;
        data_outside_7bit++;
      }
      else if (curchar == '\n')
      {
        if (num_of_chars_in_line > MAX_7BIT_LINE_LENGTH)
        {
          num_of_chars_in_line = 0;
          long_lines = true;
        }
      }
      next_char();
      num_of_chars_in_line++;
    }
    stop();

    if (num_of_chars_in_line > MAX_7BIT_LINE_LENGTH)
    {
      long_lines = true;
    }

    if ((data_outside_7bit != 0) && (is_usascii == true))
    {
      is_usascii = false;
    }

    if (is_usascii == true)
      rc = SetCharSet(ELIB_CS_US_ASCII);

    if ((data_outside_7bit == 0) && (long_lines == true))
      data_outside_7bit = 1;
  }
  else
    rc = ELIB_EINVALIDFILENAME;

  return rc;
}


void body::Display(void)
{
  printf("BODY DISPLAY:\n");
  printf("CHARSET     : %s\n", charsets[charset]);
  printf("ENCODING    : ");
  switch (encoding)
  {
    case ELIB_TE_NONE:
      printf("NONE\n");
      break;
    case ELIB_TE_7BIT:
      printf("7BIT\n");
      break;
    case ELIB_TE_8BIT:
      printf("8BIT\n");
      break;
    case ELIB_TE_BINARY:
      printf("BINARY\n");
      break;
    case ELIB_TE_QUOTED_PRINTABLE:
      printf("QUOTED_PRINTABLE\n");
      break;
    case ELIB_TE_BASE64:
      printf("BASE64\n");
      break;
    case ELIB_TE_UNKNOWN:
      printf("UNKNOWN\n");
      break;
    default:
      printf("INTERNALERR\n");
  }
  elibbase::Display();
  printf("END OF BODY\n");
  printf("\n");
}


ELib_rcode body::GetEncoding(ELIB_TE &enc)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (data_present())
    enc = encoding;
  else
    rc = ELIB_ENODATAPRESENT;
  return rc;
}


// Remove to file
ELib_rcode body::PerformRemoveEncoding(ELIB_CONTEXT  &context,
                                       const clock_t  t_slice,
                                       char          *filename,
                                       FILE          *filedes,
                                       uint32         buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }

  if ((rc == ELIB_RUNNING) && (out_fd == 0))
  {
    bwritten = 0;
    if (filedes)
    {
      out_fd = filedes;
    }
    else
    {
      out_fd = fopen(filename, "wb+");
      if (out_fd == 0)
        rc = ELIB_EWRITEFAIL;
    }
    long int tmp = ftell(out_fd);
    if (tmp < 0)
      rc = ELIB_EFAILED;
    else
      new_start = (uint32)tmp;
  }

  if (rc == ELIB_RUNNING)
  {
    switch (encoding)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_NONE:
      case ELIB_TE_BINARY:
      {
        rc = ELIB_EALREADYDECODED;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_7BIT:
      {
        if (rc >= ELIB_RUNNING)
        {
          if (encoding == ELIB_TE_8BIT)
            rc = Decode8BIT(context, t_slice, true, filename, buffer);
          else
            rc = Decode7BIT(context, t_slice, true, filename, buffer);
        }
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        if (rc >= ELIB_RUNNING)
        {
          rc = DecodeQT(true, t_slice, ELIB_TE_NONE, 4096, filename);
        }
        break;
      }
      case ELIB_TE_BASE64:
      {
        rc = DecodeBASE64(context, t_slice, 4096);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    }  // end switch

  } // endif on rc == ELIB_RUNNING

  if (rc != ELIB_RUNNING)
  {
    if (filedes == 0)			// If caller DID NOT give us a file to use then
    {
      if (out_fd)
        fclose(out_fd);			// close the file as we opened it
      out_fd = 0;
    }
  }

  return rc;
}


ELib_rcode body::RemoveEncoding(ELIB_CONTEXT  &context,
                                const clock_t  t_slice,
                                char          *filename,
                                uint32         buffer)
{
  return RemoveEncoding(context, t_slice, filename, 0, buffer);
}


ELib_rcode body::RemoveEncoding(ELIB_CONTEXT  &context,
                                const clock_t  t_slice,
                                char          *filename,
                                FILE          *filedes,
                                uint32         buffer)
{
  ELib_rcode rc = PerformRemoveEncoding(context, t_slice, filename, filedes, buffer);

  if (rc == ELIB_COMPLETED)
  {
    // need to replace current body data with this new encoded body data
    encoding = ELIB_TE_NONE;
    ReplaceData(filename);
  }

  return rc;
}


void body::ReplaceData(char* filename)
{
  if ((ownership) && (!file))
    delete[] mem_base;
  if (file)
    delete[] mem_base;
  file = true;
  parsed = true;
  start = new_start;
  len = bwritten;
  mem_base = new char[strlen(filename)+1];
  strcpy(mem_base, filename);
  mem_size = 0;
}


// Remove to memory
ELib_rcode body::RemoveEncoding(ELIB_CONTEXT &context,
                                const clock_t t_slice)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }

  if (rc == ELIB_RUNNING)
  {
    char *new_memory = 0;

    switch (encoding)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_NONE:
      case ELIB_TE_BINARY:
      {
        rc = ELIB_EALREADYDECODED;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_7BIT:
      case ELIB_TE_BASE64:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = DecodeQT(false, t_slice, ELIB_TE_NONE, 4096, new_memory);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    } // end switch

    if (rc == ELIB_COMPLETED)		// If decoding has completed, then
    {
      // need to replace current body data with this new encoded body data
      encoding = ELIB_TE_NONE;
      if ((ownership) && (!file))
        delete[] mem_base;
      if (file)
        delete[] mem_base;
      file = false;
      parsed = true;
      start = 0;
      len = bwritten;
      mem_base = new_memory;
      mem_size = bwritten;
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}


// Encode to file
ELib_rcode body::PerformApplyEncoding(ELIB_CONTEXT& context,
                                      const clock_t t_slice,
                                      ELIB_TE       enc,
                                      char*         filename,
                                      uint32        buffer,
                                      FILE*         filedes)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }
  else if (enc == encoding)
  {
    rc = ELIB_EALREADYENCODED;
  }

  if ((rc == ELIB_RUNNING) && (out_fd == 0))
  {
    bwritten = 0;
    if (filedes)
    {
      out_fd = filedes;
    }
    else
    {
      out_fd = fopen(filename, "wb+");
      if (out_fd == 0)
        rc = ELIB_EWRITEFAIL;
    }
    long int tmp = ftell(out_fd);
    if (tmp < 0)
      rc = ELIB_EFAILED;
    else
      new_start = (uint32)tmp;
  }

  if (rc == ELIB_RUNNING)
  {
    switch (enc)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_8BIT:			// 8bit not implemented yet
      case ELIB_TE_BINARY:			// cant apply binary or NONE (OS format), they are base formats.
      case ELIB_TE_NONE:
      {
        rc = ELIB_ENOTSUPPORTED;
        break;
      }
      case ELIB_TE_7BIT:
      {
        rc = Encode7BIT(context, t_slice, true, filename, buffer);
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = EncodeQT(true, t_slice, buffer, filename);
        break;
      }
      case ELIB_TE_BASE64:
      {
        rc = EncodeBASE64(context, t_slice, buffer);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    }  // end switch
  } // endif on rc == ELIB_RUNNING

  if (rc != ELIB_RUNNING)
  {
    if (filedes == 0)			// If we didn't get given the file opened, then
    {
      if (out_fd)
      {
        fclose(out_fd);			// we need to close it
        out_fd = 0;
      }
    }
  }

  return rc;
}


// Encode to file
ELib_rcode body::ApplyEncoding(ELIB_CONTEXT& context,
                               const clock_t t_slice,
                               ELIB_TE       enc,
                               char*         filename,
                               uint32        buffer,
                               FILE*         filedes)
{
  ELib_rcode rc = PerformApplyEncoding(context, t_slice, enc, filename, buffer, filedes);

  if (rc == ELIB_COMPLETED)			// If encoding has completed, then
  {
    // need to replace current body data with this new encoded body data
    encoding = enc;
    ReplaceData(filename);
  }

  return rc;
}


// Encode to memory
ELib_rcode body::ApplyEncoding(ELIB_CONTEXT &context,
                               const clock_t t_slice,
                               ELIB_TE       enc)
{
  ELib_rcode rc = ELIB_RUNNING;
  char *new_memory = 0;

  if (data_present() == false)
  {
    rc = ELIB_ENODATAPRESENT;
  }
  else if (enc == encoding)
  {
    rc = ELIB_EALREADYENCODED;
  }

  if (rc == ELIB_RUNNING)
  {
    switch (enc)
    {
      case ELIB_TE_UNKNOWN:
      {
        rc = ELIB_ECANTDOUNKNOWN;
        break;
      }
      case ELIB_TE_8BIT:
      case ELIB_TE_BINARY:
      case ELIB_TE_7BIT:
      case ELIB_TE_NONE:
      case ELIB_TE_BASE64:
      {
        rc = ELIB_ENOTSUPPORTED;
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = EncodeQT(false, t_slice, 4096, new_memory);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    } // end switch
  }

  if (rc == ELIB_COMPLETED)
  {
    // need to replace current body data with this new encoded body data
    encoding = enc;
    if ((ownership) && (!file))
      delete[] mem_base;
    if (file)
      delete[] mem_base;
    file = false;
    parsed = true;
    start = 0;
    len = bwritten;
    mem_base = new_memory;
    mem_size = bwritten;
  }

  return rc;
}


// ********************************************************************************
// 7BIT Methods
//

// method to take the body in it's native system form(ie. RISC OS) Text file
// and CRLF terminate it.  Later I'll make this none blocking and throw error if
// characters are not legal 7bit ASCII
ELib_rcode body::Encode7BIT(ELIB_CONTEXT   &c,
                            const clock_t  t_slice,
                            bool           file_output,
                            char          *output,
                            uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;		// As I've not implemented memory output yet!
  else
  {
    bool ok = goto_start();		// Goto start of this body object
    if (!ok)
    {
      rc = ELIB_EINVALIDFILENAME;
    }
    else
    {
      bwritten = 0;
      char prev = 0;
      int error = 0;

      while ( (error != EOF) && (!end_of_data()) )
      {
        if (curchar == LF)				// if current char is a LF
        {
          if ((prev != CR) && (error != EOF))		// if previous char is not a CR then
          {
            error = fputc(CR, out_fd);			// write out a CR
            if (error != EOF) bwritten++;
          }
        }
        error = fputc(curchar, out_fd);
        if (error != EOF) bwritten++;
        prev = curchar;
        next_char();
      } // endwhile
      stop();
    }
  } // endif file_output check

  return rc;
}


ELib_rcode body::Decode7BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           uint32         bufsize)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (!file_output)
    rc = ELIB_EINTERNALERR;				// As I've not implemented memory output yet!
  else
  {
    bool ok = goto_start();				// Goto start of this body object
    if (!ok)
    {
      rc = ELIB_EINVALIDFILENAME;
    }
    else
    {
      bwritten = 0;
      int error = 0;

      while ( (error != EOF) && (!end_of_data()) && (curpos<len))
      {
        if (curchar == CR)				// if current char is a CR
        {
          next_char();					// get the next char
          if (curchar == LF)				// if the next char is a LF then
          {
            error = fputc(LF, out_fd);			// Turn CRLF into LF by just outputing LF
            if (error != EOF) bwritten++;
          }
          else						// else, next char wasn't LF, so not a CRLF sequence, so
          {
            error = fputc(CR, out_fd);			// write out the CR and
            if (error !=EOF) bwritten++;
            error = fputc(curchar, out_fd);		// write out this character
            if (error !=EOF) bwritten++;
          }
        }
        else						// else current char wasn't a CR, so
        {
          error = fputc(curchar, out_fd);		// write it out
          if (error != EOF) bwritten++;
        }
        next_char();
      } // endwhile
      stop();
    } // endif goto_start() check
  } // endif file_output check

  return rc;
}
//
// End of 7BIT Methods
// ********************************************************************************


// ********************************************************************************
// 8BIT Methods
//
ELib_rcode body::Decode8BIT(ELIB_CONTEXT   &c,
                           const clock_t  t_slice,
                           bool           file_output,
                           char          *output,
                           uint32         bufsize)
{
  return Decode7BIT(c, t_slice, file_output, output, bufsize);			// As for decoding 8BIT we just need to turn CRLF into OS linebreaks
}
//
// End of 8BIT Methods
// ********************************************************************************


// ********************************************************************************
// QUOTED PRINTABLE Methods
//
ELib_rcode body::DecodeQT(bool              output_to_file,
                          const clock_t     t_slice,
                          ELIB_TE           output_encoding,
                          uint32            bufsize,
                          char*&            output)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (qp_obj == 0)			// This is the start
  {
    rc = SetUpQT(output_to_file, output);
  }

  if ((qp_obj) && (rc >= ELIB_RUNNING))	// this is the next time slice or straight after a successful creation of qp_obj
  {
    rc = qp_obj->decode(t_slice, bwritten, output_encoding);
  }

  if (rc != ELIB_RUNNING)
  {
    CleanUpQT();
  }

  return rc;
}


void body::CleanUpQT(void)
{
  if (qp_obj)
  {
    delete qp_obj;
    qp_obj = 0;
  }
  stop();
}


ELib_rcode body::EncodeQT(bool              output_to_file,
                          const clock_t     t_slice,
                          uint32            bufsize,
                          char*&            output)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (qp_obj == 0)			// This is the start
  {
    rc = SetUpQT(output_to_file, output);
  }

  if ((qp_obj) && (rc >= ELIB_RUNNING))	// this is the next time slice or straight after a successful creation of qp_obj
  {
    rc = qp_obj->encode(t_slice, bwritten);
  }

  if (rc != ELIB_RUNNING)
  {
    CleanUpQT();
  }

  return rc;
}


ELib_rcode body::SetUpQT(bool output_to_file, char*& output)
{
  ELib_rcode rc = ELIB_RUNNING;

  bool ok = goto_start();
  if (ok)
  {
    if (file)
    {
      fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
    }
    bwritten = 0;

    if (rc >= ELIB_RUNNING)
    {
      if (file)
      {
        if (output_to_file == true)
        {
          qp_obj = new quotedprintable(fd, len, out_fd, rc);
        }
        else
        {
          qp_obj = new quotedprintable(fd, len, &output, rc);
        }
      }
      else
      {
        if (output_to_file == true)
        {
          qp_obj = new quotedprintable(mem_base, len, out_fd, rc);
        }
        else
        {
          qp_obj = new quotedprintable(mem_base, len, &output, rc);
        }
      }

      if (qp_obj == 0)
      {
        rc = ELIB_EMALLOCFAILED;
      }
    }
  }
  else
  {
    rc = ELIB_EFAILED;
  }

  return rc;
}
//
// End of QUOTED PRINTABLE Methods
// ********************************************************************************


// ********************************************************************************
// BASE64 Methods
//
ELib_rcode body::DecodeBASE64(ELIB_CONTEXT &context,
                              const clock_t t_slice,
                              uint32        buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (file == false)
    rc = ELIB_EINTERNALERR;	// memory as sourse not implemented

  if (rc == ELIB_RUNNING)
  {
    if (context == 0)		// if this is the start (we've not opend the files yet), then
    {
      new_context(&context);

      bool ok = goto_start();	// move to start in file
      if (ok)
      {
        fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
      }
      else
        rc = ELIB_EINVALIDFILENAME;
    }

    if (rc >= ELIB_RUNNING)
      rc = base64decode(&context, t_slice, fd, out_fd, buffer, &bwritten);
    if (rc != ELIB_RUNNING)
    {
      destroy_context(&context);
      stop();
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}


ELib_rcode body::EncodeBASE64(ELIB_CONTEXT &context,
                              const clock_t t_slice,
                              uint32        buffer)
{
  ELib_rcode rc = ELIB_RUNNING;

  if (file == false)
    rc = ELIB_EINTERNALERR;	// memory as sourse not implemented

  if (rc == ELIB_RUNNING)
  {
    if (context == 0)		// if this is the start (we've not opend the files yet), then
    {
      new_context(&context);

      bool ok = goto_start();	// move to start in file
      if (ok)
      {
        fseek(fd, -1, SEEK_CUR);	// move back on char in file as goto_start reads in first char
      }
      else
        rc = ELIB_EINVALIDFILENAME;
    }

    if (rc >= ELIB_RUNNING)
      rc = base64encode(&context, t_slice, fd, out_fd, buffer, &bwritten);

    if (rc != ELIB_RUNNING)
    {
      destroy_context(&context);
      stop();
    }
  } // endif on rc == ELIB_RUNNING

  return rc;
}
//
// End of BASE64 Methods
// ********************************************************************************


ELib_rcode body::GetCharSet(char*& data, uint32 &size)
{
  ELib_rcode rc = ELIB_DEFAULTED;

  if (data == 0)								// If we've not been given a block of memory
  {
    if (size == 0)								// are we to allocate some, if size == 0, then no
    {
      size = strlen(charsets[charset]) + 1;
      rc = ELIB_ENULLADDR;
    }
    else									// else, allocate the required amount of space
    {
      size = strlen(charsets[charset]) + 1;
      data = new char[size];
      if (data == 0)
        rc = ELIB_EMALLOCFAILED;
    }
  }

  if (data)									// if memory allocated, then
  {
    if (size >= strlen(charsets[charset]) + 1)					// is it big enough?  if so then
    {
      strcpy(data, charsets[charset]);
    }
    else
      rc = ELIB_ENOSPACE;
  }

  return rc;
}


ELib_rcode body::SetCharSet(const char* const set, uint32 length)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (set)
  {
    if (length == 0)
      length = strlen(set);

    if (charset == ELIB_CS_UNKNOWN)
    {
      delete[] charset_string;
    }

    bool match = false;
    uint32 count = ELIB_CS_US_ASCII;
    while ((charset<ELIB_CS_UNKNOWN) && (match == false))
    {
      if (strncmp(set, charsets[count], length) == 0)
        match = true;
      else
        count++;
    }
    charset = (ELIB_CS)count;

    if (match)
    {
      charset_string = charsets[charset];
    }
    else
    {
      charset = ELIB_CS_UNKNOWN;
      charset_string = new char[length+1];
      if (charset_string)
      {
        memcpy(charset_string, set, length);
        charset_string[length] = '\0';
      }
      else
        rc = ELIB_EMALLOCFAILED;
    }
  }
  else
    rc = ELIB_ENULLADDR;

  return rc;
}


ELib_rcode body::SetCharSet(ELIB_CS set)
{
  ELib_rcode rc = ELIB_COMPLETED;

  if (set == ELIB_CS_UNKNOWN)
  {
    rc = ELIB_ECANTDOUNKNOWN;
  }
  else
  {
    rc = SetCharSet(charsets[set], 0);
  }

  return rc;
}


ELib_rcode body::WriteOut(ELIB_CONTEXT& context, clock_t t_slice, FILE* file)
{
  return super::WriteOut(context, t_slice, file);
}

// function to write out the object to memory
ELib_rcode body::WriteOut(ELIB_CONTEXT& context, clock_t t_slice, char* mem, uint32& l)
{
  return super::WriteOut(context, t_slice, mem, l);
}


// function to write out the object to file
ELib_rcode body::WriteOut(ELIB_CONTEXT &context, clock_t t_slice, FILE *f, ELIB_TE format)
{
  ELib_rcode rc = ELIB_COMPLETED;
  ELIB_TE output_encoding = GetWriteOutEncoding(format);

  if (output_encoding == encoding)
  {
    rc = super::WriteOut(context, t_slice, f, format);
  }
  else
  {
    switch (output_encoding)
    {
      case ELIB_TE_NONE:
      case ELIB_TE_BINARY:
      {
        rc = WriteOutAs_BINARY(context, t_slice, f);
        break;
      }
      case ELIB_TE_7BIT:
      {
        rc = WriteOutAs_7BIT(context, t_slice, f);
        break;
      }
      case ELIB_TE_QUOTED_PRINTABLE:
      {
        rc = WriteOutAs_QUOTED_PRINTABLE(context, t_slice, f);
        break;
      }
      case ELIB_TE_8BIT:
      {
        rc = WriteOutAs_8BIT(context, t_slice, f);
        break;
      }
      case ELIB_TE_BASE64:
      {
        rc = WriteOutAs_BASE64(context, t_slice, f);
        break;
      }
      default:
      {
        rc = ELIB_EINTERNALERR;
        break;
      }
    }
  }

  return rc;
}


ELib_rcode body::WriteOutAs_7BIT(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  switch (encoding)
  {
    case ELIB_TE_NONE:					// Not suitable for 7BIT
    case ELIB_TE_8BIT:
    case ELIB_TE_BINARY:
    {
      rc = ELIB_RUNNING;
      new_context(&context);
      while (rc == ELIB_RUNNING)
      {
        t_slice = clock() + 50;
        rc = PerformApplyEncoding(context, t_slice, ELIB_TE_7BIT, "", 3072, f);
      }
      destroy_context(&context);
      break;
    }
    case ELIB_TE_QUOTED_PRINTABLE:			// Should not get here, as GetWriteOutEncoding() will leave encoded data as is
    case ELIB_TE_BASE64:
    case ELIB_TE_7BIT:					// Should not get 7BIt as WriteOut should recongise we are already in correct format
    {
      rc = ELIB_EINTERNALERR;
      break;
    }
    case ELIB_TE_UNKNOWN:				// Unknown encoding format, erk! what to do???
    default:
    {
      rc = ELIB_ECANTDOUNKNOWN;
      break;
    }
  }

  return rc;
}


ELib_rcode body::WriteOutAs_8BIT(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  switch (encoding)
  {
    case ELIB_TE_NONE:					// Not suitable for 8BIT
    case ELIB_TE_BINARY:				// Text entities should overload this implementation and determine
			      				// they're own body contents to see if 7BIT, QPRINT. would be better
    {
      rc = ELIB_RUNNING;
      new_context(&context);
      while (rc == ELIB_RUNNING)
      {
        t_slice = clock() + 50;
        rc = PerformApplyEncoding(context, t_slice, ELIB_TE_8BIT, "", 3072, f);
      }
      destroy_context(&context);
      break;
    }
    case ELIB_TE_7BIT:					// Should not get here, as GetWriteOutEncoding() will leave encoded data as is
    case ELIB_TE_QUOTED_PRINTABLE:
    case ELIB_TE_BASE64:
    case ELIB_TE_8BIT:					// Should not get 8Bit as WriteOut should recognise we are already in correct format
    {
      rc = ELIB_EINTERNALERR;
      break;
    }
    case ELIB_TE_UNKNOWN:				// Unknown encoding format, erk! what to do???
    default:
    {
      rc = ELIB_ECANTDOUNKNOWN;
      break;
    }
  }

  return rc;
}


ELib_rcode body::WriteOutAs_QUOTED_PRINTABLE(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  switch (encoding)
  {
    case ELIB_TE_NONE:					// Not suitable for 7BIT stream so encode it
    case ELIB_TE_8BIT:
    case ELIB_TE_BINARY:
    {
      rc = ELIB_RUNNING;
      new_context(&context);
      while (rc == ELIB_RUNNING)
      {
        t_slice = clock() + 50;
        rc = PerformApplyEncoding(context, t_slice, ELIB_TE_QUOTED_PRINTABLE, "", 3072, f);
      }
      destroy_context(&context);
      break;
    }
    case ELIB_TE_7BIT:					// Should not get here, as GetWriteOutEncoding() will leave encoded data as is
    case ELIB_TE_BASE64:
    case ELIB_TE_QUOTED_PRINTABLE:			// Should not get here as WriteOut should recongise we are already in correct format
    {
      rc = ELIB_EINTERNALERR;
      break;
    }
    case ELIB_TE_UNKNOWN:				// Unknown encoding format, erk! what to do???
    default:
    {
      rc = ELIB_ECANTDOUNKNOWN;
      break;
    }
  }

  return rc;
}


ELib_rcode body::WriteOutAs_BASE64(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  switch (encoding)
  {
    case ELIB_TE_NONE:					// Not suitable for 7BIT stream so encode it
    case ELIB_TE_8BIT:
    case ELIB_TE_BINARY:
    {
      rc = ELIB_RUNNING;
      new_context(&context);
      while (rc == ELIB_RUNNING)
      {
        t_slice = clock() + 50;
        rc = PerformApplyEncoding(context, t_slice, ELIB_TE_BASE64, "", 3072, f);
      }
      destroy_context(&context);
      break;
    }
    case ELIB_TE_7BIT:					// Should not get here, as GetWriteOutEncoding() will leave encoded data as is
    case ELIB_TE_QUOTED_PRINTABLE:
    case ELIB_TE_BASE64:				// Should not get here as WriteOut should recongise we are already in correct format
    {
      rc = ELIB_EINTERNALERR;
      break;
    }
    case ELIB_TE_UNKNOWN:				// Unknown encoding format, erk! what to do???
    default:
    {
      rc = ELIB_ECANTDOUNKNOWN;
      break;
    }
  }

  return rc;
}


ELib_rcode body::WriteOutAs_BINARY(ELIB_CONTEXT &context, clock_t t_slice, FILE *f)
{
  ELib_rcode rc = ELIB_COMPLETED;

  switch (encoding)
  {
    case ELIB_TE_7BIT:
    case ELIB_TE_8BIT:
    case ELIB_TE_QUOTED_PRINTABLE:
    case ELIB_TE_BASE64:
    {
      rc = ELIB_RUNNING;
      new_context(&context);
      while (rc == ELIB_RUNNING)
      {
        t_slice = clock() + 50;
        rc = PerformRemoveEncoding(context, t_slice, "", f, 4096);
      }
      destroy_context(&context);
      break;
    }
    case ELIB_TE_NONE:					// Should not get here as WriteOut should recongise we are already in correct format
    case ELIB_TE_BINARY:
    {
      rc = ELIB_EINTERNALERR;
      break;
    }
    case ELIB_TE_UNKNOWN:				// Unknown encoding format, erk! what to do???
    default:
    {
      rc = ELIB_ECANTDOUNKNOWN;
      break;
    }
  }

  return rc;
}


// Given the data_stream_type of 7BIT, 8BIT, BINARY, or NONE
// Which encoding will this body object use if told to WriteOut
// in a form suitable for the given data stream
ELIB_TE body::GetWriteOutEncoding(ELIB_TE data_stream_type)
{
  ELIB_TE data_format = ELIB_TE_BASE64;

  switch (data_stream_type)
  {
    case ELIB_TE_NONE:			// if NONE requested, we just writeout in our current format
    {
      data_format = encoding;
      break;
    }
    case ELIB_TE_BINARY:		// If stream has no restrictions, we'll decode down to raw data no encoding
    {
      data_format = ELIB_TE_BINARY;
      break;
    }
    case ELIB_TE_7BIT:
    case ELIB_TE_8BIT:
    {
      if ((encoding == ELIB_TE_BASE64) || (encoding == ELIB_TE_QUOTED_PRINTABLE))	// If it's already encoded as base64 or quotedprintable
        										// then lets just write that out
      {
        data_format = encoding;
      }
      else if (data_outside_7bit == 0)							// If the raw data has nothing outside 7bit range then
      {
        data_format = ELIB_TE_7BIT;							// do 7bit
      }
      else if ((data_outside_7bit > 0) &&						// else, if outside 7bit range but below the threshold
               (data_outside_7bit < base64_threshold()))				// for using BASE64, then
      {
        if (data_stream_type == ELIB_TE_7BIT)
          data_format = ELIB_TE_QUOTED_PRINTABLE;					// use quoted printable if stream is 7bit
        else
          data_format = ELIB_TE_8BIT;							// else, use 8bit
      }
      else										// else, raw data is binary, so use base64
      {
        data_format = ELIB_TE_BASE64;
      }
      break;
    }
    default:
    {
      data_format = ELIB_TE_BASE64;							// default to BASE64 as this will always be safe
      break;
    }
  } // end switch

  return data_format;
}


// Return the number of characters needed to cause base64 to be chosen
uint32 body::base64_threshold(void)
{
  if (len > B64_SIZE_THRESHOLD)					// If body size is greater than the size threshold then
    return (len/100)*B64_PERCENTAGE_THRESHOLD;			// return the number of characters allowed to before we switch to b64
  else								// else
    return len + 1;						//
}

