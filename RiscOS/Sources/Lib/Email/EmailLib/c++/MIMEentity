/*	Project Post (769)
	Acorn Computers Ltd
	Copyright © 1997. All Rights Reserved.

	FILE:		MIMEentity.c++
	AUTHOR:		Richard D. Warren
	VERSION:	0.09D for RISC OS

	OVERVIEW
	========
	Source file for implementation of entity object

	A MIMEentity object should have a transfer encode/decode engine,
	Content-Type header

	HISTORY
	=======
	20/08/97	0.01	RDW	initial version
	12/09/97	0.02	RDW	Merged file and memory constructors into one
	15/09/97	0.03	RDW	GetContentType which output parameter is a pointer
					to the ContentType header object added
	19/09/97	0.04	RDW	operator= from rfc822msg object added and copy
					constructor from rfc822msg object added
	04/12/97	0.05	RDW	2nd RemoveEncoding file version method added
					which also takes a FILE* ptr as input and uses
					that instead of opening the file itself
	09/01/98	0.06	RDW	GetMajorType altered so it defaults to NFE_CT_TEXT
					if Content-Type header is not present.
	18/02/98	0.07	RDW	#include DebugLib path added
	23/04/98	0.08D	RDW	#ifdef DISPLAY round Display method added
	10/06/98	0.09D	RDW	GetRegistryMethod added and is called from
					all constructors.  Sets up class data members
					to hold the registry type values for the
					headers this class needs to regularly access
*/


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - System                                              */
/*                                                                            */
/* ************************************************************************** */
extern "C"
{
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  #include "DebugLib/DebugLib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* Include entity files - Project defined                                     */
/*                                                                            */
/* ************************************************************************** */
#include "MIMEentity.h"
#include "hdr_reg.h"
#include "entity.h"
#include "contentT.h"
#include "contentTE.h"
#include "rfc822msg.h"
extern "C"
{
  #include "ELib.h"
}


/* ************************************************************************** */
/*                                                                            */
/* New enumerated types                                                       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Function Prototypes - Private to this file                                 */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/* Globals to this file                                                       */
/*                                                                            */
/* ************************************************************************** */
bool         MIMEentity::got_registry_entries               = false;
NFE_HDR_TYPE MIMEentity::content_type_hdr_type              = NFE_HDR_UNKNOWN;
NFE_HDR_TYPE MIMEentity::content_transfer_encoding_hdr_type = NFE_HDR_UNKNOWN;


/* ************************************************************************** */
/*                                                                            */
/* Object methods                                                             */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */
/*
   METHOD:         Constructor for a entity object
   DESCRIPTION:
   DEPENDENCIES:
   DEPENDED ON BY:
   INPUT PARAMS:
   OUTPUT PARAMS:  NONE
   RETURN VALUE:   NONE
   CONSTANTS:      NONE
   VARIABLES:      NONE
 */
/* ************************************************************************** */
MIMEentity::MIMEentity(bool f, char *membase, uint32 offset, uint32 length, bool owner) : entity(f, membase, offset, length, NFE_ENTITY_MIME, owner),
       content_type_index(-1),
       content_transfer_encoding_index(-1)
{
  GetRegistryEntries();
}


// copy constructor
MIMEentity::MIMEentity(const MIMEentity &object) : entity(object)
{
  GetRegistryEntries();
  copyMIMEentityobject(object);
}


// copy constructor
MIMEentity::MIMEentity(const rfc822msg &object) : entity(object)
{
  GetRegistryEntries();
  entity_type = NFE_ENTITY_MIME;
  content_type_index = -1;
  content_transfer_encoding_index = -1;
}


// assignment operator
MIMEentity& MIMEentity::operator=(const MIMEentity &object)
{
  entity::operator=(object);
  if (this != &object)
  {
    // do destructor type things
    copyMIMEentityobject(object);
  }
  return *this;
}


// assignment operator from a rfc822msg object
MIMEentity& MIMEentity::operator=(const rfc822msg &object)
{
  entity::operator=(object);
  entity_type = NFE_ENTITY_MIME;
  content_type_index = -1;
  content_transfer_encoding_index = -1;
  return *this;
}


void MIMEentity::copyMIMEentityobject(const MIMEentity &object)
{
  // nothing to do, should get rid of this and leave the default copy constructors, etc.
  content_type_index = object.content_type_index;
  content_transfer_encoding_index = object.content_transfer_encoding_index;
}


// Implementation of destructor for MIMEentity
MIMEentity::~MIMEentity()
{
  // nothing to do
}


NFE_rcode MIMEentity::parse(NFE_CONTEXT &context, clock_t t_slice)
{
  NFE_rcode rc    = NFE_COMPLETED;
  bool      error = false;

  if (!entity::Parsed())
    rc = entity::parse(context, t_slice);

  return rc;
}


#ifdef DISPLAY
void MIMEentity::Display(void)
{
  printf("MIMEENTITY DISPLAY:\n");
  if (the_headers)
    the_headers->Display();
  if (the_body)
    the_body->Display();
  printf("END OF MIMEENTITY\n");
  printf("\n");
}
#endif

NFE_rcode MIMEentity::GetEncoding(NFE_TE &enc)
{
  if (the_body)
    return the_body->GetEncoding(enc);
  else
    return NFE_DATAMUSTBEPARSED;
}


NFE_rcode MIMEentity::RemoveEncoding(NFE_CONTEXT &context, const clock_t t_slice, char *filename, FILE *fd, uint32 buffer)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (the_body)
  {
    rc = the_body->RemoveEncoding(context, t_slice, filename, fd, buffer);
    if (rc == NFE_COMPLETED)
      rc = SetContentTransferEncoding(NFE_TE_7BIT);
  }
  else
    rc = NFE_DATAMUSTBEPARSED;

  return rc;
}


NFE_rcode MIMEentity::RemoveEncoding(NFE_CONTEXT &context, const clock_t t_slice, char *filename, uint32 buffer)
{
  return RemoveEncoding(context, t_slice, filename, 0, buffer);
}


NFE_rcode MIMEentity::RemoveEncoding(NFE_CONTEXT &context, const clock_t t_slice, char *memory)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (the_body)
  {
    rc = the_body->RemoveEncoding(context, t_slice, memory);
    if (rc == NFE_COMPLETED)
      rc = SetContentTransferEncoding(NFE_TE_7BIT);
  }
  else
    rc = NFE_DATAMUSTBEPARSED;

  return rc;
}


NFE_rcode MIMEentity::ApplyEncoding(NFE_CONTEXT &context, const clock_t t_slice, NFE_TE enc, char *filename, uint32 buffer)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (the_body)
  {
    rc = the_body->ApplyEncoding(context, t_slice, enc, filename, buffer);
    if (rc == NFE_COMPLETED)
      rc = SetContentTransferEncoding(enc);
  }
  else
    rc = NFE_DATAMUSTBEPARSED;

  return rc;
}


NFE_rcode MIMEentity::ApplyEncoding(NFE_CONTEXT &context, const clock_t t_slice, NFE_TE enc, char *memory)
{
  NFE_rcode rc = NFE_COMPLETED;

  if (the_body)
  {
    rc = the_body->ApplyEncoding(context, t_slice, enc, memory);
    if (rc == NFE_COMPLETED)
      rc = SetContentTransferEncoding(enc);
  }
  else
    rc = NFE_DATAMUSTBEPARSED;

  return rc;
}


NFE_rcode MIMEentity::GetMajorType(NFE_CT &ct)
{
  NFE_rcode rc = NFE_FAILED;
  header *h = 0;
/*  if (!content_type_index)
    h = the_headers.FindHdr(NFE_HDR_CONTENT_TYPE, content_type_index);
  else
  {*/
    if (the_headers)
      h = the_headers->GetHdr(content_type_index);					// check header has not moved pos. in list
    else
      rc = NFE_FAILED;
    if (h)
    {
      if (h->GetType() != content_type_hdr_type)
        h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
    }
    else
      h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
//  }
  if (h)
    rc = ((contentT*)h)->GetMajorType(ct);
  else
  {
    rc = NFE_COMPLETED;
    ct = NFE_CT_TEXT;
  }

  return rc;
}


uint32 MIMEentity::GetContentTypeLen(void)
{
  header *h = 0;
  uint32 value = 0;

  if (the_headers)
    h = the_headers->GetHdr(content_type_index);
  if (h)
  {
    if (h->GetType() != content_type_hdr_type)					// check header has not moved pos. in list
      h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
  }

  if (h)
    h->GetBodyLen(value);

  return value;
}


NFE_rcode MIMEentity::GetContentType(char *string, uint32 &len)
{
  header *h = 0;
  if (the_headers)
    h = the_headers->GetHdr(content_type_index);
  if (h)
  {
    if (h->GetType() != content_type_hdr_type)					// check header has not moved pos. in list
      h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
  }
  if (h)
    return h->GetUnfoldedNoCommentsBody(string, len);
  else
    return NFE_FAILED;
}


NFE_rcode MIMEentity::GetContentSubType(char *string, uint32 &len)
{
  NFE_rcode rc = NFE_COMPLETED;

  rc = GetContentType(string, len);
  if (rc == NFE_COMPLETED)
  {
    // RIP THE MAJOR TYPE OFF THE FRONT OF THE STRING
    uint32 size = len;
    char* start = string;
    while ((size) && (*start != '/'))
    {
      size--;
      start++;
    }
    if (size)
    {
      start++;
      size--;
    }
    if (size)
    {
      uint32 i = 0;
      bool end = false;
      while ((i<size) && (!end))
      {
        switch (start[i])
        {
          case ';':
          case 32:
          case '\r':
          case '\n':
          case '\t':
            end = true;
            break;
          default:
            string[i] = start[i];
            i++;
            break;
        }
      }
      string[i] = 0;
      len = strlen(string);
    }
  }

  return rc;
}


NFE_rcode MIMEentity::SetContentTransferEncoding(char *string, NFE_TE enc)
{
  NFE_rcode rc = NFE_COMPLETED;
  header *h = 0;

  if (string)
  {
    if ((the_headers) && (content_transfer_encoding_index >= 0))
      h = the_headers->GetHdr(content_transfer_encoding_index);
    if (h)
    {
      if (h->GetType() != content_transfer_encoding_hdr_type)				// check header has not moved pos. in list
        h = the_headers->FindHdr(content_transfer_encoding_hdr_type, content_transfer_encoding_index);
    }
    if (h)
      return h->SetBody(string);
    else
    {
      // no Content-Transfer-Encoding field present, so add one!
//      char *data = new char[255];
      h = new contentTE(false, 0, 0, 0, enc, true);			// MEMORY ONE!
      if (h)
      {
        rc = h->SetBody(string);
        if (the_headers)
          rc = the_headers->AddHdr(*h);
        else
          rc = NFE_FAILED;
      }
      else
        rc = NFE_MALLOCFAILED;
    }
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


NFE_rcode MIMEentity::SetContentTransferEncoding(NFE_TE enc)
{
  NFE_rcode rc = NFE_COMPLETED;

  switch (enc)
  {
    case NFE_TE_7BIT:
      rc = SetContentTransferEncoding("7bit", enc);
      break;
    case NFE_TE_8BIT:
      rc = SetContentTransferEncoding("8bit", enc);
      break;
    case NFE_TE_BINARY:
      rc = SetContentTransferEncoding("binary", enc);
      break;
    case NFE_TE_QUOTED_PRINTABLE:
      rc = SetContentTransferEncoding("quoted-printable", enc);
      break;
    case NFE_TE_BASE64:
      rc = SetContentTransferEncoding("base64", enc);
      break;
    case NFE_TE_UNKNOWN:
      rc = NFE_CANTDOUNKNOWN;
      break;
    default:
      rc = NFE_INTERNALERR;
      break;
  } // endswitch

  return rc;
}


// FORGET THE BELOW FOR NOW, IT's CRAP!
/*NFE_rcode MIMEentity::SetContentType(NFE_CT t, int32 st)
{
  NFE_rcode rc = NFE_COMPLETED;
  char buffer[30];						// FOR GOD SAKE MAKE SURE THIS BUFFER IS ALWAYS BIG ENOUGH!

  switch (enc)
  {
    case NFE_CT_APPLICATION:
    {
      strcpy(buffer, "application/");
      switch (st)
      {
        case NFE_CT_APPLICATION_OCTET_STREAM:
          strcat(buffer, "octet-stream");
          break;
        case NFE_CT_APPLICATION_PGP_ENCRYPTED:
          strcat(buffer, "pgp-encrypted");
          break;
        case NFE_CT_APPLICATION_PGP_KEYS:
          strcat(buffer, "pgp-keys");
          break;
        case NFE_CT_APPLICATION_UNKNOWN:
          rc = NFE_CANTDOUNKNOWN;
          break;
        default:
          rc = NFE_INTERNALERR;
          break;
      } // end subtype switch
      if (rc == NFE_COMPLETED)
        rc = SetContentType(buffer);
      break;
    }
    case NFE_CT_TEXT:
    {
      strcpy(buffer, "text/");
      switch (st)
      {
        case NFE_CT_TEXT_PLAIN:
          strcat(buffer, "plain");
          break;
        case NFE_CT_TEXT_RICHTEXT:
          strcat(buffer, "richtext");
          break;
        case NFE_CT_TEXT_ENRICHED:
          strcat(buffer, "enriched");
          break;
        case NFE_CT_TEXT_HTML:
          strcat(buffer, "html");
          break;
        case NFE_CT_TEXT_SGML:
          strcat(buffer, "sgml");
          break;
        case NFE_CT_TEXT_UNKNOWN:
          rc = NFE_CANTDOUNKNOWN;
          break;
        default:
          rc = NFE_INTERNALERR;
          break;
      } // end subtype switch
      if (rc == NFE_COMPLETED)
      rc = SetContentType("text", st);
      break;
    }
    case NFE_CT_MULTIPART:
      rc = SetContentType("multipart", st);
      break;
    case NFE_CT_MESSAGE:
      rc = SetContentType("message", st);
      break;
    case NFE_CT_IMAGE:
      rc = SetContentType("image", st);
      break;
    case NFE_CT_AUDIO:
      rc = SetContentType("audio", st);
      break;
    case NFE_CT_VIDEO:
      rc = SetContentType("video", st);
      break;
    case NFE_CT_MODEL:
      rc = SetContentType("model", st);
      break;
    case NFE_CT_MODEL:
      rc = NFE_CANTDOUNKNOWN;
    default:
      rc = NFE_INTERNALERR;
      break;
  } // endswitch

  return rc;
}*/


NFE_rcode MIMEentity::SetContentType(char *string, NFE_CT ct, int32 minor)
{
  NFE_rcode rc = NFE_COMPLETED;
  header *h = 0;

  if (string)
  {
    if ((the_headers) && (content_type_index >= 0))
      h = the_headers->GetHdr(content_type_index);
    if (h)
    {
      if (h->GetType() != content_type_hdr_type)				// check header has not moved pos. in list
        h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
    }
    if (h)
      return h->SetBody(string);
    else
    {
      // no Content-Type field present, so add one!
//      char *data = new char[255];						// ARRRRRR
      h = new contentT(false, 0, 0, 0, ct, minor, true);			// MEMORY ONE!
      if (h)
      {
        rc = h->SetBody(string);
        if (the_headers)
          rc = the_headers->AddHdr(*h);
        else
          rc = NFE_FAILED;
      }
      else
        rc = NFE_MALLOCFAILED;
    }
  }
  else
    rc = NFE_NULLADDR;

  return rc;
}


NFE_rcode MIMEentity::GetContentType(contentT *&ptr)
{
  NFE_rcode rc = NFE_COMPLETED;
  header *h = 0;

  if (the_headers)
    h = the_headers->GetHdr(content_type_index);
  if (h)
  {
    if (h->GetType() != content_type_hdr_type)					// check header has not moved pos. in list
      h = the_headers->FindHdr(content_type_hdr_type, content_type_index);
  }
  if (h)
    ptr = (contentT*)h;
  else
    rc = NFE_FAILED;

  return rc;
}


void MIMEentity::GetRegistryEntries(void)
{
  if (!got_registry_entries)
  {
    content_type_hdr_type              = hdr_registry::Instance().GetType("Content-Type");
    content_transfer_encoding_hdr_type = hdr_registry::Instance().GetType("Content-Transfer-Encoding");
    got_registry_entries = true;
  }
}
