; -*-As-*-
;
; $Header$
; $Source$
;
; Copyright (c) 1995 Acorn Computers Ltd., Cambridge, UK
;
; makecall.s - based upon code generated by Norcroft RISC OS ARM C
;              vsn 5.06 (Acorn Computers Ltd) [Jun 26 1995]
;
; :RCS Log discontinued:
;
; Revision 1.2  96/03/19  10:21:34  kbracey
; Merged the two variants into a single source file
; Nasty -zM relocation bug fixed.
;
; Revision 1.1  95/08/17  18:41:56  kwelton
; Initial revision
;

	GET	Hdr:ListOpts
	GET 	Hdr:Macros
	GET 	Hdr:System

ESRCH	*	3
EREMOTE *	71

	; If "module" is not predefined on the command line, declare it
	; here (it defaults to {FALSE})
	[ :LNOT::DEF:module
	GBLL	module
	]

	AREA	|As$$code|, CODE, READONLY

	[ :LNOT:module
	IMPORT	__rt_stkovf_split_small
	]
	IMPORT	_kernel_swi

;
; **********************************************************************
;
; makecall - call the Internet module, and deal with the return value
;
; int _makecall(int swinum, _kernel_swi_regs *in, _kernel_swi_regs *out)
;

	[ :LNOT:module
;
; this is "_makecall", for the benefit of stack backtracing
;
	= "_makecall", 0, 0, 0        ; Be careful when changing length!
	DCD	&ff00000c

	]

	EXPORT	_makecall
_makecall
	[ module
	MOV	ip, sp
	STMDB	sp!, {v1-v3, fp, ip, lr, pc}
	SUB	fp, ip, #4
	|
	MOV	ip, sp
	STMDB	sp!, {a1-a4}
	STMDB	sp!, {v1-v3, fp, ip, lr, pc}
	SUB	fp, ip, #20
;
; stack limit checking
;
	CMPS	 sp, sl
	BLLT	 __rt_stkovf_split_small
;
; by making the call to the Internet module
; from SVC mode, we can make sure that no callbacks go off between
; detecting an error and copying the error block into _inet_error.
;
	SWI	OS_EnterOS
	]

;
; make the SWI call, result into v3, setting Z flag in the process
;
	MOV	v1, a3
	BL	_kernel_swi
	MOVS	v3, a1

	LDR	lr, adrerrno
	[ module
	LDR	ip, [sl, #-536]
	ADD	lr, ip, lr
	]
	MOVEQ	a1, #0
	STREQ	a1, [lr]
	BEQ	OKreturn

;
; SWI call failed - fill in errno, and copy error block into _inet_error
; first step is to read the error number, and decide whether it is a
; properly formatted inet error (inet errorblock should start at 0x20e00,
; but it currently starts at 0 because of all the applications out there
; that expect this to be the case).
;
	LDR	a1, [v3, #0]
	BIC	a2, a1, #&ff
	SUB	a4, a2, #&20c00
	TEQ	a4, #&200
	BNE	noerrblock

;
; using inet error block: offsets 0-7f should be converted to an errno
; style number, other errors should be left alone.
;
	AND	a2, a1, #&ff
	CMP	a2, #&80
	ANDLT	a1, a1, #&7f

noerrblock
	CMPS	a1, #EREMOTE
	MOVGT	a1, #ESRCH

	STR	a1, [lr]        ; place error number into errno

;
; copy error block into _inet_error which is 256 bytes long
;
	LDR	v2, adr_inet_error
	[ module
	ADD	v2, ip, v2
	]
	MOV	ip, #16				; 16*(4*4)=256

0	LDMIA	v3!, {a2-a4,v1}
	STMIA	v2!, {a2-a4,v1}
	SUBS	ip, ip, #1
	BNE	%B0

	[ :LNOT:module
;
; back to user mode before returning error to caller
;
	TEQP	pc, #0
	]

	MVN	a1, #0				; non-banked register: OK
	LDMDB	fp, {v1-v3, fp, sp, pc}^        ; return -1

;
; back to user mode before returning to caller
;
OKreturn
	[ :LNOT:module
	TEQP	pc, #0
	]
	LDR	a1, [v1, #0]			; non-banked registers: OK
	LDMDB	fp, {v1-v3, fp, sp, pc}^        ; return R0 from SWI

adrerrno
	IMPORT	errno
	DCD	errno
adr_inet_error
	IMPORT	_inet_error
	DCD	_inet_error

	END

; EOF makecall.s
