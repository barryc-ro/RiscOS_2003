/*
 * Name:	EtherI driver
 * Purpose:	DCI 4 driver for EtherI ethernet cards
 * Author:	Acorn Computers, Irlam Instruments Ltd. and Microlynx
 * Version:	2.00
 *
 * Adapted from the Ether2 source tree by Acorn computers
 * for use with the EtherI card
 *
 *
 * Copyright(c) 1995   Acorn Computers Ltd., Cambridge, England
 * Copytight(c) 1997   Irlam Instruments Ltd., Uxbridge, Middlesex
 * Copyright(c) 1998-9 Microlynx, Ely, England
 *
 * Revision 1.1  95/09/18  15:17:53  kwelton
 * Initial revision
 *
 * Adapted for use on NC's ethernet card by Irlam Instruments
 * Massive patching to work around MX chipset
 * Big fixed ensuring alignment of mbuf data.  Required for LanManFS.
 * Modification for large packet buffers
 *
 * 10/7/98 Gary Stephenson
 * Changes for machines with on-board Ethernet eg: BOCA NC2
 *
 * 26/8/98 Paul Skirrow
 * Bug fix to make EtherI work with MAC OTP address starting 0000 in OTP area of EEROM.
 *
 * 26/8/98 Paul Skirrow
 * Removed code to read MAC address from Dallas chip (it is excluded if DALLAS is 0
 * and DALLAS=0 is defined in the h.Dallas header file).
 * The DeskLite board does not have a Dallas chip and although the Boca 2 board
 * has an option to fit one it is very unlikely every to be used as we now use
 * the OTP area in the EEROM). See the h.Dallas file for more details.
 *
 * 3.01 31/3/99 Gary Stephenson
 * Changes to reduce interrupt latency caused by driver, now enables IRQs during reception
 *
 * 3.02 8/4/99 Gary Stephenson
 * Stopped driver reading from configb register in order to allow rcbr1 to be used, this
 * means we can't check the goodlink!
 * Removed MXPATCH routines, now uses rbcr1 during data transfers
 * Added delay for remote dma completion in en_memtest and en_run_diags
 *
 * 3.03 14/4/99 Gary Stephenson
 * Stopped driver waiting for RDC forever in two places
 * Now checks irq_active flag on entry to transmit
 *
 * 3.04 20/4/99 Gary Stephenson
 * Removed border debug code.
 * Added code to validate Ethernet address, checks for all 0 or 0xff
 *
 * 3.05 3/5/99 Gary Stephenson
 * Now checks if tx packet is pending in en_update_multicast_filter(), was failing to send packets
 * during multicast channel changing.
 * 'if' changed to 'while' in en_intr() so it clears all ints before exiting
 * Added stats to record tx and rx ints
 * Disables ints during manipulation of tx queue in tx_done()
 */

/* 12/4/99 Outstanding issues
 * Need to find out what the problem with configb and rbcr1 is.
 * Optimisation of receive to pass multiple frames to protocol modules.
 * The way multicast addresses are handled could be improved.
 */

/* RDW 1999-06-09
   Removed #undef DALLAS.  Other #undefs should be removed too, otherwise
   how can they be passed in as options from the MakeFile?
   Changed #if DALLAS to #ifdef DALLAS
   Implemented support for Proton Dallas chips
 */

/* RDW 1999-12-17
   Removed dropcrc: code from en_read() as it locks up on Nat. Semi.
   controller.  Code was redunant anyway and looks like it worked on
   MX controller by luck rather than judgement.
 */


#define ENABLE_IRQS
#define USE_DEVICEVECTOR

#undef ADDRESS_BODGE
#undef BORDER
#undef TXBUF_PROFILE
#undef ONBOARD_ETHERNET

#ifdef FILTER_IP_ADDR
#define IP_HDR_LEN 20 /* # bytes of fixed IP header (excluding options) */
#endif

#ifdef TXBUF_PROFILE
static int max_txbuf = 100;
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#include "kernel.h"
#include "swis.h"
#include "delay.h"

#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/mbuf.h"
#include "sys/errno.h"

#include "net/ethernet.h"

#include "int_hndlr.h"
#include "xcb.h"
#include "ioc.h"

#include "if_en.h"
#include "e2module.h"
#include "enhdr.h"
#include "support.h"
#include "dallas.h"

//#include "parallel.h"

#undef XCB_SLOTS
#define XCB_SLOTS	(8)

unsigned int parallel = 0;

#define PSET(bit) parallel|=(1<<(bit));parallel_write(parallel);
#define PCLR(bit) parallel&=~(1<<(bit));parallel_write(parallel);

#define IS_MULTICAST_IP(x) ((*(u_char *)(x) >= 224) && \
                            (*(u_char *)(x)) <= 239)

/*
 * MXPATCH
 *
 * The MX chipset seems to mess up the SENDP command, and also
 * the rbcr1 registers seems to be messed too, so we cannot DMA
 * more than 256 bytes in one bit.  This results in a little
 * loss in performance.
 */

/*
 * XXX TRACE XXX
 *
 * if someone could tell me why this value has
 * been altered to 700 (it is usually 100), I
 * would be really interested
 */
#define HZ 100

struct en_softc *en_softc[8];

extern void en_io_out(u_char *src, volatile u_int *dst, int nbytes, u_int *bytebuf);
extern void en_flush_output(volatile u_int *dst, u_int *bytebuf);
extern void en_io_in(volatile u_int *src, void *dst, int nbytes);
extern int xcb_add_ethernet_card(int unit, int slot);
static int en_post(struct en_softc *en, int loopback_only);
static int en_run_diags(struct en_softc *en, int loopback_only);
static int lb3_failed(struct en_softc *en, NICRef nic);
static int en_memtest(struct en_softc *en, int page, u_int *pattern);
static int tx_mbufs(struct en_softc *en, struct mbuf *m0,
		    u_char *edst, int type, u_char *esrc);

#ifdef BORDER
extern void set_border(int);
#endif

#define ENCARD_ROM(slot)	(XCB_ADDRESS(FAST, slot))

#ifndef NULL
# define NULL 0
#endif

#define EN_TYPE (0x00000139)

char en_lastlog[64] = { 0 };
char en_lasterr[64] = { 0 };

int encnt = 0;
char slotmap[8];
static int en_slots[8];
volatile int en_irq_active = 0;
volatile int en_tx_active = 0;

extern void *module_wsp;
struct int_hndlr intr_routine;

extern DibRef dibs[];

extern FilterSingleRef ieeefilter[8];
extern FilterSingleRef e2monitor[8];
extern FilterSingleRef e2sink[8];
extern FilterChainRef e2specific[8];

extern int (*address_filter)(FilterSingleRef fs, u_char *pack_hdr, struct en_softc *en);

static int pdrops = 0;

static struct stats st = { 0 };

/**********************************************************************/

static void nulldev(u_char c)
{
    c = c;
}

/**********************************************************************/

/*
 * shutdown - go through the motions of taking the NIC off a live
 * network to allow recovery from a ring buffer overflow
 */
static void shutdown(NICRef nic, u_char *TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * test for transmit pending
     * issue the STOP command,
     * clear remote byte counters,
     * wait for RST to come up,
     * put the NIC into loopback,
     * issue the START command.
     */
    *TxPending = nic->command & TXP;
    nic->command = SEL_PAGE(0, NIC_STOPPED);
    MICRODELAY(1600);
    nic->rbcr0 = nic->rbcr1 = 0;

#if 0
    while( !(nic->isr & RST) )
	/* do nothing */
	;
#endif
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);
    nic->command = SEL_PAGE(0, NIC_RUNNING);

    /*
     * acknowledge the RST bit also clear RDC which
     * decides to appear
     */
    nic->isr = (RST | RDC);
}

/**********************************************************************/

/*
 * abort_packet - stop the currently executing send_packet command
 */
static void abort_packet(struct en_softc *en, NICRef nic, u_char *buff_hdr)
{
    int Bnry;
    /*
     * send the ABORT DMA command, then move the
     * boundary pointer past the unwanted packet
     */
    nic->command = START_DMA(DMA_ABORT);

    Bnry = en->en_nxt_pkt-1;
    if ( Bnry < en->en_rbs )
        Bnry = en->en_rbd-1;
    nic->bnry = Bnry;

/* we shouldn't be trying read data if we have already read it all!!! */

    /*
     * throw away the data waiting for us at the DMA port
     */
    nulldev(*en->dma_port);
}

/**********************************************************************/

#if 0
/*
 * drop_packet - discard packet data
 */
static void drop_packet(struct en_softc *en, int datalen)
{
    register volatile u_int *port = en->dma_port;
    int i;
    char buf[128 + 2];

    pdrops++;
    datalen -= PACK_HDR_LEN + CRC_LEN;
    for( i = datalen; i > 0; i -= 128 )
       en_io_in(port, buf, min(i, 128));
}
#endif

/**********************************************************************/

static    u_char pack_hdr[PACK_HDR_LEN];
static    u_char buff_hdr[BUFF_HDR_LEN];
static    RxHdrRef hdr;
/*
void mbuf_dump ( struct mbuf *m )
{
    parallel_printf ( "struct mbuf {\n" );
    parallel_printf ( "    struct mbuf         *m_next   = %08x\n", m->m_next   );
    parallel_printf ( "    struct mbuf         *m_list   = %08x\n", m->m_list   );

    parallel_printf ( "    ptrdiff_t            m_off    = %08x\n", m->m_off    );
    parallel_printf ( "    size_t               m_len    = %08x\n", m->m_len    );
    parallel_printf ( "    const ptrdiff_t     *m_inioff = %08x\n", m->m_inioff );
    parallel_printf ( "    const ptrdiff_t     *m_inilen = %08x\n", m->m_inilen );

    parallel_printf ( "    unsigned char        m_type   = %02x\n", m->m_type   );
    parallel_printf ( "    const unsigned char  m_sys1   = %02x\n", m->m_sys1   );
    parallel_printf ( "    const unsigned char  m_sys2   = %02x\n", m->m_sys2   );
    parallel_printf ( "    const unsigned char  m_sys3   = %02x\n", m->m_sys3   );
    parallel_printf ( "}" );
}
*/

/*
 * en_read - read a packet out of the ring buffer (no trailers!)
 */
void en_read(struct en_softc *en, NICRef nic)
{
    register u_int databuff;
    register volatile u_int *port = en->dma_port;
    register struct mbuf *m, *m0 = NULL;
    struct mbuf *pd;
#ifdef FILTER_IP_ADDR
    int ip_hdr_captured = 0;
#endif

    /*
     * XXX
     *
     * pack_hdr *must* be word aligned - this fact is used by a
     * hacky test for broadcast addresses in the address filters
     */
    u_short type;
    u_int datalen;
    u_int unit = en->en_unit;
    int i;
    FilterSingleRef fs = NULL;
    int this_packet;
    int bytes_left;
    int ptr;

#ifdef DEBUG
    Printf("ei_read(%d)...", unit);
#endif

    /* we have received another frame */
    en->en_st_rx_frames++;

    /* Remember which frame we're doing */
    this_packet = en->en_nxt_pkt;

    /* start the Send Packet command */
    /* Do the header in 1 go */
    nic->rsar0 = 0;
    nic->rsar1 = this_packet;
    nic->rbcr0 = BUFF_HDR_LEN + PACK_HDR_LEN;
    nic->rbcr1 = 0;
    nic->command = START_DMA(DMA_READ);

    /* read the buffer header */
    for( i = 0; i < BUFF_HDR_LEN; i += 2 )
    {
	databuff = *port;
	buff_hdr[i] = databuff;
	buff_hdr[i + 1] = databuff >> 8;
    }

    /*
     * read the packet length from this header
     */
    datalen = *(u_short *)(buff_hdr + 2);
    if( datalen < (PACK_HDR_LEN + CRC_LEN) )
    {
	/* update stats */
	en->en_st_runt_frames++;
	en->en_nxt_pkt = *(buff_hdr + 1);
	abort_packet(en, nic, buff_hdr);
	return;
    }

    /*
     * set the next packet pointer from the header
     */
    en->en_nxt_pkt = *(buff_hdr + 1);

    /*
     * read the packet header to get dest address, src address
     * and packet type.
     */
    for( i = 0; i < PACK_HDR_LEN; i += 2)
    {
	databuff = *port;
	pack_hdr[i] = databuff;
	pack_hdr[i + 1] = databuff >> 8;
    }

    /*
     * XXX
     *
     * copy source address into stats. structure - because of
     * unfavourable word alignments, we cannot use the same
     * hack applied to the st_last_dst_addr stat.
     */
    memcpy(en->en_st_last_src_addr, pack_hdr + HW_ADDR_LEN, HW_ADDR_LEN);

    /*
     * Check that the DMA for the headers completed
     */
    if( !(nic->isr & RDC) ) {
	MICRODELAY(RDC_RECOVER_PERIOD);

	if( !(nic->isr & RDC) )
	{
	    sprintf(en_lastlog, "Unit %d: RDC failure in ei_read\n",
		    en->en_unit);
	    type = 0;
	    /*abort_packet(en, nic, buff_hdr);*/
	    goto rdc_failed;
	}
    }
    /* Acknowledge it */
    nic->isr = RDC;

    /*
     * drop overlong packets
     */
    if( datalen > ETHERMTU + (PACK_HDR_LEN + CRC_LEN) )
    {
	en->en_st_overlong_frames++;
	goto unwanted;
    }

    /*
     * get the type, & decide if we can handle it
     */
    type = ntohs(*(u_short *)(pack_hdr + (2 * HW_ADDR_LEN)));

#ifdef DEBUG
    Printf("type = %x\n", type);
#endif

    /*
     * 1st discrimination of frame type - is it
     * an IEEE 802.3 or an Ethernet 2.0 frame?
     */
    if( type <= ETHERMTU )
    {
	fs = ieeefilter[unit];
	SET_FRAMELEVEL(type, FRMLVL_IEEE);
    }

    /*
     * it's an Ethernet 2.0 frame, do we have
     * specific or sink filters active?
     */
    else if( e2specific[unit] || e2sink[unit] )
    {
	FilterChainRef fc;

	/*
	 * start by trying to match specific frame types
	 */
	for( fc = e2specific[unit]; fc; fc = fc->fc_next )
	    if( fc->fc_type == type )
	    {
		fs = &fc->fc_filter;
		SET_FRAMELEVEL(type, FRMLVL_E2SPECIFIC);
		break;
	    }

	/*
	 * default to sink filter if no specific matches
	 */
	if( !fc )
	{
	    fs = e2sink[unit];
	    SET_FRAMELEVEL(type, FRMLVL_E2SINK);
	}
    }

    /*
     * all we have left is the Ethernet 2.0 monitor
     */
    else
    {
	fs = e2monitor[unit];
	SET_FRAMELEVEL(type, FRMLVL_E2MONITOR);
    }

    /*
     * statistics count *all* received frames, not
     * just those passed along to protocols.
     */
    en->en_st_rx_bytes += datalen;

    /*
     * pass the packet along if it is wanted
     */
    if( fs )
    {
	/*
	 * use the filtering routine appropriate to
	 * the current level of packet reception
	 */
	if( address_filter(fs, pack_hdr, en) )
	{
	    fs = NULL;
	    en->en_st_unwanted_frames++;
	    goto unwanted;
	}
    }
    else
    {
	/*
	 * no protocols want this frame
	 */
	en->en_st_unwanted_frames++;
	goto unwanted;
    }

    if( (m = (m0 = ALLOC_S(MINCONTIG, NULL))) == (struct mbuf *)0 )
    {
	fs = NULL;
	goto unwanted;
    }
    m->m_type = MT_HEADER;

    hdr = mtod(m0, RxHdrRef);
    m0->m_len = sizeof(RxHdr);

    hdr->rx_tag = 0;
    memcpy(hdr->rx_src_addr, pack_hdr + HW_ADDR_LEN, HW_ADDR_LEN);
    memcpy(hdr->rx_dst_addr, pack_hdr, HW_ADDR_LEN);
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    *(u_short *)(&hdr->_spad[0]) = 0;
    *(u_short *)(&hdr->_dpad[0]) = 0;

    /*
     * adjust datalen to account for bytes within the packet header
     * and the unwanted crc bytes at the end of the packet; read
     * data out of the packet into a large mbuf or an mbuf chain.
     */
    datalen -= (PACK_HDR_LEN + CRC_LEN);

	/*
	 * XXX
	 *
	 * I am slightly worried by the use of MLEN - 2 in the
	 * old code: I suspect that this was just a case of
	 * someone being conservative (and NOT COMMENTING THEIR
	 * CODE!), without understanding that the data overrun
	 * in the data copiers is already catered for safely in
	 * the fact that all mbufs have an even length.
	 *
	 * The original RISC iX drivers certainly use MLEN without
	 * any trouble.
	 */
	if( (m->m_next = ALLOC(datalen, NULL)) == NULL )
	{
	    fs = NULL;
	    goto unwanted;
	}
	/*
	 * run down the mbufs, filling them in
	 */

	/* Set a pointer to the start of the packet */
	ptr = (this_packet<<8) + BUFF_HDR_LEN + PACK_HDR_LEN;

        /* Start off the first chunk of the remote DMA.  This DMA ends at this_packet<<8 + 0x80 or less */
	/* bytes_left = (datalen>(128-BUFF_HDR_LEN-PACK_HDR_LEN)) ? (128-BUFF_HDR_LEN-PACK_HDR_LEN) : datalen;*/

	nic->rsar0 = ptr & 0xff;
        nic->rsar1 = (ptr>>8) & 0xff;
        nic->rbcr0 = datalen;
        nic->rbcr1 = datalen >> 8;
        nic->command = START_DMA(DMA_READ);

#ifdef FILTER_IP_ADDR
        if ((type == 0x0800) && fs)
        {
            if ((fs->fs_addrlevel == ADDRLVL_MULTICAST) && (!fs->fs_multiall))
            {
                 char *p = mtod(m->m_next,char *);
                 char *dst_address;

                 en_io_in(port,p,IP_HDR_LEN);
                 ip_hdr_captured = 1;
                 dst_address = p + 16;

                 if (IS_MULTICAST_IP(dst_address))
                 {
                     int j;
                     int found = 0;

                     for (j = 0; j < fs->fs_multitablesize; j++)
                     {
                          if ((memcmp(&fs->fs_multitable[j].ip_address, (void *)dst_address,4)) == 0)
                          {
                               found = 1;
                               break;
                          }
                     }

                     if (!found)
                     {
                         nic->command = START_DMA(DMA_ABORT);
                         nulldev(*port);
                         en->en_st_unwanted_frames++;
                         fs = NULL;
                         goto unwanted;
                     }
                 }
            }
        }
#endif

	for( pd = m->m_next; pd; pd = pd->m_next )
	{
redo:
	    /* If this is not the last mbuf and it is of odd length then align it */
	    if ( (pd->m_next!=0) && ((pd->m_len&3)||(pd->m_off&3)) )
	    {
	        /* The best way is to extend the mbuf by 1 byte since mbufs are usually aligned so
	           we stand a good chance of succeeding (I do not rely on (MINILEN&1)==0), and it means there is
	           less (theoretical) chance that we will need another ALLOC at the end */
	        while ( pd->m_off&3 )
	            pd->m_off++;

	        while ( pd->m_len&3 )
	            pd->m_len--;
	    }

	    /* If is the last mbuf, and we have the wrong number of bytes, then do some adjustment */
	    if ( (pd->m_next==0) && (pd->m_len!=datalen) )
	    {
	        if ( ( datalen+pd->m_off ) <= (pd->m_inilen+pd->m_inioff) )
	        {
  	            pd->m_len = datalen;
  	        }
  	        else
  	        {
  	            /* We need more buffer space */
  	            pd->m_next = ALLOC(datalen-pd->m_len, NULL);

  	            if ( pd->m_next==0 )
  	            {
  	                /* Drop this last DMA.  Maybe aborting it is better ? I dont like aborting, it's more risky */
  	                for ( ; bytes_left; bytes_left-=2 )
  	                    nulldev (*port);

  	                /* Quietly loose this frame */
  	                fs = 0;
  	                break;
  	            }

		    /* This means this isn't the last mbuf any more, so run round again */
  	            goto redo;
  	        }
	    }

	    pd->m_type = MT_DATA;

#ifdef FILTER_IP_ADDR
            if (ip_hdr_captured)
            {
                en_io_in(port, mtod(pd, char *) + IP_HDR_LEN, pd->m_len - IP_HDR_LEN);
                ip_hdr_captured = 0;  /* carry on as normal */
            }
            else
#endif
	    {
	        en_io_in(port, mtod(pd, char *), pd->m_len);
	    }

	    datalen -= pd->m_len;

	}

	if( datalen != 0 )
	    panic("BAD DATALEN");

    if( !(nic->isr & RDC) )
    {
        /*
	 * this is not yet a fatal error - give it
	 * a chance to recover then try again
	 */
	MICRODELAY(RDC_RECOVER_PERIOD);

	if( !(nic->isr & RDC) )
	{
	    sprintf(en_lastlog, "Unit %d: RDC failure2 in ei_read \n",
		    en->en_unit);
	    type = 0;
	    /*abort_packet(en, nic, buff_hdr);
	    goto notify_protocol;*/
	    goto rdc_failed;
	}
    }

    /* acknowledge end of remote DMA */
    nic->isr = RDC;

  unwanted:
  rdc_failed:

    i = en->en_nxt_pkt-1;
    if ( i < en->en_rbs )
        i = en->en_rbd-1;
    nic->bnry = i;

  notify_protocol:
    if( fs )
	callproto(dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
    else if( m0 )
	m_freem(m0);
}

/**********************************************************************/

/*
 * start_tx - send a transmit packet command to the NIC. MUST be called
 * at splet.
 */
static void start_tx(struct en_softc *en, NICRef nic)
{
    TxqRef txq = en->TxPending;

    /* set up the control registers */
    nic->tpsr = txq->TxStartPage;
    nic->tbcr0 = txq->TxByteCount;
    nic->tbcr1 = txq->TxByteCount >> 8;

    /* start the transmission */
    nic->command = START_DMA(DMA_IDLE) | TXP;
}

/**********************************************************************/

/*
 * startup - bring the NIC back onto a live network following a shutdown
 */
static void startup(struct en_softc *en, NICRef nic, u_char TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * take the NIC out of loopback & onto the live network
     */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /*
     * restart transmit if lost by shutdown
     */
    if( (TxPending) && !(nic->isr & (PTX | TXE)) )
	start_tx(en, nic);
}

/**********************************************************************/

/*
 * en_recv - deal with received packet interrupts
 */
void en_recv(struct en_softc *en, NICRef nic)
{
    u_char overflowed = 0;
    u_char current_page, TxPending;
    int i = 900;  /* Yes, this is high. */

    en->en_st_rx_interrupts++;

    /*
     * loop until all packets read
     */
    if( (nic->isr & PRX) )
    {
	/*
	 * acknowledge this interrupt, then read where the
	 * start of the free buffer is
	 */
	nic->isr = PRX;
	nic->command = SEL_PAGE(1, NIC_RUNNING);
	current_page = nic->curr;
	nic->command = SEL_PAGE(0, NIC_RUNNING);

	/*
	 * loop until the boundary pointer reaches the start
	 * of the free buffer
	 */
	while(( en->en_nxt_pkt != current_page ) && ( i > 0))
	{
	    /*
	     * check for receive ring overflows
	     */
	    if( (nic->isr & OVW) )
	    {
		++overflowed;
		en->en_st_late_events++;
		shutdown(nic, &TxPending);

		/* remove a packet & acknowledge the overflow */
		en_read(en, nic);
		nic->isr = OVW;
	    }
	    else
		/* read next packet */
		en_read(en, nic);

            i--;
	}
    }

    /* restart reception if necessary */
    if( overflowed )
    {
	startup(en, nic, TxPending);
    }

}

/**********************************************************************/

/*
 * tx_done - remove transmit request from head of queue, start next
 * transmit if required
 */
static void tx_done(struct en_softc *en, NICRef nic)
{
    TxqRef txdesc;
    int s;

    /* act cautious */
    if( !en->TxPending )
    {
	sprintf(en_lasterr,"Unit %d: packet transmitted from empty queue",
		en->en_unit);
	return;
    }

    s = ensure_irqs_off();

    /* put this transmit request back into the free list */
    if( en->TxqFree )
    {
	for( txdesc = en->TxqFree; txdesc->TxNext; txdesc = txdesc->TxNext )
	    /* do nothing */
	    ;
	txdesc->TxNext = en->TxPending;
    }
    else
	en->TxqFree = en->TxPending;

    txdesc = en->TxPending->TxNext;
    en->TxPending->TxNext = (TxqRef)NULL;

    restore_irqs(s);

    /* start next transmit if one there */
    if( (en->TxPending = txdesc) != NULL )
	start_tx(en, nic);

}

/**********************************************************************/

/*
 * en_txdone - remove a successfully transmitted packet from the queue,
 * then start next packet if necessary.
 */
void en_txdone(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count of
     * transmitted packets
     */
    en->en_st_tx_interrupts++;

    nic->isr = PTX;

    /* check for Signal Quality Error if this is appropriate */
    if( (en->en_flags & EN_SQETEST) &&
       !(nic->tsr & COL) && (nic->tsr & CDH) )
    {
	/* one more for the stats. */
	en->en_st_heartbeat_failures++;

	/* do not repeatedly send out this message */
	if( !(en->en_flags & EN_SQEINFORMED) )
	{
	    sprintf(en_lastlog,
		    "Unit %d: CD/Heartbeat failure "
		    "(is the AUI cable connected?)\n",
		    en->en_unit);
	    en->en_flags |= EN_SQEINFORMED;
	}
    }

    /* test for recovered collisions */
    if( nic->tsr & COL )
    {
	u_char n_colls = nic->ncr & 0x0f;

	en->en_st_collisions += n_colls;
	en->en_flags &= ~EN_SQETEST;
    }
    else
	en->en_flags |= EN_SQETEST;

    if (nic->tsr & CRS)
    {
      en->en_st_link_failures++;
    }

    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_txfailed - `recover' from a transmit error. this means log the
 * failure then forget about the packet it happened on.
 */
static void en_txfailed(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count
     * of Tx errors
     */
    nic->isr = TXE;

    /* check for aborted transmit (excess collisions) */
    if( nic->tsr & ABT )
    {
	en->en_st_excess_collisions++;
	en->en_st_collisions += 16;
    }

    /* check for FIFO underrun */
    if( nic->tsr & FU )
    {
	sprintf(en_lasterr, "Unit %d: FIFO underrun\n",
		en->en_unit);
	/* log this as a general transmit error */
	en->en_st_tx_general_errors++;
    }

    if (nic->tsr & CRS)
    {
      en->en_st_link_failures++;
    }

    /* now get rid of this transmit request */
    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_rxfailed - deal with receive errors. this means log them then
 * forget about them.
 */
void en_rxfailed(struct en_softc *en, NICRef nic)
{
    u_char err_count, max_count = 0;
    char status;

    status = en->Chip->rsr;

    /*
     * acknowledge both the receive error & counter
     * overflow interrupts, then increment the count
     * of bad receives
     */
    nic->isr = (RXE | CNT);

    /* frame alignment errors */
    err_count = nic->cntr0;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: Frame alignment error", en->en_unit);
    en->en_st_frame_alignment_errors += err_count;
    max_count = max(max_count, err_count);

    /* crc errors */
    err_count = nic->cntr1;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: CRC error", en->en_unit);
    en->en_st_crc_failures += err_count;
    max_count = max(max_count, err_count);

    /* frames lost */
    err_count = nic->cntr2;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: Dropped frames", en->en_unit);
    en->en_st_dropped_frames += err_count;
    max_count = max(max_count, err_count);

    /*
     * if all these counters returned zero, then assume
     * problem was a fifo overrun. (a bit crude)
     */
    if( max_count == 0 )
    {
	/* log this as a general receive error */
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: receive counters returned no errors",
		en->en_unit);
    }

    if ( status & 2 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: CRC check caught a bad packet",
		en->en_unit);
    }

    if ( status & 4 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: Misaligned frame detected on net",
		en->en_unit);
    }

    if ( status & 8 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: FIFO overran",
		en->en_unit);
    }

    if ( status & 0x10 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: Missed packet",
		en->en_unit);
    }
}

/**********************************************************************/

/*
 * en_intr - entry point for ISR, steps are:
 *
 * 1 - handle all received packets
 *
 * 2 - deal with packet transmitted ints.
 *
 * 3 - check for transmit errors
 *
 * 4 - check for receive errors
 *
 * 5 - check for overwrite warning (should not happen - this is tested
 *     for within the receive packet code)
 *
 * 6 - deal with tally counter overflows
 *
 */

static void en_intr(int unit)
{
    register struct en_softc *en = en_softc[unit];
    register NICRef nic = en->Chip;
    u_char TxPending;

    /* loop until all ints cleared */
    while ( nic->isr & MY_INTS )
    {
	/* stage 1 - received packets */
	if ( nic->isr & PRX )
	    en_recv(en, nic);

	/* stage 2 - transmitted packets */
	if( nic->isr & PTX )
	    en_txdone(en, nic);

	/* stage 3 - transmit errors */
	if( nic->isr & TXE )
	    en_txfailed(en, nic);

	/* stage 4 - receive errors */
	if( nic->isr & RXE )
	    en_rxfailed(en, nic);

	/* stage 5 - overwrite warning */
	if( nic->isr & OVW )
	{
	    if( nic->isr & PRX )
		/* more packets have arrived so read them out */
		en_recv(en, nic);
	    else
	    {
		shutdown(nic, &TxPending);
		nic->isr = OVW;
		startup(en, nic, TxPending);
	    }
	}

	/* stage 6 - tally counter overflow */
	if( nic->isr & CNT )
	{
	    if( nic->isr & RXE )
		/* got more errors */
		en_rxfailed(en, nic);
	    else
	    {
		/* this is also bad news */
		sprintf(en_lastlog,"Count of error registers:\n"
		       "FAE: %x "
		       "CRC: %x "
		       "FRL: %x\n",
		       nic->cntr0, nic->cntr1, nic->cntr2);
		sprintf(en_lasterr,"ei_intr: CNT with no receive errors");
	    }
	}

	/* all over bar the shouting - test for extraneous bits */
	if( nic->isr & RDC )
	{
	    nic->isr = RDC;  /* clear the interrupt */
	    sprintf(en_lasterr,"ei_intr: RDC signalled");
	}

/*  RST bit in MX chip is buggy
	else if( nic->isr & RST )
	    sprintf(en_lasterr,"en_intr: RST signalled");
*/
    }
}


/**********************************************************************/

/*
 * give the Ethernet card a hard reset
 */
static void en_reset_card(int slot)
{
    int easibase;
    volatile int dummy;

#ifdef ONBOARD_ETHERNET
    easibase = EASIBASE_SLOT0;
#else
    if ( (_swix ( 0x4028D, _IN(0)|_IN(1)|_IN(2)|_IN(3), 1<<9, &easibase, 4, slot ))!=0 )
        return;
#endif

    /* Force stop the controller.  We seem to need this before reset */
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x4)) = 0x21;

    /* Writing actaually resets, but this algorithm holds for all circumstances */
    *((unsigned int *)(ENCARD_RESET_PORT(easibase))) = 0xff;
    MICRODELAY ( 50000 );
    *((unsigned int *)(ENCARD_RESET_PORT(easibase))) = 0x00;
    MICRODELAY ( 50000 );

    /* Set up config A for irq 0 */
    dummy = *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x54)) = 0x00;
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x54)) = dummy & ~4;

    /* Clear the isr */
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x3C)) = 0xff;

#ifdef ONBOARD_ETHERNET
#ifdef DEBUG1
    printf("DEBUG: Hard reset ok, easibase:%x\n",easibase);
#endif
#endif
}

/*
 * This is a horriblly hacky command, needed
 * due to the lack of a decent podule manager
 */

void en_reset_all ()
{
    int i;
    for( i = 0; i < XCB_SLOTS; i++ )
    {
        if ( en_slots[i] )
            en_reset_card ( en_slots[i] );
    }
}

/**********************************************************************/

void decl_xcb_interrupt(int slot, struct int_hndlr *hndlr, int prior, int intstatus)
{
#ifndef USE_DEVICEVECTOR
    _kernel_swi_regs rin, rout;
#endif
    static int claimed;

    if( claimed != 0x091067 ) /* Only claim the vector once ! */
    {
#ifdef USE_DEVICEVECTOR
        int device = 13;

        /* Ask the Podule Manager which interrupt to use (yes, it's normally 13, but we have weird boxes where
         * it isn't)
         */
        _swix ( Podule_ReadInfo, _INR(0,3), 1u<<17, &device, sizeof device, slot);

/*      _swix ( OS_ClaimDeviceVector, _INR(0,4), device, en_irq_entry, module_wsp, easibase + EI_CTRLREG, 4 ); */
        _swix ( OS_ClaimDeviceVector, _INR(0,4), device, en_irq_entry, module_wsp, intstatus, MY_INTS );
#else
	intr_routine = *hndlr;
	rin.r[0] = 2;
	rin.r[1] = (int)en_irq_entry;
	rin.r[2] = (int)module_wsp;

	(void)_kernel_swi(OS_Claim, &rin, &rout);
#endif
	claimed = 0x091067;
    }
}

/**********************************************************************/

/*
 * stats_init - initialise stats structures
 */
void stats_init(struct en_softc *en)
{
    int i;

    /*
     * actual statistics structure is easy - only one field to set
     */
    en->en_st_interface_type = ST_TYPE_10BASET;

    /*
     * now fill in struct st which describes
     * the stats. this interface supports.
     */
    st.st_interface_type = (u_char) ~0;
    st.st_link_status = (u_char) ~0;
    st.st_link_polarity = (u_char) ~0;
    st.st_blank1 = 0;
    st.st_link_failures = 0;
    st.st_network_collisions = 0;
    st.st_collisions = ~0;
    st.st_excess_collisions = ~0;
    st.st_heartbeat_failures = ~0;
    st.st_not_listening = 0;
#if 0
    st.st_net_error = 0;
#endif
    st.st_tx_frames = ~0;
    st.st_tx_bytes = ~0;
    st.st_tx_general_errors = ~0;
    st.st_crc_failures = ~0;
    st.st_frame_alignment_errors = ~0;
    st.st_dropped_frames = ~0;
    st.st_runt_frames = ~0;
    st.st_overlong_frames = ~0;
    st.st_jabbers = 0;
    st.st_late_events = ~0;
    st.st_unwanted_frames = ~0;
    st.st_rx_frames = ~0;
    st.st_rx_bytes = ~0;
    st.st_rx_general_errors = ~0;

    for( i = 0; i < 6; ++i )
    {
	st.st_last_dest_addr[i] = 0xff;
	st.st_last_src_addr[i] = 0xff;
    }

    do
    {
	st.st_last_dest_addr[i] = 0;
	st.st_last_src_addr[i] = 0;
	++i;
    } while( ++i < sizeof(st.st_last_dest_addr) );
}

/**********************************************************************/

/*
 * high priority XCB card initialisation - reset the card
 */
static void en_init_high(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/* Dallas chip control */

#ifdef DALLAS

static void en_dallas_pull_high ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;
    *en->en_dallas = 1;
}

static void en_dallas_pull_low ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;
    *en->en_dallas = 0;
}

static int en_dallas_read_bus ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;

    return (*en->en_dallas & 2)>>1;
}

static struct dallas_physical en_dp = {
    en_dallas_pull_high,
    en_dallas_pull_low,
    en_dallas_read_bus,
    (void *)0
};
#endif

/**********************************************************************/

/*
 * low priority XCB card initialisation - first round with ints off
 * allocates memory for control structures; second round declares the driver
 * to the network interface code.
 */
static void en_init_low(int slot, int irqs_on)
{
    if( !irqs_on )
    {
	static int enunits;
	struct en_softc *en;
	int unit = enunits++;
	int i;
	int easibase;
	char *flash_constants;
        int c, size, osid, next;
        char *buf;

#ifdef DEBUG1
	printf("DEBUG: en_init_low entered for slot:%x\n", slot);
#endif

#ifdef ONBOARD_ETHERNET
	/* this is hardwired for the ONBOARD_ETHERNET NC */
	easibase=EASIBASE_SLOT0;
#else
        /* Lookup easibase.  I dont see xcb.h supporting this.  This is only in RiscOS 3.5 and up */
        if ( (_swix ( Podule_ReadInfo, _IN(0)|_IN(1)|_IN(2)|_IN(3), 1<<9, &easibase, 4, slot ))!=0 )
            return;
	/*
	 * check for too many Ethernet (version I or II) cards.
	 */
	if (!xcb_add_ethernet_card (enunits, slot))
	    return;
#endif

	/* get some memory for the control structure */
	en = (struct en_softc *)malloc(sizeof(*en));
	memset((char *)en, 0, sizeof(struct en_softc));
	en_softc[unit] = en;

        en->sc_easibase = easibase;

        /* Enumerate the chunks to find the modification number */
        c=0;
        en->sc_modification = 0;

#ifndef ONBOARD_ETHERNET
        while ( 1 )
        {
            if ( ( _swix ( Podule_EnumerateChunks, _IN(0)|_IN(3)|_OUT(0)|_OUT(1)|_OUT(2), c, slot, &next, &size, &osid ))!=0 )
                break;

        	/* Modification chunk */
            if ( osid == 0xf3 )
            {
                if ( (buf = (char *)malloc ( size ))==0 )
                    break;

        	/* Read the modification data */
                if ( (_swix ( Podule_ReadChunk, _IN(0)|_IN(2)|_IN(3), c, buf, slot ))!=0 )
                    break;

                /* Decode the modification and limit it to ones we can handle */
                en->sc_modification = atoi ( buf );

                free ( buf );
            }

            if ( (c=next)==0 )
                break;
        }

        switch ( en->sc_modification & 1 )
        {
            case 0:
                _swi ( Podule_SetSpeed, _IN(0)|_IN(3), 1, slot );
                break;
            default:
            case 1:
                _swi ( Podule_SetSpeed, _IN(0)|_IN(3), 3, slot );
                break;
        }
#else
	en->sc_modification = 1 << 1;		/* Boca2 has 32KB frame buffer */
#endif

	/* record which logical slot this is */
	slotmap[slot] = unit;

        switch ( (en->sc_modification & (7 << 1)) >> 1 )	/* Need at least 2 bits - 16KB, 32KB, 64KB, so lets have 3   */
        							/* however, these are to treated as a value, not a bit field */
        {
            default:	/* Never happens... in theory ;-) RCE */
            case 0:
		en->NIC_BUFFER   	= (16 * 1024);
		en->NIC_BUFFER_START	= (0x4000);		/* this is the buffer offset in 16-bit I/O port compatible mode */
		en->NIC_PAGE     	= 256;			/* buffer page size */
		en->MAXTXQ       	= HC_MAXTXQ / 4;
		en->PAGES_PER_TX 	= (((ETHERMAXP - 1) / en->NIC_PAGE) + 1);
		en->TX_START     	= (en->NIC_BUFFER_START/en->NIC_PAGE);
		en->RX_START     	= (en->TX_START + (en->MAXTXQ * en->PAGES_PER_TX));
		en->RX_END       	= ((en->NIC_BUFFER_START/en->NIC_PAGE)+(en->NIC_BUFFER / en->NIC_PAGE) - 1);
                break;

            case 1:
		en->NIC_BUFFER   	= (32 * 1024);
		en->NIC_BUFFER_START	= (0x4000);		/* this is the buffer offset in 16-bit I/O port compatible mode */
		en->NIC_PAGE     	= 256;			/* buffer page size */
		en->MAXTXQ       	= HC_MAXTXQ / 2;
		en->PAGES_PER_TX 	= (((ETHERMAXP - 1) / en->NIC_PAGE) + 1);
		en->TX_START     	= (en->NIC_BUFFER_START/en->NIC_PAGE);
		en->RX_START     	= (en->TX_START + (en->MAXTXQ * en->PAGES_PER_TX));
		en->RX_END       	= ((en->NIC_BUFFER_START/en->NIC_PAGE)+(en->NIC_BUFFER / en->NIC_PAGE) - 1);
                break;

            case 2:
		en->NIC_BUFFER   	= (63 * 1024);
		en->NIC_BUFFER_START	= (0x100);		/* this value lowered from 0x4000 (16-bit non-compat I/O mode) RCE:990323 */
		en->NIC_PAGE     	= 256;			/* buffer page size */
		en->MAXTXQ       	= HC_MAXTXQ;
		en->PAGES_PER_TX 	= (((ETHERMAXP - 1) / en->NIC_PAGE) + 1);
		en->TX_START     	= (en->NIC_BUFFER_START/en->NIC_PAGE);
		en->RX_START     	= (en->TX_START + (en->MAXTXQ * en->PAGES_PER_TX));
		en->RX_END       	= ((en->NIC_BUFFER_START/en->NIC_PAGE)+(en->NIC_BUFFER / en->NIC_PAGE) - 1);
                break;
        }

	/* initialise the en_softc structure */
	en->en_unit = unit;
	en->en_slot = slot;
	en->en_flags = 0;
	en->Chip = (NICRef)ENCARD_NIC_REGS(easibase);
	en->dma_port = (u_int *)ENCARD_REMOTE_DMA(easibase);
	en->en_dallas   = (char *)ENCARD_DALLAS(easibase);

	/*
	 * initialise stats structures
	 */
	stats_init(en);

	for( i = 0; i < en->MAXTXQ; ++i )
	{
	    en->TxqPool[i].TxNext = (i < (en->MAXTXQ - 1)) ?
				     &(en->TxqPool[(i + 1)]) : (TxqRef)NULL;
	    en->TxqPool[i].TxStartPage = (i * en->PAGES_PER_TX) + en->TX_START;
	}
	en->TxqFree = en->TxqPool;
	en->TxPending = (TxqRef)NULL;

	/* Flash constants are in the top sector (16k) of the 128k flash */
	flash_constants = (char *)easibase + (((128-16)*1024)<<2);

	/* See if RiscOS will supply us with an ethernet address */
	if ( (_swix ( Podule_ReadInfo, _INR(0,3), (1<<27)|(1<<28), en->en_addr, 8, slot )) == 0 )
	{
	    int temp;
	    /* We got an address from the Podule Manager, we must byte swap it now */
	    temp = en->en_addr[0]; en->en_addr[0] = en->en_addr[5]; en->en_addr[5] = temp;
	    temp = en->en_addr[1]; en->en_addr[1] = en->en_addr[4]; en->en_addr[4] = temp;
	    temp = en->en_addr[2]; en->en_addr[2] = en->en_addr[3]; en->en_addr[3] = temp;
	}
	else
	{
	  _kernel_oserror *err;
          while ( 1 )
          {
              if ( ( _swix ( Podule_EnumerateChunks, _IN(0)|_IN(3)|_OUTR(0,2), c, slot, &next, &size, &osid ))!=0 )
                  break;

              /* Ethernet ID chunk */
              if ( osid == 0xf7 && size == 6)
              {
                  if ( (_swix ( Podule_ReadChunk, _IN(0)|_INR(2,3), c, en->en_addr, slot ))!=0 )
                      break;
                  goto got_address;
              }

              if ( (c=next)==0 )
                  break;
          }

	  err = _swix( OS_ReadSysInfo, _IN(0)|_OUTR(0,1), 4, (int *)&en->en_addr[0], (int *)&en->en_addr[4] );

          if ( (err == NULL) && ((*(int *)&en->en_addr[0] != 0) || (*(int *)&en->en_addr[4] != 0) ))
          {
            int temp;
	    /* We got an address from the Kernel, we must byte swap it now */
	    temp = en->en_addr[0]; en->en_addr[0] = en->en_addr[5]; en->en_addr[5] = temp;
	    temp = en->en_addr[1]; en->en_addr[1] = en->en_addr[4]; en->en_addr[4] = temp;
	    temp = en->en_addr[2]; en->en_addr[2] = en->en_addr[3]; en->en_addr[3] = temp;
          }
          else
          {
#ifdef DALLAS
            /* Attempt to read from Dallas chip if present in this hardware (DALLAS=FALSE for DESKLITE) */
	    int dallas_retries;
	    int myid;
	    unsigned int myetheraddr;

	    /* Set this dallas descriptor to point to my sc */
	    en_dp.sc = (void *)en;

    	    for ( i=0; i<6; i++ )
    	        en->en_addr[i]=0;

	    for ( dallas_retries = 0; dallas_retries<6; dallas_retries++ )
	    {
	        /* Read the id in */
	        if ( dallas_id_read ( &en_dp, &en->dallas_id ) )
	        {
	            continue;
	        }
	        else
	        {
	            /* Check the dallas is of the right family */
	            switch (en->dallas_id.d_family_code)
	            {
	              case DALLAS_ACORN_FAMILY_CODE:			/* if it's an Acorn part, then continue */
	                break;
	              case DALLAS_PROTON_FAMILY_CODE:			/* if it's a Proton part, then continue */
	              {
	                en->en_addr[0] = (PROTON_VENDOR_ALLOCATION >> 16) & 0xff;
	                en->en_addr[1] = (PROTON_VENDOR_ALLOCATION >> 8)  & 0xff;
	                en->en_addr[2] = (PROTON_VENDOR_ALLOCATION)       & 0xff;
	                en->en_addr[3] = en->dallas_id.d_id[2];
	                en->en_addr[4] = en->dallas_id.d_id[1];
	                en->en_addr[5] = en->dallas_id.d_id[0];
	                continue;					/* RDW: I hate this, but it keeps the code flow close to the original */
	              }
	              default:						/* else, we don't recognise the dallas chip, so break out of the for loop */
	                continue;					/* RDW: I hate this, but it keeps the code flow close to the original */
	            }

		    /* Get the acorn id part and check it */
		    myid = (*(int *)&en->dallas_id.d_id[3]) & 0xffffff;

		    if ( myid != 0x0050a4 )
		        continue;

		    /* I'm not to keen on this code, but it was supplied this way by acorn */
		    myid = (*(int *)(&en->dallas_id.d_family_code));
		    myid = myid>>8;
		    myetheraddr = 0xa4100000;
		    myetheraddr += myid;
		    if ( myetheraddr & (1<<23) )
		        continue;
		    if ( ( myetheraddr>>24 ) != 0xa4 )
		        continue;

		    /* Write it in then */
		    en->en_addr[0] = 0x00;
		    en->en_addr[1] = 0x00;
		    en->en_addr[2] = (myetheraddr>>24)&0xff;
		    en->en_addr[3] = (myetheraddr>>16)&0xff;
		    en->en_addr[4] = (myetheraddr>>8)&0xff;
		    en->en_addr[5] = (myetheraddr>>0)&0xff;
		    break;
	        }
	    }

	    /* Validate the dallas */
    	    for ( i=0; i<6; i++ )
    	    {
    	        if ((en->en_addr[i]!=0)&&(en->en_addr[i]!=0xff))
    	            break;
    	    }
    	    if ( i==6 )		/* Dallas chip has no valid address if i=6, so read flash constants... */
#endif
    	    {
	        /* If not the get them from the flash constants */
    	        for ( i=0; i<6; i++ )
	            en->en_addr[i] = flash_constants[i<<2];
    	    }
    	  }
	}

    got_address:
	/* validate the Ethernet address */
	for ( i=0; i<6; i++ )
	{
	    if ((en->en_addr[i]!=0)&&(en->en_addr[i]!=0xff))
                break;
        }

    	if ( i==6 )
    	{
    	    sprintf ( en_lasterr, "Ethernet address missing %d\n", slot );
            en->en_flags |= EN_FAULTY;
    	}

	/* declare the interrupt sense for old-fashioned machines */
	en->en_sense.flag = (int *)&en->Chip->isr;
	en->en_int_status = (int *)&en->Chip->isr;
	en->en_sense.mask = EN_INTR_MASK;

	/* declare the ISR to the XCB manager */
	en->en_handler.ih_fn = en_intr;
	en->en_handler.ih_farg = unit;
	/* note assumption of structure element ordering */
	if (_swix(Podule_ReadInfo, _INR(0,3), 0x38000, &en->en_int_mask, 12, slot))
	{
	    en->en_int_mask = (volatile u_int *) 0x03200028;
	    en->en_int_mask_bit = 0x20;
	    en->en_device_no = 13;
	}
	decl_xcb_interrupt(slot, &(en->en_handler), PRIO_ET, (int)en->en_int_status);
    }
    else
    {
	int unit = slotmap[slot];
	struct en_softc *en;

	if( unit >= 8 )
	    return;
	else
	    en = en_softc[unit];

	/* run the diagnostics */
	if ( en )
	    en_post(en, 0);
    }
}

/**********************************************************************/

/*
 * XCB shutdown entry point - reset the card
 */
static void en_shutdown(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/*
 * run power on self test for a card
 */
static int en_post(struct en_softc *en, int loopback_only)
{
    int retc;

    if( (en->en_flags & EN_FAULTY) )
	/* do not run the tests */
	return(0);

    /* run the diagnostic tests */
    retc = en_run_diags(en, loopback_only);
    if( !retc && !(en->en_flags & EN_RECOVERABLE_ERROR) )
	en->en_flags |= EN_FAULTY;

    /* pass the results to the statistics tests */
    if( (en->en_flags & (EN_FAULTY | EN_RECOVERABLE_ERROR)) )
	en->en_st_link_status = 0;
    else
	en->en_st_link_status |= ST_STATUS_OK;

    /* put the reset back on & return status */
    en_reset_card ( en->en_slot );

    return(retc);
}

/**********************************************************************/

/*
 * configure the NIC for diagnostic tests
 */
static void en_setup_diags(struct en_softc *en, NICRef nic,
			   u_char loop_mode, u_char manual_crc)
{
    int i;

    /*
     * must ensure the NIC is stopped - the act of starting
     * initialises its internal FIFO pointers. must also clear any
     * previous loopback mode - can only enter a loopback mode from
     * normal operation
     */
    nic->tcr = LOOP_MODE(LIVE_NET);
    if( (nic->isr & RST) )
	/* clear any outstanding reset signal */
	nic->isr = RST;
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    for( i = 0; i < STP_TIMEO; ++i )
    {
	if( (nic->isr & RST) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == STP_TIMEO )
    {
	sprintf(en_lasterr, "Unit %d: NIC has not reset\n",
	    slotmap[en->en_slot]);
	return;
    }

    /*
     * now set tcr to required loopback mode and
     * CRC type, then clear interrupts & mask
     * them all out
     */
    nic->tcr = LOOP_MODE(loop_mode) | manual_crc;
    nic->isr = 0xff;
    nic->imr = 0;

    /*
     * set up data configuration register
     */
    nic->dcr = WTS | FIFO_THRESH(WORD_THRESH4);

    /*
     * set parameters on page 1 - MAC address
     */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * bring the NIC back to page 0, alive & kicking
     */
    nic->command = SEL_PAGE(0, NIC_RUNNING);
}

/**********************************************************************/

/*
 * calculate the Autodin II CRC for the passed data
 */
static u_char *calc_crc(u_char *data, int datalen)
{
    u_long crc, swap = 0;
    int i, j;
    static u_char retc[sizeof(crc)];

    crc = ~0;
    for( i = 0; i < datalen; ++i )
    {
	u_long next = *data++;
	for( j = 0; j < NBBY; ++j )
	{
	    if( (next & 1) ^ (crc >> 31) )
		crc = (crc << 1) ^ POLYNOMIAL;
	    else
		crc <<= 1;
	    next >>= 1;
	}
    }

    /* reverse, nibble swap & complement the result */
    for( i = 0; i < (NBBY * sizeof(crc)); ++i )
    {
	swap <<= 1;
	swap |= ((crc & 0x01) ? 1 : 0);
	crc >>= 1;
    }

    for( i = 0; i < sizeof(crc); ++i)
    {
	retc[i] = (u_char) ~swap;
	swap >>= NBBY;
    }

    return(retc);
}


unsigned int calc_crc2 ( unsigned char *data, int datalen )
{
    unsigned int crc, swap;
    unsigned int bit, byte, j;

    crc = 0xffffffff;

    for ( byte=0; byte<datalen; byte++ )
    {
        for ( bit=*(data++),j=0;j<8;j++, bit>>=1 )
            crc = (crc>>1) ^ (((crc^bit)&0x01)?0xedb88320:0 );
    }

    for ( swap=0, bit=0; bit<32; bit++ )
    {
        swap<<=1;
        swap |= crc&1;
        crc>>=1;
    }

    return swap;
}

/**********************************************************************/

/*
 * build a loopback test packet - this is currently all zeros, plus an
 * appropriate CRC
 */
static void build_tpkt(struct en_softc *en, TestPacket *test_pack)
{
    int i;
    u_char *cptr;

    /*
     * check size of TestPacket to make sure no padding is present
     */
    if( sizeof(TestPacket) != (TESTP_LEN + CRC_LEN) )
	panic("ei: bad size for TestPacket\n");

    /*
     * build a packet full of zeroes then fill in the source
     * and destination address
     */
    memset ((caddr_t)test_pack, 0, TESTP_LEN);
    memcpy ((caddr_t)test_pack->src_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);
    memcpy ((caddr_t)test_pack->dst_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);

    /*
     * calculate & fill in the packet's CRC
     */
    for( i = 0, cptr = calc_crc((u_char *)test_pack, TESTP_LEN);
	i < CRC_LEN; ++i, ++cptr)
	test_pack->crc_bytes[i] = *cptr;
}

/**********************************************************************/

/*
 * run loopback tests in given loopback mode. manual_crc is the CRC
 * source used to program tcr (0 if NIC is to generate CRC, !0 if
 * CRC not appended after transmit). routine returns 0 if test failed,
 * else !0
 */
static int en_loopback(struct en_softc *en, TestPacket *test_pack,
		       u_char loop_mode, u_char manual_crc)
{
    NICRef nic = en->Chip;
    int i, pack_len;

    return 1;

    /*
     * set up the NIC, then start the transmit
     */
    en_setup_diags(en, nic, loop_mode, manual_crc);
    pack_len = TESTP_LEN + ((manual_crc) ? CRC_LEN : 0);
    nic->tpsr = 0;
    nic->tbcr0 = pack_len << 1;
    nic->tbcr1 = pack_len >> 7;
    nic->command = START_DMA(DMA_IDLE) | TXP;

    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->isr & (PTX | TXE)) )
	    /* packet has gone out */
	    break;

	MICRODELAY(1000000 / HZ);

    }

    if( (loop_mode == LOOPBACK3) && (nic->isr == TXE || i == LB_TIMEO) )
	return(lb3_failed(en, nic));
    else if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) transmit timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * now wait for the receive to come in
     */
    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->rsr & (PRX | CRCE | FAE)) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) receive timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * check the result from the test
     */
    if( manual_crc )
    {
	if( (nic->isr & RXE) )
	{
	    sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC recognition\n",
		slotmap[en->en_slot], loop_mode, manual_crc);
	    return(0);
	}
    }
    else if( loop_mode != LOOPBACK3 )
    {
	u_char nic_crc, *ok_crc;

	/*
	 * junk unwanted data from the FIFO
	 */
	for( i = 0; i < N_JUNK; ++i )
	    nulldev(nic->fifo);

	/*
	 * now read the CRC back & check it against what is expected
	 */
	for(i = 0, ok_crc = test_pack->crc_bytes;
	    i < CRC_LEN; ++i, ++ok_crc )
	    if( (nic_crc = nic->fifo) != *ok_crc )
	    {
		sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC (%x != %x)\n",
		    slotmap[en->en_slot], loop_mode, manual_crc,
		    nic_crc, *ok_crc);
		return(0);
	    }
    }

    /* tests passed successfully */
    return(1);
}

/**********************************************************************/

/*
 * en_run_diags - run a set of internal diagnostics. return 0 if
 * something failed, else 1.
 */
static int en_run_diags(struct en_softc *en, int loopback_only)
{
    register int i;
    NICRef nic = en->Chip;
    TestPacket lback_data;
    u_char *dptr = (u_char *)(&lback_data);
    static int lb_sequence[] = { LOOPBACK3 };

    if( !loopback_only )
    {
	u_int pattern[PAT_LEN];

	/* build the test pattern */
	for( i = 0; i < (PAT_MID - 1); ++i)
	{
	    pattern[i] = O(i);
	    pattern[i + PAT_MID] = Z(i);
	}
	pattern[PAT_MID - 1] = 0;
	pattern[PAT_LEN - 1] = 0xffff;

	/* configure the NIC in an appropriate mode */
	en_setup_diags(en, en->Chip, LOOPBACK1, 0);

	/* run the test for all pages */
	for( i = en->NIC_BUFFER_START; i < (en->NIC_BUFFER / en->NIC_PAGE); ++i )
	    if( !en_memtest(en, i, pattern) )
		return(0);
    }

    /*
     * run loopback tests - make sure the NIC is in some
     * sensible state, build the test packet & copy it
     * into on-card RAM
     */
    en_setup_diags(en, en->Chip, LOOPBACK1, 0);
    build_tpkt(en, &lback_data);

    nic->rbcr0 = (char) ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    /*
     * the NIC is loaded using word wide transfers, but can only
     * read byte wide for loopback testing. Therefore need to
     * write each byte from the packet into a word of memory.
     */
    nic->rsar0 = nic->rsar1 = 0;
    nic->rbcr0 = sizeof(TestPacket) << 1;
    nic->rbcr1 = sizeof(TestPacket) >> 7;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0; i < sizeof(TestPacket); ++i, ++dptr )
	*en->dma_port = (*dptr << 16) | (*dptr << 24);

    /*
     * check that remote DMA has completed
     */
    if( !(nic->isr & RDC) )
    {
	/*
	 * this is not yet a fatal error - give it
	 * a chance to recover then try again
	 */
	MICRODELAY(RDC_RECOVER_PERIOD);
    }

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote DMA failure, isr=%x\n",
	    slotmap[en->en_slot], (int) nic->isr);
	return(0);
    }
    else
	/* acknowledge the DMA completion */
	nic->isr = RDC;

    /* I dont set the recoverable error bit for the cable check so that the network */
    /* stuff can initialise properly without incident.  The user can plug the cable */
    /* in later */
#if 0
    check_cable(en); /* doing this seems to mess up writing of rcbc1 GS 7/4/99 */
#endif

    en->en_flags &= ~EN_RECOVERABLE_ERROR;

    for( i = 0; i < (sizeof(lb_sequence) / sizeof(lb_sequence[0])); ++i )
    {
	register u_int mode = lb_sequence[i];

	if( !en_loopback(en, &lback_data, mode, 0) )
	    return(0);

	if( !en_loopback(en, &lback_data, mode, 1) )
	    return(0);
    }

    /*
     * all tests passed - return OK status
     */
    return(1);
}

/**********************************************************************/

/*
 * run a memory test on the given page
 */
static int en_memtest(struct en_softc *en, int page, u_int *pattern)
{
    NICRef nic = en->Chip;
    int i, j;
    u_int nextword;

    /*
     * write the pattern into RAM
     */
    nic->rbcr0 = (u_char) ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = en->NIC_PAGE;
    nic->rbcr1 = en->NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0, j = 0; i < (en->NIC_PAGE >> 1); ++i )
    {
	*en->dma_port = (pattern[j] << 16);
	if( ++j == PAT_LEN )
	    j = 0;
    }

    /*
     * check that remote DMA has completed
     */
    if( !(nic->isr & RDC) )
    {
	/*
	 * this is not yet a fatal error - give it
	 * a chance to recover then try again
	 */
	MICRODELAY(RDC_RECOVER_PERIOD);
    }

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote write has not completed\n",
	    slotmap[en->en_slot]);
	return(0);
    }
    else
	nic->isr = RDC;

    /* now do the read & check */
    *en->page_reg = ((HARD_RESET_OFF | IO_READ) << 16);
    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = en->NIC_PAGE;
    nic->rbcr1 = en->NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_READ);
    for( i = 0, j = 0; i < (en->NIC_PAGE >> 1); ++i )
    {
	if( (nextword = (*en->dma_port & 0xffff)) != pattern[j] )
	{
	    sprintf(en_lasterr,
		"Unit %d (slot %d): RAM failure page %d, word %d (%x != %x)\n",
		slotmap[en->en_slot], en->en_slot, page,
		i, nextword, pattern[j]);
	    return(0);
	}

	if( ++j == PAT_LEN )
	    j = 0;
    }

    /* finished OK */
    return(1);
}

/**********************************************************************/

/*
 * see what has gone wrong with mode 3 loopback (onto live net,
 * therefore susceptible to genuine collisions)
 */
static int lb3_failed(struct en_softc *en, NICRef nic)
{
    u_char txstat = nic->tsr;
    int unit = slotmap[en->en_slot];

    if( !(txstat & COL) )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (no COL)\n",
	    unit);
	return(0);
    }
    else if( (txstat & ABT) )
    {
	sprintf(en_lasterr, "Unit %d: bad termination\n",
	    unit);
	return(0);
    }
    else if( nic->ncr == 0 )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (COL with 0 collisions)\n",
	    unit);
	return(0);
    }
    else
    {
	return(1);
    }
}

/**********************************************************************/

/*
 * attempt to send test packet out in non-loopback mode, use
 * transmit status to work out whether or not the cabling is OK
 *
 * MTR I've overrided this whole routine to do a cable check on
 * the TP connector.  If we ever do a BNC card, we should alter
 * this routine accordingly
 */
static int check_cable(struct en_softc *en)
{
    NICRef nic = en->Chip;
    int unit = slotmap[en->en_slot];

    int cb;

    /* Enable the link test */
    cb = nic->configb;
    cb &= ~7;
    nic->configb = cb;

    /* Delay for a bit, to be sure */
    MICRODELAY (1000);

    /* Check the link */
    if ( en->Chip->configb & 4 )
    {
        return 1;
    }
    else
    {
        sprintf ( en_lasterr, "Cable is not connected at unit %d\n", unit );
        return 0;
    }
}

/**********************************************************************/

char *bina ( unsigned char num )
{
    int c;
    static char text[9];

    for ( c=7; c>=0; c-- )
        text[7-c] = ((num>>c)&1) ? '1' : '0';
    text[8] = 0;

    return text;
}

char *bina32 ( unsigned int num )
{
    int c;
    static char text[33];

    for ( c=31; c>=0; c-- )
        text[31-c] = ((num>>c)&1) ? '1' : '0';
    text[32] = 0;

    return text;
}

/*
 * en_setup - initialise the NIC, but do not bring it up onto the network.
 * returns <> 0 if all OK, 0 if hardware determined to be faulty.
 */
static int en_setup(int unit)
{
    struct en_softc *en = en_softc[unit];
    NICRef nic = en->Chip;

    /* test for faulty hardware already detected */
    if( en->en_flags & EN_FAULTY )
	return(0);

    /* bring the card out of reset */

    /* wait for a bit 'till reset trickles through */
    MICRODELAY(25);

    /* initialise the command register */
    nic->command = CMD_INIT_VALUE;

    /*
     * set up the Data Configuration Register:
     *
     * 16-bit data transfers,
     * normal operation,
     * auto-initialise remote,
     * fifo threshold of 4 words.
     */
    nic->dcr = DCR_INIT_VALUE | FIFO_THRESH(WORD_THRESH4);

    /* clear remote byte count registers */
    nic->rbcr0 = nic->rbcr1 = 0;

    /*
     * set up the Receive Configuration Register:
     *
     * accept broadcast packets
     */
    nic->rcr = RCR_INIT_VALUE;

    /* put the NIC into loopback mode */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);

    /* set up the receive buffer ring */
    en->en_rbs = nic->bnry = nic->pstart = en->RX_START;
    en->en_rbd = nic->pstop = en->RX_END;

    /*
     * clear all bits in the ISR, then set up the IMR
     *
     * interrupts required:
     *
     * packet received,
     * packet transmitted,
     * receive error,
     * transmit error,
     * overwrite warning,
     * counter overflow.
     *
     * NOTE: write clear value to ISR twice to ensure all ints cleared
     */
    nic->isr = 0xff;
    nic->isr = 0xff;
    nic->imr = IMR_INIT_VALUE;

    /* select page 1 & set physical address */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * multicast filters: pass all multicast
     * packets (when AM bit is set in rcr)
     */

    nic->mar0 = nic->mar1 = nic->mar2 = nic->mar3 = 0x00;
    nic->mar4 = nic->mar5 = nic->mar6 = nic->mar7 = 0x00;

    /* set the current page register for remote DMA */
    en->en_nxt_pkt = nic->curr = en->RX_START + 1;

    /* put the NIC back to page 0 */
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    /* all done OK */
    return(1);
}

/**********************************************************************/

/*
 * en_forcepost - set the EN_RECOVERABLE_ERROR flag; this will force
 * a power-on self-test when en_bringup() is called.
 */
void en_forcepost(int unit)
{
    en_softc[unit]->en_flags |= EN_FORCEPOST;
}

/**********************************************************************/

void en_runtest(int unit)
{
    struct en_softc *en = en_softc[unit];

    /*
     * only bother if the card is not already diagnosed as faulty
     */
    if( !(en->en_flags & EN_FAULTY) )
    {
	/*
	 * pretend driver is disappearing while tests are performed
	 */
	send_driverstatus(dibs[unit], 1);

	/*
	 * driver will no longer be running after POST
	 */
	en->en_flags &= ~EN_RUNNING;

	(void)en_post(en, 1);

	/*
	 * XXX
	 *
	 * we're back!  the pretence that the driver has
	 * disappeared while the tests were being run will
	 * have confused the protocol modules which, when
	 * they receive the `startup' service call will
	 * try to reclaim the filters they already hold.
	 */
	en->en_flags |= EN_DUPCLAIMEXPECTED;
	send_driverstatus(dibs[unit], 0);

	/*
	 * if protocol modules have not reclaimed yet, then
	 * they have lost the chance to do so
	 */
	en->en_flags &= ~EN_DUPCLAIMEXPECTED;
    }

    /*
     * analyse and print results
     */
    if( (en->en_flags & (EN_FAULTY | EN_RECOVERABLE_ERROR)) )
    {
	printf("TESTS FAILED %s\n", en_lasterr);
    }
    else
    {
	printf("TESTS PASSED\n");
    }
}

/**********************************************************************/

/*
 * en_bringup - bring the card up live onto the network - returns 0
 * if all OK, else errno.
 */
static int en_bringup(int unit)
{
    register struct en_softc *en = en_softc[unit];
    int s;
    int cb;

    /* do not do this if already running */
    if( en->en_flags & EN_RUNNING )
    {
	return(0);
    }

    /*
     * check to see that card passed diagnostic tests
     */
    if( (en->en_flags & (EN_RECOVERABLE_ERROR | EN_FORCEPOST)) )
    {
	/* POST detected no network - try again */
	if( !en_post(en, 1) )
	    /*
	     * do not bring this network up - unit is either
	     * faulty or still has a recoverable error
	     */
	    return((en->en_flags & EN_FAULTY) ? ENXIO : ETIMEDOUT);
    }

    if( !en_setup(unit) )
	/*
	 * unit is faulty
	 */
	return(ENXIO);

    s = ensure_irqs_off();

#if 0
    /* doing this seems to mess up rbcr1 GS 7/4/99 */
    /* Select TP */
    cb = en->Chip->configb;
    cb &= ~7;
    en->Chip->configb = cb;
#endif

    /* set the NIC running, take it out of loopback mode */
    en->Chip->command = SEL_PAGE(0, NIC_RUNNING);
    en->Chip->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /* mark this interface as active */
    en->en_flags |= EN_RUNNING;

    /* all done */
    restore_irqs(s);
    return(0);
}

/**********************************************************************/

void en_init(void)
{
    int i;
    u_char buffer[16];
    _kernel_oserror *e;
    _kernel_swi_regs rin,rout;
    int s;
    int id;

    s = ensure_irqs_off();

/* Mod for Boca hardware
 * there is no podule manager or bus!
 */
#ifdef ONBOARD_ETHERNET
    for( i = 0; i < XCB_SLOTS; ++i )
    {
	en_slots[i] = 0;
	slotmap[i] = -1;
    }
    en_slots[0] = (++encnt);
    en_init_high(0);
#else
    for( i = 0; i < XCB_SLOTS; ++i )
    {
	en_slots[i] = 0;
	slotmap[i] = (char) -1;

	rin.r[3] = i;
	if( (e =_kernel_swi(Podule_ReadID, &rin, &rout)) == NULL )
	{
	    rin.r[2] = (int)buffer;
	    rin.r[3] = i;
	    e =_kernel_swi(Podule_ReadHeader, &rin, &rout);

	    id = buffer[3] | (buffer[4]<<8) | (buffer[5]<<16) | (buffer[6]<<24);

	    if( (id) == EN_TYPE )
	    {
		en_slots[i] = (++encnt);
		en_init_high(i);
	    }
	}
    }
#endif

    if( encnt == 0 )
    {
	restore_irqs(s);
	return;
    }

    for( i = 0; i < XCB_SLOTS; ++i )
	if( en_slots[i] )
	    en_init_low (i, 0);

    restore_irqs(s);

    for( i = 0; i < XCB_SLOTS; i++ )
	if( en_slots[i] )
	    en_init_low (i, 1);

    rin.r[0] = (int)"Inet$EiCount";
    rin.r[1] = (int)&encnt;
    rin.r[2] = 4;
    rin.r[3] = 0;
    rin.r[4] = 1;
    _kernel_swi(OS_SetVarVal, &rin, &rout);

    rin.r[0] = (int)"Inet$EtherType";
    rin.r[1] = (int)"ei0";
    rin.r[2] = 3;
    rin.r[3] = 0;
    rin.r[4] = 0;
    _kernel_swi(OS_SetVarVal, &rin, &rout);
}

/**********************************************************************/

int en_transmit(_kernel_swi_regs *r)
{
    u_int flags = r->r[0];
    u_int unit = r->r[1];
    u_int type = r->r[2];
    struct mbuf *m, *m0 = (struct mbuf *)(r->r[3]);
    u_char *edst = (u_char *)(r->r[4]);
    u_char *esrc = (flags & TX_FAKESOURCE) ? (u_char *)r->r[5] : 0;
    struct en_softc *en = en_softc[unit];
    int error = 0, s, i;

#ifdef BORDER
    set_border(1);
#endif

    /*s = splet();*/

    if (en_irq_active)
    {
      sprintf(en_lastlog,"Transmit entered during irq\n");
      return(EINPROGRESS);
    }

    if (en_tx_active)
    {
      sprintf(en_lastlog,"Transmit re-entered during transmit\n");
      return(EALREADY);
    }

#ifdef ENABLE_IRQS
    s = ensure_irqs_off();
    en_tx_active = 1;
    /*
     * stop all our cards from generating any interrupts
     * we can't deal with a receive whilst doing transmit
     */
    en = en_softc[0];
    en->Chip->imr = 0;
    restore_irqs(s);
#endif

#ifdef DEBUGTX
    printf("en_transmit: flags %d unit %d type %x m0 %x\n",
	   r->r[0], r->r[1], r->r[2], r->r[3]);
#endif

    if( flags >= TX_1STRESERVED )
	error = EINVAL;
    else if( !(en->en_flags & EN_RUNNING) )
	error = ENETDOWN;

    /*
     * XXX
     *
     * copy dest address into stats. structure - this is
     * very hacky, but we need to be as quick as possible
     *
     * this is not ideal, as recording the stats. here means
     * we don't hold the destination of the last packet transmitted,
     * merely that of the last packet a transmission request was
     * received for.
     */
    *(u_int *)(en->en_st_last_dest_addr) = *(u_int *)(r->r[4]);
    *(u_short *)(en->en_st_last_dest_addr + 4) = *(u_short *)(r->r[4] + 4);

    /*
     * run down the supplied mbuf list, transmitting each
     * chain, until an error is flagged.  all mbuf chains
     * not transmitted before an error condition arises
     * are silently dropped
     */
    while( m0 )
    {
	m = m0;
	m0 = m0->m_list;

	if( !error )
	    error = tx_mbufs(en, m, edst, type, esrc);

	if( !(flags & TX_PROTOSDATA) )
	    m_freem(m);
    }

    /*
     * all done
     */
    /*splx(s);*/

#ifdef ENABLE_IRQS
    s = ensure_irqs_off();

    /* check for outstanding transmits */
    /*if (en->TxPending)
        tx_done(en, en->Chip);*/

    /*
     * enable all our cards interrupts
     */
    en->Chip->imr = IMR_INIT_VALUE;
    en_tx_active = 0;
    restore_irqs(s);
#endif

    return (error);
}

/**********************************************************************/

_kernel_oserror *en_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int i,s,s2;
    struct en_softc *en;

#ifdef BORDER
    set_border(0);
#endif

#ifdef ENABLE_IRQS
    /* make sure this IRQ handler is not re-entered */
    if (en_irq_active)
    {
    	sprintf(en_lastlog,"Re-entering IRQ handler\n");
    	return (NULL);
    }

    /* make sure this IRQ handler is not entered when in en_transmit() */
    if (en_tx_active)
    {
    	sprintf(en_lastlog,"IRQ handler entered during transmit\n");
    	return (NULL);
    }

    /* set flag to indicate the IRQ handler has been entered */
    en_irq_active = 1;

    /* this will only work for 1 Ethernet card!!!! */
    en = en_softc[0];
    en->Chip->imr = 0;

    /* enable system IRQs */
    s = ensure_irqs_on();
#endif

    for( i = 0; i < XCB_SLOTS; i++ )
    {
	if( (en_slots[i]) && ((*en_softc[slotmap[i]]->en_int_status)&MY_INTS) )
	{
            /* deal with our interrupt(s) */
            en_intr( slotmap[i] );
	}

    }

#ifdef ENABLE_IRQS
    ensure_irqs_off();
    /* now enable interrupts from all our cards */
    en->Chip->imr = IMR_INIT_VALUE;
    en_irq_active = 0;
    restore_irqs(s);
#endif

#ifdef BORDER
    set_border(3);
#endif

    return (NULL);
}

/**********************************************************************/

void en_final(void)
{
#ifndef USE_DEVICEVECTOR
    _kernel_oserror *e;
    _kernel_swi_regs rin, rout;
#endif
    struct en_softc *en;
    int i;

    /* The original code here was _awful_ */

    for ( i=0; i<XCB_SLOTS; i++ )
    {
	if (en_slots[i])
	{
	    en = en_softc[slotmap[i]];
	    en_shutdown(i);

	    /* If we didn't claim, this swi will return an error and we will ignore it */
#ifdef USE_DEVICEVECTOR
/*            _swix ( OS_ReleaseDeviceVector, _INR(0,4), en->en_device_no, en_irq_entry, module_wsp, en->sc_easibase + EI_CTRLREG, 4 ); */
              _swix ( OS_ReleaseDeviceVector, _INR(0,4), en->en_device_no, en_irq_entry, module_wsp, en->en_int_status, MY_INTS );
#else
            rin.r[0] = 2;
            rin.r[1] = (int) en_irq_entry;
            rin.r[2] = (int) module_wsp;
            e = _kernel_swi(OS_Release, &rin, &rout);
#endif
	}
    }

/*
    for( i = 0; i < XCB_SLOTS; i++ )
    {
	if (en_slots[i])
	    en_shutdown (i);
    }

    _swix ( OS_ClaimDeviceVector, _IN(0)|_IN(1)|_IN(2)|_IN(3)|_IN(4), 13, en_intr_entry, module_wsp, easibase + EI_CTRLREG, 4 );
        rin.r[0] = 2;
       rin.r[1] = (int) en_irq_entry;
        rin.r[2] = (int) module_wsp;
        e = _kernel_swi(OS_Release, &rin, &rout);
    }
*/
}

/**********************************************************************/

u_char *en_addresses(int unit)
{
    struct en_softc *en = en_softc[unit];

    return((u_char *)en->en_addr);
}

/**********************************************************************/

#if 0
void filter_multi ( FilterSingleRef filter )
{
    unsigned char zeroaddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  };
    unsigned int c;

    if ( filter->fs_multiall )
    {
        printf ( "All multicast\n" );
        return;
    }

    for ( c=0; c<filter->fs_multitablesize; c++ )
    {
        if ( memcmp ( &filter->fs_multitable[c], zeroaddr, 8 ) )
            printf ( "%s", ether_sprintf ( filter->fs_multitable[c].address ) );
    }

    printf ( "\n" );
}
#endif

#ifdef HASHED_MULTICAST
void prmulticount(unsigned int *mc)
{
#if 1
    int i, j, b;
    printf("         multicasts");
    #if MULTICAST_HASHSIZE != 64
    #error Expecting 64 hash entries
    #endif
    for (i = 0; i < 8; i++)
    {
        b = 0;
        for (j = 0; j < 8; j++)
        {
            if (mc[i*8+j])
                b |= 1 << j;
        }
        printf("%s%02X", i==0?" ":":", b);
    }
    printf("\n");
#else
    int i;
    char l='[';

    for (i=0; i<MULTICAST_HASHSIZE; i++)
    {
        if (mc[i] != UINT_MAX)
            break;
    }

    if (i==MULTICAST_HASHSIZE)
    {
        printf("All multicasts\n");
        return;
    }

    for (i=0; i<MULTICAST_HASHSIZE; i++)
    {
        if (mc[i] != 0)
        {
            printf("%c%d:", l, i);
            if (mc[i] == UINT_MAX)
                putchar('x');
            else
                printf("%d", mc[i]);
            l = ',';
        }
    }

    if (l=='[')
        printf("No multicasts\n");
    else
        printf("]\n");
#endif
}
#endif

static const char *straddrlevel(int addrlevel)
{
    switch (addrlevel)
    {
        case ADDRLVL_SPECIFIC:    return "(specific)   ";
        case ADDRLVL_NORMAL:      return "(normal)     ";
        case ADDRLVL_MULTICAST:   return "(multicast)  ";
        case ADDRLVL_PROMISCUOUS: return "(promiscuous)";
        default:                  return "";
    }
}

int prenstats(int flag)
{
    struct en_softc *en;
    int i, unit;
    int enfound = 0;
    int filters_active;
    register NICRef nic;

    for( unit = 0; unit < encnt; ++unit)
    {
	int slot;

	en = en_softc[unit];
	nic = en->Chip;
	filters_active = 0;

#ifdef TXBUF_PROFILE
	printf ( "DEBUG %d\n", max_txbuf );
#endif
	if ( (en->en_addr[0]==0)&&(en->en_addr[1]==0)&&(en->en_addr[2]==0)&&
	     (en->en_addr[3]==0)&&(en->en_addr[4]==0)&&(en->en_addr[5]==0) )
	{
	    printf ( "ei%d 16-bit transfers COMPUTER COULD NOT SUPPLY AN ETHERNET ADDRESS\n", unit );
	}
	else
	{
	    printf ( "ei%d 16-bit transfers Ethernet address %02X:%02X:%02X:%02X:%02X:%02X\n",
		unit, en->en_addr[0], en->en_addr[1], en->en_addr[2],
		      en->en_addr[3], en->en_addr[4], en->en_addr[5] );
	    printf("ei%d: (mod %x) frame buffer %dKB : PAL type %c\n",
		unit, en->sc_modification, (en->NIC_BUFFER) >> 10, ((en->sc_modification & 1) == 0) ? 'A':'C' );
	}

	for( slot = 0; slot < XCB_SLOTS; ++slot )
	    if( slotmap[slot] == i )
		break;

	printf ( "   TX frames %10ld : TX errors %10ld : TX bytes %10ld\n   TX ints   %10ld\n",
	 		en->en_st_tx_frames,
	        	en->en_st_tx_general_errors,
	        	en->en_st_tx_bytes,
	        	en->en_st_tx_interrupts);

	printf ( "   RX frames %10ld : RX errors %10ld : RX bytes %10ld\n   RX ints   %10ld\n\n",
	        	en->en_st_rx_frames,
	        	en->en_st_rx_general_errors,
	        	en->en_st_rx_bytes,
	        	en->en_st_rx_interrupts);

	printf ( "   Frame types claimed:\n" );

	if( ieeefilter[unit] )
	{
	    printf ( "      IEEE 802.3       %s handler=(%08X,%08X)\n",
	             straddrlevel(ieeefilter[unit]->fs_addrlevel),
	             (u_int) ieeefilter[unit]->fs_handler, ieeefilter[unit]->fs_pwptr );
#ifdef HASHED_MULTICAST
	    if (ieeefilter[unit]->fs_addrlevel == ADDRLVL_MULTICAST)
	    	prmulticount(ieeefilter[unit]->fs_multicount);
#endif
	}

	if( e2monitor[unit] )
	{
	    printf ( "      Ethernet Monitor %s handler=(%08X,%08X)\n",
	             straddrlevel(e2monitor[unit]->fs_addrlevel),
	             (u_int) e2monitor[unit]->fs_handler, e2monitor[unit]->fs_pwptr );
#ifdef HASHED_MULTICAST
	    if (e2monitor[unit]->fs_addrlevel == ADDRLVL_MULTICAST)
	        prmulticount(e2monitor[unit]->fs_multicount);
#endif
	}

	if( e2sink[unit] )
	{
	    printf ( "      Ethernet Sink    %s handler=(%08X,%08X)\n",
	             straddrlevel(e2sink[unit]->fs_addrlevel),
	             (u_int) e2sink[unit]->fs_handler, e2sink[unit]->fs_pwptr );
#ifdef HASHED_MULTICAST
	    if (e2sink[unit]->fs_addrlevel == ADDRLVL_MULTICAST)
	        prmulticount(e2sink[unit]->fs_multicount);
#endif
	}

	if( e2specific[unit] )
	{
	    FilterChainRef fc = e2specific[unit];

	    ++filters_active;

	    while( fc )
	    {
		printf ( "      Ethernet %04x    %s handler=(%08X,%08X)\n", fc->fc_type,
	             straddrlevel(fc->fc_filter.fs_addrlevel),
	             (u_int) fc->fc_filter.fs_handler, fc->fc_filter.fs_pwptr );
#ifdef HASHED_MULTICAST
	        if (fc->fc_filter.fs_addrlevel == ADDRLVL_MULTICAST)
	            prmulticount(fc->fc_filter.fs_multicount);
#endif
		fc = fc->fc_next;
	    }
	}

	printf ( "\n   link 10BaseT\n" );
    }
#if 0
    nic->command = SEL_PAGE(1, NIC_STOPPED);
#endif

        printf ( "   multicast filter %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\n",
	en->en_mar[0], en->en_mar[1], en->en_mar[2], en->en_mar[3],
	en->en_mar[4], en->en_mar[5], en->en_mar[6], en->en_mar[7] );

#if 0
    nic->command = SEL_PAGE(0, NIC_STOPPED);
    nic->command = SEL_PAGE(0, NIC_RUNNING);
#endif
    if( en_lasterr[0] )
    {
        printf("   last error %s\n", en_lasterr);
        en_lasterr[0] = '\0';
    }

    if( en_lastlog[0] )
    {
        printf("   last log %s\n", en_lastlog);
        en_lastlog[0] = '\0';
    }


    return(enfound);
}

/**********************************************************************/

int xcb_add_ethernet_card(int unit, int slot)
{
    return( unit > 8 ? 0 : 1 );
}

/**********************************************************************/

/*
 * set_receive_level - either turn the hardware for the unit off
 * (if addrlevel = -1), or enable appropriate levels of packet
 * reception
 */
void set_receive_level(int unit, int addrlevel)
{
    struct en_softc *en = en_softc[unit];

    en->en_st_link_status &= ~(ST_STATUS_RXMASK);

    if( addrlevel == -1 )
    {
	/*
	 * take the hardware down
	 */
	enioctl(unit, 1, 0);

	en->en_st_link_status &= ~ST_STATUS_ACTIVE;
    }
    else
    {
	u_char rcrbits = RCR_INIT_VALUE;
	u_char status = ST_STATUS_DIRECT;

	if( addrlevel >= ADDRLVL_NORMAL )
	{
	    /* broadcasts are OK */
	    rcrbits |= AB;

	    status = ST_STATUS_BROADCAST;
	}

	if( addrlevel >= ADDRLVL_MULTICAST )
	{
	    /* multicasts are OK */
	    rcrbits |= AM;

	    status = ST_STATUS_MULTICAST;
	}

	if( addrlevel >= ADDRLVL_PROMISCUOUS )
	{
	    rcrbits |= PRO;

	    status = ST_STATUS_PROMISCUOUS;
	}

#ifdef DEBUG
	Printf("\021\06set_receive_level: rcr = %x (addrlevel = %x)\021\07\n",
	       rcrbits, addrlevel);
#endif

	/*
	 * update the recieve control register on the chip
	 */
	en->Chip->rcr = rcrbits;

	en->en_st_link_status |= (status | ST_STATUS_ACTIVE);
    }
}

/**********************************************************************/

int en_stats(_kernel_swi_regs *r)
{
    struct stats *sptr;
    struct en_softc *en;
    register NICRef nic;

    en = en_softc[r->r[1]];
    nic = en->Chip;

    switch ( r->r[0] )
    {
      case 0:
	sptr = &st;
	break;

      case 1:
	sptr = &(en->en_stats);
	nic->command = SEL_PAGE(0, NIC_RUNNING);
	/* removed this 7/4/99 GS */
	/*en->en_st_link_polarity = (nic->configb & 1<<2) >> 2;*/
	/* assume link okay 2000/08/17 RJC */
	en->en_st_link_polarity = 1;
	break;

      default:
	return(EINVAL);
    }

    (void)memcpy((char *)(r->r[2]), (char *)sptr, sizeof(*sptr));
    return(0);
}

/**********************************************************************/

int enioctl(int unit, int cmd, int flag)
{
    register struct en_softc *en;
    int s, error = 0;

    if (unit < 0 || unit > 4)
	return (1);
    en = en_softc[unit];
    switch(cmd)
    {
      case 0:
	if( en->en_flags & EN_FAULTY )
	    return (1);
	error = en_bringup(unit);
	break;

      case 1:
	s = ensure_irqs_off();

	/*
	 * log a message on next CD/Heartbeat error
	 */
	en->en_flags &= ~EN_SQEINFORMED;
	en->en_flags |= EN_SQETEST;

	if( (en->en_flags & EN_FAULTY) )
	{
	    en_reset_card(en->en_slot);
	    break;
	}

	if( flag == 0 && (en->en_flags & EN_RUNNING) )
	{
	    /* take the card down */
	    en_reset_card(en->en_slot);
	    en->en_flags &= ~EN_RUNNING;
	}
	else if( flag && !(en->en_flags & EN_RUNNING) )
	    error = en_bringup(unit);

	restore_irqs(s);
	break;

      default:
	break;
    }

    /* that's all */
    return(error);
}

/**********************************************************************/

static int load_packet(u_char *hw_dst, u_char *hw_src, u_short type,
			struct mbuf *m0, volatile u_int *port, int datalen, int page, NICRef nic )
{
    u_int bytebuf = 0;
    int s;

    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = datalen;
    nic->rbcr1 = datalen >> 8;
    nic->command = START_DMA(DMA_WRITE);

    /*
     * load up the packet destination, source, and type first
     */
    en_io_out(hw_dst, port, HW_ADDR_LEN, &bytebuf);
    en_io_out(hw_src, port, HW_ADDR_LEN, &bytebuf);
    en_io_out((u_char *)(&type), port, sizeof(u_short), &bytebuf);

    /* now load up the mbuf data */
    for( ; m0; m0 = m0->m_next)
    {
	en_io_out(mtod(m0, u_char *), port, m0->m_len, &bytebuf);
    }

    /* flush any odd bytes remaining */
    en_flush_output(port, &bytebuf);

#if 0
    while ( !(nic->isr & RDC) )
        /* Do nothing */;
#endif

    if( !(nic->isr & RDC) )
    {
        /*
         * this is not yet a fatal error - give it
         * a chance to recover then try again
         */
	MICRODELAY(RDC_RECOVER_PERIOD);
    }

    /* now test the RDC bit for real */
    if( !(nic->isr & RDC) )
        return 0;

    nic->isr = RDC;

    /* finished */
    return 1;
}


/**********************************************************************/

/*
 * tx_mbufs - copy packet out of mbuf chain into Tx buffer, and queue
 * the transmit request. returns 0 if all OK, else an appropriate errno.
 */
static int tx_mbufs(struct en_softc *en, struct mbuf *m0,
		    u_char *edst, int type, u_char *esrc)
{
    register struct mbuf *m;
    register int datalen;
    TxqRef txdesc;
    NICRef nic = en->Chip;
    int s, retries;
    u_char TxPending;

    /* count the length of the packet */
    for( datalen = PACK_HDR_LEN, m = m0; m; m = m->m_next )
	datalen += m->m_len;

    /* another frame for the stats. */
    en->en_st_tx_frames++;
    en->en_st_tx_bytes += datalen;

    if( datalen > ETHERMAXP )
    {
	/* log this as a general transmit failure */
	sprintf(en_lasterr, "Unit %d: Asked to transmit a giant packet\n",
		en->en_unit);
	en->en_st_tx_general_errors++;

	return(EMSGSIZE);
    }

    s = ensure_irqs_off();

    /* check for a free transmit structure */
    if( (txdesc = en->TxqFree) == (TxqRef)NULL )
    {




	/*
	 * no free structures - log this
	 * as a general transmit failure
	 */
	restore_irqs(s);
	sprintf(en_lasterr, "Unit %d: No free transmit buffers\n",
		en->en_unit);
       	en->en_st_tx_general_errors++;

	return(INETERR_TXBLOCKED);
    }
    else
    {
	/* pull this buffer off the chain */
	en->TxqFree = txdesc->TxNext;
	txdesc->TxNext = (TxqRef)NULL;
	txdesc->TxByteCount = max(datalen, (ETHERMIN + PACK_HDR_LEN));
    }

#ifdef TXBUF_PROFILE
    {
        TxqRef n;
        int m;

        for ( m=0, n=en->TxqFree; n!=NULL; n=n->TxNext )
            m++;
        if ( max_txbuf > m )
            max_txbuf = m;
    }
#endif

    /* loop until packet is loaded, or excessive retries have failed */
    for( retries = 0; retries <= MAX_RDC_RETRIES; ++retries )
    {
	/*
	 * define I/O direction, execute workaround for bug in remote
	 * write DMA, initialise remote DMA parameters, then load
	 * the packet
	 */
	nic->rbcr0 = (u_char) ~0;
	nic->command = START_DMA(DMA_READ);

	MICRODELAY(1);
	nic->command = START_DMA(DMA_ABORT);

	if ( load_packet(edst, esrc?esrc:(u_char *)en->en_addr,
		    htons(type), m0, en->dma_port, datalen, txdesc->TxStartPage, nic ) )
        {
            break;
        }
        else
        {
	    shutdown(nic, &TxPending);
	    startup(en, nic, TxPending);
        }
    }

    if( retries > MAX_RDC_RETRIES )
    {
	/*
	 * discarding this transmit - return transmit buffer
	 * to free chain & return error
	 */
	txdesc->TxNext = en->TxqFree;
	en->TxqFree = txdesc;
	sprintf(en_lastlog, "Unit %d: RDC failure in tx_mbufs()\n",
	    en->en_unit);

	restore_irqs(s);

	/* mark this as a general tx failure */
	en->en_st_tx_general_errors++;

	return(EIO);
    }

    /* is this the first packet in the queue? */
    if( en->TxPending == (TxqRef)NULL )
    {
	/* yes - kick start the NIC */
	en->TxPending = txdesc;
	start_tx(en, nic);
    }
    else
    {
	register TxqRef prev;
	for( prev = en->TxPending; prev->TxNext; prev = prev->TxNext )
	    /* do nothing */
	    ;

	prev->TxNext = txdesc;
    }

    /* all done */
    restore_irqs(s);
    return(0);
}

#ifndef HASHED_MULTICAST
static int en_add_addrs ( struct en_softc *en, FilterSingleRef filter )
{
    register NICRef nic = en->Chip;
    unsigned char zeroaddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    unsigned int crc, byte, bit, c;

    if ( filter==0 )
        return 0;

    if ( filter->fs_multiall )
    {
        /* Open up the filter and return no more work */
        nic->mar0 = nic->mar1 = nic->mar2 = nic->mar3 = 0xff;
        nic->mar4 = nic->mar5 = nic->mar6 = nic->mar7 = 0xff;

        memset(&en->en_mar[0], 0xff, sizeof(en->en_mar));

        return 1;
    }

    /* Add all the addresses */
    for ( c=0; c<filter->fs_multitablesize; c++ )
    {
        if ( !memcmp ( &filter->fs_multitable[c].mac_address, zeroaddr, 8 ) )
            continue;

        /* We have an address to add here */
	crc = calc_crc2 ( (unsigned char *)&filter->fs_multitable[c].mac_address, 6 );

        /* crc is 6 MS bits of crc */
        crc = crc>>(32-6);
        byte = (crc>>3)&0x7;
        bit  = 1<<(crc&0x7);

        /* Hmm */
        switch ( byte )
        {
            case 0:
              nic->mar0 |= bit;
              en->en_mar[0] |= bit;
              break;
            case 1:
              nic->mar1 |= bit;
              en->en_mar[1] |= bit;
              break;
            case 2:
              nic->mar2 |= bit;
              en->en_mar[2] |= bit;
              break;
            case 3:
              nic->mar3 |= bit;
              en->en_mar[3] |= bit;
              break;
            case 4:
              nic->mar4 |= bit;
              en->en_mar[4] |= bit;
              break;
            case 5:
              nic->mar5 |= bit;
              en->en_mar[5] |= bit;
              break;
            case 6:
              nic->mar6 |= bit;
              en->en_mar[6] |= bit;
              break;
            case 7:
              nic->mar7 |= bit;
              en->en_mar[7] |= bit;
              break;
        }
    }

    return 0;
}
#endif

static const u_char empty_mar[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static const u_char full_mar[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

void en_update_multicast_filter ( int unit )
{
    struct en_softc *en = en_softc[unit];
    register NICRef nic = en->Chip;
    FilterSingleRef filter=0;
    FilterChainRef chain;
    u_char TxPending;
    u_char mar_buf[8];
    const u_char *new_mar;
    int s = ensure_irqs_off();
    int i, j;
    int rxstatus;

#ifdef HASHED_MULTICAST
    rxstatus = en->en_st_link_status & ST_STATUS_RXMASK;

    if (rxstatus < ST_STATUS_MULTICAST)
        new_mar = empty_mar;
    else if (rxstatus > ST_STATUS_MULTICAST)
        new_mar = full_mar;
    else {
        for (i = 0; i < 8; i++) {
            mar_buf[i] = 0x00;
            for (j = 0; j < 8; j++)
                if (en->en_multicount[i * 8 + j])
                    mar_buf[i] |= 1 << j;
        }
        new_mar = mar_buf;
    }

    if (memcmp(new_mar, en->en_mar, 8) == 0)
        return;                 /* registers haven't changed */

    shutdown(nic, &TxPending);

    nic->command = SEL_PAGE(1, NIC_STOPPED);

    memcpy(en->en_mar, new_mar, 8);

    /* Can we really not provide array access to the NIC? */
    nic->mar0 = new_mar[0];
    nic->mar1 = new_mar[1];
    nic->mar2 = new_mar[2];
    nic->mar3 = new_mar[3];
    nic->mar4 = new_mar[4];
    nic->mar5 = new_mar[5];
    nic->mar6 = new_mar[6];
    nic->mar7 = new_mar[7];

    nic->command = SEL_PAGE(0, NIC_RUNNING);
    startup(en, nic, TxPending);
#else

    shutdown(nic, &TxPending);

    nic->command = SEL_PAGE(1, NIC_STOPPED);

    nic->mar0 = nic->mar1 = nic->mar2 = nic->mar3 = 0x00;
    nic->mar4 = nic->mar5 = nic->mar6 = nic->mar7 = 0x00;

    memset(&en->en_mar[0], 0, sizeof(en->en_mar));

    filter = e2sink[unit];
    if ( (en_add_addrs ( en, filter ))!=0 ) goto out;

    filter = e2monitor[unit];
    if ( (en_add_addrs ( en, filter ))!=0 ) goto out;

    filter = ieeefilter[unit];
    if ( (en_add_addrs ( en, filter ))!=0 ) goto out;

    for ( chain=e2specific[unit]; chain; chain=chain->fc_next )
    {
        filter = &chain->fc_filter;
        if ( (en_add_addrs ( en, filter ))!=0 ) goto out;
    }

out:

   /*nic->command = SEL_PAGE(0, NIC_STOPPED);*/
    nic->command = SEL_PAGE(0, NIC_RUNNING);
    startup(en, nic, TxPending);
#endif

    restore_irqs(s);
}

#ifdef BORDER
#define VIDC ((volatile unsigned int *)0x03500000)

void set_border(int colour)
{
    *VIDC = 0x40000000u | ((255 << (colour*8)) & 0x00FFFFFF);
}
#endif


/**********************************************************************/

/* EOF if_en.c */
