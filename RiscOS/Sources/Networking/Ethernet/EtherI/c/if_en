/* -*-C-*-
 *
 * $Header$
 * $Source$
 *
 * Copyright(c) 1995 Acorn Computers Ltd., Cambridge, England
 *
 * $Log$
 * Revision 1.1  95/09/18  15:17:53  kwelton
 * Initial revision
 *
 * Adapted for use on NC's ethernet card by Irlam Instruments
 * Massive patching to work around MX chipset
 * Big fixed ensuring alignment of mbuf data.  Required for LanManFS.
 *
 */
  
#undef TXBUF_PROFILE

#ifdef TXBUF_PROFILE
static int max_txbuf = 100;
#endif

#include "kernel.h"
#include "swis.h"
#include "delay.h"

#include "sys/types.h"
#include "sys/dcistructs.h"
#include "sys/mbuf.h"
#include "sys/errno.h"

#include "int_hndlr.h"
#include "xcb.h"
#include "ioc.h"

#include "if_en.h"
#include "e2module.h"

#include "dallas.h"

#define DALLAS

#undef XCB_SLOTS
#define XCB_SLOTS	(8)

/*
 * MXPATCH
 *
 * The MX chipset seems to fuck up the SENDP command, and also
 * the rbcr1 registers seems to be fucked too, so we cannot DMA
 * more than 256 bytes in one bit.  This results in a little
 * loss in performance.
 */

/*
 * XXX TRACE XXX
 *
 * if someone could tell me why this value has
 * been altered to 700 (it is usually 100), I
 * would be really interested
 */
#define HZ 100

struct en_softc *en_softc[8];

extern void en_io_out(), en_flush_out(), en_io_in();
extern char *ether_sprintf();

extern int callproto();

#define ENCARD_ROM(slot)	(XCB_ADDRESS(FAST, slot))

#ifndef NULL
# define NULL 0
#endif

#define EN_TYPE (0x001f5678)

char en_lastlog[64] = { 0 };
char en_lasterr[64] = { 0 };

int encnt = 0;
char slotmap[8];
static int en_slots[8];

extern void *module_wsp;
struct int_hndlr intr_routine;
extern void en_log();
extern int en_irq_entry();
extern void enable_podule_irqs();
extern void disable_podule_irqs();

extern DibRef dibs[];

extern FilterSingleRef ieeefilter[8];
extern FilterSingleRef e2monitor[8];
extern FilterSingleRef e2sink[8];
extern FilterChainRef e2specific[8];

extern int (*address_filter)(u_int level, u_char *pack_hdr, u_char *mac_addr);

#ifndef MXPATCH
static int pdrops = 0;
#endif

static struct stats st = { 0 };

/**********************************************************************/

static void nulldev(u_char c)
{
    c = c;
}

/**********************************************************************/

/*
 * shutdown - go through the motions of taking the NIC off a live
 * network to allow recovery from a ring buffer overflow
 */
static void shutdown(NICRef nic, u_char *TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * test for transmit pending
     * issue the STOP command,
     * clear remote byte counters,
     * wait for RST to come up,
     * put the NIC into loopback,
     * issue the START command.
     */
    *TxPending = nic->command & TXP;
    nic->command = SEL_PAGE(0, NIC_STOPPED);
    nic->rbcr0 = nic->rbcr1 = 0;
    MICRODELAY(100);
#if 0
    while( !(nic->isr & RST) )
	/* do nothing */
	;
#endif
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);
    nic->command = SEL_PAGE(0, NIC_RUNNING);

    /*
     * acknowledge the RST bit also clear RDC which
     * decides to appear
     */
    nic->isr = (RST | RDC);
}

/**********************************************************************/

/*
 * abort_packet - stop the currently executing send_packet command
 */
static void abort_packet(struct en_softc *en, NICRef nic, u_char *buff_hdr)
{

#ifdef MXPATCH
    int Bnry;
#endif
    
    /*
     * send the ABORT DMA command, then move the
     * boundary pointer past the unwanted packet
     */
    nic->command = START_DMA(DMA_ABORT);

#ifndef MXPATCH
    nic->bnry = *(buff_hdr + 1);
#else
    Bnry = en->en_nxt_pkt-1;
    if ( Bnry < en->en_rbs )
        Bnry = en->en_rbd-1;
    nic->bnry = Bnry;
#endif

    /*
     * throw away the data waiting for us at the DMA port
     */
    nulldev(*en->dma_port);
}

/**********************************************************************/

#ifndef MXPATCH
/*
 * drop_packet - discard packet data
 */
static void drop_packet(struct en_softc *en, int datalen)
{
    register volatile u_int *port = en->dma_port;
    int i;
    char buf[128 + 2];

    pdrops++;
    datalen -= PACK_HDR_LEN + CRC_LEN;
    for( i = datalen; i > 0; i -= 128 )
	en_io_in(port, buf, min(i, 128));
}
#endif

/**********************************************************************/

static    u_char pack_hdr[PACK_HDR_LEN];
static    u_char buff_hdr[BUFF_HDR_LEN];
static    RxHdrRef hdr;
/*
void mbuf_dump ( struct mbuf *m )
{
    parallel_printf ( "struct mbuf {\n" );
    parallel_printf ( "    struct mbuf         *m_next   = %08x\n", m->m_next   );
    parallel_printf ( "    struct mbuf         *m_list   = %08x\n", m->m_list   );
                                      
    parallel_printf ( "    ptrdiff_t            m_off    = %08x\n", m->m_off    );
    parallel_printf ( "    size_t               m_len    = %08x\n", m->m_len    );
    parallel_printf ( "    const ptrdiff_t     *m_inioff = %08x\n", m->m_inioff );
    parallel_printf ( "    const ptrdiff_t     *m_inilen = %08x\n", m->m_inilen );

    parallel_printf ( "    unsigned char        m_type   = %02x\n", m->m_type   );
    parallel_printf ( "    const unsigned char  m_sys1   = %02x\n", m->m_sys1   );
    parallel_printf ( "    const unsigned char  m_sys2   = %02x\n", m->m_sys2   );
    parallel_printf ( "    const unsigned char  m_sys3   = %02x\n", m->m_sys3   );
    parallel_printf ( "}" );
}
*/

/*
 * en_read - read a packet out of the ring buffer (no trailers!)
 */
void en_read(struct en_softc *en, NICRef nic)
{
    register u_int databuff;
    register volatile u_int *port = en->dma_port;
    register struct mbuf *m, *m0 = NULL;
    /*
     * XXX
     *
     * pack_hdr *must* be word aligned - this fact is used by a
     * hacky test for broadcast addresses in the address filters
     */
    u_short type;
    u_int datalen;
    u_int unit = en->en_unit;
    int i;
    FilterSingleRef fs = NULL;
    int this_packet;
    int bytes_left;
    int ptr;
    
#ifdef DEBUG
    Printf("ei_read(%d)...", unit);
#endif

    /* we have received another frame */
    en->en_st_rx_frames++;

    /* Rememer which frame we're doing */
    this_packet = en->en_nxt_pkt;

    /* start the Send Packet command */
#ifdef MXPATCH
    /* Do the header in 1 go */
    nic->rsar0 = 0;
    nic->rsar1 = this_packet;
    nic->rbcr0 = BUFF_HDR_LEN + PACK_HDR_LEN;
    nic->rbcr1 = 0;
    nic->command = START_DMA(DMA_READ);    
#else
    /* Send the whole packet up */
    nic->rbcr1 = 0x0f;
    nic->command = START_DMA(DMA_SENDP);
#endif

    /* read the buffer header */
    for( i = 0; i < BUFF_HDR_LEN; i += 2 )
    {
	databuff = *port;
	buff_hdr[i] = databuff;
	buff_hdr[i + 1] = databuff >> 8;
    }

    /*
     * read the packet length from this header
     */
    datalen = *(u_short *)(buff_hdr + 2);
    if( datalen < (PACK_HDR_LEN + CRC_LEN) )
    {
	/* update stats */
	en->en_st_runt_frames++;

#ifdef DEBUG
	Printf("bad length (%d) - aborting\n", datalen);
#endif
	abort_packet(en, nic, buff_hdr);
	return;
    }
    
    /*
     * set the next packet pointer from the header
     */
     
    en->en_nxt_pkt = *(buff_hdr + 1);

    /*
     * read the packet header to get dest address, src address
     * and packet type.
     */
    for( i = 0; i < PACK_HDR_LEN; i += 2)
    {
	databuff = *port;
	pack_hdr[i] = databuff;
	pack_hdr[i + 1] = databuff >> 8;
    }

    /*
     * XXX
     *
     * copy source address into stats. structure - because of
     * unfavourable word alignments, we cannot use the same
     * hack applied to the st_last_dst_addr stat.
     */
    memcpy(en->en_st_last_src_addr, pack_hdr + HW_ADDR_LEN, HW_ADDR_LEN);

#ifdef MXPATCH
    /*
     * Check that the DMA for the headers completed
     */
    if( !(nic->isr & RDC) ) {
	MICRODELAY(RDC_RECOVER_PERIOD);

	if( !(nic->isr & RDC) )
	{
	    sprintf(en_lastlog, "Unit %d: RDC failure in ei_read\n",
		    en->en_unit);
	    type = 0;
	    abort_packet(en, nic, buff_hdr);
	    goto rdc_failed;
	}
    }
    /* Acknowledge it */
    nic->isr = RDC;
    
#endif

    /*
     * drop overlong packets
     */
    if( datalen > ETHERMTU + (PACK_HDR_LEN + CRC_LEN) )
    {
	en->en_st_overlong_frames++;
#ifndef MXPATCH
	drop_packet(en, datalen);
	goto dropcrc;
#else
	goto unwanted;
#endif	
    }

    /*
     * get the type, & decide if we can handle it
     */
    type = ntohs(*(u_short *)(pack_hdr + (2 * HW_ADDR_LEN)));

#ifdef DEBUG
    Printf("type = %x\n", type);
#endif

    /*
     * 1st discrimination of frame type - is it
     * an IEEE 802.3 or an Ethernet 2.0 frame?
     */
    if( type <= ETHERMTU )
    {
	fs = ieeefilter[unit];
	SET_FRAMELEVEL(type, FRMLVL_IEEE);
    }

    /*
     * it's an Ethernet 2.0 frame, do we have
     * specific or sink filters active?
     */
    else if( e2specific[unit] || e2sink[unit] )
    {
	FilterChainRef fc;

	/*
	 * start by trying to match specific frame types
	 */
	for( fc = e2specific[unit]; fc; fc = fc->fc_next )
	    if( fc->fc_type == type )
	    {
		fs = &fc->fc_filter;
		SET_FRAMELEVEL(type, FRMLVL_E2SPECIFIC);
		break;
	    }

	/*
	 * default to sink filter if no specific matches
	 */
	if( !fc )
	{
	    fs = e2sink[unit];
	    SET_FRAMELEVEL(type, FRMLVL_E2SINK);
	}
    }

    /*
     * all we have left is the Ethernet 2.0 monitor
     */
    else
    {
	fs = e2monitor[unit];
	SET_FRAMELEVEL(type, FRMLVL_E2MONITOR);
    }

    /*
     * statistics count *all* received frames, not
     * just those passed along to protocols.
     */
    en->en_st_rx_bytes += datalen;

    /*
     * pass the packet along if it is wanted
     */
    if( fs )
    {
	/*
	 * use the filtering routine appropriate to
	 * the current level of packet reception
	 */
	if( address_filter(fs->fs_addrlevel, pack_hdr, (u_char *)en->en_addr) )
	{
	    fs = NULL;
	    en->en_st_unwanted_frames++;
#ifndef MXPATCH
	    drop_packet(en, datalen);
	    goto dropcrc;
#else
	    goto unwanted;
#endif
	}
    }
    else
    {
	/*
	 * no protocols want this frame
	 */
	en->en_st_unwanted_frames++;
#ifndef MXPATCH
	drop_packet(en, datalen);
	goto dropcrc;
#else
	goto unwanted;	
#endif	
    }

#ifdef OldCode
    if( (m = (m0 = m_get(M_DONTWAIT, MT_DATA))) == (struct mbuf *)0 )
    {
	fs = NULL;
#ifndef MXPATCH
	drop_packet(en, datalen);
#endif
	goto dropcrc;
    }
#else
    if( (m = (m0 = ALLOC_S(MINCONTIG, NULL))) == (struct mbuf *)0 )
    {
	fs = NULL;
#ifndef MXPATCH
	drop_packet(en, datalen);
	goto dropcrc;
#else
	goto unwanted;
#endif
    }
    m->m_type = MT_HEADER;
#endif

    hdr = mtod(m0, RxHdrRef);
    m0->m_len = sizeof(RxHdr);

    hdr->rx_tag = 0;
    memcpy(hdr->rx_src_addr, pack_hdr + HW_ADDR_LEN, HW_ADDR_LEN);
    memcpy(hdr->rx_dst_addr, pack_hdr, HW_ADDR_LEN);
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    *(u_short *)(&hdr->_spad[0]) = 0;
    *(u_short *)(&hdr->_dpad[0]) = 0;

    /*
     * adjust datalen to account for bytes within the packet header
     * and the unwanted crc bytes at the end of the packet; read
     * data out of the packet into a large mbuf or an mbuf chain.
     */
    datalen -= (PACK_HDR_LEN + CRC_LEN);

#ifdef OldCode
    /*
     * XXX TRACE XXX
     *
     * this could be much more efficient with the new mbuf manager
     */
    for( i = datalen; i > 0; i -= (OLDMLEN - 2) )
    {
	/* allocate another mbuf */
	if( (m->m_next = m_get(M_DONTWAIT, MT_DATA)) == (struct mbuf *)0 )
	{
	    fs = NULL;
	    m_freem(m0);
#ifndef MXPATCH
	    drop_packet(en, i + PACK_HDR_LEN + CRC_LEN);
	    goto dropcrc;
#else
	    goto unwanted;	    
#endif
	}

	m = m->m_next;
	en_io_in(port, mtod(m, u_char *), min(i, OLDMLEN - 2));
	m->m_len = min(i, OLDMLEN - 2);
    }
#else
    {
	struct mbuf *pd;

	/*
	 * XXX
	 *
	 * I am slightly worried by the use of MLEN - 2 in the
	 * old code: I suspect that this was just a case of
	 * someone being conservative (and NOT COMMENTING THEIR
	 * CODE!), without understanding that the data overrun
	 * in the data copiers is already catered for safely in
	 * the fact that all mbufs have an even length.
	 *
	 * The original RISC iX drivers certainly use MLEN without
	 * any trouble.
	 */
	if( (m->m_next = ALLOC(datalen, NULL)) == NULL )
	{
	    fs = NULL;
#ifndef MXPATCH
	    drop_packet(en, datalen + PACK_HDR_LEN + CRC_LEN);
	    goto dropcrc;
#else
	    goto unwanted;	    
#endif
	}

	/*
	 * run down the mbufs, filling them in
	 */

#ifdef MXPATCH

	/* Set a pointer to the start of the packet */
	ptr = (this_packet<<8) + BUFF_HDR_LEN + PACK_HDR_LEN;

        /* Start off the first chunk of the remote DMA.  This DMA ends at this_packet<<8 + 0x80 or less */
	bytes_left = (datalen>(128-BUFF_HDR_LEN-PACK_HDR_LEN)) ? (128-BUFF_HDR_LEN-PACK_HDR_LEN) : datalen;
	nic->rsar0 = ptr & 0xff;
        nic->rsar1 = (ptr>>8) & 0xff;
        nic->rbcr0 = bytes_left;
        nic->rbcr1 = 0;
        nic->command = START_DMA(DMA_READ);
        ptr+=bytes_left;

	for( pd = m->m_next; pd; pd = pd->m_next )
	{
	    int c = 0;

	    pd->m_type = MT_DATA;

            /* LanManFS Data corruption bug is cured here.
            
               The writer of this driver assumes mbufs will always have an even length.  However,
               this is not the case.  When running LanManFS mbuf chains claimed from the mbuf manager
               have been seen to have an odd m_len.  This causes the copy code to screw up since it
               assumes all even copies.
               
               2 cures are availible.  1) Write the copy code to cope with odd length transfers.
               			       2) Re-align the mbufs
               			       
               I have chosen the latter since under normal circumstances it only requires a few
               instructions.
               
               This code, below, ensures aligned mbuf chains.
               
               I would reccomend that this code is also run for non MXPATCH'ed drivers too, but
               that's not been tested so I shant.
            */

redo:
	    /* If this is not the last mbuf and it is of odd length then align it */
	    if ( (pd->m_next!=0) && (pd->m_len&1) )
	    {
	        /* The best way is to extend the mbuf by 1 byte since mbufs are usually aligned so
	           we stand a good chance of succeeding (I do not rely on (MINILEN&1)==0), and it means there is
	           less (theoretical) chance that we will need another ALLOC at the end */
	        if ( ( pd->m_len+pd->m_off+1 ) <= (pd->m_inilen+pd->m_inioff) )
  	            pd->m_len++;
  	        else
  	            pd->m_len--;
	    }
	    
	    /* If is the last mbuf, and we have the wrong number of bytes, then do some adjustment */
	    if ( (pd->m_next==0) && (pd->m_len!=datalen) )
	    {
	        if ( ( datalen+pd->m_off ) <= (pd->m_inilen+pd->m_inioff) )
	        {
  	            pd->m_len = datalen;
  	        }
  	        else
  	        {
  	            /* We need more buffer space */
  	            pd->m_next = ALLOC(datalen-pd->m_len, NULL);
  	            
  	            if ( pd->m_next==0 )
  	            {
  	                /* Drop this last DMA.  Maybe aborting it is better ? I dont like aborting, it's more risky */
  	                for ( ; bytes_left; bytes_left-=2 )
  	                    nulldev (*port);
  	                    
  	                /* Quietly loose this frame */
  	                fs = 0;
  	                break;
  	            }
  	            
		    /* This means this isn't the last mbuf any more, so run round again */  	            
  	            goto redo;
  	        }
	    }

	    /* Loop until this mbuf is done */
	    for ( c=0; c < pd->m_len ; )
	    {
	        /* If this DMA is done, then check it really is done and start a new one */
	        if ( bytes_left==0 )
	        {
	            /* First make sure the previous DMA's finished */
                    if( !(nic->isr & RDC) ) {
	                MICRODELAY(RDC_RECOVER_PERIOD);

	                if( !(nic->isr & RDC) )
	                {
	                    sprintf(en_lastlog, "Unit %d: RDC failure in en_read\n",
		                en->en_unit);
	                    type = 0;
	                    
	                    /* Noone wants this corrupt packet, mbufs will be freed */
	                    fs=0;

	                    goto rdc_failed;
	                }
                    }
                    
		    /* Acknowledge the previous DMA */
                    nic->isr = RDC;

		    /* Catch buffer wrapps */
		    if ( ptr == (en->en_rbd<<8) )
		       ptr = en->en_rbs<<8;

		    /* Start a new DMA.  This DMA MUST end on a page boundary to ensure the wrap catch works */
		    bytes_left = (datalen>128) ? 128 : datalen;
	            nic->rsar0 = ptr & 0xff;
                    nic->rsar1 = (ptr>>8) & 0xff;
                    nic->rbcr0 = bytes_left;
                    nic->rbcr1 = 0;
                    nic->command = START_DMA(DMA_READ);    
                    ptr+=bytes_left;
	        }

		/* DMA as many bytes as we have left, or that fit into the mbuf */
		if ((pd->m_len-c)>bytes_left)
		{
	            en_io_in(port, (mtod(pd, char *)) + c, bytes_left );
	            c += bytes_left;
	            datalen -= bytes_left;
	            bytes_left=0;
	        }
	        else
	        {
	            en_io_in(port, (mtod(pd, char *)) + c, pd->m_len - c);
	            bytes_left -= pd->m_len - c;
	            datalen -= pd->m_len - c;
	            c = pd->m_len;
	            break;
	        }
	    }
	}

#else
	for( pd = m->m_next; pd; pd = pd->m_next )
	{
	    pd->m_type = MT_DATA;
	    en_io_in(port, mtod(pd, char *), pd->m_len);
	    datalen -= pd->m_len;
	}
#endif

	if( datalen != 0 )
	    panic("BAD DATALEN");
	
#ifdef MXPATCH
	if ( bytes_left!=0 )
	    panic("BYTES_LEFT INCORRECT");
#endif
	
    }
#endif

#ifndef MXPATCH
  dropcrc:
#endif  

    /* now read the CRC bytes & drop them on the floor */
#ifndef MXPATCH
    for( i = 0; i < CRC_LEN; i += 2 )
	nulldev(*port);
#endif
    /*
     * check that remote DMA has completed
     */
    if( !(nic->isr & RDC) )
    {
	/*
	 * this is not yet a fatal error - give it
	 * a chance to recover then try again
	 */
	MICRODELAY(RDC_RECOVER_PERIOD);

	if( !(nic->isr & RDC) )
	{
	    sprintf(en_lastlog, "Unit %d: RDC failure in en_read\n",
		    en->en_unit);
	    type = 0;
	    abort_packet(en, nic, buff_hdr);
	    goto notify_protocol;
	}
    }

    /* acknowledge end of remote DMA */
    nic->isr = RDC;

    unwanted:
    rdc_failed:

#ifdef MXPATCH
    i = en->en_nxt_pkt-1;
    if ( i < en->en_rbs )
        i = en->en_rbd-1;
    nic->bnry = i;
#endif    

  notify_protocol:
    if( fs )
	callproto(dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
    else if( m0 )
    {
#ifdef OldCode
	m_freem(m0);
#else
	FREEM(m0);
#endif
    }
}

/**********************************************************************/

/*
 * start_tx - send a transmit packet command to the NIC. MUST be called
 * at splet.
 */
static void start_tx(struct en_softc *en, NICRef nic)
{
    TxqRef txq = en->TxPending;

    /* set up the control registers */
    nic->tpsr = txq->TxStartPage;
    nic->tbcr0 = txq->TxByteCount;
    nic->tbcr1 = txq->TxByteCount >> 8;

    /* start the transmission */
    nic->command = START_DMA(DMA_IDLE) | TXP;
}

/**********************************************************************/

/*
 * startup - bring the NIC back onto a live network following a shutdown
 */
static void startup(struct en_softc *en, NICRef nic, u_char TxPending)
{
    /*
     * follow the recipe given in the NIC datasheets, i.e.
     *
     * take the NIC out of loopback & onto the live network
     */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /*
     * restart transmit if lost by shutdown
     */
    if( (TxPending) && !(nic->isr & (PTX | TXE)) )
	start_tx(en, nic);
}

/**********************************************************************/

/*
 * en_recv - deal with received packet interrupts
 */
void en_recv(struct en_softc *en, NICRef nic)
{
    u_char overflowed = 0;
    u_char current_page, TxPending;

    /*
     * loop until all packets read
     */
    while( (nic->isr & PRX) )
    {
	/*
	 * acknowledge this interrupt, then read where the
	 * start of the free buffer is
	 */
	nic->isr = PRX;
	nic->command = SEL_PAGE(1, NIC_RUNNING);
	current_page = nic->curr;
	nic->command = SEL_PAGE(0, NIC_RUNNING);

	/*
	 * loop until the boundary pointer reaches the start
	 * of the free buffer
	 */
#ifndef MXPATCH	 
	while( nic->bnry != current_page )
#else
	while( en->en_nxt_pkt != current_page )
#endif	
	{
	    /*
	     * check for receive ring overflows
	     */
	    if( (nic->isr & OVW) )
	    {
		++overflowed;
		shutdown(nic, &TxPending);

		/* remove a packet & acknowledge the overflow */
		en_read(en, nic);
		nic->isr = OVW;
	    }
	    else
		/* read next packet */
		en_read(en, nic);
	}
    }

    /* restart reception if necessary */
    if( overflowed )
    {
	startup(en, nic, TxPending);
    }
}

/**********************************************************************/

/*
 * tx_done - remove transmit request from head of queue, start next
 * transmit if required
 */
static void tx_done(struct en_softc *en, NICRef nic)
{
    TxqRef txdesc;

    /* act cautious */
    if( !en->TxPending )
    {
	sprintf(en_lasterr,"Unit %d: packet transmitted from empty queue",
		en->en_unit);
	return;
    }

    /* put this transmit request back into the free list */
    if( en->TxqFree )
    {
	for( txdesc = en->TxqFree; txdesc->TxNext; txdesc = txdesc->TxNext )
	    /* do nothing */
	    ;
	txdesc->TxNext = en->TxPending;
    }
    else
	en->TxqFree = en->TxPending;

    txdesc = en->TxPending->TxNext;
    en->TxPending->TxNext = (TxqRef)NULL;

    /* start next transmit if one there */
    if( (en->TxPending = txdesc) )
	start_tx(en, nic);
}

/**********************************************************************/

/*
 * en_txdone - remove a successfully transmitted packet from the queue,
 * then start next packet if necessary.
 */
void en_txdone(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count of
     * transmitted packets
     */
    nic->isr = PTX;

    /* check for Signal Quality Error if this is appropriate */
    if( (en->en_flags & EN_SQETEST) &&
       !(nic->tsr & COL) && (nic->tsr & CDH) )
    {
	/* one more for the stats. */
	en->en_st_heartbeat_failures++;

	/* do not repeatedly send out this message */
	if( !(en->en_flags & EN_SQEINFORMED) )
	{
	    sprintf(en_lastlog,
		    "Unit %d: CD/Heartbeat failure "
		    "(is the AUI cable connected?)\n",
		    en->en_unit);
	    en->en_flags |= EN_SQEINFORMED;
	}
    }

    /* test for recovered collisions */
    if( nic->tsr & COL )
    {
	u_char n_colls = nic->ncr & 0x0f;

	en->en_st_collisions += n_colls;
	en->en_flags &= ~EN_SQETEST;
    }
    else
	en->en_flags |= EN_SQETEST;

    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_txfailed - `recover' from a transmit error. this means log the
 * failure then forget about the packet it happened on.
 */
static void en_txfailed(struct en_softc *en, NICRef nic)
{
    /*
     * acknowledge the interrupt, then increment the count
     * of Tx errors
     */
    nic->isr = TXE;

    /* check for aborted transmit (excess collisions) */
    if( nic->tsr & ABT )
    {
	en->en_st_excess_collisions++;
	en->en_st_collisions += 16;
    }

    /* check for FIFO underrun */
    if( nic->tsr & FU )
    {
	sprintf(en_lasterr, "Unit %d: FIFO underrun\n",
		en->en_unit);
	/* log this as a general transmit error */
	en->en_st_tx_general_errors++;
    }

    /* now get rid of this transmit request */
    tx_done(en, nic);
}

/**********************************************************************/

/*
 * en_rxfailed - deal with receive errors. this means log them then
 * forget about them.
 */
void en_rxfailed(struct en_softc *en, NICRef nic)
{
    u_char err_count, max_count = 0;
    char status;
    
    status = en->Chip->rsr;

    /*
     * acknowledge both the receive error & counter
     * overflow interrupts, then increment the count
     * of bad receives
     */
    nic->isr = (RXE | CNT);

    /* frame alignment errors */
    err_count = nic->cntr0;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: Frame alignment error", en->en_unit);
    en->en_st_frame_alignment_errors += err_count;
    max_count = max(max_count, err_count);

    /* crc errors */
    err_count = nic->cntr1;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: CRC error", en->en_unit);
    en->en_st_crc_failures += err_count;
    max_count = max(max_count, err_count);

    /* frames lost */
    err_count = nic->cntr2;
    if ( err_count>0 )
        sprintf(en_lastlog,"Unit %d: Dropped frames", en->en_unit);
    en->en_st_dropped_frames += err_count;
    max_count = max(max_count, err_count);

    /*
     * if all these counters returned zero, then assume
     * problem was a fifo overrun. (a bit crude)
     */
    if( max_count == 0 )
    {
	/* log this as a general receive error */
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: receive counters returned no errors",
		en->en_unit);
    }
    
    if ( status & 2 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: CRC check caught a bad packet",
		en->en_unit);
    }
    
    if ( status & 4 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: Misaligned frame detected on net",
		en->en_unit);
    }

    if ( status & 8 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: FIFO overran",
		en->en_unit);
    }

    if ( status & 0x10 )
    {
	en->en_st_rx_general_errors++;
	sprintf(en_lastlog,"Unit %d: Missed packet",
		en->en_unit);
    }
}

/**********************************************************************/

/*
 * en_intr - entry point for ISR, steps are:
 *
 * 1 - handle all received packets
 *
 * 2 - deal with packet transmitted ints.
 *
 * 3 - check for transmit errors
 *
 * 4 - check for receive errors
 *
 * 5 - check for overwrite warning (should not happen - this is tested
 *     for within the receive packet code)
 *
 * 6 - deal with tally counter overflows
 *
 */
static void en_intr(int unit)
{
    register struct en_softc *en = en_softc[unit];
    register NICRef nic = en->Chip;
    u_char TxPending;

    /* loop until all ints cleared */
    while( nic->isr&MY_INTS )
    {
	/* stage 1 - received packets */
	while( nic->isr & PRX )
	    en_recv(en, nic);

	/* stage 2 - transmitted packets */
	while( nic->isr & PTX )
	    en_txdone(en, nic);

	/* stage 3 - transmit errors */
	while( nic->isr & TXE )
	    en_txfailed(en, nic);

	/* stage 4 - receive errors */
	while( nic->isr & RXE )
	    en_rxfailed(en, nic);

	/* stage 5 - overwrite warning */
	while( nic->isr & OVW )
	    if( nic->isr & PRX )
		/* more packets have arrived so read them out */
		en_recv(en, nic);
	    else
	    {
		shutdown(nic, &TxPending);
		nic->isr = OVW;
		startup(en, nic, TxPending);
	    }

	/* stage 6 - tally counter overflow */
	while( nic->isr & CNT )
	    if( nic->isr & RXE )
		/* got more errors */
		en_rxfailed(en, nic);
	    else
	    {
		/* this is also bad news */
		sprintf(en_lastlog,"Count of error registers:\n"
		       "FAE: %x "
		       "CRC: %x "
		       "FRL: %x\n",
		       nic->cntr0, nic->cntr1, nic->cntr2);
		sprintf(en_lasterr,"ei_intr: CNT with no receive errors");
	    }

	/* all over bar the shouting - test for extraneous bits */
	if( nic->isr & RDC )
	    sprintf(en_lasterr,"ei_intr: RDC signalled");

/*  RST bit in MX chip is buggy
	else if( nic->isr & RST )
	    sprintf(en_lasterr,"en_intr: RST signalled");
*/
    }
}

/**********************************************************************/

/*
 * give the Ethernet card a hard reset
 */
static void en_reset_card(int slot)
{
    int easibase;
    volatile int dummy;
    
    if ( (_swix ( 0x4028D, _IN(0)|_IN(1)|_IN(2)|_IN(3), 1<<9, &easibase, 4, slot ))!=0 )
        return;
        
    /* Force stop the controller.  We seem to need this before reset */
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x4)) = 0x21;
    
    /* Writing actaually resets, but this algorithm holds for all circumstances */
    *((unsigned int *)(ENCARD_RESET_PORT(easibase))) = 0xff;
    MICRODELAY ( 50000 );
    *((unsigned int *)(ENCARD_RESET_PORT(easibase))) = 0x00;
    MICRODELAY ( 50000 );
    
    /* Set up config A for irq 0 */
    dummy = *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x54)) = 0x00;
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x54)) = dummy & ~4;
    
    /* Clear the isr */
    *((unsigned int *)(ENCARD_NIC_REGS(easibase)+0x3C)) = 0xff;
}

/*
 * This is a horriblly hacky command, needed
 * due to the lack of a decent podule manager
 */

void en_reset_all ()
{
    int i;
    for( i = 0; i < XCB_SLOTS; i++ )
    {
        if ( en_slots[i] )
            en_reset_card ( en_slots[i] );
    }
}

/**********************************************************************/

void decl_xcb_interrupt(int slot, struct int_hndlr *hndlr, int prior)
{
    _kernel_swi_regs rin, rout;
    static int claimed;

    if( claimed != 0x091067 ) /* Only claim the vector once ! */
    {
	intr_routine = *hndlr;
	rin.r[0] = 2;
	rin.r[1] = (int)en_irq_entry;
	rin.r[2] = (int)module_wsp;

	(void)_kernel_swi(XOS_Bit | OS_Claim, &rin, &rout);
	claimed = 0x091067;
    }
}

/**********************************************************************/

/*
 * stats_init - initialise stats structures
 */
void stats_init(struct en_softc *en)
{
    int i;

    /*
     * actual statistics structure is easy - only one field to set
     */
    en->en_st_interface_type = ST_TYPE_10BASE5N2;

    /*
     * now fill in struct st which describes
     * the stats. this interface supports.
     */
    st.st_interface_type = ~0;
    st.st_link_status = ~0;
    st.st_link_polarity = 0;
    st.st_blank1 = 0;
    st.st_link_failures = 0;
    st.st_network_collisions = 0;
    st.st_collisions = ~0;
    st.st_excess_collisions = ~0;
    st.st_heartbeat_failures = ~0;
    st.st_not_listening = 0;
#if 0
    st.st_net_error = 0;
#endif
    st.st_tx_frames = ~0;
    st.st_tx_bytes = ~0;
    st.st_tx_general_errors = ~0;
    st.st_crc_failures = ~0;
    st.st_frame_alignment_errors = ~0;
    st.st_dropped_frames = ~0;
    st.st_runt_frames = ~0;
    st.st_overlong_frames = ~0;
    st.st_jabbers = 0;
    st.st_late_events = 0;
    st.st_unwanted_frames = ~0;
    st.st_rx_frames = ~0;
    st.st_rx_bytes = ~0;
    st.st_rx_general_errors = ~0;

    for( i = 0; i < 6; ++i )
    {
	st.st_last_dest_addr[i] = 0xff;
	st.st_last_src_addr[i] = 0xff;
    }

    do
    {
	st.st_last_dest_addr[i] = 0;
	st.st_last_src_addr[i] = 0;
	++i;
    } while( ++i < sizeof(st.st_last_dest_addr) );
}

/**********************************************************************/

/*
 * high priority XCB card initialisation - reset the card
 */
static void en_init_high(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/* Dallas chip control */

static void en_dallas_pull_high ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;
    *en->en_dallas = 1;
}

static void en_dallas_pull_low ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;
    *en->en_dallas = 0;
}   

static int en_dallas_read_bus ( struct dallas_physical *dp )
{
    struct en_softc *en = (struct en_softc *)dp->sc;

    return (*en->en_dallas & 2)>>1;
}

static struct dallas_physical en_dp = {
    en_dallas_pull_high,
    en_dallas_pull_low,
    en_dallas_read_bus,
    (void *)0
};

/**********************************************************************/

/*
 * low priority XCB card initialisation - first round with ints off
 * allocates memory for control structures; second round declares the driver
 * to the network interface code.
 */
static void en_init_low(int slot, int irqs_on)
{
    if( !irqs_on )
    {
	static int enunits;
	struct en_softc *en;
	int unit = enunits++;
	int i;
	int easibase;
	char *flash_constants;
	
        /* Lookup easibase.  I dont see xcb.h supporting this.  This is only in RiscOS 3.5 and up */
        if ( (_swix ( 0x4028D, _IN(0)|_IN(1)|_IN(2)|_IN(3), 1<<9, &easibase, 4, slot ))!=0 )
            return;

        /* Set accesses to cycle type A.  Should this really be done here ? */
        if ( (_swix ( Podule_SetSpeed, _IN(0)|_IN(3), 1, slot ))!=0 )
            return;

	/* record which logical slot this is */
	slotmap[slot] = unit;

	/*
	 * check for too many Ethernet (version I or II) cards.
	 */
	if (!xcb_add_ethernet_card (enunits, slot))
	    return;

	/* get some memory for the control structure */
	en = (struct en_softc *)malloc(sizeof(*en));
	memset((char *)en, 0, sizeof(struct en_softc));
	en_softc[unit] = en;

	/* initialise the en_softc structure */
	en->en_unit = unit;
	en->en_slot = slot;
	en->en_flags = 0;
	en->Chip = (NICRef)ENCARD_NIC_REGS(easibase);
	en->dma_port = (u_int *)ENCARD_REMOTE_DMA(easibase);
	en->en_dallas   = (char *)ENCARD_DALLAS(easibase);
	
	/*
	 * initialise stats structures
	 */
	stats_init(en);

	for( i = 0; i < MAXTXQ; ++i )
	{
	    en->TxqPool[i].TxNext = (i < (MAXTXQ - 1)) ?
				     &(en->TxqPool[(i + 1)]) : (TxqRef)NULL;
	    en->TxqPool[i].TxStartPage = (i * PAGES_PER_TX) + TX_START;
	}
	en->TxqFree = en->TxqPool;
	en->TxPending = (TxqRef)NULL;

	/* Flash constants are in the top sector (16k) of the 128k flash */
	flash_constants = (char *)easibase + (((128-16)*1024)<<2);

	/* See if RiscOS will supply us with an ethernet address */
	if ( (_swix ( Podule_ReadInfo, _IN(0)|_IN(1)|_IN(2)|_IN(3), (1<<27)|(1<<28), en->en_addr, 8, slot )) == 0 )
	{
	    /* We got an address from the Podule Manager, we must byte swap it now */
	    en->en_addr[6] = en->en_addr[0];
	    en->en_addr[0] = en->en_addr[5];
	    en->en_addr[5] = en->en_addr[6];
	    en->en_addr[6] = en->en_addr[1];
	    en->en_addr[1] = en->en_addr[4];
	    en->en_addr[4] = en->en_addr[6];
	    en->en_addr[6] = en->en_addr[2];
	    en->en_addr[2] = en->en_addr[3];
	    en->en_addr[3] = en->en_addr[6];
	}
	else
	{
	    int dallas_retries;
	    int myid;
	    unsigned int myetheraddr;

	    /* Set this dallas descriptor to point to my sc */
	    en_dp.sc = (void *)en;

    	    for ( i=0; i<6; i++ )
    	        en->en_addr[i]=0;

	    for ( dallas_retries = 0; dallas_retries<6; dallas_retries++ )
	    {
	        /* Read the id in */
	        if ( dallas_id_read ( &en_dp, &en->dallas_id ) )
	        {
	            continue;
	        }
	        else
	        {
	            /* Check the dallas is of the right family */
	            if ( en->dallas_id.d_family_code!=0x81 )
	                continue;

		    /* Get the acorn id part and check it */
		    myid = (*(int *)&en->dallas_id.d_id[3]) & 0xffffff;

		    if ( myid != 0x0050a4 )
		        continue;

		    /* I'm not to keen on this code, but it was supplied this way by acorn */
		    myid = (*(int *)(&en->dallas_id.d_family_code));
		    myid = myid>>8;
		    myetheraddr = 0xa4100000;
		    myetheraddr += myid;
		    if ( myetheraddr & (1<<23) )
		        continue;
		    if ( ( myetheraddr>>24 ) != 0xa4 )
		        continue;
		        
		    /* Write it in then */
		    en->en_addr[0] = 0x00;
		    en->en_addr[1] = 0x00;
		    en->en_addr[2] = (myetheraddr>>24)&0xff;
		    en->en_addr[3] = (myetheraddr>>16)&0xff;
		    en->en_addr[4] = (myetheraddr>>8)&0xff;
		    en->en_addr[5] = (myetheraddr>>0)&0xff;
		    break;
	        }
	    }
	    
	    /* Validate the dallas */
    	    for ( i=0; i<6; i++ )
    	    {
    	        if ((en->en_addr[i]!=0)&&(en->en_addr[i]!=0xff))
    	            break;
    	    }
    	    
    	    if ( i==6 )
    	    {
	    
	        /* If not the get them from the flash constants */
    	        for ( i=0; i<6; i++ )
	            en->en_addr[i] = flash_constants[i<<2];
	            
	        /* Validate the flash constants */
    	        for ( i=0; i<6; i++ )
    	        {
    	            if ((en->en_addr[i]!=0)&&(en->en_addr[i]!=0xff))
    	                break;
    	        }
    	        
    	        if ( i==6 )
    	        {
    	            sprintf ( en_lasterr, "Ethernet address missing %d\n", slot );
    	            en->en_flags |= EN_FAULTY;
    	        }
    	    }
	}

	/* declare the ISR to the XCB manager */
	en->en_handler.ih_fn = en_intr;
	en->en_handler.ih_farg = unit;
	decl_xcb_interrupt(slot, &(en->en_handler), PRIO_ET);

	/* declare the interrupt sense for old-fashioned machines */
	en->en_sense.flag = (int *)&en->Chip->isr;
	en->en_int_status = (int *)&en->Chip->isr;
	en->en_sense.mask = EN_INTR_MASK;
    }
    else
    {
	int unit = slotmap[slot];
	struct en_softc *en;

	if( unit >= 8 )
	    return;
	else
	    en = en_softc[unit];

	/* run the diagnostics */
	(void)en_post(en, 0);
    }
}

/**********************************************************************/

/*
 * XCB shutdown entry point - reset the card
 */
static void en_shutdown(int slot)
{
    en_reset_card(slot);
}

/**********************************************************************/

/*
 * run power on self test for a card
 */
static int en_post(struct en_softc *en, int loopback_only)
{
    int retc;

    if( (en->en_flags & EN_FAULTY) )
	/* do not run the tests */
	return(0);

    /* run the diagnostic tests */
    if( !(retc = en_run_diags(en, loopback_only)) &&
       !(en->en_flags & EN_RECOVERABLE_ERROR) )
	en->en_flags |= EN_FAULTY;

    /* pass the results to the statistics tests */
    if( (en->en_flags & (EN_FAULTY | EN_RECOVERABLE_ERROR)) )
	en->en_st_link_status = 0;
    else
	en->en_st_link_status |= ST_STATUS_OK;

    /* put the reset back on & return status */
    en_reset_card ( en->en_slot );
    
    return(retc);
}

/**********************************************************************/

/*
 * configure the NIC for diagnostic tests
 */
static void en_setup_diags(struct en_softc *en, NICRef nic,
			   u_char loop_mode, u_char manual_crc)
{
    int i;

    /*
     * must ensure the NIC is stopped - the act of starting
     * initialises its internal FIFO pointers. must also clear any
     * previous loopback mode - can only enter a loopback mode from
     * normal operation
     */
    nic->tcr = LOOP_MODE(LIVE_NET);
    if( (nic->isr & RST) )
	/* clear any outstanding reset signal */
	nic->isr = RST;
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    for( i = 0; i < STP_TIMEO; ++i )
    {
	if( (nic->isr & RST) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == STP_TIMEO )
    {
	sprintf(en_lasterr, "Unit %d: NIC has not reset\n",
	    slotmap[en->en_slot]);
	return;
    }

    /*
     * now set tcr to required loopback mode and
     * CRC type, then clear interrupts & mask
     * them all out
     */
    nic->tcr = LOOP_MODE(loop_mode) | manual_crc;
    nic->isr = 0xff;
    nic->imr = 0;

    /*
     * set up data configuration register
     */
    nic->dcr = WTS | FIFO_THRESH(WORD_THRESH4);

    /*
     * set parameters on page 1 - MAC address
     */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * bring the NIC back to page 0, alive & kicking
     */
    nic->command = SEL_PAGE(0, NIC_RUNNING);
}

/**********************************************************************/

/*
 * calculate the Autodin II CRC for the passed data
 */
static u_char *calc_crc(u_char *data, int datalen)
{
    u_long crc, swap = 0;
    int i, j;
    static u_char retc[sizeof(crc)];

    crc = ~0;
    for( i = 0; i < datalen; ++i )
    {
	u_char next = *data++;
	for( j = 0; j < NBBY; ++j )
	{
	    if( (next & 1) ^ (crc >> 31) )
		crc = (crc << 1) ^ POLYNOMIAL;
	    else
		crc <<= 1;
	    next >>= 1;
	}
    }

    /* reverse, nibble swap & complement the result */
    for( i = 0; i < (NBBY * sizeof(crc)); ++i )
    {
	swap <<= 1;
	swap |= ((crc & 0x01) ? 1 : 0);
	crc >>= 1;
    }

    for( i = 0; i < sizeof(crc); ++i)
    {
	retc[i] = ~(swap & 0xff);
	swap >>= NBBY;
    }
    return(retc);
}

/**********************************************************************/

/*
 * build a loopback test packet - this is currently all zeros, plus an
 * appropriate CRC
 */
static void build_tpkt(struct en_softc *en, TestPacket *test_pack)
{
    int i;
    u_char *cptr;

    /*
     * check size of TestPacket to make sure no padding is present
     */
    if( sizeof(TestPacket) != (TESTP_LEN + CRC_LEN) )
	panic("ei: bad size for TestPacket\n");

    /*
     * build a packet full of zeroes then fill in the source
     * and destination address
     */
    memset ((caddr_t)test_pack, 0, TESTP_LEN);
    memcpy ((caddr_t)test_pack->src_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);
    memcpy ((caddr_t)test_pack->dst_addr, (caddr_t)en->en_addr, HW_ADDR_LEN);

    /*
     * calculate & fill in the packet's CRC
     */
    for( i = 0, cptr = calc_crc((u_char *)test_pack, TESTP_LEN);
	i < CRC_LEN; ++i, ++cptr)
	test_pack->crc_bytes[i] = *cptr;
}

/**********************************************************************/

/*
 * run loopback tests in given loopback mode. manual_crc is the CRC
 * source used to program tcr (0 if NIC is to generate CRC, !0 if
 * CRC not appended after transmit). routine returns 0 if test failed,
 * else !0
 */
static int en_loopback(struct en_softc *en, TestPacket *test_pack,
		       u_char loop_mode, u_char manual_crc)
{
    NICRef nic = en->Chip;
    int i, pack_len;

    return 1;

    /*
     * set up the NIC, then start the transmit
     */
    en_setup_diags(en, nic, loop_mode, manual_crc);
    pack_len = TESTP_LEN + ((manual_crc) ? CRC_LEN : 0);
    nic->tpsr = 0;
    nic->tbcr0 = pack_len << 1;
    nic->tbcr1 = pack_len >> 7;
    nic->command = START_DMA(DMA_IDLE) | TXP;

    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->isr & (PTX | TXE)) )
	    /* packet has gone out */
	    break;

	MICRODELAY(1000000 / HZ);

    }

    if( (loop_mode == LOOPBACK3) && (nic->isr == TXE || i == LB_TIMEO) )
	return(lb3_failed(en, nic));
    else if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) transmit timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * now wait for the receive to come in
     */
    for(i = 0; i < LB_TIMEO; ++i)
    {
	if( (nic->rsr & (PRX | CRCE | FAE)) )
	    break;

	MICRODELAY(1000000 / HZ);
    }

    if( i == LB_TIMEO )
    {
	/* timed_out */
	sprintf(en_lasterr, "Unit %d: loopback(%d, %d) receive timed out\n",
	    slotmap[en->en_slot], loop_mode, manual_crc);
	return(0);
    }

    /*
     * check the result from the test
     */
    if( manual_crc )
    {
	if( (nic->isr & RXE) )
	{
	    sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC recognition\n",
		slotmap[en->en_slot], loop_mode, manual_crc);
	    return(0);
	}
    }
    else if( loop_mode != LOOPBACK3 )
    {
	u_char nic_crc, *ok_crc;

	/*
	 * junk unwanted data from the FIFO
	 */
	for( i = 0; i < N_JUNK; ++i )
	    nulldev(nic->fifo);

	/*
	 * now read the CRC back & check it against what is expected
	 */
	for(i = 0, ok_crc = test_pack->crc_bytes;
	    i < CRC_LEN; ++i, ++ok_crc )
	    if( (nic_crc = nic->fifo) != *ok_crc )
	    {
		sprintf(en_lasterr, "Unit %d: loopback(%d, %d) bad CRC (%x != %x)\n",
		    slotmap[en->en_slot], loop_mode, manual_crc,
		    nic_crc, *ok_crc);
		return(0);
	    }
    }

    /* tests passed successfully */
    return(1);
}

/**********************************************************************/

/*
 * en_run_diags - run a set of internal diagnostics. return 0 if
 * something failed, else 1.
 */
static int en_run_diags(struct en_softc *en, int loopback_only)
{
    register int i;
    NICRef nic = en->Chip;
    TestPacket lback_data;
    u_char *dptr = (u_char *)(&lback_data);
    static int lb_sequence[] = { LOOPBACK3 };

    if( !loopback_only )
    {
	u_int pattern[PAT_LEN];

	/* build the test pattern */
	for( i = 0; i < (PAT_MID - 1); ++i)
	{
	    pattern[i] = O(i);
	    pattern[i + PAT_MID] = Z(i);
	}
	pattern[PAT_MID - 1] = 0;
	pattern[PAT_LEN - 1] = 0xffff;

	/* configure the NIC in an appropriate mode */
	en_setup_diags(en, en->Chip, LOOPBACK1, 0);

	/* run the test for all pages */
	for( i = NIC_BUFFER_START; i < (NIC_BUFFER / NIC_PAGE); ++i )
	    if( !en_memtest(en, i, pattern) )
		return(0);
    }

    /*
     * run loopback tests - make sure the NIC is in some
     * sensible state, build the test packet & copy it
     * into on-card RAM
     */
    en_setup_diags(en, en->Chip, LOOPBACK1, 0);
    build_tpkt(en, &lback_data);

    nic->rbcr0 = ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    /*
     * the NIC is loaded using word wide transfers, but can only
     * read byte wide for loopback testing. Therefore need to
     * write each byte from the packet into a word of memory.
     */
    nic->rsar0 = nic->rsar1 = 0;
    nic->rbcr0 = sizeof(TestPacket) << 1;
    nic->rbcr1 = sizeof(TestPacket) >> 7;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0; i < sizeof(TestPacket); ++i, ++dptr )
	*en->dma_port = (*dptr << 16) | (*dptr << 24);

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote DMA failure\n",
	    slotmap[en->en_slot]);
	return(0);
    }
    else
	/* acknowledge the DMA completion */
	nic->isr = RDC;

    /* I dont set the recoverable error bit for the cable check so that the network */
    /* stuff can initialise properly without incident.  The user can plug the cable */
    /* in later */
    check_cable(en);

    en->en_flags &= ~EN_RECOVERABLE_ERROR;

    for( i = 0; i < (sizeof(lb_sequence) / sizeof(lb_sequence[0])); ++i )
    {
	register u_int mode = lb_sequence[i];

	if( !en_loopback(en, &lback_data, mode, 0) )
	    return(0);

	if( !en_loopback(en, &lback_data, mode, 1) )
	    return(0);
    }

    /*
     * all tests passed - return OK status
     */
    return(1);
}

/**********************************************************************/

/*
 * run a memory test on the given page
 */
static int en_memtest(struct en_softc *en, int page, u_int *pattern)
{
    NICRef nic = en->Chip;
    int i, j;
    u_int nextword;

    /*
     * write the pattern into RAM
     */
    nic->rbcr0 = ~0;
    nic->command = START_DMA(DMA_READ);

    MICRODELAY(1);
    nic->command = START_DMA(DMA_ABORT);

    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = NIC_PAGE;
    nic->rbcr1 = NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_WRITE);
    for( i = 0, j = 0; i < (NIC_PAGE >> 1); ++i )
    {
	*en->dma_port = (pattern[j] << 16);
	if( ++j == PAT_LEN )
	    j = 0;
    }

    if( !(nic->isr & RDC) )
    {
	sprintf(en_lasterr, "Unit %d: remote write has not completed\n",
	    slotmap[en->en_slot]);
	return(0);
    }
    else
	nic->isr = RDC;

    /* now do the read & check */
    *en->page_reg = ((HARD_RESET_OFF | IO_READ) << 16);
    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = NIC_PAGE;
    nic->rbcr1 = NIC_PAGE >> 8;
    nic->command = START_DMA(DMA_READ);
    for( i = 0, j = 0; i < (NIC_PAGE >> 1); ++i )
    {
	if( (nextword = (*en->dma_port & 0xffff)) != pattern[j] )
	{
	    sprintf(en_lasterr,
		"Unit %d (slot %d): RAM failure page %d, word %d (%x != %x)\n",
		slotmap[en->en_slot], en->en_slot, page,
		i, nextword, pattern[j]);
	    return(0);
	}

	if( ++j == PAT_LEN )
	    j = 0;
    }

    /* finished OK */
    return(1);
}

/**********************************************************************/

/*
 * see what has gone wrong with mode 3 loopback (onto live net,
 * therefore susceptible to genuine collisions)
 */
static int lb3_failed(struct en_softc *en, NICRef nic)
{
    u_char txstat = nic->tsr;
    int unit = slotmap[en->en_slot];

    if( !(txstat & COL) )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (no COL)\n",
	    unit);
	return(0);
    }
    else if( (txstat & ABT) )
    {
	sprintf(en_lasterr, "Unit %d: bad termination\n",
	    unit);
	return(0);
    }
    else if( nic->ncr == 0 )
    {
	sprintf(en_lasterr, "Unit %d: CTI failure (COL with 0 collisions)\n",
	    unit);
	return(0);
    }
    else
    {
	return(1);
    }
}

/**********************************************************************/

/*
 * attempt to send test packet out in non-loopback mode, use
 * transmit status to work out whether or not the cabling is OK
 *
 * MTR I've overrided this whole routine to do a cable check on
 * the TP connector.  If we ever do a BNC card, we should alter
 * this routine accordingly
 */
static int check_cable(struct en_softc *en)
{
    NICRef nic = en->Chip;
    int unit = slotmap[en->en_slot];

    int cb;
    
    /* Enable the link test */
    cb = nic->configb;
    cb &= ~7;
    nic->configb = cb;
    
    /* Delay for a bit, to be sure */
    MICRODELAY (1000);
    
    /* Check the link */
    if ( en->Chip->configb & 4 )
    {
        return 1;
    }         
    else
    {
        sprintf ( en_lasterr, "Cable is not connected at unit %d\n", unit );
        return 0;
    }
}

/**********************************************************************/

/*
 * en_setup - initialise the NIC, but do not bring it up onto the network.
 * returns <> 0 if all OK, 0 if hardware determined to be faulty.
 */
static int en_setup(int unit)
{
    struct en_softc *en = en_softc[unit];
    NICRef nic = en->Chip;

    /* test for faulty hardware already detected */
    if( en->en_flags & EN_FAULTY )
	return(0);

    /* bring the card out of reset */

    /* wait for a bit 'till reset trickles through */
    MICRODELAY(25);

    /* initialise the command register */
    nic->command = CMD_INIT_VALUE;

    /*
     * set up the Data Configuration Register:
     *
     * 16-bit data transfers,
     * normal operation,
     * auto-initialise remote,
     * fifo threshold of 4 words.
     */
    nic->dcr = DCR_INIT_VALUE | FIFO_THRESH(WORD_THRESH4);

    /* clear remote byte count registers */
    nic->rbcr0 = nic->rbcr1 = 0;

    /*
     * set up the Receive Configuration Register:
     *
     * accept broadcast packets
     */
    nic->rcr = RCR_INIT_VALUE;

    /* put the NIC into loopback mode */
    nic->tcr = TCR_INIT_VALUE | LOOP_MODE(LOOPBACK1);

    /* set up the receive buffer ring */
    en->en_rbs = nic->bnry = nic->pstart = RX_START;
    en->en_rbd = nic->pstop = RX_END;

    /*
     * clear all bits in the ISR, then set up the IMR
     *
     * interrupts required:
     *
     * packet received,
     * packet transmitted,
     * receive error,
     * transmit error,
     * overwrite warning,
     * counter overflow.
     *
     * NOTE: write clear value to ISR twice to ensure all ints cleared
     */
    nic->isr = 0xff;
    nic->isr = 0xff;
    nic->imr = IMR_INIT_VALUE;

    /* select page 1 & set physical address */
    nic->command = SEL_PAGE(1, NIC_STOPPED);
    nic->par0 = en->en_addr[0];
    nic->par1 = en->en_addr[1];
    nic->par2 = en->en_addr[2];
    nic->par3 = en->en_addr[3];
    nic->par4 = en->en_addr[4];
    nic->par5 = en->en_addr[5];

    /*
     * multicast filters: pass all multicast
     * packets (when AM bit is set in rcr)
     */
    nic->mar0 = nic->mar1 = nic->mar2 = nic->mar3 = 0xff;
    nic->mar4 = nic->mar5 = nic->mar6 = nic->mar7 = 0xff;

    /* set the current page register for remote DMA */
#ifndef MXPATCH
    nic->curr = RX_START;
#else
    en->en_nxt_pkt = nic->curr = RX_START + 1;
#endif

    /* put the NIC back to page 0 */
    nic->command = SEL_PAGE(0, NIC_STOPPED);

    /* all done OK */
    return(1);
}

/**********************************************************************/

/*
 * en_forcepost - set the EN_RECOVERABLE_ERROR flag; this will force
 * a power-on self-test when en_bringup() is called.
 */
void en_forcepost(int unit)
{
    en_softc[unit]->en_flags |= EN_FORCEPOST;
}

/**********************************************************************/

void en_runtest(int unit)
{
    struct en_softc *en = en_softc[unit];

    /*
     * only bother if the card is not already diagnosed as faulty
     */
    if( !(en->en_flags & EN_FAULTY) )
    {
	/*
	 * pretend driver is disappearing while tests are performed
	 */
	send_driverstatus(dibs[unit], 1);

	/*
	 * driver will no longer be running after POST
	 */
	en->en_flags &= ~EN_RUNNING;

	(void)en_post(en, 1);

	/*
	 * XXX
	 *
	 * we're back!  the pretence that the driver has
	 * disappeared while the tests were being run will
	 * have confused the protocol modules which, when
	 * they receive the `startup' service call will
	 * try to reclaim the filters they already hold.
	 */
	en->en_flags |= EN_DUPCLAIMEXPECTED;
	send_driverstatus(dibs[unit], 0);

	/*
	 * if protocol modules have not reclaimed yet, then
	 * they have lost the chance to do so
	 */
	en->en_flags &= ~EN_DUPCLAIMEXPECTED;
    }

    /*
     * analyse and print results
     */
    if( (en->en_flags & (EN_FAULTY | EN_RECOVERABLE_ERROR)) )
    {
	printf("TESTS FAILED %s\n", en_lasterr);
    }
    else
    {
	printf("TESTS PASSED\n");
    }
}

/**********************************************************************/

/*
 * en_bringup - bring the card up live onto the network - returns 0
 * if all OK, else errno.
 */
static int en_bringup(int unit)
{
    register struct en_softc *en = en_softc[unit];
    int s;
    int cb;

    /* do not do this if already running */
    if( en->en_flags & EN_RUNNING )
    {
	return(0);
    }

    /*
     * check to see that card passed diagnostic tests
     */
    if( (en->en_flags & (EN_RECOVERABLE_ERROR | EN_FORCEPOST)) )
    {
	/* POST detected no network - try again */
	if( !en_post(en, 1) )
	    /*
	     * do not bring this network up - unit is either
	     * faulty or still has a recoverable error
	     */
	    return((en->en_flags & EN_FAULTY) ? ENXIO : ETIMEDOUT);
    }

    if( !en_setup(unit) )
	/*
	 * unit is faulty
	 */
	return(ENXIO);

    s = splet();

    /* Select TP */
    cb = en->Chip->configb;
    cb &= ~7;
    en->Chip->configb = cb;

    /* set the NIC running, take it out of loopback mode */
    en->Chip->command = SEL_PAGE(0, NIC_RUNNING);
    en->Chip->tcr = TCR_INIT_VALUE | LOOP_MODE(LIVE_NET);

    /* mark this interface as active */
    en->en_flags |= EN_RUNNING;

    /* all done */
    splx(s);
    return(0);
}

/**********************************************************************/

en_init(void)
{
    int i;
    u_char buffer[16];
    _kernel_oserror *e;
    _kernel_swi_regs rin,rout;
    int s;
    int id;
    
    s = splet();
    for( i = 0; i < XCB_SLOTS; ++i )
    {
	en_slots[i] = 0;
	slotmap[i] = -1;

	rin.r[3] = i;
	if( (e =_kernel_swi(XOS_Bit | Podule_ReadID, &rin, &rout)) == NULL )
	{
	    rin.r[2] = (int)buffer;
	    rin.r[3] = i;
	    e =_kernel_swi(XOS_Bit | Podule_ReadHeader, &rin, &rout);

	    id = buffer[3] | (buffer[4]<<8) | (buffer[5]<<16) | (buffer[6]<<24);

	    if( (id) == EN_TYPE )
	    {
		en_slots[i] = (++encnt);
		en_init_high(i);
	    }
	}
    }

    if( encnt == 0 )
    {
	splx(s);
	return;
    }

    for( i = 0; i < XCB_SLOTS; ++i )
	if( en_slots[i] )
	    en_init_low (i, 0);

    splx(s);

    for( i = 0; i < XCB_SLOTS; i++ )
	if( en_slots[i] )
	    en_init_low (i, 1);

    rin.r[0] = (int)"Inet$EnCount";
    rin.r[1] = (int)&encnt;
    rin.r[2] = 4;
    rin.r[3] = 0;
    rin.r[4] = 1;
    _kernel_swi(XOS_Bit | OS_SetVarVal, &rin, &rout);

    rin.r[0] = (int)"Inet$EtherType";
    rin.r[1] = (int)"ei0";
    rin.r[2] = 3;
    rin.r[3] = 0;
    rin.r[4] = 0;
    _kernel_swi(XOS_Bit | OS_SetVarVal, &rin, &rout);
}

/**********************************************************************/

int en_transmit(_kernel_swi_regs *r)
{
    u_int flags = r->r[0];
    u_int unit = r->r[1];
    u_int type = r->r[2];
    struct mbuf *m, *m0 = (struct mbuf *)(r->r[3]);
    char *edst = (char *)(r->r[4]);
    char *esrc = (flags & TX_FAKESOURCE) ? (char *)r->r[5] : 0;
    struct en_softc *en = en_softc[unit];
    int error = 0;
    int s = splet();

#ifdef DEBUG
    Printf("ei_transmit: flags %d unit %d type %x m0 %x\n",
	   r->r[0], r->r[1], r->r[2], r->r[3]);
#endif

    if( flags >= TX_1STRESERVED )
	error = EINVAL;
    else if( !(en->en_flags & EN_RUNNING) )
	error = ENETDOWN;

    /*
     * XXX
     *
     * copy dest address into stats. structure - this is
     * very hacky, but we need to be as quick as possible
     *
     * this is not ideal, as recording the stats. here means
     * we don't hold the destination of the last packet transmitted,
     * merely that of the last packet a transmission request was
     * received for.
     */
    *(u_int *)(en->en_st_last_dest_addr) = *(u_int *)(r->r[4]);
    *(u_short *)(en->en_st_last_dest_addr + 4) = *(u_short *)(r->r[4] + 4);

    /*
     * run down the supplied mbuf list, transmitting each
     * chain, until an error is flagged.  all mbuf chains
     * not transmitted before an error condition arises
     * are silently dropped
     */
    while( m0 )
    {
	m = m0;
	m0 = m0->m_list;

	if( !error )
	    error = tx_mbufs(en, m, edst, type, esrc);

	if( !(flags & TX_PROTOSDATA) )
	{
#ifdef OldCode
	    m_freem(m);
#else
	    FREEM(m);
#endif
	}
    }

    /*
     * all done
     */
    splx(s);

    return (error);
}

/**********************************************************************/

int en_irq_handler(_kernel_swi_regs *r, void *pw)
{
    int i;
    
    for( i = 0; i < XCB_SLOTS; i++ )
    {
	if( (en_slots[i]) && ((*en_softc[slotmap[i]]->en_int_status)&MY_INTS) )
	{
	    set_irqsareoff();
	    en_intr(slotmap[i]);
	    clear_irqsareoff();
	    return (0);
	}
    }
    return (1);
}

/**********************************************************************/

void en_final(void)
{
    _kernel_oserror *e;
    _kernel_swi_regs rin, rout;
    int i;

    for( i = 0; i < XCB_SLOTS; i++ )
    {
	if (en_slots[i])
	    en_shutdown (i);
    }

    rin.r[0] = 2;
    rin.r[1] = (int) en_irq_entry;
    rin.r[2] = (int) module_wsp;
    e = _kernel_swi(XOS_Bit | OS_Release, &rin, &rout);
}

/**********************************************************************/

u_char *en_addresses(int unit)
{
    struct en_softc *en = en_softc[unit];

    return((u_char *)en->en_addr);
}

/**********************************************************************/

prenstats(int flag)
{
    struct en_softc *en;
    int i, unit;
    int enfound = 0;
    int filters_active;

    for( unit = 0; unit < encnt; ++unit)
    {
	int slot;

	en = en_softc[unit];
	filters_active = 0;
	
#ifdef TXBUF_PROFILE
	printf ( "DEBUG %d\n", max_txbuf );
#endif
	if ( (en->en_addr[0]==0)&&(en->en_addr[1]==0)&&(en->en_addr[2]==0)&&
	     (en->en_addr[3]==0)&&(en->en_addr[4]==0)&&(en->en_addr[5]==0) )
	{
	    printf ( "ei%d 16-bit transfers COMPUTER COULD NOT SUPPLY AN ETHERNET ADDRESS\n" );
	}
	else
	{
	    printf ( "ei%d 16-bit transfers Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\n",
		unit, en->en_addr[0]&0xff, en->en_addr[1]&0xff, en->en_addr[2]&0xff, 
		      en->en_addr[3]&0xff, en->en_addr[4]&0xff, en->en_addr[5]&0xff );
	}

	for( slot = 0; slot < XCB_SLOTS; ++slot )
	    if( slotmap[slot] == i )
		break;

	printf ( "     oframes %10ld : oerrors %10ld : usage %10ld\n",
	 		en->en_stats.st_tx_frames,
	        	en->en_stats.st_tx_general_errors,
	        	en->en_stats.st_tx_bytes );

	printf ( "     iframes %10ld : ierrors %10ld : usage %10ld\n",
	        	en->en_stats.st_rx_frames,
	        	en->en_stats.st_rx_general_errors,
	        	en->en_stats.st_rx_bytes );
	        	
	printf ( "     frames claimed " );

	if( ieeefilter[unit] )
	    printf ( "IEEE " );

	if( e2monitor[unit] )
	    printf ( "Monitor " );

	if( e2sink[unit] )
	    printf ( "Sink " );

	if( e2specific[unit] )
	{
	    FilterChainRef fc = e2specific[unit];

	    ++filters_active;

	    while( fc )
	    {
		printf ( "%04x ", fc->fc_type );
		fc = fc->fc_next;
	    }
	}

        printf ( "\n" );

	printf ( "     link 10BaseT\n" );
    }

    if( en_lasterr[0] )
    {
        printf("     last error %s\n", en_lasterr);
        en_lasterr[0] = '\0';
    }

    if( en_lastlog[0] )
    {
        printf("     last log %s\n", en_lastlog);
        en_lastlog[0] = '\0';
    }
    
    return(enfound);
}

/**********************************************************************/

int xcb_add_ethernet_card(int unit, int slot)
{
    return( unit > 8 ? 0 : 1 );
}

/**********************************************************************/

/*
 * set_receive_level - either turn the hardware for the unit off
 * (if addrlevel = -1), or enable appropriate levels of packet
 * reception
 */
void set_receive_level(int unit, int addrlevel)
{
    struct en_softc *en = en_softc[unit];

    en->en_st_link_status &= ~(ST_STATUS_RXMASK);

    if( addrlevel == -1 )
    {
	/*
	 * take the hardware down
	 */
	enioctl(unit, 1, 0);

	en->en_st_link_status &= ~ST_STATUS_ACTIVE;
    }
    else
    {
	u_char rcrbits = RCR_INIT_VALUE;
	u_char status = ST_STATUS_DIRECT;

	if( addrlevel >= ADDRLVL_NORMAL )
	{
	    /* broadcasts are OK */
	    rcrbits |= AB;

	    status = ST_STATUS_BROADCAST;
	}

	if( addrlevel >= ADDRLVL_MULTICAST )
	{
	    /* multicasts are OK */
	    rcrbits |= AM;

	    status = ST_STATUS_MULTICAST;
	}

	if( addrlevel >= ADDRLVL_PROMISCUOUS )
	{
	    rcrbits |= PRO;

	    status = ST_STATUS_PROMISCUOUS;
	}

#ifdef DEBUG
	Printf("\021\06set_receive_level: rcr = %x (addrlevel = %x)\021\07\n",
	       rcrbits, addrlevel);
#endif

	/*
	 * update the recieve control register on the chip
	 */
	en->Chip->rcr = rcrbits;

	en->en_st_link_status |= (status | ST_STATUS_ACTIVE);
    }
}

/**********************************************************************/

int en_stats(_kernel_swi_regs *r)
{
    struct stats *sptr;

    switch( r->r[0] )
    {
      case 0:
	sptr = &st;
	break;

      case 1:
	sptr = &(en_softc[r->r[1]]->en_stats);
	break;

      default:
	return(EINVAL);
    }

    (void)memcpy((char *)(r->r[2]), (char *)sptr, sizeof(*sptr));
    return(0);
}

/**********************************************************************/

int enioctl(int unit, int cmd, int flag)
{
    register struct en_softc *en;
    int s, error = 0;

    if (unit < 0 || unit > 4)
	return (1);
    en = en_softc[unit];
    switch(cmd)
    {
      case 0:
	if( en->en_flags & EN_FAULTY )
	    return (1);
	error = en_bringup(unit);
	break;

      case 1:

	s = splet();

	/*
	 * log a message on next CD/Heartbeat error
	 */
	en->en_flags &= ~EN_SQEINFORMED;
	en->en_flags |= EN_SQETEST;

	if( (en->en_flags & EN_FAULTY) )
	{
	    en_reset_card(en->en_slot);
	    break;
	}

	if( flag == 0 && (en->en_flags & EN_RUNNING) )
	{
	    /* take the card down */
	    en_reset_card(en->en_slot);
	    en->en_flags &= ~EN_RUNNING;
	}
	else if( flag && !(en->en_flags & EN_RUNNING) )
	    error = en_bringup(unit);

	splx(s);
	break;

      default:
	break;
    }

    /* that's all */
    return(error);
}

/**********************************************************************/

#ifndef MXPATCH

static int load_packet(u_char *hw_dst, u_char *hw_src, u_short type,
			struct mbuf *m0, volatile u_int *port, int datalen, int page, NICRef nic )
{
    u_int bytebuf = 0;

    nic->rsar0 = 0;
    nic->rsar1 = page;
    nic->rbcr0 = datalen;
    nic->rbcr1 = datalen >> 8;
    nic->command = START_DMA(DMA_WRITE);

    /*
     * load up the packet destination, source, and type first
     */
    en_io_out(hw_dst, port, HW_ADDR_LEN, &bytebuf);
    en_io_out(hw_src, port, HW_ADDR_LEN, &bytebuf);
    en_io_out((u_char *)(&type), port, sizeof(u_short), &bytebuf);

    /* now load up the mbuf data */
    for( ; m0; m0 = m0->m_next)
    {
	en_io_out(mtod(m0, u_char *), port, m0->m_len, &bytebuf);
    }

    /* flush any odd bytes remaining */
    en_flush_output(port, &bytebuf);


    if( !(nic->isr & RDC) )
    {
        /*
         * this is not yet a fatal error - give it
         * a chance to recover then try again
         */
	MICRODELAY(RDC_RECOVER_PERIOD);
    }

    /* now test the RDC bit for real */
    if( !(nic->isr & RDC) )
        return 0;

    nic->isr = RDC;

    /* finished */
    return 1;
}

#else

static int load_packet(u_char *hw_dst, u_char *hw_src, u_short type,
			struct mbuf *m0, volatile u_int *port, int datalen, int page, NICRef nic )
{
    u_int bytebuf = 0;
    int ptr = page<<8;
    int bytes_left;

    /* Kick off the first dma */
    nic->rsar0 = ptr;
    nic->rsar1 = ptr>>8;
    nic->rbcr0 = bytes_left = (datalen > 128) ? 128 : datalen;
    nic->rbcr1 = 0;
    nic->command = START_DMA(DMA_WRITE);
    ptr+=bytes_left;

    /*
     * load up the packet destination, source, and type first.  These definatly fit in the 1st dma
     */
    en_io_out(hw_dst, port, HW_ADDR_LEN, &bytebuf);
    en_io_out(hw_src, port, HW_ADDR_LEN, &bytebuf);
    en_io_out((u_char *)(&type), port, sizeof(u_short), &bytebuf);
    datalen -= HW_ADDR_LEN + HW_ADDR_LEN + sizeof(u_short);
    bytes_left -= HW_ADDR_LEN + HW_ADDR_LEN + sizeof(u_short);

    /* now load up the mbuf data */
    for( ; m0; m0 = m0->m_next)
    {
        int c = 0;

        while ( c < m0->m_len )
        {
            if ( bytes_left==0 )
            {
                en_flush_output(port, &bytebuf);
                bytebuf=0;
                if( !(nic->isr & RDC) )
                {
         	    MICRODELAY(RDC_RECOVER_PERIOD);
                }
                
                if( !(nic->isr & RDC) )
                    return 0;
    
                nic->isr = RDC;

      	        nic->rbcr0 = ~0;
	        nic->command = START_DMA(DMA_READ);

	        MICRODELAY(1);
	        nic->command = START_DMA(DMA_ABORT);
    
                nic->rsar0 = ptr;
                nic->rsar1 = ptr>>8;
                nic->rbcr0 = bytes_left = (datalen > 128) ? 128 : datalen;
                nic->rbcr1 = 0;
                nic->command = START_DMA(DMA_WRITE);
                ptr+=bytes_left;
            }
            
            if ( (m0->m_len-c) >= bytes_left )
            {
     	        en_io_out(mtod(m0, u_char *)+c, port, bytes_left, &bytebuf);
     	        c += bytes_left;
                datalen-=bytes_left;
     	        bytes_left = 0;
     	    }
     	    else
     	    {
     	        en_io_out(mtod(m0, u_char *)+c, port, m0->m_len-c, &bytebuf);
     	        bytes_left -= m0->m_len - c;
                datalen-= m0->m_len - c;
     	        c = m0->m_len;
     	    }
        }
    }

    /* flush any odd bytes remaining */
    en_flush_output(port, &bytebuf);

    if ( !(nic->isr & RDC) )
    {
        /*
         * this is not yet a fatal error - give it
         * a chance to recover then try again
         */
	MICRODELAY(RDC_RECOVER_PERIOD);
    }

    /* now test the RDC bit for real */
    if( !(nic->isr & RDC) )
        return 0;

    nic->isr = RDC;

    /* finished */
    return 1;
}

#endif

/**********************************************************************/

/*
 * tx_mbufs - copy packet out of mbuf chain into Tx buffer, and queue
 * the transmit request. returns 0 if all OK, else an appropriate errno.
 */
static int tx_mbufs(struct en_softc *en, struct mbuf *m0,
		    u_char *edst, int type, u_char *esrc)
{
    register struct mbuf *m;
    register int datalen;
    TxqRef txdesc;
    NICRef nic = en->Chip;
    int s, retries;
    u_char TxPending;

    /* count the length of the packet */
    for( datalen = PACK_HDR_LEN, m = m0; m; m = m->m_next )
	datalen += m->m_len;

    /* another frame for the stats. */
    en->en_st_tx_frames++;
    en->en_st_tx_bytes += datalen;

    if( datalen > ETHERMAXP )
    {
	/* log this as a general transmit failure */
	sprintf(en_lasterr, "Unit %d: Asked to transmit a giant packet\n",
		en->en_unit);
	en->en_st_tx_general_errors++;

	return(EMSGSIZE);
    }

    s = splet();

    /* check for a free transmit structure */
    if( (txdesc = en->TxqFree) == (TxqRef)NULL )
    {
	/*
	 * no free structures - log this
	 * as a general transmit failure
	 */
	splx(s);
	sprintf(en_lasterr, "Unit %d: No free transmit buffers\n",
		en->en_unit);
       	en->en_st_tx_general_errors++;

	return(INETERR_TXBLOCKED);
    }
    else
    {
	/* pull this buffer off the chain */
	en->TxqFree = txdesc->TxNext;
	txdesc->TxNext = (TxqRef)NULL;
	txdesc->TxByteCount = max(datalen, (ETHERMIN + PACK_HDR_LEN));
    }

#ifdef TXBUF_PROFILE
    {
        TxqRef n;
        int m;
        
        for ( m=0, n=en->TxqFree; n!=NULL; n=n->TxNext )
            m++;
        if ( max_txbuf > m )
            max_txbuf = m;
    }
#endif

    /* loop until packet is loaded, or excessive retries have failed */
    for( retries = 0; retries <= MAX_RDC_RETRIES; ++retries )
    {
	/*
	 * define I/O direction, execute workaround for bug in remote
	 * write DMA, initialise remote DMA parameters, then load
	 * the packet
	 */
	nic->rbcr0 = ~0;
	nic->command = START_DMA(DMA_READ);

	MICRODELAY(1);
	nic->command = START_DMA(DMA_ABORT);

	if ( load_packet(edst, esrc?esrc:(u_char *)en->en_addr,
		    htons(type), m0, en->dma_port, datalen, txdesc->TxStartPage, nic ) )
        {
            break;
        }
        else
        {
	    shutdown(nic, &TxPending);
	    startup(en, nic, TxPending);
        }
    }

    if( retries > MAX_RDC_RETRIES )
    {
	/*
	 * discarding this transmit - return transmit buffer
	 * to free chain & return error
	 */
	txdesc->TxNext = en->TxqFree;
	en->TxqFree = txdesc;
	sprintf(en_lastlog, "Unit %d: RDC failure in tx_mbufs()\n",
	    en->en_unit);

	splx(s);

	/* mark this as a general tx failure */
	en->en_st_tx_general_errors++;

	return(EIO);
    }

    /* is this the first packet in the queue? */
    if( en->TxPending == (TxqRef)NULL )
    {
	/* yes - kick start the NIC */
	en->TxPending = txdesc;
	start_tx(en, nic);
    }
    else
    {
	register TxqRef prev;
	for( prev = en->TxPending; prev->TxNext; prev = prev->TxNext )
	    /* do nothing */
	    ;

	prev->TxNext = txdesc;
    }

    /* all done */
    splx(s);
    return(0);
}

/**********************************************************************/

/* EOF if_en.c */
