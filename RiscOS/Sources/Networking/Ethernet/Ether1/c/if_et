#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <DebugLib/DebugLib.h>

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/mbuf.h>
#include <sys/dcistructs.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/if_ether.h>

#include <int_hndlr.h>
#include <xcb.h>
#include <ioc.h>
#include <delay.h>

#include "e1module.h"
#include "if_et.h"
#include "EtHdr.h"
#include "poduleirqs.h"

#define RBUF_SIZE MINCONTIG   /* receive buffer size  (same size as mbufs) */
#define TBUF_SIZE ETHERMTU  /* transmit buffer size */
#define NRFD 45             /* no of receive buffers descriptors (rx packets) */
#define NRBD 175            /* no of receive buffers */
#define NXMT 12             /* no of transmit buffers */

#define pageno(addr) (((int)(addr) >> PAGESHIFT) & TOPPAGE)


#define iowrite(where, value) where = ((unsigned)(value) << 16)
/*
This one doesn't work yet, but should be used.
#define iowrite(where, value) where = (((unsigned)(value) << 16)|(u_short)value)
*/

static void etintr (int unit);
static void et_shutdown (int);
static void etsetup (int);
static void setup_tx_bufs (struct et_softc *);
static void setup_rx_bufs (struct et_softc *);
static void wait_scb (struct et_softc *);
static void issue_cmd (struct et_softc *, struct obj_cb *);
static void et_cmd_done (struct et_softc *etp);
static void selectpage (struct et_softc *et, int n);
static void etread (struct et_softc *et, struct obj_rfd *rfd);
static void stats_init (struct et_softc *et);
static lanceaddr alloc_struct (struct et_softc *et, int size);
static lanceaddr alloc_buffer (struct et_softc *et, int bufsize);
static struct mbuf *if_rdbuf (lanceaddr rxbuf, int buflen, struct et_softc *et);

static caddr_t ARMaddress (struct et_softc *et, lanceaddr lanceptr);
static lanceaddr LANCEaddress (struct et_softc * et, caddr_t ioaddr);

static struct obj_cfg *make_cfg (struct et_softc *et, int int_loop, int ext_loop, int s);
static struct obj_ias *make_ias (struct et_softc *et);
static struct obj_dia *make_dia (struct et_softc *et);
#ifdef  ET_TDR
static struct obj_tdr *make_tdr (et_softc * et);
#endif /* ET_TDR */
extern char *ether_sprintf(register u_char *ap);


struct et_softc *et_softc[4];

int etcnt = 0;
struct xcb_block xblock[4];

extern caddr_t acopy_io_out (caddr_t ioaddr, caddr_t buffer, int count);
extern caddr_t acopy_io_in (caddr_t ioaddr, caddr_t buffer, int count);
#define copy_io_out acopy_io_out
#define copy_io_in  acopy_io_in

extern void et_irq_entry1 (void);
extern void et_init_high (int  unit);
extern void et_init_low (int unit, int irqs);

extern void callproto (Dib *, struct mbuf *, void (*)(), unsigned int);
static int etmem_test (int unit);
static int tx_mbufs (struct et_softc *et, struct mbuf *m0, u_char *edst, u_int type);


extern int (*address_filter[4]) (u_int level, u_char * pack_hdr, u_char * mac_addr);

static char et_lastlog[64] = { 0 };
static char et_lasterr[64] = { 0 };

static struct stats st = { 0 };

#define ET_TYPE    3

#define MEMCADDR  (0x112)
#define MEMCBIT   1

void et_init (void)
{
    int i, d;
    int ncards;
    u_char buffer[16];
    int s;
    u_int addr;

    if (_swix (Podule_ReturnNumber, _OUT (0), &ncards))
        return;

    s = splet ();
    for (i = 0; i < ncards; i++)
    {
        if (_swix (Podule_ReadID, _IN (3) | _OUT (0), i, &d) == NULL && d == 0)
        {
            if (_swix (Podule_ReadHeader, _INR (2, 3), buffer, i) == NULL)
            {
                if (((buffer[3]) | (buffer[4] << 8)) == ET_TYPE)
                {
                    _swix (Podule_HardwareAddress, _IN (3) | _OUT (3), i, &addr);
                    addr &= 0xFFEFFC00;         /* Extract fast address */
                    xblock[etcnt].address = (u_char *) addr;
                    xblock[etcnt].unit = etcnt;
                    xblock[etcnt].slot = i;
                    xblock[etcnt].wsp = module_wsp;
                    et_init_high (etcnt++);
                }
            }
        }
    }
    if (etcnt == 0)
    {
        splx (s);
        return;
    }
    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_init_low (i, 0);
        }
    }
    splx (s);
    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_init_low (i, 1);
        }
    }

    _swix (OS_SetVarVal, _INR (0, 4), "Inet$EtCount", &etcnt, 4, 0, 1);

    _swix (OS_SetVarVal, _INR (0, 4), "Inet$EtherType", "et0", 3, 0, 0);
}

int et_transmit (_kernel_swi_regs* r)
{
    u_int flags = r->r[0];
    u_int unit = r->r[1];
    u_int type = r->r[2];
    struct et_softc *et = et_softc[unit];
    int error = 0;
    u_char *edst = (u_char *) (r->r[4]);
    struct mbuf *m, *m0 = (struct mbuf *) (r->r[3]);

    dprintf (("", "et_transmit: unit=%d, flags=%x, type=%x, m0=%p\n",
              unit, flags, type, m0));

    if (flags >= TX_1STRESERVED)
    {
        error = EINVAL;
    }

    /*
     * run down the supplied mbuf list, transmitting each
     * chain, until an error is flagged.  all mbuf chains
     * not transmitted before an error condition arises
     * are silently dropped
     */
    while (m0)
    {
        m = m0;
        m0 = m0->m_list;

        if (!error)
        {
            error = tx_mbufs (et, m, edst, type);
        }
        dprintf (("", "error=%d\n", error));
        if (!(flags & TX_PROTOSDATA))
        {
            m_freem (m);
        }
    }

    return (error);
}

static void claim_device_interrupt (int unit)
{
    _swix (OS_ClaimDeviceVector, _INR (0, 4), 13, et_irq_entry1, &xblock[unit],
           xblock[unit].address,
           1);
}

static void release_device_interrupt (int unit)
{
    _swix (OS_ReleaseDeviceVector, _INR (0, 4), 13, et_irq_entry1, &xblock[unit],
           xblock[unit].address,
           1);
}

void et_final (void)
{
    int i;

    for (i = 0; i < 4; i++)
    {
        if (xblock[i].address)
        {
            et_shutdown (i);
            release_device_interrupt (i);
        }
    }
}

/* R0 is set up from the xblocks in et_irq_entry1 */
_kernel_oserror *et_irq_handler (_kernel_swi_regs *r, void *pw)
{
    UNUSED (pw);

    set_irqsareoff ();
    etintr (r->r[0]);
    clear_irqsareoff ();

    return (NULL);
}

unsigned char *et_addresses (int unit)
{
    return et_softc[unit]->et_addr;
}


extern int pretstats (int flag)
{
    struct et_softc *et;
    int unit;
    int first = 1;
    int filters_active;

    UNUSED (flag);

    for (unit = 0; unit < 4; unit++)
    {
        if (xblock[unit].address)
        {
            et = et_softc[unit];
            filters_active = 0;

            if (et->et_flags & ET_FAULTY)
            {
                printf ("Unit %d is FAULTY. Try machine reset to clear\n", unit);
                continue;
            }
            if (first)
            {
                first = 0;
            }
            else
            {
                printf ("\n");
            }

            if (etcnt > 1)
            {
                printf ("%s %d\n\n", "Unit", unit);
            }
            printf ("%-18s", "Card Info");
            printf ("Slot=%d, Ethernet address=%s\n\n", xblock[unit].slot, ether_sprintf (&et->et_addr[0]));
            printf ("%-18s", "I/O Stats");
            printf ("Rxframes=%ld, Rxerrs=%ld, Txframes=%ld, Txerrs=%ld\n",
                    et->et_st_rx_frames,
                    et->et_st_rx_general_errors,
                    et->et_st_tx_frames,
                    et->et_st_tx_general_errors);
            printf ("%-18s", " ");
            printf ("Collisions=%ld, Unwanted frames=%ld\n",
                    et->et_st_collisions, et->et_st_unwanted_frames);
            printf ("Active Filters:\n");

            if (ieeefilter[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @%p, r12 = %08x\n", "IEEE",
                        (ieeefilter[unit])->fs_handler,
                        (ieeefilter[unit])->fs_pwptr);
            }

            if (e2monitor[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @%p, r12 = %08x\n", "Ethernet2 Monitor",
                        (e2monitor[unit])->fs_handler,
                        (e2monitor[unit])->fs_pwptr);
            }

            if (e2sink[unit])
            {
                ++filters_active;
                printf ("%-18s: handler @%p, r12 = %08x\n", "Ethernet2 Sink",
                        (e2sink[unit])->fs_handler,
                        (e2sink[unit])->fs_pwptr);
            }

            if (e2specific[unit])
            {
                FilterChainRef fc = e2specific[unit];
                char *firstline = "Specific Types";

                ++filters_active;

                while (fc)
                {
                    printf ("%-18s: type %x, level %x, handler @%p, r12 = %08x\n",
                            firstline, fc->fc_type, fc->fc_addrlevel, fc->fc_handler, fc->fc_pwptr);

                    firstline = "";
                    fc = fc->fc_next;
                }
            }

            if (!filters_active)
            {
                printf ("(no filters active)\n");
            }

            if (et_lastlog[0])
            {
                printf ("\n%-18s%s\n", "Driver Info", et_lastlog);
                et_lastlog[0] = 0;
            }
            if (et_lasterr[0])
            {
                printf ("%-18s%s\n", "Driver Error", et_lasterr);
                et_lasterr[0] = 0;
            }
        }
    }

    return (1);
}

static void etcard_reset (int unit)
{
    /*
     * Compute the card registers' address - note that we always
     * access the card at FAST speed.
     */
    struct et_registers *regs = (struct et_registers *) xblock[unit].address;

    /* Reset the card and check this succeeded */
    iowrite (regs->control, RESET);
    if ((((XCBIDRef) regs)->id0 & XCB_ID0_IRQ) != 0)
    {
        sprintf (et_lasterr, "Ethernet card in slot %d: reset failed\n", xblock[unit].slot);
        iowrite (regs->control, 0);
    }
}


/*
 * High-priority XCB card initialisation.  Reset this card.
 */
void et_init_high (int unit)
{
    etcard_reset (unit);
}


/*
 * This is the XCB card second/third phase entry point (called by the
 * xcb manager at spl0) to check hardware and inform upper layers of
 * networking software that interfaces are available.  The xcb manager
 * is informed of the routine to handle interrupts for each configured
 * card.  This implementation does not provide a working if_reset
 * or if_init routine in the interface structure.  This decision was
 * taken after a search of the code failed to find any use of this
 * routines at the network/interface level. They have been replaced by
 * panic() calls in case they are used by other parts of networking
 * layers at a later date.  Unusually for a network interface, the main
 * card initialisation is done with interrupts enabled since this
 * allows the interrupt handler to perform its natural function. The
 * LANCE is designed to be driven by interrupts and the complexity of
 * the code is reduced.
 */
void et_init_low (int unit, int irqs)
{
    struct et_softc *et;
    struct et_registers *regs;

    if (irqs == 0)
    {
        /*
         * Phase 2 xcb initialisation - check hardware and
         * declare interrupts etc if all OK.
         */
        int i;

        /* Allocate a software control structure */
        et = (struct et_softc *) malloc (sizeof (struct et_softc));
        memset ((char *) et, 0, sizeof (struct et_softc));

        et_softc[unit] = et;
        et->et_unit = unit;
        regs = (struct et_registers *) xblock[unit].address;
        et->et_registers = regs;
        et->et_slot = xblock[unit].slot;
        /*
         * Copy the pcb revision from the rom - this is stored
         * in the LSB of the 8th word of ROM space, 0th element
         * of the generalised "data" field of an XCBID.
         */
        et->et_pcb_issue = ((XCBIDRef) regs)->data[0].d_uchar[0];
        /*
         * We can't handle old-issue boards, even if xcbman actually
         * manages to detect their presence...
         */
        if (et->et_pcb_issue == 0x0c || et->et_pcb_issue == 0xf3)
        {
            et->et_flags = ET_FAULTY;
            sprintf (et_lasterr, "Ethernet card in slot %d ignored: *OBSOLETE issue %X*\n",
                     et->et_slot, et->et_pcb_issue);
            return;
        }
        /*
         * Get unique station ethernet hardware adddress from
         * card ROM, LSB of words 9 thru' E.
         */
        for (i = 0; i < 6; i++)
            et->et_addr[i] = ((XCBIDRef) regs)->data[1 + i].d_uchar[0];

        et->et_dpram = (caddr_t) ((u_int) xblock[unit].address | (1 << 13));
        et->et_flags = 0;

        stats_init (et);
        /*
         * Declare the card to the xcb manager
         */
        claim_device_interrupt (unit);
    }
    else
    {
        /*
         * XCB init phase 3: further tests - declare unit to system if OK
         *
         * Give the LANCE a prod by releasing RESET+CA
         */
        et = et_softc[unit];
        if (et->et_flags & ET_FAULTY)
            return;                    /* ignore faulty units */
        regs = et->et_registers;
        iowrite (regs->control, RESET);
        iowrite (regs->control, 0);
        /* Check out the memory - etmem_test prints diags for us */
        if (!etmem_test (unit))
        {
            int s = splet ();

            et->et_flags |= ET_FAULTY; /* mark failure */
            iowrite (regs->control, RESET);     /* leave board disabled */
            splx (s);
            return;
        }
        et->et_st_link_status |= ST_STATUS_OK;
        et->et_st_link_polarity = 1;
        /*
         * We have a working ethernet unit, folks.
         *
         * Initialise control structures in LANCE memory and
         * get proceedings underway.
         */
        etsetup (unit);
    }
}


/*
 * XCB interface entry point for system reboot/halt time - close
 * down the card, and ensure it's in reset state.  etcard_reset
 * does all the work for us.
 */
static void et_shutdown (int unit)
{
    etcard_reset (unit);
}


static void etsetup (int unit)
{
    register struct et_softc *et = et_softc[unit];
    register struct obj_scp *scp;
    register struct obj_iscp *iscp;
    register struct obj_scb *scb;
    register lanceaddr la;
    register int i;
    int s = splet ();

    et->et_backoff = 60;                                                    /* Start at 1 minute and increase */
    et->et_watch.cmd = 0;
    et->et_watch.tdr = 0;
    et->et_flags = 0;
    iowrite (et->et_registers->control, RESET);
    iowrite (et->et_registers->control, 0);
    et->next_buffer = (lanceaddr) 0;
    et->cfg = (struct obj_cfg *) 0;
    et->ias = (struct obj_ias *) 0;
    et->dia = (struct obj_dia *) 0;
    et->tdr = (struct obj_tdr *) 0;
    /* set up SCP AND ISCP */
    selectpage (et, TOPPAGE);                                               /* all control structures are in TOPPAGE, recv & xmt buffers elsewhere */
    scp = (struct obj_scp *) ARMaddress (et, 0xFFFFF6);                     /* SCP is at fixed address 0x0FFFFF6, the top byte gets ignored */
    et->last_struct = LANCEaddress (et, (caddr_t) scp);
    iowrite (scp->sysbus, 0);                                               /* 16 bit bus */
    la = alloc_struct (et, SZ_ISCP);
    iowrite (scp->iscpaddr, la);
    iowrite (scp->iscptopaddr, 0);
    iscp = (struct obj_iscp *) ARMaddress (et, la);
    iowrite (iscp->busy, 1);                                                /* cleared by LANCE when it has completed initialisation */
    la = alloc_struct (et, SZ_SCB);
    iowrite (iscp->scb_offset, la);
    iowrite (iscp->scb_base[0], 0);
    iowrite (iscp->scb_base[1], 0);                                         /* base address of 64K segment */
    /* set up SCB */
    scb = (struct obj_scb *) ARMaddress (et, la);
    iowrite (scb->status, 0);
    iowrite (scb->command, 0);
    iowrite (scb->cbl, LANCE_NULL);
    iowrite (scb->rfa, LANCE_NULL);
    iowrite (scb->crcerrs, 0);                                              /* clear error counts */
    iowrite (scb->alnerrs, 0);
    iowrite (scb->rscerrs, 0);
    iowrite (scb->ovrnerrs, 0);
    et->scb = scb;                                                          /* save scb pointer */
    et->cmd_tail = NULL;
    setup_tx_bufs (et);
    setup_rx_bufs (et);
    attention (et, CA);                                                     /* init LANCE: RESET,CA -> read SCP */
    for (i = 0; i < 3; i++)
    {
        MICRODELAY (1000);
        if ((scb->status & 0xffff) == (SCB_CX | SCB_CNA))
            break;
    }
    if ((scb->status & 0xffff) != (SCB_CX | SCB_CNA))
    {
        sprintf (et_lastlog, "Unit %d: can't initialise, status 0x%x\n",
                 unit, scb->status & 0xffff);
        et->et_flags |= ET_FAULTY;
        iowrite (et->et_registers->control, RESET);                         /* Leave board disabled */
        splx (s);
        return;
    }
    splx (s);
    issue_cmd (et, (struct obj_cb *) make_cfg (et, 0, 0, ST_STATUS_BROADCAST));
    issue_cmd (et, (struct obj_cb *) make_ias (et));
    issue_cmd (et, (struct obj_cb *) make_dia (et));
}

#define O(n) (1 << n)
#define Z(n) (O(n) ^ 0xffff)

static int etmem_test (int unit)
{
    struct et_softc *et = et_softc[unit];
    unsigned pattern[34];
    unsigned pat, *addr, val, offset, page;
    register int i, j;

    iowrite (et->et_registers->control, RESET);
    iowrite (et->et_registers->control, 0);
    for (i = 0; i < 16; i++)
    {
        pattern[i] = O (i);
    }
    pattern[16] = 0;
    for (i = 0; i < 16; i++)
    {
        pattern[17 + i] = Z (i);
    }
    pattern[17 + 16] = 0xffff;
    for (i = 0; i < 34; i += 17)
    {
        /* The complete test takes too long, just do 1s and 0s. */
        offset = i;
        for (page = 0; page <= TOPPAGE; page++)
        {
            selectpage (et, page);
            addr = (unsigned *) et->et_dpram;
            for (j = 0; j < PAGESIZE; j += 2, addr++)
            {
                pat = pattern[offset];
                iowrite (*addr, pat);
                if (++offset == 34)
                {
                    offset = 0;
                }
            }
        }
        offset = i;
        for (page = 0; page <= TOPPAGE; page++)
        {
            selectpage (et, page);
            addr = (unsigned *) et->et_dpram;
            for (j = 0; j < PAGESIZE; j += 2, addr++)
            {
                pat = pattern[offset];
                val = *addr & 0xffff;
                if (val != pat)
                {
                    sprintf (et_lasterr, "Unit %d: slot %d: RAM fault: addr 0x%04x, w:0x%04x r:0x%04x\n",
                             unit, et->et_slot, page * PAGESIZE + j, pat, val);
                    return (0);
                }
                if (++offset == 34)
                {
                    offset = 0;
                }
            }
        }
    }
    return (1);
}


/* Use transmit buffers large enough to hold a whole ethernet package. We
 * have enough memory to avoid the added complication of buffer chaining.
 * Allocate an array of TCBs, each one pointing to one TBD in TOPPAGE, which
 * in turn points to one data buffer in any page but TOPPAGE.
 */
static void setup_tx_bufs (struct et_softc *et)
{
    register struct obj_tbd *tbd;
    register struct obj_tcb *tcb;
    register struct obj_nop *nop;
    register lanceaddr tcbla, la, nopla, temp;
    register int i;

    /*
    ** TransmitControlBlocks are always used with one NOP command following
    ** so that the EL bit can be left clear on a transmit command to allow
    ** chaining to work.
    **      +-----------+                   +-----------+
    **      |   T C B   +------------------>|   N O P   +--------->   etc
    **      +-----+-----+                   +-----------+
    **            |
    **            |         +-----------+
    **            +-------> |   T B D   |
    **                      +-----+-----+
    **                            |
    **                            |
    **                            |         +---------------+
    **                            +-------> |  B u f f e r  |
    **                                      |               |
    **                                      |               |
    **                                      |               |
    */
    tcbla = alloc_struct (et, SZ_TCB);
    et->tcb_free = (struct obj_tcb *) ARMaddress (et, tcbla);
    nopla = alloc_struct (et, SZ_NOP);
    et->nop_free = (struct obj_nop *) ARMaddress (et, nopla);
    for (i = 0; i <= NXMT - 1; i++)
    {
        tcb = (struct obj_tcb *) ARMaddress (et, tcbla);
        nop = (struct obj_nop *) ARMaddress (et, nopla);
        iowrite (tcb->status, 0);
        iowrite (nop->status, 0);
        iowrite (tcb->command, CB_XMT);
        iowrite (nop->command, CB_NOP);
        if (i == NXMT - 1)
        {
            iowrite (tcb->link, LANCE_NULL);
            iowrite (nop->link, LANCE_NULL);
        }
        else
        {
            tcbla = alloc_struct (et, SZ_TCB);
            nopla = alloc_struct (et, SZ_NOP);
            iowrite (tcb->link, tcbla);
            iowrite (nop->link, nopla);
        }
        la = alloc_struct (et, SZ_TBD);
        iowrite (tcb->tbd, la);
        tbd = (struct obj_tbd *) ARMaddress (et, la);
        iowrite (tbd->next_tbd, LANCE_NULL);
        temp = alloc_buffer (et, TBUF_SIZE);
        iowrite (tbd->buffer, temp);
        iowrite (tbd->buffer_hi, 0);   /* buffer address is 24 bit */
    }
}

/* Allocate a circular linked list of RFDs and a circular linked list of RBDs
 * in top page, each RBD pointing to one buffer elsewhere.  Each buffer is
 * the size of a mbuf, since the LANCE does scatter/gather DMA and it makes
 * better use of the buffer memory. The limiting factor is RBDs in the
 * TOPPAGE not the actual buffer space.
 */
static void setup_rx_bufs (struct et_softc *et)
{
    register struct obj_rfd *rfd;
    register struct obj_rbd *rbd;
    lanceaddr head, temp;
    register lanceaddr la;
    register int i;

    /* circular list of RFDs */
    head = la = alloc_struct (et, SZ_RFD);
    for (i = 0; i <= NRFD - 1; i++)
    {
        rfd = (struct obj_rfd *) ARMaddress (et, la);
        iowrite (rfd->status, 0);
        iowrite (rfd->rbd, LANCE_NULL);
        if (i != (NRFD - 1))
        {
            la = alloc_struct (et, SZ_RFD);
            iowrite (rfd->command, 0);
            iowrite (rfd->link, la);
        }
        else
        {
            iowrite (rfd->command, RFD_EL);
            iowrite (rfd->link, head);
        }
    }
    et->rfd_head = (struct obj_rfd *) ARMaddress (et, head);
    et->rfd_tail = rfd;
    /* put pointer to rfa in scb */
    iowrite (et->scb->rfa, head);

    /* circular list of RBDs */
    head = la = alloc_struct (et, SZ_RBD);
    iowrite (et->rfd_head->rbd, head);
    for (i = 0; i <= NRBD - 1; i++)
    {
        rbd = (struct obj_rbd *) ARMaddress (et, la);
        iowrite (rbd->status, 0);
        temp = alloc_buffer (et, RBUF_SIZE);
        iowrite (rbd->buffer, temp);
        iowrite (rbd->buffer_hi, 0);
        if (i != NRBD - 1)
        {
            la = alloc_struct (et, SZ_RBD);
            iowrite (rbd->size, RBUF_SIZE);
            iowrite (rbd->next, la);
        }
        else
        {
            iowrite (rbd->size, RBD_EL | RBUF_SIZE);
            iowrite (rbd->next, head);
        }
    }
    et->rbd_tail = rbd;
}


static int etbringup (int unit)
{
    register struct et_softc *et = et_softc[unit];
    int s;


    if (et->et_flags & ET_RUNNING)
        return (1);
    etsetup (unit);
    if (et->et_flags & ET_FAULTY)
        return (0);
    s = splet ();
    et->et_flags |= ET_RUNNING;

    /* start receive unit */
    wait_scb (et);
    iowrite (et->scb->command, RU (START));
    if ((et->scb->cbl & 0xffff) != LANCE_NULL)
    {
        iowrite (et->scb->command, et->scb->command | CU (START));
        et->et_watch.cmd = 3;
    }
    attention (et, CA);
    et->et_watch.timer = ET_WATCHTIME * 100;
    splx (s);
    return (1);
}


int etioctl (int unit, int cmd, int flag)
{
    register struct et_softc *et;
    register struct obj_scb *scb;

    dprintf (("", "etioctl: unit=%d, cmd=%d, flag=%d\n", unit, cmd, flag));

    if (unit < 0 || unit > 4)
        return (1);
    et = et_softc[unit];

    switch (cmd)
    {

        case 0:
            if ((et->et_flags & ET_FAULTY) || !etbringup (unit))
                return (1);
            break;

        case 1:
            scb = et->scb;
            et->et_flags &= ~ET_SQEINFORMED;    /* Will print message on next SQE error */
            if (et->et_flags & ET_FAULTY)
            {
                /* Reset the card to disable it - no rx */
                iowrite (et->et_registers->control, RESET);
                break;
            }
            if (flag == 0 && et->et_flags & ET_RUNNING)
            {
                /* Reset the card to disable it - no rx */
                iowrite (et->et_registers->control, RESET);
                et->et_flags &= ~ET_RUNNING;
            }
            else if (flag && (et->et_flags & ET_RUNNING) == 0)
            {
                if (!etbringup (unit))
                    return (1);
            }
#ifdef  ET_TDR
            et->et_watch.tdr = 5;
            issue_cmd (et, make_tdr (et));
#endif /* ET_TDR */
        default:
            break;


    }
    return (0);
}


#define CFG_FIFO_LIM(n) ((n)<<8)
#define CFG_BYTE_CNT(n) (n)

#define CFG_SRDY(tf) ((tf)<<6)
#define CFG_SAV_BF(tf) ((tf)<<7)
#define CFG_ADDR_LEN(n) ((n)<<8)
#define CFG_AL_LOC(tf) ((tf)<<11)
#define CFG_PREAM_LEN(n) ((n)<<12)
#define CFG_INT_LPBCK(tf) ((tf)<<14)
#define CFG_EXT_LPBCK(tf) ((tf)<<15)

#define CFG_LIN_PRIO(n) (n)
#define CFG_ACR(n) ((n)<<4)
#define CFG_BOF_MET(tf) ((tf)<<7)
#define CFG_IFRM_SPACE(n) ((n)<<8)

#define CFG_SLOT_TIME(n) (n)
#define CFG_RETRY_NUM(n) ((n)<<12)

/*#define CFG_PRM(tf) (tf)*/
#define CFG_PRM(tf) (1)
#define CFG_BC_DIS(tf) ((tf)<<1)
#define CFG_MANCH(tf) ((tf)<<2)
#define CFG_TONO_CRS(tf) ((tf)<<3)
#define CFG_NCRC_INS(tf) ((tf)<<4)
#define CFG_CRC_16(tf) ((tf)<<5)
#define CFG_BT_STF(tf) ((tf)<<6)
#define CFG_PAD(tf) ((tf)<<7)
#define CFG_CRSF(n) ((n)<<8)
#define CFG_CRS_SRC(tf) ((tf)<<11)
#define CFG_CDTF(n) ((n)<<12)
#define CFG_CDT_SRC(tf) ((tf)<<15)

#define CFG_MIN_FRM_LEN(n) (n)

static struct obj_cfg *make_cfg (struct et_softc *et, int int_loop, int ext_loop, int s)
{
    register struct obj_cfg *cfg = et->cfg;

    if (cfg == NULL)
    {
        et->cfg = cfg = (struct obj_cfg *) ARMaddress (et, alloc_struct (et, SZ_CFG));
    }
    else
    {
        while ((et->et_flags & ET_DOING_CFG) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.  If you don't do this then you can end up overwriting
             * the previous command structure if this routine gets called again
             * before the previous one has finished.  This will cause the
             * configure command structure's next pointer to point back to the
             * same command, so the interrupt handler will go into an infinite
             * loop.
             *
             * This is what was causing the problems with StrongARM - it
             * wasn't a 'StrongARM bug' per se, but the StrongARM is
             * sufficiently quick that the DCI4 Filter SWI (which is mostly
             * what causes this routine to be called) can be issued again before
             * the previous one has been fully dealt with.
             */
        }
    }

    et->et_flags |= ET_DOING_CFG;

    int_loop &= 1;
    ext_loop &= 1;
    iowrite (cfg->status, 0);
    iowrite (cfg->command, CB_EL | CB_CFG);
    iowrite (cfg->link, LANCE_NULL);
    iowrite (cfg->param[0], CFG_FIFO_LIM (8) | CFG_BYTE_CNT (10));
                                       /* Change BYTE_CNT if altering more
                                        * parameters */
    iowrite (cfg->param[1], CFG_SRDY (1) | CFG_SAV_BF (0) |
             CFG_ADDR_LEN (6) | CFG_AL_LOC (0) | CFG_PREAM_LEN (2) |
             CFG_INT_LPBCK (int_loop) | CFG_EXT_LPBCK (int_loop | ext_loop));
    iowrite (cfg->param[2], CFG_LIN_PRIO (0) | CFG_ACR (0) | CFG_BOF_MET (0) |
             CFG_IFRM_SPACE (96));
    iowrite (cfg->param[3], CFG_SLOT_TIME (512) | CFG_RETRY_NUM (15));
    iowrite (cfg->param[4], CFG_PRM (s == ST_STATUS_PROMISCUOUS) |
             CFG_BC_DIS (s == ST_STATUS_DIRECT) |
             CFG_MANCH (0) | CFG_TONO_CRS (0) | CFG_NCRC_INS (0) |
             CFG_CRC_16 (0) | CFG_BT_STF (0) | CFG_PAD (0) |
             CFG_CRSF (0) | CFG_CRS_SRC (0) | CFG_CDTF (0) |
             CFG_CDT_SRC (0));
    return (cfg);
}


static struct obj_ias *make_ias (struct et_softc *et)
{
    register struct obj_ias *ias = et->ias;

    if (ias == NULL)
    {
        et->ias = ias = (struct obj_ias *) ARMaddress (et, alloc_struct (et, SZ_IAS));
    }
    else
    {
        while ((et->et_flags & ET_DOING_IAS) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_IAS;

    iowrite (ias->status, 0);
    iowrite (ias->command, CB_EL | CB_IAS);
    iowrite (ias->link, LANCE_NULL);
    copy_io_out ((caddr_t) et->et_addr, (caddr_t) & ias->address[0], 6);
    return (ias);
}

static struct obj_dia *make_dia (struct et_softc *et)
{
    register struct obj_dia *dia = et->dia;

    if (dia == NULL)
    {
        et->dia = dia = (struct obj_dia *) ARMaddress (et, alloc_struct (et, SZ_DIA));
    }
    else
    {
        while ((et->et_flags & ET_DOING_DIA) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_DIA;

    iowrite (dia->status, 0);
    iowrite (dia->command, CB_EL | CB_DIA);
    iowrite (dia->link, LANCE_NULL);
    return (dia);
}


#ifdef  ET_TDR
static struct obj_tdr *make_tdr (et_softc * et)
{
    register struct obj_tdr *tdr = et->tdr;

    if (tdr == NULL)
    {
        et->tdr = tdr = (struct obj_tdr *) ARMaddress (et, alloc_struct (et, SZ_TDR));
    }
    else
    {
        while ((et->et_flags & ET_DOING_TDR) != 0)
        {
            /* Busy-wait until the previous configure command has been
             * processed.
             */
        }
    }

    et->et_flags |= ET_DOING_TDR;

    iowrite (tdr->status, 0);
    iowrite (tdr->command, CB_EL | CB_TDR);
    iowrite (tdr->link, LANCE_NULL);
    return (tdr);
}
#endif /* ET_TDR */


static int tx_mbufs (struct et_softc *et, struct mbuf *m0, u_char *edst, u_int type)
{
    struct mbuf *m;
    struct obj_tcb *tcb;
    struct obj_tbd *tbd;
    struct obj_nop *nop;
    u_int datalen = 0;
    caddr_t buffer;
    int s, page;
    u_int temp;

    for (m = m0; m; m = m->m_next)
        datalen += m->m_len;
    dprintf (("", "et:tx_mbufs: datalen=%x\n", datalen));

    s = splet ();
    /* check there is a free tcb + nop and update free pointers */
    tcb = et->tcb_free;
    if (tcb == NULL)
    {
        splx (s);
        dprintf (("", "et:tx_mbufs returning ENOBUFS\n"));
        return ENOBUFS;
    }
    et->et_st_tx_bytes += (u_long) datalen + PACK_HDR_LEN;
    nop = et->nop_free;
    et->tcb_free = (struct obj_tcb *) ARMaddress (et, tcb->link);
    et->nop_free = (struct obj_nop *) ARMaddress (et, nop->link);
    splx (s);
    iowrite (tcb->status, 0);
    iowrite (tcb->command, CB_XMT);
    iowrite (tcb->link, LANCEaddress (et, (caddr_t) nop));
    iowrite (nop->status, 0);
    iowrite (nop->command, CB_EL | CB_NOP);
    iowrite (nop->link, LANCE_NULL);

    /* fill in destination address and packet type */
    copy_io_out ((caddr_t) edst, (caddr_t) tcb->destaddr, 6);

    temp = htons (type);
    iowrite (tcb->type, temp);
    tbd = (struct obj_tbd *) ARMaddress (et, tcb->tbd);

    /* set count of data bytes and EOF bit in TBD */
    temp = MAX (datalen, ETHERMIN) | TBD_EOF;
    iowrite (tbd->status, temp);

    buffer = (caddr_t) ARMaddress (et, tbd->buffer);
    page = pageno (tbd->buffer);
    while (m0)
    {
        s = splet ();
        selectpage (et, page);
        buffer = copy_io_out (mtod (m0, caddr_t), buffer, m0->m_len);
        selectpage (et, TOPPAGE);
        splx (s);
        m0 = m0->m_next;
    }
    /* put the tcb + nop on the end of the command list */
    issue_cmd (et, (struct obj_cb *) tcb);
    return (0);
}


static void etrecv (struct et_softc *et)
{
    register struct obj_rfd *rfd = et->rfd_head;
    register struct obj_rbd *rbd;
    register unsigned status = rfd->status;

    dprintf (("", "rc\n"));
    while (status & RFD_C)
    {
        et->et_watch.reset = 0;        /* Reset did something useful */
        et->et_backoff = 60;           /* Reset reset backoff to 1 minute */
        et->et_st_rx_frames++;
        if (status & RFD_OK)
        {
            etread (et, rfd);
        }
        else
        {
            et->et_st_rx_general_errors++;
        }
        /* free RBD */
        rbd = (struct obj_rbd *) ARMaddress (et, rfd->rbd);
        if (rbd)
        {
            do
            {
                status = rbd->status;
                /* Chain this rbd on to the tail of the list, and mark the old tail as not endlist */
                /* The order is vital, since the LANCE is active on this chain */
                iowrite (rbd->size, RBD_EL | RBUF_SIZE);
                iowrite (et->rbd_tail->size, RBUF_SIZE);
                et->rbd_tail = rbd;
                rbd = (struct obj_rbd *) ARMaddress (et, rbd->next);
            }
            while ((status & RBD_EOF) == 0);
        }
        /* free RFD */
        iowrite (rfd->status, 0);
        iowrite (rfd->command, RFD_EL);
        iowrite (rfd->rbd, LANCE_NULL);
        iowrite (et->rfd_tail->command, 0);
        et->rfd_tail = rfd;
        rfd = (struct obj_rfd *) ARMaddress (et, rfd->link);
        status = rfd->status;
    }
    et->rfd_head = rfd;
}

static void etread (struct et_softc *et, struct obj_rfd *rfd)
{
    struct mbuf *m, *m0;
    struct obj_rbd *rbd;
    struct obj_rbd *rbd_next;
    unsigned status, type;
    u_int unit = et->et_unit;
    RxHdr *hdr;
    FilterSingleRef fs = NULL;
    int i;
    struct hwaddr
    {
        u_char addr[HW_ADDR_LEN];
    } src, dst;

    dprintf (("", "rd\n"));

    type = ntohs (rfd->type & 0xffff);

    /*
     * 1st discrimination of frame type - is it
     * an IEEE 802.3 or an Ethernet 2.0 frame?
     */
    if (type <= ETHERMTU)
    {
        fs = ieeefilter[unit];
    }

    /*
     * it's an Ethernet 2.0 frame, do we have
     * specific or sink filters active?
     */
    else if (e2specific[unit] || e2sink[unit])
    {
        FilterChainRef fc;

        /*
         * start by trying to match specific frame types
         */
        for (fc = e2specific[unit]; fc; fc = fc->fc_next)
            if (fc->fc_type == type)
            {
                fs = &fc->fc_filter;
                break;
            }

        /*
         * default to sink filter if no specific matches
         */
        if (!fc)
        {
            fs = e2sink[unit];
        }
    }

    /*
     * all we have left is the Ethernet 2.0 monitor
     */
    else
    {
        fs = e2monitor[unit];
    }

    /*
     * pass the packet along if it is wanted
     */
    if (fs)
    {
        extern void read_six_from_card (u_char *, u_char *);

        /* First copy in header */
        read_six_from_card (src.addr, (u_char *) rfd->sourceaddr);
        read_six_from_card (dst.addr, (u_char *) rfd->destaddr);

        *(struct hwaddr *) (et->et_st_last_src_addr) = src;
        *(struct hwaddr *) (et->et_st_last_dest_addr) = dst;

        /* for (i=0; i < PACK_HDR_LEN/2; i++) ((u_short
         * *)pack_hdr)[i]=((u_short *)rfd->destaddr)[i*2+1]; */

#ifdef DEBUGLIB
        {
            char temp[32];

            strcpy (temp, ether_sprintf (src.addr));
            /*sprintf (et_lastlog, "%s -> %s (type %04x)", temp, ether_sprintf (dst.addr), type);*/
            dprintf (("", "%s -> %s (type %04x)\n", temp, ether_sprintf (dst.addr), type));
        }
#endif

        /*
         * use the filtering routine appropriate to
         * the current level of packet reception
         */
        if (address_filter[unit] (fs->fs_addrlevel, dst.addr, (u_char *) et->et_addr))
        {
            et->et_st_unwanted_frames++;
            return;
        }
    }
    else
    {
        /*
         * no protocols want this frame
         */
        et->et_st_unwanted_frames++;
        return;
    }

    rbd = (struct obj_rbd *) ARMaddress (et, rfd->rbd);

    m0 = m = ALLOC_S (MINCONTIG, NULL);
    if (m == 0)
    {
        return;
    }
    m->m_type = MT_HEADER;
    hdr = mtod (m0, RxHdr *);
    m0->m_len = sizeof (RxHdr);
    dprintf (("", "LANCE rfd address %x\n", (int) rfd));
    *(struct hwaddr *) (hdr->rx_src_addr) = src;
    *(struct hwaddr *) (hdr->rx_dst_addr) = dst;
    hdr->_spad[0] = hdr->_spad[1] = 0;
    hdr->_dpad[0] = hdr->_dpad[1] = 0;
    hdr->rx_tag = 0;
    hdr->rx_frame_type = type;
    hdr->rx_error_level = 0;
    do
    {
        int length;

        status = rbd->status;
        if ((status & RBD_F) == 0)
        {
            sprintf (et_lastlog, "Unit %d: etread: incomplete receive\n", et->et_unit);
            type = 0;
            et->et_st_runt_frames++;
            break;
        }
        length = status & RBD_ACTCOUNT;
        et->et_st_rx_bytes += length;
        m->m_next = if_rdbuf (rbd->buffer, length, et);
        if (m->m_next == 0)
        {
            type = 0;
            break;
        }
        m = m->m_next;
        rbd_next = (struct obj_rbd *) ARMaddress (et, rbd->next);
        rbd = rbd_next;
        i++;
    } while ((status & RBD_EOF) == 0);

    dprintf (("", "callproto: dib=%p, m0=%p, handler=%p, pw=%08x\n",
              dibs[unit], m0, fs->fs_handler, fs->fs_pwptr));

    callproto (dibs[unit], m0, fs->fs_handler, fs->fs_pwptr);
}


/* Rx buffer chains are MLEN bytes each, so one fits exactly in a mbuf */
static struct mbuf *if_rdbuf (lanceaddr rxbuf, int buflen, struct et_softc *et)
{
    register struct mbuf *m = ALLOC_S (MINCONTIG, NULL);

    if (m == 0)
        return (0);
    m->m_type = MT_DATA;
    selectpage (et, pageno (rxbuf));
    copy_io_in ((caddr_t) ARMaddress (et, rxbuf), mtod (m, caddr_t), buflen);
    m->m_len = buflen;
    selectpage (et, TOPPAGE);
    return (m);
}


void wait_scb (struct et_softc *et)
{
    register int i;

    for (i = 0; i <= 0xfffff; i++)
    {
        if ((et->scb->command & 0xffff) == 0)
        {
            return;
        }
    }
    sprintf (et_lastlog, "Unit %d: scb failed to clear status 0x%x command 0x%x\n",
             et->et_unit, et->scb->status & 0xffff, et->scb->command & 0xffff);
}


void issue_cmd (struct et_softc *et, struct obj_cb *cmd)
{
    register struct obj_scb *scb = et->scb;
    register struct obj_cb *tail = cmd;
    lanceaddr temp;
    int s = splet (), was_idle;

    wait_scb (et);
    while ((tail->link & 0xffff) != LANCE_NULL)
    {
        /* If there's a chain of commands, clear the End Of List bit
         * on all but the last command in the chain.
         */
        iowrite (tail->command, tail->command & ~CB_EL);
        tail = (struct obj_cb *) ARMaddress (et, tail->link);
    }

    /* Ensure last command (possibly in chain) has End Of List bit set */
    iowrite (tail->command, tail->command | CB_EL);
    et->et_watch.cmd = 3;              /* Set up watchdog in case command hangs */
    if (et->cmd_tail == NULL)
    {
        /* No commands currently in list.
         * Make new command(s) the list.
         */
        temp = LANCEaddress (et, (caddr_t) cmd);
        iowrite (scb->cbl, temp);
        was_idle = 1;
    }
    else
    {
        register struct obj_cb *cmd_tail = et->cmd_tail;

        /* Already commands in list.
         * Attach new command(s) to end of list.
         */
        temp = LANCEaddress (et, (caddr_t) cmd);
        iowrite (cmd_tail->link, temp);
        iowrite (cmd_tail->command, cmd_tail->command & ~CB_EL);
        was_idle = 0;
    }
    et->cmd_tail = tail;
    if (was_idle)
    {
        /* Activate the Command Unit */
        iowrite (scb->command, CU (START));
        attention (et, CA);
    }
    splx (s);
}



/* called every ET_WATCHTIME seconds to check that things have happened */

extern void etwatch (int unit)
{
    register struct et_softc *et = et_softc[unit];
    int s = splet ();

    if (et->et_watch.cmd && (--et->et_watch.cmd == 0))
    {
        sprintf (et_lastlog, "Unit %d: Hardware timed out during command, resetting\n", unit);
        goto hung;
    }
#ifdef  ET_TDR
    if (et->et_watch.tdr && (--et->et_watch.tdr == 0))
    {
        sprintf (et_lastlog, "Unit %d: TDR not available on this hardware\n", unit);
    }
#endif /* ET_TDR */
    if (et->et_watch.reset && (--et->et_watch.reset == 0))
    {
        sprintf (et_lastlog, "Unit %d: device hung and will not reset\n", unit);
        et->et_flags |= ET_FAULTY;
        iowrite (et->et_registers->control, RESET);     /* Leave the card reset
                                                         */
        et->et_watch.timer = 0;
    }
    splx (s);
    return;

  hung:
    splx (s);
    et->et_watch.reset = et->et_backoff / ET_WATCHTIME;
    et->et_backoff = (et->et_backoff * 3) / 2;
    etsetup (unit);
    (void) etbringup (unit);
}


static void etintr (int unit)
{
    register struct et_softc *et = et_softc[unit];
    register struct obj_scb *scb = et->scb;
    unsigned status, ack;
    lanceaddr temp;

    /* Determine type of interrupt and acknowledge before modifying
     * structures. Any interrupting event that occurs while we are
     * processing will then still generate an interrupt even though
     * we will have handled it already. This is OK, whereas missing
     * an interrupt would cause us to hang!
     */
    dprintf (("", "i\n"));
    wait_scb (et);
    status = scb->status;
    ack = status & (SCB_CX | SCB_CNA | SCB_FR | SCB_RNR);
    if (ack)
    {
        iowrite (scb->command, ack);
        attention (et, CA | ACK);
    }
    else
    {
        /* The Ethernet card can have a latched interrupt pending left over
         * from the previous INTEL chip interrupt. We must clear it just in
         * the PAL since the INTEL chip says there is no work to be done.
         * (Else it just comes back until the next Ethernet packet arrives
         * BUG 2127) */
        attention (et, ACK);
        return;
    }
    if (status & SCB_FR)
    {
        etrecv (et);
    }
    if (status & SCB_RNR)
    {
        wait_scb (et);
        iowrite (et->rfd_head->rbd, et->rbd_tail->next);
        temp = LANCEaddress (et, (caddr_t) et->rfd_head);
        iowrite (scb->rfa, temp);
        iowrite (scb->command, RU (START));
        attention (et, CA);
    }
    if (status & SCB_CX)
    {
        et_cmd_done (et);
    }
    if (status & SCB_CNA)
    {
        et_cmd_done (et);
        if ((scb->cbl & 0xffff) != LANCE_NULL)
        {
            iowrite (scb->command, CU (START));
            attention (et, CA);
        }
    }
}


void et_cmd_done (struct et_softc *etp)
{
    register struct et_softc *et = etp;
    register struct obj_scb *scb = et->scb;
    struct obj_cb *cb = (struct obj_cb *) ARMaddress (et, scb->cbl), *cbn;
    unsigned unit = et->et_unit;
    lanceaddr temp;

    while (cb != NULL)
    {
        cbn = (struct obj_cb *) ARMaddress (et, cb->link);
        if ((cb->status & CB_C) == 0)
        {
            return;
        }
        et->et_watch.reset = 0;        /* Reset did something useful */
        iowrite (scb->cbl, cb->link);
        if (cb == et->cmd_tail)
        {
            et->cmd_tail = NULL;
        }
        if (cbn == NULL)
        {
            et->et_watch.cmd = 0;      /* All commands have completed */
        }
        switch (cb->command & CB_CMD)
        {
            case CB_XMT:
            {
                register struct obj_tcb *tcb = (struct obj_tcb *) cb;
                register unsigned status = tcb->status;
                register int ncoll;

                et->et_st_tx_frames++;
                if ((status & CB_OK) == 0)
                {
                    et->et_st_tx_general_errors++;
                }
                if ((et->et_flags & ET_SQETEST) &&
                    ((status & (TCB_COLL | TCB_NCOLL)) == 0) &&
                    ((status & TCB_SQE) == 0))
                {
                    if ((et->et_flags & ET_SQEINFORMED) == 0)
                    {
                        sprintf (et_lasterr, "Unit %d: SQE (is the AUI cable connected?)\n", unit);
                        et->et_flags |= ET_SQEINFORMED;
                    }
                }
                ncoll = status & TCB_NCOLL;

                /* test for abort due to excessive collisions */
                if (status & TCB_COLL)
                {
                    if (ncoll == 0)
                    {
                        ncoll = 16;         /* Encoded in only 4 bits */
                    }
                    et->et_st_collisions += ncoll;
                    et->et_flags &= ~ET_SQETEST;    /* If aborted due to collisions, no SQE test next time */
                }
                else
                {
                    /* no. of collisions may still be non-zero:
                     * TCB_COLL is only set when *excessive*
                     * collisions have occured
                     */
                    if (ncoll)
                    {
                        et->et_st_collisions += ncoll;
                    }

                    et->et_flags |= ET_SQETEST;
                }
                /* free transmit buffer */
                temp = LANCEaddress (et, (caddr_t) et->tcb_free);
                iowrite (tcb->link, temp);
                et->tcb_free = tcb;
                break;
            }

            case CB_NOP:
                temp = LANCEaddress (et, (caddr_t) et->nop_free);
                iowrite (cb->link, temp);
                et->nop_free = (struct obj_nop *) cb;
            case CB_CFG:
            case CB_IAS:
            case CB_DIA:
                switch (cb->command & CB_CMD)
                {
                    case CB_CFG:
                        et->et_flags &= ~ET_DOING_CFG;
                        break;

                    case CB_IAS:
                        et->et_flags &= ~ET_DOING_IAS;
                        break;

                    case CB_DIA:
                        et->et_flags &= ~ET_DOING_DIA;
                        break;

                    default:
                        break;
                }
                dprintf (("", "c=%d, s=%x\n", cb->command & CB_CMD, cb->status & 0xffff));
                if ((cb->status & CB_OK) == 0)
                {
                    sprintf (et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff);
                    dprintf (("", "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff));
                }
                break;

#ifdef  ET_TDR
            case CB_TDR:
                et->et_watch.tdr = 0;
                if ((cb->status & CB_OK) == 0)
                {
                    if (cb->status & CB_BUSY)
                    {
                        /* The SIA is not an INTEL part */
                        sprintf (et_lastlog, "Unit %d: SIA cannot perform TDR\n", unit);
                        break;
                    }
                    sprintf (et_lastlog, "Unit %d: hardware problem: cmd=%d, status=0x%x\n",
                             unit, cb->command & CB_CMD, cb->status & 0xffff);
                }
                else
                {
                    struct obj_tdr *tdr = (struct obj_tdr *) cb;
                    register unsigned result = tdr->result;

                    if ((result & TDR_LNKOK) == 0)
                    {
                        register unsigned time = result & TDR_TIME;
                        unsigned tu = time / 10, tf = time % 10;

                        if (result & TDR_XCVR)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies transceiver problem\n", unit);
                        }
                        if (result & TDR_OPEN)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies cable open-circuit at %d.%d uS\n",
                                     unit, tu, tf);
                        }
                        if (result & TDR_SHORT)
                        {
                            sprintf (et_lastlog,
                                     "Unit %d: TDR implies cable short-circuit at %d.%d uS\n",
                                     unit, tu, tf);
                        }
                    }
                    else
                    {
                        sprintf (et_lastlog, "Unit %d: TDR implies cable is OK\n", unit);
                    }
                }
                et->et_flags &= ~ET_DOING_TDR;
                break;
#endif /* ET_TDR */

            default:
                sprintf (et_lastlog, "Unit %d: unexpected command %d interrupt, status %x\n",
                         unit, cb->command & CB_CMD, cb->status);
                break;

        }
        cb = cbn;
    }
}


void selectpage (struct et_softc *et, int n)
{
    iowrite (et->et_registers->page, n);
}


static caddr_t ARMaddress (struct et_softc *et, lanceaddr lanceptr)     /* lanceptr must be even */
{
    caddr_t ioaddr;

    if (((unsigned) lanceptr & 0xffff) == LANCE_NULL)
    {
        return (NULL);
    }
    ioaddr = (caddr_t) ((((unsigned) lanceptr & PAGEMASK) << 1) + (unsigned) et->et_dpram);
    return (ioaddr);
}


/* LANCEaddress for top page addresses */
lanceaddr LANCEaddress (struct et_softc * et, caddr_t ioaddr)
{
    if (ioaddr != NULL)
    {
        register unsigned offset = ioaddr - et->et_dpram;

        return ((lanceaddr) ((offset >> 1) | (TOPPAGE << PAGESHIFT)));
    }
    else
    {
        return (LANCE_NULL);
    }
}


/* allocate size bytes in TOPPAGE */
lanceaddr alloc_struct (struct et_softc *et, int size)
{
    lanceaddr nextstruct = et->last_struct - size;

    et->last_struct = nextstruct;
    return (nextstruct);
}


/* allocate buffer of bufsize, make sure it doesn't cross page boundary */
lanceaddr alloc_buffer (struct et_softc * et, int bufsize)
{
    lanceaddr nextfree = et->next_buffer;

    if (pageno (nextfree + bufsize - 1) != pageno (nextfree))
    {
        nextfree = ((pageno (nextfree) + 1)) << PAGESHIFT;
    }
    et->next_buffer = nextfree + bufsize;
    return (nextfree);
}


/**********************************************************************/

int et_stats (_kernel_swi_regs * r)
{
    struct stats *sptr;

    switch (r->r[0])
    {
        case 0:
            sptr = &st;
            break;

        case 1:
            sptr = &(et_softc[r->r[1]]->et_stats);
            break;

        default:
            return (EINVAL);
    }

    (void) memcpy ((char *) (r->r[2]), (char *) sptr, sizeof (*sptr));
    return (0);
}

/**********************************************************************/

/*
 * stats_init - initialise stats structures
 */
void stats_init (struct et_softc *et)
{
    int i;

    /*
     * actual statistics structure is easy - only one field to set
     */
    et->et_st_interface_type = ST_TYPE_10BASE5N2;

    /*
     * now fill in struct st which describes
     * the stats. this interface supports.
     */
    st.st_interface_type = 0xff;
    st.st_link_status = 0xff;
    st.st_link_polarity = 0;
    st.st_blank1 = 0;
    st.st_link_failures = 0;
    st.st_network_collisions = 0;
    st.st_collisions = ~0;
    st.st_excess_collisions = 0;
    st.st_heartbeat_failures = 0;
    st.st_not_listening = 0;
#if 0
    st.st_net_error = 0;
#endif
    st.st_tx_frames = ~0;
    st.st_tx_bytes = ~0;
    st.st_tx_general_errors = ~0;
    st.st_crc_failures = 0;
    st.st_frame_alignment_errors = 0;
    st.st_dropped_frames = 0;
    st.st_runt_frames = ~0;
    st.st_overlong_frames = 0;
    st.st_jabbers = 0;
    st.st_late_events = 0;
    st.st_unwanted_frames = ~0;
    st.st_rx_frames = ~0;
    st.st_rx_bytes = ~0;
    st.st_rx_general_errors = ~0;

    for (i = 0; i < 6; ++i)
    {
        st.st_last_dest_addr[i] = 0xff;
        st.st_last_src_addr[i] = 0xff;
    }

    do
    {
        st.st_last_dest_addr[i] = 0;
        st.st_last_src_addr[i] = 0;
        ++i;
    }
    while (++i < sizeof (st.st_last_dest_addr));
}

/**********************************************************************/

extern void et_runtest (int unit)
{
    struct et_softc *et = et_softc[unit];

    /*
     * only bother if the card is not already diagnosed as faulty
     */
    if (!(et->et_flags & ET_FAULTY))
    {
        /*
         * pretend driver is disappearing while tests are performed
         */
        send_driverstatus (dibs[unit], 1);

        /*
         * driver will no longer be running after POST
         */
        et->et_flags &= ~ET_RUNNING;

        et_init_low (unit, 1);

        /*
         * XXX
         *
         * we're back!  the pretence that the driver has
         * disappeared while the tests were being run will
         * have confused the protocol modules which, when
         * they receive the `startup' service call will
         * try to reclaim the filters they already hold.
         */
        et->et_flags |= ET_DUPCLAIMEXPECTED;
        send_driverstatus (dibs[unit], 0);

        /*
         * if protocol modules have not reclaimed yet, then
         * they have lost the chance to do so
         */
        et->et_flags &= ~ET_DUPCLAIMEXPECTED;
    }

    /*
     * analyse and print results
     */
    printf ("Driver et%d is ", unit);
    if (et->et_flags & ET_FAULTY)
    {
        printf ("faulty: %s\n", et_lasterr);
    }
    else
    {
        printf ("OK\n");
    }
}

/**********************************************************************/

/*
 * set_receive_level - either turn the hardware for the unit off
 * (if addrlevel = -1), or enable appropriate levels of packet
 * reception
 */



void set_receive_level (int unit, int addrlevel)
{
    struct et_softc *et = et_softc[unit];

    et->et_st_link_status &= ~(ST_STATUS_RXMASK);

    if (addrlevel == -1)
    {
        /* take the hardware down */
        etioctl (unit, 1, 0);

        et->et_st_link_status &= ~ST_STATUS_ACTIVE;
    }
    else
    {
        u_char status = ST_STATUS_DIRECT;

        if (addrlevel >= ADDRLVL_NORMAL)
        {
            /* broadcasts are OK */
            status = ST_STATUS_BROADCAST;
        }

        if (addrlevel >= ADDRLVL_MULTICAST)
        {
            /* multicasts are OK */
            status = ST_STATUS_PROMISCUOUS;
        }

        dprintf (("", "set_receive_level: addrlevel=%x\n", addrlevel));

        et->et_st_link_status |= (status | ST_STATUS_ACTIVE);
        issue_cmd (et, (struct obj_cb *) make_cfg (et, 0, 0, status));
    }
}
