/* -*-C-*-
 *
 * omniacc.c    OmniClient interface for Access and Access+
 *
 * Previously (C) ANT Limited 1994. All rights reserved.
 * (C) Acorn Computers Ltd 1996. All rights reserved.
 *
 * Borris, December 1994.
 *
 * 30-03-95 Borris  Serious hackings to get authenticated objects both
 *                  working and appearing as Access+ presents them, which
 *                  isn't entirely straightforward.
 * 31-03-95 Borris  Polishing.
 * 25-05-95 Borris  Removed requirement for Access+ logins having a
 *                  password, as this is thought awkward by Acorn.
 *                  (Acorn bug ID NET-00761)
 * 26-01-96 Borris  Changes so last interest in an authenticated mount
 *                  disappearing cause deregistration of the interest
 *                  with FreeWay.
 * 31-01-96 Borris  Unauthentication changes done in accordance with new
 * 	    	    specification - provide a new entry point to cause
 *		    authentication interests to be deregistered.
 * 01-02-96 Borris  Added new SWI call through to above register stuff.
 * 02-02-96 Borris  Minor presentation changes.
 * 11-06-96 NAS     Minor changes to bring up to SWI_Spec v1.01 for domain
 * 		    logon.
 * 12-06-96 NAS     SWI_Spec 1.02, removed _Reset SWI and supports OmniOp,17
 * 		    instead.
 * 26-06-96 NAS     SWI_Spec 1.03, errors for FreeSpace and InactiveMount
 */

typedef unsigned int uint;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>        /* For sig_atomic_t only - I don't use signals! */
#include <ctype.h>
#include <stdarg.h>

#include "kernel.h"
#include "swis.h"
#include "freeway.h"
#include "omni.h"
#include "omniacc.h"

static Error claim_omni(void);
static void release_omni(void);
static Error claim_freeway(void);
static void release_freeway(void);
static Error claim_sharefs(void);
static void release_sharefs(void);
static Error claim_free(void);
static void release_free(void);
static Error claim_upcall(void);
static void release_upcall(void);
/* static Error claim_timer(void);
static void release_timer(void); */

static Error schedule (uint reasons);


/* global buffer, shared by many things. */
/* ensure no re-entrancy conflicts possible */

#define GSIZE   256

static char gbuf[GSIZE];
static Error gerr = NoError;


static ClaimPair connect_list[] =
{
    {   resources_register,          resources_deregister       },
    {   claim_omni,                  release_omni               },
    {   claim_freeway,               release_freeway            },
    {   claim_sharefs,               release_sharefs            },
    {   claim_free,                  release_free               },
    {   claim_upcall,                release_upcall             },
/*    {   claim_timer,                 release_timer              },*/
    {   NULL,                        NULL                       }
};

#if DEBUG
static char *act_names[4] = { "ARRIVAL", "DEPARTURE", "CHANGED", "DELETED" };
#endif

static int module_private_word;
static volatile uint state;
static struct authlist *auths;

volatile uint flags;

extern char *developed = "\n Developed by ANT Limited <sales@ant.co.uk> \n";

/*****************************************************************************
 *
 * The Upcall handler adds items to this list during the upcall and schedules
 * the callback handler to complete the processing.
 */

static struct up_action *pending_actions;

/*****************************************************************************/

server for_pseudo_accessplus =
{
    NULL,                   /* next server - none */
    NULL,                   /* omnireg * - Fill in later */

    (FreewayDescrip) 0u,    /* not really applicable */
    (unsigned char) 0u,     /* flags */
    0,                      /* at_offset */

    "Pseudo Access+ Object",
    NO_AUTHENT,
    (IPaddress) 0,

    "Access+",
    "Access+",
    "Logon Network\nRISC OS\n",

    NULL,
    NULL,
    NULL
};


/*****************************************************************************/

omnireg access_servers =
{
    SWI_BASE + 0,
    OMNI_SUPPORT_FILING  | OMNI_NOTREQUIRE_MOUNT,
    "04a900",
    "Acorn Access",
    "Acorn Access\n© Acorn Computers Ltd, 1997\n" VERSION " (17-Jan-97)",
    0u,
    "Share",
    NULL
};

/*****************************************************************************/

omnireg pseudo_accessplus =
{
    SWI_BASE + 1,
        OMNI_PSEUDO_SERVER |
        OMNI_SUPPORT_FILING |
        /*OMNI_REQUIRE_USERID |*/
        OMNI_REQUIRE_PASSWORD |      /* 25/5/95: borris: permit empty password */
        OMNI_REQUIRE_AUTHENT  |      /* 11/6/96: NAS: request 'domain name' v1.01 spec */
        OMNI_NOTREQUIRE_MOUNT
/*        (ACORN * OMNI_REQUIRE_MOUNTPATH)*/
    ,
    "04a901",
    "Acorn Access+",
    "Acorn Access+\n© Acorn Computers Ltd, 1997\n" VERSION " (17-Jan-97)",
    0u,
    "Share+",
    NULL
};


/*****************************************************************************/




/*****************************************************************************
 *
 */

#if DEBUG

FILE *debugfile;

static void debugrtn(char *msg, ...)
{
    static char buffer[1024];

    va_list arg;
    va_start(arg, msg);

/*    sprintf(buffer, "%08x: ", *(int*)0x10c);*/
    buffer[0] = 0;

    vsprintf(buffer + strlen(buffer), msg, arg);

    fputs(buffer, debugfile);

    sprintf(buffer, "\n");

    fputs(buffer, debugfile);
    fflush(debugfile);

    va_end(arg);
}

static void note_error(Error err)
{
    if ( err == NoError )
        return;

    dbg(("Error %s\n", err->errmess));
}

#else

#define note_error(e)

#endif

/*****************************************************************************
 *
 */


#if DEBUG
#if 0 
static void dump_state(char *ctx)
{
    server *sp;
    uint f = flags;

    dbg(("\nState dump: %s\n", ctx));

    dbg(("Flags: %x\n", f));

    if (f & HAVE_AUTHENTICATION)
        dbg(("HAVE AUTHENTICATION"));

    if (f & ACTIONS_SUSPENDED)
        dbg(("ACTIONS SUSPENDED"));

    if (f & CALLBACK_SCHEDULED)
        dbg(("CALLBACK SCHEDULED"));

    if (f & DONT_QUEUE_ACTIONS)
        dbg(("DONT QUEUE ACTIONS"));

    if (f & HIDDEN_ERROR)
        dbg(("HIDDEN ERROR"));

    if (f & LOST_OMNI)
        dbg(("LOST OMNI"));

    if (f & LOST_FREEWAY)
        dbg(("LOST FREEWAY"));

    if (f & LOST_SHAREFS)
        dbg(("LOST SHAREFS"));

    if (f & SEEN_OMNI)
        dbg(("SEEN OMNI"));

    if (f & SEEN_FREEWAY)
        dbg(("SEEN FREEWAY"));

    if (f & SEEN_SHAREFS)
        dbg(("SEEN SHAREFS"));

    if (f & REGISTERED_0)
        dbg(("REGISTERED 0"));

    if (f & REGISTERED_1)
        dbg(("REGISTERED 1"));

    if (f & REGISTERED_2)
        dbg(("REGISTERED 2"));

    /* if (f & DO_DISCONNECT)
        dbg(("DO DISCONNECT")); */

    if (f & DO_CONNECT)
        dbg(("DO CONNECT"));

    if (f & DO_ENUM_FREEWAY)
        dbg(("DO ENUM FREEWAY"));

    if (f & DO_UPCALL_ACTION)
        dbg(("DO UPCALL ACTION"));


    dbg(("Servers:"));

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
/*
        dbg(("Server %p, next %p, context %p, descrip %x, flags %x",
            sp,
            sp->next,
            sp->context,
            sp->descriptor,
            sp->flags));
*/
        if (sp->flags & SERVER_GONE)
            dbg(("SERVER GONE"));

        if (sp->flags & SERVER_HIDDEN)
            dbg(("SERVER HIDDEN"));

        if (sp->flags & SERVER_MOUNTED)
            dbg(("SERVER MOUNTED"));

        if (sp->flags & SERVER_FLAG)
            dbg(("SERVER FLAG"));

        if (sp->flags & SERVER_PSEUDO)
            dbg(("SERVER PSEUDO"));

        if (sp->flags & SERVER_ACCESSPLUS)
            dbg(("SERVER ACCESSPLUS"));

        dbg(("    objname %s, authent %x, addr %x", sp->objname, sp->authent, sp->address));
/*
        dbg(("short %s, full %s, description %s", sp->server_shortname, sp->server_fullname, sp->server_description));
        dbg(("short %s, full %s, mount name  %s\n", sp->mount_shortname, sp->mount_fullname, sp->mount_mountname));
*/
    }

    dbg(("*****************************************************************************"));
}
#endif
#endif

/*****************************************************************************
 *
 */

#if PARANOID

static void panic(char *msg, ...)
{
    static char buffer[1024];

    va_list arg;
    va_start(arg, msg);

    strcpy(buffer, "Panic: ");

    vsprintf(buffer + strlen(buffer), msg, arg);

    fputs(buffer, stdout);

    sprintf(buffer, "\n");

    fputs(buffer, stdout);
    fflush(stdout);

    va_end(arg);

    exit(1);
}

#endif

/*****************************************************************************/

#if DEBUG

static Error mycli(char *str)
{
    Error err;

    dbg(("CLI: %s", str));

    err = mycli_(str);

    if (err != NoError)
    {
        dbg(("Got error %s", err->errmess));
    }

    return err;
}

#else

#define mycli   mycli_

#endif

/*****************************************************************************/

/* These two functions come from Acorn and are the magic routines for   */
/* converting a password string to a freeway authentication value.      */
/* There is no ABI/API to access these. They are not defined. We have   */
/* to ensure either they never change or we keep up to date with Acorn  */
/* on any changes they make. How repulsive!                             */

static int encode_psw_char(char c)
{
    int i;
    c = toupper(c);
    if (isdigit(c))
        i = ((int) c - (int) '0') + 1;
    else
    if (isalpha(c))
        i = ((int) c - (int) 'A') + 11;
    else
        i = 0;
    return i;
}

static FreewayAuthent password_to_authent(char *buf)
{
    FreewayAuthent pin = 0;

    if (buf != NULL)
        for (; *buf; buf++)
        {
            pin *= 37;
            pin += encode_psw_char(*buf);
        }

    return pin;
}


/*****************************************************************************
 *
 *
 */

static void commit_suicide(void)
{
    dbg(("Commiting suicide"));

    suicide("OmniAccess");   /* Module title, as in rmkill OmniAccess */
}


/*****************************************************************************/

static char * strdup (char *str)
{
    char *new;

    if (str == NULL)
        return NULL;

    new = (char *) malloc( strlen(str) + 1 );

    if (new == NULL)
        return NULL;

    return strcpy(new, str);
}

/*****************************************************************************
 *
 *
 */

static char * strndup (char *str, int n)
{
    char *new;

    if (str == NULL)
        return NULL;

    new = (char *) malloc( n + 1 );

    if (new == NULL)
        return NULL;

    new[n] = '\0';

    return strncpy(new, str, n);
}

/*****************************************************************************
 *
 */

static int strieq(char *a, char *b)
{
    if (a == b)
        return 1;

    if (a == NULL || b == NULL)
        return 0;

    while (*a != 0 && *b != 0)
    {
        if (toupper(*a) != toupper(*b))
            return 0;
        a++;
        b++;
    }

    return toupper(*a) == toupper(*b);
}

static int strieqn(char *a, char *b, int len)
{
    if (a == b || len <= 0)
        return 1;

    if (a == NULL || b == NULL)
        return 0;

    while (*a != 0 && *b != 0 && len-- > 0)
    {
        if (toupper(*a) != toupper(*b))
            return 0;
        a++;
        b++;
    }

    return (len == 0) ? 1 : toupper(*a) == toupper(*b);
}



/*****************************************************************************
 *
 * Ensure that an association between a user name and a Freeway authentication
 * value exists in our dictionary.
 */


static struct authlist * find_authentN(FreewayAuthent auth, char *mntpre, int len)
{
    struct authlist *ap = auths;

    /*dbg(("Searching for %*s:%x in authlist", len, mntpre, auth));*/

    if (len == 0)
        return NULL;

    while (ap != NULL)
    {
        if ( ap->authent == auth && ap->len == len && strieqn(mntpre, ap->users_name, len) )
            return ap;
        ap = ap->next;
    }

    return NULL;
}

#if 0
static struct authlist * find_authent(FreewayAuthent auth, char *mntpre)
{
    return find_authentN(auth, mntpre, strlen(mntpre));
}
#endif

static struct authlist * stash_authent(FreewayAuthent auth, char *mntpre)
{
    struct authlist *ap = find_authentN(auth, mntpre, strlen(mntpre));
    args_FreewayRegister args;
    Error err;

    if (ap != NULL)
    {
        dbg(("Found authlist entry for %s:%x in authlist", ap->users_name, ap->authent));
        return ap;
    }

    /* Don't have an entry yet, try to create one */

    ap = calloc(sizeof(struct authlist), 1);

    if (ap == NULL || (ap->users_name = strdup(mntpre)) == NULL)
    {
        dbg(("Ran out of memory creating authlist entry"));

        if (ap != NULL)
            free(ap);

        return NULL;
    }

    args.flags = 2;                      /* Register authenticated interest*/
    args.type = FREEOBJ_DISCS;
    ap->authent = args.authent = auth;
    ap->len = strlen(ap->users_name);

    dbg(("Registering interest in authenticated objects for %s:%x", mntpre, auth));

    err = SWIX(Freeway_Register, &args, &args);

    if (err != NoError)
    {
        free(ap->users_name);
        free(ap);
        dbg(("Error %s when trying to register interest", err->errmess));
        return NULL;
    }

    {DISABLE_IRQS;
        ap->next = auths;
        auths = ap;
    RESTORE_IRQS;}

    return ap;
}


/*****************************************************************************
 *
 * 0 - don't mount this mount
 * 1 - mount this mount
 */

static int consider_accessplus_mount_name(server *sp)
{
    int rc;

#if ANT

    static int WARNING_the_ANT_option_isnt_properly_tried_yet;

    /* We never apply authentication restrictions on object display */
    rc = 1;

#else

    /* Acorn only get mounts if they tie up with the user's entered mount name */

    if (sp->at_offset == 0)
    {
        /* always permits unauthenticated objects through this filter */
        rc = 1;
    }
    else if (sp->authent == NO_AUTHENT)
    {
        /* Cannot yet determine if this should be displayed or not, so hide it */
        rc = 0;
    }
    else
    {
        /* Permit to be displayed if can find matching auth/prefix pair */
        rc = NULL != find_authentN(sp->authent, sp->objname, sp->at_offset);
    }

#endif

#if 0
    dbg(("Consider mountname on %s:%x gives %s",
        sp->objname,
        sp->authent,
        rc ? "YES" : "NO"
       ));
#endif

    if (rc)
        sp->flags |= SERVER_YES;
    else
        sp->flags &= ~ SERVER_YES;

    return rc;
}
/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied active mount.
 */

static uint bytes_to_enum_active_mount (server *sp)
{
    uint x = sizeof(server *) + sizeof(server *) + strlen(sp->mount_mountname) + 1 + 3;

    return x & ~ 3;
}

/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied mount.
 */

#if 0
static uint bytes_to_enum_mount (server *sp)
{
    uint x = sizeof(server *) + strlen(sp->mount_shortname) + strlen(sp->mount_fullname) + 1+1 + 3;

    return x & ~ 3;
}
#endif

/*****************************************************************************
 *
 * Calculate how many bytes of buffer space are required to enumerate the
 * supplied server.
 */

static uint bytes_to_enum_server (server *sp)
{
    uint x = sizeof(server *)
             + strlen(sp->server_shortname)
             + strlen(sp->server_fullname)
             + strlen(sp->server_description)
             + 1+1+1 + 3;

    return x & ~ 3;
}


/*****************************************************************************
 *
 */

static char * gen_server_shortname (up_action *up)
{
    char *cp = strndup(up->objname, 24);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_server_fullname (up_action *up)
{
    char *cp = strndup(up->objname, 64);

    return cp;
}

/*****************************************************************************
 *
 * Coded for little endian processor!
 */

static char * gen_server_description (up_action *up)
{
    char *cp = (char *) malloc(64), *cp2 = (char *) (&up->address);

    if (cp == NULL)
        return NULL;

    sprintf(cp, "%d.%d.%d.%d\nRISC OS", cp2[0], cp2[1], cp2[2], cp2[3]);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_shortname (up_action *up)
{
    char *cp = strndup(up->objname, 24);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_fullname (up_action *up)
{
    char *cp = strndup(up->objname, 64);

    return cp;
}

/*****************************************************************************
 *
 */

static char * gen_mount_mountname (up_action *up)
{
    char *cp = strndup(up->objname, 16);

    return cp;
}

/*****************************************************************************
 *
 *
 */

#if PARANOID

static volatile sig_atomic_t gbuf_sema;

static void claim_gbuf (void)
{
    DISABLE_IRQS;

    if (gbuf_sema == 0)
    {
        gbuf_sema = 1;
    }
    else
    {
               dbg(("Global buffer claim error\n"));
    }

    RESTORE_IRQS;

    return;
}

#else

#define claim_gbuf()

#endif

/*****************************************************************************
 *
 *
 */

#if PARANOID

static void release_gbuf (void)
{
    DISABLE_IRQS;

    if (gbuf_sema == 1)
    {
        gbuf_sema = 0;
    }
    else
    {
        dbg(("Global buffer free error\n"));
    }

    RESTORE_IRQS;

    return;
}

#else

#define release_gbuf()

#endif

/*****************************************************************************
 *
 * Free a server structure. Assume it is not currently linked into any chains.
 */

static void free_server (server *sp)
{
    if (sp == NULL)
        return;

    if (sp->objname != NULL)
        free(sp->objname);

    if (sp->server_shortname != NULL)
        free(sp->server_shortname);

    if (sp->server_fullname != NULL)
        free(sp->server_fullname);

    if (sp->server_description != NULL)
        free(sp->server_description);

    if (sp->mount_shortname != NULL)
        free(sp->mount_shortname);

    if (sp->mount_fullname != NULL)
        free(sp->mount_fullname);

    if (sp->mount_mountname != NULL)
        free(sp->mount_mountname);

    free(sp);
}

static void free_server_list(server *sp)
{
    while (sp != NULL)
    {
        server *tp = sp->next;
        free_server(sp);
        sp = tp;
    }
}

/*****************************************************************************/


static void remove_dead_servers(void)
{
    DISABLE_IRQS;

    server *sp = access_servers.servers;

    while ( sp != NULL && (sp->flags & SERVER_GONE) != 0 )
    {
        access_servers.servers = sp->next;
        dbg(("Removing dead server %s:%x", sp->objname, sp->authent));
        free_server(sp);
        sp = access_servers.servers;
        cause_server_enum(access_servers.client_id);
    }

    if (sp != NULL)
    {
        while (sp->next != NULL)
        {
            if (sp->next->flags & SERVER_GONE)
            {
                server *tp = sp->next->next;
                dbg(("Removing dead server %s:%x", sp->objname, sp->authent));
                free_server(sp->next);
                sp->next = tp;
                cause_server_enum(access_servers.client_id);
            }
            else
                sp = sp->next;
        }
    }

    RESTORE_IRQS;
}


/*****************************************************************************/


static void sharefsify(char *a, char *b)
{
    gbuf[0] = 0;

    if (a != NULL)
    {
        strcpy(gbuf, a);
        strcat(gbuf, " ");
    }

    strcat(gbuf, "Share::");
    strcat(gbuf, b);
    strcat(gbuf, ".$");
}

/*****************************************************************************/

/* static int visible_servers(void)
{
    server *sp;
    int vis = 0;

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
        if ( (sp->flags & SERVER_HIDDEN) == 0)
            vis += 1;

    return vis;
} */

static server *server_from_objname(server *sp, char *objname)
{
    while (sp != NULL)
    {
        if ( strieq(sp->objname, objname) )
        {
            return sp;
        }
        sp = sp->next;
    }

    return NULL;
}


/*****************************************************************************/

static server * create_server_from_upaction(up_action *up)
{
    server *sp = (server *) calloc(sizeof(server),1);
    char *cp;

    dbg(("Create server for %s", up->objname));

    if (sp == NULL)
        return sp;

    sp->objname = strdup(up->objname);
    sp->server_shortname = gen_server_shortname(up);
    sp->server_fullname  = gen_server_fullname(up);
    sp->server_description = gen_server_description(up);
    sp->mount_shortname = gen_mount_shortname(up);
    sp->mount_fullname = gen_mount_fullname(up);
    sp->mount_mountname = gen_mount_mountname(up);

    if (sp->objname == NULL
    || sp->server_shortname == NULL
    || sp->server_fullname == NULL
    || sp->server_description == NULL
    || sp->mount_shortname == NULL
    || sp->mount_fullname == NULL
    || sp->mount_mountname == NULL )
    {
        free_server(sp);
        return NULL;
    }

    cp = strchr(sp->objname, '@');
    sp->flags = 0;
    sp->descriptor = up->descriptor;
    sp->authent = up->authent;
    sp->address = up->address;

    if (cp == NULL)
    {
        sp->at_offset = 0;
    }
    else
    {
        sp->at_offset = cp - sp->objname;
        sp->flags |= SERVER_ACCESSPLUS | SERVER_HIDDEN;

        if (sp->authent == NO_AUTHENT)
        {
            /*dbg(("Triggering enumeration due to creation of '@' server with no authent"));*/
            schedule(DO_ENUM_FREEWAY);
        }

        if ( consider_accessplus_mount_name(sp) )
            sp->flags &= ~ SERVER_HIDDEN;
    }

    return sp;
}


/*****************************************************************************/

static void free_upaction(up_action *up)
{
    if (up == NULL)
        return;

    if (up->objname != NULL)
        free(up->objname);

    free(up);
}

/*****************************************************************************/

static server * server_from_fullname(server *sp, char *fullname)
{
    while (sp != NULL)
    {
        if (strieq(sp->server_fullname, fullname))
            return sp;

        sp = sp->next;
    }

    return NULL;
}

/*****************************************************************************/

static void add_up_action(up_action *up)
{
    if (up != NULL)
    {
        DISABLE_IRQS;

            up->next = pending_actions;
            pending_actions = up;

            schedule(DO_UPCALL_ACTION);

        RESTORE_IRQS;

        dbg(("Added up action %s for %s:%x", act_names[up->action], up->objname, up->authent));
    }
}

/*****************************************************************************
 *
 * Start interacting with the Free module.
 */

static Error claim_free (void)
{
    return NoError;
}

/*****************************************************************************
 *
 * Release interaction with the Free module.
 */

static void release_free (void)
{
    return;
}

/*****************************************************************************
 *
 * Register an interest in unauthenticated disc objects. Registration for
 * authenticated objects is performed when we are supplied the user,key pairs
 * via the pseudo server.
 */

static Error claim_freeway(void)
{
    args_FreewayRegister args;

    args.flags = 0;             /* Register interest */
    args.type = FREEOBJ_DISCS;
    args.authent = NO_AUTHENT;

    dbg(("claiming freeway"));

    return SWIX(Freeway_Register, &args, &args);
}

/*****************************************************************************
 *
 * Deregister all interest in Freeway objects. This includes both
 * authenticated and unauthenticated disc objects. Memory is not actually
 * freed by this routine (see post_final). Remember that a given authent
 * value can occur multiply, and that
 * a particular authent value should only be de-registered once.
 */

static void deregister_authenticated(struct authlist *ap)
{
    args_FreewayRegister args;
    Error err;

    args.flags = 3;                             /* Deregister authenticated*/
    args.type = FREEOBJ_DISCS;
    args.authent = ap->authent;

    dbg(("Releasing freeway interest in %s:%x", ap->users_name, ap->authent));

    err = SWIX(Freeway_Register, &args, &args);

#if PARANOID
    if (err != NULL)
        dbg(("Error %s when deregistering freeway interest", err->errmess));
#endif
}

static void release_freeway(void)
{
    args_FreewayRegister args;
    Error err;
    struct authlist *ap;

    if (flags & LOST_FREEWAY)
        return;

    dbg(("Releasing all Freeway registrations"));

    args.flags = 1;                           /* Deregister unauthenticated*/
    args.type = FREEOBJ_DISCS;
    args.authent = NO_AUTHENT;

    err = SWIX(Freeway_Register, &args, &args);

#if PARANOID
    if (err != NoError)
        dbg(("Error %s when de-registering unauthenticated interest", err->errmess));
#endif

    for (ap = auths; ap != NULL; ap = ap->next)
    {
        deregister_authenticated(ap);
    }

    return;
}

/*****************************************************************************
 *
 *
 */

/* static Error claim_timer(void)
{
   _kernel_swi_regs r;

   r.r[0] = TickerV;
   r.r[1] = (int) timer_veneer;
   r.r[2] = (int) module_private_word;

   dbg(("Claiming timer"));

   return SWIX(OS_Claim, &r, &r);
} */

/*****************************************************************************
 *
 *
 */

/* static void release_timer(void)
{
   _kernel_swi_regs r;

   r.r[0] = TickerV;
   r.r[1] = (int) timer_veneer;
   r.r[2] = (int) module_private_word;

   dbg(("Releasing timer"));

   (void) SWIX(OS_Release, &r, &r);

   return;
} */

/*****************************************************************************
 *
 *
 */

static Error claim_upcall(void)
{
   _kernel_swi_regs r;

   r.r[0] = UpcallV;
   r.r[1] = (int) upcall_veneer;
   r.r[2] = (int) module_private_word;

   dbg(("Claiming upcalls"));

   return SWIX(OS_Claim, &r, &r);
}

/*****************************************************************************
 *
 *
 */

static void release_upcall(void)
{
   _kernel_swi_regs r;

   r.r[0] = UpcallV;
   r.r[1] = (int) upcall_veneer;
   r.r[2] = (int) module_private_word;

   dbg(("Releasing Upcalls"));

   (void) SWIX(OS_Release, &r, &r);

   return;
}

/*****************************************************************************
 *
 * No claiming actions currently known for ShareFS, but hook provided.
 */

static Error claim_sharefs(void)
{
    dbg(("Claiming ShareFS - no actions"));

    return NoError;
}

/*****************************************************************************
 *
 * No releasing actions currently known for ShareFS, but hook provided.
 */

static void release_sharefs(void)
{
    dbg(("Releasing ShareFS"));

    if (flags & LOST_SHAREFS)
        return;

    return;
}

/*****************************************************************************
 *
 * We place two connections to OmniClient for Access, and another two for
 * Access+, if present. The first of each of these connections is where a
 * new disc object appears. The second is present for pseudo server purpose,
 * to give us something to log on through.
 */

static Error claim_omni2(omnireg *orp)
{
    args_OmniRegisterClient args;
    Error err;

    args.client_id = orp->client_id;
    args.client_flags = orp->client_flags;
    args.sprite_name = orp->sprite_name;
    args.client_name = orp->client_name;
    args.client_description = orp->client_description;
    args.site_word = orp->site_word;
    args.fs_name = orp->fs_name;

    err = SWIX(Omni_RegisterClient, &args, &args);

    note_error(err);

    return err;
}

static Error claim_omni(void)
{
    Error err;

    dbg(("Claiming OmniClient"));

    if ( ( err = claim_omni2(&access_servers) ) == NULL )
    {
        flag_set(REGISTERED_0);
    }

    if (err != NoError || (flags & HAVE_AUTHENTICATION) == 0)
        return err;

    if ( ( err = claim_omni2(&pseudo_accessplus) ) == NULL )
    {
        flag_set(REGISTERED_1);
    }


    return err;
}

/*****************************************************************************
 *
 * Deregister all our claims with OmniClient.
 */

static void release_omni(void)
{
    uint f;

    args_OmniDeregisterClient args;

    dbg(("Releasing OmniClient"));

    if (flags & LOST_OMNI)
        return;

    f  = flag_clr(REGISTERED_0 | REGISTERED_1  );
    f &=          REGISTERED_0 | REGISTERED_1   ;

    if (f & REGISTERED_0)
    {
        args.client_id = access_servers.client_id;
        (void) SWIX(Omni_DeregisterClient, &args, &args);
    }

    if (f & REGISTERED_1)
    {
        args.client_id = pseudo_accessplus.client_id;
        (void) SWIX(Omni_DeregisterClient, &args, &args);
    }

    return;
}

/*****************************************************************************
 *
 * Release a set of claims from a list.
 */

static void release_from_list (ClaimPair *list)
{
    ClaimPair *ptr = list;

    dbg(("Releasing from list"));

    while (ptr->release != NULL)
    {
        ptr += 1;
    }

    while (ptr != list)
    {
        ptr -= 1;

        (*ptr->release) ();
    }

    dbg(("Released from list"));

    return;
}

/*****************************************************************************
 *
 * Run down a ClaimPair list, claiming facilities. If an error occurs,
 * backtrack and execute the release functions and return the error. Returns
 * NoError if all the claim functions successfully terminated. The higher
 * index end of the table is denotated through a pair of NULL entries.
 */

static Error claim_from_list (ClaimPair *list)
{
    ClaimPair *ptr = list;
    Error e = NoError;

    dbg(("Starting to claim from list"));

    do
    {
        e = (*ptr->claim) ();

        ptr += 1;
    } while ( e == NoError && ptr->claim != NULL );

    if ( e == NoError )
    {
        dbg(("Successfully claimed from list\n"));

        return e;
    }

    dbg(("Failed to claim from list - reversing claims"));

    while (ptr != list)
    {
        ptr -= 1;

        (*ptr->release) ();
    }

    dbg(("Finished reversing claims - idle state restored"));

    return e;
}

/*****************************************************************************
 *
 * This routine determines if the required modules are present. This must be
 * done in a fashion without side effects.
 *
 * We use OS_Module to perform a lookup on the desired module's name. For
 * Freeway and ShareFS we also use the version number to decide whether we
 * have a system capable of supporting Freeway authentication.
 */

static int necessary_modules_present (int std)
{
    static char *table [] =
    {
        "Freeway",      /* first checked */
        "ShareFS",      /* second checked */
        "OmniClient",
        "ResourceFS",
        "Free"
    };

    int i;
    int no_auth = 0;

    for (i = 0; i < sizeof(table) / sizeof(table[0]); i++)
    {
        _kernel_swi_regs r;
        _kernel_oserror *ep;
        char *cp;
        int n;

        r.r[0] = 18;        /* Lookup module name */
        r.r[1] = (int) table[i];

        ep = _kernel_swi(XOS_Bit + OS_Module, &r, &r);

        if (ep != NULL)
        {
            dbg(("Module %s not present yet", table[i]));

            return 0;
        }

        switch (i)
        {
            case 0:
                if (!std)
                    flag_set(SEEN_FREEWAY);
                break;

            case 1:
                if (!std)
                    flag_set(SEEN_SHAREFS);
                break;
/*
            case 2:
                if (!std)
                    flag_set(SEEN_OMNI);
                break;
*/
        }

        if (i > 1)
            continue;

        n = r.r[3];

        n += ((int *)n) [0x14 / sizeof(int) ];

        cp = (char *) n;
/*
        dbg(("Checking modules: %s", cp));
*/
        cp = strchr(cp, '(');

        if (cp == NULL || cp[-4] != '.')
            continue;

        n  = (cp[-5] - '0') * 100;
        n += (cp[-3] - '0') * 10;
        n += (cp[-2] - '0') * 1;
/*
        dbg(("Got version of %d", n));
*/
        if (i == 0 && n < MAGIC_FREEWAY_VERSION)
            no_auth = 1;

        if (i == 1 && n < MAGIC_SHAREFS_VERSION)
            no_auth = 1;
    }

    dbg(("All necessary modules present"));

    if (no_auth)
        flag_clr(HAVE_AUTHENTICATION);
    else
        flag_set(HAVE_AUTHENTICATION);

    return 1;
}
/*****************************************************************************
 *
 * Perform whatever close down type actions are necessary to cease using
 * a server. This includes dismounting it and closing its windows.
 */

static Error shutdown_server(server *sp, uint flags)
{
    Error err;

    if (sp == NULL)
        return ENOSERVER;

    if (sp->flags & SERVER_MOUNTED)
    {
        dbg(("OmniOp_Dismount server '%s', %x", sp->mount_fullname, flags));
        claim_gbuf();
        if (flags & SHUT_CLOSEDIR)
        {
            sharefsify("filer_closedir", sp->objname);
            err = mycli(gbuf);
            note_error(err);
        }
        if (flags & SHUT_DISMOUNT)
        {
            strcpy(gbuf, "share:dismount :");
            strcat(gbuf, sp->objname);
            err = mycli(gbuf);
            note_error(err);
        }
        release_gbuf();
        sp->flags &= ~ SERVER_MOUNTED;
        if (state == RUNNING && (flags & SHUT_ENUMERATE) != 0)
        {
            cause_mounts_enum(sp->context->client_id);
            cause_server_enum(sp->context->client_id);
        }
    }
    else
    {
          dbg(("Not mounted: %s", sp->objname));
          err = ENOSUCHSERVER(sp->objname);
    }

    return err;
}

/*****************************************************************************
 *
 * Perform the upcall actions currently queued up. This will only be called
 * when upcall action processing is not suspended. This can trigger OmniClient
 * enumeration requests. If these arrive during this processing, then maybe
 * things won't work quite so well!
 */

static void perform_upcall_actions (void)
{
    struct up_action *curr = NULL, *revd = NULL;
    server *sp;

    /* Atomically remove currently queued actions */

    DISABLE_IRQS;
        struct up_action *acts = pending_actions;
        pending_actions = NULL;
    RESTORE_IRQS;

    dbg(("Performing queued upcall actions"));

    /* Reverse action list to get requests in correct order */

    while (acts != NULL)
    {
        struct up_action *next = acts->next;

        acts->next = NULL;

        if (curr == NULL)
        {
            curr = revd = acts;
        }
        else
        {
            curr->next = acts;
            curr = acts;
        }

        acts = next;
    }

    /* Process correctly ordered actions list */

    while (revd != NULL)
    {
        up_action *next = revd->next;
        sp = server_from_objname(access_servers.servers, revd->objname);

        switch (revd->action)
        {
            case FREEACT_ARRIVAL:
                if (sp == NULL)
                {
                    sp = create_server_from_upaction(revd);

                    if (sp == NULL)
                    {
                        flag_set(HIDDEN_ERROR);
                        dbg(("Failed to create server for %s:%x", revd->objname, revd->authent));
                    }
                    else
                    {
                        omnireg *rp = &access_servers;/* omnireg_from_authent(revd->authent);*/

                        DISABLE_IRQS;
                            sp->next = rp->servers;
                            sp->context = rp;
                            rp->servers = sp;
                        RESTORE_IRQS;

                        cause_server_enum(rp->client_id);

                        dbg(("Added new object %s:%x", revd->objname, revd->authent));
                    }
                }
                else
                {
                    dbg(("Already got object %s:%x - rescheduling as change", sp->objname, sp->authent));

                    revd->action = FREEACT_CHANGED;

                    add_up_action(revd);
                    revd = NULL;
                }
                break;

            case FREEACT_DEPARTURE:
            case FREEACT_DELETED:
                if (sp == NULL)
                {
                    dbg(("Object %s:%x not exist - force freeway enumeration", revd->objname, revd->authent));

                    schedule(DO_ENUM_FREEWAY);
                }
                else
                {
                    if (sp->flags & SERVER_MOUNTED)
                    {
                        shutdown_server(sp, SHUT_ENUMERATE | SHUT_DISMOUNT);
                    }

                    sp->flags |= SERVER_GONE | SERVER_HIDDEN;

                    cause_server_enum(sp->context->client_id);

                    dbg(("Freeway object departure/deletion %s:%x", sp->objname, sp->authent));
                }
                break;

            case FREEACT_CHANGED:
                if ( sp != NULL )
                {
                    int old = 0, new = 0;

                    old |= (sp->descriptor & OBJDESC_HIDDEN) ? 1 : 0;
                    old |= (sp->flags & SERVER_YES) ? 2 : 0;

                    sp->descriptor = revd->descriptor;

                    if (revd->authent != NO_AUTHENT)
                    {
                        if (sp->authent != revd->authent)
                        {
                            dbg(("Latched onto %x as authent value for %s", revd->authent, sp->objname));
                            sp->authent = revd->authent;
                            new |= 4;
                        }
                    }

                    new |= (sp->descriptor & OBJDESC_HIDDEN) ? 1 : 0;
                    new |= consider_accessplus_mount_name(sp) ? 2 : 0;

                    if ( new != old )
                    {
                        dbg(("Change information: new %x, old %x", new, old));

                        sp->flags &= ~ SERVER_MOUNTED;
                        sp->flags |= SERVER_HIDDEN;

                        if ( (revd->descriptor & OBJDESC_HIDDEN) == 0 && consider_accessplus_mount_name(sp) )
                            sp->flags &= ~ SERVER_HIDDEN;

                        dbg(("Causing server enum due to %s:%x", sp->objname, sp->authent));

                        cause_server_enum(sp->context->client_id);
                    }
                    else
                        dbg(("%s:%x - noted nothing significant in %x", sp->objname, sp->authent, new));
                }
                else
                {
                    dbg(("Object %s:%x has changed but not found - force freeway enum", revd->objname, revd->authent));

                    schedule(DO_ENUM_FREEWAY);
                }
                break;
        }

        free_upaction(revd);    /* Maybe NULL */

        revd = next;
    }

    return;
}


/*****************************************************************************
 *
 * Assume disc objects only.
 */

static up_action *make_up_action
(
    uint act,
    char *name,
    FreewayDescrip descrip,
    IPaddress addr,
    FreewayAuthent auth
)
{
    up_action *up = (up_action *) malloc(sizeof(*up));

    if (up == NULL)
        return NULL;

    if ( (up->objname = strdup(name)) == NULL)
    {
        free(up);
        return NULL;
    }

    up->next = NULL;
    up->action = act;
    up->type = FREEOBJ_DISCS;
    up->descriptor = descrip;
    up->address = addr;
    up->authent = auth;

    return up;
}


/*****************************************************************************
 *
 * Enumerate all available Freeway objects and ensure that our view of the
 * current objects ties up with Freeway's. This can cause object deletion,
 * addition and changing, just like the upcall.
 */

static void enumerate_access(void)
{
    server *sp;
    up_action *up;
    Error err;
    int f;

    args_FreewayEnumerate args;

    /* if (flag_clr(SEEN_SHAREFS) || flag_clr(SEEN_FREEWAY)) return; */
    claim_gbuf();

    args.flags = 0;         /* Unauth objects */
    args.type = FREEOBJ_DISCS;
    args.name_buffer = & gbuf[0];
    args.descriptor_buffer = & gbuf[GSIZE / 2];
    args.context = 0;
    args.authent = NO_AUTHENT;

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Catch only Access servers */
        if ( (sp->flags & SERVER_ACCESSPLUS) == 0)
            sp->flags |= SERVER_FLAG;
        else
            sp->flags &= ~ SERVER_FLAG;
    }

    do
    {
        args.name_length = GSIZE / 2;
        args.descriptor_length = GSIZE / 2;

        err = SWIX(Freeway_Enumerate, &args, &args);

        f = (err == NoError && args.context != -1);

#if PARANOID
        if (err != NULL)
            dbg(("Error %s when enumerating access", err->errmess));
#endif

        if (f)
        {
            /* Either this server is previously unknown or it has changed */

            /*dbg(("Access enumeration found %s:%x", args.name_buffer, args.authent));*/

            sp = server_from_objname(access_servers.servers, args.name_buffer);

            if (sp != NULL)
                sp->flags &= ~ SERVER_FLAG;     /* Note still exists */

            up = make_up_action(sp == NULL ? FREEACT_ARRIVAL : FREEACT_CHANGED,
                                args.name_buffer,
                                (FreewayDescrip) args.descriptor_buffer[0],
                                args.address,
                                NO_AUTHENT);

            if (up == NULL)
            {
                f = 0;
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    } while (f);

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Will only look for Access servers - not Access+ servers */

        if (sp->flags & SERVER_FLAG)
        {
            /* Server has disappeared since our last observations */

            dbg(("Server seems to have disappeared %s:%x", sp->objname, sp->authent));

            up = make_up_action(FREEACT_DEPARTURE, sp->objname, sp->descriptor, sp->address, sp->authent);

            if (up == NULL)
            {
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    }

    release_gbuf();

    return;
}

/*****************************************************************************
 *
 * Enumerate all available freeway authenticated disc objects and ensure we
 * are up to date with them.
 */

static void enumerate_accessplus(void)
{
    struct authlist *ap;
    server *sp;
    up_action *up;
    args_FreewayEnumerate args;
    int f;
    Error err;

    /* if (flag_clr(SEEN_SHAREFS) || flag_clr(SEEN_FREEWAY)) return; */
    claim_gbuf();

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Only catch Access+ servers */
        if ( (sp->flags & SERVER_ACCESSPLUS) == SERVER_ACCESSPLUS )
        {
            sp->flags |= SERVER_FLAG;
        }
        else
        {
            sp->flags &= ~ SERVER_FLAG;
        }
    }

    for (ap = auths; ap != NULL; ap = ap->next)
    {
        args.flags = 1;         /* Auth objects only */
        args.type = FREEOBJ_DISCS;
        args.name_buffer = & gbuf[0];
        args.descriptor_buffer = & gbuf[GSIZE / 2];
        args.context = 0;
        args.authent = ap->authent;

        /* Will do more work than necessary when have same key for different */
        /* 'users name' values. */

        dbg(("Enumerating on authentication value of %s:%x", ap->users_name, ap->authent));

        do
        {
            args.name_length = GSIZE / 2;
            args.descriptor_length = GSIZE / 2;

            err = SWIX(Freeway_Enumerate, &args, &args);

            f = (err == NoError && args.context != -1);

#if PARANOID
            if (err != NULL)
                dbg(("Error %s enumerating Access+", err->errmess));
#endif

            if (f)
            {
                /*dbg(("Access+ enumeration found %s:%x", args.name_buffer, args.authent));*/

                /* Either this server is previously unknown or it has changed */

                sp = server_from_objname(access_servers.servers, args.name_buffer);

                if (sp != NULL)
                {
                    sp->flags &= ~ SERVER_FLAG;     /* Note still exists */
                    /*dbg(("Cancelled server flag on %s:%x", sp->objname, sp->authent));*/
#if PARANOID
                    if (args.authent != ap->authent)
                        dbg(("SWI has overridden %x with %x", ap->authent, args.authent));

                    if ( sp->authent != NO_AUTHENT && sp->authent != ap->authent )
                        dbg(("Auth %x appears to override %x for %s", ap->authent, sp->authent, sp->objname));

                    if ( strchr(sp->objname, '@') == NULL )
                        dbg(("%s:%x doesn't appear to be an authenticated object?", sp->objname, sp->authent));
#endif
                    if (sp->authent == NO_AUTHENT)
                    {
#if PARANOID
                        if ( (sp->flags & SERVER_HIDDEN) == 0)
                            dbg(("Server %s not hidden when would expect it to be", sp->objname));
#endif
                        dbg(("Now got authent %x for %s", ap->authent, sp->objname));
                        sp->authent = ap->authent;
                        if ( consider_accessplus_mount_name(sp) )
                            sp->flags &= ~ SERVER_HIDDEN;
                    }
                }

                up = make_up_action(sp == NULL ? FREEACT_ARRIVAL : FREEACT_CHANGED,
                                    args.name_buffer,
                                    (FreewayDescrip) args.descriptor_buffer[0],
                                    args.address,
                                    ap->authent);

                if (up == NULL)
                {
                    f = 0;
                    flag_set(HIDDEN_ERROR);
                }
                else
                    add_up_action(up);
            }
        } while (f);
    }

    for (sp = access_servers.servers; sp != NULL; sp = sp->next)
    {
        /* Will only catch Access+ servers - not Access servers */

        if (sp->flags & SERVER_FLAG)
        {
            /* Server has disappeared since our last observations */

            dbg(("Server %s:%x seems to have disappeared", sp->objname, sp->authent));

            up = make_up_action(FREEACT_DEPARTURE, sp->objname, sp->descriptor, sp->address, sp->authent);

            if (up == NULL)
            {
                flag_set(HIDDEN_ERROR);
            }
            else
                add_up_action(up);
        }
    }

    release_gbuf();

    return;
}

/*****************************************************************************/

static void ripple_any_changes(void)
{
    do
    {
        enumerate_access();
        if (flags & HAVE_AUTHENTICATION)
            enumerate_accessplus();

        perform_upcall_actions();
    } while ( flag_clr(DO_ENUM_FREEWAY) & DO_ENUM_FREEWAY );
}

/*****************************************************************************
 *
 * The necessary modules are present and we have successfully established
 * the necessary connections to them. We are now in a position to create the
 * necessary servers and pseudo servers. Whether the current version of
 * Freeway and Access support authenticated objects is also now known.
 *
 * The necessary structure for the pseudo servers has pre-initialised - we
 * just have to ensure they get enumerated.
 */

static Error create_initial_servers (void)
{
    args_OmniEnumerateMounts args;
    Error err;

    args.type = 0;                  /* Enumerate servers/mounts */

    dbg(("Create initial servers"));

    if (flags & REGISTERED_0)
    {
        args.client_id = access_servers.client_id;
        err = SWIX(Omni_EnumerateMounts, &args, &args);
        if (err != NoError)
            return err;
        else
            dbg(("Registered Access server successfully"));
    }

    if (flags & REGISTERED_1)
    {
        args.client_id = pseudo_accessplus.client_id;
        err = SWIX(Omni_EnumerateMounts, &args, &args);
        if (err != NoError)
            return err;
        else
            dbg(("Registered Access+ server successfully"));
    }

    /* Pick up existing servers with the standard enumeration */

    return schedule(DO_ENUM_FREEWAY);
}

/*****************************************************************************/

extern RETURNMETHOD timer_handler (_kernel_swi_regs *regs, void *pw)
{
    return VIAR14;
}

/*****************************************************************************/

static void module_finalise(void)
{
    server *sp;
    struct authlist *ap;
    up_action *up;

    dbg(("\nModule finalise - hidden error is %s", flags & HIDDEN_ERROR ? "YES" : "NO"));

    {
        DISABLE_IRQS;

        if (flags & CALLBACK_SCHEDULED)
        {
            _kernel_swi_regs r;
            r.r[0] = (int) /* callback_veneer */ bounce_cb;
            r.r[1] = module_private_word;

            (void) _kernel_swi(XOS_Bit + OS_RemoveCallBack, &r, &r);

            flags &= ~CALLBACK_SCHEDULED;
        }

        RESTORE_IRQS;
    }

    if (state == RUNNING)
    {
        state = DYING;

        for (sp = access_servers.servers; sp != NULL; sp = sp->next)
            (void) shutdown_server(sp, SHUT_DISMOUNT | SHUT_CLOSEDIR);

        release_from_list( connect_list );
    }

    free_server_list(access_servers.servers);

    for (ap = auths; ap != NULL; )
    {
        struct authlist *tp = ap->next;
        free(ap->users_name);
        free(ap);
        ap = tp;
    }

    for (up = pending_actions; up != NULL; )
    {
        struct up_action *tp = up->next;
        free(up->objname);
        free(up);
        up = tp;
    }

    dbg(("Post final - freeing servers"));

#if DEBUG
    fflush(debugfile);
    fclose(debugfile);
#endif

    return;
}

/*****************************************************************************
 *
 * Schedule the happening of various actions. Currently, these happen from
 * within a callback.
 * [The use of a callback gives us more stack, makes actions occur when the
 * OS is not currently threaded and schedules actions so that presence/
 * absence of SWIs, etc is more defined.]
 */

static Error schedule (uint reasons)
{
    _kernel_swi_regs r;
    Error ep = NoError;

    DISABLE_IRQS;

    if ( flags & CALLBACK_SCHEDULED )
    {
        flags |= reasons;
    }
    else
    {
        r.r[0] = (int) /* callback_veneer */ bounce_cb;
        r.r[1] = module_private_word;

        if (_kernel_swi(XOS_Bit + OS_AddCallBack, &r, &r) == NoError)
        {
            flags |= reasons | CALLBACK_SCHEDULED;
        }
        else
        {
            dbg(("\nFAILED TO SCHEDULE 0X%X\n", reasons));
            flags |= HIDDEN_ERROR;
        }
    }

    RESTORE_IRQS;

    return ep;
}

/*****************************************************************************
 *
 * UPcall handler
 *
 * We are not notified of the authentication value associated with autheneticated
 * objects via the UpCall (an Acorn design bug, IMHO), so any change on what
 * appears to be an authenticated object (has an '@' character in the name!)
 * triggers an enumeration of the Access+ object list in it's entirety. This
 * is potentially grossly inefficient (verging on N*N overhead), but there's not
 * much we can do.
 */


extern RETURNMETHOD upcall_handler(_kernel_swi_regs *regs, void *pw)
{
    up_action *up;

    if (regs->r[0] == UPCALL_FREEWAY)
    {
        dbg(("%s upcall for %s of type %d (r1=%x, r6=%x, r7=%x",
            act_names[regs->r[1]],
            (char *) regs->r[3],
            regs->r[2],
            regs->r[1],
            regs->r[6],
            regs->r[7]
           ));

        if ( (FreewayType) regs->r[2] == FREEOBJ_DISCS && (flags & DONT_QUEUE_ACTIONS) == 0 )
        {
            up = make_up_action((uint) regs->r[1],
                                (char *) regs->r[3],
                                * (FreewayDescrip *) regs->r[5],
                                (IPaddress) regs->r[6],
                                NO_AUTHENT );

            if ( up != NULL )
            {
                DISABLE_IRQS;

                    /* Add at head for ease - means must reverse list later */
                    up->next = pending_actions;
                    pending_actions = up;
                    schedule(DO_UPCALL_ACTION);
                RESTORE_IRQS;
            }
            else
            {
                flag_set(HIDDEN_ERROR);
            }
        }
    }

    return VIAR14;
}

/*****************************************************************************
 *
 * Attempt to connect to the necessary modules and go active.
 */

extern RETURNMETHOD callback_handler(_kernel_swi_regs *regs, void *pw)
{
    Error err;

    flag_clr(CALLBACK_SCHEDULED);

    if (flag_clr(DO_CONNECT) & DO_CONNECT)
    {
        if ( necessary_modules_present(1) && (flags & MUST_SEE) == MUST_SEE )
        {
            if ( (err = claim_from_list( connect_list )) == NoError )
            {
                if ( (err = create_initial_servers()) == NoError )
                {
                    state = RUNNING;
                    dbg(("State now running\n"));
                    flag_clr(DONT_QUEUE_ACTIONS | ACTIONS_SUSPENDED);
                }
                else
                {
                    dbg(("Error creating initial servers\n"));
                    note_error(err);
                    release_from_list( connect_list );
                    flag_set(HIDDEN_ERROR);
                }
            }
            else
            {
                note_error(err);
                flag_set(HIDDEN_ERROR);
            }
        }
    }


    if ( (flags & ACTIONS_SUSPENDED) == 0 && (flag_clr(DO_ENUM_FREEWAY) & DO_ENUM_FREEWAY) != 0 )
    {
        enumerate_access();

        if (flags & HAVE_AUTHENTICATION)
            enumerate_accessplus();
    }


    if (! (flags & ACTIONS_SUSPENDED) && (flag_clr(DO_UPCALL_ACTION) & DO_UPCALL_ACTION) )
    {
        perform_upcall_actions();
    }


    /* if (flag_clr(DO_DISCONNECT) & DO_DISCONNECT)
    {
        commit_suicide();
    } */

    /* Is this correct? MOVS or MOV ? */

    return VIAR14;
}

/*****************************************************************************/

extern _kernel_oserror *module_initialise(char *cmd_tail, int pbase, void *pw)
{
#if DEBUG
    debugfile = fopen("<omni$dir>.!OmniAcc", "w"); /* 17-01-97 NAS from adfs::4.$. */

    if (debugfile == NULL)
    {
        fprintf(stderr, "Failed to open debug file!\n");
        return EINTERNAL;
    }

#endif

    flags = DONT_QUEUE_ACTIONS | ACTIONS_SUSPENDED;
    state = WAITING;
    module_private_word = (int) pw;

    /* Make circular refs - last bit must be runtime initd! */


    for_pseudo_accessplus.context = &pseudo_accessplus;
    pseudo_accessplus.servers = &for_pseudo_accessplus;

    if (necessary_modules_present(0))
    {
        /* Assume present before us, so immediately usable */

        flags |= MUST_SEE;
    }

    atexit( &module_finalise );

    dbg(("OmniClient Access+ Client loaded\n"));

#if PARANOID
    dbg(("Paranoia code is active"));
#endif

    return schedule(DO_CONNECT);
}


/***************************************************************************/

#if 0
/* For each registered authenticated FreeWay interest, if there are no */
/* longer any servers using it, deregister the interest. */

static void check_authenticated_interests(void)
{
        server *sp;
        struct authlist *ap, **app;

        for (ap = auths; ap != NULL; ap = ap->next)
                ap->used = 0;

        for (sp = access_servers.servers; sp != NULL; sp = sp->next)
        {
                if ( (sp->flags & SERVER_ACCESSPLUS) == 0 )
                        continue;
                /* Might not be entirely correct - could we have an */
                /* authenticated mount that we choose to hide?      */
                if ( (sp->flags & (SERVER_GONE | SERVER_HIDDEN)) == 0 )
                        continue;
                ap = find_authentN(sp->authent, sp->objname, sp->at_offset);
                if (ap != NULL)
                        ap->used = 1;
        }

        for (app = &auths; (ap = *app) != NULL; )
        {
                if (ap->used == 0)
                {
                        *app = ap->next;
                        deregister_authenticated(ap);
                        free(ap);
                }
                else
                {
                        app = &ap->next;
                }
        }
}
#endif


/* deregister interest in all currently known authentications */

static _kernel_oserror * deregister_swi(_kernel_swi_regs *regs)
{
  struct authlist *auth;
  uint oldflags = flag_set(ACTIONS_SUSPENDED);

  for (auth = auths; auth; )
  {
    struct authlist *next = auth->next;
    deregister_authenticated(auth);
    free(auth);
    auth = next;
  }
  auths = NULL;
  /* This is dubious - want counter and only have latch */

  if ( (oldflags & ACTIONS_SUSPENDED) == 0)
      flag_clr(ACTIONS_SUSPENDED);

  return NoError;
}


/*****************************************************************************
 *
 * Perform the Omni actions. Somewhat blunt approach to implementation.
 * Given the context (client_id / swi number) we're operating in via the
 * orp parameter.
 */

static _kernel_oserror * normal_swi(uint swinum, _kernel_swi_regs *rp, omnireg *orp)
{
    Error err = NoError;
    server *sp;

    gerr = NoError;

    switch (rp->r[0])
    {
        case OmniOp_Mount:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               err = ENOSERVER;
               rp->r[1] = 0;
               break;
            }
            {
                args_OmniOpMount *args = (args_OmniOpMount *) rp;
                char *name = args->u.server;
                _kernel_swi_regs r;

                sp = server_from_fullname(orp->servers, name);
                dbg(("OmniOp_Mount: server name '%s'", name));
                switch (swinum)
                {
                    /* Access: */

                    case 0: /* Access */
                        if (sp == NULL)
                        {
                            claim_gbuf();

                            dbg(("Going ahunting for the server"));

                            sharefsify(NULL, name);
                            r.r[0] = 17;
                            r.r[1] = (int) gbuf;
                            err = SWIX(OS_File, &r, &r);

                            release_gbuf();

                            if (err == NoError)
                            {
                                /* Mount looks like it is available - try tickling */
                                /* things into it existing suitably for us */

                                uint oldflags = flag_set(ACTIONS_SUSPENDED);

                                dbg(("Forcing enumeration and upcall processing"));

                                enumerate_access();
                                if (flags & HAVE_AUTHENTICATION)
                                    enumerate_accessplus();

                                perform_upcall_actions();

                                dbg(("Forced enums - hunting again"));

                                sp = server_from_fullname(orp->servers, name);

                                if (sp == NULL)
                                    err = ENOSUCHSERVER(name);

                                /* This is dubious - want counter and only have latch */

                                if ( (oldflags & ACTIONS_SUSPENDED) == 0)
                                    flag_clr(ACTIONS_SUSPENDED);
                            }
                            else
                            {
                                dbg(("Got error hunting: %s", err->errmess));
                            }
                        }

                        if (sp != NULL && err == NoError)
                        {
                            if ( (sp->flags & SERVER_MOUNTED) == 0)
                            {
                                sp->flags |= SERVER_MOUNTED;
                                dbg(("Mounted it"));
                            }
                            else
                            {
                                dbg(("It was already mounted"));
                                err = ECONNECTED;
                                sp = NULL;
                            }
                        }
                	if (err != NoError)
                	    sp = NULL;
                	args->u.mount_id = sp;                       /* NULL or not*/
                        break;


                    case 1: /* Access+ Pseudo Server */
                        {
                            uint oldflags = flag_set(ACTIONS_SUSPENDED);
                            /* 25/5/95: Borris - permit empty password */
                            FreewayAuthent auth = args->password == NULL ? 0
                                           : password_to_authent(args->password);
                            struct authlist *ap;

                            if (args->u.server == NULL || strlen(args->u.server) == 0)
                            {
                                char *cp = args->u.server;
                                if (cp == NULL)
                                    cp = "";
                                err = ENOSUCHSERVER(cp);
                            }
#if 0
                            else if (args->password == NULL||strlen(args->password) == 0)
                            {
                                err = EPASSWD;
                            }
#endif
                            else if ( (ap = stash_authent(auth, args->u.server)) == NULL )
                            {
                                dbg(("Stashing authentication key failed"));
                                err = ENOMEM;
                            }
                            else
                            {
                                /*int vis = 0, oldvis = visible_servers();*/

                                dbg(("Access+ login with name %s, password %s and authent %x",
                                    args->u.server, args->password, auth));

                                enumerate_access();
                                enumerate_accessplus();
                                perform_upcall_actions();
#if 0
                                vis = visible_servers();

                                if (vis == oldvis)
                                    err = EPASSWD;
#endif
                                dbg(("Forced enumeration of Access+"));
                            }

                            /* This is dubious - want counter and only have latch */

                            if ( (oldflags & ACTIONS_SUSPENDED) == 0)
                                flag_clr(ACTIONS_SUSPENDED);

                            /* Indicate want connection window closed */
                            if (err == NoError)
                                sp = access_servers.servers;
                        }
                        
			/* 17-01-97: NAS: Correct return values to close window,
			 * since we don't know for many seconds if the auth login is valid
			 * or not, we always say "yea" unless an error.
			 */
                	if (err == NoError) args->u.mount_id = (void *) 1;
                	  else args->u.mount_id = 0;
                        break;
                }
            }
            break;


        case OmniOp_Dismount:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               err = ENOSERVER;
               break;
            }
            {
                args_OmniOpDismount *args = (args_OmniOpDismount *) rp;

                err = shutdown_server(args->mount_id, SHUT_DISMOUNT | SHUT_CLOSEDIR);
                /*check_authenticated_interests();*/
            }
            break;


        case OmniOp_EnumerateServers:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateServers *args = (args_OmniOpEnumerateServers *) rp;
                register server *sp = args->server_id;
                uint x;
                register char *cp;

                dbg(("OmniOp_EnumerateServers: %s", orp->fs_name));

                if (sp == NULL)
                {
                    START_ENUMERATION;
                    ripple_any_changes();
                    sp = orp->servers;
                }

                while (1)
                {
                    if (sp == NULL)
                    {
                        args->server_id = NULL;
                        DONE_ENUMERATION;
                        remove_dead_servers();
                        break;
                    }

                    if (sp->flags & SERVER_HIDDEN)
                    {
                        sp = sp->next;
                        continue;
                    }

                    if ( (x = bytes_to_enum_server(sp)) > args->size)
                    {
                        args->server_id = sp;
                        break;
                    }

                    dbg(("Enumerating server %s:%x", sp->server_fullname, sp->authent));

                    cp = args->buffer;
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    strcpy(cp, sp->server_shortname);
                    cp += strlen(cp) + 1;
                    strcpy(cp, sp->server_fullname);
                    cp += strlen(cp) + 1;
                    strcpy(cp, sp->server_description);
                    args->size -= x;
                    args->buffer += x;
                    sp = sp->next;
                }
            }
            break;


        case OmniOp_EnumerateMounts:
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateMounts *args = (args_OmniOpEnumerateMounts *) rp;
/*                server *sp = args->server_id;*/
/*                char *cp = args->server_name;*/
/*                uint x;*/

                dbg(("OmniOp_EnumerateMounts:"));

                args->mount_id = NULL;      /* Always finished! */
#if 0
                if (sp == NULL
                && (cp == NULL || (sp = server_from_fullname(orp->servers, cp)) == NULL) )
                {
                    if (args->server_id == NULL || cp == NULL)
                        err = ENOSERVER;
                    else
                        err = ENOSUCHSERVER(cp);
                    break;
                }

                if ( (sp->flags & SERVER_HIDDEN) != 0
                || (sp->flags & SERVER_MOUNTED) == 0
                || (x = bytes_to_enum_mount (sp) ) > args->size )
                    break;

                dbg(("OmniOp_EnumerateMounts on server %s", sp->server_fullname));

                cp = args->buffer;
                ((server **) cp)[0] = sp;
                cp += sizeof(server *);
                strcpy(cp, sp->mount_shortname);
                cp += strlen(cp) + 1;
                strcpy(cp, sp->mount_fullname);
                args->buffer += x;
                args->size -= x;
#endif
            }
            break;


        case OmniOp_EnumerateActiveMounts:
            dbg(("OmniOp_EnumerateActiveMounts"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
               rp->r[3] = NULL;
               break;
            }
            {
                args_OmniOpEnumerateActiveMounts *args = (args_OmniOpEnumerateActiveMounts *) rp;
                server *sp = args->mount_id;
                char *cp;
                uint x;

                if (sp == NULL)
                {
                    START_ENUMERATION;
                    ripple_any_changes();
                    sp = orp->servers;
                }

                while (1)
                {
                    if (sp == NULL)
                    {
                        args->mount_id = NULL;
                        DONE_ENUMERATION;
                        remove_dead_servers();
                        break;
                    }

                    if ( (sp->flags & SERVER_HIDDEN) != 0 || (sp->flags & SERVER_MOUNTED) == 0 )
                    {
                        sp = sp->next;
                        continue;
                    }

                    if ( (x = bytes_to_enum_active_mount (sp) ) > args->size )
                    {
                        dbg(("More room needed for %s", sp->objname));
                        args->mount_id = sp;
                        break;
                    }

                    dbg(("Enumerating active mount %s:%x", sp->mount_fullname, sp->authent));

                    cp = args->buffer;
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    ((server **) cp)[0] = sp;
                    cp += sizeof(server *);
                    strcpy(cp, sp->mount_mountname);
                    args->buffer += x;
                    args->size -= x;

                    sp = sp->next;
                }
            }
            dbg(("Finished enumerating active mounts\n"));

            break;


        case OmniOp_OpenRoot:
        case OmniOp_OpenUserRoot:
            dbg(("OmniOp_Open(User)Root"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
                err = ENOSERVER;
                break;
            }
            {
                args_OmniOpOpenRoot *args = (args_OmniOpOpenRoot *) rp;
                server *sp = args->mount_id;

                claim_gbuf();

                sharefsify("filer_opendir", sp->objname);
                err = mycli(gbuf);

                release_gbuf();
            }
            break;


        case OmniOp_GetActiveMountInfo:
            dbg(("OmniOp_GetActiveMountInfo"));
            if ((flags & LOST_FREEWAY) || (flags & LOST_SHAREFS))
            {
                err = ENOSERVER;
                break;
            }
            {
                args_OmniOpGetActiveMountInfo *args = (args_OmniOpGetActiveMountInfo *) rp;
                server *sp = args->u.mount_id;

                if (sp == NULL)
                {
                    err = ENOSERVER;
                    break;
                }
                args->u.server = sp->server_fullname;
                args->user_id = NULL; /*user_name_from_authent(sp->authent);*/
                args->mount_name = sp->mount_mountname;
                args->mount_path = NULL;
                args->authenticator = NULL;
                args->server_id = sp;
            }
            break;


        case OmniOp_Reset:
            dbg(("OmniOp_Reset"));
            deregister_swi(rp);
            break;

        case OmniOp_FreeSpace:
        case OmniOp_GetInactiveMountInfo:
        case OmniOp_CreatePrintJob:
        case OmniOp_SendPrintJob:
        case OmniOp_EndPrintJob:
        case OmniOp_AbortPrintJob:
        case OmniOp_GetPrintJobInfo:
        case OmniOp_ClearPrintJobs:
        case OmniOp_EnumeratePrinters:
        default:
            err = EBADCALL;
            break;
    }

    note_error(err);

    return err;
}

/*****************************************************************************
 *
 * SWI handler.
 *
 * We support two SWIs: one for OmniClient access and the other for DCI4
 * statistic access (the latter is not yet implemented).
 */

extern _kernel_oserror *swi_handler(uint swinum, _kernel_swi_regs *regs, void *pw)
{
#if DEBUG
    static char *opnames[] =
    {
        "Mount",
        "Dismount",
        "Free",
        "Enumerate servers",
        "Enumerate mounts",
        "Enumerate active mounts",
        "Open root",
        "Open user root",
        "Get inactive mount info",
        "Get active mount info",
        "Create print job",
        "Send print data",
        "End print job",
        "Abort print job",
        "Get print job info",
        "Clear print job",
        "Enumerate printers",
        "Reset"
    };

    dbg(("\n\n      SWI %s\n\n", opnames[ regs->r[0] ] ));
#endif

    switch (swinum)
    {
        case 0:
            return normal_swi(swinum, regs, &access_servers);
            break;

        case 1:
/*            return normal_swi(swinum, regs, &access_servers);*/
            return normal_swi(swinum, regs, &pseudo_accessplus);
            break;

	/* case 2:
	    return deregister_swi(regs);
	    break; */
    }

    return EBADCALL;
}

/*****************************************************************************/

extern void service_call_handler(register int sn, _kernel_swi_regs *r)
{
    dbg(("ServiceCall 0x%x", sn));

    switch (sn)
    {
        case Service_OmniAction:
            {
                args_OmniServiceCall *args = (args_OmniServiceCall *) r;

                switch (args->action)
                {
                    case 0:         /* OmniClient module has started */
                        flag_setclr(SEEN_OMNI, LOST_OMNI);
                        dbg(("omniclient arrived"));
                        if (state == WAITING)
                        {
                            schedule(DO_CONNECT);
                        }
                        else
                        {
                            /* As per 0.996 and greater versions of the spec. */
                            (void) claim_omni();
                        }
                        break;

                    case 1:                /* OmniClient module is/has died*/
                        flag_setclr(LOST_OMNI, SEEN_OMNI | DO_CONNECT);
                        dbg(("omniclient gone"));
                        commit_suicide();
                        break;

                    default:                         /* Unexpected - ignore*/
                        dbg(("Unknown omni service action %x", args->action));
                        break;
                }
            }
            break;

        case Service_FreewayStarting:
            flag_setclr(SEEN_FREEWAY, LOST_FREEWAY);
            dbg(("freeway arrived"));
            if (state == WAITING)
            {
                schedule(DO_CONNECT);
            }
            break;


        case Service_FreewayTerminating:
            flag_setclr(LOST_FREEWAY, SEEN_FREEWAY | DO_CONNECT);
            dbg(("freeway gone"));
            release_sharefs();
            release_freeway();
            break;

        case Service_ShareFSStarting:
            flag_setclr(SEEN_SHAREFS, LOST_SHAREFS | DO_CONNECT);
            dbg(("sharefs arrived"));
            if (state == WAITING)
            {
                schedule(DO_CONNECT);
            }
            break;

        case Service_ShareFSTerminating:
            flag_setclr(LOST_SHAREFS, SEEN_SHAREFS | DO_CONNECT);
            dbg(("sharefs gone"));
            release_sharefs();
            release_freeway();
            break;

        default:                    /* Unexpected - ignore */
            break;
    }
}

/*****************************************************************************/

/* eof omniacc.c */

