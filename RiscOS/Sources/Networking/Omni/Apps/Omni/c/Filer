/*
 * Program:	Filer.c - core module routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	11 July 1994
 * Last Edited:	3 May 1995
 *
 * Copyright 1994,1995 by ANT Limited
 */

#include "Hdrs.h"
#include "netdb.h"
#include "ModuleWrap.h"
#include "DebugLib/DebugLib.h"

#include "OmniClient.h"

extern int        	taskhandle = 0;			/* Wimp task handle */
extern int      	wind_info = NULL;		/* Window handle */
extern int      	wind_client = NULL;		/* Window handle */
extern int      	wind_mounttmp = NULL;		/* Window handle */
extern int      	wind_mountdom = NULL;		/* Window handle */
extern int      	wind_mountinfo = NULL;		/* Window handle */
extern Desk_linklist_header	mount_anchor = {NULL, NULL};	/* List of mount icon records */
extern Desk_linklist_header	mlist_anchor = {NULL, NULL};	/* List of mount list records */
extern Desk_linklist_header	mwind_anchor = {NULL, NULL};	/* List of mount window records */
extern Desk_linklist_header	client_anchor = {NULL, NULL};	/* List of client records */
extern Desk_linklist_header	item_anchor = {NULL, NULL};	/* List of item records */
extern Desk_linklist_header	ext_anchor = {NULL, NULL};	/* List of file extn mapping records */
extern wind_record	wind_filer = {NULL,NULL,0,0,0,
				      NULL,NULL};	/* Record of servers 'filer' window */
extern config_record    prog_config = {0,0,Desk_FALSE};	/* Program configuration */
extern Desk_linklist_header	print_anchor = {NULL, NULL};	/* List of print job records */
extern Desk_linklist_header	plist_anchor = {NULL, NULL};	/* List of print list records */

extern Desk_bool		all_done = Desk_FALSE;		/* Exit task */
extern int      	icon_dragtype = 0;		/* Type of drag operation */
extern int 		Image__RO_Base;			/* To get at our module base */
extern _kernel_oserror  omni_errblk = {0, ""};          /* Global error block */
extern int		pollword = pollword_NONE;	/* Poll word non-zero */
extern int		pollword_r0 = -1;		/* Poll word non-zero parameter */
extern char		*pollword_str = NULL;		/* Poll word string */
/* extern Desk_bool		all_restart = Desk_TRUE; */		/* Desk_TRUE if we are just RMLoading */
extern Desk_bool 		all_hasrun = Desk_FALSE;		/* Desk_TRUE if we have been running task */

#ifdef DEBUG
extern FILE 		*omniout = NULL;		/* Debug trace file handle */

/*  Initialise debug spool files.
 */
static Desk_bool debuginit(void)
{
  char filebuf[256];

  sprintf(filebuf, "<%s$Dir>.!TRACE", app_DIR);
  if ((omniout = fopen(filebuf, "w")) == NULL) return(Desk_FALSE);
  return(Desk_TRUE);
}


/*  Finalise debug spool files.
 */
static void debugclose(void)
{
  if (omniout != NULL) fclose(omniout);
}
#else
#define debuginit()	((void) 0)
#define debugclose()	((void) 0)
#endif


/*  Clear out mlist struct from RMA.
 */
extern void mlist_clean(void)
{
  mlist_record *mr = (mlist_record *) mlist_anchor.next;
  TRACE("mlist_clean: enter\n");
  while (mr)
  {
    mlist_record *mr_tmp = (mlist_record *) mr->header.next;
    MountDeleteList(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&mlist_anchor);
  TRACE("mlist_clean: exit\n");
}


/*  Clear out print struct from RMA.
 */
extern void print_clean(void)
{
  print_record *mr = (print_record *) print_anchor.next;
  TRACE("print_clean: enter\n");
  while (mr)
  {
    print_record *mr_tmp = (print_record *) mr->header.next;
    PrintClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&print_anchor);
  TRACE("print_clean: exit\n");
}


/*  Clear out print struct from RMA.
 */
extern void plist_clean(void)
{
  plist_record *mr = (plist_record *) plist_anchor.next;
  TRACE("plist_clean: enter\n");
  while (mr)
  {
    plist_record *mr_tmp = (plist_record *) mr->header.next;
    PListClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&plist_anchor);
  TRACE("plist_clean: exit\n");
}


/*  Clear out client struct from RMA.
 */
extern void client_clean(void)
{
  client_record *mr = (client_record *) client_anchor.next;
  TRACE("client_clean: enter\n");
  while (mr)
  {
    client_record *mr_tmp = (client_record *) mr->header.next;
    ClientDelete(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&client_anchor);
  TRACE("client_clean: exit\n");
}


/* Kill task, release workspace.
 */
static void removetask(void)
{
  TRACE1("removetask: %x\n", taskhandle);
  if (taskhandle > 0) Desk_Wimp_CloseDown(taskhandle);
  taskhandle = 0;
  mlist_clean();
  plist_clean();
  TRACE("removetask: completed\n");
}


/* Broadcast Service_OmniAction call.
 */
extern void serviceomni(int num)
{
  _kernel_swi_regs r;

  TRACE1("serviceomni: %d\n", num);
  r.r[0] = num;
  r.r[1] = Service_OmniAction;
  _kernel_swi(XOS_Bit | OS_ServiceCall, &r, &r);
  TRACE("serviceomni: completed\n");
}


/*  This is the finalisation code
 */
_kernel_oserror *fs_finalise(int fatal, int podule, void *pw)
{
  TRACE("fs_finalise:\n");
  if (!all_done <= 1) serviceomni(1);
  removetask();
  print_clean();
  client_clean();
  FileType_FreeChain();
  FS_Remove();
  SetVar_Code(-1, NULL);
  CloseErrors();
  TRACE("fs_finalise: completed\n");
  /* debugclose(); */

  debug_terminate ();

}


/*  This is the initialisation code
 */
_kernel_oserror *fs_initialise(const char *cmd_tail, int podule_base, void *private_word)
{
  _kernel_oserror *err = NULL;

  /* These keep the compiler quiet. */
  cmd_tail = cmd_tail;
  podule_base = podule_base;

  debug_initialise ("", "Omni", NULL);
  debug_set_options (0, 0, 0);
  debug_output_device (TML_OUTPUT);
  debug_initialise_trace (TML_OUTPUT, "");

  Desk_Error2_Init_JumpSig();

  Desk_Error2_Try
  {
    Desk_LinkList_Init(&client_anchor);
    Desk_LinkList_Init(&print_anchor);
    Desk_LinkList_Init(&ext_anchor);

    InitVars();

    RMAFREE(pollword_str);
    /* debuginit(); */
    err = FS_Declare(private_word);
    if (err)
    {
      debugclose();
      return(err);
    }

    /*atexit(fs_finalise);*/
    /* Delay the service call via callback because we aren't yet registered as a module,
     * so Omni_SWI calls will fail.
     */
    #if 0
    serviceomni_delay(0);
    #endif
    SetVar_Code(1, &taskhandle);
    InitErrors();
  }
  Desk_Error2_Catch
  {
    err = Desk_Error2_ConvertToOS2();
  }
  Desk_Error2_EndCatch

  return(err);
}


/* Service call handler
 */
/*#ifdef TRACESERVICE*/
#ifdef DEBUG
static struct
{
  int svc;
  char *name;
} svcs[] =
{
  {0x00,"Serviced"},
  {0x04,"UKCommand"},
  {0x06,"Error"},
  {0x07,"UKByte"},
  {0x08,"UKWord"},
  {0x09,"Help"},
  {0x0b,"ReleaseFIQ"},
  {0x0c,"ClaimFIQ"},
  {0x11,"Memory"},
  {0x12,"StartUpFS"},
  {0x27,"Reset"},
  {0x28,"UKConfig"},
  {0x29,"UKStatus"},
  {0x2a,"NewApplication"},
  {0x40,"FSRedclare"},
  {0x41,"Print"},
  {0x42,"LookupFileType"},
  {0x43,"International"},
  {0x44,"Keyhandler"},
  {0x45,"PreReset"},
  {0x46,"ModeChange"},
  {0x47,"ClaimFIQinBackground"},
  {0x48,"ReAllocatePorts"},
  {0x49,"StartWimp"},
  {0x4a,"StartedWimp"},
  {0x4b,"StartFiler"},
  {0x4c,"StartedFiler"},
  {0x4d,"PreModeChange"},
  {0x4e,"MemoryMoved"},
  {0x4f,"FilerDying"},
  {0x50,"ModeExtension"},
  {0x51,"ModeTranslation"},
  {0x52,"MouseTrap"},
  {0x53,"WimpCloseDown"},
  {0x54,"Sound"},
  {0x55,"NetFS"},
  {0x56,"EconetDying"},
  {0x57,"WimpReportError"},
  {0x60,"ResourceFSStarting"},
  {-1,"Something else"}
};
#endif
/*#endif */

void fs_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
/* #ifdef TRACESERVICE */
#ifdef DEBUG
  int i;

  for (i=0; svcs[i].svc >= 0; i++) if (svcs[i].svc == service_number) break;
  dprintf(("", "Service_%s (%#x)%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n", svcs[i].name,
        service_number, r->r[0],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5],r->r[6],r->r[7],
        r->r[8],r->r[9]));
#endif
/* #endif */
  /* TRACE1("service: %x\n", service_number); */
  switch (service_number)
  {
    case Service_Memory:
      /* keep application workspace (r2 holds CAO pointer) */
      if (r->r[2] == (int) Image__RO_Base) r->r[1] = 0;
      break;
    case Service_StartFiler:
      /* We use StartFiler/StartedFiler *not* StartWimp/StartedWimp because we are
       * a desktop filer, not just any old task, and we want to wait for the RISC OS
       * Filer task to startup first.
       */
      TRACE1("Service_StartFiler task %d\n", taskhandle);
      if (taskhandle == 0)
      {
        taskhandle = -1; 		/* attempting start flag */
        r->r[0] = (int) ("Desktop_OmniClient");
        r->r[1] = 0;
      }
      break;
    case Service_StartedFiler:
      TRACE1("Service_StartedFiler %d\n", taskhandle);
      if (taskhandle == -1) taskhandle = 0;
      break;
    case Service_Reset:
    case Service_ShutdownComplete:
      /* We have problems with soft-resets: If we've previously run on this
       * soft reset (RO3.1), then mark as never wanting to startup again.
       */
      if (!all_hasrun) taskhandle = 0;
        else taskhandle = -2;
      break;
    case Service_FilerDying:
      TRACE1("Service_FilerDying %d\n", taskhandle);
      removetask();
      break;
    case Service_FSRedeclare:
      FS_Declare(private_word);
      break;
    /* Handle other service calls here */
  }
}


#define OS_FSControl		0x000029
#define _Wimp_StartTask		0x0400de
#define Wimp_ReadSysInfo	0x0400F2

/* User Command processor
 */
_kernel_oserror *fs_command(const char *arg_string, int argc, int cmd_no, void *private_word)
{
  _kernel_swi_regs rr;
  _kernel_swi_regs *r = &rr;
  int currentslot, nextslot, freepool;

  argc = argc;
  private_word = private_word;

  dprintf (("", "fs_command\n"));

  /* Switch between the commands */
  switch (cmd_no)
  {
    case 0:			/* Desktop_<app_DIR> */
      TRACE2("Desktop_OmniClient called handle %d hasrun %d\n", taskhandle, all_hasrun);
      TRACE1("Desktop_OmniClient called args '%s'\n", arg_string);
      if (taskhandle > 0)
      {
        if (argc > 1) MountCLI(arg_string, Desk_FALSE);
        return(NULL);
      }
      if (!all_hasrun)
      {
        int active;
        Desk_bool start = Desk_TRUE;

        /* Check we are really in the desktop.
         */
        TRACE("OMNI running for first time - checking Desktop running\n");
        Desk_SWI(1,1, Wimp_ReadSysInfo, 0, &active);
        if (active <= 0) start = Desk_FALSE;
        Desk_SWI(1,1, Wimp_ReadSysInfo, 3, &active);
        if (active == 0) start = Desk_FALSE;
        if (!start)
        {
          /* Preserve command line string, because we'll start later */
          if (argc > 1) MountCLI(arg_string, Desk_FALSE);
          return(NULL);
        }

        TRACE("OMNI running for first time - calling Desktop_OmniClient\n");
        currentslot = 32*1024;
        nextslot = -1;
        Desk_Wimp_SlotSize(&currentslot, &nextslot, &freepool);
        r->r[0] = OSModule_Enter;
        r->r[1] = (int) app_DIR"Client";
        r->r[2] = (int) arg_string;
        return(_kernel_swi(XOS_Bit | OS_Module, r, r));
      }
      else
      {
        TRACE("OMNI running for nth time\n");
        return(MakeError(err_RESTART));
      }
      break;
    case 1:			/* OmniMount */
      MountCLI(arg_string, Desk_FALSE);
      return(NULL);
      break;
    case 2:			/* OmniLoadMounts */
      if (MountLoadFile(arg_string)) return(NULL);
      return(MakeError(err_BADMOUNTS));
      break;
    case 3:			/* OmniPrint */
      r->r[0] = 14;
      r->r[1] = (int) fsname;
      return(_kernel_swi(XOS_Bit | OS_FSControl, r, r));
      break;

    default:
      return(NULL);
  }
}


/* Desk_SWI omni_base+0 "Omni_EnumerateMounts"
 *	On entry, R0 = 0, for all client types
 *	             = client_id, for a single client
 *                R1 = 0, for servers/mounts
 *                   = 1, for active mount connections
 *                   = 2, for printers
 *	All registers preserved on exit
 *
 *	This SWI is used by clients to request that the filer re-enumerates
 *	all the mounts for a given client_id [!=0] or for all registered
 *	client_id's [=0].
 *	This would be used, for example, when the client knows that the
 *	state of the active mounts [R1 = 1] has changed. eg, a
 *	command line *Dismount has been performed.
 *      If [R1 = 0], then the client knows that the list of servers and/or
 *      mounts exported by those servers has changed. eg, a periodic
 *      broadcast has noted that a new server has appeared.
 *      If [R1 = 2], then the client knows that the list of printers has
 *      changed.
 */
static _kernel_oserror *EnumerateMounts(_kernel_swi_regs *r)
{
  TRACE2("EnumerateMounts: %x %x\n", r->r[0], r->r[1]);
  /* If task isn't running, then we shouldn't do anything */
  if ((taskhandle <= 0) || (r->r[1] > 2)) return(NULL);
  if (r->r[1] == 0) pollword |= pollword_ENUMERATENET;
  if (r->r[1] == 1) pollword |= pollword_ENUMERATE;
  if (r->r[1] == 2) pollword |= pollword_ENUMERATEPRINT;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  return(NULL);
}


/* Desk_SWI omni_base+1 "Omni_RegisterClient"
 *	On entry, R0 = client_id, (Desk_SWI xxxx_OmniOp)
 *	          R1 = client flags word;
 *	               	      bit 0 = 1, Client supports network filing system
 *	                            = 0, No filing system support
 *	               	      bit 1 = 1, UserID string required
 *	               	      bit 2 = 1, Password string required
 *	               	      bit 3 = 1, Mount path string required
 *	               	      bit 4 = 1, Authentication server string
 *               	      bit 5 = 1, Mount name *not* required
 *	               	      bit 6 = 1, Special network authenticator
 *	           	      bit 7 = *reserved* zero
 *	               	      bit 8 = 1, Client supports network printers
 *	                            = 0, No printing support
 *	               	      bit 9 = 1, Password string required
 *	              	     bit 10 = 1, Needs file length before print job starts
 *	         	bits 11..15 = *reserved* zero
 *	         	bits 16..23 = ASCII extension character, or 0 for none
 *	               	bits 24..31 = *reserved* zero
 *	          R2 = sprite name ptr
 *	          R3 = client name ptr
 *	          R4 = client description ptr
 *	          R5 = site_id word (See document [Site_SpecN] for details)
 *	          R6 = filing system name ptr
 *	On exit,  R0 = 0, if successful
 *	             = error block (V set), on error
 *	All other registers preserved on exit
 *
 *      This SWI is used when a client module is (re)started to register
 *      itself with the Omni filer, and pass to the filer the facilities
 *      that it provides via the flags word.
 *      An error is returned if registration fails for whatever reason.
 *
 *      Revisions of this document prior to 0.996 stated that the correct
 *      behaviour was to register with This SWI only once. However, this has
 *      now changed so that protocol modules should attempt to (re)register
 *      when they startup and whenever they recieve Service_OmniAction. If
 *      the protocol is already registered, no error is returned.
 *      An error is returned if registration fails for whatever reason.
 *
 * 	The flags word (R1) lets the filer know which connect fields
 * 	are *never* required by this client. Some clients can further
 * 	reduce the number of fields required at a later time (see
 * 	OmniOp 7). eg, LAN Manager. The flags word can also register a
 * 	single ASCII character (eg, '.' or '/') which is used to
 * 	separate filename and file extension in the filing system. This
 * 	separator is used by the Omni_Convert Desk_SWI calls.
 *
 *	Bit 5 of the flags word is set for filing systems (typically those
 *	written before OmniClient) that have no concept of a user-supplied
 *	mount name, separate from the actual server name. When this bit is
 *	set, users will not be prompted for a mount name - it will be set
 *	to the mount path string (if it is set as required and is of non-zero
 *	length), or failing that the server name string. Note that when
 *	returning the mount path string (eg, OmniOp,9) protocol modules
 *	should return the appropriate string to allow Free operations, etc.
 *	This is the string that will appear under the iconbar, and if bit
 *	5 is set in the flags, the string will most likely either be
 *	the real server name, or the mount path. Hopefully most protocol
 *	module authors will never be required to understand this paragraph ;-)
 *
 *	Bit 6 of the flags word is set for protocols that require a network
 *	authentication action before servers can be located (eg, Acorn Access+)
 *	The expected use is for the protocol module to provide a 'dummy'
 *	network server, which the user 'mounts' with their user name/password.
 *	The mount operation is passed onto the protocol module as normal, but
 *	because there is no real connection, the mount should not be returned
 *	via enumerate active mounts calls, and no icon will appear on the
 *	iconbar. The protocol module can then perform its network
 *	authentication and enumerate those new servers that it can access.
 *
 * 	The sprite name ptr (R2) is a pointer to a null-terminated
 * 	sprite name, which must exist in the Wimp sprite pool as
 * 	'sprite', along with the small version 'sprite' postfix 's'. The
 * 	unique name for the client sprites (suggest the ASCII hex of
 * 	the xxxx_MiscOp Desk_SWI number) must be no more than 6 characters
 * 	long. Static string. If normal and small size versions of these
 * 	sprites exist with postfix '_22' then these hi-resolution sprites
 * 	will be used in square pixel modes.
 *
 *	The client name ptr (R3) is a pointer to a null-terminated text
 *	string, which should be a short format description of the client.
 *	eg, 'Berkeley NFS'. It should be no more than 24 characters long.
 *	This string is used in filer menus and title bars. Static string.
 *
 *	The client description ptr (R4) is a pointer to a null-terminated
 *	text string of the form '<desc>|J<author>|J<version>'. ie,
 *	3 lines of text (each line no longer than 32 chars), separated
 *	by ASCII 0x0a, and the whole string terminated by a null (0x00).
 *	This string is used in a filer 'client info' window. Static string.
 *
 * 	The site_id word (R5) (See document [Site_SpecN] for details)
 * 	should be 0 if the client module provides its own site-license
 * 	enforcement mechanism, or has no upper limit on the number of
 * 	users.
 *
 *	The filing system name ptr (R6) is the textual name of the filing
 *	system used by this protocol. eg, 'NetFS'.
 *
 *      Errors returned include:
 *      err_base+0	"Protocol is already registered"
 *	err_base+1	"Bad protocol identifier value"
 *	err_base+2	"No free memory for protocol registration"
 */
static _kernel_oserror *RegisterClient(_kernel_swi_regs *r)
{
  client_record *cr = ClientCreate(r);
  TRACE("RegisterClient:\n");
  if (cr != NULL)
  {
    pollword |= pollword_REGISTER;
    if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
      else pollword_r0 = r->r[0];
    returnOK()
  } else return((_kernel_oserror *) r->r[0]);
}


/* Desk_SWI omni_base+2 "Omni_DeregisterClient"
 *	On entry, R0 = client_id
 *      On exit,  R0 = 0, if deregistration successful
 *                   = not 0, if deregistration failed (error ptr)
 *	All other registers preserved on exit
 *
 *      This SWI is the companion call to Desk_SWI Omni_RegisterClient, and
 *      releases the client from the Omni filer.
 */
static _kernel_oserror *DeregisterClient(_kernel_swi_regs *r)
{
  client_record *cr = ClientFind(r->r[0], NULL, -1, NULL);
  TRACE("DeregisterClient:\n");
  if (cr == NULL) return(MakeError(err_NOTREGISTERED));
  ClientDelete(cr);
  pollword |= pollword_DEREGISTER;
  /* Force to enumerate for active mounts that may have disappeared */
  pollword |= pollword_ENUMERATE;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  returnOK();
}


/* Desk_SWI omni_base+3 "Omni_MessageLookup"
 *  	On entry, R0 = message_id, (see table)
 *	          R1 = parameter string (if required)
 *      On exit,  R0 = error_blk, pointer to error block;
 *                       +0 = error number
 *                       $4 = null-terminated text string
 *	All other registers preserved on exit
 *
 *	This SWI provides for a shared set of common error/message
 *	blocks which can be used by client modules, irrespective of
 *	whether they are register with Omni filer.
 *	The text messages returned may be internationalised.
 *	NOTE do not rely on the maximum OmniClient(tm) error message
 *	being 16 - this list is subject to change and expansion.
 *	The filer does not guarantee to store error blocks statically.
 *	If you need the error block again, call This SWI.
 */
static _kernel_oserror *MessageLookup(_kernel_swi_regs *r)
{
  TRACE2("MessageLookup: %x %x\n", r->r[0], r->r[1]);
  return(OmniError(r->r[0], (char *) r->r[1]));
}


/* Desk_SWI omni_base+4 "Omni_ConvertClientToAcorn"
 *	On entry, R0 = client_id
 *		  R1 = ptr to client-format filename (including extension)
 *		  R2 = ptr to buffer for Acorn-format filename
 *		  R3 = ptr to flags string
 *	On exit,  R0 = Acorn-filetype, or -1 if not applicable
 *	All other registers preserved on exit
 *
 *	This SWI performs client -> RISC OS filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping Desk_SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertClientToAcorn(_kernel_swi_regs *r)
{
  client_record *cr = NULL;

  TRACE("ConvertClientToAcorn:\n");
  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  r->r[0] = FileType_ConvertToType(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3]);
  return(NULL);
}


/* Desk_SWI omni_base+5 "Omni_ConvertAcornToClient"
 *	On entry, R0 = client_id
 *		  R1 = ptr to acorn-format filename
 *		  R2 = ptr to buffer for client-format filename
 *		       (including extension)
 *		  R3 = flags string
 *	          R4 = Acorn-filetype, or -1 if not typed
 *	All registers preserved on exit
 *
 *	This SWI performs RISC OS -> client filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping Desk_SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertAcornToClient(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  TRACE("ConvertAcornToClient:\n");

  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  FileType_ConvertToExtension(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3], r->r[4]);
  return(NULL);
}


/* Desk_SWI omni_base+6 "Omni_ConvertTime"
 *	On entry, R0 = time formats;
 *		       bits 0..3 = source format
 *		       bits 4..7 = destination format;
 *		         0 = RISC OS, 5 byte, csec from 1st Jan 1900
 *		         1 = UNIX, 4 byte, sec from 1st Jan 1970
 *		         2 = DOS, 4 byte, sec from 1st Jan 1980
 *		         3 = Mac, 4 byte, signed sec from 00:00 1st Jan 2000
 *	         	 4 = Generic, 28 bytes (see below)
 *		        >4 = *reserved*
 *		       bits 8..31 = *reserved* zero
 *		  R1 = *pointer* to source time block
 *		  R2 = *pointer* to destination time buffer
 *	All registers preserved on exit
 *
 *	This SWI performs file timestamp conversions between any
 *	combination of supported system time formats.
 */
static _kernel_oserror *ConvertTime(_kernel_swi_regs *r)
{
  int src, dst;
  int time[9];

  TRACE("ConvertTime:\n");

  src = r->r[0] & 0x0F;
  dst = (r->r[0] & 0xF0) >> 4;
  TRACE1("ConvertTime: src %d\n", src);
  switch (src)
  {
    case 0:
      Time_FromAcorn((char *) r->r[1], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_FromSecs((int *) r->r[1], &time[0], src);
      break;
    case 4:
      memcpy((char *) &time[0], (char *) r->r[1], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  time[7] = -1;
  time[8] = -1;
  TRACE1("ConvertTime: dst %d\n", dst);
  switch (dst)
  {
    case 0:
      Time_ToAcorn((char *) r->r[2], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_ToSecs((int *) r->r[2], &time[0], dst);
      break;
    case 4:
      memcpy((char *) r->r[2], (char *) &time[0], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  TRACE("ConvertTime: exit\n");
  return(NULL);
}


/* Desk_SWI omni_base+7 "Omni_Printers"
 *     	On entry, R0 = reason code;
 *                        0 = list protocols supporting printers
 *                        1 = list protocol (FS names) supporting printers
 *                        2 = protocol print flags for protocol in R1
 *                       16 = list printer servers for protocol in R1
 *                       17 = list printers for protocol/server in R1/R2
 *                       18 = list all printers for protocol in R1
 *                R1 = ptr to name of protocol (R0 = 2,16,17,18)
 *                R2 = ptr to name of server for printers (R0 = 17)
 *                R3 = ptr to buffer to fill with result string, or NULL
 *                R4 = size of buffer in bytes, or -1 if not known
 *      On exit,  R0 = protocol printing-support flags word (R0 = 2)
 *        	  R4 = size of buffer required for result string
 *	All other registers preserved on exit
 *
 *      This SWI provides information about printer support in OmniClient.
 *      Currently the reason codes (R0=0,1,16,17,18) return a result string
 *      into a user buffer supplied as R3. It is expected that this is
 *      done as a 2-stage process to ensure that a large-enough buffer
 *      exists for the result string.
 *
 *      The Desk_SWI is firstly called with R3=NULL,R4=-1, and the call returns
 *      with R4 containing the total size of buffer required (including
 *      terminator). The buffer is allocated by the caller, and then the
 *      Desk_SWI is called the second time, with the new R3/R4.
 *      If no items are available, then R4=0 is returned.
 *
 *      If R0 = 0, then the menu string contains the available protocol
 *      names that are registered as supporting printers. eg, "Acorn NFS,
 *      Acorn NetFS, ANT RemoteFS". R0 = 1 returns the same menu string,
 *      but with filing system names rather than full client descriptions.
 *      eg, "NFS, NetFS, RemoteFS".
 *
 *	If R0 = 2, then the protocol printing-support flags word for the
 *	protocol named in R1 is returned. The flags word is of the format;
 *
 *		bit 0 = 1, Client supports network printers
 *	              = 0, No printing support
 *	        bit 1 = 1, Password string required
 *	        bit 2 = 1, Needs file length before print job starts
 *	   bits 3..31 = *reserved* zero
 *
 *      If R0 = 16, then the menu string contains the servers exported
 *      by the protocol named in R1. eg, "laser.net, print.cl".
 *
 *      If R0 = 17, then the menu string contains the printers exported
 *      by the protocol named in R1, available as printers from the server
 *      named in R2. eg, "LibraryDM, Laser 600".
 *
 *      If R0 = 18, then the menu string contains all the printers exported
 *      by the protocol named in R1. eg, "NetLaser, LibraryDM, Laser 600".
 *      This reason code lists all the printers available, irrespective of
 *      which network server they are connected to.
 */
static _kernel_oserror *Printers(_kernel_swi_regs *r)
{
  _kernel_oserror *err = NULL;

  TRACE1("Printers: %x\n", r->r[0]);
  switch (r->r[0])
  {
    case 0:
    case 1:
      /* List protocols */
      err = PrintListProtocols(r);
      break;
    case 2:
      /* Protocol flags */
      err = PrintFlag(r);
      break;
    case 16:
      /* List print servers */
      err = PrintListServers(r);
      break;
    case 17:
    case 18:
      /* List printers */
      err = PrintListPrinters(r);
      break;
    default:
      err = MakeError(err_BADREASON);
      break;
  }
  return(err);
}


/* Desk_SWI omni_base+8 "Omni_CreateJob"
 * 	On entry, R0 = ptr to protocol name
 * 	          R1 = ptr to server name
 * 	          R2 = ptr to printer name
 * 	          R3 = ptr to user name, or NULL
 *	          R4 = ptr to password string, or NULL
 *                R5 = ptr to options string, or NULL
 *                R6 = size of print job (bytes), or 0 if not known
 *      On exit,  R0 = print_id of new job, if successful
 *                   = error block (V set), on error
 * 	All other registers preserved on exit
 *
 *      Submit a new job for network printing. Returns a unique 'print_id'
 *      word, or a pointer to an error block.
 *
 *      The protocol name (R0) is the name as provided by Desk_SWI Omni_Printers
 *      (and registered as the 'client name'). eg, "Sun NFS". The user name,
 *      password and options string are optional, and may be NULL pointers.
 *
 *      Some printing protocols require that the total size of the job is
 *      known before printing starts. If this is the case, they should be
 *      registered with OmniClient as requiring this. When a client
 *      program calls Desk_SWI Omni_PrinterInfo, reason code 2, it can determine
 *      whether a password field is required for this protocol, and whether
 *      the total size of the print job is required.
 */
static _kernel_oserror *CreateJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;

  TRACE("CreateJob:\n");
  if ((pr = PrintCreate(r)) == NULL) return((_kernel_oserror *) r->r[0]);
  r->r[0] = pr->print_id;
  return(NULL);
}


/* Desk_SWI omni_base+9 "Omni_SendJob"
 * 	On entry, R0 = print_id
 * 		  R1 = ptr to data block to send
 * 		  R2 = size of data block to send
 * 	On exit,  R2 = number of bytes not sent, or 0 for all done
 * 	All other registers preserved on exit
 *
 *      Send a block of data down network printer stream for a given active
 *      print_id word.
 */
static _kernel_oserror *SendJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  TRACE("SendJob:\n");
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = (_kernel_oserror *) Desk_SWI(4,4, pr->client_id, 11,pr->pjob_id,r->r[1],r->r[2],
    NULL,NULL,NULL,&r->r[2]);
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* Desk_SWI omni_base+10 "Omni_EndJob"
 * 	On entry, R0 = print_id
 * 	All registers preserved on exit
 *
 *      End a specified print job normally (ie, all data transmitted).
 */
static _kernel_oserror *EndJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  TRACE("EndJob:\n");
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 12,pr->pjob_id);
  /* Mark as complete */
  if (!err)
  {
    pr->status = (print_STATUS | print_COMPLETE);
    pr->handle = -1;
    returnOK();
  }
  r->r[0] = (int) err;
  return(err);
}


/* Desk_SWI omni_base+11 "Omni_AbortJob"
 * 	On entry, R0 = print_id, or
 * 		     = 0, to abort all jobs
 * 	All registers preserved on exit
 *
 *      Abort a specified print job, or all current jobs.
 */
static _kernel_oserror *AbortJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  TRACE("AbortJob:\n");
  if (r->r[0] == 0)
  {
    /* Abort all print jobs */
    cr = (client_record *) client_anchor.next;
    while (cr != NULL)
    {
      if (PrintFind(-1, -1, cr->client_id, -1) != NULL) Desk_SWI(2,0, cr->client_id, 13,0);
      cr = (client_record *) cr->header.next;
    }
    /* Free print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));
    /* Make call onto client */
    err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 13,pr->pjob_id);
    /* Delete from list */
    if (!err)
    {
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* Desk_SWI omni_base+12 "Omni_JobStatus"
 * 	On entry, R0 = print_id
 * 	On exit,  R1 = local job status word (see below)
 * 		  R2 = local job # bytes sent
 * 		  R3 = error/status block ptr, or 0
 * 		  R4 = remote job status word (see below)
 * 		  R5 = remote job # bytes printed
 * 		  R6 = error/status block ptr, or 0
 * 	All other registers preserved on exit
 *
 *      Get information on a specified print job. The status
 *      word (R1, R3) is currently defined as;
 *
 *      	bit 0 = 0, no status available
 *         	      = 1, status information available
 *          bits 1..3 = 0, pending connection
 *         	      = 1, connection made, waiting for initial data
 *                    = 2, sending bytes
 *                    = 3, transfer complete
 *                    = 4, job marked as temporary error
 *     	              = 5, job marked as terminal error
 *                    =>5, *reserved*
 * 	   bits 4..31 = *reserved* zero
 */
static _kernel_oserror *JobStatus(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  TRACE("JobStatus:\n");
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = (_kernel_oserror *) Desk_SWI(2,7, pr->client_id, 14,pr->pjob_id,
    NULL,&r->r[1],&r->r[2],&r->r[3],&r->r[4],&r->r[5],&r->r[6]);
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* Desk_SWI omni_base+13 "Omni_ClearJob"
 *	On entry, R0 = print_id, or
 *		     = 0, to clear all inactive jobs
 *	All registers preserved on exit
 *
 *      Clear a specified print job, or all current inactive jobs. It is
 *      important to make this call once the client program has finished
 *      with the print job, and will no longer be calling Omni_JobStatus.
 *      eg, once it has marked the job as having been completed or having a
 *      terminal error. The status of a print job will reside in memory
 *      forever if this call is not made.
 */
static _kernel_oserror *ClearJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;
  int lstatus, rstatus;

  TRACE("ClearJob:\n");
  if (r->r[0] == 0)
  {
    /* Free inactive print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;

      /* Call OmniOp, 14 (Get Print Job Info) */
      err = (_kernel_oserror *) Desk_SWI(2,5, pr->client_id, 14,pr->pjob_id,
        NULL,&lstatus,NULL,NULL,&rstatus);
      if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
      {
        /* Make call onto client */
        err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 15,pr->pjob_id);
        if (!err) PrintClear(pr);
      }
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));

    /* Call OmniOp, 14 (Get Print Job Info) */
    err = (_kernel_oserror *) Desk_SWI(2,5, pr->client_id, 14,pr->pjob_id,
      NULL,&lstatus,NULL,NULL,&rstatus);
    TRACE1("ClearJob: jobinfo = %x\n", (int) err);
    TRACE1("ClearJob: %x\n", lstatus);
    TRACE2("ClearJob: %x %x\n", pflagSET(lstatus, print_COMPLETE),
      pflagSET(lstatus, print_ERROR));
    if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
    {
      /* Make call onto client */
      err = (_kernel_oserror *) Desk_SWI(2,0, pr->client_id, 15,pr->pjob_id);
      TRACE1("ClearJob: clearclient = %x\n", (int) err);
      if (!err) PrintClear(pr);
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* Desk_SWI omni_base+14 "Omni_PrinterInfo"
 *      On entry, R0 = ptr to name of protocol for printer
 *                R1 = ptr to name of server
 *                R2 = ptr to name of printer
 *      On exit,  R0 = flags word, or 0 if not available
 *	All other registers preserved on exit
 *
 *      This SWI provides information about the facilities provided by a
 *      named printer. If information is not available then 0 is returned,
 *      or if the printer name is not valid, an error block ptr is returned.
 *
 *      The flags word,is a set of bit fields that describe the printer type
 *  	and facilities provided (see PRM 3-595);
 *
 *             	bit 0 = 1, Facilities information available,
 *                    = 0, information not available
 *          bits 1..7 = *reserved* zero
 *	        bit 8 = 1, Raw ASCII text
 *              bit 9 = 1, Postscript compatible
 *             bit 10 = 1, Epson FX80 or compatible
 *             bit 11 = 1, HP Laserjet or compatible
 *             bit 12 = 1, Integrex Colourjet
 *             bit 13 = 1, FAX modem
 *             bit 14 = 1, Direct drive laser printer
 *             bit 15 = 1, Caspel graphics language
 *             bit 16 = 1, PDumper interface
 *             bit 17 = 1, TeX 'DVI' files
 *             bit 18 = 1, Epson JX/Star LC10, HP Paintjet
 *        bits 19..31 = *reserved* zero
 */
static _kernel_oserror *PrinterInfo(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  plist_record *pr = NULL;

  TRACE("PrinterInfo:\n");
  cr = ClientFind(-1, (char *) r->r[0], -1, NULL);
  if (!cr) cr = ClientFind(-1, NULL, -1, (char *) r->r[0]);
  if (!cr) return(MakeError(err_NOTREGISTERED));
  /* Locate named server/printer */
  pr = PrinterFind(cr->client_id, (char *) r->r[1], (char *) r->r[2]);
  if (pr) r->r[0] = pr->flags;
    else r->r[0] = 0;
  return(NULL);
}


/* Desk_SWI omni_base+15 "Omni_EnumerateJobs"
 *	On entry, R1 = ptr to buffer for job list (word aligned)
 *	          R2 = size of buffer (words * 4)
 *	          R3 = 0, start enumerating jobs
 *	               not 0, continue enumerating jobs
 *	On exit,  R1 = ptr to next free byte in buffer, word aligned
 *	          R3 = 0, operation complete
 *	               not 0, buffer full, call again with this R3
 *	All other registers preserved on exit
 *
 *	This SWI enumerates all printer jobs that OmniClient knows about,
 *	returning a list of their print_id values in consecutive words of
 *	the supplied buffer, until the buffer is full or the enumeration is
 *	complete. This allows printer managment applications to gain access
 *	to print_id handles of jobs even if they were started using the
 *	OmniPrint filing system, or by another application using Desk_SWI
 *	Omni_CreateJob.
 *
 *	If R3 is not 0 on exit, then the enumeration is not complete
 *	(buffer full), and the reason code is called again with the
 *	new R3 value. This process continues until the enumeration
 *	is complete.
 */
static _kernel_oserror *EnumerateJobs(_kernel_swi_regs *r)
{
  TRACE("EnumerateJobs:\n");
  r->r[3] = (int) PrintListJobs((print_record *) r->r[3], (int **) &r->r[1], r->r[2]);
  return(NULL);
}


/* Desk_SWI omni_base+16 "Omni_NameLookup"
 *      On entry, R0 = reason code;
 *                      0 = get internet host by name
 *                      1 = get internet service by name/protocol
 *                     >1 = *reserved*
 *                  R1 = ptr to name of host (R0=0) or service (R0=1)
 *                  R2 = ptr to name of protocol (R0=1)
 *      On exit,  R0 = ptr to hostent (R0=0) or servent (R0=1) struct's
 *	All other registers preserved on exit
 *
 *	This SWI exists as an interface to the Internet name lookup
 *	facilities, for those protocol modules that do not wish to use the
 *	Acorn-provided 'inetlib' library, either for space reasons or
 *	because they cannot easily link in the library (eg, the protocol
 *	module is written entirely in assembler).
 *
 *	Parameters and return results are exactly as the Berkeley standard
 *	gethostbyname(char *name) and getservbyname(char *name, char *proto)
 *	functions.
 */
static _kernel_oserror *NameLookup(_kernel_swi_regs *r)
{
  TRACE("NameLookup:\n");
  switch (r->r[0])
  {
    case 0:
      r->r[0] = (int) gethostbyname((char *) r->r[1]);
      break;
    case 1:
      r->r[0] = (int) getservbyname((char *) r->r[1], (char *) r->r[2]);
      break;
    default:
      r->r[0] = 0;
      break;
  }
  return(NULL);
}


/*  User Desk_SWI call handler.
 */
_kernel_oserror *fs_swi(int swi_no, _kernel_swi_regs *r, void *private_word)
{
  TRACE1("fs_swi: %d\n", swi_no);
  switch (swi_no)
  {
    case 0: /* Omni_EnumerateMounts */
      return(EnumerateMounts(r));
      break;
    case 1: /* Omni_RegisterClient */
      return(RegisterClient(r));
      break;
    case 2: /* Omni_DeregisterClient */
      return(DeregisterClient(r));
      break;
    case 3: /* Omni_MessageLookup */
      return(MessageLookup(r));
      break;
    case 4: /* Omni_ConvertClientToAcorn */
      return(ConvertClientToAcorn(r));
      break;
    case 5: /* Omni_ConvertAcornToClient */
      return(ConvertAcornToClient(r));
      break;
    case 6: /* Omni_ConvertTime */
      return(ConvertTime(r));
      break;
    case 7: /* Omni_Printers */
      return(Printers(r));
      break;
    case 8: /* Omni_CreateJob */
      return(CreateJob(r));
      break;
    case 9: /* Omni_SendJob */
      return(SendJob(r));
      break;
    case 10: /* Omni_EndJob */
      return(EndJob(r));
      break;
    case 11: /* Omni_AbortJob */
      return(AbortJob(r));
      break;
    case 12: /* Omni_JobStatus */
      return(JobStatus(r));
      break;
    case 13: /* Omni_ClearJob */
      return(ClearJob(r));
      break;
    case 14: /* Omni_PrinterInfo */
      return(PrinterInfo(r));
      break;
    case 15: /* Omni_EnumerateJobs */
      return(EnumerateJobs(r));
      break;
    case 16: /* Omni_NameLookup */
      return(NameLookup(r));
      break;
    case 17: /* Omni_TraceFile */
#ifdef DEBUG
      r->r[0] = (int) omniout;
#else
      r->r[0] = 0;
#endif
      break;

    default:
      omni_errblk.errnum = 0x1e6;
      strcpy(omni_errblk.errmess, "Bad Desk_SWI call");
      return(&omni_errblk);
      break;
  }

  /* Return with no error */
  return(NULL);
}
