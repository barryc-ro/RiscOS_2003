/*
 * Program:	Filer.c - core module routines
 *
 * Project:	!Omni OmniClient(tm) project
 *
 * Author:	Nick Smith
 *              ANT Limited
 *              Cambridge
 *              Internet: nas@ant.co.uk
 *
 * Date:	11 July 1994
 * Last Edited:	3 May 1995
 *
 * Copyright 1994,1995 by ANT Limited
 */

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include <kernel.h>
#include <swis.h>

#include <netdb.h>

#include <Global/Services.h>

#include <Desk/Error2.h>
#include <Desk/WimpSWIs.h>

#include <DebugLib/DebugLib.h>
#include <MemCheck/MemCheck.h>

#include "Client.h"
#include "CoreInit.h"
#include "Defs.h"
#include "ExtLib.h"
#include "FileType.h"
#include "Filer.h"
#include "Heap.h"
#include "MakeError.h"
#include "Mount.h"
#include "Omni.h"
#include "OmniClient.h"
#include "Print.h"
#include "PrintFS.h"
#include "Time.h"

enum
{
  OSModule_Enter = 2,
  OSModule_Claim = 6,
  OSModule_Free  = 7
};

extern int        	taskhandle = 0;			/* Wimp task handle */
extern int      	wind_info = NULL;		/* Window handle */
extern int      	wind_client = NULL;		/* Window handle */
extern int      	wind_mounttmp = NULL;		/* Window handle */
extern int      	wind_mountdom = NULL;		/* Window handle */
extern int      	wind_mountinfo = NULL;		/* Window handle */
extern Desk_linklist_header	mount_anchor = {NULL, NULL};	/* List of mount icon records */
extern Desk_linklist_header	mlist_anchor = {NULL, NULL};	/* List of mount list records */
extern Desk_linklist_header	mwind_anchor = {NULL, NULL};	/* List of mount window records */
extern Desk_linklist_header	client_anchor = {NULL, NULL};	/* List of client records */
extern Desk_linklist_header	item_anchor = {NULL, NULL};	/* List of item records */
extern Desk_linklist_header	ext_anchor = {NULL, NULL};	/* List of file extn mapping records */
extern wind_record	wind_filer = {NULL,NULL,0,0,0,
				      NULL,NULL};	/* Record of servers 'filer' window */
extern config_record    prog_config = {0,0,Desk_FALSE};	/* Program configuration */
extern Desk_linklist_header	print_anchor = {NULL, NULL};	/* List of print job records */
extern Desk_linklist_header	plist_anchor = {NULL, NULL};	/* List of print list records */

extern int		all_done = 0;		/* Exit task */
extern int      	icon_dragtype = 0;		/* Type of drag operation */
extern int 		Image__RO_Base;			/* To get at our module base */
extern _kernel_oserror  omni_errblk = {0, ""};          /* Global error block */
extern int		pollword = pollword_NONE;	/* Poll word non-zero */
extern int		pollword_r0 = -1;		/* Poll word non-zero parameter */
extern char		*pollword_str = NULL;		/* Poll word string */
/* extern bool		all_restart = true; */		/* true if we are just RMLoading */
extern bool 		all_hasrun = false;		/* true if we have been running task */

/*  Clear out mlist struct from RMA.
 */
extern void mlist_clean(void)
{
  mlist_record *mr = (mlist_record *) mlist_anchor.next;
  while (mr)
  {
    mlist_record *mr_tmp = (mlist_record *) mr->header.next;
    MountDeleteList(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&mlist_anchor);
}


/*  Clear out print struct from RMA.
 */
extern void print_clean(void)
{
  print_record *mr = (print_record *) print_anchor.next;
  while (mr)
  {
    print_record *mr_tmp = (print_record *) mr->header.next;
    PrintClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&print_anchor);
}


/*  Clear out print struct from RMA.
 */
extern void plist_clean(void)
{
  plist_record *mr = (plist_record *) plist_anchor.next;
  while (mr)
  {
    plist_record *mr_tmp = (plist_record *) mr->header.next;
    PListClear(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&plist_anchor);
}


/*  Clear out client struct from RMA.
 */
extern void client_clean(void)
{
  client_record *mr = (client_record *) client_anchor.next;
  while (mr)
  {
    client_record *mr_tmp = (client_record *) mr->header.next;
    ClientDelete(mr);
    mr = mr_tmp;
  }
  Desk_LinkList_Init(&client_anchor);
}


/* Kill task, release workspace.
 */
static void removetask(void)
{
  if (taskhandle > 0) Desk_Wimp_CloseDown(taskhandle);
  taskhandle = 0;
  mlist_clean();
  plist_clean();
}


/* Broadcast Service_OmniAction call.
 */
extern void serviceomni(int num)
{
  _swix (OS_ServiceCall, _INR (0, 1), num, Service_OmniAction);
}


/*  This is the finalisation code
 */
_kernel_oserror *fs_finalise(int fatal, int podule, void *private_word)
{
  UNUSED (fatal);
  UNUSED (podule);
  UNUSED (private_word);

  /* BAL: This does not make sense.  !<anything> will be <= 1 (it's a logical, not a bitwise not).
   * I _think_ this is supposed to do something like only issue ServiceOmni if the whole module is
   * being killed, and not just the filer.
   */
  if (!all_done <= 1) serviceomni(1);

  removetask();
  print_clean();
  client_clean();
  FileType_FreeChain();
  FS_Remove();
  SetVar_Code(-1, NULL);
  CloseErrors();

  MemCheck_OutputBlocksInfo ();
  MemCheck_Finalise ();

  debug_terminate ();

  return NULL;
}


#ifdef MemCheck_MEMCHECK

static int  memcheck_vprintf (void *        reference,
                              const char *  format,
                              va_list       args)
{
    dvprintf (("", format, args));
    return 0;
}

#endif


/*  This is the initialisation code
 */
_kernel_oserror *fs_initialise(const char *cmd_tail, int podule_base, void *private_word)
{
  _kernel_oserror *err = NULL;

  /* These keep the compiler quiet. */
  cmd_tail = cmd_tail;
  podule_base = podule_base;

  debug_initialise ("", "Omni", NULL);
  debug_set_options (0, 0, 0);
  debug_output_device (FILE_OUTPUT);
  debug_initialise_trace (FILE_OUTPUT, "memcheck*");

  MemCheck_InitNoDebug ();
  MemCheck_RedirectToFunction (memcheck_vprintf, 0);
  MemCheck_SetStoreMallocFunctions (1);
  MemCheck_InterceptSCLStringFunctions();
  MemCheck_SetQuitting (0, 0);
  MemCheck_SetAccessQuitting (0, 0);
  /* Don't output blocks on every diagnostic.  A lot of diagnostics
   * are produced because of MemCheck faulting accesses to externally
   * supplied mbuf data structures. There are too many instances of
   * these to make it feasible to register them all as misc blocks.
   */
  MemCheck_SetAutoOutputBlocksInfo (0);

  Desk_Error2_Init_JumpSig();

  Desk_Error2_Try
  {
    Desk_LinkList_Init(&client_anchor);
    Desk_LinkList_Init(&print_anchor);
    Desk_LinkList_Init(&ext_anchor);

    InitVars();

    RMAFREE(pollword_str);

    err = FS_Declare(private_word);
    if (err)
    {
      return(err);
    }

    /* Delay the service call via callback because we aren't yet registered as a module,
     * so Omni_SWI calls will fail.
     */
    serviceomni_delay(0);
    SetVar_Code(1, &taskhandle);
    InitErrors();
  }
  Desk_Error2_Catch
  {
      err = Desk_Error2_ConvertToOS2();
  }
  Desk_Error2_EndCatch

  return(err);
}


/* Service call handler
 */
#ifdef DEBUG
static struct
{
  int svc;
  char *name;
} svcs[] =
{
  {0x00, "Serviced"},
  {0x04, "UKCommand"},
  {0x06, "Error"},
  {0x07, "UKByte"},
  {0x08, "UKWord"},
  {0x09, "Help"},
  {0x0b, "ReleaseFIQ"},
  {0x0c, "ClaimFIQ"},
  {0x11, "Memory"},
  {0x12, "StartUpFS"},
  {0x27, "Reset"},
  {0x28, "UKConfig"},
  {0x29, "UKStatus"},
  {0x2a, "NewApplication"},
  {0x40, "FSRedclare"},
  {0x41, "Print"},
  {0x42, "LookupFileType"},
  {0x43, "International"},
  {0x44, "Keyhandler"},
  {0x45, "PreReset"},
  {0x46, "ModeChange"},
  {0x47, "ClaimFIQinBackground"},
  {0x48, "ReAllocatePorts"},
  {0x49, "StartWimp"},
  {0x4a, "StartedWimp"},
  {0x4b, "StartFiler"},
  {0x4c, "StartedFiler"},
  {0x4d, "PreModeChange"},
  {0x4e, "MemoryMoved"},
  {0x4f, "FilerDying"},
  {0x50, "ModeExtension"},
  {0x51, "ModeTranslation"},
  {0x52, "MouseTrap"},
  {0x53, "WimpCloseDown"},
  {0x54, "Sound"},
  {0x55, "NetFS"},
  {0x56, "EconetDying"},
  {0x57, "WimpReportError"},
  {0x60, "ResourceFSStarting"},
  {-1,   "Something else"}
};
#endif

void fs_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
  MemCheck_RegisterMiscBlock_Ptr (r);

  #ifdef DEBUG
  {
    int i;

    for (i=0; svcs[i].svc >= 0; i++) if (svcs[i].svc == service_number) break;
    dprintf(("", "Service_%s (%#x)%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n", svcs[i].name,
          service_number, r->r[0],r->r[1],r->r[2],r->r[3],r->r[4],r->r[5],r->r[6],r->r[7],
          r->r[8],r->r[9]));
  }
  #endif

  /* dprintf (("", "service: %x\n", service_number)); */
  switch (service_number)
  {
    case Service_Memory:
      /* keep application workspace (r2 holds CAO pointer) */
      if (r->r[2] == (int) Image__RO_Base) r->r[1] = 0;
      break;

    case Service_StartFiler:
      /* We use StartFiler/StartedFiler *not* StartWimp/StartedWimp because we are
       * a desktop filer, not just any old task, and we want to wait for the RISC OS
       * Filer task to startup first.
       */
      dprintf (("", "Service_StartFiler task %d\n", taskhandle));
      if (taskhandle == 0)
      {
        taskhandle = -1; 		/* attempting start flag */
        r->r[0] = (int) ("Desktop_OmniClient");
        r->r[1] = 0;
      }
      break;

    case Service_StartedFiler:
      dprintf (("", "Service_StartedFiler %d\n", taskhandle));
      if (taskhandle == -1) taskhandle = 0;
      break;

    case Service_Reset:
    case Service_ShutDownComplete:
      /* We have problems with soft-resets: If we've previously run on this
       * soft reset (RO3.1), then mark as never wanting to startup again.
       */
      if (!all_hasrun) taskhandle = 0;
        else taskhandle = -2;
      break;

    case Service_FilerDying:
      dprintf (("", "Service_FilerDying %d\n", taskhandle));
      removetask();
      break;

    case Service_FSRedeclare:
      FS_Declare(private_word);
      break;
  }

  MemCheck_UnRegisterMiscBlock (r);
}


/* User Command processor
 */
_kernel_oserror *fs_command(const char *arg_string, int argc, int cmd_no, void *private_word)
{
  int currentslot, nextslot, freepool;

  UNUSED (argc);
  UNUSED (private_word);

  /* Switch between the commands */
  switch (cmd_no)
  {
    case CMD_Desktop_OmniClient:			/* Desktop_<app_DIR> */
      dprintf (("", "Desktop_OmniClient called handle %d hasrun %d\n", taskhandle, all_hasrun));
      dprintf (("", "Desktop_OmniClient called args '%s'\n", arg_string));
      if (taskhandle > 0)
      {
        if (argc > 1) MountCLI(arg_string, false);
        return(NULL);
      }
      if (!all_hasrun)
      {
        int active;
        bool start = false;

        /* Check we are really in the desktop.
         */
        dprintf (("", "OMNI running for first time - checking Desktop running\n"));

        /* Check number of active tasks */
        if (_swix (Wimp_ReadSysInfo, _IN (0) | _OUT (0), 0, &active) == NULL)
        {
          /* Then check command/desktop state */
          if (active > 0 && _swix (Wimp_ReadSysInfo, _IN (0) | _OUT (0), 3, &active) == NULL)
          {
            if (active == 1)
            {
              start = true;
            }
          }
        }
        if (!start)
        {
          /* Preserve command line string, because we'll start later */
          if (argc > 1) MountCLI(arg_string, false);
          return(NULL);
        }

        dprintf (("", "OMNI running for first time - calling Desktop_OmniClient\n"));
        currentslot = 32*1024;
        nextslot = -1;
        Desk_Wimp_SlotSize(&currentslot, &nextslot, &freepool);
        return (_swix (OS_Module, _INR (0, 2), OSModule_Enter, app_DIR"Client", arg_string));
      }
      else
      {
        dprintf (("", "OMNI running for nth time\n"));
        return(MakeError(err_RESTART));
      }
      break;

    case CMD_OmniMount:			/* OmniMount */
      MountCLI(arg_string, false);
      return(NULL);
      break;

    case CMD_OmniLoadMounts:			/* OmniLoadMounts */
      if (MountLoadFile(arg_string)) return(NULL);
      return(MakeError(err_BADMOUNTS));
      break;

    case CMD_OmniPrint:			/* OmniPrint */
      return (_swix (OS_FSControl, _INR (0, 1), OS_FSControl_SelectFilingSystem, fsname));
      break;

    default:
      return(NULL);
  }
}


/* SWI omni_base+0 "Omni_EnumerateMounts"
 *	On entry, R0 = 0, for all client types
 *	             = client_id, for a single client
 *                R1 = 0, for servers/mounts
 *                   = 1, for active mount connections
 *                   = 2, for printers
 *	All registers preserved on exit
 *
 *	This SWI is used by clients to request that the filer re-enumerates
 *	all the mounts for a given client_id [!=0] or for all registered
 *	client_id's [=0].
 *	This would be used, for example, when the client knows that the
 *	state of the active mounts [R1 = 1] has changed. eg, a
 *	command line *Dismount has been performed.
 *      If [R1 = 0], then the client knows that the list of servers and/or
 *      mounts exported by those servers has changed. eg, a periodic
 *      broadcast has noted that a new server has appeared.
 *      If [R1 = 2], then the client knows that the list of printers has
 *      changed.
 */
static _kernel_oserror *EnumerateMounts(_kernel_swi_regs *r)
{
  dprintf (("", "EnumerateMounts: %x %x\n", r->r[0], r->r[1]));
  /* If task isn't running, then we shouldn't do anything */
  if ((taskhandle <= 0) || (r->r[1] > 2)) return(NULL);
  if (r->r[1] == 0) pollword |= pollword_ENUMERATENET;
  if (r->r[1] == 1) pollword |= pollword_ENUMERATE;
  if (r->r[1] == 2) pollword |= pollword_ENUMERATEPRINT;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  return(NULL);
}


/* SWI omni_base+1 "Omni_RegisterClient"
 *	On entry, R0 = client_id, (SWI xxxx_OmniOp)
 *	          R1 = client flags word;
 *	               	      bit 0 = 1, Client supports network filing system
 *	                            = 0, No filing system support
 *	               	      bit 1 = 1, UserID string required
 *	               	      bit 2 = 1, Password string required
 *	               	      bit 3 = 1, Mount path string required
 *	               	      bit 4 = 1, Authentication server string
 *               	      bit 5 = 1, Mount name *not* required
 *	               	      bit 6 = 1, Special network authenticator
 *	           	      bit 7 = *reserved* zero
 *	               	      bit 8 = 1, Client supports network printers
 *	                            = 0, No printing support
 *	               	      bit 9 = 1, Password string required
 *	              	     bit 10 = 1, Needs file length before print job starts
 *	         	bits 11..15 = *reserved* zero
 *	         	bits 16..23 = ASCII extension character, or 0 for none
 *	               	bits 24..31 = *reserved* zero
 *	          R2 = sprite name ptr
 *	          R3 = client name ptr
 *	          R4 = client description ptr
 *	          R5 = site_id word (See document [Site_SpecN] for details)
 *	          R6 = filing system name ptr
 *	On exit,  R0 = 0, if successful
 *	             = error block (V set), on error
 *	All other registers preserved on exit
 *
 *      This SWI is used when a client module is (re)started to register
 *      itself with the Omni filer, and pass to the filer the facilities
 *      that it provides via the flags word.
 *      An error is returned if registration fails for whatever reason.
 *
 *      Revisions of this document prior to 0.996 stated that the correct
 *      behaviour was to register with This SWI only once. However, this has
 *      now changed so that protocol modules should attempt to (re)register
 *      when they startup and whenever they recieve Service_OmniAction. If
 *      the protocol is already registered, no error is returned.
 *      An error is returned if registration fails for whatever reason.
 *
 * 	The flags word (R1) lets the filer know which connect fields
 * 	are *never* required by this client. Some clients can further
 * 	reduce the number of fields required at a later time (see
 * 	OmniOp 7). eg, LAN Manager. The flags word can also register a
 * 	single ASCII character (eg, '.' or '/') which is used to
 * 	separate filename and file extension in the filing system. This
 * 	separator is used by the Omni_Convert SWI calls.
 *
 *	Bit 5 of the flags word is set for filing systems (typically those
 *	written before OmniClient) that have no concept of a user-supplied
 *	mount name, separate from the actual server name. When this bit is
 *	set, users will not be prompted for a mount name - it will be set
 *	to the mount path string (if it is set as required and is of non-zero
 *	length), or failing that the server name string. Note that when
 *	returning the mount path string (eg, OmniOp,9) protocol modules
 *	should return the appropriate string to allow Free operations, etc.
 *	This is the string that will appear under the iconbar, and if bit
 *	5 is set in the flags, the string will most likely either be
 *	the real server name, or the mount path. Hopefully most protocol
 *	module authors will never be required to understand this paragraph ;-)
 *
 *	Bit 6 of the flags word is set for protocols that require a network
 *	authentication action before servers can be located (eg, Acorn Access+)
 *	The expected use is for the protocol module to provide a 'dummy'
 *	network server, which the user 'mounts' with their user name/password.
 *	The mount operation is passed onto the protocol module as normal, but
 *	because there is no real connection, the mount should not be returned
 *	via enumerate active mounts calls, and no icon will appear on the
 *	iconbar. The protocol module can then perform its network
 *	authentication and enumerate those new servers that it can access.
 *
 * 	The sprite name ptr (R2) is a pointer to a null-terminated
 * 	sprite name, which must exist in the Wimp sprite pool as
 * 	'sprite', along with the small version 'sprite' postfix 's'. The
 * 	unique name for the client sprites (suggest the ASCII hex of
 * 	the xxxx_MiscOp SWI number) must be no more than 6 characters
 * 	long. Static string. If normal and small size versions of these
 * 	sprites exist with postfix '_22' then these hi-resolution sprites
 * 	will be used in square pixel modes.
 *
 *	The client name ptr (R3) is a pointer to a null-terminated text
 *	string, which should be a short format description of the client.
 *	eg, 'Berkeley NFS'. It should be no more than 24 characters long.
 *	This string is used in filer menus and title bars. Static string.
 *
 *	The client description ptr (R4) is a pointer to a null-terminated
 *	text string of the form '<desc>|J<author>|J<version>'. ie,
 *	3 lines of text (each line no longer than 32 chars), separated
 *	by ASCII 0x0a, and the whole string terminated by a null (0x00).
 *	This string is used in a filer 'client info' window. Static string.
 *
 * 	The site_id word (R5) (See document [Site_SpecN] for details)
 * 	should be 0 if the client module provides its own site-license
 * 	enforcement mechanism, or has no upper limit on the number of
 * 	users.
 *
 *	The filing system name ptr (R6) is the textual name of the filing
 *	system used by this protocol. eg, 'NetFS'.
 *
 *      Errors returned include:
 *      err_base+0	"Protocol is already registered"
 *	err_base+1	"Bad protocol identifier value"
 *	err_base+2	"No free memory for protocol registration"
 */
static _kernel_oserror *RegisterClient(_kernel_swi_regs *r)
{
  client_record *cr;

  MemCheck_RegisterMiscBlock_String ((char *) r->r[2]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[3]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[4]);
  MemCheck_RegisterMiscBlock_String ((char *) r->r[6]);
  cr = ClientCreate(r);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[2]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[3]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[4]);
  MemCheck_UnRegisterMiscBlock ((char *) r->r[6]);
  dprintf (("", "RegisterClient:\n"));
  if (cr != NULL)
  {
    pollword |= pollword_REGISTER;
    if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
      else pollword_r0 = r->r[0];
    returnOK()
  } else return((_kernel_oserror *) r->r[0]);
}


/* SWI omni_base+2 "Omni_DeregisterClient"
 *	On entry, R0 = client_id
 *      On exit,  R0 = 0, if deregistration successful
 *                   = not 0, if deregistration failed (error ptr)
 *	All other registers preserved on exit
 *
 *      This SWI is the companion call to SWI Omni_RegisterClient, and
 *      releases the client from the Omni filer.
 */
static _kernel_oserror *DeregisterClient(_kernel_swi_regs *r)
{
  client_record *cr = ClientFind(r->r[0], NULL, -1, NULL);
  dprintf (("", "DeregisterClient:\n"));
  if (cr == NULL) return(MakeError(err_NOTREGISTERED));
  ClientDelete(cr);
  pollword |= pollword_DEREGISTER;
  /* Force to enumerate for active mounts that may have disappeared */
  pollword |= pollword_ENUMERATE;
  if ((pollword_r0 != -1) && (pollword_r0 != r->r[0])) pollword_r0 = 0;
    else pollword_r0 = r->r[0];
  returnOK();
}


/* SWI omni_base+3 "Omni_MessageLookup"
 *  	On entry, R0 = message_id, (see table)
 *	          R1 = parameter string (if required)
 *      On exit,  R0 = error_blk, pointer to error block;
 *                       +0 = error number
 *                       $4 = null-terminated text string
 *	All other registers preserved on exit
 *
 *	This SWI provides for a shared set of common error/message
 *	blocks which can be used by client modules, irrespective of
 *	whether they are register with Omni filer.
 *	The text messages returned may be internationalised.
 *	NOTE do not rely on the maximum OmniClient(tm) error message
 *	being 16 - this list is subject to change and expansion.
 *	The filer does not guarantee to store error blocks statically.
 *	If you need the error block again, call This SWI.
 */
static _kernel_oserror *MessageLookup(_kernel_swi_regs *r)
{
  dprintf (("", "MessageLookup: %x %x\n", r->r[0], r->r[1]));
  return(OmniError(r->r[0], (char *) r->r[1]));
}


/* SWI omni_base+4 "Omni_ConvertClientToAcorn"
 *	On entry, R0 = client_id
 *		  R1 = ptr to client-format filename (including extension)
 *		  R2 = ptr to buffer for Acorn-format filename
 *		  R3 = ptr to flags string
 *	On exit,  R0 = Acorn-filetype, or -1 if not applicable
 *	All other registers preserved on exit
 *
 *	This SWI performs client -> RISC OS filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertClientToAcorn(_kernel_swi_regs *r)
{
  client_record *cr = NULL;

  dprintf (("", "ConvertClientToAcorn:\n"));
  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  r->r[0] = FileType_ConvertToType(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3]);
  return(NULL);
}


/* SWI omni_base+5 "Omni_ConvertAcornToClient"
 *	On entry, R0 = client_id
 *		  R1 = ptr to acorn-format filename
 *		  R2 = ptr to buffer for client-format filename
 *		       (including extension)
 *		  R3 = flags string
 *	          R4 = Acorn-filetype, or -1 if not typed
 *	All registers preserved on exit
 *
 *	This SWI performs RISC OS -> client filename & file extension
 *	translations by using a user-configurable mappings file. The format
 *	of this file and the flags R3 parameter are described in another
 *	document. [File_SpecN]
 *	Note that this mapping SWI deals with mappings for multiple
 *	client types (not just DOS 8+3 format, for example), hence the need
 *	to pass in the calling client_id in R0.
 */
static _kernel_oserror *ConvertAcornToClient(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  dprintf (("", "ConvertAcornToClient:\n"));

  if ((cr = ClientFind(r->r[0], NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  FileType_ConvertToExtension(cr->client_id, (char *) r->r[1], (char *) r->r[2],
    (char *) r->r[3], r->r[4]);
  return(NULL);
}


/* SWI omni_base+6 "Omni_ConvertTime"
 *	On entry, R0 = time formats;
 *		       bits 0..3 = source format
 *		       bits 4..7 = destination format;
 *		         0 = RISC OS, 5 byte, csec from 1st Jan 1900
 *		         1 = UNIX, 4 byte, sec from 1st Jan 1970
 *		         2 = DOS, 4 byte, sec from 1st Jan 1980
 *		         3 = Mac, 4 byte, signed sec from 00:00 1st Jan 2000
 *	         	 4 = Generic, 28 bytes (see below)
 *		        >4 = *reserved*
 *		       bits 8..31 = *reserved* zero
 *		  R1 = *pointer* to source time block
 *		  R2 = *pointer* to destination time buffer
 *	All registers preserved on exit
 *
 *	This SWI performs file timestamp conversions between any
 *	combination of supported system time formats.
 */
static _kernel_oserror *ConvertTime(_kernel_swi_regs *r)
{
  int src, dst;
  int time[9];

  dprintf (("", "ConvertTime:\n"));

  src = r->r[0] & 0x0F;
  dst = (r->r[0] & 0xF0) >> 4;
  dprintf (("", "ConvertTime: src %d\n", src));
  switch (src)
  {
    case 0:
      Time_FromAcorn((char *) r->r[1], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_FromSecs((int *) r->r[1], &time[0], src);
      break;
    case 4:
      memcpy((char *) &time[0], (char *) r->r[1], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  time[7] = -1;
  time[8] = -1;
  dprintf (("", "ConvertTime: dst %d\n", dst));
  switch (dst)
  {
    case 0:
      Time_ToAcorn((char *) r->r[2], &time[0]);
      break;
    case 1:
    case 2:
    case 3:
      Time_ToSecs((int *) r->r[2], &time[0], dst);
      break;
    case 4:
      memcpy((char *) r->r[2], (char *) &time[0], sizeof(int)*7);
      break;
    default:
      return(MakeError(err_BADTIME));
      break;
  }
  dprintf (("", "ConvertTime: exit\n"));
  return(NULL);
}


/* SWI omni_base+7 "Omni_Printers"
 *     	On entry, R0 = reason code;
 *                        0 = list protocols supporting printers
 *                        1 = list protocol (FS names) supporting printers
 *                        2 = protocol print flags for protocol in R1
 *                       16 = list printer servers for protocol in R1
 *                       17 = list printers for protocol/server in R1/R2
 *                       18 = list all printers for protocol in R1
 *                R1 = ptr to name of protocol (R0 = 2,16,17,18)
 *                R2 = ptr to name of server for printers (R0 = 17)
 *                R3 = ptr to buffer to fill with result string, or NULL
 *                R4 = size of buffer in bytes, or -1 if not known
 *      On exit,  R0 = protocol printing-support flags word (R0 = 2)
 *        	  R4 = size of buffer required for result string
 *	All other registers preserved on exit
 *
 *      This SWI provides information about printer support in OmniClient.
 *      Currently the reason codes (R0=0,1,16,17,18) return a result string
 *      into a user buffer supplied as R3. It is expected that this is
 *      done as a 2-stage process to ensure that a large-enough buffer
 *      exists for the result string.
 *
 *      The SWI is firstly called with R3=NULL,R4=-1, and the call returns
 *      with R4 containing the total size of buffer required (including
 *      terminator). The buffer is allocated by the caller, and then the
 *      SWI is called the second time, with the new R3/R4.
 *      If no items are available, then R4=0 is returned.
 *
 *      If R0 = 0, then the menu string contains the available protocol
 *      names that are registered as supporting printers. eg, "Acorn NFS,
 *      Acorn NetFS, ANT RemoteFS". R0 = 1 returns the same menu string,
 *      but with filing system names rather than full client descriptions.
 *      eg, "NFS, NetFS, RemoteFS".
 *
 *	If R0 = 2, then the protocol printing-support flags word for the
 *	protocol named in R1 is returned. The flags word is of the format;
 *
 *		bit 0 = 1, Client supports network printers
 *	              = 0, No printing support
 *	        bit 1 = 1, Password string required
 *	        bit 2 = 1, Needs file length before print job starts
 *	   bits 3..31 = *reserved* zero
 *
 *      If R0 = 16, then the menu string contains the servers exported
 *      by the protocol named in R1. eg, "laser.net, print.cl".
 *
 *      If R0 = 17, then the menu string contains the printers exported
 *      by the protocol named in R1, available as printers from the server
 *      named in R2. eg, "LibraryDM, Laser 600".
 *
 *      If R0 = 18, then the menu string contains all the printers exported
 *      by the protocol named in R1. eg, "NetLaser, LibraryDM, Laser 600".
 *      This reason code lists all the printers available, irrespective of
 *      which network server they are connected to.
 */
static _kernel_oserror *Printers(_kernel_swi_regs *r)
{
  _kernel_oserror *err = NULL;

  dprintf (("", "Printers: %x\n", r->r[0]));
  switch (r->r[0])
  {
    case 0:
    case 1:
      /* List protocols */
      err = PrintListProtocols(r);
      break;
    case 2:
      /* Protocol flags */
      err = PrintFlag(r);
      break;
    case 16:
      /* List print servers */
      err = PrintListServers(r);
      break;
    case 17:
    case 18:
      /* List printers */
      err = PrintListPrinters(r);
      break;
    default:
      err = MakeError(err_BADREASON);
      break;
  }
  return(err);
}


/* SWI omni_base+8 "Omni_CreateJob"
 * 	On entry, R0 = ptr to protocol name
 * 	          R1 = ptr to server name
 * 	          R2 = ptr to printer name
 * 	          R3 = ptr to user name, or NULL
 *	          R4 = ptr to password string, or NULL
 *                R5 = ptr to options string, or NULL
 *                R6 = size of print job (bytes), or 0 if not known
 *      On exit,  R0 = print_id of new job, if successful
 *                   = error block (V set), on error
 * 	All other registers preserved on exit
 *
 *      Submit a new job for network printing. Returns a unique 'print_id'
 *      word, or a pointer to an error block.
 *
 *      The protocol name (R0) is the name as provided by SWI Omni_Printers
 *      (and registered as the 'client name'). eg, "Sun NFS". The user name,
 *      password and options string are optional, and may be NULL pointers.
 *
 *      Some printing protocols require that the total size of the job is
 *      known before printing starts. If this is the case, they should be
 *      registered with OmniClient as requiring this. When a client
 *      program calls SWI Omni_PrinterInfo, reason code 2, it can determine
 *      whether a password field is required for this protocol, and whether
 *      the total size of the print job is required.
 */
static _kernel_oserror *CreateJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;

  dprintf (("", "CreateJob:\n"));
  if ((pr = PrintCreate(r)) == NULL) return((_kernel_oserror *) r->r[0]);
  r->r[0] = pr->print_id;
  return(NULL);
}


/* SWI omni_base+9 "Omni_SendJob"
 * 	On entry, R0 = print_id
 * 		  R1 = ptr to data block to send
 * 		  R2 = size of data block to send
 * 	On exit,  R2 = number of bytes not sent, or 0 for all done
 * 	All other registers preserved on exit
 *
 *      Send a block of data down network printer stream for a given active
 *      print_id word.
 */
static _kernel_oserror *SendJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "SendJob:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = _swix (pr->client_id, _INR (0, 3) | _OUT (3),
               11, pr->pjob_id, r->r[1], r->r[2],
               &r->r[2]);
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+10 "Omni_EndJob"
 * 	On entry, R0 = print_id
 * 	All registers preserved on exit
 *
 *      End a specified print job normally (ie, all data transmitted).
 */
static _kernel_oserror *EndJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "EndJob:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));
  /* Make call onto client */
  err = _swix(pr->client_id, _INR (0, 1), 12, pr->pjob_id);
  /* Mark as complete */
  if (!err)
  {
    pr->status = (print_STATUS | print_COMPLETE);
    pr->handle = -1;
    returnOK();
  }
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+11 "Omni_AbortJob"
 * 	On entry, R0 = print_id, or
 * 		     = 0, to abort all jobs
 * 	All registers preserved on exit
 *
 *      Abort a specified print job, or all current jobs.
 */
static _kernel_oserror *AbortJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "AbortJob:\n"));
  if (r->r[0] == 0)
  {
    /* Abort all print jobs */
    cr = (client_record *) client_anchor.next;
    while (cr != NULL)
    {
      if (PrintFind(-1, -1, cr->client_id, -1) != NULL)
      {
        /* Don't stop if an error occurs, but remember the first one */
        _kernel_oserror *temp_err = _swix(cr->client_id, _INR (0, 1), 13, 0);
        if (temp_err != NULL && err == NULL)
        {
          err = temp_err;
        }
      }
      cr = (client_record *) cr->header.next;
    }
    /* Free print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));
    /* Make call onto client */
    err = _swix(pr->client_id, _INR (0, 1), 13, pr->pjob_id);
    /* Delete from list */
    if (!err)
    {
      pr->status = (print_STATUS | print_ERROR);
      pr->handle = -1;
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+12 "Omni_JobStatus"
 * 	On entry, R0 = print_id
 * 	On exit,  R1 = local job status word (see below)
 * 		  R2 = local job # bytes sent
 * 		  R3 = error/status block ptr, or 0
 * 		  R4 = remote job status word (see below)
 * 		  R5 = remote job # bytes printed
 * 		  R6 = error/status block ptr, or 0
 * 	All other registers preserved on exit
 *
 *      Get information on a specified print job. The status
 *      word (R1, R3) is currently defined as;
 *
 *      	bit 0 = 0, no status available
 *         	      = 1, status information available
 *          bits 1..3 = 0, pending connection
 *         	      = 1, connection made, waiting for initial data
 *                    = 2, sending bytes
 *                    = 3, transfer complete
 *                    = 4, job marked as temporary error
 *     	              = 5, job marked as terminal error
 *                    =>5, *reserved*
 * 	   bits 4..31 = *reserved* zero
 */
static _kernel_oserror *JobStatus(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;

  dprintf (("", "JobStatus:\n"));
  if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
  if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
    return(MakeError(err_NOTREGISTERED));

  /* Make call onto client */
  err = _swix (pr->client_id, _INR (0, 1) | _OUTR (1, 6),
               14,pr->pjob_id,
               &r->r[1], &r->r[2], &r->r[3], &r->r[4], &r->r[5], &r->r[6]);

  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+13 "Omni_ClearJob"
 *	On entry, R0 = print_id, or
 *		     = 0, to clear all inactive jobs
 *	All registers preserved on exit
 *
 *      Clear a specified print job, or all current inactive jobs. It is
 *      important to make this call once the client program has finished
 *      with the print job, and will no longer be calling Omni_JobStatus.
 *      eg, once it has marked the job as having been completed or having a
 *      terminal error. The status of a print job will reside in memory
 *      forever if this call is not made.
 */
static _kernel_oserror *ClearJob(_kernel_swi_regs *r)
{
  print_record *pr = NULL;
  _kernel_oserror *err = NULL;
  client_record *cr = NULL;
  int lstatus, rstatus;

  dprintf (("", "ClearJob:\n"));
  if (r->r[0] == 0)
  {
    /* Free inactive print job records */
    pr = (print_record *) print_anchor.next;
    while (pr != NULL)
    {
      print_record *pr_tmp = (print_record *) pr->header.next;

      /* Call OmniOp, 14 (Get Print Job Info) */
      err = _swix (pr->client_id, _INR (0, 1) | _OUT (1) | _OUT (4),
                   14, pr->pjob_id,
                   &lstatus, &rstatus);
      if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
      {
        /* Make call onto client */
        err = _swix (pr->client_id, _INR (0, 1), 15, pr->pjob_id);
        if (!err) PrintClear(pr);
      }
      pr = pr_tmp;
    }
  }
  else
  {
    /* Abort a single print job */
    if ((pr = PrintFind(r->r[0], -1, -1, -1)) == NULL) return(MakeError(err_BADPRINT));
    if ((cr = ClientFind(pr->client_id, NULL, -1, NULL)) == NULL)
      return(MakeError(err_NOTREGISTERED));

    /* Call OmniOp, 14 (Get Print Job Info) */
    err = _swix (pr->client_id, _INR (0, 1) | _OUT(1) | _OUT (4),
                 14, pr->pjob_id,
                 &lstatus, &rstatus);
    dprintf (("", "ClearJob: jobinfo = %x\n", (int) err));
    dprintf (("", "ClearJob: %x\n", lstatus));
    dprintf (("", "ClearJob: %x %x\n", pflagSET(lstatus, print_COMPLETE),
      pflagSET(lstatus, print_ERROR)));
    if ((!err) && ((pflagSET(lstatus, print_COMPLETE)) || (pflagSET(lstatus, print_ERROR))))
    {
      /* Make call onto client */
      err = _swix (pr->client_id, _INR (0, 1), 15, pr->pjob_id);
      dprintf (("", "ClearJob: clearclient = %x\n", (int) err));
      if (!err) PrintClear(pr);
    }
  }
  if (!err) returnOK();
  r->r[0] = (int) err;
  return(err);
}


/* SWI omni_base+14 "Omni_PrinterInfo"
 *      On entry, R0 = ptr to name of protocol for printer
 *                R1 = ptr to name of server
 *                R2 = ptr to name of printer
 *      On exit,  R0 = flags word, or 0 if not available
 *	All other registers preserved on exit
 *
 *      This SWI provides information about the facilities provided by a
 *      named printer. If information is not available then 0 is returned,
 *      or if the printer name is not valid, an error block ptr is returned.
 *
 *      The flags word,is a set of bit fields that describe the printer type
 *  	and facilities provided (see PRM 3-595);
 *
 *             	bit 0 = 1, Facilities information available,
 *                    = 0, information not available
 *          bits 1..7 = *reserved* zero
 *	        bit 8 = 1, Raw ASCII text
 *              bit 9 = 1, Postscript compatible
 *             bit 10 = 1, Epson FX80 or compatible
 *             bit 11 = 1, HP Laserjet or compatible
 *             bit 12 = 1, Integrex Colourjet
 *             bit 13 = 1, FAX modem
 *             bit 14 = 1, Direct drive laser printer
 *             bit 15 = 1, Caspel graphics language
 *             bit 16 = 1, PDumper interface
 *             bit 17 = 1, TeX 'DVI' files
 *             bit 18 = 1, Epson JX/Star LC10, HP Paintjet
 *        bits 19..31 = *reserved* zero
 */
static _kernel_oserror *PrinterInfo(_kernel_swi_regs *r)
{
  client_record *cr = NULL;
  plist_record *pr = NULL;

  dprintf (("", "PrinterInfo:\n"));
  cr = ClientFind(-1, (char *) r->r[0], -1, NULL);
  if (!cr) cr = ClientFind(-1, NULL, -1, (char *) r->r[0]);
  if (!cr) return(MakeError(err_NOTREGISTERED));
  /* Locate named server/printer */
  pr = PrinterFind(cr->client_id, (char *) r->r[1], (char *) r->r[2]);
  if (pr) r->r[0] = pr->flags;
    else r->r[0] = 0;
  return(NULL);
}


/* SWI omni_base+15 "Omni_EnumerateJobs"
 *	On entry, R1 = ptr to buffer for job list (word aligned)
 *	          R2 = size of buffer (words * 4)
 *	          R3 = 0, start enumerating jobs
 *	               not 0, continue enumerating jobs
 *	On exit,  R1 = ptr to next free byte in buffer, word aligned
 *	          R3 = 0, operation complete
 *	               not 0, buffer full, call again with this R3
 *	All other registers preserved on exit
 *
 *	This SWI enumerates all printer jobs that OmniClient knows about,
 *	returning a list of their print_id values in consecutive words of
 *	the supplied buffer, until the buffer is full or the enumeration is
 *	complete. This allows printer managment applications to gain access
 *	to print_id handles of jobs even if they were started using the
 *	OmniPrint filing system, or by another application using SWI
 *	Omni_CreateJob.
 *
 *	If R3 is not 0 on exit, then the enumeration is not complete
 *	(buffer full), and the reason code is called again with the
 *	new R3 value. This process continues until the enumeration
 *	is complete.
 */
static _kernel_oserror *EnumerateJobs(_kernel_swi_regs *r)
{
  dprintf (("", "EnumerateJobs:\n"));
  r->r[3] = (int) PrintListJobs((print_record *) r->r[3], (int **) &r->r[1], r->r[2]);
  return(NULL);
}


/* SWI omni_base+16 "Omni_NameLookup"
 *      On entry, R0 = reason code;
 *                      0 = get internet host by name
 *                      1 = get internet service by name/protocol
 *                     >1 = *reserved*
 *                  R1 = ptr to name of host (R0=0) or service (R0=1)
 *                  R2 = ptr to name of protocol (R0=1)
 *      On exit,  R0 = ptr to hostent (R0=0) or servent (R0=1) struct's
 *	All other registers preserved on exit
 *
 *	This SWI exists as an interface to the Internet name lookup
 *	facilities, for those protocol modules that do not wish to use the
 *	Acorn-provided 'inetlib' library, either for space reasons or
 *	because they cannot easily link in the library (eg, the protocol
 *	module is written entirely in assembler).
 *
 *	Parameters and return results are exactly as the Berkeley standard
 *	gethostbyname(char *name) and getservbyname(char *name, char *proto)
 *	functions.
 */
static _kernel_oserror *NameLookup(_kernel_swi_regs *r)
{
  dprintf (("", "NameLookup:\n"));
  switch (r->r[0])
  {
    case 0:
      r->r[0] = (int) gethostbyname((char *) r->r[1]);
      break;
    case 1:
      r->r[0] = (int) getservbyname((char *) r->r[1], (char *) r->r[2]);
      break;
    default:
      r->r[0] = 0;
      break;
  }
  return(NULL);
}


/*  User SWI call handler.
 */
_kernel_oserror *fs_swi(int swi_no, _kernel_swi_regs *r, void *private_word)
{
  _kernel_oserror *  e = NULL;

  UNUSED (private_word);

  MemCheck_RegisterMiscBlock_Ptr (r);
  dprintf (("", "fs_swi: %d\n", swi_no));

  switch (swi_no)
  {
    case Omni_EnumerateMounts - Omni_00:
      e = EnumerateMounts(r);
      break;

    case Omni_RegisterClient - Omni_00:
      e = RegisterClient(r);
      break;

    case Omni_DeregisterClient - Omni_00:
      e = DeregisterClient(r);
      break;

    case Omni_MessageLookup - Omni_00:
      e = MessageLookup(r);
      break;

    case Omni_ConvertClientToAcorn - Omni_00:
      e = ConvertClientToAcorn(r);
      break;

    case Omni_ConvertAcornToClient - Omni_00:
      e = ConvertAcornToClient(r);
      break;

    case Omni_ConvertTime - Omni_00:
      e = ConvertTime(r);
      break;

    case Omni_Printers - Omni_00:
      e = Printers(r);
      break;

    case Omni_CreateJob - Omni_00:
      e = CreateJob(r);
      break;

    case Omni_SendJob - Omni_00:
      e = SendJob(r);
      break;

    case Omni_EndJob - Omni_00:
      e = EndJob(r);
      break;

    case Omni_AbortJob - Omni_00:
      e = AbortJob(r);
      break;

    case Omni_JobStatus - Omni_00:
      e = JobStatus(r);
      break;

    case Omni_ClearJob - Omni_00:
      e = ClearJob(r);
      break;

    case Omni_PrinterInfo - Omni_00:
      e = PrinterInfo(r);
      break;

    case Omni_EnumerateJobs - Omni_00:
      e = EnumerateJobs(r);
      break;

    case Omni_NameLookup - Omni_00:
      e = NameLookup(r);
      break;

    case Omni_TraceFile - Omni_00:
      /* 2000-03-04: BAL
       * Not sure what to do about this - investigate if protocol modules
       * actually use this.
       */
      #if 0
      #ifdef DEBUG
      r->r[0] = (int) omniout;
      #else
      r->r[0] = 0;
      #endif
      #endif

      r->r[0] = 0;
      break;

    default:
      e = error_BAD_SWI;
      break;
  }

  MemCheck_UnRegisterMiscBlock (r);

  /* Return with no error */
  return(e);
}
